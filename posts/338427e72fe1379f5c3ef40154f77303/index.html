<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IMX6ULL-uboot启动内核流程分析(4) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="IMX6ULL-uboot启动内核流程分析(4)" />
<meta property="og:description" content="uboot版本2016.03 bootz命令加载linux内核流程分析 bootz命令在启动内核的过程中会一直伴随一个全局变量images，images是一个bootm_headers_t形式的结构体，结构体的定义在文件/include/image.h中：
typedef struct bootm_headers { /* * Legacy os image header, if it is a multi component image * then boot_get_ramdisk() and get_fdt() will attempt to get * data from second and third component accordingly. */ image_header_t *legacy_hdr_os; /* image header pointer */ image_header_t legacy_hdr_os_copy; /* header copy */ ulong legacy_hdr_valid; #if defined(CONFIG_FIT) const char *fit_uname_cfg; /* configuration node unit name */ void *fit_hdr_os; /* os FIT image header */ const char *fit_uname_os; /* os subimage node unit name */ int fit_noffset_os; /* os subimage node offset */ void *fit_hdr_rd; /* init ramdisk FIT image header */ const char *fit_uname_rd; /* init ramdisk subimage node unit name */ int fit_noffset_rd; /* init ramdisk subimage node offset */ void *fit_hdr_fdt; /* FDT blob FIT image header */ const char *fit_uname_fdt; /* FDT blob subimage node unit name */ int fit_noffset_fdt;/* FDT blob subimage node offset */ void *fit_hdr_setup; /* x86 setup FIT image header */ const char *fit_uname_setup; /* x86 setup subimage node name */ int fit_noffset_setup;/* x86 setup subimage node offset */ #endif #ifndef USE_HOSTCC image_info_t os; /* os image info */ ulong ep; /* entry point of OS */ ulong rd_start, rd_end;/* ramdisk start/end */ char *ft_addr; /* flat dev tree address */ ulong ft_len; /* length of flat device tree */ ulong initrd_start; ulong initrd_end; ulong cmdline_start; ulong cmdline_end; bd_t *kbd; #endif int verify; /* getenv(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/338427e72fe1379f5c3ef40154f77303/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-02T23:05:53+08:00" />
<meta property="article:modified_time" content="2023-02-02T23:05:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">IMX6ULL-uboot启动内核流程分析(4)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h3 style="text-align:left;"><a class="kdocs-link" style="color:#0A6CFF;" href="https://so.csdn.net/so/search?q=uboot&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer"><span class="kdocs-bold" style="font-weight:bold;">uboot</span></a><span class="kdocs-bold" style="font-weight:bold;">版本2016.03</span></h3> 
 <h3 style="">bootz命令加载linux内核流程分析</h3> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">bootz命令在启动内核的过程中会一直伴随一个全局变量images，images是一个<span class="kdocs-color" style="color:#C21C13;">bootm_headers_t</span>形式的结构体，结构体的定义在文件/include/image.h中：</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">typedef struct bootm_headers {
    /*
     * Legacy os image header, if it is a multi component image
     * then boot_get_ramdisk() and get_fdt() will attempt to get
     * data from second and third component accordingly.
     */
    image_header_t    *legacy_hdr_os;        /* image header pointer */
    image_header_t    legacy_hdr_os_copy;    /* header copy */
    ulong        legacy_hdr_valid;

#if defined(CONFIG_FIT)
    const char    *fit_uname_cfg;    /* configuration node unit name */

    void        *fit_hdr_os;    /* os FIT image header */
    const char    *fit_uname_os;    /* os subimage node unit name */
    int        fit_noffset_os;    /* os subimage node offset */

    void        *fit_hdr_rd;    /* init ramdisk FIT image header */
    const char    *fit_uname_rd;    /* init ramdisk subimage node unit name */
    int        fit_noffset_rd;    /* init ramdisk subimage node offset */

    void        *fit_hdr_fdt;    /* FDT blob FIT image header */
    const char    *fit_uname_fdt;    /* FDT blob subimage node unit name */
    int        fit_noffset_fdt;/* FDT blob subimage node offset */

    void        *fit_hdr_setup;    /* x86 setup FIT image header */
    const char    *fit_uname_setup; /* x86 setup subimage node name */
    int        fit_noffset_setup;/* x86 setup subimage node offset */
#endif

#ifndef USE_HOSTCC
    image_info_t    os;        /* os image info */
    ulong        ep;        /* entry point of OS */

    ulong        rd_start, rd_end;/* ramdisk start/end */

    char        *ft_addr;    /* flat dev tree address */
    ulong        ft_len;        /* length of flat device tree */

    ulong        initrd_start;
    ulong        initrd_end;
    ulong        cmdline_start;
    ulong        cmdline_end;
    bd_t        *kbd;
#endif

    int        verify;        /* getenv("verify")[0] != 'n' */

#define    BOOTM_STATE_START    (0x00000001)
#define    BOOTM_STATE_FINDOS    (0x00000002)
#define    BOOTM_STATE_FINDOTHER    (0x00000004)
#define    BOOTM_STATE_LOADOS    (0x00000008)
#define    BOOTM_STATE_RAMDISK    (0x00000010)
#define    BOOTM_STATE_FDT        (0x00000020)
#define    BOOTM_STATE_OS_CMDLINE    (0x00000040)
#define    BOOTM_STATE_OS_BD_T    (0x00000080)
#define    BOOTM_STATE_OS_PREP    (0x00000100)
#define    BOOTM_STATE_OS_FAKE_GO    (0x00000200)    /* 'Almost' run the OS */
#define    BOOTM_STATE_OS_GO    (0x00000400)
    int        state;

#ifdef CONFIG_LMB
    struct lmb    lmb;        /* for memory mgmt */
#endif
} bootm_headers_t;</code></pre> 
 <p style="text-indent:1.4em;padding-left:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第32行，定义了一个<span class="kdocs-color" style="color:#C21C13;">image_info_t</span>类型的成员变量os，通过此变量描述系统的镜像信息。定义如下：</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">typedef struct image_info {
    ulong start, end; /* blob 开始和结束位置*/
    ulong image_start, image_len; /* 镜像起始地址(包括 blob)和长度 */
    ulong load; /* 系统镜像加载地址*/
    uint8_t comp, type, os; /* 镜像压缩、类型， OS 类型 */
    uint8_t arch; /* CPU 架构 */
} image_info_t;</code></pre> 
 <p style="text-indent:1.4em;padding-left:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第49~59行，宏定义用来描述uboot启动内核的不同阶段。</span></p> 
 <h4 style=""><span class="kdocs-bold" style="font-weight:bold;">do_bootz </span>函数</h4> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">bootz命令对应调用的函数就是do_bootz函数，函数定义在/cmd/bootm.c中，如下：</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int do_bootz(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
    int ret;

    /* Consume 'bootz' */
    argc--; argv++;

    if (bootz_start(cmdtp, flag, argc, argv, &amp;images))
        return 1;

    /*
     * We are doing the BOOTM_STATE_LOADOS state ourselves, so must
     * disable interrupts ourselves
     */
    bootm_disable_interrupts();

    images.os.os = IH_OS_LINUX;
    ret = do_bootm_states(cmdtp, flag, argc, argv,
                  BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |
                  BOOTM_STATE_OS_GO,
                  &amp;images, 1);

    return ret;
}</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第6行，相当于把命令传参的boot命令去掉。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第8行，调用了<span class="kdocs-color" style="color:#C21C13;">bootz_start</span>函数。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第15行，调用了<span class="kdocs-color" style="color:#C21C13;">bootm_disable_interrupts</span>函数，关闭了中断。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第17行，设置了要启动内核的类型为LINUX。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第18行，调用了<span class="kdocs-color" style="color:#C21C13;">do_bootm_states</span>函数执行boot的不同阶段。</span></p> 
 <h5 style="">bootz_start函数</h5> 
 <pre class="kdocs-cpp"><code class="language-cpp">/*
 * zImage booting support
 */
static int bootz_start(cmd_tbl_t *cmdtp, int flag, int argc,
            char * const argv[], bootm_headers_t *images)
{
    int ret;
    ulong zi_start, zi_end;

    ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START,
                  images, 1);

    /* Setup Linux kernel zImage entry point */
    if (!argc) {
        images-&gt;ep = load_addr;
        debug("*  kernel: default image load address = 0x%08lx\n",
                load_addr);
    } else {
        images-&gt;ep = simple_strtoul(argv[0], NULL, 16);
        debug("*  kernel: cmdline image address = 0x%08lx\n",
            images-&gt;ep);
    }

    ret = bootz_setup(images-&gt;ep, &amp;zi_start, &amp;zi_end);
    if (ret != 0)
        return 1;

    lmb_reserve(&amp;images-&gt;lmb, images-&gt;ep, zi_end - zi_start);

    /*
     * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not
     * have a header that provide this informaiton.
     */
    if (bootm_find_images(flag, argc, argv))
        return 1;

#ifdef CONFIG_SECURE_BOOT
    extern uint32_t authenticate_image(
            uint32_t ddr_start, uint32_t image_size);
    if (authenticate_image(images-&gt;ep, zi_end - zi_start) == 0) {
        printf("Authenticate zImage Fail, Please check\n");
        return 1;
    }
#endif
    return 0;
}</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">bootz_start函数的作用是完成对uboot启动zImage镜像文件的支持工作的。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第10行，调用<span class="kdocs-color" style="color:#C21C13;">do_bootm_states</span>函数完成执行<span class="kdocs-color" style="color:#C21C13;">BOOTM_STATE_START</span>阶段。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第18~22行，设置images的成员变量ep即系统镜像的入口地址，并打印出地址。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第24行，调用<span class="kdocs-color" style="color:#C21C13;">bootz_setup</span>函数，该函数较为简单，在该函数中获取了镜像文件的<span class="kdocs-color" style="color:#C21C13;">zimage_header</span>类型的文件头，并判断当前镜像文件是否为ARM的LINUX镜像。并将镜像文件的入口地址和结束地址分别保存到变量<span class="kdocs-color" style="color:#C21C13;">zi_start</span>和<span class="kdocs-color" style="color:#C21C13;">zi_end</span>中。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第34行，调用<span class="kdocs-color" style="color:#C21C13;">bootm_find_images</span>函数，设置了<span class="kdocs-color" style="color:#C21C13;">images-&gt;ftaddr</span>（设备树的起始地址）和<span class="kdocs-color" style="color:#C21C13;">images-&gt;ft_len</span>（设备树的长度）。</span></p> 
 <h5 style="text-indent:1.4em;"><span class="kdocs-color" style="color:#080F17;">do_bootm_states函数</span></h5> 
 <pre class="kdocs-cpp"><code class="language-cpp">int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
            int states, bootm_headers_t *images, int boot_progress)
{
    boot_os_fn *boot_fn;
    ulong iflag = 0;
    int ret = 0, need_boot_fn;

    images-&gt;state |= states;

    /*
     * Work through the states and see how far we get. We stop on
     * any error.
     */
    if (states &amp; BOOTM_STATE_START)
        ret = bootm_start(cmdtp, flag, argc, argv);


    /*****省略部分代码*****/


    /* From now on, we need the OS boot function */
    if (ret)
        return ret;
    boot_fn = bootm_os_get_boot_func(images-&gt;os.os);
    need_boot_fn = states &amp; (BOOTM_STATE_OS_CMDLINE |
            BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |
            BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);
    if (boot_fn == NULL &amp;&amp; need_boot_fn) {
        if (iflag)
            enable_interrupts();
        printf("ERROR: booting os '%s' (%d) is not supported\n",
               genimg_get_os_name(images-&gt;os.os), images-&gt;os.os);
        bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);
        return 1;
    }

    if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP))
        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);

#ifdef CONFIG_TRACE
    /* Pretend to run the OS, then run a user command */
    if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_FAKE_GO)) {
        char *cmd_list = getenv("fakegocmd");

        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,
                images, boot_fn);
        if (!ret &amp;&amp; cmd_list)
            ret = run_command_list(cmd_list, -1, flag);
    }
#endif

    /* Check for unsupported subcommand. */
    if (ret) {
        puts("subcommand not supported\n");
        return ret;
    }

    /* Now run the OS! We hope this doesn't return */
    if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))
        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,
                images, boot_fn);

    /* Deal with any fallout */
err:
    if (iflag)
        enable_interrupts();

    if (ret == BOOTM_ERR_UNIMPLEMENTED)
        bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);
    else if (ret == BOOTM_ERR_RESET)
        do_reset(cmdtp, flag, argc, argv);

    return ret;
}</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">do_bootm_states函数会跟根据参数states，实现uboot启动内核不同阶段的代码。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第14行处理了<span class="kdocs-color" style="color:#C21C13;">BOOTM_STATE_START</span>阶段。在该阶段调用了bootm_start函数，完成了<span class="kdocs-color" style="color:#C21C13;">images内存清空和images.verify成员变量设置</span>，并将images.state设置为<span class="kdocs-color" style="color:#C21C13;">BOOTM_STATE_START</span>。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第24行，通过函数bootm_os_get_boot_func查找系统的启动函数，参数images-&gt;os.os就是在do_bootz函数中设置的IH_OS_LINUX。至此<span class="kdocs-color" style="color:#C21C13;">boot_fn</span>这个函数指针指向的就是LINUX的启动函数do_bootm_linux。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第37行，调用do_bootm_linux函数处理BOOTM_STATE_OS_PREP状态，do_bootm_linux函数如下：</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int do_bootm_linux(int flag, int argc, char * const argv[],
           bootm_headers_t *images)
{
    /* No need for those on ARM */
    if (flag &amp; BOOTM_STATE_OS_BD_T || flag &amp; BOOTM_STATE_OS_CMDLINE)
        return -1;

    if (flag &amp; BOOTM_STATE_OS_PREP) {
        boot_prep_linux(images);
        return 0;
    }

    if (flag &amp; (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) {
        boot_jump_linux(images, flag);
        return 0;
    }

    boot_prep_linux(images);
    boot_jump_linux(images, flag);
    return 0;
}</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">在该函数中调用boot_prep_linux处理BOOTM_STATE_OS_PREP状态。在boot_prep_linux函数中主要处理uboot用于启动linux的环境变量bootargs。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第42行，是处理BOOTM_STATE_OS_FAKE_GO状态，由于没有定义宏因此不会执行。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第59行，是处理BOOTM_STATE_OS_GO状态，即开始启动内核，调用boot_selected_os函数-&gt;调用boot_fn(do_bootm_linux)函数-&gt;boot_jump_linux函数，函数定义如下：</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">static void boot_jump_linux(bootm_headers_t *images, int flag)
{
    /*省略64位代码*/

    unsigned long machid = gd-&gt;bd-&gt;bi_arch_number;
    char *s;
    void (*kernel_entry)(int zero, int arch, uint params);
    unsigned long r2;
    int fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO);

    kernel_entry = (void (*)(int, int, uint))images-&gt;ep;

    s = getenv("machid");
    if (s) {
        if (strict_strtoul(s, 16, &amp;machid) &lt; 0) {
            debug("strict_strtoul failed!\n");
            return;
        }
        printf("Using machid 0x%lx from environment\n", machid);
    }

    debug("## Transferring control to Linux (at address %08lx)" \
        "...\n", (ulong) kernel_entry);
    bootstage_mark(BOOTSTAGE_ID_RUN_OS);
    announce_and_cleanup(fake);

    if (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len)
        r2 = (unsigned long)images-&gt;ft_addr;
    else
        r2 = gd-&gt;bd-&gt;bi_boot_params;

    if (!fake) {
#ifdef CONFIG_ARMV7_NONSEC
        if (armv7_boot_nonsec()) {
            armv7_init_nonsec();
            secure_ram_addr(_do_nonsec_entry)(kernel_entry,
                              0, machid, r2);
        } else
#endif
            kernel_entry(0, machid, r2);
    }
#endif
}</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第5行，定义了变量machid，不采用设备树此变量uboot会传递给linux内核，内核会在机器ID表中查找是否支持该机器。如果采用设备树，该变量则无效。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第7行，定义了一个函数指针kernel_entry，该函数有3个参数，第一个参数为0，第二个参数是机器ID，第三个参数为ATAGS 或者设备树(DTB)首地址。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第11行，获取kernel_entry函数，该函数为linux内核定义，是linux镜像的第一行代码。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第27行，如果使用设备树将r2寄存器的值赋值为设备树首地址。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">第30行，不适用设备树，r2就是bootargs参数首地址。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:15pt;">最后第40行，调用kernel_entry函数启动linux内核。</span></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:15pt;">至此uboot所有工作都已经结束！</span></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e9e049e67d8fa852ba842b11ecb8fb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">macOS下使用vscode&#43;xdebug调试php</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c4d2a7793cd65d8a6669a99987978b11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">中间件之Pulsar的概念与特性</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>