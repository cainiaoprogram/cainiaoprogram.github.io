<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>核密度函数加权直方图的计算 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="核密度函数加权直方图的计算" />
<meta property="og:description" content="在本篇博客中，我将与众位看官分享我自己写的关于用核密度函数加权的直方图的计算
欢饮批评指正！！！
核密度函数加权直方图在基于Mean shift的跟踪算法中经常用到。请客官查看我的博客：
样本均值漂移的原理 Mean Shift 原理
常用的核密度函数有
EpanechnikovKernal：
在Mean Shift的迭代过程中用的是上述两个函数的截面函数：
下面是这两个函数(4)和(5)的程序实现：
/*核函数：Epanechnikov Kernal
center: 核函数中心坐标
xy : 在核区域内的某一个点
hx,hy : 核区域在x方向和y方向的半径（或叫 带宽）
*/
static float EpanechnikovKernalFunc(Point2f&amp; center,Point2f&amp; xy,int hx,int hy)
{
//计算点xy到中心center的归一化距离
float distx = (xy.x - center.x)/hx;
float disty = (xy.y - center.y)/hy;
float dist_square = distx*distx &#43; disty*disty;//距离平方
float result = 0.f; //函数要返回的结果
//核区域就是以hx和hy为边长的矩形的内接圆，在该内接圆中的点
//的函数值都不为0，若距离超过核区域，则返回0，
//距离center越近，函数值越大
if(dist_square&gt;=1) {
result = 0.f; }
else
{
//float Cd = CV_PI; //单位圆面积 pi*R^2 ,R==1" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/43ca55dc70834cb481aa93bc3c940d17/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-05T17:11:34+08:00" />
<meta property="article:modified_time" content="2021-01-05T17:11:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">核密度函数加权直方图的计算</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在本篇博客中，我将与众位看官分享我自己写的关于用核密度函数加权的直方图的计算</p> 
<p>欢饮批评指正！！！</p> 
<p>核密度函数加权直方图在基于Mean shift的跟踪算法中经常用到。请客官查看我的博客：</p> 
<p>样本均值漂移的原理 <a href="http://blog.csdn.net/zhjm07054115/article/details/24453947">Mean Shift 原理</a></p> 
<p>常用的核密度函数有</p> 
<p>EpanechnikovKernal：</p> 
<p> </p> 
<p><img alt="" src="https://images2.imgbox.com/02/7a/xxlNl2TP_o.jpg"></p> 
<p> </p> 
<p> </p> 
<p>在Mean Shift的迭代过程中用的是上述两个函数的截面函数：</p> 
<p><img alt="" src="https://images2.imgbox.com/f8/1a/8HtJNnoT_o.jpg"></p> 
<p>下面是这两个函数(4)和(5)的程序实现：</p> 
<p> </p> 
<pre> </pre> 
<ol><li> </li><li> <p><code>/*核函数：Epanechnikov Kernal</code></p> </li><li> <p><code>center: 核函数中心坐标</code></p> </li><li> <p><code>xy : 在核区域内的某一个点</code></p> </li><li> <p><code>hx,hy : 核区域在x方向和y方向的半径（或叫 带宽）</code></p> </li><li> <p><code>*/</code></p> </li><li> <p><code>static float EpanechnikovKernalFunc(Point2f&amp; center,Point2f&amp; xy,int hx,int hy)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>//计算点xy到中心center的归一化距离</code></p> </li><li> <p><code>float distx = (xy.x - center.x)/hx;</code></p> </li><li> <p><code>float disty = (xy.y - center.y)/hy;</code></p> </li><li> <p><code>float dist_square = distx*distx + disty*disty;//距离平方</code></p> </li><li> </li><li> <p><code>float result = 0.f; //函数要返回的结果</code></p> </li><li> </li><li> <p><code>//核区域就是以hx和hy为边长的矩形的内接圆，在该内接圆中的点</code></p> </li><li> <p><code>//的函数值都不为0，若距离超过核区域，则返回0，</code></p> </li><li> <p><code>//距离center越近，函数值越大</code></p> </li><li> <p><code>if(dist_square&gt;=1) </code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>result = 0.f; </code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>else</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>//float Cd = CV_PI; //单位圆面积 pi*R^2 ,R==1</code></p> </li><li> <p><code>float Cd_inv = 0.318309886f; // == 1.0/Cd;单位圆的面积的倒数</code></p> </li><li> <p><code>int dimension = 2; //坐标的维数</code></p> </li><li> <p><code>//Epanechnikov核函数的截面断层函数：profile</code></p> </li><li> <p><code>result = 0.5f*Cd_inv*( dimension + 2 )*( 1 - dist_square );</code></p> </li><li> <p><code>}</code></p> </li><li> </li><li> <p><code>return result;</code></p> </li><li> <p><code>}</code></p> </li><li> </li><li> <p><code>/*核函数：Gaussian Kernal</code></p> </li><li> <p><code>center: 核函数中心坐标</code></p> </li><li> <p><code>xy : 在核区域内的某一个点</code></p> </li><li> <p><code>hx,hy : 核区域在x方向和y方向的半径（或叫 带宽）</code></p> </li><li> <p><code>*/</code></p> </li><li> <p><code>static float GaussianKernalFunc(Point2f&amp; center,Point2f&amp; xy,int hx,int hy)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>//计算点xy到中心center的归一化距离</code></p> </li><li> <p><code>float distx = (xy.x - center.x)/hx;</code></p> </li><li> <p><code>float disty = (xy.y - center.y)/hy;</code></p> </li><li> <p><code>float dist_square = distx*distx + disty*disty;//距离平方</code></p> </li><li> </li><li> <p><code>float result = 0.f; //函数要返回的结果</code></p> </li><li> </li><li> <p><code>//核区域就是以hx和hy为边长的矩形的内接圆，在该内接圆中的点</code></p> </li><li> <p><code>//的函数值都不为0，若距离超过核区域，则返回0，</code></p> </li><li> <p><code>//距离center越近，函数值越大</code></p> </li><li> <p><code>if(dist_square&gt;=1) </code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>result = 0.f; </code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>else</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>float Cd = 6.2831853072f; // ==2*CV_PI</code></p> </li><li> <p><code>float Cd_inv = 1.0f/Cd;</code></p> </li><li> <p><code>int dimension = 2; //坐标的维数</code></p> </li><li> <p><code>result = Cd_inv*expf( -0.5f*dist_square ); //高斯核函数的截面断层函数：profile</code></p> </li><li> <p><code>}</code></p> </li><li> </li><li> <p><code>return result;</code></p> </li><li> <p><code>}</code></p> </li><li> </li></ol> 
<p> </p> 
<p>下面是调用上述核函数实现的一维加权直方图统计函数 </p> 
<p>该函数中的最后一个参数是函数指针类型的参数，用于指定到底用哪个核函数</p> 
<p>KernalFunc的定义如下：</p> 
<p>//定义一个核函数指针，该函数指针可以指向任意一个符合参数标准的核函数<br> typedef float (*KernalFunc)(Point2f&amp; center,Point2f&amp; xy,int hx,int hy);</p> 
<p> </p> 
<pre> </pre> 
<ol><li> <p><code>//计算图像一维加权直方图的函数</code></p> </li><li> <p><code>static void myCalcWeightedHist1D( const Mat&amp; image, vector</code></p> </li><li> </li><li> <p><code>&amp; channels,OutputArray _hist, </code></p> </li><li> <p><code>int dims, const int* histSize,const float** ranges,KernalFunc kernal)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> </li><li> <p><code>//KernalFunc kernal;//声明一个KernalFunc类型的函数指针变量 </code></p> </li><li> </li><li> <p><code>int calc_channels = channels.size();//image图像中指定要被统计计算的通道的个数</code></p> </li><li> <p><code>int img_channel = image.channels(); //image图像的总的通道个数</code></p> </li><li> <p><code>if(img_channel &lt; channels[calc_channels - 1] + 1 )</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>printf("channels中的最大通道索引数不能超过images的通道数\n");</code></p> </li><li> <p><code>getchar();</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>if(image.depth() != CV_8U)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>printf("该函数仅支持CV_8U类的图像\n");</code></p> </li><li> <p><code>getchar();</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>if(dims != calc_channels)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>printf("被索引的通道数目与直方图的维数不相等\n");</code></p> </li><li> <p><code>getchar();</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>int img_width = image.cols; //图像宽度</code></p> </li><li> <p><code>int img_height = image.rows;//图像高度</code></p> </li><li> </li><li> <p><code>//图像区域的中心，即核函数中心</code></p> </li><li> <p><code>Point2f center(0.5f*img_width,0.5f*img_height);</code></p> </li><li> <p><code>int hx = img_width/2 , hy = img_height/2;//核函数带宽</code></p> </li><li> <p><code>float NormalConst =0.f; //用于归一化加权系数</code></p> </li><li> <p><code>//参数_hist是输出参数，保存着计算好的直方图，一维直方图是histSize[0]行1列的矩阵</code></p> </li><li> <p><code>_hist.create(dims, histSize, CV_32F); //为输出直方图开辟空间</code></p> </li><li> <p><code>Mat hist = _hist.getMat(); </code></p> </li><li> <p><code>hist.flags = (hist.flags &amp; ~CV_MAT_TYPE_MASK)|CV_32S;//直方图矩阵的类型信息 </code></p> </li><li> <p><code>hist = Scalar(0.f); //清空原来的数据，当前直方图不累加到原来的直方图上去</code></p> </li><li> </li><li> <p><code>int ch = channels[dims-1];//要统计的通道编号 ==: 0 or 1 or 2 </code></p> </li><li> <p><code>float low_range = ranges[0][0] ,high_range = ranges[0][1];//要计算的直方图区间的上下限</code></p> </li><li> <p><code>float a = histSize[0]/(high_range - low_range);/* 单位区间内直方图bin的数目*/</code></p> </li><li> <p><code>float b = -a*low_range;</code></p> </li><li> </li><li> <p><code>//外循环按行从上往下扫描 </code></p> </li><li> <p><code>for(int y=0; y &lt; img_height ; y++ )</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>//指向图像第y行的指针</code></p> </li><li> <p><code>const uchar* ptr_y = image.ptr</code></p> </li><li> </li><li> <p><code>(y);</code></p> </li><li> </li><li> <p><code>//内循环从左往右扫描</code></p> </li><li> <p><code>for(int x=0; x &lt; img_width ; x++)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>//取出输入图像的第y行第x列第ch通道的像素值</code></p> </li><li> <p><code>uchar val = ptr_y[x*img_channel + ch];</code></p> </li><li> </li><li> <p><code>//灰度值val在输入参数规定的灰度区间内的bin序号的索引值</code></p> </li><li> <p><code>int idx = cvFloor(val*a + b);//该索引值是数学上线性运算后得到的</code></p> </li><li> <p><code>float* hist_ptr = hist.ptr</code></p> </li><li> </li><li> <p><code>(idx); //指向输出直方图的第idx个bin</code></p> </li><li> <p><code>float weighted_value = kernal(center,Point2f(x,y),hx,hy); //（x,y）位置处的加权值</code></p> </li><li> <p><code>(*hist_ptr) += weighted_value; //加权累计直方图的每一个bin</code></p> </li><li> <p><code>NormalConst += weighted_value; //加权系数归一化因子</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li><li> </li><li> <p><code>float NomalConst_inv = 1.0f/(NormalConst + DBL_EPSILON);</code></p> </li><li> <p><code>//归一化加权直方图</code></p> </li><li> <p><code>for(int ii=0; ii &lt; histSize[0]; ii++)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>float* hist_ptr = hist.ptr</code></p> </li><li> </li><li> <p><code>(ii); //指向输出直方图的第ii个bin</code></p> </li><li> <p><code>*hist_ptr *= NomalConst_inv;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>return;</code></p> </li><li> <p><code>}</code></p> </li><li> </li><li> </li><li> </li><li> </li></ol> 
<p> </p> 
<p> </p> 
<p>下面是测试上述各个小函数的主函数：</p> 
<p>说明：在主函数中，计算了三种不同的一维直方图。</p> 
<p>一种是非加权直方图，它的计算函数可以参见我的博客：<a href="http://blog.csdn.net/zhjm07054115/article/details/24514445">自己编写的直方图函数</a></p> 
<p>第二种是Epanikov 核函数加权的直方图</p> 
<p>第三种是Gaussian核函数加权的直方图</p> 
<p>主函数： </p> 
<p> </p> 
<pre> </pre> 
<ol><li> <p><code>//基于核函数的加权直方图计算</code></p> </li><li> </li><li> <p><code>#include "stdafx.h"</code></p> </li><li> <p><code>#include </code></p> </li><li> </li><li> </li><li> <p><code>#include </code></p> </li><li> </li><li> </li><li> <p><code>#include </code></p> </li><li> </li><li> </li><li> </li><li> <p><code>using namespace std;</code></p> </li><li> <p><code>using namespace cv;</code></p> </li><li> </li><li> <p><code>Mat image; //母图像</code></p> </li><li> <p><code>Mat roi_hist; //兴趣区域图像块的直方图</code></p> </li><li> <p><code>Mat roi_whist1,roi_whist2;//兴趣区域图像块的加权直方图</code></p> </li><li> <p><code>Mat roi_img; //兴趣区域的图像块</code></p> </li><li> <p><code>Rect roi_rect(162,159,100,122); //ROI图像块在原图的真正区域</code></p> </li><li> <p><code>Mat ms_hist; //由MeanShift给出的目标区域的直方图</code></p> </li><li> <p><code>Mat ProbImg; //反射概率分布图像</code></p> </li><li> <p><code>bool selectObject = false; //selectObject的初始值为false,</code></p> </li><li> <p><code>int calculateHist = 0; //calculateHist的初值是0</code></p> </li><li> <p><code>bool showHist = false;</code></p> </li><li> <p><code>Point origin;</code></p> </li><li> <p><code>Rect selection;</code></p> </li><li> </li><li> <p><code>//指定要统计的通道编号</code></p> </li><li> <p><code>vector</code></p> </li><li> </li><li> <p><code>selected_channel(1,0);</code></p> </li><li> <p><code>//设定直方图中bin的数目</code></p> </li><li> <p><code>int histSize = 128;</code></p> </li><li> <p><code>//设定取值范围</code></p> </li><li> <p><code>float range[] = {0,256};//灰度特征的范围都是[0,256)</code></p> </li><li> <p><code>const float* histRange = {range}; </code></p> </li><li> <p><code>bool uniform = true; //均匀分布，</code></p> </li><li> <p><code>bool accumu = false;//无累加</code></p> </li><li> <p><code>int hist_w = 400; int hist_h = 400;//直方图图像的宽度和高度</code></p> </li><li> <p><code>int bin_w = cvRound( (double) hist_w/histSize );//直方图中一个矩形条纹的宽度</code></p> </li><li> <p><code>// 创建直方图画布 </code></p> </li><li> <p><code>Mat histImage( hist_w, hist_h, CV_8UC3, Scalar( 0,0,0) );//创建画布图像</code></p> </li><li> <p><code>//用鼠标选择目标图像区域</code></p> </li><li> <p><code>static void onMouse( int event, int x, int y, int, void* );</code></p> </li><li> <p><code>//该函数用于计算给定矩形图像块的加权直方图</code></p> </li><li> <p><code>static void CalculateWeightedHistogram(const Mat&amp; img,vector</code></p> </li><li> </li><li> <p><code>&amp; channels, Mat&amp; _hist,int weighted_method); //该函数用于计算给定矩形图像块的非加权直方图 static void CalculateHistogram(const Mat&amp; img,vector</code></p> </li><li> </li><li> <p><code>&amp; channels, Mat&amp; _hist); //自己写的计算图像一维直方图的函数 void myCalcHist1D( const Mat&amp; image, vector</code></p> </li><li> </li><li> <p><code>&amp; channels,OutputArray _hist, int dims, const int* histSize,const float** ranges); //定义一个核函数指针，该函数指针可以指向任意一个标准的核函数 typedef float (*KernalFunc)(Point2f&amp; center,Point2f&amp; xy,int hx,int hy); //计算图像一维加权直方图的函数 static void myCalcWeightedHist1D( const Mat&amp; image, vector</code></p> </li><li> </li><li> <p><code>&amp; channels,OutputArray _hist, int dims, const int* histSize,const float** ranges,KernalFunc kernal); /*核函数：Epanechnikov Kernal*/ static float EpanechnikovKernalFunc(Point2f&amp; center,Point2f&amp; xy,int hx,int hy); /*核函数：Gaussian Kernal */ static float GaussianKernalFunc(Point2f&amp; center,Point2f&amp; xy,int hx,int hy); //绘制直方图 void DrawHistogramImage( Mat&amp; _hist , Scalar&amp; color); int _tmain(int argc, _TCHAR* argv[]) { string filename = "meinv1.jpg"; string winname = "MainWindow"; namedWindow(winname,1); namedWindow("Hist Image",1); namedWindow("ROI Image",1); //为 Histogram Demo窗口添加鼠标响应函数，用于选择图像块 setMouseCallback( "MainWindow", onMouse, 0 ); Mat src, dst;//声明原始图像和目标图像 /// 装载图像 src = imread( filename, 1 ); if( !src.data ) //判断图像是否成功读取 { return -1; } //src.copyTo(image); cvtColor(src,image,CV_BGR2GRAY); for(;;) { ///循环显示读入的图像 imshow(winname,src); if(calculateHist) { roi_img = image(selection);//提取鼠标选中的图像块 imshow("ROI Image",roi_img);//显示roi 图像块 calculateHist = 0; //计算选中的图像块的直方图 CalculateHistogram(roi_img,selected_channel,roi_hist); //计算选中图像块的加权直方图 int weighted_method = 0; //指定加权核函数的种类 CalculateWeightedHistogram(roi_img,selected_channel,roi_whist1,weighted_method); weighted_method = 1; //使用高斯核函数 CalculateWeightedHistogram(roi_img,selected_channel,roi_whist2,weighted_method); //清空画布 histImage = Scalar::all(0); //绘制直方图 DrawHistogramImage(roi_hist,Scalar(0,0,255)); //绘制加权直方图 DrawHistogramImage(roi_whist1,Scalar(0,255,0)); //绘制加权直方图 DrawHistogramImage(roi_whist2,Scalar(255,0,0)); cout&lt;&lt;"红色曲线： 未加权直方图"&lt;</code></p> </li><li> </li><li> <p><code>0 &amp;&amp; selection.height &gt; 0 ) calculateHist = 1; //当在第一帧用鼠标选定了合适的目标跟踪窗口后，calculateHist的值置为 1 //selection = roi_rect; //放开这一句注释，则鼠标选取被无效化，使用roi_rect的默认位置作为roi区域 cout&lt;&lt;"选中的矩形区域为： "&lt;</code></p> </li><li> </li><li> <p><code>&lt;</code></p> </li><li> </li><li> <p><code>&amp; channels, Mat&amp; _hist,int weighted_method) { //调用自己写的函数计算选中图像块的加权直方图 KernalFunc kernal;//声明一个KernalFunc类型的函数指针变量 //根据加权参数指定具体的核函数 if(weighted_method == 0) kernal = EpanechnikovKernalFunc; //调用Epanechnikov核函数 else if(weighted_method == 1) kernal = GaussianKernalFunc; //调用高斯Gaussian核函数 myCalcWeightedHist1D(img,channels,_hist,1,&amp;histSize,&amp;histRange,kernal); /// 将直方图归一化到范围 [ 0, 1] normalize(_hist, _hist, 0, 1, NORM_MINMAX, -1, Mat() ); } //该函数用于计算给定矩形图像块的非加权直方图 static void CalculateHistogram(const Mat&amp; img,vector</code></p> </li><li> </li><li> <p><code>&amp; channels, Mat&amp; _hist) { //调用OpenCV函数计算选中图像块的灰度直方图 //calcHist(&amp;img,1,0,Mat(),_hist,1,&amp;histSize,&amp;histRange,uniform,accumu); //调用自己写的函数计算选中图像块的灰度直方图 myCalcHist1D(img,channels,_hist,1,&amp;histSize,&amp;histRange); /// 将直方图归一化到范围 [ 0, 1] normalize(_hist, _hist, 0, 1, NORM_MINMAX, -1, Mat() ); } //绘制直方图 void DrawHistogramImage( Mat&amp; _hist , Scalar&amp; color) { //用于绘图的直方图矩阵数组 Mat draw_hist; /// 将直方图归一化到范围 [ 0, histImage.rows ] normalize( _hist , draw_hist , 0, histImage.rows, NORM_MINMAX, -1, Mat() ); /// 在直方图画布上画出直方图 /*histImage = Scalar::all(0);*/ for(int i=1;i&lt;=histSize;i++) { //矩形图表示 /* rectangle( histImage,Point((i-1)*bin_w,hist_h),Point(i*bin_w,hist_h-cvRound(draw_hist.at</code></p> </li><li> </li><li> <p><code>(i-1))),Scalar(0,0,255),1,8,0); */ //折线图表示 line( histImage, Point( bin_w*(i-1), hist_h - cvRound(draw_hist.at</code></p> </li><li> </li><li> <p><code>(i-1)) ) , Point( bin_w*(i), hist_h - cvRound(draw_hist.at</code></p> </li><li> </li><li> <p><code>(i)) ), color, 1, 8, 0 ); } /// 显示直方图 imshow("Hist Image", histImage ); } /** 计算给定图像的一维直方图，图像类型必须是CV_8UCx的,x = 1,or 2, or 3 or ...., channels规定了通道索引顺序，对于1D直方图,channels数组只能有一个值，且必须 &lt; x */ void myCalcHist1D( const Mat&amp; image, vector</code></p> </li><li> </li><li> <p><code>&amp; channels,OutputArray _hist, int dims, const int* histSize,const float** ranges) { int calc_channels = channels.size();//image图像中指定要被统计计算的通道的个数 int img_channel = image.channels(); //image图像的总的通道个数 if(img_channel &lt; channels[calc_channels - 1] + 1 ) { printf("channels中的最大通道索引数不能超过images的通道数\n"); getchar(); } if(image.depth() != CV_8U) { printf("该函数仅支持CV_8U类的图像\n"); getchar(); } if(dims != calc_channels) { printf("被索引的通道数目与直方图的维数不相等\n"); getchar(); } int img_width = image.cols; //图像宽度 int img_height = image.rows;//图像高度 //参数_hist是输出参数，保存着计算好的直方图，一维直方图是histSize[0]行1列的矩阵 _hist.create(dims, histSize, CV_32F); //为输出直方图开辟空间 Mat hist = _hist.getMat(); hist.flags = (hist.flags &amp; ~CV_MAT_TYPE_MASK)|CV_32S;//直方图矩阵的类型信息 hist = Scalar(0.f); //清空原来的数据，当前直方图不累加到原来的直方图上去 int ch = channels[dims-1];//要统计的通道编号 ==: 0 or 1 or 2 float low_range = ranges[0][0] ,high_range = ranges[0][1];//要计算的直方图区间的上下限 float a = histSize[0]/(high_range - low_range);/* 单位区间内直方图bin的数目*/ float b = -a*low_range; //外循环按行从上往下扫描 for(int y=0; y &lt; img_height ; y++ ) { //指向图像第y行的指针 const uchar* ptr_y = image.ptr</code></p> </li><li> </li><li> <p><code>(y); //内循环从左往右扫描 for(int x=0; x &lt; img_width ; x++) { //取出输入图像的第y行第x列第ch通道的像素值 uchar val = ptr_y[x*img_channel + ch]; //灰度值val在输入参数规定的灰度区间内的bin序号的索引值 int idx = cvFloor(val*a + b);//该索引值是数学上线性运算后得到的 float* hist_ptr = hist.ptr</code></p> </li><li> </li><li> <p><code>(idx); //指向输出直方图的第idx个bin (*hist_ptr)++; //累计idx对应的直方图bin上的数量 } } return; } /*核函数：Epanechnikov Kernal center: 核函数中心坐标 xy : 在核区域内的某一个点 hx,hy : 核区域在x方向和y方向的半径（或叫 带宽） */ static float EpanechnikovKernalFunc(Point2f&amp; center,Point2f&amp; xy,int hx,int hy) { //计算点xy到中心center的归一化距离 float distx = (xy.x - center.x)/hx; float disty = (xy.y - center.y)/hy; float dist_square = distx*distx + disty*disty;//距离平方 float result = 0.f; //函数要返回的结果 //核区域就是以hx和hy为边长的矩形的内接圆，在该内接圆中的点 //的函数值都不为0，若距离超过核区域，则返回0， //距离center越近，函数值越大 if(dist_square&gt;=1) { result = 0.f; } else { //float Cd = CV_PI; //单位圆面积 pi*R^2 ,R==1 float Cd_inv = 0.318309886f; // == 1.0/Cd;单位圆的面积的倒数 int dimension = 2; //坐标的维数 //Epanechnikov核函数的截面断层函数：profile result = 0.5f*Cd_inv*( dimension + 2 )*( 1 - dist_square ); } return result; } /*核函数：Gaussian Kernal center: 核函数中心坐标 xy : 在核区域内的某一个点 hx,hy : 核区域在x方向和y方向的半径（或叫 带宽） */ static float GaussianKernalFunc(Point2f&amp; center,Point2f&amp; xy,int hx,int hy) { //计算点xy到中心center的归一化距离 float distx = (xy.x - center.x)/hx; float disty = (xy.y - center.y)/hy; float dist_square = distx*distx + disty*disty;//距离平方 float result = 0.f; //函数要返回的结果 //核区域就是以hx和hy为边长的矩形的内接圆，在该内接圆中的点 //的函数值都不为0，若距离超过核区域，则返回0， //距离center越近，函数值越大 if(dist_square&gt;=1) { result = 0.f; } else { float Cd = 6.2831853072f; // ==2*CV_PI float Cd_inv = 1.0f/Cd; int dimension = 2; //坐标的维数 result = Cd_inv*expf( -0.5f*dist_square ); //高斯核函数的截面断层函数：profile } return result; } //计算图像一维加权直方图的函数 static void myCalcWeightedHist1D( const Mat&amp; image, vector</code></p> </li><li> </li><li> <p><code>&amp; channels,OutputArray _hist, int dims, const int* histSize,const float** ranges,KernalFunc kernal) { //KernalFunc kernal;//声明一个KernalFunc类型的函数指针变量 int calc_channels = channels.size();//image图像中指定要被统计计算的通道的个数 int img_channel = image.channels(); //image图像的总的通道个数 if(img_channel &lt; channels[calc_channels - 1] + 1 ) { printf("channels中的最大通道索引数不能超过images的通道数\n"); getchar(); } if(image.depth() != CV_8U) { printf("该函数仅支持CV_8U类的图像\n"); getchar(); } if(dims != calc_channels) { printf("被索引的通道数目与直方图的维数不相等\n"); getchar(); } int img_width = image.cols; //图像宽度 int img_height = image.rows;//图像高度 //图像区域的中心，即核函数中心 Point2f center(0.5f*img_width,0.5f*img_height); int hx = img_width/2 , hy = img_height/2;//核函数带宽 float NormalConst =0.f; //用于归一化加权系数 //参数_hist是输出参数，保存着计算好的直方图，一维直方图是histSize[0]行1列的矩阵 _hist.create(dims, histSize, CV_32F); //为输出直方图开辟空间 Mat hist = _hist.getMat(); hist.flags = (hist.flags &amp; ~CV_MAT_TYPE_MASK)|CV_32S;//直方图矩阵的类型信息 hist = Scalar(0.f); //清空原来的数据，当前直方图不累加到原来的直方图上去 int ch = channels[dims-1];//要统计的通道编号 ==: 0 or 1 or 2 float low_range = ranges[0][0] ,high_range = ranges[0][1];//要计算的直方图区间的上下限 float a = histSize[0]/(high_range - low_range);/* 单位区间内直方图bin的数目*/ float b = -a*low_range; //外循环按行从上往下扫描 for(int y=0; y &lt; img_height ; y++ ) { //指向图像第y行的指针 const uchar* ptr_y = image.ptr</code></p> </li><li> </li><li> <p><code>(y); //内循环从左往右扫描 for(int x=0; x &lt; img_width ; x++) { //取出输入图像的第y行第x列第ch通道的像素值 uchar val = ptr_y[x*img_channel + ch]; //灰度值val在输入参数规定的灰度区间内的bin序号的索引值 int idx = cvFloor(val*a + b);//该索引值是数学上线性运算后得到的 float* hist_ptr = hist.ptr</code></p> </li><li> </li><li> <p><code>(idx); //指向输出直方图的第idx个bin float weighted_value = kernal(center,Point2f(x,y),hx,hy); //（x,y）位置处的加权值 (*hist_ptr) += weighted_value; //加权累计直方图的每一个bin NormalConst += weighted_value; //加权系数归一化因子 } } float NomalConst_inv = 1.0f/(NormalConst + DBL_EPSILON); //归一化加权直方图 for(int ii=0; ii &lt; histSize[0]; ii++) { float* hist_ptr = hist.ptr</code></p> </li><li> </li><li> <p><code>(ii); //指向输出直方图的第ii个bin *hist_ptr *= NomalConst_inv; } return; } </code></p> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li><li> </li></ol> 
<p> </p> 
<p> </p> 
<p>实验结果：</p> 
<p><img alt="" src="https://images2.imgbox.com/3f/22/fasWz6WM_o.jpg"></p> 
<p>上图显示了对美女脸部图像的加权直方图的统计结果(实际计算的时候是在灰度图像上计算的），</p> 
<p>红色曲线是未加权直方图，它的中间部分有一个小高突起，是因为美女的脸部灰度值在100到150区间内，</p> 
<p>蓝色曲线是高斯加权直方图的结果，可以看到中间的小峰比红色曲线高，这是由于用高斯函数进行了加权，把脸部中间的直方图bin的灰度频率值提高了</p> 
<p>绿色曲线是Epanechikov核函数的加权结果，可以看到中间的小峰比蓝色曲线还要高，这是因为Epanechikov核函数比高斯核函数在中心区域更加陡峭所致，所以加权效果也比高斯函数要大的多</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/286c428d2394b07d1f020bcf028e0d09/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">4.创建并调用自动控制器(api)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5fce1b3e34b520afeffb37ce08c7cd66/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">zabbix</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>