<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JWT - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JWT" />
<meta property="og:description" content="一、
1. JWT是什么
JSON Web Token (JWT)，它是目前最流行的跨域身份验证解决方案
2. 为什么使用JWT
JWT的精髓在于：“去中心化”，数据是保存在客户端的。
3. JWT的工作原理
1. 是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，示例如下：
{&#34;UserName&#34;: &#34;Chongchong&#34;,&#34;Role&#34;: &#34;Admin&#34;,&#34;Expire&#34;: &#34;2018-08-08 20:15:56&#34;}
2. 之后，当用户与服务器通信时，客户在请求中发回JSON对象
3. 为了防止用户篡改数据，服务器将在生成对象时添加签名，并对发回的数据进行验证
4. JWT组成
一个JWT实际上就是一个字符串，它由三部分组成：头部(Header)、载荷(Payload)与签名(signature)
它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。
二、实践、操作
2.1 JwtUtils 类
package com.zking.vue.util; import java.util.Date; import java.util.Map; import java.util.UUID; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import org.apache.commons.codec.binary.Base64; import io.jsonwebtoken.Claims; import io.jsonwebtoken.JwtBuilder; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; /** * JWT验证过滤器：配置顺序 CorsFilte-&gt;JwtUtilsr--&gt;StrutsPrepareAndExecuteFilter * */ public class JwtUtils { /** * JWT_WEB_TTL：WEBAPP应用中token的有效时间,默认30分钟 */ public static final long JWT_WEB_TTL = 30 * 60 * 1000; /** * 将jwt令牌保存到header中的key */ public static final String JWT_HEADER_KEY = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1d1fadbd9150349c135781140fffee9d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-08T12:02:57+08:00" />
<meta property="article:modified_time" content="2019-09-08T12:02:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JWT</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、</p> 
<p>1. JWT是什么<br>    JSON Web Token (JWT)，它是目前最流行的跨域身份验证解决方案</p> 
<p><br> 2. 为什么使用JWT<br>    JWT的精髓在于：“去中心化”，数据是保存在客户端的。</p> 
<p><br> 3. JWT的工作原理<br>    1. 是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，示例如下：<br>       {"UserName": "Chongchong","Role": "Admin","Expire": "2018-08-08 20:15:56"}</p> 
<p>   2. 之后，当用户与服务器通信时，客户在请求中发回JSON对象<br>     <br>    3. 为了防止用户篡改数据，服务器将在生成对象时添加签名，并对发回的数据进行验证</p> 
<p> </p> 
<p><img alt="" class="has" height="680" src="https://images2.imgbox.com/1a/3e/tHa5EBYU_o.png" width="1200"><br> 4. JWT组成<br>    一个JWT实际上就是一个字符串，它由三部分组成：头部(Header)、载荷(Payload)与签名(signature)<br><img alt="" class="has" height="212" src="https://images2.imgbox.com/de/0c/zfU71sCl_o.png" width="637"></p> 
<p> </p> 
<p>   它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。<br>    </p> 
<p>二、实践、操作</p> 
<p>2.1  JwtUtils 类</p> 
<pre class="has"><code>package com.zking.vue.util;

import java.util.Date;
import java.util.Map;
import java.util.UUID;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

/**
 * JWT验证过滤器：配置顺序 CorsFilte-&gt;JwtUtilsr--&gt;StrutsPrepareAndExecuteFilter
 *
 */
public class JwtUtils {
    /**
     * JWT_WEB_TTL：WEBAPP应用中token的有效时间,默认30分钟
     */
    public static final long JWT_WEB_TTL = 30 * 60 * 1000;

    /**
     * 将jwt令牌保存到header中的key
     */
    public static final String JWT_HEADER_KEY = "jwt";

    // 指定签名的时候使用的签名算法，也就是header那部分，jjwt已经将这部分内容封装好了。
    private static final SignatureAlgorithm SIGNATURE_ALGORITHM = SignatureAlgorithm.HS256;
    private static final String JWT_SECRET = "f356cdce935c42328ad2001d7e9552a3";// JWT密匙
    private static final SecretKey JWT_KEY;// 使用JWT密匙生成的加密key

    static {
        byte[] encodedKey = Base64.decodeBase64(JWT_SECRET);
        JWT_KEY = new SecretKeySpec(encodedKey, 0, encodedKey.length, "AES");
    }

    private JwtUtils() {
    }

    /**
     * 解密jwt，获得所有声明(包括标准和私有声明)
     * 
     * @param jwt
     * @return
     * @throws Exception
     */
    public static Claims parseJwt(String jwt) {
        Claims claims = Jwts.parser().setSigningKey(JWT_KEY).parseClaimsJws(jwt).getBody();
        return claims;
    }

    /**
     * 创建JWT令牌，签发时间为当前时间
     * 
     * @param claims
     *            创建payload的私有声明（根据特定的业务需要添加，如果要拿这个做验证，一般是需要和jwt的接收方提前沟通好验证方式的）
     * @param ttlMillis
     *            JWT的有效时间(单位毫秒)，当前时间+有效时间=过期时间
     * @return jwt令牌
     */
    public static String createJwt(Map&lt;String, Object&gt; claims, long ttlMillis) {
        // 生成JWT的时间，即签发时间
        long nowMillis = System.currentTimeMillis();

        // 下面就是在为payload添加各种标准声明和私有声明了
        // 这里其实就是new一个JwtBuilder，设置jwt的body
        JwtBuilder builder = Jwts.builder()
                // 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的
                .setClaims(claims)
                // 设置jti(JWT ID)：是JWT的唯一标识，根据业务需要，这个可以设置为一个不重复的值，主要用来作为一次性token,从而回避重放攻击。
                // 可以在未登陆前作为身份标识使用
                .setId(UUID.randomUUID().toString().replace("-", ""))
                // iss(Issuser)签发者，写死
                // .setIssuer("zking")
                // iat: jwt的签发时间
                .setIssuedAt(new Date(nowMillis))
                // 代表这个JWT的主体，即它的所有人，这个是一个json格式的字符串，可放数据{"uid":"zs"}。此处没放
                // .setSubject("{}")
                // 设置签名使用的签名算法和签名使用的秘钥
                .signWith(SIGNATURE_ALGORITHM, JWT_KEY)
                // 设置JWT的过期时间
                .setExpiration(new Date(nowMillis + ttlMillis));

        return builder.compact();
    }

    /**
     * 复制jwt，并重新设置签发时间(为当前时间)和失效时间
     * 
     * @param jwt
     *            被复制的jwt令牌
     * @param ttlMillis
     *            jwt的有效时间(单位毫秒)，当前时间+有效时间=过期时间
     * @return
     */
    public static String copyJwt(String jwt, Long ttlMillis) {
        Claims claims = parseJwt(jwt);

        // 生成JWT的时间，即签发时间
        long nowMillis = System.currentTimeMillis();

        // 下面就是在为payload添加各种标准声明和私有声明了
        // 这里其实就是new一个JwtBuilder，设置jwt的body
        JwtBuilder builder = Jwts.builder()
                // 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的
                .setClaims(claims)
                // 设置jti(JWT ID)：是JWT的唯一标识，根据业务需要，这个可以设置为一个不重复的值，主要用来作为一次性token,从而回避重放攻击。
                // 可以在未登陆前作为身份标识使用
                //.setId(UUID.randomUUID().toString().replace("-", ""))
                // iss(Issuser)签发者，写死
                // .setIssuer("zking")
                // iat: jwt的签发时间
                .setIssuedAt(new Date(nowMillis))
                // 代表这个JWT的主体，即它的所有人，这个是一个json格式的字符串，可放数据{"uid":"zs"}。此处没放
                // .setSubject("{}")
                // 设置签名使用的签名算法和签名使用的秘钥
                .signWith(SIGNATURE_ALGORITHM, JWT_KEY)
                // 设置JWT的过期时间
                .setExpiration(new Date(nowMillis + ttlMillis));
        return builder.compact();
    }
}</code></pre> 
<p>2.2 JwtDemo 类</p> 
<pre class="has"><code>package com.zking.vue.test;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.junit.Test;

import com.zking.vue.util.JwtUtils;

import io.jsonwebtoken.Claims;

public class JwtDemo {

    private SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");

    @Test
    public void test1() {// 生成JWT
        Map&lt;String, Object&gt; claims = new HashMap&lt;String, Object&gt;();
        claims.put("username", "zss");
        claims.put("age", 18);

        String jwt = JwtUtils.createJwt(claims, JwtUtils.JWT_WEB_TTL);
        System.out.println(jwt);

        Claims parseJwt = JwtUtils.parseJwt(jwt);
        for (Map.Entry&lt;String, Object&gt; entry : parseJwt.entrySet()) {
            System.out.println(entry.getKey() + "=" + entry.getValue());
        }
        Date d1 = parseJwt.getIssuedAt();
        Date d2 = parseJwt.getExpiration();
        System.out.println("令牌签发时间：" + sdf.format(d1));
        System.out.println("令牌过期时间：" + sdf.format(d2));
    }

    @Test
    public void test2() {// 解析oldJwt
//        String oldJwt = "eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE1NjI5MDMzNjAsImlhdCI6MTU2MjkwMTU2MCwiYWdlIjoxOCwianRpIjoiZDVjMzE4Njg0MDcyNDgyZDg1MDE5ODVmMDY3OGQ4NjkiLCJ1c2VybmFtZSI6InpzcyJ9.XDDDRRq5jYq5EdEBHtPm7GcuBz4S0VhDTS1amRCdf48";
        String oldJwt = "eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE1NjM1MjU5MjMsImlhdCI6MTU2MzUyNDEyMywiYWdlIjoxOCwianRpIjoiOTAzNmMwY2Q3NGIwNDBjMzgzMDAxYzdiNmZkMzYzZmIiLCJ1c2VybmFtZSI6InpzcyJ9.sgV9fr4fgmmahDFRJnsfazA6R3H-gNMVcg2ucA227n4";
        Claims parseJwt = JwtUtils.parseJwt(oldJwt);
        for (Map.Entry&lt;String, Object&gt; entry : parseJwt.entrySet()) {
            System.out.println(entry.getKey() + "=" + entry.getValue());
        }
        Date d1 = parseJwt.getIssuedAt();
        Date d2 = parseJwt.getExpiration();
        System.out.println("令牌签发时间：" + sdf.format(d1));
        System.out.println("令牌过期时间：" + sdf.format(d2));
    }

    @Test
    public void test3() {// 复制jwt，并延时30秒
        String oldJwt = "eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE1NjI5MDMzNjAsImlhdCI6MTU2MjkwMTU2MCwiYWdlIjoxOCwianRpIjoiZDVjMzE4Njg0MDcyNDgyZDg1MDE5ODVmMDY3OGQ4NjkiLCJ1c2VybmFtZSI6InpzcyJ9.XDDDRRq5jYq5EdEBHtPm7GcuBz4S0VhDTS1amRCdf48";
        String jwt = JwtUtils.copyJwt(oldJwt, JwtUtils.JWT_WEB_TTL);
        Claims parseJwt = JwtUtils.parseJwt(jwt);
        for (Map.Entry&lt;String, Object&gt; entry : parseJwt.entrySet()) {
            System.out.println(entry.getKey() + "=" + entry.getValue());
        }
        Date d1 = parseJwt.getIssuedAt();
        Date d2 = parseJwt.getExpiration();
        System.out.println("令牌签发时间：" + sdf.format(d1));
        System.out.println("令牌过期时间：" + sdf.format(d2));
    }

    @Test
    public void test4() {// 测试JWT的有效时间
        Map&lt;String, Object&gt; claims = new HashMap&lt;String, Object&gt;();
        claims.put("username", "zss");
        String jwt = JwtUtils.createJwt(claims, 3 * 1000L);
        System.out.println(jwt);
        Claims parseJwt = JwtUtils.parseJwt(jwt);
        Date d1 = parseJwt.getIssuedAt();
        Date d2 = parseJwt.getExpiration();
        System.out.println("令牌签发时间：" + sdf.format(d1));
        System.out.println("令牌过期时间：" + sdf.format(d2));
    }

    @Test
    public void test5() {// 三秒后再解析上面过期时间只有三秒的令牌，因为过期则会报错io.jsonwebtoken.ExpiredJwtException
        String oldJwt = "eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE1NjI4NTMzMzAsImlhdCI6MTU2Mjg1MzMyNywidXNlcm5hbWUiOiJ6c3MifQ.e098Vj9KBlZfC12QSDhI5lUGRLbNwb27lrYYSL6JwrQ";
        Claims parseJwt = JwtUtils.parseJwt(oldJwt);
        // 过期后解析就报错了，下面代码根本不会执行
        Date d1 = parseJwt.getIssuedAt();
        Date d2 = parseJwt.getExpiration();
        System.out.println("令牌签发时间：" + sdf.format(d1));
        System.out.println("令牌过期时间：" + sdf.format(d2));
    }
}</code></pre> 
<p>2.3 配置过滤器</p> 
<p>JwtFilter</p> 
<pre class="has"><code>package com.zking.vue.util;

import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import io.jsonwebtoken.Claims;

/**
 * * JWT验证过滤器，配置顺序 ：CorsFilte--&gt;JwtFilter--&gt;struts2中央控制器
 * 
 * @author Administrator
 *
 */
public class JwtFilter implements Filter {

    // 排除的URL，一般为登陆的URL(请改成自己登陆的URL)
    private static String EXCLUDE = "^/vue/userAction_login\\.action?.*$";

    private static Pattern PATTERN = Pattern.compile(EXCLUDE);

    private boolean OFF = false;// true关闭jwt令牌验证功能

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void destroy() {
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        String path = req.getServletPath();
        if (OFF || isExcludeUrl(path)) {// 登陆直接放行
            chain.doFilter(request, response);
            return;
        }

        // 从客户端请求头中获得令牌并验证
        String jwt = req.getHeader(JwtUtils.JWT_HEADER_KEY);
        Claims claims = this.validateJwtToken(jwt);
        if (null == claims) {
            // resp.setCharacterEncoding("UTF-8");
            resp.sendError(403, "JWT令牌已过期或已失效");
            return;
        } else {
            String newJwt = JwtUtils.copyJwt(jwt, JwtUtils.JWT_WEB_TTL);
            resp.setHeader(JwtUtils.JWT_HEADER_KEY, newJwt);
            chain.doFilter(request, response);
        }
    }

    /**
     * 验证jwt令牌，验证通过返回声明(包括公有和私有)，返回null则表示验证失败
     */
    private Claims validateJwtToken(String jwt) {
        Claims claims = null;
        try {
            if (null != jwt) {
                claims = JwtUtils.parseJwt(jwt);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return claims;
    }

    /**
     * 是否为排除的URL
     * 
     * @param path
     * @return
     */
    private boolean isExcludeUrl(String path) {
        Matcher matcher = PATTERN.matcher(path);
        return matcher.matches();
    }

    // public static void main(String[] args) {
    // String path = "/sys/userAction_doLogin.action?username=zs&amp;password=123";
    // Matcher matcher = PATTERN.matcher(path);
    // boolean b = matcher.matches();
    // System.out.println(b);
    // }

}</code></pre> 
<p>2.4 UserAction 类</p> 
<pre class="has"><code>package com.zking.vue.web;

import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.opensymphony.xwork2.ModelDriven;
import com.zking.base.web.BaseAction;
import com.zking.vue.biz.UserBiz;
import com.zking.vue.entity.User;
import com.zking.vue.util.JsonData;
import com.zking.vue.util.JwtUtils;
import com.zking.vue.util.PageBean;
import com.zking.vue.util.ResponseUtil;
import com.zking.vue.util.StringUtils;

public class UserAction extends BaseAction implements ModelDriven&lt;User&gt;{

    private UserBiz userBiz;
    private User user = new User();

    public UserBiz getUserBiz() {
        return userBiz;
    }

    public void setUserBiz(UserBiz userBiz) {
        this.userBiz = userBiz;
    }
     
    public String login() {
        ObjectMapper om = new ObjectMapper();
        JsonData jsonData = null;
        try {
            if(StringUtils.isBlank(user.getUname()) || StringUtils.isBlank(user.getPwd())) {
                jsonData = new JsonData(0, "用户或者密码为空", user);
            }else {
                User u = this.userBiz.login(user);
                Map&lt;String, Object&gt; claims = new HashMap&lt;String, Object&gt;();
                claims.put("uname",user.getUname());
                claims.put("pwd", user.getPwd());
                String jwt = JwtUtils.createJwt(claims, JwtUtils.JWT_WEB_TTL);
                response.setHeader(JwtUtils.JWT_HEADER_KEY, jwt);
                jsonData = new JsonData(1, "登录成功", u);
            }
        } catch (Exception e) {
            e.printStackTrace();
            jsonData = new JsonData(0, "用户或者密码错误", user);
        }finally {
            try {
                ResponseUtil.write(response, om.writeValueAsString(jsonData));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        
        return null;
    }
    
    public String getAsyncData() {
        ObjectMapper om = new ObjectMapper();
        try {
            Thread.sleep(6000);
            ResponseUtil.write(response, om.writeValueAsString("http://www.javaxl.com"));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public User getModel() {
        return user;
    }
}</code></pre> 
<p>2.5 配置js  </p> 
<p>main.js</p> 
<pre class="has"><code>// The Vue build version to load with the `import` command
// (runtime-only or standalone) has been set in webpack.base.conf with an alias.
import Vue from 'vue'
// process.env.MOCK &amp;&amp; require('@/mock') 
import 'element-ui/lib/theme-chalk/index.css'
import App from './App'
import router from './router'
import ElementUI from 'element-ui' // 新添加 1
import axios from '@/api/http' 
// import axios from 'axios'    
import VueAxios from 'vue-axios'
import store from './store' 

Vue.use(VueAxios,axios)

Vue.use(ElementUI)
Vue.config.productionTip = false

/* eslint-disable no-new */
window.vm=new Vue({
  el: '#app',
  data(){
      return{
          Bus:new Vue({
              
          })
      }
  },
  router,
  store,
  components: { App },
  template: '&lt;App/&gt;'
})</code></pre> 
<p>2.6 http.js</p> 
<pre class="has"><code>/**
 * vue项目对axios的全局配置
 */
import axios from 'axios'
import qs from 'qs'

//引入action模块，并添加至axios的类属性urls上
import action from '@/api/action'
axios.urls = action

// axios默认配置
axios.defaults.timeout = 10000; // 超时时间
// axios.defaults.baseURL = 'http://localhost:8080/j2ee15'; // 默认地址
axios.defaults.baseURL = action.SERVER;

//整理数据
// 只适用于 POST,PUT,PATCH，transformRequest` 允许在向服务器发送前，修改请求数据
axios.defaults.transformRequest = function(data) {
    data = qs.stringify(data);
    return data;
};


// 请求拦截器
axios.interceptors.request.use(function(config) {
    var jwt = window.vm.$store.getters.getJwt;
    config.headers['jwt'] = jwt;
    return config;
}, function(error) {
    return Promise.reject(error);
});

// 响应拦截器
axios.interceptors.response.use(function(response) {
    // debugger;
    var jwt = response.headers['jwt'];
    if(jwt){
        window.vm.$store.commit('setJwt',{jwt:jwt});
        
    }
    return response;
}, function(error) {
    return Promise.reject(error);
});



export default axios;</code></pre> 
<p>2.7 State.js</p> 
<pre class="has"><code>export default{
    
    jwt:''
}</code></pre> 
<p>2.8 Mutations.js</p> 
<pre class="has"><code>export default{
    setResturantName:(state,payload)=&gt;{
        state.resturantName=payload.resturantName;
    },
    setJwt:(state,payload)=&gt;{
        state.jwt=payload.jwt;
    }
}</code></pre> 
<p>2.9 Getters.js</p> 
<pre class="has"><code>export default{
    getResturantName:(state)=&gt;{
        return state.resturantName;
    },
    getJwt:(state)=&gt;{
        return state.jwt;
    }
}</code></pre> 
<p>三、结果</p> 
<p>正确账号、密码、</p> 
<p><img alt="" class="has" height="744" src="https://images2.imgbox.com/83/8c/0QkqNL1a_o.png" width="1030"></p> 
<p> </p> 
<p>直接输入原IP</p> 
<p><img alt="" class="has" height="886" src="https://images2.imgbox.com/6e/ff/jT0r4Uet_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/478ea7ad440b995f183bdc23aee79ba8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Python &#43; fitz &#43; PIL&#43; pytesseract 解析PDF</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/339c490c827e0b9fcf1a33ed8475f310/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图像处理之高斯滤波的几种实现方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>