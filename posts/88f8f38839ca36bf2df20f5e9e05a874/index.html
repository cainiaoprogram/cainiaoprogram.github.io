<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>架构设计模式详解：夯实架构设计的基础 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="架构设计模式详解：夯实架构设计的基础" />
<meta property="og:description" content="文章目录 一、分层架构设计1、层的定义2、什么是分层3、经典分层架构（1）OSI 网络7层架构（2）CS架构（3）BS架构（4）企业应用三层架构 4、为什么需要分层架构（1）复杂度隔离（2）防止错误传播（3）层自治 5、分层架构的优缺点（1）优点：高内聚（2）优点：低耦合（3）优点：易扩展（4）优点：可维护性好（5）优点：可测试性高（6）缺点：性能下降（7）缺点：开发成本上升 6、如何设计分层架构（1）依赖规则（2）定义职责（3）定义技术栈（4）代码抽象与分层（5）集成 7、分层架构模型（1）MVC模型（2）MVP模型（3）MVVM模型（4）BFF模型 二、EDA事件驱动架构设计1、EDA：Notification（通知）2、EDA：Carried State Transfer（事件携带的状态转移）3、总结：什么是EDA4、EDA：经典应用NIO5、EDA：经典应用nginx6、EDA：两种Topology（拓扑结构）（1）Mediactor（中介模式）（2）Broker（代理模式） 7、EDA架构的优点（1）整体灵活性（2）可扩展性（3）整体性能较高（4）易于部署 8、EDA架构的缺点（1）可测试性（2）可维护性（3）性能问题 9、案例 三、Microkernel微内核架构设计1、什么是微内核2、微内核系统的核心3、插件模块4、优点（1）符合开闭原则（2）良好的隔离性（3）灵活性高（4）可测试性好（5）性能较好（6）易于部署 5、缺点（1）开发难度高（2）可扩展性不高 6、设计微内核架构（1）核心（2）定义开放规范（3）注册规范（4）定义通信机制（5）实现插件（6）装载插件 7、微内核架构经典应用（1）操作系统（2）Eclipse（3）Rule Engine 规则引擎（4）ESB（5）BPM 工作流（6）Nginx Plus（7）Servlet 四、生产者消费者架构设计1、什么是生产者消费者模式2、生产者3、消费者4、容器5、核心问题：平衡6、与EDA的异同7、消费者的消费策略8、优点（1）低耦合（2）分布式部署（可选）（3）平衡系统差速（4）削峰填谷 9、设计数据单元10、设计生产者（1）生产者成功确认（2）序列化（3）数据单元独立性（4）异常处理 11、设计消费者（1）消费者的消费方式（2）消费者的分发模式（3）反序列化（4）消费确认（5）消费策略 12、设计Container（1）集群（2）消息/数据存储（3）调度算法 13、消费保证（QOS）（1）At least onse 至少一次（2）At most once 至多一次（3）Exactly once 有且仅有一次 14、经典案例（1）BlockingQueue（2）Kafka（3）ERP审批流程（4）消息广播：Spring events 一、分层架构设计 1、层的定义 层：软件的逻辑单元。
每一层都有特定的功能。
组件被分配到不同层。
2、什么是分层 将系统按照之策拆分和组织。
上层依赖于直接下层。（下层不可以依赖于上层，不可以跨层访问）
3、经典分层架构 （1）OSI 网络7层架构 （2）CS架构 CS架构是典型的两层架构，分为Client客户端和Server服务端。
客户端运行于客户的终端，服务端处理应用服务、业务逻辑和数据存储。
客户端和服务端通过网络交换信息。
（3）BS架构 BS架构同样是典型的两层架构，分为Browser浏览器和Server服务端。
Browser运行于各种浏览器的瘦客户端。
客户端和服务端通过网络交换信息。
（4）企业应用三层架构 Presentation：与用户交互和呈现信息（UI）。
Domain：业务逻辑。
Data：数据存储。
4、为什么需要分层架构 （1）复杂度隔离 隔离业务复杂度和技术复杂度。
解决不同层的问题，可以采用不同的技术栈。
每层变化速度不一致。
（2）防止错误传播 防止错误传播。
降低错误影响。
防水仓设计。（熔断）
（3）层自治 本层功能内聚。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/88f8f38839ca36bf2df20f5e9e05a874/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T09:10:34+08:00" />
<meta property="article:modified_time" content="2024-01-02T09:10:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">架构设计模式详解：夯实架构设计的基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、分层架构设计</a></li><li><ul><li><a href="#1_2" rel="nofollow">1、层的定义</a></li><li><a href="#2_6" rel="nofollow">2、什么是分层</a></li><li><a href="#3_10" rel="nofollow">3、经典分层架构</a></li><li><ul><li><a href="#1OSI_7_11" rel="nofollow">（1）OSI 网络7层架构</a></li><li><a href="#2CS_13" rel="nofollow">（2）CS架构</a></li><li><a href="#3BS_20" rel="nofollow">（3）BS架构</a></li><li><a href="#4_27" rel="nofollow">（4）企业应用三层架构</a></li></ul> 
   </li><li><a href="#4_32" rel="nofollow">4、为什么需要分层架构</a></li><li><ul><li><a href="#1_33" rel="nofollow">（1）复杂度隔离</a></li><li><a href="#2_38" rel="nofollow">（2）防止错误传播</a></li><li><a href="#3_43" rel="nofollow">（3）层自治</a></li></ul> 
   </li><li><a href="#5_48" rel="nofollow">5、分层架构的优缺点</a></li><li><ul><li><a href="#1_49" rel="nofollow">（1）优点：高内聚</a></li><li><a href="#2_53" rel="nofollow">（2）优点：低耦合</a></li><li><a href="#3_57" rel="nofollow">（3）优点：易扩展</a></li><li><a href="#4_62" rel="nofollow">（4）优点：可维护性好</a></li><li><a href="#5_66" rel="nofollow">（5）优点：可测试性高</a></li><li><a href="#6_69" rel="nofollow">（6）缺点：性能下降</a></li><li><a href="#7_74" rel="nofollow">（7）缺点：开发成本上升</a></li></ul> 
   </li><li><a href="#6_79" rel="nofollow">6、如何设计分层架构</a></li><li><ul><li><a href="#1_80" rel="nofollow">（1）依赖规则</a></li><li><a href="#2_85" rel="nofollow">（2）定义职责</a></li><li><a href="#3_89" rel="nofollow">（3）定义技术栈</a></li><li><a href="#4_93" rel="nofollow">（4）代码抽象与分层</a></li><li><a href="#5_98" rel="nofollow">（5）集成</a></li></ul> 
   </li><li><a href="#7_103" rel="nofollow">7、分层架构模型</a></li><li><ul><li><a href="#1MVC_104" rel="nofollow">（1）MVC模型</a></li><li><a href="#2MVP_109" rel="nofollow">（2）MVP模型</a></li><li><a href="#3MVVM_114" rel="nofollow">（3）MVVM模型</a></li><li><a href="#4BFF_119" rel="nofollow">（4）BFF模型</a></li></ul> 
  </li></ul> 
  </li><li><a href="#EDA_124" rel="nofollow">二、EDA事件驱动架构设计</a></li><li><ul><li><a href="#1EDANotification_125" rel="nofollow">1、EDA：Notification（通知）</a></li><li><a href="#2EDACarried_State_Transfer_132" rel="nofollow">2、EDA：Carried State Transfer（事件携带的状态转移）</a></li><li><a href="#3EDA_142" rel="nofollow">3、总结：什么是EDA</a></li><li><a href="#4EDANIO_149" rel="nofollow">4、EDA：经典应用NIO</a></li><li><a href="#5EDAnginx_155" rel="nofollow">5、EDA：经典应用nginx</a></li><li><a href="#6EDATopology_161" rel="nofollow">6、EDA：两种Topology（拓扑结构）</a></li><li><ul><li><a href="#1Mediactor_162" rel="nofollow">（1）Mediactor（中介模式）</a></li><li><a href="#2Broker_192" rel="nofollow">（2）Broker（代理模式）</a></li></ul> 
   </li><li><a href="#7EDA_212" rel="nofollow">7、EDA架构的优点</a></li><li><ul><li><a href="#1_213" rel="nofollow">（1）整体灵活性</a></li><li><a href="#2_218" rel="nofollow">（2）可扩展性</a></li><li><a href="#3_223" rel="nofollow">（3）整体性能较高</a></li><li><a href="#4_226" rel="nofollow">（4）易于部署</a></li></ul> 
   </li><li><a href="#8EDA_229" rel="nofollow">8、EDA架构的缺点</a></li><li><ul><li><a href="#1_230" rel="nofollow">（1）可测试性</a></li><li><a href="#2_234" rel="nofollow">（2）可维护性</a></li><li><a href="#3_240" rel="nofollow">（3）性能问题</a></li></ul> 
   </li><li><a href="#9_242" rel="nofollow">9、案例</a></li></ul> 
  </li><li><a href="#Microkernel_249" rel="nofollow">三、Microkernel微内核架构设计</a></li><li><ul><li><a href="#1_250" rel="nofollow">1、什么是微内核</a></li><li><a href="#2_255" rel="nofollow">2、微内核系统的核心</a></li><li><a href="#3_261" rel="nofollow">3、插件模块</a></li><li><a href="#4_279" rel="nofollow">4、优点</a></li><li><ul><li><a href="#1_280" rel="nofollow">（1）符合开闭原则</a></li><li><a href="#2_284" rel="nofollow">（2）良好的隔离性</a></li><li><a href="#3_289" rel="nofollow">（3）灵活性高</a></li><li><a href="#4_294" rel="nofollow">（4）可测试性好</a></li><li><a href="#5_298" rel="nofollow">（5）性能较好</a></li><li><a href="#6_302" rel="nofollow">（6）易于部署</a></li></ul> 
   </li><li><a href="#5_306" rel="nofollow">5、缺点</a></li><li><ul><li><a href="#1_307" rel="nofollow">（1）开发难度高</a></li><li><a href="#2_311" rel="nofollow">（2）可扩展性不高</a></li></ul> 
   </li><li><a href="#6_316" rel="nofollow">6、设计微内核架构</a></li><li><ul><li><a href="#1_317" rel="nofollow">（1）核心</a></li><li><a href="#2_322" rel="nofollow">（2）定义开放规范</a></li><li><a href="#3_328" rel="nofollow">（3）注册规范</a></li><li><a href="#4_330" rel="nofollow">（4）定义通信机制</a></li><li><a href="#5_334" rel="nofollow">（5）实现插件</a></li><li><a href="#6_336" rel="nofollow">（6）装载插件</a></li></ul> 
   </li><li><a href="#7_341" rel="nofollow">7、微内核架构经典应用</a></li><li><ul><li><a href="#1_342" rel="nofollow">（1）操作系统</a></li><li><a href="#2Eclipse_344" rel="nofollow">（2）Eclipse</a></li><li><a href="#3Rule_Engine__347" rel="nofollow">（3）Rule Engine 规则引擎</a></li><li><a href="#4ESB_354" rel="nofollow">（4）ESB</a></li><li><a href="#5BPM__360" rel="nofollow">（5）BPM 工作流</a></li><li><a href="#6Nginx_Plus_366" rel="nofollow">（6）Nginx Plus</a></li><li><a href="#7Servlet_372" rel="nofollow">（7）Servlet</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_377" rel="nofollow">四、生产者消费者架构设计</a></li><li><ul><li><a href="#1_378" rel="nofollow">1、什么是生产者消费者模式</a></li><li><a href="#2_383" rel="nofollow">2、生产者</a></li><li><a href="#3_389" rel="nofollow">3、消费者</a></li><li><a href="#4_396" rel="nofollow">4、容器</a></li><li><a href="#5_402" rel="nofollow">5、核心问题：平衡</a></li><li><a href="#6EDA_406" rel="nofollow">6、与EDA的异同</a></li><li><a href="#7_416" rel="nofollow">7、消费者的消费策略</a></li><li><a href="#8_422" rel="nofollow">8、优点</a></li><li><ul><li><a href="#1_423" rel="nofollow">（1）低耦合</a></li><li><a href="#2_428" rel="nofollow">（2）分布式部署（可选）</a></li><li><a href="#3_433" rel="nofollow">（3）平衡系统差速</a></li><li><a href="#4_438" rel="nofollow">（4）削峰填谷</a></li></ul> 
   </li><li><a href="#9_446" rel="nofollow">9、设计数据单元</a></li><li><a href="#10_454" rel="nofollow">10、设计生产者</a></li><li><ul><li><a href="#1_455" rel="nofollow">（1）生产者成功确认</a></li><li><a href="#2_461" rel="nofollow">（2）序列化</a></li><li><a href="#3_463" rel="nofollow">（3）数据单元独立性</a></li><li><a href="#4_466" rel="nofollow">（4）异常处理</a></li></ul> 
   </li><li><a href="#11_468" rel="nofollow">11、设计消费者</a></li><li><ul><li><a href="#1_469" rel="nofollow">（1）消费者的消费方式</a></li><li><a href="#2_480" rel="nofollow">（2）消费者的分发模式</a></li><li><a href="#3_485" rel="nofollow">（3）反序列化</a></li><li><a href="#4_487" rel="nofollow">（4）消费确认</a></li><li><a href="#5_491" rel="nofollow">（5）消费策略</a></li></ul> 
   </li><li><a href="#12Container_496" rel="nofollow">12、设计Container</a></li><li><ul><li><a href="#1_497" rel="nofollow">（1）集群</a></li><li><a href="#2_501" rel="nofollow">（2）消息/数据存储</a></li><li><a href="#3_505" rel="nofollow">（3）调度算法</a></li></ul> 
   </li><li><a href="#13QOS_508" rel="nofollow">13、消费保证（QOS）</a></li><li><ul><li><a href="#1At_least_onse__509" rel="nofollow">（1）At least onse 至少一次</a></li><li><a href="#2At_most_once__513" rel="nofollow">（2）At most once 至多一次</a></li><li><a href="#3Exactly_once__518" rel="nofollow">（3）Exactly once 有且仅有一次</a></li></ul> 
   </li><li><a href="#14_524" rel="nofollow">14、经典案例</a></li><li><ul><li><a href="#1BlockingQueue_525" rel="nofollow">（1）BlockingQueue</a></li><li><a href="#2Kafka_527" rel="nofollow">（2）Kafka</a></li><li><a href="#3ERP_529" rel="nofollow">（3）ERP审批流程</a></li><li><a href="#4Spring_events_531" rel="nofollow">（4）消息广播：Spring events</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_544" rel="nofollow"></a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、分层架构设计</h2> 
<h3><a id="1_2"></a>1、层的定义</h3> 
<p>层：软件的逻辑单元。<br> 每一层都有特定的功能。<br> 组件被分配到不同层。</p> 
<h3><a id="2_6"></a>2、什么是分层</h3> 
<p>将系统按照之策拆分和组织。<br> 上层依赖于直接下层。（下层不可以依赖于上层，不可以跨层访问）</p> 
<h3><a id="3_10"></a>3、经典分层架构</h3> 
<h4><a id="1OSI_7_11"></a>（1）OSI 网络7层架构</h4> 
<p><img src="https://images2.imgbox.com/84/f6/slvUhemF_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2CS_13"></a>（2）CS架构</h4> 
<p>CS架构是典型的两层架构，分为Client客户端和Server服务端。</p> 
<p>客户端运行于客户的终端，服务端处理应用服务、业务逻辑和数据存储。</p> 
<p>客户端和服务端通过网络交换信息。</p> 
<h4><a id="3BS_20"></a>（3）BS架构</h4> 
<p>BS架构同样是典型的两层架构，分为Browser浏览器和Server服务端。</p> 
<p>Browser运行于各种浏览器的瘦客户端。</p> 
<p>客户端和服务端通过网络交换信息。</p> 
<h4><a id="4_27"></a>（4）企业应用三层架构</h4> 
<p>Presentation：与用户交互和呈现信息（UI）。<br> Domain：业务逻辑。<br> Data：数据存储。<br> <img src="https://images2.imgbox.com/97/da/nRzMLekY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_32"></a>4、为什么需要分层架构</h3> 
<h4><a id="1_33"></a>（1）复杂度隔离</h4> 
<p>隔离业务复杂度和技术复杂度。<br> 解决不同层的问题，可以采用不同的技术栈。<br> 每层变化速度不一致。</p> 
<h4><a id="2_38"></a>（2）防止错误传播</h4> 
<p>防止错误传播。<br> 降低错误影响。<br> 防水仓设计。（熔断）</p> 
<h4><a id="3_43"></a>（3）层自治</h4> 
<p>本层功能内聚。<br> 自主决策。<br> 只有本层的知识。（知道的越少，泄密的可能性越小，受影响的可能性变小）</p> 
<h3><a id="5_48"></a>5、分层架构的优缺点</h3> 
<h4><a id="1_49"></a>（1）优点：高内聚</h4> 
<p>每一层的任何变更最多影响自身和上一层。<br> 专注自身功能，其他层的影响被屏蔽。<br> 符合单一职责原则。</p> 
<h4><a id="2_53"></a>（2）优点：低耦合</h4> 
<p>每一层只依赖于下一层。<br> 单向依赖。<br> 通过接口交流。（接口聚合、依赖反转）</p> 
<h4><a id="3_57"></a>（3）优点：易扩展</h4> 
<p>功能扩展，影响仅限本层。<br> 内聚性，易于横向扩展。<br> 独立部署，易于纵向扩展。<br> 每层定义了清晰的边界，扩展发生在不同边界，符合开闭原则。</p> 
<h4><a id="4_62"></a>（4）优点：可维护性好</h4> 
<p>分工合作，开发者关注点集中。<br> 每一层可以依据接口并行开发。<br> 每一层功能单一，代码易于理解。</p> 
<h4><a id="5_66"></a>（5）优点：可测试性高</h4> 
<p>每层对外提供固定接口，可以直接测试接口。<br> 分层测试。（比如Springboot分为@DataJpsTest和@WebMvcTest测试）</p> 
<h4><a id="6_69"></a>（6）缺点：性能下降</h4> 
<p>分层必定引入新的通信开销。<br> 层信息不能泄漏，导致每层都有数据转化发生。<br> 不能跨层访问，无法减少调用链路。</p> 
<h4><a id="7_74"></a>（7）缺点：开发成本上升</h4> 
<p>Full stack全栈少且难以培养。<br> 跨组织提高沟通成本。<br> 任何变更可能都需要多层参与。</p> 
<h3><a id="6_79"></a>6、如何设计分层架构</h3> 
<h4><a id="1_80"></a>（1）依赖规则</h4> 
<p>越向外越具体，越朝内越抽象。<br> 外圈是软件，内圈是规则。<br> 依赖关系只能从外向内。<br> <img src="https://images2.imgbox.com/58/34/c0z7XCHi_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_85"></a>（2）定义职责</h4> 
<p>高层表示规则，底层实现细节。<br> 逻辑内聚自治分组。<br> 依据组织职责分工。</p> 
<h4><a id="3_89"></a>（3）定义技术栈</h4> 
<p>根据每层的需求各自选定。<br> 借鉴成功案例。<br> 部署方式局限，选定技术栈。</p> 
<h4><a id="4_93"></a>（4）代码抽象与分层</h4> 
<p>层对外暴露的接口，隐藏实现细节。<br> 实现依赖于抽象，抽象不可依赖于实现细节。<br> 代码不跨层调用，只依赖于直接的下一层。</p> 
<h4><a id="5_98"></a>（5）集成</h4> 
<p>集成前做单元测试、功能测试。<br> 根据接口和技术栈确定集成方式。<br> 集成联调。</p> 
<h3><a id="7_103"></a>7、分层架构模型</h3> 
<h4><a id="1MVC_104"></a>（1）MVC模型</h4> 
<p>Model：Domain model和业务逻辑。<br> View：展示数据和用户交互。<br> Controller：接收输入并转化为对model的操作，将model转化为view能展示的数据。<br> <img src="https://images2.imgbox.com/f6/42/IaxOoAo9_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2MVP_109"></a>（2）MVP模型</h4> 
<p>是MVC的派生变种。<br> View通过Presenter获得数据而非Model。<br> Presenter层充当了桥梁，双向绑定。<br> <img src="https://images2.imgbox.com/77/da/V867tIY9_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3MVVM_114"></a>（3）MVVM模型</h4> 
<p>Model：除了自身也包含部分Controller功能。<br> ViewModel：View的模型、映射、显示逻辑和绑定器。<br> View：将ViewModel展示在特定界面。<br> <img src="https://images2.imgbox.com/cf/b9/shrjBTs3_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4BFF_119"></a>（4）BFF模型</h4> 
<p>BFF：Backend for frontend，一般用于微服务架构。<br> 避免了终端与多个服务的交流。<br> 比较常见的就是GraphQL。</p> 
<h2><a id="EDA_124"></a>二、EDA事件驱动架构设计</h2> 
<h3><a id="1EDANotification_125"></a>1、EDA：Notification（通知）</h3> 
<p>源系统发送消息通知其他系统状态改变。<br> 接收方响应非必须。<br> 发送Event逻辑与处理Event逻辑无依赖，独立变化。<br> 双方解耦，各自扩展。</p> 
<p>（例如：使用MQ）</p> 
<h3><a id="2EDACarried_State_Transfer_132"></a>2、EDA：Carried State Transfer（事件携带的状态转移）</h3> 
<p>该模式下，生产者把详细状态数据添加到事件中，如此对消费者而言，不需要再访问事件生产者服务了解详情就可以完成后续任务。事件生产者需要仔细衡量，提供足够的信息以便对已知和未知订阅者有用。</p> 
<p>该模式的好处显而易见，通过数据冗余增加了系统的可恢复性能力，因为消费者不依赖生产者就可以独立提供服务，同时可以降低延迟，不需要远程调用生产者系统，也不用担心生产者系统来自不同消费者过多的查询工作负载；但副作用也很明显，大量的副本，带来冗余的存储使用，同时增加了消费者从所有事件中维护一致性状态的复杂性（需要依赖事件顺序）。</p> 
<p>源系统推送信息及变化。（依赖者生成信息副本）<br> 容错（fault tolerance）。（源系统不可用时，依赖者可以使用副本）<br> 依赖者维护信息副本和变化。（数据的冗余问题、数据一致性问题）<br> 提高整体性能。（依赖者直接使用信息副本）</p> 
<h3><a id="3EDA_142"></a>3、总结：什么是EDA</h3> 
<p>事件驱动架构模式是一种<code>异步</code>分发事件的架构模式。</p> 
<p>用于高扩展且低耦合的系统。</p> 
<p>事件为核心，一系列解耦的、单一功能的事件处理器。</p> 
<h3><a id="4EDANIO_149"></a>4、EDA：经典应用NIO</h3> 
<p>针对不同的IO event分配不同的handler。</p> 
<p>Selector：监控哪些Channel有IO event。<br> SelectionKey：维护IO event的状态和绑定的handler。<br> <img src="https://images2.imgbox.com/1b/53/EKvCrb6e_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5EDAnginx_155"></a>5、EDA：经典应用nginx</h3> 
<p>nginx的工作进程一直监听端口并等待event。<br> event是由新建立的连接所触发。<br> 所有的连接都会被分配到一个对应的状态机。<br> Non-blocking。</p> 
<h3><a id="6EDATopology_161"></a>6、EDA：两种Topology（拓扑结构）</h3> 
<h4><a id="1Mediactor_162"></a>（1）Mediactor（中介模式）</h4> 
<p>存在业务流程。<br> 多步骤。<br> 统一协调，集中调度。<br> 事件分层次。</p> 
<p><img src="https://images2.imgbox.com/43/68/WIqdXGXM_o.png" alt="在这里插入图片描述"><br> <strong>Event Queue</strong>：<br> 源系统将event发送到queue。<br> Event处理系统从queue中消费event。<br> 是源系统和事件处理系统的连接点。<br> Queue只关心事件的传输，对事件的处理不关心。</p> 
<p><strong>Event Mediator</strong>：<br> 中介从queue中消费原始事件，并分配、协调各个执行步骤。<br> 对应业务处理的每个步骤，产生待处理事件（业务事件）。<br> 将待处理事件异步分发到不同的通道（channel）。<br> 无具体业务逻辑，只知道有哪些步骤。</p> 
<p><strong>Event Channel</strong>：<br> Mediator向channel发送消息，processor从channel读取。<br> 某种类型的业务事件（消息）的聚合。<br> 多个processor可以监听同一个channel。</p> 
<p><strong>Event Processor</strong>：<br> 监听channel的event。<br> 具体的、单一功能的业务逻辑单元。<br> 处理器之间无关联性。<br> 所有处理器合作形成完整业务流程。</p> 
<h4><a id="2Broker_192"></a>（2）Broker（代理模式）</h4> 
<p>无中心控制器。<br> 轻量的消息代理将消息串联成链状。<br> 分发至事件处理器组件。<br> 事件处理器独立运作。</p> 
<p><img src="https://images2.imgbox.com/5f/a6/lezJfgaL_o.png" alt="在这里插入图片描述"><br> <strong>Broker</strong>：<br> 是轻量级的代理。（中介是知道业务流程的，Broker不需要知道业务流程）<br> 无业务逻辑的简单消息分发。<br> 源系统将event发送至代理（通道）提供processor消费。<br> 事件通道可以是queue、topic或两者组合。</p> 
<p><strong>Event Processor</strong>：<br> 监听channel的event，判断是否处理。<br> 处理一个事件，并发送回Broker一个事件，标明其行为。<br> 事件处理器，单一业务逻辑。<br> 处理器无关联性，不构成业务逻辑链。</p> 
<h3><a id="7EDA_212"></a>7、EDA架构的优点</h3> 
<h4><a id="1_213"></a>（1）整体灵活性</h4> 
<p>架构能否在不断改变的使用场景下快速响应。<br> 事件处理器组件目的单一、高度解耦，可以独立变化。<br> 代理拓扑结构比中介拓扑结构调度会更容易。（事件中介与事件处理器是耦合的，代理模式完全解耦）</p> 
<h4><a id="2_218"></a>（2）可扩展性</h4> 
<p>高度解耦，独立变化。<br> 横向扩展。（不同组件的运行节点数均可自行调整、组件本身可以自行决定是否再拆分实现）<br> 纵向扩展。（计算密集型还是内存密集型，按需调整）</p> 
<h4><a id="3_223"></a>（3）整体性能较高</h4> 
<p>细粒度的事件处理器有利于提高性能。<br> 整体架构是异步并行有利于提高性能。</p> 
<h4><a id="4_226"></a>（4）易于部署</h4> 
<p>高度解耦的事件处理器组件让整体部署相对容易。</p> 
<h3><a id="8EDA_229"></a>8、EDA架构的缺点</h3> 
<h4><a id="1_230"></a>（1）可测试性</h4> 
<p>单元测试无差异。<br> 集成测试难。（组件众多、异步）</p> 
<h4><a id="2_234"></a>（2）可维护性</h4> 
<p>分布式部署，复杂性高。<br> 异步，对程序员要求高。<br> 异常处理难。<br> 代码可读性较差，代码复杂度高。</p> 
<h4><a id="3_240"></a>（3）性能问题</h4> 
<p>分布式消息（事件）传递会降低性能。</p> 
<h3><a id="9_242"></a>9、案例</h3> 
<p>（1）短信验证码异步发送<br> （2）电商订单生命周期管理<br> <img src="https://images2.imgbox.com/59/a6/kSkBJrH1_o.png" alt="在这里插入图片描述"><br> （3）数据同步消息广播<br> <img src="https://images2.imgbox.com/14/61/NIlVQTLI_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Microkernel_249"></a>三、Microkernel微内核架构设计</h2> 
<h3><a id="1_250"></a>1、什么是微内核</h3> 
<p>微内核，就是<code>核心功能</code>、<code>资源封装</code>。</p> 
<p>提供<code>可插拔</code>、<code>功能扩展</code>的插件。<br> <img src="https://images2.imgbox.com/94/68/tK5JxldA_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_255"></a>2、微内核系统的核心</h3> 
<p>资源封装（提供硬件接口、系统资源访问接口、环境/上下文Context访问接口、系统事件接口）。<br> 定义插件规范（使用场景、规则、条件）。<br> 核心功能（支持系统运作的最小功能集）。<br> 职责分离（通用流程由核心系统定义、核心定义规范，插件具体实现）。</p> 
<h3><a id="3_261"></a>3、插件模块</h3> 
<p>插件模块是核心系统能力的扩展（遵循核心系统规范、实现其逻辑外延和业务逻辑）。<br> 插件应该遵循单一职责原则（专注于其独立功能、只能通过核心提供的接口操作系统资源）。<br> 插件间无依赖（尽可能避免依赖其他插件，只依赖于核心）。<br> 隔离性（插件不能影响核心）。</p> 
<p><strong>插件注册</strong>：<br> 需要获取插件可用性。<br> 统一的获取插件的方式。<br> 检查信息抽象规范（名称、数据规范、访问协议）。</p> 
<p><strong>插件连接</strong>：<br> 自定义连接方式（OSGI，点对点绑定，依赖注入）（web service、message等）。<br> 通信规范（标准规范配合版本策略、自定义规范配合Adapter）。</p> 
<p><strong>插件事件</strong>：<br> <img src="https://images2.imgbox.com/80/de/5nLzmM1S_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_279"></a>4、优点</h3> 
<h4><a id="1_280"></a>（1）符合开闭原则</h4> 
<p>系统核心封闭。<br> 插件提供开放性。<br> 整体系统可持续升级。</p> 
<h4><a id="2_284"></a>（2）良好的隔离性</h4> 
<p>核心系统可以关闭插件。<br> 错误的传播范围有限。（插件内的错误不会被传播到核心系统）<br> 各自独立升级改进。（可能有兼容性问题）</p> 
<h4><a id="3_289"></a>（3）灵活性高</h4> 
<p>核心系统保持稳定，将变化尽量隔离在插件层。<br> 插件根据核心提供的接口和规范来提供丰富的功能。<br> 整体保持开放，持续进化。</p> 
<h4><a id="4_294"></a>（4）可测试性好</h4> 
<p>核心系统和插件系统可以分开测试。<br> 插件可以运行在模拟环境。</p> 
<h4><a id="5_298"></a>（5）性能较好</h4> 
<p>通过简化核心系统，提高其性能。<br> 插件按需加载，降低资源消耗。<br> 可以动态关闭插件以保护核心系统。</p> 
<h4><a id="6_302"></a>（6）易于部署</h4> 
<p>插件可在运行时动态添加到核心系统。<br> 减少核心系统停机时间。</p> 
<h3><a id="5_306"></a>5、缺点</h3> 
<h4><a id="1_307"></a>（1）开发难度高</h4> 
<p>需要分离核心功能与插件功能。<br> 插件需要可以热插拔。<br> 需要专门注册协议和通信协议。</p> 
<h4><a id="2_311"></a>（2）可扩展性不高</h4> 
<p>主要用于开发产品，不考虑扩展性。<br> 不以可扩展性见长。<br> 但是，可以结合其他模式获得扩展性。</p> 
<h3><a id="6_316"></a>6、设计微内核架构</h3> 
<h4><a id="1_317"></a>（1）核心</h4> 
<p>定义核心功能。（实现MVP最小可行产品）<br> 封装系统资源。（插件通过接口访问）<br> 开放集成点。（支持与插件的集成和通信）<br> <img src="https://images2.imgbox.com/fa/7d/4reBJKUq_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_322"></a>（2）定义开放规范</h4> 
<p>核心系统提供的接口及版本。<br> 提供上下文（context）、环境参数。<br> 提供回调（call back）、钩子（hook）、事件（event）。<br> 集成规范。</p> 
<h4><a id="3_328"></a>（3）注册规范</h4> 
<p><img src="https://images2.imgbox.com/70/a0/KaJuBM66_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_330"></a>（4）定义通信机制</h4> 
<p>同步/异步。<br> 本地/远程调用。<br> 数据格式。</p> 
<h4><a id="5_334"></a>（5）实现插件</h4> 
<p><img src="https://images2.imgbox.com/92/64/YSFrFypx_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="6_336"></a>（6）装载插件</h4> 
<p>基于注册表获取插件信息。<br> 装载机制。（启动器/运行期装载、内存/远程装载）<br> 装载条件。（触发条件符合才加载）</p> 
<h3><a id="7_341"></a>7、微内核架构经典应用</h3> 
<h4><a id="1_342"></a>（1）操作系统</h4> 
<p><img src="https://images2.imgbox.com/93/7d/8tTL4IQp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2Eclipse_344"></a>（2）Eclipse</h4> 
<p>Eclipse开发者可以提供各种插件，为Eclipse提供更多额外的功能。<br> <img src="https://images2.imgbox.com/d9/d7/sW0sgOsz_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3Rule_Engine__347"></a>（3）Rule Engine 规则引擎</h4> 
<p>专家系统。（将人类专业知识转化为程序，用程序来解决专业问题）<br> Rule。（Condition、Action）<br> Rule Engine。（基于输入数据执行规则的专家系统，如果满足条件则执行对应的任务）<br> <img src="https://images2.imgbox.com/f6/ad/jgebuFBD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fc/06/qRqyopMF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/91/76/tQmvn2Dl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4ESB_354"></a>（4）ESB</h4> 
<p>通过将不同应用接入ESB以扩展系统功能。<br> ESB是核心系统。<br> 应用就是插件。<br> 应用之间无依赖，都与ESB沟通。<br> <img src="https://images2.imgbox.com/b6/21/5BzzVKOa_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5BPM__360"></a>（5）BPM 工作流</h4> 
<p>通过BPM组合不同子流程形成新的流程扩展系统功能。<br> BPM是核心系统。<br> 子流程是插件。<br> 子流程间无直接依赖。<br> <img src="https://images2.imgbox.com/42/f1/xyIsd1A7_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="6Nginx_Plus_366"></a>（6）Nginx Plus</h4> 
<p>Nginx通过module为nginx添加新功能。<br> nginx是核心，module是plugin。<br> 开源nginx在编译期指定要添加的模块。<br> nginx plus可以动态添加或移除module。<br> <img src="https://images2.imgbox.com/22/f8/KWPonFDK_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="7Servlet_372"></a>（7）Servlet</h4> 
<p>Servlet实现核心功能。<br> 插件：（Filter：针对request和response的操作；Listener：Servlet生命周期事件并执行相应命令）<br> SpringMVC，Struts众多功能都是基于Listener和Filter实现。</p> 
<h2><a id="_377"></a>四、生产者消费者架构设计</h2> 
<h3><a id="1_378"></a>1、什么是生产者消费者模式</h3> 
<p>同步调用变成异步调用。<br> 生产数据与消费数据分离。<br> 协调不同处理速度。<br> <img src="https://images2.imgbox.com/d9/7e/ftdD9qJN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_383"></a>2、生产者</h3> 
<p>生产者是系统运转的动力。<br> 为下一环节产生待处理的工作/数据。<br> 与消费者关系：重点在如何将数据发送到容器、对消费者无依赖、不关注消费者的how/when。<br> 发送顺序问题比较难处理。</p> 
<h3><a id="3_389"></a>3、消费者</h3> 
<p>从容器中获得数据，并按照自身业务逻辑处理。<br> 依赖于容器，不直接依赖于生产者。<br> 向容器确认数据已经被消费。<br> 处理后的数据：从容器中删除（queue）、保留在容器中（topic）。<br> 消费顺序问题比较难以处理。</p> 
<h3><a id="4_396"></a>4、容器</h3> 
<p>容器是消费者与生产者的交汇点。<br> 容器担当了保管数据的责任。（容量、保存时间、读写效率）<br> 是生产者和消费者的差速器。<br> 数据分配策略。（发给哪个消费者）</p> 
<h3><a id="5_402"></a>5、核心问题：平衡</h3> 
<p>数据不堆积。（容器中数据不会溢出）<br> 消费者无资源浪费。（最好是消费者的消费能力刚刚好）<br> 调度算法。（多个消费者消息路由问题）</p> 
<h3><a id="6EDA_406"></a>6、与EDA的异同</h3> 
<p>EDA架构模式：<br> 事件触发流程；<br> 重点在事件本身；<br> 不解决事件/消息如何传递的问题。</p> 
<p>生产者消费者模式：<br> 强调的是从生产端到消费端的全流程；<br> 从抽象程度来看EDA更抽象。</p> 
<h3><a id="7_416"></a>7、消费者的消费策略</h3> 
<p>消费策略决定消费者如何消费数据。<br> 消费方式：push（容器推送给消费者）、poll（消费者从容器拉取）。<br> 分发方式：topic（消息一对多）、queue（消息点对点）。<br> 事务性问题。</p> 
<h3><a id="8_422"></a>8、优点</h3> 
<h4><a id="1_423"></a>（1）低耦合</h4> 
<p>producer、consumer和container均可独立变化。<br> producer和consumer互无依赖。<br> 无事务系统时，对三者都无约束。<br> 异步运作。</p> 
<h4><a id="2_428"></a>（2）分布式部署（可选）</h4> 
<p>producer、consumer和container均可分开部署。<br> producer、consumer和container自成分布式系统。<br> 各自按需扩展。</p> 
<h4><a id="3_433"></a>（3）平衡系统差速</h4> 
<p>通过container来平衡生产速度和消费速度。<br> 通过动态调节producer和consumer数量，以平衡系统差速。<br> 减少资源浪费。（避免生产过多数据，避免数据堆积在容器）</p> 
<h4><a id="4_438"></a>（4）削峰填谷</h4> 
<p>生产和消费速度不确定时，达到削峰填谷的效果。</p> 
<p>削峰：生产数据超过消费数据，缓存数据。<br> 填谷：生产数据的速度下降，消费端消费速度不变。</p> 
<p>单点流量增加不影响系统稳定性，整体系统运行于匀速状态。</p> 
<h3><a id="9_446"></a>9、设计数据单元</h3> 
<p>定义：生产者放入/发送到容器的单体、容器内存储的单体、消费者消费的单体。</p> 
<p>从业务逻辑推导：数据单元具备业务含义、数据单元的颗粒度适中。</p> 
<p>完整性保证：传输过程中数据单元不可缺失。</p> 
<p>无依赖：数据单元是独立的，两个数据单元之间互不影响。</p> 
<h3><a id="10_454"></a>10、设计生产者</h3> 
<h4><a id="1_455"></a>（1）生产者成功确认</h4> 
<p>生产/发送，对发送成功的确认：<br> 只管发送不管是否发送成功；<br> 发送之后需要同步知道是否发送成功；<br> 异步发送之后不需要同步知道是否发送成功，而是通过回调来知道是否发送成功。</p> 
<h4><a id="2_461"></a>（2）序列化</h4> 
<p>数据单元变成用于网络传输的数据。（JSON、Avro、Thrift、Protobuf）</p> 
<h4><a id="3_463"></a>（3）数据单元独立性</h4> 
<p>数据单元的时间、空间的独立性。</p> 
<h4><a id="4_466"></a>（4）异常处理</h4> 
<p>超时、错误、重试等。</p> 
<h3><a id="11_468"></a>11、设计消费者</h3> 
<h4><a id="1_469"></a>（1）消费者的消费方式</h4> 
<p>推（pust）：<br> 由container发起，将数据单元推送给consumer；<br> consumer可以尽快获得数据。<br> 如果推的太快，可能会导致consumer崩溃。</p> 
<p>拉（pull）：<br> 由consumer主动发起，一直不停的询问container。<br> 获取数据有一定的滞后，并不是实时。（Long polling）<br> 好处就是，consumer可以自己控制拉取数据的数量。</p> 
<h4><a id="2_480"></a>（2）消费者的分发模式</h4> 
<p>Queue：点对点的模式，不可重复消费。<br> <img src="https://images2.imgbox.com/a4/5f/x8UAZzDM_o.png" alt="在这里插入图片描述"><br> Pub/Sub：发布订阅，Topic模式，1对N，消息相当于可重复消费。<br> <img src="https://images2.imgbox.com/c2/85/HYvb0USW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_485"></a>（3）反序列化</h4> 
<p>将网络数据流还原为数据单元。（JSON、Avro、Thrift、Protobuf）</p> 
<h4><a id="4_487"></a>（4）消费确认</h4> 
<p>Commit log（记录消息读到哪里了）。<br> ACK。（消息处理完毕之后，给容器一个应答）</p> 
<h4><a id="5_491"></a>（5）消费策略</h4> 
<p>批量/单体消费。<br> 同步/异步消费。<br> 保证幂等性。</p> 
<h3><a id="12Container_496"></a>12、设计Container</h3> 
<h4><a id="1_497"></a>（1）集群</h4> 
<p>Replica（数据复制）。主从节点复制、分区。</p> 
<p>Non-replica（不复制）。只存meta data，读取转移。（读的时候会判断，数据和真实存储的地方有个关联关系，类似做了index索引）（用的较少）</p> 
<h4><a id="2_501"></a>（2）消息/数据存储</h4> 
<p>数据单元的存储结构。<br> 时效性。（不能一直保存下去）</p> 
<h4><a id="3_505"></a>（3）调度算法</h4> 
<p>分配数据单元到consumer。</p> 
<h3><a id="13QOS_508"></a>13、消费保证（QOS）</h3> 
<h4><a id="1At_least_onse__509"></a>（1）At least onse 至少一次</h4> 
<p>Producer保证Consumer至少收到一次数据单元。<br> 从业务分析Container中可能有重复数据单元。<br> Consumer实现要防重或幂等。</p> 
<h4><a id="2At_most_once__513"></a>（2）At most once 至多一次</h4> 
<p>Producer保证Consumer最多收到一次数据单元。<br> 从业务分析Container中可能会丢失部分数据单元。<br> Consumer可能无法读取到所需数据单元。<br> 或许要引入第三方数据比对验证程序。</p> 
<h4><a id="3Exactly_once__518"></a>（3）Exactly once 有且仅有一次</h4> 
<p>Producer保证Consumer收到并仅收到一次数据单元。<br> 从业务分析Container中有且仅有一份数据单元。<br> Consumer无需防重。</p> 
<h3><a id="14_524"></a>14、经典案例</h3> 
<h4><a id="1BlockingQueue_525"></a>（1）BlockingQueue</h4> 
<p><img src="https://images2.imgbox.com/3e/14/SQoQmKDE_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2Kafka_527"></a>（2）Kafka</h4> 
<p><img src="https://images2.imgbox.com/e4/0b/t03Kf0Yg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3ERP_529"></a>（3）ERP审批流程</h4> 
<p><img src="https://images2.imgbox.com/ee/98/un4yC49U_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4Spring_events_531"></a>（4）消息广播：Spring events</h4> 
<p><img src="https://images2.imgbox.com/a5/d6/gNsTJc1R_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_544"></a></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f61ba62a80aa76410eccecab30de86c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华为HCIA课堂笔记第七章 以太网交换基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e0be8b1ac3acc8cdea2b8e55fe2aabdd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【话题】ChatGPT等大语言模型为什么没有智能2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>