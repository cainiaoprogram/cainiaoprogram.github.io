<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>tcp整理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="tcp整理" />
<meta property="og:description" content="什么是tcp？TCP是在IP网络层之上的传输层协议，用于提供port到port面向连接的可靠的字节流传输
port到port：IP层只管数据包从一个IP到另一个IP的传输，IP层之上的TCP层加上端口后，就是面向进程了，每个port都可以对应到用户进程。
可靠：TCP会负责维护实际上子虚乌有的连接概念，包括收包后的确认包、丢包后的重发等来保证可靠性。由于带宽和不同机器处理能力的不同，TCP要能控制流量。
字节流：TCP会把应用进程传来的字节流数据切割成许多个数据包，在网络上发送。IP包是会失去顺序或者产生重复的，TCP协议要能还原到字节流本来面目。
滑动窗口 滑动窗口：维持发送方/接收方缓冲区（缓冲区是 用来解决网络之间数据不可靠的问题，例如丢包，重复包，出错，乱序）
正常情况下，窗口（window）里包括已发送和待发送到的数据包，当已发送的包得到ack确认后，滑动窗口往后移继续将未发送的包读进缓存
丢包情况下，窗口里的数据已经存满，但是迟迟未得到第一个包的ack确认，这是就会启动超时重传（注意ack包是有顺序的，必须先接受第一个待确认的ack包）
超时重传 超时时间 RTO 一般是根据RTT（round trip time）也就是往返时间来设置的
如果 RTO小于RTT则会造成很多不必要的重传
如果RTO远大于RTT则会降低整体网络的利用率，造成TCP性能低
所以，RTO应该比RTT稍大
RTO=SRTT（两次RTT的均值）&#43;4×RTTD（均值偏差）
拥塞控制 当超过RTO时间还没有收到ACK确认就会发生重传，重传后如果再次超过RTO时间还是没收到ACK确认，这时候会认为是网络拥堵，会引发 TCP 拥塞控制行为，使 RTO 翻倍。则第 n 次重传的 RTOn 值为：
RTOn=2^(n−1)×RTO1
快速重传 者TCP 发送方在观测到至少 dupthresh ( 通常是 3 ) 个重复 ACK，立即重传，而不必得到计时器超时，当然也可以同时发送新的数据。
RST RST是复位标志，不必等缓冲区的包都发出去（不像上面的FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。
TCP处理程序会在自己认为的异常时刻发送RST包。例如，A向B发起连接，但B之上并未监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。
又比如，AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect reset by peer错误。
RST攻击：A和B服务器连接后，C伪造成A使A和B断开连接，两种方式：1.伪造成A发送一个RST包 2.伪造成A发送一个SYN连接请求包" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f5146d0162a49549489f7d9d8aba644e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-16T14:14:56+08:00" />
<meta property="article:modified_time" content="2022-02-16T14:14:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">tcp整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>什么是tcp？TCP是在IP网络层之上的传输层协议，用于提供port到port面向连接的可靠的字节流传输<br> port到port：IP层只管数据包从一个IP到另一个IP的传输，IP层之上的TCP层加上端口后，就是面向进程了，每个port都可以对应到用户进程。</p> 
<p>可靠：TCP会负责维护实际上子虚乌有的连接概念，包括收包后的确认包、丢包后的重发等来保证可靠性。由于带宽和不同机器处理能力的不同，TCP要能控制流量。</p> 
<p>字节流：TCP会把应用进程传来的字节流数据切割成许多个数据包，在网络上发送。IP包是会失去顺序或者产生重复的，TCP协议要能还原到字节流本来面目。</p> 
<h3><a id="_8"></a>滑动窗口</h3> 
<p>滑动窗口：维持发送方/接收方缓冲区（缓冲区是 用来解决网络之间数据不可靠的问题，例如丢包，重复包，出错，乱序）<br> <strong>正常情况下</strong>，窗口（window）里包括已发送和待发送到的数据包，当已发送的包得到ack确认后，滑动窗口往后移继续将未发送的包读进缓存<br> <strong>丢包情况下</strong>，窗口里的数据已经存满，但是迟迟未得到第一个包的ack确认，这是就会启动<strong>超时重传</strong>（注意ack包是有顺序的，必须先接受第一个待确认的ack包）</p> 
<h3><a id="_13"></a>超时重传</h3> 
<p>超时时间 RTO 一般是根据RTT（round trip time）也就是<strong>往返时间</strong>来设置的<br> 如果 RTO小于RTT则会造成很多不必要的重传<br> 如果RTO远大于RTT则会降低整体网络的利用率，造成TCP性能低<br> 所以，RTO应该比RTT稍大<br> RTO=SRTT（两次RTT的均值）+4×RTTD（均值偏差）</p> 
<h3><a id="_20"></a>拥塞控制</h3> 
<p>当超过RTO时间还没有收到ACK确认就会发生重传，重传后如果再次超过RTO时间还是没收到ACK确认，这时候会认为是网络拥堵，会引发 TCP 拥塞控制行为，使 RTO 翻倍。则第 n 次重传的 RTOn 值为：<br> RTOn=2^(n−1)×RTO1</p> 
<h3><a id="_24"></a>快速重传</h3> 
<p>者TCP 发送方在观测到至少 dupthresh ( 通常是 3 ) 个重复 ACK，立即重传，而不必得到计时器超时，当然也可以同时发送新的数据。</p> 
<h3><a id="RST_27"></a>RST</h3> 
<p>RST是复位标志，不必等缓冲区的包都发出去（不像上面的FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。<br> TCP处理程序会在自己认为的异常时刻发送RST包。例如，A向B发起连接，但B之上并未监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。<br> 又比如，AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect reset by peer错误。<br> RST攻击：A和B服务器连接后，C伪造成A使A和B断开连接，两种方式：1.伪造成A发送一个RST包 2.伪造成A发送一个SYN连接请求包</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5654115a6b479529af992e09c5f8a549/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux 网卡特性配置 ethtool 详解 网卡Offload</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02fd7af880eccda00a8489db54609b38/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决Unexpected end of JSON input 报错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>