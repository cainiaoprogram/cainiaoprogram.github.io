<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构入门到入土——链表（2） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构入门到入土——链表（2）" />
<meta property="og:description" content="目录
一，与链表相关的题目（2）
1.输入两个链表，找出它们的第一个公共节点
2.给定一个链表，判断链表中是否有环
3.给定一个链表，返回链表开始入环的第一个节点，若无则返回null
一，与链表相关的题目（2） 1.输入两个链表，找出它们的第一个公共节点 下面是两个相交的链表
此时要找两个链表的相交节点非常简单
只需要将两个链表的头节点分别向后移
当head1 == head2 时说明改节点是它们的相交节点
但当两个链表长度不一样的时候就会出现问题
遇到这种情况，一般会先求出两个链表的长度len1与len2，让长的那个链表走两链表的差值步（len1-len2）/（len2 - len1）
之后走相同步数直至相遇
代码示例：
public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode cur1 = headA; ListNode cur2 = headB; int count1 = 0; int count2 = 0; while (cur1.next != null) { count1&#43;&#43;; cur1 = cur1.next; } cur1 = headA; while (cur2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/31619562acd329f3ecb1069036dbb2db/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T21:56:29+08:00" />
<meta property="article:modified_time" content="2024-01-07T21:56:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构入门到入土——链表（2）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"><a href="#" rel="nofollow">一，与链表相关的题目（2）</a></p> 
<p id="1.%E8%BE%93%E5%85%A5%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%89%BE%E5%87%BA%E5%AE%83%E4%BB%AC%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><a href="#1.%E8%BE%93%E5%85%A5%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%89%BE%E5%87%BA%E5%AE%83%E4%BB%AC%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9" rel="nofollow">1.输入两个链表，找出它们的第一个公共节点</a></p> 
<p id="2.%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF-toc" style="margin-left:40px;"><a href="#2.%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF" rel="nofollow">2.给定一个链表，判断链表中是否有环</a></p> 
<p id="3.%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E5%BC%80%E5%A7%8B%E5%85%A5%E7%8E%AF%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E8%8B%A5%E6%97%A0%E5%88%99%E8%BF%94%E5%9B%9Enull-toc" style="margin-left:40px;"><a href="#3.%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E5%BC%80%E5%A7%8B%E5%85%A5%E7%8E%AF%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E8%8B%A5%E6%97%A0%E5%88%99%E8%BF%94%E5%9B%9Enull" rel="nofollow">3.给定一个链表，返回链表开始入环的第一个节点，若无则返回null</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>一，与链表相关的题目（2）</h2> 
<h3 id="1.%E8%BE%93%E5%85%A5%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%89%BE%E5%87%BA%E5%AE%83%E4%BB%AC%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9">1.<a class="link-info" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/" rel="nofollow" title="输入两个链表，找出它们的第一个公共节点">输入两个链表，找出它们的第一个公共节点</a></h3> 
<p>下面是两个相交的链表</p> 
<p><img alt="" height="580" src="https://images2.imgbox.com/c6/89/MrX8JruM_o.png" width="1061"></p> 
<p>此时要找两个链表的相交节点非常简单</p> 
<p>只需要将两个链表的头节点分别向后移</p> 
<p>当head1 == head2 时说明改节点是它们的相交节点</p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/9c/00/JyDfXg80_o.png" width="954"></p> 
<p><img alt="" height="498" src="https://images2.imgbox.com/a4/b4/sM3wCK9f_o.png" width="1200"></p> 
<p>但当两个链表长度不一样的时候就会出现问题</p> 
<p><img alt="" height="579" src="https://images2.imgbox.com/31/c6/ZqInbUfL_o.png" width="956"></p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/a7/01/hUTB12Xs_o.png" width="999"></p> 
<p>遇到这种情况，一般会先求出两个链表的长度len1与len2，让长的那个链表走两链表的差值步（len1-len2）/（len2 - len1）</p> 
<p></p> 
<p><img alt="" height="621" src="https://images2.imgbox.com/a2/47/Dsw909fE_o.png" width="966"></p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/ff/9d/Sdrp5wWK_o.png" width="1002"></p> 
<p>之后走相同步数直至相遇</p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/33/fa/TSMUlOyP_o.png" width="962"></p> 
<p>代码示例：</p> 
<pre><code class="language-java">public class Solution {
        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            if (headA == null || headB == null) {
                return null;
            }
            ListNode cur1 = headA;
            ListNode cur2 = headB;
            int count1 = 0;
            int count2 = 0;
            while (cur1.next != null) {
                count1++;
                cur1 = cur1.next;
            }
            cur1 = headA;
            while (cur2.next != null) {
                count2++;
                cur2 = cur2.next;
            }
            cur2 = headB;
            int dif = 0;
            if (count1 &gt;= count2) {
                dif = count1 - count2;
                while (dif != 0) {
                    cur1 = cur1.next;
                    dif--;
                }
            } else {
                dif = count2 - count1;
                while (dif != 0) {
                    cur2 = cur2.next;
                    dif--;
                }
            }
            while (cur1 != cur2) {
                cur1 = cur1.next;
                cur2 = cur2.next;
            }
            if (cur1 == cur2) {
                return cur1;
            } else {
                return null;
            }
        }
    }</code></pre> 
<h3 id="2.%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF">2.<a class="link-info" href="https://leetcode.cn/problems/linked-list-cycle/description/" rel="nofollow" title="给定一个链表，判断链表中是否有环">给定一个链表，判断链表中是否有环</a></h3> 
<div> 
 <span style="color:#494949;">【思路】 </span> 
</div> 
<div> 
 <span style="color:#494949;">       快慢指针，即慢指针一次走一步，快指针一次走两步，两个指针从链表起始位置开始运行，如果链表带环则一定会在环中相遇，否则快指针率先走到链表的末尾。比如：陪女朋友到操作跑步减肥。</span> 
</div> 
<div></div> 
<pre><code class="language-java">public class Solution {
        public boolean hasCycle(ListNode head) {
            ListNode fast = head;
            ListNode slow = head;
            while (fast != null &amp;&amp; fast.next != null) {
                fast = fast.next.next;
                slow = slow.next;
                if (fast == slow) {
                    return true;
                }
            }
           return false;
        }
    }</code></pre> 
<div> 
 <span style="color:#494949;"><strong>为什么快指针每次走两步，慢指针走一步可以？ </strong></span> 
</div> 
<div> 
 <span style="color:#494949;">假设链表带环，两个指针最后都会进入环，快指针先进环，慢指针后进环。当慢指针刚进环时，可能就和快指针相遇了，最差情况下两个指针之间的距离刚好就是环的长度。此时，两个指针每移动一次，之间的距离就缩小一步，不会出现每次刚好是套圈的情况，因此：在慢指针走到一圈之前，快指针肯定是可以追上慢指针的，即相遇。 </span> 
</div> 
<div></div> 
<div> 
 <img alt="" height="547" src="https://images2.imgbox.com/19/c8/89mw1Sem_o.png" width="1031"> 
</div> 
<div></div> 
<h3 id="3.%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E5%BC%80%E5%A7%8B%E5%85%A5%E7%8E%AF%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E8%8B%A5%E6%97%A0%E5%88%99%E8%BF%94%E5%9B%9Enull"><span style="color:#494949;">3.</span><a class="link-info" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/" rel="nofollow" title="给定一个链表，返回链表开始入环的第一个节点，若无则返回null">给定一个链表，返回链表开始入环的第一个节点，若无则返回null</a></h3> 
<div>
  上一题我们知道了怎么求一个链表是否有环，而其实这一题也不难。基于上一题的基础上，我们给出以下推导： 
</div> 
<div> 
 <img alt="" height="672" src="https://images2.imgbox.com/cd/1e/vWdgggNl_o.png" width="1200"> 
</div> 
<div>
  通过以上过程我们推导出头节点距入口处（x）其实是等于快指针和慢指针相遇点到入口处的距离（y）的，所有我们大可在这里再次令slow等于head，让fast和slow以相同的速度往后走，因为速度一样，路程一样，所有它们再次相遇的地方就一定是这个环的入口点 
</div> 
<div></div> 
<div> 
 <img alt="" height="751" src="https://images2.imgbox.com/6f/dd/oPxM0sAX_o.png" width="1200"> 
</div> 
<div>
  这里是当fast只比slow多走一圈的情况 
</div> 
<div>
  而还存在的情况就是当环很小，而head距入口处又非常远时，fast就会为了等待x进入环而多走n圈 
</div> 
<div> 
 <img alt="" height="330" src="https://images2.imgbox.com/33/67/QAzZsVH9_o.png" width="1200"> 
</div> 
<div>
  此时我们还可以根据上一题的思路就可以推导出以下公式： 
</div> 
<div> 
 <img alt="" height="540" src="https://images2.imgbox.com/fd/02/omGXqHDx_o.png" width="814"> 
</div> 
<div>
  详解： 
</div> 
<div> 
 <img alt="" height="848" src="https://images2.imgbox.com/ae/54/NFksn5Zt_o.png" width="1200"> 
</div> 
<div>
  可以发现，slow到入口点的距离（x）其实是等于转的圈数减一乘以圈的周长，再加上slow和fast的相遇点距入口点的距离（y）的，并且我们上一题的推导结果也符合该条公式。 
</div> 
<div></div> 
<div>
  此时代码就可以基于上一题的代码进行修改并书写： 
</div> 
<div> 
 <pre><code class="language-java">public class Solution {
        public ListNode detectCycle(ListNode head) {
            ListNode fast = head;
            ListNode slow = head;
            while (fast != null &amp;&amp; fast.next != null) {
                fast = fast.next.next;
                slow = slow.next;
                if (fast == slow) {
                    slow = head;
                    while (slow != fast) {
                        slow = slow.next;
                        fast = fast.next;
                    }
                    return fast;
                }
            }
            return null;
        }
    }</code></pre> 
</div> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b228cd0e11bfa7f6972df969e300df4e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">江科大STM32</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e056c500a1c4b6a7110b50d807bade5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">https</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>