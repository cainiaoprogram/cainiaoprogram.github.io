<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从损失函数解决关于密集遮挡人群的检测问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从损失函数解决关于密集遮挡人群的检测问题" />
<meta property="og:description" content="关于密集遮挡的行人检测
行人检测是计算机视觉领域的一个重要研究课题，在自动驾驶，视频监控和机器人等各种应用，旨在预测一系列行人实例的边界框。实际上，在现实生活中的复杂情景中，遮挡是行人检测的最重要挑战之一，尤其是在拥挤的场景中。例如在CityPersons数据集中48.8 ％行人其它行人互相遮挡。以前的方法只要求每个预测的边界框都接近其指定的GT，而不考虑它们之间的关系。因此，它们使得检测器对拥挤场景中的非最大抑制（NMS）的阈值敏感，这种密集遮挡问题并不能单靠调整NMS阈值来解决，较大的NMS阈值导致很多误检，较小的NMS阈值导致很多漏检。
有些论文专门提出方法来解决密集和遮挡问题，本文将关注Occlusion-aware R-CNN:Detecting Pedestrians in a Crowd（简称为OR-CNN）和Repulsion Loss两个解决方案。
1.OR-CNN
该论文以Faster R-CNN为基础，对损失函数部分和RoIPooling两个部分分别做出了一些改进。本博客将主要关注对损失函数改进的部分，提出聚集损失（AggLoss）来改进密集遮挡问题。
Faster R-CNN是两阶段检测方法，分别在RPN和R-CNN头部网络检测。为了在RPN模块中能有效的生成更加准确的区域候选框，设计了AggLoss使候选框尽量的靠近对应的GT，并且同一个GT对应的所有proposal boxes尽量紧凑。其定义如下：
损失函数包含两个部分，分类损失和AggLoss，其中分类损失是与原始论文一样，使用交叉熵损失。AggLoss定义如下：
AggLoss 包含常规的回归损失用于使proposal boxes尽量靠近GT，同时还有一个compactness loss，Lcom，用于使同一个GT对应的多个proposal boxes之间尽量紧凑，定义如下：
由以上定义可知，Lcom是专门针对一个GT对应了多个anchor的情况，让同一个GT对应的候选框之间尽量的紧凑，通过计算GT与多个候选框的均值之间的smoothL1实现。
AggLoss的思想非常简单，损失设计也很简洁，只是在原来的损失基础上增加了一个Lcom，从而达到了使候选框尽量的靠近对应的GT，并且同一个GT对应的所有proposal boxes尽量紧凑的目的。效果很赞，在多个公开数据集上达到了SOTA，作者对比了使用原始损失和AggLoss的区别，见下图。
这两个图很有意思，能反映一些问题，图a是没有使用NMS的预测结果，可以明显看出AggLoss的预测结果更好，基线的预测结果框比较分散，AggLoss的结果同一个GT的框更加紧凑，这种情况使用NMS可轻松去掉冗余框而不会出现漏检或者误检。图b是NMS阈值对预测结果的影响，对于基线方法0.55是一个分水岭，NMS阈值小于0.55时，错误率一直下降，但是超过0.55之后错误率大幅增加。对于AggLoss情况，错误率曲线更加平滑，首先整体错误率比基线更低，其次NMS阈值对AggLoss的影响没那么大，而且NMS阈值增加到0.55继续增加也不会出现错误率上升的情况，因为AggLoss的预测框更加紧凑，使用NMS很容易过滤冗余框。
2. 互斥损失
Repulsion Loss是旷视提出的，针对密集遮挡行人问题在损失函数做了一些改进。其想法也很简单，对于密集遮挡问题，如何处理同一个GT对应的多个候选框以及不同的GT对应的候选框？类似磁铁原理，同性相斥异性相吸，RepLoss使同一个GT对应的多个候选框尽量的紧凑聚集，不同GT对应的候选框尽量远离，有点类似triplet loss的想法。函数设计如下：
其中LAttr是吸引损失，其实就是常规使用回归损失smoothL1，RepGT和RepBox分为两个排斥损失，第一个使proposals远离具有第二大IoU的GT，第二个使不同GT对应的proposals尽量远离。
注意，第一个loss中作者使用了IoG而不是传统的IoU，原因在于GT无法改变，如果使用IoU则网络可以通过放大proposal的方式来降低loss，这并不是我们所期望的。如果直接使用IoG，分母是GT的面积无法改变，从而规避了这样的问题。
其中这个Smooth_ln是针对0到1的输入变量设计的一个鲁棒函数，具体形状如下所示：
可以看到，正如Smooth_l1不会对特别大的偏差给予过大的惩罚，Smooth_ln对于很小接近于1的输入也不会像原始的ln函数一样给予负无穷那么大的loss，从而可以稳定训练过程，而且对抗一些离群点。
NMS对错误率的影响曲线，相对于基线，RepLoss的曲线会更加平滑，且在各个阈值都要优于基线方法。
参考：
[1] Wang, X., Xiao, T., Jiang, Y., Shao, S., Sun, J., &amp; Shen, C. (2017). Repulsion Loss: Detecting Pedestrians in a Crowd. arXiv preprint arXiv:1711.07752.
[2] Zhang, S., Wen, L., Bian, X., Lei, Z." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7b1e3deeda0d77e271e9dcc7f241b014/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-22T17:21:46+08:00" />
<meta property="article:modified_time" content="2019-05-22T17:21:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从损失函数解决关于密集遮挡人群的检测问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;">关于密集遮挡的行人检测</p> 
<p style="margin-left:0cm;">行人检测是计算机视觉领域的一个重要研究课题，在自动驾驶，视频监控和机器人等各种应用，旨在预测一系列行人实例的边界框。实际上，在现实生活中的复杂情景中，遮挡是行人检测的最重要挑战之一，尤其是在拥挤的场景中。例如在CityPersons数据集中48.8 ％行人其它行人互相遮挡。以前的方法只要求每个预测的边界框都接近其指定的GT，而不考虑它们之间的关系。因此，它们使得检测器对拥挤场景中的非最大抑制（NMS）的阈值敏感，这种密集遮挡问题并不能单靠调整NMS阈值来解决，较大的NMS阈值导致很多误检，较小的NMS阈值导致很多漏检。</p> 
<p style="margin-left:0cm;">有些论文专门提出方法来解决密集和遮挡问题，本文将关注Occlusion-aware R-CNN:Detecting Pedestrians in a Crowd（简称为OR-CNN）和Repulsion Loss两个解决方案。</p> 
<p style="margin-left:0cm;">1.OR-CNN</p> 
<p style="margin-left:0cm;">该论文以Faster R-CNN为基础，对损失函数部分和RoIPooling两个部分分别做出了一些改进。本博客将主要关注对损失函数改进的部分，提出聚集损失（AggLoss）来改进密集遮挡问题。</p> 
<p style="margin-left:0cm;">Faster R-CNN是两阶段检测方法，分别在RPN和R-CNN头部网络检测。为了在RPN模块中能有效的生成更加准确的区域候选框，设计了AggLoss使候选框尽量的靠近对应的GT，并且同一个GT对应的所有proposal boxes尽量紧凑。其定义如下：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="389" src="https://images2.imgbox.com/75/a6/ZJ6DdlBO_o.png" width="831"></p> 
<p style="margin-left:0cm;">损失函数包含两个部分，分类损失和AggLoss，其中分类损失是与原始论文一样，使用交叉熵损失。AggLoss定义如下：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="371" src="https://images2.imgbox.com/cb/b2/uCroNED5_o.png" width="816"></p> 
<p style="margin-left:0cm;">      AggLoss 包含常规的回归损失用于使proposal boxes尽量靠近GT，同时还有一个compactness loss，Lcom，用于使同一个GT对应的多个proposal boxes之间尽量紧凑，定义如下：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="518" src="https://images2.imgbox.com/8a/65/m8GZkqY9_o.png" width="814">    </p> 
<p style="margin-left:0cm;">      由以上定义可知，Lcom是专门针对一个GT对应了多个anchor的情况，让同一个GT对应的候选框之间尽量的紧凑，通过计算GT与多个候选框的均值之间的smoothL1实现。</p> 
<p style="margin-left:0cm;">      AggLoss的思想非常简单，损失设计也很简洁，只是在原来的损失基础上增加了一个Lcom，从而达到了使候选框尽量的靠近对应的GT，并且同一个GT对应的所有proposal boxes尽量紧凑的目的。效果很赞，在多个公开数据集上达到了SOTA，作者对比了使用原始损失和AggLoss的区别，见下图。</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="600" src="https://images2.imgbox.com/5d/40/aOoIfkKJ_o.png" width="844"></p> 
<p style="margin-left:0cm;">这两个图很有意思，能反映一些问题，图a是没有使用NMS的预测结果，可以明显看出AggLoss的预测结果更好，基线的预测结果框比较分散，AggLoss的结果同一个GT的框更加紧凑，这种情况使用NMS可轻松去掉冗余框而不会出现漏检或者误检。图b是NMS阈值对预测结果的影响，对于基线方法0.55是一个分水岭，NMS阈值小于0.55时，错误率一直下降，但是超过0.55之后错误率大幅增加。对于AggLoss情况，错误率曲线更加平滑，首先整体错误率比基线更低，其次NMS阈值对AggLoss的影响没那么大，而且NMS阈值增加到0.55继续增加也不会出现错误率上升的情况，因为AggLoss的预测框更加紧凑，使用NMS很容易过滤冗余框。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">2. 互斥损失</p> 
<p style="margin-left:0cm;">      Repulsion Loss是旷视提出的，针对密集遮挡行人问题在损失函数做了一些改进。其想法也很简单，对于密集遮挡问题，如何处理同一个GT对应的多个候选框以及不同的GT对应的候选框？类似磁铁原理，同性相斥异性相吸，RepLoss使同一个GT对应的多个候选框尽量的紧凑聚集，不同GT对应的候选框尽量远离，有点类似triplet loss的想法。函数设计如下：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="213" src="https://images2.imgbox.com/ad/05/m52QAUoZ_o.png" width="484"></p> 
<p style="margin-left:0cm;">其中LAttr是吸引损失，其实就是常规使用回归损失smoothL1，RepGT和RepBox分为两个排斥损失，第一个使proposals远离具有第二大IoU的GT，第二个使不同GT对应的proposals尽量远离。</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="349" src="https://images2.imgbox.com/f8/54/bJRRQmbs_o.png" width="748"></p> 
<p style="margin-left:0cm;">注意，<strong>第一个</strong><strong>loss</strong><strong>中作者使用了</strong><strong>IoG</strong><strong>而不是传统的</strong><strong>IoU</strong><strong>，原因在于</strong><strong>GT</strong><strong>无法改变，如果使用</strong><strong>IoU</strong><strong>则网络可以通过放大</strong><strong>proposal</strong><strong>的方式来降低</strong><strong>loss</strong>，这并不是我们所期望的。如果直接使用IoG，分母是GT的面积无法改变，从而规避了这样的问题。</p> 
<p style="margin-left:0cm;">其中这个Smooth_ln是针对0到1的输入变量设计的一个鲁棒函数，具体形状如下所示：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="412" src="https://images2.imgbox.com/db/46/7vkZFzBn_o.png" width="539"></p> 
<p style="margin-left:0cm;">可以看到，正如Smooth_l1不会对特别大的偏差给予过大的惩罚，Smooth_ln对于很小接近于1的输入也不会像原始的ln函数一样给予负无穷那么大的loss，从而可以稳定训练过程，而且对抗一些离群点。</p> 
<p style="margin-left:0cm;">      NMS对错误率的影响曲线，相对于基线，RepLoss的曲线会更加平滑，且在各个阈值都要优于基线方法。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">参考：</p> 
<p style="margin-left:0cm;">[1] Wang, X., Xiao, T., Jiang, Y., Shao, S., Sun, J., &amp; Shen, C. (2017). Repulsion Loss: Detecting Pedestrians in a Crowd. <em>arXiv preprint arXiv:1711.07752</em>.</p> 
<p style="margin-left:0cm;">[2] Zhang, S., Wen, L., Bian, X., Lei, Z., &amp; Li, S. Z. (2018). Occlusion-aware R-CNN: Detecting Pedestrians in a Crowd. <em>arXiv preprint arXiv:1807.08407</em>.</p> 
<p style="margin-left:0cm;">[3] https://zhuanlan.zhihu.com/p/43655912</p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0dcf827a259020f741438b0aa855e773/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CRNN代码解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/767b5e38ef3a079b26a4d5908d9b08b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot整合IBM MQ 连接发送和接受</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>