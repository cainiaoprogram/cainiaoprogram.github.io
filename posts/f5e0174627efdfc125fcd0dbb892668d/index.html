<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>git创建与合并分支 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="git创建与合并分支" />
<meta property="og:description" content="文章目录 创建与合并分支分支管理的概念实际操作 解决冲突分支管理策略Bug分支Feature分支多人协作 创建与合并分支 分支管理的概念 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。
现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。
每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。
一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：
每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。
当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：
你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！
不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：
假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：
所以Git合并分支也很快！就改改指针，工作区内容也不变！
合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：
实际操作 首先，我们创建dev分支，然后切换到dev分支：
$ git checkout -b dev
git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：
$ git branch dev
$ git checkout dev
然后，用git branch命令查看当前分支：
$ git branch
git branch命令会列出所有分支，当前分支前面会标一个*号。
然后，我们就可以在dev分支上正常提交，比如对test.txt做个修改，加上一行：
Creating a new branch is quick.
然后提交：
$ git add test.txt
$ git commit -m “branch test”
现在，dev分支的工作完成，我们就可以切换回master分支：
$ git checkout master
切换回master分支后，再查看一个test.txt文件，刚才添加的内容不见了！
因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：
HEAD
│
▼
master" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f5e0174627efdfc125fcd0dbb892668d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-21T10:55:32+08:00" />
<meta property="article:modified_time" content="2023-10-21T10:55:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">git创建与合并分支</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">创建与合并分支</a></li><li><ul><li><a href="#_2" rel="nofollow">分支管理的概念</a></li><li><a href="#_40" rel="nofollow">实际操作</a></li></ul> 
  </li><li><a href="#_91" rel="nofollow">解决冲突</a></li><li><a href="#_162" rel="nofollow">分支管理策略</a></li><li><a href="#Bug_196" rel="nofollow">Bug分支</a></li><li><a href="#Feature_258" rel="nofollow">Feature分支</a></li><li><a href="#_288" rel="nofollow">多人协作</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>创建与合并分支</h2> 
<h3><a id="_2"></a>分支管理的概念</h3> 
<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。<br> 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p> 
<p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p> 
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：<br> <img src="https://images2.imgbox.com/87/0f/Ke1lEL0u_o.png" alt="在这里插入图片描述"></p> 
<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</p> 
<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br> <img src="https://images2.imgbox.com/63/e6/VKeinral_o.png" alt="master
│
▼
┌───┐    ┌───┐    ┌───┐
│   │───▶│   │───▶│   │
└───┘    └───┘    └───┘
▲
│
dev
▲
│
HEAD"></p> 
<p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p> 
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br> <img src="https://images2.imgbox.com/23/40/RQFMBOs2_o.png" alt="在这里插入图片描述"></p> 
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br> <img src="https://images2.imgbox.com/91/6a/hbrL4EpG_o.png" alt="在这里插入图片描述"></p> 
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p> 
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：<br> <img src="https://images2.imgbox.com/bd/94/1hp8aPFG_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_40"></a>实际操作</h3> 
<p>首先，我们创建dev分支，然后切换到dev分支：<br> $ git checkout -b dev<br> <img src="https://images2.imgbox.com/50/d7/N6Y43SSa_o.png" alt="在这里插入图片描述"><br> git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：<br> $ git branch dev<br> $ git checkout dev</p> 
<p>然后，用git branch命令查看当前分支：<br> $ git branch<br> <img src="https://images2.imgbox.com/2d/73/RJVfqIW9_o.png" alt="在这里插入图片描述">git branch命令会列出所有分支，当前分支前面会标一个*号。</p> 
<p>然后，我们就可以在dev分支上正常提交，比如对test.txt做个修改，加上一行：<br> Creating a new branch is quick.</p> 
<p>然后提交：<br> $ git add test.txt<br> $ git commit -m “branch test”<br> 现在，dev分支的工作完成，我们就可以切换回master分支：<br> $ git checkout master<br> <img src="https://images2.imgbox.com/8a/6d/vib3hLF6_o.png" alt="在这里插入图片描述"><br> 切换回master分支后，再查看一个test.txt文件，刚才添加的内容不见了！<img src="https://images2.imgbox.com/fd/d6/eKy1u4fU_o.png" alt="在这里插入图片描述"></p> 
<p>因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：<br> HEAD<br> │<br> ▼<br> master<br> │<br> ▼<br> ┌───┐ ┌───┐ ┌───┐ ┌───┐<br> │ │───▶│ │───▶│ │───▶│ │<br> └───┘ └───┘ └───┘ └───┘<br> ▲<br> │<br> dev</p> 
<p>现在，我们把dev分支的工作成果合并到master分支上：<br> $ git merge dev<br> <img src="https://images2.imgbox.com/68/d7/IhSu5ElG_o.png" alt="在这里插入图片描述"><br> git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。<br> <img src="https://images2.imgbox.com/22/ac/k5Ep65M5_o.png" alt="在这里插入图片描述"></p> 
<p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。<br> 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p> 
<p>合并完成后，就可以放心地删除dev分支了：<br> $ git branch -d dev<br> <img src="https://images2.imgbox.com/f2/c8/YUwCyl4M_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_91"></a>解决冲突</h2> 
<p>准备新的feature1分支，继续我们的新分支开发：<br> $ git switch -c feature1</p> 
<p>修改test.txt最后一行，改为：<br> Creating a new branch is quick AND simple.</p> 
<p>在feature1分支上提交：<br> $ git add test.txt<br> $ git commit -m “AND simple”</p> 
<p>切换到master分支：<br> $ git switch master</p> 
<p>在master分支上把test.txt文件的最后一行改为：<br> Creating a new branch is quick &amp; simple.<br> 提交：<br> $ git add test.txt<br> $ git commit -m “&amp; simple”</p> 
<p>现在，master分支和feature1分支各自都分别有新的提交，变成了这样：<br> <img src="https://images2.imgbox.com/2d/66/IsB8xKgT_o.png" alt="在这里插入图片描述"><br> 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：<br> $ git merge feature1<br> <img src="https://images2.imgbox.com/31/1a/uKuuNCYQ_o.png" alt="在这里插入图片描述"></p> 
<p>果然冲突了！Git告诉我们，test.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：<br> $ git status<br> <img src="https://images2.imgbox.com/78/75/r1lRD5Li_o.png" alt="在这里插入图片描述"></p> 
<p>我们可以直接查看readme.txt的内容：<br> $ cat test.txt<br> <img src="https://images2.imgbox.com/12/25/ahl9mk0k_o.png" alt="在这里插入图片描述"><br> Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容</p> 
<p>我们修改如下后保存：<br> Creating a new branch is quick and simple.<br> 再提交：<br> $ git add test.txt<br> $ git commit -m “conflict fixed”<br> <img src="https://images2.imgbox.com/4a/65/r5skNfeG_o.png" alt="在这里插入图片描述"></p> 
<p>现在，master分支和feature1分支变成了下图所示：<br> <img src="https://images2.imgbox.com/1c/d6/1N5pogw8_o.png" alt="在这里插入图片描述"><br> 用带参数的git log也可以看到分支的合并情况：<br> $ git log --graph --pretty=oneline --abbrev-commit<br> <img src="https://images2.imgbox.com/c3/3f/cO8KQj9O_o.png" alt="在这里插入图片描述"><br> 问题：<br> 再次把两个分支合并的时候，提示Already up to date.<br> 因为你不能让一个最新的提交往回合并！<br> 解释：<br> 在master分支下修改并提交后，此时master分支已经指向了修改后的新提交，而feature分支仍指向发生冲突的那次提交。<br> 在master分支下执行 git merge feature，会提示“Already up to date.”<br> 从内容上看，master的提交内容要比feature新；从时间轴上看，master要晚于feature。<br> 解决：<br> $ git switch feature // 切换到feature分支<br> $ git merge master // 和master合并<br> 合并成功！此时无论你切换到哪个分支，查看改文件的内容都是一样的。<br> <img src="https://images2.imgbox.com/46/f0/yWiZd3rJ_o.png" alt="在这里插入图片描述"></p> 
<p>小结：<br> 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br> 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。<br> 用git log --graph命令可以看到分支合并图。</p> 
<p>当初将本地仓库推送到远程库时，你应该是直接git push，没有加-u，本地和远程的分支没关联起来。<br> git push -u origin master<br> “我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。”</p> 
<h2><a id="_162"></a>分支管理策略</h2> 
<p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。<br> 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p> 
<p>下面我们实战一下–no-ff方式的git merge：</p> 
<p>首先，仍然创建并切换dev分支：<br> $ git switch -c dev<br> Switched to a new branch ‘dev’<br> 修改readme.txt文件，并提交一个新的commit：<br> $ git add readme.txt<br> $ git commit -m “add China”<br> <img src="https://images2.imgbox.com/3b/ff/jyzvYd2Z_o.png" alt="在这里插入图片描述"></p> 
<p>现在，我们切换回master：<br> $ git switch master</p> 
<p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：<br> （因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去）<br> $ git merge --no-ff -m “merge with no-ff” dev<br> <img src="https://images2.imgbox.com/cd/94/ZlO0nG17_o.png" alt="在这里插入图片描述"></p> 
<p>合并后，我们用git log看看分支历史：<br> $ git log --graph --pretty=oneline --abbrev-commit<br> <img src="https://images2.imgbox.com/e3/88/YVKVSuIJ_o.png" alt="在这里插入图片描述"></p> 
<p>小结：<br> 在实际开发中，我们应该按照几个基本原则进行分支管理：<br> 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br> 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；<br> 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。<br> <img src="https://images2.imgbox.com/4e/82/NbMndPbE_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Bug_196"></a>Bug分支</h2> 
<p>软件开发中有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p> 
<p>当你接到一个修复一个代号007的bug的任务时，很自然地，你想创建一个分支issue-007来修复它，但是，等等，当前正在dev上进行的工作还没有提交：<br> $ git status<br> <img src="https://images2.imgbox.com/4d/3c/6SDOOD17_o.png" alt="在这里插入图片描述"></p> 
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？<br> 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：<br> $ git stash<br> <img src="https://images2.imgbox.com/d6/94/WVeUFgWg_o.png" alt="在这里插入图片描述"></p> 
<p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p> 
<p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：<br> $ git checkout master<br> $ git checkout -b issue-007<br> <img src="https://images2.imgbox.com/4f/35/6QfKIOde_o.png" alt="在这里插入图片描述"></p> 
<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：<br> $ git add readme.txt<br> $ git commit -m “fix bug 007”<br> <img src="https://images2.imgbox.com/fa/cc/mV71mIoq_o.png" alt="在这里插入图片描述"></p> 
<p>修复完成后，切换到master分支，并完成合并，最后删除issue-007分支：<br> $ git switch master<br> $ git merge --no-ff -m “merged bug fix 007” issue-007<br> <img src="https://images2.imgbox.com/35/68/4xvnlo5H_o.png" alt="在这里插入图片描述"></p> 
<p>现在，是时候接着回到dev分支干活了！<br> $ git switch dev<br> $ git status<br> <img src="https://images2.imgbox.com/95/e2/5nhR1ijs_o.png" alt="在这里插入图片描述"></p> 
<p>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：<br> $ git stash list<br> <img src="https://images2.imgbox.com/22/51/oe6nNxvY_o.png" alt="在这里插入图片描述"></p> 
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：<br> 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；<br> 另一种方式是用git stash pop，恢复的同时把stash内容也删了：<br> $ git stash pop<br> <img src="https://images2.imgbox.com/bd/e4/TsiN3dDX_o.png" alt="在这里插入图片描述"></p> 
<p>恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：<br> $ git stash apply stash@{0}<br> 删除用：<br> $ git stash drop stash@{0}</p> 
<p>发散思维：<br> 在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。<br> 那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？<br> 有木有更简单的方法？<br> 有！<br> 同样的bug，要在dev上修复，我们只需要把5560e30 fix bug 007这个提交所做的修改“复制”到dev分支。注意：我们只想复制5560e30 fix bug 007这个提交所做的修改，并不是把整个master分支merge过来。<br> 为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支：<br> $ git branch<br> $ git cherry-pick 5560e30</p> 
<p>既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要git stash命令保存现场，才能从dev分支切换到master分支。</p> 
<h2><a id="Feature_258"></a>Feature分支</h2> 
<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。<br> 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。<br> 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p> 
<p>于是准备开发：<br> $ git switch -c feature-vulcan<br> <img src="https://images2.imgbox.com/f7/d4/WlrXhfan_o.png" alt="在这里插入图片描述"></p> 
<p>5分钟后，开发完毕：<br> $ git add vulcan.py<br> $ git status<br> <img src="https://images2.imgbox.com/8a/5b/p43LifWL_o.png" alt="在这里插入图片描述"></p> 
<p>切回dev，准备合并：<br> $ git switch dev</p> 
<p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p> 
<p>但是！<br> 就在此时，接到上级命令，因经费不足，新功能必须取消！<br> 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：<br> $ git branch -d feature-vulcan<br> 此时会error: The branch ‘feature-vulcan’ is not fully merged.<br> If you are sure you want to delete it, run ‘git branch -D feature-vulcan’.<br> 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。<br> 我们要强行删除：<br> $ git branch -D feature-vulcan</p> 
<h2><a id="_288"></a>多人协作</h2> 
<p><strong>多人协作</strong><br> 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p> 
<p>要查看远程库的信息，用git remote：<br> $ git remote<br> <img src="https://images2.imgbox.com/cb/57/InqyLUTE_o.png" alt="在这里插入图片描述"><br> 用git remote -v可以显示更详细的信息：<br> $ git remote -v<br> <img src="https://images2.imgbox.com/65/40/91h9dZs5_o.png" alt="在这里插入图片描述"><br> 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p> 
<p>推送分支<br> 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：<br> $ git push origin master<br> 如果要推送其他分支，比如dev，就改成：<br> $ git push origin dev<br> <img src="https://images2.imgbox.com/9e/10/R2DkTfhY_o.png" alt="在这里插入图片描述"><br> 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？<br> master分支是主分支，因此要时刻与远程同步；</p> 
<p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p> 
<p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p> 
<p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p> 
<p><strong>抓取分支</strong><br> 多人协作时，大家都会往master和dev分支上推送各自的修改。</p> 
<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：<br> $ git clone git@github.com:songwaimaideyasuo/learngit.git<br> 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：<br> $ git branch<br> <img src="https://images2.imgbox.com/a3/56/NqId4AIb_o.png" alt="在这里插入图片描述"></p> 
<p>现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：<br> $ git checkout -b dev origin/dev<br> <img src="https://images2.imgbox.com/74/cd/P6aomehP_o.png" alt="在这里插入图片描述"></p> 
<p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：<br> $ git add env.txt<br> $ git commit -m “add env”<br> $ git push origin dev<br> <img src="https://images2.imgbox.com/4c/4a/d03dfI4q_o.png" alt="在这里插入图片描述"></p> 
<p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：<br> $ git add env.txt<br> $ git commit -m “add new env”<br> $ git push origin dev<br> <img src="https://images2.imgbox.com/55/5b/chx87k30_o.png" alt="在这里插入图片描述"><br> 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：<br> $ git pull<br> <img src="https://images2.imgbox.com/65/b4/om79YadM_o.png" alt="在这里插入图片描述"><br> git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：<br> $ git branch --set-upstream-to=origin/dev dev<br> <img src="https://images2.imgbox.com/e8/d5/JNPErV4b_o.png" alt="在这里插入图片描述"></p> 
<p>再pull：<br> $ git pull<br> <img src="https://images2.imgbox.com/b8/19/lmm1vaHv_o.png" alt="在这里插入图片描述"></p> 
<p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：<br> $ git add env.txt<br> $ git commit -m “fix env conflict”<br> $ git push origin dev<br> <img src="https://images2.imgbox.com/d0/b0/gNIe2C2B_o.png" alt="在这里插入图片描述"></p> 
<p><strong>小结</strong><br> 因此，多人协作的工作模式通常是这样：<br> 首先，可以试图用$ git push origin 推送自己的修改；<br> 如果推送失败，则因为远程分支比你的本地更新，需要先用$ git pull试图合并；<br> 如果合并有冲突，则解决冲突，并在本地提交；<br> 没有冲突或者解决掉冲突后，再用$ git push origin 推送就能成功！<br> 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令$ git branch --set-upstream-to origin/。<br> 这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p> 
<p>查看远程库信息，使用$ git remote -v；<br> 本地新建的分支如果不推送到远程，对其他人就是不可见的；<br> 从本地推送分支，使用$ git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；<br> 在本地创建和远程分支对应的分支，使用$ git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；<br> 建立本地分支和远程分支的关联，使用$ git branch --set-upstream branch-name origin/branch-name；<br> 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0592688efc291a02cffc463775f872dd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于范围的for循环</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db57b90ce6c3594e2f6456480c7a3653/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">oracle实现搜索不区分大小写</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>