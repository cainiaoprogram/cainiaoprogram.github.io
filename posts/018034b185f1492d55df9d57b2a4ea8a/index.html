<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【云原生之k8s】Pod 基础概念 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【云原生之k8s】Pod 基础概念" />
<meta property="og:description" content="目录
一、资源限制
二、Pod 的两种使用方式
三、Pod 资源共享
四、底层容器Pause
1、Pause共享资源
1.1网络
1.2存储
1.3小结
2、Pause主要功能
3、Pod 与 Pause 结构的设计初衷
五、Pod容器的分类
1、基础容器（infrastructure container）
2、初始化容器（init container）
3、应用容器（main container）
六、操作示例
6.1、编写myapp.yaml
6.2、myapp.yaml配置资源
6.3、查看pod创建过程
6.5、编写myservice.yaml
6.6、创建myservice.yaml配置资源
6.7、编写mydb.yaml
6.8、创建mydb.yaml配置资源
6.9、chakan myapp-pod创建全过程
10、小结
七、镜像拉取策略（Image PullPolicy）
1、官方示例
2、不指定版本，查看默认拉取策略
2.1 不指定版本号创建pod
2.2 查看默认拉取策略
2.3 查看创建过程
3、测试案例（非循环命令）
3.1 创建测试案例mypod.yaml
3.2 生成mypod配置资源
3.3 查看创建过程
3.4 修改mypod.yaml
3.5 删除原有资源
3.6 更新资源
3.7 在node2节点使用curl查看头部信息
4、测试案例（循环命令）
4.1 修改mypod.yaml
4.2 生成新的 mypod.yaml 配置资源
4.3 查看pod状态
4.4 查看创建过程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/018034b185f1492d55df9d57b2a4ea8a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-10T17:07:46+08:00" />
<meta property="article:modified_time" content="2022-11-10T17:07:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【云原生之k8s】Pod 基础概念</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6" rel="nofollow">一、资源限制</a></p> 
<p id="%E4%BA%8C%E3%80%81Pod%20%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Pod%20%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" rel="nofollow">二、Pod 的两种使用方式</a></p> 
<p id="%E4%B8%89%E3%80%81Pod%20%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Pod%20%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB" rel="nofollow">三、Pod 资源共享</a></p> 
<p id="%C2%A0%E5%9B%9B%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8Pause-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%9B%9B%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8Pause" rel="nofollow"> 四、底层容器Pause</a></p> 
<p id="1%E3%80%81Pause%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#1%E3%80%81Pause%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90" rel="nofollow">1、Pause共享资源</a></p> 
<p id="1.1%E7%BD%91%E7%BB%9C-toc" style="margin-left:80px;"><a href="#1.1%E7%BD%91%E7%BB%9C" rel="nofollow">1.1网络</a></p> 
<p id="1.2%E5%AD%98%E5%82%A8-toc" style="margin-left:80px;"><a href="#1.2%E5%AD%98%E5%82%A8" rel="nofollow">1.2存储</a></p> 
<p id="1.3%E5%B0%8F%E7%BB%93-toc" style="margin-left:80px;"><a href="#1.3%E5%B0%8F%E7%BB%93" rel="nofollow">1.3小结</a></p> 
<p id="2%E3%80%81Pause%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#2%E3%80%81Pause%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD" rel="nofollow">2、Pause主要功能</a></p> 
<p id="3%E3%80%81Pod%20%E4%B8%8E%20Pause%20%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%88%9D%E8%A1%B7-toc" style="margin-left:40px;"><a href="#3%E3%80%81Pod%20%E4%B8%8E%20Pause%20%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%88%9D%E8%A1%B7" rel="nofollow">3、Pod 与 Pause 结构的设计初衷</a></p> 
<p id="%E4%BA%94%E3%80%81Pod%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81Pod%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">五、Pod容器的分类</a></p> 
<p id="1%E3%80%81%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8%EF%BC%88infrastructure%20container%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8%EF%BC%88infrastructure%20container%EF%BC%89" rel="nofollow">1、基础容器（infrastructure container）</a></p> 
<p id="2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8%EF%BC%88init%20container%EF%BC%89-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8%EF%BC%88init%20container%EF%BC%89" rel="nofollow">2、初始化容器（init container）</a></p> 
<p id="3%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%EF%BC%88main%20container%EF%BC%89-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%EF%BC%88main%20container%EF%BC%89" rel="nofollow">3、应用容器（main container）</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B" rel="nofollow">六、操作示例</a></p> 
<p id="6.1%E3%80%81%E7%BC%96%E5%86%99myapp.yaml-toc" style="margin-left:40px;"><a href="#6.1%E3%80%81%E7%BC%96%E5%86%99myapp.yaml" rel="nofollow">6.1、编写myapp.yaml</a></p> 
<p id="6.2%E3%80%81myapp.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#6.2%E3%80%81myapp.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90" rel="nofollow">6.2、myapp.yaml配置资源</a></p> 
<p id="6.3%E3%80%81%E6%9F%A5%E7%9C%8Bpod%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#6.3%E3%80%81%E6%9F%A5%E7%9C%8Bpod%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B" rel="nofollow">6.3、查看pod创建过程</a></p> 
<p id="%C2%A06.5%E3%80%81%E7%BC%96%E5%86%99myservice.yaml-toc" style="margin-left:40px;"><a href="#%C2%A06.5%E3%80%81%E7%BC%96%E5%86%99myservice.yaml" rel="nofollow"> 6.5、编写myservice.yaml</a></p> 
<p id="%C2%A06.6%E3%80%81%E5%88%9B%E5%BB%BAmyservice.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%C2%A06.6%E3%80%81%E5%88%9B%E5%BB%BAmyservice.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90" rel="nofollow"> 6.6、创建myservice.yaml配置资源</a></p> 
<p id="%C2%A06.7%E3%80%81%E7%BC%96%E5%86%99mydb.yaml-toc" style="margin-left:40px;"><a href="#%C2%A06.7%E3%80%81%E7%BC%96%E5%86%99mydb.yaml" rel="nofollow"> 6.7、编写mydb.yaml</a></p> 
<p id="%C2%A0%C2%A06.8%E3%80%81%E5%88%9B%E5%BB%BAmydb.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A06.8%E3%80%81%E5%88%9B%E5%BB%BAmydb.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90" rel="nofollow">  6.8、创建mydb.yaml配置资源</a></p> 
<p id="%C2%A06.9%E3%80%81chakan%20myapp-pod%E5%88%9B%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%C2%A06.9%E3%80%81chakan%20myapp-pod%E5%88%9B%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B" rel="nofollow"> 6.9、chakan myapp-pod创建全过程</a></p> 
<p id="10%E3%80%81%E5%B0%8F%E7%BB%93-toc" style="margin-left:40px;"><a href="#10%E3%80%81%E5%B0%8F%E7%BB%93" rel="nofollow">10、小结</a></p> 
<p id="%E4%B8%83%E3%80%81%E9%95%9C%E5%83%8F%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5%EF%BC%88Image%20PullPolicy%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E9%95%9C%E5%83%8F%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5%EF%BC%88Image%20PullPolicy%EF%BC%89" rel="nofollow">七、镜像拉取策略（Image PullPolicy）</a></p> 
<p id="1%E3%80%81%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B" rel="nofollow">1、官方示例</a></p> 
<p id="2%E3%80%81%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%EF%BC%8C%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%EF%BC%8C%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5" rel="nofollow">2、不指定版本，查看默认拉取策略</a></p> 
<p id="2.1%20%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E5%8F%B7%E5%88%9B%E5%BB%BApod-toc" style="margin-left:80px;"><a href="#2.1%20%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E5%8F%B7%E5%88%9B%E5%BB%BApod" rel="nofollow">2.1 不指定版本号创建pod</a></p> 
<p id="%C2%A02.2%20%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%C2%A02.2%20%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5" rel="nofollow"> 2.2 查看默认拉取策略</a></p> 
<p id="%C2%A02.3%20%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%C2%A02.3%20%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B" rel="nofollow"> 2.3 查看创建过程</a></p> 
<p id="3%E3%80%81%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B%EF%BC%88%E9%9D%9E%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4%EF%BC%89-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B%EF%BC%88%E9%9D%9E%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4%EF%BC%89" rel="nofollow">3、测试案例（非循环命令）</a></p> 
<p id="3.1%20%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8Bmypod.yaml-toc" style="margin-left:80px;"><a href="#3.1%20%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8Bmypod.yaml" rel="nofollow">3.1 创建测试案例mypod.yaml</a></p> 
<p id="%C2%A03.2%20%E7%94%9F%E6%88%90mypod%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90-toc" style="margin-left:80px;"><a href="#%C2%A03.2%20%E7%94%9F%E6%88%90mypod%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90" rel="nofollow"> 3.2 生成mypod配置资源</a></p> 
<p id="3.3%20%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-toc" style="margin-left:80px;"><a href="#3.3%20%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B" rel="nofollow">3.3 查看创建过程</a></p> 
<p id="3.4%20%E4%BF%AE%E6%94%B9mypod.yaml-toc" style="margin-left:80px;"><a href="#3.4%20%E4%BF%AE%E6%94%B9mypod.yaml" rel="nofollow">3.4 修改mypod.yaml</a></p> 
<p id="%C2%A03.5%20%E5%88%A0%E9%99%A4%E5%8E%9F%E6%9C%89%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%C2%A03.5%20%E5%88%A0%E9%99%A4%E5%8E%9F%E6%9C%89%E8%B5%84%E6%BA%90" rel="nofollow"> 3.5 删除原有资源</a></p> 
<p id="%C2%A03.6%20%E6%9B%B4%E6%96%B0%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%C2%A03.6%20%E6%9B%B4%E6%96%B0%E8%B5%84%E6%BA%90" rel="nofollow"> 3.6 更新资源</a></p> 
<p id="%C2%A03.7%20%E5%9C%A8node2%E8%8A%82%E7%82%B9%E4%BD%BF%E7%94%A8curl%E6%9F%A5%E7%9C%8B%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#%C2%A03.7%20%E5%9C%A8node2%E8%8A%82%E7%82%B9%E4%BD%BF%E7%94%A8curl%E6%9F%A5%E7%9C%8B%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF" rel="nofollow"> 3.7 在node2节点使用curl查看头部信息</a></p> 
<p id="4%E3%80%81%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4%EF%BC%89-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4%EF%BC%89" rel="nofollow">4、测试案例（循环命令）</a></p> 
<p id="4.1%20%E4%BF%AE%E6%94%B9mypod.yaml-toc" style="margin-left:80px;"><a href="#4.1%20%E4%BF%AE%E6%94%B9mypod.yaml" rel="nofollow">4.1 修改mypod.yaml</a></p> 
<p id="%C2%A04.2%20%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84%20mypod.yaml%20%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%C2%A04.2%20%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84%20mypod.yaml%20%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90" rel="nofollow"> 4.2 生成新的 mypod.yaml 配置资源</a></p> 
<p id="%C2%A04.3%20%E6%9F%A5%E7%9C%8Bpod%E7%8A%B6%E6%80%81-toc" style="margin-left:40px;"><a href="#%C2%A04.3%20%E6%9F%A5%E7%9C%8Bpod%E7%8A%B6%E6%80%81" rel="nofollow"> 4.3 查看pod状态</a></p> 
<p id="%C2%A04.4%20%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%C2%A04.4%20%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B" rel="nofollow"> 4.4 查看创建过程</a></p> 
<p id="%C2%A04.5%20%E6%9F%A5%E7%9C%8Bpod%E6%97%A5%E5%BF%97-toc" style="margin-left:40px;"><a href="#%C2%A04.5%20%E6%9F%A5%E7%9C%8Bpod%E6%97%A5%E5%BF%97" rel="nofollow"> 4.5 查看pod日志</a></p> 
<p id="%C2%A04.6%20%E6%A3%80%E6%9F%A5mypod.yaml%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%C2%A04.6%20%E6%A3%80%E6%9F%A5mypod.yaml%E6%96%87%E4%BB%B6" rel="nofollow"> 4.6 检查mypod.yaml文件</a></p> 
<p id="%C2%A0%E5%86%8D%E6%AC%A1%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84mypod.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%86%8D%E6%AC%A1%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84mypod.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90" rel="nofollow"> 再次生成新的mypod.yaml配置资源</a></p> 
<p id="%C2%A0%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B" rel="nofollow"> 查看创建过程</a></p> 
<p id="%E6%9F%A5%E7%9C%8Bpod%E6%97%A5%E5%BF%97-toc" style="margin-left:80px;"><a href="#%E6%9F%A5%E7%9C%8Bpod%E6%97%A5%E5%BF%97" rel="nofollow">查看pod日志</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6">一、资源限制</h2> 
<p><strong>Pod 是 kubernetes 中最小的资源管理组件</strong>，Pod 也是最小化运行容器化应用的资源对象。<strong>一个 Pod 代表着集群中运行的一个进程</strong>。<a href="https://so.csdn.net/so/search?q=kubernetes&amp;spm=1001.2101.3001.7020" title="kubernetes">kubernetes</a> 中其他大多数组件都是围绕着 Pod 来进行支撑和扩展 Pod 功能的，例如用于管理 Pod 运行的 StatefulSet 和 Deployment 等控制器对象，用于暴露 Pod 应用的 Service 和 Ingress 对象，为 Pod 提供存储的 PersistentVolume 存储资源对象等。</p> 
<h2 id="%E4%BA%8C%E3%80%81Pod%20%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><a name="t2"></a><a id="Pod__6"></a>二、Pod 的两种使用方式</h2> 
<ol><li><strong>一个 Pod 中运行一个容器</strong>。每个 Pod 中一个容器的模式是最常见的用法，在这种使用方式中，你可以把 Pod想象成是单个容器的封装，kubernetes 管理的是 Pod 而不是直接管理容器。</li><li><strong>在一个 Pod 中同时运行多个容器</strong>。一个 Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个 Pod 中的容器可以互相协作成为一个 service单位，比如一个容器共享文件，另一个 sidecar 容器来更新这些文件。Pod 将这些容器的存储资源作为一个实体来管理。</li></ol> 
<h2 id="%E4%B8%89%E3%80%81Pod%20%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><a name="t3"></a><a id="Pod__11"></a>三、Pod 资源共享</h2> 
<p>一个Pod 下的容器必须运行于同一节点上。现代容器技术建议一个容器只运行一个进程，该进程在容器中PID命令空间中的进程号为1，可直接接收并处理信号，进程终止时容器生命周期也就1结束了。</p> 
<p>       若想在容器内运行多个进程，需要有一个类似linux操作系统init进程的管控类进程，以树状结构完成多进程的生命周期管理。运行于各自容器内的进程无法完成网络通信，这是由于容器间的隔离机制导致，k8s中的Pod 资源抽象正是解决此类问题，Pod 对象是一组容器的集合，这些容器共享 Network、UTS 及 IPC 命令空间，因此具有相同的域名、主机名和网络接口，并可通过 IPC 直接通信。</p> 
<table><thead><tr><th style="text-align:center;">namespace</th><th style="text-align:center;">功能说明</th></tr></thead><tbody><tr><td style="text-align:center;">mnt</td><td style="text-align:center;">提供磁盘挂载点和文件系统的隔离能力</td></tr><tr><td style="text-align:center;">ipc</td><td style="text-align:center;">提供进程间通信的隔离能力</td></tr><tr><td style="text-align:center;">net</td><td style="text-align:center;">提供网络隔离能力</td></tr><tr><td style="text-align:center;">uts</td><td style="text-align:center;">提供主机名隔离能力</td></tr><tr><td style="text-align:center;">pid</td><td style="text-align:center;">提供进程隔离能力</td></tr><tr><td style="text-align:center;">user</td><td style="text-align:center;">提供用户隔离能力</td></tr></tbody></table> 
<h2 id="%C2%A0%E5%9B%9B%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8Pause"> 四、底层容器Pause</h2> 
<p><strong>Pod资源中针对各容器提供网络命令空间等共享机制的是底层基础容器pause</strong>，基础容器（也可称为父容器）pause就是为了管理Pod容器间的共享操作，这个父容器需要能够准确地知道如何去创建共享运行环境地容器，还能管理这些容器地生命周期。为了实现这个父容器地构想，kuberntes中，用pause容器来作为一个Pod中所有容器的父容器。<strong>这个pause容器有两个核心的功能，一是它提供整个Pod的linux命名空间的基础。二来启用PID命名空间，它在每一个Pod中都作为PID为1进程（init进程），并回收僵尸进程。</strong></p> 
<h3 id="1%E3%80%81Pause%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><strong>1、Pause共享资源</strong></h3> 
<h4 id="1.1%E7%BD%91%E7%BB%9C"><strong>1.1网络</strong></h4> 
<p>每个Pod都会被分配一个唯一的ip地址。Pod中的所有容器共享网络空间，包括IP地址和端口。</p> 
<p>Pod内部的容器可以使用localhost互相通信。Pod中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。</p> 
<h4 id="1.2%E5%AD%98%E5%82%A8"><strong>1.2存储</strong></h4> 
<p>可以Pod指定多个共享的volume。Pod中的所有容器都可以访问共享网络空间，包括IP地址和端口。</p> 
<p>volumey也可以用来持久化Pod中存储资源，以防容器重启后文件丢失。</p> 
<h4 id="1.3%E5%B0%8F%E7%BB%93">1.3小结</h4> 
<p>每个pod都有一个特殊的被称为“基础容器”的Pause容器。Pause容器对应的镜像属于kubernetes平台的一部分，除了Pause容器，每个Pod还包含一个或者多个紧密相关的用户应用容器。</p> 
<h3></h3> 
<h3 id="2%E3%80%81Pause%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">2、Pause主要功能</h3> 
<p><strong>kubernetes中的pause容器主要为每个容器提供以下功能：</strong></p> 
<p>1.在pod中担任linux命名空间（如网络命令空间）共享的基础</p> 
<p>2.启用PID命名空间，开启init进程</p> 
<p></p> 
<h3 id="3%E3%80%81Pod%20%E4%B8%8E%20Pause%20%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%88%9D%E8%A1%B7">3、Pod 与 Pause 结构的设计初衷</h3> 
<ol><li>原因一：在一组容器作为一个单元的情况下，难以对整体的容器简单地进行判断及有效地进行行动。比如，一个容器死亡了，此时是算整体挂了么？那么引入与业务无关的Pause 容器作为 Pod 的基础容器，以它的状态代表着整个容器组的状态，这样就可以解决该问题。</li><li>原因二：Pod 里的多个应用容器共享 Pause 容器的 IP，共享 Pause 容器挂载的Volume，这样简化了应用容器之间的通信问题，也解决了容器之间的文件共享问题。</li></ol> 
<h2 id="%E4%BA%94%E3%80%81Pod%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB">五、Pod容器的分类</h2> 
<h3 id="1%E3%80%81%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8%EF%BC%88infrastructure%20container%EF%BC%89"><a name="t12"></a><a id="1infrastructure_container_50"></a>1、基础容器（infrastructure container）</h3> 
<ol><li>维护整个 Pod 网络和存储空间</li><li>node 节点中操作</li><li>启动一个容器时，k8s会自动启动一个基础容器</li></ol> 
<h3 id="2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8%EF%BC%88init%20container%EF%BC%89"><a name="t13"></a><a id="2init_container_56"></a>2、初始化容器（init container）</h3> 
<p><strong>Init 容器必须在应用程序容器启动之前运行完成，而应用程序容器是并行运行的，所以 Init 容器能够提供了一种简单的阻塞或延迟应用容器的启动的方法。Init 容器与普通的容器非常像，除了以下两点：</strong></p> 
<ol><li>Init 容器总是运行到成功完成为止</li><li>每个 Init 容器都必须在下一个 Init 容器启动之前成功完成启动和退出</li></ol> 
<p><strong>如果 Pod 的 Init 容器失败，k8s 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的重启策略（restartPolicy）为 Never，它不会重新启动。</strong></p> 
<p><span style="color:#4da8ee;">Init 的容器作用</span></p> 
<p><strong>因为 init 容器具有与应用容器分离的单独镜像，其启动相关代码具有如下优势：</strong></p> 
<ol><li>Init 容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码。例如，没有必要仅为了在安装过程中使用类似 sed、 awk、python 或 dig 这样的工具而去 FROM 一个镜像来生成一个新的镜像。</li><li>Init 容器可以安全地运行这些工具，避免这些工具导致应用镜像的安全性降低。</li><li>应用镜像的创建者和部署者可以各自独立工作，而没有必要联合构建一个单独的应用镜像。</li><li>Init 容器能以不同于 Pod 内应用容器的文件系统视图运行。因此，Init 容器可具有访问 Secrets的权限，而应用容器不能够访问。</li><li>由于 Init 容器必须在应用容器启动之前运行完成，因此 Init容器提供了一种机制来阻塞或延迟应用容器的启动，直到满足了一组先决条件。一旦前置条件满足，Pod 内的所有的应用容器会并行启动。</li></ol> 
<h3 id="3%E3%80%81%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%EF%BC%88main%20container%EF%BC%89">3、应用容器（main container）</h3> 
<p>应用容器会在 init 容器完成并退出后并行启动。</p> 
<h2 id="%E5%85%AD%E3%80%81%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B">六、操作示例</h2> 
<h3 id="6.1%E3%80%81%E7%BC%96%E5%86%99myapp.yaml"><a name="t15"></a>6.1、编写myapp.yaml</h3> 
<blockquote> 
 <p>apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: myapp-pod<br>   labels:<br>     app: myapp<br> spec:<br>   containers:<br>   - name: myapp-container<br>     image: busybox:1.28<br>     command: ['sh','-c','echo The app is running! &amp;&amp; sleep 3600']<br>   initContainers:<br>   - name: init-myservice<br>     image: busybox:1.28<br>     command: ['sh','-c','until nslookup myservice;do echo waiting for myservice; sleep2; done;']<br>   - name: init-mydb<br>     image: busybox:1.28<br>     command: ['sh','-c','until nslookup mydb; do echo waiting for mydb; sleep 2; done;']</p> 
</blockquote> 
<p> <img alt="" height="412" src="https://images2.imgbox.com/d7/b2/o1CIwZU9_o.png" width="1120"></p> 
<p>  这个例子是定义了一个具有 2 个 Init 容器的简单 Pod。 第一个等待 myservice 启动， 第二个等待 mydb 启动。一旦这两个 Init 容器都启动完成，Pod 将启动 spec 中的应用容器。</p> 
<h3 id="6.2%E3%80%81myapp.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90">6.2、myapp.yaml配置资源</h3> 
<blockquote> 
 <p>kubectl apply -f myapp.yaml<br> kubectl get pod</p> 
</blockquote> 
<p> <img alt="" height="263" src="https://images2.imgbox.com/8a/2f/T8jhQFbY_o.png" width="761"></p> 
<p><span style="color:#fe2c24;">  该pod会一直处于init:0/2状态</span></p> 
<h3 id="6.3%E3%80%81%E6%9F%A5%E7%9C%8Bpod%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B">6.3、查看pod创建过程</h3> 
<blockquote> 
 <p>kubectl describe pod myapp-pod</p> 
</blockquote> 
<p> <img alt="" height="501" src="https://images2.imgbox.com/c2/93/bFRNgCqG_o.png" width="853"></p> 
<p>  发现开启 init-myservice 容器后，创建步骤停滞，<strong>查看 init-myservice 日志进一步查明原因</strong></p> 
<blockquote> 
 <p> kubectl logs myapp-pod -c init-myservice</p> 
</blockquote> 
<p><img alt="" height="105" src="https://images2.imgbox.com/a0/2d/p1pxSy3B_o.png" width="894"></p> 
<h3 id="%C2%A06.5%E3%80%81%E7%BC%96%E5%86%99myservice.yaml"> 6.5、编写myservice.yaml</h3> 
<blockquote> 
 <p>[root@master ~]# vim myservice.yaml<br>  <br> apiVersion: v1<br> kind: Service<br> metadata:<br>   name: myservice<br> spec:<br>   ports:<br>   - protocol: TCP<br>     port: 80<br>     targetPort: 1111</p> 
</blockquote> 
<p> <img alt="" height="226" src="https://images2.imgbox.com/0a/b6/UOLHjZvU_o.png" width="705"></p> 
<h3 id="%C2%A06.6%E3%80%81%E5%88%9B%E5%BB%BAmyservice.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90"> 6.6、创建myservice.yaml配置资源</h3> 
<blockquote> 
 <p>kubectl create -f myservice.yaml </p> 
</blockquote> 
<p> <img alt="" height="242" src="https://images2.imgbox.com/cc/e8/UdPa6lFY_o.png" width="888"></p> 
<h3 id="%C2%A06.7%E3%80%81%E7%BC%96%E5%86%99mydb.yaml"> 6.7、编写mydb.yaml</h3> 
<blockquote> 
 <p>[root@master ~]# vim mydb.yaml<br>  <br> apiVersion: v1<br> kind: Service<br> metadata:<br>   name: mydb<br> spec:<br>   ports:<br>   - protocol: TCP<br>     port: 80<br>     targetPort: 2222</p> 
</blockquote> 
<p> <img alt="" height="317" src="https://images2.imgbox.com/2c/e3/EucDlB4N_o.png" width="728"></p> 
<h3 id="%C2%A0%C2%A06.8%E3%80%81%E5%88%9B%E5%BB%BAmydb.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90">  6.8、创建mydb.yaml配置资源</h3> 
<blockquote> 
 <p>kubectl create -f mydb.yaml<br> kubectl get pod,svc</p> 
</blockquote> 
<p> <img alt="" height="367" src="https://images2.imgbox.com/73/16/Smq8gxOM_o.png" width="1023"></p> 
<h3 id="%C2%A06.9%E3%80%81chakan%20myapp-pod%E5%88%9B%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B"> 6.9、chakan myapp-pod创建全过程</h3> 
<blockquote> 
 <p>kubectl describe pod myapp-pod</p> 
</blockquote> 
<p><img alt="" height="501" src="https://images2.imgbox.com/27/d9/HsDdcdc1_o.png" width="1070"></p> 
<p> </p> 
<ol><li>创建过程中第一次停滞，是 init-myservice 容器启动后，未能发现 myservice 域名，无法得到解析，因此陷入循环。</li><li>第二次停滞，是 init-mydb 容器启动后，未能发现 mydb 域名，无法得到解析，因此再次陷入循环中。</li><li>在上述两个 init 容器成功并退出后，myapp-pod 才开始创建，否则 pod 无法创建</li></ol> 
<h3 id="10%E3%80%81%E5%B0%8F%E7%BB%93">10、小结</h3> 
<ol><li><strong>在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。</strong></li><li>如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 restartPolicy 指定的策略进行重试。然而，如果 Pod的 restartPolicy <strong>设置为 Always</strong>，Init 容器失败时会使用 RestartPolicy 策略。</li><li>在所有的 Init 容器没有成功之前，Pod 将不会变成 Ready 状态。Init 容器的端口将不会在 Service中进行聚集。正在初始化中的 Pod 处于 Pending 状态，但应该会将 Initializing 状态设置为 true。</li><li>如果 Pod 重启，所有 Init 容器必须重新执行。</li><li>对 <strong>Init 容器 spec 的修改被限制在容器 image 字段，修改其他字段都不会生效。更改 Init 容器的 image字段，等价于重启该 Pod。</strong></li><li>Init 容器具有应用容器的所有字段。除了 readinessProbe，因为 <strong>Init容器无法定义不同于完成（completion）的就绪（readiness）之外的其他状态</strong>。这会在验证过程中强制执行。</li><li>在 Pod 中的每个 app 和 Init 容器的名称必须唯一；与任何其它容器共享同一个名称，会在验证时抛出错误。</li></ol> 
<h2 id="%E4%B8%83%E3%80%81%E9%95%9C%E5%83%8F%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5%EF%BC%88Image%20PullPolicy%EF%BC%89">七、镜像拉取策略（Image PullPolicy）</h2> 
<p><strong>Pod的核心是运行容器，必须指定容器引擎，比如Docker,启动容器时需要拉取镜像，k8s的镜像拉取策略可以由用户指定：</strong></p> 
<ol><li>IfNotPresent:在镜像已经存在的情况下，kubelet将不再去拉取镜像，仅当本地缺失时才会从仓库中拉取，<strong>默认的镜像拉取策略</strong>。</li><li>Alaways:每次创建Pod都会重新拉取一次镜像</li><li>Never:Pod不会主动拉取这个镜像，仅使用本地镜像。</li></ol> 
<p><strong>注意：对于标签为latest的镜像文件，其默认的镜像获取策略即为Always；而对于其他标签的镜像，其默认策略则为IfNotPresent。</strong></p> 
<h3 id="1%E3%80%81%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B">1、官方示例</h3> 
<p><strong>创建使用私有镜像的 Pod 来验证</strong></p> 
<pre><code class="language-bash">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: private-image-test-1
spec:
  containers:
    - name: uses-private-image
      image: $PRIVATE_IMAGE_NAME
      imagePullPolicy: Always
      command: [ "echo", "SUCCESS" ]
EOF
</code></pre> 
<p><strong>输出类似于</strong></p> 
<blockquote> 
 <p><strong>pod/private-image-test-1 created</strong></p> 
</blockquote> 
<p> <strong>如果一切顺利，那么一段时间后你可以执行</strong></p> 
<blockquote> 
 <p><strong>kubectl logs private-image-test-1</strong></p> 
</blockquote> 
<p> <strong>然后可以看到 SUCCESS，如果你怀疑命令失败了，可以运行</strong></p> 
<blockquote> 
 <p><strong>kubectl describe pods/private-image-test-1 | grep 'Failed'</strong></p> 
</blockquote> 
<p> <strong>如果命令确实失败了，输出类似于</strong></p> 
<blockquote> 
 <p><strong>Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image "user/privaterepo:v1": Error: image user/privaterepo:v1 not found</strong></p> 
</blockquote> 
<ol><li>必须确保集群中所有节点的 .docker/config.json 文件内容相同。 否则 Pod会能在一些节点上正常运行而无法在另一些节点上启动。 例如，如果使用节点自动扩缩，那么每个实例模板都需要包含.docker/config.json，或者挂载一个包含该文件的驱动器。</li><li>在 .docker/config.json 中配置了私有仓库密钥后，所有 Pod 都将能读取私有仓库中的镜像。</li></ol> 
<h3 id="2%E3%80%81%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%EF%BC%8C%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5">2、不指定版本，查看默认拉取策略</h3> 
<h4 id="2.1%20%E4%B8%8D%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E5%8F%B7%E5%88%9B%E5%BB%BApod"><a name="t29"></a><a id="21_pod_256"></a>2.1 不指定版本号创建pod</h4> 
<blockquote> 
 <p>kubectl run nginx-test1 --image=nginx</p> 
</blockquote> 
<p> <img alt="" height="261" src="https://images2.imgbox.com/6f/cd/1SSdprDC_o.png" width="799"></p> 
<h4 id="%C2%A02.2%20%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5"> 2.2 查看默认拉取策略</h4> 
<blockquote> 
 <p>kubectl edit pod nginx-test1</p> 
</blockquote> 
<p> <img alt="" height="409" src="https://images2.imgbox.com/d1/ae/Fc2iuKox_o.png" width="957"></p> 
<h3 id="%C2%A02.3%20%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"> 2.3 查看创建过程</h3> 
<blockquote> 
 <p>kubectl describe pod nginx-test1</p> 
</blockquote> 
<p> <img alt="" height="372" src="https://images2.imgbox.com/ed/f5/CLyMScvZ_o.png" width="1006"></p> 
<p> 由于拉取策略为Always,因此不管本地有没有对应镜像，kubectl都会前往共有仓库下载最新版本应用。</p> 
<h3 id="3%E3%80%81%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B%EF%BC%88%E9%9D%9E%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4%EF%BC%89">3、测试案例（非循环命令）</h3> 
<h4 id="3.1%20%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8Bmypod.yaml"><a name="t33"></a><a id="31_mypodyaml_280"></a>3.1 创建测试案例mypod.yaml</h4> 
<blockquote> 
 <p>[root@master ~]# vim mypod.yaml </p> 
 <p>apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: mypod<br> spec:<br>   containers:<br>     - name: nginx<br>       image: nginx<br>       imagePullPolicy: Always<br>       command: [ "echo","SUCCESS" ]</p> 
</blockquote> 
<h4 id="%C2%A03.2%20%E7%94%9F%E6%88%90mypod%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90"> 3.2 生成mypod配置资源</h4> 
<blockquote> 
 <p>kubectl create -f mypod.yaml<br> kubectl get pods</p> 
</blockquote> 
<p><img alt="" height="311" src="https://images2.imgbox.com/45/5e/RtlrovXj_o.png" width="880"></p> 
<p> 该pod状态为CrashLoopBackOff，说明pod进入异常循环状态。原因是echo执行完进程终止，容器声明周期也就结束了。</p> 
<h4 id="3.3%20%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B">3.3 查看创建过程</h4> 
<blockquote> 
 <p>kubectl describe pod mypod</p> 
</blockquote> 
<p><img alt="" height="520" src="https://images2.imgbox.com/75/57/bPhtBFIk_o.png" width="1026"></p> 
<p> <strong>可以发现 Pod 中的容器在生命周期结束后，由于 Pod 的重启策略为 Always，容器再次重启了，并且又重新开始拉取镜像。</strong></p> 
<h4 id="3.4%20%E4%BF%AE%E6%94%B9mypod.yaml">3.4 修改mypod.yaml</h4> 
<p><strong>失败的状态的原因是因为命令启动冲突</strong><br> 删除 command: [ “echo”, “SUCCESS” ]<br><strong>同时更改一下版本</strong><br> image: nginx:1.14</p> 
<blockquote> 
 <p>vim mypod.yaml</p> 
</blockquote> 
<p> <img alt="" height="272" src="https://images2.imgbox.com/bb/3e/hQFfENB7_o.png" width="510"></p> 
<h3 id="%C2%A03.5%20%E5%88%A0%E9%99%A4%E5%8E%9F%E6%9C%89%E8%B5%84%E6%BA%90"> 3.5 删除原有资源</h3> 
<blockquote> 
 <p>kubectl delete -f mypod.yamv</p> 
</blockquote> 
<p> <img alt="" height="98" src="https://images2.imgbox.com/44/f0/57NYI2G0_o.png" width="537"></p> 
<h3 id="%C2%A03.6%20%E6%9B%B4%E6%96%B0%E8%B5%84%E6%BA%90"> 3.6 更新资源</h3> 
<blockquote> 
 <p>kubectl apply -f mypod.yaml</p> 
 <p>#查看分配节点<br> kubectl get pods -o wide</p> 
</blockquote> 
<p> <img alt="" height="340" src="https://images2.imgbox.com/f2/1c/pkYxFBEx_o.png" width="1081"></p> 
<p> </p> 
<h3 id="%C2%A03.7%20%E5%9C%A8node2%E8%8A%82%E7%82%B9%E4%BD%BF%E7%94%A8curl%E6%9F%A5%E7%9C%8B%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF"> 3.7 在node2节点使用curl查看头部信息</h3> 
<p><img alt="" height="197" src="https://images2.imgbox.com/b3/2a/5IfqEsk7_o.png" width="453"></p> 
<p> </p> 
<h3 id="4%E3%80%81%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%91%BD%E4%BB%A4%EF%BC%89">4、测试案例（循环命令）</h3> 
<h4 id="4.1%20%E4%BF%AE%E6%94%B9mypod.yaml"><a name="t41"></a><a id="41_mypodyaml_349"></a>4.1 修改mypod.yaml</h4> 
<blockquote> 
 <p>[root@master ~]# vim mypod.yaml </p> 
 <p>apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: mypod<br> spec:<br>   containers:<br>     - name: nginx<br>       image: nginx<br>       imagePullPolicy: IfNotPresent<br>       command: [ "sh","while true;do echo SUCCESS;done" ]</p> 
</blockquote> 
<p><img alt="" height="210" src="https://images2.imgbox.com/5c/1d/8rccGGSZ_o.png" width="862"></p> 
<h3 id="%C2%A04.2%20%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84%20mypod.yaml%20%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90"><strong> 4.2 生成新的 mypod.yaml 配置资源</strong></h3> 
<p><img alt="" height="77" src="https://images2.imgbox.com/b9/22/uHNz0v2s_o.png" width="441"></p> 
<h3 id="%C2%A04.3%20%E6%9F%A5%E7%9C%8Bpod%E7%8A%B6%E6%80%81"> 4.3 查看pod状态</h3> 
<blockquote> 
 <p>kubectl get pod -o wide</p> 
</blockquote> 
<p> <img alt="" height="518" src="https://images2.imgbox.com/13/f4/0OifV1aI_o.png" width="1012"></p> 
<h3 id="%C2%A04.4%20%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"> 4.4 查看创建过程</h3> 
<blockquote> 
 <p>kubectl describe pod mypod</p> 
</blockquote> 
<p><img alt="" height="380" src="https://images2.imgbox.com/4a/6a/9LWuH9Lj_o.png" width="1015"> </p> 
<h3 id="%C2%A04.5%20%E6%9F%A5%E7%9C%8Bpod%E6%97%A5%E5%BF%97"> 4.5 查看pod日志</h3> 
<blockquote> 
 <p>kubectl logs mypod</p> 
</blockquote> 
<p><img alt="" height="46" src="https://images2.imgbox.com/b0/29/1mcX0T4U_o.png" width="697"></p> 
<h3 id="%C2%A04.6%20%E6%A3%80%E6%9F%A5mypod.yaml%E6%96%87%E4%BB%B6"> 4.6 检查mypod.yaml文件</h3> 
<blockquote> 
 <p>vim mypod.yaml</p> 
</blockquote> 
<p> <img alt="" height="192" src="https://images2.imgbox.com/25/33/biETX9p1_o.png" width="730"></p> 
<h3 id="%C2%A0%E5%86%8D%E6%AC%A1%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84mypod.yaml%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90"> 再次生成新的mypod.yaml配置资源</h3> 
<blockquote> 
 <p>#删除原有的资源<br> kubectl delete -f mypod.yaml<br>  <br> #生成新的资源<br> kubectl apply -f mypod.yaml</p> 
</blockquote> 
<p> <img alt="" height="369" src="https://images2.imgbox.com/6f/3b/jd7JBDuB_o.png" width="844"></p> 
<h3 id="%C2%A0%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"> 查看创建过程</h3> 
<blockquote> 
 <p>kubectl describe pod mypod</p> 
</blockquote> 
<p> <img alt="" height="149" src="https://images2.imgbox.com/76/74/jAARNHoM_o.png" width="875"></p> 
<p>  由于镜像拉取策略设定的是 IfNotPresent，因此 kubelet 会先检查本地镜像仓库，如果有对应版本镜像就直接使用，没有的话才会前往镜像仓库拉取。</p> 
<h4 id="%E6%9F%A5%E7%9C%8Bpod%E6%97%A5%E5%BF%97">查看pod日志</h4> 
<p><img alt="" height="209" src="https://images2.imgbox.com/38/e7/WHKRazhv_o.png" width="490"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2ea167cd78ef3f6c89a366568ad2cff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机视觉学习路线</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5222c87dc9ddd8dca70d5c829065c88/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在Windows环境下配置及安装Nacos</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>