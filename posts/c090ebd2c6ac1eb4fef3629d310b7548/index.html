<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python中import的用法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python中import的用法" />
<meta property="og:description" content="我的小程序： 待办计划：卷起来吧，少年！ 我们记账：年薪50w够花么？ Python用了快两年了吧，其中有些东西一直是稀里糊涂地用，import便是我一直没有明白的东西。曾经有过三次解决它的机会，我都因得过且过、一拖再拖而没能化敌为友。今天下午，它又给了我一次机会，我想我还是从了它的心愿吧。
故事是从这篇台湾同胞的博客（Python 的 Import 陷阱）开始的，然后又跳到了Python社区的PEP 328提案（PEP 328 -- Imports: Multi-Line and Absolute/Relative），再结合过去的经验以及一些测试，我想我大概懂了吧。下面是我的总结，希望内容能够言简意赅、易于理解。
import语句有什么用？import语句用来导入其他python文件（称为模块module），使用该模块里定义的类、方法或者变量，从而达到代码复用的目的。为了方便说明，我们用实例来说明import的用法，读者朋友可以跟着尝试（尝试时建议使用python3，python2和python3在import的表现有差异，之后会提到）。
首先，先建立一个文件夹Tree作为工作目录，并在其内建立两个文件m1.py和m2.py，在m1.py写入代码：
import os import m2 m2.printSelf() 在m2.py写入代码：
def printSelf(): print(&#39;In m2&#39;) 打开命令行，进入到Tree目录下，敲下python m1.py运行，发现没有报错，且打印出In m2，说明这样使用import没有问题。由此我们总结出import语句的第一种用法。
import module_name。即import后直接接模块名。在这种情况下，Python会在两个地方寻找这个模块，第一是sys.path（通过运行代码import sys; print(sys.path)查看），os这个模块所在的目录就在列表sys.path中，一般安装的Python库的目录都可以在sys.path中找到（前提是要将Python的安装目录添加到电脑的环境变量），所以对于安装好的库，我们直接import即可。第二个地方就是运行文件（这里是m1.py）所在的目录，因为m2.py和运行文件在同一目录下，所以上述写法没有问题。 用上述方法导入原有的sys.path中的库没有问题。但是，最好不要用上述方法导入同目录下的文件！因为这可能会出错。演示这个错误需要用到import语句的第二种写法，所以先来学一学import的第二种写法。在Tree目录下新建一个目录Branch，在Branch中新建文件m3.py，m3.py的内容如下：
def printSelf(): print(&#39;In m3&#39;) 如何在m1中导入m3.py呢，请看更改后的m1.py：
from Branch import m3 m3.printSelf() 总结import语句的第二种用法：
from package_name import module_name。一般把模块组成的集合称为包（package）。与第一种写法类似，Python会在sys.path和运行文件目录这两个地方寻找包，然后导入包中名为module_name的模块。 现在我们来说明为什么不要用import的第一种写法来导入同目录下的文件。在Branch目录下新建m4.py文件，m4.py的内容如下：
def printSelf(): print(&#39;In m4&#39;) 然后我们在m3.py中直接导入m4，m3.py变为：
import m4 def printSelf(): print(&#39;In m3&#39;) 这时候运行m1.py就会报错了，说没法导入m4模块。为什么呢？我们来看一下导入流程：m1使用from Branch import m3导入m3，然后在m3.py中用import m4导入m4。看出问题了吗？m4.py和m1.py不在同一目录，怎么能直接使用import m4导入m4呢。（读者可以试试直接在Tree目录下新建另一个m4.py文件，你会发现再运行m1.py就不会出错了，只不过导入的是第二个m4.py了）
面对上面的错误，使用python2运行m1.py就不会报错，因为在python2中，上面提到的import的两种写法都属于相对导入，而在python3中，却属于绝对导入。话说到了这里，就要牵扯到import中最关键的部分了——相对导入和绝对导入。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c090ebd2c6ac1eb4fef3629d310b7548/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-01T12:29:33+08:00" />
<meta property="article:modified_time" content="2023-02-01T12:29:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python中import的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><span style="color:#fe2c24;"><strong>我的小程序：</strong></span></h4> 
<figure class="image left"> 
 <img alt="" height="200" src="https://images2.imgbox.com/e5/a8/59rO3hn6_o.jpg" width="200"> 
 <figcaption> 
  <strong>待办计划：卷起来吧，少年！</strong> 
 </figcaption> 
</figure> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="200" src="https://images2.imgbox.com/25/f0/XiFShaAf_o.jpg" width="200"> 
  <figcaption> 
   <strong>我们记账：年薪50w够花么？</strong> 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p>Python用了快两年了吧，其中有些东西一直是稀里糊涂地用，import便是我一直没有明白的东西。曾经有过三次解决它的机会，我都因得过且过、一拖再拖而没能化敌为友。今天下午，它又给了我一次机会，我想我还是从了它的心愿吧。</p> 
<p>故事是从这篇台湾同胞的博客（<a href="https://link.zhihu.com/?target=https%3A//medium.com/pyladies-taiwan/python-%25E7%259A%2584-import-%25E9%2599%25B7%25E9%2598%25B1-3538e74f57e3" rel="nofollow" title="Python 的 Import 陷阱">Python 的 Import 陷阱</a>）开始的，然后又跳到了Python社区的PEP 328提案（<a href="https://link.zhihu.com/?target=https%3A//www.python.org/dev/peps/pep-0328/%23id1" rel="nofollow" title="PEP 328 -- Imports: Multi-Line and Absolute/Relative">PEP 328 -- Imports: Multi-Line and Absolute/Relative</a>），再结合过去的经验以及一些测试，我想我大概懂了吧。下面是我的总结，希望内容能够言简意赅、易于理解。</p> 
<p>import语句有什么用？import语句用来导入其他python文件（称为模块module），使用该模块里定义的类、方法或者变量，从而达到代码复用的目的。为了方便说明，我们用实例来说明import的用法，读者朋友可以跟着尝试（尝试时建议使用python3，python2和python3在import的表现有差异，之后会提到）。</p> 
<p>首先，先建立一个文件夹Tree作为工作目录，并在其内建立两个文件m1.py和m2.py，在m1.py写入代码：</p> 
<pre><code>import os
import m2
m2.printSelf()</code></pre> 
<p>在m2.py写入代码：</p> 
<pre><code>def printSelf():
	print('In m2')</code></pre> 
<p>打开命令行，进入到Tree目录下，敲下<code>python m1.py</code>运行，发现没有报错，且打印出<code>In m2</code>，说明这样使用import没有问题。由此我们总结出import语句的第一种用法。</p> 
<ul><li><code>import module_name</code>。即import后直接接模块名。在这种情况下，Python会在两个地方寻找这个模块，第一是sys.path（通过运行代码<code>import sys; print(sys.path)</code>查看），os这个模块所在的目录就在列表sys.path中，一般安装的Python库的目录都可以在sys.path中找到（前提是要将Python的安装目录添加到电脑的环境变量），所以对于安装好的库，我们直接import即可。第二个地方就是运行文件（这里是m1.py）所在的目录，因为m2.py和运行文件在同一目录下，所以上述写法没有问题。</li></ul> 
<p>用上述方法导入原有的sys.path中的库没有问题。但是，最好不要用上述方法导入同目录下的文件！因为这可能会出错。演示这个错误需要用到import语句的第二种写法，所以先来学一学import的第二种写法。在Tree目录下新建一个目录Branch，在Branch中新建文件m3.py，m3.py的内容如下：</p> 
<pre><code>def printSelf():
	print('In m3')</code></pre> 
<p>如何在m1中导入m3.py呢，请看更改后的m1.py：</p> 
<pre><code>from Branch import m3
m3.printSelf()</code></pre> 
<p>总结import语句的第二种用法：</p> 
<ul><li><code>from package_name import module_name</code>。一般把模块组成的集合称为包（package）。与第一种写法类似，Python会在sys.path和运行文件目录这两个地方寻找包，然后导入包中名为module_name的模块。</li></ul> 
<p>现在我们来说明为什么不要用import的第一种写法来导入同目录下的文件。在Branch目录下新建m4.py文件，m4.py的内容如下：</p> 
<pre><code>def printSelf():
	print('In m4')</code></pre> 
<p>然后我们在m3.py中直接导入m4，m3.py变为：</p> 
<pre><code>import m4
def printSelf():
	print('In m3')</code></pre> 
<p>这时候运行m1.py就会报错了，说没法导入m4模块。为什么呢？我们来看一下导入流程：m1使用<code>from Branch import m3</code>导入m3，然后在m3.py中用<code>import m4</code>导入m4。看出问题了吗？m4.py和m1.py不在同一目录，怎么能直接使用<code>import m4</code>导入m4呢。（读者可以试试直接在Tree目录下新建另一个m4.py文件，你会发现再运行m1.py就不会出错了，只不过导入的是第二个m4.py了）</p> 
<p>面对上面的错误，使用python2运行m1.py就不会报错，因为在python2中，上面提到的import的两种写法都属于相对导入，而在python3中，却属于绝对导入。话说到了这里，就要牵扯到import中最关键的部分了——相对导入和绝对导入。</p> 
<p>我们还是谈论python3的import用法。上面提到的两种写法属于绝对导入，即用于导入sys.path中的包和运行文件所在目录下的包。对于sys.path中的包，这种写法毫无问题；导入自己写的文件，如果是非运行入口文件（上面的m1.py是运行入口文件，可以使用绝对导入），则需要相对导入。</p> 
<p>比如对于非运行入口文件m3.py，其导入m4.py需要使用相对导入：</p> 
<pre><code>from . import m4
def printSelf():
	print('In m3')</code></pre> 
<p>这时候再运行m1.py就ok了。列举一下相对导入的写法：</p> 
<ul><li><code>from . import module_name</code>。导入和自己同目录下的模块。</li><li><code>from .package_name import module_name</code>。导入和自己同目录的包的模块。</li><li><code>from .. import module_name</code>。导入上级目录的模块。</li><li><code>from ..package_name import module_name</code>。导入位于上级目录下的包的模块。</li><li>当然还可以有更多的<code>.</code>，每多一个点就多往上一层目录。</li></ul> 
<p>不知道你有没有留神上面的一句话——“上面的m1.py是运行入口文件，可以使用绝对导入”，这句话是没问题的，也和我平时的做法一致。那么，运行入口文件可不可以使用相对导入呢？比如m1.py内容改成：</p> 
<pre><code>from .Branch import m3
m3.printSelf()</code></pre> 
<p>答案是可以，但不能用<code>python m1.py</code>命令，而是需要使用<code>python -m m1</code>来运行。为什么？关于前者，PEP 328提案中的一段文字好像给出了原因：</p> 
<blockquote>
  Relative imports use a module's _name 
 <strong>_</strong> attribute to determine that module's position in the package hierarchy. If the module's name does not contain any package information (e.g. it is set to '__main 
 <strong>__</strong>') then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system. 
</blockquote> 
<p>我不太懂，但是又有一点明白。我们应该见过下面一段代码：</p> 
<pre><code>if __name__ == '__main__':
	main()</code></pre> 
<p>意思是如果运行了当前文件，则__name__变量会置为__main__，然后会执行main函数，如果当前文件是被其他文件作为模块导入的话，则__name__为模块名，不等于__main__，就不会执行main函数。比如对于上述更改后的m1.py，执行<code>python m1.py</code>命令后，会报如下错误：</p> 
<blockquote>
  Traceback (most recent call last): File "m1.py", line 1, in from .Branch import m3 ModuleNotFoundError: No module named '_ 
 <em>main</em>_.Branch'; '__main__' is not a package 
</blockquote> 
<p>据此我猜测执行<code>python m1.py</code>命令后，当前目录所代表的包'.'变成了__main__。</p> 
<p>那为什么<code>python -m m1</code>就可以呢？那位台湾老师给出了解释：</p> 
<blockquote>
  执行指令中的-m是为了让Python预先import你要的package或module给你，然后再执行script。 
</blockquote> 
<p>即不把m1.py当作运行入口文件，而是也把它当作被导入的模块，这就和非运行入口文件有一样的表现了。</p> 
<p>那反过来，如果m1.py使用绝对导入（<code>from Branch import m3</code>），能使用<code>python -m m1</code>运行吗？我试了一下，如果当前目录是Tree就可以。如果在其他目录下运行，比如在Tree所在的目录（使用<code>python -m Tree.m1</code>运行），就不可以。这可能还是与绝对导入相关。</p> 
<p>（之前看到了一个大型项目，其运行入口文件有一大堆的相对导入，我还傻乎乎地用python直接运行它。之后看到他给的样例运行命令是带了-m参数的。现在才恍然大悟。）</p> 
<p>理解import的难点差不多就这样了。下面说一说import的其他简单但实用的用法。</p> 
<ul><li><code>import moudle_name as alias</code>。有些module_name比较长，之后写它时较为麻烦，或者module_name会出现名字冲突，可以用as来给它改名，如<code>import numpy as np</code>。</li><li><code>from module_name import function_name, variable_name, class_name</code>。上面导入的都是整个模块，有时候我们只想使用模块中的某些函数、某些变量、某些类，用这种写法就可以了。使用逗号可以导入模块中的多个元素。</li><li>有时候导入的元素很多，可以使用反斜杠来换行，官方推荐使用括号。</li></ul> 
<pre><code>from Tkinter import Tk, Frame, Button, Entry, Canvas, Text, \
    LEFT, DISABLED, NORMAL, RIDGE, END	# 反斜杠换行
from Tkinter import (Tk, Frame, Button, Entry, Canvas, Text,
    LEFT, DISABLED, NORMAL, RIDGE, END)	# 括号换行（推荐）</code></pre> 
<p>说到这感觉import的核心已经说完了。再跟着上面的博客说一说使用import可能碰到的问题吧。</p> 
<p>问题1描述：ValueError: attempted relative import beyond top-level package。直面问题的第一步是去了解熟悉它，最好是能复现它，让它躺在两跨之间任我们去践踏蹂躏。仍然是上面四个文件，稍作修改，四个文件如下：</p> 
<pre><code># m1.py
from Branch import m3
m3.printSelf()
# m2.py
def printSelf():
	print('module2')
# m3.py
from .. import m2 # 复现的关键在这 #
print(__name__)
def printSelf():
	print('In m3')
# m4.py
def printSelf():
	print('In m4')</code></pre> 
<p>运行<code>python m1.py</code>，就会出现该问题。问题何在？我猜测，运行m1.py后，m1代表的模块就是顶层模块（参见上面PEP 328的引用），而m3.py中尝试导入的m2模块所在的包（即Tree目录代表的包）比m1的层级更高，所以会报出这样的错误。怎么解决呢？将m1.py的所有导入改为相对导入，然后进入m1.py的上层目录，运行<code>python -m Tree.m1</code>即可。</p> 
<p>对于使用import出现的其他问题，碰到了再接着更新。</p> 
<figure class="image left"> 
 <img alt="" height="200" src="https://images2.imgbox.com/09/98/BRyS27xz_o.jpg" width="200"> 
 <figcaption> 
  <strong>待办计划：卷起来吧，少年！</strong> 
 </figcaption> 
</figure> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="200" src="https://images2.imgbox.com/86/9c/3aL3KrIF_o.jpg" width="200"> 
  <figcaption> 
   <strong>我们记账：年薪50w够花么？</strong> 
  </figcaption> 
 </figure> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b77e34b814fbc00e20302f54566f96f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NR RB转带宽</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51d220beb0f8edb675f40b4b51abc887/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器学习：模型评估与选择-数据集划分（附代码实现）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>