<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis拾遗 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis拾遗" />
<meta property="og:description" content="本文整理自剑指Java面试-Offer直通车
主流应用架构
Memcache和Redis的区别
Memcache
代码层次类似Hash
支持简单数据类型
不支持数据持久化存储
不支持主从
不支持分片
Redis
数据类型丰富
支持数据磁盘持久化存储
支持主从
支持分片（Redis3.0&#43;） 为什么Redis能这么快
完全基于内存，绝大部分请求是纯粹的内存啊哦做，执行效率高
数据结构简单，对数据操作也简单
采用单线程，单线程也能处理高并发请求，想多核也可启动多实例
使用多路I/O复用模型，非阻塞IO
多路I/O复用模型
FD
File Descriptor，文件描述符
一个打开的文件通过为疑似的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射
传统的阻塞I/O模型
epoll/kqueue/evport/select
Redis根据不同的操作系统，选择不同的多路复用函数
优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现
以时间复杂度为O(n)的select作为保底
基于react设计模式监听I/O事件
Select系统调用
说说你用过的Redis的数据类型
String
最基本的数据类型
二进制安全
可以包含任何数据，比如JPG图片或者序列化的对象
最大512M
Hash
String元素组成的字典，适合用于存储对象
List
列表，按照String元素插入顺序排序
大约能存储40亿个成员
Set
String元素组成的无需集合，通过哈希表实现，不允许重复
Sorted Set
通过分数来为集合中的成员进行从小到大的排序
HyperLogLog
用于计数
Geo
支持存储地理位置信息
底层数据类型基础
简单动态字符串
链表
字典
跳跃表
整数集合
压缩列表
对象
从海量Key里查询出某一固定前缀的Key
KEYS pattern
查找所有复核给定模式pattern的key
一次性返回左右匹配的key
键的数量过大会导致服务器卡顿
SCAN cursor [MATCH pattern] [COUNT count]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cbb4786243227ef434c53d7317d6e57b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-24T00:52:28+08:00" />
<meta property="article:modified_time" content="2018-12-24T00:52:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis拾遗</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li> <p>本文整理自<a href="https://coding.imooc.com/class/303.html" rel="nofollow">剑指Java面试-Offer直通车</a></p> </li><li> <p>主流应用架构</p> 
  <ul><li> <p><img alt="" class="has" height="310" src="https://images2.imgbox.com/a8/d8/c7F1isOv_o.png" width="695"></p> </li></ul></li><li> <p>Memcache和Redis的区别</p> 
  <ul><li> <p>Memcache</p> 
    <ul><li> <p>代码层次类似Hash</p> </li><li> <p>支持简单数据类型</p> </li><li> <p>不支持数据持久化存储</p> </li><li> <p>不支持主从</p> </li><li> <p>不支持分片</p> </li></ul></li><li> <p>Redis</p> 
    <ul><li> <p>数据类型丰富</p> </li><li> <p>支持数据磁盘持久化存储</p> </li><li> <p>支持主从</p> </li><li> <p>支持分片（Redis3.0+） </p> </li></ul></li></ul></li><li> <p>为什么Redis能这么快</p> 
  <ul><li> <p>完全基于内存，绝大部分请求是纯粹的内存啊哦做，执行效率高</p> </li><li> <p>数据结构简单，对数据操作也简单</p> </li><li> <p>采用单线程，单线程也能处理高并发请求，想多核也可启动多实例</p> </li><li> <p>使用多路I/O复用模型，非阻塞IO</p> </li></ul></li><li> <p>多路I/O复用模型</p> 
  <ul><li> <p>FD</p> 
    <ul><li> <p>File Descriptor，文件描述符</p> </li><li> <p>一个打开的文件通过为疑似的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射</p> </li></ul></li><li> <p>传统的阻塞I/O模型</p> 
    <ul><li> <p><img alt="" class="has" height="351" src="https://images2.imgbox.com/34/54/cS6WY0oA_o.png" width="528"></p> </li></ul></li><li> <p>epoll/kqueue/evport/select</p> 
    <ul><li> <p>Redis根据不同的操作系统，选择不同的多路复用函数</p> </li><li> <p>优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现</p> </li><li> <p>以时间复杂度为O(n)的select作为保底</p> </li><li> <p>基于react设计模式监听I/O事件</p> </li><li> <p>Select系统调用</p> 
      <ul><li> <p><img alt="" class="has" height="207" src="https://images2.imgbox.com/66/6b/Kg2H6Zpq_o.png" width="262"></p> </li></ul></li></ul></li></ul></li><li> <p>说说你用过的Redis的数据类型</p> 
  <ul><li> <p>String</p> 
    <ul><li> <p>最基本的数据类型</p> </li><li> <p>二进制安全</p> 
      <ul><li> <p>可以包含任何数据，比如JPG图片或者序列化的对象</p> </li></ul></li><li> <p>最大512M</p> </li><li> <p><img alt="" class="has" height="225" src="https://images2.imgbox.com/e8/b2/LAh59DPP_o.png" width="190"></p> </li></ul></li><li> <p>Hash</p> 
    <ul><li> <p>String元素组成的字典，适合用于存储对象</p> </li></ul></li><li> <p>List</p> 
    <ul><li> <p>列表，按照String元素插入顺序排序</p> </li><li> <p>大约能存储40亿个成员</p> </li></ul></li><li> <p>Set</p> 
    <ul><li> <p>String元素组成的无需集合，通过哈希表实现，不允许重复</p> </li></ul></li><li> <p>Sorted Set</p> 
    <ul><li> <p>通过分数来为集合中的成员进行从小到大的排序</p> </li></ul></li><li> <p>HyperLogLog</p> 
    <ul><li> <p>用于计数</p> </li></ul></li><li> <p>Geo</p> 
    <ul><li> <p>支持存储地理位置信息</p> </li></ul></li><li> <p>底层数据类型基础</p> 
    <ul><li> <p>简单动态字符串</p> </li><li> <p>链表</p> </li><li> <p>字典</p> </li><li> <p>跳跃表</p> </li><li> <p>整数集合</p> </li><li> <p>压缩列表</p> </li><li> <p>对象</p> </li></ul></li></ul></li><li> <p>从海量Key里查询出某一固定前缀的Key</p> 
  <ul><li> <p>KEYS pattern</p> 
    <ul><li> <p>查找所有复核给定模式pattern的key</p> </li><li> <p>一次性返回左右匹配的key</p> </li><li> <p>键的数量过大会导致服务器卡顿</p> </li></ul></li><li> <p>SCAN cursor [MATCH pattern] [COUNT count]</p> 
    <ul><li> <p>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程</p> </li><li> <p>以0作为游标开始一次新的迭代，知道命令返回游标0完成一次遍历</p> </li><li> <p>不保证每次执行都返回某个给定数量的元素（甚至会返回0个，只要游标不为0，就不应该结束迭代），支持模糊查询</p> </li><li> <p>一次返回的数量不可控，只能是大概率复核count参数 </p> </li><li> <p>有可能会返回重复Key</p> </li></ul></li></ul></li><li> <p>如何通过Redis实现分布式锁</p> 
  <ul><li> <p>分布式锁需要解决的问题</p> 
    <ul><li> <p>互斥性</p> 
      <ul><li> <p>只能有一个客户端获得锁</p> </li></ul></li><li> <p>安全性</p> 
      <ul><li> <p>锁只能被持有锁的客户端删除</p> </li></ul></li><li> <p>死锁</p> 
      <ul><li> <p>获取锁的客户端未能释放锁，其他客户端再也无法获取该锁</p> </li></ul></li><li> <p>容错</p> 
      <ul><li> <p>当部分Redis节点宕机时，客户端应依然能够获取锁</p> </li></ul></li></ul></li><li> <p>SETNX key value</p> 
    <ul><li> <p>如果key不存在，则创建并赋值</p> </li><li> <p>时间复杂度，O(1)</p> </li><li> <p>设置成功返回1，设置失败返回0</p> </li><li> <p>SETNX设置的key将长期存在，分开设置EXPIRE无法满足原子性</p> </li></ul></li><li> <p>SET key value [EX seconds] [PX milliseconds] [NX|XX]</p> 
    <ul><li> 
      <ul><li> <p>EX seconds，设置键的过期时间为seconds秒</p> </li><li> <p>PX millisecond，设置键的过期时间为milliseconds毫秒</p> </li><li> <p>NX，只在键不存在时，才对键进行设置操作</p> </li><li> <p>XX，只在键已存在时，才对键进行设置操作</p> </li><li> <p>SET操作完成时，返回OK，否则返回nil</p> </li></ul></li></ul></li><li> <p>大量的key同时过期的注意事项</p> 
    <ul><li> <p>集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象</p> </li><li> <p>解决方法，在key的过期时间上加上一个随机值</p> </li></ul></li></ul></li><li> <p>如何使用Redis做异步队列</p> 
  <ul><li> <p>使用List作为队列，RPUSH生产消息，LPOP消费消息</p> 
    <ul><li> <p>缺点，没有等待队列里有值就直接消费</p> </li><li> <p>弥补，可以通过在应用层引入Sleep机制去调用LPOP重试</p> </li></ul></li><li> <p>BLPOP key [key...] timeout</p> 
    <ul><li> <p>阻塞直到队列有消息或者超时</p> </li><li> <p>缺点，只能供一个消费者消费</p> </li></ul></li><li> <p>使用pub/sub，主题订阅者模式</p> 
    <ul><li> <p>发送者pub发送消息，订阅者sub接收消息</p> </li><li> <p>订阅者可以订阅任意数量的频道</p> </li><li> <p>subscribe 频道</p> </li><li> <p>publish 频道 消息</p> </li><li> <p><img alt="" class="has" height="266" src="https://images2.imgbox.com/ce/6e/LYzYlEqd_o.png" width="452"></p> </li><li> <p>缺点，消息发布是无状态的，无法保证可达，若发送消息时，没有消费者在线，消息就丢失了</p> </li></ul></li></ul></li><li> <p>Redis如何做持久化</p> 
  <ul><li> <p>RDB（快照）持久化，保存某个时间点的全量数据快照</p> 
    <ul><li> <p>优点，全量数据快照，文件小，恢复快</p> </li><li> <p>缺点，无法保存最近一次快照之后的数据</p> </li></ul> 
    <ul><li> <p>SAVE命令</p> 
      <ul><li> <p>在主线程中保存快照，阻塞Redis的服务器进程，知道RDB文件被创建完毕</p> </li></ul></li><li> <p>BGSAVE命令</p> 
      <ul><li> <p>Fork一个子进程来创建RDB文件，不阻塞服务器进程</p> </li><li> <p><img alt="" class="has" height="481" src="https://images2.imgbox.com/35/7b/occCdHHZ_o.png" width="530"></p> </li></ul></li><li> <p>LASTSAVE</p> 
      <ul><li> <p>返回上次执行save的时间</p> </li><li> <p>BGSAVE保存成功后，才会更新此时间</p> </li></ul></li><li> <p>自动化出发RDB持久化</p> 
      <ul><li> <p>redis.conf</p> 
        <ul><li> <p>save 900 1</p> 
          <ul><li> <p>900秒内有1条写入指令，则产生一次快照</p> </li></ul></li><li> <p>save 300 10</p> 
          <ul><li> <p>300秒内有10条写入指令，则产生一次快照</p> </li></ul></li><li> <p>save 60 10000</p> 
          <ul><li> <p>60秒内有10000条写入指令，则产生一次快照</p> </li></ul></li><li> <p>stop-writes-on-bgsave-error yes</p> 
          <ul><li> <p>当备份进程出错时，主进程停止接受写入操作</p> </li></ul></li><li> <p>rdbcompression yes</p> 
          <ul><li> <p>在备份时，将rdb压缩后再保存，建议设置为no</p> </li></ul></li><li> <p>save ""</p> 
          <ul><li> <p>禁用rdb配置</p> </li></ul></li></ul></li><li> <p>主从复制时，主节点自动触发</p> </li><li> <p>执行Debug Reload时</p> </li><li> <p>执行Shutdown且没有开启AOF持久化</p> </li></ul></li><li> <p>缺点</p> 
      <ul><li> <p>内存数据的全量同步，数据量大会由于I/O而严重影响性能</p> </li><li> <p>可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据</p> </li></ul></li></ul></li><li> <p>AOF（Append-Only-File）持久化，保存写状态</p> 
    <ul><li> <p>优点，可读性高，适合保存增量数据，数据不易丢失</p> 
      <ul><li> <p>缺点，文件体积大，恢复时间长 </p> </li></ul></li><li> <p>记录下除了查询以外的所有变更数据库状态的指令</p> </li><li> <p>以append的形式追加保存到AOF文件中（增量）</p> </li><li> <p>redis.conf</p> 
      <ul><li> <p>appendonly yes</p> 
        <ul><li> <p>开启AOF</p> </li></ul></li><li> <p>appendfilename "appendonly.aof"</p> 
        <ul><li> <p>AOF文件的名字</p> </li></ul></li><li> <p>appendfsync always/everysec/no</p> 
        <ul><li> <p>立即写入/每秒写入/交由操作系统决定（一般等到缓存区填满才同步数据到磁盘中）</p> </li><li> <p>推荐everysec</p> </li></ul></li></ul></li><li> <p>日志重写解决AOF文件大小不断增大的问题</p> 
      <ul><li> <p>调用fork()，创建一个子进程</p> </li><li> <p>子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件</p> </li><li> <p>主进程持续将新的变动同时写到内存和原来的AOF里</p> </li><li> <p>主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动</p> </li><li> <p>使用新的AOF文件替换掉旧的AOF文件</p> </li></ul></li></ul></li><li> <p>RDB-AOF混合持久化方式，4.0后默认</p> 
    <ul><li> <p>BGSZVE做镜像全量持久化，AOF做增量持久化</p> </li><li> <p><img alt="" class="has" height="543" src="https://images2.imgbox.com/47/4c/JD6neuJ8_o.png" width="628"></p> </li></ul></li><li> <p>Redis数据的恢复</p> 
    <ul><li> <p>RDB和AOF文件共存情况下的恢复流程，AOF优先</p> </li><li> <p><img alt="" class="has" height="446" src="https://images2.imgbox.com/60/3c/dGoEqDKQ_o.png" width="361"></p> </li></ul></li></ul></li><li> <p>使用Pipeline的好处</p> 
  <ul><li> <p>Pipeline和Linux的管道类似</p> </li><li> <p>Redis基于请求/响应模型，单个请求处理需要一一应答</p> </li><li> <p>Pipeline批量执行指令，节省多次IO往返时间</p> </li><li> <p>有顺序依赖的指令建议分批发送</p> </li></ul></li><li> <p>Redis的同步机制</p> 
  <ul><li> <p>全同步过程</p> 
    <ul><li> <p>Slave发送sync命令到Master</p> </li><li> <p>Master启动一个后台进程，将Redis中的数据快照保存到文件中</p> </li><li> <p>Master将保存数据快照期间接收到的写命令缓存起来</p> </li><li> <p>Master完成写文件操作后，将该文件发送给Slave</p> </li><li> <p>使用新的AOF文件替换掉旧的AOF文件</p> </li><li> <p>Master将这期间收集的增量写命令发送给Slave端进行回放</p> </li></ul></li><li> <p>增量同步过程</p> 
    <ul><li> <p>Master接收到用户的操作指令，判断是否需要传播到Slave</p> </li><li> <p>将操作记录追加到AOF文件</p> </li><li> <p>将操作传播到其他Slave</p> 
      <ul><li> <p>对齐主从库，确保从数据库是该操作所对应的数据库</p> </li><li> <p>将命令和参数按照Redis的格式写入到响应Slave的缓存中</p> </li></ul></li><li> <p>将缓存中的数据发送给Slave  </p> </li></ul></li></ul></li><li> <p>Redis Sentinel（Redis哨兵）</p> 
  <ul><li> <p>解决主从同步Master宕机后的主从切换问题</p> 
    <ul><li> <p>监控，检查主从服务器是否运行正常  </p> </li><li> <p>提醒，通过API向管理员或其他应用程序发送故障通知</p> </li><li> <p>自动故障迁移，主从切换</p> </li></ul></li></ul></li><li> <p>流言协议Gossip</p> 
  <ul><li> <p>每个节点都随机地与对方通信，最终所有节点的状态达成一致</p> </li><li> <p>种子节点定期随机向其他节点发送街店列表以及需要传播的消息</p> </li><li> <p>不保证信息一定会传递给所有的节点，但是最终会趋于一致  </p> </li></ul></li></ul> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ecef44c1abf44b43a09b89d335283f35/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据库拾遗</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ce24766a8947c63942d2851e7c04e0d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在线文件大小(bit,bytes,KB,MB,GB,TB)转换换算</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>