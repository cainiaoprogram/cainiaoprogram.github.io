<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Postgresql的灾备管理(二）一主一备——几个软件的缝合怪 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Postgresql的灾备管理(二）一主一备——几个软件的缝合怪" />
<meta property="og:description" content="前文所述，我抛弃了repmgr改用pgpool，就是看重了其丰富的灾备功能，很不幸的是，符合要求的snapshot模式宕机了，而且是官方修不好的那种，无奈放弃。 剩下的选项就是patroni. 又仔细研究了patroni的说明，对于备故障是有改同步复制为异步复制的功能，然而必须依赖etcd或者consul等分布式多活检测器，必须部署3台以上，而且主服务器身份的漂移只能通过HAproxy来实现，等于一个灾备程序需要再搭用2个其他程序，还要多加一台备用服务器，一点都不简单。
所幸的是，pgpool官方给了很多的bash脚本，以此为基础，我可以通过对repmgr的修补，来补全灾备功能，实现前述的2台机器条件下的乘法原理。以下是对repmgr功能缺陷的补全方案：
1）备服务器故障造成同步的主服务器无法接受写操作——更换postgresql相关的配置，将同步复制改成异步复制，使用reload进行不停机切换。但是当备服务器恢复了，重新加入进来后，也应该相应的恢复为同步复制。
2）备服务器切换为主服务器，应用程序无法得知——使用firewalld对写程序的接口进行端口转发的反向代理。在这种事件发生后试图在两台机器上进行切换，当然旧主服务器的机器可能根本无法接通，在恢复后应该先去备服务器进行检查，并同步最新的反向代理流向。用pgpool中学会的postgres账号互通进行切换，通过特殊的sudo设置和执行bash脚本去更改在firewalld的反向代理设置。读程序则在本机直接连，无需特意更改。
这里使用firewalld的端口转发(NAT)功能而不是虚拟IP来实现主服务器身份的漂移，不仅仅是因为大部分的云服务设置虚拟IP都非常麻烦，而且更重要的是两台数据库服务器为了实现最大限度的不相关性，已经分属于2个可用区的2个子网，虚拟IP策略根本无法跨网段，是无效的。又不想用HAProxy，就直接用Linux自带的底层NAT来实现反向代理了。
3）主服务器必须记录自己是否在solo状态。记录和解除都在故障切换时实现。则恢复后启动先检查自己是否在solo状态，如果是则直接作为主启动，并且试图通知另一台当备。如果不是则先检查另一台是否已经启动了，如果启动主动当备，如果还未启动则挂机等待另一台给信号，自己再去当备。
以上的实现依赖于repmgr的event_notification_command等接口，它们可以将当前发生的事件和具体细节传输给自定义的脚本来具体处理。当然开机启动也必须编写相应的脚本，来实现对repmgr启动的控制，避免主备身份出错。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/908b47fb942c0c1776229d113b82d49b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-20T16:45:08+08:00" />
<meta property="article:modified_time" content="2023-07-20T16:45:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Postgresql的灾备管理(二）一主一备——几个软件的缝合怪</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>前文所述，我抛弃了repmgr改用pgpool，就是看重了其丰富的灾备功能，很不幸的是，符合要求的snapshot模式宕机了，而且是官方修不好的那种，无奈放弃。 剩下的选项就是patroni. 又仔细研究了patroni的说明，对于备故障是有改同步复制为异步复制的功能，然而必须依赖etcd或者consul等分布式多活检测器，必须部署3台以上，而且主服务器身份的漂移只能通过HAproxy来实现，等于一个灾备程序需要再搭用2个其他程序，还要多加一台备用服务器，一点都不简单。</p> 
<p>所幸的是，pgpool官方给了很多的bash脚本，以此为基础，我可以通过对repmgr的修补，来补全灾备功能，实现前述的2台机器条件下的乘法原理。以下是对repmgr功能缺陷的补全方案：</p> 
<p>1）备服务器故障造成同步的主服务器无法接受写操作——更换postgresql相关的配置，将同步复制改成异步复制，使用reload进行不停机切换。但是当备服务器恢复了，重新加入进来后，也应该相应的恢复为同步复制。</p> 
<p>2）备服务器切换为主服务器，应用程序无法得知——使用firewalld对写程序的接口进行端口转发的反向代理。在这种事件发生后试图在两台机器上进行切换，当然旧主服务器的机器可能根本无法接通，在恢复后应该先去备服务器进行检查，并同步最新的反向代理流向。用pgpool中学会的postgres账号互通进行切换，通过特殊的sudo设置和执行bash脚本去更改在firewalld的反向代理设置。读程序则在本机直接连，无需特意更改。</p> 
<p>这里使用firewalld的端口转发(NAT)功能而不是虚拟IP来实现主服务器身份的漂移，不仅仅是因为大部分的云服务设置虚拟IP都非常麻烦，而且更重要的是两台数据库服务器为了实现最大限度的不相关性，已经分属于2个可用区的2个子网，虚拟IP策略根本无法跨网段，是无效的。又不想用HAProxy，就直接用Linux自带的底层NAT来实现反向代理了。</p> 
<p>3）主服务器必须记录自己是否在solo状态。记录和解除都在故障切换时实现。则恢复后启动先检查自己是否在solo状态，如果是则直接作为主启动，并且试图通知另一台当备。如果不是则先检查另一台是否已经启动了，如果启动主动当备，如果还未启动则挂机等待另一台给信号，自己再去当备。</p> 
<p>以上的实现依赖于repmgr的event_notification_command等接口，它们可以将当前发生的事件和具体细节传输给自定义的脚本来具体处理。当然开机启动也必须编写相应的脚本，来实现对repmgr启动的控制，避免主备身份出错。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d51ccff618cbf71f5c3b3925ea71367f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker启动mysql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/69d70dd1fb0859f42ffe20eb3743c187/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CSS基础知识(二）——盒子模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>