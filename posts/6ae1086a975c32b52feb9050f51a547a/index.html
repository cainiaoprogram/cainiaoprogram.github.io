<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android compress函数,Linux Kernel(Android) 加密算法小结（cipher、compress、digest） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android compress函数,Linux Kernel(Android) 加密算法小结（cipher、compress、digest）" />
<meta property="og:description" content="Linux Kernel(Android) 加密算法总结(cipher、compress、digest)
1. Linux内核支持哪些加密算法 ？
内核支持的加密算法很多，包括：
对称加密算法，如AES；
摘要算法，如sha1,md5；
压缩算法，如deflate。
不过内核好像不支持非对称加密算法。
2. 加密算法源文件位置
这些算法作为加密函数框架的最底层，提供加密和解密的实际操作。这些函数可以在内核crypto文件夹下，相应的文件中找到。
3. 配置编译选项将加密算法作为模块编入内核
Cryptographic options
加密选项
Cryptographic API
提供核心的加密API支持.这里的加密算法被广泛的应用于驱动程序通信协议等机制中.子选项可以全不选,内核中若有其他部分依赖它,会自动选上
Cryptographic algorithm manager
创建加密模版实例,必须要选
HMAC support
为IPSec所必须,可为PPPoE提供压缩支持
Null algorithms
NULL加密算法(什么也不做),用于IPsec协议的封装安全载荷模块(ESP)
MD4 digest algorithm
老旧的摘要算法,已经过时
MD5 digest algorithm
主流摘要算法,128位(已被中国山东大学王小云攻破,可以快速找到碰撞)
SHA1 digest algorithm
主流摘要算法,160位(已被中国山东大学王小云攻破,可以快速找到碰撞),速度与MD5相当
SHA256 digest algorithm
更好的摘要算法,256位,速度较SHA1稍慢
SHA384 and SHA512 digest algorithms
更好的摘要算法,384/512位,速度大约只有SHA1的40-50%
Whirlpool digest algorithms
最安全的摘要算法,512位,已被列入ISO标准,目前最新版本为3.0(2003年发布)
Tiger digest algorithms
号称最快的摘要算法,192位,专门为64位CPU进行了优化
ECB support
电子密码本,最简单的加密方法
CBC support
密码块链,IPSec需要使用它
DES and Triple DES EDE cipher algorithms" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6ae1086a975c32b52feb9050f51a547a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-25T16:58:44+08:00" />
<meta property="article:modified_time" content="2021-05-25T16:58:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android compress函数,Linux Kernel(Android) 加密算法小结（cipher、compress、digest）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>Linux Kernel(Android) 加密算法总结(cipher、compress、digest)</p> 
 <p>1. Linux内核支持哪些加密算法 ？</p> 
 <p>内核支持的加密算法很多，包括：</p> 
 <p>对称加密算法，如AES；</p> 
 <p>摘要算法，如sha1,md5；</p> 
 <p>压缩算法，如deflate。</p> 
 <p>不过内核好像不支持非对称加密算法。</p> 
 <p>2. 加密算法源文件位置</p> 
 <p>这些算法作为加密函数框架的最底层，提供加密和解密的实际操作。这些函数可以在内核crypto文件夹下，相应的文件中找到。</p> 
 <p>3.  配置编译选项将加密算法作为模块编入内核</p> 
 <p>Cryptographic options</p> 
 <p>加密选项</p> 
 <p>Cryptographic API</p> 
 <p>提供核心的加密API支持.这里的加密算法被广泛的应用于驱动程序通信协议等机制中.子选项可以全不选,内核中若有其他部分依赖它,会自动选上</p> 
 <p>Cryptographic algorithm manager</p> 
 <p>创建加密模版实例,必须要选</p> 
 <p>HMAC support</p> 
 <p>为IPSec所必须,可为PPPoE提供压缩支持</p> 
 <p>Null algorithms</p> 
 <p>NULL加密算法(什么也不做),用于IPsec协议的封装安全载荷模块(ESP)</p> 
 <p>MD4 digest algorithm</p> 
 <p>老旧的摘要算法,已经过时</p> 
 <p>MD5 digest algorithm</p> 
 <p>主流摘要算法,128位(已被中国山东大学王小云攻破,可以快速找到碰撞)</p> 
 <p>SHA1 digest algorithm</p> 
 <p>主流摘要算法,160位(已被中国山东大学王小云攻破,可以快速找到碰撞),速度与MD5相当</p> 
 <p>SHA256 digest algorithm</p> 
 <p>更好的摘要算法,256位,速度较SHA1稍慢</p> 
 <p>SHA384 and SHA512 digest algorithms</p> 
 <p>更好的摘要算法,384/512位,速度大约只有SHA1的40-50%</p> 
 <p>Whirlpool digest algorithms</p> 
 <p>最安全的摘要算法,512位,已被列入ISO标准,目前最新版本为3.0(2003年发布)</p> 
 <p>Tiger digest algorithms</p> 
 <p>号称最快的摘要算法,192位,专门为64位CPU进行了优化</p> 
 <p>ECB support</p> 
 <p>电子密码本,最简单的加密方法</p> 
 <p>CBC support</p> 
 <p>密码块链,IPSec需要使用它</p> 
 <p>DES and Triple DES EDE cipher algorithms</p> 
 <p>老迈的(DES)和尚佳的(Triple DES)对称加密算法</p> 
 <p>Blowfish cipher algorithm</p> 
 <p>又老又慢的对称加密算法</p> 
 <p>Twofish cipher algorithm</p> 
 <p>很强的对称加密算法,使用较广</p> 
 <p>Twofish cipher algorithms (i586)</p> 
 <p>很强的对称加密算法,使用较广(针对i586的版本)</p> 
 <p>Serpent cipher algorithm</p> 
 <p>很强的对称加密算法</p> 
 <p>AES cipher algorithms</p> 
 <p>最佳的对称加密算法(Rijndael),128/192/256位,强度最高,快速且节省内存</p> 
 <p>AES cipher algorithms (i586)</p> 
 <p>最佳的对称加密算法(Rijndael),128/192/256位,强度最高,快速且节省内存(针对i586的版本)</p> 
 <p>CAST5 (CAST-128) cipher algorithm</p> 
 <p>对称加密算法</p> 
 <p>CAST6 (CAST-256) cipher algorithm</p> 
 <p>对称加密算法</p> 
 <p>TEA, XTEA and XETA cipher algorithms</p> 
 <p>较弱的对称加密算法</p> 
 <p>ARC4 cipher algorithm</p> 
 <p>脆弱的流对称加密算法</p> 
 <p>Khazad cipher algorithm</p> 
 <p>对称加密算法</p> 
 <p>Anubis cipher algorithm</p> 
 <p>对称加密算法</p> 
 <p>Deflate compression algorithm</p> 
 <p>压缩算法,当在IPSec中使用IPCOMP协议时才需要</p> 
 <p>Michael MIC keyed digest algorithm</p> 
 <p>摘要算法,仅仅用于校验iSCSI设备传输的数据,因为算法本身比较脆弱</p> 
 <p>CRC32c CRC algorithm</p> 
 <p>摘要算法,可用于校验iSCSI设备传输的数据</p> 
 <p>Testing module</p> 
 <p>快速且丑陋的测试模块</p> 
 <p>Hardware crypto devices</p> 
 <p>仅有VIA C7系列处理器支持硬件加密(VIA PadLock高级加密引擎)</p> 
 <p>参考：</p> 
 <p>CryptoAPI support</p> 
 <p>提供核心的加密API支持.这里的加密算法被广泛的应用于驱动程序通信协议等机制上，子选项可以全不选，内核中若有其他部分依赖它，会自动选</p> 
 <p>(M)Cipher Algorithms</p> 
 <p>创建加密模版实例，必须要选</p> 
 <p>-- 128 bit blocksize(M) AES (aka Rijndael) cipher</p> 
 <p>(M) Identity Function cipher</p> 
 <p>(M) Crypto Devices</p> 
 <p>(M) Loop Crypto support</p> 
 <p>4.  加密API 的调用方法：</p> 
 <p>不过内核模块不能直接调用这些函数，因为它们并没有export。内核提供一个统一的框架，来管理这些算法。</p> 
 <p>加密算法通过crypto_register_alg()和crypto_unregister_alg()注册。</p> 
 <p>内核将加密算法分为三类，1)cipher，2)compress，3)digest。</p> 
 <p>加密函数框架中有相应的API封装，提供给模块调用。</p> 
 <p>对于使用这些加密函数，首先通过crypto_alloc_tfm()来分配一个加密函数对象的实例。初始化这些实例，然后就可以通过框架提供的API对数据进行加密和解密。完成以后，必须通过crypto_free_tfm()撤销实例。</p> 
 <p>5.  代码示例：</p> 
 <p>1)digest算法(sha1)</p> 
 <p>#include</p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>struct crypto_tfm *tfm;</p> 
 <p>struct scatterlist sg[1];</p> 
 <p>char * code1=</p> 
 <p>"234123132513451345";</p> 
 <p>char * code2=</p> 
 <p>"234123132513451345";</p> 
 <p>char *do_digest(char* code)</p> 
 <p>{<!-- --></p> 
 <p>char *result;</p> 
 <p>int code_len =strlen(code);</p> 
 <p>tfm = crypto_alloc_tfm("sha1",0);</p> 
 <p>if(IS_ERR(tfm))</p> 
 <p>return 0;</p> 
 <p>sg_init_one(sg,code,code_len);</p> 
 <p>crypto_digest_init(tfm);</p> 
 <p>crypto_digest_update(tfm,sg,1);</p> 
 <p>result = (char*)kmalloc(sizeof(char)*50,GFP_KERNEL);</p> 
 <p>if(result == NULL) {<!-- --></p> 
 <p>crypto_free_tfm(tfm);</p> 
 <p>return 0;</p> 
 <p>}memset(result,0,sizeof(char)*50);</p> 
 <p>crypto_digest_final(tfm,result);</p> 
 <p>crypto_free_tfm(tfm);</p> 
 <p>return result;</p> 
 <p>}</p> 
 <p>static int __init test_init(void)</p> 
 <p>{<!-- --></p> 
 <p>char *result1,*result2;</p> 
 <p>result1 = do_digest(code1);</p> 
 <p>if(!result1)</p> 
 <p>goto failed2;</p> 
 <p>result2 = do_digest(code2);</p> 
 <p>if(!result2)</p> 
 <p>goto failed1;</p> 
 <p>if(memcmp(result1,result2,50)!=</p> 
 <p>0)</p> 
 <p>printk("&lt;1&gt;code1 != code2\n");</p> 
 <p>else</p> 
 <p>printk("&lt;1&gt;code1 == code2\n");</p> 
 <p>kfree(result2);</p> 
 <p>failed1:</p> 
 <p>kfree(result1);</p> 
 <p>failed2:</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>static void __exit test_exit(void)</p> 
 <p>{<!-- --></p> 
 <p>}</p> 
 <p>module_init(test_init);</p> 
 <p>module_exit(test_exit);</p> 
 <p>MODULE_LICENSE("GPL");</p> 
 <p>MODULE_AUTHOR("robert@cm");</p> 
 <p>2)compress算法(deflate)</p> 
 <p>#include</p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>struct crypto_tfm *tfm;</p> 
 <p>char * code=</p> 
 <p>"Hello everyone, I'm robert from cm !";</p> 
 <p>static inline  void hexdump(unsignedchar</p> 
 <p>*buf,unsignedint len)</p> 
 <p>{<!-- --></p> 
 <p>while(len--)</p> 
 <p>printk("0x%02x,",*buf++);</p> 
 <p>printk("\n");</p> 
 <p>}</p> 
 <p>static int __init test_init(void){<!-- --></p> 
 <p>int ret,result_len,temp_len;</p> 
 <p>char result[512];</p> 
 <p>char temp[512];</p> 
 <p>printk("&lt;1&gt;%s\n",code);</p> 
 <p>/* Allocate transform for deflate */</p> 
 <p>tfm = crypto_alloc_tfm("deflate",0);</p> 
 <p>if(IS_ERR(tfm)){<!-- --></p> 
 <p>printk("&lt;1&gt;failed to load transform for deflate !\n");</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>memset(result,0,sizeof(result));</p> 
 <p>temp_len = 512;</p> 
 <p>ret = crypto_comp_compress(tfm,code,strlen(code),temp,&amp;temp_len);</p> 
 <p>if(ret){<!-- --></p> 
 <p>printk("&lt;1&gt;failed to compress !\n");</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>hexdump(temp,strlen(temp));</p> 
 <p>memset(result,0,sizeof(result));</p> 
 <p>result_len = 512;</p> 
 <p>ret = crypto_comp_decompress(tfm,temp,strlen(temp),result,&amp;result_len);</p> 
 <p>if(ret){<!-- --></p> 
 <p>printk("&lt;1&gt;failed to decompress !\n");</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>printk("&lt;1&gt;%s\n",result);</p> 
 <p>if(memcmp(code,result,strlen(code))!=</p> 
 <p>0)</p> 
 <p>printk("&lt;1&gt;decompressed was not successful\n");</p> 
 <p>else</p> 
 <p>printk("&lt;1&gt;decompressed was successful\n");</p> 
 <p>crypto_free_tfm(tfm);</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>static void __exit test_exit(void)</p> 
 <p>{<!-- --></p> 
 <p>}</p> 
 <p>module_init(test_init);</p> 
 <p>module_exit(test_exit);</p> 
 <p>MODULE_LICENSE("GPL");</p> 
 <p>MODULE_AUTHOR("robert@cm");</p> 
 <p>3)cipher算法(aes)</p> 
 <p>#include</p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>struct crypto_tfm *tfm;</p> 
 <p>#if 1</p> 
 <p>char *code = "Hello everyone,I'm robert"</p> 
 <p>"Hello everyone,I'm robert"</p> 
 <p>"Hello everyone,I'm robert";</p> 
 <p>char *key = "00112233445566778899aabbccddeeff";</p> 
 <p>#endif</p> 
 <p>#if 0</p> 
 <p>char code[]=</p> 
 <p>{0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,</p> 
 <p>0xbb,0xcc,0xdd,0xee,0xff};</p> 
 <p>char key[]=</p> 
 <p>{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,</p> 
 <p>0x0b,0x0c,0x0d,0x0e,0x0f};</p> 
 <p>#endif</p> 
 <p>static inline  void hexdump(unsignedchar</p> 
 <p>*buf,unsignedint len)</p> 
 <p>{<!-- --></p> 
 <p>while(len--)</p> 
 <p>printk("%02x",*buf++);</p> 
 <p>printk("\n");</p> 
 <p>}</p> 
 <p>static int __init test_init(void){<!-- --></p> 
 <p>int ret,templen,keylen,codelen;</p> 
 <p>struct scatterlist sg[1];</p> 
 <p>char *result;</p> 
 <p>char *temp;</p> 
 <p>keylen = 16;</p> 
 <p>codelen = strlen(code)/2;</p> 
 <p>#if 0</p> 
 <p>printk("&lt;1&gt;%s, codelen=%d\n",code,strlen(code));</p> 
 <p>printk("&lt;1&gt;%s, keylen=%d\n",key,strlen(key));</p> 
 <p>#endif</p> 
 <p>/* Allocate transform for AES ECB mode */</p> 
 <p>tfm = crypto_alloc_tfm("aes",CRYPTO_TFM_MODE_ECB);</p> 
 <p>if(IS_ERR(tfm)){<!-- --></p> 
 <p>printk("&lt;1&gt;failed to load transform for aes ECB mode !\n");</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>ret = crypto_cipher_setkey(tfm,key,keylen);</p> 
 <p>if(ret){<!-- --></p> 
 <p>printk("&lt;1&gt;failed to setkey \n");</p> 
 <p>goto failed1;</p> 
 <p>}</p> 
 <p>sg_init_one(sg,code,codelen);</p> 
 <p>/* start encrypt */</p> 
 <p>ret = crypto_cipher_encrypt(tfm,sg,sg,codelen);</p> 
 <p>if(ret){<!-- --></p> 
 <p>printk("&lt;1&gt;encrypt failed \n");</p> 
 <p>goto failed1;</p> 
 <p>}</p> 
 <p>temp = kmap(sg[0].page)+</p> 
 <p>sg[0].offset;</p> 
 <p>hexdump(temp,sg[0].length);</p> 
 <p>/* start dencrypt */</p> 
 <p>templen = strlen(temp)/2;</p> 
 <p>sg_init_one(sg,temp,templen);</p> 
 <p>ret = crypto_cipher_decrypt(tfm,sg,sg,templen);</p> 
 <p>if(ret){<!-- --></p> 
 <p>printk("&lt;1&gt;dencrypt failed \n");</p> 
 <p>goto failed1;</p> 
 <p>}</p> 
 <p>result = kmap(sg[0].page)+</p> 
 <p>sg[0].offset;</p> 
 <p>printk("&lt;1&gt;%s\n",result);</p> 
 <p>//        hexdump(result,sg[0].length);</p> 
 <p>#if 0</p> 
 <p>if(memcmp(code,result,strlen(code))!=</p> 
 <p>0)</p> 
 <p>printk("&lt;1&gt;dencrpt was not successful\n");</p> 
 <p>else</p> 
 <p>printk("&lt;1&gt;dencrypt was successful\n");</p> 
 <p>#endif</p> 
 <p>failed1:</p> 
 <p>crypto_free_tfm(tfm);</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>static void __exit test_exit(void)</p> 
 <p>{<!-- --></p> 
 <p>}</p> 
 <p>module_init(test_init);</p> 
 <p>module_exit(test_exit);</p> 
 <p>MODULE_LICENSE("GPL");</p> 
 <p>MODULE_AUTHOR("robert@cm");</p> 
 <p>部分采用网络代码。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6b7e28b85a378d09ad44ee8020ae4fd9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【论文】未：考虑出行距离和时延的基于小区的动态拥塞定价方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0733f4e6458b3a00c3f8be56191ca14c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android9.0官方下载,安卓9.0系统刷机包 官方正式版</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>