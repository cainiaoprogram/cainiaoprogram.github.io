<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Ansible 的脚本 --- playbook 剧本 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Ansible 的脚本 --- playbook 剧本" />
<meta property="og:description" content="一、playbook简介 Playbook（剧本）是系统 Ansible 指令的集合，其利用 YAML 语言编写，自上而下按顺序一次执行。它可以实现一些 Ad-Hoc 指令无法实现的操作，例如从一台机器的文件中抓取内容并赋为另一台机器的变量等操作。
playbook本身由以下各部分组成 Tasks任务，即通过 task调用 ansible的模板将多个操作组织在一个playbook中运行Variables变量Templates模板Handlers处理器，当notify所在任务满足changed状态条件时，触发执行的操作Roles角色 Playbook 的执行结果有三种颜色： 红色： 表示有task执行失败或者提醒的信息黄色：表示执行了且改变了远程主机状态绿色：表示执行成功 Playbook 剧本语法 一个 Playbook 主要有以下四部分构成：
**target section：**定义将要执行 playbook 的远程主机组；**variable section：**定义 playbook 运行时需要使用的变量；**task section：**定义将要在远程主机上执行的任务列表；**handler section：**定义task执行完成以后需要调用的任务； 二、编写playbook 示例1：yum安装apache vim test1.yaml --- #yaml文件以---开头，以表明这是一个yaml文件，可省略 - name: first play #定义一个play的名称，可省略 gather_facts: false #设置不进行facts信息收集，这可以加快执行速度，可省略 hosts: webservers #指定要执行任务的被管理主机组，如多个主机组用冒号分隔 remote_user: root #指定被管理主机上执行任务的用户 tasks: #定义任务列表，任务列表中的各任务按次序逐个在hosts中指定的主机上执行 - name: test connection #自定义任务名称 ping: #使用 module: [options] 格式来定义一个任务 - name: disable selinux command: &#39;/sbin/setenforce 0&#39; #command模块和shell模块无需使用key=value格式 ignore_errors: True #如执行命令的返回值不为0，就会报错，tasks停止，可使用ignore_errors忽略失败的任务 - name: disable firewalld service: name=firewalld state=stopped #使用 module: options 格式来定义任务，option使用key=value格式 - name: mount cdrom mount: src=/dev/sr0 path=/mnt state=mounted fstype=iso9660 ignore_errors: True - name: install httpd yum: name=httpd state=latest - name: install configuration file for httpd copy: src=/opt/httpd." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7825e3ae7c6b2021907b080f1f93800a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-19T09:02:30+08:00" />
<meta property="article:modified_time" content="2023-06-19T09:02:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Ansible 的脚本 --- playbook 剧本</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、playbook简介</h2> 
<p>Playbook（剧本）是系统 Ansible 指令的集合，其利用 YAML 语言编写，自上而下按顺序一次执行。它可以实现一些 Ad-Hoc 指令无法实现的操作，例如从一台机器的文件中抓取内容并赋为另一台机器的变量等操作。</p> 
<p></p> 
<h3>playbook本身由以下各部分组成</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:666px;"><tbody><tr><td><strong>Tasks</strong></td><td>任务，即通过 task调用 ansible的模板将多个操作组织在一个playbook中运行</td></tr><tr><td><strong>Variables</strong></td><td>变量</td></tr><tr><td><strong>Templates</strong></td><td>模板</td></tr><tr><td><strong>Handlers</strong></td><td>处理器，当notify所在任务满足changed状态条件时，触发执行的操作</td></tr><tr><td><strong>Roles</strong></td><td>角色</td></tr></tbody></table> 
<p></p> 
<h3><strong>Playbook 的执行结果有三种颜色：</strong></h3> 
<ul><li>红色： 表示有task执行失败或者提醒的信息</li><li>黄色：表示执行了且改变了远程主机状态</li><li>绿色：表示执行成功</li></ul> 
<h3>Playbook 剧本语法</h3> 
<p>一个 Playbook 主要有以下四部分构成：</p> 
<ul><li>**target section：**定义将要执行 playbook 的远程主机组；</li><li>**variable section：**定义 playbook 运行时需要使用的变量；</li><li>**task section：**定义将要在远程主机上执行的任务列表；</li><li>**handler section：**定义task执行完成以后需要调用的任务；</li></ul> 
<h3></h3> 
<h2>二、编写playbook</h2> 
<h3>示例1：yum安装apache</h3> 
<pre><code>vim test1.yaml
---     #yaml文件以---开头，以表明这是一个yaml文件，可省略
- name: first play     #定义一个play的名称，可省略
  gather_facts: false    #设置不进行facts信息收集，这可以加快执行速度，可省略
  hosts: webservers    #指定要执行任务的被管理主机组，如多个主机组用冒号分隔
  remote_user: root    #指定被管理主机上执行任务的用户
  tasks:     #定义任务列表，任务列表中的各任务按次序逐个在hosts中指定的主机上执行
   - name: test connection    #自定义任务名称
     ping:     #使用 module: [options] 格式来定义一个任务
   - name: disable selinux
     command: '/sbin/setenforce 0'    #command模块和shell模块无需使用key=value格式
     ignore_errors: True     #如执行命令的返回值不为0，就会报错，tasks停止，可使用ignore_errors忽略失败的任务
   - name: disable firewalld
     service: name=firewalld state=stopped    #使用 module: options 格式来定义任务，option使用key=value格式
   - name: mount cdrom
     mount: src=/dev/sr0 path=/mnt state=mounted fstype=iso9660
     ignore_errors: True
   - name: install httpd
     yum: name=httpd state=latest
   - name: install configuration file for httpd
     copy: src=/opt/httpd.conf dest=/etc/httpd/conf/httpd.conf    #这里需要一个事先准备好的/opt/httpd.conf文件
     notify: "restart httpd"    #如以上操作后为changed的状态时，会通过notify指定的名称触发对应名称的handlers操作
   - name: start httpd service
     service: enabled=true name=httpd state=started
  handlers:     #handlers中定义的就是任务，此处handlers中的任务使用的是service模块
   - name: restart httpd    #notify和handlers中任务的名称必须一致
     service: name=httpd state=restarted
##Ansible在执行完某个任务之后并不会立即去执行对应的handler，而是在当前play中所有普通任务都执行完后再去执行handler，这样的好处是可以多次触发notify，但最后只执行一次对应的handler，从而避免多次重启</code></pre> 
<h2>运行playbook</h2> 
<pre><code class="hljs">ansible-playbook test1.yaml
//补充参数：
-k（–ask-pass）：用来交互输入ssh密码
-K（-ask-become-pass）：用来交互输入sudo密码
-u：指定用户
ansible-playbook test1.yaml --syntax-check    #检查yaml文件的语法是否正确
ansible-playbook test1.yaml --list-task       #检查tasks任务
ansible-playbook test1.yaml --list-hosts      #检查生效的主机
ansible-playbook test1.yaml --start-at-task='install httpd'     #指定从某个task开始运行
</code></pre> 
<p></p> 
<h3>示例2：yum安装nginx</h3> 
<pre><code class="hljs">- name: second play
  gather_facts: false
  hosts: webservers
  remote_user: root
  tasks:
  - name: disable selinux
    command: '/usr/sbin/setenforce 0'
    ignore_errors: true
  - name: disable firewalld
    service: name=firewalld state=stopped enabled=no
  - name: upload nginx.repo
    copy: src=/etc/yum.repos.d/nginx.repo dest=/etc/yum.repos.d/nginx.repo
  - name: install nginx
    yum: name=nginx state=latest
  - name: prepare httpd configuration file
    copy: src=/opt/default.confdest=/etc/nginx/conf.d/default.conf
    notify: " restart nginx"
  - name: start nginx
    service: name=nginx state=started enabled=yes
  handlers:
  - name: restart nginx
    service: name=nginx state=restarted
</code></pre> 
<p></p> 
<h2>定义、引用变量</h2> 
<pre><code class="hljs">- name: second play
  hosts: dbservers
  remote_user: root
  vars:                 #定义变量
   - groupname: mysql   #格式为 key: value
   - username: nginx
  tasks:
   - name: create group
     group: name={<!-- -->{groupname}} system=yes gid=306    #使用 {<!-- -->{key}} 引用变量的值
   - name: create user
     user: name={<!-- -->{username}} uid=306 group={<!-- -->{groupname}} 
   - name: copy file
     copy: content="{<!-- -->{ansible_default_ipv4}}" dest=/opt/vars.txt    #gather_facts设为true，进行facts信息收集，在setup模块中可以获取facts变量信息
</code></pre> 
<p>变量可命令行里定义</p> 
<p><strong>格式</strong>：<code>ansible-playbook 剧本文件名 -e "变量名=定义的值"</code></p> 
<p></p> 
<h2>迭代</h2> 
<p>Ansible提供了很多种循环结构，一般都命名为with_items，作用等同于 loop 循环。</p> 
<ul><li><strong>with_items</strong>：{<!-- -->{item}}会把所有的列表展开进行遍历输出，with_flattened也可以替代with_items</li><li><strong>with_list</strong>：{<!-- -->{item}}会把每个列表当作一个整体输出。如果每个列表中只有一个值，则效果与with items一致。loop也可以替代ith</li><li><strong>with_together</strong>：{<!-- -->{item}}引用时会把每个列表相同位置的值对齐合并后输出</li><li><strong>with nested</strong>：{<!-- -->{item}}引用时会把每个列表的值两两组合循环输出</li></ul> 
<h4>with_item 单循环输出</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/95/54/ZBQI1SHL_o.png"></p> 
<p>即在webservers的opt目录下创建a,b,c,d四个文件 </p> 
<h4><strong>两个列表时，with_item 循环输出</strong></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ad/90/Q8JQip8u_o.png"></p> 
<p>即两个列表依次遍历一遍 </p> 
<h4>遍历定义的变量</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d2/d1/FSXKznYB_o.png"></p> 
<h4>不止一种变量时 </h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b9/0d/LNPabrq4_o.png"></p> 
<p>列表也可以横向表示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e2/0d/vfnNVOyM_o.png"> </p> 
<h4>with_list  每组列表一起循环的输出 </h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d7/70/58VF8C6d_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c4/a6/LnRkpkOW_o.png"> </p> 
<h4> with_together 同一列表位置数据组合输出的循环 </h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7f/ed/pUmI8gq7_o.png"></p> 
<h4> 两个列表数量不一样</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3a/b1/uQcBY8EU_o.png"></p> 
<p>没有的输出为None</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/a1/bhB4bEVx_o.png"></p> 
<h4> with_nested 列表数据循环匹配的循环（根据列表个数定义有多少层的循环）</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/90/d1/RVMzKAMK_o.png"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/25/36/buqYylnK_o.png"></p> 
<p></p> 
<h2>when条件判断 </h2> 
<p>在Ansible中，提供的唯一一个通用的条件判断是when指令，当when指令的值为true时，则该任务执行，否则不执行该任务。</p> 
<p>when一个比较常见的应用场景是实现跳过某个主机不执行任务或者只有满足条件的主机执行任务</p> 
<pre><code class="hljs">vim demo7.yaml
---
- hosts: all
  remote_user: root
  tasks:
   - name: stop httpd
     service: name=httpd state=stopped enabled=no
     when: ansible_default_ipv4.address == "192.168.126.28"      #when指令中的变量名不需要手动加上 {<!-- -->{}}
     或 
     when: inventory_hostname == "&lt;主机名&gt;"
	
ansible-playbook demo7.yaml
</code></pre> 
<h4>when条件还可以通过 ！=（不等于条件来进行判断）</h4> 
<pre><code class="hljs">vim demo7.yaml
---
- hosts: all
  remote_user: root
  tasks:
   - name: stop httpd
     service: name=httpd state=stopped enabled=no
     when: ansible_default_ipv4.address != "192.168.126.28"      #when指令中的变量名不需要手动加上 {<!-- -->{}}
     或 
     when: inventory_hostname == "&lt;主机名&gt;"
	
ansible-playbook demo7.yaml
</code></pre> 
<h2>Templates 模块</h2> 
<p>Jinja是基于Python的模板引擎。Template类是Jinja的一个重要组件，可以看作是一个编译过的模板文件，用来产生目标文本，传递Python的变量给模板去替换模板中的标记。</p> 
<h4>过程演示</h4> 
<ol><li>先准备一个以 .j2 为后缀的 template 模板文件，设置引用的变量</li></ol> 
<pre><code class="hljs">cp /etc/httpd/conf/httpd.conf /opt/httpd.conf.j2

vim /opt/httpd.conf.j2
Listen {<!-- -->{http_port}}				#42行，修改
ServerName {<!-- -->{server_name}}			#95行，修改
DocumentRoot "{<!-- -->{root_dir}}"          #119行，修改
</code></pre> 
<p>2.修改主机清单文件，使用主机变量定义一个变量名相同，而值不同的变量</p> 
<pre><code class="hljs">[webservers]
192.168.126.28 http_port=192.168.126.28:80 server_name=www.test1.com:80 root_dir=/etc/httpd/htdocs

[dbservers]
192.168.126.29 http_port=192.168.126.29:80 server_name=www.test2.com:80 root_dir=/etc/httpd/htdocs
</code></pre> 
<p>3.编写 playbook</p> 
<pre><code class="hljs">vim apache.yaml
---
- hosts: all
  remote_user: root
  vars:
    - package: httpd
    - service: httpd
  tasks:
    - name: install httpd package
      yum: name={<!-- -->{package}} state=latest
    - name: install configure file
      template: src=/opt/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf     #使用template模板
      notify:
        - restart httpd
    - name: create root dir
      file: path=/etc/httpd/htdocs state=directory
    - name: start httpd server
      service: name={<!-- -->{service}} enabled=true state=started
  handlers:
    - name: restart httpd
      service: name={<!-- -->{service}} state=restarted

ansible-playbook apache.yaml
</code></pre> 
<p></p> 
<h2>tags 模块</h2> 
<p>可以在一个playbook中为某个或某些任务定义“标签”，在执行此playbook时通过ansible-playbook命令使用--tags选项能实现仅运行指定的tasks。<br> playbook还提供了一个特殊的tags为always。作用就是当使用always作为tags的task时，无论执行哪一个tags时，定义有always的tags都会执行。</p> 
<h4>单标签的使用</h4> 
<pre><code class="hljs">vim test1.yaml
---
- name: this is a play for testing variables
  hosts: webservers
  remote_user: root
  tasks:
   - name: position 1
     debug:
       msg: 'ls /opt'
     tags:
      - only
   - name: position 2
     debug:
       msg: 'ls /mnt'
 
ansible-playbook test1.yaml --tags="only"  #只会执行only标签的task
</code></pre> 
<h3>多标签的运用</h3> 
<pre><code class="hljs">- name: this is a play for testing variables
  hosts: webservers
  remote_user: root
  tasks:
   - name: position 1
     debug:
       msg: '测试标签1'
     tags:
      - one
   - name: position 2
     debug:
       msg: '测试标签2'
     tags:
      - two
   - name: position 3
     debug:
       msg: '测试标签3'
     tags:
      - one

ansible-playbook test2.yaml --tags="one" #只执行标签one的task</code></pre> 
<h3></h3> 
<h2>Roles 模块</h2> 
<p>Ansible为了层次化、结构化地组织Playbook，使用了角色（roles），roles可以根据层次型结构自动装载变量文件、task以及handlers等。简单来讲，roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中，并可以便捷地include它们。roles一般用于基于主机构建服务的场景中，但也可以用于构建守护进程等场景中。</p> 
<h4></h4> 
<h4>简述Ansible角色</h4> 
<p>数据中心有各种不同类型的主机。如web服务器、数据库服务器，基于开发环境的服务器。随着时间的推移，具有处理所有这些情况的任务和人员的Ansible playbook将变得庞大而复杂。</p> 
<ul><li>角色允许将复杂的剧本组织成独立的、更小的剧本和文件。</li><li>角色提供了一种从外部文件加载任务、处理程序和变量的方法。</li><li>角色也可关联和引用静态的文件和模板。</li><li>角色可以编写成满足普通用途需求，并且能被重复利用。</li><li>定义角色的文件具有特定的名称，并以严格的目录结构进行组织。</li></ul> 
<h4>roles 的目录结构</h4> 
<pre><code class="hljs">cd /etc/ansible/
tree roles/
roles/      #剧本
├── web/    #角色，相当于 playbook 中的 每一个 play 主题
│   ├── files/         #普通文件
│   ├── templates/     #模板文件
│   ├── tasks/         #包含该角色要执行的任务列表
│   ├── handlers/      #处理器,不仅该角色可以使用，其他角色也能使用
│   ├── vars/          #其他变量
│   ├── defaults/      #默认变量
│   └── meta/          #元数据
└── db/
    ├── files/
    ├── templates/
    ├── tasks/
    ├── handlers/
    ├── vars/
    ├── defaults/
    └── meta/
</code></pre> 
<h4>roles 内各目录含义解释</h4> 
<ul><li><strong>files</strong>：用来存放由 copy 模块或 script 模块调用的文件。</li><li><strong>templates</strong>：用来存放 jinjia2 模板，template 模块会自动在此目录中寻找 jinjia2 模板文件。</li><li><strong>tasks</strong>：此目录应当包含一个 main.yml 文件，用于定义此角色的任务列表，此文件可以使用 include 包含其它的位于此目录的 task 文件。</li><li><strong>handlers</strong>：此目录应当包含一个 main.yml 文件，用于定义此角色中触发条件时执行的动作。</li><li><strong>vars</strong>：此目录应当包含一个 main.yml 文件，用于定义此角色用到的变量。</li><li><strong>defaults</strong>：此目录应当包含一个 main.yml 文件，用于为当前角色设定默认变量。</li><li><strong>meta</strong>：此目录应当包含一个 main.yml 文件，用于定义此角色的特殊设定及其依赖关系。</li></ul> 
<h4>在一个 playbook 中使用 roles 的步骤</h4> 
<p>1.创建以 roles 命名的目录</p> 
<pre><code class="hljs">mkdir /etc/ansible/roles/ -p    #yum装完默认就有</code></pre> 
<p>2.创建全局变量目录（可选）</p> 
<pre><code class="hljs">mkdir /etc/ansible/group_vars/ -p
touch /etc/ansible/group_vars/all     #文件名自己定义，引用的时候注意</code></pre> 
<p>3.在 roles 目录中分别创建以各角色名称命名的目录，如 httpd、mysql</p> 
<pre><code class="hljs">mkdir /etc/ansible/roles/httpd
mkdir /etc/ansible/roles/mysql</code></pre> 
<p>4.在每个角色命名的目录中分别创建files、handlers、tasks、templates、meta、defaults和vars目录，用不到的目录可以创建为空目录，也可以不创建</p> 
<pre><code class="hljs">mkdir /etc/ansible/roles/httpd/{files,templates,tasks,handlers,vars,defaults,meta}
mkdir /etc/ansible/roles/mysql/{files,templates,tasks,handlers,vars,defaults,meta}
</code></pre> 
<p>5.在每个角色的 handlers、tasks、meta、defaults、vars 目录下创建 main.yml 文件，千万不能自定义文件名</p> 
<pre><code class="hljs">touch /etc/ansible/roles/httpd/{defaults,vars,tasks,meta,handlers}/main.yml
touch /etc/ansible/roles/mysql/{defaults,vars,tasks,meta,handlers}/main.yml
</code></pre> 
<p>6.修改 site.yml 文件，针对不同主机去调用不同的角色</p> 
<pre><code class="hljs">（6）修改 site.yml 文件，针对不同主机去调用不同的角色
vim /etc/ansible/site.yml
---
- hosts: webservers
  remote_user: root
  roles:
     - httpd
- hosts: dbservers
  remote_user: root
  roles:
     - mysql
</code></pre> 
<p>7.运行 ansible-playbook</p> 
<pre><code class="hljs">cd /etc/ansible
ansible-playbook site.yml</code></pre> 
<h3></h3> 
<h3>示例：安装lamp</h3> 
<pre><code class="hljs">mkdir /etc/ansible/roles/httpd/{files,templates,tasks,handlers,vars,defaults,meta} -p
mkdir /etc/ansible/roles/mysql/{files,templates,tasks,handlers,vars,defaults,meta} -p
mkdir /etc/ansible/roles/php/{files,templates,tasks,handlers,vars,defaults,meta} -p

touch /etc/ansible/roles/httpd/{defaults,vars,tasks,meta,handlers}/main.yml
touch /etc/ansible/roles/mysql/{defaults,vars,tasks,meta,handlers}/main.yml
touch /etc/ansible/roles/php/{defaults,vars,tasks,meta,handlers}/main.yml
</code></pre> 
<p>编写httpd模块</p> 
<pre><code class="hljs">写一个简单的tasks/main.yml
vim /etc/ansible/roles/httpd/tasks/main.yml
- name: install apache
  yum: name={<!-- -->{pkg}} state=latest
- name: start apache
  service: enabled=true name={<!-- -->{svc}} state=started
 
//定义变量：可以定义在全局变量中，也可以定义在roles角色变量中，一般定义在角色变量中
vim /etc/ansible/roles/httpd/vars/main.yml
pkg: httpd
svc: httpd
</code></pre> 
<p>编写mysql模块</p> 
<pre><code class="hljs">vim /etc/ansible/roles/mysql/tasks/main.yml
- name: install mysql
  yum: name={<!-- -->{pkg}} state=latest
- name: start mysql
  service: enabled=true name={<!-- -->{svc}} state=started
  
vim /etc/ansible/roles/mysql/vars/main.yml
pkg:
  - mariadb
  - mariadb-server
svc: mariadb
</code></pre> 
<p>编写php模块</p> 
<pre><code class="hljs">vim /etc/ansible/roles/php/tasks/main.yml
- name: install php
  yum: name={<!-- -->{pkg}} state=latest
- name: start php-fpm
  service: enabled=true name={<!-- -->{svc}} state=started

vim /etc/ansible/roles/php/vars/main.yml
pkg:
  - php
  - php-fpm
svc: php-fpm
</code></pre> 
<p>编写roles</p> 
<pre><code class="hljs">vim /etc/ansible/site.yml
---
- hosts: webservers
  remote_user: root
  roles:
   - httpd
   - mysql
   - php</code></pre> 
<pre><code class="hljs">cd /etc/ansible
ansible-playbook site.yml</code></pre> 
<h2>总结</h2> 
<h4>迭代循环方式</h4> 
<ul><li><strong>with_items</strong>：{<!-- -->{item}}会把所有的列表展开进行遍历输出，with_flattened也可以替代with_items</li><li><strong>with_list</strong>：{<!-- -->{item}}会把每个列表当作一个整体输出。如果每个列表中只有一个值，则效果与with items一致。loop也可以替代ith</li><li><strong>with_together</strong>：{<!-- -->{item}}引用时会把每个列表相同位置的值对齐合并后输出</li><li><strong>with nested</strong>：{<!-- -->{item}}引用时会把每个列表的值两两组合循环输出</li></ul> 
<h4>when</h4> 
<p>when判断返回值为true，即条件成立时执行当前任务，条件不成立则不执行当前任务</p> 
<p>when: inventoryhostname =='主机名|IP'<br> when: facts信息字段!='XXXXXXX'</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8be42561fa44719170c1889eb896cdff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">llvm程序手册</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b2f6a31a89c8ed5f50e5b9deedfeb6f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于【C语言】中scanf与getchar的用法和常见错误详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>