<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Nuxt3入门 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Nuxt3入门" />
<meta property="og:description" content="文章目录 前言一、Nuxt是什么？1.SSR概念2.Nuxt3.Hydration概念 二、Nuxt3准备1.Node版本2.nvm 三、创建一个Nuxt3应用四、应用场景1.SSR2.SSG3.CSR 总结扩展阅读 前言 上一篇文章（了解Vue3预渲染）探讨了Vue的预渲染方案，但是预渲染对于首屏有动态内容的网页还是有着较大的局限性，需要考虑使用SSR（服务端渲染），所以这篇文章来介绍一下基于Vue的SSR方案，即Nuxt框架，同时也会陆续把最近学习Nuxt3框架过程中的一些心得体会记录下来，分享给大家。那么开始吧~
一、Nuxt是什么？ 1.SSR概念 SSR全称是 Server-Side Rendering，即服务端渲染。与客户端渲染 CSR（Client-Side Rendering）不同的是，SSR输出的是一个渲染完成的HTML，整个渲染过程是在服务器端进行的。 用户访问网址后得到的是一个完全呈现的HTML 页面，其中包含网站所需的所有信息，无需等待任何 JavaScript 或 CSS 文件加载。这意味着访问网站的用户将能够比在等待JavaScript 文件加载时只是看着空白屏幕更快地看到所有内容；另外搜索引擎爬虫可以直接看到完全渲染的页面，也有利于网页搜索引擎优化，即 SEO（Search Engine Optimization）。
2.Nuxt Nuxt 是一个基于Vue.js的、可用来创建服务端渲染（SSR）应用的通用应用框架，对应 React 技术栈的叫做 Next.js 框架，两者名字长得很像，都是支持 SSR 技术的框架，由于我没使用过Next.js，所以无法对比就不介绍了Next了，只对比 Nuxt2 。
Nuxt3优势
①：全面拥抱Vue3
②：全面支持TypeScript
③：自动导入与引用（包括 Vue3 的 setup 语法）
④：支持所有渲染模式和所有环境
⑤：充分支持Vue生态系统（如：Vite、Pinia）
特点：
①：基于目录结构约定式开发
②：允许使用路由规则为每个路由使用不同的渲染模式或缓存策略
3.Hydration概念 当浏览器请求启用通用（服务器端&#43;客户端）渲染的 URL 时，服务器会向浏览器返回完全渲染的 HTML 页面。无论页面是提前生成并缓存还是动态渲染，在某个时刻，Nuxt 都会在服务器环境中运行 JavaScript (Vue.js) 代码，生成 HTML 文档。用户立即获得我们应用程序的内容，这与客户端渲染相反。此步骤类似于PHP 或 Ruby 应用程序执行的传统服务器端渲染。
为了不失去客户端渲染方法的优点，例如动态界面和页面转换，一旦下载了 HTML 文档，客户端（浏览器）就会加载在后台服务器上运行的 JavaScript 代码。浏览器再次解释它（因此称为通用渲染），Vue.js 控制文档并启用交互性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/217d3a744e325c901ed7ced426102301/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-02T18:46:37+08:00" />
<meta property="article:modified_time" content="2023-07-02T18:46:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Nuxt3入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#Nuxt_11" rel="nofollow">一、Nuxt是什么？</a></li><li><ul><li><a href="#1SSR_12" rel="nofollow">1.SSR概念</a></li><li><a href="#2Nuxt_15" rel="nofollow">2.Nuxt</a></li><li><a href="#3Hydration_30" rel="nofollow">3.Hydration概念</a></li></ul> 
  </li><li><a href="#Nuxt3_35" rel="nofollow">二、Nuxt3准备</a></li><li><ul><li><a href="#1Node_36" rel="nofollow">1.Node版本</a></li><li><a href="#2nvm_43" rel="nofollow">2.nvm</a></li></ul> 
  </li><li><a href="#Nuxt3_54" rel="nofollow">三、创建一个Nuxt3应用</a></li><li><a href="#_69" rel="nofollow">四、应用场景</a></li><li><ul><li><a href="#1SSR_71" rel="nofollow">1.SSR</a></li><li><a href="#2SSG_73" rel="nofollow">2.SSG</a></li><li><a href="#3CSR_75" rel="nofollow">3.CSR</a></li></ul> 
  </li><li><a href="#_79" rel="nofollow">总结</a></li><li><a href="#_85" rel="nofollow">扩展阅读</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_4"></a>前言</h2> 
<p>上一篇文章（<a href="https://blog.csdn.net/m0_55119483/article/details/130950623">了解Vue3预渲染</a>）探讨了Vue的预渲染方案，但是预渲染对于首屏有动态内容的网页还是有着较大的局限性，需要考虑使用SSR（服务端渲染），所以这篇文章来介绍一下基于Vue的SSR方案，即Nuxt框架，同时也会陆续把最近学习Nuxt3框架过程中的一些心得体会记录下来，分享给大家。那么开始吧~</p> 
<hr> 
<h2><a id="Nuxt_11"></a>一、Nuxt是什么？</h2> 
<h3><a id="1SSR_12"></a>1.SSR概念</h3> 
<p>SSR全称是 Server-Side Rendering，即服务端渲染。与客户端渲染 CSR（Client-Side Rendering）不同的是，SSR输出的是一个渲染完成的HTML，整个渲染过程是在服务器端进行的。 用户访问网址后得到的是一个完全呈现的HTML 页面，其中包含网站所需的所有信息，无需等待任何 JavaScript 或 CSS 文件加载。这意味着访问网站的用户将能够比在等待JavaScript 文件加载时只是看着空白屏幕更快地看到所有内容；另外搜索引擎爬虫可以直接看到完全渲染的页面，也有利于网页搜索引擎优化，即 SEO（Search Engine Optimization）。</p> 
<h3><a id="2Nuxt_15"></a>2.Nuxt</h3> 
<p>Nuxt 是一个基于Vue.js的、可用来创建服务端渲染（SSR）应用的通用应用框架，对应 React 技术栈的叫做 Next.js 框架，两者名字长得很像，都是支持 SSR 技术的框架，由于我没使用过Next.js，所以无法对比就不介绍了Next了，只对比 Nuxt2 。</p> 
<p><strong>Nuxt3</strong>优势<br> ①：全面拥抱Vue3<br> ②：全面支持TypeScript<br> ③：自动导入与引用（包括 Vue3 的 setup 语法）<br> ④：支持所有渲染模式和所有环境<br> ⑤：充分支持Vue生态系统（如：Vite、Pinia）</p> 
<p>特点：<br> ①：基于目录结构约定式开发<br> ②：允许使用路由规则为每个路由使用不同的渲染模式或缓存策略</p> 
<p><img src="https://images2.imgbox.com/9b/2c/Glhn8tcN_o.png" alt="Nuxt3"></p> 
<h3><a id="3Hydration_30"></a>3.Hydration概念</h3> 
<p>当浏览器请求启用通用（服务器端+客户端）渲染的 URL 时，服务器会向浏览器返回完全渲染的 HTML 页面。无论页面是提前生成并缓存还是动态渲染，在某个时刻，Nuxt 都会在服务器环境中运行 JavaScript (Vue.js) 代码，生成 HTML 文档。用户立即获得我们应用程序的内容，这与客户端渲染相反。此步骤类似于PHP 或 Ruby 应用程序执行的传统服务器端渲染。<br> 为了不失去客户端渲染方法的优点，例如动态界面和页面转换，一旦下载了 HTML 文档，客户端（浏览器）就会加载在后台服务器上运行的 JavaScript 代码。浏览器再次解释它（因此称为通用渲染），Vue.js 控制文档并启用交互性。<br> 使静态页面在浏览器中具有交互性称为<code>Hydration</code>。（"Hydration"有翻译为“水化”，也有翻译为“水合作用”）</p> 
<h2><a id="Nuxt3_35"></a>二、Nuxt3准备</h2> 
<h3><a id="1Node_36"></a>1.Node版本</h3> 
<p>Nuxt3 需要在 Node.js 版本 v16.10.0 或以上运行，在终端输入以下命令可查看当前node版本号。</p> 
<pre><code class="prism language-bash"><span class="token function">node</span> -v
</code></pre> 
<p>附个 Node.js <a href="https://nodejs.org/zh-cn" rel="nofollow">官网地址</a> ，看看最新Node.js版本出到多少了，有没有惊讶到了😂。</p> 
<h3><a id="2nvm_43"></a>2.nvm</h3> 
<p>我们在项目开发过程中，不同的项目可能依赖不同版本的NodeJS，当然不可能为了一个项目卸载重装Node，通常使用 <code>nvm</code> 这个工具管理版本，NVM：Node Version Manage，即Node的版本管理工具。使用NVM，可以很方便地在多个NodeJS版本之间进行切换。安装NVM前，建议先卸载电脑上现有的NodeJS。</p> 
<ul><li><a href="https://github.com/nvm-sh/nvm">NVM 官网</a></li><li><a href="https://github.com/coreybutler/nvm-windows">NVM for Windows</a></li></ul> 
<pre><code class="prism language-bash">nvm <span class="token function">ls</span>               // 查看已安装node版本
nvm <span class="token function">install</span> vXX      // 安装对应vXX版本的node
nvm uninstall vXX    // 卸载对应vXX版本的node
nvm use xxx          // 选择使用XXX版本
</code></pre> 
<h2><a id="Nuxt3_54"></a>三、创建一个Nuxt3应用</h2> 
<pre><code class="prism language-bash">npx nuxi init <span class="token operator">&lt;</span>project-name<span class="token operator">&gt;</span>
</code></pre> 
<p>创建完并且安装好依赖后就可以运行dev命令开启本地服务器访问页面了，Welcome to Nuxt!</p> 
<table><thead><tr><th>运行命令</th><th>描述</th></tr></thead><tbody><tr><td>npm run dev</td><td>启动开发服务器</td></tr><tr><td>npm run build</td><td>打包命令。使用混合渲染模式创建一个.output目录，其中包含所有应用程序、服务器和依赖项，可用于生产。可通过node、pm2等启动后提供WEB服务。</td></tr><tr><td>npm run generate</td><td>打包之后每个页面都生成了HTML页面，只有首屏的数据是之前渲染好了，但是其它数据还是从后台获取，要想改变首屏的数据的话，需要重新打包发布才行。可以部署在任何静态托管服务上。</td></tr><tr><td>npm run preview</td><td>运行build命令后启动服务器以预览应用程序</td></tr><tr><td>npm run postinstall</td><td>在应用程序中创建.nuxt目录并生成类型</td></tr></tbody></table> 
<h2><a id="_69"></a>四、应用场景</h2> 
<p>Nuxt.js是一个非常强大的框架，但是并不是所有类型的网页都必须使用SSR技术。由于使用SSR需要服务端渲染每一个请求，对服务器资源要求高，尤其是高并发访问的情况，会大量占用服务端CPU资源。我们需要根据业务需求来决定使用什么技术栈去开发页面。</p> 
<h3><a id="1SSR_71"></a>1.SSR</h3> 
<p>如果项目首屏是动态数据的，对首屏速度要求高且很在乎在搜索引擎的排名，可以考虑使用SSR。</p> 
<h3><a id="2SSG_73"></a>2.SSG</h3> 
<p>如果项目首屏数据与用户不是强关联的、内容相对稳定的且需要SEO的可以考虑使用预渲染 SSG（Static Site Generation），Nuxt也可以做SSG，避免服务端的渲染压力。</p> 
<h3><a id="3CSR_75"></a>3.CSR</h3> 
<p>如果网站只是内部产品不需要SEO，或者项目较小不太在意首屏性能的，或者项目是富交互和动态内容的应用，那么还是直接用Vue是最明智的选择。可以通过优化项目体积及其他优化方法如：骨架屏或者添加loading图等方式来优化用户体验。</p> 
<hr> 
<h2><a id="_79"></a>总结</h2> 
<p>以上就是全部内容，这篇文章主要介绍了SSR方面的概念，以及创建了 Nuxt3 框架的应用。在前端领域技术确实是日新月异，Nuxt3目前来说还是一门比较新的技术，同时也是选择VUE技术栈去做SSR比较完善的解决方案，所以值得我们去学习这个框架，“技多不压身”。学习任何一门语言框架初期都离不开看文档和多做实战项目这两个步骤，后续我会继续分享总结Nuxt3的实践心得。</p> 
<p>如果此篇文章对您有帮助，欢迎您【点赞】、【收藏】！也欢迎您【评论】留下宝贵意见，共同探讨一起学习~</p> 
<hr> 
<h2><a id="_85"></a>扩展阅读</h2> 
<ul><li><a href="https://nuxt.com/" rel="nofollow">Nuxt 官网</a></li><li><a href="https://nuxt.com.cn/" rel="nofollow">Nuxt 中文网</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/832b9b02c3399b9295d818fb8917fe65/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Matlab中统计矩阵中元素个数的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10fe5df1b7624ed9e43136981719c03e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第十周：机器学习周报</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>