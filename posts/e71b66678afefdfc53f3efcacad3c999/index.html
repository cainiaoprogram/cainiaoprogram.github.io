<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何读懂一段代码 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何读懂一段代码" />
<meta property="og:description" content="对于一段不知道背景知识的代码，如何读懂？ 对于程序员来说，读代码要比写代码困难。因为写代码是在自己的世界创造，而读代码却是在接触别人的世界的建筑。每个人的世界都是不尽相同的，因此在读别人的代码时，总会有些滞涩，我也是更愿意自己写，读懂算法思想、梗概，然后自己来实现。因此在过去很长一段时间，写的代码都只是一时之快，很难长久——写完不久之后，我已经不认识自己曾经写的东西了，甚至觉得那是别人写的。 要学会写，先学会读。 读别人的代码，就是走出自己的舒适区，挑战自己的理解力，开阔自己的思维。同时，在读的过程中会意识到怎样的代码才更容易让人理解。 今天读到的一段如下（Matlab代码，不是很熟悉语法）：
for i = 2:n p(i) = inf; s(i) = i; end %用Ford 算法求最短路, 赋初值 for k = 1 : n %求有向赋权图中源点vs到汇点vt的最短路 pd = 1; for i = 2 : n for j = 1 : n if (p(i) &gt; p(j) &#43; a(j,i)) p(i) = p(j) &#43; a(j,i); s(i) = j; %s(i)为点i的标号，表示在最短路径中i点的前一个点的编号 pd = 0; end; end; end if (pd) break; end; end %求最短路的Ford 算法结束 第一步，先读最简单的——注释。最容易被看懂的注释应该解释的是读者最想知道的内容：这段代码什么意思？但注释不能写那么详细，要尽量写得简洁，所以应该注释的是：这段代码是来做什么的。 这里用名词简洁介绍：Ford算法，作用：求最短路径。那么就知道这段代码是用来求最短路径的，但这还不够。 第二步，读结构。程序的基本结构：顺序、循环、条件分支是大部分程序代码所共有的。这个程序的第一层有顺序的两个结构：循环、循环。第一个循环是顺序语句；第二个循环内含一个两层循环和一个条件语句，两层循环内是一个条件语句。 这步看似复杂，其实熟悉语法的可以很快过掉，即使不熟悉语法，也可以半猜半查的读懂结构，这一步是为后面了解程序所做的数据操作做准备。 第三步，读变量。由于Matlab中的变量是弱类型的，风格不好的代码很难找到其声明或定义，变量往往是拿来就用，因此需要以关键词的形式来分类理解。 这个程序中，有如下关键词是已知显示定义了的：p、s、pd；有如下关键词是未知的（来自于前文或者全局）：a；有如下关键词是用于循环变量的：k，i，j。列举如下： p：初始化为(0,inf,inf…." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e71b66678afefdfc53f3efcacad3c999/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-05-10T23:39:13+08:00" />
<meta property="article:modified_time" content="2017-05-10T23:39:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何读懂一段代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>对于一段不知道背景知识的代码，如何读懂？ <br> 对于程序员来说，读代码要比写代码困难。因为写代码是在自己的世界创造，而读代码却是在接触别人的世界的建筑。每个人的世界都是不尽相同的，因此在读别人的代码时，总会有些滞涩，我也是更愿意自己写，读懂算法思想、梗概，然后自己来实现。因此在过去很长一段时间，写的代码都只是一时之快，很难长久——写完不久之后，我已经不认识自己曾经写的东西了，甚至觉得那是别人写的。 <br> 要学会写，先学会读。 <br> 读别人的代码，就是走出自己的舒适区，挑战自己的理解力，开阔自己的思维。同时，在读的过程中会意识到怎样的代码才更容易让人理解。 <br> 今天读到的一段如下（Matlab代码，不是很熟悉语法）：</p> 
<pre class="prettyprint"><code class=" hljs matlab">   <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">2</span>:n
        p(<span class="hljs-built_in">i</span>) = <span class="hljs-built_in">inf</span>;
        s(<span class="hljs-built_in">i</span>) = <span class="hljs-built_in">i</span>;
    <span class="hljs-keyword">end</span>  <span class="hljs-comment">%用Ford 算法求最短路, 赋初值</span>

    <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span> : n   <span class="hljs-comment">%求有向赋权图中源点vs到汇点vt的最短路</span>
        pd = <span class="hljs-number">1</span>; 
        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">2</span> : n
            <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span> : n
                <span class="hljs-keyword">if</span> (p(<span class="hljs-built_in">i</span>) &gt; p(<span class="hljs-built_in">j</span>) + a(<span class="hljs-built_in">j</span>,<span class="hljs-built_in">i</span>))
                    p(<span class="hljs-built_in">i</span>) = p(<span class="hljs-built_in">j</span>) + a(<span class="hljs-built_in">j</span>,<span class="hljs-built_in">i</span>);
                    s(<span class="hljs-built_in">i</span>) = <span class="hljs-built_in">j</span>;  <span class="hljs-comment">%s(i)为点i的标号，表示在最短路径中i点的前一个点的编号</span>
                    pd = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>;
            <span class="hljs-keyword">end</span>;
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">if</span> (pd)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">end</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-comment">%求最短路的Ford 算法结束</span></code></pre> 
<p>第一步，先读最简单的——注释。最容易被看懂的注释应该解释的是读者最想知道的内容：这段代码什么意思？但注释不能写那么详细，要尽量写得简洁，所以应该注释的是：这段代码是来做什么的。 <br> 这里用名词简洁介绍：Ford算法，作用：求最短路径。那么就知道这段代码是用来求最短路径的，但这还不够。 <br> 第二步，读结构。程序的基本结构：顺序、循环、条件分支是大部分程序代码所共有的。这个程序的第一层有顺序的两个结构：循环、循环。第一个循环是顺序语句；第二个循环内含一个两层循环和一个条件语句，两层循环内是一个条件语句。 <br> 这步看似复杂，其实熟悉语法的可以很快过掉，即使不熟悉语法，也可以半猜半查的读懂结构，这一步是为后面了解程序所做的数据操作做准备。 <br> 第三步，读变量。由于Matlab中的变量是弱类型的，风格不好的代码很难找到其声明或定义，变量往往是拿来就用，因此需要以关键词的形式来分类理解。 <br> 这个程序中，有如下关键词是已知显示定义了的：p、s、pd；有如下关键词是未知的（来自于前文或者全局）：a；有如下关键词是用于循环变量的：k，i，j。列举如下： <br> p：初始化为(0,inf,inf….) 长度n <br> s：初始化为(0,2,3,4…)长度n <br> pd：初始化为1 <br> a：已知为一个矩阵形式的变量 <br> k：范围1到n <br> i：范围2到n <br> j：范围1到n <br> 第四步，结合变量和结构，读数据的操作。 <br> 程序的难点在于三层循环。最外层的终止条件除了变量k到n还有pd！=0；第二层无其他条件；最内层有一个条件语句，条件达成则使pd=0，说明多重循环中，若内两层共(n-1)*n次判断均未进入条件则退出最外循环。 <br> 基本循环结构已经明了，最关键的是其内部的条件语句以及执行的内容： <br> 条件：p(i) &gt; p(j) + a(j,i) <br> 执行：p(i) = p(j) + a(j,i); s(i) = j; <br> 这里有注释： “s(i)为点i的标号，表示在最短路径中i点的前一个点的编号” <br> 条件中的p(i)，i是从2到n，p(j)，j是从1到n，最初p(i)都是inf（无穷），因此第一轮是将p(i)赋值为p(j)+a(j,i)，这里可以将a(j,i)看作j-&gt;i，当做j到i的连接量。第二轮、第三轮，就是对当前的赋值量进行更新，试图找到更小的连接量。 <br> 注释最开始就说了，这是找最短路径，便可以理解：这里是在循环中求出p(i)的最小值，p(i)最终就是s(i)-&gt;i的连接量，也就是最短的路径权值。 <br> 数据的操作归结如下： <br> 操作次数最大为n*n*(n-1)，每一次进行判断，s(i)-&gt;i，也就是当前这个连接量是不是比s(j)-&gt;j、j-&gt;i这个量更大，是则更新。循环直到无可更新。</p> 
<p>这应该就是Ford算法的描述，通常我们喜欢根据这个描述来写程序，但逆向的过程却很难受，很困难，但这样逆向才能认识到自己写的代码的可读性存在的问题。比如变量的使用，对于ijk这种烂大街的变量由于是循环变量无可厚非，但是p、a、pd的使用却是让人摸不着头脑。对于这类变量的命名，我们应该使用更有意义的命名，不要嫌麻烦（否则让读的人很麻烦），对于弱类型语言，尽可能在命名中表现出类型，比如这里的a命名成mat_connect就可以。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dc0bf9895c1c846e4851692da7b42f7b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">开发企业微信之接收消息服务器配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da4e596f37f213b6fefafeb3fceddbc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nginx配置https后，网站出现无法访问情况</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>