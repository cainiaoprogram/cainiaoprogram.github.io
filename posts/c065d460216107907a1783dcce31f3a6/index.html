<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（十）linux下使用串口控制语音模块 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（十）linux下使用串口控制语音模块" />
<meta property="og:description" content="平台：NanoPi fire3
系统：Ubuntu core&#43;Qt5.10（linux kernel 4.4）
语音模块：SYN6288A
模块链接：https://item.taobao.com/item.htm?spm=a1z09.2.0.0.6fa82e8dV9HJVN&amp;id=575307622242&amp;_u=51pfiddhc204
使用引脚信息
串口3对应设备结点/dev/ttySAC3
模块官方给了51单片机的程序，现在修改并移植到linux中运行
修改了其中两个头文件，如下
SYN6288.h
/***************************乐声电子科技有限公司**************************** ** 工程名称：YS-SYN6288语音合成配套程序 **	CPU: STC89LE52 **	晶振：22.1184MHZ **	波特率：9600 bit/S **	配套产品信息：YS-SYN6288语音合成模块 ** http://yuesheng001.taobao.com ** 作者：zdings ** 联系：751956552@qq.com ** 修改日期：2012.8.25 ** 说明：。。 /***************************乐声电子科技有限公司******************************/ #ifndef SYN6288_H #define SYN6288_H #include &lt;stdlib.h&gt; #include &#34;config.h&#34; /**************芯片设置命令*********************/ uint8_t SYN_StopCom[]={0xFD,0X00,0X02,0X02,0XFD};//停止合成 uint8_t SYN_SuspendCom[]={0XFD,0X00,0X02,0X03,0XFC};//暂停合成 uint8_t SYN_RecoverCom[]={0XFD,0X00,0X02,0X04,0XFB};//恢复合成 uint8_t SYN_ChackCom[]={0XFD,0X00,0X02,0X21,0XDE};//状态查询 uint8_t SYN_PowerDownCom[]={0XFD,0X00,0X02,0X88,0X77};//进入POWER DOWN 状态命令 /***********************************************/ /*********************************************************** * 名 称： YS-SYN6288 文本合成函数 * 功 能： 发送合成文本到SYN6288芯片进行合成播放 * 入口参数：Music(背景音乐选择):0无背景音乐。1-15：相关背景音乐 *HZdata:文本指针变量 * 出口参数： * 说 明： 本函数只用于文本合成，具备背景音乐选择。默认波特率9600bps。	* 调用方法：例： SYN_FrameInfo（0，“乐声电子科技”）； **********************************************************/ int SYN_FrameInfo(uint8_t Music,uint8_t *HZdata, unsigned char *buf) { /****************需要发送的文本**********************************/ unsigned char *Frame_Info = buf; unsigned char HZ_Length; unsigned char ecc = 0; //定义校验字节 unsigned int i=0; HZ_Length =strlen(HZdata); //需要发送文本的长度 /*****************帧固定配置信息**************************************/ Frame_Info[0] = 0xFD ; //构造帧头FD Frame_Info[1] = 0x00 ; //构造数据区长度的高字节 Frame_Info[2] = HZ_Length &#43; 3; //构造数据区长度的低字节 Frame_Info[3] = 0x01 ; //构造命令字：合成播放命令	Frame_Info[4] = 0x01 | Music&lt;&lt;4 ; //构造命令参数：背景音乐设定 /*******************校验码计算***************************************/	for(i = 0; i&lt;5; i&#43;&#43;) //依次发送构造好的5个帧头字节 { ecc=ecc^(Frame_Info[i]);	//对发送的字节进行异或校验	} for(i= 0; i&lt;HZ_Length; i&#43;&#43;) //依次发送待合成的文本数据 { ecc=ecc^(HZdata[i]); //对发送的字节进行异或校验	}	/*******************发送帧信息***************************************/	memcpy(&amp;Frame_Info[5], HZdata, HZ_Length); Frame_Info[5&#43;HZ_Length]=ecc; return 5&#43;HZ_Length&#43;1; //PrintCom(Frame_Info,5&#43;HZ_Length&#43;1); } #endif config." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c065d460216107907a1783dcce31f3a6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-05T19:25:47+08:00" />
<meta property="article:modified_time" content="2019-06-05T19:25:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（十）linux下使用串口控制语音模块</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;">平台：NanoPi fire3</p> 
<p style="margin-left:0cm;">系统：Ubuntu core+Qt5.10（linux kernel 4.4）</p> 
<p style="margin-left:0cm;">语音模块：SYN6288A</p> 
<p style="margin-left:0cm;">模块链接：<a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.6fa82e8dV9HJVN&amp;id=575307622242&amp;_u=51pfiddhc204" rel="nofollow">https://item.taobao.com/item.htm?spm=a1z09.2.0.0.6fa82e8dV9HJVN&amp;id=575307622242&amp;_u=51pfiddhc204</a></p> 
<hr> 
<p style="margin-left:0cm;">使用引脚信息</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="581" src="https://images2.imgbox.com/cb/f0/LXr6Me4B_o.png" width="416"></p> 
<p style="margin-left:0cm;">串口3对应设备结点/dev/ttySAC3</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">模块官方给了51单片机的程序，现在修改并移植到linux中运行</p> 
<p style="margin-left:0cm;">修改了其中两个头文件，如下</p> 
<p style="margin-left:0cm;">SYN6288.h</p> 
<pre class="has"><code class="hljs language-cpp">/***************************乐声电子科技有限公司****************************
**  工程名称：YS-SYN6288语音合成配套程序
**	CPU: STC89LE52
**	晶振：22.1184MHZ
**	波特率：9600 bit/S
**	配套产品信息：YS-SYN6288语音合成模块
**                http://yuesheng001.taobao.com
**  作者：zdings
**  联系：751956552@qq.com
**  修改日期：2012.8.25
**  说明：。。
/***************************乐声电子科技有限公司******************************/


#ifndef SYN6288_H
#define SYN6288_H

#include &lt;stdlib.h&gt;
#include "config.h"

/**************芯片设置命令*********************/
uint8_t SYN_StopCom[]={0xFD,0X00,0X02,0X02,0XFD};//停止合成
uint8_t SYN_SuspendCom[]={0XFD,0X00,0X02,0X03,0XFC};//暂停合成
uint8_t SYN_RecoverCom[]={0XFD,0X00,0X02,0X04,0XFB};//恢复合成
uint8_t SYN_ChackCom[]={0XFD,0X00,0X02,0X21,0XDE};//状态查询
uint8_t SYN_PowerDownCom[]={0XFD,0X00,0X02,0X88,0X77};//进入POWER DOWN 状态命令

/***********************************************/

/***********************************************************
* 名    称：  YS-SYN6288 文本合成函数
* 功    能：  发送合成文本到SYN6288芯片进行合成播放
* 入口参数：Music(背景音乐选择):0无背景音乐。1-15：相关背景音乐
            *HZdata:文本指针变量 
* 出口参数：
* 说    明： 本函数只用于文本合成，具备背景音乐选择。默认波特率9600bps。					 
* 调用方法：例： SYN_FrameInfo（0，“乐声电子科技”）；
**********************************************************/
int SYN_FrameInfo(uint8_t Music,uint8_t *HZdata, unsigned char *buf)
{
/****************需要发送的文本**********************************/ 
		 unsigned  char  *Frame_Info = buf;
         unsigned  char  HZ_Length;  
		 unsigned  char  ecc  = 0;  			//定义校验字节
	     unsigned  int i=0; 
		 HZ_Length =strlen(HZdata); 			//需要发送文本的长度
		 
 
/*****************帧固定配置信息**************************************/           
		 Frame_Info[0] = 0xFD ; 			//构造帧头FD
		 Frame_Info[1] = 0x00 ; 			//构造数据区长度的高字节
		 Frame_Info[2] = HZ_Length + 3; 		//构造数据区长度的低字节
		 Frame_Info[3] = 0x01 ; 			//构造命令字：合成播放命令		 		 
		 Frame_Info[4] = 0x01 | Music&lt;&lt;4 ;  //构造命令参数：背景音乐设定

/*******************校验码计算***************************************/		 
		 for(i = 0; i&lt;5; i++)   				//依次发送构造好的5个帧头字节
	     {  
	         ecc=ecc^(Frame_Info[i]);		//对发送的字节进行异或校验	
	     }

	   	 for(i= 0; i&lt;HZ_Length; i++)   		//依次发送待合成的文本数据
	     {  
	         ecc=ecc^(HZdata[i]); 				//对发送的字节进行异或校验		
	     }		 
/*******************发送帧信息***************************************/		  
		  memcpy(&amp;Frame_Info[5], HZdata, HZ_Length);
		  Frame_Info[5+HZ_Length]=ecc;

		  return 5+HZ_Length+1;
		  //PrintCom(Frame_Info,5+HZ_Length+1);
}

#endif</code></pre> 
<p style="margin-left:0cm;">config.h</p> 
<pre class="has"><code class="hljs language-cpp">/******************** 飞音云电子***************
* File Name          : config.h
* Author             : http://yuesheng001.taobao.com/
* Version						 : zds0.0.3
* Date First Issued  : 10/12/2011
* Description        : public header file
*******************************************************/
#ifndef __CONFIG_H
#define __CONFIG_H
/*****相关宏定义***/
    /* exact-width signed integer types */
typedef   signed          char int8_t;
typedef   signed short     int int16_t;
typedef   signed           int int32_t;
typedef   signed       long int int64_t;

    /* exact-width unsigned integer types */
typedef unsigned          char uint8_t;
typedef unsigned short     int uint16_t;
typedef unsigned           int uint32_t;
typedef unsigned       long int uint64_t;

#endif</code></pre> 
<p style="margin-left:0cm;">自己编写linux端程序</p> 
<p style="margin-left:0cm;">首先头文件</p> 
<pre class="has"><code class="hljs language-cpp">//标准输入输出头文件
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

//打开文件需要的头文件
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

//打开串口需要的头文件
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;

//语音模块的头文件
#include "SYN6288.h"</code></pre> 
<p style="margin-left:0cm;">串口初始化函数</p> 
<pre class="has"><code class="hljs language-cpp">/*******************************************************************************************
	函数名：set_opt();
	函数作用：串口初始化
	参数说明： 参数1：fd----open函数返回的文件句柄
			   参数2 	：nSpeed----波特率设置（2400，4800，9600，115200）
			   参数3：nBits----数据位设置（7，8）
			   参数4：nEvent----校验位设置（'O'，'E'，'N'）
			   参数5：nStop----停止位（1，2）			   
*******************************************************************************************/
int set_opt(int fd,int nSpeed, int nBits, char nEvent, int nStop){
	struct termios newtio,oldtio;
	//将旧的参数配置文件赋给fd指向的文件
	if(tcgetattr(fd,&amp;oldtio) != 0){
		perror("SetupSerial 1");
		return -1;
	}
	//清空结构体newtio中的数据
	bzero(&amp;newtio,sizeof(newtio));
	newtio.c_cflag |= CLOCAL|CREAD;
	newtio.c_cflag &amp;= ~CSIZE;

	//配置数据位
	switch (nBits)
		{
		case 7:{
			newtio.c_cflag |= CS7;
			break;}
		case 8:{
			newtio.c_cflag |= CS8;
			break;}
		}
	
	//配置校验位
	switch (nEvent)
		{
		case 'O':{
			newtio.c_cflag |= PARENB;
			newtio.c_cflag |= PARODD;
			newtio.c_iflag |= (INPCK | ISTRIP);
			break;}
		case 'E':{
			newtio.c_iflag |= (INPCK | ISTRIP);
			newtio.c_cflag |= PARENB;
			newtio.c_cflag &amp;= ~PARODD;
			break;}
		case 'N':{
				newtio.c_cflag &amp;= ~PARENB;
				break;}
		}

	//配置波特率
	switch (nSpeed)
		{
		case 2400:{
			cfsetispeed(&amp;newtio,B2400);
			cfsetospeed(&amp;newtio,B2400);
			break;}
		case 4800:{
			cfsetispeed(&amp;newtio,B4800);
			cfsetospeed(&amp;newtio,B4800);
			break;}
		case 9600:{
			cfsetispeed(&amp;newtio,B9600);
			cfsetospeed(&amp;newtio,B9600);
			break;}
		case 115200:{
			cfsetispeed(&amp;newtio,B115200);
			cfsetospeed(&amp;newtio,B115200);
			break;}
		case 460800:{
			cfsetispeed(&amp;newtio,B460800);
			cfsetospeed(&amp;newtio,B460800);
			break;}
		default:{
			cfsetispeed(&amp;newtio,B9600);
			cfsetospeed(&amp;newtio,B9600);
			break;}
		}

	//配置停止位
	if(nStop == 1){
		newtio.c_cflag &amp;= ~CSTOPB;
	}
	else if(nStop == 2){
		newtio.c_cflag |= CSTOPB;
	}
	//清空数据
	newtio.c_cc[VTIME] = 0;
	newtio.c_cc[VMIN] = 0;

/*******************************************************************************************
	函数名：tcflush();
	函数作用：清空串口缓存器BUFFER中的数据
	参数说明： 参数1：fd----open函数返回的文件句柄
			   参数2：TCIFLUSH----清除正受到的数据，且不会读出来
			   		  TCOFLUSH----清除正写入的数据，且不会发送至终端
			          TCIOFLUSH----清除所有正在发生的IO数据
	函数返回值：成功返回0，失败返回-1			   
*******************************************************************************************/
	tcflush(fd,TCIFLUSH);

/*******************************************************************************************
	函数名：tcsetattr();
	函数作用：设置串口参数函数
	参数说明： 参数1：fd----open函数返回的文件句柄
			   参数2：TCSANOW----不等数据传输完毕就立刻改变属性
			   		  TCSADRAIN----等待所有数据传输结束才改变属性
			          TCSAFLUSH----清空输入输出缓冲区才改变属性
			   参数3：newtio----在旧的参数基础上修改后的参数
	函数返回值：成功返回0，失败返回-1			   
*******************************************************************************************/	
	if((tcsetattr(fd,TCSANOW,&amp;newtio)) != 0){
		perror("com set error");
		return -1;
	}
	return 0;
}</code></pre> 
<p>串口发送函数</p> 
<pre class="has"><code class="hljs language-cpp">static void UART_SendData(int fd,unsigned char *buffer,int count)
{
	int j;

	write(fd, buffer, count);

	//打印发出的数据至屏幕
	printf("send : ");
	//清空输出流缓存区
	fflush(stdout);
	for(j=0;j&lt;count;j++)
	{
		printf("%02X ",buffer[j]);
		fflush(stdout);
	}
	printf("\n");
}</code></pre> 
<p style="margin-left:0cm;">通过命令行传入要转语音的文本</p> 
<pre class="has"><code class="hljs language-cpp">int main(int argc, char **argv)
{
	unsigned char *buffer = (unsigned char *)malloc(sizeof(unsigned char) * 200);
	int bufSize;
	int i, ret;

	if(argc != 2)
	{
		printf("argument number error!!\n");
		printf("%s \"the text you want to say\"\n", argv[0]);
		return -1;
	}


	if((fd = open(uartPath,O_RDWR|O_NOCTTY)) &lt; 0)
	{
		printf("can not open %s\n",uartPath);
		return -1;
	}

	//printf("text: %s\n", argv[1]);
	
	set_opt(fd,9600,8,'N',1);

	bufSize = SYN_FrameInfo(0, argv[1], buffer);

	UART_SendData(fd, buffer, bufSize);

	free(buffer);
	free(buffer_gb2312);
	
	close(fd);
	
	return 0;
}</code></pre> 
<p style="margin-left:0cm;">交叉编译成功，测试后发现，语音模块说的东西和实际传入的不一样。</p> 
<p style="margin-left:0cm;">查看模块的数据手册，发现了这个一句话。</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="51" src="https://images2.imgbox.com/05/b6/zAe59t2h_o.png" width="813"></p> 
<p style="margin-left:0cm;">由于linux下的文字编码为utf-8，所以语音模块不能识别该编码。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">接下来转换编码格式，将传入的utf-8的编码转换为GB2312</p> 
<p style="margin-left:0cm;">加入头文件</p> 
<pre class="has"><code class="hljs language-cpp">//字符编码转换
#include &lt;iconv.h&gt;</code></pre> 
<pre class="has"><code class="hljs language-cpp">//字符编码转换
static int charset_convert(const char *from_charset, const char *to_charset,
                           char *in_buf, size_t in_left, char *out_buf, size_t out_left)
{
    iconv_t icd = (iconv_t)-1;
    size_t sRet = -1;
    char *pIn = in_buf;
    char *pOut = out_buf;
    size_t outLen = out_left;
 
    if (NULL == from_charset || NULL == to_charset || NULL == in_buf || 0 &gt;= in_left || NULL == out_buf || 0 &gt;= out_left)
    {
        return -1;
    }
 
    icd = iconv_open(to_charset, from_charset);
    if ((iconv_t)-1 == icd)
    {
        return -1;
    }
 
    sRet = iconv(icd, &amp;pIn, &amp;in_left, &amp;pOut, &amp;out_left);
    if ((size_t)-1 == sRet)
    {
        iconv_close(icd);
        return -1;
    }
 
    out_buf[outLen - out_left] = 0;
    iconv_close(icd);
    return (int)(outLen - out_left);
}


static int charset_convert_UTF8_TO_GB2312(char *in_buf, size_t in_left, char *out_buf, size_t out_left)
{
    return charset_convert("UTF-8", "GB2312", in_buf, in_left, out_buf, out_left);
}
</code></pre> 
<p style="margin-left:0cm;">在主程序中修改如下</p> 
<pre class="has"><code class="hljs language-cpp">    bufSize = strlen(argv[1]);
    buffer_gb2312 = (unsigned char *)malloc(sizeof(unsigned char) * bufSize);

    ret = charset_convert_UTF8_TO_GB2312(argv[1], (size_t)bufSize, buffer_gb2312, (size_t)bufSize);
    if (-1 == ret)
    {
    	printf("failed convert UTF-8 to GB2312\n");
        return -1;
    }	

	bufSize = SYN_FrameInfo(0, buffer_gb2312, buffer);

	UART_SendData(fd, buffer, bufSize);
</code></pre> 
<p style="margin-left:0cm;">交叉编译成功，测试后可以语音正常识别。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">完整的源码放在github上，有需要可以自行下载。 名称为190531</p> 
<p style="margin-left:0cm;">https://github.com/ljy980330/opencv_face_sys</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">有任何问题可以在下面给我留言！大家一起学习！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9871bac9ca00c4108082f1b89f038e84/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Edittext焦点处理；</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3c05834ea9277b64774b197367ffa50/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用 keepalived 设置虚拟 IP 环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>