<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>并发编程 — 原子类 AtomicReference 详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="并发编程 — 原子类 AtomicReference 详解" />
<meta property="og:description" content="通过对 AtomicInteger、AtomicBoolean 和 AtomicLong 分析我们发现，这三个原子类只能对单个变量进行原子操作，那么我们如果要对多个变量进行原子操作，这三个类就无法实现了。那如果要进行多个变量进行原子操作呢？操作方式就是，先把 多个变量封装成一个类，然后通过 AtomicReference 进行操作。
众所周知，对象的引用其实是一个4字节的数字，代表着在JVM堆内存中的引用地址，对一个4字节数字的读取操作和写入操作本身就是原子性的，通常情况下，我们对对象引用的操作一般都是获取该引用或者重新赋值（写入操作），我们也没有办法对对象引用的4字节数字进行加减乘除运算，那么为什么JDK要提供AtomicReference类用于支持引用类型的原子性操作呢？
1、AtomicReference的应用场景 这里通过设计一个个人银行账号资金变化的场景，逐渐引入AtomicReference的使用，该实例有些特殊，需要满足如下几点要求。
个人账号被设计为不可变对象，一旦创建就无法进行修改。个人账号类只包含两个字段：账号名、现金数字。为了便于验证，我们约定个人账号的现金只能增多而不能减少。 根据前两个要求，我们简单设计一个代表个人银行账号的Java类DebitCard，该类将被设计为不可变。
public class DebitCard { private final String name; private final int account; public DebitCard(String name, int account) { this.name = name; this.account = account; } public String getName() { return name; } public int getAccount() { return account; } @Override public String toString() { return &#34;DebitCard {name=\&#34;&#34;&#43;name&#43;&#34;\&#34;,&#34; &#43; &#34;account=&#34;&#43;account&#43;&#34;}&#34;; } } 1.1、通过 volatile 修饰的多线程 public class AtomicReferenceDemo1 { // 定义为 volatile 修饰的变量 volatile static DebitCard debitCard = new DebitCard(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a07f0ffec787f73d9d6e77422b18c8cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-12T12:49:00+08:00" />
<meta property="article:modified_time" content="2020-12-12T12:49:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">并发编程 — 原子类 AtomicReference 详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>通过对 AtomicInteger、AtomicBoolean 和 AtomicLong 分析我们发现，这三个原子类只能对单个变量进行原子操作，那么我们如果要对多个变量进行原子操作，这三个类就无法实现了。那如果要进行多个变量进行原子操作呢？操作方式就是，先把 多个变量封装成一个类，然后通过 AtomicReference 进行操作。</p> 
<p>众所周知，对象的引用其实是一个4字节的数字，代表着在JVM堆内存中的引用地址，对一个4字节数字的读取操作和写入操作本身就是原子性的，通常情况下，我们对对象引用的操作一般都是获取该引用或者重新赋值（写入操作），我们也没有办法对对象引用的4字节数字进行加减乘除运算，那么为什么JDK要提供AtomicReference类用于支持引用类型的原子性操作呢？</p> 
<h3>1、AtomicReference的应用场景</h3> 
<p>这里通过设计一个个人银行账号资金变化的场景，逐渐引入AtomicReference的使用，该实例有些特殊，需要满足如下几点要求。</p> 
<ul><li> 个人账号被设计为不可变对象，一旦创建就无法进行修改。</li><li>个人账号类只包含两个字段：账号名、现金数字。</li><li>为了便于验证，我们约定个人账号的现金只能增多而不能减少。</li></ul> 
<p>根据前两个要求，我们简单设计一个代表个人银行账号的Java类DebitCard，该类将被设计为不可变。</p> 
<pre><code class="language-java">
public class DebitCard {
    private final String name;
    private final int account;
    public DebitCard(String name, int account) {
        this.name = name;
        this.account = account;
    }
    public String getName() {
        return name;
    }

    public int getAccount() {
        return account;
    }

    @Override
    public String toString() {
        return "DebitCard {name=\""+name+"\"," +
                "account="+account+"}";
    }
}
</code></pre> 
<h4>1.1、通过 volatile 修饰的多线程 </h4> 
<pre><code class="language-java">
public class AtomicReferenceDemo1 {

    // 定义为 volatile 修饰的变量
    volatile static  DebitCard debitCard = new DebitCard("zhangSan", 10);

    public static void main(String[] args) {
        IntStream.range(0, 10).forEach(i -&gt; {
            new Thread(() -&gt; {
                while (true){
                    // 读取全局的 debitCard 对象
                    final DebitCard debitCard1 = debitCard;
                    // 基于全局的 debitCard 加10构建一个新的对象
                    DebitCard newDc = new DebitCard(debitCard1.getName(), debitCard1.getAccount() + 10);
                    // 把新建的都行赋值给 全局的变量
                    debitCard = newDc;
                    System.out.println(newDc);
                    try {
                        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(20));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }, "T-" + i).start();
        });
    }
}</code></pre> 
<p>运行结果如下：</p> 
<p style="text-align:center;"><img alt="" height="285" src="https://images2.imgbox.com/1c/a6/SQa34sxJ_o.png" width="511"></p> 
<p> 根据运行结果我们发现，出现了两处存在问题的地方(上图标红的地方)，这个是什么造成的呢？这就涉及到我们之前讲过的，虽然被 volatile 关键字修饰的变量每次更改都可以立即被其他线程看到，但是我们针对对象引用的修改其实至少包含了如下两个步骤，<strong>获取该引用</strong>和<strong>改变该引用 </strong>每一个步骤都是原子性的操作，但组合起来就无法保证原子性了。</p> 
<h4>1.2、通过加锁的多线程</h4> 
<p>针对上面的问题，我们首先想到的可能是通过加锁(synchronized 或 Lock )解决，如下代码所示：</p> 
<pre><code class="language-java">// 加 锁 操作
synchronized (AtomicReferenceDemo1.class) {
    // 读取全局的 debitCard 对象
   final DebitCard debitCard1 = debitCard;
   // 基于全局的 debitCard 加10构建一个新的对象
 DebitCard newDc = new DebitCard(debitCard1.getName(), debitCard1.getAccount() + 10);
// 把新建的都行赋值给 全局的变量
  debitCard = newDc;
  System.out.println(newDc);
  try {
                            TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(10));
} catch (InterruptedException e) {
    e.printStackTrace();
}
}</code></pre> 
<h4>1.3、 AtomicReference的非阻塞解决方案</h4> 
<p>第2小节中的方案似乎满足了我们的需求，但是它却是一种阻塞式的解决方案，同一时刻只能有一个线程真正在工作，其他线程都将陷入阻塞，因此这并不是一种效率很高的解决方案，这个时候就可以利用 AtomicReference 的非阻塞原子性解决方案提供更加高效的方式了。</p> 
<pre><code class="language-java">public class AtomicReferenceDemo1 {

    static AtomicReference&lt;DebitCard&gt; ref = new AtomicReference(new DebitCard("zhangSan", 10));

    public static void main(String[] args) {



        IntStream.range(0, 10).forEach(i -&gt; {
            new Thread(() -&gt; {

                while (true){
                    DebitCard debitCard = ref.get();
                    DebitCard newDc = new DebitCard(debitCard.getName(), debitCard.getAccount() + 10);
                    if(ref.compareAndSet(debitCard, newDc)){
                        System.out.println(Thread.currentThread().getName() + " 当前值为： " + newDc.toString() + " " + System.currentTimeMillis());
                    }
                    long sleepValue = (long) (Math.random() * 10000);
                    try {
                        Thread.sleep(sleepValue);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }, "T-" + i).start();
        });
    }
}</code></pre> 
<h3>2、AtomicReference的基本用法</h3> 
<h4>2.1、创建 AtomicReference</h4> 
<p>  AtomicReference是一个泛型类，它的构造与其他原子类型的构造一样，也提供了无参和一个有参的构造函数。</p> 
<ul><li> AtomicReference()：当使用无参构造函数创建AtomicReference对象的时候，需要再次调用set()方法为AtomicReference内部的value指定初始值。</li><li> AtomicReference(V initialValue)：创建AtomicReference对象时顺便指定初始值。</li></ul> 
<h4>2.2、常用方法</h4> 
<ul><li><strong>compareAndSet(V expect, V update)</strong>：原子性地更新AtomicReference内部的value值，其中expect代表当前AtomicReference的value值，update则是需要设置的新引用值。该方法会返回一个boolean的结果，当expect和AtomicReference的当前值不相等时，修改会失败，返回值为false，若修改成功则会返回true。</li><li><strong>getAndSet(V newValue)</strong>：原子性地更新AtomicReference内部的value值，并且返回AtomicReference的旧值。</li><li><strong>getAndUpdate(UnaryOperator&lt;V&gt; updateFunction)</strong>：原子性地更新value值，并且返回AtomicReference的旧值，该方法需要传入一个Function接口。</li><li><strong>updateAndGet(UnaryOperator&lt;V&gt; updateFunction)</strong>：原子性地更新value值，并且返回AtomicReference更新后的新值，该方法需要传入一个Function接口。</li><li><strong>getAndAccumulate(V x, BinaryOperator&lt;V&gt; accumulatorFunction)</strong>：原子性地更新value值，并且返回AtomicReference更新前的旧值。该方法需要传入两个参数，第一个是更新后的新值，第二个是BinaryOperator接口。</li><li><strong>getAndAccumulate(V x, BinaryOperator&lt;V&gt; accumulatorFunction)</strong>：原子性地更新value值，并且返回AtomicReference更新前的旧值。该方法需要传入两个参数，第一个是更新后的新值，第二个是BinaryOperator接口。</li><li><strong>accumulateAndGet(V x, BinaryOperator&lt;V&gt; accumulatorFunction)</strong>：原子性地更新value值，并且返回AtomicReference更新后的值。该方法需要传入两个参数，第一个是更新的新值，第二个是BinaryOperator接口。</li><li>get()：获取AtomicReference的当前对象引用值。</li><li>set(V newValue)：设置AtomicReference最新的对象引用值，该新值的更新对其他线程立即可见。</li><li>lazySet(V newValue)：设置AtomicReference的对象引用值。lazySet方法的原理已经在AtomicInteger中介绍过了，这里不再赘述。</li></ul> 
<h3>3、AtomicReference的内幕</h3> 
<p>在AtomicReference类中，最关键的方法为compareAndSet()，下面来一探该方法的内幕。</p> 
<p><strong>AtomicReference中的方法</strong></p> 
<pre><code class="language-java">public final boolean compareAndSet(V expect, V update) {
  return unsafe.compareAndSwapObject(this, valueOffset, expect, update);
}</code></pre> 
<p><strong> Unsafe中的代码</strong></p> 
<pre><code class="language-java">public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</code></pre> 
<h3>4、总结</h3> 
<p>AtomicReference 类的使用比较简单，但是需要了解 AtomicReference 类的使用场景，才能在开发中更好的使用 AtomicReference。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/11052ca6f5781e79da2b1d228dc87673/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">理解对比表示学习(Contrastive Learning)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/24e4eea9d7a22b6a66da0d0d3c14d31c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">get请求和post请求的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>