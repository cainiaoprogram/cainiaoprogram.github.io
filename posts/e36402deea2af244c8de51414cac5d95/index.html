<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue组件之间的通讯方式数据处理：父子组件，兄弟组件，同级组件，爷孙组件 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue组件之间的通讯方式数据处理：父子组件，兄弟组件，同级组件，爷孙组件" />
<meta property="og:description" content="贴一张图先建立几个组件
先讲一句 每个 Vue 实例都实现了事件接口，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 Vue 的事件系统与浏览器的 EventTarget API 有所不同。尽管它们的运行起来类似， 但是 $on 和 $emit 并不是addEventListener 和 dispatchEvent 的别名， 另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。 那就同级兄弟之间数据的传递，刚才贴了兄弟之一，再贴一下它老弟
好了，老大想搞老二？他们之间怎么搞呢？
建个房啊，公共枢纽站多方便以后也划算
你可以随便建 我就不说了，我在src/assets/下创建一个js文件,内容如下
嗯，内容虽然少，但是我不想写啊，也防止你直接copy啊，哈哈
（eventBus中我们创建了一个新的Vue实例，以后它就承担起了组件之间通信的桥梁了，也就是中央事件总线。
（这句话不是我说的，不过的却是eventBus的确是这意思）
1、一句话就是我们在响应点击事件的sendMsg函数中，用$emit触发了一个自定义的userDefinedEvent事件， 并传递了一个字符串参数，而$emit实例方法触发当前实例(这里的当前实例就是bus)上的事件,附加参数就会传给监听器回调。 所以在 第二个组件里
在mounted中，监听了userDefinedEvent,并把传递过来的字符串参数传递给了$on监听器的回调函数
好了，三分归元气当然是把组建放到父级上去，注册这两个组件，并添加这两个组件的标签
算了，贴一下 总结
1、创建一个事件总线，例如demo中的eventBus，用它作为通信桥梁 2、在需要传值的组件中用bus.$emit触发一个自定义事件，并传递参数 3、在需要接收数据的组件中用bus.$on监听自定义事件，并在回调函数中处理传递过来的参数 好像有点长，算了，快一点，父子之间传递，父向子，子向父我这里放在了一个组件里
同时我们看到app.Vue里面的蓝2 是通过绑定的形式直接传进子组件的，不过是在子组件里的pros里面接受一下就能使用
里面的红1是子组件向父组件传值后（@reduce-parent） 是v-on 来监听子组件触发的事件，别瞎搞
至于下面methods里面写的，上面也说了，也不说了，好像完了…
对于vue来说，组件之间的消息传递是非常重要的，组件之间消息传递的各种方式有那些呢？
1. props和$emit 父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的。
&lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&#34;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&#34;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e36402deea2af244c8de51414cac5d95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-30T16:21:55+08:00" />
<meta property="article:modified_time" content="2023-08-30T16:21:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue组件之间的通讯方式数据处理：父子组件，兄弟组件，同级组件，爷孙组件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>贴一张图先建立几个组件<br> <img src="https://images2.imgbox.com/28/47/gBYgNaEf_o.png" alt="这里写图片描述"></p> 
<pre><code>先讲一句
每个 Vue 实例都实现了事件接口，即：
使用 $on(eventName) 监听事件
使用 $emit(eventName) 触发事件

Vue 的事件系统与浏览器的 EventTarget API 有所不同。尽管它们的运行起来类似，
但是 $on 和 $emit 并不是addEventListener 和 dispatchEvent 的别名，
另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。
</code></pre> 
<p>那就同级兄弟之间数据的传递，刚才贴了兄弟之一，再贴一下它老弟<br> <img src="https://images2.imgbox.com/c0/50/Vu09CjNg_o.png" alt="这里写图片描述"><br> 好了，老大想搞老二？他们之间怎么搞呢？<br> 建个房啊，公共枢纽站多方便以后也划算<br> 你可以随便建 我就不说了，我在src/assets/下创建一个js文件,内容如下<br> <img src="https://images2.imgbox.com/d2/7c/s99VzLYQ_o.png" alt="这里写图片描述"><br> 嗯，内容虽然少，但是我不想写啊，也防止你直接copy啊，哈哈<br> （eventBus中我们创建了一个新的Vue实例，以后它就承担起了组件之间通信的桥梁了，也就是中央事件总线。<br> （这句话不是我说的，不过的却是eventBus的确是这意思）</p> 
<pre><code>1、一句话就是我们在响应点击事件的sendMsg函数中，用$emit触发了一个自定义的userDefinedEvent事件，
并传递了一个字符串参数，而$emit实例方法触发当前实例(这里的当前实例就是bus)上的事件,附加参数就会传给监听器回调。
</code></pre> 
<p><strong>所以在 第二个组件里</strong><br> 在mounted中，监听了userDefinedEvent,并把传递过来的字符串参数传递给了$on监听器的回调函数<br> 好了，三分归元气当然是把组建放到父级上去，注册这两个组件，并添加这两个组件的标签<br> <img src="https://images2.imgbox.com/06/5d/ZhIVrBgy_o.png" alt="这里写图片描述"><br> 算了，贴一下 总结</p> 
<pre><code>1、创建一个事件总线，例如demo中的eventBus，用它作为通信桥梁
2、在需要传值的组件中用bus.$emit触发一个自定义事件，并传递参数
3、在需要接收数据的组件中用bus.$on监听自定义事件，并在回调函数中处理传递过来的参数
</code></pre> 
<p>好像有点长，算了，快一点，父子之间传递，父向子，子向父我这里放在了一个组件里<br> <img src="https://images2.imgbox.com/d0/4c/CEJsy69s_o.png" alt="这里写图片描述"><br> 同时我们看到app.Vue里面的蓝2 是通过绑定的形式直接传进子组件的，不过是在子组件里的pros里面接受一下就能使用<br> <img src="https://images2.imgbox.com/3b/fc/9ktSRv5E_o.png" alt="这里写图片描述"><br> 里面的红1是子组件向父组件传值后（@reduce-parent） 是v-on 来监听子组件触发的事件，别瞎搞<br> 至于下面methods里面写的，上面也说了，也不说了，好像完了…</p> 
<p>对于vue来说，组件之间的消息传递是非常重要的，组件之间消息传递的各种方式有那些呢？<br> <font color="green" size="4"><strong>1. props和$emit</strong> </font><br> 父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的。</p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;&lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;
&lt;script&gt;
    Vue.component('child', {
        data() {
            return {
                childMessage: this.parentMessage
            }
        },
        template: `&lt;div&gt;
                        &lt;input type="text" v-model="childMessage" @input="passData(childMessage)"&gt;
                    &lt;/div&gt;`,
        props: ['parentMessage'],//得到父组件传递过来的数据
        methods: {
            passData(val) {
                this.$emit('getChildData', val)//触发父组件中的事件
            }
        }
    })
    Vue.component('parent', {
        template: `&lt;div&gt;
                    &lt;p&gt;this is parent compoent!{<!-- -->{reciveChildMemessage}}&lt;/p&gt;
                    &lt;child :parentMessage="parentMessage" v-on:getChildData="getChildData"&gt;&lt;/child&gt;
                   &lt;/div&gt;`,
        data() {
            return {
                parentMessage: 'hello',
                reciveChildMemessage: ''// 定义一个字段来接收子组件里面传来的值
            }
        },
        methods: {
            getChildData(val) {//执行子组件触发的事件
                this.reciveChildMemessage = val // 定义一个字段来接收子组件里面传来的值
                console.log(val)
            }
        }
    })
    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>上例中，有父组件parent和子组件child。<br> 1).父组件传递了message数据给子组件，并且通过<font color="red" size="3">v-on绑定了一个getChildData</font>事件来监听子组件的触发事件；<br> 2).子组件通过props得到相关的message数据,最后通过<font color="red" size="3">this.$emit</font>触发了getChildData事件。</p> 
<p><font color="green" size="4"><strong>2.$attrs和$listeners</strong> </font><br> 第一种方式处理父子组件之间的数据传输有一个问题：如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？<br> <font color="red" size="3">Vue 2.4</font>开始提供了<font color="red" size="3">$attrs</font>和<font color="red" size="3">$listeners</font>来解决这个问题，能够让组件A之间传递消息给组件C。</p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;first&gt;&lt;/first&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('third',{
        template:`&lt;div title="third, component"&gt;
                  &lt;input type="text" v-model="$attrs.firstToThirdMessage" @input="setThirdData($attrs.firstToThirdMessage)"&gt;
                  &lt;/div&gt;`,
        methods:{
            setThirdData(val){
                //触发父组件A中的事件
                this.$emit('getThirdData', val)
            },
        }
    })
    Vue.component('second',{
        data(){
            return {
                secondMessage:this.firstToSecondMessage
            }
        },
        template:`&lt;div title="second, component"&gt;
                    &lt;input type="text" v-model="secondMessage" @input="setSecondData(secondMessage)"&gt;
                     &lt;third v-bind="$attrs" v-on="$listeners"&gt;&lt;/third&gt;
                  &lt;/div&gt;`,
        props:['firstToSecondMessage'],//得到父组件传递过来的数据
        methods:{
            setSecondData(val){
                //触发父组件中的事件
                this.$emit('getSecondData',val)
            }
        }
    })
    Vue.component('first',{
        template:`&lt;div title="first, component"&gt;
                    &lt;p&gt;this is first compoent!&lt;/p&gt;
                    &lt;p&gt;来自Second 组件的数据：{<!-- -->{firstToSecondMessage}}&lt;/p&gt;
                    &lt;p&gt;来自third 组件的数据：{<!-- -->{firstToThirdMessage}}&lt;/p&gt;
                    &lt;second :firstToThirdMessage="firstToThirdMessage" :firstToSecondMessage="firstToSecondMessage" v-on:getThirdData="getThirdData" v-on:getSecondData="getSecondData"&gt;&lt;/second&gt;
                 &lt;/div&gt;`,
        data(){

            return {
                firstToSecondMessage:'hello second',
                firstToThirdMessage:'hello third' //传递给c组件的数据
            }
        },
        methods:{
            getSecondData(val){
                this.firstToSecondMessage = val
                console.log('这是来自Second组件的数据:'+ val)
            },
            //执行C子组件触发的事件
            getThirdData(val){
                this.firstToThirdMessage = val
                console.log("这是来自Third组件的数据："+val)
            }
        }
    })

   var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre> 
<p><font color="green" size="4"><strong>3.中央事件总线</strong> </font><br> 上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过<font color="red" size="3">bus.$emit</font>触发事件，<font color="red" size="3">bus.$on</font>监听触发的事件。</p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;old-brother&gt;&lt;/old-brother&gt;
    &lt;young-brother&gt;&lt;/young-brother&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('oldBrother',{
        data(){
            return {
                OldBrotherMessage:'hello youngBrother'
            }
        },
        template:`&lt;div&gt;
                &lt;p&gt;this is oldBrother compoent!&lt;/p&gt;
                &lt;input type="text" v-model="OldBrotherMessage" @input="passData(OldBrotherMessage)"&gt;
            &lt;/div&gt;`,
        methods:{
            passData(val){
                bus.$emit('globalEvent',val) //触发全局事件globalEvent

            }
        }
    })
    Vue.component('youngBrother',{
        template:`&lt;div style="border: 1px dotted red;"&gt;
                &lt;p&gt;this is youngBrother compoent!&lt;/p&gt;
                &lt;p&gt;oldBrother传递过来的数据：{<!-- -->{reciveOldBrotherMessage}}&lt;/p&gt;
            &lt;/div&gt;`,
        data(){
            return {
                reciveOldBrotherMessage:''
            }
        },
        mounted(){
            bus.$on('globalEvent',(val)=&gt;{//绑定全局事件globalEvent
                this.reciveOldBrotherMessage=val;
            })
        }
    })
    //中央事件总线
    var bus=new Vue();
    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p><font color="green" size="4"><strong>4. provide和inject</strong> </font><br> 父组件中通过<font color="red" size="3">provider</font>来提供变量，然后在子组件中通过<font color="red" size="3">inject</font>来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，<font color="red" size="3">只要在父组件的生命周期内，子组件都可以调用。</font></p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;parent&gt;&lt;/parent&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child', {
            inject:['obj'],//得到父组件传递过来的数据

        data() {
            return {
                childMessage: this.obj
            }
        },
        template: `&lt;div title="this is child compoent!"&gt;
                        &lt;input type="text" v-model="childMessage" @input="passData(childMessage)"&gt;
                    &lt;/div&gt;`,
        props: ['message'],//得到父组件传递过来的数据
        methods: {
            passData(val) {
                this.$emit('getChildData', val)//触发父组件中的事件
            }
        }
    })
    Vue.component('parent', {
        template: `&lt;div title="this is parent compoent!"&gt;
                    &lt;p&gt;this is parent compoent!{<!-- -->{reciveChildMemessage}}&lt;/p&gt;
                    &lt;child :message="message" v-on:getChildData="getChildData"&gt;&lt;/child&gt;
                   &lt;/div&gt;`,
        provide:{
            obj:'test'
        },
        data() {
            return {
                message: 'hello',
                reciveChildMemessage: ''// 定义一个字段来接收子组件里面传来的值
            }
        },
        methods: {
            getChildData(val) {//执行子组件触发的事件
                this.reciveChildMemessage = val// 定义一个字段来接收子组件里面传来的值
            }
        }
    })
    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p><font color="green" size="4"><strong>5. v-model</strong> </font><br> 父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过<font color="red" size="3">this.$emit(‘input’,val)</font>自动修改v-model绑定的值</p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;parent&gt;&lt;/parent&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child', {
        props: {
            value: String, //v-model会自动传递一个字段为value的prop属性
        },
        data() {
            return {
                childMessage: this.value
            }
        },
        methods: {
            changeValue() {
                this.$emit('input', this.childMessage);//通过如此调用可以改变父组件上v-model绑定的值
            }
        },
        template: `&lt;div title="this is child compoent!"&gt;
                        &lt;input type="text" v-model="childMessage" @input="changeValue"&gt;
                  &lt;/div&gt;`
    })
    Vue.component('parent', {
        template: `&lt;div title="this is parent compoent!"&gt;
                        &lt;p&gt;this is parent compoent!&lt;/p&gt;
                        &lt;p&gt;{<!-- -->{parentMessage}}&lt;/p&gt;
                        &lt;child v-model="parentMessage"&gt;&lt;/child&gt;
                    &lt;/div&gt;`,
        data() {
            return {
                parentMessage: 'hello'
            }
        }
    })
    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p><font color="green" size="4"><strong>6. $parent和$children</strong></font></p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;parent&gt;&lt;/parent&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child',{
        props:{
            value:String, //v-model会自动传递一个字段为value的prop属性
        },
        data(){
            return {
                childMessage:this.value
            }
        },
        methods:{
            changeValue(){
                this.$parent.parentMessage = this.childMessage;//通过如此调用可以改变父组件的值
            }
        },
        template:`&lt;div title="this is parent compoent!"&gt;
                    &lt;input type="text" v-model="childMessage" @input="changeValue"&gt;
                &lt;/div&gt;`
    })
    Vue.component('parent',{
        template:`&lt;div title="this is parent compoent!"&gt;
                    &lt;p&gt;this is parent compoent!{<!-- -->{parentMessage}}&lt;/p&gt;
                    &lt;button @click="changeChildValue"&gt;点击将值传给子组件&lt;/button &gt;
                    &lt;child&gt;&lt;/child&gt;
                 &lt;/div&gt;`,
        methods:{
            changeChildValue(){
                this.$children[0].childMessage = this.parentMessage;
            }
        },
        data(){
            return {
                parentMessage:'父组件的值'
            }
        }
    })
   var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre> 
<p><font color="green" size="4"><strong>7.boradcast和dispatch</strong> </font><br> vue1.0中提供了这种方式，但<font color="red" size="3">vue2.0</font>中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。<br> 比如如下代码，一般都作为一个mixins去使用, broadcast是向特定的父组件，触发事件，dispatch是向特定的子组件触发事件，本质上这种方式还是on和on和emit的封装，但在一些基础组件中却很实用。</p> 
<p><font color="green" size="4"><strong>8.vuex处理组件之间的数据交互</strong> </font><br> 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。<br> 详情可参考：https://vuex.vuejs.org/zh-cn/</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd05ac98af04e0cf6b65c10ab70333f5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Power Pivot 实现数据建模</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90014a1de0172da71ed30932be2b5fe7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端防抖与节流</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>