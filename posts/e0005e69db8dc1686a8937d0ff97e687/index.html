<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue知识点汇总【持更】 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue知识点汇总【持更】" />
<meta property="og:description" content="目录
1 vue的两个特性
1.1 数据驱动视图
1.2 双向数据绑定 2 MVVM工作原理
3 vue 的指令
3.1 内容渲染指令
3.2 属性绑定指令
3.3 事件绑定指令
3.4 事件修饰符 3.5 按钮修饰符
3.6 双向数据绑定指令
3.7 条件渲染指令
3.8 列表渲染指令 4 vue 的生命周期和生命周期函数 4.1 生命周期&amp;生命周期函数
4.2 组件生命周期函数的分类
4.3 生命周期函数特点
5 keep-alive
5.1 keep-alive的基本使用
5.2 keep-alive属性
6 计算属性和侦听器
6.1 侦听器
6.1.1 作用
6.1.2 侦听器的格式
6.2 计算属性
6.2.1 使用
6.2.2 注意
6.3 Computed 和 Watch 的区别
7 获取组件/元素——refs
7.1 ref的概念
7.2 使用ref引用组件实例
8 绑定Class" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e0005e69db8dc1686a8937d0ff97e687/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-14T15:41:06+08:00" />
<meta property="article:modified_time" content="2022-09-14T15:41:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue知识点汇总【持更】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%20vue%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%80%A7-toc" style="margin-left:0px;"><a href="#1%20vue%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%80%A7" rel="nofollow">1 vue的两个特性</a></p> 
<p id="1.1%20%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE-toc" style="margin-left:40px;"><a href="#1.1%20%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE" rel="nofollow">1.1 数据驱动视图</a></p> 
<p id="1.2%20%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%C2%A0-toc" style="margin-left:40px;"><a href="#1.2%20%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%C2%A0" rel="nofollow">1.2 双向数据绑定 </a></p> 
<p id="%C2%A02%C2%A0MVVM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#%C2%A02%C2%A0MVVM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">2 MVVM工作原理</a></p> 
<p id="2%C2%A0%20vue%20%E7%9A%84%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8-toc" style="margin-left:0px;"><a href="#2%C2%A0%20vue%20%E7%9A%84%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8" rel="nofollow">3 vue 的指令</a></p> 
<p id="3.1%20%E5%86%85%E5%AE%B9%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#3.1%20%E5%86%85%E5%AE%B9%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4" rel="nofollow">3.1 内容渲染指令</a></p> 
<p id="%C2%A03.2%C2%A0%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#%C2%A03.2%C2%A0%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4" rel="nofollow">3.2 属性绑定指令</a></p> 
<p id="3.3%C2%A0%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#3.3%C2%A0%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4" rel="nofollow">3.3 事件绑定指令</a></p> 
<p id="3.4%20%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%C2%A0-toc" style="margin-left:40px;"><a href="#3.4%20%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%C2%A0" rel="nofollow">3.4 事件修饰符 </a></p> 
<p id="%C2%A03.5%C2%A0%E6%8C%89%E9%92%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%C2%A03.5%C2%A0%E6%8C%89%E9%92%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" rel="nofollow">3.5 按钮修饰符</a></p> 
<p id="3.6%C2%A0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#3.6%C2%A0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4" rel="nofollow">3.6 双向数据绑定指令</a></p> 
<p id="3.7%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#3.7%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4" rel="nofollow">3.7 条件渲染指令</a></p> 
<p id="3.8%C2%A0%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4%C2%A0-toc" style="margin-left:40px;"><a href="#3.8%C2%A0%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4%C2%A0" rel="nofollow">3.8 列表渲染指令 </a></p> 
<p id="4%C2%A0vue%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:0px;"><a href="#4%C2%A0vue%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">4 vue 的生命周期和生命周期函数 </a></p> 
<p id="4.1%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%26%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.1%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%26%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0" rel="nofollow">4.1 生命周期&amp;生命周期函数</a></p> 
<p id="4.2%C2%A0%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#4.2%C2%A0%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">4.2 组件生命周期函数的分类</a></p> 
<p id="%C2%A04.3%C2%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#%C2%A04.3%C2%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9" rel="nofollow">4.3 生命周期函数特点</a></p> 
<p id="5%20keep-alive-toc" style="margin-left:0px;"><a href="#5%20keep-alive" rel="nofollow">5 keep-alive</a></p> 
<p id="5.1%20keep-alive%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#5.1%20keep-alive%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">5.1 keep-alive的基本使用</a></p> 
<p id="5.2%20keep-alive%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#5.2%20keep-alive%E5%B1%9E%E6%80%A7" rel="nofollow">5.2 keep-alive属性</a></p> 
<p id="6%C2%A0%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8-toc" style="margin-left:0px;"><a href="#6%C2%A0%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8" rel="nofollow">6 计算属性和侦听器</a></p> 
<p id="6.1%20%E4%BE%A6%E5%90%AC%E5%99%A8-toc" style="margin-left:40px;"><a href="#6.1%20%E4%BE%A6%E5%90%AC%E5%99%A8" rel="nofollow">6.1 侦听器</a></p> 
<p id="6.1.1%20%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#6.1.1%20%E4%BD%9C%E7%94%A8" rel="nofollow">6.1.1 作用</a></p> 
<p id="6.1.2%C2%A0%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9A%84%E6%A0%BC%E5%BC%8F-toc" style="margin-left:80px;"><a href="#6.1.2%C2%A0%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9A%84%E6%A0%BC%E5%BC%8F" rel="nofollow">6.1.2 侦听器的格式</a></p> 
<p id="6.2%C2%A0%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#6.2%C2%A0%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7" rel="nofollow">6.2 计算属性</a></p> 
<p id="6.2.1%20%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#6.2.1%20%E4%BD%BF%E7%94%A8" rel="nofollow">6.2.1 使用</a></p> 
<p id="6.2.2%20%E6%B3%A8%E6%84%8F-toc" style="margin-left:80px;"><a href="#6.2.2%20%E6%B3%A8%E6%84%8F" rel="nofollow">6.2.2 注意</a></p> 
<p id="6.2.3%C2%A0Computed%20%E5%92%8C%20Watch%20%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#6.2.3%C2%A0Computed%20%E5%92%8C%20Watch%20%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">6.3 Computed 和 Watch 的区别</a></p> 
<p id="%C2%A07%C2%A0%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%2F%E5%85%83%E7%B4%A0%E2%80%94%E2%80%94refs-toc" style="margin-left:0px;"><a href="#%C2%A07%C2%A0%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%2F%E5%85%83%E7%B4%A0%E2%80%94%E2%80%94refs" rel="nofollow">7 获取组件/元素——refs</a></p> 
<p id="%C2%A07.1%20ref%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%C2%A07.1%20ref%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow"> 7.1 ref的概念</a></p> 
<p id="%C2%A07.2%C2%A0%E4%BD%BF%E7%94%A8ref%E5%BC%95%E7%94%A8%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%C2%A07.2%C2%A0%E4%BD%BF%E7%94%A8ref%E5%BC%95%E7%94%A8%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B" rel="nofollow"> 7.2 使用ref引用组件实例</a></p> 
<p id="8%20%E7%BB%91%E5%AE%9AClass-toc" style="margin-left:0px;"><a href="#8%20%E7%BB%91%E5%AE%9AClass" rel="nofollow">8 绑定Class</a></p> 
<p id="8.1%C2%A0%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#8.1%C2%A0%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95%EF%BC%9A" rel="nofollow">8.1 对象语法：</a></p> 
<p id="8.1.1%20%E4%BC%A0%E7%BB%99v-bind%3Aclass%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BB%A5%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2class-toc" style="margin-left:80px;"><a href="#8.1.1%20%E4%BC%A0%E7%BB%99v-bind%3Aclass%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BB%A5%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2class" rel="nofollow">8.1.1 传给v-bind:class一个对象，以动态切换class</a></p> 
<p id="8.1.2%C2%A0%20%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B8%AD%E4%BC%A0%E5%85%A5%E6%9B%B4%E5%A4%9A%E5%AD%97%E6%AE%B5%E6%9D%A5%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E5%A4%9A%E4%B8%AA%20class-toc" style="margin-left:80px;"><a href="#8.1.2%C2%A0%20%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B8%AD%E4%BC%A0%E5%85%A5%E6%9B%B4%E5%A4%9A%E5%AD%97%E6%AE%B5%E6%9D%A5%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E5%A4%9A%E4%B8%AA%20class" rel="nofollow">8.1.2  在对象中传入更多字段来动态切换多个 class</a></p> 
<p id="8.1.3%20%E7%BB%91%E5%AE%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%BF%85%E5%86%85%E8%81%94%E5%AE%9A%E4%B9%89%E5%9C%A8%E6%A8%A1%E6%9D%BF%E9%87%8C-toc" style="margin-left:80px;"><a href="#8.1.3%20%E7%BB%91%E5%AE%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%BF%85%E5%86%85%E8%81%94%E5%AE%9A%E4%B9%89%E5%9C%A8%E6%A8%A1%E6%9D%BF%E9%87%8C" rel="nofollow">8.1.3 绑定的数据对象不必内联定义在模板里</a></p> 
<p id="8.2%20%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#8.2%20%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95" rel="nofollow">8.2 数组语法</a></p> 
<p id="8.2.1%20%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%BC%A0%E7%BB%99%C2%A0v-bind%3Aclass%EF%BC%8C%E4%BB%A5%E5%BA%94%E7%94%A8%E4%B8%80%E4%B8%AA%20class%20%E5%88%97%E8%A1%A8-toc" style="margin-left:80px;"><a href="#8.2.1%20%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%BC%A0%E7%BB%99%C2%A0v-bind%3Aclass%EF%BC%8C%E4%BB%A5%E5%BA%94%E7%94%A8%E4%B8%80%E4%B8%AA%20class%20%E5%88%97%E8%A1%A8" rel="nofollow">8.2.1 把一个数组传给 v-bind:class，以应用一个 class 列表</a></p> 
<p id="8.2.2%20%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E5%88%87%E6%8D%A2%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%20class-toc" style="margin-left:80px;"><a href="#8.2.2%20%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E5%88%87%E6%8D%A2%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%20class" rel="nofollow">8.2.2 根据条件切换列表中的 class</a></p> 
<p id="8.3%20%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A-toc" style="margin-left:40px;"><a href="#8.3%20%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A" rel="nofollow">8.3 用在组件上</a></p> 
<p id="8.4%20%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#8.4%20%E6%80%BB%E7%BB%93" rel="nofollow">8.4 总结</a></p> 
<p id="9%C2%A0%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F-toc" style="margin-left:0px;"><a href="#9%C2%A0%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F" rel="nofollow">9 绑定内联样式</a></p> 
<p id="9.1%20%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#9.1%20%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95" rel="nofollow">9.1 对象语法</a></p> 
<p id="%C2%A09.2%C2%A0%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A09.2%C2%A0%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95" rel="nofollow">9.2 数组语法</a></p> 
<p id="10%20%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF-toc" style="margin-left:0px;"><a href="#10%20%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF" rel="nofollow">10 组件通讯</a></p> 
<p id="10.1%20%E7%88%B6%E4%BC%A0%E5%AD%90%E7%94%A8props-toc" style="margin-left:40px;"><a href="#10.1%20%E7%88%B6%E4%BC%A0%E5%AD%90%E7%94%A8props" rel="nofollow">10.1 父传子用props</a></p> 
<p id="10.2%C2%A0%E5%AD%90%E4%BC%A0%E7%88%B6%E7%94%A8%24emit-toc" style="margin-left:40px;"><a href="#10.2%C2%A0%E5%AD%90%E4%BC%A0%E7%88%B6%E7%94%A8%24emit" rel="nofollow">10.2 子传父用$emit</a></p> 
<p id="%C2%A010.3%C2%A0%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB-toc" style="margin-left:40px;"><a href="#%C2%A010.3%C2%A0%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB" rel="nofollow">10.3 兄弟组件之间的数据共享</a></p> 
<p id="11%20%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#11%20%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">11 插槽的使用</a></p> 
<p id="11.1%C2%A0%E6%8F%92%E6%A7%BD%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#11.1%C2%A0%E6%8F%92%E6%A7%BD%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" rel="nofollow">11.1 插槽基本用法</a></p> 
<p id="%C2%A011.2%C2%A0%20v-slot%3A%20%E5%B0%86%E5%86%85%E5%AE%B9%E6%94%BE%E5%9C%A8%E6%8C%87%E5%AE%9A%E6%8F%92%E6%A7%BD-toc" style="margin-left:40px;"><a href="#%C2%A011.2%C2%A0%20v-slot%3A%20%E5%B0%86%E5%86%85%E5%AE%B9%E6%94%BE%E5%9C%A8%E6%8C%87%E5%AE%9A%E6%8F%92%E6%A7%BD" rel="nofollow">11.2  v-slot: 将内容放在指定插槽</a></p> 
<p id="11.3%C2%A0%E6%8F%92%E6%A7%BD%E5%90%8E%E8%83%8C%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89%E5%86%85%E5%AE%B9-toc" style="margin-left:40px;"><a href="#11.3%C2%A0%E6%8F%92%E6%A7%BD%E5%90%8E%E8%83%8C%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89%E5%86%85%E5%AE%B9" rel="nofollow">11.3 插槽后背（默认）内容</a></p> 
<p id="11.4%20%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%C2%A0-toc" style="margin-left:40px;"><a href="#11.4%20%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%C2%A0" rel="nofollow">11.4 具名插槽 </a></p> 
<p id="11.5%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%C2%A0-toc" style="margin-left:40px;"><a href="#11.5%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%C2%A0" rel="nofollow">11.5 作用域插槽 </a></p> 
<p id="11.6%C2%A0%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#11.6%C2%A0%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95" rel="nofollow">11.6 独占默认插槽的缩写语法</a></p> 
<p id="11.7%20%E5%8A%A8%E6%80%81%E6%8F%92%E6%A7%BD%E5%90%8D-toc" style="margin-left:40px;"><a href="#11.7%20%E5%8A%A8%E6%80%81%E6%8F%92%E6%A7%BD%E5%90%8D" rel="nofollow">11.7 动态插槽名</a></p> 
<p id="11.8%C2%A0%E5%B8%A6%E6%9C%89%20slot%20attribute%20%E7%9A%84%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD-toc" style="margin-left:40px;"><a href="#11.8%C2%A0%E5%B8%A6%E6%9C%89%20slot%20attribute%20%E7%9A%84%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD" rel="nofollow">11.8 带有 slot attribute 的具名插槽</a></p> 
<p id="12%C2%A0%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#12%C2%A0%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">12 路由的使用</a></p> 
<p id="%C2%A012.1%20%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%C2%A012.1%20%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86" rel="nofollow">12.1 前端路由的概念和原理</a></p> 
<p id="12.2%20%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#12.2%20%E9%85%8D%E7%BD%AE" rel="nofollow">12.2 配置</a></p> 
<p id="%C2%A012.3%C2%A0%E6%8A%8Arouter%E5%AF%B9%E8%B1%A1%E6%8C%82%E8%BD%BD%E5%88%B0main.js%E4%B8%8A-toc" style="margin-left:40px;"><a href="#%C2%A012.3%C2%A0%E6%8A%8Arouter%E5%AF%B9%E8%B1%A1%E6%8C%82%E8%BD%BD%E5%88%B0main.js%E4%B8%8A" rel="nofollow">12.3 把router对象挂载到main.js上</a></p> 
<p id="12.4%20%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#12.4%20%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">12.4 路由的基本使用</a></p> 
<p id="12.5%C2%A0%C2%A0%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91-toc" style="margin-left:40px;"><a href="#12.5%C2%A0%C2%A0%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91" rel="nofollow">12.5  路由重定向</a></p> 
<p id="%C2%A012.6%C2%A0%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1-toc" style="margin-left:40px;"><a href="#%C2%A012.6%C2%A0%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1" rel="nofollow">12.6 嵌套路由</a></p> 
<p id="12.7%C2%A0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D-toc" style="margin-left:40px;"><a href="#12.7%C2%A0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D" rel="nofollow">12.7 动态路由匹配</a></p> 
<p id="%C2%A012.8%C2%A0%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E6%88%96%20404%20Not%20found%20%E8%B7%AF%E7%94%B1-toc" style="margin-left:40px;"><a href="#%C2%A012.8%C2%A0%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E6%88%96%20404%20Not%20found%20%E8%B7%AF%E7%94%B1" rel="nofollow">12.8 捕获所有路由或 404 Not found 路由</a></p> 
<p id="12.9%C2%A0%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC-toc" style="margin-left:40px;"><a href="#12.9%C2%A0%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC" rel="nofollow">12.9 编程式导航跳转</a></p> 
<p id="12.10%C2%A0%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB-toc" style="margin-left:40px;"><a href="#12.10%C2%A0%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB" rel="nofollow">12.10 路由守卫</a></p> 
<p id="12.10.1%20%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB-toc" style="margin-left:80px;"><a href="#12.10.1%20%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB" rel="nofollow">12.10.1 全局前置守卫</a></p> 
<p id="12.10.2%20next%20%E5%87%BD%E6%95%B0%E7%9A%84%203%20%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#12.10.2%20next%20%E5%87%BD%E6%95%B0%E7%9A%84%203%20%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F" rel="nofollow">12.10.2 next 函数的 3 种调用方式</a></p> 
<p id="%C2%A012.10.3%C2%A0%E5%85%B3%E4%BA%8Epath%E5%92%8Cfullpath-toc" style="margin-left:80px;"><a href="#%C2%A012.10.3%C2%A0%E5%85%B3%E4%BA%8Epath%E5%92%8Cfullpath" rel="nofollow">12.10.3 关于path和fullpath</a></p> 
<p id="12.11%20%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82-toc" style="margin-left:40px;"><a href="#12.11%20%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82" rel="nofollow">12.11 路由传参</a></p> 
<p id="%C2%A012.11.1%C2%A0query%E4%BC%A0%E5%8F%82-toc" style="margin-left:80px;"><a href="#%C2%A012.11.1%C2%A0query%E4%BC%A0%E5%8F%82" rel="nofollow">12.11.1 query传参</a></p> 
<p id="12.11.2%20params%E4%BC%A0%E5%8F%82-toc" style="margin-left:80px;"><a href="#12.11.2%20params%E4%BC%A0%E5%8F%82" rel="nofollow">12.11.2 params传参</a></p> 
<p id="12.11.3%C2%A0%E8%B7%AF%E7%94%B1props%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#12.11.3%C2%A0%E8%B7%AF%E7%94%B1props%E9%85%8D%E7%BD%AE" rel="nofollow">12.11.3 路由props配置</a></p> 
<p id="13%C2%A0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#13%C2%A0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86" rel="nofollow">13 状态管理</a></p> 
<p id="13.1%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#13.1%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B" rel="nofollow">13.1 状态管理简介</a></p> 
<p id="13.2%20Vuex%20%E7%9A%84%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#13.2%20Vuex%20%E7%9A%84%E6%80%9D%E6%83%B3" rel="nofollow">13.2 Vuex 的思想</a></p> 
<p id="13.3%20%E6%A0%B8%E5%BF%83%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-toc" style="margin-left:40px;"><a href="#13.3%20%E6%A0%B8%E5%BF%83%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86" rel="nofollow">13.3 核心状态管理</a></p> 
<p id="13.4%20%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#13.4%20%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8" rel="nofollow">13.4 在项目中使用</a></p> 
<p id="%C2%A013.4.1%20store%E4%B8%80%E8%88%AC%E6%9C%89%E4%BB%A5%E4%B8%8B6%E4%B8%AA%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%C2%A013.4.1%20store%E4%B8%80%E8%88%AC%E6%9C%89%E4%BB%A5%E4%B8%8B6%E4%B8%AA%E6%96%87%E4%BB%B6" rel="nofollow">13.4.1 store一般有以下6个文件</a></p> 
<p id="%C2%A013.4.2%C2%A0vuex%E4%B8%AD%20this.%24store.dispatch()%20%E4%B8%8E%20this.%24store.commit()%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%C2%A013.4.2%C2%A0vuex%E4%B8%AD%20this.%24store.dispatch%28%29%20%E4%B8%8E%20this.%24store.commit%28%29%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">13.4.2 vuex中 this.$store.dispatch() 与 this.$store.commit()方法的区别</a></p> 
<p id="14.4.3%20%E5%AE%9E%E4%BE%8B1-toc" style="margin-left:80px;"><a href="#14.4.3%20%E5%AE%9E%E4%BE%8B1" rel="nofollow">13.4.3 实例1</a></p> 
<p id="13.4.4%20%E5%AE%9E%E4%BE%8B2-toc" style="margin-left:80px;"><a href="#13.4.4%20%E5%AE%9E%E4%BE%8B2" rel="nofollow">13.4.4 实例2</a></p> 
<hr id="hr-toc"> 
<p><span style="color:#a5a5a5;">（部分图例引用黑马教程及其他文章来源）</span></p> 
<h2 id="1%20vue%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%80%A7">1 vue的两个特性</h2> 
<h3 id="1.1%20%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE">1.1 数据驱动视图</h3> 
<p>数据的变化会<strong>驱动视图</strong>自动更新。</p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/38/5d/ukpfXARV_o.png" width="597"></p> 
<h3 id="1.2%20%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%C2%A0"><strong>1.2 双向数据绑定</strong> </h3> 
<p>在网页中，form负责<strong>采集数据</strong>，Ajax负责<strong>提交数据</strong>。数据源的变化，会被自动渲染到页面上；页面上表单采集的数据发生变化的时候，会被 vue 自动获取到，并更新到数据源中。</p> 
<p> <img alt="" height="188" src="https://images2.imgbox.com/8a/c7/CVh8qGIJ_o.png" width="552"></p> 
<p> </p> 
<h2 id="%C2%A02%C2%A0MVVM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">2 MVVM工作原理</h2> 
<p> MVVM 是 vue 实现数据驱动视图和双向数据绑定的核心原理。<span style="color:#fe2c24;"><strong>MVVM 指的是 Model、View 和 ViewModel</strong></span>，它把每个 HTML 页面都拆分成了这三个部分，如图所示：</p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/35/7a/x1Gvs4mg_o.png" width="851"></p> 
<p> <img alt="" height="433" src="https://images2.imgbox.com/3e/14/soaGmkrU_o.png" width="550"></p> 
<blockquote> 
 <p>注：</p> 
 <p>1、当数据源发生变化时，会被 ViewModel 监听到，VM会根据最新的数据源自动更新页面的结构。</p> 
 <p>2、当表单元素的值发生变化时，也会被VM监听到，VM会把变化过后最新的数据自动同步到Model数据源中。</p> 
</blockquote> 
<h2 id="2%C2%A0%20vue%20%E7%9A%84%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8">3 vue 的指令</h2> 
<h3 id="3.1%20%E5%86%85%E5%AE%B9%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4">3.1 内容渲染指令</h3> 
<p>内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下 3 个：</p> 
<ul><li><strong>{<!-- -->{}}插值表达式</strong>：在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容！</li></ul> 
<p> （注意：插值表达式只能用在元素的<span style="color:#fe2c24;">内容节点</span>中，不能用在元素的<span style="color:#fe2c24;">属性节点</span>中！）</p> 
<ul><li><strong>v-text</strong>：会覆盖元素内部原有的内容！</li><li><strong>v-html</strong>：不仅会覆盖原来的内容，而且可以把带有标签的字符串，渲染成真正的HTML内容！</li></ul> 
<p><img alt="" height="438" src="https://images2.imgbox.com/13/4d/xEPytUkN_o.png" width="1189"></p> 
<h3 id="%C2%A03.2%C2%A0%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4">3.2 属性绑定指令</h3> 
<p><strong> v-bind</strong>：为元素的属性动态绑定属性值，则需要用到 v-bind 属性绑定指令。</p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/f1/aa/y61fX3Sk_o.png" width="1156"></p> 
<ul><li>在 vue 中，可以使用<strong>v-bind:属性</strong>为元素的属性动态绑定值。</li><li>简写是英文的 " <strong>: </strong>"。</li><li>在使用 v-bind 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如：</li></ul> 
<pre><code class="language-javascript">&lt;!--html--&gt;
&lt;a :href="'https://www.runoob.com/vue2/'+url"&gt;点击跳转vue菜鸟教程&lt;/a&gt;

&lt;!--script--&gt;
const vm2=new Vue({
     el:'#box2',
     data:{
         url:'vue-tutorial.html'
     }
})</code></pre> 
<h3 id="3.3%C2%A0%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4">3.3 事件绑定指令</h3> 
<p><span style="color:#0d0016;">vue提供了<strong>v-on</strong>事件绑定指令，用于为DOM元素绑定事件监听。</span></p> 
<ul><li>注意：原生DOM对象有onclick、oninput、onkeyup等原生事件，替换为vue的事件绑定形式后，分别为v-on:click、v-on:input、v-on:keyup。</li><li>在v-on指令所绑定的事件处理函数，可以接收事件参数对象event。</li><li>$event是vue提供的特殊变量，用来表示原生的事件参数对象event。</li></ul> 
<pre><code class="language-javascript">&lt;button @click="add"&gt;自增&lt;/botton&gt;
&lt;button @click="changeColor"&gt;变色&lt;/botton&gt;
data(){
    return{
        count:'',
    }
}
methods:{
    add(){
        this.count++;    
    },
    changeColor(e){
            e.target.style.backgroundColor='red';
    }
}</code></pre> 
<h3 id="3.4%20%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%C2%A0">3.4 事件修饰符 </h3> 
<p><img alt="" height="408" src="https://images2.imgbox.com/05/21/6Tfbx7Xs_o.png" width="727"></p> 
<h3 id="%C2%A03.5%C2%A0%E6%8C%89%E9%92%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">3.5 按钮修饰符</h3> 
<p><img alt="" height="255" src="https://images2.imgbox.com/3a/e2/0yXMzIt2_o.png" width="779"></p> 
<h3 id="3.6%C2%A0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4">3.6 双向数据绑定指令</h3> 
<p><img alt="" height="362" src="https://images2.imgbox.com/af/4a/Uvga84fI_o.png" width="872"></p> 
<p><img alt="" height="485" src="https://images2.imgbox.com/96/62/tP169S5W_o.png" width="891"></p> 
<h3 id="3.7%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4">3.7 条件渲染指令</h3> 
<p><img alt="" height="301" src="https://images2.imgbox.com/79/ac/fZM1pysP_o.png" width="669"></p> 
<blockquote> 
 <ul><li>v-if、v-else、v-else-if条件性的渲染某元素，判定为true时渲染，否则不渲染</li><li>两者区别：v-if条件不满足不渲染，v-show条件不满足令其display为none</li></ul> 
</blockquote> 
<pre><code class="language-javascript">&lt;div v-if="score&lt;60"&gt;不及格&lt;/div&gt;
&lt;div v-else-if="60&lt;=score&amp;&amp;score&lt;90"&gt;中等&lt;/div&gt;
&lt;div v-else="score&gt;=90"&gt;优秀&lt;/div&gt;

&lt;div v-show="true"&gt;display:block显示&lt;/div&gt;
&lt;div v-show="false"&gt;display:none隐藏&lt;/div&gt;</code></pre> 
<h3 id="3.8%C2%A0%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4%C2%A0">3.8 列表渲染指令 </h3> 
<p><img alt="" height="325" src="https://images2.imgbox.com/64/b3/JzkJ1zy0_o.png" width="693"></p> 
<p> <img alt="" height="285" src="https://images2.imgbox.com/09/bd/Vw3ESPTD_o.png" width="626"></p> 
<p><img alt="" height="506" src="https://images2.imgbox.com/44/6f/EVV6Wq9i_o.png" width="991"></p> 
<p><span style="color:#0d0016;"><span style="background-color:#f9eda6;"> 注意：不推荐在同一元素上使用 v-if 和 v-for</span></span><span style="color:#fe2c24;"><span style="background-color:#f9eda6;"> </span></span><a class="link-info" href="https://v2.cn.vuejs.org/v2/guide/list.html#v-for-%E4%B8%8E-v-if-%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8" rel="nofollow" title="（详情请查看官网）">（详情请查看官网）</a></p> 
<h2 id="4%C2%A0vue%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%C2%A0">4 vue 的生命周期和生命周期函数 </h2> 
<h3 id="4.1%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%26%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0">4.1 生命周期&amp;生命周期函数</h3> 
<p><strong>生命周期概念</strong>：生命周期是指一个组件从创建 &gt; 运行 &gt; 销毁的整个过程，强调的是一个时间段。</p> 
<p><strong>生命周期函数概念</strong>：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。</p> 
<p>（注意：生命周期强调的是时间段，生命周期函数强调的是时间点 。）</p> 
<h3 id="4.2%C2%A0%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB">4.2 组件生命周期函数的分类</h3> 
<p><img alt="" height="747" src="https://images2.imgbox.com/ef/63/Du8xkkds_o.png" width="1200"></p> 
<h3 id="%C2%A04.3%C2%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9"><strong>4.3 生命周期函数特点</strong></h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/90/c8/ZtPnTETr_o.png" width="1200"></p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="test-container"&gt;
    &lt;h3 id="myh3"&gt;Test.vue 组件 --- {<!-- -->{ books.length }} 本图书&lt;/h3&gt;
    &lt;p id="pppp"&gt;message 的值是：{<!-- -->{ message }}&lt;/p&gt;
    &lt;button @click="message += '~'"&gt;修改 message 的值&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 
&lt;script&gt;
export default {
  props: ['info'],
  data() {
    return {
      message: 'hello vue.js',
      books: []
    }
  },
  watch: {
    message(newVal) {
      console.log('监视到了 message 的变化：' + newVal)
    }
  },
  methods: {
  },
  
  beforeCreate() {
  // 创建阶段的第1个生命周期函数。在这个函数无法访问data、prors、methods
  //很少有
  },
  created() {
    // 组件只是在内存中被创建好，但还未被渲染到页面
    // 经常在它里面，调用 methods 中的方法，利用Ajax请求服务器的数据。并且，把请求到的数据，转存到 data 中，供 template 模板渲染的时候使用！
    //可以访问data、prors、methods
    this.initBookList()
  },
  beforeMount() {
      //只是在内存上编译好HTML
      //将在渲染组件时执行的操作
      //很少用
  },
  
  mounted() {
      //在此之前DOM还没被渲染，但此时在mounted()时DOM已经被渲染
      // 如果要操作当前组件的 DOM，最早只能在 mounted 阶段执行
      //组件创建阶段到此结束
  },
  beforeUpdate() {
   //已经根据拿到最新数据，还没完成组件DOM结构的渲染
  },
  // 当数据变化之后，为了能够操作到最新的 DOM 结构，必须把代码写到 updated 生命周期函数中
  updated() {
  //已经根据最新数据，完成组件DOM结构的渲染。可以被执行多次（因为数据会变化多次）
  //组件运行阶段到此结束
  },
  beforeDestroy() {
    this.message = 'aaa'
  },
  destroyed() {
  //组件销毁阶段到此结束
  }
}
&lt;/script&gt;</code></pre> 
<h2 id="5%20keep-alive">5 keep-alive</h2> 
<h3 id="5.1%20keep-alive%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">5.1 keep-alive的基本使用</h3> 
<p><img alt="" height="64" src="https://images2.imgbox.com/a0/4b/LAq2BKps_o.png" width="448"></p> 
<blockquote> 
 <p> 当组件第一次被创建，会执行created生命周期函数，也会执行activated生命周期函数。之后组件再被激活，只会触发activated而不会触发created。</p> 
</blockquote> 
<p>使用： </p> 
<pre><code class="language-javascript">&lt;keep-alive&gt;
    &lt;组件名&gt;&lt;/组件名&gt;
&lt;keep-alive&gt;</code></pre> 
<h3 id="5.2%20keep-alive%E5%B1%9E%E6%80%A7">5.2 keep-alive属性</h3> 
<ul><li><strong>include</strong>包含的组件(可以为字符串，数组，以及正则表达式，只有名称匹配的组件会被缓存)。</li><li><strong>exclude</strong>排除的组件(可以为字符串，数组，以及正则表达式，任何匹配的组件都不会被缓存)。</li><li><strong>max</strong>缓存组件的最大值(类型为字符或者数字,可以控制缓存组件的个数)。</li></ul> 
<pre><code class="language-javascript">// 只缓存组件name为a和b的组件
&lt;keep-alive include="a,b"&gt; 
  &lt;component /&gt;
&lt;/keep-alive&gt;

// 组件name为c的组件不缓存(可以保留它的状态或避免重新渲染)
&lt;keep-alive exclude="c"&gt; 
  &lt;component /&gt;
&lt;/keep-alive&gt;

// 如果同时使用include,exclude,那么exclude优先于include， 下面的例子只缓存a组件
&lt;keep-alive include="a,b" exclude="b"&gt; 
  &lt;component /&gt;
&lt;/keep-alive&gt;

// 如果缓存的组件超过了max设定的值5，那么将删除第一个缓存的组件
&lt;keep-alive exclude="c" max="5"&gt; 
  &lt;component /&gt;
&lt;/keep-alive&gt;</code></pre> 
<p><span style="background-color:#f9eda6;"> 注意：若组件没有定义自己的name，则默认以注册组件时的名称作为匹配条件。如果定义了name，会以name作为匹配条件。</span></p> 
<h2 id="6%C2%A0%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8">6 计算属性和侦听器</h2> 
<h3 id="6.1%20%E4%BE%A6%E5%90%AC%E5%99%A8">6.1 侦听器</h3> 
<h4 id="6.1.1%20%E4%BD%9C%E7%94%A8">6.1.1 作用</h4> 
<p>watch侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。</p> 
<h4 id="6.1.2%C2%A0%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9A%84%E6%A0%BC%E5%BC%8F">6.1.2 侦听器的格式</h4> 
<p>1、方法格式的侦听器（watch:{……}）：</p> 
<ul><li>缺点1：无法在刚进入页面的时候自动触发。</li><li>缺点2：如果侦听的是一个对象，当对象里的属性值发生变化时，不会触发侦听器。</li></ul> 
<p id="6.1.3%C2%A0%E5%AF%B9%E8%B1%A1%E6%A0%BC%E5%BC%8F%E7%9A%84%E4%BE%A6%E5%90%AC%E5%99%A8%20%EF%BC%88watch%EF%BC%88%EF%BC%89%7B%E2%80%A6%E2%80%A6%7D%EF%BC%89">2、对象格式的侦听器 （watch（）{……}）：</p> 
<ul><li> 好处1：可以通过immediate选项让侦听器自动触发。</li></ul> 
<p><img alt="" height="122" src="https://images2.imgbox.com/24/75/Vjwv5wQZ_o.png" width="479"> </p> 
<ul><li> 好处2：可以通过deep选项，让侦听器深度监听对象中每个属性的变化。</li></ul> 
<p><img alt="" height="88" src="https://images2.imgbox.com/86/53/BRwaR7dE_o.png" width="182"> </p> 
<p> <img alt="" height="119" src="https://images2.imgbox.com/4e/68/B9GUmMi6_o.png" width="269"></p> 
<p>如果要侦听对象里属性的变化，可以如以下操作：</p> 
<p><img alt="" height="135" src="https://images2.imgbox.com/28/83/t96Q61fR_o.png" width="398"></p> 
<h3 id="6.2%C2%A0%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7">6.2 计算属性</h3> 
<h4 id="6.2.1%20%E4%BD%BF%E7%94%A8">6.2.1 使用</h4> 
<p>1、定义计算属性：</p> 
<pre><code class="language-javascript">new Vue({
    el:"#app",
    data:{ ... },
    methods:{ ... },
    watch:{ ... },
    computed:{
      计算属性名(){
        计算过程
        return 属性值
      }
    }
})</code></pre> 
<p>2、在页面上使用计算属性：</p> 
<pre><code class="language-html">&lt;p&gt;{<!-- -->{计算属性名}}&lt;/p&gt;</code></pre> 
<h4 id="6.2.2%20%E6%B3%A8%E6%84%8F">6.2.2 注意</h4> 
<p>1、computed 和 data同级，计算属性写在computed中；</p> 
<p>2、写起来像方法，用起来像属性；</p> 
<p>3、计算属性虽然称为属性，但其本质是一个函数；</p> 
<p>4、虽然计算属性本质是一个函数，但是在页面中使用计算属性时，不要加()；</p> 
<p>5、一定要有返回值；</p> 
<p>6、可以使用data中的已知值；</p> 
<p>7、只要跟计算属性相关的数据发生了变化，计算属性就会重新计算，不相关的属性无论如何变化，都不会导致计算属性变化；</p> 
<p>8、计算属性名不能和data中的数据重名（因为要使用data中的数据）。</p> 
<pre><code class="language-javascript">【页面上使用】{<!-- -->{reversedMessage}}

【data中定义】msg:'New York'

【计算属性】computed:{
    reversedMsg (){
      return this.msg.split('').reverse().join('')
    }
}</code></pre> 
<h3 id="6.2.3%C2%A0Computed%20%E5%92%8C%20Watch%20%E7%9A%84%E5%8C%BA%E5%88%AB">6.3 Computed 和 Watch 的区别</h3> 
<p><strong>1、computed计算属性：</strong><br><strong>作用：</strong><br> （1）解决模板中放入过多的逻辑会让模板过重且难以维护的问题。例如两个数据的拼接或字体颜色的判断。</p> 
<p>（2）它支持缓存，只有依赖的数据发生了变化，才会重新计算。例如模板中多次用到数据拼接可以用计算属性，只执行一次计算，除非数据发生变化。</p> 
<p>（3）<span style="color:#fe2c24;">不支持异步</span>，如果有异步操作，无法监听数据的变化。</p> 
<p>（4）如果属性值是函数，默认使用get方法，函数的返回值就是属性的属性值。还有一个set方法，当数据变化时就会调用set方法。</p> 
<p>（5）computed的值会<span style="color:#fe2c24;">默认走缓存</span>，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</p> 
<p><strong>2、watch侦听器：</strong><br><strong>作用：</strong><br> （1）它<span style="color:#fe2c24;">不支持缓存</span>，数据变化时，它就会触发相应的操作。</p> 
<p>（2）支持<span style="color:#fe2c24;">异步监听</span>。</p> 
<p>（3）接受两个参数，第一个是最新的值，第二个是变化之前的值。</p> 
<p>（4）监听data或者props传来的数据，发生变化时会触发相应操作。有两个参数：</p> 
<p>        <span style="color:#fe2c24;">immediate</span>：立即触发回调函数。</p> 
<p>        <span style="color:#fe2c24;">deep</span>：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</p> 
<p><strong>3、总结：</strong><br> （1）<strong>computed 计算属性</strong> : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</p> 
<p>（2）<strong>watch 侦听器 </strong>: 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</p> 
<p><strong>4、computed与watch的使用场景：</strong><br><strong>computed</strong>：是多对一，多个数据影响一个。当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</p> 
<p><strong>watch</strong>：是一对多，一个数据发生变化，执行相应操作会影响多个数据。当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。<br><span style="color:#d7d8d9;">————————————————<br> 版权声明：本板块为CSDN博主「前端路啊」的原创文章，原文链接：<a class="link-info" href="https://blog.csdn.net/m0_62118859/article/details/124455926" title="原文网址">原文网址</a></span></p> 
<h2 id="%C2%A07%C2%A0%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%2F%E5%85%83%E7%B4%A0%E2%80%94%E2%80%94refs">7 获取组件/元素——refs</h2> 
<h3 id="%C2%A07.1%20ref%E7%9A%84%E6%A6%82%E5%BF%B5"> 7.1 ref的概念</h3> 
<p>ref用来辅助开发者在不依赖于jQuery的情况下，获取DOM元素或组件的引用。</p> 
<pre><code class="language-html">&lt;p ref="mytext"&gt;我会被refs获取到&lt;/p&gt;
&lt;button @click="refTest"&gt;获取mytext，改变其文本&lt;/button&gt;</code></pre> 
<pre><code class="language-javascript">refTest(){
    console.log(this.$refs.mytext);
    this.$refs.mytext.innerHTML='我被获取到啦'
},</code></pre> 
<h3 id="%C2%A07.2%C2%A0%E4%BD%BF%E7%94%A8ref%E5%BC%95%E7%94%A8%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B"> 7.2 使用ref引用组件实例</h3> 
<p>【子组件 child.vue】</p> 
<pre><code class="language-javascript">showTitle(){
  alert('aaa');
}</code></pre> 
<p>【父组件 parent.vue】</p> 
<pre><code class="language-html">&lt;child ref="A"&gt;流程环节配置&lt;/child&gt;
&lt;button @click="B"&gt;点我弹出&lt;/button&gt;</code></pre> 
<pre><code class="language-javascript">B(){
    this.$refs.A.showTitle();
},</code></pre> 
<h2 id="8%20%E7%BB%91%E5%AE%9AClass">8 绑定Class</h2> 
<h3 id="8.1%C2%A0%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95%EF%BC%9A">8.1 对象语法：</h3> 
<h4 id="8.1.1%20%E4%BC%A0%E7%BB%99v-bind%3Aclass%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BB%A5%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2class">8.1.1 传给v-bind:class一个对象，以动态切换class</h4> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- class和style --&gt;
    &lt;div v-bind:class="{ 'active': isActive, 'text-danger': hasError }"&gt;aa&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    data() {
        return {
            isActive:true,
            hasError:false 
        }
    },  
}
&lt;/script&gt;
&lt;style&gt;
.active{
    color:#e5c
}
.text-danger{
    color: rgb(16, 212, 65);
}
&lt;/style&gt;</code></pre> 
<p>上面的语法表示 active 这个 class 存在与否将取决于数据isActive为true还是false。</p> 
<h4 id="8.1.2%C2%A0%20%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B8%AD%E4%BC%A0%E5%85%A5%E6%9B%B4%E5%A4%9A%E5%AD%97%E6%AE%B5%E6%9D%A5%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E5%A4%9A%E4%B8%AA%20class">8.1.2  在对象中传入更多字段来动态切换多个 class</h4> 
<p>此外，v-bind:class 指令也可以与普通的 class attribute 共存。当有如下模板：</p> 
<pre><code class="language-javascript">&lt;div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
&gt;&lt;/div&gt;

data: {
  isActive: true,
  hasError: false
}</code></pre> 
<p>以上渲染的结果是：<span style="color:#0d0016;"><span style="background-color:#d7d8d9;">&lt;div class="static active"&gt;&lt;/div&gt;</span></span></p> 
<p>当 isActive 或者 hasError 变化时，class 列表将相应地更新。例如，如果hasError=true，则渲染结果为：<span style="background-color:#d7d8d9;">&lt;div class="static active hasError"&gt;&lt;/div&gt;</span></p> 
<h4 id="8.1.3%20%E7%BB%91%E5%AE%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%BF%85%E5%86%85%E8%81%94%E5%AE%9A%E4%B9%89%E5%9C%A8%E6%A8%A1%E6%9D%BF%E9%87%8C">8.1.3 绑定的数据对象不必内联定义在模板里</h4> 
<pre><code class="language-javascript">&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;

data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}</code></pre> 
<h3 id="8.2%20%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95">8.2 数组语法</h3> 
<h4 id="8.2.1%20%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%BC%A0%E7%BB%99%C2%A0v-bind%3Aclass%EF%BC%8C%E4%BB%A5%E5%BA%94%E7%94%A8%E4%B8%80%E4%B8%AA%20class%20%E5%88%97%E8%A1%A8">8.2.1 把一个数组传给 v-bind:class，以应用一个 class 列表</h4> 
<pre><code class="language-javascript">&lt;div v-bind:class="[class1,class2]"&gt;&lt;/div&gt;
data: {
    class1:'active',
    class2:'box'
}</code></pre> 
<p>以上结果渲染为：<span style="background-color:#d7d8d9;">&lt;div class="active box"&gt;&lt;/div&gt;</span></p> 
<h4 id="8.2.2%20%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E5%88%87%E6%8D%A2%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%20class">8.2.2 根据条件切换列表中的 class</h4> 
<p>在数组语法中也可以使用对象语法：</p> 
<pre><code class="language-html">&lt;div v-bind:class="[{ active: isActive }, errorClass]"&gt;&lt;/div&gt;</code></pre> 
<p>这样写将始终添加 errorClass，但是只有在 isActive：true 时才添加 activeClass。</p> 
<h3 id="8.3%20%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A">8.3 用在组件上</h3> 
<p>对于带数据绑定 class的组件也同样适用：</p> 
<pre><code class="language-html">&lt;my-component v-bind:class="{ active: isActive }"&gt;&lt;/my-component&gt;</code></pre> 
<p>当 isActive 为 true 时，class="组件原来的样式 active"</p> 
<h3 id="8.4%20%E6%80%BB%E7%BB%93">8.4 总结</h3> 
<pre><code class="language-html">方式一：v-bind:class="{ '类名1': data1, '类名2': data2,…… }"
data(){
    return{
        data1：false/true，
        data2 : false/true
        ……
    }
}

方式二：v-bind:class="对象名"
data(){
    return{
    对象名:{
         "类名1":false/true,
         "类名2":true/true,
          ……
        }
    }
}

方式三：v-bind:class="[class1，class2，class3，……]"
data(){
    return{
        class1:'类名1',
        class2:'类名2',
        ……
    }
}</code></pre> 
<h2 id="9%C2%A0%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F">9 绑定内联样式</h2> 
<h3 id="9.1%20%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95">9.1 对象语法</h3> 
<blockquote> 
 <p><strong>v-bind:style </strong>的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：</p> 
</blockquote> 
<pre><code class="language-javascript">&lt;div v-bind:style="{color:textColor,fontSize:textSize+ 'px'}"&gt;aa&lt;/div&gt;

data() {
    return {
        textColor:'#aa8',
        textSize:30
    }
},</code></pre> 
<p> 直接绑定到一个样式对象通常更好，这会让模板更清晰：</p> 
<pre><code class="language-javascript">&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt;

data: {
  styleObject:{
        color:'#fff',
        fontSize:25+'px',
    }
}</code></pre> 
<h3 id="%C2%A09.2%C2%A0%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95">9.2 数组语法</h3> 
<p>v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：</p> 
<pre><code class="language-javascript">&lt;div v-bind:style="[styleObject1,styleObject2]"&gt;&lt;/div&gt;
data: {
  styleObject1: {
    color: 'red',
    fontSize:13+'px'
  },
  styleObject2: {
    width: 100+'px',
    height:130+'px'
  }
}
</code></pre> 
<h2 id="10%20%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF">10 组件通讯</h2> 
<h3 id="10.1%20%E7%88%B6%E4%BC%A0%E5%AD%90%E7%94%A8props">10.1 父传子用props</h3> 
<ul><li>第一步：引入子组件。</li><li>第二步：在数据源中定义要传入子组件的数据parentMsg。</li><li>第三步：在使用child组件时传入parentMsg。<span style="background-color:#d7d8d9;">&lt;child :自定义属性名="parentMsg"&gt;&lt;/child&gt;。</span></li><li>第四步：在子组件中，要<span style="background-color:#d7d8d9;"> props:['自定义属性名']</span>来接收传过来的参数。</li></ul> 
<p> 【父组件】</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;parent&lt;/h2&gt;
    &lt;!--3、传入parentMsg--&gt;
    &lt;child :visible="visible"&gt;&lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
//1、引入子组件
import child from './child.vue'
export default {
    data() {
        return {
            //2、定义要传入子组件的数据parentMsg
            visible:'true'
        }
    },
    components:{
        child
    }
}
&lt;/script&gt;</code></pre> 
<p>【子组件】</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    {<!-- -->{visible}}
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    name:'child',
    //使用prors对象可以设置配置项，使用prors数组不可以。
    // props:{
    //     parentMsg:{
    //         type:String,
    //         default:'i am child'
    //     }
    // }
    props:['visible']//接收
}
&lt;/script&gt;</code></pre> 
<p><img alt="" height="573" src="https://images2.imgbox.com/10/19/v83MLAdv_o.png" width="1090"></p> 
<h3 id="10.2%C2%A0%E5%AD%90%E4%BC%A0%E7%88%B6%E7%94%A8%24emit">10.2 子传父用$emit</h3> 
<blockquote> 
 <p>emit使用方法：this.$emit(‘自定义事件名’,所需要传的值)</p> 
</blockquote> 
<ul><li>第一步：首先在子组件中定义一个事件，并且使用emit发送给父组件，在示例中子组件使用的click事件触发发送自定义事件(sendmsg)。</li><li>第二步：在父组件中需要定义方法(getmsg)接受自定义事件(sendmsg)：</li><li>第三步：在使用子组件时，&lt;child @sendmsg="getmsg"&gt;&lt;/child&gt;。</li></ul> 
<p> 【子组件】发送值</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click="childmsg"&gt;点我试试&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    name:'child',
    data() {
        return {
             msg:"This is the first word from child"
        }
    },
    methods:{
        //点击按钮则向父组件传自定义事件sendmsg，childmsg
        childmsg(){
            this.$emit('sendmsg',this.msg)
        }
    }
}
&lt;/script&gt;</code></pre> 
<p>【父组件】接收值</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;child @sendmsg="getmsg"&gt;&lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import child from './child.vue'
export default {
    data() {
        return {
        }
    },
    components:{
        child
    },
    methods:{
        getmsg(val){
            console.log(val)
        }
    }
}
&lt;/script&gt;</code></pre> 
<blockquote> 
 <p><strong>总结：</strong></p> 
 <ul><li>父传子【父中定义要传的值A，通过:B="A"传给子，子用props:["B"]接收，但props只读，要C:this.B，在子组件中就可以对C进行操作（可以理解为B只是C的初始值）】</li><li>子传父【在子中的某个事件 this.$emit('传给父组件的事件E',要传的值G)，父用@E="F"接收并使用,在F中可以如下定义：F(val){……}，此处会把G作为实参传给val】</li></ul> 
</blockquote> 
<h3 id="%C2%A010.3%C2%A0%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB">10.3 兄弟组件之间的数据共享</h3> 
<p><img alt="" height="351" src="https://images2.imgbox.com/ea/fd/OaagmdG8_o.png" width="775"></p> 
<ul><li> 第一步：在兄弟组件同目录下创建eventBus.js，然后创建vue实例：</li></ul> 
<pre><code class="language-javascript">import Vue from 'vue'
export default new Vue()</code></pre> 
<ul><li> <p>第二步：在【兄弟组件A】中，引入eventBus.js &gt; 定义数据msg &gt; 编写方法用于发送msg：</p> </li></ul> 
<pre><code class="language-javascript">import bus from './eventBus.js'
&lt;button @click="sendMsg"&gt;
export default{
    data(){
        return{
            msg:'hello'        
        }    
    },
    methods:{
        sendMsg(){
            bus.$emit('share',this.msg);        
        }    
    }
}</code></pre> 
<ul><li>第三步：在【兄弟组件B】中，引入eventBus.js&gt;定义数据newMsg&gt;编写方法用于接收msg和赋值给newMsg：</li></ul> 
<pre><code class="language-javascript">import bus from './eventBus.js'
&lt;button @click="sendMsg"&gt;
export default{
    data(){
        return{
            newMsg:[]        
        }    
    },
    created:{
          bus.$on('share',val=&gt;{
              this.newMsg=val;          
          }) 
    }
}</code></pre> 
<h2 id="11%20%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%BF%E7%94%A8">11 插槽的使用</h2> 
<p><img alt="" height="1070" src="https://images2.imgbox.com/33/4e/7a8lZix1_o.png" width="1200">总体思想：父组件指定内容，子组件渲染内容。</p> 
<h3 id="11.1%C2%A0%E6%8F%92%E6%A7%BD%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">11.1 插槽基本用法</h3> 
<pre><code class="language-javascript">【父组件】
&lt;Left&gt;
    &lt;p&gt;这是在 Left 组件声明的p标签&lt;/p&gt;
&lt;/Left&gt;

【子组件】
&lt;div class="left-box"&gt;
    &lt;span&gt;Left 组件&lt;/span&gt;
    &lt;!-- 在 Left 组件内声明一个插槽区 --&gt;
    &lt;slot&gt;&lt;/slot&gt;
&lt;/div&gt;</code></pre> 
<h3 id="%C2%A011.2%C2%A0%20v-slot%3A%20%E5%B0%86%E5%86%85%E5%AE%B9%E6%94%BE%E5%9C%A8%E6%8C%87%E5%AE%9A%E6%8F%92%E6%A7%BD">11.2  v-slot: 将内容放在指定插槽</h3> 
<ul><li>vue 官方规定：每一个 slot 插槽都要有一个 name 名称</li><li>如果省略了 slot 的name 则有一个默认名称 default</li><li>默认情况下，使用组件时提供的内容会被填充到 name 为 default 的插槽内</li></ul> 
<p>【将内容放在指定的插槽内】：</p> 
<ul><li>使用 v-slot:xxx， 其中 xxx为插槽 name 值，只能放在 标签内</li><li>使用 标签包裹</li><li>是一个虚拟标签，只起到包裹性质的作用，不会被渲染为实质性的 html 元素</li><li>v-slot:xxx 可以简写为 #xxx</li></ul> 
<pre><code class="language-javascript">【父组件】
&lt;Left&gt;
    &lt;template v-slot:mySlot&gt;
        &lt;p&gt;这是在 Left 组件声明的p标签&lt;/p&gt;
    &lt;/template&gt;
&lt;/Left&gt;

【子组件】
&lt;div style="color:#33e;background:#ee2"&gt;
    &lt;slot name="mySlot"&gt;&lt;/slot&gt;
&lt;/div&gt;</code></pre> 
<h3 id="11.3%C2%A0%E6%8F%92%E6%A7%BD%E5%90%8E%E8%83%8C%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89%E5%86%85%E5%AE%B9">11.3 插槽后背（默认）内容</h3> 
<ul><li>当使用组件指定了插槽内容时，优先显示指定的内容</li><li>当没有指定内容时，渲染 slot 标签内的默认内容</li></ul> 
<h3 id="11.4%20%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%C2%A0">11.4 具名插槽 </h3> 
<p>当需要将内容置入不同组件时，要用带有name属性的插槽：</p> 
<pre><code class="language-html">&lt;HeaderVue #header&gt;我是来自header的插槽&lt;/HeaderVue&gt;
&lt;Main&gt;
    &lt;template v-slot:box1&gt;我是来自child的插槽box1&lt;/template&gt;
    &lt;template v-slot:box2&gt;我是来自child的插槽box2&lt;/template&gt;
&lt;/Main&gt;</code></pre> 
<ul><li>注意 <strong>v-slot</strong> 只能添加在<strong>&lt;template&gt;</strong>上</li><li>v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header</li></ul> 
<h3 id="11.5%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%C2%A0">11.5 作用域插槽 </h3> 
<p><strong>条件</strong>：在封装组件时，为预留的 &lt;slot&gt; 提供属性对应的值<br><strong>格式</strong>：<br><u>子组件：&lt;slot v-bind:username='username' name='box1'&gt;&lt;/slot&gt;</u><br><u>父组件：&lt;template v-slot:box1='username_prors'&gt;</u><br> 在封装组件时，为预留的 &lt;slot&gt; 提供<strong>属性对应的值</strong>，叫做<strong>作用域插槽。</strong>这些属性对应的值可以在<strong>父组件中访问到</strong>，默认为空对象。<br> 【子组件中】</p> 
<pre><code class="language-javascript">&lt;div&gt;
    &lt;slot v-bind:user="user" name="box3"&gt;&lt;/slot&gt;
    &lt;slot v-bind:msg="hello world" name="box4"&gt;&lt;/slot&gt;
&lt;/div&gt;

data(){
    return:{
        user:{
              firstname:'lan',
              lastname:'chun'
            }    
    }
}</code></pre> 
<p>【父组件中】</p> 
<pre><code class="language-html">&lt;子组件名&gt;
    &lt;template v-slot:box3="slotProps1"&gt;
        {<!-- -->{slotProps1.user.firstname}}
        {<!-- -->{slotProps1.user.lastname}}
    &lt;/template&gt;
    &lt;template v-slot:box4="slotProps2"&gt;
        {<!-- -->{slotProps2.msg}}
    &lt;/template&gt;
&lt;/子组件名&gt;</code></pre> 
<h3 id="11.6%C2%A0%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95">11.6 独占默认插槽的缩写语法</h3> 
<p>条件：被提供的内容只有默认插槽时</p> 
<p>格式：直接写在组件里</p> 
<p>当被提供的内容只有默认插槽时，组件的标签可以被当作插槽的模板来使用，可以把 v-slot 直接用在组件上：</p> 
<pre><code class="language-html">&lt;子组件名 v-slot:default="slotProps"&gt;
  {<!-- -->{ slotProps.user.firstName }}
&lt;/子组件名&gt;</code></pre> 
<ul><li>当被提供的内容只有默认插槽时，可以用<span style="background-color:#d7d8d9;"> v-slot:default=" "</span>，也可以直接用缩写<span style="background-color:#d7d8d9;">v-slot=" "</span>。</li><li>默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确。</li><li>只要出现多个插槽，请始终为所有的插槽使用完整的基于 的语法，如下：</li></ul> 
<pre><code class="language-html">&lt;current-user&gt;
  &lt;template v-slot:default="slotProps"&gt;
    {<!-- -->{ slotProps.user.firstName }}
  &lt;/template&gt;

  &lt;template v-slot:other="otherSlotProps"&gt;
    ...
  &lt;/template&gt;

&lt;/current-user&gt;</code></pre> 
<p><img alt="" height="661" src="https://images2.imgbox.com/0a/30/9zoMNInE_o.png" width="594"></p> 
<h3 id="11.7%20%E5%8A%A8%E6%80%81%E6%8F%92%E6%A7%BD%E5%90%8D">11.7 动态插槽名</h3> 
<p>动态指令参数也可以用在 v-slot 上，来定义动态的插槽名：</p> 
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:[dynamicSlotName]&gt;
    ...
  &lt;/template&gt;
&lt;/base-layout&gt;</code></pre> 
<h3 id="11.8%C2%A0%E5%B8%A6%E6%9C%89%20slot%20attribute%20%E7%9A%84%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">11.8 带有 slot attribute 的具名插槽</h3> 
<p>直接把 slot attribute 用在一个普通元素上：</p> 
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;h1 slot="header"&gt;Here might be a page title&lt;/h1&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;p slot="footer"&gt;Here's some contact info&lt;/p&gt;
&lt;/base-layout&gt;</code></pre> 
<h2 id="12%C2%A0%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8">12 路由的使用</h2> 
<blockquote> 
 <p>url地址里，‘#’及以后的部分称为哈希地址，可以在控制台用location.hash打印哈希地址</p> 
</blockquote> 
<h3 id="%C2%A012.1%20%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86">12.1 前端路由的概念和原理</h3> 
<p>1）用户点击页面上的路由链接</p> 
<p>2）导致url地址的Hash值变化</p> 
<p>3）前端路由监听到Hash地址的变化</p> 
<p>4）前端路由把当前Hash地址对应的组件渲染到浏览器中</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/18/87/XvPAuSIH_o.png" width="856"></p> 
<h3 id="12.2%20%E9%85%8D%E7%BD%AE">12.2 配置</h3> 
<ul><li>第一步：安装vue-router包npm install <a href="http://3.5.2" rel="nofollow" title="vue-router@3.5.2">vue-router@3.5.2</a> -S</li><li>第二步：创建路由模块。创建router文件夹，在文件夹下建立index.js</li></ul> 
<pre><code class="language-javascript">//1、导入Vue和VueRouter的包，定义 (路由) 组件
import Vue from 'vue'
import VueRouter from 'vue-router'
import Prize from '@/components/Prize.vue'
import Home from "@/components/Main.vue";
import parent from '@/components/parent'

//2、调用Vue.use()函数，把VueRouter安装为vue插件
Vue.use(VueRouter);

//3、创建路由的实例对象
const router =new VueRouter({
    routes:[
        {
            path:'/home',
            component:Home
        },
        {
            path:'/prize',
            component:Prize,
        },
        {
            path:'/parent',
            component:parent
        }
    ]
})

//4、向外共享路由的实例
export default router</code></pre> 
<h3 id="%C2%A012.3%C2%A0%E6%8A%8Arouter%E5%AF%B9%E8%B1%A1%E6%8C%82%E8%BD%BD%E5%88%B0main.js%E4%B8%8A">12.3 把router对象挂载到main.js上</h3> 
<p>（在new Vue中的router是“router：router”的简写，若import <span style="color:#be191c;">routerVue</span> from 'xxxx'，则应写为<span style="color:#be191c;">router：routerVue</span>)</p> 
<p><img alt="" height="560" src="https://images2.imgbox.com/88/a4/2A5y5tzd_o.png" width="918"></p> 
<p>（ "el"等价于$mount）</p> 
<h3 id="12.4%20%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">12.4 路由的基本使用</h3> 
<ul><li>第一步：在index.js中定制路由规则：</li></ul> 
<pre><code class="language-javascript">import Vue from 'vue'
import VueRouter from 'vue-router'
import Prize from '@/components/Prize.vue'
import Home from "@/components/Main.vue";
import parent from '@/components/parent'

Vue.use(VueRouter);

const router =new VueRouter({
    routes:[
        {
            path:'/',
            redirect:'/home'
        },
        {
            path:'/home',
            component:Home
        },
        {
            path:'/prize',
            component:Prize,
        },
        {
            path:'/parent',
            component:parent
        }
    ]
})

export default router</code></pre> 
<ul><li>第二步：在页面中使用router-view：</li></ul> 
<pre><code class="language-html">&lt;!--可以实现路由跳转，如下：--&gt;
&lt;div id="app"&gt;
  &lt;h1&gt;Hello App!&lt;/h1&gt;
  &lt;p&gt;
    &lt;!-- 使用 router-link 组件来导航. --&gt;
    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;
    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;
    &lt;router-link to="/home"&gt;首页&lt;/router-link&gt;
    &lt;router-link to="/prize"&gt;奖品&lt;/router-link&gt;
  &lt;/p&gt;
  &lt;!-- 路由出口 --&gt;
  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;</code></pre> 
<pre><code class="language-javascript">//也可以在methods中使用，如下：
methods: {
    goBack() {
      window.history.length &gt; 1 ? this.$router.go(-1) : this.$router.push('/')
    }
}</code></pre> 
<blockquote> 
 <ul><li>在进行模块化导入的时候，如果给定的是文件夹，则默认导入这个文件夹下，名字叫做 index.js 的文件</li><li>当对应的路由匹配成功，将自动设置 class 属性值 。查看<a class="link-info" href="https://v3.router.vuejs.org/zh/api/#router-link" rel="nofollow" title="API文档">API文档</a>学习更多相关内容。 ​​​​​</li></ul> 
</blockquote> 
<h3 id="12.5%C2%A0%C2%A0%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91">12.5  路由重定向</h3> 
<p><img alt="" height="449" src="https://images2.imgbox.com/7e/1d/Dzkj89S6_o.png" width="942"></p> 
<h3 id="%C2%A012.6%C2%A0%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1">12.6 嵌套路由</h3> 
<p>需求：在apptest.vue下路由到about，在about组件下路由到tab1、tab2</p> 
<ul><li>第一步：路由配置index.js</li></ul> 
<pre><code class="language-javascript">{
      path: '/about',
      component: About,
      // redirect: '/about/tab1',
      children: [
        // 子路由规则
        // 默认子路由：如果 children 数组中，某个路由规则的 path 值为空字符串，则这条路由规则，叫做“默认子路由”
        { path: '', component: Tab1 },
        { path: 'tab2', component: Tab2 }
      ]
},</code></pre> 
<ul><li>第二步：在apptest.vue下路由到about</li></ul> 
<pre><code class="language-html">&lt;router-link to="/about"&gt;关于&lt;/router-link&gt;
&lt;!-- 作用很单纯：占位符，给要显示的组件预留位置的 --&gt;
&lt;router-view&gt;&lt;/router-view&gt;</code></pre> 
<ul><li>第三步：在about组件下路由到tab1、tab2</li></ul> 
<pre><code class="language-html">&lt;router-link to="/about"&gt;关于&lt;/router-link&gt;
&lt;router-link to="/about/tab2"&gt;关于&lt;/router-link&gt;

&lt;router-view&gt;&lt;/router-view&gt;</code></pre> 
<h3 id="12.7%C2%A0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D">12.7 动态路由匹配</h3> 
<p><img alt="" height="60" src="https://images2.imgbox.com/13/94/IKbNElGx_o.png" width="624"></p> 
<p>需求：有一个组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。</p> 
<pre><code class="language-javascript">const User = {
  template: '&lt;div&gt;User&lt;/div&gt;'
}

const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User }
    //相当于/user？id=xxx
  ]
})</code></pre> 
<p> ①可以通过const User = {template: '{<!-- -->{ $route.params.动态路径参数 }}'来查看当前用户的动态路径参数。</p> 
<p>打印this时是对象</p> 
<p><img alt="" height="167" src="https://images2.imgbox.com/0f/36/NxAmpgLw_o.png" width="354"></p> 
<blockquote> 
 <p> this.$route 是路由的“参数对象”</p> 
 <p>this.$router 是路由的“导航对象”</p> 
</blockquote> 
<p> ②可以为路由规则开启 props 传参，从而方便的拿到动态参数的值</p> 
<p>【index.js】</p> 
<pre><code class="language-javascript">{ path: '/movie/:mid', component: Movie, props: true },</code></pre> 
<p>【movie.vue】</p> 
<pre><code class="language-javascript">props: ['mid'],</code></pre> 
<blockquote> 
 <ul><li>在 hash 地址中， / 后面的参数项，叫做“路径参数”</li><li>在路由“参数对象”中，需要使用 this.$route.params 来访问路径参数</li></ul> 
 <ul><li>在 hash 地址中，? 后面的参数项，叫做“查询参数”</li><li>在路由“参数对象”中，需要使用 this.$route.query 来访问查询参数</li></ul> 
 <ul><li>在 this.$route 中，path 只是路径部分；fullPath 是完整的地址</li></ul> 
 <p>【 例如】：</p> 
 <p>/movie/2?name=zs&amp;age=20 是 fullPath 的值</p> 
 <p>/movie/2 是 path 的值</p> 
</blockquote> 
<h3 id="%C2%A012.8%C2%A0%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E6%88%96%20404%20Not%20found%20%E8%B7%AF%E7%94%B1">12.8 捕获所有路由或 404 Not found 路由</h3> 
<pre><code class="language-javascript">{
  // 会匹配所有路径
  path: '*'
}
{
  // 会匹配以 `/user-` 开头的任意路径
  path: '/user-*'
}</code></pre> 
<p>注：当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: '*' } 通常用于客户端 404 错误。</p> 
<h3 id="12.9%C2%A0%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC">12.9 编程式导航跳转</h3> 
<p><img alt="" height="173" src="https://images2.imgbox.com/4f/ac/LX6JIyeu_o.png" width="582"></p> 
<p>vue-router中的编程式导航API，常用的导航API有：</p> 
<p><strong>①this.$router.push('hash地址')</strong></p> 
<p><u>跳转到指定hash地址，并增加一条历史记录</u></p> 
<p><strong>②this.$router.replace('hash地址')</strong></p> 
<p><u>跳转到指定的hash地址，并替换掉当前的历史记录</u></p> 
<p><strong>③this.$router.go(数值n)</strong></p> 
<p><u>跳回第n条历史记录 </u></p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="movie-container"&gt;
    &lt;button @click="gotoLk"&gt;通过 push 跳转到“洛基”页面&lt;/button&gt;
    &lt;button @click="gotoLk2"&gt;通过 replace 跳转到“洛基”页面&lt;/button&gt;
    
    &lt;button @click="goback"&gt;后退&lt;/button&gt;
    &lt;!-- 在行内使用编程式导航跳转的时候，this 必须要省略，否则会报错！ --&gt;
    &lt;button @click="$router.back()"&gt;back 后退&lt;/button&gt;
    &lt;button @click="$router.forward()"&gt;forward 前进&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'Movie',
  methods: {
    gotoLk() {
      // 通过编程式导航 API，导航跳转到指定的页面
      this.$router.push('/movie/1')
    },
    gotoLk2() {
      this.$router.replace('/movie/1')
    },
    goback() {
      // go(-1) 表示后退一层
      // 如果后退的层数超过上限，则原地不动
      this.$router.go(-1)
    }
  }
}
&lt;/script&gt;</code></pre> 
<h3 id="12.10%C2%A0%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB">12.10 路由守卫</h3> 
<p>路由守卫可以控制路由的访问权限。</p> 
<h4 id="12.10.1%20%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">12.10.1 全局前置守卫</h4> 
<p>【index.js】中</p> 
<pre><code class="language-javascript">// 为 router 实例对象，声明全局前置导航守卫
// 只要发生了路由的跳转，必然会触发 beforeEach 指定的 function 回调函数
router.beforeEach(function(to, from, next) {
  // to 表示将要访问的路由的信息对象
  // from 表示将要离开的路由的信息对象
  // next() 函数表示放行的意思
  // 分析：
  // 1. 要拿到用户将要访问的 hash 地址
  // 2. 判断 hash 地址是否等于 /main。
  // 2.1 如果等于 /main，证明需要登录之后，才能访问成功
  // 2.2 如果不等于 /main，则不需要登录，直接放行  next()
  // 3. 如果访问的地址是 /main。则需要读取 localStorage 中的 token 值
  // 3.1 如果有 token，则放行
  // 3.2 如果没有 token，则强制跳转到 /login 登录页
  if (to.path === '/main') {
    // 要访问后台主页，需要判断是否有 token
    const token = localStorage.getItem('token')
    if (token) {
      next()//如果有token（登录）就放行
    } else {
      // 没有登录，强制跳转到登录页
      next('/login')
    }
  } else {
    next()
  }
})</code></pre> 
<h4 id="12.10.2%20next%20%E5%87%BD%E6%95%B0%E7%9A%84%203%20%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F">12.10.2 next 函数的 3 种调用方式</h4> 
<p><img alt="" height="621" src="https://images2.imgbox.com/bd/88/OzQtrLUs_o.png" width="1200"></p> 
<h4 id="%C2%A012.10.3%C2%A0%E5%85%B3%E4%BA%8Epath%E5%92%8Cfullpath">12.10.3 关于path和fullpath</h4> 
<p>如：<a href="http://localhost:8080/index?page=1" rel="nofollow" title="http://localhost:8080/index?page=1">http://localhost:8080/index?page=1</a></p> 
<p>fullPath：路由全地址，fullPath为<span style="background-color:#f9eda6;">/index?page=1</span></p> 
<p>path：路径，不带参数，path为<span style="background-color:#f9eda6;">/index</span></p> 
<h3 id="12.11%20%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82">12.11 路由传参</h3> 
<h4 id="%C2%A012.11.1%C2%A0query%E4%BC%A0%E5%8F%82">12.11.1 query传参</h4> 
<pre><code class="language-html"> 1. 路由跳转并携带query参数，to的字符串写法 messageData是一个变量
 &lt;router-link :to="`/home/news?id=001&amp;message=${messageData}`" &gt;&lt;/router-link&gt;
 
 2. 路由跳转并携带query参数，to的对象
 &lt;router-link :to="{
 path:"/home/news",
 query:{
            id:001,
            message:messageData
 }
 }" &gt;
 &lt;/router-link&gt;
</code></pre> 
<p>获取参数：<span style="background-color:#d7d8d9;">this.$route.query.id</span> 、 <span style="background-color:#d7d8d9;">this.$route.query.message </span></p> 
<h4 id="12.11.2%20params%E4%BC%A0%E5%8F%82">12.11.2 params传参</h4> 
<p> <strong>方式一</strong>：路由跳转并携带param参数，to的字符串写法 ，首先我们要在路由文件中定义我们要传递的参数</p> 
<pre><code class="language-html">// 1. 路由跳转并携带params参数，to的字符串写法 messageData是一个变量
 &lt;router-link :to="`/home/news/001/${messageData}`" &gt;&lt;/router-link&gt; //即{id:001,message:xxx}
</code></pre> 
<p>跳转时直接斜杠/后面拼接参数</p> 
<pre><code class="language-html">// 1. 路由跳转并携带params参数，to的字符串写法 messageData是一个变量
 &lt;router-link :to="`/home/news/001/${messageData}`" &gt;&lt;/router-link&gt; //即{id:001,message:xxx}
</code></pre> 
<p><strong>方式二</strong>：路由跳转并携带params参数，to的对象写法，不需要在路由文件中定义参数</p> 
<pre><code class="language-html">&lt;router-link :to="{
    name:"HomeNews", //使用params传参时，必须使用name属性进行路由跳转，不能使用path配置项跳转
    params:{
        id:001,
        message:messageData
}
 }" &gt;&lt;/router-link&gt;
</code></pre> 
<p>获取参数：<span style="background-color:#d7d8d9;">this.$route.params.id</span> 、 <span style="background-color:#d7d8d9;">this.$route.params.message</span></p> 
<h4 id="12.11.3%C2%A0%E8%B7%AF%E7%94%B1props%E9%85%8D%E7%BD%AE">12.11.3 路由props配置</h4> 
<p>传参配置： src/router/index.js</p> 
<pre><code class="language-javascript"> {
    name:'HomeNews'
    path:'news/:id/:message',//二级路由,定义参数，表示第一个参数是id，第二个是message
    component:News,
    // 第一种写法：props值为对象，该对象中所有的key-value最终都会通过props传递给组件news
    // props:{a:1},
    // 第二种写法(只能params)：props值为Boolean，为true时把路由收到的`params`参数通过props传递给组件news
    // props:true,
    // 第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传递给组件news
   props:function(route){
   return {
   id:route.query.id,
   message:route.query.message
   }
   },
 },
</code></pre> 
<p>使用: New.vue</p> 
<pre><code class="language-javascript">export default{
    prors:['id','message']
}</code></pre> 
<h2 id="13%C2%A0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86">13 状态管理</h2> 
<h3 id="13.1%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B">13.1 状态管理简介</h3> 
<p>vuex是专为vue.js应用程序开发的状态管理模式。它采用集中存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex也集成刀vue的官方调试工具devtools extension，提供了诸如零配置的time-travel调试、状态快照导入导出等高级调试功能。</p> 
<h3 id="13.2%20Vuex%20%E7%9A%84%E6%80%9D%E6%83%B3">13.2 Vuex 的思想</h3> 
<p>当我们在页面上点击一个按钮，它会触发(dispatch)一个action, action 随后会执行(commit)一个mutation, mutation 立即会改变state, state 改变以后,我们的页面会state 获取数据，页面发生了变化。</p> 
<h3 id="13.3%20%E6%A0%B8%E5%BF%83%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86">13.3 核心状态管理</h3> 
<p><span style="color:#fe2c24;">通俗理解是存储在store里的都是全局变量，可以通过方法提交更新，其他页面和组件也会同步更新，拿到最新的值。</span>状态管理核心状态管理有5个核心，分别是<strong>state、getter、mutation、action以及module</strong>。</p> 
<ul><li><strong>state</strong></li></ul> 
<p><strong>驱动应用的数据源</strong>。state为单一状态树，可以使用一个对象包含全部的应用层级状态，state就是数据源。</p> 
<ul><li><strong>getter</strong></li></ul> 
<p><strong>getter有点类似vue的计算属性computed</strong>，当我们需要对数据进行处理，那么我们就需要使用getter，getter会接收state作为第一个参数，而且getter的返回值会根据它的依赖被缓存起来，只有getter中的依赖值（state中的某个需要派生状态的值）发生改变的时候才会被重新计算。</p> 
<pre><code class="language-javascript">const getters = {
    getUserState (state) {
        let data;
        if(state.userState==0){
            data='无效'
        }else if(state.userState==1){
            data = '1级'
        }else{
            data = '2级'       
        }
        return data;
    }
}

 export default new Vuex.Store({
    state,
    mutations,
    getters
})</code></pre> 
<p>页面上使用这个getters：</p> 
<pre><code class="language-html">计算数据状态：{<!-- -->{$store.getters.getUserState}}</code></pre> 
<ul><li><strong>mutation</strong></li></ul> 
<p>更改store中state状态的唯一方法就是提交mutation，<strong>类似vue中的methods</strong>。每个mutation都有一个字符串类型的事件类型和一个回调函数，我们需要改变state的值就要在回调函数中改变。我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。</p> 
<ul><li><strong>action</strong></li></ul> 
<p><strong>响应在 view 上的用户输入导致的状态变化</strong>。action可以提交mutation，在action中可以执行store.commit，而且action中可以有任何的异步操作。<strong>action处理异步操作，</strong>由于mutation都是同步事务，在 mutation 中混合异步调用会导致你的程序很难调试。action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。</p> 
<pre><code class="language-javascript"> mutations: {
        addAge: (state, payload) =&gt; {
            state.informations.forEach(info =&gt; {
                info.age += payload;
            })
        }
 },
 actions: {
        addAge: (context, payload) =&gt; {
            setTimeout(function () {
                context.commit("addAge", payload);
            }, 2000);
        }
  }</code></pre> 
<p>在组件的methods中能够通过【this.$store.dispatch("addAge", 2);】分发action。</p> 
<p>(或者使用mapActions辅助函数将组件的 methods 映射为 store.dispatch 调用)</p> 
<pre><code class="language-javascript">methods: {
    addAge() {
      this.$store.dispatch("addAge", 2);
    }
},</code></pre> 
<blockquote> 
 <p>注意：</p> 
 <p>1、所有 store 中 state 的变更，都放置在 store 自身的 action 中去管理。</p> 
 <p>2、Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到更新。</p> 
 <p>3、不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交（commit）mutation。</p> 
</blockquote> 
<h3 id="13.4%20%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8">13.4 在项目中使用</h3> 
<h4 id="%C2%A013.4.1%20store%E4%B8%80%E8%88%AC%E6%9C%89%E4%BB%A5%E4%B8%8B6%E4%B8%AA%E6%96%87%E4%BB%B6">13.4.1 store一般有以下6个文件</h4> 
<p><img alt="" height="466" src="https://images2.imgbox.com/03/44/CwtIIvtc_o.png" width="1184"></p> 
<h4 id="%C2%A013.4.2%C2%A0vuex%E4%B8%AD%20this.%24store.dispatch()%20%E4%B8%8E%20this.%24store.commit()%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB">13.4.2 vuex中 this.$store.dispatch() 与 this.$store.commit()方法的区别</h4> 
<p>这两个的区别是存取的方式不同，两个都是传值给vuex的mutation改变state.</p> 
<ul><li>this.$store.dispatch含有异步操作，可以向后台提交数据</li></ul> 
<pre><code class="language-javascript">【存储】this.$store.dispatch（"action的方法名",value)
【取值】this.$store.getters.action的方法名</code></pre> 
<ul><li>this.$store.commit同步操作</li></ul> 
<pre><code class="language-javascript">【存储】this.$store.commit("mutation的方法名",value)
【取值】this.$store.state.mutation的方法名</code></pre> 
<h4 id="14.4.3%20%E5%AE%9E%E4%BE%8B1">13.4.3 实例1</h4> 
<p>在app.vue里先import store from “./store” 并且在new vue实例的时候加上store，这样就可以全局调用了。</p> 
<p>【src/store/index.js】引入Vuex文组件：</p> 
<pre><code class="language-javascript">//第一步：使用import引入vue和vuex
import Vue from 'vue';
import Vuex from 'vuex';

//第二步：把vuex作为组件引入
Vue.use(Vuex);

//第三步：实例化vuex.store对象
//store变量是实例化一个vuex.store
export const store =new Vuex.Store({
//第四步：定义state
    //state专门用于保存共享的状态值
    state:{
        //保存登陆状态
          login:false  
    },

//第五步：编写方法改变state中的值
//专门书写方法，用于更新state中的值
    mutations:{
        doLogin(state){
            state.login=true;        
        },
         doLoginout(state){
             state.login=false;         
         }
    }
});</code></pre> 
<p>【 src/components/Header.vue】组件JS部分：</p> 
<pre><code class="language-javascript">&lt;script&gt;
//使用vuex的mapState需要引入
import {mapState} form "vuex";

export default{
    name:"Header",
    //引入vuex&gt;store&gt;state中的值，必须在计算属性中书写
    computed:{
        //mapState辅助函数，可以快速引入store中的值
        ...mapState(["login"])    
    },
    methods:{
        loginout(){
            //调用store里登出的方法
            this.$store.commit(" doLoginout");        
        }    
    }
}
&lt;/script&gt;</code></pre> 
<p>【src/components/Login.vue】组件JS部分 ：</p> 
<pre><code class="language-javascript">&lt;script&gt;
export default {
  name: "Login",
  data() {
    return {
    };
  },
  methods: {
    doLogin() {
             ……
            // 路由跳转指定页面
            this.$router.push({ path: "/" });

            //更新 vuex 的 state的值, 必须通过 mutations 提供的方法才可以
            //通过 commit('方法名') 就可以触发mutations 中的指定方法
            this.$store.commit("doLogin");
          } 
        });
     }
  }
};
&lt;/script&gt;
</code></pre> 
<p>使用$router.push转到首页url，并且调用store里的登录方法把共享登录状态变成true。</p> 
<h4 id="13.4.4%20%E5%AE%9E%E4%BE%8B2">13.4.4 实例2</h4> 
<p>【声明】src/store/index.js:</p> 
<pre><code class="language-javascript">import Vuex from 'vuex';
import Vue from 'vue';
……；
import test from '@/store/modules/test'

Vue.use(Vuex);
export default new Vuex.Store({
  modules: {
    ……，
    test
  },
});</code></pre> 
<p>【定义】src/store/models/test.js：</p> 
<pre><code class="language-javascript">const state={
    username:'lanchun',
    userState:0
}
const mutations={
    SetUserName(state,name){
        state.username=name;
    },
    SetUserState(state,num){
        state.userState+=num;
    }
}

export default{
    state,
    mutations
}</code></pre> 
<p>【使用】src/views/page.vue：</p> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div&gt;
      &lt;h1&gt;{<!-- -->{$store.state.test.username}}&lt;/h1&gt;
      &lt;h1&gt;{<!-- -->{$store.state.test.userState}}&lt;/h1&gt;
      数据状态：
      &lt;a-button @click="addState"&gt;状态+1&lt;/a-button&gt;
    &lt;/div&gt;
&lt;/template&gt;

 methods: {
    addState(){
      console.log(this.$store.state.test);
      console.log(this.$store);
      this.$store.commit('SetUserName','张三');
      this.$store.commit('SetUserState',1);
    },
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4215fb62d0df87fbf23ecafe9244a06a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32通过DMA进行ADC采集（HAL库）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5419fa6992145e678675433637905608/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JAVA实现Date日期加一天</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>