<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java开发之设计模式--抽象工厂模式(Abstract Factory) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java开发之设计模式--抽象工厂模式(Abstract Factory)" />
<meta property="og:description" content="作为工厂方法模式的孪生兄弟，相信大家对工厂方法模式和抽象工厂模式傻傻分不清楚吧。
那么，就让我来拯救大家吧！
抽象工厂模式 定义：所谓抽象工厂模式就是为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。
类型：创建类模式
类图： 抽象工厂模式与工厂方法模式的区别 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。
在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们拿生产汽车的例子来说明他们之间的区别。 在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。
明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。
总而言之，言而总之，如果把他们的区别总结一下就是：
工厂方法模式： 一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类只能创建一个具体产品类的实例。
抽象工厂模式： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。
区别：
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。
抽象工厂模式代码 interface IProduct1 { public void show(); } interface IProduct2 { public void show(); } class Product1 implements IProduct1 { public void show() { System.out.println(&#34;这是1型产品&#34;); } } class Product2 implements IProduct2 { public void show() { System.out.println(&#34;这是2型产品&#34;); } } interface IFactory { public IProduct1 createProduct1(); public IProduct2 createProduct2(); } class Factory implements IFactory{ public IProduct1 createProduct1() { return new Product1(); } public IProduct2 createProduct2() { return new Product2(); } } public class Client { public static void main(String[] args){ IFactory factory = new Factory(); factory." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/15ec6d3c9943ffb3b90f30f9c6c20c5d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-04-12T17:14:34+08:00" />
<meta property="article:modified_time" content="2015-04-12T17:14:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java开发之设计模式--抽象工厂模式(Abstract Factory)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>作为工厂方法模式的孪生兄弟，相信大家对工厂方法模式和抽象工厂模式傻傻分不清楚吧。</p> 
<p>那么，就让我来拯救大家吧！</p> 
<h3 id="抽象工厂模式">抽象工厂模式</h3> 
<p><strong>定义：</strong>所谓抽象工厂模式就是为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。</p> 
<p><strong>类型：</strong>创建类模式</p> 
<p><strong>类图：</strong> <br> <img src="https://images2.imgbox.com/39/c7/LokK8XcE_o.jpg" alt="这里写图片描述" title=""></p> 
<h4 id="抽象工厂模式与工厂方法模式的区别">抽象工厂模式与工厂方法模式的区别</h4> 
<p>抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。</p> 
<p>在抽象工厂模式中，有一个<strong>产品族</strong>的概念：所谓的产品族，是指<strong>位于不同产品等级结构中功能相关联的产品组成的家族。</strong>抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们拿生产汽车的例子来说明他们之间的区别。 <br> <img src="https://images2.imgbox.com/5a/c3/AzvgWuKq_o.jpg" alt="这里写图片描述" title=""></p> 
<p>在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。</p> 
<p>明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。</p> 
<p>总而言之，言而总之，如果把他们的区别总结一下就是：</p> 
<p><strong>工厂方法模式：</strong> <br> 一个抽象产品类，可以派生出多个具体产品类。 <br> 一个抽象工厂类，可以派生出多个具体工厂类。 <br> 每个具体工厂类只能创建一个具体产品类的实例。</p> 
<p><strong>抽象工厂模式：</strong> <br> 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 <br> 一个抽象工厂类，可以派生出多个具体工厂类。 <br> 每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。</p> 
<p><strong>区别：</strong></p> 
<ol><li><p>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 </p></li><li><p>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</p></li><li><p>工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 </p></li><li><p>抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。</p></li></ol> 
<h4 id="抽象工厂模式代码">抽象工厂模式代码</h4> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IProduct1</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> show();
}
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IProduct2</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> show();
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product1</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">IProduct1</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> show() {
        System.out.println(<span class="hljs-string">"这是1型产品"</span>);
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product2</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">IProduct2</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> show() {
        System.out.println(<span class="hljs-string">"这是2型产品"</span>);
    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFactory</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> IProduct1 createProduct1();
    <span class="hljs-keyword">public</span> IProduct2 createProduct2();
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">IFactory</span>{<!-- --></span>
    <span class="hljs-keyword">public</span> IProduct1 createProduct1() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product1();
    }
    <span class="hljs-keyword">public</span> IProduct2 createProduct2() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product2();
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args){
        IFactory factory = <span class="hljs-keyword">new</span> Factory();
        factory.createProduct1().show();
        factory.createProduct2().show();
    }
}</code></pre> 
<h4 id="抽象工厂模式的优点">抽象工厂模式的优点</h4> 
<p>抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。</p> 
<h4 id="抽象工厂模式的缺点">抽象工厂模式的缺点</h4> 
<p>产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。</p> 
<h4 id="适用场景">适用场景</h4> 
<p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p> 
<h4 id="总结">总结</h4> 
<p>无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。</p> 
<p>所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f65d1e16a7796eca9ab0d1bd55a22ad9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HOGDescriptor::SetSVMDetector()</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0965e63d64483b412f3cb5f6d655c1f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python 如何判断一个array是否是空?</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>