<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Sspring Boot 处理数据 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Sspring Boot 处理数据" />
<meta property="og:description" content="今天我们接着上一期来说一下，如果出现空值，SpringBoot会如何处理
在实际项目中，难免会遇到一些 null 值出现，转 json 时是不希望有这些 null 出现的，比如期望所有的 null 在转 json 时都变成&#34;&#34;这种空字符串，那该如何做呢？在 Spring Boot 中做一下配置即可。
1.新建一个 jackson 的配置类
import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializerProvider; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; import java.io.IOException; @Configuration *[HTML]: 用于声明当前类是一个配置类，最新的注解为@SpringBootConfiguration public class JacksonConfig { @Bean 用于在配置类中，表示方法的返回值是一个受管 bean @Primary 如果多个配置，则以当前的为主 @ConditionalOnMissingBean(ObjectMapper.class) 条件注解，表示如果受管 bean 中没有 ObjectMapper 类型的对象，则需要构建 public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() { @Override public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { jsonGenerator." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c49f697c87f9d2007c153bfc03c41eff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-23T21:26:26+08:00" />
<meta property="article:modified_time" content="2023-07-23T21:26:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Sspring Boot 处理数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>今天我们接着上一期来说一下，如果出现空值，SpringBoot会如何处理</p> 
<p>在实际项目中，难免会遇到一些 null 值出现，转 json 时是不希望有这些 null 出现的，比如期望所有的 null 在转 json 时都变成""这种空字符串，那该如何做呢？在 Spring Boot 中做一下配置即可。<br> <strong>1.新建一个 jackson 的配置类</strong></p> 
<pre><code>import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializerProvider;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import java.io.IOException;

@Configuration    *[HTML]:  用于声明当前类是一个配置类，最新的注解为@SpringBootConfiguration
public class JacksonConfig {
@Bean 用于在配置类中，表示方法的返回值是一个受管 bean
@Primary 如果多个配置，则以当前的为主
@ConditionalOnMissingBean(ObjectMapper.class) 条件注解，表示如果受管 bean 中没有 ObjectMapper
类型的对象，则需要构建
public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
ObjectMapper objectMapper = builder.createXmlMapper(false).build();
objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() {
@Override
public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)
throws IOException {
jsonGenerator.writeString(""); 针对 null 内容输出空字符串
}
});
return objectMapper;
}
}
然后修改一下上面返回 map 的接口，将几个值改成 null 测试一下：
@RequestMapping("/map")
public Map&lt;String, Object&gt; getMap() {
Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);
User user = new User(1, "张三", null);
map.put("作者信息", user);
map.put("博客地址", "http://blog.zhang.com");
map.put("CSDN 地址", null);
map.put("粉丝数量", 4153);
return map;
}
重启项目再次输入 localhost:8080/json/map，可以看到 jackson 已经将所有 null 字段转成了空字符串了。例如
返回数据为{"作者信息":{"id":1,"username":"张三","password":""},"CSDN 地址":"","粉丝数量":4153,"博客地
址":"http://blog.yan.com"}

</code></pre> 
<p><strong>配置属性不参与映射输出</strong><br> @JsonIgnore 指定该属性不参与 JSON 字符串的映射<br> private String password;<br> <strong>配置日期类型数据的映射格式</strong><br> @JsonFormat(pattern = “yyyy-MM-dd”)<br> private Date birth=new Date();</p> 
<p><strong>2. 整合通用 Mapper 的开发方法</strong><br> 通用 mapper 就是基于 mybatis 的一款 MyBatis 增强插件，可以提供一些常用增、删、改、查的操作，不需要<br> 重复写一些常用的 sql。简化操作，精简代码，并且达到代码风格统一的目的。它的出现不是为了替代 mybatis，<br> 而是让 mybatis 的开发更方便。<br> 添加依赖：</p> 
<pre><code>&lt;dependency&gt;
&lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
&lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
&lt;version&gt;4.2.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
<p>使用通用 mapper 的开发方式，采用注解定义映射关系，自动生成常见的 SQL 语句，不需要 xml 映射元文件<br> /*<br> 1.表名默认使用类名,驼峰转下划线(只对大写字母进行处理),如 TestUser 默认对应的表名为 test_user<br> 2.表名可以使用@Table(name = “tableName”)进行指定,对不符合第一条默认规则的可以通过这种方式指定表<br> 名<br> 3.字段默认和@Column 一样,都会作为表字段,表字段默认为 Java 对象的 Field 名字驼峰转下划线形式.<br> 4.可以使用@Column(name = “fieldName”)指定不符合第 3 条规则的字段名<br> 5.使用@Transient 注解可以忽略字段,添加该注解的字段不会作为表字段使用.<br> 6.建议一定是有一个@Id 注解作为主键的字段,可以有多个@Id 注解的字段作为联合主键. 7.默认情况下,实体类中如果不存在包含@Id 注解的字段,所有的字段都会作为主键字段进行使用(这种效率极<br> 低).<br> 8.实体类可以继承使用,可以参考测试代码中的 tk.mybatis.mapper.model.UserLogin2 类. 9.由于基本类型,如 int 作为实体类字段时会有默认值 0,而且无法消除,所以实体类中建议不要使用基本类型.<br> 10.@NameStyle 注解，用来配置对象名/字段和表名/字段之间的转换方式，该注解优先于全局配置 style，<br> 可选值：<br> normal:使用实体类名/属性名作为表名/字段名<br> camelhump:这是默认值，驼峰转换为下划线形式<br> uppercase:转换为大写<br> lowercase:转换为小写<br> *</p> 
<pre><code>@Entity //用于声明当前类是一个实体类
@Table(name="tbl_users") // 用于声明当前类所对应的表名称
public class User implements Serializable {
@Id //用于声明标识属性，对应表中的主键
@GeneratedValue(strategy = GenerationType.IDENTITY) 声明主键生成策略
private Long id;
@Column //如果属性名称和列名称不一致，则需要通过@Column 进行配置对应的列名称
private String username;
private String password;
private Date birth;
private Boolean sex;
}
</code></pre> 
<p><strong>定义 mapper 接口</strong></p> 
<pre><code>public interface UserMapper extends BaseMapper&lt;User&gt; {
}
</code></pre> 
<p>针对 mapper 接口进行注册，一般是依赖自动扫描实现。可以在主类或者配置上添加一个注解配置<br> <img src="https://images2.imgbox.com/13/08/HetRNJN4_o.png" alt="在这里插入图片描述"></p> 
<pre><code>SpringBoot 针对 Junit 的单元测试有很好的支持
@SpringBootTest
class CommonMapperApplicationTests {
@Autowired
private UserMapper userMapper;
@Test
void contextLoads() {
}
@Test
void testCreate(){
User user=new User();
user.setUsername("张三丰");
user.setPassword("333333");
user.setSex(true);
int len = userMapper.insertSelective(user);
Assertions.assertEquals(1,len);
}
}
</code></pre> 
<p>需要控制器调用业务，业务再通过 Mapper 访问数据库，最终返回 JSON 字符串<br> <strong>3. 使用阿里巴巴 FastJson 的设置</strong><br> 3.1 jackson 和 fastJson 的对比<br> 有很多人已经习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，比如目前项目中使用的就是阿里的 fastJson<br> 关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。<br> 从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，项目中目前使用的是阿里的 fastJson，挺方便的。<br> 3.2 fastJson 依赖导入<br> 使用 fastJson 需要导入依赖</p> 
<pre><code>&lt;dependency&gt;
&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
&lt;artifactId&gt;fastjson&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<p>3.3 使用 fastJson 处理 null<br> 使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要继承 WebMvcConfigurationSupport 类或者实现WebMvcConfiguration 接口，然后覆盖 configureMessageConverters 方法，在方法中可以选择对要实现 null转换的场景，配置好即可。</p> 
<pre><code>import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.support.config.FastJsonConfig;
import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
@Configuration
public class fastJsonConfig extends WebMvcConfigurationSupport {
//使用阿里 FastJson 作为 JSON MessageConverter
@Override
public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();
FastJsonConfig config = new FastJsonConfig();
config.setSerializerFeatures(
SerializerFeature.WriteMapNullValue, // 保留 map 空的字段
SerializerFeature.WriteNullStringAsEmpty, // 将 String 类型的 null 转成"" SerializerFeature.WriteNullNumberAsZero, // 将 Number 类型的 null 转成 0
SerializerFeature.WriteNullListAsEmpty, // 将 List 类型的 null 转成[]
SerializerFeature.WriteNullBooleanAsFalse, // 将 Boolean 类型的 null 转成 false
SerializerFeature.DisableCircularReferenceDetect); // 避免循环引用
converter.setFastJsonConfig(config);
converter.setDefaultCharset(Charset.forName("UTF-8"));
List&lt;MediaType&gt; mediaTypeList = new ArrayList&lt;&gt;();
// 解决中文乱码问题，相当于在 Controller 上的@RequestMapping 中加了个属性 produces =
"application/json" mediaTypeList.add(MediaType.APPLICATION_JSON);
converter.setSupportedMediaTypes(mediaTypeList);
converters.add(converter);
}
}
</code></pre> 
<p><strong>测试工具 postman</strong><br> <img src="https://images2.imgbox.com/94/c8/IK5SoVVC_o.png" alt="在这里插入图片描述"><br> 如果直接测试，则需要编写页面和 js 代码才能进行验证，可以使用 postman 避免这些繁琐的操作<br> <img src="https://images2.imgbox.com/77/21/TGY41BWA_o.png" alt="插入图片描述"><br> 这里用的是postman进行测试的，因为如果在idea里进行测试，我们还得写html,js等前端用的东西，会比较繁琐<br> 这里针对日期类型数据的格式转换会有报错。最终提交数据为</p> 
<pre><code>{"username":"谢逊","sex":"true","birth":"1989-02-03","password":"666666"}
</code></pre> 
<p><strong>4. 封装统一返回的数据结构</strong><br> 在实际项目中，除了要封装数据之外，往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code<br> 【注意不是 response 的响应状态码】，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些<br> 逻辑判断。所以在实际项目中，需要封装一个统一的 json 返回结构存储返回信息。<br> 4.1 定义统一的 json 结构<br> 由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时需要用到泛型。统一的 json 结构中属性包<br> 括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认<br> 的返回结构，也应该有用户指定的返回结构。</p> 
<pre><code>public class JsonResult&lt;T&gt; {
private T data; //需要传递的数据
private int code; //用户自定义相应码，注意不是服务器响应状态码。如果不需要传递详细信息还可以使
用 boolean success;
</code></pre> 
<pre><code>private String msg; // 服务器回传信息
public JsonResult() { 若没有数据返回，默认状态码为 0，提示信息为：操作成功！
this.code = 0;
this.msg = "操作成功！";
}
public JsonResult(int code, String msg) { 若没有数据返回，可以人为指定状态码和提示信息
this.code = code;
this.msg = msg;
}
public JsonResult(T data) { 有数据返回时，状态码为 0，默认提示信息为：操作成功！
this.data = data;
this.code = 0;
this.msg = "操作成功！";
}
public JsonResult(T data, String msg) { 有数据返回，状态码为 0，人为指定提示信息
this.data = data;
this.code = 0;
this.msg = msg;
}
// 省略 get 和 set 方法
}
</code></pre> 
<p>建议写法，不一定最佳</p> 
<p><img src="https://images2.imgbox.com/0d/d1/in8aqmkd_o.png" alt="在这里插入图片描述"><br> 4.2 修改 Controller 中的返回值类型及测试<br> 由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体<br> 的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义<br> 一个枚举类型，以后只需要维护这个枚举类型中的数据即可。根据以上的 JsonResult 可以改写一下 Controller</p> 
<pre><code>@RestController
@RequestMapping("/jsonresult")
public class JsonResultController {
@RequestMapping("/user")
public JsonResult&lt;User&gt; getUser() {
</code></pre> 
<pre><code>User user = new User(1, "张三", "123456");
return new JsonResult&lt;&gt;(user);
}
@RequestMapping("/list")
public JsonResult&lt;List&gt; getUserList() {
List&lt;User&gt; userList = new ArrayList&lt;&gt;();
User user1 = new User(1, "张三", "123456");
User user2 = new User(2, "死胖子", "123456");
userList.add(user1);
userList.add(user2);
return new JsonResult&lt;&gt;(userList, "获取用户列表成功");
}
@RequestMapping("/map")
public JsonResult&lt;Map&gt; getMap() {
Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);
User user = new User(1, "张三", null);
map.put("作者信息", user);
map.put("博客地址", "http://blog.yan.com");
map.put("CSDN 地址", null);
map.put("粉丝数量", 4153);
return new JsonResult&lt;&gt;(map);
}
}
</code></pre> 
<p>重新在浏览器中输入：localhost:8080/jsonresult/user 返回 json：<br> {“code”:0,“data”:{“id”:1,“password”:“123456”,“username”:“张三”},“msg”:“操作成功！”}<br> 输入：localhost:8080/jsonresult/list，返回 json 格式：<br> {“code”:0, “data”:[{“id”:1, “password”:“123456”, “username”:" 张三 “}, {“id”:2, “password”:“123456”, “username”:“死胖子”}], “msg”:“获取用户列表成功”}<br> 输入：localhost:8080/jsonresult/map，返回 json 格式：<br> {“code”:“0”, “data”:{“作者信息”:{“id”:1, “password”:”",“username”:“张三”},“CSDN 地址”:null,"粉丝数量<br> ":4153,“博客地址”:“http://blog.yan.com”},“msg”:“操作成功！”}<br> 通过封装，不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中<br> 应用非常广泛。<br> <img src="https://images2.imgbox.com/bd/c6/nC7k7Lk6_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5__288"></a>5. 总结</h4> 
<p>本篇主要是对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里的fastJson 框架，分别对它们的配置做了相应的描述。另外，结合实际项目情况，总结了实际项目中使用的 json封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d94c0117ad92433f8f6b99661514118/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu下打开QtCreator环境变量LD_LIBRARY_PATH与终端不一致</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ed9f36a311a57e684a79ea26d1ea087/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">继电器开关阿里云IOT上云设置操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>