<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python之struct详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python之struct详解" />
<meta property="og:description" content="用处
按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送; 按照指定格式将字节流转换为Python指定的数据类型; 处理二进制数据,如果用struct来处理文件的话,需要用’wb’,’rb’以二进制(字节流)写,读的方式来处理文件; 处理c语言中的结构体; struct模块中的函数
函数 return explain
pack(fmt,v1,v2…) string 按照给定的格式(fmt),把数据转换成字符串(字节流),并将该字符串返回.
pack_into(fmt,buffer,offset,v1,v2…) None 按照给定的格式(fmt),将数据转换成字符串(字节流),并将字节流写入以offset开始的buffer中.(buffer为可写的缓冲区,可用array模块)
unpack(fmt,v1,v2……) tuple 按照给定的格式(fmt)解析字节流,并返回解析结果
pack_from(fmt,buffer,offset) tuple 按照给定的格式(fmt)解析以offset开始的缓冲区,并返回解析结果
calcsize(fmt) size of fmt 计算给定的格式(fmt)占用多少字节的内存，注意对齐方式
格式化字符串
当打包或者解包的时,需要按照特定的方式来打包或者解包.该方式就是格式化字符串,它指定了数据类型,除此之外,还有用于控制字节顺序、大小和对齐方式的特殊字符.
对齐方式
为了同c中的结构体交换数据，还要考虑c或c&#43;&#43;编译器使用了字节对齐，通常是以4个字节为单位的32位系统，故而struct根据本地机器字节顺序转换.可以用格式中的第一个字符来改变对齐方式.定义如下
Character Byte order Size Alignment
@(默认) 本机 本机 本机,凑够4字节
= 本机 标准 none,按原字节数
&lt; 小端 标准 none,按原字节数
大端 标准 none,按原字节数
! network(大端) 标准 none,按原字节数
如果不懂大小端,见大小端参考网址.
格式符
格式符 C语言类型 Python类型 Standard size
x pad byte(填充字节) no value c char string of length 1 1" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/adf74cead1394f4543ceedf9bd1776c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-10T17:58:21+08:00" />
<meta property="article:modified_time" content="2023-10-10T17:58:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python之struct详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>用处</p> 
<pre><code>按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送;
按照指定格式将字节流转换为Python指定的数据类型;
处理二进制数据,如果用struct来处理文件的话,需要用’wb’,’rb’以二进制(字节流)写,读的方式来处理文件;
处理c语言中的结构体;
</code></pre> 
<p>struct模块中的函数<br> 函数 return explain<br> pack(fmt,v1,v2…) string 按照给定的格式(fmt),把数据转换成字符串(字节流),并将该字符串返回.<br> pack_into(fmt,buffer,offset,v1,v2…) None 按照给定的格式(fmt),将数据转换成字符串(字节流),并将字节流写入以offset开始的buffer中.(buffer为可写的缓冲区,可用array模块)<br> unpack(fmt,v1,v2……) tuple 按照给定的格式(fmt)解析字节流,并返回解析结果<br> pack_from(fmt,buffer,offset) tuple 按照给定的格式(fmt)解析以offset开始的缓冲区,并返回解析结果<br> calcsize(fmt) size of fmt 计算给定的格式(fmt)占用多少字节的内存，注意对齐方式<br> 格式化字符串</p> 
<p>当打包或者解包的时,需要按照特定的方式来打包或者解包.该方式就是格式化字符串,它指定了数据类型,除此之外,还有用于控制字节顺序、大小和对齐方式的特殊字符.<br> 对齐方式</p> 
<p>为了同c中的结构体交换数据，还要考虑c或c++编译器使用了字节对齐，通常是以4个字节为单位的32位系统，故而struct根据本地机器字节顺序转换.可以用格式中的第一个字符来改变对齐方式.定义如下<br> Character Byte order Size Alignment<br> @(默认) 本机 本机 本机,凑够4字节<br> = 本机 标准 none,按原字节数<br> &lt; 小端 标准 none,按原字节数</p> 
<blockquote> 
 <p>大端 标准 none,按原字节数<br> ! network(大端) 标准 none,按原字节数</p> 
</blockquote> 
<p>如果不懂大小端,见大小端参考网址.<br> 格式符<br> 格式符 C语言类型 Python类型 Standard size<br> x pad byte(填充字节) no value <br> c char string of length 1 1<br> b signed char integer 1<br> B unsigned char integer 1<br> ? _Bool bool 1<br> h short integer 2<br> H unsigned short integer 2<br> i int integer 4<br> I(大写的i) unsigned int integer 4<br> l(小写的L) long integer 4<br> L unsigned long long 4<br> q long long long 8<br> Q unsigned long long long 8<br> f float float 4<br> d double float 8<br> s char[] string <br> p char[] string <br> P void * long</p> 
<p>注- -!</p> 
<pre><code>_Bool在C99中定义,如果没有这个类型,则将这个类型视为char,一个字节;
q和Q只适用于64位机器;
每个格式前可以有一个数字,表示这个类型的个数,如s格式表示一定长度的字符串,4s表示长度为4的字符串;4i表示四个int;
P用来转换一个指针,其长度和计算机相关;
f和d的长度和计算机相关;
</code></pre> 
<p>进制转化:</p> 
<h2><a id="_59"></a>获取用户输入十进制数</h2> 
<p>dec = int(input(“输入数字：”))</p> 
<p>print(“十进制数为：”, dec)<br> print(“转换为二进制为：”, bin(dec))<br> print(“转换为八进制为：”, oct(dec))<br> print(“转换为十六进制为：”, hex(dec))</p> 
<pre><code>16进制转10进制: int('0x10', 16)  ==&gt;  16
</code></pre> 
<p>struct</p> 
<p>准确地讲，Python没有专门处理字节的数据类型。但由于b’str’可以表示字节，所以，字节数组＝二进制str。而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。</p> 
<p>在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的bytes，你得配合位运算符这么写：</p> 
<pre><code>&gt;&gt;&gt; n = 10240099
&gt;&gt;&gt; b1 = (n &amp; 0xff000000) &gt;&gt; 24
&gt;&gt;&gt; b2 = (n &amp; 0xff0000) &gt;&gt; 16
&gt;&gt;&gt; b3 = (n &amp; 0xff00) &gt;&gt; 8
&gt;&gt;&gt; b4 = n &amp; 0xff
&gt;&gt;&gt; bs = bytes([b1, b2, b3, b4])
&gt;&gt;&gt; bs
b'\x00\x9c@c'
</code></pre> 
<p>非常麻烦。如果换成浮点数就无能为力了。</p> 
<p>好在Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换。</p> 
<p>struct的pack函数把任意数据类型变成bytes：</p> 
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack('&gt;I', 10240099)
b'\x00\x9c@c'
</code></pre> 
<p>pack的第一个参数是处理指令，'&gt;I’的意思是：</p> 
<blockquote> 
 <p>表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。</p> 
</blockquote> 
<p>后面的参数个数要和处理指令一致。</p> 
<p>unpack把bytes变成相应的数据类型：</p> 
<pre><code>&gt;&gt;&gt; struct.unpack('&gt;IH', b'\xf0\xf0\xf0\xf0\x80\x80')
(4042322160, 32896)
</code></pre> 
<p>根据&gt;IH的说明，后面的bytes依次变为I：4字节无符号整数和H：2字节无符号整数。</p> 
<p>所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。</p> 
<p>struct模块定义的数据类型可以参考Python官方文档：</p> 
<p>https://docs.python.org/3/library/struct.html#format-characters</p> 
<p>Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用struct分析一下。</p> 
<p>首先找一个bmp文件，没有的话用“画图”画一个。</p> 
<p>读入前30个字节来分析：</p> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>s = b’\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00’</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>BMP格式采用小端方式存储数据，文件头的结构按顺序如下：</p> 
<p>两个字节：'BM’表示Windows位图，'BA’表示OS/2位图；一个4字节整数：表示位图大小；一个4字节整数：保留位，始终为0；一个4字节整数：实际图像的偏移量；一个4字节整数：Header的字节数；一个4字节整数：图像宽度；一个4字节整数：图像高度；一个2字节整数：始终为1；一个2字节整数：颜色数。</p> 
<p>所以，组合起来用unpack读取：</p> 
<pre><code>&gt;&gt;&gt; struct.unpack('&lt;ccIIIIIIHH', s)
(b'B', b'M', 691256, 0, 54, 40, 640, 360, 1, 24)
</code></pre> 
<p>结果显示，b’B’、b’M’说明是Windows位图，位图大小为640x360，颜色数为24。</p> 
<p>请编写一个bmpinfo.py，可以检查任意文件是否是位图文件，如果是，打印出图片大小和颜色数。</p> 
<pre><code># -*- coding: utf-8 -*-
 
import base64,struct
 
bmp_data = base64.b64decode('Qk1oAgAAAAAAADYAAAAoAAAAHAAAAAoAAAABABAAAAAAADICAAASCwAAEgsAAAAAAAAAAAAA/3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9/AHwAfAB8AHwAfAB8AHwAfP9//3//fwB8AHwAfAB8/3//f/9/AHwAfAB8AHz/f/9//3//f/9//38AfAB8AHwAfAB8AHwAfAB8AHz/f/9//38AfAB8/3//f/9//3//fwB8AHz/f/9//3//f/9//3//f/9/AHwAfP9//3//f/9/AHwAfP9//3//fwB8AHz/f/9//3//f/9/AHwAfP9//3//f/9//3//f/9//38AfAB8AHwAfAB8AHwAfP9//3//f/9/AHwAfP9//3//f/9//38AfAB8/3//f/9//3//f/9//3//fwB8AHwAfAB8AHwAfAB8/3//f/9//38AfAB8/3//f/9//3//fwB8AHz/f/9//3//f/9//3//f/9/AHwAfP9//3//f/9/AHwAfP9//3//fwB8AHz/f/9/AHz/f/9/AHwAfP9//38AfP9//3//f/9/AHwAfAB8AHwAfAB8AHwAfAB8/3//f/9/AHwAfP9//38AfAB8AHwAfAB8AHwAfAB8/3//f/9//38AfAB8AHwAfAB8AHwAfAB8/3//f/9/AHwAfAB8AHz/fwB8AHwAfAB8AHwAfAB8AHz/f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//38AAA==')
 
 
def bmp_info(data):
 
    str = struct.unpack('&lt;ccIIIIIIHH',data[:30]) #bytes类也有切片方法
 
 
    if str[0]==b'B' and str[1]==b'M':
 
        print("这是位图文件")
 
        return {
            'width': str[-4],
            'height': str[-3],
            'color': str[-1]
            }
 
    else:
 
        print("这不是位图文件")
 
 
if __name__ == '__main__':
    bmp_info(bmp_data)
    print('ok')
</code></pre> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>from struct import *<br> pack(‘hhl’, 1, 2, 3)<br> b’\x00\x01\x00\x02\x00\x00\x00\x03’<br> unpack(‘hhl’, b’\x00\x01\x00\x02\x00\x00\x00\x03’)<br> (1, 2, 3)<br> calcsize(‘hhl’)<br> 8</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>Unpacked fields can be named by assigning them to variables or by wrapping the result in a named tuple:</p> 
<blockquote> 
 <blockquote> 
  <blockquote></blockquote> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>record = b’raymond \x32\x12\x08\x01\x08’<br> name, serialnum, school, gradelevel = unpack(‘&lt;10sHHb’, record)</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>from collections import namedtuple<br> Student = namedtuple(‘Student’, ‘name serialnum school gradelevel’)<br> Student._make(unpack(‘&lt;10sHHb’, record))<br> Student(name=b’raymond ', serialnum=4658, school=264, gradelevel=8)</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>The ordering of format characters may have an impact on size since the padding needed to satisfy alignment requirements is different:</p> 
<blockquote> 
 <blockquote> 
  <blockquote></blockquote> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>pack(‘ci’, b’<em>‘, 0x12131415)<br> b’</em>\x00\x00\x00\x12\x13\x14\x15’<br> pack(‘ic’, 0x12131415, b’<em>‘)<br> b’\x12\x13\x14\x15</em>’<br> calcsize(‘ci’)<br> 8<br> calcsize(‘ic’)<br> 5</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>The following format ‘llh0l’ specifies two pad bytes at the end, assuming longs are aligned on 4-byte boundaries:</p> 
<blockquote> 
 <blockquote> 
  <blockquote></blockquote> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>pack(‘llh0l’, 1, 2, 3)<br> b’\x00\x00\x00\x01\x00\x00\x00\x02\x00\x03\x00\x00’</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>示例</p> 
<pre><code> 现在我们有了格式字符串，也知道了封装函数，那现在先通过一两个例子看一看。

  例一：比如有一个报文头部在C语言中是这样定义的

  struct header

  {

      unsigned short  usType;

      char[4]               acTag;

      unsigned int      uiVersion;

      unsigned int      uiLength;

  };

  在C语言对将该结构体封装到一块缓存中是很简单的，可以使用memcpy()实现。在Python中，使用struct就需要这样：

          str = struct.pack('B4sII', 0x04, 'aaaa', 0x01, 0x0e)

  'B4sII'  ------   有一个unsigned short、char[4], 2个unsigned int。其中s之前的数字说明了字符串的大小 。

          type, tag, version, length = struct.unpack('B4sll', str)
</code></pre> 
<p>class struct.Struct(format)</p> 
<p>返回一个struct对象（结构体，参考C）。</p> 
<p>该对象可以根据格式化字符串的格式来读写二进制数据。</p> 
<p>第一个参数（格式化字符串）可以指定字节的顺序。</p> 
<p>默认是根据系统来确定，也提供自定义的方式，只需要在前面加上特定字符即可：</p> 
<p>struct.Struct(‘&gt;I4sf’)</p> 
<p>特定字符对照表附件有。</p> 
<p>常见方法和属性：</p> 
<p>方法</p> 
<p>pack<br> (v1, v2, …)</p> 
<p>返回一个字节流对象。</p> 
<p>按照fmt（格式化字符串）的格式来打包参数v1,v2,…。</p> 
<p>通俗的说就是：</p> 
<p>首先将不同类型的数据对象放在一个“组”中（比如元组(1,‘good’,1.22)），</p> 
<p>然后打包（“组”转换为字节流对象），最后再解包（将字节流对象转换为“组”）。</p> 
<p>pack_into(buffer, offset, v1, v2, …)</p> 
<p>根据格式字符串fmt包装值v1，v2，…，并将打包的字节写入从位置偏移开始的可写缓冲buffer。 请注意，offset是必需的参数。</p> 
<p>unpack_from(buffer, offset=0)</p> 
<p>根据格式字符串fmt，从位置偏移开始从缓冲区解包。 结果是一个元组，即使它只包含一个项目。 缓冲区的大小（以字节为单位，减去偏移量）必须至少为格式所需的大小，如calcsize()所反映的。</p> 
<p>属性</p> 
<p>format</p> 
<p>格式化字符串。</p> 
<p>size</p> 
<p>结构体的大小。</p> 
<p>实例：</p> 
<p>1.通常的打包和解包<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17</p> 
<h2><a id="_coding_utf8__311"></a>-<em>- coding: utf-8 -</em>-</h2> 
<p>“” "<br> 打包和解包<br> “” "<br> import struct<br> import binascii</p> 
<p>values = (1, b ‘good’ , 1.22) #查看格式化对照表可知，字符串必须为字节流类型。<br> s = struct .Struct( ‘I4sf’ )<br> packed_data = s.pack(*values)<br> unpacked_data = s.unpack(packed_data)</p> 
<p>print( ‘Original values:’ , values)<br> print( ‘Format string :’ , s.format)<br> print( ‘Uses :’ , s.size, ‘bytes’ )<br> print( ‘Packed Value :’ , binascii.hexlify(packed_data))<br> print( ‘Unpacked Type :’ , type(unpacked_data), ’ Value:’ , unpacked_data)</p> 
<p>结果：</p> 
<p>Original values: (1, b’good’, 1.22)<br> Format string : b’I4sf’<br> Uses : 12 bytes<br> Packed Value : b’01000000676f6f64f6289c3f’<br> Unpacked Type : &lt;class ‘tuple’&gt; Value: (1, b’good’, 1.2200000286102295)<br> [Finished in 0.1s]</p> 
<p>说明：</p> 
<p>首先将数据对象放在了一个元组中，然后创建一个Struct对象，并使用pack()方法打包该元组；最后解包返回该元组。</p> 
<p>这里使用到了binascii.hexlify(data)函数。</p> 
<p>binascii.hexlify(data)</p> 
<p>返回字节流的十六进制字节流。</p> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7</p> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>a = ‘hello’<br> b = a.encode()<br> b<br> b ‘hello’<br> c = binascii.hexlify(b)<br> c<br> b ‘68656c6c6f’</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>2.使用buffer来进行打包和解包</p> 
<p>使用通常的方式来打包和解包会造成内存的浪费，所以python提供了buffer的方式：<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19</p> 
<h2><a id="_coding_utf8__394"></a>-<em>- coding: utf-8 -</em>-</h2> 
<p>“” "<br> 通过buffer方式打包和解包<br> “” "<br> import struct<br> import binascii<br> import ctypes</p> 
<p>values = (1, b ‘good’ , 1.22) #查看格式化字符串可知，字符串必须为字节流类型。<br> s = struct .Struct( ‘I4sf’ )<br> buff = ctypes.create_string_buffer(s.size)<br> packed_data = s.pack_into(buff,0,*values)<br> unpacked_data = s.unpack_from(buff,0)</p> 
<p>print( ‘Original values:’ , values)<br> print( ‘Format string :’ , s.format)<br> print( ‘buff :’ , buff)<br> print( ‘Packed Value :’ , binascii.hexlify(buff))<br> print( ‘Unpacked Type :’ , type(unpacked_data), ’ Value:’ , unpacked_data)</p> 
<p>结果：<br> 复制代码</p> 
<p>Original values1: (1, b’good’, 1.22)<br> Original values2: (b’hello’, True)<br> buff : &lt;ctypes.c_char_Array_18 object at 0x000000D5A5617348&gt;<br> Packed Value : b’01000000676f6f64f6289c3f68656c6c6f01’<br> Unpacked Type : &lt;class ‘tuple’&gt; Value: (1, b’good’, 1.2200000286102295)<br> Unpacked Type : &lt;class ‘tuple’&gt; Value: (b’hello’, True)<br> [Finished in 0.1s]</p> 
<p>复制代码</p> 
<p>说明：</p> 
<p>针对buff对象进行打包和解包，避免了内存的浪费。</p> 
<p>这里使用到了函数</p> 
<p>ctypes.create_string_buffer(init_or_size,size = None)</p> 
<p>创建可变字符缓冲区。<br> 返回的对象是c_char的ctypes数组。</p> 
<p>init_or_size必须是一个整数,它指定数组的大小,或者用于初始化数组项的字节对象。</p> 
<p>3.使用buffer方式来打包多个对象<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24</p> 
<h2><a id="_coding_utf8__466"></a>-<em>- coding: utf-8 -</em>-</h2> 
<p>“” "<br> buffer方式打包和解包多个对象<br> “” "<br> import struct<br> import binascii<br> import ctypes</p> 
<p>values1 = (1, b ‘good’ , 1.22) #查看格式化字符串可知，字符串必须为字节流类型。<br> values2 = (b ‘hello’ ,True)<br> s1 = struct .Struct( ‘I4sf’ )<br> s2 = struct .Struct( ‘5s?’ )<br> buff = ctypes.create_string_buffer(s1.size+s2.size)<br> packed_data_s1 = s1.pack_into(buff,0,*values1)<br> packed_data_s2 = s2.pack_into(buff,s1.size,*values2)<br> unpacked_data_s1 = s1.unpack_from(buff,0)<br> unpacked_data_s2 = s2.unpack_from(buff,s1.size)</p> 
<p>print( ‘Original values1:’ , values1)<br> print( ‘Original values2:’ , values2)<br> print( ‘buff :’ , buff)<br> print( ‘Packed Value :’ , binascii.hexlify(buff))<br> print( ‘Unpacked Type :’ , type(unpacked_data_s1), ’ Value:’ , unpacked_data_s1)<br> print( ‘Unpacked Type :’ , type(unpacked_data_s2), ’ Value:’ , unpacked_data_s2)</p> 
<p>结果：</p> 
<p>Original values2: (b’hello’, True)<br> buff : &lt;ctypes.c_char_Array_18 object at 0x000000D5A5617348&gt;<br> Packed Value : b’01000000676f6f64f6289c3f68656c6c6f01’<br> Unpacked Type : &lt;class ‘tuple’&gt; Value: (1, b’good’, 1.2200000286102295)<br> Unpacked Type : &lt;class ‘tuple’&gt; Value: (b’hello’, True)<br> [Finished in 0.1s]<br> ————————————————<br> 版权声明：本文为CSDN博主「醉小义」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/qq_30638831/article/details/80421019</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1cab58c1c13e05fbe3f661d431d8e478/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Factorial 函数求阶乘的详细代码以及所用知识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc0839f7c9d0da6d08b62e8b28993c31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">获取地理相关数据应该知道的方法（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>