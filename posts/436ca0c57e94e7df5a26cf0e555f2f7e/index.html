<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>最长单调递增子序列的三种解法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="最长单调递增子序列的三种解法" />
<meta property="og:description" content="从报名蓝桥杯开始我就觉得我走入了一条及其坑的路。
从大一到大三我写过的代码，思考过的算法真是少之又少，一个动态规划我依旧没有吃透，真的是觉得好有挫败感。不过还好，一点点来。
既然知道自己要去做这件事情，就认真去做吧。就算开始的比较晚但是能学到东西就很好。
这是转载自爱天涯技术论坛。http://qiemengdao.iteye.com/blog/1660229
解释部分是人家的，代码是我自己又写了一遍的，加深理解吧算是。觉得自己学习能力真的是有待加强。
问题 给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为6的数组A{5， 6， 7， 1， 2， 8}，则其最长的单调递增子序列为{5，6，7，8}，长度为4.
解法1：最长公共子序列法 这个问题可以转换为最长公共子序列问题。如例子中的数组A{5，6， 7， 1， 2， 8}，则我们排序该数组得到数组A‘{1， 2， 5， 6， 7， 8}，然后找出数组A和A’的最长公共子序列即可。显然这里最长公共子序列为{5, 6, 7, 8}，也就是原数组A最长递增子序列。最长公共子序列算法在算法导论上有详细讲解，这里简略说下思想。
假定两个序列为X={x1, x2, ..., xm}和Y={y1, y2, ..., yn)，并设Z={z1, z2, ..., zk}为X和Y的任意一个LCS。
1）如果xm = yn，则zk = xm=yn，且Zk-1是Xm-1和Yn-1的一个LCS。
2）如果xm != yn, 则zk != xm蕴含Z是Xm-1和Y得一个LCS。
3）如果xm != yn, 则zk != yn蕴含Z是X和Yn-1的一个LCS。
这个方法我记得原来老师讲过，但是都忘记怎么实现了。今天先放在这里，立个flag，后期补充上。
解法2：动态规划法（时间复杂度O(N^2)) 设长度为N的数组为{a0，a1, a2, ...an-1)，则假定以ai结尾的数组序列的最长递增子序列长度为L(i)，则L(i)={ max(L(j))&#43;1, j&lt;i且a[j]&lt;a[i] }。也就是说，我们需要遍历在i之前的所有位置j(从0到i-1)，找出满足条件a[j]&lt;a[i]的L(j)，求出max(L(j))&#43;1即为L(j)的值。最后，我们遍历所有的L(i)（从0到N-1），找出最大值即为最大递增子序列。时间复杂度为O(N^2)。
例如给定的数组为{5，6，7，1，2，8}，则L(0)=1, L(1)=2, L(2)=3, L(3)=1, L(4)=2, L(5)=4。所以该数组最长递增子序列长度为4，序列为{5，6，7，8}。算法代码如下：
#include&lt;iostream&gt;
#include&lt;algorithm&gt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/436ca0c57e94e7df5a26cf0e555f2f7e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-26T14:34:14+08:00" />
<meta property="article:modified_time" content="2017-02-26T14:34:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">最长单调递增子序列的三种解法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><br> <span style="color:#FF6666">从报名蓝桥杯开始我就觉得我走入了一条及其坑的路。</span></p> 
<p><span style="color:#FF6666"><br> 从大一到大三我写过的代码，思考过的算法真是少之又少，一个动态规划我依旧没有吃透，真的是觉得好有挫败感。不过还好，一点点来。</span></p> 
<p><span style="color:#FF6666"><br> 既然知道自己要去做这件事情，就认真去做吧。就算开始的比较晚但是能学到东西就很好。</span></p> 
<p><span style="color:#FF6666"><br> </span></p> 
<p><span style="color:#FF6666">这是转载自爱天涯技术论坛。http://qiemengdao.iteye.com/blog/1660229</span></p> 
<p><span style="color:#FF6666"><br> </span></p> 
<p><span style="color:#FF6666">解释部分是人家的，代码是我自己又写了一遍的，加深理解吧算是。觉得自己学习能力真的是有待加强。</span><br> </p> 
<p><br> </p> 
<p></p> 
<h3>问题</h3> 
<p></p> 
<p>给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为6的数组A{5， 6， 7， 1， 2， 8}，则其最长的单调递增子序列为{5，6，7，8}，长度为4.</p> 
<h3>解法1：最长公共子序列法</h3> 
<p>这个问题可以转换为最长公共子序列问题。如例子中的数组A{5，6， 7， 1， 2， 8}，则我们排序该数组得到数组A‘{1， 2， 5， 6， 7， 8}，然后找出数组A和A’的最长公共子序列即可。显然这里最长公共子序列为{5, 6, 7, 8}，也就是原数组A最长递增子序列。最长公共子序列算法在算法导论上有详细讲解，这里简略说下思想。</p> 
<p>假定两个序列为X={x1, x2, ..., xm}和Y={y1, y2, ..., yn)，并设Z={z1, z2, ..., zk}为X和Y的任意一个LCS。</p> 
<p>1）如果xm = yn，则zk = xm=yn，且Zk-1是Xm-1和Yn-1的一个LCS。</p> 
<p>2）如果xm != yn, 则zk != xm蕴含Z是Xm-1和Y得一个LCS。</p> 
<p>3）如果xm != yn, 则zk != yn蕴含Z是X和Yn-1的一个LCS。</p> 
<p><img alt="" src="https://images2.imgbox.com/05/8d/kdm1CI8c_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/9a/e2/1uf6hhdZ_o.png"></p> 
<p><br> </p> 
<p><strong>这个方法我记得原来老师讲过，但是都忘记怎么实现了。今天先放在这里，立个flag，后期补充上。</strong><br> </p> 
<h3>解法2：动态规划法（时间复杂度O(N^2))</h3> 
<p>设长度为N的数组为{a0，a1, a2, ...an-1)，则假定以ai结尾的数组序列的最长递增子序列长度为L(i)，则L(i)={ max(L(j))+1, j&lt;i且a[j]&lt;a[i] }。也就是说，我们需要遍历在i之前的所有位置j(从0到i-1)，找出满足条件a[j]&lt;a[i]的L(j)，求出max(L(j))+1即为L(j)的值。最后，我们遍历所有的L(i)（从0到N-1），找出最大值即为最大递增子序列。时间复杂度为O(N^2)。</p> 
<p>例如给定的数组为{5，6，7，1，2，8}，则L(0)=1, L(1)=2, L(2)=3, L(3)=1, L(4)=2, L(5)=4。所以该数组最长递增子序列长度为4，序列为{5，6，7，8}。算法代码如下：</p> 
<p>#include&lt;iostream&gt;<br> #include&lt;algorithm&gt;<br> #include&lt;cstring&gt;<br> using namespace std;<br> char array[10001];<br> int MaxLen[10001];<br> //最长单调递增子序列，解法一<br> void LIS (){<!-- --><br>     memset(MaxLen,0,sizeof(MaxLen));   //将Maxlen数组初始化为0<br>     int len = strlen(array);  //求出字符串长度<br>     for(int i=0;i&lt;len;i++){<!-- --><br>         MaxLen[i]= 1;<br>         //通过两步判断实现对最长子序列的查找<br>         for(int j=0;j&lt;i;j++){<!-- --><br>             if(array[i]&gt;array[j]&amp;&amp;MaxLen[i]&lt;1+MaxLen[j]){<!-- --><br> <br>                     MaxLen[i]= 1+MaxLen[j];<br> <br>             }<br>         }<br>     }<br> }<br> //Max存储以array[i]为末尾元素的LIS 的长度，所以max数组的最大值即array的lis长度<br> int main ()<br> {<!-- --><br>     int N,i,len,Max;<br>     cin&gt;&gt;N;<br>     while(N--)<br>     {<!-- --><br>         Max =0;<br>         cin&gt;&gt;array;<br>         LIS();<br>         //通过循环查找其最大值<br>         len = strlen(array);<br>         for(i=0;i&lt;len;i++)<br>         {<!-- --><br>             if(Max &lt; MaxLen[i]){<!-- --><br>                 Max = MaxLen[i];<br>             }<br>         }<br>         cout&lt;&lt;Max&lt;&lt;endl;<br>     }<br>     return 0;<br> }<br> <br> <br> </p> 
<br> 这个代码是一个让我比较容易理解的代码。他就是很严格的按照动态规划的要求，有状态和状态转移方程。 
<p>状态是L[i]，它的下标和字符串的下标一样，代表的是若该字符是最长递增子序列的最后一个字符，那么序列的长度就是L[i]。</p> 
<p>那么L[i]的数值如何确定呢？    则是由状态转移方程来进行这个完成工作的。</p> 
<p>两个循环，下标 i 前面的字符是否小于这个字符，若小于且L[j]+1&gt;L[i]，则L[i] = L[j]+1；</p> 
<p><br> </p> 
<p>但是这种方法有一个问题，不能输出该序列。因为没有存储。</p> 
<p><br> </p> 
<p></p> 
<h3>解法3：O(NlgN）算法</h3> 
<p></p> 
<p>假设存在一个序列d[1..9] ={ 2，1 ，5 ，3 ，6，4， 8 ，9， 7}，可以看出来它的LIS长度为5。<br> 下面一步一步试着找出它。<br> 我们定义一个序列B，然后令 i = 1 to 9 逐个考察这个序列。<br> 此外，我们用一个变量Len来记录现在最长算到多少了<br> <br> 首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1<br> <br> 然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1<br> <br> 接着，d[3] = 5，d[3]&gt;B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] = 1, 5，Len＝2<br> <br> 再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2<br> <br> 继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。<br> <br> 第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3<br> <br> 第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了<br> <br> 第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。<br> <br> 最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。<br> <br> 于是我们知道了LIS的长度为5。<br> <br> <strong>注意，这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。</strong>有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。<br> <br> 然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)~~~~~于是算法的时间复杂度就降低到了O(NlogN)～！</p> 
<p>代码如下（代码中的数组B从位置0开始存数据）：</p> 
<p>#include&lt;iostream&gt;<br> #include&lt;algorithm&gt;<br> #include&lt;cstring&gt;<br> using namespace std;<br> char array[10001];<br> char b[10001];<br> //最长单调递增子序列<br> int BiSearch(int len,char w)<br> {<!-- --><br>     int left =0,right = len-1;<br>     int mid;<br>     while(left&lt;=right){<!-- --><br>         mid = left +(right-left)/2;<br>         if(b[mid]&gt;w)<br>         {<!-- --><br>             right = mid -1;<br>         }<br>         else if(b[mid]&lt;w)<br>         {<!-- --><br>             left = mid +1;<br>         }<br>         else<br>             return mid;<br>     }<br>     return left;<br> }<br> int LIS (int n){<!-- --><br>     int len =1;    //表示b数组的长度<br>     b[0]=array[0];<br>     int i,pos=0;<br>     for(i=1;i&lt;n;++i){<!-- --><br>         if(array[i]&gt;b[len-1])<br>         {<!-- --><br>             b[len]=array[i];<br>             ++len;<br>         }<br>         else<br>         {<!-- --><br>             pos= BiSearch(len,array[i]);<br>             b[pos]= array[i];<br>         }<br>     }<br>     return len;<br> }<br> <br> //Max存储以array[i]为末尾元素的LIS 的长度，所以max数组的最大值即array的lis长度<br> int main ()<br> {<!-- --><br>     int N,i,len,Max;<br>     cin&gt;&gt;N;<br>     while(N--)<br>     {<!-- --><br>         Max =0;<br>         cin&gt;&gt;array;<br>         len = strlen(array);<br>         Max=LIS(len);<br>         cout&lt;&lt;Max&lt;&lt;endl;<br>         //通过循环查找其最大值<br>         for(int i=0;i&lt;Max;i++){<!-- --><br>             cout&lt;&lt;b[i];<br>         }<br>         cout&lt;&lt;endl;<br>     }<br>     return 0;<br> }<br> <br> </p> 
<p>我喜欢这个解法，这个解法觉得很清楚。</p> 
<p>用len记录b数组的长度，而且b数组还是记录的序列的内容。</p> 
<p>这真是极好的。<br> </p> 
<br> 
<p><br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/358c5019fd80e0332678421a5c9a8acd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于C语言的malloc函数以及内存泄漏的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/509447324c398f9e52a867649250978c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">学习OpenCV(4) 基于OpenCV的双目测距程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>