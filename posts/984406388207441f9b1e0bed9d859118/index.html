<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>1.《剑指Java面试-Offer直通车》--计算机网络 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="1.《剑指Java面试-Offer直通车》--计算机网络" />
<meta property="og:description" content="计算机网络
1. 物理层【传输比特流 模数/数模 网卡】
2. 链路层【封装成帧 SOH EOT、透明传输 增加转义字符、 差错检查 cro循环冗余】
3. 网络层【路由器的分组交换，有个转发表，知道下一条的路有】【MTU 】
————物理地址是数据链路层和物理层使用的地址。主机或者路由器收到MAC帧后，根据硬件地址决定是否需要接受
————ARP：高速缓存。广播出，单播回
4. 传输层【为应用进程提供通信】
5. 会话层
6. 表示层
7. 应用层
8. TCP【MSS 536】
————TCP和UDP在发送报文时，所采用的方式完全不同。TCP不关心应用进程一次把多长的报文发送到TCP缓存中，而是根据对方给出的窗口值和当前网络拥塞来决定一个报文段应该包含多少字节；UDP发送的报文长度是应用进程决定的，如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些再传送。如果应用进程一次只发送一个字节，TCP也可以等待累积足够多字节后再传送
————TCP下层网络提供的是不可靠的传输。因此：TCP必须采用适当的措施才能变得可靠【理想传输条件有两个特点：1. 传输信道不产生差错2. 不管发送方多快的发送数据，接收方总是来得及处理收到的数据 ————停止等待、连续ARQ、滑动窗口流量控制（让发送方发送的不要太快，接收方来得及接受）、Nagle算法、拥塞控制算法【慢开始、快重传（让发送方尽早知道个别报文段的丢失）】
————三次握手：【SYN、ACK CLOSED-》SYN_SENT-》LISTEN-》SYN_RECVED-》ESTABLISTED】【三次握手也可以变成四次握手】【保证数据序列正确、为了防止失效的报文浪费资源】
————SERVER没有收到三次握手的最后一次（SERVER会不断重试直到超时，Linux默认等待63s后超时） SYN FLOOD攻击：SYN队列满后，通过tcp_syncookies回发SYNC—COOKIE
————三次握手后，客户端故障，服务端触发保活机制【向对方发送保活探测包，如果未收到响应则继续发送，一定次数后中断】
————四次挥手：【FIN_WAIT-1、CLOSE_WAIT、FIN_WAIT2、LAST_ACK、TIME_WAIT】 2msl原因: 最后ack可以有效到达、本次连接相关的请求都可以在网络中消失
9. keep-alive
————Connection: keep-alive。【指定时间或者达到最大连接数就会断开】
————Transfer-Encoding - 分块传输和Content-Length【服务端和客户单都保持长链接，那么客户端如何知道此刻已经响应完成了呢？】有时候响应体长度不好获取
10. cookie. session
————用来跟踪浏览器用户身份的会话方式。cookie数据保存在客户端，session数据保存在服务端
11. Https
————什么是安全？A与B通信的内容，有且只有AB能看到通信的真正内容
————使用非对称加密算法对对称加密算法协商【为了不让对称加密算法被第三者知道。所以使用了随机数】
————使用非对称加密算法，服务器端发送公钥给客户端时，被中间人调包了，怎么办？【中间人攻击，无法确认返回公钥的是中间人还是真实的人。密码学的身份验证问题】——使用第三方机构的公钥
【所以，我们不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。】
————数字证书&#43;数字签名 【XX.com 非对称公钥 md5】-》编码【第三方机构siyao加密】
一、网络基础知识讲解 OSI开放式互联参考模型 第1层 物理层
首先解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到比特流。
主要作用是传输比特流（0101二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。这层数据叫做比特。网卡工作在这层。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/984406388207441f9b1e0bed9d859118/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-21T19:58:35+08:00" />
<meta property="article:modified_time" content="2022-02-21T19:58:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">1.《剑指Java面试-Offer直通车》--计算机网络</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>计算机网络<br> 1. 物理层【传输比特流 模数/数模 网卡】<br> 2. 链路层【封装成帧 SOH EOT、透明传输 增加转义字符、 差错检查 cro循环冗余】<br> 3. 网络层【路由器的分组交换，有个转发表，知道下一条的路有】【MTU 】<br> ————物理地址是数据链路层和物理层使用的地址。主机或者路由器收到MAC帧后，根据硬件地址决定是否需要接受<br> ————ARP：高速缓存。广播出，单播回<br> 4. 传输层【为应用进程提供通信】<br> 5. 会话层<br> 6. 表示层<br> 7. 应用层<br> 8. TCP【MSS 536】<br> ————TCP和UDP在发送报文时，所采用的方式完全不同。TCP不关心应用进程一次把多长的报文发送到TCP缓存中，而是根据对方给出的窗口值和当前网络拥塞来决定一个报文段应该包含多少字节；UDP发送的报文长度是应用进程决定的，如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些再传送。如果应用进程一次只发送一个字节，TCP也可以等待累积足够多字节后再传送<br> ————TCP下层网络提供的是不可靠的传输。因此：TCP必须采用适当的措施才能变得可靠【理想传输条件有两个特点：1. 传输信道不产生差错2. 不管发送方多快的发送数据，接收方总是来得及处理收到的数据 <br> ————停止等待、连续ARQ、滑动窗口流量控制（让发送方发送的不要太快，接收方来得及接受）、Nagle算法、拥塞控制算法【慢开始、快重传（让发送方尽早知道个别报文段的丢失）】<br> ————三次握手：【SYN、ACK CLOSED-》SYN_SENT-》LISTEN-》SYN_RECVED-》ESTABLISTED】【三次握手也可以变成四次握手】【保证数据序列正确、为了防止失效的报文浪费资源】<br> ————SERVER没有收到三次握手的最后一次（SERVER会不断重试直到超时，Linux默认等待63s后超时）   SYN FLOOD攻击：SYN队列满后，通过tcp_syncookies回发SYNC—COOKIE<br> ————三次握手后，客户端故障，服务端触发保活机制【向对方发送保活探测包，如果未收到响应则继续发送，一定次数后中断】<br> ————四次挥手：【FIN_WAIT-1、CLOSE_WAIT、FIN_WAIT2、LAST_ACK、TIME_WAIT】 2msl原因: 最后ack可以有效到达、本次连接相关的请求都可以在网络中消失<br> 9. keep-alive<br> ————Connection: keep-alive。【指定时间或者达到最大连接数就会断开】<br> ————Transfer-Encoding - 分块传输和Content-Length【服务端和客户单都保持长链接，那么客户端如何知道此刻已经响应完成了呢？】有时候响应体长度不好获取<br> 10. cookie. session<br> ————用来跟踪浏览器用户身份的会话方式。cookie数据保存在客户端，session数据保存在服务端<br> 11. Https<br> ————什么是安全？A与B通信的内容，有且只有AB能看到通信的真正内容<br> ————使用非对称加密算法对对称加密算法协商【为了不让对称加密算法被第三者知道。所以使用了随机数】<br> ————使用非对称加密算法，服务器端发送公钥给客户端时，被中间人调包了，怎么办？【中间人攻击，无法确认返回公钥的是中间人还是真实的人。密码学的身份验证问题】——使用第三方机构的公钥<br>     【所以，我们不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。】<br> ————数字证书+数字签名 【XX.com 非对称公钥 md5】-》编码【第三方机构siyao加密】<br>  </p> 
</blockquote> 
<h2>一、网络基础知识讲解</h2> 
<ul><li> <h3 id="OSI%E5%BC%80%E6%94%BE%E5%BC%8F%E4%BA%92%E8%81%94%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><a name="t1"></a>OSI开放式互联参考模型</h3> </li></ul> 
<p><img alt="" src="https://images2.imgbox.com/d5/c7/tBW1Am1W_o.png"></p> 
<p><strong>第1层 物理层</strong></p> 
<p>首先解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到比特流。</p> 
<p>主要作用是传输比特流（0101二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。这层数据叫做比特。网卡工作在这层。</p> 
<p><strong>第2层 数据链路层</strong></p> 
<p>【封装成帧、透明传输、差错检测】</p> 
<p>封装成帧：在数据前后添加首部和尾部，使用帧定界符。（SOH、EOT），数据部分小等于MTU</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/59/58/WgizXbvO_o.png" width="477"></p> 
<p></p> 
<p>透明传输：为了避免中数据中非法包含SOH、EOT等特殊字符，链路层需要给特殊字符前增加转义字符   <img alt="" height="648" src="https://images2.imgbox.com/9e/91/lRQeiusU_o.png" width="1200"></p> 
<p></p> 
<p>差错检测：比特在传输过程中可能会出现1-》0，0-》1的差错，采用循环冗余检验（CRC）检错技术。<img alt="" height="424" src="https://images2.imgbox.com/18/8b/84uCM5X5_o.png" width="1200"></p> 
<p><img alt="" height="319" src="https://images2.imgbox.com/4a/d1/U6YkZslz_o.png" width="439"></p> 
<p><strong>第3层 网络层</strong></p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/01/88/Hqggy2no_o.png" width="1200"></p> 
<p><img alt="" height="744" src="https://images2.imgbox.com/dd/f7/1w6H5wiF_o.png" width="1108"></p> 
<p>从层次角度看：物理地址是数据链路层和物理层使用的地址，而IP层是网络层和以上各层使用的地址，是一种逻辑地址。</p> 
<p>使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧了。【MAC帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在MAC帧首部中】 </p> 
<blockquote> 
 <p><img alt="" height="136" src="https://images2.imgbox.com/25/bf/Gr9GYGpA_o.png" width="1196"></p> 
 <p><img alt="" height="510" src="https://images2.imgbox.com/4d/fa/91hAfCCL_o.png" width="1200"><img alt="" height="722" src="https://images2.imgbox.com/02/04/24PG47cS_o.png" width="1118"> <img alt="" height="1072" src="https://images2.imgbox.com/ce/9a/9ux9lBgs_o.png" width="938"></p> 
</blockquote> 
<blockquote> 
 <p>ARP：根据IP地址找出硬件地址【在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或者超时删除）】，如果ARP高速缓存中找不到，那么会广播请求，单播收到回复。。。。请注意：ARP是解决同一局域网上的主机或路由器的IP地址和硬件地址的映射问题</p> 
 <p></p> 
 <p>路由器有转发表，可以知道下一跳路由器</p> 
 <p>网络层：IP数据报有个字段叫做：首部校验和。只检验首部，不包括数据部分</p> 
</blockquote> 
<p></p> 
<p><strong>第4层 传输层</strong></p> 
<blockquote> 
 <p>为什么需要传输层？</p> 
 <p>网络层为主机之间提供逻辑通信。而运输层为应用进程之间提供端到端的逻辑通信</p> 
</blockquote> 
<blockquote> 
 <p>运输层：需要对收到的报文进行差错检测</p> 
 <p>TCP：传输控制协议（Transmission Control Protocol）</p> 
 <p>UDP：用户数据报协议（User Datagram Protocol）</p> 
</blockquote> 
<p></p> 
<p><strong>第5层 会话层</strong></p> 
<p>自动收发包，自动寻址。</p> 
<p>会话层作用是建立和管理应用程序间的通信。</p> 
<p><strong>第6层 表示层</strong></p> 
<p>Linux给WIndows发包，不同系统语法不一致，如exe不能在Linux下执行，shell不能在Windows不能直接运行。于是需要表示层。</p> 
<p>解决不同系统之间通信语法问题，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。</p> 
<p><strong>第7层 应用层</strong></p> 
<p>规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。应用层旨在更方便应用从网络中接收的数据，重点关注TCP/IP协议中的HTTP协议。</p> 
<p><img alt="" src="https://images2.imgbox.com/dd/78/MSXroPLE_o.png"></p> 
<p><img alt="" height="880" src="https://images2.imgbox.com/23/55/S06IJnJU_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h2>二、TCP三次握手</h2> 
<p>IP负责将每个包路由至目的地。IP协议没有确认包是否按顺序发送，或包是否被破环，因此IP数据包是不可靠的。需要它的上层协议做出控制。</p> 
<ul><li> <h3 id="%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP%E7%AE%80%E4%BB%8B">传输控制协议TCP简介</h3> </li></ul> 
<p>1）面向连接的、可靠的、基于字节流的传输层通信协议</p> 
<p>2）将应用层的数据流分割成报文段并发送给目标节点的TCP层</p> 
<p>3）数据包都有序号，对方收到则发送ACK确认，未收到则重传</p> 
<p>4）使用校验和来检验数据在传输过程中是否有误</p> 
<blockquote> 
 <p>应用层向TCP层发送数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元MTU的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认ACK；如果发送端实体在合理的往返时延RTT内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p> 
</blockquote> 
<blockquote> 
 <p><img alt="" height="662" src="https://images2.imgbox.com/4a/18/Uz81UYPY_o.png" width="1200"></p> 
 <p>TCP和UDP在发送报文时，所采用的方式完全不同。TCP不关心应用进程一次把多长的报文发送到TCP缓存中，而是根据对方给出的窗口值和当前网络拥塞来决定一个报文段应该包含多少字节；UDP发送的报文长度是应用进程决定的</p> 
 <p>如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些再传送。如果应用进程一次只发送一个字节，TCP也可以等待累积足够多字节后再传送</p> 
 <p></p> 
</blockquote> 
<blockquote> 
 <p>TCP下层网络提供的是不可靠的传输。因此：TCP必须采用适当的措施才能变得可靠</p> 
 <p>理想传输条件有两个特点：<br> 1. 传输信道不产生差错</p> 
 <p>2. 不管发送方多快的发送数据，接收方总是来得及处理收到的数据 </p> 
 <p></p> 
 <p>停止等待协议、连续ARQ协议、</p> 
 <p>注：TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段 【首部+数据】</p> 
 <p><img alt="" height="369" src="https://images2.imgbox.com/54/1b/HiNA4gTL_o.png" width="526"><br> 端口：两个进程在计算机内部进行通信，有管道、内存共享、信号量、消息队列等方法。两个进程通信最基本的前提是唯一标识一个进程，通过唯一标识找到对应的进程。在本地进程通信中可以通过pid，但pid只在本地唯一。如果把两个进程放到两台计算机通信，pid实现不了。解决这个问题的方法就是在传输层使用协议端口号，简称端口。IP地址可以唯一标识主机，TCP协议和端口号可以唯一标识主机中的一个进程，利用IP地址+协议+端口号唯一标识去标识网络中的一个进程，这种唯一标识的模式称为Socket。</p> 
</blockquote> 
<blockquote> 
 <p>seq序号：占4字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如：一段报文的序号字段值是107，携带的数据是100个字段，下一个报文段序号从107+100=207开始。</p> 
 <p>ack确认号：4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如：B收到A发送的报文，其序号字段是301，数据长度是200字节，表明B正确收到A发送的到序号500为止的数据（301+200-1=500），B期望收到A下一个数据序号是501。B发送给A的确认报文段中把ack确认号置为501。</p> 
 <p>数据偏移：TCP报文的首部长度</p> 
 <p>保留：保留今后使用的，被标为1。</p> 
 <p>控制位：由8个标志位组成。每个标志位表示一个控制功能。</p> 
 <p>其中主要的6个：</p> 
 <p>URG紧急指针标志，为1表示紧急指针有效，为0忽略紧急指针。</p> 
 <p>ACK确认序号标志，为1表示确认号有效，为0表示报文不含确认信息，忽略确认号字段。上面的确认号是否有效就是通过该标识控制的。</p> 
 <p>PSHpush标志，为1表示带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将该报文段交给应用程序，而不是在缓冲区排队。</p> 
 <p>RST重置连接标志，重置因为主机崩溃或其他原因而出现错误的连接，或用于拒绝非法的报文段或非法的连接。</p> 
 <p>SYN同步序号，用于建立连接过程，在连接请求中SYN=1和ACK=0表示该数据段没有使用捎带的确认域，连接应答捎带一个确认即SYN=1和ACK=1。</p> 
 <p>FIN终止标志，用于释放连接，为1时表示发送方没有发送了。</p> 
 <p>窗口：滑动窗口大小，用来告知发送端接收端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。</p> 
 <p>校验和：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。</p> 
 <p>紧急指针：只有控制位中的URG为1时才有效。指出本报文段中的紧急数据的字节数。</p> 
 <p>选项：其长度可变，定义其他的可选参数。【最长可达40字节】，当没有使用选项时，TCP的首部长度是20字节。</p> 
 <p>最大报文长度MSS【Maximum Segment Size】：是每一个TCP报文段中的数据字段的最大长度</p> 
 <p><img alt="" height="752" src="https://images2.imgbox.com/00/6d/YDk70oAh_o.png" width="1200"></p> 
 <p></p> 
 <p>TCP流量控制。利用滑动窗口实现流量控制</p> 
 <p><img alt="" height="766" src="https://images2.imgbox.com/f4/0f/4ZTrg9WD_o.png" width="1196"> <img alt="" height="368" src="https://images2.imgbox.com/53/e4/iWNY8Do5_o.png" width="1200"></p> 
 <p>拥塞控制算法</p> 
 <p><img alt="" height="928" src="https://images2.imgbox.com/e4/6d/ZHokqFAY_o.png" width="1070"> <img alt="" height="1032" src="https://images2.imgbox.com/83/f2/0c5fMC2G_o.png" width="942"></p> 
 <p></p> 
 <p></p> 
 <p></p> 
</blockquote> 
<h3>TCP三次握手</h3> 
<p><br> 当应用程序希望通过TCP与另一个应用程序通信时，会发送一个通信请求，这个请求必须发送到一个确切的地址，双方握手之后，TCP建立一个全双工的通信（计算机A能给B发送信息，在发送信息的同时B也能给A回发信息。半双工通信：双向交替通信，即通信的双方都可以发送信息，但不能双方同时发送和接收），这个通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。握手即为TCP三次握手。</p> 
<p><img alt="" height="620" src="https://images2.imgbox.com/5e/ba/5yaCn8d6_o.png" width="1146"></p> 
<p><img alt="" height="992" src="https://images2.imgbox.com/c6/df/VslXU7IN_o.png" width="906"> <img alt="" height="344" src="https://images2.imgbox.com/7f/a5/duUPk2O1_o.png" width="1200"></p> 
<p><img alt="" height="772" src="https://images2.imgbox.com/f6/d3/TmLI4H8h_o.png" width="1200"></p> 
<p><img alt="" height="730" src="https://images2.imgbox.com/b0/ce/IL57DnrL_o.png" width="1200"></p> 
<p><img alt="" height="718" src="https://images2.imgbox.com/58/5a/aWzXxh3Y_o.png" width="1200"></p> 
<h2> TCP四次挥手</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/6d/b3/ZdEeTH6D_o.png" width="998"></p> 
<p><img alt="" height="1162" src="https://images2.imgbox.com/71/3a/JVXRKxd5_o.png" width="1100"> <img alt="" height="454" src="https://images2.imgbox.com/03/8a/QMjpuSnk_o.png" width="1200"></p> 
<p> <img alt="" height="784" src="https://images2.imgbox.com/a3/07/ffpA0vAK_o.png" width="1200"></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/cd/ab/2FRhKNBc_o.png" width="1200"></p> 
<h2>UDP的理解：</h2> 
<p><img alt="" height="269" src="https://images2.imgbox.com/d3/63/KuCNK3X2_o.png" width="461"></p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/58/a7/XSLjKEPW_o.png" width="380"></p> 
<p><img alt="" height="340" src="https://images2.imgbox.com/3c/9e/3eeSkubh_o.png" width="537"></p> 
<p></p> 
<p> TCP的滑动窗口<br><img alt="" height="848" src="https://images2.imgbox.com/78/17/MHnJVegi_o.png" width="1200"><img alt="" height="1200" src="https://images2.imgbox.com/15/ee/Y3vW229h_o.png" width="1200"></p> 
<p><a href="https://blog.csdn.net/kexuanxiu1163/article/details/107148025/?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=tcp%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-107148025.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187" title="TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？_程序员吴师兄的博客-CSDN博客">TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？_程序员吴师兄的博客-CSDN博客</a></p> 
<h2>HTTP相关<br><img alt="" height="1184" src="https://images2.imgbox.com/d6/59/FHDUJWRp_o.png" width="1200"></h2> 
<ul><li> <h3 id="Http1.0%201.1%202.0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">Http1.0 1.1 2.0的区别？</h3> </li></ul> 
<p>参考:<a href="https://blog.csdn.net/xiaoduanayu/article/details/78386508?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164181976216780255229970%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164181976216780255229970&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78386508.first_rank_v2_pc_rank_v29&amp;utm_term=http+keepalive&amp;spm=1018.2226.3001.4187" title="HTTP keep-alive详解_海为龙世界，云是鹤家乡-CSDN博客_keep-alive">HTTP keep-alive详解_海为龙世界，云是鹤家乡-CSDN博客_keep-alive</a></p> 
<ul><li> <h3 id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%EF%BC%88Request%EF%BC%89">客户端请求消息（Request）</h3> </li></ul> 
<p>客户端发送一个HTTP请求到服务器的请求消息结构如下:</p> 
<p><img alt="" src="https://images2.imgbox.com/50/2a/CtTrvSGV_o.png"></p> 
<ul><li> <h3 id="%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E9%94%AE%E5%85%A5URL%EF%BC%8C%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E7%BB%8F%E5%8E%86%E7%9A%84%E6%B5%81%E7%A8%8B">在浏览器地址栏键入URL，按下回车之后经历的流程</h3> </li></ul> 
<blockquote> 
 <p>忽略掉诸如键盘事件响应之类的，只关心跟网络相关的知识。考虑最简单的流程。</p> 
 <p>1）DNS解析：浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名对应的IP地址，DNS缓存从近到远依次是浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、域名服务器缓存、顶级域名服务器缓存。从哪个缓存找到对应的IP直接返回，不再查询后面的缓存。</p> 
 <p>2）TCP连接：结合三次握手</p> 
 <p>3）发送HTTP请求：浏览器发出读取文件的HTTP请求，该请求发送给服务器</p> 
 <p>4）服务器处理请求并返回HTTP报文：服务器对浏览器请求做出响应，把对应的带有HTML文本的HTTP响应报文发送给浏览器</p> 
 <p>5）浏览器解析渲染页面</p> 
 <p>6）连接结束：浏览器释放TCP连接，该步骤即四次挥手。第5步和第6步可以认为是同时发生的，哪一步在前没有特别的要求。</p> 
</blockquote> 
<ul><li> <h3 id="%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81">常见的HTTP状态码</h3> </li></ul> 
<blockquote> 
 <p>状态码由3位数字组成，第一位定义响应的类别</p> 
 <p>1XX：指示信息，服务器收到请求</p> 
 <p>2XX：请求成功，表示请求已经被成功接收、理解、接受</p> 
 <p>    200 OK：正常返回信息</p> 
 <p>3XX：重定向，要完成请求必须进行进一步操作</p> 
 <p>    301：永久重定向，配合location，浏览器自动处理。</p> 
 <p>    302：临时重定向，配合location，浏览器自动处理。只是临时地从旧地址跳转到新地址</p> 
 <p>    304：资源未被修改</p> 
 <p>4XX：客户端错误，请求由语法错误或请求无法实现</p> 
 <p>    400 Bad Request：客户端请求有语法错误，不能被服务器所理解。此时需要分析客户端的代码，去看看请求为什么出现服务      器无法理解的错误。</p> 
 <p>    401 Unauthorized：缺失或错误的认证，这个状态代码必须和WWW-Authenticate报头域一起使用。</p> 
 <p>    403 Forbidden：客户端请求没有权限去访问要求的资源。</p> 
 <p>    404 Not Found：请求资源不存在，检擦URL或路径配置。</p> 
 <p>5XX：服务端错误，服务器未能实现合法的请求</p> 
 <p>    500 Internal Server Error：服务器错误。检查服务器日志，看看里面的代码哪里错误，进而抛出异常。</p> 
 <p>    502 Bad Gateway：服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</p> 
 <p>    503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</p> 
 <p>    504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/83/c8/glKPraQX_o.png" width="1200"></p> 
 <p></p> 
 <ul><li> <h4 id="GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB">GET请求和POST请求的区别</h4> </li></ul> 
 <p>Content-Type最常见的几种类型：</p> 
 <p>application/x-www-form-urlencoded  form表单默认的数据格式，提交的数据形式 key1=val1&amp;key2=val2（参数少）</p> 
 <p>multiple/form-data 一般用来上传文件，也可以上传普通数据</p> 
 <p>application/json json对象（参数多）<br>  </p> 
</blockquote> 
<p><a href="https://blog.csdn.net/chen13333336677/article/details/100939030?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164187641316780265488922%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164187641316780265488922&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-100939030.first_rank_v2_pc_rank_v29&amp;utm_term=cookie%E4%B8%8Esession%E5%8C%BA%E5%88%AB&amp;spm=1018.2226.3001.4187" title="Cookie和Session的区别（面试必备）_chen13333336677的博客-CSDN博客_session和cookie的区别面试题">Cookie和Session的区别（面试必备）_chen13333336677的博客-CSDN博客_session和cookie的区别面试题</a></p> 
<p><img alt="" height="1164" src="https://images2.imgbox.com/52/66/q3kIYzUT_o.png" width="1200"></p> 
<p><a href="https://showme.codes/2017-02-20/understand-https/" rel="nofollow" title="也许，这样理解HTTPS更容易">也许，这样理解HTTPS更容易</a></p> 
<p></p> 
<p></p> 
<p>​​​​​​​</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03185afc2c385d719a58dd716b210934/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">构建YOCTO项目详细教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9396044dd4ea3878bde976033ead1c51/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>