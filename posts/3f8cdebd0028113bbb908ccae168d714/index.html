<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>gtest单元测试框架介绍及简单使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="gtest单元测试框架介绍及简单使用" />
<meta property="og:description" content="Gtest介绍 Gtest是Google的一个开源框架，它主要用于写单元测试，检查真自己的程序是否符合预期行为。可在多个平台上使用（包括Linux, Mac OS X, Windows, Cygwin和Symbian）。它提供了丰富的断言、致命和非致命失败判断，能进行值参数化测试、类型参数化测试、“死亡测试”。
下载安装 相关地址：
http://googletest.googlecode.com/files/gtest-1.3.0.zip
GitHub - google/googletest: GoogleTest - Google Testing and Mocking Framework
windows下推荐使用vcpkg工具下载安装，安装很简便。
默认下载安装的是32位的，若需要64位的则指定.\vcpkg.exe install gtest:x64-windows
.\vcpkg.exe install gtest 相关特性 一 .断言 一般的要测试一个方法（函数）是否是正常执行的，可以提供一些输入数据。在调用这个方法（函数）后得到输出数据，然后检查输出的数据是否与我们期望的结果是一致的。若一致则说明这个方法的逻辑是正确的，否则就有问题。
在对输出结果进行检查（check）时，Gtest为我提供了一系列的断言（assertion）来进行代码测试，这些宏有点类似于函数调用。当断言失败时Gtest将会打印出assertion时的源文件和出错行的位置以及附加的失败信息。这些输出的附加信息用户可以直接通过“&lt;&lt;”在这些断言宏后面。
Gtest中，断言的宏可以理解为分为两类，一类是ASSERT系列，一类是EXPECT系列。
ASSERT_系列的断言（Fatal assertion）：
当检查点失败时，退出当前函数（注意：并非退出当前案例）。
EXPECT_系列的断言(Nonfatal assertion)：
当检查点失败时，继续执行下一个检查点（每一个断言表示一个测试点）。
通常情况应该首选使用EXPECT_，因为ASSERT_*在报告完错误后不会进行清理工作，有可能导致内存泄露问题。
断言中提供以下几种检查方法:
布尔类型检查
二值检查
字符串检查
异常检查
浮点检查
相近值检查
二 .宏测试 TEST宏 TEST宏的第一个参数是test_suite_name（测试套件名），第二个参数是test_name（测试特例名）。
测试套件（Test Case）是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。
测试特例是测试套件下的一个（组）测试。
对于测试套件名和测试特例名，不能有下划线（_）。因为GTest源码中需要使用下划线把它们连接成一个独立的类名。不能有相同的“测试套件名和特例名”的组合——否则类名重合。
测试套件名和测试特例名的分开，使得我们编写的测试代码有着更加清晰的结构。
TEST_F宏 使用TEST_F前需要创建一个固件类，继承esting::Test类。
在类内部使用public或者protected描述其成员，为了保证实际执行的测试子类可以使用其成员变量。在构造函数或者继承于::testing::Test类中的SetUp方法中可以实现我们需要构造的数据。在析构函数或者继承于::testing::Test类中的TearDown方法中可以实现一些资源释放的代码。
第一个参数为测试套件名（必须与创建的固件类名一致），第二个为测试名，可任意取。
TEST_F宏和TEST宏的实现接近，只是TEST_F宏的封装更加开放一些，对TEST宏的功能多了一些扩展。
TEST_F与TEST的区别，TEST_F提供了一个初始化函数（SetUp）和一个清理函数(TearDown)。在TEST_F中使用的变量可以在初始化函数SetUp中初始化，在TearDown中销毁。所有的TEST_F是互相独立的，都是在初始化以后的状态开始运行。一个TEST_F不会影响另一个TEST_F所使用的数据，多个测试场景需要相同数据配置的情况用 TEST_F。
TEST_P宏 在设计测试案例时，经常需要考虑给被测函数传入不同的值的情况。我们之前的做法通常是写一个通用方法然后编写在测试案例调用它。即使使用了通用方法，这样的工作也是有很多重复性的。
用TEST这个宏，需要编写如下的测试案例，每输入一个值就需要写一个测试点，这还只是在一个测试中，如果把每个测试点单独创建一个测试，工作量就更大。使用TEST_P这个宏，对输入进行参数化，就简单很多。
预处理事件机制 gtest 提供了多种预处理事件机制，方便我们在测试之前或之后做一些操作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3f8cdebd0028113bbb908ccae168d714/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-06T21:11:06+08:00" />
<meta property="article:modified_time" content="2023-09-06T21:11:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">gtest单元测试框架介绍及简单使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/13/ab/a4ecymLj_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="Gtest_3"></a>Gtest介绍</h3> 
<p>Gtest是Google的一个开源框架，它主要用于写单元测试，检查真自己的程序是否符合预期行为。可在多个平台上使用（包括Linux, Mac OS X, Windows, Cygwin和Symbian）。它提供了丰富的断言、致命和非致命失败判断，能进行值参数化测试、类型参数化测试、“死亡测试”。</p> 
<h3><a id="_6"></a>下载安装</h3> 
<p>相关地址：</p> 
<p><a href="http://googletest.googlecode.com/files/gtest-1.3.0.zip" rel="nofollow">http://googletest.googlecode.com/files/gtest-1.3.0.zip</a></p> 
<p><a href="https://gitcode.net/mirrors/google/googletest?utm_source=csdn_github_accelerator" rel="nofollow">GitHub - google/googletest: GoogleTest - Google Testing and Mocking Framework</a></p> 
<p>windows下推荐使用vcpkg工具下载安装，安装很简便。</p> 
<p>默认下载安装的是32位的，若需要64位的则指定.\vcpkg.exe install gtest:x64-windows</p> 
<pre><code>.\vcpkg.exe install gtest
</code></pre> 
<h2><a id="_21"></a>相关特性</h2> 
<h4><a id="__23"></a>一 .断言</h4> 
<p>一般的要测试一个方法（函数）是否是正常执行的，可以提供一些输入数据。在调用这个方法（函数）后得到输出数据，然后检查输出的数据是否与我们期望的结果是一致的。若一致则说明这个方法的逻辑是正确的，否则就有问题。</p> 
<p>在对输出结果进行检查（check）时，Gtest为我提供了一系列的断言（assertion）来进行代码测试，这些宏有点类似于函数调用。当断言失败时Gtest将会打印出assertion时的源文件和出错行的位置以及附加的失败信息。这些输出的附加信息用户可以直接通过“&lt;&lt;”在这些断言宏后面。</p> 
<p>Gtest中，断言的宏可以理解为分为两类，一类是ASSERT系列，一类是EXPECT系列。</p> 
<p>ASSERT_系列的断言（Fatal assertion）：</p> 
<p>当检查点失败时，退出当前函数（注意：并非退出当前案例）。</p> 
<p>EXPECT_系列的断言(Nonfatal assertion)：</p> 
<p>当检查点失败时，继续执行下一个检查点（每一个断言表示一个测试点）。</p> 
<p>通常情况应该首选使用EXPECT_，因为ASSERT_*在报告完错误后不会进行清理工作，有可能导致内存泄露问题。</p> 
<p>断言中提供以下几种检查方法:</p> 
<p>布尔类型检查</p> 
<p><img src="https://images2.imgbox.com/01/b9/0wXiEPyj_o.png" alt=""></p> 
<p>二值检查</p> 
<p><img src="https://images2.imgbox.com/bc/21/FMRTMJue_o.png" alt="在这里插入图片描述"><br> 字符串检查</p> 
<p><img src="https://images2.imgbox.com/96/03/coZArYqE_o.png" alt=""><br> 异常检查</p> 
<p><img src="https://images2.imgbox.com/a5/94/qxJFJIfc_o.png" alt=""><br> 浮点检查</p> 
<p><img src="https://images2.imgbox.com/3a/8f/CRZmLhLg_o.png" alt=""><br> 相近值检查</p> 
<p><img src="https://images2.imgbox.com/f6/64/1EAErN5f_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="__61"></a>二 .宏测试</h3> 
<h4><a id="TEST_63"></a>TEST宏</h4> 
<p>TEST宏的第一个参数是test_suite_name（测试套件名），第二个参数是test_name（测试特例名）。</p> 
<p>测试套件（Test Case）是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。</p> 
<p>测试特例是测试套件下的一个（组）测试。</p> 
<p>对于测试套件名和测试特例名，不能有下划线（_）。因为GTest源码中需要使用下划线把它们连接成一个独立的类名。不能有相同的“测试套件名和特例名”的组合——否则类名重合。</p> 
<p>测试套件名和测试特例名的分开，使得我们编写的测试代码有着更加清晰的结构。</p> 
<h4><a id="TEST_F_76"></a>TEST_F宏</h4> 
<p>使用TEST_F前需要创建一个固件类，继承esting::Test类。</p> 
<p>在类内部使用public或者protected描述其成员，为了保证实际执行的测试子类可以使用其成员变量。在构造函数或者继承于::testing::Test类中的SetUp方法中可以实现我们需要构造的数据。在析构函数或者继承于::testing::Test类中的TearDown方法中可以实现一些资源释放的代码。</p> 
<p>第一个参数为测试套件名（必须与创建的固件类名一致），第二个为测试名，可任意取。</p> 
<p>TEST_F宏和TEST宏的实现接近，只是TEST_F宏的封装更加开放一些，对TEST宏的功能多了一些扩展。</p> 
<p>TEST_F与TEST的区别，TEST_F提供了一个初始化函数（SetUp）和一个清理函数(TearDown)。在TEST_F中使用的变量可以在初始化函数SetUp中初始化，在TearDown中销毁。所有的TEST_F是互相独立的，都是在初始化以后的状态开始运行。一个TEST_F不会影响另一个TEST_F所使用的数据，多个测试场景需要相同数据配置的情况用 TEST_F。</p> 
<h4><a id="TEST_P_89"></a>TEST_P宏</h4> 
<p>在设计测试案例时，经常需要考虑给被测函数传入不同的值的情况。我们之前的做法通常是写一个通用方法然后编写在测试案例调用它。即使使用了通用方法，这样的工作也是有很多重复性的。</p> 
<p>用TEST这个宏，需要编写如下的测试案例，每输入一个值就需要写一个测试点，这还只是在一个测试中，如果把每个测试点单独创建一个测试，工作量就更大。使用TEST_P这个宏，对输入进行参数化，就简单很多。</p> 
<h4><a id="_96"></a>预处理事件机制</h4> 
<p>gtest 提供了多种预处理事件机制，方便我们在测试之前或之后做一些操作。</p> 
<ol><li> <p>全局的，所有测试执行前后。</p> </li><li> <p>TestSuite级别的，在某测试套件中第一个测试前，最后一个测试执行后。</p> </li><li> <p>TestCase级别的，每个测试前后。</p> </li></ol> 
<p><strong>1.全局事件</strong></p> 
<p>要实现全局事件，必须写一个类继承testing::Environment类，实现里面的SetUp和TearDown方法。</p> 
<ol><li> <p>SetUp()方法在所有案例执行前执行。</p> </li><li> <p>TearDown()方法在所有案例执行后执行。</p> </li></ol> 
<p>还需要在main函数中通过调用testing::AddGlobalTestEnvironment这个函数将事件挂进来，也就是说，我们可以写很多个这样的类，然后将他们的事件都挂上去，AddGlobalTestEnvironment这个函数要放在RUN_ALL_TEST之前。</p> 
<p><img src="https://images2.imgbox.com/61/9c/ZUQ9lqKJ_o.png" alt="在这里插入图片描述"><br> <strong>2.TestSuites事件</strong></p> 
<p>需要写一个类，继承testing::Test，然后实现两个静态方法</p> 
<ol><li> <p>SetUpTestCase() 方法在第一个TestCase之前执行。</p> </li><li> <p>TearDownTestCase() 方法在最后一个TestCase之后执行。</p> </li></ol> 
<p><strong>3.TestCase事件</strong></p> 
<p>TestCase事件是挂在每个案例执行前后的，实现方式和Test’Suites的几乎一样，不过需要实现的是SetUp方法和TearDown方法：</p> 
<ol><li> <p>SetUp()方法在每个TestCase之前执行。</p> </li><li> <p>TearDown()方法在每个TestCase之后执行。</p> </li></ol> 
<h4><a id="_132"></a>测试用例入口</h4> 
<pre><code>int main(int argc,char *argv[])
{
    testing::InitGoogleTest(&amp;argc,argv);
    return RUN_ALL_TESTS();
}
</code></pre> 
<h4><a id="cmake_141"></a>cmake工程中使用</h4> 
<pre><code>find_package(GTest CONFIG REQUIRED)
target_link_libraries(${PROJECT_NAME} PRIVATE GTest::gtest GTest::gtest_main GTest::gmock GTest::gmock_main)
</code></pre> 
<p>附个简单的cmake工程模板：</p> 
<pre><code>cmake_minimum_required(VERSION 3.12)
 
project(mygtest VERSION 0.0.1)
 
set(CMAKE_CXX_STANDARD 11)
 
####################  QT dependencies ####################
#set(CMAKE_CXX_STANDARD 11)
#set(CMAKE_AUTOMOC ON)
#set(CMAKE_AUTORCC ON)
#set(CMAKE_AUTOUIC ON)
 
#set(QT_VERSION 5)
#set(REQUIRED_LIBS Core)
#set(REQUIRED_LIBS_QUALIFIED Qt5::Core)
 
####################  set output directory ####################
set(BUILD_DIR ${CMAKE_CURRENT_SOURCE_DIR}/build)
set(LIB_DIR ${BUILD_DIR}/Release)
set(LIB_FIX)
if (CMAKE_BUILD_TYPE MATCHES "Debug")
    set(LIB_DIR ${BUILD_DIR}/Debug)
    set(LIB_FIX _d)
endif ()
 
get_filename_component(ABSOLUTE_PATH ${LIB_DIR} ABSOLUTE)
set(LIB_DIR ${ABSOLUTE_PATH})
 
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LIB_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LIB_DIR}/lib)
set(CMAKE_PDB_OUTPUT_DIRECTORY ${LIB_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LIB_DIR}/lib)
 
set(LIB_DIR_FIX ${LIB_DIR}/bin)
option(USE_VS_BUILD "use visual studio build." OFF)
if (USE_VS_BUILD)
    set(LIB_DIR_FIX ${LIB_DIR}/bin/Debug)
endif ()
 
####################  set include path ####################
set(SRC_PATH
        ${CMAKE_CURRENT_SOURCE_DIR}/
        )
 
include_directories(
        ${SRC_PATH}
        ${BUILD_DIR}/../include
)
 
add_definitions(
        
)
 
####################  scan source files ####################
foreach (path ${SRC_PATH})
    aux_source_directory(${path} SRC_FILES)
endforeach ()
 
 
####################  version config ####################
#configure_file(${BUILD_DIR}/../include/version.h.in ${CMAKE_CURRENT_BINARY_DIR}/plugin_version.h)
#include_directories(${CMAKE_CURRENT_BINARY_DIR})
 
#if (MSVC)
#    set(MY_VERSIONINFO_RC "${CMAKE_CURRENT_BINARY_DIR}/VersionInfo.rc")
#    configure_file("${CMAKE_CURRENT_SOURCE_DIR}/resource.rc.in"
#            "${MY_VERSIONINFO_RC}")
#endif ()
 
#add_library(${PROJECT_NAME} SHARED ${SRC_FILES} ${MY_VERSIONINFO_RC})
add_executable(${PROJECT_NAME} ${SRC_FILES})
####################  set target properties ####################
set_target_properties(${PROJECT_NAME} PROPERTIES DEBUG_POSTFIX _d)
 
####################  set target dependencies ####################
find_package(GTest CONFIG REQUIRED)
#find_package(Qt${QT_VERSION} COMPONENTS ${REQUIRED_LIBS} REQUIRED)
 
set(THIRD_LIBS
        #${REQUIRED_LIBS_QUALIFIED}
        #${LOGGING_LIB}
        )
target_link_libraries(${PROJECT_NAME} PRIVATE ${THIRD_LIBS})
target_link_libraries(${PROJECT_NAME} PRIVATE GTest::gtest GTest::gtest_main GTest::gmock GTest::gmock_main)
</code></pre> 
<p>在clion的项目中还需要配置：</p> 
<pre><code>-DCMAKE_PREFIX_PATH=D:\Qt5.12.11\Qt5.12.11\5.12.11\msvc2015_64\lib\cmake -DCMAKE_TOOLCHAIN_FILE=F:\vcpkg\scripts\buildsystems\vcpkg.cmake -Wno-dev
</code></pre> 
<p>若使用命令行下尝试，则推荐使用powershell脚本，附个示例：</p> 
<pre><code>$VcpkgPath = "F:/vcpkg/scripts/buildsystems/vcpkg.cmake"
#if (($result = Read-Host "Enter the full path of vcpkg.cmake[default: F:/vcpkg/scripts/buildsystems/vcpkg.cmake]") -eq '') {} else {$VcpkgPath=$result}
Write-Host "`n VcpkgPath: $VcpkgPath" -ForegroundColor Yellow
 
Push-Location 'C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\Tools'    
cmd /c "vsvars32.bat&amp;set" |
ForEach-Object {
  if ($_ -match "=") {
    $v = $_.split("="); set-item -force -path "ENV:\$($v[0])"  -value "$($v[1])"
  }
}
Pop-Location
write-host "`nVisual Studio 2015 Command Prompt variables set." -ForegroundColor Yellow
 
Write-Host "`n build for this module project." -ForegroundColor Green
cmake . -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_TOOLCHAIN_FILE="$VcpkgPath" -Wno-dev -G "NMake Makefiles" 
Set-Location build
nmake 
#nmake install
Set-Location ..
</code></pre> 
<h3><a id="_264"></a>简单示例</h3> 
<pre><code>#include&lt;iostream&gt;
using namespace std; 
#include&lt;gtest/gtest.h&gt;
 
class MyClass{
public:
    int add(int a,int b){
        return a+b;
    }
    int del(int a,int b){
        return a-b;
    }
 
};
//class MyClassTest: public testing::Test{}
class MyClassTest: public testing::TestWithParam&lt;int&gt;{
public:
    static void SetUpTestCase()
    {
        cout&lt;&lt;"SetUpTestCase"&lt;&lt;endl;
    }
    static void TearDownTestCase()
    {
        cout&lt;&lt;"TearDownTestCase"&lt;&lt;endl;
    }
    virtual void SetUp()   //TEST跑之前会执行SetUp
    {
        cout&lt;&lt;"SetUp"&lt;&lt;endl;
    }
    virtual void TearDown() //TEST跑完之后会执行TearDown
    {
        cout&lt;&lt;"TearDown"&lt;&lt;endl;
    }
    MyClass myClass;
 
};
 
INSTANTIATE_TEST_SUITE_P(PARAM,MyClassTest,testing::Values(3,5,7,9));
 
int Abs(int x)
{
     return x &gt; 0 ? x : -x;
}
 
TEST(IsAbsTest,MyTest)
{
    ASSERT_TRUE(Abs(1) == 1) &lt;&lt; "Abs(1)=1";  //ASSERT_TRUE期待结果是true,operator&lt;&lt;输出一些自定义的信息
    ASSERT_TRUE(Abs(-1) == 1) &lt;&lt; "Abs(-1)=1";
    ASSERT_FALSE(Abs(-2) == -2);  //期待结果是false
    ASSERT_EQ(Abs(1),Abs(-1));
    ASSERT_NE(Abs(-1),0);
    ASSERT_LT(Abs(-1),2);
    ASSERT_GT(Abs(-1),0);
    ASSERT_LE(Abs(-1),2);
    ASSERT_GE(Abs(-1),0);
}
 
//此时使用的是TEST_P宏
TEST_P(MyClassTest,AddTest)
{
    auto out= myClass.add(1,2);
    //ASSERT_NE(out,3);
    int n = GetParam();
    ASSERT_EQ(out,3);
    ASSERT_EQ(out,n);
}
//此时使用的是TEST_F宏
TEST_F(MyClassTest,Add)
{
    auto out= myClass.add(1,2);
    ASSERT_EQ(out,3);
}
TEST_F(MyClassTest,del)
{
    ASSERT_EQ(myClass.del(4,3),1);
}
 
int main(int argc,char *argv[])
{
    testing::InitGoogleTest(&amp;argc,argv);
    return RUN_ALL_TESTS();
}
</code></pre> 
<p>运行结果：</p> 
<p><img src="https://images2.imgbox.com/ed/9a/NYQSrOZk_o.png" alt="在这里插入图片描述"><br> 最后给大家分享一下我的一些学习资料：<br> <img src="https://images2.imgbox.com/0e/98/nLviE2g1_o.png" alt=""><br> 以上内容，对于软件测试的朋友来说应该是最全面最完整的备战仓库了，为了更好地整理每个模块，我也参考了很多网上的优质博文和项目，力求不漏掉每一个知识点，很多朋友靠着这些内容进行复习，拿到了BATJ等大厂的offer，这个仓库也已经帮助了很多的软件测试的学习者，希望也能帮助到你。</p> 
<p>关注下方我的微信公众号免费领取！↓ ↓ ↓ ↓ ↓</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d205f1341d913b36db5d5f81bb24d14a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL为什么不建议使用DELETE 删除数据？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dee59cd45db648fb4b41507eef4a6499/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Typora使用技巧 | 各种跳转 【必备】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>