<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python中的Counter类 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python中的Counter类" />
<meta property="og:description" content="在很多场景中经常会用到统计计数的需求，比如在实现 kNN 算法时统计 k 个标签值的个数，进而找出标签个数最多的标签值作为最终 kNN 算法的预测结果。Python内建的 collections 集合模块中的 Counter 类能够简洁、高效的实现统计计数。
Counter 是 dict 字典的子类，Counter 拥有类似字典的 key 键和 value 值，只不过 Counter 中的键为待计数的元素，而 value 值为对应元素出现的次数 count，为了方便介绍统一使用元素和 count 计数来表示。虽然 Counter 中的 count 表示的是计数，但是 Counter 允许 count 的值为 0 或者负值。
1. 实例化 Counter 类 如果要使用 Counter，必须要进行实例化，在实例化的同时可以为构造函数传入参数来指定不同类型的元素来源。
from collections import Counter # 实例化元素为空的 Counter 对象 a = Counter() # 从可迭代对象中实例化 Counter 对象 b = Counter(&#39;chenkc&#39;) # 从 mapping 中实例化 Counter 对象 c = Counter({&#39;a&#39;:1, &#39;b&#39;:2, &#39;c&#39;:3}) # 从关键词参数中实例化 Counter 对象 d = Counter(a = 1, b = 2, c = 3) 实例化元素为空的 Counter 对象，之后可以通过为字典添加元素的方式为 Counter 对象添加元素。 from collections import Counter # 实例化元素为空的 Counter a = Counter() # 为 Counter 添加元素以及对应的 count 计数 a[&#39;a&#39;] = 1 a[&#39;b&#39;] = 2 a[&#39;c&#39;] = 3 &gt;&gt;&gt; print(a) Counter({&#39;c&#39;: 3, &#39;b&#39;: 2, &#39;a&#39;: 1}) 从 string（字符为list列表的元素）、list 和 tuple 这些可迭代对象中获取元素。 from collections import Counter # 从可迭代对象中实例化 Counter b = Counter(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/eed46e8309aeae535609349d075d0bbf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-27T22:25:26+08:00" />
<meta property="article:modified_time" content="2022-09-27T22:25:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python中的Counter类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在很多场景中经常会用到统计计数的需求，比如在实现 kNN 算法时统计 k 个标签值的个数，进而找出标签个数最多的标签值作为最终 kNN 算法的预测结果。Python内建的 collections 集合模块中的 Counter 类能够简洁、高效的实现统计计数。</p> 
<p>Counter 是 dict 字典的子类，Counter 拥有类似字典的 key 键和 value 值，只不过 Counter 中的键为待计数的元素，而 value 值为对应元素出现的次数 count，为了方便介绍统一使用元素和 count 计数来表示。<strong>虽然 Counter 中的 count 表示的是计数，但是 Counter 允许 count 的值为 0 或者负值。</strong></p> 
<h3><strong>1. 实例化 Counter 类</strong></h3> 
<p>如果要使用 Counter，必须要进行实例化，在实例化的同时可以为构造函数传入参数来指定不同类型的元素来源。</p> 
<pre><code>from collections import Counter

# 实例化元素为空的 Counter 对象
a = Counter()

# 从可迭代对象中实例化 Counter 对象
b = Counter('chenkc')

# 从 mapping 中实例化 Counter 对象
c = Counter({'a':1, 'b':2, 'c':3})

# 从关键词参数中实例化 Counter 对象
d = Counter(a = 1, b = 2, c = 3)</code></pre> 
<ul><li>实例化元素为空的 Counter 对象，之后可以通过为字典添加元素的方式为 Counter 对象添加元素。</li></ul> 
<pre><code>from collections import Counter

# 实例化元素为空的 Counter
a = Counter()
# 为 Counter 添加元素以及对应的 count 计数
a['a'] = 1
a['b'] = 2
a['c'] = 3

&gt;&gt;&gt; print(a)
Counter({'c': 3, 'b': 2, 'a': 1})</code></pre> 
<ul><li>从 string（字符为list列表的元素）、list 和 tuple 这些可迭代对象中获取元素。</li></ul> 
<pre><code>from collections import Counter

# 从可迭代对象中实例化 Counter
b = Counter("chenkc") # string
b2 = Counter(['c', 'h', 'e', 'n', 'k', 'c']) # list
b3 = Counter(('c', 'h', 'e', 'n', 'k', 'c')) # tuple

&gt;&gt;&gt; print(b)
Counter({'c': 2, 'h': 1, 'e': 1, 'n': 1, 'k': 1})
&gt;&gt;&gt; print(b2)
Counter({'c': 2, 'h': 1, 'e': 1, 'n': 1, 'k': 1})
&gt;&gt;&gt; print(b3)
Counter({'c': 2, 'h': 1, 'e': 1, 'n': 1, 'k': 1})</code></pre> 
<ul><li>从 mapping 中实例化 Counter 对象，mapping 类型的数据就是元素为<code>(x, y)</code>的列表，字典也属于 mapping 类型的数据。</li></ul> 
<pre><code>from collections import Counter

# 从 mapping 中实例化 Counter 对象
c = Counter([('a', 1), ('b', 2), ('a', 3), ('c', 3)])
c2 = Counter({'a':1, 'b':2, 'a':3, 'c':3}) # 字典

&gt;&gt;&gt; print(c)
Counter({('a', 1): 1, ('b', 2): 1, ('a', 3): 1, ('c', 3): 1}) 
&gt;&gt;&gt; print(c2)
Counter({'a': 3, 'c': 3, 'b': 2})</code></pre> 
<p>虽然传入的 mapping 类型的数据是一样的，<strong>但是由于字典中的键是唯一的，因此如果字典中的键重复会保留最后一个</strong>。</p> 
<pre><code>dic = {'a':1, 'b':2, 'a':3, 'c':3}

&gt;&gt;&gt; print(dic)
{'a': 3, 'b': 2, 'c': 3}</code></pre> 
<ul><li>从关键词参数中实例化 Counter 对象，<strong>关键词参数中指定的关键词必须是唯一的，但是不同于字典，如果指定的关键词重复，程序会抛出SyntaxError异常。</strong></li></ul> 
<pre><code>from collections import Counter

# 从关键词参数中实例化 Counter 对象
d = Counter(a = 1, b = 2, c = 3)
# d2 = Counter(a = 1, b = 2, a = 3, c = 3) # SyntaxError

&gt;&gt;&gt; print(d)
Counter({'c': 3, 'b': 2, 'a': 1})</code></pre> 
<p>我们都知道在字典中查找不存在的键，程序会抛出 KyeError的异常，但是由于 Counter 用于统计计数，因此 Counter 不同于字典，**如果在 Counter 中查找一个不存在的元素，不会产生异常，而是会返回 0，这其实很好理解，Counter 计数将不存在元素的 count 值设置为 0 **。</p> 
<pre><code>from collections import Counter

c = Counter({'a':1, 'b':2, 'c':3})

&gt;&gt;&gt; print(c['d']) # 查找键值为'd'对应的计数
0
&gt;&gt;&gt; print(c)
Counter({'c': 3, 'b': 2, 'a': 1})</code></pre> 
<p><code>c['d']</code>表示的查找返回元素值为<code>d</code>的 count 计数，而如果使用<code>c['d'] = 0</code>则表示的是为 Counter 添加元素。</p> 
<pre><code>from collections import Counter

c = Counter({'a':1, 'b':2, 'c':3})
c['d'] = 4 # 为 Counter 添加元素

&gt;&gt;&gt; print(c['d'])
4
&gt;&gt;&gt; print(c)
Counter({'d': 4, 'c': 3, 'b': 2, 'a': 1})</code></pre> 
<h3><strong>2. Counter 中的方法</strong></h3> 
<p>实例化 Counter 类对象之后，就可以使用 Counter 对象中的方法。由于 Counter 类继承自 dict 类，所以 Counter 类可以使用 dict 类的方法。下面分别从 Counter 所特有的方法和一些字典的常规方法来介绍。</p> 
<h4><strong>2.1 Counter 特有的方法</strong></h4> 
<p>Counter 额外支持字典中没有的三个方法：<code>elements()</code>、<code>most_common([m])</code>以及<code>subtract([iterable-or-mapping])</code>。</p> 
<ul><li>elements 方法</li></ul> 
<p><code>elements()</code>方法返回一个迭代器，可以通过 list 或者其它方法将迭代器中的元素输出，输出的结果为对应出现次数的元素。</p> 
<pre><code>from collections import Counter

c = Counter({'a':1, 'b':2, 'c':3})
c2 = Counter({'a':0, 'b':-1, 'c':3}) # 将出现次数设置为 0 和负值

&gt;&gt;&gt; print(c.elements())
&lt;itertools.chain object at 0x0000022A57509B70&gt; 
&gt;&gt;&gt; print(list(c.elements()))
['a', 'b', 'b', 'c', 'c', 'c'] 

&gt;&gt;&gt; print(c2.elements())
&lt;itertools.chain object at 0x0000022A57509B70&gt; 
&gt;&gt;&gt; print(list(c2.elements()))
['c', 'c', 'c']</code></pre> 
<p>在 Counter 中是允许计数为 0 或者负值的，<strong>不过通过上面代码可以看出 elements 函数没有将 0 和负值对应的元素值打印出来</strong>。</p> 
<ul><li>most_common 方法</li></ul> 
<p><code>most_common([n])</code>是 Counter 最常用的方法，返回一个出现次数从大到小的前 n 个元素的列表。</p> 
<pre><code>from collections import Counter

c = Counter({'a':1, 'b':2, 'c':3})

&gt;&gt;&gt; print(c.most_common()) # 默认参数
[('c', 3), ('b', 2), ('a', 1)]
&gt;&gt;&gt; print(c.most_common(2)) # n = 2
 [('c', 3), ('b', 2)] 
&gt;&gt;&gt; print(c.most_common(3)) # n = 3
[('c', 3), ('b', 2), ('a', 1)] 
&gt;&gt;&gt; print(c.most_common(-1)) # n = -1
[]</code></pre> 
<p><code>n</code>为可选参数，通过上面的代码可以总结出：</p> 
<ol><li>不输入<code>n</code>，默认返回所有；</li><li>输入<code>n</code>小于最长长度，则返回前<code>n</code>个数；</li><li>输入<code>n</code>等于最长长度，则返回所有；</li><li>输入<code>n = -1</code>，则返回空；</li></ol> 
<ul><li>subtract 方法</li></ul> 
<p><code>subtract([iterable_or_mapping])</code>方法其实就是将两个 Counter 对象中的元素对应的计数相减。</p> 
<pre><code>from collections import Counter

c = Counter({'a':1, 'b':2, 'c':3})
d = Counter({'a':1, 'b':3, 'c':2, 'd':2})
c.subtract(d)

&gt;&gt;&gt; print(c)
Counter({'c': 1, 'a': 0, 'b': -1, 'd': -2})</code></pre> 
<p>其实就是两个 Counter 中的对应的元素的计数相减。当其中某个 Counter 中对应的元素不存在的时候，默认将其计数设置为 0，这也是为什么<code>'d'</code>的计数为-2的原因。</p> 
<h4><strong>2.2 Counter 支持的字典方法</strong></h4> 
<p>一般常规的字典方法对 Counter 对象都是有效的，将这些字典方法作用到下面的 Counter 对象<code>c</code>中，并绘制到下面的表格中。</p> 
<pre><code>from collections import Counter

c = Counter({'a':1, 'b':2, 'c':3, 'd':0, 'e':-1})</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c3/07/yEzHjU67_o.jpg"></p> 
<p>但是在 Counter 中有两个方法和字典中的使用有些区别：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c8/c8/l3VfBGfd_o.png"></p> 
<pre><code>from collections import Counter

c = Counter({'a':1, 'b':2, 'c':3, 'd':0, 'e':-1})

c.update({'a':2, 'd':2, 'e':1})

&gt;&gt;&gt; print(c)
Counter({'a': 3, 'c': 3, 'b': 2, 'd': 2, 'e': 0})</code></pre> 
<p>对于 Counter 中的<code>update</code>函数简单来说，就是增加对应元素的计数。</p> 
<h4><strong>2.3 集合运算符</strong></h4> 
<p>这里直接贴出集合运算符的代码示例。</p> 
<pre><code>&gt;&gt;&gt; c = Counter(a=3, b=1)
&gt;&gt;&gt; d = Counter(a=1, b=2)
&gt;&gt;&gt; c + d                           # add two counters together:  c[x] + d[x]
Counter({'a': 4, 'b': 3})
&gt;&gt;&gt; c - d                           # subtract (keeping only positive counts)
Counter({'a': 2})
&gt;&gt;&gt; c &amp; d                           # intersection:  min(c[x], d[x])
Counter({'a': 1, 'b': 1})
&gt;&gt;&gt; c | d                           # union:  max(c[x], d[x])
Counter({'a': 3, 'b': 2})</code></pre> 
<p></p> 
<blockquote> 
 <em>原文地址：<br><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg5NzE1NzM4NA%3D%3D%26mid%3D2247486151%26idx%3D1%26sn%3D6e54a73d82fb75f5d2230271f3d3104c%26chksm%3Dc0775aa0f700d3b66ccc0a4f02c40dc9636701ee60b2a4ffa9be9299bbf78631f375416ce6cc%26token%3D1021205192%26lang%3Dzh_CN%23rd" rel="nofollow" title="Python中的计数 - Counter类">Python中的计数 - Counter类</a><br> References：<br><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/Shiroh_ms08/article/details/52653385" rel="nofollow" title="Python collections中的Counter作用以及源码分析">Python collections中的Counter作用以及源码分析</a></em> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1cefdbdc03c103e67b34865f598da20/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python修饰函数用法，结合mmcv中的Registry类说明</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/018de32e4135ae44533b95e1613ab476/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QT_7(菜单栏、工具栏、状态栏、资源文件的添加)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>