<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python - 深夜数据结构与算法之 Two-Ended BFS - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python - 深夜数据结构与算法之 Two-Ended BFS" />
<meta property="og:description" content="目录
一.引言
二.双向 BFS 简介
1.双向遍历示例
2.搜索模版回顾
三.经典算法实战
1.Word-Ladder [127]
2.Min-Gen-Mutation [433]
四.总结
一.引言 DFS、BFS 是常见的初级搜索方式，为了提高搜索效率，衍生了剪枝、双向 BFS 以及 A* 即启发式搜索等高级搜索方式。剪枝通过避免不必要或者次优解来减少搜索的次数，提高搜索效率；双向 BFS 通过层序遍历从首尾逼近答案，提高搜索效率；启发式搜索则是从优先级的角度出发，基于优先级高低搜索，提高搜索效率。本文主要介绍双向 BFS 的使用。
二.双向 BFS 简介 1.双向遍历示例 ◆ 双向连通图
求 A -&gt; L 所需最短路径。
◆ 遍历层级关系
不同颜色代表不同层级的 BFS，绿色为 root，蓝色为第二层，从左向右递推。
◆ 双向遍历
从 A/L 同时层序遍历，当二者扩散的点重合时，左右路径长度相加即为最短路径。
2.搜索模版回顾 ◆ DFS - 递归
◆ DFS - 非递归 ◆ BFS - 栈 三.经典算法实战 1.Word-Ladder [127] 单词接龙: https://leetcode.cn/problems/word-ladder/description/
◆ 单向 BFS
class Solution: def ladderLength(self, beginWord, endWord, wordList): &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7479af016b028a7ba1fd53743b1363fd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T14:07:40+08:00" />
<meta property="article:modified_time" content="2024-01-09T14:07:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python - 深夜数据结构与算法之 Two-Ended BFS</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="1200" src="https://images2.imgbox.com/a7/ad/JHo7312b_o.jpg" width="1200"></h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%BC%95%E8%A8%80" rel="nofollow">一.引言</a></p> 
<p id="%E4%BA%8C.%E5%8F%8C%E5%90%91%20BFS%20%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E5%8F%8C%E5%90%91%20BFS%20%E7%AE%80%E4%BB%8B" rel="nofollow">二.双向 BFS 简介</a></p> 
<p id="1.%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#1.%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86%E7%A4%BA%E4%BE%8B" rel="nofollow">1.双向遍历示例</a></p> 
<p id="3.%E6%90%9C%E7%B4%A2%E6%A8%A1%E7%89%88%E5%9B%9E%E9%A1%BE-toc" style="margin-left:40px;"><a href="#3.%E6%90%9C%E7%B4%A2%E6%A8%A1%E7%89%88%E5%9B%9E%E9%A1%BE" rel="nofollow">2.搜索模版回顾</a></p> 
<p id="%E4%B8%89.%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98" rel="nofollow">三.经典算法实战</a></p> 
<p id="1.Word-Ladder%20%5B127%5D-toc" style="margin-left:40px;"><a href="#1.Word-Ladder%20%5B127%5D" rel="nofollow">1.Word-Ladder [127]</a></p> 
<p id="2.Min-Gen-Mutation%20%5B433%5D-toc" style="margin-left:40px;"><a href="#2.Min-Gen-Mutation%20%5B433%5D" rel="nofollow">2.Min-Gen-Mutation [433]</a></p> 
<p id="%E5%9B%9B.%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E6%80%BB%E7%BB%93" rel="nofollow">四.总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E5%BC%95%E8%A8%80">一.引言</h2> 
<p>DFS、BFS 是常见的初级搜索方式，为了提高搜索效率，衍生了剪枝、双向 BFS 以及 A* 即启发式搜索等高级搜索方式。剪枝通过避免不必要或者次优解来减少搜索的次数，提高搜索效率；双向 BFS 通过层序遍历从首尾逼近答案，提高搜索效率；启发式搜索则是从优先级的角度出发，基于优先级高低搜索，提高搜索效率。本文主要介绍双向 BFS 的使用。</p> 
<p></p> 
<h2 id="%E4%BA%8C.%E5%8F%8C%E5%90%91%20BFS%20%E7%AE%80%E4%BB%8B">二.双向 BFS 简介</h2> 
<h3 id="1.%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86%E7%A4%BA%E4%BE%8B">1.双向遍历示例</h3> 
<p><strong><em>◆ </em> 双向连通图</strong></p> 
<p>求 A -&gt; L 所需最短路径。</p> 
<p class="img-center"><img alt="" height="278" src="https://images2.imgbox.com/63/52/yLZ5MJPw_o.png" width="550"></p> 
<p><strong><em>◆ </em> 遍历层级关系</strong></p> 
<p>不同颜色代表不同层级的 BFS，绿色为 root，蓝色为第二层，从左向右递推。</p> 
<p class="img-center"><img alt="" height="252" src="https://images2.imgbox.com/28/66/k6xByS3n_o.png" width="550"></p> 
<p><strong><em>◆ </em> 双向遍历</strong></p> 
<p>从 A/L 同时层序遍历，当二者扩散的点重合时，左右路径长度相加即为最短路径。</p> 
<p class="img-center"><img alt="" height="249" src="https://images2.imgbox.com/de/2f/f9yZ43za_o.png" width="550"></p> 
<p></p> 
<h3 id="3.%E6%90%9C%E7%B4%A2%E6%A8%A1%E7%89%88%E5%9B%9E%E9%A1%BE">2.搜索模版回顾</h3> 
<p><strong>◆ DFS - 递归</strong></p> 
<p class="img-center"><img alt="" height="367" src="https://images2.imgbox.com/93/3e/EwYNgvIA_o.png" width="550"></p> 
<p><strong>◆ DFS - 非递归</strong> </p> 
<p class="img-center"><img alt="" height="368" src="https://images2.imgbox.com/65/19/hCTiKO12_o.png" width="550"></p> 
<p><strong>◆ BFS - 栈</strong> </p> 
<p class="img-center"><img alt="" height="393" src="https://images2.imgbox.com/86/19/eWOYRtWI_o.png" width="550"></p> 
<p></p> 
<h2 id="%E4%B8%89.%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98">三.经典算法实战</h2> 
<h3 id="1.Word-Ladder%20%5B127%5D">1.Word-Ladder [127]</h3> 
<p>单词接龙: <a class="link-info" href="https://leetcode.cn/problems/word-ladder/description/" rel="nofollow" title="https://leetcode.cn/problems/word-ladder/description/">https://leetcode.cn/problems/word-ladder/description/</a></p> 
<p class="img-center"><img alt="" height="397" src="https://images2.imgbox.com/d2/51/EpUVXfYA_o.png" width="700"></p> 
<p><strong>◆ 单向 BFS</strong></p> 
<pre><code class="language-python">class Solution:    
    def ladderLength(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """
        valid_word = set(wordList)

        if endWord not in valid_word:
            return 0

        stack = [(beginWord, 1)]

        while stack:
            word, level = stack.pop(0)

            for i in range(len(word)):
                for char in "abcdefghijklmnopqrstuvwxyz":
                    new_word = word[:i] + char + word[i + 1:]

                    if new_word == endWord:
                        return level + 1
                    elif new_word in valid_word:
                        stack.append((new_word, level + 1))
                        valid_word.remove(new_word)

        return 0</code></pre> 
<p>这里我们可以打印一下转换的流程图，hot 有多层 level 出发，第二条路径走到了 cog，即结束遍历，当然 log 也可以走到 cog 只不过已经不需要了。</p> 
<blockquote> 
 <p>hot 2 -&gt; lot 3</p> 
 <p><strong>hot 2 -&gt; dot 3 -&gt; dog 4 -&gt; cog 5</strong></p> 
 <p>hot 2 -&gt; dot 3 -&gt; log 4 </p> 
</blockquote> 
<p class="img-center"><img alt="" height="382" src="https://images2.imgbox.com/91/dc/BXxD4hKw_o.png" width="550"></p> 
<p class="img-center"><img alt="" height="212" src="https://images2.imgbox.com/e6/03/c5jhnC6p_o.png" width="450"></p> 
<p></p> 
<p><strong>◆ 双向 BFS</strong> </p> 
<pre><code class="language-python">class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """
        # 去重使用
        valid_word = set(wordList)

        # 边界条件
        if endWord not in wordList or len(wordList) == 0:
            return 0

        # 双向 BFS
        begin, end, step = {beginWord}, {endWord}, 1


        # 同时有元素才能继续，如果一遍没元素代表已中断，无法联通，直接结束
        while begin and end:

            # 减少排查的可能性，从单词少的方向排查，避免无效查询
            if len(begin) &gt; len(end):
                begin, end = end, begin

            # 存储下一层
            next_level = set()
            # 遍历下一层的多个结果
            for word in begin:
                # 遍历每个位置
                for i in range(len(word)):
                    # a-z
                    for char in "abcdefghijklmnopqrstuvwxyz":
                        # 节省无必要的替换
                        if char != word[i]:
                            new_word = word[:i] + char + word[i + 1:]
                            # 二者相遇即返回
                            if new_word in end:
                                return step + 1
                            if new_word in valid_word:
                                next_level.add(new_word)
                                valid_word.remove(new_word)

            # 指针替换
            begin = next_level
            step += 1

        return 0</code></pre> 
<p>已经将详细的注释加在代码里了，从 {start}，{end} 两个方向查找，每次只找短的缩小无效查询的次数，这其实也是一种剪枝的策略，正所谓图中有真意欲辨已忘言：</p> 
<p class="img-center"><img alt="" height="658" src="https://images2.imgbox.com/94/cb/NQ7ZdXXP_o.png" width="550"></p> 
<p class="img-center"><img alt="" height="208" src="https://images2.imgbox.com/32/4b/GGN5GUck_o.png" width="450"></p> 
<p></p> 
<p><strong>◆ 双向 BFS + 剪枝</strong></p> 
<pre><code class="language-python">class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """
        # 去重使用
        valid_word = set(wordList)

        if endWord not in wordList or len(wordList) == 0:
            return 0

        # 剪枝优化
        s = set()
        for word in wordList:
            for char in word:
                s.add(char)

        s = ''.join(list(s))

        # 双向 BFS
        begin, end, step = {beginWord}, {endWord}, 1

        while begin and end:

            if len(begin) &gt; len(end):
                begin, end = end, begin

            # 存储下一层
            next_level = set()
            for word in begin:
                for i in range(len(word)):
                    # a-z
                    for char in s:
                        # 节省无必要的替换
                        if char != word[i]:
                            new_word = word[:i] + char + word[i + 1:]

                            if new_word in end:
                                return step + 1
                            if new_word in valid_word:
                                next_level.add(new_word)
                                valid_word.remove(new_word)

            # 指针替换
            begin = next_level
            step += 1

        return 0</code></pre> 
<p>上面的两个方法在构建 new_word 时都遍历了所有 26 个字母 char，其实我们可以根据 end_word 的去重字符进行状态空间压缩，从而减少无意义的遍历，因为 char not in end_word 则 new_word 必定 not in end_word，从而优化时间复杂度。 </p> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/9a/be/OmSl7s7y_o.png" width="450"></p> 
<p></p> 
<h3 id="2.Min-Gen-Mutation%20%5B433%5D">2.Min-Gen-Mutation [433]</h3> 
<p>最小基因突变: <a class="link-info" href="https://leetcode.cn/problems/minimum-genetic-mutation/description/" rel="nofollow" title="https://leetcode.cn/problems/minimum-genetic-mutation/description/">https://leetcode.cn/problems/minimum-genetic-mutation/description/</a> </p> 
<p class="img-center"><img alt="" height="396" src="https://images2.imgbox.com/f0/6b/anTjvux4_o.png" width="700"></p> 
<p><strong>◆ BFS</strong></p> 
<pre><code class="language-python">class Solution(object):
    def minMutation(self, startGene, endGene, bank):
        """
        :type startGene: str
        :type endGene: str
        :type bank: List[str]
        :rtype: int
        """
        if not bank:
            return -1

        bank = set(bank)
        if endGene not in bank:
            return -1

        stack = [(startGene, 0)]

        while stack:
            gene, level = stack.pop(0)

            for i in range(len(gene)):
                for char in "ACGT":
                    new_gene = gene[:i] + char + gene[i + 1:]

                    if new_gene == endGene:
                        return level + 1

                    if new_gene in bank:
                        stack.append((new_gene, level + 1))
                        bank.remove(new_gene)

        return -1</code></pre> 
<p>和上一题异曲同工之妙，只不过从单词接龙变成基因 🧬 接龙，每次修改的地方有限。</p> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/30/22/66wj6FyL_o.png" width="450"></p> 
<p></p> 
<p><strong>◆ 双向 BFS</strong></p> 
<pre><code class="language-python">class Solution(object):
    def minMutation(self, startGene, endGene, bank):
        """
        :type startGene: str
        :type endGene: str
        :type bank: List[str]
        :rtype: int
        """
        if not bank:
            return -1

        bank = set(bank)
        if endGene not in bank:
            return -1

        # 初始化首尾
        front, back, step = {startGene}, {endGene}, 0

        while front and back:

            next_front = set()

            # 遍历当前层 Gene
            for gene in front:
                print(gene)
                for i in range(len(gene)):
                    for char in "ACGT":
                        new_gene = gene[:i] + char + gene[i + 1:]
                        # 相遇了
                        if new_gene in back:
                            return step + 1
                        # 下一层突变
                        if new_gene in bank:
                            next_front.add(new_gene)
                            bank.remove(new_gene)

            # 取短的遍历加速
            if len(next_front) &gt; len(back):
                front, back = back, next_front
            else:
                front = next_front

            step += 1

        return -1</code></pre> 
<p>和上面异曲同工，老曲新唱，相当于再温习一遍。其加速点就是左右替换，优先遍历可能性少的情况。</p> 
<p class="img-center"><img alt="" height="211" src="https://images2.imgbox.com/52/21/PWn6H8Zw_o.png" width="450"></p> 
<p></p> 
<h2 id="%E5%9B%9B.%E6%80%BB%E7%BB%93">四.总结</h2> 
<p>这节内容 '双向 BFS' 起始也包含着很多剪枝的策略，所以其也属于优化搜索方式的方法之一，下一节我们介绍高级搜索的最后一块内容: A* 启发式搜索。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be74ef95a8c9f549670519d0d39dc156/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ORACLE之rman备份恢复及故障处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27cb7a764d9a3e35b93e0ba51701a05f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1045 - Access denied for user ‘root @223.98.184.126‘ (using password: YES)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>