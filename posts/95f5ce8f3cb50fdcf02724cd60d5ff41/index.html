<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HDFS的NameNode和SecondaryNameNode - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HDFS的NameNode和SecondaryNameNode" />
<meta property="og:description" content="一、NN 和 2NN 工作机制 NameNode中的元数据是存储在哪里的？
首先，我们做个假设，如果存储在NameNode节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此产生了磁盘中备份元数据的FsImage。
这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新FsImage，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。因此，引入Edits文件(只进行追加操作，效率很高)。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到Edits中。这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。
但是，如果长时间添加数据到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，又会效率过低。因此，引入一个新的节点SecondaryNamenode，专门用于FsImage和Edits的合并。
1.第一阶段：NameNode启动
（1）第一次启动NameNode格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。
（2）客户端对元数据进行增删改的请求。
（3）NameNode记录操作日志，更新滚动日志。
（4）NameNode在内存中对元数据进行增删改。
2. 第二阶段：Secondary NameNode工作
（1）Secondary NameNode询问NameNode是否需要CheckPoint。直接带回NameNode是否检查结果。
（2）Secondary NameNode请求执行CheckPoint。
（3）NameNode滚动正在写的Edits日志。
（4）将滚动前的编辑日志和镜像文件拷贝到Secondary NameNode。
（5）Secondary NameNode加载编辑日志和镜像文件到内存，并合并。
（6）生成新的镜像文件fsimage.chkpoint。
（7）拷贝fsimage.chkpoint到NameNode。
（8）NameNode将fsimage.chkpoint重新命名成fsimage。
翻译与官网（哈哈哈哈）
NN和2NN工作机制详解：
Fsimage：NameNode内存中元数据序列化后形成的文件。
Edits：记录客户端更新元数据信息的每一步操作（可通过Edits运算出元数据）。
NameNode启动时，先滚动Edits并生成一个空的edits.inprogress，然后加载Edits和Fsimage到内存中，此时NameNode内存就持有最新的元数据信息。Client开始对NameNode发送元数据的增删改的请求，这些请求的操作首先会被记录到edits.inprogress中（查询元数据的操作不会被记录在Edits中，因为查询操作不会更改元数据信息），如果此时NameNode挂掉，重启后会从Edits中读取元数据的信息。然后，NameNode会在内存中执行元数据的增删改的操作。
由于Edits中记录的操作会越来越多，Edits文件会越来越大，导致NameNode在启动加载Edits时会很慢，所以需要对Edits和Fsimage进行合并（所谓合并，就是将Edits和Fsimage加载到内存中，照着Edits中的操作一步步执行，最终形成新的Fsimage）。SecondaryNameNode的作用就是帮助NameNode进行Edits和Fsimage的合并工作。
SecondaryNameNode首先会询问NameNode是否需要CheckPoint（触发CheckPoint需要满足两个条件中的任意一个，定时时间到和Edits中数据写满了）。直接带回NameNode是否检查结果。SecondaryNameNode执行CheckPoint操作，首先会让NameNode滚动Edits并生成一个空的edits.inprogress，滚动Edits的目的是给Edits打个标记，以后所有新的操作都写入edits.inprogress，其他未合并的Edits和Fsimage会拷贝到SecondaryNameNode的本地，然后将拷贝的Edits和Fsimage加载到内存中进行合并，生成fsimage.chkpoint，然后将fsimage.chkpoint拷贝给NameNode，重命名为Fsimage后替换掉原来的Fsimage。NameNode在启动时就只需要加载之前未合并的Edits和Fsimage即可，因为合并过的Edits中的元数据信息已经被记录在Fsimage中。
二、CheckPoint时间设置 （1）通常情况下，SecondaryNameNode每隔一小时执行一次。
[hdfs-default.xml]
&lt;property&gt;
&lt;name&gt;dfs.namenode.checkpoint.period&lt;/name&gt;
&lt;value&gt;3600&lt;/value&gt;
&lt;/property&gt;
（2）一分钟检查一次操作次数，当操作次数达到1百万时，SecondaryNameNode执行一次。
&lt;property&gt;
&lt;name&gt;dfs.namenode.checkpoint.txns&lt;/name&gt;
&lt;value&gt;1000000&lt;/value&gt;
&lt;description&gt;操作动作次数&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;dfs.namenode.checkpoint.check.period&lt;/name&gt;
&lt;value&gt;60&lt;/value&gt;
&lt;description&gt; 1分钟检查一次操作次数&lt;/description&gt; &lt;/property &gt;
三、NameNode故障处理 方法一：将SecondaryNameNode中数据拷贝到NameNode存储数据的目录；
方法二：使用-importCheckpoint选项启动NameNode守护进程，从而将SecondaryNameNode中数据拷贝到NameNode目录中。
四、集群安全模式 1.概述 2.基本语法 集群处于安全模式，不能执行重要操作（写操作）。集群启动完成后，自动退出安全模式。
（1）bin/hdfs dfsadmin -safemode get （功能描述：查看安全模式状态）
（2）bin/hdfs dfsadmin -safemode enter （功能描述：进入安全模式状态）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/95f5ce8f3cb50fdcf02724cd60d5ff41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-22T22:43:44+08:00" />
<meta property="article:modified_time" content="2021-04-22T22:43:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HDFS的NameNode和SecondaryNameNode</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、NN 和 2NN 工作机制</h2> 
<p><span style="color:#000000;">NameNode</span><span style="color:#000000;">中的元数据是存储在哪里的？</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        首先，我们做个假设，如果存储在</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。</span><span style="color:#FF0000;">因此产生了磁盘中备份元数据的</span><span style="color:#FF0000;">FsImage</span><span style="color:#FF0000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新</span><span style="color:#000000;">FsImage</span><span style="color:#000000;">，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">节点断电，就会产生数据丢失。</span><span style="color:#FF0000;">因此，引入</span><span style="color:#FF0000;">Edits</span><span style="color:#FF0000;">文件</span><span style="color:#FF0000;">(</span><span style="color:#FF0000;">只进行追加操作，效率很高</span><span style="color:#FF0000;">)</span><span style="color:#FF0000;">。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到</span><span style="color:#FF0000;">Edits</span><span style="color:#FF0000;">中。</span><span style="color:#000000;">这样，一旦</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">节点断电，可以通过</span><span style="color:#000000;">FsImage</span><span style="color:#000000;">和</span><span style="color:#000000;">Edits</span><span style="color:#000000;">的合并，合成元数据。</span></p> 
<p><span style="color:#000000;">        但是，如果长时间添加数据到</span><span style="color:#000000;">Edits</span><span style="color:#000000;">中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行</span><span style="color:#000000;">FsImage</span><span style="color:#000000;">和</span><span style="color:#000000;">Edits</span><span style="color:#000000;">的合并，如果这个操作由</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">节点完成，又会效率过低。</span><span style="color:#FF0000;">因此，引入一个新的节点</span><span style="color:#FF0000;">SecondaryNamenode</span><span style="color:#FF0000;">，专门用于</span><span style="color:#FF0000;">FsImage</span><span style="color:#FF0000;">和</span><span style="color:#FF0000;">Edits</span><span style="color:#FF0000;">的合并。</span></p> 
<p><img alt="" height="573" src="https://images2.imgbox.com/2d/0c/07gfBivh_o.png" width="1089"></p> 
<p>1.第一阶段：NameNode启动</p> 
<p style="margin-left:0cm;">     （1）第一次启动NameNode格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。</p> 
<p style="margin-left:0cm;">     （2）客户端对元数据进行增删改的请求。</p> 
<p style="margin-left:0cm;">     （3）NameNode记录操作日志，更新滚动日志。</p> 
<p style="margin-left:0cm;">     （4）NameNode在内存中对元数据进行增删改。</p> 
<p>2. 第二阶段：Secondary NameNode工作</p> 
<p style="margin-left:0cm;">       （1）<a name="_Hlk515221703">Secondary NameNode</a>询问NameNode是否需要CheckPoint。直接带回NameNode是否检查结果。</p> 
<p style="margin-left:0cm;">       （2）Secondary NameNode请求执行CheckPoint。</p> 
<p style="margin-left:0cm;">       （3）NameNode滚动正在写的Edits日志。</p> 
<p style="margin-left:0cm;">       （4）将滚动前的编辑日志和镜像文件拷贝到Secondary NameNode。</p> 
<p style="margin-left:0cm;">       （5）Secondary NameNode加载编辑日志和镜像文件到内存，并合并。</p> 
<p style="margin-left:0cm;">       （6）生成新的镜像文件fsimage.chkpoint。</p> 
<p style="margin-left:0cm;">       （7）拷贝fsimage.chkpoint到NameNode。</p> 
<p style="margin-left:0cm;">       （8）NameNode将fsimage.chkpoint重新命名成fsimage。</p> 
<p style="margin-left:0cm;">翻译与官网（哈哈哈哈）</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong><span style="color:#FF0000;">NN</span></strong><strong><span style="color:#FF0000;">和</span><span style="color:#FF0000;">2NN</span></strong><strong><span style="color:#FF0000;">工作机制详解：</span></strong></p> <p style="margin-left:0cm;">Fsimage：NameNode内存中元数据序列化后形成的文件。</p> <p style="margin-left:0cm;">Edits：记录客户端更新元数据信息的每一步操作（可通过Edits运算出元数据）。</p> <p style="margin-left:0cm;">NameNode启动时，先滚动Edits并生成一个空的edits.inprogress，然后加载Edits和Fsimage到内存中，此时NameNode内存就持有最新的元数据信息。Client开始对NameNode发送元数据的增删改的请求，这些请求的操作首先会被记录到edits.inprogress中（查询元数据的操作不会被记录在Edits中，因为查询操作不会更改元数据信息），如果此时NameNode挂掉，重启后会从Edits中读取元数据的信息。然后，NameNode会在内存中执行元数据的增删改的操作。</p> <p style="margin-left:0cm;">由于Edits中记录的操作会越来越多，Edits文件会越来越大，导致NameNode在启动加载Edits时会很慢，所以需要对Edits和Fsimage进行合并（所谓合并，就是将Edits和Fsimage加载到内存中，照着Edits中的操作一步步执行，最终形成新的Fsimage）。<span style="color:#FF0000;">SecondaryNameNode</span><span style="color:#FF0000;">的作用就是帮助</span><span style="color:#FF0000;">NameNode</span><span style="color:#FF0000;">进行</span><span style="color:#FF0000;">Edits</span><span style="color:#FF0000;">和</span><span style="color:#FF0000;">Fsimage</span><span style="color:#FF0000;">的合并工作。</span></p> <p style="margin-left:0cm;">SecondaryNameNode首先会询问NameNode是否需要CheckPoint（触发CheckPoint需要满足两个条件中的任意一个，定时时间到和Edits中数据写满了）。直接带回NameNode是否检查结果。SecondaryNameNode执行CheckPoint操作，首先会让NameNode滚动Edits并生成一个空的edits.inprogress，滚动Edits的目的是给Edits打个标记，以后所有新的操作都写入edits.inprogress，其他未合并的Edits和Fsimage会拷贝到SecondaryNameNode的本地，然后将拷贝的Edits和Fsimage加载到内存中进行合并，生成fsimage.chkpoint，然后将fsimage.chkpoint拷贝给NameNode，重命名为Fsimage后替换掉原来的Fsimage。NameNode在启动时就只需要加载之前未合并的Edits和Fsimage即可，因为合并过的Edits中的元数据信息已经被记录在Fsimage中。</p> </td></tr></tbody></table> 
<h2> 二、CheckPoint时间设置</h2> 
<p style="margin-left:0cm;">（1）通常情况下，SecondaryNameNode每隔一小时执行一次。</p> 
<p style="margin-left:0cm;">[hdfs-default.xml]</p> 
<blockquote> 
 <p style="margin-left:0cm;"><span style="color:#000000;">&lt;property&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">  &lt;name&gt;dfs.namenode.checkpoint.period&lt;/name&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">  &lt;value&gt;3600&lt;/value&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">&lt;/property&gt;</span></p> 
</blockquote> 
<p> （2）一分钟检查一次操作次数，当操作次数达到1百万时，SecondaryNameNode执行一次。</p> 
<blockquote> 
 <p style="margin-left:0cm;"><span style="color:#000000;">&lt;property&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">  &lt;name&gt;dfs.namenode.checkpoint.txns&lt;/name&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">  &lt;value&gt;1000000&lt;/value&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">&lt;description&gt;</span><span style="color:#000000;">操作动作次数</span><span style="color:#000000;">&lt;/description&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">&lt;/property&gt;</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">&lt;property&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">  &lt;name&gt;dfs.namenode.checkpoint.check.period&lt;/name&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">  &lt;value&gt;60&lt;/value&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">&lt;description&gt; 1</span><span style="color:#000000;">分钟检查一次操作次数</span><span style="color:#000000;">&lt;/description&gt;</span> </p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">&lt;/property &gt;</span></p> 
</blockquote> 
<h2 style="margin-left:0cm;">三、NameNode故障处理</h2> 
<p style="margin-left:0cm;"><strong>方法一：将SecondaryNameNode中数据拷贝到NameNode</strong><strong>存储数据的目录；</strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">方法二：使用</span><span style="color:#000000;">-importCheckpoint</span></strong><strong><span style="color:#000000;">选项启动</span><span style="color:#000000;">NameNode</span></strong><strong><span style="color:#000000;">守护进程，从而将</span><span style="color:#000000;">SecondaryNameNode</span></strong><strong><span style="color:#000000;">中数据拷贝到</span><span style="color:#000000;">NameNode</span></strong><strong><span style="color:#000000;">目录中。</span></strong></p> 
<h2 style="margin-left:0cm;"><span style="color:#000000;">四、集群安全模式</span></h2> 
<h3><span style="color:#000000;">1.概述</span></h3> 
<p><img alt="" height="492" src="https://images2.imgbox.com/88/62/d58lKUeq_o.png" width="1012"></p> 
<h3><span style="color:#000000;">2.基本语法</span></h3> 
<p>集群处于安全模式，不能执行重要操作（写操作）。集群启动完成后，自动退出安全模式。</p> 
<p style="margin-left:0cm;">（1）<span style="color:#7030a0;">bin/hdfs dfsadmin -safemode get        </span>（功能描述：查看安全模式状态<span style="color:#7030a0;">）</span></p> 
<p style="margin-left:0cm;">（2）<span style="color:#7030a0;">bin/hdfs dfsadmin -safemode enter    </span>（功能描述：进入安全模式状态<span style="color:#7030a0;">）</span></p> 
<p style="margin-left:0cm;">（3）<span style="color:#7030a0;">bin/hdfs dfsadmin -safemode leave     </span>（功能描述：离开安全模式状态<span style="color:#7030a0;">）</span></p> 
<p style="margin-left:0cm;">（4）<span style="color:#7030a0;">bin/hdfs dfsadmin -safemode wait       </span>（功能描述：等待安全模式状态<span style="color:#7030a0;">）</span></p> 
<p style="margin-left:0cm;"> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/066391e3b88bad2428afaaea028e1902/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54176b64f953838e9def03febf70df5f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Shell 数组</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>