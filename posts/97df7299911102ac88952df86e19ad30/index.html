<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32的hex文件格式的分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32的hex文件格式的分析" />
<meta property="og:description" content="前言 最近研究Bootloader，通过串口实现STM32程序的更新。需要学习了解STM32的Hex文件格式。在这进行一下总结。
HEX文件格式 我们通过文本形式打开hex文件，可以看到：
这一行就是一条指令数据，这里对数据帧格式进行说明：
报头本行数据长度数据起始地址数据类型数据校验码:（冒号）1 byte2 byte1 byten byte1 byte 结合这个格式可以发现，它将数值1byte变成了字符串形式的2个字符来表示。
用第一行数据 :020000040800F2 作为示例：
&#34;:&#34; 表示 指令头
&#34;02&#34; 表示 数据部分有两字节（即四个字符）
&#34;0000&#34; 表示 数据的16位起始存储器地址偏移量，是0x0000。数据的物理地址是通过将此偏移量添加到先前建立的基地址来计算的。
&#34;04&#34; 表示 数据类型。基地址
&#34;0800&#34; 表示 数据内容，为 0x08 和 0x00
&#34;F2&#34; 是检验码。LRC校验(纵向冗余校验)：在线LRC校验(纵向冗余校验)计算器 (lddgo.net)
该条语句功能即说明 基地址为0x0800&lt;&lt;16为0x08000000.
后面的数据语句的地址则是在该条语句基地址基础上的偏移量。
第四字节表示数据类型，数据类型有：0x00、0x01、0x02、0x03、0x04、0x05。
数据类型功能描述示例00数据包含数据和该数据的16位起始地址。字节计数指定记录中的数据字节数。右侧显示的示例为0B （十一）个数据字节（61， 64， 64， 72， 65， 73， 73， 20， 67， 61， 70）位于以地址开头的连续地址 0010。:0B0010006164647265737320676170A701文件结束每个文件在文件的最后一行必须恰好发生一次。数据字段为空（因此字节数为00），并且地址字段通常为 0000。:00000001FF02扩展段地址数据字段包含一个16位的段基址（因此字节数始终为02）与80x86实模式寻址兼容。地址字段（通常为0000）被忽略。最近的段地址02记录乘以16，然后加到每个后续数据记录地址，以形成数据的物理起始地址。这允许寻址多达1 MB的地址空间。:020000021200EA03起始段地址对于80x86处理器，请指定CS：IP寄存器的初始内容（即起始执行地址）。地址字段是0000，字节数始终为04，前两个数据字节是CS值，后两个是IP值。:0400000300003800C104扩展线性地址允许32位寻址（最大4GiB）。记录的地址字段将被忽略（通常是0000），其字节数始终为02。两个数据字节（大字节序）为所有后续类型指定32位绝对地址的高16位00记录; 这些高位地址位适用于下一个04记录。类型的绝对地址00 通过组合最近的高16位地址位形成记录 04 用低16位的地址记录 00记录。如果是类型00 记录之前没有任何类型 04 记录，然后其高16位地址位默认为0000。:02000004FFFFFC05起始线性地址地址字段是 0000（未使用），字节数始终为04。四个数据字节代表一个32位地址值（big-endian）。对于80386和更高版本的CPU，此地址将加载到EIP寄存器中。:0400000508000135B9 总结 了解了这个东西，似乎自己也能做一个stm32版本的类似arduino的bootloader了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/97df7299911102ac88952df86e19ad30/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-30T14:13:20+08:00" />
<meta property="article:modified_time" content="2023-10-30T14:13:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32的hex文件格式的分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>        最近研究Bootloader，通过串口实现STM32程序的更新。需要学习了解STM32的Hex文件格式。在这进行一下总结。</p> 
<h2>HEX文件格式</h2> 
<p>我们通过文本形式打开hex文件，可以看到：</p> 
<p> <img alt="" height="472" src="https://images2.imgbox.com/0c/d9/muFis7l8_o.png" width="542"></p> 
<p>这一行就是一条指令数据，这里对数据帧格式进行说明：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>报头</td><td>本行数据长度</td><td>数据起始地址</td><td>数据类型</td><td>数据</td><td>校验码</td></tr><tr><td>:（冒号）</td><td>1 byte</td><td>2 byte</td><td>1 byte</td><td>n byte</td><td>1 byte</td></tr></tbody></table> 
<p>结合这个格式可以发现，它将数值1byte变成了字符串形式的2个字符来表示。</p> 
<blockquote> 
 <p>用第一行数据 :020000040800F2  作为示例：</p> 
 <p>":"  表示  指令头</p> 
 <p>"02" 表示 数据部分有两字节（即四个字符）</p> 
 <p>"0000" 表示 数据的16位起始存储器地址偏移量，是0x0000。数据的物理地址是通过将此偏移量添加到先前建立的基地址来计算的。</p> 
 <p>"04" 表示 数据类型。基地址</p> 
 <p>"0800" 表示 数据内容，为 0x08 和 0x00</p> 
 <p>"F2" 是检验码。LRC校验(纵向冗余校验)：<a href="https://www.lddgo.net/encrypt/lrc" rel="nofollow" title="在线LRC校验(纵向冗余校验)计算器 (lddgo.net)">在线LRC校验(纵向冗余校验)计算器 (lddgo.net)</a></p> 
 <p>该条语句功能即说明 基地址为0x0800&lt;&lt;16为0x08000000.</p> 
 <p>后面的数据语句的地址则是在该条语句基地址基础上的偏移量。</p> 
</blockquote> 
<p>第四字节表示数据类型，数据类型有：0x00、0x01、0x02、0x03、0x04、0x05。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td>数据类型</td><td>功能</td><td>描述</td><td>示例</td></tr><tr><td>00</td><td>数据</td><td>包含数据和该数据的16位起始地址。字节计数指定记录中的数据字节数。右侧显示的示例为0B （十一）个数据字节（61， 64， 64， 72， 65， 73， 73， 20， 67， 61， 70）位于以地址开头的连续地址 0010。</td><td>:0B0010006164647265737320676170A7</td></tr><tr><td>01</td><td>文件结束</td><td>每个文件在文件的最后一行必须恰好发生一次。数据字段为空（因此字节数为00），并且地址字段通常为 0000。</td><td>:00000001FF</td></tr><tr><td>02</td><td>扩展段地址</td><td>数据字段包含一个16位的段基址（因此字节数始终为02）与80x86实模式寻址兼容。地址字段（通常为0000）被忽略。最近的段地址02记录乘以16，然后加到每个后续数据记录地址，以形成数据的物理起始地址。这允许寻址多达1 MB的地址空间。</td><td>:020000021200EA</td></tr><tr><td>03</td><td>起始段地址</td><td>对于80x86处理器，请指定CS：IP寄存器的初始内容（即起始执行地址）。地址字段是0000，字节数始终为04，前两个数据字节是CS值，后两个是IP值。</td><td>:0400000300003800C1</td></tr><tr><td>04</td><td>扩展线性地址</td><td>允许32位寻址（最大4GiB）。记录的地址字段将被忽略（通常是0000），其字节数始终为02。两个数据字节（大字节序）为所有后续类型指定32位绝对地址的高16位00记录; 这些高位地址位适用于下一个04记录。类型的绝对地址00 通过组合最近的高16位地址位形成记录 04 用低16位的地址记录 00记录。如果是类型00 记录之前没有任何类型 04 记录，然后其高16位地址位默认为0000。</td><td>:02000004FFFFFC</td></tr><tr><td>05</td><td>起始线性地址</td><td>地址字段是 0000（未使用），字节数始终为04。四个数据字节代表一个32位地址值（big-endian）。对于80386和更高版本的CPU，此地址将加载到EIP寄存器中。</td><td>:0400000508000135B9</td></tr></tbody></table> 
<hr> 
<h2> 总结</h2> 
<p>了解了这个东西，似乎自己也能做一个stm32版本的类似arduino的bootloader了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9769edc4b66f2810671545491860b372/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux自己搭建远程桌面软件Rustdesk（2023）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5cf8f15d14cae24f107a7292cfcfff9c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据清洗（1）--数据查缺补漏</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>