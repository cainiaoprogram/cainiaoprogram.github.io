<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android Hal 分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android Hal 分析" />
<meta property="og:description" content="Android Hal 分析
-------rockchip Andy
本文是基于android4.0.3.对应其他低版本的代码，可能有所差异，但基本大同小异。
Android的HAL是为了保护一些硬件提供商的知识产权而提出的，是为了避开linux的GPL束缚。思路是把控制硬件的动作都放到了Android HAL中，而linux driver仅仅完成一些简单的数据交互作用，甚至把硬件寄存器空间直接映射到user space。而Android是基于Aparch的license，因此硬件厂商可以只提供二进制代码，所以说Android只是一个开放的平台，并不是一个开源的平台。也许也正是因为Android不遵从GPL，所以Greg Kroah-Hartman才在2.6.33内核将Andorid驱动从linux中删除。GPL和硬件厂商目前还是有着无法弥合的裂痕。Android想要把这个问题处理好也是不容易的。
总结下来，Android HAL存在的原因主要有：
1. 并不是所有的硬件设备都有标准的linux kernel的接口
2. KERNEL DRIVER涉及到GPL的版权。某些设备制造商并不原因公开硬件驱动，所以才去用HAL方 式绕过GPL。
3. 针对某些硬件，An有一些特殊的需求
现有HAL架构由Patrick Brady (Google) 在2008 Google I/O演讲中提出的，如下图：
一、 源码位置
/hardware/libhardware_legacy/ - 旧的架构、采取链接库模块的方式
/hardware/libhardware 新架构、调整为 HAL stub 目录的结构如下：
/hardware/libhardware/hardware.c 编译成libhardware.s置于/system/lib /hardware/libhardware/include/hardware目录下包含如下头文件：
hardware.h 通用硬件模块头文件
copybit.h copybit模块头文件
gralloc.h gralloc模块头文件
lights.h 背光模块头文件
overlay.h overlay模块头文件
qemud.h qemud模块头文件
sensors.h 传感器模块头文件
/hardware/libhardware/modules 目录下定义了很多硬件模块
/hardware/msm7k /hardware/qcom /hardware/ti /device/Samsung /device/moto 各个厂商平台相关的hal
这些硬件模块都编译成xxx.xxx.so，目标位置为/system/lib/hw目录
二、 HAL层的实现方式
目前HAL存在两种构架，位于libhardware_legacy目录下的“旧HAL架构”和位于libhardware目录下的“新HAL架构”。两种框架如下图所示：
libhardware_legacy 是将 *." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/498a14ab4006b103d6fe31352609974d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-01-14T16:16:00+08:00" />
<meta property="article:modified_time" content="2012-01-14T16:16:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android Hal 分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body">
    
 <p>                    <strong>                                                           Android Hal 分析</strong></p> 
 <p><strong>                                                                                                 -------rockchip  Andy</strong></p> 
 <p><strong>       </strong>本文是基于android4.0.3.对应其他低版本的代码，可能有所差异，但基本大同小异。</p> 
 <p>      Android的HAL是为了保护一些硬件提供商的知识产权而提出的，是为了避开linux的GPL束缚。思路是把控制硬件的动作都放到了Android HAL中，而linux driver仅仅完成一些简单的数据交互作用，甚至把硬件寄存器空间直接映射到user space。而Android是基于Aparch的license，因此硬件厂商可以只提供二进制代码，所以说Android只是一个开放的平台，并不是一个开源的平台。也许也正是因为Android不遵从GPL，所以Greg Kroah-Hartman才在2.6.33内核将Andorid驱动从linux中删除。GPL和硬件厂商目前还是有着无法弥合的裂痕。Android想要把这个问题处理好也是不容易的。</p> 
 <p>    总结下来，Android HAL存在的原因主要有：</p> 
 <p>    1. 并不是所有的硬件设备都有标准的linux kernel的接口</p> 
 <p>    2. KERNEL DRIVER涉及到GPL的版权。某些设备制造商并不原因公开硬件驱动，所以才去用HAL方 式绕过GPL。</p> 
 <p>    3. 针对某些硬件，An有一些特殊的需求</p> 
 <p>现有HAL架构由Patrick Brady (Google) 在2008 Google  I/O演讲中提出的，如下图：</p> 
 <p> </p> 
 <p> <img src="https://images2.imgbox.com/ed/4d/mO39flD9_o.gif" alt=""></p> 
 <p><strong>一、       源码位置</strong></p> 
 <p>/hardware/libhardware_legacy/ - 旧的架构、采取链接库模块的方式</p> 
 <p>/hardware/libhardware     新架构、调整为 HAL stub 目录的结构如下：</p> 
 <p>/hardware/libhardware/hardware.c  编译成libhardware.s置于/system/lib </p> 
 <p>/hardware/libhardware/include/hardware目录下包含如下头文件：</p> 
 <p>hardware.h                             通用硬件模块头文件</p> 
 <p>copybit.h                              copybit模块头文件</p> 
 <p>gralloc.h                              gralloc模块头文件</p> 
 <p>lights.h                              背光模块头文件</p> 
 <p>overlay.h                              overlay模块头文件</p> 
 <p>qemud.h                               qemud模块头文件</p> 
 <p>sensors.h                              传感器模块头文件</p> 
 <p>/hardware/libhardware/modules  目录下定义了很多硬件模块</p> 
 <p>/hardware/msm7k  /hardware/qcom  /hardware/ti  /device/Samsung  </p> 
 <p>/device/moto            各个厂商平台相关的hal</p> 
 <p>这些硬件模块都编译成xxx.xxx.so，目标位置为/system/lib/hw目录</p> 
 <p> </p> 
 <p><strong>二、       HAL层的实现方式</strong></p> 
 <p>目前HAL存在两种构架，位于libhardware_legacy目录下的“旧HAL架构”和位于libhardware目录下的“新HAL架构”。两种框架如下图所示：</p> 
 <p> <img src="https://images2.imgbox.com/f9/08/ydGyO3nK_o.gif" alt=""></p> 
 <p>libhardware_legacy 是将 *.so 文件当作shared library来使用，在runtime（JNI 部份）以 direct function call 使用 HAL module。通过直接函数调用的方式，来操作驱动程序。当然，应用程序也可以不需要通过 JNI 的方式进行，直接加载 *.so （dlopen）的做法调用*.so 里的符号（symbol）也是一种方式。总而言之是没有经过封装，上层可以直接操作硬件。</p> 
 <p>    现在的libhardware 架构，就有stub的味道了。HAL stub 是一种代理人（proxy）的概念，stub 虽然仍是以 *.so檔的形式存在，但HAL已经将 *.so 档隐藏起来了。Stub 向 HAL提供操作函数（operations），而 runtime 则是向 HAL 取得特定模块（stub）的 operations，再 callback 这些操作函数。这种以 indirect function call 的架构，让HAL stub 变成是一种包含关系，即 HAL 里包含了许许多多的 stub（代理人）。Runtime 只要说明类型，即 module ID，就可以取得操作函数。对于目前的HAL，可以认为Android定义了HAL层结构框架，通过几个接口访问硬件从而统一了调用方式。</p> 
 <p>Android的HAL的实现需要通过JNI(Java Native Interface)，JNI简单来说就是java程序可以调用C/C++写的动态链接库，这样的话，HAL可以使用C/C++语言编写，效率更高。JNI-&gt;通用硬件模块-&gt;硬件模块-&gt;内核驱动接口，具体一点：JNI-&gt;libhardware.so-&gt;xxx.xxx.so-&gt;kernel，具体来说：android frameworks中JNI调用hardware.c中定义的hw_get_module函数来获取硬件模块，然后调用硬件模块中的方法，硬件模块中的方法直接调用内核接口完成相关功能</p> 
 <p>在Android下访问HAL大致有以下两种方式：</p> 
 <p>   （1）Android的app可以直接通过service调用.so格式的jni</p> 
 <p>      <img src="https://images2.imgbox.com/91/6e/nRMJylIE_o.gif" alt=""></p> 
 <p align="left">  （2）经过Manager调用service</p> 
 <p>     </p> 
 <p> <img src="https://images2.imgbox.com/db/84/yP25Lpjf_o.gif" alt=""></p> 
 <p>上面两种方法应该说是各有优缺点，第一种方法简单高效，但不正规。第二种方法实现起来比较复杂，但更符合目前的Android框架。第二种方法中，LegManager和LedService（java）在两个进程中，需要通过进程通讯的方式来通讯。</p> 
 <p>在现在的android框架中，这两种方式都存在，比如对于lights，是直接透过LightsService调用JNI，而对于sensor，中间则是通过SensorsManager</p> 
 <p>来调用JNI的。</p> 
 <p> </p> 
 <p><strong>1、通用硬件模块(libhardware.so)</strong></p> 
 <p align="left">    一般来说HAL moudle需要涉及的是三个关键结构体：</p> 
 <p align="left">struct hw_module_t;    </p> 
 <p align="left">struct hw_module_methods_t;</p> 
 <p align="left">struct hw_device_t;</p> 
 <p>这三个结构体定义在hardware.h中。</p> 
 <p>(1)头文件为：/hardware/libhardware/include/hardware/hardware.h</p> 
 <p>头文件中主要定义了通用硬件模块结构体hw_module_t，声明了JNI调用的接口函数hw_get_module、hw_module_t定义如下：</p> 
 <p align="left">/**</p> 
 <p align="left">* Every hardware module must have a data structure named HAL_MODULE_INFO_SYM</p> 
 <p align="left"> * and the fields of this data structure must begin with hw_module_t</p> 
 <p align="left"> * followed by module specific information.</p> 
 <p align="left"> */</p> 
 <p align="left">typedef struct hw_module_t {<!-- --></p> 
 <p align="left">/** tag must be initialized to HARDWARE_MODULE_TAG */</p> 
 <p align="left">uint32_t tag;</p> 
 <p align="left"> </p> 
 <p align="left">/** major version number for the module */</p> 
 <p align="left">uint16_t version_major;</p> 
 <p align="left"> </p> 
 <p align="left">/** minor version number of the module */<br>       uint16_t version_minor;</p> 
 <p align="left"> </p> 
 <p align="left">/** Identifier of module */</p> 
 <p align="left">const char *id;</p> 
 <p align="left"> </p> 
 <p align="left">/** Name of this module */</p> 
 <p align="left">const char *name;<br><br></p> 
 <p align="left">/** Author/owner/implementor of the module */</p> 
 <p align="left">const char *author;</p> 
 <p align="left"> </p> 
 <p align="left">/** Modules methods */<br>   struct hw_module_methods_t* methods; //硬件模块的方法</p> 
 <p align="left"> </p> 
 <p align="left">/** module's dso */</p> 
 <p align="left">void* dso;</p> 
 <p align="left"> </p> 
 <p align="left">/** padding to 128 bytes, reserved for future use */</p> 
 <p align="left">uint32_t reserved[32-7];</p> 
 <p align="left">} hw_module_t;</p> 
 <p> </p> 
 <p>如注释所说，所有的hal模块都要有一个以HAL_MODULE_INFO_SYM命名的结构，而且这个结构要以hw_module_t开始，即要继承hw_module_t这个结构，比如lights，sensor：</p> 
 <p align="left">struct sensors_module_t {<!-- --></p> 
 <p align="left"> struct hw_module_t common;</p> 
 <p align="left">int (*get_sensors_list)(struct sensors_module_t* module,</p> 
 <p align="left">            struct sensor_t const** list);</p> 
 <p align="left">};</p> 
 <p align="left">/*</p> 
 <p align="left"> * The lights Module</p> 
 <p align="left"> */</p> 
 <p align="left">struct light_module_t HAL_MODULE_INFO_SYM = {<!-- --></p> 
 <p align="left">    common: {<!-- --></p> 
 <p align="left">        tag: HARDWARE_MODULE_TAG,</p> 
 <p align="left">        version_major: 1,</p> 
 <p align="left">        version_minor: 0,</p> 
 <p align="left">        id: LIGHTS_HARDWARE_MODULE_ID,</p> 
 <p align="left">        name: "Lights module",</p> 
 <p align="left">        author: "Rockchip",</p> 
 <p align="left">        methods: &amp;light_module_methods,</p> 
 <p align="left">    }</p> 
 <p align="left">};</p> 
 <p align="left">const struct sensors_module_t HAL_MODULE_INFO_SYM = {<!-- --></p> 
 <p align="left">    .common = {<!-- --></p> 
 <p align="left">        .tag = HARDWARE_MODULE_TAG,</p> 
 <p align="left">        .version_major = 1,</p> 
 <p align="left">        .version_minor = 0,</p> 
 <p align="left">        .id = SENSORS_HARDWARE_MODULE_ID,</p> 
 <p align="left">        .name = "Stingray SENSORS Module",</p> 
 <p align="left">        .author = "Motorola",</p> 
 <p align="left">        .methods = &amp;sensors_module_methods,</p> 
 <p align="left">    },</p> 
 <p align="left">    .get_sensors_list = sensors__get_sensors_list</p> 
 <p align="left">};</p> 
 <p>hw_module_t中比较重要的是硬件模块方法结构体hw_module_methods_t定义如下：</p> 
 <p align="left">typedef struct hw_module_methods_t {<!-- --></p> 
 <p align="left"> /** Open a specific device */</p> 
 <p align="left">int (*open)(const struct hw_module_t* module, const char* id,</p> 
 <p align="left"> struct hw_device_t** device);</p> 
 <p align="left">} hw_module_methods_t;</p> 
 <p align="left">该方法在定义HAL_MODULE_INFO_SYM的时候被初始化。目前该结构中只定义了一个open方法，其中调用的设备结构体参数hw_device_t定义如下：<br>         /**</p> 
 <p align="left"> * Every device data structure must begin with hw_device_t</p> 
 <p align="left"> * followed by module specific public methods and attributes.</p> 
 <p align="left"> */</p> 
 <p align="left">typedef struct hw_device_t {<!-- --></p> 
 <p align="left">    /** tag must be initialized to HARDWARE_DEVICE_TAG */</p> 
 <p align="left">    uint32_t tag;</p> 
 <p align="left"> </p> 
 <p align="left">    /** version number for hw_device_t */</p> 
 <p align="left">    uint32_t version;</p> 
 <p align="left"> </p> 
 <p align="left">    /** reference to the module this device belongs to */</p> 
 <p align="left">    struct hw_module_t* module;</p> 
 <p align="left"> </p> 
 <p align="left">    /** padding reserved for future use */</p> 
 <p align="left">    uint32_t reserved[12];</p> 
 <p align="left"> </p> 
 <p align="left">    /** Close this device */</p> 
 <p align="left">    int (*close)(struct hw_device_t* device);</p> 
 <p align="left"> </p> 
 <p align="left">} hw_device_t;</p> 
 <p align="left">struct light_device_t {<!-- --></p> 
 <p align="left">    struct hw_device_t common;</p> 
 <p align="left">    int (*set_light)(struct light_device_t* dev,</p> 
 <p align="left">            struct light_state_t const* state);</p> 
 <p align="left">};</p> 
 <p align="left">/**</p> 
 <p align="left"> * Every device data structure must begin with hw_device_t</p> 
 <p align="left"> * followed by module specific public methods and attributes.</p> 
 <p align="left"> */</p> 
 <p align="left">struct sensors_poll_device_t {<!-- --></p> 
 <p align="left">    struct hw_device_t common;</p> 
 <p align="left">    int (*activate)(struct sensors_poll_device_t *dev,</p> 
 <p align="left">            int handle, int enabled);</p> 
 <p align="left">    int (*setDelay)(struct sensors_poll_device_t *dev,</p> 
 <p align="left">            int handle, int64_t ns);</p> 
 <p align="left">    int (*poll)(struct sensors_poll_device_t *dev,</p> 
 <p align="left">            sensors_event_t* data, int count);</p> 
 <p align="left">};</p> 
 <p align="left"> </p> 
 <p>亦如注释所说，每一个设备的数据结构都必须也以hw_device_t开始。hw_get_module函数声明如下：<br>     int hw_get_module(const char *id, const struct hw_module_t **module);<br> 参数id为模块标识，定义在/hardware/libhardware/include/hardware录下的硬件模块头文件中，参数module是硬件模块地址，定义在/hardware/libhardware/include/hardware/hardware.h中</p> 
 <p>下面以lights模块为例进行分析：</p> 
 <p>     在lights.h中定义有lights模块的ID</p> 
 <p>     #define LIGHTS_HARDWARE_MODULE_ID "lights"</p> 
 <p>     在JNI层会通过hw_ge_module()方法获得对应的模块，对于lights，在</p> 
 <p>frameworks/base/services/jni/com_android_server_LightsService.cpp的init_native方法中，代码如下：</p> 
 <p align="left">static jint init_native(JNIEnv *env, jobject clazz)</p> 
 <p align="left">{<!-- --></p> 
 <p align="left">    int err;</p> 
 <p align="left">    hw_module_t* module;</p> 
 <p align="left">    Devices* devices;</p> 
 <p align="left">    devices = (Devices*)malloc(sizeof(Devices));</p> 
 <p align="left"> err = hw_get_module(LIGHTS_HARDWARE_MODULE_ID, (hw_module_t const**)&amp;module);</p> 
 <p align="left">    if (err == 0) {<!-- --></p> 
 <p align="left">        devices-&gt;lights[LIGHT_INDEX_BACKLIGHT]</p> 
 <p align="left">                = get_device(module, LIGHT_ID_BACKLIGHT);</p> 
 <p align="left">………………………………………….</p> 
 <p align="left">}</p> 
 <p> hw_get_module函数在hardware.c中实现：</p> 
 <p align="left">int hw_get_module(const char *id, const struct hw_module_t **module)</p> 
 <p align="left">{<!-- --></p> 
 <p align="left">    return hw_get_module_by_class(id, NULL, module);</p> 
 <p align="left">}</p> 
 <p> 再看hw_get_module_by_class时如何实现的：</p> 
 <p>首先在hardware.c的开始有如下定义和注释：</p> 
 <p align="left">/** Base path of the hal modules */</p> 
 <p align="left">#define HAL_LIBRARY_PATH1 "/system/lib/hw"</p> 
 <p align="left">#define HAL_LIBRARY_PATH2 "/vendor/lib/hw"</p> 
 <p align="left"> </p> 
 <p align="left">/**</p> 
 <p align="left"> * There are a set of variant filename for modules. The form of the filename</p> 
 <p align="left"> * is "&lt;MODULE_ID&gt;.variant.so" so for the led module the Dream variants</p> 
 <p align="left"> * of base "ro.product.board", "ro.board.platform" and "ro.arch" would be:</p> 
 <p align="left"> *</p> 
 <p align="left"> * led.trout.so</p> 
 <p align="left"> * led.msm7k.so</p> 
 <p align="left"> * led.ARMV6.so</p> 
 <p align="left"> * led.default.so</p> 
 <p align="left"> */</p> 
 <p align="left"> </p> 
 <p align="left">static const char *variant_keys[] = {<!-- --></p> 
 <p align="left">    "ro.hardware",  /* This goes first so that it can pick up a different</p> 
 <p align="left">                       file on the emulator. */</p> 
 <p align="left">    "ro.product.board",</p> 
 <p align="left">    "ro.board.platform",</p> 
 <p align="left">    "ro.arch"</p> 
 <p align="left">};</p> 
 <p align="left"> </p> 
 <p align="left">static const int HAL_VARIANT_KEYS_COUNT =</p> 
 <p align="left">    (sizeof(variant_keys)/sizeof(variant_keys[0]));</p> 
 <p> </p> 
 <p align="left">int hw_get_module_by_class(const char *class_id, const char *inst,</p> 
 <p align="left">                           const struct hw_module_t **module)</p> 
 <p align="left">{<!-- --></p> 
 <p align="left">    int status;</p> 
 <p align="left">    int i;</p> 
 <p align="left">    const struct hw_module_t *hmi = NULL;</p> 
 <p align="left">    char prop[PATH_MAX];</p> 
 <p align="left">    char path[PATH_MAX];</p> 
 <p align="left">    char name[PATH_MAX];</p> 
 <p align="left"> </p> 
 <p align="left">    if (inst)</p> 
 <p align="left">        snprintf(name, PATH_MAX, "%s.%s", class_id, inst);</p> 
 <p align="left">    else</p> 
 <p align="left">        strlcpy(name, class_id, PATH_MAX);</p> 
 <p align="left"> </p> 
 <p align="left">    /*</p> 
 <p align="left">     * Here we rely on the fact that calling dlopen multiple times on</p> 
 <p align="left">     * the same .so will simply increment a refcount (and not load</p> 
 <p align="left">     * a new copy of the library).</p> 
 <p align="left">     * We also assume that dlopen() is thread-safe.</p> 
 <p align="left">     */</p> 
 <p align="left"> </p> 
 <p align="left">    /* Loop through the configuration variants looking for a module */</p> 
 <p align="left">    for (i=0 ; i&lt;HAL_VARIANT_KEYS_COUNT+1 ; i++) {<!-- --></p> 
 <p align="left">        if (i &lt; HAL_VARIANT_KEYS_COUNT) {<!-- --></p> 
 <p align="left">            if (property_get(variant_keys[i], prop, NULL) == 0) {<!-- --></p> 
 <p align="left">                continue;</p> 
 <p align="left">            }</p> 
 <p align="left">            snprintf(path, sizeof(path), "%s/%s.%s.so",</p> 
 <p align="left">                     HAL_LIBRARY_PATH2, name, prop);</p> 
 <p align="left">            if (access(path, R_OK) == 0) break;</p> 
 <p align="left"> </p> 
 <p align="left">            snprintf(path, sizeof(path), "%s/%s.%s.so",</p> 
 <p align="left">                     HAL_LIBRARY_PATH1, name, prop);</p> 
 <p align="left">            if (access(path, R_OK) == 0) break;</p> 
 <p align="left">        } else {<!-- --></p> 
 <p align="left">            snprintf(path, sizeof(path), "%s/%s.default.so",</p> 
 <p align="left">                     HAL_LIBRARY_PATH1, name);</p> 
 <p align="left">            if (access(path, R_OK) == 0) break;</p> 
 <p align="left">        }</p> 
 <p align="left">    }</p> 
 <p align="left"> </p> 
 <p align="left">    status = -ENOENT;</p> 
 <p align="left">    if (i &lt; HAL_VARIANT_KEYS_COUNT+1) {<!-- --></p> 
 <p align="left">        /* load the module, if this fails, we're doomed, and we should not try</p> 
 <p align="left">         * to load a different variant. */</p> 
 <p align="left">        status = load(class_id, path, module);</p> 
 <p align="left">    }</p> 
 <p align="left"> </p> 
 <p align="left">    return status;</p> 
 <p align="left">}</p> 
 <p>可以看到，在hw_get_module_by_class函数中，先通过property_get获得varient_key中定义的系统属性，如果系统中有定义该属性，就会获得一个模块名.属性名组成的一个so的名称，然后去定义两个patch(/system/lib/hw、/vendor/lib/hw)下查看，该so是否存在，如果存在，几回调用load函数，打开.so.例如在rockchip的rk29平台上，有定义ro.product.board = rk29sdk，在这里会得到lights.rk29sdk.so。</p> 
 <p> 再看load函数的实现：</p> 
 <p align="left">  /**</p> 
 <p align="left"> * Load the file defined by the variant and if successful</p> 
 <p align="left"> * return the dlopen handle and the hmi.</p> 
 <p align="left"> * @return 0 = success, !0 = failure.</p> 
 <p align="left"> */</p> 
 <p align="left">static int load(const char *id,const char *path,</p> 
 <p align="left">                const struct hw_module_t **pHmi)</p> 
 <p align="left">{<!-- --></p> 
 <p align="left">    int status;</p> 
 <p align="left">    void *handle;</p> 
 <p align="left">    struct hw_module_t *hmi;</p> 
 <p align="left"> </p> 
 <p align="left">    /*</p> 
 <p align="left">     * load the symbols resolving undefined symbols before</p> 
 <p align="left">     * dlopen returns. Since RTLD_GLOBAL is not or'd in with</p> 
 <p align="left">     * RTLD_NOW the external symbols will not be global</p> 
 <p align="left">     */</p> 
 <p align="left">    handle = dlopen(path, RTLD_NOW);</p> 
 <p align="left">    if (handle == NULL) {<!-- --></p> 
 <p align="left">        char const *err_str = dlerror();</p> 
 <p align="left">        LOGE("load: module=%s\n%s", path, err_str?err_str:"unknown");</p> 
 <p align="left">        status = -EINVAL;</p> 
 <p align="left">        goto done;</p> 
 <p align="left">    }</p> 
 <p align="left"> </p> 
 <p align="left">    /* Get the address of the struct hal_module_info. */</p> 
 <p align="left">    const char *sym = HAL_MODULE_INFO_SYM_AS_STR;</p> 
 <p align="left">    hmi = (struct hw_module_t *)dlsym(handle, sym);</p> 
 <p align="left">    if (hmi == NULL) {<!-- --></p> 
 <p align="left">        LOGE("load: couldn't find symbol %s", sym);</p> 
 <p align="left">        status = -EINVAL;</p> 
 <p align="left">        goto done;</p> 
 <p align="left">    }</p> 
 <p align="left"> </p> 
 <p align="left">    /* Check that the id matches */</p> 
 <p align="left">    if (strcmp(id, hmi-&gt;id) != 0) {<!-- --></p> 
 <p align="left">        LOGE("load: id=%s != hmi-&gt;id=%s", id, hmi-&gt;id);</p> 
 <p align="left">        status = -EINVAL;</p> 
 <p align="left">        goto done;</p> 
 <p align="left">    }</p> 
 <p align="left"> </p> 
 <p align="left">    hmi-&gt;dso = handle;</p> 
 <p align="left"> </p> 
 <p align="left">    /* success */</p> 
 <p align="left">    status = 0;</p> 
 <p align="left"> </p> 
 <p align="left">    done:</p> 
 <p align="left">    if (status != 0) {<!-- --></p> 
 <p align="left">        hmi = NULL;</p> 
 <p align="left">        if (handle != NULL) {<!-- --></p> 
 <p align="left">            dlclose(handle);</p> 
 <p align="left">            handle = NULL;</p> 
 <p align="left">        }</p> 
 <p align="left">    } else {<!-- --></p> 
 <p align="left">        LOGV("loaded HAL id=%s path=%s hmi=%p handle=%p",</p> 
 <p align="left">                id, path, *pHmi, handle);</p> 
 <p align="left">    }</p> 
 <p align="left"> </p> 
 <p align="left">    *pHmi = hmi;</p> 
 <p align="left"> </p> 
 <p align="left">    return status;</p> 
 <p align="left">}</p> 
 <p>   在这里会打开对应了so，比如lights.rk29sdk.so,然后获得这个模块中定义的hw_module_t的地址。后面JNI就能通过这个接口和hal层进行沟通了。</p> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/armlinux/archive/2012/01/14/2396768.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b836062df7da75286d4ecc2b75254a03/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux下的C语言开发（开篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a972eee3401edae1275ad424ea00341c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android-sharedUserId数据权限</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>