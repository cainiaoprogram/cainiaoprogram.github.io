<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的适配器模式（Adapter Pattern） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中的适配器模式（Adapter Pattern）" />
<meta property="og:description" content="Java中的适配器模式（Adapter Pattern） 简介： 适配器模式（Adapter Pattern）是一种常用的设计模式，用于将一个类的接口转换成客户端所期望的另一个接口。在Java中，适配器模式可以帮助我们解决不兼容接口之间的问题，提供一种灵活的方式来重用现有的类。
作用： 适配器模式的主要作用是使不兼容的接口能够协同工作。它通过将一个类的接口转换成另一个类的接口，使得原本由于接口不匹配而无法在一起工作的类能够合作。适配器模式可以有效地将现有类库、第三方组件或旧系统与新系统进行集成，从而提高代码的复用性和可维护性。
优势： 代码重用：适配器模式允许我们重用现有的类，而不需要修改其原始代码。通过适配器，我们可以将这些类纳入到新的系统中，无需进行大规模的重构。
系统扩展：适配器模式允许我们在不修改现有代码的情况下，扩展系统的功能。通过添加适配器类，我们可以引入新的接口或类，并使其与现有代码无缝集成。
接口转换：适配器模式提供了一种接口转换的方式，使得不兼容的接口能够协同工作。这样，我们可以将不同的接口统一起来，简化系统的复杂度。
应用场景： 适配器模式在以下情况下特别有用：
老旧代码的重用：当我们需要在新的系统中重用旧有的代码时，适配器模式可以帮助我们无缝集成这些代码，并与新代码协同工作。
第三方组件的集成：当我们需要使用某个第三方组件，但其接口与我们的系统不兼容时，适配器模式可以提供一个适配器，将第三方组件的接口转换为我们所期望的接口。
接口转换：当我们需要将一个接口转换成另一个接口时，适配器模式可以提供一种简单而灵活的解决方案。这对于系统的整合和扩展非常有帮助。
总结：
适配器模式在Java中是一种常用的设计模式，用于解决不兼容接口之间的问题。它可以帮助我们重用现有的类，扩展系统的功能，并提供接口转换的能力。适配器模式适用于需要将旧有代码与新代码无缝集成的情况，以及需要将不兼容接口转换为兼容接口的情况。通过适配器模式，我们可以提高代码的复用性、可维护性和系统的灵活性。
举例说明 假设我们有一个旧的音频播放器接口 OldAudioPlayer，它定义了播放音频文件的方法 playAudio(String fileName)，但我们希望使用一个新的音频播放器类 NewAudioPlayer，它具有不同的接口 play(String audioType, String fileName)。
这时候就可以使用适配器模式来解决接口不兼容的问题。我们可以创建一个适配器类 AudioPlayerAdapter，它实现了新的音频播放器接口 NewAudioPlayer，并且内部持有一个旧的音频播放器对象 OldAudioPlayer。适配器类会将新接口的方法转换为调用旧接口的方法，从而实现对新旧接口的适配。
下面是适配器模式在Java中的示例代码：
// 旧的音频播放器接口 interface OldAudioPlayer { void playAudio(String fileName); } // 旧的音频播放器实现类 class OldAudioPlayerImpl implements OldAudioPlayer { public void playAudio(String fileName) { System.out.println(&#34;Playing audio file: &#34; &#43; fileName); } } // 新的音频播放器接口 interface NewAudioPlayer { void play(String audioType, String fileName); } // 适配器类 class AudioPlayerAdapter implements NewAudioPlayer { private OldAudioPlayer oldAudioPlayer; public AudioPlayerAdapter(OldAudioPlayer oldAudioPlayer) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2a311e2b68494dd72453654af2195a63/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-03T09:00:00+08:00" />
<meta property="article:modified_time" content="2023-06-03T09:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的适配器模式（Adapter Pattern）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="JavaAdapter_Pattern_0"></a>Java中的适配器模式（Adapter Pattern）</h2> 
<h2><a id="_2"></a>简介：</h2> 
<p>适配器模式（Adapter Pattern）是一种常用的设计模式，用于将一个类的接口转换成客户端所期望的另一个接口。在Java中，适配器模式可以帮助我们解决不兼容接口之间的问题，提供一种灵活的方式来重用现有的类。</p> 
<h2><a id="_6"></a>作用：</h2> 
<p>适配器模式的主要作用是使不兼容的接口能够协同工作。它通过将一个类的接口转换成另一个类的接口，使得原本由于接口不匹配而无法在一起工作的类能够合作。适配器模式可以有效地将现有类库、第三方组件或旧系统与新系统进行集成，从而提高代码的复用性和可维护性。</p> 
<h2><a id="_10"></a>优势：</h2> 
<ol><li> <p>代码重用：适配器模式允许我们重用现有的类，而不需要修改其原始代码。通过适配器，我们可以将这些类纳入到新的系统中，无需进行大规模的重构。</p> </li><li> <p>系统扩展：适配器模式允许我们在不修改现有代码的情况下，扩展系统的功能。通过添加适配器类，我们可以引入新的接口或类，并使其与现有代码无缝集成。</p> </li><li> <p>接口转换：适配器模式提供了一种接口转换的方式，使得不兼容的接口能够协同工作。这样，我们可以将不同的接口统一起来，简化系统的复杂度。</p> </li></ol> 
<h2><a id="_19"></a>应用场景：</h2> 
<p>适配器模式在以下情况下特别有用：</p> 
<ol><li> <p>老旧代码的重用：当我们需要在新的系统中重用旧有的代码时，适配器模式可以帮助我们无缝集成这些代码，并与新代码协同工作。</p> </li><li> <p>第三方组件的集成：当我们需要使用某个第三方组件，但其接口与我们的系统不兼容时，适配器模式可以提供一个适配器，将第三方组件的接口转换为我们所期望的接口。</p> </li><li> <p>接口转换：当我们需要将一个接口转换成另一个接口时，适配器模式可以提供一种简单而灵活的解决方案。这对于系统的整合和扩展非常有帮助。</p> </li></ol> 
<p>总结：<br> 适配器模式在Java中是一种常用的设计模式，用于解决不兼容接口之间的问题。它可以帮助我们重用现有的类，扩展系统的功能，并提供接口转换的能力。适配器模式适用于需要将旧有代码与新代码无缝集成的情况，以及需要将不兼容接口转换为兼容接口的情况。通过适配器模式，我们可以提高代码的复用性、可维护性和系统的灵活性。</p> 
<h2><a id="_33"></a>举例说明</h2> 
<p>假设我们有一个旧的音频播放器接口 OldAudioPlayer，它定义了播放音频文件的方法 playAudio(String fileName)，但我们希望使用一个新的音频播放器类 NewAudioPlayer，它具有不同的接口 play(String audioType, String fileName)。</p> 
<p>这时候就可以使用适配器模式来解决接口不兼容的问题。我们可以创建一个适配器类 AudioPlayerAdapter，它实现了新的音频播放器接口 NewAudioPlayer，并且内部持有一个旧的音频播放器对象 OldAudioPlayer。适配器类会将新接口的方法转换为调用旧接口的方法，从而实现对新旧接口的适配。</p> 
<p>下面是适配器模式在Java中的示例代码：</p> 
<pre><code>// 旧的音频播放器接口
interface OldAudioPlayer {
    void playAudio(String fileName);
}

// 旧的音频播放器实现类
class OldAudioPlayerImpl implements OldAudioPlayer {
    public void playAudio(String fileName) {
        System.out.println("Playing audio file: " + fileName);
    }
}

// 新的音频播放器接口
interface NewAudioPlayer {
    void play(String audioType, String fileName);
}

// 适配器类
class AudioPlayerAdapter implements NewAudioPlayer {
    private OldAudioPlayer oldAudioPlayer;

    public AudioPlayerAdapter(OldAudioPlayer oldAudioPlayer) {
        this.oldAudioPlayer = oldAudioPlayer;
    }

    public void play(String audioType, String fileName) {
        if (audioType.equals("mp3")) {
            oldAudioPlayer.playAudio(fileName);
        } else {
            System.out.println("Unsupported audio type: " + audioType);
        }
    }
}

// 新的音频播放器实现类
class NewAudioPlayerImpl implements NewAudioPlayer {
    public void play(String audioType, String fileName) {
        System.out.println("Playing " + audioType + " file: " + fileName);
    }
}

// 测试代码
public class Main {
    public static void main(String[] args) {
        // 使用适配器将旧的音频播放器适配为新的音频播放器
        OldAudioPlayer oldAudioPlayer = new OldAudioPlayerImpl();
        NewAudioPlayer newAudioPlayer = new AudioPlayerAdapter(oldAudioPlayer);

        // 使用新的音频播放器播放音频文件
        newAudioPlayer.play("mp3", "song.mp3");
        newAudioPlayer.play("mp4", "movie.mp4"); // 不支持的格式，适配器会忽略
    }
}

</code></pre> 
<p>在上述示例中，我们通过创建适配器类 AudioPlayerAdapter，将旧的音频播放器接口 OldAudioPlayer 适配到新的音频播放器接口 NewAudioPlayer 上。这样，我们可以使用新的音频播放器来播放音频文件，并且通过适配器转换调用了旧的音频播放器的方法。</p> 
<p>通过适配器模式，我们成功地将不兼容的接口进行了适配，实现了新旧接口的协同工作。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a5f0264325c0e4a831fe764de81c201/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">刘知远团队提出：如何通过扩大高质量指导性对话数据集，来提高模型的性能和效率...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8163464f481cacb7c45d24903d4bf2ae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c# mudbus TCP协议</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>