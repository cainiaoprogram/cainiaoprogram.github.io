<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java设计模式之单例模式（Singleton Pattern） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java设计模式之单例模式（Singleton Pattern）" />
<meta property="og:description" content="目录
单例模式的概念
单例模式的要点
单例模式类图
单例模式归类
单例模式的应用场景
单例模式解决的问题
单例模式的实现方式
单例模式实现方式对比
单例模式的概念 单例模式，顾名思义就是只有一个实例，并且由它自己负责创建自己的对象，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象
单例模式的要点 1、一个类有且仅有一个实例
这个是单例模式的的精髓所在，如何保证类的实例有且只有一个是单例模式必须要保证的，单例实现的所有方式都是围绕着这个出发点来展开的
2、必须自行创建这个实例
在java中，通常是将类的构造方法私有化，从而保证无法在外部进行创建实例
3、必须自行向整个系统提供这个实例
在java中，是通过类的静态方法获取类的实例
单例模式类图 单例模式归类 单例模式属于创建型模式的一种
单例模式的应用场景 单例模式可以说无论是在我们的生活中，还是工作中，都有许多的应用场景，例如：
1、我们使用的电脑里的回收站
2、Spring的抽象工厂
3、日常开发用的工具类
单例模式解决的问题 全局使用的类的实例被频繁的创建和销毁，如果这些类的实例创建和销毁非常消耗性能，对系统来说无疑增加了负担
单例模式的实现方式 1、饿汉式
预创建实例，不管实例有没有用到。
代码实现：
public final class SingletonEHS { private static final SingletonEHS singleton = new SingletonEHS(); private SingletonEHS() {} public static SingletonEHS getInstance() { return singleton; } } 延迟初始化：否，由于实例是预创建的，所以没有达到延迟初始化的效果
线程安全：是，基于 classloader 机制避免了多线程的同步问题
反射破解：可破解
@Test public void testSingletonEHS() { try { Constructor&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f5b6c1858c044bb1463d6c5c7f136d82/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-04T17:26:13+08:00" />
<meta property="article:modified_time" content="2020-08-04T17:26:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java设计模式之单例模式（Singleton Pattern）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"> </p> 
<p><strong>目录</strong></p> 
<p id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">单例模式的概念</a></p> 
<p id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A6%81%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A6%81%E7%82%B9" rel="nofollow">单例模式的要点</a></p> 
<p id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE" rel="nofollow">单例模式类图</a></p> 
<p id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB" rel="nofollow">单例模式归类</a></p> 
<p id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">单例模式的应用场景</a></p> 
<p id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">单例模式解决的问题</a></p> 
<p id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow">单例模式的实现方式</a></p> 
<p id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94" rel="nofollow">单例模式实现方式对比</a></p> 
<hr id="hr-toc"> 
<h3>单例模式的概念</h3> 
<p>单例模式，顾名思义就是只有一个实例，并且由它自己负责创建自己的对象，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</p> 
<h3 id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A6%81%E7%82%B9">单例模式的要点</h3> 
<p>1、一个类有且仅有一个实例</p> 
<p>这个是单例模式的的精髓所在，如何保证类的实例有且只有一个是单例模式必须要保证的，单例实现的所有方式都是围绕着这个出发点来展开的</p> 
<p>2、必须自行创建这个实例</p> 
<p>在java中，通常是将类的构造方法私有化，从而保证无法在外部进行创建实例</p> 
<p>3、必须自行向整个系统提供这个实例</p> 
<p>在java中，是通过类的静态方法获取类的实例</p> 
<h3 id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE">单例模式类图</h3> 
<p><img alt="" height="150" src="https://images2.imgbox.com/c4/fa/Pgyl7gRs_o.png" width="210"></p> 
<h3 id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB">单例模式归类</h3> 
<p>单例模式属于创建型模式的一种</p> 
<h3 id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">单例模式的应用场景</h3> 
<p>单例模式可以说无论是在我们的生活中，还是工作中，都有许多的应用场景，例如：</p> 
<p>1、我们使用的电脑里的回收站</p> 
<p>2、Spring的抽象工厂</p> 
<p>3、日常开发用的工具类</p> 
<h3 id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">单例模式解决的问题</h3> 
<p>全局使用的类的实例被频繁的创建和销毁，如果这些类的实例创建和销毁非常消耗性能，对系统来说无疑增加了负担</p> 
<h3 id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">单例模式的实现方式</h3> 
<p>1、饿汉式</p> 
<p>预创建实例，不管实例有没有用到。</p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-java">public final class SingletonEHS {

    private static final SingletonEHS singleton = new SingletonEHS();
    private SingletonEHS() {}
    public static SingletonEHS getInstance() {
        return singleton;
    }
}</code></pre> 
<p><strong>延迟初始化：</strong>否，由于实例是预创建的，所以没有达到延迟初始化的效果</p> 
<p><strong>线程安全：</strong>是，基于 classloader 机制避免了多线程的同步问题</p> 
<p><strong>反射破解：</strong>可破解</p> 
<pre><code class="language-java">@Test
public void testSingletonEHS() {

    try {
        Constructor&lt;? extends SingletonEHS&gt; declaredConstructor = SingletonEHS.class.getDeclaredConstructor(null);
        declaredConstructor.setAccessible(true);
        SingletonEHS singletonReflect = declaredConstructor.newInstance();
        SingletonEHS singletonReflect1 = declaredConstructor.newInstance();
        System.out.println("反射获取实例：" + singletonReflect);
        System.out.println("反射获取实例_1：" + singletonReflect1);
        System.out.println(singletonReflect == singletonReflect1);
    } catch (NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {
        e.printStackTrace();
    }
}</code></pre> 
<pre><code class="language-java">反射获取实例：com.cn87.constants.test.designpattern.singleton.SingletonEHS@543c6f6d
反射获取实例_1：com.cn87.constants.test.designpattern.singleton.SingletonEHS@13eb8acf
false
</code></pre> 
<p><strong>序列化破解：</strong>可破解</p> 
<pre><code class="language-java">序列化实例：com.cn87.constants.test.designpattern.singleton.SingletonDCL@75881071
反序列化实例：com.cn87.constants.test.designpattern.singleton.SingletonDCL@1efee8e7
false</code></pre> 
<p>2、懒汉式</p> 
<p>实例在使用的时候才去创建。</p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-java">public final class SingletonLHS {

    private static SingletonLHS singleton;
    private SingletonLHS() {}
    public static SingletonLHS getInstance() {

        if (singleton == null) {
            singleton = new SingletonLHS();
        }
        return singleton;
    }
}</code></pre> 
<p>严格意义上来讲，这种不属于单例模式，因为无法避免多线程同步问题。所以衍生了下面这种写法。</p> 
<pre><code class="language-java">public final class SingletonLHS {

    private static SingletonLHS singleton;
    private SingletonLHS() {}
    public static synchronized SingletonLHS getInstance() {

        if (singleton == null) {
            singleton = new SingletonLHS();
        }
        return singleton;
    }
}</code></pre> 
<p>通过synchronized关键字解决了多线程访问getInstance方法获取多个实例的问题。但是由于synchronized锁的粒度较大，在高并发环境下会产生锁竞争问题。于是又派生出了下面的DCL单例实现。DCL意为double check lock 双检锁。</p> 
<pre><code class="language-java">/**
 * 声明final是为了不被继承
 */
public final class SingletonDCL {
    /**
     * volatile 防止指令重排序
     */
    private static volatile SingletonDCL singleton;

    /**
     * 私有化构造方法，阻止在外部创建实例
     */
    private SingletonDCL() {}

    /**
     * 提供获取唯一实例的静态方法
     */
    public static SingletonDCL getInstance() {
        //double check
        if (singleton == null) {
            //lock
            synchronized (SingletonDCL.class) {
                //double check
                if (singleton == null) {
                    singleton = new SingletonDCL();
                }
            }
        }
        return singleton;
    }
}</code></pre> 
<p>DCL单例不但避免了多线程下多个实例的创建，同时又降低了锁的粒度，在多线程情况下能保持高性能。volatile关键字的引入更是锦上添花，对单例对象有特殊要求的业务场景不妨尝试一下。</p> 
<p><strong>延迟初始化：</strong>是</p> 
<p><strong>线程安全：</strong>是</p> 
<p><strong>反射破解：</strong>可破解，同饿汉式</p> 
<p><strong>序列化破解：</strong>可破解</p> 
<p>3、登记式/静态内部类</p> 
<p>静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-java">public final class SingletonInnerClass {

    private static class SingletonHolder {
        private static final SingletonInnerClass singleton = new SingletonInnerClass();
    }

    public static SingletonInnerClass getInstance() {
        return SingletonHolder.singleton;
    }
}</code></pre> 
<p><strong>延迟初始化：</strong>是</p> 
<p><strong>线程安全：</strong>是</p> 
<p><strong>反射破解：</strong>可破解，同饿汉式</p> 
<p><strong>序列化破解：</strong>可破解</p> 
<p>4、枚举</p> 
<p>枚举的方式是比较少见的一种实现方式，但是看上面的代码实现，却更简洁清晰。并且她还自动支持序列化机制，绝对防止多次实例化。</p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-java">public class SingletonEnum {

    private SingletonEnum() {}

    private enum Singleton {
        INSTANCE;
        private final Gson gson;
        Singleton() {
            gson = new Gson();
        }

        public Gson getInstance() {
            return gson;
        }
    }
    
    public static Gson getInstance() {
        return Singleton.INSTANCE.getInstance();
    }
}</code></pre> 
<p><strong>延迟初始化：</strong>否</p> 
<p><strong>线程安全：</strong>是</p> 
<p><strong>反射破解：</strong>不可破解</p> 
<p>由于枚举没有无参构造，只有如下一个构造方法</p> 
<pre><code class="language-java">protected Enum(String name, int ordinal) {
    this.name = name;
    this.ordinal = ordinal;
}</code></pre> 
<p>但是JDK反射机制内部完全禁止了用反射创建枚举实例的可能性，所以反射破解在枚举单例中是不存在的 </p> 
<pre><code class="language-java">//通过有参构造反射创建枚举会报如下异常
Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects
    at java.lang.reflect.Constructor.newInstance(Constructor.java:417)
    at me.lmagics.singleton.SingletonAttack.reflectionAttack(SingletonAttack.java:38)
    at me.lmagics.singleton.SingletonAttack.main(SingletonAttack.java:19)

//这是因为反射机制禁止创建枚举类型
if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)
    throw new IllegalArgumentException("Cannot reflectively create enum objects");</code></pre> 
<p><strong>序列化破解：</strong>不可破解</p> 
<p>对Enum的反序列化过程中，对枚举类型有一个专门的readEnum()方法来处理</p> 
<pre><code class="language-java">private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException {
	...
    //获取枚举value的name，即INSTANCE
	String name = readString(false);
	Enum&lt;?&gt; result = null;
	Class&lt;?&gt; cl = desc.forClass();
	if (cl != null) {
		try {
			@SuppressWarnings("unchecked")
            //通过Enum.valueOf根据枚举类型和枚举值的名字，获得最终的单例
			Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);
			result = en;
		} catch (IllegalArgumentException ex) {
			throw (IOException) new InvalidObjectException(
				"enum constant " + name + " does not exist in " +
				cl).initCause(ex);
		}
		if (!unshared) {
			handles.setObject(enumHandle, result);
		}
	}

    ...
	return result;
}</code></pre> 
<h3 id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94">单例模式实现方式对比</h3> 
<p><img alt="" src="https://images2.imgbox.com/83/f4/W7zElVTA_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/73a6bd74251df901e56461000389a7a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">spring boot中实现动态定时任务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4aff30d7387cc923b1f12cf217a76144/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GROMACS使用小计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>