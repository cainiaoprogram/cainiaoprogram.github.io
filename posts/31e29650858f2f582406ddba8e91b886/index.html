<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入学习JVM（Java虚拟机） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入学习JVM（Java虚拟机）" />
<meta property="og:description" content="目录
一.JDK、JRE、JVM的关系
1.1JDK(Java SE Development Kit)
1.2JRE( Java Runtime Environment)
1.3JVM(Java Virtual Machine)
1.4JDK、JRE、JVM的区别与联系
二.Class的生命周期
2.1加载
2.1.1 类加载器
2.1.2类加载机制
2.1.3双亲委派
2.2链接
2.2.1验证
2.2.2准备
2.2.3解析
2.3初始化
2.4使用
2.5卸载
三.JVM 内存模型
3.1.运行时数据区
四.垃圾回收机制
一.JDK、JRE、JVM的关系 Java 程序是运行在 JVM(Java 虚拟机)上的，在开发程序之前都要配置 Java 开发环境，其中首先要做的就是 JDK 的安装和配置，那么 JDK、JVM、JRE 到底有何联系和区别呢？想必并不是每一个程序员都能说得清楚的，接下来将带你了解它们之间的关系。
1.1JDK(Java SE Development Kit) Java标准开发工具包，它提供了编译、运行 Java 程序所需的各种工具和资源，包括 Java 编译器、Java 运行时环境，以及常用的 Java 类库等。下图是 JDK 的安装目录：
1.2JRE( Java Runtime Environment) Java 运行环境，用于解释执行 Java 的字节码文件。普通用户而只需要安装 JRE就能够Java 程序。而程序开发者必须安装 JDK 来编译、调试程序。下图是 JRE 的安装目录：里面有两个文件夹 bin 和 lib，在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 jvm 和 lib 和起来就称为 jre。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/31e29650858f2f582406ddba8e91b886/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-26T14:58:04+08:00" />
<meta property="article:modified_time" content="2023-09-26T14:58:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入学习JVM（Java虚拟机）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.JDK%E3%80%81JRE%E3%80%81JVM%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#%E4%B8%80.JDK%E3%80%81JRE%E3%80%81JVM%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">一.JDK、JRE、JVM的关系</a></p> 
<p id="1.1JDK(Java%20SE%20Development%20Kit)-toc" style="margin-left:80px;"><a href="#1.1JDK%28Java%20SE%20Development%20Kit%29" rel="nofollow">1.1JDK(Java SE Development Kit)</a></p> 
<p id="1.2JRE(%20Java%20Runtime%20Environment)-toc" style="margin-left:80px;"><a href="#1.2JRE%28%20Java%20Runtime%20Environment%29" rel="nofollow">1.2JRE( Java Runtime Environment)</a></p> 
<p id="1.3JVM(Java%20Virtual%20Machine)-toc" style="margin-left:80px;"><a href="#1.3JVM%28Java%20Virtual%20Machine%29" rel="nofollow">1.3JVM(Java Virtual Machine)</a></p> 
<p id="1.4JDK%E3%80%81JRE%E3%80%81JVM%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB-toc" style="margin-left:80px;"><a href="#1.4JDK%E3%80%81JRE%E3%80%81JVM%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB" rel="nofollow">1.4JDK、JRE、JVM的区别与联系</a></p> 
<p id="%E4%BA%8C.Class%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C.Class%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">二.Class的生命周期</a></p> 
<p id="2.1%E5%8A%A0%E8%BD%BD-toc" style="margin-left:80px;"><a href="#2.1%E5%8A%A0%E8%BD%BD" rel="nofollow">2.1加载</a></p> 
<p id="2.1.1%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-toc" style="margin-left:120px;"><a href="#2.1.1%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8" rel="nofollow">2.1.1 类加载器</a></p> 
<p id="2.1.2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-toc" style="margin-left:120px;"><a href="#2.1.2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6" rel="nofollow">2.1.2类加载机制</a></p> 
<p id="2.1.3%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE-toc" style="margin-left:120px;"><a href="#2.1.3%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE" rel="nofollow">2.1.3双亲委派</a></p> 
<p id="2.2%E9%93%BE%E6%8E%A5-toc" style="margin-left:80px;"><a href="#2.2%E9%93%BE%E6%8E%A5" rel="nofollow">2.2链接</a></p> 
<p id="2.2.1%E9%AA%8C%E8%AF%81-toc" style="margin-left:120px;"><a href="#2.2.1%E9%AA%8C%E8%AF%81" rel="nofollow">2.2.1验证</a></p> 
<p id="2.2.2%E5%87%86%E5%A4%87-toc" style="margin-left:120px;"><a href="#2.2.2%E5%87%86%E5%A4%87" rel="nofollow">2.2.2准备</a></p> 
<p id="2.2.3%E8%A7%A3%E6%9E%90-toc" style="margin-left:120px;"><a href="#2.2.3%E8%A7%A3%E6%9E%90" rel="nofollow">2.2.3解析</a></p> 
<p id="2.3%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#2.3%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2.3初始化</a></p> 
<p id="2.4%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#2.4%E4%BD%BF%E7%94%A8" rel="nofollow">2.4使用</a></p> 
<p id="2.5%E5%8D%B8%E8%BD%BD-toc" style="margin-left:80px;"><a href="#2.5%E5%8D%B8%E8%BD%BD" rel="nofollow">2.5卸载</a></p> 
<p id="%E4%B8%89.JVM%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%89.JVM%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B" rel="nofollow">三.JVM 内存模型</a></p> 
<p id="3.1.%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-toc" style="margin-left:80px;"><a href="#3.1.%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA" rel="nofollow">3.1.运行时数据区</a></p> 
<p id="%E5%9B%9B.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#%E5%9B%9B.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6" rel="nofollow">四.垃圾回收机制</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80.JDK%E3%80%81JRE%E3%80%81JVM%E7%9A%84%E5%85%B3%E7%B3%BB">一.JDK、JRE、JVM的关系</h3> 
<p><span style="color:#000000;">        Java 程序是运行在 </span><span style="color:#000000;">JVM(Java </span><span style="color:#000000;">虚拟机</span><span style="color:#000000;">)</span><span style="color:#000000;">上的，在开发程序之前都要配置 </span><span style="color:#000000;">Java </span><span style="color:#000000;">开发环境，其中首先要做的就是 JDK </span><span style="color:#000000;">的安装和配置，那么 </span><span style="color:#000000;">JDK</span><span style="color:#000000;">、</span><span style="color:#000000;">JVM</span><span style="color:#000000;">、</span><span style="color:#000000;">JRE </span><span style="color:#000000;">到底有何联系和区别呢？想必并不是每一个程序员都能说得清楚的，接下来将带你了解它们之间的关系。</span></p> 
<p><img alt="" height="417" src="https://images2.imgbox.com/fd/e1/4oVhI6nM_o.png" width="838"></p> 
<h4 id="1.1JDK(Java%20SE%20Development%20Kit)">1.1JDK<span style="color:#000000;">(Java SE Development Kit)</span></h4> 
<p><span style="color:#000000;">        </span><span style="color:#000000;">Java</span><span style="color:#000000;">标准开发工具包，它提供了编译、运行 </span><span style="color:#000000;">Java </span><span style="color:#000000;">程序所需的各种工具和资源，包括 Java </span><span style="color:#000000;">编译器、</span><span style="color:#000000;">Java </span><span style="color:#000000;">运行时环境，以及常用的 </span><span style="color:#000000;">Java 类库等。下图是 </span><span style="color:#000000;">JDK </span><span style="color:#000000;">的安装目录：</span></p> 
<div> 
 <img alt="" height="539" src="https://images2.imgbox.com/f7/5d/gosy4wt6_o.png" width="1037"> 
</div> 
<div></div> 
<h4 id="1.2JRE(%20Java%20Runtime%20Environment)">1.2JRE<span style="color:#000000;">( Java Runtime Environment)</span></h4> 
<div> 
 <p><span style="color:#000000;">        Java 运行环境，用于解释执行 </span><span style="color:#000000;">Java </span><span style="color:#000000;">的字节码文件。普通用户而只需要安装 JRE就能够</span><span style="color:#000000;">Java </span><span style="color:#000000;">程序。而程序开发者必须安装 JDK </span><span style="color:#000000;">来编译、调试程序。下图是 JRE </span><span style="color:#000000;">的安装目录：里面有两个文件夹 </span><span style="color:#000000;">bin </span><span style="color:#000000;">和 </span><span style="color:#000000;">lib</span><span style="color:#000000;">，在这里可以认为 </span><span style="color:#000000;">bin </span><span style="color:#000000;">里的就是 jvm</span><span style="color:#000000;">，</span><span style="color:#000000;">lib </span><span style="color:#000000;">中则是 </span><span style="color:#000000;">jvm </span><span style="color:#000000;">工作所需要的类库，而 </span><span style="color:#000000;">jvm </span><span style="color:#000000;">和 </span><span style="color:#000000;">lib </span><span style="color:#000000;">和起来就称为 </span><span style="color:#000000;">jre</span><span style="color:#000000;">。</span></p> 
</div> 
<p><img alt="" height="489" src="https://images2.imgbox.com/fb/d1/nuinsycK_o.png" width="1165"></p> 
<h4 id="1.3JVM(Java%20Virtual%20Machine)">1.3JVM<span style="color:#000000;">(Java Virtual Machine)</span></h4> 
<p><span style="color:#000000;">        JVM，</span><span style="color:#000000;">Java </span><span style="color:#000000;">虚拟机，是 </span><span style="color:#000000;">JRE </span><span style="color:#000000;">的一部分。它是整个 </span><span style="color:#000000;">java </span><span style="color:#000000;">实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行 java </span><span style="color:#000000;">字节码文件的虚拟计算机。所有平台的上的 JVM </span><span style="color:#000000;">向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。 </span></p> 
<p><span style="color:#000000;">当使用 </span><span style="color:#000000;">Java </span><span style="color:#000000;">编译器编译 </span><span style="color:#000000;">Java </span><span style="color:#000000;">程序时，生成的是与平台无关的字节码，这些字节码只面向 JVM</span><span style="color:#000000;">。不同平台的 </span><span style="color:#000000;">JVM </span><span style="color:#000000;">都是不同的，但它们都提供了相同的接口。</span><span style="color:#000000;">JVM </span><span style="color:#000000;">是Java 程序跨平台的关键部分，只要为不同平台实现了相应的虚拟机，编译后的Java 字节码就可以在该平台上运行</span></p> 
<h4 id="1.4JDK%E3%80%81JRE%E3%80%81JVM%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB">1.4JDK、JRE、JVM的区别与联系</h4> 
<p><span style="color:#000000;">1. JDK 用于开发，</span><span style="color:#000000;">JRE </span><span style="color:#000000;">用于运行 </span><span style="color:#000000;">java </span><span style="color:#000000;">程序 ；如果只是运行 </span><span style="color:#000000;">Java </span><span style="color:#000000;">程序，可以只安装 JRE</span><span style="color:#000000;">，无需安装 </span><span style="color:#000000;">JDK</span><span style="color:#000000;">。 </span></p> 
<p><span style="color:#000000;">2. JDK </span><span style="color:#000000;">包含 </span><span style="color:#000000;">JRE</span><span style="color:#000000;">，</span><span style="color:#000000;">JDK </span><span style="color:#000000;">和 </span><span style="color:#000000;">JRE </span><span style="color:#000000;">中都包含 </span><span style="color:#000000;">JVM</span><span style="color:#000000;">。 </span></p> 
<p><span style="color:#000000;">3. JVM </span><span style="color:#000000;">是 </span><span style="color:#000000;">java </span><span style="color:#000000;">编程语言的核心并且具有平台独立性,实现了Java语言的跨平台。</span></p> 
<h3 id="%E4%BA%8C.Class%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">二.Class的生命周期</h3> 
<h4 id="2.1%E5%8A%A0%E8%BD%BD">2.1加载</h4> 
<p>        java程序经过javac.exe编译成java.class文件存储在磁盘中，而我们的JVM运行在内存中，所以需要将java.class文件通过IO加载到我们的JVM中。这里就设计到类加载器</p> 
<h5 id="2.1.1%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">2.1.1 类加载器</h5> 
<p><img alt="" height="932" src="https://images2.imgbox.com/72/8c/o8xEvEEC_o.png" width="1200"></p> 
<ul><li> <p><span style="color:#0d0016;">启动类加载器（Bootstrap ClassLoader ）：</span>加载$JAVA_HOME 中 jre/lib/rt.jar 里所有的 class 或 Xbootclassoath 选项指定的jar 包! 这些类是 Java 运行的基础类，BootstrapClassLoader 比较特殊，它不继承ClassLoader，而是由 JVM 内部实现；C++实现，并非 java 代码实现</p> </li><li> <p><span style="color:#0d0016;">扩展类加载器（Extension ClassLoader）：</span><span style="color:#000000;">加载 java </span><span style="color:#000000;">平台中扩展功能的一些 </span><span style="color:#000000;">jar </span><span style="color:#000000;">包，包括</span><span style="color:#000000;">$JAVA_HOME </span><span style="color:#000000;">中 </span><span style="color:#000000;">jre/lib/ext/*.jar </span><span style="color:#000000;">或</span><span style="color:#000000;">-Djava.ext.dirs（启动指令属性）指定目录下的 </span><span style="color:#000000;">jar 包</span></p> </li><li> <p><span style="color:#0d0016;">系统类加载器（Application ClassLoader）：</span>加载 classpath 中指定的 jar 包-Djava.class.path 所指定目录下的类和 jar 包具体实现为 sum.misc.Launcher 中的内部类 AppClassLoader</p> </li><li><span style="color:#0d0016;">自定类加载器（Custom ClassLoader）：通过继承ClassLoader 实现自己的类加载器，可以通过这种方式打破双亲委派机制。</span></li></ul> 
<h5 id="2.1.2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">2.1.2类加载机制</h5> 
<ol><li> <p>  <span style="color:#000000;">全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个 Class 时，该Class 所依赖和引用其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。 </span></p> </li><li> <p><span style="color:#000000;">双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该 Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。 </span></p> </li><li> <p><span style="color:#000000;">缓存机制。缓存机制将会保证所有加载过的 Class </span><span style="color:#000000;">都会被缓存，当程序中需要使用某个 Class </span><span style="color:#000000;">时，类加载器先从缓存区中搜寻该 </span><span style="color:#000000;">Class</span><span style="color:#000000;">，只有当缓存区中不存在该 Class </span><span style="color:#000000;">对象时，系统才会读取该类对应的二进制数据，并将其转换成Class 对象，存入缓冲区中。这就是为很么修改了 Class 后，必须重新启动JVM，程序所做的修改才会生效的原因。</span> <strong><span style="color:#000000;"> </span></strong> </p> </li></ol> 
<h5 id="2.1.3%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE">2.1.3双亲委派</h5> 
<p>        当一个类收到了类的加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一层的类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class)，子类加载器才会尝试自己去加载。<br>         采用双亲委派机制的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托顶层的启动类加载器进行加载，这样保证了使用不同的类加载器最终得到的都是同一个Object对象。</p> 
<p>好处：</p> 
<ul><li>安全，防止了Java的核心API被随意更改</li><li>避免了类的重复加载</li></ul> 
<p>如何打破双亲委派</p> 
<p>        自定义类加载器，继承ClassLoder，重写他的loadCLass方法，不让他向上委派。</p> 
<h4 id="2.2%E9%93%BE%E6%8E%A5">2.2链接</h4> 
<p>        链接分为三步，分别是验证 - &gt; 准备 - &gt; 解析</p> 
<h5 id="2.2.1%E9%AA%8C%E8%AF%81">2.2.1验证</h5> 
<p><span style="color:#000000;">        验证是连接阶段的第一步，这一阶段的目的是为了确保 Class </span><span style="color:#000000;">文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证文件格式、元数据、字节码等等 </span></p> 
<p><span style="color:#000000;">        文件格式验证：此阶段保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java </span><span style="color:#000000;">类型信息的要求。</span></p> 
<h5 id="2.2.2%E5%87%86%E5%A4%87">2.2.2准备</h5> 
<p>        <span style="color:#000000;">为静态变量分配内存，赋值初始值</span></p> 
<h5 id="2.2.3%E8%A7%A3%E6%9E%90">2.2.3解析</h5> 
<p><span style="color:#000000;">        将常量池中的符号引用转为直接引用 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。直接引用就死我们的真实地址。</span></p> 
<h4 id="2.3%E5%88%9D%E5%A7%8B%E5%8C%96">2.3初始化</h4> 
<p><span style="color:#000000;">        为静态变量赋真正的值。到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行 &lt;clinit&gt;() 方法的过程。</span></p> 
<h4 id="2.4%E4%BD%BF%E7%94%A8">2.4使用</h4> 
<p>        就是实例化，new一个类的对像。</p> 
<h4 id="2.5%E5%8D%B8%E8%BD%BD">2.5卸载</h4> 
<p><span style="color:#000000;">Class </span><span style="color:#000000;">被回收要满足以下三个条件</span><span style="color:#000000;">: </span></p> 
<p><span style="color:#000000;">a) No Instance</span><span style="color:#000000;">：该类所有的实例都已经被 </span><span style="color:#000000;">GC; </span></p> 
<p><span style="color:#000000;">b) No ClassLoader</span><span style="color:#000000;">：加载该类的 </span><span style="color:#000000;">ClassLoader </span><span style="color:#000000;">实例已经被 </span><span style="color:#000000;">GC; </span></p> 
<p><span style="color:#000000;">c) No Reference</span><span style="color:#000000;">：该类的 </span><span style="color:#000000;">java.lang.Class </span><span style="color:#000000;">对象没有被引用。</span><span style="color:#000000;">(XXX.class, </span><span style="color:#000000;">静态变量</span><span style="color:#000000;">/</span><span style="color:#000000;">方 </span></p> 
<p><span style="color:#000000;">法</span><span style="color:#000000;">)</span></p> 
<h3 id="%E4%B8%89.JVM%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span style="color:#0d0016;">三.<strong>JVM 内存模型</strong></span></h3> 
<h4 id="3.1.%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><strong>3.1.运行时数据区</strong></h4> 
<p><img alt="" height="580" src="https://images2.imgbox.com/0b/79/mmWfwAVQ_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;">方法区</span>：是线程共享的，生命周期和虚拟机一样。存储类信息，静态变量，常量池。方法区满了会OutOfMemoryError(OOM)。</p> 
<p><span style="color:#fe2c24;">堆</span>：是线程共享的，生命周期和虚拟机一样。存储的是大部分的对象。堆满了也会OOM.堆是GC的主要空间，堆分为老年代和新生代，新生代又分为eden区S0、S1.</p> 
<p>默认    老年代：新生代 = 2:1      Eden ：S0 : S1 = 8 : 1 : 1</p> 
<p><span style="color:#fe2c24;">虚拟机栈</span>：是线程私有的，生命周期和创建的线程一样。存储8种基本数据类型和对象的引用，每调用一个方法就会把一个栈帧压栈。栈满了会报错StackOverflowError。线程太多没有足够的空间创建虚拟机栈就会出现OutOfMemoryError(OOM)。</p> 
<p>栈帧包括：局部变量表，操作数栈，动态链接，返回地址</p> 
<p>操作数栈是用来执行字节码指令过程中用来计算的。</p> 
<p>Java虚拟机栈，执行方法的时候，到底经历什么? javap 反编译-&gt;字节码指令，对应Java虚拟机栈执行过程</p> 
<p><span style="color:#fe2c24;">本地方法栈</span>：线程私有的，调用nativ方法的。结构与虚拟机栈相似。</p> 
<p><span style="color:#fe2c24;">程序计数器</span>：线程私有的，记录程序执行到第几行。他是唯一不会内存溢出的</p> 
<p></p> 
<p><img alt="" height="705" src="https://images2.imgbox.com/a1/c2/kowKQkQv_o.png" width="1200"></p> 
<h3 id="%E5%9B%9B.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><strong>四.垃圾回收机制</strong></h3> 
<p><a class="link-info" href="https://blog.csdn.net/w7486/article/details/119036050" title="Java垃圾回收机制(GC)">Java垃圾回收机制(GC)</a></p> 
<h3><strong>五.JVM参数</strong></h3> 
<h4>1.1标准参数</h4> 
<p><span style="color:#000000;">不会随着 </span><span style="color:#000000;">JDK </span><span style="color:#000000;">版本的变化而变化 </span></p> 
<blockquote> 
 <p><span style="color:#000000;">-version </span></p> 
 <p><span style="color:#000000;">-help </span></p> 
 <p><span style="color:#000000;">-server </span></p> 
 <p><span style="color:#000000;">-cp </span></p> 
</blockquote> 
<h4>1.2-X参数</h4> 
<div> 
 <p><span style="color:#000000;">非标准参数，也就是在 </span><span style="color:#000000;">JDK </span><span style="color:#000000;">各个版本中可能会变动 </span></p> 
 <blockquote> 
  <p><span style="color:#000000;">java -Xint -version </span><span style="color:#000000;">解释执行 </span></p> 
  <p><span style="color:#000000;">java -Xcomp -version </span><span style="color:#000000;">第一次使用就编译成本地代码 </span></p> 
  <p><span style="color:#000000;">java -Xmixed -version </span><span style="color:#000000;">混合模式，</span><span style="color:#000000;">JVM </span><span style="color:#000000;">自己来决定</span></p> 
 </blockquote> 
 <h4><span style="color:#000000;">1.3-XX参数</span></h4> 
 <p><span style="color:#000000;"><strong>使用得最多的参数类型</strong></span><span style="color:#000000;">非标准化参数，相对不稳定，主要用于 </span><span style="color:#000000;">JVM </span><span style="color:#000000;">调优和 </span><span style="color:#000000;">Debug。</span></p> 
</div> 
<blockquote> 
 <p><strong><span style="color:#000000;">a.Boolean </span><span style="color:#000000;">类型 </span></strong></p> 
 <p><span style="color:#000000;">格式：</span><span style="color:#000000;">-XX:[+-]&lt;name&gt;                              +或</span><span style="color:#000000;">-</span><span style="color:#000000;">表示启用或者禁用 </span><span style="color:#000000;">name </span><span style="color:#000000;">属性 </span></p> 
 <p><span style="color:#000000;">比如：</span><span style="color:#000000;">-XX:+UseConcMarkSweepGC       </span><span style="color:#000000;">表示启用 </span><span style="color:#000000;">CMS </span><span style="color:#000000;">类型的垃圾回收器 </span></p> 
 <p><span style="color:#000000;">           -XX:+UseG1GC                             表示启用 G1 </span><span style="color:#000000;">类型的垃圾回收器 </span></p> 
 <p><strong><span style="color:#000000;">b.</span><span style="color:#000000;">非 </span><span style="color:#000000;">Boolean </span><span style="color:#000000;">类型 </span></strong></p> 
 <p><span style="color:#000000;">格式：</span><span style="color:#000000;">-XX:&lt;name&gt;=&lt;value&gt;                    </span><span style="color:#000000;">表示 </span><span style="color:#000000;">name </span><span style="color:#000000;">属性的值是 </span><span style="color:#000000;">value </span></p> 
 <p><span style="color:#000000;">比如：</span><span style="color:#000000;">-XX:MaxGCPauseMillis=500 </span></p> 
 <p>          <span style="color:#000000;">-XX:InitialHeapSize=100M              表示初始化堆大小为100M</span></p> 
</blockquote> 
<h4>1.4其他参数</h4> 
<blockquote> 
 <p><span style="color:#000000;">-Xms100M         等价于</span><span style="color:#000000;">-XX:InitialHeapSize=100M </span></p> 
 <p><span style="color:#000000;">-Xmx100M         等价于</span><span style="color:#000000;">-XX:MaxHeapSize=100M </span></p> 
 <p><span style="color:#000000;">-Xss100k           等价于</span><span style="color:#000000;">-XX:ThreadStackSize=100k </span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#000000;">java -XX:+PrintFlagsFinal -version </span>      查看参数</p> 
</blockquote> 
<h4>1.5五大常用参数</h4> 
<p>jps  查看java进程</p> 
<p>jinfo  <span style="color:#000000;">实时查看和调整 </span><span style="color:#000000;">JVM </span><span style="color:#000000;">配置参数 </span></p> 
<ul><li><span style="color:#000000;">查看：jinfo -flag name PID </span><span style="color:#000000;">查看某个 </span><span style="color:#000000;">java </span><span style="color:#000000;">进程的 </span><span style="color:#000000;">name 属性的值。  例如：jinfo -flag MaxHeapSize PID</span></li><li> <p><span style="color:#000000;">修改：</span><strong>参数只有被标记为 </strong><span style="color:#fe2c24;"><strong>manageable </strong></span><strong>的 </strong><strong>flags </strong><strong>可以被实时修改。 </strong>jinfo -flag name=value PID。例如: <span style="color:#000000;">jinfo -flag MaxHeapSize = 20M PID</span></p> </li></ul> 
<p>jstat  查看性能</p> 
<p>jstack  查看栈</p> 
<p>jmap 查看堆</p> 
<p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof  这个参数可以在OOM时自动打印dump文件</p> 
<p>jmap -dump:format=b,file=heap.hprof pid  手动打印dump</p> 
<p>打印出来的dump文件可以结合工具来分析</p> 
<h4>1.6调优思路</h4> 
<p><img alt="" height="741" src="https://images2.imgbox.com/12/b7/dEhtzR3K_o.png" width="1174"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65b03428611a52a7c9ff8da119b29991/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">『heqingchun-ubuntu系统下设置关闭笔记本盖子不休眠方法』</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/520a129b3f613da0080e494adad96d84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">这本书竟然把JAVA讲的如此透彻！漫画JAVA火爆出圈！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>