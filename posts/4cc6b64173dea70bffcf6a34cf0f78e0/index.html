<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>codeforces 787D Legacy （线段树） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="codeforces 787D Legacy （线段树）" />
<meta property="og:description" content="题目链接：http://codeforces.com/problemset/problem/787/D
Description Rick and his co-workers have made a new radioactive formula and a lot of bad guys are after them. So Rick wants to give his legacy to Morty before bad guys catch them.
There are n planets in their universe numbered from 1 to n. Rick is in planet number s (the earth) and he doesn&#39;t know where Morty is. As we all know, Rick owns a portal gun." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4cc6b64173dea70bffcf6a34cf0f78e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-19T11:24:33+08:00" />
<meta property="article:modified_time" content="2019-07-19T11:24:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">codeforces 787D Legacy （线段树）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>题目链接：<a href="http://codeforces.com/problemset/problem/787/D" rel="nofollow">http://codeforces.com/problemset/problem/787/D</a></p> 
</blockquote> 
<h3><span style="color:#3399ea;">Description</span></h3> 
<p>Rick and his co-workers have made a new radioactive formula and a lot of bad guys are after them. So Rick wants to give his legacy to Morty before bad guys catch them.</p> 
<p>There are <em>n</em> planets in their universe numbered from 1 to <em>n</em>. Rick is in planet number <em>s</em> (the earth) and he doesn't know where Morty is. As we all know, Rick owns a portal gun. With this gun he can open one-way portal from a planet he is in to any other planet (including that planet). But there are limits on this gun because he's still using its free trial.</p> 
<p><img alt="" class="has" height="354" src="https://images2.imgbox.com/a6/8e/WLWioVVy_o.png" width="640"></p> 
<p>By default he can not open any portal by this gun. There are <em>q</em> plans in the website that sells these guns. Every time you purchase a plan you can only use it once but you can purchase it again if you want to use it more.</p> 
<p>Plans on the website have three types:</p> 
<ol><li>With a plan of this type you can open a portal from planet <em>v</em> to planet <em>u</em>.</li><li>With a plan of this type you can open a portal from planet <em>v</em> to any planet with index in range [<em>l</em>, <em>r</em>].</li><li>With a plan of this type you can open a portal from any planet with index in range [<em>l</em>, <em>r</em>] to planet <em>v</em>.</li></ol> 
<p>Rick doesn't known where Morty is, but Unity is going to inform him and he wants to be prepared for when he finds and start his journey immediately. So for each planet (including earth itself) he wants to know the minimum amount of money he needs to get from earth to that planet.</p> 
<h3><span style="color:#3399ea;">Input</span></h3> 
<p>The first line of input contains three integers <em>n</em>, <em>q</em> and <em>s</em> (1 ≤ <em>n</em>, <em>q</em> ≤ 105, 1 ≤ <em>s</em> ≤ <em>n</em>) — number of planets, number of plans and index of earth respectively.</p> 
<p>The next <em>q</em> lines contain the plans. Each line starts with a number <em>t</em>, type of that plan (1 ≤ <em>t</em> ≤ 3). If <em>t</em> = 1 then it is followed by three integers <em>v</em>, <em>u</em> and <em>w</em> where <em>w</em>is the cost of that plan (1 ≤ <em>v</em>, <em>u</em> ≤ <em>n</em>, 1 ≤ <em>w</em> ≤ 109). Otherwise it is followed by four integers <em>v</em>, <em>l</em>, <em>r</em> and <em>w</em> where <em>w</em> is the cost of that plan (1 ≤ <em>v</em> ≤ <em>n</em>, 1 ≤ <em>l</em> ≤ <em>r</em> ≤ <em>n</em>, 1 ≤ <em>w</em> ≤ 109).</p> 
<h3><span style="color:#3399ea;">Output</span></h3> 
<p>In the first and only line of output print <em>n</em> integers separated by spaces. <em>i</em>-th of them should be minimum money to get from earth to <em>i</em>-th planet, or  - 1 if it's impossible to get to that planet.</p> 
<h3><span style="color:#3399ea;">Examples</span></h3> 
<h3><span style="color:#3399ea;">Input</span></h3> 
<pre class="has"><code class="language-html">3 5 1
2 3 2 3 17
2 3 2 2 16
2 2 2 3 3
3 3 1 1 12
1 3 3 17
</code></pre> 
<h3><span style="color:#3399ea;">Output</span></h3> 
<pre class="has"><code class="language-html">0 28 12 
</code></pre> 
<h3><span style="color:#3399ea;">Input</span></h3> 
<pre class="has"><code class="language-html">4 3 1
3 4 1 3 12
2 2 3 4 10
1 2 4 16
</code></pre> 
<h3><span style="color:#3399ea;">Output</span></h3> 
<pre class="has"><code class="language-html">0 -1 -1 12 </code></pre> 
<h3><span style="color:#3399ea;">题目分析</span></h3> 
<p style="text-indent:50px;">看完题目，觉得是一个最短路问题，但是想到一种情况：如果每次操作让一个点连接最大的区间，那么建图的时间将用时 O(n*q)， 这样是不行的，但是我们可以用线段树来优化建图过程。</p> 
<p style="text-indent:50px;">线段树的特点在于区间操作，比如求区间最值以及对区间进行整体操作等等，为此我们将所有的顶点构成区间，建立线段树： [1.n] , [1, (n+1)/2 ] , [ (n + 1 )/2 + 1, n ] .....由于我们将某一段连续的点当作线段树上的一个顶点，这样我们在建立 点到区间的边 和 区间到点的边的时候，就不用进行点和点之间的直接建边了，而是在线段树上进行顶点和顶点之间的建边了，即直接建立区间和点之间的边，这将节省建图的时间。</p> 
<p style="text-indent:50px;">而以区间 [1,n] 建立线段树，自然会想到线段树的叶子结点都是星球（点），那么为了体现从点x到区间建边的操作，我们将线段树所有的顶点当作求最短路时的顶点，也就是说，我们也会把一个区间看作一个顶点，求起点到各个顶点的最短距离，  图如下所示</p> 
<p style="text-indent:50px;">  <img alt="" class="has" height="230" src="https://images2.imgbox.com/53/86/gs0frj7A_o.png" width="453"></p> 
<p style="text-indent:50px;">首先，因为我们需要建立从点x到区间[a,b]的边，那么我们必须使得这个区间[a,b]代表的顶点到其子结点的距离为0，这样一来，我们在求最短路的时候，点x代表的顶点到区间[a,b]代表的顶点之间的距离是dis，同时点x到区间代表的点 a, a+1,a+2 ...b 的距离也会是dis，这样也就实现了点x到区间[a,b]中的每一个点的建边，由此我们需要建图如下（图中的蓝线代表距离为0的边）：</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="229" src="https://images2.imgbox.com/fe/f2/JHxi7bhb_o.png" width="443"></p> 
<p style="text-indent:50px;">然后，我们需要建立从区间[a,b]到点x的边，显然，上面的图中区间到点的距离都是0，明显不符合我们的要求，我们需要构建一个新的图。</p> 
<p style="text-indent:50px;">我们必须使得点a,a+1...b代表的顶点到其父结点的距离为0，这样一来，我们在求最短路的时候，从区间[a,b]代表的顶点到点x代表的顶点之间的距离是dis，同时区间代表的点a, a+1,a+2 ...b 到点 x的距离也是dis，这样也就实现了区间[a,b]中的每一个点到点x的建边，由此我们需要建图如下（图中的蓝线代表距离为0的边）：</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="250" src="https://images2.imgbox.com/b8/b0/haGJigbn_o.png" width="455"></p> 
<p style="text-indent:50px;">此时，我们构建出了两个图，第一个用于表示建立从点x到区间[a,b]的边的时候的区间[a,b]，第二个图表示建立从区间[a,b]到点x的边的时候的区间[a,b]，而我们发现，建边的时候的点x无论在哪个图都会产生同样的效果，<strong>因此两个图中的叶子结点是同一个点</strong>，为了体现这一效果，我们可以将上述两个图合并为如下的图（图中的蓝线代表距离为0的边）：</p> 
<p style="text-indent:50px;"><img alt="" class="has" height="557" src="https://images2.imgbox.com/97/17/755BOejz_o.png" width="459"></p> 
<p style="text-indent:50px;">这样一来，我们就可以正常地为点到区间，区间到点建边了，为了方便，我们将3种建边操作描述如下：</p> 
<p style="text-indent:50px;">Type == 1 ,建立点u到点v之间的边，权值为w，由于起点和终点都是点，那么由橙色的叶子结点[u,u]向绿色的叶子结点[v,v]建一条权值为w的单向边。</p> 
<p style="text-indent:50px;">Type == 2，建立区间[a,b]到点u之间的边，权值为w，这个时候，我们由橙色的结点[a,b]向绿色的叶子结点[u.u]建一条权值为w的单向边。</p> 
<p style="text-indent:50px;">Type == 3，建立点u到区间[a,b]之间的边，权值为w，这个时候，我们由橙色的叶子结点[u.u]向绿色的顶点[a,b]建一条权值为w的单向边。</p> 
<p style="text-indent:50px;">嗯，方便起见，始终以下线段树为起点，以上线段树为终点，进行建边</p> 
<p style="text-indent:50px;">下面给出第二组样例构建的图，帮助理解<img alt="" class="has" height="568" src="https://images2.imgbox.com/41/26/3pUOs3MX_o.png" width="800"></p> 
<p style="text-indent:50px;">最后，我们从起点1对整个图跑一遍dijkstra，得到各个叶子结点到起点1的距离：0，-1，-1，12</p> 
<h3><span style="color:#3399ea;">代码区</span></h3> 
<pre class="has"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;string&gt;
#include&lt;fstream&gt;
#include&lt;vector&gt;
#define bug cout &lt;&lt; "**********" &lt;&lt; endl
//#define LOCAL = 1;
using namespace std;
typedef long long ll;
const ll inf = 1e18 + 5;
const int mod = 1e8;
const int Max = 1e5 + 10;

struct Node
{
	int l, r;
	int num;
}node1[Max &lt;&lt; 3], node2[Max &lt;&lt; 3];		//记录上下两个线段树

struct Edge
{
	int to;
	ll dis;
};

vector&lt;Edge&gt;edge[Max &lt;&lt; 3];				//记录边的信息，这里用vector存图导致了运行时间较长，请见谅
int pos1[Max &lt;&lt; 3], pos2[Max &lt;&lt; 3];		//记录上下两个树中的每个叶子结点在线段树中的下标
int n, q, s;
int tot;


void build_up(int l, int r, int num)	//自底向上建边，下线段树
{
	node1[num].l = l;
	node1[num].r = r;
	node1[num].num = ++tot;				//每一个顶点都有唯一的编号，便于建边
	if (l == r)
	{
		pos1[l] = node1[num].num;		//记录下线段树的叶子结点对应的编号，借助pos1直接找到叶子结点
		return;
	}
	int mid = (l + r) &gt;&gt; 1;
	build_up(l, mid, num &lt;&lt; 1);
	build_up(mid + 1, r, num &lt;&lt; 1 | 1);

	edge[node1[num &lt;&lt; 1].num].push_back({ node1[num].num, 0 });
	edge[node1[num &lt;&lt; 1 | 1].num].push_back({ node1[num].num, 0 });	//子结点向父结点建边
}

void build_down(int l, int r, int num)	//自顶向下建边
{
	node2[num].l = l;
	node2[num].r = r;
	node2[num].num = ++tot;
	if (l == r)
	{
		pos2[l] = node2[num].num;							//记录上线段树的叶子结点对应的编号，借助pos1直接找到叶子结点
		edge[node2[num].num].push_back({ pos1[l], 0 });		//由上线段树的叶子结点向下线段树的叶子结点建边
		return;
	}
	int mid = (l + r) &gt;&gt; 1;
	build_down(l, mid, num &lt;&lt; 1);
	build_down(mid + 1, r, num &lt;&lt; 1 | 1);
	edge[node2[num].num].push_back({ node2[num &lt;&lt; 1].num, 0 });
	edge[node2[num].num].push_back({ node2[num &lt;&lt; 1 | 1].num, 0 });	//父结点向子结点建边
}

//由区间向点建边
void upData_section_to_dot(int l, int r, int v, ll dis, int num)
{
	if (l &lt;= node1[num].l &amp;&amp; node1[num].r &lt;= r)
	{
		edge[node1[num].num].push_back({ pos2[v], dis });	//由下线段树的区间向上线段树的叶子结点建边
		return;
	}
	int mid = (node1[num].l + node1[num].r) &gt;&gt; 1;
	if (l &lt;= mid)
		upData_section_to_dot(l, r, v, dis, num &lt;&lt; 1);
	if (r &gt; mid)
		upData_section_to_dot(l, r, v, dis, num &lt;&lt; 1 | 1);
}

//由点向边建边
void upData_dot_to_section(int l, int r, int u, ll dis, int num)
{
	if (l &lt;= node2[num].l &amp;&amp; node2[num].r &lt;= r)
	{
		edge[pos1[u]].push_back({ node2[num].num, dis });	//由下线段树的点向上线段树的区间建边
		return;
	}
	int mid = (node2[num].l + node2[num].r) &gt;&gt; 1;
	if (l &lt;= mid)
		upData_dot_to_section(l, r, u, dis, num &lt;&lt; 1);
	if (r &gt; mid)
		upData_dot_to_section(l, r, u, dis, num &lt;&lt; 1 | 1);
}


bool vis[Max &lt;&lt; 3];	//访问状态
ll dist[Max &lt;&lt; 3];	//各个点到起点的距离

void dijkstra(int start)
{
	memset(vis, 0, sizeof(vis));	//初始化访问状态
	for (int i = 1;i &lt;= 8 * n;i++)	//初始化各个点到起点的距离
		dist[i] = inf;
	dist[start] = 0;
	priority_queue &lt; pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt;&gt;, greater&lt;pair&lt;ll, int&gt; &gt; &gt;queues;//以到起点距离单增的优先队列
	queues.push({ 0,start });		//起点入队

	while (!queues.empty())
	{
		int u = queues.top().second;
		queues.pop();
		if (vis[u]) continue;		//重复访问
		vis[u] = true;
		for (int i = 0;i &lt; edge[u].size(); i++)
		{
			int v = edge[u][i].to;
			ll dis = edge[u][i].dis;
			if (vis[v]) continue;	//重复访问
			if (dist[v] &gt; dist[u] + dis)	//缩边
			{
				dist[v] = dist[u] + dis;
				queues.push({ dist[v],v });
			}
		}
	}
	for (int i = 1;i &lt;= n;i++)		//输出结果
	{
		if (dist[pos1[i]] != inf)
			printf("%lld ", dist[pos1[i]]);
		else
			printf("-1 ");
	}
	printf("\n");
}

int main()
{
#ifdef LOCAL
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);	
	//这个是文件进行输入和输出，如果将13行的#define LOCAL = 1;注释掉，就是常规运行了（黑框框里面的那种）
#endif
	while (scanf("%d%d%d", &amp;n, &amp;q, &amp;s) != EOF)
	{
		for (int i = 0;i &lt; Max &lt;&lt; 3; i++)	//多组输入的初始化，其实这里不需要多组输入，习惯使然
			edge[i].clear();
		tot = 0;							//控制编号的变量
		build_up(1, n, 1);
		build_down(1, n, 1);				//构建上下线段树
		while (q--)
		{
			int type, u, v, l, r;
			ll cost;
			scanf("%d", &amp;type);
			if (type == 1)
			{
				scanf("%d%d%lld", &amp;u, &amp;v, &amp;cost);
				edge[pos1[u]].push_back({ pos2[v], cost });	//由下线段树的叶子结点向上线段树的叶子结点建边
			}
			else if (type == 2)
			{
				scanf("%d%d%d%lld", &amp;u, &amp;l, &amp;r, &amp;cost);
				upData_dot_to_section(l, r, u, cost, 1);	//由下线段树的叶子结点向上线段树的区间结点建边
			}
			else
			{
				scanf("%d%d%d%lld", &amp;v, &amp;l, &amp;r, &amp;cost);
				upData_section_to_dot(l, r, v, cost, 1);	//由下线段树的区间结点向上线段树的叶子结点建边
			}
		}
		dijkstra(pos1[s]);	//最短路
	}
	return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1494a750de682da04fd278cffc76098c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">我的STM32学习日记（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3e04330e958d1f498c26cf67f9ca934/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring中使用LocalDateTime、LocalDate等参数作为入参数据转换问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>