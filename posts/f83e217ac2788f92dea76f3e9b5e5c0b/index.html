<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排队论 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排队论" />
<meta property="og:description" content="1-泊松流与指数分布
主要是关于输入流为泊松流，而时间间隔是服从指数分布
2-排队模型
这里主要是MMN和MM1
M表示泊松分布和负指数分布
3-单服务台负指数分布M/M/1排队系统
模型的条件是：
1、输入过程――顾客源是无限的，顾客到达
完全是随机的，单个到来，到达过程服从普阿
松分布，且是平稳的；
2、排队规则――单队，且队长没有限制，先
到先服务；
3、服务机构――单服务台，服务时间的长短
是随机的，服从相同的指数分布 4-
服务强度就是多除了个S，也就是有s台服务器平均分担工作
不同之处还在于如果有排队不是单独排队而是排成一起在一个候诊区
Ws为逗留时间，Wq为等待时间，Ls为队长即系统中顾客期望值，Lq为等待服务的顾客数
其他
对于MMS，也就多除了个S 服务强度《1
例子
计算mms paidui1：
s=2;
mu=4;
lambda=3;
ro=lambda/mu;
ros=ro/s;
sum1=0;
for i=0:(s-1)
sum1=sum1&#43;ro.^i/factorial(i);
end
sum2=ro.^s/factorial(s)/(1-ros);
p0=1/(sum1&#43;sum2);
p=ro.^s.*p0/factorial(s)/(1-ros);
Lq=p.*ros/(1-ros);
L=Lq&#43;ro;
W=L/lambda;
Wq=Lq/lambda;
fprintf(&#39;排队等待的平均人数为%5.2f人\n&#39;,Lq)
fprintf(&#39;系统内的平均人数为%5.2f人\n&#39;,L)
fprintf(&#39;平均逗留时间为%5.2f分钟\n&#39;,W*60)
fprintf(&#39;平均等待时间为%5.2f分种\n&#39;,Wq*60)
————————————————————————————————————————————————————————
给MM1画图
paidui2
clear clc %***************************************** %初始化顾客源 %***************************************** %总仿真时间 Total_time = 10; %队列最大长度 N = 10000000000; %到达率与服务率 lambda = 10; mu = 6; %平均到达时间与平均服务时间 arr_mean = 1/lambda; ser_mean = 1/mu; arr_num = round(Total_time*lambda*2); events = []; %按负指数分布产生各顾客达到时间间隔 events(1,:) = exprnd(arr_mean,1,arr_num); %各顾客的到达时刻等于时间间隔的累积和 events(1,:) = cumsum(events(1,:)); %按负指数分布产生各顾客服务时间 events(2,:) = exprnd(ser_mean,1,arr_num); %计算仿真顾客个数，即到达时刻在仿真时间内的顾客数 len_sim = sum(events(1,:)&lt;= Total_time); %***************************************** %计算第 1个顾客的信息 %***************************************** %第 1个顾客进入系统后直接接受服务，无需等待 events(3,1) = 0; %其离开时刻等于其到达时刻与服务时间之和 events(4,1) = events(1,1)&#43;events(2,1); %其肯定被系统接纳，此时系统内共有 %1个顾客，故标志位置1 events(5,1) = 1; %其进入系统后，系统内已有成员序号为 1 member = [1]; for i = 2:arr_num %如果第 i个顾客的到达时间超过了仿真时间，则跳出循环 if events(1,i)&gt;Total_time break; else number = sum(events(4,member) &gt; events(1,i)); %如果系统已满，则系统拒绝第 i个顾客，其标志位置 0 if number &gt;= N&#43;1 events(5,i) = 0; %如果系统为空，则第 i个顾客直接接受服务 else if number == 0 %其等待时间为 0" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f83e217ac2788f92dea76f3e9b5e5c0b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-06T22:51:39+08:00" />
<meta property="article:modified_time" content="2018-11-06T22:51:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排队论</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1-泊松流与指数分布</p> 
<p>主要是关于输入流为泊松流，而时间间隔是服从指数分布</p> 
<p><img alt="image" class="has" src="https://images2.imgbox.com/2e/eb/Qt4Gcada_o.png"></p> 
<p><img alt="image" class="has" src="https://images2.imgbox.com/ce/10/mrLgkXW6_o.png"></p> 
<p>2-排队模型</p> 
<p>这里主要是MMN和MM1</p> 
<p>M表示泊松分布和负指数分布</p> 
<p>3-单服务台负指数分布M/M/1排队系统<br> 模型的条件是：<br> 1、输入过程――顾客源是无限的，顾客到达<br> 完全是随机的，单个到来，到达过程服从普阿<br> 松分布，且是平稳的；<br> 2、排队规则――单队，且队长没有限制，先<br> 到先服务；<br> 3、服务机构――单服务台，服务时间的长短<br> 是随机的，服从相同的指数分布 </p> 
<p><img alt="" class="has" height="674" src="https://images2.imgbox.com/20/aa/mc66rwoG_o.png" width="1086"></p> 
<p><img alt="" class="has" height="670" src="https://images2.imgbox.com/b1/42/UaUEcugO_o.png" width="1078"></p> 
<p><img alt="" class="has" height="671" src="https://images2.imgbox.com/c3/58/h0C1Wwxp_o.png" width="1071"></p> 
<p>4-<img alt="" class="has" height="668" src="https://images2.imgbox.com/14/b7/v22bVQiF_o.png" width="1070"></p> 
<p>服务强度就是多除了个S，也就是有s台服务器平均分担工作</p> 
<p>不同之处还在于如果有排队不是单独排队而是排成一起在一个候诊区</p> 
<p><img alt="" class="has" height="671" src="https://images2.imgbox.com/05/ac/JWY9IiLW_o.png" width="1084"></p> 
<p><img alt="" class="has" height="675" src="https://images2.imgbox.com/5e/a1/AXT37Vwb_o.png" width="1085"></p> 
<p> Ws为逗留时间，Wq为等待时间，Ls为队长即系统中顾客期望值，Lq为等待服务的顾客数</p> 
<p>其他</p> 
<p><img alt="" class="has" height="755" src="https://images2.imgbox.com/3f/f7/VQpfgdlA_o.png" width="1075"></p> 
<p>对于MMS，也就多除了个S </p> 
<p><span style="color:#f33b45;"><strong>服务强度《1</strong></span></p> 
<p> </p> 
<p> </p> 
<p><strong>例子</strong></p> 
<p><img alt="" class="has" height="673" src="https://images2.imgbox.com/71/38/EWVcHSBe_o.png" width="1080"></p> 
<p><img alt="" class="has" height="656" src="https://images2.imgbox.com/68/e4/kmhLxos2_o.png" width="1080"></p> 
<p> </p> 
<p><img alt="" class="has" height="649" src="https://images2.imgbox.com/71/ac/vbnEtSEW_o.png" width="1200"></p> 
<p> </p> 
<p> </p> 
<p><span style="color:#f33b45;">计算mms </span></p> 
<p><span style="color:#f33b45;">paidui1：</span><br><strong><span style="color:#f33b45;">s=2;<br> mu=4;<br> lambda=3;</span></strong><br> ro=lambda/mu;<br> ros=ro/s;<br> sum1=0;</p> 
<p>for i=0:(s-1)<br>     sum1=sum1+ro.^i/factorial(i);<br> end</p> 
<p>sum2=ro.^s/factorial(s)/(1-ros);</p> 
<p>p0=1/(sum1+sum2);<br> p=ro.^s.*p0/factorial(s)/(1-ros);<br> Lq=p.*ros/(1-ros);<br> L=Lq+ro;<br> W=L/lambda;<br> Wq=Lq/lambda;<br> fprintf('排队等待的平均人数为%5.2f人\n',Lq)<br> fprintf('系统内的平均人数为%5.2f人\n',L)<br> fprintf('平均逗留时间为%5.2f分钟\n',W*60)<br> fprintf('平均等待时间为%5.2f分种\n',Wq*60)</p> 
<p>————————————————————————————————————————————————————————</p> 
<p><span style="color:#f33b45;">给MM1画图</span></p> 
<p><span style="color:#f33b45;">paidui2</span></p> 
<p>clear <br> clc <br> %***************************************** <br> %初始化顾客源 <br> %***************************************** <br> %总仿真时间 <br><span style="color:#f33b45;"><strong>Total_time = 10; <br> %队列最大长度 <br> N = 10000000000; <br> %到达率与服务率 <br> lambda = 10; <br> mu = 6; </strong></span><br> %平均到达时间与平均服务时间 <br> arr_mean = 1/lambda; <br> ser_mean = 1/mu; <br> arr_num = round(Total_time*lambda*2); <br> events = []; <br> %按负指数分布产生各顾客达到时间间隔 <br> events(1,:) = exprnd(arr_mean,1,arr_num); <br> %各顾客的到达时刻等于时间间隔的累积和 <br> events(1,:) = cumsum(events(1,:)); <br> %按负指数分布产生各顾客服务时间 <br> events(2,:) = exprnd(ser_mean,1,arr_num); <br> %计算仿真顾客个数，即到达时刻在仿真时间内的顾客数 <br> len_sim = sum(events(1,:)&lt;= Total_time); <br> %***************************************** <br> %计算第 1个顾客的信息 <br> %***************************************** <br> %第 1个顾客进入系统后直接接受服务，无需等待 <br> events(3,1) = 0; <br> %其离开时刻等于其到达时刻与服务时间之和 <br> events(4,1) = events(1,1)+events(2,1); <br> %其肯定被系统接纳，此时系统内共有 <br> %1个顾客，故标志位置1 <br> events(5,1) = 1; <br> %其进入系统后，系统内已有成员序号为 1 <br> member = [1]; <br> for i = 2:arr_num <br> %如果第 i个顾客的到达时间超过了仿真时间，则跳出循环 </p> 
<p>if events(1,i)&gt;Total_time </p> 
<p>break; </p> 
<p>else <br> number = sum(events(4,member) &gt; events(1,i)); <br> %如果系统已满，则系统拒绝第 i个顾客，其标志位置 0 <br> if number &gt;= N+1 <br> events(5,i) = 0; <br> %如果系统为空，则第 i个顾客直接接受服务 <br> else <br> if number == 0 <br> %其等待时间为 0</p> 
<p>2009.1516<br><br> %PROGRAMLANGUAGEPROGRAMLANGUAGE<br> events(3,i) = 0; <br> %其离开时刻等于到达时刻与服务时间之和 <br> events(4,i) = events(1,i)+events(2,i); <br> %其标志位置 1 <br> events(5,i) = 1; <br> member = [member,i]; <br> %如果系统有顾客正在接受服务，且系统等待队列未满，则 第 i个顾客进入系统 </p> 
<p>else len_mem = length(member); <br> %其等待时间等于队列中前一个顾客的离开时刻减去其到 达时刻 <br> events(3,i)=events(4,member(len_mem))-events(1,i); <br> %其离开时刻等于队列中前一个顾客的离开时刻加上其服 <br> %务时间 <br> events(4,i)=events(4,member(len_mem))+events(2,i); <br> %标识位表示其进入系统后，系统内共有的顾客数 <br> events(5,i) = number+1; <br> member = [member,i]; <br> end <br> end </p> 
<p>end <br> end <br> %仿真结束时，进入系统的总顾客数 <br> len_mem = length(member); <br> %***************************************** <br> %输出结果 <br> %***************************************** <br> %绘制在仿真时间内，进入系统的所有顾客的到达时刻和离 <br> %开时刻曲线图（stairs：绘制二维阶梯图） <br> stairs([0 events(1,member)],0:len_mem); <br> hold on; <br> stairs([0 events(4,member)],0:len_mem,'.-r'); <br> legend('到达时间 ','离开时间 '); <br> hold off; <br> grid on; <br> %绘制在仿真时间内，进入系统的所有顾客的停留时间和等 <br> %待时间曲线图（plot：绘制二维线性图） <br> figure; <br> plot(1:len_mem,events(3,member),'r-*',1: len_mem,events(2,member)+events(3,member),'k-'); <br> legend('等待时间 ','停留时间 '); <br> grid on;</p> 
<p>第一个图</p> 
<p><img alt="" class="has" height="598" src="https://images2.imgbox.com/ca/e5/62dvYME5_o.png" width="702"></p> 
<p>表示到达时间和离开时间</p> 
<p>开始基本一样，因为人少，所以可以直接接受服务</p> 
<p>而之后人多了，需要排队等待</p> 
<p>第二个图表示停留时间和等待时间</p> 
<p><img alt="" class="has" height="628" src="https://images2.imgbox.com/6c/d2/vFVlPAtT_o.png" width="702"></p> 
<p> </p> 
<p> </p> 
<p>MMS有个很大的特点是排成一列</p> 
<p>和现实不同</p> 
<p>但是可以联系</p> 
<p>比如麦当劳3个服务台</p> 
<p>朗姆打15个人</p> 
<p>其实现实中的自动排成3个队，看着哪个少就过去了</p> 
<p><strong>就相当于3个MM1</strong></p> 
<p><strong>每个MM1朗姆打为5</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e689de828459f272b8690295116116be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux学习-常用文件目录操作命令（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0429bde8527dc6ca1c7b1785552b77af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图像算法——特征拟合之平面拟合</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>