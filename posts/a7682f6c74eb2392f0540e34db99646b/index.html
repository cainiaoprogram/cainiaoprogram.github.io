<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Cloud Stream使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Cloud Stream使用" />
<meta property="og:description" content="一、什么是Spring Cloud Stream Spring Cloud Stream对Spring Cloud体系中的Mq进⾏了很好的上层抽象，可以让我们与具体消息中间件解耦合，屏蔽掉了底层具体MQ消息中间件的细节差异，就像Hibernate屏蔽掉了具体数据库（Mysql/Oracle⼀样）。如此⼀来，我们学习、开发、维护MQ都会变得轻松。⽬前Spring Cloud Stream原生⽀持RabbitMQ和Kafka，阿里在这个基础上提供了RocketMQ的支持，简单使用Spring Cloud Stream 构建基于RocketMQ的生产者和消费者
二、 Spring Cloud Stream的一些概念 要理解和使用Spring Cloud Stream需要先明白Spring Cloud Stream提出的一些概念。
辅助图 假设：模块1和模块2间数据可能使用的是kafka，模块1向kafka中push数据，模块2向kafka中poll数据。而模块2和模块3可能使用的是rabbitMQ。很明显，它们的功能都是一样的：提供数据的流向，让数据可以流入自己同时又可以从自己流出发给别人。但由于中间件的不同，需要使用不同的API。为了消除这种数据流入（输入）和数据流出（输出）实现上的差异性，因此便出现了Spring Cloud Stream。Spring Cloud Stream想让我们不关心如何获取数据，如何发送数据，而只专心处理自己的业务。还拿上面的例子来说，假设你现在负责的是系统里的模块3，它的功能是将模块2传来的字符串全部转成大写，然后再将这个转化后的字符串发给模块4。
Binder 什么是Binder？一句话概括就是具体中间件的统一抽象。一个kafka中间件在Spring Cloud Stream里是一个Binder，一个rabbitMQ中间件也是一个Binder。官方文档中写道：当你引入spring-cloud-stream依赖的时候，Spring Cloud Stream就会为你的那个中间件生成一个Binder实例，你就可以通过这个Binder实例来和这个消息中间件通信（收发数据）。很容易得出结论，Spring Cloud Stream对底层中间件的差异屏蔽都是基于我们的Binder，Binder适配了不同的消息中间件（官方文档中写道：Spring Cloud Stream为kafka和rabbitMQ提供了Binder的实现了）。
Binding Binding是个比较抽象的概念，那下面的例子来说：
public String handle(String source){ return source.toUpperCase(); } 这是你写的模块3中的业务代码，我们假设你与模块2交互使用的是中间件kafka和与模块4交互使用的是中间件rabbitMQ。也即你的模块的功能就变为了从kafka中获取数据，将获取的字符串数据全转为大写并写出给rabbitMQ。很明显，这里有两个Binder，一个kafka Binder一个rabbitMQ Binder。而你这个业务处理函数其实也有两个功能：接收中间件的输入和将返回数据输出。再结合Binder，我们可以理解为：
函数接收kafka Binder中的输入函数将返回结果写出给rabbitMQ binder。 但是如何表示这种关系呢？也即你现在写了一个函数，怎么表示这个函数的参数是从kafka入的，函数的返回是向rabbitMQ输出的呢？这就需要Binding。Binding其实就是一座桥，桥的一头是Binder，另一头是你的业务处理函数。Bindings将外部消息中间件与你的业务处理代码连接在了一起（官方原话是：外部消息系统和应用程序之间的桥梁，提供消息的生产者和消费者（由Binder创建））。
了解了这些其实也就了解Spring Cloud Stream的架构图，Spring Cloud Stream官网中有一张图讲了它的架构：
首先最底层的Middleware是中间件，我们的kafka，rabbitMQ都属于中间件。上一层的Binder已经讲了，是对中间件的一层抽象和封装。再上一层的inputs和outputs其实就是Bindings，我们与Binder的交互就是通过Binding，其中写出数据就是output，而获取数据就是input。再上层的Application Core就是我们自己的业务代码，可以看到我们的业务代码通过Binding（input、output）与Binder交互，而Binder又负责和具体中间件交互。
函数式接口 Spring Cloud Stream 2.x与Spring Cloud Stream 3.x最大的不同就是2.x是基于注解的，而3.x是基于函数式编程的。
还拿上面的例子来说：对于你开发的一个模块而言，它无非三种情况：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a7682f6c74eb2392f0540e34db99646b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-13T02:08:01+08:00" />
<meta property="article:modified_time" content="2023-07-13T02:08:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Cloud Stream使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Spring_Cloud_Stream_0"></a>一、什么是Spring Cloud Stream</h3> 
<p>Spring Cloud Stream对Spring Cloud体系中的Mq进⾏了很好的上层抽象，可以让我们与具体消息中间件解耦合，<code>屏蔽掉了底层具体MQ消息中间件的细节差异，就像Hibernate屏蔽掉了具体数据库（Mysql/Oracle⼀样）</code>。如此⼀来，我们学习、开发、维护MQ都会变得轻松。<code>⽬前Spring Cloud Stream原生⽀持RabbitMQ和Kafka，阿里在这个基础上提供了RocketMQ的支持，简单使用Spring Cloud Stream 构建基于RocketMQ的生产者和消费者</code></p> 
<h3><a id="_Spring_Cloud_Stream_5"></a>二、 Spring Cloud Stream的一些概念</h3> 
<p>要理解和使用Spring Cloud Stream需要先明白Spring Cloud Stream提出的一些概念。</p> 
<ul><li>辅助图</li></ul> 
<p><img src="https://images2.imgbox.com/5b/07/X1vDFbmP_o.png" alt="在这里插入图片描述"></p> 
<p>假设：模块1和模块2间数据可能使用的是kafka，模块1向kafka中push数据，模块2向kafka中poll数据。而模块2和模块3可能使用的是rabbitMQ。很明显，它们的功能都是一样的：提供数据的流向，让数据可以流入自己同时又可以从自己流出发给别人。但由于中间件的不同，需要使用不同的API。<code>为了消除这种数据流入（输入）和数据流出（输出）实现上的差异性，因此便出现了Spring Cloud Stream</code>。Spring Cloud Stream想让我们不关心如何获取数据，如何发送数据，而只专心处理自己的业务。还拿上面的例子来说，假设你现在负责的是系统里的模块3，它的功能是将模块2传来的字符串全部转成大写，然后再将这个转化后的字符串发给模块4。</p> 
<ol><li>Binder</li></ol> 
<p>什么是Binder？一句话概括就是具体中间件的统一抽象。<code>一个kafka中间件在Spring Cloud Stream里是一个Binder，一个rabbitMQ中间件也是一个Binder</code>。官方文档中写道：当你引入spring-cloud-stream依赖的时候，Spring Cloud Stream就会为你的那个中间件生成一个Binder实例，你就可以通过这个Binder实例来和这个消息中间件通信（收发数据）。很容易得出结论，<code>Spring Cloud Stream对底层中间件的差异屏蔽都是基于我们的Binder，Binder适配了不同的消息中间件</code>（官方文档中写道：Spring Cloud Stream为kafka和rabbitMQ提供了Binder的实现了）。</p> 
<ol start="2"><li>Binding</li></ol> 
<p>Binding是个比较抽象的概念，那下面的例子来说：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">String</span> source<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> source<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这是你写的模块3中的业务代码，我们假设你与模块2交互使用的是中间件kafka和与模块4交互使用的是中间件rabbitMQ。也即你的模块的功能就变为了从kafka中获取数据，将获取的字符串数据全转为大写并写出给rabbitMQ。很明显，<code>这里有两个Binder，一个kafka Binder一个rabbitMQ Binder</code>。而你这个业务处理函数其实也有两个功能：接收中间件的输入和将返回数据输出。再结合Binder，我们可以理解为：</p> 
<blockquote> 
 <ol><li>函数接收kafka Binder中的输入</li><li>函数将返回结果写出给rabbitMQ binder。</li></ol> 
</blockquote> 
<p>但是如何表示这种关系呢？也即你现在写了一个函数，<code>怎么表示这个函数的参数是从kafka入的，函数的返回是向rabbitMQ输出的呢？这就需要Binding</code>。<code>Binding其实就是一座桥，桥的一头是Binder，另一头是你的业务处理函数</code>。Bindings将外部消息中间件与你的业务处理代码连接在了一起（官方原话是：外部消息系统和应用程序之间的桥梁，提供消息的生产者和消费者（由Binder创建））。</p> 
<p>了解了这些其实也就了解Spring Cloud Stream的架构图，Spring Cloud Stream官网中有一张图讲了它的架构：</p> 
<p><img src="https://images2.imgbox.com/d3/9f/uBPeiK36_o.png" alt="SCSt with binder
SCSt with binder"></p> 
<p>首先最底层的Middleware是中间件，我们的kafka，rabbitMQ都属于中间件。上一层的Binder已经讲了，是对中间件的一层抽象和封装。<code>再上一层的inputs和outputs其实就是Bindings，我们与Binder的交互就是通过Binding</code>，其中写出数据就是output，而获取数据就是input。再上层的Application Core就是我们自己的业务代码，可以看到我们的业务代码通过Binding（input、output）与Binder交互，而Binder又负责和具体中间件交互。</p> 
<ol start="3"><li>函数式接口</li></ol> 
<p>Spring Cloud Stream 2.x与Spring Cloud Stream 3.x最大的不同就是2.x是基于注解的，而3.x是基于函数式编程的。</p> 
<p>还拿上面的例子来说：对于你开发的一个模块而言，它无非三种情况：</p> 
<blockquote> 
 <ol><li>从上一个模块获取数据，将这个数据转发到下一个模块</li><li>从上一个模块获取数据，自己处理完后不再将这个数据发给别的模块</li><li>不需要从别处获取数据，自己就是数据源，将自己的数据发送到下一个模块。</li></ol> 
</blockquote> 
<p>这三种模式其实就对应Java 8函数式编程中的三个接口：<code>Function、Consumer、Supplier</code>（不了解这三个接口的可自行搜索相关资料，关键字：Java 8；函数式接口）。</p> 
<p>现在我们还来模拟之前的系统，首先模块1是系统的入口模块，不需要其他模块提供数据源，换言之它是个生产者，那么模块1就可以使用接口Supplier（只有返回没有入参）。我们假设模块1的功能是生成字符串，那模块1的代码可以写为：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">produceStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"hello spring cloud stream"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>模块2会消费模块1的字符串，并将它全部转为大写，然后再将转化后的字符串写出。很明显模块2既是生产者也是消费者，那模块2就可以使用接口Function（既有返回也有入参）。模块2的代码为：</p> 
<pre><code class="prism language-bash">public Function<span class="token operator">&lt;</span>String,String<span class="token operator">&gt;</span> <span class="token function-name function">upperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token builtin class-name">return</span> String::toUpperCase<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>模块3会消费模块2的字符串，并将它直接打印到控制台，且模块3不再将字符串写出，很明显模块3只是一个消费者，那模块3就可以使用接口Consumer（只有入参没有返回）。模块3的代码为：</p> 
<pre><code class="prism language-bash">public Consumer<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token function-name function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token builtin class-name">return</span> System.out::println<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，我们将自己的业务处理都封装成了一个函数式接口，并作为一个函数的返回。在实际的开发中上面的那些函数都会被标上@Bean注解，注入到Spring容器，也即：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">produceStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"hello spring cloud stream"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">upperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toUpperCase</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们知道这代表向Spring中注入一个Bean，<code>其中Bean的名字就是函数名，而Bean本身就是函数的返回。也即我们将自己的业务处理逻辑包装成一个对象（函数式接口）注入到了Spring IOC中。</code>现在假设Binder收到了一条数据，那它会寻找Binding，而Binding是一个桥梁，它会连接一个我们的处理函数，处理函数其实就是这里的Bean，Binder拿到Bean后，自然就会调用Bean的处理函数来处理（因为是函数式接口）。</p> 
<p>如果用一张图来描述的话，大概就是这样：<br> <img src="https://images2.imgbox.com/9d/df/GF7NjYwI_o.png" alt="在这里插入图片描述"></p> 
<p>这里主要讲的就是我们之前的业务处理被函数式接口包装成了对象，包装成对象后就可以注入到Spring IOC中，<code>这样的一个Bean对象就可以对应一个Binding，通过Binding与Binder交互。</code></p> 
<h3><a id="_109"></a>三、案例</h3> 
<p>说了那么多，还是没讲怎么使用。我们不妨还以文档一开始的那个例子来作为编码案例：</p> 
<p>现在的需求如下：</p> 
<blockquote> 
 <ol><li>模块1生产字符串，并将字符串写出到kafka</li><li>模块2消费模块1的字符串，并将字符串转为大写，输出到rabbitMQ</li><li>模块3消费模块2的字符串，并将字符串打印到控制台。</li></ol> 
</blockquote> 
<p>也即：</p> 
<p><img src="https://images2.imgbox.com/d4/78/JlUYkHwX_o.png" alt="在这里插入图片描述"><br> 为了项目的简洁，我们将上述模块1、模块2和模块3写在一个项目中。</p> 
<ol><li>docker-compose，kafka与rabbitMQ</li></ol> 
<pre><code class="prism language-yaml">  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> rabbitmq<span class="token punctuation">:</span>3.10.6
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> rabbitmq
    <span class="token key atrule">build</span><span class="token punctuation">:</span>
      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./rabbitmq
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">RABBITMQ_DEFAULT_USER</span><span class="token punctuation">:</span> ruoyi
      <span class="token key atrule">RABBITMQ_DEFAULT_PASS</span><span class="token punctuation">:</span> ruoyi123
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"15672:15672"</span> <span class="token comment"># 管理界面端口</span>
      <span class="token punctuation">-</span> <span class="token string">"5672:5672"</span>   <span class="token comment"># api 端口</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> /docker/rabbitmq/log<span class="token punctuation">:</span>/var/log/rabbitmq
      <span class="token punctuation">-</span> /docker/rabbitmq/data<span class="token punctuation">:</span>/var/lib/rabbitmq

  <span class="token key atrule">zookeeper</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">'bitnami/zookeeper:3.8.0'</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> zookeeper
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"2181:2181"</span>
      <span class="token punctuation">-</span> <span class="token string">"28080:8080"</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">TZ</span><span class="token punctuation">:</span> Asia/Shanghai
      <span class="token key atrule">ALLOW_ANONYMOUS_LOGIN</span><span class="token punctuation">:</span> <span class="token string">"yes"</span>
      <span class="token key atrule">ZOO_SERVER_ID</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token key atrule">ZOO_PORT_NUMBER</span><span class="token punctuation">:</span> <span class="token number">2181</span>
      <span class="token comment"># 自带的控制台 一般用不上可自行开启</span>
      <span class="token key atrule">ZOO_ENABLE_ADMIN_SERVER</span><span class="token punctuation">:</span> <span class="token string">"no"</span>
      <span class="token comment"># 自带控制台的端口</span>
      <span class="token key atrule">ZOO_ADMIN_SERVER_PORT_NUMBER</span><span class="token punctuation">:</span> <span class="token number">8080</span>

  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">'bitnami/kafka:3.2.0'</span>
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> kafka
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"9092:9092"</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">TZ</span><span class="token punctuation">:</span> Asia/Shanghai
      <span class="token comment"># 更多变量 查看文档 https://github.com/bitnami/bitnami-docker-kafka/blob/master/README.md</span>
      <span class="token key atrule">KAFKA_BROKER_ID</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token comment"># 监听端口</span>
      <span class="token key atrule">KAFKA_CFG_LISTENERS</span><span class="token punctuation">:</span> PLAINTEXT<span class="token punctuation">:</span>//<span class="token punctuation">:</span><span class="token number">9092</span>
      <span class="token comment"># 实际访问ip 本地用 127 内网用 192 外网用 外网ip</span>
      <span class="token key atrule">KAFKA_CFG_ADVERTISED_LISTENERS</span><span class="token punctuation">:</span> PLAINTEXT<span class="token punctuation">:</span>//192.168.1.8<span class="token punctuation">:</span><span class="token number">9092</span>
      <span class="token key atrule">KAFKA_CFG_ZOOKEEPER_CONNECT</span><span class="token punctuation">:</span> 192.168.1.8<span class="token punctuation">:</span><span class="token number">2181</span>
      <span class="token key atrule">ALLOW_PLAINTEXT_LISTENER</span><span class="token punctuation">:</span> <span class="token string">"yes"</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> /docker/kafka/data<span class="token punctuation">:</span>/bitnami/kafka/data
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> zookeeper
</code></pre> 
<ol start="2"><li>maven依赖</li></ol> 
<p>我们需要的依赖并不多，其实只需要rabbit和kafka的依赖，整个项目的maven配置如下：</p> 
<pre><code class="prism language-xml">        <span class="token comment">&lt;!-- 主要依赖，版本由导入的springcloud帮我们控制--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-stream-rabbit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-stream-kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<ol start="3"><li>配置文件之Binder</li></ol> 
<p>之前已经讲了一个kafka实例或者rabbitMQ实例其实就是一个binder，那你现在有了一个kafka，要如何告诉Spring Cloud呢？最简单的就是通过配置文件，<code>配置文件配置Binder的思想很简单，就是告诉Spring Cloud Stream，我要创建一个Binder，这个Binder的类型是kafka或者rabbitMQ，然后它的IP，端口都是啥以及用户名密码等都是啥就好了</code>。</p> 
<p>我们先以kafka为例，配置kafka为Binder有两种方式：</p> 
<ul><li>方式1:</li></ul> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
        <span class="token key atrule">binder</span><span class="token punctuation">:</span>
          <span class="token comment"># kafka的Ip和端口，可以是集群</span>
          <span class="token key atrule">brokers</span><span class="token punctuation">:</span> ip<span class="token punctuation">:</span>port
</code></pre> 
<p>方式2:</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">binders</span><span class="token punctuation">:</span>
        <span class="token comment"># 你的binder名字，自己随意取，我取的名字叫myKafka</span>
        <span class="token key atrule">myKafka</span><span class="token punctuation">:</span>
          <span class="token comment"># 你的binder类型，我们这里类型是kafka</span>
          <span class="token key atrule">type</span><span class="token punctuation">:</span> kafka
          <span class="token comment"># 下面的环境配置与上面的一模一样</span>
          <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token key atrule">spring</span><span class="token punctuation">:</span>
              <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
                <span class="token key atrule">stream</span><span class="token punctuation">:</span>
                  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
                    <span class="token key atrule">binder</span><span class="token punctuation">:</span>
                      <span class="token comment"># kafka的Ip和端口，可以是集群</span>
                      <span class="token key atrule">brokers</span><span class="token punctuation">:</span> ip<span class="token punctuation">:</span>port
</code></pre> 
<p>很明显，第二种比第一种更复杂，你如果只有一个kafka实例，那直接用第一种就可以了，但如果你的项目中有多个kafka实例，比如项目2和项目1之间用的是kafka，项目2和项目3间也用的kafka，这两个kafka又是不是同一套kafka。所以，第二种配置可以配备多个kafka实例，如：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">binders</span><span class="token punctuation">:</span>
        <span class="token key atrule">myKafka1</span><span class="token punctuation">:</span>
          <span class="token key atrule">type</span><span class="token punctuation">:</span> kafka
          <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token key atrule">spring</span><span class="token punctuation">:</span>
              <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
                <span class="token key atrule">stream</span><span class="token punctuation">:</span>
                  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
                    <span class="token key atrule">binder</span><span class="token punctuation">:</span>
                      <span class="token key atrule">brokers</span><span class="token punctuation">:</span> ip1<span class="token punctuation">:</span>port1
        <span class="token key atrule">myKafka2</span><span class="token punctuation">:</span>
          <span class="token key atrule">type</span><span class="token punctuation">:</span> kafka
          <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token key atrule">spring</span><span class="token punctuation">:</span>
              <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
                <span class="token key atrule">stream</span><span class="token punctuation">:</span>
                  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
                    <span class="token key atrule">binder</span><span class="token punctuation">:</span>
                      <span class="token key atrule">brokers</span><span class="token punctuation">:</span> ip2<span class="token punctuation">:</span>port2
</code></pre> 
<p>另外，如果你有多个kafka实例，<code>使用第一种方式下配备的属性信息会被这多个kafka实例共享</code>，如：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
        <span class="token key atrule">binder</span><span class="token punctuation">:</span>
          <span class="token key atrule">configuration</span><span class="token punctuation">:</span>
            <span class="token key atrule">security.protocol</span><span class="token punctuation">:</span> SASL_PLAINTEXT
            <span class="token key atrule">sasl.mechanism</span><span class="token punctuation">:</span> PLAIN
      <span class="token key atrule">binders</span><span class="token punctuation">:</span>
        <span class="token key atrule">myKafka1</span><span class="token punctuation">:</span>
          <span class="token key atrule">type</span><span class="token punctuation">:</span> kafka
          <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token key atrule">spring</span><span class="token punctuation">:</span>
              <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
                <span class="token key atrule">stream</span><span class="token punctuation">:</span>
                  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
                    <span class="token key atrule">binder</span><span class="token punctuation">:</span>
                      <span class="token key atrule">brokers</span><span class="token punctuation">:</span> ip1<span class="token punctuation">:</span>port1
                      <span class="token key atrule">configuration.sasl.jaas.config</span><span class="token punctuation">:</span> <span class="token string">"org.apache.kafka.common.security.plain.PlainLoginModule required username=\"admin\" password=\"admin-secret\";"</span>
        <span class="token key atrule">myKafka2</span><span class="token punctuation">:</span>
          <span class="token key atrule">type</span><span class="token punctuation">:</span> kafka
          <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token key atrule">spring</span><span class="token punctuation">:</span>
              <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
                <span class="token key atrule">stream</span><span class="token punctuation">:</span>
                  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
                    <span class="token key atrule">binder</span><span class="token punctuation">:</span>
                      <span class="token key atrule">brokers</span><span class="token punctuation">:</span> ip2<span class="token punctuation">:</span>port2
                      <span class="token key atrule">configuration.sasl.jaas.config</span><span class="token punctuation">:</span> <span class="token string">"org.apache.kafka.common.security.plain.PlainLoginModule required username=\"user1\" password=\"user1-secret\";"</span>
</code></pre> 
<p>我们现在有两个kafka实例myKafka1和myKafka2，但我们在一开头配置了security.protocol = SASL_PLAINTEXT和 sasl.mechanism = PLAIN，这是kafka的安全配置，这个配置信息会被myKafka1和myKafka2都具备。也即在一开始的这些配置会被每个kafka实例都具有，因此一些公共的配置可以放在一开始。</p> 
<p>同理rabbitMQ的配置也有两种：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> 你的rabbitMQ的IP
    <span class="token key atrule">port</span><span class="token punctuation">:</span> 你的rabbitMQ的端口
    <span class="token key atrule">username</span><span class="token punctuation">:</span> 用户名
    <span class="token key atrule">password</span><span class="token punctuation">:</span> 密码
YAML 复制
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">binders</span><span class="token punctuation">:</span>
        <span class="token key atrule">myRabbit</span><span class="token punctuation">:</span>
          <span class="token key atrule">type</span><span class="token punctuation">:</span> rabbit
          <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token key atrule">spring</span><span class="token punctuation">:</span>
              <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
                <span class="token key atrule">host</span><span class="token punctuation">:</span> 你的rabbitMQ的IP
                <span class="token key atrule">port</span><span class="token punctuation">:</span> 你的rabbitMQ的端口
                <span class="token key atrule">username</span><span class="token punctuation">:</span> 用户名
                <span class="token key atrule">password</span><span class="token punctuation">:</span> 密码
</code></pre> 
<p>是的，如果你只有一个rabbitMQ实例可以使用第一种，但如果有多个，就得使用第二种，它与kafka配置的思路一模一样，这里不再赘述。虽然我们只有一个kafka实例和一个rabitMQ实例，但笔者依然采取了第二种配置文件，一则是考虑到以后实例增多改动比较小的可能，二则是第二种配置笔者认为更清晰。项目对于Binder的配置全部信息为：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">binders</span><span class="token punctuation">:</span>
        <span class="token key atrule">myRabbit</span><span class="token punctuation">:</span>
          <span class="token key atrule">type</span><span class="token punctuation">:</span> rabbit
          <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token key atrule">spring</span><span class="token punctuation">:</span>
              <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
                <span class="token key atrule">host</span><span class="token punctuation">:</span> 你的rabbitMQ的IP
                <span class="token key atrule">port</span><span class="token punctuation">:</span> 你的rabbitMQ的端口
                <span class="token key atrule">username</span><span class="token punctuation">:</span> 用户名
                <span class="token key atrule">password</span><span class="token punctuation">:</span> 密码
        <span class="token key atrule">myKafka</span><span class="token punctuation">:</span>
          <span class="token key atrule">type</span><span class="token punctuation">:</span> kafka
          <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token key atrule">spring</span><span class="token punctuation">:</span>
              <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
                <span class="token key atrule">stream</span><span class="token punctuation">:</span>
                  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
                    <span class="token key atrule">binder</span><span class="token punctuation">:</span>
                      <span class="token key atrule">brokers</span><span class="token punctuation">:</span> ip<span class="token punctuation">:</span>port
</code></pre> 
<p>关于rabbitMQ与kafka更详细的配置，如自动提交，ACK等信息可以参考Spring官网，本文不再列出。</p> 
<ol start="4"><li>编写自己的业务代码</li></ol> 
<p>配置完Binder就代表你已经具备和外部消息中间件通信的能力了，现在你可以写自己的业务代码了：</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>coderzoe<span class="token punctuation">.</span>loggingconsumer</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">Consumer</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">Function</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">Supplier</span>

<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingConsumerApplication</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">LoggingConsumerApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 模块1 生产字符串
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">produceStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"hello spring cloud stream"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 模块2，将生产的字符串转为大写
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">upperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toUpperCase</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 模块3 将字符串打印
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>写完这些Bean后，我们还需要将它写到配置文件，告诉Spring Cloud，这些都是用于函数处理的Bean：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">function</span><span class="token punctuation">:</span>
      <span class="token key atrule">definition</span><span class="token punctuation">:</span> produceStr;upperCase;log
</code></pre> 
<ol start="5"><li>配置文件之Bindings</li></ol> 
<p>现在我们<code>有了Binder，也有了处理业务函数，肯定还差一个Binding，将Binder与业务处理联系起来</code>。联系起来的方法很简单，就是通过配置文件来配置。在讲配置文件前，我们先讲Binding的名称规范。Binding的命名是：<code>&lt;functionName&gt;-in/out-&lt;index&gt;。</code></p> 
<p>比如：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">produceStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"hello spring cloud stream"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>它的<code>Binding名字就是produceStr-out-0。其中produceStr是函数名（也是Bean名），out代表这个Binding是向外写出的，而index是输入或输出绑定的索引</code>。对于典型的单个输入/输出函数，它始终为 0，因此它仅与具有多个输入和输出参数的函数相关（一个函数被多次作为输出/输出，比如这个函数被kafka和rabbitMQ都作为输出，那就是一个index0一个index1）。</p> 
<p>再比如：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">upperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toUpperCase</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>它对应两个Binding，<code>因为它既是输入又是输出（从kafka入数据，向rabbitMQ出数据），它们的名字是：upperCase-in-0、upperCase-out-0</code>。可以看到，我们通过名字就将Binding和处理函数做了关联。关联了Binding与处理函数，还需要关联Binding与Binder，它的配置写法如下：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
        <span class="token key atrule">produceStr-out-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">binder</span><span class="token punctuation">:</span> myKafka
</code></pre> 
<p>通过在你的Binding中指明使用的是哪个binder就可以了。</p> 
<p>这样我们配置好了Binding，项目的Bindings完整配置如下：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
        <span class="token key atrule">produceStr-out-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">binder</span><span class="token punctuation">:</span> myKafka
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> topic1
        <span class="token key atrule">upperCase-in-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">binder</span><span class="token punctuation">:</span> myKafka
          <span class="token key atrule">group</span><span class="token punctuation">:</span> group1
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> topic1
        <span class="token key atrule">upperCase-out-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> topic2
          <span class="token key atrule">binder</span><span class="token punctuation">:</span> myRabbit
        <span class="token key atrule">log-in-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">binder</span><span class="token punctuation">:</span> myRabbit
          <span class="token key atrule">group</span><span class="token punctuation">:</span> group1
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> topic2
</code></pre> 
<p>这里在配置Binding的时候比上面多了group和destination两个属性，<code>其中group是消费组的意思，而destination是主题（topic）。</code>如果你不了解这两个概念，我建议你查阅一下kafka的相关资料。</p> 
<ol start="6"><li>主动发送消息</li></ol> 
<p>这样其实我们就完成了整个项目，启动项目你会发现：控制台会不断的打印HELLO SPRING CLOUD STREAM。</p> 
<p><img src="https://images2.imgbox.com/7f/8d/uAravxT6_o.png" alt="image-20221004212533640
image-20221004212533640"></p> 
<p>但这个消息我们是被动发送的，<code>因为Binder调用我们的produceStr-out-0这个Binding来不断的发送消息。很多时候我们是希望主动的发送消息的，比如处理完一条用户请求后，将处理结果发送出去。</code>Spring Cloud Stream主动发送消息借助于StreamBridge，它的用法如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SendService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">StreamBridge</span> streamBridge<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        streamBridge<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"upperCase-in-0"</span><span class="token punctuation">,</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，就是使用StreamBridge给一个in的Binding发送消息。</p> 
<ol start="6"><li>一些补充</li></ol> 
<ul><li>Message</li></ul> 
<p>我们刚才的文档一直在以字符串作为消息传递的数据，实际上消息传递的准确对象是org.springframework.messaging.Message，这是一个接口：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
   <span class="token comment">/**
    * Return the message payload.
    */</span>
   <span class="token class-name">T</span> <span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">/**
    * Return message headers for the message (never {@code null} but may be empty).
    */</span>
   <span class="token class-name">MessageHeaders</span> <span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>也即<code>生产者和消费者交互的对象其实是Message，我们之前写的String只是在生产时被Spring Cloud Stream封装为了Message，而在消费时又从Message转为了String</code>，因此我们其实完全可以这样写：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">produceStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span><span class="token string">"hello spring cloud stream"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但大部分场景下没有必要，还是那句话，因为Spring Cloud Stream会为我们自动“装箱”和“拆箱”。另外，消息是支持发送Java对象的，比如：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token comment">//省略 getter setter和toString</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">produceUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>消费者可以写为：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">logUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> s<span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">"_"</span><span class="token operator">+</span>s<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>很明显，对象想要被发送需要被序列化，且想要被消费也需要被反序列化，<code>在Spring Cloud Stream中默认的序列化是json。也即对象会被以application/json的形式发送出去</code>。</p> 
<p>这可以在配置文件中进行修改：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">produceUser-out-0</span><span class="token punctuation">:</span>
  <span class="token key atrule">binder</span><span class="token punctuation">:</span> myKafka
  <span class="token key atrule">destination</span><span class="token punctuation">:</span> topic1
  <span class="token key atrule">content-type</span><span class="token punctuation">:</span> application/json
</code></pre> 
<p>是不是发现和Spring MVC有点眼熟，是的，其实就是Spring MVC那一套。</p> 
<ol start="7"><li>消费组</li></ol> 
<p>我们在配置文件之Bindings中为消费的Binding配置了一个group，<code>Spring Cloud Stream建议大家为每个消费者都显示声明一个消费组，因为这样可以保证“断点续传”的功能。比如你消费者挂了，如果指明了消费组，重启后可以从之前挂掉的地方继续消费</code>，但如果没有指明消费组，Spring Cloud Stream会分配一个匿名的消费组，但每次启动这个名字可能都会变，这样可能会导致重启后重复消费。</p> 
<p><a href="http://www.coderzoe.com/archives/31/" rel="nofollow">文章转自</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/179439963025dc16c86e35540a5bd712/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">innerHTML和outerHTML的异同点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/24def7bedbe77b680bdcf2cb4ad262c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网上购物商城 基于&#43;vue（含文档）超市零食商城系统源码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>