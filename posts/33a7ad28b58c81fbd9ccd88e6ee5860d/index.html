<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>&lt;Principles of fMRI 1&gt;课程笔记8--fMRI的数据预处理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="&lt;Principles of fMRI 1&gt;课程笔记8--fMRI的数据预处理" />
<meta property="og:description" content="刚采集的原始图像数据会经过一系列的预处理步骤。这些步骤主要是分辨并去除伪影（Artifact），或者是检验一些模型所需的假设是否成立。具体来说，有三个目的：
尽量减少因为数据采集（Data acquisition）和生理学特性（Physiological）导致的误差我们想检验一下模型的统计假设，并且尽可能的做一些变换让数据符合这些假设将不同个体的数据的脑区位置标准化（Standardize the location of brain region）以便于进行组间分析（Group analysis）。只有这样组间分析才具有较好的效度（Validity）和灵敏度（Sensitivity）。 扫描得到的功能图像和结构图象都要经过预处理。而且预处理的过程中功能图像和结构图像也要经过相互对比计算的。这里有张图显示了我们通常用到的预处理的步骤。
预处理步骤包括：可视化（Visualization）、去伪影（Artifact removal）、时间配准（Slice time correction）、头动校正（Motion correction）、生理噪音校正（Correction for physiological effect）、结构功能配准（Co-registration）、标准化（Normalization）和时空间滤波（Spatial and temporal filtering）。
一、Visualization and Artifact Removal 先来讲讲可视化的去伪影。在任何情况下这都一定是预处理的第一步。我们会探索性的看看刚采集的原始图像数据（Raw imagine data）有哪些问题。找到了问题才知道要用什么模型去去伪影。比如有些时候数据会出现一些异常陡峭的峰波（Spike）或者是缓慢的偏倚（Drift）。有很多种方法，例如主成分分析法（PCA，Principle components analysis），可以用来探测这些异常的峰波。
二、Slice Time Correction 在扫描一次完整大脑（Brain volume）的周期（TR，Repetition time）内，我们会扫好几片脑片（Slice），由于我们一个时间点只能扫描一张脑片，如果是按照顺序一张一张扫下去的话，每张脑片之间的扫面时间点都会有区别。比如最顶端的脑片的扫描时间会相对低端的脑片延迟2s。例如在这张图里。脑片1、2、3分别在不同的时间点上被扫描。如果我们不做时间回归直接处理的话，由于我们采样的时间点不相同，三个脑片的信号看起来很不一样，尽管实际上他们来源于同一个信号。
因此我们需要用插值（Interpolation）等方法来获得三个脑片相同时间点的数据。所谓插值就是通过与未知点相邻的已知点的信号值来预测位置点的值。我们通常用的插值函数类有线性函数和三角函数。当然，你也可以用傅里叶变换。求出傅里叶级数后平移相位就好。（其实个人认为这个就是三角函数插值）
三、Motion Correction 头动（Head motion）也是一个很严重的干扰。我们在做后续分析的时候需要假设每个体素时时刻刻对应的都是大脑的同一个位置。可是扫描的时候被试的头肯定会有微小的移动。这样的话一个体素可能在下一秒就对应了脑中另外一个截然不同的位置。因此我们会用刚性变换（Rigid body transformation）把所有的图像中的脑都固定在同一个靶位置（Target imagine）（我们假设头动过程中脑一直是个刚体）
一个刚体变换包含了六个自由度，即关于X,Y,Z轴三个方向的平移（Translation）以及围绕这三个轴的旋转（Rotation）。
下面这张图说明了以上的几种基本变换，当然有时候我们还可能用到缩放变换（Scaling）和切变换（Shearing）其实还有很多的线性变换可以用的。例如
相似变换（平移，旋转和等比缩放，七个自由度）仿射变换（关于三个轴的平移，旋转，缩放和切变换，12个自由度） 除此之外还有非线性变换（Warping method），即方程对图像的处理是非线性（Nonlinear）的。
不管怎样我们变换的最终目的是使处理过的图像与靶图像尽量的重合。我们会有一个代价函数来描述处理过的图像与靶图像的相似度和重合度。例如我们可以使用所有体素数据值的差的平方和或者互信息（Mutual information）（信息论里一种有用的信息度量，它可以看成是一个随机变量中包含的关于另一个随机变量的信息量，或者说是一个随机变量由于已知另一个随机变量而减少的不肯定性）。
一般来说靶图像选取的是第一张图像或者所以图像关于时间的平均图像（Mean imagine）。
例如这张图，我们有一个靶图像，还有一个等着我们变换的图像（Input imagine）。我们希望经过一些列的平移很旋转使蓝色的大脑和绿色的重合在一起。这就是头动校正。
注：软件计算出的旋转角度和平移距离的曲线，横坐标是输入图像（Input imagine）的序号（按时间排列）
四、Co-registration 接下来的事情就是结构图像与功能图像配准（Co-registration）了。我们希望能把功能图像上的点定位在有着较高分辨率的结构图像上。
虽然我们分析的是较低分辨率的功能图像，但当我们将其定位在结构图象上时，我们可以发现一些更细节的问题。配准也为我们之后要讲到的标准脑（Standard coordinate system）提供了很大的帮助。
一般来说我们会在实验的每轮扫描的开始扫一张结构图像。虽然说结构图像和功能图像是在同一论扫描里扫得的。但往往它们往往是没法重合覆盖在一起的。一是因为他们测量不是一个东西（编者注：一个是组织一个是血流信号），二是因为测量过程中会有头动。
结构图像和功能图像有这么几个区别：
信号的数量级不一样，没法直接对比形状不一样。至少要用仿射变换才能配在一起。在这里我们一般使用Mutual Information 来作为代价函数 注：软件SPM算出的配准变换方式。
下图 1是预处理的流程，可以看到不仅功能像需要进行预处理，实验前获得的结构像也需要进行预处理。在上个模块中我们讨论了寻找尖峰伪影（spike artifacts），扫描层时间校正（slice time correction），头动校正（motion correction），以及结构像和功能像的配准（co-registration）。 图 1 fMRI数据预处理流程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/33a7ad28b58c81fbd9ccd88e6ee5860d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-09T09:38:39+08:00" />
<meta property="article:modified_time" content="2017-01-09T09:38:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">&lt;Principles of fMRI 1&gt;课程笔记8--fMRI的数据预处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>刚采集的原始图像数据会经过一系列的预处理步骤。这些步骤主要是分辨并去除伪影（Artifact），或者是检验一些模型所需的假设是否成立。具体来说，有三个目的：</p> 
<ul><li>尽量减少因为数据采集（Data acquisition）和生理学特性（Physiological）导致的误差</li><li>我们想检验一下模型的统计假设，并且尽可能的做一些变换让数据符合这些假设</li><li>将不同个体的数据的脑区位置标准化（Standardize the location of brain region）以便于进行组间分析（Group analysis）。只有这样组间分析才具有较好的效度（Validity）和灵敏度（Sensitivity）。</li></ul> 
<p>扫描得到的功能图像和结构图象都要经过预处理。而且预处理的过程中功能图像和结构图像也要经过相互对比计算的。这里有张图显示了我们通常用到的预处理的步骤。</p> 
<p><img src="https://images2.imgbox.com/10/df/1SMafs6B_o.png" alt="这里写图片描述" title=""></p> 
<p>预处理步骤包括：可视化（Visualization）、去伪影（Artifact removal）、时间配准（Slice time correction）、头动校正（Motion correction）、生理噪音校正（Correction for physiological effect）、结构功能配准（Co-registration）、标准化（Normalization）和时空间滤波（Spatial and temporal filtering）。</p> 
<p><img src="https://images2.imgbox.com/96/98/2KYB23Ll_o.png" alt="这里写图片描述" title=""></p> 
<p><img src="https://images2.imgbox.com/21/ab/XX8D5lhU_o.png" alt="这里写图片描述" title=""></p> 
<h3 id="一visualization-and-artifact-removal">一、Visualization and Artifact Removal</h3> 
<p>先来讲讲可视化的去伪影。在任何情况下这都一定是预处理的第一步。我们会探索性的看看刚采集的原始图像数据（Raw imagine data）有哪些问题。找到了问题才知道要用什么模型去去伪影。比如有些时候数据会出现一些异常陡峭的峰波（Spike）或者是缓慢的偏倚（Drift）。有很多种方法，例如主成分分析法（PCA，Principle components analysis），可以用来探测这些异常的峰波。</p> 
<p><img src="https://images2.imgbox.com/d1/7f/1H72yFzS_o.png" alt="这里写图片描述" title=""></p> 
<h3 id="二slice-time-correction">二、Slice Time Correction</h3> 
<p>在扫描一次完整大脑（Brain volume）的周期（TR，Repetition time）内，我们会扫好几片脑片（Slice），由于我们一个时间点只能扫描一张脑片，如果是按照顺序一张一张扫下去的话，每张脑片之间的扫面时间点都会有区别。比如最顶端的脑片的扫描时间会相对低端的脑片延迟2s。例如在这张图里。脑片1、2、3分别在不同的时间点上被扫描。如果我们不做时间回归直接处理的话，由于我们采样的时间点不相同，三个脑片的信号看起来很不一样，尽管实际上他们来源于同一个信号。</p> 
<p><img src="https://images2.imgbox.com/2b/3d/o2bqRNFf_o.png" alt="这里写图片描述" title=""></p> 
<p>因此我们需要用插值（Interpolation）等方法来获得三个脑片相同时间点的数据。所谓插值就是通过与未知点相邻的已知点的信号值来预测位置点的值。我们通常用的插值函数类有线性函数和三角函数。当然，你也可以用傅里叶变换。求出傅里叶级数后平移相位就好。（其实个人认为这个就是三角函数插值）</p> 
<h3 id="三motion-correction">三、Motion Correction</h3> 
<p>头动（Head motion）也是一个很严重的干扰。我们在做后续分析的时候需要假设每个体素时时刻刻对应的都是大脑的同一个位置。可是扫描的时候被试的头肯定会有微小的移动。这样的话一个体素可能在下一秒就对应了脑中另外一个截然不同的位置。因此我们会用刚性变换（Rigid body transformation）把所有的图像中的脑都固定在同一个靶位置（Target imagine）（我们假设头动过程中脑一直是个刚体）</p> 
<p>一个刚体变换包含了六个自由度，即关于X,Y,Z轴三个方向的平移（Translation）以及围绕这三个轴的旋转（Rotation）。</p> 
<p>下面这张图说明了以上的几种基本变换，当然有时候我们还可能用到缩放变换（Scaling）和切变换（Shearing）其实还有很多的线性变换可以用的。例如</p> 
<ul><li>相似变换（平移，旋转和等比缩放，七个自由度）</li><li>仿射变换（关于三个轴的平移，旋转，缩放和切变换，12个自由度）</li></ul> 
<p><img src="https://images2.imgbox.com/56/a5/gD4ySGFs_o.png" alt="这里写图片描述" title=""></p> 
<p>除此之外还有非线性变换（Warping method），即方程对图像的处理是非线性（Nonlinear）的。</p> 
<p>不管怎样我们变换的最终目的是使处理过的图像与靶图像尽量的重合。我们会有一个代价函数来描述处理过的图像与靶图像的相似度和重合度。例如我们可以使用所有体素数据值的差的平方和或者互信息（Mutual information）（信息论里一种有用的信息度量，它可以看成是一个随机变量中包含的关于另一个随机变量的信息量，或者说是一个随机变量由于已知另一个随机变量而减少的不肯定性）。</p> 
<p><img src="https://images2.imgbox.com/1b/98/lsMpiMCU_o.png" alt="这里写图片描述" title=""></p> 
<p>一般来说靶图像选取的是第一张图像或者所以图像关于时间的平均图像（Mean imagine）。</p> 
<p>例如这张图，我们有一个靶图像，还有一个等着我们变换的图像（Input imagine）。我们希望经过一些列的平移很旋转使蓝色的大脑和绿色的重合在一起。这就是头动校正。</p> 
<p><img src="https://images2.imgbox.com/39/d0/T2kiMmPK_o.png" alt="这里写图片描述" title=""></p> 
<p><img src="https://images2.imgbox.com/ff/76/kWCHHCFQ_o.png" alt="这里写图片描述" title=""></p> 
<p>注：软件计算出的旋转角度和平移距离的曲线，横坐标是输入图像（Input imagine）的序号（按时间排列）</p> 
<h3 id="四co-registration">四、Co-registration</h3> 
<p>接下来的事情就是结构图像与功能图像配准（Co-registration）了。我们希望能把功能图像上的点定位在有着较高分辨率的结构图像上。</p> 
<p><img src="https://images2.imgbox.com/85/7e/qHqfNFTv_o.png" alt="这里写图片描述" title=""></p> 
<p>虽然我们分析的是较低分辨率的功能图像，但当我们将其定位在结构图象上时，我们可以发现一些更细节的问题。配准也为我们之后要讲到的标准脑（Standard coordinate system）提供了很大的帮助。</p> 
<p>一般来说我们会在实验的每轮扫描的开始扫一张结构图像。虽然说结构图像和功能图像是在同一论扫描里扫得的。但往往它们往往是没法重合覆盖在一起的。一是因为他们测量不是一个东西（编者注：一个是组织一个是血流信号），二是因为测量过程中会有头动。</p> 
<p>结构图像和功能图像有这么几个区别：</p> 
<ul><li>信号的数量级不一样，没法直接对比</li><li>形状不一样。至少要用仿射变换才能配在一起。在这里我们一般使用Mutual Information 来作为代价函数</li></ul> 
<p><img src="https://images2.imgbox.com/28/d1/8VXhlTXT_o.png" alt="这里写图片描述" title=""></p> 
<p>注：软件SPM算出的配准变换方式。</p> 
<p>下图 1是预处理的流程，可以看到不仅功能像需要进行预处理，实验前获得的结构像也需要进行预处理。在上个模块中我们讨论了寻找尖峰伪影（spike artifacts），扫描层时间校正（slice time correction），头动校正（motion correction），以及结构像和功能像的配准（co-registration）。 <br> <img src="https://images2.imgbox.com/98/bb/vJwmPMAi_o.png" alt="图 1 fMRI数据预处理流程" title=""> <br> 图 1 fMRI数据预处理流程</p> 
<p>在这个模块中我们会讨论将图像与脑图谱模板（atlas template）配准及平滑（smoothing）的过程。通常来说，每个人的大脑都是不同的，两个个体的大脑尺寸差异可以达到30%，大脑形状也可能存在显著差别，所以标准化（normalization）所做的正是通过拉伸、压缩以及卷绕使得扫描得到的大脑与标准大脑模板一致。这对于组分析（group analysis）而言很重要，因为我们想要对比不同的大脑，当我们关注某一个体素（voxel）时，我们希望能够在所有被试个体的扫描图像中看到这个体素，这就需要所有的大脑“匹配”至同一个标准脑空间（standard brain space）。所以高分辨率的T1结构像现在又被配准至标准空间（normalized space），如下图 2所示。 <br> <img src="https://images2.imgbox.com/49/c4/BNFsIvoA_o.png" alt="这里写图片描述" title=""></p> 
<p>注：从图 1的流程图中可以看出，课程中所讲的标准化是先将高分辨率的T1结构像与标准模板（此处的标准模板是高分辨率的结构像标准模板）进行配准，再直接将这些配准参数应用于功能像上（因为功能像之前已经与结构像进行过一次配准），这也是目前比较普遍的一种做法，因为T1结构像分辨率高，大脑内部结构可精准对齐。但还有另外一种做法，可以直接将功能像与标准模板（此处的标准模板是低分辨率的功能像标准模板）进行配准，这种做法在SPM软件中比较常见，不需要借助T1结构像，但在对齐效果上较差。</p> 
<p>标准化的优点是：</p> 
<ul><li>可以以一致的方式报告和解释空间位置。在标准空间内讨论某一坐标时，我们总能知道它在哪里。</li><li>实验结果可以被推广到更大的群体，因为我们可以对不同个体进行比较。</li><li>实验结果可以跨研究进行比较，前提是每个研究在标准化过程中采用同一大脑模板。</li><li>不同个体的实验结果可以进行平均。</li></ul> 
<p>缺点是：</p> 
<ul><li>会降低空间分辨率。</li><li>引入潜在误差。</li></ul> 
<p>目前主要有两个脑图谱模板被广泛使用。一是Talairach图谱，由Talairach建立，随后Talairach和Tournoux在1988年对其进行了更新。Talairach图谱是基于一位60岁女性尸体的单个大脑半球建立的，在该图谱中，原点被设定在前联合（Anterior Commissure），水平向被设定为前联合与后联合（Posterior Commissure）的连线方向。近来，另外一个MNI脑图谱（Montreal Neurological Institute Brain Atlas）也越来越常用。该图谱集合了许多正常对照组的MRI扫描数据，在现行的ICBM-152模板中就集合了152个右利手个体的脑区图。相较于基于单个个体建立的脑图谱（如Talairach图谱），MNI图谱更具代表性。</p> 
<p>进行标准化的方法有很多，这里作简要介绍：</p> 
<ul><li>标定点法（Landmark-based methods），根据大脑的解剖结构特征，找到不同个体的大脑标定点，并将其与标准模板的标定点对齐（如Talairach图谱的标记点就包括前联合、后联合、颅正中矢状平面以及在每一方向上的大脑外边界）。</li><li><p>基于体积配准法（volume-based registration），利用线性和非线性变换实现（与结构像和功能像配准时所采用的方法相似）。</p></li><li><p>计算解剖学法（computational anatomy methods），采用微分同胚变换。</p></li><li>表层法（surface-based methods），主适用于皮层表面（you sort of blow up the brain and <br> do normalization that way）。</li></ul> 
<p>标准化之后我们要做的就是空间滤波，在统计分析前对采集到的数据进行空间平滑是很普遍的，这可以提高信噪比（signal to noise ratio），消除伪影（artifacts），使数据更符合分布假设（distributional assumptions）。例如，我们经常假设数据呈正态分布，通过对许多体素取平均值的平滑过程，可以增加其呈正态分布的可能性。</p> 
<p>空间滤波的优点是：</p> 
<ul><li>通过模糊残留的解剖结构差异，克服标准化过程的缺陷。标准化过程并不完美，有时会造成图像上出现一些解剖结构差异（失匹配现象），这就需要通过模糊的方式来消除差异。</li><li>提高信噪比。例如，有一片区域被激活，我们对这片区域进行均值滤波，可以保留其信号强度但降低噪声强度（因为噪声多为正态分布，有正有负，取均值后噪声强度降低，均值滤波实质是一种低通滤波，保留低频的信号成分，滤掉高频噪声成分），从而提高信噪比。</li><li>增强统计分析的效力。</li><li>满足高斯随机场理论的分析要求。高斯随机场理论在多重比较中广泛应用。</li></ul> 
<p>缺点是：</p> 
<ul><li>降低图像分辨率，丢失信息。</li></ul> 
<p>对图像进行空间滤波时，我们经常使用高斯核（Gaussian kernel），该平滑核的尺寸（平滑范围）由半高宽（full width at half maximum, FWHM）决定。如下图 3所示，半高宽是指：分布函数在其峰值一半位置上的峰宽。对于高斯分布而言，其半高宽与标准差存在关系：<span class="MathJax_Preview"></span></p> 
<div class="MathJax_Display" style="text-align: center;"> 
 <span class="MathJax" id="MathJax-Element-17-Frame"> 
   
   <span class="math" id="MathJax-Span-257" style="width: 8.109em; display: inline-block;"><span style="display: inline-block; position: relative; width: 6.456em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.229em 1000em 4.056em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-258"><span class="mi" id="MathJax-Span-259" style="font-family: MathJax_Math-italic;">σ<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-260" style="font-family: MathJax_Main; padding-left: 0.269em;">=</span><span class="mfrac" id="MathJax-Span-261" style="padding-left: 0.269em;"><span style="display: inline-block; position: relative; width: 4.376em; height: 0px; margin-right: 0.109em; margin-left: 0.109em;"><span style="position: absolute; clip: rect(1.869em 1000em 2.883em -0.477em); top: -3.411em; left: 50%; margin-left: -1.651em;"><span class="mtext" id="MathJax-Span-262" style="font-family: MathJax_Main;">FWHM</span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span><span style="position: absolute; clip: rect(1.709em 1000em 3.203em -0.424em); top: -1.864em; left: 50%; margin-left: -2.131em;"><span class="mrow" id="MathJax-Span-263"><span class="mn" id="MathJax-Span-264" style="font-family: MathJax_Main;">2</span><span class="msqrt" id="MathJax-Span-265"><span style="display: inline-block; position: relative; width: 3.789em; height: 0px;"><span style="position: absolute; clip: rect(1.816em 1000em 3.149em -0.424em); top: -2.717em; left: 1.016em;"><span class="mrow" id="MathJax-Span-266"><span class="mn" id="MathJax-Span-267" style="font-family: MathJax_Main;">2</span><span class="mi" id="MathJax-Span-268" style="font-family: MathJax_Main; padding-left: 0.163em;">ln</span><span class="mo" id="MathJax-Span-269"></span><span class="mo" id="MathJax-Span-270" style="font-family: MathJax_Main;">(</span><span class="mn" id="MathJax-Span-271" style="font-family: MathJax_Main;">2</span><span class="mo" id="MathJax-Span-272" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span><span style="position: absolute; clip: rect(3.576em 1000em 4.056em -0.477em); top: -4.584em; left: 1.016em;"><span style="display: inline-block; position: relative; width: 2.776em; height: 0px;"><span style="position: absolute; font-family: MathJax_Main; top: -3.997em; left: -0.104em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; font-family: MathJax_Main; top: -3.997em; left: 2.083em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 0.429em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 1.016em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.997em; left: 1.549em;">−<span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(2.989em 1000em 4.536em -0.371em); top: -3.997em; left: 0.003em;"><span style="font-family: MathJax_Size1;">√</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span><span style="position: absolute; clip: rect(0.856em 1000em 1.229em -0.477em); top: -1.277em; left: 0.003em;"><span style="border-left: 4.376em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.25px; vertical-align: 0.003em;"></span><span style="display: inline-block; width: 0px; height: 1.069em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 3.27em; vertical-align: -1.53em;"></span></span> 
  </span> 
</div><script type="math/tex; mode=display" id="MathJax-Element-17">\sigma=\frac{\text{FWHM}}{2\sqrt{2\ln(2)}}</script> 
<br> 
<img src="https://images2.imgbox.com/f1/db/4dkUJgjY_o.png" alt="这里写图片描述" title=""> 
<br> 根据匹配滤波器（matched filter）的设计原则，与信号尺度相匹配的滤波器可以为我们提供最大信噪比，所以如果我们知道激活区的确切尺度，就应该以该尺度进行平滑，这样可以保留信号幅度并降低噪声。但通常平滑核的尺寸是在观察激活区之前就根据先验知识确定的，所以我们不大可能使得该尺寸与激活区尺度完全匹配。另外，我们通常采用同样尺寸的平滑核对整个大脑图像进行平滑，但在不同脑区，激活区的尺度不尽相同。为了避免这样的问题，可以采用自适应平滑（adaptive smoothing）的方法，涉及非平稳空间的Gaussian-Markov随机场，实现空间和时间的平滑。 
<p></p> 
<p>注：通常来说，平滑核的选取在不同的实验要求下有不同的标准，增加平滑核尺寸可导致检测到更大范围的激活区域，但会减弱对较小激活区域的检测能力，如下图 4所示。一般选取两倍于体素尺寸的平滑核，即若体素大小为3×3×3，一般选取FWHM=6mm。 <br> <img src="https://images2.imgbox.com/9b/28/VmPB9Yr6_o.png" alt="这里写图片描述" title=""> <br> 图 4 平滑核尺寸对激活检测造成影响的例子</p> 
<p>最后，再来回顾一下fMRI数据预处理的流程（如下图 5所示），扫描得到的结构像和功能像都需要进行预处理。结构像，通常是T1加权，需要与功能像进行配准，并配准至标准空间。功能像，通常是T2*加权，需要进行去噪，扫描层时间校正，以及头动校正。之后，将标准化过程中结构像的配准参数应用于功能像上，使功能像也配准至标准空间（如MNI脑图谱）。最后，功能像进行平滑，就可以开始数据分析了。</p> 
<p>转载申明：</p> 
<p>作者：窦权 <br> 链接：<a href="https://zhuanlan.zhihu.com/p/22385985" rel="nofollow">https://zhuanlan.zhihu.com/p/22385985</a> <br> 来源：知乎 <br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca103da26b1941d530c424be6d165a41/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Eclipse下使用Maven开发Spring Boot应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b3515b3f54338d2c355eecec4942e03f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring集成RabbitMQ</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>