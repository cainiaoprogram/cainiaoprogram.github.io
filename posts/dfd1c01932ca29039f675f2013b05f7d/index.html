<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA中读取配置文件以及修改配置文件 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA中读取配置文件以及修改配置文件" />
<meta property="og:description" content="1.ServletContext方式
采用ServletContext读取配置文件realpath，然后通过文件流读出来。
优点：可以读取任意位置的文件
采用文件流读取，所以可以读取不同格式的文件
缺点：不能在servlet外面读取配置文件
实现：
package com.xunjie.common.utils; import java.io.FileInputStream; import java.io.InputStreamReader; import java.util.Properties; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class Profile { // 采用ServletContext读取配置文件的realpath,然后通过文件流读取出来 public void readProfileByServletContext(HttpServletRequest request, HttpServletResponse response) { // 通过servletcontext读取到文件路径 String realPath = request.getServletContext().getRealPath(&#34;jdbc.properties&#34;); //InputStream 是字节输入流的所有类的超类,一般我们使用它的子类,如FileInputStream InputStreamReader reader; //Properties类,主要用于读取Java的配置文件 Properties props = new Properties(); try { // 建议使用Reader来读，因为reader体系中有个InputStreamReader可以指定编码 reader = new InputStreamReader(new FileInputStream(realPath), &#34;utf-8&#34;); // load ( InputStream inStream)方法 // 从输入流中读取属性列表（键和元素对）。 通过对指定的文件（比如说上面的jdbc.properties文件）进行装载来获取该文件中的所有键 - 值对。 以供 getProperty ( String key) 来搜索。 props." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dfd1c01932ca29039f675f2013b05f7d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-29T16:59:29+08:00" />
<meta property="article:modified_time" content="2018-03-29T16:59:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA中读取配置文件以及修改配置文件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.ServletContext方式</p> 
<p>    采用ServletContext读取配置文件realpath，然后通过文件流读出来。<br></p> 
<p>    优点：可以读取任意位置的文件<br></p> 
<p>               采用文件流读取，所以可以读取不同格式的文件<br></p> 
<p>    缺点：不能在servlet外面读取配置文件<br></p> 
<p>    实现：</p> 
<pre><code class="language-html">package com.xunjie.common.utils;

import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.Properties;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Profile {
	// 采用ServletContext读取配置文件的realpath,然后通过文件流读取出来
	public void readProfileByServletContext(HttpServletRequest request, HttpServletResponse response) {
		// 通过servletcontext读取到文件路径
		String realPath = request.getServletContext().getRealPath("jdbc.properties");
		//InputStream 是字节输入流的所有类的超类,一般我们使用它的子类,如FileInputStream
		InputStreamReader reader;
		//Properties类,主要用于读取Java的配置文件
		Properties props = new Properties();
		try {
			// 建议使用Reader来读，因为reader体系中有个InputStreamReader可以指定编码
			reader = new InputStreamReader(new FileInputStream(realPath), "utf-8");
			// load ( InputStream inStream)方法
			// 从输入流中读取属性列表（键和元素对）。 通过对指定的文件（比如说上面的jdbc.properties文件）进行装载来获取该文件中的所有键 - 值对。 以供 getProperty ( String key) 来搜索。
			props.load(reader);
		} catch (Exception e) {
			e.printStackTrace();
		}
		// getProperty ( String key)方法，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。
		String jdbcUrl = props.getProperty("url");
		System.out.println(jdbcUrl);
		System.out.println(realPath);
	}
}
</code></pre> 
<p>    使用Junit测试输出结果</p> 
<p>    Junit使用参考：https://blog.csdn.net/qq_37725650/article/details/79409589<br></p> 
<pre><code class="language-html">package com.xunjie.test;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.xunjie.common.utils.Profile;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "classpath:spring.xml" })
public class ProfileTest {

	private MockHttpServletRequest request;
	private MockHttpServletResponse response;

	@Before
	public void setUp() {
		request = new MockHttpServletRequest();
		request.setCharacterEncoding("UTF-8");
		response = new MockHttpServletResponse();
	}

	@Test
	public void test() {
		System.err.println("-----测试开始-start-----");
		Profile profile = new Profile();
		profile.readProfileByServletContext(request, response);
		System.err.println("-----测试结束-end-----");
	}
}</code></pre> 
<p>测试结果：</p> 
<pre><code class="language-html">-----测试开始-start-----
jdbc:mysql://127.0.0.1:3306/yeebi?useUnicode=true&amp;&amp;characterEncoding=UTF-8
E:\WorkSpace\xunjie\xunjie\target\classes\jdbc.properties
-----测试结束-end-----</code></pre> 
<p>2.通过ResourceBundle类获取配置文件资源</p> 
<p>    优点：1可以以全限定类名的方式加载资源2可以在非web应用里加载资源<br></p> 
<p>    缺点：只能加载类下面的资源文件，且只能读取properties文件<br></p> 
<pre><code class="language-html">	/**
	 * @Title: getProfileByResourceBundle
	 * @Description: 通过ResourceBundle类获取配置文件资源
	 * @param propertyName 配置文件名称
	 * 调用方式：  
     * 1.配置文件放在resource源包下，不用加后缀  
     *  PropertiesUtil.getProfileByResourceBundle("message");  
     * 2.放在包里面的  
     *  PropertiesUtil.getProfileByResourceBundle("com.test.message");
	 * @return Map&lt;String,String&gt; 以Map键值对方式返回配置文件内容
	 */
	public static Map&lt;String, String&gt; getProfileByResourceBundle(String propertyName) {
		// 获得资源包
		ResourceBundle rb = ResourceBundle.getBundle(propertyName.trim());
		// 通过资源包拿到所有的key
		Enumeration&lt;String&gt; allKey = rb.getKeys();
		Map&lt;String, String&gt; profileMap = new HashMap&lt;String, String&gt;();
		// 遍历key 得到 value
		while (allKey.hasMoreElements()) {
			String key = allKey.nextElement();
			String value = (String) rb.getString(key);
			//将文件内容存入map
			profileMap.put(key, value);
		}
		return profileMap;
	}</code></pre> 
<p>    测试运行结果：</p> 
<pre><code class="language-html">	public static void main(String[] args) {
		//我的文件直接放在了src下,所以直接传入文件名称就可以了
		Map&lt;String, String&gt; profileMap = Profile.getProfileByResourceBundle("jdbc");
		String jdbcUrl = profileMap.get("url");
		System.out.println(jdbcUrl);
	}</code></pre> 
<pre><code class="language-html">控制台输出：
jdbc:mysql://127.0.0.1:3306/yeebi?useUnicode=true&amp;&amp;characterEncoding=UTF-8</code></pre>3.通过ClassLoader方式进行读取 
<pre><code class="language-html">/**
	 * @Title: getProfileByClassLoader
	 * @Description: 采用ClassLoader(类加载器)方式进行读取配置信息
	 * @return Map&lt;String,Object&gt; 以Map键值对方式返回配置文件内容
	 * 优点：可以在非Web应用中读取配置资源信息，可以读取任意的资源文件信息  
	 * 缺点：只能加载类classes下面的资源文件
	 * @throws
	 */
	public static Map&lt;String, Object&gt; getProfileByClassLoader() {
		// 通过ClassLoader获取到文件输入流对象
		// 配置文件放在resource源包下,直接写文件名即可,需要后缀名"jdbc.properties"
		// 放在包里面的,需要写上包路径,例如：在test包下"com/test/jdbc.properties"),Profile为当前所在类类名
		InputStream in = Profile.class.getClassLoader().getResourceAsStream("jdbc.properties");
		// 获取文件的位置
		String filePath = Profile.class.getClassLoader().getResource("jdbc.properties").getFile();
		System.out.println(filePath);
		BufferedReader reader = new BufferedReader(new InputStreamReader(in));
		Properties props = new Properties();
		Map&lt;String, Object&gt; profileMap = new HashMap&lt;String, Object&gt;();
		try {
			props.load(reader);
			for (Object key : props.keySet()) {
				profileMap.put(key.toString(), props.getProperty(key.toString()));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		return profileMap;
	}</code></pre> 
<p>测试运行结果：</p> 
<pre><code class="language-html">public static void main(String[] args) {
		Map&lt;String, Object&gt; profileMap = Profile.getProfileByClassLoader();
		System.out.println(profileMap.get("url"));
	}
控制台输出：
/E:/WorkSpace/xunjie/xunjie/target/classes/jdbc.properties
jdbc:mysql://127.0.0.1:3306/yeebi?useUnicode=true&amp;&amp;characterEncoding=UTF-8</code></pre> 
<p>4.使用Sping提供的PropertiesLoaderUtils类读取配置文件</p> 
<p>    当然需要导入spring核心包<br></p> 
<pre><code class="language-html">/**
	 * @Title: getProfileByPropertiesLoaderUtils
	 * @Description: Spring 提供的 PropertiesLoaderUtils 允许您直接通过基于类路径的文件地址加载属性资源
	 * 最大的好处就是：实时加载配置文件，修改后立即生效，不必重启 
	 * @return Map&lt;String,Object&gt;
	 */
	public static Map&lt;String, Object&gt; getProfileByPropertiesLoaderUtils() {
		Properties props = new Properties();
		Map&lt;String, Object&gt; profileMap = new HashMap&lt;String, Object&gt;();
		try {
			props = PropertiesLoaderUtils.loadAllProperties("jdbc.properties");
			for (Object key : props.keySet()) {
				profileMap.put(key.toString(), props.getProperty(key.toString()));
			}
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
		return profileMap;
	}  </code></pre> 
<p>   测试运行结果：<br></p> 
<pre><code class="language-html">	public static void main(String[] args) {
		Map&lt;String, Object&gt; profileMap = Profile.getProfileByPropertiesLoaderUtils();
		System.out.println(profileMap.get("url"));
	}
控制台输出：
jdbc:mysql://127.0.0.1:3306/yeebi?useUnicode=true&amp;&amp;characterEncoding=UTF-8
</code></pre> 
<p>5.修改配置文件</p> 
<p>只是修改了classes下的文件，源文件并没有改变。</p> 
<pre><code class="language-html">	/**  
	 * 传递键值对的Map，更新properties文件  
	 *   
	 * @param fileName  
	 *            文件名(放在resource源包目录下)，需要后缀  
	 * @param keyValueMap  
	 *            键值对Map  
	 */
	public static void updateProperties(String fileName, Map&lt;String, String&gt; keyValueMap) {
		// 输入流
		// InputStream
		// inputStream=PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName);
		// 获取文件的路径
		String filePath = Profile.class.getClassLoader().getResource(fileName).getFile();
		System.out.println("propertiesPath:" + filePath);
		Properties props = new Properties();
		BufferedReader br = null;
		BufferedWriter bw = null;
		try {
			// 从输入流中读取属性列表（键和元素对）
			br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath)));
			props.load(br);
			br.close();
			// 写入属性文件
			bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath)));
			// 清空旧的文件
			// props.clear();
			for (String key : keyValueMap.keySet())
				props.setProperty(key, keyValueMap.get(key));
			props.store(bw, "改变数据");
			System.out.println(props.getProperty("url"));
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
			System.err.println("Visit " + filePath + " for updating " + "" + " value error");
		} finally {
			try {
				br.close();
				bw.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}</code></pre> 
<p>修改前：</p> 
<p><img src="https://images2.imgbox.com/9a/a7/ilvYEhTw_o.png" alt=""><br></p> 
<p>运行测试结果即修改后：</p> 
<pre><code class="language-html">	public static void main(String[] args) {
		Profile.updateProperties("jdbc.properties", new HashMap&lt;String, String&gt;() {
			{
				put("initialSize", "6");
				put("test", "修改文件属性");
			}
		});
	}</code></pre> 
<p><img src="https://images2.imgbox.com/8a/6a/McrMq8aq_o.png" alt=""></p> 
<p><br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4181ac9173eeeebf24010b790544d057/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mybatis和spring简单整合(dao/mapper)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3265f3b046f6a71f956ea74db642d88e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python读取图片并修改格式与大小</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>