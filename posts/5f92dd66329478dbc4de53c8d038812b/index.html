<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java String 最长长度和占用内存大小 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java String 最长长度和占用内存大小" />
<meta property="og:description" content="一 序 String在内存中的最大长度理论上是int型变量的最大值，Integer.MAX_VALUE,
String的字面常量的最大长度为CONSTANT_Utf8_info表决定，一般为65535.
二 介绍 1、String的内部实现
通过一个字符数组来维护字符序列，其声名如下：
private final char value[];
2
所以，String的最大长度取决于字符数组的最大长度，因为字符数组长度只能是byte,char,short,int而不能是long型，所以这也说明最大长度，另一方面，我们知道String类有一个方法，str.length() 它的返回值是int型变量，声明如下：
public int length()
3
所以这也说明了最大长度的理论值，但在实际中，要比理论值小，
public class mainClass { public static void main(String[] args) {
// TODO Auto-generated method stub
char[] value=new char[Integer.MAX_VALUE]; System.out.println(&#34;&#34;);
}
}
这个错误是内存溢出错误，所以系统无法分配这么大的内存空间。
现在的问题是，计算机系统可以分配多大的内存呢？
三 分析源码 java.lang.String.java
public final class String
implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
/** The value is used for character storage. */
private final char value[];
java String类以char[]数组存储字符元素，因而，String类的最大长度实际上取决于char[]数组能够包含的数组长度。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5f92dd66329478dbc4de53c8d038812b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-15T17:11:02+08:00" />
<meta property="article:modified_time" content="2022-08-15T17:11:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java String 最长长度和占用内存大小</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一 序</h2> 
<p><br> String在内存中的最大长度理论上是int型变量的最大值，Integer.MAX_VALUE,<br> String的字面常量的最大长度为CONSTANT_Utf8_info表决定，一般为65535.</p> 
<h2>二 介绍</h2> 
<p><br> 1、String的内部实现<br> 通过一个字符数组来维护字符序列，其声名如下：</p> 
<p>private final char value[];<br> 2<br> 所以，String的最大长度取决于字符数组的最大长度，因为字符数组长度只能是byte,char,short,int而不能是long型，所以这也说明最大长度，另一方面，我们知道String类有一个方法，str.length() 它的返回值是int型变量，声明如下：</p> 
<p>public int length()<br> 3<br> 所以这也说明了最大长度的理论值，但在实际中，要比理论值小，</p> 
<p>public class mainClass {    public static void main(String[] args) {<!-- --><br>         // TODO Auto-generated method stub<br>         char[] value=new char[Integer.MAX_VALUE];   <br>         System.out.println("");<br>     }</p> 
<p>}<br><img alt="" class="has" src="https://images2.imgbox.com/28/ec/Mpls3wXl_o.png"></p> 
<p>这个错误是内存溢出错误，所以系统无法分配这么大的内存空间。<br> 现在的问题是，计算机系统可以分配多大的内存呢？<br>  </p> 
<h2>三 分析源码</h2> 
<p></p> 
<p>java.lang.String.java</p> 
<p>public final class String<br>     implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {<!-- --><br>     /** The value is used for character storage. */<br>     private final char value[];<br> java String类以char[]数组存储字符元素，因而，String类的最大长度实际上取决于char[]数组能够包含的数组长度。<br> 我们可以简单做下试验，看看char[]数组的最大长度MAX_LENGTH是多少。<br> 当我们将len值调到320339961的时候，系统刚刚好报错，</p> 
<p><br> 因此，char[]数组的最大长度可以达到 320339960，约为2^28.255，每个字符占用空间2个字节，也就是2^28.255字节，而4个G等于2^30字节。</p> 
<p>因而char[]数组的最大长度约等于（不到）4个G。</p> 
<p>String类型的长度为320339960，其最大容量不超过4个G。</p> 
<p></p> 
<p></p> 
<p>String内部是以char数组的形式存储，数组的长度是int类型，那么String允许的最大长度就是Integer.MAX_VALUE了。又由于java中的字符是以16位存储的，因此大概需要4GB的内存才能存储最大长度的字符串。不过这仅仅是对字符串变量而言，如果是字符串字面量(string literals)，如“abc"、"1a2b"之类写在代码中的字符串literals，那么允许的最大长度取决于字符串在常量池中的存储大小，也就是字符串在class格式文件中的存储格式：</p> 
<p>CONSTANT_Utf8_info {<!-- --><br>         u1 tag;<br>         u2 length;<br>         u1 bytes[length];<br> }</p> 
<p><br>     u2是无符号的16位整数，因此理论上允许的string literal的最大长度是2^16-1=65535。然而实际测试表明，允许的最大长度仅为65534</p> 
<h2>四 不同运行阶段分析</h2> 
<p></p> 
<h4>编译期</h4> 
<p>首先，我们先来合理的推断一下，当我们在代码中使用String s = “”;的形式来定义String对象的时候，""中字符的个数有没有限制呢？<br> 既然是合理的推断，那就要要足够的依据，所以我们可以从String的源码入手，根据public String(char value[], int offset, int count)的定义，count是int类型的，所以，char value[]中最多可以保存Integer.MAX_VALUE个,即2147483647字符。(jdk1.8.0_73)<br> 但是，实验证明，String s = “”;中，最多可以有65534个字符。如果超过这个个数。就会在编译期报错。</p> 
<pre class="has"><code>public static void main(String[] args) {

    String s = "a...a";// 共65534个a
    System.out.println(s.length());

    String s1 = "a...a";// 共65535个a
    System.out.println(s1.length());
}
</code></pre> 
<p></p> 
<p>以上代码，会在String s1 = “a…a”;// 共65535个a处编译失败：</p> 
<pre class="has"><code>✗ javac StringLenghDemo.java
StringLenghDemo.java:11: 错误: 常量字符串过长
</code></pre> 
<p></p> 
<h4><a name="t1"></a><a id="214748364765535_31"></a>明明说好的长度限制是2147483647，为什么65535个字符就无法编译了呢？</h4> 
<p>当我们使用字符串字面量直接定义String的时候，是会把字符串在常量池中存储一份的。那么上面提到的65534其实是常量池的限制。<br> 常量池中的每一种数据项也有自己的类型。Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示。<br> CONSTANTUtf8info是一个CONSTANTUtf8类型的常量池数据项，它存储的是一个常量字符串。常量池中的所有字面量几乎都是通过CONSTANTUtf8info描述的。CONSTANTUtf8_info的定义如下：</p> 
<pre class="has"><code>CONSTANT_Utf8_info {
    u1 tag;
    u2 length;
    u1 bytes[length];
}
</code></pre> 
<p></p> 
<p>由于本文的重点并不是CONSTANTUtf8info的介绍，这里就不详细展开了，我们只需要我们使用字面量定义的字符串在class文件中，是使用CONSTANTUtf8info存储的，而CONSTANTUtf8info中有u2 length;表明了该类型存储数据的长度。<br> u2是无符号的16位整数，因此理论上允许的的最大长度是2^16=65536。而 java class 文件是使用一种变体UTF-8格式来存放字符的，null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。<br> 关于这一点，在the class file format spec中也有明确说明：</p> 
<blockquote> 
 <p>The length of field and method names, field and method descriptors, and other constant string values is limited to 65535 characters by the 16-bit unsigned length item of the CONSTANTUtf8info structure (§4.4.7). Note that the limit is on the number of bytes in the encoding and not on the number of encoded characters. UTF-8 encodes some characters using two or three bytes. Thus, strings incorporating multibyte characters are further constrained.</p> 
</blockquote> 
<h4><a name="t2"></a><a id="Java65535_51"></a>也就是说，在Java中，所有需要保存在常量池中的数据，长度最大不能超过65535，这当然也包括字符串的定义。</h4> 
<h4><a name="t3"></a><a id="_53"></a>运行期</h4> 
<p>上面提到的这种String长度的限制是编译期的限制，也就是使用String s= “”;这种字面值方式定义的时候才会有的限制。<br> 那么。String在运行期有没有限制呢，答案是有的，就是我们前文提到的那个Integer.MAX_VALUE ，这个值约等于4G，在运行期，如果String的长度超过这个范围，就可能会抛出异常。(在jdk 1.9之前）<br> int 是一个 32 位变量类型，取正数部分来算的话，他们最长可以有</p> 
<pre class="has"><code>2^31-1 =2147483647 个 16-bit Unicodecharacter

2147483647 * 16 = 34359738352 位
34359738352 / 8 = 4294967294 (Byte)
4294967294 / 1024 = 4194303.998046875 (KB)
4194303.998046875 / 1024 = 4095.9999980926513671875 (MB)
4095.9999980926513671875 / 1024 = 3.99999999813735485076904296875 (GB)
</code></pre> 
<h2>五 占用内存大小 </h2> 
<h4>1、先介绍一下String对象的内存占用</h4> 
<p>一般而言，Java 对象在虚拟机的结构如下：<br> •对象头（object header）：8 个字节（保存对象的 class 信息、ID、在虚拟机中的状态）<br> •Java 原始类型数据：如 int, float, char 等类型的数据<br> •引用（reference）：4 个字节<br> •填充符（padding）</p> 
<p>String定义：</p> 
<p>JDK6:<br> private final char value[];<br> private final int offset;<br> private final int count;<br> private int hash;</p> 
<p>JDK6的空字符串所占的空间为40字节</p> 
<p>JDK7:<br> private final char value[];<br> private int hash;<br> private transient int hash32;</p> 
<p>JDK7的空字符串所占的空间也是40字节</p> 
<p>JDK6字符串内存占用的计算方式：<br> 首先计算一个空的 char 数组所占空间，在 Java 里数组也是对象，因而数组也有对象头，故一个数组所占的空间为对象头所占的空间加上数组长度，即 8 + 4 = 12 字节 , 经过填充后为 16 字节。</p> 
<p>那么一个空 String 所占空间为：</p> 
<p>对象头（8 字节）+ char 数组（16 字节）+ 3 个 int（3 × 4 = 12 字节）+1 个 char 数组的引用 (4 字节 ) = 40 字节。</p> 
<p>因此一个实际的 String 所占空间的计算公式如下：</p> 
<p>8*( ( 8+12+2*n+4+12)+7 ) / 8 = 8*(int) ( ( ( (n) *2 )+43) /8 )</p> 
<p>其中，n 为字符串长度。</p> 
<h4><strong>2、举个例子：</strong></h4> 
<p><strong>A，substringA</strong></p> 
<p>package demo;</p> 
<p>import java.io.BufferedReader;</p> 
<p>import java.io.File;</p> 
<p>import java.io.FileInputStream;</p> 
<p>import java.io.InputStreamReader;</p> 
<p>public class TestBigString</p> 
<p>{<!-- --></p> 
<p>    private String strsub;</p> 
<p>    private String strempty = new String();</p> 
<p>    public static void main(String[] args) throws Exception</p> 
<p>    {<!-- --></p> 
<p>        TestBigString obj = new TestBigString();</p> 
<p>        obj.strsub = obj.readString().substring(0,1);</p> 
<p>        Thread.<em>sleep</em>(30*60*1000);</p> 
<p>    }</p> 
<p>    private String readString() throws Exception</p> 
<p>    {<!-- --></p> 
<p>        BufferedReader bis = null;</p> 
<p>        try</p> 
<p>        {<!-- --></p> 
<p>            bis = new BufferedReader(new InputStreamReader(new FileInputStream(new File("d:\\teststring.txt"))));</p> 
<p>            StringBuilder sb = new StringBuilder();</p> 
<p>            String line = null;</p> 
<p>            while((line = bis.readLine()) != null)</p> 
<p>            {<!-- --></p> 
<p>                sb.append(line);</p> 
<p>            }</p> 
<p>            System.<em>out</em>.println(sb.length());</p> 
<p>            return sb.toString();</p> 
<p>        }</p> 
<p>        finally</p> 
<p>        {<!-- --></p> 
<p>            if (bis != null)</p> 
<p>            {<!-- --></p> 
<p>                bis.close();</p> 
<p>            }</p> 
<p>        }</p> 
<p>    }</p> 
<p>}</p> 
<p>其中文件"d:\\teststring.txt"里面有33475740个字符，文件大小有35M。</p> 
<p>用JDK6来运行上面的代码，可以看到strsub只是substring(0,1)只取一个，count确实只有1，但其占用的内存却高达接近67M。</p> 
<p></p> 
<p>然而用JDK7运行同样的上面的代码，strsub对象却只有40字节</p> 
<p></p> 
<p><strong>B，什么原因呢？</strong></p> 
<p>来看下JDK的源码：</p> 
<p>JDK6：</p> 
<p>public String substring(int beginIndex, int endIndex) {<!-- --></p> 
<p>    if (beginIndex &lt; 0) {<!-- --></p> 
<p>        throw new StringIndexOutOfBoundsException(beginIndex);</p> 
<p>    }</p> 
<p>    if (endIndex &gt; count) {<!-- --></p> 
<p>        throw new StringIndexOutOfBoundsException(endIndex);</p> 
<p>    }</p> 
<p>    if (beginIndex &gt; endIndex) {<!-- --></p> 
<p>        throw new StringIndexOutOfBoundsException(endIndex - beginIndex);</p> 
<p>    }</p> 
<p>    return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this :</p> 
<p>        new String(offset + beginIndex, endIndex - beginIndex, value);</p> 
<p>}</p> 
<p>// Package private constructor which shares value array for speed.</p> 
<p>    String(int offset, int count, char value[]) {<!-- --></p> 
<p>    this.value = value;</p> 
<p>    this.offset = offset;</p> 
<p>    this.count = count;</p> 
<p>}</p> 
<p>JDK7:</p> 
<p>public String substring(int beginIndex, int endIndex) {<!-- --></p> 
<p>        if (beginIndex &lt; 0) {<!-- --></p> 
<p>            throw new StringIndexOutOfBoundsException(beginIndex);</p> 
<p>        }</p> 
<p>        if (endIndex &gt; value.length) {<!-- --></p> 
<p>            throw new StringIndexOutOfBoundsException(endIndex);</p> 
<p>        }</p> 
<p>        int subLen = endIndex - beginIndex;</p> 
<p>        if (subLen &lt; 0) {<!-- --></p> 
<p>            throw new StringIndexOutOfBoundsException(subLen);</p> 
<p>        }</p> 
<p>        return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this</p> 
<p>                : new String(value, beginIndex, subLen);</p> 
<p>}</p> 
<p>public String(char value[], int offset, int count) {<!-- --></p> 
<p>        if (offset &lt; 0) {<!-- --></p> 
<p>            throw new StringIndexOutOfBoundsException(offset);</p> 
<p>        }</p> 
<p>        if (count &lt; 0) {<!-- --></p> 
<p>            throw new StringIndexOutOfBoundsException(count);</p> 
<p>        }</p> 
<p>        // Note: offset or count might be near -1&gt;&gt;&gt;1.</p> 
<p>        if (offset &gt; value.length - count) {<!-- --></p> 
<p>            throw new StringIndexOutOfBoundsException(offset + count);</p> 
<p>        }</p> 
<p>        this.value = Arrays.<em>copyOfRange</em>(value, offset, offset+count);</p> 
<p>    }</p> 
<p>可以看到原来是因为JDK6的String.substring()所返回的 String 仍然会保存原始 String的引用，所以原始String无法被释放掉，因而导致了出乎意料的大量的内存消耗。</p> 
<p>JDK6这样设计的目的其实也是为了节约内存，因为这些 String 都复用了原始 String，只是通过 int 类型的 offerset, count 等值来标识substring后的新String。</p> 
<p>然而对于上面的例子，从一个巨大的 String 截取少数 String 为以后所用，这样的设计则造成大量冗余数据。 因此有关通过 String.split()或 String.substring()截取 String 的操作的结论如下：</p> 
<p>•对于从大文本中截取少量字符串的应用，String.substring()将会导致内存的过度浪费。<br> •对于从一般文本中截取一定数量的字符串，截取的字符串长度总和与原始文本长度相差不大，现有的 String.substring()设计恰好可以共享原始文本从而达到节省内存的目的。</p> 
<p>既然导致大量内存占用的根源是 String.substring()返回结果中包含大量原始 String，那么一个减少内存浪费的的途径就是去除这些原始 String。如再次调用 newString构造一个的仅包含截取出的字符串的 String，可调用 String.toCharArray()方法：</p> 
<p>String newString = new String(smallString.toCharArray());</p> 
<h4><strong>C</strong><strong>、同样，再看看</strong><strong>split</strong><strong>方法</strong></h4> 
<p>public class TestBigString</p> 
<p>{<!-- --></p> 
<p>    private String strsub;</p> 
<p>    private String strempty = new String();</p> 
<p>    private String[] strSplit;</p> 
<p>    public static void main(String[] args) throws Exception</p> 
<p>    {<!-- --></p> 
<p>        TestBigString obj = new TestBigString();</p> 
<p>        obj.strsub = obj.readString().substring(0,1);</p> 
<p>        obj.strSplit = obj.readString().split("Address:",5);</p> 
<p>        Thread.<em>sleep</em>(30*60*1000);</p> 
<p>    }</p> 
<p>JDK6中分割的字符串数组中，每个String元素占用的内存都是原始字符串的内存大小(67M):</p> 
<p></p> 
<p>而JDK7中分割的字符串数组中，每个String元素都是实际的内存大小:</p> 
<p></p> 
<p><strong>D，原因：</strong></p> 
<p>JDK6源代码：</p> 
<p>public String[] split(String regex, int limit) {<!-- --></p> 
<p>    return Pattern.<em>compile</em>(regex).split(this, limit);</p> 
<p>    }</p> 
<p>public String[] split(CharSequence input, int limit) {<!-- --></p> 
<p>        int index = 0;</p> 
<p>        boolean matchLimited = limit &gt; 0;</p> 
<p>        ArrayList&lt;String&gt; matchList = new ArrayList&lt;String&gt;();</p> 
<p>        Matcher m = matcher(input);</p> 
<p>        // Add segments before each match found</p> 
<p>        while(m.find()) {<!-- --></p> 
<p>            if (!matchLimited || matchList.size() &lt; limit - 1) {<!-- --></p> 
<p>                String match = input.subSequence(index, m.start()).toString();</p> 
<p>                matchList.add(match);</p> 
<p>public CharSequence subSequence(int beginIndex, int endIndex) {<!-- --></p> 
<p>        return this.substring(beginIndex, endIndex);</p> 
<p>    }</p> 
<h4><strong>4、其他方面：</strong></h4> 
<pre><code class="language-html">1、String a1 = “Hello”; //常量字符串，JVM默认都已经intern到常量池了。
创建字符串时 JVM 会查看内部的缓存池是否已有相同的字符串存在：如果有，则不再使用构造函数构造一个新的字符串，
直接返回已有的字符串实例；若不存在，则分配新的内存给新创建的字符串。
String a2 = new String(“Hello”); //每次都创建全新的字符串</code></pre> 
<p>2、在拼接静态字符串时，尽量用 +，因为通常编译器会对此做优化。</p> 
<p><strong>public</strong> String constractStr()</p> 
<p>    {<!-- --></p> 
<p>        <strong>return</strong> "str1" + "str2" + "str3";</p> 
<p>}</p> 
<p>对应的字节码：</p> 
<p>Code:</p> 
<p>0:   ldc     #24; //String str1str2str3         --将字符串常量压入栈顶</p> 
<p>2:   areturn</p> 
<p>3、在拼接动态字符串时，尽量用 StringBuffer 或 StringBuilder的 append，这样可以减少构造过多的临时 String 对象（javac编译器会对String连接做自动优化）：</p> 
<p><strong>public</strong> String constractStr(String str1, String str2, String str3)</p> 
<p>    {<!-- --></p> 
<p>        <strong>return</strong> str1 + str2 + str3;</p> 
<p>}</p> 
<p>对应字节码（JDK1.5之后转换为调用StringBuilder.append方法）：</p> 
<p>Code:</p> 
<p>0:   new     #24; //class java/lang/StringBuilder</p> 
<p>3:   dup</p> 
<p>4:   aload_1</p> 
<p>5:   invokestatic    #26; //Method java/lang/String.valueOf:(Ljava/lang/Objec</p> 
<p>t;)Ljava/lang/String;</p> 
<p>8:   invokespecial   #32; //Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/la</p> 
<p>ng/String;)V</p> 
<p>11:  aload_2</p> 
<p>12:  invokevirtual   #35; //Method java/lang/StringBuilder.append:(Ljava/lang</p> 
<p>/String;)Ljava/lang/StringBuilder;</p> 
<p>15:  aload_3</p> 
<p>16:  invokevirtual   #35; //Method java/lang/StringBuilder.append:(Ljava/lang</p> 
<p>/String;)Ljava/lang/StringBuilder;  ――调用StringBuilder的append方法</p> 
<p>19:  invokevirtual   #39; //Method java/lang/StringBuilder.toString:()Ljava/l</p> 
<p>ang/String;</p> 
<p>22:  areturn     ――返回引用</p> 
<p></p> 
<p>备注 </p> 
<p>自动装箱拆箱</p> 
<p><a href="https://www.cnblogs.com/wang-yaz/p/8516151.html" rel="nofollow" title="详解Java的自动装箱与拆箱(Autoboxing and unboxing) - 低调的小白 - 博客园">详解Java的自动装箱与拆箱(Autoboxing and unboxing) - 低调的小白 - 博客园</a></p> 
<p><a href="https://blog.csdn.net/wolfking0608/article/details/78583944" title="Java中String接受的最大字符串的长度是多少_一往无前-千夜的博客-CSDN博客_java string长度是多少个字节">Java中String接受的最大字符串的长度是多少_一往无前-千夜的博客-CSDN博客_java string长度是多少个字节</a></p> 
<p><a href="https://www.iteye.com/blog/lin-yp-1683679" title="https://www.iteye.com/blog/lin-yp-168367">https://www.iteye.com/blog/lin-yp-168367</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4242ada434a025dcf1bbf6adec5fa9ca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用 virtualBox 安装 ubuntu</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/662abc89006bbd10adceb69e99e1bf89/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于解构赋值的修改</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>