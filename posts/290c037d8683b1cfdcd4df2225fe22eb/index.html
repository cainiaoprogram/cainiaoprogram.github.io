<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VC/MFC学习笔记 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VC/MFC学习笔记" />
<meta property="og:description" content="windows中的很多数据类型，如HWND，WParam等其实都是我们所熟悉的unsigned int等一些类型，而定义成新的形式是为了方便记忆，不要因为这个而被难住！
消息队列：把消息放在队列中，应用程序每次都只取走消息队列中的第一条消息。 HINSTANCE：窗口的实例，一个程序可以有多个实例。 调用每一个消息用函数GetMessage().
创建一个完整的窗口需要经过下面四个操作步骤： 设计一个窗口类； 注册窗口类； 创建窗口； 显示及更新窗口。
wndcls.style=CS_HREDRAW | CS_VREDRAW;CS_HREDRAW与CS_VREDRAW对应的二进制数中只有一位为1，其他都为0，因此，想要wndcls.style同时具有CS_HREDRAW 与CS_VREDRAW的特征，就可利用二进制的或运算来进行。
DC是device context,叫做设备描述表:与设备驱动程序有关,比如显卡,用DC去与设备驱动程序打交道.
BeginPaint与EndPaint是一对;
GetDC和ReleaseDC是一对.
MSDN:windows GDI/user interface platform SDK去查找
UNIT message 都是以WM_ 开头的
在MFC中看不到WinMain函数是因为它被隐藏在应用程序框架内部了。
一般的全局对象theApp是CWinApp的对象，它代表了一个应用程序。
应用程序的启动：在C&#43;&#43;中，全局对象在主程序被运行之前就已经被构造好了。
CWinApp::InitInstance成员函数会进一步调用相应的函数来完成主窗口的构造和显示工作，我们必须在派生出的应用程序类中重载它，因为CWinApp基类根本无法知道具体需要什么样的窗口。
CWinApp::Run函数被隐藏在基类中，WinMain在调用InitInstance之后将紧接着调用它。
视图实际上是一个从MFC库中的CView类所派生出的类的对象。
项目文件（.DSP）不但指定了所有文件之间的依赖关系，而且还定义了便宜和连接选项。
在MFC库中，设备环境是由C&#43;&#43;的CDC类对象来表示的，该对象被作为参数（以指针的形式）传递给其他函数，比如OnDraw函数，就可以调用CDC的许多成员函数来完成各种各样的绘制工作。
消息映射：
如果程序需要对WM_LBUTTONDOWN消息有所反应的话，在视图类中就必须包含和下面给出的函数想类似的成员函数：
void CMyView::OnLButtonDown(UINT nFlags, CPoint point)
{
// event processing code here
}
在类头文件中也必须包含相应的函数原型说明：
afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
记号afx_msg并没有什么其他的用途，它只是用来表明该原型说明是针对消息映射函数而言的。
下一步，在代码文件中还需要有一个消息映射宏，该消息映射宏用于将OnLButtonDown函数和应用程序框架联系在一起：
BEGIN_MESSAGE_MAP(CEx04aView, CView)
//{{AFX_MSG_MAP(CEx04aView)
ON_WM_LBUTTONDOWN()
END_MESSAGE_MAP()
最后，在类库头文件中还需要包含如下语句：
DECLARE_MESSAGE_MAP()
如何使用ClassWizard：P49
浏览应用程序：自己设置：Project-Settings-C/C&#43;&#43;选中Generate Browse Info,在Browse Info上选中Build Browse Info File" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/290c037d8683b1cfdcd4df2225fe22eb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2009-04-22T16:24:00+08:00" />
<meta property="article:modified_time" content="2009-04-22T16:24:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VC/MFC学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> windows中的很多数据类型，如HWND，WParam等其实都是我们所熟悉的unsigned int等一些类型，而定义成新的形式是为了方便记忆，不要因为这个而被难住！</p> 
<p>消息队列：把消息放在队列中，应用程序每次都只取走消息队列中的第一条消息。 HINSTANCE：窗口的实例，一个程序可以有多个实例。 调用每一个消息用函数GetMessage().</p> 
<p>创建一个完整的窗口需要经过下面四个操作步骤： 设计一个窗口类； 注册窗口类； 创建窗口； 显示及更新窗口。</p> 
<p>wndcls.style=CS_HREDRAW | CS_VREDRAW;CS_HREDRAW与CS_VREDRAW对应的二进制数中只有一位为1，其他都为0，因此，想要wndcls.style同时具有CS_HREDRAW 与CS_VREDRAW的特征，就可利用二进制的或运算来进行。</p> 
<p>DC是device context,叫做设备描述表:与设备驱动程序有关,比如显卡,用DC去与设备驱动程序打交道.</p> 
<p>BeginPaint与EndPaint是一对;</p> 
<p>GetDC和ReleaseDC是一对.</p> 
<p> </p> 
<p>MSDN:windows GDI/user interface platform SDK去查找</p> 
<p>UNIT message 都是以WM_ 开头的</p> 
<p>在MFC中看不到WinMain函数是因为它被隐藏在应用程序框架内部了。<br>一般的全局对象theApp是CWinApp的对象，它代表了一个应用程序。<br>应用程序的启动：在C++中，全局对象在主程序被运行之前就已经被构造好了。<br>CWinApp::InitInstance成员函数会进一步调用相应的函数来完成主窗口的构造和显示工作，我们必须在派生出的应用程序类中重载它，因为CWinApp基类根本无法知道具体需要什么样的窗口。<br>CWinApp::Run函数被隐藏在基类中，WinMain在调用InitInstance之后将紧接着调用它。</p> 
<p> </p> 
<p>视图实际上是一个从MFC库中的CView类所派生出的类的对象。<br>项目文件（.DSP）不但指定了所有文件之间的依赖关系，而且还定义了便宜和连接选项。</p> 
<p>在MFC库中，设备环境是由C++的CDC类对象来表示的，该对象被作为参数（以指针的形式）传递给其他函数，比如OnDraw函数，就可以调用CDC的许多成员函数来完成各种各样的绘制工作。</p> 
<p><span style="color: #ff0000;">消息映射</span>：<br>如果程序需要对WM_LBUTTONDOWN消息有所反应的话，在视图类中就必须包含和下面给出的函数想类似的成员函数：<br>void CMyView::OnLButtonDown(UINT nFlags, CPoint point)<br>{<!-- --><br> // event processing code here<br>}<br>在类头文件中也必须包含相应的函数原型说明：<br>afx_msg void OnLButtonDown(UINT nFlags, CPoint point);<br>记号afx_msg并没有什么其他的用途，它只是用来表明该原型说明是针对消息映射函数而言的。<br>下一步，在代码文件中还需要有一个消息映射宏，该消息映射宏用于将OnLButtonDown函数和应用程序框架联系在一起：<br>BEGIN_MESSAGE_MAP(CEx04aView, CView)<br> //{<!-- -->{AFX_MSG_MAP(CEx04aView)<br> ON_WM_LBUTTONDOWN()<br>END_MESSAGE_MAP()<br>最后，在类库头文件中还需要包含如下语句：<br>DECLARE_MESSAGE_MAP()</p> 
<p> </p> 
<p><span style="color: #ff0000;">如何使用ClassWizard</span>：P49</p> 
<p> </p> 
<p><span style="color: #ff0000;">浏览应用程序</span>：自己设置：Project-Settings-C/C++选中Generate Browse Info,在Browse Info上选中Build Browse Info File</p> 
<p>在MM_TEXT映射模式下，坐标被影射到了象素，x值向右方递增，y值向下递增，但可以通过调用CDC的SetViewprotOrg和SetWindowOrg函数来改变坐标原点的位置。</p> 
<p><br>类CDC是设备环境类的基类，它的两个派生类：CClientDC和CWindowDC，前者的区域是不包括窗口边框和标题栏等，而后者就包括。<br>构造设备环境类很重要的一点就是要在合适的时候将它删掉，方法主要有两种：<br>一种是在堆栈中构造对象，也就是在局部函数中构造，这个函数调用完就自动释放了；<br>另外一种是通过GetDC RealeaseDC成对的创建和释放DC。</p> 
<p>P92教<span style="color: #ff0000;">如何做对话框</span><br>对齐控件方法在P97</p> 
<p> </p> 
<p>在对话框编辑栏中,如果一个按钮对这些数据进行操作,在这个操作对应的函数中,要包含如下代码:</p> 
<p><textarea name="code" class="cpp">	UpdateData(TRUE);//接受用户输入
	//operation
	UpdateData(FALSE);//将结果显示在对话框编辑栏中</textarea></p> 
<p> </p> 
<p>关于DLL的使用</p> 
<p>MFCDLL分为扩展的和正规的,扩展的可以导出类,正规的不可以,理解上,如果我们想将该DLL用于C++,就用扩展的,否则就用正规的,<span style="color: #ff0000;">一般我们都是用MFC扩展的DLL</span></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1909f27ea60d87ec3c919659f381f5b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DButils的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2a6bf6190c6d7500d8619eb6f2235ca2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">maxint的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>