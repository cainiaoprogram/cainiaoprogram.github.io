<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C 递归 详解（通俗易懂） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C 递归 详解（通俗易懂）" />
<meta property="og:description" content="目录
一、定义
1.概述
2.条件
3.比较
二、 如何理解递归？
1.函数调用其他函数示例 : 2.函数调用函数自身示例 : 3.函数调用自身的底层操作 : ①在主调函数调用被调函数之前——
②在被调函数返回主调函数之前——
③在出现多个函数相互调用的情况时——
三、递归的具体实例
1.求1~100的和 : 思路 : 代码 : 优化 : 2. 汉诺塔问题 : 背景 : 思路 : 代码 : 3.斐波那契数 : 介绍 : 思路 : 代码 : 一、定义 1.概述 递归（Recursion），又称递回，是指一个函数直接或间接地实现自调用。在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。绝大多数编程语言支持函数的自调用，在这些语言中函数可以通过调用自身来进行递归。计算理论可以证明递归的作用可以完全取代循环。
计算机科学家尼克劳斯·维尔特如此描述递归：
“ 递归的强大之处在于它允许用户用有限的语句描述无限的对象。因此，在计算机科学中，递归可以被用来描述无限步的运算，尽管描述运算的程序是有限的。”
——尼克劳斯·维尔特
2.条件 ①递归必须设置一个明确的终止条件，当满足该条件时，递归停止；不满足该条件时，继续递归。PS : 如果一个递归没有设置终止条件，那么它会无限制地递归下去，形成死递归（类似于死循环），称为“死龟了”。
②一个使用了递归的函数，其处理的数据规模一定是在递减的。即，一个有效的递归，它的递归总次数是一定的，执行的次数越多，剩余的规模就越小。
3.比较 这里的“比较”，指的是递归和循环的比较。
理论上讲，可以用循环解决的问题都可以转化为用递归解决；但是用递归解决的的问题有时候并不能用循环解决。
递归结构简洁，更易理解，但是递归所需存储空间大，运行速度慢；
循环结构复杂，不易理解，但是循环所需存储空间小，运行速度快。
二、 如何理解递归？ 1.函数调用其他函数示例 : 递归本质上利用的栈的原理，满足“先进后出”的特点。要想理解递归，必须先理解函数中是如何调用其他函数的，我们先来看下面一段代码 : # include &lt;stdio.h&gt; void f1(); void f2(); void f3(); int main(void) { f1(); return 0; } void f1() { f2(); printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/eeacce7f85104ebe79f4680cb96a005b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-01T16:14:31+08:00" />
<meta property="article:modified_time" content="2023-04-01T16:14:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C 递归 详解（通俗易懂）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89" rel="nofollow">一、定义</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E6%A6%82%E8%BF%B0" rel="nofollow">        1.概述</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%9D%A1%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%9D%A1%E4%BB%B6" rel="nofollow">        2.条件</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E6%AF%94%E8%BE%83" rel="nofollow">        3.比较</a></p> 
<p id="%E4%BA%8C%E3%80%81%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%EF%BC%9F" rel="nofollow">二、 如何理解递归？</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B%C2%A0%3A%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B%C2%A0%3A%C2%A0" rel="nofollow">        1.函数调用其他函数示例 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%87%AA%E8%BA%AB%E7%A4%BA%E4%BE%8B%20%3A%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%87%AA%E8%BA%AB%E7%A4%BA%E4%BE%8B%20%3A%C2%A0" rel="nofollow">        2.函数调用函数自身示例 : </a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%87%AA%E8%BA%AB%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%20%3A%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%87%AA%E8%BA%AB%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%20%3A%C2%A0" rel="nofollow">        3.函数调用自身的底层操作 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E5%9C%A8%E4%B8%BB%E8%B0%83%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A2%AB%E8%B0%83%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E2%80%94%E2%80%94-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E5%9C%A8%E4%B8%BB%E8%B0%83%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A2%AB%E8%B0%83%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E2%80%94%E2%80%94" rel="nofollow">                ①在主调函数调用被调函数之前——</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E5%9C%A8%E8%A2%AB%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%BB%E8%B0%83%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E2%80%94%E2%80%94-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E5%9C%A8%E8%A2%AB%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%BB%E8%B0%83%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E2%80%94%E2%80%94" rel="nofollow">                ②在被调函数返回主调函数之前——</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A2%E5%9C%A8%E5%87%BA%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5%E6%97%B6%E2%80%94%E2%80%94-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A2%E5%9C%A8%E5%87%BA%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5%E6%97%B6%E2%80%94%E2%80%94" rel="nofollow">                ③在出现多个函数相互调用的情况时——</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%80%92%E5%BD%92%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%80%92%E5%BD%92%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E4%BE%8B" rel="nofollow">三、递归的具体实例</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E6%B1%821~100%E7%9A%84%E5%92%8C%20%3A%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E6%B1%821~100%E7%9A%84%E5%92%8C%20%3A%C2%A0" rel="nofollow">        1.求1~100的和 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%80%9D%E8%B7%AF%20%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%80%9D%E8%B7%AF%20%3A%C2%A0" rel="nofollow">                思路 : </a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E4%BB%A3%E7%A0%81%20%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E4%BB%A3%E7%A0%81%20%3A%C2%A0" rel="nofollow">                代码 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BC%98%E5%8C%96%20%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BC%98%E5%8C%96%20%3A%C2%A0" rel="nofollow">                优化 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%20%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%20%3A%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%20%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%20%3A%C2%A0" rel="nofollow">        2. 汉诺塔问题 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E8%83%8C%E6%99%AF%20%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E8%83%8C%E6%99%AF%20%3A%C2%A0" rel="nofollow">                背景 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%80%9D%E8%B7%AF%20%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%80%9D%E8%B7%AF%20%3A%C2%A0" rel="nofollow">                思路 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%20%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%20%3A%C2%A0" rel="nofollow">                代码 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%20%3A%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%20%3A%C2%A0" rel="nofollow">        3.斐波那契数 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%8B%E7%BB%8D%20%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%8B%E7%BB%8D%20%3A%C2%A0" rel="nofollow">                介绍 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%80%9D%E8%B7%AF%20%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%80%9D%E8%B7%AF%20%3A%C2%A0" rel="nofollow">                思路 : </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%20%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%20%3A%C2%A0" rel="nofollow">                代码 : </a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89">一、定义</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E6%A6%82%E8%BF%B0">        1.概述</h3> 
<blockquote> 
 <p>        <span style="color:#956fe7;"><strong>递归（Recursion）</strong></span>，又称递回，<span style="color:#956fe7;"><strong>是指一个函数直接或间接地实现自调用</strong></span>。在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。绝大多数编程语言支持函数的自调用，在这些语言中函数可以通过调用自身来进行递归。计算理论可以证明递归的作用可以完全取代循环。</p> 
 <p>        计算机科学家<strong>尼克劳斯·维尔特</strong>如此描述递归：</p> 
 <p>       <strong> </strong><span style="background-color:#fefcd8;"><strong>“ </strong>递归的强大之处在于它允许用户用有限的语句描述无限的对象。因此，在计算机科学中，递归可以被用来描述无限步的运算，尽管描述运算的程序是有限的。<strong>”</strong></span></p> 
 <p>        <em>——尼克劳斯·维尔特</em></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%9D%A1%E4%BB%B6">        2.条件</h3> 
<blockquote> 
 <p>        <strong>①<span style="background-color:#fefcd8;">递归必须设置一个明确的终止条件，当满足该条件时，递归停止；不满足该条件时，继续递归。</span></strong>PS : 如果一个递归没有设置终止条件，那么它会无限制地递归下去，形成死递归（类似于死循环），称为“死龟了”。</p> 
 <p>        <strong>②<span style="background-color:#fefcd8;">一个使用了递归的函数，其处理的数据规模一定是在递减的</span></strong>。即，一个有效的递归，它的递归总次数是一定的，执行的次数越多，剩余的规模就越小。</p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E6%AF%94%E8%BE%83">        3.比较</h3> 
<blockquote> 
 <p>        这里的“比较”，指的是<span style="color:#fe2c24;"><strong>递归和循环的比较</strong></span>。</p> 
 <p>        理论上讲，<strong><span style="background-color:#fefcd8;">可以用循环解决的问题都可以转化为用递归解决；但是用递归解决的的问题有时候并不能用循环解决</span></strong>。</p> 
 <p>        <span style="background-color:#e7fafa;">递归结构简洁，更易理解，但是递归所需存储空间大，运行速度慢；</span></p> 
 <p>        <span style="background-color:#edf6e8;">循环结构复杂，不易理解，但是循环所需存储空间小，运行速度快。</span></p> 
</blockquote> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%EF%BC%9F">二、 如何理解递归？</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B%C2%A0%3A%C2%A0">        1.函数调用其他函数示例 : </h3> 
<p>                <strong><span style="background-color:#fefcd8;">递归本质上利用的栈的原理，满足“先进后出”的特点</span></strong>。要想理解递归，必须先理解函数中是如何调用其他函数的，我们先来看下面<strong>一段代码 : </strong></p> 
<pre><code class="language-cpp"># include &lt;stdio.h&gt;

void f1();
void f2();
void f3();

int main(void)
{
    f1();

    return 0;
}

void f1()
{
    f2();
    printf("AAAAA\n");
    return;
}

void f2()
{
    f3();
    printf("BBBBB\n");
    return;
}

void f3()
{
    printf("CCCCC\n");
    return;
}</code></pre> 
<p>                 <span style="color:#fe2c24;">你认为以上代码的输出结果是什么？</span><strong>输出结果如下 : </strong></p> 
<p class="img-center"><img alt="" height="242" src="https://images2.imgbox.com/cc/dc/FRoQY00S_o.png" width="1073"></p> 
<p>                <span style="color:#956fe7;"><strong>解释 : </strong></span><br>                 main函数先进栈，<strong><span style="background-color:#fefcd8;">main函数中调用了f1函数，因此f1函数会进栈；因为f1函数中又调用了f2函数，因此f2函数接着进栈；又因为f2函数中又调用了f3函数，所以f3函数跟着进栈</span></strong>。<br>                 <strong><span style="color:#4da8ee;">根据栈“先进后出”的特点</span></strong>，f3函数最后进栈，就要最先出栈，而f3中的代码执行完毕后，打印出CCCCC，继而返回f2中；f2函数执行完毕后，打印出BBBBB，接着f2出栈，返回f1中；f1再打印出AAAAA，最后f1出栈；所以<strong><span style="background-color:#fefcd8;">出栈的顺序是f3 ——&gt; f2 ——&gt; f1</span></strong>。<br>                 那么递归其实就是把“函数中调用其他函数”，给变成了“函数中调用函数自己本身”，同样是栈的原理，同样满足“先进后出”的特点。</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%87%AA%E8%BA%AB%E7%A4%BA%E4%BE%8B%20%3A%C2%A0">        2.函数调用函数自身示例 : </h3> 
<p>                我们再来看一段简单的<strong>递归求某个数阶乘的代码，如下 :</strong> </p> 
<pre><code class="language-cpp"># include &lt;stdio.h&gt;

int factorial(int);

int main(void)
{
    int factorial_value = factorial(4);
    printf("4的阶乘 = %d", factorial_value);

    return 0;
}

int factorial(int n)
{
    if (n == 1 || n == 0)
        return 1;
    return n * factorial(n - 1);
}</code></pre> 
<p>                <strong>运行结果 : </strong></p> 
<p class="img-center"><img alt="" height="237" src="https://images2.imgbox.com/a8/8f/G6YYCo0A_o.png" width="1005"></p> 
<p>               <span style="color:#956fe7;"><strong> 解释 : </strong></span></p> 
<p>                首先我们可以看到，这段代码的目的就是求4的阶乘。main函数先进栈，main函数中调用了factorial方法（factorial [fækˈtɔriəl] 就是“阶乘”的意思），factorial方法要进栈，此时我们传入的实参 = 4；接着，因为4不满足factorial方法中if语句的判断条件，因此要执行return语句，而return语句的内容"n * factorial(n - 1)"中又调用了factorial函数自身，只不过这次调用的效果是factorial(3)了，所以<strong><span style="background-color:#eaf4fc;">factorial(3)<span style="color:#fe2c24;">方法中包含的局部变量</span>要进栈</span></strong>；同理，factorial(2)方法包含的局部变量进栈；factorial(2)方法中有调用factorial(1)方法，所以factorial(1)方法包含的局部变量最后进栈。所以<span style="color:#956fe7;"><strong>整个求4的阶乘的递归过程中，factorial函数的</strong></span><span style="color:#fe2c24;"><strong>压栈顺序为：</strong></span><span style="color:#956fe7;"><strong>factorial(4) ——&gt; factorial(3) ——&gt; factorial(2) ——&gt; factorial(1)</strong></span><br>                 在factorial(1)方法中，满足if条件语句，因此<strong><span style="background-color:#fefcd8;">factorial(1)方法要返回1</span></strong>，接着，factorial(1)方法执行完毕，factorial(1)方法出栈，回到factorial(2)方法；<strong><span style="background-color:#fefcd8;">factorial(2)方法返回 2 * factorial(1) = 2 * (1)</span></strong>，接着factorial(2)方法出栈，回到factorial(3)方法；<strong><span style="background-color:#fefcd8;">factorial(3)方法返回3 * (2 * 1)</span></strong>，接着factorial(3)方法出栈，回到factorial(4)方法；<strong><span style="background-color:#fefcd8;">factorial(4)方法返回4 * (3 * 2 * 1)</span></strong>。所以<span style="color:#956fe7;"><strong>整个求4的阶乘的递归过程中，factorial函数的</strong></span><span style="color:#fe2c24;"><strong>出栈顺序为：</strong></span><span style="color:#956fe7;"><strong>factorial(4) ——&gt; factorial(3) ——&gt; factorial(2) ——&gt; factorial(1)</strong></span>。直到递归到factorial(1)时，停止递归，开始逐层返回。</p> 
<p>                我们可以对以上代码进行优化，使得我们可以求任意一个数的阶乘，<strong>代码如下 : </strong></p> 
<pre><code class="language-cpp"># include &lt;stdio.h&gt;

int factorial(int);

int main(void)
{
    printf("请输入你想求阶乘的数：（提示 : 大于等于0的整型数据）");
    int i;
    scanf("%d", &amp;i);
    int factorial_value = factorial(i);
    
    if (factorial_value == -1)
        printf("请传入大于等于0的数！");
    else
        printf("\n所求数%d的阶乘= %d\n", i, factorial_value);

    return 0;
}

int factorial(int n)
{
    if (n &lt; 0)
    {
        return -1;
    }
    else if (n == 0 || n == 1)
        return 1;
    return n * factorial(n - 1);
}</code></pre> 
<p>                <strong>运行效果 : (如下GIF图) </strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9e/16/l2C9Ytsz_o.gif"></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%87%AA%E8%BA%AB%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%20%3A%C2%A0">        3.函数调用自身的底层操作 : </h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E5%9C%A8%E4%B8%BB%E8%B0%83%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A2%AB%E8%B0%83%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E2%80%94%E2%80%94">                ①在主调函数调用被调函数之前——</h4> 
<p>                <span style="color:#1c7892;"><strong>1°</strong></span> <strong><span style="background-color:#fefcd8;">系统要将传入的实参和主调函数的地址等信息传递给被调函数保存</span></strong>。传递"主调函数的地址"，其目的是为了确保程序执行的连续性，即当被调函数执行完毕准备出栈时，可以根据这个地址来找到接下来需要执行的语句。<br>                 <span style="color:#1c7892;"><strong>2° </strong></span>系统要<strong><span style="background-color:#fefcd8;">为被调函数的局部变量（包括形参和方法体定义的变量）分配内存空间</span></strong>。<br>                <span style="color:#1c7892;"><strong> 3°</strong></span> 将<strong><span style="background-color:#fefcd8;">控制权限由主调函数转移到被调函数的入口</span></strong>，准备执行被调函数。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E5%9C%A8%E8%A2%AB%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%BB%E8%B0%83%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E2%80%94%E2%80%94">                ②在被调函数返回主调函数之前——</h4> 
<p>                <span style="color:#1c7892;"><strong>1°</strong></span> 系统要<strong><span style="background-color:#fefcd8;">保存被调函数的返回结果</span></strong>，即对它做一个备份，用于返回给主调函数。<br>                 <span style="color:#1c7892;"><strong>2°</strong></span> 系统要<strong><span style="background-color:#fefcd8;">释放掉为被调函数分配的内存空间</span></strong>。（不包括动态内存）<br>                 <span style="color:#1c7892;"><strong>3° </strong></span>按照被调函数保存的返回地址，<strong><span style="background-color:#fefcd8;">将控制权限由被调函数转移到主调函数</span></strong>。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A2%E5%9C%A8%E5%87%BA%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5%E6%97%B6%E2%80%94%E2%80%94">                ③在出现多个函数相互调用的情况时——</h4> 
<p>                <span style="color:#1c7892;"><strong>1°</strong></span> 按照“<span style="color:#fe2c24;"><strong>后调用，先返回</strong></span>”的原则，所涉及到的信息传递和控制转移等操作需要借助“栈”来实现。<br>                 <span style="color:#1c7892;"><strong>2° </strong></span>系统会将整个程序运行所需的内存空间安排在一个栈中，每<strong><span style="background-color:#fefcd8;">当调用一个函数时，就在栈顶分配一块空间用于压栈；每当退出一个函数时，就释放这块区域，完成出栈操作；当前运行的函数永远位于栈顶的位置</span></strong>。</p> 
<hr> 
<h2 id="%E4%B8%89%E3%80%81%E9%80%92%E5%BD%92%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E4%BE%8B">三、递归的具体实例</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E6%B1%821~100%E7%9A%84%E5%92%8C%20%3A%C2%A0">        1.求1~100的和 : </h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%80%9D%E8%B7%AF%20%3A%C2%A0">                <span style="color:#956fe7;"><strong>思路 : </strong></span></h4> 
<p>                类似于上文中求阶乘的步骤，我们可以<strong><span style="background-color:#fefcd8;">先进行一个if条件语句的判断——n是否等于1，该判断可作为递归结束的条件</span></strong>；<strong><span style="background-color:#fefcd8;">当n不满足等于1的条件时，就return n + f(n - 1)，f代表当前求和的函数</span></strong>。</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E4%BB%A3%E7%A0%81%20%3A%C2%A0"><strong>                <span style="color:#956fe7;">代码 : </span></strong></h4> 
<pre><code class="language-cpp"># include &lt;stdio.h&gt;

int sum(int);

int main(void)
{

    printf("\n1~100的和 = ");
    int sum_value = sum(100);
    printf("%d\n", sum_value);

    return 0;
}

int sum(int n)
{
    if (n == 1)
        return 1;
    return n + sum(n - 1);
}</code></pre> 
<p>                <strong>运行结果 : </strong></p> 
<p class="img-center"><img alt="" height="197" src="https://images2.imgbox.com/20/6b/11DPHxlM_o.png" width="1100"></p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BC%98%E5%8C%96%20%3A%C2%A0">                <span style="color:#956fe7;"><strong>优化 : </strong></span></h4> 
<p>                我们可以<strong><span style="background-color:#fefcd8;">令用户自定义传入sum函数的实参，达到求"1~n的和"的目的</span></strong>。<strong>代码如下 : </strong></p> 
<pre><code class="language-cpp"># include &lt;stdio.h&gt;

int sum(int);

int main(void)
{
    printf("请输入你想求的1到某个数的和：");
    int n;
    scanf("%d", &amp;n);

    int sum_value = sum(n);
    if (sum_value != -1)
    {
        printf("\n1~%d的和 = ", n);
        printf("%d\n", sum_value);
    }
    else 
        printf("请输入合法的数字！");

    return 0;
}

int sum(int n)
{
    if (n &lt; 1)
        return -1;
    else if (n == 1)
        return 1;
    return n + sum(n - 1);
}</code></pre> 
<p>                <strong>运行效果：（如下GIF图）</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0d/5a/p9hyyYA1_o.gif"></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%20%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%20%3A%C2%A0">        2. 汉诺塔问题 : </h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E8%83%8C%E6%99%AF%20%3A%C2%A0">               <span style="color:#956fe7;"><strong> 背景 : </strong></span></h4> 
<p>                传说越南河内某间寺院有三根银棒，上串<strong> 64 个</strong>金盘。寺院里的僧侣依照一个古老的预言，以特定规则移动这些盘子；预言说当这些盘子移动完毕，世界就会灭亡。<strong>移动金盘的规则如下——</strong><br>                 <strong>①</strong><span style="background-color:#fefcd8;">每次只能移动一个圆盘；</span><br>                 <strong>②</strong><span style="background-color:#fefcd8;">大盘不能叠在小盘上面。</span><br>                 <strong>③</strong><span style="background-color:#fefcd8;">设三根银棒分别为A，B，C；最终要将A棒上的64个金盘移动到C棒上，移动过程中可借助B棒来临时存放金盘。</span></p> 
<h4>               <span style="color:#956fe7;"><strong> 思路 : </strong></span></h4> 
<p>                仍是<span style="color:#fe2c24;"><strong>递归的思想</strong></span>——<br>                 <strong>①</strong>我们先从最简单的1个金盘说起，若想将一个金盘从A棒移动到C棒，直接移动就可以，不需要借助B棒。<br>                 <strong>②</strong>当A棒有2个金盘时，我们可以先将上面的第一个金盘放到B棒上；再把A棒的第二个金盘放到C棒；最后将B棒的第一个金盘放到C棒。(该目标的实现借助了B棒，B棒上临时存放了第1个金盘）<br>                 <strong>③</strong>当A棒有3个金盘时，我们可以设法将A棒上面的2个金盘放到B棒上，将第三个金盘从A棒移动到C棒，再设法将B棒临时存放的两个金盘放到C棒上。其中，<strong><span style="background-color:#fefcd8;">“设法将A棒上面的2个金盘放到B棒上” 和 “设法将B棒上面的两个金盘放到C棒上” ，这两个步骤其实就是在重复②的步骤</span></strong>。<br>                 <strong>④<span style="color:#956fe7;">通过③我们可知，金盘的数量每增加1个，其实都是在重复之前金盘数量时的步骤，最核心的步骤就是将A棒最下面的那个最大的金盘从A棒放到C棒</span></strong>。而要想实现最核心的步骤，<span style="color:#fe2c24;"><strong>必须分三步走：</strong></span><span style="color:#1c7892;"><strong>1° </strong></span><span style="color:#fe2c24;"><strong>先设法将A棒上面的n-1个金盘借助C棒移动到B棒，使A棒只剩下最下面的最大的金盘，同时C棒为空</strong></span>；这样才能<span style="color:#1c7892;"><strong>2°</strong></span> <span style="color:#fe2c24;"><strong>接着把最大的金盘从A移动到C</strong></span>；之后，再<span style="color:#1c7892;"><strong>3° </strong></span><span style="color:#fe2c24;"><strong>设法将B棒上面的n - 1个金盘借助A棒移动到C棒</strong></span>。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%20%3A%C2%A0">                <span style="color:#956fe7;"><strong>代码 : </strong></span></h4> 
<pre><code class="language-cpp"># include &lt;stdio.h&gt;

int count = 0;
void hanoi(int, char, char, char);

int main(void)
{
    printf("请输入汉诺塔的层数, floors = ");
    int floors;
    scanf("%d", &amp;floors);

    hanoi(floors, 'A','B','C');
    if (count &gt; 0)
        printf("总共需要执行的步骤有%d步\n", count);

    return 0;
}

void hanoi(int n, char a, char b, char c)
{
    if (n &lt; 1)
    {
        printf("请传入合法有效的数据！");
        return;
    }
    else if (n == 1)
    {
        printf("%c --&gt; %c\n", a,c);
        ++count;
        return;
    }

    hanoi(n - 1, a,c,b);
    printf("%c --&gt; %c\n", a,c);
    count++;
    hanoi(n - 1, b,a,c);

    return;
}

/*
    注意 : 
    ①hanoi(n - 1, a,c,b) 和 hanoi(n - 1, b,a,c)，这两个步骤是相互联系的。
    ②else if语句中的printf语句，其目的是为了帮助完成hanoi（n - 1, a,c,b)操作；
     最后的printf语句，其目的是完成最核心步骤————将最大的盘从A棒移动到C棒。
*/</code></pre> 
<p>                <strong>运行效果 : (如下GIF图）</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/17/f7/FIjPJQNx_o.gif"></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%20%3A%C2%A0">        3.斐波那契数 : </h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%8B%E7%BB%8D%20%3A%C2%A0">                <span style="color:#956fe7;"><strong>介绍 : </strong></span></h4> 
<p>                <strong><span style="background-color:#fefcd8;">Fibonacci[/ˌfɪbəˈnɑːtʃi/]，斐波那契数</span></strong>（意大利语：Successione di Fibonacci），又译为菲波拿契数、菲波那西数、斐氏数、黄金分割数。<strong><span style="background-color:#fefcd8;">所形成的数列称为斐波那契数列，又译为菲波拿契数列、菲波那西数列、斐氏数列、黄金分割数列</span></strong>。这个数列是由意大利数学家斐波那契在他的《算盘书》中提出。<br>                 <span style="color:#fe2c24;"><strong>在数学上，斐波那契数是以递归的方法来定义</strong></span>：<br>                 <strong><span style="background-color:#fefcd8;">令F0 = 0; F1 = 1; 则Fn = F(n - 1) + F(n - 2)，其中n ≥2。即——从数列的第三项开始，每一项的值等于前面两项之和</span></strong>，称为斐波那契数列。斐波那契数列的前几项如下所示 : </p> 
<p class="img-center"><img alt="" height="66" src="https://images2.imgbox.com/ae/f2/KJYMtXej_o.png" width="1153"></p> 
<p>                <span style="color:#fe2c24;"><strong>PS : 0不是第一项，而是第零项，斐波那契数列在文本上从1开始。 </strong></span></p> 
<h4>                <span style="color:#956fe7;"><strong>思路 : </strong></span></h4> 
<p>               <strong><span style="background-color:#e7fafa;"> 设n代表斐波那契数列的第n项，当n等于1或者等于2时，可以直接返回1</span></strong>；<strong><span style="background-color:#edf6e8;">当n大于2时，要想求出斐波纳契数列的第n项，必须知道它前面的两项分别是多少，而要想知道它前面的两项分别是多少，就又得知道这两项再分别往前的两项是多少</span></strong>，<span style="color:#fe2c24;"><strong>依次递归下去，直到n == 1或者n == 2的情况时，return 1；接着再逐层返回，回到你想求出的第n项</strong></span>。</p> 
<h4>                <span style="color:#956fe7;"><strong>代码 : </strong></span></h4> 
<pre><code class="language-cpp">/*
    斐波那契数列
    2023.4.1
*/

# include &lt;stdio.h&gt;

int fibonacci(int);

int main(void)
{
    printf("请输入你想输出斐波那契数列的前几项？\nnum = ");
    int num;
    scanf("%d", &amp;num);

    if (fibonacci(num) == -1)
    {
        printf("请输入合法数据!");
    }
    else 
    {
        int i;
        for (i = 1; i &lt;= num; ++i)
        {
            printf("%d\t", fibonacci(i));
        }
    }

    return 0;
}

int fibonacci(int n)
{
    if (n &lt; 1)
        return -1;
    else if (n == 1 || n == 2)
        return 1;

    return fibonacci(n - 1) + fibonacci(n - 2);
}</code></pre> 
<p>                <strong>运行效果：（如下GIF图所示）</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ff/3d/wZPlUKKk_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/347584378e3951cdf02d2d8d54fc6256/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">虚拟机连接USB设备</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0230071015b09362db34338df5a1beb9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">注意力机制综述（自用）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>