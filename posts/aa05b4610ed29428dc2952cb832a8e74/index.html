<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kubernetes 学习总结（43）—— Kubernetes 从提交 deployment 到 pod 运行的全过程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kubernetes 学习总结（43）—— Kubernetes 从提交 deployment 到 pod 运行的全过程" />
<meta property="og:description" content="当用户向 Kubernetes 提交了一个创建 deployment 的请求后，Kubernetes 从接收请求直至创建对应的 pod 运行这整个过程中都发生了什么呢？
kubernetes 架构简述 在搞清楚从 deployment 提交到 pod 运行整个过程之前，我们有先来看看 Kubernetes 的集群架构：
上图与下图相同：
如图所示，k8s 集群分为 control plane 控制平面和 node 节点。control plane 控制平面（也称之为主节点）主要包含以下组件：
kube-api-server: 顾名思义，负责处理所有 api，包括客户端以及集群内部组件的请求。
etcd: 分布式持久化存储、事件订阅通知。只有 kube-api-server 直接操作 etcd，其它所有组件都是与 kube-api-server 进行相互。
scheduler: 处理 pod 的调度，将 pod 绑定到具体的 node 节点。
controller manager: 控制器，处理各种资源对象。
cloud controller manager: 对接云服务商的控制器。
node 节点，专门部署用户的应用程序（与控制平面隔离，避免影响到 k8s 的核心组件），主要包含以下组件：
kubelet: 管理节点上的 pod 以及状态检查和上报。
kube-proxy: 进行流量的路由转发（目前是通过操作节点的 iptables 或者 ipvs 实现）。
CRI: 容器运行时接口。
从 Deployment 到 Pod 从 Deployment 到 Pod 的整个过程如下图所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/aa05b4610ed29428dc2952cb832a8e74/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T09:59:11+08:00" />
<meta property="article:modified_time" content="2024-01-07T09:59:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kubernetes 学习总结（43）—— Kubernetes 从提交 deployment 到 pod 运行的全过程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>当用户向 <code>Kubernetes</code> 提交了一个创建 <code>deployment</code> 的请求后，<code>Kubernetes</code> 从接收请求直至创建对应的 <code>pod</code> 运行这整个过程中都发生了什么呢？</p> 
<h2>kubernetes 架构简述</h2> 
<p>在搞清楚从 <code>deployment</code> 提交到 <code>pod</code> 运行整个过程之前，我们有先来看看 <code>Kubernetes</code> 的集群架构：</p> 
<p class="img-center"><img alt="图片" height="460" src="https://images2.imgbox.com/9a/ba/87pkzLxI_o.png" width="729"></p> 
<p>上图与下图相同：</p> 
<p class="img-center"><img alt="图片" height="651" src="https://images2.imgbox.com/88/2f/zmYkWJbt_o.png" width="641"></p> 
<p>如图所示，k8s 集群分为 <code>control plane</code> 控制平面和 <code>node</code> 节点。<code>control plane</code> 控制平面（也称之为主节点）主要包含以下组件：</p> 
<blockquote> 
 <ul><li> <p><code>kube-api-server</code>: 顾名思义，负责处理所有 api，包括客户端以及集群内部组件的请求。</p> </li><li> <p><code>etcd</code>: 分布式持久化存储、事件订阅通知。只有 <code>kube-api-server</code> 直接操作 <code>etcd</code>，其它所有组件都是与 <code>kube-api-server</code> 进行相互。</p> </li><li> <p><code>scheduler</code>: 处理 pod 的调度，将 pod 绑定到具体的 node 节点。</p> </li><li> <p><code>controller manager</code>: 控制器，处理各种资源对象。</p> </li><li> <p><code>cloud controller manager</code>: 对接云服务商的控制器。</p> </li></ul> 
</blockquote> 
<p><code>node</code> 节点，专门部署用户的应用程序（与控制平面隔离，避免影响到 k8s 的核心组件），主要包含以下组件：</p> 
<blockquote> 
 <ul><li> <p><code>kubelet</code>: 管理节点上的 pod 以及状态检查和上报。</p> </li><li> <p><code>kube-proxy</code>: 进行流量的路由转发（目前是通过操作节点的 iptables 或者 ipvs 实现）。</p> </li><li> <p><code>CRI</code>: 容器运行时接口。</p> </li></ul> 
</blockquote> 
<h2>从 Deployment 到 Pod</h2> 
<p>从 <code>Deployment</code> 到 <code>Pod</code> 的整个过程如下图所示：</p> 
<p class="img-center"><img alt="图片" height="925" src="https://images2.imgbox.com/cb/cb/dEk1Fhwi_o.png" width="931"></p> 
<h4>1. 请求发送到 <code>kube-api-server</code></h4> 
<p>请求发送到 <code>kube-api-server</code>，然后会进行认证、鉴权、变更、校验等一系列过程，最后将 deployment 的数据持久化存储至 <code>etcd</code>。</p> 
<p class="img-center"><img alt="图片" height="402" src="https://images2.imgbox.com/79/c0/tZhD2UJM_o.png" width="1080"></p> 
<p>在这个过程我们可以通过 mutation admission 的 webhook 自主地对资源对象进行任意的变更，比如注入 sidecar 等等。</p> 
<h4>2. controller manager 处理</h4> 
<p><code>controller manager</code> 组件针对不同的资源对象有不同的处理部分。针对 <code>Deployment</code>，由于其并不直接管理 <code>Pod</code>，而是 <code>Deployment</code> 管理 <code>ReplicaSet</code>，<code>ReplicaSet</code> 再管理 <code>Pod</code>：</p> 
<p class="img-center"><img alt="图片" height="171" src="https://images2.imgbox.com/ec/bf/vGDfQqYQ_o.png" width="461"></p> 
<p>因此其中涉及到 <code>controller manager</code> 中的两个部分：</p> 
<blockquote> 
 <ul><li> <p><code>deployment controller</code></p> </li><li> <p><code>replicaset controller</code></p> </li></ul> 
</blockquote> 
<p>(1) 先是 <code>deployment controller</code> 监听到 <code>deployment</code> 的创建事件，然后进行相关的处理，最后创建 <code>replicaset</code>。</p> 
<p>(2) 然后 <code>replicaset controller</code> 监听到 <code>replicaset</code> 的创建事件，进行相关处理后，最后创建 <code>pod</code>。</p> 
<h4>3. scheduler 调度</h4> 
<p><code>scheduler</code> 接受到 pod 需要调度的事件后，进行一系列调度逻辑处理，最后选择一个合适的 node 节点，将 pod 绑定到这个节点上（所谓的节点调度在这里只是修改 pod 数据，对其中的 nodeName 进行赋值）。具体的调度算法比较复杂，涉及强制性调度、亲和与反亲和、污点和容忍、以及硬件资源计算、优先级等等，本文不做展开。</p> 
<h4>4. 节点 kubelet 处理</h4> 
<p>调度完成后，<code>pod</code> 被绑定的 node 节点上的 <code>kubelet</code> 同样通过 <code>kube-api-server</code> 会接受到相应的事件，然后 <code>kubelet</code> 会进行 <code>pod</code> 的创建。在这个过程中 <code>kubelet</code> 会分别调用 <code>CRI</code>、<code>CNI</code>、<code>CSI</code>：</p> 
<blockquote> 
 <ul><li> <p><code>CRI</code>（Container Runtime Interface）: 容器运行时接口，<code>CRI</code> 插件负责执行拉取镜像、创建、删除容器等操作。<code>CRI</code> 的几种常用插件：</p> 
   <ul><li> <p><code>containerd</code></p> </li><li> <p><code>CRI-O</code></p> </li><li> <p><code>Docker Engine</code></p> </li></ul></li><li> <p><code>CNI</code>（Container Network Interface）: 容器网络接口，<code>CNI</code> 插件负责给 pod 分配 IP 地址，确保 pod 能够与集群内的其它 pod 进行通信。<code>CNI</code> 的几种常用插件：</p> 
   <ul><li> <p><code>Cilium</code></p> </li><li> <p><code>Calico</code></p> </li></ul></li><li> <p><code>CSI</code>（Container Storage Interface）: 容器存储接口，<code>CSI</code> 插件负责与外部存储提供者通信，执行卷的附加、挂载等操作。</p> </li></ul> 
</blockquote> 
<p>所谓的接口其实只是定义了通信的规范或者标准（使用的是 <code>grpc</code> 协议），具体的实现则是交给了插件。至此，Kubernetes 从创建 deployment 到 pod 运行的全过程就是这样了。</p> 
<p class="img-center"><img alt="图片" height="925" src="https://images2.imgbox.com/02/10/KeepDvk6_o.png" width="931"></p> 
<p>参考资料：</p> 
<blockquote> 
 <ul><li> <p>https://kubernetes.io/docs/concepts/architecture/</p> </li><li> <p>https://kubernetes.io/docs/concepts/scheduling-eviction/</p> </li><li> <p>https://kubernetes.io/docs/setup/production-environment/container-runtimes/</p> </li><li> <p>https://kubernetes.io/docs/tasks/administer-cluster/network-policy-provider/</p> </li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54d3851bd57116d0fe29c692cc318220/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot学习(八)-SpringBoot &#43; Dubbo &#43; zookeeper</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9739517b71f0a227fbc8bea49950d013/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Kubernetes 学习总结（44）—— Kubernetes 1.29 中的删除、弃用和主要更改</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>