<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python学习笔记——从面试题出发学习Python - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python学习笔记——从面试题出发学习Python" />
<meta property="og:description" content="Python学习笔记——从面试题出发学习Python Python学习笔记——从面试题出发学习Python1. 可变数据类型与不可变数据类型，深拷贝与浅拷贝，函数参数的传递机制1.1 变量与对象1.2 可变数据类型与不可变数据类型1.3 深拷贝与浅拷贝1.4 函数参数的传递机制1.5 is和==的区别 2. Python的内存管理机制，Python是否会存在内存泄漏的情况2.1 内存池机制2.2 垃圾回收机制2.2.1 标记-清除机制2.2.2 分代回收机制 2.3 Python内存泄漏 3. 闭包与装饰器3.1 Python的作用域3.2 闭包3.3 装饰器 4. 迭代器与生成器4.1 惰性计算4.1 迭代器4.2 生成器 5. 正则表达式5.1 元字符和语法5.2 re模块函数5.3 re模块变量 6. Python中的魔法方法类别有哪些？__init__和__new__的区别是什么？6.1 魔法方法6.2 __ init__和__ new__的区别 7. 多重继承中的MRO机制7.1 新式类和旧式类的区别7.2 多重继承带来的问题7.3 MRO机制7.4 super()作用 8. Python中为什么没有重载？8.1 为什么没有重载8.2 Python函数可变参数 9. Python内建模块9.1 collections模块的用法9.2 functools模块的用法9.3 itertools模块的用法 10 协程10.1 GIL的概念10.2 协程的概念 Python学习笔记——从面试题出发学习Python 1. 可变数据类型与不可变数据类型，深拷贝与浅拷贝，函数参数的传递机制 1.1 变量与对象 对象指的是内存中存储数据的实体，具有明确的类型，在 Python 中一切都是对象，包括函数。变量作为对象的引用/别名，实质保存着所指对象的内存地址。 1.2 可变数据类型与不可变数据类型 在Python中类型属于对象，变量没有类型，仅仅是对一个对象的引用。而赋值语句改变的是变量所执的对对象的引用，故一个变量可指向各种数据类型的对象。
从现象上看：不可变数据类型更改值后，内存地址发生改变；可变数据类型更改值后，内存地址不发生改变。从本质上看：不可变数据类型对象相应内存中的值不可改变，但变量对对象的引用或指向关系仍是可变的，指向原不可变对象的变量被改变为指向新对象时，Python 会开辟一块新的内存区域，并令变量指向这个新内存，并通过 “垃圾回收机制” 回收原对象；可变数据类型对象的内存地址处的值可改变，因此指向可变对象的变量若发生改变，则该可变对象亦随之改变，即发生原地 (in-place) 修改可变数据类型：list（列表）、dict（字典）不可变数据类型：数值类型（int、float、bool）、string（字符串）、tuple（元组） 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5022f522ccebfcc418aa56d23f2745e2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-03T17:19:11+08:00" />
<meta property="article:modified_time" content="2023-09-03T17:19:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python学习笔记——从面试题出发学习Python</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Python学习笔记——从面试题出发学习Python</h4> 
 <ul><li><a href="#PythonPython_1" rel="nofollow">Python学习笔记——从面试题出发学习Python</a></li><li><ul><li><a href="#1__3" rel="nofollow">1. 可变数据类型与不可变数据类型，深拷贝与浅拷贝，函数参数的传递机制</a></li><li><ul><li><a href="#11__4" rel="nofollow">1.1 变量与对象</a></li><li><a href="#12__7" rel="nofollow">1.2 可变数据类型与不可变数据类型</a></li><li><a href="#13__13" rel="nofollow">1.3 深拷贝与浅拷贝</a></li><li><a href="#14__68" rel="nofollow">1.4 函数参数的传递机制</a></li><li><a href="#15_is_74" rel="nofollow">1.5 is和==的区别</a></li></ul> 
   </li><li><a href="#2_PythonPython_78" rel="nofollow">2. Python的内存管理机制，Python是否会存在内存泄漏的情况</a></li><li><ul><li><a href="#21__79" rel="nofollow">2.1 内存池机制</a></li><li><a href="#22__89" rel="nofollow">2.2 垃圾回收机制</a></li><li><ul><li><a href="#221__94" rel="nofollow">2.2.1 标记-清除机制</a></li><li><a href="#222__99" rel="nofollow">2.2.2 分代回收机制</a></li></ul> 
    </li><li><a href="#23_Python_110" rel="nofollow">2.3 Python内存泄漏</a></li></ul> 
   </li><li><a href="#3__115" rel="nofollow">3. 闭包与装饰器</a></li><li><ul><li><a href="#31_Python_116" rel="nofollow">3.1 Python的作用域</a></li><li><a href="#32__149" rel="nofollow">3.2 闭包</a></li><li><a href="#33__179" rel="nofollow">3.3 装饰器</a></li></ul> 
   </li><li><a href="#4__247" rel="nofollow">4. 迭代器与生成器</a></li><li><ul><li><a href="#41__249" rel="nofollow">4.1 惰性计算</a></li><li><a href="#41__254" rel="nofollow">4.1 迭代器</a></li><li><a href="#42__286" rel="nofollow">4.2 生成器</a></li></ul> 
   </li><li><a href="#5__332" rel="nofollow">5. 正则表达式</a></li><li><ul><li><a href="#51__334" rel="nofollow">5.1 元字符和语法</a></li><li><a href="#52_re_337" rel="nofollow">5.2 re模块函数</a></li><li><a href="#53_re_340" rel="nofollow">5.3 re模块变量</a></li></ul> 
   </li><li><a href="#6_Python__init____new___343" rel="nofollow">6. Python中的魔法方法类别有哪些？__init__和__new__的区别是什么？</a></li><li><ul><li><a href="#61__344" rel="nofollow">6.1 魔法方法</a></li><li><a href="#62____init_____new___360" rel="nofollow">6.2 __ init__和__ new__的区别</a></li></ul> 
   </li><li><a href="#7_MRO_391" rel="nofollow">7. 多重继承中的MRO机制</a></li><li><ul><li><a href="#71__392" rel="nofollow">7.1 新式类和旧式类的区别</a></li><li><a href="#72__397" rel="nofollow">7.2 多重继承带来的问题</a></li><li><a href="#73_MRO_461" rel="nofollow">7.3 MRO机制</a></li><li><a href="#74_super_477" rel="nofollow">7.4 super()作用</a></li></ul> 
   </li><li><a href="#8_Python_517" rel="nofollow">8. Python中为什么没有重载？</a></li><li><ul><li><a href="#81__518" rel="nofollow">8.1 为什么没有重载</a></li><li><a href="#82_Python_522" rel="nofollow">8.2 Python函数可变参数</a></li></ul> 
   </li><li><a href="#9_Python_552" rel="nofollow">9. Python内建模块</a></li><li><ul><li><a href="#91_collections_554" rel="nofollow">9.1 collections模块的用法</a></li><li><a href="#92_functools_557" rel="nofollow">9.2 functools模块的用法</a></li><li><a href="#93_itertools_560" rel="nofollow">9.3 itertools模块的用法</a></li></ul> 
   </li><li><a href="#10__565" rel="nofollow">10 协程</a></li><li><ul><li><a href="#101_GIL_566" rel="nofollow">10.1 GIL的概念</a></li><li><a href="#102__572" rel="nofollow">10.2 协程的概念</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="PythonPython_1"></a>Python学习笔记——从面试题出发学习Python</h2> 
<h3><a id="1__3"></a>1. 可变数据类型与不可变数据类型，深拷贝与浅拷贝，函数参数的传递机制</h3> 
<h4><a id="11__4"></a>1.1 变量与对象</h4> 
<ol><li><strong>对象</strong>指的是内存中存储数据的实体，具有明确的类型，在 Python 中一切都是对象，包括函数。</li><li><strong>变量</strong>作为对象的引用/别名，实质保存着所指对象的内存地址。</li></ol> 
<h4><a id="12__7"></a>1.2 可变数据类型与不可变数据类型</h4> 
<p>在Python中<strong>类型属于对象，变量没有类型</strong>，仅仅是对一个对象的引用。<strong>而赋值语句改变的是变量所执的对对象的引用，故一个变量可指向各种数据类型的对象。</strong></p> 
<ol><li><strong>从现象上看</strong>：<strong>不可变数据类型</strong>更改值后，内存地址发生改变；<strong>可变数据类型</strong>更改值后，内存地址不发生改变。</li><li><strong>从本质上看</strong>：<strong>不可变数据类型</strong>对象相应内存中的值不可改变，但变量对对象的引用或指向关系仍是可变的，指向原不可变对象的变量被改变为指向新对象时，Python 会开辟一块新的内存区域，并令变量指向这个新内存，并通过 “<strong>垃圾回收机制</strong>” 回收原对象；<strong>可变数据类型</strong>对象的内存地址处的值可改变，因此指向可变对象的变量若发生改变，则该可变对象亦随之改变，即发生原地 (in-place) 修改</li><li>可变数据类型：list（列表）、dict（字典）</li><li>不可变数据类型：数值类型（int、float、bool）、string（字符串）、tuple（元组）</li></ol> 
<h4><a id="13__13"></a>1.3 深拷贝与浅拷贝</h4> 
<p>对于不可变对象，无论深、浅拷贝，内存地址都是一成不变，对于可变对象，需要分情况讨论：</p> 
<ol><li> <p><strong>直接赋值</strong>：仅拷贝了对可变对象的引用，故前后变量均未隔离，任一变量 / 对象改变，则所有引用了同一可变对象的变量都作相同改变。</p> </li><li> <p><strong>浅拷贝</strong>：使用 copy(x) 函数，拷贝可变对象最外层对象并实现隔离，但内部的嵌套对象仍是未被隔离的引用关系。下面这段代码说明这个问题：</p> <pre><code class="prism language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> copy
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> z <span class="token operator">=</span> copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 浅拷贝</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> zz <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment"># 也是浅拷贝, 等同于使用 copy() 函数的 z</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> z
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> zz
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
 
<span class="token comment"># 改变变量 x 的外围元素, 不会改变浅拷贝变量</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">777</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">777</span><span class="token punctuation">]</span>  <span class="token comment"># 只有自身改变, 增加了外围元素 777</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> z
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 未改变</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> zz
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 未改变</span>
 
<span class="token comment"># 改变变量 x 的内层元素, 则会改变浅拷贝变量</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">888</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token number">888</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">777</span><span class="token punctuation">]</span>  <span class="token comment"># 同时发生改变, 增加了内层元素 888</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> z
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token number">888</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 同时发生改变, 增加了内层元素 888</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> zz
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token number">888</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 同时发生改变, 增加了内层元素 888</span>
 
<span class="token comment"># 浅拷贝变量的外围元素改变不会相互影响</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> z<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">555</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token number">888</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">777</span><span class="token punctuation">]</span>  <span class="token comment"># 未改变</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> z
<span class="token punctuation">[</span><span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token number">888</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 只有自身改变, 弹出了外围元素 555</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> zz
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token number">888</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 未改变</span>
 
<span class="token comment"># 浅拷贝变量的内层元素改变会相互影响</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> z<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">888</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">777</span><span class="token punctuation">]</span>  <span class="token comment"># 同时发生改变, 弹出了内层元素 888</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> z
<span class="token punctuation">[</span><span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 同时发生改变, 弹出了内层元素 888</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> zz
<span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">555</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 同时发生改变, 弹出了内层元素 88</span>
</code></pre> </li><li> <p><strong>深拷贝</strong>：使用 deepcopy(x) 函数，拷贝可变对象的“外围+内层”而非引用，实现对前后变量不论深浅层的完全隔离。<strong>此外需要注意的是深拷贝递归对象 (直接或间接包含对自身引用的复合对象) 可能会导致递归循环</strong>。</p> </li></ol> 
<h4><a id="14__68"></a>1.4 函数参数的传递机制</h4> 
<p>Python参数传递采用的是“传对象引用”的方式，结合上面我们对可变对象和不可变对象、深拷贝以及浅拷贝的解析，我们应该可以得到如下结论：</p> 
<ol><li>如果函数收到的是一个<strong>可变对象</strong>的引用，就能修改对象的原始值，相当于通过**“传引用”**来传递对象。</li><li>如果函数收到的是一个<strong>不可变对象</strong>的引用，就不能直接修改原始对象，相当于通过**“传值’**来传递对象。</li></ol> 
<h4><a id="15_is_74"></a>1.5 is和==的区别</h4> 
<ol><li>is 用于判断两个变量<strong>引用对象是否为同一个</strong>， == 用于判断引用变量的<strong>值是否相等</strong></li><li>a is b 相当于 id(a)==id(b)，id() 能够获取对象的内存地址。</li><li>Python出于对性能的考虑，但凡是<strong>不可变对象，在同一个代码块中的对象，只有是值相同的对象，就不会重复创建，而是直接引用已经存在的对象。</strong></li></ol> 
<h3><a id="2_PythonPython_78"></a>2. Python的内存管理机制，Python是否会存在内存泄漏的情况</h3> 
<h4><a id="21__79"></a>2.1 内存池机制</h4> 
<ol><li>当创建大量消耗小内存的对象时，<strong>频繁调用new/malloc会导致大量的内存碎片</strong>，致使效率降低。<strong>内存池的作用就是预先在内存中申请一定数量的，大小相等的内存块留作备用</strong>，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够之后再申请新的内存。这样做最显著的优势就是能够<strong>减少内存碎片，提升效率</strong>。</li><li>Python的对象管理主要位于Level+1~Level+3层，<br> <strong>Level+3层</strong>：对于Python内置的对象（比如int,dict等）都有独立的私有内存池，对象之间的内存池不共享，即int释放的内存，不会被分配给float使用<br> <strong>Level+2层</strong>：当申请的内存大小小于256KB时，内存分配主要由 Python 对象分配器实施<br> <strong>Level+1层</strong>：当申请的内存大小大于256KB时，由Python原生的内存分配器进行分配，本质上是调用<strong>C标准库中的malloc/realloc等函数</strong></li></ol> 
<p><img src="https://images2.imgbox.com/31/2f/wK7RuMHf_o.png" alt="在这里插入图片描述" width="500"><br> 3. 关于释放内存方面，当一个对象的引用计数变为0时，Python就会调用它的析构函数。<strong>调用析构函数并不意味着最终一定会调用free来释放内存空间</strong>，频繁地申请、释放内存空间会使Python的执行效率大打折扣。在析构时也采用了内存池机制，从内存池申请到的内存会被归还到内存池中，以避免频繁地申请和释放动作</p> 
<h4><a id="22__89"></a>2.2 垃圾回收机制</h4> 
<ol><li>Python 通过<strong>引用计数和一个能够检测和打破循环引用的循环垃圾回收器来执行垃圾回收</strong>。可用 gc 模块控制垃圾回收器。具体而言，对每个对象维护一个 ob_refcnt 字段，用于记录该对象当前被引用的次数。每当有新引用指向该对象时，该对象的引用计数 ob_refcnt +1；每当该对象的引用失效时，该对象的引用计数 ob_refcnt -1；<strong>一旦对象的引用计数 ob_refcnt = 0，该对象列入垃圾回收队列，进而进行内存释放</strong>。</li><li>引用计数垃圾回收机制的<strong>优点</strong>在于，能够自动清理不用的内存空间，甚至能够随意新建对象引用而无需考虑手动释放内存空间的问题，故相比于 C 或 C++ 这类静态语言更“省心”。</li><li>引用计数垃圾回收机制的<strong>缺点</strong>是需要额外空间资源维护引用计数。</li></ol> 
<h5><a id="221__94"></a>2.2.1 标记-清除机制</h5> 
<ol><li>标记-清除用来<strong>解决引用计数机制产生的循环引用，进而导致内存泄漏的问题</strong> 。 循环引用只有在<strong>容器对象</strong>（包含对其它对象的引用的对象）才会产生，比如字典，元组，列表等。</li><li><strong>标记阶段</strong>，从root节点遍历所有的对象，如果是可达的，也就是还有对象引用它，那么就标记该对象为可达。</li><li><strong>清除阶段</strong>，从root节点出发再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。如下图中蓝色即为可达对象，红色即为不可达对象，将会被清除。<br> <img src="https://images2.imgbox.com/8f/e3/xVqwqL9f_o.jpg" alt="请添加图片描述" width="300"></li></ol> 
<h5><a id="222__99"></a>2.2.2 分代回收机制</h5> 
<p>分代回收建立标记清除的基础之上，是一种以空间换时间的操作方式，即<strong>控制内存回收频次</strong>。</p> 
<ol><li>分代回收，根据内存中对象的存活时间将他们分为3代，新生的对象放入到0代，如果一个对象能在第0代的垃圾回收过程中存活下来，则将其放入到1代中，同理，则会进入到2代。</li><li>能够活着成为第2代的对象，必然是那些使用频繁的对象，而且<strong>他们已经存活很久的时间了，大概率的，还会存活很久</strong>，因此，2代回收的就不那么频繁。</li><li>Python中可以通过设置阈值来改变分代回收的触发条件：<pre><code class="prism language-python"><span class="token keyword">import</span> gc

gc<span class="token punctuation">.</span>set_threshold<span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>gc<span class="token punctuation">.</span>get_threshold<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> </li></ol> 
<h4><a id="23_Python_110"></a>2.3 Python内存泄漏</h4> 
<p>Python内存泄漏通常有如下几种情况：</p> 
<ol><li>所用到的用 C 语言开发的<strong>底层模块中出现了内存泄露</strong>。</li><li>代码中用到了全局的 list、 dict 或其它容器，不停的往这些容器中插入对象，而忘记了在<strong>使用完之后进行删除回收</strong>。</li><li>有引用循环并且<strong>被循环引用的对象定义了__del__方法</strong>，就会发生内存泄露。原因是重载__del__方法后垃圾回收模块不知道应该先调用哪个对象的__del__方法，因此<strong>gc.collect()方法就默认不对重载了__del__方法的循环引用对象进行回收</strong>，而对象的状态也会从unreachable转变为uncollectable。<strong>要解决这种情况造成内存泄漏的话，只能显式调用其中某个对象的__del__方法</strong>。</li></ol> 
<h3><a id="3__115"></a>3. 闭包与装饰器</h3> 
<h4><a id="31_Python_116"></a>3.1 Python的作用域</h4> 
<p>在学习闭包概念之前，有必要先了解下Python的作用域相关概念</p> 
<ol><li>Python的定义是程序<strong>创建、访问、改变</strong>一个变量时，都是在一个<strong>保存</strong>该变量的空间内进行，这个空间为命名空间，即作用域。</li><li>Python的作用域可以概括为<strong>LEGB四种作用域</strong>：<br> <strong>L（Local）</strong>：在函数与类中，每当调用函数时都会创建一个局部作用域，局部变量域像一个栈，仅仅是暂时的存在，依赖创建该局部作用域的函数是否处于活动的状态；<br> <strong>E（Enclosing）</strong>：一般出现在函数中嵌套了一个函数，在外围的函数中的作用域；主要目的是实现<strong>闭包</strong>；<br> <strong>G（Global）</strong>：模块文件顶层声明的变量具有全局作用域，从外部看来，模块的全局变量就是一个模块对象的属性；仅限于单个模块文件中；<br> <strong>B（Built-in）</strong>： 系统内解释器定义的变量，如预定义在builtin 模块内的变量；解释器在则在，解释器亡则亡；</li><li><strong>只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）不会引入新的作用域的</strong>，如下代码：<pre><code class="prism language-python">flist <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">xrange</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> x<span class="token operator">*</span>i
	flist<span class="token punctuation">.</span>append<span class="token punctuation">(</span>func<span class="token punctuation">)</span>

<span class="token keyword">for</span> f <span class="token keyword">in</span> flist<span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 上述打印结果为4，4，4，而不是0，2，4，原因是在往flist中添加func的时候并<strong>没有形成作用域，也就没有保存i的值</strong>，而是在执行f(2)的时候去取，此时循环已经结束，i的值固定为2，输出结果为4，4，4，如果需要输出0，2，4的话，可以进行如下修改形成闭包即可：<pre><code class="prism language-python">flist <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">xrange</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">makefunc</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		<span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">return</span> x<span class="token operator">*</span>i
		<span class="token keyword">return</span> func
	flist<span class="token punctuation">.</span>append<span class="token punctuation">(</span>makefunc<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> f <span class="token keyword">in</span> flist<span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 下面我们来看闭包的定义和使用方法。</li></ol> 
<h4><a id="32__149"></a>3.2 闭包</h4> 
<p>闭包并不是Python的独有概念，闭包在维基百科上的定义如下：</p> 
<blockquote> 
 <p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p> 
</blockquote> 
<p>闭包的两个作用主要是：</p> 
<ol><li>可以读取外层函数的变量；</li><li>使得外层函数内的局部变量的值始终保持在内存中，不会在外层函数调用后自动被清除；</li></ol> 
<p>局部变量无法共享和长久的保存，而全局变量可能造成变量污染，其中上述第二种作用可以使得我们既可以长久保存变量又不会造成全局污染，但是使用闭包有两点需要注意几点：</p> 
<ol><li> <p><strong>闭包无法改变外部函数局部变量指向的内存地址</strong>，如下所示：</p> <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">outfun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  
	x <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">def</span> <span class="token function">infun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    	x <span class="token operator">=</span> <span class="token number">1</span>
    	<span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 打印1</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 打印0</span>
	infun<span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 打印0</span>

outfun<span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre> <p>上述函数打印结果为010，很多博客将这一特性描述为<strong>闭包无法改变外部函数的局部变量</strong>，但这一描述是不准确的，如果x为可变对象，上述代码就会表现为闭包改变了外部函数的局部变量的值。</p> </li><li> <p><strong>返回闭包时，返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong>，这条规则可以参考上述3.1节第3点展示的例子，具体原因是因为循环无法形成作用域，对应的循环变量无法保存，因此会造成与预期不符的结果。</p> </li><li> <p><strong>可以通过closure属性判断一个函数是否是闭包</strong>。</p> </li></ol> 
<h4><a id="33__179"></a>3.3 装饰器</h4> 
<ol><li> <p><strong>装饰器的定义和作用</strong>：装饰器本质上是一个Python函数，<strong>装饰器的返回值也是一个函数对象</strong>。它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，基于此可以<strong>抽离出大量与函数功能本身无关的雷同代码并继续重用</strong>，例如插入日志、性能测试、事务处理、缓存、权限校验等。</p> </li><li> <p><strong>装饰器的实现</strong>：简单装饰器实现如下：</p> <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">use_logging</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>	
    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        logging<span class="token punctuation">.</span>warn<span class="token punctuation">(</span><span class="token string">"%s is running"</span> <span class="token operator">%</span> func<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span>
        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 把 foo 当做参数传递进来时，执行func()就相当于执行foo()</span>
    <span class="token keyword">return</span> wrapper

<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'i am foo'</span><span class="token punctuation">)</span>

foo <span class="token operator">=</span> use_logging<span class="token punctuation">(</span>foo<span class="token punctuation">)</span>  <span class="token comment"># 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于  foo = wrapper</span>
foo<span class="token punctuation">(</span><span class="token punctuation">)</span>    
</code></pre> <p>基于@语法糖的实现如下：</p> <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">use_logging</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>	
    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        logging<span class="token punctuation">.</span>warn<span class="token punctuation">(</span><span class="token string">"%s is running"</span> <span class="token operator">%</span> func<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span>
        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> wrapper

<span class="token decorator annotation punctuation">@use_logging</span>
<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i am foo"</span><span class="token punctuation">)</span>

foo<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <p>带参数的装饰器实现如下：</p> <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">use_logging</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> level <span class="token operator">==</span> <span class="token string">"warn"</span><span class="token punctuation">:</span>
                logging<span class="token punctuation">.</span>warn<span class="token punctuation">(</span><span class="token string">"%s is running"</span> <span class="token operator">%</span> func<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> level <span class="token operator">==</span> <span class="token string">"info"</span><span class="token punctuation">:</span>
                logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%s is running"</span> <span class="token operator">%</span> func<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span>
            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
        <span class="token keyword">return</span> wrapper
    <span class="token keyword">return</span> decorator

<span class="token decorator annotation punctuation">@use_logging</span><span class="token punctuation">(</span>level<span class="token operator">=</span><span class="token string">"warn"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i am %s"</span> <span class="token operator">%</span> name<span class="token punctuation">)</span>

foo<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <p>还有一个与装饰器相关的<strong>库函数functools.wraps</strong>，其作用主要是将原函数f(x)的元信息拷贝到装饰器的func函数中，使得装饰器中的func函数和原函数f(x)一样的元信息：</p> <pre><code class="prism language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps
<span class="token keyword">def</span> <span class="token function">logged</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token decorator annotation punctuation">@wraps</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">with_logging</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span> func<span class="token punctuation">.</span>__name__      <span class="token comment"># 输出 'f'</span>
        <span class="token keyword">print</span> func<span class="token punctuation">.</span>__doc__       <span class="token comment"># 输出 'does some math'</span>
        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
    <span class="token keyword">return</span> with_logging

<span class="token decorator annotation punctuation">@logged</span>
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token triple-quoted-string string">"""does some math"""</span>
   <span class="token keyword">return</span> x <span class="token operator">+</span> x <span class="token operator">*</span> x
</code></pre> <p>当我们理解闭包后，会发现装饰器的实现并不难理解。</p> </li></ol> 
<h3><a id="4__247"></a>4. 迭代器与生成器</h3> 
<h4><a id="41__249"></a>4.1 惰性计算</h4> 
<ol><li>惰性计算又称为惰性求值（Lazy Evaluation），是一个计算机编程中的概念，它的<strong>目的是要最小化计算机要做的工作</strong>，尽可能延迟表达式求值。</li><li>延迟求值特别用<strong>于函数式编程语言</strong>中。在使用延迟求值的时候，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。</li><li><strong>惰性计算的最重要的好处是它可以构造一个无限的数据类型</strong>。</li></ol> 
<h4><a id="41__254"></a>4.1 迭代器</h4> 
<ol><li> <p><strong>迭代器的作用</strong>：迭代器可以像列别一样迭代获取其中每一个元素，但是它不像列表将所有元素一次性加载到内存，而是以一种<strong>延迟计算方式返回元素</strong>。当我们获取的元素数据量特别大时，列表会占用几百兆的内存，而迭代器只需要几十个字节的空间，这就是迭代器的作用。</p> </li><li> <p>将一个类作为迭代器需要实现<strong>两个方法 __ iter__() 与 __ next__()</strong>：<br> __ iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __ next__() 方法并通过 StopIteration 异常标识迭代的完成。<strong>可迭代对象需要提供 <strong>iter</strong>()方法，否则不能被 for 语句处理。</strong><br> __ next__() 方法会返回下一个迭代器对象。<br> 如下是一个斐波拉契数列的迭代器：</p> <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Fibonacci</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> all_num<span class="token punctuation">)</span><span class="token punctuation">:</span>
		self<span class="token punctuation">.</span>all_num <span class="token operator">=</span> all_num
		self<span class="token punctuation">.</span>current_num <span class="token operator">=</span> <span class="token number">0</span>
		a <span class="token operator">=</span> <span class="token number">0</span>
		b <span class="token operator">=</span> <span class="token number">1</span>
	
	<span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> self

	<span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">if</span> self<span class="token punctuation">.</span>current_num <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>all_num<span class="token punctuation">:</span>
			result <span class="token operator">=</span> self<span class="token punctuation">.</span>a
			self<span class="token punctuation">.</span>a<span class="token punctuation">,</span> self<span class="token punctuation">.</span>b <span class="token operator">=</span> self<span class="token punctuation">.</span>b<span class="token punctuation">,</span> self<span class="token punctuation">.</span>a <span class="token operator">+</span> self<span class="token punctuation">.</span>b
			self<span class="token punctuation">.</span>current_num <span class="token operator">+=</span> <span class="token number">1</span>
			<span class="token keyword">return</span> result
		<span class="token keyword">else</span><span class="token punctuation">:</span>
			<span class="token keyword">raise</span> StopIteration

fibo <span class="token operator">=</span> Fibonacci<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> fibo<span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre> </li></ol> 
<h4><a id="42__286"></a>4.2 生成器</h4> 
<p>生成器通常两种方式：生成器表达式（generator expression）和生成器函数（generator function）。</p> 
<ol><li> <p><strong>生成器表达式</strong>：在生成列表和字典时，可以通过推导表达式完成。只要把<strong>推导表达式中的中括号换成小括号</strong>就成了生成器表达式，如下</p> <pre><code class="prism language-python"><span class="token comment"># 列表：</span>
a <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">*</span> x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment"># 0,1,4</span>

<span class="token comment"># 生成器表达式：</span>
b <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 0</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 4</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 触发 StopIteration 异常</span>

<span class="token comment"># 通常我们使用时不会调用next()方法，而是使用for循环</span>
c <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> c<span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre> </li><li> <p><strong>生成器函数</strong>：如果一个函数定义中包含 <strong>yield 表达式</strong>，那么这个函数就不再是一个普通函数，而是一个生成器函数。<strong>yield 语句类似 return 会返回一个值</strong>，但它会记住这个返回的位置，<strong>下次 next() 迭代就从这个位置下一行继续执行</strong>。通过生成器表达式来进行表达式推到是有局限的，<strong>复杂的处理需要生成器函数完成</strong>。如下斐波拉契数列的生成器：</p> <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">yield</span> a
        a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b

fibo <span class="token operator">=</span> Fibonacci<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> fibo <span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token comment"># 0 1 1 2 3 </span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>fibo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 输出&lt;class 'function'&gt;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>Fibonacci<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 输出&lt;class 'generator'&gt;</span>
</code></pre> <p>从这里我们可以看出：</p> 
  <ol><li>生成器函数和相同功能相比的迭代器要简洁不少；</li><li>生成器函数并不是生成器，其运行返回后的结果才是生成器；</li></ol> </li><li> <p>生成器的本质：生成器表达式和生成器函数产生生成器时，会自动生成名为 __ iter__ 和 __ next__ 的方法。也就是说<strong>生成器是一种迭代器</strong>。对于迭代器和生成器的区别，可以从下图进行理解：<br> <img src="https://images2.imgbox.com/37/25/7A5ALIk7_o.png" alt="在这里插入图片描述" width="500"></p> </li></ol> 
<h3><a id="5__332"></a>5. 正则表达式</h3> 
<p><strong>正则表达式并不是Python的一部分</strong>。正则表达式是用于处理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能十分强大。得益于这一点，在提供了正则表达式的语言里，正则表达式的语法都是一样的，区别只在于不同的编程语言实现支持的语法数量不同。<strong>这里我们对其实现原理我们不做深究，主要以思维导图的方式整理了下正则表达式的各种语法和函数。</strong></p> 
<h4><a id="51__334"></a>5.1 元字符和语法</h4> 
<p>如下列出来Python支持的正则表达式元字符和语法<br> <img src="https://images2.imgbox.com/e3/89/YLKvy3v2_o.jpg" alt="请添加图片描述" width="800"></p> 
<h4><a id="52_re_337"></a>5.2 re模块函数</h4> 
<p>Python通过re模块提供对正则表达式的支持，如下列出来re模块函数：<br> <img src="https://images2.imgbox.com/a6/b6/gRMi6qdm_o.jpg" alt="请添加图片描述" width="800"></p> 
<h4><a id="53_re_340"></a>5.3 re模块变量</h4> 
<p>re模块中还提供了9个模块常量用于标记不同的功能细节，如下：<br> <img src="https://images2.imgbox.com/4c/96/Xe7tMV7F_o.jpg" alt="请添加图片描述" width="650"></p> 
<h3><a id="6_Python__init____new___343"></a>6. Python中的魔法方法类别有哪些？__init__和__new__的区别是什么？</h3> 
<h4><a id="61__344"></a>6.1 魔法方法</h4> 
<ol><li>魔法方法(Magic Methods)是Python中的内置函数，一般以双下划线开头和结尾，例如__init__、__del__等。之所以称之为魔法方法，是因为这些方法会在进行特定的操作时会自动被调用。</li><li>在Python中，可以<strong>通过dir()方法来查看某个对象的所有方法和属性</strong>，其中双下划线开头和结尾的就是该对象的魔法方法。以字符串为例：<pre><code class="prism language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">dir</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'__add__'</span><span class="token punctuation">,</span> <span class="token string">'__class__'</span><span class="token punctuation">,</span> <span class="token string">'__contains__'</span><span class="token punctuation">,</span> <span class="token string">'__delattr__'</span><span class="token punctuation">,</span> <span class="token string">'__doc__'</span><span class="token punctuation">,</span> <span class="token string">'__eq__'</span><span class="token punctuation">,</span> <span class="token string">'__format__'</span><span class="token punctuation">,</span> <span class="token string">'__ge__'</span><span class="token punctuation">,</span> <span class="token string">'__getattribute__'</span><span class="token punctuation">,</span>
<span class="token string">'__getitem__'</span><span class="token punctuation">,</span> <span class="token string">'__getnewargs__'</span><span class="token punctuation">,</span> <span class="token string">'__getslice__'</span><span class="token punctuation">,</span> <span class="token string">'__gt__'</span><span class="token punctuation">,</span> <span class="token string">'__hash__'</span><span class="token punctuation">,</span> <span class="token string">'__init__'</span><span class="token punctuation">,</span> <span class="token string">'__le__'</span><span class="token punctuation">,</span> <span class="token string">'__len__'</span><span class="token punctuation">,</span> <span class="token string">'__lt__'</span><span class="token punctuation">,</span> '__mo
d__<span class="token string">', '</span>__mul__<span class="token string">', '</span>__ne__<span class="token string">', '</span>__new__<span class="token string">', '</span>__reduce__<span class="token string">', '</span>__reduce_ex__<span class="token string">', '</span>__repr__<span class="token string">', '</span>__rmod__<span class="token string">', '</span>__rmul__<span class="token string">', '</span>__setattr__'<span class="token punctuation">,</span>
<span class="token string">'__sizeof__'</span><span class="token punctuation">,</span> <span class="token string">'__str__'</span><span class="token punctuation">,</span> <span class="token string">'__subclasshook__'</span><span class="token punctuation">,</span> <span class="token string">'_formatter_field_name_split'</span><span class="token punctuation">,</span> <span class="token string">'_formatter_parser'</span><span class="token punctuation">,</span> <span class="token string">'capitalize'</span><span class="token punctuation">,</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
<span class="token string">'count'</span><span class="token punctuation">,</span> <span class="token string">'decode'</span><span class="token punctuation">,</span> <span class="token string">'encode'</span><span class="token punctuation">,</span> <span class="token string">'endswith'</span><span class="token punctuation">,</span> <span class="token string">'expandtabs'</span><span class="token punctuation">,</span> <span class="token string">'find'</span><span class="token punctuation">,</span> <span class="token string">'format'</span><span class="token punctuation">,</span> <span class="token string">'index'</span><span class="token punctuation">,</span> <span class="token string">'isalnum'</span><span class="token punctuation">,</span> <span class="token string">'isalpha'</span><span class="token punctuation">,</span> <span class="token string">'isdigit'</span><span class="token punctuation">,</span> 'isl
owe<span class="token string">r', '</span>isspace<span class="token string">', '</span>istitle<span class="token string">', '</span>isuppe<span class="token string">r', '</span>join<span class="token string">', '</span>ljust<span class="token string">', '</span>lowe<span class="token string">r', '</span>lstrip<span class="token string">', '</span>partition<span class="token string">', '</span>replace<span class="token string">', '</span>rfind<span class="token string">', '</span>rindex<span class="token string">', '</span>
rjust<span class="token string">', '</span>rpartition<span class="token string">', '</span>rsplit<span class="token string">', '</span>rstrip<span class="token string">', '</span>split<span class="token string">', '</span>splitlines<span class="token string">', '</span>startswith<span class="token string">', '</span>strip<span class="token string">', '</span>swapcase<span class="token string">', '</span>title<span class="token string">', '</span>translate'
<span class="token punctuation">,</span> <span class="token string">'upper'</span><span class="token punctuation">,</span> <span class="token string">'zfill'</span><span class="token punctuation">]</span>
</code></pre> 其中有一些我们比较熟悉的例如：__ getattribute__定义当该类的属性被访问时的行为，__ getitem__定义获取容器中指定元素的行为等，具体用到的时候我们在去了解其作用。</li></ol> 
<h4><a id="62____init_____new___360"></a>6.2 __ init__和__ new__的区别</h4> 
<p>在所有魔法方法中，__ init__和__ new__可能是最重要的一对魔法方法了，其区别如下：</p> 
<ol><li>__ new__()方法用于创建实例，<strong>类实例化之前会首先调用</strong>，它是<strong>class的方法</strong>，是个静态方法。而__ init__()方法用户初始化实例，该方法用<strong>在实例对象创建后被调用</strong>，它是实例<strong>对象的方法</strong>，用于设置类实例对象的一些初始值。</li><li>如果类中同时出现了__ init__()方法和__ new__()方法，则先调用__ new__()方法后调用__ init__()方法。<strong>__ new__()方法是创建实例的第一步，执行完了需要返回创建的类的实例，否则则报错，无法执行__ init__()方法</strong>。其中，__ init__()方法将不返回任何信息。</li><li>如下是基于__ init_()方法实现的单例类：<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Mycls</span><span class="token punctuation">:</span>
        _instance <span class="token operator">=</span> <span class="token boolean">None</span>
       <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
             <span class="token comment"># 判断该类的属性是否为空；对第一个对象没有被创建，我们应该调用父类的方法，为第一个对象分配空间</span>
             <span class="token keyword">if</span> cls<span class="token punctuation">.</span>_instance <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
             <span class="token comment"># 把类属性中保存的对象引用返回给python的解释器</span>
                      cls<span class="token punctuation">.</span>_instance <span class="token operator">=</span> <span class="token builtin">object</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>
                      <span class="token keyword">return</span> cls<span class="token punctuation">.</span>_instance
            <span class="token comment"># 如果cls._instance不为None,直接返回已经实例化了的实例对象</span>
              <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> cls<span class="token punctuation">.</span>_instance
        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'init'</span><span class="token punctuation">)</span>
my1<span class="token operator">=</span>Mycls<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>my1<span class="token punctuation">)</span>
my2<span class="token operator">=</span>Mycls<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>my2<span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>
init
<span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Mycls <span class="token builtin">object</span> at <span class="token number">0x000000406E471148</span><span class="token operator">&gt;</span>
Init
<span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Mycls <span class="token builtin">object</span> at <span class="token number">0x000000406E471148</span><span class="token operator">&gt;</span>
</code></pre> </li></ol> 
<h3><a id="7_MRO_391"></a>7. 多重继承中的MRO机制</h3> 
<h4><a id="71__392"></a>7.1 新式类和旧式类的区别</h4> 
<ol><li>在早期版本的 Python 中，所有类并没有一个共同的祖先 object，如果定义一个类，但没有显式指定其祖先，那么就被解释为<strong>旧式类</strong></li><li>Python 2.x 版本中，为了向后兼容保留了旧式类。该版本中的 新式类必须显式继承 object 或者其他<strong>新式类</strong></li><li>Python 3.x 版本中，不再保留旧式类的概念。因此，没有继承任何其他类的类都隐式地继承自object</li></ol> 
<h4><a id="72__397"></a>7.2 多重继承带来的问题</h4> 
<ol><li> <p>多继承中最经典的问题就是菱形继承会带来的子类重复调用问题，如下代码</p> <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'A.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        A<span class="token punctuation">.</span>fun<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'B.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        A<span class="token punctuation">.</span>fun<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>B <span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        B<span class="token punctuation">.</span>fun<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        C<span class="token punctuation">.</span>fun<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'D.fun'</span><span class="token punctuation">)</span>

D<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>
A<span class="token punctuation">.</span>fun　
B<span class="token punctuation">.</span>fun　
A<span class="token punctuation">.</span>fun　
C<span class="token punctuation">.</span>fun　
D<span class="token punctuation">.</span>fun　
</code></pre> <p>可以看到，<strong>A类被初始化了两次</strong>，会造成资源浪费。</p> </li><li> <p>我们可以通过super()函数解决上述问题，如下代码：</p> <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'A.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>B <span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'B.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>C <span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>B <span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>D <span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'D.fun'</span><span class="token punctuation">)</span>

D<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>
A<span class="token punctuation">.</span>fun
C<span class="token punctuation">.</span>fun
B<span class="token punctuation">.</span>fun
D<span class="token punctuation">.</span>fun
</code></pre> <p>从上述结果看到，使用super()函数后A类仅初始化了一次，那么为什么输出A-&gt;C-&gt;B-&gt;D以及为什么super()可以避免菱形继承问题呢？下面进一步解释</p> </li></ol> 
<h4><a id="73_MRO_461"></a>7.3 MRO机制</h4> 
<ol><li>MRO全称为Method Resolution Order，在每个类声明之后，Python都会自动为创建一个名为“<strong>mro</strong>”的内置属性，这个属性就是Python的MRO机制生成的，该属性是一个tuple，<strong>定义的是该类的方法解析顺序（继承顺序），当用super调用父类的方法时，会按照__mro__属性中的元素顺序去挨个查找方法</strong>。我们可以通过“类名.<strong>mro</strong>”或“类名.mro()”来查看上面代码中D类的__mro__属性值：</li><li>Python 发展至今，经历了以下 3 种 MRO 算法：<br> （1）从左往右，采用深度优先搜索（DFS）的算法，称为旧式类的 MRO；<br> （2）自 Python 2.2 版本开始，新式类在采用深度优先搜索算法的基础上，对其做了优化；<br> （3）自 Python 2.3 版本，对新式类采用了 <strong>C3 算法</strong>。由于 Python 3.x 仅支持新式类，所以该版本只使用 <strong>C3 算法</strong>。</li><li><strong>C3算法流程</strong>如下图所示：<br> <img src="https://images2.imgbox.com/d7/a6/Sdu5UenN_o.png" alt="在这里插入图片描述" width="300"><br> （1）首先将入度（指向该节点的箭头数量）为零的节点放入列表，并将F节点及与F节点有关的箭头从上图树中删除；<br> （2）继续找入度为0的节点，找到D和E，左侧优先，故而现将D放入列表，并从上图树中删除D，这是列表中就有了F、D。<br> （3）继续找入度为0的节点，有A和E满足，左侧优先，所以是A，将A从上图中取出放入列表，列表中顺序为F、D、E；<br> （4）接下来入度为0的节点只剩下E，取出E放入列表；<br> （5）只剩下B和C节点，且入度都为0，但左侧优先，二先将B放入列表，然后才是后才是C；<br> （6）不过别忘了，新式类Python所有类都有一个共同的父类，那就是object类，所以，最好还会把object放入列表末尾。<br> 最终生成列表中元素顺序为：F-&gt;D-&gt;A-&gt;E-&gt;B-&gt;C-&gt;object。</li></ol> 
<h4><a id="74_super_477"></a>7.4 super()作用</h4> 
<ol><li>super是一个类，实例化之后得到的是一个代理的对象，而不是得到了父类，并且我们使用这个代理对象来调用父类或者兄弟类的方法。</li><li>super(type , obj)，这个方式要传入两个常数，第一个参数type必须是一个类名，<strong>定义在__mro__数组中的那个位置开始找</strong>，第二个参数obj是一个该类的实例化对象，<strong>定义的是用哪个类的__mro__元素</strong>。如下：<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'A.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'B.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'D.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">E</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'E.fun'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">(</span>D<span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'F.fun'</span><span class="token punctuation">)</span>

<span class="token comment"># 保持obj实例不变，尝试不同的type</span>
<span class="token builtin">super</span><span class="token punctuation">(</span>E <span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 输出结果：B.fun</span>
<span class="token builtin">super</span><span class="token punctuation">(</span>D <span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 输出结果：A.fun</span>
<span class="token builtin">super</span><span class="token punctuation">(</span>F <span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 输出结果：D.fun</span>

<span class="token comment"># 保持type不变，obj尝试不同的实例</span>
<span class="token builtin">super</span><span class="token punctuation">(</span>B <span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 输出结果：C.fun</span>
<span class="token builtin">super</span><span class="token punctuation">(</span>B <span class="token punctuation">,</span> E<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 输出结果：C.fun</span>
<span class="token builtin">super</span><span class="token punctuation">(</span>B <span class="token punctuation">,</span> B<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 这是错误的，会报错</span>
</code></pre> 上述代码__mro__的顺序：F-&gt;D-&gt;A-&gt;E-&gt;B-&gt;C-&gt;object，我们可以发现<strong>调用的都是type对应的类在__mro__顺序中的下一个类的fun方法</strong>。所以，<strong>我们可以通过type参数来指定调用父类的范围，通过obj参数指定的是用那个类的__mro__属性。</strong></li><li><strong>super()事实上是懒人版的super(type , obj)</strong>，这种方式只能用在类体内部，Python会自动把两个参数填充上，type指代当前类，obj指导当前类的实例对象，<strong>相当于super(<strong>class</strong> , self)</strong>。</li></ol> 
<h3><a id="8_Python_517"></a>8. Python中为什么没有重载？</h3> 
<h4><a id="81__518"></a>8.1 为什么没有重载</h4> 
<ol><li>函数重载主要是为了解决两个问题：对于<strong>功能相同的函数</strong>做到<strong>可变参数类型</strong>和<strong>可变参数个数</strong></li><li>对于<strong>可变参数类型</strong>问题，Python根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</li><li>对于<strong>可变参数个数</strong>问题，Python可以使用缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。Python中还有一种特殊的函数参数，即可变参数。可变参数可以接受任意数量的参数，并将它们存储为一个元组或列表。</li></ol> 
<h4><a id="82_Python_522"></a>8.2 Python函数可变参数</h4> 
<p>我们经常会在代码中看到*args、**kwargs，他们都被称为可变参数（任意参数）：</p> 
<ol><li> <p>作为函数定义时：<br> （1）*参数收集所有未匹配的位置参数组成一个tuple对象，局部变量args指向此tuple对象；<br> （2）**参数收集所有未匹配的关键字参数组成一个dict对象，局部变量kwargs指向此dict对象；<br> 例如</p> <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">temp</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
</code></pre> </li><li> <p>作为函数调用时：<br> （1）*参数用于解包tuple对象的每个元素，作为一个一个的位置参数传入到函数中；<br> （2）**参数用于解包dict对象的每个元素，作为一个一个的关键字参数传入到函数中；<br> 例如：</p> <pre><code class="prism language-python">my_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span><span class="token string">"yuan"</span><span class="token punctuation">,</span><span class="token string">"wai"</span><span class="token punctuation">)</span>
 
temp<span class="token punctuation">(</span><span class="token operator">*</span>my_tuple<span class="token punctuation">)</span>
<span class="token comment">#---等同于---#</span>
temp<span class="token punctuation">(</span><span class="token string">"wangyuan"</span><span class="token punctuation">,</span><span class="token string">"yuan"</span><span class="token punctuation">,</span><span class="token string">"wai"</span><span class="token punctuation">)</span>


my_dict <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"name"</span><span class="token punctuation">:</span><span class="token string">"wangyuanwai"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">}</span>
 
temp<span class="token punctuation">(</span><span class="token operator">**</span>my_dict<span class="token punctuation">)</span>
<span class="token comment">#----等同于----#</span>
temp<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"wangyuanwai"</span><span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span>
</code></pre> </li></ol> 
<h3><a id="9_Python_552"></a>9. Python内建模块</h3> 
<p>Python提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作Batteries Included。用Python开发，许多功能不必从零编写，直接使用现成的即可，因此作为开发者熟练掌握这些内建模块对于开发效率肯定是有帮助的。这里总结几种比较常用的模块：</p> 
<h4><a id="91_collections_554"></a>9.1 collections模块的用法</h4> 
<p><strong>collections是集成专用容器的模块</strong>，作为对通用容器 dict、list、set 和 tuple 的补充。下面仅对常用方法进行整理。<br> <img src="https://images2.imgbox.com/29/07/qsl3j9af_o.jpg" alt="请添加图片描述" width="700"></p> 
<h4><a id="92_functools_557"></a>9.2 functools模块的用法</h4> 
<p><strong>functools是集成特殊装饰器的模块</strong>，基于这些装饰器通常可以用来节省内存或者简化函数。下面仅对常用方法进行整理：<br> <img src="https://images2.imgbox.com/89/42/82WrtdkG_o.jpg" alt="请添加图片描述" width="800"></p> 
<h4><a id="93_itertools_560"></a>9.3 itertools模块的用法</h4> 
<p><strong>itertools是集成操作迭代器方法的模块</strong>，通过这些方法可以使得迭代更加高效，下面仅对常用方法进行整理：<br> <img src="https://images2.imgbox.com/26/1d/7JqU4It1_o.jpg" alt="请添加图片描述" width="800"></p> 
<h3><a id="10__565"></a>10 协程</h3> 
<h4><a id="101_GIL_566"></a>10.1 GIL的概念</h4> 
<ol><li>GIL的全称是Global Interpreter Lock(全局解释器锁)，简单来说，是一个互斥锁，它只允许一个线程拥有Python解释器的控制权。这就意味着：<strong>同一时间，只能有一个线程在执行的状态</strong>。</li><li>CPU密集型代码(各种循环处理、计数等等)，在这种情况下，单线程的操作计数很快就会达到阈值，然后触发GIL的释放与再竞争，多个线程来回切换当然是需要消耗资源的，所以<strong>Python下的多线程对CPU密集型代码并不友好</strong>。</li><li>IO密集型代码(文件处理、网络爬虫等)，单线程下有的IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率。所以<strong>Python的多线程对IO密集型代码比较友好</strong>。</li><li><strong>多核多线程比单核多线程更差</strong>，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸，导致效率更低。</li><li>Python下想要充分利用<strong>多核CPU</strong>，就用<strong>多进程</strong>，想要充分利用<strong>单核CPU</strong>，就用<strong>协程</strong></li></ol> 
<h4><a id="102__572"></a>10.2 协程的概念</h4> 
<p>在 Python 中，协程（Coroutine）是一种轻量级的并发编程方式，可以通过协作式多任务来实现高效的并发执行，协程相比于线程的优势如下：</p> 
<ol><li>轻量级：协程的上下文切换成本很小，可以在单线程内并发执行大量的协程。</li><li>低延迟：协程的执行过程中，没有线程切换的开销，也没有加锁解锁的开销，可以更快地响应外部事件。</li><li>高效性：协程的代码通常比多线程和多进程的代码更加简洁和可读，维护成本更低。</li></ol> 
<p>在 Python 3.4 之前，协程通常使用 yield 关键字来实现，称为“<strong>生成器协程</strong>”。在 Python 3.4 引入了 asyncio 模块后，可以使用 async/await 关键字来定义协程函数，称为“<strong>原生协程</strong>”。这里我们仅介绍下<strong>原生协程</strong>的用法：</p> 
<p>下面给出一个简单的原生协程示例，其中包含一个 async 关键字修饰的协程函数 coroutine 和一个简单的异步 I/O 操作：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Coroutine started'</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Coroutine finished'</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Main started'</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Main finished'</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>
Main started
Coroutine started
Coroutine finished
Main finished
</code></pre> 
<p>在上面的代码中，使用 <strong>async 关键字定义了一个原生协程函数</strong> ，并在其中使用 <strong>await 关键字来暂停函数的执行，等待异步 I/O 操作的完成</strong>。通过这种方式，可以在原生协程中编写异步并发代码，从而提高代码的性能和效率。（<strong>为什么要用asyncio.sleep, 而不用time.sleep呢?</strong> 因为await后面一个要跟一个异步函数的实例化对象，可是time.sleep并不是异步函数，也就不支持协程间切换，就没法实现并发，只能串行。）</p> 
<p>以上是在两个异步函数中实现了切换，而如果一个普通的线程要能同时处理多个异步函数, 就要创建一个<strong>事件循环</strong>：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>new_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<ol><li>在事件循环中, 会执行所有异步函数；</li><li>但同一时间, 只有一个任务在执行；</li><li>当一个任务中执行await后, 此任务被挂起, 事件循环执行下一个任务；</li></ol> 
<p>下面通过一个简单的例子来说明事件循环的用法，平常我们上课时通常是一边听一边记笔记，</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> time

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">listening</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""听课"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'start listening'</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"listening..."</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"listening..."</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'end listening'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">"finish listening"</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">taking_notes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""记笔记"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"start taking notes"</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"taking notes..."</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"taking notes..."</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"end taking notes"</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">"finish taking notes"</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"start main"</span><span class="token punctuation">)</span>
    future1 <span class="token operator">=</span> listening<span class="token punctuation">(</span><span class="token punctuation">)</span>
    future2 <span class="token operator">=</span> taking_notes<span class="token punctuation">(</span><span class="token punctuation">)</span>
    ret1 <span class="token operator">=</span> <span class="token keyword">await</span> future1
    ret2 <span class="token operator">=</span> <span class="token keyword">await</span> future2
    <span class="token keyword">print</span><span class="token punctuation">(</span>ret1<span class="token punctuation">,</span> ret2<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"end main"</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    t1 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    t2 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cost:'</span><span class="token punctuation">,</span> t2<span class="token operator">-</span>t1<span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>
start main
start listening
listening<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
listening<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
end listening
start taking notes
taking notes<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
taking notes<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
end taking notes
finish listening finish taking notes
end main
cost<span class="token punctuation">:</span> <span class="token number">6.007081508636475</span>
</code></pre> 
<p>上述执行并不符合预期，原因是用await确实会切换协程, 但你事先没有告诉事件循环有哪些协程, 它不知道切换到哪个协程, 所以事件循环就会按顺序坚持执行完，但是当我们使用用asyncio.gather()补充改信息后结果就符合预期了：</p> 
<pre><code class="prism language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"start main"</span><span class="token punctuation">)</span>
    future1 <span class="token operator">=</span> listening<span class="token punctuation">(</span><span class="token punctuation">)</span>
    future2 <span class="token operator">=</span> taking_notes<span class="token punctuation">(</span><span class="token punctuation">)</span>
    ret1<span class="token punctuation">,</span> ret2 <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>future1<span class="token punctuation">,</span> future2<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>ret1<span class="token punctuation">,</span> ret2<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"end main"</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>
start main
start listening
start taking notes
listening<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
taking notes<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
listening<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
taking notes<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
end listening
end taking notes
finish listening finish taking notes
end main
cost<span class="token punctuation">:</span> <span class="token number">3.003592014312744</span>
</code></pre> 
<p>通过上述例子我们应该了解了协程的大致使用方法，协程的更细节的用法后续有机会实际使用后再进行补充</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6459e6190bf6b37c5613d3f8a058d402/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于ELF文件格式的理解与读取</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ddbcda9ca5a9dbb7c16875550b899bbf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Citespace、vosviewer、R语言的文献计量学可视化分析技术及全流程文献可视化SCI论文高效写作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>