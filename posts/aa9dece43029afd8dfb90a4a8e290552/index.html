<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring 框架(声明式)事务学习总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring 框架(声明式)事务学习总结" />
<meta property="og:description" content="说明 ：声明式事务部分：参考网上课程，自己写的总结，如有侵权，联系删除。
目录
Spring事务_事务简介
Spring事务_Spring事务管理方案
Spring事务_Spring事务管理器
Spring事务_事务控制的API
PlatformTransactionManager接口
Spring事务_事务的相关配置
Spring事务_事务的传播行为 Spring事务_事务的隔离级别
Spring事务_注解配置声明式事务
Spring事务_事务简介 事务：不可分割的原子操作。即一系列的操作要么同时成功，要么 同时失败。
开发过程中，事务管理一般在service层，service层中可能会操作多次数据库，这些操作是不可分割的。否则当程序报错时，可能会造成数据异常。
如：张三给李四转账时，需要两次操作数据库：张三存款减少、李 四存款增加。如果这两次数据库操作间出现异常，则会造成数据错误。
准备数据库 CREATE DATABASE `student` ; USE `spring`; DROP TABLE IF EXISTS `account`; CREATE TABLE `account` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) DEFAULT NULL, `balance` double DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; insert into `account`(`id`,`username`,`balance`) values (1,&#39;张三&#39;,1000),(2,&#39;李四&#39;,1000); 创建maven项目，引入依赖 &lt;dependencies&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/aa9dece43029afd8dfb90a4a8e290552/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-22T10:06:16+08:00" />
<meta property="article:modified_time" content="2022-07-22T10:06:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring 框架(声明式)事务学习总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 说明 ：声明式事务部分：参考网上课程，自己写的总结，如有侵权，联系删除。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B" rel="nofollow">Spring事务_事务简介</a></p> 
<p id="Spring%E4%BA%8B%E5%8A%A1_Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88-toc" style="margin-left:0px;"><a href="#Spring%E4%BA%8B%E5%8A%A1_Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88" rel="nofollow">Spring事务_Spring事务管理方案</a></p> 
<p id="%C2%A0Spring%E4%BA%8B%E5%8A%A1_Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8-toc" style="margin-left:0px;"><a href="#%C2%A0Spring%E4%BA%8B%E5%8A%A1_Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8" rel="nofollow"> Spring事务_Spring事务管理器</a></p> 
<p id="Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E7%9A%84API-toc" style="margin-left:0px;"><a href="#Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E7%9A%84API" rel="nofollow">Spring事务_事务控制的API</a></p> 
<p id="PlatformTransactionManager%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#PlatformTransactionManager%E6%8E%A5%E5%8F%A3" rel="nofollow">PlatformTransactionManager接口</a></p> 
<p id="Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE" rel="nofollow">Spring事务_事务的相关配置</a></p> 
<p id="Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%C2%A0-toc" style="margin-left:0px;"><a href="#Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%C2%A0" rel="nofollow">Spring事务_事务的传播行为 </a></p> 
<p id="Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-toc" style="margin-left:0px;"><a href="#Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" rel="nofollow">Spring事务_事务的隔离级别</a></p> 
<p id="%C2%A0Spring%E4%BA%8B%E5%8A%A1_%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-toc" style="margin-left:0px;"><a href="#%C2%A0Spring%E4%BA%8B%E5%8A%A1_%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1" rel="nofollow"> Spring事务_注解配置声明式事务</a></p> 
<hr id="hr-toc"> 
<h2 id="Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B">Spring事务_事务简介</h2> 
<p><strong>事务</strong>：不可分割的原子操作。即一系列的操作要么同时成功，要么 同时失败。</p> 
<p>开发过程中，事务管理一般在service层，service层中可能会操作多次数据库，这些操作是不可分割的。<strong>否则当程序报错时，可能会造成数据异常。</strong></p> 
<p>如：张三给李四转账时，需要两次操作数据库：张三存款减少、李 四存款增加。如果这两次数据库操作间出现异常，则会造成数据错误。</p> 
<ol><li>准备数据库 <pre><code class="language-sql">CREATE DATABASE `student` ;
USE `spring`;
DROP TABLE IF EXISTS `account`;
CREATE TABLE `account` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) DEFAULT NULL,
  `balance` double DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT
CHARSET=utf8;
insert  into `account`(`id`,`username`,`balance`) values (1,'张三',1000),(2,'李四',1000);
</code></pre> </li><li>创建maven项目，引入依赖 <pre><code class="language-XML">    &lt;dependencies&gt;
        &lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.7&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mysql驱动包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.27&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--druid连接池--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.2.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--spring--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.3.21&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;5.3.13&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.3.13&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- MyBatis与Spring的整合包，该包可以让Spring创建MyBatis的对象 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- junit,如果Spring5整合junit，则junit版本至少在4.12以上 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.3.13&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> </li><li>创建配置文件 <pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans  xmlns="http://www.springframework.org/schema/beans"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;!-- 包扫描 --&gt;
    &lt;context:component-scan base-package="com.dream"&gt;&lt;/context:component-scan&gt;
    &lt;!-- 读取配置文件 classpath:db.properties --&gt;
    &lt;context:property-placeholder location="classpath:db.properties"&gt;&lt;/context:property-placeholder&gt;
    &lt;!-- 创建druid数据源对象 --&gt;
    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;
        &lt;property name="driverClassName" value="${jdbc.driverClassName}"&gt;&lt;/property&gt;
        &lt;property name="url" value="${jdbc.url}"&gt;&lt;/property&gt;
        &lt;property name="username" value="${jdbc.username}"&gt;&lt;/property&gt;
        &lt;property name="password" value="${jdbc.password}"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- Spring创建封装过的SqlSessionFactory--&gt;
    &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- Spring创建封装过的SqlSession --&gt;
    &lt;bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate"&gt;
        &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"/&gt;
    &lt;/bean&gt;
    &lt;!-- MapperScannerConfigurer 该对象可以自动扫描持久层接口，并为接口创建代理对象 --&gt;
    &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;
        &lt;!-- 配置扫描的接口包 --&gt;
        &lt;property name="basePackage" value="com.dream.dao"&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre> <pre><code class="language-XML">jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql:///student
jdbc.username=root
jdbc.password=</code></pre> </li><li>编写Java代码 <pre><code class="language-java">// 账户
public class Account {
    private int id; // 账号
    private String username; // 用户名
    private double balance; // 余额
    
    // 省略getter/setter/tostring/构造方法
}
</code></pre> <pre><code class="language-java">@Repository
public interface AccountDao {
    // 根据id查找用户
    @Select("select * from account where id = #{id}")
    Account findById(int id);
    // 修改用户
    @Update("update account set balance =#{balance} where id = #{id}")
    void update(Account account);
}
</code></pre> <pre><code class="language-java">@Service
public class AccountService {
    @Autowired
    private AccountDao accountDao;
    /**
     * 转账
     * @param id1 转出人id
     * @param id2 转入人id
     * @param price 金额
     */
    public void transfer(int id1, int id2, double price) {
        // 转出人减少余额
        Account account1 =accountDao.findById(id1);
        account1.setBalance(account1.getBalance()-price);
        accountDao.update(account1);
        int i = 1/0; // 模拟程序出错
        // 转入人增加余额
        Account account2 = accountDao.findById(id2);
        account2.setBalance(account2.getBalance()+price);
        accountDao.update(account2);
   }
}</code></pre> </li><li>测试 <pre><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:applicationContext.xml")
public class AccountServiceTest {
    @Autowired
    private AccountService accountService;
    @Test
    public void testTransfer(){
        accountService.transfer(1,2,500);
   }
}
</code></pre> <p>出错了把，第一个人的余额减少了，中途遇到除数为0的异常，结果呢后边不执行了。此时没有事务管理，所以事务处理位于业务层，即一个service方法是不能分割的，要么都成功，要么都失败，也就是事务回滚。</p> </li></ol> 
<h2 id="Spring%E4%BA%8B%E5%8A%A1_Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88">Spring事务_Spring事务管理方案</h2> 
<p>在service层手动添加事务可以解决该问题：</p> 
<pre><code class="language-java">@Service(value = "accountServic2")
public class AccountServic2 {
    @Autowired
    private AccountDao accountDao;
    @Autowired
    private SqlSessionTemplate sqlSession;
    public void transfer(int id1, int id2, double price) {
        try{
            // account1修改余额
            Account account1 = accountDao.findById(id1);
            account1.setBalance(account1.getBalance()- price);
            accountDao.update(account1);
            int i = 1/0; // 模拟转账出错
            // account2修改余额
            Account account2 = accountDao.findById(id2);
            account2.setBalance(account2.getBalance()+price);
            accountDao.update(account2);
            sqlSession.commit();
        }catch(Exception ex){
            sqlSession.rollback();
        }
    }
}</code></pre> 
<pre><code class="language-java">java.lang.UnsupportedOperationException: Manual rollback is not allowed over a Spring managed SqlSession
</code></pre> 
<p><span style="color:#fe2c24;"><strong>但在Spring管理下不允许手动提交和回滚事务。此时我们需要使用 Spring的事务管理方案，在Spring框架中提供了两种事务管理方案： </strong></span></p> 
<ol><li>编程式事务：通过编写代码实现事务管理。</li><li>声明式事务：基于AOP技术实现事务管理。</li></ol> 
<p>在Spring框架中，编程式事务管理很少使用，我们对声明式事务管 理进行详细学习。</p> 
<p>Spring的声明式事务管理在底层采用了AOP技术，其最大的优点在于无需通过编程的方式管理事务，只需要在配置文件中进行相关的 规则声明，就可以将事务规则应用到业务逻辑中。</p> 
<p>使用AOP技术为service方法添加如下通知：</p> 
<p><img alt="" class="left" height="291" src="https://images2.imgbox.com/bc/f1/ZZys484G_o.png" width="559"></p> 
<h2 id="%C2%A0Spring%E4%BA%8B%E5%8A%A1_Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"> Spring事务_Spring事务管理器</h2> 
<p>Spring依赖事务管理器进行事务管理，事务管理器即一个通知类，我们为该通知类设置切点为service层方法即可完成事务自动管理。 由于不同技术操作数据库，进行事务操作的方法不同。如：JDBC提 交事务是 connection.commit() ，MyBatis提交事务是 sqlSession.commit() ，</p> 
<p>所以 Spring提供了多个事务管理器。</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td style="width:421px;">事务管理器名称</td><td style="width:277px;">作用</td></tr><tr><td style="width:421px;"><span style="color:#4da8ee;">org.springframework.jdbc.datasource.DataSourceTransactionManager </span></td><td style="width:277px;"><span style="color:#4da8ee;">针对JDBC技术提供的事务管理器。适用于JDBC和MyBatis。 </span></td></tr><tr><td style="width:421px;">org.springframework.orm.hibernate3.HibernateTransactionManager</td><td style="width:277px;">针对于Hibernate框架提供的事务管理器。适用于Hibernate框架。</td></tr><tr><td style="width:421px;">org.springframework.orm.jpa.JpaTransactionManager</td><td style="width:277px;">针对于JPA技术提供的事务管理器。适用于JPA技术。</td></tr><tr><td style="width:421px;">org.springframework.transaction.jta.JtaTransactionManager</td><td style="width:277px;">跨越了多个事务管理源。适用在两个或者是多个不同的数据源中实现事务控制。</td></tr></tbody></table> 
<p>我们使用MyBatis操作数据库，接下来使用 DataSourceTransactionManager 进行事务管理。</p> 
<ol><li>引入依赖 <pre><code class="language-XML">&lt;!-- 事务管理 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
    &lt;version&gt;5.3.13&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- AspectJ --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.8.7&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> </li><li>在配置文件中引入约束 <pre><code class="language-XML">xmlns:aop="http://www.springframework.org/schema/aop"
xmlns:tx="http://www.springframework.org/schema/tx"


http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd</code></pre> </li><li>进行事务配置 <pre><code class="language-XML">    &lt;!-- 事务管理器 --&gt;
    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- 进行事务相关配置 --&gt;
    &lt;tx:advice id = "txAdvice"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="*"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;!-- 配置切面 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 配置切点 --&gt;
        &lt;aop:pointcut id="pointcut"
                      expression="execution(* com.dream.service.*.*(..))"/&gt;
        &lt;!-- 配置通知 --&gt;
        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:advisor&gt;
    &lt;/aop:config&gt;</code></pre> </li><li>这就可以了</li></ol> 
<h2 id="Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E7%9A%84API">Spring事务_事务控制的API</h2> 
<p>Spring进行事务控制的功能是由三个接口提供的，这三个接口是 Spring实现的，在开发中我们很少使用到，只需要了解他们的作用即可：</p> 
<h3 id="PlatformTransactionManager%E6%8E%A5%E5%8F%A3"><strong>PlatformTransactionManager接口</strong></h3> 
<p>PlatformTransactionManager是Spring提供的事务管理器接口，所 有事务管理器都实现了该接口。该接口中提供了三个事务操作方 法：</p> 
<ol><li>TransactionStatus getTransaction（TransactionDefinition definition）：获取事务状态信息。</li><li>void commit（TransactionStatus status）：事务提交</li><li>void rollback（TransactionStatus status）：事务回滚</li></ol> 
<p><strong>TransactionDefinition接口</strong></p> 
<p>TransactionDefinition是事务的定义信息对象，它有如下方法：</p> 
<ol><li>String getName()：获取事务对象名称。</li><li>int getIsolationLevel()：获取事务的隔离级别。</li><li>int getPropagationBehavior()：获取事务的传播行为。</li><li>int getTimeout()：获取事务的超时时间。</li><li>boolean isReadOnly()：获取事务是否只读。</li></ol> 
<p><strong>TransactionStatus接口</strong></p> 
<p>TransactionStatus是事务的状态接口，它描述了某一时间点上事务的状态信息。它有如下方法：</p> 
<ol><li>void flush() 刷新事务</li><li>boolean hasSavepoint() 获取是否存在保存点</li><li>boolean isCompleted() 获取事务是否完成</li><li>boolean isNewTransaction() 获取是否是新事务</li><li>boolean isRollbackOnly() 获取是否回滚</li><li>void setRollbackOnly() 设置事务回滚</li></ol> 
<h2 id="Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE">Spring事务_事务的相关配置</h2> 
<p>在 &lt;tx:advice&gt;中可以进行事务的相关配置：</p> 
<pre><code class="language-XML">&lt;tx:advice id="txAdvice"&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name="*"/&gt;
        &lt;tx:method name="find*" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre> 
<blockquote> 
 <p> &lt;tx:method /&gt;中的属性：</p> 
 <ul><li>name：指定配置的方法。 * 表示所有方法，</li><li>find* 表示所有以find开头的方法。</li><li>read-only：是否是只读事务，只读事务不存在数据的修改，数据库将会为只读事务提供一些 优化手段，会对性能有一定提升，建议在查询中开启只读事务。</li><li>timeout：指定超时时间，在限定的时间内不能完成所有操作就会抛异常。默认永不超时</li><li>rollback-for：指定某个异常事务回滚，其他异常不回滚。默认所有异常回滚。</li><li>no-rollback-for：指定某个异常不回滚，其他异常回滚。默认所有异常回滚。</li><li>propagation：事务的传播行为</li><li>isolation：事务的隔离级别</li></ul> 
</blockquote> 
<h2 id="Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%C2%A0">Spring事务_事务的传播行为 </h2> 
<p>事务传播行为是指多个含有事务的方法相互调用时，事务如何在这 些方法间传播。</p> 
<p>如果在service层的方法中调用了其他的service方法，假设每次执行 service方法都要开启事务，此时就无法保证外层方法和内层方法处 于同一个事务当中。</p> 
<pre><code class="language-java">// method1的所有方法在同一个事务中
public void method1(){
    // 此时会开启一个新事务，这就无法保证method1()
中所有的代码是在同一个事务中
    method2();
    System.out.println("method1");
}
public void method2(){
    System.out.println("method2");
}
</code></pre> 
<p>事务的传播特性就是解决这个问题的，Spring帮助我们将外层方法 和内层方法放入同一事务中。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>传播行为</td><td>介绍</td></tr><tr><td><span style="color:#4da8ee;">REQUIRED</span></td><td><span style="color:#4da8ee;">默认。支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的 选择。</span></td></tr><tr><td>SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>MANDATORY</td><td>支持当前事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>NESTED</td><td>必须在事务状态下执行，如果没有事务则新建事务，如果当前有事务则创建 一个嵌套事务</td></tr></tbody></table> 
<h2 id="Spring%E4%BA%8B%E5%8A%A1_%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">Spring事务_事务的隔离级别</h2> 
<p>事务隔离级别反映事务提交并发访问时的处理态度，隔离级别越高，数据出问题的可能性越低，但效率也会越低。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>隔离级别</td><td>脏读</td><td>不可重复读</td><td>幻读</td></tr><tr><td>READ_UNCOMMITED（<strong>读取未提交内容</strong>）</td><td><span style="color:#fe2c24;">Yes</span></td><td><span style="color:#fe2c24;">Yes</span></td><td><span style="color:#fe2c24;">Yes</span></td></tr><tr><td>READ_COMMITED（<strong>读取提交内容</strong>）</td><td>NO</td><td><span style="color:#fe2c24;">Yes</span></td><td><span style="color:#fe2c24;">Yes</span></td></tr><tr><td>REPEATABLE_READ（<strong>重复读</strong>）</td><td>NO</td><td>NO</td><td><span style="color:#fe2c24;">Yes</span></td></tr><tr><td>SERIALIZABLE（可串行化）</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table> 
<blockquote> 
 <p><strong>如果设置为DEFAULT会使用数据库的隔离级别。 </strong></p> 
 <p><strong>SqlServer , Oracle默认的事务隔离级别是READ_COMMITED </strong></p> 
 <p><span style="color:#fe2c24;"><strong>Mysql的默认隔离级别是REPEATABLE_READ</strong></span></p> 
</blockquote> 
<h2 id="%C2%A0Spring%E4%BA%8B%E5%8A%A1_%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"> Spring事务_注解配置声明式事务</h2> 
<p>Spring事务_注解配置声明式事务</p> 
<ol><li>注册事务注解驱动 <pre><code class="language-XML">&lt;!-- 注册事务注解驱动 --&gt;
&lt;tx:annotation-driven transaction-manager="transactionManager"&gt;
&lt;/tx:annotation-driven&gt;</code></pre> </li><li>在需要事务支持的方法或类上加@Transactional <pre><code class="language-java">@Service
// 作用于类上时，该类的所有public方法将都具有该
类型的事务属性
@Transactional(propagation = Propagation.REQUIRED,isolation =Isolation.DEFAULT)
public class AccountService {
    @Autowired
    private AccountDao accountDao;
    /**
     * 转账
     * @param id1 转出人id
     * @param id2 转入人id
     * @param price 金额
     */
    // 作用于方法上时，该方法将都具有该类型的事务属性
    @Transactional(propagation = Propagation.REQUIRED,isolation =Isolation.DEFAULT)
    public void transfer(int id1, int id2,double price) {
        // account1修改余额
        Account account1 = accountDao.findById(id1);
        account1.setBalance(account1.getBalance()-price);
        accountDao.update(account1);
        int i = 1/0; // 模拟转账出错
        // account2修改余额
        Account account2 = accountDao.findById(id2);
        account2.setBalance(account2.getBalance()+price);
        accountDao.update(account2);
   }
}
</code></pre> </li></ol> 
<p>spring 学习结束！！！！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/77cb5592dadeb95303b729f1d2046223/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">lotus 导出区块高度 最小快照</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e35553f5fb9943749688159ece0a80a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Monocle3</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>