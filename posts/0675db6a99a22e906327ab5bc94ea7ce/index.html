<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>异常处理的方式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="异常处理的方式" />
<meta property="og:description" content="处理异常的第一种方式： 在方法声明的位置上使用throws关键字抛出，谁调用这个方法我就抛给谁。抛给调用者来处理。 这种处理异常的态度：上报。 处理异常的第二种方式： 使用try..catch语句对异常进行捕捉。 这个异常不会上报，自己处理了。 异常抛到此处为止，不再上抛了。 注意： 只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。 另外需要注意，try语句块中的某一行出现异常，该行后面的代码不会执行。 try..catch捕捉异常之后，后续代码可以执行。 在以后的开发中，处理编译时异常，应该上报还是捕捉呢，怎么选？ 如果希望调用者来处理，选择throws上报。 其他情况使用捕捉的方式。 NullPointerException是运行时异常 import java.io.FileInputStream; import java.io.FileInputStream; import java.io.FileNotFoundException; public class ExceptionTest06 { //一般不建议在main方法上使用throws，因为这个异常如果真正发生了，一定会抛给JVM。JVM只有终止。 //异常处理机制的作用就是增强程序的健壮性。怎么做到异常发生了也不影响程序的执行。所以 //一般main方法中的异常建议使用try..catch进行捕捉。main就不要继续往上抛了。 /* public static void main(String[] args) throws FileNotFoundException { System.out.println(&#34;main begin&#34;); m1(); System.out.println(&#34;main over&#34;); } */ public static void main(String[] args) { //100/0这是算数异常，这个异常是运行时异常，在编译阶段可以处理也可不处理，编译器不管。 //System.out.println(100/0);//不处理编译器也不管 /*try{ System.out.println(100/0); }catch(ArithmeticException e){ System.out.println(&#34;算数异常了！&#34;); }*/ System.out.println(&#34;main begin&#34;); try { //try尝试 m1(); //以上代码出现异常，直接进入catch语句块中执行。 System.out.println(&#34;hello world!&#34;); } catch (FileNotFoundException e) {//catch后面的好像一个方法的形参。 //这个分支中可以使用e引用，e引用保存的内存地址是那个new出来异常对象的内存地址。 //catch是捕捉异常之后走的分支 //在catch分支中干什么？处理异常。 System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0675db6a99a22e906327ab5bc94ea7ce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-23T01:35:58+08:00" />
<meta property="article:modified_time" content="2022-09-23T01:35:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">异常处理的方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre>处理异常的第一种方式：
    在方法声明的位置上使用throws关键字抛出，谁调用这个方法我就抛给谁。抛给调用者来处理。
    这种处理异常的态度：上报。

处理异常的第二种方式：
    使用try..catch语句对异常进行捕捉。
    这个异常不会上报，自己处理了。
    异常抛到此处为止，不再上抛了。

注意：
    只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。
    另外需要注意，try语句块中的某一行出现异常，该行后面的代码不会执行。
    try..catch捕捉异常之后，后续代码可以执行。

在以后的开发中，处理编译时异常，应该上报还是捕捉呢，怎么选？
    如果希望调用者来处理，选择throws上报。
    其他情况使用捕捉的方式。

    NullPointerException是运行时异常
</pre> 
<pre>import java.io.FileInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class ExceptionTest06 {
    //一般不建议在main方法上使用throws，因为这个异常如果真正发生了，一定会抛给JVM。JVM只有终止。
    //异常处理机制的作用就是增强程序的健壮性。怎么做到异常发生了也不影响程序的执行。所以
    //一般main方法中的异常建议使用try..catch进行捕捉。main就不要继续往上抛了。
    /*
    public static void main(String[] args) throws FileNotFoundException {
        System.out.println("main begin");
        m1();
        System.out.println("main over");
    }
    */
    public static void main(String[] args) {
        //100/0这是算数异常，这个异常是运行时异常，在编译阶段可以处理也可不处理，编译器不管。
        //System.out.println(100/0);//不处理编译器也不管
        /*try{
            System.out.println(100/0);
        }catch(ArithmeticException e){
            System.out.println("算数异常了！");
        }*/
        System.out.println("main begin");
        try {
            //try尝试
            m1();
            //以上代码出现异常，直接进入catch语句块中执行。
            System.out.println("hello world!");
        } catch (FileNotFoundException e) {//catch后面的好像一个方法的形参。
            //这个分支中可以使用e引用，e引用保存的内存地址是那个new出来异常对象的内存地址。
            //catch是捕捉异常之后走的分支
            //在catch分支中干什么？处理异常。
            System.out.println("文件找不到，可能路径错误，也可能该文件被删除了！");
            System.out.println(e);//java.io.FileNotFoundException: D:\course\新建文本文档txt (系统找不到指定的文件。)
        }

        //try .. catch把异常抓住之后，这里的代码会继续执行。
        System.out.println("main over");
    }

    private static void m1() throws FileNotFoundException {
        System.out.println("m1 begin");
        m2();
        //以上代码出现异常，这里也不会执行。
        System.out.println("m1 over");
    }

    //注意：抛别的异常不可以。
    //抛IOException是可以的，因为IOException包括FileNotFoundException
    //或者Exception也可以 因为Exception包括所有的异常
    //throws后面也可以写多个异常，可以使用逗号隔开
    private static void m2() throws FileNotFoundException {
        System.out.println("m2 begin");
        //编译器报错原因是：m3()方法声明位置上有：throws FileNotFoundException
        //我们在这里调用m3()没有对异常进行预处理。
        m3();
        //以上如果出现异常，这里是无法执行的。
        System.out.println("m2 over");
    }

    private static void m3() throws FileNotFoundException{
        //调用SUN jdk中某给类的构造方法
        //这个类还没有学过，后期IO流的时候就知道了。
        //只是借助一下这个类学习一下异常处理的机制。
        //创建一个输入流对象，该流指向一个文件。
        /*
        编译报错的原因是什么？
            第一：这里调用了一个构造方法：FileInputStream（String name）
            第二：这个构造方法的声明位置上有：throws FileNotFoundException
            第三：通过类的继承结构看到：FileNotFoundException父类是IOException，IOException的父类是Exception
            最终得知，FileNotFoundException是编译时异常。

            错误原因？编译时异常要求程序员编写程序阶段必须对它进行处理，不处理就进行报错。
         */
        //new FileInputStream("D:\\course\\新建文本文档.txt");

        //我们采用第一种处理方式：在方法声明的位置上使用throws继续上抛
        //一个方法体当中的代码出现异常之后，如果上报的话，此方法结束。
        new FileInputStream("D:\\course\\新建文本文档.txt");

        System.out.println("如果以上代码出异常，这里也不会执行");
    }
}</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c13c2fab60c3e2e103e4e111945c95ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【设计模式——Adapter模式】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6b4796fe1c6b092e1edda4ddb9792e31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">哈诺塔问题及其python代码实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>