<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单目深度估计--深度学习篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="单目深度估计--深度学习篇" />
<meta property="og:description" content="文章目录 一：深度估计应用背景1.深度估计的定义2.深度估计的应用场景3.几种深度估计的方法4.使用深度学习估计的优缺点 二：单目深度估计模型1.使用的数据集2.整体网络架构3.分模块解析Ⅰ：层级Ⅱ：ASPPⅢ：特征图减法操作Ⅳ：特征融合Ⅴ：Coarse-to-FineⅥ：权重参数预处理WS与pre_act操作Ⅶ：损失函数 一：深度估计应用背景 1.深度估计的定义 假设我们有一张2d图片 I I I,我们需要一个函数 F F F 来求取其相对应的深度 d d d．这个过程可以写为：
d = F ( I ) d = F(I) d=F(I)
这里的深度信息 d d d其实就代表着由3D物体投射而来的2D图像中每个像素点与相机的实际距离。
但是众所周知, F F F是非常复杂的函数，因为从单张图片中获取具体的深度相当于从二维图像推测出三维空间，即使人眼在两只眼睛来定位自然世界的物体的情况下也依然会有问题存在，更何况使用单张照片了。所以传统的深度估计在单目深度估计上效果并不好，人们更着重于研究立体视觉　(Stereo Vision)，即从多张图片中得到深度信息．因为两张图片就可以根据视角的变化得到图片之间disparity的变化，从而达到求取深度的目的。话说多了，先往后看。
2.深度估计的应用场景 除了上面两张图片中提到的应用场景，深度估计还可以运用于3D重建，障碍物检测，SLAM等一系列需要深度信息的下游任务中。因此，可见深度估计往往作为上游任务存在，重要性不言而喻。
3.几种深度估计的方法 利用激光雷达或结构光在物体表面的反射获取深度点云
这种方法可谓是“土豪法”，直接利用传感器扫一扫，便可获得高精度点云深度信息，但是价格昂贵！
传统的双目测距
双目立体视觉，由两个摄像头组成，像人的眼睛能看到三维的物体，获取物体长度、宽度信息，和深度的信息。摄像头的位置是一般手动标定（比如张正友相机标定算法），然后通过目标点在图像坐标系和世界坐标系中的位置来推导相机内外参数矩阵的过程，往往是一个坐标转换的过程。
传统的单目测距
单目视觉是能获取二维的物体信息，即长度、宽度，所以如果想要测距，需要拍摄出几张不同角度（时序）的图像，再通过Mobileye单目测距等一系列方法，进行求解。同时，计算量复杂，而且精度不如双目高，往往是在条件艰难的时候使用。
4.使用深度学习估计的优缺点 前面铺垫完了几种传统领域的几种常见方法，现在开始聊聊今天的主角–深度学习单目估计。顾名思义，深度学习深度学习，第一反应End2End，把图像往训练好的网络里一扔，不需要任何人工参与，直接得出最后的深度图，一个词，方便！同时，我们只需要单目相机，一个词，成本低！
那有什么缺点呢，首先是80m以内的深度估计精度还行，但是再远误差就很大了，可见精度低、估计距离局限性，都是它的缺点。当然，还有一个深度学习一直绕不走的问题，需要大量训练集，在一些缺少训练数据的环境里显然是不容忽视的问题。
但是毕竟和时代前沿技术搭边了，咱们就来好好唠一唠，下面进入正题。
二：单目深度估计模型 1.使用的数据集 这里讲解的深度估计模型，使用的是KITTI数据集，取景于城市、乡村的道路上，该数据集在多个研究领域内被广泛使用，具体见下图：
2.整体网络架构 深度估计模型是输入一张图像，输出一张包含深度信息的图片，所以是一种生成模型，那么必然离不开编码和解码这个核心过程了，见下图：
当然，真正的网络架构没有这么简单，但都是围绕编码-解码进行的，下面展示CVPR最近发布的一种网络架构，我将逐模块地讲解这个“庞然大物”：
3.分模块解析 Ⅰ：层级 其实就是经过几层池化后，每次缩一半，这里的backbone使用的是Resnet101。和U-net等网络的操作相似，主要是为了后面的操作，如图：
Ⅱ：ASPP 作者在backbone的最后一个特征图做了ASPP，这里什么是ASPP不再赘述了，就是空洞卷积和SPP的结合，之所以用ASPP目的就是加点特征多样性，同时保留一定的分辨率（也是图像分割领域常规操作）。如图所示：
Ⅲ：特征图减法操作 在深度估计研究领域，物体的轮廓深度信息是一个挑战，作者为了有效解决这个问题，进行了神操作，将两张特征图 A − B A-B A−B相减（特征图B是上采样后和A一样尺寸的特征图），提取出了差异特征，得到轮廓特征图L。如下图：
Ⅳ：特征融合 进行一顿叠加，首先充分利用高层特征图与本层特征图的融合，得到中间特征图X，来增加特征的多尺度性。接着拼接高层的预测结果R‘’和本层的轮廓图L，大杂烩乱炖后得到本层预测结果R。每层都是这样操作，如图所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fc4b35d6ea84da8ddedeeff10939820c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-08T10:20:16+08:00" />
<meta property="article:modified_time" content="2022-09-08T10:20:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单目深度估计--深度学习篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一：深度估计应用背景</a></li><li><ul><li><a href="#1_2" rel="nofollow">1.深度估计的定义</a></li><li><a href="#2_12" rel="nofollow">2.深度估计的应用场景</a></li><li><a href="#3_18" rel="nofollow">3.几种深度估计的方法</a></li><li><a href="#4_26" rel="nofollow">4.使用深度学习估计的优缺点</a></li></ul> 
  </li><li><a href="#_32" rel="nofollow">二：单目深度估计模型</a></li><li><ul><li><a href="#1_33" rel="nofollow">1.使用的数据集</a></li><li><a href="#2_39" rel="nofollow">2.整体网络架构</a></li><li><a href="#3_44" rel="nofollow">3.分模块解析</a></li><li><ul><li><a href="#_45" rel="nofollow">Ⅰ：层级</a></li><li><a href="#ASPP_49" rel="nofollow">Ⅱ：ASPP</a></li><li><a href="#_52" rel="nofollow">Ⅲ：特征图减法操作</a></li><li><a href="#_58" rel="nofollow">Ⅳ：特征融合</a></li><li><a href="#CoarsetoFine_61" rel="nofollow">Ⅴ：Coarse-to-Fine</a></li><li><a href="#WSpre_act_65" rel="nofollow">Ⅵ：权重参数预处理WS与pre_act操作</a></li><li><a href="#_70" rel="nofollow">Ⅶ：损失函数</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一：深度估计应用背景</h2> 
<h3><a id="1_2"></a>1.深度估计的定义</h3> 
<p>假设我们有一张2d图片<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         I 
        
       
      
        I 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span style="margin-right: 0.0785em;" class="mord mathnormal">I</span></span></span></span></span>,我们需要一个函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
      
        F 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span style="margin-right: 0.1389em;" class="mord mathnormal">F</span></span></span></span></span> 来求取其相对应的深度<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
      
        d 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></span>．这个过程可以写为：</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         = 
        
       
         F 
        
       
         ( 
        
       
         I 
        
       
         ) 
        
       
      
        d = F(I) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.1389em;" class="mord mathnormal">F</span><span class="mopen">(</span><span style="margin-right: 0.0785em;" class="mord mathnormal">I</span><span class="mclose">)</span></span></span></span></span></p> 
<p>这里的深度信息<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
      
        d 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></span>其实就代表着<strong>由3D物体投射而来的2D图像中每个像素点与相机的实际距离</strong>。</p> 
<p>但是众所周知, <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
      
        F 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span style="margin-right: 0.1389em;" class="mord mathnormal">F</span></span></span></span></span>是非常复杂的函数，因为从单张图片中获取具体的深度相当于从二维图像推测出三维空间，即使人眼在两只眼睛来定位自然世界的物体的情况下也依然会有问题存在，更何况使用单张照片了。所以传统的深度估计在单目深度估计上效果并不好，人们更着重于研究立体视觉　(Stereo Vision)，即从多张图片中得到深度信息．因为两张图片就可以根据视角的变化得到图片之间disparity的变化，从而达到求取深度的目的。话说多了，先往后看。</p> 
<h3><a id="2_12"></a>2.深度估计的应用场景</h3> 
<p><img src="https://images2.imgbox.com/55/a1/tZtpV4D6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a9/5d/1qb6tDBt_o.png" alt="在这里插入图片描述"><br> 除了上面两张图片中提到的应用场景，深度估计还可以运用于3D重建，障碍物检测，SLAM等一系列需要深度信息的下游任务中。因此，<strong>可见深度估计往往作为上游任务存在</strong>，重要性不言而喻。</p> 
<h3><a id="3_18"></a>3.几种深度估计的方法</h3> 
<ul><li> <p><strong>利用激光雷达或结构光在物体表面的反射获取深度点云</strong><br> 这种方法可谓是“土豪法”，直接利用传感器扫一扫，便可获得高精度点云深度信息，但是价格昂贵！</p> </li><li> <p><strong>传统的双目测距</strong><br> 双目立体视觉，由两个摄像头组成，像人的眼睛能看到三维的物体，获取物体长度、宽度信息，和深度的信息。摄像头的位置是一般手动标定（比如张正友相机标定算法），然后通过目标点在图像坐标系和世界坐标系中的位置来推导相机内外参数矩阵的过程，往往是一个坐标转换的过程。</p> </li><li> <p><strong>传统的单目测距</strong><br> 单目视觉是能获取二维的物体信息，即长度、宽度，所以如果想要测距，需要拍摄出几张不同角度（时序）的图像，再通过Mobileye单目测距等一系列方法，进行求解。同时，计算量复杂，而且精度不如双目高，往往是在条件艰难的时候使用。</p> </li></ul> 
<h3><a id="4_26"></a>4.使用深度学习估计的优缺点</h3> 
<p>前面铺垫完了几种传统领域的几种常见方法，现在开始聊聊今天的主角–深度学习单目估计。顾名思义，深度学习深度学习，第一反应End2End，把图像往训练好的网络里一扔，不需要任何人工参与，直接得出最后的深度图，一个词，<strong>方便</strong>！同时，我们只需要单目相机，一个词，<strong>成本低</strong>！</p> 
<p>那有什么缺点呢，首先是80m以内的深度估计精度还行，但是再远误差就很大了，可见<strong>精度低、估计距离局限性</strong>，都是它的缺点。当然，还有一个深度学习一直绕不走的问题，<strong>需要大量训练集</strong>，在一些缺少训练数据的环境里显然是不容忽视的问题。</p> 
<p>但是毕竟和时代前沿技术搭边了，咱们就来好好唠一唠，下面进入正题。</p> 
<h2><a id="_32"></a>二：单目深度估计模型</h2> 
<h3><a id="1_33"></a>1.使用的数据集</h3> 
<p>这里讲解的深度估计模型，使用的是<strong>KITTI数据集</strong>，取景于城市、乡村的道路上，该数据集<strong>在多个研究领域内被广泛使用</strong>，具体见下图：<br> <img src="https://images2.imgbox.com/db/22/VPVyXJVn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f7/66/EiKi5snX_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_39"></a>2.整体网络架构</h3> 
<p>深度估计模型是输入一张图像，输出一张包含深度信息的图片，所以<strong>是一种生成模型</strong>，那么必然离不开编码和解码这个核心过程了，见下图：<br> <img src="https://images2.imgbox.com/3a/5a/yRLOPaoE_o.png" alt="在这里插入图片描述"><br> 当然，真正的网络架构没有这么简单，但都是围绕编码-解码进行的，下面展示CVPR最近发布的一种网络架构，我将逐模块地讲解这个“庞然大物”：<br> <img src="https://images2.imgbox.com/c5/70/7PYdQWaM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_44"></a>3.分模块解析</h3> 
<h4><a id="_45"></a>Ⅰ：层级</h4> 
<p>其实就是经过几层池化后，每次缩一半，这里的backbone使用的是Resnet101。和U-net等网络的操作相似，主要是为了后面的操作，如图：<br> <img src="https://images2.imgbox.com/0d/89/8hwNTw33_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="ASPP_49"></a>Ⅱ：ASPP</h4> 
<p>作者在backbone的最后一个特征图做了ASPP，这里什么是ASPP不再赘述了，就是<strong>空洞卷积和SPP的结合</strong>，之所以用ASPP<strong>目的就是加点特征多样性，同时保留一定的分辨率</strong>（也是图像分割领域常规操作）。如图所示：<br> <img src="https://images2.imgbox.com/6c/13/vBZn852B_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_52"></a>Ⅲ：特征图减法操作</h4> 
<p>在深度估计研究领域，物体的轮廓深度信息是一个挑战，作者为了有效解决这个问题，<strong>进行了神操作</strong>，将两张特征图<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         − 
        
       
         B 
        
       
      
        A-B 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span style="margin-right: 0.0502em;" class="mord mathnormal">B</span></span></span></span></span>相减（特征图B是上采样后和A一样尺寸的特征图），提取出了差异特征，得到轮廓特征图L。如下图：<br> <img src="https://images2.imgbox.com/58/52/vt0MFHnz_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f1/84/eZvYDXlD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_58"></a>Ⅳ：特征融合</h4> 
<p>进行一顿叠加，<strong>首先</strong>充分利用高层特征图与本层特征图的融合，得到中间特征图X，来增加特征的多尺度性。<strong>接着</strong>拼接高层的预测结果R‘’和本层的轮廓图L，大杂烩乱炖后得到本层预测结果R。每层都是这样操作，如图所示：<br> <img src="https://images2.imgbox.com/0d/d9/jRtHPCPo_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="CoarsetoFine_61"></a>Ⅴ：Coarse-to-Fine</h4> 
<p>最后是细节“雕琢”的阶段，对每一层的R进行融合，得到最后的预测结果R‘’‘，如图所示：<br> <img src="https://images2.imgbox.com/17/51/UOR4YDxW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="WSpre_act_65"></a>Ⅵ：权重参数预处理WS与pre_act操作</h4> 
<p>在真个网络中还加入了一些细节，首先是加入了权重标准化<strong>WS操作</strong>，让权重参数分布更均匀一些，不然经过ReLU后大量权重会被杀死（笔者提出疑问，那这样为什么不换一下激励函数，比如Mish，Leaky ReLU，Swish啥的？？），接着还加入了<strong>pre_act</strong>，就是先对x进行ReLU,然后再进入卷积层，比较佛系，对于他们的实验，确实准确度有了质的飞跃，如下图所示：<br> <img src="https://images2.imgbox.com/7e/c4/MmRX4zSF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/58/5e/uPx0XLAx_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_70"></a>Ⅶ：损失函数</h4> 
<p><img src="https://images2.imgbox.com/c9/9b/TIdTSrnC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/46/af/pk8Sx6AZ_o.png" alt="在这里插入图片描述"></p> 
<p>化简后的损失函数中的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
      
        d 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></span> 其实就是每个像素点预测深度和真实深度的差值，重点是后面的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         i 
        
       
         d 
        
       
         j 
        
       
      
        di dj 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span style="margin-right: 0.0572em;" class="mord mathnormal">j</span></span></span></span></span>求和是什么意思，前面为什么还加了个负号。举个例子，大家就理解了，找出两个像素点，预测值和真实值的差值分别是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         1 
        
       
      
        d1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">1</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         2 
        
       
      
        d2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span></span></span></span></span>，如果两个差值都是负数，那么相乘是个正值，前面加个负号，那么代表不被惩罚，相反的如果两者异号则被惩罚。可见<mark>损失函数中这一项的目的是，希望得到的预测值要么都是低了一点，要么都高了一点，而不是这里预测大了，那里预测小了</mark>，这样效果其实更糟糕，模型更不可靠。</p> 
<hr> 
<p>  至此我对利用深度学习进行单目深度估计的原理，进行了简单讲解，希望对大家有所帮助，有不懂的地方或者建议，欢迎大家在下方留言评论。</p> 
<p>我是努力在CV泥潭中摸爬滚打的江南咸鱼，我们一起努力，不留遗憾！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a06b429c0cabd77c3b154a34013f2810/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GNN的理解与研究</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be011ff83165756ff6f0b03d2f5744d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kafka消费组代码的实现[golang版]</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>