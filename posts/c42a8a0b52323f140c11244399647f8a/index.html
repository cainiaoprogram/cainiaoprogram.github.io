<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Http中Content-Type等属性详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Http中Content-Type等属性详解" />
<meta property="og:description" content="前言 一直以来对HTTP请求中各种属性一知半解,偶然在博客中找到一篇,特意摘录过来方便自己以后查看.
正文 敬请关注博客，后期不断更新优质博文，谢谢
这里讲解Content-Type的可用值，以及在spring MVC中如何使用它们来映射请求信息。
1. Content-Type
MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。
例如： Content-Type: text/html;charset:utf-8;
常见的媒体格式类型如下：
text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型：
application/xhtml&#43;xml ：XHTML格式 application/xml ： XML数据格式 application/atom&#43;xml ：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： &lt;form encType=””&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的：
multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。
2. Spring MVC中关于关于Content-Type类型信息的使用
首先我们来看看RequestMapping中的Class定义：
@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Mapping public @interface RequestMapping { String[] value() default {}; RequestMethod[] method() default {}; String[] params() default {}; String[] headers() default {}; String[] consumes() default {}; String[] produces() default {}; } value: 指定请求的实际地址， 比如 /action/info之类。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c42a8a0b52323f140c11244399647f8a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-23T16:08:21+08:00" />
<meta property="article:modified_time" content="2018-10-23T16:08:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Http中Content-Type等属性详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>前言</h4> 
<p>一直以来对HTTP请求中各种属性一知半解,偶然在博客中找到一篇,特意摘录过来方便自己以后查看.</p> 
<h4><a id="_2"></a>正文</h4> 
<div class="htmledit_views"> 
 <p>敬请关注博客，后期不断更新优质博文，谢谢</p> 
</div> 
<p>这里讲解Content-Type的可用值，以及在<a class="replace_word" href="http://lib.csdn.net/base/javaee" rel="nofollow noopener noreferrer" target="_blank">spring</a> MVC中如何使用它们来映射请求信息。</p> 
<p>1.  Content-Type</p> 
<p>  MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。</p> 
<p> 例如： Content-Type: text/html;charset:utf-8;</p> 
<p> 常见的媒体格式类型如下：</p> 
<ul><li>    text/html ： HTML格式</li><li>    text/plain ：纯文本格式      </li><li>    text/xml ：  XML格式</li><li>    image/gif ：gif图片格式    </li><li>    image/jpeg ：jpg图片格式 </li><li>    image/png：png图片格式</li></ul> 
<p>   以application开头的媒体格式类型：</p> 
<ul><li>   application/xhtml+xml ：XHTML格式</li><li>   application/xml     ： XML数据格式</li><li>   application/atom+xml  ：Atom XML聚合格式    </li><li>   application/json    ： JSON数据格式</li><li>   application/pdf       ：pdf格式  </li><li>   application/msword  ： Word文档格式</li><li>   application/octet-stream ： 二进制流数据（如常见的文件下载）</li><li>   application/x-www-form-urlencoded ： &lt;form encType=””&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li></ul> 
<p>   另外一种常见的媒体格式是上传文件之时使用的：</p> 
<ul><li>    multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul> 
<p>     以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。</p> 
<p>2.   Spring MVC中关于关于Content-Type类型信息的使用</p> 
<p>    首先我们来看看RequestMapping中的Class定义：</p> 
<pre><code>    @Target({ElementType.METHOD, ElementType.TYPE})  
    @Retention(RetentionPolicy.RUNTIME)  
    @Documented  
    @Mapping  
    public @interface RequestMapping {  
          String[] value() default {};  
          RequestMethod[] method() default {};  
          String[] params() default {};  
          String[] headers() default {};  
          String[] consumes() default {};  
          String[] produces() default {};  
    }  
</code></pre> 
<p>value:  指定请求的实际地址， 比如 /action/info之类。<br> method：  指定请求的method类型， GET、POST、PUT、DELETE等<br> consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;<br> produces:    指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br> params： 指定request中必须包含某些参数值是，才让该方法处理<br> headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求</p> 
<p>其中，consumes， produces使用content-typ信息进行过滤信息；headers中可以使用content-type进行过滤和判断。</p> 
<p>3. 使用示例</p> 
<p>  3.1 headers</p> 
<pre><code>@RequestMapping(value = "/test", method = RequestMethod.GET, headers="Referer=http://www.ifeng.com/")    
    public void testHeaders(@PathVariable String ownerId, @PathVariable String petId) {        
      // implementation omitted    
    }   

</code></pre> 
<p>  这里的Headers里面可以匹配所有Header里面可以出现的信息，不局限在Referer信息。</p> 
<p>  示例2</p> 
<pre><code>    @RequestMapping(value = "/response/ContentType", headers = "Accept=application/json")    
    public void response2(HttpServletResponse response) throws IOException {    
        //表示响应的内容区数据的媒体类型为json格式，且编码为utf-8(客户端应该以utf-8解码)    
        response.setContentType("application/json;charset=utf-8");    
        //写出响应体内容    
        String jsonData = "{\"username\":\"zhang\", \"password\":\"123\"}";    
        response.getWriter().write(jsonData);    
    }    

</code></pre> 
<p>服务器根据请求头“Accept=application/json”生产json数据。</p> 
<p>当你有如下Accept头，将遵守如下规则进行应用：<br> ①Accept：text/html,application/xml,application/json<br>       将按照如下顺序进行produces的匹配 ①text/html ②application/xml ③application/json<br> ②Accept：application/xml;q=0.5,application/json;q=0.9,text/html<br>       将按照如下顺序进行produces的匹配 ①text/html ②application/json ③application/xml<br>       参数为媒体类型的质量因子，越大则优先权越高(从0到1)<br> ③Accept：*/*,text/*,text/html<br>       将按照如下顺序进行produces的匹配 ①text/html ②text/* ③*/*</p> 
<p><br> 即匹配规则为：最明确的优先匹配。</p> 
<h3>Requests部分</h3> 
<table border="1" cellpadding="0"><tbody><tr><th>Header</th><th>解释</th><th>示例</th></tr><tr><td>Accept</td><td>指定客户端能够接收的内容类型</td><td>Accept: text/plain, text/html</td></tr><tr><td>Accept-Charset</td><td>浏览器可以接受的字符编码集。</td><td>Accept-Charset: iso-8859-5</td></tr><tr><td>Accept-Encoding</td><td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td><td>Accept-Encoding: compress, gzip</td></tr><tr><td>Accept-Language</td><td>浏览器可接受的语言</td><td>Accept-Language: en,zh</td></tr><tr><td>Accept-Ranges</td><td>可以请求网页实体的一个或者多个子范围字段</td><td>Accept-Ranges: bytes</td></tr><tr><td>Authorization</td><td>HTTP授权的授权证书</td><td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td>Cache-Control</td><td>指定请求和响应遵循的缓存机制</td><td>Cache-Control: no-cache</td></tr><tr><td>Connection</td><td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td><td>Connection: close</td></tr><tr><td>Cookie</td><td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td><td>Cookie: $Version=1; Skin=new;</td></tr><tr><td>Content-Length</td><td>请求的内容长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Type</td><td>请求的与实体对应的MIME信息</td><td>Content-Type: application/x-www-form-urlencoded</td></tr><tr><td>Date</td><td>请求发送的日期和时间</td><td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td>Expect</td><td>请求的特定的服务器行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发出请求的用户的Email</td><td>From: user@email.com</td></tr><tr><td>Host</td><td>指定请求的服务器的域名和端口号</td><td>Host: www.zcmhi.com</td></tr><tr><td>If-Match</td><td>只有请求内容与实体相匹配才有效</td><td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Modified-Since</td><td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td><td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td>If-None-Match</td><td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td><td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Range</td><td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td><td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Unmodified-Since</td><td>只在实体在指定时间之后未被修改才请求成功</td><td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td>Max-Forwards</td><td>限制信息通过代理和网关传送的时间</td><td>Max-Forwards: 10</td></tr><tr><td>Pragma</td><td>用来包含实现特定的指令</td><td>Pragma: no-cache</td></tr><tr><td>Proxy-Authorization</td><td>连接到代理的授权证书</td><td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td>Range</td><td>只请求实体的一部分，指定范围</td><td>Range: bytes=500-999</td></tr><tr><td>Referer</td><td>先前网页的地址，当前请求网页紧随其后,即来路</td><td>Referer: http://www.zcmhi.com/archives/71.html</td></tr><tr><td>TE</td><td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td><td>TE: trailers,deflate;q=0.5</td></tr><tr><td>Upgrade</td><td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td>User-Agent</td><td>User-Agent的内容包含发出请求的用户信息</td><td>User-Agent: Mozilla/5.0 (Linux; X11)</td></tr><tr><td>Via</td><td>通知中间网关或代理服务器地址，通信协议</td><td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td></tr><tr><td>Warning</td><td>关于消息实体的警告信息</td><td>Warn: 199 Miscellaneous warning</td></tr></tbody></table> 
<h3>Responses 部分 </h3> 
<p><img src="https://images2.imgbox.com/fe/65/HKzqMF5P_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e2/a8/TfGcpIaa_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3a/77/Fvhk55bp_o.png" alt="在这里插入图片描述"></p> 
<p>3.2 params的示例</p> 
<pre><code>    @RequestMapping(value = "/test/{userId}", method = RequestMethod.GET, params="myParam=myValue")    
    public void findUser(@PathVariable String userId) {        
      // implementation omitted    
    }    

</code></pre> 
<p>  仅处理请求中包含了名为“myParam”，值为“myValue”的请求，起到了一个过滤的作用。</p> 
<p>3.3 consumes/produces</p> 
<pre><code>    @Controller    
    @RequestMapping(value = "/users", method = RequestMethod.POST, consumes="application/json", produces="application/json")    
    @ResponseBody  
    public List&lt;User&gt; addUser(@RequestBody User userl) {        
        // implementation omitted    
        return List&lt;User&gt; users;  
    }    

</code></pre> 
<p>  方法仅处理request Content-Type为“application/json”类型的请求. produces标识==&gt;处理request请求中Accept头中包含了"application/json"的请求，同时暗示了返回的内容类型为application/json;</p> 
<h4><a id="_237"></a>总结</h4> 
<p>  在本文中，首先介绍了Content-Type主要支持的格式内容，然后基于@RequestMapping标注的内容介绍了主要的使用方法，其中,headers, consumes,produces,都是使用Content-Type中使用的各种媒体格式内容，可以基于这个格式内容来进行访问的控制和过滤。</p> 
<p>参考资料：</p> 
<p>1.  HTTP中支持的Content-Type: http://tool.oschina<a class="replace_word" href="http://lib.csdn.net/base/dotnet" rel="nofollow noopener noreferrer" target="_blank">.NET</a>/commons</p> 
<p>2.  Media Type介绍。 http://www.iteye.com/topic/1127120</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f56a35a6dc4960004b1577eb6a486c52/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python知识点：tkinter-filedialog-asksaveasfilename参数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aa106fa7e3ca2a8c25c6ddd1262beac7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用bat文件批量修改多个android终端的文件并重启</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>