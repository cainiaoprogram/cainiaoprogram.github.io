<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>oo编程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="oo编程" />
<meta property="og:description" content=" OO(Object-Oriented) 什么是OO? 就是面向接口编程。无论你是用vtable, 或gp的function object, 或就是C的函数指针，正交分解也好，各种pattern也罢，都是面向接口编程思想的一种实现。 为什么要面向接口编程？ 为了解耦。 什么是解耦？ 就是把程序中互相不相关或有限相关的模块分割开来。就象收拾屋子，你希望把不同的东西放到不同的地方。把酱油和醋倒进不同的瓶子里去。 这里，对完全不相关的功能，可以简单地分开实现。 但事实上，很多情况下，不同模块之间是有互相之间的关系的。这时，就需要接口。用接口准确定义模块之间的关系。解耦前，两个模块之间共享所有信息（这个信息包括数据，也包括各自的实现细节）。解耦后，需要共享的信息被准确地定义在接口中。同时，信息的流向也被确定。 解耦的好处是什么呢？ 首先，程序变得清晰了。 其次，不该暴露的实现细节被隐藏了。代码的修改变容易了。 再次，结构灵活了，通过静态多态(function object)或动态多态(vtable), 一个模块可以和任意实现接口的模块协作。原来类A只能与类B协作，解耦后可以和所有实现接口IB的类如B1, B2, ... 协作了。扩展性大大增强。自然而然就代码重用了。 编译依赖也没有了。你可以专心写和编译一个模块，不用等待其它模块的完成。 调试容易了。只要模块对一个接口调试成功，其它的接口也没有问题。于是，甚至可以用一个simple naive的实现该接口的dummy类来调试。（这点，使用template的gp不适用） 那么解耦的坏处是什么呢？ 接口的定义变得很关键。解耦就是隐藏一些信息，定义一些需要共享的信息。如果接口定义的不好，隐藏了不该隐藏的信息，那么对某些需要这些信息的复杂情况来说，这个解耦就失败了。 而如果没有隐藏一些应该隐藏的信息，那么不该有的耦合仍然存在。 那么怎样解耦，又怎样定义接口呢？ 这是一个纯粹业务逻辑的思考过程。这里，对编程语言的知识变得无关紧要。事实上，只要精确掌握需求，严密地分析需求和模块内部子模块之间的需求，任何一个会逻辑思考的人都可胜任这个工作。就象歌星郑智化一样，虽然不识谱，但一样写歌，只不过最后要懂谱的人把歌纪录下来。 解耦的原则很简单：精确定义需求，仔细分析需求。不要隐藏任何“需求”也许会需要的信息。不要放过任何“需求”明显不需要的信息。 而对需求不清楚的情况，宁可错放一千，不能错杀一个。总而言之，决不能隐藏可能需要的信息。 不考虑重用，重用是解耦后的自然结果。不能倒因为果 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e996ccb60ef969673774e3a3320c96bc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2007-05-19T00:06:00+08:00" />
<meta property="article:modified_time" content="2007-05-19T00:06:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">oo编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    OO(Object-Oriented) 
<br> 
<br>什么是OO? 
<br>就是面向接口编程。无论你是用vtable, 或gp的function object, 或就是C的函数指针，正交分解也好，各种pattern也罢，都是面向接口编程思想的一种实现。 
<br> 
<br>为什么要面向接口编程？ 
<br>为了解耦。 
<br> 
<br>什么是解耦？ 
<br>就是把程序中互相不相关或有限相关的模块分割开来。就象收拾屋子，你希望把不同的东西放到不同的地方。把酱油和醋倒进不同的瓶子里去。 
<br>这里，对完全不相关的功能，可以简单地分开实现。 
<br>但事实上，很多情况下，不同模块之间是有互相之间的关系的。这时，就需要接口。用接口准确定义模块之间的关系。解耦前，两个模块之间共享所有信息（这个信息包括数据，也包括各自的实现细节）。解耦后，需要共享的信息被准确地定义在接口中。同时，信息的流向也被确定。 
<br> 
<br>解耦的好处是什么呢？ 
<br>首先，程序变得清晰了。 
<br>其次，不该暴露的实现细节被隐藏了。代码的修改变容易了。 
<br>再次，结构灵活了，通过静态多态(function object)或动态多态(vtable), 一个模块可以和任意实现接口的模块协作。原来类A只能与类B协作，解耦后可以和所有实现接口IB的类如B1, B2, ... 协作了。扩展性大大增强。自然而然就代码重用了。 
<br>编译依赖也没有了。你可以专心写和编译一个模块，不用等待其它模块的完成。 
<br>调试容易了。只要模块对一个接口调试成功，其它的接口也没有问题。于是，甚至可以用一个simple naive的实现该接口的dummy类来调试。（这点，使用template的gp不适用） 
<br> 
<br>那么解耦的坏处是什么呢？ 
<br>接口的定义变得很关键。解耦就是隐藏一些信息，定义一些需要共享的信息。如果接口定义的不好，隐藏了不该隐藏的信息，那么对某些需要这些信息的复杂情况来说，这个解耦就失败了。 
<br>而如果没有隐藏一些应该隐藏的信息，那么不该有的耦合仍然存在。 
<br> 
<br>那么怎样解耦，又怎样定义接口呢？ 
<br>这是一个纯粹业务逻辑的思考过程。这里，对编程语言的知识变得无关紧要。事实上，只要精确掌握需求，严密地分析需求和模块内部子模块之间的需求，任何一个会逻辑思考的人都可胜任这个工作。就象歌星郑智化一样，虽然不识谱，但一样写歌，只不过最后要懂谱的人把歌纪录下来。 
<br>解耦的原则很简单：精确定义需求，仔细分析需求。不要隐藏任何“需求”也许会需要的信息。不要放过任何“需求”明显不需要的信息。 
<br>而对需求不清楚的情况，宁可错放一千，不能错杀一个。总而言之，决不能隐藏可能需要的信息。 
<br>不考虑重用，重用是解耦后的自然结果。不能倒因为果 
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e5163d1f7fb4bd0fcb00a2257a583e53/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">gexin 2410bp开发板调试笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45b8d296fb0475f560fd79a8c8120d47/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【c&#43;&#43;】复数加减法类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>