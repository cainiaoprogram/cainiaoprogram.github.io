<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>5 计算机组成原理第四章  指令系统 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="5 计算机组成原理第四章  指令系统" />
<meta property="og:description" content="文章目录 1 指令格式1.1 指令定义1.2 指令格式1.3 指令格式-地址码1.4 指令格式-操作码1.5 操作码分类1.6 操作类型 2 数据存放指令寻址2.1 数据存放方式2.2 指令寻址2.3 操作数类型2.4 数据寻址2.4.1立即寻址2.4.2 直接寻址2.4.3 间接寻址2.4.4 寄存器寻址2.4.5 寄存器间接寻址2.4.6 隐含寻址 2.5 数据寻址-2偏移寻址2.5.1 基址寻址2.5.2 变址寻址2.5.3 相对寻址2.5.4 相对寻址举例2.5.5 寻址方式小结2.5.6 堆栈寻址 2.6 CISC和RISC2.7 指令系统小结 1 指令格式 1.1 指令定义 指令（又称机器指令）：
是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。
一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。
注：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。
1.2 指令格式 一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。
一条指令通常要包括操作码字段和地址码字段两部分：
1.3 指令格式-地址码 指令含义：（A1）OP（A2）→A3，A4=下一条将要执行指令的地址
设指令字长为32位，操作码占8位，4个地址码字段各占6位
设存储字长为32位，即 4B
Ai 可直接表示 26=64 个不同的位置一条指令的执行（假设每个地址都是主存地址）： 取指令访存1次（假设指令字长=存储字长）
取两个操作数访存2次
存回结果访存1次
总计共访存4次
设指令字长及存储字长均为32位，操作码占8位
指令含义：（A1）OP（A2）→A3，A4=下一条将要执行指令的地址
4个地址码字段各占6位，指令操作数直接寻址范围为 26=64；
完成一条指令需要访存4次
指令含义：（A1）OP（A2）→A3
3个地址码字段各占8位，指令操作数直接寻址范围为 28=256；
完成一条指令需要访存4次
指令含义：（A1）OP（A2）→A1
2个地址码字段各占12位，指令操作数直接寻址范围为 212=4K；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a34a87a9effb280d2910fec7eca53ef5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-08T18:03:45+08:00" />
<meta property="article:modified_time" content="2020-07-08T18:03:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">5 计算机组成原理第四章  指令系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1__1" rel="nofollow">1 指令格式</a></li><li><ul><li><a href="#11__3" rel="nofollow">1.1 指令定义</a></li><li><a href="#12__11" rel="nofollow">1.2 指令格式</a></li><li><a href="#13__16" rel="nofollow">1.3 指令格式-地址码</a></li><li><a href="#14__61" rel="nofollow">1.4 指令格式-操作码</a></li><li><a href="#15__82" rel="nofollow">1.5 操作码分类</a></li><li><a href="#16__96" rel="nofollow">1.6 操作类型</a></li></ul> 
    </li><li><a href="#2__122" rel="nofollow">2 数据存放指令寻址</a></li><li><ul><li><a href="#21__123" rel="nofollow">2.1 数据存放方式</a></li><li><a href="#22__136" rel="nofollow">2.2 指令寻址</a></li><li><a href="#23__142" rel="nofollow">2.3 操作数类型</a></li><li><a href="#24__144" rel="nofollow">2.4 数据寻址</a></li><li><ul><li><ul><li><a href="#241_150" rel="nofollow">2.4.1立即寻址</a></li><li><a href="#242__164" rel="nofollow">2.4.2 直接寻址</a></li><li><a href="#243__181" rel="nofollow">2.4.3 间接寻址</a></li><li><a href="#244__190" rel="nofollow">2.4.4 寄存器寻址</a></li><li><a href="#245__204" rel="nofollow">2.4.5 寄存器间接寻址</a></li><li><a href="#246__215" rel="nofollow">2.4.6 隐含寻址</a></li></ul> 
     </li></ul> 
     </li><li><a href="#25_2_235" rel="nofollow">2.5 数据寻址-2偏移寻址</a></li><li><ul><li><ul><li><a href="#251__237" rel="nofollow">2.5.1 基址寻址</a></li><li><a href="#252__249" rel="nofollow">2.5.2 变址寻址</a></li><li><a href="#253__263" rel="nofollow">2.5.3 相对寻址</a></li><li><a href="#254__270" rel="nofollow">2.5.4 相对寻址举例</a></li><li><a href="#255__289" rel="nofollow">2.5.5 寻址方式小结</a></li><li><a href="#256__304" rel="nofollow">2.5.6 堆栈寻址</a></li></ul> 
     </li></ul> 
     </li><li><a href="#26_CISCRISC_312" rel="nofollow">2.6 CISC和RISC</a></li><li><a href="#27__323" rel="nofollow">2.7 指令系统小结</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="1__1"></a>1 指令格式</h4> 
<h5><a id="11__3"></a>1.1 指令定义</h5> 
<blockquote> 
 <p>指令（又称机器指令）：</p> 
 <blockquote> 
  <p>是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。</p> 
 </blockquote> 
</blockquote> 
<p>一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。</p> 
<blockquote> 
 <p>注：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。</p> 
</blockquote> 
<h5><a id="12__11"></a>1.2 指令格式</h5> 
<p>一条指令就是机器语言的一个语句，它是一组有意义的<mark>二进制代码</mark>。</p> 
<blockquote> 
 <p>一条指令通常要包括操作码字段和地址码字段两部分：<br> <img src="https://images2.imgbox.com/5c/da/VTIZKl0f_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="13__16"></a>1.3 指令格式-地址码</h5> 
<p><img src="https://images2.imgbox.com/8a/44/iMFJSnIA_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>指令含义</strong>：<code>（A1）OP（A2）→A3</code>，A4=下一条将要执行指令的地址<br> 设指令字长为32位，操作码占8位，4个地址码字段各占6位<br> 设存储字长为32位，即 4B</p> 
 <ul><li>A<sub>i</sub> 可直接表示 2<sup>6</sup>=64 个不同的位置</li><li>一条指令的执行（假设每个地址都是主存地址）：</li></ul> 
 <blockquote> 
  <blockquote> 
   <p>取指令访存1次（假设指令字长=存储字长）<br> 取两个操作数访存2次<br> 存回结果访存1次<br> 总计共访存4次</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>设指令字长及存储字长均为32位，操作码占8位</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/ee/3f/jU6r5czy_o.png" alt="在这里插入图片描述"><br> <strong>指令含义</strong>：<code>（A1）OP（A2）→A3</code>，A4=下一条将要执行指令的地址</p> 
 <blockquote> 
  <p>4个地址码字段各占6位，指令操作数直接寻址范围为 2<sup>6</sup>=64；<br> 完成一条指令需要访存4次</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/2a/f8/Dxp9mbmu_o.png" alt="在这里插入图片描述"><br> <strong>指令含义</strong>：<code>（A1）OP（A2）→A3</code></p> 
 <blockquote> 
  <p>3个地址码字段各占8位，指令操作数直接寻址范围为 2<sup>8</sup>=256；<br> 完成一条指令需要访存4次</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/95/58/HpQnCaZi_o.png" alt="在这里插入图片描述"><br> <strong>指令含义</strong>：<code>（A1）OP（A2）→A1</code></p> 
 <blockquote> 
  <p>2个地址码字段各占12位，指令操作数直接寻址范围为 2<sup>12</sup>=4K；<br> 完成一条指令需要访存4次</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/e5/17/pMihn0SI_o.png" alt="在这里插入图片描述"><br> <strong>指令含义</strong>：</p> 
 <ol><li><code>OP（A1）→A1</code>，如加1、减1、取反、求补等完成一条指令需要访存3次</li><li><code>（ACC）OP（A1）→ACC</code>，隐含约定的目的地址为 <strong>ACC</strong><br> 完成一条指令需要访存2次<br> 1个地址码字段占24位，指令操作数直接寻址范围为 2<sup>24</sup>=16M</li></ol> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/90/33/LORDDGUr_o.png" alt="在这里插入图片描述"><br> <strong>指令含义</strong>：</p> 
 <ol><li>不需要操作数，如空操作、停机、关中断等指令</li><li>堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶</li></ol> 
</blockquote> 
<p><strong>指令字结构</strong></p> 
<blockquote> 
 <ul><li><strong>定长指令字结构</strong>：指令长度固定</li><li><strong>变长指令字结构</strong>：指令长度不等</li></ul> 
</blockquote> 
<h5><a id="14__61"></a>1.4 指令格式-操作码</h5> 
<p>定长操作码：n位→ 2<sup>n</sup> 条指令<br> 扩展操作码：操作码长度可变</p> 
<blockquote> 
 <p><strong>扩展操作码举例</strong>：<img src="https://images2.imgbox.com/67/1b/gwF6hqVp_o.png" alt="在这里插入图片描述"><br> <strong>扩展思想</strong>：即动态的把地址码用作操作码，而为了识别变化，上一层操作码字段留出一个状态表示下一层</p> 
</blockquote> 
<p>在设计扩展操作码指令格式时，必须注意以下两点：</p> 
<blockquote> 
 <ol><li>不允许短码是长码的前缀，即<strong>短操作码不能与长操作码的前面部分的代码相同</strong>。</li><li>各指令的操作码一定不能重复。<br> 通常情况下，对使用频率较高的指令，分配较短的操作码；<br> 对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。</li></ol> 
</blockquote> 
<p>设地址长度为 n，上一层留出 m 种状态，下一层可扩展出 mx2<sup>n</sup> 种状态<br> <img src="https://images2.imgbox.com/32/93/VdiKOoJB_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="15__82"></a>1.5 操作码分类</h5> 
<blockquote> 
 <ul><li>操作码指出指令中该指令应该执行什么性质的操作和具有何种功能。</li><li>操作码是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。例如，指出是算术加运算，还是减运算；是程序转移，还是返回操作。</li></ul> 
</blockquote> 
<ol><li>定长操作码：在指令字的最高位部分分配固定的若干位（定长）表示操作码。<br> 一般 n 位操作码字段的指令系统最大能够表示 2<sup>n</sup> 条指令。</li></ol> 
<blockquote> 
 <p><strong>优</strong>：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利；<br> <strong>缺</strong>：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。</p> 
</blockquote> 
<ol start="2"><li>扩展操作码（不定长操作码）：全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。<br> 最常见的变长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。</li></ol> 
<blockquote> 
 <p><strong>优</strong>：在指令字长有限的前提下仍保持比较丰富的指令种类；<br> <strong>缺</strong>：增加了指令译码和分析的难度，使控制器的设计复杂化。</p> 
</blockquote> 
<h5><a id="16__96"></a>1.6 操作类型</h5> 
<ol><li>数据传送源目的</li></ol> 
<blockquote> 
 <ul><li><code>LOAD</code>作用：把<strong>存储器</strong>中（<strong>源</strong>）的数据放到<strong>寄存器</strong>中（<strong>目的</strong>）</li><li><code>STORE</code>作用：把<strong>寄存器</strong>中的数据放到<strong>存储器</strong>中</li></ul> 
</blockquote> 
<ol start="2"><li>算术逻辑操作</li></ol> 
<blockquote> 
 <ul><li>算术：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算</li><li>逻辑：与、或、非、异或、位操作、位测试、位清除、位求反</li></ul> 
</blockquote> 
<ol start="3"><li>移位操作</li></ol> 
<blockquote> 
 <p>算术移位、逻辑移位、循环移位（带进位和不带进位）</p> 
</blockquote> 
<ol start="4"><li>转移操作</li></ol> 
<blockquote> 
 <ul><li>无条件转移<code>JMP</code></li><li>条件转移<code>JZ</code>：结果为0；<code>JO</code>：结果溢出；<code>JC</code>：结果有进位</li><li>调用和返回<code>CALL</code>和<code>RETURN</code></li><li>陷阱（<code>Trap</code>）与陷阱指令</li></ul> 
</blockquote> 
<ol start="5"><li>输入输出操作</li></ol> 
<blockquote> 
 <p>CPU寄存器与IO端口之间的数据传送（端口即IO接口中的寄存器）</p> 
</blockquote> 
<p>也可以分为以下四类：</p> 
<blockquote> 
 <ul><li><strong>数据传送类</strong>：进行主存与CPU之间的数据传送</li><li><strong>运算类</strong></li><li><strong>程序控制类</strong>：改变程序执行的顺序</li><li><strong>输入输出类（I/O）</strong>：进行CPU和I/O设备之间的数据传送</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8a/ca/JlXsavHa_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__122"></a>2 数据存放指令寻址</h4> 
<h5><a id="21__123"></a>2.1 数据存放方式</h5> 
<p><img src="https://images2.imgbox.com/39/98/gsxDnxhp_o.png" alt="在这里插入图片描述"></p> 
<p>三个字长：</p> 
<blockquote> 
 <ul><li><strong>机器字长</strong>：CPU一次能处理的二进制数据的位数，受寄存器能够存放二进制位数的限制。</li><li><strong>指令字长</strong>：一个指令字中包含二进制代码的位数。</li><li><strong>存储字长</strong>：一个存储单元存储二进制代码的长度。<br> <strong>注</strong>：这三个字长没有固定大小的关系，但这些长度都是字节的整数倍</li></ul> 
</blockquote> 
<p>单字长指令：指令长度=机器字长<br> 半字长指令、双字长指令</p> 
<h5><a id="22__136"></a>2.2 指令寻址</h5> 
<p><img src="https://images2.imgbox.com/56/a2/b8excl3D_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>指令寻址</strong>：</p> 
 <blockquote> 
  <p>顺序寻址：（PC）+1→PC<br> 跳跃寻址：由转移指令指出</p> 
 </blockquote> 
</blockquote> 
<h5><a id="23__142"></a>2.3 操作数类型</h5> 
<p><img src="https://images2.imgbox.com/3d/d7/oYPoxQqO_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="24__144"></a>2.4 数据寻址</h5> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/5f/4d/Jg5kzE3o_o.png" alt="在这里插入图片描述"><br> 数据寻址即根据寻址方式的要求将形式地址转化为实际地址的过程</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c2/8d/Qk0j1L6b_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="241_150"></a>2.4.1立即寻址</h6> 
<p><strong>立即寻址</strong>：形式地址<strong>A就是操作数本身</strong>，又称为立即数，一般采用补码形式。<br> #表示立即寻址特征。<br> <img src="https://images2.imgbox.com/d1/e8/dduAwOl2_o.png" alt="在这里插入图片描述"><br> 一条指令的执行：</p> 
<blockquote> 
 <blockquote> 
  <p>取指令访存1次<br> 执行指令访存0次<br> 暂不考虑存结果<br> 共访存1次</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <ul><li><strong>优点</strong>：指令执行阶段不访问主存，指令执行时间最短</li><li><strong>缺点</strong>：A的位数限制了立即数的范围。<br> 如A的位数为 n，且立即数采用补码时，可表示的数据范围为 - 2 <sup>n</sup> - 1 ~ 2 <sup>n - 1</sup>-1</li></ul> 
</blockquote> 
<h6><a id="242__164"></a>2.4.2 直接寻址</h6> 
<p><strong>直接寻址</strong>：指令字中的形式地址A就是<strong>操作数的真实地址EA</strong>，即 EA=A。</p> 
<p><img src="https://images2.imgbox.com/ab/04/LddQnKQG_o.png" alt="在这里插入图片描述"><br> 一条指令的执行：</p> 
<blockquote> 
 <blockquote> 
  <p>取指令访存1次<br> 执行指令访存1次<br> 暂不考虑存结果<br> 共访存2次</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <ul><li><strong>优点</strong>：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址。</li><li><strong>缺点</strong>：A的位数决定了该指令操作数的寻址范围。<br> 操作数的地址不易修改。</li></ul> 
</blockquote> 
<h6><a id="243__181"></a>2.4.3 间接寻址</h6> 
<p><strong>间接寻址</strong>：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是<strong>操作数地址的地址</strong>，即 EA=（A）。</p> 
<p><img src="https://images2.imgbox.com/e5/12/qQP5GDMS_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li><strong>优点</strong>：可扩大寻址范围（有效地址<code>EA</code>的位数大于形式地址<code>A</code>的位数）。<br> 便于编制程序（用间接寻址可以方便地完成子程序返回）。</li><li><strong>缺点</strong>：指令在执行阶段要多次访存<br> 一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存。</li></ul> 
</blockquote> 
<h6><a id="244__190"></a>2.4.4 寄存器寻址</h6> 
<p><strong>寄存器寻址</strong>：在指令字中直接给出<strong>操作数所在的寄存器编号</strong>，即 EA=R<sub>i</sub>，其操作数在由R<sub>i</sub>所指的寄存器内。</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/e8/43/PoHNNWuL_o.png" alt="在这里插入图片描述"><br> 与直接寻址类似，只是把主存换成了寄存器</p> 
</blockquote> 
<p>一条指令的执行：</p> 
<blockquote> 
 <blockquote> 
  <p>取指令访存1次<br> 执行指令访存0次<br> 暂不考虑存结果<br> 共访存1次</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <ul><li><strong>优点</strong>：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算。</li><li><strong>缺点</strong>：寄存器价格昂贵，计算机中寄存器个数有限。</li></ul> 
</blockquote> 
<h6><a id="245__204"></a>2.4.5 寄存器间接寻址</h6> 
<p><strong>寄存器间接寻址</strong>：寄存器R<sub>i</sub>中给出的不是一个操作数，而是<strong>操作数所在主存单元的地址</strong>，即 EA=（R<sub>i</sub>）。<br> <img src="https://images2.imgbox.com/a3/13/vJ5Y8sII_o.png" alt="在这里插入图片描述"><br> 一条指令的执行：</p> 
<blockquote> 
 <blockquote> 
  <p>取指令访存1次<br> 执行指令访存1次<br> 暂不考虑存结果<br> 共访存2次</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <ul><li><strong>特点</strong>：与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）。</li></ul> 
</blockquote> 
<h6><a id="246__215"></a>2.4.6 隐含寻址</h6> 
<p><strong>隐含寻址</strong>：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。<br> <img src="https://images2.imgbox.com/90/af/BjmmZssS_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li><strong>优点</strong>：有利于缩短指令字长。</li><li><strong>缺点</strong>：需增加存储操作数或隐含地址的硬件。</li></ul> 
</blockquote> 
<p><strong>小结</strong>：</p> 
<table><thead><tr><th>寻址方式</th><th>有效地址</th><th>访存次数（指令执行期间）</th></tr></thead><tbody><tr><td>隐含寻址</td><td>程序待定</td><td>0</td></tr><tr><td>立即寻址</td><td>A即是操作数</td><td>0</td></tr><tr><td>直接寻址</td><td>EA=A</td><td>1</td></tr><tr><td>一次间接寻址</td><td>EA=(A)</td><td>2</td></tr><tr><td>寄存器寻址</td><td>EA=R<sub>i</sub></td><td>0</td></tr><tr><td>寄存器间接一次寻址</td><td>EA=（R<sub>i</sub>）</td><td>1</td></tr></tbody></table> 
<h5><a id="25_2_235"></a>2.5 数据寻址-2偏移寻址</h5> 
<p><img src="https://images2.imgbox.com/3a/82/W6UjxkaE_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="251__237"></a>2.5.1 基址寻址</h6> 
<p><strong>基址寻址</strong>：将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即<mark>EA=（BR）+A</mark><br> <img src="https://images2.imgbox.com/a3/55/fiLoWKTJ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>注</strong>：基址寄存器是<strong>面向操作系统</strong>的，其内容由操作系统或管理程序确定。<br> 在程序执行过程中，<strong>基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）</strong>。</p> 
</blockquote> 
<p>当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。</p> 
<blockquote> 
 <ul><li><strong>优点</strong>：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）；<br> 用户不必考虑自己的程序存于主存的哪一空间区域，故<strong>有利于多道程序设计</strong>，以及可用于编制浮动程序。</li></ul> 
</blockquote> 
<h6><a id="252__249"></a>2.5.2 变址寻址</h6> 
<p><strong>变址寻址</strong>：有效地址<code>EA</code>等于指令字中的形式地址<code>A</code>与变址寄存器<code>IX</code>的内容相加之和，即<mark>EA=（IX）+A</mark>，其中<code>IX</code>为变址寄存器（专用），也可用通用寄存器作为变址寄存器。<br> <img src="https://images2.imgbox.com/75/cd/U6w17sNa_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>注</strong>：变址寄存器是<strong>面向用户</strong>的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。</p> 
</blockquote> 
<blockquote> 
 <ul><li><strong>优点</strong>：可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）；<br> 在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器<code>IX</code>的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。</li></ul> 
</blockquote> 
<blockquote> 
 <p>变址寻址与基址寻址配合使用：<code>EA=A+（BR）+（IX）</code><br> 变址寻址与间接寻址配合使用：</p> 
 <ul><li>如先变址后间址，<code>EA=（A+（IX））</code>；</li><li>先间址后变址，<code>EA=（A）+（IX）</code>。</li></ul> 
</blockquote> 
<h6><a id="253__263"></a>2.5.3 相对寻址</h6> 
<p><strong>相对寻址</strong>：把程序计数器<code>PC</code>的内容加上指令格式中的形式地址<code>A</code>而形成操作数的有效地址，即<mark>EA=（PC）+A</mark>，其中<code>A</code>是相对于当前指令地址的位移量，可正可负，补码表示。</p> 
<p><img src="https://images2.imgbox.com/bc/df/PqgaqF28_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li><strong>优点</strong>：操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动。。<br> 相对寻址广泛应用于转移指令。</li></ul> 
</blockquote> 
<h6><a id="254__270"></a>2.5.4 相对寻址举例</h6> 
<p>某机器指令字长为16位，主存按字节编址，取指令时，<strong>每取一个字节</strong>PC自动加1。当前指令地址为2000H，指令内容为<strong>相对寻址</strong>的无条件转移指令，指令中第一个字节为操作码，第二个字节为形式地址，当前形式地址为40H。<br> （1）求取指令后及指令执行后PC内容。<br> （2）若要求转移到1F00H，求形式地址的内容。</p> 
<blockquote> 
 <p>（1）PC中一开始存放2000H，<strong>多字节指令</strong>，第一次取出的是操作码，PC更新为2001H，在2001H中取出地址码，取数过程结束，PC更新为2002H</p> 
 <blockquote> 
  <p>CPU分析指令的结果：是一条无条件转移指令，<code>EA=（PC）+A =2002H+40H =2042H</code><br> 故取指令后PC内容为2002H，指令执行后PC内容为2042H</p> 
 </blockquote> 
</blockquote> 
<blockquote> 
 <p>（2）即<code>（PC）+A=2002H+A=1F00H</code><br> <code>A=1F00H-2002H=1EFFH+1H-2002H =1EFFH-2002H+1H=FEFDH+1H=FEFEH</code></p> 
 <blockquote> 
  <p><strong>说明</strong>：（1EFFH-2002H=FEFDH，F（15）-2=13→D，1-2 不够减，向上借位，若是10进制，+10，这是16进制，+16为17,17-2=15,15的16进制就是F）<br> 形式地址就是偏移量</p> 
 </blockquote> 
</blockquote> 
<h6><a id="255__289"></a>2.5.5 寻址方式小结</h6> 
<table><thead><tr><th>寻址方式</th><th>有效地址</th><th>访存次数（指令执行期间）</th></tr></thead><tbody><tr><td>隐含寻址</td><td>程序待定</td><td>0</td></tr><tr><td>立即寻址</td><td>A即是操作数</td><td>0</td></tr><tr><td>直接寻址</td><td>EA=A</td><td>1</td></tr><tr><td>一次间接寻址</td><td>EA=(A)</td><td>2</td></tr><tr><td>寄存器寻址</td><td>EA=R<sub>i</sub></td><td>0</td></tr><tr><td>寄存器间接一次寻址</td><td>EA=（R<sub>i</sub>）</td><td>1</td></tr><tr><td>相对寻址</td><td>EA=（PC）+A</td><td>1</td></tr><tr><td>基址寻址</td><td>EA=（BR）+A</td><td>1</td></tr><tr><td>变址寻址</td><td>EA=（IX）+A</td><td>1</td></tr></tbody></table> 
<blockquote> 
 <ul><li><strong>相对寻址</strong>：指令中的形式地址给出一个位移量A，基准地址由<strong>程序计数器PC</strong>提供，通常用于转移指令中转移目标或公共子程序中的操作数的寻址</li><li><strong>变址寻址</strong>：通常用于<strong>循环体</strong>中对数组元素的访问</li></ul> 
</blockquote> 
<h6><a id="256__304"></a>2.5.6 堆栈寻址</h6> 
<blockquote> 
 <p><strong>堆栈寻址</strong>：操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址。</p> 
 <blockquote> 
  <p>堆栈是存储器（或专用寄存器组）中一块特定的按后进先出（<code>LIFO</code>）原则管理的<strong>存储区</strong>，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。</p> 
 </blockquote> 
</blockquote> 
<p><img src="https://images2.imgbox.com/bd/b8/H0l1gx0e_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="26_CISCRISC_312"></a>2.6 CISC和RISC</h5> 
<blockquote> 
 <p><code>CISC:Complex Instruction Set Computer</code>（复杂指令系统计算机）</p> 
 <ul><li>设计思路：一条指令完成一个复杂的基本功能。</li><li>代表：×86架构，主要用于笔记本、台式机等</li></ul> 
</blockquote> 
<blockquote> 
 <p><code>RISC:Reduced Instruction Set Computer</code>（精简指令系统计算机）</p> 
 <ul><li>设计思路：一条指令完成一个基本“动作”；多条指令组合完成一个复杂的基本功能。</li><li>代表：ARM架构，主要用于手机、平板等</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/94/76/5f1qtY3m_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="27__323"></a>2.7 指令系统小结</h5> 
<p><img src="https://images2.imgbox.com/0e/0c/c2tTjXab_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c02e9a633c94d8b403b2996e80725b5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue 表单验证由异步变更为同步</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0808c35eeeaef7bf8cdcc4fbe03edd38/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">bootstrop</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>