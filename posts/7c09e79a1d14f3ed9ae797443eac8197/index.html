<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[数据结构]----顺序表 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[数据结构]----顺序表" />
<meta property="og:description" content="目录
1.线性表的介绍
2.顺序表
2.1顺序表的概念及结构
2.2静态顺序表
2.3动态顺序表
2.3.1动态顺序表的定义
2.3.2动态顺序表的初始化
2.3.3动态循序表的销毁
2.3.4检查动态顺序表空间,满了则增容
2.3.5动态顺序表的尾插和尾删
2.3.6动态顺序表的头插和头删
2.3.7在动态顺序表中查找某个数
2.3.8动态顺序表在pos位置插入x
2.3.9动态顺序表删除pos位置的值
1.线性表的介绍 线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...
线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储 2.顺序表 顺序表是数据结构中给的单独的名字，严格来说顺序表就是数组
2.1顺序表的概念及结构 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。
注：顺序表要求数据是连续存储的 、
2.2静态顺序表 使用定长数组存储元素
我们可以用宏（define）来控制数组大小，方便修改数组大小
因为要控制数组是连续存储的 我们需要用size来控制存储顺序
下面是静态顺序表的定义
#define N 100 typedef int DataType typedef struct StaticSeqList { DataType a[N]; int size;// 记录存储多少个有效数据 }SSL; 静态顺序表的增删查改就是数组的移动
静态顺序表的初始化：
void init_SSL(SSL* slt) { slt-&gt;size = 0; } 静态顺序表的后插：
void insert_SSL(SSL* slt, DataType x) { if (slt-&gt;size == N) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7c09e79a1d14f3ed9ae797443eac8197/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-05T16:17:11+08:00" />
<meta property="article:modified_time" content="2022-11-05T16:17:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[数据结构]----顺序表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1.%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">1.线性表的介绍</a></p> 
<p id="2.%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:0px;"><a href="#2.%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">2.顺序表</a></p> 
<p id="2.1%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.1%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">2.1顺序表的概念及结构</a></p> 
<p id="2.2%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.2%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">2.2静态顺序表</a></p> 
<p id="2.3%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.3%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">2.3动态顺序表</a></p> 
<p id="%C2%A02.3.1%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%C2%A02.3.1%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">2.3.1动态顺序表的定义</a></p> 
<p id="2.3.2%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#2.3.2%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2.3.2动态顺序表的初始化</a></p> 
<p id="2.3.3%E5%8A%A8%E6%80%81%E5%BE%AA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#2.3.3%E5%8A%A8%E6%80%81%E5%BE%AA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">2.3.3动态循序表的销毁</a></p> 
<p id="%C2%A02.3.4%E6%A3%80%E6%9F%A5%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A9%BA%E9%97%B4%2C%E6%BB%A1%E4%BA%86%E5%88%99%E5%A2%9E%E5%AE%B9-toc" style="margin-left:80px;"><a href="#%C2%A02.3.4%E6%A3%80%E6%9F%A5%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A9%BA%E9%97%B4%2C%E6%BB%A1%E4%BA%86%E5%88%99%E5%A2%9E%E5%AE%B9" rel="nofollow">2.3.4检查动态顺序表空间,满了则增容</a></p> 
<p id="2.3.5%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B0%BE%E6%8F%92%E5%92%8C%E5%B0%BE%E5%88%A0-toc" style="margin-left:80px;"><a href="#2.3.5%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B0%BE%E6%8F%92%E5%92%8C%E5%B0%BE%E5%88%A0" rel="nofollow">2.3.5动态顺序表的尾插和尾删</a></p> 
<p id="2.3.6%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92%E5%92%8C%E5%A4%B4%E5%88%A0-toc" style="margin-left:80px;"><a href="#2.3.6%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92%E5%92%8C%E5%A4%B4%E5%88%A0" rel="nofollow">2.3.6动态顺序表的头插和头删</a></p> 
<p id="2.3.7%E5%9C%A8%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.3.7%E5%9C%A8%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E6%95%B0" rel="nofollow">2.3.7在动态顺序表中查找某个数</a></p> 
<p id="2.3.8%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5x-toc" style="margin-left:80px;"><a href="#2.3.8%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5x" rel="nofollow">2.3.8动态顺序表在pos位置插入x</a></p> 
<p id="2.3.9%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%80%BC-toc" style="margin-left:80px;"><a href="#2.3.9%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%80%BC" rel="nofollow">2.3.9动态顺序表删除pos位置的值</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="1.%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D"><strong>1.<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">线性表的介绍</span></span></strong></h2> 
<blockquote> 
 <p><strong>线性表（linear list）是<span style="color:#fe2c24;">n个具有相同特性的数据元素的有限序列</span>。 线性表是一种在实际中广泛使用的数据结构，常见的线性表：<span style="color:#fe2c24;">顺序表、链表、栈、队列、字符串</span>...</strong></p> 
 <p><br><strong>线性表在逻辑上是<span style="color:#956fe7;">线性结构</span>，也就说是<span style="color:#a2e043;">连续的一条直线</span>。但是在<span style="color:#956fe7;">物理结构上并不一定是连续的</span>，线性表在物理上存储时，通常以<span style="color:#fe2c24;">数组</span>和<span style="color:#fe2c24;">链式结构</span>的形式存储 </strong></p> 
</blockquote> 
<p><img alt="" height="372" src="https://images2.imgbox.com/23/e8/uiYIMfnV_o.png" width="911"></p> 
<h2 id="2.%E9%A1%BA%E5%BA%8F%E8%A1%A8"><strong>2.<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">顺序表</span></span></strong></h2> 
<blockquote> 
 <p><strong>顺序表是数据结构中给的单独的名字，严格来说顺序表就是数组</strong></p> 
</blockquote> 
<h3 id="2.1%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84"><strong>2.1<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">顺序表的概念及结构</span></span></strong></h3> 
<blockquote> 
 <p><strong>顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下<span style="color:#fe2c24;">采用数组存储</span>。在数组上完成数据的增删查改。</strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#f9eda6;">注：顺序表要求数据是</span></strong></span><span style="color:#956fe7;"><strong><span style="background-color:#f9eda6;">连续存储</span></strong></span><span style="color:#fe2c24;"><strong><span style="background-color:#f9eda6;">的</span></strong></span> 、</p> 
<h3 id="2.2%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8"><strong>2.2<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">静态顺序表</span></span></strong></h3> 
<blockquote> 
 <p><strong>使用<span style="color:#fe2c24;">定长数组</span>存储元素</strong></p> 
</blockquote> 
<p><strong>我们可以用宏（define）来控制数组大小，方便修改数组大小</strong></p> 
<p><strong>因为要控制数组是连续存储的 我们需要用<span style="color:#fe2c24;">size</span>来控制存储顺序</strong></p> 
<p class="img-center"><img alt="" height="384" src="https://images2.imgbox.com/d6/27/DAVByA0n_o.png" width="503"></p> 
<p> </p> 
<p> </p> 
<p><strong>下面是静态顺序表的定义</strong></p> 
<pre><code class="language-cpp">#define N 100
typedef int DataType
typedef struct StaticSeqList
{
	DataType a[N];
	int size;// 记录存储多少个有效数据
}SSL;</code></pre> 
<p><strong>静态顺序表的增删查改就是数组的移动</strong></p> 
<p></p> 
<p><strong>静态顺序表的初始化：</strong></p> 
<pre><code class="language-cpp">void init_SSL(SSL* slt)
{
	slt-&gt;size = 0;
}</code></pre> 
<p><strong>静态顺序表的后插：</strong><br>  </p> 
<pre><code class="language-cpp">void insert_SSL(SSL* slt, DataType x)
{
    if (slt-&gt;size == N)
    {
        printf("顺序表是满的!"); exit(1);
    }
    slt-&gt;a[slt-&gt;size] = x;
    slt-&gt;size = slt-&gt;size + 1;
}</code></pre> 
<p><strong>静态顺序表的打印：</strong></p> 
<pre><code class="language-cpp">void print_SSL(SSL slt)
{
    int i;
    if (!slt.size)
        printf("\n顺序表是空的!");
    else
    for (i = 0; i &lt; slt.size; i++)
        printf("%5d", slt.a[i]);
}</code></pre> 
<p></p> 
<blockquote> 
 <p><strong>但由于静态顺序表的N是规定死的，就导致它具有局限性，存储数据满的时候会造成越界，所以<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">静态顺序表不太实用，用的很少</span></span>，所以这里不展示更多的静态顺序表的算法</strong></p> 
</blockquote> 
<h3 id="2.3%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8"><strong>2.3<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">动态顺序表</span></span></strong></h3> 
<blockquote> 
 <p><strong>使用<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">动态开辟</span></span>的数组存储</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>静态顺序表只适用于确定知道需要存多少数据的场景。</strong></p> 
 <p></p> 
 <p><span style="color:#956fe7;"><strong>静态顺序表的定长数组导致N定大了，空间开多了浪费，开少了不够用。</strong></span></p> 
 <p></p> 
 <p><strong>所以<span style="color:#fe2c24;">现实中基本都是使用动态顺序表</span>，根据需要动态的分配空间大小，所以下面我们实现动态顺序表 </strong></p> 
</blockquote> 
<p class="img-center"><img alt="" height="342" src="https://images2.imgbox.com/0a/5a/bRZLQtp0_o.png" width="521"></p> 
<h4 id="%C2%A02.3.1%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><strong> 2.3.1<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">动态顺序表的定义</span></span></strong></h4> 
<pre><code class="language-cpp">typedef struct Seqlist
{
	Datatype* a; // 指向动态开辟的数组
	int size;    // 有效数据个数
	int capacity;// 容量空间的大小
}SL;</code></pre> 
<h4 id="2.3.2%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><strong>2.3.2<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">动态顺序表的初始化</span></span></strong></h4> 
<blockquote> 
 <p><strong>注：<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">我们在传递动态顺序表时，不要传结构体变量，而应该传结构体指针 </span></span></strong></p> 
</blockquote> 
<p><strong>原因：传结构体变量会导致函数内部创建一个新局部结构体变量 ，而初始化完后，局部变量被销毁，形参的改变不会影响实参，所以我们需要传地址</strong></p> 
<p></p> 
<p><strong> 函数接口声明：</strong></p> 
<pre><code class="language-cpp">void SeqlistInit(SL* phead);</code></pre> 
<p><strong>函数接口定义： </strong> </p> 
<pre><code class="language-cpp">void SeqlistInit(SL* phead)
{
	assert(phead);//断言空指针
	phead-&gt;a = NULL;
	phead-&gt;capacity = phead-&gt;size = 0;
}
</code></pre> 
<h4 id="2.3.3%E5%8A%A8%E6%80%81%E5%BE%AA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81"><span style="color:#0d0016;"><strong>2.3.3</strong></span><span style="color:#fe2c24;"><strong><span style="background-color:#f9eda6;">动态循序表的销毁</span></strong></span></h4> 
<blockquote> 
 <p><strong>先<span style="color:#fe2c24;">释放掉realloc申请的内存</span></strong></p> 
 <p></p> 
 <p><strong>再将指向数组首地址的<span style="color:#956fe7;">指针置空 </span></strong></p> 
</blockquote> 
<p><strong> 函数接口声明：</strong> </p> 
<pre><code class="language-cpp">void SeqlistDestroy(SL* phead);</code></pre> 
<p><strong>函数接口定义： </strong> </p> 
<pre><code class="language-cpp">void SeqlistDestroy(SL* phead)
{
	assert(phead);
	free(phead-&gt;a);
	phead-&gt;a = NULL;
	phead-&gt;capacity = phead-&gt;size = 0;
}</code></pre> 
<h4 id="%C2%A02.3.4%E6%A3%80%E6%9F%A5%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A9%BA%E9%97%B4%2C%E6%BB%A1%E4%BA%86%E5%88%99%E5%A2%9E%E5%AE%B9"> <strong>2.3.4<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">检查动态顺序表空间,满了则增容</span></span></strong></h4> 
<blockquote> 
 <p><strong>在我们进行顺序表的增删查改之前，我们应该想到静态顺序表的缺点，就是不能自动增容顺序表，而在动态顺序表中我们进行这些操作之前需要进行空间的检查</strong></p> 
</blockquote> 
<p><strong> 函数接口声明：</strong> </p> 
<pre><code class="language-cpp">void CheckCapacity(SL* phead)</code></pre> 
<p><strong>在动态顺序表<span style="color:#956fe7;">第一次进行开辟空间时，我们通过realloc函数开辟4个int类型的空间</span>，此后<span style="color:#fe2c24;">每当容量满时，新容量就扩大二倍</span></strong></p> 
<p><strong>在动态开辟数组时，我们用到realloc函数，<span style="color:#956fe7;">realloc函数将参数中的指针进行扩容</span>，但有可能扩容失败返回空指针（扩容内存很大），此时我们需要检查一下</strong></p> 
<pre><code class="language-cpp">void CheckCapacity(SL* phead)
{
	if (phead-&gt;size == phead-&gt;capacity)
	{
		int newcapacity = phead-&gt;capacity == 0 ? 4 : 2 * phead-&gt;capacity;
		Datatype* tmp = (Datatype*)realloc(phead-&gt;a, newcapacity * sizeof(Datatype));
		if (tmp == NULL)
		{
			perror("realloc fail\n");
			exit(-1);
		}
		phead-&gt;a = tmp;
		phead-&gt;capacity = newcapacity;
	}
}</code></pre> 
<h4 id="2.3.5%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B0%BE%E6%8F%92%E5%92%8C%E5%B0%BE%E5%88%A0"><strong>2.3.5<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">动态顺序表的尾插和尾删</span></span></strong></h4> 
<p><span style="color:#fe2c24;"><strong>尾插</strong></span>：</p> 
<blockquote> 
 <p><strong>尾插很简单，就是<span style="color:#fe2c24;">在顺序表size的位置插入，插入后size++</span>，<span style="color:#956fe7;">注意在插入前对动态顺序表进行容量的检查，防止空间溢出</span></strong></p> 
</blockquote> 
<p><strong> 函数接口声明：</strong> </p> 
<pre><code class="language-cpp">void SeqlistPushBack(SL* phead,Datatype x);</code></pre> 
<p><strong>函数接口定义： </strong> </p> 
<pre><code class="language-cpp">void SeqlistPushBack(SL* phead, Datatype x)
{
	assert(phead);

	CheckCapacity(phead);
	phead-&gt;a[phead-&gt;size] = x;
	(phead-&gt;size)++;
}</code></pre> 
<p><strong><span style="color:#fe2c24;">尾删</span>：</strong></p> 
<blockquote> 
 <p><strong>这里就直接把<span style="color:#fe2c24;">size-1</span>让顺序表访问不到这个位置就行，<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">注意在尾删前，检查断言指针不为空</span></span></strong></p> 
</blockquote> 
<p><strong> 函数接口声明：</strong> </p> 
<pre><code class="language-cpp">void SeqlistPopBack(SL* phead);</code></pre> 
<p><strong>函数接口定义： </strong> </p> 
<pre><code class="language-cpp">void SeqlistPopBack(SL* phead)
{
	assert(phead);

	assert(phead-&gt;size);
	phead-&gt;size--;
}</code></pre> 
<h4 id="2.3.6%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92%E5%92%8C%E5%A4%B4%E5%88%A0"><span style="color:#0d0016;"><strong>2.3.6</strong></span><span style="color:#fe2c24;"><strong><span style="background-color:#f9eda6;">动态顺序表的头插和头删</span></strong></span></h4> 
<p><strong>头插：</strong></p> 
<blockquote> 
 <p><strong>头插需要先在头插前 <span style="color:#a2e043;">先进行顺序表的容量检查</span>，其次<span style="color:#956fe7;">需要先移动整个顺序表，把顺序表每个位置的值向后移动一位</span>，然后<span style="color:#38d8f0;">再在0的位置插入值</span></strong></p> 
</blockquote> 
<p><strong> 函数接口声明：</strong> </p> 
<pre><code class="language-cpp">void SeqlistPushFront(SL* phead, Datatype x);
</code></pre> 
<p><strong>函数接口定义： </strong> </p> 
<pre><code class="language-cpp">void SeqlistPushFront(SL* phead, Datatype x)
{
	assert(phead);

	CheckCapacity(phead);
	for (int i = phead-&gt;size; i &gt; 0; i--)
	{
		phead-&gt;a[i] = phead-&gt;a[i - 1];
	}
	phead-&gt;a[0] = x;
	phead-&gt;size++;
}</code></pre> 
<p><strong>头删：</strong></p> 
<blockquote> 
 <p><strong> 头删则需要<span style="color:#fe2c24;">先检查顺序表是否为空</span>，<span style="color:#956fe7;">然后再把顺序表中1-size-1的数据向前移动一位</span>，最后<span style="color:#38d8f0;">size再--</span></strong></p> 
</blockquote> 
<p><strong> 函数接口声明：</strong> </p> 
<pre><code class="language-cpp">void SeqlistPopFront(SL* phead);
</code></pre> 
<p><strong>函数接口定义： </strong> </p> 
<pre><code class="language-cpp">void SeqlistPopFront(SL* phead)
{
	assert(phead);

	assert(phead-&gt;size);
	for (int i = 1; i &lt; phead-&gt;size; i++)
	{
		phead-&gt;a[i - 1] = phead-&gt;a[i];
	}
	phead-&gt;size--;
}</code></pre> 
<p></p> 
<h4 id="2.3.7%E5%9C%A8%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E6%95%B0"><strong>2.3.7<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">在动态顺序表中查找某个数</span></span></strong></h4> 
<blockquote> 
 <p><strong>断言指针不为空</strong></p> 
 <p><strong>直接<span style="color:#fe2c24;">遍历顺序表，找到值则返回元素下标</span>，找不到则说明</strong></p> 
</blockquote> 
<p><strong> 函数接口声明：</strong> </p> 
<pre><code class="language-cpp">void SeqlistFind(SL* phead, Datatype x);
</code></pre> 
<p><strong>函数接口定义： </strong> </p> 
<pre><code class="language-cpp">void SeqlistFind(SL* phead, Datatype x)
{
	assert(phead);
	for (int i = 0; i &lt; phead-&gt;size; i++)
	{
		if (phead-&gt;a[i] == x)
		{
			printf("找到了，是顺序表的第%d个元素\n",i+1);
			return;
		}
	}
	printf("没找到，无此数字\n");
}</code></pre> 
<h4 id="2.3.8%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5x"><strong>2.3.8<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">动态顺序表在pos位置插入x</span></span></strong></h4> 
<blockquote> 
 <p><strong>首先<span style="color:#fe2c24;">判断pos的值小于size</span>，并且<span style="color:#fe2c24;">进行判空操作</span></strong></p> 
 <p></p> 
 <p><span style="color:#956fe7;"><strong>再将pos及pos之后的位置的值向后移动一位，移动前判容量</strong></span></p> 
 <p></p> 
 <p><span style="color:#38d8f0;"><strong>最后直接将值插在pos位置，size++</strong></span></p> 
</blockquote> 
<p><strong> 函数接口声明：</strong> </p> 
<pre><code class="language-cpp">void SeqlistInsert(SL* phead, size_t pos, Datatype x);
</code></pre> 
<p><strong>函数接口定义： </strong> </p> 
<pre><code class="language-cpp">void SeqlistInsert(SL* phead, size_t pos, Datatype x)
{
	assert(phead);
	assert(pos &lt;= phead-&gt;size);
	CheckCapacity(phead);

	size_t end = phead-&gt;size;
	while (end &gt; pos)
	{
		phead-&gt;a[end] = phead-&gt;a[end - 1];
		end--;
	}
	phead-&gt;a[pos] = x;
	phead-&gt;size++;
}</code></pre> 
<h4 id="2.3.9%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%80%BC"><strong>2.3.9<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">动态顺序表删除pos位置的值</span></span></strong></h4> 
<blockquote> 
 <p><strong>首先<span style="color:#fe2c24;">判断pos的值小于size</span>，并且<span style="color:#fe2c24;">进行判空操作</span></strong></p> 
 <p></p> 
 <p><span style="color:#956fe7;"><strong>再将pos后面的值（不包括pos位置），向前移动一位（这样原本pos位置的值就被覆盖）</strong></span></p> 
 <p></p> 
 <p><span style="color:#38d8f0;"><strong>再size--</strong></span></p> 
</blockquote> 
<p><strong> 函数接口声明：</strong> </p> 
<pre><code class="language-cpp">void SeqlistErase(SL* phead, size_t pos);
</code></pre> 
<p><strong>函数接口定义： </strong> </p> 
<pre><code class="language-cpp">void SeqlistErase(SL* phead, size_t pos)
{
	assert(phead);
	assert(pos &lt; phead-&gt;size);
	for (int i = pos; i &lt; phead-&gt;size-1; i++)
	{
		phead-&gt;a[i] = phead-&gt;a[i + 1];
	}
	phead-&gt;size--;
}
</code></pre> 
<p>2.3.10改变动态顺序表pos位置的值</p> 
<blockquote> 
 <p><strong>首先<span style="color:#fe2c24;">判断pos的值小于size</span>，并且<span style="color:#fe2c24;">进行判空操作</span></strong></p> 
 <p></p> 
 <p><span style="color:#956fe7;"><strong>然后直接修改值即可</strong></span></p> 
</blockquote> 
<p><strong> 函数接口声明：</strong> </p> 
<pre><code class="language-cpp">void SeqlistModify(SL* phead, size_t pos, Datatype x);</code></pre> 
<p><strong>函数接口定义： </strong></p> 
<pre><code class="language-cpp">void SeqlistModify(SL* phead, size_t pos, Datatype x)
{
	assert(phead);
	assert(pos &lt; phead-&gt;size);
	phead-&gt;a[pos] = x;
}
</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c619825ffa624a3c69dddbf8e176975/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp跳转微信小程序（5&#43;app通用）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3117c27d22dab56f2c1ce527737b99d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">My Publications</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>