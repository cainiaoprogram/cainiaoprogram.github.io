<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 智能指针常用总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; 智能指针常用总结" />
<meta property="og:description" content="C&#43;&#43; 智能指针常用总结 文章目录 C&#43;&#43; 智能指针常用总结1. 写在对前面2. why 智能指针3. what 智能指针3.1 unique_ptr3.2 shared_ptr3.3 weak_ptr 3. how 指针指针3.1 unique_ptr3.1.1 创建3.1.2 成员函数 3.2 shared_ptr3.2.1创建3.2.2 成员对象 3.3 weak_ptr 4. 碎碎念5.参考资料 1. 写在对前面 最近接了一个写 c&#43;&#43; 的任务，在使用智能指针的时候，写出一个 dump 的 bug。作为 golang 小白在入门 c&#43;&#43; 的必经之路。整理一份 c&#43;&#43; 智能指针的常用知识点。全文按照如下思路整理
why 智能指针
what 智能指针
how 智能指针
智能指针是 C&#43;&#43; 中用于管理动态分配对象的一种特殊指针。它能够自动管理对象的生命周期。避免内存泄漏和野指针的问题。
2. why 智能指针 「一种特性的提出，势必是为了解决某类难以解决的问题。」在智能指针提出之前，C&#43;&#43; 是通过手动分配和释放内存来进行管理的。使用如下两个关键字进行分配和释放内存：
new：用于分配动态内存。通过使用 new 关键字，可以在堆上分配指定大小的内存，并返回指向新分配的内存的指针。例如，可以使用 int* p = new int; 来分配一个整数的内存，并将指向该内存的指针存储在变量 p 中。
delete：用于释放动态内存。使用 delete 关键字，可以释放通过 new 关键字分配的内存。例如，可以使用 delete p; 来释放变量 p 指向的整数内存。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c146ffb4abd47347e53ce32b57b55957/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-20T21:25:12+08:00" />
<meta property="article:modified_time" content="2023-10-20T21:25:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 智能指针常用总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="C__0"></a>C++ 智能指针常用总结</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#C__0" rel="nofollow">C++ 智能指针常用总结</a></li><li><ul><li><a href="#1__2" rel="nofollow">1. 写在对前面</a></li><li><a href="#2_why__15" rel="nofollow">2. why 智能指针</a></li><li><a href="#3_what__30" rel="nofollow">3. what 智能指针</a></li><li><ul><li><a href="#31_unique_ptr_49" rel="nofollow">3.1 unique_ptr</a></li><li><a href="#32_shared_ptr_57" rel="nofollow">3.2 shared_ptr</a></li><li><a href="#33_weak_ptr_70" rel="nofollow">3.3 weak_ptr</a></li></ul> 
   </li><li><a href="#3_how__96" rel="nofollow">3. how 指针指针</a></li><li><ul><li><a href="#31_unique_ptr_98" rel="nofollow">3.1 unique_ptr</a></li><li><ul><li><a href="#311__100" rel="nofollow">3.1.1 创建</a></li><li><a href="#312__158" rel="nofollow">3.1.2 成员函数</a></li></ul> 
    </li><li><a href="#32_shared_ptr_172" rel="nofollow">3.2 shared_ptr</a></li><li><ul><li><a href="#321_174" rel="nofollow">3.2.1创建</a></li><li><a href="#322__234" rel="nofollow">3.2.2 成员对象</a></li></ul> 
    </li><li><a href="#33_weak_ptr_248" rel="nofollow">3.3 weak_ptr</a></li></ul> 
   </li><li><a href="#4__252" rel="nofollow">4. 碎碎念</a></li><li><a href="#5_263" rel="nofollow">5.参考资料</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1__2"></a>1. 写在对前面</h3> 
<p>最近接了一个写 c++ 的任务，在使用智能指针的时候，写出一个 dump 的 bug。作为 golang 小白在入门 c++ 的必经之路。整理一份 c++ 智能指针的常用知识点。全文按照如下思路整理</p> 
<ul><li> <p>why 智能指针</p> </li><li> <p>what 智能指针</p> </li><li> <p>how 智能指针</p> </li></ul> 
<p>智能指针是 C++ 中用于管理动态分配对象的一种特殊指针。它能够自动管理对象的生命周期。避免内存泄漏和野指针的问题。</p> 
<h3><a id="2_why__15"></a>2. why 智能指针</h3> 
<p>「<font color="red">一种特性的提出，势必是为了解决某类难以解决的问题。</font>」在智能指针提出之前，C++ 是通过手动分配和释放内存来进行管理的。使用如下两个关键字进行分配和释放内存：</p> 
<ul><li> <p>new：用于分配动态内存。通过使用 new 关键字，可以在堆上分配指定大小的内存，并返回指向新分配的内存的指针。例如，可以使用 <code>int* p = new int; </code>来分配一个整数的内存，并将指向该内存的指针存储在变量 p 中。</p> </li><li> <p>delete：用于释放动态内存。使用 delete 关键字，可以释放通过 new 关键字分配的内存。例如，可以使用 <code>delete p;</code> 来释放变量 p 指向的整数内存。</p> </li></ul> 
<p>这种原始的内存管理方式需要程序员手动追踪和管理分配和释放的内存，容易引发一系列问题，比如内存泄漏、重复释放、野指针等。因此，为了简化内存管理的过程并减少错误，C++ 引入智能指针和 RAII (资源获取即初始化) 等方式来自动管理和释放内存。</p> 
<blockquote> 
 <p>注：资源获取即初始化(Resource Acquisition Is Initialization，RAII) 是一种 C++ 编程技术，通过在对象的构造函数中获取资源，并在析构函数中释放资源，以确保资源在对象生命周期内始终被争取管理。</p> 
 <p>RAII 的核心思想，将资源的生命周期与对象的生命周期绑定在一起。当对象被创建时，它获取了所需的资源；当对象被销毁时，它释放了持有的资源。</p> 
</blockquote> 
<h3><a id="3_what__30"></a>3. what 智能指针</h3> 
<p>智能指针有多种实现，包括 std::shared_ptr、std::unique_ptr 和 std::weak_ptr。要理解这三类智能指针，需要从「对象所有权」的概念入手。</p> 
<ol><li> <p>每个独占的资源都应该有一个所有者 owner。</p> </li><li> <p>被共享的资源需要通过引用计数来管理。对应的实现是 shared_ptr。</p> </li><li> <p>借用资源的时候，可以使用 raw point 或者引用。但更推荐使用引用</p> </li><li> <p>如果有循环引用，需要打破循环，可能的办法有借助 weak pointer。</p> </li><li> <p>资源的所有权可以被转移，比如 move。</p> </li><li> <p>资源的所有者负责释放资源，资源的借用者不能释放资源。</p> </li></ol> 
<p>指针解决的是第1、2、4 这三类问题。</p> 
<h4><a id="31_unique_ptr_49"></a>3.1 unique_ptr</h4> 
<p>unique_ptr 代表的是专属所有权（exclusive ownership），即由 unique_ptr 管理的内存，只能被一个对象持有。</p> 
<blockquote> 
 <p>注：大多数场景下应用到的应该是 unique_ptr</p> 
</blockquote> 
<p><strong>性能</strong>：c++ 的 zero cost abstraction 的特点，unique_ptr 在默认的情况下和裸指针的大小是一样的。所以在内存上没有任何的额外消耗，性能最优。</p> 
<h4><a id="32_shared_ptr_57"></a>3.2 shared_ptr</h4> 
<p>shared_ptr 代表共享所有权（shared ownership），即多个 shared_ptr 可以共享同一块内存。</p> 
<p><strong>性能</strong></p> 
<ul><li> <p>「内存占用高」：shared_ptr 的内存占用是裸指针的两倍。因为除了要管理一个裸指针外，还需要维护一个引用计数。</p> </li><li> <p>「原子操作性能低」：考虑到线程安全问题，引用计数的增减必须是原子操作。而原子操作一般情况下都比非原子操作慢。</p> </li><li> <p>「使用移动优化性能」：shared_ptr 在性能是虽然低于 unique_ptr。但是可以通过使用 std::move 来优化性能。在「复制 （a = b）」与「移动（a = std::move(b)）」之间，建议选择后者。因为<strong>移动不用增加引用计数</strong>。</p> </li></ul> 
<h4><a id="33_weak_ptr_70"></a>3.3 weak_ptr</h4> 
<p>weak_ptr 解决了 shared_ptr 存在的「循环引用」问题。它不会增加引用计数，也不会阻止资源的销毁。</p> 
<p><strong>避免循环引用</strong>：在对象之间存在循环引用时，使用 shared_ptr 会到导致资源无法释放。而 weak_ptr 可以打破循环引用，因为它不增加引用计数。当所有的 shared_ptr 释放之后，资源会被争取的释放。</p> 
<p>导致循环引用的示例：</p> 
<pre><code>class B;
struct A{
    shared_ptr&lt;B&gt; b;
};
struct B{
    shared_ptr&lt;A&gt; a;
};
auto pa = make_shared&lt;A&gt;();
auto pb = make_shared&lt;B&gt;();
pa-&gt;b = pb;
pb-&gt;a = pa;
</code></pre> 
<blockquote> 
 <p>注：解除循环引用只需要 struct B 中的 shared_ptr(A) 替换为 weak_ptr(A)</p> 
</blockquote> 
<p><strong>性能</strong>：weak_ptr 具有比 shared_ptr 更高的性能。但是需要注意的是，由于 weak_ptr 不会增加引用计数，所以如果想要访问对象，需要提前判断对象是否存在，防止访问空指针。</p> 
<h3><a id="3_how__96"></a>3. how 指针指针</h3> 
<h4><a id="31_unique_ptr_98"></a>3.1 unique_ptr</h4> 
<h5><a id="311__100"></a>3.1.1 创建</h5> 
<ol><li>可以通过如下两种方式，构造出 unique_ptr 类型的空指针</li></ol> 
<pre><code>std::unique_ptr&lt;int&gt; p1;          // 不传入任何实参
std::unique_ptr&lt;int&gt; p2(nullptr); // 传入空指针
</code></pre> 
<ol start="2"><li>在构建 unique_ptr 智能指针时，明确其指向</li></ol> 
<pre><code>std::unique_ptr&lt;int&gt; p3(new int(20));
</code></pre> 
<ol start="3"><li>使用 std::make_unique 模板函数，可以用于初始化 unique_ptr 智能指针</li></ol> 
<pre><code>std::unique_ptr&lt;int&gt; p4 = std::make_unique&lt;int&gt;(10);
</code></pre> 
<blockquote> 
 <p>注：std::make_unique 为 C++11 标准提供的函数</p> 
</blockquote> 
<ol start="4"><li>使用 std::move 移动构造函数</li></ol> 
<pre><code>std::unique_ptr&lt;int&gt; p5(std::move(p4))
std::unique_ptr&lt;int&gt; p5 = std::move(p4)
</code></pre> 
<blockquote> 
 <p>注：使用 std::move(p4) 初始化 p5，会使得 p5 拥有 p4 的堆内存，而 p4 则变成空智能指针</p> 
</blockquote> 
<ol start="5"><li>在初始化 unique_ptr 智能指针时，还可以自定义所指堆内存的释放规则，可以在定义的释放规则中加入自定义的释放规则，以释放默写资源</li></ol> 
<pre><code>//指定 default_delete 作为释放规则
std::unique_ptr&lt;int&gt; p6(new int[10], std::default_delete&lt;int[]&gt;());

//自定义释放规则
void deleteInt(int*p) {
    delete []p;
}

// lambda 表示缩写 deleteInt 函数
// [](int* p) {delete[]p; }

//初始化智能指针，并自定义释放规则
std::unique_ptr&lt;int&gt; p7(new int[10], deleteInt);
</code></pre> 
<p><strong>特殊说明</strong>：<strong>unique_ptr 不支持复制和赋值</strong></p> 
<pre><code>auto w = std::make_unique&lt;int&gt;();
auto w2 = w; // 编译错误
</code></pre> 
<h5><a id="312__158"></a>3.1.2 成员函数</h5> 
<table><thead><tr><th>成员方法名</th><th>功 能</th></tr></thead><tbody><tr><td>operator=()</td><td>重载赋值号</td></tr><tr><td>operator*()</td><td>重载 * 号，获取当前unique_ptr 智能指针对象指向的数据。</td></tr><tr><td>operator-&gt;()</td><td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td></tr><tr><td>release()</td><td>返回指向管理对象的指针并释放所有权。</td></tr><tr><td>reset()</td><td>替换 unique_ptr 管理的对象。</td></tr><tr><td>swap()</td><td>交换 2 个相同类型 unique_ptr 智能指针的内容。</td></tr><tr><td>get()</td><td>获得 unique_ptr 对象内部包含的普通指针。</td></tr><tr><td>get_deleter()</td><td>返回用于销毁管理对象的删除器</td></tr><tr><td>operator bool()</td><td>判断当前 unique_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td></tr></tbody></table> 
<h4><a id="32_shared_ptr_172"></a>3.2 shared_ptr</h4> 
<h5><a id="321_174"></a>3.2.1创建</h5> 
<ul><li> <p>可以通过如下两种方式，构造出 shared_ptr 类型的空指针</p> <pre><code>std::shared_ptr&lt;int&gt; p1;          // 不传入任何实参
std::shared_ptr&lt;int&gt; p2(nullptr); // 传入空指针
</code></pre> </li><li> <p>在构建 shared_ptr 智能指针时，明确其指向</p> <pre><code>std::shared_ptr&lt;int&gt; p3(new int(20));
</code></pre> </li><li> <p>使用 std::make_shared 模板函数，可以用于初始化 shared_ptr 智能指针</p> <pre><code>std::shared_ptr&lt;int&gt; p4 = std::make_shared&lt;int&gt;(10);
</code></pre> 
  <blockquote> 
   <p>注：std::make_shared 为 C++11 标准提供的函数</p> 
  </blockquote> </li><li> <p>使用 std::move 移动构造函数或者使用赋值构造</p> <pre><code>// 赋值构造
std::shared_ptr&lt;int&gt; p5(p4);
std::shared_ptr&lt;int&gt; p5 = p4;

// 移动构造
std::unique_ptr&lt;int&gt; p5(std::move(p4))
std::unique_ptr&lt;int&gt; p5 = std::move(p4)
</code></pre> 
  <blockquote> 
   <p>注：</p> 
   <p>使用赋值构造会导致引用计数加 1，同一普通指针不能同时为多个 shared_ptr 对象赋值</p> 
   <p>使用 std::move(p4) 初始化 p5，会使得 p5 拥有 p4 的堆内存，而 p4 则变成空智能指针</p> 
  </blockquote> </li><li> <p>在初始化 unique_ptr 智能指针时，还可以自定义所指堆内存的释放规则，可以在定义的释放规则中加入自定义的释放规则，以释放默写资源</p> <pre><code>//指定 default_delete 作为释放规则
std::shared_ptr&lt;int&gt; p6(new int[10], std::default_delete&lt;int[]&gt;());

//自定义释放规则
void deleteInt(int*p) {
    delete []p;
}

// lambda 表示缩写 deleteInt 函数
// [](int* p) {delete[]p; }

//初始化智能指针，并自定义释放规则
std::shared_ptr&lt;int&gt; p7(new int[10], deleteInt);
</code></pre> </li></ul> 
<h5><a id="322__234"></a>3.2.2 成员对象</h5> 
<table><thead><tr><th>成员方法名</th><th>功 能</th></tr></thead><tbody><tr><td>operator=()</td><td>重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。</td></tr><tr><td>operator*()</td><td>重载 * 号，获取当前 shared_ptr 智能指针对象指向的数据。</td></tr><tr><td>operator-&gt;()</td><td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td></tr><tr><td>swap()</td><td>交换 2 个相同类型 shared_ptr 智能指针的内容。</td></tr><tr><td>reset()</td><td>当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</td></tr><tr><td>get()</td><td>获得 shared_ptr 对象内部包含的普通指针。</td></tr><tr><td>use_count()</td><td>返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。</td></tr><tr><td>unique()</td><td>判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。</td></tr><tr><td>operator bool()</td><td>判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td></tr></tbody></table> 
<h4><a id="33_weak_ptr_248"></a>3.3 weak_ptr</h4> 
<p>weak_ptr 当前的代码库中使用的较少，后续代码用到单独总结其使用场景吧。</p> 
<h3><a id="4__252"></a>4. 碎碎念</h3> 
<p>虽然现在总结的知识都可以通过 chatgpt 问到，但是「学习」的目的在于自己学习、理解和分析，如果只是单纯的看的话，下次、下下次在遇到可能自己还是一知半解的照抄模式。</p> 
<ul><li> <p>我永远喜欢我自己，我有勇气敞开心扉去接受一起新的变化和想法，但我永远不会因为别人的反映而惶恐不安，不因外界的评价而自我怀疑，我允许自己被否定，但我无需认同，也不会在意。</p> </li><li> <p>任何人在任何时间分道扬镳很正常。</p> </li><li> <p>如果感觉有点累了，那就去喜欢的事物里喘口气。</p> </li></ul> 
<h3><a id="5_263"></a>5.参考资料</h3> 
<ul><li> <p><a href="https://www.zhihu.com/question/501350105" rel="nofollow">关于 c++ 智能指针的使用场景。智能指针能完全替代 new\delete 吗？</a></p> </li><li> <p><a href="https://zhuanlan.zhihu.com/p/374392832" rel="nofollow">什么是 move？ 理解 c++ value categories, move, move in Rust</a></p> </li><li> <p><a href="https://zhuanlan.zhihu.com/p/264855981" rel="nofollow">RAII: 如何编写没有内存泄漏的代码 with C++</a></p> </li><li> <p><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr" rel="nofollow">std::unique_ptr - cppreference.com</a></p> </li><li> <p><a href="https://c.biancheng.net/view/7898.html" rel="nofollow">C++11 shared_ptr智能指针（超级详细）</a></p> </li><li> <p><a href="https://c.biancheng.net/view/2339.html" rel="nofollow">C++转换构造函数：将其它类型转换为当前类的类型</a></p> </li><li> <p><a href="https://c.biancheng.net/view/2334.html" rel="nofollow">C++拷贝构造函数（复制构造函数）详解</a></p> </li><li> <p><a href="https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/" rel="nofollow">C++ 智能指针的正确使用方式 | 编程沉思录</a></p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9555d6a5c869007de76f086365282e02/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenCV探索之路（二十三）：特征检测和特征匹配方法汇总</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/221b175898636fd161c2d0cf8ceae4b0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Siren’s Song in the AI Ocean: A Survey on Hallucination in Large Language Models翻译</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>