<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python中变量作用域规则详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python中变量作用域规则详解" />
<meta property="og:description" content="前言 作用域是指变量的生效范围，例如本地变量、全局变量描述的就是不同的生效范围。python的变量作用域的规则非常简单，可以说是所有语言中最直观、最容易理解的作用域。
在开始介绍作用域之前，先抛一个问题：
x = 1 def f(): x = 3 g() print(&#34;f:&#34;, x) # 3 def g(): print(&#34;g:&#34;, x) # 1 f() print(&#34;main:&#34;, x) # 1 上面的代码的依次输出为：
g: 1 f: 3 main: 1 python作用域规则简介 它有4个层次的作用域范围：内部嵌套函数、包含内部嵌套函数的函数自身、全局作用域、内置作用域。上面4个作用域的范围排序是按照从内到外，从小到大排序的。如下图所示：
其中：
内置作用域是预先定义好的，在__builtins__模块中。这些名称主要是一些关键字，例如open、range、quit等；全局作用域是文件级别的，或者说是模块级别的，每个py文件中处于顶层的变量都是全局作用域范围内的变量；本地作用域是函数内部属于本函数的作用范围，因为函数可以嵌套函数，嵌套的内层函数有自身的内层范围嵌套函数的本地作用域是属于内层函数的范围，不属于外层 所以对于下面这段python代码来说，如果它处于a.py文件中，且没有嵌套在其它函数内：
# a.py X = 1 def out1(i): X = 2 Y = &#39;a&#39; print(X) print(i) def in1(n): print(n) print(X, Y) in1(3) out1(99) print(&#34;X: &#34;, X) 上述代码依次输出：
&gt;&gt;&gt; out1(99) 2 99 3 2 a &gt;&gt;&gt; print(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/669aaaa13aa6f4d92efcbdf9adf31e33/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-30T11:13:06+08:00" />
<meta property="article:modified_time" content="2019-09-30T11:13:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python中变量作用域规则详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><strong><span style="color:#f33b45;">前言</span></strong></h4> 
<p style="text-indent:0;">作用域是指变量的生效范围，例如本地变量、全局变量描述的就是不同的生效范围。python的变量作用域的规则非常简单，可以说是所有语言中最直观、最容易理解的作用域。<br> 在开始介绍作用域之前，先抛一个问题：</p> 
<pre class="has"><code class="language-python">x = 1
def f():
    x = 3
    g()
    print("f:", x)   # 3
 
def g():
    print("g:", x)   # 1
 
f()
print("main:", x)    # 1</code></pre> 
<p>上面的代码的依次输出为：</p> 
<pre class="has"><code class="language-python">g: 1
f: 3
main: 1</code></pre> 
<h4><span style="color:#f33b45;"><strong>python作用域规则简介</strong></span></h4> 
<p>它有4个层次的作用域范围：内部嵌套函数、包含内部嵌套函数的函数自身、全局作用域、内置作用域。上面4个作用域的范围排序是按照从内到外，从小到大排序的。如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/c2/fc/kYFE7mPC_o.png"></p> 
<p>其中：</p> 
<ul><li>内置作用域是预先定义好的，在__builtins__模块中。这些名称主要是一些关键字，例如open、range、quit等；</li><li>全局作用域是文件级别的，或者说是模块级别的，每个py文件中处于顶层的变量都是全局作用域范围内的变量；</li><li>本地作用域是函数内部属于本函数的作用范围，因为函数可以嵌套函数，嵌套的内层函数有自身的内层范围</li><li>嵌套函数的本地作用域是属于内层函数的范围，不属于外层</li></ul> 
<p>所以对于下面这段python代码来说，如果它处于a.py文件中，且没有嵌套在其它函数内：</p> 
<pre class="has"><code class="language-python"># a.py
X = 1
def out1(i):
    X = 2
    Y = 'a'
    print(X)
    print(i)
    
    def in1(n):
        print(n)
        print(X, Y)
    
    in1(3)

out1(99)
print("X: ", X)</code></pre> 
<p>上述代码依次输出：</p> 
<pre class="has"><code class="language-python">&gt;&gt;&gt; out1(99)
2
99
3
2 a
&gt;&gt;&gt; print("X: ", X)
X:  1</code></pre> 
<p>解释：<br> 处于全局作用域范围的变量有：X、out1<br> 处于out1本地作用域范围的变量有：i、X、Y、in1<br> 处于函数out1内部的嵌套函数in1的本地作用域范围的变量有：n</p> 
<p><u>注意上面的函数名out1和in1也是一种变量。</u></p> 
<p>如下图：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/bf/4b/uEX8Ptob_o.png"></p> 
<p> </p> 
<h4><span style="color:#f33b45;"><strong>搜索规则</strong></span></h4> 
<p>当在某个范围引用某个变量的时候，将从它所在的层次开始搜索变量是否存在，不存在则向外层继续搜索。搜索到了，则立即停止。</p> 
<p>例如函数ab()中嵌套了一个函数cd()，cd()中有一个语句print(x)，它将首先检查cd()函数的本地作用域内是否有x，如果没有则继续检查外部函数ab()的本地作用域范围内是否有x，如果没有则再次向外搜索全局范围内的变量x，如果还是没有，则继续搜索内置作用域，像"x"这种变量名，在内置作用域范围内是不存在的，所以最终没有搜索到，报错。如果一开始在cd()中就已经找到了变量x，就不会再搜索ab()范围以及更外层的范围。</p> 
<p>所以，内层范围可以引用外层范围的变量，外层范围不能引用内层范围的变量。</p> 
<h4><span style="color:#f33b45;"><strong>内置作用域</strong></span></h4> 
<p>内置作用域主要是一些内置的函数名、内置的异常等关键字。例如open，range，quit等。</p> 
<p>两种方式可以搜索内置作用域：一是直接导入builtins模块，二是让python自动搜索。导入builtins模块会让内置作用域内的变量直接置于当前文件的全局范围，自动搜索内置作用域则是最后的阶段进行搜索。</p> 
<p>一般来说无需手动导入builtins模块，不过可以看看这个模块中包含了哪些内置变量。</p> 
<pre class="has"><code class="language-python">&gt;&gt;&gt; import builtins
&gt;&gt;&gt; dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
</code></pre> 
<h4><span style="color:#f33b45;"><strong>变量掩盖和修改规则</strong></span></h4> 
<p>如果在函数内部引用了一个和全局变量同名的变量，且不是重新定义、重新赋值(其实python中没有变量声明的概念，只有赋值的概念)，那么函数内部引用的是全局变量。</p> 
<p>例如，下面的函数g()中，print函数中的变量x并未在g()中单独定义或赋值，所以这个x引用的是全局变量x，它将输出值3。</p> 
<pre class="has"><code class="language-python">x = 3
def g():
    print(x)  # 引用全局变量x</code></pre> 
<p>如果函数内部重新赋值了一个和全局变量名称相同的变量，则这个变量是本地变量，它会掩盖全局变量。注意是掩盖而非覆盖，掩盖的意思是出了函数的范围(函数退出)，全局变量就会恢复。或者换句话说，在函数内部看到的是本地变量<code>x=2</code>，在函数外部看到的是全局变量<code>x=3</code>。</p> 
<p>例如：下面的g()中重新声明了x，这个x称为g()的本地变量，全局变量<code>x=3</code>暂时被掩盖(当然，这是对该函数来说的掩盖)。</p> 
<pre class="has"><code class="language-python">x = 3
def g():
    x = 2     # 定义并赋值本地变量x
    print(x)  # 引用本地变量x</code></pre> 
<p>python是一种解释性语言，读一行解释一行，读了下一行就忘记前一行，所以在使用变量之前必须先进行变量的定义。</p> 
<p>例如下面是错误的：</p> 
<pre class="has"><code class="language-python">def g():
    print(x)
    x = 3

g()</code></pre> 
<p>错误信息：</p> 
<pre class="has"><code class="language-python">UnboundLocalError: local variable 'x' referenced before assignment</code></pre> 
<p>这个很好理解，但是下面和同名的全局变量混合的时候，就不那么容易理解了：</p> 
<pre class="has"><code class="language-python">x = 1
def g():
    print(x)
    x = 2

g()</code></pre> 
<p>这里也会报错，而不是输出1或2。</p> 
<p>这里需要解释一下，虽说python是逐行解释的。但<u><span style="color:#f33b45;">每个函数属于一个区块，这个区块范围是一次性解释的，并不会读一行忘记一行，而是一直读，读完整个区块再解释</span></u>。所以，读完整个g()区块后，首先就记住了重新定义了本地变量<code>x=2</code>，于是g()中所有使用变量x的时候，都是本地变量x，所以print(x)中的x也是本地变量，但这违反了使用变量前先赋值的规则，所以也会报错。</p> 
<p>因此，在函数内修改和全局变量同名的变量前，必须先修改，再使用该变量。所以，上面的代码中，<code>x=2</code>必须放在print的前面：</p> 
<pre class="has"><code class="language-python">x = 1
def g():
    x = 2
    print(x)

g()</code></pre> 
<p>所以，对于函数来说，也必须先定义函数，再调用函数。下面是错误的：</p> 
<pre class="has"><code class="language-python">g()
def g():
    x = 2
    print(x)</code></pre> 
<p>报错信息：</p> 
<pre class="has"><code class="language-python">NameError: name 'g' is not defined</code></pre> 
<p>但是下面的代码中，f()中先调用了g()，然后才定义g()，为什么能执行呢：</p> 
<pre class="has"><code class="language-python">x = 1
def f():
    x = 3
    g()
    print("f:",x)  # 3
 
def g():
    print("g:",x)  # 1
 
f()
print("main:",x)   # 1</code></pre> 
<p>实际上并非是先调用了g( )，python解释到def f( )区块的时候，只是声明这一个函数，并非调用这个函数，真正调用f( )的时候是在<code>def g()</code>区块的后面，所以实际上是先声明完f( )和g( )之后，再调用f( )和g( )的。</p> 
<p>但如果把f( )放在<code>def f()</code>和<code>def g()</code>的中间，将会报错，因为调用f()函数的时候，<code>def g()</code>还没解释到，也就是说g( )还没有声明。如下所示：</p> 
<pre class="has"><code class="language-python">x = 1
def f():
    x = 3
    g()
    print("f:",x)
 
f() # 报错: NameError: name 'g' is not defined
 
def g():
    print("g:",x)</code></pre> 
<p>更容易犯错的一种情况是边赋值，边使用。下面的代码是错误的：</p> 
<pre class="has"><code class="language-python">x = 3
def f1():
    x += 3    # 报错: UnboundLocalError: local variable 'x' referenced before assignment
    print(x)

f1()</code></pre> 
<p>因为<code>x+=3</code>也是赋值操作，<u><span style="color:#f33b45;">函数内部只要是赋值操作就表示声明为本地变量</span></u>。它首先计算<code>x=x+3</code>右边的<code>x+3</code>，然后将结果赋值给左边的变量x，但计算<code>x+3</code>的时候变量x并未定义，所以它是错误的。</p> 
<p> </p> 
<h4><span style="color:#f33b45;"><strong>关于全局变量</strong></span></h4> 
<p>关于python中的全局变量：</p> 
<ul><li>每个py文件(模块)都有一个自己的全局范围；</li><li>文件内部顶层的，不在def区块内部的变量，都是全局变量；</li><li>def内部赋值的变量默认是本地变量，要想让其变成全局变量，需要使用global关键字声明；</li><li>def内部如果没有对某个变量进行赋值操作，则引用的这个变量是全局变量；</li></ul> 
<p style="text-indent:0px;">默认情况下，下面f()中的x变量是全局变量：</p> 
<pre class="has"><code class="language-python">x = 2
def f():
    print(x)

f() # 输出2</code></pre> 
<p>默认情况下，下面f()中的x变量是本地变量：</p> 
<pre class="has"><code class="language-python">x = 2
def f():
    x = 3
    print(x)

f()       # 输出3
print(x)  # 输出2</code></pre> 
<h4><span style="color:#f33b45;"><strong>global关键字</strong></span></h4> 
<p>如果想要在def的内部修改全局变量，就需要使用global关键字声明变量：</p> 
<pre class="has"><code class="language-python">x = 2
def f():
    global x
    x = 3
    print(x)
 
f()       # 输出3
print(x)  # 输出3</code></pre> 
<p>global可以声明一个或多个变量为全局变量，多个变量使用逗号隔开，也可以声明事先不存在的变量为全局变量：</p> 
<pre class="has"><code class="language-python">x = 2
def f():
    global x, y
    x, y = 3, 4
    print(x, y)

f()          # 输出: 3 4
print(x, y)  # 输出: 3 4</code></pre> 
<p>不能global中直接赋值，所以下面的是错的：</p> 
<pre class="has"><code class="language-python">global x = 2  # 报错: SyntaxError: invalid syntax</code></pre> 
<p>注意，global不是声明变量，在变量赋值之前，变量是一定不存在的，就算是被global修饰了也一样不存在，所以下面的代码是错的。实际上，global有点类似于声明变量的名称空间，而非变量。</p> 
<pre class="has"><code class="language-python">x = 2
def f():
    global x, y
    print(y)    # 报错: NameError: name 'y' is not defined</code></pre> 
<p>必须在print(y)之前(不能是之后)加上y的赋值语句，才表示它的存在。</p> 
<pre class="has"><code class="language-python">x = 2
def f():
    global x, y
    y = 3
    print(y)</code></pre> 
<p>global修饰的变量必须在它的赋值之前，所以下面的是错的，因为y=2首先将它声明为本地变量了。</p> 
<pre class="has"><code class="language-python">def f():
    y = 2
    global y   # 报错: SyntaxError: name 'y' is assigned to before global declaration</code></pre> 
<h4><span style="color:#f33b45;"><strong>全局变量的不安全性</strong></span></h4> 
<p>考虑下面这个问题：</p> 
<pre class="has"><code class="language-python">x = 2
def f():
    global x
    x = 3
 
def g():
    global x
    x = 4
 
f() 或 g()
print(x)</code></pre> 
<p>这时，函数f()和g()的调用顺序决定了print输出的全局变量x的值。因为全局变量是共享的，如果多线程同时执行这段代码，就不知道是谁先谁后修改，导致print(x)的值随机性。这是多线程不安全特性。因此，如果允许，应尽量不要将函数内部的变量修饰为全局变量。</p> 
<h4><span style="color:#f33b45;"><strong>访问其它模块中的全局变量</strong></span></h4> 
<p>python中一个文件一个模块，在模块1中可以导入模块2中的属性(例如全局变量)。</p> 
<p>例如，b.py文件中：</p> 
<pre class="has"><code class="language-python"># b.py
x = 3</code></pre> 
<p>a.py文件中：</p> 
<pre class="has"><code class="language-python"># a.py
import b
print(b.x)
b.x = 4</code></pre> 
<p>上面的a.py中导入了b.py模块，通过<code>b.x</code>可以访问、修改这个来自于b.py中的全局变量x。</p> 
<p>这是极不安全的，因为谁也不知道是否有其他的模块也在修改<code>b.x</code>。</p> 
<p>所以，没有人会去直接修改其它模块的属性，如果要修改，基本上都会通过类似面向对象中的setter函数进行修改。只需在b.py中定义一个函数，以后在其它文件中使用这个函数修改即可。</p> 
<pre class="has"><code class="language-python"># b.py
x = 3
def setx(n)
    global x
    x = n</code></pre> 
<p>a.py文件中：</p> 
<pre class="has"><code class="language-python">import b
b.setx(54)  # 将b.x变量设置为54</code></pre> 
<h4><span style="color:#f33b45;"><strong>其它访问全局变量的方法</strong></span></h4> 
<p>上面通过import导入模块文件，就可以获取这个模块中属性的访问权。实际上，也可以在当前模块文件中使用<code>import mod_name</code>导入当前模块，其中<code>mod_name</code>为当前文件名，这样就可以在函数内部直接访问全局变量，而无需使用global关键字。</p> 
<p>除了<code>import mod_name</code>可以导入当前模块，使用sys模块的modules()函数也可以导入：<code>sys.modules['mod_name']</code> 。</p> 
<p>例如，在b.py文件中：</p> 
<pre class="has"><code class="language-python"># b.py
x = 3

def f():
    global x
    x += 2

def f1():
    x = 4       # 本地变量

def f2():
    x = 4       # 本地变量
    import b
    b.x += 2    # 全局变量

def f3():
    x = 4       # 本地变量
    import sys
    glob = sys.modules['b']
    glob.x += 2 # 全局变量

def test():
    print("test", x) # 输出3


f();f1();f2();f3()
print("main", x)     # 输出9</code></pre> 
<p>在a.py文件中：</p> 
<pre class="has"><code class="language-python"># a.py
import b
b.test()</code></pre> 
<h4><span style="color:#f33b45;"><strong>nonlocal关键字</strong></span></h4> 
<p>当函数进行嵌套的时候，内层函数的作用域是最内层的，它的外层是外层函数的作用域。内层函数和外层函数的关系类似于本地作用域与全局作用域的关系：</p> 
<ul><li>内层函数中赋值的变量是属于内层、不属于外层的本地变量；</li><li>内层函数中使用的未在当前内层函数中赋值的变量是属于外层、全局的变量；</li></ul> 
<p>例如，下面的嵌套代码中，f2( )中<code>print(x,y)</code>的x是属于外层函数f1( )的本地变量，而y则是属于内层函数自身的本地变量，外层函数f1( )无法访问属于内层函数的y。</p> 
<pre class="has"><code class="language-python">x=3
def f1():
    x=4
    def f2():
        y=5
        print(x, y)
    f2()

f1()</code></pre> 
<p>nonlocal语句可以修饰内层函数中的变量使其成为它上一层函数的变量。它的用法和global基本相同，修饰多个变量的时候，需要逗号隔开。但和global有一点不同，global修饰的变量可能事先并未存在于全局作用域内，但nonlocal修饰的变量必须已经存在于上层或上上层(或更多层)函数，不能只存在于全局。</p> 
<p>例如下面的代码片段中嵌套了2次，其中f3()中的x使用nonlocal修饰，使得这个x变成它上一层作用域f2()中的x变量。</p> 
<pre class="has"><code class="language-python">x = 3
def f1():
    x = 4       # f1的本地变量
    def f2():
        x = 5   # f2的本地变量
        def f3():
            nonlocal x       # f2的本地变量
            print("f3:", x)  # 输出5
            x = 6
        f3()
        print("f2:", x)  # 被修改，输出6
    f2()
    print("f1:", x)  # 输出4

f1()
print("mian:", x)  # 输出3</code></pre> 
<p>上面的代码将输出：</p> 
<pre class="has"><code class="language-bash">f3: 5
f2: 6
f1: 4
mian: 3</code></pre> 
<p>如果将上面的f2()中的<code>x=5</code>删除，会如何？</p> 
<pre class="has"><code class="language-python">x = 3
def f1():
    x = 4       # f1的本地变量
    def f2():
        def f3():
            nonlocal x       # f1的本地变量
            print("f3:", x)  # 输出4
            x = 6
        f3()
        print("f2:", x)  # f1的本地变量，被修改，输出6
    f2()
    print("f1:", x)  # 被修改，输出6

f1()
print("main:", x)  # 输出3</code></pre> 
<p>上面的代码将输出：</p> 
<pre class="has"><code class="language-bash">f3: 4
f2: 6
f1: 6
mian: 3</code></pre> 
<p>但如果把f1()中的<code>x=4</code>也删除，那么将报错，因为nonlocal无法将变量修饰为全局范围。</p> 
<p>所以，nonlocal默认将内层函数中的变量修饰为上一层函数的作用域范围，如果上一层函数中不存在该变量，则修饰为上上层、上上上层直到顶层函数，但不能修饰为全局作用域范围。</p> 
<p>同样的，只要在内层函数中赋值，就表示声明这个变量的作用域为内层函数作用域范围。所以，下面的代码是错误的：</p> 
<pre class="has"><code class="language-python">x = 3
def f1():
    x = 4
    def f2():
        print(x)  #UnboundLocalError: local variable 'x' referenced before assignment
        x = 3
    f2()

f1()</code></pre> 
<p>下面的代码也是错的：</p> 
<pre class="has"><code class="language-python">x = 3
def f1():
    x = 4
    def f2():
        x += 3  # UnboundLocalError: local variable 'x' referenced before assignment
        print(x)
    f2()

f1()</code></pre> 
<h4><span style="color:#f33b45;"><strong>访问外层函数变量的其它方法</strong></span></h4> 
<p>在以前的版本中，还没有nonlocal关键字，这时如果要保存外层函数的变量，就需要使用函数参数默认值的方式定义内层函数。</p> 
<pre class="has"><code class="language-python">x = 3
def f1():
    x = 4
    def f2(x = x):
        x += 3
        print("f2:", x)
    
    x = 5
    f2()
    print("f1:", x)

f1()</code></pre> 
<p>输出：</p> 
<pre class="has"><code class="language-bash">f2: 7
f1: 5</code></pre> 
<p>上面的<code>f2(x=x)</code>中，等号右边的x来自于f1()中<code>x=4</code>，然后将其赋值给f2()的本地作用域变量x。注意，python的作用域是词法作用域，函数区块的定义位置决定了它看到的变量。所以，尽管调用f2()之前再次对x进行了赋值，f2()函数调用时，<code>f2(x=x)</code>等号右边的x早已经赋值给左边的本地变量x了。它们的关系如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/05/af/HrBBxVbM_o.png"></p> 
<p> </p> 
<h4><span style="color:#f33b45;"><strong>避免函数嵌套</strong></span></h4> 
<p>一般来说，函数嵌套都只用于闭包(工厂函数)，而且是结合匿名函数(lambda)实现的闭包。其它时候，函数嵌套一般都可以改写为非嵌套模式。</p> 
<pre class="has"><code class="language-python">def f1():
    x = 3
    def f2():
        nonlocal x
        print(x)

    f2()

f1()</code></pre> 
<p>可以改写为：</p> 
<pre class="has"><code class="language-python">def f1():
    x = 3
    f2(x)
 
def f2(x):
    print(x)
 
f1()</code></pre> 
<h4><strong><a name="xunhuan"><span style="color:#f33b45;">循环内部的函数</span></a></strong></h4> 
<p>当函数位于循环结构中，且这个函数引用了循环控制变量，那么结果可能会出乎意料。</p> 
<p>本来以匿名函数(lambda)来解释更清晰，但因为尚未介绍匿名函数，所以这里采用命名函数为例。</p> 
<p>下面的代码中，将5个函数作为列表的元素保存到列表list1中</p> 
<pre class="has"><code class="language-python">def f1():
    list1 = []
    for i in range(5):
        def n(x):
            return i + x
        list1.append(n)
    return list1

mylist = f1()
for i in mylist:
    print(i)

print(mylist[0](2))
print(mylist[2](2))</code></pre> 
<p>输出：</p> 
<pre class="has"><code class="language-bash">&lt;function f1.&lt;locals&gt;.n at 0x104414200&gt;
&lt;function f1.&lt;locals&gt;.n at 0x104414290&gt;
&lt;function f1.&lt;locals&gt;.n at 0x104414170&gt;
&lt;function f1.&lt;locals&gt;.n at 0x104414320&gt;
&lt;function f1.&lt;locals&gt;.n at 0x1044143b0&gt;
6
6</code></pre> 
<p>从结果中可以看到<code>mylist[0](2)</code>和<code>mylist[2](2)</code>的执行结果是一样的，不仅如此，<code>mylist[N](2)</code>的结果也全都一样。换句话说，保存到列表中的各个函数n()中所引用的循环控制变量"i"并没有因为循环的迭代而改变，而且列表中所有函数保存的i的值都是循环的最后一个元素<code>i=4</code>。</p> 
<p>(注：对于此现象，各语言基本都是如此，本节稍作解释，真正的本质原因在本文的最后一节做了额外的补充解释)。</p> 
<p>先看下面的例子：</p> 
<pre class="has"><code class="language-python">def f1():
    for i in range(5):
    def n():
        print(i)
    return n
 
f1()()</code></pre> 
<p>结果输出4。可见，<code>print(i)</code>的值并没有随循环的迭代过程而改变。</p> 
<p>究其原因，是因为<code>def n()</code>只是函数的声明，它不会去查找i的值是多少，所以不会将i的值替换到函数n()的i变量，而是直接保存变量i的地址，当循环结束时，i指向最后一个元素i=4的地址。</p> 
<p>当开始调用n()的时候，即<code>f1()()</code>，才会真正开始查找i的值，这时候i指向的正是i=4。</p> 
<p>这就像下面的代码一样，在还没有开始调用f()的时候，f()内部的x一直都只是指向它所看见的变量x，而这个x是全局作用域范围。当真正开始调用f()的时候，才会去定位x的指向。</p> 
<pre class="has"><code class="language-python">x = 3
def f():
    print(x)</code></pre> 
<p>回到上面循环中的嵌套函数，如果要保证循环的迭代能作用到其内部的函数中，可以采用默认参数值的方式进行赋值：</p> 
<pre class="has"><code class="language-python">def f1():
    list1 = []
    for i in range(5):
        def n(x, i = i):
            return i + x
        list1.append(n)
    return list1</code></pre> 
<p>上面<code>def n(x,i=i)</code>中的<code>i=i</code>是设置默认参数值，等号右边的i是函数声明时就查找并替换完成的，所以每次循环迭代过程中，等号右边的i都不同，等号左边的参数i的默认值就不同。</p> 
<h4><strong><a name="zuoyongyu"><span style="color:#f33b45;">再述作用域规则</span></a></strong></h4> 
<p>python的作用域是词法作用域，这意味着函数的定义位置决定了它所看见的变量。除了词法作用域，还有动态作用域，动态作用域意味着函数的调用位置决定了它所看见的变量。</p> 
<p>下面是本文开头的问题：</p> 
<pre class="has"><code class="language-python">x = 1
def f():
    x = 3
    g()
    print("f:", x)  # 3
 
def g():
    print("g:", x)  # 1
 
f()
print("main:", x)   # 1</code></pre> 
<p>对于python的这段代码来说，这里有两个值得注意的地方：</p> 
<ul><li>调用函数之前，理论上要先定义好函数，但这里g()的调用似乎看上去比g()的定义更先；</li><li>f()中调用g()时，为什么g()输出的是1而不是3；</li></ul> 
<p>第一个问题在前文已经解释过了，再解释一遍：虽然f()里面有g()的调用语句，但<code>def f()</code>只是声明，但在调用f()之前，是不会去调用g()的。所以，只要f()的调用语句在<code>def g()</code>之后，就是正确的。</p> 
<p>第二个问题，python是词法作用域，所以：</p> 
<ul><li>首先声明<code>def f()</code>，在此期间会创建一个本地变量x，并且<code>print("f:",x)</code>中的x指向这个本地变量；</li><li>然后声明<code>g()</code>，在此期间，g()的定义语句不在f()内部，而是在全局范围，所以它看见的是x是全局x，所以<code>print("g:",x)</code>中的x指向全局变量x；</li></ul> 
<p>当调用f()的时候，执行到g()时，g()中所指向的是全局范围的x，而非f()段中的x。所以，输出1。</p> 
<p>再看一个嵌套在函数内部的示例：</p> 
<pre class="has"><code class="language-python">x = 3
def f1():
    x = 4
    def f2():
        print(x)
    x = 5
    f2()

f1() # 输出5</code></pre> 
<p>这里的问题是f2()中的print为什么不输出4，而是输出5？</p> 
<p>其实也很容易理解，因为<code>def f2()</code>是定义在f1()内部的，所以f2()看见的x是f1()中的x，也就是说<code>print(x)</code>中的x指向的是f1()中的x。但在调用f2()之前，重新赋值了<code>x=5</code>，等到调用f2()的时候，根据x的指向，将找到新的x的值。</p> 
<p>也就是说，前面的示例中，有两个独立的变量x：全局的和f()本地的。后面这个示例中只有一个变量x，属于f()。</p> 
<h4><strong><a name="daimakuai"><span style="color:#f33b45;">代码块细述(必看)</span></a></strong></h4> 
<p>代码块可以使得一段python代码作为一个单元、一个整体执行。以下是 官方手册 的描述。</p> 
<blockquote> 
 <p>A Python program is constructed from code blocks. A block is a piece of Python program text that is executed as a unit. The following are blocks: a module, a function body, and a class definition. Each command typed interactively is a block. A script file (a file given as standard input to the interpreter or specified as a command line argument to the interpreter) is a code block. A script command (a command specified on the interpreter command line with the ‘-c' option) is a code block. The string argument passed to the built-in functions eval() and exec() is a code block.</p> 
</blockquote> 
<p>所以，有以下几种类型的代码块：</p> 
<ul><li>模块文件是一个代码块</li><li>函数体是一个代码块</li><li>class的定义是一个代码块</li><li>交互式(python idle)的每一个命令行都是一个独立的代码块</li><li>脚本文件是一个代码块</li><li>脚本命令是一个代码块(python -c "xxx")</li><li>eval()和exec()中的内容也都有各自的代码块</li></ul> 
<p>代码块的作用是组织代码，同时意味着退出代码区块范围就退出了作用域范围。例如退出函数区块，就退出了函数的作用域，使得函数内的本地变量无法被函数的外界访问。</p> 
<p>此外，python是解释性语言，读一行解释一行，这意味着每读一行就忘记前一行。<span style="color:#f33b45;"><u>但实际上更严格的说法是读一个代码块解释一个代码块，这意味着读代码块中的内容时，是暂时记住属于这个代码块中所读内容的，读完整个代码块后再以统筹的形式解释这个代码块。</u></span></p> 
<p>先说明读一行解释一行的情况，也就是每一行都属于一个代码块，这个只能通过python的交互式工具idle工具来测试：</p> 
<pre class="has"><code class="language-python">&gt;&gt;&gt; x = 2000
&gt;&gt;&gt; y = 2000
&gt;&gt;&gt; x is y
False

&gt;&gt;&gt; x = 2000; y = 2000
&gt;&gt;&gt; x is y
True</code></pre> 
<p>理论上分号是语句的分隔符，并不会影响结果。但为什么第一个<code>x is y</code>为False，而第二个<code>x is y</code>为True？</p> 
<p>首先分析第一个<code>x is y</code>。由于交互式工具idle中每一个命令都是一个单独的语句块，这使得解释完<code>x=2000</code>后立刻就忘记了2000这个数值对象，同时忘记的还有x变量本身。然后再读取解释<code>y=2000</code>，因为不记得刚才解释的<code>x=2000</code>，所以会在内存中重新创建一个数值结构用来保存2000这个数值，然后用y指向它。换句话说，x和y所指向的2000在内存中是不同的数据对象，所以<code>x is y</code>为False。</p> 
<p>下面的<code>x is y</code>返回True：</p> 
<pre class="has"><code class="language-python">&gt;&gt;&gt; x = 2000; y = 2000
&gt;&gt;&gt; x is y
True</code></pre> 
<p>因为python按行解释，一个命令是一个代码块。对于<code>x=2000;y=2000</code>，python首先读取这一整行，发现x和y的数值对象都是2000，于是做个简单优化，等价于<code>x,y=2000,2000</code>，这意味着它们属于一个代码块内，由于都是2000，所以只会在内存中创建一个数据对象，然后x和y都引用这个数据对象。所以，<code>x is y</code>返回True。</p> 
<p>idle工具中每个命令都是独立的代码块，但是py文件却是一个完整的代码块，其内还可以嵌套其它代码块(如函数、exec()等)。所以，如果上面的分行赋值语句放在py文件中，得到的结果将是True。</p> 
<pre class="has"><code class="language-python"># a.py
x = 2000
y = 2000
print(x is y)      # True

def f1():
    z = 2000
    z1 = 2000
    print(x is z)  # False
    print(z is z1) # True
 
f1()</code></pre> 
<p>python先读取<code>x=2000</code>，并在内存中创建一个属于全局作用域的2000数据对象，再解释y=2000的时候，发现这个全局对象2000已经存在了(因为x和y同处于全局代码块内)，所以不会再额外创建新的2000对象。这里反映出来的结果是"同一个代码块内，虽然仍然是读一行解释一行，但在退出这个代码块之前，不会忘记这个代码块中的内容，而且会统筹安排这个代码块"。</p> 
<p>同理<code>def f1()</code>内的代码块，因为z是本地作用域的变量，更标准的是处于不同代码块内，所以会在本地作用域内存区创建新的数据对象2000，所以<code>x is z</code>返回False。根据前面的解释，<code>z1 is z</code>返回True。</p> 
<p>再回顾前文多次出现的一个异常：</p> 
<pre class="has"><code class="language-python">x = 3
def f1():
    print(x)  # UnboundLocalError: local variable 'x' referenced before assignment
    x = 4

f1()</code></pre> 
<p>当执行到def语句的时候，因为def声明函数，函数体是一个代码块，所以按照代码块的方式读取属于这个代码块中的内容。首先读取<code>print(x)</code>，但并不会直接解释，而是会记住它，并继续向下读取，读取x=4，这意味着x是一个本地变量。然后统筹安排整个代码块，将print(x)的x认为是本地变量而非全局变量。注意，直到def退出的时候都还没有进行x的赋值，而是记录了本地变量x，赋值操作是在函数调用的时候进行的。当调用函数f()的时候，发现print(x)中的x是本地变量，但因为还没有赋值，所以报错。</p> 
<p>但是再看下面的，为什么又返回True？</p> 
<pre class="has"><code class="language-python">&gt;&gt;&gt; x=256
&gt;&gt;&gt; y=256
&gt;&gt;&gt; x is y
True</code></pre> 
<p>因为Python在启动的时候就在内存中预先为常用的较小整数值(-5到256)创建好了对象，因为它们使用的非常频繁(有些在python的内部已经使用了)。所以，对于这个范围内的整数，都是直接引用，不会再在内存中额外创建新的数值对象，所以<code>x is y</code>总是返回true。甚至，这些小值整数可以跨作用域：</p> 
<pre class="has"><code class="language-python">x = 3
def f1():
    y = 3
    print(x is y) # True
 
f1()</code></pre> 
<p>再看前文循环内的函数的问题。<br>  </p> 
<pre class="has"><code class="language-python">def f1():
    for i in range(5):
        def n():
            print(i)
    return n
 
f1()()   # 4</code></pre> 
<p>前面对现象已经解释过，内部函数n()中print(i)的i不会随循环的迭代而改变，而是固定的值i=4。</p> 
<p>python首先解释<code>def f1()</code>的代码块，会记录属于这个代码块作用域内的变量i和n，但i和n都不会赋值，也就是说暂时并不知道变量n是一个函数变量。</p> 
<p>同理，当需要解释<code>def n()</code>代码块的时候，将记住这个代码块涉及到的变量i，只不过这个变量i是属于外层函数的，但不管如何，这个代码块记住了i，且记住了它是外部函数作用域的。</p> 
<p>注意，函数的声明过程中，所有涉及到变量i的作用域内都不会对i进行赋值，仅仅只是保存了这个i变量名，只有在调用函数的时候才会进行赋值操作。</p> 
<p>当开始调用f1()的时候，开始执行函数体中的代码，于是开始循环迭代，且多次声明函数<code>n()</code>，每一次迭代生成的n()都会让原先已记录的变量n指向这个新声明的函数体(相当于赋值的操作，只不过是变量n引用的对象是函数体结构，而不是一般的数据对象)，由于只是在循环中声明函数n()，并没有进行调用，所以不会对n()中的i进行赋值操作。而且，每次循环迭代都会让变量n指向新的函数体，使得先前迭代过程中定义的函数被丢弃(覆盖)，所以最终只记住了最后一轮循环时声明的函数n()，并且i=4。</p> 
<p>当调用f1()()时，表示调用f1()中返回的函数n()，直到这个时候才会对n()内的i进行赋值，赋值时将搜索它的外层函数f1()作用域，发现这个作用域内的i指向内存中的数值4，于是最终输出4。</p> 
<p>再看下面的代码：</p> 
<pre class="has"><code class="language-python">def f1():
    for i in range(5):
        def n():
            print(i)
        n()
    return n

f1()</code></pre> 
<p>输出为：</p> 
<pre class="has"><code class="language-bash">0
1
2
3
4</code></pre> 
<p>调用f1()的时候，执行循环的迭代，每次迭代时都会调用n()，意味着每次迭代都要对n()中的i进行赋值。</p> 
<p>另外注意，前面说过，函数的默认参数是在函数声明时进行赋值的，所以下面的列表L中每个元素所代表的函数，它们的变量i都指向不同的数值对象。</p> 
<pre class="has"><code class="language-python">def f1():
    L = []
    for i in range(5):
        def n(i = i):
            print(i)
        L.append(n)
    return L
 
f1()[0]()  # 0
f1()[1]()  # 1
f1()[2]()  # 2
f1()[3]()  # 3
f1()[4]()  # 4</code></pre> 
<h4> </h4> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/745699765ba25b71d412f8d04f728746/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">angular2单元测试学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2e960ca700311998da969bf63bad509/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">L3-Day28</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>