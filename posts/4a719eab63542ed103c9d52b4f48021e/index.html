<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>etcd基本介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="etcd基本介绍" />
<meta property="og:description" content="etcd基本介绍 ETCD是SoreOs公司发布的一个分布式的、高可用的、key-value存储的数据库。基于Go语言实现，k8s中也使用了ETCD作为数据库。主要用于共享配置和服务发现。相对于zookeeper采用的Paxos，ETCD采用的是Raft算法，该算法具备的性能更佳、数据一致性强等优点。
服务发现 服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。 本质上来说，服务发现就是想要了解集群中是否有进程在监听udp或tcp端口，并且通过名字就可以查找和连接。
要解决服务发现的问题，需要有下面三大支柱，缺一不可:
1.一个强一致性、高可用的服务存储目录。基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录。 2.一种注册服务和监控服务健康状态的机制。用户可以在etcd中注册服务，并且对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果。 3. 一种查找和连接服务的机制。通过在etcd指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可 以确保能访问etcd集群的服务都能互相连接。 Raft选举算法 一、什么是Raft算法 Raft算法是基于Multi-Paxos 思想 提出的一种易于理解的共识算法，主要解决了分布式中的一致性问题。
二、选举过程 Raft算法中每个节点拥有三种状态： Follower 跟随者状态 Candidate 候选者状态 Leader 领导者状态 1、所有的节点初始都是在跟随者状态下 2、如果一个跟随者在一定时间内（150ms 至300ms，随机值）没有收到领导者的心跳信息，自己将变成候选者状态，先投自己一票，并向群体内的其它节点发送选举投票请求 3、群体内的其它节点如果在这一任期内没有投过票，收到投票请求后将投一票给候选者，并返回 4、如果一个候选者收到了群体内大多数人（N/2 &#43; 1）的投票，它将变成一名领导者，选举完成，开始不断地向其它节点发送心跳检测。任期将一直持续到某一个跟随者在一定时间内没有收到领导者的心跳信息。 选举完成之后，所有的数据操作将都通过领导者进行
通过上述的选举过程发现，肯定会有一定几率，两个跟随者节点同时进入候选者状态。 Raft算法中还有一个概念叫做任期（term），在一个任期中，每个节点只能投一次票。每次处理群体内其它节点的请求时，都会对term进行校验或者更新，当某个节点发现自己的 term 号比其他人小，那么它会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。
个人理解可以想象成你们村儿选第二百五十届村长，term相当于第250个任期，总共有2个村名，还有2个候选者去竞选，你爸是村民，你家在这个任期只能投一票，你爸投给了张三，就不能投给李四了。
这时候他们会进行 2 步骤：先投自己一票，并向群体内的其它节点发送选举投票请求 并且两人都拉到了一名村民（跟随者）的投票，这时两位候选者都拥有两票，这一轮的选举就失败了，赋随机等待值继续等待下一轮的选举，重复2-4步骤.
etcd常用术语 Raft：etcd所采用的保证分布式系统强一致性的算法。
Node：一个Raft状态机实例。
Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。
Cluster：由多个Member构成可以协同工作的etcd集群。
Peer：对同一个etcd集群中另外一个Member的称呼。
Client： 向etcd集群发送HTTP请求的客户端。
WAL：预写式日志，etcd用于持久化存储的日志格式。
snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。
Proxy：etcd的一种模式，为etcd集群提供反向代理服务。
Leader(领导者)：Raft算法中通过竞选而产生的处理所有数据提交的节点。
Follower(跟随者)：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。
Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始Leader竞选。
Term：某个节点成为Leader到下一次竞选开始的时间周期，称为一个Term。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4a719eab63542ed103c9d52b4f48021e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T15:18:37+08:00" />
<meta property="article:modified_time" content="2024-01-05T15:18:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">etcd基本介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" src="https://images2.imgbox.com/7d/fd/qpTBWXcF_o.png"></p> 
<h2>etcd基本介绍</h2> 
<p>ETCD是SoreOs公司发布的一个分布式的、高可用的、key-value存储的数据库。基于Go语言实现，k8s中也使用了ETCD作为数据库。主要用于共享配置和服务发现。相对于zookeeper采用的Paxos，ETCD采用的是Raft算法，该算法具备的性能更佳、数据一致性强等优点。</p> 
<h3>服务发现</h3> 
<p>服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。 本质上来说，服务发现就是想要了解集群中是否有进程在监听udp或tcp端口，并且通过名字就可以查找和连接。</p> 
<p>要解决服务发现的问题，需要有下面三大支柱，缺一不可:</p> 
<h6>1.一个强一致性、高可用的服务存储目录。基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录。</h6> 
<h6>2.一种注册服务和监控服务健康状态的机制。用户可以在etcd中注册服务，并且对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果。</h6> 
<h6>3. 一种查找和连接服务的机制。通过在etcd指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可 以确保能访问etcd集群的服务都能互相连接。</h6> 
<h4>Raft选举算法</h4> 
<h5>一、什么是Raft算法</h5> 
<p>Raft算法是基于Multi-Paxos 思想 提出的一种易于理解的共识算法，主要解决了分布式中的一致性问题。</p> 
<h5>二、选举过程</h5> 
<p>Raft算法中每个节点拥有三种状态： Follower 跟随者状态 Candidate 候选者状态 Leader 领导者状态 1、所有的节点初始都是在跟随者状态下 2、如果一个跟随者在一定时间内（150ms 至300ms，随机值）没有收到领导者的心跳信息，自己将变成候选者状态，先投自己一票，并向群体内的其它节点发送选举投票请求 3、群体内的其它节点如果在这一任期内没有投过票，收到投票请求后将投一票给候选者，并返回 4、如果一个候选者收到了群体内大多数人（N/2 + 1）的投票，它将变成一名领导者，选举完成，开始不断地向其它节点发送心跳检测。任期将一直持续到某一个跟随者在一定时间内没有收到领导者的心跳信息。 选举完成之后，所有的数据操作将都通过领导者进行</p> 
<p>通过上述的选举过程发现，肯定会有一定几率，两个跟随者节点同时进入候选者状态。 Raft算法中还有一个概念叫做任期（term），在一个任期中，每个节点只能投一次票。每次处理群体内其它节点的请求时，都会对term进行校验或者更新，当某个节点发现自己的 term 号比其他人小，那么它会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。</p> 
<p>个人理解可以想象成你们村儿选第二百五十届村长，term相当于第250个任期，总共有2个村名，还有2个候选者去竞选，你爸是村民，你家在这个任期只能投一票，你爸投给了张三，就不能投给李四了。</p> 
<p>这时候他们会进行 2 步骤：先投自己一票，并向群体内的其它节点发送选举投票请求 并且两人都拉到了一名村民（跟随者）的投票，这时两位候选者都拥有两票，这一轮的选举就失败了，赋随机等待值继续等待下一轮的选举，重复2-4步骤.</p> 
<h3>etcd常用术语</h3> 
<p>Raft：etcd所采用的保证分布式系统强一致性的算法。</p> 
<p>Node：一个Raft状态机实例。</p> 
<p>Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。</p> 
<p>Cluster：由多个Member构成可以协同工作的etcd集群。</p> 
<p>Peer：对同一个etcd集群中另外一个Member的称呼。</p> 
<p>Client： 向etcd集群发送HTTP请求的客户端。</p> 
<p>WAL：预写式日志，etcd用于持久化存储的日志格式。</p> 
<p>snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。</p> 
<p>Proxy：etcd的一种模式，为etcd集群提供反向代理服务。</p> 
<p>Leader(领导者)：Raft算法中通过竞选而产生的处理所有数据提交的节点。</p> 
<p>Follower(跟随者)：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。</p> 
<p>Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始Leader竞选。</p> 
<p>Term：某个节点成为Leader到下一次竞选开始的时间周期，称为一个Term。</p> 
<p>Index：数据项编号。</p> 
<p>Raft中通过Term和Index来定位数据。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e0/0d/EORTf9mB_o.png"></p> 
<h3>centos安装etcd</h3> 
<p>1.解压etcd安装包</p> 
<pre>**tar -zxvf etcd-v3.4.3-linux-amd64.tar.gz**</pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bc/d1/erFgh5xJ_o.png"></p> 
<p>2.切换至etcd根目录，将etcd和etcdctl二进制文件复制到/usr/local/bin目录这样系统中可以直接调用etcd/etcdctl这两个程序</p> 
<pre>**cp etcd etcdctl /usr/local/bin**</pre> 
<p>3.查看etcd版本</p> 
<pre>**etcd --version**</pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/de/c7/DhDQFRkb_o.png"></p> 
<p>4.输入命令etcd，即可启动一个单节点的etcd服务,ctrl+c即可停止服务</p> 
<pre>**xxxx-xx-xx xx:xx:xx.xxxxxx I | embed: name = default **
​
**xxxx-xx-xx xx:xx:xx.xxxxxx I | embed: data dir = default.etcd **
​
**xxxx-xx-xx xx:xx:xx.xxxxxx I | embed: member dir = default.etcd/member **
​
**xxxx-xx-xx xx:xx:xx.xxxxxx I | embed: heartbeat = 100ms **
​
**xxxx-xx-xx xx:xx:xx.xxxxxx I | embed: election = 1000ms **
​
**xxxx-xx-xx xx:xx:xx.xxxxxx I | embed: snapshot count = 100000 **
​
**xxxx-xx-xx xx:xx:xx.xxxxxx I | embed: advertise client URLs = http://localhost:2379 **
​
**xxxx-xx-xx xx:xx:xx.xxxxxx I | etcdserver: starting member 8e9e05c52164694d in cluster cdf818194e3a8c32**</pre> 
<p>1.name表示节点名称，默认为default。</p> 
<p>2.data-dir 保存日志和快照的目录，默认为当前工作目录default.etcd/目录下。</p> 
<p>3.在<a href="http://localhost:2380/" rel="nofollow" title="http://localhost:2380">http://localhost:2380</a>和集群中其他节点通信。</p> 
<p>4.在<a href="http://localhost:2379/" rel="nofollow" title="http://localhost:2379">http://localhost:2379</a>提供客户端交互。</p> 
<p>5.heartbeat为100ms，该参数的作用是leader多久发送一次心跳到followers，默认值是100ms。</p> 
<p>6.election为1000ms，该参数的作用是重新投票的超时时间，如果follow在该时间间隔没有收到心跳包，会触发重新投票，默认为1000ms。</p> 
<p>7.snapshot count为10000，该参数的作用是指定有多少事务被提交时，触发截取快照保存到磁盘。</p> 
<p>8.集群和每个节点都会生成一个uuid。</p> 
<p>9.启动的时候会运行raft，选举出leader</p> 
<p></p> 
<h3>创建一个etcd服务</h3> 
<p><strong>1.建立etcd相关目录(即数据文件和配置文件的保存位置)</strong></p> 
<pre>mkdir -p /var/lib/etcd/ &amp;&amp; mkdir -p /etc/etcd/</pre> 
<p>数据目录mkdir -p /var/lib/etcd/</p> 
<p>配置文件目录mkdir -p /etc/etcd/</p> 
<p><strong>2.创建etcd配置文件</strong></p> 
<pre>vim /etc/etcd/etcd.conf</pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e2/69/ZzrvNKCD_o.png"></p> 
<p><strong>3.创建systemd配置文件</strong></p> 
<pre>vim /etc/systemd/system/etcd.service</pre> 
<p>创建完成后刷新系统资源 systemctl daemon-reload</p> 
<p><strong>etcd开机自启</strong></p> 
<pre>systemctl enable etcd</pre> 
<p><strong>etcd启动</strong></p> 
<pre>systemctl start etcd</pre> 
<p><strong>etcd查看服务</strong></p> 
<pre>systemctl status etcd</pre> 
<h3>etcd基本使用</h3> 
<h5>增删改查数据相关命令</h5> 
<p><strong>帮助命令</strong></p> 
<pre>etcdctl -h</pre> 
<p><strong>put 放入数据</strong></p> 
<pre>etcdctl put /testdir/testkey "Hello world"
--sort 对结果进行排序
--consistent 将请求发给主节点，保证获取内容的一致性。</pre> 
<p><strong>删除</strong></p> 
<pre>清空数据
etcdctl del / --prefix

删除所有/test前缀的节点
etcdctl del /test --prefix</pre> 
<p><strong>watch,监测一个键值的变化，一旦键值发生更新，就会输出最新的值并退出</strong></p> 
<pre>etcdctl watch key1</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42fe44d83a6517a8fc5ee3c8660f2c94/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">打破闲鱼商品搜索瓶颈！云端电商API接口让你畅享商品详情关键词搜索的便利！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c6b844c89b36db32a45b387fbeb40c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">go语言gin框架的基本使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>