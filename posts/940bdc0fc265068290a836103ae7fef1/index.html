<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Rust 基础再理解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Rust 基础再理解" />
<meta property="og:description" content="Rust堆栈 Rust中各种类型的值默认都存储在栈中，除非显式地使用Box::new()将它们存放在堆上，但数据要存放在栈中，要求其数据类型的大小已知。对于静态大小的类型，可直接存储在栈上，如裸指针、布尔、字符、整数浮点数，数组等。
动态大小的（Vec、string）都是存堆的
一些注意事项
栈中的数据赋值给变量的时候，数据是直接放在栈中的。类型的值都默认放在栈中，所以创建引用的时候，引用的是栈里的值。容器中保存的是原始类型的栈里的值或者指向堆数据的引用字符串字面量，static静态变量都会硬编码嵌入到二进制程序的全局内存区const定义的常量，会在编译期间直接以硬编码的方式内联插入到使用常量的地方，即，直接硬编码到对应代码行。同时函数也可以内联，即函数对应代码体会直接展开并插入到调用函数的地方，省去调用函数的开销。
位置与值 位置：某一块内存位置，它有自己的地址，有自己的空间，有自己所保存的值。
值：存储到位置中的数据(即保存在内存中的数据)
位置的产生
会产生变量的时候（初始化）需要保存某个值的时候（函数调用参数和返回值）产生新的值（引用，解引用）
let 语句 let a = 1;
a：为变量名，也是对内存位置的一个可读代号，编译期间会被替换为更低级的代号或者直接为地址。也就是位置，是存值1的一块内存。
每个位置就是它所放值的所有值，因为每个值都只能存放在一个位置中，所以每个值都只能有一个所有者。
let v = vec![1, 2, 3, 4];
v：位置，代表栈中的一块内存，值是一个指针地址，实际数据是放在堆里的。
引用 Rust的引用是一种原始数据类型，位置仍然是栈里，保存的值和指针一样，是一个地址。该地址指向了**位置（**也就是前面的a和v）
如
let n = 33; // 假设n的地址为0x234 let nn = &amp;n; // 假设nn的地址为0x123 那么，nn的位置是0x123，它存的值是0x234，也就是n的地址。
编译器维护栈内存，所以它知道栈中的某个内存是否安全，而堆内存由程序员自己负责，程序员自己的行为是无法保证安全的。
所以，Rust的行为模式是将是涉及到内存安全的概念扔到栈上，让程序员远离对堆的操作。所以，允许允许对栈中同一个数据的多个指向，不允许对堆中同一个内存的多个指向，即变量存在多个引用，但所有权只能有一个。
位置的属性 位置的属性和状态都由编译器在编译期进行维护。
位置有类型，有标记（是否被引用，可变引用还是不可变，共享还是独占等等），根据位置的类型是否实现Copy Trait来决定该位置的是拷贝还是移走。
所有权和借用 变量作用域 我们知道rust 变量在脱离作用域之后就会被销毁，但事实是，变量在跳出作用域时，会自动Drop Trait的drop函数来销毁内存中堆和栈的数据，全局内存中的数据是从程序启动到终止期间一直存在。
另外rust的作用域为一对大括号{}，大括号的作用域是可以访问大括号外部的变量，而在函数的作用域内则不行，这被称为捕获环境，函数是不能捕获环境的，而大括号可以捕获环境。
数据的拷贝 由于所有权问题和变量脱离作用域而引起的内存二次释放问题，rust是不允许有两个指针同时指向同一块内存的。所以rust 没有浅拷贝和深拷贝的概念，取而代之的是move、copy和clone。
move：也就是转移所有权，涉及到的过程是拷贝到目标变量，同时会将原来的变量设置到未初始的状态。rust 默认使用的就是move。 当使用值的时候，就会产生位置，那么就会发生移动。解引用，字段访问，索引访问等都会隐式移动。
copy：和move的区别就是，拷贝之后原来的变量还是可以用。如果要使用copy，就需要要拷贝的数据类型实现了Copy Trait，手动实现的时候需要同时实现Clone Trait。clone：clone和copy很接近，区别在于，Copy时，只拷贝变量本身的值，如果这个变量指向了其它数据，则不会拷贝其指向的数据。Clone时，拷贝变量本身的值，如果这个变量指向了其它数据，则也会拷贝其指向的数据。 函数调用之后也是会转移所有权的，有时候这样是很不方便的，所以在传参的时候可以传递到变量的引用，引用时保存在栈里，也实现了Copy Trait，这样效率会更高。
可变引用的排他性 不可变引用是可以共存的，但是可变引用具有排他性，在同一作用域同一数据只能有一个。
这里的排他性，应该看作一把独占锁，在当前作用域内，从第一次使用可变引用开始创建这把独占锁，之后无论使用原始变量(即所有权拥有者)、可变引用还是不可变引用都会抢占这把独占锁，以保证只有一方可以访问数据，每次抢得独占锁后，都会将之前所有引用变量给锁住，使它们变成不可用状态。当离开当前作用域时，当前作用域内的所有独占锁都被释放。
回顾一下可变引用的几个性质" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/940bdc0fc265068290a836103ae7fef1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-25T19:20:04+08:00" />
<meta property="article:modified_time" content="2023-09-25T19:20:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rust 基础再理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<h3><a id="Rust_1"></a>Rust堆栈</h3> 
<p>Rust中各种类型的值默认都存储在栈中，除非显式地使用<code>Box::new()</code>将它们存放在堆上，但数据要存放在栈中，要求其数据类型的大小已知。对于静态大小的类型，可直接存储在栈上，如裸指针、布尔、字符、整数浮点数，数组等。<br>动态大小的（<code>Vec</code>、<code>string</code>）都是存堆的<br><strong>一些注意事项</strong></p> 
<ul><li>栈中的数据赋值给变量的时候，数据是直接放在栈中的。</li><li>类型的值都默认放在栈中，所以创建引用的时候，引用的是栈里的值。</li><li>容器中保存的是原始类型的栈里的值或者指向堆数据的引用</li><li>字符串字面量，<code>static</code>静态变量都会硬编码嵌入到二进制程序的全局内存区</li><li><code>const</code>定义的常量，会在编译期间直接以硬编码的方式内联插入到使用常量的地方，即，直接硬编码到对应代码行。同时函数也可以内联，即函数对应代码体会直接展开并插入到调用函数的地方，省去调用函数的开销。<br> </li></ul> 
<h3><a id="_10"></a>位置与值</h3> 
<p><strong>位置</strong>：某一块内存位置，它有自己的地址，有自己的空间，有自己所保存的值。<br><strong>值</strong>：存储到位置中的数据(即保存在内存中的数据)<br><strong>位置的产生</strong></p> 
<ul><li>会产生变量的时候（初始化）</li><li>需要保存某个值的时候（函数调用参数和返回值）</li><li>产生新的值（引用，解引用）<br> </li></ul> 
<h4><a id="let__17"></a>let 语句</h4> 
<p><code>let a = 1;</code><br><code>a</code>：为变量名，也是对内存位置的一个可读代号，编译期间会被替换为更低级的代号或者直接为地址。也就是位置，是存值<code>1</code>的一块内存。<br>每个位置就是它所放值的所有值，<strong>因为每个值都只能存放在一个位置中，所以每个值都只能有一个所有者。</strong><br><code>let v = vec![1, 2, 3, 4];</code><br><code>v</code>：位置，代表栈中的一块内存，值是一个指针地址，实际数据是放在堆里的。</p> 
<p></p> 
<h4><a id="_21"></a>引用</h4> 
<p>Rust的引用是一种原始数据类型，位置仍然是栈里，保存的值和指针一样，是一个地址。该地址指向了**位置（**也就是前面的<code>a</code>和<code>v</code>）<br>如</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span> <span class="token comment">// 假设n的地址为0x234</span>
<span class="token keyword">let</span> nn <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">;</span> <span class="token comment">// 假设nn的地址为0x123</span>
</code></pre> 
<p>那么，<code>nn</code>的位置是<code>0x123</code>，它存的值是<code>0x234</code>，也就是<code>n</code>的地址。<br>编译器维护栈内存，所以它知道栈中的某个内存是否安全，而堆内存由程序员自己负责，程序员自己的行为是无法保证安全的。<br>所以，Rust的行为模式是将是涉及到内存安全的概念扔到栈上，让程序员远离对堆的操作。所以，允许允许对栈中同一个数据的多个指向，不允许对堆中同一个内存的多个指向，即<strong>变量存在多个引用，但所有权只能有一个</strong>。</p> 
<p></p> 
<h4><a id="_30"></a>位置的属性</h4> 
<p>位置的属性和状态都由编译器在编译期进行维护。<br>位置有类型，有标记（是否被引用，可变引用还是不可变，共享还是独占等等），根据位置的类型是否实现<code>Copy Trait</code>来决定该位置的是拷贝还是移走。</p> 
<p></p> 
<h3><a id="_34"></a>所有权和借用</h3> 
<p></p> 
<h4><a id="_36"></a>变量作用域</h4> 
<p>我们知道rust 变量在脱离作用域之后就会被销毁，但事实是，变量在跳出作用域时，会自动<code>Drop Trait</code>的<code>drop</code>函数来销毁内存中堆和栈的数据，全局内存中的数据是从程序启动到终止期间一直存在。<br>另外rust的作用域为一对大括号<code>{}</code>，大括号的作用域是可以访问大括号外部的变量，而在函数的作用域内则不行，这被称为捕获环境，<strong>函数是不能捕获环境的，而大括号可以捕获环境</strong>。<br> </p> 
<h4><a id="_39"></a>数据的拷贝</h4> 
<p>由于所有权问题和变量脱离作用域而引起的内存二次释放问题，rust是不允许有两个指针同时指向同一块内存的。所以rust 没有浅拷贝和深拷贝的概念，取而代之的是<code>move</code>、<code>copy</code>和<code>clone</code>。</p> 
<ul><li><code>move</code>：也就是转移所有权，涉及到的过程是拷贝到目标变量，同时会将原来的变量设置到未初始的状态。rust 默认使用的就是<code>move</code>。</li></ul> 
<p>当使用值的时候，就会产生位置，那么就会发生移动。解引用，字段访问，索引访问等都会隐式移动。</p> 
<ul><li><code>copy</code>：和<code>move</code>的区别就是，拷贝之后原来的变量还是可以用。如果要使用<code>copy</code>，就需要要拷贝的数据类型实现了<code>Copy Trait</code>，手动实现的时候需要同时实现<code>Clone Trait</code>。</li><li><code>clone</code>：<code>clone</code>和<code>copy</code>很接近，区别在于，</li><li>Copy时，只拷贝变量本身的值，如果这个变量指向了其它数据，则不会拷贝其指向的数据。</li><li>Clone时，拷贝变量本身的值，如果这个变量指向了其它数据，则也会拷贝其指向的数据。</li></ul> 
<p>函数调用之后也是会转移所有权的，有时候这样是很不方便的，所以在传参的时候可以传递到变量的引用，引用时保存在栈里，也实现了<code>Copy Trait</code>，这样效率会更高。</p> 
<p></p> 
<h4><a id="_54"></a>可变引用的排他性</h4> 
<p>不可变引用是可以共存的，但是可变引用具有排他性，在同一作用域同一数据只能有一个。<br>这里的排他性，应该看作一把<strong>独占锁</strong>，在当前作用域内，从第一次使用可变引用开始创建这把独占锁，之后无论使用原始变量(即所有权拥有者)、可变引用还是不可变引用都会抢占这把独占锁，以保证只有一方可以访问数据，每次抢得独占锁后，都会将之前所有引用变量给锁住，使它们变成不可用状态。当离开当前作用域时，当前作用域内的所有独占锁都被释放。</p> 
<p>回顾一下可变引用的几个性质</p> 
<ul><li>同一作用域，特定数据只能有一个可变引用</li><li>可变借用不能用于不可变借用上</li><li>有了可变借用就不能再有不可变借用</li><li>引用作用域和变量作用域不一样，它的结束位置再最后一次使用的位置</li></ul> 
<p>自从第一次使用可变引用导致独占锁出现后，可以随时使用原始变量、可变引用或不可变引用来抢独占锁，但抢锁后以前的引用变量就不能再用，且当前持有的锁也可以随时被抢走。不可变引用抢占之后所有的包括自身都是不可用的，但再次使用可变引用抢占锁之后，该可变引用是可用的。<br>一切都由程序员控制，程序员可以在任意代码位置通过原始变量或引用来抢锁。</p> 
<p></p> 
<h4><a id="_67"></a>模式匹配</h4> 
<p>rust中可分为</p> 
<ul><li>不可反驳的模式(irrefutable)：一定会匹配成功，否则编译错误，如<code>let</code>赋值，<code>for</code>迭代，函数传参等。</li><li>可反驳的的模式(refutable)：可以匹配成功，也可以匹配失败，匹配失败的结果是不执行对应分支的代码，如<code>if let</code> 和 <code>while let</code></li></ul> 
<p><code>match</code>匹配支持两个模式</p> 
<ul><li>当明确给出分支的Pattern时，必须是可反驳模式，这些模式允许匹配失败</li><li>使用<code>_</code>作为最后一个分支时，是不可反驳模式，它一定会匹配成功</li><li>如果只有一个Pattern分支，则可以是不可反驳模式，也可以是可反驳模式<br> </li></ul> 
<h3><a id="Trait_79"></a>再谈Trait</h3> 
<p></p> 
<h4><a id="_81"></a>组合</h4> 
<p><code>Trait</code>最基本的作用是从多种类型中抽取出共性的属性或方法，主要表现为泛型数据类型。可以理解为，它描述了一种通用的功能，功能都要求具有某些特殊的行为，同时功能可以被很多种类型实现。<br>同样，一个类型也可以实现很多种<code>Trait</code>，组合出很多功能，这和一般面向对象编程语言的继承有所不同，不用继承冗余的功能，而更加的自由。<br>组合和继承的关系可以理解为 **has a **和 <strong>is a</strong> 的关系。</p> 
<p></p> 
<h4><a id="_85"></a>特征对象</h4> 
<p>也就是具有某个特征功能的类的实例。<br>上篇提到过，<strong>Duck Typing</strong> ，也就是只需要叫起来想鸭子，就可以当成鸭子来使用。（只需要你会打螺丝，不管你是不是大学生。）<br>这里的意思就是，实现了某个特征的众多对象都具有该功能，而由于 <code>Trait</code> 自身不能当作数据类型来用（因为，可能一种类型实现了很多中 <code>Trait</code>，显然无法用一种 <code>Trait</code> 来代替这种数据类型）。因此就诞生了 <code>Trait Object</code>，也就是将实现了 <code>Trait A</code> 的类型 B,C,D 当作 <code>Trait A</code> 的 <code>Trait Object</code>使用。（可以类比为继承里的父类）</p> 
<p><code>Trait object</code>的创建是通过<code>&amp;dyn T</code>或者指针<code>Box&lt;dyn T&gt;</code>，<code>Rc&lt;dyn T&gt;</code>等等<br>本质就是由于 <code>Trait object</code> 的大小是不定的，所以选择将引用存在栈中，包含两部分数据</p> 
<ul><li>指向数据的指针：指向实现了<code>Trait</code>的具体类型的实例，</li><li>指向一个虚表 <strong>vtable</strong> 的指针：因为实现了 <code>Trait</code> 的类型有很多，而每个类型拥有的方法时各不相同的，所以需要一个虚表来区分保存。虚表中保存了实例可以调用的，实现的来自特征 <code>Trait</code> 的方法。当该对象调用方法时，直接从虚表中找到方法，然后调用。</li></ul> 
<p></p> 
<h4><a id="_94"></a>其他</h4> 
<ul><li><code>Struct</code>和<code>Enum</code>类型需要手动实现<code>Trait</code>，即，使用<code>#[derive()]</code></li><li>特征是支持继承的，如</li></ul> 
<pre><code class="prism language-rust"><span class="token keyword">trait</span> <span class="token type-definition class-name">B</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">trait</span> <span class="token type-definition class-name">A</span><span class="token punctuation">:</span> <span class="token class-name">B</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>当类型想实现 <code>Trait A</code> 的时候，需要要求同时实现 <code>Trait B</code></p> 
<p></p> 
<h3><a id="_108"></a>参考</h3> 
<p><a href="https://rust-book.junmajinlong.com/" rel="nofollow">Rust入门秘籍</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6df491c90720f363ac6da5148c0a6303/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue中前端导出word文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ea6332aa24f8b9c76c3137aa0863e07/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows开源版的pymol安装方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>