<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分配策略_基于AUTOSAR的任务分配策略 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="分配策略_基于AUTOSAR的任务分配策略" />
<meta property="og:description" content="随着汽车电子应用程序对处理器性能需求的不断提高,现代汽车电子系统中的电子控制单元(ECU)已升级为多核结构.
多核结构处理器 在系统级设计中,汽车电子应用程序由若干构件(SWC)组成. 每个构件实现了应用程序的某一特定功能. 若干构件通过相互协作共同实现应用程序的具体行为. 然而,在ECU设计中, 操作系统调度的对象却是任务(Task). 因此,在进行ECU配置时,须将构件内的可运行实体(Runnable entity)映射到具体任务中,以供操作系统调度执行,这个过程被称为&#34;可运行实体到任务的映射&#34;。
一种较为简单的映射方法是将每个可运行实体单独封装为一个任务, 简称方法１。 但是如此大量的任务会使得系统被频繁调度,增加系统的调度开销。
另一种较为实用的方法是将拥有相同周期的可运行实体映射为一个任务,简称方法２。然而,该方法忽略了可运行实体之间的依赖关系和数据通信,且缺乏在映射过程中对任务实时性的分析。在实际中,可运行实体到任务映射主要根据AUTOSAR标准中关于任务生成的规范,依靠软件工程师的丰富经验来手动完成. 目前的自动映射方法(如方法１和方法２)还不能很好地满足汽车电子系统对实时性的需求。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
有没有更优化更有效的方法来分配任务呢？思考研究一下:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
在AUTOSAR架构中, 汽车电子应用软件由构件(Software Component)组成. 构件的具体行为依靠可运行实体以及可运行实体之间的相互协作来实现. 通常情况下, 一个构件包含一个或多个可运行实体(Runnable Entity). 可运行实体是一段用于实现一个简单算法或某一特定功能的程序代码.
可运行实体之间的通信一般分为构件内部的通信和构件之间的通信. 位于同一构件的可运行实体可以共享构件内部的变量, 而位于不同构件之间的可运行实体则只能通过端口通信. 一般而言, 每个构件存在若干个端口(Port), 这些端口或用于数据通信, 或用于功能调用. 用于发送数据或提供服务的端口被称为P-Port,而用于接收数据或请求服务的端口被称为R-Port.
构件之间的通信关系 上图中有两个SWCs, c1 and c2. c1里面有3个runnables, c2里面有3个runables. 其中a和b分别为构件c1和c2的内部变量, r1和r2共享数据a, r4和r5共享数据b.
再举个ACC自动巡航的例子：
ACC: 自动巡航系统 Automotive adaptive cruise control system 汽车电子巡航控制系统主要由６个构件组成, 分别为传感器数据收集、目标对象选择、自由巡航控制、跟踪控制与加速仲裁、巡航控制与ACC状态机以及巡航控制和ACC车辆观测器. 根据这６个构件的功能和通信拓扑结构构建了39个可运行实体、3个触发关系、7个构件间的数据通信和23个构件内的共享数据,如上所示。
接下来就是正题了，如何把这些runnables分配到具体处理器可以调度的task里面去呢？
RTE触发事件呈现出周期性,但由于任务抢占、任务阻塞等原因而有着明显的抖动.因此,由这些RTE事件所触发的可运行实体也存在着明显的抖动, 即抖动会从以上一个可运行实体传递到下一个运行实体.
可运行实体的执行顺序 很容易理解：将不同周期的可运行实体映射到一个任务内,将会使任务被频繁调度.
a是正常触发执行，b为被阻塞后，会明显存在抖动现象。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
我们的目标是： 减少抖动时间减少阻塞时间减少调度频繁度减少数据通信量 对于目标1
具有触发关系的任务将会被合并到一个任务中,从而消除触发调用带来的任务抖动。
对于目标2
将两个存在共享变量的可运行实体映射到一个任务中,那么这个共享变量就成为了任务的内部变量. 在任务内部,可运行实体顺序执行,从而避免了阻塞。
对于目标3" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d6c1e368dde8a4e752e2c5b8d9d04588/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-12T18:38:35+08:00" />
<meta property="article:modified_time" content="2021-01-12T18:38:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分配策略_基于AUTOSAR的任务分配策略</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/fb/7e/wseUFLqP_o.png" alt="9d1d59b2a0838ef06524dff5c4f54638.png"> 
 </div> 
 <p>随着汽车电子应用程序对处理器性能需求的不断提高,现代汽车电子系统中的电子控制单元(ECU)已升级为多核结构.</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/d5/df/FuTvupgh_o.png" alt="a6aec80944e4785af97fb81d66977dd1.png"> 
 </div> 
 <figcaption>
   多核结构处理器 
 </figcaption> 
 <p>在系统级设计中,汽车电子应用程序由若干<b>构件(SWC)</b>组成. 每个构件实现了应用程序的某一特定功能. 若干构件通过相互协作共同实现应用程序的具体行为. 然而,在ECU设计中, 操作系统调度的对象却是<b>任务(Task)</b>. 因此,在进行ECU配置时,须将构件内的可<b>运行实体(Runnable entity)</b>映射到具体任务中,以供操作系统调度执行,这个过程被称为<b>"可运行实体到任务的映射"。</b></p> 
 <p>一种较为简单的映射方法是将每个可运行实体单独封装为一个任务, 简称<b>方法１。 </b>但是如此大量的任务会使得系统被频繁调度,增加系统的调度开销。</p> 
 <p>另一种较为实用的方法是将拥有相同周期的可运行实体映射为一个任务,简称<b>方法２。</b>然而,该方法忽略了可运行实体之间的依赖关系和数据通信,且缺乏在映射过程中对任务实时性的分析。在实际中,可运行实体到任务映射主要根据AUTOSAR标准中关于任务生成的规范,依靠软件工程师的丰富经验来手动完成. 目前的自动映射方法(如方法１和方法２)还不能很好地满足汽车电子系统对实时性的需求。</p> 
 <p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> 
 <p><b>有没有更优化更有效的方法来分配任务呢？思考研究一下:</b></p> 
 <p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> 
 <p>在AUTOSAR架构中, 汽车电子应用软件由构件(Software Component)组成. 构件的具体行为依靠可运行实体以及可运行实体之间的相互协作来实现. 通常情况下, 一个构件包含一个或多个可运行实体(Runnable Entity). 可运行实体是一段用于实现一个简单算法或某一特定功能的程序代码.</p> 
 <p>可运行实体之间的通信一般分为构件内部的通信和构件之间的通信. 位于同一构件的可运行实体可以共享构件内部的变量, 而位于不同构件之间的可运行实体则只能通过端口通信. 一般而言, 每个构件存在若干个端口(Port), 这些端口或用于数据通信, 或用于功能调用. 用于发送数据或提供服务的端口被称为P-Port,而用于接收数据或请求服务的端口被称为R-Port.</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/6d/3b/8cCv1UkT_o.png" alt="8ea03c96926f014bac09d91162b1288c.png"> 
 </div> 
 <figcaption>
   构件之间的通信关系 
 </figcaption> 
 <p>上图中有两个SWCs, c1 and c2. c1里面有3个runnables, c2里面有3个runables. 其中a和b分别为构件c1和c2的内部变量, r1和r2共享数据a, r4和r5共享数据b.</p> 
 <p>再举个ACC自动巡航的例子：</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/8c/f0/6lhLxOc8_o.png" alt="bf98f3de235b84ad6a6c802f4735483a.png"> 
 </div> 
 <figcaption>
   ACC: 自动巡航系统 Automotive adaptive cruise control system 
 </figcaption> 
 <p>汽车电子巡航控制系统主要由６个构件组成, 分别为<b>传感器数据收集</b>、<b>目标对象选择</b>、<b>自由巡航控制</b>、<b>跟踪控制与加速仲裁</b>、<b>巡航控制</b>与<b>ACC状态机</b>以及<b>巡航控制</b>和<b>ACC车辆观测器</b>. 根据这６个构件的功能和通信拓扑结构构建了39个可运行实体、3个触发关系、7个构件间的数据通信和23个构件内的共享数据,如上所示。</p> 
 <p>接下来就是正题了，如何把这些runnables分配到具体处理器可以调度的task里面去呢？</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/e9/1b/L8NTE4k6_o.png" alt="ab88ab20180d3bc7138431a25c0e8a17.png"> 
 </div> 
 <p>RTE触发事件呈现出周期性,但由于<b>任务抢占、任务阻塞</b>等原因而有着明显的抖动.因此,由这些RTE事件所触发的可运行实体也存在着明显的抖动, 即抖动会从以上一个可运行实体传递到下一个运行实体.</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/e9/78/cTsTgprE_o.png" alt="b55c59d0992b56db339c616e860d2701.png"> 
 </div> 
 <figcaption>
   可运行实体的执行顺序 
 </figcaption> 
 <p>很容易理解：将不同周期的可运行实体映射到一个任务内,将会使任务被频繁调度.</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/db/23/iTGzpOpU_o.png" alt="71c563ac686352470d09391aa6509341.png"> 
 </div> 
 <figcaption>
   a是正常触发执行，b为被阻塞后，会明显存在抖动现象。 
 </figcaption> 
 <p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p> 
 <h3><b>我们的目标是：</b></h3> 
 <ol><li><b>减少抖动时间</b></li><li><b>减少阻塞时间</b></li><li><b>减少调度频繁度</b></li><li><b>减少数据通信量</b></li></ol> 
 <p><i><b>对于目标1</b></i></p> 
 <p><i><b>具有触发关系的任务将会被合并到一个任务中,从而消除触发调用带来的任务抖动。</b></i></p> 
 <p><i><b>对于目标2</b></i></p> 
 <p><i><b>将两个存在共享变量的可运行实体映射到一个任务中,那么这个共享变量就成为了任务的内部变量. 在任务内部,可运行实体顺序执行,从而避免了阻塞。</b></i></p> 
 <p><i><b>对于目标3</b></i></p> 
 <p><i><b>一般而言,顺序触发的可运行实体都具有相同的周期. 将其映射到一个任务之后,任务的周期不变. 在任务每一次调度中都会将其中的可运行实体顺序执行一遍, 而非单独调度每个可运行实体,从而减少了系统调度的频率.</b></i></p> 
 <p><i><b>对于目标4</b></i></p> 
 <p><i><b>如果可运行实体之间的数据通信在任务内部进行,那么系统的通信开销将会减少.</b></i></p> 
 <p>当然也可以数学建模，通过IPL(整数线性规划)来自动优化分配策略，过程比较数学，这里就不展开了，有兴趣的可以自己搜索相关论文来了解学习。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f97606b9216e29bc3dd37682d63c37a8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">接收文件_2020年党内统计软件使用指引：2.启动系统接收数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a16d39eaaec23afe961fba4c3713fe9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">rust插件指令_Rust指令大全（包括服务器指令，插件指令）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>