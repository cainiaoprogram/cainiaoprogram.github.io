<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GTID概念介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GTID概念介绍" />
<meta property="og:description" content="GTID概念介绍 1 GTID概念介绍2 GTID工作原理3 GTID主从配置4mysql安装4.1node1 主机4.2node2 主机 5测试，是否同步 1 GTID概念介绍 GTID即全局事务ID (global transaction identifier), 其保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID。GTID最初由google实现，官方MySQL在5.6才加入该功能。mysql主从结构在一主一从情况下对于GTID来说就没有优势了，而对于2台主以上的结构优势异常明显，可以在数据不丢失的情况下切换新主。使用GTID需要注意: 在构建主从复制之前，在一台将成为主的实例上进行一些操作（如数据清理等），通过GTID复制，这些在主从成立之前的操作也会被复制到从服务器上，引起复制失败。也就是说通过GTID复制都是从最先开始的事务日志开始，即使这些操作在复制之前执行。比如在server1上执行一些drop、delete的清理操作，接着在server2上执行change的操作，会使得server2也进行server1的清理操作。
GTID实际上是由UUID&#43;TID (即transactionId)组成的。其中UUID(即server_uuid) 产生于auto.conf文件(cat /data/mysql/data/auto.cnf)，是一个MySQL实例的唯一标识。TID代表了该实例上已经提交的事务数量，并且随着事务提交单调递增，所以GTID能够保证每个MySQL实例事务的执行（不会重复执行同一个事务，并且会补全没有执行的事务）。GTID在一组复制中，全局唯一。 下面是一个GTID的具体形式 :
mysql&gt; show master status; &#43;------------------&#43;----------&#43;--------------&#43;------------------&#43;------------------------------------------&#43; | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | &#43;------------------&#43;----------&#43;--------------&#43;------------------&#43;------------------------------------------&#43; | mysql_bin.000001 | 1150 | | | b35dffb0-fc03-11ec-920f-000c29f6e7cf:1-4 | &#43;------------------&#43;----------&#43;--------------&#43;------------------&#43;------------------------------------------&#43; 1 row in set (0.01 sec) D:b35dffb0-fc03-11ec-920f-000c29f6e7cf:1-4 UUID:b35dffb0-fc03-11ec-920f-000c29f6e7cf transactionId:1-4 在整个复制架构中GTID 是不变化的,即使在多个连环主从中也不会变。 例如：ServerA ---&gt;ServerB ----&gt;ServerC GTID从在ServerA ,ServerB,ServerC 中都是一样的。 了解了GTID的格式，通过UUID可以知道这个事务在哪个实例上提交的。通过GTID可以极方便的进行复制结构上的故障转移，新主设置，这就很好地解决了下面这个图所展现出来的问题。
如图, Server1(Master)崩溃，根据从上show slave status获得Master_log_File/Read_Master_Log_Pos的值，Server2(Slave)已经跟上了主，Server3(Slave)没有跟上主。这时要是把Server2提升为主，Server3变成Server2的从。这时在Server3上执行change的时候需要做一些计算。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8a909e5590d3c48901c5839d29b18ef8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-18T10:24:41+08:00" />
<meta property="article:modified_time" content="2023-07-18T10:24:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GTID概念介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>GTID概念介绍</h4> 
 <ul><li><ul><li><ul><li><a href="#1_GTID_1" rel="nofollow">1 GTID概念介绍</a></li><li><a href="#2_GTID_87" rel="nofollow">2 GTID工作原理</a></li><li><a href="#3_GTID_102" rel="nofollow">3 GTID主从配置</a></li><li><a href="#4mysql_111" rel="nofollow">4mysql安装</a></li><li><ul><li><a href="#41node1__113" rel="nofollow">4.1node1 主机</a></li><li><a href="#42node2__304" rel="nofollow">4.2node2 主机</a></li></ul> 
    </li><li><a href="#5_617" rel="nofollow">5测试，是否同步</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="1_GTID_1"></a>1 GTID概念介绍</h4> 
<p>GTID即全局事务ID (global transaction identifier), 其保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID。GTID最初由google实现，官方MySQL在5.6才加入该功能。mysql主从结构在一主一从情况下对于GTID来说就没有优势了，而对于2台主以上的结构优势异常明显，可以在数据不丢失的情况下切换新主。使用GTID需要注意: 在构建主从复制之前，在一台将成为主的实例上进行一些操作（如数据清理等），通过GTID复制，这些在主从成立之前的操作也会被复制到从服务器上，引起复制失败。也就是说通过GTID复制都是从最先开始的事务日志开始，即使这些操作在复制之前执行。比如在server1上执行一些drop、delete的清理操作，接着在server2上执行change的操作，会使得server2也进行server1的清理操作。</p> 
<p>GTID实际上是由UUID+TID (即transactionId)组成的。其中UUID(即server_uuid) 产生于auto.conf文件(cat /data/mysql/data/auto.cnf)，是一个MySQL实例的唯一标识。TID代表了该实例上已经提交的事务数量，并且随着事务提交单调递增，所以GTID能够保证每个MySQL实例事务的执行（不会重复执行同一个事务，并且会补全没有执行的事务）。GTID在一组复制中，全局唯一。 下面是一个GTID的具体形式 :</p> 
<pre><code class="prism language-text">mysql&gt; show master status;
+------------------+----------+--------------+------------------+------------------------------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                        |
+------------------+----------+--------------+------------------+------------------------------------------+
| mysql_bin.000001 |     1150 |              |                  | b35dffb0-fc03-11ec-920f-000c29f6e7cf:1-4 |
+------------------+----------+--------------+------------------+------------------------------------------+
1 row in set (0.01 sec)




D:b35dffb0-fc03-11ec-920f-000c29f6e7cf:1-4
UUID:b35dffb0-fc03-11ec-920f-000c29f6e7cf
transactionId:1-4
 
在整个复制架构中GTID 是不变化的,即使在多个连环主从中也不会变。
 
例如：ServerA ---&gt;ServerB ----&gt;ServerC
GTID从在ServerA ,ServerB,ServerC 中都是一样的。
</code></pre> 
<p>了解了GTID的格式，通过UUID可以知道这个事务在哪个实例上提交的。通过GTID可以极方便的进行复制结构上的故障转移，新主设置，这就很好地解决了下面这个图所展现出来的问题。</p> 
<p><img src="https://images2.imgbox.com/58/be/f775pzDq_o.png" alt="在这里插入图片描述"></p> 
<p>如图, Server1(Master)崩溃，根据从上show slave status获得Master_log_File/Read_Master_Log_Pos的值，Server2(Slave)已经跟上了主，Server3(Slave)没有跟上主。这时要是把Server2提升为主，Server3变成Server2的从。这时在Server3上执行change的时候需要做一些计算。</p> 
<p>这个问题在5.6的GTID出现后，就显得非常的简单。由于同一事务的GTID在所有节点上的值一致，那么根据Server3当前停止点的GTID就能定位到Server2上的GTID。甚至由于MASTER_AUTO_POSITION功能的出现，我们都不需要知道GTID的具体值，直接使用CHANGE MASTER TO MASTER_HOST=‘xxx’, MASTER_AUTO_POSITION命令就可以直接完成failover的工作。</p> 
<p>GTID和Binlog的关系</p> 
<ul><li>GTID在binlog中的结构</li></ul> 
<p><img src="https://images2.imgbox.com/99/4a/ObVUhjyM_o.png" alt="在这里插入图片描述"></p> 
<ul><li>GTID event 结构</li></ul> 
<p><img src="https://images2.imgbox.com/dc/d1/1gHgGv0Y_o.png" alt="在这里插入图片描述"></p> 
<ul><li>Previous_gtid_log_event<br> Previous_gtid_log_event 在每个binlog 头部都会有每次binlog rotate的时候存储在binlog头部Previous-GTIDs在binlog中只会存储在这台机器上执行过的所有binlog，不包括手动设置gtid_purged值。换句话说，如果你手动set global gtid_purged=xx； 那么xx是不会记录在Previous_gtid_log_event中的。</li><li>GTID和Binlog之间的关系是怎么对应的呢? 如何才能找到GTID=? 对应的binlog文件呢？<br> 假设有4个binlog: bin.001,bin.002,bin.003,bin.004<br> bin.001 : Previous-GTIDs=empty; binlog_event有: 1-40<br> bin.002 : Previous-GTIDs=1-40; binlog_event有: 41-80<br> bin.003 : Previous-GTIDs=1-80; binlog_event有: 81-120<br> bin.004 : Previous-GTIDs=1-120; binlog_event有: 121-160<br> 假设现在我们要找GTID=$A，那么MySQL的扫描顺序为:</li><li>从最后一个binlog开始扫描（即: bin.004）</li><li>bin.004的Previous-GTIDs=1-120，如果$A=140 &gt; Previous-GTIDs,那么肯定在bin.004中</li><li>bin.004的Previous-GTIDs=1-120，如果$A=88 包含在Previous-GTIDs中,那么继续对比上一个binlog文件 bin.003,然后再循环前面2个步骤，直到找到为止.</li></ul> 
<p>GTID 重要参数的持久化</p> 
<ul><li>GTID相关参数</li></ul> 
<table><thead><tr><th>参数</th><th>comment</th></tr></thead><tbody><tr><td>gtid_executed</td><td>执行过的所有GTID</td></tr><tr><td>gtid_purged</td><td>丢弃掉的GTID</td></tr><tr><td>gtid_mode</td><td>GTID模式</td></tr><tr><td>gtid_next</td><td>session级别的变量，下一个gtid</td></tr><tr><td>gtid_owned</td><td>正在运行的GTID</td></tr><tr><td>enforce_gtid_consistency</td><td>保证GTID安全的参数</td></tr></tbody></table> 
<p>开启GTID的必备条件</p> 
<pre><code class="prism language-text">gtid_mode=on    (必选)
enforce-gtid-consistency=1  （必选）
log_bin=mysql-bin           （可选）    #高可用切换，最好开启该功能
log-slave-updates=1     （可选）       #高可用切换，最好打开该功能
</code></pre> 
<h4><a id="2_GTID_87"></a>2 GTID工作原理</h4> 
<p>从服务器连接到主服务器之后，把自己执行过的GTID (Executed_Gtid_Set: 即已经执行的事务编码) 、获取到的GTID (Retrieved_Gtid_Set: 即从库已经接收到主库的事务编号) 发给主服务器，主服务器把从服务器缺少的GTID及对应的transactions发过去补全即可。当主服务器挂掉的时候，找出同步最成功的那台从服务器，直接把它提升为主即可。如果硬要指定某一台不是最新的从服务器提升为主， 先change到同步最成功的那台从服务器， 等把GTID全部补全了，就可以把它提升为主了。</p> 
<p>GTID是MySQL 5.6的新特性，可简化MySQL的主从切换以及Failover。GTID用于在binlog中唯一标识一个事务。当事务提交时，MySQL Server在写binlog的时候，会先写一个特殊的Binlog Event，类型为GTID_Event，指定下一个事务的GTID，然后再写事务的Binlog。主从同步时GTID_Event和事务的Binlog都会传递到从库，从库在执行的时候也是用同样的GTID写binlog，这样主从同步以后，就可通过GTID确定从库同步到的位置了。也就是说，无论是级联情况，还是一主多从情况，都可以通过GTID自动找点儿，而无需像之前那样通过File_name和File_position找点儿了。</p> 
<p>简而言之，GTID的工作流程为：</p> 
<ul><li>master更新数据时，会在事务前产生GTID，一同记录到binlog日志中。</li><li>slave端的i/o 线程将变更的binlog，写入到本地的relay log中。</li><li>sql线程从relay log中获取GTID，然后对比slave端的binlog是否有记录。</li><li>如果有记录，说明该GTID的事务已经执行，slave会忽略。</li><li>如果没有记录，slave就会从relay log中执行该GTID的事务，并记录到binlog。</li><li>在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有就用全部扫描。</li></ul> 
<h4><a id="3_GTID_102"></a>3 GTID主从配置</h4> 
<p><strong>环境说明：</strong></p> 
<table><thead><tr><th align="center">数据库角色</th><th>IP</th><th>应用与系统版本</th><th>有无数据</th><th>主机名</th></tr></thead><tbody><tr><td align="center">主数据库</td><td>192.168.229.130</td><td>centos8/redhat8 mysql-5.7</td><td>无数据</td><td>node1</td></tr><tr><td align="center">从数据库</td><td>192.168.229.145</td><td>centos8/redhat8 mysql-5.7</td><td>无数据</td><td>node2</td></tr></tbody></table> 
<h4><a id="4mysql_111"></a>4mysql安装</h4> 
<h5><a id="41node1__113"></a>4.1node1 主机</h5> 
<pre><code># 下载二进制格式的mysql软件包
[root@node1 ~]# cd /opt/
[root@node1 opt]# wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.37-linux-glibc2.12-x86_64.tar.gz
[root@node1 opt]# ls
mysql-5.7.37-linux-glibc2.12-x86_64.tar.gz

# 解压，并改为mysql
## 解压到/usr/local/
[root@node1 opt]# tar xf mysql-5.7.37-linux-glibc2.12-x86_64.tar.gz -C /usr/local/
[root@node1 local]# ls
bin  etc  games  include  lib  lib64  libexec  mysql-5.7.37-linux-glibc2.12-x86_64  sbin  share  src
# 改名为mysql
[root@node1 local]# mv mysql-5.7.37-linux-glibc2.12-x86_64 mysql
[root@node1 local]# ls
bin  etc  games  include  lib  lib64  libexec  mysql  sbin  share  src


# 创建mysql系统用户，没有家目录，不需要登录
[root@node1 ~]# useradd -r -M -s /sbin/nologin mysql
[root@node1 ~]# id mysql
uid=995(mysql) gid=992(mysql) groups=992(mysql)

#修改目录/usr/local/mysql的属主属组
[root@node1 local]#  chown -R mysql.mysql mysql
[root@node1 local]# ll mysql/ -d
drwxr-xr-x. 9 mysql mysql 129 Jul  5 09:18 mysql/


# 添加环境变量(你也可以直接vim 写到/etc/profile.d/mysql.sh下面)
[root@node1 ~]# echo 'export PATH=/usr/local/mysql/bin:$PATH' &gt; /etc/profile.d/mysql.sh
[root@node1 ~]# source /etc/profile.d/mysql.sh # 刷新，让其生效
[root@node1 ~]# which mysqld
/usr/local/mysql/bin/mysqld



# 配置include
## 软链接到/usr/include/mysql，叫mysql
[root@node1 ~]# ln -s /usr/local/mysql/include /usr/include/mysql


# 配置 man 文档
[root@node1 ~]# vim /etc/man_db.conf
MANDATORY_MANPATH   /usr/local/share/man
MANDATORY_MANPATH   /usr/local/mysql/man # 添加这条

# 映射库文件
[root@node1 ~]# vim /etc/ld.so.conf.d/mysql.conf
/usr/local/mysql/lib
[root@node1 ~]# ldconfig # 让其生效

# 建立数据存放目录
[root@node1 ~]# mkdir /opt/data
# 设置所有者和所属组为mysql
[root@node1 ~]# chown -R mysql.mysql /opt/data/
[root@node1 ~]# ll /opt/data/ -d
drwxr-xr-x. 2 mysql mysql 6 Jun 28 16:36 /opt/data/

# 初始化数据库
[root@node1 ~]# /usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/opt/data/
.....省略
root@node1: z!r;kBSfX5uu  # 临时密码
# 请注意，这个命令的最后会生成一个临时密码，此处密码是 z!r;kBSfX5uu
# 再次注意，这个密码是随机的，你的不会跟我一样，一定要记住这个密码，因为一会登录时会用到


# 生成配置文件
[root@node1 ~]# vim /etc/my.cnf
[mysqld]
basedir = /usr/local/mysql
datadir = /opt/data
socket = /tmp/mysql.sock
port = 3306
pid-file = /opt/data/mysql.pid
user = mysql
skip-name-resolve
sql-mode = STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION


# 配置服务启动脚本
[root@node1 ~]# cd /usr/local/mysql/support-files/
# 复制
[root@node1 support-files]# cp mysql.server mysqld
# 更改所有者和所属组为MySQL
[root@node1 support-files]# chown -R mysql.mysql mysqld
[root@node1 support-files]# ll mysqld -d
-rwxr-xr-x. 1 mysql mysql 10576 Jul  5 09:44 mysqld



# 启动mysql
[root@node1 ~]# /usr/local/mysql/support-files/mysqld start
Starting MySQL.Logging to '/opt/data/node1.err'.
 SUCCESS!

[root@node1 ~]#  ps -ef|grep mysql
root       10496       1  0 09:46 pts/1    00:00:00 /bin/sh /usr/local/mysql/binmysqld_safe --datadir=/opt/data --pid-file=/opt/data/mysql.pid
mysql      10696   10496  1 09:46 pts/1    00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/opt/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=node1.err --pid-file=/opt/data/mysql.pid --socket=/tmp/mysql.sock --port=3306
root       10726    1754  0 09:46 pts/1    00:00:00 grep --color=auto mysql



[root@node1 ~]# ss -antl
State   Recv-Q  Send-Q   Local Address:Port  Peer Address:Port   Process        
LISTEN    0     128          0.0.0.0:22         0.0.0.0:*                          
LISTEN    0     128           [::]:22             [::]:*                          
LISTEN    0     80           *:3306               *:*   


# 安装依赖包 (不安装登录不了)
[root@node1 ~]# dnf -y install ncurses-compat-libs



# 使用临时密码登录
[root@node1 ~]# mysql -uroot -p'z!r;kBSfX5uu'
....省略
 # 看到这个ok
mysql&gt; 

# 修改密码
mysql&gt; set password = password('runtime123!');
## 退出使用设置好的密码登录
[root@node1 ~]# mysql -uroot -pruntime123!
....省略
mysql&gt; 


# 配置service文件，目的让MySQL能够开机自启

# 配置service文件之前关闭关闭防火墙和SElinux
# 关闭防火墙和SElinux
[root@node1 ~]# systemctl disable --now firewalld

# 临时关闭
[root@node1 ~]# setenforce 0


# 永久关闭
[root@node1 ~]# vim /etc/selinux/config
[root@node1 ~]#  head -7 /etc/selinux/config | tail -1
SELINUX=disabled # 把它改为disabled 

# 杀死 mysql 进程
[root@node1 ~]# pkill mysqld

# 复制到当前目录下、更改它
[root@node1 ~]# cd /usr/lib/systemd/system/
[root@node1 system]# cp sshd.service mysqld.service
[root@node1 system]# vim mysqld.service
[Unit]
Description=mysql server daemon
After=network.target sshd-keygen.target
[Service]
Type=forking
ExecStart=/usr/local/mysql/support-files/mysqld start
ExecStop=/usr/local/mysql/support-files/mysqld stop
ExecReload=/bin/kill -HUP $MAINPID

[Install]
WantedBy=multi-user.target

# 刷新程序、让其生效
[root@node1 ~]#  systemctl daemon-reload
# 查看状态
[root@node1 ~]#  systemctl status mysqld
● mysql.service - mysql server daemon
   Loaded: loaded (/usr/lib/systemd/system/mysql.service; disabled; vendor preset: disabled)
   Active: inactive (dead)

# 设置为开机自启、并立马启动
[root@node1 ~]# systemctl enable --now mysqld
Created symlink /etc/systemd/system/multi-user.target.wants/mysqld.service→ /usr/lib/systemd/system/mysqld.service.
[root@node1 ~]#  systemctl status mysqld
● mysqld.service - mysql server daemon
   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor&gt;
   Active: active (running) since Tue 2022-07-05 09:54:22 CST; 2s ago
  Process: 10855 ExecStart=/usr/local/mysql/support-files/mysqld start (co&gt;
 Main PID: 10868 (mysqld_safe)
.....省略

[root@node1 ~]# ss -antl
State   Recv-Q  Send-Q   Local Address:Port  Peer Address:Port   Process        
LISTEN    0     128          0.0.0.0:22         0.0.0.0:*                          
LISTEN    0     128           [::]:22             [::]:*                          
LISTEN    0     80           *:3306               *:*   
</code></pre> 
<h5><a id="42node2__304"></a>4.2node2 主机</h5> 
<pre><code># 下载二进制格式的mysql软件包
[root@node2 ~]# cd /opt/
[root@node2 opt]# wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.37-linux-glibc2.12-x86_64.tar.gz
[root@node2 opt]# ls
mysql-5.7.37-linux-glibc2.12-x86_64.tar.gz

# 解压，并改为mysql
## 解压到/usr/local/
[root@node2 opt]# tar xf mysql-5.7.37-linux-glibc2.12-x86_64.tar.gz -C /usr/local/
[root@node2 local]# ls
bin  etc  games  include  lib  lib64  libexec  mysql-5.7.37-linux-glibc2.12-x86_64  sbin  share  src
# 改名为mysql
[root@node2 local]# mv mysql-5.7.37-linux-glibc2.12-x86_64 mysql
[root@node2 local]# ls
bin  etc  games  include  lib  lib64  libexec  mysql  sbin  share  src


# 创建mysql系统用户，没有家目录，不需要登录
[root@node2 ~]# useradd -r -M -s /sbin/nologin mysql
[root@node2 ~]# id mysql
uid=995(mysql) gid=992(mysql) groups=992(mysql)

#修改目录/usr/local/mysql的属主属组
[root@node2 local]#  chown -R mysql.mysql mysql
[root@node2 local]# ll mysql/ -d
drwxr-xr-x. 9 mysql mysql 129 Jul  5 09:18 mysql/


# 添加环境变量(你也可以直接vim 写到/etc/profile.d/mysql.sh下面)
[root@node2 ~]# echo 'export PATH=/usr/local/mysql/bin:$PATH' &gt; /etc/profile.d/mysql.sh
[root@node2 ~]# source /etc/profile.d/mysql.sh # 刷新，让其生效
[root@node2 ~]# which mysqld
/usr/local/mysql/bin/mysqld



# 配置include
## 软链接到/usr/include/mysql，叫mysql
[root@node2 ~]# ln -s /usr/local/mysql/include /usr/include/mysql


# 配置 man 文档
[root@node2 ~]# vim /etc/man_db.conf
MANDATORY_MANPATH   /usr/local/share/man
MANDATORY_MANPATH   /usr/local/mysql/man # 添加这条

# 映射库文件
[root@node2 ~]# vim /etc/ld.so.conf.d/mysql.conf
/usr/local/mysql/lib
[root@node2 ~]# ldconfig # 让其生效

# 建立数据存放目录
[root@node2 ~]# mkdir /opt/data
# 设置所有者和所属组为mysql
[root@node2 ~]# chown -R mysql.mysql /opt/data/
[root@node2 ~]# ll /opt/data/ -d
drwxr-xr-x. 2 mysql mysql 6 Jun 28 16:36 /opt/data/

# 初始化数据库
[root@node2 ~]# /usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/opt/data/
.....省略
root@node2:!MAsgd+h9pgl  # 临时密码
# 请注意，这个命令的最后会生成一个临时密码，此处密码是 !MAsgd+h9pgl
# 再次注意，这个密码是随机的，你的不会跟我一样，一定要记住这个密码，因为一会登录时会用到


# 生成配置文件
[root@node2 ~]# vim /etc/my.cnf
[mysqld]
basedir = /usr/local/mysql
datadir = /opt/data
socket = /tmp/mysql.sock
port = 3306
pid-file = /opt/data/mysql.pid
user = mysql
skip-name-resolve
sql-mode = STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION


# 配置服务启动脚本
[root@node2 ~]# cd /usr/local/mysql/support-files/
# 复制
[root@node2 support-files]# cp mysql.server mysqld
# 更改所有者和所属组为MySQL
[root@node2 support-files]# chown -R mysql.mysql mysqld
[root@node2 support-files]# ll mysqld -d
-rwxr-xr-x. 1 mysql mysql 10576 Jul  5 09:44 mysqld



# 启动mysql
[root@node2 ~]# /usr/local/mysql/support-files/mysqld start
Starting MySQL.Logging to '/opt/data/node1.err'.
 SUCCESS!

[root@node2 ~]#  ps -ef|grep mysql
root       10496       1  0 09:46 pts/1    00:00:00 /bin/sh /usr/local/mysql/binmysqld_safe --datadir=/opt/data --pid-file=/opt/data/mysql.pid
mysql      10696   10496  1 09:46 pts/1    00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/opt/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=node1.err --pid-file=/opt/data/mysql.pid --socket=/tmp/mysql.sock --port=3306
root       10726    1754  0 09:46 pts/1    00:00:00 grep --color=auto mysql



[root@node2 ~]# ss -antl
State   Recv-Q  Send-Q   Local Address:Port  Peer Address:Port   Process        
LISTEN    0     128          0.0.0.0:22         0.0.0.0:*                          
LISTEN    0     128           [::]:22             [::]:*                          
LISTEN    0     80           *:3306               *:*   


# 安装依赖包 (不安装登录不了)
[root@node2 ~]# dnf -y install ncurses-compat-libs



# 使用临时密码登录
[root@node2 ~]# mysql -uroot -p'!MAsgd+h9pgl'
....省略
 # 看到这个ok
mysql&gt; 

# 修改密码
mysql&gt; set password = password('runtime123!');
## 退出使用设置好的密码登录
[root@node2 ~]# mysql -uroot -pruntime123!
....省略
mysql&gt; 


# 配置service文件，目的让MySQL能够开机自启

# 配置service文件之前关闭关闭防火墙和SElinux
# 关闭防火墙和SElinux
[root@node2 ~]# systemctl disable --now firewalld

# 临时关闭
[root@node2 ~]# setenforce 0


# 永久关闭
[root@node2 ~]# vim /etc/selinux/config
[root@node2 ~]#  head -7 /etc/selinux/config | tail -1
SELINUX=disabled # 把它改为disabled 

# 杀死 mysql 进程
[root@node2 ~]# pkill mysqld

# 复制到当前目录下、更改它
[root@node2 ~]# cd /usr/lib/systemd/system/
[root@node2 system]# cp sshd.service mysqld.service
[root@node2 system]# vim mysqld.service
[Unit]
Description=mysql server daemon
After=network.target sshd-keygen.target
[Service]
Type=forking
ExecStart=/usr/local/mysql/support-files/mysqld start
ExecStop=/usr/local/mysql/support-files/mysqld stop
ExecReload=/bin/kill -HUP $MAINPID

[Install]
WantedBy=multi-user.target

# 刷新程序、让其生效
[root@node2 ~]#  systemctl daemon-reload
# 查看状态
[root@node2 ~]#  systemctl status mysqld
● mysql.service - mysql server daemon
   Loaded: loaded (/usr/lib/systemd/system/mysql.service; disabled; vendor preset: disabled)
   Active: inactive (dead)

# 设置为开机自启、并立马启动
[root@node2 ~]# systemctl enable --now mysqld
Created symlink /etc/systemd/system/multi-user.target.wants/mysqld.service→ /usr/lib/systemd/system/mysqld.service.
[root@node2 ~]#  systemctl status mysqld
● mysqld.service - mysql server daemon
   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor&gt;
   Active: active (running) since Tue 2022-07-05 09:54:22 CST; 2s ago
  Process: 10855 ExecStart=/usr/local/mysql/support-files/mysqld start (co&gt;
 Main PID: 10868 (mysqld_safe)
.....省略

[root@node2 ~]# ss -antl
State   Recv-Q  Send-Q   Local Address:Port  Peer Address:Port   Process        
LISTEN    0     128          0.0.0.0:22         0.0.0.0:*                          
LISTEN    0     128           [::]:22             [::]:*                          
LISTEN    0     80           *:3306               *:*   


</code></pre> 
<p>主库配置。vi /etc/my.cnf，添加以下配置，重启mysql。</p> 
<pre><code class="prism language-text">log-bin=mysql_bin
server-id=10
gtid_mode=on
enforce-gtid-consistency=true
log-slave-updates=on

[root@node1 ~]# cat /etc/my.cnf
[mysqld]
basedir = /usr/local/mysql
datadir = /opt/data
socket = /tmp/mysql.sock
port = 3306
pid-file = /opt/data/mysql.pid
user = mysql
skip-name-resolve
sql-mode = STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

log-bin = mysql_bin # 添加
server-id = 10 # 添加
gtid_mode = on # 添加
enforce-gtid-consistency = true # 添加
log-slave-updates = on # 添加

# 重启mysql
[root@node1 ~]# systemctl restart mysqld
</code></pre> 
<p>从库配置。vi /etc/my.cnf, 添加以下配置，重启mysql。</p> 
<pre><code class="prism language-text">server-id=20
relay-log=myrelay
gtid_mode=on
enforce-gtid-consistency=true
log-slave-updates=on
read_only=on
master-info-repository=TABLE
relay-log-info-repository=TABLE

[root@node2 ~]# cat /etc/my.cnf
[mysqld]
basedir = /usr/local/mysql
datadir = /opt/data
socket = /tmp/mysql.sock
port = 3306
pid-file = /opt/data/mysql.pid
user = mysql
skip-name-resolve
sql-mode = STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

server-id = 20
relay-log = myrelay
gtid_mode = on
enforce-gtid-consistency = true
log-slave-updates = on
read_only = on
master-info-repository = TABLE
relay-log-info-repository = TABLE

# 重启mysql
[root@node1 ~]# systemctl restart mysqld
</code></pre> 
<p>主库授权复制用户。</p> 
<pre><code class="prism language-text">set global validate_password_policy=0; # 这是在centos7/redhat7操作，在centos8/redhat8里不用做
set global validate_password_length=1;  # 这是在centos7/redhat7操作，在centos8/redhat8里不用做
grant replication slave on *.* to 'tom'@'%' identified by 'tom123!';

# 登录进去操作
[root@node1 ~]# mysql -uroot -pruntime123!
mysql&gt; grant replication slave on *.* to 'tom'@'%' identified by 'tom123!';
Query OK, 0 rows affected, 1 warning (0.01 sec)
# 你可以把% 号改为某个ip地址。
</code></pre> 
<p>从库设置要同步的主库信息，并开启同步。</p> 
<pre><code class="prism language-text">change master to master_host='192.168.229.130', \  # ip 是主库ip
master_port=3306,master_user='tom',master_password='tom123!', \
master_auto_position=1;

# 登录进去操作
[root@node2 ~]# mysql -uroot -pruntime123!
mysql&gt; change master to master_host='192.168.229.130',
master_port=3306,master_user='tom',master_password='tom123!', master_auto_position=1;
Query OK, 0 rows affected, 2 warnings (0.00 sec)

# 启动
mysql&gt; start slave;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; show slave status\G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.229.130
                  Master_User: tom
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql_bin.000001
          Read_Master_Log_Pos: 436
               Relay_Log_File: myrelay.000002
                Relay_Log_Pos: 649
        Relay_Master_Log_File: mysql_bin.000001
             Slave_IO_Running: Yes  # 这个一定要为yes
            Slave_SQL_Running: Yes  # 这个一定要为yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
.......省略N
</code></pre> 
<p>配置完之后，通过查看slave的状态，可以看是否配置成功。同时可以在主库进行一些操作，提交一些事务(insert,update)，之后数据就会自动同步到从库。</p> 
<h4><a id="5_617"></a>5测试，是否同步</h4> 
<p>node1操作</p> 
<pre><code># 创建数据库school，在里面创建一张表
mysql&gt; create database school;
Query OK, 1 row affected (0.00 sec)

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| school             |
| sys                |
+--------------------+
5 rows in set (0.01 sec)


mysql&gt; use school;
Database changed
mysql&gt; create table tom(
    -&gt; id int(11) not null primary key auto_increment,
    -&gt; name varchar(20) not null
    -&gt; )charset utf8;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; insert tom(name) values('陈冠希'),('张国荣'),('刘德华');
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; select * from tom;
+----+-----------+
| id | name      |
+----+-----------+
|  1 | 陈冠希    |
|  2 | 张国荣    |
|  3 | 刘德华    |
+----+-----------+
3 rows in set (0.01 sec)
</code></pre> 
<p>node2 查看是否同步</p> 
<pre><code># 登录进去
[root@node2 ~]# mysql -uroot -pruntime123!
..........省略

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| school             | # 数据库已存在
| sys                |
+--------------------+
5 rows in set (0.01 sec)

# 进去数据库里查看表
Database changed
mysql&gt; show tables;
+------------------+
| Tables_in_school |
+------------------+
| tom              |
+------------------+
1 row in set (0.00 sec)

mysql&gt; select * from tom;
+----+-----------+
| id | name      |
+----+-----------+
|  1 | 陈冠希    |
|  2 | 张国荣    |
|  3 | 刘德华    |
+----+-----------+
3 rows in set (0.00 sec)
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/906d6871eecfdc03a5549bf90e10491a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数字IC前端笔试真题精刷（2023）】专栏内容规划</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ffc81ebc7ccec077031671169cba8704/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CSS中的BFC，是什么？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>