<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python深度学习实战PyQt5信号与槽的连接 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python深度学习实战PyQt5信号与槽的连接" />
<meta property="og:description" content="本文讲解信号与槽的连接机制，详细示范各种类型的信号/槽连接的实现方法，这是图形用户界面的核心内容。还将介绍面向对象的程序设计，这是图形用户界面的基本思想
目录 1. 信号与槽（Signals and slots） 信号与槽机制是 PyQt 的核心机制，用于对象之间的通信，也就是实现函数之间的自动调用。
1.1 信号与槽的原理 简单地说，将信号与槽函数连接后，当信号被触发时，槽函数将被自动调用。
分析这个过程，涉及到几个基本概念和关系：
信号：信号可以是一个动作，也可以是对象的一种状态，用于触发所连接的槽。
槽：槽就是一个函数，可以由连接的信号触发。
发射信号：信号被发射时，自动调用信号连接的槽函数。通常，在对象的状态改变时发射信号。
信号可以带有参数，但必须与槽函数的参数相对应。
一个信号可以连接多个槽函数，多个信号也可以连接到一个槽函数。
一个信号可以连接到另一个信号上。
很多窗口部件（控件）内置了一下信号和槽，可以直接调用。也可以按需求自定义信号和槽。
1.2 信号发送者与槽的接收者 信号的发送者通常是一个控件对象，在控件对象的状态发生变化时发送信号。常见的发送者是图形窗口中的各种控件对象，但也可以是动作对象。
槽的接收者通常也是控件对象。槽函数是一个自定义的槽函数，或控件内置的槽函数。一般地，槽函数也有一个对象作为主体，即对于接受者这个控件对象执行函数定义的操作。例如槽函数执行的功能是关闭，哪么究竟是关闭那个控件呢？关闭对象就是接受者。
为了方便讲解信号与槽的连接，我们用 QtDesigner 在上节设计的图形窗口 uiDemo3.ui 的基础上，增加几个按钮对象和文本行编辑对象：
打开 PyCharm，从 Tools -&gt; ExternalTools -&gt; QtDesigner 打开 QtDesigner，打开 uiDemo3.ui 文件。
鼠标点击选中 QtDesigner 左侧控件栏 Buttons 中的 PushButton，按住鼠标不放，将其拖动到中间的图形界面后松开鼠标，就在图形界面中创建了一个 PushButton 控件。
鼠标点击选中 QtDesigner 左侧控件栏 InputWidget 中的 LineEdit，按住鼠标不放，将其拖动到中间的图形界面后松开鼠标，就在图形界面中创建了一个 LineEdit 控件。
重复以上步骤，再建立几个 PushButton 控件和 LineEdit 控件。
注意在 QtDesigner 右侧 “对象查看器” 中所显示的控件名称和属性，多个 PushButton、LineEdit 被自动赋予不同的命名（objectName），如：LineEdit_1、LineEdit_2、LineEdit_3，这就如同桌子有几个抽屉分别标记为 “抽屉1”、“抽屉2”、“抽屉3” 以便识别。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6a2c107141d2207c47e380aa8a7dd6c2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-09T11:38:37+08:00" />
<meta property="article:modified_time" content="2023-02-09T11:38:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python深度学习实战PyQt5信号与槽的连接</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="text-align:null;">本文讲解信号与槽的连接机制，详细示范各种类型的信号/槽连接的实现方法，这是图形用户界面的核心内容。还将介绍面向对象的程序设计，这是图形用户界面的基本思想</p> 
 <h6 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">目录</span></h6> 
 <p style="text-align:right;"></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1. 信号与槽（Signals and slots）</span></h3> 
 <p style="text-align:left;">信号与槽机制是 PyQt 的核心机制，用于对象之间的通信，也就是实现函数之间的自动调用。</p> 
 <p style="text-align:right;"></p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1.1 信号与槽的原理</span></h4> 
 <p style="text-align:left;">简单地说，将信号与槽函数连接后，当信号被触发时，槽函数将被自动调用。</p> 
 <p style="text-align:left;">分析这个过程，涉及到几个基本概念和关系：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>信号：信号可以是一个动作，也可以是对象的一种状态，用于触发所连接的槽。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>槽：槽就是一个函数，可以由连接的信号触发。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>发射信号：信号被发射时，自动调用信号连接的槽函数。通常，在对象的状态改变时发射信号。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>信号可以带有参数，但必须与槽函数的参数相对应。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>一个信号可以连接多个槽函数，多个信号也可以连接到一个槽函数。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>一个信号可以连接到另一个信号上。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>很多窗口部件（控件）内置了一下信号和槽，可以直接调用。也可以按需求自定义信号和槽。</p></li></ul> 
 <p style="text-align:right;"></p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">1.2 信号发送者与槽的接收者</span></h4> 
 <p style="text-align:left;">信号的发送者通常是一个控件对象，在控件对象的状态发生变化时发送信号。常见的发送者是图形窗口中的各种控件对象，但也可以是动作对象。</p> 
 <p style="text-align:left;">槽的接收者通常也是控件对象。槽函数是一个自定义的槽函数，或控件内置的槽函数。一般地，槽函数也有一个对象作为主体，即对于接受者这个控件对象执行函数定义的操作。例如槽函数执行的功能是关闭，哪么究竟是关闭那个控件呢？关闭对象就是接受者。</p> 
 <p style="text-align:left;">为了方便讲解信号与槽的连接，我们用 QtDesigner 在上节设计的图形窗口 uiDemo3.ui 的基础上，增加几个按钮对象和文本行编辑对象：</p> 
 <p style="text-align:left;">打开 PyCharm，从 Tools -&gt; ExternalTools -&gt; QtDesigner 打开 QtDesigner，打开 uiDemo3.ui 文件。</p> 
 <p style="text-align:left;">鼠标点击选中 QtDesigner 左侧控件栏 Buttons 中的 PushButton，按住鼠标不放，将其拖动到中间的图形界面后松开鼠标，就在图形界面中创建了一个 PushButton 控件。</p> 
 <p style="text-align:left;">鼠标点击选中 QtDesigner 左侧控件栏 InputWidget 中的 LineEdit，按住鼠标不放，将其拖动到中间的图形界面后松开鼠标，就在图形界面中创建了一个 LineEdit 控件。</p> 
 <p style="text-align:left;">重复以上步骤，再建立几个 PushButton 控件和 LineEdit 控件。</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>注意在 QtDesigner 右侧 “对象查看器” 中所显示的控件名称和属性，多个 PushButton、LineEdit 被自动赋予不同的命名（objectName），如：LineEdit_1、LineEdit_2、LineEdit_3，这就如同桌子有几个抽屉分别标记为 “抽屉1”、“抽屉2”、“抽屉3” 以便识别。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>控件的名称和其它属性都可以在 “属性编辑器” 中编辑修改。</p></li></ul> 
 <p style="text-align:left;">鼠标选中在图形界面中创建的 PushButton 控件或 LineEdit 控件，可以拖动控件调整位置。</p> 
 <p style="text-align:left;">鼠标双击 PushButton 按钮，可以编辑按钮控件的标签即按钮上的显示内容。</p> 
 <p style="text-align:left;">为了便于讲解，本例将各 PushButton 控件的显示内容（text 属性）修改为：“1# 按钮” ~ “4# 按钮”，将各 LineEdit 控件的显示内容（text 属性）修改为：“文本编辑行-1” ~ “文本编辑行-3”。</p> 
 <p style="text-align:left;">将这个应用程序图形界面另存为 uiDemo4.ui，其预览效果如下：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:79.054054%;height:0;"> 
    <img src="https://images2.imgbox.com/02/42/NDOROtDt_o.png" style="margin-left:;display:block;width:740px;margin-top:-79.054054%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:right;"></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2. QtDesigner 建立信号与槽的连接</span></h3> 
 <p style="text-align:right;"></p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.1 信号与槽的连接：不同的发送者与接收者，槽函数为控件的内置函数</span></h4> 
 <p style="text-align:left;">QtDesigner 提供了便捷和直观的信号/槽编辑方法。</p> 
 <p style="text-align:left;">本例介绍不同的发送者与接收者，槽函数为控件的内置函数的操作方法。不同类型的控件分别内置了若干方法，例如 QPushButton 控件内置的方法包括：点击、选中、状态变化、显示菜单等，而 QLineEdit 控件内置的方法包括：清空、复制、剪切、粘贴、全选、撤销操作等。使用控件内置的方法作为槽函数，可以直接调用，不需要对函数进行定义。</p> 
 <p style="text-align:left;">我们所设计的功能是：当点击按钮控件 “pushButton_1” 时，清空文本编辑控件 “lineEdit_1” 的显示内容。注意我们称按钮控件为 “lineEdit_1” 而不是 “文本编辑行-1”，这是因为 lineEdit_1 才是控件名称，在程序中是不变的，而 “文本编辑行-1” 只是显示内容，可以在程序中修改。</p> 
 <p style="text-align:right;"></p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">QtDesigner 设置信号/槽的连接的操作步骤如下：</span></h5> 
 <p style="text-align:left;">（1）选择菜单项 “Edit” -&gt; 编辑信号/槽，或者通过快捷键 F4 或在工具栏选择，进入信号/槽编辑模式。</p> 
 <p style="text-align:left;">（2）选中控件对象发送者，此处为按钮控件 “pushButton_1”，鼠标左键长按不放，该按钮控件变为浅红色。</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>鼠标左键继续长按不放，并移动鼠标，当鼠标移出控件对象区域后，出现一条带箭头的红线和一个红色的接地符号。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>鼠标左键继续长按不放，并拖动鼠标到控件对象 “lineEdit_1”，松开鼠标左键，就建立了以控件对象 “pushButton_1” 为发送者、控件对象 “lineEdit_1” 为接收者的信号/槽连接。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>此时控件对象 “pushButton_1” 和 “lineEdit_1” 都变为浅红色，带箭头的红线从 “pushButton_1” 出发，指向 “lineEdit_1” 结束。</p></li></ul> 
 <p style="text-align:left;">（3）同时弹出对话框 “配置连接 - QtDesigner”，对话框的左侧显示发送者控件的信号选项，对话框的右侧显示接收者的控件选项。</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p> 根据功能要求，触发信号为按钮 “pushButton_1” 被点击，从对话框左侧选中 “clicked()”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>根据功能要求，收到信号后动作是清空文本编辑控件 “lineEdit_1”，从对话框右侧选中 “clear()”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击对话框下方的按钮 “OK”，完成该信号/槽连接的配置。</p></li></ul> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:78.78378%;height:0;"> 
    <img src="https://images2.imgbox.com/4d/05/WfVEKqhY_o.png" style="margin-left:;display:block;width:740px;margin-top:-78.78378%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:right;"></p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.2 信号与槽的连接：不同的发送者与接收者，槽函数为自定义函数</span></h4> 
 <p style="text-align:left;">本例介绍不同的发送者与接收者，槽函数为自定义函数的操作方法。</p> 
 <p style="text-align:left;">在 2.1 中介绍了使用控件内置的方法作为槽函数，可以直接调用，不需要对函数进行定义。程序设计中的核心功能通常是程序员根据需求开发的自定义函数。使用自定义函数作为槽函数，一方面当然是要编写自定义函数，另一方面要将自定义函数添加到槽函数配置连接表中。</p> 
 <p style="text-align:left;">我们所设计的功能是：</p> 
 <p style="text-align:left;">当点击按钮控件 “pushButton_2” 时，清空文本编辑控件 “lineEdit_2” 的显示内容，并显示文本信息 “current signal: click pushButton_2”。</p> 
 <p style="text-align:left;">在主程序中要编写一个自定义函数实现该功能，将该自定义函数命名为 click_pushButton_2()。</p> 
 <p style="text-align:left;">注意我们编写的自定义函数 click_pushButton_2()，虽然功能只是对文本编辑控件 “lineEdit_2” 进行操作，但对于自定义函数也可以完成任意的其它功能，对其它控件按照控件名称进行操作。因此该槽函数的接收者并不是文本编辑控件 “lineEdit_2”，而是主窗口控件 “MainWindow”。</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">QtDesigner 设置信号/槽的连接的操作步骤如下：</span></h5> 
 <p style="text-align:left;">首先要在 QtDesigner 将自定义函数添加到槽函数配置连接表中——非常重要。</p> 
 <p style="text-align:left;">网上的很多文章都没有讲具体实现方法，这个操作的入口也很难找到。</p> 
 <p style="text-align:left;">（1）在 QtDesigner 右侧上方的 “对象查看器”，选中 MainWindow 或其它顶层对象，单击鼠标右键唤出下拉菜单，选择 “改变信号/槽”；</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p> 弹出 “MainWindow 的信号/槽” 对话框，对话框的上方显示槽的选项，下方显示信号选项。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击对话框上方 “槽” 选项框下部的绿色 “+”，系统在 “槽” 选项表的最后自动增加了一行 “slot1()”。这就是新增的自定义槽函数。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击选中 “slot1()”，再鼠标双击，就可以修改槽函数的函数名，例如修改为 click_pushButton_2()。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>再点击对话框上方 “槽” 选项框下部的绿色 “+”，可以继续逐一添加自定义的槽函数。</p></li></ul> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:599px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:78.46411%;height:0;"> 
    <img src="https://images2.imgbox.com/f2/33/nJTCFM5E_o.jpg" style="margin-left:;display:block;width:599px;margin-top:-78.46411%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:left;">然后设置信号/槽的连接：</p> 
 <p style="text-align:left;">（2）选择菜单项 “Edit” -&gt; 编辑信号/槽，或者通过快捷键 F4 或在工具栏选择，进入信号/槽编辑模式。</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p> 选中控件对象发送者，此处为按钮控件 “pushButton_2”，长按鼠标左键并移动，当鼠标移出控件对象区域后，出现一条带箭头的红线和一个红色的接地符号。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>松开鼠标左键，就建立了以控件对象 “pushButton_2” 为发送者、控件对象 “MainWindow” 为接收者的信号/槽连接。此时控件对象 “pushButton_2” 变为浅红色，带箭头的红线从 “pushButton_2” 出发，并不指向其它控件，而是以一个接地符号结束。</p></li></ul> 
 <p style="text-align:left;">（3）同时弹出对话框 “配置连接 - QtDesigner”，对话框的左侧显示发送者控件 “pushButton_2” 的信号选项，对话框的右侧显示接收者 “MainWindow” 的控件选项。</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>根据功能要求，触发信号为按钮 “pushButton_2” 被点击，从对话框左侧选中 “clicked()”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>对话框右侧接收者 “MainWindow” 的控件选项列表中，显示了刚才添加的几个自定义函数，选择 “click_pushButton_2()”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击对话框下方的按钮 “OK”，完成该信号/槽连接的配置。</p></li></ul> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:600px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:78.833336%;height:0;"> 
    <img src="https://images2.imgbox.com/95/a4/7S6OVl8Z_o.jpg" style="margin-left:;display:block;width:600px;margin-top:-78.833336%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="text-align:left;">最后，别忘了要在主程序中编写自定义的函数。但这已不属于 QtDesigner 设计的内容了，在此不再详述。</p> 
 <p style="text-align:left;">类似地，我们设计：当点击按钮控件 “pushButton_3” 时，在文本编辑控件 "lineEdit_1"显示当前系统日期，在文本编辑控件 "lineEdit_2"显示当前系统时间，在文本编辑控件 “lineEdit_3” 显示提示信息。在主程序中编写一个自定义函数 click_pushButton_3()，并与 “pushButton_3” 建立信号/槽连接。</p> 
 <p style="text-align:left;">这表明：在自定义的子函数中，可以同时操作多个控件对象，进而可以实现用户定义的各种功能。</p> 
 <p style="text-align:right;"></p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.3 信号与槽的连接：相同的发送者与接收者，槽函数为控件的内置函数</span></h4> 
 <p style="text-align:left;">本例介绍相同的发送者与接收者，槽函数为控件的内置函数的操作方法。</p> 
 <p style="text-align:left;">顾名思义，相同的发送者与接收者，就是说信号的发送者与槽函数的接收者是同一个控件对象。这是什么情况？例如，一个开关按钮有 “On/Off” 两种状态，每按一次则按钮状态发生翻转。类似地，选项框也有选中、未选中两种状态。特殊地，点击按钮后，关闭该按钮控件，也属于相同的发送者与接收者。</p> 
 <p style="text-align:left;">我们首先将控件对象 “pushButton_4” 从按钮控件 QPushButton 改变为 选项框控件 “QCheckBox”：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击控件对象 “pushButton_4”，控件对象的周围边界显示几个蓝色小方块；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击鼠标右键唤出下拉菜单，选择：“变型为” -&gt;“QCheckBox”。</p></li></ul> 
 <p style="text-align:left;">此时，设计界面窗口中的按钮控件，变成了一个选项框。同时，右侧 “对象查看器” 中的控件 “pushButton_4”，也自动变更为 “checkBox_4”。变更的控件 “checkBox_4” 继承了原来控件 “pushButton_4” 的一些属性，如：位置、尺寸、显示内容。</p> 
 <p style="text-align:left;">接下来设置信号/槽的连接：</p> 
 <p style="text-align:left;">（1）选择菜单项 “Edit” -&gt; 编辑信号/槽，或者通过快捷键 F4 或在工具栏选择，进入信号/槽编辑模式。</p> 
 <p style="text-align:left;">（2）选中控件对象发送者，此处为按钮控件 “checkBox_4”，长按鼠标左键并移动，当鼠标移出控件对象区域后，出现一条带箭头的红线和一个红色的接地符号。</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p> 长按鼠标左键，拖动鼠标再回到控件对象 “checkBox_4” 区域后松开鼠标左键，就建立了发送者和接收者都是控件对象 “checkBox_4” 的信号/槽连接。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>此时控件对象 “checkBox_4” 变为浅红色，带箭头的红线从 “checkBox_4” 出发，又返回到 “checkBox_4” 结束。</p></li></ul> 
 <p style="text-align:left;">（3）同时弹出了对话框 “配置连接 - QtDesigner”，对话框的左侧和右侧分别是控件对象 “checkBox_4” 的信号和槽函数。</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p> 从对话框左侧选中 “clicked(bool)”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>从对话框右侧选中 “setChecked(bool)”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击对话框下方的按钮 “OK”，完成该信号/槽连接的配置。</p></li></ul> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:78.37838%;height:0;"> 
    <img src="https://images2.imgbox.com/9a/a5/AiFlxPaR_o.png" style="margin-left:;display:block;width:740px;margin-top:-78.37838%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:right;"></p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.4 信号与槽的连接：发送者是动作对象</span></h4> 
 <p style="text-align:left;">常见的信号发送者是图形窗口中的各种控件对象，但也可以是动作对象。本例介绍对菜单栏和工具栏中控件对象建立信号与槽的连接。</p> 
 <p style="text-align:left;">信号的发送者是动作对象时，信号的接收者通常是顶层对象 “MainWindow”，而槽函数可以是对象 “MainWindow” 的内置函数，也可以是自定义函数。</p> 
 <p style="text-align:left;">在上一篇文章中我们曾为菜单栏和工具栏中的动作 “actionQuit” 建立信号/槽连接，就是发送者是动作对象、连接到对象 “MainWindow” 的内置函数的案例。其操作过程如下：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>从在 QtDesigner 右侧下方窗口 “信号/槽编辑器”，点击绿色的 “+” 新建一个信号/槽连接；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “&lt;发送者&gt;”，从菜单中选择对象 “actionQuit”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “&lt;信号&gt;”，从菜单中选择 “triggered()”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “&lt;接收者&gt;”，从菜单中选择 “MainWindow”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “&lt;槽&gt;”，从菜单中选择 “closed()”。</p></li></ul> 
 <p style="text-align:left;">以上操作的作用是：发送者 对象 “actionQuit” 触发 “triggered()” 时，接收者 对象"MainWindow" 执行槽函数 “closed()”。</p> 
 <p style="text-align:left;">下面我们再为另一个动作 “actionHelp” 建立信号/槽连接，连接的槽函数为自定义函数 trigger_actHelp()。其操作过程如下：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>在 QtDesigner 将自定义函数 trigger_actHelp() 添加到槽函数配置连接表中；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>从在 QtDesigner 右侧下方窗口 “信号/槽编辑器”，点击绿色的 “+” 新建一个信号/槽连接；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “&lt;发送者&gt;”，从菜单中选择对象 “actionHelp”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “&lt;信号&gt;”，从菜单中选择 “triggered()”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “&lt;接收者&gt;”，从菜单中选择 “MainWindow”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “&lt;槽&gt;”，从菜单中选择 “trigger_actHelp()”。</p></li></ul> 
 <p style="text-align:left;">至此，本章介绍了用 QtDesigner 进行几种常见的信号/槽连接的编辑和设置方法。如下图所示，在 QtDesigner 中所添加的信号/槽连接都会在信号/槽编辑器窗口内显示。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:78.37838%;height:0;"> 
    <img src="https://images2.imgbox.com/de/63/krihfgqw_o.png" style="margin-left:;display:block;width:740px;margin-top:-78.37838%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:right;"></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3. 图形界面的主程序</span></h3> 
 <p style="text-align:left;">上节在 QtDesigner 中完成了图形界面的设计，将该文件另存为 uiDemo4.ui。打开 PyCharm，选中文件 uiDemo4.ui，使用 PyUIC 可以将其转换为 uiDemo4.py。</p> 
 <p style="text-align:left;">接下来我们要编写图形界面的主程序，调用图形界面设计文件 uiDemo4.py。</p> 
 <p style="text-align:right;"></p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.1 从面向过程到面向对象</span></h4> 
 <p style="text-align:right;"></p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">面向过程的程序设计</span></h5> 
 <p style="text-align:left;">在上一篇文章中，我们在主程序中创建主窗口后，直接调用 UI 中的 Ui_MainWindow()。这是面向过程的程序设计方法。</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:top;height:52px;"><p style="text-align:null;">1</p><p style="text-align:null;">2</p><p style="text-align:null;">3</p><p style="text-align:null;">4</p><p style="text-align:null;">5</p><p style="text-align:null;">6</p><p style="text-align:null;">7</p><p style="text-align:null;">8</p><p style="text-align:null;">9</p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:top;height:52px;"><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"># GUIdemo3.py</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;">importuiDemo3 # 导入图像界面设计文件</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;">if__name__ =='__main__':</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> app =QApplication(sys.argv) # 创建应用程序对象</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> MainWindow =QMainWindow() # 创建主窗口</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> ui =uiDemo3.Ui_MainWindow()</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> ui.setupUi(MainWindow)</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> MainWindow.show() # 显示主窗口</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> sys.exit(app.exec_()) # 在主线程中退出</span></p></td></tr></tbody></table> 
 </div> 
 <p style="text-align:right;"></p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">面向对象的程序设计</span></h5> 
 <p style="text-align:left;">随着项目的不断深入，需要处理更加丰富的图形界面和实现更加复杂的软件功能，程序的规模越来越大，程序的结构越来越复杂。</p> 
 <p style="text-align:left;">面向对象的程序设计使程序的结构更加清晰，从而易于阅读、理解、开发和维护，非常适合开发大规模、多任务的图形界面应用软件。PyQt5 中的类、对象、控件和方法，都是面向对象的程序设计的概念。因此，从本文开始我们采用面向对象的程序设计方法，来编写图形界面的主程序。</p> 
 <p style="text-align:left;">例程 GUIdemo4.py 如下：</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:top;height:52px;"><p style="text-align:null;">1</p><p style="text-align:null;">2</p><p style="text-align:null;">3</p><p style="text-align:null;">4</p><p style="text-align:null;">5</p><p style="text-align:null;">6</p><p style="text-align:null;">7</p><p style="text-align:null;">8</p><p style="text-align:null;">9</p><p style="text-align:null;">10</p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:top;height:52px;"><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;">fromuiDemo4 importUi_MainWindow # 导入 uiDemo4.py 中的 Ui_MainWindow 界面类</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;">classMyMainWindow(QMainWindow, Ui_MainWindow): # 继承 QMainWindow类和 Ui_MainWindow界面类</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> def__init__(self, parent=None):</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> super(MyMainWindow, self).__init__(parent) # 初始化父类</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> self.setupUi(self) # 继承 Ui_MainWindow 界面类 </span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;">if__name__ =='__main__':</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> app =QApplication(sys.argv) # 在 QApplication 方法中使用，创建应用程序对象</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> myWin =MyMainWindow() # 实例化 MyMainWindow 类，创建主窗口</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> myWin.show() # 在桌面显示控件 myWin</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> sys.exit(app.exec_()) # 结束进程，退出程序</span></p></td></tr></tbody></table> 
 </div> 
 <p style="text-align:left;">在上面这个例程中，我们创建了一个类 MyMainWindow()，它继承了 QtWidgets.QMainWindow 类方法和导入的 uiDemo4.py 中的 Ui_MainWindow 界面类。</p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">super(MyMainWindow, self).init()</span>：初始化父类，把 MyMainWindow 的对象 self 转成父类 QMainWindow 对象，并调用 init 函数。</p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">self.setupUi(self)</span>：继承 uiDemo4.py 中的 Ui_MainWindow 界面类，调用 Ui_MainWindow 类的setupUi() 方法。</p> 
 <p style="text-align:left;">不熟悉面向对象程序设计的小白，如果看不懂这段程序也没有关系，保存下来照猫画虎就可以了。</p> 
 <p style="text-align:right;"></p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.2 自定义槽函数</span></h4> 
 <p style="text-align:left;">运行例程 GUIdemo4.py。咦，报错了：</p> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   AttributeError: ‘MyMainWindow' object has no attribute ‘click_pushButton_2' 
 </blockquote> 
 <p style="text-align:left;">系统提示找不到 ‘click_pushButton_2'，这是因为在主程序中还没有编写 2.2 中自定义的槽函数。</p> 
 <p style="text-align:left;">将自定义的槽函数 click_pushButton_2()、click_pushButton_3、trigger_actHelp(self) 添加到主程序中。下面给出例程 GUIdemo4.py 完整的代码。</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:top;height:52px;"><p style="text-align:null;">1</p><p style="text-align:null;">2</p><p style="text-align:null;">3</p><p style="text-align:null;">4</p><p style="text-align:null;">5</p><p style="text-align:null;">6</p><p style="text-align:null;">7</p><p style="text-align:null;">8</p><p style="text-align:null;">9</p><p style="text-align:null;">10</p><p style="text-align:null;">11</p><p style="text-align:null;">12</p><p style="text-align:null;">13</p><p style="text-align:null;">14</p><p style="text-align:null;">15</p><p style="text-align:null;">16</p><p style="text-align:null;">17</p><p style="text-align:null;">18</p><p style="text-align:null;">19</p><p style="text-align:null;">20</p><p style="text-align:null;">21</p><p style="text-align:null;">22</p><p style="text-align:null;">23</p><p style="text-align:null;">24</p><p style="text-align:null;">25</p><p style="text-align:null;">26</p><p style="text-align:null;">27</p><p style="text-align:null;">28</p><p style="text-align:null;">29</p><p style="text-align:null;">30</p><p style="text-align:null;">31</p><p style="text-align:null;">32</p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:top;height:52px;"><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"># GUIdemo4.py</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"># Demo4 of GUI by PyQt5</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"># Copyright 2021 youcans, XUPT</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"># Crated：2021-10-10</span></p><p style="text-align:null;"> </p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;">importsys</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;">fromPyQt5.QtWidgets importQApplication, QMainWindow, QMessageBox</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;">fromuiDemo4 importUi_MainWindow # 导入 uiDemo4.py 中的 Ui_MainWindow 界面类</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;">classMyMainWindow(QMainWindow, Ui_MainWindow): # 继承 QMainWindow类和 Ui_MainWindow界面类</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> def__init__(self, parent=None):</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> super(MyMainWindow, self).__init__(parent) # 初始化父类</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> self.setupUi(self) # 继承 Ui_MainWindow 界面类</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> defclick_pushButton_2(self): # 点击 pushButton_2 触发</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> self.lineEdit_2.setText("click_pushButton_2")</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> return</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> defclick_pushButton_3(self): # 点击 pushButton_3 触发</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> fromdatetime importdatetime # 导入 datetime 库</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> nowDate =datetime.now().strftime("%Y-%m-%d") # 获取当前日期 "2021-10-10"</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> nowTime =datetime.now().strftime("%H:%M:%S") # 获取当前时间 "16:58:00"</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> self.lineEdit_1.setText("Current date: {}".format(nowDate)) # 显示日期</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> self.lineEdit_2.setText("Current time: {}".format(nowTime)) # 显示时间</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> self.lineEdit_3.setText("Demo4 of GUI by PyQt5") #</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> return</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> deftrigger_actHelp(self): # 动作 actHelp 触发</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> QMessageBox.about(self, "About",</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> """数字图像处理工具箱 v1.0\nCopyright YouCans, XUPT 2021""")</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> return</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;">if__name__ =='__main__':</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> app =QApplication(sys.argv) # 在 QApplication 方法中使用，创建应用程序对象</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> myWin =MyMainWindow() # 实例化 MyMainWindow 类，创建主窗口</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> myWin.show() # 在桌面显示控件 myWin</span></p><p style="text-align:null;"><span class="kdocs-fontSize" style="font-size:9pt;"> sys.exit(app.exec_()) # 结束进程，退出程序</span></p></td></tr></tbody></table> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:79.054054%;height:0;"> 
    <img src="https://images2.imgbox.com/28/f5/W5wai43z_o.png" style="margin-left:;display:block;width:740px;margin-top:-79.054054%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:left;">现在我们就得到了一个虽然简单但是很完整的面向对象的图形界面应用程序 GUIdemo4。</p> 
 <p style="text-align:left;">检查一下应用程序 GUIdemo4 的各项功能：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “1# 按钮”，清空 “文本编辑行-1”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “2# 按钮”，在 “文本编辑行-2” 显示：“click_pushButton_2”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “3# 按钮”，在 “文本编辑行-1” 显示当前日期，在 “文本编辑行-2” 显示当前时间，在 “文本编辑行-3” 显示： “Demo4 of GUI by PyQt5”；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击 “4# 按钮”， “4# 按钮” 的选项框被选中；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击工具栏中的 “帮助”，弹出上图中的信息提示框，点击 “OK” 可以关闭信息框；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;text-align:left;"><p>点击菜单栏或工具栏中的 “退出”，关闭图形窗口应用程序。</p></li></ul> 
 <p style="text-align:left;">如果以上测试都成功了，那么恭喜小白同学，你已经掌握了用 QtDesigner 设计 PyQt5 图形界面的基本功能。</p> 
 <p style="text-align:left;">在下一篇文章中，我们将介绍 PyQt5 中的常用控件。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10777121b94e41970991bf423a24effd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习笔记之生成模型综述(二)监督学习与无监督学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9bd1ba132b5af38fbacfe9b7cb293a29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32CubeMX配置HAL库实现SPI-DMA的递归调用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>