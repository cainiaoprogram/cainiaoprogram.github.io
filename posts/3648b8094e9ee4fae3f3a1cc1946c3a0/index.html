<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenCV Camera Calibration 示例使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenCV Camera Calibration 示例使用" />
<meta property="og:description" content="本文主要介绍OpenCV自带标定例子的使用方法。
OpenCV包含标定文件：calibration.cpp：是通过用户输入可选参数进行相机标定的程序；
（1）新建项目 test_Calibration
File-&gt;New -&gt; Project,点击ok，next，选择Empty project，点击finish。
（2）添加源文件 将OpenCV安装目录下的OpenCV\opencv\sources\samples\cpp文件夹中的calibration.cpp文件复制到港创建的工程目录下....\Test_Calibration\test_Calibration\test_Calibration文件夹下。作者为了区分两者，所以将其重命名为TestCalibration.cpp
在VS中右击工程名，右键点击工程中的Source Files-&gt;Add -&gt;Existing Item ,选择刚复制的TestCalibration.cpp文件。
（3）运行
点击Debug-&gt;Start Without Debugging，运行。生成test_Calibration.exe，在。。。Test_Calibration\test_Calibration\x64\Debug文件夹下。
（4）标定
打开所有程序中的“运行”，或直接按键Win&#43;R，打开“运行”，输入“cmd”回车，打开命令行窗口
输入文件地址，如作者的地址输入 “E：”回车-&gt;cd paper_and_code\code20180507\C&#43;&#43;\Test_Calibration\test_Calibration\x64\Debug 进入文件夹。
输入命令：“test_Calibration.exe -w=8 -h=6”回车
程序开始运行。
并生成out_camera_data.yml文件
利用事先拍好的图片标定的方法在下一篇会讲到
OpenCV Camera Calibration 示例使用（二） - CSDN博客
https://blog.csdn.net/panpan_jiang1/article/details/80429937
TestCalibration.cpp的代码如下
#include &#34;opencv2/core.hpp&#34;
#include &lt;opencv2/core/utility.hpp&gt;
#include &#34;opencv2/imgproc.hpp&#34;
#include &#34;opencv2/calib3d.hpp&#34;
#include &#34;opencv2/imgcodecs.hpp&#34;
#include &#34;opencv2/videoio.hpp&#34;
#include &#34;opencv2/highgui.hpp&#34;
#include &lt;cctype&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
using namespace cv;
using namespace std;
const char * usage =" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3648b8094e9ee4fae3f3a1cc1946c3a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-22T12:30:18+08:00" />
<meta property="article:modified_time" content="2018-05-22T12:30:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenCV Camera Calibration 示例使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-top:20px;margin-bottom:20px;color:rgb(51,51,51);font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);">本文主要介绍OpenCV自带标定例子的使用方法。</p> 
<p style="margin-top:20px;margin-bottom:20px;color:rgb(51,51,51);font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);">OpenCV包含标定文件：calibration.cpp：是通过用户输入可选参数进行相机标定的程序；</p> 
<p style="margin-top:20px;margin-bottom:20px;color:rgb(51,51,51);font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);">（1）新建项目 test_Calibration</p> 
<p style="margin-top:20px;margin-bottom:20px;color:rgb(51,51,51);font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);">File-&gt;New -&gt; Project,点击ok，next，选择Empty project，点击finish。</p> 
<p style="margin-top:20px;margin-bottom:20px;color:rgb(51,51,51);font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);"></p> 
<div> 
 <img src="https://images2.imgbox.com/a1/44/JN5Eqwdp_o.png" alt=""> 
 <br> 
</div> 
<div>
  （2）添加源文件 
</div> 
<p>将OpenCV安装目录下的OpenCV\opencv\sources\samples\cpp文件夹中的calibration.cpp文件复制到港创建的工程目录下....\Test_Calibration\test_Calibration\test_Calibration文件夹下。作者为了区分两者，所以将其重命名为TestCalibration.cpp</p> 
<p>在VS中右击工程名，右键点击工程中的Source Files-&gt;Add -&gt;Existing Item ,选择刚复制的<span style="font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);">TestCalibration.cpp文件。</span></p> 
<p><span style="font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);">（3）运行</span></p> 
<p><span style="font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);">点击Debug-&gt;Start Without Debugging，运行。生成test_Calibration.exe，在。。。Test_Calibration\test_Calibration\x64\Debug文件夹下。</span></p> 
<p>（4）标定</p> 
<p>打开所有程序中的“运行”，或直接按键Win+R，打开“运行”，输入“cmd”回车，打开命令行窗口<img src="https://images2.imgbox.com/32/66/d7XiRWm3_o.png" alt=""></p> 
<p>输入文件地址，如作者的地址输入 “<span style="font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);">E：</span>”回车-&gt;cd paper_and_code\code20180507\C++\Test_Calibration\test_Calibration\x64\Debug 进入文件夹。</p> 
<p>输入命令：“<span style="color:rgb(51,51,51);font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);"><span style="font-family:'Microsoft Yahei', '微软雅黑', arial, '宋体', sans-serif;background-color:rgb(255,255,255);">test_Calibration.</span>exe -w=8 -h=6</span>”回车</p> 
<p>程序开始运行。</p> 
<p><img src="https://images2.imgbox.com/0a/9c/cFIrOO3F_o.png" alt=""><br></p> 
<p>并生成out_camera_data.yml文件</p> 
<p><br></p> 
<p>利用事先拍好的图片标定的方法在下一篇会讲到</p> 
<p>OpenCV Camera Calibration 示例使用（二） - CSDN博客<br> <a href="https://blog.csdn.net/panpan_jiang1/article/details/80429937">https://blog.csdn.net/panpan_jiang1/article/details/80429937</a><br></p> 
<p><br></p> 
<p><br></p> 
<p>TestCalibration.cpp的代码如下<br></p> 
<p>#include "opencv2/core.hpp"<br>#include &lt;opencv2/core/utility.hpp&gt;<br>#include "opencv2/imgproc.hpp"<br>#include "opencv2/calib3d.hpp"<br>#include "opencv2/imgcodecs.hpp"<br>#include "opencv2/videoio.hpp"<br>#include "opencv2/highgui.hpp"<br><br><br>#include &lt;cctype&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;time.h&gt;<br><br><br>using namespace cv;<br>using namespace std;<br><br><br>const char * usage =<br>" \nexample command line for calibration from a live feed.\n"<br>"   calibration  -w=4 -h=5 -s=0.025 -o=camera.yml -op -oe\n"<br>" \n"<br>" example command line for calibration from a list of stored images:\n"<br>"   imagelist_creator image_list.xml *.png\n"<br>"   calibration -w=4 -h=5 -s=0.025 -o=camera.yml -op -oe image_list.xml\n"<br>" where image_list.xml is the standard OpenCV XML/YAML\n"<br>" use imagelist_creator to create the xml or yaml list\n"<br>" file consisting of the list of strings, e.g.:\n"<br>" \n"<br>"&lt;?xml version=\"1.0\"?&gt;\n"<br>"&lt;opencv_storage&gt;\n"<br>"&lt;images&gt;\n"<br>"view000.png\n"<br>"view001.png\n"<br>"&lt;!-- view002.png --&gt;\n"<br>"view003.png\n"<br>"view010.png\n"<br>"one_extra_view.jpg\n"<br>"&lt;/images&gt;\n"<br>"&lt;/opencv_storage&gt;\n";<br><br>const char* liveCaptureHelp =<br>    "When the live video from camera is used as input, the following hot-keys may be used:\n"<br>        "  &lt;ESC&gt;, 'q' - quit the program\n"<br>        "  'g' - start capturing images\n"<br>        "  'u' - switch undistortion on/off\n";<br><br><br>static void help()<br>{<!-- --><br>    printf( "This is a camera calibration sample.\n"<br>        "Usage: calibration\n"<br>        "     -w=&lt;board_width&gt;         # the number of inner corners per one of board dimension\n"<br>        "     -h=&lt;board_height&gt;        # the number of inner corners per another board dimension\n"<br>        "     [-pt=&lt;pattern&gt;]          # the type of pattern: chessboard or circles' grid\n"<br>        "     [-n=&lt;number_of_frames&gt;]  # the number of frames to use for calibration\n"<br>        "                              # (if not specified, it will be set to the number\n"<br>        "                              #  of board views actually available)\n"<br>        "     [-d=&lt;delay&gt;]             # a minimum delay in ms between subsequent attempts to capture a next view\n"<br>        "                              # (used only for video capturing)\n"<br>        "     [-s=&lt;squareSize&gt;]       # square size in some user-defined units (1 by default)\n"<br>        "     [-o=&lt;out_camera_params&gt;] # the output filename for intrinsic [and extrinsic] parameters\n"<br>        "     [-op]                    # write detected feature points\n"<br>        "     [-oe]                    # write extrinsic parameters\n"<br>        "     [-zt]                    # assume zero tangential distortion\n"<br>        "     [-a=&lt;aspectRatio&gt;]      # fix aspect ratio (fx/fy)\n"<br>        "     [-p]                     # fix the principal point at the center\n"<br>        "     [-v]                     # flip the captured images around the horizontal axis\n"<br>        "     [-V]                     # use a video file, and not an image list, uses\n"<br>        "                              # [input_data] string for the video file name\n"<br>        "     [-su]                    # show undistorted images after calibration\n"<br>        "     [input_data]             # input data, one of the following:\n"<br>        "                              #  - text file with a list of the images of the board\n"<br>        "                              #    the text file can be generated with imagelist_creator\n"<br>        "                              #  - name of video file with a video of the board\n"<br>        "                              # if input_data not specified, a live view from the camera is used\n"<br>        "\n" );<br>    printf("\n%s",usage);<br>    printf( "\n%s", liveCaptureHelp );<br>}<br><br><br>enum { DETECTION = 0, CAPTURING = 1, CALIBRATED = 2 };<br>enum Pattern { CHESSBOARD, CIRCLES_GRID, ASYMMETRIC_CIRCLES_GRID };<br><br><br>//计算重投影误差  返回标准差<br>static double computeReprojectionErrors(<br>        const vector&lt;vector&lt;Point3f&gt; &gt;&amp; objectPoints,<br>        const vector&lt;vector&lt;Point2f&gt; &gt;&amp; imagePoints,<br>        const vector&lt;Mat&gt;&amp; rvecs, const vector&lt;Mat&gt;&amp; tvecs,<br>        const Mat&amp; cameraMatrix, const Mat&amp; distCoeffs,<br>        vector&lt;float&gt;&amp; perViewErrors )<br>{<!-- --><br>    vector&lt;Point2f&gt; imagePoints2;<br>    int i, totalPoints = 0;<br>    double totalErr = 0, err;<br>    perViewErrors.resize(objectPoints.size());<br><br><br>    for( i = 0; i &lt; (int)objectPoints.size(); i++ )<br>    {<!-- --><br>        projectPoints(Mat(objectPoints[i]), rvecs[i], tvecs[i],<br>                      cameraMatrix, distCoeffs, imagePoints2);//根据给定的固有和外部参数，计算3D点对图像平面的投影<br>        err = norm(Mat(imagePoints[i]), Mat(imagePoints2), NORM_L2);<br>        int n = (int)objectPoints[i].size();<br>        perViewErrors[i] = (float)std::sqrt(err*err/n);<br>        totalErr += err*err;<br>        totalPoints += n;<br>    }<br><br><br>    return std::sqrt(totalErr/totalPoints);<br>}<br><br><br>//计算棋盘标定板的角点<br>static void calcChessboardCorners(Size boardSize, float squareSize, vector&lt;Point3f&gt;&amp; corners, Pattern patternType = CHESSBOARD)<br>{<!-- --><br>    corners.resize(0);<br><br><br>    switch(patternType)<br>    {<!-- --><br>      case CHESSBOARD://棋盘格<br>      case CIRCLES_GRID://圆形网格<br>        for( int i = 0; i &lt; boardSize.height; i++ )<br>            for( int j = 0; j &lt; boardSize.width; j++ )<br>                corners.push_back(Point3f(float(j*squareSize),<br>                                          float(i*squareSize), 0));//遍历棋盘格的角点，三维坐标，写入corners。   每一个角点的行列数乘以每个网格里的像素数等于角点的像素坐标？？？？？<br>        break;<br><br><br>      case ASYMMETRIC_CIRCLES_GRID://非对称圆形网格<br>        for( int i = 0; i &lt; boardSize.height; i++ )<br>            for( int j = 0; j &lt; boardSize.width; j++ )<br>                corners.push_back(Point3f(float((2*j + i % 2)*squareSize),<br>                                          float(i*squareSize), 0));//float()强制类型转换<br>        break;<br><br><br>      default:<br>        CV_Error(Error::StsBadArg, "Unknown pattern type\n");<br>    }<br>}<br><br><br><br>static bool runCalibration( vector&lt;vector&lt;Point2f&gt; &gt; imagePoints,<br>                    Size imageSize, Size boardSize, Pattern patternType,<br>                    float squareSize, float aspectRatio,<br>                    int flags, Mat&amp; cameraMatrix, Mat&amp; distCoeffs,<br>                    vector&lt;Mat&gt;&amp; rvecs, vector&lt;Mat&gt;&amp; tvecs,<br>                    vector&lt;float&gt;&amp; reprojErrs,<br>                    double&amp; totalAvgErr)<br>{<!-- --><br>    cameraMatrix = Mat::eye(3, 3, CV_64F);//CV_64F 64-bit floating-point numbers 对角矩阵<br>    if( flags &amp; CALIB_FIX_ASPECT_RATIO )<br>        cameraMatrix.at&lt;double&gt;(0,0) = aspectRatio;//第1行，第1列的元素，纵横比<br><br><br>    distCoeffs = Mat::zeros(8, 1, CV_64F);//全零矩阵<br><br><br>    vector&lt;vector&lt;Point3f&gt; &gt; objectPoints(1);//point3f类型的二维数组<br>    calcChessboardCorners(boardSize, squareSize, objectPoints[0], patternType);<br><br><br>    objectPoints.resize(imagePoints.size(),objectPoints[0]);<br><br><br>    double rms = calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix,<br>                    distCoeffs, rvecs, tvecs, flags|CALIB_FIX_K4|CALIB_FIX_K5);//estimates the intrinsic camera parameters and extrinsic parameters for each of the views.<br>                    ///*|CALIB_FIX_K3*/|CALIB_FIX_K4|CALIB_FIX_K5);<br>    printf("RMS error reported by calibrateCamera: %g\n", rms);<br><br><br>    bool ok = checkRange(cameraMatrix) &amp;&amp; checkRange(distCoeffs);//checkRange<span style="white-space:pre;"> </span>检查矩阵的每个元素的取值是否在最小值与最大值之间，返回验证结果bool<br><br><br>    totalAvgErr = computeReprojectionErrors(objectPoints, imagePoints,<br>                rvecs, tvecs, cameraMatrix, distCoeffs, reprojErrs);<br><br><br>    return ok;<br>}<br><br><br>static void saveCameraParams( const string&amp; filename,<br>                       Size imageSize, Size boardSize,<br>                       float squareSize, float aspectRatio, int flags,<br>                       const Mat&amp; cameraMatrix, const Mat&amp; distCoeffs,<br>                       const vector&lt;Mat&gt;&amp; rvecs, const vector&lt;Mat&gt;&amp; tvecs,<br>                       const vector&lt;float&gt;&amp; reprojErrs,<br>                       const vector&lt;vector&lt;Point2f&gt; &gt;&amp; imagePoints,<br>                       double totalAvgErr )<br>{<!-- --><br>    FileStorage fs( filename, FileStorage::WRITE );<br><br><br>    time_t tt;<br>    time( &amp;tt );<br>    struct tm *t2 = localtime( &amp;tt );<br>    char buf[1024];<br>    strftime( buf, sizeof(buf)-1, "%c", t2 );<br><br><br>    fs &lt;&lt; "calibration_time" &lt;&lt; buf;<br><br><br>    if( !rvecs.empty() || !reprojErrs.empty() )<br>        fs &lt;&lt; "nframes" &lt;&lt; (int)std::max(rvecs.size(), reprojErrs.size());<br>    fs &lt;&lt; "image_width" &lt;&lt; imageSize.width;<br>    fs &lt;&lt; "image_height" &lt;&lt; imageSize.height;<br>    fs &lt;&lt; "board_width" &lt;&lt; boardSize.width;<br>    fs &lt;&lt; "board_height" &lt;&lt; boardSize.height;<br>    fs &lt;&lt; "square_size" &lt;&lt; squareSize;<br><br><br>    if( flags &amp; CALIB_FIX_ASPECT_RATIO )<br>        fs &lt;&lt; "aspectRatio" &lt;&lt; aspectRatio;<br><br><br>    if( flags != 0 )<br>    {<!-- --><br>        sprintf( buf, "flags: %s%s%s%s",<br>            flags &amp; CALIB_USE_INTRINSIC_GUESS ? "+use_intrinsic_guess" : "",<br>            flags &amp; CALIB_FIX_ASPECT_RATIO ? "+fix_aspectRatio" : "",<br>            flags &amp; CALIB_FIX_PRINCIPAL_POINT ? "+fix_principal_point" : "",<br>            flags &amp; CALIB_ZERO_TANGENT_DIST ? "+zero_tangent_dist" : "" );<br>        //cvWriteComment( *fs, buf, 0 );<br>    }<br><br><br>    fs &lt;&lt; "flags" &lt;&lt; flags;<br><br><br>    fs &lt;&lt; "camera_matrix" &lt;&lt; cameraMatrix;<br>    fs &lt;&lt; "distortion_coefficients" &lt;&lt; distCoeffs;<br><br><br>    fs &lt;&lt; "avg_reprojection_error" &lt;&lt; totalAvgErr;<br>    if( !reprojErrs.empty() )<br>        fs &lt;&lt; "per_view_reprojection_errors" &lt;&lt; Mat(reprojErrs);<br><br><br>    if( !rvecs.empty() &amp;&amp; !tvecs.empty() )<br>    {<!-- --><br>        CV_Assert(rvecs[0].type() == tvecs[0].type());<br>        Mat bigmat((int)rvecs.size(), 6, rvecs[0].type());<br>        for( int i = 0; i &lt; (int)rvecs.size(); i++ )<br>        {<!-- --><br>            Mat r = bigmat(Range(i, i+1), Range(0,3));<br>            Mat t = bigmat(Range(i, i+1), Range(3,6));<br><br><br>            CV_Assert(rvecs[i].rows == 3 &amp;&amp; rvecs[i].cols == 1);<br>            CV_Assert(tvecs[i].rows == 3 &amp;&amp; tvecs[i].cols == 1);<br>            //*.t() is MatExpr (not Mat) so we can use assignment operator<br>            r = rvecs[i].t();<br>            t = tvecs[i].t();<br>        }<br>        //cvWriteComment( *fs, "a set of 6-tuples (rotation vector + translation vector) for each view", 0 );<br>        fs &lt;&lt; "extrinsic_parameters" &lt;&lt; bigmat;<br>    }<br><br><br>    if( !imagePoints.empty() )<br>    {<!-- --><br>        Mat imagePtMat((int)imagePoints.size(), (int)imagePoints[0].size(), CV_32FC2);<br>        for( int i = 0; i &lt; (int)imagePoints.size(); i++ )<br>        {<!-- --><br>            Mat r = imagePtMat.row(i).reshape(2, imagePtMat.cols);<br>            Mat imgpti(imagePoints[i]);<br>            imgpti.copyTo(r);<br>        }<br>        fs &lt;&lt; "image_points" &lt;&lt; imagePtMat;<br>    }<br>}<br><br><br>static bool readStringList( const string&amp; filename, vector&lt;string&gt;&amp; l )<br>{<!-- --><br>    l.resize(0);<br>    FileStorage fs(filename, FileStorage::READ);<br>    if( !fs.isOpened() )<br>        return false;<br>    FileNode n = fs.getFirstTopLevelNode();<br>    if( n.type() != FileNode::SEQ )<br>        return false;<br>    FileNodeIterator it = n.begin(), it_end = n.end();<br>    for( ; it != it_end; ++it )<br>        l.push_back((string)*it);<br>    return true;<br>}<br><br><br>static bool runAndSave(const string&amp; outputFilename,<br>                const vector&lt;vector&lt;Point2f&gt; &gt;&amp; imagePoints,<br>                Size imageSize, Size boardSize, Pattern patternType, float squareSize,<br>                float aspectRatio, int flags, Mat&amp; cameraMatrix,<br>                Mat&amp; distCoeffs, bool writeExtrinsics, bool writePoints )<br>{<!-- --><br>    vector&lt;Mat&gt; rvecs, tvecs;<br>    vector&lt;float&gt; reprojErrs;<br>    double totalAvgErr = 0;<br><br><br>    bool ok = runCalibration(imagePoints, imageSize, boardSize, patternType, squareSize,<br>                   aspectRatio, flags, cameraMatrix, distCoeffs,<br>                   rvecs, tvecs, reprojErrs, totalAvgErr);<br>    printf("%s. avg reprojection error = %.2f\n",<br>           ok ? "Calibration succeeded" : "Calibration failed",<br>           totalAvgErr);<br><br><br>    if( ok )<br>        saveCameraParams( outputFilename, imageSize,<br>                         boardSize, squareSize, aspectRatio,<br>                         flags, cameraMatrix, distCoeffs,<br>                         writeExtrinsics ? rvecs : vector&lt;Mat&gt;(),<br>                         writeExtrinsics ? tvecs : vector&lt;Mat&gt;(),<br>                         writeExtrinsics ? reprojErrs : vector&lt;float&gt;(),<br>                         writePoints ? imagePoints : vector&lt;vector&lt;Point2f&gt; &gt;(),<br>                         totalAvgErr );<br>    return ok;<br>}<br><br><br>int main( int argc, char** argv )<br>{<!-- --><br>    Size boardSize, imageSize;//boardSize棋盘格内部角点的行列数 imageSize未畸变的图片尺寸<br>    float squareSize, aspectRatio; // The size of a square in your defined unit (point, millimeter,etc).       The aspect ratio<br>    Mat cameraMatrix, distCoeffs;//cameraMatrix 相机内参矩阵A   distCoeffs相机的畸变系数(k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τx,τy]]]])(k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τx,τy]]]])<br>    string outputFilename; The name of the file where to write <br>    string inputFilename = "";<br><br><br>    int i, nframes; //The number of frames to use from the input for calibration<br>    bool writeExtrinsics, writePoints; // Write extrinsic parameters       Write detected feature points <br>    bool undistortImage = false;//<br>    int flags = 0;<br>    VideoCapture capture;//捕获摄像机传来的视频<br>    bool flipVertical;<br>    bool showUndistorted;<br>    bool videofile;<br>    int delay;   // In case of a video input  <br>    clock_t prevTimestamp = 0;<br>    int mode = DETECTION;<br>    int cameraId = 0;<br>    vector&lt;vector&lt;Point2f&gt; &gt; imagePoints;<br>    vector&lt;string&gt; imageList;//图像文件名称序列<br>    Pattern pattern = CHESSBOARD;//标定板的标定图案的类型// One of the Chessboard, circles, or asymmetric circle pattern<br><br><br>    cv::CommandLineParser parser(argc, argv,<br>        "{help ||}{w||}{h||}{pt|chessboard|}{n|10|}{d|1000|}{s|1|}{o|out_camera_data.yml|}"<br>        "{op||}{oe||}{zt||}{a|1|}{p||}{v||}{V||}{su||}"<br>        "{@input_data|0|}");<br>    if (parser.has("help"))<br>    {<!-- --><br>        help();<br>        return 0;<br>    }<br>    boardSize.width = parser.get&lt;int&gt;( "w" );<br>    boardSize.height = parser.get&lt;int&gt;( "h" );<br>    if ( parser.has("pt") )<br>    {<!-- --><br>        string val = parser.get&lt;string&gt;("pt");<br>        if( val == "circles" )<br>            pattern = CIRCLES_GRID;<br>        else if( val == "acircles" )<br>            pattern = ASYMMETRIC_CIRCLES_GRID;<br>        else if( val == "chessboard" )<br>            pattern = CHESSBOARD;<br>        else<br>            return fprintf( stderr, "Invalid pattern type: must be chessboard or circles\n" ), -1;<br>    }<br>    squareSize = parser.get&lt;float&gt;("s");<br>    nframes = parser.get&lt;int&gt;("n");<br>    aspectRatio = parser.get&lt;float&gt;("a");<br>    delay = parser.get&lt;int&gt;("d");<br>    writePoints = parser.has("op");<br>    writeExtrinsics = parser.has("oe");<br>    if (parser.has("a"))<br>        flags |= CALIB_FIX_ASPECT_RATIO;<br>    if ( parser.has("zt") )<br>        flags |= CALIB_ZERO_TANGENT_DIST;<br>    if ( parser.has("p") )<br>        flags |= CALIB_FIX_PRINCIPAL_POINT;<br>    flipVertical = parser.has("v");<br>    videofile = parser.has("V");<br>    if ( parser.has("o") )<br>        outputFilename = parser.get&lt;string&gt;("o");<br>    showUndistorted = parser.has("su");<br>    if ( isdigit(parser.get&lt;string&gt;("@input_data")[0]) )<br>        cameraId = parser.get&lt;int&gt;("@input_data");<br>    else<br>        inputFilename = parser.get&lt;string&gt;("@input_data");<br>    if (!parser.check())<br>    {<!-- --><br>        help();<br>        parser.printErrors();<br>        return -1;<br>    }<br>    if ( squareSize &lt;= 0 )<br>        return fprintf( stderr, "Invalid board square width\n" ), -1;<br>    if ( nframes &lt;= 3 )<br>        return printf("Invalid number of images\n" ), -1;<br>    if ( aspectRatio &lt;= 0 )<br>        return printf( "Invalid aspect ratio\n" ), -1;<br>    if ( delay &lt;= 0 )<br>        return printf( "Invalid delay\n" ), -1;<br>    if ( boardSize.width &lt;= 0 )<br>        return fprintf( stderr, "Invalid board width\n" ), -1;<br>    if ( boardSize.height &lt;= 0 )<br>        return fprintf( stderr, "Invalid board height\n" ), -1;<br><br><br><span style="white-space:pre;"> </span>//选择打开文件或是摄像头<br>    if( !inputFilename.empty() )<br>    {<!-- --><br>        if( !videofile &amp;&amp; readStringList(inputFilename, imageList) )<br>            mode = CAPTURING;<br>        else<br>            capture.open(inputFilename);<br>    }<br>    else<br>        capture.open(cameraId);<br><br><br><span style="white-space:pre;"> </span>//摄像机没打开且图像序列为空，则返回initialize video 结束程序<br>    if( !capture.isOpened() &amp;&amp; imageList.empty() )<br>        return fprintf( stderr, "Could not initialize video (%d) capture\n",cameraId ), -2;<br><br><br>    if( !imageList.empty() )<br>        nframes = (int)imageList.size();<br><br><br>    if( capture.isOpened() )<br>        printf( "%s", liveCaptureHelp );<br><br><br>    namedWindow( "Image View", 1 );<br><br><br>    for(i = 0;;i++)//无限循环至标定完且保存相机参数<br>    {<!-- --><br>        Mat view, viewGray;//view 暂时存储棋盘格图像<br>        bool blink = false;<br><br><br>        if( capture.isOpened() )<br>        {<!-- --><br>            Mat view0;<br>            capture &gt;&gt; view0;<br>            view0.copyTo(view);<br>        }<br>        else if( i &lt; (int)imageList.size() )<br>            view = imread(imageList[i], 1);<br><br><br><span style="white-space:pre;"> </span>//若存在棋盘格图像，则进行标定且保存相机参数，并结束循环<br>        if(view.empty())<br>        {<!-- --><br>            if( imagePoints.size() &gt; 0 )<br>                runAndSave(outputFilename, imagePoints, imageSize,<br>                           boardSize, pattern, squareSize, aspectRatio,<br>                           flags, cameraMatrix, distCoeffs,<br>                           writeExtrinsics, writePoints);<br>            break;<br>        }<br><br><br>        imageSize = view.size();<br><br><br>        if( flipVertical )<br>            flip( view, view, 0 );//切换所有元素<br><br><br>        vector&lt;Point2f&gt; pointbuf;//棋盘格角点二维坐标<br>        cvtColor(view, viewGray, COLOR_BGR2GRAY);<br><br><br>        bool found;<br>        switch( pattern )<br>        {<!-- --><br>            case CHESSBOARD:<br>                found = findChessboardCorners( view, boardSize, pointbuf,  //第一个参数输入棋盘格图像 第二个参数棋盘格内部角点的行列数 第三个参数输出棋盘格角点 <br>                    CALIB_CB_ADAPTIVE_THRESH | CALIB_CB_FAST_CHECK | CALIB_CB_NORMALIZE_IMAGE);//角点检测 如果找到角点则返回true  第四个参数用于指定在检测棋盘格角点的过程中所应用的一种或多种过滤方法，两个方法之间用|隔开<br>                break;<br>            case CIRCLES_GRID:<span style="white-space:pre;"> </span>//圆<br>                found = findCirclesGrid( view, boardSize, pointbuf );<br>                break;<br>            case ASYMMETRIC_CIRCLES_GRID:<span style="white-space:pre;"> </span>//非对称圆<br>                found = findCirclesGrid( view, boardSize, pointbuf, CALIB_CB_ASYMMETRIC_GRID );<br>                break;<br>            default:<br>                return fprintf( stderr, "Unknown pattern type\n" ), -1;<br>        }<br><br><br>       // improve the found corners' coordinate accuracy<br>        if( pattern == CHESSBOARD &amp;&amp; found) cornerSubPix( viewGray, pointbuf, Size(11,11),<br>            Size(-1,-1), TermCriteria( TermCriteria::EPS+TermCriteria::COUNT, 30, 0.1 ));//cornerSubPix定位之前角点的亚像素精确定位<br><br><br>        if( mode == CAPTURING &amp;&amp; found &amp;&amp;<br>           (!capture.isOpened() || clock() - prevTimestamp &gt; delay*1e-3*CLOCKS_PER_SEC) )<br>        {<!-- --><br>            imagePoints.push_back(pointbuf);<br>            prevTimestamp = clock();<br>            blink = capture.isOpened();<br>        }<br><br><br>        if(found)<br>            drawChessboardCorners( view, boardSize, Mat(pointbuf), found );<br><br><br>        string msg = mode == CAPTURING ? "100/100" :<br>            mode == CALIBRATED ? "Calibrated" : "Press 'g' to start";<br>        int baseLine = 0;<br>        Size textSize = getTextSize(msg, 1, 1, 1, &amp;baseLine);<br>        Point textOrigin(view.cols - 2*textSize.width - 10, view.rows - 2*baseLine - 10);<br><br><br>        if( mode == CAPTURING )<br>        {<!-- --><br>            if(undistortImage)<br>                msg = format( "%d/%d Undist", (int)imagePoints.size(), nframes );<br>            else<br>                msg = format( "%d/%d", (int)imagePoints.size(), nframes );<br>        }<br><br><br>        putText( view, msg, textOrigin, 1, 1,<br>                 mode != CALIBRATED ? Scalar(0,0,255) : Scalar(0,255,0));<br><br><br>        if( blink )<br>            bitwise_not(view, view);<br><br><br>        if( mode == CALIBRATED &amp;&amp; undistortImage )<br>        {<!-- --><br>            Mat temp = view.clone();<br>            undistort(temp, view, cameraMatrix, distCoeffs);<br>        }<br><br><br>        imshow("Image View", view);<br>        char key = (char)waitKey(capture.isOpened() ? 50 : 500);<br><br><br>        if( key == 27 )<br>            break;<br><br><br>        if( key == 'u' &amp;&amp; mode == CALIBRATED )<br>            undistortImage = !undistortImage;<br><br><br>        if( capture.isOpened() &amp;&amp; key == 'g' )<br>        {<!-- --><br>            mode = CAPTURING;<br>            imagePoints.clear();<br>        }<br><br><br>        if( mode == CAPTURING &amp;&amp; imagePoints.size() &gt;= (unsigned)nframes )<br>        {<!-- --><br>            if( runAndSave(outputFilename, imagePoints, imageSize,<br>                       boardSize, pattern, squareSize, aspectRatio,<br>                       flags, cameraMatrix, distCoeffs,<br>                       writeExtrinsics, writePoints))<br>                mode = CALIBRATED;<br>            else<br>                mode = DETECTION;<br>            if( !capture.isOpened() )<br>                break;<br>        }<br>    }<br><br><br>    if( !capture.isOpened() &amp;&amp; showUndistorted )<br>    {<!-- --><br>        Mat view, rview, map1, map2;<br><span style="white-space:pre;"> </span>//计算无畸变和修正转换映射 imageSize未畸变的图片尺寸  输出的映射的类型，可以为 CV_32FC1, CV_32FC2或CV_16SC2    map1：第一个输出映射  map2：第二个输出映射。<br><span style="white-space:pre;"> </span>//该函数实际上为反向映射算法构建映射，供反向映射使用。也就是，对于在已经修正畸变的图像中的每个像素(u,v)(u,v)，该函数计算原来图像（从相机中获得的原始图像）中对应的坐标系。<br>        initUndistortRectifyMap(cameraMatrix, distCoeffs, Mat(),<br>                                getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, 1, imageSize, 0),//返回基于 alpha Free scaling parameter的新相机内参矩阵，1 是 alpha Free scaling parameter，<br>                                imageSize, CV_16SC2, map1, map2);<br><br><br>        for( i = 0; i &lt; (int)imageList.size(); i++ )<br>        {<!-- --><br>            view = imread(imageList[i], 1);<br>            if(view.empty())<br>                continue;<br>            //undistort( view, rview, cameraMatrix, distCoeffs, cameraMatrix );<br>            remap(view, rview, map1, map2, INTER_LINEAR);//重映射就是把一幅图像中某位置的像素放置到另一个图片指定位置的过程。双线性插值<br>            imshow("Image View", rview);<br>            char c = (char)waitKey();<br>            if( c == 27 || c == 'q' || c == 'Q' )<br>                break;<br>        }<br>    }<br><br><br>    return 0;<br>}<br></p> 
<div> 
 <br> 
</div> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2aeafa6428c9028f6fac7c26544d3f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信支付回调不了怎么办？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/313dc4074d4ebbbb700c303febccfee4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">后台导入excel数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>