<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>windows环境下用c&#43;&#43;实现socket编程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="windows环境下用c&#43;&#43;实现socket编程" />
<meta property="og:description" content="一、什么是Socket
socket即套接字，用于描述地址和端口，是一个通信链的句柄。应用程序通过socket向网络发出请求或者回应。
sockets(套接字)编程有三种，流式套接字（SOCK_STREAM），数据报套接字（SOCK_DGRAM），原始套接字（SOCK_RAW）；前两种较常用。基于TCP的socket编程是采用的流式套接字。
（1）SOCK_STREAM表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常用的HTTP协议就使用SOCK_STREAM传输数据，因为要确保数据的正确性，否则网页不能正常解析。
（2）SOCK_DGRAM表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为SOCK_DGRAM所做的校验工作少，所以效率比SOCK_STREAM高。
QQ视频聊天和语音聊天就使用SOCK_DGRAM传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。
注意：SOCK_DGRAM没有想象中的糟糕，不会频繁的丢失数据，数据错读只是小概率事件。
有可能多种协议使用同一种数据传输方式，所以在socket编程中，需要同时指明数据传输方式和协议。
二、客户端/服务端模式：
在TCP/IP网络应用中，通信的两个进程相互作用的主要模式是客户/服务器模式，即客户端向服务器发出请求，服务器接收请求后，提供相应的服务。客户/服务器模式的建立基于以下两点：
（1）建立网络的起因是网络中软硬件资源、运算能力和信息不均等，需要共享，从而就让拥有众多资源的主机提供服务，资源较少的客户请求服务这一非对等作用。
（2）网间进程通信完全是异步的，相互通信的进程间既不存在父子关系，又不共享内存缓冲区。
因此需要一种机制为希望通信的进程间建立联系，为二者的数据交换提供同步，这就是基于客户/服务端模式的TCP/IP。
服务端：建立socket，声明自身的端口号和地址并绑定到socket，使用listen打开监听，然后不断用accept去查看是否有连接，如果有，捕获socket，并通过recv获取消息的内容，通信完成后调用closeSocket关闭这个对应accept到的socket，如果不再需要等待任何客户端连接，那么用closeSocket关闭掉自身的socket。
客户端：建立socket，通过端口号和地址确定目标服务器，使用Connect连接到服务器，send发送消息，等待处理，通信完成后调用closeSocket关闭socket。
三、编程步骤
（1）服务端
1、加载套接字库，创建套接字（WSAStartup()/socket()）;
2、绑定套接字到一个IP地址和一个端口上（bind()）;
3、将套接字设置为监听模式等待连接请求（listen()）；
4、请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept()）；
5、用返回的套接字和客户端进行通信（send()/recv()）；
6、返回，等待另一个连接请求；
7、关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）；
（2）客户端
1、加载套接字库，创建套接字（WSAStartup()/socket()）；
2、向服务器发出连接请求（connect()）；
3、和服务器进行通信（send()/recv()）；
4、关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）；
四、windows下实现socket简单实例
使用软件：devc&#43;&#43;
（一）TCP协议
（1）代码
服务端：server.cpp
#include &lt;stdio.h&gt; #include &lt;winsock2.h&gt; #pragma comment(lib,&#34;ws2_32.lib&#34;) int main(int argc, char* argv[]) { //初始化WSA WORD sockVersion = MAKEWORD(2,2); WSADATA wsaData; if(WSAStartup(sockVersion, &amp;wsaData)!=0) { return 0; } //创建套接字 SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(slisten == INVALID_SOCKET) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b350b0df7c460b72c241c4126fae22c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-27T16:29:42+08:00" />
<meta property="article:modified_time" content="2017-02-27T16:29:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">windows环境下用c&#43;&#43;实现socket编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px"><strong>一、什么是Socket</strong></span></p> 
<p><span style="font-size:18px">socket即套接字，用于描述地址和端口，是一个通信链的句柄。应用程序通过socket向网络发出请求或者回应。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">sockets(套接字)编程有三种，流式套接字（SOCK_STREAM），数据报套接字（SOCK_DGRAM），原始套接字（SOCK_RAW）；前两种较常用。基于TCP的socket编程是采用的流式套接字。</span></p> 
<p><span style="font-size:18px">（1）SOCK_STREAM表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常用的HTTP协议就使用SOCK_STREAM传输数据，因为要确保数据的正确性，否则网页不能正常解析。</span></p> 
<p><span style="font-size:18px">（2）SOCK_DGRAM表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为SOCK_DGRAM所做的校验工作少，所以效率比SOCK_STREAM高。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">QQ视频聊天和语音聊天就使用SOCK_DGRAM传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><strong>注意</strong>：SOCK_DGRAM没有想象中的糟糕，不会频繁的丢失数据，数据错读只是小概率事件。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">有可能多种协议使用同一种数据传输方式，所以在socket编程中，需要同时指明数据传输方式和协议。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><strong>二、客户端/服务端模式：</strong></span></p> 
<p><span style="font-size:18px">在TCP/IP网络应用中，通信的两个进程相互作用的主要模式是客户/服务器模式，即客户端向服务器发出请求，服务器接收请求后，提供相应的服务。客户/服务器模式的建立基于以下两点：</span></p> 
<p><span style="font-size:18px">（1）建立网络的起因是网络中软硬件资源、运算能力和信息不均等，需要共享，从而就让拥有众多资源的主机提供服务，资源较少的客户请求服务这一非对等作用。</span></p> 
<p><span style="font-size:18px">（2）网间进程通信完全是异步的，相互通信的进程间既不存在父子关系，又不共享内存缓冲区。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">因此需要一种机制为希望通信的进程间建立联系，为二者的数据交换提供同步，这就是基于客户/服务端模式的TCP/IP。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><strong>服务端</strong>：建立socket，声明自身的端口号和地址并绑定到socket，使用listen打开监听，然后不断用accept去查看是否有连接，如果有，捕获socket，并通过recv获取消息的内容，通信完成后调用closeSocket关闭这个对应accept到的socket，如果不再需要等待任何客户端连接，那么用closeSocket关闭掉自身的socket。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"></span></p> 
<p><span style="font-size:18px"><strong>客户端</strong>：建立socket，通过端口号和地址确定目标服务器，使用Connect连接到服务器，send发送消息，等待处理，通信完成后调用closeSocket关闭socket。</span></p> 
<div> 
 <span style="font-size:18px"><br> </span> 
</div> 
<p><span style="font-size:18px"><strong>三、编程步骤</strong></span></p> 
<p><span style="font-size:18px"><strong>（1）服务端</strong></span></p> 
<p><span style="font-size:18px">1、加载套接字库，创建套接字（WSAStartup()/socket()）;</span></p> 
<p><span style="font-size:18px">2、绑定套接字到一个IP地址和一个端口上（bind()）;</span></p> 
<p><span style="font-size:18px">3、将套接字设置为监听模式等待连接请求（listen()）；</span></p> 
<p><span style="font-size:18px">4、请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept()）；</span></p> 
<p><span style="font-size:18px">5、用返回的套接字和客户端进行通信（send()/recv()）；</span></p> 
<p><span style="font-size:18px">6、返回，等待另一个连接请求；</span></p> 
<p><span style="font-size:18px">7、关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）；</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><strong>（2）客户端</strong></span></p> 
<p><span style="font-size:18px">1、加载套接字库，创建套接字（WSAStartup()/socket()）；</span></p> 
<p><span style="font-size:18px">2、向服务器发出连接请求（connect()）；</span></p> 
<p><span style="font-size:18px">3、和服务器进行通信（send()/recv()）；</span></p> 
<p><span style="font-size:18px">4、关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）；</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><strong>四、windows下实现socket简单实例</strong></span></p> 
<p><span style="font-size:18px">使用软件：devc++</span></p> 
<p><span style="font-size:18px"><strong>（一）TCP协议</strong></span></p> 
<p><span style="font-size:18px"><strong>（1）代码</strong></span></p> 
<p><span style="font-size:18px">服务端：server.cpp</span></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;  
#include &lt;winsock2.h&gt;  
  
#pragma comment(lib,"ws2_32.lib")  
  
int main(int argc, char* argv[])  
{  
    //初始化WSA  
    WORD sockVersion = MAKEWORD(2,2);  
    WSADATA wsaData;  
    if(WSAStartup(sockVersion, &amp;wsaData)!=0)  
    {  
        return 0;  
    }  
  
    //创建套接字  
    SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);  
    if(slisten == INVALID_SOCKET)  
    {  
        printf("socket error !");  
        return 0;  
    }  
  
    //绑定IP和端口  
    sockaddr_in sin;  
    sin.sin_family = AF_INET;  
    sin.sin_port = htons(8888);  
    sin.sin_addr.S_un.S_addr = INADDR_ANY;   
    if(bind(slisten, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR)  
    {  
        printf("bind error !");  
    }  
  
    //开始监听  
    if(listen(slisten, 5) == SOCKET_ERROR)  
    {  
        printf("listen error !");  
        return 0;  
    }  
  
    //循环接收数据  
    SOCKET sClient;  
    sockaddr_in remoteAddr;  
    int nAddrlen = sizeof(remoteAddr);  
    char revData[255];   
    while (true)  
    {  
        printf("等待连接...\n");  
        sClient = accept(slisten, (SOCKADDR *)&amp;remoteAddr, &amp;nAddrlen);  
        if(sClient == INVALID_SOCKET)  
        {  
            printf("accept error !");  
            continue;  
        }  
        printf("接受到一个连接：%s \r\n", inet_ntoa(remoteAddr.sin_addr));  
          
        //接收数据  
        int ret = recv(sClient, revData, 255, 0);         
        if(ret &gt; 0)  
        {  
            revData[ret] = 0x00;  
            printf(revData);  
        }  
  
        //发送数据  
        const char * sendData = "你好，TCP客户端！\n";  
        send(sClient, sendData, strlen(sendData), 0);  
        closesocket(sClient);  
    }  
      
    closesocket(slisten);  
    WSACleanup();  
    return 0;  
} </code></pre> 
<p></p> 
<p><br> </p> 
<span style="font-size:18px">客户端代码：client.cpp</span> 
<p></p> 
<pre><code class="language-cpp">#include&lt;WINSOCK2.H&gt;
#include&lt;STDIO.H&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
#pragma comment(lib, "ws2_32.lib")

int main()
{
	WORD sockVersion = MAKEWORD(2, 2);
	WSADATA data;
	if(WSAStartup(sockVersion, &amp;data)!=0)
	{
		return 0;
	}
	while(true){
		SOCKET sclient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if(sclient == INVALID_SOCKET)
		{
			printf("invalid socket!");
			return 0;
		}
		
		sockaddr_in serAddr;
		serAddr.sin_family = AF_INET;
		serAddr.sin_port = htons(8888);
		serAddr.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
		if(connect(sclient, (sockaddr *)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR)
		{  //连接失败 
			printf("connect error !");
			closesocket(sclient);
			return 0;
		}
		
		string data;
		cin&gt;&gt;data;
		const char * sendData;
		sendData = data.c_str();   //string转const char* 
		//char * sendData = "你好，TCP服务端，我是客户端\n";
		send(sclient, sendData, strlen(sendData), 0);
		//send()用来将数据由指定的socket传给对方主机
		//int send(int s, const void * msg, int len, unsigned int flags)
		//s为已建立好连接的socket，msg指向数据内容，len则为数据长度，参数flags一般设0
		//成功则返回实际传送出去的字符数，失败返回-1，错误原因存于error 
		
		char recData[255];
		int ret = recv(sclient, recData, 255, 0);
		if(ret&gt;0){
			recData[ret] = 0x00;
			printf(recData);
		} 
		closesocket(sclient);
	}
	
	
	WSACleanup();
	return 0;
	
}

</code></pre> 
<br> 
<br> 
<p></p> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px"><strong>（2）可能遇到的问题</strong>：</span></p> 
<p><span style="font-size:18px">(1)undefined reference to '_imp_WSAStartup'</span></p> 
<p><img src="https://images2.imgbox.com/6a/e4/ccWhXG4f_o.png" alt=""><br> </p> 
<p><br> </p> 
<p><span style="font-size:18px"><strong>解决方案：</strong></span></p> 
<p><span style="font-size:18px">工具-&gt;编译选项-&gt;在连接器命令行加入如下命令里面添加-lwsock32 即可</span></p> 
<p><span style="font-size:18px">然后重启devc++运行程序问题解决。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">（2）deprecated conversion from string constant to 'char *'[-Wwrite-strings]</span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/14/1d/vXO9cdEL_o.png" alt=""><br> </span></p> 
<p><br> </p> 
<p><span style="font-size:18px">解决方法：将char * 改为const char *</span></p> 
<p><br> </p> 
<p><span style="font-size:18px"><strong>（3）结果运行</strong></span></p> 
<p><span style="font-size:18px">先运行服务端，运行service.cpp，服务端显示如下：</span></p> 
<p><img src="https://images2.imgbox.com/e0/03/gTJ3NBCO_o.png" alt=""><br> </p> 
<p><br> </p> 
<p><span style="font-size:18px">然后运行客户端，运行client.cpp，在客户端输入数据，即可传送到服务器端显示如下：</span></p> 
<p><img src="https://images2.imgbox.com/a5/4c/CeEcwMwI_o.png" alt=""><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><span style="font-size:18px">（4）部分代码说明</span></p> 
<p><span style="font-size:18px">第一步：加载/释放Winsock库：</span></p> 
<p><span style="font-size:18px">加载方法：</span></p> 
<p></p> 
<pre><code class="language-cpp">WORD sockVersion = MAKEWORD(2,2);
WSADATA wsaData;</code></pre> 
<pre><code class="language-cpp">//初始化socket资源
if(WSAStartup(sockVersion, &amp;wsaData)!=0)
{
   return 0;  //代表失败
}</code></pre> 
<p></p> 
<p><span style="font-size:18px">释放方法：</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">WSACleanup();</code></pre> 
<p></p> 
<p><span style="font-size:18px"><br> </span></p> 
<span style="font-size:18px">第二步：构造SOCKET</span> 
<p><span style="font-size:18px">1. 服务端：构造监听SOCKET，流式SOCKET</span></p> 
<p></p> 
<pre><code class="language-cpp">//创建套接字
    SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(slisten == INVALID_SOCKET)
    {
        printf("socket error !");
        return 0;
    }
</code></pre> 
<p></p> 
<p><br> </p> 
<p><span style="font-size:18px">2. 客户端：构造通讯SOCKET，流式SOCKET</span></p> 
<p></p> 
<pre><code class="language-cpp">//创建套接字
   SOCKET sclient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if(sclient == INVALID_SOCKET)
    {
       printf("invalid socket !");
       return 0;
    }</code></pre> 
<br> 
<p></p> 
<p><span style="font-size:18px">第三步：配置监听地址和端口，服务端绑定IP地址和端口，客户端连接目的IP地址和端口：</span></p> 
<p><span style="font-size:18px">1. 服务端：</span></p> 
<p></p> 
<pre><code class="language-cpp">//绑定IP和端口
   sockaddr_in sin;
   sin.sin_family = AF_INET;
   sin.sin_port = htons(8888);   //本地监听端口：8888
   sin.sin_addr.S_un.S_addr = INADDR_ANY;
   if(bind(slisten, (LPSOCKADDR)&amp;sin, sizeof(sin)) ==SOCKET_ERROR)  //尝试绑定
    {
       printf("bind error !");
    }
//绑定成功后就开始监听
   if(listen(slisten, 5) == SOCKET_ERROR)
    {
       printf("listen error !");
       return 0;
    }</code></pre> 
<br> 
<p></p> 
<p><span style="font-size:18px">2. 客户端：</span></p> 
<p></p> 
<pre><code class="language-cpp">//配置要连接的地址和端口   
   sockaddr_in serAddr;
   serAddr.sin_family = AF_INET;
   serAddr.sin_port = htons(8888);
   serAddr.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
   if (connect(sclient, (sockaddr *)&amp;serAddr, sizeof(serAddr)) ==SOCKET_ERROR)  //尝试连接
    {
       printf("connect error !");
       closesocket(sclient);
       return 0;
    }</code></pre> 
<br> 
<p></p> 
<p><span style="font-size:18px">第四步：服务端/客户端连接</span></p> 
<p><span style="font-size:18px">1. 服务端：等待客户端接入</span></p> 
<p><span style="font-size:18px">SOCKET Command_Sock = accept(Listen_Sock,...)</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">2. 客户端：请求与服务端连接</span></p> 
<p><span style="font-size:18px">int ret = connect(Client_Sock, ...)</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">第五步：收/发数据</span></p> 
<p><span style="font-size:18px">1. 服务端：等待客户接入 charbuf[1024].</span></p> 
<p><span style="font-size:18px">接收数据：recv(Command_Sock, buf, ...)</span></p> 
<p><span style="font-size:18px">或</span></p> 
<p><span style="font-size:18px">发送数据：send(Command_Sock, buf, ...)</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">2. 客户端：请求与服务端连接char buf[1024].</span></p> 
<p><span style="font-size:18px">发送数据：send(Client_Sock, buf, ...)</span></p> 
<p><span style="font-size:18px">或</span></p> 
<p><span style="font-size:18px">接收数据：recv(Client_Sock, buf, ...)</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">第六步：关闭SOCKET</span></p> 
<p><span style="font-size:18px">1. 服务端关闭SOCKET</span></p> 
<p><span style="font-size:18px">closesocket(Listen_Sock)</span></p> 
<p><span style="font-size:18px">closesocket(Command_Sock)</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">2. 客户端关闭SOCKET</span></p> 
<p><span style="font-size:18px">closesocket(Client_Sock)</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">（二）UDP协议</span></p> 
<p><span style="font-size:18px">服务端代码：</span></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt; 
#include &lt;winsock2.h&gt; 
 
#pragma comment(lib,"ws2_32.lib")  
 
int main(int argc, char* argv[]) 
{ 
   WSADATA wsaData; 
   WORD sockVersion = MAKEWORD(2,2); 
   if(WSAStartup(sockVersion, &amp;wsaData) != 0) 
   { 
       return 0; 
   } 
 
   SOCKET serSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);  
   if(serSocket == INVALID_SOCKET) 
   { 
       printf("socket error !"); 
       return 0; 
   } 
 
   sockaddr_in serAddr; 
   serAddr.sin_family = AF_INET; 
   serAddr.sin_port = htons(8888); 
   serAddr.sin_addr.S_un.S_addr = INADDR_ANY; 
   if(bind(serSocket, (sockaddr *)&amp;serAddr, sizeof(serAddr)) ==SOCKET_ERROR) 
   { 
       printf("bind error !"); 
       closesocket(serSocket); 
       return 0; 
   } 
     
   sockaddr_in remoteAddr; 
   int nAddrLen = sizeof(remoteAddr);  
   while (true) 
   { 
       char recvData[255];   
       int ret = recvfrom(serSocket, recvData, 255, 0, (sockaddr*)&amp;remoteAddr, &amp;nAddrLen); 
       if (ret &gt; 0) 
       { 
           recvData[ret] = 0x00; 
           printf("接受到一个连接：%s \r\n",inet_ntoa(remoteAddr.sin_addr)); 
           printf(recvData);            
       } 
 
       const char * sendData = "一个来自服务端的UDP数据包\n"; 
       sendto(serSocket, sendData,strlen(sendData), 0, (sockaddr *)&amp;remoteAddr, nAddrLen);     
 
   } 
   closesocket(serSocket);  
   WSACleanup(); 
   return 0; 
} </code></pre> 
<br> 
<p></p> 
<p><span style="font-size:18px">客户端代码：</span></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt; 
#include &lt;winsock2.h&gt; 
 
#pragma comment(lib,"ws2_32.lib")  
 
int main(int argc, char* argv[]) 
{ 
   WORD socketVersion = MAKEWORD(2,2); 
   WSADATA wsaData;  
   if(WSAStartup(socketVersion, &amp;wsaData) != 0) 
   { 
       return 0; 
   } 
   SOCKET sclient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); 
     
   sockaddr_in sin; 
   sin.sin_family = AF_INET; 
   sin.sin_port = htons(8888); 
   sin.sin_addr.S_un.S_addr = inet_addr("127.0.0.1"); 
   int len = sizeof(sin); 
     
   const char * sendData = "来自客户端的数据包.\n"; 
   sendto(sclient, sendData, strlen(sendData), 0, (sockaddr *)&amp;sin,len); 
 
   char recvData[255];      
   int ret = recvfrom(sclient, recvData, 255, 0, (sockaddr *)&amp;sin,&amp;len); 
   if(ret &gt; 0) 
   { 
       recvData[ret] = 0x00; 
       printf(recvData); 
   } 
 
   closesocket(sclient); 
   WSACleanup(); 
   return 0; 
} 
</code></pre> 
<br>   
<p></p> 
<p><span style="font-size:18px">结果显示如下：</span></p> 
<p><span style="font-size:18px">服务端：</span></p> 
<p> <img src="https://images2.imgbox.com/47/91/siIUyVGj_o.png" alt=""></p> 
<p> </p> 
<p><span style="font-size:18px">客户端：</span></p> 
<p> <img src="https://images2.imgbox.com/a6/4a/8TuZHuq1_o.png" alt=""></p> 
<p> </p> 
<p></p> 
<p><span style="font-size:18px">五、Windows下的socket程序和Linux思路相同，细节处区别如下：</span></p> 
<p><span style="font-size:18px">（1）Windows下的socket程序依赖Winsock.dll或ws2_32.dll，必须提前加载。DLL有两种加载方式。</span></p> 
<p><span style="font-size:18px">（2）Linux使用“文件描述符”的概念，而Windows使用“文件句柄”的概念；Linux不区分socket文件和普通文件，而Windows区分；Linux下socket()函数的返回值为int类型，而Windows下为SOCKET类型，也就是句柄。</span></p> 
<p><span style="font-size:18px">（3）Linux下使用read()/write()函数读写，而Windows下使用recv()/send()函数发送和接收</span></p> 
<p><span style="font-size:18px">（4）关闭socket时，Linux使用close()函数，而Windows使用closesocket()函数。</span></p> 
<br> 
<pre><code class="language-cpp"></code><pre><code class="language-cpp"></code></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/749244b48fa7b55036529a341bf11002/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL截取和拆分字符</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a2bb6469336c54a221b3c44e430e826/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring循环依赖的三种方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>