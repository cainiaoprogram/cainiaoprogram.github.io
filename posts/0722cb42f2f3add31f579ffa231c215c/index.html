<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Rust之常用集合(二)：字符串(String) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Rust之常用集合(二)：字符串(String)" />
<meta property="og:description" content="开发环境 Windows 10Rust 1.65.0 VS Code 1.73.1
项目工程 这里继续沿用上次工程rust-demo
用字符串存储UTF-8编码的文本 我们在之前的章节中讨论了字符串，但现在我们将更深入地研究它们。新的Rust人会因为三个原因而陷入字符串:Rust倾向于暴露可能的错误，字符串是比许多程序员认为的更复杂的数据结构，以及UTF-8。当您来自其他编程语言时，这些因素以一种看起来很困难的方式结合在一起。
我们在集合的上下文中讨论字符串，因为字符串是作为字节的集合实现的，加上一些在那些字节被解释为文本时提供有用功能的方法。在这一节中，我们将讨论每个集合类型对String的操作，比如创建、更新和读取。我们还将讨论String与其他集合的不同之处，即人和计算机解释String数据的方式不同，如何使String的索引变得复杂。
字符串 我们先来定义一下字符串这个词的含义。Rust在核心语言中只有一个字符串类型，那就是字符串切片str，通常以其借用的形式&amp;str出现。在之前的章节中，我们谈到了字符串切片，它是对存储在其他地方的一些UTF-8编码的字符串数据的引用。例如，字符串字面意义存储在程序的二进制中，因此是字符串切片。
String类型是由Rust的标准库提供的，而不是编入核心语言的，它是一个可增长的、可变异的、自有的、UTF-8编码的字符串类型。当Rust人在Rust中提到 &#34;字符串 &#34;时，他们可能指的是String类型或字符串切片&amp;str类型，而不仅仅是这些类型中的一个。虽然本节主要是关于String，但这两种类型在Rust的标准库中都被大量使用，而且String和字符串切片都是UTF-8编码的。
创建新字符串 许多与Vec&lt;T&gt;相同的操作也可以用在String上，因为String实际上是作为一个字节向量的封装器来实现的，有一些额外的保证、限制和能力。一个在Vec&lt;T&gt;和String中以同样方式工作的函数的例子是创建实例的new函数。如下例所示，
fn main() { let mut s = String::new(); // 创建字符串 } 这一行创建了一个新的名为s的空字符串，然后我们可以将数据加载到其中。通常，我们会有一些想要开始字符串的初始数据。为此，我们使用to_string方法，该方法可用于任何实现Display特征的类型，就像字符串一样。如下所示，
fn main() { let data = &#34;initial contents&#34;; let s = data.to_string(); // 创建字符串s，并将data的值赋给s // 该方法也可以直接使用 let s = &#34;initial contents&#34;.to_string(); } 这段代码创建了一个包含初始内容的字符串。
我们也可以使用函数String::from来从一个字符串字面创建一个字符串。下例中的代码等同于上例中使用to_string的代码。
fn main() { let s = String::from(&#34;initial contents&#34;); // 通过from函数创建并初始化字符串变量s } 由于字符串的用途非常多，我们可以使用许多不同的字符串通用API，为我们提供了很多选择。其中有些看起来是多余的，但它们都有自己的位置 在这种情况下，String::from和to_string做同样的事情，所以你选择哪个是风格和可读性的问题。
请记住，字符串是UTF-8编码的，所以我们可以在其中包含任何正确编码的数据，如下例所示。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0722cb42f2f3add31f579ffa231c215c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-28T15:32:01+08:00" />
<meta property="article:modified_time" content="2022-11-28T15:32:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rust之常用集合(二)：字符串(String)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>开发环境</h2> 
<ul><li>Windows 10</li><li>Rust 1.65.0</li></ul> 
<p> <img alt="" height="52" src="https://images2.imgbox.com/fa/ed/nOhGFq5m_o.png" width="406"></p> 
<p>   VS Code 1.73.1</p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/74/9b/w0uF6oMB_o.png" width="402"></p> 
<h2> <a name="t1"></a>项目工程</h2> 
<p>这里继续沿用上次工程<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&amp;q=rust" title="rust">rust</a>-demo<br><img alt="" height="186" src="https://images2.imgbox.com/97/79/JJ6Vpqpf_o.png" width="264"></p> 
<h2>用字符串存储UTF-8编码的文本</h2> 
<p>我们在之前的章节中讨论了字符串，但现在我们将更深入地研究它们。新的Rust人会因为三个原因而陷入字符串:Rust倾向于暴露可能的错误，字符串是比许多程序员认为的更复杂的数据结构，以及UTF-8。当您来自其他编程语言时，这些因素以一种看起来很困难的方式结合在一起。</p> 
<p>我们在集合的上下文中讨论字符串，因为字符串是作为字节的集合实现的，加上一些在那些字节被解释为文本时提供有用功能的方法。在这一节中，我们将讨论每个集合类型对<strong><span style="background-color:#a2e043;">String</span></strong>的操作，比如创建、更新和读取。我们还将讨论<strong><span style="background-color:#a2e043;">String</span></strong>与其他集合的不同之处，即人和计算机解释<strong><span style="background-color:#a2e043;">String</span></strong>数据的方式不同，如何使<strong><span style="background-color:#a2e043;">String</span></strong>的索引变得复杂。</p> 
<h2>字符串</h2> 
<p>我们先来定义一下字符串这个词的含义。Rust在核心语言中只有一个字符串类型，那就是字符串切片<strong><span style="color:#a2e043;"><span style="background-color:#a2e043;">str</span></span></strong>，通常以其借用的形式<strong><span style="background-color:#a2e043;">&amp;str</span></strong>出现。在之前的章节中，我们谈到了字符串切片，它是对存储在其他地方的一些UTF-8编码的字符串数据的引用。例如，字符串字面意义存储在程序的二进制中，因此是字符串切片。</p> 
<p><strong><span style="background-color:#a2e043;">String</span></strong>类型是由Rust的标准库提供的，而不是编入核心语言的，它是一个可增长的、可变异的、自有的、UTF-8编码的字符串类型。当Rust人在Rust中提到 "字符串 "时，他们可能指的是<strong><span style="background-color:#a2e043;">String</span></strong>类型或字符串切片<strong><span style="background-color:#a2e043;">&amp;str</span></strong>类型，而不仅仅是这些类型中的一个。虽然本节主要是关于<strong><span style="background-color:#a2e043;">String</span></strong>，但这两种类型在Rust的标准库中都被大量使用，而且<strong><span style="background-color:#a2e043;">String</span></strong>和字符串切片都是UTF-8编码的。</p> 
<h2>创建新字符串</h2> 
<p>许多与<strong><span style="background-color:#a2e043;">Vec&lt;T&gt;</span></strong>相同的操作也可以用在<strong><span style="background-color:#a2e043;">String</span></strong>上，因为<strong><span style="background-color:#a2e043;">String</span></strong>实际上是作为一个字节向量的封装器来实现的，有一些额外的保证、限制和能力。一个在<strong><span style="background-color:#a2e043;">Vec&lt;T&gt;</span></strong>和<strong><span style="background-color:#a2e043;">String</span></strong>中以同样方式工作的函数的例子是创建实例的<strong><span style="background-color:#a2e043;">new</span></strong>函数。如下例所示，</p> 
<pre><code class="language-rust">fn main() {
    let mut s = String::new();        // 创建字符串
}
</code></pre> 
<p>这一行创建了一个新的名为<strong><span style="background-color:#a2e043;">s</span></strong>的空字符串，然后我们可以将数据加载到其中。通常，我们会有一些想要开始字符串的初始数据。为此，我们使用<strong><span style="background-color:#a2e043;">to_string</span></strong>方法，该方法可用于任何实现<strong><span style="background-color:#a2e043;">Display</span></strong>特征的类型，就像字符串一样。如下所示，</p> 
<pre><code class="language-rust">fn main() {
    let data = "initial contents";

    let s = data.to_string();         // 创建字符串s，并将data的值赋给s

    // 该方法也可以直接使用
    let s = "initial contents".to_string();
}
</code></pre> 
<p> 这段代码创建了一个包含初始内容的字符串。</p> 
<p>我们也可以使用函数<strong><span style="background-color:#a2e043;">String::from</span></strong>来从一个字符串字面创建一个字符串。下例中的代码等同于上例中使用<strong><span style="background-color:#a2e043;">to_string</span></strong>的代码。</p> 
<pre><code class="language-rust">fn main() {
    let s = String::from("initial contents");   // 通过from函数创建并初始化字符串变量s
}
</code></pre> 
<p>由于字符串的用途非常多，我们可以使用许多不同的字符串通用API，为我们提供了很多选择。其中有些看起来是多余的，但它们都有自己的位置 在这种情况下，<strong><span style="background-color:#a2e043;">String::from</span></strong>和<strong><span style="background-color:#a2e043;">to_string</span></strong>做同样的事情，所以你选择哪个是风格和可读性的问题。</p> 
<p>请记住，字符串是UTF-8编码的，所以我们可以在其中包含任何正确编码的数据，如下例所示。</p> 
<pre><code class="language-rust">fn main() {
    let hello = String::from("السلام عليكم");       // 字符串创建示例
    print!("{}\n", hello);
    let hello = String::from("Dobrý den");
    print!("{}\n", hello);
    let hello = String::from("Hello");
    print!("{}\n", hello);
    let hello = String::from("שָׁלוֹם");
    print!("{}\n", hello);
    let hello = String::from("नमस्ते");
    print!("{}\n", hello);
    let hello = String::from("こんにちは");
    print!("{}\n", hello);
    let hello = String::from("안녕하세요");
    print!("{}\n", hello);
    let hello = String::from("你好");
    print!("{}\n", hello);
    let hello = String::from("Olá");
    print!("{}\n", hello);
    let hello = String::from("Здравствуйте");
    print!("{}\n", hello);
    let hello = String::from("Hola");
    print!("{}\n", hello);
}
</code></pre> 
<p>编译运行</p> 
<pre><code class="language-bash">cargo run</code></pre> 
<p>结果 </p> 
<p> <img alt="" height="264" src="https://images2.imgbox.com/37/1c/NrD5UaXR_o.png" width="561"></p> 
<p> 所有这些都是有效的<strong><span style="background-color:#a2e043;">String</span></strong>值。</p> 
<h2>更新字符串</h2> 
<p>如果你把更多的数据推入一个<strong><span style="background-color:#a2e043;">String</span></strong>，它的大小可以增长，它的内容可以改变，就像<strong><span style="background-color:#a2e043;">Vec&lt;T&gt;</span></strong>的内容一样。此外，你可以方便地使用<strong><span style="background-color:#a2e043;">+</span></strong>运算符或<strong><span style="background-color:#a2e043;">format！</span></strong>宏来连接<strong><span style="background-color:#a2e043;">String</span></strong>的值。</p> 
<h3>追加字符串：push_str和push</h3> 
<p>我们可以通过使用<strong><span style="background-color:#a2e043;">push_str</span></strong>方法追加一个<strong><span style="background-color:#a2e043;">String</span></strong>切片来增长一个字符串，下例所示。</p> 
<pre><code class="language-rust">fn main() {
    let mut s = String::from("foo");
    s.push_str("bar");     // 追加字符串，push_str接口
}
</code></pre> 
<p>在这两行之后<strong><span style="background-color:#a2e043;">，s</span></strong>将包含<strong><span style="background-color:#a2e043;">foobar</span></strong>。<strong><span style="background-color:#a2e043;">push_str</span></strong>方法需要一个字符串切片，因为我们不一定要取得参数的所有权。例如，在下例中，我们希望在将<strong><span style="background-color:#a2e043;">s2</span></strong>的内容追加到<strong><span style="background-color:#a2e043;">s1</span></strong>后能够使用它。</p> 
<pre><code class="language-rust">fn main() {
    let mut s1 = String::from("foo");     // 创建字符串s1
    let s2 = "bar";                       // 初始化字符串s2
    s1.push_str(s2);                      // 将s2追加到s1
    println!("s2 is {}", s2);
    println!("s1 is {}", s1);
}
</code></pre> 
<p>编译运行</p> 
<pre><code class="language-bash">cargo run</code></pre> 
<p><img alt="" height="113" src="https://images2.imgbox.com/25/56/Gh04RvsZ_o.png" width="545"></p> 
<p> 如果<strong><span style="background-color:#a2e043;">push_str</span></strong>方法取得了<strong><span style="background-color:#a2e043;">s2</span></strong>的所有权，我们就不能在最后一行打印它的值。然而，这段代码正如我们所期望的那样工作。</p> 
<p><strong><span style="background-color:#a2e043;">push</span></strong>方法接受一个单一的字符作为参数并将其添加到<strong><span style="background-color:#a2e043;">String</span></strong>中。下例中使用<strong><span style="background-color:#a2e043;">push</span></strong>方法将字母 "l "添加到一个<strong><span style="background-color:#a2e043;">String</span></strong>中。</p> 
<pre><code class="language-rust">fn main() {
    let mut s = String::from("lo");
    s.push('l');            // push接口
    println!("s is {}", s);
}
</code></pre> 
<p>编译运行</p> 
<pre><code class="language-bash">cargo run</code></pre> 
<p>结果 </p> 
<p><img alt="" height="89" src="https://images2.imgbox.com/cc/24/gUP0czO8_o.png" width="506"></p> 
<p>结果显示，<strong><span style="background-color:#a2e043;">s</span></strong>将包含<strong><span style="background-color:#a2e043;">lol</span></strong>。</p> 
<h3>格式化字符串：用 "+"运算符或 "format!宏</h3> 
<p>通常情况下，你会想把两个现有的字符串结合起来。一种方法是使用<strong><span style="background-color:#a2e043;">+</span></strong>运算符，如下例所示。</p> 
<pre><code class="language-rust">fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // + 运算符
    println!("s3 is {}", s3);
}
</code></pre> 
<p>编译运行</p> 
<pre><code class="language-bash">cargo run</code></pre> 
<p>结果 </p> 
<p><img alt="" height="98" src="https://images2.imgbox.com/ff/ba/NBwqXZib_o.png" width="535"></p> 
<p>字符串<strong><span style="background-color:#a2e043;">s3</span></strong>将包含<strong><span style="background-color:#a2e043;">Hello, world！</span></strong>。<strong><span style="background-color:#a2e043;">s1</span></strong>在添加后不再有效的原因，以及我们使用对<strong><span style="background-color:#a2e043;">s2</span></strong>的引用的原因，都与我们使用<strong><span style="background-color:#a2e043;">+</span></strong>运算符时调用的方法的签名有关。<strong><span style="background-color:#a2e043;">+</span></strong>操作符使用<strong><span style="background-color:#a2e043;">add</span></strong>方法，其签名看起来像这样。</p> 
<pre><code class="language-rust">fn add(self, s: &amp;str) -&gt; String {
</code></pre> 
<p>在标准库中，你会看到使用泛型和关联类型定义的<strong><span style="background-color:#a2e043;">add</span></strong>。在这里，我们用具体的类型来代替，这就是我们用<strong><span style="background-color:#a2e043;">String</span></strong>值调用这个方法时的情况。我们将在后续章节讨论泛型。这个签名为我们提供了理解<strong><span style="background-color:#a2e043;">+</span></strong>运算符的棘手部分所需的线索。</p> 
<p>首先，<strong><span style="background-color:#a2e043;">s2</span></strong>有一个<strong><span style="background-color:#a2e043;">&amp;</span></strong>，意味着我们要把第二个字符串的引用添加到第一个字符串中。这是因为<strong><span style="background-color:#a2e043;">add</span></strong>函数中的<strong><span style="background-color:#a2e043;">s</span></strong>参数：我们只能把一个<strong><span style="background-color:#a2e043;">&amp;str</span></strong>加到一个<strong><span style="background-color:#a2e043;">String</span></strong>上；我们不能把两个<strong><span style="background-color:#a2e043;">String</span></strong>值加在一起。但是等等--<strong><span style="background-color:#a2e043;">&amp;s2</span></strong>的类型是<strong><span style="background-color:#a2e043;">&amp;String</span></strong>，而不是<strong><span style="background-color:#a2e043;">&amp;str</span></strong>，正如<strong><span style="background-color:#a2e043;">add</span></strong>的第二个参数所指定的那样。那么，为什么上例会被编译？</p> 
<p>我们能够在调用<strong><span style="background-color:#a2e043;">add</span></strong>时使用<strong><span style="background-color:#a2e043;">&amp;s2</span></strong>的原因是，编译器可以将<strong><span style="background-color:#a2e043;">&amp;String</span></strong>参数强制变成<strong><span style="background-color:#a2e043;">&amp;str</span></strong>。当我们调用<strong><span style="background-color:#a2e043;">add</span></strong>方法时，Rust使用了一个<strong><span style="background-color:#a2e043;">deref coercion</span></strong>，在这里它把<strong><span style="background-color:#a2e043;">&amp;s2</span></strong>变成了<strong><span style="background-color:#a2e043;">&amp;s2[...]</span></strong>。我们将在后续章节更深入地讨论<strong><span style="background-color:#a2e043;">deref coercion</span></strong>。因为<strong><span style="background-color:#a2e043;">add</span></strong>并没有取得<strong><span style="background-color:#a2e043;">s</span></strong>参数的所有权，所以<strong><span style="background-color:#a2e043;">s2</span></strong>在这个操作之后仍然是一个有效的<strong><span style="background-color:#a2e043;">String</span></strong>。</p> 
<p>第二，我们可以在签名中看到，<strong><span style="background-color:#a2e043;">add</span></strong>取得了<strong><span style="background-color:#a2e043;">self</span></strong>的所有权，因为<strong><span style="background-color:#a2e043;">self</span></strong>没有<strong><span style="background-color:#a2e043;">&amp;</span></strong>。这意味着上例中的<strong><span style="background-color:#a2e043;">s1</span></strong>将被移到<strong><span style="background-color:#a2e043;">add</span></strong>调用中，此后将不再有效。因此，尽管l<strong><span style="background-color:#a2e043;">et s3 = s1 + &amp;s2</span></strong>;看起来会复制两个字符串并创建一个新的字符串，但这个语句实际上取得了<strong><span style="background-color:#a2e043;">s1</span></strong>的所有权，附加了<strong><span style="background-color:#a2e043;">s2</span></strong>内容的副本，然后返回结果的所有权。换句话说，它看起来是在做大量的拷贝，但其实不是；实现起来比拷贝更有效率。</p> 
<p>如果我们需要串联多个字符串，那么<strong><span style="background-color:#a2e043;">+</span></strong>运算符的行为就会变得很不方便。</p> 
<pre><code class="language-rust">fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;          // 多字符串追加
    
    println!("s is {}", s);
}
</code></pre> 
<p>编译运行</p> 
<pre><code class="language-bash">cargo run</code></pre> 
<p> 结果</p> 
<p><img alt="" height="98" src="https://images2.imgbox.com/55/33/5lLRHSAG_o.png" width="516"></p> 
<p>在这一点上，<strong><span style="background-color:#a2e043;">s</span></strong>将是<strong><span style="background-color:#a2e043;">tic-tac-toe</span></strong>。由于所有的 "<strong><span style="background-color:#a2e043;">+</span></strong>"和""字符，我们很难看到发生了什么事。对于更复杂的字符串组合，我们可以改用<strong><span style="background-color:#a2e043;">format！</span></strong>宏。 </p> 
<pre><code class="language-rust">fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{}-{}-{}", s1, s2, s3);       // format!宏
    
    println!("s is {}", s);
}
</code></pre> 
<p>编译运行</p> 
<pre><code class="language-bash">cargo run</code></pre> 
<p>结果</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/fd/f8/7OmFsuyO_o.png" width="545"></p> 
<p>这段代码还将<strong><span style="background-color:#a2e043;">s</span></strong>设置为<strong><span style="background-color:#a2e043;">tic-tac-toe</span></strong>。<strong><span style="background-color:#a2e043;">format！</span></strong>宏的工作原理与<strong><span style="background-color:#a2e043;">println！</span></strong>类似，但它不是将输出打印到屏幕上，而是返回一个包含内容的字符串。使用<strong><span style="background-color:#a2e043;">format! </span></strong>的代码版本更容易阅读，由<strong><span style="background-color:#a2e043;">format! </span></strong>宏生成的代码使用了引用，这样这个调用就不会占用任何参数的所有权。</p> 
<h3>对字符串进行索引</h3> 
<p>在许多其他编程语言中，通过索引来访问字符串中的单个字符是一种有效的、常见的操作。然而，如果你试图用Rust中的索引语法访问字符串的一部分，你会得到一个错误。请看下例中的无效代码。</p> 
<pre><code class="language-rust">fn main() {
    let s1 = String::from("hello");
    let h = s1[0];
}
</code></pre> 
<p>编译</p> 
<pre><code class="language-bash">cargo run</code></pre> 
<p><img alt="" height="488" src="https://images2.imgbox.com/1b/8d/OsdOtGq3_o.png" width="630"></p> 
<p>这个错误和注释说明了问题。Rust字符串不支持索引。但为什么不呢？为了回答这个问题，我们需要讨论Rust如何在内存中存储字符串。 </p> 
<h4>内部表述</h4> 
<p>字符串是对<strong><span style="background-color:#a2e043;">Vec&lt;u8&gt;</span></strong>的一个封装。让我们看看上例中的一些正确编码的UTF-8示例字符串。首先是这个。</p> 
<pre><code class="language-rust"> let hello = String::from("Hola");</code></pre> 
<p>在这种情况下，<strong><span style="background-color:#a2e043;">len</span></strong>将是4，这意味着存储 "Hola "字符串的向量有4个字节长。当用UTF-8编码时，每个字母需要1个字节。然而，下面一行可能会让你吃惊。(请注意，这个字符串以大写的西里尔字母Ze开始，而不是阿拉伯数字3）。</p> 
<pre><code class="language-rust">let hello = String::from("Здравствуйте");</code></pre> 
<p>当被问及这个字符串有多长时，你可能会说12。事实上，Rust的答案是24：这是UTF-8编码 "Здравствуйте "所需的字节数，因为该字符串中的每个Unicode标量值需要2个字节的存储空间。因此，对字符串字节的索引并不总是与有效的Unicode标量值相关。为了证明这一点，请看这个无效的Rust代码。</p> 
<pre><code class="language-rust">let hello = "Здравствуйте";
let answer = &amp;hello[0];
</code></pre> 
<p>你已经知道<strong><span style="background-color:#a2e043;">answer</span></strong>不会是<strong><span style="background-color:#a2e043;">З</span></strong>，第一个字母。当用UTF-8编码时，<strong><span style="background-color:#a2e043;">З</span></strong>的第一个字节是<strong><span style="background-color:#a2e043;">208</span></strong>，第二个字节是<strong><span style="background-color:#a2e043;">151</span></strong>，所以看起来<strong><span style="background-color:#a2e043;">answer</span></strong>实际上应该是<strong><span style="background-color:#a2e043;">208</span></strong>，但是<strong><span style="background-color:#a2e043;">208</span></strong>本身不是一个有效的字符。如果用户要求得到这个字符串的第一个字母，返回<strong><span style="background-color:#a2e043;">208</span></strong>可能不是他们想要的；但是，这是Rust在字节索引<strong><span style="background-color:#a2e043;">0</span></strong>处的唯一数据。用户一般不希望返回字节值，即使字符串只包含拉丁字母：如果<strong><span style="background-color:#a2e043;">&amp;"hello"[0]</span></strong>是返回字节值的有效代码，它将返回<strong><span style="background-color:#a2e043;">104</span></strong>，而不是<strong><span style="background-color:#a2e043;">h</span></strong>。</p> 
<p>那么答案是，为了避免返回一个意外的值，造成可能无法立即发现的bug，Rust根本不编译这段代码，并在开发过程的早期防止误解。</p> 
<h4>字节和标量值以及字母簇</h4> 
<p>关于UTF-8的另一点是，从Rust的角度来看，实际上有三种相关的方式来看待字符串：作为字节、标量值和字素簇（最接近于我们所说的字母）。</p> 
<p>如果我们看一下用Devanagari文字写的印地语单词 "नमस्ते"，它被存储为一个u8值的向量，看起来像这样。</p> 
<pre><code class="language-rust">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]</code></pre> 
<p>这就是18个字节，也是计算机最终存储这些数据的方式。如果我们把它们看成Unicode标量值，也就是Rust的<strong><span style="background-color:#a2e043;">char</span></strong>类型，这些字节看起来是这样的。</p> 
<pre><code class="language-rust">['न', 'म', 'स', '्', 'त', 'े']</code></pre> 
<p>这里有六个<strong><span style="background-color:#a2e043;">char</span></strong>值，但第四个和第六个不是字母：它们是本身没有意义的变音符号。最后，如果我们把它们看作是字素簇，我们会得到一个人所说的组成印地语单词的四个字母。</p> 
<pre><code class="language-rust">["न", "म", "स्", "ते"]</code></pre> 
<p>Rust提供了不同的方式来解释计算机存储的原始字符串数据，这样每个程序都可以选择它所需要的解释，无论数据是用什么人类语言。</p> 
<p>Rust不允许我们在一个<strong><span style="background-color:#a2e043;">String</span></strong>中建立索引来获得一个字符的最后一个原因是，索引操作预计总是需要恒定的时间 (O(1))。但是用一个<strong><span style="background-color:#a2e043;">String</span></strong>不可能保证这样的性能，因为Rust必须从开始到索引的内容中走一遍，以确定有多少个有效字符。</p> 
<h2>字符串切片</h2> 
<p>对字符串进行索引往往是一个坏主意，因为不清楚字符串索引操作的返回类型应该是什么：一个字节值、一个字符、一个字素簇，还是一个字符串片断。因此，如果你真的需要使用索引来创建字符串片，Rust会要求你更加具体。</p> 
<p>与使用<strong><span style="background-color:#a2e043;">[]</span></strong>与单个数字进行索引相比，你可以使用<strong><span style="background-color:#a2e043;">[]</span></strong>与一个范围来创建一个包含特定字节的字符串切片。</p> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
    let hello = "Здравствуйте";

    let s = &amp;hello[0..4];      // 字符串切片
}
</code></pre> 
<p>这里，<strong><span style="background-color:#a2e043;">s</span></strong>将是一个<strong><span style="background-color:#a2e043;">&amp;str</span></strong>，包含了字符串的前4个字节。早些时候，我们提到这些字符中的每一个都是2个字节，这意味着<strong><span style="background-color:#a2e043;">s</span></strong>将是<strong><span style="background-color:#a2e043;">Зд</span></strong>。</p> 
<p>如果我们试图用<strong><span style="background-color:#a2e043;">&amp;hello[0..1]</span></strong>这样的东西只对一个字符的部分字节进行切分，Rust会在运行时出现恐慌，就像在向量中访问一个无效的索引一样。</p> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
    let hello = "Здравствуйте";

    let s = &amp;hello[0..1];
}
</code></pre> 
<p>编译</p> 
<pre><code class="language-bash">cargo run</code></pre> 
<p><img alt="" height="135" src="https://images2.imgbox.com/da/62/PGIavFYc_o.png" width="1039"></p> 
<p> 你应该谨慎地使用范围来创建字符串片，因为这样做会使你的程序崩溃。</p> 
<h2> 字符串迭代</h2> 
<p>对字符串片段进行操作的最好方法是明确说明你要的是字符还是字节。对于单个Unicode标量值，使用<strong><span style="background-color:#a2e043;">chars</span></strong>方法。在 "Зд "上调用<strong><span style="background-color:#a2e043;">chars</span></strong>，可以分离并返回两个<strong><span style="background-color:#a2e043;">char</span></strong>类型的值，你可以对结果进行迭代以访问每个元素。</p> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
    for c in "Зд".chars() {
        println!("{}", c);
     }
}
</code></pre> 
<p>编译运行</p> 
<pre><code class="language-bash">cargo run</code></pre> 
<p><img alt="" height="107" src="https://images2.imgbox.com/14/17/iHlYkLkV_o.png" width="526"></p> 
<p>或者，字节方法返回每个原始字节，这可能适合你的领域。 </p> 
<pre><code class="language-rust">#![allow(unused)]
fn main() {
    for b in "Зд".bytes() {
       println!("{}", b);
   }
}
</code></pre> 
<p>编译运行</p> 
<pre><code class="language-bash">cargo run</code></pre> 
<p><img alt="" height="149" src="https://images2.imgbox.com/bd/b1/x6bi6KmT_o.png" width="545"></p> 
<p><strong>但一定要记住，有效的Unicode标量值可能由1个以上的字节组成。 </strong></p> 
<p>像Devanagari脚本那样从字符串中获取字素簇是很复杂的，所以标准库没有提供这个功能。如果你需要这个功能，可以在<strong><span style="background-color:#a2e043;">crates.io</span></strong>上找到<strong><span style="background-color:#a2e043;">crates</span></strong>。</p> 
<h2>字符串并不简单</h2> 
<p>总而言之，字符串是复杂的。不同的编程语言对如何向程序员展示这种复杂性做出了不同的选择。Rust选择将正确处理<strong><span style="background-color:#a2e043;">String</span></strong>数据作为所有Rust程序的默认行为，这意味着程序员必须在处理UTF-8数据上花费更多心思。这种权衡使字符串的复杂性比其他编程语言更明显，但它可以防止你在开发周期的后期处理涉及非ASCII字符的错误。</p> 
<p>好消息是，标准库提供了很多基于<strong><span style="background-color:#a2e043;">String</span></strong>和<strong><span style="background-color:#a2e043;">&amp;str</span></strong>类型的功能，以帮助正确处理这些复杂的情况。请务必查看文档，了解有用的方法，如用于在字符串中搜索的<strong><span style="background-color:#a2e043;">contains</span></strong>和用于用另一个字符串替换部分字符串的<strong><span style="background-color:#a2e043;">replace</span></strong>。</p> 
<h2>本章重点</h2> 
<ul><li>字符串的概念</li><li>创建字符串，以及初始化字符串</li><li>更新字符串，push_str和push的使用</li><li>字符串连接和格式化：+操作符和format！宏</li><li>字符串索引及注意事项</li><li>字符串切片及注意使用范围</li><li>字符串的迭代</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/384153463970fe040faa864d9b9d3ce4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">八皇后问题4种c语言算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3211f6d67b665bd12296a22fde980887/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android学习---zygote(上)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>