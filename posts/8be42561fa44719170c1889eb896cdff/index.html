<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>llvm程序手册 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="llvm程序手册" />
<meta property="og:description" content="原文地址 注：单纯机翻
1 Introduction2 General Information 2.1 The C&#43;&#43; Standard Template Library2.2 Other useful references 3 Important and useful LLVM APIs 3.1 The isa&lt;&gt;, cast&lt;&gt; and dyn_cast&lt;&gt; templates3.2 Passing strings (the StringRef and Twine classes) 3.2.1 The StringRef class3.2.2 The Twine class 3.3 Formatting strings (the formatv function) 3.3.1 Simple formatting3.3.2 Custom formatting3.3.3 formatv Examples 3.4 Error handling 3.4.1 Programmatic Errors3.4.2 Recoverable Errors 3.4.2.1 StringError3.4.2.2 Interoperability with std::error_code and ErrorOr3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8be42561fa44719170c1889eb896cdff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-18T23:02:26+08:00" />
<meta property="article:modified_time" content="2023-06-18T23:02:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">llvm程序手册</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="httpsllvmorgdocsProgrammersManualhtml_3"></a><a href="https://llvm.org/docs/ProgrammersManual.html" rel="nofollow">原文地址</a></h2> 
<p><code>注：单纯机翻</code></p> 
<ul><li>1 Introduction</li><li>2 General Information 
  <ul><li>2.1 The C++ Standard Template Library</li><li>2.2 Other useful references</li></ul> </li><li>3 Important and useful LLVM APIs 
  <ul><li>3.1 The isa&lt;&gt;, cast&lt;&gt; and dyn_cast&lt;&gt; templates</li><li>3.2 Passing strings (the StringRef and Twine classes) 
    <ul><li>3.2.1 The StringRef class</li><li>3.2.2 The Twine class</li></ul> </li><li>3.3 Formatting strings (the formatv function) 
    <ul><li>3.3.1 Simple formatting</li><li>3.3.2 Custom formatting</li><li>3.3.3 formatv Examples</li></ul> </li><li>3.4 Error handling 
    <ul><li>3.4.1 Programmatic Errors</li><li>3.4.2 Recoverable Errors 
      <ul><li>3.4.2.1 StringError</li><li>3.4.2.2 Interoperability with std::error_code and ErrorOr</li><li>3.4.2.3 Returning Errors from error handlers</li><li>3.4.2.4 Using ExitOnError to simplify tool code</li><li>3.4.2.5 Using cantFail to simplify safe callsites</li><li>3.4.2.6 Fallible constructors</li><li>3.4.2.7 Propagating and consuming errors based on types</li><li>3.4.2.8 Concatenating Errors with joinErrors</li><li>3.4.2.9 Building fallible iterators and iterator ranges</li></ul> </li></ul> </li><li>3.5 Passing functions and other callable objects 
    <ul><li>3.5.1 Function template</li><li>3.5.2 The function_ref class template</li></ul> </li><li>3.6 The LLVM_DEBUG() macro and -debug option 
    <ul><li>3.6.1 Fine grained debug info with DEBUG_TYPE and the -debug-only option</li></ul> </li><li>3.7 The Statistic class &amp; -stats option</li><li>3.8 Adding debug counters to aid in debugging your code</li><li>3.9 Viewing graphs while debugging code</li></ul> </li><li>4 Picking the Right Data Structure for a Task 
  <ul><li>4.1 Sequential Containers (std::vector, std::list, etc) 
    <ul><li>4.1.1 llvm/ADT/ArrayRef.h</li><li>4.1.2 Fixed Size Arrays</li><li>4.1.3 Heap Allocated Arrays</li><li>4.1.4 llvm/ADT/TinyPtrVector.h</li><li>4.1.5 llvm/ADT/SmallVector.h</li><li>4.1.6 <code>&lt;vector&gt;</code></li><li>4.1.7 <code>&lt;deque&gt;</code></li><li>4.1.8 <code>&lt;list&gt;</code></li><li>4.1.9 llvm/ADT/ilist.h</li><li>4.1.10 llvm/ADT/PackedVector.h</li><li>4.1.11 ilist_traits</li><li>4.1.12 llvm/ADT/ilist_node.h</li><li>4.1.13 Sentinels</li><li>4.1.14 Other Sequential Container options</li></ul> </li><li>4.2 String-like containers 
    <ul><li>4.2.1 llvm/ADT/StringRef.h</li><li>4.2.2 llvm/ADT/Twine.h</li><li>4.2.3 llvm/ADT/SmallString.h</li><li>4.2.4 std::string</li></ul> </li><li>4.3 Set-Like Containers (std::set, SmallSet, SetVector, etc) 
    <ul><li>4.3.1 A sorted ‘vector’</li><li>4.3.2 llvm/ADT/SmallSet.h</li><li>4.3.3 llvm/ADT/SmallPtrSet.h</li><li>4.3.4 llvm/ADT/StringSet.h</li><li>4.3.5 llvm/ADT/DenseSet.h</li><li>4.3.6 llvm/ADT/SparseSet.h</li><li>4.3.7 llvm/ADT/SparseMultiSet.h</li><li>4.3.8 llvm/ADT/FoldingSet.h</li><li>4.3.9 <code>&lt;set&gt;</code></li><li>4.3.10 llvm/ADT/SetVector.h</li><li>4.3.11 llvm/ADT/UniqueVector.h</li><li>4.3.12 llvm/ADT/ImmutableSet.h</li><li>4.3.13 Other Set-Like Container Options</li></ul> </li><li>4.4 Map-Like Containers (std::map, DenseMap, etc) 
    <ul><li>4.4.1 A sorted ‘vector’</li><li>4.4.2 llvm/ADT/StringMap.h</li><li>4.4.3 llvm/ADT/IndexedMap.h</li><li>4.4.4 llvm/ADT/DenseMap.h</li><li>4.4.5 llvm/IR/ValueMap.h</li><li>4.4.6 llvm/ADT/IntervalMap.h</li><li>4.4.7 llvm/ADT/IntervalTree.h</li><li>4.4.8 <code>&lt;map&gt;</code></li><li>4.4.9 llvm/ADT/MapVector.h</li><li>4.4.10 llvm/ADT/IntEqClasses.h</li><li>4.4.11 llvm/ADT/ImmutableMap.h</li><li>4.4.12 Other Map-Like Container Options</li></ul> </li><li>4.5 Bit storage containers 
    <ul><li>4.5.1 BitVector</li><li>4.5.2 SmallBitVector</li><li>4.5.3 SparseBitVector</li><li>4.5.4 CoalescingBitVector</li></ul> </li><li>4.6 Useful Utility Functions 
    <ul><li>4.6.1 Iterating over ranges 
      <ul><li>4.6.1.1 The zip* functions</li><li>4.6.1.2 enumerate</li></ul> </li></ul> </li></ul> </li><li>5 Debugging</li><li>6 Helpful Hints for Common Operations 
  <ul><li>6.1 Basic Inspection and Traversal Routines 
    <ul><li>6.1.1 Iterating over the BasicBlock in a Function</li><li>6.1.2 Iterating over the Instruction in a BasicBlock</li><li>6.1.3 Iterating over the Instruction in a Function</li><li>6.1.4 Turning an iterator into a class pointer (and vice-versa)</li><li>6.1.5 Finding call sites: a slightly more complex example</li><li>6.1.6 Iterating over def-use &amp; use-def chains</li><li>6.1.7 Iterating over predecessors &amp; successors of blocks</li></ul> </li><li>6.2 Making simple changes 
    <ul><li>6.2.1 Creating and inserting new Instructions</li><li>6.2.2 Deleting Instructions</li><li>6.2.3 Replacing an Instruction with another Value 
      <ul><li>6.2.3.1 Replacing individual instructions</li><li>6.2.3.2 Deleting Instructions</li><li>6.2.3.3 Replacing multiple uses of Users and Values</li></ul> </li><li>6.2.4 Deleting GlobalVariables</li></ul> </li></ul> </li><li>7 Threads and LLVM 
  <ul><li>7.1 Ending Execution with llvm_shutdown()</li><li>7.2 Lazy Initialization with ManagedStatic</li><li>7.3 Achieving Isolation with LLVMContext</li><li>7.4 Threads and the JIT</li></ul> </li><li>8 Advanced Topics 
  <ul><li>8.1 The ValueSymbolTable class</li><li>8.2 The User and owned Use classes’ memory layout 
    <ul><li>8.2.1 Interaction and relationship between User and Use objects</li></ul> </li><li>8.3 Designing Type Hierarchies and Polymorphic Interfaces</li><li>8.4 ABI Breaking Checks</li></ul> </li><li>9 The Core LLVM Class Hierarchy Reference 
  <ul><li>9.1 The Type class and Derived Types 
    <ul><li>9.1.1 Important Public Methods</li><li>9.1.2 Important Derived Types</li></ul> </li><li>9.2 The Module class 
    <ul><li>9.2.1 Important Public Members of the Module class</li></ul> </li><li>9.3 The Value class 
    <ul><li>9.3.1 Important Public Members of the Value class</li></ul> </li><li>9.4 The User class 
    <ul><li>9.4.1 Important Public Members of the User class</li></ul> </li><li>9.5 The Instruction class 
    <ul><li>9.5.1 Important Subclasses of the Instruction class</li><li>9.5.2 Important Public Members of the Instruction class</li></ul> </li><li>9.6 The Constant class and subclasses 
    <ul><li>9.6.1 Important Subclasses of Constant</li></ul> </li><li>9.7 The GlobalValue class 
    <ul><li>9.7.1 Important Public Members of the GlobalValue class</li></ul> </li><li>9.8 The Function class 
    <ul><li>9.8.1 Important Public Members of the Function</li></ul> </li><li>9.9 The GlobalVariable class 
    <ul><li>9.9.1 Important Public Members of the GlobalVariable class</li></ul> </li><li>9.10 The BasicBlock class 
    <ul><li>9.10.1 Important Public Members of the BasicBlock class</li></ul> </li><li>9.11 The Argument class</li></ul> </li></ul> 
<h2><a id="1__152"></a>1 介绍</h2> 
<p>重点介绍LLVM基线源码中一些重要的类和接口, 这个用户手册没有解释LLVM是什么怎么工作这些, 我们假设您对LLVM已经有了基本的了解, 并有兴趣去写一个转换 pass 或分析修改源码.</p> 
<p>这个文档将引导你找到自己的方式去适应不断增长的LLVM源代码, 读这个文档不代表可以不读源码, 以源码为准. 在 llvm 的 <a href="https://llvm.org/doxygen/" rel="nofollow">doxygen</a> 页面中你能更快找到与设想不一致时的答案.</p> 
<p>第一部分描述了工作中通用有用信息, 第二部分描述了LLVM 核心的类. 未来这个用户手册准备扩展描述怎么使用扩展的库(如dominator), CFG 遍历例程, 和一些有用的通用组件如 InstVisitor(<a href="https://llvm.org/doxygen/InstVisitor_8h_source.html" rel="nofollow">doxygen</a>) 模板</p> 
<h2><a id="2__160"></a>2 一般信息</h2> 
<p>这个部分包含了当你在LLVM工作时通用的非常有用的信息, 但不是针对特定场景的API.</p> 
<h3><a id="21_C__164"></a>2.1 C++ 标准模板库</h3> 
<p>LLVM 源码中大量使用了 C++ 标准模板库(STL), 所以你可能需要了解一些技术与库背景, 这里有一些非常好的讨论 STL 的文章和书籍</p> 
<ul><li><a href="http://en.cppreference.com/w/" rel="nofollow">cppreference.com</a></li><li><a href="http://www.tempest-sw.com/cpp/" rel="nofollow">C++ In a Nutshell</a></li><li><a href="http://www.sgi.com/tech/stl/stl_introduction.html" rel="nofollow">C++ Frequently Asked Questions</a></li><li><a href="http://www.sgi.com/tech/stl/" rel="nofollow">SGI’s STL Programmer’s Guide</a>, 包含了一些有用的 <a href="" rel="nofollow">STL 介绍</a></li><li><a href="http://www.stroustrup.com/C++.html" rel="nofollow">Bjarne Stroustrup’s C++ Page</a></li><li><a href="http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html" rel="nofollow">Bruce Eckel’s Thinking in C++, 2nd ed. Volume 2 Revision 4.0 (even better, get the book).</a></li><li><a href="http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html" rel="nofollow">跨平台使用静态和共享库</a></li></ul> 
<h2><a id="3__LLVM_API_177"></a>3 重要与实用的 LLVM API</h2> 
<p>介绍几个常用的.</p> 
<h3><a id="31_isa_cast__dyn_cast__180"></a>3.1 <code>isa&lt;&gt;</code>, <code>cast&lt;&gt;</code> , <code>dyn_cast&lt;&gt;</code> 模板</h3> 
<p>LLVM源代码库广泛使用一种自定义的RTTI形式. 这些模板与C++的dynamic_cast&lt;&gt;运算符有许多相似之处, 但它们没有一些缺点(主要源于dynamic_cast&lt;&gt;只适用于具有虚函数表的类). 由于它们经常被使用, 你必须了解它们的功能和工作原理. 所有这些模板都在 <a href="https://llvm.org/doxygen/Casting_8h_source.html" rel="nofollow">llvm/Support/Casting.h</a> 文件中定义(注意你很少直接包含这个文件).</p> 
<ul><li><code>isa&lt;&gt;</code> 
  <ul><li>非常类似 java 的 instanceof, 返回值 true/false 取决于引用或指针是否指向一个已经实例化的类, 下面有例子</li></ul> </li><li><code>cast&lt;&gt;</code> 
  <ul><li>是一个带检查的操作, 把基类转换为派生类, 如果对象不是一个实例会产生一个断言, 你最好在确认转换能够成功的情况下使用, 下面是一个例子：</li></ul> <pre><code class="prism language-cpp"><span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">isLoopInvariant</span><span class="token punctuation">(</span><span class="token keyword">const</span> Value <span class="token operator">*</span>V<span class="token punctuation">,</span> <span class="token keyword">const</span> Loop <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">isa</span><span class="token generic class-name"><span class="token operator">&lt;</span>Constant<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token generic-function"><span class="token function">isa</span><span class="token generic class-name"><span class="token operator">&lt;</span>Argument<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token generic-function"><span class="token function">isa</span><span class="token generic class-name"><span class="token operator">&lt;</span>GlobalValue<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

  <span class="token comment">// Otherwise, it must be an instruction...</span>
  <span class="token keyword">return</span> <span class="token operator">!</span>L<span class="token operator">-&gt;</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Instruction<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <ul><li>注：isa和cast最好别结合使用, 可用 dyn_cast 代替</li></ul> </li><li><code>dyn_cast&lt;&gt;</code> 
  <ul><li>是一个带检查的操作, 它检查操作数是否为指定类型, 如果是, 返回指针(不能转换引用), 如果不是则返回空指针, 所以非常像 C++ 的 <code>dynamic_cast&lt;&gt;</code>, 通常用在一些if语句或控制流语句.</li></ul> <pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">*</span>AI <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dyn_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>AllocationInst<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 注意这个可以被滥用, 比起用一大推 if/then/else, 使用 InstVisitor 类直接调度指令类型会更简洁、更高效</li><li><code>isa_and_nonnull&lt;&gt;</code> 
  <ul><li>与 isa&lt;&gt; 很像, 不过它允许参数为空指针(返回false), 允许你把很多空指针检查语句和并成一条</li></ul> </li><li><code>cast_or_null&lt;&gt;</code> 
  <ul><li>类似 cast&lt;&gt;, 不过它允许参数为空指针(空指针传递), 允许你把很多空指针检查语句和并成一条</li></ul> </li><li><code>dyn_cast_or_null&lt;&gt;</code> 
  <ul><li>类似 dyn_cast&lt;&gt;, 不过它允许参数为空指针(空指针传递), 允许你把很多空指针检查语句和并成一条</li></ul> </li></ul> 
<p>这五个模板可以用于任何类, 他们是否有 v 表, 如果要添加对这些模板的支持, 请参阅文档 <a href="https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html" rel="nofollow">How to set up LLVM-style RTTI for your class hierarchy</a></p> 
<h3><a id="32_stringRef_and_Twine_214"></a>3.2 stringRef and Twine</h3> 
<p>虽然LLVM通常不进行太多的字符串操作, 但我们确实有几个重要的API需要使用字符串. 两个重要的例子是Value类(用于指令、函数等的名称)和StringMap类, 在LLVM和Clang中广泛使用.</p> 
<p>这些都是通用类, 它们需要能够接受 <code>可能包含嵌入的空字符的字符串</code>. 因此, 它们不能简单地接受const char *, 而使用const std::string&amp;则要求客户端执行通常是不必要的 <code>堆分配</code>. 相反, 许多LLVM API使用 <code>StringRef</code> 或 <code>const Twine&amp;</code> 来高效传递字符串.</p> 
<h4><a id="321_StringRef_219"></a>3.2.1 StringRef</h4> 
<p>StringRef 是一种表示对 <code>常量字符串的引用</code> 的数据类型(包括字符数组和长度), 它支持 <code>std::string</code> 上可用的常见操作, 但不需要堆分配.</p> 
<p>可以使用C风格的以空字符结尾的字符串、std::string 隐式构造它, 也可以显式使用字符指针和长度构造. 例如, StringMap的find函数声明如下：</p> 
<pre><code class="prism language-cpp">iterator <span class="token function">find</span><span class="token punctuation">(</span>StringRef Key<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>客户端可以使用以下任一方式调用它：</p> 
<pre><code class="prism language-cpp">Map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查找"foo"</span>
Map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查找"bar"</span>
Map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">StringRef</span><span class="token punctuation">(</span><span class="token string">"\0baz"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查找"\0baz"</span>
</code></pre> 
<p>类似地, 需要返回字符串的API可能会返回一个StringRef实例, 可以直接使用它或使用 <code>str</code> 成员函数将其转换为<code>std::string</code>. 有关更多信息, 请参阅 <a href="https://llvm.org/doxygen/StringRef_8h_source.html" rel="nofollow">llvm/ADT/StringRef.h</a></p> 
<p>你应该很少直接使用 StringRef 类, 因为它包含对外部内存的指针, 通常不安全存储类的实例(除非你知道外部存储不会被释放). 在LLVM中, StringRef 足够小且广泛使用, 因此应始终 <code>按值传递</code>.</p> 
<p>个人理解, 可以使用 StringRef 代替 <code>const char *</code></p> 
<h4><a id="322_Twine_237"></a>3.2.2 Twine</h4> 
<p><a href="https://llvm.org/doxygen/classllvm_1_1Twine.html" rel="nofollow">Twine</a> 类是API接受连接字符串的高效方式. 例如, LLVM中常见的范例是根据另一个指令的名称给一个指令命名, 并添加后缀, 例如：</p> 
<pre><code class="prism language-cpp">New <span class="token operator">=</span> <span class="token class-name">CmpInst</span><span class="token double-colon punctuation">::</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> SO<span class="token operator">-&gt;</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".cmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>Twine类实际上是一个轻量级的绳子, 它指向临时(栈分配的)对象. Twine可以通过字符串之间的加法运算符(即C字符串、std::string或StringRef)隐式构造. Twine <code>推迟了实际字符串连接的操作</code>, 直到真正需要时, 才能将其高效地直接渲染到字符数组中. 这避免了在构造字符串连接的临时结果时涉及的不必要的堆分配. 请参阅 <a href="https://llvm.org/doxygen/Twine_8h_source.html" rel="nofollow">llvm/ADT/Twine.h</a> 和此处以获取更多信息.</p> 
<h3><a id="33_formatv__244"></a>3.3 formatv 格式化字符串</h3> 
<p>尽管LLVM不一定会进行大量的字符串操作和解析, 但它确实会进行大量的字符串格式化. 从诊断消息到 llvm 工具的输出(如llvm-readobj), 再到打印详细的反汇编列表和 LLDB 运行时日志, 字符串格式化的需求无处不在.</p> 
<p>formatv 在精神上类似于 printf, 但使用了不同的语法, 借鉴了Python和 C＃ 的许多特性. 与 printf 不同, 它在编译时推断要格式化的类型, 因此不需要像 <code>％d</code> 这样的格式说明符. 这降低了尝试构建可移植格式字符串的心理负担, 特别是对于像 <code>size_t</code> 或指针类型这样的平台特定类型. 与 <code>printf</code> 和 <code>Python</code> 都不同的是, 如果 LLVM 不知道如何格式化该类型, 它还会导致编译失败. 这两个特性确保该函数比传统的格式化方法(如 printf 系列函数)更安全、更简单易用.</p> 
<h4><a id="331__249"></a>3.3.1 简单格式化</h4> 
<p>调用 formatv 函数涉及一个格式字符串, 其中包含0个或多个替换序列, 后跟一个可变长度的替换值列表. 替换序列的格式为 <code>{N[[,align]:style]}</code>.</p> 
<p>N 表示替换值列表中参数的基于0的索引. 请注意, 这意味着可以以任意顺序多次引用相同的参数, 可能带有不同的样式和/或对齐选项.</p> 
<p>align是一个可选的字符串, 用于指定要将值格式化到的字段的宽度以及值在字段中的对齐方式. 它由一个可选的对齐样式后跟一个正整数字段宽度组成. 对齐样式可以是字符 <code>-</code>(左对齐)、<code>=</code>(居中对齐)或<code>+</code>(右对齐). 默认值为右对齐.</p> 
<p>style 是一个可选的字符串, 由特定于类型的字符组成, 用于控制值的格式化方式. 例如, 要将浮点值格式化为百分比, 可以使用样式选项 <code>P</code>.</p> 
<h4><a id="332__258"></a>3.3.2 自定义格式</h4> 
<p>有两种方法可以自定义类型的格式化行为.</p> 
<ul><li>一种方法是为您的类型 T 提供 <code>llvm::format_provider&lt;T&gt;</code> 的模板特化, 其中包含适当的静态 <code>format</code> 方法</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> llvm <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
  <span class="token keyword">struct</span> <span class="token class-name">format_provider</span><span class="token operator">&lt;</span>MyFooBar<span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyFooBar <span class="token operator">&amp;</span>V<span class="token punctuation">,</span> raw_ostream <span class="token operator">&amp;</span>Stream<span class="token punctuation">,</span> StringRef Style<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// Do whatever is necessary to format `V` into `Stream`</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    MyFooBar X<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0}"</span><span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这是一种有用的扩展机制, 用于为您自定义的类型添加支持, 并使用自定义的样式选项进行格式化. 但是, 当您想要扩展库已经知道如何格式化的类型的机制时, 它并不能帮助您. 为此, 我们需要其他的方法.</p> 
<ul><li>2、提供 format adapter, 从 llvm::FormatAdapter&lt;T&gt; 继承</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> anything <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">struct</span> <span class="token class-name">format_int_custom</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> llvm<span class="token double-colon punctuation">::</span><span class="token class-name">FormatAdapter</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">explicit</span> <span class="token function">format_int_custom</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token operator">:</span> llvm<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">FormatAdapter</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">format</span><span class="token punctuation">(</span>llvm<span class="token double-colon punctuation">::</span>raw_ostream <span class="token operator">&amp;</span>Stream<span class="token punctuation">,</span> StringRef Style<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// Do whatever is necessary to format ``this-&gt;Item`` into ``Stream``</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">namespace</span> llvm <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>string S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0}"</span><span class="token punctuation">,</span> anything<span class="token double-colon punctuation">::</span><span class="token function">format_int_custom</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果检测到该类型是从 FormatAdapter 派生出来的, formatv 将调用该参数上的 format 方法, 并传入指定的样式. 这允许您提供任何类型的自定义格式化, 包括那些已经具有内置格式化提供程序的类型.</p> 
<h4><a id="333_formatv_Examples_295"></a>3.3.3 formatv Examples</h4> 
<p>以下是一组不完整的示例, 演示了 formatv 的用法. 要获取更多信息, 可以阅读 doxygen 文档或查看单元测试套件.</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>string S<span class="token punctuation">;</span>
<span class="token comment">// Simple formatting of basic types and implicit string conversion.</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0} ({1:P})"</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">0.35</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// S == "7 (35.00%)"</span>

<span class="token comment">// Out-of-order referencing and multi-referencing</span>
<span class="token function">outs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0} {2} {1} {0}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints "1 3 test 1"</span>

<span class="token comment">// Left, right, and center alignment</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0,7}"</span><span class="token punctuation">,</span>  <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// S == "      a";</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0,-7}"</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// S == "a      ";</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0,=7}"</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// S == "   a   ";</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0,+7}"</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// S == "      a";</span>

<span class="token comment">// Custom styles</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0:N} - {0:x} - {1:E}"</span><span class="token punctuation">,</span> <span class="token number">12345</span><span class="token punctuation">,</span> <span class="token number">123908342</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// S == "12,345 - 0x3039 - 1.24E8"</span>

<span class="token comment">// Adapters</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0}"</span><span class="token punctuation">,</span> <span class="token function">fmt_align</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> AlignStyle<span class="token double-colon punctuation">::</span>Center<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// S == "  42   "</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0}"</span><span class="token punctuation">,</span> <span class="token function">fmt_repeat</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// S == "hihihi"</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0}"</span><span class="token punctuation">,</span> <span class="token function">fmt_pad</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// S == "  hi      "</span>

<span class="token comment">// Ranges</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> V <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0}"</span><span class="token punctuation">,</span> <span class="token function">make_range</span><span class="token punctuation">(</span>V<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> V<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// S == "8, 9, 10"</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0:$[+]}"</span><span class="token punctuation">,</span> <span class="token function">make_range</span><span class="token punctuation">(</span>V<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> V<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// S == "8+9+10"</span>
S <span class="token operator">=</span> <span class="token function">formatv</span><span class="token punctuation">(</span><span class="token string">"{0:$[ + ]@[x]}"</span><span class="token punctuation">,</span> <span class="token function">make_range</span><span class="token punctuation">(</span>V<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> V<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// S == "0x8 + 0x9 + 0xA"</span>
</code></pre> 
<h3><a id="34__326"></a>3.4 错误处理</h3> 
<p>正确的错误处理帮助我们识别代码中的错误, 并帮助最终用户理解他们在使用工具时发生的错误. 错误可以分为两个广泛的类别：<code>程序错误</code> 和 <code>可恢复错误</code>, 对于处理和报告这两种错误需要采用不同的策略.</p> 
<h4><a id="341__329"></a>3.4.1 程序错误</h4> 
<p>程序错误是程序不变式或API约定的违反, 代表着程序本身的错误. 我们的目标是记录不变式, 并在运行时不变式被破坏时, 快速中止程序并提供一些基本的诊断信息.</p> 
<p>处理程序错误的基本工具是断言(<code>assertions</code>)和 <code>llvm_unreachable</code>函数. 断言用于表达不变式条件, 并应包含描述不变式的消息：</p> 
<pre><code class="prism language-cpp"><span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">isPhysReg</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token string">"All virt regs should have been allocated already."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>llvm_unreachable 函数可用于记录控制流中永远不应进入的区域, 前提是程序的不变式保持不变：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span> Foo<span class="token punctuation">,</span> Bar<span class="token punctuation">,</span> Baz <span class="token punctuation">}</span> X <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">switch</span> <span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">case</span> Foo<span class="token operator">:</span> <span class="token comment">/* 处理 Foo */</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> Bar<span class="token operator">:</span> <span class="token comment">/* 处理 Bar */</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
    <span class="token function">llvm_unreachable</span><span class="token punctuation">(</span><span class="token string">"X should be Foo or Bar here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="342__347"></a>3.4.2 可恢复错误</h4> 
<p>可恢复错误代表程序 <code>环境中的错误</code>, 例如资源故障(缺少文件、网络连接中断等)或格式错误的输入. 应该检测这些错误并将其传递到能够适当处理的程序级别. 处理错误可能只是向用户报告问题, 也可能涉及尝试恢复的操作.</p> 
<p>注意：</p> 
<blockquote> 
 <p>尽管在整个 LLVM 中使用这种错误处理方案是理想的, 但有些地方并不适用. 在绝对必须发出非程序错误且 Error 模型不可行的情况下, 可以调用report_fatal_error, 该函数将调用安装的错误处理程序, 打印消息并终止程序. 在这种情况下, 不建议使用 report_fatal_error.</p> 
</blockquote> 
<p>可恢复错误使用 LLVM 的 Error 方案进行建模. 该方案使用函数返回值表示错误, 类似于经典的C整数错误码或 C++ 的 std::error_code. 但是, Error 类实际上是对用户定义的错误类型的轻量级包装器, 允许附加任意信息来描述错误. 这类似于C++ 异常允许抛出用户定义类型的方式.</p> 
<p>通过调用 <code>Error::success()</code> 可以创建成功的返回值, 例如：</p> 
<pre><code class="prism language-cpp">Error <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// Do something.</span>
  <span class="token comment">// Return success.</span>
  <span class="token keyword">return</span> <span class="token class-name">Error</span><span class="token double-colon punctuation">::</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>成功值的构造和返回非常廉价, 对程序性能几乎没有影响.</p> 
<p>失败值使用 <code>make_error&lt;T&gt;</code> 构造, 其中 T 是从 ErrorInfo 实用程序继承的任何类, 例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">BadFileFormat</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">ErrorInfo</span><span class="token operator">&lt;</span><span class="token class-name">BadFileFormat</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> <span class="token keyword">char</span> ID<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string Path<span class="token punctuation">;</span>

  <span class="token function">BadFileFormat</span><span class="token punctuation">(</span>StringRef Path<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Path</span><span class="token punctuation">(</span>Path<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>raw_ostream <span class="token operator">&amp;</span>OS<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">{<!-- --></span>
    OS <span class="token operator">&lt;&lt;</span> Path <span class="token operator">&lt;&lt;</span> <span class="token string">" is malformed"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  std<span class="token double-colon punctuation">::</span>error_code <span class="token function">convertToErrorCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">make_error_code</span><span class="token punctuation">(</span>object_error<span class="token double-colon punctuation">::</span>parse_failed<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> BadFileFormat<span class="token double-colon punctuation">::</span>ID<span class="token punctuation">;</span> <span class="token comment">// This should be declared in the C++ file.</span>

Error <span class="token function">printFormattedFile</span><span class="token punctuation">(</span>StringRef Path<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>check <span class="token keyword">for</span> valid format<span class="token operator">&gt;</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">make_error</span><span class="token generic class-name"><span class="token operator">&lt;</span>BadFileFormat<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Path<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// print file contents.</span>
  <span class="token keyword">return</span> <span class="token class-name">Error</span><span class="token double-colon punctuation">::</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Error值可以隐式转换为bool类型：错误为true, 成功为false, 从而实现以下惯用法：</p> 
<pre><code class="prism language-cpp">Error <span class="token function">mayFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Error <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Err <span class="token operator">=</span> <span class="token function">mayFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> Err<span class="token punctuation">;</span>
  <span class="token comment">// Success! We can proceed.</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>对于可能失败但需要返回值的函数, 可以使用 <code>Expected&lt;T&gt;</code> 工具. 此类型的值可以使用 T 或 Error 构造. <code>Expected&lt;T&gt;</code> 值也可以隐式转换为布尔值, 但与Error 的约定相反：成功为 true, 错误为 false. 如果成功, <code>可以通过解引用运算符访问 T 值</code>. 如果失败, 可以使用 <code>takeError()</code> 方法提取 Error 值. 典型的用法如下：</p> 
<pre><code class="prism language-cpp">Expected<span class="token operator">&lt;</span>FormattedFile<span class="token operator">&gt;</span> <span class="token function">openFormattedFile</span><span class="token punctuation">(</span>StringRef Path<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// If badly formatted, return an error.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Err <span class="token operator">=</span> <span class="token function">checkFormat</span><span class="token punctuation">(</span>Path<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>Err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Otherwise return a FormattedFile instance.</span>
  <span class="token keyword">return</span> <span class="token function">FormattedFile</span><span class="token punctuation">(</span>Path<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Error <span class="token function">processFormattedFile</span><span class="token punctuation">(</span>StringRef Path<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// Try to open a formatted file</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> FileOrErr <span class="token operator">=</span> <span class="token function">openFormattedFile</span><span class="token punctuation">(</span>Path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// On success, grab a reference to the file and continue.</span>
    <span class="token keyword">auto</span> <span class="token operator">&amp;</span>File <span class="token operator">=</span> <span class="token operator">*</span>FileOrErr<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span>
    <span class="token comment">// On error, extract the Error value and return it.</span>
    <span class="token keyword">return</span> FileOrErr<span class="token punctuation">.</span><span class="token function">takeError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果 <code>Expected&lt;T&gt;</code> 的值处于成功模式, 那么 takeError() 方法将返回一个成功值. 利用这一点, 上述函数可以改写为：</p> 
<pre><code class="prism language-cpp">Error <span class="token function">processFormattedFile</span><span class="token punctuation">(</span>StringRef Path<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// Try to open a formatted file</span>
  <span class="token keyword">auto</span> FileOrErr <span class="token operator">=</span> <span class="token function">openFormattedFile</span><span class="token punctuation">(</span>Path<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Err <span class="token operator">=</span> FileOrErr<span class="token punctuation">.</span><span class="token function">takeError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// On error, extract the Error value and return it.</span>
    <span class="token keyword">return</span> Err<span class="token punctuation">;</span>
  <span class="token comment">// On success, grab a reference to the file and continue.</span>
  <span class="token keyword">auto</span> <span class="token operator">&amp;</span>File <span class="token operator">=</span> <span class="token operator">*</span>FileOrErr<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果 <code>Expected&lt;T&gt;</code> 的值将被移动到现有变量中, 那么 <code>moveInto()</code> 方法可以避免命名额外的变量. 这对于使 <code>Expected&lt;T&gt;</code> 值具有类似指针的语义的 <code>operator-&gt;()</code> 非常有用. 例如：</p> 
<pre><code class="prism language-cpp">Expected<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>MemoryBuffer<span class="token operator">&gt;&gt;</span> <span class="token function">openBuffer</span><span class="token punctuation">(</span>StringRef Path<span class="token punctuation">)</span><span class="token punctuation">;</span>
Error <span class="token function">processBuffer</span><span class="token punctuation">(</span>StringRef Buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

Error <span class="token function">processBufferAtPath</span><span class="token punctuation">(</span>StringRef Path<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// Try to open a buffer.</span>
  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>MemoryBuffer<span class="token operator">&gt;</span> MB<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Err <span class="token operator">=</span> <span class="token function">openBuffer</span><span class="token punctuation">(</span>Path<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">moveInto</span><span class="token punctuation">(</span>MB<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// On error, return the Error value.</span>
    <span class="token keyword">return</span> Err<span class="token punctuation">;</span>
  <span class="token comment">// On success, use MB.</span>
  <span class="token keyword">return</span> <span class="token function">processBuffer</span><span class="token punctuation">(</span>MB<span class="token operator">-&gt;</span><span class="token function">getBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这种第三种形式适用于任何可以从 <code>T&amp;&amp;</code> 进行赋值的类型. 如果需要将 <code>Expected&lt;T&gt;</code> 值存储在已经声明的 <code>Optional&lt;T&gt;</code> 中, 这将非常有用. 例如：</p> 
<pre><code class="prism language-cpp">Expected<span class="token operator">&lt;</span>StringRef<span class="token operator">&gt;</span> <span class="token function">extractClassName</span><span class="token punctuation">(</span>StringRef Definition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ClassData</span> <span class="token punctuation">{<!-- --></span>
  StringRef Definition<span class="token punctuation">;</span>
  Optional<span class="token operator">&lt;</span>StringRef<span class="token operator">&gt;</span> LazyName<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  Error <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Err <span class="token operator">=</span> <span class="token function">extractClassName</span><span class="token punctuation">(</span>Path<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">moveInto</span><span class="token punctuation">(</span>LazyName<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// On error, return the Error value.</span>
      <span class="token keyword">return</span> Err<span class="token punctuation">;</span>
    <span class="token comment">// On success, LazyName has been initialized.</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>所有的 Error 实例, 无论是成功还是失败, 必须在它们被销毁之前进行检查或移动(通过 <code>std::move</code> 或返回). 如果意外丢弃了未经检查的错误, 将会导致程序在未经检查的值的析构函数运行的位置中中止, 从而容易发现和修复违反这个规则的问题.</p> 
<p>成功值被认为是已经检查过的, 一旦它们经过了测试(通过调用布尔转换运算符)：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Err <span class="token operator">=</span> <span class="token function">mayFail</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> Err<span class="token punctuation">;</span> <span class="token comment">// Failure value - move error to caller.</span>

<span class="token comment">// Safe to continue: Err was checked.</span>
</code></pre> 
<p><code>作者注： Excepted&lt;&gt; 类的声明加了 [[nodiscard]] 属性, 帮助做到了上述一点</code></p> 
<p>相反, 以下代码将始终导致中止, 即使mayFail返回一个成功值：</p> 
<pre><code class="prism language-cpp"><span class="token function">mayFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Program will always abort here, even if mayFail() returns Success, since</span>
<span class="token comment">// the value is not checked.</span>
</code></pre> 
<p>一旦激活了错误类型的处理程序, 失败值被视为已经被检查：</p> 
<pre><code class="prism language-cpp"><span class="token function">handleErrors</span><span class="token punctuation">(</span>
  <span class="token function">processFormattedFile</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> BadFileFormat <span class="token operator">&amp;</span>BFF<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">report</span><span class="token punctuation">(</span><span class="token string">"Unable to process "</span> <span class="token operator">+</span> BFF<span class="token punctuation">.</span>Path <span class="token operator">+</span> <span class="token string">": bad format"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> FileNotFound <span class="token operator">&amp;</span>FNF<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">report</span><span class="token punctuation">(</span><span class="token string">"File not found "</span> <span class="token operator">+</span> FNF<span class="token punctuation">.</span>Path<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>handleErrors</code> 函数以错误作为其第一个参数, 后面跟着一个可变参数的“处理程序”列表, 其中每个处理程序必须是一个可调用类型(函数、lambda表达式或具有调用运算符的类), 并且只有一个参数. handleErrors 函数将按顺序访问每个处理程序, 并将其参数类型与错误的动态类型进行比较, 运行与之匹配的第一个处理程序. 这与决定运行哪个 catch 子句来处理 C++ 异常的决策过程相同.</p> 
<p>由于传递给 handleErrors 的处理程序列表可能无法涵盖可能发生的每种错误类型, handleErrors 函数还返回一个必须检查或传播的错误值. 如果传递给handleErrors 的错误值与任何处理程序都不匹配, 则它将从 handleErrors 中返回. 因此, 使用 handleErrors 的惯用方式如下所示：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Err <span class="token operator">=</span>
      <span class="token function">handleErrors</span><span class="token punctuation">(</span>
        <span class="token function">processFormattedFile</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> BadFileFormat <span class="token operator">&amp;</span>BFF<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">report</span><span class="token punctuation">(</span><span class="token string">"Unable to process "</span> <span class="token operator">+</span> BFF<span class="token punctuation">.</span>Path <span class="token operator">+</span> <span class="token string">": bad format"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> FileNotFound <span class="token operator">&amp;</span>FNF<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">report</span><span class="token punctuation">(</span><span class="token string">"File not found "</span> <span class="token operator">+</span> FNF<span class="token punctuation">.</span>Path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> Err<span class="token punctuation">;</span>
</code></pre> 
<p>在确切知道处理程序列表是穷尽的情况下, 可以使用 handleAllErrors 函数. 它与handleErrors 函数相同, 只是如果传递了一个未处理的错误, 它将终止程序, 并且因此可以返回 void 类型. 通常应避免使用 handleAllErrors 函数：在程序的其他位置引入新的错误类型可能会将以前穷尽的错误列表转变为非穷尽的列表, 从而导致意外的程序终止. 在可能的情况下, 应使用 handleErrors 函数 <code>将未知错误向上传播到堆栈</code>.</p> 
<p>对于工具代码, 错误可以通过打印错误消息然后以错误代码退出来处理, ExitOnError 实用程序可能比 handleErrors 更合适, 因为它简化了调用可能出错的函数时的控制流程.</p> 
<p>在已知特定调用到一个可能出错的函数将始终成功的情况下(例如, 调用一个只在一部分输入上可能失败的函数, 并且输入已知是安全的情况), 可以使用 <code>cantFail</code> 函数来移除错误类型, 简化控制流程.</p> 
<h5><a id="3421_StringError_516"></a>3.4.2.1 StringError</h5> 
<p>许多种类的错误没有恢复策略, 唯一可以采取的操作是将其报告给用户, 以便用户可以尝试修复环境. 在这种情况下, 将错误表示为字符串是非常合理的. LLVM提供了 <code>StringError</code> 类来实现这个目的. 它接受两个参数：一个 <code>字符串错误消息</code> 和一个等效的 <code>std::error_code</code> 以便进行互操作. 它还提供了 <code>createStringError</code> 函数以简化对该类的常见使用方式：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// These two lines of code are equivalent:</span>
<span class="token generic-function"><span class="token function">make_error</span><span class="token generic class-name"><span class="token operator">&lt;</span>StringError<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Bad executable"</span><span class="token punctuation">,</span> errc<span class="token double-colon punctuation">::</span>executable_format_error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">createStringError</span><span class="token punctuation">(</span>errc<span class="token double-colon punctuation">::</span>executable_format_error<span class="token punctuation">,</span> <span class="token string">"Bad executable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果您确信您构建的错误永远不需要转换为 <code>std::error_code</code>, 可以使用 <code>inconvertibleErrorCode()</code> 函数：</p> 
<pre><code class="prism language-cpp"><span class="token function">createStringError</span><span class="token punctuation">(</span><span class="token function">inconvertibleErrorCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Bad executable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在仔细考虑后才应该这样做. 如果尝试将此错误转换为 <code>std::error_code</code>, 则会立即终止程序. 除非您确定您的错误不需要互操作性, 否则应寻找可转换的现有 <code>std::error_code</code>, 甚至(尽管非常痛苦)考虑引入一个新的 <code>std::error_code</code> 作为权宜之计.</p> 
<p>createStringError 函数可以接受 printf 样式的格式说明符, 以提供格式化的消息：</p> 
<pre><code class="prism language-cpp"><span class="token function">createStringError</span><span class="token punctuation">(</span>errc<span class="token double-colon punctuation">::</span>executable_format_error<span class="token punctuation">,</span>
                  <span class="token string">"Bad executable: %s"</span><span class="token punctuation">,</span> FileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="3422_stderror_code__ErrorOr__535"></a>3.4.2.2 std::error_code 和 ErrorOr 的互操作性</h5> 
<p>许多现有的LLVM API使用 std::error_code 及其伙伴 <code>ErrorOr&lt;T&gt;</code>(与 <code>Expected&lt;T&gt;</code> 扮演相同角色, 但包装的是 <code>std::error_code</code> 而不是 <code>Error</code>). 错误类型的传染性意味着将其中一个函数更改为返回 <code>Error</code> 或 <code>Expected&lt;T&gt;</code> 通常会导致对调用者、调用者的调用者等的一系列更改. (首次尝试返回 <code>Error</code> 的 <code>MachOObjectFile</code> 构造函数在差异达到 3000 行后被放弃, 影响到数个库, 并且仍在继续增长).</p> 
<p>为了解决这个问题, 引入了 <code>Error/std::error_code</code> 互操作性需求. 有两对函数允许将任何 <code>Error</code> 值转换为 <code>std::error_code</code>, 将任何 <code>Expected&lt;T&gt;</code> 转换为 <code>ErrorOr&lt;T&gt;</code>, 并且反之亦然：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>error_code <span class="token function">errorToErrorCode</span><span class="token punctuation">(</span>Error Err<span class="token punctuation">)</span><span class="token punctuation">;</span>
Error <span class="token function">errorCodeToError</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>error_code EC<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> ErrorOr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">expectedToErrorOr</span><span class="token punctuation">(</span>Expected<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> TOrErr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> Expected<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">errorOrToExpected</span><span class="token punctuation">(</span>ErrorOr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> TOrEC<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>使用这些 API, 可以轻松地进行手术式修补, 将单个函数从 <code>std::error_code</code> 更新为 <code>Error</code>, 并将 <code>ErrorOr&lt;T&gt;</code> 更新为 <code>Expected&lt;T&gt;</code></p> 
<h5><a id="3423__547"></a>3.4.2.3 从错误处理程序返回错误</h5> 
<p>错误恢复尝试本身可能会失败. 因此, handleErrors 实际上识别了三种不同形式的处理程序签名：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 必须处理错误, 不会产生新的错误：</span>
<span class="token keyword">void</span><span class="token punctuation">(</span>UserDefinedError <span class="token operator">&amp;</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 必须处理错误, 可以产生新的错误：</span>
<span class="token function">Error</span><span class="token punctuation">(</span>UserDefinedError <span class="token operator">&amp;</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 可以检查原始错误, 然后重新封装并返回(或可以产生新的错误)：</span>
<span class="token function">Error</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>UserDefinedError<span class="token operator">&gt;</span> E<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>从处理程序返回的任何错误都将从 <code>handleErrors</code> 函数返回, 以便可以对其进行处理, 或者向上传播到调用栈.</p> 
<h5><a id="3424__ExitOnError__561"></a>3.4.2.4 使用 ExitOnError 简化工具代码</h5> 
<p>库代码永远不应调用 exit 来处理可恢复的错误, 但在工具代码中(特别是命令行工具)这可能是一个合理的方法. 在遇到错误时调用exit可以显著简化控制流程, 因为错误不再需要向上传播到调用栈. 这使得代码可以以直线的方式编写, 只要每个可能失败的调用都被包装在检查和调用exit的语句中. ExitOnError 类支持这种模式, 通过提供调用运算符来检查 Error 值, 在成功情况下去除错误并在失败情况下记录到 stderr 然后退出.</p> 
<p>要使用这个类, 在程序中声明一个全局的 <code>ExitOnError</code> 变量：</p> 
<pre><code class="prism language-cpp">ExitOnError ExitOnErr<span class="token punctuation">;</span>
</code></pre> 
<p>然后, 对可能失败的函数的调用可以用ExitOnErr来包装, 将它们转换为非失败的调用：</p> 
<pre><code class="prism language-cpp">Error <span class="token function">mayFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Expected<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">mayFail2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">ExitOnErr</span><span class="token punctuation">(</span><span class="token function">mayFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> X <span class="token operator">=</span> <span class="token function">ExitOnErr</span><span class="token punctuation">(</span><span class="token function">mayFail2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在失败的情况下, 错误的日志消息将被写入 stderr, 可以通过调用 setBanner方法来设置一个可选的字符串“banner”作为前缀. 还可以使用 <code>setExitCodeMapper</code> 方法提供从 Error 值到退出码的映射：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
ExitOnErr<span class="token punctuation">.</span><span class="token function">setBanner</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" error:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ExitOnErr<span class="token punctuation">.</span><span class="token function">setExitCodeMapper</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> Error <span class="token operator">&amp;</span>Err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Err<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">isA</span><span class="token generic class-name"><span class="token operator">&lt;</span>BadFileFormat<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在工具代码中尽可能使用 ExitOnError, 它可以极大地提高可读性.</p> 
<h5><a id="3425__cantFail__591"></a>3.4.2.5 使用 cantFail 简化安全调用点</h5> 
<p>有些函数只会在它们的输入的某些子集上失败, 因此对于使用已知安全输入的调用可以假定其会成功.</p> 
<p>cantFail 函数通过包装断言来封装这一点, 断言其参数是一个成功值, 并且在 <code>Expected&lt;T&gt;</code> 的情况下解开T值：</p> 
<pre><code class="prism language-cpp">Error <span class="token function">onlyFailsForSomeXValues</span><span class="token punctuation">(</span><span class="token keyword">int</span> X<span class="token punctuation">)</span><span class="token punctuation">;</span>
Expected<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">onlyFailsForSomeXValues2</span><span class="token punctuation">(</span><span class="token keyword">int</span> X<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">cantFail</span><span class="token punctuation">(</span><span class="token function">onlyFailsForSomeXValues</span><span class="token punctuation">(</span>KnownSafeValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> Y <span class="token operator">=</span> <span class="token function">cantFail</span><span class="token punctuation">(</span><span class="token function">onlyFailsForSomeXValues2</span><span class="token punctuation">(</span>KnownSafeValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>与 ExitOnError 实用程序类似, cantFail 简化了控制流程. 然而, 它们对错误情况的处理非常不同： ExitOnError 保证在出现错误输入时终止程序, 而 cantFail只是断言结果是成功的. 在调试版本中, 如果遇到错误, 这将导致断言失败. 在发布版本中, 对于失败值, cantFail 的行为是未定义的. 因此, 在使用 cantFail 时必须小心：客户端必须确信使用 cantFail 包装的调用在给定参数下确实不会失败.</p> 
<p>在库代码中, 很少使用 cantFail 函数, 但在 <code>工具代码和单元测试代码</code> 中, 它们可能更有用, 因为输入和/或模拟的类或函数可能被知道是安全的.</p> 
<h5><a id="3426__609"></a>3.4.2.6 可失败的构造函数</h5> 
<p>某些类在构造过程中需要进行资源获取或其他复杂的初始化操作, 这些操作可能会失败. 不幸的是, 构造函数无法返回错误, 而在构造对象后让客户端进行测试以确保其有效性容易出错, 因为很容易忘记进行测试. 为了解决这个问题, 可以使用命名构造函数模式并返回一个 <code>Expected&lt;T&gt;</code>：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>

  <span class="token keyword">static</span> Expected<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> <span class="token function">Create</span><span class="token punctuation">(</span>Resource R1<span class="token punctuation">,</span> Resource R2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Error Err <span class="token operator">=</span> <span class="token class-name">Error</span><span class="token double-colon punctuation">::</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Foo <span class="token function">F</span><span class="token punctuation">(</span>R1<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> Err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Err<span class="token punctuation">)</span>
      <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>Err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>

  <span class="token function">Foo</span><span class="token punctuation">(</span>Resource R1<span class="token punctuation">,</span> Resource R2<span class="token punctuation">,</span> Error <span class="token operator">&amp;</span>Err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ErrorAsOutParameter <span class="token function">EAO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Err2 <span class="token operator">=</span> R1<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      Err <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>Err2<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Err <span class="token operator">=</span> R2<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这里, 命名构造函数将一个 Error 通过引用传递到实际的构造函数中, 构造函数可以使用它来返回错误. ErrorAsOutParameter 实用程序在进入构造函数时将 Error 值的 checked 标志设置为 true , 以便可以对错误进行赋值, 然后在退出时重置为 false, 以强制客户端(即命名构造函数)检查错误.</p> 
<p>通过使用这种模式, 试图构造 Foo 对象的客户端将收到一个良好构造的 Foo 对象或一个 Error 对象, 而不会收到处于无效状态的对象.</p> 
<h5><a id="3427__639"></a>3.4.2.7 基于类型传播和消耗错误</h5> 
<p>在某些情况下, 某些类型的错误被认为是无害的. 例如, 在遍历存档时, 有些客户端可能愿意跳过格式错误的目标文件, 而不是立即终止遍历. 可以使用复杂的处理方法来跳过格式错误的对象, 但是 <code>Error.h</code> 头文件提供了两个实用程序, 使得这种惯用法更加清晰：类型检查方法 <code>isA</code> 和 <code>consumeError</code> 函数：</p> 
<pre><code class="prism language-cpp">Error <span class="token function">walkArchive</span><span class="token punctuation">(</span>Archive A<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> I <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> I <span class="token operator">!=</span> A<span class="token punctuation">.</span><span class="token function">numMembers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>I<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> ChildOrErr <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">getMember</span><span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Err <span class="token operator">=</span> ChildOrErr<span class="token punctuation">.</span><span class="token function">takeError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Err<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">isA</span><span class="token generic class-name"><span class="token operator">&lt;</span>BadFileFormat<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">consumeError</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>Err<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">else</span>
        <span class="token keyword">return</span> Err<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">auto</span> <span class="token operator">&amp;</span>Child <span class="token operator">=</span> <span class="token operator">*</span>ChildOrErr<span class="token punctuation">;</span>
    <span class="token comment">// Use Child</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token class-name">Error</span><span class="token double-colon punctuation">::</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="3428__joinErrors__Errors_658"></a>3.4.2.8 使用 joinErrors 构造 Errors</h5> 
<p>在上面的存档遍历示例中, BadFileFormat 错误只是被消耗和忽略掉了. 如果客户端在完成对存档的遍历后想要报告这些错误, 可以使用 joinErrors 实用程序：</p> 
<pre><code class="prism language-cpp">Error <span class="token function">walkArchive</span><span class="token punctuation">(</span>Archive A<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  Error DeferredErrs <span class="token operator">=</span> <span class="token class-name">Error</span><span class="token double-colon punctuation">::</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> I <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> I <span class="token operator">!=</span> A<span class="token punctuation">.</span><span class="token function">numMembers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>I<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> ChildOrErr <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">getMember</span><span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Err <span class="token operator">=</span> ChildOrErr<span class="token punctuation">.</span><span class="token function">takeError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Err<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">isA</span><span class="token generic class-name"><span class="token operator">&lt;</span>BadFileFormat<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        DeferredErrs <span class="token operator">=</span> <span class="token function">joinErrors</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>DeferredErrs<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>Err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">else</span>
        <span class="token keyword">return</span> Err<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> <span class="token operator">&amp;</span>Child <span class="token operator">=</span> <span class="token operator">*</span>ChildOrErr<span class="token punctuation">;</span>
    <span class="token comment">// Use Child</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> DeferredErrs<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>joinErrors 函数构建了一个特殊的错误类型, 称为 ErrorList , 它保存了一系列用户定义的错误. handleErrors 函数识别到这种类型, 并尝试按顺序处理其中包含的每个错误. 如果所有包含的错误都能够被处理, handleErrors 将返回Error::success(), 否则 handleErrors 将连接剩余的错误, 并返回生成的ErrorList.</p> 
<h5><a id="3429__678"></a>3.4.2.9 构建可失败迭代器和迭代器范围</h5> 
<p>上面的存档遍历示例通过索引检索存档成员, 但这需要大量的样板代码用于迭代和错误检查. 我们可以通过使用“可失败迭代器”模式来简化这个过程, 该模式支持以下自然的迭代方式, 适用于像 Archive 这样的可失败容器：</p> 
<pre><code class="prism language-cpp">Error Err <span class="token operator">=</span> <span class="token class-name">Error</span><span class="token double-colon punctuation">::</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>Child <span class="token operator">:</span> Ar<span class="token operator">-&gt;</span><span class="token function">children</span><span class="token punctuation">(</span>Err<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// Use Child - only enter the loop when it's valid</span>

  <span class="token comment">// Allow early exit from the loop body, since we know that Err is success</span>
  <span class="token comment">// when we're inside the loop.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">BailOutOn</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>

  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token comment">// Check Err after the loop to ensure it didn't break due to an error.</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>Err<span class="token punctuation">)</span>
  <span class="token keyword">return</span> Err<span class="token punctuation">;</span>
</code></pre> 
<p>为了实现这种方式, 对于可失败容器的迭代器, 我们需要使用可失败的 inc() 和 dec() 函数来替代 ++ 和 – 运算符. 例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">FallibleChildIterator</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">FallibleChildIterator</span><span class="token punctuation">(</span>Archive <span class="token operator">&amp;</span>A<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> ChildIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Archive<span class="token double-colon punctuation">::</span>Child <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> ArchiveIterator <span class="token operator">&amp;</span>LHS<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> ArchiveIterator <span class="token operator">&amp;</span>RHS<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// operator++/operator-- replaced with fallible increment / decrement:</span>
  Error <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">.</span><span class="token function">childValid</span><span class="token punctuation">(</span>ChildIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">make_error</span><span class="token generic class-name"><span class="token operator">&lt;</span>BadArchiveMember<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>ChildIdx<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">Error</span><span class="token double-colon punctuation">::</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  Error <span class="token function">dec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这种类型的可失败迭代器接口的实例可以使用 <code>fallible_iterator</code> 工具进行包装, 该工具提供了 <code>operator++</code> 和 <code>operator--</code>, 通过在构造时传入的引用返回任何错误. <code>fallible_iterator</code> 包装器负责以下两个任务：</p> 
<ul><li>(a) 在出现错误时跳转到范围的末尾</li><li>(b) 当迭代器与 end 进行比较并发现不相等时, 将错误标记为已检查(特别是：这将在基于范围的 for 循环的主体中标记错误为已检查), 从而实现在循环中的早期退出, 避免冗余的错误检查.</li></ul> 
<p>使用 make_fallible_itr 和 make_fallible_end 函数对可失败迭代器接口的实例(例如上面的 FallibleChildIterator)进行包装. 例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Archive</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> child_iterator <span class="token operator">=</span> fallible_iterator<span class="token operator">&lt;</span>FallibleChildIterator<span class="token operator">&gt;</span><span class="token punctuation">;</span>

  child_iterator <span class="token function">child_begin</span><span class="token punctuation">(</span>Error <span class="token operator">&amp;</span>Err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">make_fallible_itr</span><span class="token punctuation">(</span><span class="token function">FallibleChildIterator</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  child_iterator <span class="token function">child_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">make_fallible_end</span><span class="token punctuation">(</span><span class="token function">FallibleChildIterator</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  iterator_range<span class="token operator">&lt;</span>child_iterator<span class="token operator">&gt;</span> <span class="token function">children</span><span class="token punctuation">(</span>Error <span class="token operator">&amp;</span>Err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">make_range</span><span class="token punctuation">(</span><span class="token function">child_begin</span><span class="token punctuation">(</span>Err<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">child_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>使用 <code>fallible_iterator</code> 工具不仅可以自然地构造可失败迭代器(使用失败的 inc 和 dec 操作), 还可以相对自然地使用 <code>C++</code> 迭代器/循环习惯用法.</p> 
<p>有关 Error 及其相关实用程序的更多信息可以在 <code>Error.h</code> 头文件中找到.</p> 
<h3><a id="35__743"></a>3.5 传递函数和其他可调用对象</h3> 
<p>有时您可能希望一个函数接受一个回调对象. 为了支持 lambda 表达式和其他函数对象, 不应该使用传统的 C 方法, 即采用一个函数指针和一个不透明的 cookie 参数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">takeCallback</span><span class="token punctuation">(</span><span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>Callback<span class="token punctuation">)</span><span class="token punctuation">(</span>Function <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>Cookie<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>相反, 可以使用以下方法之一：</p> 
<h4><a id="351__750"></a>3.5.1 函数模板</h4> 
<p>如果您不介意将函数的定义放入头文件中, 可以将其定义为一个模板函数, 该模板函数的模板参数是可调用对象的类型.</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Callable</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">takeCallback</span><span class="token punctuation">(</span>Callable Callback<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">Callback</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="352_The_function_ref_class_template_758"></a>3.5.2 The function_ref class template</h4> 
<p>function_ref (<a href="https://llvm.org/doxygen/classllvm_1_1function__ref_3_01Ret_07Params_8_8_8_08_4.html" rel="nofollow">doxygen</a>) 类模板表示对可调用对象的引用, 模板化为可调用对象的类型. 如果您在函数返回后不需要保留回调函数, 那么这是将回调传递给函数的好选择. 在这种情况下, function_ref 类似于 <code>std::function</code>, 就像 StringRef 类似于 std::string 一样.</p> 
<p><code>function_ref&lt;Ret(Param1, Param2, ...)&gt;</code> 可以从任何可调用对象隐式构造, 该可调用对象可以使用类型为 Param1、Param2、… 的参数进行调用, 并返回一个可以转换为类型 Ret 的值. 例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">visitBasicBlocks</span><span class="token punctuation">(</span>Function <span class="token operator">*</span>F<span class="token punctuation">,</span> function_ref<span class="token operator">&lt;</span><span class="token keyword">bool</span> <span class="token punctuation">(</span>BasicBlock<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> Callback<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>BasicBlock <span class="token operator">&amp;</span>BB <span class="token operator">:</span> <span class="token operator">*</span>F<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Callback</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>BB<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以这样调用：</p> 
<pre><code class="prism language-cpp"><span class="token function">visitBasicBlocks</span><span class="token punctuation">(</span>F<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span>BasicBlock <span class="token operator">*</span>BB<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">process</span><span class="token punctuation">(</span>BB<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>BB<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>请注意, function_ref 对象包含对外部内存的指针, 因此通常不安全存储该类的实例(除非您知道外部存储不会被释放). 如果您需要这种能力, 请考虑使用 <code>std::function</code>. function_ref 的大小足够小, 应始终按值传递.</p> 
<h3><a id="36_The_LLVM_DEBUG_macro_and_debug_option_779"></a>3.6 The LLVM_DEBUG() macro and -debug option</h3> 
<p>通常在处理自己的 Pass 时, 您会在其中添加一些调试打印和其他代码. 在使其正常工作后, 您希望将这些代码删除, 但将来可能需要再次使用(以解决您遇到的新错误).</p> 
<p>自然而然地, 由于这个原因, 您不希望删除调试打印, 但也不希望它们一直存在. 一个标准的折中方案是将其注释掉, 以便在将来需要时启用它们.</p> 
<p>llvm/Support/Debug.h(<a href="https://llvm.org/doxygen/Debug_8h_source.html" rel="nofollow">doxygen</a>)文件提供了一个名为 LLVM_DEBUG() 的宏, 它是解决这个问题的更好方案. 基本上, 您可以将任意代码放入 LLVM_DEBUG 宏的参数中, 只有当使用 ‘opt’(或任何其他工具)运行时使用了 ‘-debug’ 命令行参数时, 该代码才会被执行：</p> 
<pre><code class="prism language-cpp"><span class="token function">LLVM_DEBUG</span><span class="token punctuation">(</span><span class="token function">dbgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"I am here!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>Then you can run your pass like this:</p> 
<pre><code class="prism language-bash">$ opt <span class="token operator">&lt;</span> a.bc <span class="token operator">&gt;</span> /dev/null -mypass
<span class="token operator">&lt;</span>no output<span class="token operator">&gt;</span>
$ opt <span class="token operator">&lt;</span> a.bc <span class="token operator">&gt;</span> /dev/null -mypass -debug
I am here<span class="token operator">!</span>
</code></pre> 
<p>使用 LLVM_DEBUG() 宏而不是自行创建解决方案, 可以避免为您的 Pass 创建“又一个”用于调试输出的命令行选项. 请注意, LLVM_DEBUG() 宏在非断言构建中被禁用, 因此它们不会对性能产生任何影响(出于同样的原因, 它们也不应包含副作用！).</p> 
<p>LLVM_DEBUG() 宏的另一个好处是, 您可以直接在 gdb 中启用或禁用它. 只需在程序运行时使用 “set DebugFlag=0” 或 “set DebugFlag=1” 即可. 如果程序尚未启动, 您始终可以使用 -debug 参数来运行它.</p> 
<h4><a id="361_Fine_grained_debug_info_with_DEBUG_TYPE_and_the_debugonly_option_799"></a>3.6.1 Fine grained debug info with DEBUG_TYPE and the -debug-only option</h4> 
<p>有时候您可能会发现启用 -debug 会打印过多的信息(例如在工作于代码生成器时). 如果您想以更细粒度的控制启用调试信息, 您可以定义 DEBUG_TYPE 宏并按如下方式使用 -debug-only 选项：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEBUG_TYPE</span> <span class="token string">"foo"</span></span>
<span class="token function">LLVM_DEBUG</span><span class="token punctuation">(</span><span class="token function">dbgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"'foo' debug type\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span>  <span class="token expression">DEBUG_TYPE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEBUG_TYPE</span> <span class="token string">"bar"</span></span>
<span class="token function">LLVM_DEBUG</span><span class="token punctuation">(</span><span class="token function">dbgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"'bar' debug type\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span>  <span class="token expression">DEBUG_TYPE</span></span>
</code></pre> 
<p>Then you can run your pass like this:</p> 
<pre><code class="prism language-bash">$ opt <span class="token operator">&lt;</span> a.bc <span class="token operator">&gt;</span> /dev/null -mypass
<span class="token operator">&lt;</span>no output<span class="token operator">&gt;</span>
$ opt <span class="token operator">&lt;</span> a.bc <span class="token operator">&gt;</span> /dev/null -mypass -debug
<span class="token string">'foo'</span> debug <span class="token builtin class-name">type</span>
<span class="token string">'bar'</span> debug <span class="token builtin class-name">type</span>
$ opt <span class="token operator">&lt;</span> a.bc <span class="token operator">&gt;</span> /dev/null -mypass -debug-only<span class="token operator">=</span>foo
<span class="token string">'foo'</span> debug <span class="token builtin class-name">type</span>
$ opt <span class="token operator">&lt;</span> a.bc <span class="token operator">&gt;</span> /dev/null -mypass -debug-only<span class="token operator">=</span>bar
<span class="token string">'bar'</span> debug <span class="token builtin class-name">type</span>
$ opt <span class="token operator">&lt;</span> a.bc <span class="token operator">&gt;</span> /dev/null -mypass -debug-only<span class="token operator">=</span>foo,bar
<span class="token string">'foo'</span> debug <span class="token builtin class-name">type</span>
<span class="token string">'bar'</span> debug <span class="token builtin class-name">type</span>
</code></pre> 
<p>当然, 在实践中, 您应该只在文件的顶部设置 DEBUG_TYPE, 以指定整个模块的调试类型. 请注意, 在包含 Debug.h 之后而不是在任何头文件的 #include 周围进行设置. 此外, 建议使用比 “foo” 和 “bar” 更有意义的名称, 因为没有系统来确保名称不会冲突. 如果两个不同的模块使用相同的字符串, 当指定该名称时, 它们都将被打开. 这样可以通过 -debug-only=InstrSched 启用与指令调度相关的所有调试信息, 即使源代码位于多个文件中. 名称中不能包含逗号 (,), 因为逗号用于分隔 -debug-only 选项的参数.</p> 
<p>出于性能原因, 在优化构建 (–enable-optimized) 的 LLVM 中不可用 -debug-only 选项.</p> 
<p>DEBUG_WITH_TYPE 宏也可用于需要设置 DEBUG_TYPE 但仅针对特定 DEBUG 语句的情况. 它接受额外的第一个参数, 用于指定要使用的类型. 例如, 前面的示例可以写成：</p> 
<pre><code class="prism language-cpp"><span class="token function">DEBUG_WITH_TYPE</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token function">dbgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"'foo' debug type\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">DEBUG_WITH_TYPE</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token function">dbgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"'bar' debug type\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="37_The_Statistic_class__stats_option_833"></a>3.7 The Statistic class &amp; -stats option</h3> 
<p>llvm/ADT/Statistic.h(<a href="https://llvm.org/doxygen/Statistic_8h_source.html" rel="nofollow">doxygen</a>)文件提供了一个名为 Statistic 的类, 用作统一跟踪 LLVM 编译器的活动以及各种优化的效果的方式. 它非常有用, 可以查看哪些优化有助于使特定程序运行更快.</p> 
<p>通常, 您可能会在某个大型程序上运行您的 Pass, 并且您想知道它执行某种特定转换的次数. 虽然您可以通过手动检查或一些临时方法来实现这一点, 但这非常繁琐, 对于大型程序来说并不是非常有用. 使用 Statistic 类可以非常容易地跟踪此信息, 并且计算得到的信息以与正在执行的其他 Pass 一致的方式呈现.</p> 
<p>Statistic 用法有很多示例, 但基本用法如下：</p> 
<p>像这样定义您的统计信息：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEBUG_TYPE</span> <span class="token string">"mypassname"</span>   <span class="token comment">// This goes after any #includes.</span></span>
<span class="token function">STATISTIC</span><span class="token punctuation">(</span>NumXForms<span class="token punctuation">,</span> <span class="token string">"The # of times I did stuff"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>STATISTIC 宏定义了一个静态变量, 其名称由第一个参数指定. Pass 名称取自 DEBUG_TYPE 宏, 描述取自第二个参数. 所定义的变量(在本例中为 “NumXForms”)的行为类似于无符号整数.</p> 
<p>每当进行一次转换时, 增加计数器：</p> 
<pre><code class="prism language-cpp"><span class="token operator">++</span>NumXForms<span class="token punctuation">;</span>   <span class="token comment">// I did stuff!</span>
</code></pre> 
<p>这就是你需要做的全部. 要让 ‘opt’ 打印出收集的统计信息, 请使用 ‘-stats’ 选项：</p> 
<pre><code class="prism language-css">$ opt -stats -mypassname &lt; program.bc &gt; /dev/null
... statistics output ...
</code></pre> 
<p>请注意, 在使用 ‘-stats’ 选项之前, LLVM 必须以启用断言的方式进行编译.</p> 
<p>在从 SPEC 基准测试套件中运行 opt 命令时, 会生成如下报告：</p> 
<pre><code class="prism language-css">  7646 bitcodewriter   - Number of normal instructions
   725 bitcodewriter   - Number of oversized instructions
129996 bitcodewriter   - Number of bitcode bytes written
  2817 raise           - Number of insts DCEd or constprop'd
  3213 raise           - Number of cast-of-self removed
  5046 raise           - Number of expression trees converted
    75 raise           - Number of other getelementptr's formed
   138 raise           - Number of load/store peepholes
    42 deadtypeelim    - Number of unused typenames removed from symtab
   392 funcresolve     - Number of varargs functions resolved
    27 globaldce       - Number of global variables removed
     2 adce            - Number of basic blocks removed
   134 cee             - Number of branches revectored
    49 cee             - Number of setcc instruction eliminated
   532 gcse            - Number of loads removed
  2919 gcse            - Number of instructions removed
    86 indvars         - Number of canonical indvars added
    87 indvars         - Number of aux indvars removed
    25 instcombine     - Number of dead inst eliminate
   434 instcombine     - Number of insts combined
   248 licm            - Number of load insts hoisted
  1298 licm            - Number of insts hoisted to a loop pre-header
     3 licm            - Number of insts hoisted to multiple loop preds <span class="token punctuation">(</span>bad<span class="token punctuation">,</span> no loop pre-header<span class="token punctuation">)</span>
    75 mem2reg         - Number of alloca's promoted
  1444 cfgsimplify     - Number of blocks simplified
</code></pre> 
<p>显然, 有这么多优化功能, 拥有一个统一的框架非常方便. 使你的 Pass 与框架完美结合, 使其更易于维护和使用.</p> 
<h3><a id="38__888"></a>3.8 在调试代码时添加调试计数器可以帮助你进行调试</h3> 
<p>有时, 在编写新的 Pass 或追踪错误时, 能够控制代码中某些部分的执行与否是很有用的. 例如, 有时最小化工具只能给出大型测试用例. 你希望通过二分法将错误缩小到特定的转换操作的执行与否, 以便自动化调试. 这就是调试计数器的作用. 它们提供了一个框架, 使得代码的某些部分只执行特定次数.</p> 
<p>在 LLVM 中, 你可以使用 DebugCounter 类来创建控制代码执行的命令行计数器选项.</p> 
<p>下面是定义 DebugCounter 的基本步骤：</p> 
<pre><code class="prism language-cpp"><span class="token function">DEBUG_COUNTER</span><span class="token punctuation">(</span>DeleteAnInstruction<span class="token punctuation">,</span> <span class="token string">"passname-delete-instruction"</span><span class="token punctuation">,</span>
              <span class="token string">"Controls which instructions get delete"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>DEBUG_COUNTER 宏定义了一个静态变量, 其名称由第一个参数指定. 计数器的名称(在命令行中使用)由第二个参数指定, 帮助中使用的描述由第三个参数指定.</p> 
<p>你可以使用 <code>DebugCounter::shouldExecute</code> 来控制需要进行控制的代码.</p> 
<pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">DebugCounter</span><span class="token double-colon punctuation">::</span><span class="token function">shouldExecute</span><span class="token punctuation">(</span>DeleteAnInstruction<span class="token punctuation">)</span><span class="token punctuation">)</span>
  I<span class="token operator">-&gt;</span><span class="token function">eraseFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这就是你需要做的全部. 现在, 使用 opt 命令, 你可以通过使用 --debug-counter 选项来控制代码何时触发. 提供了两个计数器, 即 skip 和 count. skip 表示跳过执行代码路径的次数, count 表示在跳过后执行代码路径的次数.</p> 
<pre><code class="prism language-cpp">$ opt <span class="token operator">--</span>debug<span class="token operator">-</span>counter<span class="token operator">=</span>passname<span class="token operator">-</span><span class="token keyword">delete</span><span class="token operator">-</span>instruction<span class="token operator">-</span>skip<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>passname<span class="token operator">-</span><span class="token keyword">delete</span><span class="token operator">-</span>instruction<span class="token operator">-</span>count<span class="token operator">=</span><span class="token number">2</span> <span class="token operator">-</span>passname
</code></pre> 
<p>这将在第一次执行时跳过上述代码, 然后执行两次, 然后跳过其余的执行.</p> 
<p>因此, 如果在以下代码上执行：</p> 
<pre><code class="prism language-cpp"><span class="token operator">%</span><span class="token number">1</span> <span class="token operator">=</span> add i32 <span class="token operator">%</span>a<span class="token punctuation">,</span> <span class="token operator">%</span>b
<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">=</span> add i32 <span class="token operator">%</span>a<span class="token punctuation">,</span> <span class="token operator">%</span>b
<span class="token operator">%</span><span class="token number">3</span> <span class="token operator">=</span> add i32 <span class="token operator">%</span>a<span class="token punctuation">,</span> <span class="token operator">%</span>b
<span class="token operator">%</span><span class="token number">4</span> <span class="token operator">=</span> add i32 <span class="token operator">%</span>a<span class="token punctuation">,</span> <span class="token operator">%</span>b
</code></pre> 
<p>它将删除 number % 2 和 number % 3.</p> 
<p>utils/bisect-skip-count 提供了一个实用工具, 用于二分搜索跳过 (skip) 和计数 (count) 参数. 它可用于自动缩小调试计数器变量的跳过和计数值.</p> 
<h3><a id="39_Viewing_graphs_while_debugging_code_922"></a>3.9 Viewing graphs while debugging code</h3> 
<p>LLVM 中的几个重要数据结构都是图形结构, 例如由 LLVM 的基本块构成的控制流图(CFG), 由LLVM的机器基本块构成的CFG, 以及指令选择图(Instruction Selection DAG). 在调试编译器的各个部分时, 即时可视化这些图形非常方便.</p> 
<p>LLVM 在调试构建中提供了几个回调函数来实现这一点. 例如, 如果调用 <code>Function::viewCFG()</code> 方法, 当前的 LLVM 工具将弹出一个窗口, 其中包含函数的 CFG, 其中每个基本块是图中的一个节点, 每个节点包含块中的指令. 类似地, 还存在 <code>Function::viewCFGOnly()</code>(不包括指令)、 MachineFunction::viewCFG() 和 MachineFunction::viewCFGOnly(), 以及SelectionDAG::viewGraph()方法. 在 GDB 中, 例如, 通常可以使用类似于 <code>call DAG.viewGraph()</code> 的方式弹出一个窗口. 或者, 您可以在代码中的调试位置添加对这些函数的调用.</p> 
<p>要使其工作, 需要进行一些设置. 在具有 <code>X11</code> 的 Unix 系统上, 安装 <code>graphviz</code> 工具包, 并确保 <code>dot</code> 和 <code>gv</code> 在您的路径中. 如果您在 macOS 上运行, 请下载并安装 macOS 的 Graphviz 程序, 并将 <code>/Applications/Graphviz.app/Contents/MacOS/</code> (或您安装的位置)添加到您的路径中. 这些程序在配置、构建或运行 LLVM 时不必存在, 而可以在活动调试会话期间根据需要安装.</p> 
<p>SelectionDAG 已扩展, 使在大型复杂图形中定位感兴趣的节点更加容易. 从 gdb 中, 如果调用 <code>DAG.setGraphColor(node, "color")</code>, 那么接下来的DAG.viewGraph()调用将以指定的颜色突出显示该节点(可以在colors中找到颜色选择). 更复杂的节点属性可以使用调用 <code>DAG.setGraphAttrs(node, "attributes")</code> 提供(可以在Graph attributes中找到选择). 如果您想重新启动并清除所有当前的图形属性, 那么可以调用 <code>DAG.clearGraphAttrs()</code>.</p> 
<p>请注意, 图形可视化功能在发布版本中被编译取消以减小文件大小. 这意味着您需要使用 <code>Debug+Asserts</code> 或 <code>Release+Asserts</code> 构建来使用这些功能.</p> 
<h2><a id="4_Picking_the_Right_Data_Structure_for_a_Task_933"></a>4 Picking the Right Data Structure for a Task</h2> 
<p>LLVM在 llvm/ADT/ 目录下有各种各样的数据结构, 我们通常使用STL数据结构. 本节将介绍在选择数据结构时需要考虑的权衡因素.</p> 
<p>首先, 你需要决定使用顺序容器、 set-like 的容器还是 map-like 的容器. 在选择容器时最重要的是要考虑你计划如何访问容器的算法特性. 基于这一点, 你应该选择以下之一：</p> 
<ul><li>如果你需要根据另一个值高效地查找一个值, 可以使用 map-like 的容器. map-like 的容器也支持高效地查询是否包含某个键. map-like 的容器通常不支持高效的反向映射(值到键的映射). 如果需要反向映射, 可以使用两个映射. 某些 map-like 的容器还支持按照键的排序顺序高效地迭代访问键. map-like 的容器是最昂贵的一类容器, 只有在需要这些功能之一时才使用它们.</li><li>如果你需要将一堆元素放入容器并自动消除重复项, 可以使用 set-like 的容器. 某些 set-like 的容器支持按照排序顺序高效地迭代访问元素. set-like 的容器比顺序容器更昂贵.</li><li>顺序容器提供了最高效的添加元素的方式, 并且会记录它们被添加到集合中的顺序. 它们允许重复项并支持高效的迭代访问, 但不支持基于键的高效查找.</li><li>字符串容器是用于字符或字节数组的专用顺序容器或引用结构.</li><li>位容器提供了一种在数字ID集上存储和执行集合操作的高效方式, 并自动消除重复项. 位容器对于存储每个要存储的标识符最多只需要1位.</li></ul> 
<p>确定了合适的容器类别后, 你可以通过智能选择类别中的成员来调整内存使用、常数因子和缓存访问行为. 需要注意的是, 常数因子和缓存行为可能非常重要. 例如, 如果你的向量通常只包含少量元素(但可能包含许多元素), 使用SmallVector要比vector好得多. 这样做避免了(相对)昂贵的 <code>malloc/free</code> 调用, 这比将元素添加到容器中的成本要高得多.</p> 
<h3><a id="41_Sequential_Containers_stdvector_stdlist_etc_946"></a>4.1 Sequential Containers (std::vector, std::list, etc)</h3> 
<p>根据你的需求, 有各种顺序容器可供选择. 选择本节中满足你需求的第一个容器.</p> 
<h4><a id="411_llvmADTArrayRefh_949"></a>4.1.1 llvm/ADT/ArrayRef.h</h4> 
<p><code>llvm::ArrayRef</code> 类是在接口中使用的首选类, 它接受一个顺序存储的元素列表并只对其进行<code>读取</code>操作. 通过接受 ArrayRef, API 可以接受固定大小的数组、std::vector、llvm::SmallVector 和其他在内存中连续的数据结构.</p> 
<h4><a id="412_Fixed_Size_Arrays_952"></a>4.1.2 Fixed Size Arrays</h4> 
<p>固定大小数组非常简单且非常快速. 如果您确切地知道有多少元素, 或者对元素数量有一个(较低的)上限, 那么固定大小数组是很好的选择.</p> 
<h4><a id="413_Heap_Allocated_Arrays_955"></a>4.1.3 Heap Allocated Arrays</h4> 
<p>堆分配的数组(<code>new[] + delete[]</code>)也很简单. 如果元素数量是可变的, 如果在数组分配之前知道需要多少元素, 并且数组通常很大(如果不是, 考虑使用 SmallVector), 那么堆分配的数组是很好的选择. 堆分配数组的成本是 <code>new/delete</code>(即 malloc/free)的成本. 还要注意, 如果您正在分配一个具有构造函数的类型的数组, 构造函数和析构函数将针对数组中的每个元素运行(可调整大小的向量仅构造实际使用的那些元素).</p> 
<h4><a id="414_llvmADTTinyPtrVectorh_958"></a>4.1.4 llvm/ADT/TinyPtrVector.h</h4> 
<p><code>TinyPtrVector&lt;Type&gt;</code> 是一种高度专门化的集合类, 它在向量没有元素或只有一个元素的情况下进行了优化, 以避免分配内存. 它有两个主要限制：1)它只能容纳指针类型的值, 2)它不能容纳空指针.</p> 
<p>由于这个容器是高度专门化的, 很少被使用.</p> 
<h4><a id="415_llvmADTSmallVectorh_963"></a>4.1.5 llvm/ADT/SmallVector.h</h4> 
<p>SmallVector&lt;Type, N&gt; 是一个简单的类, 看起来和使用 vector 类似：它支持高效的迭代, 按照内存顺序布局元素(因此可以在元素之间进行指针算术运算), 支持高效的 push_back/pop_back 操作, 支持对元素进行高效的随机访问等等.</p> 
<p>SmallVector 的主要优势在于它在对象本身中分配了一些元素(N)的空间. 因此, 如果 SmallVector 动态大小小于 N, 就不会执行 malloc 操作. 这在 malloc/free 调用的开销比操作元素的代码更大的情况下是一个巨大的优势.</p> 
<p>这适用于“通常较小”的向量(例如, 块的前驱/后继数通常小于 8). 另一方面, 这使得 SmallVector 本身的大小较大, 因此不要分配大量的 SmallVector(这样会浪费很多空间). 因此, 在堆栈上使用 SmallVector 最为有用.</p> 
<p>如果没有对于内联元素数量 N 的充分理由的选择, 建议使用 <code>SmallVector&lt;T&gt;</code>(即省略 N). 这将选择一个默认的内联元素数量, 适合在堆栈上进行分配(例如, 尝试将 sizeof(<code>SmallVector&lt;T&gt;</code>) 保持在 64 字节左右).</p> 
<p>SmallVector 还提供了一个很好的可移植和高效的替代 alloca 的方法.</p> 
<p>SmallVector 在一些其他方面也比 std::vector 有一些小优势, 这导致 SmallVector&lt;Type, 0&gt; 被优先选择而不是 <code>std::vector&lt;Type&gt;</code>.</p> 
<p>std::vector 是异常安全的, 并且一些实现在需要移动元素时会进行复制, 而 SmallVector 则会移动元素.<br> SmallVector 理解 <code>std::is_trivially_copyable&lt;Type&gt;</code>(平凡可复制), 并积极使用 realloc.<br> 许多 LLVM API 将 SmallVectorImpl 作为输出参数(请参阅下面的说明).<br> 在 64 位平台上, SmallVector 的 N 等于 0 比 std::vector 更小, 因为它使用 unsigned(而不是 void*)来表示大小和容量.</p> 
<hr> 
<p><strong>注意</strong>:<br> 优先使用 <code>ArrayRef&lt;T&gt;</code> 或 <code>SmallVectorImpl&lt;T&gt;</code> 作为参数类型.</p> 
<p>很少有情况适合使用 <code>SmallVector&lt;T, N&gt;</code> 作为参数类型. 如果一个 API 只从向量中读取数据, 应该使用 ArrayRef. 即使一个 API 更新向量, “small size” 也不太相关；这种情况下应该使用 <code>SmallVectorImpl&lt;T&gt;</code> 类, 它是 “vector header”(和方法)而不是在其之后分配元素的部分. 需要注意的是, <code>SmallVector&lt;T, N&gt;</code> 继承自 SmallVectorImpl, 所以转换是隐式的且没有额外开销. 例如：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 不推荐使用：客户端不能传递原始数组. </span>
<span class="token function">hardcodedContiguousStorage</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmallVectorImpl<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>In<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 鼓励使用：客户端可以传递任何连续的 Foo 存储</span>
<span class="token function">allowsAnyContiguousStorage</span><span class="token punctuation">(</span>ArrayRef<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> In<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">someFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  Foo Vec<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">hardcodedContiguousStorage</span><span class="token punctuation">(</span>Vec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error.</span>
  <span class="token function">allowsAnyContiguousStorage</span><span class="token punctuation">(</span>Vec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Works.</span>
<span class="token punctuation">}</span>

<span class="token comment">// 不推荐使用：客户端不能传递例如 SmallVector&lt;Foo, 8&gt;</span>
<span class="token function">hardcodedSmallSize</span><span class="token punctuation">(</span>SmallVector<span class="token operator">&lt;</span>Foo<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>Out<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 鼓励使用：客户端可以传递任何 SmallVector&lt;Foo, N&gt;</span>
<span class="token function">allowsAnySmallSize</span><span class="token punctuation">(</span>SmallVectorImpl<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>Out<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">someFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  SmallVector<span class="token operator">&lt;</span>Foo<span class="token punctuation">,</span> <span class="token number">8</span><span class="token operator">&gt;</span> Vec<span class="token punctuation">;</span>
  <span class="token function">hardcodedSmallSize</span><span class="token punctuation">(</span>Vec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error.</span>
  <span class="token function">allowsAnySmallSize</span><span class="token punctuation">(</span>Vec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Works.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>尽管名字中有 “Impl”, 但 SmallVectorImpl 已经被广泛使用, 并不再是 “private to the implementation”. 可能更合适的名称是 SmallVectorHeader.</p> 
<h4><a id="416_vector_1011"></a>4.1.6 vector</h4> 
<p><code>std::vector&lt;T&gt;</code> 备受喜爱和尊重. 然而, 由于上述优势, <code>SmallVector&lt;T, 0&gt;</code> 通常是一个更好的选择. 当您需要存储超过 UINT32_MAX 个元素或与期望使用向量的代码进行接口时, <code>std::vector</code> 仍然很有用.</p> 
<p>关于 <code>std::vector</code> 值得一提的一点是：避免编写以下类似的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>foo<span class="token operator">&gt;</span> V<span class="token punctuation">;</span>
   <span class="token comment">// make use of V.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Instead, write this as:</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>foo<span class="token operator">&gt;</span> V<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token comment">// make use of V.</span>
   V<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样做将在每次循环迭代中节省(至少)一次堆分配和释放操作.</p> 
<h4><a id="417_deque_1031"></a>4.1.7 deque</h4> 
<p>从某种意义上说, <code>std::deque</code> 是 <code>std::vector</code> 的一个通用版本. 与 <code>std::vector</code> 一样, 它提供了常数时间的随机访问和其他类似的特性, 但它还提供了对列表前端的高效访问. 然而, 它<code>不保证元素在内存中的连续性</code>.</p> 
<p>为了获得这种额外的灵活性, <code>std::deque</code> 的常数因子成本明显较高. 如果可能的话, 请使用 <code>std::vector</code> 或其他更经济的容器.</p> 
<h4><a id="418_list_1036"></a>4.1.8 list</h4> 
<p>std::list 是一个极其低效的类, 很少有用. 它对每个插入的元素执行堆分配, 因此具有非常高的常数因子, 特别是对于小型数据类型而言. <code>std::list</code> 只支持双向迭代, 不支持随机访问迭代.</p> 
<p>作为代价, <code>std::list</code> 支持对列表两端的高效访问(类似于 <code>std::deque</code>, 但与 <code>std::vector</code> 或 <code>SmallVector</code> 不同). 此外, std::list 的迭代器失效特性比向量类更强：在列表中插入或删除元素不会使迭代器或指向其他元素的指针失效.</p> 
<h4><a id="419_llvmADTilisth_1041"></a>4.1.9 llvm/ADT/ilist.h</h4> 
<p><code>ilist&lt;T&gt;</code> 实现了一种“内嵌”的双向链表. 它是内嵌的, 因为它要求元素存储并提供对列表的前后指针的访问.</p> 
<p>ilist 具有与 std::list 相同的缺点, 并且还需要为元素类型实现 <code>ilist_traits</code>, 但它提供了一些新颖的特性. 特别是, 它可以<code>高效地存储多态对象</code>, 当元素从列表中插入或删除时, traits 类会被通知, 并且 ilist 保证支持常数时间的剪接操作.</p> 
<p>ilist 和 iplist 互相使用别名, 而 iplist 目前仅出于历史目的而存在.</p> 
<p>这些特性正是我们在指令和基本块等方面所需要的, 这也是为什么它们使用 ilist 进行实现的.</p> 
<p>有关感兴趣的相关类, 请参阅以下子节：</p> 
<ul><li><a href="https://llvm.org/docs/ProgrammersManual.html#dss-ilist-traits" rel="nofollow">ilist_traits</a></li><li><a href="https://llvm.org/docs/ProgrammersManual.html#dss-ilist-node" rel="nofollow">llvm/ADT/ilist_node.h</a></li><li><a href="https://llvm.org/docs/ProgrammersManual.html#dss-ilist-sentinel" rel="nofollow">Sentinels</a></li></ul> 
<h4><a id="4110_llvmADTPackedVectorh_1056"></a>4.1.10 llvm/ADT/PackedVector.h</h4> 
<p>用于使用每个值的少量比特位存储值的向量的容器. 除了具有类似向量的容器的标准操作之外, 它还可以执行“或”集合操作.</p> 
<p>例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{<!-- --></span>
    None <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">,</span>
    FirstCondition <span class="token operator">=</span> <span class="token number">0x1</span><span class="token punctuation">,</span>
    SecondCondition <span class="token operator">=</span> <span class="token number">0x2</span><span class="token punctuation">,</span>
    Both <span class="token operator">=</span> <span class="token number">0x3</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

State <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    PackedVector<span class="token operator">&lt;</span>State<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">&gt;</span> Vec1<span class="token punctuation">;</span>
    Vec1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>FirstCondition<span class="token punctuation">)</span><span class="token punctuation">;</span>

    PackedVector<span class="token operator">&lt;</span>State<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">&gt;</span> Vec2<span class="token punctuation">;</span>
    Vec2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>SecondCondition<span class="token punctuation">)</span><span class="token punctuation">;</span>

    Vec1 <span class="token operator">|=</span> Vec2<span class="token punctuation">;</span>
    <span class="token keyword">return</span> Vec1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// returns 'Both'.</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="4111_ilist_traits_1079"></a>4.1.11 ilist_traits</h4> 
<p><code>ilist_traits&lt;T&gt;</code> 是 <code>ilist&lt;T&gt;</code> 的自定义机制. <code>ilist&lt;T&gt;</code> 公开继承自这个 <code>traits</code> 类.</p> 
<h4><a id="4112_llvmADTilist_nodeh_1082"></a>4.1.12 llvm/ADT/ilist_node.h</h4> 
<p><code>ilist_node&lt;T&gt;</code> 实现了 <code>ilist&lt;T&gt;</code>(和类似的容器)所需的前向和后向链接, 默认方式.</p> 
<p><code>ilist_node&lt;T&gt;</code> 应该嵌入在节点类型 T 中, 通常 T 公开继承自 <code>ilist_node&lt;T&gt;</code></p> 
<h4><a id="4113_Sentinels_1087"></a>4.1.13 Sentinels</h4> 
<p>ilist 在考虑到 C++ 生态系统中的规范时还有另一个特殊性需要考虑. 它需要支持标准的容器操作, 例如 begin 和 end 迭代器等. 此外, 在非空 ilist 中, operator-- 必须正确地工作于末尾迭代器.</p> 
<p>解决这个问题的唯一合理方法是在 intrusive list 旁边分配一个称为 sentinel 的元素, 作为末尾迭代器, 并提供到最后一个元素的后向链接. 然而, 根据 C++ 的约定, 不允许在 sentinel 之后进行 operator++ 操作, 并且不得对其进行解引用.</p> 
<p>这些限制允许 ilist 在如何分配和存储 sentinel 方面有一定的实现自由度. 相应的策略由 <code>ilist_traits&lt;T&gt;</code> 指定. 默认情况下, 当需要 sentinel 时, 会为 T 进行堆分配.</p> 
<p>尽管默认策略在大多数情况下足够, 但在 T 不提供默认构造函数的情况下可能会出现问题. 此外, 在存在多个 ilist 实例的情况下, 与其关联的 sentinel 的内存开销是浪费的. 为了缓解大量且庞大的 T-sentinel 问题, 有时会使用一种技巧, 即使用 ghostly sentinel.</p> 
<p>通过特殊设计的 <code>ilist_traits&lt;T&gt;</code> 可以获得 ghostly sentinel, 它将 sentinel 与 ilist 实例内存上叠加. 使用指针运算可以获取 sentinel, 该 sentinel 相对于 ilist 的 this 指针. ilist 通过额外的指针进行扩展, 该指针充当 sentinel 的后向链接. 这是 ghostly sentinel 中唯一可以合法访问的字段.</p> 
<h4><a id="4114__1098"></a>4.1.14 其他顺序容器选项</h4> 
<p>还有其他的STL容器可用, 例如 std::string.</p> 
<p>此外, 还有各种STL适配器类, 例如 std::queue 、 std::priority_queue、std::stack 等. 它们提供对底层容器的简化访问, 但不会影响容器本身的成本.</p> 
<h3><a id="42_Stringlike_containers_1103"></a>4.2 String-like containers</h3> 
<p>有多种方法可以在C和C++中传递和使用字符串, 而LLVM添加了一些新的选择. 根据相对成本的顺序, 选择能够满足需求的列表中的第一个选项.</p> 
<p>请注意, 通常最好不要将字符串作为 const char 传递. 这种方式存在一些问题, 包括不能表示嵌入的空字符(“0”)和没有有效获取长度的能力. 用于替代’const char’的通用选择是 <code>StringRef</code>.</p> 
<p>有关为API选择字符串容器的更多信息, 请参阅 <a href="https://llvm.org/docs/ProgrammersManual.html#string-apis" rel="nofollow">传递字符串</a>.</p> 
<h4><a id="421_llvmADTStringRefh_1110"></a>4.2.1 llvm/ADT/StringRef.h</h4> 
<p>StringRef 类是一个简单的值类, 包含一个指向字符的指针和一个长度, 并且与ArrayRef 类非常相关(但专门用于字符数组). 由于 StringRef 携带了长度信息, 它可以安全地处理包含空字符的字符串, 获取长度不需要调用 strlen 函数, 而且它还提供了非常方便的API来对表示的字符范围进行切片和处理.</p> 
<p>StringRef 非常适合传递简单的字符串, 这些字符串被知道是有效的, 无论是因为它们是 C 字符串字面量、std::string、C数组还是SmallVector. 这些情况下都存在一个高效的隐式转换到 StringRef 的方式, 不需要执行动态的 strlen 调用.</p> 
<p>然而, StringRef 也有一些主要限制, 这就需要更强大的字符串容器：</p> 
<p>您无法直接将 StringRef 转换为’const char*', 因为没有方法添加尾随的空字符(不像更强大的类上的 .c_str() 方法).<br> StringRef 不拥有或保持底层字符串字节的生存期. 因此, 它很容易导致悬空指针, 并且在大多数情况下不适合嵌入在数据结构中(而是使用 <code>std::string</code> 或类似的类型).<br> 出于相同的原因, 如果方法“计算”结果字符串, StringRef 不能用作方法的返回值. 而应该使用 std::string.<br> StringRef 不允许您更改指向的字符串字节, 也不允许您在该范围内插入或删除字节. 对于此类编辑操作, 它与 Twine 类进行交互.<br> 由于它的优点和限制, 函数通常会接受一个 StringRef 参数, 并且对象的方法会返回一个指向它拥有的某个字符串的 StringRef.</p> 
<h4><a id="422_llvmADTTwineh_1123"></a>4.2.2 llvm/ADT/Twine.h</h4> 
<p>Twine 类用作中间数据类型, 用于那些希望使用一系列连接操作内联构造字符串的API. Twine 通过在堆栈上形成 Twine 数据类型(一个简单的值对象)的递归实例作为临时对象, 并将它们链接在一起形成树, 然后在 Twine 被使用时将其线性化. Twine 只能安全地用作函数的参数, 并且应始终是一个 const 引用, 例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Twine <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
StringRef X <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">foo</span><span class="token punctuation">(</span>X <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> <span class="token function">Twine</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这个例子通过将值连接起来形成一个字符串"blarg.42", 而不是形成包含"blarg"或"blarg."的中间字符串.</p> 
<p>由于 Twine 是使用堆栈上的临时对象构造的, 并且因为这些实例在当前语句结束时被销毁, 它是一个固有的危险的 API. 例如, 下面这个简单的变体包含未定义行为, 并且可能会导致崩溃：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Twine <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
StringRef X <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">const</span> Twine <span class="token operator">&amp;</span>Tmp <span class="token operator">=</span> X <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> <span class="token function">Twine</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span>Tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>因为临时对象在调用之前被销毁了. 尽管如此, Twine比中间的std::string临时对象更高效, 并且它们与 StringRef 非常配合. 只要注意它们的限制即可.</p> 
<h4><a id="423_llvmADTSmallStringh_1145"></a>4.2.3 llvm/ADT/SmallString.h</h4> 
<p>SmallString 是 SmallVector 的子类, 它添加了一些方便的API, 比如 += , 接受 StringRef. 当预分配的空间足以容纳数据时, SmallString 避免了内存分配, 并在需要时回退到一般的堆分配. 由于它拥有自己的数据, 所以非常安全可靠, 并支持对字符串的完全修改.</p> 
<p>与 SmallVector 一样, SmallString 的一个主要缺点是它们的 sizeof 大小. 虽然它们被优化用于小字符串, 但它们本身并不特别小. 这意味着它们非常<code>适合用作栈上的临时缓冲区</code>, 但通常不应该放入堆中：很少见到 SmallString 作为频繁分配的堆数据结构的成员或者作为返回值.</p> 
<h4><a id="424_stdstring_1150"></a>4.2.4 std::string</h4> 
<p>标准 C++ 的 std::string 类是一个非常通用的类, 它(和SmallString一样)拥有其底层数据. <code>sizeof(std::string)</code> 非常合理, 因此可以将其嵌入到堆数据结构中并作为返回值. 另一方面, std::string 在内联编辑(例如将一堆内容拼接在一起)方面效率非常低下, 并且由于它是由标准库提供的, 其性能特性很大程度上取决于宿主标准库(例如 libc++ 和 MSVC 提供了高度优化的字符串类, GCC则包含了一个非常慢的实现).</p> 
<p>std::string 的主要缺点是几乎每个使其变大的操作都会分配内存, 这是很慢的. 因此, 最好使用 SmallVector 或 Twine 作为临时缓冲区, 然后使用 std::string 来保存结果.</p> 
<hr> 
<h2><a id="43_SetLike_Containers_stdset_SmallSet_SetVector_etc_1156"></a>4.3 Set-Like Containers (std::set, SmallSet, SetVector, etc)</h2> 
<p>当您需要将多个值归一化为单个表示时, 集合类容器非常有用. 在这方面, 有几种不同的选择, 提供了各种权衡取舍的可能性.</p> 
<h4><a id="431_A_sorted_vector_1159"></a>4.3.1 A sorted ‘vector’</h4> 
<p>如果您打算插入大量元素, 然后进行大量查询, 一个很好的方法是使用std::vector(或其他顺序容器), 结合std::sort+std::unique来去除重复项. 如果您的使用模式具有这两个明确的阶段(插入然后查询), 这种方法效果非常好, 并且可以与良好选择的顺序容器相结合使用.</p> 
<p>这种组合提供了几个优点：结果数据在内存中是连续的(有利于缓存局部性), 内存分配较少, 易于寻址(最终向量中的迭代器只是索引或指针), 并且可以使用标准的二分搜索(例如std::lower_bound；如果您想要比较相等的整个元素范围, 请使用std::equal_range)进行高效的查询.</p> 
<h4><a id="432_llvmADTSmallSeth_1164"></a>4.3.2 llvm/ADT/SmallSet.h</h4> 
<p>如果您有一个通常很小且元素相对较小的类似集合的数据结构, 那么 <code>SmallSet&lt;Type, N&gt;</code> 是一个很好的选择. 该集合在原地为N个元素提供空间(因此, 如果集合在动态上小于N, 就不需要进行内存分配), 并使用简单的线性搜索访问它们. 当集合的大小超过N个元素时, 它会分配一个更昂贵的表示形式, 以确保高效访问(对于大多数类型, 它会回退到std::set, 但对于指针, 它使用的是更好的SmallPtrSet.</p> 
<p>这个类的魔力在于它能够非常高效地处理小型集合, 同时在不损失效率的情况下优雅地处理极大型集合.</p> 
<h4><a id="433_llvmADTSmallPtrSeth_1169"></a>4.3.3 llvm/ADT/SmallPtrSet.h</h4> 
<p>SmallPtrSet 具 SmallSet 的所有优点(而且SmallSet的指针集合会透明地使用SmallPtrSet 进行实现). 如果执行的插入操作超过N次, 将分配一个单一的二次探测哈希表, 并根据需要进行扩展, 提供极其高效的访问(具有低常数因子的常数时间插入/删除/查询)并且非常节约内存分配.</p> 
<p>请注意, 与 std::set 不同, 当进行插入操作时, SmallPtrSet 的迭代器将失效. 此外, 迭代器访问的值不会按排序顺序访问.</p> 
<h4><a id="434_llvmADTStringSeth_1174"></a>4.3.4 llvm/ADT/StringSet.h</h4> 
<p>StringSet 是 <code>StringMap&lt;char&gt;</code> 的一个轻量级包装, 它可以高效地存储和检索唯一的字符串.</p> 
<p>在功能上类似于 <code>SmallSet&lt;StringRef&gt;</code>, StringSet 还支持迭代(迭代器解引用为 <code>StringMapEntry&lt;char&gt;</code> , 因此需要调用 i-&gt;getKey() 来访问StringSet的项). 另一方面, StringSet不支持范围插入和复制构造, 而 SmallSet 和 SmallPtrSet 支持这些操作.</p> 
<h4><a id="435_llvmADTDenseSeth_1179"></a>4.3.5 llvm/ADT/DenseSet.h</h4> 
<p>DenseSet 是一个简单的二次探测哈希表. 它非常适用于支持小值：它使用单个分配来存储当前插入到集合中的所有键值对. DenseSet 是唯一化非简单指针的小值的理想选择(对于指针, 请使用SmallPtrSet). 请注意, DenseSet对于值类型的要求与 DenseMap相同.</p> 
<h4><a id="436_llvmADTSparseSeth_1182"></a>4.3.6 llvm/ADT/SparseSet.h</h4> 
<p>SparseSet 是通过中等大小的无符号键标识的少量对象. 它使用了大量内存, 但提供的操作几乎和向量一样快速. 典型的键可以是物理寄存器、虚拟寄存器或编号的基本块.</p> 
<p>SparseSet 对于需要非常快速的清除、查找、插入和删除操作以及对小集合进行快速迭代的算法非常有用. 它不适用于构建复合数据结构.</p> 
<h4><a id="437_llvmADTSparseMultiSeth_1187"></a>4.3.7 llvm/ADT/SparseMultiSet.h</h4> 
<p>SparseMultiSet 在保留 SparseSet 的优点的基础上, 添加了多重集合(multiset)的行为. 与 SparseSet 类似, 它通常使用了大量的内存, 但提供的操作几乎和向量一样快速. 典型的键可以是物理寄存器、虚拟寄存器或编号的基本块.</p> 
<p>SparseMultiSet 对于需要非常快速的清除、查找、插入和删除整个集合以及对共享键的元素集进行迭代的算法非常有用. 与使用复合数据结构(例如向量的向量、向量的映射)相比, 它通常是更高效的选择. 它不适用于构建复合数据结构.</p> 
<h4><a id="438_llvmADTFoldingSeth_1192"></a>4.3.8 llvm/ADT/FoldingSet.h</h4> 
<p>FoldingSet 是一个聚合类, 非常适用于唯一化昂贵或多态对象. 它是一个使用了 <code>链式哈希表</code> 和内部链接(唯一化的对象需要继承自 FoldingSetNode )的组合, 其中在其 ID 处理过程中使用了SmallVector.</p> 
<p>考虑这样一种情况：你想为一个复杂对象(例如代码生成器中的一个节点)实现一个“getOrCreateFoo”方法. 客户端具有要生成的内容的描述(它知道操作码和所有操作数), 但我们不想先’new’一个节点, 然后尝试将其插入到集合中, 只有在发现它已经存在时, 我们才需要删除它并返回已经存在的节点.</p> 
<p>为了支持这种客户端方式, FoldingSet使用FoldingSetNodeID(它包装了SmallVector)进行查询, 该ID用于描述我们要查询的元素. 查询要么返回与ID匹配的元素, 要么返回一个不透明的ID, 指示应该进行插入的位置. 构造ID通常不需要堆上的内存操作.</p> 
<p>由于FoldingSet使用内部链接, 它可以支持集合中的多态对象(例如, 你可以将SDNode实例与LoadSDNode混合使用). 由于元素是单独分配的, 指向元素的指针是稳定的：插入或删除元素不会使指向其他元素的指针失效.</p> 
<h4><a id="439_set_1201"></a>4.3.9 set</h4> 
<p>std::set 是一个合理的通用集合类, 它在许多方面表现尚可, 但没有在任何方面表现出色. std::set 在每插入一个元素时分配内存(因此对 malloc 的需求非常频繁), 并且通常为集合中的每个元素存储三个指针(因此增加了大量的每个元素空间开销). 它提供了保证的对数复杂度性能, 从复杂度角度来看并不特别快(特别是如果集合中的元素在比较时很昂贵, 比如字符串), 并且在查找、插入和删除操作上具有极高的常数因子.</p> 
<p>std::set 的优点是它的迭代器是稳定的(从集合中删除或插入元素不会影响其他元素的迭代器或指针), 并且对集合的迭代保证按照排序顺序进行. 如果集合中的元素很大, 那么指针和 malloc 开销的相对额外开销并不是一个大问题, 但如果集合的元素很小, std::set几乎永远不是一个好的选择.</p> 
<h4><a id="4310_llvmADTSetVectorh_1206"></a>4.3.10 llvm/ADT/SetVector.h</h4> 
<p>LLVM的 <code>SetVector&lt;Type&gt;</code> 是一个适配器类, 它将您选择的类似于集合的容器和顺序容器组合在一起. 它的一个重要特性是提供了高效的插入和去重(重复元素会被忽略), 同时支持迭代. 它通过 <code>将元素同时插入类似于集合的容器和顺序容器来实现这一特性</code>, 其中类似于集合的容器用于去重, 而顺序容器用于迭代.</p> 
<p>SetVector 与其他集合的区别在于迭代的顺序保证与插入到 SetVector 中的顺序相匹配. 这一特性对于指针集合等情况非常重要. 因为指针值是非确定性的(例如, 在不同机器上的程序运行中会有所变化), 对集合中的指针进行迭代将不会有一个明确定义的顺序.</p> 
<p>SetVector 的缺点是它需要比普通集合多一倍的空间, 并且具有来自使用的类似于集合的容器和顺序容器的常数因子之和. 只有在需要按确定的顺序迭代元素时才使用它. 从SetVector中删除元素也很昂贵(线性时间), 除非使用其"pop_back"方法, 该方法更快.</p> 
<p>SetVector 是一个适配器类, 默认使用std::vector和大小为16的SmallSet作为底层容器, 因此它的开销很大. 然而, "llvm/ADT/SetVector.h"还提供了一个SmallSetVector 类, 默认使用指定大小的SmallVector和SmallSet. 如果使用这个类, 并且您的集合在动态上小于N, 将会节省大量的堆内存开销.</p> 
<h4><a id="4311_llvmADTUniqueVectorh_1215"></a>4.3.11 llvm/ADT/UniqueVector.h</h4> 
<p>UniqueVector 类类似于 SetVector, 但它为插入集合的每个元素保留了唯一的ID. 它内部包含一个映射(map)和一个向量(vector), 并为插入集合的每个值分配一个唯一的ID.</p> 
<p>UniqueVector非常昂贵：它的成本是维护映射和向量的成本之和, 具有较高的复杂度、高的常数因子, 并产生大量的堆内存开销. 应尽量避免使用它.</p> 
<h4><a id="4312_llvmADTImmutableSeth_1220"></a>4.3.12 llvm/ADT/ImmutableSet.h</h4> 
<p>ImmutableSet 是基于 AVL 树的不可变(函数式)集合实现. 通过Factory对象进行添加或删除元素, 结果会创建一个新的 ImmutableSet 对象. 如果已经存在具有相同内容的 ImmutableSet, 则返回现有的对象；相等性是通过FoldingSetNodeID 进行比较. 添加或删除操作的时间和空间复杂度与原始集合的大小呈对数关系.</p> 
<p>该集合没有返回集合元素的方法, 只能检查成员资格.</p> 
<h4><a id="4313_Other_SetLike_Container_Options_1225"></a>4.3.13 Other Set-Like Container Options</h4> 
<p>STL 提供了其他几种选项, 比如 std::multiset 和 std::unordered_set. 我们从不使用类似 unordered_set 的容器, 因为它们通常非常昂贵(每次插入都需要进行内存分配).</p> 
<p>std::multiset 在您不关心消除重复项时很有用, 但它也具有 std::set 的所有缺点. A sorted vector (其中不删除重复条目)或其他方法几乎总是更好的选择.</p> 
<h3><a id="44_MapLike_Containers_stdmap_DenseMap_etc_1230"></a>4.4 Map-Like Containers (std::map, DenseMap, etc)</h3> 
<p>当您想要将数据与键关联起来时, 类似映射的容器非常有用. 通常情况下, 有很多不同的方法可以实现这个目标. 😃</p> 
<h4><a id="441_A_sorted_vector_1233"></a>4.4.1 A sorted ‘vector’</h4> 
<p>如果您的使用模式遵循严格的 <code>插入-查询</code> 方法, 您可以轻松地使用与有序向量相同的方法来处理类似集合的容器. 唯一的区别是您的查询函数(使用std::lower_bound 进行高效的对数时间查找)应仅比较键而不是键和值. 这样可以获得与有序向量相同的优势.</p> 
<h4><a id="442_llvmADTStringMaph_1236"></a>4.4.2 llvm/ADT/StringMap.h</h4> 
<p>字符串在映射中通常用作键, 但要高效地支持它们并不容易：它们的长度可变, 在长度较长时哈希和比较效率低下, 复制开销大等等. StringMap是一个专门处理这些问题的特殊容器. 它支持将任意字节范围映射到任意其他对象.</p> 
<p>StringMap 的实现使用了一种 <code>二次探测的哈希表</code>, 其中的<code>桶</code>存储了指向<code>堆分配条目的指针</code>(以及其他一些内容). 由于字符串的长度可变, 映射中的条目必须进行堆分配. 字符串数据(键)和元素对象(值)与字符串数据紧随元素对象之后一起存储在同一分配中. 该容器保证了对于值来说, “(char*)(&amp;Value+1)” 指向键字符串.</p> 
<p>StringMap 之所以非常快速, 原因如下：<code>二次探测对于查找非常高效</code>, 桶中的字符串哈希值在查找元素时不会重新计算, StringMap 在查找值时很少需要访问与之无关的内存(即使哈希冲突发生时也是如此), 哈希表的增长不会重新计算已经存在于表中的字符串的哈希值, 而且映射中的每对元素都存储在单个分配中(字符串数据存储在与一对的值相同的分配中).</p> 
<p>StringMap 还提供了<code>接受字节范围的查询方法</code>, 因此只有在向表中插入值时才会复制字符串.</p> 
<p>然而, StringMap 的 <code>迭代顺序不能保证是确定性的</code>, 因此任何需要确定性迭代顺序的用途应改用 <code>std::map</code>.</p> 
<h4><a id="443_llvmADTIndexedMaph_1247"></a>4.4.3 llvm/ADT/IndexedMap.h</h4> 
<p>IndexedMap 是一种专门用于将小而密集的整数(或可映射为小而密集的整数的值)映射到其他类型的容器. 它在内部实现为一个向量, 并使用映射函数将键映射到密集整数范围.</p> 
<p>这在像 LLVM 代码生成器中的虚拟寄存器这样的情况下非常有用：它们具有通过编译时常量(第一个虚拟寄存器ID)进行偏移的密集映射.</p> 
<h4><a id="444_llvmADTDenseMaph_1252"></a>4.4.4 llvm/ADT/DenseMap.h</h4> 
<p>DenseMap 是一个简单的 <code>二次探测哈希表</code>, 非常适用于支持小键和小值：它使用单个分配来保存当前插入到映射中的所有键值对. DenseMap 是将指针映射到指针或将其他小类型相互映射的理想选择.</p> 
<p>然而, 有几个方面需要注意. DenseMap 中的迭代器在插入操作发生时会失效, 与map不同. 此外, 由于 DenseMap 为大量的 <code>键/值</code> 对分配空间(默认情况下从64开始), 如果键或值较大, 将会浪费很多空间. 最后, 如果您的键类型没有得到支持, 您需要为所需的键实现 DenseMapInfo 的偏特化. 这是为了向 DenseMap 介绍两个内部所需的特殊标记值(永远不能插入到映射中).</p> 
<p>DenseMap 的 <code>find_as()</code> 方法支持使用替代键类型进行查找操作. 这在正常键类型的构造成本较高, 但与之进行比较的成本很低的情况下非常有用. DenseMapInfo 负责为使用的每个替代键类型定义适当的比较和哈希方法.</p> 
<h4><a id="445_llvmIRValueMaph_1259"></a>4.4.5 llvm/IR/ValueMap.h</h4> 
<p>ValueMap 是一个包装器, 围绕着一个 DenseMap , 将 <code>Value*</code>(或其子类)映射到另一种类型. 当删除或替换 Value 时, ValueMap 会自动更新, 使新版本的键映射到相同的值, 就像键是 <code>WeakVH</code> 一样. 您可以通过向ValueMap模板传递一个 Config 参数来精确配置此过程以及在这两个事件发生时的其他操作.</p> 
<h4><a id="446_llvmADTIntervalMaph_1262"></a>4.4.6 llvm/ADT/IntervalMap.h</h4> 
<p>IntervalMap 是用于小型键和值的紧凑映射. 它将键区间映射而不是单个键, 并且会自动合并相邻的区间. 当映射只包含少量区间时, 它们存储在映射对象本身中, 以避免分配内存.</p> 
<p>IntervalMap 的迭代器相当庞大, 因此不应将其作为STL迭代器传递. 重型迭代器允许使用较小的数据结构.</p> 
<h4><a id="447_llvmADTIntervalTreeh_1267"></a>4.4.7 llvm/ADT/IntervalTree.h</h4> 
<p>llvm::IntervalTree 是一种轻量级的树形数据结构, 用于保存区间. 它允许查找与给定点重叠的所有区间. 目前, 它不支持任何删除或平衡操作.</p> 
<p>IntervalTree 的设计初衷是在设置后进行查询, 而无需进一步添加操作.</p> 
<h4><a id="448_map_1272"></a>4.4.8 map</h4> 
<p>std::map 具有与 std::set 类似的特性：它对每个插入到映射中的键值对使用单个分配, 提供了具有极大常数因子的对数级别的查找, 对于每个键值对在映射中需要3个指针的空间开销等.</p> 
<p>当键或值非常大时, 如果您需要按排序顺序迭代集合, 或者如果您需要对映射进行稳定的迭代器(即在插入或删除其他元素时不会使其失效), std::map 是非常有用的.</p> 
<h4><a id="449_llvmADTMapVectorh_1277"></a>4.4.9 llvm/ADT/MapVector.h</h4> 
<p><code>MapVector&lt;KeyT, ValueT&gt;</code> 提供了 DenseMap 接口的子集. 主要区别在于迭代顺序保证是插入顺序, 使其成为非确定性指针映射的简单(但有些昂贵)解决方案.</p> 
<p>它的实现方式是通过将键映射到键值对向量中的索引. 这提供了快速的查找和迭代, 但有两个主要缺点：键被存储两次, 并且删除元素需要线性时间. 如果需要删除元素, 最好使用 remove_if() 批量删除.</p> 
<h4><a id="4410_llvmADTIntEqClassesh_1283"></a>4.4.10 llvm/ADT/IntEqClasses.h</h4> 
<p>IntEqClasses 提供了小整数的等价类的紧凑表示. 初始情况下, 范围0到n-1中的每个整数都有自己的等价类. 可以通过将两个类的代表传递给join(a, b)方法来合并类. 当 findLeader() 返回相同的代表时, 两个整数属于同一个类.</p> 
<p>一旦所有等价类形成, 可以压缩映射, 使得0到n-1中的每个整数映射到0到m-1范围内的等价类编号, 其中m是总等价类的数量. 在可以再次编辑之前, 必须取消压缩映射.</p> 
<h4><a id="4411_llvmADTImmutableMaph_1288"></a>4.4.11 llvm/ADT/ImmutableMap.h</h4> 
<p>ImmutableMap 是基于 AVL 树的不可变(函数式)映射实现. 通过 Factory 对象进行添加或删除元素, 从而创建一个新的 ImmutableMap 对象. 如果已经存在具有给定键集的 ImmutableMap, 则返回现有的对象；通过 FoldingSetNodeID 进行相等性比较. 添加或删除操作的时间和空间复杂度与原始映射的大小成对数关系.</p> 
<h4><a id="4412_Other_MapLike_Container_Options_1291"></a>4.4.12 Other Map-Like Container Options</h4> 
<p>STL提供了其他几个选项, 例如 std::multimap 和 std::unordered_map. 我们通常不使用类似 unordered_map 的容器, 因为它们通常非常昂贵(每个插入操作都需要分配内存).</p> 
<p>如果你想将一个键映射到多个值, std::multimap 是有用的, 但它也具有 std::map 的所有缺点. 排序向量或其他方法通常更好.</p> 
<h3><a id="45_Bit_storage_containers_1296"></a>4.5 Bit storage containers</h3> 
<p>有几种位存储容器可供选择, 选择何时使用每个容器相对简单.</p> 
<p>另一个选项是 <code>std::vector&lt;bool&gt;</code>：我们不鼓励使用它, 有两个原因：1)许多常见编译器(例如常见的GCC版本)中的实现效率非常低下；2)C++ 标准委员会很可能会弃用此容器和/或以某种方式进行重大更改. 无论如何, 请不要使用它.</p> 
<h4><a id="451_BitVector_1301"></a>4.5.1 BitVector</h4> 
<p>BitVector 容器提供了一个用于操作的动态大小位集合. 它支持单个位的设置和测试, 以及集合操作. 集合操作的时间复杂度为 O(bitvector的大小), 但操作是以字为单位进行的, 而不是以位为单位. 与其他容器相比, 这使得 BitVector 在集合操作方面非常快速. 当您预计设置位数较高(即密集集合)时, 请使用 BitVector.</p> 
<h4><a id="452_SmallBitVector_1304"></a>4.5.2 SmallBitVector</h4> 
<p>SmallBitVector 容器提供与 BitVector 相同的接口, 但它针对只需要少量位(大约小于25位)的情况进行了优化. 它还可以透明地支持更大的位数, 但效率略低于普通的 BitVector, 因此 SmallBitVector 只应在较大的位数很少出现的情况下使用.</p> 
<p>目前, SmallBitVector 不支持集合操作(与、或、异或), 它的 operator[] 也不提供可赋值的左值.</p> 
<h4><a id="453_SparseBitVector_1309"></a>4.5.3 SparseBitVector</h4> 
<p>SparseBitVector 容器与 BitVector 非常相似, 但有一个主要区别：它只存储已设置的位. 当集合稀疏时, 这使得 SparseBitVector 在空间利用上比 BitVector 更高效, 同时使得集合操作的时间复杂度为O(设置位的数量), 而不是O(size of universe). SparseBitVector 的缺点是随机位的设置和测试时间复杂度为O(N), 在大型 SparseBitVector 上, 这可能比 BitVector 更慢. 在我们的实现中, 按排序顺序(向前或向后)设置或测试位的最坏情况时间复杂度为O(1). 在当前位的前后128位(取决于大小)范围内测试和设置位也是O(1). 一般而言, 在 SparseBitVector 中测试/设置位的时间复杂度为O(与上一个设置位的距离).</p> 
<h4><a id="454_CoalescingBitVector_1312"></a>4.5.4 CoalescingBitVector</h4> 
<p>CoalescingBitVector 容器在原理上与 SparseBitVector 类似, 但经过优化, 可以紧凑地表示大范围连续的置位位. 它通过将连续的置位位范围合并成间隔来实现这一点. 在 CoalescingBitVector 中搜索位的时间复杂度为 O(log(连续范围之间的间隔)).</p> 
<p>当置位位范围之间的间隔较大时, CoalescingBitVector 是比 BitVector 更好的选择. 当需要快速、可预测的 find() 操作性能时, 它比 SparseBitVector 更合适. 然而, 它不适合表示具有大量非常短范围的集合. 例如, 集合 {2*x: x 在 [0, n) 范围内} 将是一个病态输入.</p> 
<h3><a id="46_Useful_Utility_Functions_1317"></a>4.6 Useful Utility Functions</h3> 
<p>LLVM实现了许多通用的实用函数, 这些函数在代码库中被广泛使用. 你可以在STLExtras.h(<a href="https://llvm.org/doxygen/STLExtras_8h.html" rel="nofollow">doxygen</a>)中找到最常见的函数. 其中一些函数封装了众所周知的C++标准库函数, 而另一些函数则是LLVM独有的.</p> 
<h4><a id="461_Iterating_over_ranges_1320"></a>4.6.1 Iterating over ranges</h4> 
<p>有时候您可能希望一次迭代多个范围, 或者知道索引的索引. LLVM提供了自定义的实用函数来简化这个过程, 而无需手动管理所有的迭代器和/或索引：</p> 
<h5><a id="4611_The_zip_functions_1323"></a>4.6.1.1 The zip* functions</h5> 
<p>zip*函数允许同时迭代两个或多个范围的元素. 例如：</p> 
<pre><code class="prism language-cpp">SmallVector<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> Counts <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> Letters<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>Letter<span class="token punctuation">,</span> Count<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token function">zip_equal</span><span class="token punctuation">(</span>Letters<span class="token punctuation">,</span> Counts<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> Letter <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> Count <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
</code></pre> 
<p>请注意, 元素通过“引用包装器”代理类型(引用的元组)提供, 结合结构化绑定声明, 使得 Letter 和 Count 成为范围元素的引用. 对这些引用的任何修改都会影响 Letters 或 Counts 的元素.</p> 
<p>zip*函数支持临时范围, 例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>Letter<span class="token punctuation">,</span> Count<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token function">zip</span><span class="token punctuation">(</span>SmallVector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> Counts<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> Letter <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> Count <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
</code></pre> 
<p>zip系列函数之间的区别在于当提供的范围具有不同长度时它们的行为：</p> 
<ul><li>zip_equal - 要求所有输入范围具有相同的长度.</li><li>zip - 当达到最短范围的末尾时停止迭代.</li><li>zip_first - 要求第一个范围是最短的范围.</li><li>zip_longest - 迭代直到达到最长范围的末尾. 较短范围中不存在的元素将被替换为std::nullopt.</li></ul> 
<p>长度要求通过断言进行检查.</p> 
<p>作为经验法则, 如果您希望所有范围具有相同的长度, 请优先使用 zip_equal, 并且仅在不满足此条件时考虑使用其他 zip 函数. 这是因为 zip_equal 清楚地传达了这种相同长度的假设, 并且具有最佳(发布模式下的)运行时性能.</p> 
<h5><a id="4612_enumerate_1349"></a>4.6.1.2 enumerate</h5> 
<p>enumerate 函数允许在迭代过程中跟踪当前循环迭代的索引, 同时遍历一个或多个范围. 例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>Idx<span class="token punctuation">,</span> BB<span class="token punctuation">,</span> Value<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token function">enumerate</span><span class="token punctuation">(</span>Phi<span class="token operator">-&gt;</span><span class="token function">blocks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
Phi<span class="token operator">-&gt;</span><span class="token function">incoming_values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"#"</span> <span class="token operator">&lt;&lt;</span> Idx <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> BB<span class="token operator">-&gt;</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>Value <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
</code></pre> 
<p>当前元素的索引作为第一个结构化绑定元素提供. 或者, 可以使用index()和value()成员函数获取索引和元素值：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> Letters<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> En <span class="token operator">:</span> <span class="token function">enumerate</span><span class="token punctuation">(</span>Letters<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"#"</span> <span class="token operator">&lt;&lt;</span> En<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> En<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
</code></pre> 
<p>请注意, enumerate 具有 zip_equal 语义, 并通过“引用包装器”代理提供元素, 这使得它们在通过结构化绑定或 value() 成员函数访问时可修改. 当传递两个或更多范围时, enumerate 要求它们具有相等的长度(通过断言进行检查).</p> 
<h2><a id="5_Debugging_1364"></a>5 Debugging</h2> 
<p>为一些核心LLVM库提供了一些 <a href="https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html" rel="nofollow">GDB漂亮打印器</a>. 要使用它们, 请执行以下命令(或将其添加到您的 <code>~/.gdbinit</code> 文件中)：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">source</span> /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py
</code></pre> 
<p>另外, 启用打印漂亮选项可能会很方便, 以避免将数据结构打印为大块文本.</p> 
<h2><a id="6_Helpful_Hints_for_Common_Operations_1371"></a>6 Helpful Hints for Common Operations</h2> 
<p>本节介绍如何执行一些非常简单的 LLVM 代码转换. 这旨在通过展示 LLVM 转换的实际示例, 展示常见的习惯用法.</p> 
<p>因为这是一个“如何”部分, 您还应该阅读您将使用的主要类的相关信息. <a href="https://llvm.org/docs/ProgrammersManual.html#coreclasses" rel="nofollow">LLVM核心类层次结构参考</a> 提供了您应该了解的主要类的详细信息和描述.</p> 
<h3><a id="61_Basic_Inspection_and_Traversal_Routines_1376"></a>6.1 Basic Inspection and Traversal Routines</h3> 
<p>LLVM 编译器基础设施拥有许多不同的数据结构, 可以进行遍历. 按照 C++ 标准模板库的例子, 用于遍历这些不同的数据结构的技术基本上是相同的. 对于可枚举的值序列, XXXbegin()函数(或方法)返回指向序列开头的迭代器, XXXend()函数返回指向序列中最后一个有效元素之后的迭代器, 并且存在某种 XXXiterator 数据类型, 该类型在这两个操作之间是通用的.</p> 
<p>由于迭代模式在程序表示的许多不同方面都是常见的, 因此可以在它们上使用标准模板库算法, 并且更容易记住如何进行迭代. 首先, 我们展示了一些需要遍历的常见数据结构的示例. 其他数据结构的遍历方式非常类似.</p> 
<h4><a id="611_Iterating_over_the_BasicBlock_in_a_Function_1381"></a>6.1.1 Iterating over the BasicBlock in a Function</h4> 
<p>经常会有一个 Function 实例, 您希望以某种方式对其进行转换；特别是, 您希望操作其中的 BasicBlock. 为了实现这一点, 您需要遍历组成 Function 的所有 BasicBlock. 以下是一个示例, 打印 BasicBlock 的名称和其中包含的指令数：</p> 
<pre><code class="prism language-cpp">Function <span class="token operator">&amp;</span>Func <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>BasicBlock <span class="token operator">&amp;</span>BB <span class="token operator">:</span> Func<span class="token punctuation">)</span>
  <span class="token comment">// 如果BasicBlock有名称, 则打印其名称, 然后打印其中包含的指令数</span>
  <span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Basic block (name="</span> <span class="token operator">&lt;&lt;</span> BB<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">") has "</span>
    <span class="token operator">&lt;&lt;</span> BB<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" instructions.\n"</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="612_Iterating_over_the_Instruction_in_a_BasicBlock_1391"></a>6.1.2 Iterating over the Instruction in a BasicBlock</h4> 
<p>就像处理函数中的基本块(BasicBlock)时一样, 迭代构成基本块的单个指令也很容易. 以下是一个代码片段, 用于打印出基本块中的每条指令：</p> 
<pre><code class="prism language-cpp">BasicBlock<span class="token operator">&amp;</span> BB <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>Instruction <span class="token operator">&amp;</span>I <span class="token operator">:</span> BB<span class="token punctuation">)</span>
   <span class="token comment">// The next statement works since operator&lt;&lt;(ostream&amp;,...)</span>
   <span class="token comment">// is overloaded for Instruction&amp;</span>
   <span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> I <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
</code></pre> 
<p>然而, 这并不是打印 BasicBlock 内容的最佳方式！由于 ostream 运算符已经针对您关心的几乎所有内容进行了重载, 您可以直接在 BasicBlock 本身上调用打印例程：<code>errs() &lt;&lt; BB &lt;&lt; "\n";</code>.</p> 
<h4><a id="613_Iterating_over_the_Instruction_in_a_Function_1401"></a>6.1.3 Iterating over the Instruction in a Function</h4> 
<p>如果您发现自己经常迭代 Function 的 BasicBlocks , 然后迭代 BasicBlock 的 Instructions, 应该使用 InstIterator. 您需要包含 <code>llvm/IR/InstIterator.h</code>(<a href="https://llvm.org/doxygen/InstIterator_8h.html" rel="nofollow">doxygen</a>), 然后在代码中显式实例化 InstIterator . 以下是一个小例子, 展示了如何将一个函数中的所有指令转储到标准错误流中：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"llvm/IR/InstIterator.h"</span></span>

<span class="token comment">// F是一个指向 Function 实例的指针</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>inst_iterator I <span class="token operator">=</span> <span class="token function">inst_begin</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">,</span> E <span class="token operator">=</span> <span class="token function">inst_end</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">;</span> I <span class="token operator">!=</span> E<span class="token punctuation">;</span> <span class="token operator">++</span>I<span class="token punctuation">)</span>
  <span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>I <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
</code></pre> 
<p>很简单, 不是吗？您还可以使用 InstIterator 将其初始内容填充到工作列表中. 例如, 如果您想要初始化一个工作列表, 其中包含 Function F 中的所有指令, 您只需要执行以下操作：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span>Instruction<span class="token operator">*</span><span class="token operator">&gt;</span> worklist<span class="token punctuation">;</span>
<span class="token comment">// 或者更好的选择, SmallPtrSet&lt;Instruction*, 64&gt; worklist;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>inst_iterator I <span class="token operator">=</span> <span class="token function">inst_begin</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">,</span> E <span class="token operator">=</span> <span class="token function">inst_end</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">;</span> I <span class="token operator">!=</span> E<span class="token punctuation">;</span> <span class="token operator">++</span>I<span class="token punctuation">)</span>
  worklist<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token operator">*</span>I<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>现在, STL set 工作列表将包含指向 F 指向的 Function 中的所有指令.</p> 
<h4><a id="614_Turning_an_iterator_into_a_class_pointer_and_viceversa_1420"></a>6.1.4 Turning an iterator into a class pointer (and vice-versa)</h4> 
<p>有时, 当您手头只有迭代器时, 从迭代器中提取类实例的引用(或指针)会很有用. 从迭代器中提取引用或指针非常简单. 假设 i 是 BasicBlock::iterator, j 是 BasicBlock::const_iterator：</p> 
<pre><code class="prism language-cpp">Instruction<span class="token operator">&amp;</span> inst <span class="token operator">=</span> <span class="token operator">*</span>i<span class="token punctuation">;</span>   <span class="token comment">// 提取指令引用</span>
Instruction<span class="token operator">*</span> pinst <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token operator">*</span>i<span class="token punctuation">;</span> <span class="token comment">// 提取指令指针</span>
<span class="token keyword">const</span> Instruction<span class="token operator">&amp;</span> inst <span class="token operator">=</span> <span class="token operator">*</span>j<span class="token punctuation">;</span>
</code></pre> 
<p>然而, 在 LLVM 框架中, 您将使用的迭代器是特殊的：它们会在需要时自动转换为指向实例的指针类型. 您可以直接将迭代器分配给正确的指针类型, 无需对迭代器进行解引用和取地址操作(在幕后, 这是通过重载类型转换机制实现的). 因此, 最后一个示例中的第二行：</p> 
<pre><code class="prism language-cpp">Instruction <span class="token operator">*</span>pinst <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token operator">*</span>i<span class="token punctuation">;</span>
</code></pre> 
<p>在语义上等同于：</p> 
<pre><code class="prism language-cpp">Instruction <span class="token operator">*</span>pinst <span class="token operator">=</span> i<span class="token punctuation">;</span>
</code></pre> 
<p>还可以将类指针转换为相应的迭代器, 这是一个常数时间操作(非常高效). 以下代码片段演示了 LLVM 迭代器提供的转换构造函数的用法. 通过使用这些构造函数, 您可以明确地获取某个对象的迭代器, 而无需通过对某个结构进行迭代来获取它：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">printNextInstruction</span><span class="token punctuation">(</span>Instruction<span class="token operator">*</span> inst<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  BasicBlock<span class="token double-colon punctuation">::</span>iterator <span class="token function">it</span><span class="token punctuation">(</span>inst<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">++</span>it<span class="token punctuation">;</span> <span class="token comment">// 在此行之后, it引用inst后面的指令</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> inst<span class="token operator">-&gt;</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>不幸的是, 这些隐式转换会带来一些代价；它们阻止了这些迭代器符合标准迭代器约定, 因此无法与标准算法和容器一起使用. 例如, 它们会阻止以下代码(其中B是BasicBlock)的编译：</p> 
<pre><code class="prism language-cpp">llvm<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">SmallVector</span><span class="token generic class-name"><span class="token operator">&lt;</span>llvm<span class="token double-colon punctuation">::</span>Instruction <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>B<span class="token operator">-&gt;</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> B<span class="token operator">-&gt;</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>因此, 这些隐式转换可能在将来被删除, 并且 operator* 可能会更改为返回指针而不是引用.</p> 
<h4><a id="615_Finding_call_sites_a_slightly_more_complex_example_1449"></a>6.1.5 Finding call sites: a slightly more complex example</h4> 
<p>假设您正在编写一个 FunctionPass, 并希望计算整个模块(即在每个 Function 中)中已经在作用域中的某个函数(即一些Function*)的所有位置. 正如您将在后面学到的那样, 您可能希望使用 InstVisitor 以更简单的方式实现此目标, 但本示例将让我们了解如果没有 InstVisitor , 您将如何实现. 以下是我们要完成的伪代码：</p> 
<pre><code class="prism language-cpp">将 callCounter 初始化为零
对于模块中的每个函数 f
  对于函数 f 中的每个基本块 b
    对于基本块 b 中的每个指令i
      如果<span class="token punctuation">(</span> i 是一个调用并且调用了给定的函数<span class="token punctuation">)</span>
        增加 callCounter
</code></pre> 
<p>以下是实际的代码(请记住, 因为我们正在编写 FunctionPass, 我们的FunctionPass 派生类只需要覆盖 runOnFunction方法)：</p> 
<pre><code class="prism language-cpp">Function<span class="token operator">*</span> targetFunc <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">OurFunctionPass</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">FunctionPass</span></span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">OurFunctionPass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">callCounter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>

    <span class="token keyword">bool</span> <span class="token function">runOnFunction</span><span class="token punctuation">(</span>Function<span class="token operator">&amp;</span> F<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>BasicBlock <span class="token operator">&amp;</span>B <span class="token operator">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Instruction <span class="token operator">&amp;</span>I <span class="token operator">:</span> B<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">*</span>CB <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dyn_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>CallBase<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>I<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 我们知道我们遇到了某种调用指令(call、invoke或callbr), 因此我们需要确定它是否是对 m_func 指向的函数的调用. </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>CB<span class="token operator">-&gt;</span><span class="token function">getCalledFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> targetFunc<span class="token punctuation">)</span>
              <span class="token operator">++</span>callCounter<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 此示例中未进行实际修改</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">unsigned</span> callCounter<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码中, 我们假设您已经定义了目标函数 targetFunc. OurFunctionPass 是一个继承自 FunctionPass 的类, 它重写了 runOnFunction 方法. 在该方法中, 我们遍历了函数中的基本块和指令, 并通过 <code>dyn_cast&lt;CallBase&gt;</code> 将指令转换为调用指令类型. 然后, 我们检查调用的函数是否等于 targetFunc , 如果是, 则增加 callCounter 的计数. 最后, 我们将返回值设置为 false, 表示在此示例中未进行实际修改.</p> 
<h4><a id="616_Iterating_over_defuse__usedef_chains_1484"></a>6.1.6 Iterating over def-use &amp; use-def chains</h4> 
<p>经常情况下, 我们可能有一个 Value 类的实例, 并且想要确定哪些 User 使用了该Value. 特定 Value 的所有 User 的列表称为 def-use 链. 例如, 假设我们有一个指向特定函数 foo 的 Function*, 名为 F. 查找使用 foo 的所有指令就像迭代 F 的 def-use 链一样简单：</p> 
<pre><code class="prism language-cpp">Function <span class="token operator">*</span>F <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>User <span class="token operator">*</span>U <span class="token operator">:</span> F<span class="token operator">-&gt;</span><span class="token function">users</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Instruction <span class="token operator">*</span>Inst <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dyn_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Instruction<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>U<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"F is used in instruction:\n"</span><span class="token punctuation">;</span>
    <span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>Inst <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>另外, 通常我们会有一个 User 类的实例, 并且需要知道它使用的哪些 Value. User 使用的所有 Value 的列表称为 use-def 链. Instruction 类的实例通常是User, 因此我们可能希望遍历特定指令使用的所有值(即特定指令的操作数)：</p> 
<pre><code class="prism language-cpp">Instruction <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>Use <span class="token operator">&amp;</span>U <span class="token operator">:</span> pi<span class="token operator">-&gt;</span><span class="token function">operands</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  Value <span class="token operator">*</span>v <span class="token operator">=</span> U<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>将对象声明为 const 是强制执行无变异算法(例如分析等)的重要工具. 为此, 上述迭代器具有常量版本, 即 Value::const_use_iterator 和 Value::const_op_iterator. 当在 const Value 或 const User 上调用 use/op_begin() 时, 它们会自动出现. 在解引用时, 它们返回 const Use*. 除此之外, 上述模式保持不变.</p> 
<h4><a id="617_Iterating_over_predecessors__successors_of_blocks_1507"></a>6.1.7 Iterating over predecessors &amp; successors of blocks</h4> 
<p>使用在"llvm/IR/CFG.h"中定义的例程来迭代块的前驱和后继非常简单. 只需使用以下代码来迭代BB的所有前驱：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"llvm/IR/CFG.h"</span></span>
BasicBlock <span class="token operator">*</span>BB <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>BasicBlock <span class="token operator">*</span>Pred <span class="token operator">:</span> <span class="token function">predecessors</span><span class="token punctuation">(</span>BB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>类似地, 要迭代后继, 请使用 successors.</p> 
<h3><a id="62_Making_simple_changes_1518"></a>6.2 Making simple changes</h3> 
<p>LLVM基础架构中存在一些原始的转换操作, 值得了解. 在进行转换时, 通常会操作基本块的内容. 本节介绍了一些常见的方法, 并提供了示例代码.</p> 
<h4><a id="621_Creating_and_inserting_new_Instructions_1521"></a>6.2.1 Creating and inserting new Instructions</h4> 
<h5><a id="_1522"></a>实例化指令</h5> 
<p>创建指令非常简单：只需调用要实例化的指令类型的构造函数并提供必要的参数. 例如, AllocaInst仅需要一个(const-ptr-to)Type. 因此：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> <span class="token operator">*</span>ai <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">AllocaInst</span><span class="token punctuation">(</span>Type<span class="token double-colon punctuation">::</span>Int32Ty<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>将创建一个 AllocaInst 实例, 表示在运行时当前堆栈帧中分配一个整数. 每个Instruction 子类可能具有不同的默认参数, 可以改变指令的语义, 因此请参阅您要实例化的 Instruction 子类的 <a href="https://llvm.org/doxygen/classllvm_1_1Instruction.html" rel="nofollow">doxygen</a> 文档.</p> 
<h5><a id="_1530"></a>命名值</h5> 
<p>在可能的情况下, 为指令的值命名非常有用, 因为这有助于调试转换过程. 如果您查看生成的 LLVM 机器代码, 肯定希望将逻辑名称与指令的结果关联起来！通过为Instruction 构造函数的 Name(默认)参数提供一个值, 您可以将逻辑名称与指令在运行时执行的结果关联起来. 例如, 假设我正在编写一个动态分配堆栈上整数空间的转换, 该整数将由其他代码用作某种索引. 为此, 我在某个函数的第一个基本块的第一个点放置了一个 AllocaInst, 并且打算在同一函数中使用它. 我可以这样做：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">AllocaInst</span><span class="token punctuation">(</span>Type<span class="token double-colon punctuation">::</span>Int32Ty<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"indexLoc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中 indexLoc 现在是指令执行值的逻辑名称, 它是运行时堆栈上整数的指针.</p> 
<h5><a id="_1537"></a>插入指令</h5> 
<p>将指令插入到形成 BasicBlock 的现有指令序列中基本上有三种方法：</p> 
<ol><li>插入到BasicBlock的指令列表中</li></ol> 
<p>给定 BasicBlock* pb, 该 BasicBlock 中的 Instruction* pi, 以及要在*pi之前插入的新创建的指令, 可以执行以下操作：</p> 
<pre><code class="prism language-cpp">BasicBlock <span class="token operator">*</span>pb <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
Instruction <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">*</span>newInst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Instruction</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

newInst<span class="token operator">-&gt;</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在pi之前插入newInst</span>
</code></pre> 
<p>追加到cBasicBlockc的末尾非常常见, 因此cInstructionc类和cInstructionc派生类提供了构造函数, 它们接受指向要追加到的cBasicBlockc的指针. 例如, 下面的代码：</p> 
<pre><code class="prism language-cpp">BasicBlock <span class="token operator">*</span>pb <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">*</span>newInst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Instruction</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

newInst<span class="token operator">-&gt;</span><span class="token function">insertInto</span><span class="token punctuation">(</span>pb<span class="token punctuation">,</span> pb<span class="token operator">-&gt;</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将newInst追加到pb</span>
</code></pre> 
<p>可以改写为：</p> 
<pre><code class="prism language-cpp">BasicBlock <span class="token operator">*</span>pb <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">*</span>newInst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Instruction</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> pb<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这样做更加简洁, 特别是如果您正在创建长的指令流.</p> 
<ol start="2"><li>使用 IRBuilder 进行插入</li></ol> 
<p>使用前面的方法插入多个指令可能相当繁琐. IRBuilder 是一个方便的类, 可用于在 BasicBlock 的末尾或特定指令之前添加多个指令. 它还支持常量折叠和重命名命名寄存器(请参阅 IRBuilder 的模板参数).</p> 
<p>下面的示例演示了 IRBuilder 的一个非常简单的用法, 在指令 pi 之前插入了三条指令. 前两条指令是 Call 指令, 第三条指令将这两个调用的返回值相乘.</p> 
<pre><code class="prism language-cpp">Instruction <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
IRBuilder<span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token function">Builder</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span>
CallInst<span class="token operator">*</span> callOne <span class="token operator">=</span> Builder<span class="token punctuation">.</span><span class="token function">CreateCall</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
CallInst<span class="token operator">*</span> callTwo <span class="token operator">=</span> Builder<span class="token punctuation">.</span><span class="token function">CreateCall</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Value<span class="token operator">*</span> result <span class="token operator">=</span> Builder<span class="token punctuation">.</span><span class="token function">CreateMul</span><span class="token punctuation">(</span>callOne<span class="token punctuation">,</span> callTwo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>下面的示例与上面的示例类似, 只是创建的 IRBuilder 将指令插入到BasicBlock pb的末尾.</p> 
<pre><code class="prism language-cpp">BasicBlock <span class="token operator">*</span>pb <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
IRBuilder<span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token function">Builder</span><span class="token punctuation">(</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>
CallInst<span class="token operator">*</span> callOne <span class="token operator">=</span> Builder<span class="token punctuation">.</span><span class="token function">CreateCall</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
CallInst<span class="token operator">*</span> callTwo <span class="token operator">=</span> Builder<span class="token punctuation">.</span><span class="token function">CreateCall</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Value<span class="token operator">*</span> result <span class="token operator">=</span> Builder<span class="token punctuation">.</span><span class="token function">CreateMul</span><span class="token punctuation">(</span>callOne<span class="token punctuation">,</span> callTwo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>有关 IRBuilder 的实际用途, 请参阅 <a href="https://llvm.org/docs/tutorial/LangImpl03.html" rel="nofollow">Kaleidoscope Tutorial</a>.</p> 
<h4><a id="622_Deleting_Instructions_1586"></a>6.2.2 Deleting Instructions</h4> 
<p>从形成基本块的现有指令序列中删除指令非常简单：只需调用指令的eraseFromParent()方法. 例如：</p> 
<pre><code class="prism language-cpp">Instruction <span class="token operator">*</span>I <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span>
I<span class="token operator">-&gt;</span><span class="token function">eraseFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这将将指令从其包含的基本块中取消链接并删除它. 如果您只想将指令从其包含的基本块中取消链接而不删除它, 可以使用 removeFromParent()方法.</p> 
<h4><a id="623_Replacing_an_Instruction_with_another_Value_1594"></a>6.2.3 Replacing an Instruction with another Value</h4> 
<h5><a id="6231_Replacing_individual_instructions_1595"></a>6.2.3.1 Replacing individual instructions</h5> 
<p>包含 “llvm/Transforms/Utils/BasicBlockUtils.h” 允许使用两个非常有用的替换函数： ReplaceInstWithValue 和 ReplaceInstWithInst</p> 
<h5><a id="6232_Deleting_Instructions_1597"></a>6.2.3.2 Deleting Instructions</h5> 
<ul><li>ReplaceInstWithValue：</li></ul> 
<p>该函数将给定指令的所有使用用一个值替换, 然后删除原始指令. 以下示例说明将分配内存给单个整数的特定 AllocaInst 的结果替换为整数的空指针.</p> 
<pre><code class="prism language-cpp">AllocaInst<span class="token operator">*</span> instToReplace <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
BasicBlock<span class="token double-colon punctuation">::</span>iterator <span class="token function">ii</span><span class="token punctuation">(</span>instToReplace<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">ReplaceInstWithValue</span><span class="token punctuation">(</span>ii<span class="token punctuation">,</span> <span class="token class-name">Constant</span><span class="token double-colon punctuation">::</span><span class="token function">getNullValue</span><span class="token punctuation">(</span><span class="token class-name">PointerType</span><span class="token double-colon punctuation">::</span><span class="token function">getUnqual</span><span class="token punctuation">(</span>Type<span class="token double-colon punctuation">::</span>Int32Ty<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>ReplaceInstWithInst：</li></ul> 
<p>该函数将特定指令替换为另一个指令, 将新指令插入到基本块中原指令的位置, 并替换任何使用原指令的地方为新指令. 以下示例说明用另一个AllocaInst替换一个AllocaInst.</p> 
<pre><code class="prism language-cpp">AllocaInst<span class="token operator">*</span> instToReplace <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
BasicBlock<span class="token double-colon punctuation">::</span>iterator <span class="token function">ii</span><span class="token punctuation">(</span>instToReplace<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">ReplaceInstWithInst</span><span class="token punctuation">(</span>instToReplace<span class="token operator">-&gt;</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ii<span class="token punctuation">,</span>
                    <span class="token keyword">new</span> <span class="token function">AllocaInst</span><span class="token punctuation">(</span>Type<span class="token double-colon punctuation">::</span>Int32Ty<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"ptrToReplacedInt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="6233_Replacing_multiple_uses_of_Users_and_Values_1619"></a>6.2.3.3 Replacing multiple uses of Users and Values</h5> 
<p>你可以使用 Value::replaceAllUsesWith 和 User::replaceUsesOfWith 来同时更改多个使用. 有关详细信息, 请参阅分别针对 <a href="https://llvm.org/doxygen/classllvm_1_1Value.html" rel="nofollow">Value类</a> 和 <a href="https://llvm.org/doxygen/classllvm_1_1User.html" rel="nofollow">User类</a> 的Doxygen文档.</p> 
<h4><a id="624_Deleting_GlobalVariables_1622"></a>6.2.4 Deleting GlobalVariables</h4> 
<p>从模块中删除全局变量与删除指令一样简单. 首先, 您必须拥有一个指向要删除的全局变量的指针. 然后, 您可以使用该指针将其从其父对象(即模块)中擦除. 例如：</p> 
<pre><code class="prism language-cpp">GlobalVariable <span class="token operator">*</span>GV <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span>
GV<span class="token operator">-&gt;</span><span class="token function">eraseFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="7_Threads_and_LLVM_1628"></a>7 Threads and LLVM</h2> 
<p>这个部分描述了 LLVM API 与多线程的交互, 包括客户应用程序的部分和 JIT 中的托管应用程序.</p> 
<p>需要注意的是, LLVM 对多线程的支持仍然相对较新. 在2.5版本之前, 支持线程化的托管应用程序的执行, 但不支持客户端对API的多线程访问. 虽然现在支持了这种用例, 但客户端必须遵循下面指定的准则, 以确保在多线程模式下正常运行.</p> 
<p>需要注意的是, 在类 Unix 平台上, LLVM 需要 GCC 的原子内置函数才能支持多线程操作. 如果在没有适当现代系统编译器的平台上需要一个支持多线程的 LLVM 版本, 可以考虑以单线程模式编译 LLVM 和 LLVM-GCC, 并使用生成的编译器构建支持多线程的 LLVM 副本.</p> 
<h3><a id="71_Ending_Execution_with_llvm_shutdown_1635"></a>7.1 Ending Execution with llvm_shutdown()</h3> 
<p>当你使用完LLVM API后, 应调用 llvm_shutdown() 来释放用于内部结构的内存.</p> 
<h3><a id="72_Lazy_Initialization_with_ManagedStatic_1639"></a>7.2 Lazy Initialization with ManagedStatic</h3> 
<p>ManagedStatic 是 LLVM 中使用的实用类, 用于实现静态资源的静态初始化, 例如全局类型表. 在单线程环境下, 它实现了简单的延迟初始化方案. 然而, 当 LLVM 编译时支持多线程时, 它使用双重检查锁定来实现线程安全的延迟初始化.</p> 
<h3><a id="73_Achieving_Isolation_with_LLVMContext_1642"></a>7.3 Achieving Isolation with LLVMContext</h3> 
<p>LLVMContext 是 LLVM API 中的一个不透明类, 客户端可以使用它在同一地址空间内同时操作多个独立的 LLVM 实例. 例如, 在一个假设的编译服务器中, 每个翻译单元的编译在概念上是独立于其他所有翻译单元的, 并且希望能够在独立的服务器线程上并发地编译传入的翻译单元. 幸运的是, LLVMContext存在就是为了实现这种情况！</p> 
<p>从概念上讲, LLVMContext 提供了隔离. LLVM 内存中的每个实体(模块、值、类型、常量等)都属于一个 LLVMContext. 不同上下文中的实体之间无法相互交互：不同上下文中的模块无法链接在一起, 函数无法添加到不同上下文的模块中, 等等. 这意味着只要没有两个线程在同一上下文中操作实体, 就可以同时在多个线程上安全地进行编译.</p> 
<p>实际上, API 中很少有地方需要显式指定 LLVMContext, 除了类型的 创建/查找 API 之外. 因为每个类型都携带对其所属上下文的引用, 大多数其他实体可以通过查看自己的类型来确定它们属于哪个上下文. 如果您正在向 LLVM IR 中添加新实体, 请尽量保持这种接口设计.</p> 
<h3><a id="74_Threads_and_the_JIT_1649"></a>7.4 Threads and the JIT</h3> 
<p>LLVM 的 “eager” 即时编译器在多线程程序中是安全的. 多个线程可以同时调用 ExecutionEngine::getPointerToFunction() 或 ExecutionEngine::runFunction() , 并且多个线程可以同时运行 JIT 生成的代码. 用户仍然必须确保在给定的 LLVMContext 中只有一个线程访问 IR, 而另一个线程可能正在修改它. 一种做法是在访问 JIT 之外的 IR 时始终持有 JIT 锁(JIT通过添加 CallbackVHs 来修改 IR). 另一种方法是只从 LLVMContext 的线程中调用 getPointerToFunction().</p> 
<p>当 JIT 配置为延迟编译(使用 ExecutionEngine::DisableLazyCompilation (false))时, 目前存在一个竞争条件, 即在延迟 JIT 编译函数后更新调用点. 如果确保一次只有一个线程可以调用任何特定的延迟存根, 并且 JIT 锁保护任何 IR 访问, 仍然可以在多线程程序中使用延迟 JIT , 但我们建议在多线程程序中只使用 eager JIT.</p> 
<h2><a id="8_Advanced_Topics_1654"></a>8 Advanced Topics</h2> 
<p>本节介绍了一些高级或晦涩的 API, 大多数客户端不需要了解. 这些 API 用于管理 LLVM 系统的内部工作, 并且只在特殊情况下需要访问.</p> 
<h3><a id="81_The_ValueSymbolTable_class_1657"></a>8.1 The ValueSymbolTable class</h3> 
<p>ValueSymbolTable(<a href="https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html" rel="nofollow">doxygen</a>)类提供了一个符号表, 用于为 <a href="https://llvm.org/docs/ProgrammersManual.html#c-function" rel="nofollow">Function</a>和 <a href="https://llvm.org/docs/ProgrammersManual.html#module" rel="nofollow">Module</a> 类命名值定义. 符号表可以为任何 <a href="https://llvm.org/docs/ProgrammersManual.html#value" rel="nofollow">Value</a> 提供名称.</p> 
<p>请注意, 大多数客户端不应直接访问 SymbolTable 类. 它仅在需要对符号表名称进行迭代的情况下使用, 这是非常特殊的用途. 请注意, 并非所有的 LLVM 值都有名称, 没有名称的值(即名称为空的值)不会存在于符号表中.</p> 
<p>符号表支持使用 begin/end/iterator 对符号表中的值进行迭代, 并支持查询特定名称是否在符号表中(使用lookup方法). ValueSymbolTable 类没有公开的修改器方法, 而是在值上调用 setName, 它会自动将其插入到适当的符号表中.</p> 
<h3><a id="82_The_User_and_owned_Use_classes_memory_layout_1664"></a>8.2 The User and owned Use classes’ memory layout</h3> 
<p>User(<a href="https://llvm.org/doxygen/classllvm_1_1User.html" rel="nofollow">doxygen</a>)类为表达User对其他Value实例的所有权提供了基础. Use(<a href="https://llvm.org/doxygen/classllvm_1_1Use.html" rel="nofollow">doxygen</a>)辅助类用于进行簿记并便于进行O(1)的添加和移除操作.</p> 
<h4><a id="821_Interaction_and_relationship_between_User_and_Use_objects_1667"></a>8.2.1 Interaction and relationship between User and Use objects</h4> 
<p>User(子类)可以选择在其内部包含 Use 对象, 或者通过指针引用它们. 混合变体(一些Use对象内联, 其他的挂在外部)是不可行的, 并且违反了同一 User 对象的 Use 对象形成连续数组的不变性.</p> 
<p>我们在User(子)类中有两种不同的布局：</p> 
<ul><li>布局a)</li></ul> 
<p>Use对象位于 User 对象内部(或者在固定偏移量处), 且它们的数量是固定的.</p> 
<ul><li>布局b)</li></ul> 
<p>Use 对象由 User 对象中的指向数组的指针引用, 并且它们的数量可能是可变的.</p> 
<p>从 v2.4 开始, 每个布局仍然具有指向 Use 数组开头的直接指针. 尽管对于布局a)来说这并非强制要求, 但出于简单起见, 我们保留了这种冗余. User 对象还存储了它拥有的 Use 对象的数量. (理论上, 可以根据下面介绍的方案计算出这些信息. )</p> 
<p>特殊形式的分配运算符(operator new)强制执行以下内存布局：</p> 
<ul><li>布局a)通过在 User 对象之前添加 <code>Use[]</code> 数组来建模.</li></ul> 
<pre><code class="prism language-css">...---.---.---.---.-------...
  | P | P | P | P | User
<span class="token string">''</span><span class="token string">'---'</span>---<span class="token string">'---'</span>---<span class="token string">'-------'</span><span class="token string">''</span>
</code></pre> 
<ul><li>布局 b) 通过指向 Use[] 数组.</li></ul> 
<pre><code class="prism language-css">.-------...
| User
<span class="token string">'-------'</span><span class="token string">''</span>
    |
    v
    .---.---.---.---...
    | P | P | P | P |
    <span class="token string">'---'</span>---<span class="token string">'---'</span>---<span class="token string">''</span>'
</code></pre> 
<p>(在上图中 ” P’ 代表 Use** 存储在 每 Use 成员中的对象 Use::Prev )</p> 
<h3><a id="83_Designing_Type_Hierarchies_and_Polymorphic_Interfaces_1703"></a>8.3 Designing Type Hierarchies and Polymorphic Interfaces(设计类型层次结构和多态接口)</h3> 
<p>有两种不同的设计模式在 C++ 程序中常常导致 使用虚函数调度 来处理 类型层次结构中的方法. 第一种是真正的 <code>类型层次结构</code>, 其中层次结构中的不同类型 模拟了特定功能 和 语义的子集, 并且这些类型严格嵌套在彼此之内. Value 或 Type 类型层次结构中可以看到很好的例子.</p> 
<p>第二种情况是希望 <code>动态调度一组多态接口实现</code>. 这种后一种用例可以通过定义一个所有实现都从中派生并重写的抽象接口基类来使用虚函数调度和继承来建模. 然而, 这种实现策略强制存在一个实际上并不有意义的 “is-a” 关系. 通常不存在一些有用的泛化嵌套层次结构, 代码可以与之交互并上下移动. 相反, 存在一个唯一的接口, 它在一系列实现之间进行调度.</p> 
<p>对于第二种用例, 首选的实现策略是 <code>通用编程</code>(有时称为“编译时鸭子类型”或“静态多态性”). 例如, 可以针对某个类型参数T实例化模板, 该类型参数与符合接口或概念的任何特定实现相一致. 一个很好的例子是任何模拟有向图中节点的类型的高度通用属性. LLVM 主要通过 <code>模板和通用编程</code> 来建模这些. 这些模板包括 <code>LoopInfoBase</code> 和 <code>DominatorTreeBase</code>. 当这种类型的多态性真正需要动态调度时, 可以使用称为 <code>基于概念的多态性</code> 的技术进行泛化. 该模式使用非常有限的 虚函数调度 来进行类型擦除, 并模拟模板的接口和行为. 在 <code>PassManager.h</code> 系统中可以找到此技术的示例, 并且 Sean Parent 在他的几次演讲和论文中对此进行了更详细的介绍：</p> 
<ul><li><a href="http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil" rel="nofollow">Inheritance Is The Base Class of Evil</a> - The GoingNative 2013演讲中描述了这种技术, 可能是开始的最佳位置.</li><li><a href="http://www.youtube.com/watch?v=_BpMYeUFXv8" rel="nofollow">Value Semantics and Concepts-based Polymorphism - The C++Now!</a> 2012演讲中更详细地描述了这种技术.</li><li><a href="http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations">Sean Parent的论文和演讲</a> - 一个GitHub项目, 包含指向幻灯片、视频和有时代码的链接.</li></ul> 
<p>在选择 <code>创建类型层次结构</code>(使用标记或虚拟调度)和 <code>使用模板</code> 或 <code>基于概念的多态性</code> 之间时, 请考虑是否存在某个抽象基类的细化, 在接口边界上它是一个语义上有意义的类型. 如果除了根抽象接口以外的任何更具体的内容在语义模型的部分扩展中是没有意义的, 那么您的用例可能更适合使用多态性, 并且应避免使用虚拟调度. 然而, 可能会有一些紧急情况需要使用其中一种技术.</p> 
<p>如果确实需要引入类型层次结构, 我们更倾向于使用 <code>显式封闭</code>的类型层次结构, 配合手动标记调度 and/or RTTI, 而不是在 C++ 代码中更常见的 <code>开放继承模型</code> 和 <code>虚拟调度</code>. 这是因为 LLVM 很少鼓励库的使用者扩展其核心类型, 并且利用了其 层次结构的封闭性 和 标记调度 的特性来生成更高效的代码. 我们还发现, 我们大部分对类型层次结构的使用更适合 <code>基于标记的模式匹配</code>, 而不是在共同接口上进行动态调度. 在 LLVM 中, 我们构建了自定义助手来促进这种设计. 请参阅本文档关于 isa 和 dyn_cast 的部分, 以及我们的详细文档, 描述了如何实现此模式以与 LLVM 助手一起使用.</p> 
<h3><a id="84_ABI_Breaking_Checks_1718"></a>8.4 ABI Breaking Checks</h3> 
<p>对改变 LLVM C++ ABI 的检查和断言是基于预处理符号 LLVM_ENABLE_ABI_BREAKING_CHECKS 的条件 - 使用 LLVM_ENABLE_ABI_BREAKING_CHECKS 构建的 LLVM 库与未定义该符号的构建的 LLVM 库不兼容. 默认情况下, 打开断言也会打开 LLVM_ENABLE_ABI_BREAKING_CHECKS, 因此默认的 <code>+Asserts</code> 构建与默认的 <code>-Asserts</code> 构建不兼容. 希望在 +Asserts 和 -Asserts 构建之间具有 ABI 兼容性的客户端应该使用 CMake 构建系统来独立设置 LLVM_ENABLE_ABI_BREAKING_CHECKS, 而不是使用 LLVM_ENABLE_ASSERTIONS.</p> 
<h2><a id="9_The_Core_LLVM_Class_Hierarchy_Reference_1721"></a>9 The Core LLVM Class Hierarchy Reference</h2> 
<p>#include “llvm/IR/Type.h”</p> 
<p>头文件来源: <a href="https://llvm.org/doxygen/Type_8h_source.html" rel="nofollow">Type.h</a></p> 
<p>Doxygen 信息: <a href="https://llvm.org/doxygen/classllvm_1_1Type.html" rel="nofollow">类型类</a></p> 
<p>核心 LLVM 类是表示要检查或转换的程序的主要手段. 核心 LLVM 类定义在 include/llvm/IR 目录下的头文件中, 实现在 lib/IR 目录中. 值得注意的是, 出于历史原因, 该库被称为 libLLVMCore.so, 而不是像你预期的那样叫做 libLLVMIR.so.</p> 
<h3><a id="91_Type__1730"></a>9.1 Type 类和派生类型</h3> 
<p>Type 是所有类型类的超类. 每个 Value 都有一个 Type. Type 不能直接实例化, 而是通过其子类来实例化. 某些原始类型(VoidType、LabelType、FloatType 和 DoubleType)有隐藏的子类. 它们被隐藏是因为除了与 Type 类提供的功能相同以外, 它们没有其他有用的功能, 只是为了与 Type 的其他子类区分开来.</p> 
<p>所有其他类型都是 DerivedType 的子类. 类型可以有名称, 但这不是必需的. 在任何时候, 一个给定形状的类型只有一个实例. 这允许通过 Type 实例的地址相等性执行类型的相等性. 也就是说, 给定两个 Type* 值, 如果指针相等, 则类型相等.</p> 
<h4><a id="911__1735"></a>9.1.1 重要的公共方法</h4> 
<ul><li>bool isIntegerTy() const：对于任何整数类型, 返回 true.</li><li>bool isFloatingPointTy()：如果是五种浮点类型之一, 则返回 true.</li><li>bool isSized()：如果类型的大小已知, 则返回 true. 没有大小的东西是抽象类型、标签和 void.</li></ul> 
<h4><a id="912__1740"></a>9.1.2 重要的派生类型</h4> 
<h5><a id="IntegerType_1741"></a>IntegerType</h5> 
<p>DerivedType 的子类, 表示任意位宽的整数类型. 可以表示介于IntegerType::MIN_INT_BITS(1)和 IntegerType::MAX_INT_BITS(约800万)之间的任何位宽.</p> 
<ul><li>static const IntegerType* get(unsigned NumBits)：获取指定位宽的整数类型.</li><li>unsigned getBitWidth() const：获取整数类型的位宽.</li></ul> 
<h5><a id="SequentialType_1746"></a>SequentialType</h5> 
<p>由 ArrayType 和 VectorType 派生的基类</p> 
<ul><li>const Type * getElementType() const：返回顺序类型中每个元素的类型.</li><li>uint64_t getNumElements() const：返回顺序类型中的元素数量.</li></ul> 
<h5><a id="ArrayType_1751"></a>ArrayType</h5> 
<p>SequentialType 的子类, 定义了数组类型的接口.</p> 
<h5><a id="PointerType_1754"></a>PointerType</h5> 
<p>Type的子类, 表示指针类型.</p> 
<h5><a id="VectorType_1757"></a>VectorType</h5> 
<p>SequentialType 的子类, 表示向量类型. 向量类型类似于 ArrayType, 但区别在于向量类型是一种一级类型, 而 ArrayType 不是. 向量类型用于向量操作, 通常是整数或浮点类型的小型向量.</p> 
<h5><a id="StructType_1760"></a>StructType</h5> 
<p>DerivedTypes 的子类, 表示结构体类型.</p> 
<h5><a id="FunctionType_1763"></a>FunctionType</h5> 
<p>DerivedTypes 的子类, 表示函数类型.</p> 
<ul><li>bool isVarArg() const：如果是可变参数函数, 则返回 true.</li><li>const Type * getReturnType() const：返回函数的返回类型.</li><li>const Type * getParamType(unsigned i)：返回第i个参数的类型.</li><li>const unsigned getNumParams() const：返回形式参数的数量.</li></ul> 
<h3><a id="92_Module__1771"></a>9.2 Module 类</h3> 
<p>#include “llvm/IR/Module.h”</p> 
<p>头文件来源：<a href="https://llvm.org/doxygen/Module_8h_source.html" rel="nofollow">Module.h</a></p> 
<p>doxygen 信息：<a href="https://llvm.org/doxygen/classllvm_1_1Module.html" rel="nofollow">Module 类</a></p> 
<p>Module 类代表 LLVM 程序中的顶层结构. 一个 LLVM 模块实际上可以是原始程序的一个翻译单元, 或者是链接器合并的多个翻译单元的组合. Module 类跟踪函数列表、全局变量列表和符号表. 此外, 它还包含一些有用的成员函数, 旨在简化常见操作.</p> 
<h4><a id="921_Module__1780"></a>9.2.1 Module 类的重要公共成员</h4> 
<ul><li>Module::Module(std::string name = “”)</li></ul> 
<p>构造一个 Module 很简单. 你可以选择为其提供一个名称(可能基于翻译单元的名称).</p> 
<ul><li>Module::iterator - Function 列表迭代器的类型定义</li></ul> 
<p>Module::const_iterator - const_iterator 的类型定义<br> <br>begin()、end()、size()、empty() 这些是转发方法, 可以方便地访问 Module 对象的 Function 列表内容.</p> 
<ul><li>Module::FunctionListType &amp;getFunctionList()</li></ul> 
<p>返回函数列表. 当需要更新列表或执行没有转发方法的复杂操作时, 需要使用此函数.</p> 
<hr> 
<ul><li> <p>Module::global_iterator - 全局变量列表迭代器的类型定义<br> <br>Module::const_global_iterator - const_iterator 的类型定义<br> <br>Module::insertGlobalVariable() - 向列表中插入一个全局变量.<br> <br>Module::removeGlobalVariable() - 从列表中移除一个全局变量.<br> <br>Module::eraseGlobalVariable() - 从列表中移除一个全局变量并删除它.<br> <br>global_begin()、global_end()、global_size()、global_empty()<br> 这些是转发方法, 可以方便地访问 Module 对象的 GlobalVariable 列表内容.</p> </li><li> <p>SymbolTable *getSymbolTable()</p> </li></ul> 
<p>返回此 Module 的符号表的引用.</p> 
<ul><li>Function *getFunction(StringRef Name) const</li></ul> 
<p>在 Module 的符号表中查找指定的函数. 如果不存在, 则返回空指针.</p> 
<ul><li>FunctionCallee getOrInsertFunction(const std::string &amp;Name, const FunctionType *T)</li></ul> 
<p>在 Module 的符号表中查找指定的函数. 如果不存在, 则添加该函数的外部声明并返回它. 注意, 已经存在的函数签名可能与请求的签名不匹配. 因此, 为了支持将结果直接传递给 EmitCall 的常见用法, 返回类型是一个结构体 {FunctionType *T, Constant FunctionPtr}, 而不仅仅是可能具有意外签名的 Function.</p> 
<ul><li>std::string getTypeName(const Type *Ty)</li></ul> 
<p>如果指定的 Type 在符号表中至少有一个条目, 则返回该条目. 否则返回空字符串.</p> 
<ul><li>bool addTypeName(const std::string &amp;Name, const Type *Ty)</li></ul> 
<p>在符号表中插入一个映射关系, 将 Name 映射到 Ty. 如果该名称已经存在条目, 则返回 true, 并且符号表不会被修改.</p> 
<h3><a id="93_Value__1824"></a>9.3 Value 类</h3> 
<p>#include “llvm/IR/Value.h”</p> 
<p>头文件来源：<a href="https://llvm.org/doxygen/Value_8h_source.html" rel="nofollow">Value.h</a></p> 
<p>doxygen 信息：<a href="https://llvm.org/doxygen/classllvm_1_1Value.html" rel="nofollow">Value 类</a></p> 
<p>Value 类是 LLVM 源代码中最重要的类. 它表示一个带类型的值, 可以用作指令的操作数等. Value 有许多不同的类型, 比如 Constants(常量)、Arguments(参数), 甚至 Instructions(指令)和 Functions(函数)也是 Value.</p> 
<p>在 LLVM 表示中, 一个特定的 Value 可能会在程序中被多次使用. 例如, 函数的传入参数(用 Argument 类的实例表示)被函数中引用该参数的每条指令都“使用”. 为了跟踪这种关系, Value 类维护了一个使用它的所有 User 的列表(User 类是 LLVM 图中可以引用 Value 的所有节点的基类). 这个使用列表是 LLVM 在程序中表示 def-use 信息的方式, 并且可以通过下面的 use_* 方法访问.</p> 
<p>因为 LLVM 是一种带类型的表示, 所以每个 LLVM Value 都有类型, 并且可以通过 getType() 方法获取该类型. 此外, 所有 LLVM 值都可以命名. Value 的“名称”是在 LLVM 代码中打印的符号字符串：</p> 
<pre><code class="prism language-llvm">%foo = add i32 1, 2
</code></pre> 
<p>此指令的名称是“foo”. 注意, 任何值的名称都可能丢失(为空字符串), 因此名称只应用于调试(使源代码更易读, 调试打印输出), 不应用于跟踪值或在值之间建立映射. 为此, 请使用指向 Value 自身的指针的 std::map.</p> 
<p>LLVM 的一个重要方面是 SSA 变量与生成它的操作之间没有区别. 因此, 对指令生成的值(或可用作传入参数的值)的任何引用都表示为直接指向表示该值的类的实例的指针. 尽管这可能需要一些适应, 但它简化了表示并使其更容易操作.</p> 
<h4><a id="931_Value__1843"></a>9.3.1 Value 类的重要公共成员</h4> 
<h5><a id="Valueuse_iterator___1844"></a>Value::use_iterator - 用于遍历使用列表的迭代器的类型定义</h5> 
<ul><li>Value::const_use_iterator - 用于遍历使用列表的常量迭代器的类型定义</li><li>unsigned use_size() - 返回值的使用者数量</li><li>bool use_empty() - 如果没有使用者则返回 true</li><li>use_iterator use_begin() - 获取指向使用列表开头的迭代器</li><li>use_iterator use_end() - 获取指向使用列表末尾的迭代器</li><li>User *use_back() - 返回列表中的最后一个元素</li></ul> 
<p>这些方法是访问 LLVM 中的 def-use 信息的接口. 与 LLVM 中的所有其他迭代器一样, 命名约定遵循 STL 定义的约定.</p> 
<h5><a id="Type_getType_const___Value__1854"></a>Type *getType() const - 返回该 Value 的类型.</h5> 
<ul><li>bool hasName() const</li><li>std::string getName() const</li><li>void setName(const std::string &amp;Name)</li></ul> 
<p>这组方法用于访问和分配给 Value 一个名称, 请注意上面的注意事项.</p> 
<h5><a id="void_replaceAllUsesWithValue_V_1861"></a>void replaceAllUsesWith(Value *V)</h5> 
<p>该方法遍历一个 Value 的使用列表, 将当前值的所有使用者替换为引用“V”. 例如, 如果检测到一条指令始终产生一个常量值(例如通过常量折叠), 可以使用以下方式将该指令的所有使用替换为该常量：</p> 
<pre><code class="prism language-llvm">Inst-&gt;replaceAllUsesWith(ConstVal);
</code></pre> 
<h3><a id="94_User__1867"></a>9.4 User 类</h3> 
<p>#include “llvm/IR/User.h”</p> 
<p>头文件来源：<a href="https://llvm.org/doxygen/User_8h_source.html" rel="nofollow">User.h</a></p> 
<p>doxygen 信息：<a href="https://llvm.org/doxygen/classllvm_1_1User.html" rel="nofollow">User 类</a></p> 
<p>父类：<a href="https://llvm.org/docs/ProgrammersManual.html#value" rel="nofollow">Value</a></p> 
<p>User 类是所有可能引用值的 LLVM 节点的通用基类. 它公开了一个“操作数”列表, 其中包含用户所引用的所有值. User 类本身是 Value 的子类.</p> 
<p>User 的操作数直接指向它所引用的 LLVM 值. 由于 LLVM 使用静态单赋值(SSA)形式, 因此只能引用一个定义, 从而允许进行直接连接. 这种连接提供了 LLVM 中的使用定义信息.</p> 
<h4><a id="941_User__1880"></a>9.4.1 User 类的重要公共成员</h4> 
<p>User 类以两种方式公开操作数列表：通过索引访问接口和基于迭代器的接口.</p> 
<h5><a id="Value_getOperandunsigned_i_1884"></a>Value *getOperand(unsigned i)</h5> 
<ul><li>unsigned getNumOperands()</li></ul> 
<p>这两个方法以便于直接访问的形式公开了 User 的操作数.</p> 
<h5><a id="Userop_iterator___typedef_1889"></a>User::op_iterator - 用于操作数列表的迭代器的 typedef</h5> 
<ul><li>op_iterator op_begin() - 获取指向操作数列表开头的迭代器.</li><li>op_iterator op_end() - 获取指向操作数列表末尾的迭代器.</li></ul> 
<p>这些方法共同构成了基于迭代器的 User 操作数接口</p> 
<h3><a id="95_Instruction_1895"></a>9.5 指令(Instruction)类</h3> 
<p>#include “llvm/IR/Instruction.h”</p> 
<p>头文件来源：<a href="https://llvm.org/doxygen/Instruction_8h_source.html" rel="nofollow">Instruction.h</a></p> 
<p>Doxygen 信息：指令类(<a href="https://llvm.org/doxygen/classllvm_1_1Instruction.html" rel="nofollow">Instruction Class</a>)</p> 
<p>超类：<a href="https://llvm.org/docs/ProgrammersManual.html#user" rel="nofollow">User</a>, <a href="https://llvm.org/docs/ProgrammersManual.html#value" rel="nofollow">Value</a></p> 
<p>指令类是所有 LLVM 指令的共同基类. 它提供了一些方法, 但是是一个非常常用的类. 指令类本身主要跟踪的数据是操作码(指令类型)和包含指令的基本块(BasicBlock)的信息. 为了表示特定类型的指令, 会使用指令类的许多子类之一.</p> 
<p>由于指令类是 User 类的子类, 因此可以像处理其他 User 类型一样访问其操作数(使用 getOperand()/getNumOperands() 和 op_begin()/op_end() 方法). Instruction 类的一个重要文件是 llvm/Instruction.def 文件. 该文件包含有关 LLVM 中各种不同类型指令的元数据. 它描述了用作操作码的枚举值(例如 Instruction::Add 和 Instruction::ICmp), 以及实现指令的具体子类(例如 BinaryOperator 和 CmpInst). 不幸的是, 由于该文件中使用了宏, 这些枚举值在 Doxygen 输出中无法正确显示.</p> 
<h4><a id="951_Instruction_1908"></a>9.5.1 指令(Instruction)类的重要子类：</h4> 
<ul><li>BinaryOperator</li></ul> 
<p>这个子类代表所有的二元操作指令, 其操作数必须是相同类型(除了比较指令).</p> 
<ul><li>CastInst</li></ul> 
<p>这个子类是 12 条类型转换指令的父类. 它提供了对类型转换指令的常见操作.</p> 
<ul><li>CmpInst</li></ul> 
<p>这个子类代表两个比较指令, 即 ICmpInst(整数操作数)和 FCmpInst(浮点数操作数).</p> 
<h4><a id="952__1922"></a>9.5.2 指令类的重要公共成员：</h4> 
<ul><li>BasicBlock *getParent()</li></ul> 
<p>返回包含该指令的基本块(BasicBlock).</p> 
<ul><li>bool mayWriteToMemory()</li></ul> 
<p>如果该指令写入内存(即调用、释放、调用函数或存储操作), 则返回 true.</p> 
<ul><li>unsigned getOpcode()</li></ul> 
<p>返回指令的操作码(opcode).</p> 
<ul><li>Instruction *clone() const</li></ul> 
<p>返回一个与原指令在所有方面都相同的指令实例, 唯一的区别是新实例没有父级(即没有嵌入到基本块中)并且没有名称.</p> 
<h3><a id="96_Constant__1939"></a>9.6 Constant 类及其子类</h3> 
<p>Constant 类是表示不同类型常量的基类. 它的子类包括 ConstantInt、ConstantArray 等, 用于表示各种类型的常量. GlobalValue 也是一个子类, 用于表示全局变量或函数的地址.</p> 
<h4><a id="961_Constant__1942"></a>9.6.1 Constant 的重要子类：</h4> 
<ul><li>ConstantInt：ConstantInt 是 Constant 的子类, 表示任意位宽的整数常量. 
  <ul><li>const APInt&amp; getValue() const：返回该常量的底层值, 即一个 APInt 值.</li><li>int64_t getSExtValue() const：通过符号扩展将底层 APInt 值转换为 int64_t. 如果 APInt 的值(而不是位宽)太大无法放入 int64_t 中, 将导致断言失败. 因此, 不建议使用此方法.</li><li>uint64_t getZExtValue() const：通过零扩展将底层 APInt 值转换为 uint64_t. 如果 APInt 的值(而不是位宽)太大无法放入 uint64_t 中, 将导致断言失败. 因此, 不建议使用此方法.</li><li>static ConstantInt* get(const APInt&amp; Val)：返回表示 Val 提供的值的 ConstantInt 对象. 类型隐含为与 Val 的位宽对应的 IntegerType.</li><li>static ConstantInt* get(const Type *Ty, uint64_t Val)：返回表示 Val 提供的值的 ConstantInt 对象, 其整数类型为 Ty.</li></ul> </li><li>ConstantFP：这个类表示浮点数常量. 
  <ul><li>double getValue() const：返回该常量的底层值.</li></ul> </li><li>ConstantArray：这个类表示常量数组. 
  <ul><li>const std::vector 
    <use>
      &amp;getValues() const：返回由组成此数组的组件常量的向量. 
    </use></li></ul> </li><li>ConstantStruct：这个类表示常量结构体. 
  <ul><li>const std::vector 
    <use>
      &amp;getValues() const：返回由组成此结构体的组件常量的向量. 
    </use></li></ul> </li><li>GlobalValue：这个类表示全局变量或函数. 无论哪种情况, 该值都是一个常量的固定地址(链接后).</li></ul> 
<h3><a id="97_GlobalValue__1957"></a>9.7 GlobalValue 类</h3> 
<p>#include “llvm/IR/GlobalValue.h”</p> 
<p>头文件源代码：<a href="https://llvm.org/doxygen/GlobalValue_8h_source.html" rel="nofollow">GlobalValue.h</a></p> 
<p>doxygen 信息：<a href="https://llvm.org/doxygen/classllvm_1_1GlobalValue.html" rel="nofollow">GlobalValue 类</a></p> 
<p>父类：<a href="https://llvm.org/docs/ProgrammersManual.html#constant" rel="nofollow">Constant</a>、<a href="https://llvm.org/docs/ProgrammersManual.html#user" rel="nofollow">User</a>、<a href="https://llvm.org/docs/ProgrammersManual.html#value" rel="nofollow">Value</a></p> 
<p>全局值(GlobalVariables 或 Functions)是唯一可以在所有函数体中可见的 LLVM 值. 由于它们在全局范围内可见, 它们也会与在不同翻译单元中定义的其他全局变量进行链接. 为了控制链接过程, GlobalValues 知道它们的链接规则. 具体来说, GlobalValues 知道它们是否具有内部或外部链接, 这由 LinkageTypes 枚举定义.</p> 
<p>如果 GlobalValue 具有内部链接(相当于 C 语言中的 static), 它对当前翻译单元之外的代码不可见, 并且不参与链接. 如果它具有外部链接, 它对外部代码可见, 并参与链接. 除了链接信息, GlobalValues 还跟踪它们当前所属的模块.</p> 
<p>因为 GlobalValues 是内存对象, 所以它们总是通过它们的地址引用. 因此, 全局的类型始终是指向其内容的指针. 在使用 GetElementPtrInst 指令时, 记住这一点很重要, 因为首先必须对该指针进行解引用. 例如, 如果你有一个 GlobalVariable(GlobalValue 的子类), 它是一个包含 24 个 int 的数组, 类型为 [24 x i32], 那么 GlobalVariable 是指向该数组的指针. 尽管该数组的第一个元素的地址和 GlobalVariable 的值相同, 但它们具有不同的类型. GlobalVariable 的类型是 [24 x i32], 第一个元素的类型是 i32. 因此, 访问全局值需要首先使用 GetElementPtrInst 解引用指针, 然后才能访问其元素. 这在 LLVM 语言参考手册中有解释.</p> 
<h4><a id="971_GlobalValue__1973"></a>9.7.1 GlobalValue 类的重要公共成员</h4> 
<h5><a id="bool_hasInternalLinkage_const_1974"></a>bool hasInternalLinkage() const</h5> 
<ul><li>bool hasExternalLinkage() const</li><li>void setInternalLinkage(bool HasInternalLinkage)</li></ul> 
<p>这些方法用于操作 GlobalValue 的链接特性.</p> 
<h5><a id="Module_getParent_1980"></a>Module *getParent()</h5> 
<p>该方法返回当前嵌入到的模块(Module)中的 GlobalValue.</p> 
<h3><a id="98_Function__1984"></a>9.8 Function 类</h3> 
<p>#include “llvm/IR/Function.h”</p> 
<p>头文件来源: <a href="https://llvm.org/doxygen/Function_8h_source.html" rel="nofollow">Function.h</a></p> 
<p>doxygen 信息: <a href="https://llvm.org/doxygen/classllvm_1_1Function.html" rel="nofollow">Function 类</a></p> 
<p>Superclasses: <a href="https://llvm.org/docs/ProgrammersManual.html#globalvalue" rel="nofollow">GlobalValue</a>, <a href="https://llvm.org/docs/ProgrammersManual.html#constant" rel="nofollow">Constant</a>, <a href="https://llvm.org/docs/ProgrammersManual.html#user" rel="nofollow">User</a>, <a href="https://llvm.org/docs/ProgrammersManual.html#value" rel="nofollow">Value</a></p> 
<p>Function 类表示 LLVM 中的单个过程. 它实际上是 LLVM 层次结构中比较复杂的类之一, 因为它必须跟踪大量的数据. Function 类记录了基本块(BasicBlocks)的列表、形式参数(Arguments)的列表和符号表(SymbolTable).</p> 
<p>基本块列表是 Function 对象中最常用的部分. 该列表对函数中的基本块施加了隐式的排序, 指示后端将如何布局代码. 此外, 第一个基本块是函数的隐式入口节点. 在 LLVM 中, 不能显式地跳转到该初始块. 没有隐式的退出节点, 实际上一个函数可能有多个退出节点. 如果基本块列表为空, 这表示该函数实际上是函数声明：函数的实际体尚未链接.</p> 
<p>除了基本块列表外, Function 类还跟踪函数接收的形式参数列表. 该容器管理参数节点的生命周期, 就像基本块列表对基本块的管理一样.</p> 
<p>符号表是 LLVM 中一个很少使用的特性, 只有在需要通过名称查找值时才会使用. 除此之外, 符号表在内部用于确保函数体中的指令、基本块或参数的名称不会冲突.</p> 
<p>请注意, Function 是一个 GlobalValue, 因此也是一个 Constant. 函数的值是其地址(链接后), 保证是常量.</p> 
<h4><a id="981_Function__2004"></a>9.8.1 Function 类的重要公共成员</h4> 
<ul><li>Function(const FunctionType Ty, LinkageTypes Linkage, const std::string &amp;N = “”, Module Parent = 0)</li></ul> 
<p>当需要创建新的函数并将其添加到程序中时使用的构造函数. 构造函数必须指定要创建的函数的类型以及函数应具有的链接类型. FunctionType 参数指定函数的形式参数和返回值. 可以使用相同的 FunctionType 值创建多个函数. Parent 参数指定函数所在的模块. 如果提供了此参数, 函数将自动插入到该模块的函数列表中.</p> 
<ul><li>bool isDeclaration()</li></ul> 
<p>返回函数是否定义了函数体. 如果函数是“external”(外部函数), 则它没有函数体, 因此必须通过与另一个翻译单元中定义的函数进行链接来解析.</p> 
<ul><li> <p>Function::iterator - 基本块列表迭代器的类型定义<br> <br>Function::const_iterator - 常量迭代器的类型定义<br> <br>begin()、end()、size()、empty()、insert()、splice()、erase()<br> 这些是转发方法, 便于访问 Function 对象的基本块列表的内容.</p> </li><li> <p>Function::arg_iterator - 形式参数列表迭代器的类型定义<br> <br>Function::const_arg_iterator - 常量迭代器的类型定义<br> <br>arg_begin()、arg_end()、arg_size()、arg_empty()<br> 这些是转发方法, 便于访问 Function 对象的形式参数列表的内容.</p> </li><li> <p>Function::ArgumentListType &amp;getArgumentList()</p> </li></ul> 
<p>返回形式参数的列表. 在需要更新列表或执行没有转发方法的复杂操作时, 使用此方法.</p> 
<ul><li>BasicBlock &amp;getEntryBlock()</li></ul> 
<p>返回函数的入口基本块. 由于函数的入口块始终是第一个块, 因此此方法返回 Function 的第一个块.</p> 
<ul><li> <p>Type *getReturnType()<br> <br>FunctionType *getFunctionType()<br> 遍历函数的类型并返回函数的返回类型, 或者返回实际函数的 FunctionType.</p> </li><li> <p>SymbolTable *getSymbolTable()</p> </li></ul> 
<p>返回该函数的符号表指针.</p> 
<h3><a id="99_GlobalVariable__2039"></a>9.9 GlobalVariable 类</h3> 
<p>#include “llvm/IR/GlobalVariable.h”</p> 
<p>头文件来源：<a href="https://llvm.org/doxygen/GlobalVariable_8h_source.html" rel="nofollow">GlobalVariable.h</a></p> 
<p>doxygen 信息：<a href="https://llvm.org/doxygen/classllvm_1_1GlobalVariable.html" rel="nofollow">GlobalVariable 类</a></p> 
<p>父类：<a href="https://llvm.org/docs/ProgrammersManual.html#globalvalue" rel="nofollow">GlobalValue</a>, <a href="https://llvm.org/docs/ProgrammersManual.html#constant" rel="nofollow">Constant</a>, <a href="https://llvm.org/docs/ProgrammersManual.html#user" rel="nofollow">User</a>, <a href="https://llvm.org/docs/ProgrammersManual.html#value" rel="nofollow">Value</a></p> 
<p>全局变量使用 GlobalVariable 类表示(surprise surprise). 与函数一样, GlobalVariable 也是 GlobalValue 的子类, 因此它们始终通过地址引用(全局值必须驻留在内存中, 因此它们的“名称”指的是它们的常量地址). 请参阅 GlobalValue 以了解更多信息. 全局变量可以具有初始值(必须是 Constant 类型), 如果它们具有初始值, 还可以标记为“常量”(表示它们在运行时不会更改).</p> 
<h4><a id="991_GlobalVariable__2051"></a>9.9.1 GlobalVariable 类的重要公共成员</h4> 
<ul><li>GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &amp;Linkage, Constant Initializer = 0, const std::string &amp;Name = “”, Module Parent = 0)</li></ul> 
<p>创建指定类型的新全局变量. 如果 isConstant 为 true, 则全局变量将被标记为程序中不可更改. Linkage 参数指定变量的链接类型(internal、external、weak、linkonce、appending). 如果链接是 InternalLinkage、WeakAnyLinkage、WeakODRLinkage、LinkOnceAnyLinkage 或 LinkOnceODRLinkage, 则生成的全局变量将具有内部链接. AppendingLinkage 将变量的所有实例(在不同的翻译单元中)连接到单个变量中, 但仅适用于数组. 有关链接类型的详细信息, 请参阅 LLVM 语言参考手册. 还可以为全局变量指定初始化器、名称和要放置变量的模块.</p> 
<ul><li>bool isConstant() const</li></ul> 
<p>如果这是一个在运行时不会修改的全局变量, 则返回 true.</p> 
<ul><li>bool hasInitializer()</li></ul> 
<p>如果此 GlobalVariable 具有初始化器, 则返回 true.</p> 
<ul><li>Constant *getInitializer()</li></ul> 
<p>返回 GlobalVariable 的初始值. 如果没有初始化器, 调用此方法是不合法的.</p> 
<h3><a id="910_BasicBlock__2068"></a>9.10 BasicBlock 类</h3> 
<p>#include “llvm/IR/BasicBlock.h”</p> 
<p>头文件来源：<a href="https://llvm.org/doxygen/BasicBlock_8h_source.html" rel="nofollow">BasicBlock.h</a></p> 
<p>doxygen 信息：<a href="https://llvm.org/doxygen/classllvm_1_1BasicBlock.html" rel="nofollow">BasicBlock 类</a></p> 
<p>父类：<a href="https://llvm.org/docs/ProgrammersManual.html#value" rel="nofollow">Value</a></p> 
<p>该类表示代码中的 <code>单入口单出口区域</code>, 编译器社区通常称之为基本块(basic block). BasicBlock 类维护了一个指令列表, 这些指令构成了基本块的主体. 根据语言定义, 指令列表的最后一个元素始终是终止指令.</p> 
<p>除了跟踪构成基本块的指令列表之外, BasicBlock 类还记录了所嵌入的函数.</p> 
<p>请注意, 基本块本身是 Value 类的实例, 因为它们被诸如分支指令和 switch 表中的指令引用. 基本块的类型为 label.</p> 
<h4><a id="9101_BasicBlock__2084"></a>9.10.1 BasicBlock 类的重要公共成员</h4> 
<ul><li>BasicBlock(const std::string &amp;Name = “”, Function *Parent = 0)</li></ul> 
<p>基本块构造函数用于创建要插入到函数中的新基本块. 构造函数可选地接受新块的名称和要插入的函数. 如果指定了 Parent 参数, 新的 BasicBlock 会自动插入到指定函数的末尾；如果未指定, 则必须手动将 BasicBlock 插入到函数中.</p> 
<ul><li>BasicBlock::iterator - 指令列表的迭代器的类型定义<br> <br>BasicBlock::const_iterator - const_iterator 的类型定义.<br> <br>begin()、end()、front()、back()、size()、empty()、splice() - 用于访问指令列表的 STL 风格函数.</li></ul> 
<p>这些方法和类型定义是具有与同名标准库方法相同语义的转发函数. 这些方法以易于操作的方式暴露基本块的底层指令列表.</p> 
<ul><li>Function *getParent()</li></ul> 
<p>返回指向包含该基本块的函数的指针, 如果基本块没有所属函数, 则返回空指针.</p> 
<ul><li>Instruction *getTerminator()</li></ul> 
<p>返回指向出现在 BasicBlock 末尾的终止指令的指针. 如果没有终止指令, 或者块中的最后一条指令不是终止指令, 则返回空指针.</p> 
<h3><a id="911_Argument__2104"></a>9.11 Argument 类</h3> 
<p>Argument 类是 Value 类的子类, 定义了函数的传入形式参数的接口. 函数维护了其形式参数的列表. 参数具有指向父函数的指针.</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5273414177cb49360beb3c4ce8a2902e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux MTD子系统(二)——mtdblock驱动分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7825e3ae7c6b2021907b080f1f93800a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ansible 的脚本 --- playbook 剧本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>