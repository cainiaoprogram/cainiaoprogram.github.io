<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>扫雷游戏【敢看完就敢教会你】------- C语言 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="扫雷游戏【敢看完就敢教会你】------- C语言" />
<meta property="og:description" content="目录
一、扫雷游戏介绍
二、实现游戏的前期工作
1. 游戏的原理&amp;逻辑
2. 初始化雷区
三、代码实现游戏
1. 实现 test.c 文件
2. 实现 Mine_Sweeper.c 文件
2.1 雷区初始化函数
2.2 埋地雷函数
2.3 展示雷区函数
2.4 排查地雷函数
2.4.1 排查地雷子函数
2.4.2 标记地雷子函数
2.4.3 取消标记子函数
3. 完整代码 四、游戏展示 一、扫雷游戏介绍 《扫雷》是一款大众类的益智小游戏，于1992年发行。游戏目标是在最短的时间内根据点击格子出现的数字找出所有非地雷的格子，同时避免踩到地雷，踩到一个地雷全盘皆输。
玩家需要在雷区中，将所有地雷一一排查出来，同时扫雷游戏提供了插旗标记地雷和取消插旗标记地雷的功能。
本篇博客将会与大家一起学习，如何运用我们所学的C语言知识，来实现这一经典而富有娱乐性的小游戏，冲🐛🐛🐛！！！
※ ( 本篇博客实现的是 9×9 的扫雷游戏，在雷区放置 10 个地雷 )
※ ( 本篇博客采用多文件的方式来实现扫雷游戏 )
test.c - - - - 测试游戏的逻辑
MineSweeper.c - - - - 游戏代码的实现
MineSweeper.h - - - - 游戏代码的声明 ( 函数声明，符号定义 )" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/851c17a25fc6b2e1409da2e469237e35/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-08T21:55:32+08:00" />
<meta property="article:modified_time" content="2022-11-08T21:55:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">扫雷游戏【敢看完就敢教会你】------- C语言</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E4%BB%8B%E7%BB%8D" rel="nofollow">一、扫雷游戏介绍</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E7%9A%84%E5%89%8D%E6%9C%9F%E5%B7%A5%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E7%9A%84%E5%89%8D%E6%9C%9F%E5%B7%A5%E4%BD%9C" rel="nofollow">二、实现游戏的前期工作</a></p> 
<p id="1.%C2%A0%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8E%9F%E7%90%86%26%E9%80%BB%E8%BE%91-toc" style="margin-left:40px;"><a href="#1.%C2%A0%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8E%9F%E7%90%86%26%E9%80%BB%E8%BE%91" rel="nofollow">1.  游戏的原理&amp;逻辑</a></p> 
<p id="2.%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B7%E5%8C%BA-toc" style="margin-left:40px;"><a href="#2.%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B7%E5%8C%BA" rel="nofollow">2.  初始化雷区</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F" rel="nofollow">三、代码实现游戏</a></p> 
<p id="1.%C2%A0%20%E5%AE%9E%E7%8E%B0%20test.c%20%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#1.%C2%A0%20%E5%AE%9E%E7%8E%B0%20test.c%20%E6%96%87%E4%BB%B6" rel="nofollow">1.  实现 test.c 文件</a></p> 
<p id="2.%C2%A0%20%E5%AE%9E%E7%8E%B0%20Mine_Sweeper.c%20%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#2.%C2%A0%20%E5%AE%9E%E7%8E%B0%20Mine_Sweeper.c%20%E6%96%87%E4%BB%B6" rel="nofollow">2.  实现 Mine_Sweeper.c 文件</a></p> 
<p id="2.1%C2%A0%20%E9%9B%B7%E5%8C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.1%C2%A0%20%E9%9B%B7%E5%8C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0" rel="nofollow">2.1  雷区初始化函数</a></p> 
<p id="2.2%C2%A0%20%E5%9F%8B%E5%9C%B0%E9%9B%B7%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.2%C2%A0%20%E5%9F%8B%E5%9C%B0%E9%9B%B7%E5%87%BD%E6%95%B0" rel="nofollow">2.2  埋地雷函数</a></p> 
<p id="2.3%C2%A0%20%E5%B1%95%E7%A4%BA%E9%9B%B7%E5%8C%BA%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.3%C2%A0%20%E5%B1%95%E7%A4%BA%E9%9B%B7%E5%8C%BA%E5%87%BD%E6%95%B0" rel="nofollow">2.3  展示雷区函数</a></p> 
<p id="2.4%C2%A0%20%E6%8E%92%E6%9F%A5%E5%9C%B0%E9%9B%B7%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.4%C2%A0%20%E6%8E%92%E6%9F%A5%E5%9C%B0%E9%9B%B7%E5%87%BD%E6%95%B0" rel="nofollow">2.4  排查地雷函数</a></p> 
<p id="2.4.1%C2%A0%20%E6%8E%92%E6%9F%A5%E5%9C%B0%E9%9B%B7%E5%AD%90%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.4.1%C2%A0%20%E6%8E%92%E6%9F%A5%E5%9C%B0%E9%9B%B7%E5%AD%90%E5%87%BD%E6%95%B0" rel="nofollow">2.4.1  排查地雷子函数</a></p> 
<p id="2.4.2%C2%A0%20%E6%A0%87%E8%AE%B0%E5%9C%B0%E9%9B%B7%E5%AD%90%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.4.2%C2%A0%20%E6%A0%87%E8%AE%B0%E5%9C%B0%E9%9B%B7%E5%AD%90%E5%87%BD%E6%95%B0" rel="nofollow">2.4.2  标记地雷子函数</a></p> 
<p id="2.4.3%C2%A0%20%E5%8F%96%E6%B6%88%E6%A0%87%E8%AE%B0%E5%AD%90%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.4.3%C2%A0%20%E5%8F%96%E6%B6%88%E6%A0%87%E8%AE%B0%E5%AD%90%E5%87%BD%E6%95%B0" rel="nofollow">2.4.3  取消标记子函数</a></p> 
<p id="3.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:40px;"><a href="#3.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">3.  完整代码 </a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%B8%B8%E6%88%8F%E5%B1%95%E7%A4%BA%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%B8%B8%E6%88%8F%E5%B1%95%E7%A4%BA%C2%A0" rel="nofollow">四、游戏展示 </a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E4%BB%8B%E7%BB%8D"><span style="color:#956fe7;">一、扫雷游戏介绍</span></h2> 
<blockquote> 
 <p>《扫雷》是一款大众类的益智小游戏，于1992年发行。游戏目标是在最短的时间内根据点击格子出现的数字找出所有非地雷的格子，同时避免踩到地雷，踩到一个地雷全盘皆输。</p> 
 <p></p> 
 <p>玩家需要在雷区中，将<strong>所有地雷一一排查出来</strong>，同时扫雷游戏提供了<strong>插旗标记地雷</strong>和<strong>取消插旗标记地雷</strong>的功能。</p> 
 <p></p> 
 <p>本篇博客将会与大家一起学习，如何运用我们所学的<strong>C语言</strong>知识，来实现这一经典而富有娱乐性的小游戏，冲🐛🐛🐛！！！</p> 
 <p></p> 
 <p><span style="color:#be191c;"><strong>※ ( 本篇博客实现的是 9×9 的扫雷游戏，在雷区放置 10 个地雷 )</strong></span></p> 
 <p><span style="color:#be191c;"> </span></p> 
 <p><strong><span style="color:#be191c;">※ ( 本篇博客采用多文件的方式来实现扫雷游戏 )</span></strong></p> 
 <p></p> 
 <p><span style="color:#be191c;"><strong>                      </strong></span><span style="color:#be191c;"><strong>test.c  - - - -  测试游戏的逻辑</strong></span></p> 
 <p><span style="color:#be191c;"><strong>      MineSweeper.c  - - - -  游戏代码的实现</strong></span></p> 
 <p><span style="color:#be191c;"><strong>      MineSweeper.h  - - - -  游戏代码的声明 ( 函数声明，符号定义 )</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="380" src="https://images2.imgbox.com/50/ec/UQ3C2UBF_o.gif" width="328"></p> 
<h2></h2> 
<h2 id="%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E7%9A%84%E5%89%8D%E6%9C%9F%E5%B7%A5%E4%BD%9C"><span style="color:#956fe7;">二、实现游戏的前期工作</span></h2> 
<h3 id="1.%C2%A0%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8E%9F%E7%90%86%26%E9%80%BB%E8%BE%91"><span style="color:#0d0016;">1.  游戏的原理&amp;逻辑</span></h3> 
<p>让我们把目光聚焦到上面的<strong>GIF</strong>图，首先映入眼帘的一定是 <strong>9×9 </strong>的雷区，这<strong> 81 </strong>个被遮盖的格子，等待被我们翻开。</p> 
<p>当我们随机的点击其中的格子时，会出现以下三种情况：</p> 
<blockquote> 
 <p><strong>① 当翻开的格子是地雷时，玩家被炸“死”，游戏结束；</strong></p> 
 <p></p> 
 <p><strong>② 当翻开的格子不是地雷时，该格子会显示周围的 8 个格子存在的地雷的个数；</strong></p> 
 <p></p> 
 <p><strong>③ 当翻开的格子不是地雷，且周围 8 个格子不存在地雷时，雷区会一下子翻开一片区域；</strong></p> 
</blockquote> 
<p>如此反复，直到玩家把雷区所有的地雷都排查出来，排雷成功，玩家获胜，游戏结束。</p> 
<hr> 
<p>游戏的原理和逻辑捋的差不多了，一个新的问题也随之被抛出。我们如何实现这样一个可以将每个格子都一一翻转的雷区呢？</p> 
<p>首先我们会将 <strong>9×9 </strong>的雷区与二维数组联想起来，能不能用二维数组实现那？一个二维数组能实现像游戏中那样每个格子都能翻转的雷区吗？细想好像一个二维数组实现起来比较困难。</p> 
<p>一个二维数组不行，那两个呢？</p> 
<p><strong>答案是肯定的，本篇博客我们将使用两个二维数组来实现游戏里的雷区。</strong></p> 
<blockquote> 
 <p><strong>一个二维数组来设置雷区，即存放地雷，另外一个二维数组展示给玩家看，即实现翻转格子功能，达到与游戏相同的效果。</strong></p> 
</blockquote> 
<p></p> 
<h3 id="2.%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B7%E5%8C%BA">2.  初始化雷区</h3> 
<p><span style="color:#4da8ee;"><strong>| 原理&amp;逻辑 |</strong></span></p> 
<blockquote> 
 <p>首先我们要先创建两个二维数组，一个用来设置地雷，另一个用来展示给玩家看。</p> 
 <p></p> 
 <p>对于设置地雷的二维数组，我们规定：<strong>用字符 ‘0’ 和 ‘1’ 来填埋地雷，字符 ‘0’ 代表无地雷，相对应的，字符 ‘1’ 代表有地雷。</strong></p> 
 <p></p> 
 <p>对于展示于玩家的二维数组，我们规定：<strong>在格子未被翻转前，用字符 ‘*’ 来对其进行遮盖，而格子翻转以后，该格子则显示周围的 8 个格子存在的地雷的个数。</strong></p> 
</blockquote> 
<p>讲到这里，又引出了一个新的问题。二维数组设置成几行几列合适？</p> 
<p>有的小兄弟可能会说，这篇博客开头不是说要实现 <strong>9×9 </strong>的扫雷游戏吗，那就设置成 9 行 9 列！</p> 
<p>但<strong> 9×9 </strong>的二维数组真的万无一失吗？这就是我们接下来要和各位一起探讨的问题。</p> 
<hr> 
<p>我们上面规定了，若翻转的格子不是地雷，则显示该格子周围 8 个格子存在地雷的个数，这一操作对雷区中间区域的格子可能不会有问题，但对雷区边界的格子执行这一操作可能会导致数组的越界访问，有图有真相，请看下面的图例。</p> 
<p><span style="color:#1c7331;"><strong>| 图例 |</strong></span></p> 
<p class="img-center"><img alt="" height="384" src="https://images2.imgbox.com/57/20/qKxUae3B_o.png" width="685"></p> 
<p>由图例可以得出结论，实现 <strong>9×9 </strong>的扫雷游戏，创建一个 9 行 9 列的二维数组并不合适。</p> 
<p>既然对 9 行 9 列的二维数组的边界元素进行操作时，会导致数组越界访问，那我们干脆就直接<strong>将二维数组扩大一圈</strong>，将那些会导致越界访问的范围包括在数组内，从源头上解决问题，这是一个非常巧妙的办法！</p> 
<p><span style="color:#1c7331;"><strong>| 图例 |</strong></span></p> 
<p class="img-center"><img alt="" height="352" src="https://images2.imgbox.com/81/dd/HzJai9TX_o.png" width="683"></p> 
<p>弄明白了两个二维数组创建的逻辑后，接下来就是用代码一步一步的实现我们的游戏了。</p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F"><span style="color:#956fe7;">三、代码实现游戏</span></h2> 
<h3 id="1.%C2%A0%20%E5%AE%9E%E7%8E%B0%20test.c%20%E6%96%87%E4%BB%B6">1.  实现 test.c 文件</h3> 
<blockquote> 
 <p>当玩家进入游戏后，程序会向玩家展示一个菜单，供玩家选择程序 ( <strong>1.玩游戏  0.退出游戏</strong> )，玩家做出选择后，可进入相应的程序。当一把游戏结束后，玩家不过瘾，还能继续选择玩游戏，直到玩家不想玩时，可选择退出。</p> 
 <p></p> 
 <p><strong>①</strong>  对于 <strong>“玩家做出选择后，可进入相应的程序” </strong>这句话，我们会情不自禁的联想 <strong>switch </strong>语句。</p> 
 <p></p> 
 <p><strong>②</strong>  对于 <strong>“当一把游戏结束后，玩家不过瘾，还能继续选择玩游戏，直到玩家不想玩时，可选择退出” </strong>这句话，我们联想到了 <strong>do while </strong>语句，玩家进入程序就先展示菜单，待玩家做出选择后再判断是继续程序，还是结束程序。</p> 
</blockquote> 
<p><span style="color:#ff9900;"><strong>| test.c 代码 |</strong></span></p> 
<pre><code class="language-cpp">#include"Mine_Sweeper.h"

void MENU()
{
	printf("******************************\n");
	printf("*********   1.PLAY   *********\n");
	printf("*********   0.EXIT   *********\n");
	printf("******************************\n");
}

void Game()
{
	char mine[ROWS][COLS] = { 0 };       // mine 数组用于埋地雷
	char show[ROWS][COLS] = { 0 };       // show 数组用于展示于玩家
	InitBoard(mine, ROWS, COLS, '0');
	SetMine(mine, ROW, COL);
	InitBoard(show, ROWS, COLS, '*');
	DisplayBoard(show, ROW, COL);
	CheckMine(mine, show, ROW, COL);
}

int main()
{
	srand((unsigned int)time(NULL));       //这一语句是为了埋地雷，后文会讲解
	int input = 0;
	do
	{
		MENU();
		printf("\n请选择程序&gt;&gt;");
		scanf("%d", &amp;input);
		system("cls");       //这一语句是为了优化游戏界面
		switch (input)
		{
		case 1:
			Game();
			break;
		case 0:
			printf("\n&lt;退出游戏&gt;\n\n");
			break;
		default:
			printf("\n&lt;选择错误，请重新选择&gt;\n\n");
			break;
		}
	} while (input);
	return 0;
}</code></pre> 
<p> 眼神比较犀利的小兄弟可能会发现，上面的代码段中 <strong>Game </strong>函数里存在 <strong>“ROW，COL，ROWS，COLS”</strong>，那这些代表什么意义呢？再仔细观察，我们可以发现<strong> test.c </strong>文件只包含了一个头文件 <strong>"Mine_Sweeper.h"</strong>，而 <strong>“ROWS，COLS，ROW，COL” </strong>就是在头文件中用 <strong>#define </strong>定义的常量名。<strong>( ROW 代表常量 9，COL 代表常量 9，ROWS 代表 ROW + 2，即常量 11，COLS 代表 COL + 2，即常量 11 )</strong></p> 
<p><span style="color:#ff9900;"><strong>| MineSweeper.h 代码 |</strong></span></p> 
<pre><code class="language-cpp">#pragma once

#define ROW 9       //二维数组显示行数
#define COL 9       //二维数组显示列数
#define ROWS ROW+2       //二维数组实际行数
#define COLS COL+2       //二维数组实际列数
#define MINE 10       //地雷个数

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;

void InitBoard(char board[ROWS][COLS], int rows, int cols, char set);       //初始化二维数组的函数声明

void SetMine(char board[ROWS][COLS], int row, int col);       //埋地雷的函数声明

void DisplayBoard(char board[ROWS][COLS], int row, int col);       //展示雷区的函数声明

void CheckMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);       //玩家排查地雷的函数声明</code></pre> 
<p></p> 
<h3 id="2.%C2%A0%20%E5%AE%9E%E7%8E%B0%20Mine_Sweeper.c%20%E6%96%87%E4%BB%B6">2.  实现 Mine_Sweeper.c 文件</h3> 
<h4 id="2.1%C2%A0%20%E9%9B%B7%E5%8C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0">2.1  雷区初始化函数</h4> 
<p><span style="color:#ff9900;"><strong>| 代码 |</strong></span></p> 
<pre><code class="language-cpp">void InitBoard(char board[ROWS][COLS], int rows, int cols, char set)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; rows; i++)
	{
		for (j = 0; j &lt; cols; j++)
		{
			board[i][j] = set;
		}
	}
}</code></pre> 
<blockquote> 
 <p>本篇博客在讲解初始化雷区的原理和逻辑处已经规定了，用 <strong>‘0’</strong> 和 <strong>‘1’ </strong>对二维数组 <strong>mine </strong>进行初始化，用<strong> ‘*’ </strong>对二维数组 <strong>show </strong>进行初始化。</p> 
 <p>在调用此函数的同时将 <strong>数组名 数组行数 数组列数 初始化字符 </strong>作为函数参数进行传参。该函数对目标数组进行遍历，且将每个元素赋值，从而达到雷区初始化的效果。</p> 
</blockquote> 
<hr> 
<h4 id="2.2%C2%A0%20%E5%9F%8B%E5%9C%B0%E9%9B%B7%E5%87%BD%E6%95%B0">2.2  埋地雷函数</h4> 
<p><strong><span style="color:#ff9900;">| 代码 |</span></strong></p> 
<pre><code class="language-cpp">void SetMine(char board[ROWS][COLS], int row, int col)
{
	int count = MINE;       // count 记录地雷的个数
	while (count)       //循环地雷数量次，则埋下地雷数量个地雷
	{
		int x = rand() % row + 1;       //获取随机数，且使随机数的范围为 1~9，作为行坐标
		int y = rand() % col + 1;       //获取随机数，且使随机数的范围为 1~9，作为列坐标

        //判断坐标是否已经被埋了地雷
		if (board[x][y] == '0')       //坐标元素为字符 '0' 则表示未被埋地雷
		{
			board[x][y] = '1';       //埋地雷
			count--;       //每循环一次，则埋下一个地雷，地雷数量减1
		}
	}
}</code></pre> 
<blockquote> 
 <p>该代码需要获取随机数，以作为埋地雷的 <strong>行坐标 </strong>和 <strong>列坐标</strong>，获取随机数则需要调用库函数 <strong>rand </strong>函数，<span style="color:#fe2c24;">注意</span>，在调用 <strong>rand </strong>函数前还要调用库函数 <strong>srand </strong>函数，而程序中获取随机数只需要调用一次 <strong>srand </strong>函数即可，所以我们把 <strong>srand </strong>函数的调用置于 <strong>test.c </strong>文件中的 <strong>主函数</strong> 的开头位置，我们使用时间戳作为 <strong>srand </strong>函数的参数。</p> 
 <p></p> 
 <p><span style="color:#be191c;">※  <strong>srand</strong> 函数和 <strong>rand</strong> 函数都需要程序包含头文件 <strong>&lt;stdlib.h&gt; </strong></span></p> 
 <p><span style="color:#be191c;">※  <strong>time </strong>函数则需要程序包含 <strong>&lt;time.h&gt;</strong></span></p> 
</blockquote> 
<hr> 
<h4 id="2.3%C2%A0%20%E5%B1%95%E7%A4%BA%E9%9B%B7%E5%8C%BA%E5%87%BD%E6%95%B0">2.3  展示雷区函数</h4> 
<p><span style="color:#ff9900;"><strong>| 代码 |</strong></span></p> 
<pre><code class="language-cpp">void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	printf("\n----MineSweeper----\n");       //作用是使游戏界面更美观
	for (j = 0; j &lt;= col; j++)       //打印每一列的坐标数字，便于玩家辨别
	{
		printf("%d ", j);
	}
	printf("\n");
	for (i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);       //打印每一行的坐标数字，便于玩家辨别
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("----MineSweeper----\n\n");       //作用是使游戏界面更美观
}</code></pre> 
<blockquote> 
 <p>在向玩家展示雷区时，可以将雷区的行坐标与列坐标预先打印出来，给予玩家更好的游戏体验。</p> 
 <p>该函数通过对二维数组的遍历打印，向玩家展示雷区，值得注意的是，本篇博客实现的是 <strong>9×9 </strong>的扫雷游戏，也就是说玩家看到的是 9 行 9 列的雷区，所以我们使用代码遍历二维数组时，<span style="color:#fe2c24;"><strong>要注意行和列都应该从 1 开始打印 ( i = 1   j = 1 )，以打印到 ROW 和 COL 为截至条件 ( i &lt;= ROW   j &lt;= COL )。</strong></span></p> 
 <p></p> 
 <p><span style="color:#be191c;"><strong>※  ( 该函数中 i &lt;= row   j &lt;= col，并不是书写错误，row 和 col 是函数的形参名，分别接收调用函数时传来的 ROW 和 COL )</strong></span></p> 
</blockquote> 
<p><span style="color:#1c7331;"><strong>| 效果展示 |</strong></span></p> 
<p class="img-center"><img alt="" height="459" src="https://images2.imgbox.com/e2/a0/2fGYE8dE_o.png" width="683"></p> 
<hr> 
<h4 id="2.4%C2%A0%20%E6%8E%92%E6%9F%A5%E5%9C%B0%E9%9B%B7%E5%87%BD%E6%95%B0">2.4  排查地雷函数</h4> 
<blockquote> 
 <p>做完以上准备工作后，从这里开始才是真正意义上的开始扫雷。</p> 
 <p>当玩家选择玩游戏时，程序会再次向玩家展示一个菜单，供玩家选择程序 ( <strong>1.排查地雷  2.标记地雷  3.取消标记</strong> )，我们分别用三个函数去实现这三个功能。</p> 
 <p></p> 
 <p><span style="color:#be191c;"><strong>※  ( 该函数由多个子函数嵌套调用而成 )</strong></span></p> 
</blockquote> 
<p><span style="color:#ff9900;"><strong>| 代码 |</strong></span></p> 
<pre><code class="language-cpp">void menu()
{
	printf("********************************\n");
	printf("*********   1.CHECK    *********\n");
	printf("*********   2.MARK     *********\n");
	printf("*********   3.UNMARK   *********\n");
	printf("********************************\n");

}

void CheckMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int ret = 0;       // ret 用来判断玩家是否踩到地雷 
	int win = 0;       // win 用来判断玩家是否获胜
	int input = 0;
	do
	{
		menu();       //菜单函数
		printf("\n请选择程序&gt;&gt;");
		scanf("%d", &amp;input);
		switch (input)
		{
		case 1:
			if (win &lt; row * col - MINE)       //讲解点
			{
				ret = Check(mine, show, row, col, &amp;win);       //要将 win 的地址一同作为参数进行传参
				if (ret == 1)       // 玩家踩到地雷，返回上一层函数
				{
					return;
				}
			}
			if (win == row * col - MINE)       //讲解点
			{
				system("cls");
				printf("&lt;恭喜你，排雷成功&gt;\n");
				DisplayBoard(mine, row, col);       //向玩家展示雷区的地雷布局
				return;
			}
			break;
		case 2:
			Mark(show, row, col);       //标记地雷是展示给玩家看的，所以将 show 数组作为参数进行传参
			break;
		case 3:
			UnMark(show, row, col);       //取消标记地雷也是展示给玩家看的，所以也是将 show 数组作为参数进行传参
			break;
		default:
			printf("\n&lt;选择错误，请重新选择&gt;\n\n");
			break;
		}
		system("cls");       //作用是清楚屏幕上的内容，使游戏界面更美观
		DisplayBoard(show, row, col);
	} while (input);
}</code></pre> 
<p><span style="color:#1c7331;"><strong>| 讲解点 |</strong></span></p> 
<p> </p> 
<p class="img-center"><img alt="" height="520" src="https://images2.imgbox.com/11/42/dHy3Z1oP_o.png" width="623"></p> 
<h4 id="2.4.1%C2%A0%20%E6%8E%92%E6%9F%A5%E5%9C%B0%E9%9B%B7%E5%AD%90%E5%87%BD%E6%95%B0">2.4.1  排查地雷子函数</h4> 
<p><span style="color:#ff9900;"><strong>| 代码 |</strong></span></p> 
<pre><code class="language-cpp">int Check(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col, int* win)
{
	int x = 0;
	int y = 0;
again:
	printf("\n请输入要排查的坐标&gt;&gt;");
	scanf("%d %d", &amp;x, &amp;y);
	if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)       //判断玩家输入的坐标是否合法
	{
		if (show[x][y] == '*' || show[x][y] == '!')       //判断坐标是否被排查过，若 show 数组在该坐标的元素为 ‘*’ 则表示该坐标未被排查，若 show 数组在该坐标的元素为 ‘!’ 则表示该坐标仅被标记，但未被排查
		{
			if (mine[x][y] == '1')       // mine 数组在该坐标的元素为 ‘1’ 则表示该坐标为地雷
			{
				system("cls");       //为了美化游戏界面，清除屏幕上的所有内容
				printf("\n&lt;很遗憾，你踩到雷了，游戏结束&gt;\n");
				DisplayBoard(mine, ROW, COL);       //向玩家展示雷区的地雷布局，让玩家输的明明白白
				return 1;       //返回1，表示玩家踩到地雷了
			}
			else       //玩家输入的坐标不是地雷
			{
				Unfold(mine, show, x, y, win);       //展开一篇雷区函数，讲解点
				DisplayBoard(show, row, col);       //将数据反馈给玩家，显示该坐标周围的8个格子存在几个地雷
			}
		}
		else       //该坐标已被排查过
		{
			printf("\n&lt;该坐标已排查，无需重复排查，请重新输入&gt;\n");
			goto again;
		}
	}
	else       //玩家输入坐标非法
	{
		printf("\n&lt;坐标非法，请重新输入&gt;\n");
		goto again;       //利用 goto 语句将程序的进程跳转至第5行的 again 处开始执行，让玩家重新输入一个合法的坐标
	}
	return 0;       //若 int 函数正常运行结束，注意不要忘记 return 0；否则默认返回1，若返回1，程序将误以为玩家踩到地雷了
}</code></pre> 
<p><span style="color:#1c7331;"><strong>| 讲解点 |</strong></span></p> 
<blockquote> 
 <p>在扫雷游戏中，当我们点击的方格不是地雷，且周围一片区域都没有地雷时，会直接展开一片雷区，具体效果如下图</p> 
 <p class="img-center"><img alt="" height="348" src="https://images2.imgbox.com/14/4b/WYzXvV6B_o.gif" width="304"></p> 
 <p>如何用代码实现这一功能呢？</p> 
 <p>还是按照惯例，先弄明白其中的原理和逻辑。</p> 
</blockquote> 
<p><span style="color:#4da8ee;"><strong>| 原理&amp;逻辑 |</strong></span></p> 
<blockquote> 
 <p>扫雷游戏中，当玩家翻转一个方格时，若该方格不是地雷则会显示该方格周围 8 个方格存在的地雷个数。如果该方格周围 8 个坐标都不存在地雷时会将这 9 个方格都展开，以此类推直到遇到一个方格的周围 8 个方格存在地雷时停止展开，两种情况如下图所</p> 
 <p class="img-center"><img alt="" height="424" src="https://images2.imgbox.com/10/99/PwFxXabG_o.png" width="609"></p> 
</blockquote> 
<p><strong>为实现这一功能，则需要我们遍历玩家输入的坐标的周围 8 个坐标，统计该坐标周围所存在的地雷个数。</strong></p> 
<p><strong><span style="color:#ff9900;">| 代码 |</span></strong></p> 
<pre><code class="language-cpp">int count_mine(char board[ROWS][COLS], int x, int y)
{
	return board[x - 1][y]
           + board[x - 1][y + 1]
           + board[x][y + 1]
           + board[x + 1][y + 1]
           + board[x + 1][y]
           + board[x + 1][y - 1]
           + board[x][y - 1]
           + board[x - 1][y - 1]
           - 8 * '0';       //注意最后的 - 8 * '0' 不要忘记！！
}</code></pre> 
<p class="img-center"><img alt="" height="484" src="https://images2.imgbox.com/ed/a3/8IZsQH6e_o.png" width="1007"></p> 
<blockquote> 
 <p><strong>展开一片雷区，是一个重复的过程，这片区域没有地雷，则继续展开下一片区域，直至遇到一片区域周围存在地雷时，停止展开。</strong></p> 
 <p>每次展开都要判断是否遇到地雷，每次的判断都是类似的，所以这一功能可以用我们所学的函数递归实现。</p> 
 <p>接下来我们继续用图例的形式捋清<strong>展开一片雷区</strong>的逻辑。</p> 
</blockquote> 
<p><span style="color:#1c7331;"><strong>| 图例 |</strong></span></p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/f4/14/HZjx5xrI_o.png" width="1010"></p> 
<p><span style="color:#ff9900;"><strong>| 代码 |</strong></span></p> 
<pre><code class="language-cpp">void Unfold(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y, int* win)
{
	if (x&lt;1 || x&gt;ROW || y&lt;1 || y&gt;COL)       //当坐标非法时，停止递归，返回上一层函数
	{
		return;
	}
	if (show[x][y] != '*')       //当 show 数组在该坐标上的元素不为 '*' 时，表示该坐标已被排查过，则停止递归，返回上一层函数
	{
		return;
	}
	int count = count_mine(mine, x, y);       //调用 count_mine 函数计算坐标周围的8个坐标有几个地雷
	if (count &gt; 0)       //当该坐标周围的地雷数量大于0时，不递归，不展开一片雷区
	{
		(*win)++;       //每当玩家输入的坐标不是地雷时，win++
		show[x][y] = count + '0';       //由于 show 数组为 char 类型，所以 count加上 '0' 使该坐标周围的地雷个数变为字符 '地雷个数'，这样才能与 show 数组元素类型对应起来
		return;
	}
	else if (count == 0)       //当该坐标周围的地雷数量等于0时，递归函数，对周围的8个坐标依次调用 Unfold 函数
	{
		(*win)++;       //每当玩家输入的坐标不是地雷时，win++
		show[x][y] = ' ';       //将不是地雷的坐标赋值为'空格'，给玩家营造出该区域没有地雷的视觉效果
		Unfold(mine, show, x - 1, y, win);
		Unfold(mine, show, x - 1, y + 1, win);
		Unfold(mine, show, x, y + 1, win);
		Unfold(mine, show, x + 1, y + 1, win);
		Unfold(mine, show, x + 1, y, win);
		Unfold(mine, show, x + 1, y - 1, win);
		Unfold(mine, show, x, y - 1, win);
		Unfold(mine, show, x - 1, y - 1, win);
	}
}</code></pre> 
<h4 id="2.4.2%C2%A0%20%E6%A0%87%E8%AE%B0%E5%9C%B0%E9%9B%B7%E5%AD%90%E5%87%BD%E6%95%B0">2.4.2  标记地雷子函数</h4> 
<blockquote> 
 <p>在扫雷游戏中，如果我们已经推断出一个坐标必定是地雷时，我们可以通过插旗子的方式去标记地雷，如下图。</p> 
 <p class="img-center"><img alt="" height="351" src="https://images2.imgbox.com/45/af/3Y2i41Cw_o.png" width="301"></p> 
 <p>接下来我们就要学习如何用代码实现这一标记地雷的功能。</p> 
</blockquote> 
<p><span style="color:#ff9900;"><strong>| 代码 |</strong></span></p> 
<pre><code class="language-cpp">void Mark(char board[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	while (1)
	{
		printf("\n请输入要标记的坐标&gt;&gt;");
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)       //判断玩家输入坐标是否合法
		{
			if (board[x][y] == '!')       //若坐标元素为 '!' 则表示该坐标已被标记过
			{
				printf("\n&lt;该坐标已标记，无需重复标记，请重新输入&gt;\n");
			}
			else       //该坐标未被标记
			{
				board[x][y] = '!';       //将 '!' 赋值给该坐标元素
				DisplayBoard(board, row, col);       //将标记地雷后的雷区展示于玩家
				break;
			}
		}
		else
		{
			printf("\n&lt;坐标非法，请重新输入&gt;\n\n");
		}
	}
}</code></pre> 
<h4 id="2.4.3%C2%A0%20%E5%8F%96%E6%B6%88%E6%A0%87%E8%AE%B0%E5%AD%90%E5%87%BD%E6%95%B0">2.4.3  取消标记子函数</h4> 
<blockquote> 
 <p>如果玩家因判断失误而错误的标记了地雷，则此时我们还需要实现一个取消标记的功能，这样才不至于让玩家只能标记地雷而不能取消标记。</p> 
</blockquote> 
<p><span style="color:#ff9900;"><strong>| 代码 |</strong></span></p> 
<pre><code class="language-cpp">void UnMark(char board[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	while (1)
	{
		printf("\n请输入要取消标记的坐标&gt;&gt;");
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)       //判断玩家输入坐标是否合法
		{
			if (board[x][y] != '!')       //该坐标未被标记
			{
				int i = 0;
				int j = 0;
				int flag = 1;       // flag 用于判断雷区内是否有标记，若雷区内没有标记则 flag = 1
				for (i = 1; i &lt;= row; i++)       //对 show 数组遍历
				{
					for (j = 1; j &lt;= col; j++)
					{
						if (board[i][j] == '!')       //雷区内存在标记
						{
							flag = 0;       //雷区内存在标记，则将 flag 赋值为0
							goto out;       //利用 goto 语句将程序的进程跳转至第27行的 out 处开始执行
						}
					}
				}
			out:
				if (flag)       // flag == 1，则表示雷区内不存在标记；flag == 0，则表示雷区内存在标记
				{
					printf("\n&lt;雷区尚未做标记，无需取消&gt;\n\n");
					return;
				}
				else       //雷区内存在标记，但玩家输入的坐标未被标记
				{
					printf("\n&lt;该坐标未标记，无需取消，请重新输入&gt;\n");
				}
			}
			else       //该坐标已被标记
			{
				board[x][y] = '*';       //用字符 '*' 来覆盖 '!'，从而达到取消标记的效果
				DisplayBoard(board, row, col);       //将取消标记后的雷区展示于玩家
				break;
			}
		}
		else
		{
			printf("\n&lt;坐标非法，请重新输入&gt;\n\n");
		}
	}
}</code></pre> 
<p></p> 
<h3 id="3.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%C2%A0">3.  完整代码 </h3> 
<p><span style="color:#ff9900;"><strong>| 代码 |</strong></span></p> 
<p><span style="color:#ff9900;"><strong>| 头文件 &gt;&gt; Mine_Sweeper.h |</strong></span></p> 
<pre><code class="language-cpp">#pragma once

#define ROW 9
#define COL 9
#define ROWS ROW+2
#define COLS COL+2
#define MINE 10

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;

void InitBoard(char board[ROWS][COLS], int rows, int cols, char set);

void SetMine(char board[ROWS][COLS], int row, int col);

void DisplayBoard(char board[ROWS][COLS], int row, int col);

void CheckMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);</code></pre> 
<p><span style="color:#ff9900;"><strong>| 源文件 &gt;&gt; Mine_Sweeper.c |</strong></span> </p> 
<pre><code class="language-cpp">#include"Mine_Sweeper.h"

void InitBoard(char board[ROWS][COLS], int rows, int cols, char set)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; rows; i++)
	{
		for (j = 0; j &lt; cols; j++)
		{
			board[i][j] = set;
		}
	}
}

void SetMine(char board[ROWS][COLS], int row, int col)
{
	int count = MINE;
	while (count)
	{
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;
		}
	}
}

void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	printf("\n----MineSweeper----\n");
	for (j = 0; j &lt;= col; j++)
	{
		printf("%d ", j);
	}
	printf("\n");
	for (i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("----MineSweeper----\n\n");
}

int count_mine(char board[ROWS][COLS], int x, int y)
{
	return board[x - 1][y] + board[x - 1][y + 1] + board[x][y + 1] + board[x + 1][y + 1] + board[x + 1][y] + board[x + 1][y - 1] + board[x][y - 1] + board[x - 1][y - 1] - 8 * '0';
}

void menu()
{
	printf("********************************\n");
	printf("*********   1.CHECK    *********\n");
	printf("*********   2.MARK     *********\n");
	printf("*********   3.UNMARK   *********\n");
	printf("********************************\n");

}

void Unfold(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y, int* win)
{
	if (x&lt;1 || x&gt;ROW || y&lt;1 || y&gt;COL)
	{
		return;
	}
	if (show[x][y] != '*')
	{
		return;
	}
	int count = count_mine(mine, x, y);
	if (count &gt; 0)
	{
		(*win)++;
		show[x][y] = count + '0';
		return;
	}
	else if (count == 0)
	{
		(*win)++;
		show[x][y] = ' ';
		Unfold(mine, show, x - 1, y, win);
		Unfold(mine, show, x - 1, y + 1, win);
		Unfold(mine, show, x, y + 1, win);
		Unfold(mine, show, x + 1, y + 1, win);
		Unfold(mine, show, x + 1, y, win);
		Unfold(mine, show, x + 1, y - 1, win);
		Unfold(mine, show, x, y - 1, win);
		Unfold(mine, show, x - 1, y - 1, win);
	}
}

int Check(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col, int* win)
{
	int x = 0;
	int y = 0;
again:
	printf("\n请输入要排查的坐标&gt;&gt;");
	scanf("%d %d", &amp;x, &amp;y);
	if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
	{
		if (show[x][y] == '*' || show[x][y] == '!')
		{
			if (mine[x][y] == '1')
			{
				system("cls");
				printf("\n&lt;很遗憾，你踩到雷了，游戏结束&gt;\n");
				DisplayBoard(mine, ROW, COL);
				return 1;
			}
			else
			{
				Unfold(mine, show, x, y, win);
				DisplayBoard(show, row, col);
			}
		}
		else
		{
			printf("\n&lt;该坐标已排查，无需重复排查，请重新输入&gt;\n");
			goto again;
		}
	}
	else
	{
		printf("\n&lt;坐标非法，请重新输入&gt;\n");
		goto again;
	}
	return 0;
}

void Mark(char board[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	while (1)
	{
		printf("\n请输入要标记的坐标&gt;&gt;");
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			if (board[x][y] == '!')
			{
				printf("\n&lt;该坐标已标记，无需重复标记，请重新输入&gt;\n");
			}
			else
			{
				board[x][y] = '!';
				DisplayBoard(board, row, col);
				break;
			}
		}
		else
		{
			printf("\n&lt;坐标非法，请重新输入&gt;\n\n");
		}
	}
}

void UnMark(char board[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	while (1)
	{
		printf("\n请输入要取消标记的坐标&gt;&gt;");
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			if (board[x][y] != '!')
			{
				int i = 0;
				int j = 0;
				int flag = 1;
				for (i = 1; i &lt;= row; i++)
				{
					for (j = 1; j &lt;= col; j++)
					{
						if (board[i][j] == '!')
						{
							flag = 0;
							goto out;
						}
					}
				}
			out:
				if (flag)
				{
					printf("\n&lt;雷区尚未做标记，无需取消&gt;\n\n");
					return;
				}
				else
				{
					printf("\n&lt;该坐标未标记，无需取消，请重新输入&gt;\n");
				}
			}
			else
			{
				board[x][y] = '*';
				DisplayBoard(board, row, col);
				break;
			}
		}
		else
		{
			printf("\n&lt;坐标非法，请重新输入&gt;\n\n");
		}
	}
}

void CheckMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int ret = 0;
	int win = 0;
	int input = 0;
	do
	{
		menu();
		printf("\n请选择程序&gt;&gt;");
		scanf("%d", &amp;input);
		switch (input)
		{
		case 1:
			if (win &lt; row * col - MINE)
			{
				ret = Check(mine, show, row, col, &amp;win);
				if (ret == 1)
				{
					return;
				}
			}
			if (win == row * col - MINE)
			{
				system("cls");
				printf("&lt;恭喜你，排雷成功&gt;\n");
				DisplayBoard(mine, row, col);
				return;
			}
			break;
		case 2:
			Mark(show, row, col);
			break;
		case 3:
			UnMark(show, row, col);
			break;
		default:
			printf("\n&lt;选择错误，请重新选择&gt;\n\n");
			break;
		}
		system("cls");
		DisplayBoard(show, row, col);
	} while (input);
}</code></pre> 
<p><span style="color:#ff9900;"><strong>| 源文件 &gt;&gt; test.c |</strong></span></p> 
<pre><code class="language-cpp">#include"Mine_Sweeper.h"

void MENU()
{
	printf("******************************\n");
	printf("*********   1.PLAY   *********\n");
	printf("*********   0.EXIT   *********\n");
	printf("******************************\n");
}

void Game()
{
	char mine[ROWS][COLS] = { 0 };
	char show[ROWS][COLS] = { 0 };
	InitBoard(mine, ROWS, COLS, '0');
	SetMine(mine, ROW, COL);
	InitBoard(show, ROWS, COLS, '*');
	DisplayBoard(show, ROW, COL);
	CheckMine(mine, show, ROW, COL);
}

int main()
{
	srand((unsigned int)time(NULL));
	int input = 0;
	do
	{
		MENU();
		printf("\n请选择程序&gt;&gt;");
		scanf("%d", &amp;input);
		system("cls");
		switch (input)
		{
		case 1:
			Game();
			break;
		case 0:
			printf("\n&lt;退出游戏&gt;\n\n");
			break;
		default:
			printf("\n&lt;选择错误，请重新选择&gt;\n\n");
			break;
		}
	} while (input);
	return 0;
}</code></pre> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%B8%B8%E6%88%8F%E5%B1%95%E7%A4%BA%C2%A0"><span style="color:#956fe7;">四、游戏展示</span> </h2> 
<div class="csdn-video-box"> 
 <iframe id="vzJ0qTP9-1652612862969" frameborder="0" src="https://live.csdn.net/v/embed/208469" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p>扫雷游戏展示</p> 
</div> 
<div class="csdn-video-box"> 
 <iframe id="BqZbogEb-1652612924926" frameborder="0" src="https://live.csdn.net/v/embed/208470" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p>扫雷游戏展示</p> 
</div> 
<hr> 
<p>到这里本篇博客就接近尾声了，希望看完本篇博客对你有所帮助，期待下次与你相遇。</p> 
<p style="text-align:center;"><img alt="" height="405" src="https://images2.imgbox.com/e8/4a/HS3mF2bW_o.gif" width="721"></p> 
<p style="text-align:center;"><strong>&lt; 你的<span style="color:#fe2c24;">关注</span>，<span style="color:#fe2c24;">点赞</span>，<span style="color:#fe2c24;">评论</span>，<span style="color:#fe2c24;">收藏</span><span style="color:#0d0016;">都</span>是对我创作最大的鼓励 &gt;</strong> </p> 
<p></p> 
<p><strong>( 若本篇博客存在错误，望指出，感谢！ ) </strong></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03669b224e40e810a74afaf5b2cd3961/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MyBatis-Plus--分页时的排序--方法/教程/实例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2c9214c6e10c64331428b494fe0bed0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue 项目中刷新页面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>