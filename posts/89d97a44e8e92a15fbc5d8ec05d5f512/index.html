<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>using namespace std - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="using namespace std" />
<meta property="og:description" content="整体认识 —— 解决命名冲突 一个简单的C&#43;&#43;程序：
#include&lt;iostream&gt; using namespace std; int main(int argc,char **argv) { cout&lt;&lt;&#34;hello world !&#34;&lt;&lt;endl; system(&#34;pause&#34;); // 让程序暂停,按任意键继续 注意，这行不是标准的C&#43;&#43;代码, 仅限于调试使用 cout&lt;&lt;&#34;出来了&#34;&lt;&lt;endl; return 0; } 其中：
using namespace std; 是什么意思，又有什么作用呢？
“using namespace std;”，顾名思义 —— 使用（using）名空间（namespace）std，std是名空间的名字，这是C&#43;&#43;为了解决不同工程的变量，函数等命名冲突的问题，引入的名空间（namespace）的概念，相当于文件夹的目录和子文件的关系——不同的目录（namespce）下即使有相同子文件名（变量，函数等）也不会产生冲突（如果接触过Java，这里类似于Java中不同的包的作用）。下面是个小例子：
// 声明名空间Jack namespace Jack { double height; void fetch(); } // 声明名空间Jill namespace Jill { double height; void fetch(); } // 使用名空间 cout&lt;&lt;Jack::height&lt;&lt;endl; cout&lt;&lt;Jill::height&lt;&lt;endl; Jack::fetch(); 可以看到，可以指定特定名空间下的同名变量(height)和函数(fetch())。
有时名空间内的内容太多，使用限定符::就太过繁琐，可以使用&#34;using namespace XXX;&#34;直接引入整个名空间：
namespace Jack { double height; void fetch(); ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/89d97a44e8e92a15fbc5d8ec05d5f512/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-07T18:47:19+08:00" />
<meta property="article:modified_time" content="2018-08-07T18:47:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">using namespace std</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>整体认识 —— 解决命名冲突</h4> 
<p style="text-indent:33px;">一个简单的C++程序：</p> 
<pre class="has"><code class="language-cpp">#include&lt;iostream&gt;
 
using namespace std;
 
int main(int argc,char **argv)
{
	cout&lt;&lt;"hello world !"&lt;&lt;endl;
	system("pause");    // 让程序暂停,按任意键继续 注意，这行不是标准的C++代码, 仅限于调试使用 
	cout&lt;&lt;"出来了"&lt;&lt;endl;
	return 0;
}</code></pre> 
<p style="text-indent:33px;">其中：</p> 
<pre class="has"><code class="language-cpp">using namespace std;</code></pre> 
<p style="text-indent:33px;">是什么意思，又有什么作用呢？</p> 
<p style="text-indent:33px;">“using namespace std;”，顾名思义 —— <span style="color:#f33b45;">使用（using）名空间（namespace）std</span>，std是名空间的名字，这是C++<span style="color:#f33b45;">为了解决不同工程的变量，函数等<strong>命名冲突</strong>的问题</span>，引入的名空间（namespace）的概念，相当于文件夹的目录和子文件的关系——不同的目录（namespce）下即使有相同子文件名（变量，函数等）也不会产生冲突（如果接触过Java，这里类似于Java中不同的包的作用）。下面是个小例子：</p> 
<pre class="has"><code class="language-cpp">// 声明名空间Jack
namespace Jack {
  double height;
  void fetch();
}
// 声明名空间Jill
namespace Jill {
  double height;
  void fetch();
}
// 使用名空间
cout&lt;&lt;Jack::height&lt;&lt;endl;
cout&lt;&lt;Jill::height&lt;&lt;endl;
Jack::fetch();
</code></pre> 
<p style="text-indent:33px;">可以看到，可以指定特定名空间下的同名变量(height)和函数(fetch())。</p> 
<p style="text-indent:33px;">有时名空间内的内容太多，使用限定符::就太过繁琐，可以使用"using namespace XXX;"直接<strong><span style="color:#f33b45;">引入</span></strong>整个名空间：</p> 
<pre class="has"><code class="language-cpp">namespace Jack {
  double height;
  void fetch();
  ...
}

 
int main(int argc,char **argv)
{
    // 这句之后的代码，如果出现Jack中的变量，函数等，均视为Jack中的
    // 类似于局部变量覆盖整体变量的效果
    using namespace Jack;   
    
    height= 176.34;
    fetch();
}
</code></pre> 
<h4>使用方式</h4> 
<p style="text-indent:33px;">注意两种用法的区别：</p> 
<p style="text-indent:33px;">限定符方式: Jack::height;</p> 
<p style="text-indent:33px;">using编译方式：using namespace Jack;</p> 
<p style="text-indent:33px;">前者可以看做只引用名空间Jack中的一个变量——height，后者是<span style="color:#f33b45;"><strong>编译</strong></span>整个名空间Jack。</p> 
<p style="text-indent:33px;">显然，表面来看，”using namespace Jack;“无脑又方便，那为什么还要用限定符呢？</p> 
<p style="text-indent:33px;">这是因为”using namespace Jack;“会编译整个名空间并引入到当前程序中，如果本地有变量方法和类名如果和其冲突，则本地会覆盖原名空间的内容，看下面的例子：</p> 
<pre class="has"><code class="language-cpp">#include&lt;iostream&gt;

using namespace std; 

namespace Senario
{
   class Student
 {
     int age;
     string name;
     string sex;
     Student()
     {
       age = 20;
       name = "Martin";
       sex = "male";
     }
 };
}    // namespace Senario的作用域到此结束


// 注意这里是在当前名空间内声明的Student
 class Student
  {
     int age;
     string name;
     Student()
     {
       age = 18;
       name = "Kevin";
     }
  };


int main(int argcs,char** args)
{
  using namespace Senario;

  // 此时这个Student就会被“局部变量”————当前名空间内Student覆盖掉
  Student student = new Student();   
  cout&lt;&lt;student.name&lt;&lt;endl;
  cout&lt;&lt;student.sex&lt;&lt;endl;
  return 0;
}

</code></pre> 
<p style="text-indent:33px;">程序<span style="color:#f33b45;">编译</span>结果：</p> 
<p style="text-indent:33px;"><img alt="" class="has" height="509" src="https://images2.imgbox.com/8e/27/zZUmpDe9_o.png" width="822"></p> 
<p style="text-indent:33px;">好吧，经实验，直接报错：</p> 
<p style="text-indent:33px;"><span style="color:#f33b45;">[Error] reference to 'Student' is ambiguous </span></p> 
<p style="text-indent:33px;">①处说的很清楚，Student是不明确的，②处给出了更详细的信息：Student有两个选择：class Student（当前名空间内）和Senario:: Student两个选择。</p> 
<h4>总结</h4> 
<p style="text-indent:33px;">现在回到原来的问题：</p> 
<p style="text-indent:33px;">using namespace std；</p> 
<p style="text-indent:33px;">其实已经很清晰，<strong><span style="color:#f33b45;">std是CPP标准库所在的名空间的名称</span></strong>，"using namespace std;"的作用——引入并编译了标准库中所有的内容，其中最重要的莫过于cin,cout,endl,string。</p> 
<p style="text-indent:33px;">使用using编译指令固然方便，但是就像上面描述的问题一样，若程序中程序员自己定义的变量，方法，类等名称和std中冲突（这种情况下程序员大概率还不知道（std库太大，其中内容太多）），编译时就会报错。</p> 
<p style="text-indent:33px;">所以”using namespace std;“虽然最常使用，但是也要注意：保证本地名空间和引入的其他名空间没有std相同的变量方法名（当然，在程序中没有调用的变量方法不影响）。</p> 
<p style="text-indent:33px;">所以，总结一下：</p> 
<p style="text-indent:33px;">最保险：</p> 
<pre class="has"><code class="language-cpp">int main(int argcs,char** args)
{
int x;
std::cin &gt;&gt; x;
std::cout &lt;&lt; x &lt;&lt; std::endl;
}</code></pre> 
<p style="text-indent:33px;">偷懒但有隐患：</p> 
<pre class="has"><code class="language-cpp">using namespace std;
int main(int argcs,char** args)
{
int x;
cin &gt;&gt; x;
cout &lt;&lt; x &lt;&lt; endl;
}</code></pre> 
<p style="text-indent:33px;">为避免冲突和提高效率（次要）：</p> 
<pre class="has"><code class="language-cpp">using std::cin;
using std::cout;
using std::endl;
int main(int argcs,char** args)
{
int x;
cin &gt;&gt; x;
cout &lt;&lt; x &lt;&lt; endl;
}</code></pre> 
<p style="text-indent:33px;">局部代码块中使用，引入名空间而不是头部引入：</p> 
<pre class="has"><code class="language-cpp">
int main(int argcs,char** args)
{

{
using namespace std;
int x;
cin &gt;&gt; x;
cout &lt;&lt; x &lt;&lt; endl;
}

...          //其他不需要用到std的代码

}</code></pre> 
<p style="text-indent:33px;">对于这种方式，可以像上面写的一样，使用花括号限定名空间作用域。</p> 
<p style="text-indent:33px;">但这仅限于个别调用的场景，像cin,cout,endl,string基本散布在代码各个地方，这种方法就不行了，不过cin,cout,endl,string这样如此”常见“的标识符，甚至是个写C++的都知道，本地代码的命名应该不会与此发生冲突，故对于只使用std中cin,cout,endl,string的场景，使用using namespace std这种方式是安全且方便的。</p> 
<p style="text-indent:33px;">当然，最保险的方式还是：</p> 
<pre class="has"><code class="language-cpp">using std::cin;
using std::cout;
using std::endl;
using std::string;</code></pre> 
<p style="text-indent:33px;">另外，明白名空间的作用以后，可以将特定变量放在名空间中，如C++不提倡使用类似于static int counter这种来计数，那么可以将计数器放在特定的名空间中，每次访问加上名空间和作用符即可，这样既起到全局变量的效果，又不至于破坏程序的独立性和模块化。</p> 
<p style="text-indent:33px;">喜欢的别忘了点个赞哦</p> 
<p style="text-indent:33px;">参考资料：</p> 
<p style="text-indent:33px;"><a href="https://www.jianshu.com/p/16141adf0229" rel="nofollow">https://www.jianshu.com/p/16141adf0229</a></p> 
<p style="text-indent:33px;"><a href="https://www.jb51.net/article/129644.htm" rel="nofollow">https://www.jb51.net/article/129644.htm</a></p> 
<p style="text-indent:33px;">声明：除已注明的引用外，文章系作者原创，引用转载请注明出处，如有必要请联系作者。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fafc5d2dde4a85b40c49afc75ac90b08/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Centos 6.8安装Python3.7</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a9f864f136e9da7efa2666e53defa32/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">A simple yet effective baseline for 3d human pose estimation</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>