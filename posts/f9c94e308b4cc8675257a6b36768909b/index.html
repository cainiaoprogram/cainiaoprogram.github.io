<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenGL原理与实践——核心模式（一）：VBO、VAO等原理解析及项目初始设置 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenGL原理与实践——核心模式（一）：VBO、VAO等原理解析及项目初始设置" />
<meta property="og:description" content="目录
序言——OpenGL在是什么？为什么？做什么?
OpenGL实现了什么
OpenGL内模型数据的本质——顶点数据 我们需要研究什么——三角形，一个图形基元
MVP变换
OpenGL渲染流程的关键——摄像机变换
OpenGL渲染管线概览
准备——项目配置
项目初始代码框架及注释
初识——三角形绘制 OpenGL中的顶点数据格式——float数组
OpenGL中shader如何从CPU中获取数据——layout（锚点）
Shader
VBO：Vertex Buffer Object
VAO：解决锚点问题，记录了VBO的锚点信息
编译shader
设定VAO并进行渲染
整体源码
序言——OpenGL在是什么？为什么？做什么? OpenGL实现了什么 将三维物体映射到视线方向上的一个裁剪空间（屏幕）上 OpenGL内模型数据的本质——顶点数据 我们需要研究什么——三角形，一个图形基元 MVP变换 OpenGL渲染流程的关键——摄像机变换 OpenGL渲染管线概览 准备——项目配置 GLFW
Download | GLFW
GLAD
https://glad.dav1d.de
下载后，进行相应配置。
项目初始代码框架及注释 #include &lt;glad/glad.h&gt; #include &lt;GLFW/glfw3.h&gt; #include &lt;iostream&gt; void framebuffer_size_callback(GLFWwindow* window, int width, int height) { glViewport(0, 0, width, height); } void processInput(GLFWwindow* window) { if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) { glfwSetWindowShouldClose(window, true); } } int main() { //初始化OpenGL上下文环境，OpenGL是一个状态机，会保存当前状态下的渲染状态以及管线的状态 glfwInit(); //，3版本以上 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); //用OpenGL核心开发模式 glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE); //创建窗体 GLFWwindow* window = glfwCreateWindow(800, 600, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f9c94e308b4cc8675257a6b36768909b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-21T14:36:35+08:00" />
<meta property="article:modified_time" content="2023-03-21T14:36:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenGL原理与实践——核心模式（一）：VBO、VAO等原理解析及项目初始设置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%BA%8F%E8%A8%80%E2%80%94%E2%80%94OpenGL%E5%9C%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%81%9A%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:0px;"><a href="#%E5%BA%8F%E8%A8%80%E2%80%94%E2%80%94OpenGL%E5%9C%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%81%9A%E4%BB%80%E4%B9%88%3F" rel="nofollow">序言——OpenGL在是什么？为什么？做什么?</a></p> 
<p id="OpenGL%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#OpenGL%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%BB%80%E4%B9%88" rel="nofollow">OpenGL实现了什么</a></p> 
<p id="OpenGL%E5%86%85%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%C2%A0-toc" style="margin-left:40px;"><a href="#OpenGL%E5%86%85%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%C2%A0" rel="nofollow">OpenGL内模型数据的本质——顶点数据 </a></p> 
<p id="%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%A0%94%E7%A9%B6%E4%BB%80%E4%B9%88%E2%80%94%E2%80%94%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%BD%A2%E5%9F%BA%E5%85%83-toc" style="margin-left:40px;"><a href="#%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%A0%94%E7%A9%B6%E4%BB%80%E4%B9%88%E2%80%94%E2%80%94%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%BD%A2%E5%9F%BA%E5%85%83" rel="nofollow">我们需要研究什么——三角形，一个图形基元</a></p> 
<p id="MVP%E5%8F%98%E6%8D%A2-toc" style="margin-left:40px;"><a href="#MVP%E5%8F%98%E6%8D%A2" rel="nofollow">MVP变换</a></p> 
<p id="OpenGL%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E7%9A%84%E5%85%B3%E9%94%AE%E2%80%94%E2%80%94%E6%91%84%E5%83%8F%E6%9C%BA%E5%8F%98%E6%8D%A2-toc" style="margin-left:40px;"><a href="#OpenGL%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E7%9A%84%E5%85%B3%E9%94%AE%E2%80%94%E2%80%94%E6%91%84%E5%83%8F%E6%9C%BA%E5%8F%98%E6%8D%A2" rel="nofollow">OpenGL渲染流程的关键——摄像机变换</a></p> 
<p id="OpenGL%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%A7%88-toc" style="margin-left:40px;"><a href="#OpenGL%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%A7%88" rel="nofollow">OpenGL渲染管线概览</a></p> 
<p id="%E5%87%86%E5%A4%87%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#%E5%87%86%E5%A4%87%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE" rel="nofollow">准备——项目配置</a></p> 
<p id="%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%B3%A8%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%B3%A8%E9%87%8A" rel="nofollow">项目初始代码框架及注释</a></p> 
<p id="%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94%E4%B8%89%E8%A7%92%E5%BD%A2%E7%BB%98%E5%88%B6%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94%E4%B8%89%E8%A7%92%E5%BD%A2%E7%BB%98%E5%88%B6%C2%A0" rel="nofollow">初识——三角形绘制 </a></p> 
<p id="OpenGL%E4%B8%AD%E7%9A%84%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E2%80%94%E2%80%94float%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#OpenGL%E4%B8%AD%E7%9A%84%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E2%80%94%E2%80%94float%E6%95%B0%E7%BB%84" rel="nofollow">OpenGL中的顶点数据格式——float数组</a></p> 
<p id="OpenGL%E4%B8%ADshader%E5%A6%82%E4%BD%95%E4%BB%8ECPU%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94layout%EF%BC%88%E9%94%9A%E7%82%B9%EF%BC%89-toc" style="margin-left:40px;"><a href="#OpenGL%E4%B8%ADshader%E5%A6%82%E4%BD%95%E4%BB%8ECPU%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94layout%EF%BC%88%E9%94%9A%E7%82%B9%EF%BC%89" rel="nofollow">OpenGL中shader如何从CPU中获取数据——layout（锚点）</a></p> 
<p id="Shader-toc" style="margin-left:40px;"><a href="#Shader" rel="nofollow">Shader</a></p> 
<p id="VBO%EF%BC%9AVertex%20Buffer%20Object-toc" style="margin-left:40px;"><a href="#VBO%EF%BC%9AVertex%20Buffer%20Object" rel="nofollow">VBO：Vertex Buffer Object</a></p> 
<p id="VAO%EF%BC%9A%E8%A7%A3%E5%86%B3%E9%94%9A%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8C%E8%AE%B0%E5%BD%95%E4%BA%86VBO%E7%9A%84%E9%94%9A%E7%82%B9%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#VAO%EF%BC%9A%E8%A7%A3%E5%86%B3%E9%94%9A%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8C%E8%AE%B0%E5%BD%95%E4%BA%86VBO%E7%9A%84%E9%94%9A%E7%82%B9%E4%BF%A1%E6%81%AF" rel="nofollow">VAO：解决锚点问题，记录了VBO的锚点信息</a></p> 
<p id="%E7%BC%96%E8%AF%91shader-toc" style="margin-left:80px;"><a href="#%E7%BC%96%E8%AF%91shader" rel="nofollow">编译shader</a></p> 
<p id="%E8%AE%BE%E5%AE%9AVAO%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%B8%B2%E6%9F%93-toc" style="margin-left:80px;"><a href="#%E8%AE%BE%E5%AE%9AVAO%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%B8%B2%E6%9F%93" rel="nofollow">设定VAO并进行渲染</a></p> 
<p id="%E6%95%B4%E4%BD%93%E6%BA%90%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E6%95%B4%E4%BD%93%E6%BA%90%E7%A0%81" rel="nofollow">整体源码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%E5%BA%8F%E8%A8%80%E2%80%94%E2%80%94OpenGL%E5%9C%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%81%9A%E4%BB%80%E4%B9%88%3F">序言——OpenGL在是什么？为什么？做什么?</h2> 
<h3 id="OpenGL%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%BB%80%E4%B9%88">OpenGL实现了什么</h3> 
<p><img alt="" height="234" src="https://images2.imgbox.com/3e/7d/GsHAYLBp_o.png" width="539"></p> 
<p>将三维物体映射到视线方向上的一个裁剪空间（屏幕）上 </p> 
<p></p> 
<h3 id="OpenGL%E5%86%85%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%C2%A0">OpenGL内模型数据的本质——顶点数据 </h3> 
<p><img alt="" height="230" src="https://images2.imgbox.com/2a/61/mmdVKEFF_o.png" width="558"></p> 
<p></p> 
<h3 id="%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%A0%94%E7%A9%B6%E4%BB%80%E4%B9%88%E2%80%94%E2%80%94%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%BD%A2%E5%9F%BA%E5%85%83">我们需要研究什么——三角形，一个图形基元</h3> 
<p><img alt="" height="243" src="https://images2.imgbox.com/43/08/EX8vN9UB_o.png" width="485"></p> 
<p></p> 
<h3 id="MVP%E5%8F%98%E6%8D%A2">MVP变换</h3> 
<p><img alt="" height="233" src="https://images2.imgbox.com/7e/b3/OjXmReo6_o.png" width="977"></p> 
<p></p> 
<h3 id="OpenGL%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E7%9A%84%E5%85%B3%E9%94%AE%E2%80%94%E2%80%94%E6%91%84%E5%83%8F%E6%9C%BA%E5%8F%98%E6%8D%A2">OpenGL渲染流程的关键——摄像机变换</h3> 
<p><img alt="" height="434" src="https://images2.imgbox.com/fa/4d/76Ew43Io_o.png" width="905"></p> 
<p></p> 
<h3 id="OpenGL%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%A7%88">OpenGL渲染管线概览</h3> 
<p><img alt="" height="396" src="https://images2.imgbox.com/c2/1f/4aQJh8Az_o.png" width="725"></p> 
<p></p> 
<p></p> 
<h2 id="%E5%87%86%E5%A4%87%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE">准备——项目配置</h2> 
<p>GLFW</p> 
<p><a href="https://www.glfw.org/download.html" rel="nofollow" title="Download | GLFW">Download | GLFW</a></p> 
<p>GLAD</p> 
<p><a href="https://glad.dav1d.de/" rel="nofollow" title="https://glad.dav1d.de">https://glad.dav1d.de</a></p> 
<p><img alt="" height="1146" src="https://images2.imgbox.com/df/62/ogG3qBgn_o.png" width="1072"> 下载后，进行相应配置。</p> 
<p><img alt="" height="804" src="https://images2.imgbox.com/93/19/E2ZFZOhq_o.png" width="985"></p> 
<p><img alt="" height="766" src="https://images2.imgbox.com/c3/7d/k0hoyJAW_o.png" width="878"></p> 
<p><img alt="" height="528" src="https://images2.imgbox.com/e7/cf/lN15dfM5_o.png" width="791"></p> 
<p></p> 
<h3 id="%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E5%8F%8A%E6%B3%A8%E9%87%8A">项目初始代码框架及注释</h3> 
<pre><code class="language-cpp">#include &lt;glad/glad.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;iostream&gt;

void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
	glViewport(0, 0, width, height);
}

void processInput(GLFWwindow* window) {
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
		glfwSetWindowShouldClose(window, true);
	}
}

int main() {
	//初始化OpenGL上下文环境，OpenGL是一个状态机，会保存当前状态下的渲染状态以及管线的状态
	glfwInit(); 
	//，3版本以上
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	//用OpenGL核心开发模式
	glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);

	//创建窗体
	GLFWwindow* window = glfwCreateWindow(800, 600, "OpenGl Core", nullptr, nullptr);
	if (window == nullptr) {
		std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl;
		glfwTerminate();
		return -1;
	}
	//把当前上下文绑定至当前窗口
	glfwMakeContextCurrent(window);

	//通过glad绑定各种函数指针
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
		std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;
		return -1;
	}

	//视口：需要渲染的东西在哪里
	glViewport(0, 0, 800, 600);
	//当Frame大小变动，调用回调函数调整视口大小
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	//防止窗口结束退出
	while (!glfwWindowShouldClose(window)) {
		processInput(window);

		//擦除画布，用定义的颜色填充
		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);

		//双缓冲
		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	//结束，释放资源
	glfwTerminate();
	return 0;

}</code></pre> 
<p>运行结果如下：</p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/13/b5/nrMzel6a_o.png" width="816"></p> 
<p></p> 
<h2 id="%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94%E4%B8%89%E8%A7%92%E5%BD%A2%E7%BB%98%E5%88%B6%C2%A0">初识——三角形绘制 </h2> 
<p></p> 
<h3 id="OpenGL%E4%B8%AD%E7%9A%84%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E2%80%94%E2%80%94float%E6%95%B0%E7%BB%84">OpenGL中的顶点数据格式——float数组</h3> 
<p><img alt="" height="353" src="https://images2.imgbox.com/da/74/x70X7FvH_o.png" width="1066"></p> 
<p>看向-Z方向</p> 
<p></p> 
<h3 id="OpenGL%E4%B8%ADshader%E5%A6%82%E4%BD%95%E4%BB%8ECPU%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94layout%EF%BC%88%E9%94%9A%E7%82%B9%EF%BC%89">OpenGL中shader如何从CPU中获取数据——layout（锚点）</h3> 
<p><img alt="" height="350" src="https://images2.imgbox.com/11/8f/IkqWNCAz_o.png" width="1011"></p> 
<ul><li>CPU将float顶点数据数组传入GPU</li><li>CPU告诉GPU如何解析这个数组</li><li>调用渲染指令进行绘制</li></ul> 
<p><span style="color:#faa572;"><strong>GPU显存中的布局：layout；可以理解为“锚点”，指明在这一锚点代表的区域，存放了什么样的数据。</strong></span></p> 
<p></p> 
<h3 id="Shader">Shader</h3> 
<p>直白来说，Shader就是跑在GPU上的一种语言，用来操作GPU。</p> 
<p>我们先写好两个shader的内容，先大致了解一番：</p> 
<p>vertexShader：</p> 
<pre><code class="language-cpp">#version 330 core

//在layout=0，这块区域放置了一个vec3
layout (location = 0 ) in vec3 aPos;

//操作
void main()
{
	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}</code></pre> 
<ul><li>vertexShader中的数据gl_Position，会自动流入下一个阶段中，也就是fragmentShader </li><li>vertexShader会被调用多少次？有多少顶点就会调用多少次</li></ul> 
<p></p> 
<p> fragmentShader：</p> 
<pre><code class="language-cpp">#version 330 core
out vec4 FragColor;
void main(){
	FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
}</code></pre> 
<ul><li>fragmentShader的目的是为了输出一个数据，这里是vec4 FragColor，被定义为out类型，会被输出到下一个管线流程中。</li><li>fragmentShader会被调用多少次？简单来说有多少像素就会调用多少次</li></ul> 
<p></p> 
<p>流程：</p> 
<ul><li>将顶点数据转入到vertexShader，进行空间变换等操作（<span style="color:#6eaad7;">注意是并行的</span>）</li><li>数据从vertexShader传入到fragmentShader，进行像素插值等操作（处理一堆像素点）</li></ul> 
<p></p> 
<h3 id="VBO%EF%BC%9AVertex%20Buffer%20Object"><span style="color:#0d0016;">VBO：Vertex Buffer Object</span></h3> 
<p><span style="color:#0d0016;">在上面那个图中，其中的“GPU shader”就是所谓的VBO，也就是我们开辟的一块区域。</span></p> 
<p>在开辟的这块空间，存储顶点数据。</p> 
<p>那么在OpenGL中如何做这件事？</p> 
<ul><li>获取VBO的index（<span style="color:#faa572;"><strong>由OpenGL状态机分配的index</strong></span>）</li><li>绑定VBO的index</li><li>给VBO分配显存空间，并传输数据</li><li>告诉shader数据的解析方式</li><li>激活锚点，按照解析方式取读取数据</li></ul> 
<p>具体代码如下，我们在mian.cpp中添加如下函数：</p> 
<pre><code class="language-cpp">//构建模型数据：VBO，
void initModel() {
	float vertices[] = {
		-0.5f, -0.5f, 0.0f,
		0.5f, -0.5f, 0.0f,
		0.0f, 0.5f, 0.0f
	};

	glGenBuffers(1, &amp;VBO);
	//绑定哪一种buffer， 
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	//分配显存：分配哪种buffer，分配显存大小，分配地址，使用数据的方式
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	//对哪个锚点进行操作：layout=0的锚点，读3个顶点，类型为float，不需要归一化，每次步长为3个float大小，从0处开始读
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	//打开锚点：激活
	glEnableVertexAttribArray(0);

	//解绑
	glBindBuffer(GL_ARRAY_BUFFER, 0);
}</code></pre> 
<p>每个函数的作用和参数意义，这里我用注释详细标明。方便后时查阅复习。</p> 
<p></p> 
<p></p> 
<h3 id="VAO%EF%BC%9A%E8%A7%A3%E5%86%B3%E9%94%9A%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8C%E8%AE%B0%E5%BD%95%E4%BA%86VBO%E7%9A%84%E9%94%9A%E7%82%B9%E4%BF%A1%E6%81%AF"><span style="color:#0d0016;">VAO：解决锚点问题，记录了VBO的锚点信息</span></h3> 
<p></p> 
<h4 id="%E7%BC%96%E8%AF%91shader">编译shader</h4> 
<p>VAO是与shader密切相关的一个内容，所以在此之前需要进行shader的一系列操作：</p> 
<p>首先声明一个全局变量：</p> 
<pre><code class="language-cpp">unsigned int shaderProgram = 0;</code></pre> 
<p>初始化Shader，并进行编译链接。 </p> 
<pre><code class="language-cpp">void initShader(const char* _vertexPath, const char* _fragPath) {
	//shader的代码读取
	std::string _vertexCode("");
	std::string _fragCode("");

	std::ifstream _vShaderFile;
	std::ifstream _fShaderFile;

	_vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
	_fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);

	try {
		_vShaderFile.open(_vertexPath);
		_fShaderFile.open(_fragPath);

		std::stringstream _vShaderStream, _fShaderStream;
		_vShaderStream &lt;&lt; _vShaderFile.rdbuf();
		_fShaderStream &lt;&lt; _fShaderFile.rdbuf();

		_vertexCode = _vShaderStream.str();
		_fragCode = _fShaderStream.str();
	}
	catch(std::ifstream::failure e) {
		std::string errStr = "read shader fail";
		std::cout &lt;&lt; errStr &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; std::endl;
	}

	const char* _vShaderStr = _vertexCode.c_str();
	const char* _fShaderStr = _fragCode.c_str();

	//shader的编译链接
	unsigned int _vertexID = 0, _fragID = 0;
	char _infoLog[512];
	int _successFlag = 0;

	//编译

	_vertexID = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(_vertexID, 1, &amp;_vShaderStr, nullptr);
	glCompileShader(_vertexID);

	//捕捉编译过程中的状态信息
	glGetShaderiv(_vertexID, GL_COMPILE_STATUS, &amp;_successFlag);
	if (!_successFlag) {
		glGetShaderInfoLog(_vertexID, 512, nullptr, _infoLog);
		std::string errStr(_infoLog);
		std::cout &lt;&lt; errStr &lt;&lt; std::endl;
	}

	_fragID = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(_fragID, 1, &amp;_vShaderStr, nullptr);
	glCompileShader(_fragID);

	//捕捉编译过程中的状态信息
	glGetShaderiv(_fragID, GL_COMPILE_STATUS, &amp;_successFlag);
	if (!_successFlag) {
		glGetShaderInfoLog(_fragID, 512, nullptr, _infoLog);
		std::string errStr(_infoLog);
		std::cout &lt;&lt; errStr &lt;&lt; std::endl;
	}

	//链接
	//创建一个程序
	shaderProgram = glCreateProgram();
	glAttachShader(shaderProgram, _vertexID);
	glAttachShader(shaderProgram, _fragID);
	glLinkProgram(shaderProgram);

	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;_successFlag);
	if (!_successFlag) {
		glGetShaderInfoLog(shaderProgram, 512, nullptr, _infoLog);
		std::string errStr(_infoLog);
		std::cout &lt;&lt; errStr &lt;&lt; std::endl;
	}

	//删除中间文件
	glDeleteShader(_vertexID);
	glDeleteShader(_fragID);

}</code></pre> 
<p></p> 
<h4 id="%E8%AE%BE%E5%AE%9AVAO%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%B8%B2%E6%9F%93">设定VAO并进行渲染</h4> 
<pre><code class="language-cpp">//构建模型数据：VBO，VAO
void initModel() {
	float vertices[] = {
		-0.5f, -0.5f, 0.0f,
		0.5f, -0.5f, 0.0f,
		0.0f, 0.5f, 0.0f
	};

	glGenVertexArrays(1, &amp;VAO);
	glBindVertexArray(VAO);

	//之后的VBO便属于了VAO的管理范围
	glGenBuffers(1, &amp;VBO);
	//绑定哪一种buffer， 
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	//分配显存：分配哪种buffer，分配显存大小，分配地址，使用数据的方式
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	//对哪个锚点进行操作：layout=0的锚点，读3个顶点，类型为float，不需要归一化，每次步长为3个float大小，从0处开始读
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	//打开锚点：激活
	glEnableVertexAttribArray(0);

	//解绑
	//glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);

}</code></pre> 
<pre><code class="language-cpp">//渲染
void render() {
	glBindVertexArray(VAO);
	glUseProgram(shaderProgram);
	//以三角形模式绘制，从第0个顶点开始，起作用的有3个点
	glDrawArrays(GL_TRIANGLES, 0, 3);
	glUseProgram(0);
}</code></pre> 
<p>渲染结果：</p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/2a/13/jIqDzP9w_o.png" width="816"></p> 
<p></p> 
<h2 id="%E6%95%B4%E4%BD%93%E6%BA%90%E7%A0%81">整体源码</h2> 
<p>main.cpp</p> 
<pre><code class="language-cpp">#include &lt;glad/glad.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;


void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);
void initModel();
void initShader(const char* _vertexPath, const char* _fragPath);
void render();

unsigned int VBO = 0;
unsigned int VAO = 0;
unsigned int shaderProgram = 0;

int main() {
	//初始化OpenGL上下文环境，OpenGL是一个状态机，会保存当前状态下的渲染状态以及管线的状态
	glfwInit(); 
	//，3版本以上
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	//用OpenGL核心开发模式
	glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);

	//创建窗体
	GLFWwindow* window = glfwCreateWindow(800, 600, "OpenGl Core", nullptr, nullptr);
	if (window == nullptr) {
		std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl;
		glfwTerminate();
		return -1;
	}
	//把当前上下文绑定至当前窗口
	glfwMakeContextCurrent(window);

	//通过glad绑定各种函数指针
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
		std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;
		return -1;
	}

	//视口：需要渲染的东西在哪里
	glViewport(0, 0, 800, 600);
	//当Frame大小变动，调用回调函数调整视口大小
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	initModel();
	initShader("vertexShader.glsl", "fragmentShader.glsl");

	//防止窗口结束退出
	while (!glfwWindowShouldClose(window)) {
		processInput(window);

		//擦除画布，用定义的颜色填充
		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);

		render();

		//双缓冲
		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	//结束，释放资源
	glfwTerminate();
	return 0;

}

void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
	glViewport(0, 0, width, height);
}

void processInput(GLFWwindow* window) {
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
		glfwSetWindowShouldClose(window, true);
	}
}

//渲染
void render() {
	glBindVertexArray(VAO);
	glUseProgram(shaderProgram);
	//以三角形模式绘制，从第0个顶点开始，起作用的有3个点
	glDrawArrays(GL_TRIANGLES, 0, 3);
	glUseProgram(0);
}

//构建模型数据：VBO，VAO
void initModel() {
	float vertices[] = {
		-0.5f, -0.5f, 0.0f,
		0.5f, -0.5f, 0.0f,
		0.0f, 0.5f, 0.0f
	};

	glGenVertexArrays(1, &amp;VAO);
	glBindVertexArray(VAO);

	//之后的VBO便属于了VAO的管理范围
	glGenBuffers(1, &amp;VBO);
	//绑定哪一种buffer， 
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	//分配显存：分配哪种buffer，分配显存大小，分配地址，使用数据的方式
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	//对哪个锚点进行操作：layout=0的锚点，读3个顶点，类型为float，不需要归一化，每次步长为3个float大小，从0处开始读
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	//打开锚点：激活
	glEnableVertexAttribArray(0);

	//解绑
	//glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);

}

//
void initShader(const char* _vertexPath, const char* _fragPath) {
	//shader的代码读取
	std::string _vertexCode("");
	std::string _fragCode("");

	std::ifstream _vShaderFile;
	std::ifstream _fShaderFile;

	_vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
	_fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);

	try {
		_vShaderFile.open(_vertexPath);
		_fShaderFile.open(_fragPath);

		std::stringstream _vShaderStream, _fShaderStream;
		_vShaderStream &lt;&lt; _vShaderFile.rdbuf();
		_fShaderStream &lt;&lt; _fShaderFile.rdbuf();

		_vShaderFile.close();
		_fShaderFile.close();

		_vertexCode = _vShaderStream.str();
		_fragCode = _fShaderStream.str();
	}
	catch(std::ifstream::failure e) {
		std::string errStr = "read shader fail";
		std::cout &lt;&lt; errStr &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; std::endl;
	}

	const char* _vShaderStr = _vertexCode.c_str();
	const char* _fShaderStr = _fragCode.c_str();

	//shader的编译链接
	unsigned int _vertexID = 0, _fragID = 0;
	char _infoLog[512];
	int _successFlag = 0;

	//编译
	_vertexID = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(_vertexID, 1, &amp;_vShaderStr, nullptr);
	glCompileShader(_vertexID);

	//捕捉编译过程中的状态信息
	glGetShaderiv(_vertexID, GL_COMPILE_STATUS, &amp;_successFlag);
	if (!_successFlag) {
		glGetShaderInfoLog(_vertexID, 512, nullptr, _infoLog);
		std::string errStr(_infoLog);
		std::cout &lt;&lt; errStr &lt;&lt; std::endl;
	}

	_fragID = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(_fragID, 1, &amp;_fShaderStr, nullptr);
	glCompileShader(_fragID);

	//捕捉编译过程中的状态信息
	glGetShaderiv(_fragID, GL_COMPILE_STATUS, &amp;_successFlag);
	if (!_successFlag) {
		glGetShaderInfoLog(_fragID, 512, nullptr, _infoLog);
		std::string errStr(_infoLog);
		std::cout &lt;&lt; errStr &lt;&lt; std::endl;
	}

	//链接
	//创建一个程序
	shaderProgram = glCreateProgram();
	glAttachShader(shaderProgram, _vertexID);
	glAttachShader(shaderProgram, _fragID);
	glLinkProgram(shaderProgram);

	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;_successFlag);
	if (!_successFlag) {
		glGetShaderInfoLog(shaderProgram, 512, nullptr, _infoLog);
		std::string errStr(_infoLog);
		std::cout &lt;&lt; errStr &lt;&lt; std::endl;
	}

	//删除中间文件
	glDeleteShader(_vertexID);
	glDeleteShader(_fragID);

}</code></pre> 
<p>vertexShader.glsl </p> 
<pre><code class="language-cpp">#version 330 core
layout (location = 0) in vec3 aPos;
void main()
{
   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
};</code></pre> 
<p>fragmentShader.glsl </p> 
<pre><code class="language-cpp">#version 330 core
out vec4 FragColor;
void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
};</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c3adf05e3b8de5c76b5fd35f035f8b59/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">es数据库基本操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d682239f6d78176397acb5bc5562c62/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">element-plus 将语言设置为中文</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>