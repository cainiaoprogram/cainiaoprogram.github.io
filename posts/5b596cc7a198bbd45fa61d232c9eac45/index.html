<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android启动流程分析（二） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android启动流程分析（二）" />
<meta property="og:description" content="上一篇介绍了apk启动的流程到了创建activity的创建这里接着继续分析，先上图片
看高清图请下载
这里从handleLaunchActivity方法继续分析，如不明白的可以参考上一篇的分析android启动流程分析，这边直接就上代码了
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { ...... Activity a = performLaunchActivity(r, customIntent);//创建activity if (a != null) { r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); ...... } else { ...... } } private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ...... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5b596cc7a198bbd45fa61d232c9eac45/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-29T18:40:20+08:00" />
<meta property="article:modified_time" content="2017-06-29T18:40:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android启动流程分析（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上一篇介绍了apk启动的流程到了创建activity的创建这里接着继续分析，先上图片</p> 
<p><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="https://images2.imgbox.com/31/b1/0TwPIDdU_o.png" alt=""><br> </p> 
<p><span style="font-family:Arial; font-size:14px; line-height:26px">看高清图请</span><a target="_blank" href="http://download.csdn.net/detail/zjd934784273/9885460" style="color:rgb(202,0,0); text-decoration:none; font-family:Arial; font-size:14px; line-height:26px" rel="noopener noreferrer">下载</a><br> </p> 
<p>这里从<span lang="EN-US" style="font-size:10.5pt; font-family:宋体">handleLaunchActivity方法继续分析，如不明白的可以参考上一篇的分析<a target="_blank" href="http://blog.csdn.net/zjd934784273/article/details/73802543" rel="noopener noreferrer"><span style="color:rgb(102,102,102)">android</span><span style="color:rgb(102,102,102)">启动流程分析</span></a>，这边直接就上代码了</span></p> 
<p><span lang="EN-US" style="font-size:10.5pt; font-family:宋体"></span></p> 
<pre><code class="language-java">  private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
        ......

        Activity a = performLaunchActivity(r, customIntent);//创建activity

        if (a != null) {
            r.createdConfig = new Configuration(mConfiguration);
            reportSizeConfigurations(r);
            Bundle oldState = r.state;
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);
           ......
        } else {
            ......
        }
    }</code></pre> 
<pre><code class="language-java"></code></pre> 
<p></p> 
<p><code class="language-java"><span lang="EN-US" style="font-size:10.5pt; font-family:宋体"></span></code></p> 
<pre name="code" class="java"><code class="language-java">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        ......
        Activity activity = null;
        try {
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);//通过Instrumentation这个类创建Activity

            ......
        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to instantiate activity " + component
                    + ": " + e.toString(), e);
            }
        }
                ......
                activity.attach(appContext, this, getInstrumentation(), r.token,//attach方法
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
                ......
                int theme = r.activityInfo.getThemeResource();//设置主题
                   if (theme != 0) {
                         activity.setTheme(theme);
                     }

                ......
                if (r.isPersistable()) {//根据本地是否持久化来判断走那个方法，（这个持久化个人理解是activity被不正常销毁造成的）
                                        //这个方法调用的是activity的oncreate方法
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
				......
				 if (!r.activity.mFinished) {
                    activity.performStart();//调用activity的onstart方法
                    r.stopped = false;
                }
                ......
                if (!r.activity.mFinished) {
                    if (r.isPersistable()) {
                        if (r.state != null || r.persistentState != null) {
                            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
                                    r.persistentState);
                        }
                    } else if (r.state != null) {//<span style="font-family: Arial; line-height: 26px;"><span style="background-color: rgb(153, 255, 255);">r.state</span></span><span style="font-family: Arial; line-height: 26px;">是AMS传过来的，也就是说</span><span style="font-family: Arial; line-height: 26px;"><span style="background-color: rgb(255, 255, 153);">OnRestoreInstanceState<span style="background-color: rgb(255, 255, 255);">的调用取决于AMS是否想恢复activity。</span></span></span>
                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
                    }
                }
                if (!r.activity.mFinished) {
                    activity.mCalled = false;
                    if (r.isPersistable()) {
                        mInstrumentation.callActivityOnPostCreate(activity, r.state,
                                r.persistentState);
                    } else {
                        mInstrumentation.callActivityOnPostCreate(activity, r.state);
                    }
                    if (!activity.mCalled) {
                        throw new SuperNotCalledException(
                            "Activity " + r.intent.getComponent().toShortString() +
                            " did not call through to super.onPostCreate()");
                    }
                }
            }
            r.paused = true;

            mActivities.put(r.token, r);

        } catch (SuperNotCalledException e) {
            throw e;

        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to start activity " + component
                    + ": " + e.toString(), e);
            }
        }

        return activity;
    }</code></pre> 
<br> 
<span style="font-size:10.5pt">通过上面的代码可以看到activity再启动的时候首选调用attach---&gt;oncreate---&gt;onStart---&gt;onPostCreate</span> 
<p></p> 
<p><span lang="EN-US" style="font-size:10.5pt; font-family:宋体"><span style="font-size:10.5pt">对于attach是activity的一些初始化配置，在这个方法中会创建PhoneWindow对象，对于onPostCreate方法是Activity完全起来之后调用的方法（官方解释</span><span style='color:rgb(51,51,51); font-family:"PingFang SC","Lantinghei SC","Microsoft YaHei",arial,宋体,sans-serif,tahoma; font-size:16px; line-height:29px; white-space:pre-wrap'>Called when activity start-up is complete (after onStart() and onRestoreInstanceState(Bundle) have been called</span><span style="font-size:10.5pt">），对于这个方法目前不知道有什么特殊的用法如有特殊用法，希望能提出。其他的两个方法这里就不多说了我们常用的方法。上面还有个不是生命周期的一部分的是</span></span><span style="font-size:9pt; background-color:rgb(228,228,255)">onRestoreInstanceState</span><span style="font-size:10.5pt">这个方法的调用是在AMS判定需要调用的时候才会调用（转屏，activity不正常被系统回收等）</span></p> 
<p></p> 
<pre><code class="language-java">    final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
        ......

        // TODO Push resumeArgs into the activity for consideration
        r = performResumeActivity(token, clearHide, reason);

         .....
                if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) {//将decor添加到Window上
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }

         ....
    }</code></pre> 
<pre><code class="language-java"> public final ActivityClientRecord performResumeActivity(IBinder token,
            boolean clearHide, String reason) {
           ......
            try {
                r.activity.onStateNotSaved();
                r.activity.mFragments.noteStateNotSaved();
                if (r.pendingIntents != null) {
                    deliverNewIntents(r, r.pendingIntents);
                    r.pendingIntents = null;
                }
                if (r.pendingResults != null) {
                    deliverResults(r, r.pendingResults);
                    r.pendingResults = null;
                }
                r.activity.performResume();
				......
        }
        return r;
    }</code></pre> 
<br> 
<pre><code class="language-java">  final void performResume() {
        performRestart();
		.....
        mInstrumentation.callActivityOnResume(this);//调用了onResume方法
        if (!mCalled) {
            throw new SuperNotCalledException(
                "Activity " + mComponent.toShortString() +
                " did not call through to super.onResume()");
        }

        ......
        mFragments.dispatchResume();
        mFragments.execPendingActions();

        onPostResume();//
        if (!mCalled) {
            throw new SuperNotCalledException(
                "Activity " + mComponent.toShortString() +
                " did not call through to super.onPostResume()");
        }
    }</code></pre> 
<p></p> 
<p></p> 
<pre><code class="language-java"> final void performRestart() {
        mFragments.noteStateNotSaved();

        if (mToken != null &amp;&amp; mParent == null) {
            // No need to check mStopped, the roots will check if they were actually stopped.
            WindowManagerGlobal.getInstance().setStoppedState(mToken, false /* stopped */);
        }

        if (mStopped) {//当时从stop状态恢复的时候走下面的代码
            mStopped = false;

            synchronized (mManagedCursors) {
                final int N = mManagedCursors.size();
                for (int i=0; i&lt;N; i++) {
                    ManagedCursor mc = mManagedCursors.get(i);
                    if (mc.mReleased || mc.mUpdated) {
                        if (!mc.mCursor.requery()) {
                            if (getApplicationInfo().targetSdkVersion
                                    &gt;= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                                throw new IllegalStateException(
                                        "trying to requery an already closed cursor  "
                                        + mc.mCursor);
                            }
                        }
                        mc.mReleased = false;
                        mc.mUpdated = false;
                    }
                }
            }

            mCalled = false;
            mInstrumentation.callActivityOnRestart(this);
            if (!mCalled) {
                throw new SuperNotCalledException(
                    "Activity " + mComponent.toShortString() +
                    " did not call through to super.onRestart()");
            }
            performStart();
        }
    }</code></pre>通过上面的方法可以找到activity接下来正常的运行声明周期应该是-onResure----&gt;onPostResure,但是如果要是从stop状态下回复Activity的时候就会先调用onRestart---&gt;onstart--&gt;onResure---&gt;onPostResure 
<p></p> 
<p>到这里activity就算启动完成了，显现出来了，上面的代码分析是Activity启动的声明周期，下一篇分析Activity关闭的生命周期</p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/80a145b2097899593db4f8245f9c3eba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何设计数据库表？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c823e451a5c107a184cfe4489b5d207/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java HotSpot VM Options</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>