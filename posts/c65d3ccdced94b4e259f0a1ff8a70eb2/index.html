<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>查找算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="查找算法" />
<meta property="og:description" content="一、顺序查找（Seauential Search）（静态查找）
int SeqSearch(int s[],int n,int key){int i;for(i=0;i&lt;n &amp;&amp; s[i]!=key;i&#43;&#43;);if(i&lt;n)return i;elsereturn -1;}二、折半查找 (Binary Search) （静态查找）
又称为二分查找，这种查找方法要求查找表的数据时线性结构保存，并且还要求查找表中的数据时按关键字由小到大有序排列。折半查找是一种递归过程。
最坏情况下，折半查找比较的次数O（nlog2n）,其查找效率比顺序查找要快很多。
int BinarySearch(int s[],int n,int key){int low,high,mid;low=0;high=n-1;while(low&lt;=high) //查找范围含含至少一个元素 {mid=(low&#43;high)/2; //计算中间位置序号 if(s[mid]==key) //中间元素与关键字相等 return mid; //返回序号 else if(s[mid]&gt;key) //中间元素大于关键字 high=mid-1; //重定义查找范围 else //中间元素小于关键字 low=mid&#43;1; //重定义查找范围 }return -1; //返回查找失败 }优点：查找速度快，最多查找次数为O（nlog2n）。
缺点：对查找表中的数据有顺序要求，如果需要将查找不成功的关键字添加到查找表中，则需要对已有的查找表中的数据进行大量的移动。
三、二叉排序树 （Binary Sorting Tree） （动态查找）
1、插入节点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c65d3ccdced94b4e259f0a1ff8a70eb2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-05-04T21:07:13+08:00" />
<meta property="article:modified_time" content="2013-05-04T21:07:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">查找算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、顺序查找（Seauential Search）（静态查找）</p> 
<p> </p> 
<pre><code class="language-html">int SeqSearch(int s[],int n,int key)
{
    int i;
    for(i=0;i&lt;n &amp;&amp; s[i]!=key;i++)
        ;
    if(i&lt;n)
        return i;
    else
        return -1;
}
</code></pre> 
<p><br>  </p> 
<p>二、折半查找 (Binary Search) （静态查找）</p> 
<p>又称为二分查找，这种查找方法要求查找表的数据时线性结构保存，并且还要求查找表中的数据时<span style="color:#ff0000">按关键字由小到大有序</span>排列。折半查找是一种<span style="color:#ff0000">递归</span>过程。</p> 
<p>最坏情况下，折半查找比较的次数O（nlog2n）,其查找效率比顺序查找要快很多。</p> 
<pre><code class="language-html">int BinarySearch(int s[],int n,int key)
{
    int low,high,mid;
    low=0;
    high=n-1;
    while(low&lt;=high)        //查找范围含含至少一个元素 
    {
        mid=(low+high)/2;   //计算中间位置序号 
        if(s[mid]==key)      //中间元素与关键字相等 
            return mid;      //返回序号 
        else if(s[mid]&gt;key)  //中间元素大于关键字 
            high=mid-1;     //重定义查找范围 
        else                 //中间元素小于关键字 
            low=mid+1;       //重定义查找范围 
    }
    return -1;               //返回查找失败 
}
</code></pre> 
<p><br> 优点：查找速度快，最多查找次数为O（nlog2n）。</p> 
<p>缺点：对查找表中的数据<span style="color:#ff0000">有顺序要求</span>，如果需要将查找不成功的关键字添加到查找表中，则需要对已有的查找表中的<span style="color:#ff9900">数据进行大量的移动</span>。</p> 
<p> </p> 
<p> </p> 
<p>三、二叉排序树 （Binary Sorting Tree） （动态查找）</p> 
<p>1、插入节点</p> 
<p>假设t为树的根节点指针，再向该二叉树中增加新的关键字key。</p> 
<pre><code class="language-html">typedef struct bst
{
    int data;
    struct bst *left;
    struct bst * right;
}BSTree;
void InsertBST(BSTree *t,int key)//在二叉排序树中插入查找关键字key
{
    BSTree *p,*parent,*head;
    if(!(p=(BSTree *)malloc(sizeof(BSTree *)))) //申请内存空间 
    {
        printf("申请内存出错!\n");
        exit(0); 
    }
    p-&gt;data=key; //保存结点数据 
    p-&gt;left=p-&gt;right=NULL; //左右子树置空    
    head=t;
    while(head) //查找需要添加的父结点 
    {
        parent=head;
        if(key&lt;head-&gt;data) //若关键字小于结点的数据 
            head=head-&gt;left; //在左子树上查找 
        else                 //若关键字大于结点的数据 
            head=head-&gt;right;  //在右子树上查找                             
    }
    //判断添加到左子树还是右子树 
    if(key&lt;parent-&gt;data) //小于父结点 
        parent-&gt;left=p; //添加到左子树
    else           //大于父结点 
        parent-&gt;right=p; //添加到右子树 
}</code></pre> 
<p><br> 2、创建二叉树（将数组保存到二叉树中）</p> 
<p> </p> 
<pre><code class="language-html">void CreateBST(BSTree *t,int data[],int n)//n个数据在数组d中，tree为二叉排序树根
{
    int i;
    t-&gt;data=data[0];
    t-&gt;left=t-&gt;right=NULL;
    for(i=1;i&lt;n;i++)
    {
        InsertBST(t,data[i]);
    }
}</code></pre> 
<p><br> 3、中序遍历（检查二叉树是否建立成功）</p> 
<pre><code class="language-html">void BST_LDR(BSTree *t)  //中序遍历 
{
     if(t)//树不为空，则执行如下操作 
     {
         BST_LDR(t-&gt;left); //中序遍历左子树
         printf("%d ",t-&gt;data); //输出结点数据 
         BST_LDR(t-&gt;right); //中序遍历右子树/
     }
     return; 
} </code></pre> 
<p><br> 4、查找节点</p> 
<p>在二叉树中查找指定的关键字key的过程：</p> 
<p>①从根节点开始查找。</p> 
<p>②若节点为空，则查找失败。</p> 
<p>③若key值大小与跟节点数据相等，表示查找成功，返回节点指针。</p> 
<p>④若key值小于节点的数据，继续在当前节点的左子树查找。</p> 
<p>⑤若key值大于节点的数据，继续在当前节点的右子树查找。</p> 
<pre><code class="language-html">BSTree *SearchBST(BSTree *t,int key)
{
    if(!t || t-&gt;data==key) //结点为空，或关键字相等 
        return t;          //返回结点指针
    else if(key&gt;t-&gt;data) //关键字大于结点数据
        return(SearchBST(t-&gt;right,key));
    else
        return(SearchBST(t-&gt;left,key));
}</code></pre> 
<p><br> 5、删除节点</p> 
<p>删除二叉排序树中的一个节点，相当于删除有序序列中的一个记录，删除节点后需要调整二叉树，使其仍然保持二叉排序树的特点。</p> 
<p>①删除的节点是二叉排序树的叶节点，即t-&gt;left  t-&gt;right都为null。由于删除该节点不会破坏二叉排序树的结构，只需要修改t节点的父节点的指针，并释放t节点占用内存即可。</p> 
<p>②若t节点只有一个子树（即t-&gt;left   t-&gt;right有一个为空），这时，只需要修改t节点的父节点，使其子节点指针的值为t-&gt;left  或者 t-&gt;right 即可。</p> 
<p>③若t节点有两个子树，此时的操作相对复杂些，需要从二叉排序树的中序遍历中找到<span style="color:#ff0000">被删除节点的后继节点</span>。</p> 
<pre><code class="language-html">void BST_Delete(BSTree *t,int key)
{
    BSTree *p,*parent,*l,*l1;
    int child=0;//0表示左子树，1表示右子树 
    if(!t) return;     //二叉排序树为空，则退出
    p=t;
    parent=p;
    while(p)           //二叉排序树有效 
    {        
        if(p-&gt;data==key)
        {
            if(!p-&gt;left &amp;&amp; !p-&gt;right) //叶结点(左右子树都为空) 
            {
                if(p==t) //被删除的是根结点 
                {
                    free(p);//释放被删除结点 
                }
                else if(child==0) //父结点为左子树 
                {
                    parent-&gt;left=NULL; //设置父结点左子树为空 
                    free(p); //释放结点空间 
                }
                else //父结点为右子树 
                {
                    parent-&gt;right=NULL; //设置父结点右子树为空 
                    free(p); //释放结点空间 
                }
            }
            else if(!p-&gt;left) //左子树为空，右子树不为空
            {
                if(child==0) //是父结点的左子树
                    parent-&gt;left=p-&gt;right;
                else //是父结点的右子树             
                    parent-&gt;left=p-&gt;left;
                free(p); //释放被删除结点
            }
            else if(!p-&gt;right)//右子树为空，左子树不为空
            {
                 if(child==0) //是父结点的左子树
                    parent-&gt;right=p-&gt;right;
                else //是父结点的右子树             
                    parent-&gt;right=p-&gt;left;
                free(p); //释放被删除结点       
            }
            else  //左右子树都不为空 
            {
                l1=p; //保存左子树的父结点 
                l=p-&gt;right; //从当前结点的右子树进行查找 
                while(l-&gt;left) //左子树不为空 
                {
                    l1=l;
                    l=l-&gt;left; //查找左子树 
                }
                p-&gt;data=l-&gt;data; //将左子树的数据保存到被删除结点
                l1-&gt;left=NULL; //设置父结点的左子树指针为空 
                free(l1); //释放左子树占的内存空间
            }
            p=NULL;
        }
        else if(key&lt;p-&gt;data) //需删除记录的关键字小于结点的数据 
        {
            child=0;//标记在当前结点左子树查找
            parent=p; //保存当前结点作父结点 
            p=p-&gt;left; //查找右子树 
        }
        else //需删除记录的关键字大于结点的数据 
        {
            child=1;//标记在当前结点右子树查找
            parent=p;//保存当前结点作父结点 
            p=p-&gt;right; //查找右子树 
        }    
    } 
}
</code></pre> 
<p><br>  </p> 
<p> </p> 
<p>6、main主函数测试代码是否正确</p> 
<pre><code class="language-html">int main()
{
    int i,key;
    BSTree bst,*pos; //保存二叉排序树根结点
    printf("原数据:"); 
    for(i=0;i&lt;ARRAYLEN;i++)
        printf("%d ",source[i]);
    printf("\n");
    CreateBST(&amp;bst,source,ARRAYLEN);
    printf("遍历二叉排序树:"); 
    BST_LDR(&amp;bst);
    BST_Delete(&amp;bst,37);
    printf("\n删除结点后的结点:"); 
    BST_LDR(&amp;bst);    
    printf("\n请输入关键字:");
    scanf("%d",&amp;key); 
   pos=SearchBST(&amp;bst,key);
    if(pos)
       printf("查找成功，该结点的地址：%x\n",pos);
    else
        printf("查找失败!\n");
    getch();
    return 0;
}</code></pre> 
<p><br>  </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c83ca7b385c10b2c3368aee7e5d5e407/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">内存和CPU匹配方法详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b82a9f14eb367b3c2d87c1383dfd692/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ActiveX控件实现IobjectSafety接口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>