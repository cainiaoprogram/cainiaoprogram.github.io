<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python读取中文Excel问题解决 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python读取中文Excel问题解决" />
<meta property="og:description" content="Python读取中文Excel问题解决 为什么读取中文Excel会出错两个难题试验结果 为什么读取中文Excel会出错 在计算机中，一个字节(byte)有8个比特，即可以表达2^8次方即256个字符，一个英文字母或符号占一个字节，即ASCII码。ASCII码有意只编了128个。
但是这个表达对于其他语言是不够用的，特别是东亚文字。于是上世纪八九十年代出现了很多并行的编码表，将2个字节对应为日文、韩文、简体或繁体汉字。Windows官方使用cp936的编码表，相当于gb18030. 所以在Windows系统里，不论是文本内容，还是文件名，都是以它来解码的。
这样就造成了两种错误，一是如果以ASCII码去读，会发生错误（因为还有128种字节不被ASCII定义），这就逼的程序去指定编码表。但是依然会发生编码表错误，即错误解码，例如原来是日文的编码错解成gb18030就会出错，形成乱码。
后来又出现了UTF-8，用1-3个字节将所有的语言的字符都包括进来，1-3个字节是为了兼容ASCII，实际可以只用2个字节，而2个字节的是unicode，规定内存中使用。
这样，尽管在内存中字节是通用的unicode，但是永久存储却有多种编码，即便都是中文，也有cp936, gb2312, gbk, gb18030和utf-8几种. 我忘了cp936是对应哪种gb了，但是一个割裂的后果是微软体系只要安装时指定简体中文，都用cp936，而后来流行的网页，Linux及新兴语言，特别是Python都默认utf-8.
两个难题 如上，一个是在Windows系统中运行，如果碰上中文文件名，必须用cp936或gb18030去解码它。如果你写了一个中文的文件名，而python根据utf-8规则去把它翻译成字节，就会在底层的文件名上不匹配，因为该中文在cp936的规则下翻译成另外的字节。报错是找不到该文件。
我参照了很多网上内容，有以下三种解决方法，前两种类似，是用unicode：
u&#39;中文.xlsx&#39; r&#39;中文.xlsx&#39; &#39;中文.xlsx&#39;.encode(&#39;cp936&#39;) 而最后一种直接指定解码出字节。最后一种经常是失效的，而前两种在所有的库中都可以调用，应该是被python底层支持了。
第二个难题是读取文件内容时正确指定编码。如果直接用Excel编辑，或者c#之类的插件生成的一般里面的文字是cp936的，而python的各excel库偏偏喜欢默认编码为utf-8
一个非常简单粗暴的办法是在加载了相应库之后，把Excel文件对象的encoding属性强行从utf-8更改：
xlrd改文件内容编码
xlrd.Book.encoding = &#34;gbk&#34; 这样即使库没有提供改编码接口，也实际改了。当然xlrd还提供了接口。
如果cp936的内容强行用utf-8去解，会发生报错
UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xce in position 64: invalid continuation byte 试验结果 xlrd和openpyxl可以同时解决以上两个问题, 下面是xlrd的一段代码。
import xlrd, xlwt xlrd.Book.encoding = &#34;cp936&#34; exl = xlrd.open_workbook(u&#39;上海代码.xlsx&#39;) print(&#34;首行为\n &#34;, exl.sheets()[0].row_values(0) ) openpyxl也可以，但是它的语法过于复杂：
# a trial to see if openpyxl works import openpyxl openpyxl.Workbook.encoding=&#34;cp936&#34; book = openpyxl." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/676ec12cbfceb125493131d567d980f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-15T17:33:23+08:00" />
<meta property="article:modified_time" content="2020-09-15T17:33:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python读取中文Excel问题解决</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Python读取中文Excel问题解决</h4> 
 <ul><li><a href="#Excel_2" rel="nofollow">为什么读取中文Excel会出错</a></li><li><a href="#_13" rel="nofollow">两个难题</a></li><li><a href="#_38" rel="nofollow">试验结果</a></li></ul> 
</div> 
<p></p> 
<h2><a id="Excel_2"></a>为什么读取中文Excel会出错</h2> 
<p>在计算机中，一个字节(byte)有8个比特，即可以表达2^8次方即256个字符，一个英文字母或符号占一个字节，即ASCII码。ASCII码有意只编了128个。</p> 
<p>但是这个表达对于其他语言是不够用的，特别是东亚文字。于是上世纪八九十年代出现了很多并行的编码表，将2个字节对应为日文、韩文、简体或繁体汉字。Windows官方使用<strong>cp936</strong>的编码表，相当于gb18030. 所以在Windows系统里，<strong>不论是文本内容，还是文件名</strong>，都是以它来解码的。</p> 
<p>这样就造成了两种错误，一是如果以ASCII码去读，会发生错误（因为还有128种字节不被ASCII定义），这就逼的程序去指定编码表。但是依然会发生编码表错误，即错误解码，例如原来是日文的编码错解成gb18030就会出错，形成乱码。</p> 
<p>后来又出现了UTF-8，用1-3个字节将所有的语言的字符都包括进来，1-3个字节是为了兼容ASCII，实际可以只用2个字节，而2个字节的是unicode，规定内存中使用。</p> 
<p>这样，尽管在内存中字节是通用的unicode，但是永久存储却有多种编码，即便都是中文，也有cp936, gb2312, gbk, gb18030和utf-8几种. 我忘了cp936是对应哪种gb了，但是一个割裂的后果是微软体系只要安装时指定简体中文，都用cp936，而后来流行的网页，Linux及新兴语言，特别是Python都默认utf-8.</p> 
<h2><a id="_13"></a>两个难题</h2> 
<p>如上，一个是在Windows系统中运行，如果碰上中文文件名，必须用cp936或gb18030去解码它。如果你写了一个中文的文件名，而python根据utf-8规则去把它翻译成字节，就会在底层的文件名上不匹配，因为该中文在cp936的规则下翻译成另外的字节。报错是找不到该文件。</p> 
<p>我参照了很多网上内容，有以下三种解决方法，前两种类似，是用unicode：</p> 
<pre><code class="prism language-python">u<span class="token string">'中文.xlsx'</span>
r<span class="token string">'中文.xlsx'</span>
<span class="token string">'中文.xlsx'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'cp936'</span><span class="token punctuation">)</span>
</code></pre> 
<p>而最后一种直接指定解码出字节。最后一种经常是失效的，而前两种在所有的库中都可以调用，应该是被python底层支持了。</p> 
<p>第二个难题是读取文件内容时正确指定编码。如果直接用Excel编辑，或者c#之类的插件生成的一般里面的文字是cp936的，而python的各excel库偏偏喜欢默认编码为utf-8</p> 
<p>一个非常简单粗暴的办法是在加载了相应库之后，把Excel文件对象的encoding属性强行从utf-8更改：<br> <a href="https://blog.csdn.net/aaronchan1028/article/details/17577939">xlrd改文件内容编码</a></p> 
<pre><code>xlrd.Book.encoding = "gbk"
</code></pre> 
<p>这样即使库没有提供改编码接口，也实际改了。当然xlrd还提供了接口。<br> 如果cp936的内容强行用utf-8去解，会发生报错</p> 
<pre><code>UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xce in position 64: invalid continuation byte
</code></pre> 
<h2><a id="_38"></a>试验结果</h2> 
<p>xlrd和openpyxl可以同时解决以上两个问题, 下面是xlrd的一段代码。</p> 
<pre><code>import xlrd, xlwt
xlrd.Book.encoding = "cp936" 
exl = xlrd.open_workbook(u'上海代码.xlsx')
print("首行为\n ", exl.sheets()[0].row_values(0) )
</code></pre> 
<p>openpyxl也可以，但是它的语法过于复杂：</p> 
<pre><code class="prism language-python"><span class="token comment"># a trial to see if openpyxl works</span>
<span class="token keyword">import</span> openpyxl
openpyxl<span class="token punctuation">.</span>Workbook<span class="token punctuation">.</span>encoding<span class="token operator">=</span><span class="token string">"cp936"</span>
book <span class="token operator">=</span> openpyxl<span class="token punctuation">.</span>load_workbook<span class="token punctuation">(</span>u<span class="token string">'上海代码.xlsx'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>sheetnames<span class="token punctuation">)</span>
sheet <span class="token operator">=</span> book<span class="token punctuation">.</span>active
<span class="token keyword">print</span><span class="token punctuation">(</span>sheet<span class="token punctuation">[</span><span class="token string">'A1'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
</code></pre> 
<p>然后直接在cmd窗口进到相应目录运行它（注意用vscode可能被vscode自己默认的utf-8或工作路径污染出错），两个难题同时解决了</p> 
<pre><code class="prism language-cmd">Microsoft Windows [版本 6.1.7601]
版权所有 (c) 2009 Microsoft Corporation。保留所有权利。

C:\Users\Y&gt;d:

D:\&gt;python openpyxl_.py
C:\Python37-32\lib\site-packages\openpyxl\styles\stylesheet.py:214: UserWarning:
 Workbook contains no default style, apply openpyxl's default
  warn("Workbook contains no default style, apply openpyxl's default")
['Sheet0']
证券代码

D:\&gt;
</code></pre> 
<p>下一篇会讲写excel。我看到通用的视频是讲xlwt或openpyxl，其实这两个都不实用。这些培训真是误人子弟。具体如何，下期再见。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/911e119a11f83df95bd641aa2124e11b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PowerBI x Python 之关联分析（上）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6227b2263e115038f33b0cd9a6fe7b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">google  firefor  历史版本下载谷歌火狐浏览器版本下载大全</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>