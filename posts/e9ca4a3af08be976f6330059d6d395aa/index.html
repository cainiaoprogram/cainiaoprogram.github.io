<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉排序树、平衡二叉树、红黑树、B树、B&#43;树 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二叉排序树、平衡二叉树、红黑树、B树、B&#43;树" />
<meta property="og:description" content="全民制作人们，大家好。我是练习时长两天半的个人练习册，喜欢B树 ，B&#43;树， BST树， AVL树，来 red black ~
目录
一、二叉排序树(BST树)
1.1二叉排序树的定义
1.2二叉排序树的查找
1.3二叉排序树的插入
1.4二叉排序树的构造 1.5二叉排序树的删除 1.6二叉排序树的查找效率分析 二、平衡二叉树(AVL树)
2.1平衡二叉树的定义
1.2平衡二叉树的插入
1.3平衡二叉树的删除 1.4平衡二叉树的查找效率分析 三、红黑树
3.1红黑树的定义
3.2红黑树的插入 3.3红黑树的构造
3.4红黑树的删除 四、B树
4.1 B树的定义 4.2 B树的高度
4.3 B树的查找 4.4 B树的插入 4.5 B树的删除 五、B&#43;树
5.1 B&#43;树的定义 5.2 B树与B&#43;树的对比
5.3 B&#43;树的两种查找运算：
六、小结 顺序查找、折半查找、分块查找都是对线性表进行查找操作，它是静态查找表。即我们一般不对它进行插入和删除操作，因为如果是无序的，插入删除很方便但是查找的效率过低；如果是有序的，折半查找的效率不错但是插入删除太麻烦，所以我们下面要讨论的诸多树型查找就是动态查找表，它们方便进行插入删除操作的同时查找效率也不错。值得一提的是，它们是我们为了方便查找而定义的一种逻辑结构，属于是面向查找操作的数据结构，那么我们对它们复杂的定义也不足为奇了，这里点名红黑树。
一、二叉排序树(BST树) 1.1二叉排序树的定义 又称二叉查找树、二叉搜索树、BST(BinarySearch Tree)树。
它是一棵空树，或者是具有以下性质的二叉树：
若左子树非空，则左子树上所有结点的值均小于根结点的值。若右子树非空，则右子树上所有结点的值均大于根结点的值。左、右子树也分别是一棵二叉排序树。 对二叉排序树进行中序遍历，可以得到一个递增的有序序列。
1.2二叉排序树的查找 二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。
BSTNode *BST_Search(BiTree T,ElemType key) {//非递归 while(T!=NULL&amp;&amp;key!=T-&gt;data) {//若树空或者查找成功退出循环 if(key&lt;T-&gt;data) T=T-&gt;lchild;//继续往左子树中查找 else T=T-&gt;rchild;//继续往右子树中查找 } return T; } BSTNode *BST_Search(BiTree T,ElemType key) {//递归 if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e9ca4a3af08be976f6330059d6d395aa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-06T16:25:11+08:00" />
<meta property="article:modified_time" content="2023-07-06T16:25:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉排序树、平衡二叉树、红黑树、B树、B&#43;树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong><span style="color:#1c7331;">全民制作人们，大家好。我是练习时长两天半的个人练习册，喜欢B树 ，B+树， BST树， AVL树，来 red black  ~</span></strong></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91(BST%E6%A0%91)-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%28BST%E6%A0%91%29" rel="nofollow">一、二叉排序树(BST树)</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">1.1二叉排序树的定义</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">1.2二叉排序树的查找</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">1.3二叉排序树的插入</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%C2%A0" rel="nofollow">1.4二叉排序树的构造 </a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">1.5二叉排序树的删除 </a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%C2%A0" rel="nofollow">1.6二叉排序树的查找效率分析 </a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL%E6%A0%91)-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%28AVL%E6%A0%91%29" rel="nofollow">二、平衡二叉树(AVL树)</a></p> 
<p id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">2.1平衡二叉树的定义</a></p> 
<p id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">1.2平衡二叉树的插入</a></p> 
<p id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">1.3平衡二叉树的删除 </a></p> 
<p id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%C2%A0" rel="nofollow">1.4平衡二叉树的查找效率分析 </a></p> 
<p id="%E4%B8%89%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow">三、红黑树</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0" rel="nofollow">3.1红黑树的定义</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0" rel="nofollow">3.2红黑树的插入 </a></p> 
<p id="3.3%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-toc" style="margin-left:80px;"><a href="#3.3%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0" rel="nofollow">3.3红黑树的构造</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">3.4红黑树的删除 </a></p> 
<p id="%E5%9B%9B%E3%80%81B%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81B%E6%A0%91" rel="nofollow">四、B树</a></p> 
<p id="B%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0-toc" style="margin-left:80px;"><a href="#B%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0" rel="nofollow">4.1 B树的定义 </a></p> 
<p id="B%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6-toc" style="margin-left:80px;"><a href="#B%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6" rel="nofollow">4.2 B树的高度</a></p> 
<p id="B%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#B%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%C2%A0%C2%A0" rel="nofollow">4.3 B树的查找  </a></p> 
<p id="B%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0-toc" style="margin-left:80px;"><a href="#B%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0" rel="nofollow">4.4 B树的插入 </a></p> 
<p id="B%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:80px;"><a href="#B%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">4.5 B树的删除 </a></p> 
<p id="%E4%BA%94%E3%80%81B%2B%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81B%2B%E6%A0%91" rel="nofollow">五、B+树</a></p> 
<p id="B%2B%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0-toc" style="margin-left:80px;"><a href="#B%2B%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0" rel="nofollow">5.1 B+树的定义 </a></p> 
<p id="B%E6%A0%91%E4%B8%8EB%2B%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#B%E6%A0%91%E4%B8%8EB%2B%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">5.2 B树与B+树的对比</a></p> 
<p id="5.3%20B%2B%E6%A0%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9F%A5%E6%89%BE%E8%BF%90%E7%AE%97%EF%BC%9A-toc" style="margin-left:80px;"><a href="#5.3%20B%2B%E6%A0%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9F%A5%E6%89%BE%E8%BF%90%E7%AE%97%EF%BC%9A" rel="nofollow">5.3 B+树的两种查找运算：</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%B0%8F%E7%BB%93%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%B0%8F%E7%BB%93%C2%A0" rel="nofollow">六、小结 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<p id="main-toc"><span style="color:#4da8ee;"><strong>顺序查找、折半查找、分块查找都是对线性表进行查找操作，它是静态查找表</strong>。</span>即我们一般不对它进行插入和删除操作，因为如果是无序的，插入删除很方便但是查找的效率过低；如果是有序的，折半查找的效率不错但是插入删除太麻烦，<span style="color:#4da8ee;"><strong>所以我们下面要讨论的诸多树型查找就是动态查找表，它们方便进行插入删除操作的同时查找效率也不错。</strong></span>值得一提的是，它们是我们为了方便查找而定义的一种逻辑结构，属于是面向查找操作的数据结构，那么我们对它们复杂的定义也不足为奇了，这里点名红黑树。</p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91(BST%E6%A0%91)"><span style="color:#1a439c;">一、二叉排序树(BST树)</span></h2> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">1.1二叉排序树的定义</span></span></h4> 
<p><strong>又称二叉查找树、二叉搜索树、BST(BinarySearch Tree)树。</strong></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>它是一棵空树，或者是具有以下性质的二叉树：</strong></span></p> 
 <ol><li><span style="color:#0d0016;"><strong>若左子树非空，则</strong></span><span style="color:#4da8ee;"><strong>左子树</strong></span><span style="color:#0d0016;"><strong>上所有结点的值均</strong></span><span style="color:#4da8ee;"><strong>小于</strong></span><span style="color:#0d0016;"><strong>根结点的值。</strong></span></li><li><span style="color:#0d0016;"><strong>若右子树非空，则</strong></span><span style="color:#4da8ee;"><strong>右子树</strong></span><span style="color:#0d0016;"><strong>上所有结点的值均</strong></span><span style="color:#4da8ee;"><strong>大于</strong></span><span style="color:#0d0016;"><strong>根结点的值。</strong></span></li><li><span style="color:#0d0016;"><strong>左、右子树也分别是一棵二叉排序树。</strong></span></li></ol> 
</blockquote> 
<p><img alt="" height="248" src="https://images2.imgbox.com/db/2f/ng4I1kEo_o.png" width="500"></p> 
<p><span style="color:#0d0016;">对二叉排序树进行中序遍历，可以得到一个递增的有序序列。</span></p> 
<p></p> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">1.2二叉排序树的查找</span></span></h4> 
<blockquote> 
 <p><strong><span style="color:#4da8ee;">二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程</span><span style="color:#9c8ec1;">。</span></strong>若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。</p> 
</blockquote> 
<p><img alt="" height="670" src="https://images2.imgbox.com/8d/53/lwgXDI5A_o.png" width="797"></p> 
<pre><code class="language-cpp">BSTNode *BST_Search(BiTree T,ElemType key)
{//非递归
    while(T!=NULL&amp;&amp;key!=T-&gt;data)
    {//若树空或者查找成功退出循环
        if(key&lt;T-&gt;data) T=T-&gt;lchild;//继续往左子树中查找
        else T=T-&gt;rchild;//继续往右子树中查找
    }
    return T;
}
BSTNode *BST_Search(BiTree T,ElemType key)
{//递归
    if (!T)	//  查找不成功 
    return NULL; 
	else if (key==T-&gt;data) //  查找成功 
	return T; 
	else if (key&lt;T-&gt;data) 
	return SearchBST(T-&gt;lchild, key);  //在左子树中继续查找 
	else  
	return SearchBST(T-&gt;rchild, key);  // 在右子树中继续查找 
}</code></pre> 
<p>递归的代码同样简单，但效率更低。</p> 
<p></p> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">1.3二叉排序树的插入</span></span></h4> 
<p><strong>二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找的过程中，当树中不存在关键字值等于给定值的结点时再进行插入的。</strong></p> 
<blockquote> 
 <p><strong>插入结点的过程如下：</strong></p> 
 <ol><li>若原二叉排序树为空树，则直接插入结点；</li><li>若关键字k小于根结点的值，则插入到左子树，若关键字k大于根结点的值，则插入到右子树。<span style="color:#fe2c24;">插入的结点一定是一个新添加的叶结点</span><strong><span style="color:#9c8ec1;">，</span></strong>且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。</li></ol> 
</blockquote> 
<pre><code class="language-cpp">int BST_Insert(BiTree &amp;T,keyType k)
{//递归实现，最坏空间复杂度O(n)
    if (!T)	
  { T=（BiTree）malloc(sizeof(BSTNode));
    T-&gt;data=k;
    T-&gt;lchild=T-&gt;rchild=NULL;
    return 1; // 插入成功 
  }
    else if (k==T-&gt;data) 
	return 0; //树中已有该关键值，插入失败
	else if (k&lt;T-&gt;data) 
	return BST_Insert(T-&gt;lchild, k);  //在左子树中插入
	else  
	return BST_Insert(T-&gt;rchild, k);  // 在右子树中插入
}
int BST_Insert(BiTree &amp;T,keyType k)
{//非递归
    while(T!=NULL&amp;&amp;k!=T-&gt;data)
    {//当该插入时或者插入失败时跳出循环
        if(k&lt;T-&gt;data) T=T-&gt;lchild;//继续往左子树中插入
        else T=T-&gt;rchild;//继续往右子树中插入
    }
    
    if (T==NULL)	
  { T=（BiTree）malloc(sizeof(BSTNode));
    T-&gt;data=k;
    T-&gt;lchild=T-&gt;rchild=NULL;
    return 1; // 插入成功 
  }
    else return 0;//树中已有该关键值，插入失败
}</code></pre> 
<p>可以看到插入的效率和查找相同，不需要移动其他记录的位置，它表明，<strong>二叉排序树既拥有类似于折半查找的特性，又采用了链表作为存储结构，因此是动态查找表的一种适宜表示。</strong></p> 
<p></p> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">1.4二叉排序树的构造 </span></span></h4> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>从一棵空树出发，依次输入元素，将它们插入二叉排序树中合适位置</strong></span>。构造BST树的过程即为依次插入给定值的过程。</p> 
</blockquote> 
<pre><code class="language-cpp">void Creat_BST(BiTree &amp;T,KeyType str[],int n)
{
    T=NULL;
    int i=0;
    while(i&lt;n)
    {
        BST_Insert(T,str[i]);
        i++;
    }
}</code></pre> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">1.5二叉排序树的删除 </span></span></h4> 
<blockquote> 
 <p><strong>需要使删除结点后的树仍满足二叉排序树的特性<span style="color:#9c8ec1;">，</span>删除操作的过程分3种情况讨论：</strong></p> 
 <ol><li><span style="color:#4da8ee;">若被删除结点z是叶结点，</span><span style="color:#0d0016;">则直接删除，不会破坏二叉排序树的性质。</span></li><li><span style="color:#4da8ee;">若被删除结点z只有一棵左子树或右子树</span><span style="color:#0d0016;">，则让z的子树成为z的父节点的子树，替代z的位置。</span></li><li><span style="color:#4da8ee;">若被删除结点z有左子树和右子树</span><span style="color:#0d0016;">，则让z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换为了第一种或第二种情况。</span></li></ol> 
</blockquote> 
<p><span style="color:#0d0016;">前二种情况比较直观，下面给出图解讨论第三种情况：</span></p> 
<p><img alt="" height="417" src="https://images2.imgbox.com/61/46/qvSNBMgW_o.png" width="518"></p> 
<p> <img alt="" height="452" src="https://images2.imgbox.com/59/0a/V6ylyPyn_o.png" width="518"></p> 
<p> <img alt="" height="351" src="https://images2.imgbox.com/93/a6/DSYWXQzO_o.png" width="513"></p> 
<p><span style="color:#fe2c24;">如果我们按上述操作删除48后再插入48，显然二叉排序树已经不同。</span></p> 
<p></p> 
<h4 id="%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">1.6二叉排序树的查找效率分析 </span></span></h4> 
<blockquote> 
 <p><strong><span style="color:#4da8ee;">二叉排序树的查找效率，主要取决于树的高度</span><span style="color:#9c8ec1;">。</span></strong></p> 
 <p><span style="color:#0d0016;">若二叉排序树的左、右子树的高度之差的绝对值不超过1，则这样的二叉排序树称为平衡二叉树，它的平均查找长度为O(logn)。</span></p> 
 <p><span style="color:#0d0016;">若二叉排序树是一个只有左(右)孩子的单支树，(类似于有序的线性表)，则其平均查找长度为O(n)。</span></p> 
</blockquote> 
<p><span style="color:#0d0016;">明确使用(mid=(low+high)/2)时</span><span style="color:#4da8ee;"><strong>二分查找的判定树唯一</strong>，<strong>而二叉排序树的查找不唯一</strong></span><span style="color:#0d0016;">，相同的关键字其插入的顺序不同可能生成不同的二叉排序树。</span></p> 
<p><span style="color:#4da8ee;"><strong>当有序表是静态查找表时，宜选择顺序表作为其存储结构，故采用二分查找实现查找操作；</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>当有序表是动态查找表时，宜选择二叉排序树作为其逻辑结构，此时插入删除，查找的时间复杂度都是O(logn)。</strong></span></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL%E6%A0%91)"><span style="color:#1a439c;">二、平衡二叉树(AVL树)</span></h2> 
<h4 id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">2.1平衡二叉树的定义</span></span></h4> 
<p><strong>平衡二叉树又称平衡二叉搜索树</strong>，是为了避免构建二叉搜索树时树的高度增长过快，降低其性能，规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1。<strong>又称ALV树</strong>，得名于它的发明者G.M.Adelson-Velsky和E.M.Landis。</p> 
<blockquote> 
 <p><span style="color:#0d0016;">平衡二叉树是一棵空树，或者是具有以下性质的二叉树：</span></p> 
 <ol><li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li><li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li><li>左、右子树也分别是一棵平衡二叉树。</li><li><strong><span style="color:#4da8ee;">左子树和右子树的高度差的绝对值不超过1。</span></strong></li></ol> 
</blockquote> 
<p><img alt="" height="321" src="https://images2.imgbox.com/b1/52/VraUsXub_o.png" width="800"></p> 
<blockquote> 
 <p><span style="color:#0d0016;">将AVL树上<strong>结点的平衡因子</strong>定义为</span><span style="color:#4da8ee;"><strong>该结点的左子树的深度减去它的右子树的深度</strong></span><span style="color:#0d0016;">，则AVL树上所有结点的平衡因子只可能是-1、0、1。</span></p> 
 <p></p> 
</blockquote> 
<p></p> 
<h4 id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">1.2平衡二叉树的插入</span></span></h4> 
<blockquote> 
 <p><strong>平衡二叉树保证平衡的基本思想如下</strong>：每当在二叉排序树中插入(或删除)一个结点时，</p> 
 <ol><li>首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。</li><li>若导致了不平衡，则先找到<span style="color:#4da8ee;"><strong>插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A</strong></span>，再对以A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</li></ol> 
</blockquote> 
<p><span style="color:#4da8ee;"><strong>调整的对象为</strong></span><span style="color:#0d0016;"><strong>最小不平衡子树</strong></span><span style="color:#9c8ec1;"><strong>，</strong></span><span style="color:#4da8ee;"><strong>即其根结点是离插入结点最近，且平衡因子的绝对值超过1的祖先结点的子树。</strong></span></p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/12/58/LMWB2DM3_o.png" width="512"></p> 
<p>我们对其进行平衡旋转处理，<span style="color:#fe2c24;">经过旋转处理后子树深度与插入之前相同，</span>因而不影响插入路径上所有祖先结点的平衡度。</p> 
<p><strong>平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应调整，下面给出<span style="color:#4da8ee;">四种需要旋转的情况</span></strong>：</p> 
<blockquote> 
 <ul><li><strong>LL平衡旋转：</strong>由于在<strong><span style="color:#9c8ec1;">A结点的左孩子结点的左子树插入了新结点</span></strong>，A的平衡因子从1增加到2，此时我们需<span style="color:#fe2c24;">要进行一次右旋操作</span>，即A的左孩子结点B向右上旋转代替结点A成为根结点，A结点向右下旋转成为根结点B的右孩子结点，而B的原右子树成为结点A的左子树。</li></ul> 
</blockquote> 
<p><img alt="" height="484" src="https://images2.imgbox.com/b8/68/DYJubCCE_o.png" width="1200"></p> 
<blockquote> 
 <ul><li> <strong>RR平衡旋转：</strong>由于在<strong><span style="color:#9c8ec1;">A结点的右孩子结点的右子树插入了新结点</span></strong>，A的平衡因子的<span style="color:#fe2c24;">绝对值</span>从1增加到2，此时我们<span style="color:#fe2c24;">需要进行一次左旋操作</span>，即A的右孩子结点B向左上旋转代替结点A成为根结点，A结点向左下旋转成为根结点B的左孩子结点，而B的原左子树成为结点A的右子树。</li></ul> 
</blockquote> 
<p><img alt="" height="632" src="https://images2.imgbox.com/97/68/ir3yjLbZ_o.png" width="1200"></p> 
<blockquote> 
 <ul><li> <strong>LR平衡旋转：</strong>由于在<strong><span style="color:#9c8ec1;">A结点的左孩子结点的右子树插入了新结点</span></strong>，A的平衡因子从1增加到2，导致以A为根的子树失去平衡，需要进行两次旋转操作，<span style="color:#fe2c24;">先左旋转后右旋转</span>。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后把该C结点向右上旋转提升到A结点的位置。</li></ul> 
</blockquote> 
<p><img alt="" height="534" src="https://images2.imgbox.com/f5/3a/yX4CL48M_o.png" width="1200"></p> 
<p><img alt="" height="694" src="https://images2.imgbox.com/2a/d5/U3ifeTDA_o.png" width="1135"></p> 
<blockquote> 
 <ul><li>  <strong>RL平衡旋转：</strong>由于在<strong><span style="color:#9c8ec1;">A结点的右孩子结点的左子树插入了新结点</span></strong>，A的平衡因子的绝对值从1增加到2，导致以A为根的子树失去平衡，需要进行两次旋转操作，<span style="color:#fe2c24;">先右旋转后左旋转</span>。先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后把该C结点向左上旋转提升到A结点的位置。</li></ul> 
</blockquote> 
<p><img alt="" height="591" src="https://images2.imgbox.com/19/c3/Q08StK7Z_o.png" width="1200"></p> 
<p><img alt="" height="663" src="https://images2.imgbox.com/33/1b/sJAztVvd_o.png" width="1110"></p> 
<p><strong>总结一下四种情况：</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:300px;"><tbody><tr><td>分类</td><td>产生原因</td><td>解决方法</td></tr><tr><td>LL平衡旋转</td><td>左孩子的左子树插入结点</td><td>右旋转</td></tr><tr><td>RR平衡旋转</td><td>右孩子的右子树插入结点</td><td>左旋转</td></tr><tr><td>LR平衡旋转</td><td>左孩子的右子树插入结点</td><td>先左旋再右旋</td></tr><tr><td>RL平衡旋转</td><td>右孩子的左子树插入结点</td><td>先右旋再左旋</td></tr></tbody></table> 
<p></p> 
<h4 id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">1.3平衡二叉树的删除 </span></span></h4> 
<blockquote> 
 <p><strong>与平衡二叉树的插入操作类似，以删除结点w为例来说明平衡二叉树删除操作的步骤：</strong></p> 
 <ol><li>用二叉排序树的删除方法对结点w进行删除操作。</li><li>从结点w开始，向上回溯，找到第一个不平衡的结点z(还是要对最小不平衡树操作);<span style="color:#9c8ec1;"><strong>y为结点z的高度最高的孩子结点；x是结点y的高度最高的孩子结点。</strong></span></li><li>然后对以z为根的最小不平衡树进行平衡调整，其中x、y和z可能得位置有4种情况:</li></ol> 
 <ul><li>y是z的左孩子，x是y的左孩子(这种情况即为LL,右旋转)</li><li>y是z的右孩子，x是y的右孩子(这种情况即为RR,左旋转)</li><li>y是z的左孩子，x是y的右孩子(这种情况即为LR,先左旋再右旋)</li><li>y是z的右孩子，x是y的左孩子(这种情况即为LR,先左旋再右旋)</li></ul> 
</blockquote> 
<p>然后最小不平衡子树z就被调整为平衡了，<span style="color:#fe2c24;">但注意此时z的高度可能会减少</span>，<span style="color:#fe2c24;">因此我们可能需要向上回溯对z的祖先结点进行平衡调整</span>，甚至回溯到根结点(导致树高减1)。这一点与插入不同，插入结点后最小不平衡子树经过旋转处理后子树深度与插入之前相同。</p> 
<p><strong><span style="color:#0d0016;">举例删除操作为何类似插入操作：</span></strong></p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/9d/f3/sgsrJcRN_o.png" width="1200"></p> 
<p><span style="color:#0d0016;"> <strong>下图</strong></span><strong><span style="color:#0d0016;">给出删除操作可能会减少树高的情况:</span></strong><img alt="" height="475" src="https://images2.imgbox.com/63/de/7x7F0wRx_o.png" width="1200"></p> 
<p><img alt="" height="564" src="https://images2.imgbox.com/3e/3d/ySrErEGv_o.png" width="1200"></p> 
<p>总之，插入操作是因为初始左子树低，右子树高，我们往右子树插入导致不平衡，那我们一定可以通过旋转改变树形把这个插入的结点搞到左子树，旋转后整体高度不变。左子树高，右子树低同理。</p> 
<p>删除操作是因为初始左子树低，右子树高，我们减少左子树的高度使之打破平衡界限，那我们通过旋转改变树形从右边借了一个结点使左子树的高度恢复，但如果右子树恰好需要这个结点来作为最后一层，我们借过之后右子树的高度减一，旋转后整体高度减一。</p> 
<p></p> 
<h4 id="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">1.4平衡二叉树的查找效率分析 </span></span></h4> 
<blockquote> 
 <p>在平衡二叉树上进行查找的过程与二叉排序树相同。在查找的过程中，<strong><span style="color:#9c8ec1;">与</span><span style="color:#4da8ee;">给定值进行比较的关键字个数不超过树的深度。</span></strong></p> 
 <p><span style="color:#4da8ee;"><strong>假设以<img alt="n_{h}" class="mathcode" src="https://images2.imgbox.com/de/68/25Zham5B_o.png">表示深度为h的AVL树中含有的最少结点数。</strong></span><strong>有<img alt="n_{h}" class="mathcode" src="https://images2.imgbox.com/76/47/2n8NuiB7_o.png">=<img alt="n_{h- 1}" class="mathcode" src="https://images2.imgbox.com/84/4b/TtuNwWvR_o.png">+<img alt="n_{h-2}" class="mathcode" src="https://images2.imgbox.com/00/97/442BkVHD_o.png">+1。</strong></p> 
 <p><span style="color:#4da8ee;"><strong>在平衡二叉树上进行查找的时间复杂度为O(logn)。</strong></span></p> 
</blockquote> 
<p><img alt="" height="528" src="https://images2.imgbox.com/9e/b5/IGKM5RQ2_o.png" width="1181"></p> 
<p>故求给定结点数的平衡二叉树的查找所需的最多比较次数可以先构造一个该结点树的最高平衡二叉树。 </p> 
<h2 id="%E4%B8%89%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91"><span style="color:#1a439c;">三、红黑树</span></h2> 
<h4 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">3.1红黑树的定义</span></span></h4> 
<p><span style="color:#0d0016;">为了保证AVL树的平衡性，我们在插入删除时频繁地调整全树整体的拓扑结构，代价较大。</span><span style="color:#4da8ee;"><strong>因此，我们对二叉排序树不再进行高度平衡的限制(AVL树)，而进行适度平衡的限制(红黑树)</strong>。</span><span style="color:#0d0016;">这样在保证查找效率的同时我们进行插入删除操作所付出的代价也更小，因此红黑树的实际应用更广泛，C++中的map和set(Java中的TreeMap和TreeSet)就是用红黑树实现的。</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">一棵红黑树是满足如下红黑性质的二叉排序树:</span></strong></p> 
 <ol><li><span style="color:#4da8ee;">每个结点或是红色，或是黑色的。</span></li><li><span style="color:#4da8ee;"><strong>根结点是黑色的。</strong></span></li><li><span style="color:#4da8ee;"><strong>叶结点</strong>(虚构的外部结点，NULL结点)<strong>都是黑色的。</strong></span></li><li><span style="color:#4da8ee;"><strong>如果一个结点是红色的，则它的两个子结点都是黑色的。</strong></span></li><li><span style="color:#4da8ee;"><strong>对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数量相同。</strong></span></li></ol> 
</blockquote> 
<ul><li><span style="color:#0d0016;">对第3条的解释：与折半查找判定树和B树(它俩的失败结点)类似，为了便于红黑树的实现和理解，引入n+1个外部叶结点，以保证红黑树中每个内部结点的左右孩子均非空。</span></li><li><span style="color:#0d0016;">对第4、5条的解释，从<strong>根结点到叶结点(不含叶结点)的任何一条简单路径上都至少有一半是黑结点</strong>，这两条定义结合起来，所以"<strong>任意结点左右子树的高度，相差不超过2倍</strong>"。这正是适度平衡的体现。</span></li></ul> 
<p><img alt="" height="572" src="https://images2.imgbox.com/c3/97/4Og3An8w_o.png" width="1182"></p> 
<p><span style="color:#4da8ee;"><strong>从某结点出发(不含该结点)到达一个叶结点的任一简单路径上的黑结点总数</strong></span><span style="color:#0d0016;">称为该结点的<strong>黑高(记为bh)</strong>。根结点的黑高为红黑树的黑高。</span></p> 
<ul><li><span style="color:#0d0016;">结论一：从根结点到叶结点的最长路径不大于最短路径的2倍。</span></li><li><span style="color:#0d0016;">结论二：有n个内部结点的红黑树的高度h≤2log(n+1)。</span></li></ul> 
<p></p> 
<h4 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">3.2红黑树的插入 </span></span></h4> 
<p><span style="color:#0d0016;">红黑树的插入过程是二叉排序树的插入过程类似，不同之处在于，红黑树中插入新结点后需要进行调整（包括重新着色和旋转操作），以满足红黑树的性质。</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">设结点z为新插入的结点，初始色为红色。插入过程如下：</span></strong></p> 
 <ol><li><span style="color:#4da8ee;">用二叉排序树的插入法插入，若结点z的父结点是黑色，结束。</span></li><li><span style="color:#4da8ee;">如果结点z的根结点，将z着为黑色(树的黑高增1)，结束。</span></li><li><span style="color:#4da8ee;"><strong>如果结点z不是根结点，并且z的父结点z.p是红色的，</strong>此时z.p.p为黑色的，z.p的兄弟结点的颜色未知，下面分为三种解决：</span></li></ol> 
 <ul><li><span style="color:#4da8ee;">①z的叔结点y是黑色的，且z是一个右孩子。</span></li><li><span style="color:#4da8ee;">②z的叔结点y是黑色的，且z是一个左孩子。</span></li><li><span style="color:#4da8ee;">③z的叔结点y是红色的(z是左或右无所谓)。</span></li><li><span style="color:#4da8ee;">结束</span></li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>对于<span style="color:#fe2c24;">①z的叔结点y是黑色的，且z是一个右孩子。</span>：</strong>(下图为LR,先左旋，再右旋)，旋转同时还要重新着色。</p> 
</blockquote> 
<p><img alt="" height="447" src="https://images2.imgbox.com/94/2b/JEgEfq5b_o.png" width="1097"></p> 
<p> 如果y(T4)是左子树还有一种对称情况(即RL，先右旋，再左旋)。</p> 
<blockquote> 
 <p><strong>对于<span style="color:#fe2c24;">②z的叔结点y是黑色的，且z是一个左孩子。</span></strong>(下图为LL，右旋一次)，旋转同时还要重新着色。</p> 
</blockquote> 
<p><img alt="" height="404" src="https://images2.imgbox.com/5e/09/ejd7I28Q_o.png" width="833"></p> 
<p> 如果y(T4)是左子树还有一种对称情况(即RR，左旋一次)</p> 
<blockquote> 
 <p><strong>对于<span style="color:#fe2c24;">③z的叔结点y是红色的(z是左或右无所谓)</span></strong><span style="color:#fe2c24;">：</span>z的父结点z.p和叔结点y都是红色的，因为z.p.p是黑色的，将z.p和y都着为黑色，z.p.p着为红色，以在局部保持性质4、5，然后把Z.P.P作为新的结点z来重复循环。</p> 
</blockquote> 
<p><img alt="" height="768" src="https://images2.imgbox.com/0d/25/BUZbDuQH_o.png" width="1200"></p> 
<p><span style="color:#4da8ee;"><strong>只要满足③的条件，就会不断循环，每次循环指针z都会上移两层，直到根结点或者满足①和②的条件。</strong></span></p> 
<p>如果y是左子树一样的操作，也对应二个图，不再赘述。</p> 
<p></p> 
<h4 id="3.3%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">3.3红黑树的构造</span></span></h4> 
<p><span style="color:#0d0016;"><strong>下面为依次插入5，4，3，2，1时红黑树的构造过程：</strong></span></p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/ec/91/oAxs4zj9_o.png" width="985"></p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/69/3f/FdoDYe5c_o.png" width="922"></p> 
<p></p> 
<h4 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">3.4红黑树的删除 </span></span></h4> 
<p><span style="color:#0d0016;">红黑树的插入操作容易导致两个连续的红结点，破坏定义4。而红黑树的删除操作容易造成子树黑高的变化(删除黑结点会导致根结点到叶结点间的黑结点数量减少)，破坏定义5。</span></p> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>红黑树的删除也是先执行BST树的删除操作</strong></span>，<span style="color:#0d0016;">我们知道BST树的删除操作分三种情况，一是无子树，二是只有左或右子树，三是有左右子树</span>，<strong>其中第三种情况会转换为前两种情况，<span style="color:#4da8ee;">因此我们只需讨论前两种情况即可：</span></strong></p> 
 <p><span style="color:#fe2c24;"><strong>为方便对照，先将所有可能性分类，等下填到讨论的两种情况之中。设待删结点为z</strong></span></p> 
 <p><strong><span style="color:#fe2c24;">1</span>.结点z无子树</strong></p> 
 <p><strong><span style="color:#ffd900;">1.1</span></strong>结点z为<strong>红色；</strong></p> 
 <p><strong><span style="color:#ffd900;">1.2</span></strong>结点z为<strong>黑色；</strong></p> 
 <p><strong><span style="color:#fe2c24;">2.</span>结点z有左子树或右子树</strong></p> 
 <p><strong><span style="color:#ffd900;">2.1</span></strong>结点z为<strong>黑色，只有左子树</strong>且必为红色<strong>；</strong></p> 
 <p><strong><span style="color:#ffd900;">2.2</span></strong>结点z为<strong>黑色，只有右子树</strong>且必为红色<strong>；</strong></p> 
 <p>注：不存在待删结点z为红色时有单一子树这种情况</p> 
 <p><strong><span style="color:#fe2c24;">3</span>.结点z有左右子树</strong></p> 
 <p><strong><span style="color:#ffd900;">3.1</span> </strong>直接后继(前驱)结点y来替换<strong>黑色</strong>结点z并且y为<strong>红色无子树。</strong></p> 
 <p><strong><span style="color:#ffd900;">3.2</span> </strong>直接后继(前驱)结点y来替换<strong>黑色</strong>结点z并且y为<strong>黑色无子树</strong></p> 
 <p><strong><span style="color:#ffd900;">3.3</span> </strong>直接后继(前驱)结点y来替换<strong>红色</strong>结点z并且y为<strong>红色无子树。</strong></p> 
 <p><strong><span style="color:#ffd900;">3.4 </span></strong>直接后继(前驱)结点y来替换<strong>红色</strong>结点z并且y为<strong>黑色无子树。</strong></p> 
 <p><strong><span style="color:#ffd900;">3.5</span> </strong>直接后继(前驱)结点y来替换<strong>黑色</strong>结点z并且y为<strong>黑色只有左子树。</strong></p> 
 <p><strong><span style="color:#ffd900;">3.6</span> </strong>直接后继(前驱)结点y来替换<strong>黑色</strong>结点z并且y为<strong>黑色只有右子树。</strong></p> 
 <p><strong><span style="color:#ffd900;">3.7</span> </strong>直接后继(前驱)结点y来替换<strong>红色</strong>结点z并且y为<strong>黑色只有右子树。</strong></p> 
 <p><strong><span style="color:#ffd900;">3.8</span> </strong>直接后继(前驱)结点y来替换<strong>红色</strong>结点z并且y为<strong>黑色只有右子树。</strong></p> 
</blockquote> 
<ul><li><span style="color:#fe2c24;"><strong>待删结点只有右子树或左子树</strong></span><span style="color:#9c8ec1;"><strong>。</strong></span>z的子树只有一个孩子结点，该结点必然为红色，否则会破坏定义5，我们进行下图这样的转换即可。<span style="color:#ffd900;"><strong>2.1、2.2、3.5、3.6、3.7、3.8</strong></span>都属于此情况。对于3.7、3.8我们用y来替换z时注意黑色变成红色。</li></ul> 
<p><img alt="" height="577" src="https://images2.imgbox.com/52/53/vG95p8ot_o.png" width="612"></p> 
<ul><li><span style="color:#fe2c24;"><strong>待删结点没有孩子  </strong></span></li></ul> 
<ol><li><span style="color:#0d0016;">如果待删结点没有孩子，且结点是红色的，直接删除，结束。对应</span><strong><span style="color:#ffd900;">1.1、3.1、3.3</span></strong></li><li><span style="color:#0d0016;">如果待删结点没有孩子，且结点是黑色的。下面进行讨论分析。对应</span><span style="color:#ffd900;"><strong>1.2、3.2、3.4</strong></span></li></ol> 
<ul><li><span style="color:#4da8ee;"><strong>删除y(</strong></span><span style="color:#ffd900;"><strong>1.2</strong></span><span style="color:#4da8ee;"><strong>时为y为z本身)后将导致先前包含y的任何路径上的黑结点数量减1</strong></span><span style="color:#0d0016;">，因此y的任何祖先都不再满足定义5。</span></li><li><span style="color:#4da8ee;"><strong>简单的修正方法就是删除y时把现在占有y位置的x结点视为还有额外一重黑色，定义为双黑结点。(因为y是终端结点所以x是空叶结点)</strong></span></li><li>也就是说，如果将任何包含结点x的路径上的黑结点数量加1，在此假设下，定义5得到满足，但破坏了定义1(不能存在双黑结点)，于是，<span style="color:#4da8ee;"><strong>删除操作的任务就转化为将双黑结点x恢复为普通结点。</strong></span></li></ul> 
<p>分以下四种情况，区别在于x的右兄弟结点w及w的孩子结点的颜色不同：</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>情况1：x的兄弟结点w是红色结点。</strong></span></p> 
 <p><span style="color:#0d0016;">w必须有黑色父结点和黑色孩子结点。</span><strong><span style="color:#4da8ee;">交换w与父结点x.p的颜色，然后对x.p做一次左旋</span></strong><span style="color:#0d0016;">，不会破坏红黑树的任何规则。现在，x的新兄弟结点是旋转之前w的某个孩子结点，其颜色为黑色，下面要继续讨论新兄弟w的状态，这样就将情况1转换为了情况2、3、4。</span></p> 
</blockquote> 
<p><img alt="" height="443" src="https://images2.imgbox.com/f3/77/1uUCQs6R_o.png" width="1113"></p> 
<blockquote> 
 <p></p> 
 <p><span style="color:#fe2c24;"><strong>情况2：x的兄弟结点w是黑色结点，且w的右孩子是红色</strong></span></p> 
 <p><span style="color:#0d0016;">(下图对应RR，左旋一次)即红结点是其爷结点的右孩子的右孩子。</span><span style="color:#4da8ee;"><strong>交换w和父结点x.p的颜色，把w的右孩子着为黑色，并对x的父结点x.p做一次左旋，然后使x变为单重黑色</strong>，</span><span style="color:#0d0016;">此时不再破坏红黑树的性质。注：灰色代表红黑均可，不影响该情况。</span></p> 
</blockquote> 
<p><img alt="" height="372" src="https://images2.imgbox.com/c7/b2/gy3dvSJw_o.png" width="1060"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>情况3：x的兄弟结点w是黑色结点，且w的左孩子是红色的，w的右孩子是黑色的。</strong></span></p> 
 <p><span style="color:#0d0016;">(下图对应RL,先右旋再左旋)即红结点是其爷结点的右孩子结点的左孩子。</span><span style="color:#4da8ee;"><strong>交换w和其左孩子的颜色，然后对w进行一次右旋</strong></span><span style="color:#0d0016;">，而不破坏红黑树的任何性质。右旋过后x的新兄弟结点的右变为了红色，这样就变为了情况2，</span><span style="color:#4da8ee;"><strong>再进行左旋即可</strong></span><span style="color:#0d0016;">。</span></p> 
</blockquote> 
<p> <img alt="" height="477" src="https://images2.imgbox.com/5a/b5/dTcNN1xt_o.png" width="1200"></p> 
<blockquote> 
 <p></p> 
 <p><span style="color:#fe2c24;"><strong> 情况4：x的兄弟结点w是黑色结点，且w的两个孩子结点都是黑色的。</strong></span></p> 
 <p><span style="color:#0d0016;">因w和x都是黑色的，</span><strong><span style="color:#4da8ee;">我们可让x和w都去掉一层黑色，即w变为红色，x变为正常结点</span></strong><span style="color:#0d0016;">，为了保持局部的黑高不变，我们</span><span style="color:#4da8ee;"><strong>让x.p变为双黑结点。然后将x.p作为新的x结点来循环</strong></span><span style="color:#0d0016;">。如果是通过情况1进入情况4的，因为原来的x.p是红色的，将新结点变为黑色，终止循环，结束。</span></p> 
</blockquote> 
<p><img alt="" height="279" src="https://images2.imgbox.com/a6/28/2QraQrf7_o.png" width="836"></p> 
<p>我们上图假设了x为左孩子结点，当x为右孩子结点时处理方式左右对称，不再赘述。</p> 
<p>情况1、2、和3在各执行常数次的颜色改变和至多3次旋转后便终止，情况4是可能重复执行的唯一情况，每执行一次指针x上升一层，至多O(logn)次。</p> 
<h2 id="%E5%9B%9B%E3%80%81B%E6%A0%91"><span style="color:#1a439c;">四、B树</span></h2> 
<h4 id="B%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">4.1 B树的定义 </span></span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>B树，又称多路平衡查找树（或B-树、B_树）</strong>。</span></p> 
 <p><span style="color:#0d0016;">B树种所有结点的孩子个数的最大值称为<strong>B树的阶</strong>，通常用m表示。</span></p> 
 <p><span style="color:#0d0016;"><strong>一棵m阶B树或为空树，或为满足如下特性的m叉树。</strong></span></p> 
 <ol><li><span style="color:#0d0016;">树中</span><span style="color:#4da8ee;">每个结点至多有m棵子树</span><span style="color:#0d0016;">，即</span><span style="color:#4da8ee;">至多含有m-1个关键字。</span></li><li><span style="color:#0d0016;">若</span><span style="color:#4da8ee;">根结点</span><span style="color:#0d0016;">不是终端结点，则</span><span style="color:#4da8ee;">至少有两棵子树。</span></li><li><span style="color:#0d0016;">除根结点外的所有</span><span style="color:#4da8ee;">非叶结点至少有⌈m/2⌉棵子树</span><span style="color:#0d0016;">，即</span><span style="color:#4da8ee;">至少含有⌈m/2⌉-1个关键字。</span></li><li><span style="color:#4da8ee;">所有的叶结点都出现在同一层次</span><span style="color:#0d0016;">上，并且不带信息(可视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点并不存在，指向这些结点的指针为空)</span></li><li><span style="color:#0d0016;">所有非叶结点的结构如下：</span></li></ol> 
 <table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><span style="color:#0d0016;">n</span></td><td><span style="color:#0d0016;"><img alt="P_{0}" class="mathcode" src="https://images2.imgbox.com/26/0e/JyHEETa1_o.png"></span></td><td><span style="color:#0d0016;"><img alt="K_{1}" class="mathcode" src="https://images2.imgbox.com/d4/89/XbWq9lFk_o.png"></span></td><td><span style="color:#0d0016;"><img alt="P_{1}" class="mathcode" src="https://images2.imgbox.com/2c/85/N5rHtkaB_o.png"></span></td><td><span style="color:#0d0016;"><img alt="K_{2}" class="mathcode" src="https://images2.imgbox.com/ec/71/o6VWPk3A_o.png"></span></td><td><span style="color:#0d0016;"><img alt="P_{2}" class="mathcode" src="https://images2.imgbox.com/70/75/z0fnGg07_o.png"></span></td><td><span style="color:#0d0016;">...</span></td><td><span style="color:#0d0016;"><img alt="K_{n}" class="mathcode" src="https://images2.imgbox.com/06/72/BN13iSUj_o.png"></span></td><td><span style="color:#0d0016;"><img alt="P_{n}" class="mathcode" src="https://images2.imgbox.com/30/ec/g1MI8eEW_o.png"></span></td></tr></tbody></table> 
 <ul><li><span style="color:#0d0016;">其中，<img alt="K_{i}" class="mathcode" src="https://images2.imgbox.com/f6/59/dvRHuH9F_o.png">(i=1，2，...，n)为结点的关键字，且满足<img alt="K_{1}" class="mathcode" src="https://images2.imgbox.com/45/4d/Z5xCLLlu_o.png">&lt;<img alt="K_{2}" class="mathcode" src="https://images2.imgbox.com/cb/d2/IaqCDJ4j_o.png">&lt;...&lt;<img alt="K_{n}" class="mathcode" src="https://images2.imgbox.com/6e/c9/u3RFpnAM_o.png">；<img alt="P_{i }" class="mathcode" src="https://images2.imgbox.com/c9/0e/CBu0lttP_o.png">(i=1，2，...，n)为指向子树根结点的指针，且指针<img alt="P_{i-1}" class="mathcode" src="https://images2.imgbox.com/42/11/SrrW7531_o.png">所指子树中所有结点的关键字均小于<img alt="K_{i}" class="mathcode" src="https://images2.imgbox.com/32/ed/V5iWdujd_o.png">，<img alt="P_{i }" class="mathcode" src="https://images2.imgbox.com/60/94/jO3UkaRi_o.png">所指子树中所有结点的关键字均大于<img alt="K_{i}" class="mathcode" src="https://images2.imgbox.com/43/32/W3bTTSYI_o.png">，n（⌈m/2⌉-1≤n≤m-1）为结点中关键字的个数。</span></li></ul> 
</blockquote> 
<p><span style="color:#0d0016;">下图是一个4阶B树，下图只有内部结点，并没有给出第四层的叶结点(即外部结点，又或失败结点) 。注意这是一个高度为3的B树</span>，<span style="color:#fe2c24;">B树高度不算叶结点。</span></p> 
<p><img alt="" height="337" src="https://images2.imgbox.com/f7/74/6JQfelc8_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#38d8f0;">对上述定义详细解释：</span></strong></span></p> 
<p><span style="color:#0d0016;">第1条解释：每个结点的包含的n关键字可以划分出n+1个区间，即n+1棵子树。</span></p> 
<p><span style="color:#0d0016;">第2条解释：如果树不是空树，那么根结点至少要有一个关键字，即有两棵子树。终端结点是指最低层非叶结点，即上图第三层，叶子结点层指失败结点层。注：这里终端结点与叶子结点的概念居然不同，可见学习树概念还是要注重于应用。</span></p> 
<p><span style="color:#0d0016;">第3条解释：多路查找路数不能少于一个下限。</span></p> 
<p><span style="color:#0d0016;">第4条解释：B树是所有结点的平衡因子均等于0的多路平衡查找树。叶结点所在层次代表查找失败的位置。</span></p> 
<p><span style="color:#0d0016;">第5条解释：结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指子树的所有关键字均小于该关键字，右边指针所指子树的所有关键字均大于该关键字。这是保证查找的必要信息。</span></p> 
<p></p> 
<h4 id="B%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">4.2 B树的高度</span></span></h4> 
<p><span style="color:#0d0016;">B树的大部分操作所需的磁盘存取次数与B树的高度成正比。</span></p> 
<p><strong><span style="color:#4da8ee;">下面进行分析，首先B树的高度不包括最后不带任何信息的叶结点所处的那一层。</span></strong></p> 
<p><strong><span style="color:#0d0016;">若n≥1，则对任意一棵包含n个关键字、高度为h、阶数为m的B树：</span></strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">B树的最小高度：</span></p> 
 <p><span style="color:#0d0016;">由于每个结点的子树最多为m，第一层1个结点，第二层m个结点，第三层m^2...</span></p> 
 <p><span style="color:#0d0016;">n≤(m-1)(1+m+m^2+m^3+...+m^(h-1))=m^h-1,因此有</span></p> 
 <p><strong><span style="color:#0d0016;">h≥<img alt="\log_{m}(n+1)" class="mathcode" src="https://images2.imgbox.com/4e/38/20opGFNl_o.png"></span></strong></p> 
 <p><span style="color:#fe2c24;">B树的最大高度：</span></p> 
 <p><span style="color:#0d0016;">由于根结点最少1个关键字，其余非叶结点最少⌈m/2⌉-1个关键字，所以第一层1个结点，第二层2个结点，第三层2⌈m/2⌉个结点..第h+1层即叶结点层至少有2(⌈m/2⌉)^(h-1)个结点，由于叶结点有n+1个(查找失败个数)，所以n+1≥2(⌈m/2⌉)^(h-1)，因此有</span></p> 
 <p><span style="color:#0d0016;">h≤log⌈m/2⌉((n+1)/2)  +1</span></p> 
</blockquote> 
<p><span style="color:#fe2c24;">两道练习题：</span></p> 
<p>当m=5，n=53时，   2.5<span style="color:#0d0016;">≤</span>h<span style="color:#0d0016;">≤4，即最大高度为4，最小高度为3。</span></p> 
<p><span style="color:#0d0016;">当m=3，n=8时，   2</span><span style="color:#0d0016;">≤h≤3.17 ，即最大高度为3，最小高度为2。</span></p> 
<p></p> 
<h4 id="B%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%C2%A0%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">4.3 B树的查找  </span></span></h4> 
<p><span style="color:#0d0016;">在B树上的查找与二叉查找树相似，只是每个结点都是多个关键字的有序表，在每个结点上所做的不是两路分支决定，</span><span style="color:#4da8ee;"><strong>而是根据该结点的子树所做的多路分支决定。</strong></span></p> 
<p><strong>B树的查找包含两个基本操作：</strong></p> 
<ol><li><strong><span style="color:#4da8ee;">在B树中找结点。</span></strong><span style="color:#0d0016;">B树常存储在外存磁盘上，我们找到目标结点后要先在外存中把结点信息读到内存中</span></li><li><span style="color:#4da8ee;"><strong>在结点内找关键字</strong></span><span style="color:#0d0016;">。这个操作是在内存中进行的，采用顺序查找或者折半查找均可。</span></li></ol> 
<p></p> 
<h4 id="B%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">4.4 B树的插入 </span></span></h4> 
<p>与二叉排序树的插入操作相比，B树不能简单地添加到最底层非叶结点中，因为此时可能会导致不满足B树定义。</p> 
<p>将关键字key插入B树的过程如下:</p> 
<p>1<strong>.定位</strong>。和前面的查找操作类似，查找操作是找到失败结点的位置，<strong><span style="color:#4da8ee;">但是我们定位是到失败结点对应的上一层进行插入。</span></strong></p> 
<p>2.<strong>插入。</strong>插入后检查被插入结点的关键字个数，<strong><span style="color:#4da8ee;">当插入后结点个数大于m-1时，必须对结点进行分裂。</span></strong></p> 
<blockquote> 
 <p><strong>分裂的方法是</strong>：</p> 
 <p>插入key后从中间位置<span style="color:#0d0016;">⌈m/2⌉把结点分为两部分，<strong>左部分放在这个原结点中，右部分放在新结点中，中间位置⌈m/2⌉的结点插入到原结点的父节点。</strong></span></p> 
 <p><span style="color:#0d0016;">若原结点的父节点因为⌈m/2⌉位置结点的插入导致必须分裂，继续重复上述操作即可。</span></p> 
</blockquote> 
<p><img alt="" height="294" src="https://images2.imgbox.com/47/2b/9O5iErGh_o.png" width="1200"></p> 
<p></p> 
<h4 id="B%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0"><span style="color:#fe2c24;"><span style="background-color:#38d8f0;">4.5 B树的删除 </span></span></h4> 
<p>B树的删除要使删除后结点的关键字个数≥<span style="color:#0d0016;">⌈m/2⌉-1，因此涉及结点的“合并”操作</span></p> 
<ol><li><span style="color:#0d0016;"><strong>当被删关键字k不在最底层非叶结点中时，用k的前驱或后继来代替k</strong>，下面只需讨论删除最底层非叶结点中关键字的情况。</span></li><li><span style="color:#0d0016;"><strong>当被删关键字在最底层非叶结点中时</strong>，有下面三种情况：</span></li></ol> 
<blockquote> 
 <ol><li><span style="color:#4da8ee;"><strong>直接删除关键字</strong></span>，删除后仍满足B树定义，直接删除。 </li><li><span style="color:#4da8ee;"><strong>兄弟够借</strong></span>。即被删关键字所在结点的兄弟结点的关键字个数≥<span style="color:#0d0016;">⌈m/2⌉。我们可以调整该结点，左或右兄弟结点及其双亲结点中的关键字，以达到新的平衡。</span><img alt="" height="225" src="https://images2.imgbox.com/09/5b/WhSgvN40_o.png" width="725"></li><li> <strong><span style="color:#4da8ee;">兄弟不够借</span>。</strong>即被删关键字所在结点和其左右兄弟结点的目前关键字个数都为<span style="color:#0d0016;">⌈m/2⌉-1。那么我们可以将被删关键字结点、父节点中的关键字和其左或右兄弟结点进行合并。合并过后父结点的关键字个数会减1，继续判断父结点是否满足B树定义。</span><img alt="" height="338" src="https://images2.imgbox.com/ac/36/prKYvqxr_o.png" width="1059"></li></ol> 
</blockquote> 
<p></p> 
<h2 id="%E4%BA%94%E3%80%81B%2B%E6%A0%91"><span style="color:#1a439c;">五、B+树</span></h2> 
<h4 id="B%2B%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0"><span style="color:#fe2c24;"><strong><span style="background-color:#38d8f0;">5.1 B+树的定义 </span></strong></span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;">B+树是应数据库所需而出现的一种B树的变形树。</span></p> 
 <p><span style="color:#0d0016;"><strong>一棵m阶的B+树需满足下列条件：</strong></span></p> 
 <ol><li><strong>每个分支结点最多有m棵子树(孩子结点)。</strong></li><li><strong>非叶根结点至少有两棵子树，其他每个分支结点至少有⌈m/2⌉棵子树。</strong></li><li><span style="color:#4da8ee;"><strong>结点的子树个数和关键字个数相等。</strong></span></li><li><strong><span style="color:#4da8ee;">所有叶结点包含全部关键字及指向相应记录的指针</span>，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互衔接起来。</strong></li><li><strong>所有分支结点(可视为索引的索引)中<span style="color:#4da8ee;">仅包含它的各个子结点(即下一级的索引块)中关键字的最大值及指向其子结点的指针。</span></strong>注：子结点关键字最小值也可，将在后面讲解。</li></ol> 
</blockquote> 
<p><img alt="" height="648" src="https://images2.imgbox.com/53/1f/oAN1Gwjm_o.png" width="921"></p> 
<h4 id="B%E6%A0%91%E4%B8%8EB%2B%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94"><span style="color:#fe2c24;"><strong><span style="background-color:#38d8f0;">5.2 B树与B+树的对比</span></strong></span></h4> 
<blockquote> 
 <ol><li><strong>在B+树中，具有n个关键字的结点只含有n棵子树，</strong>每一个关键字为其指向的子树根结点最大关键字。<strong>在B树中，具有n个关键字的结点含有n+1个棵子树，</strong>因为每一个关键字分为含有比它小关键字的子树和比它大关键字的子树。</li><li><span style="color:#0d0016;"><strong>在B+树中，每个非根内部结点的关键字个数n的范围是⌈m/2⌉≤n≤m，根结点2≤n≤m。在B树中，每个非根内部结点的关键字个数n的范围是⌈m/2⌉-1≤n≤m-1，根结点1≤n≤m-1。</strong></span></li><li><span style="color:#0d0016;"><strong>在B+树中，叶结点包含全部信息，所以非叶结点仅起索引作用，</strong>非叶结点中每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</span></li><li><span style="color:#0d0016;"><strong>在B+树中，</strong>叶结点包含了全部关键字，<strong>非叶结点中出现的关键字也会出现在叶结点中；而在B树中，内部结点的关键字都是不重复的。</strong></span></li></ol> 
</blockquote> 
<h4 id="5.3%20B%2B%E6%A0%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9F%A5%E6%89%BE%E8%BF%90%E7%AE%97%EF%BC%9A"><span style="color:#fe2c24;"><strong><span style="background-color:#38d8f0;">5.3 B+树的两种查找运算：</span></strong></span></h4> 
<p><span style="color:#4da8ee;"><strong>一种是从最小关键字开始的顺序查找</strong></span>(有一个头指针指向关键字最小的叶结点) </p> 
<p><img alt="" height="142" src="https://images2.imgbox.com/98/d1/bxZMm4cV_o.png" width="636"></p> 
<p></p> 
<p><span style="color:#4da8ee;"><strong> 一种是从根结点开始的多路查找</strong></span>，假如要查找63</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/58/f1/YCQaIIVO_o.png" width="669"></p> 
<p> 继续:</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/8a/ce/M8ViQJt7_o.png" width="733"><span style="color:#4da8ee;"><strong> 每一次无论查找成功与否，查找路径都是一条从根结点到叶结点的路径。</strong></span></p> 
<blockquote> 
 <p> 内部结点也可以是包括下一级索引块的最小值，查找操作是类似的，不再赘述。如图：</p> 
 <p><img alt="" height="653" src="https://images2.imgbox.com/2c/1c/h5VsFAVK_o.png" width="935"></p> 
</blockquote> 
<h2 id="%E5%85%AD%E3%80%81%E5%B0%8F%E7%BB%93%C2%A0"><span style="color:#1a439c;">六、小结 </span></h2> 
<p><strong><span style="color:#fe2c24;">二叉排序树</span>既拥有类似于折半查找的特性，查找效率可以达到O(logn),又采用了链表作为存储结构，插入删除很高效。因此是动态查找表的一种适宜表示。</strong></p> 
<p><strong>二叉排序树可能会在一些极端情况下退化成线性表，为了避免树的高度增长太快，我们使用<span style="color:#fe2c24;">平衡二叉树</span>对其进行限制，防止这种极端情况的出现，保证我们的查找效率都是O(logn)。</strong></p> 
<p><strong>平衡二叉树的维护太过困难，插入和删除操作后需要频繁调整全树整体拓扑结构，维护这种高度平衡所付出的代价比获得的效益大的多。因此如果我们需要频繁的插入删除又需要一定的查找效率，我们使用<span style="color:#fe2c24;">红黑树</span>这一种放宽平衡条件的树形查找结构。</strong></p> 
<p><strong><span style="color:#fe2c24;">B树</span>是应用于文件系统的一种平衡的多路查找树，B树的查找操作涉及外存的存取，而磁盘IO的时间代价昂贵，因此我们需要降低树的深度选择多路查找树。</strong></p> 
<p><strong><span style="color:#fe2c24;">B+树</span>是应文件系统所需而出的B树的变种，实际应用于文件索引和数据库索引。B+树单一结点由于不含有关键字对应记录的存储地址，因此可以存储更多的关键字，使得查询的IO次数更少，同时B+树的查找路径从根结点到叶结点，查询效率更加稳定。此外B+树在范围查找上的优势更大，因为叶结点形成有序链表。</strong></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/695d25868947b26ff5beea39a517e2b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">初始化安装K8s集群以及docker服务（附详细步骤和代码！）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be3319ef9599f5a82aa2c206125ab42e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">InfluxDB-FLUX语法介绍以及查询InfluxDB</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>