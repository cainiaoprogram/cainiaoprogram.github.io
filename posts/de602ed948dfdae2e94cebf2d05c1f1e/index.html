<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线程池(通俗易懂) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="线程池(通俗易懂)" />
<meta property="og:description" content="目录
一、什么是线程池
二、创建线程池的方式
三、线程池的七大参数
四、四种拒绝策略
1.AbortPolicy()
2.CallerRunsPolicy()
3.DiscardPolicy()
4.DiscardOldestPolicy()
五、自定义一个线程池
1.场景描述
2.代码实现
一、什么是线程池 线程池其实就是一种多线程处理形式，处理过程中可以将任务添加到队列中，然后在创建线程后自动启动这些任务。这里的线程就是我们前面学过的线程,这里的任务就是我们前面学过的实现了Runnable或Callable接口的实例对象。
线程池的优点：降低资源消耗、提高响应速度、方便管理；线程可以复用、可以控制最大并发数、可以管理线程 二、创建线程池的方式 方式描述Executors.newSingleThreadExecutor();创建一个单一的线程池 Executors.newFixedThreadPool(int nThreads);创建一个固定大小的线程池，参数填线程池大小 Executors.newCachedThreadPool();创建一个可伸缩的线程池，遇强则强，遇弱则弱 public class ThreadPoolTest { public static void main(String[] args) { ExecutorService threadPool = Executors.newSingleThreadExecutor(); //ExecutorService threadPool = Executors.newFixedThreadPool(5); //ExecutorService threadPool = Executors.newCachedThreadPool(); try { for (int i = 1; i &lt;= 10; i&#43;&#43;) { //在execute中丢入一个Runnable ---&gt; lambda 表达式 threadPool.execute(()-&gt;{ System.out.println(Thread.currentThread().getName()); }); } } catch (Exception e) { e.printStackTrace(); } finally { //使用完毕后，程序结束，关闭线程池 threadPool." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/de602ed948dfdae2e94cebf2d05c1f1e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-22T16:20:49+08:00" />
<meta property="article:modified_time" content="2022-04-22T16:20:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线程池(通俗易懂)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">一、什么是线程池</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F" rel="nofollow">二、创建线程池的方式</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0" rel="nofollow">三、线程池的七大参数</a></p> 
<p id="%C2%A0%E5%9B%9B%E3%80%81%E5%9B%9B%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%9B%9B%E3%80%81%E5%9B%9B%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5" rel="nofollow"> 四、四种拒绝策略</a></p> 
<p id="1.AbortPolicy()-toc" style="margin-left:40px;"><a href="#1.AbortPolicy%28%29" rel="nofollow">1.AbortPolicy()</a></p> 
<p id="2.CallerRunsPolicy()-toc" style="margin-left:40px;"><a href="#2.CallerRunsPolicy%28%29" rel="nofollow">2.CallerRunsPolicy()</a></p> 
<p id="3.DiscardPolicy()-toc" style="margin-left:40px;"><a href="#3.DiscardPolicy%28%29" rel="nofollow">3.DiscardPolicy()</a></p> 
<p id="4.DiscardOldestPolicy()-toc" style="margin-left:40px;"><a href="#4.DiscardOldestPolicy%28%29" rel="nofollow">4.DiscardOldestPolicy()</a></p> 
<p id="%E4%BA%94%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">五、自定义一个线程池</a></p> 
<p id="1.%E5%9C%BA%E6%99%AF%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1.%E5%9C%BA%E6%99%AF%E6%8F%8F%E8%BF%B0" rel="nofollow">1.场景描述</a></p> 
<p id="%C2%A02.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A02.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow"> 2.代码实现</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0">一、什么是线程池</h2> 
<p>        线程池其实就是一种<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;spm=1001.2101.3001.7020" title="多线程">多线程</a>处理形式，处理过程中可以将任务添加到队列中，然后在创建线程后自动启动这些任务。这里的线程就是我们前面学过的线程,这里的任务就是我们前面学过的实现了Runnable或Callable接口的实例对象。</p> 
<p><strong>线程池的优点</strong>：降低资源消耗、提高响应速度、方便管理；<span style="color:#fe2c24;">线程可以复用、可以控制最大并发数、可以管理线程 </span></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F"><span style="color:#0d0016;">二、创建线程池的方式</span></h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>方式</strong></td><td><strong>描述</strong></td></tr><tr><td>Executors.newSingleThreadExecutor();</td><td>创建一个单一的线程池</td></tr><tr><td> Executors.newFixedThreadPool(int nThreads);</td><td>创建一个固定大小的线程池，参数填线程池大小</td></tr><tr><td> Executors.newCachedThreadPool();</td><td>创建一个可伸缩的线程池，遇强则强，遇弱则弱</td></tr></tbody></table> 
<pre><code class="language-java">public class ThreadPoolTest {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newSingleThreadExecutor(); 
        //ExecutorService threadPool = Executors.newFixedThreadPool(5);
        //ExecutorService threadPool = Executors.newCachedThreadPool();
        try {
            for (int i = 1; i &lt;= 10; i++) {
                //在execute中丢入一个Runnable ---&gt;  lambda 表达式
                threadPool.execute(()-&gt;{
                    System.out.println(Thread.currentThread().getName());
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //使用完毕后，程序结束，关闭线程池
            threadPool.shutdown();
        }
    }
}</code></pre> 
<p><img alt="" height="292" src="https://images2.imgbox.com/de/ae/DHvMuM8M_o.png" width="190"><img alt="" height="290" src="https://images2.imgbox.com/83/5e/D9tWxEJo_o.png" width="201"><img alt="" height="290" src="https://images2.imgbox.com/29/56/yENsiUu9_o.png" width="176"></p> 
<h2 id="%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0">三、线程池的七大参数</h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>参数</strong></td><td><strong>描述</strong></td></tr><tr><td>int corePoolSize</td><td>核心线程池大小</td></tr><tr><td>int maximumPoolSize</td><td>最核心大线程池大小</td></tr><tr><td>long keepAliveTime</td><td>超时时间 没有人使用会自动释放</td></tr><tr><td>TimeUnit unit</td><td>超时单位</td></tr><tr><td>BlockingQueue&lt;Runnable&gt; workQueue</td><td>阻塞队列</td></tr><tr><td>ThreadFactory threadFactory</td><td>线程工厂，创建线程的，一般不用动</td></tr><tr><td>RejectedExecutionHandler handler</td><td>拒绝策略</td></tr></tbody></table> 
<p> 在上面线程池的三种创建方式种中，点进源码，可以看到它们都new 了一个 ThreadPoolExecutor</p> 
<pre><code class="language-java">//newSingleThreadExecutor
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1, //核心线程，最大线程为 1
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;()));
    }
//newFixedThreadPool
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads, //核心线程，最大线程为传进来的参数
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;());
    }
//newCachedThreadPool
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,//核心线程默认是0，最大线程为21亿
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;());
    }</code></pre> 
<p> <strong>ThreadPoolExecutor</strong> 中就包含了线程池的七大参数</p> 
<pre><code>// ThreadPoolExecutor
public ThreadPoolExecutor(int corePoolSize,   //核心线程池大小
                              int maximumPoolSize,  //最核心大线程池大小
                              long keepAliveTime, //超时时间 没有人使用会自动释放
                              TimeUnit unit,   // 超时单位
                              BlockingQueue&lt;Runnable&gt; workQueue,  // 阻塞队列
                              ThreadFactory threadFactory,  // 线程工厂，创建线程的，一般不用动
                              RejectedExecutionHandler handler// 拒绝策略
                         ) {
        if (corePoolSize &lt; 0 ||
            maximumPoolSize &lt;= 0 ||
            maximumPoolSize &lt; corePoolSize ||
            keepAliveTime &lt; 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }</code></pre> 
<h2 id="%C2%A0%E5%9B%9B%E3%80%81%E5%9B%9B%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"> 四、四种拒绝策略</h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>拒绝策略</strong></td><td><strong>描述</strong></td></tr><tr><td>new ThreadPoolExecutor.AbortPolicy() </td><td>线程池默认拒绝策略，如果元素添加到线程池失败，会抛出RejectedExecutionException异常</td></tr><tr><td>new ThreadPoolExecutor.CallerRunsPolicy() </td><td>如果添加失败，那么主线程会自己调用执行器中的execute方法来执行任务 </td></tr><tr><td>new ThreadPoolExecutor.DiscardPolicy()</td><td>如果添加失败，则放弃，不会抛出异常        </td></tr><tr><td>new ThreadPoolExecutor.DiscardOldestPolicy()</td><td>如果添加到线程池失败，会将队列中最早添加的元素移除，再尝试添加，如果失败则按该策略不断重试</td></tr></tbody></table> 
<p>场景见下面的自定义线程池：核心线程数-2；最大核心线程数 - 5；阻塞队列 - 3 可容纳最大请求数 - 8  </p> 
<h3 id="1.AbortPolicy()">1.AbortPolicy()</h3> 
<p>分别将请求数设置为5，8，9</p> 
<p><img alt="" height="151" src="https://images2.imgbox.com/00/f2/kUp0z47v_o.png" width="224"><img alt="" height="151" src="https://images2.imgbox.com/8a/d1/OhX9iVIX_o.png" width="205"><img alt="" height="170" src="https://images2.imgbox.com/eb/6f/Mhti9Aze_o.png" width="430"></p> 
<h3 id="2.CallerRunsPolicy()">2.CallerRunsPolicy()</h3> 
<p> 将请求数量设置为9，不超过最大容量的情况都相同</p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/8b/8a/5WsAS686_o.png" width="417"></p> 
<h3 id="3.DiscardPolicy()">3.DiscardPolicy()</h3> 
<p> 将请求数量设置为9，不超过最大容量的情况都相同</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/8e/6f/CXedTM3p_o.png" width="456"></p> 
<h3 id="4.DiscardOldestPolicy()">4.DiscardOldestPolicy()</h3> 
<p> 将请求数量设置为9，不超过最大容量的情况都相同</p> 
<p>新请求把旧请求顶替</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/f2/d7/B61GJVc0_o.png" width="382"></p> 
<p> </p> 
<p> </p> 
<h2 id="%E4%BA%94%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0">五、自定义一个线程池</h2> 
<h3 id="1.%E5%9C%BA%E6%99%AF%E6%8F%8F%E8%BF%B0"><strong>1.场景描述</strong></h3> 
<p>银行办理业务</p> 
<p>平时银行只开放两个办理业务窗口，当两个窗口都有人时，新来的客户会进入侯客厅等待，当人过多时3，4，5窗口会打开进行业务办理</p> 
<p><img alt="" height="814" src="https://images2.imgbox.com/45/ae/8FmoYfrf_o.png" width="1200"></p> 
<p><img alt="" height="829" src="https://images2.imgbox.com/2b/1d/DKyDMi1C_o.png" width="1200"><img alt="" height="822" src="https://images2.imgbox.com/00/f2/8Kc9LWs8_o.png" width="1200"> 其实这种场景就与线程池类似，如下图：</p> 
<p><img alt="" height="817" src="https://images2.imgbox.com/55/00/bgUvZ7dw_o.png" width="1200"></p> 
<h3 id="%C2%A02.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"> 2.代码实现</h3> 
<pre><code class="language-java">public class ManualPool {
    public static void main(String[] args) {
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,  //核心线程池大小
                5,  //最大核心线程池大小
                3,  //超时时间
                TimeUnit.SECONDS,  //超时单位
                new LinkedBlockingQueue&lt;&gt;(3), //阻塞队列 --&gt;  相当于银行的候客区
                Executors.defaultThreadFactory(), //线程工厂
                new ThreadPoolExecutor.DiscardOldestPolicy() //拒绝策略
        );

        try {
            //最大容量 = 阻塞队列大小 + 最大核心线程池大小
            for (int i = 1; i &lt;= 9; i++) {
                //在execute中丢入一个Runnable ---&gt;  lambda 表达式
                //使用线程池来创建线程
                threadPool.execute(()-&gt;{
                    System.out.println(Thread.currentThread().getName());
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //使用完毕后，程序结束，关闭线程池
            threadPool.shutdown();
        }
    }
}</code></pre> 
<p></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/637a404c9b4b1fb470a1912f64fb3daa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">汇编----寄存器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc665e21aef9117c779cec70cd05c436/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">从结构到行为</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>