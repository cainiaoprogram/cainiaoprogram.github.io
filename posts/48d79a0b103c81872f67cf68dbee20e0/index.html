<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker容器引擎（二） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker容器引擎（二）" />
<meta property="og:description" content="docker 一、docker网络Docker 网络实现原理docker的五个网络模式1．host模式2．container模式3．none模式4．bridge模式5．自定义网络 二、资源控制1．CPU 资源控制2．对内存使用的限制3．对磁盘IO配额控制（blkio）的限制 一、docker网络 Docker 网络实现原理 Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 直接通信。
Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法直接通过 Container-IP 访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即 docker run 创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。
docker run -d --name test1 -P nginx #随机映射端口（从32768开始）
docker run -d --name test2 -p 43000:80 nginx #指定映射端口
docker ps -a
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
9d3c04f57a68 nginx “/docker-entrypoint.…” 4 seconds ago Up 3 seconds 0.0.0.0:43000-&gt;80/tcp test2
b04895f870e5 nginx “/docker-entrypoint.…” 17 seconds ago Up 15 seconds 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/48d79a0b103c81872f67cf68dbee20e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-20T23:27:14+08:00" />
<meta property="article:modified_time" content="2023-07-20T23:27:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker容器引擎（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>docker</h4> 
 <ul><li><a href="#docker_1" rel="nofollow">一、docker网络</a></li><li><ul><li><a href="#Docker__2" rel="nofollow">Docker 网络实现原理</a></li><li><a href="#docker_35" rel="nofollow">docker的五个网络模式</a></li><li><ul><li><a href="#1host_57" rel="nofollow">1．host模式</a></li><li><a href="#2container_66" rel="nofollow">2．container模式</a></li><li><a href="#3none_108" rel="nofollow">3．none模式</a></li><li><a href="#4bridge_114" rel="nofollow">4．bridge模式</a></li><li><a href="#5_131" rel="nofollow">5．自定义网络</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_152" rel="nofollow">二、资源控制</a></li><li><ul><li><a href="#1CPU__158" rel="nofollow">1．CPU 资源控制</a></li><li><a href="#2_248" rel="nofollow">2．对内存使用的限制</a></li><li><a href="#3IOblkio_265" rel="nofollow">3．对磁盘IO配额控制（blkio）的限制</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="docker_1"></a>一、docker网络</h2> 
<h3><a id="Docker__2"></a>Docker 网络实现原理</h3> 
<p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 直接通信。</p> 
<p>Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法直接通过 Container-IP 访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即 docker run 创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。<br> <img src="https://images2.imgbox.com/c0/4f/v4GwXJya_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0d/6b/dzUB7JFf_o.png" alt="在这里插入图片描述"></p> 
<p>docker run -d --name test1 -P nginx #随机映射端口（从32768开始）</p> 
<p><img src="https://images2.imgbox.com/53/d9/ipyUbtK7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b5/9e/NO1aXzPP_o.png" alt="在这里插入图片描述"></p> 
<p>docker run -d --name test2 -p 43000:80 nginx #指定映射端口<br> <img src="https://images2.imgbox.com/25/34/1aiBsbnc_o.png" alt="在这里插入图片描述"></p> 
<p>docker ps -a<br> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br> 9d3c04f57a68 nginx “/docker-entrypoint.…” 4 seconds ago Up 3 seconds 0.0.0.0:43000-&gt;80/tcp test2<br> b04895f870e5 nginx “/docker-entrypoint.…” 17 seconds ago Up 15 seconds 0.0.0.0:49170-&gt;80/tcp test1</p> 
<p>浏览器访问：http://192.168.80.10:43000 、http://192.168.80.10:49170<br> <img src="https://images2.imgbox.com/3d/50/e73pArPV_o.png" alt="在这里插入图片描述"></p> 
<p>#查看容器的输出和日志信息<br> docker logs 容器的ID/名称<br> <img src="https://images2.imgbox.com/3d/57/ifNXlCSf_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="docker_35"></a>docker的五个网络模式</h3> 
<p>Docker 的网络模式：<br> ●Host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。<br> ●Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。<br> ●None：该模式关闭了容器的网络功能。<br> ●Bridge：默认为该模式，此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及iptables nat 表配置与宿主机通信。<br> ●自定义网络</p> 
<p>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host</p> 
<p>docker network ls 或 docker network list #查看docker网络列表<br> NETWORK ID NAME DRIVER SCOPE<br> 2b4359d229c6 bridge bridge local<br> 0fa580365d39 host host local<br> cc13aa84a223 none null local</p> 
<p>#使用docker run创建Docker容器时，可以用 --net 或 --network 选项指定容器的网络模式<br> ●host模式：使用 --net=host 指定。<br> ●none模式：使用 --net=none 指定。<br> ●container模式：使用 --net=container:NAME_or_ID 指定。<br> ●bridge模式：使用 --net=bridge 指定，默认设置，可省略。</p> 
<h4><a id="1host_57"></a>1．host模式</h4> 
<p>相当于Vmware中的桥接模式，与宿主机在同一个网络中，但没有独立IP地址。<br> Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。<br> 一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、iptable规则等都与其他的Network Namespace隔离。 一个Docker容器一般会分配一个独立的Network Namespace。 但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡、配置自己的IP等，而是使用宿主机的IP和端口。<br> <img src="https://images2.imgbox.com/71/c4/6HR3cgDd_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b6/3f/I3qRI0sH_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/4a/9a/R4y8ckcC_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2container_66"></a>2．container模式</h4> 
<p><img src="https://images2.imgbox.com/72/bf/JVM45A3i_o.png" alt="在这里插入图片描述"></p> 
<p>在理解了host模式后，这个模式也就好理解了。这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。 新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p> 
<p>docker run -itd --name test1 centos:7 /bin/bash #–name 选项可以给容器创建一个自定义名称</p> 
<p>docker ps -a<br> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br> 3ed82355f811 centos:7 “/bin/bash” 5 days ago Up 6 hours test1</p> 
<p>docker inspect -f ‘{<!-- -->{.State.Pid}}’ 3ed82355f811 #查看容器进程号<br> 25945</p> 
<p>ls -l /proc/25495/ns #查看容器的进程、网络、文件系统等命名空间编号<br> lrwxrwxrwx 1 root root 0 1月 7 11:29 ipc -&gt; ipc:[4026532572]<br> lrwxrwxrwx 1 root root 0 1月 7 11:29 mnt -&gt; mnt:[4026532569]<br> lrwxrwxrwx 1 root root 0 1月 7 11:27 net -&gt; net:[4026532575]<br> lrwxrwxrwx 1 root root 0 1月 7 11:29 pid -&gt; pid:[4026532573]<br> lrwxrwxrwx 1 root root 0 1月 7 12:22 user -&gt; user:[4026531837]<br> lrwxrwxrwx 1 root root 0 1月 7 11:29 uts -&gt; uts:[4026532570]</p> 
<p>docker run -itd --name test2 --net=container:3ed82355f811 centos:7 /bin/bash<br> docker ps -a<br> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br> ff96bc43dd27 centos:7 “/bin/bash” 48 seconds ago Up 46 seconds test2<br> 3ed82355f811 centos:7 “/bin/bash” 58 minutes ago Up 58 minutes test1</p> 
<p>docker inspect -f ‘{<!-- -->{.State.Pid}}’ ff96bc43dd27<br> 27123</p> 
<p>ls -l /proc/27123/ns #查看可以发现两个容器的 net namespace 编号相同<br> lrwxrwxrwx 1 root root 0 1月 7 12:27 ipc -&gt; ipc:[4026532692]<br> lrwxrwxrwx 1 root root 0 1月 7 12:27 mnt -&gt; mnt:[4026532690]<br> lrwxrwxrwx 1 root root 0 1月 7 12:27 net -&gt; net:[4026532575]<br> lrwxrwxrwx 1 root root 0 1月 7 12:27 pid -&gt; pid:[4026532693]<br> lrwxrwxrwx 1 root root 0 1月 7 12:27 user -&gt; user:[4026531837]<br> lrwxrwxrwx 1 root root 0 1月 7 12:27 uts -&gt; uts:[4026532691]</p> 
<p><img src="https://images2.imgbox.com/b6/98/ppz8N0hN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/99/7d/jd6hV4T1_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3none_108"></a>3．none模式</h4> 
<p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。 也就是说，这个Docker容器没有网卡、IP、路由等信息。这种网络模式下容器只有lo回环网络，没有其他网卡。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。<br> <img src="https://images2.imgbox.com/df/a5/4RzS4H0v_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4bridge_114"></a>4．bridge模式</h4> 
<p>bridge模式是docker的默认网络模式，不用–net参数，就是bridge模式。</p> 
<p>相当于Vmware中的 nat 模式，容器使用独立network Namespace，并连接到docker0虚拟网卡。通过docker0网桥以及iptables nat表配置与宿主机通信，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。</p> 
<p>（1）当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p> 
<p>（2）从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备。 veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。</p> 
<p>（3）Docker将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0（容器的网卡），另一端放在主机中， 以 veth* 这样类似的名字命名， 并将这个网络设备加入到 docker0 网桥中。可以通过 brctl show 命令查看。</p> 
<p>（4）使用 docker run -p 时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL 查看。</p> 
<p><img src="https://images2.imgbox.com/4b/e0/bOlrfWrd_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5_131"></a>5．自定义网络</h4> 
<p>#直接使用bridge模式，是无法支持指定IP运行docker的，例如执行以下命令就会报错<br> docker run -itd --name test3 --network bridge --ip 172.17.0.10 centos:7 /bin/bash</p> 
<p>//创建自定义网络<br> #可以先自定义网络，再使用指定IP运行docker<br> docker network create --subnet=172.18.0.0/16 --opt “com.docker.network.bridge.name”=“docker1” mynetwork<br> <img src="https://images2.imgbox.com/42/f4/Wk2LdEn6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/22/27/ueg95HD8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5c/e4/zk04IMFf_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/7b/86/RCp9uG6m_o.png" alt="在这里插入图片描述"></p> 
<p>#docker1 为执行 ifconfig -a 命令时，显示的网卡名，如果不使用 --opt 参数指定此名称，那你在使用 ifconfig -a 命令查看网络信息时，看到的是类似 br-110eb56a0b22 这样的名字，这显然不怎么好记。<br> #mynetwork 为执行 docker network list 命令时，显示的bridge网络模式名称。</p> 
<p>docker run -itd --name test4 --net mynetwork --ip 172.18.0.10 centos:7 /bin/bash</p> 
<h2><a id="_152"></a>二、资源控制</h2> 
<p>Docker 通过 Cgroup 来控制容器使用的资源配额，包括 CPU、内存、磁盘三大方面， 基本覆盖了常见的资源配额和使用量控制。<br> Cgroup 是 ControlGroups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源(如 CPU、内存、磁盘 IO 等等) 的机制，被 LXC、docker 等很多项目用于实现进程资源控制。Cgroup 本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O 或内存的分配控制等具体的资源管理是通过该功能来实现的。<br> <img src="https://images2.imgbox.com/00/2b/MkiVL3ob_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1CPU__158"></a>1．CPU 资源控制</h3> 
<p>（1）设置CPU使用率上限<br> Linux通过CFS（Completely Fair Scheduler，完全公平调度器）来调度各个进程对CPU的使用。CFS默认的调度周期是100ms。<br> 我们可以设置每个容器进程的调度周期，以及在这个周期内各个容器最多能使用多少 CPU 时间。</p> 
<p>使用 --cpu-period 即可设置调度周期，使用 --cpu-quota 即可设置在每个周期内容器能使用的CPU时间。两者可以配合使用。<br> CFS 周期的有效范围是 1ms~1s，对应的 --cpu-period 的数值范围是 1000~1000000。<br> 而容器的 CPU 配额必须不小于 1ms，即 --cpu-quota 的值必须 &gt;= 1000。</p> 
<p>docker run -itd --name test5 centos:7 /bin/bash</p> 
<p>docker ps -a<br> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br> 3ed82355f811 centos:7 “/bin/bash” 5 days ago Up 6 hours test5</p> 
<p>cd /sys/fs/cgroup/cpu/docker/3ed82355f81151c4568aaa6e7bc60ba6984201c119125360924bf7dfd6eaa42b/<br> cat cpu.cfs_quota_us<br> -1</p> 
<p>cat cpu.cfs_period_us<br> 100000</p> 
<p>#cpu.cfs_period_us：cpu分配的周期(微秒，所以文件名中用 us 表示），默认为100000。<br> #cpu.cfs_quota_us：表示该cgroups限制占用的时间（微秒），默认为-1，表示不限制。 如果设为50000，表示占用50000/100000=50%的CPU。</p> 
<p><img src="https://images2.imgbox.com/d1/3b/wtbyBH4D_o.png" alt="在这里插入图片描述"></p> 
<p>#进行CPU压力测试<br> docker exec -it 3ed82355f811 /bin/bash<br> vim /cpu.sh<br> #!/bin/bash<br> i=0<br> while true<br> do<br> let i++<br> done</p> 
<p>chmod +x /cpu.sh<br> ./cpu.sh</p> 
<p>top #可以看到这个脚本占了很多的cpu资源</p> 
<p>#设置50%的比例分配CPU使用时间上限<br> docker run -itd --name test6 --cpu-quota 50000 centos:7 /bin/bash #可以重新创建一个容器并设置限额<br> 或者<br> cd /sys/fs/cgroup/cpu/docker/3ed82355f81151c4568aaa6e7bc60ba6984201c119125360924bf7dfd6eaa42b/<br> echo 50000 &gt; cpu.cfs_quota_us<br> docker exec -it 3ed82355f811 /bin/bash<br> ./cpu.sh</p> 
<p>top #可以看到cpu占用率接近50%，cgroups对cpu的控制起了效果</p> 
<p>#在多核情况下，如果允许容器进程完全占用两个 CPU， 则可以将 cpu-period 设置为 100000（ 即 0.1 秒）， cpu-quota设置为 200000（0.2 秒）。</p> 
<p>（2）设置CPU资源占用比（设置多个容器时才有效）<br> Docker 通过 --cpu-shares 指定 CPU 份额，默认值为1024，值为1024的倍数。<br> #创建两个容器为 c1 和 c2，若只有这两个容器，设置容器的权重，使得c1和c2的CPU资源占比为1/3和2/3。<br> docker run -itd --name c1 --cpu-shares 512 centos:7 <br> docker run -itd --name c2 --cpu-shares 1024 centos:7</p> 
<p>#分别进入容器，进行压力测试<br> yum install -y epel-release<br> yum install -y stress<br> stress -c 4 #产生四个进程，每个进程都反复不停的计算随机数的平方根</p> 
<p>#查看容器运行状态（动态更新）<br> docker stats<br> CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS<br> c3ee18e65852 c2 66.50% 5.5MiB / 976.3MiB 0.56% 20.4MB / 265kB 115MB / 14.2MB 4<br> bb02d3b345d8 c1 32.68% 2.625MiB / 976.3MiB 0.27% 20.4MB / 325kB 191MB / 12.7MB 4</p> 
<p>可以看到在 CPU 进行时间片分配的时候，容器 c2 比容器 c1 多一倍的机会获得 CPU 的时间片。<br> 但分配的结果取决于当时主机和其他容器的运行状态， 实际上也无法保证容器 c1 一定能获得 CPU 时间片。比如容器 c1 的进程一直是空闲的，那么容器 c2 是可以获取比容器 c1 更多的 CPU 时间片的。极端情况下，例如主机上只运行了一个容器，即使它的 CPU 份额只有 50，它也可以独占整个主机的 CPU 资源。</p> 
<p>Cgroups 只在容器分配的资源紧缺时，即在需要对容器使用的资源进行限制时，才会生效。因此，无法单纯根据某个容器的 CPU 份额来确定有多少 CPU 资源分配给它，资源分配结果取决于同时运行的其他容器的 CPU 分配和容器中进程运行情况。</p> 
<p>（3）设置容器绑定指定的CPU<br> #先分配虚拟机4个CPU核数<br> docker run -itd --name test7 --cpuset-cpus 1,3 centos:7 /bin/bash</p> 
<p>#进入容器，进行压力测试<br> yum install -y epel-release<br> yum install stress -y<br> stress -c 4</p> 
<p>#退出容器，执行 top 命令再按 1 查看CPU使用情况。</p> 
<h3><a id="2_248"></a>2．对内存使用的限制</h3> 
<p>//-m(–memory=) 选项用于限制容器可以使用的最大内存<br> docker run -itd --name test8 -m 512m centos:7 /bin/bash</p> 
<p>docker stats</p> 
<p>//限制可用的 swap 大小， --memory-swap<br> 强调一下，–memory-swap 是必须要与 --memory 一起使用的。</p> 
<p>正常情况下，–memory-swap 的值包含容器可用内存和可用 swap。<br> 所以 -m 300m --memory-swap=1g 的含义为：容器可以使用 300M 的物理内存，并且可以使用 700M（1G - 300）的 swap。</p> 
<p>如果 --memory-swap 设置为 0 或者 不设置，则容器可以使用的 swap 大小为 -m 值的两倍。<br> 如果 --memory-swap 的值和 -m 值相同，则容器不能使用 swap。<br> 如果 --memory-swap 值为 -1，它表示容器程序使用的内存受限，而可以使用的 swap 空间使用不受限制（宿主机有多少 swap 容器就可以使用多少）。</p> 
<h3><a id="3IOblkio_265"></a>3．对磁盘IO配额控制（blkio）的限制</h3> 
<p>–device-read-bps：限制某个设备上的读速度bps（数据量），单位可以是kb、mb(M)或者gb。<br> 例：docker run -itd --name test9 --device-read-bps /dev/sda:1M centos:7 /bin/bash</p> 
<p>–device-write-bps ： 限制某个设备上的写速度bps（数据量），单位可以是kb、mb(M)或者gb。<br> 例：docker run -itd --name test10 --device-write-bps /dev/sda:1mb centos:7 /bin/bash</p> 
<p>–device-read-iops ：限制读某个设备的iops（次数）</p> 
<p>–device-write-iops ：限制写入某个设备的iops（次数）</p> 
<p>#创建容器，并限制写速度<br> docker run -it --name test10 --device-write-bps /dev/sda:1mb centos:7 /bin/bash</p> 
<p>#通过dd来验证写速度<br> dd if=/dev/zero of=test.out bs=1M count=10 oflag=direct #添加oflag参数以规避掉文件系统cache<br> 10+0 records in<br> 10+0 records out<br> 10485760 bytes (10 MB) copied, 10.0025 s, 1.0 MB/s</p> 
<p>#清理docker占用的磁盘空间<br> docker system prune -a #可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/37a342a11bbd435e7078cf662403e87d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【JAVA】【源码学习】ByteBuffer</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d0f1c7fb1a8e1b3ac9436822ac60625/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaScript复习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>