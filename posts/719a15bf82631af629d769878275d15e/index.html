<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>爬虫框架Scrapy之Downloader Middlewares - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="爬虫框架Scrapy之Downloader Middlewares" />
<meta property="og:description" content="反反爬虫相关机制 Some websites implement certain measures to prevent bots from crawling them, with varying degrees of sophistication. Getting around those measures can be difficult and tricky, and may sometimes require special infrastructure. Please consider contacting commercial support if in doubt. (有些些网站使用特定的不同程度的复杂性规则防止爬虫访问，绕过这些规则是困难和复杂的，有时可能需要特殊的基础设施。如果有疑问请联系商业支持。)
来自于Scrapy官方文档描述：http://doc.scrapy.org/en/master/topics/practices.html#avoiding-getting-banned
通常防止爬虫被反主要有以下几个策略：
动态设置User-Agent（随机切换User-Agent，模拟不同用户的浏览器信息）
禁用Cookies（也就是不启用cookies middleware，不向Server发送cookies，有些网站通过cookie的使用发现爬虫行为）
可以通过COOKIES_ENABLED 控制 CookiesMiddleware 开启或关闭 设置延迟下载（防止访问过于频繁，设置为 2秒 或更高）
Google Cache 和 Baidu Cache：如果可能的话，使用谷歌/百度等搜索引擎服务器页面缓存获取页面数据。
使用IP地址池：VPN和代理IP，现在大部分网站都是根据IP来ban的。
使用 Crawlera（专用于爬虫的代理组件），正确配置和设置下载中间件后，项目所有的request都是通过crawlera发出。
DOWNLOADER_MIDDLEWARES = { &#39;scrapy_crawlera.CrawleraMiddleware&#39;: 600 } CRAWLERA_ENABLED = True CRAWLERA_USER = &#39;注册/购买的UserKey&#39; CRAWLERA_PASS = &#39;注册/购买的Password&#39; 如何设置下载中间件（Downloader Middlewares） 下载中间件是处于引擎(crawler." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/719a15bf82631af629d769878275d15e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-06T00:11:00+08:00" />
<meta property="article:modified_time" content="2017-03-06T00:11:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">爬虫框架Scrapy之Downloader Middlewares</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <h3 id="反反爬虫相关机制">反反爬虫相关机制</h3> 
 <blockquote> 
  <p>Some websites implement certain measures to prevent bots from crawling them, with varying degrees of sophistication. Getting around those measures can be difficult and tricky, and may sometimes require special infrastructure. Please consider contacting commercial support if in doubt. (有些些网站使用特定的不同程度的复杂性规则防止爬虫访问，绕过这些规则是困难和复杂的，有时可能需要特殊的基础设施。如果有疑问请联系商业支持。)</p> 
 </blockquote> 
 <p>来自于Scrapy官方文档描述：<a href="http://doc.scrapy.org/en/master/topics/practices.html#avoiding-getting-banned" rel="nofollow">http://doc.scrapy.org/en/master/topics/practices.html#avoiding-getting-banned</a></p> 
 <p>通常防止爬虫被反主要有以下几个策略：</p> 
 <ul><li> <p>动态设置User-Agent（随机切换User-Agent，模拟不同用户的浏览器信息）</p> </li><li> <p>禁用Cookies（也就是不启用cookies middleware，不向Server发送cookies，有些网站通过cookie的使用发现爬虫行为）</p> 
   <ul><li>可以通过<code>COOKIES_ENABLED</code> 控制 CookiesMiddleware 开启或关闭</li></ul></li><li> <p>设置延迟下载（防止访问过于频繁，设置为 2秒 或更高）</p> </li><li> <p>Google Cache 和 Baidu Cache：如果可能的话，使用谷歌/百度等搜索引擎服务器页面缓存获取页面数据。</p> </li><li> <p>使用IP地址池：VPN和代理IP，现在大部分网站都是根据IP来ban的。</p> </li><li> <p>使用 <a href="https://scrapinghub.com/crawlera" rel="nofollow">Crawlera</a>（专用于爬虫的代理组件），正确配置和设置下载中间件后，项目所有的request都是通过crawlera发出。</p> </li></ul> 
 <pre><code>DOWNLOADER_MIDDLEWARES = {
    'scrapy_crawlera.CrawleraMiddleware': 600
}

CRAWLERA_ENABLED = True
CRAWLERA_USER = '注册/购买的UserKey'
CRAWLERA_PASS = '注册/购买的Password'
</code></pre> 
 <h3 id="如何设置下载中间件（downloader-middlewares）">如何设置下载中间件（Downloader Middlewares）</h3> 
 <p>下载中间件是处于引擎(crawler.engine)和下载器(crawler.engine.download())之间的一层组件，可以有多个下载中间件被加载运行。</p> 
 <ol><li> <p>当引擎传递请求给下载器的过程中，下载中间件可以对请求进行处理 （例如增加http header信息，增加proxy信息等）；</p> </li><li> <p>在下载器完成http请求，传递响应给引擎的过程中， 下载中间件可以对响应进行处理（例如进行gzip的解压等）</p> </li></ol> 
 <p>要激活下载器中间件组件，将其加入到 DOWNLOADER_MIDDLEWARES 设置中。 该设置是一个字典(dict)，键为中间件类的路径，值为其中间件的顺序(order)。</p> 
 <p>这里是一个例子:</p> 
 <pre><code class="lang-python">DOWNLOADER_MIDDLEWARES = {
    <span class="hljs-string">'mySpider.middlewares.MyDownloaderMiddleware': <span class="hljs-number">543,
}
</span></span></code></pre> 
 <p>编写下载器中间件十分简单。每个中间件组件是一个定义了以下一个或多个方法的Python类:</p> 
 <pre><code class="lang-python">class scrapy.contrib.downloadermiddleware.DownloaderMiddleware
</code></pre> 
 <h4 id="processrequestrequest-spider">process_request(request, spider)</h4> 
 <ul><li> <p>当每个request通过下载中间件时，该方法被调用。</p> </li><li> <p>process_request() 必须返回以下其中之一：一个 None 、一个 Response 对象、一个 Request 对象或 raise IgnoreRequest:</p> 
   <ul><li> <p>如果其返回 None ，Scrapy将继续处理该request，执行其他的中间件的相应方法，直到合适的下载器处理函数(download handler)被调用， 该request被执行(其response被下载)。</p> </li><li> <p>如果其返回 Response 对象，Scrapy将不会调用 任何 其他的 process_request() 或 process_exception() 方法，或相应地下载函数； 其将返回该response。 已安装的中间件的 process_response() 方法则会在每个response返回时被调用。</p> </li><li> <p>如果其返回 Request 对象，Scrapy则停止调用 process_request方法并重新调度返回的request。当新返回的request被执行后， 相应地中间件链将会根据下载的response被调用。</p> </li><li> <p>如果其raise一个 IgnoreRequest 异常，则安装的下载中间件的 process_exception() 方法会被调用。如果没有任何一个方法处理该异常， 则request的errback(Request.errback)方法会被调用。如果没有代码处理抛出的异常， 则该异常被忽略且不记录(不同于其他异常那样)。</p> </li></ul></li><li> <p>参数:</p> 
   <ul><li><code>request (Request 对象)</code> – 处理的request</li><li><code>spider (Spider 对象)</code> – 该request对应的spider</li></ul></li></ul> 
 <h4 id="processresponserequest-response-spider">process_response(request, response, spider)</h4> 
 <p>当下载器完成http请求，传递响应给引擎的时候调用</p> 
 <ul><li> <p>process_request() 必须返回以下其中之一: 返回一个 Response 对象、 返回一个 Request 对象或raise一个 IgnoreRequest 异常。</p> 
   <ul><li> <p>如果其返回一个 Response (可以与传入的response相同，也可以是全新的对象)， 该response会被在链中的其他中间件的 process_response() 方法处理。</p> </li><li> <p>如果其返回一个 Request 对象，则中间件链停止， 返回的request会被重新调度下载。处理类似于 process_request() 返回request所做的那样。</p> </li><li> <p>如果其抛出一个 IgnoreRequest 异常，则调用request的errback(Request.errback)。 如果没有代码处理抛出的异常，则该异常被忽略且不记录(不同于其他异常那样)。</p> </li></ul></li><li> <p>参数:</p> 
   <ul><li><code>request (Request 对象)</code> – response所对应的request</li><li><code>response (Response 对象)</code> – 被处理的response</li><li><code>spider (Spider 对象)</code> – response所对应的spider</li></ul></li></ul> 
 <h4 id="使用案例：">使用案例：</h4> 
 <h5 id="1-创建middlewarespy文件。">1. 创建<code>middlewares.py</code>文件。</h5> 
 <p>Scrapy代理IP、Uesr-Agent的切换都是通过<code>DOWNLOADER_MIDDLEWARES</code>进行控制，我们在<code>settings.py</code>同级目录下创建<code>middlewares.py</code>文件，包装所有请求。</p> 
 <pre><code class="lang-python"><span class="hljs-comment"># middlewares.py

<span class="hljs-keyword">import random
<span class="hljs-keyword">import base64
<span class="hljs-comment"># 导入settings的PROXIES设置
<span class="hljs-keyword">from settings <span class="hljs-keyword">import PROXIES <span class="hljs-comment"># 随机使用预定义列表里的 User-Agent类 <span class="hljs-class"><span class="hljs-keyword">class <span class="hljs-title">RandomUserAgent<span class="hljs-params">(object): <span class="hljs-function"><span class="hljs-keyword">def <span class="hljs-title">__init__<span class="hljs-params">(self, agents): <span class="hljs-comment"># 使用初始化的agents列表 self.agents = agents <span class="hljs-decorator"> @classmethod <span class="hljs-function"><span class="hljs-keyword">def <span class="hljs-title">from_crawler<span class="hljs-params">(cls, crawler): <span class="hljs-comment"># 获取settings的USER_AGENT列表并返回 <span class="hljs-keyword">return cls(crawler.settings.getlist(<span class="hljs-string">'USER_AGENTS')) <span class="hljs-function"><span class="hljs-keyword">def <span class="hljs-title">process_request<span class="hljs-params">(self, request, spider): <span class="hljs-comment"># 随机设置Request报头header的User-Agent request.headers.setdefault(<span class="hljs-string">'User-Agent', random.choice(self.agents)) <span class="hljs-comment"># 随机使用预定义列表里的 Proxy代理 <span class="hljs-class"><span class="hljs-keyword">class <span class="hljs-title">ProxyMiddleware<span class="hljs-params">(object): <span class="hljs-function"><span class="hljs-keyword">def <span class="hljs-title">process_request<span class="hljs-params">(self, request, spider): <span class="hljs-comment"># 随机获取from settings import PROXIES里的代理 proxy = random.choice(PROXIES) <span class="hljs-comment"># 如果代理可用，则使用代理 <span class="hljs-keyword">if proxy[<span class="hljs-string">'user_pass'] <span class="hljs-keyword">is <span class="hljs-keyword">not <span class="hljs-keyword">None: request.meta[<span class="hljs-string">'proxy'] = <span class="hljs-string">"http://%s" % proxy[<span class="hljs-string">'ip_port'] <span class="hljs-comment"># 对代理数据进行base64编码 encoded_user_pass = base64.encodestring(proxy[<span class="hljs-string">'user_pass']) <span class="hljs-comment"># 添加到HTTP代理格式里 request.headers[<span class="hljs-string">'Proxy-Authorization'] = <span class="hljs-string">'Basic ' + encoded_user_pass <span class="hljs-keyword">else: <span class="hljs-keyword">print <span class="hljs-string">"****代理失效****" + proxy[<span class="hljs-string">'ip_port'] request.meta[<span class="hljs-string">'proxy'] = <span class="hljs-string">"http://%s" % proxy[<span class="hljs-string">'ip_port'] </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
 <blockquote> 
  <p>为什么HTTP代理要使用base64编码：</p> 
  <p>HTTP代理的原理很简单，就是通过HTTP协议与代理服务器建立连接，协议信令中包含要连接到的远程主机的IP和端口号，如果有需要身份验证的话还需要加上授权信息，服务器收到信令后首先进行身份验证，通过后便与远程主机建立连接，连接成功之后会返回给客户端200，表示验证通过，就这么简单，下面是具体的信令格式：</p> 
 </blockquote> 
 <pre><code>CONNECT 59.64.128.198:21 HTTP/1.1
Host: 59.64.128.198:21
Proxy-Authorization: Basic bGV2I1TU5OTIz
User-Agent: OpenFetion
</code></pre> 
 <blockquote> 
  <p>其中<code>Proxy-Authorization</code>是身份验证信息，Basic后面的字符串是用户名和密码组合后进行base64编码的结果，也就是对username:password进行base64编码。</p> 
 </blockquote> 
 <pre><code>HTTP/1.0 200 Connection established
</code></pre> 
 <blockquote> 
  <p>OK，客户端收到收面的信令后表示成功建立连接，接下来要发送给远程主机的数据就可以发送给代理服务器了，代理服务器建立连接后会在根据IP地址和端口号对应的连接放入缓存，收到信令后再根据IP地址和端口号从缓存中找到对应的连接，将数据通过该连接转发出去。</p> 
 </blockquote> 
 <h5 id="2-修改settingspy配置useragents和proxies">2. 修改settings.py配置USER_AGENTS和PROXIES</h5> 
 <ul><li>添加USER_AGENTS：</li></ul> 
 <pre><code class="lang-python">　　USER_AGENTS = [
    <span class="hljs-string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)",
    <span class="hljs-string">"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)",
    <span class="hljs-string">"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)",
    <span class="hljs-string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)",
    <span class="hljs-string">"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6", <span class="hljs-string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1", <span class="hljs-string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0", <span class="hljs-string">"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5" ] </span></span></span></span></span></span></span></span></code></pre> 
 <ul><li> <p>添加代理IP设置PROXIES：</p> <p>代理IP可以网上搜索，或者付费购买一批可用代理IP：</p> </li></ul> 
 <pre><code class="lang-python">PROXIES = [
    {<!-- --><span class="hljs-string">'ip_port': <span class="hljs-string">'111.8.60.9:8123', <span class="hljs-string">'user_pass': <span class="hljs-string">''},
    {<!-- --><span class="hljs-string">'ip_port': <span class="hljs-string">'101.71.27.120:80', <span class="hljs-string">'user_pass': <span class="hljs-string">''}, {<!-- --><span class="hljs-string">'ip_port': <span class="hljs-string">'122.96.59.104:80', <span class="hljs-string">'user_pass': <span class="hljs-string">''}, {<!-- --><span class="hljs-string">'ip_port': <span class="hljs-string">'122.224.249.122:8088', <span class="hljs-string">'user_pass': <span class="hljs-string">''}, ] </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
 <ul><li>禁用cookies，防止某些网站根据Cookie来封锁爬虫。</li></ul> 
 <pre><code>COOKIES_ENABLED = False
</code></pre> 
 <ul><li>设置下载延迟</li></ul> 
 <pre><code>DOWNLOAD_DELAY = 3
</code></pre> 
 <ul><li>最后设置setting.py里的DOWNLOADER_MIDDLEWARES</li></ul> 
 <pre><code class="lang-python">DOWNLOADER_MIDDLEWARES = {
    <span class="hljs-comment">#'mySpider.middlewares.MyCustomDownloaderMiddleware': 543,
    <span class="hljs-string">'mySpider.middlewares.RandomUserAgent': <span class="hljs-number">1,
    <span class="hljs-string">'mySpider.middlewares.ProxyMiddleware': <span class="hljs-number">100 }</span></span></span></span></span></code></pre> 
</div> 
<p>转载于:https://www.cnblogs.com/wzjbg/p/6507581.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/22841460045b69cbf8317a4ef9f09e20/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JDK(1.6,1.7,1.8,10,11)64位解压版配置使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/88c1e035bf7a82111a46759905edb09d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">重载的特点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>