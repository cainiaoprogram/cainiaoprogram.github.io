<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android Camera2教程之打开相机、开启预览、实现PreviewCallback、拍照 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android Camera2教程之打开相机、开启预览、实现PreviewCallback、拍照" />
<meta property="og:description" content="转载请注明出处： http://blog.csdn.net/lb377463323/article/details/52740411
Android API 21新增了Camera2，这与之前的camera架构完全不同，使用起来也比较复杂，但是功能变得很强大。
在讲解开启预览之前，首先需要了解camera2的几个比较重要的类：
CameraManager： 管理手机上的所有摄像头设备，它的作用主要是获取摄像头列表和打开指定的摄像头CameraDevice： 具体的摄像头设备，它有一系列参数（预览尺寸、拍照尺寸等），可以通过CameraManager的getCameraCharacteristics()方法获取。它的作用主要是创建CameraCaptureSession和CaptureRequestCameraCaptureSession： 相机捕获会话，用于处理拍照和预览的工作（很重要）CaptureRequest： 捕获请求，定义输出缓冲区以及显示界面（TextureView或SurfaceView）等 1，定义TextureView作为预览界面 在布局文件中加入TextureView控件，然后实现其监听事件
textureView = (TextureView) findViewById(R.id.textureView); 然后我们可以在OnResume()方法中设置监听SurefaceTexture的事件 textureView.setSurfaceTextureListener(textureListener); 当SurefaceTexture准备好后会回调SurfaceTextureListener 的onSurfaceTextureAvailable()方法
TextureView.SurfaceTextureListener textureListener = new TextureView.SurfaceTextureListener() { @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) { //当SurefaceTexture可用的时候，设置相机参数并打开相机 setupCamera(width, height); openCamera(); } }; 2，设置相机参数 为了更好地预览，我们根据TextureView的尺寸设置预览尺寸，Camera2中使用CameraManager来管理摄像头
private void setupCamera(int width, int height) { //获取摄像头的管理者CameraManager CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); try { //遍历所有摄像头 for (String cameraId: manager.getCameraIdList()) { CameraCharacteristics characteristics = manager." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ab3fb0916120899048188b0173149f43/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-10-05T20:32:48+08:00" />
<meta property="article:modified_time" content="2016-10-05T20:32:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android Camera2教程之打开相机、开启预览、实现PreviewCallback、拍照</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>转载请注明出处： <a href="http://blog.csdn.net/lb377463323/article/details/52740411">http://blog.csdn.net/lb377463323/article/details/52740411</a></p> 
<p>Android API 21新增了Camera2，这与之前的camera架构完全不同，使用起来也比较复杂，但是功能变得很强大。</p> 
<p>在讲解开启预览之前，首先需要了解camera2的几个比较重要的类：</p> 
<ul><li>CameraManager： 管理手机上的所有摄像头设备，它的作用主要是获取摄像头列表和打开指定的摄像头</li><li>CameraDevice： 具体的摄像头设备，它有一系列参数（预览尺寸、拍照尺寸等），可以通过CameraManager的getCameraCharacteristics()方法获取。它的作用主要是创建CameraCaptureSession和CaptureRequest</li><li>CameraCaptureSession： 相机捕获会话，用于处理拍照和预览的工作（很重要）</li><li>CaptureRequest： 捕获请求，定义输出缓冲区以及显示界面（TextureView或SurfaceView）等</li></ul> 
<h4 id="1定义textureview作为预览界面">1，定义TextureView作为预览界面</h4> 
<p>在布局文件中加入TextureView控件，然后实现其监听事件</p> 
<pre><code>textureView = (TextureView) findViewById(R.id.textureView);
</code></pre> 
<p>然后我们可以在OnResume()方法中设置监听SurefaceTexture的事件 </p> 
<pre><code>textureView.setSurfaceTextureListener(textureListener);
</code></pre> 
<p>当SurefaceTexture准备好后会回调SurfaceTextureListener 的onSurfaceTextureAvailable()方法</p> 
<pre class="prettyprint"><code class=" hljs java">TextureView.SurfaceTextureListener textureListener = <span class="hljs-keyword">new</span> TextureView.SurfaceTextureListener() {
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSurfaceTextureAvailable</span>(SurfaceTexture surface, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height) {
        <span class="hljs-comment">//当SurefaceTexture可用的时候，设置相机参数并打开相机</span>
        setupCamera(width, height);
        openCamera();
    }
};</code></pre> 
<h4 id="2设置相机参数">2，设置相机参数</h4> 
<p>为了更好地预览，我们根据TextureView的尺寸设置预览尺寸，Camera2中使用CameraManager来管理摄像头</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setupCamera</span>(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height) {
        <span class="hljs-comment">//获取摄像头的管理者CameraManager</span>
    CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//遍历所有摄像头</span>
        <span class="hljs-keyword">for</span> (String cameraId: manager.getCameraIdList()) {
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            <span class="hljs-comment">//默认打开后置摄像头</span>
            <span class="hljs-keyword">if</span> (characteristics.<span class="hljs-keyword">get</span>(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT)
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-comment">//获取StreamConfigurationMap，它是管理摄像头支持的所有输出格式和尺寸</span>
            StreamConfigurationMap map = characteristics.<span class="hljs-keyword">get</span>(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            <span class="hljs-comment">//根据TextureView的尺寸设置预览尺寸</span>
            mPreviewSize = getOptimalSize(map.getOutputSizes(SurfaceTexture.class), width, height);
            mCameraId = cameraId;
            <span class="hljs-keyword">break</span>;
        }
    } <span class="hljs-keyword">catch</span> (CameraAccessException e) {
        e.printStackTrace();
    }
}</code></pre> 
<h4 id="3开启相机">3，开启相机</h4> 
<p>Camera2中打开相机也需要通过CameraManager类</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openCamera</span>() {
    <span class="hljs-comment">//获取摄像头的管理者CameraManager</span>
    CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);
    <span class="hljs-comment">//检查权限</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (ActivityCompat.checkSelfPermission(<span class="hljs-keyword">this</span>, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">//打开相机，第一个参数指示打开哪个摄像头，第二个参数stateCallback为相机的状态回调接口，第三个参数用来确定Callback在哪个线程执行，为null的话就在当前线程执行</span>
        manager.openCamera(mCameraId, stateCallback, <span class="hljs-keyword">null</span>);
    } <span class="hljs-keyword">catch</span> (CameraAccessException e) {
        e.printStackTrace();
    }
}</code></pre> 
<p>实现StateCallback 接口，当相机打开后会回调onOpened方法，在这个方法里面开启预览</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CameraDevice.StateCallback stateCallback = <span class="hljs-keyword">new</span> CameraDevice.StateCallback() {
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpened</span>(CameraDevice camera) {
        mCameraDevice = camera;
        <span class="hljs-comment">//开启预览</span>
        startPreview();
    }
}</code></pre> 
<h4 id="4开启相机预览">4，开启相机预览</h4> 
<p>我们使用TextureView显示相机预览数据，Camera2的预览和拍照数据都是使用CameraCaptureSession会话来请求的</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startPreview</span>() {
    SurfaceTexture mSurfaceTexture = mTextureView.getSurfaceTexture();
    <span class="hljs-comment">//设置TextureView的缓冲区大小</span>
    mSurfaceTexture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());
    <span class="hljs-comment">//获取Surface显示预览数据</span>
    Surface mSurface = <span class="hljs-keyword">new</span> Surface(mSurfaceTexture);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//创建CaptureRequestBuilder，TEMPLATE_PREVIEW比表示预览请求</span>
        mCaptureRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        <span class="hljs-comment">//设置Surface作为预览数据的显示界面</span>
        mCaptureRequestBuilder.addTarget(mSurface);
        <span class="hljs-comment">//创建相机捕获会话，第一个参数是捕获数据的输出Surface列表，第二个参数是CameraCaptureSession的状态回调接口，当它创建好后会回调onConfigured方法，第三个参数用来确定Callback在哪个线程执行，为null的话就在当前线程执行</span>
        mCameraDevice.createCaptureSession(Arrays.asList(mSurface), <span class="hljs-keyword">new</span> CameraCaptureSession.StateCallback() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onConfigured</span>(CameraCaptureSession session) {
                <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">//创建捕获请求</span>
                        mCaptureRequest = mCaptureRequestBuilder.build();
                        mPreviewSession = session;
                        <span class="hljs-comment">//设置反复捕获数据的请求，这样预览界面就会一直有数据显示</span>
                        mPreviewSession.setRepeatingRequest(mCaptureRequest, mSessionCaptureCallback, <span class="hljs-keyword">null</span>);
                    } <span class="hljs-keyword">catch</span> (CameraAccessException e) {
                        e.printStackTrace();
                    }
                }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onConfigureFailed</span>(CameraCaptureSession session) {

            }
        }, <span class="hljs-keyword">null</span>);
    } <span class="hljs-keyword">catch</span> (CameraAccessException e) {
        e.printStackTrace();
    }
}</code></pre> 
<h4 id="5实现previewcallback">5，实现PreviewCallback</h4> 
<p>Camera2中并没有Camera1中的PreviewCallback接口，那怎么实现获取预览帧数据呢？答案就是使用ImageReader间接实现</p> 
<p>首先创建一个ImageReader，并监听它的事件</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setupImageReader</span>() {
    <span class="hljs-comment">//前三个参数分别是需要的尺寸和格式，最后一个参数代表每次最多获取几帧数据，本例的2代表ImageReader中最多可以获取两帧图像流</span>
    mImageReader = ImageReader.newInstance(mPreviewSize.getWidth(), mPreviewSize.getHeight(),
                ImageFormat.JPEG, <span class="hljs-number">2</span>);
    <span class="hljs-comment">//监听ImageReader的事件，当有图像流数据可用时会回调onImageAvailable方法，它的参数就是预览帧数据，可以对这帧数据进行处理</span>
    mImageReader.setOnImageAvailableListener(<span class="hljs-keyword">new</span> ImageReader.OnImageAvailableListener() {
        @Override
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onImageAvailable</span>(ImageReader reader) {
            Image image = reader.acquireLatestImage();
            <span class="hljs-comment">//我们可以将这帧数据转成字节数组，类似于Camera1的PreviewCallback回调的预览帧数据</span>
            ByteBuffer buffer = image.getPlanes()[<span class="hljs-number">0</span>].getBuffer();
            <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];
            buffer.<span class="hljs-keyword">get</span>(data);
            image.close();
        }
    }, <span class="hljs-keyword">null</span>);
}</code></pre> 
<blockquote> 
 <p>注意：一定要调用reader.acquireLatestImage()和close()方法，否则画面就会卡住</p> 
</blockquote> 
<p>然后我们在开启预览之前，设置ImageReader为输出Surface</p> 
<pre class="prettyprint"><code class=" hljs avrasm">setupImageReader()<span class="hljs-comment">;</span>

//获取ImageReader的Surface
Surface imageReaderSurface = mImageReader<span class="hljs-preprocessor">.getSurface</span>()<span class="hljs-comment">;</span>

//CaptureRequest添加imageReaderSurface，不加的话就会导致ImageReader的onImageAvailable()方法不会回调
mCaptureRequestBuilder<span class="hljs-preprocessor">.addTarget</span>(imageReaderSurface)<span class="hljs-comment">;</span>

//创建CaptureSession时加上imageReaderSurface，如下，这样预览数据就会同时输出到previewSurface和imageReaderSurface了
mCameraDevice<span class="hljs-preprocessor">.createCaptureSession</span>(Arrays<span class="hljs-preprocessor">.asList</span>(previewSurface, imageReaderSurface), new CameraCaptureSession<span class="hljs-preprocessor">.StateCallback</span>() {

}</code></pre> 
<blockquote> 
 <p>关闭相机时别忘了关闭ImageReader</p> 
</blockquote> 
<h4 id="6拍照">6，拍照</h4> 
<p>Camera2拍照也是通过ImageReader来实现的</p> 
<p>首先先做些准备工作，设置拍照参数，如方向、尺寸等</p> 
<pre class="prettyprint"><code class=" hljs avrasm">private static final SparseIntArray ORIENTATION = new SparseIntArray()<span class="hljs-comment">;</span>
    static {
        ORIENTATION<span class="hljs-preprocessor">.append</span>(Surface<span class="hljs-preprocessor">.ROTATION</span>_0, <span class="hljs-number">90</span>)<span class="hljs-comment">;</span>
        ORIENTATION<span class="hljs-preprocessor">.append</span>(Surface<span class="hljs-preprocessor">.ROTATION</span>_90, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
        ORIENTATION<span class="hljs-preprocessor">.append</span>(Surface<span class="hljs-preprocessor">.ROTATION</span>_180, <span class="hljs-number">270</span>)<span class="hljs-comment">;</span>
        ORIENTATION<span class="hljs-preprocessor">.append</span>(Surface<span class="hljs-preprocessor">.ROTATION</span>_270, <span class="hljs-number">180</span>)<span class="hljs-comment">;</span>
    }</code></pre> 
<p>设置拍照尺寸，可以跟预览尺寸一起设置，然后ImageReader初始化使用此尺寸</p> 
<pre class="prettyprint"><code class=" hljs avrasm">mCaptureSize = Collections<span class="hljs-preprocessor">.max</span>(Arrays<span class="hljs-preprocessor">.asList</span>(map<span class="hljs-preprocessor">.getOutputSizes</span>(ImageFormat<span class="hljs-preprocessor">.JPEG</span>)), new Comparator&lt;Size&gt;() {
                    @Override
                    public int compare(Size lhs, Size rhs) {
                        return Long<span class="hljs-preprocessor">.signum</span>(lhs<span class="hljs-preprocessor">.getWidth</span>() * lhs<span class="hljs-preprocessor">.getHeight</span>() - rhs<span class="hljs-preprocessor">.getHeight</span>() * rhs<span class="hljs-preprocessor">.getWidth</span>())<span class="hljs-comment">;</span>
                    }
                })<span class="hljs-comment">;</span></code></pre> 
<p>创建保存图片的线程</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">imageSaver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> {<!-- --></span>
        <span class="hljs-keyword">private</span> Image mImage;
        <span class="hljs-keyword">public</span> <span class="hljs-title">imageSaver</span>(Image image) {
            mImage = image;
        }
        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
            ByteBuffer buffer = mImage.getPlanes()[<span class="hljs-number">0</span>].getBuffer();
            <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];
            buffer.get(data);
            mImageFile = <span class="hljs-keyword">new</span> File(Environment.getExternalStorageDirectory() + <span class="hljs-string">"/DCIM/myPicture.jpg"</span>);
            FileOutputStream fos = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">try</span> {
                fos = <span class="hljs-keyword">new</span> FileOutputStream(mImageFile);
                fos.write(data, <span class="hljs-number">0</span> ,data.length);
            } <span class="hljs-keyword">catch</span> (IOException e) {
                e.printStackTrace();
            } <span class="hljs-keyword">finally</span> {
                mImageFile = <span class="hljs-keyword">null</span>;
                <span class="hljs-keyword">if</span> (fos != <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">try</span> {
                        fos.close();
                        fos = <span class="hljs-keyword">null</span>;
                    } <span class="hljs-keyword">catch</span> (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }</code></pre> 
<p>然后当ImageReader有数据时，通过此线程保存图片</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-comment">//使用前面获取的拍照尺寸</span>
mImageReader = ImageReader.newInstance(mCaptureSize.getWidth(), mCaptureSize.getHeight(),
                ImageFormat.JPEG, <span class="hljs-number">2</span>);
mImageReader.setOnImageAvailableListener(<span class="hljs-keyword">new</span> ImageReader.OnImageAvailableListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onImageAvailable</span>(ImageReader reader) {
                <span class="hljs-comment">//执行图像保存子线程</span>
                mCameraHandler.post(<span class="hljs-keyword">new</span> imageSaver(reader.acquireNextImage()));
            }
        }, mCameraHandler);</code></pre> 
<p>然后开启预览创建CaptureSession时把ImageReader添加进去</p> 
<pre class="prettyprint"><code class=" hljs avrasm">mCameraDevice<span class="hljs-preprocessor">.createCaptureSession</span>(Arrays<span class="hljs-preprocessor">.asList</span>(previewSurface, mImageReader<span class="hljs-preprocessor">.getSurface</span>()), new CameraCaptureSession<span class="hljs-preprocessor">.StateCallback</span>() { 
}</code></pre> 
<p>现在准备工作做好了，还需要响应点击拍照事件，我们设置点击拍照按钮调用capture()方法，capture()方法即实现拍照</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">capture</span>() {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//首先我们创建请求拍照的CaptureRequest</span>
            final CaptureRequest.Builder mCaptureBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            <span class="hljs-comment">//获取屏幕方向</span>
            <span class="hljs-keyword">int</span> rotation = getWindowManager().getDefaultDisplay().getRotation();
            <span class="hljs-comment">//设置CaptureRequest输出到mImageReader</span>
            mCaptureBuilder.addTarget(mImageReader.getSurface());
            <span class="hljs-comment">//设置拍照方向</span>
            mCaptureBuilder.<span class="hljs-keyword">set</span>(CaptureRequest.JPEG_ORIENTATION, ORIENTATION.<span class="hljs-keyword">get</span>(rotation));
            <span class="hljs-comment">//这个回调接口用于拍照结束时重启预览，因为拍照会导致预览停止</span>
            CameraCaptureSession.CaptureCallback mImageSavedCallback = <span class="hljs-keyword">new</span> CameraCaptureSession.CaptureCallback() {
                @Override
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCaptureCompleted</span>(CameraCaptureSession session, CaptureRequest request, TotalCaptureResult result) {
                    Toast.makeText(getApplicationContext(), <span class="hljs-string">"Image Saved!"</span>, Toast.LENGTH_SHORT).show();
                    <span class="hljs-comment">//重启预览</span>
                    restartPreview();
                }
            };
            <span class="hljs-comment">//停止预览</span>
            mCameraCaptureSession.stopRepeating();
            <span class="hljs-comment">//开始拍照，然后回调上面的接口重启预览，因为mCaptureBuilder设置ImageReader作为target，所以会自动回调ImageReader的onImageAvailable()方法保存图片</span>
            mCameraCaptureSession.capture(mCaptureBuilder.build(), mImageSavedCallback, <span class="hljs-keyword">null</span>);
        } <span class="hljs-keyword">catch</span> (CameraAccessException e) {
            e.printStackTrace();
        }
    }</code></pre> 
<p>重启预览的方法很简单了</p> 
<pre class="prettyprint"><code class=" hljs cs"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restartPreview</span>() {
        <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//执行setRepeatingRequest方法就行了，注意mCaptureRequest是之前开启预览设置的请求</span>
                       mCameraCaptureSession.setRepeatingRequest(mCaptureRequest, <span class="hljs-keyword">null</span>, mCameraHandler);
        } <span class="hljs-keyword">catch</span> (CameraAccessException e) {
            e.printStackTrace();
        }
    }</code></pre> 
<p>代码地址（<strong>顺手给个Star啊</strong>）：<a href="https://github.com/lb377463323/GraphicsTestBed/tree/master/Camera/CameraV2">点击查看源码</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70d2f154ea626d80485c559c43142008/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">条件变量的虚假唤醒(spurious wakeups)问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6587940eca67ee4b0311683471996870/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">直通BAT面试算法---智力题1-涂色练习题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>