<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python opencv入门 SIFT算法（33） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python opencv入门 SIFT算法（33）" />
<meta property="og:description" content="内容来自OpenCV-Python Tutorials 自己翻译整理
目标： 学习SIFT算法的概念 学习在图像中查找SIFT关键的和描述符
原理： （原理部分自己找了不少文章，内容中有不少自己理解和整理的东西，为了方便快速理解内容和能够快速理解原理，本文尽量不使用数学公式，仅仅使用文字来描述。本文中有很多引用别人文章的内容，仅供个人记录使用，若有错误，请指正出来，万分感谢）
参考文章：
参考文章1 参考文章2 参考文献3 参考文章4 参考文章5
之前的harris算法和Shi-Tomasi 算法，由于算法原理所致，具有旋转不变性，在目标图片发生旋转时依然能够获得相同的角点。但是如果对图像进行缩放以后，再使用之前的算法就会检测不出来，原理用一张图表示（图1）：
（harris算法和shi-tomasi算法都是基于窗口中像素分布和变化的原理，在图像放大且窗口大小不发生变化的时，窗口中的像素信息则会有很大的不同，造成无法检测的结果）
SIFT特性：
独特性，也就是特征点可分辨性高，类似指纹，适合在海量数据中匹配。多量性，提供的特征多。高速性，就是速度快。可扩展，能与其他特征向量联合使用。 SIFT特点：
旋转、缩放、平移不变性解决图像仿射变换，投影变换的关键的匹配光照影响小目标遮挡影响小噪声景物影响小 SIFT算法步骤：
尺度空间极值检测关键点定位关键点方向参数关键点描述符关键点匹配 尺度空间极值检测： 尺度空间的个人理解： 你找一张分辨率1024×1024图片，在电脑上观看，十分清晰，但是图片太大。现在把这图片反正photoshop上，将分辨率改成512×512,图片看着依然很清晰，但是不可能像1024×1024的画面那么精细，只不过是因为人眼构造的原因，512×512图片依然能让你分辨出这是个什么东西。
粗俗点说，尺度空间，就相当于一个图片需要获得多少分辨率的量级。如果把一个图片从原始分辨率到，不停的对其分辨率进行减少，然后将这些图片摞在一起，可以看成一个四棱锥的样式，这个东西就叫做图像金字塔（如下图，图2）。 再回到尺度空间，在摄像头中，计算机无法分辨一个景物的尺度信息。而人眼不同，除了人大脑里已经对物体有了基本的概念（例如正常人在十几米外看到苹果，和在近距离看到苹果，都能认出是苹果）以外，人眼在距离物体近时，能够获得物体足够多的特性，在距离物体远时，能够或略细节，例如，近距离看一个人脸能看到毛孔，距离远了看不到毛孔等等。
在图片信息当中，分辨率都是固定的，要想得到类似人眼的效果，就要把图片弄成不同的分辨率，制作成图像金字塔来模拟人眼的功能，从而在其他图片中进行特征识别时，能够像人眼睛一样，即使要识别的物体尺寸变大或者变小，也能够识别出来！
从图1可以看出，如果如果图像变大，窗口大小还是以前的大小，则无法正确检测出角点。那么很自然的就能想到，如果图片变大，咱们把窗口也放大不就行了？ 这就需要上面提到的尺度空间发挥作用。
在SIFT当中，利用了一个叫做高斯核的方程来构建尺度空间，原因是高斯核函数是唯一多尺度空间的核。听起来比较晦涩，个人理解为：
高斯核函数在之前的高斯滤波当中使用过，其原理就是利用高斯分布的特性，在以某一个点为中心要进行以某一个窗口大小进行模糊的操作。那么，根据滤波的原理，距离中心像素点位置的距离越远的像素点，需要“模糊化效果”的值就应该越少。那么这个距离值的分配方法，就是利用满足高斯核函数的分配方法，由中心，到四周，符合高斯核函数的“钟型”曲线（从二维上看）。
那么尺度空间中的高斯核也可以这么理解，高斯核函数的参数有三个 G(x,y,σ) ，在滤波当中，第三个参数σ在运算中是固定的一个值。而在尺度空间的构造当中，所谓的“尺度”，就是这个σ值变化，而x和y表示像素坐标。σ的值越小，图像被平滑（被模糊）的越少，尺度也越小。所以，大尺度图片可以对应成一个图像离远处观看，是个大致轮廓，小尺度图片可以对应成离近处观看，有更多细节。
构建尺度空间的目的是为了检测出在不同的尺度下都存在的特征点，如此可以获得缩放不变性
其中利用图像 I(x,y) 与 G(x,y,σ) 进行卷积运算，得到尺度空间 L(x,y,σ) ，可以理解，所谓的“尺度空间”在这里就是这个函数 L(x,y,σ) 如果求取特征点，可以使用一个叫做拉普拉斯算子进行运算
但是，由于拉普拉斯算子的效率太低，再SIFT算法当中使用差分来代替。
高斯金字塔：
在建立尺度空间后，需要找到关键点，此时需要实现高斯金字塔的构造来实现关键点的求取。在高斯金字塔当中，“塔”的每一层都是图像，“塔”的高度就是上面提到的尺度σ。“塔”的每一层对应一个σ值，同时将高斯金字塔中的图像分成组，每组当中图像的尺寸相同，但是尺度σ不同。具体尺度之间的计算关系，先忽略，如下图所示： 高斯差分金字塔DOG：
每一组相邻当中相邻两层的图像做差，得到的图像再“叠”成一个金字塔就是高斯差分金字塔DOG。
DOG局部特征点检测：
有了差分金字塔，现在便可以计算关键点（特征点）。由于金字塔的模型不是二维模型，而是一个三维模型，这里计算极值的方法也不再是二维求取极值的方法。
计算一个某一个点是否是局部最大值，在离散的三维空间当中，以该点为中心，检测它周围的点。类似魔方的中心位置一样，如下图中的“叉”就是待计算是否是局部极值点。
这里说明，局部极值点都是在同一个组当中进行的，所以肯定有这样的问题，某一组当中的第一个图和最后一个图层没有前一张图和下一张图，那该怎么计算？ 解决办法是，在用高斯模糊，在高斯金字塔多“模糊”出三张来凑数，所以在DOG中多出两张。
关键点定位： 上面找到的关键点要进行处理，去除一些不好的特征点，保存下来的特征点能够满足稳定性等条件。 主要是去掉DOG局部曲率非常不对称的像素。
因为低对比度的特征点和边界点对光照和噪声变化非常敏感，所以要去掉。利用阈值的方法来限制，在opencv中为contrastThreshold。
去除低对比度的特征点：
使用泰勒公式对DOG函数空间进行拟合，去掉小于修正阈值的关键点。
去除不稳定的边界点：
利用Hessian矩阵（就是求导数的矩阵），利用边缘梯度的方向上主曲率值比较大，而沿着边缘方向则主曲率值较小的原理，将主曲率限制为某个值。满足该值条件的点留下，反之去除。
关键点设定方向参数： 每个关键点设置方向以后可以获得旋转不变性。 获取关键点所在尺度空间的邻域，然后计算该区域的梯度和方向，根据计算得到的结果创建方向直方图，直方图的峰值为主方向的参数，其他高于主方向百分之80的方向被判定为辅助方向，这样设定对稳定性有很大帮助。如图
关键点描述符： 经过上面的步骤计算，每个关键点有三个信息，位置、尺度、方向。所以具备平移、缩放、和旋转不变性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/232798dfd9f2d6866023a701ca3b446b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-08T15:07:52+08:00" />
<meta property="article:modified_time" content="2017-10-08T15:07:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python opencv入门 SIFT算法（33）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>内容来自OpenCV-Python Tutorials 自己翻译整理</p> 
<h3 id="目标"><strong>目标：</strong></h3> 
<p>学习SIFT算法的概念 <br> 学习在图像中查找SIFT关键的和描述符</p> 
<h3 id="原理"><strong>原理：</strong></h3> 
<p>（原理部分自己找了不少文章，内容中有不少自己理解和整理的东西，为了方便快速理解内容和能够快速理解原理，本文尽量不使用数学公式，仅仅使用文字来描述。本文中有很多引用别人文章的内容，仅供个人记录使用，若有错误，请指正出来，万分感谢）</p> 
<p><strong>参考文章：</strong></p> 
<p><a href="http://blog.csdn.net/pi9nc/article/details/23302075" target="_blank" rel="noopener noreferrer">参考文章1</a> <br> <a href="http://blog.csdn.net/dcrmg/article/details/52561656" target="_blank" rel="noopener noreferrer">参考文章2</a> <br> <a href="https://wenku.baidu.com/view/c4c4e5323b3567ec102d8af9.html" rel="nofollow noopener noreferrer" target="_blank">参考文献3</a> <br> <a href="http://www.cnblogs.com/wangguchangqing/p/4853263.html" rel="nofollow noopener noreferrer" target="_blank">参考文章4</a> <br> <a href="http://blog.sciencenet.cn/blog-254499-739338.html" rel="nofollow noopener noreferrer" target="_blank">参考文章5</a></p> 
<p>之前的harris算法和Shi-Tomasi 算法，由于算法原理所致，具有旋转不变性，在目标图片发生旋转时依然能够获得相同的角点。但是如果对图像进行缩放以后，再使用之前的算法就会检测不出来，原理用一张图表示（图1）：</p> 
<p><img src="https://images2.imgbox.com/01/54/w7YkMbv8_o.png" alt="这里写图片描述" title=""></p> 
<p>（harris算法和shi-tomasi算法都是基于窗口中像素分布和变化的原理，在图像放大且窗口大小不发生变化的时，窗口中的像素信息则会有很大的不同，造成无法检测的结果）</p> 
<p><strong>SIFT特性：</strong></p> 
<ul><li>独特性，也就是特征点可分辨性高，类似指纹，适合在海量数据中匹配。</li><li>多量性，提供的特征多。</li><li>高速性，就是速度快。</li><li>可扩展，能与其他特征向量联合使用。</li></ul> 
<p><strong>SIFT特点：</strong></p> 
<ul><li>旋转、缩放、平移不变性</li><li>解决图像仿射变换，投影变换的关键的匹配</li><li>光照影响小</li><li>目标遮挡影响小</li><li>噪声景物影响小</li></ul> 
<p><strong>SIFT算法步骤：</strong></p> 
<ol><li>尺度空间极值检测</li><li>关键点定位</li><li>关键点方向参数</li><li>关键点描述符</li><li>关键点匹配</li></ol> 
<h4 id="尺度空间极值检测"><strong>尺度空间极值检测：</strong></h4> 
<p>尺度空间的个人理解： <br> 你找一张分辨率1024×1024图片，在电脑上观看，十分清晰，但是图片太大。现在把这图片反正photoshop上，将分辨率改成512×512,图片看着依然很清晰，但是不可能像1024×1024的画面那么精细，只不过是因为人眼构造的原因，512×512图片依然能让你分辨出这是个什么东西。</p> 
<p>粗俗点说，尺度空间，就相当于一个图片需要获得多少分辨率的量级。如果把一个图片从原始分辨率到，不停的对其分辨率进行减少，然后将这些图片摞在一起，可以看成一个四棱锥的样式，这个东西就叫做<strong>图像金字塔</strong>（如下图，图2）。 <br> <img src="https://images2.imgbox.com/ee/6c/IGu5jzqa_o.png" alt="这里写图片描述" title=""></p> 
<p>再回到尺度空间，在摄像头中，计算机无法分辨一个景物的尺度信息。而人眼不同，除了人大脑里已经对物体有了基本的概念（例如正常人在十几米外看到苹果，和在近距离看到苹果，都能认出是苹果）以外，人眼在距离物体近时，能够获得物体足够多的特性，在距离物体远时，能够或略细节，例如，近距离看一个人脸能看到毛孔，距离远了看不到毛孔等等。</p> 
<p>在图片信息当中，分辨率都是固定的，要想得到类似人眼的效果，就要把图片弄成不同的分辨率，制作成图像金字塔来模拟人眼的功能，从而在其他图片中进行特征识别时，能够像人眼睛一样，即使要识别的物体尺寸变大或者变小，也能够识别出来！</p> 
<p>从图1可以看出，如果如果图像变大，窗口大小还是以前的大小，则无法正确检测出角点。那么很自然的就能想到，如果图片变大，咱们把窗口也放大不就行了？ 这就需要上面提到的尺度空间发挥作用。</p> 
<p>在SIFT当中，利用了一个叫做<strong>高斯核</strong>的方程来构建尺度空间，原因是高斯核函数是唯一多尺度空间的核。听起来比较晦涩，个人理解为：</p> 
<p>高斯核函数在之前的高斯滤波当中使用过，其原理就是利用高斯分布的特性，在以某一个点为中心要进行以某一个窗口大小进行模糊的操作。那么，根据滤波的原理，距离中心像素点位置的距离越远的像素点，需要“模糊化效果”的值就应该越少。那么这个距离值的分配方法，就是利用满足高斯核函数的分配方法，由中心，到四周，符合高斯核函数的“钟型”曲线（从二维上看）。</p> 
<p>那么尺度空间中的高斯核也可以这么理解，高斯核函数的参数有三个<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame" style=""> 
   
   <span class="math" id="MathJax-Span-1" style="width: 5.016em; display: inline-block;"><span style="display: inline-block; position: relative; width: 4.003em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000em 3.149em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">G</span><span class="mo" id="MathJax-Span-4" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-6" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-8" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-9" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">σ<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-10" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span> 
  </span><script type="math/tex" id="MathJax-Element-1">G(x,y,\sigma)</script> ，在滤波当中，第三个参数σ在运算中是固定的一个值。而在尺度空间的构造当中，所谓的“尺度”，就是这个σ值变化，而x和y表示像素坐标。σ的值越小，图像被平滑（被模糊）的越少，尺度也越小。所以，大尺度图片可以对应成一个图像离远处观看，是个大致轮廓，小尺度图片可以对应成离近处观看，有更多细节。</p> 
<p><strong>构建尺度空间的目的是为了检测出在不同的尺度下都存在的特征点，如此可以获得缩放不变性</strong></p> 
<p>其中利用图像<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-2-Frame" style=""> 
   
   <span class="math" id="MathJax-Span-11" style="width: 3.416em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.723em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000em 3.149em -0.477em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-12"><span class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic;">I<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.056em;"></span></span><span class="mo" id="MathJax-Span-14" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-16" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-17" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-18" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span> 
  </span><script type="math/tex" id="MathJax-Element-2">I(x,y)</script>与<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-3-Frame" style=""> 
   
   <span class="math" id="MathJax-Span-19" style="width: 5.016em; display: inline-block;"><span style="display: inline-block; position: relative; width: 4.003em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000em 3.149em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-20"><span class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math-italic;">G</span><span class="mo" id="MathJax-Span-22" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-23" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-24" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-25" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-26" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-27" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">σ<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-28" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span> 
  </span><script type="math/tex" id="MathJax-Element-3">G(x,y,\sigma)</script> 进行卷积运算，得到尺度空间<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-4-Frame" style=""> 
   
   <span class="math" id="MathJax-Span-29" style="width: 4.963em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.949em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000em 3.149em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-30"><span class="mi" id="MathJax-Span-31" style="font-family: MathJax_Math-italic;">L</span><span class="mo" id="MathJax-Span-32" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-33" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-34" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-35" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-36" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-37" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">σ<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-38" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span> 
  </span><script type="math/tex" id="MathJax-Element-4">L(x,y,\sigma)</script>，可以理解，所谓的“尺度空间”在这里就是这个函数<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-5-Frame" style=""> 
   
   <span class="math" id="MathJax-Span-39" style="width: 4.963em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.949em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000em 3.149em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-40"><span class="mi" id="MathJax-Span-41" style="font-family: MathJax_Math-italic;">L</span><span class="mo" id="MathJax-Span-42" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-43" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-44" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-45" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-46" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-47" style="font-family: MathJax_Math-italic; padding-left: 0.163em;">σ<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-48" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span> 
  </span><script type="math/tex" id="MathJax-Element-5">L(x,y,\sigma)</script></p> 
<p>如果求取特征点，可以使用一个叫做拉普拉斯算子进行运算</p> 
<p>但是，由于拉普拉斯算子的效率太低，再SIFT算法当中使用<strong>差分</strong>来代替。</p> 
<p><strong>高斯金字塔：</strong></p> 
<p>在建立尺度空间后，<strong>需要找到关键点</strong>，此时需要实现高斯金字塔的构造来实现关键点的求取。在高斯金字塔当中，“塔”的每一层都是图像，“塔”的高度就是上面提到的尺度σ。“塔”的每一层对应一个σ值，同时将高斯金字塔中的图像分成组，每组当中图像的尺寸相同，但是尺度σ不同。具体尺度之间的计算关系，先忽略，如下图所示： <br> <img src="https://images2.imgbox.com/c1/07/z1tvMHqR_o.png" alt="这里写图片描述" title=""></p> 
<p><strong>高斯差分金字塔DOG：</strong></p> 
<p>每一组相邻当中相邻两层的图像做差，得到的图像再“叠”成一个金字塔就是高斯差分金字塔DOG。</p> 
<p><strong>DOG局部特征点检测：</strong></p> 
<p>有了差分金字塔，现在便可以计算关键点（特征点）。由于金字塔的模型不是二维模型，而是一个三维模型，这里计算极值的方法也不再是二维求取极值的方法。</p> 
<p>计算一个某一个点是否是局部最大值，在离散的三维空间当中，以该点为中心，检测它周围的点。类似魔方的中心位置一样，如下图中的“叉”就是待计算是否是局部极值点。</p> 
<p><img src="https://images2.imgbox.com/a5/34/cSuNZrbu_o.png" alt="这里写图片描述" title=""></p> 
<p>这里说明，局部极值点都是在同一个组当中进行的，所以肯定有这样的问题，某一组当中的第一个图和最后一个图层没有前一张图和下一张图，那该怎么计算？ 解决办法是，在用高斯模糊，在高斯金字塔多“模糊”出三张来凑数，所以在DOG中多出两张。</p> 
<h4 id="关键点定位"><strong>关键点定位：</strong></h4> 
<p>上面找到的关键点要进行处理，去除一些不好的特征点，保存下来的特征点能够满足稳定性等条件。 <br> 主要是去掉DOG局部曲率非常不对称的像素。</p> 
<p>因为低对比度的特征点和边界点对光照和噪声变化非常敏感，所以要去掉。利用阈值的方法来限制，在opencv中为contrastThreshold。</p> 
<p><strong>去除低对比度的特征点：</strong></p> 
<p>使用泰勒公式对DOG函数空间进行拟合，去掉小于修正阈值的关键点。</p> 
<p><strong>去除不稳定的边界点：</strong></p> 
<p>利用Hessian矩阵（就是求导数的矩阵），利用边缘梯度的方向上主曲率值比较大，而沿着边缘方向则主曲率值较小的原理，将主曲率限制为某个值。满足该值条件的点留下，反之去除。</p> 
<h4 id="关键点设定方向参数"><strong>关键点设定方向参数：</strong></h4> 
<p>每个关键点设置方向以后可以获得旋转不变性。 <br> 获取关键点所在尺度空间的邻域，然后计算该区域的梯度和方向，根据计算得到的结果创建方向直方图，直方图的峰值为主方向的参数，其他高于主方向百分之80的方向被判定为辅助方向，这样设定对稳定性有很大帮助。如图</p> 
<p><img src="https://images2.imgbox.com/56/62/upwtIfRq_o.png" alt="这里写图片描述" title=""></p> 
<h4 id="关键点描述符"><strong>关键点描述符：</strong></h4> 
<p>经过上面的步骤计算，每个关键点有三个信息，位置、尺度、方向。所以具备平移、缩放、和旋转不变性。</p> 
<p>接下来对每个关键点用一组向量将这个关键点描述出来，使其不随着光照、视角等等影响而改变。该描述符不但涉及关键点，而且还涉及到关键点周围的像素，使其有更强的不变特性。</p> 
<p>基本原理是选取关键点周围16×16的像素区域，分成4个小块，每个小块创建8个bin的直方图，这总共的128个信息的向量就是关键点描述符的主要内容。此外还要测量，以达到光照、旋转的稳定性。如图</p> 
<p><img src="https://images2.imgbox.com/78/67/FyrWd3k7_o.png" alt="这里写图片描述" title=""></p> 
<h4 id="关键点匹配"><strong>关键点匹配：</strong></h4> 
<p>分别对模板图和实时图建立关键点描述符集合，通过对比关键点描述符来判断两个关键点是否相同。128个信息的向量使用欧氏距离来实现。</p> 
<p>在关键点的匹配当中，使用的搜索算法为区域搜索算法当中最常用的k-d树实现。</p> 
<p>比较之后，需要在进行消除错配点才算完成。</p> 
<h3 id="opencv-中的-sift"><strong>OpenCV 中的 SIFT：</strong></h3> 
<p><strong>关于opencv版本与SIFT算法不能调用的问题：</strong></p> 
<p>SIFT算法是一个有专利的算法，在商业用途上是收费的。对于穷B学生，算法的发明者还比较仁慈，可以使用。 <br> 不过，在python当中使用SIFT算法和版本之间有不少关系，源文档当中使用opencv版本是2.4.9版本，此版本可以随意使用SIFT算法。</p> 
<p>但是，在opencv3当中就没那么幸运了，opencv中的很多特征点提取算法都和cv2中的库分离开，必须要添加opencv-contrib才可以使用，本人使用的opencv版本是3.3.0，几乎是最新的版本。</p> 
<p>网上有一大堆教程关于如何在opencv当中如何添加opencv-contrib的教程，使用cmake，使用vs，啥的非常麻烦。</p> 
<p>本人狗急跳墙，寻思在pip上面有没有啥第三方的库可以直接就将opencv-contrib这个库。</p> 
<p>结果，还真找到了 哈哈。</p> 
<p>这下方便了，只要在你的控制台当中输入 <br> pip install opencv-contrib-python即可</p> 
<p>如果pip安装不上去</p> 
<p>直接上官方上面下个轮子，然后pip安装就能用了</p> 
<p><a href="https://pypi.python.org/pypi/opencv-contrib-python" rel="nofollow noopener noreferrer" target="_blank">网站在此！！！</a></p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> cv2
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np


img = cv2.imread(<span class="hljs-string">'1.jpg'</span>)
gray= cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
sift = cv2.xfeatures2d.SIFT_create()


kp = sift.detect(gray,<span class="hljs-keyword">None</span>)<span class="hljs-comment">#找到关键点</span>

img=cv2.drawKeypoints(gray,kp,img)<span class="hljs-comment">#绘制关键点</span>

cv2.imshow(<span class="hljs-string">'sp'</span>,img)
cv2.waitKey(<span class="hljs-number">0</span>)</code></pre> 
<p>返回的关键点是一个带有很多不用属性的特殊结构体，属性当中有坐标，方向、角度等等。</p> 
<p><strong>计算关键点描述符：</strong> <br> 使用sift.compute()函数来进行计算关键点描述符</p> 
<pre class="prettyprint"><code class="language-python hljs ">kp,des = sift.compute(gray,kp)</code></pre> 
<p>如果未找到关键点，可使用函数sift.detectAndCompute()直接找到关键点并计算。</p> 
<p>在第二个函数中，kp为关键点列表，des为numpy的数组，为关键点数目×128</p> 
<pre class="prettyprint"><code class="language-python hljs ">sift = cv2.xfeatures2d.SIFT_create()

kp, des = sift.detectAndCompute(gray,<span class="hljs-keyword">None</span>)</code></pre> 
<p>结果如图</p> 
<p><img src="https://images2.imgbox.com/cf/7e/INM59Unl_o.png" alt="这里写图片描述" title=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/50723ae556c684e9788846fa35bacb07/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot学习之旅：（六）springboot 整合 redis 以及 redis 通用工具类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/423e0950282f8dab43c9f904cee35d50/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用 Electron 从剪贴板复制和粘贴</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>