<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>五、Spring AOP - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="五、Spring AOP" />
<meta property="og:description" content="目录
1. AOP入口类的添加
2. 匹配Advisor生成代理
2.1 基本概念
2.1.1 Pointcut
2.1.2 Advice
2.1.3 Advisor
2.2 生成代理
2.2.1 找到bean匹配的Advisor
2.2.2如果bean有匹配到Advisor,则为其生成代理对象
3. 被代理方法的执行
3.1 获取被代理方法匹配的增强统一包装成MethodInterceptor
3.2方法调用
3.2.1 Before 增强的调用
3.2.2 After增强的调用
3.2.3 Around增强的调用
3.2.4 AfterReturning增强的调用
3.2.5 AfterThrowing增强的调用
4. 事务切面
4.1开启事务支持
4.1.1 添加AOP入口bean
4.1.2 添加事务advisor
4.2 事务pointCut
4.3事务增强advice
4.3.1 底层JDBC事务
4.3.2 常用事务传播属性
4.3.3 事务代码分析
5. 异步切面
5.1开启异步支持
5.2 异步advisor
5.2.1 异步pointCut
5.2.2 异步advice
5.2.3 bean添加异步advisor
(本篇中用到的演示项目地址：https://gitee.com/yejuan/spring-learning-no-xml 对应tag: spring-c5)
1. AOP入口类的添加 上一篇我们分析到AbstractAutoProxyCreator#postProcessAfterInitialization这个方法中如果bean有匹配到advisor将会生成bean的代理实例。AbstractAutoProxyCreator是一个抽象类，要相关方法得以执行就必须要将其子类并且是实现了BeanPostProcessor接口的子类注册到BeanFactory的List&lt;BeanPostProcessor&gt; beanPostProcessors容器中。
@EnableAspectJAutoProxy通过@Import将AspectJAutoProxyRegistrar加入到spring 容器中，AspectJAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口，在registerBeanDefinitions方法中就会将AOP的入口类AnnotationAwareAspectJAutoProxyCreator加入spring容器。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5e7176ec82f617410a902538ea823466/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-23T15:39:58+08:00" />
<meta property="article:modified_time" content="2020-08-23T15:39:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">五、Spring AOP</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"> </p> 
<p id="1.%20AOP%E5%85%A5%E5%8F%A3%E7%B1%BB%E7%9A%84%E6%B7%BB%E5%8A%A0-toc" style="margin-left:0px;"><a href="#1.%20AOP%E5%85%A5%E5%8F%A3%E7%B1%BB%E7%9A%84%E6%B7%BB%E5%8A%A0" rel="nofollow">1. AOP入口类的添加</a></p> 
<p id="2.%20%E5%8C%B9%E9%85%8DAdvisor%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86-toc" style="margin-left:0px;"><a href="#2.%20%E5%8C%B9%E9%85%8DAdvisor%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86" rel="nofollow">2. 匹配Advisor生成代理</a></p> 
<p id="2.1%C2%A0%C2%A0%20%C2%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2.1%C2%A0%C2%A0%20%C2%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">2.1    基本概念</a></p> 
<p id="2.1.1%20Pointcut-toc" style="margin-left:80px;"><a href="#2.1.1%20Pointcut" rel="nofollow">2.1.1 Pointcut</a></p> 
<p id="2.1.2%20Advice-toc" style="margin-left:80px;"><a href="#2.1.2%20Advice" rel="nofollow">2.1.2 Advice</a></p> 
<p id="2.1.3%20Advisor-toc" style="margin-left:80px;"><a href="#2.1.3%20Advisor" rel="nofollow">2.1.3 Advisor</a></p> 
<p id="2.2%C2%A0%C2%A0%20%C2%A0%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%C2%A0%20%C2%A0%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86" rel="nofollow">2.2    生成代理</a></p> 
<p id="2.2.1%20%E6%89%BE%E5%88%B0bean%E5%8C%B9%E9%85%8D%E7%9A%84Advisor-toc" style="margin-left:80px;"><a href="#2.2.1%20%E6%89%BE%E5%88%B0bean%E5%8C%B9%E9%85%8D%E7%9A%84Advisor" rel="nofollow">2.2.1 找到bean匹配的Advisor</a></p> 
<p id="2.2.2%E5%A6%82%E6%9E%9Cbean%E6%9C%89%E5%8C%B9%E9%85%8D%E5%88%B0Advisor%2C%E5%88%99%E4%B8%BA%E5%85%B6%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#2.2.2%E5%A6%82%E6%9E%9Cbean%E6%9C%89%E5%8C%B9%E9%85%8D%E5%88%B0Advisor%2C%E5%88%99%E4%B8%BA%E5%85%B6%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1" rel="nofollow">2.2.2如果bean有匹配到Advisor,则为其生成代理对象</a></p> 
<p id="3.%20%E8%A2%AB%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C-toc" style="margin-left:0px;"><a href="#3.%20%E8%A2%AB%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C" rel="nofollow">3. 被代理方法的执行</a></p> 
<p id="3.1%20%E8%8E%B7%E5%8F%96%E8%A2%AB%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E5%8C%B9%E9%85%8D%E7%9A%84%E5%A2%9E%E5%BC%BA%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E6%88%90MethodInterceptor-toc" style="margin-left:40px;"><a href="#3.1%20%E8%8E%B7%E5%8F%96%E8%A2%AB%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E5%8C%B9%E9%85%8D%E7%9A%84%E5%A2%9E%E5%BC%BA%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E6%88%90MethodInterceptor" rel="nofollow">3.1 获取被代理方法匹配的增强统一包装成MethodInterceptor</a></p> 
<p id="3.2%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#3.2%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" rel="nofollow">3.2方法调用</a></p> 
<p id="3.2.1%20Before%20%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#3.2.1%20Before%20%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8" rel="nofollow">3.2.1 Before 增强的调用</a></p> 
<p id="3.2.2%20After%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#3.2.2%20After%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8" rel="nofollow">3.2.2 After增强的调用</a></p> 
<p id="3.2.3%20Around%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#3.2.3%20Around%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8" rel="nofollow">3.2.3 Around增强的调用</a></p> 
<p id="3.2.4%20AfterReturning%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#3.2.4%20AfterReturning%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8" rel="nofollow">3.2.4 AfterReturning增强的调用</a></p> 
<p id="3.2.5%20AfterThrowing%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#3.2.5%20AfterThrowing%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8" rel="nofollow">3.2.5 AfterThrowing增强的调用</a></p> 
<p id="4.%20%E4%BA%8B%E5%8A%A1%E5%88%87%E9%9D%A2-toc" style="margin-left:0px;"><a href="#4.%20%E4%BA%8B%E5%8A%A1%E5%88%87%E9%9D%A2" rel="nofollow">4. 事务切面</a></p> 
<p id="4.1%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81-toc" style="margin-left:40px;"><a href="#4.1%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81" rel="nofollow">4.1开启事务支持</a></p> 
<p id="4.1.1%20%E6%B7%BB%E5%8A%A0AOP%E5%85%A5%E5%8F%A3bean-toc" style="margin-left:80px;"><a href="#4.1.1%20%E6%B7%BB%E5%8A%A0AOP%E5%85%A5%E5%8F%A3bean" rel="nofollow">4.1.1 添加AOP入口bean</a></p> 
<p id="4.1.2%20%E6%B7%BB%E5%8A%A0%E4%BA%8B%E5%8A%A1advisor-toc" style="margin-left:80px;"><a href="#4.1.2%20%E6%B7%BB%E5%8A%A0%E4%BA%8B%E5%8A%A1advisor" rel="nofollow">4.1.2 添加事务advisor</a></p> 
<p id="4.2%20%E4%BA%8B%E5%8A%A1pointCut-toc" style="margin-left:40px;"><a href="#4.2%20%E4%BA%8B%E5%8A%A1pointCut" rel="nofollow">4.2 事务pointCut</a></p> 
<p id="4.3%E4%BA%8B%E5%8A%A1%E5%A2%9E%E5%BC%BAadvice-toc" style="margin-left:40px;"><a href="#4.3%E4%BA%8B%E5%8A%A1%E5%A2%9E%E5%BC%BAadvice" rel="nofollow">4.3事务增强advice</a></p> 
<p id="4.3.1%20%E5%BA%95%E5%B1%82JDBC%E4%BA%8B%E5%8A%A1-toc" style="margin-left:80px;"><a href="#4.3.1%20%E5%BA%95%E5%B1%82JDBC%E4%BA%8B%E5%8A%A1" rel="nofollow">4.3.1 底层JDBC事务</a></p> 
<p id="4.3.2%20%E5%B8%B8%E7%94%A8%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#4.3.2%20%E5%B8%B8%E7%94%A8%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7" rel="nofollow">4.3.2 常用事务传播属性</a></p> 
<p id="4.3.3%20%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#4.3.3%20%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">4.3.3 事务代码分析</a></p> 
<p id="5.%20%E5%BC%82%E6%AD%A5%E5%88%87%E9%9D%A2-toc" style="margin-left:0px;"><a href="#5.%20%E5%BC%82%E6%AD%A5%E5%88%87%E9%9D%A2" rel="nofollow">5. 异步切面</a></p> 
<p id="5.1%E5%BC%80%E5%90%AF%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81-toc" style="margin-left:40px;"><a href="#5.1%E5%BC%80%E5%90%AF%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81" rel="nofollow">5.1开启异步支持</a></p> 
<p id="5.2%20%E5%BC%82%E6%AD%A5advisor-toc" style="margin-left:40px;"><a href="#5.2%20%E5%BC%82%E6%AD%A5advisor" rel="nofollow">5.2 异步advisor</a></p> 
<p id="5.2.1%20%E5%BC%82%E6%AD%A5pointCut-toc" style="margin-left:80px;"><a href="#5.2.1%20%E5%BC%82%E6%AD%A5pointCut" rel="nofollow">5.2.1 异步pointCut</a></p> 
<p id="5.2.2%20%E5%BC%82%E6%AD%A5advice-toc" style="margin-left:80px;"><a href="#5.2.2%20%E5%BC%82%E6%AD%A5advice" rel="nofollow">5.2.2 异步advice</a></p> 
<p id="5.2.3%20bean%E6%B7%BB%E5%8A%A0%E5%BC%82%E6%AD%A5advisor-toc" style="margin-left:80px;"><a href="#5.2.3%20bean%E6%B7%BB%E5%8A%A0%E5%BC%82%E6%AD%A5advisor" rel="nofollow">5.2.3 bean添加异步advisor</a></p> 
<hr id="hr-toc"> 
<p>(本篇中用到的演示项目地址：https://gitee.com/yejuan/spring-learning-no-xml 对应tag: spring-c5)</p> 
<h2 id="1.%20AOP%E5%85%A5%E5%8F%A3%E7%B1%BB%E7%9A%84%E6%B7%BB%E5%8A%A0">1. AOP入口类的添加</h2> 
<p style="text-indent:33px;">上一篇我们分析到AbstractAutoProxyCreator#postProcessAfterInitialization这个方法中如果bean有匹配到advisor将会生成bean的代理实例。AbstractAutoProxyCreator是一个抽象类，要相关方法得以执行就必须要将其子类并且是实现了<span style="color:#000000;">BeanPostProcessor</span><span style="color:#000000;">接口的子类注册到</span><span style="color:#000000;">BeanFactory</span><span style="color:#000000;">的</span><span style="color:#000000;">List&lt;BeanPostPr</span>ocessor&gt; beanPostProcessors容器中。</p> 
<p style="text-indent:0;"><img alt="" height="457" src="https://images2.imgbox.com/f9/34/eBY43jtE_o.png" width="1151"></p> 
<p style="text-indent:0;"><img alt="" height="585" src="https://images2.imgbox.com/54/34/A4AMToG1_o.png" width="1107"></p> 
<p>@EnableAspectJAutoProxy通过@Import将AspectJAutoProxyRegistrar加入到spring 容器中，AspectJAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口，在registerBeanDefinitions方法中就会将AOP的入口类AnnotationAwareAspectJAutoProxyCreator加入spring容器。</p> 
<p><img alt="" height="559" src="https://images2.imgbox.com/09/eb/WJAaJujm_o.png" width="1200"></p> 
<p><img alt="" height="430" src="https://images2.imgbox.com/d8/77/Xe0govUm_o.png" width="1167"></p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/79/11/MMae6DDM_o.png" width="1095"></p> 
<h2 id="2.%20%E5%8C%B9%E9%85%8DAdvisor%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86">2. 匹配Advisor生成代理</h2> 
<p>切面使用示例</p> 
<pre><code>@Aspect
@Component
public class MyAspect {

    @Pointcut("execution(* com.yej.learning.service.AccountService.*(..))")
    public void myPoint(){}

    @Pointcut("execution(* com.yej.learning.service.AccountService.exceptionMethod(..))")
    public void exceptionPoint(){}

    @Before("myPoint()")
    public void befor(){
        System.out.println("---------MyAspect befor -------------");
    }

    @After("myPoint()")
    public void after(){
        System.out.println("---------MyAspect after -------------");
    }

    @Around("myPoint()")
    public Object around(ProceedingJoinPoint joinPoint) {
        Object obj = null;
        try {
            System.out.println("---------MyAspect around before -------------");
            obj = joinPoint.proceed();
            System.out.println("---------MyAspect around after -------------");
        } catch (Throwable e) {
           e.printStackTrace();
        }
        return obj;
    }

    @AfterReturning(returning = "retObj", pointcut = "myPoint()")
    public void afterReturning(Object retObj) throws Throwable {
       System.out.println("return =" + retObj + "---------MyAspect   afterReturning---------------");
    }

    @AfterThrowing(throwing = "e", pointcut = "myPoint()")
    public void afterThrowing(Exception e) throws Throwable {
       System.out.println("Exception =" + e.getMessage() + "---------MyAspect   afterThrowing---------------");
    }

}
</code></pre> 
<p> </p> 
<h3 id="2.1%C2%A0%C2%A0%20%C2%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2.1    基本概念</h3> 
<h4 id="2.1.1%20Pointcut" style="margin-left:0cm;">2.1.1 Pointcut</h4> 
<p style="margin-left:0cm;">切点，匹配哪些方法需要被增强</p> 
<h4 id="2.1.2%20Advice" style="margin-left:0cm;">2.1.2 Advice</h4> 
<p>增强，上面@Before、@After、@Around、@AfterReturning、@AfterThrowing等注解修饰的方法体,即方法调用时正常方法外需要额外执行的内容。</p> 
<h4 id="2.1.3%20Advisor" style="margin-left:0cm;">2.1.3 Advisor</h4> 
<p style="margin-left:0cm;">一组PointCut和Advice的封装</p> 
<h3 id="2.2%C2%A0%C2%A0%20%C2%A0%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86" style="margin-left:0cm;">2.2    生成代理</h3> 
<h4 id="2.2.1%20%E6%89%BE%E5%88%B0bean%E5%8C%B9%E9%85%8D%E7%9A%84Advisor" style="margin-left:0cm;">2.2.1 找到bean匹配的Advisor</h4> 
<p style="margin-left:0cm;">获取与bean匹配的Advisor，找到spring容器中所有的Advisor:1.获取容器中所有Advisor类型的bean;2.过滤有@Aspect注解修饰的bean，遍历bean中所有方法，包装 Around, Before, After, AfterReturning,AfterThrowing注解修饰的方法和注解中配置的PointCut得到Advisor。循环Advisor，获取与当前bean类匹配的Advisor，pointCut与bean进行匹配时会先进行类匹配再进行方法匹配，类过滤器未匹配上时直接返回false,类过滤器匹配上再进行方法匹配，有一个方法匹配上该advisor即与bean匹配上，则该Advisor与目标类匹配。</p> 
<p style="margin-left:0cm;">org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#wrapIfNecessary</p> 
<p style="margin-left:0cm;"><img alt="" height="619" src="https://images2.imgbox.com/b4/f6/yFPT9xXd_o.png" width="1122"></p> 
<p style="margin-left:0cm;"><img alt="" height="521" src="https://images2.imgbox.com/06/65/80831siE_o.png" width="1074"></p> 
<p style="margin-left:0cm;"><img alt="" height="429" src="https://images2.imgbox.com/97/3d/PNgCary6_o.png" width="1003"></p> 
<p style="margin-left:0cm;"><img alt="" height="591" src="https://images2.imgbox.com/49/12/m26h4hdC_o.png" width="1104"></p> 
<p style="margin-left:0cm;">被不同注解Around, Before, After, AfterReturning, AfterThrowing修饰的切面方法生成的advice增强是不同类型的。对应的增强实现的接口也是不一样的，在代理对象方法调用时会针对advice实现的不同接口进行再次包装，以实现对advice调用的统一、标准化。</p> 
<p style="margin-left:0cm;">org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory#getAdvisor</p> 
<p style="margin-left:0cm;"><img alt="" height="553" src="https://images2.imgbox.com/98/96/QcliUaWQ_o.png" width="1086"></p> 
<p style="margin-left:0cm;"><img alt="" height="430" src="https://images2.imgbox.com/db/12/gxaiNshv_o.png" width="1190"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><img alt="" height="704" src="https://images2.imgbox.com/45/a8/xmmfVtaw_o.png" width="1079"></p> 
<p style="margin-left:0cm;">org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory#getAdvice</p> 
<p style="margin-left:0cm;"><img alt="" height="520" src="https://images2.imgbox.com/cb/85/TB7LyCje_o.png" width="719"></p> 
<h4 id="2.2.2%E5%A6%82%E6%9E%9Cbean%E6%9C%89%E5%8C%B9%E9%85%8D%E5%88%B0Advisor%2C%E5%88%99%E4%B8%BA%E5%85%B6%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1" style="margin-left:0cm;">2.2.2如果bean有匹配到Advisor,则为其生成代理对象</h4> 
<p><img alt="" height="518" src="https://images2.imgbox.com/7e/76/f4GI2zRH_o.png" width="1176"></p> 
<p>2.2.2.1获取通过interceptorNames添加的通用advisor</p> 
<p style="margin-left:0cm;">获取通用advisor,遍历interceptorNames容器，通过getBean获取实例，包装生成对应的Advisor。可以自定义实现MethodInterceptor、AfterReturningAdvice、MethodBeforeAdvice、ThrowsAdvice等接口的bean添加到interceptorNames容器，包装生成通用DefaultPointcutAdvisor，DefaultPointcutAdvisor会拦截代理实例的每个实例方法。</p> 
<p style="margin-left:0cm;">org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy</p> 
<p style="margin-left:0cm;"><img alt="" height="494" src="https://images2.imgbox.com/46/8c/PXd0yocD_o.png" width="1086"></p> 
<p style="margin-left:0cm;"><img alt="" height="495" src="https://images2.imgbox.com/92/75/NrVJSyah_o.png" width="973"></p> 
<p style="margin-left:0cm;"><img alt="" height="554" src="https://images2.imgbox.com/38/5e/3iMX6jzx_o.png" width="909"></p> 
<p style="margin-left:0cm;">添加通用Advisor示例</p> 
<pre><code>@Component
public class CommonMethodInterceptor implements MethodInterceptor, BeanFactoryAware {

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        AbstractAdvisorAutoProxyCreator proxyCreator = beanFactory.getBean(AbstractAdvisorAutoProxyCreator.class);
        /**
         * 添加到interceptorNames容器中
         */
        proxyCreator.setInterceptorNames("commonMethodInterceptor");
    }

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("---------CommonMethodInterceptor invoke--------------------");
        return invocation.proceed();
    }
}
</code></pre> 
<p>2.2.2.2 创建代理实例</p> 
<p style="margin-left:0cm;">判断beanClass是否有实现接口，设置相关值，为使用CGLIB进行代理还是JDK动态代理做好准备</p> 
<p style="margin-left:0cm;">org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy</p> 
<p style="margin-left:0cm;"><img alt="" height="546" src="https://images2.imgbox.com/f3/18/ORpLPdYZ_o.png" width="1049"></p> 
<p style="margin-left:0cm;"><img alt="" height="624" src="https://images2.imgbox.com/d8/6b/kB06fyPh_o.png" width="1021"></p> 
<p style="margin-left:0cm;">获取到作用于bean的所有advisor，包括通过interceptorNames添加的通用advisor，通过CGLIB或JDK动态代理生成代理实例。</p> 
<p style="margin-left:0cm;">org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy</p> 
<p style="margin-left:0cm;"><img alt="" height="591" src="https://images2.imgbox.com/2d/d7/9ScW89fc_o.png" width="971"></p> 
<p style="margin-left:0cm;">默认如果有实现接口采用JDK动态代理，没有实现接口采用CGLIB进行代理(注意：对于JDK动态代理的bean，通过类型调用getBean(IUserService.class)获取实例时必须通过接口类型获取，spring容器中缓存的是实现接口的代理实例)</p> 
<p style="margin-left:0cm;">org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy</p> 
<p style="margin-left:0cm;"><img alt="" height="578" src="https://images2.imgbox.com/b9/a8/xAW63iLa_o.png" width="1030"></p> 
<p style="margin-left:0cm;">CGLIB生成代理实例：</p> 
<p style="margin-left:0cm;">默认的一般的方法被将匹配到AOP_PROXY索引，对应的CallBack为DynamicAdvisedInterceptor，被代理方法调用时将调用到DynamicAdvisedInterceptor.intercept方法org.springframework.aop.framework.CglibAopProxy#getProxy(java.lang.ClassLoader)</p> 
<p><img alt="" height="582" src="https://images2.imgbox.com/3c/aa/zwJy5nEU_o.png" width="999"></p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/19/3b/VGwB1ujV_o.png" width="949"></p> 
<p style="margin-left:0cm;"><strong>JDK</strong><strong>方式生成代理实例：</strong></p> 
<p style="margin-left:0cm;">生成代理实例，被代理方法调用时会调到JdkDynamicAopProxy.invoke方法</p> 
<p style="margin-left:0cm;"><img alt="" height="402" src="https://images2.imgbox.com/df/2f/1rdfYWJe_o.png" width="1053"></p> 
<h2 id="3.%20%E8%A2%AB%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C" style="margin-left:0cm;">3. 被代理方法的执行</h2> 
<p style="margin-left:0cm;">JDK动态代理调用到的代理拦截方法JdkDynamicAopProxy.invoke和CGLIB代理DynamicAdvisedInterceptor.intercept方法实现差不多，都完成了对被代理方法的所有增强Advice调用以及被代理方法的调用，我们以CGLIB代理DynamicAdvisedInterceptor.intercept方法进行分析。</p> 
<h3 id="3.1%20%E8%8E%B7%E5%8F%96%E8%A2%AB%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E5%8C%B9%E9%85%8D%E7%9A%84%E5%A2%9E%E5%BC%BA%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E6%88%90MethodInterceptor" style="margin-left:0cm;">3.1 获取被代理方法匹配的增强统一包装成MethodInterceptor</h3> 
<p style="margin-left:0cm;">获取被代理实例，获取被代理方法匹配的增强</p> 
<p style="margin-left:0cm;">org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor#intercept</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><img alt="" height="639" src="https://images2.imgbox.com/ab/db/WROyBVay_o.png" width="1168"></p> 
<p style="margin-left:0cm;">遍历被代理bean匹配的所有advisor,筛选被调用方法匹配的advisor,获取advisor中对应的增强advice,Befor对应的advice被包装成MethodBeforeAdviceInterceptor类型的MethodInterceptor，AfterReturning对应的增强包装成AfterReturningAdviceInterceptor类型的MethodInterceptor</p> 
<p style="margin-left:0cm;">org.springframework.aop.framework.DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice</p> 
<p style="margin-left:0cm;"><img alt="" height="616" src="https://images2.imgbox.com/7d/a1/63RrhkS8_o.png" width="1175"></p> 
<p style="margin-left:0cm;">org.springframework.aop.framework.adapter.DefaultAdvisorAdapterRegistry#getInterceptors</p> 
<p style="margin-left:0cm;"><img alt="" height="564" src="https://images2.imgbox.com/98/06/ZGzS5npW_o.png" width="1072"></p> 
<h3 id="3.2%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" style="margin-left:0cm;">3.2方法调用</h3> 
<p style="margin-left:0cm;">没有匹配到advice对应的MethodInterceptor直接调用被代理方法</p> 
<p style="margin-left:0cm;"><img alt="" height="606" src="https://images2.imgbox.com/c6/09/KxM2dx5m_o.png" width="932"></p> 
<p style="margin-left:0cm;">被代理方法对应的MethodInterceptor列表不为空时，依次取出被代理方法对应的增强advice,将增强转换为MethodInterceptor类型通过invoke方法进行统一调用,当所有增强MethodInterceptor都调用后执行被代理方法</p> 
<p><img alt="" height="527" src="https://images2.imgbox.com/34/93/smK4ETgi_o.png" width="1002"></p> 
<p>org.springframework.aop.framework.ReflectiveMethodInvocation#proceed</p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/7e/e7/3yGBnL4s_o.png" width="1139"></p> 
<p><img alt="" height="118" src="https://images2.imgbox.com/2c/6f/tua46Gil_o.png" width="855"></p> 
<h4 id="3.2.1%20Before%20%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8" style="margin-left:0cm;">3.2.1 Before 增强的调用</h4> 
<p>        前面讲到Before对应的增强最终会包装成MethodBeforeAdviceInterceptor通过接口方法invoke进行调用。在invoke中会先进行Before修饰的方法调用再将方法调用往后传递回代理方法的调用点。<br> 先调用Before增强方法<br> org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor#invoke</p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/4d/6d/keusOJOC_o.png" width="959"></p> 
<p>通过getBean获取增强方法对应实例再反射调用增强方法，this.aspectInstanceFactory.getAspectInstance()获取到增强方法对应的实例，this.aspectJAdviceMethod是增强方法method，有了方法、方法对应的实例以及参数，就可以通过通过反射进行方法调用org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs</p> 
<p><img alt="" height="575" src="https://images2.imgbox.com/df/8d/UG00kfW1_o.png" width="995"></p> 
<p style="margin-left:0cm;">before增强方法调用后方法调用传递回代理方法调用点ReflectiveMethodInvocation#proceed()</p> 
<p style="margin-left:0cm;"><img alt="" height="509" src="https://images2.imgbox.com/2c/a3/GY9vgtVz_o.png" width="750"></p> 
<h4 id="3.2.2%20After%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8" style="margin-left:0cm;">3.2.2 After增强的调用</h4> 
<p style="margin-left:0cm;">         After增强调用会调用到AspectJAfterAdvice的invoke方法，先将方法调用传递回代理方法调用点ReflectiveMethodInvocation#proceed()然后在finally中进行After增强方法的调用。After增强方法的调用与上面的before方法调用是相同的通过getBean获取增强方法对应的实例再反射进行方法调用。</p> 
<p style="margin-left:0cm;">org.springframework.aop.aspectj.AspectJAfterAdvice#invoke</p> 
<p style="margin-left:0cm;"><img alt="" height="538" src="https://images2.imgbox.com/2d/70/9uLvmbvR_o.png" width="947"></p> 
<h4 id="3.2.3%20Around%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8" style="margin-left:0cm;">3.2.3 Around增强的调用</h4> 
<p>Around增强调用会调用到AspectJAroundAdvice的invoke方法,在invoke方法中只直接调用的Around增强方法，所以在Around方法的前置增强和后置增强之间我们需要自己添加joinPoint.proceed()触发被代理方法的调用。org.springframework.aop.aspectj.AspectJAroundAdvice#invoke</p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/7a/53/f3EzV9Np_o.png" width="1067"></p> 
<p style="margin-left:0cm;">Around增强使用实例</p> 
<p style="margin-left:0cm;"><img alt="" height="403" src="https://images2.imgbox.com/f9/77/LuGfmFGW_o.png" width="1008"></p> 
<h4 id="3.2.4%20AfterReturning%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8" style="margin-left:0cm;">3.2.4 AfterReturning增强的调用</h4> 
<p>AfterReturning增强的调用会调用到AfterReturningAdviceInterceptor的invoke方法，先通过mi.proceed将方法调用传递回代理方法调用点ReflectiveMethodInvocation#proceed()获取到被代理方法的返回值，再执行AfterReturning增强方法。org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor#invoke</p> 
<p><img alt="" height="541" src="https://images2.imgbox.com/06/45/iNdqVd5Q_o.png" width="955"></p> 
<p style="margin-left:0cm;">将被代理方法返回值作为参数传入再通过反射执行AfterReturning增强方法</p> 
<p><img alt="" height="386" src="https://images2.imgbox.com/0b/59/Mb4ydOGR_o.png" width="1061"></p> 
<p style="margin-left:0cm;">AfterReturning增强使用示例</p> 
<pre><code>@AfterReturning(returning = "retObj", pointcut = "myPoint()")
public void afterReturning(Object retObj) throws Throwable {
   System.out.println("return =" + retObj + "---------MyAspect   afterReturning---------------");
}</code></pre> 
<p>在AfterReturning增强方法中我们可以拿到被增强方法的返回值，我们看看是如何实现的。</p> 
<p>在生成AspectJAfterReturningAdvice时将AfterReturning注解中配置的returning值设置到advice中org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory#getAdvice</p> 
<p><img alt="" height="617" src="https://images2.imgbox.com/87/6e/h9uwo2AJ_o.png" width="1120"></p> 
<p><img alt="" height="430" src="https://images2.imgbox.com/49/31/0S8LZlpT_o.png" width="1025"></p> 
<p style="margin-left:0cm;">解析增强方法的参数，将参数名与参数位置索引映射加入advice中的argumentBindings容器</p> 
<p><img alt="" height="667" src="https://images2.imgbox.com/17/31/KiOISP8S_o.png" width="1055"></p> 
<p><img alt="" height="584" src="https://images2.imgbox.com/79/62/V5rlXIqy_o.png" width="1057"></p> 
<p style="margin-left:0cm;">反射调用增强方法前通过argBinding方法进行参数绑定，包括绑定被代理方法返回值和抛出的异常</p> 
<p style="margin-left:0cm;">org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethod(org.aspectj.weaver.tools.JoinPointMatch, java.lang.Object, java.lang.Throwable)</p> 
<p style="margin-left:0cm;"><img alt="" height="569" src="https://images2.imgbox.com/53/a9/IZul1IPP_o.png" width="1071"></p> 
<p style="margin-left:0cm;">获取返回值在增强方法中参数列表中的位置，并进行赋值</p> 
<p style="margin-left:0cm;">org.springframework.aop.aspectj.AbstractAspectJAdvice#argBinding</p> 
<p style="margin-left:0cm;"><img alt="" height="604" src="https://images2.imgbox.com/94/69/L2W5Tf2W_o.png" width="1004"></p> 
<h4 id="3.2.5%20AfterThrowing%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%B0%83%E7%94%A8" style="margin-left:0cm;">3.2.5 AfterThrowing增强的调用</h4> 
<p style="margin-left:0cm;">AfterThrowing增强的调用会调用到AspectJAfterThrowingAdvice的invoke方法，先通过mi.proceed将方法调用传递回代理方法调用点ReflectiveMethodInvocation#proceed(),完成被代理方法的调用，抛出异常后调用AfterThrowing增强方法，将异常异常作为参数传入</p> 
<p style="margin-left:0cm;"><img alt="" height="538" src="https://images2.imgbox.com/9d/9c/Hx5G3fSP_o.png" width="1090"></p> 
<p style="margin-left:0cm;">AfterThrowing增强使用示例</p> 
<pre><code>@AfterThrowing(throwing = "e", pointcut = "myExceptionPoint()")

public void afterThrowing(Exception e) throws Throwable {

   System.out.println("Exception =" + e.getMessage() + "---------MyAspect   afterThrowing---------------");

}</code></pre> 
<p>AfterThrowing增强方法中拿到异常与AfterReturning增强方法中在参数中设置返回值类似，Advice创建时将AfterThrowing注解中配置的throwing值设置到advice中，反射调用AfterThrowing增强方法前获取异常在增强方法参数列表中的位置并进行赋值 </p> 
<p><img alt="" height="528" src="https://images2.imgbox.com/55/db/iMz7aFsI_o.png" width="1079"></p> 
<p><img alt="" height="444" src="https://images2.imgbox.com/e3/42/wOJXApHX_o.png" width="1040"></p> 
<h2 id="4.%20%E4%BA%8B%E5%8A%A1%E5%88%87%E9%9D%A2">4. 事务切面</h2> 
<h3 id="4.1%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81" style="margin-left:0cm;">4.1开启事务支持</h3> 
<p>在spring中通过@EnableTransactionManagement就可以开启事务支持功能，EnableTransactionManagement通过Import导入TransactionManagementConfigurationSelector实现了两个功能：①添加AOP入口bean ②添加事务advisor </p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/62/44/nefnjn3v_o.png" width="761"></p> 
<p><img alt="" height="497" src="https://images2.imgbox.com/57/9f/YGwfyiES_o.png" width="928"></p> 
<h4 id="4.1.1%20%E6%B7%BB%E5%8A%A0AOP%E5%85%A5%E5%8F%A3bean" style="margin-left:0cm;">4.1.1 添加AOP入口bean</h4> 
<p>AutoProxyRegistrar添加AOP入口bean,上面AOP的内容我们分析到需要支持AOP功能就需要将AbstractAdvisorAutoProxyCreator的子类加入spring容器。 </p> 
<p><img alt="" height="382" src="https://images2.imgbox.com/99/24/Oc5ueXcB_o.png" width="1111"></p> 
<p>如果容器中包含AOP入口BeanDefinition比较优先级，如果优先级低则进行替换，AnnotationAwareAspectJAutoProxyCreator的优先级最高，如果容器中没有包含AOP入口BeanDefinition则生成对应的beanDefinition并进行注册org.springframework.aop.config.AopConfigUtils#registerOrEscalateApcAsRequired </p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/78/00/wtGyUm5B_o.png" width="1029"></p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/9d/3c/Im1fX01Z_o.png" width="928"></p> 
<h4 id="4.1.2%20%E6%B7%BB%E5%8A%A0%E4%BA%8B%E5%8A%A1advisor" style="margin-left:0cm;">4.1.2 添加事务advisor</h4> 
<p>通过@Bean方式添加事务advisor BeanFactoryTransactionAttributeSourceAdvisor，设置advice和pointCut org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration#transactionAdvisor </p> 
<p><img alt="" height="569" src="https://images2.imgbox.com/5c/23/etFvyh7Y_o.png" width="1123"></p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/70/8e/ONgI0HEz_o.png" width="1052"></p> 
<h3 id="4.2%20%E4%BA%8B%E5%8A%A1pointCut" style="margin-left:0cm;">4.2 事务pointCut</h3> 
<p style="margin-left:0cm;">前面AOP提到pointCut的功能（1）bean初始化完成后，匹配bean是否需要生成代理；（2）代理bean方法调用时，匹配被代理方法是否需要进行增强。我们看看事务pointCut是如何实现这些功能。</p> 
<p style="margin-left:0cm;">上面讲到pointCut与bean进行匹配时会先进行类匹配再进行方法匹配，类过滤器未匹配上时直接返回false,类过滤器匹配上再进行方法匹配，有一个方法匹配上该advisor即与bean匹配上。事务pointCut <span style="color:#000000;">TransactionAttributeSourcePointcut</span><span style="color:#000000;">的</span><span style="color:#000000;">ClassFilter</span><span style="color:#000000;">为</span><span style="color:#000000;">TransactionAttributeSourceClassFilter</span><span style="color:#000000;">，一般情况</span><span style="color:#000000;">TransactionAttributeSourceClassFilter</span><span style="color:#000000;">与</span><span style="color:#000000;">beanClass</span><span style="color:#000000;">匹配都会匹配返回</span><span style="color:#000000;">true</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">org.springframework.aop.support.AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;, boolean)</span></p> 
<p style="margin-left:0cm;"><img alt="" height="591" src="https://images2.imgbox.com/1e/53/3eVLJq0C_o.png" width="1104"></p> 
<p style="margin-left:0cm;"><img alt="" height="549" src="https://images2.imgbox.com/c6/23/YFEV2rQW_o.png" width="946"></p> 
<p style="margin-left:0cm;">方法匹配，获取事务增强是否与bean方法匹配</p> 
<p style="margin-left:0cm;">org.springframework.transaction.interceptor.TransactionAttributeSourcePointcut#matches</p> 
<p style="margin-left:0cm;"><img alt="" height="368" src="https://images2.imgbox.com/d8/8c/mCyTqvgL_o.png" width="974"></p> 
<p style="margin-left:0cm;">如果bean方法上或者bean类上有Transactional注解,这bean方法与事务advisor匹配，bean也就与事务advisor匹配</p> 
<p style="margin-left:0cm;"><img alt="" height="620" src="https://images2.imgbox.com/8f/82/M3bM6DwJ_o.png" width="1102"></p> 
<h3 id="4.3%E4%BA%8B%E5%8A%A1%E5%A2%9E%E5%BC%BAadvice" style="margin-left:0cm;">4.3事务增强advice</h3> 
<h4 id="4.3.1%20%E5%BA%95%E5%B1%82JDBC%E4%BA%8B%E5%8A%A1" style="margin-left:0cm;">4.3.1 底层JDBC事务</h4> 
<p>事物是针对同一个连接的一组dml操作，这组操作要么都成功，要么都失败。具体JDBC实现的是有有三个点：①关闭连接的自动提交connection.setAutoCommit(false)（不关闭时是默认自动提交，即执行完每条ddl会自动提交）；②一组dml操作执行完手动调用连接提交方法connection.commit()结束事务；③发生异常时手动调用连接回滚方法connection.rollback()结束事务 </p> 
<pre><code>@Component
public class TranditionalTransaction {

    @Value("${jdbc.url.jdbcUrl}")
    private String jdbcUrl;
    @Value("${jdbc.username}")
    private String user;
    @Value("${jdbc.password}")
    private String password;

    /**
     * 传统事务
     */
    public void tranMethodTranditional() {
        final String JDBC_DRIVER = "com.mysql.jdbc.Driver";

        //注册JDBC驱动
        try {
            Class.forName(JDBC_DRIVER);
        } catch (ClassNotFoundException e) {
            //这里会发生类没有找到的异常！
            e.printStackTrace();
        }
        //获得数据库连接
        Connection connection = null;
        Statement statement = null;
        try {
            connection = DriverManager.getConnection(jdbcUrl, user, password);
            connection.setAutoCommit(false);

            //执行查询语句
            statement = connection.createStatement();
            String sql = "INSERT INTO area(name, CODE)\n" +
                    "VALUES(\"BeiJin\", \""+new Date().getTime() +"\")";
            statement.executeUpdate(sql);

            sql = "INSERT INTO area(name, CODE)\n" +
                    "VALUES(\"BeiJing\", \""+new Date().getTime() +"\")";
            statement.executeUpdate(sql);

            connection.commit();


        } catch (SQLException e) {
            e.printStackTrace();
            try {
                connection.rollback();
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
        }finally {
            if (null != statement){
                try {
                    statement.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if (null != connection){
                try {
                    connection.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre> 
<h4 id="4.3.2%20%E5%B8%B8%E7%94%A8%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7" style="margin-left:0cm;">4.3.2 常用事务传播属性</h4> 
<p style="margin-left:0cm;">事务传播属性是用来区分程序中事务方法嵌套调用时被嵌套方法使用事务的不同形式，常用的事务传播属性REQUIRED、REQUIRES_NEW、NESTED。</p> 
<p style="margin-left:0cm;">以A方法调用B方法为例：</p> 
<p style="margin-left:0cm;">①如果A方法没有开启事务，B方法不管是REQUIRED、REQUIRES_NEW、NESTED效果都是一样的，在B方法开始前会拿到一个连接开启事务，在B方法结束时会进行事务的提交或者事务的回滚；</p> 
<p style="margin-left:0cm;">②如果A方法开启了事务REQUIRED、REQUIRES_NEW、NESTED的表现是不同的：</p> 
<p style="margin-left:0cm;">REQUIRED：B方法与A方法使用同一个连接，B方法加入A方法连接的事务中，未指定时默认为REQUIRED；</p> 
<p style="margin-left:0cm;">REQUIRES_NEW：B方法开始前会拿到一个连接开启事务，在B方法结束时会进行事务的提交或者事务的回滚；</p> 
<p style="margin-left:0cm;">NESTED：B方法与A方法使用同一个连接，B方法开始前会创建一个回滚点，如果B方法正常执行结束将该回滚点移除，如果B方法执行异常则回滚到该回滚点。</p> 
<p style="margin-left:0cm;"> </p> 
<h4 id="4.3.3%20%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90" style="margin-left:0cm;">4.3.3 事务代码分析</h4> 
<p style="margin-left:0cm;">事务方法调用的时候会进入TransactionInterceptor的invoke方法。</p> 
<p style="margin-left:0cm;">以事务的方式进行被代理方法调用</p> 
<p style="margin-left:0cm;"><img alt="" height="482" src="https://images2.imgbox.com/05/cc/2rR9glWX_o.png" width="1110"></p> 
<p><strong>4.3.3.1 单个事务方法的执行</strong></p> 
<p style="margin-left:0cm;">首先我们来分析最简单的情况不存在事务方法嵌套调用的，单个事务方法的执行</p> 
<p style="margin-left:0cm;">调用AnnotationTransactionAttributeSource的getTransactionAttribute方法，获取被代理方法或者被代理方法所属类上是否有Transactional注解，封装得到TransactionAttribute对象</p> 
<p style="margin-left:0cm;"><img alt="" height="460" src="https://images2.imgbox.com/fd/40/n6pIUjbW_o.png" width="1151"></p> 
<p style="margin-left:0cm;">获取连接开启事务</p> 
<p style="margin-left:0cm;"><img alt="" height="444" src="https://images2.imgbox.com/34/c8/KBVKGdQu_o.png" width="1069"></p> 
<p style="margin-left:0cm;">首次进入创建事务状态，是否新事务标识为true，获取新连接，关闭连接自动提交，根据dataSource将连接将连接缓存到threadLocal类型的map中</p> 
<p style="margin-left:0cm;">org.springframework.jdbc.datasource.DataSourceTransactionManager#doBegin</p> 
<p style="margin-left:0cm;"><img alt="" height="549" src="https://images2.imgbox.com/3d/46/31cX0iKS_o.png" width="1200"></p> 
<p style="margin-left:0cm;"><img alt="" height="643" src="https://images2.imgbox.com/21/58/xUVMdybC_o.png" width="1146"></p> 
<p style="margin-left:0cm;"><img alt="" height="366" src="https://images2.imgbox.com/fd/5e/3reHL8TB_o.png" width="1066"></p> 
<p style="margin-left:0cm;"><img alt="" height="528" src="https://images2.imgbox.com/ad/09/xMNjAufM_o.png" width="1114"></p> 
<p style="margin-left:0cm;">执行被代理方法</p> 
<p style="margin-left:0cm;"><img alt="" height="509" src="https://images2.imgbox.com/32/60/vYo9RUdM_o.png" width="1082"></p> 
<p style="margin-left:0cm;"><strong>如果被代理方法执行时抛出异常，则调用连接的rollback</strong><strong>进行事务回滚</strong></p> 
<p style="margin-left:0cm;"><img alt="" height="501" src="https://images2.imgbox.com/3f/8c/jywkI1Hu_o.png" width="1022"></p> 
<p style="margin-left:0cm;">新连接调用连接的rollback方法进行回滚</p> 
<p style="margin-left:0cm;">org.springframework.transaction.support.AbstractPlatformTransactionManager#processRollback</p> 
<p style="margin-left:0cm;"><img alt="" height="587" src="https://images2.imgbox.com/c7/3c/TNLGLENn_o.png" width="980"></p> 
<p style="margin-left:0cm;"><img alt="" height="489" src="https://images2.imgbox.com/99/39/0S1ATpKu_o.png" width="1146"></p> 
<p style="margin-left:0cm;">回滚后，清除threadLocal类型map中缓存的dataSource与连接的映射关系，释放连接</p> 
<p style="margin-left:0cm;">org.springframework.transaction.support.AbstractPlatformTransactionManager#processRollback</p> 
<p style="margin-left:0cm;"><img alt="" height="392" src="https://images2.imgbox.com/6c/4e/Y2c37UFk_o.png" width="1026"></p> 
<p style="margin-left:0cm;"><img alt="" height="627" src="https://images2.imgbox.com/ec/46/ZnYv1WoD_o.png" width="1041"></p> 
<p style="margin-left:0cm;"><img alt="" height="567" src="https://images2.imgbox.com/b8/c8/XUJrfd4M_o.png" width="1042"></p> 
<p style="margin-left:0cm;">如果为新连接则调用close关闭连接，如果使用的是连接池数据源将连接还回连接池可再次进行复用</p> 
<p style="margin-left:0cm;">org.springframework.jdbc.datasource.DataSourceTransactionManager#doCleanupAfterCompletion</p> 
<p style="margin-left:0cm;"><img alt="" height="430" src="https://images2.imgbox.com/86/a9/nSeSe50v_o.png" width="930"></p> 
<p style="margin-left:0cm;"><strong>被代理方法正常执行完，如果是新事务调用连接的commit</strong><strong>方法进行事务提交</strong></p> 
<p style="margin-left:0cm;"><img alt="" height="440" src="https://images2.imgbox.com/95/f1/l0IZMEio_o.png" width="881"></p> 
<p style="margin-left:0cm;"><img alt="" height="635" src="https://images2.imgbox.com/9c/33/2WGWQB6q_o.png" width="1022"></p> 
<p style="margin-left:0cm;">调用连接的commit方法提交事务</p> 
<p style="margin-left:0cm;">org.springframework.jdbc.datasource.DataSourceTransactionManager#doCommit</p> 
<p style="margin-left:0cm;"><img alt="" height="454" src="https://images2.imgbox.com/e0/4b/jWkXyRLy_o.png" width="1144"></p> 
<p style="margin-left:0cm;">提交之后和同上面rollback一样事务执行完了会进行threadLocal类型map中DataSource缓存连接清除和连接释放</p> 
<p style="margin-left:0cm;"><img alt="" height="479" src="https://images2.imgbox.com/fc/46/wTQyD6Dz_o.png" width="1099"></p> 
<p style="margin-left:0cm;">总结下单个事务方法的伪代码执行框架如下：</p> 
<pre><code>Connection con = obtainDataSource().getConnection();
con.setAutoCommit(false);
try{
   业务代码...
}catch(Throwable ex){
   con.rollback();
   throw ex;
}
con.commit();
</code></pre> 
<p><strong>4.3.3.2 事务方法嵌套调用</strong></p> 
<p style="margin-left:0cm;">被嵌套的事务方法再次执行时从threadLocal类型的map中拿到dataSource对应的缓存连接</p> 
<p style="margin-left:0cm;">org.springframework.jdbc.datasource.DataSourceTransactionManager#doGetTransaction</p> 
<p style="margin-left:0cm;"><img alt="" height="480" src="https://images2.imgbox.com/c8/60/2d5JcTdG_o.png" width="1049"></p> 
<p style="margin-left:0cm;"><img alt="" height="527" src="https://images2.imgbox.com/7f/ef/wZkESyQk_o.png" width="1193"></p> 
<p style="margin-left:0cm;">被嵌套方法调用时事务对象中已存在连接</p> 
<p style="margin-left:0cm;"><img alt="" height="506" src="https://images2.imgbox.com/a7/a2/HZZnZq6y_o.png" width="1164"></p> 
<p style="margin-left:0cm;"><strong>被嵌套的事务方法传播属性为REQUIRED</strong></p> 
<p style="margin-left:0cm;">被嵌套的事务方法调用前，获取到的事务状态newTransaction为false</p> 
<p style="margin-left:0cm;"><img alt="" height="479" src="https://images2.imgbox.com/ea/41/4IGXMzPP_o.png" width="1165"></p> 
<p style="margin-left:0cm;">被嵌套的事务方法执行发生异常，将异常抛出<strong><span style="color:#000080;">throw </span></strong><span style="color:#000000;">ex</span><span style="color:#000000;">外层事务捕获到异常，同上面</span><span style="color:#000000;">4.3.3.1</span><span style="color:#000000;">中单个事务方法的执行发生异常将进行事务回滚</span>清除threadLocal类型map中缓存的dataSource与连接的映射关系，释放连接。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>被嵌套的事务方法传播属性为REQUIRES_NEW</strong></p> 
<p style="margin-left:0cm;">被嵌套的事务方法调用前，先挂起外层事务（获取外层事务连接，移除之前外层事务设置到threadLocal类型map中dataSource与连接的映射缓存）</p> 
<p style="margin-left:0cm;">org.springframework.transaction.support.AbstractPlatformTransactionManager#handleExistingTransaction</p> 
<p style="margin-left:0cm;"><img alt="" height="514" src="https://images2.imgbox.com/9d/a0/6IUMvxYZ_o.png" width="1200"></p> 
<p>创建事务状态newSynchronization标识设置为true，获取新连接，取消自动提交，这时候被嵌套的事务方法就同上面4.3.3.1当个事务方法的一样方法执行发生异常时调用连接的rollback进行回滚，正常执行完成后调用连接的commit进行事务提交，另外在回滚和提交的finally中的cleanupAfterCompletion方法中多了一步恢复之前挂起的外层事务的操作。恢复之前挂起的外层事务，将外层事务的连接与dataSource的映射关系重新设置到ThreadLocal类型的map中。 </p> 
<p>org.springframework.transaction.support.AbstractPlatformTransactionManager#cleanupAfterCompletion </p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/e1/ff/sODpfErs_o.png" width="1068"></p> 
<p>org.springframework.jdbc.datasource.DataSourceTransactionManager#doResume </p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/4f/4e/qgN0WQ1E_o.png" width="1092"></p> 
<p style="margin-left:0cm;"><strong>被嵌套事务方法传播属性为NESTED</strong></p> 
<p>被嵌套事务方法调用前创建事务状态对象DefaultTransactionStatus设置newTransaction标识为false, 创建回滚点org.springframework.transaction.support.AbstractPlatformTransactionManager#handleExistingTransaction </p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/26/ce/XUTWxCvu_o.png" width="1200"></p> 
<p><img alt="" height="563" src="https://images2.imgbox.com/44/78/ZdAvYxwz_o.png" width="1082"></p> 
<p><img alt="" height="381" src="https://images2.imgbox.com/72/8d/jBwCdTni_o.png" width="1195"></p> 
<p>被嵌套方法执行发生异常时，回滚到回滚点，然后往外抛异常 </p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/2c/9d/T69fYDeW_o.png" width="890"></p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/d9/1d/OjWisyUg_o.png" width="870"></p> 
<p>如果被嵌套方法正常执行完，则移除回滚点org.springframework.transaction.support.AbstractPlatformTransactionManager#processCommit </p> 
<p><img alt="" height="647" src="https://images2.imgbox.com/47/8c/0Rc1NCyQ_o.png" width="1038"></p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/9e/a3/5k2luOAK_o.png" width="1040"></p> 
<p style="margin-left:0cm;">到这里我们就完成了事务主要源码的分析</p> 
<h2 id="5.%20%E5%BC%82%E6%AD%A5%E5%88%87%E9%9D%A2" style="margin-left:0cm;">5. 异步切面</h2> 
<h3 id="5.1%E5%BC%80%E5%90%AF%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81" style="margin-left:0cm;">5.1开启异步支持</h3> 
<p>通过@EnableAsync就可以开启异步切面支持功能，EnableAsync通过@Import最终把AsyncAnnotationBeanPostProcessor加入了spring容器，异步切面的功能主要是通过AsyncAnnotationBeanPostProcessor支持的 </p> 
<p><img alt="" height="347" src="https://images2.imgbox.com/5f/d7/CcricKV9_o.png" width="656"></p> 
<h3 id="5.2%20%E5%BC%82%E6%AD%A5advisor" style="margin-left:0cm;">5.2 异步advisor</h3> 
<p>AsyncAnnotationBeanPostProcessor实现了BeanFactoryAware接口在setBeanFactory方法中创建了异步advisor </p> 
<p><img alt="" height="393" src="https://images2.imgbox.com/f3/95/yGbC0YlI_o.png" width="1040"></p> 
<h4 id="5.2.1%20%E5%BC%82%E6%AD%A5pointCut" style="margin-left:0cm;">5.2.1 异步pointCut</h4> 
<p style="margin-left:0cm;">         匹配有Async注解的类和方法，如果类上有Async注解则类的所有实例方法都会被异步切面拦截进行增强，如果只是某个实例方法上有Async注解则该方法会被异步切面拦截进行增强。</p> 
<p style="margin-left:0cm;"><img alt="" height="537" src="https://images2.imgbox.com/d1/79/8AIhUw3E_o.png" width="1005"></p> 
<h4 id="5.2.2%20%E5%BC%82%E6%AD%A5advice" style="margin-left:0cm;">5.2.2 异步advice</h4> 
<p>异步的增强为AnnotationAsyncExecutionInterceptor，当被代理的异步方法执行时会调到AnnotationAsyncExecutionInterceptor的invoke方法进行增强。<br> org.springframework.scheduling.annotation.AsyncAnnotationAdvisor#buildAdvice </p> 
<p><img alt="" height="370" src="https://images2.imgbox.com/77/76/3b82KCVm_o.png" width="1116"></p> 
<p style="margin-left:0cm;">被代理方法会被提交到包装有线程池的任务执行器中异步执行</p> 
<p style="margin-left:0cm;">org.springframework.aop.interceptor.AsyncExecutionAspectSupport#doSubmit</p> 
<p style="margin-left:0cm;"><img alt="" height="548" src="https://images2.imgbox.com/24/56/bA44giBS_o.png" width="960"></p> 
<h4 id="5.2.3%20bean%E6%B7%BB%E5%8A%A0%E5%BC%82%E6%AD%A5advisor" style="margin-left:0cm;">5.2.3 bean添加异步advisor</h4> 
<p>EnableAsync注解没有加入aop的入口类也没有将异步advisor作为bean加入spring容器，那么异步advisor是怎么作用到需要增强的bean上的呢？我们分析下。首先抛出一个结论AnnotationAwareAspectJAutoProxyCreator的优先级高于AsyncAnnotationBeanPostProcessor的优先级。<br> AnnotationAwareAspectJAutoProxyCreator的优先级Ordered.HIGHEST_PRECEDENCE </p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/f8/6d/jImTTl44_o.png" width="1079"></p> 
<p><span style="color:#000000;">AsyncAnnotationBeanPostProcessor</span><span style="color:#000000;">的优先级为</span><span style="color:#000000;">Ordered.</span><strong><em><span style="color:#660e7a;">LOWEST_PRECEDENCE</span></em></strong></p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/7d/13/iJ1Z3mo2_o.png" width="902"></p> 
<p>即bean初始化完成后循环调用BeanPostProcessor#postProcessAfterInitialization如果同时存在AnnotationAwareAspectJAutoProxyCreator和AsyncAnnotationBeanPostProcessor会先执行AnnotationAwareAspectJAutoProxyCreator.postProcessAfterInitialization。如果一个bean有被Aspect切面拦截到会先生成代理再执行AsyncAnnotationBeanPostProcessor的postProcessAfterInitialization方法。</p> 
<p>org.springframework.aop.framework.AbstractAdvisingBeanPostProcessor#postProcessAfterInitialization<br> 如果bean已经生成了AOP代理且bean类或方法上有Async注解，则将异步advisor加入被代理bean的advisor列表中。</p> 
<p> </p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/b2/dd/dtJHdtYm_o.png" width="1176"></p> 
<p>如果bean没有生成AOP代理，创建AOP代理实例，代理中包含异步advisor </p> 
<p><img alt="" height="536" src="https://images2.imgbox.com/7f/7a/RnpzbCyz_o.png" width="1061"></p> 
<p> </p> 
<p> </p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c04f22165efbb3b2db868094b27a2468/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">整理了iava新日期LocalDateTime系列类型在springweb中类型转换的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8bb96c566794c0c7966eefaab47fe7d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于映射的一些理解与常见命题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>