<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux内核】Linux内核介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux内核】Linux内核介绍" />
<meta property="og:description" content="Linux学习内核思路 学习过程：
Linux内核引导及如何初始化进程管理、内存管理 内核引导及过程：
CPU通电后，首先执行引导程序，引导程序把内核加载到**内存，**然后执行内核，内核初始化完成后，启动用户空间的进程。CPU通电后，自动把程序计数器设置为CPU厂商设计的某个固定值。嵌入式设备通常用NOR闪存作为只读存储器存放引导程序。
嵌入式设备通常使用U-Boot作为引导程序。
函数_main ENTRY(_main)–&gt;U-&gt;boot程序初始化完成之后，准备处理命令是通过数组init_sequence_r，最后一个函数run_main_loop()实现。
kernel_entry()–&gt;start_kernel()ARM架构下SMP系统自旋表引导过程？（内核技术面试） 引导处理器启动从处理器方法3种：
a. 自旋表
b. 电源状态协调接口
c. ACPI停车协议
用户空间和内核空间：
系统调用：
进程：
内存：
文件系统：
网络：
Linux内核源码 Linux内核版本介绍 linux版本分为两类：
内核版本：免费的，它只是操作系统的核心，负责控制硬件、管理文件系统、程序进程等，并不给用户提供各种工具和应用软件；发行版本：不一定免费，出了操作系统核心外，还包含一套强大的软件，例如：C／C&#43;&#43;编译器和库等 内核版本 1.1）内核版本命名：
Linux内核版本号由3组数字组成：第一个组数字.第二组数字.第三组数字
第一个组数字：目前发布的内核主版本。第二个组数字：偶数表示稳定版本；奇数表示开发中版本。第三个组数字：错误修补的次数。 可以使用uname -r 查看内核版本号，例如：2.6.32-754.2.1.el6.x86_64
第一个组数字: 2 , 主版本号第二个组数字: 6 , 次版本号，表示稳定版本(因为有偶数)第三个组数字: 32 , 修订版本号 ，表示修改的次数。第四个组数字: 754.2.1，表示发型版本的补丁版本，这里是 CentOS 6.10 。el6 则表示我正在使用的内核是 RedHat / CentOS 系列发行版专用内核；x86_64 表示64位cpu。 除了前面的版本号外，最后的有多种，例如：2.6.32-358.6.1.el6.i686、2.6.18-128.ELsmp、2.6.32-642.el6.x86_64
EL : Enterprise Linux ；ELsmp：指出了当前内核是为EL特别调校的，其中smp : 表示支持多处理器 ， 表示该内核版本支持多处理器；i386：几乎任何的X86平台，不论是旧的pentum或是新的pentum-IV和K7系统CPU，都能够正常工作，i指得是Intel兼容的CPU，至于386就是CPU的等级；i586：就是586等级的电脑，包括pentum第一代MMX CPU，AMD的K5，K6系统CPU（socket7插脚）等CPU都是这个等级；i686：pentum 2 以后的Intel系统CPU及K7以后等级的CPU都属于这个686等级；x86_64：采用的是64位的CPU；generic：当前内核版本为通用版本，另有表示不同含义的server（针对服务器）；pae（Physical Address Extension）：物理地址扩展，为了弥补32位地址在PC服务器应用上的不足而推出，表示此32位系统可以支持超过4G的内存 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/aedc30bb8492d9a4ae8b2634da924863/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-04T23:10:11+08:00" />
<meta property="article:modified_time" content="2022-12-04T23:10:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux内核】Linux内核介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Linux_0"></a>Linux学习内核思路</h2> 
<p><strong>学习过程：</strong></p> 
<ol><li>Linux内核引导及如何初始化</li><li>进程管理、内存管理</li></ol> 
<p><strong>内核引导及过程：</strong><br>CPU通电后，首先执行<strong>引导程序</strong>，引导程序把<strong>内核</strong>加载到**内存，**然后执行内核，内核初始化完成后，启动用户空间的进程。CPU通电后，自动把程序计数器设置为CPU厂商设计的某个固定值。嵌入式设备通常用NOR闪存作为只读存储器存放引导程序。<br>嵌入式设备通常使用U-Boot作为引导程序。</p> 
<ol><li>函数_main</li></ol> 
<p>ENTRY(_main)–&gt;U-&gt;boot程序初始化完成之后，准备处理命令是通过数组init_sequence_r，最后一个函数run_main_loop()实现。</p> 
<ol start="2"><li>kernel_entry()–&gt;start_kernel()</li><li>ARM架构下SMP系统自旋表引导过程？（内核技术面试）</li></ol> 
<p>引导处理器启动从处理器方法3种：<br>a. 自旋表<br>b. 电源状态协调接口<br>c. ACPI停车协议</p> 
<p><strong>用户空间和内核空间：</strong><br><img src="https://images2.imgbox.com/92/6a/VK0wlNip_o.png" alt="image.png"><br><strong>系统调用：</strong><br><img src="https://images2.imgbox.com/e2/b0/Q5uo5T3f_o.png" alt="image.png"><br><strong>进程：</strong><br><img src="https://images2.imgbox.com/e7/b9/X6YWdNpP_o.png" alt="image.png"><br><strong>内存：</strong><br><img src="https://images2.imgbox.com/58/78/Vmj0Vhmv_o.png" alt="image.png"><br><strong>文件系统：</strong><br><img src="https://images2.imgbox.com/15/fa/mNc1HbA2_o.png" alt="image.png"><br><strong>网络：</strong><br><img src="https://images2.imgbox.com/77/7a/HboulzrM_o.png" alt="image.png"></p> 
<h2><a id="Linux_18"></a>Linux内核源码</h2> 
<h3><a id="Linux_19"></a>Linux内核版本介绍</h3> 
<p>linux版本分为两类：</p> 
<ul><li>内核版本：免费的，它只是操作系统的核心，负责控制硬件、管理文件系统、程序进程等，并不给用户提供各种工具和应用软件；</li><li>发行版本：不一定免费，出了操作系统核心外，还包含一套强大的软件，例如：C／C++编译器和库等</li></ul> 
<h4><a id="_24"></a>内核版本</h4> 
<p>1.1）内核版本命名：<br>Linux内核版本号由3组数字组成：第一个组数字.第二组数字.第三组数字</p> 
<ul><li>第一个组数字：目前发布的内核主版本。</li><li>第二个组数字：偶数表示稳定版本；奇数表示开发中版本。</li><li>第三个组数字：错误修补的次数。</li></ul> 
<p>可以使用uname -r 查看内核版本号，例如：2.6.32-754.2.1.el6.x86_64</p> 
<ul><li>第一个组数字: 2 , 主版本号</li><li>第二个组数字: 6 , 次版本号，表示稳定版本(因为有偶数)</li><li>第三个组数字: 32 , 修订版本号 ，表示修改的次数。</li><li>第四个组数字: 754.2.1，表示发型版本的补丁版本，这里是 CentOS 6.10 。</li><li>el6 则表示我正在使用的内核是 RedHat / CentOS 系列发行版专用内核；x86_64 表示64位cpu。</li></ul> 
<p>除了前面的版本号外，最后的有多种，例如：2.6.32-358.6.1.el6.i686、2.6.18-128.ELsmp、2.6.32-642.el6.x86_64</p> 
<ul><li>EL : Enterprise Linux ；</li><li>ELsmp：指出了当前内核是为EL特别调校的，其中smp : 表示支持多处理器 ， 表示该内核版本支持多处理器；</li><li>i386：几乎任何的X86平台，不论是旧的pentum或是新的pentum-IV和K7系统CPU，都能够正常工作，i指得是Intel兼容的CPU，至于386就是CPU的等级；</li><li>i586：就是586等级的电脑，包括pentum第一代MMX CPU，AMD的K5，K6系统CPU（socket7插脚）等CPU都是这个等级；</li><li>i686：pentum 2 以后的Intel系统CPU及K7以后等级的CPU都属于这个686等级；</li><li>x86_64：采用的是64位的CPU；</li><li>generic：当前内核版本为通用版本，另有表示不同含义的server（针对服务器）；</li><li>pae（Physical Address Extension）：物理地址扩展，为了弥补32位地址在PC服务器应用上的不足而推出，表示此32位系统可以支持超过4G的内存</li></ul> 
<p>1.2）内核版本历史：<br><img src="https://images2.imgbox.com/94/c8/uLODvJbx_o.png" alt="image.png"><br>linux内核大致分为以下几个阶段：</p> 
<ul><li>2.6.0之前版本：</li><li>2.6.x版本：2.6 时代跨度非常大，从2.6.0 (2003年12月发布[36]) 到 2.6.39(2011年5月发布), 跨越了 40 个大版本；</li><li>3.x.y：3.0(原计划的 2.6.40, 2011年7月发布) 到 3.19（2015年2月发布）</li><li>4.x.y：4.0（2015年4月发布）到4.2（2015年8月底发布）</li><li>5.x.y：</li></ul> 
<p>截止到2021年，很多线上系统仍然使用2.6.x的内核。Linux2.6版本内核发布，与2.4内核版本相比，它在很多方面进行了改进，如支持多处理器配置和64位计算，它还支持实现高效率线和处理的本机POSIX 线程库(NPTL)。实际上，性能、安全性和驱动程序的改进是整个2.6.x 内核的关键。<br><a href="https://en.wikipedia.org/wiki/Linux_kernel_version_history#Releases_before_2.6.0" rel="nofollow">https://en.wikipedia.org/wiki/Linux_kernel_version_history#Releases_before_2.6.0</a></p> 
<h4><a id="_59"></a>发行版本</h4> 
<p>人们以Linux核心为中心，再集成搭配各种各样的系统管理软件或应用工具软件组成一套完整的操作系统，如此的组合便称为Linux发行版。<br>Linux的发行版本可以大体分为两类：</p> 
<ul><li>一类是商业公司维护的发行版本：以著名的Redhat（REHL）为代表；</li><li>一类是社区组织维护的发行版本：以Debian为代表；</li></ul> 
<p>1）Redhat（小红帽），应该称为Redhat系列，包括RHEL(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费版本)、Fedora Core(由原来的Redhat桌面版本发展而来，免费版本)、CentOS(RHEL的社区克隆版本，免费)。Redhat应该说是在国内使用人群最多 的Linux版本，甚至有人将Redhat等同于Linux，而有些老鸟更是只用这一个版本的Linux。所以这个版本的特点就是使用人群数量大，资料非常多，言下之意就是如果你有什么不明白的地方，很容易找到人来问，而且网上的一般Linux教程都是以Redhat为例来讲解的。Redhat系列的包管理方式采用的是基于RPM包的YUM包管理方式，包分发方式是编译好的二进制文件。稳定性方面RHEL和CentOS的稳定性非常好，适合于服务器使用， 但是Fedora Core的稳定性较差，最好只用于桌面应用。<br>2）Debian，或者称Debian系列，包括Debian和Ubuntu等。Debian是社区类Linux的典范，是迄今为止最遵循GNU规范 的Linux系统。Debian最早由Ian Murdock于1993年创建，分为三个版本分支（branch）： stable, testing 和 unstable。其中，unstable为最新的测试版本，其中包括最新的软件包，但是也有相对较多的bug，适合桌面用户。testing的版本都经 过unstable中的测试，相对较为稳定，也支持了不少新技术（比如SMP等）。而stable一般只用于服务器，上面的软件包大部分都比较过时，但是 稳定和安全性都非常的高。Debian最具特色的是apt-get / dpkg包管理方式，其实Redhat的YUM也是在模仿Debian的APT方式，但在二进制文件发行方式中，APT应该是最好的了。Debian的资 料也很丰富，有很多支持的社区，有问题求教也有地方可去:)<br>3）Ubuntu严格来说不能算一个独立的发行版本，Ubuntu是基于Debian的unstable版本加强而来，可以这么说，Ubuntu就是 一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。根据选择的桌面系统不同，有三个版本可供选择，基于Gnome的Ubuntu，基于KDE的Kubuntu以及基于Xfc的 Xubuntu。特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。<br><img src="https://images2.imgbox.com/5e/09/KcZ6vZ7C_o.png" alt="image.png"></p> 
<h4><a id="POSIX_66"></a>POSIX标准</h4> 
<p>POSIX：可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行的软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。<br>此标准源于一个大约开始于1985年的项目，POSIX这个名称是由理查德•斯托曼应IEEE的要求而提议的一个易于记忆的名称。<br>这个标准并不是一个强制性或者大家都在使用的标准：</p> 
<ul><li>Linux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证</li><li>微软的Windows NT声称部分实现了POSIX标准。</li></ul> 
<p>linux和posix的关系：<br>linux一些函数的功能与posix标准的一些函数（接口）功能相同，只是签名不同，你可以认为只是改了个名字。如果你使用posix标准的函数，那么你为其它可以使用posix标准的系统写代码，就不用重新修改原来的函数签名，而只需要重新编译（因为实现的代码是不同的）一遍就行了。</p> 
<h4><a id="GNULinux_73"></a>GNU和Linux的关系</h4> 
<p>UNIX操作系统最初是由贝尔实验室开发的，当时的贝尔实验室是电信业巨头AT&amp;T（美国电报电话公司）旗下的一员。在20世纪70年代，unix成为一种非常流行的多用户、多任务操作系统。Unix 系统被发明之后，大家用的很爽，但是后来开始收费和商业闭源了。。。<br>理查德 · 斯托曼 在 1983年发起GNU计划，其目标是建立完全自由的操作系统GNU，取代Unix。在1985年创建自由软件基金会（FSF），在1989年发布GPL许可协议保护和传播由FSF发布的自由软件。自由软件是权利问题，不是价格问题。要理解这个概念，你应该考虑“free”是“言论自由（free speech）”中的“自由”；而不是“免费啤酒（free beer）”中的“免费”。<br>GNU（“GNU’s Not Unix”的递归首字母缩写词）是一个<strong>类Unix操作系统</strong>，它是由多个应用程序、系统库、开发工具乃至游戏构成的程序集合。GNU的开发始于1984年1月，称为GNU工程，GNU的许多程序在GNU工程下发布，我们称之为<strong>GNU软件包</strong>。主要由：</p> 
<ul><li>GCC：GNU编译器集，它包括GNU C编译器。</li><li>G++：C++编译器，是GCC的一部分。</li><li>GDB：源代码级的调试器。</li><li>GNU make：UNIX make命令的免费版本。</li><li>Bison：与UNIX yacc兼容的语法分析程序生成器。</li><li>bash：命令解释器（shell）。</li><li>GNU Emacs：文本编辑器及环境。</li></ul> 
<p>许多其他的软件包也是在遵守自由软件的原则和GPL条款的情况下开发和发行的，包括电子表格、源代码控制工具、编译器和解释器、因特网工具、图形图像处理工具（如Gimp），以及两个完整的基于对象的环境（GNOME和KDE）。有了这么多可用的自由软件，再加上Linux内核，我们可以说：创建一个GNU的、自由的类UNIX系统的目标已经实现了。（GNU早起也有自己的内核，后面选用了Linux）<br>众所周知，一个完整的通用操作系统至少需要内核、编译套件、shell以及主要应用软件。GUN最初的内核组件Hurd开发于1990年（早于linux），但设计过于复杂进展缓慢。正巧，1991年10月林纳斯·托瓦兹（Linus Torvalds）发布了他的玩具内核源代码，这是他在学习Minix操作系统源码的过程中耗时六个月，用C写出来的POSIX不完整兼容的内核，并将GNU的基础软件Gcc和Bash成功的移植到了上面，这之后大量用户参与开发，并在1994年使用GPL协议发布了Linux 1.0内核。<br>从此，GNU计划和Linux天衣无缝的、互相弥补的就结合在了一起，成为了完全自由并且完整的操作系统——GNU/Linux。RedHat等以GNU/Linux作为产业的大厂随即出现，大力发展了GNU/Linux，使其变得越来越实用，逐渐取代了Unix操作系统的位置。</p> 
<h3><a id="Linux412_85"></a>Linux-4.12内核源码目录</h3> 
<p><img src="https://images2.imgbox.com/00/e0/Rz48QGsk_o.png" alt="image.png"></p> 
<table><thead><tr><th><strong>目录</strong></th><th><strong>开发关注度</strong></th><th><strong>描述</strong></th><th><strong>存放功能</strong></th></tr></thead><tbody><tr><td>arch</td><td>5⭐</td><td>即architecture,意为架构的意思, 常见的一些架构有mips、x86、arm。 适配一款芯片的linux内核，首先需要知道芯片属于什么架构</td><td>dts、内存管理，系统调用，动态调频，主频率设置、库文件等</td></tr><tr><td>block</td><td>4⭐</td><td>block，意为块，与块设备相关的功能，如SD卡、iNand、Nand、硬盘等块设备相关的操作</td><td>块设备相关代码</td></tr><tr><td>certs</td><td></td><td>即certificates，意为签名认证，与签名认证相关功能</td><td>认证签名相关代码</td></tr><tr><td>crypto</td><td>4⭐</td><td>可以记为encryption，与压缩加密相关的功能，如md5、sha1、 hash等</td><td>各类加密算法相关的功能代码</td></tr><tr><td>Documentation</td><td>5⭐</td><td>linux内核各类机制相关的文档，全英文，可以查阅各类机制的实现说明</td><td>官方文档</td></tr><tr><td>drivers</td><td>5⭐</td><td>即驱动，linux的驱动代码， 如GPIO、网络、usb、蓝牙等驱动源码，一般做开发都需要修改或添加该目录下的文件</td><td>驱动源码相关</td></tr><tr><td>frimware</td><td>3⭐</td><td>存放一些固件代码(.bin)</td><td></td></tr><tr><td>fs</td><td>4⭐</td><td>即files system， linux的文件系统， 如ext2-4、jffs2、nfs、squashfs、ramfs、romfs等文件系统的实现代码</td><td>文件系统相关源码</td></tr><tr><td>include</td><td>5⭐</td><td>linux库文件的头文件，如fs.h、mdio.h、mm.h等， include/linux存放与平台无关的功能的头文件</td><td>linux内核功能相关的头文件</td></tr><tr><td>init</td><td>5⭐</td><td>即initialization ，初始化相关源码，main.c也在其中</td><td>linux初始化相关</td></tr><tr><td>ipc</td><td>4⭐</td><td>即Inter-Process Communication，进程间通信， 如共享内存、信号量、消息队列等</td><td>进程间通信相关代码</td></tr><tr><td>kernel</td><td>5⭐</td><td>即内核，linux内核相关的功能实现源码，如panic、pid、module、irq、cpu相关</td><td>内核功能源码</td></tr><tr><td>lib</td><td>4⭐</td><td>即library， 实现一些库功能，如decompress、crc32、atomic等</td><td>库功能实现源码</td></tr><tr><td>mm</td><td>5⭐</td><td>即memory management，内存管理相关功能实现 ，mmap、page、mempool等</td><td>内存管理相关源码</td></tr><tr><td>net</td><td>5⭐</td><td>network， 网络功能相关的源码，如tcp/ip、dns、ipv4/v6、802.11、ethernet等</td><td>网络协议功能</td></tr><tr><td>samples</td><td>3⭐</td><td>一些linux功能代码使用的标准实例 示例参考代码</td><td></td></tr><tr><td>scripts</td><td>3⭐</td><td>与内核无关的脚本代码，如内核编译相关、menuconfig相关</td><td>内核无关的脚本</td></tr><tr><td>security</td><td>2⭐</td><td>SELinux的模块。安全相关</td><td>安全相关代码，具体未知</td></tr><tr><td>sound</td><td>3⭐</td><td>声卡与声音驱动相关代码，包含i2c、spi、usb等接口</td><td>音频功能实现代码</td></tr><tr><td>tools</td><td>3⭐</td><td>与c编译、链接生成一个完整内核镜像相关的工具</td><td>编译相关</td></tr><tr><td>usr</td><td>3⭐</td><td></td><td>用户打包和压缩内核实现代码</td></tr><tr><td>virt</td><td>3⭐</td><td>虚拟化相关的代码，允许搭建虚拟机环境，运行多个系统</td><td>虚拟化相关代码实现</td></tr></tbody></table> 
<table><thead><tr><th><strong>文件</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>COPYING</td><td>许可授权信息</td></tr><tr><td>CREDITS</td><td>贡献者相关信息列表</td></tr><tr><td>Kbuild</td><td>内核设定的脚本</td></tr><tr><td>Kconfig</td><td>内核开发人员配置内核用到的配置</td></tr><tr><td>makefile</td><td>编译内核的makefile文件</td></tr><tr><td>MAINTAINERS</td><td>维护内核者的相关信息</td></tr></tbody></table> 
<h2><a id="Linux_122"></a>Linux内核进程</h2> 
<h3><a id="_123"></a>一、进程原理</h3> 
<h4><a id="1_124"></a>1、进程</h4> 
<p>Linux内核把进程称为任务(task)，<strong>进程的虚拟地址空间</strong>分为<strong>用户虚拟地址空间</strong>和<strong>内核虚拟地址空间</strong>，所有进程共享内核虚拟地址空间，每个进程有独立的用户空间虚拟地址空间。 <br>进程有两种特殊形式：没有用户虚拟地址空间的进程称为内核线程，共享用户虚拟地址空间的进程称为用户线程。通用在不会引起混淆的情况下把用户线程简称为线程。共享同一个用户虚拟地址空间的所有用户线程组成一个线程组。 <br>C标准库的进程专业术语和Linux内核的进程专业术语对应关系如下：</p> 
<table><thead><tr><th>C标准库的进程专业术语</th><th>Linux内核的进程专业术语</th></tr></thead><tbody><tr><td>包含多个线程的进程</td><td>线程组</td></tr><tr><td>只有一个线程的进程</td><td>进程或任务</td></tr><tr><td>线程</td><td>共享用户虚拟地址空间的进程</td></tr></tbody></table> 
<h4><a id="2Linux_133"></a>2、Linux进程四要素</h4> 
<ul><li>有一段程序供其执行。</li><li>有进程专用的系统堆栈空间。</li><li>在内核有task_struct数据结构；</li><li>有独立的存储空间，拥有专有的用户空间。</li></ul> 
<p>如果只具备前三条而缺少第四条，则称为“线程”。如果完全没有用户空间，就称为“内核线程”；而如果共享用户空间映射就称为“用户线程”。内核为每个进程分配一个task_struct结构时。实际分配两个连续物理页面(8192字节)，数据结构task_struct的大小约占1kb字节左右，进程的系统空间堆栈的大小约为7kb字节（不能扩展，是静态确定的）。</p> 
<h4><a id="3task_struct_141"></a>3、进程描述符task_struct数据结构内核源码，其主要核心成员如下</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">volatile</span> <span class="token keyword">long</span>			state<span class="token punctuation">;</span> <span class="token comment">//进程的状态</span>
	<span class="token keyword">void</span>				<span class="token operator">*</span>stack<span class="token punctuation">;</span> <span class="token comment">//指向内核栈</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	pid_t				pid<span class="token punctuation">;</span> <span class="token comment">//全局进程号</span>
	pid_t				tgid<span class="token punctuation">;</span> <span class="token comment">//全局线程组的标识符</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">struct</span> <span class="token class-name">pid_link</span>			pids<span class="token punctuation">[</span>PIDTYPE_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//进程号,进程组标识符和会话标识符</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu	<span class="token operator">*</span>real_parent<span class="token punctuation">;</span> <span class="token comment">//指向真实父进程</span>
	<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu	<span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">//指向父进程,如果进程被另一个进程使用系统调用ptrace,那么父进程跟踪进程,否则和real_parent相同</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">struct</span> <span class="token class-name">task_struct</span>		<span class="token operator">*</span>group_leader<span class="token punctuation">;</span> <span class="token comment">//指向线程组的组长</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">char</span>				comm<span class="token punctuation">[</span>TASK_COMM_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//进程名称</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// 调度策略和优先级</span>
	<span class="token keyword">int</span>				prio<span class="token punctuation">;</span>
	<span class="token keyword">int</span>				static_prio<span class="token punctuation">;</span>
	<span class="token keyword">int</span>				normal_prio<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span>	rt_priority<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	cpumask_t			cpus_allowed<span class="token punctuation">;</span> <span class="token comment">//允许进程在哪些处理器上运行</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// 指向内存描述符</span>
	<span class="token comment">// 进程:mm和active_mm指向同一个内存描述符</span>
	<span class="token comment">// 内核线程:mm是空指针,当内核线程运行时,active_mm指向从进程借用的内存描述符</span>
	<span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>		<span class="token operator">*</span>mm<span class="token punctuation">;</span> 
	<span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>		<span class="token operator">*</span>active_mm<span class="token punctuation">;</span> 
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">/* Filesystem information: */</span>
	<span class="token keyword">struct</span> <span class="token class-name">fs_struct</span>		<span class="token operator">*</span>fs<span class="token punctuation">;</span> <span class="token comment">//文件系统信息,主要是进程的根目录和当前工作目录</span>
	<span class="token comment">/* Open file information: */</span>
	<span class="token keyword">struct</span> <span class="token class-name">files_struct</span>		<span class="token operator">*</span>files<span class="token punctuation">;</span> <span class="token comment">//打开文件表</span>
	<span class="token comment">/* Namespaces: */</span>
	<span class="token keyword">struct</span> <span class="token class-name">nsproxy</span>			<span class="token operator">*</span>nsproxy<span class="token punctuation">;</span> <span class="token comment">//命名空间</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">//信号处理</span>
	<span class="token comment">/* Signal handlers: */</span>
	<span class="token keyword">struct</span> <span class="token class-name">signal_struct</span>		<span class="token operator">*</span>signal<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sighand_struct</span>		<span class="token operator">*</span>sighand<span class="token punctuation">;</span>
	sigset_t			blocked<span class="token punctuation">;</span>
	sigset_t			real_blocked<span class="token punctuation">;</span>
	<span class="token comment">/* Restored if set_restore_sigmask() was used: */</span>
	sigset_t			saved_sigmask<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sigpending</span>		pending<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="4_193"></a>4、创建新进程</h4> 
<p>在Linux内核中，新进程是从一个已经存在的进程复制出来的，内核使用静态数据结构造出0号内核线程，0号内核线程分叉生成1号内核线程和2号内核线程（kthreadd线程）。1号内核线程完成初始化以后装载用户程序，变成1号进程，其他进程都是1号进程或者它的子孙进程分叉生成的；其他内核线程是kthreadd线程分叉生成的。<br>3个系统调用可以用来创建新的进程：</p> 
<ul><li>fork(分叉)：子进程是父进程的一个副本，采用定时复制技术。</li><li>vfor：用于创建子进程，之后子进程立即调用execve以装载新程序的情况，为了避免复制物理页，父进程会睡眠等待子进程装载新程序。现在fork采用了定时复制技术，vfork失去了速度优势，已经被废弃。</li><li>clone（克隆）：可以精确地控制子进程和父进程共享哪些资源。 这个系统调用的主要用处是可供pthread库用来创建线程。clone是功能最齐全的函数，参数多使用复杂，fork是clone的简化函数。</li></ul> 
<p>Linux内核定义系统调用的独特方式，目前以系统调用fork为例： 系统调用的函数名称以"sys_"开头，创建新进程的3个系统调用在文件"kernel/fork.c"中，它们把工作委托给函数__do_fork。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">long</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token comment">//克隆标志</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_start<span class="token punctuation">,</span> <span class="token comment">//只有我们在创建线程时有意义,用来指定线程的用户栈起始地址</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_size<span class="token punctuation">,</span>  <span class="token comment">//只有我们在创建线程时有意义,用来指定线程的用户栈的长度</span>
	<span class="token keyword">int</span> __user <span class="token operator">*</span>parent_tidptr<span class="token punctuation">,</span> <span class="token comment">//只有我们在创建线程时有意义,如果clone_flags参数指定标志位CLONE_PARENT_SETID</span>
	<span class="token keyword">int</span> __user <span class="token operator">*</span>child_tidptr<span class="token punctuation">,</span> <span class="token comment">//只有我们在创建线程时有意义,存放新线程保存自己的进程标识符的位置,如果参数clone_flags指定标识符CLONE_CHILD_CLEARTID/CLONE_CHILD_SETID</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> tls <span class="token comment">//只有我们在创建线程时有意义,如果clone_flags参数指定标志位CLONE_SETTLS,那么参数tls指定新线程的线程本地存储的地址</span>
	<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//相关性验证</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	p <span class="token operator">=</span> <span class="token function">copy_process</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> stack_start<span class="token punctuation">,</span> stack_size<span class="token punctuation">,</span>
			 child_tidptr<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> trace<span class="token punctuation">,</span> tls<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Linux内核函数_do_fork()执行流程如下图所示：<br><img src="https://images2.imgbox.com/0d/1f/AfvfiK89_o.png" alt="image.png"><br>函数copy_process()内核源码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">static</span> __latent_entropy <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">copy_process</span><span class="token punctuation">(</span>
					<span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span>
					<span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_start<span class="token punctuation">,</span>
					<span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_size<span class="token punctuation">,</span>
					<span class="token keyword">int</span> __user <span class="token operator">*</span>child_tidptr<span class="token punctuation">,</span>
					<span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">,</span>
					<span class="token keyword">int</span> trace<span class="token punctuation">,</span>
					<span class="token keyword">unsigned</span> <span class="token keyword">long</span> tls<span class="token punctuation">,</span>
					<span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/// 状态检查 ///</span>
    <span class="token comment">// 同时设置 CLONE_NEWNS/CLONE_FS, 即新进程属于新的挂载命名空间,同时和当前进程共享文件系统信息</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLONE_NEWNS<span class="token operator">|</span>CLONE_FS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>CLONE_NEWNS<span class="token operator">|</span>CLONE_FS<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span><span class="token operator">-</span>EINVAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 同时设置 CLONE_NEWUSER/CLONE_FS, 即新进程属于新的用户命名空间,同时和当前进程共享文件系统信息</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLONE_NEWUSER<span class="token operator">|</span>CLONE_FS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>CLONE_NEWUSER<span class="token operator">|</span>CLONE_FS<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span><span class="token operator">-</span>EINVAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 即新进程和当前进程属于同一个线程组, 但是不共享信号处理程序</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_SIGHAND<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span><span class="token operator">-</span>EINVAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 即新进程和当前进程共享信号处理程序, 但是不共享虚拟内存</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_SIGHAND<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_VM<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span><span class="token operator">-</span>EINVAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">/// dup_task_struct ///</span>
    <span class="token comment">//同一个线程组的所有线程必须属于相同的用户命名空间和进程号命名空间</span>
    p <span class="token operator">=</span> <span class="token function">dup_task_struct</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/// 检查用户创建的进程数量是否超过限制 ///</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">atomic_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>real_cred<span class="token operator">-&gt;</span>user<span class="token operator">-&gt;</span>processes<span class="token punctuation">)</span> <span class="token operator">&gt;=</span>
			<span class="token function">task_rlimit</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> RLIMIT_NPROC<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>real_cred<span class="token operator">-&gt;</span>user <span class="token operator">!=</span> INIT_USER <span class="token operator">&amp;&amp;</span>
		    <span class="token operator">!</span><span class="token function">capable</span><span class="token punctuation">(</span>CAP_SYS_RESOURCE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">capable</span><span class="token punctuation">(</span>CAP_SYS_ADMIN<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">goto</span> bad_fork_free<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/// cpoy_creds ///</span>
    <span class="token comment">//设置权限</span>
    retval <span class="token operator">=</span> <span class="token function">copy_creds</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> clone_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/// 检查线程数量是否超过限制 ///</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nr_threads <span class="token operator">&gt;=</span> max_threads<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_count<span class="token punctuation">;</span>     
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/// 初始化task_struct ///</span>
    <span class="token function">delayacct_tsk_init</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">/* Must remain after dup_task_struct() */</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/// sched_fork ///</span>
    <span class="token comment">//kernel/sched/core.c</span>
    <span class="token keyword">void</span> <span class="token function">__sched_fork</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>  <span class="token comment">//为新进程设置调度器相关的参数  </span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/// 设置或共享资源 ///</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    retval <span class="token operator">=</span> <span class="token function">copy_semundo</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//只有属于同一个线程组的线程之间才会共享UNIX系统5个信号量</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_security<span class="token punctuation">;</span>
	retval <span class="token operator">=</span> <span class="token function">copy_files</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打开文件表,只有属于同一个线程组的线程之间才会共享打开文件表</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_semundo<span class="token punctuation">;</span>
	retval <span class="token operator">=</span> <span class="token function">copy_fs</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//文件系统信息,进程的文件系统信息包括:根目录,当前工作目录,文件模式创建掩码,只有属于同一个线程组的线程之间才会共享文件系统信息</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_files<span class="token punctuation">;</span>
	retval <span class="token operator">=</span> <span class="token function">copy_sighand</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 信号处理, 只有属于同一个线程组的线程之间才会共享信号处理程序</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_fs<span class="token punctuation">;</span>
	retval <span class="token operator">=</span> <span class="token function">copy_signal</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//信号结构体, 只有属于同一个线程组的线程之间才会共享信号结构体</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_sighand<span class="token punctuation">;</span>
	retval <span class="token operator">=</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//虚拟内存, 只有属于同一个线程组的线程之间才会共享虚拟内存</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_signal<span class="token punctuation">;</span>
	retval <span class="token operator">=</span> <span class="token function">copy_namespaces</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建或共享命名空间</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_mm<span class="token punctuation">;</span>
	retval <span class="token operator">=</span> <span class="token function">copy_io</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建或共享IO上下文</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_namespaces<span class="token punctuation">;</span>
	retval <span class="token operator">=</span> <span class="token function">copy_thread_tls</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> stack_start<span class="token punctuation">,</span> stack_size<span class="token punctuation">,</span> p<span class="token punctuation">,</span> tls<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//复制寄存器值并且修改一部分寄存器值,不同处理器架构的寄存器不同,所以各种处理器架构需要自己定义结构体pt_regs和thread_struct,实现函数copy_thread_tls</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_io<span class="token punctuation">;</span>
    <span class="token comment">/// 设置进程号和进程关系等等 ///</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">!=</span> <span class="token operator">&amp;</span>init_struct_pid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		pid <span class="token operator">=</span> <span class="token function">alloc_pid</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>pid_ns_for_children<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			retval <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">goto</span> bad_fork_cleanup_thread<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>函数copy_process()：创建新进程的主要工作由此函数完成，具体处理流程如下图所示：<br><img src="https://images2.imgbox.com/e1/52/9qKQ060Q_o.png" alt="image.png"></p> 
<h3><a id="_313"></a>二、进程状态迁移</h3> 
<p>进程主要有7种状态：就绪状态、运行状态、轻度睡眠、中度睡眠、深度睡 眠、僵尸状态、死亡状态，它们之间状态变迁如下：<br><br> <img src="https://images2.imgbox.com/08/e1/8DZIhAwn_o.png" alt="image.png"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">volatile</span> <span class="token keyword">long</span>			state<span class="token punctuation">;</span> <span class="token comment">//进程的状态</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/* Used in tsk-&gt;state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_RUNNING</span>			<span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_INTERRUPTIBLE</span>		<span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_UNINTERRUPTIBLE</span>		<span class="token expression"><span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__TASK_STOPPED</span>			<span class="token expression"><span class="token number">4</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__TASK_TRACED</span>			<span class="token expression"><span class="token number">8</span></span></span>
<span class="token comment">/* Used in tsk-&gt;exit_state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXIT_DEAD</span>			<span class="token expression"><span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXIT_ZOMBIE</span>			<span class="token expression"><span class="token number">32</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXIT_TRACE</span>			<span class="token expression"><span class="token punctuation">(</span>EXIT_ZOMBIE <span class="token operator">|</span> EXIT_DEAD<span class="token punctuation">)</span></span></span>
<span class="token comment">/* Used in tsk-&gt;state again: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_DEAD</span>			<span class="token expression"><span class="token number">64</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_WAKEKILL</span>			<span class="token expression"><span class="token number">128</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_WAKING</span>			<span class="token expression"><span class="token number">256</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_PARKED</span>			<span class="token expression"><span class="token number">512</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_NOLOAD</span>			<span class="token expression"><span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_NEW</span>			<span class="token expression"><span class="token number">2048</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_STATE_MAX</span>			<span class="token expression"><span class="token number">4096</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_STATE_TO_CHAR_STR</span>		<span class="token string">"RSDTtXZxKWPNn"</span></span>

<span class="token comment">/* Convenience macros for the sake of set_current_state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_KILLABLE</span>			<span class="token expression"><span class="token punctuation">(</span>TASK_WAKEKILL <span class="token operator">|</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_STOPPED</span>			<span class="token expression"><span class="token punctuation">(</span>TASK_WAKEKILL <span class="token operator">|</span> __TASK_STOPPED<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_TRACED</span>			<span class="token expression"><span class="token punctuation">(</span>TASK_WAKEKILL <span class="token operator">|</span> __TASK_TRACED<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_IDLE</span>			<span class="token expression"><span class="token punctuation">(</span>TASK_UNINTERRUPTIBLE <span class="token operator">|</span> TASK_NOLOAD<span class="token punctuation">)</span></span></span>

<span class="token comment">/* Convenience macros for the sake of wake_up(): */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_NORMAL</span>			<span class="token expression"><span class="token punctuation">(</span>TASK_INTERRUPTIBLE <span class="token operator">|</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_ALL</span>			<span class="token expression"><span class="token punctuation">(</span>TASK_NORMAL <span class="token operator">|</span> __TASK_STOPPED <span class="token operator">|</span> __TASK_TRACED<span class="token punctuation">)</span></span></span>

<span class="token comment">/* get_task_state(): */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_REPORT</span>			<span class="token expression"><span class="token punctuation">(</span>TASK_RUNNING <span class="token operator">|</span> TASK_INTERRUPTIBLE <span class="token operator">|</span> </span><span class="token punctuation">\</span>
					 <span class="token expression">TASK_UNINTERRUPTIBLE <span class="token operator">|</span> __TASK_STOPPED <span class="token operator">|</span> </span><span class="token punctuation">\</span>
					 <span class="token expression">__TASK_TRACED <span class="token operator">|</span> EXIT_ZOMBIE <span class="token operator">|</span> EXIT_DEAD<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">task_is_traced</span><span class="token expression"><span class="token punctuation">(</span>task<span class="token punctuation">)</span>		<span class="token punctuation">(</span><span class="token punctuation">(</span>task<span class="token operator">-&gt;</span>state <span class="token operator">&amp;</span> __TASK_TRACED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">task_is_stopped</span><span class="token expression"><span class="token punctuation">(</span>task<span class="token punctuation">)</span>		<span class="token punctuation">(</span><span class="token punctuation">(</span>task<span class="token operator">-&gt;</span>state <span class="token operator">&amp;</span> __TASK_STOPPED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">task_is_stopped_or_traced</span><span class="token expression"><span class="token punctuation">(</span>task<span class="token punctuation">)</span>	<span class="token punctuation">(</span><span class="token punctuation">(</span>task<span class="token operator">-&gt;</span>state <span class="token operator">&amp;</span> <span class="token punctuation">(</span>__TASK_STOPPED <span class="token operator">|</span> __TASK_TRACED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">task_contributes_to_load</span><span class="token expression"><span class="token punctuation">(</span>task<span class="token punctuation">)</span>	<span class="token punctuation">(</span><span class="token punctuation">(</span>task<span class="token operator">-&gt;</span>state <span class="token operator">&amp;</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> </span><span class="token punctuation">\</span>
					 <span class="token expression"><span class="token punctuation">(</span>task<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> PF_FROZEN<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> </span><span class="token punctuation">\</span>
					 <span class="token expression"><span class="token punctuation">(</span>task<span class="token operator">-&gt;</span>state <span class="token operator">&amp;</span> TASK_NOLOAD<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span>
</code></pre> 
<h3><a id="_369"></a>三、调度策略及优先级</h3> 
<h4><a id="1Linux_370"></a>1、Linux内核支持调度策略</h4> 
<ul><li>先进先出调度（SCHED_FIFO）、轮流调度（SCHED_RR）、限期调度策略（SCHED_DEADLINE)采用不同的调度策略调度实时进程。</li><li>普通进程支持两种调度策略：标准轮流分时（SCHED_NORMAL）和SCHED_BATCH调度普通的非实时进程。</li><li>空闲（SCHED_IDLE）则在系统空闲时调用idle进程。</li></ul> 
<p><strong>先进先出调度（SCHED_FIFO）</strong>：没有时间片，如果没有更高优先级的实时进程，并且它不睡眠，那么它会一直占用处理器。<br><strong>轮流调度（SCHED_RR）</strong>：有时间片，进程用完时间片以后加入优先级对应运行队列的尾部，把处理器给优先级相同的其他实时进程。<br><strong>标准轮流分时策略调度（SCHED_NORMAL）</strong>：使用完全公平调度算法，把处理器时间公平分配给每个进程。<br><strong>空闲策略调度（SCHED_IDLE）</strong>：用来执行优先级非常低的后台作业，优先级比使用标准轮流分时策略（SCHED_NORMAL）和相对优先级为19的普通进程（SCHED_BATCH）还要低，进程的相对优先级空闲调度策略没有影响。</p> 
<h4><a id="2_377"></a>2、进程优先级</h4> 
<p>限期进程的优先级比实时进程高，实时进程的优先级比普通进程高。</p> 
<ul><li>限制进程的优先级是-1。</li><li>实时进程的褚优先级是1-99，优先级数值越大，表示优先级越高。</li><li>普通进程 的静态优先级是100-139，优先级值越小，表示优先级越高，可通过修改nice值改变普通进程 的优先级，优先级等于120加上nice值。</li></ul> 
<p>在task_struct结构体中，4个成员和优先级有关如下：<br><img src="https://images2.imgbox.com/4a/7a/Cw6scSMu_o.png" alt="image.png"></p> 
<table><thead><tr><th><strong>优先级</strong></th><th><strong>限期进程</strong></th><th><strong>实时进程</strong></th><th><strong>普通进程</strong></th></tr></thead><tbody><tr><td>prio调度优先级（数值越小，表示优先级越高）</td><td>大多数情况下prio等于normal_prio<br>特殊情况：如果进程a占有实时互斥锁，进程b正在等待锁，进程b的优先级比较进程a的优先级高，那么把进程a的优先级临时提高到进程b的优先级，即进程a的prio值等于进程b的prio值</td><td></td><td></td></tr><tr><td>static_prio静态优先级</td><td>没意义，为0</td><td>没意义，为0</td><td>120+nice值，数值越小，表示优先级越高</td></tr><tr><td>normal_prio正常优先级（数值越小，表示优先级越高）</td><td>-1</td><td>99-rt_priority</td><td>static_prio</td></tr><tr><td>rt_priority实时优先级</td><td>没意义，为0</td><td>实时进程的优先级，范围是1-99，数值越大，表示优先级越高</td><td>没意义，为0</td></tr></tbody></table> 
<p>如果优先级低的进程占有实时互斥锁，优先级高的进程等待实时互斥锁，将把占有实时互斥锁的进程的优先级临时提高到等待实时互斥锁的进程的优先级，称为<strong>优先级继承</strong>。</p> 
<h3><a id="_394"></a>四、写时复制</h3> 
<p>写时复制核心思想：只有在不得不复制数据内容时才去复制数据内容。<br><img src="https://images2.imgbox.com/8c/a0/MrOa0VkP_o.png" alt="image.png"></p> 
<h2><a id="Linux_396"></a>Linux调度机制</h2> 
<h3><a id="_397"></a>一、调度器</h3> 
<h4><a id="1_398"></a>1、核心调度器</h4> 
<p>调度器的实现基于两个函数：<strong>周期性调度器函数</strong>和<strong>主调度器函数</strong>。这些函数根据现有进程的优先级分配CPU时间。这也是为什么整个方法称之为优先调度的原因。</p> 
<h5><a id="a_400"></a>a.主调度器函数</h5> 
<p>在内核中的许多地方，如果要将CPU分配给与当前活动进程不同的另一个进程，都会直接调用主调度器函数 （schedule）。</p> 
<pre><code class="prism language-cpp">asmlinkage __visible <span class="token keyword">void</span> __sched <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk <span class="token operator">=</span> current<span class="token punctuation">;</span>

	<span class="token function">sched_submit_work</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">__schedule</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sched_preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>schedule<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>主调度器负责将CPU的使用权从一个进程切换到另一个进程。周期性调度器只是定时更新调度相关的统计信息。 cfs队列实际上是用红黑树组织的，rt队列是用链表组织的。</p> 
<h5><a id="b_417"></a>b.周期性调度器函数</h5> 
<p>周期性调度器在scheduler_tick中实现，如果系统正在活动中，内核会按照频率HZ自动调用该函数。该函数主要有两个任务如下： <br>(1) 更新相关统计量：管理内核中与整个系统和各个进程的调度相关的统计量。其间执行的主要操作是对各 <br>种计数器加1。 <br>(2) 激活负责当前进程的调度类的周期性调度方法。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">scheduler_tick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 获取当前CPU上的全局就绪队列rq和当前运行的进程curr</span>
	<span class="token comment">// 在SMP的情况下, 获得当前CPU的ID, 如果不是SMP, 那么返回0</span>
	<span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 获得CPU的全局就绪队列rq, 每个CPU都有一个就绪队列rq</span>
	<span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 获取就绪队列上正在运行的进程curr</span>
	<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>

	<span class="token function">sched_clock_tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">rq_lock</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 更新rq当前时间戳, 即使rq-&gt;clock变为当前时间戳</span>
    <span class="token comment">// 处理就绪队列时钟的更新, 本质上就是增加struct rq当前实例的时钟时间戳</span>
	<span class="token function">update_rq_clock</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 由于调度器的模块化结构, 主要工作可以完全由特定调度器类方法实现。task_tick实现模式取决底层的调度器类</span>
	<span class="token comment">// 执行当前运行进程所在调度类的task_tick函数进行周期性调度</span>
	curr<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">task_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 将当前负荷加入数组的第一个位置</span>
	<span class="token function">cpu_load_update_active</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 更新全局CPU就绪队列的calc_global_update, 更新CPU的活动计数, 主要是更新全局CPU就绪队列calc_global_update</span>
	<span class="token function">calc_global_load_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 解锁</span>
	<span class="token function">rq_unlock</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 与perf计数事件有关</span>
	<span class="token function">perf_event_task_tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SMP</span></span>
	<span class="token comment">// 判断CPU是否为空闲状态</span>
	rq<span class="token operator">-&gt;</span>idle_balance <span class="token operator">=</span> <span class="token function">idle_cpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 如果进程周期性负载平衡, 则触发SCHED_SOFTIRQ</span>
	<span class="token function">trigger_load_balance</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token function">rq_last_tick_reset</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>更新统计量函数：update_rq_clock()/calc_global_load_tick() <br>&lt;update_rq_clock函数&gt;</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 处理就绪队列时钟的更新, 本质上就是增加struct rq当前实例的时钟时间戳</span>
<span class="token keyword">void</span> <span class="token function">update_rq_clock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	s64 delta<span class="token punctuation">;</span>

	<span class="token function">lockdep_assert_held</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>rq<span class="token operator">-&gt;</span>clock_update_flags <span class="token operator">&amp;</span> RQCF_ACT_SKIP<span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SCHED_DEBUG</span></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sched_feat</span><span class="token punctuation">(</span>WARN_DOUBLE_CLOCK<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">SCHED_WARN_ON</span><span class="token punctuation">(</span>rq<span class="token operator">-&gt;</span>clock_update_flags <span class="token operator">&amp;</span> RQCF_UPDATED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	rq<span class="token operator">-&gt;</span>clock_update_flags <span class="token operator">|=</span> RQCF_UPDATED<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

	delta <span class="token operator">=</span> <span class="token function">sched_clock_cpu</span><span class="token punctuation">(</span><span class="token function">cpu_of</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> rq<span class="token operator">-&gt;</span>clock<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	rq<span class="token operator">-&gt;</span>clock <span class="token operator">+=</span> delta<span class="token punctuation">;</span>
	<span class="token function">update_rq_clock_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>&lt;calc_global_load_tick函数&gt;</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 更新全局CPU就绪队列的calc_global_update, 更新CPU的活动计数, 主要是更新全局CPU就绪队列calc_global_update</span>
<span class="token keyword">void</span> <span class="token function">calc_global_load_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">long</span> delta<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">time_before</span><span class="token punctuation">(</span>jiffies<span class="token punctuation">,</span> this_rq<span class="token operator">-&gt;</span>calc_load_update<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>

	delta  <span class="token operator">=</span> <span class="token function">calc_load_fold_active</span><span class="token punctuation">(</span>this_rq<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>delta<span class="token punctuation">)</span>
		<span class="token function">atomic_long_add</span><span class="token punctuation">(</span>delta<span class="token punctuation">,</span> <span class="token operator">&amp;</span>calc_load_tasks<span class="token punctuation">)</span><span class="token punctuation">;</span>

	this_rq<span class="token operator">-&gt;</span>calc_load_update <span class="token operator">+=</span> LOAD_FREQ<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="2_508"></a>2、调度类及运行队列</h4> 
<h5><a id="a_509"></a>a.调度类</h5> 
<p>为方便添加新的调度策略，Linux内核抽象一个调度类sched_class，目前为止实现5种调度类：<br><img src="https://images2.imgbox.com/09/6a/aheOQBgT_o.png" alt="image.png"><br><strong>停机调度类（stop_sched_class）</strong>：支持期限调度类，迁移线程的优先级必须比期限进程的优先级高，能够抢占所有其他进程，才能够快速处理调度器发出的迁移移求，把进程从当前处理器迁移到其他处理器。<br><strong>期限调度类（dl_sched_class）</strong>：使用优先算法（使用红黑树）把进程按照绝对截至期限从小到大排序，每次调度时选择绝对截至期限最小的进程。<br><strong>实时调度类（rt_sched_class）</strong>：为每个调度优先级维护一个队列，源码如下</p> 
<pre><code>struct rt_prio_array {
	DECLARE_BITMAP(bitmap, MAX_RT_PRIO+1); /* include 1 bit for delimiter */ //包含一个作为分割符的位
	struct list_head queue[MAX_RT_PRIO];
};
</code></pre> 
<p>位图bitmap用来快速查找第一个非空队列，队列queue的下标是实时进程的调度优先级，下标越小，优先级越高。即每次调度，先找到优先级最高的非空队列（bitmap），然后从队列当中选择第一个进程。 <br>SCHED_FIFO：进程执行时无时间片，如果没有更高优先级，那么会一直执行直到结束。<br>SCHED_RR：进程执行时有时间片。 <br><strong>公平调度类（fair_sched_class）</strong>：使用完全公平调度算法，引入虚拟运行时间。<br>虚拟运行时间=实际运行时间*nice 0对应的权重/进程的权重</p> 
<pre><code>const int sched_prio_to_weight[40] = {
 /* -20 */     88761,     71755,     56483,     46273,     36291,
 /* -15 */     29154,     23254,     18705,     14949,     11916,
 /* -10 */      9548,      7620,      6100,      4904,      3906,
 /*  -5 */      3121,      2501,      1991,      1586,      1277,
 /*   0 */      1024,       820,       655,       526,       423,
 /*   5 */       335,       272,       215,       172,       137,
 /*  10 */       110,        87,        70,        56,        45,
 /*  15 */        36,        29,        23,        18,        15,
};
//nice 0 对应权重是1024
//nice n-1 的权重大概是nice n 权重的1.2倍左右
</code></pre> 
<p><strong>空闲调度类（idle_sched_class）</strong>：每个处理器有一个空闲线程，即0号线程。空闲调度类的优先级最低，仅当没有其他进程可以调度的时候，才会执行调度空闲线程。</p> 
<p><strong>调度类优先级：stop_sched_class &gt; dl_sched_class &gt; rt_sched_class &gt; fair_sched_class &gt; idle_sched_class。</strong></p> 
<p>调度类选择下一个进程：<br>停机调度类：pick_next_task_stop<br>限期调度类：pick_next_task_dl<br>实时调度类：pick_next_task_rt<br>公平调度类：pick_next_task_fair</p> 
<h5><a id="b_537"></a>b.运行队列</h5> 
<p>每个处理器有一个运行队列，结构体是rq，定义的全局变量如下：<br><img src="https://images2.imgbox.com/05/c9/crEL2Dbe_o.png" alt="image.png"><br>rq是描述就绪队列，其设计是为每一个CPU就绪队列，本地进程在本地队列上排序<br>struct rq中嵌入公平运行队列cfs，实时运行队列rt，限期运行队列dl，停机调度类和空闲调度类在每个处理器上只有一个内核线程，不需要运行队列，直接定义成员stop/idle分别指向迁移线程的空闲线程。</p> 
<h4><a id="3_539"></a>3、调度进程</h4> 
<p>主动调度进程的函数是schedule() ，它会把主要工作委托给__schedule()去处理。<br><img src="https://images2.imgbox.com/76/1a/RQcNc7it_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/50/96/IeIt3eaF_o.png" alt="image.png"><br>函数参数preempt表示是否抢占调度</p> 
<ul><li>true：表示抢占调度, 强制剥夺当前进程对处理器的使用权。</li><li>false：表示主动调度, 当前进程主动让出处理器。</li></ul> 
<p>函数__shcedule的主要处理过程如下：</p> 
<ul><li>调用pick_next_task()以选择下一个进程。</li><li>调用context_switch()以切换进程。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>
<span class="token function">context_switch</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span>
               <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>

    <span class="token comment">// 执行进程切换的准备工作</span>
    <span class="token function">prepare_task_switch</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>

    mm <span class="token operator">=</span> next<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    oldmm <span class="token operator">=</span> prev<span class="token operator">-&gt;</span>active_mm<span class="token punctuation">;</span>
    <span class="token comment">/*
* For paravirt, this is coupled with an exit in switch_to to
* combine the page table reload and the switch backend into
* one hypercall.
*/</span>
    <span class="token comment">// 开始上下文切换, 是每种处理器架构必须定义的函数</span>
    <span class="token function">arch_start_context_switch</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果下一个进程是内核线程(成员mm是空指针), 内核线程没有用户虚拟地址空间,</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mm<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        next<span class="token operator">-&gt;</span>active_mm <span class="token operator">=</span> oldmm<span class="token punctuation">;</span>
        <span class="token function">mmgrab</span><span class="token punctuation">(</span>oldmm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 此函数通知处理器架构不需要切换用户虚拟地址空间, 这种加速进程切换的技术就是tlb</span>
        <span class="token function">enter_lazy_tlb</span><span class="token punctuation">(</span>oldmm<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span>
        <span class="token comment">// 如果下一个进程是用户进程, 那么就调用此函数, 切换进程的用户虚拟地址空间</span>
        <span class="token function">switch_mm_irqs_off</span><span class="token punctuation">(</span>oldmm<span class="token punctuation">,</span> mm<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果上一个进程是内核线程, 把成员active_mm置为空指针, 断开它与借用的用户虚拟地址空间的联系, 把它借用的用户虚拟地址空间保存在运行队列的成员prev_mm中。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev<span class="token operator">-&gt;</span>mm<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        prev<span class="token operator">-&gt;</span>active_mm <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        rq<span class="token operator">-&gt;</span>prev_mm <span class="token operator">=</span> oldmm<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    rq<span class="token operator">-&gt;</span>clock_update_flags <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span>RQCF_ACT_SKIP<span class="token operator">|</span>RQCF_REQ_SKIP<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*
* Since the runqueue lock will be released by the next
* task (which is an invalid locking op but in the case
* of the scheduler it's an obvious special-case), so we
* do an early lockdep release here:
*/</span>
    <span class="token function">rq_unpin_lock</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">spin_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>lock<span class="token punctuation">.</span>dep_map<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> _THIS_IP_<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Here we just switch the register state and the stack. */</span>
    <span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">finish_task_switch</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="aARM64switch_mm_irqs_off_603"></a>a、切换用户虚拟地址空间，ARM64架构使用默认的switch_mm_irqs_off，其内核源码定义如下：</h5> 
<p><img src="https://images2.imgbox.com/d6/72/H1XK5Fhz_o.png" alt="image.png"><br>switch_mm函数内核源码处理如下：<br><img src="https://images2.imgbox.com/17/04/VHyhHYJE_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/c1/2e/Hcn1fpgC_o.png" alt="image.png"><br><strong>内核态和用户态的切换</strong><br><strong>内核态</strong>：CPU可以访问内存所有的数据，包括外围设备（网卡、硬盘等），CPU也可以将自己从一个程序切换至另一个程序。<br><strong>用户态</strong>：只能受限的访问，并且不允许访问外围设备，占用CPU的能力被剥夺，CPU资源可以被其他程序获取。</p> 
<h5><a id="bswitch_to__switch_to_605"></a>b、切换寄存器，宏switch_to把这项工作委托给函数__switch_to：</h5> 
<p><img src="https://images2.imgbox.com/50/4c/BW6fv4yU_o.png" alt="image.png"></p> 
<pre><code class="prism language-c">__notrace_funcgraph <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">__switch_to</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span>
				<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>last<span class="token punctuation">;</span>

	<span class="token function">fpsimd_thread_switch</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//切换到浮点寄存器</span>
	<span class="token function">tls_thread_switch</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//切换线程本地存储相关的寄存器</span>
	<span class="token function">hw_breakpoint_thread_switch</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//切换调试寄存器</span>
	<span class="token function">contextidr_thread_switch</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//切换上下文标识符寄存器</span>
	<span class="token function">entry_task_switch</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使用当前处理器每处理器变量记录下一个进程的进程描述符地址</span>
	<span class="token function">uao_thread_switch</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * Complete any pending TLB or cache maintenance on this CPU in case
	 * the thread migrates to a different CPU.
	 */</span>
	<span class="token comment">// 在这个处理器上执行完前面的所有页表缓存或缓存维护操作, 防止线程迁移到其他处理器</span>
	<span class="token function">dsb</span><span class="token punctuation">(</span>ish<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* the actual thread switch */</span>
	<span class="token comment">// 实际的线程切换</span>
	last <span class="token operator">=</span> <span class="token function">cpu_switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> last<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="4_634"></a>4、调度时机</h4> 
<p>调度进程的时机如下：</p> 
<ul><li>进程主动调用schedule()函数。</li><li>周期性地调度，抢占当前进程，强迫当前进程让出处理器。</li><li>唤醒进程的时候，被唤醒的进程可能抢占当前进程。</li><li>创建新进程的时候，新进程可能抢占当前进程。</li></ul> 
<p>如果我们编译内核的时候，开启了对内核抢占的支持，那么内核还要增加一些抢占点。</p> 
<h5><a id="a_643"></a>a、主动调度</h5> 
<p>进程在用户模式下运行的时候，无法直接调用schedule()函数，只能通过系统调用进入内核模式，如果系统调用需要等待某个资源，如互斥锁或信号量，就会把进程的状态设置为睡眠状态，然后调用schedule()函数来调度进程。 <br>进程也可以通过系统调用sched_yield()让出处理器，这种情况下进程不会睡眠。<br>在内核中有三种主动调度方式：</p> 
<ol><li>直接调用schedule()函数。</li><li>调用有条件重调度函数cond_resched()。</li><li>如果需要等待某个资源（如互斥锁或信号量）</li></ol> 
<h5><a id="b_649"></a>b、周期调度</h5> 
<p>有些“地痞流氓”进程不主动让出处理器，内核只能依靠周期性的时钟中断夺回处理器的控制权，时钟中断是调度器的脉博。时钟中断处理程序检查当前进程的执行时间有没有超过限额，如果超过限额，设置需要重新调度的标志。当时钟中断处理程序准备返点处理器还给被打断的进程时，如果被打断的进程在用户模式下运行，就检查有没有设置需要重新调度的标志，如果设置了，调用schedule函数以调度进程。<br>如果需要重新调度，就为当前进程的thread_info结构体的成员flags设置需要重新调度的标志。</p> 
<h3><a id="SMP_651"></a>二、SMP调度</h3> 
<p>SMP：是Symmetric Multi Processing的简称，意为对称多处理系统。<br>SMP内有许多紧耦合多处理器，这种系统的最大特点就是共享所有资源。另外与之相对立的标准是MPP (Massively Parallel Processing)，意为大规模并行处理系统，这样的系统是由许多松耦合处理单元组成的，要注意的是这里指的是处理单元而不是处理器。<br>在SMP系统中，进程调度器必须支持如下：</p> 
<ul><li>需要使用每个处理器的负载尽可能均衡。</li><li>可以设置进程的处理器亲和性，即允许进程在哪些处理器上执行。</li><li>可以把进程从一个处理器迁移到另一个处理器。</li></ul> 
<h4><a id="1_657"></a>1、进程的处理器亲和性</h4> 
<p>设置进程的处理器亲和性，通俗就是把进程绑定到某些处理器，只允许进程在某些处理器上执行，默认情况是进程可以在所有处理器上执行。应用编程接口和使用cpuset配置具体详解分析。<br><strong>应用编程进程内核只有两个系统调用：</strong></p> 
<ol><li>sched_setaffinity：设置进程的处理器亲和性掩码</li><li>sched_getaffinity：用来获取进程的处理器亲和性掩码</li></ol> 
<p><strong>内核线程可以使用两个函数来设置处理器亲和性和亲和性掩码：</strong></p> 
<ul><li>kthread_bind：用来把一个刚刚创建的内核线程绑定到一个处理器。</li><li>set_cpus_allowed_ptr：用来设置内核线程的处理器亲和性掩码。</li></ul> 
<h4><a id="2_667"></a>2、期限调度类的处理器负载均衡</h4> 
<p>限期调度类的处理器负载均衡简单，调度选择下一个限期进程的时候，如果当前正在执行的进程是限期进程， 将会试图从限期进程超载的处理器把限期进程搞过来。 <br>限期进程超载定义：</p> 
<ul><li>限期运行队列至少有两个限期进程。</li><li>至少有一个限期进程绑定到多个处理器。</li></ul> 
<p><img src="https://images2.imgbox.com/80/3e/tVSzAAMc_o.png" alt="image.png"></p> 
<h4><a id="3_674"></a>3、实时调度类的处理器负载均衡</h4> 
<p>实时调度类的处理器负载均衡和限期调度类相似。调度器选择下一个实时进程时，如果当前处理器的实时运行队列中的进程的最高调度优先级比当前正在执行的进程的调度优先级低，将会试图从实时进程超载的处理器把可推送实时进程拉过来。 <br>实时进程超载的定义：</p> 
<ul><li>实时运行队列至少有两个实时进程。</li><li>至少有一个可推送实时进程。</li></ul> 
<p><img src="https://images2.imgbox.com/e1/4b/l9AgcioO_o.png" alt="image.png"></p> 
<h4><a id="4_681"></a>4、公平调度类的处理器负载均衡</h4> 
<p>目前多处理器系统有两种体系结构：NUMA和SMP。 <br>处理器内部的拓扑如下： <br>a.核(core)：一个处理器包含多个核，每个核独立的一级缓存，所有核共享二级缓存。 <br>b.硬件线程：也称为逻辑处理器或者虚拟处理器，一个处理器或者核包含多个硬件线程，硬件线程共享一级缓存和二级缓存。MIPS处理器的叫法是同步多线程(Simultaneous Multi-Threading,SMT)，英特尔对它的叫法是超线程。</p> 
<h2><a id="Linux_683"></a>Linux锁与进程间通信</h2> 
<h3><a id="_684"></a>一、内核控制机制</h3> 
<h4><a id="1_685"></a>1、竞态条件</h4> 
<p>几个进程在访问资源的时候彼此干扰的情况通常称为竞态条件（race condition）。 <br>由于导致竞态条件的情况非常罕见，因此需要提出一个问题：是否值得做一些（有时候是大量的）工作来保护代码避免竞态条件。在某些环境中（比如航空飞机的控制系统、重要机械的监控、危险装备），竞态条件是致命问题。</p> 
<h4><a id="2_687"></a>2、临界区</h4> 
<p>每个进程中访问<strong>临界资源</strong>的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个进程使用的共享资源）。<br>属于临界资源的硬件如打印机等，属于临界资源的软件有消息缓冲队列、数组、缓冲区等。进程间采取互斥方式，实现对这些资源进行共享。</p> 
<h3><a id="_689"></a>二、内核锁机制</h3> 
<p>内核可以不受限制地访问整个地址空间。在多处理器系统上，这会引起一些问题。如果几个处理器同时处于核心态，则理论上它们可以同时访问同一个数据结构。在第一个提供了SMP功能的内核版本中，该问题的解决方案非常简单，即每次只允许一个处理器处于核心态。因此，对数据未经协调的并行访问被自动排除了。令人遗憾的是，该方法因为效率不高，很快被废弃了。现在内核使用由锁组成的细粒度网络，来明确地保护各个数据结构。如果处理器A在操作数据结构S，则处理器B可以执行任何其他的内核操作，但不能操作S。 <br><strong>内核为此提供了各种锁选项，分别优化不同的内核数据使用模式</strong>。 <br><strong>原子操作</strong>：这些是最简单的锁操作。它们保证简单的操作，诸如计数器加1之类，可以不中断地原子执行。即使操作由几个汇编语句组成，也可以保证。 <br><strong>自旋锁</strong>：这些是最常用的锁选项。它们用于短期保护某段代码，以防止其他处理器的访问。在内核等待自旋锁释放时，会重复检查是否能获取锁，而不会进入睡眠状态（忙等待）。当然，如果等待时间较长，则效率显然不高。 <br><strong>信号量</strong>：这些是用经典方法实现的。在等待信号量释放时，内核进入睡眠状态，直至被唤醒。唤醒后，内核才重新尝试获取信号量。互斥量是信号量的特例，互斥量保护的临界区，每次只能有一个用户进入。 <br><strong>读者/写者锁</strong>：这些锁会区分对数据结构的两种不同类型的访问。任意数目的处理器都可以对数据结构进行并发读访问，但只有一个处理器能进行写访问。事实上，在进行写访问时，读访问是无法进行的。</p> 
<h3><a id="_691"></a>三、自旋锁/互斥锁</h3> 
<h4><a id="1_692"></a>1、自旋锁</h4> 
<h5><a id="a_693"></a>a、自旋锁概念</h5> 
<p>自旋锁用于处理器之间的互斥，适合保护很短的临界区，并且不允许在临界区睡眠。申请自旋锁的时候，如果自旋锁被其他处理器占有，该处理器自旋等待（也称为忙等待）。若进程、软中断和硬件中断都可以使用自旋锁。目前内核的自旋锁是排队自旋锁（queued spinlock，也称为"FIFO ticket spinlock"），核心算法类似银行柜台排队叫号。 <br>自旋锁算法核心思路案例（银行柜台排队叫号）：<br>a. 锁拥有排队号和服务号，服务号是当前占有锁的进程的排队号；<br>b. 每个进程申请锁的时候，首先申请一个排队号，然后轮询服务号是否等于自己的排队号，如果等于，表示自己占有锁，可以进入临界区，否则继续轮询；<br>c. 当进程释放时，把服务号加1，下一个进程看到服务号等于自己的排队号，退出轮询，进入临界区。<br>Linux内核自旋锁源码定义如下：</p> 
<pre><code class="prism language-c"><span class="token comment">//如果打上实时内核补丁, 那么spinlock使用实时互斥锁保护临界区, 在临界区内可以被抢占和睡眠, 但raw_spinlock还是自旋</span>
<span class="token comment">//到目前为止, 还没有合并实时内核补丁, 代码可以兼容实时内核, 最好坚持3个原则:</span>
	<span class="token comment">//1.尽可能使用spinlock</span>
	<span class="token comment">//2.绝对不允许被抢占和睡眠的地方使用raw_spinlock, 否则使用spinlock</span>
	<span class="token comment">//3.如果临界区足够小, 使用绝对不允许被抢占和睡眠的地方使用raw_spinlock	</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">union</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">struct</span> <span class="token class-name">raw_spinlock</span> rlock<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_LOCK_ALLOC</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">LOCK_PADSIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">raw_spinlock</span><span class="token punctuation">,</span> dep_map<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
		<span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
			u8 __padding<span class="token punctuation">[</span>LOCK_PADSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">struct</span> <span class="token class-name">lockdep_map</span> dep_map<span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">spinlock_t</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">raw_spinlock</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">arch_spinlock_t</span> raw_lock<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_GENERIC_LOCKBREAK</span></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> break_lock<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_SPINLOCK</span></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> magic<span class="token punctuation">,</span> owner_cpu<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_LOCK_ALLOC</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">lockdep_map</span> dep_map<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span> <span class="token class-name">raw_spinlock_t</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="barch_spinlock_tARM64_729"></a>b、处理器架构都要定义自己的数据类型arch_spinlock_t，如下ARM64架构定义如下：</h5> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__AARCH64EB__ </span><span class="token comment">// 大端字节序(高位存放在低地址)</span></span>
	u16 next<span class="token punctuation">;</span> <span class="token comment">//排队号</span>
	u16 owner<span class="token punctuation">;</span> <span class="token comment">//服务号</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> <span class="token comment">//小端字节序(低位存放在低地址)</span></span>
	u16 owner<span class="token punctuation">;</span> 
	u16 next<span class="token punctuation">;</span> 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span> <span class="token function">__aligned</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token class-name">arch_spinlock_t</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="cLinux_741"></a>c、Linux内核自旋锁申请/释放常用函数如下：</h5> 
<p>spin_lock/spin_lock_bh/spin_trylock/spin_lock_irq <br>spin_unlock/spin_unlock_bh/spin_unlock_irq/spin_unlock_irqrestore</p> 
<pre><code class="prism language-c"><span class="token comment">// 申请自旋锁, 如果锁被其他处理器占有, 当前处理器自旋等待</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">raw_spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>rlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 申请自旋锁, 并且禁止当前处理器的软中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">spin_lock_bh</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">raw_spin_lock_bh</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>rlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 申请自旋锁, 如果申请成功返回1, 如果锁被其他处理器占有, 当前处理器不等待, 立即返回0</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">int</span> <span class="token function">spin_trylock</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">raw_spin_trylock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>rlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 申请自旋锁, 并且禁止当前处理器的硬中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">spin_lock_irq</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">raw_spin_lock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>rlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="dspin_lock_768"></a>d、在多处理器系统当中，函数spin_lock负责申请自旋锁，其内核源码如下：</h5> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">arch_spin_lock</span><span class="token punctuation">(</span><span class="token class-name">arch_spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>
	<span class="token class-name">arch_spinlock_t</span> lockval<span class="token punctuation">,</span> newval<span class="token punctuation">;</span>

	<span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>
	<span class="token comment">/* Atomically increment the next ticket. */</span>
	<span class="token function">ARM64_LSE_ATOMIC_INSN</span><span class="token punctuation">(</span>
	<span class="token comment">/* LL/SC */</span>
<span class="token string">"	prfm	pstl1strm, %3\n"</span>
<span class="token string">"1:	ldaxr	%w0, %3\n"</span>
<span class="token string">"	add	%w1, %w0, %w5\n"</span>
<span class="token string">"	stxr	%w2, %w1, %3\n"</span>
<span class="token string">"	cbnz	%w2, 1b\n"</span><span class="token punctuation">,</span>
	<span class="token comment">/* LSE atomics */</span>
<span class="token string">"	mov	%w2, %w5\n"</span>
<span class="token string">"	ldadda	%w2, %w0, %3\n"</span>
	<span class="token function">__nops</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
	<span class="token punctuation">)</span>

	<span class="token comment">/* Did we get the lock? */</span>
<span class="token string">"	eor	%w1, %w0, %w0, ror #16\n"</span>
<span class="token string">"	cbz	%w1, 3f\n"</span>
	<span class="token comment">/*
	 * No: spin on the owner. Send a local event to avoid missing an
	 * unlock before the exclusive load.
	 */</span>
<span class="token string">"	sevl\n"</span>
<span class="token string">"2:	wfe\n"</span>
<span class="token string">"	ldaxrh	%w2, %4\n"</span>
<span class="token string">"	eor	%w1, %w2, %w0, lsr #16\n"</span>
<span class="token string">"	cbnz	%w1, 2b\n"</span>
	<span class="token comment">/* We got the lock. Critical section starts here. */</span>
<span class="token string">"3:"</span>
	<span class="token operator">:</span> <span class="token string">"=&amp;r"</span> <span class="token punctuation">(</span>lockval<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=&amp;r"</span> <span class="token punctuation">(</span>newval<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=&amp;r"</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"+Q"</span> <span class="token punctuation">(</span><span class="token operator">*</span>lock<span class="token punctuation">)</span>
	<span class="token operator">:</span> <span class="token string">"Q"</span> <span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>owner<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"I"</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> TICKET_SHIFT<span class="token punctuation">)</span>
	<span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>函数spin_unlock负责释放自旋锁，其内核源码如下：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">arch_spin_unlock</span><span class="token punctuation">(</span><span class="token class-name">arch_spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> tmp<span class="token punctuation">;</span>

	<span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token function">ARM64_LSE_ATOMIC_INSN</span><span class="token punctuation">(</span>
	<span class="token comment">/* LL/SC */</span>
	<span class="token string">"	ldrh	%w1, %0\n"</span>
	<span class="token string">"	add	%w1, %w1, #1\n"</span>
	<span class="token string">"	stlrh	%w1, %0"</span><span class="token punctuation">,</span>
	<span class="token comment">/* LSE atomics */</span>
	<span class="token string">"	mov	%w1, #1\n"</span>
	<span class="token string">"	staddlh	%w1, %0\n"</span>
	<span class="token function">__nops</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token operator">:</span> <span class="token string">"=Q"</span> <span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>owner<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=&amp;r"</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
	<span class="token operator">:</span>
	<span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="e_829"></a>e、读写自旋锁</h5> 
<p>读写自旋锁（又称为读写锁）是对自旋锁的改进，区分读者和写者，允许多个读者同时进入临界区，读者和写者互斥，写者和写者互斥。如果读者占用读锁，写者申请写锁的时候自旋等待。如果写者占有写锁，读者申请读锁的时候自旋等待。 <br>读写自旋锁内核源码定义定义如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">arch_rwlock_t</span> raw_lock<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_GENERIC_LOCKBREAK</span></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> break_lock<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_SPINLOCK</span></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> magic<span class="token punctuation">,</span> owner_cpu<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_LOCK_ALLOC</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">lockdep_map</span> dep_map<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span> <span class="token class-name">rwlock_t</span><span class="token punctuation">;</span>
</code></pre> 
<p>不同处理器架构都要自己定义数据类型arch_rwlock_t，ARM64架构定义如下：</p> 
<pre><code class="prism language-c"><span class="token comment">// 各种处理器架构需要自定义数据类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* no debug version on UP */</span>
<span class="token punctuation">}</span> <span class="token class-name">arch_rwlock_t</span><span class="token punctuation">;</span>

</code></pre> 
<p><strong>内核申请读锁/释放锁，申请写锁/释放锁常用函数查阅Linux内核笔记文档。</strong><br><strong>读写自旋锁缺点</strong>：如果读者太多，写者很难获取写锁，可能饿死。假设有一个读者占有读锁，然后写者申请写锁，写者需要自旋等待，接着另一个读者申请读锁，它可以获取读锁，如果两个读者轮流占有读锁，可能造成写者饿死。解决此问题，内核实现排队读写锁，主要改进是，如果写者正在等待写锁，那么读者申请读锁时自旋等待，写者在锁被释放以后先得到写锁。排队读写锁配置是宏设置的。</p> 
<h4><a id="2_855"></a>2、互斥锁</h4> 
<p>互斥锁只允许一个进程进入临界区，适合保护比较长的临界区，因为竞争互斥锁时进程可能睡眠和再次唤醒，代价很高。尽管可以把二值信号当作互斥锁使用，但是内核单独实现互斥锁，内核源码的互斥锁定义如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">mutex</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">atomic_long_t</span>		owner<span class="token punctuation">;</span>
	<span class="token class-name">spinlock_t</span>		wait_lock<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_MUTEX_SPIN_ON_OWNER</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">optimistic_spin_queue</span> osq<span class="token punctuation">;</span> <span class="token comment">/* Spinner MCS lock */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span>	wait_list<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_MUTEXES</span></span>
	<span class="token keyword">void</span>			<span class="token operator">*</span>magic<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_LOCK_ALLOC</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">lockdep_map</span>	dep_map<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>申请互斥锁常用函数：</strong></p> 
<pre><code class="prism language-c"><span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mutex</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//申请互斥锁，如果锁被占有，进程深度睡眠</span>
<span class="token function">mutex_lock_interruptible</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//申请互斥锁，如果锁被占用，进程轻度睡眠</span>
<span class="token function">mutex_lock_killable</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//申请互斥锁，如果锁被占用，进程中度睡眠</span>
<span class="token function">mutex_lock_trylock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//申请互斥锁，如果申请成功返回1，如果锁被其他进程占有，那么进程不等待返回0</span>
</code></pre> 
<p><strong>所有释放互斥锁使用的函数如下：</strong></p> 
<pre><code class="prism language-c"><span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mutex</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>实时互斥锁</strong><br>实时互斥锁是对互斥锁进行改进的，实现了优先继承，解决了优先级反转问题。什么是优先级反转问题？<br>优先级反转问题：假设进程1的优先级低，进程2的优先级高。进程1持有互斥锁，进程2申请互斥锁，因为进程1已经占用互斥锁，所以进程2必须睡眠等待，导致优先级高的进程2等待优先级低的进程1。<br>实时互斥锁的作用就是当优先级低的进程持有互斥锁，并且优先级高的进程等待互斥锁，就把持有互斥锁优先级低的进程的优先级临时提高到优先级高的等待互斥锁的进程的优先级。<br><strong>原子变量</strong><br>原子变量用来实现对整数的互斥访问，通常用来实现计数器。<br>假设：写一行代码把变量a加1，编译器把代码编译成3条汇编指令：<br>a. 把变量a从内存加载到寄存器；<br>b. 把寄存器的值加1；<br>c. 把寄存器的值写回到内存。</p> 
<h3><a id="_885"></a>四、消息队列</h3> 
<p><strong>进程间通信共有7种：</strong></p> 
<ol><li>PIPE：管道，匿名管道</li><li>FIFO：有名管道</li><li>SIGNAL：信号</li><li>MESSAGE：消息队列</li><li>SEMAPHORE：信号量</li><li>SHARE MEMORY：共享内存</li><li>SOCKET：套接字</li></ol> 
<p><strong>消息队列</strong><br>消息队列是消息的链接表，包括 Posix 消息队列和 System V 消息队列。消息队列克服了信号承载信息量少、管道只能承载无格式字节流以及缓冲区大小受限等缺点，克服了早期 Linux 通信机制的一些缺点。消息队列将消息看作一个记录，具有特定的格式以及特定的优先级，对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读取消息，消息队列是随内核持续的。</p> 
<h4><a id="1msg_queue_897"></a>1、消息队列msg_queue数据结构</h4> 
<p><img src="https://images2.imgbox.com/f9/fa/0RxOmwI1_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/03/5d/DWoas87V_o.png" alt="image.png"></p> 
<h4><a id="2_899"></a>2、系统调用定义</h4> 
<p>在程序上层可以直接调用msgsnd(msqid,&amp;msgs,sizeof(struct msgstru),IPC_NOWAIT) 这样的形式来发送消息，但是在底层是用以下的形式来调用 ：<br><img src="https://images2.imgbox.com/a9/82/mNDvirwy_o.png" alt="image.png"><br>对于 SYSCALL_DEFINE4，首个变量用于函数名，剩下的偶数对参数，依次代表参数类型与参数变量。 <br>SYSCALL_DEFINEx，随后的 x 就是对于不同的参数的个数。<br><img src="https://images2.imgbox.com/a9/34/6GcRZ68M_o.png" alt="image.png"><br>SYSCALL_DEFINEx 的定义和它具体调用的方法中 ## 是连接符，直接将参数的原来的字符替换为 ## 后的占位符。<strong>VA_ARGS</strong> 代表前面… 里面的可变参数最后调用了__do_sys##name 的方法，在后面加上大括号就是一个函数的具体定义了。</p> 
<p><img src="https://images2.imgbox.com/d4/ad/MVeKbTs7_o.png" alt="image.png"><br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/ipc.h&gt;<br>#include &lt;sys/msg.h&gt;<br><strong>a.msgget 函数</strong><br>得到消息队列标识符或创建一个消息队列对象并返回消息队列标识符。<br><strong>b.msgsnd 函数</strong><br>将消息写入到消息队列。 <br><strong>c.msgrcv 函数</strong><br>从消息队列读取消息。 msgflag:IPC_NOWAIT/IPC_EXCEPT/IPC_NOERROR<br><strong>d.msgctl函数</strong><br>获取和设置消息队列的属性。</p> 
<h4><a id="3_903"></a>3、消息队列项目实战分析（供参考）</h4> 
<h5><a id="31__904"></a>3.1 消息队列控制</h5> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span>  <span class="token comment">/* system function*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;error.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TEXT_SIZE</span>  <span class="token expression"><span class="token number">512</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">msgbuf</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> mtype <span class="token punctuation">;</span>
    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span>TEXT_SIZE<span class="token punctuation">]</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> msqid <span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span> info <span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msgbuf</span> buf <span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msgbuf</span> buf1 <span class="token punctuation">;</span>
    <span class="token keyword">int</span> flag <span class="token punctuation">;</span>
    <span class="token keyword">int</span> sendlength<span class="token punctuation">,</span> recvlength <span class="token punctuation">;</span> 

    msqid <span class="token operator">=</span> <span class="token function">msgget</span><span class="token punctuation">(</span> IPC_PRIVATE<span class="token punctuation">,</span> <span class="token number">0666</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> msqid <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"get ipc_id error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    buf<span class="token punctuation">.</span>mtype <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span>mtext<span class="token punctuation">,</span> <span class="token string">"How do you do!"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    sendlength <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    flag <span class="token operator">=</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span> msqid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> sendlength <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> flag <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"send message error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    buf<span class="token punctuation">.</span>mtype <span class="token operator">=</span> <span class="token number">3</span> <span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span>mtext<span class="token punctuation">,</span> <span class="token string">"good bye vico!"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    sendlength <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    flag <span class="token operator">=</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span> msqid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> sendlength <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> flag <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"send message error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 

    flag <span class="token operator">=</span> <span class="token function">msgctl</span><span class="token punctuation">(</span> msqid<span class="token punctuation">,</span> IPC_STAT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>info <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> flag <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"get message status error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"uid:%d, gid = %d, cuid = %d, cgid= %d\n"</span> <span class="token punctuation">,</span>info<span class="token punctuation">.</span>msg_perm<span class="token punctuation">.</span>uid<span class="token punctuation">,</span>  info<span class="token punctuation">.</span>msg_perm<span class="token punctuation">.</span>gid<span class="token punctuation">,</span>  info<span class="token punctuation">.</span>msg_perm<span class="token punctuation">.</span>cuid<span class="token punctuation">,</span>  info<span class="token punctuation">.</span>msg_perm<span class="token punctuation">.</span>cgid  <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read-write:%03o, cbytes = %lu, qnum = %lu, qbytes= %lu\n"</span> <span class="token punctuation">,</span>info<span class="token punctuation">.</span>msg_perm<span class="token punctuation">.</span>mode<span class="token operator">&amp;</span><span class="token number">0777</span><span class="token punctuation">,</span> info<span class="token punctuation">.</span>msg_cbytes<span class="token punctuation">,</span> info<span class="token punctuation">.</span>msg_qnum<span class="token punctuation">,</span> info<span class="token punctuation">.</span>msg_qbytes <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"ipcs -q"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

    recvlength <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf1<span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    flag <span class="token operator">=</span> <span class="token function">msgrcv</span><span class="token punctuation">(</span> msqid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf1<span class="token punctuation">,</span> recvlength <span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> flag <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"recv message error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"type=%ld, message=%s\n"</span><span class="token punctuation">,</span> buf1<span class="token punctuation">.</span>mtype<span class="token punctuation">,</span> buf1<span class="token punctuation">.</span>mtext<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    flag <span class="token operator">=</span> <span class="token function">msgctl</span><span class="token punctuation">(</span> msqid<span class="token punctuation">,</span> IPC_RMID<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> flag <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"rm message queue error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"ipcs -q"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/dc/56/Tl3ydiGr_o.png" alt="image.png"></p> 
<h5><a id="32__997"></a>3.2 两个进程间消息队列收发消息</h5> 
<p><strong>发送方：</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">&lt;time.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TEXT_SIZE</span>  <span class="token expression"><span class="token number">512</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">msgbuf</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> mtype <span class="token punctuation">;</span>
    <span class="token keyword">int</span>  status <span class="token punctuation">;</span>
    <span class="token keyword">char</span> time<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span>TEXT_SIZE<span class="token punctuation">]</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>  <span class="token punctuation">;</span>

<span class="token keyword">char</span>  <span class="token operator">*</span><span class="token function">getxttime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> 
    <span class="token class-name">time_t</span>  tv <span class="token punctuation">;</span>
    <span class="token keyword">struct</span>  <span class="token class-name">tm</span>   <span class="token operator">*</span>tmp <span class="token punctuation">;</span>
    <span class="token keyword">static</span>  <span class="token keyword">char</span>  buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
    tv <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    tmp <span class="token operator">=</span> <span class="token function">localtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token string">"%02d:%02d:%02d"</span><span class="token punctuation">,</span>tmp<span class="token operator">-&gt;</span>tm_hour <span class="token punctuation">,</span> tmp<span class="token operator">-&gt;</span>tm_min<span class="token punctuation">,</span>tmp<span class="token operator">-&gt;</span>tm_sec<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span>   buf <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

    <span class="token keyword">int</span> msqid <span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span> info <span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msgbuf</span> buf <span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msgbuf</span> buf1 <span class="token punctuation">;</span>
    <span class="token keyword">int</span> flag <span class="token punctuation">;</span>
    <span class="token keyword">int</span> sendlength<span class="token punctuation">,</span> recvlength <span class="token punctuation">;</span>
    <span class="token keyword">int</span> key <span class="token punctuation">;</span> 

    key <span class="token operator">=</span> <span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"msg.tmp"</span><span class="token punctuation">,</span> <span class="token number">0x01</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> key <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"ftok key error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    msqid <span class="token operator">=</span> <span class="token function">msgget</span><span class="token punctuation">(</span> key<span class="token punctuation">,</span> <span class="token number">0600</span><span class="token operator">|</span>IPC_CREAT <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> msqid <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"create message queue error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    buf<span class="token punctuation">.</span>mtype <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>
    buf<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">9</span> <span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span>time<span class="token punctuation">,</span> <span class="token function">getxttime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span>mtext<span class="token punctuation">,</span> <span class="token string">"Hello world vico!"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    sendlength <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

    flag <span class="token operator">=</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span> msqid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> sendlength <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> flag <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"send message error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    buf<span class="token punctuation">.</span>mtype <span class="token operator">=</span> <span class="token number">3</span> <span class="token punctuation">;</span>
    buf<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">9</span> <span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span>time<span class="token punctuation">,</span> <span class="token function">getxttime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span>mtext<span class="token punctuation">,</span> <span class="token string">"good bye vico!"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    sendlength <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

    flag <span class="token operator">=</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span> msqid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> sendlength <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> flag <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"send message error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"ipcs -q"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

   <span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/16/54/odwyAdWx_o.png" alt="image.png"><br><strong>接收方：</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TEXT_SIZE</span>  <span class="token expression"><span class="token number">512</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">msgbuf</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> mtype <span class="token punctuation">;</span>
    <span class="token keyword">int</span>  status <span class="token punctuation">;</span>
    <span class="token keyword">char</span> time<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span>TEXT_SIZE<span class="token punctuation">]</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>  <span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> msqid <span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span> info <span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msgbuf</span> buf1 <span class="token punctuation">;</span>
    <span class="token keyword">int</span> flag <span class="token punctuation">;</span>
    <span class="token keyword">int</span>  recvlength <span class="token punctuation">;</span>
    <span class="token keyword">int</span> key <span class="token punctuation">;</span>
    <span class="token keyword">int</span> mtype <span class="token punctuation">;</span> 

    key <span class="token operator">=</span> <span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"msg.tmp"</span><span class="token punctuation">,</span> <span class="token number">0x01</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> key <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"ftok key error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    msqid <span class="token operator">=</span> <span class="token function">msgget</span><span class="token punctuation">(</span> key<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> msqid <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"get ipc_id error"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 

    recvlength <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf1<span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    mtype <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>

    flag <span class="token operator">=</span> <span class="token function">msgrcv</span><span class="token punctuation">(</span> msqid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf1<span class="token punctuation">,</span> recvlength <span class="token punctuation">,</span>mtype<span class="token punctuation">,</span><span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> flag <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"recv message error\n"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"type=%ld,time=%s, message=%s\n"</span><span class="token punctuation">,</span> buf1<span class="token punctuation">.</span>mtype<span class="token punctuation">,</span> buf1<span class="token punctuation">.</span>time<span class="token punctuation">,</span>  buf1<span class="token punctuation">.</span>mtext<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"ipcs -q"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

   <span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c0/a5/e5dNjdIy_o.png" alt="image.png"></p> 
<p><strong>备注：删除该消息队列，否则就一直存在于系统当中。另外信号量和共享内存也是随着内核持续存在的。</strong><br><img src="https://images2.imgbox.com/4b/34/8xTfA9dS_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/f4/14/YVV92CzJ_o.png" alt="image.png"></p> 
<h3><a id="_1157"></a>五、共享内存（原理机制）</h3> 
<p>共享内存就是允许两个或多个进程共享一定的存储区。就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变这块地址中内容的时候，其它进程都会察觉到这个更改。因为数据不需要在客户机和服务器端之间复制，数据直接写到内存，不用若干次数据拷贝，所以这是最快的一种IPC。备注：共享内存没有任何的同步与互斥机制，所以要使用信号量来实现对共享内存的存取的同步。 <br>共享内存是IPC通信中<strong>传输速度最快的通信方式</strong>没有之一。共享内存原理结构图如下：<br><img src="https://images2.imgbox.com/9e/92/rn4xdz56_o.png" alt="image.png"></p> 
<p><strong>实现多个进程对共享内存的同步访问？</strong><br>通常使用信号量来实现对共享内存的同步访问控制。</p> 
<p><strong>共享内存有关常用函数：</strong></p> 
<ul><li>shmget(); //创建共享内存，成功返回共享内存的id，错误返回-1</li><li>shmat(); //连接操作，成功返回指向共享内存段的指针，错误返回-1</li><li>shmdt(); //分离操作，成功返回0，错误返回-1</li></ul> 
<p><strong>使用共享内存的优点：</strong><br>共享内存进行进程间的通信非常方便，函数接口非常简单，数据的共享还使进程间的数据不用传递，而是直接内存访问，也加快程序的效率。</p> 
<p><strong>使用共享内存的缺点：</strong><br>共享内存没有提供同步机制，在使用共享内存进行进程间通信时，要借助其他手段来解决同步工作。</p> 
<h2><a id="Linux_1171"></a>Linux内存原理与分析</h2> 
<h3><a id="UMANUMA_1172"></a>一、UMA/NUMA内存结构</h3> 
<p>共享存储型多处理机有两种模型：</p> 
<ul><li>均匀存储器存取（Uniform-Memory-Access，简称UMA）模型</li><li>非均匀存储器存取（Nonuniform-Memory-Access，简称NUMA）模型</li></ul> 
<p><img src="https://images2.imgbox.com/d5/25/l95Ou9zd_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/6d/a6/ezSnVaZc_o.png" alt="image.png"><br>比较典型NUMA服务器：SUN15K、IBMp690等</p> 
<h3><a id="mm_struct_1179"></a>二、mm_struct结构体</h3> 
<p>Linux内核内存管理子系统架构如下图所示，分为用户空间、内核空间和硬件层3个层面。<br><img src="https://images2.imgbox.com/7a/4c/F52l0QWi_o.png" alt="image.png"><br>用户空间：malloc/free–&gt;ptmalloc(glibc)/jemalloc(FreeBSD)/tcmalloc(Google) <br>内核空间：sys_brk、sys_mmap、sys_munmap等等</p> 
<h4><a id="1_1181"></a>1、用户空间</h4> 
<p>应用程序使用malloc()申请内存，使用free()释放内存，malloc()/free()是glibc库的内存分配器ptmalloc提供的接口，ptmalloc使用系统调用brk/mmap向内核以页为单位申请内存，然后划分成小内存块分配给用户应用程序。用户空间的内存分配器，除glibc库的ptmalloc，google的tcmalloc/FreeBSD的jemalloc。</p> 
<h4><a id="2_1183"></a>2、内核空间</h4> 
<p>内核空间的基本功能：虚拟内存管理负责从进程的虚拟地址空间分配虚拟页，sys_brk用来扩大或收缩堆，sys_mmap用来在内存映射区域分配虚拟页，sys_munmap用来释放虚拟页。 <br>页分配器负责分配物理页，当前使用的页分配器是伙伴分配器。内核空间提供把页划分成小内存块分配的块分配器，提供分配内存的接口kmalloc()和释放内存接口kfree()。块分配器：SLAB/SLUB/SLOB。 <br>内核空间的扩展功能：不连续页分配器提供了分配内存的接口vmalloc和释放内存接口vfree，在内存碎片化时，申请连续物理页的成功率很低，可申请不连续的物理页，映射到连续的虚拟页，即虚拟地址连续页物理地址不连续。 <br>连续内存分配器（contiguous memory allocator，CMA）用来给驱动程序预留一段连续的内存，当驱动程序不用的时候，可以给进程使用；当驱动程序需要使用的时候，把进程占用的内存通过回收或迁移的方式让出来，给驱动程序使用。</p> 
<h4><a id="3_1185"></a>3、硬件层面</h4> 
<p>处理器包含一个称为内存管理单元（Memory Management Unit，MMU）的部件，负责把虚拟地址转换成物理地址。内存管理单元包含一个称为页表缓存（Translation Lookaside Buffer，TLB）的部件，保存最近使用的页表映射，避免每次把虚拟地址转换物理地址都需要查询内存中的页表。</p> 
<h4><a id="4_1187"></a>4、虚拟地址空间布局</h4> 
<h5><a id="a_1188"></a>a、虚拟地址空间划分</h5> 
<p><img src="https://images2.imgbox.com/01/4f/9boMZ16h_o.png" alt="image.png"><br>以ARM64处理器为例：虚拟地址 的最大宽度是48位。内核虚拟地址在64位地址空间顶部，高16位全是1，范围是[0xFFFF 0000 0000 0000,0xFFFF FFFF FFFF FFFF]。用户虚拟地址 在64位地址 空间的底部，高16位全是0，范围是[0x0000 0000 0000 0000,0x0000 FFFF FFFF FFFF]。 <br>在编译ARM64架构的Linux内核时，可以选择虚拟地址宽度： <br>a.选择页长度4KB，默认虚拟地址宽度为39位； <br>b.选择页长度16KB，默认虚拟地址宽度为47位； <br>c.选择页长度64KB，默认虚拟地址宽度为42位； <br>d.选择48位虚拟地址。<br>在ARM64架构linux内核中，内核虚拟地址 和 用户虚拟地址宽度相同。所有进程共享内核虚拟地址空间，每个进程有独立的用户虚拟地址空间，同一个线程组的用户线程共享用户虚拟地址空间，内核线程没有用户虚拟地址空间。</p> 
<h5><a id="b_1190"></a>b、用户虚拟地址空间布局</h5> 
<p>进程的用户虚拟地址空间的起始地址是0，长度是TASK_SIZE，由每种处理器架构定义自己的宏TASK_SIZE。ARM64架构定义宏TASK_SIZE如下所示：</p> 
<ul><li>32位用户空间程序：TASK_SIZE的值是TASK_SIZE_32，即0x10000000，等于4GB。</li><li>64位用户空间程序：TASK_SIZE的值是TASK_SIZE_64，即2的VA_BITS次方字节，VA_BITS是编译内核时选择的虚拟地址位数。</li></ul> 
<p><img src="https://images2.imgbox.com/64/44/StLpp0BN_o.png" alt="image.png"></p> 
<p>Linux内核使用内存描述符mm_struct描述进程的用户虚拟地址空间，主要核心成员如下：</p> 
<pre><code class="prism language-c"><span class="token comment">// 内存描述符结构体类型(今后要用的主要成员)</span>
<span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>mmap<span class="token punctuation">;</span>		<span class="token comment">/* list of VMAs */</span> 	<span class="token comment">//虚拟内存区域链表</span>
	<span class="token keyword">struct</span> <span class="token class-name">rb_root</span> mm_rb<span class="token punctuation">;</span>	<span class="token comment">//虚拟内存区域红黑树</span>
	u32 vmacache_seqnum<span class="token punctuation">;</span>                   <span class="token comment">/* per-thread vmacache */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_MMU</span></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>get_unmapped_area<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span>
				<span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span>
				<span class="token keyword">unsigned</span> <span class="token keyword">long</span> pgoff<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//在内存映射区域找到一个没有映射的区域</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> mmap_base<span class="token punctuation">;</span>		<span class="token comment">/* base of mmap area */</span>	<span class="token comment">//内存映射区域的起始地址</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> mmap_legacy_base<span class="token punctuation">;</span>         <span class="token comment">/* base of mmap area in bottom-up allocations */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES</span></span>
	<span class="token comment">/* Base adresses for compatible mmap() */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> mmap_compat_base<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> mmap_compat_legacy_base<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> task_size<span class="token punctuation">;</span>		<span class="token comment">/* size of task vm space */</span>	<span class="token comment">//用户虚拟地址空间的长度</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> highest_vm_end<span class="token punctuation">;</span>		<span class="token comment">/* highest vma end address */</span>
	<span class="token class-name">pgd_t</span> <span class="token operator">*</span> pgd<span class="token punctuation">;</span>	<span class="token comment">//指向页的全局目录, 即第一级页表</span>

	<span class="token comment">/**
	 * @mm_users: The number of users including userspace.
	 *
	 * Use mmget()/mmget_not_zero()/mmput() to modify. When this drops
	 * to 0 (i.e. when the task exits and there are no other temporary
	 * reference holders), we also release a reference on @mm_count
	 * (which may then free the &amp;struct mm_struct if @mm_count also
	 * drops to 0).
	 */</span>
	<span class="token class-name">atomic_t</span> mm_users<span class="token punctuation">;</span>	<span class="token comment">//共享同一个用户虚拟地址空间的进程数量, 也就是线程组包含的进程的数量</span>

	<span class="token comment">/**
	 * @mm_count: The number of references to &amp;struct mm_struct
	 * (@mm_users count as 1).
	 *
	 * Use mmgrab()/mmdrop() to modify. When this drops to 0, the
	 * &amp;struct mm_struct is freed.
	 */</span>
	<span class="token class-name">atomic_t</span> mm_count<span class="token punctuation">;</span>	<span class="token comment">//内存描述符的引用计数</span>

	<span class="token class-name">atomic_long_t</span> nr_ptes<span class="token punctuation">;</span>			<span class="token comment">/* PTE page table pages */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">CONFIG_PGTABLE_LEVELS <span class="token operator">&gt;</span> <span class="token number">2</span></span></span>
	<span class="token class-name">atomic_long_t</span> nr_pmds<span class="token punctuation">;</span>			<span class="token comment">/* PMD page table pages */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">int</span> map_count<span class="token punctuation">;</span>				<span class="token comment">/* number of VMAs */</span>

	<span class="token class-name">spinlock_t</span> page_table_lock<span class="token punctuation">;</span>		<span class="token comment">/* Protects page tables and some counters */</span>
	<span class="token keyword">struct</span> <span class="token class-name">rw_semaphore</span> mmap_sem<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> mmlist<span class="token punctuation">;</span>		<span class="token comment">/* List of maybe swapped mm's.	These are globally strung
						 * together off init_mm.mmlist, and are protected
						 * by mmlist_lock
						 */</span>


	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> hiwater_rss<span class="token punctuation">;</span>	<span class="token comment">/* High-watermark of RSS usage */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> hiwater_vm<span class="token punctuation">;</span>	<span class="token comment">/* High-water virtual memory usage */</span>

	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_vm<span class="token punctuation">;</span>		<span class="token comment">/* Total pages mapped */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> locked_vm<span class="token punctuation">;</span>	<span class="token comment">/* Pages that have PG_mlocked set */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> pinned_vm<span class="token punctuation">;</span>	<span class="token comment">/* Refcount permanently increased */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> data_vm<span class="token punctuation">;</span>		<span class="token comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> exec_vm<span class="token punctuation">;</span>		<span class="token comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_vm<span class="token punctuation">;</span>		<span class="token comment">/* VM_STACK */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> def_flags<span class="token punctuation">;</span>
	<span class="token comment">// 代码段/数据段的起始地址和结束地址</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">,</span> end_code<span class="token punctuation">,</span> start_data<span class="token punctuation">,</span> end_data<span class="token punctuation">;</span>
	<span class="token comment">// 堆的起始地址和结束地址 栈的起始地址</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_brk<span class="token punctuation">,</span> brk<span class="token punctuation">,</span> start_stack<span class="token punctuation">;</span>
	<span class="token comment">// 参数字符串起始地址和结束地址 环境变量的起始地址和结束地址</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg_start<span class="token punctuation">,</span> arg_end<span class="token punctuation">,</span> env_start<span class="token punctuation">,</span> env_end<span class="token punctuation">;</span>

	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> saved_auxv<span class="token punctuation">[</span>AT_VECTOR_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* for /proc/PID/auxv */</span>

	<span class="token comment">/*
	 * Special counters, in some configurations protected by the
	 * page_table_lock, in other configurations by being atomic.
	 */</span>
	<span class="token keyword">struct</span> <span class="token class-name">mm_rss_stat</span> rss_stat<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token operator">*</span>binfmt<span class="token punctuation">;</span>

	<span class="token class-name">cpumask_var_t</span> cpu_vm_mask_var<span class="token punctuation">;</span>

	<span class="token comment">/* Architecture-specific MM context */</span>
	<span class="token class-name">mm_context_t</span> context<span class="token punctuation">;</span>	<span class="token comment">// 处理器架构特定的内存管理上下文</span>

	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span> <span class="token comment">/* Must use atomic bitops to access the bits */</span>

	<span class="token keyword">struct</span> <span class="token class-name">core_state</span> <span class="token operator">*</span>core_state<span class="token punctuation">;</span> <span class="token comment">/* coredumping support */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_AIO</span></span>
	<span class="token class-name">spinlock_t</span>			ioctx_lock<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">kioctx_table</span> __rcu	<span class="token operator">*</span>ioctx_table<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_MEMCG</span></span>
	<span class="token comment">/*
	 * "owner" points to a task that is regarded as the canonical
	 * user/owner of this mm. All of the following must be true in
	 * order for it to be changed:
	 *
	 * current == mm-&gt;owner
	 * current-&gt;mm != mm
	 * new_owner-&gt;mm == mm
	 * new_owner-&gt;alloc_lock is held
	 */</span>
	<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu <span class="token operator">*</span>owner<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">user_namespace</span> <span class="token operator">*</span>user_ns<span class="token punctuation">;</span>

	<span class="token comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span> __rcu <span class="token operator">*</span>exe_file<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_MMU_NOTIFIER</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">mmu_notifier_mm</span> <span class="token operator">*</span>mmu_notifier_mm<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_TRANSPARENT_HUGEPAGE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>USE_SPLIT_PMD_PTLOCKS</span></span>
	<span class="token class-name">pgtable_t</span> pmd_huge_pte<span class="token punctuation">;</span> <span class="token comment">/* protected by page_table_lock */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_CPUMASK_OFFSTACK</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">cpumask</span> cpumask_allocation<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_NUMA_BALANCING</span></span>
	<span class="token comment">/*
	 * numa_next_scan is the next time that the PTEs will be marked
	 * pte_numa. NUMA hinting faults will gather statistics and migrate
	 * pages to new nodes if necessary.
	 */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> numa_next_scan<span class="token punctuation">;</span>

	<span class="token comment">/* Restart point for scanning and setting pte_numa */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> numa_scan_offset<span class="token punctuation">;</span>

	<span class="token comment">/* numa_scan_seq prevents two threads setting pte_numa */</span>
	<span class="token keyword">int</span> numa_scan_seq<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_NUMA_BALANCING<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_COMPACTION<span class="token punctuation">)</span></span></span>
	<span class="token comment">/*
	 * An operation with batched TLB flushing is going on. Anything that
	 * can move process memory needs to flush the TLB when moving a
	 * PROT_NONE or PROT_NUMA mapped page.
	 */</span>
	bool tlb_flush_pending<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">uprobes_state</span> uprobes_state<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_HUGETLB_PAGE</span></span>
	<span class="token class-name">atomic_long_t</span> hugetlb_usage<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">work_struct</span> async_put_work<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="c_1350"></a>c、进程的进程描述和内存描述符关系如下图所示：</h5> 
<p><img src="https://images2.imgbox.com/26/36/L2etwbvd_o.png" alt="image.png"><br>进程描述符的成员 <br>struct mm_struct *mm; // 进程的mm指向一个内存描述符，内核线程没有用户虚拟地址空间，所以mm是空指针。 <br>struct mm_struct *active_mm; // 进程的active_mm和mm总是指向一个内存描述符，内核线程的active_mm在没有运行时是空指针，在运行时指向上一个进程借用的内存描述符<br><img src="https://images2.imgbox.com/e6/2b/KgowkP3d_o.png" alt="image.png"></p> 
<h5><a id="d_1352"></a>d、内核地址空间布局</h5> 
<p>ARM64处理器架构的内核地址空间布局如下：<br><img src="https://images2.imgbox.com/1e/a8/TvbEcQ1m_o.png" alt="image.png"></p> 
<h3><a id="TLB_1354"></a>三、TLB工作原理</h3> 
<p>处理器的内存管理单元（Memory Management Unit，MMU）负责把虚拟地址转换成物理地址，为了改进虚拟地址到物理地址的转换速度，避免每次转换都需要查找内存中的页表，处理器厂商在内存管理单元里面增加一个称为TLB （Translation Lookaside Buffer，TLB）的高速缓存，TLB直接为转换后备缓冲区，意译为页表缓存。</p> 
<h4><a id="1TLB_1356"></a>1、TLB表项格式</h4> 
<p>不同处理器架构的TLB表项的格式不同，ARM64处理器的每条TLB表项不仅包含虚拟地址和物理地址，也包含属性：内存类型、缓存策略、访问权限、地址空间标识符（ASID）和虚拟机标识符（VMID）。</p> 
<h4><a id="2TLB_1358"></a>2、TLB管理</h4> 
<p>如果内核修改了可能缓存在TLB里面的页表项，那么内核必须负责使旧的TLB表项失效，内核定义每种处理器架构必须实现的函数如下：</p> 
<pre><code class="prism language-c"><span class="token comment">// 使所有tlb表项失效</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">flush_tlb_all</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	<span class="token function">dsb</span><span class="token punctuation">(</span>ishst<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">__tlbi</span><span class="token punctuation">(</span>vmalle1is<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">dsb</span><span class="token punctuation">(</span>ish<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">isb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使指定用户地址空间的所有tlb表项失效, 参数mm是进程的内存描述符</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">flush_tlb_mm</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> asid <span class="token operator">=</span> <span class="token function">ASID</span><span class="token punctuation">(</span>mm<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">48</span><span class="token punctuation">;</span>

	<span class="token function">dsb</span><span class="token punctuation">(</span>ishst<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">__tlbi</span><span class="token punctuation">(</span>aside1is<span class="token punctuation">,</span> asid<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">dsb</span><span class="token punctuation">(</span>ish<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使指定用户地址空间的某个范围tlb表项进行失效, 参数vma是虚拟内存区域, start是起始地址, end是结束地址</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">flush_tlb_range</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">,</span>
				   <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">__flush_tlb_range</span><span class="token punctuation">(</span>vma<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使指定用户地址空间里面的指定虚拟页的tlb表项失效, 参数vma是虚拟内存区域, uaddr是虚拟页中的任意虚拟地址</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">flush_tlb_page</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">,</span>
				  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> uaddr<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr <span class="token operator">=</span> uaddr <span class="token operator">&gt;&gt;</span> <span class="token number">12</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token function">ASID</span><span class="token punctuation">(</span>vma<span class="token operator">-&gt;</span>vm_mm<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">dsb</span><span class="token punctuation">(</span>ishst<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">__tlbi</span><span class="token punctuation">(</span>vale1is<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">dsb</span><span class="token punctuation">(</span>ish<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使内核的某个虚拟地址范围的tlb表项失效, 参数start是起始地址, end是结束地址 </span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">flush_tlb_kernel_range</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> start<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&gt;</span> MAX_TLB_RANGE<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">flush_tlb_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	start <span class="token operator">&gt;&gt;=</span> <span class="token number">12</span><span class="token punctuation">;</span>
	end <span class="token operator">&gt;&gt;=</span> <span class="token number">12</span><span class="token punctuation">;</span>

	<span class="token function">dsb</span><span class="token punctuation">(</span>ishst<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>addr <span class="token operator">=</span> start<span class="token punctuation">;</span> addr <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> addr <span class="token operator">+=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>PAGE_SHIFT <span class="token operator">-</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">__tlbi</span><span class="token punctuation">(</span>vaae1is<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">dsb</span><span class="token punctuation">(</span>ish<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">isb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="3ARM64TLB_1418"></a>3、ARM64架构TLB失效指令：</h4> 
<p>TLB[IS]{,}</p> 
<ul><li>type: 
  <ul><li>ALL（所有表项）</li><li>VMALL（当前虚拟机的阶段1的所有表项，即表项的VMID是当前虚拟机的VMID）。虚拟机里面运行的客户操作系统的虚拟地址 转换成物理地址分两个阶段：1把虚拟地址转换成中间物理地址；2把中间物理地址 转换成物理地址。</li></ul> </li><li>level（指定异常级别）： 
  <ul><li>E1:异常级别1</li><li>E2:异常级别2</li><li>E3:异常级别3</li></ul> </li><li>IS表示内存共享（inner Shareable），多个核共享。如果不使用字段IS，表示非共享，只被一个核使用。在SMP系统中，如果指令TLBI不携带字段IS，仅仅使当前核的TLB表项失效；如果指令TLBI携带字段IS，表示使所有核的TLB表项失效。</li><li>选项Xt是X0-X31中的任何一个寄存器。</li></ul> 
<p>flush_tlb_all用来使所有核的所有TLB失效，内核代码如下：<br><img src="https://images2.imgbox.com/9b/18/JAaZPqi3_o.png" alt="image.png"></p> 
<ul><li>dsb(ishst):确保屏障前面的存储指令执行完毕，dsb是数据同步屏障，ishst中ish表示共享域是内部共享，st表示存储 ，ishst表示数据同步屏障指令对所有核的存储指令起作用。</li><li>__tlbi(vmalle1is):使用所有核上匹配当前VMID、阶段1和异常级别1的所有TLB表项失效。</li><li>dsb(ish):确保当前的TLB失效指令执行完毕，ish表示数据同步屏障指令对所有核起作用。</li><li>isb():isb是指令同步屏障，这条指令冲刷处理器流水线，重新读取屏障指令后面的所有指令。</li></ul> 
<h4><a id="4_1438"></a>4、地址空间标识符</h4> 
<p>为了减少在进程切换时清空页表缓存的需要，ARM64处理器的页表缓存使用非全局位区分内核和进程的页表项，使用地址空间标识符（Address Space Identifier，ASID）区分不同进程的页表项。</p> 
<h4><a id="5_1441"></a>5、虚拟机标识符</h4> 
<p>虚拟机里面运行的客户OS的虚拟地址转换成物理地址 分为两个阶段： <br>a.把虚拟地址转换成中间物理地址（由客户操作系统的内核控制，和非虚拟化的转换过程相同）； <br>b.把中间物理地址转换成物理地址（由虚拟机监控器控制，虚拟机监控器为每个虚拟机维护一个转换表，分配一个虚拟机标识符VMID(Virutal machine identifier)）；<br>每个虚拟机有独立的ASID空间，页表缓存使用虚拟标识 符区别不同虚拟机转换表项，可以避免每次虚拟机切换都要清空页表缓存，只需要在虚拟机标识符回绕时把处理器的页表缓存清空。</p> 
<h3><a id="_1444"></a>四、页表</h3> 
<p>层次化的页表用于支持对大地址空间的快速、高效的管理。页表用于建立用户进程的虚拟地址空间和系统物理内存（内存、页帧）之间的关联。页表用来把虚拟页映射到物理页，并且存放页的保护位，即访问权限。Linux内核把页表分为4级： <br>PGD、PUD、PMD、PT。</p> 
<ul><li>PGD（Page Global Directory）–&gt;页全局目录</li><li>PUD（Page Upper Directory）–&gt;页上层目录</li><li>PMD（Page Middle Directory）–&gt;页中间目录</li><li>PT（Page Table）–&gt;直接页表</li></ul> 
<p>4.11以后版本把页表扩展到五级，在页全局目录和页上层目录之间增加了页四级目录（Page 4th Directory，P4D） <br>选择四级页表：页全局目录、页上层目录、页中间目录、直接页表； <br>选择三级页表：页全局目录、页中间目录、直接页表； <br>选择二级页表：页全局目录、直接页表； <br>处理器架构怎么选择多少级？在内核配置宏CONFIG_PGTABLE_LEVELS配置页表级数，</p> 
<p>案例分析五级页表结构如下：<br><img src="https://images2.imgbox.com/cd/fa/RTmn81La_o.png" alt="image.png"></p> 
<h2><a id="Linux_1455"></a>Linux物理内存与虚拟内存管理</h2> 
<h3><a id="_1456"></a>一、伙伴分配器</h3> 
<p>内核初始化完毕后，使用页分配器管理物理页，当前使用的页分配器就是伙伴分配器，伙伴分配器的特点是管理算法简单且高效。</p> 
<h4><a id="1_1458"></a>1、基本伙伴分配器</h4> 
<p>连续的物理页称为页块（page block），阶（order）是页的数量单位，2的n次方个连续页称为n阶页块，满足如下条件的两个n阶页块称为伙伴（buddy）。 <br>1）两个页块是相邻的，即物理地址是连续的； <br>2）页块的第一页的物理面页号必须是2的n次方的整数倍； <br>3）如果合并（n+1）阶页块，第一页的物理页号必须是2的括号(n+1)次方的整数倍。 <br>伙伴分配器分配和释放物理页的数量单位也为阶（order）。 <br>以单页为说明，0号页和1号页是伙伴，2号页和3号页是伙伴。1号页和2号页不是伙伴？因为1号页和2号页合并组成一阶页块，第一页的物理页号不是2的整数倍。</p> 
<p>分配n阶页块的过程：<br>a. 查看是否有空闲的n阶页块，如果有，直接分配，如果没有，继续执行下一步；<br>b. 查看是否存在空闲的(n+1)阶页块，如果有把(n+1)阶页块分裂为两个n阶页块，一个插入空闲n阶页块链表，另一个分配出去，如果没有，继续执行下一步；<br>c. 查看是否存在空闲的(n+2)阶页块，如果有，把(n+2)阶页块分裂为两个(n+1)阶页块，一个插入空闲(n+1)阶页块链表，另一个分裂为两个n阶页块，一个插入空闲n阶页块链表，另一个分配出去；如果没有继续查看更高阶是否存在空闲页块。</p> 
<p>内核在基本伙伴分配器基础上进一步扩展：<br>a. 支持内存节点和区域，称为分区的伙伴分配器；<br>b. 为预防内存碎片，把物理页根据可移动性分组；<br>c. 针对分配单页做性能优化，为减少处理器之间的锁竞争，在内存区域增加1个每处理器页集合。</p> 
<h4><a id="2_1464"></a>2、分区伙伴分配器</h4> 
<p>内存区域的结构体成员free_area用来维护空闲页块，数组下标对应页块的阶数。结构体free_area的成员free_list是空闲页块的链表，nr_free是空闲页块的数量。内存区域的结构体成员managed_pages是伙伴分配器管理的物理页的数量。</p> 
<h5><a id="21_1466"></a>2.1）内存区域数据结构分析如下：</h5> 
<pre><code class="prism language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_FORCE_MAX_ZONEORDER</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_ORDER</span> <span class="token expression"><span class="token number">11</span></span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    

<span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* Read-mostly fields */</span>
	<span class="token comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> watermark<span class="token punctuation">[</span>NR_WMARK<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_reserved_highatomic<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> managed_pages<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> spanned_pages<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> present_pages<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 	<span class="token comment">/* free areas of different sizes */</span>
 	<span class="token comment">// MAX_ORDER是最大阶数, 实际上是可分配的最大除数加1, 默认值是11, 意味伙伴分配器一次 最多可分配2的10次方页   </span>
 	<span class="token keyword">struct</span> <span class="token class-name">free_area</span> free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>
 	bool contiguous<span class="token punctuation">;</span>
 	<span class="token function">ZONE_PADDING</span><span class="token punctuation">(</span>_pad3_<span class="token punctuation">)</span>
     <span class="token comment">/* Zone statistics */</span>
 	<span class="token class-name">atomic_long_t</span> vm_stat<span class="token punctuation">[</span>NR_VM_ZONE_STAT_ITEMS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> ____cacheline_internodealigned_in_smp<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/78/28/tUxi7XSW_o.png" alt="image.png"></p> 
<h5><a id="22_1494"></a>2.2）区域水线数据结构分析</h5> 
<p>首选的内存区域在什么情况下从备用区域借用物理页？此问题从区域水线讲解深入理解，每个内存区域有3个水线。 <br>a.高水线（HIGH）：如果内存区域的空闲页数大于高水线，说明该内存区域的内存充足； <br>b.低水线（LOW）：如果内存区域的空闲页数小于低水线，说明该内存区域的内存轻微不足； <br>c.最低水线（MIN）：如果内存区域空闲页数小于最低水线，说明该内存区域的内存严重不足。<br><img src="https://images2.imgbox.com/a1/01/GxUBn7ba_o.png" alt="image.png"></p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* Read-mostly fields */</span>
	<span class="token comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> watermark<span class="token punctuation">[</span>NR_WMARK<span class="token punctuation">]</span><span class="token punctuation">;</span>	
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token class-name">atomic_long_t</span> vm_stat<span class="token punctuation">[</span>NR_VM_ZONE_STAT_ITEMS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> ____cacheline_internodealigned_in_smp<span class="token punctuation">;</span>
</code></pre> 
<p><strong>计算水线时，有两个重要的参数：</strong></p> 
<ol><li>min_free_kbytes是最小空闲字节数，默认值是4*pow(lowmem_kbytes, 1/2)，并且限制范围是由机器决定。lowmem_kbytes是低端内存大小，单位是kb。</li></ol> 
<p>修改最小空闲字节数方式：</p> 
<pre><code class="prism language-c">cat <span class="token operator">/</span>proc<span class="token operator">/</span>sys<span class="token operator">/</span>vm<span class="token operator">/</span>min_free_kbytes
</code></pre> 
<ol start="2"><li>watermark_scale_factor是水线缩放因子，默认值是10，取值范围[1, 1000]</li></ol> 
<p>修改水线缩放因子方式：</p> 
<pre><code class="prism language-c">cat <span class="token operator">/</span>proc<span class="token operator">/</span>sys<span class="token operator">/</span>vm<span class="token operator">/</span>watermark_cacle_factor
</code></pre> 
<p><strong>通过函数__setup_per_zone_wmarks()负责计算每个内存区域的最低水线、低水线和高水线。</strong></p> 
<p><strong>计算最低水线方法：</strong><br>min_free_pages=min_free_kbytes对应的页数。<br>lowmem_pages=所有低端内存区域伙伴分配器管理的页数总和。<br>高端内存区域最低水线=zone-&gt;managed_pages/1024。<br>低端内存区域最低水线=min_free_pages*zone-&gt;managed_pages/lowmem_pages。</p> 
<p><strong>计算低水线和高水线方法：</strong><br>增量=(最低水线/4, managed_pages<em>watermark_scale_factor/10000) 取得最大值<br>低水线=最低水线+增量<br>高水线=最低水线+增量</em>2<br>如果(最低水线/4)比较大，那么计算公式简化为：<br>低水线=最低水线<em>5/4<br>高水线=最低水线</em>3/2</p> 
<h3><a id="SlabSlubSlob_1527"></a>二、Slab/Slub/Slob块分配器</h3> 
<h4><a id="1_1528"></a>1、基本概念</h4> 
<p>Buddy提供以page为单位的内存分配接口，这对内核来说颗粒度还太大，所以需要一种新的机制，将page拆分为更小的单位来管理。 <br>Linux中支持的主要有：slab、slub、slob。其中slob分配器的总代码量比较少，但分配速度不是最高效的，所以不是为大型系统设计，适合内存紧张的嵌入式系统。</p> 
<h4><a id="2slab_1530"></a>2、slab块分配器原理</h4> 
<p>slab分配器的作用不仅仅是分配小块内存，更重要的作用是针对经常分配和释放的对象充当缓存。slab分配器的核心思路是：为每种对象类型创建一个内存缓存，每个内存缓存由多个大块组成，一个大块是由一个或多个连续的物理页，每个大块包含多个对象。slab采用面向对象的思想，基于对象类型管理内存，每种对象被划分为一类，比如进程描述符task_struct是一个类，每个进程描述符实例是一个对象。如下图所示为内存缓存的组成结构：<br><img src="https://images2.imgbox.com/50/76/IEIHOhWs_o.png" alt="image.png"><br>slab分配器在某些情况下表现不太优先，所以Linux内核提供两个改进的块分配器。</p> 
<ul><li>在配备大量物理内存的大型计算机上，slab分配器的管理数据结构的内存开销比较大，所以设计了slub分配器；</li><li>在小内存的嵌入式设备上，slab分配器的代码过多、相当复杂，所以设计一个精简slob分配器。</li></ul> 
<p>目前slub分配器已成为默认的块分配器。</p> 
<h4><a id="3_1537"></a>3、系统编程接口</h4> 
<p>通用的内存缓存的编程接口如下： <br>a. 分配内存kmalloc；</p> 
<pre><code class="prism language-c">kmalloc（<span class="token class-name">size_t</span> size<span class="token punctuation">,</span><span class="token class-name">gfp_t</span> flags） 
</code></pre> 
<p>b. 重新分配内存krealloc;</p> 
<pre><code class="prism language-c"><span class="token function">krealloc</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token class-name">size_t</span> new_size<span class="token punctuation">,</span><span class="token class-name">gpf_t</span> flags<span class="token punctuation">)</span>
</code></pre> 
<p>c. 释放内存kfree;</p> 
<pre><code class="prism language-c"><span class="token function">kfree</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>objp<span class="token punctuation">)</span>
</code></pre> 
<p>创建专用的内存缓存编程接口如下：<br>a. 创建内存缓存kmem_cache_create <br>b. 指定内存缓存分配kmem_cache_alloc <br>c. 释放对象kmem_cache_free <br>d. 销毁内存缓存keme_cache_destroy</p> 
<h4><a id="4_1552"></a>4、内存缓存的数据结构</h4> 
<p><img src="https://images2.imgbox.com/c1/40/Nd6vY9B3_o.png" alt="image.png"><br>内存缓存的数据结构如下图所示：<br><img src="https://images2.imgbox.com/b2/74/Nq5IV96Z_o.png" alt="image.png"><br><strong>slab分配器 数据结构</strong><br>a. 每一个内存缓存对应一个kmem_cache实例<br>b. 每一个内存节点对应一个kmem_cache_node实例</p> 
<p>每个slab由一个或多个连续的物理页组成，页的阶数是kmem_cache.gfporder，如果阶数大于0，组成一个复合页，slab被划分为多个对象，大多数情况下slab长度不是对象长度的整数倍，slab有剩余部分，可以用来给slab进行着色。着色：把slab的第一个对象从slab的起始位置偏移一个数值，偏移值是处理器的一级缓存行长度的整数倍，不同slab的偏移值不同，使用不同slab的对象映射到处理器不同的缓存行。</p> 
<h4><a id="5slab_1556"></a>5、计算slab长度及着色</h4> 
<p>a. 计算slab <br>函数calculate_slab_order负责计算slab长度，从0阶到kmalloc()函数支持最大阶数KMALLOC_MAX_ORDER。<br><img src="https://images2.imgbox.com/e4/ce/ndoqvLAR_o.png" alt="image.png"><br>如果阶数大于或等于允许的最大slab阶数，那么选择这个阶数，尽量选择低的阶数，因为申请高阶页块成功的概率低。如果剩余长度小于或等于slab长度的1/8，那么选择这个阶数。slab_max_order：允许的最大slab阶数，如果内存容量大于32MB，那么默认值是0，否则值为0，通过内核参数slab_max_order指定。</p> 
<p>b.着色 <br>slab是一个或多个连续的物理页，起始地址总是页长度的整数倍，不同slab中相同偏移的位置在处理器一级缓存中的索引相同。如果slab的剩余部分的长度超过一级缓存行的长度，剩余部分对应的一级缓存行没有被利用；如果对象的填充字节的长度超过一级缓存行的长度，填充字节对应的一级缓存行没有被利用。这两种情况导致处理器的某些缓存行被过度使用，另一些缓存行很少使用。</p> 
<h4><a id="6_1561"></a>6、每处理器数组缓存</h4> 
<p>内存缓存为每个处理器创建一个数组缓存（结构体array_cahce）。释放对象时，把对象存放到当前处理器对应的数组缓存中；分配对象的时候，先从当前处理器的数组缓存分配对象，采用后进先出（Last In First Out，LIFO）的原则，这种做可以提高性能。<br><img src="https://images2.imgbox.com/0e/86/kNBL80dY_o.png" alt="image.png"><br>每处理器数组缓存：</p> 
<ol><li>刚释放的对象很可能还在处理器缓存中，可以更好地利用处理器缓存</li><li>减少链表操作</li><li>避免处理器之间的互斥，减少自旋锁操作</li></ol> 
<p><img src="https://images2.imgbox.com/40/ce/1MfH64nN_o.png" alt="image.png"></p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">array_cache</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> avail<span class="token punctuation">;</span>	<span class="token comment">//数组存放的对象的数量</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> limit<span class="token punctuation">;</span> <span class="token comment">//数组的大小, 和结构体kmem_cache成员limit值相同, 根据对象长度猜测一个值</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> batchcount<span class="token punctuation">;</span>	<span class="token comment">//批量值, 和结构体kmem_cache成员batchcount值相同, 批量值是数组大小的一半</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> touched<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>entry<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">/*
			 * Must have this definition in here for the proper
			 * alignment of array_cache. Also simplifies accessing
			 * the entries.
			 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="7slabNUMA_1582"></a>7、slab分配器支持NUMA体系结构</h4> 
<p>内存缓存针对每个内存节点创建一个kmem_cache_node实例。<br><img src="https://images2.imgbox.com/70/5d/GvLvc8ie_o.png" alt="image.png"></p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>node<span class="token punctuation">[</span>MAX_NUMNODES<span class="token punctuation">]</span><span class="token punctuation">;</span>	
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>kmem_cache_node实例的成员shared指向共享数组缓存，成员alien指向远程节点数组缓存，每个节点一个远程节点数组缓存。</p> 
<p>分配和释放本地内存节点的对象时，也会使用共享数组缓存<br>a. 申请分配对象时，如果当前处理器的数组缓存是空的，共享数组缓存里面的对象可以用来重填；<br>b. 释放对象时，如果当前处理器的数组缓存是满的，并且共享数组缓存有空闲空间，可以转移一部分对象到共享数组缓存，不需要把对象批量还给slab，然后把正在释放的对象添加到当前处理器的数组缓存中。</p> 
<h4><a id="8_1594"></a>8、回收内存</h4> 
<p>对于所有对象空闲的slab，没有立即释放，而是放在空闲slab链表中。只有内存节点上空闲对象的数量超过限制，才开始回收空闲slab，直到空闲对象的数量小于或等于限制。 <br>结构体kmem_cache_node的成员slabs_free是空闲slab链表的头节点，成员free_objects是空闲对象的数量，成员free_limit是空闲对象的数量限制。<br><img src="https://images2.imgbox.com/99/5e/1l4UtJKA_o.png" alt="image.png"><br>节点x的空闲对象的数量限制=（1+节点的处理器数量）*keme_cache.batchcount+kmem_cache.num<br> <br>每个处理器每隔2秒针对每个内存缓存执行<br>a. 回收节点x对应的远程节点数组缓存中的对象<br>b. 如果过去2秒没有从当前处理器的数组缓存分配对象，那么回收数组缓存中的对象。</p> 
<h3><a id="_1596"></a>三、不连续页分配器</h3> 
<p>当设备长时间运行后，内存碎片化，很难找到连续的物理页。在这种情况下，如果需要分配长度超过一页的内存块，可以使用不连续页分配器，分配虚拟地址连续但是物理地址不连续的内存块。在32位系统中不连续分配器还有一个好处：优先从高端内存区域分配页，保留稀缺的低端内存区域。</p> 
<h4><a id="1_1598"></a>1、系统编程接口</h4> 
<h5><a id="a_1599"></a>a.不连续页分配器提供的编程接口：</h5> 
<ul><li>vmalloc:分配不连续的物理页并且把物理页映射到连续的虚拟地址空间</li><li>vfree:释放vmalloc分配的物理页和虚拟地址空间</li><li>vmap:把已经分配的不连续物理页映射到连续的虚拟地址空间</li><li>vunmap:释放使用vmap分配的虚拟地址空间</li></ul> 
<h5><a id="b_1606"></a>b.内核提供函数接口：</h5> 
<ul><li>kvmalloc：首先尝试使用kmalloc分配内存块，如果失败，那么使用vmalloc函数分配不连续的物理页</li><li>kvfree：如果内存块是使用vmalloc分配的，那么使用vfree释放，否则使用kfree释放</li></ul> 
<h4><a id="2_1611"></a>2、数据结构</h4> 
<p>不连续页分配器的数据结构关系如下：<br><img src="https://images2.imgbox.com/ef/3f/105tg2lD_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/59/4d/uB99fPr6_o.png" alt="image.png"><br>每个虚拟内存区域对应一个vmap_area实例； <br>每个vmap_area实例关联一个vm_struct实例；</p> 
<h4><a id="3_1614"></a>3、技术原理</h4> 
<p>vmalloc虚拟地址空间的范围是（VMALLOC_START,VMALLOC_END），每种处理器架构都需要定义这两个宏。如ARM64架构定义宏如下：<br><img src="https://images2.imgbox.com/7f/3f/xHnL5mu9_o.png" alt="image.png"><br>vmalloc函数执行过程： <br>a.分配虚拟内存区域 <br>b.分配物理页 <br>c.在内核的页表中把虚拟页映射到物理页</p> 
<h2><a id="LinuxAPI_1616"></a>Linux虚拟内存及API系统调用</h2> 
<h3><a id="_1617"></a>一、内存映射原理与创建/删除映射</h3> 
<p>内存映射是在进程的虚拟地址空间中创建一个映射，可为分两种：</p> 
<ul><li>文件映射：文件支持的内存映射，把文件的一个区间映射到进程的虚拟地址空间，数据源是存储设备上的文件。</li><li>匿名映射：没有文件支持的内存映射，把物理内存映射到进程的虚拟地址空间，没有数据源。</li></ul> 
<p>通常把文件映射的物理页称为文件页，把匿名映射的物理页称为匿名页。 <br>【内存映射原理】 <br>a. 创建内存映射的时候，在进程的用户虚拟地址空间中分配一个虚拟内存区域。 <br>b. Linux内核采用延迟分配物理内存的策略，在进程第一次访问虚拟页的时候，产生缺页异常。如果是文件映射，那么分配物理页，把文件指定区间的数据讲到物理页中，然后在页表中把虚拟页映射到物理页；如果是匿名映射，那么分配物理页，然后在页表中把虚拟页映射到物理页。</p> 
<p><strong>根据修改是否其他进程可见和是否传递到底层文件，内存映射分为共享映射和私有映射：</strong><br><strong>共享映射</strong>：修改数据时映射相同区域的其他进程可以看见，如果是文件支持的映射，修改会传递到底层文件；<br><strong>私有映射</strong>：第一次修改数据时会从数据源复制一个副本，然后修改副本，其他进程看不见，不影响数据源；</p> 
<p>两个进程可以使用共享的文件映射实现共享内存。匿名映射通常是私有映射，共享的匿名映射只有出现在父进程和子进程之间。在进程的虚拟地址空间中，代码段和数据段是私有的文件映射，未初始化数据段、堆栈是私有的匿名映射。</p> 
<h4><a id="1_1629"></a>1、应用编程接口</h4> 
<p>内存管理子系统提供系统调用：</p> 
<ul><li><strong>mmap()</strong>：用来创建内存映射；</li><li><strong>mremap()</strong>：用来扩大或缩小已经存在的内存映射，可能同时移动；</li><li><strong>munmap()</strong>：用来删除内存映射；</li><li><strong>brk()</strong>：用来设置堆的上界；</li><li><strong>remap_file_pages()</strong>：用来创建非线性的文件映射，即文件区间和虚拟地址空间之间的映射不是线性关系，现在这些新版已将删除；</li><li><strong>mprotect()</strong>：用来设备虚拟内存区域的访问权限；</li><li><strong>madvise()</strong>：用来向内核提出内存使用的建议，应用程序告诉内核期望怎么样使用指定的虚拟内存区域， 以方便内核可以选择合适的预读和缓存技术。</li></ul> 
<p>在内核空间中可以使用两个函数：</p> 
<ul><li><strong>remap_fpn_range()</strong>：把内存的物理页映射到进程的虚拟地址空间，这个函数的用处是实现进程和内核共享内存。</li><li><strong>io_remap_pfn_range()</strong>：把外设寄存器的物理地址映射到进程的虚拟地址空间，进程以直接访问外设寄存器。</li></ul> 
<p>1、系统调用mmap()：进程创建匿名的内存映射，把内存的物理页映射到进程的虚拟地址空间；进程把文件映射到进程的虚拟地址空间，可以像访问内核一样访问文件，不需要调用系统调用read()/write()访问文件 ，从页避免用户模式和内核模式之间的切换，提高读写文件速度。两个进程针对同一个文件 创建共享的内存映射，达到共享内存。调用此函数成功：返回虚拟地址，否则返回负的错误号。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span> </span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
addr<span class="token operator">:</span>起始虚拟地址，如果addr为<span class="token number">0</span>，内核选择虚拟地址，否则内核把这个参数作为提示，在附近选择虚拟地址；
length<span class="token operator">:</span> 映射的长度，单位是字节；
prot：保护位
	PROT_EXEC（页可执行） 
	PROT_READ（页可读） 
	PROT_WRITE（页可写） 
	PROT_NONE（页不可访问）
flags<span class="token operator">:</span>标志
	MAP_SHARED（共享映射）
	MAP_PRIVATE（私有映射）
	MAP_ANONYMOUS（匿名映射）
	MAP_FIXED（固定映射）
	MAP_LOCKED（把页锁在内存中）
	MAP_POPULATE（填充页表，即分配并且映射到物理页，如果是文件映射，该标志导致预读文件 ）
fd：文件描述符：仅当创建文件映射的时候，此参数才有意义。
offset：偏移，单位是字节，必须是页长度的整数倍。

<span class="token keyword">int</span> <span class="token function">munmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>2、系统调用mprotect()：用来设置虚拟内存区域的访问权限。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span> </span>

<span class="token keyword">int</span> <span class="token function">mprotect</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
addr<span class="token operator">:</span>起始虚拟地址，必须是页长度的整数倍
len<span class="token operator">:</span>虚拟内存区域的长度，单位是字节
prot<span class="token operator">:</span>保护位
	PROT_NONE：页不可以访问
	PROT_READ：页可读
	PROT_WRITE：页可写
	PROT_EXEC：页可执行
调用此函数：如果成功返回<span class="token number">0</span>，否则返回负的错误号。
</code></pre> 
<h4><a id="2_1684"></a>2、数据结构</h4> 
<p>虚拟内存区域是分配给进程的一个虚拟地址范围，内核使用结构体vm_area_struct描述虚拟内存区域。具体内核源码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">//虚拟内存区域结构体类型</span>
<span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* The first cache line has the info for VMA tree walking. */</span>

	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_start<span class="token punctuation">;</span>		<span class="token comment">/* Our start address within vm_mm. */</span> <span class="token comment">//起始地址</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_end<span class="token punctuation">;</span>		<span class="token comment">/* The first byte after our end address_space-//结束地址
					   within vm_mm. */</span>

	<span class="token comment">/* linked list of VM areas per task, sorted by address */</span>
	<span class="token comment">// 虚拟内存区域链表, 按起始地址排序</span>
	<span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vm_next<span class="token punctuation">,</span> <span class="token operator">*</span>vm_prev<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">rb_node</span> vm_rb<span class="token punctuation">;</span>	<span class="token comment">//红黑树节点</span>

	<span class="token comment">/*
	 * Largest free memory gap in bytes to the left of this VMA.
	 * Either between this VMA and vma-&gt;vm_prev, or between one of the
	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps
	 * get_unmapped_area find a free area of the right size.
	 */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> rb_subtree_gap<span class="token punctuation">;</span>

	<span class="token comment">/* Second cache line starts here. */</span>

	<span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>vm_mm<span class="token punctuation">;</span>	<span class="token comment">/* The address space we belong to. */</span>	<span class="token comment">//指向内存描述符, 即虚拟内存区域所属的用户虚拟地址空间</span>
	<span class="token class-name">pgprot_t</span> vm_page_prot<span class="token punctuation">;</span>		<span class="token comment">/* Access permissions of this VMA. */</span>	<span class="token comment">//保护位, 即访问权限</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_flags<span class="token punctuation">;</span>		<span class="token comment">/* Flags, see mm.h. */</span>	<span class="token comment">//标志</span>

	<span class="token comment">/*
	 * For areas with an address space and backing store,
	 * linkage into the address_space-&gt;i_mmap interval tree.
	 */</span>
	<span class="token comment">// 为了支持查询一个文件区间被映射到哪些虚拟内存区域, 把一个文件映射到的所有虚拟内存区域加入到该文件的地址空间结构体address_space的成员i_mmap指向的区间树</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">struct</span> <span class="token class-name">rb_node</span> rb<span class="token punctuation">;</span>
		<span class="token keyword">unsigned</span> <span class="token keyword">long</span> rb_subtree_last<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> shared<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma
	 * list, after a COW of one of the file pages.	A MAP_SHARED vma
	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack
	 * or brk vma (with NULL file) can only be in an anon_vma list.
	 */</span>
	<span class="token comment">// 把虚拟内存区域关联的所有anon_vma实例串联起来, 一个虚拟内存区域会关联到父进程的anon_vma实例和自己自己的anon_vma实例</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> anon_vma_chain<span class="token punctuation">;</span> <span class="token comment">/* Serialized by mmap_sem &amp;	
					  * page_table_lock */</span>
	<span class="token keyword">struct</span> <span class="token class-name">anon_vma</span> <span class="token operator">*</span>anon_vma<span class="token punctuation">;</span>	<span class="token comment">/* Serialized by page_table_lock */</span>	<span class="token comment">//指向一个anon_vma实例, 结构体anon_vma用来组织匿名页被映射到的所有虚拟地址空间。</span>

	<span class="token comment">/* Function pointers to deal with this struct. */</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">vm_operations_struct</span> <span class="token operator">*</span>vm_ops<span class="token punctuation">;</span>	<span class="token comment">//虚拟内存操作集合</span>

	<span class="token comment">/* Information about our backing store: */</span>
	<span class="token comment">// 文件偏移, 单位为页</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_pgoff<span class="token punctuation">;</span>		<span class="token comment">/* Offset (within vm_file) in PAGE_SIZE
					   units */</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> vm_file<span class="token punctuation">;</span>		<span class="token comment">/* File we map to (can be NULL). */</span>	<span class="token comment">//文件, 如果是私有的匿名映射, 成员是空指针</span>
	<span class="token keyword">void</span> <span class="token operator">*</span> vm_private_data<span class="token punctuation">;</span>		<span class="token comment">/* was vm_pte (shared mem) */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_MMU</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">vm_region</span> <span class="token operator">*</span>vm_region<span class="token punctuation">;</span>	<span class="token comment">/* NOMMU mapping region */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_NUMA</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">mempolicy</span> <span class="token operator">*</span>vm_policy<span class="token punctuation">;</span>	<span class="token comment">/* NUMA policy for the VMA */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">vm_userfaultfd_ctx</span> vm_userfaultfd_ctx<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ee/17/LXlSCQA5_o.png" alt="image.png"></p> 
<p>虚拟内存区域的标志：结构体vm_area_struct成员vm_flags存放虚拟内存区域的标志：<br><img src="https://images2.imgbox.com/c4/d9/EmkWRMQZ_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/6c/36/MFmccyMl_o.png" alt="image.png"></p> 
<h4><a id="3_1759"></a>3、创建内存映射</h4> 
<p>C标准库封装函数mmap用来创建内存映射，内核提供POSIX标准定义系统调用mmap。系统调用执行流程：</p> 
<ul><li>检查偏移是不是页的整数倍，如果偏移不是页的整数倍，则返回“-EINVAL”。</li><li>如果偏移是页的整数倍，那么把偏移转换成以页为单位的偏移，然后调用函数sys_mmap_pgoff。</li></ul> 
<p><img src="https://images2.imgbox.com/d4/58/XuvieTIx_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/c5/47/qDYDTaGh_o.png" alt="image.png"><br>函数sys_mmap_pgoff和函数do_mmap执行流程如下：<br><img src="https://images2.imgbox.com/f6/7f/bXUw1wLg_o.png" alt="image.png"></p> 
<h4><a id="4_1767"></a>4、删除内存映射</h4> 
<p>系统调用munmap用来删除内存映射，它有两个参数：起始地址和长度。系统调用munmap的执行流程，主要把工作委托给源文件“mm/mmap.c"中的函数do_munmap。<br><img src="https://images2.imgbox.com/42/51/mOO8WE7a_o.png" alt="image.png"><br>系统调用munmap执行流程如下：<br><img src="https://images2.imgbox.com/36/ae/LeR3o3i7_o.png" alt="image.png"></p> 
<h3><a id="_1770"></a>二、物理内存组织结构</h3> 
<h4><a id="1_1771"></a>1、体系结构</h4> 
<p>非一致内存访问（Non-Uniform Memory Access，NUMA）：指内存被划分成多个内存节点的多处理器系统，访问一个内存节点花费的时间取决于处理器和内存节点的距离。<br>对称多处理器（Symmetric Multi-Processor， SMP）：即一致内存访问（Uniform Memory Access，UMA），所有处理器访问内存花费的时间是相同的。 <br>在实际应用中可以采用混合体系结构，在NUMA节点内部使用SMP体系。</p> 
<h4><a id="2_1774"></a>2、内存模型</h4> 
<p>内存模型是从处理器的角度看到的物理内存分布情况，内核管理不同内存模型的方式存在差异。内存管理子系统支持3种内存模型：</p> 
<ul><li>平坦内存（Flat Memory）：内存的物理地址空间是连续，没有空洞。</li><li>不连续内存（Discontiguous）：内存的物理地址空间存储空洞，这种模型可以高效地处理空洞。</li><li>稀疏内存（Sparse Memory）：内存的物理地址空间存储空洞。如果支持内存热插拔，只能选择稀疏内存模型。</li></ul> 
<p>什么情况下会出现内存的物理地址空间存在空洞？ <br>如果内存的物理地址空间存在空洞，应该选择那种内存模型？</p> 
<h4><a id="3_1783"></a>3、三级结构（内存节点/内存区域/物理页）</h4> 
<p>内存管理子系统使用节点（node）、区域（zone）和页（page）三级结构描述物理内存。</p> 
<h5><a id="a2_1785"></a>a、内存节点（内存节点分成2种情况）</h5> 
<ul><li>NUMA系统的内存节点，根据处理器和内存的距离划分。</li><li>在具有不连续的内存的UMA系统中，表示比区域的级别更高的内存区域，根据物理地址是否连续划分，每块物理地址连续的内存是一个内存节点。内存节点使用一个pglist_data结构体描述内存布局。对于平坦内存模型，只有一个pglist_data实例</li></ul> 
<p><img src="https://images2.imgbox.com/eb/fd/40qHwI3R_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/56/fc/W52LN5IJ_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/d0/20/BNrFAX0c_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/21/48/7GO0a30e_o.png" alt="image.png"></p> 
<h5><a id="b_1791"></a>b、内存区域</h5> 
<p>内存节点被划分为内存区域，内核定义区域类型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">enum</span> <span class="token class-name">zone_type</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA</span></span>
	<span class="token comment">/*
	 * ZONE_DMA is used when there are devices that are not able
	 * to do DMA to all of addressable memory (ZONE_NORMAL). Then we
	 * carve out the portion of memory that is needed for these devices.
	 * The range is arch specific.
	 *
	 * Some examples
	 *
	 * Architecture		Limit
	 * ---------------------------
	 * parisc, ia64, sparc	&lt;4G
	 * s390			&lt;2G
	 * arm			Various
	 * alpha		Unlimited or 0-16MB.
	 *
	 * i386, x86_64 and multiple other arches
	 * 			&lt;16M.
	 */</span>
	ZONE_DMA<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA32</span></span>
	<span class="token comment">/*
	 * x86_64 needs two ZONE_DMAs because it supports devices that are
	 * only able to do DMA to the lower 16M but also 32 bit devices that
	 * can only do DMA areas below 4G.
	 */</span>
	ZONE_DMA32<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<ul><li>ZONE_DMA：直接内存访问；</li><li>ZONE_DMA32：64位系统，如果既要支持只能直接访问16MB以下内存设备，又要支持只能直接访问4GB以下的内存的32位设备，那么必须使用DMA32区域。</li><li>ZONE_NORMAL：直接映射到内核虚拟地址空间的内存区域，又称为直接映射区域，或者叫线性映射区域。ARM处理器需要使用页表映射，MIPS不需要页表映射。</li><li>ZONE_HIGHMEM高端内存区域，DMA/DMA32/ZONE_NORMAL统称低端内存区域。</li><li>ZONE_MOVABLE：它是一个伪内存区域，用来防止内存碎片。</li><li>ZONE_DEVICE：支持持久内存热插拔增加的内存区域。</li></ul> 
<p>每个内存区域用一个zone结构体描述，其内核源码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token punctuation">{<!-- --></span>
 <span class="token comment">/* Read-mostly fields */</span>
 <span class="token comment">/* 区域水线，使用宏访问 */</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> watermark<span class="token punctuation">[</span>NR_WMARK<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 页分配器使用水线</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_reserved_highatomic<span class="token punctuation">;</span>
 
<span class="token comment">// 页分配器使用，当前区域保留多少页不能借给高的区域类型</span>
 <span class="token keyword">long</span> lowmem_reserve<span class="token punctuation">[</span>MAX_NR_ZONES<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_NUMA</span></span>
 <span class="token keyword">int</span> node<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token comment">// 指向内存节点的pglist_data实例</span>
 <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token operator">*</span>zone_pgdat<span class="token punctuation">;</span>
<span class="token comment">// 每处理器集合</span>
 <span class="token keyword">struct</span> <span class="token class-name">per_cpu_pageset</span> __percpu <span class="token operator">*</span>pageset<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_SPARSEMEM</span></span>
 <span class="token comment">/*
 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.
* In SPARSEMEM, this map is stored in struct mem_section
 */</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>pageblock_flags<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* CONFIG_SPARSEMEM */</span></span>
 <span class="token comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> zone_start_pfn<span class="token punctuation">;</span> <span class="token comment">// 当前区域的起始物理页号</span>
 
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> managed_pages<span class="token punctuation">;</span> <span class="token comment">// 伙伴分配器管理 的物理页的数量</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> spanned_pages<span class="token punctuation">;</span> <span class="token comment">// 当前区域跨越的总页数，包括空洞</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> present_pages<span class="token punctuation">;</span> <span class="token comment">// 当前区域存在的物理页的数量，不包括空洞</span>
 <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">// 区域名称</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_MEMORY_ISOLATION</span></span>
 <span class="token comment">/*
 * Number of isolated pageblock. It is used to solve incorrect
 * freepage counting problem due to racy retrieving migratetype
 * of pageblock. Protected by zone-&gt;lock.
 */</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_isolate_pageblock<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_MEMORY_HOTPLUG</span></span>
 <span class="token comment">/* see spanned/present_pages for more description */</span>
 <span class="token class-name">seqlock_t</span> span_seqlock<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
 <span class="token keyword">int</span> initialized<span class="token punctuation">;</span>
 <span class="token comment">/* Write-intensive fields used from the page allocator */</span>
 <span class="token function">ZONE_PADDING</span><span class="token punctuation">(</span>_pad1_<span class="token punctuation">)</span>
 <span class="token comment">/* free areas of different sizes */</span>
 <span class="token comment">// MAX_ORDER最大除数，实际上是可分配的最大除数加1，默认值是11，</span>
 <span class="token comment">// 意味伙伴分配器一次最多可分配2的10次方页</span>
 <span class="token keyword">struct</span> <span class="token class-name">free_area</span> free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 不同长度的空闲区域</span>
 <span class="token comment">/* zone flags, see below */</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
 <span class="token comment">/* Primarily protects free_area */</span>
 <span class="token class-name">spinlock_t</span> lock<span class="token punctuation">;</span>
 <span class="token comment">/* Write-intensive fields used by compaction and vmstats. */</span>
 <span class="token function">ZONE_PADDING</span><span class="token punctuation">(</span>_pad2_<span class="token punctuation">)</span>
 <span class="token comment">/*
 * When free pages are below this point, additional steps are taken
 * when reading the number of free pages to avoid per-cpu counter
* drift allowing watermarks to be breached
 */</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> percpu_drift_mark<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">defined CONFIG_COMPACTION <span class="token operator">||</span> defined CONFIG_CMA</span></span>
 <span class="token comment">/* pfn where compaction free scanner should start */</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> compact_cached_free_pfn<span class="token punctuation">;</span>
 <span class="token comment">/* pfn where async and sync compaction migration scanner should start */</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> compact_cached_migrate_pfn<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_COMPACTION</span></span>
 <span class="token comment">/*
 * On compaction failure, 1&lt;&lt;compact_defer_shift compactions
 * are skipped before trying again. The number attempted since
 * last failure is tracked with compact_considered.
 */</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compact_considered<span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compact_defer_shift<span class="token punctuation">;</span>
 <span class="token keyword">int</span> compact_order_failed<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">defined CONFIG_COMPACTION <span class="token operator">||</span> defined CONFIG_CMA</span></span>
 <span class="token comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span>
 bool compact_blockskip_flush<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
 bool contiguous<span class="token punctuation">;</span>
 <span class="token function">ZONE_PADDING</span><span class="token punctuation">(</span>_pad3_<span class="token punctuation">)</span>
 <span class="token comment">/* Zone statistics */</span>
 <span class="token class-name">atomic_long_t</span> vm_stat<span class="token punctuation">[</span>NR_VM_ZONE_STAT_ITEMS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> ____cacheline_internodealigned_in_smp<span class="token punctuation">;</span>
</code></pre> 
<h5><a id="c_1921"></a>c、物理页</h5> 
<p>每个物理页对应一个page结构体，称为页描述符，内存节点的pglist_data实例的成员node_mem_map指向该内存节点包含的所有物理页的页描述符组成的数据。<br><img src="https://images2.imgbox.com/76/86/h8caQF7X_o.png" alt="image.png"><br>因物理页的数量很大，所以在page结构体中增加1成员，可能导致所有page实例占用的内存大幅度增加。为了减少内存消耗，内核努力使page结构体尽可能小，对于不会同时生效的成员，使用联合体，这种做法带来的负面影响是page结构体的可读性差。</p> 
<h3><a id="kmallocvmallocmalloc_1923"></a>三、系统调用kmalloc/vmalloc（内核内存），malloc()分配用户的内存</h3> 
<p>1、kmalloc()：用于申请较小的、连续的物理内存;</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">kmalloc</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">gfp_t</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>2、vmalloc()：用于申请较大的内存空间，虚拟内存是连续的。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">vmalloc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>；
</code></pre> 
<h2><a id="Linux__1932"></a>Linux 块设备运行原理</h2> 
<h3><a id="_1933"></a>一、资源管理</h3> 
<p>首先掌握管理资源的数据结构和函数。</p> 
<h4><a id="1_1935"></a>1、树数据结构</h4> 
<p>Linux 提供了一个通用构架，用于在内存中构建数据结构。这些结构描述了系统中可用的资源，使得内核代码能够管理和分配资源。注意，其中关键的数据结构是resource，定义如下：<br><img src="https://images2.imgbox.com/c6/c0/zVija9pk_o.png" alt="image.png"><br>树型结构中的资源管理如下：<br><img src="https://images2.imgbox.com/14/e4/0nfwrmfK_o.png" alt="image.png"><br>用于连接parent、child、sibling成员的规则：</p> 
<ul><li>每个子节点只有一个父节点；</li><li>一个父节点可以有任意数目的子结点；</li><li>同一个父节点的所有的子节点，会连接到兄弟节点链表上；</li></ul> 
<h4><a id="2_1941"></a>2、请求资源和释放资源</h4> 
<p>为确保可靠地配置资源（无论何种类型），内核必须提供一种机制来分配和释放资源。一旦资源已经分配，则不能由任何其他驱动程序使用。请求和释放资源，无非是从资源树中添加和删除项而已。 <br>**请求资源 **<br>内核提供了__request_resource 函数，用于请求一个资源区域。<br><img src="https://images2.imgbox.com/e2/dc/GRFDBJV2_o.png" alt="image.png"><br>**释放资源 **<br>调用 release_resource 函数释放使用中的资源。<br><img src="https://images2.imgbox.com/3d/96/k7sT3eDi_o.png" alt="image.png"></p> 
<h3><a id="BIO__1943"></a>二、BIO 结构</h3> 
<p>在给出 BIO 的准确定义之前，最好先讨论其原理，如下图所示。BIO 的主要管理结构（bio）关联到一个向量（即数组），各个数组项都指向一个内存页（切记：不是页在内存中的地址，而是对应于该页帧的 page实例）。这些页用于从设备接收数据、向设备发送数据。<br><img src="https://images2.imgbox.com/ed/68/dod1lsAv_o.png" alt="image.png"><br>BIO 在内核源码数据结构定义如下<br><img src="https://images2.imgbox.com/27/01/ccMazWAK_o.png" alt="image.png"><br>各个数组元素的结构的定义：<br>bio_vec(<br>bio_page(指向用于数据传输的页对应page实例)<br>bio_len(指向用于数据的字节数目)<br>bio_offset(页内的偏移量)<br>)</p> 
<h3><a id="IO__1945"></a>三、I/O 调度</h3> 
<p>内核采用的各种用于调度和重排 I/O 操作的算法，称之为 I/O 调度器（对比通常的进程调度器，或网络中控制通信数据量的数据包调度器）。通常，I/O 调度器也称作电梯（elevator）。它们由下列数据结构中的一组函数表示：<br><img src="https://images2.imgbox.com/9d/a2/FJclI5Xf_o.png" alt="image.png"><br>每个 I/O 调度器都封装在下列数据结构中，其中还包含了供内核使用的其他信息：<br><img src="https://images2.imgbox.com/f8/f8/ev2iS0Qh_o.png" alt="image.png"><br>内核将所有I/O调度器在一个标准的双链表中维护，链表元素是list成员</p> 
<h3><a id="PCI__1947"></a>四、PCI 总线原理</h3> 
<h4><a id="1_1948"></a>1、系统总结知识</h4> 
<p>系统总线上传送的信息包括数据信息、地址信息、控制信息，因此，系统总线包含有三种不同功能的总 线 ， 即数 据 总 线 DB （ Data Bus ） 、地 址 总 线 AB （Address Bus）和控制总线 CB（Control Bus）。<br><img src="https://images2.imgbox.com/12/8b/4tQwy4q9_o.png" alt="image.png"><br><strong>数据总线（Data Bus）</strong>：将CPU的数据传送到存储器或IO接口等等部件，也可以将其他部件数据传送到CPU。<br><strong>地址总线（Address Bus）</strong>：专门传送地址的，由于地址只能从CPU传向外部存储器或IO端口，所以地址总线是单向三态的。比如：地址总线为n位，寻址空间为2的n次方个地址空间（存储单元）。<br><strong>控制总线（Control Bus）</strong>：用来传送控制信号和时序信号。</p> 
<h4><a id="2_1950"></a>2、系统总线工作原理</h4> 
<p>系统总线在微型计算机中的地位，如同人的神经中枢系统，CPU 通过系统总线对存储器的内容进行读写，同样通过总线，实现将 CPU 内数据写入外设，或由外设读入 CPU。微型计算机都采用总线结构。总线就是用来传送信息的一组通信线。微型计算机通过系统总线将各部件连接到一起，实现了微型计算机内部各部件间的信息交换。<br><img src="https://images2.imgbox.com/c4/26/01shuNYe_o.png" alt="image.png"></p> 
<h4><a id="3PCI__1952"></a>3、PCI 总线</h4> 
<p>PCI（peripheral component interconnect）总线是当前最流行的总线之一，它是由 Intel 公司推出的一种局部总线。它定义了 32 位数据总线，且可扩展为 64 位。 PCI 总线主板插槽的体积比原 ISA 总线插槽还小，其功能比 VESA、ISA 有极大的改善，支持突发读写操作，最大传输速率可达 132MB/s，可同时支持多组外围设备。PCI 局部总线不能兼容现有的 ISA、EISA、MCA（micro channel architecture）总线，但它不受制于处理器，是基于奔腾等新一代微处理器而发展的总线。</p> 
<p><strong>PCI 总线规定了以下设计目标</strong>：</p> 
<ul><li>支持高传输带宽，以适应具有大数据流的多媒体应用。</li><li>简单且易于自动化配置附接的外设。</li><li>平台独立性，即不绑定到特定的处理器类型或系统平台。</li></ul> 
<p>PCI系统的布局（内核中PCI）：<br>设备标识（系统某个PCI总线上每个设备。都由一组3个编号标识）<br>总线编号：设备所在总线的编号，0-255<br>插槽编号：总线内核的一个唯一标识编号。一个总线最多可附接32个设备。<br>功能编号：用于在一个扩展卡，实现包括多个扩展设备的设备（IDE控制器、USB控制器等等）。扩展设备必须通过功能编号来进行区分。PCI标准将一个设备上功能部件最大数目为8，每个设备都通过一个16位编号唯一标识（8位用于总线编号，5位用于插槽编号，3位用于功能编号）</p> 
<p>PCI配置空间，PCI有三个相互独立的物理地址（IO地址空间、配置空间、设备存储器地址空间）<br>PCI总线规范配置空间总长度为256个字节。</p> 
<p><strong>PCI 配置空间布局</strong><br><img src="https://images2.imgbox.com/09/4b/OOhlp1r9_o.png" alt="image.png"><br>Device ID：设备ID<br>Vendor ID：厂商ID<br>Rev ID：用于区分不同设备修订级别<br>Class Code：用于将设备分配到各种不同的功能组<br>基类及子类pci_ids.h中对应常数的名称：<br>大容量的存储器（PCI_BASE_CLASS_STOREAGE）:SCSI、IDE、RAID<br>网络（PCI_BASE_CLASS_NETWORK）：以太网、FDDI<br>系统组件（PCI_BASE_CLASS_SYSTEM）：实时时钟、DMA控制器</p> 
<p><strong>PCI 总线数据结构</strong><br>在内存中，每个 PCI 总线都通过 pci_bus 数据结构的一个实例表示，该结构定义如下：<br><img src="https://images2.imgbox.com/f3/55/5Plynw5P_o.png" alt="image.png"><br>结构成员：系统中的各个总线由pci_bus的实例表示；<br>pci_dev结构表示各个设备、扩展卡和功能部件；<br>每个驱动程序都通过pci_driver的一实例描述。</p> 
<h4><a id="4_1968"></a>4、设备管理</h4> 
<p>struct pci_dev 是一个关键的数据结构，用于表示系统中的各个 PCI 设备。<br><img src="https://images2.imgbox.com/92/91/seilE57i_o.png" alt="image.png"></p> 
<h4><a id="5_1971"></a>5、驱动程序函数</h4> 
<p>PCI 层中最后一个基本的数据结构是 pci_driver。它用于实现 PCI 驱动程序，表示了通用内核代码和设备的底层硬件驱动程序之间的接口。每个 PCI 驱动程序都必须将其函数填到该接口中，使得内核能够一致地控制可用的驱动程序。<br><img src="https://images2.imgbox.com/51/18/gX5wTJa2_o.png" alt="image.png"></p> 
<h4><a id="6_1973"></a>6、注册驱动程序</h4> 
<p>PCI 驱动程序可以通过 pci_register_driver 注册。该函数十分简单，其主要任务是，对相关函数已经分配的一个 pci_device 实例，填充一些剩余的字段。<br><img src="https://images2.imgbox.com/49/b1/bBFJ5Iie_o.png" alt="image.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74bff64b13e50c51adf45b7a2e21a58c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2022-3-21 课题设计：基于单片机的DS18B20测温（数码管显示）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c24c21a673faf1efe5da125a685a7be4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【用户态协议栈】用户态协议栈</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>