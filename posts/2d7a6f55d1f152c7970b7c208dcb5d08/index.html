<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring @Transactional注解失效的情况及解决方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring @Transactional注解失效的情况及解决方法" />
<meta property="og:description" content="Spring框架中的@Transactional注解是非常常用的注解，它可以将一个方法标记为事务性方法，使得在方法执行过程中发生异常时，可以自动回滚事务，保证数据的一致性。然而，在某些情况下，@Transactional注解可能会失效，本文将会介绍这些情况及其解决方法。
一、@Transactional注解的原理 在介绍@Transactional注解失效的情况之前，我们先来了解一下@Transactional注解的原理。
@Transactional注解的实现是基于Spring框架中的AOP（面向切面编程）机制，它通过代理模式在运行时动态地为标记了@Transactional注解的方法生成一个代理对象，这个代理对象会拦截方法的调用，并在方法执行前后开启和提交事务。
具体来说，当一个标记了@Transactional注解的方法被调用时，Spring框架会在运行时为这个方法生成一个代理对象，这个代理对象会在方法执行前开启一个新的事务，并将这个事务与当前线程绑定。当方法执行完成后，代理对象会根据方法的执行结果决定是提交事务还是回滚事务，并将事务与当前线程解绑。
需要注意的是，@Transactional注解只对public方法有效，对于private、protected或者默认访问级别的方法是不起作用的。
二、@Transactional注解失效的情况 虽然@Transactional注解是非常方便的，但是在某些情况下，它可能会失效。下面我们将介绍一些常见的情况。
1. 方法内部调用 如果在一个标记了@Transactional注解的方法内部调用另一个标记了@Transactional注解的方法，那么内部方法的事务将会失效。这是因为Spring框架默认使用基于代理的AOP实现，而代理对象的调用是通过Java反射机制实现的，因此在一个方法内部调用另一个方法时，实际上是在同一个对象中调用方法，而不是通过代理对象调用方法，因此事务无法生效。
@Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Transactional public void updateUser(User user) { // 更新用户信息 userDao.updateUser(user); // 调用另一个标记了@Transactional注解的方法 updateUserScore(user.getId(), 100); } @Transactional public void updateUserScore(Long userId, int score) { // 更新用户积分 userDao.updateUserScore(userId, score); } } 上面的代码中，updateUser方法和updateUserScore方法都标记了@Transactional注解，但是当updateUser方法调用updateUserScore方法时，updateUserScore方法的事务将会失效。
2. 异常被捕获 如果一个标记了@Transactional注解的方法抛出了异常，并且这个异常被捕获了，那么事务将不会回滚。这是因为Spring框架默认只对未捕获的异常进行回滚，如果异常被捕获了，那么Spring框架就认为这个异常已经被处理了，不需要回滚事务。
@Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Transactional public void updateUser(User user) { // 更新用户信息 userDao." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2d7a6f55d1f152c7970b7c208dcb5d08/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-26T11:22:05+08:00" />
<meta property="article:modified_time" content="2023-06-26T11:22:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring @Transactional注解失效的情况及解决方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Spring框架中的@Transactional注解是非常常用的注解，它可以将一个方法标记为事务性方法，使得在方法执行过程中发生异常时，可以自动回滚事务，保证数据的一致性。然而，在某些情况下，@Transactional注解可能会失效，本文将会介绍这些情况及其解决方法。</p> 
<h3>一、@Transactional注解的原理</h3> 
<p>在介绍@Transactional注解失效的情况之前，我们先来了解一下@Transactional注解的原理。</p> 
<p>@Transactional注解的实现是基于Spring框架中的AOP（面向切面编程）机制，它通过代理模式在运行时动态地为标记了@Transactional注解的方法生成一个代理对象，这个代理对象会拦截方法的调用，并在方法执行前后开启和提交事务。</p> 
<p>具体来说，当一个标记了@Transactional注解的方法被调用时，Spring框架会在运行时为这个方法生成一个代理对象，这个代理对象会在方法执行前开启一个新的事务，并将这个事务与当前线程绑定。当方法执行完成后，代理对象会根据方法的执行结果决定是提交事务还是回滚事务，并将事务与当前线程解绑。</p> 
<p>需要注意的是，@Transactional注解只对public方法有效，对于private、protected或者默认访问级别的方法是不起作用的。</p> 
<h3>二、@Transactional注解失效的情况</h3> 
<p>虽然@Transactional注解是非常方便的，但是在某些情况下，它可能会失效。下面我们将介绍一些常见的情况。</p> 
<h4>1. 方法内部调用</h4> 
<p>如果在一个标记了@Transactional注解的方法内部调用另一个标记了@Transactional注解的方法，那么内部方法的事务将会失效。这是因为Spring框架默认使用基于代理的AOP实现，而代理对象的调用是通过Java反射机制实现的，因此在一个方法内部调用另一个方法时，实际上是在同一个对象中调用方法，而不是通过代理对象调用方法，因此事务无法生效。</p> 
<pre><code>@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Transactional
    public void updateUser(User user) {
        // 更新用户信息
        userDao.updateUser(user);

        // 调用另一个标记了@Transactional注解的方法
        updateUserScore(user.getId(), 100);
    }

    @Transactional
    public void updateUserScore(Long userId, int score) {
        // 更新用户积分
        userDao.updateUserScore(userId, score);
    }
}
</code></pre> 
<p>上面的代码中，updateUser方法和updateUserScore方法都标记了@Transactional注解，但是当updateUser方法调用updateUserScore方法时，updateUserScore方法的事务将会失效。</p> 
<h4>2. 异常被捕获</h4> 
<p>如果一个标记了@Transactional注解的方法抛出了异常，并且这个异常被捕获了，那么事务将不会回滚。这是因为Spring框架默认只对未捕获的异常进行回滚，如果异常被捕获了，那么Spring框架就认为这个异常已经被处理了，不需要回滚事务。</p> 
<pre><code>@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Transactional
    public void updateUser(User user) {
        // 更新用户信息
        userDao.updateUser(user);

        try {
            // 抛出异常
            throw new RuntimeException("updateUserScore error");
        } catch (Exception e) {
            // 异常被捕获
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p>上面的代码中，updateUser方法标记了@Transactional注解，并且在方法中抛出了一个RuntimeException异常，并且这个异常被捕获了。在这种情况下，即使抛出了异常，事务也不会回滚。</p> 
<h4>3. 非public方法</h4> 
<p>如果一个标记了@Transactional注解的方法的访问级别不是public，那么事务将不会生效。这是因为Spring框架默认只对public方法进行代理，对于非public方法不会进行代理，因此事务无法生效。</p> 
<pre><code>@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Transactional
    void updateUser(User user) {
        // 更新用户信息
        userDao.updateUser(user);
    }
}
</code></pre> 
<p>上面的代码中，updateUser方法标记了@Transactional注解，但是它的访问级别不是public，因此事务无法生效。</p> 
<h4>4. 自调用</h4> 
<p>如果一个标记了@Transactional注解的方法自己调用自己，那么事务将不会生效。这是因为Spring框架默认使用基于代理的AOP实现，而代理对象的调用是通过Java反射机制实现的，因此在一个方法内部调用自己时，实际上是在同一个对象中调用方法，而不是通过代理对象调用方法，因此事务无法生效。</p> 
<pre><code>@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Transactional
    public void updateUser(User user) {
        // 更新用户信息
        userDao.updateUser(user);

        // 自调用
        updateUser(user);
    }
}
</code></pre> 
<p>上面的代码中，updateUser方法标记了@Transactional注解，并且在方法内部自调用了自己。在这种情况下，事务将不会生效。</p> 
<h4>5. 异常类型不匹配</h4> 
<p>如果一个标记了@Transactional注解的方法抛出了一个不是RuntimeException或Error的异常，那么事务将不会回滚。这是因为Spring框架默认只对RuntimeException和Error类型的异常进行回滚，对于其他类型的异常不会进行回滚。</p> 
<pre><code>@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Transactional
    public void updateUser(User user) throws Exception {
        // 更新用户信息
        userDao.updateUser(user);

        // 抛出异常
        throw new Exception("updateUser error");
    }
}
</code></pre> 
<p>上面的代码中，updateUser方法标记了@Transactional注解，并且抛出了一个Exception异常，而不是RuntimeException或Error异常。在这种情况下，事务将不会回滚。</p> 
<h3>三、@Transactional注解失效的解决方法</h3> 
<p>针对上面介绍的@Transactional注解失效的情况，我们可以采取以下的解决方法。</p> 
<h4>1. 方法内部调用</h4> 
<p>如果在一个标记了@Transactional注解的方法内部调用另一个标记了@Transactional注解的方法，我们可以通过将内部方法抽取到一个单独的类中，并在这个类上标记@Transactional注解来解决这个问题。</p> 
<pre><code>@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Autowired
    private UserScoreService userScoreService;

    @Transactional
    public void updateUser(User user) {
        // 更新用户信息
        userDao.updateUser(user);

        // 调用另一个标记了@Transactional注解的方法
        userScoreService.updateUserScore(user.getId(), 100);
    }
}

@Service
public class UserScoreServiceImpl implements UserScoreService {

    @Autowired
    private UserDao userDao;

    @Transactional
    public void updateUserScore(Long userId, int score) {
        // 更新用户积分
        userDao.updateUserScore(userId, score);
    }
}
</code></pre> 
<p>上面的代码中，我们将updateUserScore方法抽取到了一个单独的类UserScoreServiceImpl中，并在这个类上标记了@Transactional注解，这样在updateUser方法中调用userScoreService.updateUserScore方法时，事务就能够生效了。</p> 
<h4>2. 异常被捕获</h4> 
<p>如果一个标记了@Transactional注解的方法抛出了异常，并且这个异常被捕获了，我们可以通过在catch块中重新抛出异常来解决这个问题。</p> 
<pre><code>@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Transactional
    public void updateUser(User user) {
        // 更新用户信息
        userDao.updateUser(user);

        try {
            // 抛出异常
            throw new RuntimeException("updateUserScore error");
        } catch (Exception e) {
            // 异常被捕获
            e.printStackTrace();
            // 重新抛出异常
            throw e;
        }
    }
}
</code></pre> 
<p>上面的代码中，在catch块中重新抛出了异常，这样事务就能够回滚了。</p> 
<h4>3. 非public方法</h4> 
<p>如果一个标记了@Transactional注解的方法的访问级别不是public，我们可以将它的访问级别改为public来解决这个问题。</p> 
<pre><code>@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Transactional
    public void updateUser(User user) {
        // 更新用户信息
        userDao.updateUser(user);
    }
}
</code></pre> 
<p>上面的代码中，我们将updateUser方法的访问级别改为了public，这样事务就能够生效了。</p> 
<h4>4. 自调用</h4> 
<p>如果一个标记了@Transactional注解的方法自己调用自己，我们可以将自调用的逻辑抽取到一个单独的方法中，并在这个方法上标记@Transactional注解来解决这个问题。</p> 
<pre><code>@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Transactional
    public void updateUser(User user) {
        // 更新用户信息
        userDao.updateUser(user);

        // 调用自己
        updateUserInternal(user);
    }

    @Transactional
    private void updateUserInternal(User user) {
        // 更新用户信息
        userDao.updateUser(user);
    }
}
</code></pre> 
<p>上面的代码中，我们将自调用的逻辑抽取到了一个单独的方法updateUserInternal中，并在这个方法上标记了@Transactional注解，这样在updateUser方法中调用updateUserInternal方法时，事务就能够生效了。</p> 
<h4>5. 异常类型不匹配</h4> 
<p>如果一个标记了@Transactional注解的方法抛出了一个不是RuntimeException或Error的异常，我们可以通过在@Transactional注解中指定回滚的异常类型来解决这个问题。</p> 
<pre><code>@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Transactional(rollbackFor = Exception.class)
    public void updateUser(User user) throws Exception {
        // 更新用户信息
        userDao.updateUser(user);

        // 抛出异常
        throw new Exception("updateUser error");
    }
}
</code></pre> 
<p>上面的代码中，在@Transactional注解中指定了rollbackFor属性为Exception.class，这样即使抛出了Exception异常，事务也能够回滚。</p> 
<h3>四、总结</h3> 
<p>@Transactional注解是Spring框架中非常常用的注解，它可以将一个方法标记为事务性方法，使得在方法执行过程中发生异常时，可以自动回滚事务，保证数据的一致性。然而，在某些情况下，@Transactional注解可能会失效，本文介绍了这些情况及其解决方法。</p> 
<p>如果在一个标记了@Transactional注解的方法内部调用另一个标记了@Transactional注解的方法，我们可以将内部方法抽取到一个单独的类中，并在这个类上标记@Transactional注解来解决这个问题；如果一个标记了@Transactional注解的方法抛出了异常，并且这个异常被捕获了，我们可以通过在catch块中重新抛出异常来解决这个问题；如果一个标记了@Transactional注解的方法的访问级别不是public，我们可以将它的访问级别改为public来解决这个问题；如果一个标记了@Transactional注解的方法自己调用自己，我们可以将自调用的逻辑抽取到一个单独的方法中，并在这个方法上标记@Transactional注解来解决这个问题；如果一个标记了@Transactional注解的方法抛出了一个不是RuntimeException或Error的异常，我们可以通过在@Transactional注解中指定回滚的异常类型来解决这个问题。</p> 
<p>最后，需要注意的是，虽然@Transactional注解非常方便，但是在使用时需要注意它的失效情况，以免出现数据不一致的情况。</p> 
<p><span style="color:#956fe7;"><strong>公众号请关注"果酱桑", 一起学习,一起进步!</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1eff856d3e19eed1895098b9e7a25880/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux系统使用-vimrc文件的组织</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36c8d68435cfd201eeafe2ddcf523847/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于@profiles.active@的环境配置，将环境配置放在pom文件配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>