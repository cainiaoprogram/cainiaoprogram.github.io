<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>卷积神经网络（CNN）之卷积操作、池化操作、激活函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="卷积神经网络（CNN）之卷积操作、池化操作、激活函数" />
<meta property="og:description" content="前言：卷积神经网络是深度学习算法中一个重要组成部分，在深度学习图像识别技术的应用中起到了关键作用。卷积神经网络和循环神经网络(RNN)都是类似于传统的全连接神经网络(也叫深度神经网络，简称DNN)，CNN属于编码了空间相关性的DNN，RNN属于编码了时间相关性的DNN。由于图像任务的不同，CNN的网络层也会有些许变动，但是基本上都会使用到卷积层、池化层以及非线性层。为了加深这方面理论知识的理解，本文将从多方面深入讲解CNN中的卷积操作、池化操作以及激活函数。
目录
1、卷积层
1.1 卷积计算
1.2 卷积层的特点
1.3 常用的卷积操作
2、池化层
2.1 池化的作用
2.2 常用的池化操作
3、非线性层
3.1 激活函数的作用
3.2 常用的激活函数
1、卷积层 卷积层的作用是提取输入图片中的信息，这些信息被称为图像特征，这些特征是由图像中的每个像素通过组合或者独立的方式所体现，比如图片的纹理特征，颜色特征。
1.1 卷积计算 在讲解具体的卷积计算之前，我们先通过几张动图直观地感受一下不同维度的卷积操作。
一维卷积操作如下图所示：
二维卷积操作如下图所示：
三位卷积操作如下图所示：
卷积核做的是线性运算，核上的每个值与它滑动到的对应位置上的值相乘，然后把这些值相加。以二维卷积为例讲解Conv2d如何进行卷积计算，在讲解卷积计算之前，我们需要明白几点重要的概念，这对理解卷积运算有很大的帮助：
①二维卷积中的二维并不是指卷积核是二维的，它与卷积核的维度无关，而是指卷积核只在两个维度上滑动。同理，一维卷积和三维卷积分别指卷积核在一个维度或者三个维度上滑动，正如上面3个图所示；
②卷积核通道数（或者叫卷积核个数，一组卷积核中有通道数个卷积核）=输入层通道数；
③输出层通道数（即特征图通道数或特征图个数）=卷积核组数，也就是说1组卷积核对输入进行卷积计算后只能得到1个特征图，特征图有n个通道则说明需要用n组卷积核对输入进行卷积计算。
理解了上面几点概念后，现在我们来通过一个实例来具体感受一下二维卷积是如何计算的。
如上图所示，假设输入是RGB3个通道的二维图像，那么一组卷积核中包含3个二维卷积核，即卷积核也必须是3个通道的。这3个卷积核分别在输入图像的3个通道上滑动，比如R通道上，每滑动一次，对应元素相乘再相加就可以得到一个数，3个卷积核滑动一次就会得到3个数，将这3个数相加并且加上一个偏置即可得到特征图上的一个值，该组卷积核在输入图像上全部滑动结束，那么就可以得到一个完整的特征图，这个特征图代表从输入图像中提取出来的一种特征。而一般在输入图像上只提取一种特征是完全不够的，往往需要在输入图像上获取更多的特征信息，即要获得多个特征图，那么就需要多组卷积核在图像上进行卷积计算。下图中使用了两组卷积核计算得到了2个特征图。
二维卷积操作在Pytorch中通过下面函数实现：
#二维卷积 torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=&#39;zeros&#39;, device=None, dtype=None) #参数介绍： #in_channels：输入的通道数 #out_channels：输出的通道数 #kernel_size：卷积核的大小 #stride：卷积核滑动的步长，默认是1 #padding：怎么填充输入图像，此参数的类型可以是int , tuple或str , optional 。默认padding=0，即不填充。 #dilation：设置膨胀率，即核内元素间距，默认是1。即如果kernel_size=3，dilation=1，那么卷积核大小就是3×3；如果kernel_size=3，dilation=2，那么卷积核大小为5×5 #groups：通过设置这个参数来决定分几组进行卷积，默认是1，即默认是普通卷积,此时卷积核通道数=输入通道数 #bias：是否添加偏差，默认true #padding_mode：填充时，此参数决定用什么值来填充，默认是&#39;zeros&#39;，即用0填充，可选参数有&#39;zeros&#39;, &#39;reflect&#39;, &#39;replicate&#39;或&#39;circular&#39; 假设输入的尺寸是，卷积后输出的尺寸是，那么：
1.2 卷积层的特点 ①权值共享
用同一组参数去遍历整张图像，用于提取整张图像中具有某种共性的特征信息，比如纹理特征等，不同卷积核用于提取图像在不同方面具有共性的特征信息，即卷积操作后得到的一个特征图代表提取的一种图像特征。权值共享是深度学习的一个重要思想，它在减少网络参数的同时依然可以保持很好的网络容量。卷积神经网络在空间上权值共享，而循环神经网络在时间上权值共享。
②局部连接" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0441e5dcc33a1523a2bbed80cf8bc240/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-28T17:35:10+08:00" />
<meta property="article:modified_time" content="2022-07-28T17:35:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">卷积神经网络（CNN）之卷积操作、池化操作、激活函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前言：卷积神经网络是深度学习算法中一个重要组成部分，在深度学习图像识别技术的应用中起到了关键作用。卷积神经网络和循环神经网络(RNN)都是类似于传统的全连接神经网络(也叫深度神经网络，简称DNN)，CNN属于编码了空间相关性的DNN，RNN属于编码了时间相关性的DNN。由于图像任务的不同，CNN的网络层也会有些许变动，但是基本上都会使用到卷积层、池化层以及非线性层。为了加深这方面理论知识的理解，本文将从多方面深入讲解CNN中的卷积操作、池化操作以及激活函数。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E5%8D%B7%E7%A7%AF%E5%B1%82-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E5%8D%B7%E7%A7%AF%E5%B1%82" rel="nofollow">1、卷积层</a></p> 
<p id="1.1%20%E5%8D%B7%E7%A7%AF%E8%AE%A1%E7%AE%97-toc" style="margin-left:40px;"><a href="#1.1%20%E5%8D%B7%E7%A7%AF%E8%AE%A1%E7%AE%97" rel="nofollow">1.1 卷积计算</a></p> 
<p id="1.2%20%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#1.2%20%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">1.2 卷积层的特点</a></p> 
<p id="1.3%C2%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#1.3%C2%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C" rel="nofollow">1.3 常用的卷积操作</a></p> 
<p id="2%E3%80%81%E6%B1%A0%E5%8C%96%E5%B1%82-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E6%B1%A0%E5%8C%96%E5%B1%82" rel="nofollow">2、池化层</a></p> 
<p id="2.1%20%E6%B1%A0%E5%8C%96%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.1%20%E6%B1%A0%E5%8C%96%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">2.1 池化的作用</a></p> 
<p id="2.2%C2%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B1%A0%E5%8C%96%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B1%A0%E5%8C%96%E6%93%8D%E4%BD%9C" rel="nofollow">2.2 常用的池化操作</a></p> 
<p id="3%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%B1%82-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%B1%82" rel="nofollow">3、非线性层</a></p> 
<p id="3.1%20%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#3.1%20%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">3.1 激活函数的作用</a></p> 
<p id="3.2%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.2%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0" rel="nofollow">3.2 常用的激活函数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81%E5%8D%B7%E7%A7%AF%E5%B1%82">1、卷积层</h2> 
<p>        卷积层的作用是提取输入图片中的信息，这些信息被称为图像特征，这些特征是由图像中的每个像素通过组合或者独立的方式所体现，比如图片的纹理特征，颜色特征。</p> 
<h3 id="1.1%20%E5%8D%B7%E7%A7%AF%E8%AE%A1%E7%AE%97">1.1 卷积计算</h3> 
<p>        在讲解具体的卷积计算之前，我们先通过几张动图直观地感受一下不同维度的卷积操作。</p> 
<p>一维卷积操作如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0a/bb/mQE1MwQz_o.gif"></p> 
<p>二维卷积操作如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/69/73/2rb2NHZJ_o.gif"></p> 
<p>三位卷积操作如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/94/98/qDjVeq87_o.gif"></p> 
<p>        卷积核做的是线性运算，核上的每个值与它滑动到的对应位置上的值相乘，然后把这些值相加。以二维卷积为例讲解Conv2d如何进行卷积计算，在讲解卷积计算之前，我们需要明白几点重要的概念，这对理解卷积运算有很大的帮助：</p> 
<p><strong>①二维卷积中的二维并不是指卷积核是二维的，它与卷积核的维度无关，而是指卷积核只在两个维度上滑动。同理，一维卷积和三维卷积分别指卷积核在一个维度或者三个维度上滑动，正如上面3个图所示；</strong></p> 
<p><strong>②卷积核通道数（或者叫卷积核个数，一组卷积核中有通道数个卷积核）=输入层通道数；</strong></p> 
<p><strong>③输出层通道数（即特征图通道数或特征图个数）=卷积核组数，也就是说1组卷积核对输入进行卷积计算后只能得到1个特征图，特征图有n个通道则说明需要用n组卷积核对输入进行卷积计算。</strong></p> 
<p><strong>        </strong>理解了上面几点概念后，现在我们来通过一个实例来具体感受一下二维卷积是如何计算的。</p> 
<p><img alt="" src="https://images2.imgbox.com/b1/31/NZw3q0lA_o.gif"></p> 
<p>        如上图所示，假设输入是RGB3个通道的二维图像，那么一组卷积核中包含3个二维卷积核，即卷积核也必须是3个通道的。这3个卷积核分别在输入图像的3个通道上滑动，比如R通道上，每滑动一次，对应元素相乘再相加就可以得到一个数，3个卷积核滑动一次就会得到3个数，将这3个数相加并且加上一个偏置即可得到特征图上的一个值，该组卷积核在输入图像上全部滑动结束，那么就可以得到一个完整的特征图，这个特征图代表从输入图像中提取出来的一种特征。而一般在输入图像上只提取一种特征是完全不够的，往往需要在输入图像上获取更多的特征信息，即要获得多个特征图，那么就需要多组卷积核在图像上进行卷积计算。下图中使用了两组卷积核计算得到了2个特征图。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2e/a3/M0pDO4og_o.gif"></p> 
<p>二维卷积操作在Pytorch中通过下面函数实现：</p> 
<pre><code>#二维卷积
torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros', device=None, dtype=None)
#参数介绍：
#in_channels：输入的通道数
#out_channels：输出的通道数
#kernel_size：卷积核的大小
#stride：卷积核滑动的步长，默认是1
#padding：怎么填充输入图像，此参数的类型可以是int , tuple或str , optional 。默认padding=0，即不填充。
#dilation：设置膨胀率，即核内元素间距，默认是1。即如果kernel_size=3，dilation=1，那么卷积核大小就是3×3；如果kernel_size=3，dilation=2，那么卷积核大小为5×5
#groups：通过设置这个参数来决定分几组进行卷积，默认是1，即默认是普通卷积,此时卷积核通道数=输入通道数
#bias：是否添加偏差，默认true
#padding_mode：填充时，此参数决定用什么值来填充，默认是'zeros'，即用0填充，可选参数有'zeros', 'reflect', 'replicate'或'circular'

</code></pre> 
<p>假设输入的尺寸是<img alt="(N,C_{in},H_{in},W_{in})" class="mathcode" src="https://images2.imgbox.com/70/df/MSc7kgTp_o.png">，卷积后输出的尺寸是<img alt="(N,C_{out},H_{out},W_{out})" class="mathcode" src="https://images2.imgbox.com/e1/60/pKX23G26_o.png">，那么：</p> 
<p style="text-align:center;"><img alt="H_{out}=\frac{H_{in}+2*padding[0]-dilation[0]*(kernalsize[0]-1)-1}{stride[0]}+1" class="mathcode" src="https://images2.imgbox.com/9b/00/oVr2R4y3_o.png"></p> 
<p style="text-align:center;"><img alt="W_{out}=\frac{W_{in}+2*padding[1]-dilation[1]*(kernalsize[1]-1)-1}{stride[1]}+1" class="mathcode" src="https://images2.imgbox.com/68/7f/rp3cDG08_o.png"></p> 
<h3 id="1.2%20%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E7%89%B9%E7%82%B9">1.2 卷积层的特点</h3> 
<p>①权值共享</p> 
<p>        用同一组参数去遍历整张图像，用于提取整张图像中具有某种共性的特征信息，比如纹理特征等，不同卷积核用于提取图像在不同方面具有共性的特征信息，即卷积操作后得到的一个特征图代表提取的一种图像特征。权值共享是深度学习的一个重要思想，它在减少网络参数的同时依然可以保持很好的网络容量。卷积神经网络在空间上权值共享，而循环神经网络在时间上权值共享。</p> 
<p>②局部连接</p> 
<p>        卷积层是由全连接层演变而来的，在全连接层中，每个输出通过权值与所有输入相连。而在视觉识别任务中，关键性的图像特征、边缘、角点等只占据了整张图像的一小部分，图像中相距较远的的两个像素有相互影响的可能性较小。因此，在卷积层中，每个输出神经元在通道上保持全连接，而在空间上只和邻域的一小部分输入神经元相连。</p> 
<h3 id="1.3%C2%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C">1.3 常用的卷积操作</h3> 
<p>1）分组卷积</p> 
<p>        分组卷积和普通卷积的区别在于普通卷积在通道上保持全连接，而在空间上只和邻域的一小部分输入神经元局部连接，而分组卷积在通道和空间上都是局部连接，那么不难发现分组卷积可以在普通卷积的基础上进一步减少参数，但是效果可能会比普通卷积效果差点。如下图所示，可以直观地观察到分组卷积和普通卷积的区别。</p> 
<p><img alt="" src="https://images2.imgbox.com/04/1b/j1lia6er_o.png"></p> 
<p class="img-center"><img alt="" height="169" src="https://images2.imgbox.com/9c/32/B9XvUZ7v_o.png" width="441"></p> 
<p class="img-center"><img alt="" height="164" src="https://images2.imgbox.com/ad/61/AYBkUOMA_o.png" width="434"></p> 
<p>        举个例子，假设输入的shape为（1，12，24，24），卷积核的kernal_size=3，要求输出的通道数为64，如果是普通卷积，那么权值参数的数量为3×3×12×64=6912；而如果采用分组卷积的话，假定分4组，那么权值参数的数量为3×3×3×16×4=1728，分组卷积的参数量降低到普通卷积参数量的四分之一。<strong>分组卷积在代码实现上也很简单，只需将torch.nn.Conv2d()函数中的groups参数的值修改一下即可，分几组就修改成几。</strong></p> 
<p>2）深度可分离卷积</p> 
<p>        深度可以分离卷积是讲卷积过程分为Depthwise Convolution与Pointwise Convolution进行。Depthwise Convolution其实就是groups=输入通道数的分组卷积，这样做就完全孤立了像素点在通道上的相互影响，没有有效的利用不同通道在相同空间位置上的feature信息，因此需要Pointwise Convolution来将这些特征图在通道上进行线性组合生成新的特征图。Depthwise Convolution和Pointwise Convolution操作过程分别如下图所示。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/57/3d/cUOB0sTS_o.png"></p> 
<p style="text-align:center;"> Depthwise Convolution</p> 
<p><img alt="" src="https://images2.imgbox.com/59/09/GcIn0Tdp_o.png"></p> 
<p style="text-align:center;"> Pointwise Convolution</p> 
<p>        需要注意的一点是，Depthwise Convolution完成后的特征图通道数与输入层的通道数相同，也就是说Depthwise Convolution不改变通道数，而Pointwise Convolution不仅可以使每个像素点在不同channels上进行线性组合，还可以改变通道数。</p> 
<p>        简单来说，<strong>深度可分离卷积在代码实现上可以当成分组数等于输入通道数的分组卷积与1×1卷积的组合</strong>，一般来说深度可分离卷积的效果要比分组卷积的效果好，和普通卷积的效果差不多，因为深度可分离卷积和普通卷积一样在通道上实现全连接，在空间上局部连接，这更符合图像像素相互作用的特点，但是使用深度可分离卷积，其参数量会比普通卷积减少很多。举个例子，假设输入的shape为（1，12，24，24），卷积核的kernal_size=3，要求输出的通道数为64，如果是普通卷积，那么权值参数的数量为3×3×12×64=6912；如果使用深度可分离卷积，那么权值参数的数量为3×3×1×1×12+1×1×12×64=876。</p> 
<h2 id="2%E3%80%81%E6%B1%A0%E5%8C%96%E5%B1%82">2、池化层</h2> 
<h3 id="2.1%20%E6%B1%A0%E5%8C%96%E7%9A%84%E4%BD%9C%E7%94%A8">2.1 池化的作用</h3> 
<p>       池化层的引入是仿照人的视觉系统对视觉输入对象进行降维和抽象，它主要有以下几种作用：</p> 
<p>①特征不变性：池化操作使模型更加关注图像是否存在某些特征而不管这些特征以什么形式出现，比如特征的位置，大小等。其中特征不变性主要包括平移不变性和尺度不变性等。平移不变性是指输出结果对输入的平移基本保持不变，例如，假设输入为(4，1，3，7，2)，最大池化将会取7，如果将输入左移一位得到(1，3，7，2，0)，输出结果仍将为7；对于尺度不变性，池化操作就相当于图像的resize，平时一张狗的图像被缩小了一倍我们还能认出这是一张狗的照片，这说明这张图像中仍保留着狗最重要的特征，我们一看就能判断图像中画的是一只狗，图像压缩时去掉的信息只是一些无关紧要的信息，而留下的信息则是具有尺度不变性的特征，是最能表达图像的特征。</p> 
<p>②特征降维（下采样）：我们知道一幅图像含有的信息是很大的，特征也很多，但是有些信息对于我们做图像任务时没有太多用途或者有重复，我们可以把这类冗余信息去除，把最重要的特征抽取出来，这也是池化操作的一大作用。</p> 
<p>③池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。</p> 
<p>④实现非线性（类似relu）。</p> 
<p>⑤扩大了感受野。</p> 
<h3 id="2.2%C2%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B1%A0%E5%8C%96%E6%93%8D%E4%BD%9C">2.2 常用的池化操作</h3> 
<p>1）最大池化、平均池化、全局最大池化(GMP)、全局平均池化(GAP)</p> 
<p>        最大池化：选取图像中池化核区域的<strong>最大值</strong>作为该区域池化后的值。</p> 
<p>        平均池化：计算图像中池化核区域的<strong>平均值</strong>作为该区域池化后的值。</p> 
<p>        那么根据什么来决定到底是用最大池化还是平均池化呢？在回答这个问题之前，我们需要明白<strong>网络在对图像进行特征提取时产生的误差主要来自于两方面</strong>：①<strong>邻域大小受限</strong>意味着此部分区域中的数据信息不够全面，从而造成估计值<strong>方差增大</strong>；②卷积层<strong>参数的误差</strong>造成估计值<strong>偏差增大</strong>（正则化那篇文章详细讲了误差可以表示为偏差，方差，噪声之和，即误差=偏差+方差+噪声）。一般来说，平均池化能减小第一种误差，更多的保留图像的背景信息；而最大池化能减小第二种误差，更多的保留图像的纹理信息。如果还不能理解怎么选择最大池化还是平均池化，那换一种解释，就是<strong>当特征图中的信息都应该对模型预测结果有所贡献的时候用平均池化</strong>，比如图像分割中常用全局平均池化来获取全局上下文关系，再例如图像分类任务最后往往是对特征图进行平均池化而不是最大池化，是因为网络深层的高级语义信息一般来说都能帮助分类器分类；另外<strong>为了减少无用信息的影响时使用最大池化</strong>，比如网络浅层常常见到最大池化，因为浅层对图像而言包含了较多无用信息。总结一句话就是网络<strong>浅层一般使用最大池化，深层多使用平均池化</strong>。</p> 
<p>代码实现：</p> 
<pre><code>#1、最大池化
torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)
#参数解释
#kernel_size：池化核的大小
#stride：池化核滑动的步长，默认大小是kernel_size
#padding:在输入图像的两边进行填充，默认是0，即不填充，另外填充值默认是0
#dilation：设置核的膨胀率，默认 dilation=1，如果kernel_size =3，那么核的大小就是3×3。如果        dilation = 2，kernel_size =3×3，那么每列数据与每列数据，每行数据与每行数据中间都再加一行或列数据，数据都用0填充，那么核的大小就变成5×5。
#return_indices：这个参数用来控制要不要返回最大值的索引位置，如果为true那么要记住最大池化后最大值的所在索引位置，后面上采样可能要用上，为false则不用记住位置。
#ceil_mode：它决定的是在计算输出结果形状的时候，是使用向上取整还是向下取整。</code></pre> 
<pre><code>#2、平均池化
torch.nn.AvgPool2d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True, divisor_override=None)
#参数讲解，与最大池化相同的参数代表的意思一样
#count_include_pad：为True时表示平均计算时零填充也包含在内
#divisor_override：如果指定，它将用作除数，否则将使用池化区域的大小</code></pre> 
<pre><code>#3、全局最大池化
torch.nn.AdaptiveMaxPool2d(output_size, return_indices=False)
#这个函数用来自适应最大池化
#output_size：决定将输入图像分几个区域池化，如果output_size=1，就代表全局最大池化</code></pre> 
<pre><code>#全局平均池化
torch.nn.AdaptiveAvgPool2d(output_size)
#这个函数代表自适应平均池化
#output_size：决定输入图像分几个区域进行平均池化，output_size=1，就代表全局平均池化</code></pre> 
<p>2）重叠池化</p> 
<p>就是相邻池化窗口之间<strong>有重叠区域</strong>，此时一般<code>kernel_size &gt; stride</code></p> 
<p>3）空间金字塔池化(SPP)</p> 
<p>        它将一个pooling变成了多个scale的pooling。用不同大小池化窗口作用于上层的特征图。如下图所示，对输入特征图进行了3次不同窗口大小的池化操作，然后送入全连接层。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2a/17/d2ZM8LNL_o.png"></p> 
<p>这样的结构设计可以保证即使带有全连接层的卷积网络也可以处理不同尺寸的图像。为什么全连接层不能处理不同尺寸的图像呢？这是因为全连接层两边的神经元个数必须是固定的，而不同尺寸的输入图像必定神经元的个数是不同的。其代码使用上面提到的自适应最大池化或自适应平均池化即可实现。由SPP发展出了很多类似结构，比如ASPP、ROI Pooling等，这里就不一一列举了。</p> 
<h2 id="3%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%B1%82">3、非线性层</h2> 
<h3 id="3.1%20%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8">3.1 激活函数的作用</h3> 
<p>        激活函数的引入可以为神经网络带来非线性能力，这一点是非常重要的，因为世界上的数据大部分都是非线性的，而线性网络是无法学习和模拟图像、音频等非线性数据的。另外，神经网络中没有引入非线性层，那么神经网络就变成了线性层的简单堆叠， 而多层线性网络的简单堆叠本质上可以用一个线性函数来表示，这就使得神经网络的深度失去了其本来的意义。最后，激活函数还可以把数据从非线性空间映射到线性空间，让数据可以更好地被分类。</p> 
<h3 id="3.2%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0">3.2 常用的激活函数</h3> 
<p>1）sigmoid激活函数</p> 
<p style="text-align:center;"><img alt="sigmoid(x)=\frac{1}{1+e^{-x}}" class="mathcode" src="https://images2.imgbox.com/70/c0/qeUUl9Iz_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/95/38/DiF7nNrf_o.jpg"></p> 
<p>        sigmoid函数将值的范围压缩到(0,1)，刚好符合概率分布的特点，可以在用于概率预测的输出层中使用。其优点是连续且处处可导，缺点是函数值接近0和1时函数梯度较小容易造成梯度消失现象，而且该函数输出值恒为正，不是以0为中心，这会导致权值只往一个方向更新，从而影响收敛速度。</p> 
<p>2）Tanh激活函数</p> 
<p style="text-align:center;"><img alt="tanh=\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}" class="mathcode" src="https://images2.imgbox.com/24/b2/da1PqPJg_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/14/88/yZfPoG3U_o.jpg"></p> 
<p>         tanhx激活函数又叫双曲正切激活函数，该函数将值的范围压缩到(-1,1)，其优点是输出值以0为中心，解决了sigmoid函数中权值只能朝一个方向更新的问题，其缺点是也会造成梯度消失并且计算量巨大。</p> 
<p>3）ReLU激活函数</p> 
<p style="text-align:center;"><img alt="f(x)=max(0,x)" class="mathcode" src="https://images2.imgbox.com/cf/af/bE1xoDfO_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a2/83/IE9vi3RW_o.jpg"></p> 
<p>         ReLU激活函数又叫修正线性单元或线性整流函数，是神经网络中非常常用的一种激活函数。其优点是ReLU具有稀疏性，计算量小，收敛速度快且在<img alt="x&gt;0" class="mathcode" src="https://images2.imgbox.com/2c/b6/XTYDNgNz_o.png">区域，不会出现梯度消失，缺点就是输出不以0为中心并且<img alt="x&lt;0" class="mathcode" src="https://images2.imgbox.com/11/c6/MwmGsfMA_o.png">的这部分神经元的权值永远不会得到更新。</p> 
<p>4）Leaky ReLU激活函数</p> 
<p style="text-align:center;"><img alt="y=max(0,x)+\alpha *min(0,x)" class="mathcode" src="https://images2.imgbox.com/62/be/QzdxaVPT_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/89/fb/kUIIWW42_o.jpg"></p> 
<p>        该激活函数很好地解决了ReLU激活函数中<img alt="x&lt;0" class="mathcode" src="https://images2.imgbox.com/ee/54/5nu9qNNu_o.png">的这部分神经元的权值永远不会得到更新</p> 
<p> 的问题。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a62c8c93b7d0529a2357988c2009d24d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS中的reduce()函数介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/482e5e0a6cd5b5e55cfb4121f663fc7d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot 3 新特性及快速使用示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>