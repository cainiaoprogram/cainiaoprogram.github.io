<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s存储卷 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s存储卷" />
<meta property="og:description" content="目录 一、为什么要存储卷？二、emptyDir存储卷三、hostPath存储卷四、 nfs共享存储卷五、PVC 和 PV5.1 PV和PVC之间的相互作用遵循的生命周期5.2 PV 的状态5.3 一个PV从创建到销毁的具体流程 六、静态创建pv和pvc资源由pod运用过程6.1 在NFS主机上创建共享目录，并且进行exportfs发布6.2 在master主机编写pv资源创建yaml6.3 创建pvc资源，并且设置匹配绑定相应的pv6.4 挂载共享卷，并且进行共享目录写入测试6.5 K8S支持的存储卷的访问模式 七、StorageClass &#43; nfs-client-provisioner搭建动态创建pv7.1 在NFS服务器配置nfs服务7.2 创建 Service Account，用来管理 NFS Provisioner 在 k8s 集群中运行的权限和动态规则7.3 创建 StorageClass，负责建立 PVC 并调用 NFS provisioner 进行预定的工作，并让 PV 与 PVC 建立关联7.4 挂载共享卷，并且进行共享目录写入测试 八、 总结 一、为什么要存储卷？ 容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet 会重启它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动。其次，在Pod中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes 中的Volume抽象就很好的解决了这些问题。Pod中的容器通过Pause容器共享Volume。
二、emptyDir存储卷 当Pod被分配给节点时，首先创建emptyDir卷，并且只要该Pod在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中的容器可以读取和写入emptyDir卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时，emptyDir中的数据将被永久删除。
emptyDir可实现Pod中的容器之间共享目录数据，但是emptyDir卷不能持久化数据，会随着Pod生命周期结束而一起删除。
//创建一个模板文件 mkdir /opt/volumes cd /opt/volumes kubectl run myapp-demo --image=soscscs/myapp:v1 --port=80 --dry-run=client -o yaml &gt; myapp-demo.yaml vim myapp-demo.yaml apiVersion: v1 kind: Pod metadata: labels: run: myapp-demo name: myapp-demo spec: containers: - image: soscscs/myapp:v1 name: myapp-demo ports: - containerPort: 80 cp myapp-demo." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bf4d8f2a18126abb90b870f0f43120c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-04T17:48:58+08:00" />
<meta property="article:modified_time" content="2023-08-04T17:48:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s存储卷</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">一、为什么要存储卷？</a></li><li><a href="#emptyDir_12" rel="nofollow">二、emptyDir存储卷</a></li><li><a href="#hostPath_91" rel="nofollow">三、hostPath存储卷</a></li><li><a href="#_nfs_149" rel="nofollow">四、 nfs共享存储卷</a></li><li><a href="#PVC__PV_235" rel="nofollow">五、PVC 和 PV</a></li><li><ul><li><a href="#51_PVPVC_264" rel="nofollow">5.1 PV和PVC之间的相互作用遵循的生命周期</a></li><li><a href="#52_PV__274" rel="nofollow">5.2 PV 的状态</a></li><li><a href="#53_PV_281" rel="nofollow">5.3 一个PV从创建到销毁的具体流程</a></li></ul> 
  </li><li><a href="#pvpvcpod_291" rel="nofollow">六、静态创建pv和pvc资源由pod运用过程</a></li><li><ul><li><a href="#61_NFSexportfs_296" rel="nofollow">6.1 在NFS主机上创建共享目录，并且进行exportfs发布</a></li><li><a href="#62_masterpvyaml_316" rel="nofollow">6.2 在master主机编写pv资源创建yaml</a></li><li><a href="#63_pvcpv_409" rel="nofollow">6.3 创建pvc资源，并且设置匹配绑定相应的pv</a></li><li><a href="#64__431" rel="nofollow">6.4 挂载共享卷，并且进行共享目录写入测试</a></li><li><a href="#65_K8S_470" rel="nofollow">6.5 K8S支持的存储卷的访问模式</a></li></ul> 
  </li><li><a href="#StorageClass__nfsclientprovisionerpv_475" rel="nofollow">七、StorageClass + nfs-client-provisioner搭建动态创建pv</a></li><li><ul><li><a href="#71_NFSnfs_488" rel="nofollow">7.1 在NFS服务器配置nfs服务</a></li><li><a href="#72__Service_Account_NFS_Provisioner__k8s__500" rel="nofollow">7.2 创建 Service Account，用来管理 NFS Provisioner 在 k8s 集群中运行的权限和动态规则</a></li><li><a href="#73__StorageClass_PVC__NFS_provisioner__PV__PVC__524" rel="nofollow">7.3 创建 StorageClass，负责建立 PVC 并调用 NFS provisioner 进行预定的工作，并让 PV 与 PVC 建立关联</a></li><li><a href="#74__553" rel="nofollow">7.4 挂载共享卷，并且进行共享目录写入测试</a></li></ul> 
  </li><li><a href="#__606" rel="nofollow">八、 总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_7"></a>一、为什么要存储卷？</h2> 
<p>容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet 会重启它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动。其次，在Pod中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes 中的Volume抽象就很好的解决了这些问题。<strong>Pod中的容器通过Pause容器共享Volume</strong>。</p> 
<h2><a id="emptyDir_12"></a>二、emptyDir存储卷</h2> 
<p>当Pod被分配给节点时，首先创建emptyDir卷，并且只要该Pod在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中的容器可以读取和写入emptyDir卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时，emptyDir中的数据将被永久删除。</p> 
<p><strong>emptyDir可实现Pod中的容器之间共享目录数据，但是emptyDir卷不能持久化数据，会随着Pod生命周期结束而一起删除。</strong></p> 
<pre><code class="prism language-bash">//创建一个模板文件
<span class="token function">mkdir</span> /opt/volumes
<span class="token builtin class-name">cd</span> /opt/volumes

kubectl run myapp-demo <span class="token parameter variable">--image</span><span class="token operator">=</span>soscscs/myapp:v1 <span class="token parameter variable">--port</span><span class="token operator">=</span><span class="token number">80</span> --dry-run<span class="token operator">=</span>client <span class="token parameter variable">-o</span> yaml <span class="token operator">&gt;</span> myapp-demo.yaml

<span class="token function">vim</span> myapp-demo.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo
  name: myapp-demo
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo
    ports:
    - containerPort: <span class="token number">80</span>
</code></pre> 
<pre><code class="prism language-bash"><span class="token function">cp</span> myapp-demo.yaml demo1-emptydir.yaml
<span class="token function">vim</span> demo1-emptydir.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo
  name: myapp-empty
spec:
  volumes:
  - name: test-vol
    emptyDir: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo
    ports:
    - containerPort: <span class="token number">80</span>
    volumeMounts:
    - name: test-vol
      mountPath: /var/www/
  - image: busybox:1.28
    name: busybox-demo
    ports:
    - containerPort: <span class="token number">80</span>
    command: <span class="token punctuation">[</span><span class="token string">'/bin/sh'</span>,<span class="token string">'-c'</span>,<span class="token string">'sleep 3600'</span><span class="token punctuation">]</span>
    volumeMounts:
    - name: test-vol
      mountPath: /data/
</code></pre> 
<p><img src="https://images2.imgbox.com/5b/9f/yo8jwooX_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/6a/0c/3BXn52Yr_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl describe pod myapp-empty 
</code></pre> 
<p><img src="https://images2.imgbox.com/89/4f/TGX0dmN2_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> myapp-empty <span class="token parameter variable">-c</span> myapp-demo <span class="token function">sh</span>
//再另外开一个进程
kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> myapp-empty <span class="token parameter variable">-c</span> busybox-demo <span class="token function">sh</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3d/06/1NUSC8gk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a7/a6/0vPyYMYc_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="hostPath_91"></a>三、hostPath存储卷</h2> 
<p>hostPath卷将 node 节点的文件系统中的文件或目录挂载到集群中。<br> hostPath可以实现持久存储，但是在node节点故障时，也会导致数据的丢失。</p> 
<p><strong>把Node节点上的目录/文件挂载到容器中，可实现持久化数据存储。但是存储空间会受到Node节点的单机限制，Node节点故障数据就会丢失，且Pod不能实现跨节点共享数据</strong></p> 
<p><a href="https://kubernetes.io/docs/concepts/storage/volumes#hostpath" rel="nofollow">https://kubernetes.io/docs/concepts/storage/volumes#hostpath</a></p> 
<pre><code class="prism language-bash"><span class="token function">cp</span> myapp-demo.yaml demo2-hostpath.yaml 
<span class="token function">vim</span> demo2-hostpath.yaml 

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo
  name: myapp-demo
spec:
  volumes:
  - name: hostpath-vol
    hostPath:
      path: /var/www/html/
      type: DirectoryOrCreate
  nodeSelector:
    test: b
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo
    ports:
    - containerPort: <span class="token number">80</span>
    volumeMounts:
    - name: hostpath-vol
      mountPath: /usr/share/nginx/html/
      readOnly: <span class="token boolean">false</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/16/22/astLmFX0_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl apply <span class="token parameter variable">-f</span> demo2-hostpath.yaml
kubectl get pods <span class="token parameter variable">-o</span> wide
</code></pre> 
<p><img src="https://images2.imgbox.com/a7/73/XgVaXj8t_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/28/4b/Qj95GqeI_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">//进入容器
kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> myapp-demo <span class="token function">sh</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/44/b3/sUOHGnyX_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fb/d5/6wKnWUIc_o.png" alt="在这里插入图片描述"><br> <strong>在创建Pod时，node02节点的目录会自动挂载到容器的目录上</strong><br> <img src="https://images2.imgbox.com/d1/03/cTikBzsy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/04/ea/uUrLKsfC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cd/c4/IeLaIKyf_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_nfs_149"></a>四、 nfs共享存储卷</h2> 
<p><strong>另开一台节点上安装nfs，并配置nfs服务</strong></p> 
<p><img src="https://images2.imgbox.com/c1/8d/adMHi0fg_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">//在master节点部署
<span class="token function">cp</span> myapp-demo.yaml demo3.nfs.yaml
<span class="token function">vim</span> demo3.nfs.yaml 

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo3
  name: myapp-demo3
spec:
  volumes:
  - name: test-nfs
    nfs:
      path: /opt/share
      server: <span class="token number">192.168</span>.154.13

  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo
    ports:
    - containerPort: <span class="token number">80</span>
    volumeMounts:
    - name: test-nfs
      mountPath: /usr/share/nginx/html
</code></pre> 
<pre><code class="prism language-bash"> kubectl apply <span class="token parameter variable">-f</span> demo3.nfs.yaml
 kubectl get pods <span class="token parameter variable">-owide</span>
</code></pre> 
<pre><code class="prism language-bash"><span class="token function">vim</span> demo3.nfs.yaml 

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo3
  name: myapp-demo4
spec:
  nodeName: node02
  volumes:
  - name: test-nfs
    nfs:
      path: /opt/share
      server: <span class="token number">192.168</span>.154.13

  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo
    ports:
    - containerPort: <span class="token number">80</span>
    volumeMounts:
    - name: test-nfs
      mountPath: /usr/share/nginx/html

</code></pre> 
<pre><code class="prism language-bash"> kubectl apply <span class="token parameter variable">-f</span> demo3.nfs.yaml
 kubectl get pods <span class="token parameter variable">-owide</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1f/8a/0iTM5htZ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/0e/9e/frT3U5RD_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/2a/e4/oliIgssH_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"> kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> myapp-demo3 <span class="token function">sh</span>
  <span class="token builtin class-name">cd</span> /usr/share/nginx/html/

 kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> myapp-demo4 <span class="token function">sh</span>
  <span class="token builtin class-name">cd</span> /usr/share/nginx/html/  
</code></pre> 
<p><img src="https://images2.imgbox.com/d3/08/fSOSclrW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b9/f9/UfrKevJM_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="PVC__PV_235"></a>五、PVC 和 PV</h2> 
<p><strong>PV 全称叫做 Persistent Volume，持久化存储卷。它是用来描述或者说用来定义一个存储卷的，这个通常都是由运维工程师来定义。</strong></p> 
<p><strong>PVC 的全称是 Persistent Volume Claim，是持久化存储的请求。它是用来描述希望使用什么样的或者说是满足什么条件的 PV 存储。</strong></p> 
<p><strong>PVC 的使用逻辑：在 Pod 中定义一个存储卷（该存储卷类型为 PVC），定义的时候直接指定大小，PVC 必须与对应的 PV 建立关系，PVC 会根据配置的定义去 PV 申请，而 PV 是由存储空间创建出来的。PV 和 PVC 是 Kubernetes 抽象出来的一种存储资源。</strong><br> <img src="https://images2.imgbox.com/b2/42/TYAWzjmD_o.png" alt="在这里插入图片描述"><br> <strong>一个PV可以个一个或多个POD使用，PV是k8s集群里专用的存储资源，是逻辑划分存储设备空间的资源对象。存储资源要提供存储空间给存储资源使用，不能凭空出现<br> 真正提供存储空间的是存储设备，如硬盘挂载的目录，nfs共享的目录，ceph分布式存储等<br> 我们作为K8S集群管理员，可以在K8S集群中创建PV，再从存储设备划分存储空间给PV<br> 然后我的POD想引用哪个PV，得先定义一个PVC，用来描述希望使用什么样的或者说是满足什么条件的 PV 存储，比如多大存储空间，是专用，是一对一，还是一对多<br> POD会根据PVC去找符合条件的PV进行绑定，最后给POD挂载使用</strong></p> 
<p>上面介绍的PV和PVC模式是需要运维人员先创建好PV，然后开发人员定义好PVC进行一对一的Bond，但是如果PVC请求成千上万，那么就需要创建成千上万的PV，对于运维人员来说维护成本很高，<strong>Kubernetes提供一种自动创建PV的机制，叫<code>StorageClass</code>，它的作用就是创建PV的模板。</strong></p> 
<p><strong>创建 StorageClass 需要定义 PV 的属性，比如存储类型、大小等；另外创建这种 PV 需要用到的存储插件，比如 Ceph 等。 有了这两部分信息，Kubernetes 就能够根据用户提交的 PVC，找到对应的 StorageClass，然后 Kubernetes 就会调用 StorageClass 声明的存储插件，自动创建需要的 PV 并进行绑定。</strong></p> 
<p><strong>动态创建PV</strong><br> <img src="https://images2.imgbox.com/d6/ff/DuRZlKYy_o.png" alt="在这里插入图片描述"><br> <strong>怎样动态创建PV？</strong><br> <strong>使用StorageClass 引用某一存储设备的存储卷插件，通过调用存储卷插件去到存储设备中动态创建符合PVC需求的存储资源，然后PV和PVC进行绑定，这样Pod就可以使用PV的存储空间</strong></p> 
<p><strong>PV是集群中的资源。 PVC是对这些资源的请求，也是对资源的索引检查。</strong></p> 
<h3><a id="51_PVPVC_264"></a>5.1 PV和PVC之间的相互作用遵循的生命周期</h3> 
<p><strong>PV和PVC之间的相互作用遵循这个生命周期：<br> Provisioning（配置）—&gt; Binding（绑定）—&gt; Using（使用）—&gt; Releasing（释放） —&gt; Recycling（回收）</strong></p> 
<p>●<code>Provisioning</code>，<strong>即 PV 的创建，可以直接创建 PV（静态方式），也可以使用 StorageClass 动态创建</strong><br> ●<code>Binding</code>，<strong>将 PV 分配给 PVC</strong><br> ●<code>Using</code>，<strong>Pod 通过 PVC 使用该 Volume，并可以通过准入控制StorageProtection（1.9及以前版本为PVCProtection） 阻止删除正在使用的 PVC</strong><br> ●<code>Releasing</code>，<strong>Pod 释放 Volume 并删除 PVC</strong><br> ●<code>Reclaiming</code>，<strong>回收 PV，可以保留 PV 以便下次使用，也可以直接从云存储中删除</strong></p> 
<h3><a id="52_PV__274"></a>5.2 PV 的状态</h3> 
<p>根据这 5 个阶段，PV 的状态有以下 4 种：<br> ●<strong>Available</strong>（可用）：表示可用状态，还未被任何 PVC 绑定<br> ●<strong>Bound</strong>（已绑定）：表示 PV 已经绑定到 PVC<br> ●<strong>Released</strong>（已释放）：表示 PVC 被删掉，但是资源尚未被集群回收<br> ●<strong>Failed</strong>（失败）：表示该 PV 的自动回收失败</p> 
<h3><a id="53_PV_281"></a>5.3 一个PV从创建到销毁的具体流程</h3> 
<p><strong>1、一个PV创建完后状态会变成Available，等待被PVC绑定。</strong></p> 
<p><strong>2、一旦被PVC邦定，PV的状态会变成Bound，就可以被定义了相应PVC的Pod使用。</strong></p> 
<p><strong>3、Pod使用完后会释放PV，PV的状态变成Released。</strong></p> 
<p><strong>4、变成Released的PV会根据定义的回收策略做相应的回收工作。有三种回收策略，Retain、Delete和Recycle。Retain就是保留现场，K8S集群什么也不做，等待用户手动去处理PV里的数据，处理完后，再手动删除PV。Delete策略，K8S会自动删除该PV及里面的数据。Recycle方式，K8S会将PV里的数据删除，然后把PV的状态变成Available，又可以被新的PVC绑定使用。</strong></p> 
<h2><a id="pvpvcpod_291"></a>六、静态创建pv和pvc资源由pod运用过程</h2> 
<p>如图所示我们将选择一台k8s集群之外的服务器作为NFS共享存储服务器，并且按照图中的规格</p> 
<p>创建pv，再由k8s集群创建pv资源和pvc资源，最后将其挂载在pod上进行使用<br> <img src="https://images2.imgbox.com/53/5b/zbtbkXAa_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="61_NFSexportfs_296"></a>6.1 在NFS主机上创建共享目录，并且进行exportfs发布</h3> 
<pre><code class="prism language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /opt/k8s/v<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">}</span>
<span class="token function">ls</span> <span class="token parameter variable">-R</span> k8s/

<span class="token function">vim</span> /etc/exports
systemctl status nfs
exportfs <span class="token parameter variable">-arv</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e3/2c/kEl4fDZr_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d9/f8/LPfjDafo_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">//其他两个node节点能不能看到
showmount <span class="token parameter variable">-e</span> <span class="token number">192.168</span>.154.13
</code></pre> 
<p><img src="https://images2.imgbox.com/0d/77/ZxQWyBF9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="62_masterpvyaml_316"></a>6.2 在master主机编写pv资源创建yaml</h3> 
<p><strong>访问模式有：</strong></p> 
<ul><li><strong><code>ReadWriteOnce</code></strong><br> 卷可以被一个节点以读写方式挂载。 ReadWriteOnce 访问模式也允许运行在同一节点上的多个 Pod 访问卷。</li><li><strong><code>ReadOnlyMany</code></strong><br> 卷可以被多个节点以只读方式挂载。</li><li><strong><code>ReadWriteMany</code></strong><br> 卷可以被多个节点以读写方式挂载。</li></ul> 
<pre><code class="prism language-bash">//在master主机编写pv资源创建yaml
<span class="token function">mkdir</span> <span class="token function">pv</span>
<span class="token builtin class-name">cd</span> pv/
<span class="token function">vim</span> pv1.yaml

apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv001
spec:
  accessModes:
  - ReadWriteOnce
  - ReadWriteMany
  capacity:
    storage: 1Gi
  nfs:
    path: /opt/k8s/v1
    server: <span class="token number">192.168</span>.154.13
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv002
spec:
  accessModes:
  - ReadWriteOnce
  capacity:
    storage: 2Gi
  nfs:
    path: /opt/k8s/v2
    server: <span class="token number">192.168</span>.154.13
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv003
spec:
  accessModes:
  - ReadWriteOnce
  - ReadWriteMany
  capacity:
    storage: 2Gi
  nfs:
    path: /opt/k8s/v3
    server: <span class="token number">192.168</span>.154.13
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv004
spec:
  accessModes:
  - ReadWriteOnce
  - ReadWriteMany
  capacity:
    storage: 4Gi
  nfs:
    path: /opt/k8s/v4
    server: <span class="token number">192.168</span>.154.13
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv005
spec:
  accessModes:
  - ReadWriteOnce
  - ReadWriteMany
  capacity:
    storage: 5Gi
  nfs:
    path: /opt/k8s/v1
    server: <span class="token number">192.168</span>.154.13

</code></pre> 
<pre><code class="prism language-bash">kubectl apply <span class="token parameter variable">-f</span> pv1.yaml
kubectl get <span class="token function">pv</span>
 
</code></pre> 
<p><img src="https://images2.imgbox.com/74/d0/CJg3lQhP_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="63_pvcpv_409"></a>6.3 创建pvc资源，并且设置匹配绑定相应的pv</h3> 
<p><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims" rel="nofollow">https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims</a></p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> pvc1.yaml

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc01
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 2Gi
</code></pre> 
<p><img src="https://images2.imgbox.com/dc/9e/5r1ZeRP8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/36/c9/nQVMIaBA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a0/c8/Ss1JvXHX_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="64__431"></a>6.4 挂载共享卷，并且进行共享目录写入测试</h3> 
<pre><code class="prism language-bash"> kubectl run myapp-demo <span class="token parameter variable">--image</span><span class="token operator">=</span>soscscs/myapp:v1 <span class="token parameter variable">--port</span><span class="token operator">=</span><span class="token number">80</span> --dry-run<span class="token operator">=</span>client <span class="token parameter variable">-oyaml</span> <span class="token operator">&gt;</span> myapp-demo.yaml
<span class="token function">cp</span> myapp-demo.yaml demo1.yaml
<span class="token function">vim</span> demo1.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo1
  name: myapp-demo1
spec:
  volumes:
    - name: test-vol
      persistentVolumeClaim:
        claimName: mypvc01

  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo1
    ports:
    - containerPort: <span class="token number">80</span>
    volumeMounts:
    - name: test-vol
      mountPath: /data/
</code></pre> 
<pre><code class="prism language-bash">kubectl apply <span class="token parameter variable">-f</span> demo1.yaml 
kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> myapp-demo1 <span class="token function">sh</span>
<span class="token builtin class-name">cd</span> /data/
<span class="token builtin class-name">echo</span> <span class="token string">'Hello World'</span> <span class="token operator">&gt;</span> index.html
</code></pre> 
<p><img src="https://images2.imgbox.com/a3/62/iCQgE5x0_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/33/29/Fc0s8xAy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="65_K8S_470"></a>6.5 K8S支持的存储卷的访问模式</h3> 
<p><img src="https://images2.imgbox.com/26/5a/VU4jdmWH_o.png" alt="在这里插入图片描述"></p> 
<p><strong>其中 × 表示支持，- 表示不支持</strong></p> 
<h2><a id="StorageClass__nfsclientprovisionerpv_475"></a>七、StorageClass + nfs-client-provisioner搭建动态创建pv</h2> 
<p><strong>StorageClass + nfs-client-provisioner的理解</strong><br> 上面介绍的PV和PVC模式是需要运维人员先创建好PV，然后开发人员定义好PVC进行一对一的Bond，但是如果PVC请求成千上万，那么就需要创建成千上万的PV，对于运维人员来说维护成本很高，Kubernetes提供一种自动创建PV的机制，叫StorageClass，它的作用就是创建PV的模板。</p> 
<p>创建 StorageClass 需要定义 PV 的属性，比如存储类型、大小等；另外创建这种 PV 需要用到的存储插件，比如 Ceph 等。 有了这两部分信息，Kubernetes 就能够根据用户提交的 PVC，找到对应的 StorageClass，然后 Kubernetes 就会调用 StorageClass 声明的存储插件，自动创建需要的 PV 并进行绑定。</p> 
<p><strong>Kubernetes 本身支持的动态 PV 创建不包括 NFS，所以需要使用外部存储卷插件分配PV。详见：</strong><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/" rel="nofollow">https://kubernetes.io/zh/docs/concepts/storage/storage-classes/</a></p> 
<p><strong>卷插件称为 Provisioner（存储分配器），NFS 使用的是 nfs-client，这个外部卷插件会使用已经配置好的 NFS 服务器自动创建 PV。<br> Provisioner：用于指定 Volume 插件的类型，包括内置插件（如 kubernetes.io/aws-ebs）和外部插件（如 external-storage 提供的 ceph.com/cepfs）。</strong></p> 
<h3><a id="71_NFSnfs_488"></a>7.1 在NFS服务器配置nfs服务</h3> 
<pre><code class="prism language-bash">//nfs服务器
<span class="token function">mkdir</span> /opt/k8s
<span class="token function">vim</span> /etc/exports
/opt/k8s <span class="token number">192.168</span>.154.0/24<span class="token punctuation">(</span>rw,sync,no_root_squash<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/35/2f/ALOP6QMn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4f/9b/WGqB5mYO_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="72__Service_Account_NFS_Provisioner__k8s__500"></a>7.2 创建 Service Account，用来管理 NFS Provisioner 在 k8s 集群中运行的权限和动态规则</h3> 
<pre><code class="prism language-bash">//master节点
<span class="token builtin class-name">cd</span> pv/
<span class="token function">mkdir</span> sc
<span class="token builtin class-name">cd</span> sc/
<span class="token function">unzip</span> nfs-client.zip 
</code></pre> 
<p><img src="https://images2.imgbox.com/16/5e/v0o39dep_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/8f/60/mimTV5j0_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/de/96/2qOYGxdJ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>创建网络插件</strong><br> <img src="https://images2.imgbox.com/69/fd/UfpbN1af_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cd/97/1TAtMvOg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/83/71/pdezfKAG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1d/3e/8KfeChde_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e5/23/FlMNwTw7_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/7f/53/2jTbZHGe_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="73__StorageClass_PVC__NFS_provisioner__PV__PVC__524"></a>7.3 创建 StorageClass，负责建立 PVC 并调用 NFS provisioner 进行预定的工作，并让 PV 与 PVC 建立关联</h3> 
<pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /etc/kubernetes/manifests/
<span class="token function">vim</span> kube-apiserver.yaml 

- --feature-gates<span class="token operator">=</span>RemoveSelfLink<span class="token operator">=</span>false

</code></pre> 
<p><img src="https://images2.imgbox.com/59/e8/PjC0pd6B_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> pvc.yaml

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc01-nfs
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 2Gi
  storageClassName: nfs-client-storageclass
</code></pre> 
<p><img src="https://images2.imgbox.com/b7/c5/orFdkvRE_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="74__553"></a>7.4 挂载共享卷，并且进行共享目录写入测试</h3> 
<pre><code class="prism language-bash"><span class="token function">vim</span> pod-demo.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo1
  name: myapp-demo1
spec:
  volumes:
    - name: test-vol
      persistentVolumeClaim:
        claimName: mypvc01-nfs

  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo1
    ports:
    - containerPort: <span class="token number">80</span>
    volumeMounts:
    - name: test-vol
      mountPath: /data/
</code></pre> 
<p><img src="https://images2.imgbox.com/92/b2/dVQhYtEa_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/62/e5/ZY6UA6fY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/dc/56/X0vjfz2A_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token function">cp</span> pvc.yaml pvc1.yaml
<span class="token function">vim</span> pvc1.yaml

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc02-nfs
spec:
  accessModes:
    - ReadOnlyMany
  resources:
    requests:
      storage: 2Gi
  storageClassName: nfs-client-storageclass
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/53/wL93X20i_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d1/ff/TaideZMG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f3/3a/UHs9zhvO_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__606"></a>八、 总结</h2> 
<p><strong>k8s 存储卷 volumes</strong></p> 
<ul><li><strong>emptyDir</strong> <strong>：可实现Pod中的容器之间共享目录数据，但emptyDir存储卷没有持久化数据的能力，存储卷会随着Pod生命周期结束而一起删除</strong></li><li><strong>hostPath</strong> <strong>：将Node节点上的目录/文件挂载到容器的指定目录中，有持久化数据的能力，但只能在单个Node节点上持久化数据，不能实现跨节点的Pod共享数据</strong></li><li><strong>nfs</strong> <strong>：使用NFS服务将存储设备的共享目录挂载到容器的指定目录中，有持久化数据的能力，且也能实现跨节点的Pod共享数据</strong></li></ul> 
<p><strong>PV PVC</strong><br> <strong>PV ：K8S在指定的存储设备空间中逻辑划分创建的可持久化的存储资源对象<br> PVC ：是对PV资源对象的请求和绑定，也是一致Pod可挂载的存储卷类型</strong></p> 
<p><strong>PV的状态 4 种</strong></p> 
<ul><li><strong>Available（可用）：表示可用状态，还未被任何 PVC 绑定</strong></li><li><strong>Bound（已绑定）：表示 PV 已经绑定到 PVC</strong></li><li><strong>Released（已释放）：表示 PVC 被删掉，但是资源尚未被回收</strong></li><li><strong>Failed（失败）：表示该 PV 的自动回收失败</strong></li></ul> 
<p><strong>创建和使用 静态PV</strong><br> <strong>1）准备好存储设备和共享目录</strong><br> <strong>2）手动创建PV资源，配置 存储卷类型 访问模式（RWO RWX ROX） 存储能力大小</strong><br> <strong>3）创建PVC资源，配置请求PV资源的问模式（必要条件，必须是PV能支持的访问模式）和存储大小（就近选择大于等于指定大小的PV）来绑定PV（一个PV只能绑定一个PVC）</strong><br> <strong>4）创建Pod资源挂载PVC存储卷，配置存储卷类型为 persistentVolumeClaim ，在容器配置中定义存储卷的挂载点</strong></p> 
<p><strong>创建和使用 动态PV</strong><br> <strong>1）准备好存储设备和共享目录<br> 2）如果是外置存储卷插件，需要先创建service account账户（Pod应用使用的账户）和RBAC授权（创建角色授予相应资源对象的操作权限，角色与账户绑定），使得 sa 账户具有对PV PVC SC等资源的操作权限<br> 3）创建外置存储卷插件Provisioner的Pod，配置中使用sa账户作为Pod账户，并设置相关环境变量参数<br> 4）创建SC资源(StorageClass)，配置中引用之前定义的Provisioner的名称</strong><br> <strong>-------------- 以上过程是一劳永逸的，以后只需要创建PVC时引用StorageClass就可以动态生成相关PV资源 ---------------<br> 5）创建PVC资源，配置中引用StorageClass资源名称。创建PVC资源后会自动创建相关的PV资源。<br> 6）创建Pod资源挂载PVC存储卷，配置存储卷类型为 persistentVolumeClaim ，在容器配置中定义存储卷的挂载点</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b0ddcf980e0a49e81232f742c03283da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为什么说Yii2.0比Laravel更快？底层原理是什么？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b6f2fde99205316d8c08cac386ff321/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jdk1.8的安装和环境变量的配置最新版（超详细，保姆级教程）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>