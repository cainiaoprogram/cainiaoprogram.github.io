<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>矩阵转置算法和一些简单的加，减，乘法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="矩阵转置算法和一些简单的加，减，乘法" />
<meta property="og:description" content="矩阵转置分为方阵的转置和非方阵的转置，方阵支持原地转置，非方阵则不支持。
方阵原地转置算法：
template&lt;class T&gt; void transpose(T **a,int rows) { for(int i=0;i&lt;rows;i&#43;&#43;) for(int j=i&#43;1;j&lt;rows;j&#43;&#43;) swap(a[i][j],a[j][i]) } 因为方阵转置前后他们的形状不变，所以可以原地转换。
一般矩阵的转置方法：
template&lt;class T&gt; void transpose(T **a,int rows,int cols) { T **b=new T*[cols]; for(int k=0;k&lt;cols;k&#43;&#43;) b[k]=new T[rows] for(int i=0;i&lt;rows;i&#43;&#43;) for(int j=i&#43;1;j&lt;cols;j&#43;&#43;) swap(a[i][j],b[j][i]) return b } for(int i=0;i&lt;cols;i&#43;&#43;) delete [] b[i]; delete [] b; 对于一般矩阵，转置后空间会不一样，所以我们事先在堆中为转置后的矩阵申请一块空间，然后再进行赋值运算，最后返回转置后的矩阵，但是注意，申请的空间在用后，要手动析构不然会出现内存泄漏。
两个矩阵的加法：
template&lt;class T&gt; void matrixAdd(T **a,T **b,T **c,int numberOfRows,int numberOfCols) { for (int i=0;i&lt;numberOfRows;i&#43;&#43;) for(int j=0;j&lt;numberOfCols;j&#43;&#43;) c[i][j]=a[i][j]&#43;b[i][j] } 这个加法很简单吧。
m*n矩阵与n*p矩阵的乘法:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4a86e44a83952c6f742ffe34aadf1788/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-14T09:55:59+08:00" />
<meta property="article:modified_time" content="2018-07-14T09:55:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">矩阵转置算法和一些简单的加，减，乘法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>矩阵转置分为方阵的转置和非方阵的转置，方阵支持原地转置，非方阵则不支持。</p> 
<p>方阵原地转置算法：</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
void transpose(T **a,int rows)
{
	for(int i=0;i&lt;rows;i++)
		for(int j=i+1;j&lt;rows;j++)
			swap(a[i][j],a[j][i])
}</code></pre> 
<p>因为方阵转置前后他们的形状不变，所以可以原地转换。</p> 
<p>一般矩阵的转置方法：</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
void transpose(T **a,int rows,int cols)
{
	T **b=new T*[cols];
	for(int k=0;k&lt;cols;k++)
		b[k]=new T[rows]
	for(int i=0;i&lt;rows;i++)
		for(int j=i+1;j&lt;cols;j++)
			swap(a[i][j],b[j][i])
	return b 
}
for(int i=0;i&lt;cols;i++)
	delete [] b[i];
delete [] b;</code></pre> 
<p>对于一般矩阵，转置后空间会不一样，所以我们事先在堆中为转置后的矩阵申请一块空间，然后再进行赋值运算，最后返回转置后的矩阵，但是注意，申请的空间在用后，要手动析构不然会出现内存泄漏。</p> 
<p>两个矩阵的加法：</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
void matrixAdd(T **a,T **b,T **c,int numberOfRows,int numberOfCols)
{
	for (int i=0;i&lt;numberOfRows;i++)
		for(int j=0;j&lt;numberOfCols;j++)
			c[i][j]=a[i][j]+b[i][j]
}</code></pre> 
<p>这个加法很简单吧。</p> 
<p>m*n矩阵与n*p矩阵的乘法:</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
void matrixMultiply(T **a,T **b,T **c,int m,int n,int p)
{
	for(int i=0;i&lt;m;i++)
		for(int j=0;i&lt;p;j++)
		{
			T sum=0;
			for(int k=0;k&lt;n;k++)
				sum+=a[i][k]+b[k][j]
			c[i][j]=sum;
		}
		
}</code></pre> 
<br> 
<p>这个函数有3个for循环，乍看有点绕脑，仔细看后发现还是很简单的，m*n矩阵与n*p矩阵相乘后就是m*p矩阵，所以我们首先两个for循环构造一个m*p的框架，然后再在第二个for循环里面进行矩阵的行与列的乘法与加法。</p> 
<p>上面这个写法比较容易理解，但是这种写法却并不是最快的算法，考虑到计算机存取数据的机制，将其中的for循环进行交换后它的速度会有个小幅度的提升，我们之前的循环次序是i,j,k我们交换为i,k,j后，同样的计算机，相同的执行步数，但是速度就是会不同。</p> 
<p>这是为什么呢？一个简单的计算机结构有一个主存，一个二级缓存，一个一级缓存和若干个寄存器和一个ALU，数据的一般流动方式为主存-&gt;二级缓存-&gt;一级缓存-&gt;寄存器-&gt;ALU，分别所需要的时间为100机器周期，10机器周期，2机器周期，1机器周期。所以要是数据都在主存，那么每次计算时都要从主存调取数据，速度会非常慢。计算机为了提高速度采取了一些策略。以数组为例，将需要的数据和其同行的相邻数组预先装载至缓存以加速，在ijk顺序中a和c数组的顺序的按行取数据，而b是按列取数据，所以b进行运算时取数据很慢。而ikj都是按行取数据，所以所以速度会快很多。</p> 
<br> 
<p><br></p> 
<p><br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d013f59b82a02294ec312c3a301b5ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis集群重启</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4cb1ed1ab49eeee329276c97ae859bd7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu编译找不到eigen3的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>