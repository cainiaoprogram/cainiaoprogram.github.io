<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【LeetCode】27. 移除元素（简单）——代码随想录算法训练营第1天 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【LeetCode】27. 移除元素（简单）——代码随想录算法训练营第1天" />
<meta property="og:description" content="题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &lt; len; i&#43;&#43;) { print(nums[i]); } 示例 1：
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0700a067a6d8bc84b82c3295d4363cf7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T00:42:37+08:00" />
<meta property="article:modified_time" content="2024-01-11T00:42:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【LeetCode】27. 移除元素（简单）——代码随想录算法训练营第1天</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>题目描述</h3> 
<p>给你一个数组 nums 和一个值 val，你需要 <strong>原地</strong> 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p> 
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 <strong>原地</strong> 修改输入数组。</p> 
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p> 
<p>说明:</p> 
<blockquote> 
 <p>为什么返回数值是整数，但输出的答案是数组呢?</p> 
 <p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p> 
 <p>你可以想象内部操作如下:</p> 
 <pre><code class="language-javascript">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}</code></pre> 
</blockquote> 
<p>示例 1：</p> 
<blockquote> 
 <p>输入：nums = [3,2,2,3], val = 3<br> 输出：2, nums = [2,2]<br> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</p> 
</blockquote> 
<p>示例 2：</p> 
<blockquote> 
 <p>输入：nums = [0,1,2,2,3,0,4,2], val = 2<br> 输出：5, nums = [0,1,3,0,4]<br> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p> 
</blockquote> 
<p>提示：</p> 
<blockquote> 
 <p>0 &lt;= nums.length &lt;= 100<br> 0 &lt;= nums[i] &lt;= 50<br> 0 &lt;= val &lt;= 100</p> 
</blockquote> 
<div></div> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="color:#333333;">文章讲解：</span><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html" rel="nofollow" title="代码随想录">代码随想录</a></p> 
 <p style="margin-left:0;text-align:left;"><span style="color:#333333;">视频讲解：</span><a href="https://www.bilibili.com/video/BV12A4y1Z7LP" rel="nofollow" title="数组中移除元素并不容易！ | LeetCode：27. 移除元素_哔哩哔哩_bilibili">数组中移除元素并不容易！ | LeetCode：27. 移除元素_哔哩哔哩_bilibili</a></p> 
</div> 
<p> </p> 
<h3>题解1：暴力法</h3> 
<p>思路：用一个变量记录当前遍历的位置，用一个新变量查找下一个非目标值的位置，将用此值前移覆盖要删除的元素。</p> 
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let i = j = 0;
    // 变量 i 记录当前检索位置，变量 j 查找下一个非目标值的位置
    while (i &lt; nums.length) {
        if (nums[i] === val) {
            // 遇到要删除的元素，查找下一个不需要删除的元素的位置
            j = i + 1;
            while (nums[j] === val) {
                j++;
            }
            if (j === nums.length) {
                return i; // 查找到数组末尾，返回 i
            }
            nums[i] = nums[j]; // 将不删除的元素前移覆盖要删除的元素
            nums[j] = val; // 将 j 位置标记为要删除元素的位置
        }
        i++;
    }
    return i; // 查找结束，返回 i
};</code></pre> 
<p>分析：此解法用了双层循环，j 变量重复遍历了多次数组，时间复杂度为 O(n²)，空间复杂度为 O(1)。存在不必要的消耗，可以使用快慢指针法来优化。</p> 
<h3>题解2：快慢指针法</h3> 
<p>定义快慢指针：</p> 
<ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新新数组下标的位置</li></ul> 
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let i = 0; // 慢指针，记录当前位置
    for (let j = 0; j &lt; nums.length; j++) {
        // 快指针，查找下一个非目标值
        if (nums[j] !== val) {
            nums[i++] = nums[j]; // 将非目标值前移，且慢指针自增
        }
    }
    return i; // 返回慢指针位置，即为移除元素后新数组元素的个数
};</code></pre> 
<p>分析：使用双指针法，只需遍历一次数组，时间复杂度为 O(n)，空间复杂度为 O(1)。此方法没有改变原数组元素的顺序。</p> 
<h3>题解3：相向双指针法</h3> 
<p>思路：题目中提到元素顺序可以改变，因此可以使用相向双指针法从数组的两边来遍历数组。左边寻找等于目标值的元素，右边寻找不为目标值的元素，交换位置得到新数组。</p> 
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let left = 0, right = nums.length - 1;
    while (left &lt;= right) {
        // 从左边找等于 val 的元素
        while (left &lt;= right &amp;&amp; nums[left] !== val) {
            left++;
        }
        // 从右边找不等于 val 的元素
        while (left &lt;= right &amp;&amp; nums[right] === val) {
            right--;
        }
        // 右边覆盖左边
        if (left &lt; right) {
            nums[left++] = nums[right--];
        }
    }
    return left; // left 此时是新数组最后一个元素的下一个位置，即为新数组长度
};</code></pre> 
<p>分析：使用相向双指针法，只需遍历一次数组，时间复杂度为 O(n)，空间复杂度为 O(1)。此方法改变了原数组元素的顺序。</p> 
<h3>收获</h3> 
<p>初次体验了快慢指针法和相向双指针法这两种双指针法的使用，并理解了它们的原理。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8392f675f447cd1e90431802de0ff30f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">“编程语言大比拼：Python、JavaScript、Java与C#的优劣与选择“。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3fb017a563c5aaa40b37b030ae129e88/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">嵌出式学习又一天</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>