<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式——抽象工厂 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式——抽象工厂" />
<meta property="og:description" content="抽象工厂 目的 抽象工厂是一种创建型的设计模式，它允许您生成一系列相关的对象而无需指定它们的具体类。
问题 假设您正在创建一个家具商店模拟器。你的代码由以下类组成：
系列相关产品，如:Chair &#43; Sofa &#43; CoffeeTable。
这个家族的几个派生。例如Chair &#43; Sofa &#43; CoffeeTable产品有Modern、Victorian、ArtDeco等多种版本。
您需要一种方法来创建单独的家具对象以便它们与同类的其他对象相匹配。顾客收到不匹配的家具时会很生气。
此外在向程序添加新产品或产品族时，您不希望更改现有代码。家具供应商经常更新他们的目录，您不会希望每次都更改核心代码。
解决方案 抽象工厂模式建议的第一件事是为产品家族的每个不同产品(例如，椅子、沙发或茶几)显式地声明接口。然后您可以让所有具体产品遵循这些接口。例如所有椅子变体都可以实现chair接口；所有的咖啡桌变体都可以实现CoffeeTable接口。
下一步是声明抽象工厂——一个包含所有产品的创建方法列表的接口（例如createChair，createSofa，createCoffeeTable)。这些方法必须返回由我们前面提取的接口表示的抽象产品类型:Chair、Sofa、CoffeeTable等等。
现在具体产品呢？对于产品系列的具体产品，我们基于AbstractFactory接口创建一个单独的工厂类。工厂是返回特定类型产品的类。例如ModernFurnitureFactory只能创建ModernChair， ModernSofa和ModernCoffeeTable物件。
客户端代码必须通过各自的抽象接口与工厂和产品一起工作。这允许您更改传递给客户端代码的工厂类型以及客户端代码接收的产品变体而不会破坏实际的客户端代码。
结构 抽象产品为组成产品族的一组相关的产品统一声明接口。
具体产品是抽象产品的各种实现，按类型分组。具体产品(Victorian/Modern)必须实现抽象产品的接口。
抽象工厂接口声明了一组创建抽象产品的方法。
具体工厂实现了抽象工厂的创建方法。每个具体工厂对应于一组具体产品并且只创建这些具体产品。
虽然具体的工厂实例化具体的产品，但是它们的创建方法的签名必须返回相应的抽象产品。这样，使用工厂的客户机代码就不会与它从工厂获得的产品的特定变体耦合。客户端可以使用任何具体的工厂/产品变体，只要它通过抽象接口与它们的对象通信。
伪码 这个例子说明了如何使用抽象工厂模式来创建跨平台的UI元素而不用将客户端代码耦合到具体的UI类，同时保持所有创建的元素与所选的操作系统一致。
在跨平台应用程序中相同的UI元素的行为应该是相似的，但在不同的操作系统下看起来会有些不同。此外确保UI元素与当前操作系统的风格匹配是您的工作。您不希望您的程序在Windows中执行时呈现macOS控件。
抽象工厂接口声明了一组创建方法，客户端代码可以使用这些方法来生成不同类型的UI元素。具体的工厂对应于特定的操作系统并创建与特定操作系统相匹配的UI元素。
它是这样工作的：当一个应用程序启动时，它检查当前操作系统的类型。应用程序使用这个信息从一个匹配操作系统的类中创建一个工厂对象。剩下的代码使用这个工厂来创建UI元素。这可以防止创建错误的元素。
使用这种方法，客户端代码不依赖于工厂和UI元素的具体类只要它通过抽象接口处理这些对象即可。这也允许客户端代码支持将来可能添加的其他工厂或UI元素。
因此你不需要每次在你的应用程序中添加一个新的UI元素变体时修改客户端代码。你只需要创建一个新的工厂类来产生这些元素并稍微修改应用程序的初始化代码，以便它在适当的时候选择那个类。
// The abstract factory interface declares a set of methods that // return different abstract products. These products are called // a family and are related by a high-level theme or concept. // Products of one family are usually able to collaborate among // themselves." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2ebd9278878f36f9ac4aef4d2da9f18c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-19T09:49:34+08:00" />
<meta property="article:modified_time" content="2022-06-19T09:49:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式——抽象工厂</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>抽象工厂</h3> 
<h4><a id="_1"></a>目的</h4> 
<p><strong>抽象工厂</strong>是一种创建型的设计模式，它允许您生成一系列相关的对象而无需指定它们的具体类。<br> <img src="https://images2.imgbox.com/3e/2a/OqreiRW5_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_4"></a>问题</h4> 
<p>假设您正在创建一个家具商店模拟器。你的代码由以下类组成：</p> 
<ol><li> <p>系列相关产品，如:<code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code>。</p> </li><li> <p>这个家族的几个派生。例如<code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code>产品有<code>Modern</code>、<code>Victorian</code>、<code>ArtDeco</code>等多种版本。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/78/cb/bDhUetCo_o.png" alt="产品族和它的变种"><br> 您需要一种方法来创建单独的家具对象以便它们与同类的其他对象相匹配。顾客收到不匹配的家具时会很生气。</p> 
<p><img src="https://images2.imgbox.com/1f/aa/hd5ZT3iL_o.png" alt="一个现代风格的沙发跟维多利亚时期的并不匹配"><br> 此外在向程序添加新产品或产品族时，您不希望更改现有代码。家具供应商经常更新他们的目录，您不会希望每次都更改核心代码。</p> 
<h4><a id="_17"></a>解决方案</h4> 
<p>抽象工厂模式建议的第一件事是为产品家族的每个不同产品(例如，椅子、沙发或茶几)显式地声明接口。然后您可以让所有具体产品遵循这些接口。例如所有椅子变体都可以实现chair接口；所有的咖啡桌变体都可以实现CoffeeTable接口。</p> 
<p><img src="https://images2.imgbox.com/f8/50/kaxObP81_o.png" alt="同一对象的所有变量必须移动到单个类层次结构中"><br> 下一步是声明抽象工厂——一个包含所有产品的创建方法列表的接口（例如<code>createChair</code>，<code>createSofa</code>，<code>createCoffeeTable</code>)。这些方法必须返回由我们前面提取的接口表示的<strong>抽象</strong>产品类型:<code>Chair</code>、<code>Sofa</code>、<code>CoffeeTable</code>等等。<br> <img src="https://images2.imgbox.com/64/26/zPiinb9p_o.png" alt="在这里插入图片描述"><br> 现在具体产品呢？对于产品系列的具体产品，我们基于<code>AbstractFactory</code>接口创建一个单独的工厂类。工厂是返回特定类型产品的类。例如<code>ModernFurnitureFactory</code>只能创建<code>ModernChair</code>， <code>ModernSofa</code>和<code>ModernCoffeeTable</code>物件。</p> 
<p>客户端代码必须通过各自的抽象接口与工厂和产品一起工作。这允许您更改传递给客户端代码的工厂类型以及客户端代码接收的产品变体而不会破坏实际的客户端代码。</p> 
<p><img src="https://images2.imgbox.com/00/d8/MKOGVXR1_o.png" alt="客户端不应该关心它工作的工厂的具体类"></p> 
<h4><a id="_28"></a>结构</h4> 
<p><img src="https://images2.imgbox.com/85/bf/HT0QbQ2Q_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p><strong>抽象产品</strong>为组成产品族的一组相关的产品统一声明接口。</p> </li><li> <p><strong>具体产品</strong>是抽象产品的各种实现，按类型分组。具体产品(Victorian/Modern)必须实现抽象产品的接口。</p> </li><li> <p><strong>抽象工厂</strong>接口声明了一组创建抽象产品的方法。</p> </li><li> <p><strong>具体工厂</strong>实现了抽象工厂的创建方法。每个具体工厂对应于一组具体产品并且只创建这些具体产品。</p> </li><li> <p>虽然具体的工厂实例化具体的产品，但是它们的创建方法的签名必须返回相应的抽象产品。这样，使用工厂的客户机代码就不会与它从工厂获得的产品的特定变体耦合。<strong>客户端</strong>可以使用任何具体的工厂/产品变体，只要它通过抽象接口与它们的对象通信。</p> </li></ol> 
<h4><a id="_40"></a>伪码</h4> 
<p>这个例子说明了如何使用抽象工厂模式来创建跨平台的UI元素而不用将客户端代码耦合到具体的UI类，同时保持所有创建的元素与所选的操作系统一致。</p> 
<p><img src="https://images2.imgbox.com/23/e0/voJSq0bv_o.png" alt="跨平台的UI类型"><br> 在跨平台应用程序中相同的UI元素的行为应该是相似的，但在不同的操作系统下看起来会有些不同。此外确保UI元素与当前操作系统的风格匹配是您的工作。您不希望您的程序在Windows中执行时呈现macOS控件。</p> 
<p>抽象工厂接口声明了一组创建方法，客户端代码可以使用这些方法来生成不同类型的UI元素。具体的工厂对应于特定的操作系统并创建与特定操作系统相匹配的UI元素。</p> 
<p>它是这样工作的：当一个应用程序启动时，它检查当前操作系统的类型。应用程序使用这个信息从一个匹配操作系统的类中创建一个工厂对象。剩下的代码使用这个工厂来创建UI元素。这可以防止创建错误的元素。</p> 
<p>使用这种方法，客户端代码不依赖于工厂和UI元素的具体类只要它通过抽象接口处理这些对象即可。这也允许客户端代码支持将来可能添加的其他工厂或UI元素。</p> 
<p>因此你不需要每次在你的应用程序中添加一个新的UI元素变体时修改客户端代码。你只需要创建一个新的工厂类来产生这些元素并稍微修改应用程序的初始化代码，以便它在适当的时候选择那个类。</p> 
<pre><code class="prism language-java"><span class="token comment">// The abstract factory interface declares a set of methods that</span>
<span class="token comment">// return different abstract products. These products are called</span>
<span class="token comment">// a family and are related by a high-level theme or concept.</span>
<span class="token comment">// Products of one family are usually able to collaborate among</span>
<span class="token comment">// themselves. A family of products may have several variants,</span>
<span class="token comment">// but the products of one variant are incompatible with the</span>
<span class="token comment">// products of another variant.</span>
<span class="token keyword">interface</span> <span class="token class-name">GUIFactory</span> is
    method <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Button</span>
    method <span class="token function">createCheckbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Checkbox</span>


<span class="token comment">// Concrete factories produce a family of products that belong</span>
<span class="token comment">// to a single variant. The factory guarantees that the</span>
<span class="token comment">// resulting products are compatible. Signatures of the concrete</span>
<span class="token comment">// factory's methods return an abstract product, while inside</span>
<span class="token comment">// the method a concrete product is instantiated.</span>
<span class="token keyword">class</span> <span class="token class-name">WinFactory</span> <span class="token keyword">implements</span> <span class="token class-name">GUIFactory</span> is
    method <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Button</span> is
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WinButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    method <span class="token function">createCheckbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Checkbox</span> is
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WinCheckbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// Each concrete factory has a corresponding product variant.</span>
<span class="token keyword">class</span> <span class="token class-name">MacFactory</span> <span class="token keyword">implements</span> <span class="token class-name">GUIFactory</span> is
    method <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Button</span> is
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MacButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    method <span class="token function">createCheckbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Checkbox</span> is
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MacCheckbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment">// Each distinct product of a product family should have a base</span>
<span class="token comment">// interface. All variants of the product must implement this</span>
<span class="token comment">// interface.</span>
<span class="token keyword">interface</span> <span class="token class-name">Button</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// Concrete products are created by corresponding concrete</span>
<span class="token comment">// factories.</span>
<span class="token keyword">class</span> <span class="token class-name">WinButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token comment">// Render a button in Windows style.</span>

<span class="token keyword">class</span> <span class="token class-name">MacButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token comment">// Render a button in macOS style.</span>

<span class="token comment">// Here's the base interface of another product. All products</span>
<span class="token comment">// can interact with each other, but proper interaction is</span>
<span class="token comment">// possible only between products of the same concrete variant.</span>
<span class="token keyword">interface</span> <span class="token class-name">Checkbox</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">WinCheckbox</span> <span class="token keyword">implements</span> <span class="token class-name">Checkbox</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token comment">// Render a checkbox in Windows style.</span>

<span class="token keyword">class</span> <span class="token class-name">MacCheckbox</span> <span class="token keyword">implements</span> <span class="token class-name">Checkbox</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token comment">// Render a checkbox in macOS style.</span>


<span class="token comment">// The client code works with factories and products only</span>
<span class="token comment">// through abstract types: GUIFactory, Button and Checkbox. This</span>
<span class="token comment">// lets you pass any factory or product subclass to the client</span>
<span class="token comment">// code without breaking it.</span>
<span class="token keyword">class</span> <span class="token class-name">Application</span> is
    <span class="token keyword">private</span> field factory<span class="token operator">:</span> <span class="token class-name">GUIFactory</span>
    <span class="token keyword">private</span> field button<span class="token operator">:</span> <span class="token class-name">Button</span>
    constructor <span class="token class-name">Application</span><span class="token punctuation">(</span>factory<span class="token operator">:</span> <span class="token class-name">GUIFactory</span><span class="token punctuation">)</span> is
        <span class="token keyword">this</span><span class="token punctuation">.</span>factory <span class="token operator">=</span> factory
    method <span class="token function">createUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token keyword">this</span><span class="token punctuation">.</span>button <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        button<span class="token punctuation">.</span><span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment">// The application picks the factory type depending on the</span>
<span class="token comment">// current configuration or environment settings and creates it</span>
<span class="token comment">// at runtime (usually at the initialization stage).</span>
<span class="token keyword">class</span> <span class="token class-name">ApplicationConfigurator</span> is
    method <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        config <span class="token operator">=</span> <span class="token function">readApplicationConfigFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>OS <span class="token operator">==</span> <span class="token string">"Windows"</span><span class="token punctuation">)</span> then
            factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WinFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>OS <span class="token operator">==</span> <span class="token string">"Mac"</span><span class="token punctuation">)</span> then
            factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MacFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Error! Unknown operating system."</span><span class="token punctuation">)</span>

        <span class="token class-name">Application</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Application</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_149"></a>应用场景</h4> 
<p><strong>当您的代码需要使用各种系列的相关产品，但您不希望它依赖于这些产品的具体类——它们可能事先不为人知或您希望允许未来的可扩展性时，使用抽象工厂。</strong></p> 
<p>抽象工厂为您提供了一个从产品家族的每个类中创建对象的接口。只要你的代码通过这个接口创建对象，你就不必担心创建的产品的错误变体与你的应用程序已经创建的产品不匹配。</p> 
<ul><li> <p>当你有一个类，它有一组模糊了它的主要职责的工厂方法时，考虑实现抽象工厂。</p> </li><li> <p>在一个设计良好的程序中，每个类只负责一件事。当一个类处理多个产品类型时，可能有必要将其工厂方法提取到独立的工厂类或成熟的抽象工厂实现中。</p> </li></ul> 
<h4><a id="_158"></a>如何实现</h4> 
<ol><li>绘制出不同产品类型和这些产品变体的矩阵。</li><li>为所有产品类型声明抽象产品接口。然后让所有具体的产品类实现这些接口。</li><li>使用所有抽象产品的一组创建方法声明抽象工厂接口。</li><li>实现一组具体的工厂类，每个产品变体一个。</li><li>在应用程序的某个地方创建工厂初始化代码。它应该实例化一个具体的工厂类，这取决于应用程序配置或当前环境。将这个工厂对象传递给所有构造产品的类。</li><li>扫描代码并找到所有对产品构造函数的直接调用。将它们替换为对工厂对象的适当创建方法的调用。</li></ol> 
<h4><a id="_166"></a>正反面</h4> 
<p><strong>正面因素：</strong></p> 
<ul><li>你可以确定你从工厂得到的产品是相互兼容的。</li><li>您可以避免具体产品和客户端代码之间的紧密耦合。</li><li>单一责任原则。您可以将产品创建代码提取到一个地方使代码更易于支持。</li><li>打开/关闭原则。您可以在不破坏现有客户端代码的情况下引入新的产品变体。</li></ul> 
<p><strong>反面因素：</strong></p> 
<ul><li>代码可能会变得比它应该的更加复杂，因为随着模式引入了许多新的接口和类。</li></ul> 
<h4><a id="_176"></a>同其他设计模式的关系</h4> 
<ul><li> <p>许多设计开始使用<strong>工厂方法</strong>(更简单，更可通过子类定制)，然后发展到<strong>抽象工厂</strong>、<strong>原型</strong>或<strong>构建器</strong>(更灵活，但更复杂)。</p> </li><li> <p><strong>构建器</strong>专注于一步一步地构建复杂对象。<strong>抽象工厂</strong>专门用于创建相关对象族。<strong>抽象工厂</strong>立即返回产品，而<strong>构建器</strong>允许您在获取产品之前运行一些额外的构造步骤。</p> </li><li> <p><strong>抽象工厂</strong>类通常基于一组<strong>工厂方法</strong>，但您也可以使用<strong>原型模式</strong>来组合这些类上的方法。</p> </li><li> <p>当您只想隐藏从客户端代码创建子系统对象的方式时，<strong>抽象工厂</strong>可以作为<strong>外观模式</strong>的替代方案。</p> </li><li> <p>你可以同时使用<strong>抽象工厂</strong>和<strong>桥模式</strong>。当<strong>桥模式</strong>定义的某些抽象只能用于特定的实现时，这种配对很有用。在这种情况下，抽象工厂可以封装这些关系并对客户端代码隐藏复杂性。</p> </li><li> <p><strong>抽象工厂</strong>、<strong>构建器</strong>和<strong>原型</strong>都可以实现为<strong>单例</strong>。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21c396bb6e76b678ed363e3b9f3c1e4c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nginx location（正则）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e237e5f7c6836410db5391fb5a42a1b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">企业级WEB应用服务器TOMCAT</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>