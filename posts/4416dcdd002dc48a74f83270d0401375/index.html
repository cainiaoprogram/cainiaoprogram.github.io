<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>「前端进阶」高性能渲染十万条数据(虚拟列表) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="「前端进阶」高性能渲染十万条数据(虚拟列表)" />
<meta property="og:description" content="为什么需要使用虚拟列表? 参考：https://github.com/chenqf/vue-virtual-listview
假设我们的长列表需要展示10000条记录，我们同时将10000条记录渲染到页面中，先来看看需要花费多长时间：
&lt;button id=&#34;button&#34;&gt;button&lt;/button&gt;&lt;br&gt; &lt;ul id=&#34;container&#34;&gt;&lt;/ul&gt; document.getElementById(&#39;button&#39;).addEventListener(&#39;click&#39;, function () { let now = Date.now(); const total = 10000; let ul = document.getElementById(&#39;container&#39;); for (let i = 0; i &lt; total; i&#43;&#43;) { let li = document.createElement(&#39;li&#39;); li.innerText = i ul.appendChild(li); } console.log(&#39;JS运行时间：&#39;, Date.now() - now); setTimeout(() =&gt; { console.log(&#39;总运行时间：&#39;, Date.now() - now); }, 0) //JS运行时间： 38 //总运行时间： 957 }) 当我们点击按钮，会同时向页面中加入一万条记录，通过控制台的输出，我们可以粗略的统计到，JS的运行时间为38ms,但渲染完成后的总时间为957ms。
简单说明一下，为何两次console.log的结果时间差异巨大，并且是如何简单来统计JS运行时间和总渲染时间：
在 JS 的Event Loop中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染第一个console.log的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间第二个console.log是放到 setTimeout 中的，它的触发时间是在渲染完成，在下一次Event Loop中执行。 在实际的工作中，列表项不会像例子中仅仅只由一个li标签组成，必然是由复杂DOM节点组成的。那么可以想象的是，当列表项数过多并且列表项结构复杂的时候，同时渲染时，会在Recalculate Style和Layout阶段消耗大量的时间。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4416dcdd002dc48a74f83270d0401375/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-12T11:31:02+08:00" />
<meta property="article:modified_time" content="2022-04-12T11:31:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">「前端进阶」高性能渲染十万条数据(虚拟列表)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>为什么需要使用虚拟列表?</h3> 
<p>参考：<a href="https://github.com/chenqf/vue-virtual-listview">https://github.com/chenqf/vue-virtual-listview</a><br> 假设我们的长列表需要展示10000条记录，我们同时将10000条记录渲染到页面中，先来看看需要花费多长时间：</p> 
<pre><code>&lt;button id="button"&gt;button&lt;/button&gt;&lt;br&gt;
&lt;ul id="container"&gt;&lt;/ul&gt;  

</code></pre> 
<pre><code>document.getElementById('button').addEventListener('click', function () {
    let now = Date.now();
    const total = 10000;
    let ul = document.getElementById('container');
    for (let i = 0; i &lt; total; i++) {
        let li = document.createElement('li');
        li.innerText = i
        ul.appendChild(li);
    }
    console.log('JS运行时间：', Date.now() - now);
    setTimeout(() =&gt; {
        console.log('总运行时间：', Date.now() - now);
    }, 0)
    //JS运行时间： 38
    //总运行时间： 957
})
</code></pre> 
<p>当我们点击按钮，会同时向页面中加入一万条记录，通过控制台的输出，我们可以粗略的统计到，JS的运行时间为38ms,但渲染完成后的总时间为957ms。<br> 简单说明一下，为何两次console.log的结果时间差异巨大，并且是如何简单来统计JS运行时间和总渲染时间：</p> 
<ul><li>在 JS 的Event Loop中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染</li><li>第一个console.log的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间</li><li>第二个console.log是放到 setTimeout 中的，它的触发时间是在渲染完成，在下一次Event Loop中执行。</li></ul> 
<p>在实际的工作中，列表项不会像例子中仅仅只由一个li标签组成，必然是由复杂DOM节点组成的。那么可以想象的是，当列表项数过多并且列表项结构复杂的时候，同时渲染时，会在Recalculate Style和Layout阶段消耗大量的时间。<br> 而<font color="red">虚拟列表</font>就是解决这一问题的一种实现。</p> 
<h3><a id="_38"></a>什么是虚拟列表?</h3> 
<p><font color="red">虚拟列表</font>其实是按需显示的一种实现，即只对<font color="red">可见区域</font>进行渲染，对<font color="red">非可见区域</font>中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。<br> 假设有1万条记录需要同时渲染，我们屏幕的<font color="red">可见区域</font>的高度为500px，而列表项的高度为50px，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条即可。<br> <img src="https://images2.imgbox.com/c6/a1/DiTdj7s0_o.png" alt="在这里插入图片描述"><br> 说完首次加载，再分析一下当滚动发生时，我们可以通过计算当前滚动值得知此时在屏幕可见区域应该显示的列表项。</p> 
<p>假设滚动发生，滚动条距顶部的位置为150px，则我们可得知在可见区域内的列表项为第4项至第13项</p> 
<p><img src="https://images2.imgbox.com/c9/a1/NmgYwAfi_o.png" alt="在这里插入图片描述"><br> <strong>实现</strong><br> 在首屏加载的时候，只加载可视区域内需要的列表项，当滚动发生时，动态通过计算获得可视区域内的列表项，并将非可视区域内存在的列表项删除。</p> 
<ul><li>计算当前可视区域起始数据索引(startIndex)</li><li>计算当前可视区域结束数据索引(endIndex)</li><li>计算当前可视区域的数据，并渲染到页面中</li><li>计算startIndex对应的数据在整个列表中的偏移位置startOffset并设置到列表上<br> <img src="https://images2.imgbox.com/4a/1f/lD76DsZS_o.png" alt="在这里插入图片描述"><br> 完整代码：<a href="https://codesandbox.io/s/virtuallist-1-rp8pi" rel="nofollow">https://codesandbox.io/s/virtuallist-1-rp8pi</a></li></ul> 
<h3><a id="_56"></a>列表项动态高度：</h3> 
<p>在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本之类的可变内容，会导致列表项的高度并不相同。</p> 
<p>在虚拟列表中应用动态高度的解决方案一般有如下三种：</p> 
<blockquote> 
 <p><font color="red">1.对组件属性itemSize进行扩展，支持传递类型为数字、数组、函数</font></p> 
</blockquote> 
<p>可以是一个固定值，如 100，此时列表项是固高的<br> 可以是一个包含所有列表项高度的数据，如 [50, 20, 100, 80, …]<br> 可以是一个根据列表项索引返回其高度的函数：(index: number): number</p> 
<p>这种方式虽然有比较好的灵活度，但仅适用于可以预先知道或可以通过计算得知列表项高度的情况，依然无法解决列表项高度由内容撑开的情况。</p> 
<blockquote> 
 <p><font color="red">2.将列表项渲染到屏幕外，对其高度进行测量并缓存，然后再将其渲染至可视区域内。</font></p> 
</blockquote> 
<p>由于预先渲染至屏幕外，再渲染至屏幕内，这导致渲染成本增加一倍，这对于数百万用户在低端移动设备上使用的产品来说是不切实际的。</p> 
<blockquote> 
 <p><font color="red">3.以预估高度先行渲染，然后获取真实高度并缓存。</font></p> 
</blockquote> 
<p>这是我选择的实现方式，可以避免前两种方案的不足。</p> 
<p><strong>实现</strong><br> 1.定义组件属性estimatedItemSize,用于接收预估高度</p> 
<pre><code>props: {
  //预估高度
  estimatedItemSize:{
    type:Number
  }
}
</code></pre> 
<p>2.定义<font color="red">positions</font>，用于列表项渲染后存储每一项的高度以及位置信息，并在初始时根据estimatedItemSize对positions进行初始化。</p> 
<pre><code>initPositions(){
  this.positions = this.listData.map((item,index)=&gt;{
    return {
      index,
      height:this.estimatedItemSize,
      top:index * this.estimatedItemSize,
      bottom:(index + 1) * this.estimatedItemSize
    }
  })
}
</code></pre> 
<p>由于列表项高度不定，并且我们维护了positions，用于记录每一项的位置，而列表高度实际就等于列表中最后一项的底部距离列表顶部的位置。</p> 
<pre><code>//列表总高度
listHeight(){
  return this.positions[this.positions.length - 1].bottom;
}
</code></pre> 
<p>由于需要在渲染完成后，获取列表每项的位置信息并缓存，所以使用钩子函数updated来实现：</p> 
<pre><code>updated(){
  let nodes = this.$refs.items;
  nodes.forEach((node)=&gt;{
    let rect = node.getBoundingClientRect();
    let height = rect.height;
    let index = +node.id.slice(1)
    let oldHeight = this.positions[index].height;
    let dValue = oldHeight - height;
    //存在差值
    if(dValue){
      this.positions[index].bottom = this.positions[index].bottom - dValue;
      this.positions[index].height = height;
      for(let k = index + 1;k&lt;this.positions.length; k++){
        this.positions[k].top = this.positions[k-1].bottom;
        this.positions[k].bottom = this.positions[k].bottom - dValue;
      }
    }
  })
}
</code></pre> 
<p>滚动后获取列表开始索引的方法修改为通过缓存获取：</p> 
<pre><code>//获取列表起始索引
getStartIndex(scrollTop = 0){
  let item = this.positions.find(i =&gt; i &amp;&amp; i.bottom &gt; scrollTop);
  return item.index;
}
</code></pre> 
<p>由于我们的缓存数据，本身就是有顺序的，所以获取开始索引的方法可以考虑通过二分查找的方式来降低检索次数：</p> 
<pre><code>//获取列表起始索引
getStartIndex(scrollTop = 0){
  //二分法查找
  return this.binarySearch(this.positions,scrollTop)
},
//二分法查找
binarySearch(list,value){
  let start = 0;
  let end = list.length - 1;
  let midIndex = null;
  while(start &lt;= end){
    midIndex = parseInt((start + end)/2);
    let midValue = list[midIndex].bottom;
    if(midValue === value){
      return midIndex + 1;
    }else if(midValue &lt; value){
      start = midIndex + 1;
    }else if(midValue &gt; value){
      end = end - 1;
    }
  }
  return midIndex;
},

</code></pre> 
<p>滚动后将偏移量的获取方式变更：</p> 
<pre><code>scrollEvent() {
  //...省略
  if(this.start &gt;= 1){
    this.startOffset = this.positions[this.start - 1].bottom
  }else{
    this.startOffset = 0;
  }
}
</code></pre> 
<p>完整代码：<a href="https://codesandbox.io/s/virtuallist2-1bqk6" rel="nofollow">https://codesandbox.io/s/virtuallist2-1bqk6</a></p> 
<p>我们实现了基于文字内容动态撑高列表项情况下的虚拟列表，但是我们可能会发现，当滚动过快时，会出现短暂的白屏现象。<br> 为了使页面平滑滚动，我们还需要在可见区域的上方和下方渲染额外的项目，在滚动时给予一些缓冲，所以将屏幕分为三个区域：</p> 
<ul><li>可视区域上方：above</li><li>可视区域：screen</li><li>可视区域下方：below<br> <img src="https://images2.imgbox.com/8f/4a/RTCtbFT6_o.png" alt="在这里插入图片描述"><br> <strong>实现</strong><br> 定义组件属性bufferScale,用于接收缓冲区数据与可视区数据的比例</li></ul> 
<pre><code>props: {
  //缓冲区比例
  bufferScale:{
    type:Number,
    default:1
  }
}
</code></pre> 
<p>可视区上方渲染条数aboveCount获取方式如下：</p> 
<pre><code>aboveCount(){
  return Math.min(this.start,this.bufferScale * this.visibleCount)
}
</code></pre> 
<p>可视区下方渲染条数belowCount获取方式如下：</p> 
<pre><code>belowCount(){
  return Math.min(this.listData.length - this.end,this.bufferScale * this.visibleCount);
}
</code></pre> 
<p>真实渲染数据visibleData获取方式如下：</p> 
<pre><code>visibleData(){
  let start = this.start - this.aboveCount;
  let end = this.end + this.belowCount;
  return this._listData.slice(start, end);
}
</code></pre> 
<p>完整代码：<a href="https://codesandbox.io/s/virtuallist-3-i3h9v" rel="nofollow">https://codesandbox.io/s/virtuallist-3-i3h9v</a></p> 
<blockquote> 
 <p>基于这个方案，基于Vue2.x的虚拟列表组件：<a href="https://github.com/chenqf/vue-virtual-listview">vue-virtual-listview</a></p> 
</blockquote> 
<h3><a id="_232"></a>面向未来</h3> 
<p>在前文中我们使用监听scroll事件的方式来触发可视区域中数据的更新，当滚动发生后，scroll事件会频繁触发，很多时候会造成重复计算的问题，从性能上来说无疑存在浪费的情况。</p> 
<p>可以使用<font color="red">IntersectionObserver</font>替换监听scroll事件，IntersectionObserver可以监听目标元素是否出现在可视区域内，在监听的回调事件中执行可视区域数据的更新，并且IntersectionObserver的监听回调是异步触发，不随着目标元素的滚动而触发，性能消耗极低。</p> 
<h3><a id="_238"></a>遗留问题</h3> 
<p>我们虽然实现了根据列表项动态高度下的虚拟列表，但如果列表项中包含图片，并且列表高度由图片撑开，由于图片会发送网络请求，此时无法保证我们在获取列表项真实高度时图片是否已经加载完成，从而造成计算不准确的情况。</p> 
<p>这种情况下，如果我们能监听列表项的大小变化就能获取其真正的高度了。我们可以使用<font color="red">ResizeObserver</font>来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度。</p> 
<p>不过仅有少数浏览器支持ResizeObserver。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb4a6d630e0518d0c9d2256bba05db0b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Opencv4.0学习记录（opencv4.0&#43;vs2015环境配置）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4eaa7e39dbd53a4c9bebfcf1af54cb80/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JS 合并数组的三大方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>