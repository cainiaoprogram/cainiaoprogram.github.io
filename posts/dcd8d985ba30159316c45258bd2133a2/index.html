<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis7知识点总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis7知识点总结" />
<meta property="og:description" content="文章目录 1. redis单线程为啥会这么快2. redis数据类型和底层存储结构2.1 string类型2.1.1 SDS 2.2 hash类型2.3 list类型2.4 set类型（集合）2.5 zset类型（有序集合）2.6 ziplist压缩列表2.7 listpack2.8 quicklist-快速列表2.9 skiplist 跳表 3. redis高可用方案（集群策略）4. redis淘汰key算法5. redis过期key删除策略6. redis分布式锁7. redis数据持久化8. redis如何配置key的过期时间，实现原理9. redis主从复制原理10. redis高并发问题11. 热点数据缓存重建问题 1. redis单线程为啥会这么快 基于内存操作，一条命令几十纳秒单线程，减少线程切换使用io多路复用技术使用高效的数据存储结构，链表和数组 2. redis数据类型和底层存储结构 参考： Redis的五种数据结构的底层实现原理
type数据类型，对应的是value五种数据类型。
字符串：REDIS_STRING；
哈希：REDIS_HASH；
列表：REDIS_LIST；
集合：REDIS_SET；
有序集合：REDIS_ZSET
encoding类型如下图
String类型的编码方式，即encoding有三种：int、embstr、raw。
value的值是整数，encoding为int，没有对应底层数据结构；
value长度小于32，encoding为embstr，长度大于，32编码为raw，embstr和raw都使用SDS数据结构存储。
2.1 string类型 By default, a single Redis string can be a maximum of 512 MB.
2.1.1 SDS 参考： Redis 源码解读——sds
sds优势
提升性能，sds直接使用len字段获取长度，时间复杂度是o(1), c语言中获取字符串长度是遍历，直到遇到‘\0’,时间复杂度是o(n)保证二进制安全，sds遇到‘\0’不会结束，c语言字符串遇到‘\0’结束减少内存再分配次数， sds修改字符串不一定会重新分配内存，采用的是空间与分配和惰性空间释放策略来避免内存再分配，len小于1M，会分配2len(str)的空间，修改时，空间够则不进行分配，不够则再分配2len(总str), 修改后字符串长度大于1M，则再分配1m的未使用空间， 当c语言修改字符串，会进行内存再分配策略" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dcd8d985ba30159316c45258bd2133a2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-15T19:27:34+08:00" />
<meta property="article:modified_time" content="2022-12-15T19:27:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis7知识点总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_redis_1" rel="nofollow">1. redis单线程为啥会这么快</a></li><li><a href="#2_redis_6" rel="nofollow">2. redis数据类型和底层存储结构</a></li><li><ul><li><a href="#21_string_20" rel="nofollow">2.1 string类型</a></li><li><ul><li><a href="#211_SDS_22" rel="nofollow">2.1.1 SDS</a></li></ul> 
   </li><li><a href="#22_hash_34" rel="nofollow">2.2 hash类型</a></li><li><a href="#23_list_36" rel="nofollow">2.3 list类型</a></li><li><a href="#24_set_39" rel="nofollow">2.4 set类型（集合）</a></li><li><a href="#25_zset_43" rel="nofollow">2.5 zset类型（有序集合）</a></li><li><a href="#26_ziplist_45" rel="nofollow">2.6 ziplist压缩列表</a></li><li><a href="#27_listpack_55" rel="nofollow">2.7 listpack</a></li><li><a href="#28_quicklist_58" rel="nofollow">2.8 quicklist-快速列表</a></li><li><a href="#29_skiplist__79" rel="nofollow">2.9 skiplist 跳表</a></li></ul> 
  </li><li><a href="#3_redis_87" rel="nofollow">3. redis高可用方案（集群策略）</a></li><li><a href="#4_rediskey_93" rel="nofollow">4. redis淘汰key算法</a></li><li><a href="#5_rediskey_95" rel="nofollow">5. redis过期key删除策略</a></li><li><a href="#6_redis_98" rel="nofollow">6. redis分布式锁</a></li><li><a href="#7_redis_102" rel="nofollow">7. redis数据持久化</a></li><li><a href="#8_rediskey_108" rel="nofollow">8. redis如何配置key的过期时间，实现原理</a></li><li><a href="#9_redis_114" rel="nofollow">9. redis主从复制原理</a></li><li><a href="#10_redis_117" rel="nofollow">10. redis高并发问题</a></li><li><a href="#11__119" rel="nofollow">11. 热点数据缓存重建问题</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_redis_1"></a>1. redis单线程为啥会这么快</h2> 
<ol><li>基于内存操作，一条命令几十纳秒</li><li>单线程，减少线程切换</li><li>使用io多路复用技术</li><li>使用高效的数据存储结构，链表和数组</li></ol> 
<h2><a id="2_redis_6"></a>2. redis数据类型和底层存储结构</h2> 
<p>参考： <a href="https://blog.csdn.net/a745233700/article/details/113449889">Redis的五种数据结构的底层实现原理</a></p> 
<p>type数据类型，对应的是value五种数据类型。<br> 字符串：REDIS_STRING；<br> 哈希：REDIS_HASH；<br> 列表：REDIS_LIST；<br> 集合：REDIS_SET；<br> 有序集合：REDIS_ZSET<br> encoding类型如下图<br> <img src="https://images2.imgbox.com/7d/c8/Y5N1FyYf_o.png" alt="在这里插入图片描述"><br> String类型的编码方式，即encoding有三种：int、embstr、raw。<br> value的值是整数，encoding为int，没有对应底层数据结构；<br> value长度小于32，encoding为embstr，长度大于，32编码为raw，embstr和raw都使用SDS数据结构存储。</p> 
<h3><a id="21_string_20"></a>2.1 string类型</h3> 
<p>By default, a single Redis string can be a maximum of 512 MB.</p> 
<h4><a id="211_SDS_22"></a>2.1.1 SDS</h4> 
<p>参考： <a href="https://segmentfault.com/a/1190000041832335" rel="nofollow">Redis 源码解读——sds</a><br> <img src="https://images2.imgbox.com/31/b6/fZGyS6w6_o.png" alt="在这里插入图片描述"><br> sds优势</p> 
<ol><li>提升性能，sds直接使用len字段获取长度，时间复杂度是o(1), c语言中获取字符串长度是遍历，直到遇到‘\0’,时间复杂度是o(n)</li><li>保证二进制安全，sds遇到‘\0’不会结束，c语言字符串遇到‘\0’结束</li><li>减少内存再分配次数， sds修改字符串不一定会重新分配内存，采用的是空间与分配和惰性空间释放策略来避免内存再分配，len小于1M，会分配2<em>len(str)的空间，修改时，空间够则不进行分配，不够则再分配2</em>len(总str), 修改后字符串长度大于1M，则再分配1m的未使用空间， 当c语言修改字符串，会进行内存再分配策略<br> 参考： <a href="https://www.cnblogs.com/kmcl1314/articles/15896129.html" rel="nofollow">redis字符串实现，空间与分配,sds和c区别</a></li><li>兼容c函数， 用于字符串比较，strcmp(sds_str-&gt;buf, buf)，buf属性为一个字符数组，，最后一个保存空字符’\0’，空字符不算进len中</li><li>杜绝缓冲区溢出<br> <img src="https://images2.imgbox.com/c4/4c/9F5DoDs3_o.png" alt="在这里插入图片描述"><br> 参考：<a href="https://blog.csdn.net/qq_39240270/article/details/88384976?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-88384976-blog-117433390.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-88384976-blog-117433390.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1">理解Redis设计与实现(一)：简单动态字符串(SDS)</a></li></ol> 
<h3><a id="22_hash_34"></a>2.2 hash类型</h3> 
<p>listpack 和hash表</p> 
<h3><a id="23_list_36"></a>2.3 list类型</h3> 
<p><img src="https://images2.imgbox.com/be/02/LLUO5GvC_o.png" alt="在这里插入图片描述"><br> quicklist</p> 
<h3><a id="24_set_39"></a>2.4 set类型（集合）</h3> 
<p>intset和哈希表<br> 参考： <a href="https://blog.csdn.net/m0_53804791/article/details/121294227">Redis之intset(整数集合)</a></p> 
<h3><a id="25_zset_43"></a>2.5 zset类型（有序集合）</h3> 
<p>listpack和skiplist</p> 
<h3><a id="26_ziplist_45"></a>2.6 ziplist压缩列表</h3> 
<p>是经过特殊编码的可以存储字符串或整数的双向链表<br> 参考 ： <a href="https://blog.csdn.net/solo_jm/article/details/118520888">Redis Ziplist（压缩列表）</a><br> <img src="https://images2.imgbox.com/8a/68/KPKAggaN_o.png" alt="在这里插入图片描述"></p> 
<ul><li>zlbytes：记录整个ziplist的大小。</li><li>zltail：ziplist开始指针与最后一个entry之间的偏移量，通过该偏移量可以获得最后一个entry。</li><li>zllen：entry数量。</li><li>entry：存储具体数据的节点。</li><li>zlend：ziplist结尾标识。<br> <strong>ziplist会导致级联更新，降低性能</strong></li></ul> 
<h3><a id="27_listpack_55"></a>2.7 listpack</h3> 
<p>与ziplist类似<br> <img src="https://images2.imgbox.com/2a/ae/HbqNruAb_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="28_quicklist_58"></a>2.8 quicklist-快速列表</h3> 
<p><img src="https://images2.imgbox.com/75/37/oWOzXcrM_o.png" alt="在这里插入图片描述"></p> 
<ul><li>-2 表示zlbytes 最大8k<br> <img src="https://images2.imgbox.com/d0/2d/e36UkEyv_o.png" alt="在这里插入图片描述"></li></ul> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token punctuation">{<!-- --></span>
    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>        <span class="token comment">/* total count of all entries in all listpacks */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>          <span class="token comment">/* number of quicklistNodes */</span>
    <span class="token keyword">signed</span> <span class="token keyword">int</span> fill <span class="token operator">:</span> QL_FILL_BITS<span class="token punctuation">;</span>       <span class="token comment">/* fill factor for individual nodes */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token operator">:</span> QL_COMP_BITS<span class="token punctuation">;</span> <span class="token comment">/* depth of end nodes not to compress;0=off */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bookmark_count<span class="token operator">:</span> QL_BM_BITS<span class="token punctuation">;</span>
    quicklistBookmark bookmarks<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span>
</code></pre> 
<ol><li>检索（遍历 zlen 的和 与index比较）</li><li>插入数据， 先检索，再插入，插入数据时需要判断插入数据的大小<br> <img src="https://images2.imgbox.com/fc/8a/JwplDUov_o.png" alt="在这里插入图片描述"></li><li>删除元素<br> 如果删除后ziplist 没有元素，则需要吧该ziplist也从链表中移除</li></ol> 
<h3><a id="29_skiplist__79"></a>2.9 skiplist 跳表</h3> 
<p><img src="https://images2.imgbox.com/e4/83/TVlCdeGm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0e/0c/4pLV4JSV_o.png" alt="在这里插入图片描述"></p> 
<p>优点：查询快<br> 缺点：节点增或删除之后需要更新层级结构，采用随机化的层级结构解决此问题</p> 
<p><strong>参考</strong>：<a href="https://blog.csdn.net/zzti_erlie/article/details/112132712">Redis源码解析：数据结构详解-skiplist</a></p> 
<h2><a id="3_redis_87"></a>3. redis高可用方案（集群策略）</h2> 
<ol><li>主从集群-1主多从</li><li>主从+哨兵</li><li>多主多从模式</li></ol> 
<p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzI3MjY1ODI2Ng==&amp;mid=2247486094&amp;idx=1&amp;sn=f727b9fe6f53f4ebc5280dd09d6161ed&amp;chksm=eb2e70bbdc59f9ad8157859f0c6eb5fa881c9e147d7e03ca9693633f7d2bff7215d0f813c847&amp;scene=27" rel="nofollow">4 种 Redis 集群方案介绍 + 优缺点对比</a></p> 
<h2><a id="4_rediskey_93"></a>4. redis淘汰key算法</h2> 
<p>LRU(least recently used) 和LFU(least frequently used)</p> 
<h2><a id="5_rediskey_95"></a>5. redis过期key删除策略</h2> 
<p>惰性过期-只有访问到了才回去检查是否过期，过期则删掉<br> 定期过期- 隔一定时间扫描一定数量的key,删除过期的</p> 
<h2><a id="6_redis_98"></a>6. redis分布式锁</h2> 
<ul><li><a href="https://baijiahao.baidu.com/s?id=1730716661153081344&amp;wfr=spider&amp;for=pc" rel="nofollow">一文搞定Redis分布式锁的实现和原理</a></li><li><a href="https://www.cnblogs.com/wangyingshuo/p/14510524.html" rel="nofollow">Redis实现分布式锁的7种方案，及正确使用姿势！</a></li><li><a href="https://blog.csdn.net/weixin_46129192/article/details/126010250">Redis实现分布式锁</a></li></ul> 
<h2><a id="7_redis_102"></a>7. redis数据持久化</h2> 
<p>rdb和aof</p> 
<ul><li><a href="https://blog.csdn.net/weixin_47626220/article/details/123511339">Redis 数据持久化</a></li><li><a href="https://blog.csdn.net/HappyLearnerL/article/details/128264426">redis7.0.5数据持久化(RDB和AOF)</a></li><li><a href="https://baijiahao.baidu.com/s?id=1708708550003841683&amp;wfr=spider&amp;for=pc" rel="nofollow">深度好文：Redis持久化</a></li><li><a href="https://www.cnblogs.com/shenStudy/p/16757742.html" rel="nofollow">redis的两种持久化方式</a></li></ul> 
<h2><a id="8_rediskey_108"></a>8. redis如何配置key的过期时间，实现原理</h2> 
<p>expire<br> setex<br> 惰性过期-只有访问到了才回去检查是否过期，过期则删掉<br> 定期过期- 隔一定时间扫描一定数量的key,删除过期的, 平衡执行频率和执行时长，会遍历每个database(默认16个)， 检查当前数据库中执行的key(默认20个)， 随机抽查key, 过期就删除</p> 
<h2><a id="9_redis_114"></a>9. redis主从复制原理</h2> 
<ul><li><a href="https://blog.csdn.net/u013994536/article/details/124087770">Redis主从复制</a></li><li><a href="https://blog.csdn.net/qq_34827674/article/details/123448733">Redis 主从复制1</a></li></ul> 
<h2><a id="10_redis_117"></a>10. redis高并发问题</h2> 
<p><a href="https://blog.csdn.net/HappyLearnerL/article/details/128281152">redis高并发问题以及解决方案</a></p> 
<h2><a id="11__119"></a>11. 热点数据缓存重建问题</h2> 
<p>双重检测锁<br> 分布式锁（针对不同的key设置不同的锁）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f7ab22a650d47eb346ccf1a87dbfcee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pycharm输出中文乱码解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2332d9bcc74d79dffb3dd57274b84361/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">A&#43;B Problem C&#43;&#43;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>