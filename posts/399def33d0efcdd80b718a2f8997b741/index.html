<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用Trie数据结构实现搜索自动完成功能 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用Trie数据结构实现搜索自动完成功能" />
<meta property="og:description" content="本文旨在讨论使用 Java 的搜索自动完成的低级实现，将Trie在用例中使用数据结构。
这是一个示例TrieNode类：
class TrieNode{
Map&lt;Character,TrieNode&gt; children;
boolean isEndOfWord;
TrieNode(){
children = new HashMap&lt;&gt;();
isEndOfWord = false;
}
}
请注意，我们在这里使用 Map 来存储 Trie 中特定层级的所有字符。
如果问题是按字母顺序返回结果，那么我们别无选择，只能使用 TreeMap，能确保顺序，但会在插入和搜索时耗费时间，因为 TreeMap 查找/插入将耗费 log(n) 时间。
在本文中，我们假设可以按任意顺序返回结果，以使事情变得简单。
另外，假设我们有来自后台的缓存响应。我们可以将其作为自动完成任务的单词来源。让这个输入是单词，假设我们正在搜索一个单词 searchWord 。因此，方法定义可归结为以下内容：
public List suggestedWords(String[] words, String searchWord) { for (String word: words) { insert(word); // insert to Trie } return search(searchWord); // search in Trie and return results } 方法 insert(String word) 可以在 Trie 中插入单词。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/399def33d0efcdd80b718a2f8997b741/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T06:28:30+08:00" />
<meta property="article:modified_time" content="2024-01-09T06:28:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用Trie数据结构实现搜索自动完成功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文旨在讨论使用 <a href="https://www.jdon.com/tag-395/" rel="nofollow"><strong>Java</strong></a> 的搜索自动完成的低级实现，将Trie在用例中使用<a href="https://www.jdon.com/tag-49580/" rel="nofollow"><strong>数据</strong></a>结构。</p> 
<p>这是一个示例TrieNode类：</p> 
<p><strong>class</strong> TrieNode{<!-- --><br> Map&lt;Character,TrieNode&gt; children;<br> <strong>boolean</strong> isEndOfWord;</p> 
<p>    TrieNode(){<!-- --><br> children = <strong>new</strong> HashMap&lt;&gt;();<br> isEndOfWord = false;<br> }<br> }</p> 
<p>请注意，我们在这里使用 Map 来存储 Trie 中特定层级的所有字符。<br> 如果问题是按字母顺序返回结果，那么我们别无选择，只能使用 TreeMap，能确保顺序，但会在插入和搜索时耗费时间，因为 TreeMap 查找/插入将耗费 log(n) 时间。</p> 
<p>在本文中，我们假设可以按任意顺序返回结果，以使事情变得简单。</p> 
<p>另外，假设我们有来自后台的<a href="https://www.jdon.com/cache.html" rel="nofollow"><strong>缓存</strong></a>响应。我们可以将其作为自动完成任务的单词来源。让这个输入是单词，假设我们正在搜索一个单词 searchWord 。因此，方法定义可归结为以下内容：</p> 
<p><strong>public</strong> List 
 
   suggestedWords(String[] words, 
  <br> String searchWord) { 
  <br> 
  <strong>for</strong> (String word: words) { 
  <br> insert(word); 
  <em>// insert to Trie</em> } 
  <br> 
  <strong>return</strong> search(searchWord); 
  <em>// search in Trie and return results</em> 
  <br> } 
 </p> 
<p>方法 insert(String word) 可以在 Trie 中插入单词。<br> 以下是该方法的示例实现。<br> 请注意，我们需要将最后一个 TrieNode 的 isEndOfWord 标志设置为 true，表示单词的最后一个字符。</p> 
<p><strong>private</strong> <strong>void</strong> insert(String word) {<!-- --><br> <strong>int</strong> len = word.length();<br> TrieNode current = <strong>this</strong>.root; <em>// member variable pointing to the root of TrieNode</em> <strong>for</strong> (<strong>int</strong> i = 0; i &lt; len; i++) {<!-- --><br> TrieNode node = current.children.get(word.charAt(i));<br> <strong>if</strong> (node == <strong>null</strong>) {<!-- --><br> node = <strong>new</strong> TrieNode();<br> current.children.put(word.charAt(i), node);<br> }<br> current = node;<br> }<br> current.isEndOfWord = <strong>true</strong>;<br> }</p> 
<p>Trie 可以预先填充，也可以在应用服务器中设置。</p> 
<p>因此，实时查询只需直接调用 search(searchWord)。在插入一堆单词后，它看起来就像下面这样（例如：apple, ape, god, good）：<br> <img src="https://images2.imgbox.com/59/99/GyGNZSZ0_o.png" alt=""></p> 
<p><strong>现在到了主要部分，即搜索自动完成。</strong><br> 首先，我们需要实现前缀搜索。<br> 我们应该能够在 Trie 中搜索前缀。如果找到匹配，我们就需要搜索该特定 TrieNode 中的完整单词。实时应用将返回 k 个结果，而不是所有单词。<br> 为了实现实时<a href="https://www.jdon.com/tag-300/" rel="nofollow"><strong>性能</strong></a>，返回 k 个单词是合理的。以下是前缀搜索的实现：</p> 
<p><strong>private</strong> TrieNode startsWith(String prefix) {<!-- --><br> <strong>int</strong> len = prefix.length();<br> TrieNode current = <strong>this</strong>.root;</p> 
<p>  <strong>for</strong> (<strong>int</strong> i = 0; i &lt; len; i++) {<!-- --><br> TrieNode node = current.children.get(prefix.charAt(i));<br> <strong>if</strong> (node == <strong>null</strong>) {<!-- --><br> <strong>return</strong> <strong>null</strong>;<br> }<br> current = node;<br> }<br> <strong>return</strong> current;<br> }</p> 
<p>如果在 Trie 中没有找到前缀，我们将返回 null，否则我们将返回 TrieNode 作为主要搜索的起点。在最坏的情况下，前缀搜索只需要 O(n) 时间。下面，让我用迄今为止定义的所有方法重写搜索函数：</p> 
<p><strong>private</strong> List 
 
   search(String searchWord) { 
  <br> List 
  
    result = 
   <strong>new</strong> ArrayList &lt;&gt; (); 
   <br> TrieNode current = 
   <strong>this</strong>.root; 
   <br> 
   <strong>int</strong> len = searchWord.length(); 
   
 </p> 
<p>  current = startsWith(searchWord);<br> <strong>if</strong> (current != <strong>null</strong>) {<!-- --><br> List 
 
   list = 
  <strong>new</strong> ArrayList &lt;&gt; (); 
  <br> StringBuilder sb = 
  <strong>new</strong> StringBuilder(searchWord); 
  <br> 
  <em>// backtrack(list, current, sb, k); yet to implement.</em> result.addAll(list); 
  <br> } 
  <br> 
  <strong>return</strong> result; 
  <br> } 
 </p> 
<p>请注意，searchWord 可能是一个完整的词，也可能不是。但这并不重要，我们会返回 searchWord 的所有完整单词。我已经对上述代码进行了注释，这些代码还有待讨论/实现。我们可以使用回溯法从前缀 TrieNode 开始遍历所有后续 TrieNode，直到找到一个完整的单词。请参考下面的实现：</p> 
<p><strong>private</strong> <strong>void</strong> backtrack(List 
 
   list, 
  <br> TrieNode current, 
  <br> StringBuilder sb, 
  <br> 
  <strong>int</strong> k) { 
  <br> 
  <strong>if</strong> (list.size() == k) { 
  <br> 
  <strong>return</strong>; 
  <br> } 
  <br> 
  <strong>if</strong> (current.isEndOfWord) { 
  <br> list.add(sb.toString()); 
  <br> } 
  <br> 
  <strong>for</strong> (Map.Entry&lt;Character,TrieNode&gt; entry: current.children.entrySet()) { 
  <br> sb.append(entry.getKey()); 
  <br> backtrack(list, entry.getValue(), sb); 
  <br> sb.setLength(sb.length() - 1); 
  <br> } 
  <br> } 
 </p> 
<p>当最多收集到 k 个单词时，我们就停止回溯 Trie。最重要的是，我们会借助 isEndOfWord 标志来收集单词。StringBuilder 的使用在此不言自明。一旦完成回溯，结果将包含所有完整的单词。现在，如果我们需要返回短语列表而不是单词列表，也可以采用同样的解决方案。这里的单词是短语的同义词，所以并不重要。</p> 
<p>您可以在实际的编码<a href="https://www.jdon.com/tag-20618/" rel="nofollow"><strong>面试</strong></a>中快速完成编码，改进的空间是无限的！编码快乐</p> 
<p><a href="https://www.jdon.com/71720.html" rel="nofollow">https://www.jdon.com/71720.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b950fbe844d186e8fdbfc2e148b0eb6b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">rockscache：保证与DB最终或强一致性的Redis缓</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e83799607ae491250237d07c2782a2b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Electron】 Vite项目 初始配置 scss</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>