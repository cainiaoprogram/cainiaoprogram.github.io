<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GPT的前世今生：从gpt1到chatgpt的能力提升 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GPT的前世今生：从gpt1到chatgpt的能力提升" />
<meta property="og:description" content="从2017年google brain提出transformer模型，到2018年基于transformer模型open ai推出了gpt1模型以及google推出了bert模型，到2019-2021年open ai陆续推出gpt2和gpt3，再到2022-2023年推出chat-gpt和gpt4，大语言模型已经发展成了一个具有3个大分支的参天大树[LLM：大语言模型]。在这里主要写写关于gpt的那些事。
GPT发展路径 GPT-1到GPT-3到ChatGPT
各GPT的技术路线：
各GPT的模型大小：
模型发布时间参数量预训练数据量GPT2018 年 6 月1.17 亿约 5GBGPT-22019 年 2 月15 亿40GBGPT-32020 年 5 月1,750 亿45TB GPT-3.5 的进化树：
Note: 图中的几个概念：
1 Instruction tuning 有两个版本，一个是 supervised tuning，另一个是 reinforcement learning from human feedback (RLHF).
2 supervised instruction tuning 使用自然语言作为任务描述，而supervised fine tuning 使用固定格式或标签作为任务描述。supervised instruction tuning 的数据集包含指令、输入和输出三个部分，而supervised fine tuning 的数据集只包含输入和输出两个部分。 GPT-1、GPT-2和GPT-3模型 参考[GPT-1、GPT-2和GPT-3模型详解]
codex：code-davinci-002 [论文：Evaluating Large Language Models Trained on Code]
InstructGPT 参考[InstructionGPT]
[论文：Training language models to follow instructions with human feedback]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d46d9228c00b42b28dee0687c113f748/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-27T11:52:27+08:00" />
<meta property="article:modified_time" content="2023-10-27T11:52:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GPT的前世今生：从gpt1到chatgpt的能力提升</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        从2017年google brain提出transformer模型，到2018年基于transformer模型open ai推出了gpt1模型以及google推出了bert模型，到2019-2021年open ai陆续推出gpt2和gpt3，再到2022-2023年推出chat-gpt和gpt4，大语言模型已经发展成了一个具有3个大分支的参天大树[<a href="https://blog.csdn.net/pipisorry/article/details/131079470" title="LLM：大语言模型">LLM：大语言模型</a>]。在这里主要写写关于gpt的那些事。</p> 
<h2>GPT发展路径</h2> 
<p>GPT-1到GPT-3到ChatGPT</p> 
<p><img alt="" height="348" src="https://images2.imgbox.com/29/e1/8uDyCsXT_o.png" width="573"></p> 
<p>各GPT的技术路线：</p> 
<p><img alt="" height="309" src="https://images2.imgbox.com/69/7b/pEYXpten_o.png" width="570"></p> 
<p>各GPT的模型大小：</p> 
<table><tbody><tr><th style="width:87px;">模型</th><th style="width:110px;">发布时间</th><th style="width:98px;">参数量</th><th style="width:394px;">预训练数据量</th></tr><tr><td style="width:87px;">GPT</td><td style="width:110px;">2018 年 6 月</td><td style="width:98px;">1.17 亿</td><td style="width:394px;">约 5GB</td></tr><tr><td style="width:87px;">GPT-2</td><td style="width:110px;">2019 年 2 月</td><td style="width:98px;">15 亿</td><td style="width:394px;">40GB</td></tr><tr><td style="width:87px;">GPT-3</td><td style="width:110px;">2020 年 5 月</td><td style="width:98px;">1,750 亿</td><td style="width:394px;">45TB</td></tr></tbody></table> 
<p>GPT-3.5 的进化树：</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/0d/f2/cpCizdcK_o.png" width="493"></p> 
<p>Note: 图中的几个概念：</p> 
<p>1 Instruction tuning 有两个版本，一个是 supervised tuning，另一个是 reinforcement learning from human feedback (RLHF).</p> 
<p>2 supervised instruction tuning 使用自然语言作为任务描述，而supervised fine tuning 使用固定格式或标签作为任务描述。supervised instruction tuning 的数据集包含指令、输入和输出三个部分，而supervised fine tuning 的数据集只包含输入和输出两个部分。 </p> 
<h4></h4> 
<h3 id="articleContentId">GPT-1、GPT-2和GPT-3模型</h3> 
<p>参考[<a href="https://blog.csdn.net/pipisorry/article/details/108743639" title="GPT-1、GPT-2和GPT-3模型详解">GPT-1、GPT-2和GPT-3模型详解</a>]</p> 
<h3>codex：code-davinci-002</h3> 
<p>[论文：<a class="link-info" href="https://arxiv.org/pdf/2107.03374.pdf" rel="nofollow" title="Evaluating Large Language Models Trained on Code">Evaluating Large Language Models Trained on Code</a>]</p> 
<h3>InstructGPT</h3> 
<p>参考[<a href="https://youzipi.blog.csdn.net/article/details/134052380" rel="nofollow" title="InstructionGPT">InstructionGPT</a>]</p> 
<p>[论文：<a href="https://arxiv.org/pdf/2203.02155.pdf" rel="nofollow" title="Training language models to follow instructions with human feedback">Training language models to follow instructions with human feedback</a>]</p> 
<h3>ChatGPT</h3> 
<p>ChatGPT的博客中讲到ChatGPT和InstructGPT的训练方式相同，不同点仅仅是它们采集数据上有所不同，但是并没有更多的资料来讲数据采集上有哪些细节上的不同。</p> 
<p>考虑到ChatGPT仅仅被用在对话领域，猜测ChatGPT在数据采集上有两个不同：1. 提高了对话类任务的占比；2. 将提示的方式转换Q&amp;A的方式。</p> 
<h4>关于多轮对话</h4> 
<p>微调模型如 standard_alpaca，或者alpaca-lora，这些都是单轮的对话。对于多轮对话的模型，我们该怎么去组织数据呢？</p> 
<p>1  进行对话推理的时候，历史信息的处理和训练的时候是类似的，维护一个列表叫做history。操作起来的时候，就是将历史信息分别按照User和Assistant的角色拼起来，再镶嵌到模板里面，第一轮对话的时候，这个history是个空列表。[<a href="https://zhuanlan.zhihu.com/p/630914334" rel="nofollow" title="Chinese-Vicuna中的对话数据处理方式 - 知乎">Chinese-Vicuna中的对话数据处理方式 - 知乎</a>]</p> 
<p>2 ChatGPT也可以使用记忆网络（MemoryNetwork）等技术对对话历史进行编码和表示，然后使用生成模型或分类模型等方法进行回复生成。</p> 
<h3>GPT-4</h3> 
<p>        GPT-4（Generative Pre-trained Transformer 4）是 OpenAI 2023年发布的GPT 系列模型 [<a href="https://arxiv.org/pdf/2303.08774.pdf" rel="nofollow" title="GPT-4 Technical Report">GPT-4 Technical Report</a>]。它是一个大规模的多模态模型，可以接受图像和文本输入，产生文本输出。输出任务依旧是一个自回归的单词预测任务。</p> 
<p>GPT-4的主要改进和性能提升表现在以下几个方面：</p> 
<p>1 训练稳定性和预测性能<br> GPT-4 的开发经历了全面重建深度学习堆栈的过程，并与 Azure 共同设计了专门为其工作负载而优化的超级计算机。通过将 GPT-3.5 视为系统的首次“试运行”，OpenAI 发现并修复了一些错误，改进了理论基础。这使得 GPT-4 的训练运行非常稳定，并成为他们首个能够准确预测训练性能的大型模型。OpenAI 还计划持续专注于可靠的扩展，以进一步提高预测能力，为未来的应用做好准备。</p> 
<p>2 模型性能<br> GPT-4 在许多专业和学术基准测试中展现出了显著的性能提升。举例来说，GPT-4 在模拟律师资格考试中的成绩超过了90%的考生，而 GPT-3.5 仅在后10%范围内。这表明 GPT-4 在解决复杂问题、创造性写作等方面具备更高的可靠性和灵活性。</p> 
<p>3 多模态能力<br> 一个关键的改进是 GPT-4 的多模态能力，即接受图像和文本输入，能够结合图像和文本信息生成更丰富的输出，具有在图像理解、图像分类和问题回答等方面的能力。</p> 
<p>4 安全性和可控性<br> 通过引入对齐方案和加入额外的安全奖励信号，提高了模型的安全性能。此外，OpenAI 还邀请了多位专家对模型进行对抗测试，以发现并修复潜在的安全问题，减少了生成有害内容的风险。</p> 
<p>5 模型架构和训练方法<br> GPT-4 的架构与之前的 GPT 模型相似，采用了 Transformer 的结构。预训练阶段使用了公开可用的互联网数据和第三方提供的数据，并且在微调阶段应用了RLHF来微调。</p> 
<p>6 引入了可预测的拓展<br> GPT-4 引入了一个可预测扩展的深度学习栈，该栈能够在不同的规模下表现出可预测的行为。通过开发基础设施和优化方法，团队能够在小规模模型上进行实验，并准确地预测在大规模模型上的性能，提高了工作效率和模型性能。</p> 
<p>官网说明[<a href="https://openai.com/product/gpt-4" rel="nofollow" title="GPT-4">GPT-4</a>][<a href="https://openai.com/research/gpt-4" rel="nofollow" title="GPT-4">GPT-4</a>]</p> 
<h3>WebGPT</h3> 
<p>        WebGPT 论文发表于2021年12月，让 GPT 调用了搜索引擎。</p> 
<p>[<a href="https://openai.com/blog/webgpt/" rel="nofollow" title="WebGPT: Improving the factual accuracy of language models through web browsing">WebGPT: Improving the factual accuracy of language models through web browsing</a>]</p> 
<p></p> 
<p></p> 
<h2>ChatGPT能力溯源</h2> 
<p>ChatGPT 是怎么变得这么强的？它强大的涌现能力（Emergent Ability）到底从何而来？</p> 
<p>Note: 很多能力小模型没有，只有当模型大到一定的量级之后才会出现的能力称为Emergent Abilities。</p> 
<p>OpenAI有一个独特的先发优势，它在2020年就开放了GPT-3的接口，因此收集了大量的真实用户提问。可以预见，随着ChatGPT的商业化，OpenAI会逐步形成自己的数据生态循环。</p> 
<h3>初代 GPT-3（davinci）</h3> 
<p>初代 GPT-3（在 OpenAI API 中被称为davinci） [<a href="https://youzipi.blog.csdn.net/article/details/108743639#t16" rel="nofollow" title="GPT-3">GPT-3</a>]。一方面，它合理地回应了某些特定的查询，并在许多数据集中达到了还不错的性能；另一方面，它在许多任务上的表现还不如 T5 这样的小模型，它的能力与当今的标准也形成了尖锐的对比。虽然初代的 GPT-3 可能表面上看起来很弱，但后来的实验证明，初代 GPT-3 有着非常强的潜力。这些潜力后来被代码训练、指令微调 (instruction tuning) 和基于人类反馈的强化学习 (reinforcement learning with human feedback, RLHF) 解锁，最终展示出极为强大的涌现能力。</p> 
<h4>初代GPT-3三个重要能力</h4> 
<ul><li><strong>语言生成</strong>：遵循提示词（prompt），然后生成补全提示词的句子 (completion) 
  <ul><li>能力来自于语言建模的训练目标 (language modeling)。</li></ul></li><li><strong>世界知识 (world knowledge)</strong>：包括事实性知识 (factual knowledge) 和常识 (commonsense) 
  <ul><li>世界知识来自 3000 亿单词的训练语料库。模型的 1750 亿参数是为了存储知识，Liang et al. (2022) 的文章进一步证明了这一点。 他们的结论是，知识密集型任务的性能与模型大小息息相关。</li></ul></li><li><strong>上下文学习 (in-context learning)</strong>: 遵循给定任务的几个类似的示例，然后为新的测试用例生成解决方案。上下文学习才是 GPT-3的真正重点 
  <ul><li>能力来源及为什么上下文学习可以泛化仍然难以溯源。直觉上，这种能力可能来自于同一个任务的数据点在训练时按顺序排列在同一个 batch 中。然而，很少有人研究为什么语言模型预训练会促使上下文学习，以及为什么上下文学习的行为与fine-tuning)如此不同。 </li></ul></li></ul> 
<h3>Codex：code-davinci-002</h3> 
<p>初始的 Codex 是根据（可能是内部的，数据可能使用C4 的 2019-2021 版本）120 亿参数的 GPT-3 变体进行微调的，后来这个 120 亿参数的模型演变成 OpenAI API 中的code-cushman-001。</p> 
<p>在 2022 年 4 月至 7 月的，OpenAI 开始对code-davinci-002模型进行 Beta 测试，也称其为 Codex。Code-davinci-002 可能是第一个深度融合了代码训练和指令微调的模型。</p> 
<p>尽管 Codex 听着像是一个只管代码的模型，但code-davinci-002可能是最强大的针对自然语言的GPT-3.5 变体（优于 text-davinci-002和 -003）。</p> 
<h3>text-davinci-002</h3> 
<p>2022 年 5-6 月发布的text-davinci-002是一个基于code-davinci-002的有监督指令微调 (supervised instruction tuned) 模型，在以下数据上作了微调：（一）人工标注的指令和期待的输出；（二）由人工标注者选择的模型输出。</p> 
<p>在code-davinci-002上面进行指令微调很可能降低了模型的上下文学习能力，但是增强了模型的零样本能力。- 当有上下文示例 (in-context example) 的时候， Code-davinci-002 更擅长上下文学习；当没有上下文示例 / 零样本的时候， text-davinci-002 在零样本任务完成方面表现更好。从这个意义上说，text-davinci-002 更符合人类的期待（因为对一个任务写上下文示例可能会比较麻烦）。- OpenAI 不太可能故意牺牲了上下文学习的能力换取零样本能力 —— 上下文学习能力的降低更多是指令学习的一个副作用，OpenAI 管这叫对齐税。</p> 
<h3>第一版GPT3.5 模型的能力</h3> 
<p><code>code-davinci-002</code>和<code>text-davinci-002</code>，这两兄弟是第一版的 GPT3.5 模型，一个用于代码，另一个用于文本。它们表现出了四种与初代 GPT-3 不同的重要能力：</p> 
<ul><li><strong>响应人类指令</strong>：以前GPT-3 的输出主要是训练集中常见的句子。现在的模型会针对指令 / 提示词生成更合理的答案（而不是相关但无用的句子）。 
  <ul><li>能够响应人类指令的能力是指令微调的直接产物。</li></ul></li><li><strong>泛化到没有见过的任务</strong>： 这种能力对于上线部署至关重要，因为用户总会提新的问题，模型得答得出来才行。 
  <ul><li>当用于调整模型的指令数量超过一定的规模时，模型就可以自动在从没见过的新指令上也能生成有效的回答[T0、Flan 和 FlanPaLM 论文]。</li></ul></li><li><strong>代码生成和代码理解</strong>：这个能力很显然，因为模型用代码训练过。</li><li><strong>利用思维链 (chain-of-thought) 进行复杂推理</strong>：思维链推理之所以重要，是因为思维链可能是解锁涌现能力和超越缩放法则 (scaling laws) 的关键。[<a href="https://yaofu.notion.site/A-Closer-Look-at-Large-Language-Models-Emergent-Abilities-493876b55df5479d80686f68a1abd72f" rel="nofollow" title="A Closer Look at Large Language Models Emergent Abilities">A Closer Look at Large Language Models Emergent Abilities</a>] 
  <ul><li>使用思维链进行复杂推理的能力很可能是代码训练的一个神奇的副产物，且代码数据量足够大（例如PaLM 有 5% 的代码训练数据）。 
    <ul><li>- 初代 GPT-3 没有接受过代码训练，它不能做思维链（能力很弱甚至没有），而code-davinci-002 和 text-davinci-002 是两个拥有足够强的思维链推理能力的模型。</li><li>- text-davinci-001 模型虽然经过了指令微调，但思维链推理的能力非常弱，所以指令微调可能不是思维链存在的原因。区分代码训练和指令微调效果的最好方法可能是比较 code-cushman-001、T5 和 FlanT5。</li><li>- 面向过程的编程 (procedure-oriented programming) 跟人类逐步解决任务的过程很类似，面向对象编程 (object-oriented programming) 跟人类将复杂任务分解为多个简单任务的过程很类似。</li><li>- 没有非常确凿的证据证明代码就是思维链和复杂推理的原因。</li></ul></li><li>代码训练另一个可能的副产品是长距离依赖，正如Peter Liu所指出：“语言中的下个词语预测通常是非常局部的，而代码通常需要更长的依赖关系来做一些事情，比如前后括号的匹配或引用远处的函数定义”。这里我想进一步补充的是：由于面向对象编程中的类继承，代码也可能有助于模型建立编码层次结构的能力。</li></ul></li></ul> 
<h3>text-davinci-003</h3> 
<p>text-davinci-003和 ChatGPT，它们都在 2022 年 11 月发布，是使用的基于人类反馈的强化学习的版本指令微调 模型的两种不同变体。</p> 
<p>text-davinci-003 恢复了（但仍然比code-davinci-002差）一些在text-davinci-002 中丢失的部分上下文学习能力（大概是因为它在微调的时候混入了语言建模） 并进一步改进了零样本能力（得益于RLHF）。</p> 
<h3>ChatGPT</h3> 
<p>ChatGPT 似乎牺牲了几乎所有的上下文学习的能力来换取建模对话历史的能力（即chatgpt不需要你给这个任务{对话}示例，我只在乎当前对话历史说过什么即可）。</p> 
<h3>关于指令微调</h3> 
<p>完成<code>code-davinci-002</code>时，所有的能力都已经存在了。很可能后续的指令微调，无论是通过有监督指令微调还是RLHF，都会做以下事情：</p> 
<ul><li>指令微调不会为模型注入新的能力 —— 作用是解锁 / 激发这些能力。这主要是因为指令微调的数据量77K比预训练数据量少几个数量级（基础的能力是通过预训练注入的）。其他指令微调论文如 Chung et al. (2022) Flan-PaLM 的指令微调仅为预训练计算的 0.4%。</li><li>指令微调将 GPT-3.5 的分化到不同的技能树。有些更擅长上下文学习，如<code>text-davinci-003</code>，有些更擅长对话，如<code>ChatGPT</code>。</li><li>指令微调通过牺牲性能换取与人类的对齐（alignment）。 OpenAI 的作者在他们的指令微调论文中称其为 “对齐税” (alignment tax)。许多论文都报道了<code>code-davinci-002</code>在基准测试中实现了最佳性能（但模型不一定符合人类期望），进行指令微调后模型可以生成更加符合人类期待的反馈（或者说模型与人类对齐），例如：零样本问答、生成安全和公正的对话回复、拒绝超出模型它知识范围的问题。</li></ul> 
<h3>关于RLHF</h3> 
<p>通过对比text-davinci-002和text-davinci-003/ChatGPT，可知大多数新模型的行为都是 RLHF 的产物。</p> 
<p>RLHF 的作用是触发 / 解锁涌现能力：</p> 
<ul><li><strong>翔实的回应：</strong> text-davinci-003 的生成通常比 text-davinci-002长。 ChatGPT 的回应则更加冗长，以至于用户必须明确要求“用一句话回答我”，才能得到更加简洁的回答。这是 RLHF 的直接产物。</li><li><strong>公正的回应</strong>：ChatGPT 通常对涉及多个实体利益的事件（例如政治事件）给出非常平衡的回答。这也是RLHF的产物。</li><li><strong>拒绝不当问题</strong>：这是内容过滤器和由 RLHF 触发的模型自身能力的结合，过滤器过滤掉一部分，然后模型再拒绝一部分。</li><li><strong>拒绝其知识范围之外的问题</strong>：例如，拒绝在2021 年 6 月之后发生的新事件（因为它没在这之后的数据上训练过）。这是 RLHF 最神奇的部分，因为它使模型能够隐式地区分哪些问题在其知识范围内，哪些问题不在其知识范围内。</li></ul> 
<h3>总结</h3> 
<ul><li>语言生成能力 + 基础世界知识 + 上下文学习都是来自于预训练（<code>davinci</code>）</li><li>存储大量知识的能力来自 1750 亿的参数量。</li><li>遵循指令和泛化到新任务的能力来自于扩大指令学习中指令的数量（<code>Davinci-instruct-beta</code>)</li><li>执行复杂推理的能力很可能来自于代码训练（<code>code-davinci-002</code>）</li><li>生成中立、客观的能力、安全和翔实的答案来自与人类的对齐。具体来说： 
  <ul><li>如果是监督学习版，得到的模型是<code>text-davinci-002</code></li><li>如果是强化学习版 (RLHF) ，得到的模型是<code>text-davinci-003</code></li><li>无论是有监督还是 RLHF ，模型在很多任务的性能都无法超过 code-davinci-002 ，这种因为对齐而造成性能衰退的现象叫做对齐税。</li></ul></li><li>对话能力也来自于 RLHF（<code>ChatGPT</code>），具体来说它牺牲了上下文学习的能力，来换取： 
  <ul><li>建模对话历史</li><li>增加对话信息量</li><li>拒绝模型知识范围之外的问题</li></ul></li></ul> 
<p>[<a href="https://yaofu.notion.site/GPT-3-5-360081d91ec245f29029d37b54573756" rel="nofollow" title="拆解追溯 GPT-3.5 各项能力的起源">拆解追溯 GPT-3.5 各项能力的起源</a>]</p> 
<p></p> 
<h2>GPT-3.5 目前不能做什么</h2> 
<p>GPT-3.5不具备的某些重要属性：</p> 
<ul><li><strong>实时改写模型的信念</strong>：当模型表达对某事的信念时，如果该信念是错误的，我们可能很难纠正它： 
  <ul><li>例子：ChatGPT 坚持认为 3599 是一个质数，尽管它承认 3599 = 59 * 61。</li><li>然而，模型信念的强度似乎存在不同的层次。一个例子是即使我告诉它达斯·维达（星球大战电影中的人物）赢得了2020年大选，模型依旧会认为美国现任总统是拜登。但是如果我将选举年份改为 2024 年，它就会认为总统是达斯·维达是 2026 年的总统。</li></ul></li><li><strong>形式推理</strong>：GPT-3.5系列不能在数学或一阶逻辑等形式严格的系统中进行推理。</li></ul> 
<p>from:<a href="https://youzipi.blog.csdn.net/" rel="nofollow" title="-柚子皮-">-柚子皮-</a></p> 
<p>ref: [<a class="link-info" href="https://beta.openai.com/docs/model-index-for-researchers" rel="nofollow" title="OpenAI的模型索引">OpenAI的模型索引</a>]</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ec5ad4c8139830cb0412c4a277b2572/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">InstructionGPT</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65373f65eab0349ccb8a908a208857a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Jetson Nano下安装opencv</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>