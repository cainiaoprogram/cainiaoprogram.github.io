<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>六、Spring MVC - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="六、Spring MVC" />
<meta property="og:description" content="目录
1. Spring MVC使用示例
2. 主要结构
3. RequestMappingHandlerMapping的实例化和初始化
3.1 RequestMappingHandlerMapping的实例化
3.2 RequestMappingHandlerMapping的初始化(web方法收集)
4. 拦截器
4.1 拦截器使用示例
4.2 拦截器的收集
5. RequestMappingHandlerAdapter
5.1 RequestMappingHandlerAdapter的实例化
5.2 RequestMappingHandlerAdapter的初始化
6. ExceptionHandlerExceptionResolver
6.1 ExceptionHandlerExceptionResolver的实例化
6.2 ExceptionHandlerExceptionResolver的初始化
7. Spring mvc容器中的bean注入
8. 请求的处理流程
8.1 getHandler获取请求路径对应的HandlerMethod和拦截器
8.2 getHandlerAdapter获取HandlerAdapter
8.3 mappedHandler.applyPreHandle正序调用拦截器前置处理方法
8.4 ha.handle调用请求路径对应的web方法
8.4.1 参数解析
8.4.2 反射调用web方法
8.4.3 返回值解析
8.5 mappedHandler.applyPostHandle倒序调用拦截器的中置处理方法
8.6 processDispatchResult
8.6.1 ControllerAdvice异常处理方法调用
8.6.2 倒序调用拦截器后置处理方法
(本篇中用到的演示项目地址：https://gitee.com/yejuan/spring-learning-no-xml 对应tag: spring-c6)
1. Spring MVC使用示例 我们通过类与方法上面的RequestMapping拼接出来的路径/user/showUser就可以调用到showUser方法，本篇将分析下是如何实现的。
@Controller @RequestMapping(&#34;/user&#34;) public class UserController { @Autowired IUserService userService; @ResponseBody @RequestMapping(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d20be0e3c289dfce3293f61c12a5197f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-02T22:22:06+08:00" />
<meta property="article:modified_time" content="2020-09-02T22:22:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">六、Spring MVC</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"> </p> 
<p id="1.%20Spring%20MVC%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-toc" style="margin-left:0px;"><a href="#1.%20Spring%20MVC%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B" rel="nofollow">1. Spring MVC使用示例</a></p> 
<p id="2.%20%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#2.%20%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84" rel="nofollow">2. 主要结构</a></p> 
<p id="3.%20RequestMappingHandlerMapping%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#3.%20RequestMappingHandlerMapping%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">3. RequestMappingHandlerMapping的实例化和初始化</a></p> 
<p id="3.1%20RequestMappingHandlerMapping%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#3.1%20RequestMappingHandlerMapping%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96" rel="nofollow">3.1 RequestMappingHandlerMapping的实例化</a></p> 
<p id="3.2%20RequestMappingHandlerMapping%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96(web%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86)-toc" style="margin-left:40px;"><a href="#3.2%20RequestMappingHandlerMapping%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%28web%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86%29" rel="nofollow">3.2 RequestMappingHandlerMapping的初始化(web方法收集)</a></p> 
<p id="4.%20%E6%8B%A6%E6%88%AA%E5%99%A8-toc" style="margin-left:0px;"><a href="#4.%20%E6%8B%A6%E6%88%AA%E5%99%A8" rel="nofollow">4. 拦截器</a></p> 
<p id="4.1%20%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#4.1%20%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B" rel="nofollow">4.1 拦截器使用示例</a></p> 
<p id="4.2%20%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%94%B6%E9%9B%86-toc" style="margin-left:40px;"><a href="#4.2%20%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%94%B6%E9%9B%86" rel="nofollow">4.2 拦截器的收集</a></p> 
<p id="5.%20RequestMappingHandlerAdapter-toc" style="margin-left:0px;"><a href="#5.%20RequestMappingHandlerAdapter" rel="nofollow">5. RequestMappingHandlerAdapter</a></p> 
<p id="5.1%20RequestMappingHandlerAdapter%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#5.1%20RequestMappingHandlerAdapter%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96" rel="nofollow">5.1 RequestMappingHandlerAdapter的实例化</a></p> 
<p id="5.2%20RequestMappingHandlerAdapter%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#5.2%20RequestMappingHandlerAdapter%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">5.2 RequestMappingHandlerAdapter的初始化</a></p> 
<p id="6.%20ExceptionHandlerExceptionResolver-toc" style="margin-left:0px;"><a href="#6.%20ExceptionHandlerExceptionResolver" rel="nofollow">6. ExceptionHandlerExceptionResolver</a></p> 
<p id="6.1%20ExceptionHandlerExceptionResolver%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#6.1%20ExceptionHandlerExceptionResolver%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96" rel="nofollow">6.1 ExceptionHandlerExceptionResolver的实例化</a></p> 
<p id="6.2%C2%A0%C2%A0%20%C2%A0ExceptionHandlerExceptionResolver%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#6.2%C2%A0%C2%A0%20%C2%A0ExceptionHandlerExceptionResolver%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">6.2    ExceptionHandlerExceptionResolver的初始化</a></p> 
<p id="7.%20Spring%20mvc%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84bean%E6%B3%A8%E5%85%A5-toc" style="margin-left:0px;"><a href="#7.%20Spring%20mvc%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84bean%E6%B3%A8%E5%85%A5" rel="nofollow">7. Spring mvc容器中的bean注入</a></p> 
<p id="8.%20%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px;"><a href="#8.%20%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B" rel="nofollow">8. 请求的处理流程</a></p> 
<p id="8.1%20getHandler%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E5%AF%B9%E5%BA%94%E7%9A%84HandlerMethod%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8-toc" style="margin-left:40px;"><a href="#8.1%20getHandler%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E5%AF%B9%E5%BA%94%E7%9A%84HandlerMethod%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8" rel="nofollow">8.1 getHandler获取请求路径对应的HandlerMethod和拦截器</a></p> 
<p id="8.2%20getHandlerAdapter%E8%8E%B7%E5%8F%96HandlerAdapter-toc" style="margin-left:40px;"><a href="#8.2%20getHandlerAdapter%E8%8E%B7%E5%8F%96HandlerAdapter" rel="nofollow">8.2 getHandlerAdapter获取HandlerAdapter</a></p> 
<p id="8.3%20mappedHandler.applyPreHandle%E6%AD%A3%E5%BA%8F%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#8.3%20mappedHandler.applyPreHandle%E6%AD%A3%E5%BA%8F%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95" rel="nofollow">8.3 mappedHandler.applyPreHandle正序调用拦截器前置处理方法</a></p> 
<p id="8.4%20ha.handle%E8%B0%83%E7%94%A8%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E5%AF%B9%E5%BA%94%E7%9A%84web%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#8.4%20ha.handle%E8%B0%83%E7%94%A8%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E5%AF%B9%E5%BA%94%E7%9A%84web%E6%96%B9%E6%B3%95" rel="nofollow">8.4 ha.handle调用请求路径对应的web方法</a></p> 
<p id="8.4.1%20%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90-toc" style="margin-left:80px;"><a href="#8.4.1%20%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90" rel="nofollow">8.4.1 参数解析</a></p> 
<p id="8.4.2%20%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8web%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#8.4.2%20%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8web%E6%96%B9%E6%B3%95" rel="nofollow">8.4.2 反射调用web方法</a></p> 
<p id="8.4.3%20%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90-toc" style="margin-left:80px;"><a href="#8.4.3%20%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90" rel="nofollow">8.4.3 返回值解析</a></p> 
<p id="8.5%20mappedHandler.applyPostHandle%E5%80%92%E5%BA%8F%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%B8%AD%E7%BD%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#8.5%20mappedHandler.applyPostHandle%E5%80%92%E5%BA%8F%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%B8%AD%E7%BD%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95" rel="nofollow">8.5 mappedHandler.applyPostHandle倒序调用拦截器的中置处理方法</a></p> 
<p id="8.6%20processDispatchResult-toc" style="margin-left:40px;"><a href="#8.6%20processDispatchResult" rel="nofollow">8.6 processDispatchResult</a></p> 
<p id="8.6.1%20ControllerAdvice%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#8.6.1%20ControllerAdvice%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" rel="nofollow">8.6.1 ControllerAdvice异常处理方法调用</a></p> 
<p id="8.6.2%20%E5%80%92%E5%BA%8F%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#8.6.2%20%E5%80%92%E5%BA%8F%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95" rel="nofollow">8.6.2 倒序调用拦截器后置处理方法</a></p> 
<hr id="hr-toc"> 
<p>(本篇中用到的演示项目地址：https://gitee.com/yejuan/spring-learning-no-xml 对应tag: spring-c6)</p> 
<h2 id="1.%20Spring%20MVC%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">1. Spring MVC使用示例</h2> 
<p style="margin-left:0cm;">我们通过类与方法上面的RequestMapping拼接出来的路径/user/showUser就可以调用到showUser方法，本篇将分析下是如何实现的。</p> 
<pre><code>@Controller
@RequestMapping("/user")
public class UserController {

    @Autowired
    IUserService userService;
    @ResponseBody
    @RequestMapping("/showUser")
    public String showUser(){
        LogUtil.getLogger().info("invoke showUser");
        User user = new User();
        user.setName("ZhangSan");
        user.setAge(18);

        return userService.showUser(user);
    }

}
</code></pre> 
<h2 id="2.%20%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84">2. 主要结构</h2> 
<p><img alt="" height="864" src="https://images2.imgbox.com/b2/82/a0CGHbCW_o.png" width="1200"></p> 
<p>DispatcherServlet中有三个重要的容器handlerMappings、handlerAdapters、handlerExceptionResolvers三个容器中RequestMappingHandlerMapping、RequestMappingHandlerAdapter、ExceptionHandlerExceptionResolver三个实例对web请求的处理尤为重要：</p> 
<ol><li><strong><span style="color:#000000;">RequestMappingHandlerMapping</span></strong><span style="color:#000000;">:</span>DispatcherServlet是我们配置的用来接收所有请求的Servlet, Servlet接收到用户请求后根据请求路径在<span style="color:#000000;">RequestMappingHandlerMapping</span> 中mappingRegistry的urlLookup匹配到RequestMappingInfo，再在mappingRegistry的mappingLookup中根据RequestMappingInfo找到对应的HandlerMethod，这样就找到了请求路径对应的具体方法，再进行反射调用就可以处理请求了；</li><li><strong>RequestMappingHandlerAdapter</strong>：通过RequestMappingHandlerAdapter的参数解析器和返回值解析器完成请求的参数解析和返回值解析；</li><li><strong>ExceptionHandlerExceptionResolver</strong>：可通过ControllerAdvice注解自定义Controller调用发生异常后的增强，ControllerAdvice类型bean的收集和调用通过ExceptionHandlerExceptionResolver支持。</li></ol> 
<h2 id="3.%20RequestMappingHandlerMapping%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96" style="margin-left:0cm;">3. RequestMappingHandlerMapping的实例化和初始化</h2> 
<p>AbstractApplicationContext#refresh方法中的finishRefresh()（调用发生在spring容器bean实例化之后）会通过Listener监听机制调用到DispatcherServlet#onRefresh方法进行初始化。<br> org.springframework.web.servlet.DispatcherServlet#onRefresh</p> 
<p><img alt="" height="576" src="https://images2.imgbox.com/76/97/HwqZMY5e_o.png" width="877"></p> 
<h3 id="3.1%20RequestMappingHandlerMapping%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96" style="margin-left:0cm;">3.1 RequestMappingHandlerMapping的实例化</h3> 
<p style="margin-left:0cm;">默认会读取DispatcherServlet.properties中的配置的key为org.springframework.web.servlet.HandlerMapping对应的value，value为HandlerMapping接口实现类的全限定名,创建相应的beanDefinition再通过Spring那套实例化、初始化流程拿到对应的实例。</p> 
<p style="margin-left:0cm;"><img alt="" height="620" src="https://images2.imgbox.com/c2/bb/dtek7dx6_o.png" width="942"></p> 
<p style="margin-left:0cm;">默认读取DispatcherServlet.properties配置文件</p> 
<p style="margin-left:0cm;"><img alt="" height="459" src="https://images2.imgbox.com/df/ca/hbAHJjNX_o.png" width="1051"></p> 
<p style="margin-left:0cm;"><img alt="" height="571" src="https://images2.imgbox.com/01/58/7khpMT8T_o.png" width="1069"></p> 
<p style="margin-left:0cm;">拿到实现类后，封装生成beanDefinition调用spring那套进行实例化、初始化</p> 
<p style="margin-left:0cm;">org.springframework.web.servlet.DispatcherServlet#getDefaultStrategies</p> 
<p style="margin-left:0cm;"><img alt="" height="525" src="https://images2.imgbox.com/dd/76/Da73eMmo_o.png" width="1001"></p> 
<p style="margin-left:0cm;"><img alt="" height="419" src="https://images2.imgbox.com/6b/4f/EdcPqfUB_o.png" width="1008"></p> 
<h3 id="3.2%20RequestMappingHandlerMapping%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96(web%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86)" style="margin-left:0cm;">3.2 RequestMappingHandlerMapping的初始化(web方法收集)</h3> 
<p>RequestMappingHandlerMapping实现了InitializingBean接口在初始化过程中会调用到afterPropertiesSet方法进行web方法（web请求路径对应的方法）的收集。org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#afterPropertiesSet</p> 
<p><img alt="" height="516" src="https://images2.imgbox.com/03/e0/8EXWVaZZ_o.png" width="1020"></p> 
<p>过滤类上有 Controller、RequestMapping注解的类</p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/03/b7/it63ngV1_o.png" width="1017"></p> 
<p><img alt="" height="340" src="https://images2.imgbox.com/3a/f2/eLOLKBxW_o.png" width="961"></p> 
<p>遍历方法如果方法上有RequestMapping注解则该方法为web方法结合类上的RequestMapping注解信息包装生成RequestMappingInfo对象， RequestMappingInfo对象中有web方法对应的请求路径与方法，建立web方法方法与RequestMappingInfo映射关系缓存到容器。org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#detectHandlerMethods</p> 
<p><img alt="" height="586" src="https://images2.imgbox.com/66/07/IAczeW2W_o.png" width="1082"></p> 
<p><img alt="" height="574" src="https://images2.imgbox.com/c1/b9/y7S5fNwT_o.png" width="1041"></p> 
<p><img alt="" height="555" src="https://images2.imgbox.com/0a/32/48asNMOI_o.png" width="1160"></p> 
<ol><li>将RequestMappingInfo与HandlerMethod的映射关系加入mappingRegistry的mappingLookup容器,HandlerMethod包装有web方法对应的method、beanName、beanFactory方便反射调用;</li><li>将请求路径字符串与RequestMappingInfo的映射关系加入mappingRegistry的urlLookup容器</li></ol> 
<p style="margin-left:0cm;">org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#detectHandlerMethods</p> 
<p style="margin-left:0cm;"><img alt="" height="566" src="https://images2.imgbox.com/e5/e6/dz7k9Evv_o.png" width="1086"></p> 
<p style="margin-left:0cm;">org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.MappingRegistry#register</p> 
<p style="margin-left:0cm;"><img alt="" height="614" src="https://images2.imgbox.com/55/b3/Xw9UUwNq_o.png" width="1090"></p> 
<p style="margin-left:0cm;">到这里我们就完成了web方法的收集和缓存，为处理web请求做好准备。</p> 
<h2 id="4.%20%E6%8B%A6%E6%88%AA%E5%99%A8" style="margin-left:0cm;">4. 拦截器</h2> 
<h3 id="4.1%20%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B" style="margin-left:0cm;">4.1 拦截器使用示例</h3> 
<p>实现HandlerInterceptor接口定义自己的拦截器</p> 
<pre><code>public class MyHandlerInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("-------MyHandlerInterceptor   preHandle ------------");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("-------MyHandlerInterceptor   postHandle ------------");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("-------MyHandlerInterceptor   afterCompletion ------------");
    }
}
</code></pre> 
<p>配置拦截器，配置拦截器的拦截路径，通过@Bean将拦截器加入Spring容器</p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/25/c4/Yi1KEsqL_o.png" width="1000"></p> 
<h3 id="4.2%20%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%94%B6%E9%9B%86" style="margin-left:0cm;">4.2 拦截器的收集</h3> 
<p>由2中的结构图可知RequestMappingHandlerMapping的adaptedInterceptors容器中缓存了所有的拦截器，下面我们来分析整理下拦截器的收集过程。spring在初始化RequestMappingHandlerMapping时会调用到RequestMappingHandlerMapping的initApplicationContext进行拦截器的收集。<br> org.springframework.web.servlet.handler.AbstractHandlerMapping#initApplicationContext</p> 
<p><img alt="" height="459" src="https://images2.imgbox.com/9a/30/zguZttcO_o.png" width="1052"></p> 
<p><img alt="" height="431" src="https://images2.imgbox.com/97/33/9nw0wuK7_o.png" width="1187"></p> 
<h2 id="5.%20RequestMappingHandlerAdapter">5. RequestMappingHandlerAdapter</h2> 
<p style="margin-left:0cm;">RequestMappingHandlerAdapter主要是完成了web方法调用的参数解析和返回值解析</p> 
<h3 id="5.1%20RequestMappingHandlerAdapter%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96" style="margin-left:0cm;">5.1 RequestMappingHandlerAdapter的实例化</h3> 
<p style="margin-left:0cm;">同HandlerMapping的实例化一样，RequestMappingHandlerAdapter的实例化也是在AbstractApplicationContext#refresh方法中的finishRefresh()调用到的DispatcherServlet#onRefresh方法中进行的</p> 
<p style="margin-left:0cm;">org.springframework.web.servlet.DispatcherServlet#onRefresh</p> 
<p style="margin-left:0cm;"><img alt="" height="576" src="https://images2.imgbox.com/c7/3c/CribTpcQ_o.png" width="961"></p> 
<p style="margin-left:0cm;">默认读取DispatcherServlet.properties中的key为org.springframework.web.servlet.HandlerAdapter的配置进行实例化、初始化。</p> 
<p><img alt="" height="422" src="https://images2.imgbox.com/e6/44/6nlVLHxg_o.png" width="1032"></p> 
<p>org.springframework.web.servlet.DispatcherServlet#getDefaultStrategies</p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/5e/a7/Jbt7EOpb_o.png" width="1064"></p> 
<h3 id="5.2%20RequestMappingHandlerAdapter%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" style="margin-left:0cm;">5.2 RequestMappingHandlerAdapter的初始化</h3> 
<p style="margin-left:0cm;">RequestMappingHandlerAdapter实现了InitializingBean接口在初始化过程中会调用到<span style="color:#000000;">afterPropertiesSet</span><span style="color:#000000;">方法，</span><span style="color:#000000;">afterPropertiesSet</span><span style="color:#000000;">方法中完成了参数解析器与返回值解析器的创建和添加。</span></p> 
<p style="margin-left:0cm;">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#afterPropertiesSet</p> 
<p style="margin-left:0cm;"><img alt="" height="586" src="https://images2.imgbox.com/f4/e2/8qonQKhQ_o.png" width="1138"></p> 
<p style="margin-left:0cm;">参数解析器的创建</p> 
<p style="margin-left:0cm;"><img alt="" height="616" src="https://images2.imgbox.com/89/d3/jmNLV3QL_o.png" width="1016"></p> 
<p style="margin-left:0cm;">返回值解析器的创建</p> 
<p style="margin-left:0cm;"><img alt="" height="573" src="https://images2.imgbox.com/7b/b2/Y1tvyFnD_o.png" width="998"></p> 
<h2 id="6.%20ExceptionHandlerExceptionResolver">6. ExceptionHandlerExceptionResolver</h2> 
<h3 id="6.1%20ExceptionHandlerExceptionResolver%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96">6.1 ExceptionHandlerExceptionResolver的实例化</h3> 
<p>ExceptionHandlerExceptionResolver的实例化也是通过DispatcherServlet#onRefresh方法完成的，默认的HandlerExceptionResolver同样的配置在DispatcherServlet.properties文件中。</p> 
<p><img alt="" height="609" src="https://images2.imgbox.com/e1/51/HZ64gW97_o.png" width="872"></p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/fb/a7/0BwLJM6y_o.png" width="1066"></p> 
<h3 id="6.2%C2%A0%C2%A0%20%C2%A0ExceptionHandlerExceptionResolver%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">6.2    ExceptionHandlerExceptionResolver的初始化</h3> 
<p>ExceptionHandlerExceptionResolver的初始化方法afterPropertiesSet完成了有ControllerAdvice注解bean的收集、解析，以及ControllerAdvice类型bean的参数解析器、返回值解析器的创建和设置。</p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/2e/5d/wqD4RCqk_o.png" width="1113"></p> 
<p style="margin-left:0cm;">一个ControllerAdviceBean对应一个ExceptionHandlerMethodResolver对象,ControllerAdviceBean与ExceptionHandlerMethodResolver的映射关系缓存在exceptionHandlerAdviceCache容器中，ExceptionHandlerMethodResolver中的mappedMethods容器缓存了异常类型与异常处理方法的映射关系。</p> 
<p style="margin-left:0cm;">org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#initExceptionHandlerAdviceCache</p> 
<p style="margin-left:0cm;"><img alt="" height="622" src="https://images2.imgbox.com/09/73/KAPtJzOH_o.png" width="1128"></p> 
<p style="margin-left:0cm;"><img alt="" height="511" src="https://images2.imgbox.com/b2/1a/8gdLQt5X_o.png" width="1110"></p> 
<h2 id="7.%20Spring%20mvc%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84bean%E6%B3%A8%E5%85%A5" style="margin-left:0cm;">7. Spring mvc容器中的bean注入</h2> 
<p style="margin-left:0cm;">在spring源码分析的第二篇中我们分析了spring web项目中有两个容器一个专门装载Controller类型的bean为了区分我们把它称为Spring mvc容器，另一个Spring mvc的parent 容器即root 容器，专门缓存Controller之外的其他bean。Controller bean与其他类型的bean不在同一个容器，Controller中的依赖注入是如何完成的呢，我们来分析下。</p> 
<p style="margin-left:0cm;">         前面讲过AutowiredAnnotationBeanPostProcessor#postProcessProperties会对bean中有@Autowired的属性调用getBean获取实例，进行属性的注入。getBean获取实例时如果父容器不为空并且当前容器（子容器）中没有相关的bean，调用父容器doGetBean获取相关实例。</p> 
<p style="margin-left:0cm;">org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</p> 
<p style="margin-left:0cm;"><img alt="" height="630" src="https://images2.imgbox.com/0d/93/wxyr1LJi_o.png" width="1019"></p> 
<h2 id="8.%20%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B" style="margin-left:0cm;">8. 请求的处理流程</h2> 
<p><img alt="" height="629" src="https://images2.imgbox.com/58/63/HAE9XHmm_o.png" width="1116"></p> 
<h3 id="8.1%20getHandler%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E5%AF%B9%E5%BA%94%E7%9A%84HandlerMethod%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8" style="margin-left:0cm;">8.1 getHandler获取请求路径对应的HandlerMethod和拦截器</h3> 
<p style="margin-left:0cm;">根据请求路径从urlLookup拿到RequestMappingInfo，根据RequestMappingInfo从mappingLookup拿到HandlerMethod，从List&lt;HandlerInterceptor&gt; adaptedInterceptors容器中过滤筛选与请求路径匹配的拦截器，包装拦截器与HandlerMethod得到HandlerExecutionChain</p> 
<p style="margin-left:0cm;">org.springframework.web.servlet.DispatcherServlet#getHandler</p> 
<p style="margin-left:0cm;"><img alt="" height="632" src="https://images2.imgbox.com/ec/f7/UufdO4Cb_o.png" width="1158"></p> 
<p style="margin-left:0cm;"><img alt="" height="491" src="https://images2.imgbox.com/e3/90/drZhunz3_o.png" width="1200"></p> 
<p style="margin-left:0cm;"><img alt="" height="604" src="https://images2.imgbox.com/98/4e/x29yTz5E_o.png" width="968"></p> 
<h3 id="8.2%20getHandlerAdapter%E8%8E%B7%E5%8F%96HandlerAdapter" style="margin-left:0cm;">8.2 getHandlerAdapter获取HandlerAdapter</h3> 
<p style="margin-left:0cm;">应用策略模式根据HandlerMethod获取到匹配的HandlerAdapter为RequestMappingHandlerAdapter</p> 
<p style="margin-left:0cm;">org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter</p> 
<p style="margin-left:0cm;"><img alt="" height="442" src="https://images2.imgbox.com/4f/ec/DiZS83iL_o.png" width="1037"></p> 
<h3 id="8.3%20mappedHandler.applyPreHandle%E6%AD%A3%E5%BA%8F%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95" style="margin-left:0cm;">8.3 mappedHandler.applyPreHandle正序调用拦截器前置处理方法</h3> 
<p style="margin-left:0cm;">正序调用拦截器的前置处理，如果请求被拦截，直接倒序调用拦截器的后置处理方法后返回</p> 
<p style="margin-left:0cm;"><img alt="" height="433" src="https://images2.imgbox.com/9f/db/extnBD9F_o.png" width="1051"></p> 
<p style="margin-left:0cm;"><img alt="" height="508" src="https://images2.imgbox.com/1a/b1/2P3OcCE8_o.png" width="1083"></p> 
<h3 id="8.4%20ha.handle%E8%B0%83%E7%94%A8%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E5%AF%B9%E5%BA%94%E7%9A%84web%E6%96%B9%E6%B3%95" style="margin-left:0cm;">8.4 ha.handle调用请求路径对应的web方法</h3> 
<p style="margin-left:0cm;">不同的参数和返回值对应的解析器和消息转换器不同，但整个流程框架大致一样的，我们以下面的代码为例分析web方法的执行过程</p> 
<pre><code>@Controller
@RequestMapping("/account")
public class AccountController {

    @Autowired
    AccountService accountService2;

    @ResponseBody
    @RequestMapping("/show")
    public String showUser(@RequestBody String requestBody){
        LogUtil.getLogger().info("requestBody :{}", requestBody);
        return "AccountController show";
    }
}
</code></pre> 
<p>整体流程如下</p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/6f/7f/MwK3leeN_o.png" width="300"></p> 
<h4 id="8.4.1%20%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90" style="margin-left:0cm;">8.4.1 参数解析</h4> 
<p style="margin-left:0cm;">解析web方法的参数，策略模式通过supportsParameter方法找到能解析参数的解析器，如RequestResponseBodyMethodProcessor#supportsParameter 匹配有RequestBody注解的参数，我们的示例代码匹配的解析器为RequestResponseBodyMethodProcessor。</p> 
<p style="margin-left:0cm;">org.springframework.web.method.support.InvocableHandlerMethod#getMethodArgumentValues</p> 
<p style="margin-left:0cm;"><img alt="" height="644" src="https://images2.imgbox.com/9d/0e/D1iUocM5_o.png" width="1158"></p> 
<p style="margin-left:0cm;">org.springframework.web.method.support.HandlerMethodArgumentResolverComposite#getArgumentResolver</p> 
<p style="margin-left:0cm;"><img alt="" height="529" src="https://images2.imgbox.com/91/23/llSQ6CK1_o.png" width="1027"></p> 
<p style="margin-left:0cm;"><img alt="" height="357" src="https://images2.imgbox.com/bf/a7/Xh2HdCSJ_o.png" width="989"></p> 
<p style="margin-left:0cm;">解析参数，根据参数类型和请求的contentType找到匹配的消息解析器，从请求的输入流中读取内容进行解析</p> 
<p style="margin-left:0cm;">org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor#resolveArgument</p> 
<p style="margin-left:0cm;"><img alt="" height="607" src="https://images2.imgbox.com/c5/71/UBSCN3Wf_o.png" width="1082"></p> 
<p style="margin-left:0cm;">AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters(org.springframework.http.HttpInputMessage, org.springframework.core.MethodParameter, java.lang.reflect.Type)</p> 
<p style="margin-left:0cm;"><img alt="" height="636" src="https://images2.imgbox.com/18/d8/8jsmYLgP_o.png" width="1181"></p> 
<h4 id="8.4.2%20%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8web%E6%96%B9%E6%B3%95" style="margin-left:0cm;">8.4.2 反射调用web方法</h4> 
<p style="margin-left:0cm;">org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest</p> 
<p style="margin-left:0cm;"><img alt="" height="478" src="https://images2.imgbox.com/2d/8f/oOvNJdIS_o.png" width="1155"></p> 
<p style="margin-left:0cm;"><img alt="" height="470" src="https://images2.imgbox.com/ac/50/8aYeyH6k_o.png" width="950"></p> 
<h4 id="8.4.3%20%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90" style="margin-left:0cm;">8.4.3 返回值解析</h4> 
<p style="margin-left:0cm;">返回值的解析与参数解析的流程相似，同样通过策略模式找到返回值匹配的解析器，再从解析器中找到消息转换器，解析返回值将返回值写入请求对应的输出流</p> 
<p style="margin-left:0cm;">org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle</p> 
<p style="margin-left:0cm;"><img alt="" height="561" src="https://images2.imgbox.com/df/d9/99vAb0sq_o.png" width="1109"></p> 
<p style="margin-left:0cm;">匹配返回值解析器</p> 
<p style="margin-left:0cm;"><img alt="" height="530" src="https://images2.imgbox.com/d6/24/cSdM6eUy_o.png" width="1129"></p> 
<p style="margin-left:0cm;"><img alt="" height="414" src="https://images2.imgbox.com/b9/cd/2ZemZ6sa_o.png" width="1108"></p> 
<p>获取返回值匹配的解析器，如RequestResponseBodyMethodProcessor匹配类或方法上有ResponseBody注解的返回值org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor#supportsReturnType</p> 
<p> </p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/7a/63/mNx0I7cL_o.png" width="1200"></p> 
<p style="margin-left:0cm;">解析返回值，根据返回值类型找到匹配的消息转换器，示例代码将匹配到StringHttpMessageConverter消息转换器，将返回值写入请求的输出流</p> 
<p style="margin-left:0cm;">org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#handleReturnValue</p> 
<p style="margin-left:0cm;"><img alt="" height="452" src="https://images2.imgbox.com/32/23/1SgfBXqH_o.png" width="1180"></p> 
<p style="margin-left:0cm;">AbstractMessageConverterMethodProcessor#writeWithMessageConverters(T, org.springframework.core.MethodParameter, org.springframework.http.server.ServletServerHttpRequest, org.springframework.http.server.ServletServerHttpResponse)</p> 
<p style="margin-left:0cm;"><img alt="" height="650" src="https://images2.imgbox.com/40/e5/G3f2EoD1_o.png" width="1100"></p> 
<h3 id="8.5%20mappedHandler.applyPostHandle%E5%80%92%E5%BA%8F%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%B8%AD%E7%BD%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95" style="margin-left:0cm;">8.5 mappedHandler.applyPostHandle倒序调用拦截器的中置处理方法</h3> 
<p style="margin-left:0cm;">org.springframework.web.servlet.HandlerExecutionChain#applyPostHandle</p> 
<p style="margin-left:0cm;"><img alt="" height="470" src="https://images2.imgbox.com/e7/54/0vkMgTVP_o.png" width="1035"></p> 
<h3 id="8.6%20processDispatchResult" style="margin-left:0cm;">8.6 processDispatchResult</h3> 
<h4 id="8.6.1%20ControllerAdvice%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" style="margin-left:0cm;">8.6.1 ControllerAdvice异常处理方法调用</h4> 
<p style="margin-left:0cm;">发生异常时会调用到到异常处理器ExceptionHandlerExceptionResolver，通过exceptionHandlerAdviceCache容器遍历所有的ControllerAdvice类型的bean，通过ControllerAdvice注解中配置的basePackages、assignableTypes、annotations判断抛出异常的Controller是否被当前ControllerAdvice类型的bean匹配，如果匹配通过异常类型在mappedMethods容器中找到匹配的方法</p> 
<p style="margin-left:0cm;">org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerMethod</p> 
<p style="margin-left:0cm;"><img alt="" height="596" src="https://images2.imgbox.com/3f/77/EX4rkjNj_o.png" width="1101"></p> 
<p>获取异常对应的ControllerAdvice类型bean的异常处理方法后，设置参数解析器，设置返回值解析器，调用异常处理方法，将异常和请求路径对应的HandlerMethod作为参数传入，解析异常处理方法的参数反射进行异常处理方法方法调用org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#doResolveHandlerMethodException</p> 
<p><img alt="" height="618" src="https://images2.imgbox.com/e5/8b/U2kchtn3_o.png" width="1139"></p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/f7/e5/Y2qWnkDS_o.png" width="1090"></p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/37/18/F4cgPyje_o.png" width="975"></p> 
<h4 id="8.6.2%20%E5%80%92%E5%BA%8F%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95" style="margin-left:0cm;">8.6.2 倒序调用拦截器后置处理方法</h4> 
<p style="margin-left:0cm;">org.springframework.web.servlet.DispatcherServlet#processDispatchResult</p> 
<p style="margin-left:0cm;"><img alt="" height="533" src="https://images2.imgbox.com/e6/b9/31rQvVy8_o.png" width="1086"></p> 
<p style="margin-left:0cm;"><img alt="" height="488" src="https://images2.imgbox.com/51/d2/GIBEGfqj_o.png" width="1104"></p> 
<p style="margin-left:0cm;">到这里就完成了spring mvc主流程的源码分析，截止本篇也就完成了spring 整个源码包括spring ioc、spring aop、spring mvc的简要分析。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a23941431ea9e801bb84ac180a2291c1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【深度学习】关于负梯度方向，函数值下降最大的思考</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1e4a305905c313d3189da9223b63f7c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaSE笔记 类与对象</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>