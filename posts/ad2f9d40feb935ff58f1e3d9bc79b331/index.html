<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>「RabbitMQ」实现消息确认机制以确保消息的可靠发送、接收和拒收 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="「RabbitMQ」实现消息确认机制以确保消息的可靠发送、接收和拒收" />
<meta property="og:description" content="目录
介绍
方案
配置手动确认
使用 「Bean 」 配置RabbitMQ的属性
确定消费、拒绝消费、拒绝消费进入死信队列
模拟生产者发送消息①
介绍 RabbitMQ 的消息确认机制应用场景非常广泛，尤其是在需要确保消息可靠性和避免消息丢失的场合下更为重要，例如：金融系统、电商交易系统等。以下是消息确认机制的一些常见应用场景和好处：
1. 确认消息的可靠性
在 RabbitMQ 中，生产者将消息发送到队列之后就不能再控制该消息的安全性，而消费者需要及时地对该消息进行处理并进行确认，以确保该消息已经被成功消费。使用消息确认机制可以保证消息只会被消费一次，从而确保消息的可靠性。
2. 防止消息丢失
在 RabbitMQ 中，当消费者从队列中取出消息之后，消息就被认为是已经消费，如果消费者在消费过程中出现异常导致消费失败，那么该消息就会从队列中被删除，从而导致消息丢失。使用消息确认机制可以避免这种情况的发生，从而保证消息不会丢失。
3. 避免重复消费
在 RabbitMQ 中，如果消费者在处理完一个消息之后没有及时确认该消息已经被消费，那么 RabbitMQ 认为该消息未被消费，就会将该消息重新发送给另一个消费者进行消费，从而导致消息重复消费。使用消息确认机制可以避免这种情况的发生，从而保证消息只会被消费一次。
4. 节约系统资源
在 RabbitMQ 中，当一个消费者同时处理多个消息时，可能会导致系统资源短缺或者消息被重复消费。使用消息确认机制可以限制消费者一次只处理一个消息，从而提高系统的稳定性和可靠性，同时还可以避免消息被重复消费的问题。
综上所述，消息确认机制在 RabbitMQ 中的应用场景非常广泛，可以有效地保证消息的可靠性、避免消息丢失和重复消费、节约系统资源等。因此，在实际应用中，推荐使用消息确认机制来确保 RabbitMQ 的高可用和高性能。
方案 在消息传递系统中，实现消息的可靠性可以通过引入消息确认机制来完成。该机制涉及三个方面：确认消息的发送、确认消息的接收以及拒收消息的处理。以下是这一优化的详细方案：
确认消息的发送：
发送者在向消息队列发送消息之前，需等待接收到消息队列发出的确认信号。当消息成功写入消息队列后，消息队列会发送一个确认信号给发送者，表示消息已经被成功接收并保存。如果发送者在一定时间内未收到确认信号，可以选择重新发送消息或执行其他错误处理逻辑。 确认消息的接收：
接收者在从消息队列中获取消息后，需发送一个确认信号给消息队列，表示已经成功接收到该消息。消息队列收到确认信号后，会将该消息标记为已确认，并在需要的情况下进行下一步处理。如果接收者在一定时间内未发送确认信号，消息队列可以将该消息重新投递给其他接收者或执行其他补救措施。 拒收消息的处理：
如果接收者无法处理某条消息，可以发送拒收信号给消息队列，表示拒绝接收该消息。消息队列收到拒收信号后，可以将该消息重新投递给其他接收者或执行其他适当的处理策略。发送拒收信号的原因可能包括消息格式错误、业务逻辑不符等。 通过实现消息确认机制，可以提高消息传递的可靠性和稳定性。发送者可以确保消息被正确写入消息队列，接收者可以确保每条消息被成功接收，并且拒收功能可以帮助处理无法处理的消息。
配置手动确认 #自动签收:auto 手动:manual spring.rabbitmq.listener.simple.acknowledge-mode=manual 若要实现手动确认，必须在配置中这样配置，否则消息会被重复消费，还会遇见不可预料的报错结果
使用 「Bean 」 配置RabbitMQ的属性 @Configuration public class RabbitMqConfig { Logger logger = LoggerFactory.getLogger(RabbitMqConfig.class); @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) { RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory); // 设置开启Mandatory,才能触发回调函数,无论消息推送结果怎么样都强制调用回调函数 rabbitTemplate." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ad2f9d40feb935ff58f1e3d9bc79b331/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-12T11:31:05+08:00" />
<meta property="article:modified_time" content="2023-07-12T11:31:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">「RabbitMQ」实现消息确认机制以确保消息的可靠发送、接收和拒收</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%BB%8B%E7%BB%8D" rel="nofollow">介绍</a></p> 
<p id="%E6%96%B9%E6%A1%88-toc" style="margin-left:0px;"><a href="#%E6%96%B9%E6%A1%88" rel="nofollow">方案</a></p> 
<p id="%E9%85%8D%E7%BD%AE%E6%89%8B%E5%8A%A8%E7%A1%AE%E8%AE%A4-toc" style="margin-left:0px;"><a href="#%E9%85%8D%E7%BD%AE%E6%89%8B%E5%8A%A8%E7%A1%AE%E8%AE%A4" rel="nofollow">配置手动确认</a></p> 
<p id="%E4%BD%BF%E7%94%A8%20%E3%80%8CBean%C2%A0%E3%80%8D%20%E9%85%8D%E7%BD%AERabbitMQ%E7%9A%84%E5%B1%9E%E6%80%A7-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8%20%E3%80%8CBean%C2%A0%E3%80%8D%20%E9%85%8D%E7%BD%AERabbitMQ%E7%9A%84%E5%B1%9E%E6%80%A7" rel="nofollow">使用 「Bean 」 配置RabbitMQ的属性</a></p> 
<p id="%E7%A1%AE%E5%AE%9A%E6%B6%88%E8%B4%B9%E3%80%81%E6%8B%92%E7%BB%9D%E6%B6%88%E8%B4%B9%E3%80%81%E6%8B%92%E7%BB%9D%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%85%A5%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E7%A1%AE%E5%AE%9A%E6%B6%88%E8%B4%B9%E3%80%81%E6%8B%92%E7%BB%9D%E6%B6%88%E8%B4%B9%E3%80%81%E6%8B%92%E7%BB%9D%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%85%A5%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97" rel="nofollow">确定消费、拒绝消费、拒绝消费进入死信队列</a></p> 
<p id="%E6%A8%A1%E6%8B%9F%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E2%91%A0-toc" style="margin-left:0px;"><a href="#%E6%A8%A1%E6%8B%9F%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E2%91%A0" rel="nofollow">模拟生产者发送消息①</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%BB%8B%E7%BB%8D">介绍</h2> 
<blockquote> 
 <p>        RabbitMQ 的消息确认机制应用场景非常广泛，尤其是在需要确保消息可靠性和避免消息丢失的场合下更为重要，例如：金融系统、电商交易系统等。以下是消息确认机制的一些常见应用场景和好处：</p> 
 <p></p> 
 <p>        <span style="color:#fe2c24;"><strong>1. 确认消息的可靠性</strong></span></p> 
 <p>        在 RabbitMQ 中，生产者将消息发送到队列之后就不能再控制该消息的安全性，而消费者需要及时地对该消息进行处理并进行确认，以确保该消息已经被成功消费。使用消息确认机制可以保证消息只会被消费一次，从而确保消息的可靠性。</p> 
 <p></p> 
 <p>        <span style="color:#fe2c24;"><strong>2. 防止消息丢失</strong></span></p> 
 <p>        在 RabbitMQ 中，当消费者从队列中取出消息之后，消息就被认为是已经消费，如果消费者在消费过程中出现异常导致消费失败，那么该消息就会从队列中被删除，从而导致消息丢失。使用消息确认机制可以避免这种情况的发生，从而保证消息不会丢失。</p> 
 <p></p> 
 <p>       <span style="color:#fe2c24;"><strong> 3. 避免重复消费</strong></span></p> 
 <p>        在 RabbitMQ 中，如果消费者在处理完一个消息之后没有及时确认该消息已经被消费，那么 RabbitMQ 认为该消息未被消费，就会将该消息重新发送给另一个消费者进行消费，从而导致消息重复消费。使用消息确认机制可以避免这种情况的发生，从而保证消息只会被消费一次。</p> 
 <p></p> 
 <p>       <span style="color:#fe2c24;"><strong> 4. 节约系统资源</strong></span></p> 
 <p>        在 RabbitMQ 中，当一个消费者同时处理多个消息时，可能会导致系统资源短缺或者消息被重复消费。使用消息确认机制可以限制消费者一次只处理一个消息，从而提高系统的稳定性和可靠性，同时还可以避免消息被重复消费的问题。</p> 
 <p></p> 
 <p>        综上所述，消息确认机制在 RabbitMQ 中的应用场景非常广泛，可以有效地保证消息的可靠性、避免消息丢失和重复消费、节约系统资源等。因此，在实际应用中，推荐使用消息确认机制来确保 RabbitMQ 的高可用和高性能。</p> 
</blockquote> 
<h2 id="%E6%96%B9%E6%A1%88">方案</h2> 
<blockquote> 
 <p>        在消息传递系统中，实现消息的可靠性可以通过引入消息确认机制来完成。该机制涉及三个方面：确认消息的发送、确认消息的接收以及拒收消息的处理。以下是这一优化的详细方案：</p> 
 <ol><li> <p><strong><span style="color:#fe2c24;">确认消息的发送：</span></strong></p> 
   <ul><li>发送者在向消息队列发送消息之前，需等待接收到消息队列发出的确认信号。</li><li>当消息成功写入消息队列后，消息队列会发送一个确认信号给发送者，表示消息已经被成功接收并保存。</li><li>如果发送者在一定时间内未收到确认信号，可以选择重新发送消息或执行其他错误处理逻辑。</li></ul></li><li> <p><strong><span style="color:#fe2c24;">确认消息的接收：</span></strong></p> 
   <ul><li>接收者在从消息队列中获取消息后，需发送一个确认信号给消息队列，表示已经成功接收到该消息。</li><li>消息队列收到确认信号后，会将该消息标记为已确认，并在需要的情况下进行下一步处理。</li><li>如果接收者在一定时间内未发送确认信号，消息队列可以将该消息重新投递给其他接收者或执行其他补救措施。</li></ul></li><li> <p><span style="color:#fe2c24;"><strong>拒收消息的处理：</strong></span></p> 
   <ul><li>如果接收者无法处理某条消息，可以发送拒收信号给消息队列，表示拒绝接收该消息。</li><li>消息队列收到拒收信号后，可以将该消息重新投递给其他接收者或执行其他适当的处理策略。</li><li>发送拒收信号的原因可能包括消息格式错误、业务逻辑不符等。</li></ul></li></ol> 
 <p>        通过实现消息确认机制，可以提高消息传递的可靠性和稳定性。发送者可以确保消息被正确写入消息队列，接收者可以确保每条消息被成功接收，并且拒收功能可以帮助处理无法处理的消息。</p> 
</blockquote> 
<h2 id="%E9%85%8D%E7%BD%AE%E6%89%8B%E5%8A%A8%E7%A1%AE%E8%AE%A4">配置手动确认</h2> 
<pre><code class="language-java">#自动签收:auto  手动:manual
spring.rabbitmq.listener.simple.acknowledge-mode=manual</code></pre> 
<blockquote> 
 <p>若要实现手动确认，必须在配置中这样配置，否则消息会被重复消费，还会遇见不可预料的报错结果</p> 
</blockquote> 
<h2 id="%E4%BD%BF%E7%94%A8%20%E3%80%8CBean%C2%A0%E3%80%8D%20%E9%85%8D%E7%BD%AERabbitMQ%E7%9A%84%E5%B1%9E%E6%80%A7">使用 「Bean 」 配置RabbitMQ的属性</h2> 
<pre><code class="language-java">@Configuration
public class RabbitMqConfig {
    Logger logger = LoggerFactory.getLogger(RabbitMqConfig.class);
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        // 设置开启Mandatory,才能触发回调函数,无论消息推送结果怎么样都强制调用回调函数
        rabbitTemplate.setMandatory(true);
        // 确认消息送到交换机(Exchange)回调
        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; {
            if (ack) {
                assert correlationData != null;
                logger.info("消息确认送到交换机(Exchange)，消息的唯一标识符：{}", correlationData.getId());
            } else {
                logger.info("投递失败，错误原因 ：{}", cause);
            }
        });
        return rabbitTemplate;
    }
}</code></pre> 
<blockquote> 
 <p>生产者发送的消息，不管成功与否都会调用回调函数，确保消息已经成功发送到交换机中</p> 
</blockquote> 
<blockquote> 
 <p>如果设置手动确认，则所有队列中的消息被消费后都需要手动确认，不然不会从队列中移除，第二次重启服务后还会被重复消费，如下图所示：</p> 
</blockquote> 
<p class="img-center"><img alt="" height="333" src="https://images2.imgbox.com/c4/f6/Oi5dPYfX_o.png" width="765"></p> 
<h2 id="%E7%A1%AE%E5%AE%9A%E6%B6%88%E8%B4%B9%E3%80%81%E6%8B%92%E7%BB%9D%E6%B6%88%E8%B4%B9%E3%80%81%E6%8B%92%E7%BB%9D%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%85%A5%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97">确定消费、拒绝消费、拒绝消费进入死信队列</h2> 
<pre><code class="language-java">@Configuration
public class SimpleQueueConfig {
    Logger logger = LoggerFactory.getLogger(SimpleQueueConfig.class);
    private static Map&lt;Long, String&gt; list = new HashMap&lt;&gt;();

    @Bean(name = "simpleQueue")
    public Queue queue() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(4);
        arguments.put("x-message-ttl", 20000);
        arguments.put("x-max-length", 1000);
        arguments.put("x-dead-letter-exchange", "dead.exchange");
        arguments.put("x-dead-letter-routing-key", "dead.message");
        return new Queue("simple_queue", true, false, false, arguments);
    }

    @Bean(name = "deadQueue")
    public Queue deadQueue() {
        return new Queue("dead.queue", true, false, false);
    }

    @Bean(name = "deadExchange")
    public Exchange exchange() {
        return new DirectExchange("dead.exchange", true, false);
    }

    @Bean(name = "deadBinding")
    public Binding binding() {
        return BindingBuilder.bind(deadQueue()).to(exchange()).with("dead.message").noargs();
    }

    @RabbitListener(queues = "dead.queue")
    public void readDeadMessage(Message message, Channel channel) throws IOException {
        String msg = new String(message.getBody());
        logger.info("接收到的死信消息为：{}", msg);
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    }

    @RabbitListener(queues = "simple_queue")
    public void readMessage(Message message, Channel channel) throws IOException {
        String msg = new String(message.getBody());
        System.out.println(msg);
        try {
            if (msg.contains("2") || msg.contains("7")) {
                logger.info("拒绝消费，（false）不重回队列，进入死信队列,消息为:{}", msg);
                // 第二个参数若为TRUE，则表示拒绝消费，重回队列让其他消费者消费，也可能自己会再次消费，若为FALSE，则表示不重回队列，将消息发送到死信队列中（前提是该队列绑定了死信队列）
                channel.basicReject(message.getMessageProperties().getDeliveryTag(), true);
            } else if (msg.contains("3")) {
                // 消费报了异常
                int i = 1 / 0;
            } else {
                logger.info("确认消费，消息为:{}", msg);
                // 符合消费的条件，确认消费,第二个参数表示，是否批量确认
                channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
            }
        } catch (Exception e) {
            logger.info("报错消息，拒绝消费，直接丢弃,进入死信队列,消息为:{}", msg);
            // 进入异常方法，拒绝当前消费，第二个参数表示是否批量拒绝，第三个参数表示当前消息是否重回队列顶部，若为FALSE则表示丢弃该消息，但该消息会进入死信队列（前提是该队列绑定了死信队列）
            channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);
        } finally {
            // 限制消费者只有在确认之前最多接收一个未确认的消息
            channel.basicQos(1);
        }
    }

    @RabbitListener(queues = "simple_queue")
    public void readMessageTwo(Message message, Channel channel) throws IOException {
        logger.info("two接收one拒绝的消息为：{}", new String(message.getBody()));
        // 一次只确认一条消息
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    }
}</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
 <p>channel.basicReject和channel.basicNack的主要区别是：<strong><span style="color:#fe2c24;">是否可以批量拒绝</span></strong></p> 
</blockquote> 
<p></p> 
<h2 id="%E6%A8%A1%E6%8B%9F%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E2%91%A0">模拟生产者发送消息①</h2> 
<pre><code class="language-java">@SpringBootTest(classes = MqApplication.class)
@RunWith(SpringRunner.class)
public class ProducerSimpleTest {
    @Resource
    RabbitTemplate rabbitTemplate;

    @Test
    public void test() {
        for (int i = 1; i &lt;=10; i++) {
            String msg = "消息" + i;
            CorrelationData correlationData = new CorrelationData();
            correlationData.setId(UUID.randomUUID().toString());
            rabbitTemplate.convertAndSend("simple_queue", (Object) msg, correlationData);
        }
    }
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43ab2dd6d460dff1cdc3d269d12dc2d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">U盘写流程USB协议抓包分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43aac739eb81c8e98041745eaf857b8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux驱动开发：uboot移植流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>