<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【vs2019】调试介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【vs2019】调试介绍" />
<meta property="og:description" content="文章目录 1. 调试是什么2. 调试的基本步骤3. 调试的环境4. VS2019调试快捷键5. vs2019调试窗口6. 写代码的注意事项6.1 Coding技巧6.2 assert6.3 const 7. 实现strcpy,strlen函数8. 编程常见的错误8.1 编译型错误8.2 链接型错误8.3 运行时错误 1. 调试是什么 调试(debug)是发现和减少计算机程序和电子仪器设备中得程序性错误
2. 调试的基本步骤 发现程序错误的存在 以隔离、消除等方式对错误进行定位 确定错误产生的原因 提出纠正错误的解决办法 对程序错误予以改正，重新测试 3. 调试的环境 并不是在任何环境下都可以进行调试
源程序通常有两种版本
Debug版本Release版本 Debug版本称为调试版本，包含调试信息，并且不做任何优化，便于程序员调试程序
Release版本称为发布版本，它往往进行了各种优化，使得程序在代码大小上和运行速度上都是最优的，便于用户使用
只有在Debug版本下，程序才可以进行调试
代码在Debug环境下的结果展示
代码在Release环境下的结果展示
在这里插入图片描述
代码在Debug环境下的反汇编
代码在Release环境下的反汇编
可以看到Release环境下确实会对代码进行优化
那么Release版本和Debug版本究竟进行了哪些优化？
优化编译选项：Release版本的编译选项通常会启用更多的优化选项，例如去除符号表、优化调试信息、优化代码大小等，这些都有助于减小程序体积、提高程序的运行效率。剔除调试代码：Debug版本通常会包含一些额外的调试代码，例如assert、日志输出等，这些代码对程序的运行效率可能会产生一定的影响。在Release版本中，这些调试代码通常会被剔除，从而提高程序的运行效率。优化代码结构：在Debug版本中，编译器会生成一些额外的代码，例如调试信息、符号表等，这些代码可能会导致代码结构比较松散。在Release版本中，编译器会进行优化，将代码结构优化得更加紧凑，从而提高程序的运行效率。禁用断言：Debug版本通常会包含一些断言代码，这些代码会在程序运行时进行检查，如果检查失败会导致程序崩溃。在Release版本中，这些断言代码通常会被禁用，从而减小程序体积、提高程序的运行效率。 来看下面这个代码在Release版本和Debug版本下有什么不同?
#include &lt;stdio.h&gt; int main() { int i = 0; int arr[10] = {0}; for(i=0; i&lt;=12; i&#43;&#43;) { arr[i] = 0; printf(&#34;hehe\n&#34;); } return 0; } Debug版本下是死循环" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a9da595b8c1186ff97eae964c30d7ae2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-25T09:12:08+08:00" />
<meta property="article:modified_time" content="2023-02-25T09:12:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【vs2019】调试介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1. 调试是什么</a></li><li><a href="#2__3" rel="nofollow">2. 调试的基本步骤</a></li><li><a href="#3__11" rel="nofollow">3. 调试的环境</a></li><li><a href="#4_VS2019_78" rel="nofollow">4. VS2019调试快捷键</a></li><li><a href="#5_vs2019_108" rel="nofollow">5. vs2019调试窗口</a></li><li><a href="#6__128" rel="nofollow">6. 写代码的注意事项</a></li><li><ul><li><a href="#61_Coding_137" rel="nofollow">6.1 Coding技巧</a></li><li><a href="#62_assert_144" rel="nofollow">6.2 assert</a></li><li><a href="#63_const_166" rel="nofollow">6.3 const</a></li></ul> 
  </li><li><a href="#7_strcpystrlen_184" rel="nofollow">7. 实现strcpy,strlen函数</a></li><li><a href="#8__189" rel="nofollow">8. 编程常见的错误</a></li><li><ul><li><a href="#81__190" rel="nofollow">8.1 编译型错误</a></li><li><a href="#82__194" rel="nofollow">8.2 链接型错误</a></li><li><a href="#83__197" rel="nofollow">8.3 运行时错误</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1. 调试是什么</h2> 
<blockquote> 
 <p>调试(debug)是发现和减少<code>计算机程序</code>和电子仪器设备中得<code>程序性错误</code></p> 
</blockquote> 
<h2><a id="2__3"></a>2. 调试的基本步骤</h2> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 发现程序错误的存在</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 以隔离、消除等方式对错误进行定位</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 确定错误产生的原因</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 提出纠正错误的解决办法</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 对程序错误予以改正，重新测试</li></ul> 
<h2><a id="3__11"></a>3. 调试的环境</h2> 
<p>并不是在任何环境下都可以进行调试<br> 源程序通常有两种版本</p> 
<ul><li>Debug版本</li><li>Release版本</li></ul> 
<blockquote> 
 <p><code>Debug</code>版本称为调试版本，<strong>包含调试信息，并且不做任何优化</strong>，便于程序员调试程序<br> <code>Release</code>版本称为发布版本，<strong>它往往进行了各种优化</strong>，使得程序在代码大小上和运行速度上都是最优的，便于用户使用<br> <mark>只有在<code>Debug</code>版本下，程序才可以进行调试</mark></p> 
</blockquote> 
<blockquote> 
 <p>代码在<code>Debug</code>环境下的结果展示<br> <img src="https://images2.imgbox.com/9d/97/ZLAMRnUr_o.png" alt="在这里插入图片描述"><br> 代码在<code>Release</code>环境下的结果展示<br> <a href="https://img-blog.csdnimg.cn/30dcd3b9efe94f66a2c244cca2176def.png" rel="nofollow">在这里插入图片描述</a><br> 代码在<code>Debug</code>环境下的反汇编<br> <img src="https://images2.imgbox.com/4c/59/2ngIV4Uf_o.png" alt="在这里插入图片描述"><br> 代码在<code>Release</code>环境下的反汇编<br> <img src="https://images2.imgbox.com/7a/a3/n4owCqim_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>可以看到<code>Release</code>环境下确实会对代码进行优化</p> 
<blockquote> 
 <p>那么Release版本和Debug版本究竟进行了哪些优化？</p> 
 <ol><li>优化编译选项：Release版本的编译选项通常会启用更多的优化选项，例如去除符号表、优化调试信息、优化代码大小等，这些都有助于减小程序体积、提高程序的运行效率。</li><li>剔除调试代码：Debug版本通常会包含一些额外的调试代码，例如assert、日志输出等，这些代码对程序的运行效率可能会产生一定的影响。在Release版本中，这些调试代码通常会被剔除，从而提高程序的运行效率。</li><li>优化代码结构：在Debug版本中，编译器会生成一些额外的代码，例如调试信息、符号表等，这些代码可能会导致代码结构比较松散。在Release版本中，编译器会进行优化，将代码结构优化得更加紧凑，从而提高程序的运行效率。</li><li>禁用断言：Debug版本通常会包含一些断言代码，这些代码会在程序运行时进行检查，如果检查失败会导致程序崩溃。在Release版本中，这些断言代码通常会被禁用，从而减小程序体积、提高程序的运行效率。</li></ol> 
</blockquote> 
<blockquote> 
 <p>来看下面这个代码在<code>Release版本和Debug版本</code>下有什么不同?</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">12</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hehe\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><code>Debug</code>版本下是死循环<br> <img src="https://images2.imgbox.com/20/7d/LJncI3DW_o.png" alt="在这里插入图片描述"><br> <code>Release</code>版本下不是死循环<br> <img src="https://images2.imgbox.com/5a/32/srsQgl7u_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>我们观察在Debug版本下的各个变量的地址<br> <img src="https://images2.imgbox.com/9e/3d/1Na3tCaC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/95/83/PMJ3Hxax_o.png" alt="在这里插入图片描述"><br> 我们发现在<code>Debug</code>版本下<code>arr[12]的</code>地址就是i的地址，也就是说<code>arr[12]</code>和<code>i</code>是同一个变量，当<code>i==12</code>时，<code>arr[12]=0</code>相当于改变了<code>循环变量</code>，在循环体内改变<code>循环变量</code>的值极有可能发生死循环<br> 我们可以大胆分析以下在<code>Debug</code>模式下变量的内存图如下<br> <img src="https://images2.imgbox.com/fb/f0/2bjwhLii_o.png" alt="在这里插入图片描述"><br> <font color="pink">在Debug版本下，先定义谁就先开辟谁的空间，至于每个变量之间空多大位置取决于编译器，MSVC编译器变量i的地址比arr[9]的地址多12字节</font></p> 
</blockquote> 
<blockquote> 
 <p>我们在来观察一下在<code>Release</code>版本下变量的地址<br> <code>Release</code>版本不能调试，所以用printf打印出来<br> <img src="https://images2.imgbox.com/6c/3c/rW0S3bMm_o.png" alt="在这里插入图片描述"><br> 我们可以推测在<code>Release</code>版本下，内存布局是这样的<br> <img src="https://images2.imgbox.com/39/07/1dVkPLx3_o.png" alt="在这里插入图片描述"><br> <font color="pink">在这种特殊情况下，Release版本下编译器会对变量的定义的顺序发生改变，编译器会先定义arr数组，再定义i</font></p> 
</blockquote> 
<p><font color="pink">注：上面两种版本的内存布局是这样基于两个原因</font></p> 
<ol><li>定义的局部变量存储在栈区，而栈区空间使用规则是先用高地址，后用低地址</li><li>数组元素随着下标增长，地址由低到高</li></ol> 
<h2><a id="4_VS2019_78"></a>4. VS2019调试快捷键</h2> 
<blockquote> 
 <p><strong>F5</strong><br> 未启动调试前，开始调试并跳到第一个间断点(如果有)，没有则不会进行调试<br> 启动调试后，跳到下一个间断点(如果有)，没有则推出调试<br> <strong>F9</strong><br> 创建断点和取消断点<br> 断点的重要作用，可以在程序的任意位置设置断点。<br> 这样就可以使得程序在想要的位置随意停止执行，继而一步步执行下去。<br> <strong>F10</strong><br> 逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句。<br> <strong>F11</strong><br> 逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部（这是最<br> 长用的）。<br> <strong>CTRL + F5</strong><br> 开始执行不调试，如果你想让程序直接运行起来而不调试就可以直接使用。</p> 
</blockquote> 
<p>更多快捷键<a href="https://blog.csdn.net/mrlisky/article/details/72622009">点我</a><br> <font color="pink">注:按上述快捷键无效果，则需要同时按住Fn和上述快捷键</font></p> 
<blockquote> 
 <p>这里有一个小技巧，当我们想调试观察循环第n次的情况时，我们可以设置<code>条件断点</code>,<code>条件断点</code>的意思是当满足条件时，才可以跳到断点处<br> <mark>设置方式</mark><br> 1-&gt;在循环体内打上断点，并且右击断点<img src="https://images2.imgbox.com/f3/63/UXbHT4wS_o.png" alt="在这里插入图片描述"><br> 2-&gt;选择条件选项，并且设置条件，如想直接从第10次循环开始调试，直接将条件设置为i==10<br> <img src="https://images2.imgbox.com/7a/20/L0O2ZTz8_o.png" alt="在这里插入图片描述"><br> 3-&gt;按下回车保存<br> <img src="https://images2.imgbox.com/a2/70/UuSqjZU6_o.png" alt="在这里插入图片描述"><br> 4-&gt;开始调试，这样按F5后直接跳到条件断点处，此时的i等于10<br> <img src="https://images2.imgbox.com/58/0d/SFQi6vRX_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<hr> 
<h2><a id="5_vs2019_108"></a>5. vs2019调试窗口</h2> 
<p><font color="pink"><strong>注：调试窗口均是在开启调试后才能开启的</strong></font></p> 
<blockquote> 
 <p>1.查看临时变量的值-&gt;<strong>自动窗口</strong><br> 作用：观察上下文出现过变量的值<br> 打开方式<img src="https://images2.imgbox.com/b9/73/5U6ptpPp_o.png" alt="在这里插入图片描述"><br> 2.查看变量的地址-&gt;<strong>内存</strong><br> <strong>作用</strong>：查看变量的内存信息<br> <img src="https://images2.imgbox.com/c0/dd/eFUQ4BRF_o.png" alt="在这里插入图片描述"><br> <strong>打开方式</strong><img src="https://images2.imgbox.com/62/a7/A15MBEuD_o.png" alt="在这里插入图片描述"><br> <font color="pink">注：若没有内存选项，则需要手动开启</font><br> 开启方式 工具-&gt;选项-&gt;调试-&gt;打开地址级调试<br> <img src="https://images2.imgbox.com/45/e5/8BtnoqRg_o.png" alt="在这里插入图片描述"><br> 3.查看调用堆栈-&gt;<strong>调用堆栈</strong><br> <strong>作用</strong>：清晰的反应函数的调用关系以及当前调用所处的位置<br> <img src="https://images2.imgbox.com/07/bb/zCR6Apbh_o.png" alt="在这里插入图片描述"><br> <strong>打开方式</strong><br> <img src="https://images2.imgbox.com/e5/57/GGqflYjU_o.png" alt="在这里插入图片描述"><br> 4.查看程序的汇编代码-&gt;反汇编<br> 打开方式:程序开启调试后直接在代码区域右击鼠标，选中反汇编<br> <img src="https://images2.imgbox.com/52/a4/2Ti2Fi7P_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="6__128"></a>6. 写代码的注意事项</h2> 
<blockquote> 
 <p>优秀的代码应该是这样</p> 
 <ol><li>代码运行正常</li><li>bug很少</li><li>效率高</li><li>可读性高</li><li>可维护性高</li><li>注释清晰</li><li>文档齐全</li></ol> 
</blockquote> 
<h3><a id="61_Coding_137"></a>6.1 Coding技巧</h3> 
<blockquote> 
 <ul><li>使用assert</li><li>尽量使用const’</li><li>养成良好的编码风格</li><li>添加必要的注释</li><li>避免编码的陷阱</li></ul> 
</blockquote> 
<h3><a id="62_assert_144"></a>6.2 assert</h3> 
<p><img src="https://images2.imgbox.com/93/52/FipVvtEO_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><code>assert</code>用来检测一个表达式是不是0，如果表达式是0则调用<code>abort</code>函数终止程序并且在标准错误流上输出一段话，这句话包含值是0的表达式和该程序所在的路径以及<code>assert</code>所在的行数<br> 使用<code>assert</code>需要包含头文件<code>assert.h</code><br> <img src="https://images2.imgbox.com/e7/e7/oHZQ4543_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>我们不能解引用空指针，所以<code>assert</code>可以用来判断该指针是否为空指针</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100000000l</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="63_const_166"></a>6.3 const</h3> 
<blockquote> 
 <p>在C语言中,<code>const</code>修饰的变量叫做<code>常变量</code>，它们本质上是变量，只不过具有<code>只读性</code></p> 
</blockquote> 
<blockquote> 
 <ol><li>const直接修饰变量，无法直接修改变量<img src="https://images2.imgbox.com/e2/cf/C3jn0vYP_o.png" alt="在这里插入图片描述"><br> 可以通过该变量的指针来修改该变量的值<br> <img src="https://images2.imgbox.com/b3/35/xMIHfSxH_o.png" alt="在这里插入图片描述"></li><li>const修饰指针变量有两种情况</li></ol> 
 <blockquote> 
  <ul><li><strong>const在*前面</strong><br> 代表const修饰的是指针变量所指向的对象，指向的对象不可以直接修改<br> <img src="https://images2.imgbox.com/d1/01/hd1BSSpO_o.png" alt="在这里插入图片描述"><br> 这样并不是很严谨，因为定义时没有规定a被<code>const</code>修饰的，但是定义指针变量p时又规定了a被<code>const </code>修饰</li><li><strong>const在*后面</strong><br> 代表const修饰的是指针变量本身，则这个指针变量不能指向其他的变量<br> <img src="https://images2.imgbox.com/76/47/R3Mrmcfq_o.png" alt="在这里插入图片描述"><br> 可以通过二级指针改变p本身的值<br> <img src="https://images2.imgbox.com/2b/c6/eiQkiHYy_o.png" alt="在这里插入图片描述"></li></ul> 
 </blockquote> 
</blockquote> 
<h2><a id="7_strcpystrlen_184"></a>7. 实现strcpy,strlen函数</h2> 
<p><img src="https://images2.imgbox.com/f7/15/ic4cs36X_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a8/34/h34Xxfmr_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><font color="red">注：实参是<code>chat*</code>类型，形参是<code>const char*</code> 类型，可以把不安全的类型传给更安全的类型<br> </font>如果将<code>const char*</code>类型传给<code>char*</code>类型的话，编译器会报警告</p> 
</blockquote> 
<h2><a id="8__189"></a>8. 编程常见的错误</h2> 
<h3><a id="81__190"></a>8.1 编译型错误</h3> 
<p>直接看错误提示信息(双击)，解决问题。或者凭借经验就可以搞定。相对来说比较简单。<br> <img src="https://images2.imgbox.com/0f/00/vzIJmUpp_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="82__194"></a>8.2 链接型错误</h3> 
<p>看错误提示信息，主要在代码中找到错误信息中的标识符，然后定位问题所在。一般是<mark>函数名不存在或者拼写错误</mark><img src="https://images2.imgbox.com/52/2c/IRwlKLka_o.png" alt="在这里插入图片描述"><br> LNK代表LINK链接，说明是链接错误</p> 
<h3><a id="83__197"></a>8.3 运行时错误</h3> 
<p>借助调试，逐步定位问题</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0373d0cac90e1d48ba6356ef817ba254/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#的多线程、线程池和Task</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3232ca598978fc6856fe92d4d387d8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">代码编写环境和编译器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>