<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PowerMock(一)：PowerMock的基本使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PowerMock(一)：PowerMock的基本使用" />
<meta property="og:description" content="文章目录
为啥要使用PowerMock
PowerMock的使用
环境
引入依赖
注解说明
mock普通方法
mock抛出异常
mock新建对象
mock无返回值的方法
mock被final修饰的方法
参数模糊匹配
mock静态方法
mock私有方法
总结
参考
为啥要使用PowerMock
现在流行的测试驱动开发TDD(Test-Driven Development) ，是敏捷开发中一项核心实践和技术。也是一种设计方法论。其中最重要的一环就是使用单元测试。
单元测试是保证代码质量的一个重要手段，通过单元测试我们可以快速的测试代码的各个分支，各种场景，代码重构时只需要重新跑下单元测试就是能知道代码潜在的问题。
单元测试是通过Mock的方式调用被测试的方法，其有如下几个优点：
Mock可以解除测试对象对外部服务的依赖（比如数据库，第三方接口等），使得测试用例可以独立运行。不管是单体应用还是微服务，这点都特别重要。
Mock的第二个好处就是替换外部服务调用，提升测试用例的运行速度。因为任何外部服务调用至少是跨进程级别的消耗，甚至是跨系统、跨网络的消耗，而Mock可以把消耗降低到进程内。
Mock的第三个好处就是提升测试效率，提高单位时间内测试的接口数量。
Mock的框架有很多中比如EasyMock等，这里选用PowerMock是因为PowerMock可以用来Mock 私有方法，静态方法以及final方法。EasyMock等则不能。
PowerMock的使用
环境
软件 版本
junit 4.13
powermock 2.0.7
引入依赖
&lt;properties&gt;
&lt;powermock.version&gt;2.0.7&lt;/powermock.version&gt;
&lt;/properties&gt;
&lt;dependency&gt;
&lt;groupId&gt;junit&lt;/groupId&gt;
&lt;artifactId&gt;junit&lt;/artifactId&gt;
&lt;version&gt;4.13&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--powermock开始--&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.powermock&lt;/groupId&gt;
&lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;
&lt;version&gt;${powermock.version}&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.powermock&lt;/groupId&gt;
&lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt;
&lt;version&gt;${powermock.version}&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!--powermock结束--&gt;
这里引入了是三个依赖，junit依赖如果项目中已有的话，则不需要重复引入，需要注意的是JUnit 4.4及以上版本的JUnit需要引入2.0.x 版本以上的 powermock 。如果项目中有mockito依赖还需要注意mockito的版本与powermock版本对应关系，对应如下图：
详细请参考Using PowerMock with Mockito，如果引入的版本不匹配则可能会报如下错误：
java.lang.TypeNotPresentException: Type org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/44d7bb76b0ff49d6519cffd794e4e258/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-24T16:29:59+08:00" />
<meta property="article:modified_time" content="2022-05-24T16:29:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PowerMock(一)：PowerMock的基本使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>文章目录<br><br>     为啥要使用PowerMock<br>     PowerMock的使用<br>         环境<br>         引入依赖<br>         注解说明<br>         mock普通方法<br>         mock抛出异常<br>         mock新建对象<br>         mock无返回值的方法<br>         mock被final修饰的方法<br>         参数模糊匹配<br>         mock静态方法<br>         mock私有方法<br>         总结<br>         参考<br><br> 为啥要使用PowerMock<br><br> 现在流行的测试驱动开发TDD(Test-Driven Development) ，是敏捷开发中一项核心实践和技术。也是一种设计方法论。其中最重要的一环就是使用单元测试。<br> 单元测试是保证代码质量的一个重要手段，通过单元测试我们可以快速的测试代码的各个分支，各种场景，代码重构时只需要重新跑下单元测试就是能知道代码潜在的问题。<br> 单元测试是通过Mock的方式调用被测试的方法，其有如下几个优点：<br><br>     Mock可以解除测试对象对外部服务的依赖（比如数据库，第三方接口等），使得测试用例可以独立运行。不管是单体应用还是微服务，这点都特别重要。<br>     Mock的第二个好处就是替换外部服务调用，提升测试用例的运行速度。因为任何外部服务调用至少是跨进程级别的消耗，甚至是跨系统、跨网络的消耗，而Mock可以把消耗降低到进程内。<br>     Mock的第三个好处就是提升测试效率，提高单位时间内测试的接口数量。<br>     Mock的框架有很多中比如EasyMock等，这里选用PowerMock是因为PowerMock可以用来Mock 私有方法，静态方法以及final方法。EasyMock等则不能。<br><br> PowerMock的使用<br> 环境<br> 软件    版本<br> junit    4.13<br> powermock    2.0.7<br> 引入依赖<br><br>   &lt;properties&gt;<br>         &lt;powermock.version&gt;2.0.7&lt;/powermock.version&gt;<br>     &lt;/properties&gt;<br>      &lt;dependency&gt;<br>             &lt;groupId&gt;junit&lt;/groupId&gt;<br>             &lt;artifactId&gt;junit&lt;/artifactId&gt;<br>             &lt;version&gt;4.13&lt;/version&gt;<br>         &lt;/dependency&gt;<br>         &lt;!--powermock开始--&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;org.powermock&lt;/groupId&gt;<br>             &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;<br>             &lt;version&gt;${powermock.version}&lt;/version&gt;<br>             &lt;scope&gt;test&lt;/scope&gt;<br>         &lt;/dependency&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;org.powermock&lt;/groupId&gt;<br>             &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt;<br>             &lt;version&gt;${powermock.version}&lt;/version&gt;<br>             &lt;scope&gt;test&lt;/scope&gt;<br>         &lt;/dependency&gt;<br>         &lt;!--powermock结束--&gt;<br><br><br> 这里引入了是三个依赖，junit依赖如果项目中已有的话，则不需要重复引入，需要注意的是JUnit 4.4及以上版本的JUnit需要引入2.0.x 版本以上的 powermock 。如果项目中有mockito依赖还需要注意mockito的版本与powermock版本对应关系，对应如下图：<br> 详细请参考Using PowerMock with Mockito，如果引入的版本不匹配则可能会报如下错误：<br><br> java.lang.TypeNotPresentException: Type org.powermock.modules.junit4.PowerMockRunner not present<br><br><br><br> 依赖引入之后就可以编写单元测试代码了。<br> 注解说明<br><br> 现有一个待测试的类UserServiceImpl，该类中注入了一个UserMapper的类实例。<br><br> @Service<br> public class UserServiceImpl {<!-- --><br>      @Autowried<br>     private UserMapper userMapper;<br>     ........省略部分方法<br> }<br><br><br> 那么如何对上面的类通过powermock的方式进行单元测试呢？首先是定义一个测试类，定义如下：<br><br> @RunWith(PowerMockRunner.class)<br> @PrepareForTest({UserServiceImpl.class, DateUtil.class, UserMapper.class})<br> public class UserServiceImplTest {<!-- --><br>       @Mock<br>     private UserMapper userMapper;<br>     @InjectMocks<br>     private UserServiceImpl userServiceImpl = new UserServiceImpl();<br> }<br><br><br><br> @RunWith(PowerMockRunner.class) 注解表明使用PowerMockRunner运行测试用例，这个必须添加，不然无法使用PowerMock。<br> @PrepareForTest({UserServiceImpl.class, DateUtil.class, UserMapper.class}) @PrepareForTest 注解是用来添加所有需要测试的类，这里列举了三个需要测试的类。<br> @Mock注解修饰会mock出来一个对象，这里mock出来的是UserMapper类实例。<br> @InjectMocks 注解会主动将已存在的mock对象注入到bean中，按名称注入，这个注解修饰在我们需要测试的类上。必须要手动new一个实例，不然单元测试会有问题。<br> 这几个注解是一个测试类必须要的。说完了测试类的定义，接下来就让我们来看看各种方法是如何mock的。<br> mock普通方法<br><br>     待测试的方法（UserMapper中）<br><br>  boolean saveUser(User user) {<!-- --><br>         int i = userMapper.addUser(user);<br>         return i == 1 ? true : false;<br>     }<br><br><br><br> 这里的方法int i = userMapper.addUser(user); 有入参，有出参，没有关键字修饰，是一个普通的方法，mock的方式也很简单，就是PowerMockito.when(userMapper.addUser(user)).thenReturn(1); 在when方法中调用你需要mock的方法，thenReturn方法写入你期待返回的值。从字面意思理解就是当调用xxx方法时，返回xxx值。 详细的示例如下：<br> 2. 测试方法<br><br>  User user = new User();<br>         user.setId(1);<br>         user.setUserName("test");<br>         user.setPassword("admin123");<br>         PowerMockito.when(userMapper.addUser(user)).thenReturn(1);<br>         boolean result = userServiceImpl.saveUser(user);<br>         Assert.assertEquals(true, result);<br><br><br><br> mock抛出异常<br><br> 单元测试中我们有时候需要mock异常的抛出，其mock的方式也很简单就是在thenThrow(new Exception())写入你期待抛出的异常。如果被mock的方法抛出的是受检异常(checked exception)的话，那么thenThrow抛出new Exception()或者其子类。<br> 如果被mock的方法抛出的是非受检异常(unchecked exception)，那么thenThrow抛出new RuntimeException或其子类。使用的示范如下：<br><br>     待测试的方法（UserMapper中）<br><br>  int delUser(int id) throws Exception {<!-- --><br>         if (id == -1) {<!-- --><br>             throw new Exception("传入的id值不对");<br>         } else {<!-- --><br>             return 1;<br>         }<br>     }<br><br><br><br>     测试方法<br><br>    PowerMockito.when(userMapper.delUser(-1)).thenThrow(new Exception());<br><br><br> 这里delUser方法抛出的是受检异常Exception，所以在thenThrow中需要new一个Exception对象。<br> mock新建对象<br><br> 如果我们要对一个实体对象Bean进行Mock，只需要这样写PowerMockito.whenNew(User.class).withAnyArguments().thenReturn(user)<br> 这个代码的意思是创建一个User实例对象，不管传入啥参数都返回定义的实例user，用于替换被测试方法中相应的User对象。使用示范如下：<br><br>     待测试的方法（UserMapper中）<br><br>  public int countUser() {<!-- --><br>         User user = new User();<br>         int count = 0;<br>         if (user.getId() &gt; 0) {<!-- --><br>             count += 1;<br>         }<br>         return count;<br>     }<br><br><br><br>     测试方法<br><br>  // 6.mock新建对象<br>         User user = new User();<br>         user.setId(11);<br>         PowerMockito.whenNew(User.class).withAnyArguments().thenReturn(user);<br>         int result = userServiceImpl.countUser();<br>         Assert.assertEquals(1, result);<br><br><br><br> 这里mock了一个User对象。id是11，当调用countUser方法时可以拿到之前mock的User对象，所以返回的结果是1。<br> mock无返回值的方法<br><br> 对于返回值是通过void修饰的方法，他的mock方式与普通方法的mock方式不同。有两种方式mock。<br> 方式一：<br><br>   PowerMockito.doNothing().when(userMapper, "updateUser", new User());<br><br><br><br> 在when方法中传入userMapper类实例，需要调用的方法名，以及需要传入的参数。<br> 方式二：<br><br>   PowerMockito.doNothing().when(userMapper).updateUser(user);<br><br><br> 在when方法中只传入userMapper类实例，然后通过函数式调用的方式调用待测试的方法。<br> 使用示范如下：<br><br>     待测试的方法（UserServiceImpl中）<br><br>  public void updateUser(User user) {<!-- --><br>         userMapper.updateUser(user);<br>     }<br><br>     测试方法<br><br>   User user = new User();<br>         // 4.mock返回值为void的方法<br>         //方法一<br>         PowerMockito.doNothing().when(userMapper, "updateUser", new User());<br>         //方法二<br>         PowerMockito.doNothing().when(userMapper).updateUser(user);<br>         userServiceImpl.updateUser(user);<br><br><br><br> mock被final修饰的方法<br><br> 现在有一个方法被final关键字修饰，那么该如何要mock这个方法，首先需要mock出一个类实例。如下所示：<br><br>     UserMapper mock = PowerMockito.mock(UserMapper.class);<br><br> 这里需要特别注意的是被mock的类必须要在@PrepareForTest注解中指定，如本例中的@PrepareForTest({UserMapper.class})。不然就会报如下错误：<br><br> org.mockito.exceptions.misusing.MissingMethodInvocationException:<br> when() requires an argument which has to be 'a method call on a mock'.<br><br> 使用示范如下：<br><br>     待测试的方法（UserMapper中）<br><br>     final String getUserName() {<!-- --><br>         return "admin";<br>     }<br><br><br>     测试方法<br><br>   UserMapper mock = PowerMockito.mock(UserMapper.class);<br>   when(mock.getUserName()).thenReturn("123");<br><br><br> 参数模糊匹配<br><br> 前面的测试方法中，参数我们都是指定的，在一些场景下，对于一些比较复杂的参数，我们不好构造，这时候参数模糊匹配就派上用场了。如下所示，现有方法selectUser，他有三个参数，参数类型个不相同。<br><br> User selectUser(Integer id, String userName, String password)<br><br><br><br> 当对这个方法进行mock时，可以不用传入具体的参数值。就行这样进行mock。<br><br> PowerMockito.when(userMapper.selectUser(ArgumentMatchers.anyInt(), ArgumentMatchers.anyString(), ArgumentMatchers.anyString())).thenReturn(user);</p> 
<p><br> 。。。。。。。。。。。。。。。。。</p> 
<p>版权原因，完整文章，请参考如下：</p> 
<p><a class="link-info" href="http://www.mark-to-win.com/tutorial/175141.html" rel="nofollow" title="PowerMock(一)：PowerMock的基本使用">PowerMock(一)：PowerMock的基本使用</a><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65e7bc49fbdd0126421d770d21a07cdc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">xpath获取父元素的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c96e2d894d6fa0d46f9ba11ea5fbfbb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决ArcMap中栅格的统计问题，提高工作效率</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>