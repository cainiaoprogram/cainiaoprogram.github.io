<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Spring注解必知必会】深度解析@Component注解实现原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Spring注解必知必会】深度解析@Component注解实现原理" />
<meta property="og:description" content="概述 想必@Component注解大家一直在使用，只要类上加上它，就可以被Spring容器管理，那大家有想过它是怎么实现的吗？本篇文章就带领到家揭秘。
注解介绍 用来标记的类是一个“组件”或者说是一个Bean，Spring会自动扫描标记@Component注解的类作为一个Spring Bean对象。
注解源码：
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Indexed public @interface Component { /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) */ String value() default &#34;&#34;; } 复制代码 属性说明：
value: 自定义当前组件或者说bean的名称，可以不配置， 不配置的话默认为组件的首字母小写的类名。 元注解说明：
该注解只能使用在类，接口、枚举、其他注解上该注解的生命周期是运行时JVM@Indexed元注解在spring 5.0引入，用于项目编译打包时，会在自动生成META-INF/spring.components文件，简历索引，从而提高组件扫描效率，减少应用启动时间。 注解使用 定义Person类，被@Component注解修饰 检查Person类是否在扫描路径下 获取bean验证 小结： 通过添加@Component能够将类转为Spring中的Bean对象，前提是能过够被扫描到。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/444c2d868d9bfb0288f16ae92e1d116f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-16T14:14:06+08:00" />
<meta property="article:modified_time" content="2022-08-16T14:14:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Spring注解必知必会】深度解析@Component注解实现原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>概述</h3> 
<p>想必<code>@Component</code>注解大家一直在使用，只要类上加上它，就可以被Spring容器管理，那大家有想过它是怎么实现的吗？本篇文章就带领到家揭秘。</p> 
<h3>注解介绍</h3> 
<p>用来标记的类是一个“组件”或者说是一个Bean，Spring会自动扫描标记<code>@Component</code>注解的类作为一个Spring Bean对象。</p> 
<p><strong>注解源码：</strong></p> 
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any (or empty String otherwise)
	 */
	String value() default "";

}
复制代码</code></pre> 
<p><strong>属性说明：</strong></p> 
<ul><li>value: 自定义当前组件或者说bean的名称，可以不配置， 不配置的话默认为组件的首字母小写的类名。</li></ul> 
<p><strong>元注解说明：</strong></p> 
<ul><li>该注解只能使用在类，接口、枚举、其他注解上</li><li>该注解的生命周期是运行时JVM</li><li>@Indexed元注解在spring 5.0引入，用于项目编译打包时，会在自动生成META-INF/spring.components文件，简历索引，从而提高组件扫描效率，减少应用启动时间。</li></ul> 
<h3>注解使用</h3> 
<ol><li>定义Person类，被<code>@Component</code>注解修饰</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7a/b2/klRpenUW_o.png"></p> 
<ol><li>检查Person类是否在扫描路径下</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a5/1a/tuSK893E_o.png"></p> 
<ol><li>获取bean验证</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ee/af/ay2nyWO7_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/da/e2/B2kow3jF_o.png"></p> 
<p><strong>小结：</strong> 通过添加<code>@Component</code>能够将类转为Spring中的Bean对象，前提是能过够被扫描到。</p> 
<h3>原理解析</h3> 
<p>阅读源码，我们查看<code>@Component</code>注解的源码，从中可以看到一个关键的类<code>ClassPathBeanDefinitionScanner</code>，我们可以从这个类下手，找到切入点。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/24/07/BVW4pdw7_o.png"></p> 
<p>分析<code>ClassPathBeanDefinitionScanner</code>类，找到核心方法<code>doscan</code>, 打个断点，了解整个调用链路。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d4/a9/eQ76sbQA_o.png"></p> 
<p>具体分析结果如下：</p> 
<ol><li>SpringBoot应用启动会注册<code>ConfigurationClassPostProcessor</code>这个Bean，它实现了<code>BeanDefinitionRegistryPostProcessor</code>接口，而这个接口是Spring提供的一个扩展点，可以往BeanDefinition Registry中添加BeanDefintion。所以，只要能够扫描到<code>@Component</code>注解的类，并且把它注册到BeanDefinition Registry中即可。</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ed/b2/gAEaaHp6_o.png"></p> 
<ol><li>关键方法<code>ConfigurationClassPostProcessor</code>的<code>postProcessBeanDefinitionRegistry</code>，查找<code>@Component</code>的类，并进行注册。</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/45/ad/RvKTDXqS_o.png"></p> 
<ol><li>我们直接跳到是如何查找<code>@Component</code>的类的，核心方法就是<code>ClassPathBeanDefinitionScanner#doScan</code>。</li></ol> 
<pre><code>protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
		Assert.notEmpty(basePackages, "At least one base package must be specified");
		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
        // 遍历多个扫描目录，如本例中的com.alvinlkk
		for (String basePackage : basePackages) {
            // 核心方法查找所有符合条件的BeanDefinition, 该方法后面重点关注
			Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
			// 遍历找到的BeanDefinition
            for (BeanDefinition candidate : candidates) {
				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
				candidate.setScope(scopeMetadata.getScopeName());
				String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
				if (candidate instanceof AbstractBeanDefinition) {
					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
				}
				if (candidate instanceof AnnotatedBeanDefinition) {
					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
				}
                // 验证BeanDefinition
				if (checkCandidate(beanName, candidate)) {
					BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
					definitionHolder =
							AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
					beanDefinitions.add(definitionHolder);
                    // 注册BeanDefinition到registry中
					registerBeanDefinition(definitionHolder, this.registry);
				}
			}
		}
		return beanDefinitions;
	}
复制代码</code></pre> 
<ol><li>重点关注<code>ClassPathBeanDefinitionScanner#findCandidateComponents</code>方法，找出候选的Bean Component。</li></ol> 
<pre><code>public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) {
		// 判断组件是否加了索引，打包后默认会有索引，用于加快扫描
        if (this.componentsIndex != null &amp;&amp; indexSupportsIncludeFilters()) {
			return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
		}
       // 重点查看else逻辑
		else {
			return scanCandidateComponents(basePackage);
		}
	}
复制代码</code></pre> 
<pre><code>private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) {
		Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;();
		try {
            // 解析出需要扫描的路径，本例是classpath*:com/alvinlkk/**/*.class
			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
					resolveBasePackage(basePackage) + '/' + this.resourcePattern;
			// 根据扫描路径找到所有的Resource
            Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
			boolean traceEnabled = logger.isTraceEnabled();
			boolean debugEnabled = logger.isDebugEnabled();
            // 遍历扫描路径
			for (Resource resource : resources) {
				if (traceEnabled) {
					logger.trace("Scanning " + resource);
				}
				try {
                    // 解析出扫描到类的元数据信息，里面包含了注解信息
					MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
					// 关键方法，判断是否候选组件
                    if (isCandidateComponent(metadataReader)) {
						ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
						sbd.setSource(resource);
						if (isCandidateComponent(sbd)) {
							if (debugEnabled) {
								logger.debug("Identified candidate component class: " + resource);
							}
							candidates.add(sbd);
						}
						else {
							if (debugEnabled) {
								logger.debug("Ignored because not a concrete top-level class: " + resource);
							}
						}
					}
					else {
						if (traceEnabled) {
							logger.trace("Ignored because not matching any filter: " + resource);
						}
					}
				}
				catch (FileNotFoundException ex) {
					if (traceEnabled) {
						logger.trace("Ignored non-readable " + resource + ": " + ex.getMessage());
					}
				}
				catch (Throwable ex) {
					throw new BeanDefinitionStoreException(
							"Failed to read candidate component class: " + resource, ex);
				}
			}
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
		}
		return candidates;
	}
复制代码</code></pre> 
<pre><code>// 判断是否候选的Bean Component
protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
		// exclude过滤器,在exclude过滤其中的，会直接排除掉，返回false
        for (TypeFilter tf : this.excludeFilters) {
			if (tf.match(metadataReader, getMetadataReaderFactory())) {
				return false;
			}
		}
       // include过滤器， 这里会看到有AnnotationTypeFilter,注解类型过滤器
		for (TypeFilter tf : this.includeFilters) {
            // 调用AnnotationTypeFilter的match方法，来判断是否满足条件
			if (tf.match(metadataReader, getMetadataReaderFactory())) {
                // 下面在进行Condition的判断，就是类上的@Conditional，这里不是重点
				return isConditionMatch(metadataReader);
			}
		}
		return false;
	}
复制代码</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b5/9e/kyKb8iVT_o.png"></p> 
<p>而这个AnnotationTypeFilter默认是在构造函数中注册进去的。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8a/78/qEdnVMkF_o.png"></p> 
<p><strong>小结：</strong></p> 
<p>@Component到Spring bean容器管理过程如下：</p> 
<ol><li>初始化时设置了Component类型过滤器；</li><li>根据指定扫描包扫描.class文件，生成Resource对象；</li><li>解析.class文件并注解归类，生成MetadataReader对象；</li><li>使用第一步的注解过滤器过滤出有@Component类；</li><li>生成BeanDefinition对象；</li><li>把BeanDefinition注册到Spring容器。</li></ol> 
<h3>总结</h3> 
<p>经过这篇文章文章，是不是对@Component的使用和实现原理一清二楚了呢，其实Spring中还有@Service、@Controller和@Repository等注解，他们和@Component有什么区别呢？</p> 
<p style="text-align:center;"><br><img alt="" src="https://images2.imgbox.com/eb/61/gBcBhjlS_o.jpg"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/39c6bc6db61e3d73e2891734cc7a61b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">gitlab&#43;Jenkins自动化搭建部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1944aeed40e773d47c3263a05fed966c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Hexo】本地local4000打不开解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>