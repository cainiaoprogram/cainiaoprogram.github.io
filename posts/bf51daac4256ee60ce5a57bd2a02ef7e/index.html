<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java43——泛型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java43——泛型" />
<meta property="og:description" content="一、泛型的理解
1.泛型的概念
所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返
回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、
创建对象时确定（即传入实际的类型参数，也称为类型实参）。
2.泛型的引入背景
集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt; 这个&lt;E&gt;就是类型参数，即泛型。
二、泛型在集合中的使用
1. 在集合中使用泛型之前的例子
@Test
public void test1(){
ArrayList list = new ArrayList();
//需求：存放学生的成绩
list.add(78);
list.add(76);
list.add(89);
list.add(88);
//问题一：类型不安全
// list.add(&#34;Tom&#34;);
for(Object score : list){
//问题二：强转时，可能出现ClassCastException
int stuScore = (Integer) score;
System.out.println(stuScore);
}
}
图示：
2. 在集合中使用泛型例子1
@Test
public void test2(){
ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list.add(78);
list.add(87);
list.add(99);
list.add(65);
//编译时，就会进行类型检查，保证数据的安全
// list.add(&#34;Tom&#34;);
//方式一：
// for(Integer score : list){
// //避免了强转操作
// int stuScore = score;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bf51daac4256ee60ce5a57bd2a02ef7e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-07T21:34:32+08:00" />
<meta property="article:modified_time" content="2020-09-07T21:34:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java43——泛型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、泛型的理解</p> 
<p>1.泛型的概念<br><span style="color:#f33b45;">所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返<br> 回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、<br> 创建对象时确定（即传入实际的类型参数，也称为类型实参）。</span></p> 
<p>2.泛型的引入背景<br> 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以<span style="color:#3399ea;">在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决</span>。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt;   这个&lt;E&gt;就是类型参数，即泛型。</p> 
<p>二、泛型在集合中的使用</p> 
<p>1. 在集合中使用泛型之前的例子<br> @Test<br>     public void test1(){<!-- --><br>         ArrayList list = new ArrayList();<br>     <span style="color:#86ca5e;">    //需求：存放学生的成绩</span><br>         list.add(78);<br>         list.add(76);<br>         list.add(89);<br>         list.add(88);<br><span style="color:#86ca5e;">        //问题一：类型不安全<br> //        list.add("Tom");</span></p> 
<p>        for(Object score : list){<!-- --><br>             <span style="color:#86ca5e;">//问题二：强转时，可能出现ClassCastException</span><br>             int stuScore = (Integer) score;</p> 
<p>            System.out.println(stuScore);</p> 
<p>        }</p> 
<p>    }</p> 
<p>图示：</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/67/c6/NZynDpTj_o.png" width="715"></p> 
<p>2. 在集合中使用泛型例子1<br> @Test<br>     public void test2(){<!-- --><br>        ArrayList&lt;Integer&gt; list =  new ArrayList&lt;Integer&gt;();</p> 
<p>        list.add(78);<br>         list.add(87);<br>         list.add(99);<br>         list.add(65);<br><span style="color:#86ca5e;">        //编译时，就会进行类型检查，保证数据的安全<br> //        list.add("Tom");</span></p> 
<p><span style="color:#86ca5e;">        //方式一：<br> //        for(Integer score : list){<!-- --><br> //            //避免了强转操作<br> //            int stuScore = score;<br> //<br> //            System.out.println(stuScore);<br> //<br> //        }<br>         //方式二：</span><br>         Iterator&lt;Integer&gt; iterator = list.iterator();<br>         while(iterator.hasNext()){<!-- --><br>             int stuScore = iterator.next();<br>             System.out.println(stuScore);<br>         }</p> 
<p>    }</p> 
<p>    </p> 
<p>图示：</p> 
<p><img alt="" height="172" src="https://images2.imgbox.com/25/7f/8UMzpLmE_o.png" width="678"></p> 
<p>3. 在集合中使用泛型例子2<br><span style="color:#86ca5e;">//在集合中使用泛型的情况：以HashMap为例</span><br>     @Test<br>     public void test3(){<!-- --><br><span style="color:#86ca5e;">//        Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</span><br>         <span style="color:#86ca5e;">//jdk7新特性：类型推断</span><br>         Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</p> 
<p>        map.put("Tom",87);<br>         map.put("Jerry",87);<br>         map.put("Jack",67);</p> 
<p><span style="color:#86ca5e;">//        map.put(123,"ABC");</span><br>        <span style="color:#86ca5e;"> //泛型的嵌套</span><br>         Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();<br>         Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</p> 
<p>        while(iterator.hasNext()){<!-- --><br>             Map.Entry&lt;String, Integer&gt; e = iterator.next();<br>             String key = e.getKey();<br>             Integer value = e.getValue();<br>             System.out.println(key + "----" + value);<br>         }</p> 
<p>    }</p> 
<p>4. 集合中使用泛型总结：</p> 
<p>*  ① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。<br> *  ② 在实例化集合类时，可以指明具体的泛型类型<br> *  ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。<br> *    比如：add(E e)  ---&gt;实例化以后：add(Integer e)<br> *  ④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换<br> *  ⑤ 如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型。</p> 
<p>三、自定义泛型类、泛型接口、泛型方法</p> 
<p>1.举例:<br> 【Order.java】</p> 
<p>public class Order&lt;T&gt; {<!-- --></p> 
<p>    String orderName;<br>     int orderId;</p> 
<p>   <span style="color:#86ca5e;"> //类的内部结构就可以使用类的泛型</span></p> 
<p>    T orderT;</p> 
<p>    public Order(){<!-- --><br><span style="color:#86ca5e;">        //编译不通过<br> //        T[] arr = new T[10];<br>         //编译通过</span><br>         T[] arr = (T[]) new Object[10];<br>     }</p> 
<p>    public Order(String orderName,int orderId,T orderT){<!-- --><br>         this.orderName = orderName;<br>         this.orderId = orderId;<br>         this.orderT = orderT;<br>     }</p> 
<p>   <span style="color:#86ca5e;"> //如下的个方法都不是泛型方法</span><br>     public T getOrderT(){<!-- --><br>         return orderT;<br>     }</p> 
<p>    public void setOrderT(T orderT){<!-- --><br>         this.orderT = orderT;<br>     }</p> 
<p>    @Override<br>     public String toString() {<!-- --><br>         return "Order{" +<br>                 "orderName='" + orderName + '\'' +<br>                 ", orderId=" + orderId +<br>                 ", orderT=" + orderT +<br>                 '}';<br>     }<br><span style="color:#86ca5e;">    //静态方法中不能使用类的泛型。<br> //    public static void show(T orderT){<!-- --><br> //        System.out.println(orderT);<br> //    }</span></p> 
<p>    public void show(){<!-- --><br><span style="color:#86ca5e;">        //编译不通过<br> //        try{<!-- --><br> //<br> //<br> //        }catch(T t){<!-- --><br> //<br> //        }</span></p> 
<p>    }</p> 
<p>  <span style="color:#86ca5e;">  //泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系。<br>     //换句话说，泛型方法所属的类是不是泛型类都没关系。<br>     //泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</span><br>     public static &lt;E&gt;  List&lt;E&gt; copyFromArrayToList(E[] arr){<!-- --></p> 
<p>        ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</p> 
<p>        for(E e : arr){<!-- --><br>             list.add(e);<br>         }<br>         return list;</p> 
<p>    }<br> }</p> 
<p>【SubOrder.java】<br> public class SubOrder extends Order&lt;Integer&gt; {<!-- --><span style="color:#86ca5e;">//SubOrder:不是泛型类</span></p> 
<p><br>     public static &lt;E&gt; List&lt;E&gt; copyFromArrayToList(E[] arr){<!-- --></p> 
<p>        ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</p> 
<p>        for(E e : arr){<!-- --><br>             list.add(e);<br>         }<br>         return list;</p> 
<p>    }</p> 
<p><br> }</p> 
<p>//实例化时，如下的代码是错误的<br> SubOrder&lt;Integer&gt; o = new SubOrder&lt;&gt;();</p> 
<p>【SubOrder1.java】<br> public class SubOrder1&lt;T&gt; extends Order&lt;T&gt; {<!-- --><span style="color:#86ca5e;">//SubOrder1&lt;T&gt;:仍然是泛型类</span></p> 
<p>}</p> 
<p>【测试】<br> @Test<br>     public void test1(){<!-- --><br>     <span style="color:#86ca5e;">    //如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型<br>         //要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。</span><br>         Order order = new Order();<br>         order.setOrderT(123);<br>         order.setOrderT("ABC");</p> 
<p>      <span style="color:#86ca5e;">  //建议：实例化时指明类的泛型</span><br>         Order&lt;String&gt; order1 = new Order&lt;String&gt;("orderAA",1001,"order:AA");</p> 
<p>        order1.setOrderT("AA:hello");</p> 
<p>    }</p> 
<p>    @Test<br>     public void test2(){<!-- --><br>         SubOrder sub1 = new SubOrder();<br>        <span style="color:#86ca5e;"> //由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。</span><br>         sub1.setOrderT(1122);</p> 
<p>        SubOrder1&lt;String&gt; sub2 = new SubOrder1&lt;&gt;();<br>         sub2.setOrderT("order2...");<br>     }</p> 
<p>    @Test<br>     public void test3(){<!-- --></p> 
<p>        ArrayList&lt;String&gt; list1 = null;<br>         ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();<br><span style="color:#86ca5e;">        //泛型不同的引用不能相互赋值。<br> //        list1 = list2;</span></p> 
<p>        Person p1 = null;<br>         Person p2 = null;<br>         p1 = p2;</p> 
<p><br>     }</p> 
<p>  <span style="color:#86ca5e;">  //测试泛型方法</span><br>     @Test<br>     public void test4(){<!-- --><br>         Order&lt;String&gt; order = new Order&lt;&gt;();<br>         Integer[] arr = new Integer[]{1,2,3,4};<br>     <span style="color:#86ca5e;">    //泛型方法在调用时，指明泛型参数的类型。</span><br>         List&lt;Integer&gt; list = order.copyFromArrayToList(arr);</p> 
<p>        System.out.println(list);<br>     }</p> 
<p>2.注意点：</p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/35/00/ESIWIp3i_o.png" width="785"></p> 
<p><img alt="" height="415" src="https://images2.imgbox.com/d3/ab/BoIaMixu_o.png" width="816"></p> 
<p>3.应用场景举例：<br> 【DAO.java】:定义了操作数据库中的表的通用操作。   ORM思想(数据库中的表和Java中的类对应)<br> public class DAO&lt;T&gt; {//表的共性操作的DAO</p> 
<p>    //添加一条记录<br>     public void add(T t){<!-- --></p> 
<p>    }</p> 
<p>    //删除一条记录<br>     public boolean remove(int index){<!-- --></p> 
<p>        return false;<br>     }</p> 
<p>    //修改一条记录<br>     public void update(int index,T t){<!-- --></p> 
<p>    }</p> 
<p>    //查询一条记录<br>     public T getIndex(int index){<!-- --></p> 
<p>        return null;<br>     }</p> 
<p>    //查询多条记录<br>     public List&lt;T&gt; getForList(int index){<!-- --></p> 
<p>        return null;<br>     }</p> 
<p>    //泛型方法<br>     //举例：获取表中一共有多少条记录？获取最大的员工入职时间？<br>     public &lt;E&gt; E getValue(){<!-- --></p> 
<p>        return null;<br>     }</p> 
<p>}</p> 
<p>【CustomerDAO.java】:<br> public class CustomerDAO extends DAO&lt;Customer&gt;{//只能操作某一个表的DAO<br> }</p> 
<p>【StudentDAO.java】:<br> public class StudentDAO extends DAO&lt;Student&gt; {//只能操作某一个表的DAO<br> }</p> 
<p>四、泛型在继承上的体现</p> 
<p>泛型在继承上的体现:<br> /*<br>     1. 泛型在继承方面的体现</p> 
<p>      虽然类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。</p> 
<p>       补充：类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类</p> 
<p>     */<br>     @Test<br>     public void test1(){<!-- --></p> 
<p>        Object obj = null;<br>         String str = null;<br>         obj = str;</p> 
<p>        Object[] arr1 = null;<br>         String[] arr2 = null;<br>         arr1 = arr2;<br>         //编译不通过<br> //        Date date = new Date();<br> //        str = date;<br>         List&lt;Object&gt; list1 = null;<br>         List&lt;String&gt; list2 = new ArrayList&lt;String&gt;();<br>         //此时的list1和list2的类型不具子父类关系<br>         //编译不通过<br> //        list1 = list2;<br>         /*<br>         反证法：<br>         假设list1 = list2;<br>            list1.add(123);导致混入非String的数据。出错。</p> 
<p>         */</p> 
<p>        show(list1);<br>         show1(list2);</p> 
<p>    }</p> 
<p>    public void show1(List&lt;String&gt; list){<!-- --></p> 
<p>    }</p> 
<p>    public void show(List&lt;Object&gt; list){<!-- --></p> 
<p>    }</p> 
<p>    @Test<br>     public void test2(){<!-- --></p> 
<p>        AbstractList&lt;String&gt; list1 = null;<br>         List&lt;String&gt; list2 = null;<br>         ArrayList&lt;String&gt; list3 = null;</p> 
<p>        list1 = list3;<br>         list2 = list3;</p> 
<p>        List&lt;String&gt; list4 = new ArrayList&lt;&gt;();</p> 
<p>    }</p> 
<p>五、通配符</p> 
<p>1.通配符的使用<br><span style="color:#86ca5e;">/*<br>     通配符的使用<br>        通配符：?</span></p> 
<p><span style="color:#86ca5e;">       类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没关系的，二者共同的父类是：G&lt;?&gt;</span></p> 
<p><br><span style="color:#86ca5e;">     */</span></p> 
<p>    @Test<br>     public void test3(){<!-- --><br>         List&lt;Object&gt; list1 = null;<br>         List&lt;String&gt; list2 = null;</p> 
<p>        List&lt;?&gt; list = null;</p> 
<p>        list = list1;<br>         list = list2;<br>      <span style="color:#86ca5e;">   //编译通过<br> //        print(list1);<br> //        print(list2);</span></p> 
<p><br>         //<br>         List&lt;String&gt; list3 = new ArrayList&lt;&gt;();<br>         list3.add("AA");<br>         list3.add("BB");<br>         list3.add("CC");<br>         list = list3;<br>    <span style="color:#86ca5e;">     //添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。<br>         //除了添加null之外。<br> //        list.add("DD");<br> //        list.add('?');</span></p> 
<p>        list.add(null);</p> 
<p>        <span style="color:#86ca5e;">//获取(读取)：允许读取数据，读取的数据类型为Object。</span><br>         Object o = list.get(0);<br>         System.out.println(o);</p> 
<p><br>     }</p> 
<p>    public void print(List&lt;?&gt; list){<!-- --><br>         Iterator&lt;?&gt; iterator = list.iterator();<br>         while(iterator.hasNext()){<!-- --><br>             Object obj = iterator.next();<br>             System.out.println(obj);<br>         }<br>     }</p> 
<p>2.涉及通配符的集合的数据的写入和读取:</p> 
<p>见上    </p> 
<p>3.有限制条件的通配符的使用<br><span style="color:#86ca5e;">/*<br>     限制条件的通配符的使用。<br>         ? extends A:<br>                 G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类</span></p> 
<p><span style="color:#86ca5e;">        ? super A:<br>                 G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类</span></p> 
<p><span style="color:#86ca5e;">     */</span><br>     @Test<br>     public void test4(){<!-- --></p> 
<p>        List&lt;? extends Person&gt; list1 = null;<br>         List&lt;? super Person&gt; list2 = null;</p> 
<p>        List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;();<br>         List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;();<br>         List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;();</p> 
<p>        list1 = list3;<br>         list1 = list4;<br> //        list1 = list5;</p> 
<p>//        list2 = list3;<br>         list2 = list4;<br>         list2 = list5;</p> 
<p>        //读取数据：<br>         list1 = list3;<br>         Person p = list1.get(0);<br>         //编译不通过<br>         //Student s = list1.get(0);</p> 
<p>        list2 = list4;<br>         Object obj = list2.get(0);<br>         编译不通过<br> //        Person obj = list2.get(0);</p> 
<p>        //写入数据：<br>         //编译不通过<br> //        list1.add(new Student());</p> 
<p>        //编译通过<br>         list2.add(new Person());<br>         list2.add(new Student());</p> 
<p>    }     </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/317bc68279a5082f9799d156e524193b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何利用VisionSeed&#43;树莓派，实现智能小车实时图传系统？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b19ec666325e9dd224105f48357332c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CVPR2020 步态论文：Gait Recognition via Semi-supervised Disentangled Representation Learning to Identit</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>