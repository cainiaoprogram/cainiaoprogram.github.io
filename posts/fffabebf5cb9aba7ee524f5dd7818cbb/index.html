<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>尚硅谷kubernates学习笔记 1 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="尚硅谷kubernates学习笔记 1" />
<meta property="og:description" content="文章目录 1 概念1.1 组件1.2 插件1.3 术语1.4 Pod类型1.4.1 RS1.4.2 Deployment1.4.3 DaemonSet1.4.4 Job &amp; CronJob1.4.5 StatefulSet 1.5 service服务发现1.5.1 ipvs代理模式1.5.2 Service实验1.5.3 Ingress 1.6 网络空间1.7 资源1.8 容器生命周期1.8.1 容器hook1.8.2 Pod状态含义 1 概念 k8s用于大规模部署和运维容器
优点：
自动部署自动修复水平扩展服务发现滚动更新版本回退密钥配置管理（类似热部署）存储编排（持久化）批处理（定时任务） 1.1 组件 master：主节点，其下包含：
api server：Kubernetes 控制平面的前端，用于处理内部和外部请求，所有服务访问的统一入口controller manager：处理后台任务，资源控制，控制器负责实际运行集群，维持副本期望数目scheduler：节点调度，选择node节点部署应用，检测集群和节点状态etcd：用于存储集群中的相关数据，键值对 worker node：工作节点，其下包含：
kubelet：类似于node节点的agent，管理当前节点的容器，管理容器生命周期kube proxy：提供网络上的代理，实现负载均衡等功能，写入iptables、ipvs等端口映射 核心概念：
Pod：k8s最小的部署单元、一个Pod中包含一组容器、同一个Pod中容器网络共享、生命周期短暂Controller：确保预期Pod副本数量、部署Pod、设定Pod运行规则、设定定时任务和一次任务Service：定义Pod访问规则
1.2 插件 CoreDNS：为集群中的SVC创建一个域名IP的对应解析
Dashboard：给集群提供一个B/S访问体系
Ingress Controller：官方只有四成代理，ingress可以实现七层代理
Federation：提供一个跨集群中心多k8s统一管理
Prometheus：提供集群监控
elk：提供日志分析
1.3 术语 主机（Master）： 用于控制 Kubernetes 节点的计算机。所有任务分配都来自于此。
节点（Node）：负责执行请求和所分配任务的计算机。由 Kubernetes 主机负责对节点进行控制。
容器集（Pod）：被部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将网络和存储从底层容器中抽象出来。这样，您就能更加轻松地在集群中移动容器。
复制控制器（Replication controller）：用于控制应在集群某处运行的完全相同的容器集副本数量。
服务（Service）：将工作内容与容器集分离。Kubernetes 服务代理会自动将服务请求分发到正确的容器集——无论这个容器集会移到集群中的哪个位置，甚至可以被替换掉。
Kubelet：运行在节点上的服务，可读取容器清单（container manifest），确保指定的容器启动并运行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fffabebf5cb9aba7ee524f5dd7818cbb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-15T15:52:49+08:00" />
<meta property="article:modified_time" content="2023-11-15T15:52:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">尚硅谷kubernates学习笔记 1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1 概念</a></li><li><ul><li><a href="#11__14" rel="nofollow">1.1 组件</a></li><li><a href="#12__30" rel="nofollow">1.2 插件</a></li><li><a href="#13__37" rel="nofollow">1.3 术语</a></li><li><a href="#14_Pod_46" rel="nofollow">1.4 Pod类型</a></li><li><ul><li><a href="#141_RS_77" rel="nofollow">1.4.1 RS</a></li><li><a href="#142_Deployment_81" rel="nofollow">1.4.2 Deployment</a></li><li><a href="#143_DaemonSet_198" rel="nofollow">1.4.3 DaemonSet</a></li><li><a href="#144_Job__CronJob_202" rel="nofollow">1.4.4 Job &amp; CronJob</a></li><li><a href="#145_StatefulSet_228" rel="nofollow">1.4.5 StatefulSet</a></li></ul> 
   </li><li><a href="#15_service_233" rel="nofollow">1.5 service服务发现</a></li><li><ul><li><a href="#151_ipvs_267" rel="nofollow">1.5.1 ipvs代理模式</a></li><li><a href="#152_Service_280" rel="nofollow">1.5.2 Service实验</a></li><li><a href="#153_Ingress_302" rel="nofollow">1.5.3 Ingress</a></li></ul> 
   </li><li><a href="#16__463" rel="nofollow">1.6 网络空间</a></li><li><a href="#17__482" rel="nofollow">1.7 资源</a></li><li><a href="#18__550" rel="nofollow">1.8 容器生命周期</a></li><li><ul><li><a href="#181_hook_579" rel="nofollow">1.8.1 容器hook</a></li><li><a href="#182_Pod_602" rel="nofollow">1.8.2 Pod状态含义</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1 概念</h2> 
<p>k8s用于大规模部署和运维容器<br> 优点：</p> 
<ul><li>自动部署</li><li>自动修复</li><li>水平扩展</li><li>服务发现</li><li>滚动更新</li><li>版本回退</li><li>密钥配置管理（类似热部署）</li><li>存储编排（持久化）</li><li>批处理（定时任务）</li></ul> 
<h3><a id="11__14"></a>1.1 组件</h3> 
<p>master：主节点，其下包含：</p> 
<ul><li>api server：Kubernetes 控制平面的前端，用于处理内部和外部请求，所有服务访问的统一入口</li><li>controller manager：处理后台任务，资源控制，控制器负责实际运行集群，维持副本期望数目</li><li>scheduler：节点调度，选择node节点部署应用，检测集群和节点状态</li><li>etcd：用于存储集群中的相关数据，键值对</li></ul> 
<p>worker node：工作节点，其下包含：</p> 
<ul><li>kubelet：类似于node节点的agent，管理当前节点的容器，管理容器生命周期</li><li>kube proxy：提供网络上的代理，实现负载均衡等功能，写入iptables、ipvs等端口映射</li></ul> 
<p>核心概念：</p> 
<ul><li>Pod：k8s最小的部署单元、一个Pod中包含一组容器、同一个Pod中容器网络共享、生命周期短暂</li><li>Controller：确保预期Pod副本数量、部署Pod、设定Pod运行规则、设定定时任务和一次任务</li><li>Service：定义Pod访问规则<br> <img src="https://images2.imgbox.com/0f/47/fsGf0bzU_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="12__30"></a>1.2 插件</h3> 
<p>CoreDNS：为集群中的SVC创建一个域名IP的对应解析<br> Dashboard：给集群提供一个B/S访问体系<br> Ingress Controller：官方只有四成代理，ingress可以实现七层代理<br> Federation：提供一个跨集群中心多k8s统一管理<br> Prometheus：提供集群监控<br> elk：提供日志分析</p> 
<h3><a id="13__37"></a>1.3 术语</h3> 
<p><strong>主机（Master）</strong>： 用于控制 Kubernetes 节点的计算机。所有任务分配都来自于此。<br> <strong>节点（Node）</strong>：负责执行请求和所分配任务的计算机。由 Kubernetes 主机负责对节点进行控制。<br> <strong>容器集（Pod）</strong>：被部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将网络和存储从底层容器中抽象出来。这样，您就能更加轻松地在集群中移动容器。<br> <strong>复制控制器（Replication controller）</strong>：用于控制应在集群某处运行的完全相同的容器集副本数量。<br> <strong>服务（Service）</strong>：将工作内容与容器集分离。Kubernetes 服务代理会自动将服务请求分发到正确的容器集——无论这个容器集会移到集群中的哪个位置，甚至可以被替换掉。<br> <strong>Kubelet</strong>：运行在节点上的服务，可读取容器清单（container manifest），确保指定的容器启动并运行。<br> <strong>kubectl</strong>： Kubernetes 的命令行配置工具。</p> 
<h3><a id="14_Pod_46"></a>1.4 Pod类型</h3> 
<p>Pod分为：</p> 
<ul><li>自主式：Pod推出了，不会被创建</li><li>控制器管理的：在控制器的生命周期中，始终要维持Pod副本数</li></ul> 
<p>一个pod默认启动时会创建一个初始容器：pause，其余在该pod上的容器会公用pause的【网络栈】和【存储卷】，即一个pod中的容器的端口不能冲突</p> 
<p>pod中有多种<strong>控制器</strong>：</p> 
<ul><li>ReplicationController(RC)：确保容器副本数保持在用户定义的数量，容器异常会自动回收并创建新的（现在建议使用RS取代RC，RC已淘汰）</li><li><strong>ReplicaSet</strong>(RS)：功能和RC一样，支持集合式的selector，打标签</li><li><strong>Deployment：RC</strong>独立使用不如使用Deployment来管理好用，可以无需担心兼容问题，如RS不支持rolling-update，但是Deployment支持，通过声明式语法来定义和管理Pod，提供滚动升级、扩容缩容、暂停和继续</li><li><strong>DaemonSet</strong>：每个DeamonSet都会确保全部或部分Node上只运行<strong>归他管理</strong>的【一个】Pod，新增的Node会自动创建一个Pod，删除的Node会自动回收Pod，删除DaemonSet会删除所有其创建的Pod。</li><li><strong>Job</strong>：负责批处理任务，只执行一次，确保正常退出（可配置），没成功会重新创建执行</li><li><strong>CronJob</strong>：通过定时创建Job进行管理Pod，周期性的执行，定时（集群版本&gt;1.8，之前的集群可以通过启动api server时传递：<code>--runtime-config=batch/v2alpha1=true</code>开启)</li><li><strong>StatefullSet</strong>：为了解决<strong>有状态服务</strong>的问题，使用场景： 
  <ul><li>1 稳定持久化存储，重新调度数据部会丢失（基于PVC）；</li><li>2 稳定网络标识，重新调度PodName和HostName不变（基于Headless Service即无集群IP的Service实现）；</li><li>3 有序部署，前一个running和ready才部署下一个（基于init c）；</li><li>4 有序收缩</li><li>5 有序扩展</li></ul> </li></ul> 
<p>HPA：平滑扩展，仅适用于Deployment和RS，在v1中支持根据pod的cpu利用率扩容，后面版本支持根据内存和其他值标扩缩容，通过控制控制器来对Pod进行管理，需要提供一个<strong>资源控制方案</strong>才可以进行控制</p> 
<blockquote> 
 <p>Deployment：<strong>会通过创建RS，达到管理Pod的能力</strong>，滚动更新机制是，创建新的RS，新RS创建新Pod，旧RS删除旧Pod，以此过渡，最终旧RS停用（不删除），回滚时，旧RS启动流程一样<br> HPA：比如通过监听CPU&gt;80，则创建新的pod，直到指定上限，使用率下来后会减少pod，直到下限<br> DaemonSet：常用于在每个Node上都要有一个的服务：1 运行集群存储；2 运行日志收集；3 运行监控<br> CronJob：常用于数据库备份、发送邮件<br> StatefullSet：该控制器对MySQL依然不太稳定，MongoDB比较稳定，适用于稳定持久化存储（基于PVC实现）；稳定网络标识（重新调度后Pod名称和hostname不变），有序收缩和有序扩展等。</p> 
</blockquote> 
<p>对于RS创建出来的Pod，如果选择方式为：matchLabels，那改变创建出来的Pod的label，则RS会重新创建一个原来label的Pod，因为RS按照选择方式去控制Pod数量，被改变的那个Pod则不归RS管了</p> 
<h4><a id="141_RS_77"></a>1.4.1 RS</h4> 
<p>RS测试样例：<br> <img src="https://images2.imgbox.com/20/fd/3FiPZ7Mo_o.png" alt="在这里插入图片描述"><br> 末尾的containerPort可写可不写，因为内部网络所有端口都可以访问，extensions/v1beta1可以改成apps/v1，查看apiVersion可以：<code>kubectl api-resources |grep Deployment</code></p> 
<h4><a id="142_Deployment_81"></a>1.4.2 Deployment</h4> 
<p>Deployment与RS关系：<br> <img src="https://images2.imgbox.com/a6/39/I9gO68wk_o.png" alt="在这里插入图片描述"><br> Deployment测试样例：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>dep
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mynginx
        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
</code></pre> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f deployment-nginx.yaml --record</span>
deployment.apps/nginx-dep created
<span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get deployment</span>
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
nginx-dep   <span class="token number">1</span>/3     <span class="token number">3</span>            <span class="token number">1</span>           15s
<span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get rs</span>
NAME                  DESIRED   CURRENT   READY   AGE
nginx-dep-fbd97f5b7   <span class="token number">3</span>         <span class="token number">3</span>         <span class="token number">1</span>       22s
<span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get pods --show-labels</span>
NAME                        READY   STATUS    RESTARTS   AGE     LABELS
nginx-dep-fbd97f5b7-dg87j   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m37s   <span class="token assign-left variable">name</span><span class="token operator">=</span>nginx,pod-template-hash<span class="token operator">=</span>fbd97f5b7
nginx-dep-fbd97f5b7-fbk6s   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m37s   <span class="token assign-left variable">name</span><span class="token operator">=</span>nginx,pod-template-hash<span class="token operator">=</span>fbd97f5b7
nginx-dep-fbd97f5b7-qkvzw   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m37s   <span class="token assign-left variable">name</span><span class="token operator">=</span>nginx,pod-template-hash<span class="token operator">=</span>fbd97f5b7
<span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get pod -o wide</span>
NAME                        READY   STATUS    RESTARTS   AGE     IP           NODE    NOMINATED NODE   READINESS GATES
nginx-dep-fbd97f5b7-dg87j   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          4m49s   <span class="token number">10.244</span>.2.5   node1   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-dep-fbd97f5b7-fbk6s   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          4m49s   <span class="token number">10.244</span>.2.4   node1   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
nginx-dep-fbd97f5b7-qkvzw   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          4m49s   <span class="token number">10.244</span>.1.2   node2   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
<span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># curl 10.244.2.5</span>
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>style<span class="token operator">&gt;</span>
html <span class="token punctuation">{<!-- --></span> color-scheme: light dark<span class="token punctuation">;</span> <span class="token punctuation">}</span>
body <span class="token punctuation">{<!-- --></span> width: 35em<span class="token punctuation">;</span> margin: <span class="token number">0</span> auto<span class="token punctuation">;</span>
font-family: Tahoma, Verdana, Arial, sans-serif<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token operator">&lt;</span>/style<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>h<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/h<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>
<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.<span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>For online documentation and support please refer to
<span class="token operator">&lt;</span>a <span class="token assign-left variable">href</span><span class="token operator">=</span><span class="token string">"http://nginx.org/"</span><span class="token operator">&gt;</span>nginx.org<span class="token operator">&lt;</span>/a<span class="token operator">&gt;</span>.<span class="token operator">&lt;</span>br/<span class="token operator">&gt;</span>
Commercial support is available at
<span class="token operator">&lt;</span>a <span class="token assign-left variable">href</span><span class="token operator">=</span><span class="token string">"http://nginx.com/"</span><span class="token operator">&gt;</span>nginx.com<span class="token operator">&lt;</span>/a<span class="token operator">&gt;</span>.<span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token operator">&lt;</span>em<span class="token operator">&gt;</span>Thank you <span class="token keyword">for</span> using nginx.<span class="token operator">&lt;</span>/em<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span>

</code></pre> 
<p>Deployment扩容：<code>kubectl scale deployment 名称 --replicas=数量</code></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl scale deployment nginx-dep --replicas=10</span>
deployment.apps/nginx-dep scaled
<span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get pod</span>
NAME                        READY   STATUS    RESTARTS   AGE
nginx-dep-fbd97f5b7-2shcs   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          94s
nginx-dep-fbd97f5b7-cbws9   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          94s
nginx-dep-fbd97f5b7-dg87j   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          16m
nginx-dep-fbd97f5b7-fbk6s   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          16m
nginx-dep-fbd97f5b7-kxtks   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          94s
nginx-dep-fbd97f5b7-qkvzw   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          16m
nginx-dep-fbd97f5b7-qskjr   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          94s
nginx-dep-fbd97f5b7-wt59c   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          94s
nginx-dep-fbd97f5b7-wzfdz   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          94s
nginx-dep-fbd97f5b7-xjfrr   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          94s
</code></pre> 
<p>Deployment滚动更新：<code>kubectl set image deployment/nginx-dep mynginx=nginx:1.23</code></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl set image deployment/nginx-dep mynginx=nginx:1.23</span>
deployment.apps/nginx-dep image updated
<span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get rs</span>
NAME                   DESIRED   CURRENT   READY   AGE
nginx-dep-7f4688fd7f   <span class="token number">5</span>         <span class="token number">5</span>         <span class="token number">0</span>       39s
nginx-dep-fbd97f5b7    <span class="token number">8</span>         <span class="token number">8</span>         <span class="token number">8</span>       32m
</code></pre> 
<p>注意：</p> 
<ul><li>Deployment更新时，可以保证在期望值中，最多比不可用期望多一个不可用，最多比可用期望多出一个可用的</li><li>如果在一次更新中，更新前，原来的的Pod副本还未创建齐全，会直接kill掉已有的，直接创建新的！<br> 一般来说一次会25%的Pod数量替换</li></ul> 
<p>Deployment回滚：<code>kubectl rollout undo deployment/nginx-dep</code></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl rollout undo deployment/nginx-dep</span>
deployment.apps/nginx-dep rolled back
</code></pre> 
<p>查看当前Deployment回滚状态：<code>kubectl rollout status deployment/nginx-dep</code><br> 查看当前Deployment回滚历史：<code>kubectl rollout history deployment/nginx-dep</code>，此处如果在创建Deployment时没有加参数<code>--record</code>则回滚方式为NONE<br> 指定回退版本：<code>kubectl rollout undo deployment/nginx-dep --to-revision=2</code><br> 暂停更新：<code>kubectl rollout pause deployment/nginx-dep</code></p> 
<p>Deployment更新历史记录保留策略<br> 可以通过<code>.spec.revisionHistoryLimit</code>来指定保留多少次记录，默认会保留所有，如果设置为0则不允许回退（因为没有历史记录了）</p> 
<blockquote> 
 <p>查看上一条命令的执行结果，0表示成功<br> <code>echo $?</code></p> 
</blockquote> 
<h4><a id="143_DaemonSet_198"></a>1.4.3 DaemonSet</h4> 
<p><img src="https://images2.imgbox.com/49/5c/l0e1BZYr_o.png" alt="在这里插入图片描述"><br> 需要注意的是：虽然daemonset会在所有的节点上创建pod，但是不会在主节点上创建，因为主节点被默认打了污点，不会参与调度</p> 
<h4><a id="144_Job__CronJob_202"></a>1.4.4 Job &amp; CronJob</h4> 
<p><img src="https://images2.imgbox.com/81/44/Q45hx6Aq_o.png" alt="在这里插入图片描述"><br> 查看pod的控制台显示日志：<code>kubectl log Pod名称</code></p> 
<p><strong>Job Spec设置</strong></p> 
<ul><li>spec.template 和其他Pod一样</li><li>RestartPolicy只支持Never or OnFailure</li><li>单个Pod时，运行成功Job结束</li><li>spec.completions 标志Job结束需要成功几个Pod，默认为1</li><li>spec.parallelism 标志并行运行Pod，默认为1</li><li>spec.activeDeadlineSeconds 标志失败Pod最大重试时间，超过则停止重试</li></ul> 
<p><strong>CronJob Spec</strong></p> 
<ul><li>spec.schedule 必填，指定运行周期，分时日月周</li><li>spec.jobTemplate 必填，同Job</li><li>spec.startingDeadlineSeconds 该字段指定如果在指定时间范围内，由于原因导致该job没有被执行，错过了调度时间，则被认为是失败</li><li>spec.concurrencyPolicy 并发策略：（只控制当前CronJob，别的CronJob创建的不影响） 
  <ul><li>Allow 允许</li><li>Forbid 禁止，前一个没运行完，下一个跳过</li><li>Replace 替换，取消当前，用新的替换</li></ul> </li><li>spec.suspend 如果改成true，则后续的Job会挂起，之前的不影响</li><li>spec.successfulJobsHistoryLimit 成功保留历史数，默认3个Job，0表示不保留</li><li>spec.failedJobsHistoryLimit 失败保留数，默认1个，0表示不保留</li></ul> 
<p><img src="https://images2.imgbox.com/9f/a4/syDCzy8N_o.png" alt="在这里插入图片描述"><br> 注意：删除cronjob不会删除job，需要手动删除job，且cronjob无法判断job是否成功执行</p> 
<h4><a id="145_StatefulSet_228"></a>1.4.5 StatefulSet</h4> 
<p>创建的Pod的名称为：<code>statefulset名称-序号</code>，如statefulset名称为web，则Pod名称为<code>web-0</code>，<code>web-1</code><br> StatefulSet为每个管辖下的Pod创建了一个DNS域名，格式为：<code>Pod名称.无头服务名称</code>，服务提供是通过域名而非IP，因为Pod所属Node故障时会发生漂移，IP会改变，但是域名不变</p> 
<p>statefulset使用headless svc来控制Pod域名，svc域名为：<code>svc名称.命名空间.svc.cluster.local</code>，其中<code>cluster.local</code>指集群域名</p> 
<h3><a id="15_service_233"></a>1.5 service服务发现</h3> 
<p>通常对于多个副本的Pod提供一种服务的，k8s方案是在Pod上层提供一个service层，用于管理该服务，然后对外或其他Pod提供访问方式，简单来说，可以将提供一个服务的一组Pod加上service 层，看成一个服务去访问，这就是服务发现，用于管理集群中的服务</p> 
<p>在创建一个SVC时，过程如下：</p> 
<ol><li>apiserver接受创建指令，将请求写入etcd</li><li>kube-proxy监听etcd中SVC和Pod信息变化，将新增的SVC地址和转发Pod规则写入iptables中</li><li>访问某个Pod时，通过iptables直接流量转发到目的Pod上<br> 最终看起来就是：访问svc然后转发到对应pod</li></ol> 
<p>通常采用Label Selector进行管理Pod，匹配到标签后，Pod的信息会被写入到svc中，对外提供访问，策略是轮询</p> 
<p>注意：SVC虽然能提供轮询的负载均衡机制，但是只能基于IP和端口进行转发，也就是4层负载均衡能力（没有7层，不能通过主机名或域名的方案去做），可以使用Ingress来支持7层</p> 
<p>SVC有四种类型：</p> 
<ul><li>ClusterIP：默认，自动分配一个集群内部可访问的虚拟网IP（VIP）</li><li>Nodeport：在ClusterIP基础上为SVC在每个机器（Node）上绑定一个端口，这样可以通过NodeIP:NodePort来访问服务（增加一个Nginx反向代理到Node可以实现7层负载均衡）user-&gt;nginx-&gt;svc-&gt;pod</li><li>LoadBalancer：在NodePort基础上借助云供应商创建外部负载均衡转发到NodePort上</li><li>ExternalName：Pod访问外部是直接访问，如果外部服务IP、Port改变会影响服务，所以将外部的服务在集群内部建立一个SVC，用于记录外部服务的IP和端口，内部集群访问外部时去这个SVC上查询（相当于做了一个配置），外部改变时，只需要重新配置这个SVC，不用每个Pod都去改</li></ul> 
<p><img src="https://images2.imgbox.com/d7/44/yIBDVAPf_o.png" alt="在这里插入图片描述"><br> 首先kube-proxy会监控每个Pod的信息，按照标签分类将信息写入iptables中<br> apiserver通过监控kube-proxy来实现服务的发现<br> 在用户访问某个服务时，访问的是iptables，重定向到某个Pod完成访问</p> 
<blockquote> 
 <p>k8s在1.14版本中默认使用ipvs代理<br> 为什么不实用DNS进行负载均衡？因为DNS有缓存，不会及时更新</p> 
</blockquote> 
<p>代理模式分类：</p> 
<ol><li>userspace：Pod_x-&gt;iptables-&gt;kube-proxy-&gt;SVC-&gt;Pod_y</li><li>iptables：Pod_x-&gt;iptables-&gt;SVC-&gt;Pod_y，去掉了kube-proxy的中间代理</li><li>ipvs：用ipvs代替了iptables，因为iptables插入数据过多性能不佳，ipvs实现了snat，借助iptables又实现了dnat</li></ol> 
<blockquote> 
 <p>ipvs和iptables都是防火墙配置工具，ipvs支持dnat</p> 
</blockquote> 
<h4><a id="151_ipvs_267"></a>1.5.1 ipvs代理模式</h4> 
<p>kube-proxy监控SVC和Endpoints，调用netlink接口创建ipvs规则，并与SVC和Endpoints同步ipvs规则</p> 
<p>ipvs使用哈希表作为底层数据结构，并在内核空间工作，可以更快的重定向流量，同步时也有更好的性能，支持多重负载均衡算法：</p> 
<ul><li>rr 轮询</li><li>lc 最小链接</li><li>dh 目标哈希</li><li>sh 源哈希</li><li>sed 最短期望延迟</li><li>nq 不排队调度</li></ul> 
<p>注意：ipvs模式要求kube-proxy启动前，节点需要安装ipvs内核模块，并已ipvs代理模式启动，启动时如果验证节点未安装ipvs，kube-proxy会退回到iptables代理模式</p> 
<h4><a id="152_Service_280"></a>1.5.2 Service实验</h4> 
<p>先创建Deployment，副本数3：<br> <img src="https://images2.imgbox.com/ee/e3/FkrVuDj2_o.png" alt="在这里插入图片描述"><br> 创建Service：<br> <img src="https://images2.imgbox.com/b1/ea/5KSnzVpQ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>kubectl delete -f 文件<br> 可以通过这种方式去删除对应的资源（由该文件创建出来的）</p> 
</blockquote> 
<p>headless service：<br> <img src="https://images2.imgbox.com/f2/28/zk7QlJ9O_o.png" alt="在这里插入图片描述"><br> 此时该service无法通过vip的方式进行访问，但是可以通过域名访问，通过查看coredns域名解析pod的解析，可以看到该service下确实管理着之前创建的Pod</p> 
<p>NodePort：<br> <img src="https://images2.imgbox.com/5d/6f/tIF3veRW_o.png" alt="在这里插入图片描述"><br> 查询结果：<code>kubectl get svc</code>可以看到将80端口代理到了node的xxx端口，通过访问node的xxx端口即可访问Pod</p> 
<p>LoadBalancer<br> 和nodeport类似，只是在前面多了一层云服务商提供的负载均衡服务，由k8s的provider cloud去创建的LB，需要购买云服务商提供的LAAS服务<br> <img src="https://images2.imgbox.com/f3/4a/WJKWYpzB_o.png" alt="在这里插入图片描述"><br> externalname<br> <img src="https://images2.imgbox.com/75/c5/J34MZQcF_o.png" alt="在这里插入图片描述"><br> 此时访问域名：<code>SVC名称.命名空间.svc.cluster.local</code>，会被集群内部DNS重定向到<code>externalName</code>指定的域名上，发生在DNS层，不会进行代理和转发（简单理解就是做了一个DNS的别名操作）</p> 
<h4><a id="153_Ingress_302"></a>1.5.3 Ingress</h4> 
<p>案例背景：如果对外需要提供一个HTTPS的连接，SVC是没有这个功能的，只能在每个Pod上都要配置HTTPS连接才行<br> 而如果在集群外部配置一个Nginx，Nginx对外可以采用HTTPS连接，对内反向代理采用HTTP连接，这样就可以实现了。（但是外部Nginx和集群是HTTP，所以其实还是有一定风险的）<br> 因此，最优方案是：外部访问集群使用的HTTPS，集群内部提供一个Nginx去做反向代理到不同的SVC，Ingress就是做这样的事。<br> 注意：为什么不自己在内部部署一个nginx服务去做这个呢，因为ingress的nginx配置文件是会自动生成对应的SVC反向代理，无需手动配置。<br> Ingress内部逻辑：<br> <img src="https://images2.imgbox.com/54/a4/eCKaIm25_o.png" alt="在这里插入图片描述"><br> 如果需要高可用，建议将master做主备，然后再在外部使用Nginx做负载均衡连接两台master，master内部通过ingress-nginx做内部的Pod的负载均衡</p> 
<p><strong>部署Ingress-Nginx</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># 启动ingress 控制器</span>
kubectl apply <span class="token parameter variable">-f</span> mandatory.yaml
<span class="token comment"># 设置为nodeport暴露方式</span>
kubectl apply <span class="token parameter variable">-f</span> service-nodeport.yaml
</code></pre> 
<p>参考：https://kubernetes.github.io/ingress-nginx/deploy</p> 
<p><strong>Ingress HTTP访问</strong><br> deployment service ingress 配置</p> 
<pre><code class="prism language-bash">apiVersion: extension/v1beta1
kind: Deployment
metadata:
  name: nginx-dm
spec:
  replicas: <span class="token number">2</span>
  template:
    metadata:
      labels:
        name: nginx
    spec:
      containers:
        - name: nginx
          image: xxxx/myapp:v1
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: <span class="token number">80</span>
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
spec:
  port:
    - port: <span class="token number">80</span>
      targetPort: <span class="token number">80</span>
      protocol: TCP
  selector:
    name: nginx
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: nginx-test
spec:
  rules:
    - host: foo.bar.com
      http:
        paths:
          - path: /
            backend:
              serviceName: nginx-svc
              servicePort: <span class="token number">80</span>
</code></pre> 
<p>执行：<code>kubeclt apply -f ingress.http.yaml</code></p> 
<pre><code class="prism language-bash"><span class="token comment"># 查看当前创建的svc</span>
kubectl get svc <span class="token comment"># 可以直接访问下集群的svc地址获取服务</span>

<span class="token comment"># 查询当前ingress在宿主机上暴露出去的端口</span>
kubectl get svc <span class="token parameter variable">-n</span> ingress-nginx

<span class="token comment"># 查看当前的ingress</span>
kubectl get ingress
</code></pre> 
<p>此时当前NodePort模式暴露后，可以在主机上配置好DNS访问：<code>nodeIP foo.bar.com</code><br> 宿主机上访问：<code>foo.bar.com:ingress暴露的端口</code></p> 
<blockquote> 
 <p>宿主机访问域名，其实相当于访问nodeport的ip，然后ingress暴露了端口给nodeport，所以外部可以通过这个端口访问到ingress，而ingress代理访问了内部svc的端口和地址，svc又可以访问到pod，服务就联通了<br> 与直接使用svc比，ingress还可以通过不同路径来访问不通服务，svc必须通过不通的域名或者ip来访问不同服务</p> 
</blockquote> 
<p><strong>ingress HTTPS访问</strong><br> 首先需要创建证书：</p> 
<pre><code class="prism language-bash">openssl req <span class="token parameter variable">-x509</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-nodes</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-newkey</span> rsa:2048 <span class="token parameter variable">-keyout</span> tls.key <span class="token parameter variable">-out</span> tls.crt <span class="token parameter variable">-subj</span> <span class="token string">"/CN=nginxsvc/O=nginxsvc"</span>

kubectl create secret tls tls-secret <span class="token parameter variable">--key</span> tls.key <span class="token parameter variable">--cert</span> tls.crt
</code></pre> 
<p>创建ingress：</p> 
<pre><code class="prism language-yml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>test
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">tls</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> foo.bar.com
        <span class="token key atrule">secretName</span><span class="token punctuation">:</span> tls<span class="token punctuation">-</span>secret
  <span class="token key atrule">rules</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> foo.bar.com
      <span class="token key atrule">http</span><span class="token punctuation">:</span>
        <span class="token key atrule">path</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /
            <span class="token key atrule">backend</span><span class="token punctuation">:</span>
              <span class="token key atrule">seviceName</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>svc
              <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre> 
<p><strong>Nginx BasicAuth</strong><br> 对Nginx进行基础授权认证，在进入网站时弹出用户名和密码框</p> 
<pre><code class="prism language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> httpd
htpasswd <span class="token parameter variable">-c</span> 文件名 用户名
kubectl create secret generic basic-auth --from-file<span class="token operator">=</span>文件名
</code></pre> 
<p>这里使用文件名：auth，用户名：foo</p> 
<pre><code class="prism language-yml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/b1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>with<span class="token punctuation">-</span>auth
  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>
    <span class="token key atrule">nginx.ingress.kubernetes.io/auth-type</span><span class="token punctuation">:</span> basic
    <span class="token key atrule">nginx.ingress.kubernetes.io/auth-secret</span><span class="token punctuation">:</span> basic<span class="token punctuation">-</span>auth
    <span class="token key atrule">nginx.ingress.kubernetes.io/auth-realm</span><span class="token punctuation">:</span> <span class="token string">'Authentication Required - foo'</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">rules</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> foo2.bar.com
      <span class="token key atrule">http</span><span class="token punctuation">:</span>
        <span class="token key atrule">path</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /
            <span class="token key atrule">backend</span><span class="token punctuation">:</span>
              <span class="token key atrule">seviceName</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>svc
              <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre> 
<p><strong>Nginx 重写</strong><br> <img src="https://images2.imgbox.com/17/d7/sxsogpCf_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: nginx-test
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: http://foo.bar.com:31795/hostname.html
spec:
  rules:
    - host: foo10.bar.com
      http:
        path:
          - path: /
            backend:
              seviceName: nginx-svc
              servicePort: <span class="token number">80</span>

</code></pre> 
<h3><a id="16__463"></a>1.6 网络空间</h3> 
<p>k8s模型是假定所有Pod都在一个可以直接连通的扁平化的网络空间中，所以，搭建集群时，我们必须确保不同节点上的Docker互相打通。（flannel可以实现扁平网络空间）</p> 
<p><strong>网络通讯示意图</strong><br> <img src="https://images2.imgbox.com/01/94/Ncudydfi_o.jpg" alt="在这里插入图片描述"></p> 
<p>同一个Pod内的多个容器之间的通讯：lo（本地回路localhost，即docker0组成的虚拟网桥）<br> Pod之间的通讯：Overlay Network<br> Pod与Service通讯：各节点的Iptables规则（建议使用LVS，性能更好）<br> Pod与外网访问：通过查找路由表，转发到宿主几网卡，然后网卡执行Masquerade，将源IP改为宿主机IP，向外部发送请求（SNAT）<br> 外网与Pod访问：通过Service</p> 
<p>Etcd和Flannel之间的关系：</p> 
<ul><li>存储管理flannel可分配地址段资源</li><li>监控Etcd中每个Pod实际地址，并建立Pod节点路由表</li></ul> 
<blockquote> 
 <p>Flannel：CoreOS团队创建，让集群不同Node上的Docker有集群唯一IP，且创建一个Overlay Network，让数据包可以原封不动的从一个容器传送到另一个容器内<br> <img src="https://images2.imgbox.com/d1/59/xYxttw6S_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="17__482"></a>1.7 资源</h3> 
<p>k8s中所有内容都被抽象为资源，资源实例化后，叫做对象</p> 
<p><strong>名称空间级别</strong><br> 工作负载类型资源：Pod、RS、Deployment、StatefulSet、DaemonSet、Job、CronJob<br> 服务发现及负载均衡类型资源：Service、Ingress<br> 配置与存储资源：Volume、CSI（容器存储接口，可扩展第三方卷存储）<br> 特殊类型存储娟：ConfigMap（当配置中心来使用）、Secret（保护敏感数据）、DownwardAPI（把外部信息输出给容器）</p> 
<p><strong>集群级别</strong><br> Namespace<br> Node<br> Role<br> ClusterRole<br> RoleBinding<br> ClusterRoleBinding</p> 
<p><strong>元数据级别</strong><br> HAP<br> PodTemplate<br> LimitRange</p> 
<blockquote> 
 <p>YAML文件语法tips<br> 对象类型可以写成：hash: { name: pp, age: 18 }<br> 或</p> 
 <pre><code class="prism language-yml"><span class="token key atrule">hash</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pp
  <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span>
</code></pre> 
 <p>数组类型可以写成：animal: [Cat, Dog]<br> 或</p> 
 <pre><code class="prism language-yml"><span class="token key atrule">animal</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> Cat
<span class="token punctuation">-</span> Dog
</code></pre> 
 <p>类型强制转换：!!类型</p> 
 <pre><code class="prism language-yml"><span class="token key atrule">a</span><span class="token punctuation">:</span> <span class="token tag">!!str</span> <span class="token number">123</span>
<span class="token key atrule">b</span><span class="token punctuation">:</span> <span class="token tag">!!str</span> <span class="token boolean important">true</span>
</code></pre> 
 <p>类型：<br> 字符串：可以不用引号，但如果有特殊字符需要放在引号中，且双引号不会对特殊字符转义，单引号中如果还有单引号必须使用两个单引号来表示</p> 
</blockquote> 
<p>k8s定义一个Pod所需yml配置文件的必填字段类型及含义：<br> <img src="https://images2.imgbox.com/26/2d/uCcbT8H0_o.png" alt="在这里插入图片描述"></p> 
<p>重要的一些参数：<br> <img src="https://images2.imgbox.com/ec/b1/fUEHSJ1V_o.png" alt="在这里插入图片描述"><br> 此处提供一个Pod模板供参考：</p> 
<pre><code class="prism language-yml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp
    <span class="token key atrule">version</span><span class="token punctuation">:</span> v1
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> app
    <span class="token key atrule">image</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span>5000/xiaopi3/httpd<span class="token punctuation">:</span>v1
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test
    <span class="token key atrule">image</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span>5000/xiaopi3/httpd<span class="token punctuation">:</span>v1
</code></pre> 
<p>注意：如果镜像下载策略为默认的即always，且镜像没有版本号或版本号为latest，则容器每次都会拉取最新镜像进行下载</p> 
<h3><a id="18__550"></a>1.8 容器生命周期</h3> 
<p><img src="https://images2.imgbox.com/68/91/wK3tu9Yo_o.png" alt="在这里插入图片描述"><br> 在容器启动前有很多initC容器进行容器环境初始化<br> 有很多探测，在生命周期中会进行检测<br> start：容器启动<br> readiness：容器就绪，可提供服务了<br> liveness：容器生存<br> stop：容器停止</p> 
<p><strong>init容器</strong><br> 与普通容器很像，必须运行到成功为止，且串行，前一个必须成功才会运行后一个，如果没有成功运行，则pod会重启，直到成功。如果pod对应restartPolicy策略为Never，则不会重启</p> 
<ul><li>将主容器的运行环境准备好（如安装工具、配置文件），放在init C中，用于主容器运行前的环境初始化</li><li>init C可以赋予和主容器不同的权限，如可以访问到更机密的文件用于创建环境，而不用给主容器该权限</li><li>init C有启动顺序，且串行，不同于主容器的并行，所以可以执行一些有前提的程序，直到满足条件才启动主容器</li></ul> 
<blockquote> 
 <p>简单理解：A容器需要访问B容器才能启动，如果AB同时启动，有可能导致A容器启动失败（B并未ready），可以在A容器启动前加入【探测B容器是否正常运行的探测程序】作为init C，然后启动AB即可</p> 
</blockquote> 
<p>init模板<br> <img src="https://images2.imgbox.com/e4/e5/3OmJjf2F_o.png" alt="在这里插入图片描述"><br> 启动两个init C，直到两个都成功结束才会运行主容器，此处必须启动下面这个两个pod才能让init C检测通过（成功运行的含义是容器退出代码为0）<br> <img src="https://images2.imgbox.com/8b/ac/tN0TvX3D_o.png" alt="在这里插入图片描述"><br> 需要注意的是：</p> 
<ol><li>Pod在启动过程中，最先启动的是pause容器，初始化网络和数据卷，然后再启动init C，最后启动主容器</li><li>init C会采用Pod的重启策略restartpolicy</li><li>init C执行过程中，Pod状态为Pending，执行完毕，Pod才会变成Ready，在这之前，Service中都不会收集该Pod的端口</li><li>Pod重启，init C需要重新执行</li><li>对正在运行的Pod进行edit，如果修改init容器的image字段，则整个Pod会重新启动</li><li>init C和主容器所具有的字段一样，除了readinessProbe字段没有</li><li>init C名字要在当前Pod中唯一，端口可重复</li></ol> 
<h4><a id="181_hook_579"></a>1.8.1 容器hook</h4> 
<p><strong>容器探针</strong><br> 由kubelet对容器发起定期诊断，有三种探测方式：</p> 
<ul><li>ExecAction：在容器中执行命令，返回0则成功</li><li>TCPSocketAction：对指定端口上的容器的IP地址进行TCP检查，如果端口打开则成功</li><li>HTTPGetAction：对指定端口和容器IP执行HTTPGET请求，响应码&gt;=200 &lt;400，则成功</li></ul> 
<p>注意：诊断结果有三种：成功、失败、未知。未知不会采取任何行动</p> 
<p>探测策略有两种：</p> 
<ol><li>livenessProbe：指示容器正在运行，如果探测失败，kubelet会kill容器，如果容器不提供存活探针，则默认状态为success，容器指示RUNNING状态</li><li>readinessProbe：指示容器是否准备好提供服务，如果失败，【端点控制器】会将与Pod匹配的所有Service的端点中删除该Pod的IP，在初始延迟前状态默认为Failure，如果容器不提供就绪探针，默认为success，容器指示Ready状态</li></ol> 
<p>注意：两种检测策略可以同时存在</p> 
<p><img src="https://images2.imgbox.com/de/45/UOzdwwPa_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b0/df/jBluINun_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f6/ce/A2eUCijy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/54/86/N75W2kgi_o.png" alt="在这里插入图片描述"><br> <strong>生命周期hook</strong><br> <img src="https://images2.imgbox.com/a3/fd/cSUHfnVe_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="182_Pod_602"></a>1.8.2 Pod状态含义</h4> 
<ol><li>Pending：Pod被集群控制中，但有容器还在创建中，或者镜像下载中</li><li>Running：Pod已经绑定到节点了，所有容器都被创建了，至少有一个容器在运行或者处于启动或者重启状态</li><li>Succeeded：Pod中所有容器都已终止，全部正常结束，且不会再重启</li><li>Failed：Pod中所有容器都已终止，且存在容器失败终止的情况</li><li>未知：无法取得Pod状态，通常网络问题</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2b91fd5ddb1075c9866fe84fb431354a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Qt的布局</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b40a6d91e6fbd500ac76e5d6c3eb2666/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端element的el-tooltip鼠标经过显示文字，没有文字显示空黑框问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>