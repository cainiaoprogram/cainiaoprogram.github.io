<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>经典调度问题：读者优先/写者优先算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="经典调度问题：读者优先/写者优先算法" />
<meta property="og:description" content=" 文章目录 算法介绍读者优先:写者优先:多线程编程注意事项写者优先算法流程图 算法介绍 创建一个包含n 个线程的控制台进程。用这n 个线程来表示n个读者或写者。每个线程按相应测试数据文件的要求，进行读写操作。请用信号量机制分别实现读者优先和写者优先的读者-写者问题。
读者优先：如果一个读者申请进行读操作时已有另一读者正在进行读操作，则该读者可直接开始读操作。
写者优先：如果一个读者申请进行读操作时已有另一写者在等待访问共享资源，则该读者必须等到没有写者处于等待状态后才能开始读操作。
首先要明白在多线程编程中的互斥关系: 读写互斥和写写互斥.两个优先方式都遵循这个出发点.在满足以上条件的情况下,进来的线程都好像是在排队,然后看当前谁优先.自己如果是优先的,那么可以直接插队.再考虑正在执行的是否和自己阻塞,如果正在执行的和自己阻塞,那自己也得排队,只不过排在前面.(类似写者优先的写写线程),如果正在执行的和自己不是阻塞的,那么自己就可以直接进去执行(读者优先的读读进程).如果自己不是优先的,那么自己只能老老实实的排队,就算自己前面有和自己不互斥的线程执行也不行.类似写者优先中读线程在执行,新的写进程等待资源,更新的读线程只能等写进程释放,如果有新的写进程进来,还可以排在这个读线程前面. 读者优先: 读者就是优先的。假设a，b都是同时请求，但是a是读者那么a优先使用资源，还有一点很重要的就是读者优先的读者可以并行执行。而写着只能单线程执行。在执行过程中，只要阻塞的写者在等待过程中有新的读者进来那么他要等待所有读者完成才能自己释放自己。
写者优先: 无疑所有写的操作是优先的，这个过程可能会产生大量阻塞，因为相对较快（本来可以并行的读者被大量阻塞）。如果资源中没有写者那么读者依然可以并行，但是一旦出现写者在等待读者资源，那么新的读者就不能在并行执行，要等待所有写者执行完毕才可执行读者。
多线程编程注意事项 读者优先和写者优先是两个不同的策略方法，方法有相似之处但是也有很大不同，函数需要分开完成。最主要的排序方式基于时间排序，次要的排序以读者还是写者谁优先为准则读者优先或者写者优先的阻塞会导致线程开始时间的变化。而不过采用双队列一个存进入时间的排序，一个存结束时间的排序，修改其中的一个会影响另一个队列中元素值不错，但是如果不对另一个队列进行增/删是不会触发堆排序的功能（挺重要的）。可能有些阻塞时候的等待时间和开始时间改变处理比较复杂，要考虑当前是读致使阻塞，还是写致使阻塞，还是前面有写的资源再等待致使阻塞。要用多个变量维系系统使得正确的更改线程的阻塞时间。 写者优先算法流程图 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/339db6ca4dffd1e73bae763567412ab1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-19T10:15:29+08:00" />
<meta property="article:modified_time" content="2019-09-19T10:15:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">经典调度问题：读者优先/写者优先算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">算法介绍</a></li><li><a href="#_11" rel="nofollow">读者优先:</a></li><li><a href="#_16" rel="nofollow">写者优先:</a></li><li><a href="#_21" rel="nofollow">多线程编程注意事项</a></li><li><a href="#_27" rel="nofollow">写者优先算法流程图</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>算法介绍</h3> 
<p>创建一个包含n 个线程的控制台进程。用这n 个线程来表示n个读者或写者。每个线程按相应测试数据文件的要求，进行读写操作。请用信号量机制分别实现读者优先和写者优先的读者-写者问题。<br> 读者优先：如果一个读者申请进行读操作时已有另一读者正在进行读操作，则该读者可直接开始读操作。<br> 写者优先：如果一个读者申请进行读操作时已有另一写者在等待访问共享资源，则该读者必须等到没有写者处于等待状态后才能开始读操作。</p> 
<ul><li>首先要明白在多线程编程中的互斥关系: 读写互斥和写写互斥.两个优先方式都遵循这个出发点.</li><li>在满足以上条件的情况下,进来的线程都好像是在排队,然后看当前谁优先.</li><li>自己如果是优先的,那么可以直接插队.再考虑正在执行的是否和自己阻塞,如果正在执行的和自己阻塞,那自己也得排队,只不过排在前面.(类似写者优先的写写线程),如果正在执行的和自己不是阻塞的,那么自己就可以直接进去执行(读者优先的读读进程).</li><li>如果自己不是优先的,那么自己只能老老实实的排队,就算自己前面有和自己不互斥的线程执行也不行.类似<strong>写者优先</strong>中<strong>读线程在执行,新的写进程等待资源,更新的读线程只能等写进程释放,如果有新的写进程进来,还可以排在这个读线程前面</strong>.</li></ul> 
<h3><a id="_11"></a>读者优先:</h3> 
<blockquote> 
 <p>读者就是优先的。假设a，b都是同时请求，但是a是读者那么a优先使用资源，还有一点很重要的就是读者优先的读者可以并行执行。而写着只能单线程执行。在执行过程中，只要阻塞的写者在等待过程中有新的读者进来那么他要等待所有读者完成才能自己释放自己。<br> <img src="https://images2.imgbox.com/32/0c/471vh7yJ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_16"></a>写者优先:</h3> 
<blockquote> 
 <p>无疑所有写的操作是优先的，这个过程可能会产生大量阻塞，因为相对较快（本来可以并行的读者被大量阻塞）。如果资源中没有写者那么读者依然可以并行，但是一旦出现写者在等待读者资源，那么新的读者就不能在并行执行，要等待所有写者执行完毕才可执行读者。<br> <img src="https://images2.imgbox.com/69/26/ehTvT3uE_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_21"></a>多线程编程注意事项</h3> 
<ol><li>读者优先和写者优先是两个不同的策略方法，方法有相似之处但是也有很大不同，函数需要分开完成。</li><li>最主要的排序方式基于时间排序，次要的排序以读者还是写者谁优先为准则</li><li>读者优先或者写者优先的阻塞会导致线程开始时间的变化。而不过采用双队列一个存进入时间的排序，一个存结束时间的排序，修改其中的一个会影响另一个队列中元素值不错，但是如果不对另一个队列进行增/删是不会触发堆排序的功能（挺重要的）。</li><li>可能有些阻塞时候的等待时间和开始时间改变处理比较复杂，要考虑当前是读致使阻塞，还是写致使阻塞，还是前面有写的资源再等待致使阻塞。要用多个变量维系系统使得正确的更改线程的阻塞时间。</li></ol> 
<h3><a id="_27"></a>写者优先算法流程图</h3> 
<p><img src="https://images2.imgbox.com/2d/02/4qQQwApA_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2b9bfbe752932a8c04706765def42380/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">6大思维模型, 揭秘硅谷高管如何做区块链应用决策</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/68782a8a5e284453f854ce2bb97570db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">golang 数据库操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>