<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中的“引用”详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中的“引用”详解" />
<meta property="og:description" content="前言：在面向对象的程序设计语言中，我们经常听见一些名词，引用，地址，在函数传递参数的时候，我们又经常说值传递，引用传递，最容易让人搞混淆的就是“引用”和“地址”这两个概念了，对于C&#43;&#43;和C#来说，引用一词从他们所呈现的表象来看的确很类似，但是本质实际上是不一样的，
C&#43;&#43;：引用就是一个变量的别名；
C#：引用可以用指针去理解，虽然C#没有指针，我们经常说某个变量所引用的数据，可以理解为某个变量所指向的数据。
一、先从C语言的交换两个变量说起 C语言中：函数传参有传值和传址两种方式
用swap函数举例：
1.1 传值方式（创建了临时变量存放实参的值）
缺点：不能通过函数形参改变外部实参
优点：不能改变外部的实参
void swap(int left,int right)//此代码不能完成两数的交换 { int tmp = left; left = right; right = tmp; } 2.传址方式（创建了临时变量存放了实参的地址）
缺点：每次访问实参都要解引用
优点：可以改变外部实参
void swap(int* left,int* right) { int tmp = *left; *left = *right; *right = tmp; } 而C&#43;&#43;中就引入了引用的概念，下面详细介绍一下C&#43;&#43;中的引用
上面的代码就可以写成这样
此时代码中的left和right就是实参的别名，通过交换left和right就能将传过来的实参进行交换。
void swap(int&amp; left,int&amp; right) { int tmp = left; left = right; right = tmp; } 总结：C&#43;&#43;通过引用就可以达到C语言的指针作为参数的效果。
二、引用的简单概念 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。
定义引用类型的格式：
类型 &amp; 引用变量名(对象名) = 引用实体；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/daaadcd4bf2abdd463d1b3a21dc9ee35/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-22T11:45:06+08:00" />
<meta property="article:modified_time" content="2019-11-22T11:45:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中的“引用”详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" class="has" src="https://images2.imgbox.com/ff/e9/8NkE0A0C_o.png"></p> 
<p><strong><span style="color:#f33b45;">前言：</span></strong>在面向对象的程序设计语言中，我们经常听见一些名词，引用，地址，在函数传递参数的时候，我们又经常说值传递，引用传递，最容易让人搞混淆的就是“引用”和“地址”这两个概念了，对于C++和C#来说，引用一词从他们所呈现的表象来看的确很类似，但是本质实际上是不一样的，</p> 
<blockquote> 
 <p><strong>C++：</strong>引用就是一个变量的别名；</p> 
 <p><strong>C#：</strong>引用可以用指针去理解，虽然C#没有指针，我们经常说某个变量所引用的数据，可以理解为某个变量所指向的数据。</p> 
</blockquote> 
<h3><span style="color:#f33b45;">一、先从C语言的交换两个变量说起</span></h3> 
<p>C语言中：函数传参有传值和传址两种方式<br> 用swap函数举例：</p> 
<p><br><strong>1.1 传值方式（创建了临时变量存放实参的值）</strong><br> 缺点：不能通过函数形参改变外部实参<br> 优点：不能改变外部的实参</p> 
<pre class="has"><code class="language-cpp">void swap(int left,int right)//此代码不能完成两数的交换
{
    int tmp = left;
    left = right;
    right = tmp;
} 
</code></pre> 
<p><strong>2.传址方式（创建了临时变量存放了实参的地址）</strong></p> 
<p><br> 缺点：每次访问实参都要解引用<br> 优点：可以改变外部实参</p> 
<pre class="has"><code class="language-cpp">void swap(int* left,int* right)
{
    int tmp = *left;
    *left = *right;
    *right = tmp;
} </code></pre> 
<p>而C++中就引入了引用的概念，下面详细介绍一下C++中的引用<br> 上面的代码就可以写成这样<br> 此时代码中的left和right就是实参的别名，通过交换left和right就能将传过来的实参进行交换。</p> 
<pre class="has"><code class="language-cpp">void swap(int&amp; left,int&amp; right)
{
    int tmp = left;
    left = right;
    right = tmp;
}</code></pre> 
<p><span style="color:#f33b45;"><strong>总结：C++通过引用就可以达到C语言的指针作为参数的效果。</strong></span></p> 
<h3><span style="color:#f33b45;">二、引用的简单概念</span></h3> 
<p><br> 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。</p> 
<p>定义引用类型的格式：</p> 
<blockquote> 
 <p><br><span style="color:#f33b45;"><strong>类型 &amp; 引用变量名(对象名) = 引用实体；</strong></span></p> 
 <p><span style="color:#f33b45;"><strong>注意这里的空格是可选的，即</strong></span></p> 
 <ul><li><span style="color:#f33b45;"><strong>&amp;符号与前后均可以有一个空格；如下：int &amp; ra=a;</strong></span></li><li><span style="color:#f33b45;"><strong>&amp;符号与类型挨着，如下：int&amp; ra=a;</strong></span></li><li><span style="color:#f33b45;"><strong>&amp;符号与引用名称挨着，如下：int &amp;ra=a;</strong></span></li></ul> 
</blockquote> 
<p>到底怎么理解引用只是一个变量的别名呢？其实在生活中别名很好理解，比如 张三 有一个别名叫做  三儿 。那么这两个名称指的实际上就是同一个人，张三干嘛，三儿就在干嘛，两者是一起的，为了说明，我们看一个例子：</p> 
<pre class="has"><code class="language-cpp">int main()
{
	int  a = 100;
	int &amp; ar = a;
	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; ar &lt;&lt; endl;
	cout &lt;&lt; &amp;a &lt;&lt; endl;
	cout &lt;&lt; &amp;a &lt;&lt; endl;

	ar = 200;  //改变引用变量
	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; ar &lt;&lt; endl;
	cout &lt;&lt; &amp;a &lt;&lt; endl;
	cout &lt;&lt; &amp;a &lt;&lt; endl;

	getchar();
	return 0;
}
/*
100
100
012FF77C
012FF77C
200
200
012FF77C
012FF77C
*/</code></pre> 
<p><span style="color:#f33b45;"><strong>2.1  总结引用的特点</strong></span></p> 
<blockquote> 
 <ol><li>引用变量的类型必须与它的实体类型一致（因为取别名要符合引用实体的身份，如果类型不一致则会报错）</li><li>引用变量使用必须要进行初始化（不然没有实体都不知道给谁取别名）</li><li>一个变量可以有多个引用（就相当于一个变量有好几个别名，这是可以的）</li></ol> 
 <pre class="has"><code class="language-cpp">int a = 10;
int&amp; ra = a;
int&amp; rra = ra;  ra,raa都是a的别名</code></pre> 
 <ol><li>引用一旦引用一个实体，再不能引用其他实体（同一个别名不能引用不同的人，否则就分不清谁是谁了）</li><li>引用不是指针，他就是一个变量，仅仅是一个别名；</li></ol> 
</blockquote> 
<p><span style="color:#f33b45;"><strong>总而言之：</strong></span></p> 
<p><span style="color:#f33b45;">引用本身也是一个变量，但是这个变量又仅仅是另外一个变量一个别名，它不占用内存空间，它不是指针哦！不要混淆了，仅仅是一个别名，别名，别名，重要的事情说三遍</span>。</p> 
<p> </p> 
<h3><span style="color:#f33b45;">三、引用的更多使用</span></h3> 
<p><strong>3.1 常引用</strong></p> 
<p>变量可以使变量和常量，别名本质上也是变量，也可以是变量或者是常量，所以对应起来有四种情况，分别如下：</p> 
<p><strong><span style="color:#f33b45;">（1）变引用——变量</span></strong></p> 
<pre class="has"><code class="language-cpp">int a = 10;   //可读可写
int&amp; ra = a;  //可读可写</code></pre> 
<p><span style="color:#f33b45;"><strong>（2）常引用——变量</strong></span></p> 
<pre class="has"><code class="language-cpp">int a = 10;         //可读可写
int const&amp; ra = a;  //仅仅可读，不可写

ra=20;  //编译不通过，ra是常量</code></pre> 
<p><span style="color:#f33b45;"><strong>（3）变引用——常量</strong></span></p> 
<pre class="has"><code class="language-cpp">int const  a = 100;  //常量
int  &amp; ar = a;       //变量，编译没办法通过，因为本尊都是常量，别名自然不能是变量</code></pre> 
<p><strong><span style="color:#f33b45;">（4）常引用——常量</span></strong></p> 
<pre class="has"><code class="language-cpp">int const  a = 100;  //常量
int const &amp; ar = a;  //常量，自身和别名都是常量，没有问题</code></pre> 
<p><strong>3.2 指针引用</strong></p> 
<p>引用既然就是一个变量，那我同样也可以给指针变量去一个别名啊，参见下面的</p> 
<pre class="has"><code class="language-cpp">int main()
{
	int a = 100;
	int *p = &amp;a;
	int * &amp;rp = p;

	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; *p &lt;&lt; endl;
	cout &lt;&lt; *rp &lt;&lt; endl; //这里为什么要将*放在前面，因为p的类型是 int * 作为一个整体哦！！

	cout &lt;&lt; p &lt;&lt; endl;
	cout &lt;&lt; rp &lt;&lt; endl;

	getchar();
	return 0;
}
/*
100
100
100
012FF84C
012FF84C
*/</code></pre> 
<p>我们发现这里的指针变量p和它的引用（别名）rp是完全一样的。但是由于引用的目的跟指针的目的是类似的，所以一般不需要对指针再起别名了。（参见两数交换的函数）</p> 
<blockquote> 
 <p><span style="color:#f33b45;"><strong>总而言之一句话：</strong></span></p> 
 <p><span style="color:#f33b45;"><strong>引用变量就是别名、别名、别名。</strong></span></p> 
</blockquote> 
<h3><span style="color:#f33b45;">四、引用与函数的结合使用</span></h3> 
<p><strong>4.1 引用变量作为函数参数</strong></p> 
<p>把传值和传址的优点结合起来了，写起来会比较方便，<strong><span style="color:#f33b45;">同时对形参修改了会体现到我们的外部实参上（因为形参就是实参的别名</span></strong>），同时传引用的效率比传值的效率高，传引用写起来也比传址方便。</p> 
<pre class="has"><code class="language-cpp">void swap(int&amp; left,int&amp; right)
{
    int tmp = left;
    left = right;
    right = tmp;
}
//函数调用,由于引用仅仅是一个别名，对于形参的操作会影响到实参
a=10;，需要特别注意
b=20;
swap(a,b);</code></pre> 
<p>由于引用变量作为函数参数，对形参修改了会体现到我们的外部实参上（因为形参就是实参的别名），这需要特别注意，但是如果我不希望改变外面的实参呢？<br> 传了引用之后，在函数内部进行操作就会把实参修改怎么办？</p> 
<p>此时就采用const引用</p> 
<pre class="has"><code class="language-cpp">void testfun(const int&amp; a)
{
    //a = 10;
    //此时a就不能改，因为a是一个常量的引用，不允许修改
}</code></pre> 
<p><span style="color:#f33b45;"><strong>总结：</strong></span>所以我们在构建函数的时候，还是要根据实际的需求，来决定到底是传值、传指针、还是传引用。不能一概而论。<br>  </p> 
<p><strong>4.2 引用变量作为函数的返回值</strong></p> 
<p><strong><span style="color:#f33b45;">（1）不要返回局部变量的引用——一个严重的问题</span></strong></p> 
<p>先看一个代码：</p> 
<pre class="has"><code class="language-cpp">using namespace std;

int&amp; test1()
{
	int n = 5;
	return n;
}

int main()
{
	int i = test1();
	cout &lt;&lt; i &lt;&lt; endl;

	getchar();
	return 0;
}</code></pre> 
<p><span style="color:#f33b45;"><strong>注意：</strong></span></p> 
<p>不同的编译器对于返回局部变量的引用有所区别对待：</p> 
<blockquote> 
 <ul><li>对于gcc和g++， 编译报警告，运行的时候会出现错误</li><li>对于msvc：编译报警告，warning C4172: 返回局部变量或临时变量的地址: n，但是运行的时候不会出现错误，而是像正常的运行一样，比如上面的代码结果为5.</li></ul> 
</blockquote> 
<p>为什么不要返回局部变量的引用呢？</p> 
<p>因为当该函数调用结束之后，该函数内部创建的局部变量出了作用域会被销毁，为这个函数开辟的栈帧也会被系统回收，在调用下一个函数之前会对这一部分栈空间里的垃圾数据进行清理，因此你也会失去对这个空间的管控能力。函数调用结束之后，所有的局部变量都销毁了，哪里来的别名这一说法。</p> 
<p><span style="color:#f33b45;"><strong>（2）返回全局变量的引用</strong></span></p> 
<pre class="has"><code class="language-cpp">int c; //定义全局变量
int &amp; add(int a, int b)
{
	c = a + b;
	return c;  //这里的返回值就是一个int类型的变量，并不是一个引用类型啊，这是不是和int &amp;不兼容？
}</code></pre> 
<p>不兼容问题并不会存在，由于引用变量并不会占用内存，它实际上就是c，所以返回引用变量就是c。</p> 
<p>当然我想下面这样写，更规范，也是没问题的</p> 
<pre class="has"><code class="language-cpp">int c; //定义全局变量
int &amp;rc=c;  //先给c把别名起好
int &amp; add(int a, int b)
{
	c = a + b;
	return rc;  //rc 就是c
}</code></pre> 
<p>怎么调用呢？</p> 
<p>如下就像普通函数调用即可：</p> 
<pre class="has"><code class="language-cpp">int main()
{
	int a = 100;  
	int b = 200;
	int result = add(a, b);  //就像普通函数调用即可
	cout &lt;&lt; result &lt;&lt; endl;

	getchar();
	return 0;
}</code></pre> 
<p>当然也可以这样做，这样看起来更加规范一些：</p> 
<pre class="has"><code class="language-cpp">int main()
{
    int a = 100;  
    int b = 200;
    int result;
    int &amp;rresult=result  //先给返回值起一个别名
    rresultadd(a, b);  
    cout &lt;&lt; rresult &lt;&lt; endl;

    getchar();
    return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f651a5d6c410153a4d228176b49bb4e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hibernate 的级联更新</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8151d385fa3573e2b6bac7c424546a4a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MFC设置编辑框背景颜色等</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>