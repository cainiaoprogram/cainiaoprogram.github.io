<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL---join驱动表的选择 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL---join驱动表的选择" />
<meta property="og:description" content="文章目录 join关键字IndexNested-Loop JoinBlock Nested-Loop Join小表的概念总结： join关键字 当业务需要从多个数据表中读取数据时，可以使用SQL语句中的连接（JOIN），在两个或多个数据表中查询数据。
JOIN 按照功能可分为三类：
INNER JOIN（内连接，或等值连接）：获取两个表中字段匹配关系的记录；LEFT JOIN（左连接）：获取左表中的所有记录，即使在右表没有对应匹配的记录；RIGHT JOIN（右连接）：与 LEFT JOIN 相反，用于获取右表中的所有记录，即使左表没有对应匹配的记录。 但是当有多张表的时候，驱动表该如何选择？
首先建一张表用来演示。
CREATE TABLE `t2` ( `id` int(11) NOTNULL, `a` int(11) DEFAULTNULL, `b` int(11) DEFAULTNULL, PRIMARY KEY (`id`), KEY `a` (`a`) ) ENGINE=InnoDB; CREATE TABLE `t1` LIKE `t2`; 假设插入的数据是一一对应的以方面计算。 提示：文中用到的straight_join完全等同于inner join，但是从左到右实现强制多表的载入顺序，不同于inner join会进行优化。
IndexNested-Loop Join 对于SQLselect * from t1 straight_join t2 on (t1.a=t2.a)；有以下执行流程：
从表t1中读入一行数据 R；从数据行R中，取出a字段到表t2里去查找；取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；重复执行步骤1到3，直到表t1的末尾循环结束。 我们称之为IndexNested-Loop Join算法，简称NLJ。
在这个流程里：
对驱动表t1做了全表扫描，这个过程需要扫描N行；对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描M行；所以整个执行流程，总扫描行数是N&#43;M。 假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。
当驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。因此整个执行过程，近似复杂度是 N&#43;N2log M，很明显N对扫描行数的影响更大，因此应该让小表来做驱动表。（N扩大1000倍的话，扫描行数就会扩大1000倍；而M扩大1000倍，扫描行数扩大不到10倍。）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3f24240d5dc6b36a05bce8883d1098d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-12T22:16:14+08:00" />
<meta property="article:modified_time" content="2021-07-12T22:16:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL---join驱动表的选择</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#join_2" rel="nofollow">join关键字</a></li><li><a href="#IndexNestedLoop_Join_30" rel="nofollow">IndexNested-Loop Join</a></li><li><a href="#Block_NestedLoop_Join_51" rel="nofollow">Block Nested-Loop Join</a></li><li><a href="#_84" rel="nofollow">小表的概念</a></li><li><ul><li><a href="#_98" rel="nofollow">总结：</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="join_2"></a>join关键字</h2> 
<p>当业务需要从多个数据表中读取数据时，可以使用SQL语句中的连接（JOIN），在两个或多个数据表中查询数据。</p> 
<p>JOIN 按照功能可分为三类：</p> 
<ol><li>INNER JOIN（内连接，或等值连接）：获取两个表中字段匹配关系的记录；</li><li>LEFT JOIN（左连接）：获取左表中的所有记录，即使在右表没有对应匹配的记录；</li><li>RIGHT JOIN（右连接）：与 LEFT JOIN 相反，用于获取右表中的所有记录，即使左表没有对应匹配的记录。</li></ol> 
<p><strong>但是当有多张表的时候，驱动表该如何选择？</strong></p> 
<p>首先建一张表用来演示。</p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t2<span class="token punctuation">`</span> <span class="token punctuation">(</span>
<span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOTNULL<span class="token punctuation">,</span>
<span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> DEFAULTNULL<span class="token punctuation">,</span>
<span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> DEFAULTNULL<span class="token punctuation">,</span>
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">KEY</span> <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token operator">LIKE</span> <span class="token punctuation">`</span>t2<span class="token punctuation">`</span><span class="token punctuation">;</span>
假设插入的数据是一一对应的以方面计算。
</code></pre> 
<blockquote> 
 <p>提示：文中用到的straight_join完全等同于inner join，但是从左到右实现强制多表的载入顺序，不同于inner join会进行优化。</p> 
</blockquote> 
<h2><a id="IndexNestedLoop_Join_30"></a>IndexNested-Loop Join</h2> 
<p>对于SQL<code>select * from t1 straight_join t2 on (t1.a=t2.a)；</code>有以下执行流程：</p> 
<ol><li>从表t1中读入一行数据 R；</li><li>从数据行R中，取出a字段到表t2里去查找；</li><li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li><li>重复执行步骤1到3，直到表t1的末尾循环结束。</li></ol> 
<p>我们称之为<strong>IndexNested-Loop Join</strong>算法，简称NLJ。</p> 
<p>在这个流程里：</p> 
<ol><li>对驱动表t1做了<strong>全表扫描</strong>，这个过程需要扫描N行；</li><li>对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描M行；</li><li>所以整个执行流程，总扫描行数是N+M。</li></ol> 
<p>假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是<strong>以2为底的M的对数</strong>，记为log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。</p> 
<p>当驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。因此整个执行过程，近似复杂度是 N+N<em>2</em>log M，很明显N对扫描行数的影响更大，<strong>因此应该让小表来做驱动表。</strong>（N扩大1000倍的话，扫描行数就会扩大1000倍；而M扩大1000倍，扫描行数扩大不到10倍。）</p> 
<h2><a id="Block_NestedLoop_Join_51"></a>Block Nested-Loop Join</h2> 
<p>SQL<code>select * from t1 straight_join t2 on (t1.a=t2.b);</code>由于表t2的字段b上没有索引，因此搜索时，每次到t2去匹配的时候，就要做一次全表扫描。<strong>假设驱动表行数是N，被驱动表行数是M，那就需要扫描行数是N*M。</strong></p> 
<p>我们将这个算法称为<strong>Simple Nested-Loop Join</strong>，但是MySQL没有使用这个算法，而是使用了另一个叫作<strong>BlockNested-Loop Join</strong>的算法，简称BNL。</p> 
<p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p> 
<ol><li>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</li><li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</li></ol> 
<p>假设小表的行数是N，大表的行数是M，在这个算法里：</p> 
<ol><li>两个表都做一次全表扫描，所以总的扫描行数是M+N；</li><li>内存中的判断次数是M*N。</li></ol> 
<p>看样子和Simple Nested-Loop Join是一样的，但是Block Nested-Loop Join算法的判断是内存操作，速度上会快很多，性能也更好。</p> 
<p>这里涉及到一个参数是<code>join_buffer_size</code>，join_buffer的大小是由join_buffer_size的大小控制的，默认256K。如果放不下的话，策略是分段放。</p> 
<p>假设t1有100行，内存放不下，执行过程就变成了：</p> 
<ol><li>扫描表t1，顺序读取数据行放入join_buffer中，放完第80行join_buffer满了，继续第2步；</li><li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回；</li><li>清空join_buffer；</li><li>继续扫描表t1，顺序读取最后的20行数据放入join_buffer中，继续执行第2步。</li></ol> 
<p>假设驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。这里的K不是常数，N越大K就会越大，因此把K表示为λ*N，λ的取值范围是(0,1)。</p> 
<p>在这个算法的执行过程中：</p> 
<ol><li>扫描行数是 <code>N+λ*N*M</code>；</li><li>内存判断 <code>N*M</code>次。</li></ol> 
<p>从内存判断次数看来不论哪个作为驱动表结果都是一样的，但是考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。<strong>所以使用小表作为驱动表会更好。</strong></p> 
<h2><a id="_84"></a>小表的概念</h2> 
<p>假设t1有100行，t2有1000行。</p> 
<p>对于SQL<code>select * from t2 straight_join t1 on (t1.b=t2.b) where t2.id&lt;=50;</code>join_buffer只需要放入t2的前50行。虽然t2比t1的行数多，但是这里“t2的前50行”是那个相对小的表，也就是“小表”。</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> t1<span class="token punctuation">.</span>b<span class="token punctuation">,</span>t2<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>b<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token keyword">where</span> t2<span class="token punctuation">.</span>id<span class="token operator">&lt;=</span><span class="token number">100</span>；
<span class="token keyword">select</span> t1<span class="token punctuation">.</span>b<span class="token punctuation">,</span>t2<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> t2 straight_join t1 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>b<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token keyword">where</span> t2<span class="token punctuation">.</span>id<span class="token operator">&lt;=</span><span class="token number">100</span>；
</code></pre> 
<p>这两条SQL表t1只查字段b，因此如果把t1放到join_buffer中，则join_buffer中只需要放入b的值；表t2需要查所有的字段，因此如果把表t2放到join_buffer中的话，就需要放入三个字段id、a和b。</p> 
<p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表就是小表</strong>。</p> 
<h3><a id="_98"></a>总结：</h3> 
<ol><li>如果可以使用IndexNested-Loop Join算法，也就是说可以用上被驱动表上的索引，可以使用join连接，同时将小表作为驱动表。</li><li>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。这种join连接要慎用。</li><li>不管使用哪一种，都尽量将小表作为驱动表！</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a769f699c6b2e30a9b210b6b57cc20a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS数组转字符串（3种方法）和字符串转数组（2种）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac5c0128ee574ba3d66148f903301fcb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">必修二英语计算机课文翻译,教科版（2019）高中信息技术必修二  2.1 计算机系统的组成...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>