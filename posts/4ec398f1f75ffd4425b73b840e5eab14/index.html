<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>刷题Leetcode - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="刷题Leetcode" />
<meta property="og:description" content="目录
1.按奇偶排序数组
2.从尾到头打印链表
3.替换空格
4.二维数组中的查找
5.六一儿童节
6.大整数相乘
7.最大乘积
8.两数之和
9.数组中重复的数字
10.二维数组中的查找
11. 最大矩形
12.跳跃游戏
13.三角形的最大周长
14.DI序列的有效排列
15.最佳买卖股票时机含冷冻期
16.连续数组
17.汉明距离
18.汉明距离总和
1.按奇偶排序数组 给定一个非负整数数组 A，返回一个由 A 的所有偶数元素组成的数组，后面跟 A 的所有奇数元素。
你可以返回满足此条件的任何数组作为答案。
示例：
输入：[3,1,2,4]
输出：[2,4,3,1]
输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */ int* sortArrayByParity(int* A, int ASize, int* returnSize) { int temp,p=0,i; for(i=0;i&lt;ASize;i&#43;&#43;) { if(A[i]%2==0) { temp=A[i]; A[i]=A[p]; A[p]=temp; p&#43;&#43;; } } *returnSize=ASize; return A; } 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4ec398f1f75ffd4425b73b840e5eab14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-18T15:29:41+08:00" />
<meta property="article:modified_time" content="2019-06-18T15:29:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">刷题Leetcode</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:40px;"><a href="#main-toc" rel="nofollow">1.按奇偶排序数组</a></p> 
<p id="2.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8" rel="nofollow">2.从尾到头打印链表</a></p> 
<p id="3.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-toc" style="margin-left:40px;"><a href="#3.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC" rel="nofollow">3.替换空格</a></p> 
<p id="4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">4.二维数组中的查找</a></p> 
<p id="5.%E5%85%AD%E4%B8%80%E5%84%BF%E7%AB%A5%E8%8A%82-toc" style="margin-left:40px;"><a href="#5.%E5%85%AD%E4%B8%80%E5%84%BF%E7%AB%A5%E8%8A%82" rel="nofollow">5.六一儿童节</a></p> 
<p id="6.%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E4%B9%98-toc" style="margin-left:40px;"><a href="#6.%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E4%B9%98" rel="nofollow">6.大整数相乘</a></p> 
<p id="7.%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF-toc" style="margin-left:40px;"><a href="#7.%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF" rel="nofollow">7.最大乘积</a></p> 
<p id="8.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-toc" style="margin-left:40px;"><a href="#8.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C" rel="nofollow">8.两数之和</a></p> 
<p id="9.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-toc" style="margin-left:40px;"><a href="#9.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97" rel="nofollow">9.数组中重复的数字</a></p> 
<p id="10.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#10.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">10.二维数组中的查找</a></p> 
<p id="11.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2-toc" style="margin-left:40px;"><a href="#11.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2" rel="nofollow">11. 最大矩形</a></p> 
<p id="12.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-toc" style="margin-left:40px;"><a href="#12.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F" rel="nofollow">12.跳跃游戏</a></p> 
<p id="13.%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF-toc" style="margin-left:40px;"><a href="#13.%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF" rel="nofollow">13.三角形的最大周长</a></p> 
<p id="14.DI%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%89%E6%95%88%E6%8E%92%E5%88%97-toc" style="margin-left:40px;"><a href="#14.DI%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%89%E6%95%88%E6%8E%92%E5%88%97" rel="nofollow">14.DI序列的有效排列</a></p> 
<p id="15.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F-toc" style="margin-left:40px;"><a href="#15.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F" rel="nofollow">15.最佳买卖股票时机含冷冻期</a></p> 
<p id="16.%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#16.%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84" rel="nofollow">16.连续数组</a></p> 
<p id="17.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB-toc" style="margin-left:40px;"><a href="#17.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB" rel="nofollow">17.汉明距离</a></p> 
<p id="18.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C-toc" style="margin-left:40px;"><a href="#18.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C" rel="nofollow">18.汉明距离总和</a></p> 
<hr id="hr-toc"> 
<h3>1.按奇偶排序数组</h3> 
<blockquote> 
 <p>给定一个非负整数数组 <code>A</code>，返回一个由 <code>A</code> 的所有偶数元素组成的数组，后面跟 <code>A</code> 的所有奇数元素。</p> 
 <p>你可以返回满足此条件的任何数组作为答案。</p> 
 <p>示例：</p> 
 <p><strong>输入：</strong>[3,1,2,4]</p> 
 <p><strong>输出：</strong>[2,4,3,1]</p> 
 <p>输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortArrayByParity(int* A, int ASize, int* returnSize) {
    int temp,p=0,i;
    for(i=0;i&lt;ASize;i++)
    {
        if(A[i]%2==0)
        {
            temp=A[i];
            A[i]=A[p];
            A[p]=temp;
            p++;
        }
    }
    *returnSize=ASize;
    return A;
}</code></pre> 
<h3 id="2.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">2.从尾到头打印链表</h3> 
<blockquote> 
 <p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    vector&lt;int&gt; printListFromTailToHead(ListNode* head) {
        vector&lt;int&gt; value;
        if(head != NULL)
        {
            value.insert(value.begin(),head-&gt;val);
            while(head-&gt;next != NULL)
            {
                value.insert(value.begin(),head-&gt;next-&gt;val);
                head = head-&gt;next;
            }         
              
        }
        return value;
    }
};</code></pre> 
<h3 id="3.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">3.替换空格</h3> 
<blockquote> 
 <p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p> 
</blockquote> 
<pre class="has"><code class="language-cpp"> void replaceSpace(char *&amp;str,int length) {
         char *newstr;int flag=0,i=0,j=0;
         for(i=0;i&lt;length;i++)
             if(str[i]==' ') flag++;
        newstr=new char[length+flag*3];
        for(i=0,j=0;i&lt;length;i++,j++)
            if(str[i]==' '){
                newstr[j]='%';
                newstr[j+1]='2';
                newstr[j+2]='0';
                j=j+2;
            }
           else
                newstr[j]=str[i];
        str=newstr;
         
    }</code></pre> 
<h3 id="4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">4.二维数组中的查找</h3> 
<blockquote> 
 <p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) {
        int flag=array[0].size();
        for(int i=0;i&lt;array.size();i++)
            for(int j=0;j&lt;flag;j++)
            {
                if(target==array[i][j]) return true;
                if(target&lt;array[i][j])
                {
                    flag=j;
                    break;
                }
            }
        return false;
    }
};
</code></pre> 
<h3 id="5.%E5%85%AD%E4%B8%80%E5%84%BF%E7%AB%A5%E8%8A%82">5.六一儿童节</h3> 
<blockquote> 
 <p>六一儿童节，老师带了很多好吃的巧克力到幼儿园。每块巧克力j的重量为w[j]，对于每个小朋友i，当他分到的巧克力大小达到h[i] (即w[j]&gt;=h[i])，他才会上去表演节目。老师的目标是将巧克力分发给孩子们，使得最多的小孩上台表演。可以保证每个w[i]&gt; 0且不能将多块巧克力分给一个孩子或将一块分给多个孩子。</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
 
int main(){
    int n,m;
    int *h,*w;
    cin&gt;&gt;n;
    h=new int[n];
    for(int i=0;i&lt;n;i++){
        cin&gt;&gt;h[i];
    }
    cin&gt;&gt;m;
    w=new int[m];
    for(int j=0;j&lt;m;j++){
        cin&gt;&gt;w[j];
    }
    sort(h, h+n); sort(w, w+m);
    int i = 0, j = 0, res = 0;
    while(j &lt; m &amp;&amp; i &lt; n){
        if(h[i] &lt;= w[j]) {res++; i++; j++;}
        else j++;
    }
    cout&lt;&lt;res&lt;&lt;endl;
}</code></pre> 
<h3 id="6.%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E4%B9%98">6.大整数相乘</h3> 
<blockquote> 
 <p>有两个用字符串表示的非常大的大整数,算出他们的乘积，也是用字符串表示。不能用系统自带的大整数类型。</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;
const int L=11000;
string mul(string,string);
int main(){
    string x,y;
    while(cin&gt;&gt;x&gt;&gt;y)
        cout&lt;&lt;mul(x,y)&lt;&lt;endl;
}
string mul(string a,string b) {
    string s;
    int na[L],nb[L],nc[L],La=a.size(),Lb=b.size(),i,j;
    fill(na,na+L,0);fill(nb,nb+L,0);fill(nc,nc+L,0);
    for(i=La-1;i&gt;=0;i--) na[La-i]=a[i]-'0';
    for(i=Lb-1;i&gt;=0;i--) nb[Lb-i]=b[i]-'0';
    for(i=1;i&lt;=La;i++)
        for(j=1;j&lt;=Lb;j++)
        nc[i+j-1]+=na[i]*nb[j];
    for(i=1;i&lt;=La+Lb;i++)
        nc[i+1]+=nc[i]/10,nc[i]%=10;
    if(nc[La+Lb]) s+=nc[La+Lb]+'0';
    for(i=La+Lb-1;i&gt;=1;i--)
        s+=nc[i]+'0';
    return s;
}
</code></pre> 
<h3 id="7.%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF">7.最大乘积</h3> 
<blockquote> 
 <p>给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大。</p> 
 <p>要求时间复杂度：O(n)，空间复杂度：O(1)</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
 
int main()
{
    long long *a,c,d,result,temp,max,pre,ppre;
    int i,n;
    cin&gt;&gt;n;
    a=new long long[n];
    for(i=0;i&lt;n;i++)
    {
        cin&gt;&gt;a[i];
    }
    for(int j=0;j&lt;n;j++)
    {
    for(i=0;i&lt;n-j-1;i++)
    {
        if(a[i]&gt;a[i+1])
        {
            temp=a[i];
            a[i]=a[i+1];
            a[i+1]=temp;
        }
    }
    }
    max=a[n-1];
    pre=a[n-2];
    ppre=a[n-3];
    for(int j=0;j&lt;n;j++)
    {
    for(i=0;i&lt;n-j-1;i++)
    {
        if(a[i]&lt;a[i+1])
        {
            temp=a[i];
            a[i]=a[i+1];
            a[i+1]=temp;
        }
    }
    }
    c=max*pre*ppre;
    d=a[n-1]*a[n-2]*max;
    if(c&gt;d)
    cout&lt;&lt;c&lt;&lt;endl;
    else
    cout&lt;&lt;d&lt;&lt;endl;
}</code></pre> 
<h3 id="8.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">8.两数之和</h3> 
<blockquote> 
 <p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p> 
 <p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target) {
    static int a[2];
    int temp;
    for(int p=0;p&lt;numsSize-1;p++)
    {
        temp=target-nums[p];
        for(int q=p+1;q&lt;numsSize;q++)
        {
            if(nums[q]==temp)
            {
                a[0]=p;a[1]=q; return a;
            }   
        }
    }
    return 0;
}</code></pre> 
<h3 id="9.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">9.数组中重复的数字</h3> 
<blockquote> 
 <p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p> 
 <p>Input: {2, 3, 1, 0, 2, 5}</p> 
 <p>Output: 2</p> 
 <p>要求是时间复杂度 O(N)，空间复杂度 O(1)。</p> 
 <p>因此不能使用排序的方法，也不能使用额外的标记数组。</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">//对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。
bool Solution(int* nums, int length, int* duplication){
    for (int i = 0; i &lt; length; i++) {
        while (nums[i] != i) {
            if (nums[i] == nums[nums[i]]) {
                duplication[0] = nums[i];
                cout&lt;&lt;duplication[0];
                return true;
            }
            swap(nums[i],nums[nums[i]]);
        }
    }
    return false;
}

int main(){
    int arr[6] = {2, 3, 1, 0, 2, 5};
    int *b=new int[6];
    Solution(arr,6,b);
}</code></pre> 
<h3 id="10.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">10.二维数组中的查找</h3> 
<blockquote> 
 <p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。要求时间复杂度 O(M + N)，空间复杂度 O(1)</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">//二维数组中的查找.该二维数组中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找.
bool Find(int target, int matrix[5][5],int rows,int cols) {
    int r = 0, c = cols - 1; // 从右上角开始
    while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target &gt; matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}
int main(){
    int arr[5][5] = {<!-- -->{1,   4,  7, 11, 15},
                     {2,   5,  8, 12, 19},
                     {3,   6,  9, 16, 22},
                     {10, 13, 14, 17, 24},
                     {18, 21, 23, 26, 30}};
    int target;
    while(cin&gt;&gt;target){
        if(Find(target,arr,5,5))
        cout&lt;&lt;"True!"&lt;&lt;endl;
    else
        cout&lt;&lt;"False!"&lt;&lt;endl;
    }
}</code></pre> 
<p> </p> 
<h3 id="11.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2">11. 最大矩形</h3> 
<blockquote> 
 <p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p> 
 <p>示例:</p> 
 <p>输入:<br> [<br>   ["1","0","1","0","0"],<br>   ["1","0","1","1","1"],<br>   ["1","1","1","1","1"],<br>   ["1","0","0","1","0"]<br> ]<br> 输出: 6</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
       int m = matrix.size();
        if(!m) return 0;
        int n = matrix[0].size();
        vector&lt;int&gt; dp(n + 1,0);
        dp[n] = -1;
        int res = 0;
        stack&lt;int&gt; s;
        for(int i = 0;i &lt; m;i++){
            for(int j = 0;j &lt; n;j++)
                if(matrix[i][j] == '1') dp[j] += 1;
                else dp[j] = 0;
            for(int j = 0;j &lt;= n;j++){
                while(!s.empty() &amp;&amp; dp[s.top()] &gt; dp[j]){
                    auto t = s.top();
                    s.pop();
                    int pre = -1;
                    if(!s.empty()) pre = s.top();
                    res = max(res,dp[t] * (j !=n ? (j - pre - 1) :(n - pre - 1)));
                }
                if(j == n) break;
                s.push(j);
            }
        }
        return res;
    }
};</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/86/e8/LymONg89_o.gif" width="15"></p> 
<p> </p> 
<p><strong>递归问题：<a href="http://39.96.217.32/blog/4" rel="nofollow">http://39.96.217.32/blog/4</a></strong></p> 
<h3 id="12.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F">12.跳跃游戏</h3> 
<blockquote> 
 <p>给定一个非负整数数组，你最初位于数组的第一个位置。</p> 
 <p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p> 
 <p>判断你是否能够到达最后一个位置。</p> 
 <p><strong>例一：输入:</strong> [2,3,1,1,4] <strong>输出:</strong> true <strong>解释:</strong> 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置</p> 
 <p><strong>例二：输入:</strong> [3,2,1,0,4] <strong>输出:</strong> false <strong>解释:</strong> 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        if(nums.size() == 1) {
            return true;
        }
        int n = -2; 
        for(int i=nums.size() - 2;i&gt;=0;i--) {
             // 从后往前找，把当前过不了的坑的位置记录起来
            if(nums[i] == 0 &amp;&amp; n&lt;=-1) {  
                // 如果遇到新的坑并且当前没有坑，则记录坑的位置
                n = i;
                continue;
            }
            if(n&gt;=0 &amp;&amp; nums[i] &gt; (n-i)) {   
            // 如果发现元素的值大于元素和坑的距离，说明可以跳过这个坑，将坑的下标置为-1，继续往前找坑
                n = -1;
            }
        }
        // 走到起点发现没有记录到坑，说明可以跳过去，否则返回false
        return n&lt;0;
    }
};</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/32/32/tmbXmJkz_o.gif" width="15"></p> 
<h3 id="13.%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF">13.三角形的最大周长</h3> 
<blockquote> 
 <p>给定由一些正数（代表长度）组成的数组 <code>A</code>，返回由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长。</p> 
 <p>如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p> 
 <p><strong>输入：</strong>[2,1,2] <strong>输出：</strong>5</p> 
 <p><strong>输入：</strong>[1,2,1] <strong>输出：</strong>0</p> 
 <p><strong>输入：</strong>[3,2,3,4] <strong>输出：</strong>10</p> 
</blockquote> 
<pre class="has"><code class="language-java">class Solution {
    public int largestPerimeter(int[] A) {
        Arrays.sort(A);
        if(A.length&lt;3)
            return 0;
        for(int i = A.length - 1; i &gt;= 2; i--) {
            int a = A[i];
            int b = A[i - 1];
            int c = A[i - 2];
            if(a &lt; b + c){
                return a + b + c;
            }
        }
        return 0;
    }
}</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/5d/92/Pu5zOXhc_o.gif" width="15"></p> 
<h3 id="14.DI%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%89%E6%95%88%E6%8E%92%E5%88%97">14.DI序列的有效排列</h3> 
<blockquote> 
 <p>我们给出 <code>S</code>，一个源于 <code>{'D', 'I'}</code> 的长度为 <code>n</code> 的字符串 。（这些字母代表 “减少” 和 “增加”。）<br><em>有效排列 是对整数 <code>{0, 1, ..., n}</code> 的一个排列 <code>P[0], P[1], ..., P[n]</code>，使得对所有的 <code>i</code>：</em></p> 
 <ul><li>如果 <code>S[i] == 'D'</code>，那么 <code>P[i] &gt; P[i+1]</code>，以及；</li><li>如果 <code>S[i] == 'I'</code>，那么 <code>P[i] &lt; P[i+1]</code>。</li></ul> 
 <p>有多少个有效排列？因为答案可能很大，所以请<strong>返回你的答案模</strong><strong> <code>10^9 + 7</code></strong>.</p> 
 <p><strong>输入：</strong>"DID" <strong>输出：</strong>5 <strong>解释：</strong> (0, 1, 2, 3) 的五个有效排列是： (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0）</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    int numPermsDISequence(string S) {
        int M = pow(10, 9)+7;
        //第一维表示取到S的第几个字母，第二维表示取值，例如0，1，2，3,dp[i][3]结尾取3
        vector&lt;vector&lt;int&gt;&gt; dp(S.size()+1,vector&lt;int&gt;(S.size()+1,0));
        dp[0][0] = 1;
        for(int i = 0;i&lt;S.size();i++){
            if(S[i] == 'I'){
                for(int j = 1;j&lt;=i+1;j++){
                    dp[i+1][j] = (dp[i+1][j-1]+dp[i][j-1])%M;
                }
            }else{
                for(int j = i;j&gt;=0;j--){
                    dp[i+1][j] = (dp[i+1][j+1]+dp[i][j])%M;
                }
            }
        }
        int res = 0;
        for(int i = 0;i&lt;dp.size();i++){
            res=(res+dp[dp.size()-1][i])%M;
        }
        return res;
    }
};</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/d7/22/gnOsGfZR_o.gif" width="15"></p> 
<h3 id="15.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F">15.最佳买卖股票时机含冷冻期</h3> 
<blockquote> 
 <p>给定一个整数数组，其中第<em> i</em> 个元素代表了第 <em>i</em> 天的股票价格 。​</p> 
 <p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p> 
 <ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul> 
 <p><strong>输入:</strong> [1,2,3,0,2] <strong>输出: </strong>3 <strong>解释:</strong> 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p> 
</blockquote> 
<pre class="has"><code class="language-python">'''
sell[i]表示截至第i天，最后一个操作是卖时的最大收益；
buy[i]表示截至第i天，最后一个操作是买时的最大收益；
cool[i]表示截至第i天，最后一个操作是冷冻期时的最大收益；
递推公式：
sell[i] = max(buy[i-1]+prices[i], sell[i-1]) (第一项表示第i天卖出，第二项表示第i天冷冻)
buy[i] = max(cool[i-1]-prices[i], buy[i-1]) （第一项表示第i天买进，第二项表示第i天冷冻）
cool[i] = max(sell[i-1], buy[i-1], cool[i-1])
'''
class Solution:
    def maxProfit(self, prices):
        n = len(prices)
        if n == 0:
            return 0     
        sell = [0 for _ in range(n)]
        buy = [0 for _ in range(n)]
        cool = [0 for _ in range(n)]
        buy[0] = -prices[0]
        for i in range(1,n):
            sell[i] = max(buy[i-1] + prices[i], sell[i-1])
            buy[i] = max(cool[i-1] - prices[i], buy[i-1])
            cool[i] = max(sell[i-1], buy[i-1],cool[i-1])
        return sell[n-1]</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/96/89/oKDmOZpk_o.gif" width="15"></p> 
<pre class="has"><code class="language-java">   /**
     * buy[i]表示第i天买入时的最大利润（最后一个操作是买）
     * sell[i]表示第i天卖出时的最大利润（最后一个操作是卖）
     */
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 0)
            return 0;
        int[] buy = new int[n];
        int[] sell = new int[n];
        buy[0] = -prices[0];
        sell[0] = 0;
        if (n &gt; 1) {
            buy[1] = Math.max(buy[0], 0 - prices[1]);//因为冷冻期，所以前一天只能为买，所以比较的是buy[0]=-prices[0],而大前天无买卖，所以利润为0，则得到0-prices[1]
            sell[1] = Math.max(sell[0], buy[0] + prices[1]);
        }
        for (int i = 2; i &lt; n; ++i) {
            buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);//因为冷冻期，所以前一天只能为买，所以比较的是buy[i - 1]
            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);//比较的是前一天卖出的最大利润和前一天买入的最大利润+今天卖出的价格
        }
        return sell[n - 1];
    }</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/84/83/c5EBey6Y_o.gif" width="15"></p> 
<h3 id="16.%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84">16.连续数组</h3> 
<blockquote> 
 <p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。</p> 
 <p><strong>输入:</strong> [0,1] <strong>输出:</strong> 2 <strong>说明:</strong> [0, 1] 是具有相同数量0和1的最长连续子数组。</p> 
 <p><strong>输入:</strong> [0,1,0] <strong>输出:</strong> 2 <strong>说明:</strong> [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    int findMaxLength(vector&lt;int&gt;&amp; nums) {
        map&lt;int,int&gt; m;
        int sum = 0;
        int res = 0;
        for(int i = 0;i&lt;nums.size();i++){
            sum+=(nums[i]==1?1:-1);
            if(sum == 0){
                res = i+1;
            }
            else{
                if(m[sum]==0){
                    m[sum] = i+1;
                }else{
                    res = max(res,i-m[sum]+1);
                }
            }
        }
        return res;
    }
};</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/94/ae/RmS7LahZ_o.gif" width="15"></p> 
<h3 id="17.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">17.汉明距离</h3> 
<blockquote> 
 <p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB" rel="nofollow">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p> 
 <p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p> 
 <p><strong>输入:</strong> x = 1, y = 4 <strong>输出:</strong> 2</p> 
 <p><strong>解释:</strong> 1 (0 0 0 1)</p> 
 <p>         4 (0 1 0 0)</p> 
 <p>                ↑    ↑ 上面的箭头指出了对应二进制位不同的位置。</p> 
</blockquote> 
<p>方法一：</p> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    int hammingDistance(int x, int y) {
        return bitset&lt;32&gt;(x ^ y).count();
    }
};
//bitset&lt;32&gt; bv; 声明 bv 是 32位2进制 bitset class 的对象。</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/a5/32/XsxTFAwY_o.gif" width="15"></p> 
<p>方法二：</p> 
<pre class="has"><code class="language-java">class Solution {
    public int hammingDistance(int x, int y) {
        int sum = 0;
        x = x^y;
        while(x!=0) {
            sum+=x&amp;1;
            x&gt;&gt;=1;
        }
        return sum;
    }</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/0c/40/UxWAc952_o.gif" width="15"></p> 
<h3 id="18.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C">18.汉明距离总和</h3> 
<blockquote> 
 <p>两个整数的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin" rel="nofollow">汉明距离</a> 指的是这两个数字的二进制数对应位不同的数量。</p> 
 <p>计算一个数组中，任意两个数之间汉明距离的总和。</p> 
 <p><strong>输入:</strong> 4, 14, 2 <strong>输出:</strong> 6 <strong>解释:</strong> 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系） 所以答案为： HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p> 
</blockquote> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    int totalHammingDistance(vector&lt;int&gt;&amp; nums) {
        int res = 0,n = nums.size();
        for(int i=0;i&lt;32;i++){
            int cnt = 0;
            for(auto num:nums){
                if(num &amp; (1&lt;&lt;i)) cnt++;//统计第i位上1的个数
            }
            res += cnt * (n-cnt);//每一位0的个数与1的个数相乘
        }
        return res;
    }
};</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/03/7c/9dMjm00f_o.gif" width="15"></p> 
<pre class="has"><code class="language-java">class Solution {
    public int totalHammingDistance(int[] nums) {
        int total = 0;
    	for(int i = 0; i &lt; 32; i++) {
    		int distance = 0;
    		for(int j = 0; j &lt; nums.length; j++) {
    			if((nums[j] &amp; (1 &lt;&lt; i - 1)) != 0)
    				distance++;
    		}
    		total += distance*(nums.length - distance);
    	}
    	return total;
    }
}</code></pre> 
<p><img alt="wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" class="has" height="15" src="https://images2.imgbox.com/06/3b/0a1VVUId_o.gif" width="15"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ce854f7ad91182b01bc9862dc804846b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">instanceof 在list</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b3d2ba32e0edba895b8e157656157ab2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用casbin开发rbac模型的golang权限控制模块功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>