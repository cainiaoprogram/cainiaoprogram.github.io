<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt之模型/视图（实时更新数据） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt之模型/视图（实时更新数据）" />
<meta property="og:description" content="在实际应用中，视图展示的数据往往并非一成不变的，那么如何实时更新成了一个很重要的问题！
功能：
（1）添加委托（进度条）
（2）显示文件名称、大小、进度、速度、剩余时间、状态等。
（3）可进行添加、更新、删除、清空等操作。
（4）实时更新数据
委托（进度条）：
ProgressBarDelegate::ProgressBarDelegate(QObject *parent) : QItemDelegate(parent) { } void ProgressBarDelegate::paint(QPainter* painter, const QStyleOptionViewItem&amp; option, const QModelIndex&amp; index) const { if(index.column() == 2) { int progress = index.model ()-&gt;data(index, Qt::DisplayRole).toInt (); QStyleOptionProgressBarV2 progressBarOption; progressBarOption.state = QStyle:: State_Enabled; progressBarOption.direction = QApplication:: layoutDirection (); progressBarOption.rect = option.rect; progressBarOption.fontMetrics = QApplication:: fontMetrics (); progressBarOption.minimum = 0; progressBarOption.maximum = 100; progressBarOption.textAlignment = Qt:: AlignCenter; progressBarOption.textVisible = true; progressBarOption.progress = progress; progressBarOption." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b75df25e5d5b348d4f472b43b58af1b3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-10T16:37:49+08:00" />
<meta property="article:modified_time" content="2023-01-10T16:37:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt之模型/视图（实时更新数据）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">在实际应用中，视图展示的数据往往并非一成不变的，那么如何实时更新成了一个很重要的问题！</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">功能：</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">（1）添加委托（进度条）</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">（2）显示文件名称、大小、进度、速度、剩余时间、状态等。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">（3）可进行添加、更新、删除、清空等操作。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">（4）实时更新数据</span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">委托（进度条）：</span></p> 
 <pre class="kdocs-c-like"><code class="language-c-like">ProgressBarDelegate::ProgressBarDelegate(QObject *parent)
: QItemDelegate(parent)
{

}

void ProgressBarDelegate::paint(QPainter* painter, const QStyleOptionViewItem&amp; option, const QModelIndex&amp; index) const
{
if(index.column() == 2)
{
int progress = index.model ()-&gt;data(index, Qt::DisplayRole).toInt ();
QStyleOptionProgressBarV2 progressBarOption;
progressBarOption.state = QStyle:: State_Enabled;
progressBarOption.direction = QApplication:: layoutDirection ();
progressBarOption.rect = option.rect;
progressBarOption.fontMetrics = QApplication:: fontMetrics ();
progressBarOption.minimum = 0;
progressBarOption.maximum = 100;
progressBarOption.textAlignment = Qt:: AlignCenter;
progressBarOption.textVisible = true;
progressBarOption.progress = progress;
progressBarOption.text = QString("%1%").arg(progressBarOption.progress);
QApplication:: style ()-&gt;drawControl(QStyle::CE_ProgressBar, &amp;progressBarOption, painter);
} else {
return QItemDelegate::paint (painter, option, index);
}
}</code></pre> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">模型:</span></p> 
 <pre class="kdocs-c-like"><code class="language-c-like">TableModel::TableModel(QObject *parent)
: QAbstractTableModel(parent), arr_row_list(NULL)
{

}

TableModel::~TableModel(void)
{
arr_row_list = NULL;
}

void TableModel::setHorizontalHeaderList(QStringList horizontalHeaderList)
{
horizontal_header_list = horizontalHeaderList;
}

void TableModel::setVerticalHeaderList(QStringList verticalHeaderList)
{
vertical_header_list = verticalHeaderList;
}

int TableModel::rowCount(const QModelIndex &amp;parent) const
{
if(vertical_header_list.size() &gt; 0)
return vertical_header_list.size();

if(NULL == arr_row_list)
return 0;
else
return arr_row_list-&gt;size();
}

int TableModel::columnCount(const QModelIndex &amp;parent) const
{
if(horizontal_header_list.size() &gt; 0)
return horizontal_header_list.size();

if(NULL == arr_row_list)
return 0;
else if(arr_row_list-&gt;size() &lt; 1)
return 0;
else
return arr_row_list-&gt;at(0).size();
}

QVariant TableModel::data(const QModelIndex &amp;index, int role) const
{
if (!index.isValid())
return QVariant();

if(NULL == arr_row_list)
return QVariant();

if(arr_row_list-&gt;size() &lt; 1)
return QVariant();

if (role == Qt::TextAlignmentRole)
{
return int(Qt::AlignLeft | Qt::AlignVCenter);
}
else if (role == Qt::DisplayRole)
{
if(index.row() &gt;= arr_row_list-&gt;size())
return QVariant();
if(index.column() &gt;= arr_row_list-&gt;at(0).size())
return QVariant();
return arr_row_list-&gt;at(index.row()).at(index.column());
}
return QVariant();
}

QVariant TableModel::headerData(int section, Qt::Orientation orientation, int role) const
{
if(role==Qt::DisplayRole)
{
if(orientation==Qt::Horizontal) // 水平表头
{
if(horizontal_header_list.size() &gt; section)
return horizontal_header_list[section];
else
return QVariant();
}
else
{
if(vertical_header_list.size() &gt; section)
return vertical_header_list[section]; // 垂直表头
else
return QVariant();
}
}

return QVariant();
}

Qt::ItemFlags TableModel::flags(const QModelIndex &amp;index) const
{
if (!index.isValid())
return Qt::NoItemFlags;

Qt::ItemFlags flag = QAbstractItemModel::flags(index);

// flag|=Qt::ItemIsEditable // 设置单元格可编辑,此处注释,单元格无法被编辑
return flag;
}

void TableModel::setModalDatas(QList&lt; QStringList &gt; *rowlist)
{
arr_row_list = rowlist;
}

void TableModel::refrushModel()
{
beginResetModel();
endResetModel();

emit updateCount(this-&gt;rowCount(QModelIndex()));
}</code></pre> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">视图：</span></p> 
 <pre class="kdocs-c-like"><code class="language-c-like">TableView::TableView(QWidget *parent)
: QTableView(parent)
{
this-&gt;setAlternatingRowColors(true);
this-&gt;setStyleSheet( "QTableView{background-color: rgb(250, 250, 115);"
"alternate-background-color: rgb(141, 163, 215);}" );
this-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);
this-&gt;horizontalHeader()-&gt;setStretchLastSection(true);
this-&gt;horizontalHeader()-&gt;setHighlightSections(false);
this-&gt;verticalHeader()-&gt;setVisible(false);
this-&gt;setShowGrid(false);
this-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);
this-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection);

model = new TableModel();
this-&gt;setModel(model);
this-&gt;initHeader();
model-&gt;setModalDatas(&amp;grid_data_list);
progressbar_delegate = new ProgressBarDelegate();
this-&gt;setItemDelegate(progressbar_delegate);

connect(model, &amp;TableModel::updateCount, this, &amp;TableView::updateCount);

this-&gt;initHeader();
}

TableView::~TableView(void)
{
if(progressbar_delegate) {
delete progressbar_delegate;
progressbar_delegate = NULL;
}

if(model) {
delete model;
model = NULL;
}
grid_data_list.clear();
}

void TableView::addRow(QStringList rowList)
{
grid_data_list.append(rowList);
model-&gt;refrushModel();
}

void TableView::remove()
{
QModelIndexList model_index_list = this-&gt;selectedIndexes();
int model_count = model_index_list.count();
if(model_count &lt;= 0)
return;

QList list_row;
for(int i=model_count-1; i&gt;=0; i--)
{
QModelIndex model_index = model_index_list.at(i);
int row = model_index.row();
if(!list_row.contains(row))
list_row.append(row);
}

if(list_row.isEmpty())
return;

qSort(list_row);

for(int i=list_row.count()-1; i&gt;=0; i--)
{
grid_data_list.removeAt(list_row.at(i));
}

model-&gt;refrushModel();
}

void TableView::clear()
{
grid_data_list.clear();
model-&gt;refrushModel();
}

int TableView::rowCount()
{
return model-&gt;rowCount(QModelIndex());
}

void TableView::initHeader()
{
QStringList header;
header &lt;&lt; tr("name") &lt;&lt; tr("size") &lt;&lt; tr("progress") &lt;&lt; tr("speed") &lt;&lt; tr("left time") &lt;&lt; tr("state");
model-&gt;setHorizontalHeaderList(header);
}

void TableView::changeValue()
{
//这里以10行尾列进行更新
int row_count = this-&gt;rowCount();
if(row_count &lt; 10)
return;

for(int i=0; i&lt;10; i++)
{
QStringList file_list = grid_data_list.at(i);
int progress = rand()0;
QStringList row_list;
row_list &lt;&lt; file_list.at(0) &lt;&lt; file_list.at(1) &lt;&lt; QString::number(progress) &lt;&lt; file_list.at(3) &lt;&lt; file_list.at(4) &lt;&lt; file_list.at(5);
grid_data_list.replace(i, row_list);
}

model-&gt;refrushModel();
}</code></pre> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">在实际应用中，视图展示的数据往往并非一成不变的，那么如何实时更新成了一个很重要的问题！</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">功能：</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">（1）添加委托（进度条）</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">（2）显示文件名称、大小、进度、速度、剩余时间、状态等。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">（3）可进行添加、更新、删除、清空等操作。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">（4）实时更新数据</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">先看一个效果图：</span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">委托（进度条）：</span></p> 
 <pre class="kdocs-c-like"><code class="language-c-like">ProgressBarDelegate::ProgressBarDelegate(QObject *parent)
: QItemDelegate(parent)
{

}

void ProgressBarDelegate::paint(QPainter* painter, const QStyleOptionViewItem&amp; option, const QModelIndex&amp; index) const
{
if(index.column() == 2)
{
int progress = index.model ()-&gt;data(index, Qt::DisplayRole).toInt ();
QStyleOptionProgressBarV2 progressBarOption;
progressBarOption.state = QStyle:: State_Enabled;
progressBarOption.direction = QApplication:: layoutDirection ();
progressBarOption.rect = option.rect;
progressBarOption.fontMetrics = QApplication:: fontMetrics ();
progressBarOption.minimum = 0;
progressBarOption.maximum = 100;
progressBarOption.textAlignment = Qt:: AlignCenter;
progressBarOption.textVisible = true;
progressBarOption.progress = progress;
progressBarOption.text = QString("%1%").arg(progressBarOption.progress);
QApplication:: style ()-&gt;drawControl(QStyle::CE_ProgressBar, &amp;progressBarOption, painter);
} else {
return QItemDelegate::paint (painter, option, index);
}
}</code></pre> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">模型:</span></p> 
 <pre class="kdocs-c-like"><code class="language-c-like">TableModel::TableModel(QObject *parent)
: QAbstractTableModel(parent), arr_row_list(NULL)
{

}

TableModel::~TableModel(void)
{
arr_row_list = NULL;
}

void TableModel::setHorizontalHeaderList(QStringList horizontalHeaderList)
{
horizontal_header_list = horizontalHeaderList;
}

void TableModel::setVerticalHeaderList(QStringList verticalHeaderList)
{
vertical_header_list = verticalHeaderList;
}

int TableModel::rowCount(const QModelIndex &amp;parent) const
{
if(vertical_header_list.size() &gt; 0)
return vertical_header_list.size();

if(NULL == arr_row_list)
return 0;
else
return arr_row_list-&gt;size();
}

int TableModel::columnCount(const QModelIndex &amp;parent) const
{
if(horizontal_header_list.size() &gt; 0)
return horizontal_header_list.size();

if(NULL == arr_row_list)
return 0;
else if(arr_row_list-&gt;size() &lt; 1)
return 0;
else
return arr_row_list-&gt;at(0).size();
}

QVariant TableModel::data(const QModelIndex &amp;index, int role) const
{
if (!index.isValid())
return QVariant();

if(NULL == arr_row_list)
return QVariant();

if(arr_row_list-&gt;size() &lt; 1)
return QVariant();

if (role == Qt::TextAlignmentRole)
{
return int(Qt::AlignLeft | Qt::AlignVCenter);
}
else if (role == Qt::DisplayRole)
{
if(index.row() &gt;= arr_row_list-&gt;size())
return QVariant();
if(index.column() &gt;= arr_row_list-&gt;at(0).size())
return QVariant();
return arr_row_list-&gt;at(index.row()).at(index.column());
}
return QVariant();
}

QVariant TableModel::headerData(int section, Qt::Orientation orientation, int role) const
{
if(role==Qt::DisplayRole)
{
if(orientation==Qt::Horizontal) // 水平表头
{
if(horizontal_header_list.size() &gt; section)
return horizontal_header_list[section];
else
return QVariant();
}
else
{
if(vertical_header_list.size() &gt; section)
return vertical_header_list[section]; // 垂直表头
else
return QVariant();
}
}

return QVariant();
}

Qt::ItemFlags TableModel::flags(const QModelIndex &amp;index) const
{
if (!index.isValid())
return Qt::NoItemFlags;

Qt::ItemFlags flag = QAbstractItemModel::flags(index);

// flag|=Qt::ItemIsEditable // 设置单元格可编辑,此处注释,单元格无法被编辑
return flag;
}

void TableModel::setModalDatas(QList&lt; QStringList &gt; *rowlist)
{
arr_row_list = rowlist;
}

void TableModel::refrushModel()
{
beginResetModel();
endResetModel();

emit updateCount(this-&gt;rowCount(QModelIndex()));
}</code></pre> 
 <p style=""><span class="kdocs-fontSize" style="font-size:19pt;">视图：</span></p> 
 <pre class="kdocs-c-like"><code class="language-c-like">TableView::TableView(QWidget *parent)
: QTableView(parent)
{
this-&gt;setAlternatingRowColors(true);
this-&gt;setStyleSheet( "QTableView{background-color: rgb(250, 250, 115);"
"alternate-background-color: rgb(141, 163, 215);}" );
this-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);
this-&gt;horizontalHeader()-&gt;setStretchLastSection(true);
this-&gt;horizontalHeader()-&gt;setHighlightSections(false);
this-&gt;verticalHeader()-&gt;setVisible(false);
this-&gt;setShowGrid(false);
this-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);
this-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection);

model = new TableModel();
this-&gt;setModel(model);
this-&gt;initHeader();
model-&gt;setModalDatas(&amp;grid_data_list);
progressbar_delegate = new ProgressBarDelegate();
this-&gt;setItemDelegate(progressbar_delegate);

connect(model, &amp;TableModel::updateCount, this, &amp;TableView::updateCount);

this-&gt;initHeader();
}

TableView::~TableView(void)
{
if(progressbar_delegate) {
delete progressbar_delegate;
progressbar_delegate = NULL;
}

if(model) {
delete model;
model = NULL;
}
grid_data_list.clear();
}

void TableView::addRow(QStringList rowList)
{
grid_data_list.append(rowList);
model-&gt;refrushModel();
}

void TableView::remove()
{
QModelIndexList model_index_list = this-&gt;selectedIndexes();
int model_count = model_index_list.count();
if(model_count &lt;= 0)
return;

QList list_row;
for(int i=model_count-1; i&gt;=0; i--)
{
QModelIndex model_index = model_index_list.at(i);
int row = model_index.row();
if(!list_row.contains(row))
list_row.append(row);
}

if(list_row.isEmpty())
return;

qSort(list_row);

for(int i=list_row.count()-1; i&gt;=0; i--)
{
grid_data_list.removeAt(list_row.at(i));
}

model-&gt;refrushModel();
}

void TableView::clear()
{
grid_data_list.clear();
model-&gt;refrushModel();
}

int TableView::rowCount()
{
return model-&gt;rowCount(QModelIndex());
}

void TableView::initHeader()
{
QStringList header;
header &lt;&lt; tr("name") &lt;&lt; tr("size") &lt;&lt; tr("progress") &lt;&lt; tr("speed") &lt;&lt; tr("left time") &lt;&lt; tr("state");
model-&gt;setHorizontalHeaderList(header);
}

void TableView::changeValue()
{
//这里以10行尾列进行更新
int row_count = this-&gt;rowCount();
if(row_count &lt; 10)
return;

for(int i=0; i&lt;10; i++)
{
QStringList file_list = grid_data_list.at(i);
int progress = rand()0;
QStringList row_list;
row_list &lt;&lt; file_list.at(0) &lt;&lt; file_list.at(1) &lt;&lt; QString::number(progress) &lt;&lt; file_list.at(3) &lt;&lt; file_list.at(4) &lt;&lt; file_list.at(5);
grid_data_list.replace(i, row_list);
}

model-&gt;refrushModel();
}</code></pre> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c9004a245c15f59962652efd759f6c6e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">input标签placeholder字体居中颜色变更</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1e6e33260bf61fd4aaf4365959f918b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大华网络摄像头通过gstreamer 获取不到RTSP流</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>