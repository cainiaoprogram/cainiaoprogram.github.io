<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件架构设计的七大原则 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件架构设计的七大原则" />
<meta property="og:description" content="1、开闭原则 开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开
闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。
在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间，规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什么时候来，什么时候走是开放的。早来早走，晚来晚走。
实现开闭原则的核心思想就是面向抽象编程，接下来我们来看一段代码：
首先创建一个课程接口 ICourse：
整个课程生态有 Java 架构、大数据、人工智能、前端、软件测试等，我们来创建一个 Java架构课程的类 JavaCourse：
现在我们要给 Java 架构课程做活动，价格优惠。如果修改 JavaCourse 中的 getPrice()方法，则会存在一定的风险，可能影响其他地方的调用结果。我们如何在不修改原有代码前提前下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的类，
JavaDiscountCourse 类 （ 思 考 一 下 为 什 么 要 叫 JavaDiscountCourse ， 而 不 叫DiscountCourse）：
回顾一下，简单一下类结构图：
2、依赖倒置原则 依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。接下来看一个案例，还是以课程为例，先来创建一个类 Tom：
来调用一下：
Tom 热爱学习，目前正在学习 Java 课程和 Python 课程。大家都知道，学习也是会上瘾的。随着学习兴趣的暴涨，现在 Tom 还想学习 AI 人工智能的课程。这个时候，业务扩展，我们的代码要从底层到高层（调用层）一次修改代码。在 Tom 类中增加studyAICourse()的方法，在高层也要追加调用。如此一来，系统发布以后，实际上是非常不稳定的，在修改代码的同时也会带来意想不到的风险。接下来我们优化代码，创建一个课程的抽象 ICourse 接口：
然后写 JavaCourse 类：
再实现 PythonCourse 类：
修改 Tom 类：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/59dece4541d9cf7e324aec5c8110bab6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-21T22:02:11+08:00" />
<meta property="article:modified_time" content="2019-06-21T22:02:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件架构设计的七大原则</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1、开闭原则</h2> 
<p>开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开<br> 闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。<br> 在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间，规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什么时候来，什么时候走是开放的。早来早走，晚来晚走。<br> 实现开闭原则的核心思想就是面向抽象编程，接下来我们来看一段代码：<br> 首先创建一个课程接口 ICourse：<br><img alt="" class="has" height="105" src="https://images2.imgbox.com/08/f2/fd3wBCiC_o.png" width="700"></p> 
<p>整个课程生态有 Java 架构、大数据、人工智能、前端、软件测试等，我们来创建一个 Java架构课程的类 JavaCourse：<br><img alt="" class="has" height="384" src="https://images2.imgbox.com/3a/57/gJgvoXMR_o.png" width="700"></p> 
<p>现在我们要给 Java 架构课程做活动，价格优惠。如果修改 JavaCourse 中的 getPrice()方法，则会存在一定的风险，可能影响其他地方的调用结果。我们如何在不修改原有代码前提前下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的类，<br> JavaDiscountCourse 类 （ 思 考 一 下 为 什 么 要 叫 JavaDiscountCourse ， 而 不 叫DiscountCourse）：<br><img alt="" class="has" height="223" src="https://images2.imgbox.com/f1/8e/xC0QmKm8_o.png" width="700"></p> 
<p>回顾一下，简单一下类结构图：</p> 
<p><img alt="" class="has" height="388" src="https://images2.imgbox.com/c6/98/0UbfEj87_o.png" width="300"></p> 
<h2>2、依赖倒置原则</h2> 
<p>依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。接下来看一个案例，还是以课程为例，先来创建一个类 Tom：<br><img alt="" class="has" height="160" src="https://images2.imgbox.com/97/c8/xaag5IwT_o.png" width="600"></p> 
<p>来调用一下：<br><img alt="" class="has" height="88" src="https://images2.imgbox.com/01/bb/wP7YkEbL_o.png" width="600"></p> 
<p>Tom 热爱学习，目前正在学习 Java 课程和 Python 课程。大家都知道，学习也是会上瘾的。随着学习兴趣的暴涨，现在 Tom 还想学习 AI 人工智能的课程。这个时候，业务扩展，我们的代码要从底层到高层（调用层）一次修改代码。在 Tom 类中增加studyAICourse()的方法，在高层也要追加调用。如此一来，系统发布以后，实际上是非常不稳定的，在修改代码的同时也会带来意想不到的风险。接下来我们优化代码，创建一个课程的抽象 ICourse 接口：<br><img alt="" class="has" height="52" src="https://images2.imgbox.com/87/35/X61KyBJq_o.png" width="600"></p> 
<p>然后写 JavaCourse 类：</p> 
<p><img alt="" class="has" height="108" src="https://images2.imgbox.com/0b/4e/NXI3NWGZ_o.png" width="600"></p> 
<p>再实现 PythonCourse 类：<br><img alt="" class="has" height="104" src="https://images2.imgbox.com/fb/37/5ee49LAc_o.png" width="600"></p> 
<p>修改 Tom 类：<br><img alt="" class="has" height="90" src="https://images2.imgbox.com/75/c9/eya1LwMC_o.png" width="600"></p> 
<p>来看调用：<br><img alt="" class="has" height="87" src="https://images2.imgbox.com/71/06/vxfTluxi_o.png" width="600"></p> 
<p>我们这时候再看来代码，Tom 的兴趣无论怎么暴涨，对于新的课程，我只需要新建一个类，通过传参的方式告诉 Tom，而不需要修改底层代码。实际上这是一种大家非常熟悉的方式，叫依赖注入。注入的方式还有构造器方式和 setter 方式。我们来看构造器注入方式：<br><img alt="" class="has" height="209" src="https://images2.imgbox.com/61/f7/oIeD5gD1_o.png" width="600"></p> 
<p>看调用代码：<br><img alt="" class="has" height="71" src="https://images2.imgbox.com/55/bb/lHj8ZNTj_o.png" width="600"></p> 
<p>根据构造器方式注入，在调用时，每次都要创建实例。那么，如果 Tom 是全局单例，则我们就只能选择用 Setter 方式来注入，继续修改 Tom 类的代码：<br><img alt="" class="has" height="155" src="https://images2.imgbox.com/47/4c/vbVGafgm_o.png" width="600"></p> 
<p>看调用代码：<br><img alt="" class="has" height="141" src="https://images2.imgbox.com/03/04/pHliMVba_o.png" width="600"></p> 
<p>现在我们再来看最终的类图：<br><img alt="" class="has" height="270" src="https://images2.imgbox.com/4a/e1/KDGQ6aOS_o.png" width="600"></p> 
<p>切记：以抽象为基准比以细节为基准搭建起来的架构要稳定得多，因此大家在拿到需求之后，要面向接口编程，先顶层再细节来设计代码结构。</p> 
<h2>3、单一职责原则</h2> 
<p>单一职责（Simple Responsibility Pinciple，SRP）是指不要存在多于一个导致类变更的原因。假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导致类变更的原因。如何解决这个问题呢？我们就要给两个职责分别用两个 Class 来实现，进行解耦。后期需求变更维护互不影响。这样的设计，可以降低类的复杂度，提高类的可 读 性 ， 提 高 系 统 的 可 维 护 性 ， 降 低 变 更 引 起 的 风 险 。 总 体 来 说 就 是 一 个Class/Interface/Method 只负责一项职责。<br> 接下来，我们来看代码实例，还是用课程举例，我们的课程有直播课和录播课。直播课不能快进和快退，录播可以可以任意的反复观看，功能职责不一样。还是先创建一个Course 类：<br><img alt="" class="has" height="156" src="https://images2.imgbox.com/8d/f6/UBxF2pcd_o.png" width="600"></p> 
<p>看代码调用：<br><img alt="" class="has" height="88" src="https://images2.imgbox.com/90/ab/QepfoZS9_o.png" width="600"></p> 
<p>从上面代码来看，Course 类承担了两种处理逻辑。假如，现在要对课程进行加密，那么直播课和录播课的加密逻辑都不一样，必须要修改代码。而修改代码逻辑势必会相互影响容易造成不可控的风险。我们对职责进行分离解耦，来看代码，分别创建两个类ReplayCourse 和 LiveCourse：</p> 
<p>LiveCourse 类：<br><img alt="" class="has" height="73" src="https://images2.imgbox.com/8e/3c/XFKWTUrx_o.png" width="600"></p> 
<p>ReplayCourse 类：<br><img alt="" class="has" height="87" src="https://images2.imgbox.com/ef/32/jhrJxLr2_o.png" width="600"></p> 
<p>调用代码：<br><img alt="" class="has" height="121" src="https://images2.imgbox.com/d6/36/SjRPU9i2_o.png" width="600"></p> 
<p>业务继续发展，课程要做权限。没有付费的学员可以获取课程基本信息，已经付费的学员可以获得视频流，即学习权限。那么对于控制课程层面上至少有两个职责。我们可以把展示职责和管理职责分离开来，都实现同一个抽象依赖。设计一个顶层接口,创建<br> ICourse 接口：<br><img alt="" class="has" height="226" src="https://images2.imgbox.com/ec/41/HaXnhuT2_o.png" width="600"></p> 
<p>我们可以把这个接口拆成两个接口，创建一个接口 ICourseInfo 和 ICourseManager：<br> ICourseInfo 接口：<br><img alt="" class="has" height="72" src="https://images2.imgbox.com/13/40/ZaxTtPv4_o.png" width="600"></p> 
<p>ICourseManager 接口：<br><img alt="" class="has" height="68" src="https://images2.imgbox.com/93/d5/JplfwgJ8_o.png" width="600"></p> 
<p>来看一下类图：<br><img alt="" class="has" height="226" src="https://images2.imgbox.com/b2/14/npnCQacs_o.png" width="600"></p> 
<p>下面我们来看一下方法层面的单一职责设计。有时候，我们为了偷懒，通常会把一个方法写成下面这样：<br><img alt="" class="has" height="69" src="https://images2.imgbox.com/f5/6e/lp3i2CJi_o.png" width="600"></p> 
<p>还可能写成这样：<br><img alt="" class="has" height="248" src="https://images2.imgbox.com/a4/49/cOHKf45G_o.png" width="600"></p> 
<p>显然，上面的 modifyUserInfo()方法中都承担了多个职责，既可以修改 userName,也可以修改 address，甚至更多，明显不符合单一职责。那么我们做如下修改，把这个方法拆成两个：<br><img alt="" class="has" height="105" src="https://images2.imgbox.com/85/63/qWWwCV68_o.png" width="600"></p> 
<p>这修改之后，开发起来简单，维护起来也容易。但是，我们在实际开发中会项目依赖，组合，聚合这些关系，还有还有项目的规模，周期，技术人员的水平，对进度的把控，很多类都不符合单一职责。但是，我们在编写代码的过程，尽可能地让接口和方法保持单一职责，对我们项目后期的维护是有很大帮助的。</p> 
<h2>4、接口隔离原则</h2> 
<p>接口隔离原则（Interface Segregation Principle, ISP）是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口时应当注意一下几点：<br> 1、一个类对一类的依赖应该建立在最小的接口之上。<br> 2、建立单一接口，不要建立庞大臃肿的接口。<br> 3、尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）。<br> 接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型，包括以后有可能发生变更的地方还要做一些预判。所以，对于抽象，对业务模型的理解是非常重要的。下面我们来看一段代码，写一个动物行为的抽象：<br> IAnimal 接口：<br><img alt="" class="has" height="89" src="https://images2.imgbox.com/c0/52/dQaPpIRC_o.png" width="600"></p> 
<p>Bird 类实现：<br><img alt="" class="has" height="139" src="https://images2.imgbox.com/ff/5c/m1ai2HKe_o.png" width="600"></p> 
<p>Dog 类实现：<br><img alt="" class="has" height="139" src="https://images2.imgbox.com/2c/df/bxgPeu8K_o.png" width="600"></p> 
<p>可以看出，Bird 的 swim()方法可能只能空着，Dog 的 fly()方法显然不可能的。这时候，我们针对不同动物行为来设计不同的接口，分别设计 IEatAnimal，IFlyAnimal 和ISwimAnimal 接口，来看代码：<br> IEatAnimal 接口：<br><img alt="" class="has" height="52" src="https://images2.imgbox.com/1d/97/lCCNbZAO_o.png" width="600"></p> 
<p>IFlyAnimal 接口：<br><img alt="" class="has" height="52" src="https://images2.imgbox.com/94/df/Wlko7du5_o.png" width="600"></p> 
<p>ISwimAnimal 接口：<br><img alt="" class="has" height="54" src="https://images2.imgbox.com/19/2e/oQL32Gcc_o.png" width="600"></p> 
<p>Dog 只实现 IEatAnimal 和 ISwimAnimal 接口：<br><img alt="" class="has" height="106" src="https://images2.imgbox.com/9e/c5/BLUJ1vhm_o.png" width="600"></p> 
<p>来看下两种类图的对比，还是非常清晰明了的：<br><img alt="" class="has" height="191" src="https://images2.imgbox.com/6d/f8/To3ElVL1_o.png" width="600"></p> 
<h2>5、迪米特法则</h2> 
<p>迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。</p> 
<p>现在来设计一个权限系统，Boss 需要查看目前发布到线上的课程数量。这时候，Boss要找到 TeamLeader 去进行统计，TeamLeader 再把统计结果告诉 Boss。接下来我们还是来看代码：<br> Course 类：<br><img alt="" class="has" height="36" src="https://images2.imgbox.com/01/01/WyRhjm0T_o.png" width="600"></p> 
<p>TeamLeader 类：<br><img alt="" class="has" height="90" src="https://images2.imgbox.com/f3/ba/5Fv6YKUv_o.png" width="600"></p> 
<p>Boss 类：<br><img alt="" class="has" height="191" src="https://images2.imgbox.com/a0/28/4m5cU3eY_o.png" width="600"></p> 
<p>测试代码：<br><img alt="" class="has" height="88" src="https://images2.imgbox.com/74/f6/DhlAm1th_o.png" width="600"></p> 
<p>写到这里，其实功能已经都已经实现，代码看上去也没什么问题。根据迪米特原则，Boss只想要结果，不需要跟 Course 产生直接的交流。而 TeamLeader 统计需要引用 Course对象。Boss 和 Course 并不是朋友，从下面的类图就可以看出来：<br><img alt="" class="has" height="221" src="https://images2.imgbox.com/60/68/sgrSRBCG_o.png" width="600"></p> 
<p>下面来对代码进行改造：<br> TeamLeader 类：<br><img alt="" class="has" height="158" src="https://images2.imgbox.com/86/31/pqENVyd3_o.png" width="600"></p> 
<p>Boss 类：<br><img alt="" class="has" height="90" src="https://images2.imgbox.com/d8/f4/I7UV2ApT_o.png" width="600"></p> 
<p>再来看下面的类图，Course 和 Boss 已经没有关联了。<br><img alt="" class="has" height="234" src="https://images2.imgbox.com/0b/0e/HszhOa0i_o.png" width="600"></p> 
<p>学习软件设计原则，千万不能形成强迫症。碰到业务复杂的场景，我们需要随机应变。</p> 
<h2>6、里氏替换原则</h2> 
<p>里氏替换原则（Liskov Substitution Principle,LSP）是指如果对每一个类型为 T1 的对象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。<br> 定义看上去还是比较抽象，我们重新理解一下，可以理解为一个软件实体如果适用一个父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下：<br> 引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。<br> 1、子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br> 2、子类中可以增加自己特有的方法。<br> 3、当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。<br> 4、当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等。<br> 在前面讲开闭原则的时候埋下了一个伏笔，我们记得在获取折后时重写覆盖了父类的getPrice()方法，增加了一个获取源码的方法 getOriginPrice()，显然就违背了里氏替换原则。我们修改一下代码，不应该覆盖 getPrice()方法，增加 getDiscountPrice()方法：<br><img alt="" class="has" height="141" src="https://images2.imgbox.com/10/88/taK1u3Bg_o.png" width="600"></p> 
<p>使用里氏替换原则有以下优点：<br> 1、约束继承泛滥，开闭原则的一种体现。<br> 2、加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。<br> 现在来描述一个经典的业务场景，用正方形、矩形和四边形的关系说明里氏替换原则，我们都知道正方形是一个特殊的长方形，那么就可以创建一个长方形父类 Rectangle 类：<br><img alt="" class="has" height="316" src="https://images2.imgbox.com/16/4d/7D5r2Y3I_o.png" width="600"></p> 
<p>创建正方形 Square 类继承长方形：<br><img alt="" class="has" height="434" src="https://images2.imgbox.com/4d/ab/h3PMDdAC_o.png" width="600"></p> 
<p>在测试类中创建 resize()方法，根据逻辑长方形的宽应该大于等于高，我们让高一直自增，知道高等于宽变成正方形：<br><img alt="" class="has" height="140" src="https://images2.imgbox.com/0c/d0/L4uoG7j5_o.png" width="600"></p> 
<p>测试代码：<br><img alt="" class="has" height="111" src="https://images2.imgbox.com/9a/be/drHzZxHW_o.png" width="600"></p> 
<p>运行结果发现高比宽还大了，在长方形中是一种非常正常的情况。现在我们再来看下面的代码，<br> 把长方形 Rectangle 替换成它的子类正方形 Square，修改测试代码：<br><img alt="" class="has" height="88" src="https://images2.imgbox.com/da/eb/Fo0ho8rO_o.png" width="600"></p> 
<p>这时候我们运行的时候就出现了死循环，违背了里氏替换原则，将父类替换为子类后，程序运行结果没有达到预期。因此，我们的代码设计是存在一定风险的。里氏替换原则只存在父类与子类之间，约束继承泛滥。我们再来创建一个基于长方形与正方形共同的抽象四边形 Quadrangle 接口：<br><img alt="" class="has" height="70" src="https://images2.imgbox.com/f0/d4/vGWpiEiJ_o.png" width="600"></p> 
<p>修改长方形 Rectangle 类：<br><img alt="" class="has" height="296" src="https://images2.imgbox.com/cb/b5/XP4P3gsN_o.png" width="600"></p> 
<p>修改正方形类 Square 类：<br><img alt="" class="has" height="298" src="https://images2.imgbox.com/64/55/bUWOULEV_o.png" width="600"></p> 
<p>此时，如果我们把 resize()方法的参数换成四边形 Quadrangle 类，方法内部就会报错。因为正方形 Square 已经没有了 setWidth()和 setHeight()方法了。因此，为了约束继承泛滥，resize()的方法参数只能用 Rectangle 长方形。</p> 
<h2>7、合成复用原则</h2> 
<p>合成复用原则（Composite/Aggregate Reuse Principle,CARP）是指尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。<br> 继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱复用，对类以外的对象是无法获取到实现细节的。要根据具体的业务场景来做代码设计，其实也都需要遵循 OOP 模型。还是以数据库操作为例，先来创建 BConnection 类：</p> 
<p><img alt="" class="has" height="89" src="https://images2.imgbox.com/31/08/UQQ98yM6_o.png" width="600"></p> 
<p>创建 ProductDao 类：<br><img alt="" class="has" height="175" src="https://images2.imgbox.com/9b/f2/qdXnWJyL_o.png" width="600"></p> 
<p>这就是一种非常典型的合成复用原则应用场景。但是，目前的设计来说，DBConnection还不是一种抽象，不便于系统扩展。目前的系统支持 MySQL 数据库连接，假设业务发生变化，数据库操作层要支持 Oracle 数据库。当然，我们可以在 DBConnection 中增加对Oracle 数据库支持的方法。但是违背了开闭原则。其实，我们可以不必修改 Dao 的代码，将 DBConnection 修改为 abstract，来看代码：<br><img alt="" class="has" height="54" src="https://images2.imgbox.com/22/4f/TlgBzp4j_o.png" width="600"></p> 
<p>然后，将 MySQL 的逻辑抽离：<br><img alt="" class="has" height="106" src="https://images2.imgbox.com/06/0c/fthtJBNS_o.png" width="600"></p> 
<p>再创建 Oracle 支持的逻辑：<br><img alt="" class="has" height="106" src="https://images2.imgbox.com/94/0f/mUiqkzzN_o.png" width="600"></p> 
<p>具体选择交给应用层，来看一下类图：<br><img alt="" class="has" height="311" src="https://images2.imgbox.com/bd/ab/iad1U3wT_o.png" width="600"></p> 
<h2>8、设计原则总结</h2> 
<p>学习设计原则，学习设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，我们要考虑人力、时间、成本、质量，不是刻意追求完美，要在适当的场景遵循设计原则，体现的是一种平衡取舍，帮助我们设计出更加优雅的代码结构。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d6699f72cd11e386bd1e83a64b725482/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue初步认识，前端发展历史</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e089b4a8a7bc92567979e8eb6009a49/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">十二色相环</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>