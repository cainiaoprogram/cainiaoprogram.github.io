<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Emerging Properties in Self-Supervised Vision Transformers(2021) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Emerging Properties in Self-Supervised Vision Transformers(2021)" />
<meta property="og:description" content="[paper] Emerging Properties in Self-Supervised Vision Transformers
[code] facebookresearch/dino
摘要 在本文中，我们质疑自我监督学习是否为视觉变压器（ViT）[18]提供了与卷积网络（convnets）相比脱颖而出的新属性。除了使自我监督方法适应这种体系结构特别有效的事实之外，我们还做出以下观察：首先，自我监督的ViT功能包含有关图像语义分割的明确信息，而对于监督的ViT来说，这显然不明显， 也没有卷积网。其次，这些功能也是出色的k-NN分类器，使用较小的ViT在ImageNet上的top-1达到78.3％。我们的研究还强调了动量编码器[31]，多作物训练[10]以及在ViT上使用小补丁的重要性。我们将研究结果实施为一种简单的自我监督方法，称为DINO，我们将其解释为无标签的自我蒸馏形式。通过使用ViT-Base进行线性评估，在ImageNet上达到80.1％的top-1，我们展示了DINO和ViT之间的协同作用。
介绍 变压器[67]最近出现，可以替代卷积神经网络（convnets）进行视觉识别[18、66、80]。它们的采用与自然语言处理（NLP）启发的训练策略相结合，即对大量数据进行预训练并对目标数据集进行微调[17，53]。最终的视觉变形器（ViT）[18]与卷积网络相比具有竞争优势，但是，它们还没有比卷积网络带来明显的好处：它们在计算上要求更高，需要更多的训练数据，并且它们的功能没有表现出独特的性能。
在本文中，我们质疑变压器在视觉上的成功是否可以通过在他们的训练前使用监督来解释。我们的动机是，成功实现NLP的主要因素之一是使用自我监督的预训练，形式是BERT [17]中的紧密过程或GPT [53]中的语言建模。这些自我监督的预训练目标使用句子中的单词来创建借口任务，这些任务提供比预测每个句子单个标签的监督目标更丰富的学习信号。类似地，在图像中，图像级监督通常将图像中包含的丰富视觉信息减少为从几千个类别的对象的预定义集合中选择的单个概念[58]。
尽管NLP中使用的自我监督的前置任务是特定于文本的，但许多现有的自我监督方法已在具有卷积网络的图像上显示了它们的潜力[10、12、28、31]。它们通常具有相似的结构，但具有不同的组件，旨在避免琐碎的解决方案（崩溃）或提高性能[15]。在这项工作中，受这些方法的启发，我们研究了自我监督的预训练对ViT功能的影响。特别令人感兴趣的是，我们发现了受监督的ViT或卷积网络都没有出现的几个有趣的属性：
自我监督的ViT功能明确包含场景布局，尤其是对象边界，如图1所示。在最后一个块的自我关注模块中可以直接访问此信息。自我监督的ViT功能在没有任何微调，线性分类器或数据增强的情况下，使用基本的最近邻分类器（k-NN）尤其出色，在ImageNet上达到了78.3％的top-1准确性。 分割掩码的出现似乎是跨自我监督方法共享的属性。然而，仅当结合某些要素（例如动量编码器[31]和多作物增强[10]）时，k-NN的良好性能才会出现。我们研究的另一个发现是，将较小的补丁与ViT配合使用对于提高最终功能质量的重要性。
总体而言，我们对这些组件重要性的发现促使我们设计了一种简单的自我监督方法，可以将其解释为一种无标签的知识蒸馏形式[33]。产生的框架DINO通过使用标准的交叉熵损失直接预测由动量编码器构建的教师网络的输出，从而简化了自我监督的训练。有趣的是，我们的方法只能对教师的输出进行居中和锐化，以避免崩溃，而其他流行的组成部分，例如预测变量[28]，高级归一化[10]或对比损失[31]，则在稳定性或稳定性方面几乎没有增加任何益处或表现。尤其重要的是，我们的框架非常灵活，可以在卷积网络和ViT上工作，而无需修改架构，也无需调整内部标准化[56]。
我们通过以小补丁的ViT-Base优于ImageNet线性分类基准的以前的自我监督功能，以80.1％的top-1准确性，来进一步验证DINO和ViT之间的协同作用。我们还通过将最先进的技术与ResNet-50架构进行匹配，确认了DINO可与卷积网络一起使用。最后，我们讨论了在计算和内存容量有限的情况下将DINO与ViT结合使用的不同方案。特别是，使用ViT训练DINO仅需两台8-GPU服务器，即可在3天之内达到ImageNet线性基准测试的76.1％，该性能优于基于可比较大小的卷积网络的自我监督系统，并且显着降低了计算需求[10，28]。
相关工作 自我监督学习 关于自我监督学习的大量工作着重于区分实例分类[12、19、31、70]的判别方法，该方法将每个图像视为不同的类别，并通过将它们区分为数据扩充来训练模型。但是，明确学习分类器以区分所有图像[19]并不能很好地缩放图像的数量。Wu等[70]建议使用噪声对比估计器（NCE）[30]来比较实例，而不是对它们进行分类。这种方法的一个警告是，它需要同时比较大量图像中的特征。实际上，这需要大批量[12]或存储库[31、70]。有几种变体允许以聚类的形式对实例进行自动分组[2、8、9、25、34、40、71、77、82]。
最近的工作表明，我们可以在不区分图像的情况下学习不受监督的功能。特别有趣的是，Grill等[28]提出了一种称为BYOL的度量学习公式，其中通过将特征与动量编码器获得的表示进行匹配来对特征进行训练。已经表明，像BYOL这样的方法即使没有动量编码器也可以工作，但会降低性能[15，28]。其他一些工作也呼应了这个方向，表明人们可以训练匹配它们的特征到 l 2 l_2 l2​超球体上的均匀分布[6]或使用增白[22，78]。我们的方法是从BYOL中汲取灵感的，但是在相似度匹配损失方面却有所不同，并且为学生和老师使用了完全相同的体系结构。这样，我们的工作就完成了BYOL发起的自我监督学习的解释，这是一种没有标签的中庸教师自我提炼的形式[62]。
自我训练和知识升华 自我训练旨在通过将少量的初始批注传播到大量的未标记实例来提高要素的质量。可以使用标签[39、75、76]的硬分配或使用软分配[73]来完成此传播。当使用软标签时，该方法通常被称为知识提炼[7，33]，并且主要用于训练小型网络以模仿大型网络的输出以压缩模型。谢等[73]最近表明，蒸馏可以用于在自训练管道中将软伪标签传播到未标记的数据，从而在自训练和知识蒸馏之间建立了必不可少的联系。我们的工作建立在这种关系的基础上，并将知识提炼扩展到没有标签可用的情况。先前的工作还结合了自我监督学习和知识提炼，从而实现了自我监督模型压缩[24]和性能提升[13，45]。但是，当我们的老师在培训过程中动态建立时，这些作品依赖于受过培训的固定老师。这样，知识提纯而不是被用作自我监督式预训练的后处理步骤，而是直接转化为自我监督的目标。最后，我们的工作还涉及到协作[1]，即学生和教师拥有相同的体系结构，并在培训过程中使用蒸馏。然而，协同教学中的教师也是从学生身上提炼出来的，而在我们的工作中则是用学生的平均动量来更新的。
方法 SSL与知识蒸馏 用于这项工作的框架 DINO 与最近的自我监督方法具有相同的整体结构 [10、15、12、28、31]。然而，我们的方法与知识蒸馏 [33] 也有相似之处，我们在这个角度下呈现它。我们在图 2 中说明了 DINO，并在算法 1 中提出了一个伪代码实现。
知识蒸馏是一种学习范式，我们训练学生网络 gθs 以匹配给定教师网络 gθt 的输出，分别由 θs 和 θt 参数化。给定输入图像 x，两个网络都输出 K 维的概率分布，用 Ps 和 Pt 表示。概率 P 是通过使用 softmax 函数对网络 g 的输出进行归一化得到的。 更确切地说，
τs &gt; 0 是控制输出分布锐度的温度参数，类似的公式适用于温度为 τt 的 Pt。给定一个固定的教师网络 gθt ，我们通过最小化交叉熵损失 w." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e53e74cc671db2d9953e1aef2c36c2b3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-11T11:05:23+08:00" />
<meta property="article:modified_time" content="2021-06-11T11:05:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Emerging Properties in Self-Supervised Vision Transformers(2021)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://arxiv.org/pdf/2104.14294v1.pdf" rel="nofollow">[paper] Emerging Properties in Self-Supervised Vision Transformers</a><br> <a href="https://github.com/facebookresearch/dino">[code] facebookresearch/dino</a><br> <img src="https://images2.imgbox.com/44/e3/XeGF6Xgj_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_3"></a>摘要</h2> 
<p>在本文中，我们质疑自我监督学习是否为视觉变压器（ViT）[18]提供了与卷积网络（convnets）相比脱颖而出的新属性。除了使自我监督方法适应这种体系结构特别有效的事实之外，我们还做出以下观察：首先，自我监督的ViT功能包含有关图像语义分割的明确信息，而对于监督的ViT来说，这显然不明显， 也没有卷积网。其次，这些功能也是出色的k-NN分类器，使用较小的ViT在ImageNet上的top-1达到78.3％。我们的研究还强调了动量编码器[31]，多作物训练[10]以及在ViT上使用小补丁的重要性。我们将研究结果实施为一种简单的自我监督方法，称为DINO，我们将其解释为无标签的自我蒸馏形式。通过使用ViT-Base进行线性评估，在ImageNet上达到80.1％的top-1，我们展示了DINO和ViT之间的协同作用。</p> 
<h2><a id="_6"></a>介绍</h2> 
<p>变压器[67]最近出现，可以替代卷积神经网络（convnets）进行视觉识别[18、66、80]。它们的采用与自然语言处理（NLP）启发的训练策略相结合，即对大量数据进行预训练并对目标数据集进行微调[17，53]。最终的视觉变形器（ViT）[18]与卷积网络相比具有竞争优势，但是，它们还没有比卷积网络带来明显的好处：它们在计算上要求更高，需要更多的训练数据，并且它们的功能没有表现出独特的性能。</p> 
<p>在本文中，我们质疑变压器在视觉上的成功是否可以通过在他们的训练前使用监督来解释。我们的动机是，成功实现NLP的主要因素之一是使用自我监督的预训练，形式是BERT [17]中的紧密过程或GPT [53]中的语言建模。这些自我监督的预训练目标使用句子中的单词来创建借口任务，这些任务提供比预测每个句子单个标签的监督目标更丰富的学习信号。类似地，在图像中，图像级监督通常将图像中包含的丰富视觉信息减少为从几千个类别的对象的预定义集合中选择的单个概念[58]。</p> 
<p>尽管NLP中使用的自我监督的前置任务是特定于文本的，但许多现有的自我监督方法已在具有卷积网络的图像上显示了它们的潜力[10、12、28、31]。它们通常具有相似的结构，但具有不同的组件，旨在避免琐碎的解决方案（崩溃）或提高性能[15]。在这项工作中，受这些方法的启发，我们研究了自我监督的预训练对ViT功能的影响。特别令人感兴趣的是，我们发现了受监督的ViT或卷积网络都没有出现的几个有趣的属性：</p> 
<ul><li>自我监督的ViT功能明确包含场景布局，尤其是对象边界，如图1所示。在最后一个块的自我关注模块中可以直接访问此信息。</li><li>自我监督的ViT功能在没有任何微调，线性分类器或数据增强的情况下，使用基本的最近邻分类器（k-NN）尤其出色，在ImageNet上达到了78.3％的top-1准确性。</li></ul> 
<p>分割掩码的出现似乎是跨自我监督方法共享的属性。然而，仅当结合某些要素（例如动量编码器[31]和多作物增强[10]）时，k-NN的良好性能才会出现。我们研究的另一个发现是，将较小的补丁与ViT配合使用对于提高最终功能质量的重要性。</p> 
<p>总体而言，我们对这些组件重要性的发现促使我们设计了一种简单的自我监督方法，可以将其解释为一种无标签的知识蒸馏形式[33]。产生的框架DINO通过使用标准的交叉熵损失直接预测由动量编码器构建的教师网络的输出，从而简化了自我监督的训练。有趣的是，我们的方法只能对教师的输出进行居中和锐化，以避免崩溃，而其他流行的组成部分，例如预测变量[28]，高级归一化[10]或对比损失[31]，则在稳定性或稳定性方面几乎没有增加任何益处或表现。尤其重要的是，我们的框架非常灵活，可以在卷积网络和ViT上工作，而无需修改架构，也无需调整内部标准化[56]。</p> 
<p>我们通过以小补丁的ViT-Base优于ImageNet线性分类基准的以前的自我监督功能，以80.1％的top-1准确性，来进一步验证DINO和ViT之间的协同作用。我们还通过将最先进的技术与ResNet-50架构进行匹配，确认了DINO可与卷积网络一起使用。最后，我们讨论了在计算和内存容量有限的情况下将DINO与ViT结合使用的不同方案。特别是，使用ViT训练DINO仅需两台8-GPU服务器，即可在3天之内达到ImageNet线性基准测试的76.1％，该性能优于基于可比较大小的卷积网络的自我监督系统，并且显着降低了计算需求[10，28]。</p> 
<h2><a id="_21"></a>相关工作</h2> 
<h3><a id="_22"></a>自我监督学习</h3> 
<p>关于自我监督学习的大量工作着重于区分实例分类[12、19、31、70]的判别方法，该方法将每个图像视为不同的类别，并通过将它们区分为数据扩充来训练模型。但是，明确学习分类器以区分所有图像[19]并不能很好地缩放图像的数量。Wu等[70]建议使用噪声对比估计器（NCE）[30]来比较实例，而不是对它们进行分类。这种方法的一个警告是，它需要同时比较大量图像中的特征。实际上，这需要大批量[12]或存储库[31、70]。有几种变体允许以聚类的形式对实例进行自动分组[2、8、9、25、34、40、71、77、82]。</p> 
<p>最近的工作表明，我们可以在不区分图像的情况下学习不受监督的功能。特别有趣的是，Grill等[28]提出了一种称为BYOL的度量学习公式，其中通过将特征与动量编码器获得的表示进行匹配来对特征进行训练。已经表明，像BYOL这样的方法即使没有动量编码器也可以工作，但会降低性能[15，28]。其他一些工作也呼应了这个方向，表明人们可以训练匹配它们的特征到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          l 
         
        
          2 
         
        
       
      
        l_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.01968em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>超球体上的均匀分布[6]或使用增白[22，78]。我们的方法是从BYOL中汲取灵感的，但是在相似度匹配损失方面却有所不同，并且为学生和老师使用了完全相同的体系结构。这样，我们的工作就完成了BYOL发起的自我监督学习的解释，这是一种没有标签的中庸教师自我提炼的形式[62]。</p> 
<h3><a id="_26"></a>自我训练和知识升华</h3> 
<p>自我训练旨在通过将少量的初始批注传播到大量的未标记实例来提高要素的质量。可以使用标签[39、75、76]的硬分配或使用软分配[73]来完成此传播。当使用软标签时，该方法通常被称为知识提炼[7，33]，并且主要用于训练小型网络以模仿大型网络的输出以压缩模型。谢等[73]最近表明，蒸馏可以用于在自训练管道中将软伪标签传播到未标记的数据，从而在自训练和知识蒸馏之间建立了必不可少的联系。我们的工作建立在这种关系的基础上，并将知识提炼扩展到没有标签可用的情况。先前的工作还结合了自我监督学习和知识提炼，从而实现了自我监督模型压缩[24]和性能提升[13，45]。但是，当我们的老师在培训过程中动态建立时，这些作品依赖于受过培训的固定老师。这样，知识提纯而不是被用作自我监督式预训练的后处理步骤，而是直接转化为自我监督的目标。最后，我们的工作还涉及到协作[1]，即学生和教师拥有相同的体系结构，并在培训过程中使用蒸馏。然而，协同教学中的教师也是从学生身上提炼出来的，而在我们的工作中则是用学生的平均动量来更新的。</p> 
<h2><a id="_28"></a>方法</h2> 
<h3><a id="SSL_29"></a>SSL与知识蒸馏</h3> 
<p>用于这项工作的框架 DINO 与最近的自我监督方法具有相同的整体结构 [10、15、12、28、31]。然而，我们的方法与知识蒸馏 [33] 也有相似之处，我们在这个角度下呈现它。我们在图 2 中说明了 DINO，并在算法 1 中提出了一个伪代码实现。<br> <img src="https://images2.imgbox.com/0a/c4/URWrHsgH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/25/50/1GqAff6c_o.png" alt="在这里插入图片描述"></p> 
<p>知识蒸馏是一种学习范式，我们训练学生网络 gθs 以匹配给定教师网络 gθt 的输出，分别由 θs 和 θt 参数化。给定输入图像 x，两个网络都输出 K 维的概率分布，用 Ps 和 Pt 表示。概率 P 是通过使用 softmax 函数对网络 g 的输出进行归一化得到的。 更确切地说，<br> <img src="https://images2.imgbox.com/4a/14/VL4LfI7i_o.png" alt="在这里插入图片描述"><br> τs &gt; 0 是控制输出分布锐度的温度参数，类似的公式适用于温度为 τt 的 Pt。给定一个固定的教师网络 gθt ，我们通过最小化交叉熵损失 w.r.t 来学习匹配这些分布。 学生网络θs的参数：<br> <img src="https://images2.imgbox.com/93/66/gSihqCVU_o.png" alt="在这里插入图片描述"><br> 下面，我们将详细说明如何使等式（2）中的问题适应自我监督学习。首先，我们使用多重裁剪策略构建图像的不同扭曲视图或裁剪图 [10]。更准确地说，从给定的图像中，我们生成一组不同视图的 V。该集合包含两个全局视图 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          1 
         
        
          g 
         
        
       
      
        x^g_1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.04861em; vertical-align: -0.266308em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.7823em;"><span class="" style="top: -2.43369em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span class="" style="top: -3.18091em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.266308em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          2 
         
        
          g 
         
        
       
      
        x^g_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.04861em; vertical-align: -0.266308em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.7823em;"><span class="" style="top: -2.43369em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span class="" style="top: -3.18091em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.266308em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 以及几个较小分辨率的局部视图。所有裁剪都通过学生传递，而只有全局视图通过教师传递，因此鼓励“本地到全局”的对应关系。我们最小化损失：<br> <img src="https://images2.imgbox.com/62/08/KkP4GUJZ_o.png" alt="在这里插入图片描述"><br> 这种损失是通用的，可以用于任意数量的视图，甚至只有 2 个。然而，我们遵循多重裁剪的标准设置，使用 2 个分辨率为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         22 
        
        
        
          4 
         
        
          2 
         
        
       
      
        224^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 的全局视图覆盖原始图像的大（例如大于 50%）区域，和几个分辨率为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         9 
        
        
        
          6 
         
        
          2 
         
        
       
      
        96^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">9</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 的局部视图仅覆盖原始图像的小区域（例如小于 50%）。除非另有说明，否则我们将此设置称为 DINO 的基本参数化。</p> 
<p>两个网络共享相同的架构 g，具有不同的参数 θs 和 θt 集。我们使用随机梯度下降通过最小化方程 (3) 来学习参数 θs 。</p> 
<ul><li>教师网络<br> 与知识蒸馏不同，我们没有给定先验的教师 gθt，因此，我们从学生网络的过去迭代中构建它。我们在 5.2 节中研究了教师的不同更新规则，并表明在我们的框架中冻结教师网络在一个时期内的效果出奇地好，而复制教师的学生权重未能收敛。特别有趣的是，在学生权重上使用指数移动平均 (EMA)，即动量编码器 [31]，特别适合我们的框架。更新规则是 θt ← λθt + (1 − λ)θs，其中 λ 在训练期间遵循从 0.996 到 1 的余弦计划 [28]。最初，动量编码器已被引入作为对比学习中队列的替代品 [31]。然而，在我们的框架中，它的作用有所不同，因为我们没有队列也没有对比损失，并且可能更接近于自我训练中使用的平均教师的作用 [62]。事实上，我们观察到这个老师执行了一种类似于 Polyak-Ruppert 平均的模型集成形式，具有指数衰减 [49, 57]。使用 PolyakRuppert 平均进行模型集成是提高模型性能的标准做法 [36]。我们观察到该教师在整个培训过程中的表现优于学生，因此通过提供更高质量的目标特征来指导学生的培训。在以前的工作中没有观察到这种动态 [28, 56]。</li><li>网络架构<br> 神经网络 g 由主干 f（ViT [18] 或 ResNet [32]）和投影头 h 组成：g = h ◦ f。下游任务中使用的特征是主干 f 输出。投影头由一个隐藏维度为 2048 的 3 层多层感知器 (MLP) 和一个具有 K 维度的权重归一化全连接层 [59] 组成，其隐藏维度为 2048，类似于 SwAV [10] 的设计。我们测试了其他投影头，这种特殊设计似乎最适合 DINO（附录 C）。我们不使用预测器 [28, 15]，导致学生和教师网络中的架构完全相同。特别有趣的是，我们注意到与标准卷积网络不同，ViT 架构默认不使用批量归一化 (BN)。因此，当将 DINO 应用于 ViT 时，我们也不会在投影头中使用任何 BN，从而使系统完全没有 BN。</li><li>避免崩溃<br> 几种自监督方法因用于避免崩溃的操作而异，通过对比损失 [70]、聚类约束 [8、10]、预测器 [28] 或批量归一化 [28、56]。虽然我们的框架可以通过多重归一化 [10] 来稳定，但它也可以仅使用动量教师输出的居中和锐化来避免模型崩溃。如第 5.3 节中的实验所示，居中可以防止一个维度占主导地位，但会鼓励崩溃到均匀分布，而锐化则具有相反的效果。应用这两种操作可以平衡它们的效果，这足以避免在有动量教师的情况下崩溃。选择这种方法来避免崩溃交易稳定性以减少对批次的依赖性：居中操作仅依赖于一阶批次统计，并且可以解释为向教师添加偏差项 c：gt(x) ← gt(x) + C。中心 c 用指数移动平均线更新，这使得该方法可以在不同的批次大小下很好地工作，如第 5.5 节所示：<br> <img src="https://images2.imgbox.com/6d/fa/jP3EG0W5_o.png" alt="在这里插入图片描述"></li></ul> 
<p>通过在教师 softmax 归一化中使用较低的温度 τt 值来获得输出锐化。</p> 
<h3><a id="_53"></a>实施和评估协议</h3> 
<p>在本节中，我们提供了使用 DINO 进行训练的实现细节，并展示了我们实验中使用的评估协议。</p> 
<ul><li> <p>视觉转换器<br> 我们简要描述了 Vision Transformer (ViT) [18, 67] 的机制，并参考 Vaswani 等人 [67] 有关变形金刚的详细信息和 Dosovitskiy 等人 [18] 以适应图像。我们遵循 DeiT [66] 中使用的实现。我们在表 1 中总结了本文中使用的不同网络的配置。ViT 架构将分辨率为 N × N 的非重叠连续图像块的网格作为输入。在本文中，我们通常使用 N = 16 (“/16”) 或 N = 8 (“/8”)。然后将补丁通过线性层以形成一组嵌入。我们向序列 [17, 18] 添加了一个额外的可学习标记。这个令牌的作用是从整个序列中聚合信息，我们在它的输出端附加投影头 h。我们将此令牌称为类令牌 [CLS]，以与之前的作品 [17, 18, 66] 保持一致，即使在我们的案例中它没有附加到任何标签或监督。这组补丁令牌和 [CLS] 令牌被馈送到具有“预规范”层标准化的标准 Transformer 网络 [11, 37]。Transformer 是一系列自注意力和前馈层，与跳过连接并行。自注意力层通过使用注意力机制查看其他标记表示来更新标记表示 [4]。<br> <img src="https://images2.imgbox.com/e5/68/W5zceQpi_o.png" alt="在这里插入图片描述"></p> </li><li> <p>实施细则<br> 我们在没有标签的 ImageNet 数据集 [58] 上预训练模型。当使用 DeiT-S/16 时，我们使用 adamw 优化器 [42] 进行训练，批量大小为 1024，分布在 16 个 GPU 上。学习率在前 10 个 epoch 期间线性上升到其基本值，该值由以下线性缩放规则 [27] 确定：lr = 0.0005 ∗ batchsize/256。在这个热身之后，我们用一个余弦表来衰减学习率 [41]。重量衰减也遵循从 0.04 到 0.4 的余弦表。温度 τs 设置为 0.1，而我们在前 30 个时期对 τt 使用线性预热从 0.04 到 0.07。我们遵循 BYOL [28]（颜色抖动、高斯模糊和日光化）和多裁剪 [10] 的数据增强，使用双三次插值使位置嵌入适应尺度 [18, 66]。重现我们结果的代码和模型是公开的。</p> </li><li> <p>评估协议<br> 自监督学习的标准协议是学习冻结特征的线性分类器 [79, 31] 或微调下游任务的特征。对于线性评估，我们在训练期间应用随机调整裁剪和水平翻转增强，并报告中央裁剪的准确性。对于微调评估，我们使用预训练的权重初始化网络并在训练期间调整它们。然而，这两种评估都对超参数敏感，例如，当改变学习率时，我们观察到两次运行之间的准确性差异很大。因此，我们还使用 [70] 中的简单加权最近邻分类器 (k-NN) 来评估特征的质量。我们冻结预训练模型来计算和存储下游任务的训练数据的特征。然后，最近邻分类器将图像的特征与投票给标签的 k 个最近的存储特征进行匹配。我们扫描了不同数量的最近邻，发现 20 NN 在我们的大多数运行中始终保持最佳状态。该评估协议不需要任何其他超参数调整，也不需要数据增强，并且只需通过下游数据集一次即可运行，从而大大简化了特征评估。</p> </li></ul> 
<h2><a id="_63"></a>主要结果</h2> 
<p>我们首先使用 ImageNet 上的标准自监督基准验证本研究中使用的 DINO 框架。然后，我们研究用于检索、对象发现和迁移学习的结果特征的属性。</p> 
<h3><a id="_ImageNet__SSL__65"></a>与 ImageNet 上的 SSL 框架比较</h3> 
<p>我们考虑两种不同的设置：与相同架构和跨架构的比较。</p> 
<ul><li> <p>同架构对比<br> 在表 2 的顶部面板中，我们将 DINO 与具有相同架构的其他自监督方法进行了比较，ResNet-50 [32] 或 DeiT-small (DeiT-S) [66]。选择 DeiT-S 的动机是它与 ResNet-50 在几个轴上的相似性：参数数量（21M 对 23M）、吞吐量（1237/秒 VS 1007im/秒）和 ImageNet 上的监督性能，训练过程为 [66] ]（79.3% 对 79.8%）。我们在附录 D 中探索了 DeiT-S 的变体。首先，我们观察到 DINO 的性能与 ResNet-50 上的最新技术相当，验证了 DINO 在标准设置中的工作原理。当我们切换到 ViT 架构时，DINO 在线性分类方面的表现优于 BYOL、MoCov2 和 SwAV + 3.5%，在 k-NN 评估方面优于 +7.9%。更令人惊讶的是，简单的 k-NN 分类器的性能几乎与线性分类器相当（74.5% 对 77.0%）。此属性仅在将 DINO 与 ViT 架构一起使用时才会出现，并且不会出现在其他现有的自监督方法或 ResNet-50 中。<br> <img src="https://images2.imgbox.com/dc/5b/0HeJj2I1_o.png" alt="在这里插入图片描述"></p> </li><li> <p>跨架构比较<br> 在表 2 的底部面板上，我们比较了跨架构获得的最佳性能。此设置的目的不是直接比较方法，而是在迁移到更大的架构时评估使用 DINO 训练的 ViT 的限制。虽然用 DINO 训练更大的 ViT 可以提高性能，但减小补丁的大小（“/8”变体）对性能有更大的影响。减小补丁大小虽然不增加参数，但仍然会导致运行时间的显着减少，以及更大的内存使用。尽管如此，使用 DINO 训练的具有 8 × 8 块的基础 ViT 在线性分类中达到了 80.1% 的 top-1，使用 k-NN 分类器达到了 77.4%，其参数比以前的最先进技术少了 10 倍，运行时间快了 1.4 倍 [13 ]。</p> </li></ul> 
<h3><a id="_SSL__ViT__74"></a>使用 SSL 训练的 ViT 的属性</h3> 
<p>我们根据最近邻搜索来评估 DINO 特征的属性，保留有关对象位置的信息以及向下游任务的可转移性。</p> 
<h4><a id="_DINO_ViT__76"></a>使用 DINO ViT 检索最近邻</h4> 
<p>ImageNet 分类的结果暴露了我们的特征在依赖最近邻检索的任务中的潜力。在这组实验中，我们在地标检索和复制检测任务上进一步巩固了这一发现。</p> 
<ul><li>图像检索<br> 我们考虑重新访问的 [51] 牛津和巴黎图像检索数据集 [48]。它们包含 3 个不同的查询/数据库对逐渐难度拆分。我们报告了中等 (M) 和硬 (H) 拆分的平均平均精度 (mAP)。在表 3 中，我们比较了通过监督或 DINO 训练获得的不同现成特征的性能。我们冻结特征并直接应用 k-NN 进行检索。我们观察到 DINO 特征优于在带有标签的 ImageNet 上训练的特征。<br> <img src="https://images2.imgbox.com/c6/0c/Z3yxSkBQ_o.png" alt="在这里插入图片描述"><br> SSL 方法的一个优点是它们可以在任何数据集上进行训练，而无需任何形式的注释。我们在来自 Google Landmarks v2 (GLDv2) [69] 的 1.2M 干净集上训练 DINO，这是一个为检索目的而设计的地标数据集。在 GLDv2 上训练的 DINO ViT 特征非常好，优于以前发布的基于现成描述符的方法 [65, 55]。</li><li>复制检测<br> 我们还评估了使用 DINO 训练的 ViT 在复制检测任务上的性能。我们报告了 INRIA Copydays 数据集 [20] 的“强”子集的平均精度。任务是识别因模糊、插入、打印和扫描等而失真的图像。根据先前的工作 [5]，我们添加了从 YFCC100M 数据集 [63] 中随机采样的 10k 个干扰图像。我们直接使用余弦相似度对从我们的预训练网络获得的特征进行复制检测。这些特征是作为输出 [CLS] 令牌和 GeM 池化 [52] 输出补丁令牌的串联获得的。这导致 ViT-B 的 1536d 描述符。在[5]之后，我们对特征应用白化。我们在来自 YFCC100M 的额外 20K 随机图像上学习了这种转换，与干扰项不同。表 4 显示使用 DINO 训练的 ViT 在复制检测方面非常有竞争力。<br> <img src="https://images2.imgbox.com/81/8b/I9GqbCeY_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="_85"></a>发现场景的语义布局</h4> 
<p>如图 1 中定性地显示，我们的自注意力图包含有关图像分割的信息。 在这项研究中，我们在标准基准上以及通过直接探测从这些注意力图生成的掩码的质量来测量此属性。</p> 
<ul><li> <p>视频实例分割<br> 在表5中，我们在 DAVIS-2017 视频实例分割基准 [50] 上评估输出补丁标记。我们遵循 Jabri 等人的实验协议[35] 并在连续帧之间用最近的邻居分割场景； 因此，我们不会在特征之上训练任何模型，也不会微调任务的任何权重。我们在 表5中观察即使我们的训练目标和我们的架构都是为密集任务而设计的，但在这个基准测试中的性能是有竞争力的。由于网络没有经过微调，模型的输出肯定保留了一些空间信息。最后，对于这个密集识别任务，带有小块（“/8”）的变体表现要好得多（对于 ViT-B，+9.1% (J &amp; F)m）。<br> <img src="https://images2.imgbox.com/0a/5d/QR1jwcWp_o.png" alt="在这里插入图片描述"></p> </li><li> <p>探索自注意力图<br> 在图 3 中，我们展示了不同的头部可以关注图像的不同语义区域，即使它们被遮挡（第三行的灌木丛）或很小（第二行的标志）。使用 480p 图像获得可视化，从而为 DeiT-S/8 生成 3601 个标记序列。在图 4 中，我们表明受监督的 ViT 在质量和数量上都不能很好地处理存在杂波的对象。我们报告了通过对自注意力图进行阈值处理以保持质量的 60% 获得的地面实况和分割掩码之间的 Jaccard 相似性。请注意，自注意力图是平滑的，并且没有经过优化以生成掩码。尽管如此，我们看到监督模型或 DINO 模型之间存在明显差异，在 Jaccard 相似性方面存在显着差异。请注意，自监督 convnets 也包含有关分割的信息，但它需要专门的方法从它们的权重中提取它 [29]。<br> <img src="https://images2.imgbox.com/fc/43/yVhUftEG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/06/d9/cWxAbxTA_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h4><a id="_96"></a>下游任务的迁移学习</h4> 
<p>在表6中，我们评估了在不同下游任务上使用 DINO 预训练的特征的质量。我们与在 ImageNet 上进行监督训练的相同架构的特征进行比较。我们遵循 Touvron 等人使用的协议[66] 并微调每个下游任务的特征。我们观察到，对于 ViT 架构，自监督预训练传输比通过监督训练的特征更好，这与对卷积网络的观察一致 [10, 31, 60]。最后，自我监督的预训练大大提高了 ImageNet 的结果（+1-2%）。<br> <img src="https://images2.imgbox.com/a1/ac/dTkPwWWj_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="DINO__100"></a>DINO 消融研究</h2> 
<p>在本节中，我们实证研究了应用于 ViT 的 DINO。整个研究考虑的模型是 DeiT-S。我们还请读者参阅附录以进行其他研究。</p> 
<h3><a id="_102"></a>不同组件的重要性</h3> 
<p>我们展示了从自我监督学习中添加不同组件对使用我们框架训练的 ViT 的影响。在表 7 中，我们在添加或删除组件时报告了不同的模型变体。首先，我们观察到在没有动量的情况下，我们的框架不起作用（第 2 行）并且需要更高级的操作，例如 SK，以避免崩溃（第 9 行）。但是，对于动量，使用 SK 几乎没有影响（第 3 行）。此外，比较第 3 行和第 9 行突出了动量编码器对性能的重要性。其次，在第 4 行和第 5 行，我们观察到多作物训练和 DINO 中的交叉熵损失是获得良好特征的重要组成部分。我们还观察到，向学生网络添加预测器几乎没有影响（第 6 行），而在 BYOL 中对于防止崩溃至关重要 [15, 28]。为完整起见，我们在附录 B 中提出了本消融研究的扩展版本。<br> <img src="https://images2.imgbox.com/b3/a4/rMIRg17g_o.png" alt="在这里插入图片描述"></p> 
<ul><li>补丁大小的重要性<br> 在图 5 中，我们比较了使用不同补丁大小（16 × 16、8 × 8 和 5 × 5）训练的 DeiT-S 模型的 k-NN 分类性能。我们还与具有 16 × 16 和 8 × 8 补丁的 ViT-B 进行了比较。所有模型都训练了 300 个 epoch。 我们观察到随着我们减小补丁的大小，性能大大提高。有趣的是，在不添加额外参数的情况下可以大大提高性能。然而，使用较小补丁带来的性能提升是以牺牲吞吐量为代价的：当使用 5×5 补丁时，吞吐量下降到 44 im/s，而 8×8 补丁为 180 im/s。<br> <img src="https://images2.imgbox.com/88/40/aF4sgF8f_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="_109"></a>教师网络选择的影响</h3> 
<p>在本次消融中，我们对不同的教师网络进行了实验，以了解其在 DINO 中的作用。我们比较使用 k-NN 协议训练 300 个时期的模型。</p> 
<ul><li>从学生中培养不同的教师<br> 在图 6（右）中，除了动量教师之外，我们比较了从学生的先前实例构建教师的不同策略。首先，我们考虑使用前一个时期的学生网络作为教师。该策略已在 Wu 等人的存储库中使用[70] 并作为 Caron 等人[8]和浅野等人[2]的一种硬蒸馏形式。其次，我们考虑使用上一次迭代中的学生网络，以及教师的学生副本。在我们的设置中，使用基于学生最新版本的老师并不会收敛。此设置需要更多的规范化才能工作。有趣的是，我们观察到使用前一时期的教师并没有崩溃，在 k-NN 评估中提供与现有框架（如 MoCo-v2 或 BYOL）竞争的性能。虽然使用动量编码器显然为这位天真的教师提供了卓越的性能，但这一发现表明，有空间来研究教师的替代方案。<br> <img src="https://images2.imgbox.com/16/18/FPcV9hmS_o.png" alt="在这里插入图片描述"></li><li>分析训练动态<br> 为了进一步了解动量教师在我们的框架中表现良好的原因，我们在图 6 的左侧面板中研究了 ViT 训练期间的动态。一个关键的观察结果是，这位老师在训练期间不断超越学生，我们在使用 ResNet-50（附录 D）进行训练时观察到相同的行为。这种行为还没有被其他也使用动量 [31, 28] 的框架观察到，也没有观察到教师是从前一个时期构建的。我们建议将 DINO 中的动量教师解释为一种具有指数衰减的 Polyak-Ruppert 平均形式 [49, 57]。Polyak-Ruppert 平均通常用于模拟模型集成，以在训练结束时提高网络的性能 [36]。我们的方法可以解释为在训练期间应用 Polyak-Ruppert 平均来不断构建具有卓越性能的模型集成。然后，该模型集成指导学生网络的训练 [62]。</li></ul> 
<h3><a id="_116"></a>避免崩溃</h3> 
<p>我们研究了居中和目标锐化的互补作用，以避免崩溃。崩溃有两种形式：不管输入如何，模型输出在所有维度上都是统一的，或者由一个维度主导。居中避免了由主导维度引起的崩溃，但鼓励了统一的输出。锐化会产生相反的效果。我们通过将交叉熵 H 分解为熵 h 和 Kullback-Leibler 散度（“KL”）DKL 来展示这种互补性：<br> <img src="https://images2.imgbox.com/69/07/1Eblqaiq_o.png" alt="在这里插入图片描述"><br> KL 为零表示输出恒定，因此会崩溃。在图 7 中，我们在训练期间绘制了带有和不带有居中和锐化的熵和 KL。如果缺少一个操作，KL 会收敛到零，表示崩溃。然而，熵 h 收敛到不同的值：0 没有中心化和 - log(1/K) 没有锐化，表明这两种操作都会导致不同形式的崩溃。应用这两种操作可以平衡这些影响（参见附录 D 中锐化参数 τt 的研究）。<br> <img src="https://images2.imgbox.com/9b/cb/CaLTlylC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_122"></a>计算要求</h3> 
<p>在选项卡中。 8，我们详细说明了在两台 8GPU 机器上运行 DeiT-S/16 DINO 模型时的时间和 GPU 内存要求。我们报告了多种裁剪训练变体的结果，每个变体都有不同级别的计算要求。我们在表8中观察使用 multi-crop 提高了 DINO 运行的准确性/运行时间权衡。例如，在没有多次裁剪（即 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         × 
        
       
         22 
        
        
        
          4 
         
        
          2 
         
        
       
      
        2×224^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> ）的情况下训练 46 小时后的性能为 72.5%，而在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         × 
        
       
         22 
        
        
        
          4 
         
        
          2 
         
        
       
         + 
        
       
         10 
        
       
         × 
        
       
         9 
        
        
        
          6 
         
        
          2 
         
        
       
      
        2×224^2+10×96^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.897438em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">9</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 裁剪设置下的 DINO 仅在 24 小时内达到 74.6%。尽管内存使用量更高（15.4G 与 9.3G），但这是 +2% 的改进，同时需要的时间减少了 2 倍。我们观察到，在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         × 
        
       
         22 
        
        
        
          4 
         
        
          2 
         
        
       
      
        2×224^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 设置中进行更多训练无法赶上 multi-crop 带来的性能提升，这显示了“局部到全局”增强的价值。最后，对于更长的训练，添加更多视图的收益会减少（从 6× 到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         10 
        
       
         × 
        
       
         9 
        
        
        
          6 
         
        
          2 
         
        
       
      
        10×96^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">9</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 的裁剪为 +.2%）。<br> <img src="https://images2.imgbox.com/74/97/vpjfQkZg_o.png" alt="在这里插入图片描述"></p> 
<p>总体而言，使用 Vision Transformers 训练 DINO 使用两台 8-GPU 服务器持续 3 天达到了 76.1 top-1 的准确率。该结果优于基于可比较大小的卷积网络的最先进的自监督系统，并显着减少了计算需求 [28, 10]。我们的代码可用于在有限数量的 GPU 上训练自监督 ViT。</p> 
<h3><a id="_127"></a>小批量训练</h3> 
<p>在表9中，我们研究了批量大小对使用 DINO 获得的特征的影响。我们还研究了在附录 D 中的等式4的中心更新规则中使用的平滑参数 m 的影响。我们随着批量大小 [27] 线性缩放学习率：lr = 0.0005 ∗ batchsize/256。表9 证实我们可以小批量训练模型以达到高性能。较小批量（bs = 128）的结果略低于我们默认的 bs = 1024 训练设置，并且肯定需要重新调整超参数，例如动量率。请注意，批量大小为 128 的实验仅在 1 个 GPU 上运行。我们探索了训练批大小为 8 的模型，在 50 轮后达到 35.2%，显示了训练每个 GPU 几乎不适合图像的大型模型的潜力。<br> <img src="https://images2.imgbox.com/35/60/GIh355G7_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_131"></a>结论</h2> 
<p>在这项工作中，我们展示了自监督预训练标准 ViT 模型的潜力，其性能可与专门为此设置设计的最佳卷积网络相媲美。我们还看到了两个可以在未来应用中利用的特性：k-NN 分类中特征的质量具有用于图像检索的潜力，其中 ViT 已经显示出有希望的结果 [21]。特征中关于场景布局的信息的存在也有利于弱监督图像分割。然而，本文的主要结果是我们有证据表明自监督学习可能是开发基于 ViT 的类 BERT 模型的关键。未来，我们计划探索在随机未经策划的图像上使用 DINO 预训练大型 ViT 模型是否可以突破视觉特征的极限 [26]。</p> 
<h2><a id="_133"></a>附录</h2> 
<h3><a id="A__134"></a>A. 附加结果</h3> 
<h4><a id="kNN_135"></a>k-NN分类</h4> 
<p>在表10中，我们使用两种评估协议评估由 ResNet-50 或 DeiT-small 给出的冻结表示，使用 DINO 进行预训练：线性或 k-NN。对于这两种评估，我们从预先训练的网络中提取表示，而不使用任何数据增强。然后，我们使用加权 k-NN 或使用 cyanure 库 [43] 学习的线性回归进行分类。在表10中 我们看到 DeiT-S 的精度优于使用 RN50 获得的精度，无论是使用线性还是 k-NN 分类器。然而，使用 k-NN 评估时的性能差距比考虑线性评估时要大得多。例如，在 ImageNet 1% 上，DeiT-S 在 k-NN 评估中以 +14.1% 的大幅优势优于 ResNet-50。这表明使用 DINO 训练的 Transformer 架构可能会提供更多的模型灵活性，有利于 k-NN 评估。K-NN 分类器具有部署快速、轻便的巨大优势，无需任何域适应。总的来说，用 DINO 训练的 ViT 提供了与 k-NN 分类器结合得特别好的特征。<br> <img src="https://images2.imgbox.com/ba/48/qfwqcd1U_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="ViT__ImageNet__138"></a>ViT 的自监督 ImageNet 预训练</h4> 
<p>在这个实验中，我们研究了用我们的方法预训练一个有监督的 ViT 模型的影响。在表11 中，我们比较了使用不同预训练初始化或在训练期间引导的监督 ViT 模型的性能与额外的预训练卷积网络。第一组模型在由 300M 图像组成的大型策划数据集上进行预训练和不监督。第二组模型通过来自预训练的监督 RegNetY [54] 的硬知识蒸馏进行训练。最后一组模型不使用任何额外的数据或模型，并且随机初始化或在 ImageNet 上使用 DINO 进行预训练后初始化。与随机初始化相比，使用 DINO 进行预训练可带来 +1% 的性能提升。这不是由更长的训练造成的，因为使用监督而不是 DINO 进行预训练不会提高性能。使用自监督预训练减少了与在额外数据上预训练或从卷积网络中提取的模型之间的差距。<br> <img src="https://images2.imgbox.com/70/2f/LmHjLrEP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="ImageNet__141"></a>ImageNet 上的低样本学习</h4> 
<p>我们在低样本学习中评估了在 DeiT-S 上应用 DINO 获得的特征。在表12，我们报告了在具有 1% 和 10% 标签的冻结特征 (FROZEN) 上训练的逻辑回归的验证准确性。逻辑回归使用 cyanure 库 [43] 进行训练。当比较具有相似数量参数和图像/秒的模型时，我们观察到我们的特征与最先进的半监督模型相当。有趣的是，这种性能是通过在冻结特征上训练多类逻辑回归获得的，没有数据增强或微调。<br> <img src="https://images2.imgbox.com/84/78/YjZkvubm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="B__144"></a>B. 方法比较</h3> 
<p>我们比较了不同自监督框架 MoCo-v2 [14]、SwAV [10] 和 BYOL [28] 在使用 convnet 或 ViT 时的性能。在表13，我们看到当使用 ResNet-50 (convnet) 训练时，DINO 的性能与 SwAV 和 BYOL 相当。然而，DINO 利用 DeiT-S (ViT) 发挥其潜力，大幅超越 MoCo-v2、SwAV 和 BYOL（线性评估 +4.3%，k-NN 评估 +6.2%）。在本节的其余部分，我们进行消融以更好地了解应用于 ViT 的 DINO 的性能。特别是，我们提供了与使用动量编码器的方法（即 MoCo-v2 和 BYOL）和使用 multicrop 的方法（即 SwAV）的详细比较。<br> <img src="https://images2.imgbox.com/b6/0e/EwtdLeww_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_SwAV__147"></a>与 SwAV 的关系</h4> 
<p>在表14，我们评估 DINO 和 SwAV 之间的差异：动量编码器的存在和教师输出之上的操作。在没有动量的情况下，使用具有停止梯度的学生副本。我们考虑对教师输出的三个操作：居中、Sinkhorn-Knopp 或沿批处理轴的 Softmax。Softmax 类似于单个 Sinkhorn-Knopp 迭代，如下一段所述。首先，这些消融表明使用动量编码器显着提高了 ViT 的性能（3 对 6，2 对 5）。其次，当仅使用居中（第 1 行）时，动量编码器也可以避免崩溃。在没有动力的情况下，将输出居中不起作用 (4) 并且需要更高级的操作 (5, 6)。总的来说，这些消融突出了动量编码器的重要性，不仅对性能而且对稳定训练，消除了除居中之外的归一化的需要。<br> <img src="https://images2.imgbox.com/c6/28/vzcmrgzg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Softmaxbatch__150"></a>Softmax(batch) 变体的详细信息</h4> 
<p>SwAV [10] 中使用的迭代 Sinkhorn-Knopp 算法 [16] 仅使用以下 PyTorch 样式代码实现。<br> <img src="https://images2.imgbox.com/80/ef/dgyOtIkV_o.png" alt="在这里插入图片描述"><br> 我们已经在表14中看到了这种高度简化的 SwAV 变体可与 SwAV 竞争。直观地说，批处理轴上的 softmax 操作允许为每个维度（或“集群”）选择它在批处理中的最佳匹配。</p> 
<h4><a id="_MoCov2__BYOL__154"></a>与 MoCo-v2 和 BYOL 的关系</h4> 
<p>在表15，我们展示了 DINO、MoCo-v2 和 BYOL 之间不同的消融组件的影响：损失的选择、学生头中的预测器、居中操作、投影头中的批量归一化，最后，多 作物增产。DINO 中的损失是锐化的 softmax 输出 (CE) 上的交叉熵，而 MoCo-v2 使用 InfoNCE 对比损失 (INCE)，而 BYOL 是 l2 归一化输出 (MSE) 上的均方误差。MSE 标准不应用锐化。 尽管如此，当将损失函数更改为 MSE 时，DINO 令人惊讶地仍然有效，但这显着改变了性能（参见第 (1, 2) 和 (4, 9) 行）。我们还观察到添加预测器几乎没有影响 (1, 3)。然而，在 BYOL 的情况下，预测因子对于防止崩溃至关重要 (7, 8)，这与之前的研究一致 [15, 28]。有趣的是，我们观察到教师输出居中避免了 BYOL 中没有预测器或批量归一化的崩溃 (7, 9)，尽管性能显着下降，这可能是因为我们的居中运算符旨在与锐化结合使用 。最后，我们观察到 multi-crop 与 DINO 和 MoCo-v2 配合得特别好，移除它会降低 2 - 4% 的性能（1 对 4 和 5 对 6）。如附录 E 中详述的那样，向 BYOL 中添加 multi-crop 不能立即生效 (7, 10)，可能需要进一步调整。<br> <img src="https://images2.imgbox.com/96/70/43t514Na_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_157"></a>验证我们的实施</h4> 
<p>从表13中观察到 我们对 BYOL、MoCo-v2、SwAV 的复制与使用 ResNet-50 的相应发布数字相匹配或优于相应的发布数字。事实上，我们获得了 72.7% 的 BYOL，而 [28] 在这个 300 epochs 设置中报告了 72.5%。我们在 300 轮训练后获得了 71.1% 的 MoCo，而 [14] 在 800 轮训练后报告了 71.1%。与 [14] 的实现相比，我们的改进可以通过使用更大的投影头（3 层，使用批标准化和 256 的投影维度）来解释。</p> 
<h4><a id="_CsMI_159"></a>并发工作 CsMI</h4> 
<p>并发工作 CsMI [74] 在 ImageNet 上使用简单的 k-NN 分类器也表现出强大的性能，即使使用 convnets。作为 DINO，CsMI 结合了动量网络和多作物训练，我们已经看到，在我们的 ViT 实验中，这对于良好的 k-NN 性能至关重要。我们相信研究这项工作将帮助我们更准确地识别对良好 k-NN 性能很重要的组件，并将这项调查留给未来的工作。</p> 
<h3><a id="C__161"></a>C. 投影头</h3> 
<p>与其他自监督框架类似，使用投影头 [12] 大大提高了我们方法的准确性。投影头从一个 n 层多层感知器 (MLP) 开始。隐藏层为 2048d，并使用高斯误差线性单元 (GELU) 激活。MLP 的最后一层没有 GELU。然后我们应用`2 归一化和权重归一化的全连接层 [15, 59] 与 K 维。这种设计的灵感来自于 SwAV [10] 中使用的带有“原型层”的投影头。 我们不应用批量标准化。</p> 
<h4><a id="BN_163"></a>无BN系统</h4> 
<p>与标准 convnet 不同，ViT 架构默认不使用批量归一化 (BN)。因此，当将 DINO 应用于 ViT 时，我们也不在投影头中使用任何 BN。在此表中，我们评估了在磁头中添加 BN 的影响。我们观察到在投影头中添加 BN 几乎没有影响，这表明 BN 在我们的框架中并不重要。总的来说，在将 DINO 应用于 ViT 时，我们不会在任何地方使用任何 BN，使系统完全没有 BN。这是 DINO + ViT 的一大优势，无需任何 BN 即可以最先进的性能工作。事实上，使用 BN 进行训练通常会大大减慢训练速度，尤其是当这些 BN 模块需要跨进程同步时 [31, 10, 9, 28]。<br> <img src="https://images2.imgbox.com/b0/3c/rUxhVIe4_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_L2__166"></a>投影头中的 L2 归一化瓶颈</h4> 
<p>我们在图 9 中说明了带有或不带有 l2normalization 瓶颈的投影头的设计。我们评估了在有或没有 l2 归一化瓶颈的情况下训练的 DINO 模型的准确性，并改变了投影头中线性层的数量。使用 l2 瓶颈时，线性层的总数为 n + 1（n 来自 MLP，1 来自权重归一化层），而没有瓶颈时，头部的线性层总数为 n。在此表中，我们报告了使用 DeiT-S/16 进行 100 轮预训练后的 ImageNet top-1 k-NN 评估准确度。在本实验中，输出维度 K 设置为 4096。我们观察到，当增加投影头的深度时，DINO 训练在没有 l2 归一化瓶颈的情况下失败。L2 归一化瓶颈用深度投影头稳定 DINO 的训练。我们观察到增加投影头的深度会提高精度。我们的默认设置是总共使用 4 个线性层：3 个在 MLP 中，一个在 l2 瓶颈之后。<br> <img src="https://images2.imgbox.com/3d/21/YrzsTGIl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1f/b4/a6TnBznS_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_170"></a>输出维度</h4> 
<p>在此表中，我们评估了改变输出维度 K 的影响。我们观察到大的输出维度提高了性能。我们注意到使用 l2 归一化瓶颈允许使用大输出维度，同时适度增加参数总数。我们的默认值是使用 K 等于 65536 和 d = 256 作为瓶颈。<br> <img src="https://images2.imgbox.com/75/6a/OPCUnjDd_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="GELU__173"></a>GELU 激活</h4> 
<p>默认情况下，ViT 中使用的激活是高斯误差线性单位 (GELU)。因此，为了架构内的一致性，我们选择在投影头中也使用 GELU。我们在此表中评估了使用 ReLU 代替 GELU 的效果，并观察到将激活单元更改为 ReLU 的影响相对较小。<br> <img src="https://images2.imgbox.com/6e/c1/RgOdaaGT_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="D__176"></a>D. 额外的消融</h3> 
<p>我们在主要论文中详细说明了居中和锐化的结合对于避免 DINO 崩溃很重要。我们在下面消除了这两个操作的超参数。我们还研究了训练长度的影响和 ViT 网络的一些设计选择。</p> 
<h4><a id="_178"></a>在线对中</h4> 
<p>我们研究了更新规则中平滑参数对教师网络输出中使用的中心 c 的影响。收敛性对大范围的平滑具有鲁棒性，并且模型仅在更新太慢时才会崩溃，即 m = 0.999。<br> <img src="https://images2.imgbox.com/e5/d7/RnDRZrGY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_181"></a>锐化</h4> 
<p>我们通过调整教师 softmax 温度参数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          τ 
         
        
          t 
         
        
       
      
        τ_t 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-left: -0.1132em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 来强制执行锐化目标。在此表中，我们观察到需要低于 0.06 的温度才能避免坍塌。当温度高于 0.06 时，训练损失始终收敛到 ln(K)。但是，我们观察到，如果我们从较小的值开始训练并在第一个时期增加它，则使用高于 0.06 的温度不会崩溃。在实践中，我们在训练的前 30 个 epoch 期间使用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          τ 
         
        
          t 
         
        
       
      
        τ_t 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-left: -0.1132em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>从 0.04 到 0.07 的线性热身。最后，请注意 τ → 0（极端锐化）对应于 argmax 操作并导致 one-hot hard 分布。<br> <img src="https://images2.imgbox.com/58/7c/NUTHofGA_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_184"></a>更长的训练</h4> 
<p>我们在此表中观察到，更长的训练提高了应用于 DeiTSmall 的 DINO 的性能。这一观察结果与使用卷积架构获得的自监督结果一致 [12]。我们注意到，在我们在 DeiT-S 上使用 BYOL 进行的实验中，与我们运行的 300 个 epoch 相比，超过 300 个 epoch 的训练导致性能更差。出于这个原因，我们在表 2 中报告了 300 个周期的 BYOL，而 SwAV、MoCov2 和 DINO 训练了 800 个周期。<br> <img src="https://images2.imgbox.com/22/01/AkcWOXbR_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_188"></a>老师胜过学生</h4> 
<p>我们在图 6 中表明，使用 ViT 时动量教师的表现优于学生，我们在此图中表明，使用 ResNet-50 时也是如此。教师不断超越学生这一事实进一步鼓励了将 DINO 解释为“平均教师”[62] 自我蒸馏的一种形式。事实上，正如 Tarvainen 等人 [62] 所提出的，权重平均通常会产生比每次迭代中的单个模型更好的模型 [49]。通过瞄准老师比学生更好的目标，学生的表现得到改善。因此，教师也有所改进，因为它是直接根据学生权重构建的。</p> 
<h4><a id="_191"></a>来自监督与自监督学习的自注意力图</h4> 
<p>我们评估通过阈值化自注意力图获得的掩码以保持 80% 的质量。我们比较了使用不同框架训练的不同 DeiT-S 的 PASCAL VOC12 数据集验证图像上的真实情况和这些掩码之间的 Jaccard 相似性。来自 ViT 的自注意力映射的属性明确包含场景布局，特别是在不同的自监督方法中观察到的对象边界。<br> <img src="https://images2.imgbox.com/5c/3c/4rbBa0Bp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="DeiTS__194"></a>DeiT-S 中正面数量的影响</h4> 
<p>我们研究了 DeiT-S 中头部数量对准确性和吞吐量（在单个 V100 GPU 上推理时每秒处理的图像）的影响。我们发现增加头数量可以提高性能，但代价是吞吐量略有下降。在我们的论文中，所有实验都使用 [66] 中提供的默认模型运行，即只有 6 个头。<br> <img src="https://images2.imgbox.com/1c/e6/bsj61fDf_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="E_198"></a>E.多层裁剪</h3> 
<p>在本附录中，我们研究了 DINO 的核心组成部分：多层裁剪训练 [10]。</p> 
<h4><a id="_200"></a>多层裁剪的尺度范围</h4> 
<p>为了生成不同的视图，我们使用 PyTorch 中 torchvision.transforms 模块中的 RandomResizedCrop 方法。我们对两个缩放范围为 (s, 1) 的全局视图进行采样，然后将它们调整为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         22 
        
        
        
          4 
         
        
          2 
         
        
       
      
        224^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 和 6 个缩放范围为 (0.05, s) 的局部视图缩放为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         9 
        
        
        
          6 
         
        
          2 
         
        
       
      
        96^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">9</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 像素。请注意，我们按照 SwAV 的原始设计任意选择全局和局部视图的非重叠缩放范围。然而，范围肯定会重叠，并且尝试更精细的超参数搜索可能会导致更优化的设置。在此表中，我们改变了控制多层裁剪中使用的尺度范围的参数 s，并在我们的实验中找到了 0.3 左右的最佳值。我们注意到这高于 SwAV 中使用的参数 0.14。<br> <img src="https://images2.imgbox.com/67/f3/gxrq3DyT_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_203"></a>不同自监督框架中的多重裁剪</h4> 
<p>我们比较了不同的近期自监督学习框架，即 MoCo-v2 [14]、BYOL [28] 和 SwAV [10] 与 DeiT-S/16 架构。为了公平比较，所有模型都使用两个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         22 
        
        
        
          4 
         
        
          2 
         
        
       
      
        224^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 作物或多作物 [10] 训练进行预训练，即每个图像有两个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         22 
        
        
        
          4 
         
        
          2 
         
        
       
      
        224^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 作物和六个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         9 
        
        
        
          6 
         
        
          2 
         
        
       
      
        96^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">9</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 作物。我们报告了 300 轮训练后的 k-NN 和线性探测评估。Multi-crop 并没有平等地使所有框架受益，在仅考虑两种裁剪设置的基准测试中忽略了这一点 [15]。multi-crop 的有效性取决于所考虑的框架，该框架将 multi-crop 定位为模型的核心组件，而不是简单的“附加组件”，可以以相同的方式提升任何框架。在没有多重裁剪的情况下，DINO 比其他框架具有更好的准确性，尽管幅度适中（1%）。值得注意的是，DINO 从多重裁剪训练中获益最多（线性评估中 +3.4%）。有趣的是，我们还观察到框架的排名取决于所考虑的评估协议。<br> <img src="https://images2.imgbox.com/c8/14/1SNAES82_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_BYOL_206"></a>使用多重裁剪训练 BYOL</h4> 
<p>当使用 DeiT-S 将 multicrop 应用于 BYOL 时，我们观察到传输性能高于第一个训练时期没有 multi-crop 的基线。但是，在经过一定的训练后，传输性能的增长速度正在放缓并下降。我们已经为此设置执行了学习率、权重衰减、多裁剪参数扫描，并系统地观察了相同的模式。更准确地说，我们用 {1e -5 , 3e -5 , 1e -4 , 3e -4 , 1e -3 , 3e -3} 实验学习率基值，{0.02, 0.05, 0.1} 用于权重衰减和 不同数量的小裁剪：{2, 4, 6}。我们所有的运行都是在头部同步批量归一化的情况下进行的。当使用低学习率时，我们没有观察到性能断点，即在训练过程中迁移性能不断提高，但整体准确率较低。我们已经在 ResNet-50 上尝试了多重裁剪训练，我们也观察到了相同的行为。由于将多重裁剪训练整合到 BYOL 不是本研究的重点，我们没有进一步推动这个方向。然而，我们认为这值得研究，为什么在我们的实验中 multi-crop 不能与 BYOL 很好地结合，并将其留作未来的工作。<br> <img src="https://images2.imgbox.com/e7/91/jtzIwOgF_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="F__209"></a>F. 评估协议</h3> 
<h4><a id="F1_kNN__210"></a>F.1 k-NN 分类</h4> 
<p>遵循 Wu 等人 [70] 的设置，我们使用一个简单的加权 k 最近邻分类器来评估特征的质量。我们冻结预训练模型来计算和存储下游任务的训练数据的特征。为了对测试图像 x 进行分类，我们计算其表示并将其与所有存储的训练特征 T 进行比较。图像的表示由输出 [CLS] 标记给出：DeiT-S 的维数为 d = 384，ViT-B 的维数为 d = 768。顶部 kNN（表示为 Nk）用于通过加权投票进行预测。具体来说，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
      
        c 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span> 类得到的总权重为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          ∑ 
         
         
         
           i 
          
         
           ∈ 
          
          
          
            N 
           
          
            k 
           
          
         
        
        
        
          α 
         
        
          i 
         
        
        
        
          l 
         
         
          
          
            c 
           
          
            i 
           
          
         
           = 
          
         
           c 
          
         
        
       
      
        \sum_{i \in N_k}\alpha_i l_{c_i=c} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.15557em; vertical-align: -0.40557em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.178621em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.34877em; margin-left: -0.10903em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.151229em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.40557em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.0037em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.01968em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328086em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2501em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          α 
         
        
          i 
         
        
       
      
        α_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.0037em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 为贡献权重。我们使用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          α 
         
        
          i 
         
        
       
         = 
        
       
         e 
        
       
         x 
        
       
         p 
        
       
         ( 
        
        
        
          T 
         
        
          i 
         
        
       
         x 
        
       
         / 
        
       
         τ 
        
       
         ) 
        
       
      
        α_i = exp(T_ix/τ ) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.0037em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right: 0.1132em;">τ</span><span class="mclose">)</span></span></span></span></span>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         τ 
        
       
      
        τ 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.1132em;">τ</span></span></span></span></span> 等于 0.07，如在 [70] 中我们没有调整。我们评估 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span> 的不同值，发现 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         = 
        
       
         20 
        
       
      
        k = 20 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></span> 在我们的运行中始终导致最佳准确度。该评估协议不需要超参数调整，也不需要数据增强，并且只需通过下游数据集即可运行。</p> 
<h4><a id="F2__212"></a>F.2 线性分类</h4> 
<p>遵循自监督学习中的常见做法，我们使用线性分类器评估表示质量。投影头被移除，我们在冻结特征之上训练一个有监督的线性分类器。该线性分类器在 ImageNet 上的 100 个 epoch 期间使用 SGD 和 1024 的批大小进行训练。我们不应用重量衰减。对于每个模型，我们扫描学习率值。在训练期间，我们仅应用随机调整大小的裁剪（使用来自 PyTorch RandomResizedCrop 的默认参数）和水平翻转作为数据增强。我们报告了 centralcrop top-1 的准确性。在评估 convnet 时，通常的做法是在线性分类器之前对最终特征图执行全局平均池化。在下文中，我们将描述在评估 ViT 时如何调整此设计。</p> 
<ul><li>线性评估的 DeiT-S 表示<br> 遵循 BERT [17] 中基于特征的评估，我们连接来自最后<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          l 
         
        
       
         l 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span></span></span></span></span> 层的 [CLS] 令牌。我们尝试连接不同数量的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          l 
         
        
       
         l 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span></span></span></span></span> 层，与 [17] 类似，我们发现 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          l 
         
        
          = 
         
        
          4 
         
        
       
         l = 4 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span></span></span></span></span> 是最佳的。<br> <img src="https://images2.imgbox.com/ea/fe/IWTHVN7o_o.png" alt="在这里插入图片描述"></li><li>线性评估的 ViT-B 表示<br> 使用 ViT-B，我们没有发现将最后 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          l 
         
        
       
         l 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span></span></span></span></span> 层的表示连接起来以提供任何性能增益，并且只考虑最后一层 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
        
          l 
         
        
          = 
         
        
          1 
         
        
          ) 
         
        
       
         (l = 1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。在此设置中，我们通过对输出补丁标记的全局平均池化来调整 convnets 中使用的管道。我们将这些汇集的特征连接到最终的 [CLS] 输出标记。<br> <img src="https://images2.imgbox.com/cf/8e/l9TSygUV_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="G__220"></a>G. 自注意力可视化</h3> 
<p>我们在图 8 和图 10 中提供了更多的自我注意可视化。图像是从 COCO 验证集中随机选择的，在 DINO 训练期间不使用。在图 8 中，我们展示了来自 DINO DeiT-S/8 最后一层的几个参考点的自注意力。<br> <img src="https://images2.imgbox.com/74/03/imqNTg4F_o.png" alt="在这里插入图片描述"></p> 
<figure> 
 <img src="https://images2.imgbox.com/bc/dc/wyRY2zJw_o.png"> 
 <img src="https://images2.imgbox.com/90/9f/8Wx0qEHN_o.png"> 
 <img src="https://images2.imgbox.com/13/33/ReP5wdJS_o.png"> 
</figure> ## H. 类别表示 作为最终的可视化，我们建议查看来自 DINO 的特征空间中 ImageNet 概念的分布。我们用验证图像的平均特征向量表示每个 ImageNet 类。我们使用 PCA 将这些特征的维度降低到 30，并以 20 的困惑度运行 t-SNE，5000 次迭代的学习率为 200。我们在图 11 中展示了生成的类嵌入。我们的模型恢复了类之间的结构：相似的动物物种被分组在一起，形成了连贯的鸟类（顶部）或狗群，尤其是梗犬（最右侧）。 
<figure> 
 <img src="https://images2.imgbox.com/26/9f/AuxSMakc_o.png"> 
 <img src="https://images2.imgbox.com/e8/2c/13rPQrNW_o.png"> 
</figure>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2694bac1b9027c8b79aa79c1d3622c6d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VNC SERVER 安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec64704e1b0b1ff141b5cd5673d08845/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">禁用Windows Defender Antivirus Service</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>