<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>干货：五分钟带你看懂NestedScrolling嵌套滑动机制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="干货：五分钟带你看懂NestedScrolling嵌套滑动机制" />
<meta property="og:description" content="Android NestedScrolling嵌套滑动机制 Android在发布5.0之后加入了嵌套滑动机制NestedScrolling,为嵌套滑动提供了更方便的处理方案。在此对嵌套滑动机制进行详细的分析。
嵌套滑动的常见用法比如在滑动列表的时候隐藏相关的TopBar和BottomBar，增加列表的信息展示范围，让用户聚焦于App想展示的内容上等。官方出的Design包里也有很多支持该机制的炫酷控件，比如CoordinatorLayout，AppBarLayout等，在用户体验上有很大的进步。
说道嵌套滑动，离不开以下几个内容：
NestedScrollingChildNestedScrollingParentNestedScrollingChildHelperNestedScrollingParentHelper 在具体说明之前，先来看看我们的Sample，这是一个仿携程机票首页的Demo
这里用到了一个实现了NestedScrollingParent的CollaspingLayout作为父View和一个实现了NestedScrollingChild的NestedScrollView作为子View进行嵌套滑动，布局可以简单的描述成：
具体的布局结构大致如下： &lt;com.lycc.flight.fastproject.widget.search.CollaspingLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34; android:orientation=&#34;vertical&#34; android:id=&#34;@&#43;id/pl_container&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34;&gt; &lt;RelativeLayout android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;160dp&#34;&gt; &lt;com.yyydjk.library.BannerLayout android:id=&#34;@&#43;id/banner&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;160dp&#34; app:autoPlayDuration=&#34;5000&#34; app:indicatorMargin=&#34;50dp&#34; app:indicatorPosition=&#34;centerBottom&#34; app:indicatorShape=&#34;oval&#34; app:indicatorSpace=&#34;3dp&#34; app:scrollDuration=&#34;1100&#34; app:defaultImage=&#34;@mipmap/ic_launcher&#34; app:selectedIndicatorColor=&#34;?attr/colorPrimary&#34; app:selectedIndicatorHeight=&#34;6dp&#34; app:selectedIndicatorWidth=&#34;6dp&#34; app:unSelectedIndicatorColor=&#34;#99ffffff&#34; app:unSelectedIndicatorHeight=&#34;6dp&#34; app:unSelectedIndicatorWidth=&#34;6dp&#34; app:layout_collapseMode=&#34;parallax&#34; app:layout_collapseParallaxMultiplier=&#34;0.7&#34;/&gt; &lt;View android:id=&#34;@&#43;id/view&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;40dp&#34; android:background=&#34;@drawable/gradient&#34; /&gt; &lt;FrameLayout android:id=&#34;@&#43;id/search_tab_container&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;43dp&#34; android:layout_marginBottom=&#34;-4dp&#34; android:layout_alignParentBottom=&#34;true&#34;&gt; &lt;View android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;40dp&#34; android:background=&#34;#5a000000&#34; android:layout_marginLeft=&#34;5dp&#34; android:layout_marginTop=&#34;3dp&#34; android:layout_marginBottom=&#34;-4dp&#34; android:layout_marginRight=&#34;5dp&#34;/&gt; &lt;LinearLayout android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;wrap_content&#34; android:gravity=&#34;bottom&#34; android:layout_marginBottom=&#34;-4dp&#34; android:layout_marginLeft=&#34;5dp&#34; android:layout_marginRight=&#34;5dp&#34; android:orientation=&#34;horizontal&#34;&gt; &lt;View android:id=&#34;@&#43;id/slide_bg&#34; android:layout_width=&#34;120dp&#34; android:layout_height=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/346dda0b67c02fc550dba6ce668c5a50/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-11-03T13:10:38+08:00" />
<meta property="article:modified_time" content="2016-11-03T13:10:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">干货：五分钟带你看懂NestedScrolling嵌套滑动机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <h3 id="android-nestedscrolling-">Android NestedScrolling嵌套滑动机制</h3> 
 <p>Android在发布5.0之后加入了嵌套滑动机制NestedScrolling,为嵌套滑动提供了更方便的处理方案。在此对嵌套滑动机制进行详细的分析。</p> 
 <p>嵌套滑动的常见用法比如在滑动列表的时候隐藏相关的TopBar和BottomBar，增加列表的信息展示范围，让用户聚焦于App想展示的内容上等。官方出的Design包里也有很多支持该机制的炫酷控件，比如CoordinatorLayout，AppBarLayout等，在用户体验上有很大的进步。</p> 
 <p>说道嵌套滑动，离不开以下几个内容：</p> 
 <ul><li>NestedScrollingChild</li><li>NestedScrollingParent</li><li>NestedScrollingChildHelper</li><li>NestedScrollingParentHelper</li></ul> 
 <p>在具体说明之前，先来看看我们的Sample，这是一个仿携程机票首页的Demo<br></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p>这里用到了一个实现了NestedScrollingParent的CollaspingLayout作为父View和一个实现了NestedScrollingChild的NestedScrollView作为子View进行嵌套滑动，布局可以简单的描述成：<br></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <br>具体的布局结构大致如下： 
 <pre><code class="hljs javascript copyable">&lt;com.lycc.flight.fastproject.widget.search.CollaspingLayout xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    xmlns:app=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>
    android:orientation=<span class="hljs-string">"vertical"</span>
    android:id=<span class="hljs-string">"@+id/pl_container"</span>
    android:layout_width=<span class="hljs-string">"match_parent"</span>
    android:layout_height=<span class="hljs-string">"match_parent"</span>&gt;
    &lt;RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="160dp"&gt;
        &lt;com.yyydjk.library.BannerLayout
            android:id="@+id/banner"
            android:layout_width="match_parent"
            android:layout_height="160dp"
            app:autoPlayDuration="5000"
            app:indicatorMargin="50dp"
            app:indicatorPosition="centerBottom"
            app:indicatorShape="oval"
            app:indicatorSpace="3dp"
            app:scrollDuration="1100"
            app:defaultImage="@mipmap/ic_launcher"
            app:selectedIndicatorColor="?attr/colorPrimary"
            app:selectedIndicatorHeight="6dp"
            app:selectedIndicatorWidth="6dp"
            app:unSelectedIndicatorColor="#99ffffff"
            app:unSelectedIndicatorHeight="6dp"
            app:unSelectedIndicatorWidth="6dp"
            app:layout_collapseMode="parallax"
            app:layout_collapseParallaxMultiplier="0.7"/&gt;
        &lt;View
            android:id="@+id/view"
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:background="@drawable/gradient" /&gt;
        &lt;FrameLayout
            android:id="@+id/search_tab_container"
            android:layout_width="match_parent"
            android:layout_height="43dp"
            android:layout_marginBottom="-4dp"
            android:layout_alignParentBottom="true"&gt;
            &lt;View
                android:layout_width="match_parent"
                android:layout_height="40dp"
                android:background="#5a000000"
                android:layout_marginLeft="5dp"
                android:layout_marginTop="3dp"
                android:layout_marginBottom="-4dp"
                android:layout_marginRight="5dp"/&gt;
            &lt;LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="bottom"
                android:layout_marginBottom="-4dp"
                android:layout_marginLeft="5dp"
                android:layout_marginRight="5dp"
                android:orientation="horizontal"&gt;

                &lt;View
                    android:id="@+id/slide_bg"
                    android:layout_width="120dp"
                    android:layout_height="43dp"
                    android:background="@drawable/ctrip_slide_tab"/&gt;
            &lt;/LinearLayout&gt;
            &lt;RadioGroup
                android:id="@+id/rg_slide"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:orientation="horizontal"
                android:gravity="center"
                android:layout_centerInParent="true"&gt;

                &lt;RadioButton
                    android:id="@+id/rb_left"
                    android:background="@null"
                    android:textColor="@color/top_layout_sliide_text_color_selector"
                    android:gravity="center"
                    android:button="@null"
                    android:textSize="16dp"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:checked="false"
                    android:text="单程" /&gt;

                &lt;RadioButton
                    android:id="@+id/rb_center"
                    android:background="@null"
                    android:textColor="@color/top_layout_sliide_text_color_selector"
                    android:gravity="center"
                    android:textSize="16dp"
                    android:button="@null"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="往返" /&gt;

                &lt;RadioButton
                    android:id="@+id/rb_right"
                    android:background="@null"
                    android:button="@null"
                    android:textColor="@color/top_layout_sliide_text_color_selector"
                    android:gravity="center"
                    android:textSize="16dp"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:singleLine="true"
                    android:text="多程"
                    android:visibility="visible" /&gt;
            &lt;/RadioGroup&gt;


        &lt;/FrameLayout&gt;
        &lt;LinearLayout
            android:id="@+id/top_container"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:minHeight="?attr/actionBarSize"
            android:orientation="horizontal"
            android:visibility="gone"
            android:gravity="center"
            android:layout_alignParentTop="true"
            app:layout_collapseMode="pin"
            android:background="@color/ctirp_color_primary"&gt;
            &lt;RadioGroup
                android:layout_width="261dp"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center"
                android:layout_centerInParent="true"&gt;

                &lt;RadioButton
                    android:background="@drawable/title_left_shape"
                    android:padding="6dp"
                    android:textColor="@color/top_layout_text_color_selector"
                    android:gravity="center"
                    android:button="@null"
                    android:textSize="16dp"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:checked="true"
                    android:text="单程" /&gt;

                &lt;RadioButton
                    android:background="@drawable/title_center_shape"
                    android:padding="6dp"
                    android:textColor="@color/top_layout_text_color_selector"
                    android:gravity="center"
                    android:textSize="16dp"
                    android:button="@null"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:layout_marginLeft="-1dp"
                    android:layout_marginRight="-1dp"
                    android:text="往返" /&gt;

                &lt;RadioButton
                    android:background="@drawable/title_right_shape"
                    android:padding="6dp"
                    android:button="@null"
                    android:textColor="@color/top_layout_text_color_selector"
                    android:gravity="center"
                    android:textSize="16dp"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:singleLine="true"
                    android:text="多程"
                    android:visibility="visible" /&gt;
            &lt;/RadioGroup&gt;
        &lt;/LinearLayout&gt;
    &lt;/RelativeLayout&gt;
    &lt;android.support.v4.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt;

        &lt;ImageView
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:src="@drawable/search_bg"
            android:scaleType="fitStart"/&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/com.lycc.flight.fastproject.widget.search.CollaspingLayout&gt;<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>从布局可以看到其实在实现了NestedScrollingParent之后就能很方便的完成子View和父View的嵌套滑动，下面就来简单看看上面的四个类是如何使用的,在系统为我们提供的控件中，NestedScrollView是实现了这个机制的控件，以它的实现为例，首先看作为嵌套滑动的子View:</p> 
 <pre><code class="hljs javascript copyable">        <span class="hljs-comment">// NestedScrollingChild</span>
        @Override
        public <span class="hljs-keyword">void</span> setNestedScrollingEnabled(boolean enabled) {
                mChildHelper.setNestedScrollingEnabled(enabled);
        }
        @Override
        public boolean isNestedScrollingEnabled() {
                <span class="hljs-keyword">return</span> mChildHelper.isNestedScrollingEnabled();
        }
        @Override
        public boolean startNestedScroll(int axes) {
                <span class="hljs-keyword">return</span> mChildHelper.startNestedScroll(axes);
        }
        @Override
        public <span class="hljs-keyword">void</span> stopNestedScroll() {
                mChildHelper.stopNestedScroll();
        }
        @Override
        public boolean hasNestedScrollingParent() {
                <span class="hljs-keyword">return</span> mChildHelper.hasNestedScrollingParent();
        }
        @Override
        public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed,
                                            int dyUnconsumed, int[] offsetInWindow) {
                <span class="hljs-keyword">return</span> mChildHelper.dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed,
                        offsetInWindow);
        }
        @Override
        public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) {
                <span class="hljs-keyword">return</span> mChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);
        }
        @Override
        public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) {
                <span class="hljs-keyword">return</span> mChildHelper.dispatchNestedFling(velocityX, velocityY, consumed);
        }
        @Override
        public boolean dispatchNestedPreFling(float velocityX, float velocityY) {
                <span class="hljs-keyword">return</span> mChildHelper.dispatchNestedPreFling(velocityX, velocityY);
        }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>再来看看同样作为嵌套滑动父View的CollaspingLayout的实现</p> 
 <pre><code class="hljs javascript copyable">    <span class="hljs-comment">// NestedScrollingParent</span>
    @Override
    public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) {
        <span class="hljs-keyword">return</span> (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != <span class="hljs-number">0</span>;
    }

    @Override
    public <span class="hljs-keyword">void</span> onNestedScrollAccepted(View child, View target, int nestedScrollAxes) {
        mParentHelper.onNestedScrollAccepted(child, target, nestedScrollAxes);
    }

    @Override
    public <span class="hljs-keyword">void</span> onStopNestedScroll(View target) {
        <span class="hljs-keyword">if</span>(mHeaderController.getScrollPercentage() == <span class="hljs-number">1.0</span>f){
            mHeaderState = STATE_IDLE_TOP;
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mHeaderController.getScrollPercentage() == <span class="hljs-number">0.0</span>f){
            mHeaderState = STATE_IDLE_BOTTOM;
        }
        computeScroll();
    }

    @Override
    public <span class="hljs-keyword">void</span> onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed,
                               int dyUnconsumed) {
        final int myConsumed = moveBy(dyUnconsumed);
        final int myUnconsumed = dyUnconsumed - myConsumed;
    }

    @Override
    public <span class="hljs-keyword">void</span> onNestedPreScroll(View target, int dx, int dy, int[] consumed) {
        <span class="hljs-keyword">if</span> (dy &gt; <span class="hljs-number">0</span> &amp;&amp; mHeaderController.canScrollUp()) {
            final int delta = moveBy(dy);
            consumed[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
            consumed[<span class="hljs-number">1</span>] = delta;
        }
    }

    @Override
    public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed) {
        <span class="hljs-keyword">if</span> (!consumed) {
            flingWithNestedDispatch((int) velocityY);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>从上面的实现可以看出，基本上都是通过mParentHelper和mChildHelper来完成滑动的，没接触过这方面的同学看着肯定觉得很难理解，的确有些跳跃性，在说清楚这个问题之前必须先把这几个类之间的交互逻辑理清楚才能不至于不知所云。<br>先来梳理一下子View和父View的接中都有哪些方法。这种套路一般都是子View发起的然后父View进行回调从而完成配合。</p> 
 <table><thead><tr><th>子View</th><th>父View </th></tr></thead><tbody><tr><td>startNestedScroll</td><td>onStartNestedScroll、onNestedScrollAccepted </td></tr><tr><td>dispatchNestedPreScroll</td><td>onNestedPreScroll </td></tr><tr><td>dispatchNestedScroll</td><td>onNestedScroll </td></tr><tr><td>stopNestedScroll</td><td>onStopNestedScroll </td></tr></tbody></table> 
 <p>这里的子View指的是实现了NestedScrollingChild的View，例如我们的NestedScrollView，父View指的是实现了NestedScrollingParent的View，比如我们上面写的CollaspingLayout。</p> 
 <p>首先在子View滑动还未开始之前将调用startNestedScroll，对应NestedScrollView中的ACTION_DOWN:</p> 
 <pre><code class="hljs javascript copyable">@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN: {
    ......
    startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL);<span class="hljs-comment">//在接到点击事件之初调用</span>
    <span class="hljs-keyword">break</span>;                           
    }    
}<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>那么调用 startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL)寓意何在?跟进去看到其实是调用mChildHelper.startNestedScroll(axes）的实现</p> 
 <pre><code class="hljs javascript copyable">public boolean startNestedScroll(int axes) {
        <span class="hljs-keyword">if</span> (hasNestedScrollingParent()) {
            <span class="hljs-comment">// Already in progress</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">if</span> (isNestedScrollingEnabled()) {
            ViewParent p = mView.getParent();
            View child = mView;
            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">//重点在这-------&gt; 在子View开始滑动前通知父View，回调到父View的onStartNestedScroll()，</span>
                <span class="hljs-comment">//父View需要滑动则返回true：</span>
                <span class="hljs-keyword">if</span> (ViewParentCompat.onStartNestedScroll(p, child, mView, axes)) {
                    mNestedScrollingParent = p;
                    <span class="hljs-comment">//---------&gt; 如果父View决定要和子View一块滑动，调用父ViewonNestedScrollAccepted()</span>
                    ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes);
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
                <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> View) {
                    child = (View) p;
                }
                p = p.getParent();
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>大家仔细看我在代码里加的注释，需要关心的就是父View在此时需要决定是否跟随子View滑动，看看父View的实现：</p> 
 <pre><code class="hljs javascript copyable"> @Override
public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) {
    <span class="hljs-keyword">return</span> (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != <span class="hljs-number">0</span>;
}<span class="copy-code-btn">复制代码</span></code></pre> 
 <p> ViewCompat.SCROLL_AXIS_VERTICAL的值是2（10），所以当nestedScrollAxes 也为2的时候，返回true，回到上面可以看到只要是竖直方向的 滑动，父View就会和子View进行嵌套滑动。而在父View的<br> onNestedScrollAccepted中，则把滑动的方向给保存下来了。这样父View和子View的第一次合作关系就结束了，再看看接下来是如何配合的。<br> 当子View在滑动的Move事件中，又开始了嵌套滑动</p> 
 <pre><code class="hljs javascript copyable"> @Override
public boolean onTouchEvent(MotionEvent ev) {
    <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:
        final int y = (int) MotionEventCompat.getY(ev, activePointerIndex);
        int deltaY = mLastMotionY - y;
        <span class="hljs-keyword">if</span> (dispatchNestedPreScroll(<span class="hljs-number">0</span>, deltaY, mScrollConsumed, mScrollOffset)) {
            deltaY -= mScrollConsumed[<span class="hljs-number">1</span>];
            vtev.offsetLocation(<span class="hljs-number">0</span>, mScrollOffset[<span class="hljs-number">1</span>]);
            mNestedYOffset += mScrollOffset[<span class="hljs-number">1</span>];
         }
}<span class="copy-code-btn">复制代码</span></code></pre> 
 <p> 在子View决定滑动的时候，再次在进行自己的滑动前调用dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)</p> 
 <pre><code class="hljs javascript copyable">     public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) {
        <span class="hljs-keyword">if</span> (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (dx != <span class="hljs-number">0</span> || dy != <span class="hljs-number">0</span>) {
                int startX = <span class="hljs-number">0</span>;
                int startY = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (offsetInWindow != <span class="hljs-literal">null</span>) {
                    mView.getLocationInWindow(offsetInWindow);
                    startX = offsetInWindow[<span class="hljs-number">0</span>];
                    startY = offsetInWindow[<span class="hljs-number">1</span>];
                }

                <span class="hljs-keyword">if</span> (consumed == <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">if</span> (mTempNestedScrollConsumed == <span class="hljs-literal">null</span>) {
                        mTempNestedScrollConsumed = <span class="hljs-keyword">new</span> int[<span class="hljs-number">2</span>];
                    }
                    consumed = mTempNestedScrollConsumed;
                }
                <span class="hljs-comment">//---------&gt;重点在这，首先把consume封装好，consumed[0]表示X方向父View消耗的距离，</span>
                <span class="hljs-comment">// consumed[1]表示Y方向上父View消耗的距离，在父View处理前当然都是0</span>
                consumed[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                consumed[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
                <span class="hljs-comment">//然后调用父View的onNestedPreScroll并把当前的dx，dy以及消耗距离的consumed传递过去</span>
                ViewParentCompat.onNestedPreScroll(mNestedScrollingParent, mView, dx, dy, consumed);

                <span class="hljs-keyword">if</span> (offsetInWindow != <span class="hljs-literal">null</span>) {
                    mView.getLocationInWindow(offsetInWindow);
                    offsetInWindow[<span class="hljs-number">0</span>] -= startX;
                    offsetInWindow[<span class="hljs-number">1</span>] -= startY;
                }
                <span class="hljs-keyword">return</span> consumed[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span> || consumed[<span class="hljs-number">1</span>] != <span class="hljs-number">0</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offsetInWindow != <span class="hljs-literal">null</span>) {
                offsetInWindow[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                offsetInWindow[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p> 看看父View是怎么处理的,也是实现了这套机制的，看看他是怎么处理的：</p> 
 <pre><code class="hljs javascript copyable">    @Override
    public <span class="hljs-keyword">void</span> onNestedPreScroll(View target, int dx, int dy, int[] consumed) {
        <span class="hljs-keyword">if</span> (dy &gt; <span class="hljs-number">0</span> &amp;&amp; mHeaderController.canScrollUp()) {
            final int delta = moveBy(dy);
            consumed[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
            consumed[<span class="hljs-number">1</span>] = delta;
        }
    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p> 通过moveby计算父View滑动的距离，并将父ViewY方向消耗的距离记录下来</p> 
 <p> 继续来看子View，在通知了父View并且父View消耗了滑动距离之后，剩下的就是自己进行滑动了</p> 
 <pre><code class="hljs javascript copyable">@Override
public boolean onTouchEvent(MotionEvent ev) {
    <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:
        final int y = (int) MotionEventCompat.getY(ev, activePointerIndex);
        int deltaY = mLastMotionY - y;
        <span class="hljs-keyword">if</span> (dispatchNestedPreScroll(<span class="hljs-number">0</span>, deltaY, mScrollConsumed, mScrollOffset)) {
            deltaY -= mScrollConsumed[<span class="hljs-number">1</span>];
             <span class="hljs-comment">//重点在这：--------&gt;父View滑动之后调整自己的Offset为父View滑动的距离</span>
            vtev.offsetLocation(<span class="hljs-number">0</span>, mScrollOffset[<span class="hljs-number">1</span>]);
            mNestedYOffset += mScrollOffset[<span class="hljs-number">1</span>];
         }
         .........
         if(mIsBeingDragged){
            mLastMotionY = y - mScrollOffset[<span class="hljs-number">1</span>];
            final int oldY = getScrollY();
            final int range = getScrollRange();
            final int overscrollMode = ViewCompat.getOverScrollMode(<span class="hljs-keyword">this</span>);
            boolean canOverscroll = overscrollMode == ViewCompat.OVER_SCROLL_ALWAYS ||
            (overscrollMode == ViewCompat.OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp;
                range &gt; <span class="hljs-number">0</span>);
                <span class="hljs-comment">// Calling overScrollByCompat will call onOverScrolled, which</span>
                <span class="hljs-comment">// calls onScrollChanged if applicable.</span>
                <span class="hljs-comment">//重点在这：--------&gt;父View消耗了部分滑动距离后，子View自己开始滑动，通过overScrollByCompat</span>
                <span class="hljs-comment">//把滑动距离的参数传给mScroller进行弹性滑动</span>
                <span class="hljs-keyword">if</span> (overScrollByCompat(<span class="hljs-number">0</span>, deltaY, <span class="hljs-number">0</span>, getScrollY(), <span class="hljs-number">0</span>, range, <span class="hljs-number">0</span>,
                    <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>) &amp;&amp; !hasNestedScrollingParent()) {
                    <span class="hljs-comment">// Break our velocity if we hit a scroll barrier.</span>
                   mVelocityTracker.clear();
                }
         }
         ......
         <span class="hljs-comment">//重点在这：--------&gt;自己滑动完之后再调用dispatchNestedScroll通知父View滑动结束</span>
         <span class="hljs-keyword">if</span> (dispatchNestedScroll(<span class="hljs-number">0</span>, scrolledDeltaY, <span class="hljs-number">0</span>, unconsumedY, mScrollOffset)) {
             mLastMotionY -= mScrollOffset[<span class="hljs-number">1</span>];
             vtev.offsetLocation(<span class="hljs-number">0</span>, mScrollOffset[<span class="hljs-number">1</span>]);
             mNestedYOffset += mScrollOffset[<span class="hljs-number">1</span>];
         }
        <span class="hljs-keyword">break</span>;
}<span class="copy-code-btn">复制代码</span></code></pre> 
 <p> 接下来又是父View的回调了，来看看父View的处理：</p> 
 <pre><code class="hljs javascript copyable"> @Override
public <span class="hljs-keyword">void</span> onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed,
                        int dyUnconsumed) {
    final int myConsumed = moveBy(dyUnconsumed);
    final int myUnconsumed = dyUnconsumed - myConsumed;
}<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>父View在这里将最后子View滑动完后剩余的距离进行收尾处理，自我调整后第二轮的嵌套滑动也结束了。</p> 
 <p>那么再看看最后一轮滑动：</p> 
 <pre><code class="hljs javascript copyable">@Override
public boolean onTouchEvent(MotionEvent ev) {
<span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:
    <span class="hljs-comment">/* Release the drag */</span>
    mIsBeingDragged = <span class="hljs-literal">false</span>;
    mActivePointerId = INVALID_POINTER;
    recycleVelocityTracker();
    <span class="hljs-keyword">if</span> (mScroller.springBack(getScrollX(), getScrollY(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, getScrollRange())) {
        ViewCompat.postInvalidateOnAnimation(<span class="hljs-keyword">this</span>);
    }
    stopNestedScroll();
    <span class="hljs-keyword">break</span>;
}<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在触控事件的最后一个阶段，也就是ACTION_UP时，调用stopNestedScroll(),这时会通知父View的onStopNestedScroll()来对整个系列的滑动来收尾</p> 
 <pre><code class="hljs javascript copyable">    public <span class="hljs-keyword">void</span> stopNestedScroll() {
        <span class="hljs-keyword">if</span> (mNestedScrollingParent != <span class="hljs-literal">null</span>) {
            ViewParentCompat.onStopNestedScroll(mNestedScrollingParent, mView);
            mNestedScrollingParent = <span class="hljs-literal">null</span>;
        }
    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>父类最后在自己的onStopNestedScroll()实现相关的收尾处理，比如重置滑动状态标记，完成动画操作，通知滑动结束等。这样，整个滑动嵌套流程就完成了。</p> 
 <p>最后来总结一下整个流程，分为三个步骤：</p> 
 <ul><li>步骤一：子View的ACTION_DOWN调用startNestedScroll----&gt;父View的onStartNestedScroll判断是否要一起滑动，父ViewonNestedScrollAccepted同意协同滑动</li><li>步骤二：子View的ACTION_MOVE调用dispatchNestedPreScroll----&gt;父View的onNestedPreScroll在子View滑动之前先进行滑动并消耗需要的距离----&gt;父View完成该次滑动之后返回消耗的距离，子View在剩下的距离中再完成自己需要的滑动</li><li>步骤三：子View滑动完成之后调用dispatchNestedScroll----&gt;父View的onNestedScroll处理父View和子View之前滑动剩余的距离</li><li>步骤四：子View的ACTION_UP调用stopNestedScroll----&gt;父View的onStopNestedScroll完成滑动收尾工作</li></ul> 
 <p>这样，子View和父View的一系列嵌套滑动就完成了，可以看出来整个嵌套滑动还是靠子View来推动父View进行滑动的，这也解决了在传统的滑动事件中一旦事件被子View处理了就很难再分享给父View共同处理的问题，这也是嵌套滑动的一个特点。</p> 
 <h3 id="-">结语</h3> 
 <p>嵌套滑动作为官方推出的一套更加方便的处理滑动的工具，可以说是很大程度上减少了我们在出来这方面问题上的复杂性，当然，上面提到的仅仅是原理，真正的实现大家可以仔细地去看Design包一些控件的源码来进一步深入了解。同时，下一次还将继续分享如何用三大利器：CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout来实现携程机票首页的交互，敬请期待。</p> 
 <p>附上仿携程机票首页交互：<br><a href="https://link.juejin.im?target=http%3A%2F%2Fgold.xitu.io%2Fpost%2F581bf987bf22ec0068bb5939" rel="nofollow">三分钟带你仿携程机票首页炫酷交互</a></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab77cd533601a69b6f15f480b349a0f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TCP/IP、Http、Socket的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a2742bb5d5d175ac492aa38249445216/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ext.create()方法浅析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>