<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#中sort排序相关用法介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#中sort排序相关用法介绍" />
<meta property="og:description" content="C#中，List.Sort() 不仅为我们提供了默认的排序方法，还为我们提供了4种自定义排序的方法，通过默认排序方法，我们无需重写任何Sort()方法的实现代码，就能对单参数类型的List数据进行单一规则的排序，如果通过对这些方法进行改进我们可以轻松做到对多参数、多规则的复杂排序。
下面通过程序示例介绍四种相关的方法：
1.第一种，sort自带的list排序功能，但是该方法只是适用于单个元素的list。
using System; using System.Text; using System.Linq; using System.Collections; using System.Collections.Generic; class test { static void Main(string[] args) { List&lt;int&gt; list = new List&lt;int&gt;(); list.Add(6); list.Add(4); list.Add(3); list.Add(5); //直接对数字进行排序 list.Sort(); foreach (var item in list) { Console.WriteLine(item); } Console.ReadKey(); } } 对于多元素的list，需要用不同的排序方式对元素进行排序。
未排序：
using System; using System.Text; using System.Linq; using System.Collections; using System.Collections.Generic; class test { static void Main(string[] args) { List&lt;student&gt; stu = new List&lt;student&gt;(); stu." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a4ca7765b6c98769e4dd6b744b85ea05/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-10T14:36:12+08:00" />
<meta property="article:modified_time" content="2023-05-10T14:36:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#中sort排序相关用法介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> C#中，List.Sort() 不仅为我们提供了默认的排序方法，还为我们提供了4种自定义排序的方法，通过默认排序方法，我们无需重写任何Sort()方法的实现代码，就能对单参数类型的List数据进行单一规则的排序，如果通过对这些方法进行改进我们可以轻松做到对多参数、多规则的复杂排序。</p> 
<p>下面通过程序示例介绍四种相关的方法：</p> 
<p>1.第一种，sort自带的list排序功能，但是该方法只是适用于单个元素的list。</p> 
<pre><code class="language-cs">using System;
using System.Text;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
class test 
{
    static void Main(string[] args)
    {

        List&lt;int&gt; list = new List&lt;int&gt;();
        list.Add(6);
        list.Add(4);
        list.Add(3);
        list.Add(5);
        //直接对数字进行排序
        list.Sort();
        foreach (var item in list)
        {
            Console.WriteLine(item);
        }
        Console.ReadKey();
    }
 }</code></pre> 
<p><img alt="" height="258" src="https://images2.imgbox.com/45/c4/iYJHgQ3u_o.png" width="233"></p> 
<p>对于多元素的list，需要用不同的排序方式对元素进行排序。</p> 
<p>未排序：</p> 
<pre><code class="language-cs">using System;
using System.Text;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
class test 
{
    static void Main(string[] args)
    {

        List&lt;student&gt; stu = new List&lt;student&gt;();
        stu.Add(new student("apple", 23));
        stu.Add(new student("banana",18));
        stu.Add(new student("orange",19));

        foreach (var item in stu)
        {
            Console.WriteLine(item.Name+" "+" "+item.Age);
        }

        Console.ReadKey();

    }
 }

class student
{
    public student(string name, int age) { Name = name; Age = age; }
    public string Name;
    public int Age;
}



</code></pre> 
<p><img alt="" height="146" src="https://images2.imgbox.com/1e/89/MaOekLSH_o.png" width="298"></p> 
<p>第二种接口排序：</p> 
<p>该种方法是在定义的类内，通过Icomparable接口在类内定义排序的准则的方法。</p> 
<pre><code class="language-cs">using System;
using System.Text;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
class test 
{
    static void Main(string[] args)
    {

        List&lt;student&gt; stu = new List&lt;student&gt;();
        stu.Add(new student("apple", 23));
        stu.Add(new student("banana",18));
        stu.Add(new student("apple",22));
        stu.Add(new student("orange",19));

        //
        stu.Sort();
        foreach (var item in stu)
        {
            Console.WriteLine(item.Name+" "+" "+item.Age);
        }

        Console.ReadKey();
    }
 }

class student:IComparable&lt;student&gt;
{
    public student(string name, int age) { Name = name; Age = age; }
    public string Name;
    public int Age;

    public int CompareTo(student other)
    {
        if (this.Name!=other.Name)
        {
            return this.Name.CompareTo(other.Name);
        }
        else if (this.Age!=other.Age)
        {
            return this.Age.CompareTo(other.Age);
        }
        return 0;
    }
}
</code></pre> 
<p><img alt="" height="126" src="https://images2.imgbox.com/b1/b8/USThFqvy_o.png" width="167"></p> 
<p>第三种方法：接口排序的第二种</p> 
<p>该种方法时定义了一个类是作为一种方法，该类将需要排序的元素类引用，通过Icampara接口，在主函数中需要排序命令中载入该类的参数。</p> 
<pre><code class="language-cs">using System;
using System.Text;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
class test 
{
    static void Main(string[] args)
    {

        //第一种方法
        List&lt;student&gt; stu = new List&lt;student&gt;();
        stu.Add(new student("apple", 23));
        stu.Add(new student("banana", 18));
        stu.Add(new student("apple", 22));
        stu.Add(new student("orange", 19));

        stu.Sort();
        Console.WriteLine("第一种方法");
        foreach (var item in stu)
        {
            Console.WriteLine(item.Name + " " + " " + item.Age);
        }

        //第二种方法
        stu.Sort(new stupara());
        Console.WriteLine("第二种方法");
        foreach (var item in stu)
        {
            Console.WriteLine(item.Name + " " + " " + item.Age);
        }
    }
 }

class student:IComparable&lt;student&gt;
{
    public student(string name, int age) { Name = name; Age = age; }
    public string Name;
    public int Age;

    public int CompareTo(student other)
    {
        if (this.Name!=other.Name)
        {
            return this.Name.CompareTo(other.Name);
        }
        else if (this.Age!=other.Age)
        {
            return this.Age.CompareTo(other.Age);
        }
        return 0;
    }
}

class stupara : IComparer&lt;student&gt;
{
    public int Compare(student x, student y)
    {
        if (x.Age != y.Age)
        {
            return x.Age.CompareTo(y.Age);
        }
        else if (x.Name != y.Name)
        {
            return x.Name.CompareTo(y.Name);
        }

        else
            return 0;
    }
}
</code></pre> 
<p><img alt="" height="217" src="https://images2.imgbox.com/17/ad/RFkSkuQw_o.png" width="220"></p> 
<p>与第二种方法相比，第三种方法更好用，第三种方法可以将排序的类和方法类自由结合，无需要在定义元素类的时候将排序的方法载入。</p> 
<p>第四种方法：通过委托类型</p> 
<pre><code class="language-cs">using System;
using System.Text;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
class test 
{
    static void Main(string[] args)
    {

        //通过委托类型
        List&lt;Point&gt; pt = new List&lt;Point&gt;();
        pt.Add(new Point(2, 5));
        pt.Add(new Point(4, 2));
        pt.Add(new Point(3, 4));

        Console.WriteLine("第一种委托");
        pt.Sort(delegate (Point p1, Point p2)
       {
           return p1.X.CompareTo(p2.X);
       }
       );
        foreach (var item in pt)
        {
            Console.WriteLine(item.X + " " + " " + item.Y);
        }

        //P1,P2默认为pt列表中的类型
        pt.Sort((p1, p2) =&gt;
        {
            if (p1.Y != p2.Y)
            {
                return p1.Y.CompareTo(p2.Y);
            }
            else if (p1.X != p2.X)
            {
                return p1.Y.CompareTo(p2.Y);
            }
            else
            {
                return 0;          
            }
        });

        Console.WriteLine("第二种委托类型");
        foreach (var item in pt)
        {
            Console.WriteLine(item.X + " " + " " + item.Y);
        }

    }
 }


class Point
{
    public Point(int x, int y) { X = x;Y = y; }
    public int X;
    public int Y;
}</code></pre> 
<p> <img alt="" height="212" src="https://images2.imgbox.com/19/16/4r45JiCE_o.png" width="207"></p> 
<p>通过委托方法传入sort排序方法是一种比较简单的方式，该种方法无需重新定义类，直接在主函数中即可使用。</p> 
<p>参考文章：</p> 
<p><a href="https://petergao.blog.csdn.net/article/details/123344526?spm=1001.2101.3001.6650.11&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-11-123344526-blog-115246323.235%5Ev32%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-11-123344526-blog-115246323.235%5Ev32%5Epc_relevant_default_base&amp;utm_relevant_index=17" rel="nofollow" title="(1条消息) C# List.Sort排序_c# list sort_Peter_Gao_的博客-CSDN博客">(1条消息) C# List.Sort排序_c# list sort_Peter_Gao_的博客-CSDN博客</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0634d87cfb00651948f440ee350b24ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">搭建angularjs开发环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/408d22a4903a050df92c02de0ce0780b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux系统调用函数shmget()、shmat()，标准C库函数ftok()（创建共享内存段，创建共享内存段的键，把共享内存段加入当前的进程的地址空间中）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>