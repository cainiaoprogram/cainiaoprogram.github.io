<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;：多态 ( 语法 ) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;：多态 ( 语法 )" />
<meta property="og:description" content="多态目录 🍁多态简介🍁构成多态的条件🍂虚函数🍂虚函数重写🍂构成虚函数重写的两个特例🍃派生类中的虚函数的virtual关键字可以省略🔥多态的一道例题 🍃协变（运用场景不多） 🍂关键字 final 和 override🍃final🍃override 🍂重载、重定义(隐藏) 和 重写(覆盖) 🍁抽象类🍂纯虚函数🍂接口继承 和 实现继承 🍁多态简介 多态是C&#43;&#43;面向对象三大特性之一，那么多态二字又该如何去理解呢？
在现实生活中，针对同一行为不同对象所体现的事件的不同形态称为多态。
例如：
不同国家的人吃饭的所用的餐具不一样，在我国吃饭用的是筷子；美国等其他欧洲国家吃饭用餐叉；印度更是直接用手抓。去公园买票，普通人买票时需要全票价购买；学生买票时可以半票价购买；针对退伍军人可以优先购票等等。商品售卖，新用户可以享受到九折优惠；老用户可以享受到八折优惠。 🍁构成多态的条件 多态是在继承的基础上实现的，当然C&#43;&#43;构成多态还需要满足以下条件：
必须通过基类的指针或是引用去调用虚函数被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写 以上提到构成多态的条件缺一不可，否则构不成多态。
🍂虚函数 在类中被virtual关键字修饰的函数称为虚函数
class Person { public:	virtual void BuyTicket() //被virtual关键字修饰的函数为虚函数 { cout &lt;&lt; &#34;普通人买票-&gt;全票价&#34; &lt;&lt; endl; } }; 🍂虚函数重写 派生继承基类的时候，会将基类的成员和成员函数继承到派生类中，当成派生类中一部分；
在这里先捋清楚两个概念：继承中的重定义 和 多态中虚函数的重写
重定义：承体系中基类和派生类都有独立的作用域。派生类和基类中有同名成员，派生类成员将屏蔽基类对同名成员的直接访问，这种情况叫隐藏，也叫重定义虚函数重写：派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称派生类的虚函数重写了基类的虚函数 针对继承中的重定义来说，只要基类和派生类的成员名字相同即构成重定义；
虚函数构成重写的条件较为严格，不仅仅只是虚函数的函数名字相同还包括：虚函数返回值、参数列表等等。
在这里切记不要将重定义与虚函数重写两者概念搞混了。
下面举个构成虚函数重写的示例：
class Person { public:	virtual void BuyTicket() //基类的虚函数 { cout &lt;&lt; &#34;普通人购票-&gt;全票价&#34; &lt;&lt; endl; } }; class Student : public Person { public:	virtual void BuyTicket() //子类的虚函数与基类的虚函数：名字、函数返回值、参数相同；构成虚函数重写 { cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/786095ee75f8b4fb1e95010249f1ead7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-13T15:33:17+08:00" />
<meta property="article:modified_time" content="2023-09-13T15:33:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;：多态 ( 语法 )</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>多态目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">🍁多态简介</a></li><li><a href="#_11" rel="nofollow">🍁构成多态的条件</a></li><li><ul><li><a href="#_19" rel="nofollow">🍂虚函数</a></li><li><a href="#_33" rel="nofollow">🍂虚函数重写</a></li><li><a href="#_115" rel="nofollow">🍂构成虚函数重写的两个特例</a></li><li><ul><li><a href="#virtual_116" rel="nofollow">🍃派生类中的虚函数的virtual关键字可以省略</a></li><li><ul><li><a href="#_195" rel="nofollow">🔥多态的一道例题</a></li></ul> 
    </li><li><a href="#_253" rel="nofollow">🍃协变（运用场景不多）</a></li></ul> 
   </li><li><a href="#_final___override_285" rel="nofollow">🍂关键字 final 和 override</a></li><li><ul><li><a href="#final_291" rel="nofollow">🍃final</a></li><li><a href="#override_315" rel="nofollow">🍃override</a></li></ul> 
   </li><li><a href="#___347" rel="nofollow">🍂重载、重定义(隐藏) 和 重写(覆盖)</a></li></ul> 
  </li><li><a href="#_354" rel="nofollow">🍁抽象类</a></li><li><ul><li><a href="#_357" rel="nofollow">🍂纯虚函数</a></li><li><a href="#___433" rel="nofollow">🍂接口继承 和 实现继承</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>🍁多态简介</h2> 
<p>多态是C++面向对象三大特性之一，那么多态二字又该如何去理解呢？</p> 
<p>在现实生活中，针对同一行为<strong>不同对象</strong>所体现的事件的不同形态称为多态。</p> 
<blockquote> 
 <p>例如：</p> 
 <ol><li>不同国家的人吃饭的所用的餐具不一样，在我国吃饭用的是筷子；美国等其他欧洲国家吃饭用餐叉；印度更是直接用手抓。</li><li>去公园买票，普通人买票时需要全票价购买；学生买票时可以半票价购买；针对退伍军人可以优先购票等等。</li><li>商品售卖，新用户可以享受到九折优惠；老用户可以享受到八折优惠。</li></ol> 
</blockquote> 
<h2><a id="_11"></a>🍁构成多态的条件</h2> 
<p>多态是在继承的基础上实现的，当然C++构成多态还需要满足以下条件：</p> 
<ul><li><mark>必须通过基类的<strong>指针</strong>或是<strong>引用</strong>去调用<strong>虚函数</strong></mark></li><li><mark><strong>被调用的函数</strong>必须是<strong>虚函数</strong>，且<strong>派生类必须对基类的虚函数进行重写</strong></mark></li></ul> 
<p>以上提到构成多态的条件缺一不可，否则构不成多态。</p> 
<h3><a id="_19"></a>🍂虚函数</h3> 
<p><strong>在类中被<code>virtual</code>关键字修饰的函数称为虚函数</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>	
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//被virtual关键字修饰的函数为虚函数</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"普通人买票-&gt;全票价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_33"></a>🍂虚函数重写</h3> 
<p>派生继承基类的时候，会将基类的成员和成员函数继承到派生类中，当成派生类中一部分；</p> 
<p>在这里先捋清楚两个概念：<strong>继承中的重定义</strong> 和 <strong>多态中虚函数的重写</strong></p> 
<blockquote> 
 <ol><li><strong>重定义</strong>：承体系中<strong>基类</strong>和<strong>派生类</strong>都有<strong>独立的作用域</strong>。派生类和基类中有同名成员，派生类成员将屏蔽基类对同名成员的直接访问，这种情况叫隐藏，也叫重定义</li><li><strong>虚函数重写</strong>：派生类中有一个跟基类<strong>完全相同的虚函数</strong>(即派生类虚函数与基类虚函数的<strong>返回值类型</strong>、<strong>函数名字</strong>、<strong>参数列表</strong>完全相同)，称派生类的虚函数<strong>重写</strong>了基类的虚函数</li></ol> 
</blockquote> 
<p>针对继承中的重定义来说，只要基类和派生类的<strong>成员名字相同</strong>即构成重定义；</p> 
<p>虚函数构成重写的条件较为严格，不仅仅只是虚函数的函数名字相同还包括：<strong>虚函数返回值、参数列表</strong>等等。</p> 
<p><strong>在这里切记不要将重定义与虚函数重写两者概念搞混了。</strong></p> 
<p>下面举个构成虚函数重写的示例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>	
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//基类的虚函数</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"普通人购票-&gt;全票价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>	
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//子类的虚函数与基类的虚函数：名字、函数返回值、参数相同；构成虚函数重写</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"学生购票-&gt;半票价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>重定义</strong>和<strong>虚函数重写</strong>区分开后，回到刚刚提到的构成多态的条件。</p> 
<p>在上面示例中只是完成了虚函数的重写，并不能实现多态。</p> 
<p>还要需要完成另一个条件：<mark>通过基类的<strong>指针</strong>或是<strong>引用</strong>去调用<strong>虚函数</strong></mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>	
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//基类的虚函数</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"普通人购票-&gt;全票价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>	
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//子类的虚函数与基类的虚函数：名字、函数返回值、参数相同；构成虚函数重写</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"学生购票-&gt;半票价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Person<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token comment">//基类的引用</span>
<span class="token punctuation">{<!-- --></span>
	p<span class="token punctuation">.</span><span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Person ps<span class="token punctuation">;</span>
	Student st<span class="token punctuation">;</span>
	
	<span class="token function">func</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">func</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9a/97/04dHVuHY_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>创建<code>ps</code>和<code>st</code>两个不同对象，可以看到的是<code>func</code>函数的参数是<strong>基类的引用</strong>，通过基类的引用去调用虚函数从而构成多态</p> 
</blockquote> 
<p>如果构成多态情况到此为此还好，但是往往都会有特殊情况，好比如下虚函数重写的两个特例，也构成多态：</p> 
<h3><a id="_115"></a>🍂构成虚函数重写的两个特例</h3> 
<h4><a id="virtual_116"></a>🍃派生类中的虚函数的virtual关键字可以省略</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>	
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//基类的虚函数</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"普通人购票-&gt;全票价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>	
	<span class="token keyword">void</span> <span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//省略BuyTicket虚函数的virtual关键字</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"学生购票-&gt;半票价"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Person<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token comment">//基类的引用</span>
<span class="token punctuation">{<!-- --></span>
	p<span class="token punctuation">.</span><span class="token function">BuyTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Person ps<span class="token punctuation">;</span>
	Student st<span class="token punctuation">;</span>
	
	<span class="token function">func</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">func</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f2/52/7civpjaD_o.png" alt="在这里插入图片描述"></p> 
<p>上述提到的派生类中的虚函数的<code>virtual</code>关键字省略后，完成了虚函数重写。</p> 
<p>只是为了这样去运用开此特例难免会多此一举，这个特例主要运用于析构函数的重写：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Person()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span> 
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Student()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Person<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> Person<span class="token punctuation">;</span>  
	Person<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> Student<span class="token punctuation">;</span> <span class="token comment">//基类的指针调用，构成多态</span>
	
	<span class="token keyword">delete</span> p1<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> p2<span class="token punctuation">;</span> <span class="token comment">//构成多态，delete会调用Student类的析构函数</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>基类和派生类的类名字不同，因此析构函数的名字也会不同。如果基类的指针去调用派生类进行切片，待程序结束后，与之对应的析构函数又如何去调用呢？这个就要让编译器去处理了：</p> 
<blockquote> 
 <p><strong>派生类继承基类后，编译器会对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成<code>destructor</code></strong>。</p> 
</blockquote> 
<p>如果实现过程中，基类将析构函数设置为虚函数，那么派生类中的析构函数就必须完成相对应的虚函数重写。但是往往都会出现例外，要是实现者就忘记去加上<code>virtual</code>关键字不就构不成虚函数重写了吗？因此才会开此特例。</p> 
<p>上面例子我们也看到了，在这里不单单只适用于析构函数，所有情况都适用这个特例。<strong>切记，基类虚函数的关键字不能省略</strong>。</p> 
<h5><a id="_195"></a>🔥多态的一道例题</h5> 
<p>我们来看看这样的一道例题：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span> 
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A-&gt;"</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>

	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span> 
		<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span> 
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B-&gt;"</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>

	p<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这道程序构成多态么？答案为？</p> 
<p>这道程序很直观的可以看到符合多态的==<strong>虚函数重写</strong>==这个条件。</p> 
<blockquote> 
 <p>B类继承了A类，这道程序中虽然B派生类中的<code>func</code>函数没有被<code>virtual</code>关键字进行修饰，但是也构成虚函数的重写(<strong>该函数与基类的<code>func</code>虚函数的返回值相同、函数名相同、函数的参数列表个数和类型都相同</strong>)。</p> 
</blockquote> 
<p>再来分析一下该程序是否满足构成多态第二个条件：<mark><strong>虚函数</strong>通过基类的<strong>指针</strong>或是<strong>引用</strong>进行调用</mark></p> 
<p><code>test</code>函数是虚函数，派生类中并没有完成重写，在这里不构成多态。但是<code>test</code>函数内部用<code>this</code>指针去调用<code>func</code>函数的时候构成了多态。</p> 
<blockquote> 
 <p>这里解释一下为什么this指针在这里构成了多态：创建的p指针的类型是基类的，在这里存储了派生类B地址；在第调用test函数的时候，<code>p</code>指针传给了<code>this</code>指针，因此<code>this</code>指针就是基类的指针，此时调用虚函数正对应上了构成多态的第二个条件。</p> 
</blockquote> 
<p>看到这里我相信很多人会心里面的答案会是：<code>B-&gt;0</code>。但是答案果真如此吗？<br> <img src="https://images2.imgbox.com/d4/59/qqVzgGUP_o.png" alt="在这里插入图片描述"><br> 这里我们要想到一件事情：为什么要叫<strong>虚函数重写</strong>，而不是虚函数的替换或者是其他的名字？</p> 
<blockquote> 
 <p>在用基类的指针或是引用去调用派生类的虚函数时，只会去调用<strong>派生类的虚函数的定义</strong>。虚函数参数列表类型的缺省值用的还是基类的。</p> 
</blockquote> 
<p>这也是答案为什么是<code>B-&gt;1</code>而不是<code>B-&gt;0</code>。</p> 
<h4><a id="_253"></a>🍃协变（运用场景不多）</h4> 
<ul><li><mark><strong>协变(基类与派生类虚函数返回值类型不同)</strong></mark></li></ul> 
<p>派生类重写基类虚函数时，与基类虚函数返回值类型不同。这里提到派生类的虚函数的返回值不同，不是说什么返回值都可以。</p> 
<blockquote> 
 <p><strong>基类虚函数返回<mark>基类对象的指针或者引用</mark>，派生类虚函数返回<mark>派生类对象的指针或者引用</mark></strong></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> 
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> A<span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> B<span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_final___override_285"></a>🍂关键字 final 和 override</h3> 
<p><code>final</code> 和 <code>override</code> 关键字是C++11提供的，不支持C++11的编译器在使用这两个关键字时会报错。</p> 
<p>C++11提供这两个关键字是为了让用户更好的去检测虚函数重写。</p> 
<h4><a id="final_291"></a>🍃final</h4> 
<ul><li><mark><strong>final：修饰虚函数，表示该虚函数不能再被重写</strong></mark></li></ul> 
<p>该关键字直接加到函数参数列表的右括号后面即可：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Car</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span>  <span class="token comment">// final进行修饰</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Benz</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Car</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Benz-舒适"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/fc/95/JCl6g65M_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="override_315"></a>🍃override</h4> 
<ul><li><mark><strong>override: 检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错</strong></mark></li></ul> 
<p>该关键字直接加到函数参数列表的右括号后面即可：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Car</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Benz</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Car</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token comment">//用 override 关键字进行修饰，和基类的虚函数参数列表不同</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Benz-舒适"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Benz b<span class="token punctuation">;</span>
	Car c<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/44/5b/jwcHak7O_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="___347"></a>🍂重载、重定义(隐藏) 和 重写(覆盖)</h3> 
<ol><li><strong>函数重载</strong>：<mark>限制在同一个作用域内</mark>，两个函数的<mark>函数名相同</mark>；函数的形参列表的 <strong>类型</strong>、<strong>参数个数</strong>、<strong>参数顺序</strong> <mark>不同</mark>，构成<strong>函数重载</strong>。</li><li><strong>重定义</strong>：承体系中<strong>基类</strong>和<strong>派生类</strong>都有<mark>独立的作用域</mark>。派生类和基类中<strong>有同名成员</strong>，<mark>派生类成员将屏蔽基类对同名成员的直接访问</mark>，这种情况叫<strong>隐藏</strong>，也叫<strong>重定义</strong>。</li><li><strong>虚函数重写</strong>：派生类中有一个跟基类<strong>完全相同的虚函数</strong>(即派生类虚函数与基类虚函数的 <strong>返回值类型</strong>、<strong>函数名字</strong>、<strong>参数列表</strong> <mark>完全相同</mark> )，称 <mark>派生类</mark> 的<strong>虚函数</strong>重写了 <mark>基类</mark> 的<strong>虚函数</strong>。</li></ol> 
<h2><a id="_354"></a>🍁抽象类</h2> 
<p>看抽象类前，先来介绍一下纯虚函数：</p> 
<h3><a id="_357"></a>🍂纯虚函数</h3> 
<ul><li><mark><strong>直接在虚函数后面写上等于0，该函数称为纯虚函数</strong></mark></li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//Drive为纯虚函数</span>
</code></pre> 
<ul><li><mark><strong>包含纯虚函数的类被称为抽象类(接口类)</strong></mark></li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Car</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//Car类中的纯虚函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>注意：<strong>抽象类不能实例化出对象</strong>！！！</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Car c<span class="token punctuation">;</span> <span class="token comment">//报错</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/08/ab/LRsZueRS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>在继承体系中，如果基类为抽象类，派生类没有去重写纯虚函数的话，派生类也不能实例化出对象。</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Car</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Benz</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Car</span> <span class="token comment">//继承抽象类Car</span></span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Benz b<span class="token punctuation">;</span> <span class="token comment">//不能实例化出对象，报错</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/52/0f/SNayRdtl_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承</strong>（基类写了纯虚函数那么派生类就必须完成纯虚函数的重写的工作）</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Car</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Benz</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Car</span> <span class="token comment">//继承抽象类Car</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Drive()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Benz b<span class="token punctuation">;</span> <span class="token comment">//派生类重写了虚函数，实例化对象成功</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="___433"></a>🍂接口继承 和 实现继承</h3> 
<ul><li> <p><mark>接口继承</mark>：<strong>虚函数的继承</strong> 是一种接口继承，<mark>派生类继承的是基类虚函数的接口</mark>，目的是为了重写，达成多态，<strong>继承的是接口</strong></p> </li><li> <p><mark>实现继承</mark>：<strong>普通函数的继承</strong> 是一种实现继承，<mark>派生类继承了基类函数</mark>，可以使用函数，<strong>继承的是函数的实现</strong></p> </li></ul> 
<p>因此在实现过程中，如果不实现多态，不要把函数定义成虚函数</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e6b4081788b190996f5a4d8265a311c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle 19c RAC安装时遇到 INS-06006 错误</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f99f78a4ad08a522240d4fe03a0ea766/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[KeyarchOS]Chkrootkit后门检测工具的安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>