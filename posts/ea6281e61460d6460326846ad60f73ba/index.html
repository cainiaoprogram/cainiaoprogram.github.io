<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>onTouchEvent(二) 使用Scroller实现黏性滑动的ScrollView - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="onTouchEvent(二) 使用Scroller实现黏性滑动的ScrollView" />
<meta property="og:description" content="本文为楼主原创，转载请表明出处：http://blog.csdn.net/suma_sun/article/details/52900476 上一篇博文介绍了onTouchEvent()手势控制相关的一些坐标概念，这篇文章结合上一篇内容加上Scroller实现一个简单的带黏性滑动的ScrollView。
思路 滑动的时候判断最终偏移量是不是超出了子view(ViewGroup内容)的范围，如果超出了就限制不让其超出，这样就可以做出一个滑动的ScrollView并且不会滑出界当松手(action_up)的时候判断当前偏移量在该子view的什么位置，如果小于三分之一就滑动回该view的头部，如果超出三分之二就滑动到下个view 首先看看我们需要做些什么，自定义View要复写的方法有好几个，我们要复写的有： 1. onMeasure() 2. onLayout() 3. onTouchEvent() 4. computeScroll()
因为是ViewGroup需要计算、定位子View所以需要复写1和2两个函数。 3不用说了，要实现滑动功能必须要实现的函数。 4这是配合Scroller使用的一个函数。
首先介绍下Scroller这个类，这个类是一个工具，并不是实际UI操作。这个工具提供的功能是提供差值计算，就像属性动画一样，要做一个平滑过渡的动画需要用到差值器来辅助提供偏移差值。
下面是一个不使用Scroller的Demo。 差别很明显。
onMeasure @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //遍历子View，测量子View int count = getChildCount(); for (int i = 0; i &lt; count; i&#43;&#43;) { View view = getChildAt(i); measureChild(view, widthMeasureSpec, heightMeasureSpec); } super.onMeasure(widthMeasureSpec, heightMeasureSpec); } onMeasure()没什么好说的，遍历子view，测量子view。
onLayout @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { // 这里的四个坐标都是以ViewGroup来参照的，而不是屏幕的原点 // top默认0 // left默认0 // right默认屏幕宽度,ViewGroup的布局mactch_parent // bottom默认屏幕高度,ViewGroup的布局mactch_parent int count = getChildCount(); for (int i = 0; i &lt; count; i&#43;&#43;) { View view = getChildAt(i); //这个demo模仿垂直的ScrollView所以就没有累计宽度 int right = view." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ea6281e61460d6460326846ad60f73ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-11-01T22:49:06+08:00" />
<meta property="article:modified_time" content="2016-11-01T22:49:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">onTouchEvent(二) 使用Scroller实现黏性滑动的ScrollView</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文为楼主原创，转载请表明出处：<a href="http://blog.csdn.net/suma_sun/article/details/52900476">http://blog.csdn.net/suma_sun/article/details/52900476</a> <br> 上一篇博文介绍了onTouchEvent()手势控制相关的一些坐标概念，这篇文章结合上一篇内容加上Scroller实现一个简单的带黏性滑动的ScrollView。</p> 
<p><img src="https://images2.imgbox.com/86/9f/lzFpxzN3_o.gif" alt="这里写图片描述" title=""></p> 
<h3 id="思路">思路</h3> 
<ol><li>滑动的时候判断最终偏移量是不是超出了子view(ViewGroup内容)的范围，如果超出了就限制不让其超出，这样就可以做出一个滑动的ScrollView并且不会滑出界</li><li>当松手(action_up)的时候判断当前偏移量在该子view的什么位置，如果小于三分之一就滑动回该view的头部，如果超出三分之二就滑动到下个view</li></ol> 
<p>首先看看我们需要做些什么，自定义View要复写的方法有好几个，我们要复写的有： <br> 1. onMeasure() <br> 2. onLayout() <br> 3. onTouchEvent() <br> 4. computeScroll()</p> 
<p>因为是ViewGroup需要计算、定位子View所以需要复写1和2两个函数。 <br> 3不用说了，要实现滑动功能必须要实现的函数。 <br> 4这是配合Scroller使用的一个函数。</p> 
<p>首先介绍下Scroller这个类，这个类是一个工具，并不是实际UI操作。这个工具提供的功能是提供差值计算，就像属性动画一样，要做一个平滑过渡的动画需要用到差值器来辅助提供偏移差值。</p> 
<p>下面是一个不使用Scroller的Demo。 <br> <img src="https://images2.imgbox.com/af/bd/ZkWplr4H_o.gif" alt="这里写图片描述" title=""></p> 
<p>差别很明显。</p> 
<h3 id="onmeasure">onMeasure</h3> 
<pre class="prettyprint"><code class=" hljs java">    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span>(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec) {
        <span class="hljs-comment">//遍历子View，测量子View</span>
        <span class="hljs-keyword">int</span> count = getChildCount();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
            View view = getChildAt(i);
            measureChild(view, widthMeasureSpec, heightMeasureSpec);
        }
        <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }</code></pre> 
<p>onMeasure()没什么好说的，遍历子view，测量子view。</p> 
<h3 id="onlayout">onLayout</h3> 
<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayout</span>(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b) {
<span class="hljs-comment">//        这里的四个坐标都是以ViewGroup来参照的，而不是屏幕的原点 </span>
<span class="hljs-comment">//        top默认0</span>
<span class="hljs-comment">//        left默认0</span>
<span class="hljs-comment">//        right默认屏幕宽度,ViewGroup的布局mactch_parent</span>
<span class="hljs-comment">//        bottom默认屏幕高度,ViewGroup的布局mactch_parent</span>
        <span class="hljs-keyword">int</span> count = getChildCount();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
            View view = getChildAt(i);
            <span class="hljs-comment">//这个demo模仿垂直的ScrollView所以就没有累计宽度</span>
            <span class="hljs-keyword">int</span> right = view.getMeasuredWidth();
            <span class="hljs-comment">//设置子View摆放位置</span>
            <span class="hljs-comment">//mMaxHeight初始化为0</span>
            view.layout(l , mMaxHeight, right, mMaxHeight + view.getMeasuredHeight());
            mMaxHeight += view.getMeasuredHeight();
            <span class="hljs-comment">//mHeights是一个集合，用于保存每个自view的高度，用于粘性滑动判断</span>
            mHeights.add(mMaxHeight);
            <span class="hljs-keyword">if</span>(right &gt; mMaxWidth){
                mMaxWidth = right;
            }
        }
    }</code></pre> 
<p>要说明的都已经在注释上了。</p> 
<h3 id="ontouchevent">onTouchEvent</h3> 
<p>首先提醒下getScrollY()、getScrollX()这两个方法获取的是当前的偏移量，初始状态都为0，左移累加正值，右移累加负值，上移累加正值，下移累加负值。如果看不懂其中坐标操作等请参考前一篇文章<a href="http://blog.csdn.net/suma_sun/article/details/52884346">onTouchEvent(一) 你所必须知道的坐标详解</a>。</p> 
<pre class="prettyprint"><code class=" hljs cs">    @Override
    <span class="hljs-keyword">public</span> boolean <span class="hljs-title">onTouchEvent</span>(MotionEvent <span class="hljs-keyword">event</span>) {
        <span class="hljs-keyword">float</span> x = <span class="hljs-keyword">event</span>.getX();
        <span class="hljs-keyword">float</span> y = <span class="hljs-keyword">event</span>.getY();
        <span class="hljs-keyword">int</span> dx = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> dy = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">event</span>.getAction()) {
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:
                <span class="hljs-comment">//动画未停止，直接停止</span>
                <span class="hljs-keyword">if</span> (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                mLastX = x;
                mLastY = y;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:
                <span class="hljs-keyword">if</span> (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                dx = (<span class="hljs-keyword">int</span>) (mLastX - x);
                dy = (<span class="hljs-keyword">int</span>) (mLastY - y);
                <span class="hljs-keyword">if</span> (dx &lt; <span class="hljs-number">0</span>) {<!-- --><span class="hljs-comment">//右移</span>
<span class="hljs-comment">//              为什么不判断getScrollX() &lt;= 0呢，因为下面的判断已经限制了,另外三个方向手势亦然</span>
<span class="hljs-comment">//              限制最终偏移量不能超过0(不超过子view显示ViewGroup的背景)</span>
                    <span class="hljs-keyword">if</span> (dx + getScrollX() &lt; <span class="hljs-number">0</span>) {
                        dx = <span class="hljs-number">0</span> - getScrollX();
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dx &gt; <span class="hljs-number">0</span>) {<!-- --><span class="hljs-comment">//左移</span>
<span class="hljs-comment">//              左移动是正值偏移量，最大值不能超过内容的最大宽度，并且为了不超出显示容器的背景还要减去容器的宽度</span>
<span class="hljs-comment">//              (为什么不用屏幕宽度呢，这是一个坑，如果容器不是match_parent的话那就有问题了)                </span>
                    <span class="hljs-keyword">int</span> maxW = mMaxWidth - getWidth();
                    <span class="hljs-keyword">if</span> (dx &gt; maxW - getScrollX()) {
                        dx = maxW - getScrollX();
                    }
                }

                <span class="hljs-keyword">if</span> (dy &lt; <span class="hljs-number">0</span>) {<!-- --><span class="hljs-comment">//下滑</span>
                    <span class="hljs-keyword">if</span> (getScrollY() + dy &lt; <span class="hljs-number">0</span>) {
                        dy = <span class="hljs-number">0</span> - getScrollY();
                    }

                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dy &gt; <span class="hljs-number">0</span>) {<!-- --><span class="hljs-comment">//上滑</span>
<span class="hljs-comment">//               为什么不用屏幕宽高呢？内容只能显示在ViewGroup上！状态栏、标题栏、导航栏都会占用屏幕高度,</span>
<span class="hljs-comment">//               还有match_parent</span>
                    <span class="hljs-keyword">int</span> maxH = mMaxHeight - getHeight(); 
                    <span class="hljs-keyword">if</span> (maxH &lt; dy + getScrollY()) {
                        dy = maxH - getScrollY();
                    }

                }
                scrollBy(dx, dy);
                mLastX = x;
                mLastY = y;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:
 <span class="hljs-comment">//                  mScrollY 不会小于0，为什么呢？ 下滑到极限的时候是初始状态，即mScorllY=0的时候。</span>
                <span class="hljs-keyword">if</span> (mHeights.size() == <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                }
                    <span class="hljs-keyword">int</span> currY = getScrollY();
                    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">for</span> (; i &lt; mHeights.size(); i++) {
                        <span class="hljs-keyword">if</span> (mHeights.<span class="hljs-keyword">get</span>(i) &gt; currY) {<!-- --><span class="hljs-comment">//偏移量坐标 小于 集合的值 说明是前一个view</span>
                            <span class="hljs-keyword">break</span>;
                        }
                    }
                    View child = getChildAt(i);
                    <span class="hljs-keyword">int</span> height = (child.getBottom() - child.getTop()) / <span class="hljs-number">3</span>;<span class="hljs-comment">//计算3分之一的高度，小于三分之一回滚top，</span>
<span class="hljs-comment">//                    大于三分之二滚到下个view头部</span>
                    <span class="hljs-keyword">if</span> (getScrollY() &gt; (child.getBottom() - height)) {<!-- --><span class="hljs-comment">//大于三分之二view高度</span>
<span class="hljs-comment">//                    不会有超出最后一个view的情况，因为move的时候已经限制了不能超出内容的</span>
                        child = getChildAt(i + <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">int</span> viewHeight = child.getBottom() - child.getTop();
<span class="hljs-comment">//                    如果下一个view是最后一个view 判断其高度是否小于容器高度</span>
                        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == mHeights.size() - <span class="hljs-number">1</span> &amp;&amp; viewHeight &lt; getHeight()) {
<span class="hljs-comment">//                   最后一个view的bottom也就是maxHeight，其减去容器高度，</span>
<span class="hljs-comment">//                  就是最后满屏的Y轴坐标，减去当前偏移量获取需要的偏移量</span>
                            dy = child.getBottom() - getHeight() - getScrollY();
                        } <span class="hljs-keyword">else</span> {
                            dy = child.getTop() - getScrollY();
                        }
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getScrollY() &lt; (child.getTop() + height)) {<!-- --><span class="hljs-comment">//小于三分之一view高度</span>
                        dy = child.getTop() - getScrollY();
                    }
                    mScroller.startScroll(getScrollX(), getScrollY(), <span class="hljs-number">0</span>, dy);
                    invalidate();

                <span class="hljs-keyword">break</span>;

        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }</code></pre> 
<p>该说明的都在注释里标明了，毕竟后面解释的话来回滚动很麻烦。 <br> startScroll()还有一个重载。 <br> public void startScroll(int startX, int startY, int dx, int dy, int duration)自己设定操作的时间，上面那个重载是用得默认值250.</p> 
<h3 id="computescroll">computeScroll()</h3> 
<pre class="prettyprint"><code class=" hljs java">    <span class="hljs-javadoc">/**
     * Called by a parent to request that a child update its values for mScrollX
     * and mScrollY if necessary. This will typically be done if the child is
     * animating a scroll using a {@link android.widget.Scroller Scroller}
     * object.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeScroll</span>() {
    }</code></pre> 
<p>computeScroll()是一个空实现的函数，父控件调用用于更新子View，操作的是mScrollX和mScrollY，也就是移动偏移量。</p> 
<p><img src="https://images2.imgbox.com/3a/77/ri6YYMdd_o.png" alt="这里写图片描述" title=""></p> 
<p>该函数在draw中被调用，故可以用来控制scroll。但其实一个空实现的函数，那怎么做才能达到我们要的效果呢?layout()重新设置布局位置，不过这个太麻烦了用起来，上一篇介绍的scrollTo()、scrollBy()是正统滑动的代码。</p> 
<pre class="prettyprint"><code class=" hljs java">    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeScroll</span>() {
        <span class="hljs-keyword">super</span>.computeScroll();
        <span class="hljs-keyword">if</span> (mScroller.computeScrollOffset()) {<!-- --><span class="hljs-comment">//是否完成整个滑动，无调用startScroll()返回false</span>
            scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
            <span class="hljs-comment">//通过重绘来不断调用computeScroll()</span>
            invalidate();
        }
    }</code></pre> 
<p>直接上代码就很直观了，但为什么要调用invalidate()来不断调用呢？很多文章(网上随便查)都是这么写的。 <br> PS：其实我开始是相信大神们的，后面写着写着有自己的理解，就开始质疑了…然后注释掉跑了下，滑动是有时会黏性滚动有时不会，我才又相信大神们了囧rz。 <br> 说说我得思路，如果不对希望有人能给我指出，谢谢。 <br> 首先onTouchEvent()中调用了Scroller.startScroll()方法，该方法不涉及UI操作所以在后面调用了一次invalidate()让View去重绘，根据上面的computeScroll()的调用得知draw的时候会调用该方法，即invalidate()之后会被调用。里面通过scrollTo()来进行移动的操作，scrollTo()该方法源码中有一个函数postInvalidateOnAnimation()</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scrollTo</span>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) {
        <span class="hljs-keyword">if</span> (mScrollX != x || mScrollY != y) {
            <span class="hljs-keyword">int</span> oldX = mScrollX;
            <span class="hljs-keyword">int</span> oldY = mScrollY;
            mScrollX = x;
            mScrollY = y;
            invalidateParentCaches();
            onScrollChanged(mScrollX, mScrollY, oldX, oldY);
            <span class="hljs-keyword">if</span> (!awakenScrollBars()) {
                postInvalidateOnAnimation();
            }
        }
    }</code></pre> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**
     * &lt;p&gt;Cause an invalidate to happen on the next animation time step, typically the
     * next display frame.&lt;/p&gt;
     *
     * &lt;p&gt;This method can be invoked from outside of the UI thread
     * only when this View is attached to a window.&lt;/p&gt;
     *
     *<span class="hljs-javadoctag"> @see</span> #invalidate()
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postInvalidateOnAnimation</span>() {
        <span class="hljs-comment">// We try only with the AttachInfo because there's no point in invalidating</span>
        <span class="hljs-comment">// if we are not attached to our window</span>
        <span class="hljs-keyword">final</span> AttachInfo attachInfo = mAttachInfo;
        <span class="hljs-keyword">if</span> (attachInfo != <span class="hljs-keyword">null</span>) {
            attachInfo.mViewRootImpl.dispatchInvalidateOnAnimation(<span class="hljs-keyword">this</span>);
        }
    }</code></pre> 
<p>效果跟invalidate()差不多，也会重绘，但是前面有个判断。</p> 
<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">awakenScrollBars</span>() {
        <span class="hljs-keyword">return</span> mScrollCache != <span class="hljs-keyword">null</span> &amp;&amp;
                awakenScrollBars(mScrollCache.scrollBarDefaultDelayBeforeFade, <span class="hljs-keyword">true</span>);
    }</code></pre> 
<p>awakenScrollBars(int startDelay, boolean invalidate)该方法里面也有可能会调用invalidate(),但也只是有可能，里面有其他判断可能会过滤掉，所以终其原因就是有不会调动invalidate()的可能行存在，所以手动调用了一次invalidate()。</p> 
<p>既然手动调用invalidate()就会重绘，也就会调用到computeScroll()，里面再判断Scroller的差值计算是否完毕，未完毕则继续移动就这样循环直至偏移到最终坐标。</p> 
<p>附上布局文件</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>
              <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"vertical"</span>
              <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
              <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">com.suma.viewdemo.widget.MyScrollerView2
</span>        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"#656565"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">View
</span>            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"1280dp"</span>
            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"400dp"</span>
            <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"#50acde"</span>/&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-title">View
</span>            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"720dp"</span>
            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"400dp"</span>
            <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"#cc53"</span>/&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-title">View
</span>            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"400dp"</span>
            <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"#88acde88"</span>/&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-title">View
</span>            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"400dp"</span>
            <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"#55bc88"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">com.suma.viewdemo.widget.MyScrollerView2</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span></code></pre> 
<p><a href="http://download.csdn.net/detail/suma_sun/9759063">核心代码下载</a></p> 
<h3 id="结束语">结束语</h3> 
<p>呼，终于完成这一篇了，医生让我一周一更，还是有点累的，之前的我辣么懒，不过坚持下来我就是赚到了，下面就这个主题还准备写一两篇，又要挤时间敲敲demo了…</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/199a0c16a8d210f20a53f6d6494efd59/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Launcher】获取最新Launcher源码，并且导入到Android Studio</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e4f23c6c9708995df2d913db9c231a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL数据类型介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>