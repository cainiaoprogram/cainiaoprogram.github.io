<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android自定义View之蜘蛛网雷达效果 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android自定义View之蜘蛛网雷达效果" />
<meta property="og:description" content="/ 今日科技快讯 /
近日，在将聊天机器人Bard作为主要用于搜索的AI服务推出后，谷歌似乎正在偏离初衷，没有提供任何具体的用例。在最近举行的全体员工会议上，该公司高管辩称，Bard不仅仅用于搜索，他们正探索构建一种协作式AI服务。
/ 作者简介 /
本篇文章转自史大拿的博客，文章主要分享了自定义View中蛛网的效果，相信会对大家有所帮助！
原文地址：
https://juejin.cn/post/7147966036803846152
/ 前言 /
系统：mac
android studio：4.1.3
kotlin version：1.5.0
gradle：gradle-6.5-bin.zip
本篇效果：
蛛网图其实就是由多个多边形来组成蛛网的，那么先来画1个多边形来练练手。
/ 画多边形 /
首先我们先来画一个五边形，想要绘制一个五边形，那么就是求出5个点即可。例如这样：
首先我们需要定义圆的半径，也是五边形的“半径”。只需要算出每一个角的角度，那么就可以通过三角函数算出每一个点的坐标。
0的角度为360 / 5 * 0
1的角度为360 / 5 * 1
2的角度为360 / 5 * 2
3的角度为360 / 5 * 3
4的角度为360 / 5 * 4
来看看代码：
class E3PolygonChartBlogView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { companion object { // 半径 val SMALL_RADIUS = 100." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/eb99d736bc72004a7338595e9e5c5997/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-07T08:00:53+08:00" />
<meta property="article:modified_time" content="2023-03-07T08:00:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android自定义View之蜘蛛网雷达效果</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/8a/d7/0iK8Mk1t_o.png" alt="outside_default.png"><br></p> 
 <p style="text-align:center;">/   今日科技快讯   /</p> 
 <p>近日，在将聊天机器人Bard作为主要用于搜索的AI服务推出后，谷歌似乎正在偏离初衷，没有提供任何具体的用例。在最近举行的全体员工会议上，该公司高管辩称，Bard不仅仅用于搜索，他们正探索构建一种协作式AI服务。</p> 
 <p style="text-align:center;">/   作者简介   /<br></p> 
 <p>本篇文章转自史大拿的博客，文章主要分享了自定义View中蛛网的效果，相信会对大家有所帮助！</p> 
 <p>原文地址：<br></p> 
 <blockquote> 
  <p style="text-align:justify;">https://juejin.cn/post/7147966036803846152</p> 
 </blockquote> 
 <p style="text-align:center;">/   前言   /</p> 
 <p>系统：mac</p> 
 <p>android studio：4.1.3</p> 
 <p>kotlin version：1.5.0</p> 
 <p>gradle：gradle-6.5-bin.zip</p> 
 <p>本篇效果：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/12/53/plShtLiE_o.png" alt="outside_default.png"></p> 
 <p>蛛网图其实就是由多个多边形来组成蛛网的，那么先来画1个多边形来练练手。</p> 
 <p style="text-align:center;">/   画多边形   /</p> 
 <p>首先我们先来画一个五边形，想要绘制一个五边形，那么就是求出5个点即可。例如这样：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/d8/c9/HNEKS2iQ_o.png" alt="outside_default.png"></p> 
 <p>首先我们需要定义圆的半径，也是五边形的“半径”。只需要算出每一个角的角度，那么就可以通过三角函数算出每一个点的坐标。</p> 
 <ul><li><p>0的角度为360 / 5 * 0</p></li><li><p>1的角度为360 / 5 * 1</p></li><li><p>2的角度为360 / 5 * 2</p></li><li><p>3的角度为360 / 5 * 3</p></li><li><p>4的角度为360 / 5 * 4</p></li></ul> 
 <p>来看看代码：</p> 
 <pre class="has"><code class="language-go">class E3PolygonChartBlogView @JvmOverloads constructor(
     context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
 ) : View(context, attrs, defStyleAttr) {
 
     companion object {
         // 半径
         val SMALL_RADIUS = 100.dp
 
         // 几边形
         const val COUNT = 5
    }
 
     private val paint = Paint(Paint.ANTI_ALIAS_FLAG)
 
     // 中心位置
     private val centerLocation by lazy {
         PointF(width / 2f, height / 2f)
    }
 
     override fun onDraw(canvas: Canvas) {
 
         val cx = centerLocation.x
         val cy = centerLocation.y
         // 辅助圆
         canvas.drawCircle(cx, cy, SMALL_RADIUS, paint)
 
 
         // 每一个的间隔
         val eachAngle = 360 / COUNT
        (0 until COUNT).forEach {
 
             val angle = it * eachAngle.toDouble()
 
             val x =
                (SMALL_RADIUS * cos(Math.toRadians(angle)) + centerLocation.x).toFloat()
             val y =
                (SMALL_RADIUS * sin(Math.toRadians(angle)) + centerLocation.y).toFloat()
 
             paint.color = colorRandom
             // 绘制每一个小圆
             canvas.drawCircle(x, y, 10.dp, paint)
        }
    }
 }</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/09/0c/hR2pyHDq_o.png" alt="outside_default.png"></p> 
 <p>那么五边形其实就是吧5个点连接起来即可。</p> 
 <pre class="has"><code class="language-go">private val paint = Paint(Paint.ANTI_ALIAS_FLAG)
 
     private val path = Path()
     override fun onDraw(canvas: Canvas) {
 
         // 每一个的间隔
         val eachAngle = 360 / COUNT
        (0 until COUNT).forEach {
             val angle = it * eachAngle.toDouble()
             val x =
                (SMALL_RADIUS * cos(Math.toRadians(angle)) + centerLocation.x).toFloat()
             val y =
                (SMALL_RADIUS * sin(Math.toRadians(angle)) + centerLocation.y).toFloat()
 // 连接每一个点
             if (it == 0) {
                 path.moveTo(x, y)
            } else {
                 path.lineTo(x, y)
            }
        }
         path.close() // 闭合
 
         paint.strokeWidth = 2.dp
         paint.style = Paint.Style.STROKE
         canvas.drawPath(path, paint) // 绘制
         path.reset()
    }</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/71/80/66Tb8voA_o.png" alt="outside_default.png"></p> 
 <p style="text-align:center;">/   绘制多条五边形   /</p> 
 <p>假如需要绘制成这样子：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/b8/89/ozPeCtgl_o.png" alt="outside_default.png"></p> 
 <p>刚才我们绘制的是最中心绿色的五边形，那么这里就需要定义一个变量，来标识每一个五边形之间的间距。例如蓝色五边形和绿色五边形的间距为20.dp。</p> 
 <p>那么蓝色五边形五个点的半径 = 绿色五边形的半径 + 20.dp。以此类推：</p> 
 <pre class="has"><code class="language-go">class E3PolygonChartBlogView @JvmOverloads constructor(
     context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
 ) : View(context, attrs, defStyleAttr) {
 
     companion object {
         // 半径
         val SMALL_RADIUS = 100.dp
 
         // 几边形
         const val COUNT = 5
 
         // 有几条边
         const val NUMBER = 3
 
         // 每一条边的间隔
         val INTERVAL = 20.dp
    }
 
     private val paint = Paint(Paint.ANTI_ALIAS_FLAG)
 
     // 中点
     private val centerLocation by lazy {
         PointF(width / 2f, height / 2f)
    }
 
     private val path = Path()
     override fun onDraw(canvas: Canvas) {
         // 每一个的间隔
         val eachAngle = 360 / COUNT

         // 循环有几条边
        (0 until NUMBER).forEachIndexed { index, element -&gt;
 
             // 循环每一条边有几个点
            (0 until COUNT).forEach { count -&gt;
                 // 半径 = 当前是第几条边 * 间距 + 最中间的距离
                 val radius = element * INTERVAL + SMALL_RADIUS

                 val angle = count * eachAngle.toDouble()
 
                 val x =
                    (radius * cos(Math.toRadians(angle)) + centerLocation.x).toFloat()
                 val y =
                    (radius * sin(Math.toRadians(angle)) + centerLocation.y).toFloat()
                 if (count == 0) {
                     path.moveTo(x, y)
                } else {
                     path.lineTo(x, y)
                }
            }
             path.close() // 闭合
             paint.strokeWidth = 2.dp
             paint.style = Paint.Style.STROKE
             canvas.drawPath(path, paint)
             paint.reset()
        }
    }
 }</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/44/3f/CZGav4aa_o.png" alt="outside_default.png"></p> 
 <p style="text-align:center;">/   连接最外层和最内层   /</p> 
 <p>连接最内层和最外层也比较简单，只需要循环有几条边的时候判断是否是最外层，然后将最外层的点和最内层的点相连接即可。如果需要和中心点相连接，那么stop点为 centerLocation即可。</p> 
 <pre class="has"><code class="language-go">override fun onDraw(canvas: Canvas) {
         // 每一个的间隔
         val eachAngle = 360 / COUNT
         // 循环有几条边
        (0 until NUMBER).forEachIndexed { index, element -&gt;
 
             // 循环每一条边有几个点
            (0 until COUNT).forEach { count -&gt;
                 // 半径 = 当前是第几条边 * 间距 + 最中间的距离
                 val radius = element * INTERVAL + SMALL_RADIUS
                 val angle = count * eachAngle.toDouble()
 
                 val x =
                    (radius * cos(Math.toRadians(angle)) + centerLocation.x).toFloat()
                 val y =
                    (radius * sin(Math.toRadians(angle)) + centerLocation.y).toFloat()
                  .....
 
                 // 当前是最后一层
                 if (index == NUMBER - 1) {
                     // 最内层x,y 坐标
                     val stopX =
                        (SMALL_RADIUS * cos(Math.toRadians(angle)) + centerLocation.x).toFloat()
                     val stopY =
                        (SMALL_RADIUS * sin(Math.toRadians(angle)) + centerLocation.y).toFloat()
                     canvas.drawLine(x, y, stopX, stopY, paint)
                     // 连接中心点
                     // canvas.drawLine(x, y, centerLocation.x, centerLocation.y, paint)
                }
            }
             path.close() // 闭合
 
             canvas.drawPath(path, paint)
             paint.reset()
        }
    }</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/04/e3/8t2aojKL_o.png" alt="outside_default.png"></p> 
 <p>那么现在需要一个：</p> 
 <ul><li><p>10边形</p></li><li><p>每一条边有7个点</p></li><li><p>最中心的半径为 20.dp</p></li><li><p>每一个边的间距 = 20.dp</p></li></ul> 
 <p>只需要改这4个变量即可：</p> 
 <pre class="has"><code class="language-go">companion object {
     // 半径
     val SMALL_RADIUS = 20.dp
 
     // 几边形
     const val COUNT = 10
 
     // 有几条边
     const val NUMBER = 7
 
     // 每一条边的间隔
     val INTERVAL = 20.dp
 }</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/11/ca/5PuJNYNo_o.png" alt="outside_default.png"></p> 
 <p style="text-align:center;">/   绘制文字   /</p> 
 <p>还是和上面的套路一样，先来思考文字需要绘制到什么地方？</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/66/28/zaAOhqHG_o.png" alt="outside_default.png"></p> 
 <p>我们的多边形只到红色的，那么为了保持和最外层有一点距离，所以我们需要将文字绘制到虚线处，还是当绘制最外层的时候开始绘制文字。</p> 
 <pre class="has"><code class="language-go">@SuppressLint("DrawAllocation")
     override fun onDraw(canvas: Canvas) {
 
         // 每一个的间隔
         val eachAngle = 360 / COUNT
         // 循环有几条边
        (0 until NUMBER).forEachIndexed { index, element -&gt;
 
             // 循环每一条边有几个点
            (0 until COUNT).forEach { count -&gt;
                 // 半径 = 当前是第几条边 * 间距 + 最中间的距离
                 val radius = element * INTERVAL + SMALL_RADIUS
                 val angle = count * eachAngle.toDouble()
 
                 val x =
                    (radius * cos(Math.toRadians(angle)) + centerLocation.x).toFloat()
                 val y =
                    (radius * sin(Math.toRadians(angle)) + centerLocation.y).toFloat()
                ...
 
                 // 绘制最外层和内层连接线
                ...
 
 
                 // 设置文字
                 if (index == NUMBER - 1) {
                     val text = "文字${count}"
 
                     val rect = Rect()
 
                     // 计算文字宽高 计算完成之后会把值赋值给rect
                     paint.getTextBounds(text, 0, text.length, rect)
                     val textWidth = rect.width()
                     val textHeight = rect.height()
 
                     val tempRadius = radius + textHeight
                     val textX =
                        (tempRadius * cos(Math.toRadians(angle)) + centerLocation.x).toFloat() - textWidth / 2f
                     val textY =
                        (tempRadius * sin(Math.toRadians(angle)) + centerLocation.y).toFloat()
 
                     paint.textSize = 16.dp
                     paint.style = Paint.Style.FILL
                     paint.color = E3PolygonChartView.TEXT_COLOR
                     // 绘制最外层文字
                     canvas.drawText(text, textX, textY, paint)
 
                }
            }
          ...
        }
    }</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/5d/ad/7Ens20Cu_o.png" alt="outside_default.png"></p> 
 <p>到目前为止，蛛网的雏形就差不多了，接下来绘制具体的数据。</p> 
 <p style="text-align:center;">/   绘制数据   /</p> 
 <p>绘制数据之前先来看看现在点的坐标。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/9d/16/spjaohxg_o.png" alt="outside_default.png"></p> 
 <p>假设我们当前需要设置的数据为3，2，3，1，1。那么我们只需要从0坐标开始，算出每一个对应的五边形即可。那么最终结果应该为：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/dc/53/FcLGS3yz_o.png" alt="outside_default.png"></p> 
 <pre class="has"><code class="language-go">override fun onDraw(canvas: Canvas) {

   // 绘制网格
          ...

   // 绘制数据
         drawArea(canvas)
 }
 
 var data = listOf(3f, 2f, 3f, 1f, 1f)
  private fun drawArea(canvas: Canvas) {
         data.forEachIndexed { index, value -&gt;
             val location = getLocation(index, value)
 
             if (index == 0) {
                 path.moveTo(location.x, location.y)
            } else {
                 path.lineTo(location.x, location.y)
            }
        }
         path.close()
 
 
         paint.style = Paint.Style.STROKE
         paint.color = Color.RED
         canvas.drawPath(path, paint) // 绘制边
 
         paint.style = Paint.Style.FILL
         paint.alpha = (255 * 0.1).toInt()
         canvas.drawPath(path, paint) // 绘制内边
         path.reset()
    }</code></pre> 
 <pre class="has"><code class="language-go">/*
  * 作者:史大拿
  * 创建时间: 9/27/22 2:54 PM
  * @number 第几个点
  * @count 第几条边
  */
 private fun getLocation(number: Int, count: Float): PointF = let {
     // 角度
     val angle = 360 / COUNT * number

     // 半径
     val radius = (count - 1) * INTERVAL + SMALL_RADIUS

     val x =
        (radius * cos(Math.toRadians(angle.toDouble())) + centerLocation.x).toFloat()
     val y =
        (radius * sin(Math.toRadians(angle.toDouble())) + centerLocation.y).toFloat()
 
     return PointF(x, y)
 }</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/d6/52/8jYgBtbD_o.png" alt="outside_default.png"></p> 
 <p style="text-align:center;">/   手势滑动   /</p> 
 <p>雷达图的手势滑动和其他的不太一样，因为他需要计算的是角度。</p> 
 <p><strong>场景1（右下角）</strong></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/7f/4e/vFIm9wyi_o.png" alt="outside_default.png"></p> 
 <p>假设当前滑动的位置在右下角。那么他的角度就为红色的角度。</p> 
 <p><strong>红色的角度 = atan(dy / dx)</strong><br></p> 
 <p><strong>场景2（左下角）</strong></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/b6/3a/C4oZUeT2_o.png" alt="outside_default.png"></p> 
 <p>假设当前滑动的位置在左下角，那么他的角度就为黑色的角度 + 绿色的角度。</p> 
 <p><strong>绿色角度 = 90度</strong></p> 
 <p><strong>红色的角度 = atan(dy / dx)</strong></p> 
 <p><strong>黑色角度 = 90 - 红色角度</strong></p> 
 <p><strong>场景3（左上角）</strong></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/df/91/lmYh8OlX_o.png" alt="outside_default.png"></p> 
 <p>假设当前滑动的位置在左上角，那么他的角度就为红色的角度 + 绿色角度。</p> 
 <ul><li><p>dx = centerLocation.x - event.x</p></li><li><p>dy = centerLocation.x - event.y</p></li></ul> 
 <p><strong>红色的角度 = atan(dy / dx)</strong></p> 
 <p><strong>绿色的角度 = 180度</strong></p> 
 <p><strong>场景4（右上角）</strong></p> 
 <p><strong><img src="https://images2.imgbox.com/f4/b4/kNHgzC6O_o.png" alt="outside_default.png"></strong></p> 
 <p>假设当前滑动的位置在右上角，那么他的角度就为绿色角度 + 黑色角度。</p> 
 <p><strong>黑色角度 = 90度 - 红色角度</strong></p> 
 <p><strong>红色角度 = atan(dy / dx)</strong></p> 
 <p><strong>绿色角度 = 270度</strong></p> 
 <p>判断是否是左上角或者右上角，只需要判断两个点的x，y值即可。来看看计算角度代码：</p> 
 <pre class="has"><code class="language-go">@param startP: 开始点
 @param endP: 结束点
 
 fun PointF.angle(endP: PointF): Float {
     val startP = this
 
     // 原始位置
     val angle = if (startP.x &gt;= endP.x &amp;&amp; startP.y &gt;= endP.y) {
         Log.e("szjLocation", "end在start右下角")
         0
    } else if (startP.x &gt;= endP.x &amp;&amp; startP.y &lt;= endP.y) {
         Log.e("szjLocation", "end在start右上角")
         270
    } else if (startP.x &lt;= endP.x &amp;&amp; startP.y &lt;= endP.y) {
         Log.e("szjLocation", "end在start左上角")
         180
    } else if (startP.x &lt;= endP.x &amp;&amp; startP.y &gt;= endP.y) {
         Log.e("szjLocation", "end在start左下角")
         90
    } else {
         0
    }
     // 计算距离
     val dx = startP.x - endP.x
     val dy = startP.y - endP.y
     // 弧度
     val radian = abs(atan(dy / dx))
 
     // 弧度转角度
     var a = Math.toDegrees(radian.toDouble()).toFloat()
 
     if (startP.x &lt;= endP.x &amp;&amp; startP.y &gt;= endP.y) {
         // 左下角
         a = 90 - a
    } else if (startP.x &gt;= endP.x &amp;&amp; startP.y &lt;= endP.y) {
         // 右上角
         a = 90 - a
    }
     return a + angle
 }</code></pre> 
 <pre class="has"><code class="language-go">var offsetAngle = 0f // 偏移角度
 private var downAngle = 0f // 按下角度
 private var originAngle = 0f // 原始角度
 
 @SuppressLint("ClickableViewAccessibility")
 override fun onTouchEvent(event: MotionEvent): Boolean {
     when (event.action) {
         MotionEvent.ACTION_DOWN -&gt; {
             downAngle = centerLocation.angle(PointF(event.x, event.y))
             originAngle = offsetAngle
        }
         MotionEvent.ACTION_MOVE -&gt; {
             parent.requestDisallowInterceptTouchEvent(true)
 
             // 当前偏移角度 = 现在角度 - 按下角度 + 原始角度
             offsetAngle =
                 centerLocation.angle(PointF(event.x, event.y)) - downAngle + originAngle
 
             Log.e("szjOffset","$offsetAngle")
        }
         MotionEvent.ACTION_UP -&gt; {
        }
    }
     invalidate()
 
     return true
 }</code></pre> 
 <p>如果这里角度不知道为啥 = 现在角度 - 按下角度 + 原始角度。可以看之前的文章，道理都是一样的，就不过多解释了！最后计算出来的角度直接赋值给onDraw即可。</p> 
 <pre class="has"><code class="language-go">override fun onDraw(canvas: Canvas) {
         // 每一个的间隔
         val eachAngle = 360 / COUNT
         // 循环有几条边
        (0 until NUMBER).forEachIndexed { index, element -&gt;
 
             // 循环每一条边有几个点
            (0 until COUNT).forEach { count -&gt;
                 val angle = count * eachAngle.toDouble() + offsetAngle // TODO 设置角度
 
                 val x =
                    (radius * cos(Math.toRadians(angle)) + centerLocation.x).toFloat()
                 val y =
                    (radius * sin(Math.toRadians(angle)) + centerLocation.y).toFloat()
                 if (count == 0) {
                     path.moveTo(x, y)
                } else {
                     path.lineTo(x, y)
                }
 
                 // 连接最外层和最内层
   ....
 
 
                 // 设置文字
                ....

            }
            ....
 
             canvas.drawPath(path, paint)
             path.reset()
        }
 
         // 绘制数据
         drawArea(canvas)
    }</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/4b/e4/2z5zmn0J_o.png" alt="outside_default.png"></p> 
 <p style="text-align:center;">/   设置fling事件   /</p> 
 <p>我坦白了，fling事件我是偷的MPAndroidChart的源码，这个fling事件和平常的不太一样，有大坑...想了1天没想出来，只能看看前辈思路...如果需要可以自行下载看细节。</p> 
 <p>完整代码地址如下：</p> 
 <blockquote> 
  <p style="text-align:justify;">https://gitee.com/lanyangyangzzz/custom-view-project</p> 
 </blockquote> 
 <p>推荐阅读：</p> 
 <p><a href="" rel="nofollow">我的新书，《第一行代码 第3版》已出版！</a><br></p> 
 <p><a href="" rel="nofollow">2022年终总结，我的10年Android之旅</a><br></p> 
 <p><a href="" rel="nofollow">手把手带你搞懂AMS启动原理</a><br></p> 
 <p style="text-align:center;">欢迎关注我的公众号</p> 
 <p style="text-align:center;">学习技术或投稿</p> 
 <p><img src="https://images2.imgbox.com/e5/69/Vymcwnt8_o.png" alt="outside_default.png"></p> 
 <p style="text-align:center;"><img height="123" width="123" src="https://images2.imgbox.com/ac/6d/tKIn8cHb_o.png" alt="outside_default.png"></p> 
 <p style="text-align:center;">长按上图，识别图中二维码即可关注</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bbc7ef340989d8d498446f8661cc798c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot&#43;springsecurity&#43;mybatis&#43;jwt实现单点登录（详细到爆了）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/35912b2a0df208f449074ded59d95a24/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Python 处理 MODIS 遥感数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>