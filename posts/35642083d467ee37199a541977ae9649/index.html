<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;语法入门 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;语法入门" />
<meta property="og:description" content="命名空间 什么是命名空间？ 我们先来看一个案例！
在校内，有一天，4班的小胖摔了一跤，于是a同学对b同学说：“小胖摔了一跤”。 b同学说：“哪个小胖”？a同学又说，就是4班的那个小胖啊！ 注意看上面的案例，我们可以把上面的案例代入到代码中
小胖：变量
a同学：程序员
b同学：编译器
在校内：在全局范围内
4班：其实就是对应c&#43;&#43;中的命名空间
分析：当一个项目中，我们可能要定义两个/以上的同名变量，但是如果同名对象，程序就会报错，因为编译器不会像b同学一样问a同学是哪个？它只有对与不对之分！而人与人之间可以加限定词来修饰一个变量，程序又如何限定呢？由此我们引出了命名空间！
关键字：namespace&#43;空间名
如果要访问的话就是：空间名::变量名
namespace修饰的空间其实我们可以看成一个作用域，里面的内容的作用域被限制在了命名空间中，命名空间外除非用特定的方式，不然无法访问
这里的&#34;::&#34;表示的是域访问符
了解了以上内容我们写个代码试试
再看下面
三个注意事项 命名空间可以用来放函数/变量/结构体....它就是一个域，把命名空间与命名空间之外的东西隔离开来 命名空间里的变量那些都是全局的 命名空间中变量不允许重复赋值 命名空间的三种访问形式 第一种：空间名:: 变量名 这个上面介绍过，如果命名空间中的某些东西用的次数很频繁，为了方便一点我们引入第二种
第二种：using 空间名::函数名/变量名/结构体 这里的意思是展开S1命名空间中的a变量，展开后a变量就失去了命名空间的隔离效果
要注意的是，这里的using要放在定义命名空间之后，因为using展开以后是向上进行查找，如果在定义命名空间之前，则会导致using无法找到命名空间
但有时候在我们在平时练习时有些库函数要用，但一个一个展开又太麻烦了，有什么办法可以一次性展开整个命名空间吗？由此我们引入第三种访问形式
第三种：using namespace 空间名 这个的意思是展开命名空间中的所有东西，展开后整个命名空间中的内容都失去了命名空间的隔离效果
但要注意的是这个展开方式在实际工程中不推荐使用，因为当代码量过大且很多人一起操作一个项目时容易与命名空间中的某些函数重复。
在实际工程中，推荐使用第一种或第二种！
关于命名空间的一些问题 命名空间可以嵌套使用吗？ 答：可以，看如下代码
命名空间如果也是一样的名字该怎么办？ 答：如果命名空间是一样的名字，那么编译器就是把两个命名空间的内容合为一个！
例如
这个代码就跟如下的代码是相等的
3.命名空间和结构体有什么不同？ 命名空间：是一个域，他限制了命名空间外面的访问必须要通过特定的方式
结构体：是一个自定义的类型，本质上跟int这种内置类型一样，区别就是结构体是你自己实现的类型
一个图总结命名空间，你能否全部答上来呢？ std命名空间及cin&amp;cout 简介 我们先看一段代码
我们一段一段来解释这个代码
using namespace std：由上一个命名空间章节可知，std是一个命名空间， std是C&#43;&#43;标准库的命名空间名，C&#43;&#43;将标准库的定义实现都放到这个命名空间中,using是展开的意思，所以这里的意思是展开命名空间中所有的定义
#include&lt;iostream&gt;：#include功能是包含对应的头文件/库函数，而iostream是c&#43;&#43;中的库函数，这个库函数叫做&#34;输入输出流&#34;，他的定义是在命名空间std的
cout：实际上是std中的一个类型为istream的全局变量，他放在std中，这里大概理解成cout就是一个控制台这样就够了，c&#43;&#43;后期会学IO流的原理
&#34;&lt;&lt;&#34;运算符：官方名称为流插入运算符，上述代码你可以翻译为：变量x中的字符串流向cout控制台所以控制台上就打印出来了
cin：是一个类型为ostream的全局变量，这里也可以把cin理解成一个控制台，他放在std中
&#34;&gt;&gt;&#34;：官方名称为流提取操作符，上述代码可以翻译为把cin这个控制台上的内容(也就是你输入的内容)流向x这个变量
endl：这个可以简单理解为是对应c&#43;&#43;中的换行
注意：cin输入也是以空格/换行为分隔符，这一点和scanf一致
关于cin/cout有更复杂的语法(如控制浮点数输出精度，控制整形输出进制格式等 等。)这里用起来没有c语言的方便，而且也不经常用所以不加以赘述。
c&#43;&#43;输入和输出比起c语言的有什么优势？ c&#43;&#43;的可以自动识别类型，不用再写%d,%s,%lf....，而c语言是一定要写的
一张图理清std及cin&amp;cout的知识点，你能答出来吗？ 缺省参数 初识缺省参数 理解缺省参数之前，让我们回顾一下c语言中的函数调用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/35642083d467ee37199a541977ae9649/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-26T03:12:04+08:00" />
<meta property="article:modified_time" content="2023-03-26T03:12:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;语法入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="">命名空间</h2> 
 <p style=""></p> 
 <h3 style="text-indent:1.4em;">什么是命名空间？</h3> 
 <p style=""></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;">我们先来看一个案例！</p> 
 <blockquote class="kdocs-blockquote" style="padding-left:2.8em;">
   在校内，有一天，4班的小胖摔了一跤，于是a同学对b同学说：“小胖摔了一跤”。 
  <br>b同学说：“哪个小胖”？a同学又说，就是4班的那个小胖啊！ 
 </blockquote> 
 <p style="text-indent:1.4em;padding-left:1.4em;">注意看上面的案例，我们可以把上面的案例代入到代码中</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">小胖：变量</span></span></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">a同学：程序员</span></span></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">b同学：编译器</span></span></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">在校内：在全局范围内</span></span></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">4班：其实就是对应c++中的命名空间</span></span></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">分析：当一个项目中，我们可能要定义两个/以上的同名变量，但是如果同名对象，程序就会报错，因为编译器不会像b同学一样问a同学是哪个？它只有对与不对之分！而人与人之间可以加限定词来修饰一个变量，程序又如何限定呢？由此我们引出了命名空间！</span></span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">关键字：namespace+空间名</span></span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">如果要访问的话就是：空间名::变量名</span></span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">namespace修饰的空间其实我们可以看成一个作用域，里面的内容的作用域被限制在了命名空间中，命名空间外除非用特定的方式，不然无法访问</span></span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">这里的"::"表示的是域访问符</span></span></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:920px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:87.82609%;height:0;"> 
    <img src="https://images2.imgbox.com/90/7c/pvJa5hA2_o.png" style="margin-left:;display:block;width:920px;margin-top:-87.82609%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">了解了以上内容我们写个代码试试</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;"></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1438px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:61.265644%;height:0;"> 
    <img src="https://images2.imgbox.com/59/61/WSTJrrjW_o.png" style="margin-left:;display:block;width:1438px;margin-top:-61.265644%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">再看下面</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1266px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:45.65561%;height:0;"> 
    <img src="https://images2.imgbox.com/69/1f/HHkd9CDl_o.png" style="margin-left:;display:block;width:1266px;margin-top:-45.65561%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">三个注意事项</h3> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h4>命名空间可以用来放函数/变量/结构体....它就是一个域，把命名空间与命名空间之外的东西隔离开来</h4></li></ol> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1092px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:53.113552%;height:0;"> 
    <img src="https://images2.imgbox.com/f8/03/7VV5ogZn_o.png" style="margin-left:;display:block;width:1092px;margin-top:-53.113552%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h4>命名空间里的变量那些都是全局的</h4></li></ol> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h4>命名空间中变量不允许重复赋值</h4></li></ol> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1396px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:61.389683%;height:0;"> 
    <img src="https://images2.imgbox.com/bc/9d/gk2uA1ct_o.png" style="margin-left:;display:block;width:1396px;margin-top:-61.389683%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h3 style="">命名空间的三种访问形式</h3> 
 <p style=""></p> 
 <p style=""></p> 
 <h4 style="">第一种：空间名:: 变量名</h4> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:682px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:62.60997%;height:0;"> 
    <img src="https://images2.imgbox.com/39/31/yVixL7kL_o.png" style="margin-left:;display:block;width:682px;margin-top:-62.60997%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">这个上面介绍过，如果命名空间中的某些东西用的次数很频繁，为了方便一点我们引入第二种</p> 
 <p style=""></p> 
 <h4 style="">第二种：using 空间名::函数名/变量名/结构体</h4> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:590px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:100.67796%;height:0;"> 
    <img src="https://images2.imgbox.com/35/6a/hAJfG7zL_o.png" style="margin-left:;display:block;width:590px;margin-top:-100.67796%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">这里的意思是展开S1命名空间中的a变量，展开后a变量就失去了命名空间的隔离效果</p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">要注意的是，这里的using要放在定义命名空间之后，因为using展开以后是向上进行查找，如果在定义命名空间之前，则会导致using无法找到命名空间</span></span></p> 
 <p style=""></p> 
 <p style="">但有时候在我们在平时练习时有些库函数要用，但一个一个展开又太麻烦了，有什么办法可以一次性展开整个命名空间吗？由此我们引入第三种访问形式</p> 
 <p style=""></p> 
 <h4 style="">第三种：using namespace 空间名</h4> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:784px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:71.301025%;height:0;"> 
    <img src="https://images2.imgbox.com/b5/88/DmXIudF3_o.png" style="margin-left:;display:block;width:784px;margin-top:-71.301025%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">这个的意思是展开命名空间中的所有东西，展开后整个命名空间中的内容都失去了命名空间的隔离效果</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">但要注意的是这个展开方式在实际工程中不推荐使用，因为当代码量过大且很多人一起操作一个项目时容易与命名空间中的某些函数重复。</span></span></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">在实际工程中，推荐使用第一种或第二种！</span></span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">关于命名空间的一些问题</h3> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h4>命名空间可以嵌套使用吗？</h4></li></ol> 
 <p style="text-indent:1.4em;">答：可以，看如下代码</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1388px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:49.567726%;height:0;"> 
    <img src="https://images2.imgbox.com/0f/93/ogyOtRYr_o.png" style="margin-left:;display:block;width:1388px;margin-top:-49.567726%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h4>命名空间如果也是一样的名字该怎么办？</h4></li></ol> 
 <p style="">答：<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">如果命名空间是一样的名字，那么编译器就是把两个命名空间的内容合为一个！</span></span></p> 
 <p style=""></p> 
 <p style="">例如</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1356px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:42.330383%;height:0;"> 
    <img src="https://images2.imgbox.com/9e/68/anNWehMQ_o.png" style="margin-left:;display:block;width:1356px;margin-top:-42.330383%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">这个代码就跟如下的代码是相等的</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1108px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:37.093864%;height:0;"> 
    <img src="https://images2.imgbox.com/5b/50/fHXYhwxM_o.png" style="margin-left:;display:block;width:1108px;margin-top:-37.093864%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h4 style="">3.命名空间和结构体有什么不同？</h4> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">命名空间：是一个域，他限制了命名空间外面的访问必须要通过特定的方式</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">结构体：是一个自定义的类型，本质上跟int这种内置类型一样，区别就是结构体是你自己实现的类型</span></span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">一个图总结命名空间，你能否全部答上来呢？</h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1439px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:25.920778%;height:0;"> 
    <img src="https://images2.imgbox.com/c5/b0/jfgoujVG_o.png" style="margin-left:;display:block;width:1439px;margin-top:-25.920778%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h2 style=""><span class="kdocs-color" style="color:#080F17;">std命名空间及cin&amp;cout</span></h2> 
 <p style=""></p> 
 <h3 style="">简介</h3> 
 <p style="">我们先看一段代码</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:517px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:74.66151%;height:0;"> 
    <img src="https://images2.imgbox.com/32/31/1AnHNim1_o.png" style="margin-left:;display:block;width:517px;margin-top:-74.66151%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">我们一段一段来解释这个代码</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">using namespace std：由上一个命名空间章节可知，std是一个命名空间， std是C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中,using是展开的意思，所以这里的意思是展开命名空间中所有的定义</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;"> #include&lt;iostream&gt;：#include功能是包含对应的头文件/库函数，而iostream是c++中的库函数，这个库函数叫做"输入输出流"，他的定义是在命名空间std的</span></span></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">cout：实际上是std中的一个类型为istream的全局变量，他放在std中，这里大概理解成cout就是一个控制台这样就够了，c++后期会学IO流的原理</span></span></p> 
 <p style=""></p> 
 <p style="text-align:left;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">"&lt;&lt;"运算符：官方名称为流插入运算符，上述代码你可以翻译为：变量x中的字符串流向cout控制台所以控制台上就打印出来了</span></span></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">cin：是一个类型为ostream的全局变量，这里也可以把cin理解成一个控制台，他放在std中</span></span></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">"&gt;&gt;"：官方名称为流提取操作符，上述代码可以翻译为把cin这个控制台上的内容(也就是你输入的内容)流向x这个变量</span></span></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">endl：这个可以简单理解为是对应c++中的换行</span></span></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">注意：cin输入也是以空格/换行为分隔符，这一点和scanf一致</span></span></p> 
 <blockquote class="kdocs-blockquote" style=""></blockquote> 
 <p style="">关于cin/cout有更复杂的语法(如控制浮点数输出精度，控制整形输出进制格式等 等。)这里用起来没有c语言的方便，而且也不经常用所以不加以赘述。</p> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">c++输入和输出比起c语言的有什么优势？</h3> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">c++的可以自动识别类型，不用再写%d,%s,%lf....，而c语言是一定要写的</span></span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">一张图理清std及cin&amp;cout的知识点，你能答出来吗？</h3> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1541px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:29.785854%;height:0;"> 
    <img src="https://images2.imgbox.com/c3/98/qRfoMiw5_o.png" style="margin-left:;display:block;width:1541px;margin-top:-29.785854%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <h2 style="">缺省参数</h2> 
 <h3 style="">初识缺省参数</h3> 
 <p style="">理解缺省参数之前，让我们回顾一下c语言中的函数调用</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:482px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:73.443985%;height:0;"> 
    <img src="https://images2.imgbox.com/fd/53/iBWvjoG6_o.png" style="margin-left:;display:block;width:482px;margin-top:-73.443985%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">这里传了一个1赋给形参a，2赋给形参b，但当我们不写参数时是会报错的</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:764px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:93.45549%;height:0;"> 
    <img src="https://images2.imgbox.com/d6/49/DFMdvBEs_o.png" style="margin-left:;display:block;width:764px;margin-top:-93.45549%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">那在c++中有没有办法让他不报错呢？答案是有的，于是引进了缺省参数</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:579px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:62.52159%;height:0;"> 
    <img src="https://images2.imgbox.com/4a/8f/ktjk7j0E_o.png" style="margin-left:;display:block;width:579px;margin-top:-62.52159%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">这里两个形参都给上了缺省参数，设置为0，意思就是当我们不传值得时候a默认等于0，b默认等于0</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:436px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:104.12844%;height:0;"> 
    <img src="https://images2.imgbox.com/e7/56/l6Diy7Tp_o.png" style="margin-left:;display:block;width:436px;margin-top:-104.12844%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">而给了参数以后调用得是我们给得参数</p> 
 <p style=""></p> 
 <h3 style="">缺省参数的分类</h3> 
 <p style="">缺省参数除了上面那样给还分为几类</p> 
 <p style=""></p> 
 <p style="">全缺省：就是上面给的</p> 
 <p style=""></p> 
 <p style="">半缺省：准确的说就是部分缺省，例如</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:553px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:99.09585%;height:0;"> 
    <img src="https://images2.imgbox.com/83/42/2xgAYlQm_o.png" style="margin-left:;display:block;width:553px;margin-top:-99.09585%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">可以看到我们的参数是给到了a，而b用的缺省参数</p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">注意①：c++11之前的语法不允许中间的形参or传参 缺省 而两边的形参or传参不缺省</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">缺省参数只允许以下三种形式的</span></span></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:665px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:64.210526%;height:0;"> 
    <img src="https://images2.imgbox.com/a0/a2/APrTmWtQ_o.png" style="margin-left:;display:block;width:665px;margin-top:-64.210526%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">注意②：如果函数有声明那么缺省参数建议放到声明中(为了可读性)，不允许声明定义同时有缺省参数</span></span></p> 
 <p style="">例如</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1222px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:67.59411%;height:0;"> 
    <img src="https://images2.imgbox.com/af/ff/AJ84Ecp8_o.png" style="margin-left:;display:block;width:1222px;margin-top:-67.59411%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">正确如下</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:427px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:97.1897%;height:0;"> 
    <img src="https://images2.imgbox.com/6c/03/3RM2myXB_o.png" style="margin-left:;display:block;width:427px;margin-top:-97.1897%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h3 style="">缺省参数的总结</h3> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1377px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:16.41249%;height:0;"> 
    <img src="https://images2.imgbox.com/6c/c8/Sl2bkJwu_o.png" style="margin-left:;display:block;width:1377px;margin-top:-16.41249%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <h2 style="">函数重载</h2> 
 <p style=""></p> 
 <h3 style="">定义</h3> 
 <p style=""></p> 
 <p style="">以前我们在写c语言的时候会有一个很麻烦的点，例如：写了一个整数和整数相加的函数，但我们在用的时候可能又是浮点型的相加，于是就要再写一个函数，但再写一个函数跟原来的函数还无法重名！而c++完善了这一点，提供了函数重载的功能</p> 
 <p style=""></p> 
 <p style="">函数重载就是编译器对同一个名字的函数，进行区分不同</p> 
 <p style="">例如</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:539px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:120.77922%;height:0;"> 
    <img src="https://images2.imgbox.com/a3/cc/rg9uKPS8_o.png" style="margin-left:;display:block;width:539px;margin-top:-120.77922%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">可以看到，这里编译器会自动识别传过去的参数类型，而找到对应的同名函数</p> 
 <p style=""></p> 
 <h3 style="">函数的重载到底有什么条件呢？</h3> 
 <p style=""></p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h5>参数类型不同</h5></li></ol> 
 <p style=""></p> 
 <p style="">例如：</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:474px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:129.32489%;height:0;"> 
    <img src="https://images2.imgbox.com/02/a2/bdXY9wVL_o.png" style="margin-left:;display:block;width:474px;margin-top:-129.32489%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h5>参数个数不同</h5></li></ol> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:639px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:115.023476%;height:0;"> 
    <img src="https://images2.imgbox.com/71/34/PLxFk1SB_o.png" style="margin-left:;display:block;width:639px;margin-top:-115.023476%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h5>参数顺序不同</h5></li></ol> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:616px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:80.35714%;height:0;"> 
    <img src="https://images2.imgbox.com/b4/d2/ptjIygPf_o.png" style="margin-left:;display:block;width:616px;margin-top:-80.35714%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">特别要注意：函数重载与返回值无关，只与参数有关</span></span></p> 
 <p style=""></p> 
 <h3 style="">函数重载例子</h3> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">为什么c语言不支持函数重载？而c++支持函数重载</h3> 
 <p style=""></p> 
 <p style="">要理解这个问题我们先看看编译器对c语言同名函数的报错信息是什么！</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:682px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:89.14956%;height:0;"> 
    <img src="https://images2.imgbox.com/da/2e/12VTnZrU_o.png" style="margin-left:;display:block;width:682px;margin-top:-89.14956%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">这里说明编译器无法识别这两个函数的不同，那为什么无法识别呢？</span></span></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">这就要说到c语言程序执行到编译阶段时会生成一个符号表，这个符号表记录了一些特殊的符号，例如main....</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">当符号表中有两个f函数时，编译器无法识别哪个对应哪个，所以会报错</span></span></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">而当函数的声明和定义分离时，我们再看</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#080F17;">头文件存放函数声明</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:466px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:41.845493%;height:0;"> 
    <img src="https://images2.imgbox.com/41/e1/clYWVfI5_o.png" style="margin-left:;display:block;width:466px;margin-top:-41.845493%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">源文件存放函数实现</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:392px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:99.23469%;height:0;"> 
    <img src="https://images2.imgbox.com/9d/16/yupVwArN_o.png" style="margin-left:;display:block;width:392px;margin-top:-99.23469%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">报错信息</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:464px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:33.189655%;height:0;"> 
    <img src="https://images2.imgbox.com/5e/19/PgtDcqmr_o.png" style="margin-left:;display:block;width:464px;margin-top:-33.189655%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">为什么这里会报错呢？</p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">分析：我们知道c程序在预处理阶段会进行头文件展开，然后编译器会向上进行查找，而查找到声明时不会产生地址因为程序只有遇到定义时才会产生地址，但会产生的是一个 函数名(?) 这样的一个东西，这个是什么意思呢？其实就是你先跟编译器声明有这么个东西的实现，然后在链接阶段会合并所有文件的符号表，而原来的 函数(?) 也会从其他文件中的符号表中找到他的实现，并把定义的地址替换掉原来的"?"，但是如果编译的时候发现有两份同名实现时，编译器就无法识别该填哪个地址</span></span></p> 
 <blockquote class="kdocs-blockquote" style=""></blockquote> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">但是为什么c++支持函数重载呢？而且函数重载的要求还一定是参数的差别呢？</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">分析：那是因为c++编译器在符号表中的名称添加了函数的修饰规则，这个修饰规则是根据编译器的不同而不同的，但是都或多或少与参数有关</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">比如：linux上的g++编译中void f(int a)产生的符号表对应符号名称为_Z4fi</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">这个符号表对应符号名称的意思是：_Z4是编译器前缀，f是函数名，i是参数的类型为int</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">所以在以上void f(double b)和void f(int a)在c++linux上的符号表对应符号就分别是_Z1fd和_Z1fi</span></span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">总结一下：c语言不能实现函数重载的原因就是因为他的符号表里的函数名就单纯是个函数名，而无法区分出两个同名函数有什么不同,而c++能实现函数重载的原因就是因为他的符号表对应的符号把参数带上了，这样编译器就能根据他的参数不同而找到对应的同名函数</span></span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">一张图总结函数重载</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1484px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:18.867924%;height:0;"> 
    <img src="https://images2.imgbox.com/c1/59/FgK4mXew_o.png" style="margin-left:;display:block;width:1484px;margin-top:-18.867924%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h2 style=""><span class="kdocs-color" style="color:#080F17;">引用</span></h2> 
 <p style=""></p> 
 <h3 style="">引用概念</h3> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">引用其实就是给变量取了一个别名，引用不会创建变量！</span></span>，比如我们每个人除了自己得本名之外，在小得时候有人会叫你得乳名，在上学得时候有人会叫你得外号，其实不管是乳名还是外号形容得人都是你，并没有多出来一个人</p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">引用的格式：类型&amp; 新变量名 = 变量名</span></span></p> 
 <p style="">比如下面得代码</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:565px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:40.35398%;height:0;"> 
    <img src="https://images2.imgbox.com/4c/de/owqTR7y3_o.png" style="margin-left:;display:block;width:565px;margin-top:-40.35398%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">这里b和a得地址相同，说明这个地址除了叫做a以外还叫作b，而b没有创建新得变量</span></span></p> 
 <p style=""></p> 
 <h3 style="">引用的特性</h3> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">1、要注意的是取得外号(引用)的类型一定要跟实体相同</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1113px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:63.97125%;height:0;"> 
    <img src="https://images2.imgbox.com/0f/44/3CobLzEP_o.png" style="margin-left:;display:block;width:1113px;margin-top:-63.97125%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">2、引用必须初始化</span></span></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:559px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:93.023254%;height:0;"> 
    <img src="https://images2.imgbox.com/bb/de/9ZjjHqkZ_o.png" style="margin-left:;display:block;width:559px;margin-top:-93.023254%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">3、一个变量可以有多个引用，并且引用变量也能引用</span></span></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:821px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:41.900124%;height:0;"> 
    <img src="https://images2.imgbox.com/4a/ef/Zb2df8Am_o.png" style="margin-left:;display:block;width:821px;margin-top:-41.900124%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">4、引用一旦引用一个变量，就不能再引用另一个变量了</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:730px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:50.958904%;height:0;"> 
    <img src="https://images2.imgbox.com/f9/01/ApCTb9sc_o.png" style="margin-left:;display:block;width:730px;margin-top:-50.958904%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">如图，当b引用了一个实体以后，b=c就是把c的值赋给b，而不是b是c的引用</p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">5、引用可以给引用取别名</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:788px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:38.19797%;height:0;"> 
    <img src="https://images2.imgbox.com/cd/2a/CkaMldT7_o.png" style="margin-left:;display:block;width:788px;margin-top:-38.19797%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">引用的使用场景</h3> 
 <p style=""></p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h4><span class="kdocs-color" style="color:#080F17;">做参数</span></h4></li></ol> 
 <p style=""></p> 
 <p style="">以前我们写c语言时的有些函数，例如：swap函数，实参传给形参时交换的是形参的结果，无法交换实参的结果，当时的解决办法就是传地址调用如图代码</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:724px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:57.320442%;height:0;"> 
    <img src="https://images2.imgbox.com/ae/56/4HCvTLD8_o.png" style="margin-left:;display:block;width:724px;margin-top:-57.320442%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">正确调用方式，如图</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:726px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:60.055096%;height:0;"> 
    <img src="https://images2.imgbox.com/e9/3f/gIxVjAiu_o.png" style="margin-left:;display:block;width:726px;margin-top:-60.055096%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">现在还有一种方式，就是传引用调用</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:696px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:61.49425%;height:0;"> 
    <img src="https://images2.imgbox.com/af/b8/rVnVXSgw_o.png" style="margin-left:;display:block;width:696px;margin-top:-61.49425%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">做参数的好处有什么？</p> 
 <p style="">第一，当大变量传参时(如结构体)可以减少拷贝，提高效率</p> 
 <p style="">第二，输出型参数可以把指针替换为引用</p> 
 <p style="">第三、某些场景下，引用有指针代替不了的作用，这个我们后面了解</p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h4>做返回值</h4></li></ol> 
 <p style="">为什么会产生传返回值引用呢？</p> 
 <p style="">先看如图(这里还有一个bug，先往后看)</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:439px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:87.24374%;height:0;"> 
    <img src="https://images2.imgbox.com/8a/a5/UxGkDtlm_o.png" style="margin-left:;display:block;width:439px;margin-top:-87.24374%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">当代码执行到return n 时，n会生产一个临时变量我们把它叫做tmp，于是代码返回的逻辑就变成了如下</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:692px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:72.39884%;height:0;"> 
    <img src="https://images2.imgbox.com/c8/37/5PcjnJul_o.png" style="margin-left:;display:block;width:692px;margin-top:-72.39884%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">那这么设计是为了什么呢？为什么不直接返回n要根据n的返回值生成一个临时变量呢？</p> 
 <p style="">这其实跟函数栈帧有关</p> 
 <p style="">首先，我们先看一下两个函数的栈帧</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:936px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:50.10684%;height:0;"> 
    <img src="https://images2.imgbox.com/27/44/gbtPuV3t_o.png" style="margin-left:;display:block;width:936px;margin-top:-50.10684%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">我们知道，当函数返回时，栈帧的使用权就已经给了系统，那么我们返回的时候n就已经被销毁了，如果不反回拷贝，直接返回n的话就会造成越界</p> 
 <p style=""></p> 
 <p style="">那么我们回到刚开始的bug代码中，如图</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:439px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:87.24374%;height:0;"> 
    <img src="https://images2.imgbox.com/57/6e/bpsa9g73_o.png" style="margin-left:;display:block;width:439px;margin-top:-87.24374%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">这里其实传返回值引用的时候就已经造成了越界。</p> 
 <p style=""></p> 
 <p style="">这里的越界解决办法是把n改成静态变量，这样他就存储在静态区了，这样函数销毁的时候就不会影响n的值</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:420px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:98.09523%;height:0;"> 
    <img src="https://images2.imgbox.com/0f/59/rFGRa7Ic_o.png" style="margin-left:;display:block;width:420px;margin-top:-98.09523%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">总结一下：传返回值引用，如果是出了函数的作用域之后销毁的变量则一定不能传引用返回，如果出了函数作用域不销毁的变量则可以传引用返回减少拷贝</p> 
 <p style=""></p> 
 <h3 style="">传值和传引用的效率对比</h3> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:844px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:88.862564%;height:0;"> 
    <img src="https://images2.imgbox.com/76/4d/pzM31cKw_o.png" style="margin-left:;display:block;width:844px;margin-top:-88.862564%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">可以看到，在图上场景中，效率差距百倍不止</p> 
 <p style=""></p> 
 <h3 style="">值和引用的作为返回值类型的性能比较 </h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:787px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:95.93392%;height:0;"> 
    <img src="https://images2.imgbox.com/95/3c/qd4dZ1o8_o.png" style="margin-left:;display:block;width:787px;margin-top:-95.93392%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">引用和指针有什么区别</h3> 
 <p style=""></p> 
 <p style="">虽然指针和引用很像，而引用能完成的功能指针基本上也能完成，但他们却也有着一些不同</p> 
 <p style=""></p> 
 <h4 style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">1.语法上引用是变量的别名，不开空间，而指针存储一个变量地址。但是引用的底层是用指针实现的。</span></span></h4> 
 <p style=""></p> 
 <p style="">这里虽然从语法上来说引用是一个变量的别名，而指针是一个存储一个变量的地址，但在指令级语言中其实不然，先看下图代码</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:625px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:79.2%;height:0;"> 
    <img src="https://images2.imgbox.com/c5/b9/xjqSe6iM_o.png" style="margin-left:;display:block;width:625px;margin-top:-79.2%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">可以看到，转到反汇编时，调用指针改变一个值和调用引用改变一个值的反汇编是完全相等的，所以由这一点我们也可以知道其实引用就是通过指针实现的，所以说从底层来说引用不开空间，指针才开空间是错误的</p> 
 <p style="">注意：但我们从语法/概念来讲的时候把引用当做不开空间就行，因为如果要纠结底层可能会造成很多的困惑</p> 
 <p style=""></p> 
 <h4 style=""><span class="kdocs-color" style="color:#C21C13;">2.引用必须初始化并且在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何 一个同类型实体 </span></h4> 
 <p style=""></p> 
 <p style="">这一点也就造成了指针能完成的引用完成不了，但引用做不成的指针一定能做</p> 
 <p style="">例如，数据结构中的链表需要不断指向前驱后继结点，所以进入c++后链表也还是通过指针来完成的</p> 
 <p style=""></p> 
 <p style="">而因为引用必须初始化的原因，所以也导致在链表中的前驱和后继无法使用引用只能使用指针</p> 
 <p style=""></p> 
 <h4 style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">3.没有NULL引用，但有NULL指针 </span></span></h4> 
 <p style="">因为引用必须初始化，而既然必须初始化，那么他的类型就是引用实体的类型，可能有人会说</p> 
 <p style="">int*&amp; a 这样的引用一个实体会是空指针嘛？那就让我们看看吧</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:808px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:41.58416%;height:0;"> 
    <img src="https://images2.imgbox.com/a6/2b/nAouhH6x_o.png" style="margin-left:;display:block;width:808px;margin-top:-41.58416%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">可以看到，虽然int*&amp;看似是空引用但其实是一个int*的类型</p> 
 <p style=""></p> 
 <p style=""></p> 
 <h4 style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">4在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32 位平台下占4个字节)</span></span></h4> 
 <p style=""></p> 
 <h4 style=""> <span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">5.引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小 </span></span></h4> 
 <p style=""></p> 
 <p style=""></p> 
 <h4 style=""><span class="kdocs-color" style="color:#C21C13;">6. 有多级指针，但是没有多级引用 </span></h4> 
 <p style=""></p> 
 <p style=""></p> 
 <h4 style=""> <span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">7.访问实体方式不同，指针需要显式解引用，引用编译器自己处理 </span></span></h4> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">总的来说，引用比指针可读性更高，安全性更好，指针比引用更强大，但也更危险</span></span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">一张图总结引用，你能答出来嘛？</h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1398px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:22.67525%;height:0;"> 
    <img src="https://images2.imgbox.com/60/2a/Um5VcOaq_o.png" style="margin-left:;display:block;width:1398px;margin-top:-22.67525%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h2 style="">内联函数</h2> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">定义</h3> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">内联函数就是在调用的时候直接进行展开，而不创造函数栈帧，跟宏很像，现在我们看看效果</span></span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">在开始实验之前我们先调一些东西，因为内联函数在debug版本下不会展开因为要可以进行调试，但release下如果变量不用的话又会自动优化掉，优化会很大所以我们先设置一点，首先右键源文件打开属性然后点开以下两个设置</p> 
 <p style=""></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:984px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:69.51219%;height:0;"> 
    <img src="https://images2.imgbox.com/cf/ce/pLfLQ5c7_o.png" style="margin-left:;display:block;width:984px;margin-top:-69.51219%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:984px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:69.51219%;height:0;"> 
    <img src="https://images2.imgbox.com/b3/2c/EdnnnCdb_o.png" style="margin-left:;display:block;width:984px;margin-top:-69.51219%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">把以上两张图中的画红框的设置成如图所示，现在开始调试吧</p> 
 <p style=""></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:543px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:72.92818%;height:0;"> 
    <img src="https://images2.imgbox.com/f0/c0/UBiFub55_o.png" style="margin-left:;display:block;width:543px;margin-top:-72.92818%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">我们先看看反汇编，我们知道如果函数调用了函数栈帧，对应的反汇编指令就是call ...，如果没有说明函数以及被展开了</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:624px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:36.53846%;height:0;"> 
    <img src="https://images2.imgbox.com/e9/4a/jS5yyLWs_o.png" style="margin-left:;display:block;width:624px;margin-top:-36.53846%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">我们看到，这里没有call...说明函数展开成功！</p> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">特点</h3> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">1、<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">内联函数只适用于小而频繁调用的函数</span></span>，例如swap，add等，并且内联函数<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">如果汇编指令过长(一般超过10行)则内联函数还是会自动调用函数栈帧</span></span>，如图我们看看</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:532px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:75.751884%;height:0;"> 
    <img src="https://images2.imgbox.com/ba/2d/LGOLRAfs_o.png" style="margin-left:;display:block;width:532px;margin-top:-75.751884%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:704px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:55.823864%;height:0;"> 
    <img src="https://images2.imgbox.com/09/72/TVz1xHcv_o.png" style="margin-left:;display:block;width:704px;margin-top:-55.823864%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">2、内联函数不能进行定义和声明分离</span></span></p> 
 <p style="text-indent:1.4em;">如图</p> 
 <p style="">.cpp文件</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1380px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:65.797104%;height:0;"> 
    <img src="https://images2.imgbox.com/3b/86/2pjDpHzq_o.png" style="margin-left:;display:block;width:1380px;margin-top:-65.797104%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">.h文件</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:494px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:42.71255%;height:0;"> 
    <img src="https://images2.imgbox.com/dc/55/wKDWl9k8_o.png" style="margin-left:;display:block;width:494px;margin-top:-42.71255%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">原理：这里是造成了链接错误，我们函数重载时说过，声明在还没找到定义时，会只有函数名而没有地址，等到链接阶段时再把实现的地址填上，但这里的内联函数因为是直接展开的，所以造成这里的声明不会进入符号表，合并符号表的阶段也就不会把他的地址找到，也就造成了链接错误</p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">总结一下：<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">内联函数其实就是为了替换c语言中的宏函数而设计的</span></span>，因为我们知道宏函数本身就非常的难用并且不能调试，也就会造成了很容易出现误用的情况，所以进入以后建议不要用宏函数用内联函数就好了！</p> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">总结</h3> 
 <p style=""></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1108px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:23.555958%;height:0;"> 
    <img src="https://images2.imgbox.com/2c/c6/zMV7sTug_o.png" style="margin-left:;display:block;width:1108px;margin-top:-23.555958%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <h2 style="">auto</h2> 
 <p style=""></p> 
 <h3 style="">定义</h3> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">auto是c++中新加的一个关键字，他的作用是<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">可以根据赋给他的变量自动推导出类型</span></span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">如下</p> 
 <p style=""></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:37.027027%;height:0;"> 
    <img src="https://images2.imgbox.com/c3/c1/TzvlSp8P_o.png" style="margin-left:;display:block;width:740px;margin-top:-37.027027%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <h3 style="">常用场景</h3> 
 <p style=""></p> 
 <p style=""></p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">当有一个类型非常长的时候，用auto是非常方便的例如（特别是当我们学到c++中的stl时）</span></span></p></li></ol> 
 <p style=""></p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">当要遍历一个数组...这种结构时，c++11支持使用范围for，格式为：for(auto e : 数组名)</span></span></p></li></ol> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">如下</span></span></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:659px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:47.799698%;height:0;"> 
    <img src="https://images2.imgbox.com/ef/d9/ljQDqKok_o.png" style="margin-left:;display:block;width:659px;margin-top:-47.799698%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">而当我们要修改的时候试试</p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:594px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:69.52862%;height:0;"> 
    <img src="https://images2.imgbox.com/20/f1/GyzGLqtb_o.png" style="margin-left:;display:block;width:594px;margin-top:-69.52862%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="">好像并没有成功，为什么？</p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">因为<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">一个变量赋值给另一个变量会创建一个临时拷贝</span></span>，所以这里改变e的值并不会改变a的值，要改变a的值我们就要加上引用，如下</p> 
 <p style=""></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:636px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:64.308174%;height:0;"> 
    <img src="https://images2.imgbox.com/fe/4c/v4rXdwBi_o.png" style="margin-left:;display:block;width:636px;margin-top:-64.308174%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:650px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:62.615383%;height:0;"> 
    <img src="https://images2.imgbox.com/df/5c/cidzWFLX_o.png" style="margin-left:;display:block;width:650px;margin-top:-62.615383%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h3 style="">总结</h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:813px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:22.017221%;height:0;"> 
    <img src="https://images2.imgbox.com/b3/8b/8VcX2Yez_o.png" style="margin-left:;display:block;width:813px;margin-top:-22.017221%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""></p> 
 <h2 style="">c++语法入门总结</h2> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">总结并不会直接告诉答案，需要对应问题去原文中找，并且没有标准答案，试试拿着这些问题讲给自己，能讲出来就代表已经掌握了</span></span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1176px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:54.506805%;height:0;"> 
    <img src="https://images2.imgbox.com/2e/b4/nlG7ufMN_o.png" style="margin-left:;display:block;width:1176px;margin-top:-54.506805%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d68c82235ebee1a84d27c81442da9f4d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">K-means聚类算法的三种改进(K-means&#43;&#43;,ISODATA,Kernel K-means)介绍与对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/082aca5a6939addd42d9c693ec5479ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python求遍历、最短路径、最小生成树、旅行商问题并绘图展示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>