<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java Fork/Join框架学习（一） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java Fork/Join框架学习（一）" />
<meta property="og:description" content="1. 序言：分治算法 ForkJoinTask使用了的分治算法的思想，因此在学习ForkJoinTask前，回顾下分治算法实际问题：国家开展人口普查，如何统计人口数？负责该事项的工作人员，肯定不会傻傻地带上电脑，一个人走遍全中国而是将该事项下发到省，省下发到市，市下发到县，县下发到镇，镇下发到乡（divide，分）假设乡足够小，工作人员能够轻松完成乡上人口的统计，这时候便可以不再下发任务，直接统计乡人口然后镇汇总乡、县汇总镇、市汇总县、省汇总市，中央汇总省，从而完成此次人口普查（combine，合）分治算法包含三大步： Divide：将问题划分为两个或两个以上与原始问题相似但规模较小的子问题。Conquer：如果子问题足够小，则直接求解；否则，递归求解子问题。Combine: 合并子问题的解决方案，以构建原始问题的解 如何理解递归求解子问题？ 在笔者看来，divide：需要将问题分解为足够小的子问题，但是很难一次就完成。因此，需要递归地对子问题进行分解，直到能直接求解这样来看，divide和conquer是无法严格界定的，因为在conquer时，如果发现子问题不能直接求解，还需要递归地进行divide &amp; conquer 下面的代码很好地解释了分治算法的整个流程：divideAndConquer(big_problem){ if (canSolve(big_problem)){ //问题可以直接求解则直接求解返回 solve(big_problem); //求解 return; } else { small_problem_A = divide(big_problem); //不能直接求解的问题拆分 small_problem_B = divide(big_problem); //不能直接求解的问题拆分 divideAndConquer(small_problem_A); //递归求解子问题 divideAndConquer(small_problem_B); //递归求解子问题 return merge(); //合并子问题的解 } } 2. Fork/Join框架 2.1 Fork/Join框架概述 JDK 7开始，引入了Fork/Join框架
该框架采用了分治算法的思想，将大任务拆分为若干个独立的小任务，最后合并每个小任务的执行结果以得到大任务的执行结果
这样可以充分利用操作系统的多核特性，加速对小任务的并行处理，从而提高大任务的吞吐量
可以说，Java的Fork/Join框架，提供了一种充分利用所有可用的处理能力来加速并行处理的工具
伪代码解释如下：
// from 《A Java Fork/Join Framework》Dong Lea Result solve(Problem problem) { if (problem is small) directly solve problem else { split problem into independent parts fork new subtasks to solve each part join all subtasks compose result from subresults } } 注意： ForkJoinTask的类注释中，明确提到：一个非常粗略的经验法则，一个任务的基本计算步骤应该 &gt; 100 且 &lt; 10000，同时需要避免无循环" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/696083229909cd7b707b2b7ae7c62328/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-05T21:36:35+08:00" />
<meta property="article:modified_time" content="2022-10-05T21:36:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java Fork/Join框架学习（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__0"></a>1. 序言：分治算法</h2> 
<ul><li>ForkJoinTask使用了的分治算法的思想，因此在学习ForkJoinTask前，回顾下分治算法</li><li>实际问题：国家开展人口普查，如何统计人口数？</li><li>负责该事项的工作人员，肯定不会傻傻地带上电脑，一个人走遍全中国</li><li>而是将该事项下发到省，省下发到市，市下发到县，县下发到镇，镇下发到乡（divide，分）</li><li>假设乡足够小，工作人员能够轻松完成乡上人口的统计，这时候便可以不再下发任务，直接统计乡人口</li><li>然后镇汇总乡、县汇总镇、市汇总县、省汇总市，中央汇总省，从而完成此次人口普查（combine，合）</li><li>分治算法包含三大步： 
  <ul><li>Divide：将问题划分为两个或两个以上与原始问题相似但规模较小的子问题。</li><li>Conquer：如果子问题足够小，则直接求解；否则，递归求解子问题。</li><li>Combine: 合并子问题的解决方案，以构建原始问题的解</li></ul> </li><li><strong>如何理解递归求解子问题？</strong> 
  <ul><li>在笔者看来，divide：需要将问题分解为足够小的子问题，但是很难一次就完成。因此，需要递归地对子问题进行分解，直到能直接求解</li><li>这样来看，divide和conquer是无法严格界定的，因为在conquer时，如果发现子问题不能直接求解，还需要递归地进行divide &amp; conquer</li></ul> </li><li>下面的代码很好地解释了分治算法的整个流程：<pre><code class="prism language-java"><span class="token function">divideAndConquer</span><span class="token punctuation">(</span>big_problem<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">canSolve</span><span class="token punctuation">(</span>big_problem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//问题可以直接求解则直接求解返回</span>
      <span class="token function">solve</span><span class="token punctuation">(</span>big_problem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//求解</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      small_problem_A <span class="token operator">=</span> <span class="token function">divide</span><span class="token punctuation">(</span>big_problem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不能直接求解的问题拆分</span>
      small_problem_B <span class="token operator">=</span> <span class="token function">divide</span><span class="token punctuation">(</span>big_problem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不能直接求解的问题拆分</span>
      <span class="token function">divideAndConquer</span><span class="token punctuation">(</span>small_problem_A<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归求解子问题</span>
      <span class="token function">divideAndConquer</span><span class="token punctuation">(</span>small_problem_B<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归求解子问题</span>
      <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//合并子问题的解</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h2><a id="2_ForkJoin_29"></a>2. Fork/Join框架</h2> 
<h3><a id="21_ForkJoin_30"></a>2.1 Fork/Join框架概述</h3> 
<ul><li> <p>JDK 7开始，引入了Fork/Join框架</p> </li><li> <p>该框架采用了<strong>分治算法</strong>的思想，将大任务拆分为若干个独立的小任务，最后合并每个小任务的执行结果以得到大任务的执行结果</p> </li><li> <p>这样可以充分利用操作系统的多核特性，加速对小任务的并行处理，从而提高大任务的吞吐量</p> </li><li> <p>可以说，Java的Fork/Join框架，提供了一种充分利用所有可用的处理能力来<strong>加速并行处理</strong>的工具<br> <img src="https://images2.imgbox.com/51/27/48hZpRgZ_o.png" width="60%"></p> </li><li> <p>伪代码解释如下：</p> <pre><code class="prism language-java"><span class="token comment">// from 《A Java Fork/Join Framework》Dong Lea</span>
<span class="token class-name">Result</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token class-name">Problem</span> problem<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>problem is small<span class="token punctuation">)</span>
 		directly solve problem
 	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
 		split problem into independent parts
 		fork <span class="token keyword">new</span> subtasks <span class="token keyword">to</span> <span class="token namespace">solve</span> each part
 		join all subtasks
 		compose result from subresults
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>注意：</strong> ForkJoinTask的类注释中，明确提到：一个非常粗略的经验法则，一个任务的基本计算步骤应该 &gt; 100 且 &lt; 10000，同时需要避免无循环</p> 
  <ul><li>因为如果任务过大，无法充分利用处理器的多核特性，导致任务吞吐量较低</li><li>如果任务太小，并发执行时的上下文切换、内存开销等会使得操作系统高负载，反而不利于任务的执行</li></ul> </li></ul> 
<h3><a id="22_fork__join_57"></a>2.2 fork &amp; join</h3> 
<p><strong>fork</strong></p> 
<ul><li>fork/join框架先将任务递归分解为较小的独立子任务，直到这些子任务足够简单以异步执行。</li><li>英文单词fork的动词释义为分岔，结合上图（类似树状图）对任务拆分过程的描述，就像将较大的任务分岔出多个子任务一样</li><li>所以，这里的拆分操作就叫做fork</li></ul> 
<p><strong>join</strong></p> 
<ul><li>完成任务拆分后，等子任务执行完成，需要将所有子任务的结果递归汇总成一个结果（也就是大任务的执行结果）</li><li>在SQL领域，join用于将多张表的结果关联起来</li><li>在fork/join框架中，将子任务的结果汇总起来，就是一种join操作</li></ul> 
<h3><a id="23__67"></a>2.3 重要成员</h3> 
<h4><a id="231_ForkJoinPool_68"></a>2.3.1 ForkJoinPool</h4> 
<ul><li>Fork/Join框架的专用线程池，一种用于运行ForkJoinTask的ExecutorService</li><li>ForkJoinPool只接受ForkJoinTask类型的任务，虽然Runnable或Callable任务也能正常提交，但是会被ForkJoinPool自动转化为ForkJoinTask</li><li>实现了工作窃取（<code>work-stealing</code>）算法，最大程度利用线程池中的线程，避免这些线程累的累死、闲的闲死，从而提高任务的处理效率</li><li>work-stealing：空闲的工作线程从其他处于busy状态的工作线程处窃取等待执行的任务，准确地说：从处于busy状态的工作线程关联的WorkQueue中窃取等待执行的任务</li></ul> 
<h4><a id="232_ForkJoinTask_73"></a>2.3.2 ForkJoinTask</h4> 
<ul><li>Fork/Join框架中任务的抽象基类，它有三个常用的抽象子类： 
  <ul><li>有返回值的<code>RecursiveTask</code></li><li>无返回值的<code>RecursiveAction</code></li><li>带钩子函数的<code>CountedCompleter</code>，在任务完成后会触发钩子函数；这里的完成，可能是正常执行完毕，也可能是异常退出</li></ul> </li><li>使用时，一般会继承上述三个子类来实现业务需求，而不会直接继承 ForkJoinTask 类</li><li>在ForkJoinPool中，ForkJoinTask分为两类： 
  <ul><li>外部提交的<code>submission task</code>，即非ForkJoin线程（non-FJ threads）通过ForkJoinPool的invoke()、execute()、submit()方法提交的任务</li><li>ForkJoinTask执行过程中，通过fork操作分割出的子任务，<code>worker task</code></li></ul> </li></ul> 
<h4><a id="233_WorkQueue_83"></a>2.3.3 WorkQueue</h4> 
<ul><li> <p>同其他线程池一样，ForkJoinPool也使用队列对提交到池中的任务进行管理</p> </li><li> <p>WorkQueue是一个双端队列，支持任务提交和work-stealing</p> </li><li> <p>它包含<code>top</code>和<code>base</code>两个指针，正常的任务提交和获取在top处进行，work-stealing在base处进行</p> 
  <ul><li>任务都是从队列的top处插入，简称push操作<pre><code class="prism language-java">q<span class="token punctuation">.</span>array<span class="token punctuation">[</span>q<span class="token punctuation">.</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> task<span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">.</span>top<span class="token punctuation">;</span>
</code></pre> </li><li>工作线程从自身关联队列的top处<strong>获取</strong>task，简称pop操作 —— <strong>LIFO序</strong><pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>base <span class="token operator">!=</span> top<span class="token punctuation">)</span> and
	<span class="token punctuation">(</span>the task at top slot is not <span class="token keyword">null</span><span class="token punctuation">)</span> and
   <span class="token punctuation">(</span>CAS slot <span class="token keyword">to</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       decrement top and <span class="token keyword">return</span> task<span class="token punctuation">;</span>
</code></pre> </li><li>工作线程从其他队列的base处<strong>窃取</strong>task，简称poll操作 —— <strong>FIFO序</strong><pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>base <span class="token operator">!=</span> top<span class="token punctuation">)</span> and
     <span class="token punctuation">(</span>the task at base slot is not <span class="token keyword">null</span><span class="token punctuation">)</span> and
     <span class="token punctuation">(</span>base has not changed<span class="token punctuation">)</span> and
     <span class="token punctuation">(</span>CAS slot <span class="token keyword">to</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         increment base and <span class="token keyword">return</span> task<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>ForkJoinPool中，有一个<code>WorkQueue[]</code>数组，名叫<code>workQueues</code>：</p> 
  <ul><li>下标为偶数（<code>even</code>）的WorkQueue用于存储submission task，叫做<code>submission queue</code>或<code>shared queue</code></li><li>下标为奇数（<code>odd</code>）的WorkQueue用于存储worker task，叫做<code>worker queue</code>或<code>un-shared queue</code></li></ul> </li><li> <p><strong>为什么submission queue又叫shared queue？</strong> —— 介绍完ForkJoinWorkerThread就能回答该问题</p> </li></ul> 
<h4><a id="234_ForkJoinWorkerThread_111"></a>2.3.4 ForkJoinWorkerThread</h4> 
<ul><li>ForkJoinPool中执行ForkJoinTask的工作线程，又叫<strong>worker</strong></li><li>ForkJoinWorkerThread<strong>没有公开的构造函数</strong>，只能通过实现ForkJoinPool.ForkJoinWorkerThreadFactory接口中的newThread()方法进行创建<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">ForkJoinWorkerThread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">ForkJoinPool</span> pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li>ForkJoinPool也提供了ForkJoinWorkerThreadFactory接口的默认实现：<code>DefaultForkJoinWorkerThreadFactory</code></li><li>ForkJoinPool只为<code>worker queue</code>分配ForkJoinWorkerThread，而submission queue没有对应的ForkJoinWorkerThread</li></ul> 
<p><strong>work-stealing的重要性</strong></p> 
<ul><li>由于submission queue未关联worker，外部提交的submission task进入submission queue后，如果不借助work-stealing则永远无法执行</li><li>work-stealing使得worker queue关联的空闲worker会从submission queue窃取任务并执行，从而保证了submission task的正常执行</li></ul> 
<p><strong>为什么submission queue又叫shared queue？</strong></p> 
<ul><li>submission queue中的任务，必须借助worker queue关联的worker + work stealing才能被执行</li><li>它就像一个共享的queue一样，任何worker都可以从其中<strong>窃取</strong>任务并执行</li><li>submission queue的开放性 + work stealing，弥补了submission queue没有worker的短处</li></ul> 
<h4><a id="235__128"></a>2.3.5 小结</h4> 
<ul><li>如果不考虑具体细节，Fork/Join框架的四个重要成员的关系如下图所示<br> <img src="https://images2.imgbox.com/01/36/Dw4ixum1_o.png" width="90%"></li></ul> 
<h2><a id="3_ForkJoin_132"></a>3. 编程实战，体验Fork/Join框架</h2> 
<ul><li>基于ForkJoinTask的抽象子类RecursiveTask和RecursiveAction进行编程实战，以体验Fork/Join框架</li></ul> 
<h3><a id="31__134"></a>3.1 数组排序</h3> 
<ul><li> <p>对于有成千上万个元素的数组进行排序，可以考虑使用Fork/Join框架，将其划分成合适大小的子数组后，直接使用<code>Arrays.sort()</code>进行排序</p> </li><li> <p>排序过程中，直接对数组进行操作，无需任何返回值。因此，可以继承RecursiveAction实现对应的ForkJoinTask</p> </li><li> <p>排序任务的实现</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SortArrayTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveAction</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">SortArrayTask</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">SortArrayTask</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>array <span class="token operator">=</span> array<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>low <span class="token operator">=</span> low<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>high <span class="token operator">=</span> high<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 自定义compute方法，在其中实现排序任务的分治逻辑：
     * &lt;p&gt;1. 定义最小执行单元：满足条件，可以不用继续拆分（fork），直接进行计算&lt;/p&gt;
     * &lt;p&gt;2. 定义任务的拆分逻辑：不满足条件时，如何拆分任务&lt;/p&gt;
     * &lt;p&gt;3. 定义合并逻辑（如果需要的话）：合并子任务的执行合并&lt;/p&gt;
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 满足最小执行单元，直接进行排序</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low <span class="token operator">&lt;</span> THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">sortArray</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 拆分数组，分别进行排序</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token class-name">SortArrayTask</span> leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortArrayTask</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">SortArrayTask</span> rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortArrayTask</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">invokeAll</span><span class="token punctuation">(</span>leftTask<span class="token punctuation">,</span> rightTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 合并排序结果,参考RecursiveAction类的注释，实现的一种减少空间和时间复杂度的、巧妙的合并方法</span>
            <span class="token function">mergeArray</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mergeArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 先将左半部分复制到临时数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将临时数组与右半部分比较，实现数组合并</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 合并temp[k]的情况：① 右半部分没有了元素；② 右半部分有元素，但数值较大</span>
            array<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;</span> high <span class="token operator">||</span> temp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> array<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mergeArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> low1<span class="token punctuation">,</span> <span class="token keyword">int</span> high1<span class="token punctuation">,</span> <span class="token keyword">int</span> low2<span class="token punctuation">,</span> <span class="token keyword">int</span> hig2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>hig2 <span class="token operator">-</span> low1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left1 <span class="token operator">=</span> low1<span class="token punctuation">;</span>
        <span class="token keyword">int</span> left2 <span class="token operator">=</span> low2<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left1 <span class="token operator">&lt;=</span> high1 <span class="token operator">&amp;&amp;</span> left2 <span class="token operator">&lt;=</span> hig2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>left1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>left2<span class="token punctuation">]</span> <span class="token operator">?</span> array<span class="token punctuation">[</span>left1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> array<span class="token punctuation">[</span>left2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 合并剩余元素</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left1 <span class="token operator">&lt;=</span> high1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>left1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left2 <span class="token operator">&lt;=</span> hig2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>left2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将临时数组复制到当前数组</span>
        k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>low1 <span class="token operator">&lt;=</span> hig2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            array<span class="token punctuation">[</span>low1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s -- 数组排序，start：%d, end: %d\n"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Arrays.sort()不包含end元素</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>使用ForkJoinPool提交排序任务，排序完成后，为了观察排序效果打印首尾10个元素</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SortArrayTaskTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始化待排序数组数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token class-name">SortArrayTaskTest</span><span class="token punctuation">.</span><span class="token function">generateIntArray</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 通过ForkJoinPool提交并执行ForkJoinTask</span>
        <span class="token comment">// 使用ForkJoinPool提供的common线程池，未自定义ForkJoinPool</span>
        <span class="token class-name">ForkJoinPool</span> forkJoinPool <span class="token operator">=</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span><span class="token function">commonPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token comment">// 直接执行任务，invoke()方法会在任务执行结束后返回结果</span>
        forkJoinPool<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SortArrayTask</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印数组的首尾元素</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后，数组前10个元素"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n排序后，数组后10个元素"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">11</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">generateIntArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token class-name">RandomStringUtils</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> array<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>执行结果如下，通过执行结果可知：以1000为阈值，将原始数组划分为多个大小不超过1000的子数组，排序、合并后得到一个全局有序的数组<br> <img src="https://images2.imgbox.com/8e/94/hpgM5kLa_o.png" width="80%"></p> </li></ul> 
<h3><a id="32__253"></a>3.2 统计数组中超过阈值的元素个数</h3> 
<ul><li> <p>统计数组中超过阈值的元素个数，如果数组过大，同样可以考虑使用Fork/Join框架：将其划分成合适大小的子数组后，直接遍历、统计</p> </li><li> <p>每个统计任务，需要返回当前子数组中超过阈值的元素个数。因此，因此需要继承<code>RecursiveTask&lt;Integer&gt;</code>实现对应的ForkJoinTask</p> </li><li> <p>基于Fork/Join框架的统计任务实现如下：</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountElementTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIZE_THRESHOLD <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">CountElementTask</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">,</span> threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">CountElementTask</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>array <span class="token operator">=</span> array<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Integer</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//  最小执行单元，直接遍历数组，统计超过阈值的元素个数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">&lt;=</span> SIZE_THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 打印相关信息</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s -- 遍历数组，start: %d, end: %d\n"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    count<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 拆分子任务，递归求解</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">+</span> start<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">CountElementTask</span> task1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountElementTask</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CountElementTask</span> task2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountElementTask</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">,</span> threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// fork()会将任务插入ForkJoinPool的队列，是递归求解的关键</span>
        <span class="token comment">// System.out.printf("%s -- 向队列提交子任务，task1: start = %d, end = %d, task2: start = %d; end2 = %d\n",Thread.currentThread().getName(), start, mid, mid, end);</span>
        task1<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        task2<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 合并子任务结果：worker从当前队列获取任务并执行，需要按照innermost-first原则</span>
        <span class="token keyword">return</span> task2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> task1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>使用统计任务，对有3000个元素的数组进行统计，统计其超过<code>阈值5000</code>的元素个数</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountElementTaskTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ARRAY_SIZE <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始化待排序数组数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token class-name">SortArrayTaskTest</span><span class="token punctuation">.</span><span class="token function">generateIntArray</span><span class="token punctuation">(</span>ARRAY_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 通过ForkJoinPool提交并执行ForkJoinTask</span>
        <span class="token class-name">ForkJoinPool</span> forkJoinPool <span class="token operator">=</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span><span class="token function">commonPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ForkJoinTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CountElementTask</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取任务执行结果</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数组中，共%d个元素超过阈值%d\n"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 直接遍历，比较统计结果</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"直接遍历的统计结果：共%d个元素超过阈值%d"</span><span class="token punctuation">,</span> count<span class="token punctuation">,</span> THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> </li><li> <p>执行结果如下：<br> <img src="https://images2.imgbox.com/08/fc/2V1YMfB9_o.png" width="80%"></p> </li></ul> 
<h3><a id="33__336"></a>3.3 一些疑问</h3> 
<ul><li>从上面的编程实战可知，任务的执行逻辑都定义在了重写的<code>compute()</code>方法中。</li><li>只是简单地向ForkJoinPool提交了一个原始任务，后续就自动按照<code>compute()</code>方法的逻辑对任务进行递归求解</li><li><strong>疑问一</strong>： 向ForkJoinPool提交任务后，最终是如何执行到<code>compute()</code>方法的？</li></ul> 
<hr> 
<ul><li>实现数组排序时，拆分出的SortArrayTask子任务并未调用其fork()和join()方法，而是直接使用用invokeAll()</li><li>而实现数组中超过阈值的元素统计时，却使用fork()、join()方法处理CountElementTask子任务</li><li><strong>疑问二</strong>：在Fork/Join框架中，任务的拆分、执行与合并可以使用哪些方法？这些方法有何区别？</li></ul> 
<hr> 
<ul><li>向ForkJoinPool提交任务时，示例1使用的是<code>invoke()</code>方法，示例2使用的<code>submit()</code>方法</li><li><strong>疑问三</strong>：Client（或submiter）可以通过哪些方法向ForkJoinPool提交任务？这些方法有何区别？</li></ul> 
<hr> 
<ul><li>前面对Fork/Join框架的四个重要成员的简单介绍，小结如下： 
  <ul><li>Fork/Join框架中，ForkJoinPool使用WorkQueue（队列）对ForkJoinTask进行管理</li><li>下标为偶数 or 奇数的队列，其职责有所差异： 
    <ul><li>下标为<strong>偶数</strong>的队列 
      <ul><li>叫做submission queue或share queue，只负责存储外部submiter提交的任务；</li><li>同时，由于没有对应的worker与之关联，借助work- stealing机制，submission queue中的任务才得以执行</li></ul> </li><li>下标为<strong>奇数</strong>的队列： 
      <ul><li>叫做worker queue，关联一个worker，最初的任务是借助worke-stealing机制从submission queue窃取的</li><li>在处理任务的过程中，worker会fork出的新任务将提交到当前队列</li><li>当前队列有任务后，worker会从当前队列的top处获取任务</li><li>worker在当前队列的push和pop操作，因为单线程而不用考虑并发</li></ul> </li></ul> </li></ul> </li><li><strong>疑问四</strong>：submiter提交的任务，是如何push到submission queue的？</li><li><strong>疑问五</strong>：submission queue没有worker与之关联，而worker queue却有，这两种的队列的创建有何区别？</li><li><strong>疑问六</strong>：work-stealing是如何实现的？</li></ul> 
<hr> 
<ul><li><strong>疑问…</strong></li><li>用笔者和同事之间交流的一句话说：很多东西看似简单，只要你肯深入学习，没有个几天你是搞不定的</li><li>后续的内容，我们将带着上面的这些疑惑，去深入学习Fork/Join框架</li></ul> 
<hr> 
<ul><li>Fork/Join框架的相关内容太多，拆分成多篇博客 
  <ul><li>下一篇博客： <a href="https://blog.csdn.net/u014454538/article/details/127152697">Java Fork/Join框架学习（二）</a></li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb04f3e76616e5897507ecfe21d97deb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常见的css兼容问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3a410bf5b99196edd51a0cfe5c3ebc99/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">有公网IP内网穿透配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>