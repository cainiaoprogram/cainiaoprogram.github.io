<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ServiceConnection - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ServiceConnection" />
<meta property="og:description" content="绑定到一个Service 应用组件(客户端)可以调用bindService()绑定到一个service．Android系统之后调用service的onBind()方法，它返回一个用来与service交互的IBinder．
绑定是异步的．bindService()会立即返回，它不会返回IBinder给客户端．要接收IBinder，客户端必须创建一个ServiceConnection的实例并传给bindService()．ServiceConnection包含一个回调方法，系统调用这个方法来传递要返回的IBinder．
注：只有activities,services,和contentproviders可以绑定到一个service—你不能从一个broadcastreceiver绑定到service．
所以，从你的客户端绑定到一个service，你必须：
１实现ServiceConnection.
你的实现必须重写两个回调方法：
onServiceConnected()
系统调用这个来传送在service的onBind()中返回的IBinder．
OnServiceDisconnected()
Android系统在同service的连接意外丢失时调用这个．比如当service崩溃了或被强杀了．当客户端解除绑定时，这个方法不会被调用．
２调用bindService()，传给它ServiceConnection的实现．
３当系统调用你的onServiceConnected()方法时，你就可以使用接口定义的方法们开始调用service了．
４要与service断开连接，调用unbindService()．
当你的客户端被销毁，它将从service解除绑定，但是你必须总是在你完成与service的交互时或当你的activity暂停于是service在不被使用时可以关闭此两种情况下解除绑定．(下面会讨论更多在适当的时候绑定和解除绑定的问题．)
例如，下面是前一篇＂派生Binder类＂中创建的代码片段，它把客户端连接到了service．所有需要做的就是把返回的IBinder强制转换到LocalBinder类并且请求LocalService实例：
LocalService mService; private ServiceConnection mConnection = new ServiceConnection() { // 当与service的连接建立后被调用 public void onServiceConnected(ComponentName className, IBinder service) { // Because we have bound to an explicit // service that is running in our own process, we can // cast its IBinder to a concrete class and directly access it. LocalBinder binder = (LocalBinder) service; mService = binder." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ece78a70b624b88f562799ec52ddb02d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-19T16:39:43+08:00" />
<meta property="article:modified_time" content="2018-09-19T16:39:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ServiceConnection</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>绑定到一个Service</h4> 
<p>应用组件(客户端)可以调用bindService()绑定到一个service．Android系统之后调用service的onBind()方法，它返回一个用来与service交互的IBinder．</p> 
<p>绑定是异步的．bindService()会立即返回，它不会返回IBinder给客户端．要接收IBinder，客户端必须创建一个ServiceConnection的实例并传给bindService()．ServiceConnection包含一个回调方法，系统调用这个方法来传递要返回的IBinder．</p> 
<p><em>注：只有activities,services,和contentproviders可以绑定到一个service—你不能从一个broadcastreceiver绑定到service．</em></p> 
<p>所以，从你的客户端绑定到一个service，你必须：</p> 
<ul><li> <p>１实现ServiceConnection.</p> <p>你的实现必须重写两个回调方法：</p> 
  <ul><li> <p>onServiceConnected()</p> <p>系统调用这个来传送在service的onBind()中返回的IBinder．</p> </li><li> <p>OnServiceDisconnected()</p> <p><a href="http://lib.csdn.net/base/15" rel="nofollow">Android</a>系统在同service的连接意外丢失时调用这个．比如当service崩溃了或被强杀了．当客户端解除绑定时，这个方法不会被调用．</p> </li></ul></li><li> <p>２调用bindService()，传给它ServiceConnection的实现．</p> </li><li> <p>３当系统调用你的onServiceConnected()方法时，你就可以使用接口定义的方法们开始调用service了．</p> </li><li> <p>４要与service断开连接，调用unbindService()．</p> <p>　　当你的客户端被销毁，它将从service解除绑定，但是你必须总是在你完成与service的交互时或当你的activity暂停于是service在不被使用时可以关闭此两种情况下解除绑定．(下面会讨论更多在适当的时候绑定和解除绑定的问题．)</p> </li></ul> 
<p>例如，下面是前一篇＂<a href="http://blog.csdn.net/nkmnkm/article/details/7367227">派生Binder类</a>＂中创建的代码片段，它把客户端连接到了service．所有需要做的就是把返回的IBinder强制转换到LocalBinder类并且请求LocalService实例：</p> 
<pre class="has"><code class="language-java">LocalService mService;  
private ServiceConnection mConnection = new ServiceConnection() {  
    // 当与service的连接建立后被调用  
    public void onServiceConnected(ComponentName className, IBinder service) {  
        // Because we have bound to an explicit  
        // service that is running in our own process, we can  
        // cast its IBinder to a concrete class and directly access it.  
        LocalBinder binder = (LocalBinder) service;  
        mService = binder.getService();  
        mBound = true;  
    }  
  
    // 当与service的连接意外断开时被调用  
    public void onServiceDisconnected(ComponentName className) {  
        Log.e(TAG, "onServiceDisconnected");  
        mBound = false;  
    }  
};</code></pre> 
<p>使用这个ServiceConnection，客户端可以绑定到一个service，通过把它传给bindService()．例如：</p> 
<p>Intentintent = new Intent(this, LocalService.class);</p> 
<p>bindService(intent,mConnection, Context.BIND_AUTO_CREATE);</p> 
<ul><li> <p>第一个bindService()的参数是一个明确指定了要绑定的service的Intent．</p> </li><li> <p>第二个参数是ServiceConnection对象．</p> </li><li> <p>第三个参数是一个标志，它表明绑定中的操作．它一般应是BIND_AUTO_CREATE，这样就会在service不存在时创建一个．其它可选的值是BIND_DEBUG_UNBIND和BIND_NOT_FOREGROUND,不想指定时设为0即可．</p> </li></ul> 
<h4>补充事项</h4> 
<p>下面是一些关于绑定到service的重要事项：</p> 
<ul><li> <p>你总是需要捕获DeadObjectException异常．它会在连接被打断时抛出．这是被远程方法抛出的唯一异常．</p> </li><li> <p>对象引用计数是跨进程的作用的．</p> </li><li> <p>你应该在客户端的生命期内使绑定和解除绑定配对进行，例如：</p> 
  <ul><li> <p>如果你需要在你的activity可见时与service交互，你应该在onStart()绑定并在onStop()中解除绑定．</p> </li><li> <p>如果你想让你的activity即使在它停止时也能接收回应，那么你可以在onCreate()中绑定并在onDestroy()中解除绑定．注意这意味着你的activity需要使用在自己整个运行期间使用service(即使位于后台)，所以如果service在另一个进程中，那么你增加了这个进程的负担而使它变得更容易被系统杀掉．</p> </li></ul></li></ul> 
<p>　　注：你一般不应该在你的activity的onResume()和onPause()中绑定和解除绑定到service，因为这些回调方法,出现在每个生命期变化中，并且你需要使发生在这些变化中的处理最小化．还有，如果你应用中的多个activity绑定到同一个service，并且有一个变化发生在其中两个activity之间，service可能在当前activity解除绑定(pause中)和下一个绑定前(rusume中)被销毁又重建．</p> 
<p>管理BoundService的生命期</p> 
<p>　　当一个service的所有客户端都解除绑定，Android系统就销毁它(除非它是从onStartCommand()启动)．如果你的service是一个纯boundservice，你不需管理它的生命期—Android系统会为你管理它．</p> 
<p>　　然而，如果你选择了实现onStartCommand()回调方法，那么你必须明确地停止service，因为service现在被认为是＂开始的＂．在此情况下，service会一直运行，直到service使用stopSelf()停止它自己或另外的组件调用了stopService()停止了它，不管是否有客户端绑定了它．</p> 
<p>　　另外，如果你的service已经启动并且接受绑定，那么当系统调用你的onUnbind()方法，你可以选择返回true表示你想在客户端下一次绑定到service时接受一个对onRebind()的调用(而不是一个对onBind()的调用)．onRebind()返回void，但是客户端依然会在它的onServiceConnected()回调中接收到IBinder．下图演示了这种生命其的逻辑：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/7c/34/U0GbRFob_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a87d3f47a9872fe8b28e4d99c7a98436/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java 根据模板文件生成word文档</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51e210ca19f1d79ae8329fe7a8cf357d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Conference Partner 会议</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>