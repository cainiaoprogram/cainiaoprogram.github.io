<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CTF-Crypto 出题思路与解题思路 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CTF-Crypto 出题思路与解题思路" />
<meta property="og:description" content="CTF-Crypto 出题思路：区块链、公钥RSA、流密码、分组密码
机密性(加密算法)、完整性(消息摘要)、可用性、认证性(认证签名)、不可否认性、
编码基础|HEX：a-f 0-9，考虑ascii解码
编码基础|Base64:A-W a-w 0-9 &#43; / 共64个字符使用4字符表达3字节，不足用0替换，也即是=
import base64 str = &#34;解密字符串&#34; //将数字用！@#等替换 basestr = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#34; newstr = &#39;&#39; table = &#39;)!@#$%^&amp;*(&#39; for i in str: if i not in table: newstr=newstr &#43; i else newstr=newstr&#43;(table.index(i)) import base64 print(base.b64decode(newstr)) 编码基础|古典密码学：单表代换加密–爆破和词频分析
凯撒密码：向前或后移动若干位。特定凯撒密码名–偏移量10 Avocat、偏移量13 ROT13、偏移量-5 Cassis、偏移量-6 Cassette摩斯密码：点线键盘密码：用手机九宫格或键盘位置加密猪圈密码：以格子为基础的替换密码培根密码：使用两种不同字体代表AB结合加密表加密栅栏密码：要加密明文分成N个一组，然后每组第一个字相连曲路密码：明文划分为矩阵维吉尼亚密码：使用多表替换，同凯撒，利用重合性字频分析爆破Polybius、BrainFuck、与佛论禅、社会主义核心价值观编码、Ook！、云影密码(01246)、JsFuck(()[]!&#43;)、圣堂武士密码、夏多密码(曲折加密)、跳舞的小人密码、 编码基础|仿射密码：一小串字母数字，有2个以上重复字母
加密函数：E(x) = (ax &#43; b) (mod m)，其中 a与b互质，m是编码系统中字母的个数（通常都是26）。
解密函数：D(x) = a^-1(x-b)(mod m)，a的逆元可以用pow(a,-1,m)求出，
异或加密|OTP一次性密码本：key长度大于message，一次性key
现代密码|哈希函数：散列算法，单向性、固定长度、雪崩效应—MD5 16字节
flag = &#39;d0g3{&#39; &#43; hashlib." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3cf0f33623758f41f3297a2198c5aea3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-30T09:09:01+08:00" />
<meta property="article:modified_time" content="2023-06-30T09:09:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CTF-Crypto 出题思路与解题思路</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="CTFCrypto_1"></a>CTF-Crypto</h2> 
<hr> 
<p>出题思路：区块链、公钥RSA、流密码、分组密码</p> 
<p>机密性(加密算法)、完整性(消息摘要)、可用性、认证性(认证签名)、不可否认性、</p> 
<ol><li> <p>编码基础|HEX：a-f 0-9，考虑ascii解码</p> </li><li> <p>编码基础|Base64:A-W a-w 0-9 + / 共64个字符使用4字符表达3字节，不足用0替换，也即是=</p> <pre><code class="prism language-python"><span class="token keyword">import</span> base64
<span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">"解密字符串"</span> <span class="token operator">//</span>将数字用！@<span class="token comment">#等替换</span>
basestr <span class="token operator">=</span> <span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>

newstr <span class="token operator">=</span> <span class="token string">''</span>
table <span class="token operator">=</span> <span class="token string">')!@#$%^&amp;*('</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">str</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> i <span class="token keyword">not</span> <span class="token keyword">in</span> table<span class="token punctuation">:</span>
		newstr<span class="token operator">=</span>newstr <span class="token operator">+</span> i
	<span class="token keyword">else</span> 
		newstr<span class="token operator">=</span>newstr<span class="token operator">+</span><span class="token punctuation">(</span>table<span class="token punctuation">.</span>index<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">import</span> base64
<span class="token keyword">print</span><span class="token punctuation">(</span>base<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>newstr<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> </li><li> <p>编码基础|古典密码学：单表代换加密–爆破和词频分析</p> 
  <ol><li>凯撒密码：向前或后移动若干位。特定凯撒密码名–偏移量10 Avocat、偏移量13 ROT13、偏移量-5 Cassis、偏移量-6 Cassette</li><li>摩斯密码：点线</li><li>键盘密码：用手机九宫格或键盘位置加密</li><li>猪圈密码：以格子为基础的替换密码</li><li>培根密码：使用两种不同字体代表AB结合加密表加密</li><li>栅栏密码：要加密明文分成N个一组，然后每组第一个字相连</li><li>曲路密码：明文划分为矩阵</li><li>维吉尼亚密码：使用多表替换，同凯撒，利用<strong>重合性字频分析</strong>爆破</li><li>Polybius、BrainFuck、与佛论禅、社会主义核心价值观编码、Ook！、云影密码(01246)、JsFuck(()[]!+)、圣堂武士密码、夏多密码(曲折加密)、跳舞的小人密码、</li></ol> </li><li> <p>编码基础|仿射密码：一小串字母数字，有2个以上重复字母</p> <p>加密函数：E(x) = (ax + b) (mod m)，其中 a与b互质，m是编码系统中字母的个数（通常都是26）。</p> <p>解密函数：D(x) = a^-1(x-b)(mod m)，a的逆元可以用pow(a,-1,m)求出，</p> </li><li> <p>异或加密|OTP一次性密码本：key长度大于message，一次性key</p> </li><li> <p>现代密码|哈希函数：散列算法，单向性、固定长度、雪崩效应—MD5 16字节</p> <pre><code class="prism language-python">flag <span class="token operator">=</span> <span class="token string">'d0g3{'</span> <span class="token operator">+</span> hashlib<span class="token punctuation">.</span>md5<span class="token punctuation">(</span>SECRET<span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'}'</span>
broken_flag <span class="token operator">=</span> <span class="token string">'d0g3{71b2b5616**2a4639**7d979**de964c}'</span>
<span class="token keyword">assert</span> flag<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token operator">==</span> broken_flag<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">]</span>
<span class="token keyword">assert</span> flag<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">==</span> broken_flag<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">22</span><span class="token punctuation">]</span>
<span class="token keyword">assert</span> flag<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">:</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">==</span> broken_flag<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">:</span><span class="token number">29</span><span class="token punctuation">]</span>
ciphier <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>sha256<span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ciphier<span class="token punctuation">)</span>
<span class="token triple-quoted-string string">'''ciphier = '0596d989a2938e16bcc5d6f89ce709ad9f64d36316ab80408cb6b89b3d7f064a'''</span>

<span class="token operator">//</span>多线程爆破<span class="token builtin">hash</span>串
<span class="token comment">#!/usr/bin/python</span>
<span class="token keyword">from</span> pwn <span class="token keyword">import</span> pwnlib
<span class="token keyword">from</span> pwnlib<span class="token punctuation">.</span>util<span class="token punctuation">.</span>iters <span class="token keyword">import</span> mbruteforce 
<span class="token keyword">import</span> hashlib

<span class="token comment"># flag = 'd0g3{71b2b5616**2a4639**7d979**de964c}'</span>
msgbroken <span class="token operator">=</span> <span class="token string">'d0g3{71b2b5616**2a4639**7d979**de964c}'</span>
table <span class="token operator">=</span> <span class="token string">'0123456789abcdef'</span>
<span class="token keyword">assert</span> <span class="token builtin">len</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token number">16</span>

m1 <span class="token operator">=</span> <span class="token string">'d0g3{71b2b5616'</span> 
m2<span class="token operator">=</span><span class="token string">'2a4639'</span> 
m3<span class="token operator">=</span><span class="token string">'7d979'</span> 
m4<span class="token operator">=</span><span class="token string">'de964c}'</span>

<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">:</span>
	ciphier <span class="token operator">=</span> <span class="token string">'0596d989a2938e16bcc5d6f89ce709ad9f64d36316ab80408cb6b89b3d7f064a'</span>
	msgbroken <span class="token operator">=</span> m1<span class="token operator">+</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>m2<span class="token operator">+</span>res<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">+</span>m3<span class="token operator">+</span>res<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">+</span>m4
	tmp <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>sha256<span class="token punctuation">(</span>msgbroken<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> tmp <span class="token operator">==</span>ciphier<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">True</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> mbruteforce<span class="token punctuation">(</span>f<span class="token punctuation">,</span>table<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token string">'fixed'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>m1<span class="token operator">+</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>m2<span class="token operator">+</span>res<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">+</span>m3<span class="token operator">+</span>res<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">+</span>m4<span class="token punctuation">)</span>
</code></pre> </li><li> <p>现代密码|<strong>steam crypto</strong>：明文与随机数进行位异或得到密文，下面是随机数产生的一些函数</p> <p>Pseudorandom Number Generator PNG，伪随机生成器</p> <pre><code>#Linear Congruential Generator
S0 = seed   Si+1 = ASi + B mod m
class LCG() :
	def __init__(self, seed) :
		self .state = seed
		self.m = 2**32
		self.A = random.getrandbits(32)| 1
		self.B = random.getrandbits(32)| 1
	def getbits(self):
		self .clock()
		return self .state
	def clock(self):
		self.state = (self.A * self.state + self.B) % self.m
#decrypto
S1 = S0A+B %m
S2 = S1A+B %m
A = (S2-S1)//gmpy2.invert(S1-S0,m)%m
B = S0*A+B%m

example：MT19937
</code></pre> <p>LFSR：liner feedback shift register</p> <pre><code>P(x) = x^m + Pm-1 * x^（m-1） + ...+p1x+p0
class LFSR:
	def_init__ (self, key, taps): 
		d = max(taps)
		assert len(key) == d, "Error: key of wrong size."
		self. S = key
		self.t=[d-tfortintaps]
	def sum(self, L) :
		S=0
		forxinL:
		s^=x
		return S
	def_ clock(self):
		b = self._ s[0]
		self. S = self. _s[1:] + [self._ sum(self._ s[p] for p in self._ t)]
		return b
	def getbit(self):
		return self._ clock()
</code></pre> <p>Correlation Attack</p> </li><li> <p>现代密码|<strong>block crypto</strong>：</p> 
  <ol><li> <p><strong>Feistel结构</strong>：加解密相同，仅轮密钥顺序相反输入，round key按轮次与key进行进行function最后得到c m</p> 
    <ol><li>example:DES-》分组长度64bit，密钥长度64位，共16轮迭代</li><li>blowfish</li></ol> </li><li> <p><strong>Substitution-permutation network</strong>:每轮keyn与m做异或后产生多个固定大小s，s输入类似hashtable产出下个m，轮n次后输出c</p> 
    <ol><li> <p>example:AES-&gt;输入输出长度固定，加密<strong>任意长度</strong>明文需要一些<strong>额外加工</strong>(不够就padding)-&gt;加工方式 ECB CBC CFB OFB CTR</p> </li><li> <p>ECB:相同明文出现相同密文（攻击：通过剪切达到改变数据目的）</p> <pre><code>def ecb_encrypto(text):
	return text+flag
#通过类似ascii爆破sql的方法，一个s里面的16个byte，只输入填充flag前15个，即放一位flag进来，此时得到加密后c1，这时候填充16个进去，通过遍历第16个的字符判定相等即可得出flag[0]，如此反复最后得到整段flag
</code></pre> </li><li> <p>CBC：每块密文都依赖前面的明文-&gt;有初始IV，与m异或后得到m0和key进行function_encrypto，得到的作为IV参与下一轮次的m异或（攻击：字节翻转攻击-&gt;通过修改iv和c来控制m）</p> <pre><code>#encrypto
flag="d0g3{1235346547}"
key = "0123456789abcdef"
iv = flag.strip('d0g3{').strip('}')

hint = os.urandom(4) * 8
msg = b'Welcome to this competition, I hope you can have fun today!!!!!!'

def encrypto(message):
    aes = AES.new(key,AES.MODE_CBC,iv)
    return aes.encrypt(message)

#解密aes-CBC
#get key
tmp = 56631233292325412205528754798133970783633216936302049893130220461139160682777
hint = int(str(hex(tmp))[2:10] * 8, 16)
key = long_to_bytes(tmp ^ hint)

#get iv
msg = b'Welcome to this competition, I hope you can have fun today!!!!!!'
msgs = [msg[ii:(ii+16)] for ii in range(0,len(msg),16)]
msgs.reverse()
IV = binascii.unhexlify('3c976c92aff4095a23e885b195077b66')

def decry(key,IV,ms):
	aes = AES.new(key,AES.MODE_ECB)
	return strxor(aes.decrypt(IV),ms)

for ms in msgs:
	IV=decry(key,IV,ms)
print(b'd0g{'+IV+b'}')
</code></pre> </li><li> <p>Padding：PKCS#7–&gt;定义了一种padding方法，要填充n个bytes就填充n个0xn（攻击：padding oracle attack-&gt;因为padding错误oracle会报错）</p> <pre><code>def pad(data):
	p=16-len(data)%16
	return data + bytes([p]) * p
def unpad(data):
	if not all([x == data[-1] for x in data[-data[-1]:]):
		raise Va lueError
	return data[:-data[-1]]

</code></pre> </li><li> <p>CTR：产生个随机数字counter1，按顺序到countern,counter1与key参与func_encry运算得到的结果与m1异或，得到第一段密文m1，这样可以输入m马上得到c</p> </li><li> <p>GCM：</p> </li></ol> </li></ol> </li><li> <p>现代密码|公钥密码：<strong>Factoring Integers大数分解 | Discrete Logrithm 离散对数| Elliptic Curves椭圆曲线</strong></p> </li><li> <p>RSA：最大公约数GCD：</p> </li></ol> 
<pre><code>def gcd(a,b):
 while b:
 	a,b = b, a%b
 	return a
def gcd(a,b):
 if b==0:	return a
 else 
 	a=gcd(b,a%b)
 	return a
def egcd(a,b):
 if b==0:	return (a,1,0)
 else:
 	g,x,y = egcd(b,a%b)
 	return (g,y,x-(a//b)*y)
</code></pre> 
<ol start="11"><li>RSA|<strong>费马小定理</strong> and <strong>中国剩余定理</strong></li></ol> 
<pre><code>a^p = a mod p   推出 a^(q-1) = 1 mod p
由中国剩余定理得到 a^(q-1) = 1 mod p;a^(q-1) = 1 mod q;a^(q-1) = 1 mod n;
c^d = m ^ed = m^kphi+1 =m mod n
</code></pre> 
<ol start="12"><li> <p>RSA|过程分解：密钥生成，公钥加密，私钥解密</p> 
  <ol><li> <p>密钥生成：选大质数p、q， N=p*q，再选一个符合欧拉函数n的e，这样e必有倒数e<sup>-1，可得私钥d=e</sup>-1 mod(p-1)(q-1)，公钥=(N,e)，e大加密慢，e小不安全</p> </li><li> <p>公钥加密：明文m，计算密文C=m^e(mod N)</p> </li><li> <p>私钥解密：密文C，计算明文m=C^d(mod N)</p> </li></ol> </li><li> <p>RSA|基于N分解的RSA几种情况</p> 
  <ol><li>在线查询分解网站 http://www.factordb.com/index.php</li><li>使用yafu分解</li><li>使用费马或pollard泊拉分解</li><li>p q相差过小：题目给p=nextprinme(q)，说明pq特别接近，等价n=p^2，所以对n开方直接得pq之间值t，进而求nextprime(t)可得p</li><li>模n有公约数：利用gcd求</li></ol> </li><li> <p>RSA|<strong>共模攻击</strong>：<strong>相同模数n加密，两个密文c</strong> 原理：a * e1+b * e2 = 1,有n,e1,c1,e2,c2,求e1 e2的逆元和公因子</p> </li><li> <p>RSA|<strong>维纳攻击</strong>：<strong>e指数特别大</strong>，d作为倒数特别小，有<strong>n,e,c</strong>, phi = (p-1)*(q-1) = pq - (p+q)+1 = n-(pq)+1 =&gt; p+q = n-phi+1，连分子计算</p> </li><li> <p>RSA|低加密指数攻击(<strong>小明文攻击</strong>):e一般是65525，当<strong>e=3</strong>时，可直接破解</p> <pre><code>如果e=3，且m^e&lt;n，c开3次根式，得到m。

如果e=3，且m^e&gt;n，那么设k，有：
 c= m^e +kn
 
爆破k，如果c−kn能开三次根式，得到m.
</code></pre> </li><li> <p>RSA|<strong>低加密广播攻击</strong>：如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。<strong>n、c不同，明文m，e相同，其e比较小</strong>。爆破e后求根，使用中国剩余定理求解</p> </li><li> <p>RSA|<strong>共享素数</strong>：两个n里使用有相同的素数p或q。在CTF中，同样一个e（一般为65537）和m， <strong>有两个或多个n和c时</strong>，那么n之间可能是共享素数</p> </li><li> <p>RSA|dp泄露：dp=d%(p-1)，<strong>有n,e,dp,c</strong></p> </li><li> <p>RSA|dp dq：dp=d%(p-1) dq=d%(q-1)，<strong>有p,q,c,dp,dq</strong></p> </li><li> <p>RSA|n是p的r次方：n=p^r，<strong>有q,n,e,c</strong></p> </li><li> <p>RSA|N分解三个素数：n分解出三个素数</p> </li><li> <p>RSA|e和phi_n不互素：不互素就没倒数d，需要e除两者最大公约数再互素</p> </li><li> <p>RSA|选择密文攻击：</p> </li><li> <p>现代密码|<strong>离散对数</strong>：<strong>Diffle-Hellman</strong>密钥协商协议，约定大质数p、模p下的生成元g(p,g必互素)</p> 
  <ol><li>A选a，计算A=g^a(mod p) -&gt; B</li><li>B选b，计算B=g^b(mod p) -&gt; A</li><li>KEY=B<sup>a=A</sup>b=g^ab(mod p)</li></ol> </li><li> <p>现代密码|离散对数：<strong>ElGamal Encryption Scheme</strong></p> 
  <ol><li>alice在范围2:p-2范围选d, 计算b=a^d，发送(p, a, b)给bob；</li><li>bob在范围2:p-2范围选i，计算ephemeral key为Ke=a^i, 计算masking key为Km=b^i, 密文c=m*Km mod p，发送(c, Ke)给alice</li><li>alice收到后计算masking key Km=Ke^d, 解密出密文m=c*Km^-1 mod p</li></ol> </li><li> <p>现代密码|离散对数：<strong>DLP</strong> 群</p> </li><li> <p>现代密码|<strong>椭圆曲线</strong>：三个问题：密钥交换、数字签名、离散对数</p> 
  <ol><li>定义：y^2 = x^3 + ax + b mod p，有限域上的计算，零元是O， 4a^3 +27b^2 !=0 mod p ；p不能等于E</li><li><strong>ECDLP</strong>困难问题：P+P+…+P=dP=Q , 给P Q，计算d很困难，但是dP很简单</li><li>point addition点加法：沿曲线的P+Q两点画线，继续这条线直到第三次相交曲线，最后在第三点(x,y)沿y取反，即(x,-y)，一个点的话就是切线找第二个点</li><li><strong>点的阶</strong>：对于ecc上一点P，若存在一个最小的正整数n，使nP=0，则称n是P的阶</li><li><strong>椭圆曲线的阶</strong>：有限域上ecc由有限点组成，多少点ecc就是多少阶</li><li>估计曲线上点数：p+1-2根p &lt;=#E &lt;=p+1+2根p ，点数靠近素数p</li><li><strong>ECDH</strong>：Elliptic Curve Diffie-Hellman Key Exhange椭圆曲线Dh秘钥交换 
    <ol><li>用素数p生成椭圆曲线E和点P=(xp-yp)</li><li>Alice和bob选择随机私钥keya=1:#E-1, 交换A=keya*P和B=keyb*P ，即使被截取，也无法通过A B计算出两者的key</li><li>Alice和Bob的公钥为K=aB=a(keyb*P)=bA=b(keya*P)</li><li>还原方法：Pohlig-Hellman</li><li></ol> </li></ol> </li></ol> 
<h3><a id="_338"></a>总结</h3> 
<table><thead><tr><th align="center">攻击</th><th align="center">需求</th><th align="center">使用</th></tr></thead><tbody><tr><td align="center">共模攻击</td><td align="center">1n(同), 2e, 2c</td><td align="center">同n，求e1 e2的逆元和公因子</td></tr><tr><td align="center">广播攻击</td><td align="center">多n, 1e, 多c</td><td align="center">共享素数，即中国剩余定理,gcd(n1,n2)出p，分别求q1q2</td></tr><tr><td align="center">维纳攻击</td><td align="center">n, e(大), c</td><td align="center">e很大，d很小，e/n近似k/d，连分子计算</td></tr><tr><td align="center">小e攻击</td><td align="center">n, e(小), c</td><td align="center">小明文攻击，通过m^e%n反向得出当e小时，可通过c开根爆破出m</td></tr><tr><td align="center">模(n)不互素</td><td align="center">2n, 1e, 2c</td><td align="center">gcd(n1,n2)出p</td></tr><tr><td align="center">NC不互素</td><td align="center">n, e, c</td><td align="center">gcd(n,c)出p</td></tr><tr><td align="center">仅dp泄露</td><td align="center">n, e, c, dp</td><td align="center">dp放d位置，计算后删掉dp，重新计算出d填入</td></tr><tr><td align="center">dp dq泄露</td><td align="center">p, q, c, d, dp, dq</td><td align="center">dp dq放入d位置计算，计算n后选e del_f不互素</td></tr><tr><td align="center">e del_f</td><td align="center">p, q, e, c</td><td align="center"></td></tr><tr><td align="center">rabin算法</td><td align="center">p, q, n, c, e</td><td align="center"></td></tr><tr><td align="center">n是p的r次方</td><td align="center">n, e, c</td><td align="center">p位置重复r次填</td></tr></tbody></table> 
<h3><a id="example_360"></a>example</h3> 
<p>nc不互素：指n与c有最大公约数，这个公约数是与p相关数，通过p可求出q，最后通过题目给出算式得出m</p> 
<pre><code class="prism language-python"><span class="token comment">#M = 2021 *m*1001*p  </span>
<span class="token comment">#c = pow(M,e,n) //题目给条件，给c n e</span>
<span class="token comment">#推理：c = M^e%n = M^e+kn = (2021 *m*1001*p)^e + k*p*q</span>
<span class="token comment">#两边同时mod p , c%p = (2021 *m*1001*p)^e%p + k*p*q%p</span>
<span class="token comment"># c % p = 0，所以c=kp，n=qp，c与n存在公因数</span>
<span class="token keyword">import</span> gmpy2
<span class="token keyword">import</span> libnum
n<span class="token operator">=</span> c<span class="token operator">=</span> e<span class="token operator">=</span> <span class="token number">65537</span>

p <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>n<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token operator">//</span>求最大公因数
q <span class="token operator">=</span> n<span class="token operator">//</span>p
phi_n <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  
d <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>e<span class="token punctuation">,</span>phi_n<span class="token punctuation">)</span>
M <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>n<span class="token punctuation">)</span>
m <span class="token operator">=</span> M<span class="token operator">//</span><span class="token punctuation">(</span><span class="token number">2021</span><span class="token operator">*</span><span class="token number">1001</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token comment">#需要除掉无关数得到真正的密文m</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>libnum<span class="token punctuation">.</span>n2s<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">#2 题目给c=pow(m*p+n,e,n)，同上步骤</span>
<span class="token comment">#(m*p+n)^e%n=c，两边mod p，c=kp,n c存在公约数，求解出m1，此时m1=m*p+n,因为n=kp,与前面合并即m1=m*p</span>
<span class="token comment">#m = m1//p</span>
</code></pre> 
<p>pq的逆元：不给q,p，但是给出p,q的逆元，可以通过推理公式，最后计算长度得知k值，使用脚本联立方程跑出p q</p> 
<pre><code class="prism language-python"><span class="token comment">#p = libnum.generate_prime(512)</span>
<span class="token comment">#q = libnum.generate_prime(512)</span>
<span class="token comment">#p1 = gmpy2.invert(p,q)</span>
<span class="token comment">#q1 = gmpy2.invert(q,p)</span>
<span class="token comment">#c = pow(m,e,n) 题目给p1,q1,phi_n,e,c</span>
<span class="token comment">#推理：</span>
<span class="token comment">#p1*p%q=1	p1*p-1=k1q	 </span>
<span class="token comment">#q1*q%p=1	q1*q-1=k2p</span>
<span class="token comment">#上下两方程相乘 (p1*p-1)*(q1*q-1)=kpq </span>
<span class="token comment">#				p1*q1*n+1-p1p-q1q=kn</span>
<span class="token comment">#					p1p+q1q-1=kn ，此时由于给出pq长度，pq=n，所以n长度不超过1024，推出k=1</span>
<span class="token comment">#联立phi=(q-1)*(p-1)，p1p+q1q-1=n，可得pq</span>

<span class="token comment">#解题</span>
<span class="token keyword">import</span> gmpy2
<span class="token keyword">import</span> libnum
<span class="token keyword">from</span> z3 <span class="token keyword">import</span> <span class="token operator">*</span>
e<span class="token operator">=</span> <span class="token number">65537</span> phi<span class="token operator">=</span>  c<span class="token operator">=</span>  p1<span class="token operator">=</span> q1<span class="token operator">=</span> 

s <span class="token operator">=</span> Solver<span class="token punctuation">(</span><span class="token punctuation">)</span>
p<span class="token operator">=</span>Int<span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span>
q<span class="token operator">=</span>Int<span class="token punctuation">(</span><span class="token string">"q"</span><span class="token punctuation">)</span>
s<span class="token punctuation">.</span>add<span class="token punctuation">(</span>phi<span class="token operator">==</span><span class="token punctuation">(</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">#联立方程组</span>
s<span class="token punctuation">.</span>add<span class="token punctuation">(</span>p1<span class="token operator">*</span>p<span class="token operator">+</span>q1<span class="token operator">*</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token operator">==</span>p<span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token keyword">if</span> s<span class="token punctuation">.</span>check<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>sat<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>model<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> 
q <span class="token operator">=</span> 
n <span class="token operator">=</span> q<span class="token operator">*</span>p
d <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>e<span class="token punctuation">,</span> phi<span class="token punctuation">)</span>
m <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token builtin">int</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">int</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>libnum<span class="token punctuation">.</span>n2s<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>费马小定理运用：a^p=a mod p</p> 
<pre><code>#hint = pow(2020*p+2021, q, n)   题目给出n c hint 
#推理：h=(2020*p+2021)^q%n=(2020*p+2021)^q+kn=k1p^q+2021^q+k2n
#两边mod p	h%p=2021^q%p
#				2021^q%p-h=kp(p与n有倍数关系，即n与2021^p-h存在公约数，可以用gcd，但q不知道，需要替换)
#由费马小定理，a^p=a mod p 得，(2021^q)^p%p-h=kp 可推2021^q%p-h=kp，所以可证2021^n%p=2021^q%p
#最后得2021^n%p-h=kp，n与2021^n-h存在公因数，用gcd求解出p

import libnum
import gmpy2
n=
c=
hint=
e = 65537

p = gmpy2.gcd(pow(2021,n,n)-hint,n)  
#原本是gcd(2021^n-hint,n)，但是太大无法计算，等化为2021^n%n，即pow(2021,n,n)
q = n//p
print(q,p)
phi = (p-1)*(q-1)
d = gmpy2.invert(e, phi)
m = pow(c,d,n)
print(libnum.n2s(int(m)))
</code></pre> 
<p>pq在两条不同公式，通过消去得到n替代</p> 
<pre><code># h1=pow(2022*p+2021*q,1919,n)
# h2=pow(2021*p+2022*q,9191,n)  题目给出条件，p q在通过h1 h2给出
# c=pow(m, e ,n)
h1= h2= n= c= e=65537
#推理
# h1 = 2022*p+2021*q ^ 1919 %n
# h2 = 2021*p+2022*q ^ 9191 %n
#两边同乘，直到右边相等，相减消去
# h1^9191*2021^(9191*1919)%q = 2022^(9191*1919)*p^(1919*9191)*2021^(9191*1919)
# h2^1919*2022^(9191*1919)%q = 2021^(9191*1919)*p^(9191*1919)*2022^(9191*1919)

# h2^1919*2022^(9191*1919)-h1^9191*2021^(9191*1919)
#存在公约数
# h2^1919 *p^ 9191*1919-h1^9191 =kn
#数字太大，需要通过pow减小
h3 = pow(h2,1919,n)*pow(2022,9191*1919,n)-pow(h1,9191,n)*pow(2021,9191*1919,n)
p = gmpy2.gcd(h3,n)
q = n//p
phi = (p-1)*(q-1)
d = gmpy2.invert(e,phi)
m = pow(c,d,n)
print(libnum.n2s(int(m)))
</code></pre> 
<p>二项式：(n+1)^p = (kpn+1)</p> 
<pre><code class="prism language-python"><span class="token comment"># g=n+1</span>
<span class="token comment"># c= (pow(g,p,n*n) *pow (m,n,n*n))%(n*n)</span>
<span class="token comment"># print("c="+str(c))</span>
<span class="token comment"># print("n="+str(n))</span>
<span class="token comment"># print("hint="+str(pow(m,n,n*n)))  题目给出条件</span>
<span class="token comment">#推理：c = [(g^p)%n*n * (m^n)%n*n]%(n*n) = (g^p * m^n)%(n*n) =(n+1)^p%(n*n)*hint</span>
<span class="token comment">#		c + knn = (kpn+1)*hint = kpn*hint+hint </span>
<span class="token comment">#		c-hint = kpn*hint + knn</span>
<span class="token comment">#		(c-hint) // n = kp*hint + kn</span>
<span class="token comment">#两边同时mod p, (c-hint) // n =kp ,[(c-hint)//n]与n存在公约数</span>

p <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">-</span>hint<span class="token punctuation">)</span><span class="token operator">//</span>n<span class="token punctuation">,</span>n<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
q <span class="token operator">=</span> n<span class="token operator">//</span>p
phi <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
d <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>n<span class="token punctuation">,</span>phi<span class="token punctuation">)</span>
m <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>n<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>libnum<span class="token punctuation">.</span>n2s<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>pq接近但无c：通过c的其他表达替换解出c，pq接近证明可用yafu分解</p> 
<pre><code class="prism language-python"><span class="token comment">#给e n  c1  c2</span>
<span class="token comment">#解析：n扔yafu解出p q， c1=c+kp c2=c+kq </span>
<span class="token comment"># c1=c2+kp+kq  (c1-c2)%q=kp  两边同除p，即pq逆元p1，(c1-c2)*p1%q = k</span>
<span class="token comment">#即c = c1-(c1-c2)*p1%q</span>
p1 <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>
d <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>e<span class="token punctuation">,</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
m <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>c1<span class="token operator">-</span><span class="token punctuation">(</span>c1<span class="token operator">-</span>c2<span class="token punctuation">)</span><span class="token operator">*</span>p1<span class="token operator">%</span>q<span class="token punctuation">,</span> d<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>libnum<span class="token punctuation">.</span>n2s<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>共享素数（广播攻击）：同素数，直接gcd(n1,n2)，p是共同的素数，后面就按照题目逻辑继续</p> 
<pre><code class="prism language-python">e <span class="token operator">=</span> n1 <span class="token operator">=</span> c1 <span class="token operator">=</span> n2 <span class="token operator">=</span> c2 <span class="token operator">=</span> 
q <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>n1<span class="token punctuation">,</span>n2<span class="token punctuation">)</span>
p <span class="token operator">=</span> n1<span class="token operator">//</span>q
d <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>e<span class="token punctuation">,</span><span class="token punctuation">(</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
m <span class="token operator">=</span> libnum<span class="token punctuation">.</span>n2s<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">pow</span><span class="token punctuation">(</span>c1<span class="token punctuation">,</span>d<span class="token punctuation">,</span>n1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
</code></pre> 
<p>小明文攻击（e很小）：题目只给c n，通过m^e%n反向得出当e小时，可通过c开根爆破出m</p> 
<pre><code class="prism language-python">题目只给了出
e<span class="token operator">=</span><span class="token number">2</span>  c<span class="token operator">=</span> n<span class="token operator">=</span> 
<span class="token keyword">import</span> libnum
<span class="token keyword">import</span> gmpy2
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> i <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">continue</span>
    <span class="token keyword">if</span> gmpy2<span class="token punctuation">.</span>iroot<span class="token punctuation">(</span>c<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">True</span><span class="token punctuation">:</span>  <span class="token comment">#开根</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>gmpy2<span class="token punctuation">.</span>iroot<span class="token punctuation">(</span>c<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment"># print(libnum.n2s(int(29305044677847256883031643626546437461373017758852477))) #明文转字符</span>
</code></pre> 
<p>共模攻击：n相同，求e1 e2逆元再用公因子求根</p> 
<pre><code class="prism language-python"><span class="token comment">#e1e2 = 3087   flag1 = pow(m1,e1,n)  flag2 = pow(m1,e2,n)</span>
<span class="token comment">#推理：给了e1*e2，和c1 c2，爆破拆散e1e2组合，然后分别放入等式</span>
<span class="token comment">#c1 = m1^e1%n ,c2 = m1^e2%n ，两边同时开方e1 e2的逆元k1 k2，让右边等于m1</span>
<span class="token comment">#c1^k1%n= m1,c2^k2%n=m1，等式相乘后对结果用公因子求根，m = gmpy2.iroot(m0,k)[0]</span>

<span class="token keyword">import</span> libnum
<span class="token keyword">import</span> gmpy2

flag1<span class="token operator">=</span>  flag2<span class="token operator">=</span>  n<span class="token operator">=</span>  e1e2<span class="token operator">=</span><span class="token number">3087</span>
<span class="token keyword">for</span> e1 <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> e1e2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> e1e2 <span class="token operator">%</span> e1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        e2 <span class="token operator">=</span> e1e2 <span class="token operator">//</span> e1
        k <span class="token punctuation">,</span>k1<span class="token punctuation">,</span>k2<span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>gcdext<span class="token punctuation">(</span>e1<span class="token punctuation">,</span>e2<span class="token punctuation">)</span> <span class="token comment">#k1 k2此时是逆元，即求d</span>
        m0 <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>flag1<span class="token punctuation">,</span>k1<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token operator">*</span><span class="token builtin">pow</span><span class="token punctuation">(</span>flag2<span class="token punctuation">,</span>k2<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token operator">%</span>n   
        m <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>iroot<span class="token punctuation">(</span>m0<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>libnum<span class="token punctuation">.</span>n2s<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>相邻素数：有next_prime必能分解，分解出pq观察代码，c1 c2有两条公式组成，上z3，出原文</p> 
<pre><code>p = sympy.nextprime(secret_num)
q = sympy.nextprime(p)
n=pq
c1 = F1 + F2
c2 = pow(F1, 3) + pow(F2, 3)
assert(c2 &lt; N)
m1 = pow(c1, e, N)
m2 = pow(c2, e, N)
#提供n，e，m1，m2
#解题
s = Solver()
f1=Int("f1")
f2=Int("f2")
s.add((f1+f2)==int(c1))
s.add((f1**3)+(f2**3)==int(c2))
if s.check()==sat:
    print(s.model())
</code></pre> 
<p>n分解出3个素数：有多余的，需要n后面除掉</p> 
<pre><code class="prism language-python"><span class="token comment">#初始化n和phi。遍历3素数，查看e与哪个互素，是就乘进去n和phi，然后正常流程</span>
<span class="token keyword">import</span> libnum
<span class="token keyword">import</span> gmpy2
<span class="token keyword">from</span> z3 <span class="token keyword">import</span> <span class="token operator">*</span>
n <span class="token operator">=</span> <span class="token number">3454083680130687060405946528826790951695785465926614724373</span>
e <span class="token operator">=</span> <span class="token number">3</span>
c <span class="token operator">=</span> <span class="token number">1347530713288996422676156069761604101177635382955634367208</span>

p<span class="token operator">=</span><span class="token number">11761833764528579549</span>
q<span class="token operator">=</span><span class="token number">17100682436035561357</span>
r3<span class="token operator">=</span><span class="token number">17172929050033177661</span>
n<span class="token punctuation">,</span> phi <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>  <span class="token comment">#初始化n phi，也可以除掉不互素的</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span>p<span class="token punctuation">,</span>q<span class="token punctuation">,</span>r3<span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> gmpy2<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>e<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
        phi <span class="token operator">*=</span> i <span class="token operator">-</span> <span class="token number">1</span>
        n <span class="token operator">*=</span> i
<span class="token comment">#或  phi = (p-1)*(r3-1)          n=n//q</span>
d <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>e<span class="token punctuation">,</span> phi<span class="token punctuation">)</span>
flag <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>libnum<span class="token punctuation">.</span>n2s<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>爆破公式和e</p> 
<pre><code class="prism language-python"><span class="token comment"># A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x</span>
<span class="token comment"># p=next_prime(z*x*y)</span>
<span class="token comment"># q=next_prime(z)   题目条件，给出n A c</span>
<span class="token comment">#解析：没有pq，试试扔工具拆分，不行就用A等式爆破x y，爆破后n=z^2*x*y，n开方后即得到z，在附近找素数</span>
<span class="token comment">#题目给的n可以拆分，所以直接出pq，然后爆破e</span>
<span class="token comment"># print(p//q)</span>
<span class="token comment"># for x in range(1,1000):</span>
<span class="token comment">#     for y in range(1,1000):</span>
<span class="token comment">#         try:</span>
<span class="token comment">#             if ((((y%x)**5)%(x%y))**2019+y**316+(y+1)//x==A):</span>
<span class="token comment">#                 print(x,y)</span>
<span class="token comment">#         except:</span>
<span class="token comment">#             continue</span>
x <span class="token operator">=</span> <span class="token number">2</span>   y <span class="token operator">=</span> <span class="token number">83</span>
<span class="token keyword">for</span> e <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> gmpy2<span class="token punctuation">.</span>is_prime<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">==</span><span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            d <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            flag <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>n<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token string">b'CTF{'</span> <span class="token keyword">in</span> libnum<span class="token punctuation">.</span>n2s<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span>libnum<span class="token punctuation">.</span>n2s<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span><span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
</code></pre> 
<p>p高位泄露：有p&gt;&gt;200，只剩高位</p> 
<pre><code>p3 = getPrime(512)
q3 = getPrime(512)
N3 = p3*q3
给e n3 p3&gt;&gt;200  c

#解析，上sage，打开sage notebook
from sage.all import *
c3 = n3 = p3_200 =

pbits = 512
kbits = pbits - p3_200.nbits()
p3 = p3_200 &lt;&lt; 200
print(p3.nbits())

PR.&lt;x&gt; = PolynomialRing(Zmod(n3))       # 构建多项式环
f = x + p3      # 定义函数
roots = f.small_roots(X = 2^kbits,beta = 0.4)       #直接解出低位
if roots:
    print(roots[0])
    p = p3 + int(roots[0])
    print("n3: "+str(n3))
    print("p: "+str(p))
    print("q: "+str(n3//p))
</code></pre> 
<p>密钥加密及打开</p> 
<pre><code>import libnum
import gmpy2
from z3 import *
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
import base64
from Crypto.Cipher import PKCS1_OAEP

p=
q=

with open("public.key","rb") as f:
    key = RSA.import_key(f.read())
    n=key.n
    e=key.e
    print(n,e)
with open("flag.enc","rb") as f:
    c=f.read()
    c=base64.b64decode(c)
    c=libnum.s2n(c)
    print(c)

d = gmpy2.invert(e, (p-1)*(q-1))
# flag = pow(c1, d, n2)
rsa_components = (n, e, int(d), p, q)
arsa = RSA.construct(rsa_components)
rsakey = RSA.importKey(arsa.exportKey())
rsakey = PKCS1_OAEP.new(rsakey)
decrypted = rsakey.decrypt(libnum.n2s(c))
print(decrypted)
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1e5902bc5af8b0d0ef56246aac7ba23/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Chrome浏览器使用AdGuard去除百度热搜</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f39b92c41710f33bbd48f2cd7fd678ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用POI实现EXcel表格的读写</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>