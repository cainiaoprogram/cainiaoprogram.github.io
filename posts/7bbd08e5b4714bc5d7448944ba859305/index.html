<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>rabbitMQ高级 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="rabbitMQ高级" />
<meta property="og:description" content="目录
消息可靠性
消息可靠性 -- 生产者确认
消息可靠性 -- 消息持久化
消息可靠性 -- 消费者确认
消息可靠性 -- 消费者失败重试机制
消息可靠性 -- 实现总结
死信交换机
死信交换机 -- 实现消息延迟推送
死信交换机 -- 延迟队列插件 -- DelayExchange
消息堆积 -- 惰性队列
MQ集群分类
MQ集群 -- 普通集群
MQ集群 -- 镜像集群
MQ集群 -- 仲裁集群
消息可靠性 在消息的推送,路由和接收处理中,都有可能遇到消息的丢失,常见的丢失原因可以分为三类:
发送时丢失： 生产者发送的消息未送达exchange 消息到达exchange后未到达queue
MQ宕机，queue中的消息丢失
consumer接收到消息后未消费就宕机
针对这三类情况,MQ提供了四种解决方案:
生产者确认机制
消息持久化
消费者确认机制
失败重试机制
消息可靠性 -- 生产者确认 RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。
返回结果有两种方式：
publisher-confirm，发送者确认
消息成功投递到交换机，返回ack
消息未投递到交换机，返回nack
publisher-return，发送者回执
消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。
发送消息的时候需要给消息提供一个唯一ID,结果返回的时候可以绑定ack/nack, 用来区分不同的消息,避免ack碰撞
配置生产者确认模式:
修改publisher服务中的application.yml文件:
spring: rabbitmq: publisher-confirm-type: correlated publisher-returns: true template: mandatory: true publish-confirm-type：开启publisher-confirm，这里支持两种类型：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7bbd08e5b4714bc5d7448944ba859305/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-05T18:45:34+08:00" />
<meta property="article:modified_time" content="2022-03-05T18:45:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">rabbitMQ高级</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow">消息可靠性</a></p> 
<p id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4" rel="nofollow">消息可靠性 -- 生产者确认</a></p> 
<p id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96" rel="nofollow">消息可靠性 -- 消息持久化</a></p> 
<p id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4" rel="nofollow">消息可靠性 -- 消费者确认</a></p> 
<p id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6" rel="nofollow">消息可靠性 -- 消费者失败重试机制</a></p> 
<p id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93" rel="nofollow">消息可靠性 -- 实现总结</a></p> 
<p id="%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA-toc" style="margin-left:80px;"><a href="#%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA" rel="nofollow">死信交换机</a></p> 
<p id="%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%20--%20%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%BB%B6%E8%BF%9F%E6%8E%A8%E9%80%81-toc" style="margin-left:80px;"><a href="#%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%20--%20%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%BB%B6%E8%BF%9F%E6%8E%A8%E9%80%81" rel="nofollow">死信交换机 -- 实现消息延迟推送</a></p> 
<p id="%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%20--%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6%20--%C2%A0DelayExchange-toc" style="margin-left:80px;"><a href="#%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%20--%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6%20--%C2%A0DelayExchange" rel="nofollow">死信交换机 -- 延迟队列插件 -- DelayExchange</a></p> 
<p id="%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%20--%20%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%20--%20%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97" rel="nofollow">消息堆积 -- 惰性队列</a></p> 
<p id="MQ%E9%9B%86%E7%BE%A4%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#MQ%E9%9B%86%E7%BE%A4%E5%88%86%E7%B1%BB" rel="nofollow">MQ集群分类</a></p> 
<p id="MQ%E9%9B%86%E7%BE%A4%20--%20%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4-toc" style="margin-left:80px;"><a href="#MQ%E9%9B%86%E7%BE%A4%20--%20%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4" rel="nofollow">MQ集群 -- 普通集群</a></p> 
<p id="MQ%E9%9B%86%E7%BE%A4%20--%20%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4-toc" style="margin-left:80px;"><a href="#MQ%E9%9B%86%E7%BE%A4%20--%20%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4" rel="nofollow">MQ集群 -- 镜像集群</a></p> 
<p id="MQ%E9%9B%86%E7%BE%A4%20--%20%E4%BB%B2%E8%A3%81%E9%9B%86%E7%BE%A4-toc" style="margin-left:80px;"><a href="#MQ%E9%9B%86%E7%BE%A4%20--%20%E4%BB%B2%E8%A3%81%E9%9B%86%E7%BE%A4" rel="nofollow">MQ集群 -- 仲裁集群</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">消息可靠性</h4> 
<blockquote> 
 <p><img alt="" height="345" src="https://images2.imgbox.com/5c/59/eW4uFMvo_o.png" width="1178"></p> 
 <p> 在消息的推送,路由和接收处理中,都有可能遇到消息的丢失,常见的丢失原因可以分为<strong>三类:</strong></p> 
 <p>        <strong>发送时丢失</strong>： 生产者发送的消息未送达exchange 消息到达exchange后未到达queue</p> 
 <p>        <strong>MQ宕机</strong>，queue中的消息丢失</p> 
 <p>        <strong>consumer</strong>接收到消息后未消费就宕机</p> 
 <p>针对这三类情况,MQ提供了四种解决方案:</p> 
 <p>        <strong>生产者确认机制</strong></p> 
 <p><strong>        消息持久化</strong></p> 
 <p><strong>        消费者确认机制</strong></p> 
 <p><strong>        失败重试机制</strong></p> 
</blockquote> 
<h4 id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4">消息可靠性 -- 生产者确认</h4> 
<blockquote> 
 <p>RabbitMQ提供了<span style="color:#4da8ee;"><strong>publisher confirm机制</strong></span>来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。</p> 
 <p>返回结果有两种方式：</p> 
 <p>        <strong>publisher-confirm，发送者确认</strong></p> 
 <p>                消息成功投递到交换机，返回ack</p> 
 <p>                消息未投递到交换机，返回nack</p> 
 <p>        <strong>publisher-return，发送者回执</strong></p> 
 <p>                消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。</p> 
 <p><strong>发送消息的时候需要给消息提供一个唯一ID,结果返回的时候可以绑定ack/nack, 用来区分不同的消息,避免ack碰撞</strong></p> 
 <hr> 
 <p><strong>配置生产者确认模式:</strong></p> 
 <p><strong>        </strong>修改publisher服务中的application.yml文件:</p> 
 <pre><code class="language-XML">spring:
  rabbitmq:
    publisher-confirm-type: correlated
    publisher-returns: true
    template:
      mandatory: true</code></pre> 
 <p><strong>publish-confirm-type</strong>：开启publisher-confirm，这里支持两种类型：</p> 
 <p>        <strong>simple</strong>：同步等待confirm结果，直到超时</p> 
 <p>        <strong>correlated</strong>：异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback</p> 
 <p><strong>publish-returns</strong>：开启publish-return功能，同样是基于callback机制，不过需要的定义ReturnCallback</p> 
 <p><strong>template.mandatory</strong>：定义消息路由失败时的策略。<strong>true</strong>，则调用ReturnCallback；<strong>false</strong>：则直接丢弃消息</p> 
 <hr> 
 <p><strong>定义publish-returns的回调</strong>ReturnCallback:</p> 
 <p>        在spring中RabbitTemplate只能配置一个ReturnCallback,所以我们需要在启动时配置</p> 
 <pre><code class="language-java">@Slf4j
@Configuration
//继承ApplicationContextAware,spring的bean容器通知接口
public class CommonConfig implements ApplicationContextAware {

    //重写设置容器方法
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        // 从bean容器中获取RabbitTemplate这个bean
        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);
        // 通过lambda表达式设置ReturnCallback回调函数
        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; {
            // 投递失败，记录日志
            log.info("消息发送失败，应答码{}，原因{}，交换机{}，路由键{},消息{}",
                     replyCode, replyText, exchange, routingKey, message.toString());
            // 如果有业务需要，可以重发消息
        });
    }
}</code></pre> 
 <hr> 
 <p> <strong>定义publisher-confirm的correlated类型回调ConfirmCallback</strong>:</p> 
 <pre><code class="language-java">//模拟发送消息
public void testSendMessage2SimpleQueue() throws InterruptedException {
    //构造消息体
    String message = "hello, spring amqp!";
    //因为Correlated类型的回调
    //所以需要创建CorrelationData对象   
    //需要封装两个属性 1:消息唯一id  2:回调函数              这里封装消息唯一ID
    CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
    //封装callback回调
    correlationData.getFuture().addCallback(
        result -&gt; {
            //调用函数判断MQ返回结果
            if(result.isAck()){
                //ack，消息成功
                log.debug("消息发送成功, ID:{}", correlationData.getId());
            }else{
                //nack，消息失败
                log.error("消息发送失败, ID:{}, 原因{}",correlationData.getId(), result.getReason());
            }
        },
        ex -&gt; log.error("消息发送异常, ID:{}, 原因{}",correlationData.getId(),ex.getMessage())
    );
    //发送消息,参数: 交换机 routingKey  correlationData对象
    rabbitTemplate.convertAndSend("task.direct", "task", message, correlationData);

    // 休眠一会儿，等待ack回执
    Thread.sleep(2000);
}</code></pre> 
</blockquote> 
<h4 id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96">消息可靠性 -- 消息持久化</h4> 
<blockquote> 
 <p>生产者确认机制可以保证将消息推送到队列中,但是如果MQ宕机,还是会出现消息丢失问题,我们可以使用消息持久化机制解决这个问题</p> 
 <p>而消息持久化分为三个阶段:</p> 
 <p>        <strong>交换机持久化</strong></p> 
 <p>        <strong>队列持久化</strong></p> 
 <p>        <strong>消息持久化</strong></p> 
 <p><span style="color:#4da8ee;"><strong>而spring中,默认是全部实现持久化的</strong></span></p> 
 <p>不过我们也可以手动设置,或者取消,因为持久化是写入到本地中的,会有额外的磁盘IO,所以我们可以根据实际情况,将一些低价值的数据取消持久化,实现和取消持久化,只需要设置direct 类型即可,true为开启持久化, false为取消持久化</p> 
 <hr> 
 <p><strong>交换机设置</strong></p> 
 <pre><code class="language-java">@Bean
public DirectExchange simpleExchange(){
    // 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除
    return new DirectExchange("simple.direct", true, false);
}</code></pre> 
 <hr> 
 <p><strong>队列设置</strong></p> 
 <pre><code class="language-java">@Bean
public Queue simpleQueue(){
    // 使用QueueBuilder构建队列，durable就是持久化的
    return QueueBuilder.durable("simple.queue").build();
}</code></pre> 
 <hr> 
 <p><strong>消息设置</strong></p> 
 <p><img alt="" height="479" src="https://images2.imgbox.com/4e/bb/qteRRoxn_o.png" width="1197"></p> 
</blockquote> 
<h4 id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4">消息可靠性 -- 消费者确认</h4> 
<blockquote> 
 <p>值得注意的是RabbitMQ是"阅后即焚"模式的,即消费者确认接收到消息后,MQ就会将消息删除,那如果此时消费者宕机,消息就会丢失,所以针对消费者确认机制,MQ提供了三种策略:</p> 
 <p>        <strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p> 
 <p>        <strong>auto</strong>：自动ack，由spring运用AOP机制监测代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p> 
 <p>        <strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p> 
 <p><span style="color:#4da8ee;"><strong>一般情况下,我们使用auto就能满足需求</strong></span></p> 
 <hr> 
 <p><strong>auto模式开启:</strong></p> 
 <p>        修改消费者的application.yml配置文件</p> 
 <pre><code>spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: auto # 开启spring管理</code></pre> 
 <p><strong>none模式开启:</strong></p> 
 <pre><code>spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: none # 关闭ack</code></pre> 
</blockquote> 
<h4 id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6">消息可靠性 -- 消费者失败重试机制</h4> 
<blockquote> 
 <p>当消费者出现异常后,消息会<span style="color:#4da8ee;"><strong>requeue</strong></span>(重入队)到消息队列中,进行失败重试,但如果消费者依旧是不可用状态,name消息就会一直requeue,导致MQ消息负载,而spring为我们提供了<span style="color:#4da8ee;"><strong>retry机制</strong></span>(本地重试机制)</p> 
 <p><strong>retry机制:</strong></p> 
 <p>        当消息异常后,会在本地按照我们的自定义策略进行重试,这样可以避免MQ的消息负载</p> 
 <p>开启retry,修改消费者的application.yml文件</p> 
 <pre><code>spring:
  rabbitmq:
    listener:
      simple:
        retry:
          enabled: true # 开启本地消费者失败重试
          initial-interval: 1000 # 第一次失败等待时长为1秒
          multiplier: 1 # 失败的等待时长倍数，下次等待时长 = multiplier * 上一次等待时长
          max-attempts: 3 # 最大重试次数
          stateless: true # true无状态；false有状态。如果业务中包含事务，这里改为false</code></pre> 
 <p>当超过了重试此时spring默认会抛出异常,同时将消息丢弃,</p> 
 <hr> 
 <p><span style="color:#4da8ee;"><strong>而spring也提供了三种重试失败策略供我们定制, MessageRecovery接口的三种实现:</strong></span></p> 
 <p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p> 
 <p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p> 
 <p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p> 
 <hr> 
 <p>比较实用的是<strong>RepublishMessageRecoverer</strong>自定义处理,我们可以定义一个专门处理这种问题消息的交换机,统一进行人工处理</p> 
 <pre><code class="language-java">@Configuration
public class ErrorMessageConfig {

    //定义专门处理的"error"交换机
    @Bean
    public DirectExchange errorMessageExchange(){
        return new DirectExchange("error.direct");
    }
    
    //定义"error"队列
    @Bean
    public Queue errorQueue(){
        return new Queue("error.queue", true);
    }

    //绑定交换机与队列
    @Bean
    public Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange){
        return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with("error");
    }


    //设置republishMessageRecoverer接口
    @Bean
    public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){
        return new RepublishMessageRecoverer(rabbitTemplate, "error.direct", "error");
    }
}</code></pre> 
</blockquote> 
<h4 id="%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%20--%20%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93">消息可靠性 -- 实现总结</h4> 
<blockquote> 
 <ul><li> <p>开启生产者确认机制，确保生产者的消息能到达队列</p> </li><li> <p>开启持久化功能，确保消息未消费前在队列中不会丢失</p> </li><li> <p>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</p> </li><li> <p>开启消费者失败重试机制，并设置MessageRecoverer，多次重试失败后将消息投递到异常交换机，交由人工处理</p> </li></ul> 
</blockquote> 
<h4 id="%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA">死信交换机</h4> 
<blockquote> 
 <p>当一个队列中的消息满足下列情况之一时，可以成为<span style="color:#4da8ee;"><strong>死信（dead letter）</strong></span>：</p> 
 <p>        消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</p> 
 <p>        消息是一个过期消息，超时无人消费</p> 
 <p>        要投递的队列消息满了，无法投递</p> 
 <hr> 
 <p>如果这个包含死信的队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>（Dead Letter Exchange，简称<strong><span style="color:#4da8ee;">DLX</span></strong>）。</p> 
 <p><img alt="" height="284" src="https://images2.imgbox.com/4d/36/ZbMkBD9o_o.png" width="1177"></p> 
 <p>如果队列绑定了死信交换机,那么死信消息就会被推送到死信交换机中</p> 
 <p><img alt="" height="298" src="https://images2.imgbox.com/88/8f/oGkHfVux_o.png" width="1193"></p> 
 <p>如果死信交换机绑定了队列,那么死信消息就会进入到死信队列中</p> 
 <p><img alt="" height="285" src="https://images2.imgbox.com/d6/64/FmFwxwad_o.png" width="1188"></p> 
 <p>另外，队列将死信投递给死信交换机时，必须知道两个信息：</p> 
 <p><span style="color:#4da8ee;"><strong>死信交换机名称 </strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>死信交换机与死信队列绑定的RoutingKey</strong></span></p> 
 <p>这样才能确保投递的消息能到达死信交换机，并且正确的路由到死信队列。</p> 
 <hr> 
 <p>上面讲到的<strong>RepublishMessageRecoverer</strong>失败重试机制,我们可以为队列配置死信交换机与死信队列就可以不用配置"error"交换机,</p> 
</blockquote> 
<h4 id="%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%20--%20%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%BB%B6%E8%BF%9F%E6%8E%A8%E9%80%81">死信交换机 -- 实现消息延迟推送</h4> 
<blockquote> 
 <p><strong> TTL超时:</strong></p> 
 <p>        上面讲到称为死信有个条件是" 消息是一个过期消息,超时无人消费 ", 我们可以运用这一点,设置TTL超时的时间,实现消息的延迟推送</p> 
 <p>具体原理:</p> 
 <p><img alt="" height="521" src="https://images2.imgbox.com/fd/b8/XQuTvjb6_o.png" width="1200"></p> 
 <p>有两种方式设置超时时间:</p> 
 <p>        设置消息的超时时间:</p> 
 <pre><code class="language-java">@Test
public void testTTLMsg() {
    // 创建消息
    Message message = MessageBuilder
        .withBody("hello, ttl message".getBytes(StandardCharsets.UTF_8))
        .setExpiration("5000") //设置5000毫秒的超时
        .build();
    // 消息ID，需要封装到CorrelationData中
    CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
    // 发送消息
    rabbitTemplate.convertAndSend("ttl.direct", "ttl", message, correlationData);
    log.debug("发送消息成功");
}</code></pre> 
 <p>        设置队列的超时时间:</p> 
 <pre><code class="language-java">@Bean
public Queue ttlQueue(){
    return QueueBuilder.durable("ttl.queue") // 指定队列名称，并持久化
        .ttl(10000) // 设置队列的超时时间，10秒
        .deadLetterExchange("dl.ttl.direct") // 指定死信交换机
        .build();
}</code></pre> 
 <p>当队列和消息都设置了超时时间的话,spring会以最短的那个时间为准</p> 
 <p><strong>总结</strong></p> 
 <p><strong>        </strong><strong>消息超时的两种设置方式:</strong></p> 
 <p>                设置消息TTL属性,队列接收到消息后超过TTL时间的信息变为死信</p> 
 <p>                设置队列TTL属性,消息进入队列后超过TTL时间的信息变为死信</p> 
 <p>       <strong> 如何实现消息的延迟推送:</strong></p> 
 <p>                1) 给目标队列指定死信交换机</p> 
 <p>                2) 将消费者监听的队列绑定到死信交换机</p> 
 <p>                3) 设置消息/队列的TTL超时时间</p> 
</blockquote> 
<h4 id="%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%20--%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6%20--%C2%A0DelayExchange">死信交换机 -- 延迟队列插件 -- DelayExchange</h4> 
<blockquote> 
 <p>利用<strong>TTL结合死信交换机</strong>，我们实现了消息发出后，消费者延迟收到消息的效果。这种消息模式就称为<span style="color:#4da8ee;"><strong>延迟队列（Delay Queue）模式</strong></span>。</p> 
 <p>延迟队列的使用场景包括：</p> 
 <p>- 延迟发送短信<br> - 用户下单，如果用户在15 分钟内未支付，则自动取消<br> - 预约工作会议，20分钟后自动通知所有参会人员</p> 
 <hr> 
 <p>因为延迟队列的需求非常多，所以RabbitMQ的官方也推出了一个插件，原生支持延迟队列效果。这个插件就是<strong>DelayExchange</strong>插件。<a href="https://www.rabbitmq.com/community-plugins.html" rel="nofollow" title="Community Plugins — RabbitMQ">Community Plugins — RabbitMQ</a><a href="https://www.rabbitmq.com/community-plugins.html" rel="nofollow" title="RabbitMQ插件库">RabbitMQ插件库</a> <a href="https://www.rabbitmq.com/community-plugins.html" rel="nofollow" title="Community Plugins — RabbitMQ">Community Plugins — RabbitMQ</a></p> 
 <p><img alt="" height="202" src="https://images2.imgbox.com/cb/c4/aVd4Wpya_o.png" width="1052"></p> 
 <p> 使用方式可以参考官网地址：<a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq" rel="nofollow" title="Scheduling Messages with RabbitMQ | RabbitMQ - Blog">Scheduling Messages with RabbitMQ | RabbitMQ - Blog</a></p> 
 <hr> 
 <p><strong>DelayExchange原理</strong></p> 
 <p>DelayExchange需要将一个交换机声明为delayed类型。当我们发送消息到delayExchange时，流程如下：</p> 
 <p>        - 接收消息<br>         - 判断消息是否具备x-delay属性<br>         - 如果有x-delay属性，说明是延迟消息，持久化到硬盘，读取x-delay值，作为延迟时间<br>         - 返回routing not found结果给消息发送者<br>         - x-delay时间到期后，重新投递消息到指定队列</p> 
 <hr> 
 <p><strong>使用DelayExchange</strong></p> 
 <p>声明一个交换机，交换机的类型可以是任意类型，只需要设定delayed属性为true即可，然后声明队列与其绑定即可。</p> 
 <p>        基于注解:</p> 
 <p><img alt="" height="265" src="https://images2.imgbox.com/4c/9a/rBmJ1Ndg_o.png" width="999"></p> 
 <p>         基于@Bean:<img alt="" height="500" src="https://images2.imgbox.com/e1/33/ipfhPhho_o.png" width="1180"></p> 
 <p> 发送消息时,需要设置x-delay属性,给定超时时间</p> 
 <p><img alt="" height="365" src="https://images2.imgbox.com/3e/e7/zyjzbgPa_o.png" width="1166"></p> 
</blockquote> 
<h4 id="%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%20--%20%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97">消息堆积 -- 惰性队列</h4> 
<blockquote> 
 <p>消息堆积问题:</p> 
 <p>        当遇到消息的生产速度高于消息的处理速度的时候,消息就会在队列中堆积,引发消息堆积问题,解决消息堆积问题有两种方案</p> 
 <p>       <strong> 使用work queue的队列模型</strong>,通过增加消费者来提高消息处理的速度</p> 
 <p><img alt="" height="329" src="https://images2.imgbox.com/a6/ae/NvWVjuIr_o.png" width="977"></p> 
 <p>         提高队列的存储容量,而消息队列默认是将数据存储到内存中的,这样显然不满足需求,所以我们要使用RabbitMQ的3.6.0版本开始,增加的<strong>Lazy Queues</strong>的概念，也就是惰性队列</p> 
 <hr> 
 <p><strong>Lazy Queues(惰性队列):</strong></p> 
 <p><strong>        </strong>- 接收到消息后<strong>直接存入磁盘</strong>而非内存<br>         - 消费者要消费消息时才会从磁盘中读取并加载到内存<br>         - 支持数百万条的消息存储</p> 
 <p><span style="color:#4da8ee;"><strong>使用惰性队列就能极大的提高消息队列的容量,不过这时候,消费消息的时候要从磁盘读取,会损耗一定的性能</strong></span></p> 
 <hr> 
 <p><strong>开启Lazy Queues</strong>:</p> 
 <p>        设置惰性队列,有两种方式,可以在程序运行时,动态的将普通队列改为惰性队列,也可以在定义队列的时候直接设置为惰性队列</p> 
 <p><strong>修改运行中的队列:</strong></p> 
 <pre><code class="language-java">rabbitmqctl set_policy Lazy "^lazy-queue$" '{"queue-mode":"lazy"}' --apply-to queues  </code></pre> 
 <p>命令解读：</p> 
 <p>- <strong>rabbitmqctl</strong> ：RabbitMQ的命令行工具<br> - <strong>set_policy</strong> ：添加一个策略<br> - <strong>Lazy</strong> ：策略名称，可以自定义<br> - <strong>"^lazy-queue$"</strong> ：用正则表达式匹配队列的名字<br> - <strong>'{"queue-mode":"lazy"}'</strong>：设置队列模式为lazy模式<br> - <strong>--apply-to queues</strong>  ：策略的作用对象，是所有满足正则表达式的队列</p> 
 <p><strong>创建惰性队列:</strong></p> 
 <p>        基于注解:</p> 
 <p>                <img alt="" height="269" src="https://images2.imgbox.com/4d/f0/49YdM3B4_o.png" width="913"></p> 
 <p>         基于@Bean:</p> 
 <p>                <img alt="" height="239" src="https://images2.imgbox.com/e1/ce/RhRSyXzD_o.png" width="620"></p> 
 <hr> 
 <p><strong>总结</strong></p> 
 <p>消息堆积问题的解决方案？</p> 
 <p>        - 队列上绑定多个消费者，提高消费速度<br>         - 使用惰性队列，可以再mq中保存更多消息        </p> 
 <p>惰性队列的优点有哪些？</p> 
 <p>        - 基于磁盘存储，消息上限高<br>         - 没有间歇性的page-out，性能比较稳定</p> 
 <p>惰性队列的缺点有哪些？</p> 
 <p>        - 基于磁盘存储，消息时效性会降低<br>         - 性能受限于磁盘的IO</p> 
</blockquote> 
<h4 id="MQ%E9%9B%86%E7%BE%A4%E5%88%86%E7%B1%BB">MQ集群分类</h4> 
<blockquote> 
 <p>RabbitMQ的是基于Erlang语言编写，而Erlang又是一个面向并发的语言，天然支持集群模式。RabbitMQ的集群有两种模式：</p> 
 <p><span style="color:#4da8ee;"><strong>普通集群</strong></span>：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。</p> 
 <p><span style="color:#4da8ee;"><strong>镜像集群</strong></span>：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。</p> 
 <p>镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ的3.8版本以后，推出了新的功能：<span style="color:#4da8ee;"><strong>仲裁队列</strong></span>来代替镜像集群，底层采用Raft协议确保主从的数据一致性。</p> 
</blockquote> 
<h4 id="MQ%E9%9B%86%E7%BE%A4%20--%20%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4">MQ集群 -- 普通集群</h4> 
<blockquote> 
 <p><strong>普通集群</strong>，或者叫标准集群（classic cluster），具备下列特征：</p> 
 <p>        - 会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。<br>         - 当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回<br>         - 缺点是队列所在节点宕机，队列中的消息就会丢失</p> 
 <p><img alt="" height="594" src="https://images2.imgbox.com/64/2f/RA3cJ8eQ_o.png" width="1098"></p> 
</blockquote> 
<h4 id="MQ%E9%9B%86%E7%BE%A4%20--%20%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4">MQ集群 -- 镜像集群</h4> 
<blockquote> 
 <p><strong>镜像集群</strong>：本质是主从模式，具备下面的特征：</p> 
 <p>        - 交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。<br>         - 创建队列的节点被称为该队列的主节点，备份到的其它节点叫做该队列的镜像节点。<br>         - 一个队列的主节点可能是另一个队列的镜像节点<br>         - 所有操作都是主节点完成，然后同步给镜像节点<br>         - 主宕机后，镜像节点会替代成新的主节点</p> 
 <p><img alt="" height="599" src="https://images2.imgbox.com/d0/47/p06HJ79s_o.png" width="639"></p> 
</blockquote> 
<h4 id="MQ%E9%9B%86%E7%BE%A4%20--%20%E4%BB%B2%E8%A3%81%E9%9B%86%E7%BE%A4">MQ集群 -- 仲裁集群</h4> 
<blockquote> 
 <p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p> 
 <p>        - 与镜像队列一样，都是主从模式，支持主从数据同步<br>         - 使用非常简单，没有复杂的配置<br>         - 主从同步基于Raft协议<a href="https://blog.csdn.net/xiongwenwu/article/details/79981712?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164647708516780366544645%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164647708516780366544645&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79981712.pc_search_result_control_group&amp;utm_term=Raft%E5%8D%8F%E8%AE%AE&amp;spm=1018.2226.3001.4187" title="Raft协议详解">Raft协议详解</a>，强一致</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3dc81721a5e0a0dfeb26d5bb8063dae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Cloudflare DDoS 防止洪水攻击</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/099a70d64a4a79628b44d31ba8d0df31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kafka Windows测试启动踩坑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>