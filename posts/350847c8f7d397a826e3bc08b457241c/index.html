<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>05_MySQL索引优化 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="05_MySQL索引优化" />
<meta property="og:description" content="四种：1.主键 2.单值 3.唯一 4.复合
1. 性能分析（explain） mysql5.6以后优化器做了很多改进，执行时会自动进行大量的优化，很多现象需要在5.5才能演示成功。
1.1 explain是什么? 模拟优化器查看执行计划
使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈
1.2 explain能干什么？ 表的读取顺序
那些索引可以使用
数据读取操作的操作类型
那些索引被实际使用
表之间的引用
每张表有多少行被物理查询
1.3 explain怎么玩？ explain &#43; SQL语句
官方文档：MySQL :: MySQL 8.0 Reference Manual :: 8.8.2 EXPLAIN Output Format
数据准备：
CREATE TABLE t1(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id)); CREATE TABLE t2(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id)); CREATE TABLE t3(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id)); CREATE TABLE t4(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id)); # 以下新增sql多执行几次，以便演示 INSERT INTO t1(content) VALUES(CONCAT(&#39;t1_&#39;,FLOOR(1&#43;RAND()*1000))); INSERT INTO t2(content) VALUES(CONCAT(&#39;t2_&#39;,FLOOR(1&#43;RAND()*1000))); INSERT INTO t3(content) VALUES(CONCAT(&#39;t3_&#39;,FLOOR(1&#43;RAND()*1000))); INSERT INTO t4(content) VALUES(CONCAT(&#39;t4_&#39;,FLOOR(1&#43;RAND()*1000))); 演示：explain select * from t1, t2, t3 where t1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/350847c8f7d397a826e3bc08b457241c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-09T15:11:35+08:00" />
<meta property="article:modified_time" content="2023-06-09T15:11:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">05_MySQL索引优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>四种：1.主键 2.单值 3.唯一 4.复合</p> 
</blockquote> 
<h2><strong>1. 性能分析（explain）</strong></h2> 
<blockquote> 
 <p>mysql5.6以后优化器做了很多改进，执行时会自动进行大量的优化，很多现象需要在5.5才能演示成功。</p> 
</blockquote> 
<h3><strong>1.1 explain是什么?</strong></h3> 
<p><span style="color:#1a439c;"><strong>模拟优化器查看执行计划</strong></span></p> 
<blockquote> 
 <p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的<strong>性能瓶颈</strong></p> 
</blockquote> 
<h3><strong><strong>1.2 explain能干什么？</strong></strong></h3> 
<blockquote> 
 <ul><li> <p>表的读取顺序</p> </li><li> <p>那些索引可以使用</p> </li><li> <p>数据读取操作的操作类型</p> </li><li> <p>那些索引被实际使用</p> </li><li> <p>表之间的引用</p> </li><li> <p>每张表有多少行被物理查询</p> </li></ul> 
</blockquote> 
<h3><strong><strong>1.3 explain怎么玩？</strong></strong></h3> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>explain + SQL语句</strong></span></p> 
</blockquote> 
<p>官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information" rel="nofollow" title="MySQL :: MySQL 8.0 Reference Manual :: 8.8.2 EXPLAIN Output Format">MySQL :: MySQL 8.0 Reference Manual :: 8.8.2 EXPLAIN Output Format</a></p> 
<p>数据准备：</p> 
<pre><code class="language-sql">CREATE TABLE t1(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id));
CREATE TABLE t2(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id));
CREATE TABLE t3(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id));
CREATE TABLE t4(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id));

# 以下新增sql多执行几次，以便演示
INSERT INTO t1(content) VALUES(CONCAT('t1_',FLOOR(1+RAND()*1000)));
INSERT INTO t2(content) VALUES(CONCAT('t2_',FLOOR(1+RAND()*1000)));
INSERT INTO t3(content) VALUES(CONCAT('t3_',FLOOR(1+RAND()*1000)));
INSERT INTO t4(content) VALUES(CONCAT('t4_',FLOOR(1+RAND()*1000)));</code></pre> 
<blockquote> 
 <p><span style="color:#1c7892;"><strong>演示：explain select * from t1, t2, t3 where t1.id=t2.id and t2.id=t3.id;  </strong></span></p> 
</blockquote> 
<p><img alt="" height="214" src="https://images2.imgbox.com/c6/47/fiT9L77t_o.png" width="1073"></p> 
<h3><strong>1.4 各字段解释</strong></h3> 
<h4><strong>1.4.1 id(重要)</strong></h4> 
<blockquote> 
 <p>select查询的序列号，表示查询中执行select子句或操作表的顺序</p> 
</blockquote> 
<p>三种情况：</p> 
<p><span style="color:#be191c;"><strong>① id相同，执行顺序由上至下。例如上图</strong></span></p> 
<p><span style="color:#be191c;"><strong>② id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</strong></span></p> 
<pre><code class="language-sql">EXPLAIN SELECT * 
FROM t1 WHERE t1.content =(
	SELECT t2.content
	FROM t2 WHERE t2.content=(
		SELECT t3.content
		FROM t3
		WHERE t3.content=""
	)
);</code></pre> 
<p><img alt="" height="310" src="https://images2.imgbox.com/79/df/lYeFAwXG_o.png" width="1129"><span style="color:#be191c;"><strong>③  id既有相同又有不同</strong></span></p> 
<p><img alt="" height="164" src="https://images2.imgbox.com/9a/d3/XdKbp5fw_o.png" width="1143"></p> 
<blockquote> 
 <p> id为NULL最后执行。</p> 
 <p>关注点：每个id号码，表示一趟独立的查询。一个sql 的查询趟数越少越好。</p> 
</blockquote> 
<h4><strong>1.4.2 select_type(不会用于优化)</strong></h4> 
<blockquote> 
 <p>查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询</p> 
</blockquote> 
<table><thead><tr><th> <p><span style="color:#0d0016;"><code>SIMPLE</code></span></p> </th><th> <p>简单的 SELECT(没有 使用UNION或者 子查询（PS：单表查询）)</p> </th></tr></thead><tbody><tr><td> <p><span style="color:#0d0016;"><code>PRIMARY</code></span></p> </td><td> <p>最外层的Select 作为primary 查询。(PS:含有子查询的情况,但是并不复杂)案例1</p> </td></tr><tr><td> <p><span style="color:#0d0016;"><code>DERIVED</code></span></p> </td><td> <p>在from 查询语句中的（派生，嵌套很多）子查询.(PS:递归操作这些子查询)</p> </td></tr><tr><td> <p><span style="color:#0d0016;"><code>SUBQUERY</code></span></p> </td><td> <p>在SELECT或WHERE列表中包含了子查询。案例2</p> </td></tr><tr><td> <p><span style="color:#0d0016;"><code>DEPENDENT SUBQUERY</code></span></p> </td><td> <p>第一个查询是子查询，依赖于外部查询（相关查询）。案例3</p> </td></tr><tr><td> <p><span style="color:#0d0016;"><code>MATERIALIZED</code></span></p> </td><td> <p>在非相关子查询中 并且需要进行物化时会出现MATERIALIZED关键词。案例4</p> </td></tr><tr><td> <p><span style="color:#0d0016;"><code>UNCACHEABLE SUBQUERY</code></span></p> </td><td> <p>子查询结果(系统变量)不能被缓存， 而且必须重写（分析）外部查询的每一行。案例5</p> </td></tr><tr><td> <p><span style="color:#0d0016;"><code>UNION</code></span></p> </td><td> <p>若第二个SELECT出现在UNION之后，则被标记为UNION。案例6</p> <p>若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</p> </td></tr><tr><td> <p><span style="color:#0d0016;"><code>UNION RESULT</code></span></p> </td><td> <p>结果集是通过union 而来的。案例6</p> </td></tr></tbody></table> 
<p><strong>案例1：explain select * from (select t2.* from t2) s2</strong></p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/9f/18/KtTnlIRK_o.png" width="999"></p> 
<p><strong>案例2：explain select * from t1 where t1.id=(select t2.id from t2 where t2.id=1)</strong></p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/18/80/B9H9eqaB_o.png" width="1008"></p> 
<p><strong>案例3：explain select t1.*,(select t2.content from t2 where t2.id=t1.id) from t1 where t1.id=1;</strong></p> 
<p><img alt="" height="200" src="https://images2.imgbox.com/43/0d/gkQcZtoP_o.png" width="1126"></p> 
<p><strong>案例4：explain select * from t1 where t1.content in (select t2.content from t2 where t2.content in (select t3.content from t3 where t3.content='')) #需要5.7以后版本演示</strong></p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/56/a2/9HkjRphN_o.png" width="1170"></p> 
<p><strong>案例5：EXPLAIN SELECT * from t1 where t1.id=(select t2.id from t2 where t2.id=@@sort_buffer_size);</strong></p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/7f/db/zrPaVUKz_o.png" width="1170"></p> 
<p><strong>案例6：explain select * from t1 UNION select * from t2;</strong></p> 
<p><img alt="" height="262" src="https://images2.imgbox.com/17/c0/BTjrD8We_o.png" width="1170"></p> 
<h4><strong>1.4.3 table</strong></h4> 
<blockquote> 
 <p>显示这一行的数据是关于哪张表的</p> 
</blockquote> 
<h4><strong>1.4.3 partitions</strong></h4> 
<blockquote> 
 <p>代表分区表中的命中情况，非分区表，该项为null</p> 
</blockquote> 
<h4><strong>1.4.5 type(重要)</strong></h4> 
<p><img alt="" height="100" src="https://images2.imgbox.com/7a/46/jx5sVQMn_o.png" width="1177"></p> 
<blockquote> 
 <p><span style="color:#1a439c;">type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：</span></p> 
 <p><span style="color:#1a439c;">null&gt;system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </span></p> 
 <p><span style="color:#1c7331;">常见：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</span></p> 
</blockquote> 
<p><strong>一般来说，得保证查询至少达到range级别，最好能达到ref。</strong></p> 
<blockquote> 
 <p><strong>null</strong>: MySQL不访问任何表或索引，直接返回结果</p> 
 <p><strong>system</strong>：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计。</p> 
 <p><strong>const</strong>：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。（select * from t1 where t1.id=1）</p> 
 <p><strong>eq_ref</strong>：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。（select * from t1,t2 where t1.id=t2.id）</p> 
 <p><strong>ref</strong>: 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</p> 
 <p><strong>range</strong>：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。（select * from t1 where t1.id&lt;10）</p> 
 <p><strong>index</strong>：出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。（explain select id from t1）</p> 
 <p><strong>all</strong>：Full Table Scan，将遍历全表以找到匹配的行。（explain select * from t1）</p> 
 <p><strong>index_merge</strong>：在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中。</p> 
 <p><strong>ref_or_null</strong>：对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。</p> 
 <p><strong>index_subquery</strong>：利用索引来关联子查询，不再全表扫描。</p> 
 <p><strong>unique_subquery</strong>：该联接类型类似于index_subquery。 子查询中的唯一索引。</p> 
</blockquote> 
<p><strong>① 创建索引</strong></p> 
<p><img alt="" height="89" src="https://images2.imgbox.com/2a/52/eB6whCbY_o.png" width="508"></p> 
<p><strong>② index_merge</strong></p> 
<pre><code class="language-sql">EXPLAIN SELECT * FROM t3 WHERE t3.content IS NULL OR t3.id=10;</code></pre> 
<h4><img alt="" height="128" src="https://images2.imgbox.com/86/2c/AW6YyMyu_o.png" width="1181"></h4> 
<p><strong>③ ref_or_null</strong></p> 
<pre><code class="language-sql">EXPLAIN SELECT * FROM t3 WHERE t3.content IS NULL OR t3.content='aaaa';</code></pre> 
<p><img alt="" height="142" src="https://images2.imgbox.com/67/8d/aij24zfo_o.png" width="1162"></p> 
<p><strong>④ index_subquery</strong></p> 
<pre><code class="language-sql">EXPLAIN SELECT * FROM t2 WHERE t2.content IN (SELECT t3.content FROM t3);</code></pre> 
<p><img alt="" height="185" src="https://images2.imgbox.com/48/05/hX1up9sz_o.png" width="1180"></p> 
<p><strong>⑤ unique_subquery</strong></p> 
<pre><code class="language-sql">EXPLAIN SELECT * FROM t2 WHERE t2.id IN (SELECT t3.id FROM t3);</code></pre> 
<p><img alt="" height="198" src="https://images2.imgbox.com/53/21/l7476No8_o.png" width="1154"></p> 
<h4><strong>1.4.6 possible_keys</strong></h4> 
<blockquote> 
 <p>显示可能应用在这张表中的索引，一个或多个。</p> 
 <p>查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用。</strong></p> 
</blockquote> 
<h4><strong>1.4.7 key(优化重要指标)</strong></h4> 
<blockquote> 
 <p>实际使用的索引。如果为NULL，则没有使用索引。</p> 
 <p><strong>查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</strong></p> 
</blockquote> 
<p><img alt="" height="350" src="https://images2.imgbox.com/2e/43/aQralSOl_o.png" width="1063"></p> 
<h4><strong>1.4.8 key_len(重要)</strong></h4> 
<blockquote> 
 <p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。</p> 
 <p>key_len字段能够帮你检查是否充分的利用上了索引。</p> 
</blockquote> 
<p><img alt="" height="356" src="https://images2.imgbox.com/b5/9c/1AkkPobj_o.png" width="1166"></p> 
<p>如何计算</p> 
<blockquote> 
 <p>① 先看索引上字段的类型+长度比如 int=4 ; varchar(20) =20 ; char(20) =20</p> 
 <p>② 如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf8mb3要乘 3(MySQL5.7)，如果是utf8mb4要乘4，,GBK要乘2</p> 
 <p>③ varchar这种动态字符串要加2个字节</p> 
 <p>④ 允许为空的字段要加1个字节</p> 
</blockquote> 
<p><span style="color:#be191c;">索引字段最好不要为NULL，因为NULL让统计更加复杂，并且需要额外一个字节的存储空间。</span></p> 
<h4><strong>1.4.9 ref</strong></h4> 
<blockquote> 
 <p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p> 
</blockquote> 
<h4><strong>1.4.10 rows</strong></h4> 
<blockquote> 
 <p>rows列显示MySQL认为它执行查询时必须检查的行数。<span style="color:#1c7331;"><strong>越少越好。</strong></span></p> 
</blockquote> 
<h4><strong>1.4.11 filtered</strong></h4> 
<blockquote> 
 <p>这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数，<span style="color:#fe2c24;"><strong><code>值越大越好</code></strong></span>。</p> 
</blockquote> 
<h4><strong>1.4.12 extra(重要)</strong></h4> 
<p>包含不适合在其他列中显示但十分重要的额外信息，通过这些额外信息来<span style="color:#1c7331;"><strong><code>理解MySQL到底将如何执行当前的查询语句</code></strong></span>。MySQL提供的额外信息有好几十个，这里只挑比较重要的介绍。</p> 
<p><strong>Using filesort</strong>：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。</p> 
<p>MySQL中无法利用索引完成的排序操作称为“文件排序”</p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/47/fe/SBRVrwhu_o.png" width="1161"></p> 
<p>这类SQL语句性能极差，需要进行优化。</p> 
<p>在一个非索引列上进行了order by，就会触发filesort，常见的优化方案是，在order by的列上添加索引，避免每次查询都全量排序(只查询索引列的值)。</p> 
<p><strong>Using temporary</strong>：使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</p> 
<p><img alt="" height="164" src="https://images2.imgbox.com/24/0a/bN4WdjJ5_o.png" width="1170"></p> 
<p>group by和order by同时存在，且作用于不同的字段时，就会建立临时表，以便计算出最终的结果集。</p> 
<p><strong>USING index</strong>：利用索引进行了排序或分组。表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！（EXPLAIN select * from t_emp where age=30 ORDER BY name）如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</p> 
<p><strong>Using where</strong>：表明使用了where过滤</p> 
<p><strong>using join buffer</strong>：使用了连接缓存，非主键关联(mysql8<code>Using join buffer (hash join)</code> 速度要好于 mysql5.7<code>Using join buffer (Block Nested Loop)</code> )</p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/3e/19/HdFJeHXC_o.png" width="1137"></p> 
<p><strong>impossible where</strong>：where子句的值总是false，不能用来获取任何元组。（EXPLAIN select * from t_emp where false;）</p> 
<p><strong>select tables optimized away</strong>：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p> 
<p>在innodb中：</p> 
<p><img alt="" height="162" src="https://images2.imgbox.com/84/96/JTByFTcQ_o.png" width="953"></p> 
<p>在Myisam中：</p> 
<p><img alt="" height="156" src="https://images2.imgbox.com/2f/c6/r8WrqKIz_o.png" width="1157"></p> 
<h3><strong>1.5 小结</strong></h3> 
<p><strong>表的读取顺序：id</strong></p> 
<blockquote> 
 <p>​ id趟数越少越好，id相同执行顺序由上至下，id不同 大的先执行</p> 
 <p>查询方式：select_type</p> 
 <p>那些索引可以使用：possible_keys</p> 
</blockquote> 
<p><strong>数据读取操作的操作类型：type</strong></p> 
<blockquote> 
 <p>range index all</p> 
</blockquote> 
<p><strong>那些索引被实际使用：key</strong></p> 
<blockquote> 
 <p>创建的索引是否能够被实际应用</p> 
</blockquote> 
<p><strong>使用索引的长度：key_len</strong></p> 
<blockquote> 
 <p>命中的索引匹配的长度(用来判断索引是否被完全利用)</p> 
 <p>计算索引长度：</p> 
 <p>        utf-8</p> 
 <p>                varchar(len) =使用len*3+2 (如果字段可以为null，再+1)</p> 
 <p>                char(len) =使用len*3 (如果字段可以为null，再+1)</p> 
 <p>                int(len) = 4 (如果字段可以为null，再+1)</p> 
</blockquote> 
<p><strong>表之间的引用：table</strong></p> 
<p><strong>每张表有多少行被物理查询：rows</strong></p> 
<blockquote> 
 <p>行数越少越好(多表联查时 被驱动表的rows如果使用索引了一般非常小)</p> 
</blockquote> 
<p><strong>额外优化信息：extra</strong></p> 
<blockquote> 
 <p>using join buffer(多表联查)、using filesort(排序)和 using temporary(分组) 需要考虑优化</p> 
 <p>其他情况性能都可以无需优化</p> 
</blockquote> 
<h3><strong>1.6 Json格式的执行计划</strong></h3> 
<p><strong>EXPLAIN语句输出中缺少了一个衡量执行计划好坏的重要属性 —执行计划花费的成本，在EXPLAIN单词和真正的查询语句中间加上FORMAT=JSON。</strong></p> 
<pre><code class="language-sql">EXPLAIN FORMAT=json SELECT * FROM t_emp;</code></pre> 
<pre><code class="language-javascript">{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "1.25" // 查询耗时：单位毫秒
    },
    "table": {
      "table_name": "t_emp",
      "access_type": "ALL",
      "rows_examined_per_scan": 10,
      "rows_produced_per_join": 10,
      "filtered": "100.00",
      "cost_info": {
        "read_cost": "0.25",//io耗时
        "eval_cost": "1.00",//获取处理返回结果耗时
        "prefix_cost": "1.25",
        "data_read_per_join": "800"//读取的数据量
      },
      "used_columns": [//投影列
        "id",
        "name",
        "age",
        "deptId",
        "empno"
      ]
    }
  }
}</code></pre> 
<h2><strong>2. 数据准备</strong></h2> 
<p>在做优化之前，要准备大量数据。接下来创建两张表，并往员工表里插入50W数据，部门表中插入1W条数据。</p> 
<p>建表sql：</p> 
<pre><code class="language-sql">CREATE TABLE `dept` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`deptName` VARCHAR(30) DEFAULT NULL,
	`address` VARCHAR(40) DEFAULT NULL,
	ceo INT NULL ,
	PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE TABLE `emp` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`empno` INT NOT NULL ,
	`name` VARCHAR(20) DEFAULT NULL,
	`age` INT(3) DEFAULT NULL,
	`deptId` INT(11) DEFAULT NULL,
	PRIMARY KEY (`id`)
	#CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre> 
<p><span style="color:#be191c;"><strong>怎么快速插入50w条数据呢？ 存储过程</strong></span></p> 
<p><span style="color:#be191c;"><strong>怎么保证插入的数据不重复？函数</strong></span></p> 
<p><span style="color:#1a439c;"><strong>以部门表分析：</strong></span></p> 
<blockquote> 
 <p>​ id：自增长</p> 
 <p>​ deptName：随机字符串，允许重复</p> 
 <p>​ address：随机字符串，允许重复</p> 
 <p>​ CEO：1-50w之间的任意数字</p> 
</blockquote> 
<p><span style="color:#1a439c;"><strong>以员工表分析：</strong></span></p> 
<blockquote> 
 <p>​ id：自增长</p> 
 <p>​ empno：可以使用随机数字，或者<strong>从1开始的自增数字</strong>，不允许重复</p> 
 <p>​ name：随机生成，允许姓名重复</p> 
 <p>​ age：区间随机数</p> 
 <p>​ deptId：1-1w之间随机数</p> 
</blockquote> 
<p><span style="color:#1c7331;"><strong>总结：需要产生随机字符串和区间随机数的函数。</strong></span></p> 
<h3><strong>2.1 创建函数</strong></h3> 
<pre><code class="language-sql">set global log_bin_trust_function_creators=1; 
# 随机产生字符串
DELIMITER $$
CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)
BEGIN    
	DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	WHILE i &lt; n DO  
		SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));  
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END $$

#用于随机产生区间数字
DELIMITER $$
CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN   
 DECLARE i INT DEFAULT 0;  
 SET i = FLOOR(from_num +RAND()*(to_num -from_num+1));
RETURN i;  
END$$

#假如要删除
#drop function rand_string;
#drop function rand_num;</code></pre> 
<h3><strong>2.2 存储过程</strong></h3> 
<pre><code class="language-sql"># 插入员工存储过程
DELIMITER $$
CREATE PROCEDURE  insert_emp(START INT, max_num INT)
BEGIN  
	DECLARE i INT DEFAULT 0;   
	#set autocommit =0 把autocommit设置成0  
	SET autocommit = 0;    
	REPEAT  
		SET i = i + 1;  
		INSERT INTO emp (empno, NAME, age, deptid ) VALUES ((START+i) ,rand_string(6), rand_num(30,50), rand_num(1,10000));  
		UNTIL i = max_num  
	END REPEAT;  
	COMMIT;  
END$$
 
#删除
# DELIMITER ;
# drop PROCEDURE insert_emp;

 
#往dept表添加随机数据
DELIMITER $$
CREATE PROCEDURE `insert_dept`(max_num INT)
BEGIN  
	DECLARE i INT DEFAULT 0;   
	SET autocommit = 0;    
	REPEAT  
		SET i = i + 1;  
		INSERT INTO dept ( deptname,address,ceo ) VALUES (rand_string(8),rand_string(10),rand_num(1,500000));  
		UNTIL i = max_num  
	END REPEAT;  
	COMMIT;  
END$$
 
#删除
# DELIMITER ;
# drop PROCEDURE insert_dept;</code></pre> 
<h3><strong>2.3 调用存储过程</strong></h3> 
<pre><code class="language-sql">#执行存储过程，往dept表添加1万条数据
DELIMITER ;
CALL insert_dept(10000); 

#执行存储过程，往emp表添加50万条数据
DELIMITER ;
CALL insert_emp(100000,500000); </code></pre> 
<h3><strong>2.4 批量删除表索引</strong></h3> 
<p>批量删除某个表上的所有索引</p> 
<pre><code class="language-sql">DELIMITER $$
CREATE PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))
BEGIN
	DECLARE done INT DEFAULT 0;
	DECLARE ct INT DEFAULT 0;
	DECLARE _index VARCHAR(200) DEFAULT '';
	DECLARE _cur CURSOR FOR SELECT index_name FROM information_schema.STATISTICS WHERE table_schema=dbname AND table_name=tablename AND seq_in_index=1 AND index_name &lt;&gt;'PRIMARY'  ;
	DECLARE CONTINUE HANDLER FOR NOT FOUND set done=2 ;      
	OPEN _cur;
		FETCH _cur INTO _index;
		WHILE  _index&lt;&gt;'' DO 
			SET @str = CONCAT("drop index ",_index," on ",tablename ); 
			PREPARE sql_str FROM @str ;
			EXECUTE sql_str;
			DEALLOCATE PREPARE sql_str;
			SET _index=''; 
			FETCH _cur INTO _index; 
		END WHILE;
	CLOSE _cur;
END$$</code></pre> 
<p>执行批量删除：  </p> 
<pre><code class="language-sql">CALL proc_drop_index("dbname","tablename"); # 库名称和表名称</code></pre> 
<h2><strong>3. 单表优化</strong></h2> 
<h3><strong>3.1 索引优化原则</strong></h3> 
<blockquote> 
 <ol><li> <p>不在索引列上做任何操作（<strong>计算、函数、(自动or手动)类型转换</strong>），会导致索引失效而转向全表扫描</p> </li><li> <p><strong>like以通配符开头</strong>('%abc...')mysql索引失效会变成全表扫描的操作</p> </li><li> <p>mysql 在使用<strong>不等于(!=或者&lt;&gt;)</strong>的时候无法使用索引会导致全表扫描</p> </li><li> <p><strong>is not null</strong> 也无法使用索引，但是is null是可以使用索引的</p> </li><li> <p><strong>字符串不加单引号</strong>索引失效</p> </li></ol> 
</blockquote> 
<p>案例：</p> 
<blockquote> 
 <p><span style="color:#511b78;"><strong>查找姓名以"abc"开头的员工信息</strong></span></p> 
 <p><span style="color:#511b78;"><strong>查找姓名含有"abc"的员工信息</strong></span></p> 
 <p><span style="color:#511b78;"><strong>查找年龄不等于25的员工</strong></span></p> 
 <p><span style="color:#511b78;"><strong>查找姓名不为空的员工信息</strong></span></p> 
 <p><span style="color:#511b78;"><strong>查找姓名等于"123"的员工信息</strong></span></p> 
</blockquote> 
<h4><strong>① 以下两个sql，那个写法更好？</strong></h4> 
<pre><code class="language-sql"># 创建索引
create index idx_emp_age on emp(age);
create index idx_emp_name on emp(name);

EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name LIKE 'abc%';
EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE LEFT(emp.name,3)='abc';</code></pre> 
<blockquote> 
 <p>sql访问类型range &gt; ALL；使用索引idx_emp_name &gt; NULL； 使用索引长度63 &gt; NULL; 扫描行数25 &lt; 498951</p> 
 <p><img alt="" height="276" src="https://images2.imgbox.com/5a/46/mh1Bvkbb_o.png" width="1165"></p> 
 <p>第一个sql用时：0.00s</p> 
 <p><img alt="" height="671" src="https://images2.imgbox.com/fc/f1/ZK9tGvGr_o.png" width="706"></p> 
 <p>第二个sql用时：0.37s</p> 
 <p><img alt="" height="664" src="https://images2.imgbox.com/e3/49/3KJ1DUuC_o.png" width="722"></p> 
 <p>由此可见第一个sql优于第二个sql：第一个走了索引，第二个走了全表扫描。</p> 
</blockquote> 
<h4><strong>② 把第一个sql的like查询条件改成‘%abc%’，会怎样呢？  </strong></h4> 
<blockquote> 
 <p><img alt="" height="149" src="https://images2.imgbox.com/25/f5/Jxzpzhqq_o.png" width="1161"></p> 
 <p>可以发现改成'%abc%'之后，第一个sql失去了索引优势，走了全表扫描。</p> 
</blockquote> 
<h4><strong>③ 再来看这两个sql：不等于(!=或者&lt;&gt;) </strong></h4> 
<blockquote> 
 <p><span style="color:#1a439c;">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30;<br> EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age!=30;</span></p> 
 <p><img alt="" height="298" src="https://images2.imgbox.com/2e/9b/SzH9CLJC_o.png" width="1158"></p> 
</blockquote> 
<h4><strong>④ is not null和is null</strong></h4> 
<p><img alt="" height="265" src="https://images2.imgbox.com/c7/88/DDZrss07_o.png" width="1161"><strong> </strong></p> 
<h4><strong>⑤ 字符串加引号</strong></h4> 
<p><img alt="" height="286" src="https://images2.imgbox.com/46/ae/LZLCOmfH_o.png" width="1158"></p> 
<h3><strong>3.2 组合索引原则</strong></h3> 
<blockquote> 
 <ol><li> <p>全值匹配我最爱</p> </li><li> <p>符合最左原则：不跳过索引中的列。</p> </li><li> <p>如果where条件中是OR关系，加索引不起作用</p> </li><li> <p>存储引擎不能使用索引中范围条件右边的列</p> </li></ol> 
</blockquote> 
<p><strong>① 首先删除之前创建的索引</strong></p> 
<pre><code class="language-sql">CALL proc_drop_index("mydb","emp");</code></pre> 
<p><strong>② 全值匹配我最爱  </strong></p> 
<blockquote> 
 <p><span style="color:#511b78;"><strong>SELECT SQL_NO_CACHE * FROM emp WHERE age=30 and deptId=1 and name='abc';<br> create index idx_age_deptId_name on emp(age, deptId, name);<br> SELECT SQL_NO_CACHE * FROM emp WHERE age=30 and deptId=1 and name='abc';</strong></span></p> 
</blockquote> 
<p><img alt="" height="210" src="https://images2.imgbox.com/ca/0a/NfMbh5XU_o.png" width="850"></p> 
<p><strong>③最左匹配原则 </strong></p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/2d/2e/R20m5h7K_o.png" width="950"></p> 
<p><strong>④ OR关联 </strong></p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/6c/34/9CbiKQ1w_o.png" width="1166"></p> 
<p><strong>⑤ 范围条件右边的列</strong></p> 
<p><img alt="" height="239" src="https://images2.imgbox.com/1b/23/1QUrCTfT_o.png" width="1164"></p> 
<h3><strong>3.3 小结</strong></h3> 
<p>一般性建议：</p> 
<blockquote> 
 <ol><li> <p>对于单键索引，尽量选择针对当前query过滤性更好的索引</p> </li><li> <p>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</p> </li><li> <p>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</p> </li><li> <p>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面</p> </li><li> <p>书写sql语句时，尽量避免造成索引失效的情况</p> </li></ol> 
</blockquote> 
<p>假设index(a,b,c) <strong>重要</strong></p> 
<table><thead><tr><th>Where语句</th><th>索引是否被使用</th></tr></thead><tbody><tr><td>where a = 3</td><td>Y,使用到a</td></tr><tr><td>where a = 3 and b = 5</td><td>Y,使用到a，b</td></tr><tr><td>where a = 3 and b = 5 and c = 4</td><td>Y,使用到a,b,c</td></tr><tr><td>where b = 3 或者 where b = 3 and c = 4 或者 where c = 4</td><td>N</td></tr><tr><td>where a = 3 and c = 5</td><td>使用到a， 但是c不可以，b中间断了</td></tr><tr><td>where a = 3 and b &gt; 4 and c = 5</td><td>使用到a和b， c不能用在范围之后，b断了</td></tr><tr><td>where a is null and b is not null</td><td>is null 支持索引 is not null 类似范围查询，ab能使用，b右边的会失效</td></tr><tr><td>where a &lt;&gt; 3</td><td>不能使用索引</td></tr><tr><td>where abs(a) =3</td><td>不能使用 索引</td></tr><tr><td>where a = 3 and b like 'kk%' and c = 4</td><td>Y,使用到a,b,c</td></tr><tr><td>where a = 3 and b like '%kk' and c = 4</td><td>Y,只用到a</td></tr><tr><td>where a = 3 and b like '%kk%' and c = 4</td><td>Y,只用到a</td></tr><tr><td>where a = 3 and b like 'k%kk%' and c = 4</td><td>Y,使用到a,b,c</td></tr></tbody></table> 
<p><strong>4. 关联查询优化</strong></p> 
<p>接下来再次创建两张表，并分别导入20条数据：</p> 
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS `class` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`card` INT(10) UNSIGNED NOT NULL,
	PRIMARY KEY (`id`)
);
CREATE TABLE IF NOT EXISTS `book` (
	`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`card` INT(10) UNSIGNED NOT NULL,
	PRIMARY KEY (`bookid`)
);
 
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
 
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</code></pre> 
<h3><strong>4.1 关联案例</strong></h3> 
<p>explain分析一下两个sql：</p> 
<pre><code class="language-sql">EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;
EXPLAIN SELECT * FROM class RIGHT JOIN book ON class.card = book.card;
EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;</code></pre> 
<p><img alt="" height="273" src="https://images2.imgbox.com/ea/03/clJgYhdk_o.png" width="1166"></p> 
<p>给book.card创建索引：</p> 
<pre><code class="language-sql">ALTER TABLE `book` ADD INDEX idx_card ( `card`);</code></pre> 
<p>然后explain分析：  </p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/3c/92/vEqPrm0X_o.png" width="1173"></p> 
<p>删除旧索引，添加新索引：</p> 
<pre><code class="language-sql"># 删除旧索引 + 新建 + 第3次explain
drop index idx_card on book;
ALTER TABLE class ADD INDEX index_class_card (card);</code></pre> 
<p>再次explain分析：  </p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/06/c8/Tc0pbp9p_o.png" width="1168"></p> 
<p>同时给两张表的card字段添加索引：（class(card)索引已有：index_class_card，只需给book（card）添加索引）</p> 
<pre><code class="language-sql">ALTER TABLE `book` ADD INDEX idx_card ( `card`);</code></pre> 
<p>最后explain分析：</p> 
<p><img alt="" height="449" src="https://images2.imgbox.com/44/f1/C0ms2JZt_o.png" width="1170"></p> 
<h3><strong>4.2 优化建议</strong></h3> 
<blockquote> 
 <ol><li> <p>保证被驱动表的join字段已经创建了索引</p> </li><li> <p>left/right join 时，选择小表作为驱动表，大表作为被驱动表。</p> </li><li> <p>inner join 时，mysql会自己帮你把小结果集的表选为驱动表,对被驱动表连接字段创建索引。(5.6已经优化掉了，5.5需要手动编写)</p> </li><li> <p>子查询尽量不要放在被驱动表，有可能使用不到索引。</p> </li><li> <p>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</p> </li></ol> 
</blockquote> 
<h3><strong>4.3 三种实现的比较</strong></h3> 
<h2>5. 子查询优化</h2> 
<blockquote> 
 <p>尽量不要使用not in 或者 not exists</p> 
 <p>尽量不要使用子查询</p> 
</blockquote> 
<h2>6. 排序优化</h2> 
<p>以下三种情况不走索引：</p> 
<blockquote> 
 <ol><li> <p>无过滤，不索引</p> </li><li> <p>顺序错，不索引</p> </li><li> <p>方向反，不索引</p> </li></ol> 
</blockquote> 
<pre><code class="language-sql">create index idx_age_deptid_name on emp (age,deptid,name)

# 以下  是否能使用到索引，能否去掉using filesort

explain  select SQL_NO_CACHE * from emp order by age,deptid; 

explain  select SQL_NO_CACHE * from emp order by age,deptid limit 10; 
 
 # 无过滤 不索引  观察extra的值
 
explain  select * from emp where age=45 order by deptid;
 
 
explain  select * from emp where age=45 order by   deptid,name; 
 
explain  select * from emp where age=45 order by  deptid,empno;
 
explain  select * from emp where age=45 order by  name,deptid;
 
explain select * from emp where deptid=45 order by age;
 
# 顺序错，不索引
explain select * from emp where age=45 order by  deptid desc, name desc ;
# 方向反 不索引
explain select * from emp where age=45 order by  deptid asc, name desc ;</code></pre> 
<h3><strong>6.1 优化演示</strong></h3> 
<p>ORDER BY子句，尽量使用Index方式排序,避免使用FileSort方式排序</p> 
<p><strong>执行案例前先清除emp上的索引，只留主键</strong></p> 
<pre><code class="language-sql"># 查询 年龄为30岁的，且员工编号小于101000的用户，按用户名称排序
SELECT SQL_NO_CACHE * FROM emp WHERE age =30 AND empno &lt;101000 ORDER BY NAME;</code></pre> 
<p><img alt="" height="571" src="https://images2.imgbox.com/45/2a/3jt8nD8k_o.png" width="1171"></p> 
<p>结论：很显然，执行时间为0.477s，type 是 ALL,即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。优化是必须的。</p> 
<p>优化思路： 尽量让where的过滤条件和排序使用上索引。</p> 
<p>现在过滤条件使用了两个字段（age，empno）排序使用了name。</p> 
<p>我们建一个三个字段的组合索引可否？</p> 
<pre><code class="language-sql">CREATE INDEX idx_age_empno_name ON emp(age,empno,NAME);</code></pre> 
<p>再次explain测试：</p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/a5/2a/EnNxBlta_o.png" width="1168"></p> 
<p>我们发现using filesort 依然存在，所以name 并没有用到索引。</p> 
<p>原因是因为empno是一个范围过滤，所以索引后面的字段不会再使用索引了。</p> 
<p>所以我们建一个3值索引是没有意义的 那么我们先删掉这个索引：<code>DROP INDEX idx_age_empno_name ON emp</code></p> 
<p>为了去掉filesort我们可以把索引建成</p> 
<pre><code class="language-sql">CREATE INDEX idx_age_name ON emp(age,NAME);</code></pre> 
<p>也就是说empno 和name这个两个字段只能二选其一。 这样我们优化掉了 using filesort。</p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/f7/68/bQ6pTeqZ_o.png" width="1163"></p> 
<p>执行一下sql：</p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/1f/30/2VtJjMfS_o.png" width="1167"></p> 
<p>速度果然提高了4倍。</p> 
<p>假如：<strong>选择创建age和empno会速度会怎样呢，自己试试有惊喜！</strong></p> 
<p><img alt="" height="373" src="https://images2.imgbox.com/4b/3f/4fWwqp7v_o.png" width="1162"></p> 
<p>结果竟然有 filesort的 sql 运行速度，超过了已经优化掉 filesort的 sql ，而且快了好多倍。何故？</p> 
<p>原因：是所有的排序都是在条件过滤之后才执行的，所以如果条件过滤了大部分数据的话，几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序但实际提升性能很有限。 相对的 empno&lt;101000 这个条件如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</p> 
<p>结论： <strong>当范围条件和group by 或者 order by 的字段出现二选一时 ，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</strong></p> 
<h3><strong>6.2 了解filesort算法</strong></h3> 
<blockquote> 
 <p>如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序</p> 
</blockquote> 
<h4><strong>6.2.1 双路排序</strong></h4> 
<blockquote> 
 <p>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。</p> 
</blockquote> 
<blockquote> 
 <p>也就是：<strong>从磁盘取排序字段，再buffer进行排序，再从磁盘取其他字段</strong>。</p> 
</blockquote> 
<blockquote> 
 <p>取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p> 
</blockquote> 
<h4><strong>6.2.2 单路排序</strong></h4> 
<blockquote> 
 <p><strong>从磁盘读取查询需要的所有列</strong>，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会<strong>使用更多的空间</strong>，因为它把每一行都保存在内存中了。</p> 
</blockquote> 
<blockquote> 
 <p><strong>结论及引申出的问题</strong>：由于单路是后出的，总体而言好过双路。</p> 
</blockquote> 
<blockquote> 
 <p>但是用单路有问题：在sort_buffer中，比双路排序要多占用很多空间，因为单路排序是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。</p> 
</blockquote> 
<blockquote> 
 <p>本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p> 
</blockquote> 
<h4><strong>6.2.3 优化策略</strong></h4> 
<blockquote> 
 <ol><li> <p>Order by时select * 是一个大忌，只Query需要的字段， 这点非常重要。在这里的影响是</p> 
   <ul><li> <p>当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。</p> </li><li> <p>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。</p> </li></ul></li><li> <p>尝试提高 sort_buffer_size</p> <p>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的 1M-8M之间调整</p> </li><li> <p>尝试提高 max_length_for_sort_data</p> <p>提高这个参数， 会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。1024-8192之间调整</p> </li></ol> 
</blockquote> 
<h2><strong>7. 分组优化</strong></h2> 
<p>group by 使用索引的原则几乎跟order by一致 ，唯一区别是<strong>groupby 即使没有过滤条件用到索引，也可以直接使用索引。</strong></p> 
<blockquote> 
 <ul><li> <p>group by 先排序再分组，遵照索引建的最佳左前缀法则</p> </li></ul> 
 <ul><li> <p>当无法使用索引列，增大max_length_for_sort_data和sort_buffer_size参数的设置</p> </li></ul> 
 <ul><li> <p>where高于having, 能写在where限定的条件就不要写在having中了</p> </li></ul> 
</blockquote> 
<p>只要对分组列创建索引即可</p> 
<h2><strong>8. 覆盖索引  </strong></h2> 
<p>最后使用索引的手段：覆盖索引</p> 
<p>什么是覆盖索引？简单说就是，select 到 from 之间查询的列 &lt;=使用的索引列+主键</p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/8f/d8/mUdh1kdu_o.png" width="1172"></p> 
<pre><code class="language-sql">explain select * from emp where name like '%abc';</code></pre> 
<p><img alt="" height="168" src="https://images2.imgbox.com/51/b7/uakIQBxP_o.png" width="1033"></p> 
<p><img alt="" height="821" src="https://images2.imgbox.com/ec/18/gIMcg36W_o.png" width="679"></p> 
<h2></h2> 
<p>使用覆盖索引后  </p> 
<p><img alt="" height="832" src="https://images2.imgbox.com/7a/6e/PmYa94SC_o.png" width="823"></p> 
<blockquote> 
 <p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>==一个索引包含了满足查询结果的数据就叫做覆盖索引==</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>理解方式二</strong>：非聚集复合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段，也即，索引包含了查询正在查找的数据）。</p> 
</blockquote> 
<p><strong>9. 索引无效说明</strong></p> 
<blockquote> 
 <p>创建索引后，用不用索引，最终是优化器说了算。<code>优化器会基于开销选择索引</code>，怎么开销小就怎么来。不是基于规则，也不是基于语义。</p> 
</blockquote> 
<blockquote> 
 <p>另外SQL语句是否使用索引，和数据库的版本、数据量、数据选择度（查询中选择的列数）运行环境都有关系。</p> 
</blockquote> 
<blockquote> 
 <p>所有创建索引后需要结合explain进行分析索引是否有效</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53f1395d61e7c9119bca0e2a1ff053a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">06_ MySQL优化实战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cae9e7fbbe51e5df3e1b8335687cb089/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue毕业设计——基于Vue&#43;SpringBoot&#43;MySQL的测试事务管理平台设计与实现（毕业论文&#43;程序源码）——测试事务管理平台</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>