<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP 和UDP 的详细介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP 和UDP 的详细介绍" />
<meta property="og:description" content="TCP 协议概述 TCP：传输控制协议，是一种面向连接的可靠传输协议。TCP为应用程序提供一种面向连接的、可靠的服务。（面向连接：传输前进行沟通和协商，确保互相可以/愿意发送数据）
TCP三次握手能够保证面向连接，面向连接是可靠的，并不能保证TCP传输是可靠的，三次握手是TCP传输之前的一个过程，那么如何保证TCP是可靠的：
面向连接的传输（准备好了传）最大报文段长度（一共传多少）传输确认机制（TCP发送的每一个数据都要进行确认，丢没丢）首部和数据的校验和（错没错）重传输（若没有收到ACK,则在等一定时间后重新发送数据）重排序（对分片用序列号进行重新排序）流量控制（量力而行，按需传递） 三次握手：C要向S发送数据（C/S模型，客户端先进行三次握手；如果两设备是公平的情况下是随机发送，详见下图）
三次握手的过程：
1）第一次握手：建立连接时，客户端发送syn（syn=a）包到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号
2）第二次握手：服务器收到syn包，必须确认客户的SYN（ack=a&#43;1），同时自己也发送一个SYN包（syn=b），即SYN&#43;ACK包，此时服务器进入SYN_RECV状态
3）第三次握手：客户端收到服务器的SYN&#43;ACK包，向服务器发送确认包ACK(ack=b&#43;1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手
三次握手的确认：
第一个数据包要靠第二个数据包进行显性确认，第二个数据包要靠第三个数据包进行显性确认，第三个数据包自己进行隐性确认（不需要回复，但完成确认）
第三个数据包隐性确认的过程：
eg:服务器在收到第三个数据包前会有猜想，如收到第三个数据包和自己及的猜想一样，服务器不回复，如果服务器收到的数据包和自己的猜想不一样甚至没有收到，服务器就重新传输第二个数据包，以至于客户端知道自己发送的第三个数据包失败（服务器怎么知道第三个数据包的内容？第三个数据包的内容来自刚服务器发送的第二个数据包的内容或者是内容&#43;1，即ACK确认下一个想要对方的数据包）
为什么TCP需要三次握手？
总结来说，两次不可靠，四次不高效。TCP是可靠的传输控制协议，三次握手能保证数据可靠传输又能提高传输效率，而且三次握手可以保证任何一次握手出现问题，都是可以被发现或补救的。
1）如果是两次握手：
现假定出现一种异常情况，即C发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达S。本来这是一个早已失效的报文段。但S收到此失效的连接请求报文段后，就误认为是C又发出一次新的连接请求。于是就向C发出确认报文段，同意建立连接。假定不采用三次握手，那么只要S发出确认，新的连接就建立了。由于现在C并没有发出建立连接的请求，因此不会理睬S的确认，也不会向S发送数据。但S却以为新的运输连接已经建立了，并一直等待C发来数据。S的许多资源就这样白白浪费了。采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，C不会向S的确认发出确认。S由于收不到确认，就知道C并没有要求建立连接。
2）如果是4次及以上的握手
三次握手之后，C和S可以保证正常通信，之后的次数都是徒劳没有必要，三次握手是可以建立链接的最少次数，节约资源使传输更加高效。
四次断开的过程：
1）客户端C发送一个FIN，用来关闭客户端到服务器S的数据传送
2）服务器S收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号
3）服务器S关闭与客户端C的连接，发送一个FIN给客户端C
4）客户端C发回ACK报文确认，并将确认序号设置为收到序号加1
为什么断开需要四次？为什么FIN数据包 和ACK数据包不能一起发？
断开双方都要收到应用层的指令才可以，当对方收到断开请求时并不清楚他自己的应用层要不要断开，所以先回复收到的确认，同时再问应用层要不要断开，同意后再发送自己的断开，另一方收到后确认最终断开。
举个四次断开的例子：我收到了我妈的命令（应用层断开指令）给男朋友发一条微信分手，男朋友回一条他看到了我的微信，与此同时赶紧问他妈咋办（问应用层），他妈说快分吧（应用层表示可以断开），于是男朋友又发条微信分手，我在回复一条我收到了他的微信，遂分手成功（四次断开）
也有特殊情况：当对方要断开时，我自己也收到应用层的断开指令，这种情况可以将断开请求和确认放在一个包内（FIN和ACK）
举个例子：男朋友收到了他妈命令（应用层断开指令）给我发一条微信分手，与此同时我妈也就告诉我男朋友不靠谱早点分（应用层断开指令），于是我高兴的回一条微信，表示我收到了他的分手信息，并且很乐意分手。男朋友收到我消息后回复确认，遂分手成功（三次断开）。
MSS：最大分段大小
MSS最大传输大小的缩写，是TCP 协议里面的一个概念
MSS就是TCP数据包每次能够传输的最大数据分段，为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替
优化机制/滑动窗口机制：利用滑动窗口实现流量控制（TCP一次性可以传递很多报文，若达到一定数量不能传输时减半再递增，链路稳定，窗口越大）
窗口值可以解决一包一确认很繁琐的问题，一次性可以发多个，每次确认下一个想要的包。双方可以在过程中协商窗口的大小来决定下一次传输/发包的数量
慢启动、快重传
UDP协议概述 UDP：用户数据报协议，是一种非面向连接的不可靠传输协议。非面向连接：发送数据，收不收无所谓，eg:IPTV，网络电视，接收就看，不接收就不看，但必须发送。如何保证面向连接：TCP三次握手
UDP 为应用程序提供面向无连接的服务（仅仅提供端口号）。传输数据之前源端和目的端不需要建立连接，不需要维护连接状态，转发状态等，因此服务器可同时向多个客户端传输相同的消息，UDP适用于对传输效率要求高的运用。
描述TCP和UDP的区别？
TCP：传输控制协议，是一种面向连接的可靠的传输协议
UDP:用户数据报协议，是一种非面向连接的不可靠的传输协议" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3aec89315d078fbd6542afbb6c7963d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-10T10:41:55+08:00" />
<meta property="article:modified_time" content="2019-04-10T10:41:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP 和UDP 的详细介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0cm;"><span style="color:#3399ea;"><strong>TCP 协议概述</strong></span></h2> 
<p style="margin-left:0cm;">TCP：传输控制协议，是一种面向连接的可靠传输协议。TCP为应用程序提供一种面向连接的、可靠的服务。（面向连接：传输前进行沟通和协商，确保互相可以/愿意发送数据）</p> 
<p style="margin-left:0cm;">TCP三次握手能够保证面向连接，面向连接是可靠的，并不能保证TCP传输是可靠的，三次握手是TCP传输之前的一个过程，那么如何保证TCP是可靠的：</p> 
<ol><li>面向连接的传输（准备好了传）</li><li>最大报文段长度（一共传多少）</li><li>传输确认机制（TCP发送的每一个数据都要进行确认，丢没丢）</li><li>首部和数据的校验和（错没错）</li><li>重传输（若没有收到ACK,则在等一定时间后重新发送数据）</li><li>重排序（对分片用序列号进行重新排序）</li><li>流量控制（量力而行，按需传递）</li></ol> 
<p style="margin-left:0cm;"><img alt="" class="has" height="323" src="https://images2.imgbox.com/0a/6b/KZ3D1Uf9_o.png" width="378"></p> 
<p style="margin-left:0cm;">三次握手：C要向S发送数据（C/S模型，客户端先进行三次握手；如果两设备是公平的情况下是随机发送，详见下图）</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="296" src="https://images2.imgbox.com/c8/83/eV67BQdZ_o.png" width="362"></p> 
<p style="margin-left:0cm;">三次握手的过程：</p> 
<p style="margin-left:0cm;">1）第一次握手：建立连接时，客户端发送syn（syn=a）包到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号</p> 
<p style="margin-left:0cm;">2）第二次握手：服务器收到syn包，必须确认客户的SYN（ack=a+1），同时自己也发送一个SYN包（syn=b），即SYN+ACK包，此时服务器进入SYN_RECV状态</p> 
<p style="margin-left:0cm;">3）第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=b+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手</p> 
<p style="margin-left:0cm;">三次握手的确认：</p> 
<p style="margin-left:0cm;">第一个数据包要靠第二个数据包进行显性确认，第二个数据包要靠第三个数据包进行显性确认，第三个数据包自己进行隐性确认（不需要回复，但完成确认）</p> 
<p style="margin-left:0cm;">第三个数据包隐性确认的过程：</p> 
<p style="margin-left:0cm;">eg:服务器在收到第三个数据包前会有猜想，如收到第三个数据包和自己及的猜想一样，服务器不回复，如果服务器收到的数据包和自己的猜想不一样甚至没有收到，服务器就重新传输第二个数据包，以至于客户端知道自己发送的第三个数据包失败（服务器怎么知道第三个数据包的内容？第三个数据包的内容来自刚服务器发送的第二个数据包的内容或者是内容+1，即ACK确认下一个想要对方的数据包）</p> 
<p style="margin-left:0cm;">为什么TCP需要三次握手？</p> 
<p style="margin-left:0cm;">总结来说，两次不可靠，四次不高效。TCP是可靠的传输控制协议，三次握手能保证数据可靠传输又能提高传输效率，而且三次握手可以保证任何一次握手出现问题，都是可以被发现或补救的。</p> 
<p>1）如果是两次握手：</p> 
<p style="margin-left:0cm;">现假定出现一种异常情况，即C发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达S。本来这是一个早已失效的报文段。但S收到此失效的连接请求报文段后，就误认为是C又发出一次新的连接请求。于是就向C发出确认报文段，同意建立连接。假定不采用三次握手，那么只要S发出确认，新的连接就建立了。由于现在C并没有发出建立连接的请求，因此不会理睬S的确认，也不会向S发送数据。但S却以为新的运输连接已经建立了，并一直等待C发来数据。S的许多资源就这样白白浪费了。采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，C不会向S的确认发出确认。S由于收不到确认，就知道C并没有要求建立连接。</p> 
<p>2）如果是4次及以上的握手</p> 
<p style="margin-left:0cm;">三次握手之后，C和S可以保证正常通信，之后的次数都是徒劳没有必要，三次握手是可以建立链接的最少次数，节约资源使传输更加高效。</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="306" src="https://images2.imgbox.com/61/57/jq5Dnrd9_o.png" width="344"></p> 
<p style="margin-left:0cm;">四次断开的过程：</p> 
<p style="margin-left:0cm;">1）客户端C发送一个FIN，用来关闭客户端到服务器S的数据传送</p> 
<p style="margin-left:0cm;">2）服务器S收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号</p> 
<p style="margin-left:0cm;">3）服务器S关闭与客户端C的连接，发送一个FIN给客户端C</p> 
<p style="margin-left:0cm;">4）客户端C发回ACK报文确认，并将确认序号设置为收到序号加1</p> 
<p style="margin-left:0cm;">为什么断开需要四次？为什么FIN数据包 和ACK数据包不能一起发？</p> 
<p style="margin-left:0cm;">断开双方都要收到应用层的指令才可以，当对方收到断开请求时并不清楚他自己的应用层要不要断开，所以先回复收到的确认，同时再问应用层要不要断开，同意后再发送自己的断开，另一方收到后确认最终断开。</p> 
<p style="margin-left:0cm;">举个四次断开的例子：我收到了我妈的命令（应用层断开指令）给男朋友发一条微信分手，男朋友回一条他看到了我的微信，与此同时赶紧问他妈咋办（问应用层），他妈说快分吧（应用层表示可以断开），于是男朋友又发条微信分手，我在回复一条我收到了他的微信，遂分手成功（四次断开）</p> 
<p style="margin-left:0cm;">也有特殊情况：当对方要断开时，我自己也收到应用层的断开指令，这种情况可以将断开请求和确认放在一个包内（FIN和ACK）</p> 
<p style="margin-left:0cm;">举个例子：男朋友收到了他妈命令（应用层断开指令）给我发一条微信分手，与此同时我妈也就告诉我男朋友不靠谱早点分（应用层断开指令），于是我高兴的回一条微信，表示我收到了他的分手信息，并且很乐意分手。男朋友收到我消息后回复确认，遂分手成功（三次断开）。</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="323" src="https://images2.imgbox.com/e5/e3/XVA4qvr6_o.png" width="436"></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="307" src="https://images2.imgbox.com/16/2a/T2E6fIj2_o.png" width="445"></p> 
<p style="margin-left:0cm;">MSS：最大分段大小</p> 
<p style="margin-left:0cm;">MSS最大传输大小的缩写，是TCP 协议里面的一个概念</p> 
<p style="margin-left:0cm;">MSS就是TCP数据包每次能够传输的最大数据分段，为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="301" src="https://images2.imgbox.com/da/22/dQfQXlv4_o.png" width="426"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">优化机制/滑动窗口机制：利用滑动窗口实现流量控制（TCP一次性可以传递很多报文，若达到一定数量不能传输时减半再递增，链路稳定，窗口越大）</p> 
<p style="margin-left:0cm;">窗口值可以解决一包一确认很繁琐的问题，一次性可以发多个，每次确认下一个想要的包。双方可以在过程中协商窗口的大小来决定下一次传输/发包的数量</p> 
<p style="margin-left:0cm;">慢启动、快重传</p> 
<h2 style="margin-left:0cm;"><span style="color:#3399ea;"><strong>UDP</strong><strong>协议概述</strong></span></h2> 
<p style="margin-left:0cm;">UDP：用户数据报协议，是一种非面向连接的不可靠传输协议。非面向连接：发送数据，收不收无所谓，eg:IPTV，网络电视，接收就看，不接收就不看，但必须发送。如何保证面向连接：TCP三次握手</p> 
<p style="margin-left:0cm;">UDP 为应用程序提供面向无连接的服务（仅仅提供端口号）。传输数据之前源端和目的端不需要建立连接，不需要维护连接状态，转发状态等，因此服务器可同时向多个客户端传输相同的消息，UDP适用于对传输效率要求高的运用。</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="292" src="https://images2.imgbox.com/fe/48/qtXGu9yq_o.png" width="356"></p> 
<p style="margin-left:0cm;">描述TCP和UDP的区别？</p> 
<p style="margin-left:0cm;">TCP：传输控制协议，是一种面向连接的可靠的传输协议</p> 
<p style="margin-left:0cm;">UDP:用户数据报协议，是一种非面向连接的不可靠的传输协议</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="280" src="https://images2.imgbox.com/e3/d5/thQwLjrz_o.png" width="418"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5440e5460990b4c47e735d5a68510d65/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql中dual表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7703da3fee4d93a1b8c7faa1844529ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">word中手动添加endnote的加载项</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>