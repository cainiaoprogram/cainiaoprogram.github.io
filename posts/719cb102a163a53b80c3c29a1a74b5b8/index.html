<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>malloc函数与free函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="malloc函数与free函数" />
<meta property="og:description" content="malloc函数与free函数
malloc函数
Malloc 向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。void* 表示未确定类型的指针。C,C&#43;&#43;规定，void* 类型可以强制转换为任何其它类型的指针。
1函数简介
原型
extern void *malloc(unsigned int num_bytes);
头文件
在TC2.0中可以用malloc.h或 alloc.h (注意：alloc.h 与 malloc.h 的内容是完全一致的)，而在Visual C&#43;&#43;6.0中可以用malloc.h或者stdlib.h。
功能
分配长度为num_bytes字节的内存块
返回值
如果分配成功，则返回指向被分配内存的指针(此存储区中的初始值不确定)；否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。
说明
关于该函数的原型，在旧的版本中malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。
名称解释
malloc的全称是memory allocation，中文叫动态内存分配，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。
相关函数
calloc、realloc、free、_alloca
2函数声明
全名
void *malloc(size_t size);
备注
void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者...）。
3与new的区别
从函数声明上可以看出。malloc 和 new 至少有两个不同：new 返回指定类型的指针，并且可以自动计算所需要大小。比如：
int *p;
p = new int; //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int);
或：
int* parr;
parr = newint[100]; //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/719cb102a163a53b80c3c29a1a74b5b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-11-23T15:06:58+08:00" />
<meta property="article:modified_time" content="2014-11-23T15:06:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">malloc函数与free函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p align="left"><strong>malloc函数与free函数</strong></p> 
<p align="left"><strong>malloc函数</strong></p> 
<p align="left">Malloc 向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。void* 表示未确定类型的<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>。C,C++规定，void* 类型可以<a target="_blank" href="http://baike.baidu.com/view/965170.htm" rel="nofollow noopener noreferrer"><span style="color:black">强制转换</span></a>为任何其它类型的<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>。</p> 
<p align="left"><strong>1</strong><a target="_blank" name="1"></a><a target="_blank" name="sub1213621_1"></a><strong>函数简介</strong></p> 
<p align="left"><a target="_blank" name="1_1"></a><a target="_blank" name="sub1213621_1_1"></a><strong>原型</strong></p> 
<p align="left"><span style="color:blue; background:lightgrey">extern void *malloc(unsigned int num_bytes);</span></p> 
<p align="left"><a target="_blank" name="1_2"></a><a target="_blank" name="sub1213621_1_2"></a><strong>头文件</strong></p> 
<p align="left">在TC2.0中可以用malloc.h或 alloc.h (注意：alloc.h 与 malloc.h 的内容是完全一致的)，而在Visual C++6.0中可以用malloc.h或者<a target="_blank" href="http://baike.baidu.com/view/1347718.htm" rel="nofollow noopener noreferrer"><span style="color:black">stdlib.h</span></a>。</p> 
<p align="left"><a target="_blank" name="1_3"></a><a target="_blank" name="sub1213621_1_3"></a><strong>功能</strong></p> 
<p align="left">分配长度为num_bytes字节的<a target="_blank" href="http://baike.baidu.com/view/1082.htm" rel="nofollow noopener noreferrer"><span style="color:black">内存</span></a>块</p> 
<p align="left"><a target="_blank" name="1_4"></a><a target="_blank" name="sub1213621_1_4"></a><strong>返回值</strong></p> 
<p align="left">如果分配成功，则返回指向被分配内存的<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>(此存储区中的初始值不确定)；否则返回空指针NULL。当内存不再使用时，应使用<a target="_blank" href="http://baike.baidu.com/view/512783.htm" rel="nofollow noopener noreferrer"><span style="color:black">free</span></a>()函数将内存块释放。函数返回的<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>一定要适当对齐，使其可以用于任何<a target="_blank" href="http://baike.baidu.com/view/178571.htm" rel="nofollow noopener noreferrer"><span style="color:black">数据对象</span></a>。</p> 
<p align="left"><a target="_blank" name="1_5"></a><a target="_blank" name="sub1213621_1_5"></a><strong>说明</strong></p> 
<p align="left">关于该函数的原型，在旧的版本中malloc返回的是char型<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。</p> 
<p align="left"><a target="_blank" name="1_6"></a><a target="_blank" name="sub1213621_1_6"></a><strong>名称解释</strong></p> 
<p align="left">malloc的全称是memory allocation，中文叫<a target="_blank" href="http://baike.baidu.com/view/3312702.htm" rel="nofollow noopener noreferrer"><span style="color:black">动态内存</span></a>分配，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。</p> 
<p align="left"><a target="_blank" name="1_7"></a><a target="_blank" name="sub1213621_1_7"></a><strong>相关函数</strong></p> 
<p align="left"><a target="_blank" href="http://baike.baidu.com/view/653964.htm" rel="nofollow noopener noreferrer"><span style="color:blue; background:lightgrey">calloc</span></a><span style="color:blue; background:lightgrey">、</span><span style="color:blue; background:lightgrey"><a target="_blank" href="http://baike.baidu.com/view/736230.htm" rel="nofollow noopener noreferrer"><span style="color:blue">realloc</span></a></span><span style="color:blue; background:lightgrey">、</span><span style="color:blue; background:lightgrey"><a target="_blank" href="http://baike.baidu.com/view/512783.htm" rel="nofollow noopener noreferrer"><span style="color:blue">free</span></a></span><span style="color:blue; background:lightgrey">、</span><span style="color:blue; background:lightgrey">_alloca</span></p> 
<p align="left"><strong>2</strong><a target="_blank" name="2"></a><a target="_blank" name="sub1213621_2"></a><strong>函数声明</strong></p> 
<p align="left"><a target="_blank" name="2_1"></a><a target="_blank" name="sub1213621_2_1"></a><strong>全名</strong></p> 
<p align="left"><span style="color:blue; background:lightgrey">void *malloc(size_t size);</span></p> 
<p align="left"><a target="_blank" name="2_2"></a><a target="_blank" name="sub1213621_2_2"></a><strong>备注</strong></p> 
<p align="left">void* 表示未确定类型的<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者...）。</p> 
<p align="left"><strong>3</strong><a target="_blank" name="3"></a><a target="_blank" name="sub1213621_3"></a><strong>与new的区别</strong></p> 
<p align="left">从函数声明上可以看出。malloc 和 new 至少有两个不同：new 返回指定类型的<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>，并且可以自动计算所需要大小。比如：</p> 
<p align="left"><span style="color:blue; background:lightgrey">int *p;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">p = new int; </span> </p> 
<p align="left"><span style="color:blue; background:lightgrey">//</span><span style="color:blue; background:lightgrey">返回类型为</span><span style="color:blue; background:lightgrey">int* </span><span style="color:blue; background:lightgrey">类型</span><span style="color:blue; background:lightgrey">(</span><span style="color:blue; background:lightgrey">整数型指针</span><span style="color:blue; background:lightgrey">)</span><span style="color:blue; background:lightgrey">，分配大小为</span><span style="color:blue; background:lightgrey"> sizeof(int);</span></p> 
<p align="left">或：</p> 
<p align="left"><span style="color:blue; background:lightgrey">int* parr;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">parr = new</span><span style="color:blue; background:lightgrey">int</span><span style="color:blue; background:lightgrey">[100]; </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">//</span><span style="color:blue; background:lightgrey">返回类型为</span><span style="color:blue; background:lightgrey"> int* </span><span style="color:blue; background:lightgrey">类型</span><span style="color:blue; background:lightgrey">(</span><span style="color:blue; background:lightgrey">整数型指针</span><span style="color:blue; background:lightgrey">)</span><span style="color:blue; background:lightgrey">，分配大小为</span><span style="color:blue; background:lightgrey"> sizeof(int) * 100;</span></p> 
<p align="left">而 malloc 则必须要由我们计算字节数，并且在返回后强行转换为实际类型的<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>。</p> 
<p align="left"><span style="color:blue; background:lightgrey">int* p;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">p = (int</span><span style="color:blue; background:lightgrey">*) malloc</span><span style="color:blue; background:lightgrey">(sizeof(int)*128);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">//</span><span style="color:blue; background:lightgrey">分配</span><span style="color:blue; background:lightgrey">128</span><span style="color:blue; background:lightgrey">个（可根据实际需要替换该数值）整型存储单元，</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">//</span><span style="color:blue; background:lightgrey">并将这</span><span style="color:blue; background:lightgrey">128</span><span style="color:blue; background:lightgrey">个连续的整型存储单元的首地址存储到指针变量</span><span style="color:blue; background:lightgrey">p</span><span style="color:blue; background:lightgrey">中</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">double</span><span style="color:blue; background:lightgrey">*pd=(double</span><span style="color:blue; background:lightgrey">*) malloc</span><span style="color:blue; background:lightgrey">(sizeof(double)*12);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">//</span><span style="color:blue; background:lightgrey">分配</span><span style="color:blue; background:lightgrey">12</span><span style="color:blue; background:lightgrey">个</span><span style="color:blue; background:lightgrey">double</span><span style="color:blue; background:lightgrey">型存储单元，</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">//</span><span style="color:blue; background:lightgrey">并将首地址存储到指针变量</span><span style="color:blue; background:lightgrey">pd</span><span style="color:blue; background:lightgrey">中</span></p> 
<p align="left">第一：malloc 函数返回的是 void * 类型。对于C++，如果你写成：</p> 
<p align="left">p = malloc (sizeof(int)); </p> 
<p align="left">则程序无法通过编译，报错：“不能将 void* 赋值给 int * 类型<a target="_blank" href="http://baike.baidu.com/view/296689.htm" rel="nofollow noopener noreferrer"><span style="color:black">变量</span></a>”。所以必须通过 (int *) 来将<a target="_blank" href="http://baike.baidu.com/view/965170.htm" rel="nofollow noopener noreferrer"><span style="color:black">强制转换</span></a>。而对于C，没有这个要求，但为了使C程序更方便的移植到C++中来，建议养成<a target="_blank" href="http://baike.baidu.com/view/965170.htm" rel="nofollow noopener noreferrer"><span style="color:black">强制转换</span></a>的习惯。</p> 
<p align="left">第二：函数的<a target="_blank" href="http://baike.baidu.com/view/816501.htm" rel="nofollow noopener noreferrer"><span style="color:black">实参</span></a>为 sizeof(int) ，用于指明一个<a target="_blank" href="http://baike.baidu.com/view/2317434.htm" rel="nofollow noopener noreferrer"><span style="color:black">整型数据</span></a>需要的大小。如果你写成：</p> 
<p align="left"><span style="color:blue; background:lightgrey">int* p = (int *) malloc (1);</span></p> 
<p align="left">代码也能通过编译，但事实上只分配了1个字节大小的内存空间，当你往里头存入一个整数，就会有3个字节无家可归，而直接“住进邻居家”！造成的结果是后面的内存中原有数据内容被改写。</p> 
<p align="left">在Linux中可以有这样：malloc(0)，这是因为Linux中malloc有一个下限值16Bytes，注意malloc(-1)是禁止的；但是在某些系统中是不允许malloc(0)的。在规范的程序中我们有必要按照这样的格式去使用malloc及<a target="_blank" href="http://baike.baidu.com/view/512783.htm" rel="nofollow noopener noreferrer"><span style="color:black">free</span></a>：</p> 
<p align="left"><span style="color:blue; background:lightgrey">type *p;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">if</span><span style="color:blue; background:lightgrey">(NULL == (p = (type *)malloc(sizeof</span><span style="color:blue; background:lightgrey">(type)))) </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">/*</span><span style="color:blue; background:lightgrey">请使用</span><span style="color:blue; background:lightgrey">if</span><span style="color:blue; background:lightgrey">来判断</span><span style="color:blue; background:lightgrey">,</span><span style="color:blue; background:lightgrey">这是有必要的</span><span style="color:blue; background:lightgrey">*/</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">{<!-- --></span></p> 
<p align="left"><span style="color:blue; background:lightgrey">perror("error...");</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">exit(1);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">}</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">... /*</span><span style="color:blue; background:lightgrey">其它代码</span><span style="color:blue; background:lightgrey">*/</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">free(p);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">p = NULL; /*</span><span style="color:blue; background:lightgrey">请加上这句</span><span style="color:blue; background:lightgrey">*/</span></p> 
<p align="left">malloc 也可以达到 new [] 的效果，申请出一段连续的内存，方法无非是指定你所需要内存大小。</p> 
<p align="left">比如想分配100个int类型的空间：</p> 
<p align="left"><span style="color:blue; background:lightgrey">int* p = (int</span><span style="color:blue; background:lightgrey">*) malloc</span><span style="color:blue; background:lightgrey">( sizeof(int) * 100 ); </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">//</span><span style="color:blue; background:lightgrey">分配可以放得下</span><span style="color:blue; background:lightgrey">100</span><span style="color:blue; background:lightgrey">个整数的内存空间。</span></p> 
<p align="left">另外有一点不能直接看出的区别是，malloc只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的。</p> 
<p align="left">除了分配及最后释放的方法不一样以外，通过malloc或new得到<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>，在其它操作上保持一致。</p> 
<p align="left">对其做一个特例补充</p> 
<p align="left"><span style="color:blue; background:lightgrey">char</span><span style="color:blue; background:lightgrey">*ptr;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">if</span><span style="color:blue; background:lightgrey">((ptr = (char</span><span style="color:blue; background:lightgrey">*)malloc(0)) == NULL)</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">puts("Got a null pointer");</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">else</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">puts("Got a valid pointer");</span></p> 
<p align="left">此时得到的是Got a valid pointer。把0赋给malloc能得到一个合法的<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>。</p> 
<p align="left"><strong>4</strong><a target="_blank" name="4"></a><a target="_blank" name="sub1213621_4"></a><strong>工作机制</strong></p> 
<p align="left">malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲<a target="_blank" href="http://baike.baidu.com/view/549479.htm" rel="nofollow noopener noreferrer"><span style="color:black">链表</span></a>。调用malloc函数时，它沿<a target="_blank" href="http://baike.baidu.com/view/694082.htm" rel="nofollow noopener noreferrer"><span style="color:black">连接表</span></a>寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用<a target="_blank" href="http://baike.baidu.com/view/512783.htm" rel="nofollow noopener noreferrer"><span style="color:black">free</span></a>函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL<a target="_blank" href="http://baike.baidu.com/view/159417.htm" rel="nofollow noopener noreferrer"><span style="color:black">指针</span></a>，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。</p> 
<p align="left">Linux Libc6采用的机制是在<a target="_blank" href="http://baike.baidu.com/view/512783.htm" rel="nofollow noopener noreferrer"><span style="color:black">free</span></a>的时候试图整合相邻的碎片，使其合并成为一个较大的free空间。</p> 
<p align="left"><strong>5</strong><a target="_blank" name="5"></a><a target="_blank" name="sub1213621_5"></a><strong>程序示例</strong></p> 
<p align="left"><a target="_blank" name="5_1"></a><a target="_blank" name="sub1213621_5_1"></a><strong>正常程序</strong></p> 
<p align="left"><span style="color:blue; background:lightgrey">typedef</span><span style="color:blue; background:lightgrey">struct</span><span style="color:blue; background:lightgrey">data_type{<!-- --></span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    int</span><span style="color:blue; background:lightgrey">age;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    char</span><span style="color:blue; background:lightgrey">name[20];</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">} data;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">data *bob;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">bob = (data *) malloc( sizeof(data) );</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">if( bob != NULL ) {<!-- --></span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    bob-&gt;age = 22;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    strcpy( bob-&gt;name,"Robert"</span><span style="color:blue; background:lightgrey">);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    printf( "%s is %dyears old\n", bob-&gt;name, bob-&gt;age );</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">}else{<!-- --></span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    printf("mallocerror!\n");</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    exit(1);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">}</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">free( bob );</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">bob = NULL;</span></p> 
<p align="left"><a target="_blank" name="5_2"></a><a target="_blank" name="sub1213621_5_2"></a><strong>内存泄漏实例</strong></p> 
<p align="left">例1：</p> 
<p align="left"><span style="color:blue; background:lightgrey">#include &lt;stdio.h&gt;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">#include &lt;malloc.h&gt;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">#define MAX 100000000</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">int</span><span style="color:blue; background:lightgrey">main(void)</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">{<!-- --></span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    int</span><span style="color:blue; background:lightgrey">*a[MAX];</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    int</span><span style="color:blue; background:lightgrey">i;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    for( i=0; i&lt;MAX; i++) {<!-- --></span></p> 
<p align="left"><span style="color:blue; background:lightgrey">        a[i]= (int</span><span style="color:blue; background:lightgrey">*)malloc( MAX );</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    }</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    return</span><span style="color:blue; background:lightgrey">0;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">}</span></p> 
<p align="left">例2：</p> 
<p align="left"><span style="color:blue; background:lightgrey">#include "stdio.h"</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">#include "malloc.h" //malloc()</span><span style="color:blue; background:lightgrey">函数被包含在</span><span style="color:blue; background:lightgrey">malloc.h</span><span style="color:blue; background:lightgrey">里面</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">int</span><span style="color:blue; background:lightgrey">main(void) // </span><span style="color:blue; background:lightgrey">主函数程序的入口</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">{<!-- --></span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    char</span><span style="color:blue; background:lightgrey">*a; //</span><span style="color:blue; background:lightgrey">声明一个指向</span><span style="color:blue; background:lightgrey">char</span><span style="color:blue; background:lightgrey">的指针</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    a=(char</span><span style="color:blue; background:lightgrey">*)malloc(100*sizeof(char));//</span><span style="color:blue; background:lightgrey">使用</span><span style="color:blue; background:lightgrey">malloc</span><span style="color:blue; background:lightgrey">分配内存的首地址，然后赋值给</span><span style="color:blue; background:lightgrey">a</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    gets(a); //</span><span style="color:blue; background:lightgrey">从用户那里得到数据，把数据放入</span><span style="color:blue; background:lightgrey">a</span><span style="color:blue; background:lightgrey">中</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    printf("%s\n",a);//</span><span style="color:blue; background:lightgrey">输出用户输入的数据</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    free(a); //</span><span style="color:blue; background:lightgrey">释放掉使用的内存地址，就是因为可以释放内存地址才被称为动态内存分配</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    return</span><span style="color:blue; background:lightgrey">0;  //</span><span style="color:blue; background:lightgrey">返回，退出</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    //</span><span style="color:blue; background:lightgrey">例</span><span style="color:blue; background:lightgrey">2</span><span style="color:blue; background:lightgrey">有无内存泄露？</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">}</span></p> 
<p align="left"><span style="color:blue; background:lightgrey"> </span></p> 
<p align="left"><strong>free函数</strong></p> 
<p align="left">原型: void free(void *ptr)</p> 
<p align="left">功 能: 释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池，以后可在调用malloc、realloc以及calloc函数来再分配。</p> 
<p align="left">程序例:</p> 
<p align="left"><span style="color:blue; background:lightgrey">#include &lt;string.h&gt;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">#include &lt;stdio.h&gt;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">#include &lt;malloc.h&gt;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">#include &lt;stdlib.h&gt;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">int main(void)</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">{<!-- --></span></p> 
<p align="left"><span style="color:blue; background:lightgrey">char *str;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">/* allocate memory for string */</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">str = (char *)malloc(10);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">if(str == NULL){<!-- --></span></p> 
<p align="left"><span style="color:blue; background:lightgrey">perror("malloc");</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">exit(1);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">}</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">/* copy "Hello" to string */</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">strcpy(str, "Hello");</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">/* display string */</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">printf("String is %s\n", str);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">/* free memory */</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">free(str);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">return 0;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">}</span></p> 
<p align="left"><a target="_blank" href="http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html" rel="nofollow noopener noreferrer"><strong><span style="color:black">malloc</span><span style="color:black">和</span><span style="color:black">free</span><span style="color:black">函数详解</span></strong></a><strong></strong></p> 
<p align="left">本文介绍malloc和free函数的内容。</p> 
<p align="left">在C中，对内存的管理是相当重要。下面开始介绍这两个函数：</p> 
<p align="left"><strong>1. malloc()和free()的基本概念以及基本用法：</strong></p> 
<p align="left">1. 函数原型及说明：</p> 
<p align="left">void *malloc(long NumBytes)：该函数分配了NumBytes个字节，并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。</p> 
<p align="left">关于分配失败的原因，应该有多种，比如说空间不足就是一种。</p> 
<p align="left">void free(void *FirstByte)： 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。</p> 
<p align="left"> 2. 函数的用法：</p> 
<p align="left">其实这两个函数用起来倒不是很难，也就是malloc()之后觉得用够了就甩了它把它给free()了，举个简单例子：</p> 
<p align="left">程序代码：</p> 
<p align="left"><span style="color:blue; background:lightgrey">// Code... </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">char *Ptr = NULL; </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">Ptr = (char *)malloc(100 * sizeof(char)); </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">if (NULL == Ptr) </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">{ </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">exit (1); </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">} </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">gets(Ptr);</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">// code... </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">free(Ptr); </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">Ptr = NULL;</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">/ code...</span></p> 
<p align="left">就是这样！当然，具体情况要具体分析以及具体解决。比如说，你定义了一个指针，在一个函数里申请了一块内存然后通过函数返回传递给这个指针，那么也许释放这块内存这项工作就应该留给其他函数了。</p> 
<p align="left"> 3. 关于函数使用需要注意的一些地方：</p> 
<p align="left">A. <strong><span style="color:blue">申请了内存空间后，必须检查是否分配成功</span></strong>。</p> 
<p align="left">B. 当不需要再使用申请的内存时，记得释放；<strong><span style="color:blue">释放后应该把指向这块内存的指针指向</span><span style="color:blue">NULL</span></strong>，防止程序后面不小心使用了它。</p> 
<p align="left">C. 这两个函数应该是配对。如果申请后不释放就是内存泄露；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）。</p> 
<p align="left">D. 虽然malloc()函数的类型是(void *)，任何类型的指针都可以转换成(void *)，但是最好还是在前面进行强制类型转换，因为这样可以躲过一些编译器的检查。</p> 
<p align="left">现在进入第二部分：</p> 
<p align="left"><strong>2. malloc()到底从哪里得来了内存空间：</strong></p> 
<p align="left">1. malloc()到底从哪里得到了内存空间？答案是从<strong><span style="color:blue">堆</span></strong>里面获得空间。也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会<strong><span style="color:blue">遍历该链表</span></strong>，然后就寻找<strong><span style="color:blue">第一个</span></strong>空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。关于堆的知识可以查询数据结构方面的知识或查询以前的一篇帖子<a target="_blank" href="http://www.cnblogs.com/hanyonglu/archive/2011/04/12/2014212.html" rel="nofollow noopener noreferrer"><span style="color:black">C/C++</span><span style="color:black">堆、栈及静态数据区详解</span></a>。这里不过多介绍。</p> 
<p align="left">2. 在使用malloc()分配内存空间后，一定要记得释放内存空间，否则就会出现内存泄漏。</p> 
<p align="left">3. free()到底释放了什么</p> 
<p align="left">free()释放的是指针指向的内存！注意！释放的是内存，不是指针！指针并没有被释放，指针仍然指向原来的存储空间。指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在！只不过现在指针指向的内容的垃圾，是未定义的，所以说是垃圾。因此，释放内存后把指针指向NULL，防止指针在后面不小心又被解引用了。</p> 
<p align="left"><strong>3. malloc()以及free()的机制：</strong></p> 
<p align="left">事实上，仔细看一下free()的函数原型，也许也会发现似乎很神奇，free()函数非常简单，只有一个参数，只要把指向申请空间的指针传递给free()中的参数就可以完成释放工作！这里要追踪到malloc()的申请问题了。申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。</p> 
<p align="left">大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。这就意味着如果写过一个已分配区的尾端，则会改写后一块的管理信息。这种类型的错误是灾难性的，但是因为这种错误不会很快就暴露出来，所以也就很难发现。将指向分配块的指针向后移动也可能会改写本块的管理信息。</p> 
<p align="left">malloc()申请的空间实际就是分了两个不同性质的空间。一个就是用来记录管理信息的空间，另外一个就是可用空间了。而用来记录管理信息的实际上是一个结构体。在C语言中，经常用结构来记录信息！下面看看这个结构体的原型：</p> 
<p align="left">程序代码：</p> 
<p align="left"><span style="color:blue; background:lightgrey">struct mem_control_block { </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    int is_available;    //</span><span style="color:blue; background:lightgrey">一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记</span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    int size;  //</span><span style="color:blue; background:lightgrey">这是实际空间的大小</span><span style="color:blue; background:lightgrey"> </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">};</span></p> 
<p align="left"> 所以，free()就是根据这个结构体的信息来释放malloc()申请的空间！而结构体的两个成员的大小我想应该是操作系统的事了。</p> 
<p align="left">下面看看free()的源代码</p> 
<p align="left"><span style="color:blue; background:lightgrey"> // code... </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">  void free(void *ptr)  </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    { </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">  struct mem_control_block *free; </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">  free = ptr - sizeof(struct mem_control_block); </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">  free-&gt;is_available = 1; </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">  return; </span></p> 
<p align="left"><span style="color:blue; background:lightgrey">    }</span></p> 
<p align="left"> 至于malloc的源码，有兴趣的可以到网上找一下！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/663a02317a7404d067381032ac9b3be3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IOS webView播放视频时进入页面自动播放的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/56f08c2adaa7a387cc0383987bd7cf56/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">bitwise const</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>