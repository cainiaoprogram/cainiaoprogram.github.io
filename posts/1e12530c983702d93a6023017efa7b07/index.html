<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VR全景图片浏览实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VR全景图片浏览实现" />
<meta property="og:description" content="本文章主要介绍关于VR全景图片浏览的实现，Github VR全景图片(喜欢的朋友点一下star吧)主要是基于OpenGL ES 2.0 / Swift3.0实现的代码，之后会放入OC版。(接下来会发布关于VR全景视频播放器文章，现在主要是在封装播放器)
实现思路:
创建一个球体模型获取图片的纹理数据，通过着色器渲染到球体上通过手势的变换，改变球体模型视图矩阵值VR模式,则通过拖陀螺仪获取用户的行为，调整视图矩阵。 一、文件介绍。
Sphere.h: 引入C语言头文件 #include &lt;stdio.h&gt;。Sphere.c: 生成球体坐标的C语言方法。Bridging-Header.h: 桥接文件。MMPhotoView.swift: 继承于GLKView，用来渲染球体的。 注: 桥接文件路径。 二、VR全景图片浏览实现
属性一览。 /// 传过来的VR全景图片路径 public var photoURL: String? { didSet { guard let filePath = photoURL else { return } /// 将图片转为纹理信息 photoToSwitchTexture(filePath) } } /// 相机广角角度 fileprivate var overture: CGFloat = 0 /// 索引数 fileprivate var numIndices: Int = 0 /// 顶点索引缓存指针 fileprivate var vertexIndicesBufferID: GLuint = 0 /// 顶点缓存指针 fileprivate var vertexBufferID: GLuint = 0 /// 纹理缓存指针 fileprivate var vertexTexCoordID: GLuint = 0 /// 着色器 fileprivate var effect: GLKBaseEffect?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1e12530c983702d93a6023017efa7b07/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-13T10:12:20+08:00" />
<meta property="article:modified_time" content="2017-12-13T10:12:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VR全景图片浏览实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <p>本文章主要介绍关于VR全景图片浏览的实现，<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FevenCoder%2FVRPhoto" rel="nofollow">Github VR全景图片(喜欢的朋友点一下star吧)</a>主要是基于OpenGL ES 2.0 / Swift3.0实现的代码，之后会放入OC版。(接下来会发布关于VR全景视频播放器文章，现在主要是在封装播放器)</p> 
 <p>实现思路:</p> 
 <ol><li>创建一个球体模型</li><li>获取图片的纹理数据，通过着色器渲染到球体上</li><li>通过手势的变换，改变球体模型视图矩阵值</li><li>VR模式,则通过拖陀螺仪获取用户的行为，调整视图矩阵。</li></ol> 
 <p>一、文件介绍。</p> 
 <ol><li>Sphere.h: 引入C语言头文件 #include &lt;stdio.h&gt;。</li><li>Sphere.c: 生成球体坐标的C语言方法。</li><li>Bridging-Header.h: 桥接文件。</li><li>MMPhotoView.swift: 继承于GLKView，用来渲染球体的。 注: 桥接文件路径。 
   <figure> 
    <figcaption></figcaption> 
   </figure></li></ol> 
 <p>二、VR全景图片浏览实现</p> 
 <ol><li>属性一览。</li></ol> 
 <pre><code class="hljs bash copyable">/// 传过来的VR全景图片路径
    public var photoURL: String? {
        
        didSet {
            guard <span class="hljs-built_in">let</span> filePath = photoURL <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">return</span>
            }
            /// 将图片转为纹理信息
            photoToSwitchTexture(filePath)
        }
    }
    /// 相机广角角度
    fileprivate var overture: CGFloat = 0
    /// 索引数
    fileprivate var numIndices: Int = 0
    /// 顶点索引缓存指针
    fileprivate var vertexIndicesBufferID: GLuint = 0
    /// 顶点缓存指针
    fileprivate var vertexBufferID: GLuint = 0
    /// 纹理缓存指针
    fileprivate var vertexTexCoordID: GLuint = 0
    /// 着色器
    fileprivate var effect: GLKBaseEffect?
    /// 图片纹理信息
    fileprivate var textureInfo: GLKTextureInfo?
    /// 模型坐标系
    fileprivate var modelViewMatrix: GLKMatrix4 = GLKMatrix4Identity
  
    /// 拖拽手势
    fileprivate var panX: CGFloat = 0
    fileprivate var panY: CGFloat = 0  
    <span class="hljs-built_in">let</span> sphereSliceNum = 200 /// 每一帧片数
    <span class="hljs-built_in">let</span> sphereRadius = 1.0   /// 球体半径
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="2"><li>初始化GLKView。</li></ol> 
 <pre><code class="hljs bash copyable">fileprivate func <span class="hljs-function"><span class="hljs-title">setupGLKView</span></span>() {
        
        /// 设置颜色格式和深度格式
        drawableColorFormat = GLKViewDrawableColorFormat.RGBA8888
        drawableDepthFormat = GLKViewDrawableDepthFormat.format24
        self.delegate = self
        context = EAGLContext.init(api: EAGLRenderingAPI.openGLES2)
        //将此“EAGLContext”实例设置为OpenGL的“当前激活”的“Context”
        EAGLContext.setCurrent(context)
        /// 注意: 激活深度检测,设置深度检测一定要放在设置上一句的下面, 要不然context还没有激活
        glEnable(GLenum(GL_DEPTH_TEST))
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="3"><li>运行Sphere.c C语言文件获取球体索引坐标数据, 然后将索引坐标加载到GPU 中去。</li></ol> 
 <pre><code class="hljs bash copyable">fileprivate func <span class="hljs-function"><span class="hljs-title">setupBuffer</span></span>() {
        
        var vertices: UnsafeMutablePointer&lt;Float&gt;? // 顶点
        var texCoord: UnsafeMutablePointer&lt;Float&gt;? // 纹理
        var indices: UnsafeMutablePointer&lt;UInt16&gt;? // 索引
        var numVertices: Int32? = 0
        /// 编译C文件 获取顶点/纹理/索引
        numIndices = Int(GLuint(initSphere(Int32(sphereSliceNum), Float(sphereRadius), &amp;vertices, &amp;texCoord, &amp;indices, &amp;numVertices!)))
        
        /// 加载顶点索引数据
        glGenBuffers(1, &amp;vertexIndicesBufferID) // 申请内存
        glBindBuffer(GLenum(GL_ELEMENT_ARRAY_BUFFER), vertexIndicesBufferID) // 将命名的缓冲对象绑定到指定的类型上去
        glBufferData(GLenum(GL_ELEMENT_ARRAY_BUFFER), numIndices * MemoryLayout&lt;GLushort&gt;.size, indices, GLenum(GL_STATIC_DRAW))
        
        /// 加载顶点坐标数据
        glGenBuffers(1, &amp;vertexBufferID)
        glBindBuffer(GLenum(GL_ARRAY_BUFFER), vertexBufferID)
        glBufferData(GLenum(GL_ARRAY_BUFFER), Int(numVertices!) * 3 * MemoryLayout&lt;GL<span class="hljs-built_in">float</span>&gt;.size, vertices, GLenum(GL_STATIC_DRAW))
        
        /// 激活顶点位置属性
        glEnableVertexAttribArray(GLuint(GLKVertexAttrib.position.rawValue))
        glVertexAttribPointer(GLuint(GLKVertexAttrib.position.rawValue), 3, GLenum(GL_FLOAT), GLboolean(GL_FALSE), GLsizei(MemoryLayout&lt;GL<span class="hljs-built_in">float</span>&gt;.size * 3), nil)
        
        // 纹理
        glGenBuffers(1, &amp;vertexTexCoordID)
        glBindBuffer(GLenum(GL_ARRAY_BUFFER), vertexTexCoordID)
        glBufferData(GLenum(GL_ARRAY_BUFFER), Int(numVertices!) * 2 * MemoryLayout&lt;GL<span class="hljs-built_in">float</span>&gt;.size, texCoord, GLenum(GL_DYNAMIC_DRAW))
        glEnableVertexAttribArray(GLuint(GLint(GLKVertexAttrib.texCoord0.rawValue)))
        glVertexAttribPointer(GLuint(GLint(GLKVertexAttrib.texCoord0.rawValue)), 2, GLenum(GL_FLOAT), GLboolean(GL_FALSE), GLsizei(MemoryLayout&lt;GL<span class="hljs-built_in">float</span>&gt;.size * 2), nil)
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="4"><li>初始化陀螺仪。</li></ol> 
 <pre><code class="hljs bash copyable">fileprivate func <span class="hljs-function"><span class="hljs-title">startDeviceMotion</span></span>() {
        
        /**设置初始坐标系, 并开始监控
         CMAttitudeReferenceFrameXArbitraryCorrectedZVertical: 描述的参考系默认设备平放(垂直于Z轴)，在X轴上取任意值。实际上当你开始刚开始对设备进行motion更新的时候X轴就被固定了。不过这里还使用了罗盘来对陀螺仪的测量数据做了误差修正
         使用pull形式获取数据
         */
        motionManager.startDeviceMotionUpdates(using: CMAttitudeReferenceFrame.xArbitraryCorrectedZVertical)
        modelViewMatrix = GLKMatrix4Identity
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="5"><li>添加定时器CADisplayLink。主要的目的是让它执行GLKView中的display()方法，让屏幕刷新率相同的频率相同。</li></ol> 
 <pre><code class="hljs bash copyable">fileprivate func <span class="hljs-function"><span class="hljs-title">addDisplayLink</span></span>() {
        
        <span class="hljs-built_in">let</span> displayLink = CADisplayLink.init(target: self, selector: <span class="hljs-comment">#selector(displayAction))</span>
        displayLink.add(to: RunLoop.current, <span class="hljs-keyword">for</span>Mode: RunLoopMode.commonModes)
    }
    
    @objc fileprivate func <span class="hljs-function"><span class="hljs-title">displayAction</span></span>() {
        
        display() // 执行display() 不断刷新屏幕。
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="6"><li>在GLKViewDelegate代理方法内进行绘制。</li></ol> 
 <pre><code class="hljs bash copyable">// MARK: - GLKViewDelegate
    func glkView(_ view: GLKView, drawIn rect: CGRect) {
        
        // 清除缓冲区的内容
        glClearColor(0, 0, 0, 1)
        // 清除颜色缓冲区与深度缓冲区内容
        glClear(GLbitfield(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT))
        // 渲染着色器
        effect?.prepareToDraw()
        glDrawElements(GLenum(GL_TRIANGLES), GLsizei(numIndices), GLenum(GL_UNSIGNED_SHORT), nil)
        
        update()
    }
    
    // MARK: - 生命周期方法    
    fileprivate func <span class="hljs-function"><span class="hljs-title">update</span></span>() {
        
        <span class="hljs-built_in">let</span> aspect: Float = fabs(Float(bounds.size.width) / Float(bounds.size.height))
        var projectionMatrix: GLKMatrix4 = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(85.0), aspect, 0.1, 400.0)
        projectionMatrix = GLKMatrix4Scale(projectionMatrix, -1.0, 1.0, 1.0)
        
        <span class="hljs-keyword">if</span> motionManager.deviceMotion != nil {
            
            <span class="hljs-built_in">let</span> w: Float = Float(motionManager.deviceMotion!.attitude.quaternion.w)
            <span class="hljs-built_in">let</span> x: Float = Float(motionManager.deviceMotion!.attitude.quaternion.x)
            <span class="hljs-built_in">let</span> y: Float = Float(motionManager.deviceMotion!.attitude.quaternion.y)
            <span class="hljs-built_in">let</span> z: Float = Float(motionManager.deviceMotion!.attitude.quaternion.z)
            
            projectionMatrix = GLKMatrix4RotateX(projectionMatrix, -(Float)(0.005 * panY))
            
            <span class="hljs-built_in">let</span> quaternion: GLKQuaternion = GLKQuaternionMake(-x, y, z, w)
            <span class="hljs-built_in">let</span> rotation: GLKMatrix4 = GLKMatrix4MakeWithQuaternion(quaternion)
            
            projectionMatrix = GLKMatrix4Multiply(projectionMatrix, rotation)
            
            /// 为了保证在水平放置手机的时候, 是从下往上看, 因此首先坐标系沿着x轴旋转90度
            projectionMatrix = GLKMatrix4RotateX(projectionMatrix, -Float(M_PI_2))
            effect?.transform.projectionMatrix = projectionMatrix
            
            var modelViewMatrix: GLKMatrix4 = GLKMatrix4Identity
            modelViewMatrix = GLKMatrix4RotateY(modelViewMatrix, Float(0.005 * panX))
            effect?.transform.modelviewMatrix = modelViewMatrix
        }
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="7"><li>最后一步获取VR全景图片，将图片纹理信息添加到着色器中。</li></ol> 
 <pre><code class="hljs bash copyable">/// 传过来的VR全景图片路径
    public var photoURL: String? {
        
        didSet {
            
            guard <span class="hljs-built_in">let</span> filePath = photoURL <span class="hljs-keyword">else</span> {
                
                <span class="hljs-built_in">return</span>
            }
            /// 将图片转为纹理信息
            runningTexture(filePath)
        }
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <pre><code class="hljs bash copyable">fileprivate func runningTexture(_ filePath: String) {
        
        // 获取图片纹理信息
        textureInfo = try? GLKTextureLoader.texture(withContentsOfFile: filePath, options: [GLKTextureLoaderOriginBottomLeft: NSNumber(booleanLiteral: <span class="hljs-literal">true</span>)])
        
        effect = GLKBaseEffect()
        effect?.texture2d0.enabled = GLboolean(GL_TRUE)
        effect?.texture2d0.name = textureInfo!.name
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="8"><li>示例演示。(注意：要真机测试才可以)</li></ol> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>注: 如果你喜欢OpenGL ES，想学习OpenGL ES的知识，可以去看<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.jianshu.com%2Fnb%2F2135411" rel="nofollow">落影loyinglin</a>和<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.jianshu.com%2Fnb%2F5618042" rel="nofollow">酷走天涯</a>文章。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1cde2d2c286244c79dbd50f8090d838d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QT错误：collect2:ld returned 1 exit status</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c9dd463d3892b21d0d202280f0f535f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 7.0 Camera架构源码分析1 - CameraService启动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>