<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RS485串口驱动源代码 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RS485串口驱动源代码" />
<meta property="og:description" content="1、前言 串口驱动是最简单的一种驱动了，在Linux下一切设备都认为是文件，打开设备就像打开文件一样简单，直接上代码
2、RS485.c //-------------------------------------------------------------------------------------------------- // Include head files //-------------------------------------------------------------------------------------------------- #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;termios.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;sys/socket.h&gt; #include &#34;RS485.h&#34; //------------------------------------------------------------------------------------------------- // Private Definitions //------------------------------------------------------------------------------------------------- //------------------------------------------------------------------------------------------------- // Private Members //------------------------------------------------------------------------------------------------- //------------------------------------------------------------------------------------------------- // Private Functions //------------------------------------------------------------------------------------------------- static int SetAttributes(int fd, RS485PARA Rs485Para) { struct termios newtio; bzero(&amp;newtio, sizeof(newtio)); newtio.c_cflag |= CLOCAL | CREAD; newtio.c_cflag &amp;= ~CSIZE; switch (Rs485Para.m_Bits) { case SEVEN: newtio." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9b26dadc77a5065a45923eb9a891c793/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-16T16:38:43+08:00" />
<meta property="article:modified_time" content="2022-05-16T16:38:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RS485串口驱动源代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1、前言</h3> 
<p>       串口驱动是最简单的一种驱动了，在Linux下一切设备都认为是文件，打开设备就像打开文件一样简单，直接上代码</p> 
<h3>2、RS485.c</h3> 
<pre><code>//--------------------------------------------------------------------------------------------------
// Include head files
//--------------------------------------------------------------------------------------------------
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt; 
#include &lt;termios.h&gt; 
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/socket.h&gt;

#include "RS485.h"

//-------------------------------------------------------------------------------------------------
// Private Definitions
//-------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------
// Private Members
//-------------------------------------------------------------------------------------------------


//-------------------------------------------------------------------------------------------------
// Private Functions
//-------------------------------------------------------------------------------------------------
static int SetAttributes(int fd, RS485PARA Rs485Para)
{
    struct termios newtio;

    bzero(&amp;newtio, sizeof(newtio));

    newtio.c_cflag |= CLOCAL | CREAD;
    newtio.c_cflag &amp;= ~CSIZE;

    switch (Rs485Para.m_Bits)
    {
        case SEVEN:
            newtio.c_cflag |= CS7;
            break;
        case EIGHT:
            newtio.c_cflag |= CS8;
            break;
        default:
            newtio.c_cflag |= CS8;
    }

    switch (Rs485Para.m_Parity)
    {
        case O:
            newtio.c_cflag |= PARENB;
            newtio.c_cflag |= PARODD;
            newtio.c_iflag |= (INPCK);
            break;
        case E:
            newtio.c_iflag |= (INPCK);
            newtio.c_cflag |= PARENB;
            newtio.c_cflag &amp;= ~PARODD;
            break;
        case N:
            newtio.c_cflag &amp;= ~PARENB;
            break;
        default:
            newtio.c_cflag &amp;= ~PARENB;
    }

    switch (Rs485Para.m_BaudRate)
    {
        case B_9600:
            cfsetispeed(&amp;newtio, B9600);
            break;
        case B_19200:
            cfsetispeed(&amp;newtio, B19200);
            break;
        case B_38400:
            cfsetispeed(&amp;newtio, B38400);
            break;
        case B_57600:
            cfsetispeed(&amp;newtio, B57600);
            break;
        case B_115200:
            cfsetispeed(&amp;newtio, B115200);
            break;
        default:
            cfsetispeed(&amp;newtio, B19200);
    }

    if (Rs485Para.m_Stop == ONE)
    {
        newtio.c_cflag &amp;= ~CSTOPB;
    }
    else if (Rs485Para.m_Stop == TWO)
    {
        newtio.c_cflag |= CSTOPB;
    }
    else
    {
        newtio.c_cflag &amp;= ~CSTOPB;
    }

    newtio.c_cc[VTIME] = 5;
    newtio.c_cc[VMIN] = 0;

	tcflush(fd, TCOFLUSH);

    if ((tcsetattr(fd, TCSADRAIN, &amp;newtio)) != 0)
    {
        printf("com set error:%s\n", strerror(errno));
        return -1;
    }

    return 0;
}

//-------------------------------------------------------------------------------------------------
// Public Functions
//-------------------------------------------------------------------------------------------------
int RS485Open(const char* pDevname, RS485PARA Rs485Para)
{
    int ret = 0;
	int fd = 0;
	int nZero = 0;

    if (NULL == pDevname)
    {
        printf("RS485 device name is null\n");
        return -1;
    }

    fd = open(pDevname, O_RDWR | O_NOCTTY | O_NDELAY | O_NONBLOCK);
	
    if (fd &gt; 0)
    {
        ret = SetAttributes(fd, Rs485Para);

        if (ret != 0)
        {
            printf("Set RS485 port failed, error=%s\n", strerror(errno));
            return -1;
        }
    }
    else
    {
        printf("Can't open the port %s,error=%s\n", pDevname, strerror(errno));
        return -1;
    }

    return fd;
}

int RS485Read(int fd, void* buf, int size)
{
    int nleft;
    int nread;
    char* ptr = NULL;

    ptr = buf;
    nleft = size;
 
    while (nleft &gt; 0)
    {
    	nread = read(fd, ptr, nleft);
        if (nread &lt;= 0)
        {
			break;
        }
            
        nleft -= nread;
        ptr += nread;
    }
	
    return (size - nleft);

}

int RS485Write(int fd, const void* buf, int size)
{
    int nleft = 0;
    int nwritten = 0;
    const char* ptr = NULL;
 	struct termios option;
	
    ptr = buf;
    nleft = size;
 
    while (nleft &gt; 0)
    {
    	nwritten = write(fd, ptr, nleft);
    	if (nwritten &lt;= 0)
        {
			break;
        }
		
        nleft -= nwritten;
        ptr   += nwritten;
    }
	
    return size;
}

int RS485Close(int fd)
{
    if (fd &gt; 0)
    {
        close(fd);
    }
    else
    {
        return -1;
    }
    

    return 0;
}
</code></pre> 
<h3>3、RS485.h</h3> 
<pre><code>#ifndef RS485_H
#define RS485_H

//-------------------------------------------------------------------------------------------------
// Public Includes
//-------------------------------------------------------------------------------------------------


//-------------------------------------------------------------------------------------------------
// Public Definitions
//-------------------------------------------------------------------------------------------------
enum BaudRate
{
    B_9600   = 0,
    B_19200  = 1,
    B_38400  = 2,
    B_57600  = 3,
    B_115200 = 4,
    B_40000  = 5,
    B_25000  = 6,
};

enum Bits
{
    SEVEN = 7,
    EIGHT = 8,
};

enum Parity
{
    O = 0,
    E = 1,
    N = 3,
};

enum Stop
{
    ONE = 1,
    TWO = 2,
};


//-------------------------------------------------------------------------------------------------
// Public Types
//-------------------------------------------------------------------------------------------------
typedef struct tag_RS485PARA
{
    unsigned char m_BaudRate;
    unsigned char m_Bits;
    unsigned char m_Parity;
    unsigned char m_Stop;
}RS485PARA;

//-------------------------------------------------------------------------------------------------
// Public Functions
//-------------------------------------------------------------------------------------------------

/**
 * Description: open a uart , rturn the fd
 *
 * @param pDevname          [in]  uart name with path
 * @param Rs485Para         [in]  uart parater which run correctly 
 * @return                  [out] fd value
 */
extern int RS485Open(const char *pDevname, RS485PARA Rs485Para);

/**
 * Description: read data to buf from fd
 *
 * @param fd                [in]  uart fd
 * @param buf               [in]  store data from uart 
 * @param size              [in]  data len from uart  
 * @return                  [out] data len to be read
 */
extern int RS485Read(int fd, void* buf, int size);

/**
 * Description: read data to buf from fd
 *
 * @param fd                [in]  uart fd
 * @param buf               [in]  store data from uart 
 * @param size              [in]  data len of buf  
 * @return                  [out] data len to be writen
 */
extern int RS485Write(int fd, const void *buf, const int size);

/**
 * Description: read data to buf from fd
 *
 * @param fd                [in]  uart fd
 * @return                  [out] RET_STATUS_OK if OK
 */
extern int RS485Close(int fd);
 
 
#endif 
</code></pre> 
<p>4、总结</p> 
<p>注意设置的方式是非阻塞，500毫秒等待时间，在外部程序中使用select/epool等方式去调用read读取数据就可以了</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f62dd2f48aa913df9bfa7950ee178d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">对于基本的AT命令学习与掌握</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/24f98df4bde94921e59ce850c6a64e79/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">oracle oci.dll 12版本下 载方法及路径</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>