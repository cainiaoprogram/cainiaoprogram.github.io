<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringMVC 图文详解（一） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringMVC 图文详解（一）" />
<meta property="og:description" content="文章目录 一、SpringMVC概述1.1、什么是三层架构1.2、什么是MVC1.3、什么是SpringMVC1.3.1、SpringMVC工作流程图1.3.2、SpringMVC架构图 二、 SpringMVC入门案例2.1、环境准备2.2、案例编写2.3、@RequestMapping注解 三、请求参数绑定3.1、请求参数绑定基本类型3.2、请求参数绑定实体类型3.3、解决中文乱码的过滤器3.4、请求参数绑定集合类型3.5、自定义类型转换器3.6、获取Servlet原生API 四、常用注解4.1、@ResquestParam4.2、@RequestBody4.3、REST风格URL4.4、@PathVaribale4.5、@RequestHeader4.6、@CookieValue4.7、@ModelAttribute4.8、@SessionAttribute 一、SpringMVC概述 开发架构一般都是基于两种形式：一种是C/S架构，也就是客户端/服务器，另一种是B/S架构，也就是浏览器服务器。
在JavaEE开发中，几乎全都是基于B/S架构的开发。那么在B/S架构中，系统标准的三层架构包括：表现层、业务层、持久层。
1.1、什么是三层架构 其中每一层都分工明确：
表现层：负责接收客户端请求，向客户端响应结果，负责与用户进行交互。表现层的设计一般都使用MVC模型
业务层：主要是针对不同请求业务逻辑的处理，也可理解为对数据业务逻辑处理。
持久层：主要是对非原始数据（数据库或者文本文件等存放数据的形式）的操作层，也就是说是对数据库，而不是对数据的操作，具体为业务逻辑层或用户界面层提供数据服务。
常用的基于三层开发架构的框架有：
SSH：
Struct（表示层） &#43; Spring（业务层） &#43; Hibernate（持久层）
SSM：
SpringMVC（表示层） &#43; Spring（业务层） &#43; MyBatis（持久层）
如上图
面试题：Struts2 和 StringMVC的区别？
（1）Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，因此容易实现Restful API；
（2）Struts2是多例的，每次请求都创建一个Action，类属性被方法共享，而SpringMVC是单例的，只有一个实例，方法之间变量不共享；
（3）Struts2的核心控制器是Filter，SpringMVC的核心控制器是Servlet；
（4）拦截器方面，Struts2有自己的interceptor机制，SpringMVC用的是独立的AOP方式；
（5）SpringMVC是Spring的一个模块，项目管理和安全性比Struts2好，配置文件少，并且集成了Ajax，处理ajax请求,直接通过返回数据，方法中使用注解@ResponseBody，能自动将对象转换为JSON数据。
1.2、什么是MVC MVC是一个架构，或者说是一个设计模式，它就是强制性使应用程序的输入，处理和输出分开。将一个应用程序分为三个部分：Model，View，Controller
Model 模型：
完成业务逻辑：由javaBean构成，在MVC的三个部件中，模型拥有最多的处理任务。
View 视图：
负责跟用户交互的界面。一般就是由HTML，css元素组成的界面。 在视图层里没有真正的处理发生，只负责数据输出。MVC能为应用程序处理很多不同的视图。
Controller 控制器：
接收请求—&gt;调用模型—&gt;根据结果派发页面并经过模型处理返回相应数据
注：所有的表现层框架都是基于MVC开发的。例如SpringMVC和Strtus（Strtus、Strtus2）
1.3、什么是SpringMVC 我们通常所说的Spring指的是Spring Framework。而Spring Framework也只是Spring家族中的一个分支而已。
在 Spring 的基本架构中，Spring Web MVC 也就是 SpringMVC，它是属于Spring基本架构里面的一个组成部分，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面，所以我们在后期和 Spring 进行整合的时候，几乎不需要别的什么配置。
SpringMVC又是基于mvc模式开发，在SpringMVC模块中，将MVC的分工划分为多个组件来完成，以此来提高MVC的执行效率：
DispatcherServlet：前端控制器
用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/630ffc9c617afedc1fa9011280bda626/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-28T10:18:18+08:00" />
<meta property="article:modified_time" content="2020-03-28T10:18:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringMVC 图文详解（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#SpringMVC_1" rel="nofollow">一、SpringMVC概述</a></li><li><ul><li><a href="#11_4" rel="nofollow">1.1、什么是三层架构</a></li><li><a href="#12MVC_27" rel="nofollow">1.2、什么是MVC</a></li><li><a href="#13SpringMVC_38" rel="nofollow">1.3、什么是SpringMVC</a></li><li><a href="#131SpringMVC_61" rel="nofollow">1.3.1、SpringMVC工作流程图</a></li><li><a href="#132SpringMVC_65" rel="nofollow">1.3.2、SpringMVC架构图</a></li></ul> 
  </li><li><a href="#_SpringMVC_93" rel="nofollow">二、 SpringMVC入门案例</a></li><li><ul><li><a href="#21_94" rel="nofollow">2.1、环境准备</a></li><li><a href="#22_188" rel="nofollow">2.2、案例编写</a></li><li><a href="#23RequestMapping_317" rel="nofollow">2.3、@RequestMapping注解</a></li></ul> 
  </li><li><a href="#_346" rel="nofollow">三、请求参数绑定</a></li><li><ul><li><a href="#31_347" rel="nofollow">3.1、请求参数绑定基本类型</a></li><li><a href="#32_358" rel="nofollow">3.2、请求参数绑定实体类型</a></li><li><a href="#33_374" rel="nofollow">3.3、解决中文乱码的过滤器</a></li><li><a href="#34_379" rel="nofollow">3.4、请求参数绑定集合类型</a></li><li><a href="#35_397" rel="nofollow">3.5、自定义类型转换器</a></li><li><a href="#36ServletAPI_421" rel="nofollow">3.6、获取Servlet原生API</a></li></ul> 
  </li><li><a href="#_425" rel="nofollow">四、常用注解</a></li><li><ul><li><a href="#41ResquestParam_426" rel="nofollow">4.1、@ResquestParam</a></li><li><a href="#42RequestBody_443" rel="nofollow">4.2、@RequestBody</a></li><li><a href="#43RESTURL_455" rel="nofollow">4.3、REST风格URL</a></li><li><a href="#44PathVaribale_500" rel="nofollow">4.4、@PathVaribale</a></li><li><a href="#45RequestHeader_513" rel="nofollow">4.5、@RequestHeader</a></li><li><a href="#46CookieValue_522" rel="nofollow">4.6、@CookieValue</a></li><li><a href="#47ModelAttribute_535" rel="nofollow">4.7、@ModelAttribute</a></li><li><a href="#48SessionAttribute_560" rel="nofollow">4.8、@SessionAttribute</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="SpringMVC_1"></a>一、SpringMVC概述</h2> 
<p>  开发架构一般都是基于两种形式：一种是<strong>C/S架构</strong>，也就是客户端/服务器，另一种是<strong>B/S架构</strong>，也就是浏览器服务器。<br>   在JavaEE开发中，几乎全都是基于B/S架构的开发。那么在B/S架构中，系统标准的三层架构包括：表现层、业务层、持久层。</p> 
<h3><a id="11_4"></a>1.1、什么是三层架构</h3> 
<blockquote> 
 <p>其中每一层都分工明确：<br>   <code>表现层</code>：负责接收客户端请求，向客户端响应结果，负责与用户进行交互。<strong>表现层的设计一般都使用MVC模型</strong><br>   <code>业务层</code>：主要是针对不同请求业务逻辑的处理，也可理解为对数据业务逻辑处理。<br>   <code>持久层</code>：主要是对非原始数据（数据库或者文本文件等存放数据的形式）的操作层，也就是说是对数据库，而不是对数据的操作，具体为业务逻辑层或用户界面层提供数据服务。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f6/3b/VA5qJN3H_o.png" alt="在这里插入图片描述"><br> 常用的基于三层开发架构的框架有：<br> <mark>SSH</mark>：<br> Struct（表示层） + Spring（业务层） + Hibernate（持久层）</p> 
<p><mark>SSM</mark>：<br> SpringMVC（表示层） + Spring（业务层） + MyBatis（持久层）<br> 如上图</p> 
<blockquote> 
 <p><mark>面试题：Struts2 和 StringMVC的区别？</mark><br> （1）Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，因此容易实现Restful API；<br> （2）Struts2是多例的，每次请求都创建一个Action，类属性被方法共享，而SpringMVC是单例的，只有一个实例，方法之间变量不共享；<br> （3）Struts2的核心控制器是Filter，SpringMVC的核心控制器是Servlet；<br> （4）拦截器方面，Struts2有自己的interceptor机制，SpringMVC用的是独立的AOP方式；<br> （5）SpringMVC是Spring的一个模块，项目管理和安全性比Struts2好，配置文件少，并且集成了Ajax，处理ajax请求,直接通过返回数据，方法中使用注解@ResponseBody，能自动将对象转换为JSON数据。</p> 
</blockquote> 
<hr> 
<h3><a id="12MVC_27"></a>1.2、什么是MVC</h3> 
<p>  MVC是一个架构，或者说是一个设计模式，它就是强制性使应用程序的输入，处理和输出分开。将一个应用程序分为三个部分：Model，View，Controller<br> <img src="https://images2.imgbox.com/ec/43/MEaL22NV_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><code>Model 模型</code>：<br>   完成业务逻辑：由javaBean构成，在MVC的三个部件中，模型拥有最多的处理任务。<br> <code>View 视图</code>：<br>   负责跟用户交互的界面。一般就是由HTML，css元素组成的界面。 在视图层里没有真正的处理发生，只负责数据输出。MVC能为应用程序处理很多不同的视图。<br> <code>Controller 控制器</code>：<br>   接收请求—&gt;调用模型—&gt;根据结果派发页面并经过模型处理返回相应数据<br> <mark>注</mark>：所有的表现层框架都是基于MVC开发的。例如SpringMVC和Strtus（Strtus、Strtus2）</p> 
</blockquote> 
<hr> 
<h3><a id="13SpringMVC_38"></a>1.3、什么是SpringMVC</h3> 
<p>  我们通常所说的Spring指的是<code>Spring Framework</code>。而Spring Framework也只是Spring家族中的一个分支而已。<br> <img src="https://images2.imgbox.com/f9/13/I3wAC1V8_o.png" alt="在这里插入图片描述"><br>   在 Spring 的基本架构中，Spring Web MVC 也就是 SpringMVC，它是属于Spring基本架构里面的一个组成部分，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面，所以我们在后期和 Spring 进行整合的时候，几乎不需要别的什么配置。<br> <img src="https://images2.imgbox.com/f1/2f/4eYrBc6s_o.png" alt="在这里插入图片描述"><br> SpringMVC又是基于mvc模式开发，在SpringMVC模块中，将MVC的分工划分为多个组件来完成，以此来提高MVC的执行效率：</p> 
<blockquote> 
 <p><code>DispatcherServlet：前端控制器</code><br>   用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。<br> <code>HandlerMapping：映射处理器</code><br>   HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。<br> <code>Handler：处理器</code><br>   Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。<br> <code>HandlAdapter：处理适配器</code><br>   通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。<br> <code>ViewResolver：视图解析器</code><br>   View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。<br> <code>View：视图</code><br>   springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br> <mark>说明</mark>：<br>   在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。需要用户开发的组件有handler、view</p> 
</blockquote> 
<hr> 
<h3><a id="131SpringMVC_61"></a>1.3.1、SpringMVC工作流程图</h3> 
<p><img src="https://images2.imgbox.com/22/0b/oAUVCsXO_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="132SpringMVC_65"></a>1.3.2、SpringMVC架构图</h3> 
<p><img src="https://images2.imgbox.com/2d/10/NOnwpTk1_o.png" alt="在这里插入图片描述"><br> 步骤：<br> 第<mark>一</mark>步：用户发送请求到前端控制器（DispatcherServlet）。</p> 
<p>第<mark>二</mark>步：前端控制器请求 HandlerMapping 查找 Handler，可以根据 xml 配置、注解进行查找。</p> 
<p>第<mark>三</mark>步： 处理器映射器 HandlerMapping 向前端控制器返回 Handler</p> 
<p>第<mark>四</mark>步：前端控制器调用处理器适配器去执行 Handler</p> 
<p>第<mark>五</mark>步：处理器适配器执行 Handler</p> 
<p>第<mark>六</mark>步：Handler 执行完成后给适配器返回 ModelAndView</p> 
<p>第<mark>七</mark>步：处理器适配器向前端控制器返回 ModelAndView</p> 
<blockquote> 
 <p>ModelAndView 是SpringMVC 框架的一个底层对象，包括 Model 和 View</p> 
</blockquote> 
<p>第<mark>八</mark>步：前端控制器请求试图解析器去进行视图解析，根据逻辑视图名来解析真正的视图。</p> 
<p>第<mark>九</mark>步：试图解析器向前端控制器返回 view</p> 
<p>第<mark>十</mark>步：前端控制器进行视图渲染</p> 
<p>就是将模型数据（在 ModelAndView 对象中）填充到 request 域</p> 
<hr> 
<h2><a id="_SpringMVC_93"></a>二、 SpringMVC入门案例</h2> 
<h3><a id="21_94"></a>2.1、环境准备</h3> 
<p>1、新建一个project或module，选择webapp的骨架来创建web项目：<br> <img src="https://images2.imgbox.com/89/06/uswLO14G_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/33/1e/Fge0BMpC_o.png" alt="在这里插入图片描述"><br> 2、pom.xml导入所需jiar包：<br> <img src="https://images2.imgbox.com/63/a9/HJx4Notz_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java">  <span class="token generics function"><span class="token punctuation">&lt;</span>dependencies<span class="token punctuation">&gt;</span></span>
    <span class="token generics function"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>context<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span>$<span class="token punctuation">{<!-- --></span>spring<span class="token punctuation">.</span>version<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>
    <span class="token generics function"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>web<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span>$<span class="token punctuation">{<!-- --></span>spring<span class="token punctuation">.</span>version<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>
    <span class="token generics function"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>webmvc<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span>$<span class="token punctuation">{<!-- --></span>spring<span class="token punctuation">.</span>version<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>
    <span class="token generics function"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>javax<span class="token punctuation">.</span>servlet<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>servlet<span class="token operator">-</span>api<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">2.5</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>scope<span class="token punctuation">&gt;</span></span>provided<span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>
    <span class="token generics function"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>jsp<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>jsp<span class="token operator">-</span>api<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">2.0</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>scope<span class="token punctuation">&gt;</span></span>provided<span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>
    <span class="token generics function"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>junit<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>junit<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">4.11</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
      <span class="token generics function"><span class="token punctuation">&lt;</span>scope<span class="token punctuation">&gt;</span></span>test<span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>dependencies<span class="token operator">&gt;</span>
</code></pre> 
<p>3、新建spring配置文件（spring-context-5.0.5.RELEASE版本）<br> <img src="https://images2.imgbox.com/57/47/hS4L6Bp5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6c/22/3THpddUw_o.png" alt="在这里插入图片描述"><br> 4、配置一个<code>DispatcherServlet前端控制器</code>，这个必须有：<br> <img src="https://images2.imgbox.com/4e/2c/KYLn6Aua_o.png" alt="在这里插入图片描述"><br> 5、配置Tomcat服务器，并部署项目：<br> （1）在idea中也是可以配置多个服务的。点击<code>add Configurations</code> 按钮，然后点击<code>“+”</code>号（也可以直接点击<code>Templates</code>）：<br> <img src="https://images2.imgbox.com/fb/d6/ZyEYzGJt_o.png" alt="在这里插入图片描述"></p> 
<p>拉到最下面找到tomcat ：<br> <img src="https://images2.imgbox.com/90/10/n8U91QNA_o.png" alt="在这里插入图片描述"></p> 
<p>（2）配置Tomcat服务器所在位置：<br> <img src="https://images2.imgbox.com/45/ba/mVmJITib_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/43/33/XPzlKenx_o.png" alt="在这里插入图片描述"></p> 
<p>（3）Tomcat其他基本配置：<br> <img src="https://images2.imgbox.com/f8/68/fuJEcOAC_o.png" alt="在这里插入图片描述"></p> 
<p>（4）部署项目：<br> <img src="https://images2.imgbox.com/03/b5/4XYlorUP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/42/f6/essUWuqs_o.png" alt="在这里插入图片描述"><br> <mark>注</mark>：</p> 
<blockquote> 
 <p><strong>On Update action</strong> 里面有四个选项（一般选<code>Update classes and resources</code>）：<br> -<code>Update resources</code> ：如果发现有更新，而且更新的是资源文件（<em>.jsp，</em>.xml等，不包括java文件）,就会立刻生效<br> -<code>Update classes and resources</code>： 如果发现有更新，这个是同时包含java文件和资源文件的，就会立刻生效<br> 这里需要注意一下：在运行模式下，修改java文件时不会立刻生效的；而debug模式下，修改java文件时可以立刻生效的。当然，两种运行模式下，修改resources资源文件都是可以立刻生效的。</p> 
</blockquote> 
<pre><code>-Redploy ： 重新部署，只是把原来的war删掉，不重启服务器

-Restart ： 重启服务器
</code></pre> 
<p><strong>On Frame deactivation</strong>：</p> 
<pre><code> -Do nothing : 不做任何事 （一般推荐这个，因为失去焦点的几率太大）

 -Update resources : 失去焦点后，修改的resources文件都会立刻生效

-Update classes and resources ： 失去焦点后，修改的java ，resources文件都会立刻生效（与On update action中的Update classes and resources一样，也是运行模式修改的java文件不会生效，debug模式修改的java文件会立刻生效）
</code></pre> 
<p>另外，如果<mark>Artifact</mark>是war包形式的话，On Update action与On frame deactivation中的选项也是不一样的：没有Update resources和 Update classes and resources这种选项，取而代之的是Hot Swap Classes选项，本质的意思是一样的。</p> 
<hr> 
<p><img src="https://images2.imgbox.com/61/59/U2WVMrX5_o.png" alt="在这里插入图片描述"><br> 6、启动项目，并且能正常访问：<br> <img src="https://images2.imgbox.com/60/dc/242z0KYf_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="22_188"></a>2.2、案例编写</h3> 
<p>1、由于要使用注解的方式来进行编写，所以需要在<code>springmvc.xml</code>,中加入约束：<br> <img src="https://images2.imgbox.com/af/f1/aSzE6FDB_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>beans xmlns<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/beans"</span>
       xmlns<span class="token operator">:</span>mvc<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/mvc"</span>
       xmlns<span class="token operator">:</span>context<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/context"</span>
       xmlns<span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>
       xsi<span class="token operator">:</span>schemaLocation<span class="token operator">=</span>"
        http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>beans
        http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>beans<span class="token operator">/</span>spring<span class="token operator">-</span>beans<span class="token punctuation">.</span>xsd
        http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>mvc
        http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>mvc<span class="token operator">/</span>spring<span class="token operator">-</span>mvc<span class="token punctuation">.</span>xsd
        http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>context
        http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>context<span class="token operator">/</span>spring<span class="token operator">-</span>context<span class="token punctuation">.</span>xsd"<span class="token operator">&gt;</span>


<span class="token operator">&lt;</span><span class="token operator">/</span>beans<span class="token operator">&gt;</span>

</code></pre> 
<hr> 
<p>2、新增一个index.jsp文件：<br> <img src="https://images2.imgbox.com/8a/d5/An6Vq1fo_o.png" alt="在这里插入图片描述"><br> 再新建一个<mark>success.jsp</mark>作为成功跳转页面：<br> <img src="https://images2.imgbox.com/b5/8b/5IfBkRbo_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>3、新建一个HelloController控制器：<br> <img src="https://images2.imgbox.com/8b/dc/a44DaBt4_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>4、将<mark>HellerController.java</mark>类配置到spring容器中，并配置好当接收到请求的时候调用该bean对象中的<code>sayHello()</code>方法：<br> <img src="https://images2.imgbox.com/b2/25/Es0abboj_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>  服务启动的时候，容器创建了bean对象，当收到<code>/hello</code>请求的时候，由bean对象自动请求调用<code>sayHello()</code>方法<br> <mark>问题</mark>：<br> （1）容器是如何知道需要去创建HellerController的bean对象？<br> （2）如果成功调用了<code>sayHello()</code>方法，如何让页面跳转到<code>success.jsp页面</code>？</p> 
</blockquote> 
<hr> 
<p>5、配置<mark>springmvc.xml</mark>文件，让Spring容器自动扫描注解，从而创建bean对象：<br> <img src="https://images2.imgbox.com/43/08/HVCvRmkU_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><mark>注1</mark>：<br> <code>&lt;mvc:annotation-driven/&gt;</code>该注解默认开启了以下组件：<br>   (1)<code>HandlerMapping</code>：处理器映射器<br>   (2)<code>Handler</code>：处理器<br>   (3)<code>HandlAdapter</code>：处理器适配器<br> 视图解析器底层会对sayHello()返回的“success”字符串<br> 作为跳转到“success.jsp”。跳转的前提是：<br> （1）返回的字符串与jsp页面名称匹配<br> （2）需要在视图解析器中配置jsp文件的位置和文件后缀</p> 
</blockquote> 
<blockquote> 
 <p><mark>问题</mark>：刚刚说，Tomcat一启动的时候，spring容器就创建对象，那么问题来了，谁去创建Spring容器？怎么去创建？<br> <mark>答案</mark>：<br>   当然是交给tomcat服务器去创建Spring容器。那么该如何让Tomcat去获取容器呢？大家都知道在服务启动的时候都是先加载<code>web.xml</code>文件，只要里面的配置信息存在一点问题，服务都无法正常启动。所以我们可以在web.xml中设置变量，让前端处理器去读取springmvc.xml配置文件，从而创建Spring容器。</p> 
</blockquote> 
<hr> 
<p>6、配置<code>web.xml</code>，使其读取配置文件，并创建Spring容器：<br> <img src="https://images2.imgbox.com/04/8e/0zrWGUhd_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>7、测试：<br> <img src="https://images2.imgbox.com/df/0f/ex0ILPhY_o.png" alt="在这里插入图片描述"><br> 跳转成功：<br> <img src="https://images2.imgbox.com/4a/b5/6OyckA2d_o.png" alt="在这里插入图片描述"></p> 
<p>整个入门案例原理图如图所示：<br> <img src="https://images2.imgbox.com/e0/3e/BeKmyCoG_o.png" alt="在这里插入图片描述"><br> 核心架构的具体流程步骤如下：<br> 1、首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p> 
<p>2、DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</p> 
<p>3、DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p> 
<p>4、HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；</p> 
<p>5、ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</p> 
<p>6、View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</p> 
<p>7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p> 
<p>下边两个组件通常情况下需要开发：<br>   Handler：处理器，即后端控制器用controller表示。<br>   View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。</p> 
<blockquote> 
 <p><mark>HandlerMapping的实现类</mark>的作用：<br> 实现类RequestMappingHandlerMapping，它会处理@RequestMapping 注解，并将其注册到请求映射表中。<br> <mark>HandlerAdapter的实现类</mark>的作用：<br> 实现类RequestMappingHandlerAdapter，则是处理请求的适配器，确定调用哪个类的哪个方法，并且构造方法参数，返回值。<br> 当配置了<code>mvc:annotation-driven/</code>后，Spring就知道了我们启用注解驱动。然后Spring通过context:component-scan/标签的配置，会自动为我们将扫描到的@Component，@Controller，@Service，@Repository等注解标记的组件注册到工厂中，来处理我们的请求。</p> 
</blockquote> 
<p><mark>注</mark>：使用<code>&lt;mvc:annotation-driven/&gt;</code>自动加载RequestMappingHandlerMapping（处理映射器）和RequestMappingHandlerAdapter（处理适配器）。相当于在web.xml中配置了如下：</p> 
<pre><code class="prism language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> HandlerMapping <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>bean 
	<span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>bean
    <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> HandlerAdapter <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>bean
	<span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>bean
	<span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"</span><span class="token operator">&gt;</span>   
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>bean
	<span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> HadnlerExceptionResolvers <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>bean
	<span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>bean 
	<span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>bean
	<span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>

	
</code></pre> 
<hr> 
<h3><a id="23RequestMapping_317"></a>2.3、@RequestMapping注解</h3> 
<blockquote> 
 <p><mark>知识</mark>：<code>RequestMapping注解</code><br> 作用：<br>   用于建立请求URL和处理请求方法之间的对应关系。要配置 Web 请求的映射，就需要你用上 @RequestMapping 注解。<br> 出现位置：<br>   （1）类头部：<br>     请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以<code>/</code>开头。 它出现的目的是为了使我们的URL可以按照模块化管理:<br>     例如：账户模块：<code>/account/add</code><br>     例如：订单模块：<code>/order/delete</code><br> 一般将<code>/account</code>写在类头部，将<code>/add</code>写在方法头部来使用。例如：<br> <img src="https://images2.imgbox.com/0e/f2/SJNwSXoE_o.png" alt="在这里插入图片描述"><br>   （2）方法头部：请求URL的第二级访问目录。<br>     属性：<br>     value：用于指定请求的URL。<code>它和path属性的作用是一样的。如果@RequestMapping注解此时同时用到两个或者两个以上属性，value或者path不能省略不写</code><br>     path：和value属性是一样的。<br>     method：用于指定请求的方式。如果前端的请求方式的get，服务端RequestMapping注解的请求方式是post，那么无法响应到该方法。<br> <img src="https://images2.imgbox.com/f0/94/4RBsEHNj_o.png" alt="在这里插入图片描述"><br>     params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样。<br>     例如：<br> params = <code>{"accountName"}</code>，表示请求参数必须有accountName<br> params = <code>{"moeny!100"}</code>，表示请求参数中money不能是100。<br> <img src="https://images2.imgbox.com/03/b2/kc4txwvI_o.png" alt="在这里插入图片描述"><br>     headers：用于指定限制请求消息头的条件。<br> <img src="https://images2.imgbox.com/1b/89/kdC9OV1L_o.png" alt="在这里插入图片描述"><br> <mark>注意</mark>：以上四个属性只要出现2个或以上时，他们的关系是与的关系。</p> 
</blockquote> 
<p><mark>具体<code>RequestMapping注解</code>的使用参考</mark>：<a href="https://www.cnblogs.com/zj-phper/p/8961719.html" rel="nofollow">https://www.cnblogs.com/zj-phper/p/8961719.html</a></p> 
<hr> 
<h2><a id="_346"></a>三、请求参数绑定</h2> 
<h3><a id="31_347"></a>3.1、请求参数绑定基本类型</h3> 
<blockquote> 
 <p>我们都知道，表单中请求参数都是基于<code>key=value</code>的。<br> SpringMVC绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行直接绑定的。<br> 例如：<br> <code>&lt;a href="hello?username=ZhangSan"&gt;开始学习&lt;/a&gt;</code><br> <code>&lt;a href="user/login?userName=lisi&amp;password=123"&gt;登录&lt;/a&gt;</code><br> <img src="https://images2.imgbox.com/05/66/dK2553iX_o.png" alt="在这里插入图片描述"><br> <mark>注</mark>：<br> <code>1、方法头部存在@RequestMapping注解</code><br> <code>2、方法中的参数名称必须和请求参数中的key保持一致。</code></p> 
</blockquote> 
<hr> 
<h3><a id="32_358"></a>3.2、请求参数绑定实体类型</h3> 
<p>  以上学习了基本类型作为请求参数的封装，那如果 想要把请求参数封装成一个bean实体对象，并作为请求参数发送服务端怎么做呢？<br> 1、新建<mark>Account</mark>和<mark>User</mark>两个实体类，并生成set和get方法<br> <img src="https://images2.imgbox.com/e0/f9/BqUZ7whj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/14/52/pKEvApJK_o.png" alt="在这里插入图片描述"></p> 
<p>2、准备一个表单：<br> <img src="https://images2.imgbox.com/03/67/EYfakWMl_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><mark>注</mark>：封装成bean对象，<code>name</code>属性的值必须和<code>Account.java</code>类中定义的成员变量名称保持一致。</p> 
</blockquote> 
<blockquote> 
 <p><mark>原理</mark>：<br> SpringMVC会根据name中的属性值去找到对应的实体类，并调用实体中的<code>set()</code>来给变量赋值，然后封装成bean对象。</p> 
</blockquote> 
<p>3、准备服务端代码：<br> <img src="https://images2.imgbox.com/72/fc/9rA0kVto_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="33_374"></a>3.3、解决中文乱码的过滤器</h3> 
<p>  以上例子发现，如果表单的提交方式是<code>get</code>的时候，在表单提交前输入中文是没有任何问题。但是当修改成<code>post</code>的时候，在表单提交之后就发现中文出现了乱码。<br>   之前还没学SpringMVC的时候，是通过设置请求参数的字符集来解决的：<code>req.setCharacterEncoding(“utf-8”)；</code>然而在SpringMVC中，提供了一个解决中文乱码的过滤器，在<code>web.xml</code>文件下面配置即可：<br> <img src="https://images2.imgbox.com/76/88/fORkh1JY_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="34_379"></a>3.4、请求参数绑定集合类型</h3> 
<p>  如果 想要把请求参数封装成一个bean实体对象，并放到一个<code>List集合</code>或者<code>Map集合</code>中，并作为请求参数发送服务端怎么做呢？</p> 
<p>1、 <mark>Account</mark>类中增加一个List和一个Map：<br> <img src="https://images2.imgbox.com/5b/95/f5Au4f4z_o.png" alt="在这里插入图片描述"><br> 2、制作一个表单：<br> <img src="https://images2.imgbox.com/67/a2/mEacHCJE_o.png" alt="在这里插入图片描述"></p> 
<p>3、控制器：<br> <img src="https://images2.imgbox.com/29/b0/dJ0T8jy2_o.png" alt="在这里插入图片描述"><br> 4、测试结果：</p> 
<blockquote> 
 <p><code>Account{ username='admin', password='423432', money=32132.0, list=[User{uname='张三', age=32, date=null}], map={one=User{uname='李四', age=100, date=null}}}</code></p> 
</blockquote> 
<hr> 
<h3><a id="35_397"></a>3.5、自定义类型转换器</h3> 
<p>  在请求参数传递的过程中，我们的请求参数都是字符串，但是传递到服务端会发现可以匹配<code>int</code>，<code>double</code>，甚至<code>user</code>类型。其实<mark>SpringMVC是做了请求参数类型转换的</mark>。<br>   在请求转换的过程中，会存在个别特殊类型转化不了，比如<code>Date</code>类型。如果请求参数是<code>‘2020/03/21’</code>，那么SpringMVC可以正常转换成Date。那如果请求参数是<code>‘2020-03-21’</code>，那么SpringMVC是不能自动转化成SpringMVC的。</p> 
<p>1、<mark>Use</mark>r类中新增Date成员变量：<br> <img src="https://images2.imgbox.com/1f/2c/oSaGzTZA_o.png" alt="在这里插入图片描述"></p> 
<p>2、新增加表单：<br> <img src="https://images2.imgbox.com/4d/f8/hilSL7Bx_o.png" alt="在这里插入图片描述"></p> 
<p>3、控制器中增加一个保存用户的方法：<br> <img src="https://images2.imgbox.com/42/de/3lyfHb0O_o.png" alt="在这里插入图片描述"><br> 此时大家可以传错误日期格式进行测试，代码是会报错。因为在Spring提供的所以转换器中，没有提供<code>String</code>转<code>Date</code>的。如图：<br> <img src="https://images2.imgbox.com/9b/6e/SqzJu2WE_o.png" alt="在这里插入图片描述"></p> 
<p>4、写一个<code>String</code>转<code>Date</code>的类型转化器：<br> <img src="https://images2.imgbox.com/dc/04/pZjDevCj_o.png" alt="在这里插入图片描述"><br> 5、将该Bean对象注册到容器中：<br> <img src="https://images2.imgbox.com/1b/60/JPCI8MZp_o.png" alt="在这里插入图片描述"><br> 6、测试：<br> <img src="https://images2.imgbox.com/79/3d/ViYhTfRg_o.png" alt="在这里插入图片描述"><br> 结果：<br> <img src="https://images2.imgbox.com/6c/3f/xEKhmXeF_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="36ServletAPI_421"></a>3.6、获取Servlet原生API</h3> 
<p>如果想要在控制器中获取常用的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象，很简单。想要获取哪个对象，直接在控制器方法的请求参数中写上该请求参数即可。如：<br> <img src="https://images2.imgbox.com/ce/ed/7KuDUPop_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="_425"></a>四、常用注解</h2> 
<h3><a id="41ResquestParam_426"></a>4.1、@ResquestParam</h3> 
<p>  以上的Demo我们发现一个问题，只要想要获取请求中的请求参数，直接在<code>contraller</code>里的方法加入参数即可映射获取。但是，要求方法中变量名必须和请求参数的key大小写一致，才能获取。现在我们可以使用<code>@ResquestParam</code>注解来解决这个问题。</p> 
<blockquote> 
 <p><mark>知识：</mark><code>@ResquestParam</code><br> 作用：把请求中指定名称的参数给控制器中的形参赋值。<br> 属性：<br>   <code>value/name</code>：请求参数中的名称。<br>   <code>required</code>：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。</p> 
</blockquote> 
<p>1、写一个请求：<br> <img src="https://images2.imgbox.com/b9/e4/am5gkoUN_o.png" alt="在这里插入图片描述"></p> 
<p>2、编写controller<br> <img src="https://images2.imgbox.com/42/e7/HzLrsArz_o.png" alt="在这里插入图片描述"><br> 由于<code>required</code>属性默认值是true，所以请求参数中必须有key为<mark>name</mark>这个参数，如果没有也会报错。</p> 
<h3><a id="42RequestBody_443"></a>4.2、@RequestBody</h3> 
<blockquote> 
 <p><mark>知识：</mark><code>@RequestBody</code><br> 作用：<br>   用于获取请求体内容。直接使用得到key=value&amp;key=value…结构的数据。 get请求方式不适用，因为get请求是将参拼接到url后面，没有请求体。<br> 属性：<br>   <code>required</code>：是否必须有请求体。默认值是:true。当取值为true时,get请求方式会报错。如果取值为false，get请求得到是null。</p> 
</blockquote> 
<p>1、写一个表单：<br> <img src="https://images2.imgbox.com/5f/af/vkOvpJnF_o.png" alt="在这里插入图片描述"><br> 2、写一个Controller：<br> <img src="https://images2.imgbox.com/59/63/oNIMZbfR_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="43RESTURL_455"></a>4.3、REST风格URL</h3> 
<blockquote> 
 <p><mark>什么是rest</mark>：<br>   <strong>REST</strong>（英文：<code>Representational State Transfer</code>，简称<strong>REST</strong>）描述了一个架构样式的网络系统，比如 web 应用程序。<code>一般称为RESTFUL，是一种编码风格，不是规范。不要求强行使用</code>。在目前主流的三种Web服务交互方案中，<code>REST</code>相比于<code>SOAP（Simple Object Access protocol，简单对象访问协议）</code>以及<code>XML-RPC</code>更加简单明了，无论是对URL的处理还是对Payload的编码，REST都倾向于用更加简单轻量的方法设计和实现。值得注意的是REST并没有一个明确的标准，而更像是一种设计的风格。<br>   它本身并没有什么实用性，其核心价值在于如何设计出符合REST风格的网络接口。<br> <mark>restful的优点</mark>：<br>   它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。<br> <mark>restful的特性：</mark><br> <code>资源（Resources）</code>：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的URI就可以，<strong>因此 URI 即为每一个资源的独一无二的识别符</strong>。<br> <code>表现层（Representation）</code>：把资源具体呈现出来的形式，叫做它的表现层 （Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。<br> <code>状态转化（State Transfer）</code>：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。具体说，就是 <strong>HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</strong>。<br> <mark>restful的示例</mark>：<br> /account/1   HTTP <code>GET</code>： 得到 id = 1 的 account<br> /account/1   HTTP <code>DELETE</code>： 删除 id = 1的 account<br> /account/1   HTTP <code>PUT</code>： 更新id = 1的 account<br> /account   HTTP <code>POST</code>： 新增 account</p> 
</blockquote> 
<p><mark>以前的风格</mark>：<code>通过一个URL来区别调用哪个方法</code>：</p> 
<blockquote> 
 <p>在<code>UserController</code>中：<br> @RequestMapping(path=“user/add”) //新增方法<br> public void save(){}</p> 
</blockquote> 
<blockquote> 
 <p>@RequestMapping(path=“user/update”) //修改方法<br> public void update(){}</p> 
</blockquote> 
<blockquote> 
 <p>@RequestMapping(path=“user/query”) //查询方法<br> public void findAll(){}</p> 
</blockquote> 
<blockquote> 
 <p>@RequestMapping(path=“user/queryByID”) //查询方法<br> public void findById(){}</p> 
</blockquote> 
<p><mark>restful的风格</mark>：<code>通过相同的URL和请求方式来区别调用哪个方法</code>：</p> 
<blockquote> 
 <p>在<code>UserController</code>中：<br> @RequestMapping(path="/user" ,method =<code>RequestMethod.GET</code>)<br> public void save(){}</p> 
</blockquote> 
<blockquote> 
 <p>@RequestMapping(path="/user",method =<code>RequestMethod.PUT</code>)<br> public void update(){}</p> 
</blockquote> 
<blockquote> 
 <p>@RequestMapping(<strong>path="/user"</strong> ,method =<code>RequestMethod.POST</code>)<br> public void findAll(){}</p> 
</blockquote> 
<blockquote> 
 <p>@RequestMapping(<strong>path="/user/{id}"</strong> ,method =<code>RequestMethod.POST</code>)<br> public void findById(int id){}</p> 
</blockquote> 
<hr> 
<h3><a id="44PathVaribale_500"></a>4.4、@PathVaribale</h3> 
<blockquote> 
 <p><mark>作用：</mark><br>   用于绑定url中的占位符。例如：请求url中 /delete/{id}，这个{id}就是url占位符。 url支持占位符是spring3.0之后加入的。<strong>是springmvc支持rest风格URL的一个重要标志。</strong><br> <mark>属性：</mark><br> <code>value</code>：用于指定url中占位符名称。<br> <code>required</code>：是否必须提供占位符。</p> 
</blockquote> 
<p>1、编写一个请求：<br> <img src="https://images2.imgbox.com/f9/88/CUW4lpxg_o.png" alt="在这里插入图片描述"></p> 
<p>2、编写一个controller：<br> <img src="https://images2.imgbox.com/d3/ab/Is80tl8z_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="45RequestHeader_513"></a>4.5、@RequestHeader</h3> 
<p><mark>注</mark>： 在实际开发中一般不怎么用。</p> 
<blockquote> 
 <p><mark>作用：</mark><br>   用于获取请求消息头信息。<br> <mark>属性：</mark><br>   <code>value</code>：提供消息头名称<br>   <code>required</code>：是否必须有此消息头<br> <img src="https://images2.imgbox.com/33/82/dPZB3kKc_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<hr> 
<h3><a id="46CookieValue_522"></a>4.6、@CookieValue</h3> 
<blockquote> 
 <p><mark>作用：</mark><br>   用于把指定cookie名称的值传入控制器方法参数。<br> 属性：<br>   <code>value</code>：指定cookie的名称。<br>   <code>required</code>：是否必须有此cookie。</p> 
</blockquote> 
<p>1、写一个请求<br> <img src="https://images2.imgbox.com/cb/1d/Oday0IXx_o.png" alt="在这里插入图片描述"></p> 
<p>2、获取Cookie的值：<br> <img src="https://images2.imgbox.com/80/17/KQzwEHLV_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="47ModelAttribute_535"></a>4.7、@ModelAttribute</h3> 
<blockquote> 
 <p><mark>作用：</mark><br>   该注解是SpringMVC4.3版本以后新加入的。它可以用于修饰方法和参数。<br>   （1）出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。<br>   （2）出现在参数上，获取指定的数据给参数赋值。<br> <mark>属性</mark>：<br>   value：用于获取数据的key。key可以是POJO的属性名称，也可以是map结构的key。<br> <mark>应用场景</mark>：<br>   当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。<br> 例如：<br>   我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为null，此时就可以使用此注解解决问题。</p> 
</blockquote> 
<p>1、写一个表单：<br> <img src="https://images2.imgbox.com/cc/dd/Omav9Ssi_o.png" alt="在这里插入图片描述"></p> 
<p>2、<code>@ModelAttribute</code>作用在方法头上：<br> <img src="https://images2.imgbox.com/dd/e0/ZjBtLAgG_o.png" alt="在这里插入图片描述"></p> 
<p>当然，也可以这样：<br> <img src="https://images2.imgbox.com/60/90/f9pFo6M5_o.png" alt="在这里插入图片描述"></p> 
<p>3、<code>@ModelAttribute</code>作用在变量上：<br> <img src="https://images2.imgbox.com/dc/52/f5iyP68F_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="48SessionAttribute_560"></a>4.8、@SessionAttribute</h3> 
<p>多用于方法之间的参数共享。</p> 
<blockquote> 
 <p><mark>作用</mark>：<br>   用于多次执行控制器<code>方法间的参数共享</code>。<br> <mark>属性</mark>：<br> <code>value</code>：用于指定存入的属性名称<br> <code>type</code>：用于指定存入的数据类型。<br> <mark>使用例子</mark>：(该例子位于控制器头，用于保存session信息)<br> <code>@SessionAttributes(value ={"username","password"},types={Integer.class})</code></p> 
</blockquote> 
<p>1、请求：<br> <img src="https://images2.imgbox.com/c3/35/e2e4R0Nz_o.png" alt="在这里插入图片描述"><br> 2、控制器：<br> <img src="https://images2.imgbox.com/b6/d8/MfVIdB3p_o.png" alt="在这里插入图片描述"><br> 3、将值也存入session域中：<br> <img src="https://images2.imgbox.com/db/3b/v8gEiKH5_o.png" alt="在这里插入图片描述"></p> 
<p>4、跳转页面取域中值：<br> <img src="https://images2.imgbox.com/b3/15/kwsoALP7_o.png" alt="在这里插入图片描述"><br> 5、启动服务测试。</p> 
<p>6、从session中取值和session中删值：<br> <img src="https://images2.imgbox.com/4d/73/b6LsmOEz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ba/88/sB1XCWOE_o.png" alt="在这里插入图片描述"><br> 再次启动服务，测试即可。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/48f0a51c6add8bc001a10967903bb664/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode Task28. 跳跃游戏</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a12b2a738edc0a30cc6c93343a116de4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">通信系统的带宽和频率分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>