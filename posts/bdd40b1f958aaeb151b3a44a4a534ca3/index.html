<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity 0GC或者最大限度降低GC方案 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity 0GC或者最大限度降低GC方案" />
<meta property="og:description" content="文章目录 GC带来的问题性能瓶颈玩家体验受损 优化关键点1. **对象池技术**：2. **内存管理优化**：3. **UGUI优化**：4. **ECS架构下的优化**：5. **资源管理**：6. **自定义数据结构与算法**：7. **开启增量GC（Incremental GC）**：8. **代码审查与性能分析**：9. **重用组件与MonoBehaviour实例**：10. **静态化与缓存**：11. **资源预加载**：12. **避免大型集合的操作**：13. **使用StructLayout.Pack / StructLayout.Explicit**：14. **弱引用与事件处理**：15. **自定义内存管理**： Unity中垃圾回收（GC）频繁发生，会给游戏带来以下显著问题： GC带来的问题 性能瓶颈 GC暂停主线程执行：当.NET的垃圾回收器开始工作时，它会暂时挂起所有程序执行以进行内存清理和整理。这意味着游戏逻辑、物理计算、渲染等都会被迫暂停，这会导致帧率下降或卡顿，影响游戏流畅度。
帧时间不一致：
由于GC的发生不可预知，其带来的延迟可能导致每一帧的时间长度不稳定，这对于实时交互的游戏体验尤其不利，特别是在需要保持稳定刷新率（如60fps）的场景。
玩家体验受损 突然的卡顿会影响玩家沉浸感，并可能导致在关键的游戏时刻出现响应延迟，比如战斗中的操作反馈或者复杂场景加载时的视觉表现。
资源浪费：
频繁的内存分配与回收也会增加系统的内存管理开销，导致整体系统效率降低，可能消耗更多的CPU周期和其他系统资源。
潜在的内存泄漏：
如果因为编程习惯不良而导致大量短生命周期对象不断产生并触发GC，则可能存在未被正确释放的内存，久而久之可能会引发内存泄漏，使得可用内存逐渐减少，最终导致游戏崩溃或其他严重问题。
因此，在Unity开发中，开发者需要密切关注代码设计，采用合适的数据结构、内存管理和对象池技术来最小化临时对象的创建和销毁，从而最大限度地减少对GC的依赖。
在Unity中实现0GC（零垃圾回收）的目标，主要是为了避免频繁触发.NET的垃圾回收机制，因为垃圾回收会导致短暂的帧率下降和性能波动。
优化关键点 1. 对象池技术： 对于生命周期短但创建销毁频繁的对象，如子弹、特效等，可以使用对象池来复用这些对象而不是每次需要时都创建新的实例。 2. 内存管理优化： 避免临时字符串或数组的频繁拼接，可使用预分配缓冲区或者专门设计用于无GC操作的字符串库（例如zstring或OneString）。长期使用的数据结构尽可能预先分配足够的空间，并避免动态扩容导致的内存碎片和GC压力。 3. UGUI优化： 在Unity UGUI开发中，确保对UI组件进行适当的缓存和重用，减少动态创建和销毁GameObject的行为。使用容器组件（比如CanvasScaler, LayoutGroup）时注意它们可能引发的不必要的布局计算和重建，采用UpdatePanelZeroAlloc这样的工具或方法来避免更新视图过程中的临时对象生成。 4. ECS架构下的优化： 使用Entity Component System (ECS) 架构，如Unity DOTS，通过实体和组件的集合式处理来降低GC负担。在ECS框架下，避免使用托管引用类型作为组件内容，转而使用值类型或结构体以保持堆栈分配。 5. 资源管理： 合理加载和卸载资源，利用AssetBundle和对象池策略减少运行时资源加载带来的内存分配。尽量避免大量小型纹理合并为 atlases 或使用Texture Atlas来减少内存碎片和GC调用。 6. 自定义数据结构与算法： 有时需要设计特定的数据结构和算法，使得它们在执行过程中不产生中间临时对象，从而避免GC。 7. 开启增量GC（Incremental GC）： Unity引擎支持开启增量GC模式，在某些情况下可以将垃圾回收的工作分散到多个帧上，减轻单次回收带来的卡顿感。 8. 代码审查与性能分析： 使用Unity Profiler或其他性能分析工具追踪内存分配情况，定位并修复内存泄漏问题以及不必要的内存分配来源。 总之，实现0GC是一个持续性的性能优化过程，需要结合具体项目情况进行细致的设计和调整。同时，虽然追求0GC是提升性能的一个手段，但在实际开发中往往难以完全避免GC，关键是合理管理和控制GC的影响范围及频率。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bdd40b1f958aaeb151b3a44a4a534ca3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T12:54:39+08:00" />
<meta property="article:modified_time" content="2024-01-05T12:54:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity 0GC或者最大限度降低GC方案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#GC_3" rel="nofollow">GC带来的问题</a></li><li><ul><li><a href="#_4" rel="nofollow">性能瓶颈</a></li><li><a href="#_10" rel="nofollow">玩家体验受损</a></li></ul> 
  </li><li><a href="#_21" rel="nofollow">优化关键点</a></li><li><ul><li><a href="#1__23" rel="nofollow">1. **对象池技术**：</a></li><li><a href="#2__27" rel="nofollow">2. **内存管理优化**：</a></li><li><a href="#3_UGUI_32" rel="nofollow">3. **UGUI优化**：</a></li><li><a href="#4_ECS_37" rel="nofollow">4. **ECS架构下的优化**：</a></li><li><a href="#5__42" rel="nofollow">5. **资源管理**：</a></li><li><a href="#6__47" rel="nofollow">6. **自定义数据结构与算法**：</a></li><li><a href="#7_GCIncremental_GC_51" rel="nofollow">7. **开启增量GC（Incremental GC）**：</a></li><li><a href="#8__55" rel="nofollow">8. **代码审查与性能分析**：</a></li><li><a href="#9_MonoBehaviour_61" rel="nofollow">9. **重用组件与MonoBehaviour实例**：</a></li><li><a href="#10__66" rel="nofollow">10. **静态化与缓存**：</a></li><li><a href="#11__70" rel="nofollow">11. **资源预加载**：</a></li><li><a href="#12__74" rel="nofollow">12. **避免大型集合的操作**：</a></li><li><a href="#13_StructLayoutPack__StructLayoutExplicit_78" rel="nofollow">13. **使用StructLayout.Pack / StructLayout.Explicit**：</a></li><li><a href="#14__82" rel="nofollow">14. **弱引用与事件处理**：</a></li><li><a href="#15__86" rel="nofollow">15. **自定义内存管理**：</a></li></ul> 
 </li></ul> 
</div> 
<br> Unity中垃圾回收（GC）频繁发生，会给游戏带来以下显著问题： 
<p></p> 
<h2><a id="GC_3"></a>GC带来的问题</h2> 
<h3><a id="_4"></a>性能瓶颈</h3> 
<p>GC暂停主线程执行：当.NET的垃圾回收器开始工作时，它会暂时挂起所有程序执行以进行内存清理和整理。这意味着游戏逻辑、物理计算、渲染等都会被迫暂停，这会导致帧率下降或卡顿，影响游戏流畅度。<br> 帧时间不一致：<br> 由于GC的发生不可预知，其带来的延迟可能导致每一帧的时间长度不稳定，这对于实时交互的游戏体验尤其不利，特别是在需要保持稳定刷新率（如60fps）的场景。</p> 
<h3><a id="_10"></a>玩家体验受损</h3> 
<p>突然的卡顿会影响玩家沉浸感，并可能导致在关键的游戏时刻出现响应延迟，比如战斗中的操作反馈或者复杂场景加载时的视觉表现。<br> 资源浪费：<br> 频繁的内存分配与回收也会增加系统的内存管理开销，导致整体系统效率降低，可能消耗更多的CPU周期和其他系统资源。<br> 潜在的内存泄漏：<br> 如果因为编程习惯不良而导致大量短生命周期对象不断产生并触发GC，则可能存在未被正确释放的内存，久而久之可能会引发内存泄漏，使得可用内存逐渐减少，最终导致游戏崩溃或其他严重问题。<br> 因此，在Unity开发中，开发者需要密切关注代码设计，采用合适的数据结构、内存管理和对象池技术来最小化临时对象的创建和销毁，从而最大限度地减少对GC的依赖。</p> 
<p>在Unity中实现0GC（零垃圾回收）的目标，主要是为了避免频繁触发.NET的垃圾回收机制，因为垃圾回收会导致短暂的帧率下降和性能波动。</p> 
<h2><a id="_21"></a>优化关键点</h2> 
<h3><a id="1__23"></a>1. <strong>对象池技术</strong>：</h3> 
<ul><li>对于生命周期短但创建销毁频繁的对象，如子弹、特效等，可以使用对象池来复用这些对象而不是每次需要时都创建新的实例。</li></ul> 
<h3><a id="2__27"></a>2. <strong>内存管理优化</strong>：</h3> 
<ul><li>避免临时字符串或数组的频繁拼接，可使用预分配缓冲区或者专门设计用于无GC操作的字符串库（例如zstring或OneString）。</li><li>长期使用的数据结构尽可能预先分配足够的空间，并避免动态扩容导致的内存碎片和GC压力。</li></ul> 
<h3><a id="3_UGUI_32"></a>3. <strong>UGUI优化</strong>：</h3> 
<ul><li>在Unity UGUI开发中，确保对UI组件进行适当的缓存和重用，减少动态创建和销毁GameObject的行为。</li><li>使用容器组件（比如CanvasScaler, LayoutGroup）时注意它们可能引发的不必要的布局计算和重建，采用UpdatePanelZeroAlloc这样的工具或方法来避免更新视图过程中的临时对象生成。</li></ul> 
<h3><a id="4_ECS_37"></a>4. <strong>ECS架构下的优化</strong>：</h3> 
<ul><li>使用Entity Component System (ECS) 架构，如Unity DOTS，通过实体和组件的集合式处理来降低GC负担。</li><li>在ECS框架下，避免使用托管引用类型作为组件内容，转而使用值类型或结构体以保持堆栈分配。</li></ul> 
<h3><a id="5__42"></a>5. <strong>资源管理</strong>：</h3> 
<ul><li>合理加载和卸载资源，利用AssetBundle和对象池策略减少运行时资源加载带来的内存分配。</li><li>尽量避免大量小型纹理合并为 atlases 或使用Texture Atlas来减少内存碎片和GC调用。</li></ul> 
<h3><a id="6__47"></a>6. <strong>自定义数据结构与算法</strong>：</h3> 
<ul><li>有时需要设计特定的数据结构和算法，使得它们在执行过程中不产生中间临时对象，从而避免GC。</li></ul> 
<h3><a id="7_GCIncremental_GC_51"></a>7. <strong>开启增量GC（Incremental GC）</strong>：</h3> 
<ul><li>Unity引擎支持开启增量GC模式，在某些情况下可以将垃圾回收的工作分散到多个帧上，减轻单次回收带来的卡顿感。</li></ul> 
<h3><a id="8__55"></a>8. <strong>代码审查与性能分析</strong>：</h3> 
<ul><li>使用Unity Profiler或其他性能分析工具追踪内存分配情况，定位并修复内存泄漏问题以及不必要的内存分配来源。</li></ul> 
<p>总之，实现0GC是一个持续性的性能优化过程，需要结合具体项目情况进行细致的设计和调整。同时，虽然追求0GC是提升性能的一个手段，但在实际开发中往往难以完全避免GC，关键是合理管理和控制GC的影响范围及频率。</p> 
<h3><a id="9_MonoBehaviour_61"></a>9. <strong>重用组件与MonoBehaviour实例</strong>：</h3> 
<ul><li>尽量复用MonoBehaviour脚本实例，避免在Update或FixedUpdate等频繁调用的方法内创建新对象。</li><li>对于需要动态添加行为到游戏对象上的场景，可以考虑使用单例模式或者事件驱动机制代替临时对象。</li></ul> 
<h3><a id="10__66"></a>10. <strong>静态化与缓存</strong>：</h3> 
<pre><code>- 静态变量和全局缓存可以用于存储那些在整个游戏生命周期内都不会改变或只需创建一次的对象或数据结构。
</code></pre> 
<h3><a id="11__70"></a>11. <strong>资源预加载</strong>：</h3> 
<pre><code>- 在游戏启动阶段预先加载所有必要的资源，并保持它们在内存中，而不是等到运行时再根据需求加载，这样可以减少因加载资源产生的临时对象。
</code></pre> 
<h3><a id="12__74"></a>12. <strong>避免大型集合的操作</strong>：</h3> 
<pre><code>- 大型列表、数组或字典的添加、删除操作可能引发内部数组的重新分配。对于经常变动的数据集，可以采用合适的数据结构（如链表）或手动管理其容量来控制GC压力。
</code></pre> 
<h3><a id="13_StructLayoutPack__StructLayoutExplicit_78"></a>13. <strong>使用StructLayout.Pack / StructLayout.Explicit</strong>：</h3> 
<pre><code>- 当使用结构体表示连续内存块时，可以利用`System.Runtime.InteropServices.StructLayoutAttribute`特性进行内存布局优化，确保没有空隙以防止GC对小对象池的影响。
</code></pre> 
<h3><a id="14__82"></a>14. <strong>弱引用与事件处理</strong>：</h3> 
<pre><code>- 使用弱引用来监听事件可以减少由于强引用导致的对象无法被垃圾回收的问题。但要注意过度依赖弱引用可能导致逻辑复杂度增加，应在必要时谨慎使用。
</code></pre> 
<h3><a id="15__86"></a>15. <strong>自定义内存管理</strong>：</h3> 
<pre><code>- 在极少数情况下，为了达到极致性能，可能需要通过unsafe代码或接口直接操作非托管内存，但这将极大地增加开发复杂性，且需具备深厚底层知识。
</code></pre> 
<p>最后，请务必注意，尽管追求0GC有助于提升性能，但在实际项目中应权衡优化成本与收益，遵循“先做正确的事，再做快的事”的原则。同时，也要考虑到GC是.NET生态的重要组成部分，适当的GC工作对长期运行的程序是有益的，一味追求零GC并不总是最优解决方案。</p> 
<p>python学习汇总连接：<br> <a href="https://blog.csdn.net/qqrrjj2011/article/details/135201319">50个开发必备的Python经典脚本(1-10)</a></p> 
<p><a href="https://blog.csdn.net/qqrrjj2011/article/details/135220796">50个开发必备的Python经典脚本(11-20)</a></p> 
<p><a href="https://blog.csdn.net/qqrrjj2011/article/details/135220906">50个开发必备的Python经典脚本(21-30)</a></p> 
<p><a href="https://blog.csdn.net/qqrrjj2011/article/details/135222295">50个开发必备的Python经典脚本(31-40)</a></p> 
<p><a href="https://blog.csdn.net/qqrrjj2011/article/details/135222681">50个开发必备的Python经典脚本(41-50)</a><br> ————————————————</p> 
<p>​最后我们放松一下眼睛<br> <img src="https://images2.imgbox.com/0e/d0/qerEQoHk_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab35777e2633543b280dfb47dc502a1d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">聊一聊 C# 线程切换后上下文都去了哪里</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/615c4ea57b00cbba01733972af611807/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HPE惠普巡检工具OneView试玩</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>