<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GAN生成对抗网络入门理解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GAN生成对抗网络入门理解" />
<meta property="og:description" content="有兴趣阅读GAN鼻祖之作的给出链接： 2014年NIPS Generative Adversarial Net
原理解释 GAN核心思想：生成器G与判别器D，双方博弈。
生成器G的输入是手工样本/噪声/随机数之类，通过模型学习（包装）成一个逼真的样本进行输出。这里所谓逼真指的是逼近真实的样本。目的：使得自己造样本的能力尽可能强，强到什么程度呢，你判别网络没法判断我是真样本还是假样本。判别器D的输入是生成器的输出，二分类模型判断该输入是否是真实样本。目的：判别出来属于的一张图来自真实样本集还是假样本集。假如输入的是真样本，网络输出就接近1，输入的是假样本，网络输出接近0，达到完美状态。博弈过程：生成网络与判别网络的目的正好是相反的，一个说我能判别的好，一个说我让你判别不好。判别网络说，我很强，来一个样本我就知道它是来自真样本集还是假样本集。生成网络就不服了，说我也很强，我生成一个假样本，虽然我生成网络知道是假的，但是你判别网络不知道呀，我包装的非常逼真，以至于判别网络无法判断真假，那么用输出数值来解释就是，生成网络生成的假样本进去了判别网络以后，判别网络给出的结果是一个接近0.5的值，极限情况就是0.5，也就是说判别不出来了。 模型实现 扯完皮了，下面看一下怎么样训练模型。
生成模型与对抗模型可以说是完全独立的两个模型，好比就是完全独立的两个神经网络模型，他们之间没有什么联系。那么训练这样的两个模型的大方法就是：单独交替迭代训练。
下图给出模型示意，红线以上是判别模型，红线以下是生成模型&#43;判别模型。
第一步：（训练判别模型）
初始化生成模型，输入一堆随机数组，得到一堆假的样本集，而真样本集默认给定。制定标签：真样本集所有的类标签都为1，而假样本集的所有类标签都为0。单就判别网络来说，此时问题就变成了一个再简单不过的有监督的二分类问题了，直接送到神经网络模型中训练就完事了。这样我们就得到了具备一定判别能力的判别模型。
第二步：（训练生成模型）
生成网络的训练其实是对生成-判别网络串接的训练，就像上图中显示的那样。输入噪声数组Z，通过生成模型生成了假样本，此时很关键的一点来了，既然我们已经有了初具判断能力的判别模型，我们固定判别模型参数，将这些假样本的标签都设置为1，使得生成模型向着真样本分布去拟合。
好了，重新顺一下思路，现在对于生成网络的训练，我们有了样本集（只有假样本集，没有真样本集），有了对应的label（全为1），是不是就可以训练了？有人会问，这样只有一类样本，训练啥呀？谁说一类样本就不能训练了？只要有误差就行。还有人说，你这样一训练，判别网络的网络参数不是也跟着变吗？没错，这很关键，所以在训练这个串接的网络的时候，一个很重要的操作就是不要判别网络的参数发生变化，也就是不让它参数发生更新，只是把误差一直传，传到生成网络那块后更新生成网络的参数。这样就完成了生成网络的训练了。
重复上述两步：
完成第二步后，可以根据目前新的生成网络再对先前的那些噪声Z生成新的假样本，并且训练后的假样本应该是更真了才对。这样又可以重复上述过程了。我们把这个过程称作为单独交替训练。我们可以实现定义一个迭代次数，交替迭代到一定次数后停止即可。这个时候我们再去看一看噪声Z生成的假样本会发现，原来它已经很真了。
目标公式 max过程固定G生成模型优化D判别模型，min过程反之。
优势 GAN强大之处在于可以自动的学习原始真实样本集的数据分布（生成模型）；
GAN强大之处在于可以自动的定义潜在损失函数。（判别模型）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/48d8ec96bb6ec6477f6c474198e9d8f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-17T21:23:20+08:00" />
<meta property="article:modified_time" content="2020-07-17T21:23:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GAN生成对抗网络入门理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>有兴趣阅读GAN鼻祖之作的给出链接：  2014年NIPS <a href="https://arxiv.org/abs/1406.2661" rel="nofollow">Generative Adversarial Net</a></p> 
<h4>原理解释</h4> 
<p>GAN核心思想：生成器G与判别器D，双方博弈。</p> 
<ul><li>生成器G的输入是手工样本/噪声/随机数之类，通过模型学习（包装）成一个逼真的样本进行输出。这里所谓逼真指的是逼近真实的样本。目的：使得自己造样本的能力尽可能强，强到什么程度呢，你判别网络没法判断我是真样本还是假样本。</li><li>判别器D的输入是生成器的输出，二分类模型判断该输入是否是真实样本。目的：判别出来属于的一张图来自真实样本集还是假样本集。假如输入的是真样本，网络输出就接近1，输入的是假样本，网络输出接近0，达到完美状态。</li><li>博弈过程：生成网络与判别网络的目的正好是相反的，一个说我能判别的好，一个说我让你判别不好。判别网络说，我很强，来一个样本我就知道它是来自真样本集还是假样本集。生成网络就不服了，说我也很强，我生成一个假样本，虽然我生成网络知道是假的，但是你判别网络不知道呀，我包装的非常逼真，以至于判别网络无法判断真假，那么用输出数值来解释就是，生成网络生成的假样本进去了判别网络以后，判别网络给出的结果是一个接近0.5的值，极限情况就是0.5，也就是说判别不出来了。</li></ul> 
<h4>模型实现</h4> 
<p>扯完皮了，下面看一下怎么样训练模型。</p> 
<p>生成模型与对抗模型可以说是完全独立的两个模型，好比就是完全独立的两个神经网络模型，他们之间没有什么联系。那么训练这样的两个模型的大方法就是：<strong>单独交替迭代训练。</strong></p> 
<p>下图给出模型示意，红线以上是判别模型，红线以下是生成模型+判别模型。</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/c8/6d/fg0wqjJl_o.png" width="545"></p> 
<p>第一步：（训练判别模型）</p> 
<p>初始化生成模型，输入一堆随机数组，得到一堆假的样本集，而真样本集默认给定。制定标签：真样本集所有的类标签都为1，而假样本集的所有类标签都为0。单就判别网络来说，此时问题就变成了一个再简单不过的<strong>有监督的二分类问题</strong>了，直接送到神经网络模型中训练就完事了。这样我们就得到了具备一定判别能力的判别模型。</p> 
<p>第二步：（训练生成模型）</p> 
<p>生成网络的训练其实是对生成-判别网络串接的训练，就像上图中显示的那样。输入噪声数组Z，通过生成模型生成了假样本，此时很关键的一点来了，既然我们已经有了初具判断能力的判别模型，我们固定判别模型参数，将<strong>这些假样本的标签都设置为1</strong>，使得生成模型向着真样本分布去拟合。</p> 
<p>好了，重新顺一下思路，现在对于生成网络的训练，我们有了样本集（只有假样本集，没有真样本集），有了对应的label（全为1），是不是就可以训练了？有人会问，这样只有一类样本，训练啥呀？谁说一类样本就不能训练了？只要有误差就行。还有人说，你这样一训练，<strong>判别网络的网络参数不是也跟着变吗</strong>？没错，这很关键，所以在训练这个串接的网络的时候，一个很重要的操作就是<strong>不要判别网络的参数发生变化</strong>，也就是不让它参数发生更新，只是把误差一直传，传到生成网络那块后更新生成网络的参数。这样就完成了生成网络的训练了。</p> 
<p>重复上述两步：</p> 
<p>完成第二步后，可以根据目前新的生成网络再对先前的那些噪声Z生成新的假样本，并且训练后的假样本应该是更真了才对。这样又可以重复上述过程了。我们把这个过程称作为单独交替训练。我们可以实现定义一个迭代次数，交替迭代到一定次数后停止即可。这个时候我们再去看一看噪声Z生成的假样本会发现，原来它已经很真了。</p> 
<h4>目标公式</h4> 
<p><img alt="" height="75" src="https://images2.imgbox.com/7a/50/m9Ne1vcU_o.png" width="740"></p> 
<p>max过程固定G生成模型优化D判别模型，min过程反之。</p> 
<h4>优势</h4> 
<p><strong>GAN强大之处在于可以自动的学习原始真实样本集的数据分布（生成模型）；</strong></p> 
<p><strong>GAN强大之处在于可以自动的定义潜在损失函数。（判别模型）</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94a48492aa111ce4f2cc061eef59fd3d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软件制造工程学习笔记(详尽版)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0771905faa45452423668ff1561254d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VBA获取汉字拼音首字母的函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>