<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之(六)代理模式Proxy - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式之(六)代理模式Proxy" />
<meta property="og:description" content="理解并使用设计模式,能够培养我们良好的面向对象编程习惯,同时在实际应用中,可以如鱼
得水,享受游刃有余的乐趣.
Proxy 是比较有用途的一种模式,而且变种较多,应用场合覆盖从小结构到整个系统的大结 构,Proxy 是代理的意思,我们也许有代理服务器等概念,代理概念可以解释为:在出发点到 目的地之间有一道中间层,意为代理. 设计模式中定义: 为其他对象提供一种代理以控制对这个对象的访问. 为什么要使用Proxy? 1.授权机制 不同级别的用户对同一对象拥有不同的访问权利,如Jive 论坛系统中,就使用 Proxy 进行授权机制控制,访问论坛有两种人:注册用户和游客(未注册用户),Jive 中就通过 类似ForumProxy 这样的代理来控制这两种用户对论坛的访问权限. 2.某个客户端不能直接操作到某个对象,但又必须和那个对象有所互动. 举例两个具体情况: (1)如果那个对象是一个是很大的图片,需要花费很长时间才能显示出来,那么当这个图片包 含在文档中时,使用编辑器或浏览器打开这个文档,打开文档必须很迅速,不能等待大图片处 理完成,这时需要做个图片Proxy 来代替真正的图片. (2)如果那个对象在Internet 的某个远端服务器上,直接操作这个对象因为网络速度原因可 能比较慢,那我们可以先用Proxy 来代替那个对象. 总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝 贵的Java 内存. 所以,有些人认为Java 耗费资源内存,我以为这和程序编制思路也有一定的 关系. 比如:我们有一个很大的Collection,具体如hashtable,有很多客户端会并发同时访问它. 其中一个特别的客户端要进行连续的数据获取,此时要求其他客户端不能再向hashtable 中 增加或删除 东东. 最直接的解决方案是:使用collection 的lock,让这特别的客户端获得这个lock,进行连续 的数据获取,然后再释放lock. public void foFetches(Hashtable ht){ synchronized(ht){ //具体的连续数据获取动作.. } } 但是这一办法可能锁住Collection 会很长时间,这段时间,其他客户端就不能访问该 Collection 了. 第二个解决方案是clone 这个Collection,然后让连续的数据获取针对clone 出来的那个 Collection 操作.这个方案前提是,这个Collection 是可clone 的,而且必须有提供深度 clone 的方法.Hashtable 就提供了对自己的clone 方法,但不是Key 和value 对象的clone, 关于Clone 含义可以参考专门文章. public void foFetches(Hashtable ht){ Hashttable newht=(Hashtable)ht." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0c6bea7c29648bd22969b7c9c6df7a24/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T03:59:17+08:00" />
<meta property="article:modified_time" content="2019-07-05T03:59:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之(六)代理模式Proxy</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>理解并使用设计模式,能够培养我们良好的面向对象编程习惯,同时在实际应用中,可以如鱼</p> 
 <p>得水,享受游刃有余的乐趣.</p> Proxy 是比较有用途的一种模式,而且变种较多,应用场合覆盖从小结构到整个系统的大结 
 <br> 构,Proxy 是代理的意思,我们也许有代理服务器等概念,代理概念可以解释为:在出发点到 
 <br> 目的地之间有一道中间层,意为代理. 
 <br> 设计模式中定义: 为其他对象提供一种代理以控制对这个对象的访问. 
 <br> 为什么要使用Proxy? 
 <br> 1.授权机制 不同级别的用户对同一对象拥有不同的访问权利,如Jive 论坛系统中,就使用 
 <br> Proxy 进行授权机制控制,访问论坛有两种人:注册用户和游客(未注册用户),Jive 中就通过 
 <br> 类似ForumProxy 这样的代理来控制这两种用户对论坛的访问权限. 
 <br> 2.某个客户端不能直接操作到某个对象,但又必须和那个对象有所互动. 
 <br> 举例两个具体情况: 
 <br> (1)如果那个对象是一个是很大的图片,需要花费很长时间才能显示出来,那么当这个图片包 
 <br> 含在文档中时,使用编辑器或浏览器打开这个文档,打开文档必须很迅速,不能等待大图片处 
 <br> 理完成,这时需要做个图片Proxy 来代替真正的图片. 
 <br> (2)如果那个对象在Internet 的某个远端服务器上,直接操作这个对象因为网络速度原因可 
 <br> 能比较慢,那我们可以先用Proxy 来代替那个对象. 
 <br> 总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝 
 <br> 贵的Java 内存. 所以,有些人认为Java 耗费资源内存,我以为这和程序编制思路也有一定的 
 <br> 关系. 
 <br> 比如:我们有一个很大的Collection,具体如hashtable,有很多客户端会并发同时访问它. 
 <br> 其中一个特别的客户端要进行连续的数据获取,此时要求其他客户端不能再向hashtable 中 
 <br> 增加或删除 东东. 
 <br> 最直接的解决方案是:使用collection 的lock,让这特别的客户端获得这个lock,进行连续 
 <br> 的数据获取,然后再释放lock. 
 <br> public void foFetches(Hashtable ht){ 
 <br> synchronized(ht){ 
 <br> //具体的连续数据获取动作.. 
 <br> } 
 <br> } 
 <br> 但是这一办法可能锁住Collection 会很长时间,这段时间,其他客户端就不能访问该 
 <br> Collection 了. 
 <br> 第二个解决方案是clone 这个Collection,然后让连续的数据获取针对clone 出来的那个 
 <br> Collection 操作.这个方案前提是,这个Collection 是可clone 的,而且必须有提供深度 
 <br> clone 的方法.Hashtable 就提供了对自己的clone 方法,但不是Key 和value 对象的clone, 
 <br> 关于Clone 含义可以参考专门文章. 
 <br> public void foFetches(Hashtable ht){ 
 <br> Hashttable newht=(Hashtable)ht.clone(); 
 <br> } 
 <br> 问题又来了,由于是针对clone 出来的对象操作,如果原来的母体被其他客户端操作修改了, 
 <br> 那么对clone 出来的对象操作就没有意义了. 
 <br> 最后解决方案:我们可以等其他客户端修改完成后再进行clone,也就是说,这个特别的客户 
 <br> 端先通过调用一个叫clone 的方法来进行一系列数据获取操作.但实际上没有真正的进行对 
 <br> 象拷贝,直至有其他客户端修改了这个对象Collection. 
 <br> 使用Proxy 实现这个方案.这就是copy-on-write 操作. 
 <br> Proxy 应用范围很广,现在流行的分布计算方式RMI 和Corba 等都是Proxy 模式的应用. 
 <br> 
</div> 
<p>转载于:https://www.cnblogs.com/moiyer/archive/2011/08/04/2316185.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25c3b531fd5b8873206e6a5ffc57c2fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SSIS包定时执行</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/023b889475277b613bc3fe3ec12e2400/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android  onContextItemSelected和onMenuItemSelected厉害关系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>