<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[C&#43;&#43;] 一篇带你搞懂引用（&amp;）-- C&#43;&#43;入门（3） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[C&#43;&#43;] 一篇带你搞懂引用（&amp;）-- C&#43;&#43;入门（3）" />
<meta property="og:description" content="问题引入
在我们日常的生活中每个人都或多或少存在一个&#34;外号&#34;，例如《西游记》中孙悟空就有诸多外号：美猴王，孙行者，齐天大圣等等。那么在C&#43;&#43;中，也可以给一个已经存在的变量取别名，这就是引用。
那么接下来深入来探讨一下引用
目录
1.引用的概念
1.1引用的表示方法
1.2引用特性
1.3常引用 引用权限
1.4引用的使用场景
1.4.1做参数
1.4.2做返回值 传值的底层过程：
引用导致野指针：
1.5值和引用作为返回值类型的性能比较
1.6引用和指针的区别
1.引用的概念 引用 不是新定义一个变量，而 是给已存在变量取了一个别名 ，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。 1.1引用的表示方法 类型 &amp; 引用变量名 ( 对象名 ) = 引用实体； 如果熟悉C语言的同学可能会发现引用符号(&amp;)看上去就像取地址运算符(&amp;)或者按位AND运算符(&amp;)，其实这是一个运算符重载的例子。通过重载，同一个运算符将会有不同的含义。编译器会通过上下文来确定运算符的含义。除了这里所提到的，其实在C&#43;&#43;中还有一些运算符重载的情况。例如：* 即表示乘法，又表示对指针的解引用操作；&lt;&lt;即表示插入运算符，又表示按位左移运算符等。
代码实例：
int main() { //引用：取别名 int a = 10; int&amp; b = a;//定义引用类型 int&amp; c = b; return 0; } 本段代码我们可以得知，a变量取了b，c两个别名。
我们也可以通过调试观察他们的内存：
通过调取内存我们可以发现，a,b,c所指向的是同一块内存空间。
注意： 引用类型 必须和引用 实体 是 同种类型 的 1.2引用特性 引用有三个特性，分别是：
1. 引用在 定义时必须初始化 2. 一个变量可以有多个引用 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2908c48dd8bbbfc022023fd5cc3cc8a6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-10T19:07:48+08:00" />
<meta property="article:modified_time" content="2022-05-10T19:07:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[C&#43;&#43;] 一篇带你搞懂引用（&amp;）-- C&#43;&#43;入门（3）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><strong>问题引入</strong></p> 
<blockquote> 
 <p>在我们日常的生活中每个人都或多或少存在一个"外号"，例如《西游记》中孙悟空就有诸多外号：美猴王，孙行者，齐天大圣等等。那么在C++中，也可以给一个已经存在的变量取别名，这就是引用。</p> 
</blockquote> 
<p>那么接下来深入来探讨一下引用</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#1.%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1.引用的概念</a></p> 
<p id="1.1%E5%BC%95%E7%94%A8%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#1.1%E5%BC%95%E7%94%A8%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95" rel="nofollow">1.1引用的表示方法</a></p> 
<p id="1.2%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#1.2%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7" rel="nofollow">1.2引用特性</a></p> 
<p id="1.3%E5%B8%B8%E5%BC%95%E7%94%A8%C2%A0%20%E5%BC%95%E7%94%A8%E6%9D%83%E9%99%90-toc" style="margin-left:40px;"><a href="#1.3%E5%B8%B8%E5%BC%95%E7%94%A8%C2%A0%20%E5%BC%95%E7%94%A8%E6%9D%83%E9%99%90" rel="nofollow">1.3常引用  引用权限</a></p> 
<p id="1.4%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#1.4%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">1.4引用的使用场景</a></p> 
<p id="1.4.1%E5%81%9A%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.4.1%E5%81%9A%E5%8F%82%E6%95%B0" rel="nofollow">1.4.1做参数</a></p> 
<p id="1.4.2%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC%C2%A0-toc" style="margin-left:80px;"><a href="#1.4.2%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC%C2%A0" rel="nofollow">1.4.2做返回值 </a></p> 
<p id="%E4%BC%A0%E5%80%BC%E7%9A%84%E5%BA%95%E5%B1%82%E8%BF%87%E7%A8%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BC%A0%E5%80%BC%E7%9A%84%E5%BA%95%E5%B1%82%E8%BF%87%E7%A8%8B%EF%BC%9A" rel="nofollow">传值的底层过程：</a></p> 
<p id="%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%9A" rel="nofollow">引用导致野指针：</a></p> 
<p id="1.5%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#1.5%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83" rel="nofollow">1.5值和引用作为返回值类型的性能比较</a></p> 
<p id="1.6%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#1.6%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">1.6引用和指针的区别</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span style="color:#0d0016;">1.引用的概念</span></h2> 
<div> 
 <span style="color:#777777;"><strong>引用</strong></span> 
 <span style="color:#777777;">不是新定义一个变量，而</span> 
 <span style="color:#777777;"><strong>是给已存在变量取了一个别名</strong></span> 
 <span style="color:#777777;">，编译器不会为引用变量开辟内存空间，它和它引用的变量<strong>共用同一块内存空间。 </strong></span> 
</div> 
<div></div> 
<h3 id="1.1%E5%BC%95%E7%94%A8%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span style="color:#0d0016;">1.1引用的表示方法</span></h3> 
<blockquote> 
 <div> 
  <span style="color:#777777;"><strong>类型</strong></span> 
  <span style="color:#777777;"><strong>&amp; </strong></span> 
  <span style="color:#777777;"><strong>引用变量名</strong></span> 
  <span style="color:#777777;"><strong>(</strong></span> 
  <span style="color:#777777;"><strong>对象名</strong></span> 
  <span style="color:#777777;"><strong>) = </strong></span> 
  <span style="color:#777777;"><strong>引用实体；</strong></span> 
 </div> 
</blockquote> 
<p>如果熟悉C语言的同学可能会发现引用符号(&amp;)看上去就像取地址运算符(&amp;)或者按位AND运算符(&amp;)，其实这是一个运算符重载的例子。通过重载，同一个运算符将会有不同的含义。编译器会通过上下文来确定运算符的含义。除了这里所提到的，其实在C++中还有一些运算符重载的情况。例如：* 即表示乘法，又表示对指针的解引用操作；&lt;&lt;即表示插入运算符，又表示按位左移运算符等。</p> 
<p><span style="color:#956fe7;"><strong>代码实例：</strong></span></p> 
<pre><code>int main()
{
	//引用：取别名
	int a = 10;
	int&amp; b = a;//定义引用类型
	int&amp; c = b;

	return 0;
}</code></pre> 
<p>本段代码我们可以得知，a变量取了b，c两个别名。</p> 
<p>我们也可以通过调试观察他们的内存：</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/b7/e8/oWY1f3ce_o.png" width="721"></p> 
<p>通过调取内存我们可以发现，a,b,c所指向的是同一块内存空间。</p> 
<div> 
 <strong><span style="color:#777777;">注意：</span></strong> 
 <span style="color:#777777;"><strong>引用类型</strong></span> 
 <span style="color:#777777;">必须和引用</span> 
 <span style="color:#777777;"><strong>实体</strong></span> 
 <span style="color:#777777;">是</span> 
 <span style="color:#777777;"><strong>同种类型</strong></span> 
 <span style="color:#777777;">的</span> 
</div> 
<div></div> 
<h3 id="1.2%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7"><span style="color:#0d0016;">1.2引用特性</span></h3> 
<blockquote> 
 <p><span style="color:#777777;">引用有三个特性，分别是：</span></p> 
 <div> 
  <span style="color:#777777;">1. </span> 
  <span style="color:#777777;">引用在</span> 
  <span style="color:#fe2c24;"><strong>定义时必须初始化 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;">2. </span> 
  <span style="color:#777777;">一个变量可以有多个引用 </span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#777777;">3. </span> 
   <span style="color:#777777;">引用一旦引用一个实体，再不能引用其他实体</span> 
  </div> 
 </div> 
</blockquote> 
<p> 1.引用在定义的时候必须初始化</p> 
<p>由于引用是对已经存在的变量进行取别名，因此使用引用时必须指定变量(初始化)。</p> 
<pre><code>int&amp; d;//错误，未初始化</code></pre> 
<p>2.一个变量可以有多个引用</p> 
<p>在C++语法中，一个变量有多个引用，就类似于一个人可以有多个外号。在1.1的代码实例中变量a就有2个引用，分别是b和c。</p> 
<p>3.引用一旦引用一个实体，再不能引用其他实体</p> 
<p>这个也比较好理解，因为引用一旦引用了一个已经存在的实体，就是这个实体的别名，当然不能再成为其他实体的别名。</p> 
<h3 id="1.3%E5%B8%B8%E5%BC%95%E7%94%A8%C2%A0%20%E5%BC%95%E7%94%A8%E6%9D%83%E9%99%90"><span style="color:#0d0016;">1.3常引用  引用权限</span></h3> 
<p>我们来观察下面这段代码，他能编译成功吗？</p> 
<pre><code>int main()
{
   //1.
	const int x = 20;
	int&amp; y = x;      

	return 0;
}</code></pre> 
<p>当我们编译这段代码发现编译器报出错误警告： 无法从“const int”转换为“int &amp;”</p> 
<p><img alt="" height="291" src="https://images2.imgbox.com/ac/64/PCJ6TY6W_o.png" width="485"></p> 
<p> 这是因为我们在引用的时候要遵守引用的原则：</p> 
<blockquote> 
 <p>引用原则:对原变量的引用，权限不能放大。</p> 
</blockquote> 
<p>1.3这段代码中x变量是const修饰是一个常变量，只有可读权限。而我们引用的类型是int，不仅有可读权限，还有可修改权限。这就造成了对原变量的权限放大。根据我们引用原则知道，对原变量的引用，权限是不能放大的，这就是为什么这段代码会报错的原因。</p> 
<p>那我们再来看这一段代码，它能编译成功吗？</p> 
<pre><code>int main()
{
	//2.
	const int x = 20;
	const int&amp; y = x;//不变
 
    //3.
	int c = 30;
	const int&amp; d = c;//缩小

	return 0;
}</code></pre> 
<p><img alt="" height="383" src="https://images2.imgbox.com/b7/45/tx8fF5OX_o.png" width="575"></p> 
<p> 这段代码我们发现编译成功了，我们也可以轻松地分析出这里的引用是遵守引用规则的，我们发现，权限不变或者权限缩小都是符合规则的，唯一需要注意的是：<span style="color:#fe2c24;"><strong>权限不能放大。</strong></span></p> 
<p></p> 
<h3 id="1.4%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span style="color:#0d0016;">1.4引用的使用场景</span></h3> 
<h4 id="1.4.1%E5%81%9A%E5%8F%82%E6%95%B0"><span style="color:#0d0016;">1.4.1做参数</span></h4> 
<pre><code>void Swap(int&amp; x, int&amp; y)
{
	int tmp = x;
	x = y;
	y = tmp;
}

int main()
{
	int a = 0, b = 1;
	Swap(a, b);
	return 0;
}</code></pre> 
<p>引用可以作函数的形参，x是a的别名，y是b的别名。这里使用引用更加方便，也更好理解。</p> 
<p>那既然以值作为函数参数和以引用作为函数参数都能解决这个问题，那为什么还要使用引用来做参数呢？这是因为引用的效率更高，我们可以通过下面这段测试代码更加直观看出效率的差别：</p> 
<pre><code>#include &lt;time.h&gt;
struct A { int a[10000]; };
void TestFunc1(A a) {}
void TestFunc2(A&amp; a) {}
void TestRefAndValue()
{
	A a;
	// 以值作为函数参数
	size_t begin1 = clock();
	for (size_t i = 0; i &lt; 10000; ++i)
		TestFunc1(a);
	size_t end1 = clock();
	// 以引用作为函数参数
	size_t begin2 = clock();
	for (size_t i = 0; i &lt; 10000; ++i)
		TestFunc2(a);
	size_t end2 = clock();
	// 分别计算两个函数运行结束后的时间
	cout &lt;&lt; "TestFunc1(A)-time:" &lt;&lt; end1 - begin1 &lt;&lt; endl;
	cout &lt;&lt; "TestFunc2(A&amp;)-time:" &lt;&lt; end2 - begin2 &lt;&lt; endl;
}
int main()
{
	TestRefAndValue();
	return 0;
}</code></pre> 
<p><img alt="" height="183" src="https://images2.imgbox.com/a3/ad/m2wcuXDQ_o.png" width="419"></p> 
<p> 我们发现使用引用作为函数参数效率大大提高。<span style="color:#777777;">以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。 </span></p> 
<blockquote> 
 <p>引用做参数的意义：</p> 
 <p>1.输出型参数。</p> 
 <p>2.减少拷贝，提高效率。</p> 
</blockquote> 
<h4 id="1.4.2%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC%C2%A0">1.4.2做返回值 </h4> 
<p>首先我们来观察这段代码的返回值是什么?</p> 
<pre><code>int Count()
{
	static int n = 0;
	n++;

	return n;
}
int main()
{
	cout &lt;&lt; Count() &lt;&lt; endl;
	cout &lt;&lt; Count() &lt;&lt; endl;
	cout &lt;&lt; Count() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="68" src="https://images2.imgbox.com/e4/58/bQwnw2kf_o.png" width="329"></p> 
<p> 这里的结果是：1 2 3</p> 
<p>因为n是局部静态的成员变量，只会初始化一次，虽然作用域在Count函数内部，但是生命周期是全局，我们可以通过调试观看他是否再执行函数的第一句？</p> 
<p><img alt="" height="615" src="https://images2.imgbox.com/0c/b9/r6dZfvL6_o.png" width="685"></p> 
<h2 id="%E4%BC%A0%E5%80%BC%E7%9A%84%E5%BA%95%E5%B1%82%E8%BF%87%E7%A8%8B%EF%BC%9A">传值的底层过程：</h2> 
<p><img alt="" height="283" src="https://images2.imgbox.com/b2/98/izpLiIz8_o.png" width="561"></p> 
<blockquote> 
 <p>传值返回这个过程当中会产生一个临时变量，跟传参一样，如果小会用寄存器替代。传值返回的类型其实是临时变量的类型，将n拷贝给临时变量，再将临时变量拷贝给ret。那么为什么要设计临时变量呢？直接把n给ret不好吗？</p> 
</blockquote> 
<p>这是因为在当临时变量出了函数作用域之后会销毁，函数栈桢也会销毁，那么此时n是不能作为返回值再赋值给ret的。那么编译器就在此生成了一个临时变量，把n拷给临时变量，再把临时变量给ret。此时，函数栈桢销毁是不会影响临时变量的。</p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/16/57/Mdojpw2U_o.png" width="557"></p> 
<p> <img alt="" height="467" src="https://images2.imgbox.com/cb/18/VxnBLQzT_o.png" width="396"></p> 
<p> 那我们怎么可以证明这个过程产生了临时变量，我们可以给ret前加个引用。</p> 
<p><img alt="" height="336" src="https://images2.imgbox.com/55/b8/2qQBUThE_o.png" width="501"></p> 
<p></p> 
<p> 此时我们发现，编译器是过不了的，这是因为此时ret是引用的临时变量，而临时变量具有常性，这里属于权限的放大，因此我们只需要加上const即可。我们也通过这个例子证明了临时变量的存在。</p> 
<p> <img alt="" height="273" src="https://images2.imgbox.com/23/ca/g0k3CmpM_o.png" width="414"></p> 
<p></p> 
<p>那现在我们给Count函数加个引用是什么意思？我们来看这段代码。</p> 
<pre><code>int&amp; Count()
{
	int n = 0;
	n++; 

	return n;
}
//中间产生了一个临时变量
int main()
{
	int ret = Count(); 

	return 0;
}</code></pre> 
<p>这里可以这么认为，中间也会产生一个临时变量，这个临时变量的类型为int&amp;，此时这个临时变量是n的别名，再把临时变量赋给ret。返回的是一个n的别名，就相当于是吧n返回给了ret。</p> 
<p><img alt="" height="263" src="https://images2.imgbox.com/a5/37/4erttIjN_o.png" width="297"></p> 
<p> 此时我们再观察这段代码我们发现编译器可以通过了，这里ret相当于是n的别名。</p> 
<p>我们可以打印n和ret的地址看看：</p> 
<p><img alt="" height="370" src="https://images2.imgbox.com/c7/fb/XZ8p1KPK_o.png" width="687"></p> 
<p>这里ret和n的地址相同，也能证明ret是n的别名。因此，引用作为返回值其实返回的就是n的别名。</p> 
<h2 id="%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%9A">引用导致野指针：</h2> 
<p><img alt="" height="313" src="https://images2.imgbox.com/75/32/TaoXlgHe_o.png" width="589"></p> 
<p> 这段代码合法吗？</p> 
<p>其实这段代码是不合法的，因为出了函数的作用域，Count函数已经销毁了，我们再对此空间进行访问，就会造成非法访问，这里就是引用搞出来的野指针。</p> 
<p>我们来验证一下：</p> 
<div> 
 <pre><code>//传引用返回的是n的别名
int&amp; Count()
{
	int n = 0;
	n++; 
	//cout &lt;&lt; "n:"&lt;&lt; &amp; n &lt;&lt; endl;

	return n;
}
//中间产生了一个临时变量
int main()
{
	int&amp; ret = Count(); //ret是别名的别名  也就是n的别名
	cout &lt;&lt; ret &lt;&lt; endl;
	cout &lt;&lt; "ret"&lt;&lt; &amp; ret &lt;&lt; endl;
	cout &lt;&lt; ret &lt;&lt; endl;

	return 0;
}</code></pre> 
 <p>通过打印我们能够发现：第二个ret打印的是随机值。</p> 
 <p><img alt="" height="127" src="https://images2.imgbox.com/1f/e5/UsigbBcU_o.png" width="542"></p> 
 <p></p> 
</div> 
<blockquote> 
 <div>
   因此此处需要注意 ： 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>如果函数返回时，出了函数作用域，如果返回对象还未还给系统，则可以使用引用返回，如果已</strong></span> 
  <span style="color:#777777;"><strong>经还给系统了，则必须使用传值返回。 </strong></span> 
 </div> 
</blockquote> 
<p>我们来做一个实例巩固一下：</p> 
<p>下面这段代码的结果是什么？为什么？</p> 
<pre><code>int&amp; Add(int a, int b) 
{
	int c = a + b;
	return c;
}
int main()
{
	int&amp; ret = Add(1, 2);
	Add(3, 4);
	cout &lt;&lt; "Add(1, 2) is :" &lt;&lt; ret &lt;&lt; endl;
	return 0;
}</code></pre> 
<p><img alt="" height="279" src="https://images2.imgbox.com/d4/fa/5vFejf4c_o.png" width="520"></p> 
<p>结果：7，这里是因为在第一次调用Add时，ret为3，Add函数的栈桢销毁，在第二次调用时，Add函数的栈桢是相同的，c的位置为覆盖为7，再次访问ret此时就为7，因此这里使用是不安全的。以下打印就可以更加清晰了解这个过程。</p> 
<p><img alt="" height="294" src="https://images2.imgbox.com/a6/f2/WxRcVLNe_o.png" width="815"></p> 
<h3 id="1.5%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83">1.5值和引用作为返回值类型的性能比较</h3> 
<pre><code>#include &lt;time.h&gt;
struct A { int a[10000]; };
A a;
// 值返回
A TestFunc1() { return a; }
// 引用返回
A&amp; TestFunc2() { return a; }
void TestReturnByRefOrValue()
{
	// 以值作为函数的返回值类型
	size_t begin1 = clock();
	for (size_t i = 0; i &lt; 100000; ++i)
		TestFunc1();
	size_t end1 = clock();
	// 以引用作为函数的返回值类型
	size_t begin2 = clock();
	for (size_t i = 0; i &lt; 100000; ++i)
		TestFunc2();
	size_t end2 = clock();
	// 计算两个函数运算完成之后的时间
	cout &lt;&lt; "TestFunc1 time:" &lt;&lt; end1 - begin1 &lt;&lt; endl;
	cout &lt;&lt; "TestFunc2 time:" &lt;&lt; end2 - begin2 &lt;&lt; endl;
}

int main()
{
	TestReturnByRefOrValue();
	return 0;
}</code></pre> 
<p><img alt="" height="172" src="https://images2.imgbox.com/b4/c5/Rq37HKZH_o.png" width="425"></p> 
<p>通过打印我们发现引用作为返回值类型大大提高了效率。</p> 
<blockquote> 
 <p>原因：<span style="color:#777777;">以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。</span></p> 
</blockquote> 
<h3 id="1.6%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB">1.6引用和指针的区别</h3> 
<p>引用<span style="color:#777777;">在</span><span style="color:#777777;"><strong>语法概念上</strong></span><span style="color:#777777;">引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。 </span><span style="color:#777777;">在<strong>底层实现上</strong></span><span style="color:#777777;">实际是有空间的，因为</span><span style="color:#777777;"><strong>引用是按照指针方式来实现</strong></span><span style="color:#777777;">的。 </span></p> 
<pre><code>int main()
{
	int a = 10;

	int&amp; ra = a;
	ra = 20;

	int* pa = &amp;a;
	*pa = 20;

	return 0;
}</code></pre> 
<p>我们来看引用和指针的汇编代码对比：</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/a2/3f/nis1NLok_o.png" width="476"></p> 
<p>因此引用的底层实现上是按照指针的方式来实现的。</p> 
<blockquote> 
 <div> 
  <span style="color:#fe2c24;"><strong>引用和指针的不同点:</strong></span> 
  <span style="color:#777777;"> </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">1. 引用在定义时必须初始化，指针没有要求 </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">2. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体 </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">3. 没有NULL引用，但有NULL指针 </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">4. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节) </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">5. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小 </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">6. 有多级指针，但是没有多级引用 </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">7. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理 </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">8. 引用比指针使用起来相对更安全 </span> 
 </div> 
</blockquote> 
<p>（本篇完） </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a7e73aa8a28c8680be599e81fd747b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux-京东字节百度提前批，一面二面都被问到了awk——实例篇（2）去重统计排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/905596f56dabb5f5af9f42df3a44d2f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">v-model绑定子组件失效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>