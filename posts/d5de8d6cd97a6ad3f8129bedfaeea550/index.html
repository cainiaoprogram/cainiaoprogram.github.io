<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SD卡的驱动(linux操作系统下) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SD卡的驱动(linux操作系统下)" />
<meta property="og:description" content="emmc读写速度慢：是1线，还是4，8线，emmc和控制器本身支持的最高速率，还有dts的配置，cache（sync）是否有影响；回写，调度。
s3cmci_probe-&gt;mmc_alloc_host(mmc_rescan)-&gt;mmc_add_host-&gt;mmc_start_host-&gt;queue_delayed_work(system_freezable_wq, work, delay)-&gt;mmc_rescan-&gt;mmc_rescan_try_freq-&gt;mmc_attach_mmc-&gt;mmc_init_card，mmc_add_card-&gt;mmc_alloc_card-&gt;drv-&gt;probe(mmc_blk_probe)-&gt;mmc_blk_alloc-&gt;alloc_disk(perdev_minors),mmc_init_queue,add_disk-&gt;
block层：实现mmc为块设备，和块设备那套对接，实现并注册卡的驱动，加入到bus上。
core:抽象host,bus ,card实体，向底层提供便利的host要用的api。提供检测卡的插入，向bus注册sd卡。
host:提供并注册host驱动，实现host ops，用platform bus去match。
sd卡插入后的流程：中断检测总线上是否有卡，init card(standy_by),在bus上add card，找到driver match上，probe函数。
nandflash芯片
mmc 卡化
sd卡，比mmc在写保护，速率，容量
inand/emmc 电子产品越来越小，芯片比sd卡卡槽小巧，卡槽插拔次数多了接触不良。
inand/emmc sd卡芯片化，速率和接口，现在是8线io,支持1，4，8线传输模式，sd卡IO线，支持1，4线传输。自己完成ECC校验，不用代码来实现。sd卡内存有个卡的接口控制器，就相当于一个单片机。
形式上，这个部分和i2c非常相似
系统也是分成core层，host层（对应i2c的adapter），设备层
core层：主要功能应该是提供host注册，总线注册，设备注册的几个方法以及所谓sdio总线接口的算法了。
host层：已经是注册一个platform设备，其中应该提供主要sdio接口算法的实现。
设备层：应该是提供几个功能 1）注册块设备，映射到/dev下面的设备节点 2）应该还有设备其他信息。
Host层驱动，主要是填充mmc_host结构体相关内容和实现mmc_host_ops结构体中的函数。最后调用mmc_add_host向MMC core注册host驱动。可以参考S3C24XX的HOST驱动程序(drivers/mmc/host/s3cmci.c,s3cmci.h),上层MMC Core主要调用mmc_host_ops中的函数来实现与硬件交互。
MMC Core层。
该层主要实现了几个结构体函数指针，用来构建整个MMC设备驱动模型。它们是：
struct bus_type mmc_bus_type /*mmc总线，用来管理sd/mmc卡设备和驱动*/
struct mmc_bus_ops mmc_ops /*MMC卡总线操作函数，主要是在电源管理方面*/
struct mmc_bus_ops mmc_sd_op /*SD卡总线操作函数，主要是在电源管理方面*/
struct mmc_bus_ops mmc_sdio_ops /*SDIO总线操作函数，主要是在电源管理方面*/
struct bus_type sdio_bus_type /*SDIO另外定义了一条总线*/
core.c文件中实现了几个关键的函数，用来提供给上层MMC Card调用和对SD/MMC卡的侦测函数以及初始化。
供给上层MMC Card调用主要有：
void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq);
int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d5de8d6cd97a6ad3f8129bedfaeea550/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-16T16:18:46+08:00" />
<meta property="article:modified_time" content="2022-09-16T16:18:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SD卡的驱动(linux操作系统下)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>emmc读写速度慢：是1线，还是4，8线，emmc和控制器本身支持的最高速率，还有dts的配置，cache（sync）是否有影响；回写，调度。</p> 
<p>s3cmci_probe-&gt;mmc_alloc_host(mmc_rescan)-&gt;mmc_add_host-&gt;mmc_start_host-&gt;queue_delayed_work(system_freezable_wq, work, delay)-&gt;mmc_rescan-&gt;mmc_rescan_try_freq-&gt;mmc_attach_mmc-&gt;mmc_init_card，mmc_add_card-&gt;mmc_alloc_card-&gt;drv-&gt;probe(mmc_blk_probe)-&gt;mmc_blk_alloc-&gt;alloc_disk(perdev_minors),mmc_init_queue,add_disk-&gt;</p> 
<p>block层：实现mmc为块设备，和块设备那套对接，实现并注册卡的驱动，加入到bus上。</p> 
<p>core:抽象host,bus ,card实体，向底层提供便利的host要用的api。提供检测卡的插入，向bus注册sd卡。</p> 
<p>host:提供并注册host驱动，实现host ops，用platform bus去match。</p> 
<p></p> 
<p>sd卡插入后的流程：中断检测总线上是否有卡，init card(standy_by),在bus上add card，找到driver match上，probe函数。</p> 
<p></p> 
<p>nandflash芯片</p> 
<p>mmc 卡化</p> 
<p>sd卡，比mmc在写保护，速率，容量</p> 
<p>inand/emmc 电子产品越来越小，芯片比sd卡卡槽小巧，卡槽插拔次数多了接触不良。</p> 
<p>inand/emmc sd卡芯片化，速率和接口，现在是8线io,支持1，4，8线传输模式，sd卡IO线，支持1，4线传输。自己完成ECC校验，不用代码来实现。sd卡内存有个卡的接口控制器，就相当于一个单片机。</p> 
<p></p> 
<p></p> 
<p></p> 
<p>形式上，这个部分和i2c非常相似<br> 系统也是分成core层，host层（对应i2c的adapter），设备层<br> core层：主要功能应该是提供host注册，总线注册，设备注册的几个方法以及所谓sdio总线接口的算法了。<br> host层：已经是注册一个platform设备，其中应该提供主要sdio接口算法的实现。<br> 设备层：应该是提供几个功能 1）注册块设备，映射到/dev下面的设备节点 2）应该还有设备其他信息。</p> 
<p></p> 
<p>Host层驱动，主要是填充mmc_host结构体相关内容和实现mmc_host_ops结构体中的函数。最后调用mmc_add_host向MMC core注册host驱动。可以参考S3C24XX的HOST驱动程序(drivers/mmc/host/s3cmci.c,s3cmci.h),上层MMC Core主要调用mmc_host_ops中的函数来实现与硬件交互。</p> 
<p>MMC Core层。<br> 该层主要实现了几个结构体函数指针，用来构建整个MMC设备驱动模型。它们是：<br> struct bus_type mmc_bus_type  /*mmc总线，用来管理sd/mmc卡设备和驱动*/<br> struct mmc_bus_ops mmc_ops    /*MMC卡总线操作函数，主要是在电源管理方面*/<br> struct mmc_bus_ops mmc_sd_op  /*SD卡总线操作函数，主要是在电源管理方面*/<br> struct mmc_bus_ops mmc_sdio_ops  /*SDIO总线操作函数，主要是在电源管理方面*/<br> struct bus_type sdio_bus_type  /*SDIO另外定义了一条总线*/<br> core.c文件中实现了几个关键的函数，用来提供给上层MMC Card调用和对SD/MMC卡的侦测函数以及初始化。<br> 供给上层MMC Card调用主要有：<br> void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq);<br> int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries);</p> 
<p>mmc_attach_xxx函数就是用来完成侦测和初始化的，选择相应的总线操作函数，并产生struct mmc_card结构体，并填充其内容，最后注册一个mmc_card(代表着一个设备)，并在注册中由mmc_bus_type结构体的match和probe函数来查找到适合该设备的驱动(这个又牵涉到设备驱动模型，可以查看设备驱动模型相关内容，了解设备和驱动匹配的过程)，这里将匹配到mmc card层的MMC_Block(MMC块设备驱动程序，由 struct mmc_driver代表)。在完成设备侦测和初始化以后，以后的操作就是mmc card层中相关的设备驱动程序发出的了。</p> 
<p>MMC card层，该层主要实现具体的设备驱动程序，如MMC块设备驱动程序，通过mmc_register_driver注册。如果是SDIO就有可能是其它字符设备驱动程序了，其通过调用sdio_register_driver来注册设备驱动。<br> 总体概括来说：<br> host层提供驱动相关MMC/SD/SDIO控制器的功能。<br> Core层提供了具体MMC/SD/SDIO设备侦测和初始化功能，以及电源管理方面的内容和通用的操作功能。<br> Card为实现具体的设备驱动层。</p> 
<p>MMC/SD卡的驱动整个构架由三个文件组成，其实一共就做了两件事件：<br> 1).卡的检测。<br> 2).卡数据的读取。</p> 
<p>4.4.1.卡的检测中涉及到的函数<br> tcc_mmc_probe(host/tcc_sdhc.c) <br>  mmc_alloc_host(core/core.c) <br>    mmc_rescan(core/core.c) <br>   mmc_attach_mmc(core/mmc.c) <br>  mmc_init_card(core/mmc.c) <br>       mmc_add_card(core/bus.c) <br>    device_add <br>     mmc_bus_match(core/bus.c) <br>     mmc_bus_probe(core/bus.c)                                                      mmc_blk_probe(card/block.c)<br>       alloc_disk/add_disk</p> 
<p>4.4.2.卡中数据读写涉及到的函数<br> mmc_blk_issue_rq(card/block.c)<br>  mmc_wait_for_req(core/core.c)<br>   mmc_start_request(core/core.c)<br>    host-&gt;ops-&gt;requset(host,mrq)<br>      //tcc_sdhc.c中的tcc_mmc_request</p> 
<p></p> 
<p></p> 
<p>core.c</p> 
<p>注册sys/bus/mmc</p> 
<p>注册sys/class/mmc_host</p> 
<p>注册sys/bus/sdio</p> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1907c9c6dd57ff492c226c3c74112ba6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue/Nuxt框架开发的PC端网站兼容平板设备的</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9467d4bd5a37d978768b01171385cc44/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android studio Dolphin海豚 properties乱码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>