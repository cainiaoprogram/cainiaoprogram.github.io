<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java内存溢出与栈溢出 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java内存溢出与栈溢出" />
<meta property="og:description" content="一、背景知识 1、JVM体系结构 2、JVM运行时数据区 3、JVM内存模型 JVM运行时内存 = 共享内存区 &#43; 线程内存区 3-1、共享内存区 共享内存区 = 持久带 &#43; 堆
持久带 = 方法区 &#43; 其他
堆 = Old Space &#43; Young Space
Young Space = Eden &#43; S0 &#43; S1
3-1-1、持久代 JVM用持久带（Permanent Space）实现方法区，主要存放所有已加载的类信息，方法信息，常量池等等。
可通过-XX:PermSize和-XX:MaxPermSize来指定持久带初始化值和最大值。
Permanent Space并不等同于方法区，只不过是Hotspot JVM用Permanent Space来实现方法区而已，有些虚拟机没
有Permanent Space而用其他机制来实现方法区。
3-1-2、堆 堆(heap)，主要用来存放类的对象实例信息（包括new操作实例化的对象和定义的数组）。
堆分为Old Space（又名，Tenured Generation）和Young Space。
Old Space主要存放应用程序中生命周期长的存活对象；
Eden(伊甸园)主要存放新生的对象；
S0和S1是两个大小相同的内存区域，主要存放每次垃圾回收后Eden存活的对象，作为对象从Eden过渡到Old Space
的缓冲地带（S是指英文单词Survivor Space）。
堆之所以要划分区间，是为了方便对象创建和垃圾回收，后面垃圾回收部分会解释。
3-2、线程内存区 线程内存区=单个线程内存&#43;单个线程内存&#43;.......
单个线程内存=PC Regster&#43;JVM栈&#43;本地方法栈
JVM栈=栈帧&#43;栈帧&#43;.....
栈帧=局域变量区&#43;操作数区&#43;帧数据区
在Java中，一个线程会对应一个JVM栈(JVM Stack)，JVM栈里记录了线程的运行状态。
JVM栈以栈帧为单位组成，一个栈帧代表一个方法调用。栈帧由三部分组成：局部变量区、操作数栈、帧数据区。
二、堆溢出 堆（Heap）是Java存放对象实例的地方。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/126aadc933f8aa12a525a30459c1ca1e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-01-23T11:02:56+08:00" />
<meta property="article:modified_time" content="2015-01-23T11:02:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java内存溢出与栈溢出</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、背景知识</h2> 
<div> 
 <br> 
</div> 
<h3>1、JVM体系结构</h3> 
<div> 
 <br> 
</div> 
<p style="text-align:center"><img src="https://images2.imgbox.com/78/3e/FQwa4MTy_o.jpg" alt=""><br> </p> 
<p><br> </p> 
<h3>2、JVM运行时数据区</h3> 
<div> 
 <br> 
</div> 
<p style="text-align:center"><img src="https://images2.imgbox.com/56/8b/GmUOsNjn_o.jpg" alt=""><br> </p> 
<p><br> </p> 
<h3>3、JVM内存模型</h3> 
<div> 
 <br> 
</div> 
<h4><span style="color:#ff0000">JVM运行时内存 = 共享内存区 + 线程内存区</span></h4> 
<p><br> </p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/ea/81/j1MKPDNa_o.png" alt=""><br> </p> 
<p><br> </p> 
<h3>3-1、共享内存区</h3> 
<div> 
 <br> 
</div> 
<p><span style="font-size:18px; color:#ff0000">共享内存区 = 持久带 + 堆</span></p> 
<p><span style="font-size:18px; color:#ff0000">持久带 = 方法区 + 其他</span></p> 
<p><span style="font-size:18px; color:#ff0000">堆 = Old Space + Young Space</span></p> 
<p><span style="font-size:18px; color:#ff0000">Young Space = Eden + S0 + S1</span><br> </p> 
<p><br> </p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/a5/88/rjSTyz7n_o.png" alt=""><br> </p> 
<p><br> </p> 
<h3>3-1-1、持久代</h3> 
<div> 
 <br> 
</div> 
<p><span style="font-size:18px; color:#ff0000">JVM用持久带（Permanent Space）实现方法区，主要存放所有已加载的类信息，方法信息，常量池等等。</span></p> 
<p><span style="font-size:18px"><span style="color:#3333ff">可通过-XX:PermSize和-XX:MaxPermSize来指定持久带初始化值和最大值</span>。</span></p> 
<p><span style="font-size:18px">Permanent Space并不等同于方法区，只不过是Hotspot JVM用Permanent Space来实现方法区而已，有些虚拟机没</span></p> 
<p><span style="font-size:18px">有Permanent Space而用其他机制来实现方法区。</span></p> 
<p><br> </p> 
<h3>3-1-2、堆</h3> 
<div> 
 <br> 
</div> 
<p><span style="font-size:18px"><span style="color:#ff0000">堆(heap)，</span><span style="color:#3333ff">主要用来存放类的对象实例信息（包括new操作实例化的对象和定义的数组）。</span></span></p> 
<p><span style="font-size:18px">堆分为Old Space（又名，Tenured Generation）和Young Space。</span></p> 
<p><span style="font-size:18px">Old Space主要存放应用程序中生命周期长的存活对象；</span></p> 
<p><span style="font-size:18px">Eden(伊甸园)主要存放新生的对象；</span></p> 
<p><span style="font-size:18px">S0和S1是两个大小相同的内存区域，主要存放每次垃圾回收后Eden存活的对象，作为对象从Eden过渡到Old Space</span></p> 
<p><span style="font-size:18px">的缓冲地带（S是指英文单词Survivor Space）。</span></p> 
<p><span style="font-size:18px">堆之所以要划分区间，是为了方便对象创建和垃圾回收，后面垃圾回收部分会解释。<br> </span></p> 
<p><br> </p> 
<h3>3-2、线程内存区</h3> 
<div> 
 <br> 
</div> 
<p><span style="font-size:18px; color:#ff0000">线程内存区=单个线程内存+单个线程内存+.......</span></p> 
<p><span style="font-size:18px; color:#ff0000">单个线程内存=PC Regster+JVM栈+本地方法栈</span></p> 
<p><span style="font-size:18px; color:#ff0000">JVM栈=栈帧+栈帧+.....</span></p> 
<p><span style="font-size:18px; color:#ff0000">栈帧=局域变量区+操作数区+帧数据区</span><br> </p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/6b/ae/2NKnqW2k_o.png" alt=""><br> </p> 
<p><br> </p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">在Java中，一个线程会对应一个JVM栈(JVM Stack)，JVM栈里记录了线程的运行状态。</span></p> 
<p><span style="font-size:18px">JVM栈以栈帧为单位组成，一个栈帧代表一个方法调用。栈帧由三部分组成：局部变量区、操作数栈、帧数据区。<br> </span></p> 
<p><br> </p> 
<h2>二、堆溢出</h2> 
<div> 
 <br> 
</div> 
<p><span style="font-size:18px; color:#ff0000">堆（Heap）是Java存放对象实例的地方。</span></p> 
<p><span style="font-size:18px"><span style="color:#ff0000">堆溢出</span>可以分为以下两种情况，这两种情况都会抛出OutOfMemoryError:java heap space异常：</span><br> </p> 
<p><br> </p> 
<h3>1、内存泄漏</h3> 
<div> 
 <br> 
</div> 
<p><span style="font-size:18px"><span style="color:#ff0000">内存泄漏</span>是指对象实例在新建和使用完毕后，仍然被引用，没能被垃圾回收释放，一直积累，直到没有剩余</span></p> 
<p><span style="font-size:18px">内存可用。</span></p> 
<p><span style="font-size:18px">如果内存泄露，我们要找出泄露的对象是怎么被<span style="color:#6600cc">GC ROOT</span>引用起来，然后通过引用链来具体分析泄露的原因。</span></p> 
<p><span style="font-size:18px">分析内存泄漏的工具有：<span style="color:#3333ff">Jprofiler，visualvm</span>等。</span><br> </p> 
<p><br> </p> 
<p><span style="font-size:18px">示例代码：</span></p> 
<p></p> 
<pre><code class="language-java">package com.jvm;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * 内存泄漏
 * @author feizi
 * @time 2015-1-23上午8:42:53
 */
public class OOMTest {

	public static void main(String[] args) {
		
		List&lt;UUID&gt; list = new ArrayList&lt;UUID&gt;();
		while(true){
			list.add(UUID.randomUUID());
		}
	}

}</code></pre> 
<p><br> </p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">看看控制台的输出结果，因为我这边的JVM设置的参数内存足够大，所以需要等待一定的时间，才能看到效果：</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p></p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/89/17/3jOkwvaL_o.png" alt=""><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">如果是用CMD命令行，就可以自己指定参数编译运行了，这样效果就更快一些：</span></p> 
<p><span style="font-size:18px">通过下列命令运行程序，<span style="color:#ff0000">注意先要用javac命令将.java源文件编译成.class类字节码文件。</span></span></p> 
<p><br> </p> 
<p></p> 
<pre><code class="language-java">java -Xms10M -Xmx10M -XX:-UseGCOverheadLimit OOMTest</code></pre> 
<br> 
<p></p> 
<div style="text-align:center"> 
 <img src="https://images2.imgbox.com/b1/f1/BctUGkPV_o.png" alt=""> 
</div> 
<p></p> 
<p><br> </p> 
<h3>2、内存溢出</h3> 
<div> 
 <br> 
</div> 
<p><span style="font-size:18px"><span style="color:#ff0000">内存溢出</span>是指当我们新建一个实力对象时，实例对象所需占用的内存空间大于堆的可用空间。</span></p> 
<p><span style="font-size:18px">如果出现了内存溢出问题，这往往是程序本生需要的内存大于了我们给虚拟机配置的内存，这种情况下，我们可以采用调大-Xmx来解决这种问题。</span><br> </p> 
<p><br> </p> 
<p><span style="font-size:18px">示例代码：</span></p> 
<p></p> 
<pre><code class="language-java">package com.jvm;

import java.util.ArrayList;
import java.util.List;

/**
 * 内存溢出
 * @author feizi
 * @time 2015-1-23上午8:56:22
 */
public class OOMTest_1 {
	public static void main(String args[]){
		List&lt;byte[]&gt; byteList = new ArrayList&lt;byte[]&gt;();
		byteList.add(new byte[1000 * 1024 * 1024]);
	}
}
</code></pre> 
<p></p> 
<p><br> </p> 
<span style="font-size:18px"></span> 
<p><span style="font-size:18px"><br> </span></p> 看看控制台的运行效果： 
<p><br> </p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/76/02/ObjBj2SL_o.png" alt=""></p> 
<p><br> </p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">使用CMD命令行指定参数运行：</span></p> 
<p><br> </p> 
<p></p> 
<pre><code class="language-java">java -verbose:gc -Xmn10M -Xms20M -Xmx20M -XX:+PrintGC OOMTest_1</code></pre> 
<p></p> 
<p><br> </p> 
<div style="text-align:center"> 
 <img src="https://images2.imgbox.com/20/ff/T32n2FGB_o.png" alt=""> 
</div> 
<br> 
<br> 
<h2>三、线程栈</h2> 
<div> 
 <br> 
</div> 
<p><span style="font-size:18px"><span style="color:#ff0000">栈（JVM Stack）</span><span style="color:#3333ff">存放主要是栈帧( 局部变量表, 操作数栈 , 动态链接 , 方法出口信息 )的地方。注意区分栈和栈帧：栈里包含栈帧。</span><br> <br> 与线程栈相关的内存异常有两个：<br> <br> <span style="color:#ff0000">a）、StackOverflowError(方法调用层次太深，内存不够新建栈帧)</span></span></p> 
<p><span style="font-size:18px"><span style="color:#ff0000">b）、OutOfMemoryError（线程太多，内存不够新建线程）</span></span><br> </p> 
<p><br> </p> 
<h3>1、java.lang.StackOverflowError</h3> 
<div> 
 <br> 
</div> 
<p><span style="font-size:18px"><span style="color:#ff0000">栈溢出</span>抛出java.lang.StackOverflowError错误，出现此种情况是因为方法运行的时候，请求新建栈帧时，</span></p> 
<p><span style="font-size:18px">栈所剩空间小于战帧所需空间。</span></p> 
<p><span style="font-size:18px">例如，通过递归调用方法,不停的产生栈帧,一直把栈空间堆满,直到抛出异常 ：<br> </span></p> 
<p><br> </p> 
<p><span style="font-size:18px">示例代码：</span></p> 
<p></p> 
<pre><code class="language-java">package com.jvm;
/**
 * 栈溢出
 * @author feizi
 * @time 2015-1-23上午9:13:11
 */
public class SOFTest {

	public void stackOverFlowMethod(){
		stackOverFlowMethod();
	}
	
	/**
	 * 通过递归调用方法,不停的产生栈帧,一直把栈空间堆满,直到抛出异常 ：
	 * @param args
	 */
	public static void main(String[] args) {
		SOFTest sof = new SOFTest();
		sof.stackOverFlowMethod();
	}

}
</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px">看看控制台运行的效果：</span></p> 
<p><br> </p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/1c/ec/sxmPO4Cs_o.png" alt=""><br> </p> 
<p><br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd85c4f008869d9bffdf9cc86fb915e6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">numpy数组扩展函数repeat和tile用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/206533099636a633cf4e205b74a19ecf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小书匠使用手册</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>