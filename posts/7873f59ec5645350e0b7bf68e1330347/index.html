<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Foundry使用（二）--forge命令行 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Foundry使用（二）--forge命令行" />
<meta property="og:description" content="其它相关内容可见：个人主页 2. Forge： Forge是Foundry附带的命令行工具，用来测试、构建和部署智能合约
forge test 运行测试用例，所有测试都是Solidity编写
Forge将从源目录的任何位置查找测试，任何具有以test开头的函数的合约都被认为是一个测试。
通常测试放在src/test中
通过传递过滤器运行特定测试：
forge test --match-contract ComplicatedContractTest --match-test testDeposit 这将在名称中带有 testDeposit 的 ComplicatedContractTest 测试合约中运行测试。
2.1 编写测试： 测试代码是用Solidity编写的，最常见的测试编写是通过Forge ****标准库的Test合约实现。
使用Forge标准库，会利用到DSTest合约，其提供基本的日志记录和断言功能
导入forge-std/Test.sol 并继承自测试合约Test
import &#34;forge-std/Test.sol&#34;; 一个测试案例：
pragma solidity 0.8.10; import &#34;forge-std/Test.sol&#34;; contract ContractBTest is Test { uint256 testNumber; function setUp() public { testNumber = 42; } function testNumberIs42() public { assertEq(testNumber, 42); } function testFailSubtract43() public { testNumber -= 43; } } setUp() :在每个测试用例运行之前调用的可选函数test() :以test 为前缀的函数作为测试用例执行testFail() :test 的相反情况，如果函数没有报错revert，那么测试失败 测试函数必须具有external 或public ，否则测试函数将无效" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7873f59ec5645350e0b7bf68e1330347/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-16T17:50:44+08:00" />
<meta property="article:modified_time" content="2023-12-16T17:50:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Foundry使用（二）--forge命令行</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="httpsemmanuelwhgithubio_0"></a>其它相关内容可见：<a href="https://emmanuelwh.github.io/" rel="nofollow">个人主页</a></h2> 
<h2><a id="2_Forge_1"></a>2. Forge：</h2> 
<p>Forge是Foundry附带的命令行工具，用来测试、构建和部署智能合约</p> 
<pre><code class="prism language-docker">forge test
</code></pre> 
<p>运行测试用例，所有测试都是Solidity编写</p> 
<p>Forge将从源目录的任何位置查找测试，任何具有以test开头的函数的合约都被认为是一个测试。</p> 
<p>通常测试放在<code>src/test中</code></p> 
<p>通过传递过滤器运行特定测试：</p> 
<pre><code class="prism language-docker">forge test --match-contract ComplicatedContractTest --match-test testDeposit
</code></pre> 
<p>这将在名称中带有 <code>testDeposit</code> 的 <code>ComplicatedContractTest</code> 测试合约中运行测试。</p> 
<h3><a id="21__23"></a>2.1 编写测试：</h3> 
<p>测试代码是用Solidity编写的，最常见的测试编写是通过<code>Forge</code> ****标准库的<code>Test</code>合约实现。</p> 
<p>使用Forge标准库，会利用到DSTest合约，其提供基本的日志记录和断言功能</p> 
<p>导入<code>forge-std/Test.sol</code> 并继承自测试合约<code>Test</code></p> 
<pre><code class="prism language-solidity">import "forge-std/Test.sol";
</code></pre> 
<p>一个测试案例：</p> 
<pre><code class="prism language-solidity">pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract ContractBTest is Test {
    uint256 testNumber;

    function setUp() public {
        testNumber = 42;
    }

    function testNumberIs42() public {
        assertEq(testNumber, 42);
    }

    function testFailSubtract43() public {
        testNumber -= 43;
    }
}
</code></pre> 
<ul><li><code>setUp()</code> :在每个测试用例运行之前调用的可选函数</li><li><code>test()</code> :以<code>test</code> 为前缀的函数作为测试用例执行</li><li><code>testFail()</code> :<code>test</code> 的相反情况，如果函数没有报错revert，那么测试失败</li></ul> 
<blockquote> 
 <p>测试函数必须具有<code>external</code> 或<code>public</code> ，否则测试函数将无效</p> 
</blockquote> 
<h3><a id="22_cheatcodes_66"></a>2.2 cheatcodes</h3> 
<p>为了操纵区块链的状态，以及测试特定的<code>reverts</code> 和事件<code>Events</code> ，Foundry附带一组cheatcodes</p> 
<p>通过Forge标准库中的<code>Test</code> 合约提供的<code>vm</code> 实例可以访问cheatcode。</p> 
<p>以一个例子进行详细说明：</p> 
<p>我们的目的是为了验证一个合约的函数只能被合约所有者所调用，编写个测试</p> 
<p>在<code>./test</code> 文件夹下添加一个Owner.t.sol测试文件</p> 
<pre><code class="prism language-solidity">pragma solidity 0.8.10;
import "forge-std/Test.sol";
error Unauthorized();

contract OwnerUpOnly {
    address public immutable owner;
    uint256 public count;
    constructor() {
        owner = msg.sender;
    }
    function increment() external {
        if (msg.sender != owner) {
            revert Unauthorized();
        }
        count++;
    }
}

contract OwnerUpOnlyTest is Test {
    OwnerUpOnly upOnly;
    function setUp() public {
        upOnly = new OwnerUpOnly();
    }
    function testIncrementAsOwner() public {
        assertEq(upOnly.count(), 0);
        upOnly.increment();
        assertEq(upOnly.count(), 1);
    }
}
</code></pre> 
<p>运行<code>forge test</code> ,发现测试通过</p> 
<p>接下来测试不是所有者的人不能增加计数</p> 
<p>合约<code>OwnerUpOnlyTest</code> 中添加一函数：</p> 
<pre><code class="prism language-solidity">function testIncrementAsNotOwner() public {
        vm.prank(address(0));
        upOnly.increment();
    }
</code></pre> 
<p>再次运行<code>forge test</code> ,发现测试revert，说明不是合约所有者不能增加计数</p> 
<p><img src="https://images2.imgbox.com/99/a0/lB9PvQiX_o.png" alt="forge test示例"></p> 
<p><code>**vm.prank(address)</code>** cheatcode将msg.sender的身份更改为零地址后，进行下一次调用，保证调用者不是合约所有者。</p> 
<p>完整的 <code>cheatcode</code> 的详细介绍可见 [<a href="https://learnblockchain.cn/docs/foundry/i18n/zh/cheatcodes/index.html" rel="nofollow">Cheatcodes 参考 - Foundry 中文文档 (learnblockchain.cn)</a>]</p> 
<h3><a id="23_Forge_132"></a>2.3 Forge标准库概览</h3> 
<p><code>Forge Std</code>提供了编写测试代码所需的所有基本功能</p> 
<ul><li><code>Vm.sol</code>：最新的作弊码接口</li><li><code>console.sol</code> 和 <code>console2.sol</code>：Hardhat 风格的日志记录功能</li><li><code>Script.sol</code>：<a href="https://learnblockchain.cn/docs/foundry/i18n/zh/tutorials/solidity-scripting.html" rel="nofollow">Solidity 脚本</a> 的基本实用程序</li><li><code>Test.sol</code>：DSTest 的超集，包含标准库、作弊码实例 (<code>vm</code>) 和 Hardhat 控制台</li></ul> 
<h3><a id="24_Traces_141"></a>2.4 了解Traces</h3> 
<p>Forge可以为失败的测试（<code>-vvv</code>）或所有测试（<code>-vvvv</code>）生成跟踪<code>Traces</code></p> 
<p><code>Traces</code> 的不同颜色</p> 
<ul><li><strong>绿色</strong>：对于不会 revert 的调用</li><li><strong>红色</strong>：用于有 revert 的调用</li><li><strong>蓝色</strong>：用于调用作弊码</li><li><strong>青色</strong>：用于触发日志</li><li><strong>黄色</strong>：用于合约部署<br> <img src="https://images2.imgbox.com/dd/1e/JLx0oYO0_o.png" alt="forge trace示例"></li></ul> 
<h3><a id="25__155"></a>2.5 分叉测试</h3> 
<p>Forge支持使用两种不同方式进行分叉测试：</p> 
<ul><li>分叉模式（Forking Mode）：通过<code>forge test --fork-url</code> 标准使用一个单独分叉进行所有测试</li><li>分叉作弊码（Forking Cheatcodes)：通过<a href="https://learnblockchain.cn/docs/foundry/i18n/zh/cheatcodes/forking.html" rel="nofollow">forking 作弊码</a> 在 Solidity 测试代码中直接创建、选择和管理多个分叉</li></ul> 
<h4><a id="251__162"></a>2.5.1 分叉模式：</h4> 
<p>通过<code>--fork-url</code> 传递RPC URL，<code>--fork-block-number</code> 指定分叉的区块高度</p> 
<pre><code class="prism language-solidity">forge test --fork-url "https://mainnet.infura.io/v3/10973852e3ce414296d70fd551402e92" --fork-block-number 17001200
</code></pre> 
<h4><a id="252_170"></a>2.5.2分叉作弊码：</h4> 
<p>在Solidity测试代码中以编程方式进入分叉模式。</p> 
<p>Foundry测试代码中：所有的测试函数的隔离的，每个测试函数都使用<code>setup()</code> 之后的拷贝状态执行, <code>setup()</code> 期间创建的分支可用于测试。</p> 
<ul><li><code>createFork('mainnet', blocknumber)</code> cheatcode创建分支，并返回唯一的标识符</li><li><code>selectFork(Forkid)</code> 传递Forkid，启用对应的分支</li><li><code>activeFork()</code> 返回当前启用分支的Forkid</li><li><code>rollFork(blocknumber)</code> 设置分叉的区块高度</li></ul> 
<p>每个分叉是一个独立的EVM，所有分叉使用完全独立的存储，但<code>msg.sender</code> 的状态和测试合约本身在分叉更改中是持久的</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa4d79f4d0b70a1e615c94a07daf5c27/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MATLAB基础5：控制系统的校正</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb06cf325a1c63c2bcc876c8d74f20ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flask中信号机制用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>