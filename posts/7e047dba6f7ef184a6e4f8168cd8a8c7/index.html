<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux操作系统（一）系统初始化 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux操作系统（一）系统初始化" />
<meta property="og:description" content="系统初始化 CPU（Central Processing Unit，中央处理器）x86 架构32 位处理器BIOS 时期bootloader 时期从实模式切换到保护模式内核初始化从内核态到用户态glibc 对系统调用的封装32 位系统调用过程 64位系统调用表 CPU（Central Processing Unit，中央处理器） 总线：用于CPU 和其他设备连接
CPU 它包括三个部分，运算单元、数据单元和控制单元。
每个进程都有一个二进制的程序放在硬盘上，再里面就是一行行的指令，会操作一些数据。
CPU 的控制单元里面，有一个指令指针寄存器，它里面存放的是下一条指令在内存中的地 址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。 （指令分别是对数据 or 运算）。 数据单元里的数据寄存器，从数据段里 读到数据寄存器里，就可以参与运算了，运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。最终，会有指令将数据写回内存中的数据段。
多任务系统的一个操作 ：进程切换 （A进程切换到B进程）
CPU 和内存来来回回传数据，靠的都是总线。一个是地址数据，也就是我想拿内存中哪个位置的数据，这类总线叫地址总线 （Address Bus）；另一类是真正的数据，这类总线叫数据总线（Data Bus）
地址总线的位数，决定了能访问的地址范围到底有多广。例如只有两位，那 CPU 就只能认 00，01，10，11 四个位置，超过四个位置，就区分不出来了。位数越多，能够访问的位置 就越多，能管理的内存的范围也就越广。
CPU 数据总线和地址总线越来越宽，处理能力越来越强。但是一直不能忘记 三点，一是标准，二是开放，三是兼容
x86 架构 下图是x86 86 中最经典的一款处理器 ， 8086处理器
重点 ： 寄存器的作用
8086 处理器内部有 8 个 16 位的通用寄存器，也就是刚才说的 CPU 内部 的数据单元，分别是 AX、BX、CX、DX、SP、BP、SI、DI。这些寄存器主要用于在计算过 程中暂存数据。这些寄存器比较灵活，其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别 是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。IP 寄存器/指令指针寄存器（Instruction Pointer Register) :指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。切换进程：每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四 个 16 位的段寄存器（ CS、DS、SS、ES）CS 就是代码段寄存器 , 通过它可以找到代码在内存中的位置DS 是数据段的寄存器 , 通过它可以找到数据在内存中的位置SS 是栈寄存器（Stack Register） : 数据的存取只 能从一端进行，秉承后进先出的原则，push 就是入栈，pop 就是出栈." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7e047dba6f7ef184a6e4f8168cd8a8c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-29T20:12:51+08:00" />
<meta property="article:modified_time" content="2022-06-29T20:12:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux操作系统（一）系统初始化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>系统初始化</h4> 
 <ul><li><a href="#CPUCentral_Processing_Unit_1" rel="nofollow">CPU（Central Processing Unit，中央处理器）</a></li><li><a href="#x86___13" rel="nofollow">x86 架构</a></li><li><a href="#32__26" rel="nofollow">32 位处理器</a></li><li><a href="#BIOS__42" rel="nofollow">BIOS 时期</a></li><li><a href="#bootloader__58" rel="nofollow">bootloader 时期</a></li><li><a href="#_76" rel="nofollow">从实模式切换到保护模式</a></li><li><a href="#_82" rel="nofollow">内核初始化</a></li><li><a href="#_106" rel="nofollow">从内核态到用户态</a></li><li><a href="#glibc__171" rel="nofollow">glibc 对系统调用的封装</a></li><li><ul><li><a href="#32__196" rel="nofollow">32 位系统调用过程</a></li></ul> 
  </li><li><a href="#64_237" rel="nofollow">64位</a></li><li><a href="#_325" rel="nofollow">系统调用表</a></li></ul> 
</div> 
<p></p> 
<h2><a id="CPUCentral_Processing_Unit_1"></a>CPU（Central Processing Unit，中央处理器）</h2> 
<p><img src="https://images2.imgbox.com/3c/98/y65AwDP4_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>总线：用于CPU 和其他设备连接</p> </li><li> <p>CPU 它包括三个部分，运算单元、数据单元和控制单元。<br> <img src="https://images2.imgbox.com/73/c5/UPc7kC7J_o.png" alt="在这里插入图片描述"></p> </li><li> <p>每个进程都有一个二进制的程序放在硬盘上，再里面就是一行行的指令，会操作一些数据。</p> </li><li> <p>CPU 的控制单元里面，有一个指令指针寄存器，它里面存放的是下一条指令在内存中的地 址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。 （指令分别是对数据 or 运算）。 数据单元里的数据寄存器，从数据段里 读到数据寄存器里，就可以参与运算了，运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。最终，会有指令将数据写回内存中的数据段。</p> </li><li> <p>多任务系统的一个操作 ：进程切换 （A进程切换到B进程）</p> </li><li> <p>CPU 和内存来来回回传数据，靠的都是总线。一个是地址数据，也就是我想拿内存中哪个位置的数据，这类总线叫地址总线 （Address Bus）；另一类是真正的数据，这类总线叫数据总线（Data Bus）</p> </li><li> <p>地址总线的位数，决定了能访问的地址范围到底有多广。例如只有两位，那 CPU 就只能认 00，01，10，11 四个位置，超过四个位置，就区分不出来了。位数越多，能够访问的位置 就越多，能管理的内存的范围也就越广。</p> </li><li> <p>CPU 数据总线和地址总线越来越宽，处理能力越来越强。但是一直不能忘记 三点，<code>一是标准，二是开放，三是兼容</code></p> </li></ul> 
<h2><a id="x86___13"></a>x86 架构</h2> 
<p><strong>下图是x86 86 中最经典的一款处理器 ， 8086处理器</strong><br> <img src="https://images2.imgbox.com/d5/61/H90RPP8L_o.png" alt="在这里插入图片描述"><br> <strong>重点 ： 寄存器的作用</strong></p> 
<ul><li><code>8086 处理器内部</code>有 <code>8 个 16</code> 位的通用寄存器，也就是刚才说的 CPU 内部 的数据单元，分别是 <code>AX、BX、CX、DX、SP、BP、SI、DI</code>。这些寄存器主要用于在计算过 程中暂存数据。这些寄存器比较灵活，其中<code> AX、BX、CX、DX</code> 可以分成两个 8 位的寄存器来使用，分别 是<code> AH、AL、BH、BL、CH、CL、DH、DL，</code>其中 H 就是 High（高位），L 就是 Low（低位）的意思。</li><li><code>IP 寄存器/指令指针寄存器（Instruction Pointer Register)</code> :指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 <code>CPU</code> 的指令队列中，然后交给运算单元去执行。</li><li>切换进程：每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四 个 16 位的段寄存器<code>（ CS、DS、SS、ES）</code></li><li><code>CS</code> 就是代码段寄存器 , 通过它可以找到<code>代码</code>在内存中的位置</li><li><code>DS</code> 是数据段的寄存器 , 通过它可以找到<code>数据</code>在内存中的位置</li><li><code>SS</code> 是栈寄存器（Stack Register） : 数据的存取只 能从一端进行，秉承<code>后进先出</code>的原则，<code>push</code> 就是入栈，<code>pop</code> 就是出栈.凡是与<code>函数调用</code>相关的操作，都与栈紧密相关</li><li>运算中需要加载内存中的数据，需要通过 DS 找到内存中的数据，加载到通用寄存器 中, 对于一个段，有一个起始的地址，而段内的具体位置，我们称为偏移 量（Offset）。 CS 和 DS 都是 16 位的，也就是说，起始地址都是 16 位的。</li><li>方法：*<em>起始地址 <em>16+ 偏移量</em></em></li><li>8086 的地址总线地址是 20 位，也就是把 CS 和 DS 中的值左 移 4 位，变成 20 位的，加上 16 位的偏移量，这样就可以得到最终 20 位的数据地址 。 20位 == <code>2^20^ = 1M</code> 超过这个空间就访问 只能访问这个空间内的位置。</li></ul> 
<h2><a id="32__26"></a>32 位处理器</h2> 
<p><img src="https://images2.imgbox.com/7a/63/bBKGdLG4_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在 32 位处理器中， 有 32 根地址总线，可以访问 2^32=4G 的内存。</li><li>“开放” : 意味着有大量其他公司的软硬件是基于这个架构来实现的 ， 存在限制</li><li>“兼容” : 8 个 16 位的扩展到 8 个 32 位的 。 个数不变 只扩展了空间 。</li><li>段寄存器：弄了一个不上不下的 20 位的地址 ， 这 样每次都要左移四位，也就意味着段的起始地址不能是任何一个地方，只是能整除 16 的地 方。</li><li>CS、SS、DS、ES 仍然是 16 位的。表格中的一项一项是段描述 符（Segment Descriptor）。这里面才是真正的段的起始地址。而段寄存器里面保存的是 在这个表格中的哪一项，称为选择子（Selector）。 16位以及不是以前的初始位置了。</li><li>表格中的一项一项是段描述符（Segment Descriptor）。这里面才是真正的段的起始地址。而段寄存器里面保存的是 在这个表格中的哪一项，称为选择子（Selector）。</li><li><strong>实模式（Real Pattern）: 从段寄存器直接拿到的段起始地址。</strong></li><li><strong>保护模式（Protected Pattern) : 先间接地从段寄存器找到表格中 的一项，再从表格中的一项中拿到段起始地址。</strong></li></ul> 
<p><img src="https://images2.imgbox.com/09/ce/63K1tkSu_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>系统刚刚启动 的个体户模式</p> 
</blockquote> 
<h2><a id="BIOS__42"></a>BIOS 时期</h2> 
<p><img src="https://images2.imgbox.com/f8/91/s2GQpBJ6_o.png" alt="在这里插入图片描述" height="300"></p> 
<blockquote> 
 <p>如果你自己安装过操作系统，刚启动的时候，按某个组合键，显示器会弹出一个蓝色的界 面。能够调整启动顺序的系统，就是我说的 BIOS，然后我们就可以先执行它。</p> 
</blockquote> 
<ul><li>在主板上，有一个东西叫ROM（Read Only Memory，只读存储器）</li><li>内存RAM（Random Access Memory，随机存取存储器）</li><li>BIOS（Basic Input and Output System，基本输入输出系统）<br> <img src="https://images2.imgbox.com/15/5a/tTObdRKi_o.png" alt="在这里插入图片描述" height="300"><br> 在 x86 系统中，将 1M 空间最上面的 0xF0000 到 0xFFFFF 这 64K 映射给 ROM, 启动电脑的时候 会进行重置 将 CS 设置为 0xFFFF，将 IP 设置为 0x0000，所以第一条指令就会指向 0xFFFF0，正是在 ROM 的范围内。在这里，有一个 JMP 命令会跳到 ROM 中做初始化工作的代码，于是，BIOS 开始进行初始化的工作。</li></ul> 
<p>创业指导手册第一条，BIOS 要检查一下系统的硬件是不是都好着呢。<br> 创业指导手册第二条，要有个办事大厅，只不过自己就是办事员。这个时期你能提供的服务很简单，但也会有零星的客户来提要求。<br> 这个时候，要建立一个中断向量表和中断服务程序，因为现在你还要用键盘和鼠标，这些都 要通过中断进行的。</p> 
<p><img src="https://images2.imgbox.com/85/3a/nT0RacsQ_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="bootloader__58"></a>bootloader 时期</h2> 
<ul><li>Grub2（Grand Unified Bootloader Version 2） linux的一个工具，用于系统启动。</li><li><code>grub2-mkconfig -o /boot/grub2/grub.cfg</code> 来配置系统启动的选项</li></ul> 
<p><img src="https://images2.imgbox.com/6e/00/qRujIR81_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>使用 grub2-install /dev/sda，可以将启动程序安装到相应的位置。</p> </li><li> <p>grub2 第一个要安装的就是 boot.img，它由 boot.S 编译而成，一共 512 字节，正式安装 到启动盘的第一个扇区。这个扇区通常称为MBR（Master Boot Record，主引导记录 / 扇区）。</p> </li><li> <p>由于 512 个字节实在有限，boot.img 做不了太多的事情。它能做的最重要的一个事情就 是加载grub2 的另一个镜像 core.img（由 lzma_decompress.img、diskboot.img、kernel.img 和一系列的模块组成）。</p> <p><img src="https://images2.imgbox.com/e9/bc/kdynhz09_o.png" alt="在这里插入图片描述"></p> </li><li> <p>如果从硬盘启动的话，这个扇区里面是 diskboot.img，对应的代码是 diskboot.S。</p> </li><li> <p>boot.img 将控制权交给 diskboot.img 后，diskboot.img 的任务就是将 core.img 的其他 部分加载进来，先是解压缩程序 lzma_decompress.img，再往下是 kernel.img，最后是 各个模块 module 对应的映像。这里需要注意，它不是 Linux 的内核，而是 grub 的内核。</p> </li><li> <p>lzma_decompress.img 对应的代码是 startup_raw.S，本来 kernel.img 是压缩过的，现 在执行的时候，需要解压缩。</p> </li><li> <p>实模式： 1M 的地址空间 （只能满足比较小的程序）所以在真正的解压缩之前，lzma_decompress.img 做了一个重要的决定，就是调用 real_to_prot，切换到保护模式，这样就能在更大的寻址空间里面，加载更多的东西。</p> </li></ul> 
<h2><a id="_76"></a>从实模式切换到保护模式</h2> 
<p>切换到保护模式要干很多工作，大部分工作都与内存的访问方式有关。<br> 第一项是启用分段，就是在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择 子，指向某个段描述符，这样就能实现不同进程的切换了。第二项是启动分页。能够管理的 内存变大了，就需要将内存分成相等大小的块.<br> <img src="https://images2.imgbox.com/c4/1f/QJo7ki5S_o.png" alt="在这里插入图片描述" height="700"></p> 
<h2><a id="_82"></a>内核初始化</h2> 
<blockquote> 
 <p>内核的启动从入口函数 start_kernel() 开始。在 init/main.c 文件中，start_kernel 相当于 内核的 main 函数。打开这个函数，你会发现，里面是各种各样初始化函数 XXXX_init</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4c/e0/oh52zLdu_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在操作系统里面，先要有个创始进程，有一行指令<code>set_task_stack_end_magic(&amp;init_task)</code>。这里面有一个参数<code> init_task</code>，它的定义是<code> struct task_struct init_task = INIT_TASK(init_task)</code>。它是系统创建的第一个进程，我们称为<code>0</code> 号进程。这是唯一一个没有通过 <code>fork</code> 或者<code> kernel_thread</code> 产生的进程，是进程列表的第一个。</li><li>32位系统 <code>trap_init()</code>，里面设置了很多中断门（<code>Interrupt Gate</code>），用于处理各 种中断。其中有一个<code> set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)</code>， 这是系统调用的中断门。</li><li><code>mm_init() </code>就是用来初始化内存管理模块</li><li><code>sched_init() </code>就是用于初始化调度 模块</li><li><code>vfs_caches_init()</code> 会用来初始化基于内存的文件系统 <code>rootfs</code>。为了兼容各种各样的文件系统，我们需要将文件的相关数据 结构和操作抽象出来，形成一个抽象层对上提供统一的接口，这个抽象层就是 <code>VFS（Virtual File System）</code>，虚拟文件系统。</li><li>1 号进程对于操作系统来讲,有“划时代”的意义。因为它将运行一个用户进程，然后会继承很多子进程，形成一棵进程树。 有了进程也就有了权限</li><li><code> x86</code> 提供了分层的权限机制,把区域分成了四个 Ring，越往里权限越高，越往外权限越低.</li></ul> 
<p><img src="https://images2.imgbox.com/95/7f/k7KAngif_o.png" alt="在这里插入图片描述"><br> 操作系统很好地利用了这个机制，将能够访问关键资源的代码放在 Ring0，我们称为内核态（Kernel Mode）；将普通的程序代码放在 Ring3，我们称为用户态（User Mode)</p> 
<p><img src="https://images2.imgbox.com/89/e9/ObVAftCv_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>当一个用户态的程序运行到一半，要访问一个核心资源，例如访问网卡发一个网络包，就需 要暂停当前的运行，调用系统调用，接下来就轮到内核中的代码运行了。<br> 首先，内核将从系统调用传过来的包，在网卡上排队，轮到的时候就发送。发送完了，系统 调用就结束了，返回用户态，让暂停运行的程序接着运行.<br> <img src="https://images2.imgbox.com/75/3c/DqXs6iKv_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="_106"></a>从内核态到用户态</h2> 
<p>kernel_thread 的参数是一个函数 kernel_init，也就是这个进程会运行这个函数。在 kernel_init 里面，会调用 kernel_init_freeable()，里面有这样的代码：</p> 
<pre><code class="prism language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ramdisk_execute_command<span class="token punctuation">)</span>  <span class="token comment">//如果不为空  就初始化</span>
 ramdisk_execute_command <span class="token operator">=</span> <span class="token string">"/init"</span><span class="token punctuation">;</span>

kernel_init<span class="token operator">:</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>ramdisk_execute_command<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 ret <span class="token operator">=</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span>ramdisk_execute_command<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/sbin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
 <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/etc/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
  <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
   <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
</code></pre> 
<ul><li>1 号进程运行的是一个文件。如果我们打开 run_init_process 函数，会发现它 调用的是 do_execve。execve 是一个系统调用，它的作 用是运行一个执行文件。加一个 do_ 的往往是内核系统调用的实现。没错，这就是一个系 统调用，它会尝试运行 ramdisk 的“/init”，或者普通文件系统上 的“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”。不同版本的 Linux 会选择不同的 文件启动，但是只要有一个起来了就可以,而咱们刚才运行 init，是调用 do_execve，正是上面的过程的后半部分，从内核态执行系统调用开始。</li></ul> 
<pre><code class="prism language-c"><span class="token comment">//do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler</span>
<span class="token keyword">int</span> <span class="token function">search_binary_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span>bprm<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token operator">*</span>fmt<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
retval <span class="token operator">=</span> fmt<span class="token operator">-&gt;</span><span class="token function">load_binary</span><span class="token punctuation">(</span>bprm<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我要运行一个程序，需要加载这个二进制文件,它是有一定格式的。Linux 下一个常用的格式是ELF（Executable and Linkable Format，可执行与可链接格式）。</p> 
<pre><code class="prism language-c"><span class="token comment">//二进制 格式</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> elf_format <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> 
<span class="token punctuation">.</span>module <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token punctuation">.</span>load_binary
<span class="token operator">=</span> load_elf_binary<span class="token punctuation">,</span> <span class="token punctuation">.</span>load_shlib <span class="token operator">=</span> load_elf_library<span class="token punctuation">,</span>
<span class="token punctuation">.</span>core_dump <span class="token operator">=</span> elf_core_dump<span class="token punctuation">,</span>
<span class="token punctuation">.</span>min_coredump <span class="token operator">=</span> ELF_EXEC_PAGESIZE<span class="token punctuation">,</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>




<span class="token keyword">void</span> <span class="token function">start_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> new_ip<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> new_sp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token function">set_user_gs</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// register，就是寄存器</span>
regs<span class="token operator">-&gt;</span>fs<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
regs<span class="token operator">-&gt;</span>ds<span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>  <span class="token comment">//设置为用户态</span>
regs<span class="token operator">-&gt;</span>es <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span> 
regs<span class="token operator">-&gt;</span>ss <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span> 
regs<span class="token operator">-&gt;</span>cs <span class="token operator">=</span> __USER_CS<span class="token punctuation">;</span> 
regs<span class="token operator">-&gt;</span>ip  <span class="token operator">=</span> new_ip<span class="token punctuation">;</span>  <span class="token comment">//恢复</span>
regs<span class="token operator">-&gt;</span>sp  <span class="token operator">=</span> new_sp<span class="token punctuation">;</span>  <span class="token comment">// 恢复</span>
regs<span class="token operator">-&gt;</span>flags<span class="token operator">=</span> X86_EFLAGS_IF<span class="token punctuation">;</span>
<span class="token function">force_iret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL_GPL</span><span class="token punctuation">(</span>start_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
<p>**ramdisk 的作用:**内核就太大了，需要一个基于内存的文件系统,内存访问是不需要驱动的，这个就是 ramdisk。 这个时候，ramdisk 是根文件系统。ramdisk 上的 /init 会启动文件系统上的 init ,形成了用户态所有进程的祖 先</p> 
<p><strong>2号进程:</strong></p> 
<ul><li>rest_init 第二大事情就是第三个进程，就是 2 号进程。<code>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)</code> 又一次使用 <code>kernel_thread</code> 函数创建进程。</li><li>函数名 thread 可以翻译成“线程”</li><li>有多个人并 行执行不同的部分，这就叫多线程（Multithreading）,如果只有一个人，那它就是这个 项目的主线程。</li><li>从内核态来看，无论是进程，还是线程，我们都可以统称为任务（Task），都使用相 同的数据结构，平放在同一个链表中。</li><li>函数 kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</li></ul> 
<h2><a id="glibc__171"></a>glibc 对系统调用的封装</h2> 
<blockquote> 
 <p>Linux 还提供了glibc 这个中介。它更熟悉系统调用的细节，并且可以封装成更加友好的接口。</p> 
</blockquote> 
<ul><li>glibc 里面的 open 函数<code>int open(const char *pathname, int flags, mode_t mode)</code></li><li>在 glibc 的源代码中，有个文件 <code>syscalls.list</code>，里面列着所有 <code>glibc</code> 的函数对应的系统调用。 (下图只显示 open 的)<br> <img src="https://images2.imgbox.com/86/ad/RjFCJpNf_o.png" alt="在这里插入图片描述"></li><li>glibc 还有一个脚本 <code>make-syscall.sh.</code>可以根据上面的配置文件，对于每一个封装 好的系统调用，生成一个文件。这个文件里面定义了一些宏，例如 <code>#define SYSCALL_NAME open</code></li></ul> 
<pre><code class="prism language-c"><span class="token function">T_PSEUDO</span> <span class="token punctuation">(</span>SYSCALL_SYMBOL<span class="token punctuation">,</span> SYSCALL_NAME<span class="token punctuation">,</span> SYSCALL_NARGS<span class="token punctuation">)</span> ret  <span class="token comment">//伪代码  符号 名字  参数</span>
<span class="token function">T_PSEUDO_END</span> <span class="token punctuation">(</span>SYSCALL_SYMBOL<span class="token punctuation">)</span> #define <span class="token function">T_PSEUDO</span><span class="token punctuation">(</span>SYMBOL<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> N<span class="token punctuation">)</span>
<span class="token function">PSEUDO</span> <span class="token punctuation">(</span>SYMBOL<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> N<span class="token punctuation">)</span>

PSEUDO 也是一个宏

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PSEUDO</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token punctuation">.</span>text<span class="token punctuation">;</span></span></span>
<span class="token function">ENTRY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token function">DO_CALL</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> 
cmpl $<span class="token operator">-</span><span class="token number">4095</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax<span class="token punctuation">;</span>
jae SYSCALL_ERROR_LABEL 

</code></pre> 
<ul><li>里面对于任何一个系统调用，会调用 DO_CALL。这也是一个宏，这个宏 32 位和 64 位的 定义是不一样的</li></ul> 
<h3><a id="32__196"></a>32 位系统调用过程</h3> 
<p><img src="https://images2.imgbox.com/3e/d5/5dNqBGNa_o.png" alt="在这里插入图片描述"></p> 
<ul><li><code>ENTER_KERNEL : # define ENTER_KERNEL int $0x80 </code> int 就是 interrupt，也就是“中断”的意思。int $0x80 就是触发一个软中断，通过它就可以陷入（trap）内核.</li></ul> 
<pre><code class="prism language-c"><span class="token function">set_system_intr_gate</span><span class="token punctuation">(</span>IA32_SYSCALL_VECTOR<span class="token punctuation">,</span> entry_INT80_32<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 系统启动时的 trap_init</span>


<span class="token function">ENTRY</span><span class="token punctuation">(</span>entry_INT80_32<span class="token punctuation">)</span><span class="token comment">//接收到一个系统调用的时候，entry_INT80_32 就被调用了</span>
        ASM_CLAC
        pushl   <span class="token operator">%</span>eax                    <span class="token comment">/* pt_regs-&gt;orig_ax */</span>
        SAVE_ALL pt_regs_ax<span class="token operator">=</span>$<span class="token operator">-</span>ENOSYS    <span class="token comment">/* save rest */</span> <span class="token comment">//通过 push 和 SAVE_ALL 将当前用户态的寄存器，保存在 pt_regs 结构里面。</span>
        movl    <span class="token operator">%</span>esp<span class="token punctuation">,</span> <span class="token operator">%</span>eax  <span class="token comment">//内核之前，保存所有的寄存</span>
        call    do_syscall_32_irqs_on  <span class="token comment">// 调用 do_syscall_32_irqs_on</span>
<span class="token comment">/*
//下面是  do_syscall_32_irqs_on

static __always_inline void do_syscall_32_irqs_on(struct pt_regs *regs)  //
{
	struct thread_info *ti = current_thread_info();
	unsigned int nr = (unsigned int)regs-&gt;orig_ax; // 将系统调用号从 eax 里面取出来
......
	if (likely(nr &lt; IA32_NR_syscalls)) {
	//然后根据系统调用号，在系统调用 表中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。
		regs-&gt;ax = ia32_sys_call_table[nr](  //#define ia32_sys_call_table sys_call_table，系统调用就是放在这个表里 面。
			(unsigned int)regs-&gt;bx, (unsigned int)regs-&gt;cx,
			(unsigned int)regs-&gt;dx, (unsigned int)regs-&gt;si,
			(unsigned int)regs-&gt;di, (unsigned int)regs-&gt;bp);
	}
	syscall_return_slowpath(regs);
}

*/</span>
<span class="token punctuation">.</span>Lsyscall_32_done<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span>Lirq_return<span class="token operator">:</span>
	INTERRUPT_RETURN  <span class="token comment">//紧接着调用的是 INTERRUPT_RETURN，我们能够找到它的定义，也就是 iret。</span>
	<span class="token comment">//#define INTERRUPT_RETURN iret</span>
<span class="token comment">//iret 指令将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等。这时候用户 态进程恢复执行。</span>
</code></pre> 
<p>32 位的系统调用的执行过程<br> <img src="https://images2.imgbox.com/b4/d0/oIKgSC50_o.png" alt="在这里插入图片描述" height="400"></p> 
<h2><a id="64_237"></a>64位</h2> 
<blockquote> 
 <p>x86_64 下的 sysdep.h 文件</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">/* The Linux/x86-64 kernel expects the system call parameters in
   registers according to the following table:
    syscall number	rax
    arg 1		rdi
    arg 2		rsi
    arg 3		rdx
    arg 4		r10
    arg 5		r8
    arg 6		r9
......
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DO_CALL</span><span class="token expression"><span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>					      </span><span class="token punctuation">\</span>
  <span class="token expression">lea <span class="token function">SYS_ify</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax<span class="token punctuation">;</span>					      </span><span class="token punctuation">\</span>
  <span class="token expression">syscall</span></span>
</code></pre> 
<p><code>与32位的区别 放到寄存器 rax</code></p> 
<ul><li>在系统初始化的时候，<code>trap_init</code> 除了初始化上面的中断模式，这里面还会调用 <code>cpu_init&gt;syscall_init。</code>这里面有这样的代码：`</li></ul> 
<pre><code class="prism language-c"><span class="token function">wrmsrl</span><span class="token punctuation">(</span>MSR_LSTAR<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>entry_SYSCALL_64<span class="token punctuation">)</span><span class="token punctuation">;</span>  

rdmsr 和 wrmsr 是用来读写特殊模块寄存器 的
MSR_LSTAR  一个特殊的寄存器专门用来做系统调用

entry_SYSCALL_64 如下
<span class="token function">ENTRY</span><span class="token punctuation">(</span>entry_SYSCALL_64<span class="token punctuation">)</span>
        <span class="token comment">/* Construct struct pt_regs on stack */</span>
<span class="token comment">//这里先保存了很多寄存器到 pt_regs 结构里面，例如用户态的代码段、数据段、保存参数 的寄存器</span>
        pushq   $__USER_DS                      <span class="token comment">/* pt_regs-&gt;ss */</span> 
        pushq   <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>rsp_scratch<span class="token punctuation">)</span>        <span class="token comment">/* pt_regs-&gt;sp */</span>
        pushq   <span class="token operator">%</span>r11                            <span class="token comment">/* pt_regs-&gt;flags */</span>
        pushq   $__USER_CS                      <span class="token comment">/* pt_regs-&gt;cs */</span>
        pushq   <span class="token operator">%</span>rcx                            <span class="token comment">/* pt_regs-&gt;ip */</span>
        pushq   <span class="token operator">%</span>rax                            <span class="token comment">/* pt_regs-&gt;orig_ax */</span>
        pushq   <span class="token operator">%</span>rdi                            <span class="token comment">/* pt_regs-&gt;di */</span>
        pushq   <span class="token operator">%</span>rsi                            <span class="token comment">/* pt_regs-&gt;si */</span>
        pushq   <span class="token operator">%</span>rdx                            <span class="token comment">/* pt_regs-&gt;dx */</span>
        pushq   <span class="token operator">%</span>rcx                            <span class="token comment">/* pt_regs-&gt;cx */</span>
        pushq   $<span class="token operator">-</span>ENOSYS                        <span class="token comment">/* pt_regs-&gt;ax */</span>
        pushq   <span class="token operator">%</span>r8                             <span class="token comment">/* pt_regs-&gt;r8 */</span>
        pushq   <span class="token operator">%</span>r9                             <span class="token comment">/* pt_regs-&gt;r9 */</span>
        pushq   <span class="token operator">%</span>r10                            <span class="token comment">/* pt_regs-&gt;r10 */</span>
        pushq   <span class="token operator">%</span>r11                            <span class="token comment">/* pt_regs-&gt;r11 */</span>
        sub     $<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp                    <span class="token comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span>
        movq    <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
        testl   $_TIF_WORK_SYSCALL_ENTRY<span class="token operator">|</span>_TIF_ALLWORK_MASK<span class="token punctuation">,</span> <span class="token function">TASK_TI_flags</span><span class="token punctuation">(</span><span class="token operator">%</span>r11<span class="token punctuation">)</span>
        jnz     entry_SYSCALL64_slow_path <span class="token comment">//然后调用 entry_SYSCALL64_slow_pat-&gt;do_syscall_64  如下</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">/*调用 entry_SYSCALL64_slow_pat-&gt;do_syscall_64   和 32位的差不多
__visible void do_syscall_64(struct pt_regs *regs)
{
        struct thread_info *ti = current_thread_info();
        unsigned long nr = regs-&gt;orig_ax;  //从 rax 里面拿出系统调用号
......
        if (likely((nr &amp; __SYSCALL_MASK) &lt; NR_syscalls)) {
                regs-&gt;ax = sys_call_table[nr &amp; __SYSCALL_MASK](  //查表
                        regs-&gt;di, regs-&gt;si, regs-&gt;dx,
                        regs-&gt;r10, regs-&gt;r8, regs-&gt;r9);  //这些参数所对应的寄存器，和 Linux 的注释又是一样的。
        }
        syscall_return_slowpath(regs);
}
*/</span>
entry_SYSCALL64_slow_path<span class="token operator">:</span>
        <span class="token comment">/* IRQs are off. */</span>
        SAVE_EXTRA_REGS
        movq    <span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token operator">%</span>rdi
        call    do_syscall_64           <span class="token comment">/* returns with IRQs disabled */</span>
return_from_SYSCALL_64<span class="token operator">:</span>
	RESTORE_EXTRA_REGS
	TRACE_IRQS_IRETQ
	movq	<span class="token function">RCX</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rcx
	movq	<span class="token function">RIP</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
    movq	<span class="token function">R11</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
syscall_return_via_sysret<span class="token operator">:</span>
	<span class="token comment">/* rcx and r11 are already restored (see code above) */</span>
	RESTORE_C_REGS_EXCEPT_RCX_R11
	movq	<span class="token function">RSP</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
	USERGS_SYSRET64  <span class="token comment">//64 位的系统调用返回的时候，执行的是 USERGS_SYSRET64</span>
	<span class="token comment">//#define USERGS_SYSRET64 swapgs; sysretq; 返回用户态的指令变成了 sysretq。</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/14/17/s6qVOaQ4_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_325"></a>系统调用表</h2> 
<p>系统调用的方式，都是最终到了系统调用表，但是到底调用内核的什么函数?<br> 32 位的系统调用表定义在面 arch/x86/entry/syscalls/syscall_32.tbl 文件里。例如 open 是这样定义的：</p> 
<pre><code class="prism language-c"><span class="token number">5</span> i386 open sys_open compat_sys_open
</code></pre> 
<p>64 位的系统调用定义在另一个文件 arch/x86/entry/syscalls/syscall_64.tbl 里。例如 open 是这样定义的</p> 
<pre><code class="prism language-c"><span class="token number">2</span> common open sys_open
</code></pre> 
<p>第一列的数字是系统调用号。32 位和 64 位的系统调用号是不一样的。第三列是系统调用的名字，第四列是系统调用在内核的实现函数。不<br> 过，它们都是以 sys_ 开头</p> 
<ul><li>系统调用在内核中的实现函数要有一个<code>声明</code>。声明往往在 <code>include/linux/syscalls.h </code>文件 中。</li></ul> 
<pre><code class="prism language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">umode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>真正的<code>实现</code>这个系统调用，一般在一个.c 文件里面，例如 sys_open 的实现在 fs/open.c 里面</li></ul> 
<pre><code class="prism language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token class-name">umode_t</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">//SYSCALL_DEFINE3 是一个宏系统调用最多六个参数 (3也是宏的参数)，根据参数的数目选择宏</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在编译的过程中，需要根据 syscall_32.tbl 和 syscall_64.tbl 生成自己的 unistd_32.h 和 unistd_64.h。生成方式在 arch/x86/entry/syscalls/Makefile 中。<br> 这里面会使用两个脚本，其中第一个脚本 arch/x86/entry/syscalls/syscallhdr.sh，会在文 件中生成 #define __NR_open；第二个脚本 arch/x86/entry/syscalls/syscalltbl.sh，会在 文件中生成 __SYSCALL(__NR_open, sys_open)。这样，unistd_32.h 和 unistd_64.h 是对 应的系统调用号和系统调用实现函数之间的对应关系。</p> 
<p><img src="https://images2.imgbox.com/20/dd/XOL7fov4_o.png" alt="在这里插入图片描述"><br> 64位的系统调用 + 内核态和用户态的模式切换<br> <img src="https://images2.imgbox.com/fd/32/XCkIpcuW_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f7/51/da1bUYxb_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f812b9fa0ebd31af83b886f53165046/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MyBatis-Plus 字段为Null时不更新解决方案，MyBatis-Plus 更新空字段</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf6e3c8f577acfb052c9c663f62efd16/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">监督学习中判别式模型和生成式模型的区别 | 无监督学习的生成模型GAN、VAE（生成样本）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>