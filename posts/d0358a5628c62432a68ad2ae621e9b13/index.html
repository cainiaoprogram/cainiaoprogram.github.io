<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[C语言]中，为什么整型数据以浮点型输出（或浮点数类型的数据以整型输出），其输出的结果与我们预期的大相径庭？这篇博客，带你拨开云雾见月明。 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[C语言]中，为什么整型数据以浮点型输出（或浮点数类型的数据以整型输出），其输出的结果与我们预期的大相径庭？这篇博客，带你拨开云雾见月明。" />
<meta property="og:description" content="在我们学习C语言的过程中，可能会出现这样的情况：我们定义了一个整型数据，想以浮点型输出，结果却不是我们预想的那样。比如：
#include&lt;stdio.h&gt; int main() { int a = 7; float* pFloat = (float*)&amp;a; printf(&#34;a的值为：%d\n&#34;, a); printf(&#34;*pFloat的值为:%f\n&#34;, *pFloat); *pFloat = 7.0; printf(&#34;a的值为：%d\n&#34;, a); printf(&#34;*pFloat的值为:%f\n&#34;, *pFloat); return 0; } 我们预想的结果应该是 ：7 7.000000 7 7.000000
但是天不遂人愿，程序输出的结果如下：
这样的输出结果，肯定是有原因的。我们可以设想：有没有可能，是因为int和float的存储方式不同呢？
答案确实是这样。
根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成以下形式：
(-1)^S * M * 2^E
(-1)^S 表示符号位，当S=0，V为正数；当S=1，V为负数。
M表示有效数字，大于等于1，小于2
2^E表示指数位
现在我们就来仔细研究一下这个式子（(-1)^S * M * 2^E）到底是什么意思。
在看完以上这个例子之后，相信你对浮点数的表示已经有了一定的理解。
那么，理解了浮点数的表示形式之后，它又是怎么存储的呢？
IEEE 754规定：
对于32位的浮点数，最高的1位是符号位S,接着的8位是指数E，剩下的23位为有效数字M。
对于64位的浮点数，最高的1位是符号位S,接着的11位是指数E，剩下的52位为有效数字M。
我们这里主要讨论单精度浮点数。对于双精度浮点数来说，原理相同。
IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的小数部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。
至于指数E，情况就比较复杂。
首先，E为一个无符号整数（unsigned int）。
这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10&#43;127=137，即10001001。
对于E来说，
E不全为0或不全为1 这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将
有效数字M前加上第一位的1。
比如：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d0358a5628c62432a68ad2ae621e9b13/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-22T16:30:59+08:00" />
<meta property="article:modified_time" content="2023-02-22T16:30:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[C语言]中，为什么整型数据以浮点型输出（或浮点数类型的数据以整型输出），其输出的结果与我们预期的大相径庭？这篇博客，带你拨开云雾见月明。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在我们学习C语言的过程中，可能会出现这样的情况：我们定义了一个整型数据，想以浮点型输出，结果却不是我们预想的那样。比如：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	int a = 7;
	float* pFloat = (float*)&amp;a;

	printf("a的值为：%d\n", a);
	printf("*pFloat的值为:%f\n", *pFloat);

	*pFloat = 7.0;
	printf("a的值为：%d\n", a);
	printf("*pFloat的值为:%f\n", *pFloat);

	return 0;
}</code></pre> 
<p>我们预想的结果应该是 ：7  7.000000   7  7.000000</p> 
<p>但是天不遂人愿，程序输出的结果如下：</p> 
<p><img src="https://images2.imgbox.com/dd/e9/xjPZaFBv_o.png" alt="8580cc3320ab468ca60d776718ddc284.png"></p> 
<p> </p> 
<p> 这样的输出结果，肯定是有原因的。我们可以设想：有没有可能，是因为int和float的存储方式不同呢？</p> 
<p>答案确实是这样。</p> 
<hr> 
<p>根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成以下形式：</p> 
<p><strong>(-1)^S * M * 2^E</strong></p> 
<p> </p> 
<p><strong>(-1)^S</strong>  表示符号位，当S=0，V为正数；当S=1，V为负数。</p> 
<p><strong>M</strong>表示有效数字，大于等于1，小于2</p> 
<p><strong>2^E</strong>表示指数位</p> 
<hr> 
<p>现在我们就来仔细研究一下这个式子（<strong>(-1)^S * M * 2^E</strong>）到底是什么意思。</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/35/db/o8ts1n28_o.png" alt="08b668433d0e4091ab84161c20031cb8.png"></p> 
<p> 在看完以上这个例子之后，相信你对浮点数的表示已经有了一定的理解。</p> 
<hr> 
<p>那么，理解了浮点数的表示形式之后，它又是怎么<strong>存储</strong>的呢？</p> 
<p>IEEE 754规定：</p> 
<p><strong>对于32位的浮点数，最高的1位是符号位S,接着的8位是指数E，剩下的23位为有效数字M。</strong></p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/0d/dd/7PLgsj92_o.png" alt="bb2a83ae5322495ba2a3febb8a43e0b7.png"></p> 
<p> <strong>对于64位的浮点数，最高的1位是符号位S,接着的11位是指数E，剩下的52位为有效数字M。</strong></p> 
<p>我们这里主要讨论单精度浮点数。对于双精度浮点数来说，原理相同。</p> 
<hr> 
<p>IEEE 754规定，<strong>在计算机内部保存M时</strong>，默认这个数的第一位总是1，因此可以被舍去，只保存后面的小数部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。</p> 
<p>至于<strong>指数E</strong>，情况就比较复杂。<br> 首先，E为一个无符号整数（unsigned int）。<br> 这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是<strong>127</strong>；对于11位的E，这个中间数是<strong>1023</strong>。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。<br>  </p> 
<p><strong>对于E来说，</strong></p> 
<ul><li><strong>E不全为0或不全为1</strong></li></ul> 
<p>这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将<br> 有效数字M前加上第一位的1。<br> 比如：<br> 0.5（1/2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为<br> 1.0*2^(-1)，其阶码为-1+127=126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进制表示形式为:</p> 
<p style="text-align:center;">0 01111110 00000000000000000000000</p> 
<p> </p> 
<p> </p> 
<ul><li><strong>E全为0</strong></li></ul> 
<p>这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</p> 
<p> </p> 
<ul><li><strong>E全为1</strong></li></ul> 
<p>这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）。</p> 
<hr> 
<p>那么，我们回到一开始的代码。</p> 
<p><img src="https://images2.imgbox.com/73/80/XjdCFLNN_o.png" alt="8580cc3320ab468ca60d776718ddc284.png"></p> 
<p> </p> 
<p><img src="https://images2.imgbox.com/4c/1c/sQfq5Pgq_o.png" alt="23db74cae44d41cfaf9aca047fc4f519.png"></p> 
<p><strong>这就是用%f来输出整型7时，结果为0.000000的原因。</strong></p> 
<hr> 
<p><strong> 下面则是用%d来输出浮点型7.0时，结果为1088421888的原因。</strong></p> 
<p style="text-align:center;"><strong><img src="https://images2.imgbox.com/01/e3/j3HRyL35_o.png" alt="4f24b91c26624e7bbfa2eccbfff06282.png"></strong><br>  </p> 
<p>相信你已经对C语言中浮点数存储规则有了更加深入的了解。</p> 
<p>我们在使用C语言时，需要多加注意，避免出现这类错误。</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e74fb79164df655013434e13c9a608e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软件测试/测试开发 | 黑盒测试方法论—等价类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/210c16c6d2e70f9e91ed760adb2954c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">免费html5 css3大学生网页设计期末作业 网页制作作业成品</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>