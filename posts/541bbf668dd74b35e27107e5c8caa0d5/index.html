<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>if __name__ = &#39;__main__&#39;，python 主程序入口 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="if __name__ = &#39;__main__&#39;，python 主程序入口" />
<meta property="og:description" content="摘要 通俗的理解name == ‘main‘：假如你叫小明.py，在朋友眼中，你是小明(name == ‘小明’)；在你自己眼中，你是你自己(name == ‘main‘)。
if name == ‘main‘的意思是：当.py文件被直接运行时，if name == ‘main‘之下的代码块将被运行；当.py文件以模块形式被导入时，if name == ‘main‘之下的代码块不被运行。
程序入口 对于很多编程语言来说，程序都必须要有一个入口，比如C，C&#43;&#43;，以及完全面向对象的编程语言Java，C#等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C，C&#43;&#43;都需要有一个main函数作为程序的入口，也就是程序的运行会从main函数开始。同样，Java，C#必须要有一个包含Main方法的主类，作为程序入口。
而Python则不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。
一个Python源码文件（.py）除了可以被直接运行外，还可以作为模块（也就是库），被其他.py文件导入。不管是直接运行还是被导入，.py文件的最顶层代码都会被运行（Python用缩进来区分代码层次），而当一个.py文件作为模块被导入时，我们可能不希望一部分代码被运行。
2.1 一个.py文件被其他.py文件引用
假设我们有一个const.py文件，内容如下：
PI = 3.14 def main(): print(&#34;PI:&#34;, PI) main() # 运行结果：PI: 3.14 1 2 3 4 5 6 7 8 现在，我们写一个用于计算圆面积的area.py文件，area.py文件需要用到const.py文件中的PI变量。从const.py中，我们把PI变量导入area.py：
from const import PI def calc_round_area(radius): return PI * (radius ** 2) def main(): print(&#34;round area: &#34;, calc_round_area(2)) main() &#39;&#39;&#39; 运行结果： PI: 3.14 round area: 12." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/541bbf668dd74b35e27107e5c8caa0d5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-07T00:52:48+08:00" />
<meta property="article:modified_time" content="2018-03-07T00:52:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">if __name__ = &#39;__main__&#39;，python 主程序入口</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ol><li>摘要</li></ol> 
<p>通俗的理解<strong>name</strong> == ‘<strong>main</strong>‘：假如你叫小明.py，在朋友眼中，你是小明(<strong>name</strong> == ‘小明’)；在你自己眼中，你是你自己(<strong>name</strong> == ‘<strong>main</strong>‘)。</p> 
<p>if <strong>name</strong> == ‘<strong>main</strong>‘的意思是：当.py文件被直接运行时，if <strong>name</strong> == ‘<strong>main</strong>‘之下的代码块将被运行；当.py文件以模块形式被导入时，if <strong>name</strong> == ‘<strong>main</strong>‘之下的代码块不被运行。</p> 
<ol><li>程序入口</li></ol> 
<p>对于很多编程语言来说，程序都必须要有一个入口，比如C，C++，以及完全面向对象的编程语言Java，C#等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C，C++都需要有一个main函数作为程序的入口，也就是程序的运行会从main函数开始。同样，Java，C#必须要有一个包含Main方法的主类，作为程序入口。</p> 
<p>而Python则不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。</p> 
<p>一个Python源码文件（.py）除了可以被直接运行外，还可以作为模块（也就是库），被其他.py文件导入。不管是直接运行还是被导入，.py文件的最顶层代码都会被运行（Python用缩进来区分代码层次），而当一个.py文件作为模块被导入时，我们可能不希望一部分代码被运行。</p> 
<p>2.1 一个.py文件被其他.py文件引用</p> 
<p>假设我们有一个const.py文件，内容如下：</p> 
<pre class="prettyprint"><code class=" hljs python">PI = <span class="hljs-number">3.14</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    print(<span class="hljs-string">"PI:"</span>, PI)

main()

<span class="hljs-comment"># 运行结果：PI: 3.14</span>
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span>
<span class="hljs-number">6</span>
<span class="hljs-number">7</span>
<span class="hljs-number">8</span></code></pre> 
<p>现在，我们写一个用于计算圆面积的area.py文件，area.py文件需要用到const.py文件中的PI变量。从const.py中，我们把PI变量导入area.py：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">from</span> const <span class="hljs-keyword">import</span> PI

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_round_area</span><span class="hljs-params">(radius)</span>:</span>
    <span class="hljs-keyword">return</span> PI * (radius ** <span class="hljs-number">2</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    print(<span class="hljs-string">"round area: "</span>, calc_round_area(<span class="hljs-number">2</span>))

main()

<span class="hljs-string">'''
运行结果：
PI: 3.14
round area:  12.56
'''</span>
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span>
<span class="hljs-number">6</span>
<span class="hljs-number">7</span>
<span class="hljs-number">8</span>
<span class="hljs-number">9</span>
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>
<span class="hljs-number">12</span>
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>
<span class="hljs-number">15</span></code></pre> 
<p>2.2 修改const.py，添加if <strong>name</strong> == “<strong>main</strong>”</p> 
<p>我们看到const.py中的main函数也被运行了，实际上我们不希望它被运行，因为const.py提供的main函数只是为了测试常量定义。这时if <strong>name</strong> == ‘<strong>main</strong>‘派上了用场，我们把const.py改一下，添加if <strong>name</strong> == “<strong>main</strong>“：</p> 
<pre class="prettyprint"><code class=" hljs python">PI = <span class="hljs-number">3.14</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    print(<span class="hljs-string">"PI:"</span>, PI)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span>
<span class="hljs-number">6</span>
<span class="hljs-number">7</span>
运行const.py，输出如下：

PI: <span class="hljs-number">3.14</span>
<span class="hljs-number">1</span>
运行area.py，输出如下：

round area:  <span class="hljs-number">12.56</span>
<span class="hljs-number">1</span></code></pre> 
<p>如上，我们可以看到if <strong>name</strong> == ‘<strong>main</strong>‘相当于Python模拟的程序入口，Python本身并没有这么规定，这只是一种编码习惯。由于模块之间相互引用，不同模块可能有这样的定义，而程序入口只有一个。到底哪个程序入口被选中，这取决于<strong>name</strong>的值。 </p> 
<ol><li><strong>name</strong></li></ol> 
<p>3.1 <strong>name</strong>反映一个包的结构</p> 
<p><strong>name</strong>是内置变量，可用于反映一个包的结构。假设我们有一个包a，包的结构如下：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">a
├── b
│   ├── c<span class="hljs-preprocessor">.py</span>
│   └── __init__<span class="hljs-preprocessor">.py</span>
└── __init__<span class="hljs-preprocessor">.py</span>
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span></code></pre> 
<p>在包a中，文件c.py，<strong>init</strong>.py，<strong>init</strong>.py的内容都为：</p> 
<p>print(<strong>name</strong>) <br> 1 <br> 当一个.py文件（模块）被其他.py文件（模块）导入时，我们在命令行执行</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver">python -c <span class="hljs-string">"import a.b.c"</span>
<span class="hljs-number">1</span>
输出结果：

<span class="hljs-operator">a</span>
<span class="hljs-operator">a</span>.b
<span class="hljs-operator">a</span>.b.c
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span></code></pre> 
<p>由此可见，<strong>name</strong>可以清晰地反映一个模块在包中的层次。</p> 
<p>3.2 <strong>name</strong>表示当前模块的名字</p> 
<p><strong>name</strong>是内置变量，可用于表示当前模块的名字。我们直接运行一个.py文件（模块）</p> 
<pre class="prettyprint"><code class=" hljs markdown">python a/b/c.py

输出结果：

<span class="hljs-strong">__main__</span>
</code></pre> 
<p>由此我们可知：如果一个.py文件（模块）被直接运行时，则其没有包结构，其<strong>name</strong>值为<strong>main</strong>，即模块名为<strong>main</strong>。</p> 
<p>所以，if <strong>name</strong> == ‘<strong>main</strong>‘的意思是：当.py文件被直接运行时，if <strong>name</strong> == ‘<strong>main</strong>‘之下的代码块将被运行；当.py文件以模块形式被导入时，if <strong>name</strong> == ‘<strong>main</strong>‘之下的代码块不被运行。</p> 
<ol><li><strong>main</strong>.py文件与python -m</li></ol> 
<p>Python的-m参数用于将一个模块或者包作为一个脚本运行，而<strong>main</strong>.py文件相当于是一个包的“入口程序“。</p> 
<p>4.1 运行Python程序的两种方式</p> 
<p>python xxx.py，直接运行xxx.py文件 <br> python -m xxx.py，把xxx.py当做模块运行 <br> 假设我们有一个文件run.py，内容如下：</p> 
<p>import sys</p> 
<p>print(sys.path) <br> 1 <br> 2 <br> 3 <br> 我们用直接运行的方式启动</p> 
<p>python run.py <br> 1 <br> 输出结果(为了说明问题，输出结果只截取了重要部分，下同)：</p> 
<p>[‘/home/huoty/aboutme/pythonstudy/main’, …] <br> 1 <br> 然后以模块的方式运行:</p> 
<p>python -m run.py <br> 1 <br> 输出内容</p> 
<p>[”, …] <br> /usr/bin/python: No module named run.py <br> 1 <br> 2 <br> 由于输出结果只列出了关键的部分，应该很容易看出他们之间的差异：</p> 
<p>直接运行方式是把run.py文件所在的目录放到了sys.path属性中</p> 
<p>以模块方式运行是把你输入命令的目录（也就是当前工作路径），放到了 sys.path 属性中。</p> 
<p>以模块方式运行还有一个不同的地方：多出了一行No module named run.py的错误。实际上以模块方式运行时，Python先对run.py执行一遍 import，所以print(sys.path)被成功执行，然后Python才尝试运行run.py模块，但是在path变量中并没有run.py这个模块，所以报错。正确的运行方式，应该是python -m run。</p> 
<p>4.2 <strong>main</strong>.py的作用</p> 
<p>仍然先看例子，假设我们有如下一个包package：</p> 
<p>package <br> ├── <strong>init</strong>.py <br> └── <strong>main</strong>.py <br> 1 <br> 2 <br> 3 <br> 其中，文件<strong>init</strong>.py的内容</p> 
<p>import sys</p> 
<p>print(“<strong>init</strong>“) <br> print(sys.path) <br> 1 <br> 2 <br> 3 <br> 4 <br> 其中，文件<strong>main</strong>.py的内容</p> 
<p>import sys</p> 
<p>print(“<strong>main</strong>“) <br> print(sys.path) <br> 1 <br> 2 <br> 3 <br> 4 <br> 接下来，我们运行这个package，使用python -m package运行，输出结果：</p> 
<p><strong>init</strong> <br> [”, …]</p> 
<p><strong>main</strong> <br> [”, …] <br> 1 <br> 2 <br> 3 <br> 4 <br> 5 <br> 使用python package运行，输出结果：</p> 
<p><strong>main</strong> <br> [‘package’, …] <br> 1 <br> 2 <br> 总结一下</p> 
<p>当加上-m参数时，Python会把当前工作目录添加到sys.path中；而不加-m时，Python则会把脚本所在目录添加到sys.path中。</p> 
<p>当加上-m参数时，Python会先将模块或者包导入，然后再执行。</p> 
<p><strong>main</strong>.py文件是一个包或者目录的入口程序。不管是用python package还是用python -m package运行，<strong>main</strong>.py文件总是被执行。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea41c3723abd156766b39ae92383abad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">webpack4——SplitChunksPlugin使用指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a59b3122638f11b01658de59733a70d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">蜂鸟速递-无人机快递智能系统 QT编写(含视频)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>