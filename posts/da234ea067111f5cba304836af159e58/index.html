<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构系列之如何判断链表有环 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构系列之如何判断链表有环" />
<meta property="og:description" content="给定一个链表，判断链表中是否有环。
为了表示给定链表中的环，我们使用证书pos来表示链表连接到链表中的位置（索引从0开始），如果pos是-1，则在该链表中没有环。
示例：
输入：head = [3,2,0,-4]，pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点
下面列举几种方法。
哈希表缓存 创建一个以节点id为key的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就用新节点和HashSet集合中存储的节点比较，如果发现HashSet中存在相同的节点，说明链表有环；如果不存在，就把这个新节点存入HashSet，继续进入下一个节点，重复之前的操作。
这种方法与穷举遍历的方法类似，区别是使用了HashSet作为额外的缓存。
public boolean hasCycle(ListNode head){ Set&lt;ListNode&gt; nodes = new HashSet&lt;&gt;(); //如果当前节点为null，说明已经遍历完整个链表 while(head != null){ if(nodes.contains(head)){ return true; } else { nodes.add(head); } head = head.next; } return false; } 复杂度 时间复杂度：O(n)，对于含有n个元素的链表，访问每个元素最多一次，添加一个节点到哈希表中只需要花费O(1)的时间。
空间复杂度：O(n)，取决于添加到哈希表中的元素数目，最多可以添加n个元素。
快慢指针（双指针） 举个例子：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当连个人跑了一段时间之后，速度快的运动员必然会从速度慢的运动员身后再次追上并超过。原因很简单，因为跑道是环形的。
创建两个指针（在java中就是两个对象引用），同时指向这个链表的头结点。指针1每次向后移动一个节点，指针2每次向后移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，说明链表有环；如果不同，继续往后走。
public boolean hasCycle(ListNode head){ if(head == null || head.next == null){ return false; } ListNode slow = head; ListNode fast = head." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/da234ea067111f5cba304836af159e58/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-24T22:58:13+08:00" />
<meta property="article:modified_time" content="2019-10-24T22:58:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构系列之如何判断链表有环</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>  给定一个链表，判断链表中是否有环。<br>   为了表示给定链表中的环，我们使用证书pos来表示链表连接到链表中的位置（索引从0开始），如果pos是-1，则在该链表中没有环。</p> 
<p>  示例：</p> 
<blockquote> 
 <p>输入：head = [3,2,0,-4]，pos = 1<br> 输出：true<br> 解释：链表中有一个环，其尾部连接到第二个节点<br> <img src="https://images2.imgbox.com/68/68/s1Dsn9yV_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  下面列举几种方法。</p> 
<h2><a id="_11"></a>哈希表缓存</h2> 
<p>  创建一个以节点id为key的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就用新节点和HashSet集合中存储的节点比较，如果发现HashSet中存在相同的节点，说明链表有环；如果不存在，就把这个新节点存入HashSet，继续进入下一个节点，重复之前的操作。<br>   这种方法与穷举遍历的方法类似，区别是使用了HashSet作为额外的缓存。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	Set<span class="token generics function"><span class="token punctuation">&lt;</span>ListNode<span class="token punctuation">&gt;</span></span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//如果当前节点为null，说明已经遍历完整个链表</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>nodes<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_30"></a>复杂度</h3> 
<p>  时间复杂度：O(n)，对于含有n个元素的链表，访问每个元素最多一次，添加一个节点到哈希表中只需要花费O(1)的时间。</p> 
<p>  空间复杂度：O(n)，取决于添加到哈希表中的元素数目，最多可以添加n个元素。</p> 
<h2><a id="_35"></a>快慢指针（双指针）</h2> 
<p>  举个例子：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当连个人跑了一段时间之后，速度快的运动员必然会从速度慢的运动员身后再次追上并超过。原因很简单，因为跑道是环形的。</p> 
<p>  创建两个指针（在java中就是两个对象引用），同时指向这个链表的头结点。指针1每次向后移动一个节点，指针2每次向后移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，说明链表有环；如果不同，继续往后走。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
	ListNode fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> null <span class="token operator">||</span> fast<span class="token punctuation">.</span>next <span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_57"></a>复杂度</h3> 
<p>  时间复杂度：O(n)，取决于链表的长度。</p> 
<p>  空间复杂度：O(1)，只使用了快指针和慢指针两个节点。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04bc3b5629193958ae8d4f54936f80e6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">tf.image.decode_jpeg(img).shape = (?,?,?)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e2ae46e6e9e13648d51e128d5ad4132/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器人学习笔记（1）导论</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>