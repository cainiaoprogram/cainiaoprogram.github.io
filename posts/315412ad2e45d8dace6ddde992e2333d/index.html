<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C# Socket实现两台电脑通信（二） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C# Socket实现两台电脑通信（二）" />
<meta property="og:description" content="来自哔哩哔哩课程https://www.bilibili.com/video/BV1FJ411W7e5?p=186 第181-186 一、服务器端
1.GUI使用到的控件及其命名(Name)：注意txtServer和txtPort中的Text参数默认设置为如图，也就是我们把地址和端口号默认为此，地址可以更改或设置为自动获取本机IP地址
2.Server的主程序
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; using System.Threading.Tasks; using System.Windows.Forms; namespace _181_Socket网络编程 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { try { //创建监听的Socket Socket socketWatch = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //创建IP地址和端口号对象 IPAddress ip = IPAddress.Any; //IPAddress.Parse(txtServer.Text); IPEndPoint point = new IPEndPoint(ip, Convert." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/315412ad2e45d8dace6ddde992e2333d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-11T19:08:11+08:00" />
<meta property="article:modified_time" content="2020-11-11T19:08:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C# Socket实现两台电脑通信（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>来自哔哩哔哩课程<a href="https://www.bilibili.com/video/BV1FJ411W7e5?p=186" rel="nofollow">https://www.bilibili.com/video/BV1FJ411W7e5?p=186</a>   第181-186 </p> 
<p>一、服务器端</p> 
<p>1.GUI使用到的控件及其命名(Name)：注意txtServer和txtPort中的Text参数默认设置为如图，也就是我们把地址和端口号默认为此，地址可以更改或设置为自动获取本机IP地址</p> 
<p><img alt="" height="426" src="https://images2.imgbox.com/34/11/zWJpuYSj_o.png" width="675"></p> 
<p>2.Server的主程序</p> 
<pre><code>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace _181_Socket网络编程
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void button1_Click(object sender, EventArgs e)
        {
            try
            {
                //创建监听的Socket
                Socket socketWatch = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                //创建IP地址和端口号对象
                IPAddress ip = IPAddress.Any; //IPAddress.Parse(txtServer.Text);
                IPEndPoint point = new IPEndPoint(ip, Convert.ToInt32(txtPort.Text));
                //让负责监听的Socket绑定IP地址和端口号
                socketWatch.Bind(point);

                ShowMsg("监听成功");

                //设置监听队列
                socketWatch.Listen(10);//某个时间段内 能够连入服务器的 最大 客户端数量

                Thread th = new Thread(Listen);//给socketWatch.Accept()开线程，防止程序假死
                th.IsBackground = true;
                th.Start(socketWatch);
            }
            catch
            {

            }
          
        }


        /// &lt;summary&gt;
        /// 等待客户端的连接 并创建与之通信的Socket
        /// &lt;/summary&gt;
        ///         
        Socket socketSend;//创建负责通讯的Socket
        void Listen(object o)
        {
            Socket socketWatch = o as Socket;//o转为Socket,否则返回null
            try
            {
                while (true)
                {
                    //等待客户端的连接 并创建一个负责通信的Socket           
                    socketSend = socketWatch.Accept();
                    ShowMsg(socketSend.RemoteEndPoint.ToString() + "连接成功");
                    //开启一个新线程  不停接收客户端发送过来的消息

                    //客户端连接成功之后，服务器接受客户端发来的消息
                    
                    /***只能接收一次 字符***/
                    //byte[] buffer = new byte[1024 * 1024 * 2];
                    //int r = socketSend.Receive(buffer);
                    //string str = Encoding.UTF8.GetString(buffer, 0, r);
                    //ShowMsg(socketSend.RemoteEndPoint + ":" + str);

                    Thread th = new Thread(Recive);
                    th.IsBackground = true;
                    th.Start(socketSend);

                }
            }
            catch
            {   }
           
        }
        /// &lt;summary&gt;
        /// 服务器端 不停接收 客户端 发送过来的消息
        /// &lt;/summary&gt;
        /// &lt;param name="o"&gt;&lt;/param&gt;
        void Recive(object o)
        {
            Socket socketSend = o as Socket;
            while(true)
            {
                try
                {
                    //客户端连接成功后，服务器应该接受客户端发来的消息
                    byte[] buffer = new byte[1024 * 1024 * 2];
                    //实际收到的有效数字节数
                    int r = socketSend.Receive(buffer);
                    if (r == 0)
                    {
                        break;
                    }
                    string str = Encoding.UTF8.GetString(buffer, 0, r);
                    ShowMsg(socketSend.RemoteEndPoint + ":" + str);
                }
                catch
                { }
            }
        }

        void ShowMsg(string str)
        {
            txtLog.AppendText(str + "\r\n");
        }

        private void txtServer_TextChanged(object sender, EventArgs e)
        {

        }

        private void Form1_Load(object sender, EventArgs e)
        {
            Control.CheckForIllegalCrossThreadCalls = false;
        }

        /// &lt;summary&gt;
        /// 服务器给客户端发送消息
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void btnSend_Click(object sender, EventArgs e)
        {
            string str = txtMsg.Text;
            byte[] buffer = System.Text.Encoding.UTF8.GetBytes(str);
            socketSend.Send(buffer);
        }

        private void btnSend1_Click(object sender, EventArgs e)
        {

        }
    }
}
</code></pre> 
<p>二、客户端</p> 
<p>1.注意客户端的地址和端口  要填写服务端的</p> 
<p><img alt="" height="440" src="https://images2.imgbox.com/61/5f/XjuRNYqA_o.png" width="724"></p> 
<p>2.Client的主程序</p> 
<p> </p> 
<pre><code>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace _184_Socket网络编程_Client
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            Control.CheckForIllegalCrossThreadCalls = false;
        }
        Socket socketSend;
        private void btnStart_Click(object sender, EventArgs e)
        {
            //创建负责通信的Socket
            socketSend = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            IPAddress ip = IPAddress.Parse(txtServer.Text);//远程服务器端的IP地址
            IPEndPoint point = new IPEndPoint(ip, Convert.ToInt32(txtPort.Text));//远程服务器端的端口号
            //获得要连接的远程服务器应用程序的IP地址和端口号
            socketSend.Connect(point);
            ShowMsg("连接成功");

            //开启 一个新的线程 不停的接收服务端发来的消息
            Thread th = new Thread(Receive);
            th.IsBackground = true;
            th.Start();

        }

        /// &lt;summary&gt;
        /// 不停 接收 服务端发来的消息
        /// &lt;/summary&gt;
        void Receive()
        {
            while(true)
            {
                byte[] buffer = new byte[1024 * 1024 * 3];
                //实际接收到的有效字节
                int r = socketSend.Receive(buffer);
                if (r == 0)
                {
                    break;
                }
                string s = Encoding.UTF8.GetString(buffer, 0, r);
                ShowMsg(socketSend.RemoteEndPoint + ":" + s);
            }
        }

        void ShowMsg(string str)
        {
            txtLog.AppendText(str + "\r\t");
        }
        
        /// &lt;summary&gt;
        /// 客户端给服务器发送消息
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void btnSend_Click(object sender, EventArgs e)
        {
            string str = txtMsg.Text.Trim();
            byte[] buffer = System.Text.Encoding.UTF8.GetBytes(str);
            socketSend.Send(buffer);
        }


    }
}</code></pre> 
<p>2020.11.11.在同一个解决方案下 完成通讯</p> 
<p> <img alt="" height="294" src="https://images2.imgbox.com/29/64/uQAtiSfj_o.png" width="288"></p> 
<p>2020.11.12</p> 
<p>          测试两台电脑间的通讯</p> 
<p>1、在电脑A中运行<img alt="" height="30" src="https://images2.imgbox.com/76/11/bgILj9ou_o.png" width="291">，并点击“开始监听”（监听成功，如下图）</p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/db/30/YEtPwiKu_o.png" width="753"><img alt="" height="476" src="https://images2.imgbox.com/40/12/fwjR5VKU_o.png" width="753"></p> 
<p>2、将在电脑A(IP：192.168.100.2）中编译通过的程序 拷贝到电脑B（IP:192.168.100.1)，并运行bin下的可执行文件Client.exe，点击连接，连接成功如图所示。</p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/15/93/vM21dRca_o.png" width="540">    <img alt="" height="410" src="https://images2.imgbox.com/56/af/a3vqv6TG_o.png" width="550">    <img alt="" height="414" src="https://images2.imgbox.com/75/64/PJYQ3Uky_o.png" width="668"></p> 
<p>3.服务端被电脑B（IP:192.168.100.1)连接成功</p> 
<p>.<img alt="" height="476" src="https://images2.imgbox.com/9a/1a/srvuL7Lp_o.png" width="753"></p> 
<p>4.Client.exe向服务器发送信息：今天是个好天气~123123~，服务端接收成功。</p> 
<p>ShowMsg(socketSend.RemoteEndPoint + ":" + s);//服务端接收代码中，RemoteEndPoint参数拿到对方电脑的point，并用s接收对方电脑发送过来的string，具体请看代码。</p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/76/0b/qYmTWCIZ_o.png" width="776">     <img alt="" height="476" src="https://images2.imgbox.com/57/20/15T4dnIR_o.png" width="753"></p> 
<p>5.同样，服务器也可以向客户端发送消息，客户端接收</p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/24/f6/BeGkeXIg_o.png" width="753">        <img alt="" height="498" src="https://images2.imgbox.com/9d/fd/l5qzzMPq_o.png" width="774"></p> 
<p>binggo~测试完毕，但是，感觉，仿佛昨天才照着写完，今天已经忘记，等我画个思维导图理一理！！！</p> 
<p>有空把代码放到百度云盘，想要的点赞，超过10个就发（卑微求赞），我感觉都没有人看的。欢迎私信交流~</p> 
<h3>给大家介绍两个好用的<span style="color:#e579b6;">socket测试用软件：SockerTool和telnet</span>，大家可以自行百度，如果时间允许，我也写一个简答易懂的教程给大家。</h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b1625dcada347df49506638b50b478a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">创建docker镜像并push到docker hub上</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46cdb5c57fda5ee88a149648fdcd7441/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">qemu-user-static：利用x86机器编译支持arm架构的docker镜像</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>