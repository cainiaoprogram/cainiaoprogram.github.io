<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动手学习深度学习——基本简介 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="动手学习深度学习——基本简介" />
<meta property="og:description" content="前言 一些建议：如果是深度学习刚刚入门，或者对深度学习的发展历史不是很熟悉的同学，可以认真读读本文，增加对该领域的背景，发展历史，应用领域的全面了解。
参考项目：《动手学习深度学习》，李沐，第二版。
英文原文：https://d2l.ai/chapter_introduction/index.html
注意：博文中的图片均来自英文原文。
1. 简介 直到最近，几乎我们接触到的每一个计算机程序都是软件开发人员根据第一性原理（First Principles）编写而成。比如，我们想编写一个应用程序来管理电子商务平台。在围绕白板思考几个小时后，我们可以得到大致的解决方案：（i）用户通过运行在网页浏览器或者移动应用程序界面与应用程序交互；（ii）我们的应用程序与商用级的数据库引擎交互，并追踪每一个用户的状态和维持历史的交易记录；（iii）在应用程序的核心，应用程序的业务逻辑(也可以说是大脑)以系统的方式详细说明了程序在每个可能的情况下应该采取的适当操作。
为了建立应用程序的大脑，我们不得不考虑每一个可能发生的情况，并制定适当的准则。每次客户点击添加商品到购物车，我们在购物车数据库表中添加一条记录，并且将用户的ID与产品的ID相关联。很少有开发者能够一次正确完成所有的功能（可能需要一些测试才能解决这些问题），大部分情况下，我们能够根据第一性原理写出这样一个程序，并在遇到真正的客户之前推出。我们能够根据第一性原理设计自动化系统，驱动功能性产品和系统，通常在新的情况下，这是一个了不起的认知壮举。当你能够解决所有的问题时，你就不必要使用机器学习。
幸运的是，对于不断增大的机器学习科学家团体，我们想要自动化的很多任务不是那么容易屈服于人类的聪明才智。想象一下，你和你所知道的最聪明的人挤在在白板前，但是这个时候你们正在解决下面问题中的一个：
编写一个程序，根据地理信息，卫星图像和过去天气的跟踪窗口，预测明天的天气。编写一个程序，输入为自由格式的文本问题，并且正确的回答。编写一个程序，输入一张图像，能够识别图片中包含的所有人，并且画出每一个人的轮廓。编写一个程序，呈现给用户喜欢的商品，但是在自然的浏览中又不会遇到。 上面遇到的每一种情况，尽管是优秀的程序员也没办法从零开始编写解决方案。原因可能有很多。有时候，我们正在寻找的程序遵循一个随着时间变化的模式，我们需要我们的程序来适应。在其他情况下，这种关系(比如像素和抽象类别之间的关系)可能过于复杂，需要进行成千上万次的计算，而这些计算超出了我们的意识理解能力，即使我们的眼睛可以毫不费力地完成这项任务。机器学习正是这种学习能力很强的技术，可以从经验中学习。随着机器学习算法积累更多的经验，通常以观察数据或与环境交互的形式，其性能得到提高。这与我们确定的电子商务平台对比鲜明，无论有多少数据出现，电子商务平台遵循的逻辑是不变的，直到开发者自身通过学习，进而更新软件。在本书中，我们将传授机器学习的基础，并聚焦于深度学习，一系列强大的技术推动了计算机视觉、自然语言处理、医疗保健和基因组学等领域的创新。
1.1. 一个激励人心的例子 在开始写作之前，像其它工作者一样，本书的作者不得不让自己兴奋起来。我们跳入车中，开始驾驶。使用iPhone手机，Alex 喊出 “Hey，Siri”，手机的语音识别系统被唤醒。然后，Mu 给出指令 “去蓝瓶咖啡店”。手机迅速展示了转录的指令。手机同时也识别了我们说话的内容是去咖啡店，并打开地图应用来满足我们的请求。一旦打开，地图APP识别一些路线。对于每一条路线，手机APP展示了预测的通勤时间。虽然我们编造这个故事是为了教学上的便利，但它表明，在短短几秒钟内，我们与智能手机的日常交互可以使用几种机器学习模型。
想象着写一个识别唤醒词（比如，Alexa，OK Google，Hey，Siri）的程序。在一个空的屋子里，试着只使用一台电脑和代码编辑器实现如 图1.1.1 的功能。你会根据第一原理如何编写程序？想想看，这个问题很难。每一秒，麦克风大概收集44000个样本。每个样本都是对声波振幅的测量。无论语音片段是否包含唤醒词，什么样的准则能够确信的将原始音频的一段映射为可靠的预测（yes，no）？如果你感觉到困难，不用担心。我们也不知道如何从零开始写这样的程序。这也就是为什么我们要使用机器学习。
这就是诀窍的所在。常常，尽管我们不知道如何明确地告诉电脑将输入映射为输出，但是，我们还是有能力完成这样的壮举。换句话说，尽管你不知道如何编程让电脑识别唤醒词，但是你自己是可以识别的。拥有这样的能力，我们可以收集大量的数据集，包含了语音样本和相应的标签（可能包含唤醒词，也可能没有包含）。在机器学习的方法中，我们不会尝试设计一个明确识别唤醒词的系统。相反地，我们定义可变的程序，它的表现是由参数决定的。然后，我们使用数据来决定最佳的参数集，这些参数可以提升我们的程序在某些感兴趣任务方面的性能。
你可以将参数视为我们可以调用的操作程序行为的旋钮。固定参数，我们将程序称为模型。所有不同程序（输入输出的映射）的集合可以通过调整参数进而得到不同的模型被称为模型族。使用我们的数据集来选择参数的元程序称为学习算法。
在我们着手使用学习算法之前，我们必须精确地定义问题，确定输入和输出的精确性质，并选择合适的模型族。在上面的例子中，我们的模型接收语音的一个片段作为输入，并在集合（yes，no）中选择一个作为输出。如果一切都按照计划进行，模型对输入片段是否包含唤醒词的猜测通常是正确的。
如果我们选择正确的模型家族，应该存在一个旋钮（参数）设置，每次听到单词“ Alexa”，模型会给出“yes”的输出。因为唤醒词的确切选择是任意的，我们可能需要一个足够丰富的模型家族，通过另一个旋钮设置，当听到单词“Apricot”，它可以输出“yes”。我们期望相同的模型族适合“ Alexa”识别和“ Apricot”识别，因为直观上看起来它们是相似的任务。然而，如果我们想要处理完全不同的输入或输出，比如我们想要从图像映射到字幕，或者从英语句子映射到中文句子，我们可能需要一个完全不同的模型族。
正如你猜测的一样，如果我们任意设置所有的“旋钮”，我们的模型可能无法识别“Alexa”，“Apricot”或者任何其它的英文单词。在机器学习中，学习是发现正确的“旋钮”设置，并强制模型达到我们期望的表现。换句话说，我们用数据训练模型。如 图1.1.2 所示，训练过程应该如下：
随机初始化模型的设置，此时模型无法得到任何有效的输出。抓取一些数据（比如，语音片段和相应的{yes，no}标签）。调整旋钮（参数设置），使得模型相对于那些例子来说不那么糟糕。重复步骤2-步骤3，直到模型表现很好，达到预期的结果。 总而言之，如果我们给它提供一个大的带标签数据集，与其编写唤醒词识别程序，不如编写一个程序来学习如何识别唤醒词。你可以将这种用数据集决定程序行为的方式看作是用数据编程。也就是说，我们可以通过给我们的机器学习系统提供许多猫和狗的例子来“编写”一个猫检测器。通过这种方式，如果它是一只猫，检测器最终将学会给出一个非常大的正数，如果它是一只狗，则给出一个非常大的负数，如果不确定是什么动物，则给出一个接近于零的数，这仅仅触及了机器学习能做什么的表面。深度学习只是解决机器学习问题的众多流行方法之一，我们将在后面更详细地解释。
1.2. 关键组件 在我们的唤醒词例子中，我们描述了包含语音片段和二值标签的数据集，我们还粗略介绍了如何训练模型来近似一个从语音片段到分类的映射。基于包含数据样本和标签的数据集，训练一个模型可以在指定输入，没有标签的情况下，给出合适的预测结果，称之为监督学习。这些只是众多机器学习中的一种。后面，我们会深度研究不同的机器学习问题。首先，无论遇到什么样的机器学习问题，我们都需要更多了解下核心组件：
用于学习的数据。用于转换数据的模型。用于评估模型优劣的目标函数。用于调整模型参数的算法，进而优化目标函数。 1.2.1. 数据 毫无疑问，没有数据就没法进行数据科学。我们可能失去数百页的篇幅来思考数据的确切组成部分，但是现在，我们可能在实际应用中犯错，会关注于关键的特性。一般来说，我们会关注一组例子。为了有效的处理数据，我们通常给出合适的数字表示。每一个例子（或者数据点，数据实例，样本）通常包含一系列特性，称之为特征（或者协变量），模型必须作出一定的预测。在上面的监督学习问题中，要预测的是一个被指定为标签(或目标)的特定属性。
如果我们处理图像数据，每一张图片构成一个例子（样本），它是由一组与每一个像素明亮度相关的有序数值表达。一张 200x200 的彩色图像由 200x200x3=12000 个数值组成，与每一个空间位置的红，绿，蓝通道的亮度相关。在另外一个传统的任务中，给定一个标准的特征，比如年龄，生命体征，诊断结果，我们试着预测病人是否存活。
当每个例子的特征是相同数量的数值时，我们说数据由固定长度的向量组成，我们将固定长度的向量作为数据的维度。可以想象，固定长度是一个很方便的属性。如果我们想训练一个模型在显微镜图像中识别癌症，固定长度的输入意味着我们少了一件需要担心的事情。
但是，并不是所有的数据都可以容易表达为固定长度的向量。然而我们希望显微镜图像来自标准的设备，我们不可能期望来自互联网的图像都有相同的分辨率或者形状。对于图像而言，我们考虑将其裁剪为固定大小的尺寸，但是这种策略也只能到此为止。在被切去的部分存在丢失信息的风险。而且，文本数据更难用固定长度的向量表示。考虑一下亚马逊(Amazon)、IMDB和TripAdvisor等电子商务网站上的客户评论。一些是简短的句子：“它臭死了!”。另一些人则在网页上闲逛。与传统方法相比，深度学习的一个主要优势是现代模型在处理长度变化的数据方面相对优雅。
一般来说，我们拥有的数据越多，我们的工作就越容易。当我们有了更多的数据，我们就可以训练出更强大的模型，减少对预先设想的依赖。从(相对)小数据到大数据的模式转变是现代深度学习成功的主要因素。为了说明这一点，在没有大型数据集的情况下，深度学习中许多最令人兴奋的模型变得无法工作。其他一些方法在小数据系统中工作，但并不比传统方法更好。
最后，仅仅拥有大量数据和巧妙的处理是不够的。我们需要正确的，合适的数据。如果数据存在大量的错误，或者被选择的特征并不能表征目标的特性，学习就会失败。这种情况很好地体现在这句陈词滥调中：垃圾进，垃圾出。而且，糟糕的预测性能并不是唯一的潜在后果。在机器学习的敏感应用中，如预测性监管、简历筛选和用于贷款的风险模型，我们必须特别警惕垃圾数据的后果。一个常见的失败情况是一些数据从来没有在训练集中出现过。想象下，将皮肤癌识别系统应用于从没有见过的黑色皮肤。当数据不仅没有充分代表某些群体，而且反映出社会偏见时，失败也可能发生。例如，如果过去的招聘决定被用来训练一个用于筛选简历的预测模型，那么机器学习模型可能会无意中捕捉并自动呈现历史上的不公正现象。请注意，这一切都可能发生在数据科学家没有积极的阴谋，甚至没有意识到。
1.2.2. 模型 在某种意义上，大多数机器学习都涉及到数据的转换。我们可能想要建立一个系统来读取照片并预测笑容。或者，我们可能想要读取一组传感器读数，并预测读数的正常与异常程度。通过模型，我们指示一种类型数据的计算机制，并给出一个可能不同类型的预测。特别地，我们对可以从数据学习的统计模型更感兴趣。虽然简单模型完全能够恰当地解决简单问题，但我们在本书中关注的问题扩展了经典方法的限制。深度学习与经典方法的区别主要在于它所关注的一组强大的模型集合。这些模型由许多从上到下链接在一起的数据的连续转换组成，因此被称为深度学习。在讨论深度模型的过程中，我们还将讨论一些更传统的方法。
1.2.3. 目标函数 早些时候，我们将从经验中学习作为机器学习引入的关键特征。这里所说的学习，是指随着时间的推移，某些任务的性能有所提升。但是，谁能说明什么是性能改善了呢？你可能会想，我们可以提议更新模型，但是一些人会在我们的提议是造成了模型的改进还是下降方面产生了分歧。
为了开发一个正式的学习机器的数学系统，我们需要建立评估模型好、坏的正式评估标准。在机器学习和最优化中，我们称之为目标函数。按照惯例，我们通常定义目标函数，目标值越低越好。这仅仅是一个惯例。当然，也可以定义越高越好，然后通过符号翻转，将其变为新的目标函数，具有相同的评估能力，但是越低越好。因为越低越好，目标函数也常称为损失函数。
当要预测数值时，最为常见的损失函数是平方误差（squared error），比如预测值与真实值之间差的平方。对于分类问题，常用的目标函数为最小误差率，比如预测样本中，错误预测所占的比例。一些目标函数（比如，平方误差）很容易优化。其它（比如，误差率）很难直接优化，由于不可求导或者其它的一些问题。这种情况下，常优化替代的目标函数。
通常，损失函数的定义需要考虑模型的参数和数据集。在收集的训练集上，通过最小化损失函数来学习最佳的模型参数值。但是，训练集上训练好的模型不一定适用未看到的数据。所以，通常情况下，我们将提供的数据划分为两个部分：训练集（用于拟合模型参数）和测试集（用于评估模型），并给出模型在上述数据集上的表现。你可以把训练表现看作是学生为准备真正的期末考试而进行的模拟考试的分数。尽管模拟考试的结果很好，但也不能保证期末考试表现很好。换句话说，测试表现与训练表现可能存在明显的偏差。当一个模型在训练集表现很好，但是在未训练的数据上表现很差，我们称之为过拟合。在现实生活中，这就像尽管在模拟考试中做得很好，但在真正的考试中却不及格。
1.2.4. 优化算法 一旦我们有了一些数据源和表达，一个模型，和一个明确定义的目标函数，我们需要一个算法，能够搜索最好的可能参数，使得损失函数最小化。深度学习中，比较流行的优化算法是基于随机梯度的优化算法。简而言之，在每个步骤中，这个方法检查每个参数，看看如果你扰乱了这个参数的一小部分，训练集的损失会移动到哪个方向。然后按照可能减少损失的方向更新参数。
1.3. 各种机器学习问题 上面唤醒词识别问题只是机器学习能解决的众多问题之一。为了进一步激励读者，在贯穿整本书的过程中，我们在讨论更多问题时提供一些共同的语言，接下来，我们将会列举一系列机器学习问题。我们会经常引用前面提到的概念，比如数据，模型，和训练技术。
1.3.1. 监督学习 监督学习为了解决在给定输入特征情况下，预测标签的任务。每一个特征标签对（feature-label）称为一个样本。有时候，当上下文很清楚时，我们使用术语示例指代输入的集合，尽管相关的标签是未知的。我们的目标是训练一个模型，可以将任何相关的输入映射为标签的预测。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3b60b2f87f09c43289893e5692426ab7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-20T14:14:37+08:00" />
<meta property="article:modified_time" content="2021-11-20T14:14:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动手学习深度学习——基本简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<blockquote> 
 <p><font color="Fuchsia">一些建议</font>：如果是深度学习刚刚入门，或者对深度学习的发展历史不是很熟悉的同学，可以认真读读本文，增加对该领域的背景，发展历史，应用领域的全面了解。<br> <font color="Fuchsia">参考项目</font>：《动手学习深度学习》，李沐，第二版。<br> <font color="Fuchsia">英文原文</font>：<a href="https://d2l.ai/chapter_introduction/index.html#unsupervised-and-self-supervised-learning" rel="nofollow">https://d2l.ai/chapter_introduction/index.html</a><br> 注意：博文中的图片均来自英文原文。</p> 
</blockquote> 
<h3><a id="1__7"></a>1. 简介</h3> 
<p>  直到最近，几乎我们接触到的每一个计算机程序都是软件开发人员根据第一性原理（<font color="red"><em>First Principles</em></font>）编写而成。比如，我们想编写一个应用程序来管理电子商务平台。在围绕白板思考几个小时后，我们可以得到大致的解决方案：（i）用户通过运行在网页浏览器或者移动应用程序界面与应用程序交互；（ii）我们的应用程序与商用级的数据库引擎交互，并追踪每一个用户的状态和维持历史的交易记录；（iii）在应用程序的核心，应用程序的业务逻辑(也可以说是大脑)以系统的方式详细说明了程序在每个可能的情况下应该采取的适当操作。</p> 
<p>  为了建立应用程序的大脑，我们不得不考虑每一个可能发生的情况，并制定适当的准则。每次客户点击添加商品到购物车，我们在购物车数据库表中添加一条记录，并且将用户的ID与产品的ID相关联。很少有开发者能够一次正确完成所有的功能（可能需要一些测试才能解决这些问题），大部分情况下，我们能够根据第一性原理写出这样一个程序，并在遇到真正的客户之前推出。我们能够根据第一性原理设计自动化系统，驱动功能性产品和系统，通常在新的情况下，这是一个了不起的认知壮举。当你能够解决所有的问题时，你就不必要使用机器学习。</p> 
<p>  幸运的是，对于不断增大的机器学习科学家团体，我们想要自动化的很多任务不是那么容易屈服于人类的聪明才智。想象一下，你和你所知道的最聪明的人挤在在白板前，但是这个时候你们正在解决下面问题中的一个：</p> 
<ul><li>编写一个程序，根据地理信息，卫星图像和过去天气的跟踪窗口，预测明天的天气。</li><li>编写一个程序，输入为自由格式的文本问题，并且正确的回答。</li><li>编写一个程序，输入一张图像，能够识别图片中包含的所有人，并且画出每一个人的轮廓。</li><li>编写一个程序，呈现给用户喜欢的商品，但是在自然的浏览中又不会遇到。</li></ul> 
<p>  上面遇到的每一种情况，尽管是优秀的程序员也没办法从零开始编写解决方案。原因可能有很多。有时候，我们正在寻找的程序遵循一个随着时间变化的模式，我们需要我们的程序来适应。在其他情况下，这种关系(比如像素和抽象类别之间的关系)可能过于复杂，需要进行成千上万次的计算，而这些计算超出了我们的意识理解能力，即使我们的眼睛可以毫不费力地完成这项任务。机器学习正是这种学习能力很强的技术，可以从经验中学习。随着机器学习算法积累更多的经验，通常以观察数据或与环境交互的形式，其性能得到提高。这与我们确定的电子商务平台对比鲜明，无论有多少数据出现，电子商务平台遵循的逻辑是不变的，直到开发者自身通过学习，进而更新软件。在本书中，我们将传授机器学习的基础，并聚焦于深度学习，一系列强大的技术推动了计算机视觉、自然语言处理、医疗保健和基因组学等领域的创新。</p> 
<h4><a id="11__25"></a>1.1. 一个激励人心的例子</h4> 
<p>  在开始写作之前，像其它工作者一样，本书的作者不得不让自己兴奋起来。我们跳入车中，开始驾驶。使用iPhone手机，Alex 喊出 “Hey，Siri”，手机的语音识别系统被唤醒。然后，Mu 给出指令 “去蓝瓶咖啡店”。手机迅速展示了转录的指令。手机同时也识别了我们说话的内容是去咖啡店，并打开地图应用来满足我们的请求。一旦打开，地图APP识别一些路线。对于每一条路线，手机APP展示了预测的通勤时间。虽然我们编造这个故事是为了教学上的便利，但它表明，在短短几秒钟内，我们与智能手机的日常交互可以使用几种机器学习模型。</p> 
<p>  想象着写一个识别唤醒词（比如，Alexa，OK Google，Hey，Siri）的程序。在一个空的屋子里，试着只使用一台电脑和代码编辑器实现如 <font color="red">图1.1.1</font> 的功能。你会根据第一原理如何编写程序？想想看，这个问题很难。每一秒，麦克风大概收集44000个样本。每个样本都是对声波振幅的测量。无论语音片段是否包含唤醒词，什么样的准则能够确信的将原始音频的一段映射为可靠的预测（yes，no）？如果你感觉到困难，不用担心。我们也不知道如何从零开始写这样的程序。这也就是为什么我们要使用机器学习。</p> 
<p><img src="https://images2.imgbox.com/d2/59/5mhMGZt7_o.png" alt="在这里插入图片描述"></p> 
<p>  这就是诀窍的所在。常常，尽管我们不知道如何明确地告诉电脑将输入映射为输出，但是，我们还是有能力完成这样的壮举。换句话说，尽管你不知道如何编程让电脑识别唤醒词，但是你自己是可以识别的。拥有这样的能力，我们可以收集大量的数据集，包含了语音样本和相应的标签（可能包含唤醒词，也可能没有包含）。在机器学习的方法中，我们不会尝试设计一个明确识别唤醒词的系统。相反地，我们定义可变的程序，它的表现是由参数决定的。然后，我们使用数据来决定最佳的参数集，这些参数可以提升我们的程序在某些感兴趣任务方面的性能。</p> 
<p>  你可以将参数视为我们可以调用的操作程序行为的旋钮。固定参数，我们将程序称为模型。所有不同程序（输入输出的映射）的集合可以通过调整参数进而得到不同的模型被称为模型族。使用我们的数据集来选择参数的元程序称为学习算法。</p> 
<p>  在我们着手使用学习算法之前，我们必须精确地定义问题，确定输入和输出的精确性质，并选择合适的模型族。在上面的例子中，我们的模型接收语音的一个片段作为输入，并在集合（yes，no）中选择一个作为输出。如果一切都按照计划进行，模型对输入片段是否包含唤醒词的猜测通常是正确的。</p> 
<p>  如果我们选择正确的模型家族，应该存在一个旋钮（参数）设置，每次听到单词“ Alexa”，模型会给出“yes”的输出。因为唤醒词的确切选择是任意的，我们可能需要一个足够丰富的模型家族，通过另一个旋钮设置，当听到单词“Apricot”，它可以输出“yes”。我们期望相同的模型族适合“ Alexa”识别和“ Apricot”识别，因为直观上看起来它们是相似的任务。然而，如果我们想要处理完全不同的输入或输出，比如我们想要从图像映射到字幕，或者从英语句子映射到中文句子，我们可能需要一个完全不同的模型族。</p> 
<p>  正如你猜测的一样，如果我们任意设置所有的“旋钮”，我们的模型可能无法识别“Alexa”，“Apricot”或者任何其它的英文单词。在机器学习中，学习是发现正确的“旋钮”设置，并强制模型达到我们期望的表现。换句话说，我们用数据训练模型。如 <font color="red">图1.1.2</font> 所示，训练过程应该如下：</p> 
<ol><li>随机初始化模型的设置，此时模型无法得到任何有效的输出。</li><li>抓取一些数据（比如，语音片段和相应的{yes，no}标签）。</li><li>调整旋钮（参数设置），使得模型相对于那些例子来说不那么糟糕。</li><li>重复步骤2-步骤3，直到模型表现很好，达到预期的结果。</li></ol> 
<p><img src="https://images2.imgbox.com/88/aa/LbErrMNI_o.png" alt="在这里插入图片描述"></p> 
<p>  总而言之，如果我们给它提供一个大的带标签数据集，与其编写唤醒词识别程序，不如编写一个程序来学习如何识别唤醒词。你可以将这种用数据集决定程序行为的方式看作是用数据编程。也就是说，我们可以通过给我们的机器学习系统提供许多猫和狗的例子来“编写”一个猫检测器。通过这种方式，如果它是一只猫，检测器最终将学会给出一个非常大的正数，如果它是一只狗，则给出一个非常大的负数，如果不确定是什么动物，则给出一个接近于零的数，这仅仅触及了机器学习能做什么的表面。深度学习只是解决机器学习问题的众多流行方法之一，我们将在后面更详细地解释。</p> 
<h3><a id="12__58"></a>1.2. 关键组件</h3> 
<p>  在我们的唤醒词例子中，我们描述了包含语音片段和二值标签的数据集，我们还粗略介绍了如何训练模型来近似一个从语音片段到分类的映射。基于包含数据样本和标签的数据集，训练一个模型可以在指定输入，没有标签的情况下，给出合适的预测结果，称之为监督学习。这些只是众多机器学习中的一种。后面，我们会深度研究不同的机器学习问题。首先，无论遇到什么样的机器学习问题，我们都需要更多了解下核心组件：</p> 
<ol><li>用于学习的数据。</li><li>用于转换数据的模型。</li><li>用于评估模型优劣的目标函数。</li><li>用于调整模型参数的算法，进而优化目标函数。</li></ol> 
<h4><a id="121__67"></a>1.2.1. 数据</h4> 
<p>  毫无疑问，没有数据就没法进行数据科学。我们可能失去数百页的篇幅来思考数据的确切组成部分，但是现在，我们可能在实际应用中犯错，会关注于关键的特性。一般来说，我们会关注一组例子。为了有效的处理数据，我们通常给出合适的数字表示。每一个例子（或者数据点，数据实例，样本）通常包含一系列特性，称之为特征（或者协变量），模型必须作出一定的预测。在上面的监督学习问题中，要预测的是一个被指定为标签(或目标)的特定属性。</p> 
<p>  如果我们处理图像数据，每一张图片构成一个例子（样本），它是由一组与每一个像素明亮度相关的有序数值表达。一张 200x200 的彩色图像由 200x200x3=12000 个数值组成，与每一个空间位置的红，绿，蓝通道的亮度相关。在另外一个传统的任务中，给定一个标准的特征，比如年龄，生命体征，诊断结果，我们试着预测病人是否存活。</p> 
<p>  当每个例子的特征是相同数量的数值时，我们说数据由固定长度的向量组成，我们将固定长度的向量作为数据的维度。可以想象，固定长度是一个很方便的属性。如果我们想训练一个模型在显微镜图像中识别癌症，固定长度的输入意味着我们少了一件需要担心的事情。</p> 
<p>  但是，并不是所有的数据都可以容易表达为固定长度的向量。然而我们希望显微镜图像来自标准的设备，我们不可能期望来自互联网的图像都有相同的分辨率或者形状。对于图像而言，我们考虑将其裁剪为固定大小的尺寸，但是这种策略也只能到此为止。在被切去的部分存在丢失信息的风险。而且，文本数据更难用固定长度的向量表示。考虑一下亚马逊(Amazon)、IMDB和TripAdvisor等电子商务网站上的客户评论。一些是简短的句子：“它臭死了!”。另一些人则在网页上闲逛。与传统方法相比，深度学习的一个主要优势是现代模型在处理长度变化的数据方面相对优雅。</p> 
<p>  一般来说，我们拥有的数据越多，我们的工作就越容易。当我们有了更多的数据，我们就可以训练出更强大的模型，减少对预先设想的依赖。从(相对)小数据到大数据的模式转变是现代深度学习成功的主要因素。为了说明这一点，在没有大型数据集的情况下，深度学习中许多最令人兴奋的模型变得无法工作。其他一些方法在小数据系统中工作，但并不比传统方法更好。</p> 
<p>  最后，仅仅拥有大量数据和巧妙的处理是不够的。我们需要正确的，合适的数据。如果数据存在大量的错误，或者被选择的特征并不能表征目标的特性，学习就会失败。这种情况很好地体现在这句陈词滥调中：垃圾进，垃圾出。而且，糟糕的预测性能并不是唯一的潜在后果。在机器学习的敏感应用中，如预测性监管、简历筛选和用于贷款的风险模型，我们必须特别警惕垃圾数据的后果。一个常见的失败情况是一些数据从来没有在训练集中出现过。想象下，将皮肤癌识别系统应用于从没有见过的黑色皮肤。当数据不仅没有充分代表某些群体，而且反映出社会偏见时，失败也可能发生。例如，如果过去的招聘决定被用来训练一个用于筛选简历的预测模型，那么机器学习模型可能会无意中捕捉并自动呈现历史上的不公正现象。请注意，这一切都可能发生在数据科学家没有积极的阴谋，甚至没有意识到。</p> 
<h4><a id="122__82"></a>1.2.2. 模型</h4> 
<p>  在某种意义上，大多数机器学习都涉及到数据的转换。我们可能想要建立一个系统来读取照片并预测笑容。或者，我们可能想要读取一组传感器读数，并预测读数的正常与异常程度。通过模型，我们指示一种类型数据的计算机制，并给出一个可能不同类型的预测。特别地，我们对可以从数据学习的统计模型更感兴趣。虽然简单模型完全能够恰当地解决简单问题，但我们在本书中关注的问题扩展了经典方法的限制。深度学习与经典方法的区别主要在于它所关注的一组强大的模型集合。这些模型由许多从上到下链接在一起的数据的连续转换组成，因此被称为深度学习。在讨论深度模型的过程中，我们还将讨论一些更传统的方法。</p> 
<h4><a id="123__85"></a>1.2.3. 目标函数</h4> 
<p>  早些时候，我们将从经验中学习作为机器学习引入的关键特征。这里所说的学习，是指随着时间的推移，某些任务的性能有所提升。但是，谁能说明什么是性能改善了呢？你可能会想，我们可以提议更新模型，但是一些人会在我们的提议是造成了模型的改进还是下降方面产生了分歧。</p> 
<p>  为了开发一个正式的学习机器的数学系统，我们需要建立评估模型好、坏的正式评估标准。在机器学习和最优化中，我们称之为目标函数。按照惯例，我们通常定义目标函数，目标值越低越好。这仅仅是一个惯例。当然，也可以定义越高越好，然后通过符号翻转，将其变为新的目标函数，具有相同的评估能力，但是越低越好。因为越低越好，目标函数也常称为损失函数。</p> 
<p>  当要预测数值时，最为常见的损失函数是平方误差（squared error），比如预测值与真实值之间差的平方。对于分类问题，常用的目标函数为最小误差率，比如预测样本中，错误预测所占的比例。一些目标函数（比如，平方误差）很容易优化。其它（比如，误差率）很难直接优化，由于不可求导或者其它的一些问题。这种情况下，常优化替代的目标函数。</p> 
<p>  通常，损失函数的定义需要考虑模型的参数和数据集。在收集的训练集上，通过最小化损失函数来学习最佳的模型参数值。但是，训练集上训练好的模型不一定适用未看到的数据。所以，通常情况下，我们将提供的数据划分为两个部分：训练集（用于拟合模型参数）和测试集（用于评估模型），并给出模型在上述数据集上的表现。你可以把训练表现看作是学生为准备真正的期末考试而进行的模拟考试的分数。尽管模拟考试的结果很好，但也不能保证期末考试表现很好。换句话说，测试表现与训练表现可能存在明显的偏差。当一个模型在训练集表现很好，但是在未训练的数据上表现很差，我们称之为过拟合。在现实生活中，这就像尽管在模拟考试中做得很好，但在真正的考试中却不及格。</p> 
<h4><a id="124__94"></a>1.2.4. 优化算法</h4> 
<p>  一旦我们有了一些数据源和表达，一个模型，和一个明确定义的目标函数，我们需要一个算法，能够搜索最好的可能参数，使得损失函数最小化。深度学习中，比较流行的优化算法是基于随机梯度的优化算法。简而言之，在每个步骤中，这个方法检查每个参数，看看如果你扰乱了这个参数的一小部分，训练集的损失会移动到哪个方向。然后按照可能减少损失的方向更新参数。</p> 
<h3><a id="13__97"></a>1.3. 各种机器学习问题</h3> 
<p>  上面唤醒词识别问题只是机器学习能解决的众多问题之一。为了进一步激励读者，在贯穿整本书的过程中，我们在讨论更多问题时提供一些共同的语言，接下来，我们将会列举一系列机器学习问题。我们会经常引用前面提到的概念，比如数据，模型，和训练技术。</p> 
<h4><a id="131__100"></a>1.3.1. 监督学习</h4> 
<p>  监督学习为了解决在给定输入特征情况下，预测标签的任务。每一个特征标签对（feature-label）称为一个样本。有时候，当上下文很清楚时，我们使用术语示例指代输入的集合，尽管相关的标签是未知的。我们的目标是训练一个模型，可以将任何相关的输入映射为标签的预测。</p> 
<p>  为了在具体的例子中描述，假如我们在医疗行业工作，我们会想着预测一个病人是否会心脏病发作。这个例子中，显然 “heart attack” 或者 “no heart attack” 将会是标签。输入特征可能是生命体征，如心率、舒张压和收缩压。</p> 
<p>  因为参数的选择，所以监督起了作用，我们为模型提供了标注数据样本，每一个样本与真实标签匹配。在概率论术语中，我们通常感兴趣的是估计给定输入特征，标签的条件概率。虽然这只是机器学习范例中的一个，但是监督学习占据工业上大部分机器学习的成功应用案例。在一定程度上，这是因为许多重要的任务都可以清晰地描述为给定一组特定的可用数据，估计未知事物发生的概率：</p> 
<ul><li>给定一张计算机断层扫描图像，预测癌症或者没有癌症。</li><li>给定一个英语句子，预测正确的法语翻译。</li><li>根据本月的金融报告数据，预测下个月的股票价格。</li></ul> 
<p>  即使使用简单的描述“预测给定输入特征的标签”，监督式学习也可以采用许多形式，并需要许多建模决策，这些依赖于输入和输出的类型，大小和数量。比如，我们使用不同的模型处理任意序列长度和固定序列长度的向量表达。我们将在本书中深入探讨其中的许多问题。</p> 
<p>  非正式的说，监督学习的过程如下。首先，大量获取输入特征已知的数据，并从中随机挑选子集，以及每一个数据的真实标签。有时这些标签可能是已经收集到的可用数据（比如，病人在第二年会去世吗？），其它时候可能需要雇佣标注员标注数据（比如给图像添加分类标签）。将输入和相应的标签一起组成训练集。我们将训练集输入到监督学习算法，该算法以数据集作为输入，然后输出另一个函数：学习的模型。最后，我们可以将之前未见的数据输入到学习的模型，使用它的输出作为相应标签的预测值。全部的流程如 <font color="red">图.1.3.1</font>.</p> 
<p><img src="https://images2.imgbox.com/4f/97/yiZa0JL9_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1311__119"></a>1.3.1.1. 回归分析</h5> 
<p>  也许最简单的监督学习任务是回归。比如，考虑从家庭销售数据库获取数据集。我们建立一个表，每一行表示不同的房子，每一列表示相关的特性，比如房子的面积，卧室的数量，卫生间的数量，和到中心城区的时间。这个数据集中，每一个例子就是一个特定的房子，相应的特征向量就是表格中的一行。如果你住在纽约或旧金山，而你又不是亚马逊、谷歌、微软或Facebook的首席执行官，那么你就会发现，你家相应的特征向量看起来是这个样子：[600,1,1,60]。但是，如果你住在匹兹堡，特征向量应该像这样：[3000,4,3,10]。像这样的特征向量对于大多数经典的机器学习算法都是必不可少的。</p> 
<p>  一个问题是不是回归问题是由输出决定。假如你想买一个新房子。给定像上面那样的特征向量，你可能想估计出公平的市场价格。标签（房子的价格）是一个数值。如果标签是任意的数值，我们称之为回归问题。我们的目标是训练一个模型，可以预测出接近相应标签的值。</p> 
<p>  许多实际问题都是描述得很好的回归问题。预测用户对一部电影的评分可以被认为是一个回归问题，如果你在2009年设计了一个伟大的算法来完成这一壮举，你可能会赢得100万美元的Netflix奖。对患者住院时间的预测也是一个回归问题。一个好的经验法则： how much? or how many? 问题应建议回归，比如下面的表述，</p> 
<ul><li><code>How many</code> hours will this surgery take?（这个手术需要多少个小时）</li><li><code>How much</code> rainfall will this town have in the next six hours?（接下来6个小时，这个地方的降雨量）</li></ul> 
<p>  尽管你之前没有使用过机器学习，但是你可能非正式的处理过一个回归问题。想象一下，比如，你修理了你的排水管，你的承包商花了3个小时从你的污水管道清除黏稠物。然后他寄给你一张350美元的账单。现在想象一下，你的朋友雇佣了同一个承包商2小时，他收到了250美元的账单。如果有人问你在他们即将到来的清除淤泥的发票上期望多少钱，你可能会做出一些合理的假设，比如工作时间越长，成本就越高。你也可以假设有一些基本费用，以及承包商每小时收费。如果这些假设成立，那么给出这两个数据示例，你就可以确定承包商的定价结构：100美元每小时加上50美元上门服务。如果你了解了很多，那么你就已经理解了线性回归背后的高级思想。</p> 
<p>  在这种情况下，我们可以得到可以精确预测承包商价格的参数。有时候这是不可能的，比如，如果除了你的两个特征之外，还有一些因素造成了差异。在这些情况下，我们将尝试学习将预测值和观测值之间的距离最小化的模型。在我们的大多数章节中，我们将着重于最小化平方误差损失函数。正如我们稍后将看到的，这种损失与我们的数据被高斯噪声损坏的假设相关。</p> 
<h5><a id="1312__134"></a>1.3.1.2. 分类</h5> 
<p>  虽然回归模型可以很好地解决 <code>how many?</code> 问题，但是很多问题不适合这个模板。比如，一家银行想要在其移动应用程序中添加支票扫描功能。这需要客户用智能手机的摄像头拍下一张支票的照片，应用程序需要能够自动理解图像中看到的文字。具体来说，它还需要理解手写文本，以便更加稳定，比如将手写字符映射到已知的字符之一。这种 <code>which one？</code>问题称为分类。与用于回归的算法相比，它使用不同的算法集进行处理，尽管许多技术将继续使用。</p> 
<p>  在分类问题中，我们期望模型处理一个特征，比如图像中的像素，然后预测出示例所属众多离散的选项中的类别。对于手写字体识别，我们可能有10类，使用0到9的数字表示。最简单的分类问题只有两类，也称为二分类问题。比如，我们的数据包含动物图像，标签可能是（猫，狗）。在回归问题中，我们期望回归器输出具体数值，而在分类问题中，我们训练分类器，输出是类别。</p> 
<p>  由于一些原因，我们将在本书中讨论更多的技术性问题，我们很难优化一个只能输出硬分类赋值的模型，比如，猫或者狗。在这种情况下，用概率的语言来表达我们的模型通常要容易得多。给定示例的特征，我们的模型为每一个可能的类赋一个概率值。回到我们动物分类的示例中，类别为（猫，狗），给分类器输入一张图像，输出猫的概率值为0.9。根据这个概率值，我们可以说分类器90%确定图片中是一只猫。预测类别的概率的大小传达了一个不确定性的概念。它不是不确定性的唯一概念，我们将在更高级的章节讨论其他的概念。</p> 
<p>  当我们有两个以上可能的类时，我们称这个问题为多类分类。常见的例子包括手写字符识别{0,1,2，…9,a,b,c，…}。当我们试图通过最小化平方误差损失函数来处理回归问题时，而分类问题中常见的损失函数被称为交叉熵，它的名字可以通过在后面章节中对信息理论的介绍来解开。</p> 
<p>  请注意，最有可能的类不一定是您将用于决策的类。假设你在 <font color="red"> 图1.3.2</font> 找到了一个美丽的蘑菇。</p> 
<p><img src="https://images2.imgbox.com/72/a3/5nmojyq9_o.png" alt="在这里插入图片描述"></p> 
<p>  现在，假设你创建了一个分类器，用于从图像中判定该蘑菇是否有毒。假设我们的毒物检测分类器输出<font color="red">图1.3.2</font>包含死亡帽的概率是0.2。换句话说，分类器80%确信这个蘑菇不是死亡帽。不过，只有傻瓜才会吃它。这是因为一顿美味的晚餐所带来的益处，抵不上20%的死亡风险。换句话说，到目前为止，不确定风险的影响远远大于收益。因此，我们需要计算我们所发生的预期风险作为损失函数，比如我们需要将概率结果乘以与之相关的收益或者危害。在这个例子中，吃蘑菇的损失为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         0.2 
        
       
         × 
        
       
         ∞ 
        
       
         + 
        
       
         0.8 
        
       
         × 
        
       
         0 
        
       
         = 
        
       
         ∞ 
        
       
      
        0.2\times \infty+0.8\times 0=\infty 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">∞</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord">∞</span></span></span></span></span>，而丢弃的损失为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         0.2 
        
       
         × 
        
       
         0 
        
       
         + 
        
       
         0.8 
        
       
         × 
        
       
         1 
        
       
         = 
        
       
         0.8 
        
       
      
        0.2\times 0+0.8\times 1=0.8 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span></span></span></span></span>。我们的谨慎是有道理的：正如任何一位真菌学家会告诉我们的那样，<font color="red">图1.3.2</font> 中的蘑菇实际上是一种死亡帽。</p> 
<p>  分类可以变得比二进制、多类甚至多标签分类复杂得多。例如，对于寻址层次结构有一些不同的分类。层次结构假设许多类之间存在某种关系。因此，并不是所有的错误都是相等的——如果我们必须犯错，我们宁愿错误地分类到一个相关的类，而不是一个遥远的类。通常，这被称为层次分类。一个早期的例子来自 Linnaeus，他将动物按等级进行组织。</p> 
<p>  在动物分类的情况下，把贵宾犬(一种犬种)误认为雪纳瑞犬(另一种犬种)可能没有那么糟糕，但如果我们的模型把贵宾犬误认为恐龙，就会付出巨大的代价。哪个层次结构是相关的可能取决于您计划如何使用模型。例如，响尾蛇和吊袜带蛇在进化树上可能很接近，但将响尾蛇误认为吊袜带蛇可能会致命。</p> 
<h5><a id="1313__154"></a>1.3.1.3. 标注</h5> 
<p>  一些分类问题很适合二值或多类分类设置。例如，我们可以训练一个普通的二元分类器来区分猫和狗。考虑到计算机视觉的现状，我们可以用现成的工具轻松地做到这一点。然而，无论我们的模型有多精确，当分类器遇到不莱梅的城镇音乐家形象时，我们可能会发现自己遇到了麻烦，这是一个流行的德国童话故事，<font color="red">图1.3.3 </font>中有四只动物。<br> <img src="https://images2.imgbox.com/3b/41/HiAX3B4p_o.png" alt="在这里插入图片描述"></p> 
<p>  正如你看到的，<font color="red">图1.3.3 </font> 中有一只猫， 公鸡，狗和驴，以及背景中的一些树。根据我们最终想要我们的模型做什么，将其视为一个二元分类问题可能没有多大意义。相反，我们可能希望给模型一个选项，让它说图像描绘了一只猫、一只狗、一只驴和一只公鸡。</p> 
<p>  学习预测非互斥类的问题称为多标签分类。通常，自动标记问题最应该被描述为多标签分类问题。想想人们在技术博客上发布的帖子，比如“机器学习”、“技术”、“小工具”、“编程语言”、“Linux”、“云计算”、“AWS”。一篇典型的文章可能会应用5-10个标签，因为这些概念是相关的。关于“云计算”的帖子可能会提到“AWS”，而关于“机器学习”的帖子也可能涉及“编程语言”。</p> 
<p>  在处理生物医学文献时，我们也必须处理这类问题，正确标记文章是很重要的，因为它允许研究人员做详尽的文献回顾。在国家医学图书馆，许多专业注释人员仔细检查PubMed中索引的每一篇文章，并将其与MeSH中的相关术语相关联，MeSH中大约有28000个标签。这是一个耗时的过程，注释器在归档和标记之间通常有一年的延迟。机器学习可以在这里提供临时标签，直到每一篇文章都有一个适当的手工审查。事实上，几年来，BioASQ组织举办了一些竞赛，正是为了做到这一点。</p> 
<h5><a id="1314__165"></a>1.3.1.4. 搜索</h5> 
<p>  有时候我们不想给每一个例子一个分数或者实数值。在信息检索领域，我们希望对一组词条排序。以网页搜索为例，搜索的目标不是确定某个网页与用户搜索目的相关度最低，而是找到与用户搜索目的最相关的网页。我们比较关注对搜索结果进行相关度排序，那么我们的学习算法需要对大量网页的子集进行排序。换句话说，如果让我们说出字母表的前5个字母，返回“A B C D E”和“C A B E D”是有区别的。即使结果集是相同的，集合中的顺序也很重要。</p> 
<p>  解决这个问题的一种可能的解决方案是，首先为集合中的每个元素分配相应的相关性得分，然后检索评分最高的元素。PageRank是谷歌搜索引擎背后的排序算法，它是这种评分系统的一个早期例子，但它的特殊之处在于，它不依赖于实际的查询。在这里，他们依靠一个简单的相关性过滤器来识别相关的项目集，然后依靠 PageRank 来排序那些包含查询条件的结果。目前，搜索引擎使用机器学习和行为模型来获取与查询相关的相关性得分。整个学术会议都在讨论这个问题。</p> 
<h5><a id="1315__170"></a>1.3.1.5. 推荐系统</h5> 
<p>  推荐系统是另一个与搜索和排名相关的问题设置。当目标是向用户显示一组相关项时，这些问题是相似的。主要的区别在于推荐系统的上下文中强调针对特定用户的个性化推荐。例如，对于电影推荐，科幻迷的结果页面和彼得·塞勒斯喜剧鉴赏家的结果页面可能会有很大不同。在其他推荐设置中也会出现类似的问题，例如零售产品、音乐和新闻推荐。</p> 
<p>  在某些情况下，客户提供明确的反馈，以表达他们对某一特定产品的喜爱程度(例如，在Amazon、IMDb和Goodreads上的产品评级和评论)。在其他一些情况下，他们提供隐性反馈，例如，跳过播放列表上的标题，这可能表明不满，但可能只是表明歌曲在上下文中是不合适的。在最简单的公式中，这些系统被训练去估计一些分数，例如给定一个用户和一个物品的估计评级或购买概率。</p> 
<p>  给定这样一个模型，对于任何给定的用户，我们都可以检索得分最高的对象集，然后将其推荐给用户。生产系统则要先进得多，在计算这些分数时考虑到详细的用户活动和物品特征。<font color="red">图1.3.4</font> 是亚马逊基于个性化算法推荐的深度学习书籍的例子。</p> 
<p><img src="https://images2.imgbox.com/82/4a/PLRjmrlL_o.png" alt="在这里插入图片描述" width="800"></p> 
<p>  尽管其巨大的经济价值，天真地建立在预测模型之上的推荐系统遭受了一些严重的概念性缺陷。首先，我们只观察审查反馈：用户优先评价他们感觉强烈的电影。例如，在五分制的评分系统中，你可能会注意到一些项目得到了许多五星和一星的评分，但是显然很少有三星的评分。此外，目前的购买习惯往往是由于目前的推荐算法，但学习算法并不总是考虑到这个细节。因此，反馈循环就有可能形成这样一种情况：推荐系统优先推销一件商品，而这件商品随后被推销得更好(由于购买量增加) ，反过来又被推荐得更加频繁。许多关于如何处理审查、激励和反馈循环的问题都是重要的开放性研究问题。</p> 
<h5><a id="1316__181"></a>1.3.1.6. 序列学习</h5> 
<p>  到目前为止，我们已经看到了一些问题，我们有一些固定数量的输入和产生一个固定数量的输出。例如，我们考虑根据一组固定的特征来预测房价：面积、卧室数量、浴室数量、步行到市中心的时间。我们还讨论了从一个图像(固定维度)到它属于一个固定数量的类中的每一个的预测概率的映射，或者获取一个用户 ID 和一个产品 ID，然后预测一个星级等级。在这种情况下，一旦我们将固定长度的输入送入模型中，并产生输出，模型马上就会忘记它刚刚看到了什么。</p> 
<p>  如果我们的输入真的都有相同的维度，如果连续的输入真的彼此没有关系，这可能是好的。但是我们如何处理视频片段呢？在这种情况下，每个片段可能包含不同数量的帧。如果我们考虑到前一帧或后一帧，我们对每一帧中发生的事情的猜测可能会更强。语言也是如此。一个流行的深度学习问题是机器翻译：吸收一些源语言中的句子，然后预测它们在另一种语言中的翻译。</p> 
<p>  这些问题也出现在医学领域。我们可能需要一个模型来监控重症监护室的病人，并在他们在未来24小时内死亡风险超过某个阈值时发出警报。我们绝对不希望这个模型每隔一小时就抛弃它所知道的关于病人病史的一切，而只是根据最近的测量结果做出预测。</p> 
<p>  这些问题是机器学习最令人兴奋的应用之一，它们是序列学习的实例。它们需要一个模型来摄取输入序列或发出输出序列(或两者兼有)。具体来说，序列到序列学习考虑的是输入和输出都是可变长度序列的问题，例如机器翻译和从口语转录文本。虽然不可能考虑所有类型的序列转换，但以下特殊情况值得注意。</p> 
<p><strong>标注和分析</strong>. 这涉及到用属性注释文本序列。换句话说，输入和输出的数量本质上是相同的。例如，我们可能想知道动词和主语在哪里。或者，我们可能想知道哪些单词是命名的实体。通常，目标是根据结构和语法假设分解和注释文本，以获得一些注释。这听起来比实际要复杂得多。下面是一个非常简单的例子，它使用标记来标注一个句子，指明哪些单词引用了命名的实体(标记为“Ent”)。</p> 
<blockquote> 
 <p>Tom has dinner in Washington with Sally<br> Ent  -  -   -   Ent     -  Ent</p> 
</blockquote> 
<p><strong>自动语音识别</strong>. 通过语音识别，输入序列是一个说话人的音频记录(<font color="red">如图1.3.5所示</font>)，输出是说话人所说的文字记录。挑战在于音频帧(声音通常以8kHz或16kHz采样)比文本多得多，也就是说，音频和文本之间不存在1:1的对应关系，因为数千个样本可能对应一个单独的口语单词。这是一个序列对序列的学习问题其中输出比输入短得多。</p> 
<p><img src="https://images2.imgbox.com/2b/d0/YqJiOeWg_o.png" alt="在这里插入图片描述"></p> 
<p><strong>文本转语音</strong> 这与自动语音识别相反。换句话说，输入是文本，输出是音频文件。在这种情况下，输出比输入长得多。虽然人类很容易识别出坏的音频文件，但这对计算机来说并不那么简单。</p> 
<p><strong>机器翻译</strong> 与语音识别不同的是，相应的输入和输出以相同的顺序(在对齐后)出现，在机器翻译中，顺序反转是至关重要的。换句话说，当我们仍然在将一个序列转换为另一个序列时，输入和输出的数量以及相应的数据示例的顺序都不假设相同。下面的例子说明了德国人把动词放在句末的特殊倾向。</p> 
<blockquote> 
 <p>German:     Haben Sie sich schon dieses grossartige Lehrwerk angeschaut?<br> English:      Did you already check out this excellent tutorial?<br> Wrong alignment: Did you yourself already this excellent tutorial looked-at?</p> 
</blockquote> 
<p>  在其他学习任务中也会出现许多相关的问题。例如，确定用户阅读网页的顺序是一个二维布局分析问题。对话问题表现出各种额外的复杂性，决定接下来说什么需要考虑现实世界的知识和跨越长时间距离的对话的先前状态。这些都是活跃的研究领域。</p> 
<h4><a id="132__212"></a>1.3.2. 无监督和自监督学习</h4> 
<p>  到目前为止，所有的例子都与监督学习有关，也就是说，我们向模型提供一个包含特征和相应标签值的大规模数据集。你可以把有监督的学习者想象成拥有一份非常专业的工作和一个非常平庸的老板。老板站在你身后，告诉你在每种情况下该做什么，直到你学会各种情况对应的行动。为这样的老板工作听起来真没劲。另一方面，取悦这位老板很容易。你只要尽可能快地识别出模式，然后模仿他们的动作。</p> 
<p>  以一个相反的方式，为一个完全不知道自己想让你做什么的老板工作可能会令人沮丧。然而，如果你计划成为一名数据科学家，你最好习惯它。老板可能会给你一大堆数据，让你用这些数据做一些数据科学！这听起来很模糊，因为它确实模糊。我们把这类问题称为无监督学习，我们可以提出的问题的类型和数量只受我们创造力的限制。我们将在后面的章节中讨论非监督学习技术。为了刺激你的食欲，我们描述了以下几个你可能会问的问题。</p> 
<ul><li>我们能否找到一小部分能够准确概括原始数据的原型？给一组照片，我们可以把它们分成风景照片、狗、婴儿、猫和山峰的照片吗？同样地，给定一组用户的浏览活动，我们是否可以将他们划分为具有类似行为的用户？这个问题通常称为集群。</li><li>我们能否找到少量的参数来准确地捕捉数据的相关属性？球的运动轨迹可以用球的速度、直径和质量很好地描述。为了合身的衣服，裁缝们开发了一些相当准确地描述人体形状的参数。这些问题被称为子空间估计。如果相关性是线性的，则称为主成分分析。</li><li>在欧几里得空间中，是否存在一种(任意结构的)对象的表示法，使符号属性能够很好地匹配？这可以用来描述实体和实体之间的关系，如“罗马”−“意大利”+“法国”=“巴黎”。</li><li>我们观察到的很多数据的根本原因有描述吗？例如，如果我们有关于房价、污染、犯罪、地点、教育和工资的人口统计数据，我们能否仅仅基于经验数据发现它们之间的关系？与因果关系和概率图形模型有关的领域解决了这个问题。</li><li>另一个重要和令人兴奋的非监督学习的最新发展是生成对抗网络的出现。这为我们提供了一种程序性的方法来合成数据，甚至是像图像和音频这样复杂的结构化数据。基本的统计机制是检验真实数据和假数据是否相同的测试。</li></ul> 
<p>  作为非监督学习的一种形式，自我监督学习利用未标记数据在训练中提供监督，例如通过使用其他部分预测数据的某些保留部分。对于文本，我们可以训练模型“填空”，通过在大语料库中使用周围的单词(上下文)预测随机隐藏的单词，而不需要任何标记努力[Devlin et al.， 2018]！对于图像，我们可以训练模型来告诉同一图像的两个裁剪区域之间的相对位置[Doersch et al.， 2015]。在这两个自我监督学习的例子中，预测可能的单词和相对位置的训练模型都是分类任务(来自监督学习)。</p> 
<h4><a id="133__226"></a>1.3.3. 与环境交互</h4> 
<p>  到目前为止，我们还没有讨论数据实际上来自哪里，或者当机器学习模型生成输出时，实际发生了什么。这是因为监督学习和无监督学习不能以一种非常复杂的方式解决这些问题。在任何一种情况下，我们首先获取一大堆数据，然后让我们的模式识别机器在不与环境再次交互的情况下运行。因为所有的学习都发生在算法与环境断开之后，这有时被称为离线学习。对于监督学习，考虑环境数据收集的过程如<font color="red"> 图1.3.6</font> 所示。</p> 
<p><img src="https://images2.imgbox.com/bc/c4/LxwGszjZ_o.png" alt="在这里插入图片描述"></p> 
<p>  这种简单的线下学习有它的魅力。好处是，我们可以单独担心模式识别问题，而不会受到相关的其他问题干扰。但缺点是，问题的公式是相当有限的。如果你更有抱负，或者如果你是读着阿西莫夫的机器人系列长大的，那么你可能会想象人工智能机器人不仅能够做出预测，而且能够在世界上采取行动。我们要考虑智能体，而不仅仅是预测模型。这意味着我们需要考虑选择行动，而不仅仅是做出预测。此外，与预测不同，行动实际上会影响环境。如果我们想要训练一个智能的主体，我们必须考虑到它的行为可能会影响对主体未来观察的方式。</p> 
<p>考虑与环境的交互开启了一套全新的建模问题。下面只是几个例子。</p> 
<ul><li>环境还记得我们之前做了什么吗？</li><li>环境是否愿意帮助我们，例如，用户将文本读入到语音识别器？</li><li>环境是否想要打败我们，例如，像垃圾邮件过滤这样的对抗性设置(针对垃圾邮件发送者)或玩游戏(针对对手)？</li><li>难道环境不关心吗？</li><li>环境有变化的动力吗？例如，未来的数据总是与过去的数据相似吗？或者模式会随着时间的推移而改变吗？</li></ul> 
<p>  当训练和测试数据不同时，最后一个问题提出了分布偏移的问题。这是我们大多数人都经历过的一个问题，当参加一个讲师写的考试，而家庭作业是由他的助教完成的。接下来，我们将简要描述强化学习，一种明确考虑与环境交互的设置。</p> 
<h4><a id="134__245"></a>1.3.4. 强化学习</h4> 
<p>  如果你对使用机器学习开发一个与环境交互并采取行动的代理感兴趣，那么你可能会把重点放在强化学习上。这可能包括应用于机器人、对话系统，甚至用于开发电子游戏的人工智能(AI)。将深度学习应用于强化学习问题的深度强化学习受到了越来越多的欢迎。仅通过视觉输入就在雅达利(Atari)游戏中击败人类的突破性深度Q网络，以及在围棋比赛中击败世界冠军的AlphaGo程序，就是两个突出的例子。</p> 
<p>  强化学习给出了一个问题的非常一般的陈述，在这个问题中，一个代理通过一系列的时间步骤与环境进行交互。在每个时间步骤中，代理接收来自环境的一些观察，并必须选择一个动作，该动作随后通过某种机制(有时称为执行器)传输回环境。最后，代理从环境中获得奖励。这一过程如<font color="red"> 图1.3.7</font> 所示。然后代理接收后续观察，并选择后续操作，以此类推。强化学习代理的行为由策略控制。简而言之，策略只是一个将环境观察映射到操作的函数。强化学习的目标是产生一个好的策略。</p> 
<p><img src="https://images2.imgbox.com/a9/f9/O9UICaCG_o.png" alt="在这里插入图片描述"></p> 
<p>  再怎么强调强化学习框架的普遍性也不过分。例如，我们可以将任何监督学习问题视为强化学习问题。假设我们有一个分类问题。我们可以创建一个强化学习代理，每个类对应一个动作。然后我们可以创造一个环境，这个环境给予的奖励与原始监督学习问题中的损失函数完全相同。</p> 
<p>  也就是说，强化学习也可以解决许多监督学习无法解决的问题。例如，在监督学习中，我们总是期望训练输入与正确的标签相关联。但在强化学习中，我们不假设每次观察都是环境告诉我们最优行动。一般来说，我们只是得到一些奖励。此外，环境甚至可能不会告诉我们哪些行为会得到奖励。</p> 
<p>  以国际象棋为例。唯一真正的奖励信号出现在游戏最后，当我们获胜时，我们可能会分配 1，当我们失败时，我们会分配 -1。因此，强化型学习者必须处理学分分配问题：决定哪个行为应该得到学分，哪个行为应该受到责备。同样的道理也适用于在10月11日获得晋升的员工。这种提升可能反映了过去一年大量精心选择的行动。想要在未来获得更多的晋升，就需要弄清楚在晋升的过程中采取了哪些行动。</p> 
<p>  强化型学习者可能还需要处理部分可观测性的问题。也就是说，当前的观察可能不会告诉您关于当前状态的所有信息。比如，一个清洁机器人发现自己被困在一所房子里的众多相同衣柜中的一个。推测机器人的精确位置(以及状态)可能需要考虑它进入壁橱之前的观察结果。</p> 
<p>  最后，在任何给定的点上，强化学习者可能知道一个好的策略，但可能有许多其他更好的策略，但代理从未尝试过。强化型学习者必须不断地选择是利用当前已知的最佳策略作为一种策略，还是探索策略的空间，可能会放弃一些短期回报来换取知识。</p> 
<p>  最一般的强化学习问题是一个非常一般的设置。行动会影响后续的观察。奖励只与选择的行动相对应。环境可以完全观察到，也可以部分观察到。一次性解释所有这些复杂性可能对研究人员要求太多。此外，并不是每一个实际问题都表现出这种复杂性。因此，研究人员研究了一些特殊情况下的强化学习问题。</p> 
<p>  当环境被充分观察时，我们称强化学习问题为马尔可夫决策过程。当状态不依赖于前面的操作时，我们称此问题为上下文强盗问题。当游戏中没有状态，只有一组初始奖励未知的可用行动时，这个问题就是典型的多武装强盗问题。</p> 
<h3><a id="14__267"></a>1.4. 起源</h3> 
<p>  我们刚刚回顾了机器学习可以解决的一小部分问题。对于各种各样的机器学习问题，深度学习提供了强大的工具来解决它们。虽然许多深度学习方法都是最近才发明的，但使用数据和神经网络(许多深度学习模型的名称)编程的核心思想已经研究了几个世纪。事实上，长期以来，人类一直渴望分析数据并预测未来的结果，许多自然科学都起源于此。例如，伯努利分布是以Jacob Bernoulli(1655-1705)的名字命名的，高斯分布是由Carl Friedrich Gauss(1777-1855)发现的。例如，他发明了最小均方算法，这种算法至今仍被用于从保险计算到医疗诊断的无数问题。这些工具在自然科学中产生了一种实验方法——例如，关于电阻中电流和电压的欧姆定律可以用线性模型完美地描述。</p> 
<p>  即使在中世纪，数学家们也有一种敏锐的估算直觉。例如，Jacob Köbel(1460-1533)的几何书中给出了16个成年男子脚的平均长度，从而得到了脚的平均长度。</p> 
<p><img src="https://images2.imgbox.com/44/7c/bpgdAzB2_o.png" alt="在这里插入图片描述"></p> 
<p>  <font color="red">图1.4.1</font> 说明了该估计器的工作原理。这16名成年男子被要求在离开教堂时排成一排。然后将它们的总长度除以16，得到现在的估计长度为1英尺。这个“算法”后来被改进以处理畸形的脚——脚最短和脚最长的两个人分别被送走，只计算剩下所有人脚的平均值。这是平均估计优化的最早的例子之一。</p> 
<p>  随着数据的可收集性和可用性，统计学真正起飞了。其中一位巨人，罗纳德·费希尔(1890-1962)，对其理论及其在遗传学上的应用做出了重大贡献。他的许多算法(如线性判别分析)和公式(如Fisher信息矩阵)至今仍被频繁使用。事实上，Fisher在1936年发布的Iris数据集有时仍被用于说明机器学习算法。他也是优生学的支持者，这应该提醒我们，在道德上可疑的数据科学的使用，与它在工业和自然科学中的生产性使用一样，有着漫长而持久的历史。</p> 
<p>  对机器学习的第二个影响来自于Claude Shannon(1916-2001)的信息理论和Alan Turing(1912-1954)的计算理论。图灵提出了一个问题：“机器能思考吗？” 在他著名的论文《计算机与智能》(图灵，1950)中。在他所描述的图灵测试中，如果人类评估者很难根据文本交互来区分机器和人类的回复，那么机器可以被认为是智能的。</p> 
<p>  另一个影响可以在神经科学和心理学中发现。毕竟，人类显然表现出了聪明的行为。因此，唯一合理的问题是，是否可以解释并可能对这种能力进行逆向工程。受到这种方式启发的最古老算法之一是唐纳德·赫布(Donald Hebb, 1904-1985)提出的。在他开创性的著作《行为的组织》(The Organization of Behavior, Hebb &amp; Hebb, 1949)中，他假设神经元通过正强化来学习。这就是著名的Hebbian学习规则。它是Rosenblatt感知器学习算法的原型，它奠定了许多支撑当今深度学习的随机梯度下降算法的基础:加强理想行为，减少不理想行为，以获得神经网络中良好的参数设置。</p> 
<p>  神经网络的名字来源于生物学上的灵感。一个多世纪以来(可以追溯到亚历山大·贝恩(1873年)和詹姆斯·谢林顿(1890年)的模型)，研究人员一直试图组装类似于相互作用的神经元网络的计算电路。随着时间的推移，对生物学的解释变得不再那么字面化，但它的名字却保留了下来。在它的核心，有一些关键的原则，可以在今天的大多数网络中找到：</p> 
<ul><li>线性和非线性处理单元的交替使用，通常称为层（<font color="red"><em>layer</em></font>）。</li><li>使用链式法则(也称为反向传播，<font color="red"><em>backpropagation</em></font>)一次性调整整个网络中的参数。</li></ul> 
<p>  在最初的快速进展之后，神经网络的研究从1995年到2005年逐渐衰落。这主要是由于两个原因。首先，训练一个网络在计算上是非常昂贵的。尽管上世纪末随机存取存储器很丰富，但计算能力却很匮乏。其次，数据集相对较小。事实上，费雪1932年的Iris数据集是测试算法有效性的流行工具。MNIST拥有60000个手写数字的数据集被认为是巨大的。</p> 
<p>  考虑到数据和计算的稀缺，强大的统计工具，如核方法，决策树和图形模型证明了经验上的优势。与神经网络不同，它们不需要数周的训练，并且提供了具有强大理论保证的可预测结果。</p> 
<h3><a id="15__292"></a>1.5. 深度学习之路</h3> 
<p>  随着互联网的出现、为数亿用户提供在线服务的公司的出现、廉价和高质量传感器的传播、克里德定律(Kryder’s law)所说的廉价数据存储以及摩尔定律(Moore’s law)所说的廉价计算，特别是最初为电脑游戏而设计的 GPU，大量数据的可用性改变了这一切。突然之间，似乎在计算上不可行的算法和模型变得相关了(反之亦然)。这在<font color="red">表1.5.1</font>中得到了最好的说明。</p> 
<p><img src="https://images2.imgbox.com/e4/e0/gisUmziD_o.png" alt="在这里插入图片描述" width="800"></p> 
<p>  很明显，随机存取存储器没有跟上数据增长的步伐。与此同时，计算能力的增长已经超过了可用数据的增长。这意味着统计模型需要提高内存效率(这通常是通过添加非线性来实现的)，同时由于计算预算的增加，需要花费更多的时间来优化这些参数。因此，机器学习和统计的最佳点从(广义)线性模型和核方法转移到深度神经网络。这也是其中一个原因为什么许多的深度学习的支柱，如多层感知器(麦克洛克&amp;皮茨,1943)，卷积神经网络[LeCun et al., 1998]，长期短期记忆[Hochreiter &amp; Schmidhuber, 1997]，和 Q-Learning (沃特金斯&amp;达扬,1992)，在休眠相当长一段时间之后，在过去十年中基本上被“重新发现”。</p> 
<p>  最近在统计模型、应用和算法方面的进步有时被比作寒武纪大爆发：物种进化的一个快速进步的时刻。事实上，最先进的技术不仅仅是可用资源的结果，应用于几十年前的算法。请注意，下面的列表仅仅触及了过去十年中帮助研究人员取得巨大进步的一些想法的表面。</p> 
<ul><li>新的容量控制方法，如dropout [Srivastava等人，2014]，有助于减轻过拟合的危险。这是通过在整个神经网络中应用噪声注入来实现的[Bishop, 1995]，用随机变量代替权重，以达到训练的目的。</li><li>注意力机制解决了第二个困扰统计学超过一个世纪的问题：如何在不增加可学习参数数量的情况下增加系统的内存和复杂性。研究人员通过使用只能被视为可学习的指针结构找到了一个优雅的解决方案[Bahdanau等人，2014]。而不是必须记住整个文本序列，例如，机器翻译在一个固定的维度表示，所有需要存储的是一个指针，指向翻译过程的中间状态。由于模型在开始生成新序列之前不再需要记住整个序列，这大大提高了长序列预测的准确性。</li><li>多阶段设计，例如通过记忆网络[Sukhbaatar等人，2015]和神经编程解释器[Reed &amp; DeFreitas, 2015]允许统计建模者描述推理的迭代方法。这些工具允许深度神经网络的内部状态被反复修改，从而在一个推理链中执行后续步骤，类似于处理器如何为计算修改内存。</li><li>另一个关键发展是生成式对抗网络的发明[Goodfellow et al.， 2014]。传统上，用于密度估计和生成模型的统计方法专注于找到合适的概率分布和(通常是近似的)从它们中抽样的算法。结果，由于统计模型缺乏固有的灵活性，这些算法在很大程度上受到限制。生成式对抗网络的关键创新是用具有可微参数的任意算法代替采样器。然后对这些数据进行调整，使鉴别器(有效的双样本测试)无法区分假数据和真实数据。通过使用任意算法生成数据的能力，它为各种各样的技术打开了密度估计的大门。飞奔的斑马(Zhu et al.， 2017)和假名人脸(Karras et al.， 2017)的例子都证明了这一进展。即使是业余的涂鸦爱好者也可以仅根据描述场景布局的草图生成逼真的图像[Park等人，2019]。</li><li>在许多情况下，单个GPU不足以处理用于训练的大量数据。在过去的十年中，构建并行和分布式训练算法的能力有了显著的提高。设计可伸缩算法的关键挑战之一是深度学习优化的主要工具——随机梯度下降法，它依赖于处理相对较小的小批量数据。同时，小批量限制了GPU的效率。因此，对1024个GPU进行小批量的训练，比如每批32张图片，总计约为32000张图片。最近的工作，首先是Li [Li, 2017]，随后是[You等人，2017]和[Jia等人，2018]，将大小提高到64000个观测值，将ImageNet数据集上的ResNet-50模型的训练时间减少到小于7分钟。为了进行比较，最初的训练时间是以天的顺序来计算的。</li><li>并行计算的能力也对强化学习的进展做出了至关重要的贡献，至少当模拟是一种选择的时候。这导致计算机在围棋、雅达利游戏、星际争霸和物理模拟(例如，使用MuJoCo)中取得了重大进展。例如，[Silver et al.， 2016]关于如何在AlphaGo中实现这一点的描述。简而言之，如果存在大量的三元组(状态、行动、奖励)，强化学习的效果最好，也就是说，只要有可能尝试大量事物，了解它们之间的关系。模拟提供了这样一个途径。</li><li>深度学习框架在传播思想方面发挥了至关重要的作用。第一代允许简单建模的框架包括Caffe、Torch和Theano。许多开创性的论文就是用这些工具写成的。到目前为止，它们已经被TensorFlow(通常通过其高级API Keras使用)、CNTK、Caffe 2和Apache MXNet所取代。第三代工具，即用于深度学习的命令式工具，可以说是由Chainer引领的，它使用类似于Python NumPy的语法来描述模型。这个想法被PyTorch、MXNet的Gluon API和Jax采用。</li></ul> 
<p>  构建更好工具的系统研究人员和构建更好神经网络的统计建模人员之间的分工极大地简化了事情。例如，训练一个线性逻辑回归模型曾经是一个重要的家庭作业问题，值得在2014年交给卡内基梅隆大学(Carnegie Mellon University)的机器学习新博士生。到目前为止，这个任务只需要不到10行代码就可以完成，这让程序员牢牢掌握了它。</p> 
<h3><a id="16__313"></a>1.6. 成功的故事</h3> 
<p>  人工智能在很长一段时间内都能实现难以实现的结果。例如，自20世纪90年代以来，使用光学字符识别的邮件分拣系统已经部署。毕竟，这是著名的MNIST手写数字数据集的来源。这同样适用于阅读支票的银行存款和评分申请人的信誉。金融交易被自动检查是否有欺诈行为。这构成了许多电子商务支付系统的支柱，如PayPal、Stripe、AliPay、微信、Apple、Visa和MasterCard。几十年来，国际象棋的计算机程序一直很有竞争力。机器学习为互联网提供搜索、推荐、个性化和排名。换句话说，机器学习是无处不在的，尽管经常隐藏在视线之外。</p> 
<p>  直到最近，人工智能才受到关注，这主要是由于解决了以前被认为难以解决的问题，而且这些问题与消费者直接相关。许多这样的进步归功于深度学习。</p> 
<ul><li>智能助手，如苹果的Siri，亚马逊的Alexa和谷歌的助手，能够以合理的精确度回答口头问题。这包括一些卑微的工作，比如打开电灯开关(对残疾人来说是一种福利)，安排理发预约，提供电话支持对话。这可能是人工智能正在影响我们生活的最明显迹象。</li><li>数字助理的一个关键因素是准确识别语音的能力。逐渐地，这类系统的准确性已经提高到在某些应用中达到人类对等的程度[Xiong等人，2018]。</li><li>物体识别也走过了很长的路。在2010年，估算图片中的物体是一项相当具有挑战性的任务。在ImageNet的基准测试中，来自NEC实验室和伊利诺伊大学香槟分校的研究人员获得了28%的前5名错误率[Lin等人，2010]。到2017年，这一错误率降低到2.25% [Hu等，2018]。同样，在鉴别鸟类或诊断皮肤癌方面也取得了惊人的成果。</li><li>游戏曾经是人类智慧的堡垒。从TD-Gammon开始，一个玩双陆棋的程序使用时间差异强化学习，算法和计算进展已经推动算法的广泛应用。与西洋双陆棋不同的是，国际象棋拥有更复杂的状态空间和一系列动作。深蓝通过大量并行、专用硬件和通过游戏树的高效搜索击败了加里·卡斯帕罗夫(Garry Kasparov) [Campbell et al.， 2002]。围棋的难度更大，因为它的状态空间很大。2015年，AlphaGo使用深度学习和蒙特卡罗树采样相结合的方法实现了与人类的对等[Silver等人，2016]。《Poker》的挑战在于状态空间很大，且未被完全观察到(我们不知道对手的牌)。Libratus在扑克游戏中使用高效的结构化策略超越了人类的表现[Brown &amp; Sandholm, 2017]。这说明了游戏的进步，以及高级算法在其中发挥了关键作用。</li><li>人工智能取得进展的另一个迹象是自动驾驶汽车和卡车的出现。虽然完全自主还不太可能实现，但在这个方向上已经取得了出色的进展，特斯拉(Tesla)、英伟达(NVIDIA)和Waymo等公司已经推出了至少实现部分自主的产品。完全自动驾驶之所以如此具有挑战性，是因为正确的驾驶需要感知、推理和将规则纳入系统的能力。目前，深度学习主要应用于这些问题的计算机视觉方面。其余的都是由工程师精心调整的。</li></ul> 
<p>  再一次，上面的列表仅仅触及了机器学习对实际应用的影响的表面。例如，机器人、物流、计算生物学、粒子物理学和天文学，它们最近取得的一些最令人印象深刻的进展，至少部分归功于机器学习。因此，机器学习正成为工程师和科学家普遍使用的工具。</p> 
<p>  关于人工智能的非技术文章中经常提到人工智能末日或人工智能奇点的问题。令人担忧的是，机器学习系统将以某种方式变得有知觉，并独立于程序员(和大师)，对直接影响人类生计的事情做出决定。在某种程度上，人工智能已经在以一种直接的方式影响着人类的生活:信誉度是自动评估的，自动驾驶仪主要为车辆导航，是否批准保释的决定使用统计数据作为输入。更有趣的是，我们可以让Alexa打开咖啡机。</p> 
<p>  幸运的是，我们还远没有一个有知觉的人工智能系统准备好操纵它的人类创造者(或烧他们的咖啡)。首先，人工智能系统以特定的、目标导向的方式进行设计、培训和部署。虽然他们的行为可能给人一种一般智力的错觉，但这是规则、启发式和统计模型的组合，构成了设计的基础。其次，目前还不存在能够自我完善、自我推理、能够在解决一般任务的同时修改、扩展和改进自身架构的人工智能工具。</p> 
<p>  一个更紧迫的问题是人工智能如何在我们的日常生活中使用。卡车司机和店员完成的许多低级工作很可能能够而且将会实现自动化。农场机器人可能会降低有机农业的成本，但它们也会使收获操作自动化。工业革命的这一阶段可能对社会的很大一部分产生深远的影响，因为卡车司机和店员是许多国家最常见的工作。此外，如果不加注意地应用统计模型，可能会导致种族、性别或年龄偏见，并引发对程序公平性的合理担忧，如果自动驱动后果性决定的话。确保谨慎使用这些算法是很重要的。根据我们今天所知道的，这给我们带来了一个比邪恶超级智能毁灭人类的可能性更紧迫的担忧。</p> 
<h3><a id="17__332"></a>1.7. 特点</h3> 
<p>  到目前为止，我们已经广泛地讨论了机器学习，它既是人工智能的一个分支，也是人工智能的一种方法。虽然深度学习是机器学习的一个子集，但令人眼花缭乱的算法和应用使得很难评估深度学习的具体成分可能是什么。这就像确定披萨所需的原料一样困难，因为几乎每一种成分都是可以替代的。</p> 
<p>  正如我们所描述的，机器学习可以使用数据来学习输入和输出之间的转换，例如在语音识别中将音频转换为文本。在这样做的时候，通常需要以一种适合于算法的方式来表示数据，以便将这种表示转换为输出。深度学习之所以是深度学习，是因为它的模型学习了许多层转换，而每一层都提供了一个层次的表示。例如，靠近输入的层可能表示数据的低级细节，而靠近分类输出的层可能表示用于区分的更抽象的概念。由于表征学习的目的是寻找表征本身，所以深度学习可以称为多级表征学习。</p> 
<p>  我们到目前为止所讨论的问题，例如从原始音频信号中学习，图像的原始像素值，或任意长度的句子与外文对应句之间的映射，都是深度学习的优势所在，而传统机器学习方法却在这方面出现了问题。事实证明，这些多层模型能够以一种以前的工具无法做到的方式处理低级感知数据。可以说，深度学习方法中最重要的共性是端到端训练的使用。也就是说，不是基于单独调优的组件组装系统，而是构建系统，然后联合调优它们的性能。例如，在计算机视觉领域，科学家过去常常将特征工程的过程与构建机器学习模型的过程分离开来。Canny边缘检测器[Canny, 1987]和Lowe 's SIFT特征提取器[Lowe, 2004]作为将图像映射为特征向量的算法统治了十多年。在过去，将机器学习应用于这些问题的关键部分，是提出人工设计的方法，将数据转换成某种适合于浅层模型的形式。不幸的是，与由算法自动执行的对数百万个选择的一致评估相比，人类凭借聪明才智所能完成的工作实在太少了。当深度学习接管时，这些特征提取器会被自动调整的滤波器所取代，从而获得更高的精度。</p> 
<p>  因此，深度学习的一个关键优势是，它不仅替代了传统学习管道末端的浅层模型，而且还替代了特征工程的劳动密集型过程。此外，通过取代许多特定领域的预处理，深度学习消除了以前分隔计算机视觉、语音识别、自然语言处理、医学信息学和其他应用领域的许多边界，提供了一套统一的工具来解决各种问题。</p> 
<p>  除了端到端的训练，我们正在经历从参数统计描述到完全非参数模型的转变。当数据缺乏时，为了获得有用的模型，人们需要依赖于简化关于现实的假设。当数据丰富时，可以用更准确地符合现实的非参数模型代替。在某种程度上，这反映了上世纪中叶随着计算机的普及，物理学所取得的进步。人们现在可以求助于相关偏微分方程的数值模拟，而不是手工求解电子行为的参数近似。这导致了更精确的模型，尽管经常以失去可解释性为代价。</p> 
<p>  与之前工作的另一个区别是接受次优解，处理非凸非线性优化问题，以及在证明它们之前尝试的意愿。这种处理统计问题的新经验主义，加上人才的迅速涌入，导致了实用算法的快速发展，尽管在许多情况下，代价是修改和重新发明已经存在了几十年的工具。</p> 
<p>  最后，深度学习社区以跨学术和企业边界共享工具而自豪，发布了许多优秀的图书馆、统计模型和训练有素的开源网络。正是本着这种精神，构成本书的笔记本可以免费分发和使用。我们努力降低每个人学习深度学习的门槛，希望我们的读者能从中受益。</p> 
<h3><a id="18__348"></a>1.8. 总结</h3> 
<ul><li>机器学习研究计算机系统如何利用经验(通常是数据)来提高特定任务的表现。它结合了统计学、数据挖掘和优化的思想。通常，它被用作实现AI解决方案的一种手段。</li><li>表征学习作为机器学习的一种，关注的是如何自动找到合适的方法来表示数据。深度学习是通过学习多个层次的转换进行多层次表征学习。</li><li>深度学习不仅取代了传统机器学习管道末端的浅层模型，也取代了劳动密集型的特征工程过程。</li><li>深度学习的最新进展大多是由廉价传感器和互联网规模的应用程序产生的大量数据引发的，以及主要通过GPU实现的计算方面的重大进展。</li><li>整个系统的优化是实现高性能的关键。有效的深度学习框架的可用性使得设计和实现这一点变得非常容易。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27157371018c8dd605c938975c6a84f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python正则匹配两个字符之间的内容（转自：小晓酱手记）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d255e229e1ca5dd0e32d6870b700583/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDEA(最新版)配置servlet</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>