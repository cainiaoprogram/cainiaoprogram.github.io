<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【云原生】k8s(Kubernetes)中yaml文件快速阅读理解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【云原生】k8s(Kubernetes)中yaml文件快速阅读理解" />
<meta property="og:description" content="简言： k8s yaml中文件内容一般有kind类型之分，每种类型有不同的功能（一般用---符号隔开）
常见的kind类型：
（1）Endpoints：Endpoints可以把外部的链接到k8s系统中（可以理解为引用外部资源，如将一个外部mysql连接到k8s中）
（2）Service：部署一个内部虚拟IP，其他deployment可以链接。（可以简单理解为K8S的端口映射，如外部3444端口映射到pod应用中80端口）
（3）Secrets：用于存储和管理一些敏感数据，比如密码，token，密钥等敏感信息。（可以理解为ssh中的密钥）
（4）Deployment：部署一个Pod，内部只能链接service，无法互相链接。（可以简单理解为一个pod应用的部署工具，即使部署的应用挂了还能重启，但只能链接service服务）
备注：
（1）metadata一般每个类型中会带有metadata.name即表示该类型生成的名字，如
metadata: name: suncat （2）spec，资源详细定义，后面一般会带有该类型的详细信息。
如Service类型中定义接口的信息
spec: ports: - port: 3306 targetPort: 3306 protocol: TCP name: http 下面分别对下面几种kind类型来进行讲解：
一、Endpoints 先来看个需求：
我有个一个外部的mysql，不是使用本机的k8s部署的。但是现在我的应用程序想用它。那这时候，我改怎么使用它呢？毕竟k8s中的pod大部分只能通过service来链接。
这时候Endpoints就出现了，他是可以把外部的链接到k8s系统中，如：
apiVersion: v1 kind: Endpoints metadata: name: suncat-endpoints subsets: - addresses: # 代理ip - ip: 192.168.14.144 ports: - port: 3306 # 服务的端口 protocol: TCP name: http --- apiVersion: v1 kind: Service metadata: name: suncat-endpoints # 这里的名称要和上面一样才能关联 spec: ports: - port: 3306 targetPort: 3306 protocol: TCP name: http （1）首先我们看到，我们定义了名为suncat-endpoints的Endpoints，同时往suncat-endpoints配置了代理IP以及服务的端口。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1c4ce30f2111ecc328de5ec150ee5fb1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-08T20:32:03+08:00" />
<meta property="article:modified_time" content="2022-08-08T20:32:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【云原生】k8s(Kubernetes)中yaml文件快速阅读理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0px;">简言：</h2> 
<hr> 
<p style="margin-left:0;">        k8s yaml中文件内容一般有kind类型之分，每种类型有不同的功能（一般用---符号隔开）</p> 
<p style="margin-left:0;"><img alt="" height="420" src="https://images2.imgbox.com/4f/7b/tvtBlmhs_o.png" width="1200"></p> 
<p style="margin-left:0;"><strong>常见的kind类型：</strong></p> 
<p style="margin-left:0;"><strong>        （1）Endpoints</strong>：Endpoints可以把外部的链接到k8s系统中（可以理解为引用外部资源，如将一个外部mysql连接到k8s中）</p> 
<p style="margin-left:0;"><strong>        （2）Service</strong>：部署一个内部虚拟IP，其他deployment可以链接。（可以简单理解为K8S的端口映射，如外部3444端口映射到pod应用中80端口）</p> 
<p style="margin-left:0px;"><strong>        （3）Secrets</strong>：用于存储和管理一些敏感数据，比如密码，token，密钥等敏感信息。（可以理解为ssh中的密钥）</p> 
<p style="margin-left:0px;"><strong>        （4）Deployment</strong>：部署一个Pod，内部只能链接service，无法互相链接。（可以简单理解为一个pod应用的部署工具，即使部署的应用挂了还能重启，但只能链接service服务）</p> 
<p style="margin-left:0px;"></p> 
<p style="margin-left:0;"><strong>备注：</strong></p> 
<p style="margin-left:0;">（1）metadata一般每个类型中会带有metadata.name即表示该类型生成的名字，如</p> 
<pre><code class="language-java">metadata:
  name: suncat</code></pre> 
<p style="margin-left:0;">（2）spec，资源详细定义，后面一般会带有该类型的详细信息。</p> 
<p style="margin-left:0;">如Service类型中定义接口的信息</p> 
<pre><code>spec:
  ports:
    - port: 3306
      targetPort: 3306
      protocol: TCP
      name: http</code></pre> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">下面分别对下面几种kind类型来进行讲解：</p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;"><strong>一、Endpoints</strong></h2> 
<hr> 
<p style="margin-left:0;">先来看个需求：</p> 
<p style="margin-left:0;">        我有个一个外部的mysql，不是使用本机的k8s部署的。但是现在我的应用程序想用它。那这时候，我改怎么使用它呢？毕竟k8s中的pod大部分只能通过service来链接。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">这时候Endpoints就出现了，他是可以把外部的链接到k8s系统中，如：</p> 
<pre><code>apiVersion: v1
kind: Endpoints
metadata:
  name: suncat-endpoints
subsets:
  - addresses: # 代理ip
      - ip: 192.168.14.144
    ports:
      - port: 3306 # 服务的端口
        protocol: TCP
        name: http

---

apiVersion: v1
kind: Service
metadata:
  name: suncat-endpoints # 这里的名称要和上面一样才能关联
spec:
  ports:
    - port: 3306
      targetPort: 3306
      protocol: TCP
      name: http</code></pre> 
<p style="margin-left:0;">        （1）首先我们看到，我们定义了名为suncat-endpoints的Endpoints，同时往suncat-endpoints配置了代理IP以及服务的端口。</p> 
<p style="margin-left:0;">        （2）接着我们看下一个，以---分隔符隔开的另一个类型Service，定义了一个名为suncat-endpoints的Service，同时往该Service中配置内部端口映射到Pod暴露出的端口port: 3306，以及对外暴露的端口号targetPort: 3306</p> 
<p style="margin-left:0;">        总结：通过配置Endpoints以及Service，Endpoints将k8s的端口链接到外部mysql端口，而Service将k8s中内部的端口映射到k8s端口，以此就完成了pod应用访问外部链接。</p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;"><strong>二、Service</strong></h2> 
<hr> 
<p style="margin-left:0;">先来看个需求：</p> 
<p style="margin-left:0;">        我们K8S里启动了一个pod应用，并里面运行了端口为8848的前端页面。这时候，我外部怎么访问K8S内部pod应用这个端口为8848的前端页面？</p> 
<p style="margin-left:0;">        这时候就需要定义Service类型了，使pod应用端口8848映射到K8S特定端口中，外部应用访问K8S特定端口即可访问前端页面</p> 
<p style="margin-left:0;">样例：</p> 
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: suncat-service
spec:
  type: NodePort
  ports:
# 内部端口映射到Pod暴露出的端口
  - port: 8848
# 对外暴露的端口号，如果不指定则随机生成一个端口号
    nodePort: 38011
  selector:
    app: suncat-app</code></pre> 
<p style="margin-left:0;">        首先我们看到，定义了一个名为suncat-service的Service类型，他的职责时将port: 8848端口映射到nodePort: 38011对外暴露端口，并且他的管理的对应的应用时suncat-app应用</p> 
<p style="margin-left:0;">        也就是说，将pod应用名为suncat-app中端口为8848的端口映射到对外暴露端口38011，只要外部服务访问该服务器IP:38011,即可区访问k8s中suncat-app应用的8848端口</p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;"><strong>三、Secrets</strong></h2> 
<p style="margin-left:0;">        这个类型比较有意思，更多是用作于类似密钥的形式。</p> 
<p style="margin-left:0;">        （估计是不想明文记录账号密码等信息，但大部分加密都是<strong>Base64</strong>加密。所以说，我觉得有点像是防君子不防小人）</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">Secret有三种类型:</p> 
<p style="margin-left:0;"><strong>（1）Opaque</strong>：</p> 
<p style="margin-left:0;">                base64 编码格式的 Secret，用来存储密码、密钥等；但数据也可以通过base64 –decode解码得到原始数据，所有加密性很弱。</p> 
<p style="margin-left:0;"><strong>（2）Service Account</strong>：</p> 
<p style="margin-left:0;">        用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的的/run/secrets/kubernetes.io/serviceaccount 目录中。</p> 
<p style="margin-left:0;"><strong>（3）kubernetes.io/dockerconfigjson</strong> ：</p> 
<p style="margin-left:0;">        用来存储私有docker registry的认证信息。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">下面分别讲解一下：</p> 
<p style="margin-left:0;"><strong>Opaque：</strong>这种一般是加密一些账号密码，然后作为环境变量中使用</p> 
<p style="margin-left:0;">例子：</p> 
<pre><code>apiVersion: v1
kind: Secret
metadata:
  name: suncat_secret_userinfo
type: Opaque
data:
  name: c3VuY2F0
  age: MjY=</code></pre> 
<p style="margin-left:0;">        首先我们看到，定义了一个名为suncat_secret_userinfo的Secret类型，属于Secret下的Opaque种类，它所带key-value键值数据有两个分别是“name: c3VuY2F0”和“age: MjY=”。</p> 
<p style="margin-left:0;">        可能这样看有点不是很理解name是什么值、age是什么值，我们不妨将他们的值用Base64解密一下。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td style="text-align:center;width:165px;"><strong>字段</strong></td><td style="text-align:center;width:230px;"><strong>原值</strong></td><td style="text-align:center;width:251px;"><strong>Base64解密后的值</strong></td></tr><tr><td style="text-align:center;width:165px;">name</td><td style="text-align:center;width:230px;">c3VuY2F0</td><td style="text-align:center;width:251px;">suncat</td></tr><tr><td style="text-align:center;width:165px;">age</td><td style="text-align:center;width:230px;">MjY=</td><td style="text-align:center;width:251px;">26</td></tr></tbody></table> 
<p></p> 
<p style="margin-left:0;">        可以看到”name“的值为“suncat”，“age”的值是“26”</p> 
<p style="margin-left:0;">创建的secret的使用方法有<a href="https://so.csdn.net/so/search?q=%E6%8C%82%E8%BD%BD&amp;spm=1001.2101.3001.7020" title="挂载">挂载</a>和环境变量两种，以下只介绍在环境变量中的使用方法：</p> 
<pre><code>env:
    - name: username
      valueFrom:
        secretKeyRef:
          name: suncat_secret_userinfo
          key: name
    - name: userage
      valueFrom:
        secretKeyRef:
          name: suncat_secret_userinfo
          key: age</code></pre> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>kubernetes.io/dockerconfigjson：</strong>一般是用来拉镜像的密钥。比如自己搭建的harbor，有些镜像肯定不是公开的，是私密的。这时候拉取镜像就需要密码，需要密钥。</p> 
<p style="margin-left:0;">例子：</p> 
<pre><code>apiVersion: v1
kind: Secret
metadata:
     name: suncat-harbor-secret
type: kubernetes.io/dockerconfigjson
data:
     .dockerconfigjson: eyJhdXRocyI6eyIxOTIuMTY4LjAuMTo4MDkwIjp7InVzZXJuYW1lIjoic3VuY2F0IiwicGFzc3dvcmQiOiIxMjM0NTYiLCJhdXRoIjoiYzNWdVkyRjBPakV5TXpRMU5nPT0ifX19</code></pre> 
<p style="margin-left:0;">        首先我们看到，定义了一个名为suncat-harbor-secret的Secret类型，属于Secret下的kubernetes.io/dockerconfigjson种类，它所带的dockerconfigjson数据是一个由base64加密的json数据</p> 
<p style="margin-left:0;">        我们将</p> 
<pre><code>eyJhdXRocyI6eyIxOTIuMTY4LjAuMTo4MDkwIjp7InVzZXJuYW1lIjoic3VuY2F0IiwicGFzc3dvcmQiOiIxMjM0NTYiLCJhdXRoIjoiYzNWdVkyRjBPakV5TXpRMU5nPT0ifX19</code></pre> 
<p style="margin-left:0;">        进行base64解密：</p> 
<pre><code>{"auths":{"192.168.0.1:8090":{"username":"suncat","password":"123456","auth":"c3VuY2F0OjEyMzQ1Ng=="}}}</code></pre> 
<p style="margin-left:0;">我们把格式弄得漂亮一点再看看</p> 
<pre><code>{
    "auths":{
        "192.168.0.1:8090":{
            "username":"suncat",
            "password":"123456",
            "auth":"c3VuY2F0OjEyMzQ1Ng=="
        }
    }
}</code></pre> 
<p style="margin-left:0;">        我们可以看出，这是一个验证的信息，192.168.0.1:8090值的是harbor仓库的地址，而username后的值“suncat”是登录账号，password后的值“123456”是登录密码</p> 
<p style="margin-left:0;">        而auth后的值"c3VuY2F0OjEyMzQ1Ng=="则又是一个base64加密的值，它用于校验。我们将其解密后得到suncat:123456，也就是账号跟密码</p> 
<p style="margin-left:0;">备注：</p> 
<p style="margin-left:0;">创建k8s集群的kubernetes.io/dockerconfigjson种类的secret</p> 
<pre><code>kubectl -n &lt;命名空间&gt; create secret docker-registry &lt;secret名&gt; \
  --docker-server=&lt;域名或ip:port&gt; \
  --docker-username=&lt;用户名&gt; \
  --docker-password=&lt;密码&gt;</code></pre> 
<p style="margin-left:0;">例如：</p> 
<pre><code>kubectl -n suncat-test-secret create secret docker-registry registry-key \
  --docker-server=registry.k8s.suncat \
  --docker-username=suncat \
  --docker-password=123456</code></pre> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;"><strong>四、Deployment</strong></h2> 
<hr> 
<p style="margin-left:0;">先来看一下需求：</p> 
<p style="margin-left:0;">        我们希望在k8s上部署一个应用，如果该应用挂了还能重启。如果单单创建一个pod类型是不够的，应为该pod应用挂了，就不会重启了。</p> 
<p style="margin-left:0;">        如果创建一个Deployment类型，可以创建管理该pod应用，挂了都会给你重启。</p> 
<p style="margin-left:0;">例子：</p> 
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: suncat-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: suncat-app
  template:
    metadata:
      labels:
        app: suncat-app
    spec:
      imagePullSecrets:
      - name: suncat-harbor-secret
      containers:
      - name: suncat-app
        image: registry.k8s.suncat:4444/suncat/testapp:1.0
        ports:
          - containerPort: 8848
        imagePullPolicy: Always
        resources:
          limits:
            cpu: "1"
            memory: "400Mi"
          requests:
            cpu: "0.5"
            memory: "200Mi"</code></pre> 
<p style="margin-left:0;">以上内容有点多，我们慢慢讲解：</p> 
<p style="margin-left:0;">        （1）首先，我们定义了名为suncat-deployment的Deployment，并且该Deployment所管理的app应用的标签是suncat-app，副本数为1。</p> 
<p style="margin-left:0;">        （2）然后在数据定义里定义了一个定义业务模板template。可以看出，在业务模板里定义了一个名为suncat-app的pod应用。</p> 
<p style="margin-left:0;">        （3）同时该业务模板还定义了该suncat-app应用的容器名，同样也名为suncat-app，而该容器所拉取的镜像来源于registry.k8s.suncat:4444/suncat/testapp:1.0。</p> 
<p style="margin-left:0;">        这时候就会有人问，如果该拉取镜像的地址是非公开的，需要密码的。那该怎么办呢？</p> 
<p style="margin-left:0;">        还记得上面说到的类型Secrets下的kubernetes.io/dockerconfigjson种类么，这东西就是用来作密钥拉镜像的，只需要在imagePullSecrets下配置一个事先创建好的、名为suncat-harbor-secret的密钥即可拉取镜像</p> 
<p style="margin-left:0;">        （4）就是配置一些该pod的端口为8848，拉取方式imagePullPolicy为Always总是拉取pull</p> 
<p style="margin-left:0;">        （5）这个的话，就是配置该pod的正常请求cpu和内存，以及最大限制的cpu和内存。当然你不设置也所谓。</p> 
<p style="margin-left:0;">        在该配置中，我设置该pod正常请求的cpu为0.5（半核）以及内存为200M，最大限制的cpu为1核、以及内存为400M</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>备注：</strong></p> 
<p style="margin-left:0;">1、<strong>imagePullPolicy</strong>拉取方式参数详情有哪些？</p> 
<p style="margin-left:0;">        <strong>（1）Always：</strong>总是拉取pull</p> 
<p style="margin-left:0;">        <strong>（2）IfNotPresent：</strong>默认值,本地有则使⽤本地镜像,不拉取</p> 
<p style="margin-left:0;">        <strong>（3）Never：</strong>只使⽤本地镜像，从不拉取</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6de70e363787a409412ec57ee1612488/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【云原生之k8s】k8s管理工具kubectl详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c663ec2f215fc23f308724246c8129a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[TI TDA4 J721E] TDA4平台 相关技术文章 汇总</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>