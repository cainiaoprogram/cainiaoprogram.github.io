<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>阅读笔记：Instance-aware semantic segmentation via Multi-task Network Cascades - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="阅读笔记：Instance-aware semantic segmentation via Multi-task Network Cascades" />
<meta property="og:description" content="论文阅读：Instance-aware semantic segmentation via Multi-task Network Cascades
论文信息：CVPR2016, PASCAL VOC in VGG 63.5% mAP. COCO2015 in resnet101 won first prize
整体框架：对于传统的多任务方法，都是在共享特征的基础上，每个任务同时进行各不干扰，互相独立。这篇文章是在共享特征的基础上，上一个任务依赖于下一个任务，如此形成级联式的多任务结构(Multi-task Network Cascade,MNC)。 三个任务：（1）Differentiating instances；（2）Estimating masks；（3）Categorizing objects；
使用VGG16的第13层卷积层特征作为共享特征。每个阶段包含一个loss，下一阶段的loss依赖于前一阶段loss，故三个阶段的loss都不是独立的。
任务一：differentiating instance--&gt;regressing box-level instances ，该阶段的主要任务找出所有可能的物体框，即使用Faster RCNN中的RPN网络，使用NMS得到 top-ranked 300个box；
这一阶段的主要实现就是在共享特征的基础上附加一个3*3的卷积层用于降维以及1*1的卷积用于目标框定位和目标分类。因此在这一阶段的loss，作者直接使用的是RPN的loss，即：
任务二：estimating masks--&gt;regressing mask-level instances,该阶段的主要任务是以共享特征和上一阶段的得到的bounding box作为输入，输出基于box的pixel-level 的mask，不过此时的mask是class-agnostic，即无法对mask进行类别区分。
这一阶段的主要实现是在task1 输出的不同大小的box上使用ROI warping Pooling产生固定大小的特征:14*14大小的feature map，在此基础上为每个box附加两个fc层：fc1(256)&#43;fc2(m*m,28*28),这里的28*28是预先设定的mask的分辨率。因此这一阶段的task不仅是依赖于mask还依赖于box，所以这一阶段的loss，即：
任务三：categorizing objects--&gt;categorizing instances，该阶段的主要任务是以共享特征，task1的box，task2的mask作为输入，输出每个instance的categories scores。
这一阶段的主要实现是，一方面，在ROI warping pooling 的基础上连接两个fc层：fc1(4096)&#43;fc2(4096)；另一方面对task2得到的mask 也连接两个fc层：fc1(4096)&#43;fc2(4096)；然后再对这两个通道进行concat，最后得到每个instance的得分。因此这一阶段的计算量比较大，也是导致整个MNC模型巨大的原因。这一阶段的loss，如下：
End-to-end training
整个MNC网络结构的loss function如下：
MNC主要的技术挑战就是对上面的loss function 如何可以应用链式法则进行反向传播，实现end-to-end training。在fast R-CNN论文中使用的RoI pooling 的预测框是经过预训练的，是固定的，它的反向传播只考虑F(Θ) ,但我们现在必须同时考虑Bi(Θ)，而在这里得到的预测框确实在不断变化。但是，实际上task2中的框是由task1给出的，那么task2的loss就不只是依赖mask，还依赖框。这导致了无法对这部分以end to end的方式来训练，因为无法同时对这两部分求导。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e73696a18dd5783739aaf8680429b8db/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-24T15:31:53+08:00" />
<meta property="article:modified_time" content="2018-03-24T15:31:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">阅读笔记：Instance-aware semantic segmentation via Multi-task Network Cascades</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>论文阅读</strong>：<strong>Instance-aware semantic segmentation via Multi-task Network Cascades</strong></p> 
<p><strong>论文<span style="font-family:'楷体';">信息</span></strong><span style="font-family:'楷体';">：</span>CVPR2016, PASCAL VOC in VGG 63.5% mAP. COCO2015 in resnet101 won first prize</p> 
<p><strong>整体<span style="font-family:'楷体';">框架</span></strong><span style="font-family:'楷体';">：</span>对于<span style="font-family:'楷体';">传统的多任务方法，</span>都是在<span style="font-family:'楷体';">共享特征的基础上</span>，<span style="font-family:'楷体';">每个任务同时进行各不干扰，互相独立</span>。<span style="font-family:'楷体';">这</span>篇<span style="font-family:'楷体';">文章</span>是<span style="font-family:'楷体';">在共享特征的基础上，上一个任务依赖于下一个任务</span>，<span style="font-family:'楷体';">如此形成级联</span>式<span style="font-family:'楷体';">的多</span>任务结构(Multi-task Network Cascade,MNC)<span style="font-family:'楷体';">。</span><span style="text-align:center;"> </span></p> 
<p><span style="text-align:center;"> <img src="https://images2.imgbox.com/be/4c/j3FBuLhB_o.png" alt=""></span></p> 
<p><span style="text-align:center;"><img src="https://images2.imgbox.com/ec/e4/VFyG42i3_o.png" alt=""><br></span></p> 
<p><strong>三个<span style="font-family:'楷体';">任务</span></strong><span style="font-family:'楷体';">：</span><span style="font-family:'楷体';">（</span>1<span style="font-family:'楷体';">）</span>Differentiating instances；<span style="font-family:'楷体';">（</span>2<span style="font-family:'楷体';">）</span>Estimating masks；<span style="font-family:'楷体';">（</span>3<span style="font-family:'楷体';">）</span>Categorizing objects；</p> 
<p align="justify"><span style="font-family:'楷体';">使用</span>VGG16<span style="font-family:'楷体';">的</span><span style="font-family:'楷体';">第</span>13<span style="font-family:'楷体';">层</span><span style="font-family:'楷体';">卷积层特征作为共享特征。</span>每个<span style="font-family:'楷体';">阶段包含一个</span>loss<span style="font-family:'楷体';">，</span>下<span style="font-family:'楷体';">一阶段的</span>loss<span style="font-family:'楷体';">依赖于</span><span style="font-family:'楷体';">前一阶段</span>loss<span style="font-family:'楷体';">，故三个阶段的</span>loss<span style="font-family:'楷体';">都不是独立的。</span></p> 
<p align="justify"><strong>任务一</strong><span style="font-family:'楷体';">：</span>differentiating instance--&gt;regressing box-level instances <span style="font-family:'楷体';">，该阶段的主要任务找出所有可能的物体框，即使用</span><span style="font-family:Calibri;">Faster RCNN</span><span style="font-family:'楷体';">中的</span><span style="font-family:Calibri;">RPN</span><span style="font-family:'楷体';">网络，使用</span><span style="font-family:Calibri;">NMS</span><span style="font-family:'楷体';">得到 </span><span style="font-family:Calibri;">top-ranked 300</span><span style="font-family:'楷体';">个</span><span style="font-family:Calibri;">box</span><span style="font-family:'楷体';">；</span></p> 
<p align="justify"><span style="font-family:'楷体';">这一阶段的主要实现就是在共享特征的基础上附加一个</span>3*3<span style="font-family:'楷体';">的卷积层用于降维以及</span><span style="font-family:Calibri;">1*1</span><span style="font-family:'楷体';">的卷积用于目标框定位和目标分类。因此在这一阶段的</span><span style="font-family:Calibri;">loss</span><span style="font-family:'楷体';">，作者直接使用的是</span><span style="font-family:Calibri;">RPN</span><span style="font-family:'楷体';">的</span><span style="font-family:Calibri;">loss</span><span style="font-family:'楷体';">，即：</span></p> 
<p align="justify"><span style="text-align:center;">                                                        <img src="https://images2.imgbox.com/04/4d/Zv1N0rb3_o.png" align="middle" alt=""> </span></p> 
<p align="justify"><strong>任务二</strong><span style="font-family:'楷体';">：</span>estimating masks--&gt;regressing mask-level instances,<span style="font-family:'楷体';">该阶段的主要任务是以共享特征和上一阶段的得到的</span><span style="font-family:Calibri;">bounding box</span><span style="font-family:'楷体';">作为输入，输出基于</span><span style="font-family:Calibri;">box</span><span style="font-family:'楷体';">的</span><span style="font-family:Calibri;">pixel-level </span><span style="font-family:'楷体';">的</span><span style="font-family:Calibri;">mask</span><span style="font-family:'楷体';">，不过此时的</span><span style="font-family:Calibri;">mask</span><span style="font-family:'楷体';">是</span><span style="font-family:Calibri;">class-agnostic</span><span style="font-family:'楷体';">，即无法对</span><span style="font-family:Calibri;">mask</span><span style="font-family:'楷体';">进行类别区分。</span></p> 
<p align="justify"><span style="font-family:'楷体';">这一阶段的主要实现是在</span>task1 <span style="font-family:'楷体';">输出的不同大小的</span><span style="font-family:Calibri;">box</span><span style="font-family:'楷体';">上使用</span><strong><span style="color:rgb(255,0,0);">ROI warping Pooling</span></strong><span style="font-family:'楷体';">产生固定大小的特征</span>:14*14<span style="font-family:'楷体';">大小的</span><span style="font-family:Calibri;">feature map</span><span style="font-family:'楷体';">，在此基础上为每个</span><span style="font-family:Calibri;">box</span><span style="font-family:'楷体';">附加两个</span><span style="font-family:Calibri;">fc</span><span style="font-family:'楷体';">层：</span><span style="font-family:Calibri;">fc1(256)+fc2(m*m,28*28),</span><span style="font-family:'楷体';">这里的</span><span style="font-family:Calibri;">28*28</span><span style="font-family:'楷体';">是预先设定的</span><span style="font-family:Calibri;">mask</span><span style="font-family:'楷体';">的分辨率。因此这一阶段的</span><span style="font-family:Calibri;">task</span><span style="font-family:'楷体';">不仅是依赖于</span><span style="font-family:Calibri;">mask</span><span style="font-family:'楷体';">还依赖于</span><span style="font-family:Calibri;">box</span><span style="font-family:'楷体';">，所以这一阶段的</span><span style="font-family:Calibri;">loss</span><span style="font-family:'楷体';">，即：</span></p> 
<p align="justify"><span style="font-family:'楷体';">                           <img src="https://images2.imgbox.com/e1/85/5gocoQRC_o.png" alt=""><br></span></p> 
<p align="justify"><strong>任务三</strong><span style="font-family:'楷体';">：</span>categorizing objects--&gt;categorizing instances<span style="font-family:'楷体';">，该阶段的主要任务是以共享特征，</span><span style="font-family:Calibri;">task1</span><span style="font-family:'楷体';">的</span><span style="font-family:Calibri;">box</span><span style="font-family:'楷体';">，</span><span style="font-family:Calibri;">task2</span><span style="font-family:'楷体';">的</span><span style="font-family:Calibri;">mask</span><span style="font-family:'楷体';">作为输入，输出每个</span><span style="font-family:Calibri;">instance</span><span style="font-family:'楷体';">的</span><span style="font-family:Calibri;">categories scores</span><span style="font-family:'楷体';">。</span></p> 
<p align="justify"><span style="font-family:'楷体';">这一阶段的主要实现是，一方面，在</span>ROI warping pooling <span style="font-family:'楷体';">的基础上连接两个</span><span style="font-family:Calibri;">fc</span><span style="font-family:'楷体';">层：</span><span style="font-family:Calibri;">fc1(4096)+fc2(4096)</span><span style="font-family:'楷体';">；另一方面对</span><span style="font-family:Calibri;">task2</span><span style="font-family:'楷体';">得到的</span><span style="font-family:Calibri;">mask </span><span style="font-family:'楷体';">也连接两个</span><span style="font-family:Calibri;">fc</span><span style="font-family:'楷体';">层：</span><span style="font-family:Calibri;">fc1(4096)+fc2(4096)</span><span style="font-family:'楷体';">；然后再对这两个通道进行</span><span style="font-family:Calibri;">concat</span><span style="font-family:'楷体';">，最后得到每个</span><span style="font-family:Calibri;">instance</span><span style="font-family:'楷体';">的得分。因此这一阶段的计算量比较大，也是导致整个</span><span style="font-family:Calibri;">MNC</span><span style="font-family:'楷体';">模型巨大的原因。这一阶段的</span><span style="font-family:Calibri;">loss</span><span style="font-family:'楷体';">，如下：</span></p> 
<p align="justify"><span style="text-align:center;">                                    <img src="https://images2.imgbox.com/6e/d7/9rOAXiEY_o.png" alt=""> </span></p> 
<p align="justify"><strong>End-to-end training</strong></p> 
<p align="justify"><span style="font-family:'楷体';">整个</span>MNC<span style="font-family:'楷体';">网络结构的</span><span style="font-family:Calibri;">loss function</span><span style="font-family:'楷体';">如下：</span></p> 
<p align="justify"><span style="text-align:center;">                        <img src="https://images2.imgbox.com/2f/43/4JBTpanO_o.png" alt=""> </span></p> 
<p align="justify">MNC<span style="font-family:'楷体';">主要的技术挑战就是对上面的</span><span style="font-family:Calibri;">loss function </span><span style="font-family:'楷体';">如何可以应用链式法则进行反向传播，实现</span><span style="font-family:Calibri;">end-to-end training</span><span style="font-family:'楷体';">。</span><span style="font-family:'楷体';">在</span>fast R-CNN<span style="font-family:'楷体';">论文中使用的</span><span style="font-family:Calibri;">RoI pooling </span><span style="font-family:'楷体';">的预测框是经过预训练的，</span>是固定的，<span style="font-family:'楷体';">它的反向传播只考虑</span>F(Θ) ,<span style="font-family:'楷体';">但我们现在必须同时考虑</span><span style="font-family:Calibri;">Bi(Θ)</span>，而在这里得到的预测框确实在不断变化。<span style="font-family:'楷体';">但是，实际上</span>task2<span style="font-family:'楷体';">中的框是由</span>task1<span style="font-family:'楷体';">给出的，那么</span>task2<span style="font-family:'楷体';">的</span>loss<span style="font-family:'楷体';">就不只是依赖</span>mask<span style="font-family:'楷体';">，还依赖框。这导致了无法对这部分以</span>end to end<span style="font-family:'楷体';">的方式来训练，因为无法同时对这两部分求导。</span></p> 
<p><span style="font-family:'楷体';">为了解决上述问题，作者把</span>ROI pooling<span style="font-family:'楷体';">分为了两部分：</span>ROI warping <span style="font-family:'楷体';">与</span> pooling<span style="font-family:'楷体';">。</span>ROI warping的具体实现可以看原文。</p> 
<p><br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2de5fde32f088f9399865237b4e4ae5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Bootstrap栅栏布局里col-xs-*、col-sm-*、col-md-*、col-lg-*之间的区别及使用方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/408b46485983e3cbf3198dc77e505529/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">leetcode 第二高薪水</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>