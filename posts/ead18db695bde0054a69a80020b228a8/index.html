<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java实现录屏_Android5.0以上版本录屏实现代码(完整代码) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java实现录屏_Android5.0以上版本录屏实现代码(完整代码)" />
<meta property="og:description" content="我录屏的方式是分别录制音频和视频，最后合并成mp4格式，比较麻烦，因为网上完整的教程比较少，所以我打算写一个完整版的，照着我的代码写完之后，至少是能够实现功能的，而不是简单的介绍下用法。
1既然是录制视频，我们应该有一个按钮控制开始和结束。
2在录制之前，需要先判断一下Android系统的版本是否大于5.0，并且动态申请一下权限(读写，录音，照相机)，这一步可以在点开始按钮的时候执行
if (ContextCompat.checkSelfPermission(context, Manifest.permission.WRITE_EXTERNAL_STORAGE)
!= PackageManager.PERMISSION_GRANTED) {
ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 102);
}
if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO)
!= PackageManager.PERMISSION_GRANTED) {
ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.RECORD_AUDIO}, 103);
}
if (ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA)
!= PackageManager.PERMISSION_GRANTED) {
ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.RECORD_AUDIO}, 104);
}
Intent intent = null;
if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) {
intent = mediaProjectionManager.createScreenCaptureIntent();
startActivityForResult(intent, 101);//正常情况是要执行到这里的,作用是申请捕捉屏幕
} else {
ShowUtil.showToast(context, &#34;Android版本太低，无法使用该功能&#34;);
}
3定义MediaProjection和MediaProjectionManager等一些其他必要的变量
boolean isrun = false;//用来标记录屏的状态private MediaProjectionManager mediaProjectionManager;
private MediaProjection mediaProjection;//录制视频的工具private int width, height, dpi;//屏幕宽高和dpi，后面会用到" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ead18db695bde0054a69a80020b228a8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-21T12:26:10+08:00" />
<meta property="article:modified_time" content="2021-02-21T12:26:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java实现录屏_Android5.0以上版本录屏实现代码(完整代码)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>我录屏的方式是分别录制音频和视频，最后合并成mp4格式，比较麻烦，因为网上完整的教程比较少，所以我打算写一个完整版的，照着我的代码写完之后，至少是能够实现功能的，而不是简单的介绍下用法。</p> 
 <p>1既然是录制视频，我们应该有一个按钮控制开始和结束。</p> 
 <p>2在录制之前，需要先判断一下Android系统的版本是否大于5.0，并且动态申请一下权限(读写，录音，照相机)，这一步可以在点开始按钮的时候执行</p> 
 <p>if (ContextCompat.checkSelfPermission(context, Manifest.permission.WRITE_EXTERNAL_STORAGE)</p> 
 <p>!= PackageManager.PERMISSION_GRANTED) {<!-- --></p> 
 <p>ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 102);</p> 
 <p>}</p> 
 <p>if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO)</p> 
 <p>!= PackageManager.PERMISSION_GRANTED) {<!-- --></p> 
 <p>ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.RECORD_AUDIO}, 103);</p> 
 <p>}</p> 
 <p>if (ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA)</p> 
 <p>!= PackageManager.PERMISSION_GRANTED) {<!-- --></p> 
 <p>ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.RECORD_AUDIO}, 104);</p> 
 <p>}</p> 
 <p>Intent intent = null;</p> 
 <p>if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) {<!-- --></p> 
 <p>intent = mediaProjectionManager.createScreenCaptureIntent();</p> 
 <p>startActivityForResult(intent, 101);//正常情况是要执行到这里的,作用是申请捕捉屏幕</p> 
 <p>} else {<!-- --></p> 
 <p>ShowUtil.showToast(context, "Android版本太低，无法使用该功能");</p> 
 <p>}</p> 
 <p>3定义MediaProjection和MediaProjectionManager等一些其他必要的变量</p> 
 <p>boolean isrun = false;//用来标记录屏的状态private MediaProjectionManager mediaProjectionManager;</p> 
 <p>private MediaProjection mediaProjection;//录制视频的工具private int width, height, dpi;//屏幕宽高和dpi，后面会用到</p> 
 <p>private ScreenRecorder screenRecorder;//这个是自己写的录视频的工具类，下文会放完整的代码</p> 
 <p>Thread thread;//录视频要放在线程里去执行</p> 
 <p>在onCreat里写好实例化</p> 
 <p>mediaProjectionManager = (MediaProjectionManager) context.getSystemService(MEDIA_PROJECTION_SERVICE);</p> 
 <p>WindowManager manager = this.getWindowManager();</p> 
 <p>DisplayMetrics outMetrics = new DisplayMetrics();</p> 
 <p>manager.getDefaultDisplay().getMetrics(outMetrics);</p> 
 <p>width = outMetrics.widthPixels;</p> 
 <p>height = outMetrics.heightPixels;</p> 
 <p>dpi = outMetrics.densityDpi;</p> 
 <p>4我们在onActivityResult回调方法中，来处理返回的事件</p> 
 <p>@Override</p> 
 <p>protected void onActivityResult(int requestCode, int resultCode, Intent data) {<!-- --></p> 
 <p>if (requestCode == 102) {<!-- --></p> 
 <p>Toast.makeText(context, "缺少读写权限", Toast.LENGTH_SHORT).show();</p> 
 <p>return;</p> 
 <p>}</p> 
 <p>if (requestCode == 103) {<!-- --></p> 
 <p>Toast.makeText(context, "缺少录音权限", Toast.LENGTH_SHORT).show();</p> 
 <p>return;</p> 
 <p>}</p> 
 <p>if (requestCode == 104) {<!-- --></p> 
 <p>Toast.makeText(context, "缺少相机权限", Toast.LENGTH_SHORT).show();</p> 
 <p>return;</p> 
 <p>}</p> 
 <p>if (requestCode != 101) {<!-- --></p> 
 <p>Log.e("HandDrawActivity", "error requestCode =" + requestCode);</p> 
 <p>}</p> 
 <p>if (resultCode != RESULT_OK) {<!-- --></p> 
 <p>Toast.makeText(context, "捕捉屏幕被禁止", Toast.LENGTH_SHORT).show();</p> 
 <p>return;</p> 
 <p>}</p> 
 <p>mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, data);</p> 
 <p>if (mediaProjection != null) {<!-- --></p> 
 <p>screenRecorder = new ScreenRecorder(width, height, mediaProjection, dpi);</p> 
 <p>}</p> 
 <p>thread = new Thread() {<!-- --></p> 
 <p>@Override</p> 
 <p>public void run() {<!-- --></p> 
 <p>screenRecorder.startRecorder();//跟ScreenRecorder有关的下文再说，总之这句话的意思就是开始录屏的意思</p> 
 <p>}</p> 
 <p>};</p> 
 <p>thread.start();</p> 
 <p>binding.startPlayer.setText("停止");//开始和停止我用的同一个按钮，所以开始录屏之后把按钮文字改一下</p> 
 <p>isrun = true;//录屏状态改成真</p> 
 <p>}</p> 
 <p>5先放上ScreenRecorder代码，只想要结果的朋友呢，直接把类粘贴走，把报错的地方改一改(在我自己的项目里可是不报错的),就实现了录制屏幕的功能了，还想看看的，可以往下看看</p> 
 <p>import android.hardware.display.DisplayManager;</p> 
 <p>import android.media.MediaCodec;</p> 
 <p>import android.media.MediaCodecInfo;</p> 
 <p>import android.media.MediaFormat;</p> 
 <p>import android.media.MediaMuxer;</p> 
 <p>import android.media.MediaRecorder;</p> 
 <p>import android.media.projection.MediaProjection;</p> 
 <p>import android.os.Build;</p> 
 <p>import android.os.Environment;</p> 
 <p>import android.text.TextUtils;</p> 
 <p>import android.util.Log;</p> 
 <p>import android.view.Surface;</p> 
 <p>import com.coremedia.iso.boxes.Container;</p> 
 <p>import com.googlecode.mp4parser.authoring.Movie;</p> 
 <p>import com.googlecode.mp4parser.authoring.Track;</p> 
 <p>import com.googlecode.mp4parser.authoring.builder.DefaultMp4Builder;</p> 
 <p>import com.googlecode.mp4parser.authoring.container.mp4.MovieCreator;</p> 
 <p>import com.googlecode.mp4parser.authoring.tracks.AppendTrack;</p> 
 <p>import java.io.File;</p> 
 <p>import java.io.FileNotFoundException;</p> 
 <p>import java.io.IOException;</p> 
 <p>import java.io.RandomAccessFile;</p> 
 <p>import java.nio.ByteBuffer;</p> 
 <p>import java.nio.channels.FileChannel;</p> 
 <p>import java.util.ArrayList;</p> 
 <p>import java.util.LinkedList;</p> 
 <p>import java.util.List;</p> 
 <p>public class ScreenRecorder {<!-- --></p> 
 <p>private int mWidth, mHeight, mDensty;</p> 
 <p>private MediaProjection mediaProjection;</p> 
 <p>private MediaCodec.BufferInfo mBufferInfo;</p> 
 <p>private MediaCodec mEncorder;</p> 
 <p>private Surface mInputSurface;</p> 
 <p>private MediaMuxer mMuxer;</p> 
 <p>private boolean isQuit = false;</p> 
 <p>private boolean mMuxerStarted = false;</p> 
 <p>private int mTrackIndex;</p> 
 <p>private String path = Environment.getExternalStorageDirectory().getAbsolutePath() + "/cache";</p> 
 <p>private MediaRecorder mediaRecorder;</p> 
 <p>public ScreenRecorder(int mWidth, int mHeight, MediaProjection mediaProjection, int mDensty) {<!-- --></p> 
 <p>this.mWidth = mWidth;</p> 
 <p>this.mHeight = mHeight;</p> 
 <p>this.mediaProjection = mediaProjection;</p> 
 <p>this.mDensty = mDensty;</p> 
 <p>File file = new File(path);</p> 
 <p>if (!file.exists()) {<!-- --></p> 
 <p>file.mkdirs();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>public void startRecorder() {<!-- --></p> 
 <p>prepareRecorder();</p> 
 <p>startLuYin();</p> 
 <p>startRecording();</p> 
 <p>}</p> 
 <p>public void stop() {<!-- --></p> 
 <p>isQuit = true;</p> 
 <p>releaseEncorders(1);</p> 
 <p>List filePath = new ArrayList&lt;&gt;();</p> 
 <p>filePath.add(path + "/APlanyinpin.amr");</p> 
 <p>filePath.add(path + "/APlanshipin.mp4");</p> 
 <p>joinVideo(filePath, path);</p> 
 <p>}</p> 
 <p>public void destory() {<!-- --></p> 
 <p>releaseEncorders(0);</p> 
 <p>}</p> 
 <p>private void startLuYin() {<!-- --></p> 
 <p>File file = new File(path, "APlanyinpin.amr");</p> 
 <p>mediaRecorder = new MediaRecorder();</p> 
 <p>mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);</p> 
 <p>mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT);</p> 
 <p>mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT);</p> 
 <p>mediaRecorder.setOutputFile(file.getAbsolutePath());</p> 
 <p>try {<!-- --></p> 
 <p>mediaRecorder.prepare();</p> 
 <p>mediaRecorder.start();</p> 
 <p>Log.e("HandDrawActivity", "已经开始录音");</p> 
 <p>} catch (IOException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>private void prepareRecorder() {<!-- --></p> 
 <p>mBufferInfo = new MediaCodec.BufferInfo(); //元数据，描述bytebuffer的数据，尺寸，偏移</p> 
 <p>//创建格式化对象 MIMI_TYPE 传入的 video/avc 是H264编码格式</p> 
 <p>MediaFormat format = MediaFormat.createVideoFormat("video/avc", mWidth, mHeight);</p> 
 <p>int frameRate = 45;</p> 
 <p>format.setInteger(MediaFormat.KEY_BIT_RATE, 3000000);</p> 
 <p>format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);</p> 
 <p>format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 10);</p> 
 <p>format.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate);</p> 
 <p>format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 1);</p> 
 <p>format.setInteger(MediaFormat.KEY_CAPTURE_RATE, frameRate);</p> 
 <p>format.setInteger(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, 1000000 / frameRate);</p> 
 <p>try {<!-- --></p> 
 <p>mEncorder = MediaCodec.createEncoderByType("video/avc");</p> 
 <p>mEncorder.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);</p> 
 <p>mInputSurface = mEncorder.createInputSurface();</p> 
 <p>mEncorder.start();</p> 
 <p>} catch (IOException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>releaseEncorders(0);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>private void startRecording() {<!-- --></p> 
 <p>File saveFile = new File(path, "APlanshipin.mp4");</p> 
 <p>try {<!-- --></p> 
 <p>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {<!-- --></p> 
 <p>mMuxer = new MediaMuxer(saveFile.getAbsolutePath(), MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);</p> 
 <p>mediaProjection.createVirtualDisplay("SCREENRECORDER", mWidth, mHeight, mDensty, DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC,</p> 
 <p>mInputSurface, null, null);</p> 
 <p>drainEncoder();</p> 
 <p>}</p> 
 <p>} catch (Exception e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>private void drainEncoder() {<!-- --></p> 
 <p>while (!isQuit) {<!-- --></p> 
 <p>Log.e("TAG", "drain.....");</p> 
 <p>int bufferIndex = mEncorder.dequeueOutputBuffer(mBufferInfo, 0);</p> 
 <p>if (bufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) {<!-- --></p> 
 <p>try {<!-- --></p> 
 <p>Thread.sleep(10);</p> 
 <p>} catch (InterruptedException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if (bufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {<!-- --></p> 
 <p>mTrackIndex = mMuxer.addTrack(mEncorder.getOutputFormat());</p> 
 <p>if (!mMuxerStarted &amp;&amp; mTrackIndex &gt;= 0) {<!-- --></p> 
 <p>mMuxer.start();</p> 
 <p>mMuxerStarted = true;</p> 
 <p>Log.e("HandDrawActivity", "已经开始录屏");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if (bufferIndex &gt;= 0) {<!-- --></p> 
 <p>Log.e("TAG", "drain...write..");</p> 
 <p>ByteBuffer bufferData = mEncorder.getOutputBuffer(bufferIndex);</p> 
 <p>if ((mBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {<!-- --></p> 
 <p>mBufferInfo.size = 0;</p> 
 <p>}</p> 
 <p>if (mBufferInfo.size != 0) {<!-- --></p> 
 <p>if (mMuxerStarted) {<!-- --></p> 
 <p>bufferData.position(mBufferInfo.offset);</p> 
 <p>bufferData.limit(mBufferInfo.offset + mBufferInfo.size);</p> 
 <p>mMuxer.writeSampleData(mTrackIndex, bufferData, mBufferInfo);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>mEncorder.releaseOutputBuffer(bufferIndex, false);</p> 
 <p>if ((mBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {<!-- --></p> 
 <p>break;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>Log.e("HandDrawActivity", "已经结束录屏");</p> 
 <p>}</p> 
 <p>private void releaseEncorders(int i) {<!-- --></p> 
 <p>if (mediaProjection != null) {<!-- --></p> 
 <p>mediaProjection.stop();</p> 
 <p>}</p> 
 <p>mBufferInfo = null;</p> 
 <p>if (mEncorder != null) {<!-- --></p> 
 <p>mEncorder.stop();</p> 
 <p>}</p> 
 <p>mInputSurface = null;</p> 
 <p>if (mMuxer != null &amp;&amp; i == 1) {<!-- --></p> 
 <p>mMuxer.stop();</p> 
 <p>}</p> 
 <p>if (mediaRecorder != null) {<!-- --></p> 
 <p>mediaRecorder.stop();</p> 
 <p>mediaRecorder.reset();</p> 
 <p>mediaRecorder.release();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>private boolean joinVideo(List filePaths, String resultPath) {<!-- --></p> 
 <p>Log.e("HandDrawActivity", "准备合成中");</p> 
 <p>boolean result = false;</p> 
 <p>if (filePaths == null || filePaths.size() &lt;= 0 || TextUtils.isEmpty(resultPath)) {<!-- --></p> 
 <p>throw new IllegalArgumentException();</p> 
 <p>}</p> 
 <p>if (filePaths.size() == 1) { // 只有一个视频片段，不需要合并</p> 
 <p>return true;</p> 
 <p>}</p> 
 <p>try {<!-- --></p> 
 <p>Movie[] inMovies = new Movie[filePaths.size()];</p> 
 <p>for (int i = 0; i &lt; filePaths.size(); i++) {<!-- --></p> 
 <p>Log.e("HandDrawActivity", "filePaths=" + filePaths.get(i));</p> 
 <p>File f = new File(filePaths.get(i));</p> 
 <p>if (f.exists()) {<!-- --></p> 
 <p>inMovies[i] = MovieCreator.build(filePaths.get(i));</p> 
 <p>}</p> 
 <p>}</p> 
 <p>// 分别取出音轨和视频</p> 
 <p>List videoTracks = new LinkedList&lt;&gt;();</p> 
 <p>List audioTracks = new LinkedList&lt;&gt;();</p> 
 <p>for (Movie m : inMovies) {<!-- --></p> 
 <p>for (Track t : m.getTracks()) {<!-- --></p> 
 <p>if (t.getHandler().equals("soun")) {<!-- --></p> 
 <p>audioTracks.add(t);</p> 
 <p>}</p> 
 <p>if (t.getHandler().equals("vide")) {<!-- --></p> 
 <p>videoTracks.add(t);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>// 合并到最终的视频文件</p> 
 <p>Movie outMovie = new Movie();</p> 
 <p>if (audioTracks.size() &gt; 0) {<!-- --></p> 
 <p>outMovie.addTrack(new AppendTrack(audioTracks.toArray(new Track[audioTracks.size()])));</p> 
 <p>}</p> 
 <p>if (videoTracks.size() &gt; 0) {<!-- --></p> 
 <p>outMovie.addTrack(new AppendTrack(videoTracks.toArray(new Track[videoTracks.size()])));</p> 
 <p>}</p> 
 <p>Container mp4file = new DefaultMp4Builder().build(outMovie);</p> 
 <p>// 将文件输出</p> 
 <p>File resultFile = new File(resultPath, "APlanTeacherAnswer.mp4");</p> 
 <p>if (resultFile.exists() &amp;&amp; resultFile.isFile()) {<!-- --></p> 
 <p>resultFile.delete();</p> 
 <p>}</p> 
 <p>FileChannel fc = new RandomAccessFile(resultFile, "rw").getChannel();</p> 
 <p>mp4file.writeContainer(fc);</p> 
 <p>fc.close();</p> 
 <p>Log.e("HandDrawActivity", "合成完毕");</p> 
 <p>// 合成完成后把原片段文件删除</p> 
 <p>for (String filePath : filePaths) {<!-- --></p> 
 <p>File file = new File(filePath);</p> 
 <p>file.delete();</p> 
 <p>}</p> 
 <p>result = true;</p> 
 <p>HandDrawActivity.sendVideo();</p> 
 <p>} catch (FileNotFoundException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>} catch (Exception e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>return result;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>6从startRecorder方法说起</p> 
 <p>public void startRecorder() {<!-- --></p> 
 <p>prepareRecorder();//录视频前的准备</p> 
 <p>startLuYin();//直接录音频(不用准备)</p> 
 <p>startRecording();//录视频</p> 
 <p>}</p> 
 <p>录音的方法</p> 
 <p>private void startLuYin() {<!-- --></p> 
 <p>File file = new File(path, "APlanyinpin.amr");</p> 
 <p>mediaRecorder = new MediaRecorder();</p> 
 <p>mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);//声音来源，麦克</p> 
 <p>mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT);//音频格式，默认，其实就是上面定义好的amr了，除此之外还有mp4</p> 
 <p>mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT);//编码格式，问题是我不知道编码格式对什么有影响，是音质高低还是文件大小还是解析快慢，等我有时间去专门研究一下</p> 
 <p>mediaRecorder.setOutputFile(file.getAbsolutePath());</p> 
 <p>try {<!-- --></p> 
 <p>mediaRecorder.prepare();</p> 
 <p>mediaRecorder.start();</p> 
 <p>Log.e("HandDrawActivity", "已经开始录音");</p> 
 <p>} catch (IOException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>//录视频前的准备工作</p> 
 <p>private void prepareRecorder() {<!-- --></p> 
 <p>mBufferInfo = new MediaCodec.BufferInfo(); //元数据，描述bytebuffer的数据，尺寸，偏移</p> 
 <p>//创建格式化对象 MIMI_TYPE 传入的 video/avc 是H264编码格式</p> 
 <p>MediaFormat format = MediaFormat.createVideoFormat("video/avc", mWidth, mHeight);</p> 
 <p>int frameRate = 45;</p> 
 <p>format.setInteger(MediaFormat.KEY_BIT_RATE, 3000000);</p> 
 <p>format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);</p> 
 <p>format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 10);</p> 
 <p>format.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate);</p> 
 <p>format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 1);</p> 
 <p>format.setInteger(MediaFormat.KEY_CAPTURE_RATE, frameRate);</p> 
 <p>format.setInteger(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, 1000000 / frameRate);//编码器的设置，具体是设置的啥我也不太清楚，但是网上查一查都是这么写的！！！</p> 
 <p>try {<!-- --></p> 
 <p>mEncorder = MediaCodec.createEncoderByType("video/avc");</p> 
 <p>mEncorder.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);</p> 
 <p>mInputSurface = mEncorder.createInputSurface();</p> 
 <p>mEncorder.start();//让编码器先跑起来</p> 
 <p>} catch (IOException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>releaseEncorders(0);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>这里也是准备工作</p> 
 <p>private void startRecording() {<!-- --></p> 
 <p>File saveFile = new File(path, "APlanshipin.mp4");</p> 
 <p>try {<!-- --></p> 
 <p>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {<!-- --></p> 
 <p>mMuxer = new MediaMuxer(saveFile.getAbsolutePath(), MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);//百度一下MediaMuxer,讲的很详细的</p> 
 <p>mediaProjection.createVirtualDisplay("SCREENRECORDER", mWidth, mHeight, mDensty, DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC,</p> 
 <p>mInputSurface, null, null);</p> 
 <p>drainEncoder();</p> 
 <p>}</p> 
 <p>} catch (Exception e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>这个就是开始写视频文件了</p> 
 <p>private void drainEncoder() {<!-- --></p> 
 <p>while (!isQuit) {<!-- --></p> 
 <p>Log.e("TAG", "drain.....");</p> 
 <p>int bufferIndex = mEncorder.dequeueOutputBuffer(mBufferInfo, 0);</p> 
 <p>if (bufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) {<!-- --></p> 
 <p>try {<!-- --></p> 
 <p>Thread.sleep(10);</p> 
 <p>} catch (InterruptedException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if (bufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {<!-- --></p> 
 <p>mTrackIndex = mMuxer.addTrack(mEncorder.getOutputFormat());</p> 
 <p>if (!mMuxerStarted &amp;&amp; mTrackIndex &gt;= 0) {<!-- --></p> 
 <p>mMuxer.start();</p> 
 <p>mMuxerStarted = true;</p> 
 <p>Log.e("HandDrawActivity", "已经开始录屏");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if (bufferIndex &gt;= 0) {<!-- --></p> 
 <p>Log.e("TAG", "drain...write..");</p> 
 <p>ByteBuffer bufferData = mEncorder.getOutputBuffer(bufferIndex);</p> 
 <p>if ((mBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {<!-- --></p> 
 <p>mBufferInfo.size = 0;</p> 
 <p>}</p> 
 <p>if (mBufferInfo.size != 0) {<!-- --></p> 
 <p>if (mMuxerStarted) {<!-- --></p> 
 <p>bufferData.position(mBufferInfo.offset);</p> 
 <p>bufferData.limit(mBufferInfo.offset + mBufferInfo.size);</p> 
 <p>mMuxer.writeSampleData(mTrackIndex, bufferData, mBufferInfo);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>mEncorder.releaseOutputBuffer(bufferIndex, false);</p> 
 <p>if ((mBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {<!-- --></p> 
 <p>break;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>Log.e("HandDrawActivity", "已经结束录屏");</p> 
 <p>}</p> 
 <p>这个就是把录好的音频和视频合并成mp4的方法了，也是点击停止录屏的时候用到的</p> 
 <p>private boolean joinVideo(List filePaths, String resultPath) {<!-- --></p> 
 <p>Log.e("HandDrawActivity", "准备合成中");</p> 
 <p>boolean result = false;</p> 
 <p>if (filePaths == null || filePaths.size() &lt;= 0 || TextUtils.isEmpty(resultPath)) {<!-- --></p> 
 <p>throw new IllegalArgumentException();</p> 
 <p>}</p> 
 <p>if (filePaths.size() == 1) { // 只有一个视频片段，不需要合并</p> 
 <p>return true;</p> 
 <p>}</p> 
 <p>try {<!-- --></p> 
 <p>Movie[] inMovies = new Movie[filePaths.size()];</p> 
 <p>for (int i = 0; i &lt; filePaths.size(); i++) {<!-- --></p> 
 <p>Log.e("HandDrawActivity", "filePaths=" + filePaths.get(i));</p> 
 <p>File f = new File(filePaths.get(i));</p> 
 <p>if (f.exists()) {<!-- --></p> 
 <p>inMovies[i] = MovieCreator.build(filePaths.get(i));</p> 
 <p>}</p> 
 <p>}</p> 
 <p>// 分别取出音轨和视频</p> 
 <p>List videoTracks = new LinkedList&lt;&gt;();</p> 
 <p>List audioTracks = new LinkedList&lt;&gt;();</p> 
 <p>for (Movie m : inMovies) {<!-- --></p> 
 <p>for (Track t : m.getTracks()) {<!-- --></p> 
 <p>if (t.getHandler().equals("soun")) {<!-- --></p> 
 <p>audioTracks.add(t);</p> 
 <p>}</p> 
 <p>if (t.getHandler().equals("vide")) {<!-- --></p> 
 <p>videoTracks.add(t);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>// 合并到最终的视频文件</p> 
 <p>Movie outMovie = new Movie();</p> 
 <p>if (audioTracks.size() &gt; 0) {<!-- --></p> 
 <p>outMovie.addTrack(new AppendTrack(audioTracks.toArray(new Track[audioTracks.size()])));</p> 
 <p>}</p> 
 <p>if (videoTracks.size() &gt; 0) {<!-- --></p> 
 <p>outMovie.addTrack(new AppendTrack(videoTracks.toArray(new Track[videoTracks.size()])));</p> 
 <p>}</p> 
 <p>Container mp4file = new DefaultMp4Builder().build(outMovie);</p> 
 <p>// 将文件输出</p> 
 <p>File resultFile = new File(resultPath, "APlanTeacherAnswer.mp4");</p> 
 <p>if (resultFile.exists() &amp;&amp; resultFile.isFile()) {<!-- --></p> 
 <p>resultFile.delete();</p> 
 <p>}</p> 
 <p>FileChannel fc = new RandomAccessFile(resultFile, "rw").getChannel();</p> 
 <p>mp4file.writeContainer(fc);</p> 
 <p>fc.close();</p> 
 <p>Log.e("HandDrawActivity", "合成完毕");</p> 
 <p>// 合成完成后把原片段文件删除</p> 
 <p>for (String filePath : filePaths) {<!-- --></p> 
 <p>File file = new File(filePath);</p> 
 <p>file.delete();</p> 
 <p>}</p> 
 <p>result = true;</p> 
 <p>HandDrawActivity.sendVideo();</p> 
 <p>} catch (FileNotFoundException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>} catch (Exception e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>return result;</p> 
 <p>}</p> 
 <p>这个就是结束的时候了，该清空的清空，该注销的注销， i是用来判断录没录的，有可能刚进入这个页面都没录过，直接就返回到别的页面了，那就有可能空指针异常，因为有些变量都没初始化，所以用i判断一下，也可以自己写别的方法判端</p> 
 <p>private void releaseEncorders(int i) {<!-- --></p> 
 <p>if (mediaProjection != null) {<!-- --></p> 
 <p>mediaProjection.stop();</p> 
 <p>}</p> 
 <p>mBufferInfo = null;</p> 
 <p>if (mEncorder != null) {<!-- --></p> 
 <p>mEncorder.stop();</p> 
 <p>}</p> 
 <p>mInputSurface = null;</p> 
 <p>if (mMuxer != null &amp;&amp; i == 1) {<!-- --></p> 
 <p>mMuxer.stop();</p> 
 <p>}</p> 
 <p>if (mediaRecorder != null) {<!-- --></p> 
 <p>mediaRecorder.stop();</p> 
 <p>mediaRecorder.reset();</p> 
 <p>mediaRecorder.release();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>7部分代码也是我从网上扒的，但是网上的代码就没怎么见过比较完整的版本的，我上面写的都是经过我自己测试绝对没问题的而且代码也没什么遗漏的，要是发现有遗漏的代码我后续再补上。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e00f0452ab85e6e408b553f487796ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[css]  怎么让body高度自适应屏幕？为什么？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c101d8509288cc8c911ceae2eb72d6fb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[Spring]-注解开发与Junit集成</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>