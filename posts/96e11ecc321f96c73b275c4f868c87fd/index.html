<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis详解" />
<meta property="og:description" content="常见三类存储系统 RDBMS：关系型数据库系统 Oracle、DB2、PostgreSQL、MySQL、SQL Server...
NoSQL：非关系型数据库，又包含四种流派 键值存储
Memcache、Redis
列式存储
Hbase、Cassandra
文档存储
MongoDB
图式存储
Neo4j
NewSQL：本身在设计上就支持分布式的关系行数据库系统 Aerospike、FoundationDB、RethinkDB...
redis特性 既是一个缓存又是一个存储
in-memory：所有工作都在内存中实现，在磁盘上存储的主要目的是为了冗余
支持持久化存储 基于快照方式：数据异步传输，从内存中传输到磁盘上并保存起来
AOF：把每一次的写操作都直接附加在一个文件后面实现数据存储 支持主从的高可用：借助sentinel实现一定意义上的HA
支持分布式集群：读写操作可以在多借点进行
数据结构服务器：支持存储：字符串、列表、哈希（映射）、集合、有序集合等等
单线程：核心模块是单线程，这样的设计可以避免同步代码阻塞主线程，从而提高性能
支持消息队列，支持发布订阅特性
评估数据： 100W个较小键值需要消耗100M内存
在常见的linux之上支持大约50W的并发
Redis与memcached比较 redis组成： redis-server
redis-cli：客户端一般不用，通常调用API来实现请求
redis-benchmark：压测工具
redis-check-dump &amp; redis-check-aof：检查redis的两种持久化后的文件是否存在错误
安装配置redis 安装：yum -y install redis
启动redis
service redis start
或 redis-server --help 查看命令帮助
配置文件： vim /etc/redis.conf
daemonize no #是否为守护进程默认为no，即便为no但是基于脚本启动时依然运行为守护进程
port 6379 #默认端口
tcp-backlog 511 #定义 tcp等待队列的长度为511。redis的并发性很高，但是前端的并发访问量非常大并且接收缓冲都满掉了就会额外在找一个地方把新进来的请求暂存下来这个位置就叫backlog，tcp协议通常都会有backlog
bind 127.0.0.1 #监听地址 # unixsocket /tmp/redis.sock #定义socket文件位置，如果客户端和redis在同一台主机上建议像mysql一样打开socket。基于socket的客户端和服务端通信，在内存中直接交换数据，不再经过tcp/ip协议栈进行封装再重新拆封" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/96e11ecc321f96c73b275c4f868c87fd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T15:11:21+08:00" />
<meta property="article:modified_time" content="2024-01-09T15:11:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>常见三类存储系统</h2> 
<ul><li>RDBMS：关系型数据库系统</li></ul> 
<p>                Oracle、DB2、PostgreSQL、MySQL、SQL Server...</p> 
<ul><li>NoSQL：非关系型数据库，又包含四种流派</li></ul> 
<p>                键值存储</p> 
<p>                        Memcache、Redis</p> 
<p>                列式存储</p> 
<p>                        Hbase、Cassandra</p> 
<p>                文档存储</p> 
<p>                        MongoDB</p> 
<p>                图式存储</p> 
<p>                        Neo4j</p> 
<ul><li>NewSQL：本身在设计上就支持分布式的关系行数据库系统</li></ul> 
<p>                Aerospike、FoundationDB、RethinkDB...</p> 
<p></p> 
<h2>redis特性</h2> 
<p>        既是一个缓存又是一个存储</p> 
<p>        in-memory：所有工作都在内存中实现，在磁盘上存储的主要目的是为了冗余</p> 
<p>        支持持久化存储     </p> 
<p>                基于快照方式：数据异步传输，从内存中传输到磁盘上并保存起来</p> 
<p>                AOF：把每一次的写操作都直接附加在一个文件后面实现数据存储        </p> 
<p>        支持主从的高可用：借助sentinel实现一定意义上的HA</p> 
<p>        支持分布式集群：读写操作可以在多借点进行</p> 
<p>        数据结构服务器：支持存储：字符串、列表、哈希（映射）、集合、有序集合等等</p> 
<p>        单线程：核心模块是单线程，这样的设计可以避免同步代码阻塞主线程，从而提高性能</p> 
<p>        支持消息队列，支持发布订阅特性</p> 
<h2>评估数据：</h2> 
<p>        100W个较小键值需要消耗100M内存</p> 
<p>        在常见的linux之上支持大约50W的并发</p> 
<p></p> 
<h2>Redis与memcached比较</h2> 
<p>        <img alt="" height="345" src="https://images2.imgbox.com/e4/a8/lAvxqmb0_o.png" width="458"></p> 
<p>        </p> 
<h2>redis组成：</h2> 
<p>        redis-server</p> 
<p>        redis-cli：客户端一般不用，通常调用API来实现请求</p> 
<p>        redis-benchmark：压测工具</p> 
<p>        redis-check-dump &amp; redis-check-aof：检查redis的两种持久化后的文件是否存在错误</p> 
<p></p> 
<h2>安装配置redis</h2> 
<p>       安装：yum -y install redis</p> 
<p>        启动redis</p> 
<p>                service redis start</p> 
<p>                或 redis-server  --help 查看命令帮助</p> 
<p>        </p> 
<p>       配置文件： vim /etc/redis.conf</p> 
<p>                daemonize no  #是否为守护进程默认为no，即便为no但是基于脚本启动时依然运行为守护进程</p> 
<p>                port 6379  #默认端口</p> 
<p>                tcp-backlog 511 #定义 tcp等待队列的长度为511。redis的并发性很高，但是前端的并发访问量非常大并且接收缓冲都满掉了就会额外在找一个地方把新进来的请求暂存下来这个位置就叫backlog，tcp协议通常都会有backlog</p> 
<p>                bind 127.0.0.1  #监听地址               </p> 
<p>                # unixsocket /tmp/redis.sock  #定义socket文件位置，如果客户端和redis在同一台主机上建议像mysql一样打开socket。基于socket的客户端和服务端通信，在内存中直接交换数据，不再经过tcp/ip协议栈进行封装再重新拆封<br>                 # unixsocketperm 700  #和socket文件的访问权限</p> 
<p>                timeout 0  #客户端连接空闲多长时间后超时，0表示禁用此功能</p> 
<p>                tcp-keepalive 300 # <a class="link-info" href="https://zhuanlan.zhihu.com/p/545240783?utm_id=0" rel="nofollow" title="TCP keepalive和HTTP keepalive">TCP keepalive和HTTP keepalive</a></p> 
<p>                loglevel notice  # 日志级别</p> 
<p>                logfile /var/log/redis/redis.log</p> 
<p>                # syslog-enabled no  #基于syslog来记录</p> 
<p>                databases 16  #database表示redis内部的集合，表示可以用多少的database</p> 
<p>             <strong>   （快照存储） </strong>          <br>                #   save &lt;seconds&gt; &lt;changes&gt; #配置方法，每隔多少秒如果发生多大变化就进行存储</p> 
<p>               # save "" #表示禁用使用快照做持久化</p> 
<p>                        示例：save 60 10000  #每隔60秒，有超过10000个键发生变化就做一次快照</p> 
<p>               stop-writes-on-bgsave-error yes  #在进行bgsave（异步快照）时发生错误是否停止备份</p> 
<p>                rdbcompression yes  #rdb文件是否执行压缩</p> 
<p>                rdbchecksum yes  #是否对rdb的镜像文件做校验码检测</p> 
<p>                dbfilename dump.rdb  #rdb文件名</p> 
<p>                dir /var/lib/redis  #rdb文件保存位置</p> 
<p>                </p> 
<p>                <strong>（主从配置）</strong></p> 
<p><strong>                </strong># slaveof &lt;masterip&gt; &lt;masterport&gt; #启用此项是从服务器，指定主服务器ip和端口</p> 
<p>                slave-read-only yes  #从服务器只读</p> 
<p>                <strong>（限制</strong>）</p> 
<p>                # maxclients 10000  #指明最大的客户端并发数</p> 
<p>                # maxmemory &lt;bytes&gt;  #指定最多使用内存</p> 
<p>               <strong> （AOF持久化存储）</strong></p> 
<p><strong>                </strong>appendonly no  #是否启用AOF</p> 
<p>                appendfilename "appendonly.aof"  #AOF文件保存位置               </p> 
<p>                # appendfsync always  #每次执行完写操作都通知内核往磁盘同步一次<br>                 appendfsync everysec  #每秒通知内核往磁盘同步一次<br>                 # appendfsync no  #由内核自定决定</p> 
<p>                no-appendfsync-on-rewrite no  #做重写AOF时，对新写的操作不做同步而暂存到缓存中               </p> 
<p>                auto-aof-rewrite-percentage 100  #当前的AOF文件是上次重写时的二倍会自动触发一次重写操作<br>                 auto-aof-rewrite-min-size 64mb  #最小重新大小为64M</p> 
<p></p> 
<p></p> 
<p></p> 
<h2>客户端命令用法</h2> 
<p># redis-cli  #不指定参数表示连接到本地</p> 
<p>  Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]</p> 
<p>    -h &lt;hostname&gt;  #指定远程主机地址  <br>     -p &lt;port&gt;         <br>     -s &lt;socket&gt;     #本地连接 <br>     -a &lt;password&gt;     <br>     -r &lt;repeat&gt;       #执行n次命令<br>     -i &lt;interval&gt;  #每个命令执行完等待一段时间</p> 
<h2>redis交互式命令用法</h2> 
<p>help #获取帮助</p> 
<p>        help @&lt;group&gt; #因为redis支持众多数据结构，所以可以指定获取某一种数据结构所支持的操作</p> 
<p>                例： help @STRING #字符串所支持的操作</p> 
<p>        help &lt;command&gt;  #查询命令帮助</p> 
<p>        help &lt;tab&gt;  #可以用tab键自动填充命令</p> 
<p>SELECT int  #指定打开几号名称空间（数据库），一共可以有16个，默认为0号名称空间。</p> 
<p>        注意：同一个名称空间下键名是不允许重复的</p> 
<h4>String 结构常用命令（help @string）</h4> 
<p>SET key value [EX seconds]  [NX|XX]  #添加键值对或修改键值</p> 
<p>        #EX seconds 为设置过期时间</p> 
<p>        #NX 键不存在时才会执行</p> 
<p>        #XX 键存在时才会执行</p> 
<p>        例：set shop_a pingpang NX</p> 
<p>GET key #获取键值</p> 
<p>        例：get shop_a</p> 
<p>APPEND key value  #附加字符串</p> 
<p>        例：APPEND shop_a qiu</p> 
<p>STRLEN key #获取键值长度</p> 
<p>INCR key #整数型键值加一</p> 
<p>DECR key #整数型键值减一</p> 
<p>        例：</p> 
<p>                set count 0</p> 
<p>                INCR count</p> 
<p>                DECR count</p> 
<p>SETEX key seconds value  #设置过期时间</p> 
<p></p> 
<p></p> 
<h4>list 结构常用命令（help @list）</h4> 
<p>LINDEX key index  #获取索引</p> 
<p>LSET key index value  #修改列表中指定的索引的值</p> 
<p>RPUSH #从列表右边塞入一个元素，也可以定义一个新列表</p> 
<p>LPUSH #从列表左边塞入一个元素，也可以定义一个新列表</p> 
<p>RPUSH  #如果没有相同的值则从列表右边塞入一个元素</p> 
<p>LPUSHX  #如果没有相同的值则从列表左边塞入一个元素</p> 
<p>LPOP #从列表左边弹出一个元素</p> 
<p>RPOP #从列表右边弹出一个元素</p> 
<p>LLEN key  #获取指定列表长度       </p> 
<ul><li>示例</li></ul> 
<p>        LPUSH list1 a b c fsd awc #定义一个列表</p> 
<p>        LINDEX list1 6 #获取列表中第7个值</p> 
<p></p> 
<h4>set（集合） 结构常用命令（help @set）</h4> 
<p>SADD key member [member ...] #定义集合或向集合里添加元素</p> 
<p>SISMEMBER key member #判断指定的值是否是集群元素</p> 
<p>SINTER key [key ...] #多个集合交集运算</p> 
<p>SUNION key [key ...]  #多个集合并集运算</p> 
<p>SCARD key  #获取集合的元素的个数</p> 
<p>SDIFFSTORE destination key [key ...] #多个集合差集运算并保存在一个键中</p> 
<p>SINTERSTORE destination key [key ...]  #多个集合交集运算并存储到一个键中</p> 
<p>SUNIONSTORE destination key [key ...]  #多个集合并集运算并存储到一个键中</p> 
<p>SPOP key [count]  #随机弹出一个或几个元素</p> 
<p>SRANDMEMBER key [count]  #随机获取一个或多个元素</p> 
<p>SREM key member [member ...]  #从集合中删除一个或多个元素</p> 
<p>SSCAN key cursor [MATCH pattern] [COUNT count]  #遍历集群中的元素</p> 
<p>        SSCAN set1  0  #表示变量所有</p> 
<p></p> 
<h4>sorted_set（有序集合） 结构常用命令（help @sorted_set）</h4> 
<p>ZADD key [NX|XX] [CH] [INCR] score member [score member ...] #定义有序集合或添加集合元素</p> 
<p>ZCARD key  #获取个数</p> 
<p>ZCOUNT key min max  #获取指定范围内的元素个数</p> 
<p>ZRANGE key start stop [WITHSCORES]  #获取指定范围内的元素</p> 
<p>ZRANK key member  #查询指定元素的索引</p> 
<p>ZREM key member [member ...]  #删除一个或多个元素</p> 
<p>ZSCORE key member  #获取指定元素位于集合的第几个从1开始计算</p> 
<p>ZSCAN key cursor [MATCH pattern] [COUNT count]  #变量集群</p> 
<p>        例：ZSCAN sort_set 0 变量集群所有元素</p> 
<p></p> 
<h4>hash（映射，类似于字典） 结构常用命令（help @hash）</h4> 
<p>HSET key field value  #定义和添加hash元素</p> 
<p>HSETNX key field value  #只有不存在时才会设定</p> 
<p>HDEL key field [field ...]  #删除一个或多个元素</p> 
<p> HGET key field  #获取指定键值</p> 
<p>HSCAN key cursor [MATCH pattern] [COUNT count]  #基于游标方式遍历hash中的每一个值</p> 
<p>HKEYS key  #获取所有键列表</p> 
<p>HVALS key  #获取所有值列表</p> 
<p></p> 
<h4>适合全体类型的命令</h4> 
<p>EXISTS key [key ...]  #判断键是否存在</p> 
<p>DEL key [key ...]  #删除一个键</p> 
<p>TYPE key  #返回值的类型</p> 
<p>KEYS pattern  #满足给定pattern 的所有key</p> 
<p>RENAME key newkey  #重命名key</p> 
<p>EXPIRE key seconds #设置一个key的生存时间</p> 
<p>TTL key  #获得一个key的生存时间</p> 
<p>MOVE key db #将当前数据库的key转移到有dbindex索引的数据库<br>  </p> 
<p></p> 
<h4>redis 连接相关命令（help @connection）</h4> 
<p>AUTH  #认证相关</p> 
<p>PING  #测试服务器是否在线</p> 
<p>ECHO message  #打印</p> 
<p>QUIT</p> 
<p>SELECT</p> 
<h4>服务器端相关命令（help @server）</h4> 
<p>BGSAVE #异步将数据集同步到磁盘，需要启动快照功能，不会阻塞操作</p> 
<p>SAVE  #再主线程中同步保存快照，再主线程保存完成之前所有操作都会被阻塞 </p> 
<p>LASTSAVE  #获取最近一次数据保存到磁盘的时间戳</p> 
<p>CLIENT GETNAME  #获取当前客户端的连接名</p> 
<p>CLIENT KILL [ip:port] [ID client-id]  #关闭指定连接</p> 
<p>CLIENT SETNAME connection-name  #设置当前连接名</p> 
<p>CONFIG SET parameter value  #运行时直接修改配置参数，只在当前生效不会保存到配置文件中</p> 
<p>CONFIG GET parameter  #获取当前配置参数值</p> 
<p>CONFIG REWRITE  #把内存中修改的配置参数同步到配置文件中</p> 
<p>INFO [section]  #获取当前服务器状态统计数据</p> 
<p>CONFIG RESETSTAT  #重置INFO 信息</p> 
<p>DBSIZE  #获取当前数据库中键的数量</p> 
<p>FLUSHDB  #删除当前选择数据库的所有key</p> 
<p>FLUSHALL  #清空数据库</p> 
<p>MONITOR  #实时监控访问redis的请求</p> 
<p>SHUTDOWN [NOSAVE|SAVE]  #关闭redis，并设置是否做安全的数据同步</p> 
<p>SLAVEOF host port  #配置主从</p> 
<p>SLOWLOG subcommand [argument]  #显示redis慢查询日志，需要开启慢查询日志功能</p> 
<p>TIME  #返回当前时间</p> 
<p>SYNC  #复制的内建命令</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2>认证机制（默认只要是bind配置的IP中任何人都可以访问）</h2> 
<p>配置访问密码</p> 
<p>        vim /etc/redis.conf</p> 
<p>        requirepass 123456 #搜索requirepass 在下行添加上：requirepass  密码</p> 
<p>        service  redis restart  #重启redis</p> 
<p>        redis-cli  #登录到redis交互页面</p> 
<p>        AUTH 123456 #进行认证</p> 
<p></p> 
<h2>redis事务</h2> 
<p>redis事务：将多个命令进行打包一次性进行执行，在这个事务执行完之前其他的命令都会被阻塞</p> 
<p>        注意：redis事务不支持回滚</p> 
<p>MULTI  #开始一个事务，并把执行命令放在队列中</p> 
<p>EXEC  #当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行，并且服务器遍历客户端的事务队列，执行队列中保存的所有命令，最后将执行结果全部返回给客户端</p> 
<p>WATCH  #乐观锁，他可以在EXEC命令执行之前监视指定任意数量的数据库键，并且在EXEC命令执行时检查被监视的键是否有被其他客户端修改，如果是服务将拒绝执行事务并向客户端返回事务执行失败的结果</p> 
<p>示例：</p> 
<pre><code class="language-bash">[root@cj ~]# redis-cli
127.0.0.1:6379&gt; MULTI
OK
127.0.0.1:6379&gt; SET IP 172.0.0.1
QUEUED
127.0.0.1:6379&gt; GET IP
QUEUED
127.0.0.1:6379&gt; SET NAME XIAOMING
QUEUED
127.0.0.1:6379&gt; GET NAME
QUEUED
127.0.0.1:6379&gt; EXEC
1) OK
2) "172.0.0.1"
3) OK
4) "XIAOMING"
127.0.0.1:6379&gt;
</code></pre> 
<p></p> 
<h2>redis 的发布与订阅功能</h2> 
<p>SUBSCRIBE channel [channel ...]  #订阅一个或多个频道</p> 
<p>PSUBSCRIBE pattern [pattern ...]  #基于正则表达式模式订阅频道</p> 
<p>PUBLISH channel message  #向某个频道发消息</p> 
<p>UNSUBSCRIBE [channel [channel ...]]  #退订一个或多个频道</p> 
<p>PUNSUBSCRIBE [pattern [pattern ...]]  #基于模式匹配退订频道</p> 
<p></p> 
<h2>redis的持久化</h2> 
<p>注意：持久不能取代数据备份，对redis数据库定期进行备份</p> 
<h4>RDB</h4> 
<p>RDB：快照机制，保存的数据是二进制格式。按照事先定制的策略，周期性的将数据保存至磁盘，数据文件默认为dump.rdb。此持久化方法是每次同步一次内存中所有的数据而不是增量的方式所以比较占用IO</p> 
<p>工作模式：redis会创建一个子进程负责将内存中的内容快照到磁盘临时文件上去，父进程继续处理其他redis操作，当操作完成临时文件会替换旧dump.rdb 文件。不足之处是当rendis异常恢复的数据是快照时间的数据，最新一部分数据会丢失。</p> 
<h4>AOF</h4> 
<p>AOF：将redis每一次操作命令都以附加的方式直接附加到指定文件的尾部，当redis重启时可以通过重新执行文件中的命令在内存中重建数据库。可以实时进行持久话，但是文件会变得越来越大，例如重复执行一万次某一个操作但真正生效的是最后一个也会把这一万次记录保存下来</p> 
<p>BGREWRITEAOF  #完成AOF文件的重写。这种重写不会重读旧的AOF文件，重写时会创建一个子进程通过直接重读内存中的数据，为内存中所有数据生成一个命令集。所以它是类似于快照的操作将内存中的数据以命令的方式保存到临时文件中完成后去替换原来的AOF文件，所以AOF文件可以通过重写变小</p> 
<p></p> 
<h2>主从复制</h2> 
<p>特点：</p> 
<p>        一个master可以有多个slave，slave也可以有slave</p> 
<p>        master以非阻塞方式将数据同步至slave：可以同时处理数据和同步多个slave</p> 
<p></p> 
<p>过程：</p> 
<p>        启动一个slave后，slave会向master发送请求同步主库上的数据。matser此时会启动一个子进程将内存数据快照保存到磁盘的数据文件中，并把数据文件发送给slave。slave收到后把数据文件保存到本地磁盘后从磁盘重载到内存中完成同步</p> 
<p>        注意：如果主服务器开启认证功能，从服务器需要使用masterauth &lt;PASSWORD&gt; 来连入服务请求使用此密码进行认证</p> 
<p>配置从服务器命令：</p> 
<p>        SLAVEOF host port  #指定主服务器IP和端口</p> 
<p>配置文件：</p> 
<p># slaveof &lt;masterip&gt; &lt;masterport&gt;  #配置启用从服务器</p> 
<p>slave-serve-stale-data yes  #主服务器异常，从服务器数据是否还可以继续被读取</p> 
<p>slave-read-only yes  #从服务器是否只读</p> 
<p>repl-diskless-sync no  #是否基于diskless机制同步，适用于磁盘慢带宽大的场景</p> 
<p>repl-diskless-sync-delay 5  #延迟时间多少秒</p> 
<p>repl-disable-tcp-nodelay no  #是否启用tcp-nodelay 功能</p> 
<p>slave-priority 100  #指明slave的优先级</p> 
<p># min-slaves-to-write 3  #如果从节点小于3个则禁止主服务器在接受写请求</p> 
<p># min-slaves-max-lag 10  #同步时间差不能小于10秒钟以上，否则主服务器拒绝写入</p> 
<p></p> 
<h2>sentinel（哨兵模式）实现高可用</h2> 
<ul><li>作用：</li></ul> 
<p>        监控多个服务器节点是否异常</p> 
<p>        故障转移：如果检测到主服务器异常自动挑选一个从服务器作为主。并告知其他从服务器</p> 
<p>        sentinel本身是一个分布式系统，例如三个sentinel节点在发现主redis故障时互相确认是否都访问不到主redis。防止单节点sentinel发生故障</p> 
<ul><li>安装：</li></ul> 
<p>        redis-sentinel就是一个有着特殊代码的redis，启动redis时使用参数：./redis-server /etc/sentinel.conf --sentinel 就相当于启动一个sentinel</p> 
<ul><li>启动步骤：</li></ul> 
<p>       （1）运行redis-server中专用于 sentinel的功能代码</p> 
<p>        （2）初始化sentinel状态，根据指定的配置文件初始化监控的matser服务器列表</p> 
<p>        （3）创建向master的连接</p> 
<p></p> 
<ul><li>配置文件 ：/etc/redis-sentinel.conf</li></ul> 
<p>        port 26379</p> 
<p>        logfile /var/log/redis/sentinel.log</p> 
<p>        sentinel monitor mymaster 127.0.0.1 6379 2  #指定matser的主机名（可以自定义）、IP、端口、法定票数（每个sentinel 节点可以有一票），默认最少2票才能执行操作。</p> 
<p>        sentinel down-after-milliseconds mymaster 30000  #master连接失败多少毫秒之后才认为是离线</p> 
<p>        sentinel parallel-syncs mymaster 1  #在执行故障转移时最多可以有多少个从服务器对新服务器进行同步</p> 
<p>        sentinel failover-timeout mymaster 180000  #故障转移的超时时间单位毫秒</p> 
<ul><li>命令：</li></ul> 
<p>        SENTINEL masters  #获取所有所监视的主节点对应配置的详细信息</p> 
<p>        SENTINEL slaves masterName #获取指定master的从服务器详细信息</p> 
<p>        SENTINEL get-master-addr-by-name &lt;master name&gt; 根据master名字获取IP地址；或者根据地址获取名字</p> 
<p>        SENTINEL reset  #重置服务器所有状态</p> 
<p>        SENTINEL failover  &lt;master name&gt; #手动执行故障转移</p> 
<p></p> 
<ul><li>Clustering</li></ul> 
<p>        去中心化分布式数据库，通过分片机制进行数据分布，每个节点仅持有数据库的一部分数据</p> 
<p>        </p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bbfb18e44c70f940140409af48479b2c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【分布式微服务专题】SpringSecurity OAuth2快速入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8958cb365f4aa13b6fc68ba2bd06f82/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【前端】前后端的网络通信基础操作（原生ajax, axios, fetch）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>