<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python 变量作用域浅谈 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python 变量作用域浅谈" />
<meta property="og:description" content="本文主要介绍了Python 变量作用域的相关资料，文中讲解非常细致，代码帮助大家更好的理解和学习，感兴趣的朋友可以了解下
特点
python的作用域是静态的，在源代码中变量名被赋值的位置决定了该变量能被访问的范围。即Python变量的作用域由变量所在源代码中的位置决定。Python中并不是所有的语句块中都会产生作用域。只有当变量在Module(模块)、Class(类)、def(函数)中定义的时候，才会有作用域的概念。
1. 函数内部的变量，函数外部不能访问
1
2
3
4
def func():
variable = 100
print(variable) print(variable) # name &#39;variable&#39; is not defined
2. 函数上层的变量(标量)只能读取，不能再次定义，初始化
1
2
3
4
5
6
7
8
def counter1():
n = 0
def compute():
n = n &#43; 1 # n为标量（数值，字符串，浮点数），Python程序会因为“如果内部函数有引用外部函数的同名变量或者全局变量,并且对这个变量有修改.那么python会认为它是一个局部变量,又因为函数中没有n的定义和赋值，所以报错
# y = n &#43; 1 # 更改为y就没事
# return y
return n
return compute
1
2
3
4
5
6
variable = 300" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/debf93bd74d20f5250614df724af0be7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-07T23:03:49+08:00" />
<meta property="article:modified_time" content="2023-07-07T23:03:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python 变量作用域浅谈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" src="https://images2.imgbox.com/fa/4e/DdjrVs7D_o.jpg"></p> 
<p>本文主要介绍了Python 变量作用域的相关资料，文中讲解非常细致，代码帮助大家更好的理解和学习，感兴趣的朋友可以了解下</p> 
<p><strong>特点</strong></p> 
<p>python的作用域是静态的，在源代码中变量名被赋值的位置决定了该变量能被访问的范围。即Python变量的作用域由变量所在源代码中的位置决定。Python中并不是所有的语句块中都会产生作用域。只有当变量在Module(模块)、Class(类)、def(函数)中定义的时候，才会有作用域的概念。</p> 
<p><strong>1. 函数内部的变量，函数外部不能访问</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>def</code> <code>func():</code></p> <p><code>  </code><code>variable </code><code>=</code> <code>100</code></p> <p><code>  </code><code>print</code><code>(variable) </code></p> <p><code>print</code><code>(variable) </code><code># name 'variable' is not defined</code></p> </td></tr></tbody></table> 
<p><strong>2. 函数上层的变量(标量)只能读取，不能再次定义，初始化</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>def</code> <code>counter1():</code></p> <p><code>  </code><code>n </code><code>=</code> <code>0</code></p> <p><code>  </code><code>def</code> <code>compute():</code></p> <p><code>    </code><code>n </code><code>=</code> <code>n </code><code>+</code> <code>1</code> <code># n为标量（数值，字符串，浮点数），Python程序会因为“如果内部函数有引用外部函数的同名变量或者全局变量,并且对这个变量有修改.那么python会认为它是一个局部变量,又因为函数中没有n的定义和赋值，所以报错</code></p> <p><code>    </code><code># y = n + 1 # 更改为y就没事</code></p> <p><code>    </code><code># return y</code></p> <p><code>    </code><code>return</code> <code>n</code></p> <p><code>  </code><code>return</code> <code>compute</code></p> </td></tr></tbody></table> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>variable </code><code>=</code> <code>300</code></p> <p><code>def</code> <code>test_scopt():</code></p> <p><code>  </code><code>print</code><code>(variable) </code><code># 此时调用局部变量variable并有没绑定到一个内存对象(没有定义和初始化，即没有赋值)。本质上还是遵循的LEGB法则</code></p> <p><code>  </code><code>variable </code><code>=</code> <code>200</code> <code>#因为这里，前面调用过一次，所以variable就变为了局部变量</code></p> <p><code>  </code><code># print(variable) # 写在下面就没问题，因为variable是新的局部变量，而不是重新被定义，却没有绑定</code></p> <p><code>test_scopt()</code></p> </td></tr></tbody></table> 
<p>Python中的模块代码在执行之前，并不会经过预编译，但是模块内的函数体代码在运行前会经过预编译，因此不管变量名的绑定发生在作用域的那个位置，都能被编译器知道。Python虽然是一个静态作用域语言，但变量名查找是动态发生的，直到在程序运行时，才会发现作用域方面的问题,</p> 
<p><strong>3. list，dict等复合变量里面的值都可以引用更改</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> </td><td> <p><code>def</code> <code>counter():</code></p> <p><code>  </code><code>n </code><code>=</code> <code>[</code><code>0</code><code>]</code></p> <p><code>  </code><code>def</code> <code>compute():</code></p> <p><code>    </code><code>n[</code><code>0</code><code>] </code><code>+</code><code>=</code> <code>1</code> <code># 更改的是n里面的第一个值，不是更改n</code></p> <p><code>    </code><code>return</code> <code>n[</code><code>0</code><code>]</code></p> <p><code>  </code><code>return</code> <code>compute</code></p> <p></p> <p><code>func </code><code>=</code> <code>counter()</code></p> <p><code>func() </code><code># 1</code></p> <p><code>func() </code><code># 2</code></p> <p><code>func() </code><code># 3</code></p> </td></tr></tbody></table> 
<p><strong>4. global 声明全局变量，如果在局部要对全局变量修改，需要在局部也要先声明该全局变量</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> </td><td> <p><code>def</code> <code>counter1():</code></p> <p><code>  </code><code>n </code><code>=</code> <code>0</code></p> <p><code>  </code><code>def</code> <code>compute():</code></p> <p><code>    </code><code>global</code> <code>n </code><code># 如果在局部要对全局变量修改，需要在局部也要先声明该全局变量,但此处也会报错，因为没有全局变量n</code></p> <p><code>    </code><code>n </code><code>+</code><code>=</code> <code>1</code></p> <p><code>    </code><code>return</code> <code>n</code></p> <p><code>  </code><code>return</code> <code>compute</code></p> <p></p> <p></p> <p><code># right</code></p> <p><code>def</code> <code>counter1():</code></p> <p><code>  </code><code>global</code> <code>n</code></p> <p><code>  </code><code>n </code><code>=</code> <code>0</code></p> <p><code>  </code><code>def</code> <code>compute():</code></p> <p><code>    </code><code>global</code> <code>n</code></p> <p><code>    </code><code>n </code><code>+</code><code>=</code> <code>1</code></p> <p><code>    </code><code>return</code> <code>n</code></p> <p><code>  </code><code>return</code> <code>compute</code></p> </td></tr></tbody></table> 
<p><strong>5. nonlocal关键字用来在函数或其他作用域中使用外层(非全局)变量</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>def</code> <code>make_counter():</code></p> <p><code>  </code><code>count </code><code>=</code> <code>0</code></p> <p><code>  </code><code>def</code> <code>counter():</code></p> <p><code>    </code><code>nonlocal count </code><code># 使用外层非全局变量</code></p> <p><code>    </code><code>count </code><code>+</code><code>=</code> <code>1</code></p> <p><code>    </code><code>return</code> <code>count</code></p> <p><code>  </code><code>return</code> <code>counter</code></p> </td></tr></tbody></table> 
<p><strong>作用域的类型</strong></p> 
<p>在Python中，使用一个变量时并不严格要求需要预先声明它，但是在真正使用它之前，它必须被绑定到某个内存对象(被定义、赋值)；这种变量名的绑定将在当前作用域中引入新的变量，同时屏蔽外层作用域中的同名变量。</p> 
<p><strong>L(local)局部作用域</strong></p> 
<p>局部变量：包含在def关键字定义的语句块中，即在函数中定义的变量。每当函数被调用时都会创建一个新的局部作用域。Python中也有递归，即自己调用自己，每次调用都会创建一个新的局部命名空间。在函数内部的变量声明，除非特别的声明为全局变量，否则均默认为局部变量。有些情况需要在函数内部定义全局变量，这时可以使用global关键字来声明变量的作用域为全局。局部变量域就像一个 栈，仅仅是暂时的存在，依赖创建该局部作用域的函数是否处于活动的状态。所以，一般建议尽量少定义全局变量，因为全局变量在模块文件运行的过程中会一直存在，占用内存空间。<br> 注意：如果需要在函数内部对全局变量赋值，需要在函数内部通过global语句声明该变量为全局变量。</p> 
<p><strong>E(enclosing)嵌套作用域</strong></p> 
<p>E也包含在def关键字中，E和L是相对的，E相对于更上层的函数而言也是L。与L的区别在于，对一个函数而言，L是定义在此函数内部的局部作用域，而E是定义在此函数的上一层父级函数的局部作用域。主要是为了实现Python的闭包，而增加的实现。</p> 
<p><strong>G(global)全局作用域</strong></p> 
<p>即在模块层次中定义的变量，每一个模块都是一个全局作用域。也就是说，在模块文件顶层声明的变量具有全局作用域，从外部开来，模块的全局变量就是一个模块对象的属性。<br> 注意：全局作用域的作用范围仅限于单个模块文件内</p> 
<p><strong>B(built-in)内置作用域</strong></p> 
<p>系统内固定模块里定义的变量，如预定义在builtin 模块内的变量。</p> 
<p><strong>作用域链：变量名解析LEGB法则</strong></p> 
<p>搜索变量名的优先级：局部作用域 &gt; 嵌套作用域 &gt; 全局作用域 &gt; 内置作用域<br> LEGB法则： 当在函数中使用未确定的变量名时，Python会按照优先级依次搜索4个作用域，以此来确定该变量名的意义。首先搜索局部作用域(L)，之后是上一层嵌套结构中def或lambda函数的嵌套作用域(E)，之后是全局作用域(G)，最后是内置作用域(B)。按这个查找原则，在第一处找到的地方停止。如果没有找到，则会出发NameError错误。</p> 
<p>example 1</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> </td><td> <p><code>name </code><code>=</code> <code>"lzl"</code></p> <p></p> <p><code>def</code> <code>f1():</code></p> <p><code>  </code><code>print</code><code>(name)</code></p> <p></p> <p><code>def</code> <code>f2():</code></p> <p><code>  </code><code>name </code><code>=</code> <code>"eric"</code></p> <p><code>  </code><code>f1()</code></p> <p><code>  </code> </p> <p><code>f2() </code><code># 在函数未执行之前，作用域链就已经形成了，此时f1()的上一级应该name = 'lzl'</code></p> </td></tr></tbody></table> 
<p>example 2</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> </td><td> <p><code>def</code> <code>scope_test():</code></p> <p><code>  </code><code>def</code> <code>do_local():</code></p> <p><code>    </code><code>spam </code><code>=</code> <code>"local spam"</code> <code># 此函数定义了另外的一个spam字符串变量，并且生命周期只在此函数内。此处的spam和外层的spam是两个变量，如果写出spam = spam + “local spam” 会报错</code></p> <p><code>  </code><code>def</code> <code>do_nonlocal():</code></p> <p><code>    </code><code>nonlocal spam  </code><code># 使用外层的spam变量 test spam</code></p> <p><code>    </code><code>spam </code><code>=</code> <code>"nonlocal spam"</code></p> <p><code>  </code><code>def</code> <code>do_global():</code></p> <p><code>    </code><code>global</code> <code>spam</code></p> <p><code>    </code><code>spam </code><code>=</code> <code>"global spam"</code></p> <p><code>  </code><code>spam </code><code>=</code> <code>"test spam"</code></p> <p><code>  </code><code>do_local()</code></p> <p><code>  </code><code>print</code><code>(</code><code>"After local assignmanent:"</code><code>, spam) </code><code># test spam</code></p> <p><code>  </code><code>do_nonlocal()</code></p> <p><code>  </code><code>print</code><code>(</code><code>"After nonlocal assignment:"</code><code>,spam) </code><code># nonlocal spam</code></p> <p><code>  </code><code>do_global()</code></p> <p><code>  </code><code>print</code><code>(</code><code>"After global assignment:"</code><code>,spam) </code><code># nonlocal spam ???? 先找是本地变量，找到的本地变量已经在do_nonlocal()里面改变了所以输出的是nonlocal spam</code></p> <p></p> <p><code>scope_test()</code></p> <p><code>print</code><code>(</code><code>"In global scope:"</code><code>,spam) </code><code># global spam</code></p> </td></tr></tbody></table> 
<p>以上就是深入了解Python 变量作用域的详细内容，更多</p> 
<p></p> 
<p></p> 
<p></p> 
<p>转自：<a class="link-info" href="https://m.weidianyuedu.com/" rel="nofollow" title="微点阅读">微点阅读</a>   <a href="https://www.weidianyuedu.com" rel="nofollow" title="https://www.weidianyuedu.com">https://www.weidianyuedu.com</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5398d41f9ab9c1582049894156d9a0ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于搞视觉识别的数据处理的一些注意事项及诸多代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/718dfbb9b750e58c7e9f7f73ccde05eb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue&#43;springboot架构，后端service层介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>