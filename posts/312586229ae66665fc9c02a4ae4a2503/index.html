<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中连接字符串时使用&#43;号与使用StringBuilder的区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中连接字符串时使用&#43;号与使用StringBuilder的区别" />
<meta property="og:description" content="字符串是Java程序中最常用的一种数据结构之一。在Java中的String类已经重载的”&#43;”。也就是说，字符串可以直接使用”&#43;”进行连接，如下面代码所示：
String s = &#34;abc&#34; &#43; &#34;ddd&#34;; 但这样做真的好吗？当然，这个问题不能简单地回答yes orno。要根据具体情况来定。 在Java中提供了一个StringBuilder类（这个类只在J2SE5及以上版本提供，以前的版本使用StringBuffer类），这个类也可以起到”&#43;”的作用。那么我们应该用哪个呢？ 下面让我们先看看如下的代码：
package string; public class TestSimplePlus { public static void main(String[] args) { String s = &#34;abc&#34;; String ss = &#34;ok&#34; &#43; s &#43; &#34;xyz&#34; &#43; 5; System.out.println(ss); } } 上面的代码将会输出正确的结果。从表面上看，对字符串和整型使用”&#43;”号并没有什么区别，但事实真的如此吗？下面让我们来看看这段代码的本质。 我们首先使用反编译工具（如jdk带的javap、或jad）将TestSimplePlus反编译成Java Byte Code，其中的奥秘就一目了然了。在本文将使用jad来反编译，命令如下：
jad -o -a -s d.java TestSimplePlus.class 反编译后的代码如下：
package string; import java.io.PrintStream; public class TestSimplePlus { public TestSimplePlus() { // 0 0:aload_0 // 1 1:invokespecial #8 &lt;Method void Object()&gt; // 2 4:return } public static void main(String args[]) { String s = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/312586229ae66665fc9c02a4ae4a2503/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-01-29T16:35:10+08:00" />
<meta property="article:modified_time" content="2018-01-29T16:35:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中连接字符串时使用&#43;号与使用StringBuilder的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>　　字符串是Java程序中最常用的一种数据结构之一。在Java中的String类已经重载的”+”。也就是说，字符串可以直接使用”+”进行连接，如下面代码所示：</p> 
<pre class="prettyprint"><code class="language-java hljs ">String s = <span class="hljs-string">"abc"</span> + <span class="hljs-string">"ddd"</span>;</code></pre> 
<p>　　但这样做真的好吗？当然，这个问题不能简单地回答yes orno。要根据具体情况来定。 <br> 　　在Java中提供了一个StringBuilder类（这个类只在J2SE5及以上版本提供，以前的版本使用StringBuffer类），这个类也可以起到”+”的作用。那么我们应该用哪个呢？ <br> 　　 <br> 下面让我们先看看如下的代码：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> string;

  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSimplePlus</span> {<!-- --></span>
      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
          String s = <span class="hljs-string">"abc"</span>;
          String ss = <span class="hljs-string">"ok"</span> + s + <span class="hljs-string">"xyz"</span> + <span class="hljs-number">5</span>;
          System.out.println(ss);
      }
  }</code></pre> 
<p>　　上面的代码将会输出正确的结果。从表面上看，对字符串和整型使用”+”号并没有什么区别，但事实真的如此吗？下面让我们来看看这段代码的本质。 <br> 　　我们首先使用反编译工具（如jdk带的javap、或jad）将TestSimplePlus反编译成Java Byte Code，其中的奥秘就一目了然了。在本文将使用jad来反编译，命令如下：</p> 
<pre class="prettyprint"><code class=" hljs lasso">jad <span class="hljs-attribute">-o</span> <span class="hljs-attribute">-a</span> <span class="hljs-attribute">-s</span> d<span class="hljs-built_in">.</span>java TestSimplePlus<span class="hljs-built_in">.</span>class</code></pre> 
<p>反编译后的代码如下：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> string;

<span class="hljs-keyword">import</span> java.io.PrintStream;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSimplePlus</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-title">TestSimplePlus</span>() {
    <span class="hljs-comment">//    0    0:aload_0         </span>
    <span class="hljs-comment">//    1    1:invokespecial   #8   &lt;Method void Object()&gt;</span>
    <span class="hljs-comment">//    2    4:return          </span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String args[]) {
      String s = <span class="hljs-string">"abc"</span>;
    <span class="hljs-comment">//    0    0:ldc1            #16  &lt;String "abc"&gt;</span>
    <span class="hljs-comment">//    1    2:astore_1        </span>
      String ss = (<span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"ok"</span>)).append(s).append(<span class="hljs-string">"xyz"</span>).append(<span class="hljs-number">5</span>).toString();
    <span class="hljs-comment">//    2    3:new             #18  &lt;Class StringBuilder&gt;</span>
    <span class="hljs-comment">//    3    6:dup             </span>
    <span class="hljs-comment">//    4    7:ldc1            #20  &lt;String "ok"&gt;</span>
    <span class="hljs-comment">//    5    9:invokespecial   #22  &lt;Method void StringBuilder(String)&gt;</span>
    <span class="hljs-comment">//    6   12:aload_1         </span>
    <span class="hljs-comment">//    7   13:invokevirtual   #25  &lt;Method StringBuilder StringBuilder.append(String)&gt;</span>
    <span class="hljs-comment">//    8   16:ldc1            #29  &lt;String "xyz"&gt;</span>
    <span class="hljs-comment">//    9   18:invokevirtual   #25  &lt;Method StringBuilder StringBuilder.append(String)&gt;</span>
    <span class="hljs-comment">//   10   21:iconst_5        </span>
    <span class="hljs-comment">//   11   22:invokevirtual   #31  &lt;Method StringBuilder StringBuilder.append(int)&gt;</span>
    <span class="hljs-comment">//   12   25:invokevirtual   #34  &lt;Method String StringBuilder.toString()&gt;</span>
    <span class="hljs-comment">//   13   28:astore_2        </span>
      System.out.println(ss);
    <span class="hljs-comment">//   14   29:getstatic       #38  &lt;Field PrintStream System.out&gt;</span>
    <span class="hljs-comment">//   15   32:aload_2         </span>
    <span class="hljs-comment">//   16   33:invokevirtual   #44  &lt;Method void PrintStream.println(String)&gt;</span>
    <span class="hljs-comment">//   17   36:return          </span>
    }
}</code></pre> 
<p>　　读者可能看到上面的Java字节码感到迷糊，不过大家不必担心。本文的目的并不是讲解Java Byte Code，因此，并不用了解具体的字节码的含义。 <br> 　　使用jad反编译的好处之一就是可以同时生成字节码和源代码。这样可以进行对照研究。从上面的代码很容易看出，虽然在源程序中使用了”+”，但在编译时仍然将”+”转换成StringBuilder。因此，我们可以得出结论：<strong>*在Java中无论使用何种方式进行字符串连接，实际上都使用的是StringBuilder。</strong> <br> 　　那么是不是可以根据这个结论推出使用”+”和StringBuilder的效果是一样的呢？这个要从两个方面的解释。如果从运行结果来解释，那么”+”和StringBuilder是完全等效的。但如果从运行效率和资源消耗方面看，那它们将存在很大的区别。 <br> 　　当然，如果连接字符串行表达式很简单（如上面的顺序结构），那么”+”和StringBuilder基本是一样的，但如果结构比较复杂，如使用循环来连接字符串，那么产生的Java Byte Code就会有很大的区别。先让我们看看如下的代码：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> string;

<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestComplexPlus</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        String s = <span class="hljs-string">""</span>;
        Random rand = <span class="hljs-keyword">new</span> Random();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            s = s + rand.nextInt(<span class="hljs-number">1000</span>) + <span class="hljs-string">" "</span>;
        }
        System.out.println(s);
    }
}</code></pre> 
<p>上面的代码返编译后的Java Byte Code如下：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> string;

<span class="hljs-keyword">import</span> java.io.PrintStream;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestComplexPlus</span> {<!-- --></span>

    <span class="hljs-keyword">public</span> <span class="hljs-title">TestComplexPlus</span>() {
    <span class="hljs-comment">//    0    0:aload_0         </span>
    <span class="hljs-comment">//    1    1:invokespecial   #8   &lt;Method void Object()&gt;</span>
    <span class="hljs-comment">//    2    4:return          </span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String args[]) {
        String s = <span class="hljs-string">""</span>;
    <span class="hljs-comment">//    0    0:ldc1            #16  &lt;String ""&gt;</span>
    <span class="hljs-comment">//    1    2:astore_1        </span>
        Random rand = <span class="hljs-keyword">new</span> Random();
    <span class="hljs-comment">//    2    3:new             #18  &lt;Class Random&gt;</span>
    <span class="hljs-comment">//    3    6:dup             </span>
    <span class="hljs-comment">//    4    7:invokespecial   #20  &lt;Method void Random()&gt;</span>
    <span class="hljs-comment">//    5   10:astore_2        </span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
    <span class="hljs-comment">//*   6   11:iconst_0        </span>
    <span class="hljs-comment">//*   7   12:istore_3        </span>
    <span class="hljs-comment">//*   8   13:goto            49</span>
         s = (<span class="hljs-keyword">new</span> StringBuilder(String.valueOf(s))).append(rand.nextInt(<span class="hljs-number">1000</span>)).append(<span class="hljs-string">"                 "</span>).toString();
    <span class="hljs-comment">//    9   16:new             #21  &lt;Class StringBuilder&gt;</span>
    <span class="hljs-comment">//   10   19:dup             </span>
    <span class="hljs-comment">//   11   20:aload_1         </span>
    <span class="hljs-comment">//   12   21:invokestatic    #23  &lt;Method String String.valueOf(Object)&gt;</span>
    <span class="hljs-comment">//   13   24:invokespecial   #29  &lt;Method void StringBuilder(String)&gt;</span>
    <span class="hljs-comment">//   14   27:aload_2         </span>
    <span class="hljs-comment">//   15   28:sipush          1000</span>
    <span class="hljs-comment">//   16   31:invokevirtual   #32  &lt;Method int Random.nextInt(int)&gt;</span>
    <span class="hljs-comment">//   17   34:invokevirtual   #36  &lt;Method StringBuilder StringBuilder.append(int)&gt;</span>
    <span class="hljs-comment">//   18   37:ldc1            #40  &lt;String " "&gt;</span>
    <span class="hljs-comment">//   19   39:invokevirtual   #42  &lt;Method StringBuilder StringBuilder.append(String)&gt;</span>
    <span class="hljs-comment">//   20   42:invokevirtual   #45  &lt;Method String StringBuilder.toString()&gt;</span>
    <span class="hljs-comment">//   21   45:astore_1        </span>

    <span class="hljs-comment">//   22   46:iinc            3  1</span>
    <span class="hljs-comment">//   23   49:iload_3         </span>
    <span class="hljs-comment">//   24   50:bipush          10</span>
    <span class="hljs-comment">//   25   52:icmplt          16</span>
        System.out.println(s);
    <span class="hljs-comment">//   26   55:getstatic       #49  &lt;Field PrintStream System.out&gt;</span>
    <span class="hljs-comment">//   27   58:aload_1         </span>
    <span class="hljs-comment">//   28   59:invokevirtual   #55  &lt;Method void PrintStream.println(String)&gt;</span>
    <span class="hljs-comment">//   29   62:return          </span>
    }
}</code></pre> 
<p>　　大家可以看到，虽然编译器将”+”转换成了StringBuilder，但创建StringBuilder对象的位置却在for语句内部。这就意味着每执行一次循环，就会创建一个StringBuilder对象（对于本例来说，是创建了10个StringBuilder对象），虽然Java有垃圾回收器，但这个回收器的工作时间是不定的。如果不断产生这样的垃圾，那么仍然会占用大量的资源。解决这个问题的方法就是在程序中直接使用StringBuilder来连接字符串，代码如下：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> string;

<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStringBuilder</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        String s = <span class="hljs-string">""</span>;
        Random rand = <span class="hljs-keyword">new</span> Random();
        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            result.append(rand.nextInt(<span class="hljs-number">1000</span>));
            result.append(<span class="hljs-string">" "</span>);
        }
        System.out.println(result.toString());
    }
}</code></pre> 
<p>上面代码反编译后的结果如下：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> string;

<span class="hljs-keyword">import</span> java.io.PrintStream;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStringBuilder</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-title">TestStringBuilder</span>() {
    <span class="hljs-comment">//    0    0:aload_0         </span>
    <span class="hljs-comment">//    1    1:invokespecial   #8   &lt;Method void Object()&gt;</span>
    <span class="hljs-comment">//    2    4:return          </span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String args[]) {
        String s = <span class="hljs-string">""</span>;
    <span class="hljs-comment">//    0    0:ldc1            #16  &lt;String ""&gt;</span>
    <span class="hljs-comment">//    1    2:astore_1        </span>
        Random rand = <span class="hljs-keyword">new</span> Random();
    <span class="hljs-comment">//    2    3:new             #18  &lt;Class Random&gt;</span>
    <span class="hljs-comment">//    3    6:dup             </span>
    <span class="hljs-comment">//    4    7:invokespecial   #20  &lt;Method void Random()&gt;</span>
    <span class="hljs-comment">//    5   10:astore_2        </span>
        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();
    <span class="hljs-comment">//    6   11:new             #21  &lt;Class StringBuilder&gt;</span>
    <span class="hljs-comment">//    7   14:dup             </span>
    <span class="hljs-comment">//    8   15:invokespecial   #23  &lt;Method void StringBuilder()&gt;</span>
    <span class="hljs-comment">//    9   18:astore_3        </span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    <span class="hljs-comment">//*  10   19:iconst_0        </span>
    <span class="hljs-comment">//*  11   20:istore          4</span>
    <span class="hljs-comment">//*  12   22:goto            47</span>
            result.append(rand.nextInt(<span class="hljs-number">1000</span>));
    <span class="hljs-comment">//   13   25:aload_3         </span>
    <span class="hljs-comment">//   14   26:aload_2         </span>
    <span class="hljs-comment">//   15   27:sipush          1000</span>
    <span class="hljs-comment">//   16   30:invokevirtual   #24  &lt;Method int Random.nextInt(int)&gt;</span>
    <span class="hljs-comment">//   17   33:invokevirtual   #28  &lt;Method StringBuilder StringBuilder.append(int)&gt;</span>
    <span class="hljs-comment">//   18   36:pop             </span>
            result.append(<span class="hljs-string">" "</span>);
    <span class="hljs-comment">//   19   37:aload_3         </span>
    <span class="hljs-comment">//   20   38:ldc1            #32  &lt;String " "&gt;</span>
    <span class="hljs-comment">//   21   40:invokevirtual   #34  &lt;Method StringBuilder StringBuilder.append(String)&gt;</span>
    <span class="hljs-comment">//   22   43:pop             </span>
        }

    <span class="hljs-comment">//   23   44:iinc            4  1</span>
    <span class="hljs-comment">//   24   47:iload           4</span>
    <span class="hljs-comment">//   25   49:bipush          10</span>
    <span class="hljs-comment">//   26   51:icmplt          25</span>
        System.out.println(result.toString());
    <span class="hljs-comment">//   27   54:getstatic       #37  &lt;Field PrintStream System.out&gt;</span>
    <span class="hljs-comment">//   28   57:aload_3         </span>
    <span class="hljs-comment">//   29   58:invokevirtual   #43  &lt;Method String StringBuilder.toString()&gt;</span>
    <span class="hljs-comment">//   30   61:invokevirtual   #47  &lt;Method void PrintStream.println(String)&gt;</span>
    <span class="hljs-comment">//   31   64:return          </span>
    }
}</code></pre> 
<p>　　从上面的反编译结果可以看出，创建StringBuilder的代码被放在了for语句外。虽然这样处理在源程序中看起来复杂，但却换来了更高的效率，同时消耗的资源也更少了。 <br> 　　在使用StringBuilder时要注意，尽量不要”+”和StringBuilder混着用，否则会创建更多的StringBuilder对象，如下面代码所示：</p> 
<pre class="prettyprint"><code class="language-java hljs "> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    result.append(rand.nextInt(<span class="hljs-number">1000</span>));
    result.append(<span class="hljs-string">" "</span>);
}</code></pre> 
<p>改成如下形式：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
     result.append(rand.nextInt(<span class="hljs-number">1000</span>) + <span class="hljs-string">" "</span>);
}</code></pre> 
<p>则反编译后的结果如下：</p> 
<pre class="prettyprint"><code class="language-java hljs ">··· ···
 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
  <span class="hljs-comment">//*  10   19:iconst_0        </span>
  <span class="hljs-comment">//*  11   20:istore          4</span>
  <span class="hljs-comment">//*  12   22:goto            65</span>
    result.append((<span class="hljs-keyword">new</span> StringBuilder(String.valueOf(rand.nextInt(<span class="hljs-number">1000</span>)))).append(<span class="hljs-string">" "</span>).toString());
  <span class="hljs-comment">//   13   25:aload_3         </span>
  <span class="hljs-comment">//   14   26:new             #21  &lt;Class StringBuilder&gt;</span>
  <span class="hljs-comment">//   15   29:dup             </span>
··· ···</code></pre> 
<p>　　从上面的代码可以看出，Java编译器将”+”编译成了StringBuilder，这样for语句每循环一次，又创建了一个StringBuilder对象。 <br> 　　如果将上面的代码在JDK1.4下编译，必须将StringBuilder改为StringBuffer，而JDK1.4将”+”转换为StringBuffer（因为JDK1.4并没有提供StringBuilder类）。StringBuffer和StringBuilder的功能基本一样，只是StringBuffer是线程安全的，而StringBuilder不是线程安全的。因此，StringBuilder的效率会更高。</p> 
<p>转自： <br> URL：<a href="http://www.blogjava.net/nokiaguy/archive/2008/05/07/198990.html" rel="nofollow">http://www.blogjava.net/nokiaguy/archive/2008/05/07/198990.html</a> <br> 作者：李宁_Lining</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4a3bc2bcf23ef45f2d5370a15acd25b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">过滤器Filter的写法及注意事项</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/785a19866d64efce872b138c22b31d53/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CP-ABE Toolkit使用方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>