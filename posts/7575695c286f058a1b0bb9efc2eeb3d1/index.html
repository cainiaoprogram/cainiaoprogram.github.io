<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中涉及常见面试整理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中涉及常见面试整理" />
<meta property="og:description" content="Java中涉及常见面试整理 1．JDK 与 JRE 区别？
JDK 是Java开发工具包，包含Java的运行时环境；
JRE是Java运行时环境（包含Java基础的使用类库以及Java虚拟机）
2．Java基本数据类型有哪些
Java 基本数据类型：
整形：byte short int long
浮点型：float double
字符型：char
布尔型：boolean
3．final在Java中的作用？
修饰类：表示 该类不能被继承，类中所有成员方法都被隐式指定为final方法；
修饰方法：不可被重写；
修饰变量：不可被改变，修饰引用变量表示引用不可变，引用的内容可变；
修饰常量：编译阶段被存入常量池中；
4．Java 中操作字符串都有那些类，区别？
操作字符串的类有：String StringBuilder StringBuffer
String：只读字符串，每次对String的操作都会产生一个新的对象；
StringBuilder： 可变的字符数组，线程不安全，效率相对高；
SringBuffer ： 可变的字符数组，线程安全。
5．接口与抽象类的区别？
（1）抽象类中可以定义构造器，接口不能；
（2）抽象类可以有抽象方法和具体方法，接口中不能有具体方法；
（3）抽象类中可以定义成员变量，接口中只能是常量；
（4）抽象类中可以包含静态方法，接口不行；
6．TCP协议三次握手与四次挥手，能否是2次握手或者是4次？
三次握手：
第一次握手：客户端给服务端发送SYN(同步序号标志位)报文，申请建立客户端到服务端的连接；
第二次握手：服务端接收客户端的数据报文后，服务端返回 SYN&#43;ACK(确认号是否有效) 给客户端以确认连接服务端到客户端的请求；
第三次握手：客户端接收到服务端返回的数据报，将状态置为established，并返回ACK 给服务端，服务端接收到这个ACK，就将状态置为established，建立了服务端到客户端的连接；
四次挥手：
第一次挥手：客户端发送FIN（结束报文段）到服务端，申请建立关闭客户端到服务端的连接；第二次挥手：服务端接收到FIN，将状态置为close_wait，并返回一个ACK应答给客户端（TCP协议默认执行）第三次挥手：服务端发送一个FIN到客户端，申请关闭服务端到客户端的连接，并执行关闭前的一些操作；第四次挥手：客户端返回ACK到服务端，并将状态置为close_wait，需要等待一段时间（防止丢包重传FIN），客户端在将状态置为closed，等服务端接收到这个数据报时，将状态置为closed关闭连接； 不可以是2次，不可靠；
可以是4次，但存在效率问题；
7．Java常见容器有哪些？
list：有序的集合，元素可以重复，可以进行索引访问以及动态扩容；
map：使用键值对存储元素，元素不允许重复，无序；
set：元素不能重复，无序；
8．ArrayList 与LinkedList 区别？
ArrayList：底层采用数组来存储元素，因此物理上连续，支持随机访问，支持扩容，但在任意位置插入删除元素，需要进行元素的搬移，因此，时间复杂度为O(N)；
LinkedList：底层采用双向链表结构，因此逻辑上是连续的但物理上不一定连续；，不支持随机访问，并且没有扩容的概念；任意位置插入删除元素，只需要修改引用即可，因此时间复杂度为O(1)。
9．栈、虚拟机栈、栈帧、操作数栈区别？
栈：是一种后进先出的数据结构，在Java中对应的实现为Stack；
虚拟机栈：是一块具有特殊作用的内存空间，生命周期与线程相同，JVM为了方便管理，将内存分为栈区与堆区；栈区，线程是私有的，主要存放函数调用的一些信息，主要有栈帧，堆区：一般new出来的空间都在堆区；
栈帧：用于支持Java虚拟机进行方法调用和执行的数据结构，每个方法在执行时都会创建一个栈帧，用于保存局部变量表、操作数栈、动态链接以及方法出口等信息，当方法调用结束时，该方法对应的栈帧会从虚拟机栈中进行出栈；
操作数栈：也被称作操作栈，是一个后进先出的栈，同局部变量表一样，在编译期间，操作数栈的最大最大深度就被确定下来了。
10．HashMap 为什么要重写 HashCode 与 equals 方法？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7575695c286f058a1b0bb9efc2eeb3d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-07T17:23:22+08:00" />
<meta property="article:modified_time" content="2022-10-07T17:23:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中涉及常见面试整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Java中涉及常见面试整理</h4> 
</div> 
<p></p> 
<p><strong><mark>1．JDK 与 JRE 区别？</mark></strong></p> 
<blockquote> 
 <p><code>JDK</code> 是<code>Java</code>开发工具包，包含Java的运行时环境；<br> <code>JRE</code>是Java运行时环境（包含Java基础的使用类库以及Java虚拟机）</p> 
</blockquote> 
<p><strong><mark>2．Java基本数据类型有哪些</mark></strong></p> 
<p><code>Java</code> 基本数据类型：</p> 
<blockquote> 
 <p>整形：<code>byte short int long</code><br> 浮点型：<code>float double</code><br> 字符型：<code>char</code><br> 布尔型：<code>boolean</code></p> 
</blockquote> 
<p><strong><mark>3．final在Java中的作用？</mark></strong></p> 
<blockquote> 
 <p><strong>修饰类</strong>：表示 <code>该类不能被继承</code>，类中所有成员方法都被隐式指定为final方法；<br> <strong>修饰方法</strong>：不可被重写；<br> <strong>修饰变量</strong>：不可被改变，修饰引用变量表示引用不可变，引用的内容可变；<br> <strong>修饰常量</strong>：编译阶段被存入常量池中；</p> 
</blockquote> 
<p><strong><mark>4．Java 中操作字符串都有那些类，区别？</mark></strong></p> 
<blockquote> 
 <p>操作字符串的类有：<code>String</code> <code>StringBuilder</code> <code>StringBuffer</code><br> <code>String</code>：只读字符串，每次对String的操作都会产生一个新的对象；<br> <code>StringBuilder</code>： 可变的字符数组，线程不安全，效率相对高；<br> <code>SringBuffer</code> ： 可变的字符数组，线程安全。</p> 
</blockquote> 
<p><strong><mark>5．接口与抽象类的区别？</mark></strong></p> 
<blockquote> 
 <p>（1）抽象类中可以定义构造器，接口不能；<br> （2）抽象类可以有抽象方法和具体方法，接口中不能有具体方法；<br> （3）抽象类中可以定义成员变量，接口中只能是常量；<br> （4）抽象类中可以包含静态方法，接口不行；</p> 
</blockquote> 
<p><strong><mark>6．TCP协议三次握手与四次挥手，能否是2次握手或者是4次？</mark></strong></p> 
<p><strong>三次握手</strong>：</p> 
<blockquote> 
 <ul><li> <p>第一次握手：客户端给服务端发送<code>SYN</code>(同步序号标志位)报文，申请建立客户端到服务端的连接；</p> </li><li> <p>第二次握手：服务端接收客户端的数据报文后，服务端返回 <code>SYN+ACK(确认号是否有效)</code> 给客户端以确认连接服务端到客户端的请求；</p> </li><li> <p>第三次握手：客户端接收到服务端返回的数据报，将状态置为<code>established</code>，并返回<code>ACK</code> 给服务端，服务端接收到这个<code>ACK</code>，就将状态置为<code>established</code>，建立了服务端到客户端的连接；</p> </li></ul> 
</blockquote> 
<p><strong>四次挥手</strong>：</p> 
<blockquote> 
 <ul><li>第一次挥手：客户端发送<code>FIN</code>（结束报文段）到服务端，申请建立关闭客户端到服务端的连接；</li><li>第二次挥手：服务端接收到<code>FIN</code>，将状态置为<code>close_wait</code>，并返回一个<code>ACK</code>应答给客户端（<code>TCP</code>协议默认执行）</li><li>第三次挥手：服务端发送一个<code>FIN</code>到客户端，申请关闭服务端到客户端的连接，并执行关闭前的一些操作；</li><li>第四次挥手：客户端返回<code>ACK</code>到服务端，并将状态置为<code>close_wait</code>，需要等待一段时间（防止丢包重传<code>FIN</code>），客户端在将状态置为<code>closed</code>，等服务端接收到这个数据报时，将状态置为<code>closed</code>关闭连接；</li></ul> 
</blockquote> 
<p>不可以是<code>2</code>次，不可靠；<br> 可以是<code>4</code>次，但存在效率问题；</p> 
<p><strong><mark>7．Java常见容器有哪些？</mark></strong></p> 
<blockquote> 
 <p><code>list</code>：有序的集合，元素可以重复，可以进行索引访问以及动态扩容；<br> <code>map</code>：使用键值对存储元素，元素不允许重复，无序；<br> <code>set</code>：元素不能重复，无序；</p> 
</blockquote> 
<p><strong><mark>8．ArrayList 与LinkedList 区别？</mark></strong></p> 
<blockquote> 
 <p><code>ArrayList</code>：底层采用数组来存储元素，因此物理上连续，支持随机访问，支持扩容，但在任意位置插入删除元素，需要进行元素的搬移，因此，时间复杂度为O(N)；</p> 
 <p><code>LinkedList</code>：底层采用双向链表结构，因此逻辑上是连续的但物理上不一定连续；，不支持随机访问，并且没有扩容的概念；任意位置插入删除元素，只需要修改引用即可，因此时间复杂度为O(1)。</p> 
</blockquote> 
<p><strong><mark>9．栈、虚拟机栈、栈帧、操作数栈区别？</mark></strong></p> 
<blockquote> 
 <p><strong>栈</strong>：是一种后进先出的数据结构，在Java中对应的实现为<code>Stack</code>；</p> 
 <p><strong>虚拟机栈</strong>：是一块具有特殊作用的内存空间，生命周期与线程相同，<code>JVM</code>为了方便管理，将内存分为栈区与堆区；栈区，线程是私有的，主要存放函数调用的一些信息，主要有栈帧，堆区：一般new出来的空间都在堆区；</p> 
 <p><strong>栈帧</strong>：用于支持Java虚拟机进行方法调用和执行的数据结构，每个方法在执行时都会创建一个栈帧，用于保存局部变量表、操作数栈、动态链接以及方法出口等信息，当方法调用结束时，该方法对应的栈帧会从虚拟机栈中进行出栈；</p> 
 <p><strong>操作数栈</strong>：也被称作操作栈，是一个后进先出的栈，同局部变量表一样，在编译期间，操作数栈的最大最大深度就被确定下来了。</p> 
</blockquote> 
<p><strong><mark>10．HashMap 为什么要重写 HashCode 与 equals 方法？</mark></strong></p> 
<p><code>HashMap</code> 是泛型的，里面存放键值对，而它的哈希函数底层采用的是除留余数法，因此，当<code>key</code>不是整形时，就需要提供<code>HashCode</code>方法，将<code>key</code>转为整形；<br> 重写<code>equals</code>方法，是因为默认情况下继承基类中的<code>equals</code>方法，但基类中<code>equals</code>方法是比较对象的地址，当要比较对象的值时就需要重写<code>equals</code>方法。</p> 
<p><strong><mark>11．</mark> 与equals 区别？==</strong></p> 
<blockquote> 
 <p><code>==</code> ：比较地址是否相等 <code>equals</code>：比较内容是否相等</p> 
</blockquote> 
<p><strong><mark>12．IO流的分类？</mark></strong></p> 
<blockquote> 
 <p>按照流向：输入流 输出流<br> 按照操作单元：字节流 字符流<br> 按照流的角色：结点流 处理流</p> 
</blockquote> 
<p><strong><mark>13．事务的四大特性？</mark></strong></p> 
<ul><li>原子性； 持久性； 一致性； 隔离性</li></ul> 
<p><strong><mark>14．http 协议中，请求方法有哪些？</mark></strong></p> 
<blockquote> 
 <p>请求方法：<code>get</code> <code>post</code></p> 
 <p><code>get</code> 与 <code>post</code>区别：</p> 
 <ul><li>语义上：<code>get</code> 是获取资源，<code>post</code>是提交资源；</li><li>数据存放位置：<code>get</code> 存放在<code>queryString</code>中，<code>post</code>存放在<code>body</code>中；</li><li>幂等性：<code>get</code>具有幂等性，<code>post</code>则没有；</li><li>缓存：<code>get</code> 可以，<code>post</code>不可以；</li></ul> 
</blockquote> 
<p><strong><mark>15．http 与 https 区别？</mark></strong></p> 
<blockquote> 
 <ul><li>安全性：<code>https</code> 是加密后的密文传输，安全，而<code>http</code>明文传输，不安全；</li><li>默认端口：<code>http</code>默认端口<code>80</code>，<code>https</code>默认端口<code>443</code>；</li></ul> 
 <p><code>https</code>是基于<code>http</code>之上，使用<code>TSL/SSL</code>协议进行加密的。</p> 
</blockquote> 
<p><strong><mark>16．Cookie 是什么？</mark></strong></p> 
<blockquote> 
 <p><code>cookie</code>是客户端保存数据的一种技术，由于<code>web</code>程序是使用<code>http</code>协议进行传输的，而<code>http</code>协议是无状态的协议，对于事务没有记忆能力，因此当后续处理需要处理前面的信息时，就需要重新上传，导致数据量增大；因此使用<code>cookie</code>可以解决这一问题。</p> 
</blockquote> 
<p><strong><mark>17．设计模式六大原则？</mark></strong></p> 
<blockquote> 
 <ul><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特法制</li></ul> 
</blockquote> 
<p><strong><mark>18．两个对象的hashcode相同，则equals也一定为true吗？</mark></strong></p> 
<blockquote> 
 <p>两个对象的<code>equals</code>返回<code>true</code>，那么<code>hashcode</code>也一定相等；<br> 两个对象的<code>hashcode</code>相同，<code>equals</code>不一定为<code>true</code>；</p> 
</blockquote> 
<p><strong><mark>19．数组中有没有length()方法，String有没有length()方法？</mark></strong></p> 
<blockquote> 
 <p>数组中是没有<code>length()</code>这个方法的，但有<code>length()</code>这个属性，用来计算数组的长度；<br> <code>String</code>中有<code>length()</code>这个方法，用来计算字符串长度；</p> 
</blockquote> 
<p><strong><mark>20．如何解决哈希冲突？</mark></strong></p> 
<p><strong>哈希冲突</strong>：多个不同元素经过相同的哈希函数，从而产生相同的哈希地址，称为哈希冲突；</p> 
<p><strong>解决方式</strong>：</p> 
<ul><li>先检查哈希函数是否设置合理，设计原则有：</li></ul> 
<p>（1）哈希函数定义必须包括要存储元素的全部关键码；<br> （2）哈希函数计算出来的哈希地址能够均匀分布整个空间；<br> （3）哈希函数设计尽可能简单；</p> 
<ul><li>方式一：闭散列：也叫开放定址法，指发生哈希冲突时，当哈希表中元素没有满的情况下，那么就可以将关键字<code>key</code>按照某种方式存放到发生冲突位置的下一个空位置中去；</li></ul> 
<p>找空位置的方式：</p> 
<blockquote> 
 <ul><li>线性探测：从发生冲突的位置开始，依次向后探测，直到找到下一个空位置为止；</li><li>二次探测：原理同线性探测，只是中间间隔元素；</li></ul> 
</blockquote> 
<ul><li>方式二：开散列，也叫链地址法，对关键码集合使用哈希函数计算散列地址，将具有相同地址的关键码归于同一个子集合中，每一个子集合称为一个桶，各个桶中的元素通过一个单链表连接，各链表的头结点存储在哈希表中。</li></ul> 
<p><strong><mark>21．常见Linux命令？</mark></strong></p> 
<blockquote> 
 <p><code>mkdir</code>:创建目录，<code>mkdir t</code> :创建一个名为t的目录，当t存在时，会报错；<br> <code>yum</code>: 安装（yum install软件名称）更新（yum update 软件名）卸载指令（yum remove 软件名）</p> 
 <p><code>vim</code>:文本编辑命令；使用i进入插入模式，再插入模式下不能保存，需要先回到普通模式，按下esc即可返回到普通模式；保存：冒号w；</p> 
 <p><code>ls</code>：显示目录与文件，ls-a：列出目录下所有文件；ls-l:列出文件的详细信息；ls-k：以K字节的形式表示文件的大小；</p> 
 <p><code>cd</code>：切换到某个目录；cd ~:切换到用户目录；cd /：切换到根目录；cd -:返回最近访问目录；cd …：返回上级目录；</p> 
 <p><code>less</code>：查看文件内容；less -N 文件名：显示文件每行的行号</p> 
 <p><code>ps</code> ：查看进程，ps -elf<br> -e：显示系统内的所有进程信息；<br> -l：使用长（long）格式显示进程信息；<br> -f：使用完整的（full）格式显示进程信息。</p> 
</blockquote> 
<p><strong><mark>22．HTTP协议及状态码？</mark></strong></p> 
<blockquote> 
 <p>http的全称为“超文本传输协议”，所谓超文本就是指它能够传输的内容有文本、图片、音频及视频等文件，是一种应用较广泛的 应用层协议，处于OSI七层模型（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）的第7层；（目前常用的是HTTP 1.1）；</p> 
</blockquote> 
<p><strong>常见状态码</strong>：<br> （1）200 表示访问成功<br> （2）404 表示请求的URL路径中没有对应的资源<br> （3）403 表示禁止访问，一般有可能出现的情况就是权限不够<br> （4）405 表示方法不支持<br> （5）500 服务器内部出错<br> （6）301 302 表示重定向（重定向会发送两次请求）</p> 
<p><strong><mark>23．TCP 与 UDP 区别？</mark></strong></p> 
<p><strong>（1）从特点来看：</strong></p> 
<blockquote> 
 <p>TCP是有连接的、可靠的、面向字节流、有发送缓冲区以及接收缓冲区且大小不限；<br> UDP是无连接的、不可靠的、面向数据报，只有接收缓冲区没有发送缓冲区且大小受限的；</p> 
</blockquote> 
<p><strong>（2）从使用场景来看：</strong></p> 
<blockquote> 
 <p>TCP协议适用高可靠性的业务场景中（文件传输）；同时TCP提供了可靠传输及提高效率的机制： <code>表现在</code>：<br> 可靠传输：校验和、序列号、确认应答、超时重传、连接管理、流量及拥塞控制）<br> 提高效率：滑动窗口、延时应答、捎带应答</p> 
 <p>UDP协议则适用于实时性要求高，但允许一等程度的丢包的（语音聊天）</p> 
</blockquote> 
<p><strong><mark>24．网络5层结构以及各层作用？</mark></strong></p> 
<blockquote> 
 <p>（1）物理层：通过媒介传输比特<br> （2）数据链路层：负责封装和解封装ip报文 （帧）<br> （3）网络层：负责数据报从源到宿的传递（报文）<br> （4）传输层：负责对报文进行分组与重组 （包）<br> （5）应用层：负责向用户提供应用程序</p> 
</blockquote> 
<p><strong><mark>25．数组与链表的区别？</mark></strong></p> 
<blockquote> 
 <p><strong>逻辑结构上</strong>：数组在内存中是连续的，链表在内存中不连续<br> <strong>访问效率上</strong>：数组在内存中顺序存储，可以通过下标进行访问，访问效率高，链表要想访问某个元素，需要从头进行遍历；<br> <strong>越界问题上</strong>：数组的大小是固定的，存在访问越界问题，链表无影响；<br> <strong>使用场景上</strong>：频繁访问操作就选择数组、删除或插入元素时，则选择链表；</p> 
</blockquote> 
<p><strong><mark>26．进城池？</mark></strong></p> 
<blockquote> 
 <p>在程序实际处理过程中，会有成千上万的任务需要执行，当成千上万的任务需要被执行时，我们就需要创建成千上万个进程嘛？显然是不可行的，首先由于创建进程需要耗费时间，销毁进程也需要耗费时间；第二，就算创建那么多的进程，操作系统也不可能让他们同时执行（效率太低），因此就需要进城池，定义一个池，里面存放固定数量的进程，有需求时，就拿一个池中的进程来处理任务，等处理完毕，进程并不关闭，而是将进程再放回到进城池中继续等待。</p> 
</blockquote> 
<p><strong><mark>27．二叉树了解嘛？</mark></strong></p> 
<blockquote> 
 <p>二叉树：是结点的有限集合，该集合可以为空（空树）；不为空：该二叉树由一个根节点和两颗被称为左右子树的二叉树组成；<br> 同时，任何一颗二叉树中不存在度大于2的结点，包含两种特殊的二叉树,完全二叉树（假设一个二叉树的高度为H，则它的前H-1层结点军达到饱和，H层结点从前往后依次排列）和满二叉树（每层结点树都达到最大值）</p> 
</blockquote> 
<p><strong><mark>28．链表了解嘛？</mark></strong></p> 
<blockquote> 
 <p>链表是一种物理存储结构上非连续的存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的；有8种不同的分类，分别为：带头链表、不带头链表、单向链表、双向链表、循环和非循环链表。</p> 
</blockquote> 
<p><strong><mark>29．接口测试怎么测？用什么工具？</mark></strong></p> 
<blockquote> 
 <p>首先，接口其实就是一个网址（URL），对其进行测试时，<br> （1）需要检查数据的正确性：不同的参数可能对应不同的结果；<br> （2）请求类型的判断，是get还是post请求；<br> （3）检验接口的兼容性：传入异常数据时，是否会发生崩溃<br> （4）参数是否有加密</p> 
 <p><strong><code>常见的接口测试工具</code></strong>：Postman、SoapUI、REST-Assured、JMeter、Apifox、Katalon<br> Studio、Karate</p> 
</blockquote> 
<p><strong><mark>30．进程与线程有什么区别？</mark></strong></p> 
<blockquote> 
 <p><strong>进程</strong>：是系统分配资源的最小单位（基本单位），占用独立的虚拟内存空间<br> <strong>线程</strong>：操作系统调度cpu执行的基本单位<br> <strong><code>联系</code></strong>：进程包含线程，一个进程至少包含一个线程，都有创建、就绪、运行、阻塞以及销毁状态；</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db00d4c2b43e89dd706f19bd6eadc79a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python报错UnicodeDecodeError: ‘gbk‘ codec can‘t decode byte</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c01bfb8162b588f0884f26cc2c37d75f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据工程师、数据挖掘师和数据分析师有啥区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>