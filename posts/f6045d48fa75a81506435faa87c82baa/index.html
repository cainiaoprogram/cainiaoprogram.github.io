<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis的设计与实现(6)-压缩列表 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis的设计与实现(6)-压缩列表" />
<meta property="og:description" content="压缩列表 (ziplist) 是列表键和哈希键的底层实现之一.
当一个列表键只包含少量列表项, 并且每个列表项要么就是小整数值, 要么就是长度比较短的字符串, 那么 Redis 就会使用压缩列表来做列表键的底层实现.当一个哈希键只包含少量键值对, 并且每个键值对的键和值要么就是小整数值, 要么就是长度比较短的字符串, 那么 Redis 就会使用压缩列表来做哈希键的底层实现. 1. 压缩列表的构成 压缩列表是 Redis 为了节约内存而开发的, 由一系列特殊编码的连续内存块组成的顺序型 (sequential) 数据结构.
一个压缩列表可以包含任意多个节点 (entry) , 每个节点可以保存一个字节数组或者一个整数值.
压缩列表的整体布局:
| zlbytes | zltail | zllen | entry | entry | entry... | zlend |
字段名称类型占用空间备注zlbytesuint32_t4 字节记录整个压缩列表占用的内存字节数: 在对压缩列表进行内存重分配, 或者计算 zlend 的位置时使用.zltailuint32_t4 字节记录压缩列表表尾节点距离压缩列表的起始地址有多少字节: 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址.zllenuint16_t2 字节记录了压缩列表包含的节点数量: 当这个属性的值小于 UINT16_MAX (65535)时, 这个属性的值就是压缩列表包含节点的数量; 当这个值等于 UINT16_MAX 时, 节点的真实数量需要遍历整个压 缩列表才能计算得出.entryX列表节点不定压缩列表包含的各个节点，节点的长度由节点保存的内容决定.zlenduint8_t1 字节特殊值 0xFF (十进制 255 )，用于标记压缩列表的末端. 2 压缩列表节点的构成 每个压缩列表节点可以保存一个字节数组或者一个整数值, 其中, 字节数组可以是以下三种长度的其中一种:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f6045d48fa75a81506435faa87c82baa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-27T23:45:40+08:00" />
<meta property="article:modified_time" content="2023-06-27T23:45:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis的设计与实现(6)-压缩列表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>压缩列表 (ziplist) 是列表键和哈希键的底层实现之一.</p> 
<ol><li>当一个列表键只包含少量列表项, 并且每个列表项要么就是小整数值, 要么就是长度比较短的字符串, 那么 Redis 就会使用压缩列表来做列表键的底层实现.</li><li>当一个哈希键只包含少量键值对, 并且每个键值对的键和值要么就是小整数值, 要么就是长度比较短的字符串, 那么 Redis 就会使用压缩列表来做哈希键的底层实现.</li></ol> 
<h3><a id="1__5"></a>1. 压缩列表的构成</h3> 
<p>压缩列表是 Redis 为了节约内存而开发的, 由一系列特殊编码的连续内存块组成的顺序型 (sequential) 数据结构.<br> 一个压缩列表可以包含任意多个节点 (entry) , 每个节点可以保存一个字节数组或者一个整数值.</p> 
 
<p>压缩列表的整体布局:</p> 
<p><code>| zlbytes | zltail | zllen | entry | entry | entry... | zlend |</code></p> 
<table><thead><tr><th>字段名称</th><th>类型</th><th>占用空间</th><th>备注</th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4 字节</td><td>记录整个压缩列表占用的内存字节数: 在对压缩列表进行内存重分配, 或者计算 zlend 的位置时使用.</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节: 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址.</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2 字节</td><td>记录了压缩列表包含的节点数量: 当这个属性的值小于 UINT16_MAX (65535)时, 这个属性的值就是压缩列表包含节点的数量; 当这个值等于 UINT16_MAX 时, 节点的真实数量需要遍历整个压 缩列表才能计算得出.</td></tr><tr><td>entryX</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定.</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1 字节</td><td>特殊值 0xFF (十进制 255 )，用于标记压缩列表的末端.</td></tr></tbody></table> 
<h3><a id="2__24"></a>2 压缩列表节点的构成</h3> 
<p>每个压缩列表节点可以保存一个字节数组或者一个整数值, 其中, 字节数组可以是以下三种长度的其中一种:</p> 
<ul><li>长度小于等于 63 (2^{6}-1)字节的字节数组;</li><li>长度小于等于 16383 (2^{14}-1) 字节的字节数组;</li><li>长度小于等于 4294967295 (2^{32}-1)字节的字节数组;</li></ul> 
<p>而整数值则可以是以下六种长度的其中一种:</p> 
<ul><li>4 位长，介于 0 至 12 之间的无符号整数;</li><li>1 字节长的有符号整数;</li><li>3 字节长的有符号整数;</li><li>int16_t 类型整数;</li><li>int32_t 类型整数;</li><li>int64_t 类型整数.</li></ul> 
<p>压缩列表节点的构成:</p> 
<p><code>| previous_entry_length | encoding | content |</code></p> 
<h5><a id="21_previous_entry_length_45"></a>2.1 previous_entry_length</h5> 
<p>节点的 previous_entry_length 属性以字节为单位, 记录了压缩列表中前一个节点的长度.</p> 
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节:</p> 
<ul><li>如果前一节点的长度小于 254 字节, 那么 previous_entry_length 属性的长度为 1 字节: 前一节点的长度就保存在这一个字节里面.</li><li>如果前一节点的长度大于等于 254 字节, 那么 previous_entry_length 属性的长度为 5 字节: 其中属性的第一字节会被设置为 0xFE (十进制值 254), 而之后的四个字节则用于保存前一节点的长度.</li></ul> 
<p>因为节点的 previous_entry_length 属性记录了前一个节点的长度, 所以程序可以通过指针运算, 根据当前节点的起始地址来计算出前一个节点的起始地址.</p> 
<p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的: 只要我们拥有了一个指向某个节点起始地址的指针, 那么通过这个指针以及这个节点的 previous_entry_length 属性, 程序就可以一直向前一个节点回<br> 溯, 最终到达压缩列表的表头节点.</p> 
<h5><a id="22_encoding_59"></a>2.2 encoding</h5> 
<p>节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度:</p> 
<ul><li>一字节, 两字节或者五字节长, 值的最高位为 00 , 01 或者 10 的是字节数组编码: 这种编码表示节点的 content 属性保存着字节数组, 数组的长度由编码除去最高两位之后的其他位记录;</li><li>一字节长, 值的最高位以 11 开头的是整数编码: 这种编码表示节点的 content 属性保存着整数值, 整数值的类型和长度由编码除去最高两位之后的其他位记录;</li></ul> 
<table><thead><tr><th>编码</th><th>编码长度</th><th>content 属性保存的值</th></tr></thead><tbody><tr><td>00bbbbbb</td><td>1 字节</td><td>长度小于等于 63 字节的字节数组.</td></tr><tr><td>01bbbbbb xxxxxxxx</td><td>2 字节</td><td>长度小于等于 16383 字节的字节数组.</td></tr><tr><td>10______ aaaaaaaa bbbbbbbb cccccccc dddddddd</td><td>5 字节</td><td>长度小于等于 4294967295 的字节数组.</td></tr></tbody></table> 
<br> 
<table><thead><tr><th>编码</th><th>编码长度</th><th>content 属性保存的值</th></tr></thead><tbody><tr><td>11000000</td><td>1 字节</td><td>int16_t 类型的整数.</td></tr><tr><td>11010000</td><td>1 字节</td><td>int32_t 类型的整数.</td></tr><tr><td>11100000</td><td>1 字节</td><td>int64_t 类型的整数.</td></tr><tr><td>11110000</td><td>1 字节</td><td>24 位有符号整数.</td></tr><tr><td>11111110</td><td>1 字节</td><td>8 位有符号整数.</td></tr><tr><td>1111xxxx</td><td>1 字节</td><td>使用这一编码的节点没有相应的 content 属性, 因为编码本身的 xxxx 四个位已经保存了一个介于 0 和 12 之间的值, 所以它无须 content 属性.</td></tr></tbody></table> 
<h5><a id="23_content_84"></a>2.3 content</h5> 
<p>节点的 content 属性负责保存节点的值, 节点值可以是一个字节数组或者整数, 值的类型和长度由节点的 encoding 属性决定.</p> 
<h3><a id="3__88"></a>3. 连锁更新</h3> 
<p>前面说过, 每个节点的 previous_entry_length 属性都记录了前一个节点的长度:</p> 
<ul><li>如果前一节点的长度小于 254 字节, 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值.</li><li>如果前一节点的长度大于等于 254 字节, 那么 previous_entry_length 属性需要用 5 字节长的空间来保存这个长度值.</li></ul> 
<p>如果 原有的节点都小于 254 字节, 突然间插入一个大于等于 254 字节, 压缩列表将会发生空间重分配(连锁更新);<br> 删除节点, 也会发生导致连锁更新.</p> 
<p>因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作, 而每次空间重分配的最坏复杂度为 O(N) , 所以连锁更新的最坏复杂度为 O(N^2).</p> 
<p>要注意的是, 尽管连锁更新的复杂度较高, 但它真正造成性能问题的几率是很低的:</p> 
<ul><li>首先, 压缩列表里要恰好有多个连续的, 长度介于 250 字节至 253 字节之间的节点, 连锁更新才有可能被引发, 在实际中, 这种情况并不多见;</li><li>其次, 即使出现连锁更新, 但只要被更新的节点数量不多, 就不会对性能造成任何影响: 比如说, 对三五个节点进行连锁更新是绝对不会影响性能的;</li></ul> 
<p>因为以上原因, ziplistPush 等命令的平均复杂度仅为 O(N) , 在实际中, 我们可以放心地使用这些函数, 而不必担心连锁更新会影响压缩列表的性能.</p> 
<h3><a id="4__API_108"></a>4. 压缩列表 API</h3> 
<table><thead><tr><th>函数</th><th>作用</th><th>算法复杂度</th></tr></thead><tbody><tr><td>ziplistNew</td><td>创建一个新的压缩列表。</td><td>O(1)</td></tr><tr><td>ziplistPush</td><td>创建一个包含给定值的新节点， 并将这个新节点添加到压缩列表的表头或者表尾。</td><td>平均 O(N) ，最坏 O(N^2) 。</td></tr><tr><td>ziplistInsert</td><td>将包含给定值的新节点插入到给定节点之后。</td><td>平均 O(N) ，最坏 O(N^2) 。</td></tr><tr><td>ziplistIndex</td><td>返回压缩列表给定索引上的节点。</td><td>O(N)</td></tr><tr><td>ziplistFind</td><td>在压缩列表中查找并返回包含了给定值的节点。</td><td>因为节点的值可能是一个字节数组， 所以检查节点值和给定值是否相同的复杂度为 O(N) ， 而查找整个列表的复杂度则为 O(N^2) 。</td></tr><tr><td>ziplistNext</td><td>返回给定节点的下一个节点。</td><td>O(1)</td></tr><tr><td>ziplistPrev</td><td>返回给定节点的前一个节点。</td><td>O(1)</td></tr><tr><td>ziplistGet</td><td>获取给定节点所保存的值。</td><td>O(1)</td></tr><tr><td>ziplistDelete</td><td>从压缩列表中删除给定的节点。</td><td>平均 O(N) ，最坏 O(N^2) 。</td></tr><tr><td>ziplistDeleteRange</td><td>删除压缩列表在给定索引上的连续多个节点。</td><td>平均 O(N) ，最坏 O(N^2) 。</td></tr><tr><td>ziplistBlobLen</td><td>返回压缩列表目前占用的内存字节数。</td><td>O(1)</td></tr><tr><td>ziplistLen</td><td>返回压缩列表目前包含的节点数量。</td><td>节点数量小于 65535 时 O(1) ， 大于 65535 时 O(N) 。</td></tr></tbody></table> 
<p>因为 ziplistPush, ziplistInsert, ziplistDelete 和 ziplistDeleteRange 四个函数都有可能会引发连锁更新, 所以它们的最坏复杂度都是 O(N^2).</p> 
<h3><a id="5__128"></a>5. 总结</h3> 
<ul><li>压缩列表是一种为节约内存而开发的顺序型数据结构.</li><li>压缩列表被用作列表键和哈希键的底层实现之一.</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值.</li><li>添加新节点到压缩列表, 或者从压缩列表中删除节点, 可能会引发连锁更新操作, 但这种操作出现的几率并不高.</li></ul> 
<hr> 
<blockquote> 
 <p>文章来源于本人博客，发布于 2018-06-02，原文链接：https://imlht.com/archives/141/</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/80a2a2d25c0130ff032dbfec2dfe9424/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">黑客与逆向工程入门指南：你知道你的网络足够安全吗？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91782fadde8aa7f568ae4f54bb614b69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于java的学籍管理系统毕业设计(源代码&#43;数据库&#43;部署文档&#43;部署视频)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>