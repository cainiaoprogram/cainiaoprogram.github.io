<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>prometheus命令_Prometheus配置 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="prometheus命令_Prometheus配置" />
<meta property="og:description" content="配置
Prometheus可以通过命令行参数和配置文件来配置它的服务参数。命令行主要用于配置系统参数(例如：存储的位置，保留在磁盘和内存中的数据量的大小等)，配置文件主要用于配置与抓取任务和任务下的实例相关的所有内容, 并且加载指定的抓取规则file。
可以通过运行prometheus -h命令, 查看Prometheus所有可用的命令行参数，
Prometheus服务可以reload它的配置。如果这个配置错误，则更改后的配置不生效。配置reolad是通过给Prometheus服务发送信号量SIGHUP或者通过http发送一个post请求到/-/reload。这也会重载所有配置的规则文件(rule files)。
配置文件(Configuration file)
使用-config.file命令行参数来指定Prometheus启动所需要的配置文件。
这个配置文件是YAML格式， 通过下面描述的范式定义, 括号表示参数是可选的。对于非列表参数，这个值被设置了默认值。
通用占位符由下面定义：
: 一个布尔值，包括true或者false.
: 持续时间，与正则表达式[0-9]&#43;(ms|smhdwy)匹配
: 一个与正则表达式[a-zA-Z_][a-zA-Z0-9_]*匹配的字符串
: 一个为unicode字符串
: 当前工作目录下的有效路径
: 一个包含主机名或者IP地址，并且可以带上一个非必需的端口号的有效字符串
: 一个有效的URL路径
: 一个可以是http或者https的字符串
: 一个正则表达式字符串
其他的占位符被分开指定：
一个有效的配置文件示例。
全局配置指定的参数，在其他上下文配置中是生效的。这也默认这些全局参数在其他配置区域有效。
global:
# 抓取目标实例的频率时间值，默认1分钟
[ scrape_interval: | default = 1m ]
# 一次抓取请求超时时间值，默认10s
[ scrape_timeout: | default = 10s ]
# 执行配置文件规则的频率时间值, 默认1m
[ evaluation_interval: | default = 1m ]
# 当和外部系统通信时(federation, remote storage, Alertmanager), 这些标签会增加到度量指标数据中" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fdd748080e3a04c10868c30f2f0e7c12/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-21T22:14:25+08:00" />
<meta property="article:modified_time" content="2020-12-21T22:14:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">prometheus命令_Prometheus配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>配置</p> 
 <p>Prometheus可以通过命令行参数和配置文件来配置它的服务参数。命令行主要用于配置系统参数(例如：存储的位置，保留在磁盘和内存中的数据量的大小等)，配置文件主要用于配置与抓取任务和任务下的实例相关的所有内容, 并且加载指定的抓取规则file。</p> 
 <p>可以通过运行prometheus -h命令, 查看Prometheus所有可用的命令行参数，</p> 
 <p>Prometheus服务可以reload它的配置。如果这个配置错误，则更改后的配置不生效。配置reolad是通过给Prometheus服务发送信号量SIGHUP或者通过http发送一个post请求到/-/reload。这也会重载所有配置的规则文件(rule files)。</p> 
 <p>配置文件(Configuration file)</p> 
 <p>使用-config.file命令行参数来指定Prometheus启动所需要的配置文件。</p> 
 <p>这个配置文件是YAML格式， 通过下面描述的范式定义, 括号表示参数是可选的。对于非列表参数，这个值被设置了默认值。</p> 
 <p>通用占位符由下面定义：</p> 
 <p>: 一个布尔值，包括true或者false.</p> 
 <p>: 持续时间，与正则表达式[0-9]+(ms|smhdwy)匹配</p> 
 <p>: 一个与正则表达式[a-zA-Z_][a-zA-Z0-9_]*匹配的字符串</p> 
 <p>: 一个为unicode字符串</p> 
 <p>: 当前工作目录下的有效路径</p> 
 <p>: 一个包含主机名或者IP地址，并且可以带上一个非必需的端口号的有效字符串</p> 
 <p>: 一个有效的URL路径</p> 
 <p>: 一个可以是http或者https的字符串</p> 
 <p>: 一个正则表达式字符串</p> 
 <p>其他的占位符被分开指定：</p> 
 <p>一个有效的配置文件示例。</p> 
 <p>全局配置指定的参数，在其他上下文配置中是生效的。这也默认这些全局参数在其他配置区域有效。</p> 
 <p>global:</p> 
 <p># 抓取目标实例的频率时间值，默认1分钟</p> 
 <p>[ scrape_interval: | default = 1m ]</p> 
 <p># 一次抓取请求超时时间值，默认10s</p> 
 <p>[ scrape_timeout: | default = 10s ]</p> 
 <p># 执行配置文件规则的频率时间值, 默认1m</p> 
 <p>[ evaluation_interval: | default = 1m ]</p> 
 <p># 当和外部系统通信时(federation, remote storage, Alertmanager), 这些标签会增加到度量指标数据中</p> 
 <p>external_labels:</p> 
 <p>[ : ... ]</p> 
 <p># 规则文件指定规则文件路径列表。规则和警报是从所有匹配的文件中读取的</p> 
 <p>rule_files:</p> 
 <p>[ - ... ]</p> 
 <p># 抓取配置的列表</p> 
 <p>scrape_configs:</p> 
 <p>[ - ... ]</p> 
 <p># Alerting指定与Alertmanager相关的设置。</p> 
 <p>alerting:</p> 
 <p>alert_relabel_configs:</p> 
 <p>[ - ... ]</p> 
 <p>alertmanagers:</p> 
 <p>[ - ... ]</p> 
 <p># 与远程写入功能相关的设置。</p> 
 <p>remote_write:</p> 
 <p>[ - ... ]</p> 
 <p># 与远程读取功能相关的设置。</p> 
 <p>remote_read:</p> 
 <p>[ - ... ]</p> 
 <p>scrape_config 区域指定了一组目标和描述如何抓取(scrape)目标的参数。通常，一个抓取配置只能指定了一个job。在高级配置中，这可能会改变。</p> 
 <p>通过static_configs参数静态指定要监控的目标列表，或者使用一些服务发现机制动态的发现目标。</p> 
 <p>另外，relabel_configs允许在获取度量指标数据之前，对任何目标和它的标签进行进一步地修改。</p> 
 <p># 默认下任务名称赋值给要抓取的度量指标</p> 
 <p>job_name: </p> 
 <p># 从这个任务中抓取目标的频率时间值</p> 
 <p>[ scrape_interval: | default= ]</p> 
 <p># 当抓取这个任务的所有目标时，超时时间值</p> 
 <p>[ scrape_timeout: | default = ]</p> 
 <p># 从目标列表中抓取度量指标的http资源路径, 默认为/metrics</p> 
 <p>[ metrics_path: | default = /metrics ]</p> 
 <p># honor_labels controls how Prometheus handles conflicts between would labels that are already present in scraped data and labels that Prometheus would attach server-side ("job" and "instance" labels, manually configured target labels, and labels generated by service discovery implementations).</p> 
 <p># If honor_labels is set to "true", label conflicts are resolved by keeping label</p> 
 <p># values from the scraped data and ignoring the conflicting server-side labe# ls. If honor_labels is set to "false", label conflicts are resolved by ren# amin conflicting labels in the scraped data to "exported_" (for example "exported_instance", "exported_job") and then attaching server-side labels. This is useful for use cases such as federation, where all label#s specified in the target should be preserved. Note that any globally configured "external_labels" are unaffected by this</p> 
 <p># setting. In communication with external systems, they are always applied</p> 
 <p># only when a time series does not have a given label yet and are ignored otherwise.</p> 
 <p>[ honor_labels: | default = false ]</p> 
 <p># 配置请求的协议范式, 默认为http请求</p> 
 <p>[ scheme: | default = http ]</p> 
 <p># 可选的http url参数</p> 
 <p>params:</p> 
 <p>[ :[, ...]]</p> 
 <p># 在`Authorization`头部设置每次抓取请求的用户名和密码</p> 
 <p>basic_auth:</p> 
 <p>[username: ]</p> 
 <p>[password: ]</p> 
 <p># Sets the `Authorization` header on every scrape request with</p> 
 <p># the configured bearer token. It is mutually exclusive with `bearer_token_file`.</p> 
 <p>[ bearer_token: ]</p> 
 <p># Sets the `Authorization` header on every scrape request with the bearer token read from the configured file. It is mutually exclusive with `bearer_token`.</p> 
 <p>[ bearer_token_file: /path/to/bearer/token/file ]</p> 
 <p># 配置抓取请求的TLS设置</p> 
 <p>tls_config:</p> 
 <p>[ ]</p> 
 <p># 可选的代理URL</p> 
 <p>[ proxy_url: ]</p> 
 <p># 微软的Azure服务发现配置列表</p> 
 <p>azure_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># Consul服务发现配置列表</p> 
 <p>consul_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># DNS服务发现配置列表</p> 
 <p>dns_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># 亚马逊EC2服务发现的配置列表</p> 
 <p>ec2_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># 文件服务发现配置列表</p> 
 <p>file_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># google GCE服务发现配置列表</p> 
 <p>gce_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># Kubernetes服务发现配置列表</p> 
 <p>kubernetes_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># Marathon服务发现配置列表</p> 
 <p>marathon_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># AirBnB的Nerve服务发现配置列表</p> 
 <p>nerve_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># Zookeeper服务发现配置列表</p> 
 <p>serverset_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># Triton服务发现配置列表</p> 
 <p>triton_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># 静态配置目标列表</p> 
 <p>static_configs:</p> 
 <p>[ - ... ]</p> 
 <p># 抓取之前的标签重构配置列表</p> 
 <p>relabel_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of metric relabel configurations.</p> 
 <p>metric_relabel_configs:</p> 
 <p>[ - ... ]</p> 
 <p># Per-scrape limit on number of scraped samples that will be accepted.</p> 
 <p># If more than this number of samples are present after metric relabelling</p> 
 <p># the entire scrape will be treated as failed. 0 means no limit.</p> 
 <p>[ sample_limit: | default = 0 ]</p> 
 <p># Per-scrape config limit on number of unique targets that will be</p> 
 <p># accepted. If more than this number of targets are present after target</p> 
 <p># relabeling, Prometheus will mark the targets as failed without scraping them.</p> 
 <p># 0 means no limit. This is an experimental feature, this behaviour could</p> 
 <p># change in the future.</p> 
 <p>[ target_limit: | default = 0 ]</p> 
 <p>记住：在所有获取配置中必须是唯一的。</p> 
 <p>允许配置TLS连接。</p> 
 <p># CA证书</p> 
 <p>[ ca_file: ]</p> 
 <p># 证书和key文件</p> 
 <p>[ cert_file: ]</p> 
 <p>[ key_file: ]</p> 
 <p># ServerName extension to indicate the name of the server.</p> 
 <p># http://tools.ietf.org/html/rfc4366#section-3.1</p> 
 <p>[ server_name: ]</p> 
 <p># Disable validation of the server certificate.</p> 
 <p>[ insecure_skip_verify: ]</p> 
 <p>sd_config配置</p> 
 <p>一个static_config允许指定目标列表，以及附带的通用标签。在获取配置中指定静态目标是规范的方法</p> 
 <p># The targets specified by the static config.</p> 
 <p>targets:</p> 
 <p>[ - '' ]</p> 
 <p># Labels assigned to all metrics scraped from the targets.</p> 
 <p>labels:</p> 
 <p>[ : ... ]</p> 
 <p>Relabeling是一个非常强大的工具，在获取度量指标之前，它可以动态地重写标签集合。 每个获取配置过程中，多个relabeling步骤能够被配置。它们按照出现在配置文件中的顺序，应用到每个目标的标签集中。</p> 
 <p>最初，除了配置的每个目标标签之外，目标的job标签设置为相应获取配置的job_name值，这个__address__标签设置为目标地址:。在relabeling之后，这个instance标签默认设置为__address__标签值。这个__scheme__和__metrics_path__标签设置为各自目标的范式和度量指标路径。 __param_标签设置为成为的第一个传入的URL参数。</p> 
 <p>另外以__meta__为前缀的标签在relabeling阶段是可用的。他们由服务发现机制设置。</p> 
 <p>在relabeling完成之后，由__开头的标签将会从标签集合从移除。</p> 
 <p>如果一个relabeling步骤仅仅需要临时地存储标签值(作为后续relabeling步骤的输入)，使用以__tmp为前缀的标签名称。这个前缀需要确保Prometheus本身从没有使用。</p> 
 <p># 源标签从现有标签中选择值。 它们的内容使用配置的分隔符连接起来，并与配置的正则表达式匹配，以进行替换，保持和`drop`动作。</p> 
 <p>[ source_labels: '[' [, ...] ']' ]</p> 
 <p># 在连接的source label值之间放置分隔符。</p> 
 <p>[ separator: | default = ; ]</p> 
 <p># 在替换操作中将结果值写入的标签。</p> 
 <p># 替换操作是必需的。 正则表达式捕获组可用。</p> 
 <p>[ target_label: ]</p> 
 <p># 与提取的值匹配的正则表达式。</p> 
 <p>[ regex: | default = (.*) ]</p> 
 <p># Modulus to take of the hash of the source label values.</p> 
 <p>[ modulus: ]</p> 
 <p># 如果正则表达式匹配，则执行正则表达式替换的替换值。 正则表达式捕获组可用。</p> 
 <p>[ replacement: | default = $1 ]</p> 
 <p># 基于正则表达式匹配执行的操作。</p> 
 <p>[ action: | default = replace ]</p> 
 <p>是任何有效的正则表达式，它提供replace, keep, drop, labelmap, labeldrop, labelkeep动作，正则表达式处于两端。要取消指定正则表达式，请使用 .*.*。</p> 
 <p>决定要采取的relabeling动作。</p> 
 <p>replace: 匹配与source_labels相反的regex。然后，设置target_label替换source_labels, 返回结果包括(${1}, ${2}, ...)。 如果正则表达会不匹配，则不进行任何替换。</p> 
 <p>keep: 放弃与source_labels标签不匹配的目标</p> 
 <p>drop: 放弃与source_labels标签匹配的目标</p> 
 <p>hashmod: 将target_label设置为source_labels的散列模数</p> 
 <p>labelmap: 匹配所有的标签名称，然后将匹配到的标签值复制为由匹配组引用(${1}, ${2},...) 替换的标签名称替换为其值</p> 
 <p>labeldrop: 匹配所有的标签名称。然后删除匹配到的标签集合。</p> 
 <p>labelkeep: 匹配所有的标签名称。然后保留匹配到的标签集合。</p> 
 <p>必须注意labeldrop和labelkeep, 以确保除去标签后，度量指标仍然会被唯一标识。</p> 
 <p>在警告被发送到Alertmanager之前，警告relabeling应用到alerts。它有相同配置格式和目标relabeling动作。警告relabeling被应用到外部标签。</p> 
 <p>一个用途是确保HA对Prometheus服务与不同的外部标签发送相同的警告。</p> 
 <p>Alertmanager实例的动态发现是处于alpha状态。在将来的版本中配置会发生较大地更改。通过-alertmanager.url标志使用静态配置</p> 
 <p>alertmanager_config区域指定了Prometheus服务发送警告的Alertmanager实例。它也提供参数配置与这些Alertmanagers的通信。</p> 
 <p>Alertmanagers可以通过static_configs参数静态配置，或者使用服务发现机制动态发现目标。</p> 
 <p>另外，从发现的实体和使用的API路径，relabel_configs允许从发现的实体列表和提供可使用的API路径中选择路径。这个api path是通过__alerts_path__标签暴露出来的。</p> 
 <p># Per-target Alertmanager timeout when pushing alerts.</p> 
 <p>[ timeout: | default = 10s ]</p> 
 <p># Prefix for the HTTP path alerts are pushed to.</p> 
 <p>[ path_prefix: | default = / ]</p> 
 <p># Configures the protocol scheme used for requests.</p> 
 <p>[ scheme: | default = http ]</p> 
 <p># Sets the `Authorization` header on every request with the</p> 
 <p># configured username and password.</p> 
 <p>basic_auth:</p> 
 <p>[ username: ]</p> 
 <p>[ password: ]</p> 
 <p># Sets the `Authorization` header on every request with</p> 
 <p># the configured bearer token. It is mutually exclusive with `bearer_token_file`.</p> 
 <p>[ bearer_token: ]</p> 
 <p># Sets the `Authorization` header on every request with the bearer token</p> 
 <p># read from the configured file. It is mutually exclusive with `bearer_token`.</p> 
 <p>[ bearer_token_file: /path/to/bearer/token/file ]</p> 
 <p># Configures the scrape request's TLS settings.</p> 
 <p>tls_config:</p> 
 <p>[ ]</p> 
 <p># Optional proxy URL.</p> 
 <p>[ proxy_url: ]</p> 
 <p># List of Azure service discovery configurations.</p> 
 <p>azure_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of Consul service discovery configurations.</p> 
 <p>consul_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of DNS service discovery configurations.</p> 
 <p>dns_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of EC2 service discovery configurations.</p> 
 <p>ec2_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of file service discovery configurations.</p> 
 <p>file_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of GCE service discovery configurations.</p> 
 <p>gce_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of Kubernetes service discovery configurations.</p> 
 <p>kubernetes_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of Marathon service discovery configurations.</p> 
 <p>marathon_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of AirBnB's Nerve service discovery configurations.</p> 
 <p>nerve_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of Zookeeper Serverset service discovery configurations.</p> 
 <p>serverset_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of Triton service discovery configurations.</p> 
 <p>triton_sd_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of labeled statically configured Alertmanagers.</p> 
 <p>static_configs:</p> 
 <p>[ - ... ]</p> 
 <p># List of Alertmanager relabel configurations.</p> 
 <p>relabel_configs:</p> 
 <p>[ - ... ]</p> 
 <p>远程写是实验性的：在将来的版本中配置可能会实质性地变化</p> 
 <p>url是发送样本的端点URL。remote_timeout指定发送请求到URL的超时时间。目前没有重试机制</p> 
 <p>basic_auth, tls_config和proxy_url和在scrape_config区域里有相同的含义。</p> 
 <p>write_relabel_configs是relabeling应用到样本数据的。写relabeling是应用到外部标签之后的。这可能有样本发送数量的限制。</p> 
 <p>这里有一个小Demo，告诉你怎样使用这个功能</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/67bb575160e29962dec1897335cf608c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大小写 数据库 达梦_达梦常用语句</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e1a4bbf89a17cac7c052c53a585517b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">blob大小限制 oracle_优化InnoDB表BLOB,TEXT列的存储效率</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>