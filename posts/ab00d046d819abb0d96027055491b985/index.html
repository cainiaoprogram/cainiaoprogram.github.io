<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux 磁盘管理、分区管理常用命令 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux 磁盘管理、分区管理常用命令" />
<meta property="og:description" content="文章目录 基础命令挂载新硬盘/分区添加内存交换分区swaplvm分区管理模式 基础命令 查看目录文件大小
du -sh /backup du -sh /backup/* du -sh * 查看磁盘挂载信息
df -lhT 查看某个目录挂载在哪个分区，以及分区的磁盘使用情况
df [目录] #例如：df /home 查看设备列表
fdisk -l 分区核心指令
fdisk /dev/sdb # 对磁盘/dev/sdb进行分区管理 a :设置可引导标记 b :修改bsd的磁盘标签 c :设置DOS操作系统兼容标记 d :删除一个分区 l :显示已知的分区类型，其中82为Linux swap分区，83为Linux分区 m :显示帮助信息 n :增加一个新的分区 o :创建一个新的空白的DOS分区表 p :显示磁盘当前的分区表 q :退出fdisk程序，不保存任何修改 s :创建一个新的空白的Sun磁盘标签 t :改变一个分区的系统号码（比如把Linux Swap分区改为Linux分区） u :改变显示记录单位 v :对磁盘分区表进行验证 w :保存修改结果并退出fdisk程序 x :特殊功能 查看磁盘UUID
blkid 查看已挂载的分区和未挂载的分区
lsblk 可以看到有哪些分区挂载，哪些分区没有挂载
或者，查看已挂载的分区情况" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ab00d046d819abb0d96027055491b985/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-27T20:50:10+08:00" />
<meta property="article:modified_time" content="2023-11-27T20:50:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux 磁盘管理、分区管理常用命令</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">基础命令</a></li><li><a href="#_93" rel="nofollow">挂载新硬盘/分区</a></li><li><a href="#swap_136" rel="nofollow">添加内存交换分区swap</a></li><li><a href="#lvm_161" rel="nofollow">lvm分区管理模式</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>基础命令</h3> 
<p>查看目录文件大小</p> 
<pre><code class="prism language-shell"><span class="token function">du</span> <span class="token parameter variable">-sh</span> /backup
<span class="token function">du</span> <span class="token parameter variable">-sh</span> /backup/*
<span class="token function">du</span> <span class="token parameter variable">-sh</span> *
</code></pre> 
<p>查看磁盘挂载信息</p> 
<pre><code class="prism language-shell"><span class="token function">df</span> <span class="token parameter variable">-lhT</span>
</code></pre> 
<p>查看某个目录挂载在哪个分区，以及分区的磁盘使用情况</p> 
<pre><code class="prism language-shell"><span class="token function">df</span> <span class="token punctuation">[</span>目录<span class="token punctuation">]</span>
<span class="token comment">#例如：df /home</span>
</code></pre> 
<p>查看设备列表</p> 
<pre><code class="prism language-shell"><span class="token function">fdisk</span> <span class="token parameter variable">-l</span>
</code></pre> 
<p>分区核心指令</p> 
<pre><code class="prism language-shell"><span class="token function">fdisk</span> /dev/sdb <span class="token comment"># 对磁盘/dev/sdb进行分区管理</span>

a :设置可引导标记
b :修改bsd的磁盘标签
c :设置DOS操作系统兼容标记
d :删除一个分区
l :显示已知的分区类型，其中82为Linux swap分区，83为Linux分区
m :显示帮助信息
n :增加一个新的分区
o :创建一个新的空白的DOS分区表
p :显示磁盘当前的分区表
q :退出fdisk程序，不保存任何修改
s :创建一个新的空白的Sun磁盘标签
t :改变一个分区的系统号码（比如把Linux Swap分区改为Linux分区）
u :改变显示记录单位
<span class="token function">v</span> :对磁盘分区表进行验证
w :保存修改结果并退出fdisk程序
x :特殊功能
</code></pre> 
<p>查看磁盘UUID</p> 
<pre><code class="prism language-shell">blkid
</code></pre> 
<p>查看已挂载的分区和未挂载的分区</p> 
<pre><code class="prism language-shell">lsblk
</code></pre> 
<p>可以看到有哪些分区挂载，哪些分区没有挂载<br> <img src="https://images2.imgbox.com/99/36/ZsWDrsy5_o.png" alt="在这里插入图片描述"><br> 或者，查看已挂载的分区情况</p> 
<pre><code class="prism language-shell">findmnt
</code></pre> 
<p>格式化分区/dev/sda 为 ext4</p> 
<pre><code class="prism language-shell"><span class="token comment">#格式化分区/dev/sda 为 ext4</span>
mkfs.ext4 /dev/sda

<span class="token comment">#格式化分区为xfs格式</span>
mkfs.xfs /dev/sdb1
</code></pre> 
<p>使内核重新读取分区表</p> 
<pre><code class="prism language-shell">partprobe <span class="token operator">&lt;</span>磁盘设备<span class="token operator">&gt;</span>
<span class="token comment">#例如 partprobe /dev/sda</span>
</code></pre> 
<p>挂载分区到目录</p> 
<pre><code class="prism language-shell"><span class="token function">mount</span> <span class="token operator">&lt;</span>分区<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>目录<span class="token operator">&gt;</span>
<span class="token comment">#例如：mount /dev/sda3 /data</span>

<span class="token comment">#使挂载永久生效</span>
<span class="token comment">#编辑fstab文件</span>
<span class="token function">vi</span> /etc/fstab:
<span class="token comment">#加入如下内容：</span>
/dev/sda3  /data  ext4  defaults <span class="token number">0</span> <span class="token number">0</span>

</code></pre> 
<p>取消挂载</p> 
<pre><code class="prism language-shell"><span class="token function">umount</span> <span class="token operator">&lt;</span>分区<span class="token operator">&gt;</span>
<span class="token function">umount</span> /dev/sdb1
</code></pre> 
<p>自动根据fstab重新挂载</p> 
<pre><code class="prism language-shell"><span class="token function">mount</span> <span class="token parameter variable">-a</span>
</code></pre> 
<h3><a id="_93"></a>挂载新硬盘/分区</h3> 
<p>参考：<a href="https://www.linuxprobe.com/basic-learning-06.html" rel="nofollow">https://www.linuxprobe.com/basic-learning-06.html</a><br> 说明：一个新硬盘接入系统，在系统以<code>/dev/sd[a-z]</code> 形式表示，硬盘可以分为多个分区，分区以<code>/dev/sd[a-z][1-9]表示</code>。对磁盘的分区可以全部分区，也可以部分分区，在分区时通过起始扇区来设定每个分区的大小和分区范围。<br> <strong>分区挂载使用步骤：</strong><br> 查看未使用的磁盘-&gt; 磁盘分区-&gt; 磁盘格式化-&gt;挂载-&gt;使重启生效-&gt;使用</p> 
<pre><code class="prism language-shell"><span class="token comment">#1. 查看指令</span>
lsblk
blkid
<span class="token function">fdisk</span> <span class="token parameter variable">-l</span>

<span class="token comment">#2. 创建分区</span>
<span class="token function">fdisk</span> /dev/sdb
:m <span class="token comment"># 查看指令帮助</span>
:p <span class="token comment"># 查看分区信息</span>
:l <span class="token comment"># 查看磁盘编码</span>
:n <span class="token comment"># 创建分区 </span>
:p创建主分区 
:（默认）设置分区序号，默认回车  
:（默认）设置扇区起始位置，默认回车
:+2G <span class="token comment">#设置结束扇区，默认回车设置磁盘剩下的所有大小。此处决定了要增加的分区大小，这里设置为2G</span>
:p <span class="token comment"># 再次查看分区信息，可见出现sdb1分区</span>
:w <span class="token comment"># 保存分区</span>
<span class="token comment"># 查看是否正常, 打印/dev/sdb1: block special表示正常</span>
<span class="token function">file</span> /dev/sdb1
<span class="token comment"># 若不正常，执行强制让内核重新找一次分区表（更新分区表）</span>
partprobe /dev/sdb

<span class="token comment">#3.格式化分区</span>
mkfs.xfs /dev/sdb1 <span class="token comment"># 提示：在输入mkdfs 按下Tab，会提示可选的分区格式，一般使用ext4、xfs</span>

<span class="token comment">#4.挂在到目录</span>
<span class="token function">mkdir</span> /backup <span class="token comment"># 创建一个目录用来挂载</span>
<span class="token function">mount</span> /dev/sdb1 /backup <span class="token comment"># 将分区sdb1挂载到backup目录</span>
<span class="token function">df</span> <span class="token parameter variable">-h</span> <span class="token comment">#查看挂载是否正确</span>

<span class="token comment">#5.保存挂载信息，使重启也生效，</span>
<span class="token function">vim</span> /etc/fstab <span class="token comment">#文件末尾添加如下，wq保存：</span>
/dev/sdb1 /backup xfs defaults <span class="token number">0</span> <span class="token number">0</span> 
</code></pre> 
<h3><a id="swap_136"></a>添加内存交换分区swap</h3> 
<pre><code class="prism language-shell"><span class="token comment"># 划分分区，并将分区标识码设为 82 （Linux swap）</span>
<span class="token function">fdisk</span> /dev/sdb
:n <span class="token comment">#新增分区</span>
	:p <span class="token comment">#创建主分区</span>
	:（默认） <span class="token comment">#设置起始扇区，默认回车</span>
	:+5G <span class="token comment">#设置结束扇区，默认回车设置磁盘剩下的所有大小。此处决定了要增加交换分区的大小，这里设置为5G</span>
:t <span class="token comment">#修改分区标识码</span>
	:（默认） <span class="token comment">#输入刚刚创建好的分区序号，必须与上面设置的分区号一致，默认回车</span>
	:82 <span class="token comment">#设置分区识别码为82（Linux swap），按需L可以查看所有分区识别码预览</span>
	:8e <span class="token comment"># 该模式适用于创建lvm分区结构</span>
:p <span class="token comment">#查看最终的分区状态，应该会看到类似输出 /dev/sdb2 xxx xxx xxx 5G 82 Linux swap / Solaris</span>
:w <span class="token comment">#写入，结束退出</span>

partprobe /dev/sdb <span class="token comment">#建议执行一次，用于重新查找分区表</span>
<span class="token function">mkswap</span> /dev/sdb2 <span class="token comment"># 格式化为交换分区格式</span>
<span class="token function">free</span> <span class="token parameter variable">-h</span> <span class="token comment">#先查看以下已有的交换分区大小</span>
<span class="token function">swapon</span> /dev/sdb2 <span class="token comment"># 激活并挂载</span>
<span class="token function">free</span> <span class="token parameter variable">-h</span> <span class="token comment">#可以看到，基于已有大小的增加了交换分区大小</span>
<span class="token function">vim</span> /etc/fstab <span class="token comment">#开机自动挂载。末尾添加如下内容：</span>
/dev/sdb2 swap swap defaults <span class="token number">0</span> <span class="token number">0</span>

</code></pre> 
<h3><a id="lvm_161"></a>lvm分区管理模式</h3> 
<p>参考</p> 
<blockquote> 
 <p><a href="https://www.linuxprobe.com/basic-learning-07.html" rel="nofollow">第7章 使用RAID与LVM磁盘阵列技术</a><br> <a href="https://blog.csdn.net/weixin_42915431/article/details/121881054?spm=1001.2014.3001.5506">Linux下的磁盘管理之LVM详解及lvm的常用磁盘操作命令</a></p> 
</blockquote> 
<p><strong>LVM的优缺点</strong></p> 
<p><strong>优点：</strong><br> 可以在系统运行的状态下动态的扩展文件系统的大小<br> 文件系统跨越多个磁盘，文件系统的大小不受磁盘大小的限制<br> LVM的存储空间可以通过新增磁盘的方式扩容</p> 
<p><strong>缺点：</strong><br> 从卷组中移除一个磁盘的时候必须使用reducevg命令<br> 当卷组中有一个磁盘损坏了，整个卷组都会受到影响（由于一份数据可能会存储在不同的磁盘中）<br> 在磁盘创建过程中增加了额外的步骤，所以数据存贮性能会受到影响</p> 
<p><strong>结构组成</strong><br> <img src="https://images2.imgbox.com/7c/dc/Lnamyx82_o.png" alt="在这里插入图片描述"><br> 表7-3 常用的LVM部署命令</p> 
<table><thead><tr><th>功能/命令</th><th>物理卷管理PV</th><th>卷组管理 VG</th><th>逻辑卷管理 LV</th></tr></thead><tbody><tr><td>扫描</td><td>pvscan</td><td>vgscan</td><td>lvscan</td></tr><tr><td>建立</td><td>pvcreate</td><td>vgcreate</td><td>lvcreate</td></tr><tr><td>显示</td><td>pvdisplay</td><td>vgdisplay</td><td>lvdisplay</td></tr><tr><td>删除</td><td>pvremove</td><td>vgremove</td><td>lvremove</td></tr><tr><td>扩展</td><td></td><td>vgextend</td><td>lvextend</td></tr><tr><td>缩小</td><td></td><td>vgreduce</td><td>lvreduce</td></tr></tbody></table> 
<pre><code class="prism language-shell">命令lvs、lvscan、lvdisplay查看已有逻辑卷
</code></pre> 
<ol><li>划分分区sdb1，并设置为lvm格式</li></ol> 
<pre><code class="prism language-shell"><span class="token function">fdisk</span> /dev/sdb
:n -<span class="token operator">&gt;</span> p -<span class="token operator">&gt;</span> 一路回车
:t -<span class="token operator">&gt;</span> 8e
:w
</code></pre> 
<p>创建lvm分区模式，操作示例：</p> 
<pre><code class="prism language-shell">
<span class="token comment">#1.让新添加的两块硬盘设备支持LVM技术。</span>
pvcreate /dev/sdb /dev/sdc <span class="token comment"># 或者指定分区/dev/sdb1 需要先将分区设为linux lvm格式</span>
<span class="token comment">#2.把两块硬盘设备加入到storage卷组中，然后查看卷组的状态。</span>
vgcreate storage /dev/sdb /dev/sdc
<span class="token comment">#查看卷组信息</span>
vgdisplay
<span class="token comment">#3.再切割出一个约为150MB的名称为vo的逻辑卷设备。</span>
<span class="token comment">#这里需要注意切割单位的问题。在对逻辑卷进行切割时有两种计量单位。第一种是以容量为单位，所使用的参数为-L。</span>
<span class="token comment">#例如，使用-L 150M生成一个大小为150MB的逻辑卷。</span>
<span class="token comment">#另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。</span>
<span class="token comment">#例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。</span>
lvcreate <span class="token parameter variable">-n</span> vo <span class="token parameter variable">-l</span> <span class="token number">37</span> storage
<span class="token comment">#示例2：将卷组backupgroup下所有剩余空间创建backuplv逻辑卷</span>
lvcreate <span class="token parameter variable">-n</span> backuplv <span class="token parameter variable">-l</span> +100%FREE backupgroup

<span class="token comment">#4.把生成好的逻辑卷进行格式化，然后挂载使用。</span>
mkfs.ext4 /dev/storage/vo <span class="token comment">#或者格式化为速度更快的格式 mkfs.xfs /dev/storage/vo</span>
<span class="token function">mkdir</span> /linuxprobe
<span class="token function">mount</span> /dev/storage/vo /linuxprobe
<span class="token comment">#对了，如果使用了逻辑卷管理器，则不建议用XFS文件系统，因为XFS文件系统自身就可以使用xfs_growfs命令进行磁盘扩容。这虽然不比LVM灵活，但起码也够用。在实测阶段我们发现，在有一些服务器上，XFS与LVM的兼容性并不好。</span>

<span class="token comment">#5.查看挂载状态，</span>
<span class="token function">df</span> <span class="token parameter variable">-h</span>
<span class="token comment">#6.写入配置文件，使其永久生效。</span>
<span class="token builtin class-name">echo</span> <span class="token string">"/dev/storage/vo /linuxprobe ext4 defaults 0 0"</span> <span class="token operator">&gt;&gt;</span> /etc/fstab
<span class="token comment">#echo "/dev/storage/vo /linuxprobe xfs defaults 0 0" &gt;&gt; /etc/fstab</span>
</code></pre> 
<p>lvm分区模式下，对逻辑卷扩容</p> 
<pre><code class="prism language-shell"><span class="token comment">#卸载storage卷组下的所有lv逻辑卷的挂载</span>
<span class="token function">umount</span> /linuxprobe
<span class="token comment">#2.把上一个实验中的逻辑卷vo扩展至290MB。</span>
lvextend <span class="token parameter variable">-L</span> 290M /dev/storage/vo
<span class="token comment">#3.检查硬盘的完整性，确认目录结构、内容和文件内容没有丢失。一般情况下没有报错，均为正常情况。</span>
e2fsck <span class="token parameter variable">-f</span> /dev/storage/vo
<span class="token comment">#4.重置设备在系统中的容量。刚刚是对LV（逻辑卷）设备进行了扩容操作，但系统内核还没有同步到这部分新修改的信息，需要手动进行同步。</span>
resize2fs /dev/storage/vo
<span class="token comment">#5.重新挂载硬盘设备并查看挂载状态。</span>
<span class="token function">mount</span> <span class="token parameter variable">-a</span>
<span class="token function">df</span> <span class="token parameter variable">-h</span>
<span class="token comment">#可见，总大小已经增加到279M：/dev/mapper/storage-vo  279M  2.1M  259M   1% /linuxprob</span>
</code></pre> 
<p>lvm分区模式下，对逻辑卷缩容</p> 
<pre><code class="prism language-shell"><span class="token comment">#卸载storage卷组下的所有lv逻辑卷的挂载</span>
<span class="token function">umount</span> /linuxprobe
<span class="token comment">#检查文件系统的完整性。</span>
e2fsck <span class="token parameter variable">-f</span> /dev/storage/vo
<span class="token comment">#通知系统内核将逻辑卷vo的容量减小到120MB。</span>
resize2fs /dev/storage/vo 120M
<span class="token comment">#将LV逻辑卷的容量修改为120M。</span>
lvreduce <span class="token parameter variable">-L</span> 120M /dev/storage/vo
<span class="token comment">#重新挂载文件系统并查看系统状态。</span>
<span class="token function">mount</span> <span class="token parameter variable">-a</span>
<span class="token function">df</span> <span class="token parameter variable">-h</span>
</code></pre> 
<p>删除逻辑卷</p> 
<pre><code class="prism language-shell"><span class="token comment">#取消挂载</span>
<span class="token function">umount</span> /linuxprobe
<span class="token comment">#编辑分区表，删除对应的挂载</span>
<span class="token function">vim</span> /etc/fstab
<span class="token comment">#执行删除</span>
lvremove /dev/storage/vo
</code></pre> 
<p>删除卷组，此处只写卷组名称即可，不需要设备的绝对路径。</p> 
<pre><code class="prism language-shell">vgremove storage
</code></pre> 
<p>删除物理卷设备。</p> 
<pre><code class="prism language-shell">pvremove /dev/sdb /dev/sdc
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/441ed86ab13f6e94985b9bf1ce062450/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">不让IE浏览器打开后跳转到edge【2023.11.27新】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1cc91aad26d87f5ff4db6c33595e6d27/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">亲测解决RuntimeError: CUDA error: invalid device ordinal CUDA kernel errors might be asynchronously repo</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>