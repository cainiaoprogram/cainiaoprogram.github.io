<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring框架AOP学习 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring框架AOP学习" />
<meta property="og:description" content="说明 ：AOP部分：参考网上课程，自己写的总结，如有侵权，联系删除。
目录
SpringAOP_AOP简介
SpringAOP_AOP相关术语 SpringAOP_AOP入门
SpringAOP_通知类型
SpringAOP_切点表达式
SpringAOP_多切面配置
SpringAOP_注解配置AOP
SpringAOP_原生Spring实现AOP SpringAOP_SchemaBased实现AOP
SpringAOP_AOP简介 AOP的全称是Aspect Oriented Programming，即面向切面编程。 是实现功能统一维护的一种技术，它将业务逻辑的各个部分进行隔 离，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高 了开发效率。
作用：在不修改源码的基础上，对已有方法进行增强。实现原理：动态代理技术。优势：减少重复代码、提高开发效率、维护方便应用场景：事务处理、日志管理、权限控制、异常处理等方面。 SpringAOP_AOP相关术语 名称说明Joinpoint（连接点）指能被拦截到的点，在Spring中只有方法能被拦截。（路上的车好多）Pointcut（切点）指要对哪些连接点进行拦截，即被增强的方法。 （拦住一个车）Advice（通知）指拦截后要做的事情，即切点被拦截后执行的方法。Aspect（切面）切点&#43;通知称为切面Target（目标）被代理的对象Proxy（代理）代理对象Weaving（织入）生成代理对象的过程 SpringAOP_AOP入门 AspectJ是一个基于Java语言的AOP框架，在Spring框架中建议使用 AspectJ实现AOP。
接下来我们写一个AOP入门案例：dao层的每个方法结束后都可以打印一条日志：
引入依赖
&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- AspectJ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 编写连接点（就是好多方法，可以切的都是拦截点）
@Repository public class UserDao { public void add(){ System.out.println(&#34;用户新增&#34;); } public void delete(){ System.out.println(&#34;用户删除&#34;); } public void update(){ System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a98939e3679113e6a2f594322a187b16/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-21T21:12:57+08:00" />
<meta property="article:modified_time" content="2022-07-21T21:12:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring框架AOP学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 说明 ：AOP部分：参考网上课程，自己写的总结，如有侵权，联系删除。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="SpringAOP_AOP%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#SpringAOP_AOP%E7%AE%80%E4%BB%8B" rel="nofollow">SpringAOP_AOP简介</a></p> 
<p id="SpringAOP_AOP%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%C2%A0-toc" style="margin-left:0px;"><a href="#SpringAOP_AOP%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%C2%A0" rel="nofollow">SpringAOP_AOP相关术语 </a></p> 
<p id="SpringAOP_AOP%E5%85%A5%E9%97%A8-toc" style="margin-left:0px;"><a href="#SpringAOP_AOP%E5%85%A5%E9%97%A8" rel="nofollow">SpringAOP_AOP入门</a></p> 
<p id="SpringAOP_%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#SpringAOP_%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B" rel="nofollow">SpringAOP_通知类型</a></p> 
<p id="SpringAOP_%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:0px;"><a href="#SpringAOP_%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">SpringAOP_切点表达式</a></p> 
<p id="SpringAOP_%E5%A4%9A%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#SpringAOP_%E5%A4%9A%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE" rel="nofollow">SpringAOP_多切面配置</a></p> 
<p id="SpringAOP_%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEAOP-toc" style="margin-left:0px;"><a href="#SpringAOP_%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEAOP" rel="nofollow">SpringAOP_注解配置AOP</a></p> 
<p id="SpringAOP_%E5%8E%9F%E7%94%9FSpring%E5%AE%9E%E7%8E%B0AOP%C2%A0-toc" style="margin-left:0px;"><a href="#SpringAOP_%E5%8E%9F%E7%94%9FSpring%E5%AE%9E%E7%8E%B0AOP%C2%A0" rel="nofollow">SpringAOP_原生Spring实现AOP </a></p> 
<p id="%C2%A0SpringAOP_SchemaBased%E5%AE%9E%E7%8E%B0AOP-toc" style="margin-left:0px;"><a href="#%C2%A0SpringAOP_SchemaBased%E5%AE%9E%E7%8E%B0AOP" rel="nofollow"> SpringAOP_SchemaBased实现AOP</a></p> 
<hr id="hr-toc"> 
<h2 id="SpringAOP_AOP%E7%AE%80%E4%BB%8B">SpringAOP_AOP简介</h2> 
<p><img alt="" height="283" src="https://images2.imgbox.com/7b/3f/UC06FuP3_o.png" width="561"></p> 
<p> AOP的全称是Aspect Oriented Programming，即面向切面编程。 是实现功能统一维护的一种技术，它将业务逻辑的各个部分进行隔 离，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高 了开发效率。</p> 
<ul><li><strong>作用：在不修改源码的基础上，对已有方法进行增强。</strong></li><li><strong>实现原理：动态代理技术。</strong></li><li>优势：减少重复代码、提高开发效率、维护方便</li><li>应用场景：事务处理、日志管理、权限控制、异常处理等方面。</li></ul> 
<h2 id="SpringAOP_AOP%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%C2%A0">SpringAOP_AOP相关术语 </h2> 
<p class="img-center"><img alt="" height="230" src="https://images2.imgbox.com/0b/2c/GTi32IVR_o.png" width="543"></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>名称</td><td>说明</td></tr><tr><td>Joinpoint（连接点）</td><td>指能被拦截到的点，在Spring中只有方法能被拦截。（路上的车好多）</td></tr><tr><td>Pointcut（切点）</td><td>指要对哪些连接点进行拦截，即被增强的方法。 （拦住一个车）</td></tr><tr><td>Advice（通知）</td><td>指拦截后要做的事情，即切点被拦截后执行的方法。</td></tr><tr><td>Aspect（切面）</td><td>切点+通知称为切面</td></tr><tr><td>Target（目标）</td><td>被代理的对象</td></tr><tr><td>Proxy（代理）</td><td>代理对象</td></tr><tr><td>Weaving（织入）</td><td>生成代理对象的过程</td></tr></tbody></table> 
<h2 id="SpringAOP_AOP%E5%85%A5%E9%97%A8">SpringAOP_AOP入门</h2> 
<p>AspectJ是一个基于Java语言的AOP框架，在Spring框架中建议使用 AspectJ实现AOP。</p> 
<p>接下来我们写一个AOP入门案例：dao层的每个方法结束后都可以打印一条日志：</p> 
<p>引入依赖</p> 
<pre><code class="language-XML">&lt;!-- spring --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.3.13&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- AspectJ --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.8.7&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- junit --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre> 
<p>编写连接点（就是好多方法，可以切的都是拦截点）</p> 
<pre><code class="language-java">@Repository
public class UserDao {
    public void add(){
        System.out.println("用户新增");
   }
    public void delete(){
        System.out.println("用户删除");
   }
    public void update(){
        System.out.println("用户修改");
   }
}
</code></pre> 
<p>编写通知类</p> 
<pre><code class="language-java">public class MyAspectJAdvice {
    // 后置通知
    public void myAfterReturning() {
        System.out.println("打印日志...");
   }
}</code></pre> 
<p>配置切面</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;context:component-scan base-package="com.dream"&gt;&lt;/context:component-scan&gt;
    &lt;!-- 通知对象 --&gt;
    &lt;bean id="myAspectJAdvice" class="com.dream.advice.MyAspectAdvice"&gt;&lt;/bean&gt;
    &lt;!-- 配置AOP --&gt;
    &lt;aop:config&gt;
        &lt;!-- 配置切面 --&gt;
        &lt;aop:aspect ref="myAspectJAdvice"&gt;
            &lt;!-- 配置切点 --&gt;
            &lt;aop:pointcut id="myPointcut" expression="execution(* com.dream.dao.UserDao.*(..))"/&gt;
            &lt;!-- 配置通知,这个可以配置前置。。。多个 --&gt;
            &lt;aop:after-returning method="myAfterReturning" pointcut-ref="myPointcut"/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre> 
<p>测试</p> 
<pre><code class="language-java">public class UserDaoTest {
    @Test
    public void testAdd(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        UserDao userDao = (UserDao)ac.getBean("userDao");
        userDao.add();
   }
    @Test
    public void testDelete(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        UserDao userDao = (UserDao)ac.getBean("userDao");
        userDao.delete();
   }
    @Test
    public void testUpdate(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        UserDao userDao = (UserDao)ac.getBean("userDao");
        userDao.update();
   }
}
</code></pre> 
<h2 id="SpringAOP_%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B">SpringAOP_通知类型</h2> 
<p>AOP有以下几种常用的通知类型：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>通知类型</td><td>描述</td></tr><tr><td>前置通知(before)</td><td>在方法执行前添加功能</td></tr><tr><td>后置通知(after-returning)</td><td>在方法正常执行后添加功能</td></tr><tr><td>异常通知(after-throwing)</td><td>在方法抛出异常后添加功能</td></tr><tr><td>最终通知(after)</td><td>无论方法是否抛出异常，都会执行该通知</td></tr><tr><td>环绕通知 (around)</td><td>在方法执行前后添加功能</td></tr></tbody></table> 
<p>编写通知方法</p> 
<pre><code class="language-java">// 通知类
public class MyAspectAdvice {
    // 后置通知
    public void myAfterReturning(JoinPoint joinPoint) {
        System.out.println("切点方法名：" +joinPoint.getSignature().getName());
        System.out.println("目标对象：" + joinPoint.getTarget());
        System.out.println("打印日志" + joinPoint.getSignature().getName() + "方法被执行了！");
   }
    // 前置通知
    public void myBefore() {
        System.out.println("前置通知...");
   }
    // 异常通知
    public void myAfterThrowing(Exception ex) {
        System.out.println("异常通知...");
        System.err.println(ex.getMessage());
   }
    // 最终通知
    public void myAfter() {
        System.out.println("最终通知");
   }
    // 环绕通知
    public Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println("环绕前");
        Object obj = proceedingJoinPoint.proceed(); // 执行方法
        System.out.println("环绕后");
        return obj;
   }
}
</code></pre> 
<p>配置切面</p> 
<pre><code class="language-XML">&lt;!-- 配置AOP --&gt;
&lt;aop:config&gt;
    &lt;!-- 配置切面 --&gt;
    &lt;aop:aspect ref="myAspectJAdvice"&gt;
        &lt;!-- 配置切点 --&gt;
        &lt;aop:pointcut id="myPointcut" expression="execution(* com.dream.dao.UserDao.*(..))"/&gt;
        &lt;!-- 前置通知 --&gt;
        &lt;aop:before method="myBefore" pointcut-ref="myPointcut"&gt;&lt;/aop:before&gt;
        &lt;!-- 后置通知 --&gt;
        &lt;aop:after-returning method="myAfterReturning" pointcut-ref="myPointcut"/&gt;
        &lt;!-- 异常通知 --&gt;
        &lt;aop:after-throwing method="myAfterThrowing" pointcut-ref="myPointcut" throwing="ex"/&gt;
        &lt;!-- 最终通知 --&gt;
        &lt;aop:after method="myAfter" pointcut-ref="myPointcut"&gt;&lt;/aop:after&gt;
        &lt;!-- 环绕通知 --&gt;
        &lt;aop:around method="myAround" pointcut-ref="myPointcut"&gt;&lt;/aop:around&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;</code></pre> 
<h2 id="SpringAOP_%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F">SpringAOP_切点表达式</h2> 
<p>使用AspectJ需要使用切点表达式配置切点位置，写法如下：</p> 
<ul><li><strong>标准写法：访问修饰符 返回值 包名.类名.方法名(参数列表)</strong></li><li>访问修饰符可以省略。</li><li>返回值使用 * 代表任意类型。</li><li>包名使用 * 表示任意包，多级包结构要写多个 * ，使用 *.. 表示任意包结构</li><li>类名和方法名都可以用 * 实现通配。</li><li>参数列表 
  <ul><li>基本数据类型直接写类型</li><li>引用类型写 包名.类名</li><li>* 表示匹配一个任意类型参数</li><li>.. 表示匹配任意类型任意个数的参数</li></ul></li><li>全通配： * *..*.*(..)</li></ul> 
<h2 id="SpringAOP_%E5%A4%9A%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE">SpringAOP_多切面配置</h2> 
<p>我们可以为切点配置多个通知，形成多切面，比如希望dao层的每 个方法结束后都可以打印日志并发送邮件：</p> 
<p>添加编写发送邮件的通知：</p> 
<pre><code class="language-java">public class MyAspectJAdvice2 {
    // 后置通知
    public void myAfterReturning(JoinPoint joinPoint) {
        System.out.println("发送邮件");
   }
}
</code></pre> 
<p>配置切面：</p> 
<pre><code class="language-XML">&lt;!-- 通知对象 --&gt;
&lt;bean id="myAspectJAdvice" class="com.dream.advice.MyAspectAdvice"&gt;&lt;/bean&gt;
&lt;bean id="myAspectJAdvice2" class="com.dream.advice.MyAspectAdvice2"&gt;&lt;/bean&gt;
&lt;!-- 配置AOP --&gt;
&lt;aop:config&gt;
    &lt;!-- 配置切面 --&gt;
    &lt;aop:aspect ref="myAspectJAdvice"&gt;
        &lt;!-- 配置切点 --&gt;
        &lt;aop:pointcut id="myPointcut" expression="execution(* *..*.*(..))"/&gt;
        &lt;!-- 后置通知 --&gt;
        &lt;aop:after-returning method="myAfterReturning" pointcut-ref="myPointcut"/&gt;
    &lt;/aop:aspect&gt;
    
    &lt;aop:aspect ref="myAspectJAdvice2"&gt;
        &lt;aop:pointcut id="myPointcut2" expression="execution(* com.dream.dao.UserDao.*(..))"/&gt;
        &lt;aop:after-returning method="myAfterReturning" pointcut-ref="myPointcut2"/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre> 
<h2 id="SpringAOP_%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEAOP">SpringAOP_注解配置AOP</h2> 
<p>Spring可以使用注解代替配置文件配置切面：</p> 
<ol><li>Spring可以使用注解代替配置文件配置切面： <pre><code class="language-XML">&lt;!-- 开启注解配置Aop --&gt;
&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code></pre> </li><li><strong>在通知类上方加入注解 @Aspect</strong></li><li>在通知方法上方加入注解@Before/@AfterReturning/@AfterThrowing/@After/@Around <pre><code class="language-java">@Aspect
@Component
public class MyAspectAdvice {
    // 后置通知
    @AfterReturning("execution(* com.dream.dao.UserDao.*(..))")
    public void myAfterReturning(JoinPoint joinPoint) {
        System.out.println("切点方法名：" + joinPoint.getSignature().getName());
        System.out.println("目标对象：" + joinPoint.getTarget());
        System.out.println("打印日志" + joinPoint.getSignature().getName() + "方法被执行了！");
   }
    // 前置通知
    @Before("execution(* com.dream.dao.UserDao.*(..))")
    public void myBefore() {
        System.out.println("前置通知...");
   }
    // 异常通知
    @AfterThrowing(value = "execution(* com.dream.dao.UserDao.*(..))",throwing = "ex")
    public void myAfterThrowing(Exception ex) {
        System.out.println("异常通知...");
        System.err.println(ex.getMessage());
   }
    // 最终通知
    @After("execution(* com.dream.dao.UserDao.*(..))")
    public void myAfter() {
        System.out.println("最终通知");
   }
    // 环绕通知
    @Around("execution(* com.dream.dao.UserDao.*(..))")
    public Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println("环绕前");
        Object obj = proceedingJoinPoint.proceed(); // 执行方法
        System.out.println("环绕后");
        return obj;
   }
}</code></pre> </li></ol> 
<blockquote> 
 <p>如何为一个类下的所有方法统一配置切点：</p> 
 <p>1.在通知类中添加方法配置切点(单独创建一个方法)</p> 
 <pre><code class="language-java">@Pointcut("execution(* com.dream.dao.UserDao.*(..))")
public void pointCut(){}</code></pre> 
 <p>2.在通知方法上使用定义好的切点</p> 
 <pre><code class="language-java">@Before("pointCut()")
public void myBefore(JoinPoint joinPoint) {
    System.out.println("前置通知...");
}
@AfterReturning("pointCut()")
public void myAfterReturning(JoinPoint joinPoint) {
    System.out.println("后置通知...");
}
</code></pre> 
</blockquote> 
<blockquote> 
 <p>配置类如何代替xml中AOP注解支持？</p> 
 <p>在配置类上方添加@EnableAspectJAutoProxy即可</p> 
 <pre><code class="language-java">@Configuration
@ComponentScan("com.dream")
@EnableAspectJAutoProxy
public class SpringConfig {
}</code></pre> 
</blockquote> 
<h2 id="SpringAOP_%E5%8E%9F%E7%94%9FSpring%E5%AE%9E%E7%8E%B0AOP%C2%A0">SpringAOP_原生Spring实现AOP </h2> 
<p>除了AspectJ，Spring支持原生方式实现AOP。<strong>原生方式实现AOP只有四种通知类型</strong></p> 
<ol><li> 引入依赖 <pre><code class="language-XML">&lt;!-- 原生AOP --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;5.3.13&lt;/version&gt;
&lt;/dependency&gt;</code></pre> </li><li>编写通知类 <pre><code class="language-java">// Spring原生Aop的通知类
public class SpringAop implements MethodBeforeAdvice, AfterReturningAdvice,
ThrowsAdvice, MethodInterceptor {
    /**
     * 前置通知
     * @param method 目标方法
     * @param args 目标方法的参数列表
     * @param target 目标对象
     * @throws Throwable
     */
    @Override
    public void before(Method method,Object[] args, Object target) throws Throwable {
        System.out.println("前置通知");
   }
    /**
     * 后置通知
     * @param returnValue 目标方法的返回值
     * @param method 目标方法
     * @param args 目标方法的参数列表
     * @param target 目标对象
     * @throws Throwable
     */
    @Override
    public void afterReturning(Object returnValue, Method method, Object[] args,
Object target) throws Throwable {
        System.out.println("后置通知");
   }
    /**
     * 环绕通知
     * @param invocation 目标方法
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("环绕前");
        Object proceed =invocation.proceed();
        System.out.println("环绕后");
        return proceed;
   }
    /**
     * 异常通知
     * @param ex 异常对象
     */
    public void afterThrowing(Exception ex){
        System.out.println("发生异常了！");
   }
}</code></pre> <p>Spring原生方式实现AOP时，只支持四种通知类型：</p> 
  <table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>通知类型</td><td>实现接口</td></tr><tr><td>前置通知</td><td>MethodBeforeAdvice</td></tr><tr><td>后置通知</td><td>AfterReturningAdvice</td></tr><tr><td>异常通知</td><td>ThrowsAdvice</td></tr><tr><td>环绕通知</td><td>MethodInterceptor</td></tr></tbody></table></li><li>编写配置类 <pre><code class="language-XML">&lt;!-- 通知对象 --&gt;
&lt;bean id="springAop" class="com.dream.advice.SpringAop"&gt;&lt;/bean&gt;
&lt;!-- 配置代理对象 --&gt;
&lt;bean id="userDaoProxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;!-- 配置目标对象 --&gt;
    &lt;property name="target" ref="userDao"&gt;&lt;/property&gt;
    &lt;!-- 配置通知 --&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;springAop&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- 代理对象的生成方式 true：使用CGLib ,false：使用原生JDK生成--&gt;
    &lt;property name="proxyTargetClass" value="true"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre> </li><li>测试类 <pre><code class="language-java">public class UserDaoTest2 {
    @Test
    public void testAdd(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean2.xml");
        UserDao userDao = (UserDao)ac.getBean("userDaoProxy"); // 获取的是代理对象
        userDao.update();
   }
}</code></pre> </li></ol> 
<p><span style="color:#fe2c24;"><strong> 测试的时候报错：就是不知道啥情况呢哎*********************</strong></span></p> 
<pre><code>java.lang.ClassCastException: class com.sun.proxy.$Proxy27 cannot be cast to class com.dream.dao.UserDao (com.sun.proxy.$Proxy27 and com.dream.dao.UserDao are in unnamed module of loader 'app')</code></pre> 
<h2 id="%C2%A0SpringAOP_SchemaBased%E5%AE%9E%E7%8E%B0AOP"> SpringAOP_SchemaBased实现AOP</h2> 
<p><strong>SchemaBased(基础模式)配置方式是指使用Spring原生方式定义通知，而使用AspectJ框架配置切面。</strong></p> 
<ol><li>编写通知类 <pre><code class="language-java">public class SpringAop implements MethodBeforeAdvice, AfterReturningAdvice, ThrowsAdvice, MethodInterceptor {
    /**
     * 前置通知
     * @param method 目标方法
     * @param args 目标方法的参数列表
     * @param target 目标对象
     * @throws Throwable
     */
    @Override
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println("前置通知");
   }
    /**
     * 后置通知
     * @param returnValue 目标方法的返回值
     * @param method 目标方法
     * @param args 目标方法的参数列表
     * @param target 目标对象
     * @throws Throwable
     */
    @Override
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
        System.out.println("后置通知");
   }
    /**
     * 环绕通知
     * @param invocation 目标方法
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("环绕前");
        Object proceed =invocation.proceed();
        System.out.println("环绕后");
        return proceed;
   }
    /**
     * 异常通知
     * @param ex 异常对象
     */
    public void afterThrowing(Exception ex){
        System.out.println("发生异常了！");
   }
}
</code></pre> </li><li> <p>配置切面</p> <pre><code class="language-XML">&lt;!-- 通知对象 --&gt;
&lt;bean id="springAop2" class="com.dream.aop.SpringAop2"/&gt;
&lt;!-- 配置切面 --&gt;
&lt;aop:config&gt;
    &lt;!-- 配置切点--&gt;
    &lt;aop:pointcut id="myPointcut" expression="execution(* com.dream.dao.UserDao.*(..))"/&gt;
    &lt;!-- 配置切面：advice-ref：通知对象 pointcut-ref：切点 --&gt;
    &lt;aop:advisor advice-ref="springAop2" pointcut-ref="myPointcut"/&gt;
&lt;/aop:config&gt;
</code></pre> </li></ol> 
<p> 这个是可以的，感觉第三种也不太好用</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60b5496639fb91f172d21df12e370f2b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">（十一）51单片机——用AT24C02实现存储秒表数据（附成果展示）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2c4f8e4a7abd3ca0e24526d80b1c86a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是系统？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>