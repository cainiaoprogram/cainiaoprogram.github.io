<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;基础知识点 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;基础知识点" />
<meta property="og:description" content="一、 基础架构及定义 #include&lt;...&gt;定义要包含的头文件和类库#define 常量名 常量值 定义常量using namespace std;ifstream fin(&#34;流输入文件名&#34;); 为文件定义流输入函数fin,函数名fin可自由定义，可为若干个不同的函数名定义各自的输入流。ofstream fout(&#34;流输出文件名&#34;); 为文件定义流输出函数fout,函数名fout只是一个输出标识符，可自由定义多组标识符与输出流的对应关系。fin.close() 关闭fin的输入流文件（可省略）fout.close() 关闭fout对应的输出流文件（可省略）//注释内容⋯⋯ 单行注释多行注释 /* 多行注释开始标记 ⋯⋯ 注释内容 */ 多行注释结束标志主函数 MAIN(){...} 主函数无返回值 int main(){... return 0;} 主函数有返回值 二、 #include可包含的库（头文件） iostream 标准输入输出流fstream 文件输入输出流cstdlib c&#43;&#43;标准库cstdio c&#43;&#43;输入输出模块CMATH c&#43;&#43;数学函数库Cstring 字符串ctime 时间climits 极限库cfloat 实数库IOMANIP 流输出格式函数库algorithm 算法库vector 支持动态数组，是扩展栈容器 支持前缀比大小map建立两类数据的关联（映射）stack 基本栈结构支持s.pop(),s.push(x),s.size(),s.empty()及&gt;,&lt; s.top()queue 支持基本队列queue及优先队列priority_queue（堆）基本队列函数：q.pop() q.front() q.push(x) q.back() q.size()在queue中有前缀比较的&gt;和&lt;set 支持自平衡查找二叉树结构表示的单值集合set及多值集合multiset，其类函数支持集合的多种运算deque 扩展队列结构（循环队列容器） 支持前缀比大小list 双向链，用it&#43;&#43;或it–在链中寻址也可用push或pop等操作支持前缀&gt;、&lt;比较bitset 位向量集合，可当数组使用，支持与或运算c语言头文件，如math.h、string.h、stdio.h等 三、 类型 bool 布尔类型，1字节，非0(false)整数视为1(true)char 1字节，可视为有符号整数，其数组可作为字符串使用short int 2字节补码整数int 4字节补码整数long long (int) 8字节补码整数作常量赋值时应带后缀ll2——5的补码整数（有符号）前面加unsigned的前缀就是无符号类型的整数例如unsigned char变为无符号字符或整数float 4字节实数（单精度浮点编码）double 8字节双精度浮点编码long double 12字节长双精度浮点编码string 在CSTRING中可用&#43;直接连接两个字符串、可直接赋值，也可用&gt;、&lt;、==等关系符号直接比较还可以向字符数组一样逐字符地访问，结束位置有0。string s的起始位置char* s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f277952687a8698ba119c68d10499dc8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-17T19:28:10+08:00" />
<meta property="article:modified_time" content="2016-12-17T19:28:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;基础知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="一-基础架构及定义">一、 基础架构及定义</h3> 
<ol><li><code>#include&lt;...&gt;</code>定义要包含的头文件和类库</li><li><code>#define 常量名 常量值 定义常量</code></li><li><code>using namespace std;</code></li><li><code>ifstream fin("流输入文件名");</code> 为文件定义流输入函数fin,函数名fin可自由定义，可为若干个不同的函数名定义各自的输入流。</li><li><code>ofstream fout("流输出文件名");</code> 为文件定义流输出函数fout,函数名fout只是一个输出标识符，可自由定义多组标识符与输出流的对应关系。</li><li><code>fin.close()</code> 关闭fin的输入流文件（可省略）</li><li><code>fout.close()</code> 关闭fout对应的输出流文件（可省略）</li><li><code>//注释内容⋯⋯</code> 单行注释</li><li>多行注释 <br> <code>/* 多行注释开始标记 <br> ⋯⋯ 注释内容 <br> */ 多行注释结束标志</code></li><li>主函数 <br> <code>MAIN(){...}</code> 主函数无返回值 <br> <code>int main(){... return 0;}</code> 主函数有返回值</li></ol> 
<h3 id="二-include可包含的库头文件">二、 #include可包含的库（头文件）</h3> 
<ol><li>iostream 标准输入输出流</li><li>fstream 文件输入输出流</li><li>cstdlib c++标准库</li><li>cstdio c++输入输出模块</li><li>CMATH c++数学函数库</li><li>Cstring 字符串</li><li>ctime 时间</li><li>climits 极限库</li><li>cfloat 实数库</li><li>IOMANIP 流输出格式函数库</li><li>algorithm 算法库</li><li>vector 支持动态数组，是扩展栈容器 支持前缀比大小</li><li>map建立两类数据的关联（映射）</li><li>stack 基本栈结构支持s.pop(),s.push(x),s.size(),s.empty()及&gt;,&lt; s.top()</li><li>queue 支持基本队列queue及优先队列priority_queue（堆）基本队列函数：q.pop() q.front() q.push(x) q.back() q.size()在queue中有前缀比较的&gt;和&lt;</li><li>set 支持自平衡查找二叉树结构表示的单值集合set及多值集合multiset，其类函数支持集合的多种运算</li><li>deque 扩展队列结构（循环队列容器） 支持前缀比大小</li><li>list 双向链，用it++或it–在链中寻址也可用push或pop等操作支持前缀&gt;、&lt;比较</li><li>bitset 位向量集合，可当数组使用，支持与或运算</li><li>c语言头文件，如math.h、string.h、stdio.h等</li></ol> 
<h3 id="三-类型">三、 类型</h3> 
<ol><li>bool 布尔类型，1字节，非0(false)整数视为1(true)</li><li>char 1字节，可视为有符号整数，其数组可作为字符串使用</li><li>short int 2字节补码整数</li><li>int 4字节补码整数</li><li>long long (int) 8字节补码整数作常量赋值时应带后缀ll2——5的补码整数（有符号）前面加unsigned的前缀就是无符号类型的整数例如unsigned char变为无符号字符或整数</li><li>float 4字节实数（单精度浮点编码）</li><li>double 8字节双精度浮点编码</li><li>long double 12字节长双精度浮点编码</li><li>string 在CSTRING中可用+直接连接两个字符串、可直接赋值，也可用&gt;、&lt;、==等关系符号直接比较还可以向字符数组一样逐字符地访问，结束位置有0。string s的起始位置char* s.c_str()输入时空格默认为间隔符 <br> <code>s.empty()</code>是s为空的逻辑函数s的长度表示为 <br> <code>s.length()</code>在s中查找a的起始位置 <br> <code>s.find(string a[,int b])</code>可选项b表示查询起点，省略表示从头找，找不到该子串就返回“全1”的无符号整数 <br> <code>s.substr(int b[,int l])</code>表示s中从b开始到串尾（或长度为l）的子串</li><li>FILE *f; 定义文件类型的指针f</li><li>无类型 void</li><li>自定义数据类型 typedef <br> <code>typedef char chuan[100];//定义长度不超100的串类型名chuan <br> typedef int data[10];//定义名为data的数组类型</code></li><li>共用体或联合体 <br> <code>union dt{int x;char y[3];}; <br> main() { <br> dt a; <br> cin&gt;&gt;a.y; <br> cout&lt;&lt;a.x&lt;&lt;endl; <br> ...}</code></li><li>结构体（或结点）类型的定义 <br> <code>struct node { <br> int data; <br> node *next; <br> node(){next=NULL;}};</code> <br> 最后这行包含了构造函数，此函数在生成结构体变量时会自动触发，它可写可不写。与构造函数相反，析构函数~node(){…}在结构体被释放的时候自动执行。结构体内还可以定义处理该结构体变量的特定函数（例如a.make(x)等），也可以重载运算符。不特别限定时，其内部定义的对象都是public</li><li>类定义class <br> 与14相比，除了把struct换为class以外，其它很相似，只是不特别限定时，其内部定义的对象都是private</li><li>枚举类型enum <br> <code>enum fangxiang {up,down,left,right};</code></li><li>数据对pair,有序二元组 <br> <code>pair&lt;int,int&gt;c; <br> c.first=1,c.second=3;</code> <br> pair可作为map的key,建立平面坐标向其他数据的映射 <br> pair可比较，first和second分别为高、低关键字 <br> 可用<code>make_pair(x,y)</code>生成此类数据</li><li>位压缩集合 bitset 需包含同名类库 <br> 容器类型</li><li>集合与多集 set、multiset,需包含set库 <br> 存储结构为红黑树（一种自平衡的查找二叉树），支持元素与集合、集合与集合的各种运算 <br> 多集与集合的不同就是允许集合中出现值相等的元素， <br> 查找效率都是log2(n)</li><li>标准队列queue 需要同名类库 <br> <code>queue&lt;int&gt;q;</code>//可当成数组访问 <br> 
  <ul><li>头端<code>q.front()</code></li><li>尾端<code>q.back()</code></li><li>队空<code>q.empty()</code> </li><li>队长<code>q.size()</code></li><li>x进队<code>q.push(x)</code></li><li>队头元素删除<code>q.pop()</code></li></ul></li><li>vector（需包含同名函数库）多种定义形式 <br> 
  <ul><li><code>vector&lt;类型&gt;标识符 ;</code></li><li><code>vector&lt;类型&gt;标识符(最大容量)；</code></li><li><code>vector&lt; 类型 &gt; 标识符（最大容量，初始所有值）；</code>//范围内每个变量填充相同初值 <br> -括号中用两个地址参数，用数组中的一段值作初始化 <br> <code>int i[4] = {12,3,4,5}; <br> vector&lt;类型&gt;vi(i,i+2);</code></li><li><code>vector&lt; vector&lt;int&gt; &gt;v;</code>二维动态容器 <br> 定义此类型的迭代器（指针） <br> <code>vector&lt;int&gt;::iterator it;</code> <br> 相关函数：</li><li><code>vi.size()</code> vi的当前元素总数</li><li><code>a.capacity()</code>则是当前分配给a的空间</li><li><code>vi.begin()</code> vi的开始位置（引用类型）</li><li><code>vi.end()</code> vi的结束位置 引用类型，戌指</li><li>尾追加新元素x <code>vi.push_back(x)</code></li><li>在二维vi中追加一行 <code>vi.push_back(line)</code></li><li><code>vi.capacity()</code>可测得当前vi分配的空间</li><li><code>vi.clear()</code> 清空</li><li><code>vi.insert(it,x)</code> 在vi的it位置插入x或<code>vi.insert(it1,it2,it3)</code> 把it2到it3的数据插入到vi中的it1位置</li><li><code>vi.erase(it)</code> 删除vi中it位置的元素此类型可排序、可反排,甚至可直接赋值例如<code>vi=vj</code>插入溢出重新分配加倍的空间并成片搬移数据</li></ul></li><li>扩展队列 deque （需包含deque） <br> 与vector相近，但可灵活地对头尾进行push和pop操作。可利用sort reverse find count max_element min_element lower_bound upper_bound findif等函数进行处理。借助迭代器可进行任意位置上一或多个元素的插入和删除</li><li>双向队列 list,需包含同名库 <br> 用迭代器作++和–的操作可访问后一元素或前一元素</li><li>优先队列（堆） priority_queue，（需包含 queue） <br> 
  <ul><li><code>priority_queue&lt;int&gt;p;</code> 定义大者优先的堆p</li><li><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;p;p&gt;p;</code> 定义小者优先的堆p</li><li>堆头<code>p.top()</code>为最小或最大</li><li>支持<code>p.push(x)</code>和<code>p.pop()</code>的操作，代价都是log2(n)</li></ul></li><li>关联容器map,需包含同名函数库 <br> 查询代价log2(n)，可查找、插入、删除、改写、排序 <br> 
  <ul><li><code>map&lt;key,value&gt;标识符;</code> <br> 例如 <code>map&lt;string,int&gt;m;</code></li><li><code>m.empty()</code> 是否为空</li><li><code>m.size()</code> 当前元素总数</li><li><code>m.begin()</code> 首元素位置（引用类型）</li><li><code>m.end()</code> 末位置</li><li><code>m.insert(map&lt;string,int&gt;::value_type("Two",2));</code>向m中插入(“two”,2)的映射，可用m[“two”]=2实现</li><li><code>map&lt;string,int&gt;::iterator it=m.find(2);</code> 在m中找下标是2的位置，没找到则值为m.end()</li><li>此处的it是序号引用，不能做+2或-1等计算</li><li>it-&gt;first it-&gt;second分别表示下标和值</li><li><code>m.count(key)</code> 是否存在下标是key的映射</li><li><code>m.erase(it)</code> 删除一个位置的映射</li><li><code>m.erase(it,ti)</code> 删除多个关联</li></ul></li></ol> 
<h3 id="四-语句">四、 语句</h3> 
<ol><li>cin&gt;&gt;… 数据流输入变量（可当有返回值的函数用）</li><li>cout&lt;&lt;.. （可带set函数15、16、17）</li><li>fin&gt;&gt;… 有逻辑返回值TRUE或FALSE</li><li>fout&lt;&lt;…</li><li>变量=表达式 赋值 <br> 特殊情况有简略形式 x+=表达式 ++x x++ <br> 可连续赋值，例如 变量=变量=⋯⋯=表达式； <br> 也可在引用前顺带赋值，例如<code>a[i=x+1]=b</code> <br> 不能对普通字符串变量赋值 <br> 结合指针的赋值语句用法： <br> 
  <ul><li><code>FILE *f;f=fopen("文件名","r");</code> 打开文件准备读</li><li><code>FILE *f;f=fopen("文件名","w");</code>准备写</li><li><code>FILE *f=fopen("文件名","a");</code> 准备追加</li><li><code>node *p;p=new node;</code></li></ul></li><li><code>for(语句组...;条件...;语句组...)循环体;</code></li><li><code>if（条件）{...} else {...}</code></li><li><code>if（条件）{...}</code></li><li><code>while(条件) 循环体</code></li><li><code>do 循环体 while （条件）;</code></li><li><code>SYSTEM("PAUSE");停屏幕，</code> <br> 在c语言中用getch() 后者不能用于C++语言中，需用stdio.h支持 <br> <code>char c=getchar()</code> 从键盘读一个字符</li><li><code>return 表达式</code> <br> 对于无返回值的函数，执行到该函数最后的}时或执行到无返回值的return时都会结束。</li><li><code>break</code> 从当前正在执行的多重分支或当前正在执行的循环体中退出</li><li>多重分支 <br> <code>switch(表达式) <br> { <br> case ...:... break; <br> case ...:... break; <br> ... <br> default:...}</code></li><li><code>swap(a,b)</code> 交换A B的值</li><li><code>srand(time(0)) srand</code>（随机种子） 随机化语句</li><li><code>printf()</code>函数是格式化输出函数, 一般用于向标准输出设备按规定格式输出信息。 <br> 
  <ul><li>调用格式为: <code>printf("&lt;格式化字符串&gt;", &lt;参量表&gt;);</code> 其中格式化字符串包括两部分内容: <br> 
    <ul><li>一部分是正常字符, 这些字符将按原样输出;</li><li>另一部分是格式化规定字符, 以”%”开始, 后跟一个或几个规定字符,用来确定输出内容格式。 </li></ul></li><li>参量表是需要输出的一系列参数, 其个数必须与格式化字符串所说明的输出参数个数一样多,各参数之间用”,”分开, 且顺序一一对应, 否则将会出现意想不到的错误。</li><li>printf的格式控制的完整格式： <br> 
    <ul><li><code>% - 0 m.n l或h 格式字符</code></li><li>下面对组成格式说明的各项加以说明：</li><li><code>%</code>：表示格式说明的起始符号，不可缺少。</li><li><code>-</code>:有-表示左对齐输出，如省略表示右对齐输出。</li><li><code>0</code>：有0表示指定空位填0,如省略表示指定空位不填。</li><li><code>m.n</code>：m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度,用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n=6位。</li><li><code>l或h</code>:l对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。</li><li><code>f格式</code>：用来输出实数（包括单、双精度），以小数形式输出。有以下几种用法：</li><li><code>%f</code>：不指定宽度，整数部分全部输出并输出6位小数。</li><li><code>%m.nf</code> ：输出共占m列，其中有n位小数，如数值宽度小于m左端补空格。 </li><li><code>%-m.nf</code>：输出共占n列，其中有n位小数，如数值宽度小于m右端补空格。</li></ul></li><li>e格式：以指数形式输出实数。可用以下形式： <br> 
    <ul><li><code>%e</code>：数字部分（又称尾数）输出6位小数，指数部分占5位或4位。</li><li><code>%m.ne</code>和<code>%-m.ne</code>：m、n和”-”字符含义与前相同。此处n指数据的数字部分的小数位数，m表示整个输出数据所占的宽度。</li></ul></li><li>g格式：自动选f格式或e格式中较短的一种输出，且不输出无意义的零。</li></ul></li></ol> 
<h5 id="格式小结">格式小结：</h5> 
<ul><li>最常用的格式是<code>%d</code>，含义是以10进制形式打印一个整数。 <br> 如果输出的整数是负数，则输出的第一个字符就是-号。 <br> <code>%d</code>：按整型数据的实际长度输出。 <br> <code>%md</code>：m为指定的输出字段的宽度。如果数据的位数小于m，则左端补以空格，若大于m，则按实际位数输出。 <br> <code>%ld</code>：输出长整型数据。</li><li><code>%u</code>格式与<code>%d</code>格式类似，只不过要求打印无符号10进制整数。 <br> 以无符号十进制形式输出整数。 <br> 对长整型可以用”%lu”格式输出。同样也可以指定字段宽度用<code>%mu</code>格式输出。</li><li><code>%o</code>格式请求输出8进制整数,以无符号八进制形式输出整数。 <br> 对长整型可以用<code>%lo</code>格式输出。同样也可以指定字段宽度用<code>%mo</code>格式输出。</li><li><code>%x</code>和<code>%X</code>格式请求输出16进制整数。 <br> 
  <ul><li><code>%x</code>格式中用小写字母a,b,c,d,e,f来表示10到15之间的数,以无符号十六进制形式输出整数。</li><li>对长整型可以用<code>%lx</code>格式输出。同样也可以指定字段宽度用<code>%mx</code>格式输出。</li><li><code>%X</code>格式中用大写字母A,B,C,D,E,F来表示10到15之间的数 <br> 共同点：8进制和16进制整数总是作为无符号数处理的。</li></ul></li><li><code>%s</code>格式用于打印字符串，与之对应的参数应该是一个字符指针，待输出的字符始于该指针所指向的地址，直到出现一个空字符<code>'\0'</code>才终止。</li><li><code>%s</code>：例如:printf(“%s”, “CHINA”)输出”CHINA”字符串（不包括双引号）。</li><li><code>%ms</code>：输出的字符串占m列，如字符串本身长度大于m，则突破获m的限制,将字符串全部输出。若串长小于m，则左补空格。</li><li><code>%-ms</code>：如果串长小于m，则在m列范围内，字符串向左靠，右补空格。</li><li><code>%m.ns</code>：输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格。</li><li><code>%-m.ns</code>：其中m、n含义同上，n个字符输出在m列范围的左侧，右补空格。如果n&gt;m，则自动取n值，即保证n个字符正常输出。</li><li><code>%c</code>格式用于打印单个字符：例如： <br> <code>printf("%c",c);</code> 等价于 putchar(c);</li><li><code>%g</code>,<code>%f</code>和<code>%e</code>这三个格式用于打印浮点值。 <br> %g格式用于打印那些不需要按列对齐的浮点数特别有用。其作用有二： <br> 
  <ul><li>去掉该数尾多余的零（没有达到六位的数）</li><li>保留六位有效数字（多余六位的）</li></ul></li><li><code>%e</code>格式用于打印浮点数时，一律显示地使用指数形式：例如：输出圆周率时是：<code>3.141593e+00</code> <br> 两者的区别： <br> 
  <ul><li><code>%g</code>格式打印出的数是总共6位有效数字</li><li><code>%e</code>格式打印出小数点后的6位有效数字</li><li><code>%f</code>禁止使用指数形式来表示浮点数。因此圆周率输出为：<code>3.141593</code></li></ul></li></ul> 
<h5 id="但注意它的精度要求也是小数点后6位有效数字">（但注意它的精度要求：也是小数点后6位有效数字）</h5> 
<ul><li><code>%%</code>格式用于打印一个%字符。</li><li><code>%E</code>和<code>%G</code>只是在输出时用大写字母（E）代替了小写字母(e)</li><li>可以在”%”和字母之间插进数字表示最大场宽。 <br> 例如: <code>%2d</code> 表示输出3位整型数, 不够2位右对齐。 <br> 例如: <code>%5d</code> 表示输出3位整型数, 不够5位右对齐。 <br> 例如: <code>%10d</code> 表示输出3位整型数, 不够10位右对齐。</li></ul> 
<pre>unsigned int i=295;
printf("%2d\n",i);
printf("%5d\n",i);
printf("%10d\n",i);
295
  295
       295
Press any key to continue</pre> 
<ul><li>补0或者其它 <br> 例如: %02d 表示输出3位整型数, 不够2位右对齐，补0。 <br> 例如: %05d 表示输出3位整型数, 不够5位右对齐,补0。 <br> 例如: %010d 表示输出3位整型数, 不够10位右对齐,补0。 <br> <code>unsigned int i=295; <br> printf("%02d\n",i); <br> printf("%05d\n",i); <br> printf("%010d\n",i); <br> 295 <br> 00295 <br> 0000000295 <br> Press any key to continue</code></li><li>负数 <br> <code>int i=-295; <br> printf("%02d\n",i); <br> printf("%05d\n",i); <br> printf("%010d\n",i); <br> -295 <br> -0295 <br> -000000295 <br> Press any key to continue <br> </code></li><li>可以控制输出左对齐或右对齐, 即在”%”和字母之间加入一个”-” 号可 说明输出为左对齐, 否则为右对齐。 <br> <code>unsigned int i=295; <br> printf("%-02d\n",i); <br> printf("%-05d\n",i); <br> printf("%-010d\n",i); <br> 295 <br> 295 <br> 295 <br> Press any key to continue</code></li><li>可以在”%”和字母之间加小写字母l, 表示输出的是长型数。 <br> 例如: <code>%ld</code> 表示输出long整数 <br> <code>%lf</code> 表示输出double浮点数 </li><li><code>%9.2f</code> 表示输出场宽为9的浮点数, 其中小数位为2, 整数位为6, 小数点占一位, 不够9位右对齐。 <br> 例如: <code>%6.9s</code> 表示显示一个长度不小于6且不大于9的字符串。若大于9, 则第9个字符以后的内容将被删除. <br> 实例</li></ul> 
<pre>`unsigned int i=295;
printf("%d\n",i);
printf("%1d\n",i);
printf("%09d\n",i);
printf("%09d\n",(unsigned char)i);
printf("%9d\n",(unsigned char)i);
printf("%-9d\n",(unsigned char)i);
*/
295
295
000000295
000000039
       39
39
Press any key to continue</pre> 
<p>对于m.n的格式还可以用如下方法表示（例） <br> <code>int m=10,n=5; <br> char ch[]="abcdefghijklmnopqrst"; <br> printf("%*.*s\n",m,n,ch);//输出为 abcde</code> <br> 前边的*定义的是总的宽度，后边的定义的是输出的个数，分别对应外面的参数m和n。 <br> 我想这种方法的好处是可以在语句之外对参数m和n赋值，从而控制输出格式 <br> <code> <br> "%08lx\n",4byte <br> "%04x\n",2byte <br> "%-2.2BX",1byte <br> printf("%d\n",x);</code> <br> 又例如 <br> <code>PRINTF("%.03f",12.3456)</code> 输出12.346 <br> <code>printf("%4d",88)</code>输出 88 <br> <code>printf("%04d",88)</code> 输出0088 <br> 常用格式串 <br> - <code>%lld</code> 8字节整形 <br> - <code>%lf</code>:双精度实数 <br> - <code>%x</code> 十六进制 0x00 表示十进制0 <br> 其它字符按字符串原样打印</p> 
<ol><li><code>continue</code> 结束当前这一次循环体的执行</li><li><code>node *p;delete p;</code> 将P结点释放，还给系统 <br> 如果在定义NODE时也定义了反构造函数~NODE（），责此函数被触发。</li><li><code>scanf("%d",&amp;n)</code> 将整型数据输入到n中，输入格式串决定输入数据的格式。</li><li><code>fprintf(f,"%d",n)</code> 向文件F的当前位置输出整数N</li><li><code>fscanf(f,"%d %d",&amp;n,&amp;m)</code> <br> 对于字符串数组&amp;可有可无 <br> <code>char a[10],b[10]; <br> fscanf(f,"%s %s",a,&amp;b);</code></li><li><code>memset(数组名，每字节取值，字节数）</code> 用固定值（0~255）填充指定区域的内存。</li><li><code>memcpy(*a,*b,c)</code> 把*b开始的c个字节复制到*a开始的区域。</li><li><code>gets(char* a)</code> 让字符串a从键盘得到一个输入行，包括其中的空格 <br> <code>fgets(s,l,f)</code> 从文件f中读取长度不超l的输入行存入s，包括空格</li><li><code>freopen("文件名"，"方式字符"，标准输入或输出)</code> <br> 可为标准输入输出重定向 <br> 方式字符：r w a,或加’b’表示二进制方式例如wb rb <br> 标准输入用stdin表示， <br> 标准输出用stdout表示。</li><li><code>cin.getline(char *s,l)</code> 限制长度为l的行输入 <br> 与cin的输入同源，但在cin之后使用时需要用一个 <br> <code>cin.getline(s,0)</code> <br> 把未结束的换行读完，否则容易出错</li><li><code>rewind(FILE *f)</code> 将文件f指针置为开始</li><li><code>fseek(*f,p,m)</code> 设置文件f的指针位置 <br> 
  <ul><li>可用于r和w的方式，不能用于a方式</li><li>p为偏移量，可正可负 <br> m为偏移起点方式代码：0从头，1从当前位置，2从文件尾</li></ul></li><li><code>fwrite(*p,u,t,*F)</code> 将位置p(无类型指针)开始单位长度u的t项数据写入文件F中</li><li><code>fread(*p,u,t,*F)</code> 从文件指针F处读出t项单位长度为u的数据到内存的p位置 <br> 上述2语句能对有格式的数据进行输入和输出，文件都是二进制格式（b）</li><li><code>strlwr(char *s)</code> 将s中的大写字母转换为小写</li><li><code>strupr(char *s)</code> 将s中的小写字母转换为大写</li><li><code>fclose(FILE *f)</code> 关闭文件</li><li><code>next_permutation(a,a+n);</code> 把a数组中n个元素的全排列变换为下一个排列 <br> 此语句需要算法库的支持</li><li><code>make_heap(int *a,a+n);</code>//从a[0]到a[n-1]整体建堆，o(n)代价</li><li><code>push_heap(b,b+i+1);</code>//把b[i]插入从b[0]到b[i-1]的堆中</li><li><code>pop_heap(b,b+i);</code>//利用pop将堆顶删除至堆尾b[i-1]</li><li><code>reverse(首地址，末地址)</code> 反排数组,参数可以是指针或线性结构容器的迭代器</li><li>以下三个函数需流输出模块的支持 <br> 
  <ul><li><code>SETW(X)</code> 指定流输出的场宽</li><li><code>SETFILL('C')</code> 把场宽的空余位置填充上指定字符</li><li>SETPRECISION(小树位数） （小树位数包括小数点的位置，参数的小树位数不够时不填充无效0）</li></ul></li><li><code>exit 0;</code> 在子函数中结束整个程序</li><li><p><code>sort(首地址，末地址)</code> 数组升序排序,参数为指针或迭代器 <br> 可添加函数指针cmp作为第三参数，解决降序或其他特殊排序要求 <br> <code>bool cmp(const int &amp;a,const int &amp;b) { <br> return a&gt;b; <br> }//整数降序排序 <br> bool cmp(const node &amp;a,const node &amp;b) { <br> return a.x+a.y&lt;b.x+b.y; <br> }//按两个分量之和升序排序</code></p> <p>在C语言中还有一种较早期的用法： <br> <code>qsort(首地址，数据个数，单位数据字节数，比较函数名)</code> <br> 比较函数是自定义的，例如 <br> <code>int cmp(const void *a, const void *b) <br> { <br> return ((const Sample *)a)-&gt;data - ((const Sample *)b)-&gt;data; <br> }</code></p></li></ol> 
<h3 id="五-函数">五 函数</h3> 
<ol><li><code>abs()</code></li><li><code>pow(底数，指数)</code> 底数为实型，结果也是实型</li><li><code>strlen(s)</code></li><li><code>strcat(s1,s2)</code> 将S2接到S1后面并返回S1的地址</li><li><code>strcmp(s1,s2)</code> 返回值 1 0 -1</li><li><code>strcpy(s1,s2)</code> 可字符串赋值</li><li><code>strncpy(s1,s2,n)</code> 将S2的前N个字符复制到S1。如果超长则\0后面的字符将不被复制</li><li><code>strstr(s1,s2)</code></li><li><code>itoa(n,s,10)</code> 将n化为10禁制后转化为数字串存入s中</li><li><code>atoi(s)</code>数字串转数，转换失败前的转换有效</li><li><code>atof(char *s)</code>实数串转实数</li><li><code>rand()</code> 产生0到32767之间的随机整数</li><li>类型标识符（数据） 将参数强制转换为指定类型的数据形式 <br> 也可用： （类型）数据 来代替</li><li><code>（条件？值1：值2）</code> 条件函数</li><li><code>max(x,y)</code> 两个值中的较大值</li><li><code>min(x,y)</code> 两个值中的较小值</li><li><code>CLOCK()</code> 时钟函数值 <br> 每秒增加CLOCKS_PER_SEC，其值常为1000， <br> 有iostream的定义即可</li><li>log底数（真数） 省略底数时默认为自然对数</li><li><code>time(0)</code> 时间计数器，每秒加1，一年增加超过30000000</li><li><code>sqrt(x)</code> 返回算数平方根</li><li><code>sizeof(变量或类型)</code> 返回该变量或类型的字节数</li><li><code>fgetc(FILE *f)</code> 返回文件当前指针处读取的字符，指针顺移 <br> 例如 <br> <code>while((c=fgetc(f))!=EOF) c-=('a'-'A')*(c&gt;'Z');</code> <br> 此句把c中的字母变大写</li><li><code>ftell(FILE *f)</code> 返回文件当前指针位置</li><li>&amp;可返回变量首地址，例如 <br> 例如 <code>&amp;x</code>,<code>&amp;a[i][0]</code></li><li><code>make_pair(x,y)</code> 返回由x和y生成的数对</li><li>查找元素x <code>find(首地址，末地址，x)</code> <br> 返回值是指针或迭代器，若能找到就返回该位置，否则返回末地址（虚地址</li><li>数据计数 <code>count(首地址，末地址，x)</code> 统计x的个数 <br> 此函数用于map类型时，找的是key(first)是否存在</li></ol> 
<h3 id="六-运算">六 运算</h3> 
<ol><li>数值运算 +、-、*、/、% <br> +-*/有整数加减乘除法和十数加减乘除法两类含义，系统自动辨别，而%只用于整型。 <br> *在定义变量时是地址（指针）的说明符号，与定义好的指针类型变量连用时表示该地址的内存单元</li><li>关系运算 ==、&gt;、&lt;、&gt;=、&lt;=、!=</li><li>逻辑运算 <br> ！、&amp;&amp;、||</li><li>位运算 <br> &amp; | ^ ~、&gt;&gt;、&lt;&lt; <br> 其中的&amp;与单个变量作一元运算时是取地址运算</li><li>运算符重载 <br> <code>struct Sample { int data; }; <br> bool operator == (const Sample &amp;a, const Sample &amp;b) { <br> return a.data == b.data; <br> } <br> inline bool operator != (const Sample &amp;a, const Sample &amp;b) { <br> return !(a == b); <br> }</code></li></ol> 
<h3 id="七-运算顺序">七 运算顺序</h3> 
<p>() [] -&gt; . <br> 后置++ – <br> 前置++ – ! ~ 正负号+ - 地址* &amp; (类型) sizeof <br> * / % <br> + - <br> 位移&lt;&lt; &gt;&gt; <br> &lt; &lt;= &gt;= &gt; <br> == != <br> &amp; <br> ^ 异或 <br> | <br> &amp;&amp; <br> || <br> ?: 条件赋值 <br> = 赋值 <br> ,</p> 
<h3 id="六-系统常量">六 系统常量</h3> 
<ol><li><code>CLOCKS_PER_SEC</code> <br> <code>clock()</code>每秒增加的数量，其值常为1000</li><li><code>NULL</code> 空地址 0</li><li><code>false</code> 逻辑假 0</li><li><code>true</code> 逻辑真 1</li><li><code>INT_MAX</code>最大整形</li><li><code>INT_MIN</code> 最小整形</li><li><code>UINT_MAX</code> 最大无符号整形</li><li><code>LLONG_MAX</code> 最大无符号整形</li><li><code>ULLONG_MAX</code> 最大无符号长整形</li><li><code>DBL_MAX</code> 最大双精度实数，需要cfloat</li><li><code>EOF</code> 文件结束</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/89b2847464337daf115625355e83a96a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[Scrapy]模拟登陆并获取Cookie值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/13dc549cc8e6536e5a9208a53e3c4e73/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySql5.6 my.cnf配置优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>