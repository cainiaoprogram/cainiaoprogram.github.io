<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>洛谷 CSP-J 2021 分糖果&#43;插入排序 个人解答的优化过程以及详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="洛谷 CSP-J 2021 分糖果&#43;插入排序 个人解答的优化过程以及详解" />
<meta property="og:description" content="首先声明这两道题目第一题很简单，读者可以不看解答自己先做一遍题目，看看能不能获得满分，我就是因为无意识考虑时间复杂度的问题没有获得满分最开始，然后我进行了优化，获得了满分，但是第二题的难度较大，读者可以仔细领会，接下来请看题目：
首先我们来看第一道题分糖果：
样例以及数据范围：
我一开始的思路很简单，那就是从L到R进行枚举，不断更新ans得到最后的答案：
#include&lt;iostream&gt; using namespace std; int n,L,R; int ans=-1; int main(){ cin&gt;&gt;n&gt;&gt;L&gt;&gt;R; for(int i=L;i&lt;=R;i&#43;&#43;){ ans=max(ans,i%n); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } 这段代码得不到满分，在极端的情况下会导致超时，不过如果不追求满分的同学的话可以使用，因为这段代码已经有九十分了，然后接下来我进行了优化，我来讲一下我的优化思路：因为很明显我们最后的答案就是1到n-1，所以我们可以考虑引入变量，然后计算出L和R模去n的值以及除去n的值，如果除去n的两个变量相减大于等于1就说明L和R的差必定大于等于n也就意味着存在一个值x属于L到R,让我分到n-1个苹果，亦或者L,R其中一个值模去n得到n-1的话，同样可以判断出能获得n-1个苹果，否则的话我们将模出来的两个变量从小到大进行枚举最后不断更新就可以得到我们想要的答案：
#include&lt;iostream&gt; using namespace std; int n,L,R; int ans=-1; int main(){ cin&gt;&gt;n&gt;&gt;L&gt;&gt;R; if(R-L&gt;=n-1){ cout&lt;&lt;n-1&lt;&lt;endl; return 0; } int t1=L%n,t2=L/n,t3=R%n,t4=R/n; if(t1==n-1 || t3==n-1 || t4-t2&gt;=1){ cout&lt;&lt;n-1&lt;&lt;endl; return 0; } for(int i=min(t1,t3);i&lt;=max(t1,t3);i&#43;&#43;){ ans=max(ans,i); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } 好了，接下来是第二题，插入排序：
来看贼长的题干：
样例以及数据范围：
好了接下来来分析一下这一道题目：
这道题目我一开始的想法也就是模拟，首先把该输入的输入了，只不过我们需要引入一个变量数组t，因为如果是操作二的话我们每次都会对数组进行排序但是进行的操作并不会保留，因此我们可以利用这个t变量数组先存下一开始的a数组当操作结束之后再把a数组利用t数组还原：
#include&lt;iostream&gt; using namespace std; int n,q; const int N=10000; int a[N],t[N]; int main(){ cin&gt;&gt;n&gt;&gt;q; for(int i=1;i&lt;=n;i&#43;&#43;){ cin&gt;&gt;a[i]; } for(int i=1;i&lt;=q;i&#43;&#43;){ int p; cin&gt;&gt;p; if(p==1){ int x,v; cin&gt;&gt;x&gt;&gt;v; a[x]=v; } else { int x; cin&gt;&gt;x; int m=x; for(int j=1;j&lt;=n;j&#43;&#43;) t[j]=a[j]; for(int i=2;i&lt;=n;i&#43;&#43;){ for(int j=i;j&gt;=1;j--){ if(a[j]&lt;a[j-1]){ if(j==m){ int temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; m=j-1; } else if(j-1==m){ int temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; m=j; } else { int temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; } } } } cout&lt;&lt;m&lt;&lt;endl; for(int k=1;k&lt;=n;k&#43;&#43;) a[k]=t[k]; } } return 0; } but，出题人当然不会这么好心让我用模拟的思路就能直接过掉所有测试点，完完全全的超时了：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1f20ecdacda49877add41d795d5dcc47/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T22:07:09+08:00" />
<meta property="article:modified_time" content="2023-12-25T22:07:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">洛谷 CSP-J 2021 分糖果&#43;插入排序 个人解答的优化过程以及详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>首先声明这两道题目第一题很简单，读者可以不看解答自己先做一遍题目，看看能不能获得满分，我就是因为无意识考虑时间复杂度的问题没有获得满分最开始，然后我进行了优化，获得了满分，但是第二题的难度较大，读者可以仔细领会，接下来请看题目：</p> 
<p>首先我们来看第一道题分糖果：</p> 
<p><img alt="" height="1059" src="https://images2.imgbox.com/a5/10/oQ7ZkmWT_o.png" width="1173"></p> 
<p>样例以及数据范围：</p> 
<p><img alt="" height="1120" src="https://images2.imgbox.com/24/b3/PRcP9Zyc_o.png" width="1175"></p> 
<p><img alt="" height="753" src="https://images2.imgbox.com/8a/a5/5CAue17U_o.png" width="1108"> 我一开始的思路很简单，那就是从L到R进行枚举，不断更新ans得到最后的答案：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int n,L,R;
int ans=-1;
int main(){
	cin&gt;&gt;n&gt;&gt;L&gt;&gt;R;
	for(int i=L;i&lt;=R;i++){
		ans=max(ans,i%n);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</code></pre> 
<p>这段代码得不到满分，在极端的情况下会导致超时，不过如果不追求满分的同学的话可以使用，因为这段代码已经有九十分了，然后接下来我进行了优化，我来讲一下我的优化思路：因为很明显我们最后的答案就是1到n-1，所以我们可以考虑引入变量，然后计算出L和R模去n的值以及除去n的值，如果除去n的两个变量相减大于等于1就说明L和R的差必定大于等于n也就意味着存在一个值x属于L到R,让我分到n-1个苹果，亦或者L,R其中一个值模去n得到n-1的话，同样可以判断出能获得n-1个苹果，否则的话我们将模出来的两个变量从小到大进行枚举最后不断更新就可以得到我们想要的答案：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int n,L,R;
int ans=-1;
int main(){
	cin&gt;&gt;n&gt;&gt;L&gt;&gt;R;
	if(R-L&gt;=n-1){
		cout&lt;&lt;n-1&lt;&lt;endl;
		return 0;
	}
	int t1=L%n,t2=L/n,t3=R%n,t4=R/n;
	if(t1==n-1 || t3==n-1 || t4-t2&gt;=1){
		cout&lt;&lt;n-1&lt;&lt;endl;
		return 0;
	}  
	for(int i=min(t1,t3);i&lt;=max(t1,t3);i++){
	    ans=max(ans,i);
	    }
	    cout&lt;&lt;ans&lt;&lt;endl;
	    return 0;
}</code></pre> 
<p>好了，接下来是第二题，插入排序：</p> 
<p>来看贼长的题干：</p> 
<p><img alt="" height="1025" src="https://images2.imgbox.com/d5/ab/XY1mgOrH_o.png" width="1172"></p> 
<p><img alt="" height="926" src="https://images2.imgbox.com/52/fc/PbCKb8IV_o.png" width="1134"></p> 
<p>样例以及数据范围：</p> 
<p><img alt="" height="891" src="https://images2.imgbox.com/85/45/X0gdEuXU_o.png" width="1186"> <img alt="" height="690" src="https://images2.imgbox.com/40/c3/iRX7TUqc_o.png" width="1138"></p> 
<p> 好了接下来来分析一下这一道题目：<br> 这道题目我一开始的想法也就是模拟，首先把该输入的输入了，只不过我们需要引入一个变量数组t，因为如果是操作二的话我们每次都会对数组进行排序但是进行的操作并不会保留，因此我们可以利用这个t变量数组先存下一开始的a数组当操作结束之后再把a数组利用t数组还原：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int n,q;
const int N=10000;
int a[N],t[N];
int main(){
	cin&gt;&gt;n&gt;&gt;q;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;a[i];
	}
	for(int i=1;i&lt;=q;i++){
		int p;
		cin&gt;&gt;p;
		if(p==1){
			int x,v;
			cin&gt;&gt;x&gt;&gt;v;
			a[x]=v;
		}
		else {
			int x;
			cin&gt;&gt;x;
			int m=x;
			for(int j=1;j&lt;=n;j++)
			t[j]=a[j];
			for(int i=2;i&lt;=n;i++){
				for(int j=i;j&gt;=1;j--){
					if(a[j]&lt;a[j-1]){
						if(j==m){
							int temp=a[j];
							a[j]=a[j-1];
							a[j-1]=temp;
							m=j-1;
						}
						else if(j-1==m){
							int temp=a[j];
							a[j]=a[j-1];
							a[j-1]=temp;
							m=j;
						}
						else {
							int temp=a[j];
							a[j]=a[j-1];
							a[j-1]=temp;
						}
					}
				}
			}
			cout&lt;&lt;m&lt;&lt;endl;
			for(int k=1;k&lt;=n;k++)
			a[k]=t[k];
		}
	}
	return 0;
}</code></pre> 
<p>but，出题人当然不会这么好心让我用模拟的思路就能直接过掉所有测试点，完完全全的超时了：</p> 
<p><img alt="" height="864" src="https://images2.imgbox.com/47/ab/jT3AaQYS_o.png" width="1200"></p> 
<p>最后的结果就是只有五十多分，离满分具有相当大的差距 。</p> 
<p>那么接下来就是想一下如何写一个可以获得满分的代码了，当然是运用我们的老伙伴：结构体了，先放代码吧，代码下面我会进行讲解：</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int ans[8100];
int n,Q;
struct number{
	int val,pos;
	bool operator &lt; (const number &amp;A){
		return (val&lt;A.val) || (val==A.val &amp;&amp; pos&lt;A.pos);
	}
}a[8100];
int main(){
       cin&gt;&gt;n&gt;&gt;Q;
       for(int i=1;i&lt;=n;i++){
	       cin&gt;&gt;a[i].val;
	       a[i].pos=i;
	   }
	   for(int i=1;i&lt;=n;i++)
	   {
	   	for(int j=i+1;j&lt;=n;j++)
	   	   if(a[j]&lt;a[i])
	   	   swap(a[j],a[i]);
	   }
	   for(int i=1;i&lt;=n;i++){
	   	ans[a[i].pos]=i;
	   }
	   for(int i=1;i&lt;=Q;i++){
	   	int op;
	   	cin&gt;&gt;op;
	   	if(op==2){
	   		int x;
	   		cin&gt;&gt;x;
	   		cout&lt;&lt;ans[x]&lt;&lt;endl;
		   }
		   else {
		   	int x,v;
		   	cin&gt;&gt;x&gt;&gt;v;
		   	int p=ans[x];
		   	a[p].val=v;
		   	number tmp=a[p];
		   	for(int j=p;j&lt;n;j++){
		   		a[j]=a[j+1];
			   }
			   a[n]=tmp;
			   for(int j=n;j&gt;=2;j--){
			   	if(a[j]&lt;a[j-1]) swap(a[j],a[j-1]);
			    else break;
			   }
			   for(int j=1;j&lt;=n;j++)
			   ans[a[j].pos]=j;
		   }
     }
     return 0;
}</code></pre> 
<p>接下来我对这一段代码进行解释：</p> 
<p>这段代码定义了一个结构体以及ans数组，结构体里面有两个变量val和pos，分别代表了数字大小以及排名，结构体里面重载了运算符，排序规则就是如果分数不一样就按照从小到大的顺序进行排序，否则就是一开始的序号pos小的排前面，然后把所有需要输入的都输入了之后，将结构体按排序规则进行排序，这里使用的是冒泡排序法，ans数组用于存储原结构体中val的大小顺序，在排序结束后，将它们一开始的排名存储到ans对应的下标中。</p> 
<p>接下来就是Q次操作了，从1到Q进行枚举，每次的操作类型是op，如果op为2，直接输出对应的ans，因为排序是我们已经进行过的操作，否则如果是1的话，我们就要将对应x的下标中val改为v，然后利用一个中间变量tmp存下修改后的下标为p的结构体，并将从下标为x的结构体开始，挨着交换到n，然后将n令为tmp再从后到前枚举进行排序以便用于下一步的操作，并将排完序之后的大小顺序利用ans数组来进行更新。</p> 
<p>这个思路确实很难想，我想多数的读者和我一样都是想的第一个思想也就是直接模拟，希望读者仔细体会第二段代码，有所收获。</p> 
<p>如果读者觉得以上的讲解有用，如果不嫌麻烦的话，希望能得到你的一个赞，万分感谢！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9f7b440b0e7521a2f61ebdd2f302111/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python网站创建015：jQuery的各种操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10cfcade5009625ed5a1b5e2b6b96a80/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HarmonyOS鸿蒙应用开发——数据持久化Preferences</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>