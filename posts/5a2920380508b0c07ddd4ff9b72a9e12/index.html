<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32CubeMX学习笔记（16）——电源管理(PWR)低功耗停止模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32CubeMX学习笔记（16）——电源管理(PWR)低功耗停止模式" />
<meta property="og:description" content="一、低功耗模式简介 系统提供了多个低功耗模式，可在 CPU 不需要运行时（例如等待外部事件时）节省功耗。由用户根据应用选择具体的低功耗模式，以在低功耗、短启动时间和可用唤醒源之间寻求最佳平衡。
睡眠模式、停止模式及待机模式中，若备份域电源正常供电，备份域内的 RTC 都可以正常运行，备份域内的寄存器的数据会被保存，不受功耗模式影响。
从表中可以看到，这三种低功耗模式层层递进，运行的时钟或芯片功能越来越少，因而功耗越来越低。
模式名称说明进入方式唤醒方式对1.8V区域时钟的影响对VDD区域时钟的影响调压器睡眠模式内核停止，所有外设包括M3核心的外设，如NVIC、系统时钟(SysTick)等仍在运行调用WFI命令任意中断内核时钟关，对其他时钟和ADC时钟无影响无开睡眠模式内核停止，所有外设包括M3核心的外设，如NVIC、系统时钟(SysTick)等仍在运行调用WFE命令唤醒事件内核时钟关，对其他时钟和ADC时钟无影响无开停止模式所有的时钟都已停止配置PWR_CR寄存器的PDDS&#43;LPDS位&#43;SLEEPDEEP位&#43;WFI或WFE命令任意外部中断EXTI(在外部中断寄存器中设置)关闭所有1.8V区域的时钟HSI和HSE的振荡器关闭开启或处于低功耗模式(依据电源控制寄存器的设定)待机模式1.8V电源关闭配置PWR_CR寄存器的PDDS&#43;SLEEPDEEP位&#43;WFI或WFE命令WKUP上升沿、引脚的RTC闹钟事件、NRST引脚上的外部复位、IWDG复位关闭所有1.8V区域的时钟HSI和HSE的振荡器关闭关 1.1 睡眠模式 在睡眠模式中，仅关闭了内核时钟，内核停止运行，但其片上外设，CM3 核心的外设全都还照常运行。有两种方式进入睡眠模式，它的进入方式决定了从睡眠唤醒的方式，分别是 WFI(wait for interrupt) 和 WFE(wait for event)，即由等待“中断”唤醒和由“事件”唤醒。
特性和说明：
立即睡眠： 在执行 WFI 或 WFE 指令时立即进入睡眠模式。退出时睡眠： 在退出优先级最低的中断服务程序后才进入睡眠模式。进入方式： 内核寄存器的 SLEEPDEEP=0 ，然后调用 WFI 或 WFE 指令即可进入睡眠模式；SLEEPONEXIT=1 时，进入“退出时睡眠”模式。唤醒方式： 如果是使用 WFI 指令睡眠的，则可使用任意中断唤醒；如果是使用 WFE 指令睡眠的，则由事件唤醒。睡眠时： 关闭内核时钟，内核停止，而外设正常运行，在软件上表现为不再执行新的代码。这个状态会保留睡眠前的内核寄存器、内存的数据。唤醒延迟： 无延迟。唤醒后： 若由中断唤醒，先进入中断，退出中断服务程序后，接着执行 WFI 指令后的程序；若由事件唤醒，直接接着执行 WFE 后的程序。 1.2 停止模式 在停止模式中，进一步关闭了其它所有的时钟，于是所有的外设都停止了工作，但由于其 1.8V 区域的部分电源没有关闭，还保留了内核的寄存器、内存的信息，所以从停止模式唤醒，并重新开启时钟后，还可以从上次停止处继续执行代码。停止模式可以由任意一个外部中断(EXTI)唤醒，在停止模式中可以选择电压调节器为开模式或低功耗模式。
特性和说明：
调压器低功耗模式： 在停止模式下调压器可工作在正常模式或低功耗模式，可进一步降低功耗。进入方式： 内核寄存器的 SLEEPDEEP=1，PWR_CR 寄存器中的 PDDS=0，然后调用 WFI 或 WFE 指令即可进入停止模式；PWR_CR 寄存器的 LPDS=0 时，调压器工作在正常模式，LPDS=1 时工作在低功耗模式。唤醒方式： 如果是使用 WFI 指令睡眠的，可使用任意 EXTI 线的中断唤醒；如果是使用 WFE 指令睡眠的，可使用任意配置为事件模式的 EXTI 线事件唤醒。停止时： 内核停止，片上外设也停止。这个状态会保留停止前的内核寄存器、内存的数据。唤醒延迟： 基础延迟为 HSI 振荡器的启动时间，若调压器工作在低功耗模式，还需要加上调压器从低功耗切换至正常模式下的时间。唤醒后： 若由中断唤醒，先进入中断，退出中断服务程序后，接着执行 WFI 指令后的程序；若由事件唤醒，直接接着执行 WFE 后的程序。唤醒后，STM32 会使用 HSI 作为系统时钟。 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5a2920380508b0c07ddd4ff9b72a9e12/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-08T11:04:45+08:00" />
<meta property="article:modified_time" content="2021-03-08T11:04:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32CubeMX学习笔记（16）——电源管理(PWR)低功耗停止模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>一、低功耗模式简介</h2> 
<p>系统提供了多个低功耗模式，可在 CPU 不需要运行时（例如等待外部事件时）节省功耗。由用户根据应用选择具体的低功耗模式，以在低功耗、短启动时间和可用唤醒源之间寻求最佳平衡。</p> 
<p>睡眠模式、停止模式及待机模式中，若备份域电源正常供电，备份域内的 RTC 都可以正常运行，备份域内的寄存器的数据会被保存，不受功耗模式影响。</p> 
<blockquote> 
 <p>从表中可以看到，这三种低功耗模式层层递进，<strong>运行的时钟或芯片功能越来越少，因而功耗越来越低。</strong></p> 
</blockquote> 
<table><thead><tr><th>模式名称</th><th>说明</th><th>进入方式</th><th>唤醒方式</th><th>对1.8V区域时钟的影响</th><th>对VDD区域时钟的影响</th><th>调压器</th></tr></thead><tbody><tr><td>睡眠模式</td><td>内核停止，所有外设包括M3核心的外设，如NVIC、系统时钟(SysTick)等仍在运行</td><td>调用<code>WFI</code>命令</td><td>任意中断</td><td>内核时钟关，对其他时钟和ADC时钟无影响</td><td>无</td><td>开</td></tr><tr><td>睡眠模式</td><td>内核停止，所有外设包括M3核心的外设，如NVIC、系统时钟(SysTick)等仍在运行</td><td>调用<code>WFE</code>命令</td><td>唤醒事件</td><td>内核时钟关，对其他时钟和ADC时钟无影响</td><td>无</td><td>开</td></tr><tr><td>停止模式</td><td>所有的时钟都已停止</td><td>配置PWR_CR寄存器的<code>PDDS</code>+<code>LPDS</code>位+<code>SLEEPDEEP</code>位+<code>WFI</code>或<code>WFE</code>命令</td><td>任意外部中断<code>EXTI</code>(在外部中断寄存器中设置)</td><td>关闭所有1.8V区域的时钟</td><td>HSI和HSE的振荡器关闭</td><td>开启或处于低功耗模式(依据电源控制寄存器的设定)</td></tr><tr><td>待机模式</td><td>1.8V电源关闭</td><td>配置PWR_CR寄存器的<code>PDDS</code>+<code>SLEEPDEEP</code>位+<code>WFI</code>或<code>WFE</code>命令</td><td>WKUP上升沿、引脚的RTC闹钟事件、NRST引脚上的外部复位、IWDG复位</td><td>关闭所有1.8V区域的时钟</td><td>HSI和HSE的振荡器关闭</td><td>关</td></tr></tbody></table> 
<h3><a id="11__13"></a>1.1 睡眠模式</h3> 
<p>在睡眠模式中，仅关闭了内核时钟，内核停止运行，但其片上外设，CM3 核心的外设全都还照常运行。有两种方式进入睡眠模式，它的进入方式决定了从睡眠唤醒的方式，分别是 <strong>WFI(wait for interrupt)</strong> 和 <strong>WFE(wait for event)</strong>，即由等待“中断”唤醒和由“事件”唤醒。</p> 
<blockquote> 
 <p><strong>特性和说明：</strong></p> 
 <ul><li><strong>立即睡眠：</strong> 在执行 <code>WFI</code> 或 <code>WFE</code> 指令时立即进入睡眠模式。</li><li><strong>退出时睡眠：</strong> 在退出优先级最低的中断服务程序后才进入睡眠模式。</li><li><strong>进入方式：</strong> 内核寄存器的 <code>SLEEPDEEP=0</code> ，然后调用 <code>WFI</code> 或 <code>WFE</code> 指令即可进入睡眠模式；<code>SLEEPONEXIT=1</code> 时，进入“退出时睡眠”模式。</li><li><strong>唤醒方式：</strong> 如果是使用 <code>WFI</code> 指令睡眠的，则可使用任意中断唤醒；如果是使用 <code>WFE</code> 指令睡眠的，则由事件唤醒。</li><li><strong>睡眠时：</strong> 关闭内核时钟，内核停止，而外设正常运行，在软件上表现为不再执行新的代码。这个状态会保留睡眠前的内核寄存器、内存的数据。</li><li><strong>唤醒延迟：</strong> 无延迟。</li><li><strong>唤醒后：</strong> 若由中断唤醒，先进入中断，退出中断服务程序后，接着执行 <code>WFI</code> 指令后的程序；若由事件唤醒，直接接着执行 <code>WFE</code> 后的程序。</li></ul> 
</blockquote> 
<h3><a id="12__25"></a>1.2 停止模式</h3> 
<p>在停止模式中，进一步关闭了其它所有的时钟，于是所有的外设都停止了工作，但由于其 1.8V 区域的部分电源没有关闭，还保留了内核的寄存器、内存的信息，所以从停止模式唤醒，并重新开启时钟后，还可以从上次停止处继续执行代码。<strong>停止模式可以由任意一个外部中断(EXTI)唤醒</strong>，在停止模式中可以选择电压调节器为开模式或低功耗模式。</p> 
<blockquote> 
 <p><strong>特性和说明：</strong></p> 
 <ul><li><strong>调压器低功耗模式：</strong> 在停止模式下调压器可工作在正常模式或低功耗模式，可进一步降低功耗。</li><li><strong>进入方式：</strong> 内核寄存器的 <code>SLEEPDEEP=1</code>，PWR_CR 寄存器中的 <code>PDDS=0</code>，然后调用 <code>WFI</code> 或 <code>WFE</code> 指令即可进入停止模式；PWR_CR 寄存器的 <code>LPDS=0</code> 时，调压器工作在正常模式，<code>LPDS=1</code> 时工作在低功耗模式。</li><li><strong>唤醒方式：</strong> 如果是使用 <code>WFI</code> 指令睡眠的，可使用任意 EXTI 线的中断唤醒；如果是使用 <code>WFE</code> 指令睡眠的，可使用任意配置为事件模式的 EXTI 线事件唤醒。</li><li><strong>停止时：</strong> 内核停止，片上外设也停止。这个状态会保留停止前的内核寄存器、内存的数据。</li><li><strong>唤醒延迟：</strong> 基础延迟为 HSI 振荡器的启动时间，若调压器工作在低功耗模式，还需要加上调压器从低功耗切换至正常模式下的时间。</li><li><strong>唤醒后：</strong> 若由中断唤醒，先进入中断，退出中断服务程序后，接着执行 <code>WFI</code> 指令后的程序；若由事件唤醒，直接接着执行 <code>WFE</code> 后的程序。唤醒后，STM32 会使用 HSI 作为系统时钟。</li></ul> 
</blockquote> 
<h3><a id="13__36"></a>1.3 待机模式</h3> 
<p>待机模式，它除了关闭所有的时钟，还把 1.8V 区域的电源也完全关闭了，也就是说，从待机模式唤醒后，由于没有之前代码的运行记录，只能对芯片复位，重新检测 boot 条件，从头开始执行程序。<strong>它有四种唤醒方式，分别是 WKUP(PA0)引脚的上升沿，RTC 闹钟事件，NRST 引脚的复位和 IWDG(独立看门狗)复位。</strong></p> 
<blockquote> 
 <p><strong>特性和说明：</strong></p> 
 <ul><li><strong>进入方式：</strong> 内核寄存器的 <code>SLEEPDEEP=1</code>，PWR_CR 寄存器中的 <code>PDDS=1</code>，PWR_CR 寄存器中的唤醒状态位 <code>WUF=0</code>，然后调用 <code>WFI</code> 或 <code>WFE</code> 指令即可进入待机模式。</li><li><strong>唤醒方式：</strong> 通过 WKUP 引脚的上升沿，RTC 闹钟、唤醒、入侵、时间戳事件或 NRST 引脚外部复位及 IWDG 复位唤醒。</li><li><strong>待机时：</strong> 内核停止，片上外设也停止；内核寄存器、内存的数据会丢失；除复位引脚、RTC_AF1 引脚及 WKUP 引脚，其它 I/O 口均工作在高阻态。</li><li><strong>唤醒延迟：</strong> 芯片复位的时间。</li><li><strong>唤醒后：</strong> 相当于芯片复位，在程序表现为从头开始执行代码。</li></ul> 
</blockquote> 
<h3><a id="14_WFIWFE_46"></a>1.4 WFI与WFE命令</h3> 
<p>我们了解到进入各种低功耗模式时都需要调用 <code>WFI</code> 或 <code>WFE</code> 命令，它们实质上都是内核指令，在库文件 <code>core_cm3.h</code> 中把这些指令封装成了函数。</p> 
<pre><code class="prism language-cpp"><span class="token comment">/** brief 等待中断
  等待中断 是一个暂停执行指令
  暂停至任意中断产生后被唤醒
*/</span>
<span class="token macro property">#<span class="token directive keyword">define</span> __WFI        __wfi </span>

<span class="token comment">/** brief 等待事件
  等待事件 是一个暂停执行指令
  暂停至任意事件产生后被唤醒
*/</span>
<span class="token macro property">#<span class="token directive keyword">define</span> __WFE        __wfe</span>
</code></pre> 
<p>对于这两个指令，我们应用时一般只需要知道，调用它们都能进入低功耗模式，需要使用函数的格式“__WFI();”和“__WFE();”来调用(因为__wfi 及__wfe 是编译器内置的函数，函数内部调用了相应的汇编指令)。</p> 
<blockquote> 
 <p>其中 <code>WFI</code> 指令决定了它需要用中断唤醒，而 <code>WFE</code> 则决定了它可用事件来唤醒。</p> 
</blockquote> 
<h2><a id="_64"></a>二、新建工程</h2> 
<p><strong>1. 打开 STM32CubeMX 软件，点击“新建工程”</strong><br> <img src="https://images2.imgbox.com/cc/29/sL5s4WzK_o.png" alt=""></p> 
<p><strong>2. 选择 MCU 和封装</strong><br> <img src="https://images2.imgbox.com/a1/93/tPBSVr9K_o.png" alt=""></p> 
<p><strong>3. 配置时钟</strong><br> RCC 设置，选择 HSE(外部高速时钟) 为 Crystal/Ceramic Resonator(晶振/陶瓷谐振器)<br> <code>开启 LSE(外部低速时钟) 为 Crystal/Ceramic Resonator(晶振/陶瓷谐振器)</code><br> <img src="https://images2.imgbox.com/64/e0/BgohE66R_o.png" alt=""><br> 选择 Clock Configuration，配置系统时钟 SYSCLK 为 72MHz<br> 修改 HCLK 的值为 72 后，输入回车，软件会自动修改所有配置<br> <img src="https://images2.imgbox.com/ce/12/gl9i0PCH_o.png" alt=""></p> 
<p><strong>4. 配置调试模式</strong><br> <strong>非常重要的一步，否则会造成第一次烧录程序后续无法识别调试器</strong><br> SYS 设置，选择 Debug 为 Serial Wire<br> <img src="https://images2.imgbox.com/b6/0a/jPvDUxwB_o.png" alt=""></p> 
<h2><a id="_85"></a>三、停止模式</h2> 
<h3><a id="31_WFI_86"></a>3.1 WFI按键外部中断唤醒</h3> 
<h4><a id="311__87"></a>3.1.1 流程图</h4> 
<p><img src="https://images2.imgbox.com/a1/ee/Hfqu8jnX_o.png" alt=""></p> 
<h4><a id="312_HAL_89"></a>3.1.2 HAL库与标准库代码比较</h4> 
<p>STM32CubeMX 使用 HAL 库的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    ···
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        ···
        <span class="token comment">// 暂停滴答时钟，防止通过滴答时钟中断唤醒</span>
        <span class="token function">HAL_SuspendTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* 进入停止模式，设置电压调节器为低功耗模式，等待中断唤醒 */</span>
        <span class="token function">HAL_PWR_EnterSTOPMode</span><span class="token punctuation">(</span>PWR_MAINREGULATOR_ON<span class="token punctuation">,</span>PWR_STOPENTRY_WFI<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">SYSCLKConfig_STOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 被唤醒后，恢复滴答时钟</span>
        <span class="token function">HAL_ResumeTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ···
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">SYSCLKConfig_STOP</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    RCC_ClkInitTypeDef RCC_ClkInitStruct <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    RCC_OscInitTypeDef RCC_OscInitStruct <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">uint32_t</span> pFLatency <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   
    <span class="token comment">/* 启用电源控制时钟 */</span>
    <span class="token function">__HAL_RCC_PWR_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">/* 根据内部 RCC 寄存器获取振荡器配置 */</span>
    <span class="token function">HAL_RCC_GetOscConfig</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>RCC_OscInitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">/* 从停止模式唤醒后重新配置系统时钟: 启用 HSE 和 PLL */</span>
    RCC_OscInitStruct<span class="token punctuation">.</span>OscillatorType <span class="token operator">=</span> RCC_OSCILLATORTYPE_HSE<span class="token punctuation">;</span>
    RCC_OscInitStruct<span class="token punctuation">.</span>HSEState <span class="token operator">=</span> RCC_HSE_ON<span class="token punctuation">;</span>
    RCC_OscInitStruct<span class="token punctuation">.</span>PLL<span class="token punctuation">.</span>PLLState <span class="token operator">=</span> RCC_PLL_ON<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">HAL_RCC_OscConfig</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>RCC_OscInitStruct<span class="token punctuation">)</span> <span class="token operator">!=</span> HAL_OK<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 根据内部 RCC 寄存器获取时钟配置 */</span>
    <span class="token function">HAL_RCC_GetClockConfig</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>RCC_ClkInitStruct<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pFLatency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 选择 PLL 作为系统时钟源, 并配置 HCLK、PCLK1 和 PCLK2 时钟分频系数 */</span>
    RCC_ClkInitStruct<span class="token punctuation">.</span>ClockType <span class="token operator">=</span> RCC_CLOCKTYPE_SYSCLK<span class="token punctuation">;</span>
    RCC_ClkInitStruct<span class="token punctuation">.</span>SYSCLKSource <span class="token operator">=</span> RCC_SYSCLKSOURCE_PLLCLK<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">HAL_RCC_ClockConfig</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>RCC_ClkInitStruct<span class="token punctuation">,</span> pFLatency<span class="token punctuation">)</span> <span class="token operator">!=</span> HAL_OK<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{<!-- --></span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用 STM32 标准库的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    ···
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        ···
        <span class="token comment">/* 进入停止模式，设置电压调节器为低功耗模式，等待中断唤醒 */</span>
        <span class="token function">PWR_EnterSTOPMode</span><span class="token punctuation">(</span>PWR_Regulator_LowPower<span class="token punctuation">,</span>PWR_STOPEntry_WFI<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 从停止模式下被唤醒后使用的是 HSI 时钟，此处重启 HSE 时钟,使用 PLLCLK</span>
        <span class="token function">SYSCLKConfig_STOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ···
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">SYSCLKConfig_STOP</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* 停机唤醒后配置系统时钟 */</span>
    <span class="token comment">/* 使能 HSE */</span>
    <span class="token function">RCC_HSEConfig</span><span class="token punctuation">(</span>RCC_HSE_ON<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">/* 等待 HSE 准备就绪 */</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">RCC_GetFlagStatus</span><span class="token punctuation">(</span>RCC_FLAG_HSERDY<span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token comment">/* 使能 PLL */</span>
    <span class="token function">RCC_PLLCmd</span><span class="token punctuation">(</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token comment">/* 等待 PLL 准备就绪 */</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">RCC_GetFlagStatus</span><span class="token punctuation">(</span>RCC_FLAG_PLLRDY<span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token comment">/* 选择 PLL 作为系统时钟源 */</span>
    <span class="token function">RCC_SYSCLKConfig</span><span class="token punctuation">(</span>RCC_SYSCLKSource_PLLCLK<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">/* 等待 PLL 被选择为系统时钟源 */</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">RCC_GetSYSCLKSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0x08</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="313__183"></a>3.1.3 添加按键</h4> 
<p>初始化按键 <code>PA0</code> 中断模式，以便当系统进入睡眠模式的时候可以通过按键来唤醒。<br> 查看 <a href="https://blog.csdn.net/qq_36347513/article/details/112508465">STM32CubeMX学习笔记（3）——EXTI(外部中断)接口使用</a></p> 
<h4><a id="314_LED_186"></a>3.1.4 添加LED灯</h4> 
<p>添加绿灯 <code>PB0</code> 表示运行状态，红灯 <code>PB5</code> 表示睡眠状态，蓝灯 <code>PB1</code> 表示刚从睡眠状态中被唤醒。<br> 查看 <a href="https://blog.csdn.net/qq_36347513/article/details/112464598">STM32CubeMX学习笔记（2）——GPIO接口使用</a></p> 
<h4><a id="315__189"></a>3.1.5 添加串口打印</h4> 
<p>添加 <code>USART1</code> 用于打印信息。<br> 查看 <a href="https://blog.csdn.net/qq_36347513/article/details/112654724?spm=1001.2014.3001.5501">STM32CubeMX学习笔记（6）——USART串口使用</a></p> 
<h4><a id="316__192"></a>3.1.6 生成代码</h4> 
<p>输入项目名和项目路径<br> <img src="https://images2.imgbox.com/6b/0c/sECZywlW_o.png" alt=""><br> 选择应用的 IDE 开发环境 MDK-ARM V5<br> <img src="https://images2.imgbox.com/b4/0d/srwM3ZKw_o.png" alt=""><br> 每个外设生成独立的 <code>’.c/.h’</code> 文件<br> 不勾：所有初始化代码都生成在 main.c<br> 勾选：初始化代码生成在对应的外设文件。 如 GPIO 初始化代码生成在 gpio.c 中。<br> <img src="https://images2.imgbox.com/3f/b4/6b9hucih_o.png" alt=""><br> 点击 GENERATE CODE 生成代码<br> <img src="https://images2.imgbox.com/cc/76/to7B5q0i_o.png" alt=""></p> 
<h4><a id="317__203"></a>3.1.7 修改中断回调函数</h4> 
<blockquote> 
 <p>当系统进入停止状态后，我们按下实验板上的 KEY1 按键，即可使系统回到正常运行的状态，当执行完中断服务函数后，会继续执行 <code>WFI</code> 指令后的代码。</p> 
</blockquote> 
<p>打开 <code>stm32f1xx_it.c</code> 中断服务函数文件，找到 EXTI0 中断的服务函数 <code>EXTI0_IRQHandler()</code><br> 中断服务函数里面就调用了 GPIO 外部中断处理函数 <code>HAL_GPIO_EXTI_IRQHandler()</code><br> <img src="https://images2.imgbox.com/c9/7b/i9Gfna9H_o.png" alt=""><br> 打开 <code>stm32f1xx_hal_gpio.c</code> 文件，找到外部中断处理函数原型 <code>HAL_GPIO_EXTI_IRQHandler()</code>，其主要作用就是判断是几号线中断，清除中断标识位，然后调用中断回调函数 <code>HAL_GPIO_EXTI_Callback()</code>。<br> <img src="https://images2.imgbox.com/24/ff/AHx6GAxJ_o.png" alt=""></p> 
<blockquote> 
 <p>/* NOTE: This function Should not be modified, when the callback is needed,<br> the HAL_GPIO_EXTI_Callback could be implemented in the user file<br> */<br> 这个函数不应该被改变，如果需要使用回调函数，请重新在用户文件中实现该函数。</p> 
</blockquote> 
<p><code>HAL_GPIO_EXTI_Callback()</code> 按照官方提示我们应该再次定义该函数，<code>__weak</code> 是一个弱化标识，带有这个的函数就是一个弱化函数，就是你可以在其他地方写一个名称和参数都一模一样的函数，编译器就会忽略这一个函数，而去执行你写的那个函数；而 <code>UNUSED(GPIO_Pin)</code> ，这就是一个防报错的定义，当传进来的GPIO端口号没有做任何处理的时候，编译器也不会报出警告。其实我们在开发的时候已经不需要去理会中断服务函数了，只需要找到这个中断回调函数并将其重写即可而这个回调函数还有一点非常便利的地方这里没有体现出来，就是当同时有多个中断使能的时候，STM32CubeMX会自动地将几个中断的服务函数规整到一起并调用一个回调函数，也就是无论几个中断，我们只需要重写一个回调函并判断传进来的端口号即可。</p> 
<p>接下来我们就在 <code>stm32f1xx_it.c</code> 这个文件的最下面添加 <code>HAL_GPIO_EXTI_Callback()</code></p> 
<pre><code class="prism language-cpp"><span class="token comment">/* USER CODE BEGIN 1 */</span>
<span class="token keyword">void</span> <span class="token function">HAL_GPIO_EXTI_Callback</span><span class="token punctuation">(</span><span class="token keyword">uint16_t</span> GPIO_Pin<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 亮蓝灯</span>
    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_B_Pin<span class="token punctuation">,</span> GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 1 */</span>
</code></pre> 
<h4><a id="318_main_230"></a>3.1.8 修改main函数</h4> 
<blockquote> 
 <p>初始化完成后使用 LED 及串口表示运行状态，LED 灯为绿色时表示正常运行，红灯时表示停止状态，蓝灯时表示刚从停止状态中被唤醒。在停止模式下，I/O 口会保持停止前的状态，所以 LED 彩灯在停止模式时也会保持亮红灯。</p> 
 <p>程序执行一段时间后，调用库函数 <code>HAL_PWR_EnterSTOPMode</code> 把调压器设置在低功耗模式，进入停止状态。由于 <code>WFI</code> 停止模式可以使用任意 EXTI 的中断唤醒，所以我们可以使用按键中断唤醒。</p> 
 <p>当系统进入停止状态后，我们按下实验板上的 KEY1 按键，即可唤醒系统，当执行完中断服务函数后，会继续执行 <code>HAL_PWR_EnterSTOPMode</code> 函数后的代码。</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">/**
  * @brief  The application entry point.
  * @retval int
  */</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN 1 */</span>
  <span class="token keyword">uint32_t</span> SYSCLK_Frequency <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> HCLK_Frequency <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> PCLK1_Frequency <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> PCLK2_Frequency <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> SYSCLK_Source <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE END 1 */</span>

  <span class="token comment">/* MCU Configuration--------------------------------------------------------*/</span>

  <span class="token comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN Init */</span>

  <span class="token comment">/* USER CODE END Init */</span>

  <span class="token comment">/* Configure the system clock */</span>
  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN SysInit */</span>

  <span class="token comment">/* USER CODE END SysInit */</span>

  <span class="token comment">/* Initialize all configured peripherals */</span>
  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN 2 */</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"stop mode test\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN 2 */</span>
  
  <span class="token comment">/* USER CODE END 2 */</span>

  <span class="token comment">/* Infinite loop */</span>
  <span class="token comment">/* USER CODE BEGIN WHILE */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 使用绿灯指示，运行状态</span>
    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_G_Pin<span class="token punctuation">,</span> GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_G_Pin<span class="token punctuation">,</span> GPIO_PIN_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 任务执行完毕，进入睡眠降低功耗</span>

    <span class="token comment">// 使用红灯指示，进入停止状态</span>
    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_R_Pin<span class="token punctuation">,</span> GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 暂停滴答时钟，防止通过滴答时钟中断唤醒</span>
    <span class="token function">HAL_SuspendTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使能PWR时钟</span>
    <span class="token function">__HAL_RCC_PWR_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 清除唤醒标记</span>
    <span class="token function">__HAL_PWR_CLEAR_FLAG</span><span class="token punctuation">(</span>PWR_FLAG_WU<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 进入停止模式</span>
    <span class="token function">HAL_PWR_EnterSTOPMode</span><span class="token punctuation">(</span>PWR_LOWPOWERREGULATOR_ON<span class="token punctuation">,</span> PWR_STOPENTRY_WFI<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_R_Pin<span class="token punctuation">,</span> GPIO_PIN_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 刚从STOP模式唤醒时钟默认使用内部高速8M时钟，所以需要重新配置时钟</span>
    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 被唤醒后，恢复滴答时钟</span>
    <span class="token function">HAL_ResumeTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取重新配置后的时钟状态</span>
    SYSCLK_Frequency <span class="token operator">=</span> <span class="token function">HAL_RCC_GetSysClockFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    HCLK_Frequency <span class="token operator">=</span> <span class="token function">HAL_RCC_GetHCLKFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    PCLK1_Frequency <span class="token operator">=</span> <span class="token function">HAL_RCC_GetPCLK1Freq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    PCLK2_Frequency <span class="token operator">=</span> <span class="token function">HAL_RCC_GetPCLK2Freq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    SYSCLK_Source <span class="token operator">=</span> <span class="token function">__HAL_RCC_GET_SYSCLK_SOURCE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 重新配置时钟源后始终状态</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\r\n 重新配置后的时钟状态：\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" SYSCLK 频率:%d,\r\n HCLK 频率:%d,\r\n PCLK1 频率:%d,\r\n PCLK2 频率:%d,\r\n 时钟源:%d (0 表示 HSI，8 表示 PLLCLK)\n"</span><span class="token punctuation">,</span>SYSCLK_Frequency<span class="token punctuation">,</span>HCLK_Frequency<span class="token punctuation">,</span>PCLK1_Frequency<span class="token punctuation">,</span>PCLK2_Frequency<span class="token punctuation">,</span>SYSCLK_Source<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_B_Pin<span class="token punctuation">,</span> GPIO_PIN_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE END WHILE */</span>

    <span class="token comment">/* USER CODE BEGIN 3 */</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE END 3 */</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="32_RTC_322"></a>3.2 RTC时钟唤醒</h3> 
<h4><a id="321_RTC_323"></a>3.2.1 添加RTC时钟</h4> 
<p>查看 <a href="https://blog.csdn.net/qq_36347513/article/details/113663264?spm=1001.2014.3001.5501">STM32CubeMX学习笔记（14）——RTC实时时钟使用</a></p> 
<h4><a id="312_LED_325"></a>3.1.2 添加LED灯</h4> 
<p>添加绿灯 <code>PB0</code> 表示运行状态，红灯 <code>PB5</code> 表示睡眠状态，蓝灯 <code>PB1</code> 表示刚从睡眠状态中被唤醒。<br> 查看 <a href="https://blog.csdn.net/qq_36347513/article/details/112464598">STM32CubeMX学习笔记（2）——GPIO接口使用</a></p> 
<h4><a id="313__328"></a>3.1.3 添加串口打印</h4> 
<p>添加 <code>USART1</code> 用于打印信息。<br> 查看 <a href="https://blog.csdn.net/qq_36347513/article/details/112654724?spm=1001.2014.3001.5501">STM32CubeMX学习笔记（6）——USART串口使用</a></p> 
<h4><a id="324_RTC_331"></a>3.2.4 使能RTC闹钟中断</h4> 
<p><img src="https://images2.imgbox.com/90/81/5s8TjNyz_o.png" alt=""></p> 
<h4><a id="325__333"></a>3.2.5 生成代码</h4> 
<p>输入项目名和项目路径<br> <img src="https://images2.imgbox.com/de/fe/p7qL4oyV_o.png" alt=""><br> 选择应用的 IDE 开发环境 MDK-ARM V5<br> <img src="https://images2.imgbox.com/41/bb/AgeBlgUE_o.png" alt=""><br> 每个外设生成独立的 <code>’.c/.h’</code> 文件<br> 不勾：所有初始化代码都生成在 main.c<br> 勾选：初始化代码生成在对应的外设文件。 如 GPIO 初始化代码生成在 gpio.c 中。<br> <img src="https://images2.imgbox.com/7e/23/Q984R1qm_o.png" alt=""><br> 点击 GENERATE CODE 生成代码<br> <img src="https://images2.imgbox.com/d3/1a/oJgGWASS_o.png" alt=""></p> 
<h4><a id="326__344"></a>3.2.6 修改中断回调函数</h4> 
<p>打开 <code>stm32f1xx_it.c</code> 中断服务函数文件，找到 RTC 闹钟中断的服务函数 <code>RTC_Alarm_IRQHandler()</code><br> 中断服务函数里面就调用了 RTC 闹钟中断处理函数 <code>HAL_RTC_AlarmIRQHandler()</code><br> <img src="https://images2.imgbox.com/2a/dd/t8YEp4In_o.png" alt=""></p> 
<p>打开 <code>stm32f1xx_hal_rtc.c</code> 文件，找到RTC闹钟中断处理函数原型 <code>HAL_RTC_AlarmIRQHandler()</code>，其主要作用就是判断是否RTC中断，清除中断标识位，然后调用中断回调函数 <code>HAL_RTC_AlarmAEventCallback()</code>。<br> <img src="https://images2.imgbox.com/ba/c9/3jhr75RP_o.png" alt=""></p> 
<blockquote> 
 <p>/* NOTE: This function Should not be modified, when the callback is needed,<br> theHAL_RTC_AlarmAEventCallback could be implemented in the user file<br> */<br> 这个函数不应该被改变，如果需要使用回调函数，请重新在用户文件中实现该函数。</p> 
</blockquote> 
<p><code>HAL_RTC_AlarmAEventCallback()</code> 按照官方提示我们应该再次定义该函数，<code>__weak</code> 是一个弱化标识，带有这个的函数就是一个弱化函数，就是你可以在其他地方写一个名称和参数都一模一样的函数，编译器就会忽略这一个函数，而去执行你写的那个函数；而 <code>UNUSED(hrtc)</code> ，这就是一个防报错的定义，当传进来的RTC号没有做任何处理的时候，编译器也不会报出警告。其实我们在开发的时候已经不需要去理会中断服务函数了，只需要找到这个中断回调函数并将其重写即可而这个回调函数还有一点非常便利的地方这里没有体现出来，就是当同时有多个中断使能的时候，STM32CubeMX会自动地将几个中断的服务函数规整到一起并调用一个回调函数，也就是无论几个中断，我们只需要重写一个回调函并判断传进来的端口号即可。</p> 
<p>接下来我们就在 <code>stm32f1xx_it.c</code> 这个文件的最下面添加 <code>HAL_RTC_AlarmAEventCallback()</code></p> 
<pre><code class="prism language-cpp"><span class="token comment">/* USER CODE BEGIN 1 */</span>
<span class="token keyword">void</span> <span class="token function">HAL_RTC_AlarmAEventCallback</span><span class="token punctuation">(</span>RTC_HandleTypeDef <span class="token operator">*</span>hrtc<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// STOP模式唤醒后默认时钟主频为内部8M时钟，所以要先初始化时钟配置</span>
    <span class="token comment">// 亮蓝灯</span>
    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_B_Pin<span class="token punctuation">,</span> GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3s时间到，唤醒！\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 1 */</span>
</code></pre> 
<h4><a id="327_RTC_371"></a>3.2.7 添加RTC闹钟中断启动函数</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">RTC_AlarmStart</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    RTC_AlarmTypeDef sAlarm <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    RTC_TimeTypeDef tim <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 获取当前时间</span>
    <span class="token function">HAL_RTC_GetTime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hrtc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tim<span class="token punctuation">,</span> RTC_FORMAT_BIN<span class="token punctuation">)</span><span class="token punctuation">;</span>

    sAlarm<span class="token punctuation">.</span>AlarmTime<span class="token punctuation">.</span>Hours <span class="token operator">=</span> tim<span class="token punctuation">.</span>Hours<span class="token punctuation">;</span>
    sAlarm<span class="token punctuation">.</span>AlarmTime<span class="token punctuation">.</span>Minutes <span class="token operator">=</span> tim<span class="token punctuation">.</span>Minutes<span class="token punctuation">;</span>
    sAlarm<span class="token punctuation">.</span>AlarmTime<span class="token punctuation">.</span>Seconds <span class="token operator">=</span> tim<span class="token punctuation">.</span>Seconds <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment">/* 设置下次闹钟提醒时间是当前时间的3s之后 */</span>
    sAlarm<span class="token punctuation">.</span>Alarm <span class="token operator">=</span> RTC_ALARM_A<span class="token punctuation">;</span>

    <span class="token comment">// 启动闹钟中断事件</span>
    <span class="token function">HAL_RTC_SetAlarm_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hrtc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sAlarm<span class="token punctuation">,</span> RTC_FORMAT_BIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="328_main_391"></a>3.2.8 修改main函数</h4> 
<blockquote> 
 <p>初始化完成后使用 LED 及串口表示运行状态，LED 灯为绿色时表示正常运行，红灯时表示停止状态，蓝灯时表示刚从停止状态中被唤醒。在停止模式下，I/O 口会保持停止前的状态，所以 LED 彩灯在停止模式时也会保持亮红灯。</p> 
</blockquote> 
<blockquote> 
 <p>程序执行一段时间后，调用库函数 HAL_PWR_EnterSTOPMode 把调压器设置在低功耗模式，进入停止状态。由于 WFI 停止模式可以使用任意 EXTI 的中断唤醒，所以我们可以使用RTC闹钟中断唤醒。</p> 
</blockquote> 
<blockquote> 
 <p>当系统进入停止状态后，隔 3 秒后闹钟唤醒系统，当执行完中断服务函数后，会继续执行 HAL_PWR_EnterSTOPMode 函数后的代码。</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">/**
  * @brief  The application entry point.
  * @retval int
  */</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN 1 */</span>
  <span class="token keyword">uint32_t</span> SYSCLK_Frequency <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> HCLK_Frequency <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> PCLK1_Frequency <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> PCLK2_Frequency <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> SYSCLK_Source <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE END 1 */</span>

  <span class="token comment">/* MCU Configuration--------------------------------------------------------*/</span>

  <span class="token comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN Init */</span>

  <span class="token comment">/* USER CODE END Init */</span>

  <span class="token comment">/* Configure the system clock */</span>
  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN SysInit */</span>

  <span class="token comment">/* USER CODE END SysInit */</span>

  <span class="token comment">/* Initialize all configured peripherals */</span>
  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN 2 */</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"stop mode test\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN 2 */</span>
  
  <span class="token comment">/* USER CODE END 2 */</span>

  <span class="token comment">/* Infinite loop */</span>
  <span class="token comment">/* USER CODE BEGIN WHILE */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 使用绿灯指示，运行状态</span>
    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_G_Pin<span class="token punctuation">,</span> GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_G_Pin<span class="token punctuation">,</span> GPIO_PIN_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 任务执行完毕，进入睡眠降低功耗</span>

    <span class="token comment">// 使用红灯指示，进入停止状态</span>
    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_R_Pin<span class="token punctuation">,</span> GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 暂停滴答时钟，防止通过滴答时钟中断唤醒</span>
    <span class="token function">HAL_SuspendTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 配置下次唤醒的闹钟时间</span>
    <span class="token function">RTC_AlarmStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使能PWR时钟</span>
    <span class="token function">__HAL_RCC_PWR_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 清除唤醒标记</span>
    <span class="token function">__HAL_PWR_CLEAR_FLAG</span><span class="token punctuation">(</span>PWR_FLAG_WU<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 进入停止模式</span>
    <span class="token function">HAL_PWR_EnterSTOPMode</span><span class="token punctuation">(</span>PWR_LOWPOWERREGULATOR_ON<span class="token punctuation">,</span> PWR_STOPENTRY_WFI<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_R_Pin<span class="token punctuation">,</span> GPIO_PIN_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 被唤醒后，恢复滴答时钟</span>
    <span class="token function">HAL_ResumeTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取重新配置后的时钟状态</span>
    SYSCLK_Frequency <span class="token operator">=</span> <span class="token function">HAL_RCC_GetSysClockFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    HCLK_Frequency <span class="token operator">=</span> <span class="token function">HAL_RCC_GetHCLKFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    PCLK1_Frequency <span class="token operator">=</span> <span class="token function">HAL_RCC_GetPCLK1Freq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    PCLK2_Frequency <span class="token operator">=</span> <span class="token function">HAL_RCC_GetPCLK2Freq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    SYSCLK_Source <span class="token operator">=</span> <span class="token function">__HAL_RCC_GET_SYSCLK_SOURCE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 重新配置时钟源后始终状态</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\r\n 重新配置后的时钟状态：\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" SYSCLK 频率:%d,\r\n HCLK 频率:%d,\r\n PCLK1 频率:%d,\r\n PCLK2 频率:%d,\r\n 时钟源:%d (0 表示 HSI，8 表示 PLLCLK)\n"</span><span class="token punctuation">,</span>SYSCLK_Frequency<span class="token punctuation">,</span>HCLK_Frequency<span class="token punctuation">,</span>PCLK1_Frequency<span class="token punctuation">,</span>PCLK2_Frequency<span class="token punctuation">,</span>SYSCLK_Source<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> LED_B_Pin<span class="token punctuation">,</span> GPIO_PIN_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE END WHILE */</span>

    <span class="token comment">/* USER CODE BEGIN 3 */</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE END 3 */</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_483"></a>四、注意事项</h2> 
<blockquote> 
 <p><strong>用户代码要加在 <code>USER CODE BEGIN N</code> 和 <code>USER CODE END N</code> 之间，否则下次使用 STM32CubeMX 重新生成代码后，会被删除。</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d2/53/lzqv9HJu_o.png" alt=""></p> 
<blockquote> 
 <p>进入低功耗之前可以将引脚全部配置为浮空输入或者Anglog模式，这样最省电，如果你是用STM32CUBEMX，在这里可以看到这么一项配置就是将没有用到的引脚配置为了Anglog模式：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8a/94/4dlyj8pd_o.png" alt=""></p> 
<blockquote> 
 <p>当系统处于睡眠模式低功耗状态时(包括后面讲解的停止模式及待机模式)，使用 DAP 下载器是无法给芯片下载程序的，所以下载程序时要先把系统唤醒。或者使用如下方法：按着板子的复位按键，使系统处于复位状态，然后点击电脑端的下载按钮下载程序，这时再释放复位按键，就能正常给板子下载程序了。</p> 
</blockquote> 
<hr> 
<p>• 由 <a href="https://blog.csdn.net/qq_36347513">Leung</a> 写于 2021 年 3 月 8 日</p> 
<p>• 参考：<a href="https://www.waveshare.net/study/article-653-1.html" rel="nofollow">STM32CubeMX系列教程14:电源控制器(PWR)</a><br> 　　　　<a href="https://blog.csdn.net/sudaroot/article/details/85626218?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161458919816780274173285%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161458919816780274173285&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-85626218.pc_search_result_hbase_insert&amp;utm_term=stm32cubemx+%E7%94%B5%E6%BA%90%E4%BD%8E%E5%8A%9F%E8%80%97">STM32MX电源管理低功耗模式</a><br> 　　　　<a href="https://blog.csdn.net/qq153471503/article/details/111868286?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161458919816780274173285%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161458919816780274173285&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-20-111868286.pc_search_result_hbase_insert&amp;utm_term=stm32cubemx+%E7%94%B5%E6%BA%90%E4%BD%8E%E5%8A%9F%E8%80%97">STM32F1系列使用HAL库低功耗STOP和STANDBY模式唤醒（RTC时钟唤醒+外部中断唤醒示例）</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0dc183462b2e1a8e88262cc4a3aa81fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux之Netem模块</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c24dfa5156cc79239580c584cf677d36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android APP开发入门教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>