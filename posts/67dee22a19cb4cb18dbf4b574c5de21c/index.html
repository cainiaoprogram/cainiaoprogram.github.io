<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java当前时间转化毫秒_Java学习笔记day08 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java当前时间转化毫秒_Java学习笔记day08" />
<meta property="og:description" content="Object类
java.lang.Object
类Object是类层次结构的根类
每个类都使用Object作为 超(父)类
所有对象（包括数组）都实现这个类的方法
Object类的toString方法
任何一个类都是从Object类继承下来的，因此在任何一个类里面都可以重写这个toString()方法。toString()方法的作用是当一个引用对象和字符串作连接的时候，或者是直接打印这个引用对象的时侯，这个引用对象都会自动调用toString()方法，通过这个方法返回一个表示引用对象自己正常信息的字符串，而这个字符串的内容由我们自己去定义，默认的字符串内容是“类名&#43;哈希编码”
Object类的equals方法
Person类默认继承了Object类，所以使用Object类的equals方法
boolean equals(Object obj) 指示其他某个对象是否与此对象相等
equals方法源码：
public boolean equals(Object obj) {
return (this == obj);
}
参数：
Object obj;可以传递任意的对象
== 比较运算符，返回的是一个布尔值 true false
基本数据类型：比较的是值
引用数据类型：比较的是两个对象的地址值
this是谁？哪个对象调用的方法，方法中的this就是那个对象：p1调用的equals方法所以this就是p1
obj：传递过来的参数p2
this == obj --&gt;p1 == p2毫秒值
java.util.Date:表示日期和时间的类
类 Date 表示特定的瞬间，精确到毫秒
毫秒：千分之一秒 1000毫秒=1秒
毫秒值作用：可以对时间进行计算
把日期转换为毫秒：
当前的日期：2088-01-01
时间原点（0毫秒）：1970-01-01 00:00:00
就是计算当前日期到时间远点之间一共经历了多少毫秒
Date类的构造方法和成员方法
import java.util.Date; public class Demo02Date { public static void main(String[] args) { demo01(); demo02(); demo03(); } /* long getTime() 把日期转换成为毫秒值（相当于currentTimeMillis()） 返回自1970." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/67dee22a19cb4cb18dbf4b574c5de21c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-03T06:29:00+08:00" />
<meta property="article:modified_time" content="2021-01-03T06:29:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java当前时间转化毫秒_Java学习笔记day08</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/ab/61/KtQDtEOS_o.png" alt="5303ab1108314a931407f16cd363508b.png"> 
 </div> 
 <p><b>Object类</b></p> 
 <p>java.lang.Object<br> 类Object是类层次结构的根类<br> 每个类都使用Object作为 超(父)类<br> 所有对象（包括数组）都实现这个类的方法</p> 
 <p><b>Object类的toString方法</b></p> 
 <p>任何一个类都是从Object类继承下来的，因此在任何一个类里面都可以重写这个toString()方法。toString()方法的作用是当一个引用对象和字符串作连接的时候，或者是直接打印这个引用对象的时侯，这个引用对象都会自动调用toString()方法，通过这个方法返回一个表示引用对象自己正常信息的字符串，而这个字符串的内容由我们自己去定义，默认的字符串内容是“类名+哈希编码”</p> 
 <p><b>Object类的equals方法</b><br> Person类默认继承了Object类，所以使用Object类的equals方法<br> boolean equals(Object obj) 指示其他某个对象是否与此对象相等<br> equals方法源码：<br> public boolean equals(Object obj) {<!-- --><br> return (this == obj);<br> }<br> 参数：<br> Object obj;可以传递任意的对象<br> == 比较运算符，返回的是一个布尔值 true false<br> 基本数据类型：比较的是值<br> 引用数据类型：比较的是两个对象的地址值<br> this是谁？哪个对象调用的方法，方法中的this就是那个对象：p1调用的equals方法所以this就是p1<br> obj：传递过来的参数p2<br> this == obj --&gt;p1 == p2<b>毫秒值</b></p> 
 <p>java.util.Date:表示日期和时间的类<br> 类 Date 表示特定的瞬间，精确到毫秒<br> 毫秒：千分之一秒 1000毫秒=1秒<br> 毫秒值作用：可以对时间进行计算<br> 把日期转换为毫秒：<br> 当前的日期：2088-01-01<br> 时间原点（0毫秒）：1970-01-01 00:00:00<br> 就是计算当前日期到时间远点之间一共经历了多少毫秒</p> 
 <p><b>Date类的构造方法和成员方法</b></p> 
 <div class="has"> 
  <pre class="has"><code>import java.util.Date;

public class Demo02Date {<!-- -->
    public static void main(String[] args) {<!-- -->
        demo01();
        demo02();
        demo03();
    }
    /*
        long getTime() 把日期转换成为毫秒值（相当于currentTimeMillis()）
        返回自1970.01.01 GMT 以来此Date 对象表示的毫秒数）
     */
    private static void demo03() {<!-- -->
        Date date = new Date();
        long time = date.getTime();
        System.out.println(time);
    }

   /*
        Date类的带参数构造方法
        Date(long date):传递毫秒值，把毫秒l值转换为date日期
     */
    private static void demo02() {<!-- -->
        Date date = new Date(24324234242388l);
        System.out.println(date);
    }
/*
    Date类的空参数构造方法
    Date（）获取当前系统时间
 */
    private static void demo01 () {<!-- -->
        Date date = new Date();
        System.out.println(date);
    }
}</code></pre> 
 </div> 
 <p><b>DateFormat类</b></p> 
 <p>java.text.DateFormat:是日期/时间格式化子类的抽象类<br> 作用：<br> 格式化（也就是日期 -&gt; 文本）、解析（文本 -&gt; 日期）<br> 成员方法：<br> String format(Date date) 按照指定的模式，把Date的日期格式化为符合模式的字符串<br> Date parse(String source) 把符合模式的字符串，解析为Date日期<br> DateFormat类是一个抽象类，无法直接创建对象使用，可以使用DateFormat类的子类<br> java.text.SimpleDateFormat extends DateFormat<br> 构造方法<br> SimpleDateFormat(String pattern)<br> 用给定的模式和默认语言环境的日期格式符合构造 SimpleDateFormat<br> 参数：<br> String pattern：传递指定模式<br> 模式：区分大小写<br> y 年<br> M 月<br> d 天<br> H 时<br> m 分<br> s 秒<br> 写对应的模式，会把模式替换为对应的日期时间<br> ”yyyy-MM-dd HH:mm:ss“<br> 注意：<br> 联结符号可以改字母不能改</p> 
 <p><b>DateFormat类中的format方法和parse方法</b></p> 
 <div class="has"> 
  <pre class="has"><code>public class Demo01DateFormat {<!-- -->
    public static void main(String[] args) throws ParseException {<!-- -->
        demo01();
        demo02();
    }
    /*
        使用DateFormat类中的方法format，把日期转化为文本
        步骤：
            1.创建SimpleDateFormat对象，构造方法中传递指定的模式
            2.调用SimpleDateFormat对象中的方法format，按照构造方法中指定的模式
            把Date日期格式化为符合模式的字符串
     */
    private static void demo01() {<!-- -->
        //创建SDF对象，构造放大中传递指定的模式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
        //调用SDF对象中的方法format，按照构造方法中指定的模式，把Date日期格式化为符合模式的字符串（文本）
        //String format(Date date) 按照指定的模式，把Date日期，格式化为符合模式的字符串
        Date date = new Date();
        String d = sdf.format(date);

        System.out.println(date);//Sat Aug 08 14:19:58 CST 2020
        System.out.println(d);//2020/8/8 下午2:19
    }
    /*
        使用DateFormat类中的方法parse，把文本解析为日期
        步骤：
            1.创建SDF对象，构造方法中床底指定的模式
            2.使用SDF对象中的方法parse，把符合构造方法中模式的字符串，解析为Date日期
            注意：
                public Date parse(String source) throws ParseException
                parse方法声明了一个异常叫ParseException
                如果字符串和构造方法的模式不一样，那么程序就会抛出异常
                调用一个抛出异常的方法，就必须处理这个异常，要么throws继续抛出这个异常
                要么就try catch自己处理
     */
    private static void demo02() throws ParseException {<!-- -->
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
        Date date = sdf.parse("2020年08月08日 14:34:46");
        System.out.println(date);
    }
}</code></pre> 
 </div> 
 <p><b>Calendar类</b></p> 
 <p><br> java.util.Calendar:日历类<br> 抽象类，有很多操作日历字段的方法<br> 无法直接创建对象使用，有一个静态方法getInstance()，该方法返回了Calendar类的子类对象<br> static Calendar getInstance()</p> 
 <div class="has"> 
  <pre class="has"><code>public class Demo01Calendar {<!-- -->

 public static void main(String[] args) {<!-- -->

 Calendar c = Calendar.getInstance();//多态
 System.out.println(c);
    }
}</code></pre> 
 </div> 
 <p><b>System类</b></p> 
 <p><b>StringBuilder类</b></p> 
 <p> java.lang.StringBuilder类：字符串缓冲区，可以提高字符串的效率<b>构造方法</b>：<br> StringBuilder() 构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符<br> StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。</p> 
 <div class="has"> 
  <pre class="has"><code>public class Demo01StringBuilder {<!-- -->

    public static void main(String[] args) {<!-- -->
        //空参数构造
        StringBuilder bu1 = new StringBuilder();
        System.out.println("bu1" + bu1);

        //带字符串
        StringBuilder bu2 = new StringBuilder("abc");
        System.out.println("bu2" + bu2);
    }
}</code></pre> 
 </div> 
 <p><b>StringBuilder类的append方法</b></p> 
 <div class="has"> 
  <pre class="has"><code>/*
    StringBuilder的常用方法：
        public StringBuilder append(...):添加任意类型数据的字符串形式，并返回当前对象自身

 */
public class Demo02StringBuilder {<!-- -->
    public static void main(String[] args) {<!-- -->
        //创建对象
        StringBuilder bu = new StringBuilder();
        //使用append方法添加数据
        //append方法返回的是this，调用的对象bu，this==bu
//        StringBuilder bu2 =bu.append("abc");
//        System.out.println(bu);//“abc”
//        System.out.println(bu2);//“abc”
//        System.out.println(bu == bu2);//比较的是地址 true

        //使用append方法无需接受返回值
//        bu.append("abc");
//        bu.append(1);
//        bu.append(true);
//        bu.append(8.8);
//        bu.append("中");
//        System.out.println(bu);

        /*
        链式编程：方法返回值是一个对象，可以继续调用方法
         */
        System.out.println("abc".toUpperCase().toLowerCase().toUpperCase().toLowerCase());
        bu.append("abc").append(1).append(true).append(8.8).append("中");
        System.out.println(bu);
    }
}</code></pre> 
 </div> 
 <p><b>StringBuilder类的toString方法</b></p> 
 <div class="has"> 
  <pre class="has"><code>/*
    StringBuilder 和 String可以相互转换：
        String-&gt;StringBuilder:可以使用StringBuilder的构造方法
                StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。
        StringBuilder-&gt;String:可以使用StringBuilder中的toString方法
 */
public class Demo03StringBuilder {<!-- -->
    public static void main(String[] args) {<!-- -->
        //String-&gt;StringBuilder
        String str = "hello";
        System.out.println("str:" + str);
        StringBuilder bu = new StringBuilder(str);
        //添加数据
        bu.append("world");
        System.out.println("bu:" + bu);

        //StringBuilder-&gt;String
        String s = bu.toString();
        System.out.println("s" + s);
    }
}</code></pre> 
 </div> 
 String、StringBuffer与StringBuilder之间区别​www.baidu.com 
 <p><b>包装类</b></p> 
 <p>Java中的基本数据类型没有方法和属性，而包装类就是为了让这些拥有方法和属性，实现对象化交互。</p> 
 <div class="has"> 
  <pre class="has"><code>/*
    装箱：把基本类型的数据，包装到包装类中(基本类型数据-&gt;包装类)
        构造方法：
            Integer(int value) 构造一个新分配的 Integer 对象，它表示指定的 int 值。
            Integer(String s)构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。
                传递的字符串，必须是基本类型的字符串，否则会抛出异常"100"正确，"a"抛异常
        静态方法：
            static Integer valueOf(int i) 返回一个表示指定的 int 值的 Integer 实例。
            static Integer valueOf(String s) 返回保存指定的 String 的值的 Integer 对象。
    拆箱：在包装类中取出基本类型的数据(包装类-&gt;基本类型数据)
        成员方法：
            int intValue() 以 int 类型返回该 Integer 的值。
 */

public class Demo01Integer {<!-- -->

    public static void main(String[] args) {<!-- -->
        //装箱：把基本类型的数据，包装到包装类中(基本类型数据-&gt;包装类)
        Integer in1 = new Integer(1);//方法上有横线，说明方法过时了
        System.out.println(in1);//重写了toString方法
        Integer in2 = new Integer("1");
        System.out.println(in2);

        //静态方法
        Integer in3 = Integer.valueOf(1);
        System.out.println(in3);

//        Integer in4 = Integer.valueOf("a");//NumberFormatException数字格式化异常
        Integer in4 = Integer.valueOf("1");
        System.out.println(in4);

        //拆箱：在包装类中取出基本类型的数据(包装类-&gt;基本类型数据)
        int i = in1.intValue();
    }
}</code></pre> 
 </div> 
 <p><b>自动装箱与自动拆箱</b></p> 
 <div class="has"> 
  <pre class="has"><code>/*
    自动装箱与自动拆箱：基本类型的数据和包装类之间可以自动的互相转换
    JDL1.5后新特性
 */
import java.util.ArrayList;
public class Demo02Integer {<!-- -->
    public static void main(String[] args) {<!-- -->
        //自动装箱
        //Integer in = 1; 相当于 Integer in = new Integer();
        Integer in = 1;

        //自动拆箱：in 是包装类，无法直接参与运算，可以自动转换为基本数据类型，进行计算
        //in + 2;相当于 in.intVale() + 2
        //in = in.intVale() + 2 = 3 又是一个子弟哦那个装箱
        in = in + 2;

        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        //ArrayList 集合无法直接存储整数，可以存储Integer包装类
        list.add(1);//--&gt;自动装箱 list.add(new Integer(1));

        list.get(0);//--&gt;自动拆箱 list.get(0).intVale();
    }
}</code></pre> 
 </div> 
 <p><b>基本类型与字符串类型之间的相互转换</b></p> 
 <div class="has"> 
  <pre class="has"><code>/*
    基本类型--&gt;字符串（String）
        1.基本类型的值 + “” 最简单
        2.包装类的静态方法toString(参数)，不是Object类的toString() 重载
            static String toString(int i) 返回一个表示指定整数的String对象
        3.String类的静态方法valueOf(参数)
            static String valueOf(int i) 返回 int 参数的字符串表示形式
    字符串(String)--&gt;基本类型
        使用包装类的静态方法parseXXX("字符串")
            Integer类：static int parseInt(String s)
            Double类：static double parseDouble(String s)
 */
public class Demo03Integer {<!-- -->

    public static void main(String[] args) {<!-- -->
        //基本类型--&gt;字符串（String）

        int i1 = 100;
        String s1 = i1 + "";//1
        System.out.println(s1 + 200);

        String s2 = Integer.toString(100);//2
        System.out.println(s2 + 200);

        String s3 = String.valueOf(100);//3
        System.out.println(s3 + 200);

        //字符串(String)--&gt;基本类型
        int i = Integer.parseInt(s1);
        System.out.println(i-10);
    }
}</code></pre> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a18ffd190892c75bdc5c0c22086970d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">西门子ug通用后处理_优胜PM2017PM2021_三轴通用后处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ea81cc4be9752fef7f1d1fc499800dee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python学习笔记-9.高级变量5-公共方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>