<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试常见的排序算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试常见的排序算法" />
<meta property="og:description" content="一、各个排序算法的时间复杂度
一、归并排序 归并思想
思想:将两个有序的数组合并成一个有序的数组。
第一步
将数组进行分解，当分解成单个元素为一组的时候才是组内有序的。
第二步
将两两有序的数组进行合并，将两个有序数组合并成一个有序数组。重复第二步，直至排序完成。
合并的步骤:先申请两数组合并后那么大小的空间，然后将两个排好序的数组逐一进行比较，往申请空间里面放。
递归前进:自己调用自己的语句
递归回退:return,通过递归结束条件进行回退
在哪里调用的函数，函数的返回值就返回到哪里
#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; void Merg(vector&lt;int&gt;&amp; vec, int L, int mid, int R) { vector&lt;int&gt;temp(R-L&#43;1); int i = L, j = mid &#43; 1; int index = 0; while (i &lt;= mid &amp;&amp; j &lt;= R) { if (vec[i] &lt; vec[j]) { temp[index&#43;&#43;] = vec[i&#43;&#43;]; } else { temp[index&#43;&#43;] = vec[j&#43;&#43;]; }	} while (i &lt;= mid) { temp[index&#43;&#43;] = vec[i&#43;&#43;]; }	while (j &lt;= R) { temp[index&#43;&#43;] = vec[j&#43;&#43;]; } //把排好序的放回原数组 index = L; for (auto it:temp) { vec[index&#43;&#43;] = it; } } void Merg_sort(vector&lt;int&gt;&amp; vec, int L, int R) { if (L &gt;= R) return; int mid = (R - L) / 2 &#43; L; Merg_sort(vec, L, mid); Merg_sort(vec, mid &#43; 1, R); //合并 Merg(vec, L, mid, R); } int main() { int num; vector&lt;int&gt;vec; while (cin &gt;&gt; num) { vec." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/740379641f20599ac9ed564cf9a404e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-10T10:40:46+08:00" />
<meta property="article:modified_time" content="2024-01-10T10:40:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试常见的排序算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、各个排序算法的时间复杂度</p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/6b/87/eJphCAtx_o.png" width="907"></p> 
<div></div> 
<div> 
 <div> 
  <h2 style="background-color:transparent;margin-left:0pt;text-align:left;"><strong><span style="color:#1a1a1a;">一、归并排序</span></strong></h2> 
  <p style="margin-left:0;text-align:left;"><span style="background-color:#f2dcdb;"><strong><span style="color:#000000;">归并思想</span></strong></span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">思想</span><span style="color:#000000;">:</span><span style="color:#000000;">将两个有序的数组合并成一个有序的数组。</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#2e75b5;">第一步</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">将数组进行分解，当分解成单个元素为一组的时候才是组内有序的。</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#2e75b5;">第二步</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">将两两有序的数组进行合并，将两个有序数组合并成一个有序数组。重复第二步，直至排序完成。</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">合并的步骤</span><span style="color:#000000;">:</span><span style="color:#000000;">先申请两数组合并后那么大小的空间，然后将两个排好序的数组逐一进行比较，往申请空间里面放。</span></p> 
  <p style="margin-left:0;text-align:left;"><img alt="" height="777" src="https://images2.imgbox.com/5d/cc/1bRg7Xvn_o.png" width="1200"><span style="background-color:#f2dcdb;"><span style="color:#000000;">递归前进:</span></span><span style="color:#000000;">自己调用自己的语句</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="background-color:#f2dcdb;"><span style="color:#000000;">递归回退</span></span><span style="background-color:#f2dcdb;"><span style="color:#000000;">:</span></span><span style="color:#000000;">return,</span><span style="color:#000000;">通过递归结束条件进行回退</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="background-color:#f2dcdb;"><span style="color:#000000;">在哪里调用的函数，函数的返回值就返回到哪里</span></span></p> 
 </div> 
</div> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

void Merg(vector&lt;int&gt;&amp; vec, int L, int mid, int R) {
	vector&lt;int&gt;temp(R-L+1);
	int i = L, j = mid + 1;
	int index = 0;
	while (i &lt;= mid &amp;&amp; j &lt;= R) {
		if (vec[i] &lt; vec[j]) {
			temp[index++] = vec[i++];
		}
		else {
			temp[index++] = vec[j++];
		}		
	}
	 while (i &lt;= mid) {
		temp[index++] = vec[i++];
		}	
	while (j &lt;= R) {
		temp[index++] = vec[j++];
		}
	//把排好序的放回原数组
		index = L;
		for (auto it:temp) {
			vec[index++] = it;
		}
}
void Merg_sort(vector&lt;int&gt;&amp; vec, int L, int R) {
	if (L &gt;= R) return;
	int mid = (R - L) / 2 + L;
	Merg_sort(vec, L, mid);
	Merg_sort(vec, mid + 1, R);
	//合并
	Merg(vec, L, mid, R);
}
int main() {
	int num;
	vector&lt;int&gt;vec;
	 while (cin &gt;&gt; num) {
        vec.push_back(num);
    }
	Merg_sort(vec,0,vec.size()-1);
	for (auto it : vec) {
		cout &lt;&lt; it &lt;&lt; " ";
	}
	return 0;
}

</code></pre> 
<h2>二、<strong><span style="color:#1a1a1a;">堆排序</span></strong></h2> 
<div> 
 <div> 
  <p style="margin-left:0;text-align:left;"><span style="color:#e84c22;">第一步</span><span style="color:#e84c22;">:</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">我们将待排序数组形象成一个堆结构，并将其调整为最大堆</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">(</span><span style="color:#000000;">堆结构</span><span style="color:#000000;">:</span><span style="color:#000000;">左孩子的下标是</span><span style="color:#000000;">2* i+1</span><span style="color:#000000;">，右孩子下标</span><span style="color:#000000;">2*i+2)</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">(</span><span style="color:#000000;">最大堆的特点</span><span style="color:#000000;">:</span><span style="color:#000000;">在这个 堆结构里，任何一个父节点的值都大于其子节点的值</span><span style="color:#000000;">)</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#e84c22;">第二步</span><span style="color:#e84c22;">:</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">将堆顶元素与待排序数组（假设待排序的数据数量为</span><span style="color:#000000;">nums)</span><span style="color:#000000;">最后一个元素进行交换，</span><span style="color:#000000;">swap(a[0], a[nums-1]);</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#e84c22;">第三步</span><span style="color:#e84c22;">:</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">待排序的数据量减少一个</span><span style="color:#000000;">,</span><span style="color:#000000;">即</span><span style="color:#000000;">num--;</span><span style="color:#000000;">将待排序数组重新调整成最大堆结构，重复第二步，循环</span><span style="color:#000000;">n-1</span><span style="color:#000000;">次，将所有数据排序完成。</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">初始化堆（将数组调整成最大堆</span><span style="color:#000000;">)</span></p> 
  <p style="margin-left:0;text-align:left;"><span style="color:#000000;">从最后一个父节点开始调整</span><span style="color:#000000;">(</span><span style="color:#000000;">即</span><span style="color:#000000;">i = n/2-1)</span></p> 
 </div> 
</div> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

//将子树调整为最大堆
void Adjust(vector&lt;int&gt;&amp; vec, int start, int end) {  //start最开始调整时start不断变化，交换时end不断缩小
	int father = start;    //当前子树结点
	int child = father * 2 + 1;   //左子树
	while (child &lt;= end) { //不断向下调整防止破坏子树，用end来结束循环防止循环内数组访问越界（调整子树的子树的时候）
		if (child + 1 &lt;= end &amp;&amp; vec[child] &lt; vec[child + 1]) {  //child+1判断右子树是否越界
			child++;
		}
		if (vec[father] &lt; vec[child]) {
			swap(vec[father], vec[child]);
	//帮助调整子树的最大堆结构，只有和子树的根节点交换了才可能需要向下调整子树
		father = child;
		child = father * 2 + 1;
		}
		else {
			break;  //如果没交换child就会改变 会死循环
		}
	}
}
//堆排序的整个流程
void Heap_sort(vector&lt;int&gt;&amp; vec)
{
	int n = vec.size(); //完全二叉树中结点个数

	//最后一个有子节点的下标为n/2-1;
	for (int i = n / 2 - 1; i &gt;= 0; i--) {
		Adjust(vec, i, n - 1);  //end不受限制因为可能破坏子树结构向下调整
	}

	for (int i = n - 1; i &gt;= 0; i--)  //i是下标
	{
		//交换堆顶和待排序元素中的最后一个元素
		swap(vec[0], vec[i]);

	//把剩下的待排序元素调整成最大堆结构
	Adjust(vec, 0, i - 1); //为啥到i-1，因为Adjust的区间是左闭右闭
	}
}
int  main() {
	vector&lt;int&gt;vec;
	int n;
	while(cin&gt;&gt;n){
		vec.push_back(n);
	}
	Heap_sort(vec);
	for (auto it:vec) {
		cout &lt;&lt; it &lt;&lt; " ";
	}

	return 0;
   }

</code></pre> 
<h2>三、<strong><span style="color:#1a1a1a;">快速排序</span></strong></h2> 
<div> 
 <div> 
  <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1、 在数组中选一个基准数（通常为数组第一个）；</span></span></p> 
  <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2、将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边；</span></span></p> 
  <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">3、对于基准数左、右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序。</span></span></p> 
 </div> 
</div> 
<p> </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
int part(vector&lt;int&gt;&amp; nums, int l, int r)  //划分函数
{
	int m=l+rand()%(r-l+1);
    swap(nums[m],nums[l]);
	int i = l, j = r, pivot = nums[l]; //基准元素
	while (i &lt; j)
	{
		while (i&lt;j &amp;&amp; nums[j]&gt;pivot) //从右向左开始找一个 小于等于 pivot的数值
		{
			j--;
		}
		if (i &lt; j)
		{
			swap(nums[i++],nums[j]);  //r[i]和r[j]交换后 i 向右移动一位
		}
		while (i &lt; j &amp;&amp; nums[i] &lt;= pivot) //从左向右开始找一个 大于 pivot的数值
		{
			i++;
		}
		if (i &lt; j)
		{
			swap(nums[i], nums[j--]);  //r[i]和r[j]交换后 i 向左移动一位
		}
	}
	return i;  //返回最终划分完成后基准元素所在的位置
}
void Quicksort(vector&lt;int&gt;&amp; nums, int l, int r)
{
	int mid;
	if (l &lt; r)
	{
		mid = part(nums, l, r);  // 返回基准元素位置
		Quicksort(nums, l, mid - 1); // 左区间递归快速排序
		Quicksort(nums, mid+1, r); // 右区间递归快速排序
	}
}
int main()
{
	vector&lt;int&gt; vec;
	int n;
	while(cin&gt;&gt;n){
		vec.push_back(n);
	}
	Quicksort(vec, 0, vec.size()-1);
	for (auto it:vec) {
	cout &lt;&lt; it &lt;&lt; " ";
	}

	return 0;
}


</code></pre> 
<div></div> 
<div> 
 <div> 
  <h2 style="margin-left:0pt;text-align:left;"><strong><span style="color:#1a1a1a;">四、冒泡排序</span></strong></h2> 
  <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></span></p> 
  <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span></span></p> 
  <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">针对所有的元素重复以上的步骤，除了最后一个。</span></span></p> 
  <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#333333;">持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span></span></p> 
 </div> 
</div> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
using namespace std;

void swap(int* a, int* b) {
	int c = *a;
	*a = *b;
	*b = c;
}
void BubbleSort(int arr[],int n) {
	for (int i = 1; i &lt; n; i++) {   
	int flat=0;
		for (int j = 0; j &lt; n - i; j++) {
			if (arr[j] &gt; arr[j + 1]) {
				swap(&amp;arr[j], &amp;arr[j + 1]);
				flat=1;
			}
		}
		if(flat==0){
		return;
		}
	}
}
int main() {
int n;
cin &gt;&gt; n;
int arr[n];
for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; arr[i];
}
BubbleSort(arr, n);
for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; arr[i] &lt;&lt; " ";
}

	return 0;
}
</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/269579be6ab0dbec78160a0aae6dc8f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">U盘删除的文件不在回收站如何恢复？教你3个简单方法！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/294235428f711abae8baccfe482e861e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">bat批处理脚本:生成spec文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>