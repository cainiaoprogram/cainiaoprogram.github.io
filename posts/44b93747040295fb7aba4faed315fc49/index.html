<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Wireshark抓包实验验证 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Wireshark抓包实验验证" />
<meta property="og:description" content="数据链路层 实作一 熟悉 Ethernet 帧结构
使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。
问题：你会发现 Wireshark 展现给我们的帧中没有校验字段，请了解一下原因。
答：这是因为有时校验和会由网卡计算，这时wireshark抓到的本机发送的数据包的校验和都是错误的，所以默认关闭了WireShark自己的校验。
实作二 了解子网内/外通信时的 MAC 地址
1、ping 你旁边的计算机（同一子网），同时用 Wireshark 抓这些包（可使用 icmp 关键字进行过滤以利于分析），记录一下发出帧的目的 MAC 地址以及返回帧的源 MAC 地址是多少？这个 MAC 地址是谁的？
2、然后 ping qige.io （或者本子网外的主机都可以），同时用 Wireshark 抓这些包（可 icmp 过滤），记录一下发出帧的目的 MAC 地址以及返回帧的源 MAC 地址是多少？这个 MAC 地址是谁的？
3、再次 ping www.cqjtu.edu.cn （或者本子网外的主机都可以），同时用 Wireshark 抓这些包（可 icmp 过滤），记录一下发出帧的目的 MAC 地址以及返回帧的源 MAC 地址又是多少？这个 MAC 地址又是谁的？
问题;
通过以上的实验，你会发现：
1、访问本子网的计算机时，目的 MAC 就是该主机的
访问非本子网的计算机时，目的 MAC 是网关的
2、请问原因是什么？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/44b93747040295fb7aba4faed315fc49/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-09T20:15:00+08:00" />
<meta property="article:modified_time" content="2020-11-09T20:15:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Wireshark抓包实验验证</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>数据链路层</h3> 
<p>实作一 熟悉 Ethernet 帧结构<br> 使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。<br> <img src="https://images2.imgbox.com/a4/a3/oc2hLhpx_o.png" alt="在这里插入图片描述"><br> 问题：你会发现 Wireshark 展现给我们的帧中没有校验字段，请了解一下原因。<br> 答：这是因为有时校验和会由网卡计算，这时wireshark抓到的本机发送的数据包的校验和都是错误的，所以默认关闭了WireShark自己的校验。</p> 
<p>实作二 了解子网内/外通信时的 MAC 地址<br> 1、ping 你旁边的计算机（同一子网），同时用 Wireshark 抓这些包（可使用 icmp 关键字进行过滤以利于分析），记录一下发出帧的目的 MAC 地址以及返回帧的源 MAC 地址是多少？这个 MAC 地址是谁的？<br> <img src="https://images2.imgbox.com/b1/e6/SuUiXon7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/57/b2/SUAk9cXj_o.png" alt="在这里插入图片描述"></p> 
<p>2、然后 ping qige.io （或者本子网外的主机都可以），同时用 Wireshark 抓这些包（可 icmp 过滤），记录一下发出帧的目的 MAC 地址以及返回帧的源 MAC 地址是多少？这个 MAC 地址是谁的？<br> <img src="https://images2.imgbox.com/2c/4c/gz9HwdBV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f0/b9/5GiYXAff_o.png" alt="在这里插入图片描述"></p> 
<p>3、再次 ping www.cqjtu.edu.cn （或者本子网外的主机都可以），同时用 Wireshark 抓这些包（可 icmp 过滤），记录一下发出帧的目的 MAC 地址以及返回帧的源 MAC 地址又是多少？这个 MAC 地址又是谁的？<br> <img src="https://images2.imgbox.com/1f/90/a03y6rnm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f6/10/0BI7fxhA_o.png" alt="在这里插入图片描述"><br> 问题;<br> 通过以上的实验，你会发现：<br> 1、访问本子网的计算机时，目的 MAC 就是该主机的<br> 访问非本子网的计算机时，目的 MAC 是网关的<br> 2、请问原因是什么？<br> 答：ARP代理，访问非子网计算机时是通过路由器转接的，MAC地址是接入路由器端口的地址，再通过路由器发给相应计算机。</p> 
<p>实作三 掌握 ARP 解析过程<br> 1、为防止干扰，先使用 arp -d * 命令清空 arp 缓存<br> 2、ping 你旁边的计算机（同一子网），同时用 Wireshark 抓这些包（可 arp 过滤），查看 ARP 请求的格式以及请求的内容，注意观察该请求的目的 MAC 地址是什么。再查看一下该请求的回应，注意观察该回应的源 MAC 和目的 MAC 地址是什么。<br> <img src="https://images2.imgbox.com/b9/db/3J8g88uD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6d/cf/ZJeYOrfW_o.png" alt="在这里插入图片描述"></p> 
<p>3、再次使用 arp -d * 命令清空 arp 缓存<br> 4、然后 ping qige.io （或者本子网外的主机都可以），同时用 Wireshark 抓这些包（可 arp 过滤）。查看这次 ARP 请求的是什么，注意观察该请求是谁在回应。<br> <img src="https://images2.imgbox.com/dd/34/IRKtudOO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7b/f5/6kTtgHmZ_o.png" alt="在这里插入图片描述"><br> 问题：<br> 通过以上的实验，你应该会发现，<br> 1、ARP 请求都是使用广播方式发送的<br> 2、如果访问的是本子网的 IP，那么 ARP 解析将直接得到该 IP 对应的 MAC；如果访问的非本子网的 IP， 那么 ARP 解析将得到网关的 MAC。<br> 请问为什么？<br> 答：ARP代理，访问非子网IP时是通过路由器访问的，路由器再把发出去，目标IP收到请求后，再通过路由器端口IP返回去，那么ARP解析将会得到网关的MAC。</p> 
<h3><a id="_43"></a>网络层</h3> 
<p>实作一 熟悉 IP 包结构<br> 使用 Wireshark 任意进行抓包（可用 ip 过滤），熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。<br> <img src="https://images2.imgbox.com/d0/68/UGqpUhxq_o.png" alt="在这里插入图片描述"></p> 
<p>✎ 问题<br> 为提高效率，我们应该让 IP 的头部尽可能的精简。但在如此珍贵的 IP 头部你会发现既有头部长度字段，也有总长度字段。请问为什么？<br> 答：便于传输时的识别IP总长度，节省时间，当长度超过1500B时就会被返回链路层进行分段。</p> 
<p>实作二 IP 包的分段与重组<br> 根据规定，一个 IP 包最大可以有 64K 字节。但由于 Ethernet 帧的限制，当 IP 包的数据超过 1500 字节时就会被发送方的数据链路层分段，然后在接收方的网络层重组。<br> 缺省的，ping 命令只会向对方发送 32 个字节的数据。我们可以使用 ping 202.202.240.16 -l 2000 命令指定要发送的数据长度。此时使用 Wireshark 抓包（用 ip.addr == 202.202.240.16 进行过滤），了解 IP 包如何进行分段，如：分段标志、偏移量以及每个包的大小等<br> <img src="https://images2.imgbox.com/47/a6/K6wfSBRS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9a/78/7re9PITW_o.png" alt="在这里插入图片描述"></p> 
<p>✎ 问题<br> 分段与重组是一个耗费资源的操作，特别是当分段由传送路径上的节点即路由器来完成的时候，所以 IPv6 已经不允许分段了。那么 IPv6 中，如果路由器遇到了一个大数据包该怎么办？<br> 答：转发至能支持该数据报的出链路上。</p> 
<p>实作三 考察 TTL 事件<br> 在 IP 包头中有一个 TTL 字段用来限定该包可以在 Internet上传输多少跳（hops），一般该值设置为 64、128等。</p> 
<p>在验证性实验部分我们使用了 tracert 命令进行路由追踪。其原理是主动设置 IP 包的 TTL 值，从 1 开始逐渐增加，直至到达最终目的主机。</p> 
<p>请使用 tracert www.baidu.com 命令进行追踪，此时使用 Wireshark 抓包（用 icmp 过滤），分析每个发送包的 TTL 是如何进行改变的，从而理解路由追踪原理。<br> <img src="https://images2.imgbox.com/77/ae/tClCRadc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8f/a8/VbFacfKe_o.png" alt="在这里插入图片描述"><br> 每到达一个节点返回一个信息，TTL逐渐增加1直到到达目的主机。<br> 问题： IPv4 中，TTL 虽然定义为生命期即 Time To Live，但现实中我们都以跳数/节点数进行设置。如果你收到一个包，其 TTL 的值为 50，那么可以推断这个包从源点到你之间有多少跳？<br> 答：50跳。</p> 
<h3><a id="_73"></a>传输层</h3> 
<p>实作一 熟悉 TCP 和 UDP 段结构<br> 1、用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。<br> <img src="https://images2.imgbox.com/db/04/UvrXqqJ3_o.png" alt="在这里插入图片描述"></p> 
<p>2、用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。<br> <img src="https://images2.imgbox.com/52/8e/059C8RX6_o.png" alt="在这里插入图片描述"><br> 问题：<br> 由上大家可以看到 UDP 的头部比 TCP 简单得多，但两者都有源和目的端口号。请问源和目的端口号用来干什么？<br> 答：在一台机器上，一个进程对应一个端口。端口的作用就是用来唯一标识这个进程。源端口标识发起通信的那个进程，目的端口标识接受通信的那个进程。有了端口号，接受到报文后才能够知道将报文发送到哪个进程。</p> 
<p>实作二 分析 TCP 建立和释放连接<br> 1、打开浏览器访问 qige.io 网站，用 Wireshark 抓包（可用 tcp 过滤后再使用加上 Follow TCP Stream），不要立即停止 Wireshark 捕获，待页面显示完毕后再多等一段时间使得能够捕获释放连接的包。<br> 2、请在你捕获的包中找到三次握手建立连接的包，并说明为何它们是用于建立连接的，有什么特征。<br> （SYN 同步序列号，用来发起一个TCP连接）<br> <img src="https://images2.imgbox.com/3d/1e/U73yqOSR_o.png" alt="在这里插入图片描述"></p> 
<p>3、请在你捕获的包中找到四次挥手释放连接的包，并说明为何它们是用于释放连接的，有什么特征。<br> （TCP断开连接是通过发送FIN报文，来告诉对方数据已经发送完毕，可以释放连接了）<br> <img src="https://images2.imgbox.com/a4/33/8ObWYr5y_o.png" alt="在这里插入图片描述"><br> 分析：可以看到我只有三次挥手，那是因为第二次和第三次合并了。如果对方也没有数据发给本端，那么对方也会发送FIN给本端，用于关闭从对方到本端的连接，这时候就可能出现ACK和FIN合在一起的情况。</p> 
<h3><a id="_94"></a>应用层</h3> 
<p>应用层的协议非常的多，我们只对 DNS 和 HTTP 进行相关的分析。</p> 
<p>实作一 了解 DNS 解析<br> 1、先使用 ipconfig /flushdns 命令清除缓存，再使用 nslookup qige.io 命令进行解析，同时用 Wireshark 任意抓包（可用 dns 过滤）。<br> <img src="https://images2.imgbox.com/a7/ad/FXH6f4O2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/33/20/70p0NRPl_o.png" alt="在这里插入图片描述"></p> 
<p>2、你应该可以看到当前计算机使用 UDP，向默认的 DNS 服务器的 53 号端口发出了查询请求，而 DNS 服务器的 53 号端口返回了结果。<br> <img src="https://images2.imgbox.com/de/97/TITykvc1_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5d/70/yGyO13tQ_o.png" alt="在这里插入图片描述"></p> 
<p>3、可了解一下 DNS 查询和应答的相关字段的含义<br> 问题：<br> 你可能会发现对同一个站点，我们发出的 DNS 解析请求不止一个，思考一下是什么原因？<br> 答：例如，对域名www.baidu.com进行解析就会出现这样的结果。产生这样的结果是为了使baidu这个百度服务器的负载得到平衡(因为每天访问这个站点的次数非常多)。因此这个网站就设有好几个计算机，每一个计算机都运行同样的服务器软件。这些计算机的IP地址当然都是不一样的，但它们的域名却是相同的。这样，第一个访问该网址的就得到第一个计算机的IP地址，而第二个访问者就得到第二个计算机的IP地址等等。这样可使每一个计算机的负荷不会太大。</p> 
<p>实作二 了解 HTTP 的请求和应答<br> 1、打开浏览器访问 qige.io 网站，用 Wireshark 抓包（可用http 过滤再加上 Follow TCP Stream），不要立即停止 Wireshark 捕获，待页面显示完毕后再多等一段时间以将释放连接的包捕获。<br> <img src="https://images2.imgbox.com/c1/f9/x8hbfrVT_o.png" alt="在这里插入图片描述"><br> 2、请在你捕获的包中找到 HTTP 请求包，查看请求使用的什么命令，如：GET, POST。并仔细了解请求的头部有哪些字段及其意义。（用了GET命令）<br> <img src="https://images2.imgbox.com/1c/9d/uATnmyvp_o.png" alt="在这里插入图片描述"></p> 
<p>3、请在你捕获的包中找到 HTTP 应答包，查看应答的代码是什么，如：200, 304, 404 等。并仔细了解应答的头部有哪些字段及其意义。（应答代码是200）<br> <img src="https://images2.imgbox.com/5b/92/kwzN5hZ3_o.png" alt="在这里插入图片描述"><br> 建议：<br> HTTP 请求和应答的头部字段值得大家认真的学习，因为基于 Web 的编程中我们将会大量使用。如：将用户认证的令牌信息放到头部，或者把 cookie 放到头部等。<br> 问题：<br> 刷新一次 qige.io 网站的页面同时进行抓包，你会发现不少的 304 代码的应答，这是所请求的对象没有更改的意思，让浏览器使用本地缓存的内容即可。那么服务器为什么会回答 304 应答而不是常见的 200 应答？<br> 答：浏览器和服务器有一个协商的过程，服务器告诉浏览器当前请求的资源上一次修改的时间是这个时间。浏览器第二次发送请求的时候，告诉浏览器我上次请求的资源现在还在自己的缓存中，如果你那边这个资源还没有修改，就可以不用传送应答体给我了。服务器根据浏览器传来的时间发现和当前请求资源的修改时间一致，就应答304，表示不传应答体了，从缓存里取。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2d3df0bfe9ca89b40e1ea11e815ce44/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2020-11-09 VSCode在Ubuntu&#43;Snap下无法启动的解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74f9092327d3b901766312312e4d5f12/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">两台电脑navicat数据传输_【笔记】两台西门子S7-200Smart PLC进行无线通讯</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>