<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>灰色关联分析笔记 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="灰色关联分析笔记" />
<meta property="og:description" content="什么时候用灰色关联分析？ 灰色关联分析 是根据因素之间发展趋势的相似或相异程度，亦即“灰色关联度”，作为衡量因素间关联程度的一种方法
【若两个因素变化的趋势具有一致性，即同步变化程度较高，即可谓二者关联程度较高；反之，则较低】
当样本个数 n 较大时，用标准化回归（第7讲学），当样本个数 n 较少时，用灰色关联分析
灰色关联分析的顺序 ① 正向化（若已经全是极大型 则不需要）
② 预处理（每一个元素都被预处理）
③ 构造母序列和子序列（若题目本身已给出 则不需要）
④ 计算各个指标与母序列的灰色关联度（每一列 都可以求出一个灰色关联度）
⑤ 针对各个指标的权重 计算每一个元素的得分（若每一列的灰色关联度都一样 则不需要）
⑥ 对得分进行归一化 并排序
下图引用自 数学建模灰色关联分析法——学习笔记（一）
使用灰色关联分析的两种套路 ① 用于系统分析（比较母序列与哪个子序列最接近） 我们以下图举例，分析国内生产总值与哪一个产业的影响最大？
load gdp.mat	% 导入数据 Mean = mean(gdp); % 求出每一列的均值以供后续的数据预处理 gdp = gdp ./ repmat(Mean,size(gdp,1),1); % 将矩阵进行复制为和gdp同等大小，然后使用点除（对应元素相除） disp(&#39;预处理后的矩阵为：&#39;); disp(gdp) Y = gdp(:,1); % 母序列 X = gdp(:,2:end); % 子序列 absX0_Xi = abs(X - repmat(Y,1,size(X,2))) % 计算|Y-Xi|矩阵 a = min(min(absX0_Xi)) % 计算两级最小差a b = max(max(absX0_Xi)) % 计算两级最大差b rho = 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a3bfe6c70cf91a9e44eb24e4a4c17048/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-16T19:02:33+08:00" />
<meta property="article:modified_time" content="2020-06-16T19:02:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">灰色关联分析笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>什么时候用灰色关联分析？</h2> 
<p>灰色关联分析 是根据因素之间发展趋势的相似或相异程度，亦即“灰色关联度”，作为衡量因素间关联程度的一种方法<br> 【若两个因素变化的趋势具有一致性，即同步变化程度较高，即可谓二者关联程度较高；反之，则较低】</p> 
<p><strong>当样本个数 n 较大时，用标准化回归（第7讲学），当样本个数 n 较少时，用灰色关联分析</strong></p> 
<h2><a id="_6"></a>灰色关联分析的顺序</h2> 
<p><strong>①</strong> 正向化（若已经全是极大型 则不需要）<br> <strong>②</strong> 预处理（每一个元素都被预处理）<br> <strong>③</strong> 构造母序列和子序列（若题目本身已给出 则不需要）<br> <strong>④</strong> 计算各个指标与母序列的灰色关联度（每一列 都可以求出一个灰色关联度）<br> <strong>⑤</strong> 针对各个指标的权重 计算每一个元素的得分（若每一列的灰色关联度都一样 则不需要）<br> <strong>⑥</strong> 对得分进行归一化 并排序</p> 
<p><strong>下图引用自</strong> <a href="https://blog.csdn.net/weixin_43793141/article/details/105258341"><strong>数学建模灰色关联分析法——学习笔记（一）</strong></a><br> <img src="https://images2.imgbox.com/6a/6a/40zQQdld_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_17"></a>使用灰色关联分析的两种套路</h2> 
<h3><a id="__18"></a>① 用于系统分析（比较母序列与哪个子序列最接近）</h3> 
<p><strong>我们以下图举例，分析国内生产总值与哪一个产业的影响最大？</strong><br> <img src="https://images2.imgbox.com/a6/fb/24JvJy4D_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/76/9f/xBiLwmgn_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp">load gdp<span class="token punctuation">.</span>mat							    <span class="token operator">%</span> 导入数据
Mean <span class="token operator">=</span> <span class="token function">mean</span><span class="token punctuation">(</span>gdp<span class="token punctuation">)</span><span class="token punctuation">;</span> 						    <span class="token operator">%</span> 求出每一列的均值以供后续的数据预处理
gdp <span class="token operator">=</span> gdp <span class="token punctuation">.</span><span class="token operator">/</span> <span class="token function">repmat</span><span class="token punctuation">(</span>Mean<span class="token punctuation">,</span><span class="token function">size</span><span class="token punctuation">(</span>gdp<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">%</span> 将矩阵进行复制为和gdp同等大小，然后使用点除（对应元素相除）

<span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'预处理后的矩阵为：'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">disp</span><span class="token punctuation">(</span>gdp<span class="token punctuation">)</span>
Y <span class="token operator">=</span> <span class="token function">gdp</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  								<span class="token operator">%</span> 母序列
X <span class="token operator">=</span> <span class="token function">gdp</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">:</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span> 							<span class="token operator">%</span> 子序列
absX0_Xi <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>X <span class="token operator">-</span> <span class="token function">repmat</span><span class="token punctuation">(</span>Y<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">size</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token operator">%</span> 计算<span class="token operator">|</span>Y<span class="token operator">-</span>Xi<span class="token operator">|</span>矩阵
a <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>absX0_Xi<span class="token punctuation">)</span><span class="token punctuation">)</span>   				    <span class="token operator">%</span> 计算两级最小差a
b <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>absX0_Xi<span class="token punctuation">)</span><span class="token punctuation">)</span>  					<span class="token operator">%</span> 计算两级最大差b

rho <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">;</span>								    <span class="token operator">%</span> 分辨系数取 <span class="token number">0.5</span>
gamma <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>rho<span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token operator">/</span> <span class="token punctuation">(</span>absX0_Xi  <span class="token operator">+</span> rho<span class="token operator">*</span>b<span class="token punctuation">)</span>    <span class="token operator">%</span> 计算子序列中各个指标与母序列的关联系数
<span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'子序列中各个指标的灰色关联度分别为：'</span><span class="token punctuation">)</span>
<span class="token function">disp</span><span class="token punctuation">(</span><span class="token function">mean</span><span class="token punctuation">(</span>gamma<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="__39"></a>② 用于综合评价模型（评价哪个子序列是最优解）</h3> 
<p><strong>以下图为例</strong><br> <img src="https://images2.imgbox.com/b5/52/JXSrdVYz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4a/40/1JFQj5K5_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp">load data_water_quality<span class="token punctuation">.</span>mat  			<span class="token operator">%</span> 导入数据

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      								<span class="token operator">%</span> 进行正向化（操作就省略了）

<span class="token operator">%</span><span class="token operator">%</span> 对正向化后的矩阵进行预处理
Mean <span class="token operator">=</span> <span class="token function">mean</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span> 					    <span class="token operator">%</span> 求出每一列的均值以供后续的数据预处理
Z <span class="token operator">=</span> X <span class="token punctuation">.</span><span class="token operator">/</span> <span class="token function">repmat</span><span class="token punctuation">(</span>Mean<span class="token punctuation">,</span><span class="token function">size</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'预处理后的矩阵为：'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">disp</span><span class="token punctuation">(</span>Z<span class="token punctuation">)</span>

<span class="token operator">%</span><span class="token operator">%</span> 构造母序列和子序列
Y <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>Z<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  						<span class="token operator">%</span> 母序列为虚拟的，用每一行的最大值构成的列向量表示母序列
X <span class="token operator">=</span> Z<span class="token punctuation">;</span> 									<span class="token operator">%</span> 子序列就是预处理后的数据矩阵

<span class="token operator">%</span><span class="token operator">%</span> 计算得分
absX0_Xi <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>X <span class="token operator">-</span> <span class="token function">repmat</span><span class="token punctuation">(</span>Y<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">size</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 		  <span class="token operator">%</span> 计算<span class="token operator">|</span>X0<span class="token operator">-</span>Xi<span class="token operator">|</span>矩阵
a <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>absX0_Xi<span class="token punctuation">)</span><span class="token punctuation">)</span> 						      <span class="token operator">%</span> 计算两级最小差a
b <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>absX0_Xi<span class="token punctuation">)</span><span class="token punctuation">)</span>  						  <span class="token operator">%</span> 计算两级最大差b
rho <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">;</span> <span class="token operator">%</span> 分辨系数取<span class="token number">0.5</span>
gamma <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>rho<span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token operator">/</span> <span class="token punctuation">(</span>absX0_Xi  <span class="token operator">+</span> rho<span class="token operator">*</span>b<span class="token punctuation">)</span> 		  <span class="token operator">%</span> 计算子序列中各个指标与母序列的关联系数
weight <span class="token operator">=</span> <span class="token function">mean</span><span class="token punctuation">(</span>gamma<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token function">mean</span><span class="token punctuation">(</span>gamma<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  		  <span class="token operator">%</span> 利用子序列中各个指标的灰色关联度计算权重
score <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>X <span class="token punctuation">.</span><span class="token operator">*</span> <span class="token function">repmat</span><span class="token punctuation">(</span>weight<span class="token punctuation">,</span><span class="token function">size</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">%</span> 未归一化的得分
stand_S <span class="token operator">=</span> score <span class="token operator">/</span> <span class="token function">sum</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>  					  <span class="token operator">%</span> 归一化后的得分
<span class="token punctuation">[</span>sorted_S<span class="token punctuation">,</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">sort</span><span class="token punctuation">(</span>stand_S <span class="token punctuation">,</span><span class="token string">'descend'</span><span class="token punctuation">)</span>		  <span class="token operator">%</span> 进行排序
</code></pre> 
<p><strong>对于这题，我们需要自己构造母序列和子序列，每一行的最大值构成的列向量表示母序列，而预处理后的矩阵表示子序列，接下来，就可以比较母序列与哪个子序列最接近了</strong></p> 
<h3><a id="_70"></a>切记不能直接用于论文中，要根据题目适当的修改，避免查重</h3> 
<h3><a id="_72"></a>补充：</h3> 
<p>一般情况下母序列只有一个，但若母序列含有多个，则每个母序列都要与子序列算一遍，算出的灰色关联度，再来求平均值</p> 
<h2><a id="_75"></a>灰色关联分析的评估</h2> 
<p><strong>灰色关联分析 的优势：</strong><br> （1）因此对样本量的多少没有过多的要求，也不需要典型的分布规律，而且计算量比较小，其结果与定性分析结果会比较吻合。<br> （2）是系统分析中比较简单、可靠的一种分析方法<br> <strong>灰色关联分析 的缺点：</strong><br> （1）随着灰色关联分析理论应用领域的不断扩大,现有的一些模型存在的不足之处使得其不能很好地解决某些方面的实际问题<br> （2）整个理论体系目前还不是很完善，其应用受到了某些限制</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e74f02d029dc969ca9e1f0a26ac68a0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软件工程笔记：通用职责分配模式(grasp)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/37cf6f2b7450229faf46d224a37ad96c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">fMRI技术指南总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>