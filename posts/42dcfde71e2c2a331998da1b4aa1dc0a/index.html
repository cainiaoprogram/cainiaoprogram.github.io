<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker compose容器管理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker compose容器管理" />
<meta property="og:description" content="0.安装环境
CentOS7-64
镜像
nginx
mysql/mysql-server:5.7
1.什么是docker-compose
Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排
通过编写docker-compose文件可对多个服务同时进行启动/停止/更新(可定义依赖，按顺序启动服务)
docker-compose将所管理的容器分为3层结构：
project 1 一个微服务项目
service N 由N个微服务组成
container N 而每个微服务又由N个节点组成
docker-compose.yml组成一个project，project里包括多个service，每个service定义了容器运行的镜像（或构建镜像），
网络端口，文件挂载，参数，依赖等，每个service可包括同一个镜像的多个容器实例。
即 project 包含 service ，service 包含 container
注1：Docker-Compose的工程配置文件默认为docker-compose.yml
注2：compose英文意思：组成
2.为什么要使用docker-compose
前面我们使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。
然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，
那么效率之低，维护量之大可想而知
。而使用 Docker Compose 可以轻松、高效的管理容器，
它是一个用于定义和运行多容器 Docker 的应用程序工具。
注1：images/01 docker与docker-compose区别.jpg
使用compose基本上是一个三步过程：
1）用dockerfile，或者镜像定义应用程序的环境，以便在任何地方复制。
2）在docker-compose.yml中定义组成应用程序的服务，以便它们可以在单独的环境中一起运行。
3）运行docker compose up启动并运行整个应用程序。
3.docker-compose安装与配置
1.安装方式有3种
官网的方式去安装
pip进行安装
离线安装(本章介绍)，官网下载速度太慢了，离线方式更快
2.离线安装
#1.下载安装文件
访问Releases · docker/compose · GitHub，下载 docker-compose-Linux-x86_64，我是复制链接地址，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/42dcfde71e2c2a331998da1b4aa1dc0a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-25T16:35:00+08:00" />
<meta property="article:modified_time" content="2022-02-25T16:35:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker compose容器管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>0.安装环境</p> 
<p>  CentOS7-64</p> 
<p></p> 
<p>  镜像</p> 
<p>  nginx</p> 
<p>  mysql/mysql-server:5.7</p> 
<p></p> 
<p></p> 
<p></p> 
<p>1.什么是docker-compose</p> 
<p>  Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排</p> 
<p>  通过编写docker-compose文件可对多个服务同时进行启动/停止/更新(可定义依赖，按顺序启动服务)</p> 
<p></p> 
<p>  docker-compose将所管理的容器分为3层结构：</p> 
<p>    project            1             一个微服务项目</p> 
<p>      service          N             由N个微服务组成</p> 
<p>        container      N             而每个微服务又由N个节点组成</p> 
<p>  </p> 
<p>  docker-compose.yml组成一个project，project里包括多个service，每个service定义了容器运行的镜像（或构建镜像），</p> 
<p>  网络端口，文件挂载，参数，依赖等，每个service可包括同一个镜像的多个容器实例。</p> 
<p>  即 project 包含 service ，service 包含 container</p> 
<p></p> 
<p>  注1：Docker-Compose的工程配置文件默认为docker-compose.yml</p> 
<p>  注2：compose英文意思：组成</p> 
<p></p> 
<p>  </p> 
<p>2.为什么要使用docker-compose</p> 
<p>  前面我们使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。</p> 
<p>  然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，</p> 
<p>  那么效率之低，维护量之大可想而知</p> 
<p></p> 
<p>。而使用 Docker Compose 可以轻松、高效的管理容器，</p> 
<p>  它是一个用于定义和运行多容器 Docker 的应用程序工具。</p> 
<p></p> 
<p>  注1：images/01 docker与docker-compose区别.jpg</p> 
<p></p> 
<p></p> 
<p>  使用compose基本上是一个三步过程：</p> 
<p>  1）用dockerfile，或者镜像定义应用程序的环境，以便在任何地方复制。</p> 
<p>  2）在docker-compose.yml中定义组成应用程序的服务，以便它们可以在单独的环境中一起运行。</p> 
<p>  3）运行docker compose up启动并运行整个应用程序。</p> 
<p></p> 
<p></p> 
<p>3.docker-compose安装与配置</p> 
<p>  1.安装方式有3种</p> 
<p>    官网的方式去安装</p> 
<p>    pip进行安装</p> 
<p>    离线安装(本章介绍)，官网下载速度太慢了，离线方式更快</p> 
<p></p> 
<p>  2.离线安装</p> 
<p>    #1.下载安装文件</p> 
<p>    访问<a href="https://github.com/docker/compose/releases" title="Releases · docker/compose · GitHub">Releases · docker/compose · GitHub</a>，下载 docker-compose-Linux-x86_64，我是复制链接地址，</p> 
<p>    在迅雷中下载的，下载后，将docker-compose-Linux-x86_64重命名为docker-compose</p> 
<p>    #2.将刚才下载的docker-compose文件上传到centos7的/usr/local/bin/目录下</p> 
<p>    cd /usr/local/bin</p> 
<p>    rz</p> 
<p>    #3.添加可执行权限</p> 
<p>    chmod +x /usr/local/bin/docker-compose</p> 
<p>    #4.通过查看版本，测试安装是否成功</p> 
<p>    docker-compose -v</p> 
<p>    #查看所有命令</p> 
<p>    docker-compose -h</p> 
<p></p> 
<p>    注1：其它方式见资料/01 centos7中docker-compose的三种安装方式_ytangdigl的博客-CSDN博客</p> 
<p>    注2：docker-compose卸载请查看附录一</p> 
<p></p> 
<p>4.docker-compose.yml配置文件基本介绍</p> 
<p>  1.version：指定 docker-compose.yml 文件的写法格式</p> 
<p>    注1：Compose目前有三个版本分别为Version 1，Version 2，Version 3，Compose区分Version 1和Version 2（Compose 1.6.0+，Docker Engine 1.10.0+）。Version 2支持更多的指令。Version 1将来会被弃用。</p> 
<p>  </p> 
<p>  2.services：多个容器集合</p> 
<p>    services：</p> 
<p>     容器1：</p> 
<p>     容器2：</p> 
<p>     ...</p> 
<p></p> 
<p>  3.image：镜像名称或镜像ID。如果镜像在本地不存在，Compose将会尝试拉取镜像</p> 
<p></p> 
<p>  4.build：服务除了可以基于指定的镜像，还可以基于一份Dockerfile，在使用up启动时执行构建任务，构建标签是build，可以指定Dockerfile所在文件夹的路径。Compose将会利用Dockerfile自动构建镜像，然后使用镜像启动服务容器</p> 
<p>    build：./eureka-server-peer1  #创建镜像,会自动执行当前目录下的eureka-server-peer1文件夹下的Dockerfile</p> 
<p>  </p> 
<p>    注1：build都是一个目录，如果要指定Dockerfile文件需要在build标签的子级标签中使用dockerfile标签指定。</p> 
<p>    注2：如果同时指定image和build两个标签，那么Compose会构建镜像并且把镜像命名为image值指定的名字。</p> 
<p>    注3：更多参数配置介绍请看资料</p> 
<p></p> 
<p>  5.hostname：启动高可用（集群）微服务时，必须与代码配置中的spring.profiles属性一致。例如：peer1、peer2等</p> 
<p>    hostname：peer1/peer2/consumer1/consumer2</p> 
<p></p> 
<p>  6.network_mode：配置服务容器的网络模式</p> 
<p>    network_mode："bridge"</p> 
<p>    network_mode："host"</p> 
<p>    network_mode："none"</p> 
<p>    network_mode："service:[service_name]"</p> 
<p>    network_mode："container:[container name/id]"</p> 
<p></p> 
<p>  7.environment：环境变量配置，可以用数组或字典两种方式</p> 
<p>    environment:</p> 
<p>      RACK_ENV: development</p> 
<p>      SHOW: 'ture'</p> 
<p>      -------------------------</p> 
<p>    environment:</p> 
<p>      - RACK_ENV=development</p> 
<p>      - SHOW=ture</p> 
<p></p> 
<p>   注：更新配置请见资料</p> 
<p>       02 Docker-Compose简介及常用命令.mht</p> 
<p>       03 docker-compose_yml文件详解.mht</p> 
<p></p> 
<p>5.docker-compose命令</p> 
<p>  1）docker-compose up：构建并启动容器</p> 
<p>     #启动单个服务：</p> 
<p>     docker-compose up 服务名称  #服务名称来自于docker-compose.yml中services指定的容器服务名</p> 
<p>     #启动多个服务：</p> 
<p>     docker-compose up</p> 
<p>     #后台启动服务</p> 
<p>     docker-compose up -d</p> 
<p>  </p> 
<p>  2）docker-compose down：停止和删除容器、网络、卷、镜像</p> 
<p></p> 
<p>  3）docker-compose start [服务名称]：启动指定服务或启动所有服务</p> 
<p>  </p> 
<p>  4）docker-compose stop [服务名称]：停止指定服务或停止所有服务</p> 
<p></p> 
<p>  5）docker-compose ps：列出所有运行容器</p> 
<p></p> 
<p>  6）docker-compose exec：进入指定容器</p> 
<p></p> 
<p>  参数：</p> 
<p>  -d 分离模式，后台运行命令。</p> 
<p>  --privileged 获取特权。</p> 
<p>  -user USER 指定运行的用户。</p> 
<p>  -T 禁用分配TTY，默认docker-compose exec分配TTY。</p> 
<p>  --index=index，当一个服务拥有多个容器时，可通过该参数登陆到该服务下的任何服务。</p> 
<p>   </p> 
<p>  例如：docker-compose exec --index=1 web /bin/bash或者/bin/sh ，web服务中包含多个容器</p> 
<p>  7）docker-compose rm：删除所有（停止状态的）服务容器。</p> 
<p></p> 
<p>  参数：</p> 
<p>  -f：强制直接删除，包括非停止状态的容器</p> 
<p>  -v：删除容器所挂载的数据卷</p> 
<p></p> 
<p>  8）docker-compose config -q：验证(docker-compose.yml)文件配置，当配置正确时，不输出任何内容，当文件配置错误，输出错误信息。</p> 
<p></p> 
<p></p> 
<p>6. 综合示例：docker-compose部署nginx，挂载外置配置文件及项目</p> 
<p>   1.docker、docker-compose安装</p> 
<p>   2.自定义配置文件nginx.conf(参考之前课程)</p> 
<p>   3.在docker主机上新建/docker-compose/nginx</p> 
<p>     mkdir -p /docker-compose/nginx &amp;&amp; cd /docker-compose/nginx</p> 
<p>   4.在/docker-compose/nginx目录下创建并编辑docker-compose.yml</p> 
<p>     vim docker-compose.yml</p> 
<p>     详情见：资料/docker-compose-nginx.txt</p> 
<p>   5.后台启动服务</p> 
<p>     docker-compose up -d</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>附录一：docker-compose卸载</p> 
<p>   </p> 
<p>  $ rm /usr/local/bin/docker-compose</p> 
<p>  注：docker-compose卸载只需要删除二进制文件就可以了</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>附录二：docker-compose.yml配置文件介绍（补充）</p> 
<p></p> 
<p>  1）ports：对外暴露的端口定义，和expose对应。例如："宿主机端口:容器暴露端口"</p> 
<p></p> 
<p>  ports："7101:7101"</p> 
<p></p> 
<p>  2）volumes：挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER]格式。</p> 
<p></p> 
<p>  volumes：</p> 
<p>    #只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）</p> 
<p>    - /var/lib/mysql</p> 
<p></p> 
<p>    #使用绝对路径挂载数据卷</p> 
<p>    - /opt/data:/var/lib/mysql</p> 
<p>    </p> 
<p>    #已经存在的命名的数据卷</p> 
<p>    - datavolume:/var/lib/mysql</p> 
<p></p> 
<p>  3）entrypoint：在Dockerfile中有一个指令叫做ENTRYPOINT指令，用于指定接入点。在docker-compose.yml中可以定义接入点，覆盖Dockerfile中的定义。</p> 
<p>  </p> 
<p>  entrypoint：["java","-jar","eureka-server-cluster.jar","--spring.profiles.active=peer1"]</p> 
<p></p> 
<p></p> 
<p>注：详细资料请见资料《Docker-Compose简介及常用命令 - 彼扬 - 博客园.mht》</p> 
<p></p> 
<p></p> 
<p>附录三：docker-compose命令（补充）</p> 
<p></p> 
<p>  1）docker-compose build：构建（重新构建）项目中的服务容器</p> 
<p></p> 
<p>  2）docker-compose create：为服务创建容器</p> 
<p></p> 
<p>  参数：</p> 
<p>  -force-recreate：重新创建容器，即使配置和镜像没有改变，不兼容–no-recreate参数</p> 
<p>  -no-recreate：如果容器已经存在，不需要重新创建，不兼容–force-recreate参数</p> 
<p>  -no-build：不创建镜像，即使缺失</p> 
<p>  -build：创建容器前，生成镜像</p> 
<p></p> 
<p>  3）docker-compose version：打印版本信息。</p> 
<p></p> 
<p>  4）docker-compose logs [服务名称]：查看容器输出日志</p> 
<p></p> 
<p>  #查看nginx的日志</p> 
<p>  docker-compose logs  nginx                     </p> 
<p>  #查看nginx的实时日志</p> 
<p>  docker-compose logs -f nginx      </p> 
<p></p> 
<p></p> 
<p>注：详细资料请见资料《Docker-Compose简介及常用命令 - 彼扬 - 博客园.mht》</p> 
<p></p> 
<p></p> 
<p>附录四：配置虚拟机防火墙允许访问测试</p> 
<p></p> 
<p>  $ firewall-cmd --zone=public --add-port=7101/tcp --permanent</p> 
<p>  $ firewall-cmd --reload</p> 
<p></p> 
<p></p> 
<p></p> 
<p>Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。</p> 
<p>Docker-Compose的工程配置文件默认为docker-compose.yml，可通过环境变量COMPOSE_FILE或-f参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。</p> 
<p>使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p> 
<p>Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p> 
<p>Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理</p> 
<p></p> 
<p>安装docker-compose  二进制文件</p> 
<p></p> 
<p>配置的docker-compose.yml</p> 
<p></p> 
<p></p> 
<p>version: '3'</p> 
<p>services:</p> 
<p>  mynginx:</p> 
<p>    #定义主机名</p> 
<p>    container_name: mynginx</p> 
<p>    #使用的镜像</p> 
<p>    image: nginx</p> 
<p>    #容器的映射端口</p> 
<p>    ports:</p> 
<p>      - 80:80</p> 
<p>    #定义挂载点</p> 
<p>    volumes:</p> 
<p>      - /data/nginx/html:/usr/share/nginx/html</p> 
<p>      - /data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf</p> 
<p>      - /data/nginx/log:/var/log/nginx</p> 
<p>    #指定容器网络</p> 
<p>    networks:</p> 
<p>      - mynet</p> 
<p>    #docker 重启后，容器自启动</p> 
<p>    restart: always</p> 
<p>  mycentos:</p> 
<p>    container_name: mysql</p> 
<p>    image: mysql</p> 
<p>    ports:</p> 
<p>      - 3306:3306</p> 
<p>    volumes:</p> 
<p>      - /data/mysql/conf/my.cnf:/etc/my.cnf</p> 
<p>      - /data/mysql/data:/var/lib/mysql</p> 
<p>    networks:</p> 
<p>      - mynet</p> 
<p>networks:</p> 
<p>  mynet:</p> 
<p>    driver: bridge</p> 
<p></p> 
<p><img alt="" height="597" src="https://images2.imgbox.com/24/66/JSM1VdQm_o.png" width="659"><img alt="" height="562" src="https://images2.imgbox.com/02/c1/FAll64u4_o.jpg" width="800"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/15d150021cb928346db01f2c9b35f4f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Window下80端口被PID=4进程占用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec0de17bfdb9fd3043ad8af5a5683feb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql-installer安装教程（详细图文）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>