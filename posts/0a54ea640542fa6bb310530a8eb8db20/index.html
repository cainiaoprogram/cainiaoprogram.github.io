<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用docker-compose和docker swarm，部署container服务 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用docker-compose和docker swarm，部署container服务" />
<meta property="og:description" content="在之前的工作中，我一直使用docker run命令，单独启动container，再加入overlay网络，以实现部署工作。这种方式看似直接，但是随着服务包含的container个数越来越多，docker命令也就越来越多，由此带来许多重复工作。
在官网上看到，docker-compose可以执行container编排（容器编排），尤其是compose file -v3版本加入了许多功能，可以方便地把服务中的container部署在单个docker节点或者多个swarm节点上。考虑到目前的使用情况，我们确实到了需要使用docker高级特性的阶段，所以进行实践。
分享一个示例：https://hackernoon.com/deploy-docker-compose-v3-to-swarm-mode-cluster-4159e9cca712#.lyx2e8fd9
上面的例子描述了，如何使用compose file v3和swarm，构建一个投票系统。与本文的区别：实例中运用了docker stack deploy在多个docker swarm节点上部署应用服务；本文采用docker-compose up，分别在两台docker节点上面部署应用容器。 1. 使用docker-compose，进行container编排 docker-compose是容器编排的利器，那么我们应该如何使用呢？
1.1 业务需求 我们的业务：在两台docker主机上，分别建立一组服务。简单起见，我把docker节点命名为nodeDB和nodeService。顾名思义，我们要在nodeDB上面建立database服务（部署oracle），在nodeService上部署应用容器。容器之间的跨主机通信就是通过swarm的overlay网络完成。
1.2 编写dockerfile FROM 172.100.1.15:5000/oracle11g_server_v3 RUN mkdir /frs/ COPY /cafisFRSDB/ /frs/ COPY /cafisFRSDB/listener.ora /app/oracle/11.2.0/network/admin/ CMD [&#34;/bin/bash&#34;, &#34;/frs/startup.sh&#34;] dockerfile内容很简单，就是copy文件；CMD就是在启动container时，执行shell脚本（启动oracle服务和实例，实现业务逻辑）。 1.3 编写docker-compose.yml version: &#39;3&#39; services: frs_orasvr: build: context: ./frsDB dockerfile: Dockerfile image: frs_orasvr_img:v1 container_name: frs_orasvr hostname: frs_orasvr ports: - &#34;1521:1521&#34; volumes: - /DATA/compose_frs/frsDB/cafisFRSDB/:/frs networks: - qrtSwamComposeNet networks: qrtSwamComposeNet: driver: overlay 注意几个内容：
networks: 在compose file v3中，docker允许通过networks关键字，定义一个基于 docker0网桥的subnet，然后把我们的服务加到这个subnet中，这样实现了服务之间的隔离。一旦不需要这组服务，我们可以通过命令docker-compose down卸载服务和对应的subnet，不会对其他服务造成影响。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0a54ea640542fa6bb310530a8eb8db20/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-12T20:52:21+08:00" />
<meta property="article:modified_time" content="2018-04-12T20:52:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用docker-compose和docker swarm，部署container服务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在之前的工作中，我一直使用<code>docker run</code>命令，单独启动container，再加入overlay网络，以实现部署工作。这种方式看似直接，但是随着服务包含的container个数越来越多，docker命令也就越来越多，由此带来许多重复工作。</p> 
<p>在官网上看到，docker-compose可以执行container编排（容器编排），尤其是compose file -v3版本加入了许多功能，可以方便地把服务中的container部署在单个docker节点或者多个swarm节点上。考虑到目前的使用情况，我们确实到了需要使用docker高级特性的阶段，所以进行实践。</p> 
<p>分享一个示例：<a href="https://hackernoon.com/deploy-docker-compose-v3-to-swarm-mode-cluster-4159e9cca712#.lyx2e8fd9" rel="nofollow">https://hackernoon.com/deploy-docker-compose-v3-to-swarm-mode-cluster-4159e9cca712#.lyx2e8fd9</a></p> 
<p>上面的例子描述了，如何使用compose file v3和swarm，构建一个投票系统。与本文的区别：实例中运用了<code>docker stack deploy</code>在多个docker swarm节点上部署应用服务；本文采用<code>docker-compose up</code>，分别在两台docker节点上面部署应用容器。 <br> <br></p> 
<h3 id="1-使用docker-compose进行container编排">1. 使用docker-compose，进行container编排</h3> 
<p>docker-compose是容器编排的利器，那么我们应该如何使用呢？</p> 
<h4 id="11-业务需求">1.1 业务需求</h4> 
<p>我们的业务：在两台docker主机上，分别建立一组服务。简单起见，我把docker节点命名为nodeDB和nodeService。顾名思义，我们要在nodeDB上面建立database服务（部署oracle），在nodeService上部署应用容器。容器之间的跨主机通信就是通过swarm的overlay网络完成。</p> 
<h4 id="12-编写dockerfile">1.2 编写dockerfile</h4> 
<pre class="prettyprint"><code class=" hljs coffeescript">FROM <span class="hljs-number">172.100</span><span class="hljs-number">.1</span><span class="hljs-number">.15</span>:<span class="hljs-number">5000</span>/oracle11g_server_v3

RUN mkdir <span class="hljs-regexp">/frs/</span>
COPY <span class="hljs-regexp">/cafisFRSDB/</span> <span class="hljs-regexp">/frs/</span>
COPY <span class="hljs-regexp">/cafisFRSDB/listener.ora /app/oracle/11.2.0/network/admin/</span>

CMD [<span class="hljs-string">"/bin/bash"</span>, <span class="hljs-string">"/frs/startup.sh"</span>]</code></pre> 
<p>dockerfile内容很简单，就是copy文件；CMD就是在启动container时，执行shell脚本（启动oracle服务和实例，实现业务逻辑）。 </p> 
<h4 id="13-编写docker-composeyml">1.3 编写docker-compose.yml</h4> 
<pre class="prettyprint"><code class="language-yaml hljs http"><span class="hljs-attribute">version</span>: <span class="hljs-string">'3'</span>

<span class="haml">services:
  frs_orasvr:
    build:
      context: ./frsDB
      dockerfile: Dockerfile
    image: frs_orasvr_img:v1
    container_name: frs_orasvr
    hostname: frs_orasvr
    ports:
      -<span class="ruby"> <span class="hljs-string">"1521:1521"</span>
</span>    volumes:
      -<span class="ruby"> /<span class="hljs-constant">DATA</span>/compose_frs/frsDB/cafisFRSDB/<span class="hljs-symbol">:/frs</span>
</span>    networks:
      -<span class="ruby"> qrtSwamComposeNet
</span>
networks:
  qrtSwamComposeNet:
    driver: overlay</span></code></pre> 
<p>注意几个内容：</p> 
<ul><li><p>networks: 在compose file v3中，docker允许通过networks关键字，定义一个基于 docker0网桥的subnet，然后把我们的服务加到这个subnet中，这样实现了服务之间的隔离。一旦不需要这组服务，我们可以通过命令<code>docker-compose down</code>卸载服务和对应的subnet，不会对其他服务造成影响。</p></li><li><p>build: 通过build命令，我们可以指定加载哪个dockerfile。我们可以把base image定制为自己的image，这些定制化的步骤可以用dockerfile记录下来。docker image和dockerfile都可在开发人员之间共享。如果image过大不便其他人员pull拉取，我们可以共享dockerfile，使他人在本地构建image。</p></li><li><p>其他docker-compose文件指令可参见compose语法。</p></li></ul> 
<h4 id="14-启动docker服务">1.4 启动docker服务</h4> 
<p>现在我们到docker-compose.yml文件所在的目录，启动服务</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor"># cd /parh/to/docker-compose.yml</span>

<span class="hljs-preprocessor"># docker-compose up</span>

<span class="hljs-preprocessor"># docker-compose ps      // 检查服务是否启动</span></code></pre> 
<p>检查网络</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-comment"># docker network ls</span>

NETWORK ID          NAME                      DRIVER              SCOPE
p729h9nw2mxo        composefrs_qrtSwamComposeNet   overlay          swarm
efd78e72a392        bridge                    bridge              <span class="hljs-built_in">local</span>
e08545f73ee1        docker_gwbridge           bridge              <span class="hljs-built_in">local</span>
<span class="hljs-number">60</span>fb66247b73        host                      host                <span class="hljs-built_in">local</span>
<span class="hljs-number">2</span>th1f3svyriy        ingress                   overlay             swarm
<span class="hljs-number">1527</span>c9d992e8        kj66be_net                bridge              <span class="hljs-built_in">local</span>
c060dea57803        kj66interchange_default   bridge              <span class="hljs-built_in">local</span>
c7d9e786b990        <span class="hljs-constant">none</span>                      <span class="hljs-constant">null</span>                <span class="hljs-built_in">local</span></code></pre> 
<p>检查imge</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-comment"># docker image ls</span>

REPOSITORY    TAG     IMAGE ID      CREATED        SIZE
frs_orasvr_img  v1  <span class="hljs-number">6e774</span>eb7ee64  <span class="hljs-number">2</span> hours ago    <span class="hljs-number">207</span>MB
&lt;<span class="hljs-constant">none</span>&gt;        &lt;<span class="hljs-constant">none</span>&gt;  e0f9577e8ef7  <span class="hljs-number">2</span> hours ago    <span class="hljs-number">207</span>MB</code></pre> 
<p>compose运行image，生成container，并且调用shell脚本</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor"># docker ps</span></code></pre> 
<p>伸缩容器</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor"># docker-compose up --scale harbor-adminserver=2     </span>

<span class="hljs-comment">// 需要指定对应容器的副本个数</span></code></pre> 
<p>到此，我们在nodeDB上面的工作就完成了。</p> 
<h4 id="1-5-启动nodeservice服务">1. 5 启动NodeService服务</h4> 
<p>NodeService的docker-compose.yml我们要在这个host (swarm node) 部署服务，服务中的container需要与之前node上面oracle服务通信。直接上code (简单起见，只列出了services 中的一个 container)</p> 
<pre class="prettyprint"><code class=" hljs http"><span class="hljs-attribute">version</span>: <span class="hljs-string">'3'</span>

<span class="haml">services:
  frs_ftsoft:
    build:
      context: ./ftsoft
      dockerfile: Dockerfile
    image: frs_ftsoft_img:v1
    networks:
      -<span class="ruby"> composefrs_qrtSwamComposeNet
</span>    container_name: frs_ftsoft
    hostname: frs_ftsoft
    mac_address: xx:xx:xx:xx:xx:xx
    volumes:
     -<span class="ruby"> /data/<span class="hljs-constant">CabisSvr</span>/<span class="hljs-constant">DockerFrs</span>/<span class="hljs-symbol">ftsoft:</span>/frs
</span>
networks:
  composefrs_qrtSwamComposeNet:
    external: true</span></code></pre> 
<p>Compose文件中使用的dockerfile内容与上个差不多，在这里就不多说了。</p> 
<p>注意：</p> 
<ul><li><p>由于之前在nodeDB的compose file里已经创建了网络，我们这里需要指定为external：true （不需要在创建了），在container里面加入即可。</p></li><li><p>我们直接运行<code>docker-compose up</code>会报错，内容大致为找不到指定网络。这是由于之前在nodeDB上面创建的network不会自动在新的node上显示（官方说法），所以我们需要先在nodeService上面运行一个container，让其加入网络“composefrs_qrtSwamComposeNet”，例如：</p></li></ul> 
<pre class="prettyprint"><code class=" hljs brainfuck"><span class="hljs-comment">#</span> <span class="hljs-comment">docker</span> <span class="hljs-comment">run</span> <span class="hljs-literal">-</span><span class="hljs-comment">d</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">name=mybusybox</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">network=composefrs_qrtSwamComposeNet</span> <span class="hljs-comment">busybox</span> <span class="hljs-comment">/bin/sh</span></code></pre> 
<p>之后，我们便可以在nodeService上看到composefrs_qrtSwamComposeNet网络，此时再运行<code>docker-compose up</code>就好了。 <br> <br></p> 
<h3 id="2-使用docker-swarm进行stack编排">2. 使用docker swarm，进行stack编排</h3> 
<p>在nodeDB和nodeService节点上，通过运行两次<code>docker-compose up</code>命令，我们实现了手动在不同的docker节点上运行容器。</p> 
<p>用docker stack的方式部署nodeDB</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor"># cd /path/to/docker-compose.yml</span>

<span class="hljs-preprocessor"># docker stack deploy -c docker-compose.yml stack_name</span>

<span class="hljs-preprocessor"># docker stack ls</span>

<span class="hljs-preprocessor"># docker service ls</span>

<span class="hljs-preprocessor"># docker service scale service_name=10</span></code></pre> 
<p>同理，对于nodeService使用相同的方法。</p> 
<p>第二种方式最大好处是在多台docker swarm节点（swarm集群，不用关心应用容器在哪个docker swarm节点上，集群节点易于扩充）上完成部署（传说中的一键部署），最终服务以service端口映射宿主机端口的方式，展现给外部用户。 <br> <br></p> 
<h3 id="3-参考文章">3. 参考文章</h3> 
<p><a href="https://www.cnblogs.com/atuotuo/p/6588331.html" rel="nofollow">https://www.cnblogs.com/atuotuo/p/6588331.html</a></p> 
<p><a href="https://blog.csdn.net/pmlpml/article/details/53786575?locationNum=1&amp;fps=1">https://blog.csdn.net/pmlpml/article/details/53786575?locationNum=1&amp;fps=1</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea73f7233089125e6f8255fbfe66ca2d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">寻找链表环的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d79c79d0a619bcece6ae56d921d4464c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第005篇：ArcGIS中批量删除Default.gdb中的冗余数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>