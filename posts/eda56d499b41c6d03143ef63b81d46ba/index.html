<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用Go构建一个Postgres流平台 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用Go构建一个Postgres流平台" />
<meta property="og:description" content="使用 Go 通道从拉推模型转向更高效的流方法。这通过重叠拉取和推送阶段来提高性能，减少总体处理时间和延迟。
Go通道提供数据同步、资源管理和并发处理。它们允许 goroutine 安全地通信和交换数据。这些源实现了每秒 10-12k 事务的吞吐量，最小延迟为 1-5 秒，比之前使用拉推的 30 秒有了显着改进。
在PeerDB，我们的使命是创建一个 Postgres 优先的数据移动平台，使数据从 Postgres 流式传输到数据仓库、队列和存储变得快速、简单。我们的工程重点围绕数据移动速度提高 10 倍、成本效益和硬件优化。
在这篇博文中，我们将深入探讨最近从拉推模型到使用Go goroutine 的更高效流媒体方法的转变。让我们探讨为什么流式传输至关重要，以及这种变化如何显着提高性能。
Pull-and-Push推拉模型
拉推模式：将行提取到内存中的一个数组，然后将它们移动到目标位置。
虽然这种方法在批量较小的情况下效果不错，但在批量较大的情况下就出现了问题。
具体来说，我们无法在拉取的同时并行推送，导致管道效率不高。在我们的典型设置中，拉取和推送时间的比例为 60-40。
_// sync all the records normally, then apply the schema delta after NormalizeFlow._type RecordsWithTableSchemaDelta struct {
RecordBatch *RecordBatch // wrapper for &#34;Records []Record&#34; TableSchemaDeltas []*protos.TableSchemaDelta
RelationMessageMapping RelationMessageMapping
}
转向流式处理
我们的新方法是在从 PostgreSQL 提取数据的同时，分批缓冲并并发地将数据推送到目标（如 Snowflake）。这种流水线式数据传输具有显著优势：
提高效率：管道化允许我们重叠拉取和推送阶段，从而减少整体处理时间。减少延迟：使用流水线技术，数据可以更快地到达目的地，从而提高整个系统的响应速度。 这是更改后的共享结构：
type CDCRecordStream struct {
// Records are a list of json objects." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/eda56d499b41c6d03143ef63b81d46ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-08T06:11:42+08:00" />
<meta property="article:modified_time" content="2023-11-08T06:11:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用Go构建一个Postgres流平台</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>使用 Go 通道从拉推模型转向更高效的流方法。这通过重叠拉取和推送阶段来提高性能，减少总体处理时间和延迟。</p> 
<p>Go通道提供数据同步、资源管理和并发处理。它们允许 goroutine 安全地通信和交换数据。这些源实现了每秒 10-12k 事务的吞吐量，最小延迟为 1-5 秒，比之前使用拉推的 30 秒有了显着改进。</p> 
<p>在<a href="http://peerdb.io/" rel="nofollow">PeerDB</a>，我们的使命是创建一个 Postgres 优先的数据移动平台，使数据从 Postgres 流式传输到数据仓库、队列和存储变得快速、简单。我们的工程重点围绕数据移动速度提高 10 倍、成本效益和硬件优化。</p> 
<p>在这篇博文中，我们将深入探讨最近从拉推模型到使用Go goroutine 的更高效流媒体方法的转变。让我们探讨为什么流式传输至关重要，以及这种变化如何显着提高性能。</p> 
<p><strong>Pull-and-Push推拉模型</strong><br> 拉推模式：将行提取到内存中的一个数组，然后将它们移动到目标位置。</p> 
<p>虽然这种方法在批量较小的情况下效果不错，但在批量较大的情况下就出现了问题。</p> 
<p>具体来说，我们无法在拉取的同时并行推送，导致管道效率不高。在我们的典型设置中，拉取和推送时间的比例为 60-40。</p> 
<p>_// sync all the records normally, then apply the schema delta after NormalizeFlow._type RecordsWithTableSchemaDelta struct {<!-- --><br> RecordBatch            *RecordBatch <em>// wrapper for "Records []Record"</em> TableSchemaDeltas      []*protos.TableSchemaDelta<br> RelationMessageMapping RelationMessageMapping<br> }</p> 
<p><strong>转向流式处理</strong><br> 我们的新方法是在从 PostgreSQL 提取数据的同时，分批缓冲并并发地将数据推送到目标（如 Snowflake）。这种流水线式数据传输具有显著优势：</p> 
<ul><li>提高效率：管道化允许我们重叠拉取和推送阶段，从而减少整体处理时间。</li><li>减少延迟：使用流水线技术，数据可以更快地到达目的地，从而提高整个系统的响应速度。</li></ul> 
<p>这是更改后的共享结构：</p> 
<p>type CDCRecordStream struct {<!-- --><br> <em>// Records are a list of json objects.</em> records chan Record <em>// Schema changes from the slot</em> SchemaDeltas chan *protos.TableSchemaDelta <em>// Relation message mapping</em> RelationMessageMapping chan *RelationMessageMapping <em>// ... other fields</em><br> }</p> 
<p><strong>利用 Go Channels 进行流式传输</strong><br> Go Channels 用于实现 Go 程序中 goroutine（并发函数）之间的通信和同步。通道允许一个 goroutine 向另一个 goroutine 发送数据，并提供一种安全的信息交换方式。以下是 Go 通道提供的一些好处：</p> 
<ul><li>数据同步： Go 通道提供对数据同步的精细控制，防止竞争条件并确保数据流经系统时的一致性。</li><li>资源管理： Go 通道的满负荷阻塞行为可防止数据过载，降低内存不足 (OOM) 错误的风险并确保稳定性。</li><li>并发处理： Go 通道可实现高效的并发数据处理，优化资源利用率并在数据检索、转换和插入方面实现高吞吐量。</li><li>错误处理：使用<a href="https://go.dev/tour/concurrency/5" rel="nofollow">select 语句的</a>内置错误处理机制提高了系统的健壮性，使我们能够优雅地响应异常并保持可靠性。[这](<a href="https://github.com/PeerDB-io/peerdb/blob/57abb885e3e989119bff723340f9d648f5c369bd/flow/connectors/postgres/qrep_query_executor.go">https://github.com/PeerDB-io/peerdb/blob/57abb885e3e989119bff723340f9d648f5c369bd/flow/connectors/postgres/qrep_query_executor.go</a><a href="/query/searchAction.shtml?query=L" rel="nofollow noopener noreferrer" target="_blank"><b>L</b></a>184)是我们在 Go 通道中处理错误的实现</li><li>与 Postgres 逻辑复制的协同：我们使用逻辑复制槽从 Postgres 管理 CDC。[START_REPLICATION](<a href="https://www.postgresql.org/docs/current/protocol-replication.html" rel="nofollow">https://www.postgresql.org/docs/current/protocol-replication.html</a><a href="/query/searchAction.shtml?query=PROTOCOL" rel="nofollow noopener noreferrer" target="_blank"><b>PROTOCOL</b></a>-REPLICATION-START-REPLICATION)将给定 wal 位置处的 Postgres 更改传输到我们的缓冲区通道中，并等待我们请求下一个更改。Go 通道提供的反压机制和 START_REPLICATION 的流功能齐头并进，通过控制内存利用率来确保弹性。</li></ul> 
<p>在最初的规模测试中，我们实现了：</p> 
<ul><li> <p>吞吐量：每秒 10-12k 事务 (TPS)</p> </li><li> <p>最小延迟： 1-5 秒</p> </li></ul> 
<p>前完成类似任务大约需要 30 秒。</p> 
<p><a href="https://www.jdon.com/69634.html" rel="nofollow">https://www.jdon.com/69634.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a5a815489cf91e1b885040a7989b64f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java的JDBC编程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3efac4246fb2c600357c90fe6046642/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ansible 安装与使用/ssh免密互信-以及解决免密不生效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>