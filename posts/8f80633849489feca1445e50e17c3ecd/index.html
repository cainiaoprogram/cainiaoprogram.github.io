<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s——污点、容忍&#43;3个存储卷（emptyDir、hostpath和nfs） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s——污点、容忍&#43;3个存储卷（emptyDir、hostpath和nfs）" />
<meta property="og:description" content="k8s——污点、容忍&#43;3个存储卷（emptyDir、hostpath和nfs） 污点(Taint)和容忍(Tolerations)污点(Taint)概念污点的组成格式effect支持如下三个选项master上的NoSchedule污点node上设置污点去除污点污点实例测试 容忍(Tolerations)概念测试污点在设置污点的基础上设置容忍容忍的其他注意事项node升级时，设置污点的流程 Pod启动阶段（相位 phase）pod启动过程phase的状态故障排除步骤对节点执行维护操作:删除节点上的pod数据将Node标记为不可调度的状态用drain删除pod数据将Node标记为可调度的状态 存储卷emptyDir存储卷hostPath存储卷nfs共享存储卷另起服务器nfs01节点在master节点和node节点配置映射主节点操作在nfs服务器额外写网页文件 污点(Taint)和容忍(Tolerations) 污点(Taint) 概念 节点亲和性，是Pod的一种属性（偏好或硬性要求），它使Pod被吸引到一类特定的节点。Taint则相反，它使节点能够排斥一类特定的PodTaint和Toleration相互配合，可以用来避免Pod被分配到不合适的节点上。每个节点上都可以应用一个或多个taint ，这表示对于那些不能容忍这些taint的Pod，是不会被该节点接受的。如果将toleration应用于Pod上，则表示这些 Pod 可以（但不一定）被调度到具有匹配taint的节点上使用kubectl taint命令可以给某个Node节点设置污点，Node被设置上污点之后就和 Pod 之间存在了一种相斥的关系，可以让Node拒绝 Pod 的调度执行，甚至将Node已经存在的Pod驱逐出去 污点的组成格式 key=value:effect 每个污点有一个key和value作为污点的标签，其中value可以为空，effect描述污点的作用 effect支持如下三个选项 ●NoSchedule：表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上 ●PreferNoSchedule：表示 k8s 将尽量避免将 Pod 调度到具有该污点的 Node 上 ●NoExecute：表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上，同时会将 Node 上已经存在的 Pod 驱逐出去 master上的NoSchedule污点 master 就是因为有 NoSchedule 污点，k8s 才不会将 Pod 调度到 master 节点上 kubectl describe node master01 node上设置污点 #设置污点 kubectl taint nodes node01 key1=value1:NoSchedule #节点说明中，查找 Taints 字段 kubectl describe node node01 去除污点 #去除污点 kubectl taint nodes node01 key1:NoSchedule- #节点说明中，查找 Taints 字段 kubectl describe node node01 污点实例测试 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8f80633849489feca1445e50e17c3ecd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-13T09:17:46+08:00" />
<meta property="article:modified_time" content="2022-04-13T09:17:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s——污点、容忍&#43;3个存储卷（emptyDir、hostpath和nfs）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>k8s——污点、容忍+3个存储卷（emptyDir、hostpath和nfs）</h4> 
 <ul><li><a href="#TaintTolerations_2" rel="nofollow">污点(Taint)和容忍(Tolerations)</a></li><li><ul><li><a href="#Taint_4" rel="nofollow">污点(Taint)</a></li><li><ul><li><a href="#_6" rel="nofollow">概念</a></li><li><a href="#_12" rel="nofollow">污点的组成格式</a></li><li><a href="#effect_20" rel="nofollow">effect支持如下三个选项</a></li><li><a href="#masterNoSchedule_28" rel="nofollow">master上的NoSchedule污点</a></li><li><a href="#node_37" rel="nofollow">node上设置污点</a></li><li><a href="#_50" rel="nofollow">去除污点</a></li><li><a href="#_63" rel="nofollow">污点实例测试</a></li></ul> 
   </li><li><a href="#Tolerations_78" rel="nofollow">容忍(Tolerations)</a></li><li><ul><li><a href="#_80" rel="nofollow">概念</a></li><li><a href="#_84" rel="nofollow">测试污点</a></li><li><a href="#_110" rel="nofollow">在设置污点的基础上设置容忍</a></li><li><a href="#_143" rel="nofollow">容忍的其他注意事项</a></li><li><a href="#node_157" rel="nofollow">node升级时，设置污点的流程</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Pod_phase_170" rel="nofollow">Pod启动阶段（相位 phase）</a></li><li><ul><li><a href="#pod_172" rel="nofollow">pod启动过程</a></li><li><a href="#phase_181" rel="nofollow">phase的状态</a></li><li><a href="#_195" rel="nofollow">故障排除步骤</a></li><li><a href="#pod_217" rel="nofollow">对节点执行维护操作:删除节点上的pod数据</a></li><li><ul><li><a href="#Node_219" rel="nofollow">将Node标记为不可调度的状态</a></li><li><a href="#drainpod_234" rel="nofollow">用drain删除pod数据</a></li><li><a href="#Node_252" rel="nofollow">将Node标记为可调度的状态</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_265" rel="nofollow">存储卷</a></li><li><ul><li><a href="#emptyDir_267" rel="nofollow">emptyDir存储卷</a></li><li><a href="#hostPath_313" rel="nofollow">hostPath存储卷</a></li><li><a href="#nfs_364" rel="nofollow">nfs共享存储卷</a></li><li><ul><li><a href="#nfs01_366" rel="nofollow">另起服务器nfs01节点</a></li><li><a href="#masternode_400" rel="nofollow">在master节点和node节点配置映射</a></li><li><a href="#_408" rel="nofollow">主节点操作</a></li><li><a href="#nfs_445" rel="nofollow">在nfs服务器额外写网页文件</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="TaintTolerations_2"></a>污点(Taint)和容忍(Tolerations)</h2> 
<h3><a id="Taint_4"></a>污点(Taint)</h3> 
<h4><a id="_6"></a>概念</h4> 
<ol><li>节点亲和性，是Pod的一种属性（偏好或硬性要求），它使Pod被吸引到一类特定的节点。Taint则相反，它使节点能够排斥一类特定的Pod</li><li>Taint和Toleration相互配合，可以用来避免Pod被分配到不合适的节点上。每个节点上都可以应用一个或多个taint ，这表示对于那些不能容忍这些taint的Pod，是不会被该节点接受的。如果将toleration应用于Pod上，则表示这些 Pod 可以（但不一定）被调度到具有匹配taint的节点上</li><li>使用kubectl taint命令可以给某个Node节点设置污点，Node被设置上污点之后就和 Pod 之间存在了一种相斥的关系，可以让Node拒绝 Pod 的调度执行，甚至将Node已经存在的Pod驱逐出去</li></ol> 
<h4><a id="_12"></a>污点的组成格式</h4> 
<pre><code class="prism language-vbnet"><span class="token keyword">key</span><span class="token operator">=</span>value<span class="token punctuation">:</span>effect

每个污点有一个<span class="token keyword">key</span>和value作为污点的标签，其中value可以为空，effect描述污点的作用
</code></pre> 
<h4><a id="effect_20"></a>effect支持如下三个选项</h4> 
<pre><code class="prism language-mipsasm">●NoSchedule：表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上
●PreferNoSchedule：表示 k8s 将尽量避免将 Pod 调度到具有该污点的 Node 上
●NoExecute：表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上，同时会将 Node 上已经存在的 Pod 驱逐出去
</code></pre> 
<h4><a id="masterNoSchedule_28"></a>master上的NoSchedule污点</h4> 
<pre><code class="prism language-sql">master 就是因为有 NoSchedule 污点，k8s 才不会将 Pod 调度到 master 节点上
kubectl <span class="token keyword">describe</span> node master01
</code></pre> 
<p><img src="https://images2.imgbox.com/24/1f/bhH0tT2O_o.png" alt="img"></p> 
<h4><a id="node_37"></a>node上设置污点</h4> 
<pre><code class="prism language-bash"><span class="token comment">#设置污点</span>
kubectl taint nodes node01 <span class="token assign-left variable">key1</span><span class="token operator">=</span>value1:NoSchedule

<span class="token comment">#节点说明中，查找 Taints 字段</span>
kubectl describe <span class="token function">node</span> node01
</code></pre> 
<p><img src="https://images2.imgbox.com/39/06/yR20MaBM_o.png" alt="img"><br> <img src="https://images2.imgbox.com/42/09/r8icCMho_o.png" alt="img"></p> 
<h4><a id="_50"></a>去除污点</h4> 
<pre><code class="prism language-bash"><span class="token comment">#去除污点</span>
kubectl taint nodes node01 key1:NoSchedule-

<span class="token comment">#节点说明中，查找 Taints 字段</span>
kubectl describe <span class="token function">node</span> node01
</code></pre> 
<p><img src="https://images2.imgbox.com/ce/1a/esm7GG0L_o.png" alt="img"><br> <img src="https://images2.imgbox.com/07/d5/T573M1b3_o.png" alt="img"></p> 
<h4><a id="_63"></a>污点实例测试</h4> 
<pre><code class="prism language-sql"><span class="token number">1.</span>先创建两个pod资源分别在两个node节点上
kubectl get pods <span class="token operator">-</span>o wide

<span class="token number">2.</span>在node02上创建污点
kubectl taint nodes node02 <span class="token keyword">check</span><span class="token operator">=</span>mycheck:NoExecute

<span class="token number">3.</span>kubectl get pods <span class="token operator">-</span>o wide
查看 Pod 状态，会发现 node02 上的 Pod 已经被全部驱逐（注：如果是 Deployment 或者 StatefulSet 资源类型，为了维持副本数量则会在别的 Node 上再创建新的 Pod
</code></pre> 
<p><img src="https://images2.imgbox.com/8f/20/gI4h8DgB_o.png" alt="img"></p> 
<h3><a id="Tolerations_78"></a>容忍(Tolerations)</h3> 
<h4><a id="_80"></a>概念</h4> 
<p>设置了污点的 Node 将根据 taint 的 effect:NoSchedule、PreferNoSchedule、NoExecute 和 Pod 之间产生互斥的关系，Pod 将在一定程度上不会被调度到 Node 上。但我们可以在 Pod 上设置容忍(Tolerations)，意思是设置了容忍的 Pod 将可以容忍污点的存在，可以被调度到存在污点的Node上</p> 
<h4><a id="_84"></a>测试污点</h4> 
<pre><code class="prism language-yaml">1.在node02设置污点的基础上，再在node01上设置污点
kubectl taint nodes node01 check=mycheck<span class="token punctuation">:</span>NoExecute

2.vim demo1.yaml
==========================================================
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp03
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp03
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp01
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
==========================================================
3.kubectl apply <span class="token punctuation">-</span>f demo1.yaml

4.kubectl get pods <span class="token punctuation">-</span>o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/d8/ea/FrOeZ7ln_o.png" alt="img"></p> 
<h4><a id="_110"></a>在设置污点的基础上设置容忍</h4> 
<pre><code class="prism language-yaml">vim demo2.yaml
==========================================================
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp04
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp04
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp01
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"check"</span>
    <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Equal"</span>
    <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"mycheck"</span>
    <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoExecute"</span>
    <span class="token key atrule">tolerationSeconds</span><span class="token punctuation">:</span> <span class="token number">15</span>
==========================================================
<span class="token comment">#其中的 key、vaule、effect 都要与 Node 上设置的 taint 保持一致</span>
<span class="token comment">#operator 的值为 Exists 将会忽略 value 值，即存在即可</span>
<span class="token comment">#tolerationSeconds 用于描述当 Pod 需要被驱逐时可以在 Pod 上继续保留运行的时间</span>
==========================================================
kubectl apply <span class="token punctuation">-</span>f demo2.yaml

kubectl get pods <span class="token punctuation">-</span>o wide <span class="token punctuation">-</span>w
</code></pre> 
<p><img src="https://images2.imgbox.com/36/e7/eXMeMKlT_o.png" alt="img"></p> 
<h4><a id="_143"></a>容忍的其他注意事项</h4> 
<pre><code class="prism language-vbnet"><span class="token number">1.</span>当不指定 <span class="token keyword">key</span> 值时，表示容忍所有的污点 <span class="token keyword">key</span>
  tolerations<span class="token punctuation">:</span>
  <span class="token operator">-</span> <span class="token keyword">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span>  
<span class="token number">2.</span>当不指定 effect 值时，表示容忍所有的污点作用
  tolerations<span class="token punctuation">:</span>
  <span class="token operator">-</span> <span class="token keyword">key</span><span class="token punctuation">:</span> <span class="token string">"key"</span>
    <span class="token keyword">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span>
<span class="token number">3.</span>有多个 Master 存在时，防止资源浪费，可以如下设置
kubectl taint nodes Master<span class="token operator">-</span><span class="token keyword">Name</span> node<span class="token operator">-</span>role.kubernetes.io<span class="token operator">/</span>master<span class="token operator">=</span><span class="token punctuation">:</span>PreferNoSchedule
</code></pre> 
<h4><a id="node_157"></a>node升级时，设置污点的流程</h4> 
<pre><code class="prism language-cpp"><span class="token comment">//如果某个 Node 更新升级系统组件，为了防止业务长时间中断，可以先在该 Node 设置 NoExecute 污点，把该 Node 上的 Pod 都驱逐出去</span>
kubectl taint nodes node01 check<span class="token operator">=</span>mycheck<span class="token operator">:</span>NoExecute

<span class="token comment">//此时如果别的 Node 资源不够用，可临时给 Master 设置 PreferNoSchedule 污点，让 Pod 可在 Master 上临时创建</span>
kubectl taint nodes master node<span class="token operator">-</span>role<span class="token punctuation">.</span>kubernetes<span class="token punctuation">.</span>io<span class="token operator">/</span>master<span class="token operator">=</span><span class="token operator">:</span>PreferNoSchedule

<span class="token comment">//待所有 Node 的更新操作都完成后，再去除污点</span>
kubectl taint nodes node01 check<span class="token operator">=</span>mycheck<span class="token operator">:</span>NoExecute<span class="token operator">-</span>
</code></pre> 
<h2><a id="Pod_phase_170"></a>Pod启动阶段（相位 phase）</h2> 
<h3><a id="pod_172"></a>pod启动过程</h3> 
<pre><code class="prism language-undefined">1.调度到某台 node 上。kubernetes 根据一定的优先级算法选择一台 node 节点将其作为 Pod 运行的 node
2.拉取镜像
3.挂载存储配置等
4.运行起来。如果有健康检查，会根据检查的结果来设置其状态
</code></pre> 
<h3><a id="phase_181"></a>phase的状态</h3> 
<pre><code class="prism language-sql">●Pending：表示APIServer创建了Pod资源对象并已经存入了etcd中，但是它并未被调度完成（比如还没有调度到某台node上），或者仍然处于从仓库下载镜像的过程中。

●Running：Pod已经被调度到某节点之上，并且Pod中所有容器都已经被kubelet创建。至少有一个容器正在运行，或者正处于启动或者重启状态（也就是说Running状态下的Pod不一定能被正常访问）。

●Succeeded：有些pod不是长久运行的，比如job、cronjob，一段时间后Pod中的所有容器都被成功终止，并且不会再重启。需要反馈任务执行的结果。

●Failed：Pod中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非<span class="token number">0</span>状态退出或者被系统终止，比如 command 写的有问题。

●Unknown：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败
</code></pre> 
<h3><a id="_195"></a>故障排除步骤</h3> 
<pre><code class="prism language-armasm">//查看Pod事件
kubectl describe TYPE NAME_PREFIX  

//查看Pod日志（Failed状态下）
kubectl logs &lt;POD_NAME&gt; [-c Container_NAME]

//进入Pod（状态为running，但是服务没有提供）
kubectl exec –it &lt;POD_NAME&gt; bash

//查看集群信息
kubectl get nodes

//发现集群状态正常
kubectl cluster-info

//查看kubelet日志发现
journalctl -xefu kubelet
</code></pre> 
<h3><a id="pod_217"></a>对节点执行维护操作:删除节点上的pod数据</h3> 
<h4><a id="Node_219"></a>将Node标记为不可调度的状态</h4> 
<pre><code class="prism language-csharp">kubectl <span class="token keyword">get</span> nodes

<span class="token comment">//将 Node 标记为不可调度的状态，这样就不会让新创建的 Pod 在此 Node 上运行</span>
kubectl cordon <span class="token operator">&lt;</span>NODE_NAME<span class="token operator">&gt;</span> 		 #该node将会变为SchedulingDisabled状态

kubectl cordon node01

kubectl <span class="token keyword">get</span> nodes
</code></pre> 
<p><img src="https://images2.imgbox.com/21/cb/CfiHzAQR_o.png" alt="img"></p> 
<h4><a id="drainpod_234"></a>用drain删除pod数据</h4> 
<pre><code class="prism language-markdown">//kubectl drain 可以让 Node 节点开始释放所有 pod，并且不接收新的 pod 进程。drain 本意排水，意思是将出问题的 Node 下的 Pod 转移到其它 Node 下运行
==========================================================
kubectl drain node01 --ignore-daemonsets --delete-local-data --force
==========================================================
--ignore-daemonsets：无视 DaemonSet 管理下的 Pod。
--delete-local-data：如果有 mount local volume 的 pod，会强制杀掉该 pod。
--force：强制释放不是控制器管理的 Pod，例如 kube-proxy。

注：执行 drain 命令，会自动做了两件事情:
（1）设定此 node 为不可调度状态（cordon)
（2）evict（驱逐）了 Pod
</code></pre> 
<p><img src="https://images2.imgbox.com/af/aa/a0E80ey8_o.png" alt="img"></p> 
<h4><a id="Node_252"></a>将Node标记为可调度的状态</h4> 
<pre><code class="prism language-csharp"><span class="token comment">//kubectl uncordon 将 Node 标记为可调度的状态</span>
kubectl uncordon <span class="token operator">&lt;</span>NODE_NAME<span class="token operator">&gt;</span>

kubectl uncordon node01

kubectl <span class="token keyword">get</span> nodes
</code></pre> 
<p><img src="https://images2.imgbox.com/67/ea/L9tMfXtd_o.png" alt="img"></p> 
<h2><a id="_265"></a>存储卷</h2> 
<h3><a id="emptyDir_267"></a>emptyDir存储卷</h3> 
<pre><code class="prism language-yaml">当pod被分配给节点时，首先创建emptyDir卷，并且只要该Pod在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod中的容器可以读取和写入emptyDir卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 pod时<span class="token punctuation">,</span>emptyDir中的数据将被永久删除
vim demo3.yaml
==========================================================
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx1
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http
      <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html
      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html/
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx2
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html
      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'/bin/bash'</span><span class="token punctuation">,</span><span class="token string">'-c'</span><span class="token punctuation">,</span><span class="token string">'while true;do echo $(date) &gt;&gt; /data/index.html;sleep 10;done'</span><span class="token punctuation">]</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html
    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
==========================================================
kubectl apply <span class="token punctuation">-</span>f demo3.yaml

kubectl get pods <span class="token punctuation">-</span>o wide

kubectl exec <span class="token punctuation">-</span>it nginx <span class="token punctuation">-</span>c nginx2 sh  <span class="token comment">#进去nginx2容器</span>
cat /data/index.html

kubectl exec <span class="token punctuation">-</span>it nginx <span class="token punctuation">-</span>c nginx1 sh  <span class="token comment">#进去nginx1容器</span>
cat /usr/share/nginx/html/index.html
</code></pre> 
<p><img src="https://images2.imgbox.com/c5/0f/7YCAtRI5_o.png" alt="img"><br> <img src="https://images2.imgbox.com/f2/b1/Fwl7SMkg_o.png" alt="img"></p> 
<h3><a id="hostPath_313"></a>hostPath存储卷</h3> 
<pre><code class="prism language-yaml">hostpath卷将 node节点的文件系统中的文件或目录挂载到集群中。hostPath可以实现持久存储，但是在node节点故障时，也会导致数据的丢失
1.vim demo4.yaml
==========================================================
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx222
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx222
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx1
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http
      <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html    <span class="token comment">##使用的存储卷名称，如果跟下面volume字段name值相同，则表示使用volume的这个存储卷</span>
      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html/   <span class="token comment">##挂载至容器中哪个目录</span>
      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>     <span class="token comment">#读写挂载方式，默认为读写模式false</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span> 
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html     <span class="token comment">#存储卷名称</span>
    <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>      
      <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/pod/volume   <span class="token comment">#在宿主机上目录的路径</span>
      <span class="token key atrule">type</span><span class="token punctuation">:</span> DirectoryOrCreate  <span class="token comment">#定义类型，这表示如果宿主机没有此目录则会自动创建</span>
==========================================================
2.kubectl apply <span class="token punctuation">-</span>f demo4.yaml

3.查看pod在哪个node节点创建，可以用ip访问测试
kubectl get pods <span class="token punctuation">-</span>o wide 

4.在node节点上自动创建的目录中写入内容
echo 'woshiwuyifan' <span class="token punctuation">&gt;</span> /data/pod/volume/index.html

5.访问测试
curl http<span class="token punctuation">:</span>//10.244.2.70

6.主节点写入内容测试共享
kubectl exec <span class="token punctuation">-</span>it nginx222 <span class="token punctuation">-</span>c nginx1 sh <span class="token comment">#进入容器</span>
echo 'woshigutianle' <span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span> /usr/share/nginx/html/index.html
再退出容器测试node02节点：curl http<span class="token punctuation">:</span>//10.244.2.70
</code></pre> 
<p><img src="https://images2.imgbox.com/e0/d2/Ja1AWwWA_o.png" alt="img"><br> <img src="https://images2.imgbox.com/1e/f1/gPd9Ni2Z_o.png" alt="img"><br> <img src="https://images2.imgbox.com/88/26/VRVBnqsY_o.png" alt="img"><br> <img src="https://images2.imgbox.com/86/2e/cPTxfXZi_o.png" alt="img"></p> 
<h3><a id="nfs_364"></a>nfs共享存储卷</h3> 
<h4><a id="nfs01_366"></a>另起服务器nfs01节点</h4> 
<pre><code class="prism language-bash"><span class="token number">1</span>.设置主机名
hostnamectl set-hostname nfs01
<span class="token function">su</span>

<span class="token number">2</span>.关闭防火墙和安全功能
systemctl stop firewalld
setenforce <span class="token number">0</span>

<span class="token number">3</span>.创建共享目录并给权限
<span class="token function">mkdir</span> -p /data/volume
<span class="token function">chmod</span> <span class="token number">777</span> /data/volume

<span class="token number">4</span>.安装nfs，并配置nfs服务
yum <span class="token function">install</span> -y rpcbind nfs-utils

<span class="token function">vim</span> /etc/exports
/data/volume <span class="token number">192.168</span>.80.0/24<span class="token punctuation">(</span>rw,sync,no_root_squash<span class="token punctuation">)</span>

<span class="token number">5</span>.启动nfs服务并查看本机共享目录
systemctl start rpcbind
systemctl start nfs

showmount -e

<span class="token number">6</span>.在共享目录写入网页文件
<span class="token builtin class-name">echo</span> <span class="token string">'woshizhangjiahui'</span> <span class="token operator">&gt;</span> /data/volume/index.html
</code></pre> 
<p><img src="https://images2.imgbox.com/2c/e2/AmmPNVMX_o.png" alt="img"><br> <img src="https://images2.imgbox.com/3a/01/R0QbpsP1_o.png" alt="img"></p> 
<h4><a id="masternode_400"></a>在master节点和node节点配置映射</h4> 
<pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'192.168.80.14 nfs01'</span> <span class="token operator">&gt;&gt;</span> /etc/hosts
</code></pre> 
<p><img src="https://images2.imgbox.com/c8/d7/Rpc4voHM_o.png" alt="img"></p> 
<h4><a id="_408"></a>主节点操作</h4> 
<pre><code class="prism language-yaml">vim demo5.yaml
==========================================================
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx333
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx222
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx1
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http
      <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html    <span class="token comment">##使用的存储卷名称，如果跟下面volume字段name值相同，则表示使用volume的这个存储卷</span>
      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html/   <span class="token comment">##挂载至容器中哪个目录</span>
      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>     <span class="token comment">#读写挂载方式，默认为读写模式false</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span> 
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html     <span class="token comment">#存储卷名称</span>
    <span class="token key atrule">nfs</span><span class="token punctuation">:</span>      
      <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/volume   <span class="token comment">#在宿主机上目录的路径</span>
      <span class="token key atrule">server</span><span class="token punctuation">:</span> nfs01
==========================================================
kubectl apply <span class="token punctuation">-</span>f demo5.yaml

kubectl get pods <span class="token punctuation">-</span>o wide

curl http<span class="token punctuation">:</span>//10.244.2.71  <span class="token comment">#调度的node节点的ip</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/09/95/JOvlP4JJ_o.png" alt="img"></p> 
<h4><a id="nfs_445"></a>在nfs服务器额外写网页文件</h4> 
<pre><code class="prism language-bash">nfs服务器：echo <span class="token string">'woshi111'</span> <span class="token operator">&gt;&gt;</span> /data/volume/index.html
主服务器：curl http://10.244.2.71
kubectl <span class="token builtin class-name">exec</span> -it nginx333 -c nginx1 <span class="token function">sh</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7b/f9/w2To202u_o.png" alt="img"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d05e62ba211c81ab2f44a8be847bcb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常见的大数据项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/884a02fdc590301dd8f7e5fd6ec9f77c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">k8s——ingress</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>