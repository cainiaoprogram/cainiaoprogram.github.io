<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue不同编译输出文件的区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue不同编译输出文件的区别" />
<meta property="og:description" content="Vue源码是选用了rollup作为bundler，看Vue的源码时发现：npm script对应了不同的构建选项。这也对应了最后打包构建后产出的不同的包。
不同于其他的library，Vue为什么要在最后的打包构建环节输出不同类型的包呢？接下来我们通过Vue的源码以及对应的构建配置中简单的去分析下。
由于Vue是基于rollup进行构建的，我们先来简单了解下rollup这个bundler：rollup是默认使用ES Module规范而非CommonJS，因此如果你在你的项目中使用rollup作为构建工具的话，那么可以放心的使用ES Module规范，但是如果要引入只遵循了CommonJs规范的第三包的话，还需要使用相关的插件，插件会帮你将CommonJs规范的代码转为ES Module。得益于ES Module，rollup在构建前进行静态分析，进行tree-shaking。关于tree-shaking的描述请戳我。在构建输出环节，rollup提供了多种文件输出类型：
iife: 立即执行函数
cjs: 遵循CommonJs Module规范的文件输出
amd: 遵循AMD Module规范的文件输出
umd: 支持外链/CommonJs Module/AMD Module规范的文件输出
es: 将多个遵循ES6 Module的文件编译成1个ES6 Module
接下来我们就看看Vue的使用rollup进行构建的几个不同的版本(使用于browser的版本)。
npm run dev 对应 rollup -w -c build/config.js --environment TARGET:web-full-dev rollup对应的配置信息为:
// Runtime&#43;compiler development build (Browser) &#39;web-full-dev&#39;: { entry: resolve(&#39;web/runtime-with-compiler.js&#39;), dest: resolve(&#39;dist/vue.js&#39;), format: &#39;umd&#39;, env: &#39;development&#39;, alias: { he: &#39;./entity-decoder&#39; }, banner }, 开发环境下输出的umd格式的代码，入口文件是runtime-with-compiler.js，这个入口文件中是将Vue的构建时和运行时的代码都统一进行打包了，通过查看这个入口文件，我们注意到
... import { compileToFunctions } from &#39;./compiler/index&#39; ... const mount = Vue." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1dd8ab93435e386ebbe074c79138152f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-13T21:43:00+08:00" />
<meta property="article:modified_time" content="2017-08-13T21:43:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue不同编译输出文件的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article fmt article__content"> 
 <p><code>Vue</code>源码是选用了<code>rollup</code>作为<code>bundler</code>，看<code>Vue</code>的源码时发现：<code>npm script</code>对应了不同的构建选项。这也对应了最后打包构建后产出的不同的包。</p> 
 <p>不同于其他的<code>library</code>，<code>Vue</code>为什么要在最后的打包构建环节输出不同类型的包呢？接下来我们通过<code>Vue</code>的源码以及对应的构建配置中简单的去分析下。</p> 
 <p>由于<code>Vue</code>是基于<a href="https://rollupjs.org/" rel="nofollow">rollup</a>进行构建的，我们先来简单了解下<code>rollup</code>这个<code>bundler</code>：<code>rollup</code>是默认使用<code>ES Module</code>规范而非<code>CommonJS</code>，因此如果你在你的项目中使用<code>rollup</code>作为构建工具的话，那么可以放心的使用<code>ES Module</code>规范，但是如果要引入只遵循了<code>CommonJs</code>规范的第三包的话，还需要使用相关的插件，插件会帮你将<code>CommonJs</code>规范的代码转为<code>ES Module</code>。得益于<code>ES Module</code>，<code>rollup</code>在构建前进行静态分析，进行<code>tree-shaking</code>。关于<code>tree-shaking</code>的描述<a href="https://google.com.hk" rel="nofollow">请戳我</a>。在构建输出环节，<code>rollup</code>提供了多种文件输出类型：</p> 
 <ul><li><p><code>iife</code>: 立即执行函数</p></li><li><p><code>cjs</code>: 遵循<code>CommonJs Module</code>规范的文件输出</p></li><li><p><code>amd</code>: 遵循<code>AMD Module</code>规范的文件输出</p></li><li><p><code>umd</code>: 支持<code>外链</code>/<code>CommonJs Module</code>/<code>AMD Module</code>规范的文件输出</p></li><li><p><code>es</code>: 将多个遵循<code>ES6 Module</code>的文件编译成1个<code>ES6 Module</code></p></li></ul> 
 <p>接下来我们就看看<code>Vue</code>的使用<code>rollup</code>进行构建的几个不同的版本(使用于<code>browser</code>的版本)。</p> 
 <pre><code class="javascript">npm run dev 对应

rollup -w -c build/config.js --environment TARGET:web-full-dev</code></pre> 
 <p><code>rollup</code>对应的配置信息为:</p> 
 <pre><code class="javascript">// Runtime+compiler development build (Browser)
 'web-full-dev': {
    entry: resolve('web/runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },</code></pre> 
 <p>开发环境下输出的<code>umd</code>格式的代码，入口文件是<code>runtime-with-compiler.js</code>，这个入口文件中是将<code>Vue</code>的<code>构建时</code>和<code>运行时</code>的代码都统一进行打包了，通过查看这个入口文件，我们注意到</p> 
 <pre><code class="javascript">...
import { compileToFunctions } from './compiler/index'
...

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function () {
    
}</code></pre> 
 <p>我们发现，这个文件当中，首先将原来定义的<code>Vue.prototype.$mount</code>方法缓存起来，然后将这个方法进行重写，重写后的方法当中，首先判断是否有自定义的<code>render</code>函数，如果有自定义的<code>render</code>函数的话，<code>Vue</code>不会通过自带的<code>compiler</code>对模板进行编译并生成<code>render</code>函数。但是如果没有自定义的<code>render</code>函数，那么会调用<code>compiler</code>对你定义的模板进行编译，并生成<code>render</code>函数，所以通过这个<code>rollup</code>的配置构建出来的代码既支持自定义<code>render</code>函数，又支持<code>template</code>模板编译：</p> 
 <pre><code class="javascript">    // 将模板编译成render函数，并挂载到vm实例的options属性上
      const { render, staticRenderFns } = compileToFunctions(template, {
        shouldDecodeNewlines,
        delimiters: options.delimiters
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns
      
      ...
    // 调用之前缓存的mount函数，TODO: 关于这个函数里面发生了什么请戳我
    return mount.call(this, el, hydrating)</code></pre> 
 <p>接下来看第二种构建方式:</p> 
 <pre><code class="javascript">npm run dev:cjs 对应的构建脚本

rollup -w -c build/config.js --environment TARGET:web-runtime-cjs</code></pre> 
 <p><code>rollup</code>对应的配置信息为:</p> 
 <pre><code class="javascript">// Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify
  'web-runtime-cjs': {
    entry: resolve('web/runtime.js'),
    dest: resolve('dist/vue.runtime.common.js'),
    format: 'cjs',
    banner
  }</code></pre> 
 <p>最后编译输出的文件是遵循<code>CommonJs Module</code>同时只包含<code>runtime</code>部分的代码，它能直接被<code>webpack 1.x</code>和<code>Browserify</code>直接<code>load</code>。它对应的入口文件是<code>runtime.js</code>：</p> 
 <pre><code class="javascript">import Vue from './runtime/index'

export default Vue</code></pre> 
 <p>这里没有重写<code>Vue.prototye.$mount</code>方法，因此在<code>vm</code>实例的生命周期中，进行到<code>beforeMount</code>阶段时:</p> 
 <pre><code class="javascript">    // vm挂载的根元素
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }</code></pre> 
 <pre><code class="javascript">export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  // vm.$el为真实的node
  vm.$el = el
  // 如果vm上没有挂载render函数
  if (!vm.$options.render) {
    // 空节点
    vm.$options.render = createEmptyVNode
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  // 钩子函数
  callHook(vm, 'beforeMount')

  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
    updateComponent = () =&gt; {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`${name} patch`, startTag, endTag)
    }
  } else {
    // updateComponent为监听函数, new Watcher(vm, updateComponent, noop)
    updateComponent = () =&gt; {
      // Vue.prototype._render 渲染函数
      // vm._render() 返回一个VNode
      // 更新dom
      // vm._render()调用render函数，会返回一个VNode，在生成VNode的过程中，会动态计算getter,同时推入到dep里面
      // 在非ssr情况下hydrating为false
      vm._update(vm._render(), hydrating)
    }
  }

  // 新建一个_watcher对象
  // vm实例上挂载的_watcher主要是为了更新DOM
  // 在实例化watcher的过程中，就会执行updateComponent，完成对依赖的变量的收集过程
  // vm/expression/cb
  vm._watcher = new Watcher(vm, updateComponent, noop)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}</code></pre> 
 <p>首先判断<code>vm</code>实例上是否定义了<code>render</code>函数。如果没有，那么就会新建一个新的空<code>vnode</code>并挂载到<code>render</code>函数上。此外，如果页面的渲染是通过传入<code>根节点</code>的形式:</p> 
 <pre><code class="javascript">    new Vue({
      el: '#app'
    })</code></pre> 
 <p><code>Vue</code>便会打出<code>log</code>信息:</p> 
 <pre><code class="javascript">    warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.'</code></pre> 
 <p>意思就是你当前使用的是只包含<code>runtime</code>打包后的代码，模板的编译器(即构建时)的代码并不包含在里面。因此，你不能通过挂根节点或者是声明式模板的方式去组织你的<code>html</code>内容，而只能使用<code>render</code>函数去书写模板内容。不过报错信息里面也给出了提示信息就是，你还可以选择<code>pre-compile</code>预编译工具去将<code>template</code>模板编译成<code>render</code>函数(<code>vue-loader</code>就起到了这个作用)或者是使用包含了<code>compiler</code>的输出包，也就是上面分析的即包含<code>compiler</code>，又包含<code>runtime</code>的包。</p> 
 <p>第三种构建方式:</p> 
 <pre><code class="javascript">npm run dev:esm 对应的构建脚本为:

rollup -w -c build/config.js --environment TARGET:web-runtime-esm</code></pre> 
 <p>入口文件及最后构建出来的代码内容和第二种一样，只包含<code>runtime</code>部分的代码，但是输出代码是遵循<code>ES Module</code>规范的。可以被支持<code>ES Module</code>的<code>bundler</code>直接加载，如<code>webpack2</code>和<code>rollup</code>。</p> 
 <p>第四种构建方式：</p> 
 <pre><code class="javascript">npm run dev:compiler 对应的构建脚本为：

rollup -w -c build/config.js --environment TARGET:web-compiler</code></pre> 
 <p>不同于前面3种构建方式:</p> 
 <pre><code class="javascript">// Web compiler (CommonJS).
'web-compiler': {
    entry: resolve('web/compiler.js'),
    dest: resolve('packages/vue-template-compiler/build.js'),
    format: 'cjs',
    external: Object.keys(require('../packages/vue-template-compiler/package.json').dependencies)
  },</code></pre> 
 <p>这一构建对应于将关于<code>Vue</code>模板编译的成<code>render</code>函数的<code>compiler.js</code>单独进行打包输出。最后输出的<code>packages/vue-template-compiler/build.js</code>文件会单独作为一个<code>node_modules</code>进行发布，在你的开发过程中，如果使用了<code>webpack</code>作为构建工具，以及<code>vue-loader</code>，在开发构建环节，<code>vue-loader</code>便会通过<code>web compiler</code>去处理你的<code>*.vue</code>文件中的模板<code>&lt;template&gt;</code>当中的内容，将这些模板字符串编译为<code>render</code>函数。</p> 
 <p><a href="https://vuefe.cn/v2/guide/installation.html" rel="nofollow">文档请戳我</a></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/69e71e7af1a1a4df9bf87f83e6959b8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决Can’t locate ExtUtils/MakeMaker.pm in @INC</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17d7faa4bdbfcb19c4c3c7e877e9b0cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（一）HBase学习之路  -  HBase  Shell 使用 与 HBase  WebUI理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>