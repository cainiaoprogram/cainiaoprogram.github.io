<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>集合详解（四）：Map - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="集合详解（四）：Map" />
<meta property="og:description" content="一、Map （一）Map概述 1、Map集合：将键映射到值的对象。 1）一个映射不能包含重复的键； 2）每个键最多只能映射到一个值。 2、Map集合和Collection集合的区别 1）Map集合存储元素是成对出现的，Map集合的键是唯一的，值是可重复的。可以把这个理解为：夫妻对 。 2）Collection集合存储元素是单独出现的，Collection的儿子Set是唯一的，List是可重复的。可以把这个理解为：光棍(11.11) 3、注意： 1）Map集合的数据结构只针对键有效，跟值无关 ，HashMap，TreeMap。 2）Collection集合的数据结构是针对元素有效 。 （二）功能 1、添加功能 1）V put(K key,V value)：添加元素。这个其实还有另一个功能 如果键是第一次存储，就直接存储元素，返回null 如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值 2、删除功能 1）void clear()：移除所有的键值对元素 2）V remove(Object key)：根据键删除键值对元素，并把值返回 3、判断功能 （有意思） 1）boolean containsKey(Object key)：判断集合是否包含指定的键 2）boolean containsValue(Object value)：判断集合是否包含指定的值 3）boolean isEmpty()：判断集合是否为空 4、长度功能 int size()：返回集合中的键值对的对数 5、获取功能 1）基本方法： Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：遍历获取V get(Object key)：根据键获取值Set&lt;K&gt; keySet()：获取集合中所有键的集合Collection&lt;V&gt; values()：获取集合中所有值的集合 2）遍历Map的方法 方法1：先拿到所有的key，然后遍历获取所有的value keySet()get(Object key)方法2：先拿到所有的键值对，然后遍历，获取每一个键值对对象-Entry（推荐）。 entrySet()Map.Entry 3）图解 4）具体代码 &lt;span style=&#34;font-size:18px;&#34;&gt;&lt;span style=&#34;font-family:Arial;font-size:18px;&#34;&gt;	/* * Map集合的遍历。 * 方法1：先拿到所有的key，然后遍历获取所有的value * 方法2：先拿到所有的键值对，然后遍历，获取每一个键和值（推荐） * */ public void test3(){ // 创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 创建元素并添加到集合 map." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/39d32695889c9613a6178a6bbd38c678/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-31T21:57:08+08:00" />
<meta property="article:modified_time" content="2022-05-31T21:57:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">集合详解（四）：Map</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <span style="background-color:inherit;"><strong>一、Map</strong></span> 
</div> 
<div>
  （一）Map概述 
</div> 
<div> 
 <div>
   1、Map集合：将键映射到值的对象。 
 </div> 
 <div>
   1）一个映射不能包含重复的键； 
 </div> 
 <div>
   2）每个键最多只能映射到一个值。   
 </div> 
 <div></div> 
 <div>
   2、Map集合和Collection集合的区别 
 </div> 
 <div>
   1）Map集合存储元素是成对出现的，Map集合的键是唯一的，值是可重复的。可以把这个理解为：夫妻对 。 
 </div> 
 <div>
   2）Collection集合存储元素是单独出现的，Collection的儿子Set是唯一的，List是可重复的。可以把这个理解为：光棍(11.11) 
 </div> 
 <div></div> 
 <div>
   3、注意：  
 </div> 
 <div>
   1）Map集合的数据结构只针对键有效，跟值无关 ，HashMap，TreeMap。  
 </div> 
 <div>
   2）Collection集合的数据结构是针对元素有效 。 
 </div> 
 <div></div> 
 <div> 
  <div>
    （二）功能 
  </div> 
  <div>
    1、添加功能 
  </div> 
  <div>
    1）V put(K key,V value)：添加元素。这个其实还有另一个功能 
  </div> 
  <div> 
   <ul><li>如果键是第一次存储，就直接存储元素，返回null </li><li>如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值 </li></ul> 
  </div> 
  <div>
    2、删除功能 
  </div> 
  <div>
    1）void clear()：移除所有的键值对元素 
  </div> 
  <div>
    2）V remove(Object key)：根据键删除键值对元素，并把值返回 
  </div> 
  <div></div> 
  <div>
    3、判断功能 （有意思） 
  </div> 
  <div>
    1）boolean containsKey(Object key)：判断集合是否包含指定的键 
  </div> 
  <div>
    2）boolean containsValue(Object value)：判断集合是否包含指定的值 
  </div> 
  <div>
    3）boolean isEmpty()：判断集合是否为空 
  </div> 
  <div></div> 
  <div>
    4、长度功能  
  </div> 
  <div>
      int size()：返回集合中的键值对的对数 
  </div> 
  <div></div> 
  <div> 
   <div>
     5、获取功能 
   </div> 
   <div>
     1）基本方法： 
   </div> 
   <div> 
    <ul><li>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：遍历获取</li><li>V get(Object key)：根据键获取值</li><li>Set&lt;K&gt; keySet()：获取集合中所有键的集合</li><li>Collection&lt;V&gt; values()：获取集合中所有值的集合 </li></ul> 
   </div> 
   <div>
     2）遍历Map的方法 
   </div> 
   <div> 
    <ul><li>方法1：先拿到所有的key，然后遍历获取所有的value 
      <ul><li>keySet()</li><li>get(Object key)</li></ul></li><li>方法2：先拿到所有的键值对，然后遍历，获取每一个键值对对象-Entry（推荐）。 
      <ul><li>entrySet()</li><li>Map.Entry</li></ul></li></ul> 
   </div> 3）图解 
  </div> 
  <div></div> 
  <div> 
   <img alt="" src="https://images2.imgbox.com/90/7a/clbHOAzp_o.png"> 
  </div> 
  <div></div> 
  <div></div> 
  <div>
    4）具体代码 
  </div> 
  <div> 
   <pre class="has"><code class="language-java">&lt;span style="font-size:18px;"&gt;&lt;span style="font-family:Arial;font-size:18px;"&gt;	/*
	 * Map集合的遍历。
	 * 方法1：先拿到所有的key，然后遍历获取所有的value
	 * 方法2：先拿到所有的键值对，然后遍历，获取每一个键和值（推荐）
	 * 
	 */
	public void test3(){
		
		// 创建集合对象
		Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

		// 创建元素并添加到集合
		map.put("杨过", "小龙女");
		map.put("郭靖", "黄蓉");
		map.put("杨康", "穆念慈");
		map.put("陈玄风", "梅超风");

		
		// 方法1：获取所有的键，然后根据键获取值（键找值）
		Set&lt;String&gt; set = map.keySet();
		// 遍历键的集合，获取得到每一个键
		for (String key : set) {
			// 根据键去找值
			String value = map.get(key);
			System.out.println(key + "---" + value);
		}
		
		// 方法2： 直接拿到所有的键值
		Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();//拿到键值的Set集合
		for (Map.Entry&lt;String, String&gt; entry : entrySet) {//遍历集合，拿到每一对的键值
			System.out.println(entry.getKey() + ":" + entry.getValue());
		}
		
		// 方法2： 直接拿到所有的键值
		for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
			System.out.println("key= " + entry.getKey() + " and value= "
					+ entry.getValue());
		}
	}
&lt;/span&gt;&lt;/span&gt;</code></pre> 
   <br>   
  </div> 
  <div> 
   <div> 
    <strong>二、HashMap</strong> 
   </div> 
   <div>
     1、概述： 
   </div> 
   <div>
     1）HashMap是基于哈希表的Map接口实现。 
   </div> 
   <div>
     2）哈希表的作用是用来保证键的唯一性的，即键是唯一的，值是可重复的。 
   </div> 
   <div></div> 
   <div>
     2、Hashtable和HashMap的区别?  
   </div> 
   <div>
     1）Hashtable：线程安全，效率低。不允许null键和null值 
   </div> 
   <div>
     2）HashMap：线程不安全，效率高。允许null键和null值 
   </div> 
   <div> 
    <pre class="has"><code class="language-java">&lt;span style="font-size:18px;"&gt;		// hm.put(null, "world"); //NullPointerException
		// hm.put("java", null); // NullPointerException&lt;/span&gt;</code></pre> 
   </div> 
   <div>
     3、实例：键的唯一性 
   </div> 
   <pre class="has"><code class="language-java">&lt;span style="font-size:18px;"&gt;&lt;span style="font-family:Arial;font-size:18px;"&gt;	/*
	 * HashMap:是基于哈希表的Map接口实现。
	 * 哈希表的作用是用来保证键的唯一性的。
	 * 
	 * HashMap&lt;String,String&gt;
	 * 键：String
	 * 值：String
	 */
	public void test1(){

		// 创建集合对象
		HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();

		// 创建元素并添加元素
		// String key1 = "it001";
		// String value1 = "马云";
		// hm.put(key1, value1);

		hm.put("it001", "马云");
		hm.put("it003", "马化腾");
		hm.put("it004", "乔布斯");
		hm.put("it005", "张朝阳");
		hm.put("it002", "裘伯君"); // wps
		hm.put("it001", "比尔盖茨");

		// 遍历
		Set&lt;String&gt; set = hm.keySet();
		for (String key : set) {
			String value = hm.get(key);
			System.out.println(key + "---" + value);
		}
	
	}&lt;/span&gt;&lt;/span&gt;</code></pre> 
   <br>   
  </div> 
  <div> 
   <div> 
    <strong>三、LinkedHashMap</strong> 
   </div> 
   <div>
     1、特性：是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。 
   </div> 
   <div>
     1）由哈希表保证键的唯一性 
   </div> 
   <div>
     2）由链表保证键盘的有序(存储和取出的顺序一致) 
   </div> 
   <div></div> 
   <div>
     2、实例： 
   </div> 
  </div> 
  <div> 
   <pre class="has"><code class="language-java">&lt;span style="font-size:18px;"&gt;/*
 * LinkedHashMap:是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。
 * 由哈希表保证键的唯一性
 * 由链表保证键盘的有序(存储和取出的顺序一致)
 */
public class LinkedHashMapDemo {
	public static void main(String[] args) {
		// 创建集合对象
		LinkedHashMap&lt;String, String&gt; hm = new LinkedHashMap&lt;String, String&gt;();

		// 创建并添加元素
		hm.put("2345", "hello");
		hm.put("1234", "world");
		hm.put("3456", "java");
		hm.put("1234", "javaee");
		hm.put("3456", "android");

		// 遍历
		Set&lt;String&gt; set = hm.keySet();
		for (String key : set) {
			String value = hm.get(key);
			System.out.println(key + "---" + value);
		}
	}
}
&lt;/span&gt;</code></pre> 
   <div></div>   
   <div> 
    <div> 
     <div> 
      <strong>四、TreeMap</strong> 
     </div> 
    </div> 
   </div> 
   <div>
     1、TreeMap：是基于红黑树的Map接口的实现。 
   </div> 
   <div>
     2、实现：需要排序比较接口同TreeSet 
   </div> 
   <div>
     3、实例："aababcabcdabcde"，获取字符串中每一个字母出现的次数要求结果 
   </div> 
   <div></div> 
   <pre class="has"><code class="language-java">&lt;span style="font-size:18px;"&gt;	/*
	 * 需求 ："aababcabcdabcde",获取字符串中每一个字母出现的次数要求结果:a(5)b(4)c(3)d(2)e(1)
	 * 
	 * 分析：
	 * 		A:定义一个字符串(可以改进为键盘录入)
	 * 		B:定义一个TreeMap集合
	 * 			键:Character
	 * 			值：Integer
	 * 		C:把字符串转换为字符数组
	 * 		D:遍历字符数组，得到每一个字符
	 * 		E:拿刚才得到的字符作为键到集合中去找值，看返回值
	 * 			是null:说明该键不存在，就把该字符作为键，1作为值存储
	 * 			不是null:说明该键存在，就把值加1，然后重写存储该键和值
	 * 		F:定义字符串缓冲区变量
	 * 		G:遍历集合，得到键和值，进行按照要求拼接
	 * 		H:把字符串缓冲区转换为字符串输出
	 * 
	 */
	public void test3() {
		
		String line = "aababcabcdabcde";
		
		// 定义一个字符串(可以改进为键盘录入)
//		Scanner sc = new Scanner(System.in);
//		System.out.println("请输入一个字符串：");
//		String line = sc.nextLine();

		// 定义一个TreeMap集合
		TreeMap&lt;Character, Integer&gt; tm = new TreeMap&lt;Character, Integer&gt;();
		
		//把字符串转换为字符数组
		char[] chs = line.toCharArray();
		
		//遍历字符数组，得到每一个字符
		for(char ch : chs){
			//拿刚才得到的字符作为键到集合中去找值，看返回值
			Integer i =  tm.get(ch);
			
			//是null:说明该键不存在，就把该字符作为键，1作为值存储
			if(i == null){
				tm.put(ch, 1);
			}else {
				//不是null:说明该键存在，就把值加1，然后重写存储该键和值
				i++;
				tm.put(ch,i);
			}
		}
		
		//定义字符串缓冲区变量
		StringBuilder sb=  new StringBuilder();
		
		//遍历集合，得到键和值，进行按照要求拼接
		Set&lt;Character&gt; set = tm.keySet();
		for(Character key : set){
			Integer value = tm.get(key);
			sb.append(key).append("(").append(value).append(")");
		}
		
		//把字符串缓冲区转换为字符串输出
		String result = sb.toString();
		System.out.println("result:"+result);
		
	}&lt;/span&gt;</code></pre> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd2bf6a3fdce3031e7aeb4973e4bd2ca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">集合详解（三）：Set</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5fb8a85bfc1bb7b1b7171e6700fffe0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java异常：Throwable</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>