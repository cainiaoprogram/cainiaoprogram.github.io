<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>哈夫曼树的构建(C语言版) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="哈夫曼树的构建(C语言版)" />
<meta property="og:description" content="哈夫曼树的构建(C语言版) 课程要求： 左0，右1
左子树根节点 &lt; 右 子树根节点
节点 data, w , lchild, rchild
建立哈夫曼 （有序单链表）
初始：循环输入字符与权值，创建节点，插入到链表中 形成一个包含n个节点的递增单链表
然后：将第一、二两个节点从单链表中删除，然后合并形成新的节点，新节点插入到有序表中，直至剩下一个节点。
可以通过递归遍历的方法得到每个字符的 哈夫曼编码
建立有序单链表 有序单链表 typedef struct Link{ int w;//存储整形权重 char data;//存储char类型字符 struct Link *next;//指向直接后继元素的指针 struct Link *lchild; struct Link *rchild; }Link; 初始化链表 Link* InitLink(){ Link* link = (Link*)malloc(sizeof(Link));//创建头结点 link-&gt;next = NULL;//头结点的next为空 link-&gt;lchild = link-&gt;rchild = NULL; return link; } 排序插入元素(可以选择头插或者尾插，然后排序) void InsertLink(Link* link,Link* node){ Link* p = link; Link* q = p-&gt;next; while(q &amp;&amp; node-&gt;w&gt;q-&gt;w) { p=q;//记录位置 q=q-&gt;next; } node-&gt;next = q; p-&gt;next = node; } 删除节点,返回被删除的节点 Link* DelLink(Link* link,int index){ Link *p, *s; int i = 0; p = link; while(i&lt;index-1 &amp;&amp; p-&gt;next !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d135078df152b7af1f2dc965bbe08578/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-06T09:14:27+08:00" />
<meta property="article:modified_time" content="2021-04-06T09:14:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">哈夫曼树的构建(C语言版)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="C_0"></a>哈夫曼树的构建(C语言版)</h3> 
<h4><a id="_1"></a><mark>课程要求</mark>：</h4> 
<blockquote> 
 <p>左0，右1<br> 左子树根节点 &lt; 右 子树根节点<br> 节点 data, w , lchild, rchild<br> 建立哈夫曼 （有序单链表）<br> 初始：循环输入字符与权值，创建节点，插入到链表中 形成一个包含n个节点的递增单链表<br> 然后：将第一、二两个节点从单链表中删除，然后合并形成新的节点，新节点插入到有序表中，直至剩下一个节点。<br> 可以通过递归遍历的方法得到每个字符的 哈夫曼编码</p> 
</blockquote> 
<ol><li>建立有序单链表</li></ol> 
<pre><code>有序单链表
typedef struct Link{
    int  w;//存储整形权重
    char data;//存储char类型字符 
    struct Link *next;//指向直接后继元素的指针
    struct Link *lchild;
	struct Link *rchild;
}Link;
</code></pre> 
<ol start="2"><li>初始化链表</li></ol> 
<pre><code>Link* InitLink(){
	Link* link = (Link*)malloc(sizeof(Link));//创建头结点 
	link-&gt;next = NULL;//头结点的next为空
	link-&gt;lchild = link-&gt;rchild = NULL;
	return link; 
}
</code></pre> 
<ol start="3"><li>排序插入元素(可以选择头插或者尾插，然后排序)</li></ol> 
<pre><code>void InsertLink(Link* link,Link* node){
	
	Link* p = link;
	Link* q = p-&gt;next;
	
 	while(q &amp;&amp; node-&gt;w&gt;q-&gt;w)
 	{
 		p=q;//记录位置 
 		q=q-&gt;next;
	 }
	 node-&gt;next = q;
	 p-&gt;next = node;
	
}
</code></pre> 
<ol start="4"><li>删除节点,返回被删除的节点</li></ol> 
<pre><code>Link* DelLink(Link* link,int index){
	Link *p, *s;
	int i = 0;
	p = link;
	while(i&lt;index-1 &amp;&amp; p-&gt;next != NULL)	//搜索指定位置前一个节点
	{
		i++;
		p = p-&gt;next;
	}
	if(i != index-1 || p-&gt;next == NULL)
		printf("删除位置非法");
	s = p-&gt;next;
	p-&gt;next = s-&gt;next;

//	free(s);//释放节点 
	return s;//返回被删除的节点，后面步骤用
} 
</code></pre> 
<ol start="5"><li>创建哈夫曼树</li></ol> 
<pre><code>Link* CreateHuffManTree(Link* link,int n){
		Link *del1,*del2,*p;
		Link* node ;
		int w_sum,i;
		p = link;		
		for(i=0;i&lt;n-1;i++){
			
		del1 = DelLink(p,1);//最小的元素 
		del2 = DelLink(p,1);//第二小的元素
		w_sum = del1-&gt;w + del2-&gt;w; //两个最小的数的和
		
		node = (Link*)malloc(sizeof(Link));
		node-&gt;lchild= del1;
		node-&gt;rchild= del2;
		node-&gt;w = w_sum;
		
		InsertLink(link,node);
					
		}
		return node; 
		
}
</code></pre> 
<ol start="6"><li>哈夫曼编码</li></ol> 
<pre><code>void getCoding(Link *tree,int len){
	if(!tree)
	return;
	static int a[20]; //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一
	int i;
	if(!tree-&gt;lchild &amp;&amp; !tree-&gt;rchild){
		printf(" %c的哈夫曼编码为：",tree-&gt;data);
		for(i = 0; i &lt; len; i++)
		printf("%d",a[i]);
		printf("\n");
	}
	else{//访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a ，的对应元素中，向下深入一层时len值增1 
		a[len] = 0;
		getCoding(tree-&gt;lchild, len + 1);
		a[len] = 1;
		getCoding(tree-&gt;rchild, len + 1);
		
	}
}
</code></pre> 
<ol start="7"><li>打印有序链表</li></ol> 
<pre><code>void PrintLink(Link* link){
	Link* p = link-&gt;next;
	while(p){
		printf("(%c,%d)",p-&gt;data,p-&gt;w);
		p = p-&gt;next;
	}
	printf("\n");
}
</code></pre> 
<ol start="8"><li>打印哈夫曼树</li></ol> 
<pre><code>void PrintTree(Link* BT){
	if (BT != NULL)
    {
        printf("%d", BT-&gt;w); //输出根结点的值
        if (BT-&gt;lchild != NULL || BT-&gt;rchild != NULL)
        {
            printf("(");
            PrintTree(BT-&gt;lchild); //输出左子树
            if (BT-&gt;rchild != NULL)
                printf(",");
            PrintTree(BT-&gt;rchild); //输出右子树
            printf(")");
        }
    }
} 
</code></pre> 
<p><code>完整代码：</code></p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
/**
左0，右1
左子树根节点 &lt;  右 子树根节点 
节点  data, w , lchild, rchild
建立哈夫曼 （有序单链表）  
初始：循环输入字符与权值，创建节点，插入到链表中  形成一个包含8个节点的递增单链表
然后：将第一、二两个节点从单链表中删除，然后合并形成新的节点，新节点插入到有序表中，直至剩下一个节点。
可以通过递归遍历的方法得到每个字符的 哈夫曼编码
**/

//有序单链表
typedef struct Link{
  int  w;//存储整形权重
  char data;//存储char类型字符 
  struct Link *next;//指向直接后继元素的指针
  struct Link *lchild;
  struct Link *rchild;
}Link;


//初始化链表 
Link* InitLink(){
  Link* link = (Link*)malloc(sizeof(Link));//创建头结点 
  link-&gt;next = NULL;//头结点的next为空
  link-&gt;lchild = link-&gt;rchild = NULL;
  return link; 
}

//排序插入元素
void InsertLink(Link* link,Link* node){
  
  Link* p = link;
  Link* q = p-&gt;next;
  
  while(q &amp;&amp; node-&gt;w&gt;q-&gt;w)
  {
  	p=q;//记录位置 
  	q=q-&gt;next;
   }
   node-&gt;next = q;
   p-&gt;next = node;
  
}

//删除节点,返回被删除的节点 
Link* DelLink(Link* link,int index){
  Link *p, *s;
  int i = 0;
  p = link;
  while(i&lt;index-1 &amp;&amp; p-&gt;next != NULL)	//搜索指定位置前一个节点
  {
  	i++;
  	p = p-&gt;next;
  }
  if(i != index-1 || p-&gt;next == NULL)
  	printf("删除位置非法");
  s = p-&gt;next;
  p-&gt;next = s-&gt;next;

//	free(s);//释放节点 
  return s;

} 

//打印有序链表
void PrintLink(Link* link){
  Link* p = link-&gt;next;
  while(p){
  	printf("(%c,%d)",p-&gt;data,p-&gt;w);
  	p = p-&gt;next;
  }
  printf("\n");
}

//打印树
void PrintTree(Link* BT){
  if (BT != NULL)
  {
      printf("%d", BT-&gt;w); //输出根结点的值
      if (BT-&gt;lchild != NULL || BT-&gt;rchild != NULL)
      {
          printf("(");
          PrintTree(BT-&gt;lchild); //输出左子树
          if (BT-&gt;rchild != NULL)
              printf(",");
          PrintTree(BT-&gt;rchild); //输出右子树
          printf(")");
      }
  }
} 

//创建哈夫曼树 
Link* CreateHuffManTree(Link* link,int n){
  	Link *del1,*del2,*p;
  	Link* node ;
  	int w_sum,i;
  	p = link;		
  	for(i=0;i&lt;n-1;i++){
  		
  	del1 = DelLink(p,1);//最小的元素 
  	del2 = DelLink(p,1);//第二小的元素
  	w_sum = del1-&gt;w + del2-&gt;w; //两个最小的数的和
  	
  	node = (Link*)malloc(sizeof(Link));
  	node-&gt;lchild= del1;
  	node-&gt;rchild= del2;
  	node-&gt;w = w_sum;
  	
  	InsertLink(link,node);
  				
  	}
  	return node; 
  	
}


//哈夫曼编码 
void getCoding(Link *tree,int len){
  if(!tree)
  return;
  static int a[20]; //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一
  int i;
  if(!tree-&gt;lchild &amp;&amp; !tree-&gt;rchild){
  	printf(" %c的哈夫曼编码为：",tree-&gt;data);
  	for(i = 0; i &lt; len; i++)
  	printf("%d",a[i]);
  	printf("\n");
  }
  else{//访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a ，的对应元素中，向下深入一层时len值增1 
  	a[len] = 0;
  	getCoding(tree-&gt;lchild, len + 1);
  	a[len] = 1;
  	getCoding(tree-&gt;rchild, len + 1);
  	
  }
}


void main(){
  Link* link = InitLink();//初始化链表
  Link* tree;
  int num,w,i;//长度
  char data;
  printf("输入元素个数:");
  scanf("%d",&amp;num);getchar();
  for(i=0;i&lt;num;i++){
  	printf("第%d个元素的字符:",i+1);
  	scanf("%c",&amp;data);getchar();
  	printf("第%d个元素的权重:",i+1);
  	scanf("%d",&amp;w);getchar();
  	Link* node = (Link*)malloc(sizeof(Link));;
  	node-&gt;data = data;node-&gt;w = w;
  	InsertLink(link,node);
  }
  printf("******************\n");
  tree = CreateHuffManTree(link,num);
  printf("哈夫曼树:"); 
  PrintTree(tree);printf("\n"); 
  getCoding(tree,0);

} 
</code></pre> 
<p>以上为课题作业，哈夫曼树实现方式有多种，请自行查阅。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32ebeb9d8ec297dcf467ce2319a20eac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">oracle帮助系统,oracle安装sqlplus的help帮助系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f4d7f24ea1f734556b6e78185f841d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue使用vedio.js播放视频（切换视频源）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>