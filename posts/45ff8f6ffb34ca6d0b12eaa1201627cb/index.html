<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kotin学习笔记——类、接口、扩展方法、空类型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kotin学习笔记——类、接口、扩展方法、空类型" />
<meta property="og:description" content="定义类和构造方法 class SimpleClass(var x: Int, val y: String){} //创建类不需要new关键字 val simpleClass = SimpleClass(9, &#34;Hello&#34;) 构造方法放在类名的后面，如果x和y前面加了var或val， x和y会分别在类中定义一个属性以及对应的getter和setter方法，不需要额外写，否则必须手动写getter和setter实现。类前面不需要修饰符public private等，跟java不一样，默认是public的。
像下面这样：
class Person(age: Int, name: String) { var age: Int = age //property get() { return field } set(value) { println(&#34;setAge: $value&#34;) field = value } var name: String = name get() { return field // backing field } set(value) { field = value } } kotlin中，get和set方法可以显示写出来，但是一般默认不需要显示写出来，所以可以直接这样简写：
class Person(age: Int, name: String) { var age: Int = age var name: String = name } 这样也会默认生成get和set方法，除非你需要自定义get和set方法中的逻辑，那时就需要显示写出来了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/45ff8f6ffb34ca6d0b12eaa1201627cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-31T10:13:27+08:00" />
<meta property="article:modified_time" content="2023-12-31T10:13:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kotin学习笔记——类、接口、扩展方法、空类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a><strong>定义类和构造方法</strong></h2> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> <span class="token function">SimpleClass</span><span class="token punctuation">(</span><span class="token keyword">var</span> x<span class="token operator">:</span> Int<span class="token punctuation">,</span> <span class="token keyword">val</span> y<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">//创建类不需要new关键字</span>
<span class="token keyword">val</span> simpleClass <span class="token operator">=</span> <span class="token function">SimpleClass</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"Hello"</span></span><span class="token punctuation">)</span>
</code></pre> 
<p>构造方法放在类名的后面，如果x和y前面加了<code>var</code>或<code>val</code>， x和y会分别在类中定义一个属性以及对应的getter和setter方法，不需要额外写，否则必须手动写getter和setter实现。类前面不需要修饰符public private等，跟java不一样，默认是public的。</p> 
<p>像下面这样：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token operator">:</span> Int<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> age<span class="token operator">:</span> Int <span class="token operator">=</span> age <span class="token comment">//property</span>
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> field
        <span class="token punctuation">}</span>
        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"setAge: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
            field <span class="token operator">=</span> value
        <span class="token punctuation">}</span>
    <span class="token keyword">var</span> name<span class="token operator">:</span> String <span class="token operator">=</span> name
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> field <span class="token comment">// backing field</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            field <span class="token operator">=</span> value
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>kotlin中，get和set方法可以显示写出来，但是一般默认不需要显示写出来</strong>，所以可以直接这样简写：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token operator">:</span> Int<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">var</span> age<span class="token operator">:</span> Int <span class="token operator">=</span> age
   <span class="token keyword">var</span> name<span class="token operator">:</span> String <span class="token operator">=</span> name
<span class="token punctuation">}</span>
</code></pre> 
<p>这样也会默认生成get和set方法，除非你需要自定义get和set方法中的逻辑，那时就需要显示写出来了。</p> 
<ul><li><strong>定义成员变量必须提供初始值：</strong></li></ul> 
<pre><code class="prism language-kotlin">    <span class="token keyword">var</span> a <span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">var</span> b <span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
    <span class="token keyword">val</span> c <span class="token operator">:</span> Long <span class="token operator">=</span> <span class="token number">0L</span>
</code></pre> 
<p>这与java也不同，java中定义变量不指定值有默认值，如int是0</p> 
<ul><li><strong>如果定义了初始值，变量默认具备get和set方法，可以直接引用变量读取值和赋值</strong></li></ul> 
<pre><code class="prism language-kotlin"> <span class="token keyword">val</span> simpleClass <span class="token operator">=</span> <span class="token function">SimpleClass</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"Hello"</span></span><span class="token punctuation">)</span>
 <span class="token function">println</span><span class="token punctuation">(</span>simpleClass<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
 simpleClass<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">122</span>
 <span class="token function">println</span><span class="token punctuation">(</span>simpleClass<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>定义变量时如果不提供默认值，则必须定义get和set方法, 快捷键可以提示</strong></li></ul> 
<pre><code class="prism language-kotlin">    <span class="token keyword">var</span> sss<span class="token operator">:</span> Int
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token number">100</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token comment">//常量属性</span>
    <span class="token keyword">val</span> z <span class="token operator">:</span> Long
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> simpleProperty <span class="token operator">*</span> <span class="token number">2L</span>
        <span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_75"></a><strong>接口定义</strong></h2> 
<pre><code class="prism language-kotlin"><span class="token keyword">interface</span> SimpleInf <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//与java不同，接口里面可以定义待实现的常量属性，由子类实现</span>
    <span class="token keyword">val</span> simpleProperty<span class="token operator">:</span> Int <span class="token comment">// property</span>

    <span class="token keyword">fun</span> <span class="token function">simpleMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>与java不同的是，接口里面由子类实现的常量属性，java的接口类中变量值只能是初始化固定的。</p> 
<ul><li><strong>实现接口：</strong></li></ul> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> <span class="token function">SimpleClass</span><span class="token punctuation">(</span><span class="token keyword">var</span> x<span class="token operator">:</span> Int<span class="token punctuation">,</span> <span class="token keyword">val</span> y<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> SimpleInf <span class="token punctuation">{<!-- --></span>

    <span class="token comment">//覆写接口中的属性，如果是val则只有get方法 没有set方法，因为val是只读的</span>
    <span class="token keyword">override</span> <span class="token keyword">val</span> simpleProperty<span class="token operator">:</span> Int
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token number">2</span>
        <span class="token punctuation">}</span>

    <span class="token comment">//覆写方法必须加override关键字</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">simpleMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>与C++有点类似，实现接口直接在构造函数后面加冒号后写接口类名，覆写接口中的属性和方法都必须加<code>override</code>关键字。java也是需要的，但是java中不加顶多是警告，还是能运行的，但是kotlin不加直接编译报错。</p> 
<h2><a id="_106"></a><strong>抽象类定义</strong></h2> 
<pre><code class="prism language-kotlin"><span class="token keyword">abstract</span> <span class="token keyword">class</span> AbsClass <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">abstract</span> <span class="token keyword">fun</span> <span class="token function">absMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">//抽象类中的非抽象方法必须添加open才能被子类复写，否则子类不能覆写</span>
    <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">overridable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">fun</span> <span class="token function">nonOverridable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>与java相同的是，kotlin抽象类中也可以有已实现的方法和纯抽象方法，但是，与java不同的是，如果子类要覆写抽象类里的已实现方法，必须在该方法前面加<code>open</code>关键字。也就是说未加<code>open</code>关键字的方法不能被覆写。</p> 
<ul><li><strong>实现抽象类：</strong></li></ul> 
<pre><code class="prism language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> <span class="token function">SimpleClass</span><span class="token punctuation">(</span><span class="token keyword">var</span> x<span class="token operator">:</span> Int<span class="token punctuation">,</span> <span class="token keyword">val</span> y<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">AbsClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">//覆写方法必须加override关键字</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">absMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    
    <span class="token comment">//如果想子类不能覆写某个override方法，添加final属性</span>
    <span class="token keyword">final</span> <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">overridable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre> 
<p>与接口一样，继承抽象类也是加冒号，不过后面的抽象类要写构造函数。同样，覆写抽象类中的方法全部都要加<code>override</code>关键字。另外，如果想要某个被覆写的方法不能再被子类覆写，加上<code>final</code>即可，与java一样。</p> 
<h2><a id="_135"></a><strong>普通类继承</strong></h2> 
<pre><code class="prism language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> <span class="token function">SimpleClass</span><span class="token punctuation">(</span><span class="token keyword">var</span> x<span class="token operator">:</span> Int<span class="token punctuation">,</span> <span class="token keyword">val</span> y<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">zzz</span><span class="token punctuation">(</span>string<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>

    <span class="token comment">//final方法不能被覆写</span>
    <span class="token keyword">final</span> <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">overridable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//继承类</span>
<span class="token keyword">class</span> <span class="token function">SimpleClass2</span><span class="token punctuation">(</span>x<span class="token operator">:</span> Int<span class="token punctuation">,</span> y<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">SimpleClass</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">zzz</span><span class="token punctuation">(</span>string<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre> 
<p>如果类要被子类继承，则要被继承的类名和方法名前面都要加<code>open</code>关键字，否则不能被继承和覆写。</p> 
<h2><a id="_160"></a><strong>属性引用</strong></h2> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token operator">:</span> Int<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">var</span> age<span class="token operator">:</span> Int <span class="token operator">=</span> age
  <span class="token keyword">var</span> name<span class="token operator">:</span> String <span class="token operator">=</span> name
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> ageRef <span class="token operator">=</span> Person<span class="token operator">::</span>age
    <span class="token keyword">val</span> person <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"Bennyhuo"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> nameRef <span class="token operator">=</span> person<span class="token operator">::</span>name <span class="token comment">//绑定接受者的属性引用，调用set的时候可以不用传接受者</span>
    ageRef<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
    nameRef<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Andyhuo"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_177"></a><strong>扩展方法和扩展属性</strong></h2> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> PoorGuy<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> pocket<span class="token operator">:</span> Double <span class="token operator">=</span> <span class="token number">0.0</span>
<span class="token punctuation">}</span>

<span class="token comment">//定义类的扩展方法</span>
<span class="token keyword">fun</span> PoorGuy<span class="token punctuation">.</span><span class="token function">noMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"noMoney"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//定义类的扩展属性 property = backing field + getter + setter</span>
<span class="token keyword">var</span> PoorGuy<span class="token punctuation">.</span>moneyLeft<span class="token operator">:</span> Double
    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>pocket
    <span class="token punctuation">}</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        pocket <span class="token operator">=</span> value
    <span class="token punctuation">}</span>
</code></pre> 
<p>就是在类定义大括号之外，再后续给类定义方法和属性，有点像java静态方法的调用形式，但这样定义的是成员方法和属性，并不是java中那样的静态方法。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> poorGuy <span class="token operator">=</span> <span class="token function">PoorGuy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    poorGuy<span class="token punctuation">.</span><span class="token function">noMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span>poorGuy<span class="token punctuation">.</span>moneyLeft<span class="token punctuation">)</span>
    poorGuy<span class="token punctuation">.</span>moneyLeft <span class="token operator">=</span> <span class="token number">10000.0</span>
    <span class="token function">println</span><span class="token punctuation">(</span>poorGuy<span class="token punctuation">.</span>moneyLeft<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>类和扩展方法不一定在同一个<code>kt</code>文件中，但必须在方法的外层定义，即不能在某个函数方法中定义，必须是顶层的，如不能在main方法中定义。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> Person<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span>s <span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"eat</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">s</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> Person<span class="token punctuation">.</span>howOld<span class="token operator">:</span> Int
    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age
    <span class="token punctuation">}</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        age <span class="token operator">=</span> value
    <span class="token punctuation">}</span>
    
<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> eat <span class="token operator">=</span> Person<span class="token operator">::</span>eat
    <span class="token keyword">val</span> person <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"张三"</span></span><span class="token punctuation">)</span>
    person<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"aaa"</span></span><span class="token punctuation">)</span>
    <span class="token function">eat</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"222"</span></span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>howOld<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面文件中只要导入Person这个类就可以给它定义扩展方法。</p> 
<ul><li><strong>给系统类添加扩展方法：</strong></li></ul> 
<pre><code class="prism language-kotlin"><span class="token comment">//给String类定义扩展方法 给String前后加count个空格</span>
<span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span>count<span class="token operator">:</span> Int<span class="token punctuation">,</span> char<span class="token operator">:</span> Char <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//生成重复count次的空格连续串</span>
    <span class="token keyword">val</span> padding <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">..</span> count<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">joinToString</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> char<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">padding</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression"><span class="token keyword">this</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">padding</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span>
<span class="token punctuation">}</span>

<span class="token comment">//给String类定义扩展方法 判断字符串是否是邮箱</span>
<span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">isEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token function">Regex</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//给String类定义扩展方法 字符串重复count次</span>
<span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">times</span><span class="token punctuation">(</span>count<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">..</span> count<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">joinToString</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">this</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面是给String类定义扩展方法，使用起来简单：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"admin@bennyhuo.com"</span></span><span class="token punctuation">.</span><span class="token function">isEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Hello"</span></span><span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"*"</span></span><span class="token punctuation">.</span><span class="token function">times</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">//定义对扩展方法的引用</span>
    <span class="token keyword">val</span> stringTimes <span class="token operator">=</span> String<span class="token operator">::</span>times
    <span class="token keyword">val</span> stringTimesBound <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"*"</span></span><span class="token operator">::</span>times
 <span class="token punctuation">}</span>
</code></pre> 
<p>只要字符串点方法名即可, 看到这个顿时感觉便捷性这块kotlin确实比java强了太多！</p> 
<h2><a id="_269"></a><strong>空类型安全</strong></h2> 
<ul><li>kotlin中，<strong>指定类型的变量不能赋值为<code>null</code>，即空类型安全</strong></li></ul> 
<pre><code class="prism language-kotlin">  <span class="token keyword">var</span> nonNull<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello"</span></span>
  nonNull <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">//赋值为空，这一行编译器会报错</span>
  <span class="token keyword">val</span> length <span class="token operator">=</span> nonNull<span class="token punctuation">.</span>length <span class="token comment">//这样使用是安全的</span>
</code></pre> 
<p>就是说kotlin中明确的类型是不能赋值为一个null值的，这与java明显不同。</p> 
<ul><li><strong>定义可接受<code>null</code>类型的变量，在类型后面加一个 <code>?</code></strong></li></ul> 
<pre><code class="prism language-kotlin">   <span class="token keyword">var</span> nullable<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello"</span></span>
   <span class="token keyword">val</span> length <span class="token operator">=</span> nullable<span class="token operator">?</span><span class="token punctuation">.</span>length <span class="token comment">//安全访问可能为空的变量</span>
</code></pre> 
<p>这时变量可能为<code>null</code>, 所以要判空，判空方式 <code>?.</code> 比java简洁，有点类似js语法。</p> 
<p>但是用 <code>？.</code>操作符之后，如果变量为<code>null</code>，则最终等号左边的变量结果 也可能为<code>null</code>, 因此在使用<code>length</code>之前还要再判断<code>length</code>是否为<code>null</code>.</p> 
<pre><code class="prism language-kotlin">   <span class="token keyword">var</span> nullable<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello"</span></span>
   <span class="token keyword">val</span> length <span class="token operator">=</span> nullable<span class="token operator">?</span><span class="token punctuation">.</span>length <span class="token operator">?:</span> <span class="token number">0</span> <span class="token comment">//确保length不为空的写法 等价三目运算 boolean? a : b</span>
</code></pre> 
<p>其中操作符 <code>?:</code>等价于三目运算符，<code>length</code> 为<code>null</code> 返回右边的，不为<code>null</code>返回左边的。</p> 
<p>说明： <code>String</code> 类型是 <code>String?</code> 类型的子类， <code>Int</code> 类型是 <code>Number</code> 类型的子类，使用遵循里氏替换原则：所有使用父类的地方都可以使用子类替换，反之则不行</p> 
<pre><code class="prism language-kotlin">    <span class="token keyword">var</span> x<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Hello"</span></span>
    <span class="token keyword">var</span> y<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"World"</span></span>

<span class="token comment">//    x = y // Type mismatch</span>
    y <span class="token operator">=</span> x <span class="token comment">// OK</span>

    <span class="token keyword">var</span> a<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">var</span> b<span class="token operator">:</span> Number <span class="token operator">=</span> <span class="token number">10.0</span>

<span class="token comment">//    a = b // Type mismatch</span>
    b <span class="token operator">=</span> a <span class="token comment">// OK</span>
</code></pre> 
<ul><li><strong>引用其他平台语言的对象要使用<code>?.</code> 判空：</strong></li></ul> 
<p>java类</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>kotlin类</p> 
<pre><code class="prism language-kotlin">  <span class="token keyword">val</span> person <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个java的Person类实例</span>
  <span class="token keyword">val</span> title <span class="token operator">=</span> person<span class="token punctuation">.</span>title <span class="token comment">// 此时的title类型是java平台的String类型，不是kotlin的String类型</span>
  <span class="token comment">//kotlin中无法判断title的实际类型是来自哪个平台的，所以主动添加?.可确保安全访问</span>
  <span class="token keyword">val</span> titleLength <span class="token operator">=</span> title<span class="token operator">?</span><span class="token punctuation">.</span>length
</code></pre> 
<p>由于kotlin 支持java、javascript、native三个平台，并且在android项目中支持java和kotlin类混用，因此当在kotlin中导入java类的时候，kotlin无法判断导入类创建的对象属性的实际类型是来自哪个平台的，所以主动添加<code>?.</code>可确保安全访问。</p> 
<p>下面的例子也是一样：</p> 
<pre><code class="prism language-kotlin">    <span class="token keyword">val</span> file <span class="token operator">=</span> <span class="token function">File</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"abc"</span></span><span class="token punctuation">)</span> <span class="token comment">//这个File类是java的</span>
    <span class="token keyword">val</span> files <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">//因此这里的files使用可能为空，应该使用files?.size</span>
    <span class="token function">println</span><span class="token punctuation">(</span>files<span class="token punctuation">.</span>size<span class="token punctuation">)</span> 
</code></pre> 
<p>所以要注意导入的类是不是java的。当然有时出现可能为空时编译器也会给出提示，可以点击快速修复即可。但是java方法上没有加<code>@Nullable</code>注解的话，编译器也无法识别，这时要人工判断了。</p> 
<h2><a id="_344"></a><strong>类型强转</strong></h2> 
<pre><code class="prism language-kotlin">    <span class="token keyword">val</span> kotliner<span class="token operator">:</span> Kotliner <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"benny"</span></span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>kotliner <span class="token keyword">is</span> Person<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>kotliner <span class="token keyword">as</span> Person<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>使用 <code>is</code> 判断是否是实例，对比java的<code>instanceof</code><br> 使用 <code>as</code> 转换类型，对比java的小括号强制转换<br> 那如果类型转换失败呢，在java中不try-catch会直接抛异常，在kotlin中提供<code>？</code>的形式安全访问：</p> 
<pre><code class="prism language-kotlin">    <span class="token keyword">val</span> kotliner<span class="token operator">:</span> Kotliner <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"benny"</span></span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>kotliner <span class="token keyword">is</span> Person<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>kotliner <span class="token keyword">as</span><span class="token operator">?</span> Person<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><code>(kotliner as? Person)?.name</code> 其中 <code>as?</code> 表示转换失败返回null, 所以name前面也同时使用<code>？.</code>保证安全访问。</p> 
<h2><a id="_365"></a><strong>智能类型转换</strong></h2> 
<pre><code class="prism language-kotlin">    <span class="token keyword">var</span> value<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
    value <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"benny"</span></span> <span class="token comment">//如果显示的经过了类型赋值，在下面的使用是安全的</span>
<span class="token comment">//    if(value != null){<!-- --></span>
    <span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里kotlin会隐式的转成kotlin的String类型，不需要大括号</span>
        <span class="token comment">//value = null </span>
<span class="token comment">//    }</span>
</code></pre> 
<p>我的理解是显示的经过了类型赋值以后，那么再去<code>.</code>引用属性的时候就是安全的，因为kotlin转成了它的内部确定类型，不可能为<code>null</code>。</p> 
<p>慕课网上课程介绍说这里的<code>value</code>在大括号里面会转成<code>Sting</code>类型，出了大括号，<code>value</code>又会变成<code>String?</code>类型。我认为他这里说法是错误的，只是在调用<code>.length</code>时才会自动转换，如果调用完了会即刻恢复，而不是出了大括号。你可以把上面注释的代码恢复，你会发现在大括号中是可以给它赋值<code>null</code>的，这说明它还是<code>String?</code> 而不是<code>String</code>, 因为<code>String</code>是不能接受<code>null</code>的。</p> 
<ul><li><strong>外部变量不支持智能类型转换：</strong></li></ul> 
<pre><code class="prism language-kotlin"><span class="token keyword">var</span> tag<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tag <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//对顶级变量的使用会有风险，即便判断了null, 因为可能有其他线程修改了它的类型</span>
        <span class="token function">println</span><span class="token punctuation">(</span>tag<span class="token punctuation">.</span>length<span class="token punctuation">)</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里<code>if</code>即便判断了<code>null</code> ，还是会有风险，可能有线程安全问题，还是推荐使用 <code>?.</code>安全访问。</p> 
<p>总体来说，kotlin也会有<code>null</code>需要判空的情况，只不过判空的写法比java更简洁。但是在大多数情况下，你只要指定了变量定义的具体类型如<code>String</code>、<code>Int</code>就不会出现java的空指针问题。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/555e09f8a312c9e5e1bcf83dda264ae0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux 休眠唤醒中设备、总线、用户进程、内核线程调试分析流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f257904f02b71866d98dd720bbf356d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux 安装 mysql 【使用 tar.gz | tar.xz安装包-离线安装】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>