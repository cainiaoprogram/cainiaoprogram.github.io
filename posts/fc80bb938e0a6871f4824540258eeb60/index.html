<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Activiti 自定义事件监听和邮件通知 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Activiti 自定义事件监听和邮件通知" />
<meta property="og:description" content="Activiti 自定义事件监听和邮件通知 参照Activiti官方文档https://www.activiti.org/userguide/#eventDispatcher
首先，建立我们的需求。即当有任务创建、分配、完成时，邮件通知对应用户。
完成步骤如下：
Activiti为我们提供了事件监听接口– ActivitiEventListener org.activiti.engine.delegate.event.ActivitiEventType提供了各种可以监听到的事件类型
通过对应事件，获取有关联的用户，任务名称等。 public class OwnEventListener implements ActivitiEventListener { @Override public void onEvent(ActivitiEvent event) { System.out.println(&#34;Event received: &#34; &#43; event.getType()); if (event.getType() == ActivitiEventType.TASK_CREATED || event.getType() == ActivitiEventType.TASK_ASSIGNED || event.getType() == ActivitiEventType.TASK_COMPLETED) { ActivitiEntityEvent entityEvent = (ActivitiEntityEvent) event; TaskEntity taskEntity = (TaskEntity) entityEvent.getEntity(); MailWrapper.getInstance().sendTaskMail(taskEntity.getOwner(), taskEntity.getAssignee(), taskEntity.getName(), event.getType()); } } 最重要的一步就是强制将ActivitiEvent转换为其sub-interface(ActivitiEntityEvent)，再将获取的Entity强制转换为具体的Entity，最终获取相应信息。
在邮件发送模块，需要构建邮件模版，单例化邮件组件。
public class MailWrapper { private final Logger log = LoggerFactory.getLogger(MailWrapper.class); @Autowired private MailSender mailSender; private MailWrapper() { Velocity." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fc80bb938e0a6871f4824540258eeb60/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-11T11:45:28+08:00" />
<meta property="article:modified_time" content="2017-01-11T11:45:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Activiti 自定义事件监听和邮件通知</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="activiti-自定义事件监听和邮件通知">Activiti 自定义事件监听和邮件通知</h2> 
<p>参照Activiti官方文档<a href="https://www.activiti.org/userguide/#eventDispatcher" rel="nofollow">https://www.activiti.org/userguide/#eventDispatcher</a></p> 
<p>首先，建立我们的需求。即当有任务创建、分配、完成时，邮件通知对应用户。</p> 
<p>完成步骤如下：</p> 
<ol><li><p>Activiti为我们提供了事件监听接口– ActivitiEventListener </p></li><li><p>org.activiti.engine.delegate.event.ActivitiEventType提供了各种可以监听到的事件类型</p></li><li>通过对应事件，获取有关联的用户，任务名称等。</li></ol> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OwnEventListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ActivitiEventListener</span> {<!-- --></span>

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span>(ActivitiEvent event) {
        System.out.println(<span class="hljs-string">"Event received: "</span> + event.getType());

        <span class="hljs-keyword">if</span> (event.getType() == ActivitiEventType.TASK_CREATED
                || event.getType() == ActivitiEventType.TASK_ASSIGNED
                || event.getType() == ActivitiEventType.TASK_COMPLETED) {
            ActivitiEntityEvent entityEvent = (ActivitiEntityEvent) event;
            TaskEntity taskEntity = (TaskEntity) entityEvent.getEntity();
            MailWrapper.getInstance().sendTaskMail(taskEntity.getOwner(), taskEntity.getAssignee(), taskEntity.getName(), event.getType());
        }
    }</code></pre> 
<blockquote> 
 <p>最重要的一步就是强制将ActivitiEvent转换为其sub-interface(ActivitiEntityEvent)，再将获取的Entity强制转换为具体的Entity，最终获取相应信息。</p> 
</blockquote> 
<p>在邮件发送模块，需要构建邮件模版，单例化邮件组件。</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailWrapper</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(MailWrapper.class);

    <span class="hljs-annotation">@Autowired</span>
    <span class="hljs-keyword">private</span> MailSender mailSender;

    <span class="hljs-keyword">private</span> <span class="hljs-title">MailWrapper</span>() {
    Velocity.init(PropertiesUtil.readPropertiesInEnv(<span class="hljs-string">"vm.properties"</span>));
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrapperSingleton</span> {<!-- --></span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MailWrapper mv = <span class="hljs-keyword">new</span> MailWrapper();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MailWrapper <span class="hljs-title">getInstance</span>() {
        <span class="hljs-keyword">return</span> WrapperSingleton.mv;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendTaskMail</span>(String owner, String assignee, String taskName, ActivitiEventType eventType) {
        SimpleMailMessage msg = <span class="hljs-keyword">new</span> SimpleMailMessage();
        String toEmailAddress = KeystoneClient.getInstance().findEmailByUserId(assignee);
        String ownerName = KeystoneClient.getInstance().findNameByUserId(owner);
        String assigneeName = KeystoneClient.getInstance().findNameByUserId(assignee);

        TaskMail tMail = <span class="hljs-keyword">new</span> TaskMail(ownerName, assigneeName, taskName, eventType);
        VelocityContext model = <span class="hljs-keyword">new</span> VelocityContext();
        model.put(<span class="hljs-string">"task"</span>, tMail);

        Template template = Velocity.getTemplate(<span class="hljs-string">"template/task_email.vm"</span>, <span class="hljs-string">"utf8"</span>);

        StringWriter w = <span class="hljs-keyword">new</span> StringWriter();
        template.merge(model, w);

        msg.setSubject(<span class="hljs-string">"hello world"</span>);
        msg.setTo(toEmailAddress);
        msg.setText(w.toString());

        <span class="hljs-keyword">try</span> {
            mailSender.send(msg);

            log.info(<span class="hljs-string">"mail has been sent to "</span> + toEmailAddress);
        } <span class="hljs-keyword">catch</span> (MailException e) {
            System.err.println(e.getMessage());
        }
    }
}</code></pre> 
<p>在构建模版时，使用的是org.apache.velocity组件，其资源配置文件如下：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">resource<span class="hljs-preprocessor">.loader</span> = class
class<span class="hljs-preprocessor">.resource</span><span class="hljs-preprocessor">.loader</span><span class="hljs-preprocessor">.description</span> = Velocity Classpath Resource Loader
class<span class="hljs-preprocessor">.resource</span><span class="hljs-preprocessor">.loader</span><span class="hljs-preprocessor">.class</span> = org<span class="hljs-preprocessor">.apache</span><span class="hljs-preprocessor">.velocity</span><span class="hljs-preprocessor">.runtime</span><span class="hljs-preprocessor">.resource</span><span class="hljs-preprocessor">.loader</span><span class="hljs-preprocessor">.ClasspathResourceLoader</span></code></pre> 
<p>告诉velocity，加载我们定义的模版文件时，使用classloader资源路径。当然，也可以配置物理路径，具体请参照官网，这里不加赘述。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e325dbbb8eda20e871a8e70f5259a575/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu export 的作用 添加环境变量</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1b7aadc84920f5860b44d6385b7f30e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">百度地图显示的超详细过程介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>