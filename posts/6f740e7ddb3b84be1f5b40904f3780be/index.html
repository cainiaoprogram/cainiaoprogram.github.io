<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Send函数和Recv函数解析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Send函数和Recv函数解析" />
<meta property="og:description" content="下文摘自gogor的博客http://blog.csdn.net/gogor/article/details/5896931
Send函数和Recv函数解析
1. send函数
int send( SOCKET s, const char FAR *buf, int len, int flags ); 不论是客户端还是服务器端应用程序都用send函数来向TCP连接的另一端发送数据。
客户端程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。
该函数的：
第一个参数指定发送端套接字描述符；
第二个参数指明一个存放应用程序要发送数据的缓冲区；
第三个参数指明实际要发送的数据的字节数；
第四个参数一般置0。
这里只描述同步Socket的send函数的执行流程。当调用该函数时，send先比较待发送数据的长度len和套接字s的发送缓冲的长度，如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR；如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议 是否正在发送s的发送缓冲中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么 send就比较s的发送缓冲区的剩余空间和len，如果len大于剩余空间大小send就一直等待协议把s的发送缓冲中的数据发送完，如果len小于剩余 空间大小send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。
要注意send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。（每一个除send外的Socket函数在执 行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回 SOCKET_ERROR）
注意：在Unix系统下，如果send在等待协议传送数据时网络断开的话，调用send的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。
Send函数的返回值有三类：
（1）返回值=0：
（2）返回值&lt;0：发送失败，错误原因存于全局变量errno中
（3）返回值&gt;0：表示发送的字节数（实际上是拷贝到发送缓冲中的字节数）
错误代码：
EBADF 参数s 非合法的socket处理代码。
EFAULT 参数中有一指针指向无法存取的内存空间
ENOTSOCK 参数s为一文件描述词，非socket。
EINTR 被信号所中断。
EAGAIN 此操作会令进程阻断，但参数s的socket为不可阻断。
ENOBUFS 系统的缓冲内存不足
ENOMEM 核心内存不足
EINVAL 传给系统调用的参数不正确。
2. recv函数
int recv( SOCKET s, char FAR *buf, int len, int flags ); 不论是客户端还是服务器端应用程序都用recv函数从TCP连接的另一端接收数据。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6f740e7ddb3b84be1f5b40904f3780be/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-05-24T13:27:00+08:00" />
<meta property="article:modified_time" content="2013-05-24T13:27:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Send函数和Recv函数解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div class="article_content"> 
  <div class="Section0"> 
   <p class="p0">下文摘自gogor的博客<a href="http://blog.csdn.net/gogor/article/details/5896931">http://blog.csdn.net/gogor/article/details/5896931</a></p> 
   <p class="p0"><a href="http://blog.csdn.net/gogor/article/details/5896931">Send</a>函数和Recv函数解析</p> 
   <p class="p0" style="text-align:center;"> </p> 
   <p class="p0" style="text-align:center;"> </p> 
   <p class="p0">1. send函数</p> 
   <p class="p0">int send( SOCKET s, const char FAR *buf, int len, int flags );  </p> 
   <p class="p0">不论是客户端还是服务器端应用程序都用send函数来向TCP连接的另一端发送数据。</p> 
   <p class="p0">客户端程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。</p> 
   <p class="p0">该函数的：</p> 
   <p class="p0">第一个参数指定发送端套接字描述符；</p> 
   <p class="p0">第二个参数指明一个存放应用程序要发送数据的缓冲区；</p> 
   <p class="p0">第三个参数指明实际要发送的数据的字节数；</p> 
   <p class="p0">第四个参数一般置0。</p> 
   <p class="p0">这里只描述同步Socket的send函数的执行流程。当调用该函数时，send先比较待发送数据的长度len和套接字s的发送缓冲的长度，如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR；如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议 是否正在发送s的发送缓冲中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么 send就比较s的发送缓冲区的剩余空间和len，如果len大于剩余空间大小send就一直等待协议把s的发送缓冲中的数据发送完，如果len小于剩余 空间大小send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。</p> 
   <p class="p0">要注意send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。（每一个除send外的Socket函数在执 行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回 SOCKET_ERROR）</p> 
   <p class="p0">注意：在Unix系统下，如果send在等待协议传送数据时网络断开的话，调用send的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。</p> 
   <p class="p0">Send函数的返回值有三类：</p> 
   <p class="p0">（1）返回值=0：</p> 
   <p class="p0">（2）返回值&lt;0：发送失败，错误原因存于全局变量errno中</p> 
   <p class="p0">（3）返回值&gt;0：表示发送的字节数（实际上是拷贝到发送缓冲中的字节数）</p> 
   <p class="p0"> </p> 
   <p class="p0">错误代码：</p> 
   <p class="p0">EBADF 参数s 非合法的socket处理代码。<br>EFAULT 参数中有一指针指向无法存取的内存空间<br>ENOTSOCK 参数s为一文件描述词，非socket。<br>EINTR 被信号所中断。<br>EAGAIN 此操作会令进程阻断，但参数s的socket为不可阻断。<br>ENOBUFS 系统的缓冲内存不足<br>ENOMEM 核心内存不足<br>EINVAL 传给系统调用的参数不正确。</p> 
   <p class="p0"> </p> 
   <p class="p0">2.  recv函数</p> 
   <p class="p0">int recv( SOCKET s,     char FAR *buf,      int len,     int flags     );   </p> 
   <p class="p0">不论是客户端还是服务器端应用程序都用recv函数从TCP连接的另一端接收数据。</p> 
   <p class="p0">该函数的：</p> 
   <p class="p0">第一个参数指定接收端套接字描述符；</p> 
   <p class="p0">第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</p> 
   <p class="p0">第三个参数指明buf的长度；</p> 
   <p class="p0">第四个参数一般置0。</p> 
   <p class="p0">这里只描述同步Socket的recv函数的执行流程。当应用程序调用recv函数时，recv先等待s的发送缓冲 中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR，如果s的发送缓冲中没有数 据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，只到 协议把数据接收完毕。当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中（注意协议接收到的数据可能大于buf的长度，所以 在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的），recv函数返回其实际copy的字节数。如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</p> 
   <p class="p0">注意：在Unix系统下，如果recv函数在等待协议接收数据时网络断开了，那么调用recv的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。</p> 
   <p class="p0"> </p> 
   <p class="p0">默认情况下socket是阻塞的。</p> 
   <p class="p0">阻塞与非阻塞recv返回值没有区别，都是：</p> 
   <p class="p0">&lt;0 出错</p> 
   <p class="p0">=0 对方调用了close API来关闭连接</p> 
   <p class="p0">&gt;0 接收到的数据大小，</p> 
   <p class="p0"> </p> 
   <p class="p0">特别地：返回值&lt;0时并且(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)的情况下认为连接是正常的，继续接收。</p> 
   <p class="p0">只是阻塞模式下recv会一直阻塞直到接收到数据，非阻塞模式下如果没有数据就会返回，不会阻塞着读，因此需要循环读取）。</p> 
   <p class="p0"> </p> 
   <p class="p0">返回说明：   </p> 
   <p class="p0">（1）成功执行时，返回接收到的字节数。</p> 
   <p class="p0">（2）若另一端已关闭连接则返回0，这种关闭是对方主动且正常的关闭</p> 
   <p class="p0">（3）失败返回-1，errno被设为以下的某个值   </p> 
   <p class="p0">EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时</p> 
   <p class="p0">EBADF：sock不是有效的描述词</p> 
   <p class="p0">ECONNREFUSE：远程主机阻绝网络连接</p> 
   <p class="p0">EFAULT：内存空间访问出错</p> 
   <p class="p0">EINTR：操作被信号中断</p> 
   <p class="p0">EINVAL：参数无效</p> 
   <p class="p0">ENOMEM：内存不足</p> 
   <p class="p0">ENOTCONN：与面向连接关联的套接字尚未被连接上</p> 
   <p class="p0">ENOTSOCK：sock索引的不是套接字</p> 
  </div> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/flash610/archive/2013/05/24/3096681.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03b8299ce69154b375c8d348f98fd091/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ios打包IPA的各种问题和解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c26ade2dd8e542709847ec578c4bdde8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">H3C 登陆用户及权限</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>