<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MIT 计算机教育中缺失的一课 笔记：命令行环境 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MIT 计算机教育中缺失的一课 笔记：命令行环境" />
<meta property="og:description" content="MIT 计算机教育中缺失的一课 笔记：命令行环境 写在前面：本篇内容来自于 MIT 推出的课程：计算机教育中缺失的一课，这门课程介绍了命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等。中文课程主页：https://missing-semester-cn.github.io/
本篇内容为第五节：命令行环境。本节的主要内容如下：
如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。一些能够改善 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的如何使用 SSH 操作远端机器 任务控制 结束进程 Shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种_软件中断_。
当我们输入 Ctrl-C 时，shell 会发送一个 SIGINT (interrupt program) 信号到进程。另外一个退出程序的信号：SIGQUIT (quit program) ，可以通过 Ctrl-\ 触发。
尽管 SIGINT 和 SIGQUIT 都常常用来发出和终止程序相关的请求。SIGTERM 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 kill 命令, 它的语法是： kill -TERM &lt;PID&gt;。
暂停和后台执行进程 在终端中，键入 Ctrl-Z 会让 shell 发送 SIGTSTP 信号。此时，程序被挂起，并没有结束。
使用 jobs 命令，可以查看当前会话中的进程。当程序被挂起时，可以使用 fg 命令，将挂起的程序继续执行，或者使用 bg 命令，将程序放到后台继续执行。可以通过 jobs 打印结果中的进程标号，来引用某一个进程，如进程标号为 [1]，后续可以通过 bg %1 的方式来将该进程在后台运行，也可以通过 kill %1 的方式杀掉该进程。
执行命令时，在最后添加 &amp; ，可以直接让程序在后台执行。但是注意，这个进程仍然是终端的子进程，所以关闭终端时，这个进程也会被终止（此时发送的信号为 SIGHUP）。为了防止这种情况，可以在程序最前使用 nohup 程序：nohup command command_options，此时关掉终端，程序仍然会继续执行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/614413c7a7e6681d47885fa829493ff7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-10T21:42:46+08:00" />
<meta property="article:modified_time" content="2021-05-10T21:42:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MIT 计算机教育中缺失的一课 笔记：命令行环境</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="MIT___0"></a>MIT 计算机教育中缺失的一课 笔记：命令行环境</h2> 
<p><em>写在前面：本篇内容来自于 MIT 推出的课程：计算机教育中缺失的一课，这门课程介绍了命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等。中文课程主页：https://missing-semester-cn.github.io/</em></p> 
<p>本篇内容为第五节：命令行环境。本节的主要内容如下：</p> 
<ol><li>如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。</li><li>一些能够改善 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的</li><li>如何使用 SSH 操作远端机器</li></ol> 
<h3><a id="_9"></a>任务控制</h3> 
<h4><a id="_11"></a>结束进程</h4> 
<p>Shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种_软件中断_。</p> 
<p>当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个 <code>SIGINT</code> (interrupt program) 信号到进程。另外一个退出程序的信号：<code>SIGQUIT</code> (quit program) ，可以通过 <code>Ctrl-\</code> 触发。</p> 
<p>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个<strong>更加通用的、也更加优雅地退出信号</strong>。为了发出这个信号我们需要使用 <code>kill</code> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。</p> 
<h4><a id="_19"></a>暂停和后台执行进程</h4> 
<p>在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号。此时，程序被挂起，并没有结束。</p> 
<p>使用 <code>jobs</code> 命令，可以查看当前会话中的进程。当程序被挂起时，可以使用 <code>fg</code> 命令，将挂起的程序继续执行，或者使用 <code>bg</code> 命令，将程序放到后台继续执行。可以通过 <code>jobs</code> 打印结果中的进程标号，来引用某一个进程，如进程标号为 <code>[1]</code>，后续可以通过 <code>bg %1</code> 的方式来将该进程在后台运行，也可以通过 <code>kill %1</code> 的方式杀掉该进程。</p> 
<p>执行命令时，在最后添加 <code>&amp;</code> ，可以直接让程序在后台执行。但是注意，这个进程仍然是终端的子进程，所以关闭终端时，这个进程也会被终止（此时发送的信号为 <code>SIGHUP</code>）。为了防止这种情况，可以在程序最前使用 <code>nohup</code> 程序：<code>nohup command command_options</code>，此时关掉终端，程序仍然会继续执行。</p> 
<p>以下代码演示了这些命令：</p> 
<pre><code class="prism language-bash">❯ <span class="token function">sleep</span> 1000
^Z
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  + 60227 suspended  <span class="token function">sleep</span> 1000
❯ <span class="token function">nohup</span> <span class="token function">sleep</span> 2000 <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>2<span class="token punctuation">]</span> 60237
appending output to nohup.out
❯ <span class="token function">jobs</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  + suspended  <span class="token function">sleep</span> 1000
<span class="token punctuation">[</span>2<span class="token punctuation">]</span>  - running    <span class="token function">nohup</span> <span class="token function">sleep</span> 2000
❯ <span class="token function">bg</span> %1
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  - 60227 continued  <span class="token function">sleep</span> 1000
❯ <span class="token function">jobs</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  - running    <span class="token function">sleep</span> 1000
<span class="token punctuation">[</span>2<span class="token punctuation">]</span>  + running    <span class="token function">nohup</span> <span class="token function">sleep</span> 2000
❯ <span class="token function">kill</span> %1
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  - 60227 terminated  <span class="token function">sleep</span> 1000
❯ <span class="token function">jobs</span>
<span class="token punctuation">[</span>2<span class="token punctuation">]</span>  + running    <span class="token function">nohup</span> <span class="token function">sleep</span> 2000
❯ <span class="token function">kill</span> -SIGHUP %2
❯ <span class="token function">jobs</span>
<span class="token punctuation">[</span>2<span class="token punctuation">]</span>  + running    <span class="token function">nohup</span> <span class="token function">sleep</span> 2000
❯ <span class="token function">kill</span> %2
<span class="token punctuation">[</span>2<span class="token punctuation">]</span>  + 60237 terminated  <span class="token function">nohup</span> <span class="token function">sleep</span> 2000
❯ <span class="token function">jobs</span>

</code></pre> 
<p>以下为 Linux 系统中的信号列表，具体可以通过 <code>man signal</code> 来查询：</p> 
<pre><code class="prism language-bash">     No    Name         Default Action       Description
     1     SIGHUP       terminate process    terminal line hangup
     2     SIGINT       terminate process    interrupt program
     3     SIGQUIT      create core image    quit program
     4     SIGILL       create core image    illegal instruction
     5     SIGTRAP      create core image    trace <span class="token function">trap</span>
     6     SIGABRT      create core image    abort program <span class="token punctuation">(</span>formerly SIGIOT<span class="token punctuation">)</span>
     7     SIGEMT       create core image    emulate instruction executed
     8     SIGFPE       create core image    floating-point exception
     9     SIGKILL      terminate process    <span class="token function">kill</span> program
     10    SIGBUS       create core image    bus error
     11    SIGSEGV      create core image    segmentation violation
     12    SIGSYS       create core image    non-existent system call invoked
     13    SIGPIPE      terminate process    <span class="token function">write</span> on a pipe with no reader
     14    SIGALRM      terminate process    real-time timer expired
     15    SIGTERM      terminate process    software termination signal
     16    SIGURG       discard signal       urgent condition present on socket
     17    SIGSTOP      stop process         stop <span class="token punctuation">(</span>cannot be caught or ignored<span class="token punctuation">)</span>
     18    SIGTSTP      stop process         stop signal generated from keyboard
     19    SIGCONT      discard signal       <span class="token keyword">continue</span> after stop
     20    SIGCHLD      discard signal       child status has changed
     21    SIGTTIN      stop process         background <span class="token function">read</span> attempted from control terminal
     22    SIGTTOU      stop process         background <span class="token function">write</span> attempted to control terminal
     23    SIGIO        discard signal       I/O is possible on a descriptor <span class="token punctuation">(</span>see fcntl<span class="token punctuation">(</span>2<span class="token punctuation">))</span>
     24    SIGXCPU      terminate process    cpu <span class="token function">time</span> limit exceeded <span class="token punctuation">(</span>see setrlimit<span class="token punctuation">(</span>2<span class="token punctuation">))</span>
     25    SIGXFSZ      terminate process    <span class="token function">file</span> size limit exceeded <span class="token punctuation">(</span>see setrlimit<span class="token punctuation">(</span>2<span class="token punctuation">))</span>
     26    SIGVTALRM    terminate process    virtual <span class="token function">time</span> alarm <span class="token punctuation">(</span>see setitimer<span class="token punctuation">(</span>2<span class="token punctuation">))</span>
     27    SIGPROF      terminate process    profiling timer alarm <span class="token punctuation">(</span>see setitimer<span class="token punctuation">(</span>2<span class="token punctuation">))</span>
     28    SIGWINCH     discard signal       Window size change
     29    SIGINFO      discard signal       status request from keyboard
     30    SIGUSR1      terminate process    User defined signal 1
     31    SIGUSR2      terminate process    User defined signal 2
</code></pre> 
<h3><a id="Terminal_multiplexer_94"></a>终端多路复用（Terminal multiplexer）</h3> 
<p>来自维基百科的解释：终端多路复用器是一种软件应用程序，可用于在单个终端显示器，终端仿真器窗口，PC /工作站系统控制台或远程登录会话中<strong>多路复用几个单独的基于伪终端的登录会话</strong>，或者<strong>从终端分离和重新附加会话</strong>。最常用的终端多路复用软件为 <code>tmux</code> 。</p> 
<p><code>tmux</code> 中有三个非常重要的概念，分别为：会话、窗口和面板，关于其有很多重要的快捷键需要掌握：</p> 
<ul><li><strong>会话</strong> - <strong>每个会话都是一个独立的工作区</strong>，其中包含一个或多个窗口 
  <ul><li>在终端输入 <code>tmux</code> 开始一个新的会话</li><li><code>tmux new -s NAME</code> 以指定名称开始一个新的会话</li><li><code>tmux ls</code> 列出当前所有会话</li><li>在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> (detach)，将当前会话分离</li><li><code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t NAME</code> 来指定具体的会话</li></ul> </li><li><strong>窗口</strong> - 相当于编辑器或是浏览器中的<strong>标签页</strong>，从视觉上将一个会话分割为多个部分 
  <ul><li><code>&lt;C-b&gt; c</code> (create)创建一个新的窗口，使用 <code>&lt;C-d&gt;</code> 将其关闭</li><li><code>&lt;C-b&gt; N</code> 跳转到第 <code>N</code> 个窗口，注意每个窗口都是有编号的</li><li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li><li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li><li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li><li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li></ul> </li><li><strong>面板</strong> - 像 <code>vim</code> 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell 
  <ul><li><code>&lt;C-b&gt; "</code> 水平分割</li><li><code>&lt;C-b&gt; %</code> 垂直分割</li><li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，<code>&lt;方向&gt;</code> 指的是键盘上的方向键</li><li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放（把当前面板缩放到最大）</li><li><code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。可以按下空格键来开始选择，回车键复制选中的部分（非常有用）</li><li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li></ul> </li></ul> 
<h3><a id="_121"></a>别名设置</h3> 
<p>设置别名可以节省大量时间，将经常输入的命令设置为非常短的标记，用法为：<code>alias alias_name="command arg1 arg2"</code>，以下是几个示例：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 创建常用命令的缩写</span>
<span class="token function">alias</span> ll<span class="token operator">=</span><span class="token string">"ls -lh"</span>

<span class="token comment"># 能够少输入很多</span>
<span class="token function">alias</span> gs<span class="token operator">=</span><span class="token string">"git status"</span>
<span class="token function">alias</span> gc<span class="token operator">=</span><span class="token string">"git commit"</span>
<span class="token function">alias</span> v<span class="token operator">=</span><span class="token string">"vim"</span>

<span class="token comment"># 手误打错命令也没关系</span>
<span class="token function">alias</span> sl<span class="token operator">=</span>ls

<span class="token comment"># 重新定义一些命令行的默认行为</span>
<span class="token function">alias</span> mv<span class="token operator">=</span><span class="token string">"mv -i"</span>           <span class="token comment"># -i prompts before overwrite</span>
<span class="token function">alias</span> mkdir<span class="token operator">=</span><span class="token string">"mkdir -p"</span>     <span class="token comment"># -p make parent dirs as needed</span>
<span class="token function">alias</span> df<span class="token operator">=</span><span class="token string">"df -h"</span>           <span class="token comment"># -h prints human readable format</span>

<span class="token comment"># 别名可以组合使用</span>
<span class="token function">alias</span> la<span class="token operator">=</span><span class="token string">"ls -A"</span>
<span class="token function">alias</span> lla<span class="token operator">=</span><span class="token string">"la -l"</span>

<span class="token comment"># 在忽略某个别名</span>
\ls
<span class="token comment"># 或者禁用别名</span>
<span class="token function">unalias</span> la

<span class="token comment"># 获取别名的定义</span>
<span class="token function">alias</span> ll
<span class="token comment"># 会打印 ll='ls -lh'</span>
</code></pre> 
<p>需要将想要设置别名的代码保存到 shell 的启动文件里，比如 <code>.bashrc</code> 或 <code>.zshrc</code>。</p> 
<h3><a id="_158"></a>配置文件</h3> 
<p>一些常见的配置文件，位于用户目录下，以 <code>.</code> 开头：</p> 
<ul><li><code>bash</code> - <code>~/.bashrc</code> 或 <code>~/.bash_profile</code></li><li><code>git</code> - <code>~/.gitconfig</code></li><li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</li><li><code>ssh</code> - <code>~/.ssh/config</code></li><li><code>tmux</code> - <code>~/.tmux.conf</code></li></ul> 
<p>管理这些配置文件推荐的方式：将这些文件都放到一个目录下，然后通过 <code>git</code> 控制版本，通过链接的方式，将文件链接到对应的文件上。这样的好处是显而易见的：如果有多台电脑需要配置，可以一键配置；并且更改配置也会同步到每一台电脑。</p> 
<h3><a id="_169"></a>远端设备</h3> 
<p>通过 <code>ssh</code> 连接远程服务器，服务器可以通过 URL 指定（例如 <code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。</p> 
<p>可以直接通过 <code>ssh foobar@server ls</code> 来在服务器上执行 <code>ls</code> 命令，只准备执行一条命令时非常方便。</p> 
<p>使用秘钥连接远程服务器时，需要向服务器证明客户端持有对应的私钥。本地生成私钥：使用 <code>ssh-keygen</code>。将公钥传到服务器，有以下两种方式：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 第一种方式，直接上传</span>
<span class="token function">cat</span> .ssh/id_ed25519.pub <span class="token operator">|</span> <span class="token function">ssh</span> foobar@remote <span class="token string">'cat &gt;&gt; ~/.ssh/authorized_keys'</span>

<span class="token comment"># 第二种方式，需要本地支持 ssh-copy-id</span>
ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote

</code></pre> 
<p>通过 SSH 复制文件，可以使用 <code>scp</code> 命令，语法为：<code>scp path/to/local_file remote_host:path/to/remote_file</code>。更好的是使用 <code>rsync</code>，它对 <code>scp</code> 进行了改进，可以检测本地和远端的文件以防止重复拷贝。</p> 
<h4><a id="_SSH__188"></a>使用 SSH 端口转发</h4> 
<p>端口转发有两种：本地端口转发和远程端口转发。</p> 
<p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 <code>Jupyter notebook</code> 并监听 <code>8888</code> 端口。 然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p> 
<h4><a id="SSH__194"></a>SSH 配置文件</h4> 
<p>由于各种选项的存在，SSH 命令可能会很长，我们可以通过配置 <code>~/.ssh/config</code> 文件，来保存服务器的配置，这个文件可以被 <code>scp</code> 和 <code>rsync</code> 等命令读取，转换为对应的命令行选项。配置示例：</p> 
<pre><code class="prism language-bash">Host vm
    User foobar
    HostName 172.16.174.141
    Port 2222
    IdentityFile ~/.ssh/id_ed25519
    LocalForward 9999 localhost:8888

<span class="token comment"># 在配置文件中也可以使用通配符</span>
Host *.mit.edu
    User foobaz
</code></pre> 
<hr> 
<h3><a id="_213"></a>课后练习</h3> 
<h4><a id="_215"></a>任务控制</h4> 
<ol><li> <p>我们可以使用类似 <code>ps aux | grep</code> 这样的命令来获取任务的 <code>pid</code> ，然后您可以基于 <code>pid</code> 来结束这些进程。但我们其实有更好的方法来做这件事。在终端中执行 <code>sleep 10000</code> 这个任务。然后用 <code>Ctrl-Z</code> 将其切换到后台并使用 <code>bg</code> 来继续它的执行。现在，使用 <code>pgrep</code> 来查找 <code>pid</code> 并使用 <code>pkill</code> 结束进程而不需要手动输入 <code>pid</code>。(提示：: 使用 <code>-af</code> 标记)。</p> <pre><code class="prism language-bash">❯ <span class="token function">sleep</span> 10000
^Z
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  + 62750 suspended  <span class="token function">sleep</span> 10000
❯ <span class="token function">bg</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  + 62750 continued  <span class="token function">sleep</span> 10000
❯ pgrep <span class="token function">sleep</span>
62750
❯ <span class="token function">pkill</span> -af <span class="token function">sleep</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  + 62750 terminated  <span class="token function">sleep</span> 10000
</code></pre> </li><li> <p>如果您希望某个进程结束后再开始另外一个进程， 应该如何实现呢？在这个练习中，我们使用 <code>sleep 60 &amp;</code> 作为先执行的程序。一种方法是使用 <code>wait</code> 命令。尝试启动这个休眠命令，然后待其结束后再执行 <code>ls</code> 命令。</p> <pre><code class="prism language-bash">❯ <span class="token function">sleep</span> 10 <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>3<span class="token punctuation">]</span> 62850
<span class="token comment"># wait 只能够等待当前 shell 的子进程</span>
❯ <span class="token function">wait</span> 62850<span class="token punctuation">;</span> <span class="token function">ls</span>
<span class="token punctuation">[</span>3<span class="token punctuation">]</span>  + 62850 <span class="token keyword">done</span>       <span class="token function">sleep</span> 10
</code></pre> <p>但是，如果我们在不同的 bash 会话中进行操作，则上述方法就不起作用了。因为 <code>wait</code> 只能对子进程起作用。之前我们没有提过的一个特性是，<code>kill</code> 命令成功退出时其状态码为 <code>0</code> ，其他状态则是非 <code>0</code>。<code>kill -0</code> 则不会发送信号，但是会在进程不存在时返回一个不为 <code>0</code> 的状态码。请编写一个 <code>bash</code> 函数 <code>pidwait</code> ，它接受一个 <code>pid</code> 作为输入参数，然后一直等待直到该进程结束。您需要使用 <code>sleep</code> 来避免浪费 <code>CPU</code> 性能。</p> <p><code>wait</code> 程序实现：</p> <pre><code class="prism language-bash">myWait<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	pid<span class="token operator">=</span><span class="token variable">$1</span>
	<span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    	<span class="token function">kill</span> -0 <span class="token variable">$pid</span>
    	<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        	<span class="token keyword">echo</span> <span class="token string">"process exists, wait for 1 seconds..."</span>
        	<span class="token function">sleep</span> 1
    	<span class="token keyword">else</span>
        	<span class="token keyword">break</span>
    	<span class="token keyword">fi</span>
	<span class="token keyword">done</span>
	<span class="token keyword">echo</span> <span class="token string">"process finished!"</span>
	<span class="token function">ls</span>
<span class="token punctuation">}</span>
</code></pre> <p>将程序保存为 <code>wait.sh</code> ，程序执行与结果：</p> <pre><code class="prism language-bash">❯ <span class="token function">source</span> wait.sh
❯ <span class="token function">sleep</span> 10
^Z
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  + 63612 suspended  <span class="token function">sleep</span> 10
❯ <span class="token function">bg</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  + 63612 continued  <span class="token function">sleep</span> 10
❯ myWait 63612
process exists, <span class="token function">wait</span> <span class="token keyword">for</span> 1 seconds<span class="token punctuation">..</span>.
process exists, <span class="token function">wait</span> <span class="token keyword">for</span> 1 seconds<span class="token punctuation">..</span>.
process exists, <span class="token function">wait</span> <span class="token keyword">for</span> 1 seconds<span class="token punctuation">..</span>.
process exists, <span class="token function">wait</span> <span class="token keyword">for</span> 1 seconds<span class="token punctuation">..</span>.
process exists, <span class="token function">wait</span> <span class="token keyword">for</span> 1 seconds<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>  + 63612 <span class="token keyword">done</span>       <span class="token function">sleep</span> 10
myWait:kill:3: <span class="token function">kill</span> 63612 failed: no such process
process finished<span class="token operator">!</span>
wait.sh
</code></pre> </li></ol> 
<h4><a id="_280"></a>终端多路复用</h4> 
<ol><li>请完成这个 <code>tmux</code> 教程：<a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/" rel="nofollow">https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/</a></li><li>参考这些步骤来学习如何自定义 <code>tmux</code>：<a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/" rel="nofollow">https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/</a> 
  <ol><li>配置文件位于：<code>~/.tmux.conf</code></li><li>将前缀从 <code>Ctrl+b</code> 替换为 <code>Ctrl+a</code>，方便输入<pre><code class="prism language-bash"><span class="token comment"># remap prefix from 'C-b' to 'C-a'</span>
unbind C-b
set-option -g prefix C-a
bind-key C-a send-prefix
</code></pre> </li><li>使用 <code>|</code> 将面板垂直分割，使用 <code>-</code> 将面板水平分割<pre><code class="prism language-bash"><span class="token comment"># split panes using | and -</span>
bind <span class="token operator">|</span> split-window -h
bind - split-window -v
unbind <span class="token string">'"'</span>
unbind %
</code></pre> </li><li>更快捷地重载配置，使用 <code>前缀+r</code><pre><code class="prism language-bash"><span class="token comment"># reload config file (change file location to your the tmux.conf you want to use)</span>
bind r source-file ~/.tmux.conf \<span class="token punctuation">;</span> display-message <span class="token string">"Config reloaded..."</span>
</code></pre> </li><li>更快捷地切换面板，使用 <code>Alt</code> 键加方向键来切换面板<pre><code class="prism language-bash"><span class="token comment"># switch panes using Alt-arrow without prefix</span>
bind -n M-Left select-pane -L
bind -n M-Right select-pane -R
bind -n M-Up select-pane -U
bind -n M-Down select-pane -D
</code></pre> </li><li>开启鼠标模式（不一定需要）<pre><code class="prism language-bash"><span class="token comment"># Enable mouse mode (tmux 2.1 and above)</span>
<span class="token keyword">set</span> -g mouse on
</code></pre> </li><li>停止自动重命名窗口，通过 <code>,</code> 手动重命名，每个窗口可以执行不同的上下文</li></ol> </li></ol> 
<h4><a id="_320"></a>别名</h4> 
<ol><li>创建一个 <code>dc</code> 别名，它的功能是当我们错误的将 <code>cd</code> 输入为 <code>dc</code> 时也能正确执行。<pre><code class="prism language-bash"><span class="token function">alias</span> dc<span class="token operator">=</span><span class="token string">"cd"</span>
</code></pre> </li><li>执行 <code>history | awk '{$1="";print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10</code> 来获取您最常用的十条命令，尝试为它们创建别名。注意：这个命令只在 Bash 中生效，如果您使用 ZSH，使用 <code>history 1</code> 替换 <code>history</code>。</li></ol> 
<h4><a id="_328"></a>配置文件</h4> 
<p>让我们帮助您进一步学习配置文件：</p> 
<ol><li>为您的配置文件新建一个文件夹，并设置好版本控制</li><li>在其中添加至少一个配置文件，比如说您的 shell，在其中包含一些自定义设置（可以从设置 <code>$PS1</code> 开始）。</li><li>建立一种在新设备进行快速安装配置的方法（无需手动操作）。最简单的方法是写一个 shell 脚本对每个文件使用 <code>ln -s</code>，也可以使用专用工具</li><li>在新的虚拟机上测试该安装脚本。</li><li>将您现有的所有配置文件移动到项目仓库里。</li><li>将项目发布到 GitHub。</li></ol> 
<p>我将我的 <code>tmux</code>、<code>vim</code> 和 <code>zsh</code> 的配置文件上传到了 GitHub，欢迎基于此进行修改：<a href="https://github.com/chris-algo/dotfiles">https://github.com/chris-algo/dotfiles</a> 。</p> 
<hr> 
<h3><a id="_343"></a>广告时间</h3> 
<p>如果您喜欢我的文章，欢迎给我点赞关注！</p> 
<p>也欢迎关注我的公众号：算法小哥克里斯。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bdfc44d3fb442fc0f0a34fcc3d547a17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">spring---AOP---学习记录---21.05.10</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab3817647bc2d36b26462bb6a3deca10/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Nginx、HAProxy、LVS三者的优缺点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>