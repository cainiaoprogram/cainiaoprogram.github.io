<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring AOP中CGLIB代理对象增强通知执行原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring AOP中CGLIB代理对象增强通知执行原理" />
<meta property="og:description" content="前置博文：
Spring AOP中如何为Bean创建代理？
Spring AOP中是如何注册Advisor的？
Spring AOP如何为目标方法创建拦截器链？
Spring AOP拦截器调用的实现
Spring AOP中CGLIB代理对象增强通知执行原理
或者换句话说，当我们定义了切面、pointcut以及advice后，这些是如何对我们的目标对象生效的。本文这里以CglibAopProxy为例说明，至于jdk动态代理可以自行查看JdkDynamicAopProxy的invoke方法（大概流程与CGLIB代理一致）。
cglib代理为目标对象增强执行是通过CglibAopProxy的callbacks进行拦截处理的，入口在DynamicAdvisedInterceptor的intercept方法；
jdk动态代理则是通过JdkDynamicAopProxy#invoke方法进行拦截处理，流程与CGLIB类似，都是获取到拦截器链遍历调用。
继续结合前面博文分析，我们从代码角度解读其执行流程。假设我们有切面如下：
@Aspect @Component public class LogAspect { //注意这里我们没有限制方法修饰符 ，以 * 表示匹配所有 @Pointcut(&#34;execution(* com.recommend.controller.*.*(..))&#34;) public void logPointCut() { } @Before(value = &#34;execution(* com.recommend.controller.*.*(..))&#34;) public void beforeMethod(JoinPoint point) { System.out.println(&#34; before(Joinpoint point)&#34;); } @After(&#34;logPointCut()&#34;) public void afterMethod(JoinPoint point) { System.out.println(&#34; afterMethod(Joinpoint point)&#34;); } @AfterReturning(pointcut = &#34;logPointCut()&#34;,returning=&#34;result&#34;) public void AfterReturning(JoinPoint point,Object result) { System.out.println(&#34; AfterReturning(Joinpoint point)&#34;); } @AfterThrowing(value = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5411bb0807f71de959da4dfb83557ce4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-17T09:44:27+08:00" />
<meta property="article:modified_time" content="2022-07-17T09:44:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring AOP中CGLIB代理对象增强通知执行原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>前置博文：</strong><br> <a href="https://blog.csdn.net/J080624/article/details/83444209">Spring AOP中如何为Bean创建代理？</a><br> <a href="https://janus.blog.csdn.net/article/details/87894643" rel="nofollow">Spring AOP中是如何注册Advisor的？</a><br> <a href="https://blog.csdn.net/J080624/article/details/54598734">Spring AOP如何为目标方法创建拦截器链？</a><br> <a href="https://blog.csdn.net/J080624/article/details/54600945">Spring AOP拦截器调用的实现</a><br> <a href="https://blog.csdn.net/J080624/article/details/54972750">Spring AOP中CGLIB代理对象增强通知执行原理</a></p> 
<p>或者换句话说，当我们定义了切面、pointcut以及advice后，这些是如何对我们的目标对象生效的。本文这里以CglibAopProxy为例说明，至于jdk动态代理可以自行查看JdkDynamicAopProxy的invoke方法（大概流程与CGLIB代理一致）。</p> 
<blockquote> 
 <p>cglib代理为目标对象增强执行是通过CglibAopProxy的callbacks进行拦截处理的，入口在DynamicAdvisedInterceptor的intercept方法；<br> jdk动态代理则是通过JdkDynamicAopProxy#invoke方法进行拦截处理，流程与CGLIB类似，都是获取到拦截器链遍历调用。</p> 
</blockquote> 
<p>继续结合前面博文分析，我们从代码角度解读其执行流程。假设我们有切面如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogAspect</span> <span class="token punctuation">{<!-- --></span>

<span class="token comment">//注意这里我们没有限制方法修饰符 ，以 * 表示匹配所有</span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* com.recommend.controller.*.*(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logPointCut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"execution(* com.recommend.controller.*.*(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">beforeMethod</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> point<span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" before(Joinpoint point)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"logPointCut()"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterMethod</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> point<span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" afterMethod(Joinpoint point)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span>pointcut <span class="token operator">=</span> <span class="token string">"logPointCut()"</span><span class="token punctuation">,</span>returning<span class="token operator">=</span><span class="token string">"result"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">AfterReturning</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> point<span class="token punctuation">,</span><span class="token class-name">Object</span> result<span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" AfterReturning(Joinpoint point)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"logPointCut()"</span><span class="token punctuation">,</span>throwing<span class="token operator">=</span><span class="token string">"exception"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">AfterThrowing</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> point<span class="token punctuation">,</span><span class="token class-name">Exception</span> exception<span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" AfterThrowing(Joinpoint point)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"logPointCut()"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">around</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> point<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">long</span> beginTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 执行方法</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> point<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 执行时长(毫秒)</span>
        <span class="token keyword">long</span> time <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> beginTime<span class="token punctuation">;</span>
        <span class="token comment">//异步保存日志</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="1Spring_AOP_55"></a>【1】Spring AOP执行前的数据状态</h2> 
<p>如下图所示在请求执行流程时，这里就意味着反射调用目标方法。如果没有AOP增强，那么就会直接进入到我们的方法中。</p> 
<p><img src="https://images2.imgbox.com/72/cb/MicGRCXH_o.png" alt="在这里插入图片描述"><br> 从执行栈可以看到，这里进入了代理方法。</p> 
<p><img src="https://images2.imgbox.com/a7/bb/M4hDU3TM_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>我们先看一下此时代理对象的数据状态。</strong></p> 
<p>当前对象是一个代理对象，有七个回调实例，参数为目标方法参数BindingAwareModelMap.</p> 
<pre><code class="prism language-java">CGLIB$CALLBACK_0 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">CglibAopProxy</span>$<span class="token class-name">DynamicAdvisedInterceptor</span><span class="token annotation punctuation">@9685</span><span class="token punctuation">}</span> 
CGLIB$CALLBACK_1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">CglibAopProxy</span>$<span class="token class-name">StaticUnadvisedInterceptor</span><span class="token annotation punctuation">@9703</span><span class="token punctuation">}</span> 
CGLIB$CALLBACK_2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">CglibAopProxy</span>$<span class="token class-name">SerializableNoOp</span><span class="token annotation punctuation">@9704</span><span class="token punctuation">}</span> 
CGLIB$CALLBACK_3 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">CglibAopProxy</span>$<span class="token class-name">StaticDispatcher</span><span class="token annotation punctuation">@9705</span><span class="token punctuation">}</span> 
CGLIB$CALLBACK_4 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">CglibAopProxy</span>$<span class="token class-name">AdvisedDispatcher</span><span class="token annotation punctuation">@9707</span><span class="token punctuation">}</span> 
CGLIB$CALLBACK_5 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">CglibAopProxy</span>$<span class="token class-name">EqualsInterceptor</span><span class="token annotation punctuation">@9708</span><span class="token punctuation">}</span> 
CGLIB$CALLBACK_6 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">CglibAopProxy</span>$<span class="token class-name">HashCodeInterceptor</span><span class="token annotation punctuation">@9709</span><span class="token punctuation">}</span> 
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/fa/vLkBMw3C_o.png" alt="在这里插入图片描述"><br> 其中callback 1 3实例对象维护了target，我们实际的目标实例对象。</p> 
<p><img src="https://images2.imgbox.com/3d/11/Us9WU5NB_o.png" alt="在这里插入图片描述"><br> 而callback 0 4 5 6实例对象维护了advised也就是ProxyFactory实例。</p> 
<p><img src="https://images2.imgbox.com/5b/bb/QKzl2n2L_o.png" alt="在这里插入图片描述"><br> 我们具体看一下advised包含了哪些数据。如下图所示其包含了DefaultAopProxyFactory、targetSource、DefaultAdvisorChainFactory、methodCache以及advisors等。</p> 
<p>其中我们需要注意methodCache与advisors。前者维护了方法与增强器/拦截器链，后者维护了目标方法所应用的顾问/增强器。</p> 
<blockquote> 
 <p>此时（还没有进入DynamicAdvisedInterceptor#intercept执行我们目标方法的增强），methodCache只有一个toString。这个我们无需理会，只需要关注接下来的变动。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/18/cb/lPmv82ub_o.png" alt="在这里插入图片描述"><br> 如下所示，这些advisors除了第一个，其他5个其实就对应了我们切面定义的五个增强通知方法。</p> 
<pre><code class="prism language-java"><span class="token number">0</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">ExposeInvocationInterceptor</span>$<span class="token number">1</span><span class="token annotation punctuation">@9902</span><span class="token punctuation">}</span> <span class="token string">"org.springframework.aop.interceptor.ExposeInvocationInterceptor.ADVISOR"</span>
<span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">InstantiationModelAwarePointcutAdvisorImpl</span><span class="token annotation punctuation">@9903</span><span class="token punctuation">}</span> <span class="token string">"InstantiationModelAwarePointcutAdvisor: expression [logPointCut()]; advice method [public void com.recommend.config.LogAspect.AfterThrowing(org.aspectj.lang.JoinPoint,java.lang.Exception)]; perClauseKind=SINGLETON"</span>
<span class="token number">2</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">InstantiationModelAwarePointcutAdvisorImpl</span><span class="token annotation punctuation">@9904</span><span class="token punctuation">}</span> <span class="token string">"InstantiationModelAwarePointcutAdvisor: expression [logPointCut()]; advice method [public void com.recommend.config.LogAspect.AfterReturning(org.aspectj.lang.JoinPoint,java.lang.Object)]; perClauseKind=SINGLETON"</span>
<span class="token number">3</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">InstantiationModelAwarePointcutAdvisorImpl</span><span class="token annotation punctuation">@9905</span><span class="token punctuation">}</span> <span class="token string">"InstantiationModelAwarePointcutAdvisor: expression [logPointCut()]; advice method [public void com.recommend.config.LogAspect.afterMethod(org.aspectj.lang.JoinPoint)]; perClauseKind=SINGLETON"</span>
<span class="token number">4</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">InstantiationModelAwarePointcutAdvisorImpl</span><span class="token annotation punctuation">@9906</span><span class="token punctuation">}</span> <span class="token string">"InstantiationModelAwarePointcutAdvisor: expression [logPointCut()]; advice method [public java.lang.Object com.recommend.config.LogAspect.around(org.aspectj.lang.ProceedingJoinPoint) throws java.lang.Throwable]; perClauseKind=SINGLETON"</span>
<span class="token number">5</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">InstantiationModelAwarePointcutAdvisorImpl</span><span class="token annotation punctuation">@9907</span><span class="token punctuation">}</span> <span class="token string">"InstantiationModelAwarePointcutAdvisor: expression [execution(* com.recommend.controller.*.*(..))]; advice method [public void com.recommend.config.LogAspect.beforeMethod(org.aspectj.lang.JoinPoint)]; perClauseKind=SINGLETON"</span>
</code></pre> 
<h2><a id="2DynamicAdvisedInterceptor_104"></a>【2】DynamicAdvisedInterceptor</h2> 
<p>AOP的执行流程首先从<code>DynamicAdvisedInterceptor</code>的intercept方法开始。该类是CglibAopProxy的内部类，实现了MethodInterceptor接口，维护了一个AdvisedSupport advised常量。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Object</span> oldProxy <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">boolean</span> setProxyContext <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token class-name">Object</span> target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token class-name">TargetSource</span> targetSource <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
	
	<span class="token comment">// 如果exposeProxy设置为true，则将proxy暴露给AopContext</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span>exposeProxy<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// Make invocation available if necessary.</span>
			oldProxy <span class="token operator">=</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">setCurrentProxy</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
			setProxyContext <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...</span>
		<span class="token comment">// 获取目标对象，如我们的homeController</span>
		target <span class="token operator">=</span> targetSource<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass <span class="token operator">=</span> <span class="token punctuation">(</span>target <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 获取目标方法的拦截器链 很重要</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> chain <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getInterceptorsAndDynamicInterceptionAdvice</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Object</span> retVal<span class="token punctuation">;</span>
		
		<span class="token comment">// 检查是否可以直接反射调用目标方法，注意哦，这里判断了public 修饰符</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>chain<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span>
			<span class="token comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span>
			<span class="token comment">// it does nothing but a reflective operation on the target, and no hot</span>
			<span class="token comment">// swapping or fancy proxying.</span>
			<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> argsToUse <span class="token operator">=</span> <span class="token class-name">AopProxyUtils</span><span class="token punctuation">.</span><span class="token function">adaptArgumentsIfNecessary</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 直接调用目标方法</span>
			retVal <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> argsToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// We need to create a method invocation...</span>
			<span class="token comment">// 如果我们有增强Advice，那么就会从这里开始执行</span>
			retVal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CglibMethodInvocation</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> target<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> targetClass<span class="token punctuation">,</span> chain<span class="token punctuation">,</span> methodProxy<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		retVal <span class="token operator">=</span> <span class="token function">processReturnType</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> target<span class="token punctuation">,</span> method<span class="token punctuation">,</span> retVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> retVal<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>targetSource<span class="token punctuation">.</span><span class="token function">isStatic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			targetSource<span class="token punctuation">.</span><span class="token function">releaseTarget</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>setProxyContext<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// Restore old proxy.</span>
			<span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">setCurrentProxy</span><span class="token punctuation">(</span>oldProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里我们需要关注两点：拦截器的获取与执行。即如下两个入口。</p> 
<ul><li><code>List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</code></li><li><code>retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</code></li></ul> 
<h3><a id="__163"></a>① 获取拦截器链</h3> 
<p>这里来到了<code>AdvisedSupport的getInterceptorsAndDynamicInterceptionAdvice</code>方法。方法很简洁，首先从缓存里面获取，如果有直接返回，否则调用advisorChainFactory获取然后放到methodCache缓存里面。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">getInterceptorsAndDynamicInterceptionAdvice</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 包装得到方法的缓存key</span>
	<span class="token class-name">MethodCacheKey</span> cacheKey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MethodCacheKey</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 从本地缓存Map&lt;MethodCacheKey, List&lt;Object&gt;&gt; methodCache里面获取</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> cached <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>methodCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>cached <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 进一步获取拦截器链</span>
		cached <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advisorChainFactory<span class="token punctuation">.</span><span class="token function">getInterceptorsAndDynamicInterceptionAdvice</span><span class="token punctuation">(</span>
				<span class="token keyword">this</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">// 放到缓存里面</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>methodCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> cached<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> cached<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里的<code>advisorChainFactory</code>是<code>DefaultAdvisorChainFactory</code>。该类是真正为目标方法创建拦截器链的方法。这里不做介绍更多详情参考博文<a href="https://blog.csdn.net/J080624/article/details/54598734">Spring AOP如何为目标方法创建拦截器链？</a>。</p> 
<p>获取到拦截器执行链后，我们advised的methodCache就发生了变化如下所示：</p> 
<p><img src="https://images2.imgbox.com/cd/ef/8k7Yt8wW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="__188"></a>② 拦截器链的执行</h3> 
<p>其实看到上图，我们心里已经有了推测。其会逐个调用链中的每个拦截器实现目标方法的增强。我们接下来从源码角度追踪流程的实现。</p> 
<pre><code class="prism language-java">retVal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CglibMethodInvocation</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> target<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> targetClass<span class="token punctuation">,</span> 
chain<span class="token punctuation">,</span> methodProxy<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ca/cb/GPPWxnKx_o.png" alt="在这里插入图片描述"></p> 
<p>这里创建了<code>CglibMethodInvocation</code>实例对象然后调用了proceed方法。<code>CglibMethodInvocation</code>是CglibAopProxy的静态内部类继承自<code>ReflectiveMethodInvocation</code>。</p> 
<p>如下代码所示其有参构造方法调用了父类<code>ReflectiveMethodInvocation</code> 的有参构造方法。其proceed方法直接调用了父类的proceed方法。</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CglibMethodInvocation</span> <span class="token keyword">extends</span> <span class="token class-name">ReflectiveMethodInvocation</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Nullable</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MethodProxy</span> methodProxy<span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token class-name">CglibMethodInvocation</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> target<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span>
			<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arguments<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass<span class="token punctuation">,</span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> interceptorsAndDynamicMethodMatchers<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> methodProxy<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

		<span class="token keyword">super</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> target<span class="token punctuation">,</span> method<span class="token punctuation">,</span> arguments<span class="token punctuation">,</span> targetClass<span class="token punctuation">,</span> interceptorsAndDynamicMethodMatchers<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Only use method proxy for public methods not derived from java.lang.Object</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>methodProxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
				method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">AopUtils</span><span class="token punctuation">.</span><span class="token function">isEqualsMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
				<span class="token operator">!</span><span class="token class-name">AopUtils</span><span class="token punctuation">.</span><span class="token function">isHashCodeMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">AopUtils</span><span class="token punctuation">.</span><span class="token function">isToStringMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token operator">?</span>
				methodProxy <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token annotation punctuation">@Nullable</span>
	<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//...</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>我们看下其父类ReflectiveMethodInvocation的proceed方法。</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// We start with an index of -1 and increment early.</span>
	<span class="token comment">// 判断是否需要反射调用目标方法，即拦截器链执行完</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentInterceptorIndex <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>interceptorsAndDynamicMethodMatchers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">invokeJoinpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token comment">// 获取下一个拦截器</span>
	<span class="token class-name">Object</span> interceptorOrInterceptionAdvice <span class="token operator">=</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>interceptorsAndDynamicMethodMatchers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">++</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentInterceptorIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
			
	<span class="token keyword">if</span> <span class="token punctuation">(</span>interceptorOrInterceptionAdvice <span class="token keyword">instanceof</span> <span class="token class-name">InterceptorAndDynamicMethodMatcher</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Evaluate dynamic method matcher here: static part will already have</span>
		<span class="token comment">// been evaluated and found to match.</span>
		<span class="token class-name">InterceptorAndDynamicMethodMatcher</span> dm <span class="token operator">=</span>
				<span class="token punctuation">(</span><span class="token class-name">InterceptorAndDynamicMethodMatcher</span><span class="token punctuation">)</span> interceptorOrInterceptionAdvice<span class="token punctuation">;</span>
		<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>targetClass <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>targetClass <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>dm<span class="token punctuation">.</span>methodMatcher<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">,</span> targetClass<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> dm<span class="token punctuation">.</span>interceptor<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// Dynamic matching failed.</span>
			<span class="token comment">// Skip this interceptor and invoke the next in the chain.</span>
			<span class="token keyword">return</span> <span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// It's an interceptor, so we just invoke it: The pointcut will have</span>
		<span class="token comment">// been evaluated statically before this object was constructed.</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MethodInterceptor</span><span class="token punctuation">)</span> interceptorOrInterceptionAdvice<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里首先判断拦截器是否执行完，如果执行完则反射调用目标方法。否则获取下一个拦截器进行判断、调用。</p> 
<p><strong>这里第一个拦截器是ExposeInvocationInterceptor。</strong></p> 
<p>我们看下其invoke方法。该方法首先将当前的MethodInvocation 对象(也就是CglibMethodInvocation实例)放到<code>ThreadLocal&lt;MethodInvocation&gt; invocation</code>中，然后调用MethodInvocation 对象的proceed方法，最后又恢复了invocation。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">MethodInvocation</span> oldInvocation <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	invocation<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>mi<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> mi<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
		invocation<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>oldInvocation<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么CglibMethodInvocation实例的proceed方法只是直接调用了父类ReflectiveMethodInvocation的proceed方法，将会获取到下一个拦截器。</p> 
<hr> 
<p><strong>第二个拦截器是AspectJAfterThrowingAdvice</strong>。</p> 
<p>如下所示其调用mi.proceed()，那么又会来到ReflectiveMethodInvocation的proceed方法，将会获取到下一个拦截器。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> mi<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 假设抛出了异常，那么这里会尝试反射调用我们切面的增强方法</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldInvokeOnThrowing</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">invokeAdviceMethod</span><span class="token punctuation">(</span><span class="token function">getJoinPointMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>第三个拦截器是AfterReturningAdviceInterceptor。</strong></p> 
<p>其方法如下所示，首先调用<code>mi.proceed()</code>，然后调用advice的afterReturning方法。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// CglibMethodInvocation.proceed--ReflectiveMethodInvocation#proceed</span>
	<span class="token class-name">Object</span> retVal <span class="token operator">=</span> mi<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>advice<span class="token punctuation">.</span><span class="token function">afterReturning</span><span class="token punctuation">(</span>retVal<span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> retVal<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其中mi.proceed方法又会触发<code>CglibMethodInvocation.proceed--ReflectiveMethodInvocation#proceed</code>流程得到下一个拦截器。</p> 
<p>而AspectJAfterReturningAdvice的afterReturning如下所示。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterReturning</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> returnValue<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldInvokeOnReturnValueOf</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> returnValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 这里会触发我们切面的增强方法</span>
		<span class="token function">invokeAdviceMethod</span><span class="token punctuation">(</span><span class="token function">getJoinPointMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> returnValue<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>第四个拦截器是AspectJAfterAdvice。</strong></p> 
<p>首先是<code>mi.proceed();</code>流程，然后触发了invokeAdviceMethod方法。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> mi<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 尝试反射调用我们切面的增强方法</span>
		<span class="token function">invokeAdviceMethod</span><span class="token punctuation">(</span><span class="token function">getJoinPointMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>第五个拦截器是AspectJAroundAdvice方法。</strong></p> 
<p>其invoke方法如下所示尝试拿到<code>ProceedingJoinPoint</code> 和<code>JoinPointMatch</code> 后直接反射调用我们切面的增强方法。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>mi <span class="token keyword">instanceof</span> <span class="token class-name">ProxyMethodInvocation</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"MethodInvocation is not a Spring ProxyMethodInvocation: "</span> <span class="token operator">+</span> mi<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">ProxyMethodInvocation</span> pmi <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ProxyMethodInvocation</span><span class="token punctuation">)</span> mi<span class="token punctuation">;</span>
	<span class="token class-name">ProceedingJoinPoint</span> pjp <span class="token operator">=</span> <span class="token function">lazyGetProceedingJoinPoint</span><span class="token punctuation">(</span>pmi<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">JoinPointMatch</span> jpm <span class="token operator">=</span> <span class="token function">getJoinPointMatch</span><span class="token punctuation">(</span>pmi<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 这个与上面的invokeAdviceMethod(getJoinPointMatch(), null, null);不一样了哦</span>
	<span class="token keyword">return</span> <span class="token function">invokeAdviceMethod</span><span class="token punctuation">(</span>pjp<span class="token punctuation">,</span> jpm<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>从这里也可以看出<code>around方法中，我们写得前置逻辑是要优先于before的增强</code>的。而<code>invokeAdviceMethod(pjp, jpm, null, null)</code>方法首先会进行参数的绑定然后走到了<code>invokeAdviceMethodWithGivenArgs(Object[] args)</code>方法中进行增强方法的反射调用。</p> 
<p><img src="https://images2.imgbox.com/60/59/ftTsnq7n_o.png" alt="在这里插入图片描述"><br> 在我们增强around方法中会触发<code>point.proceed();</code>的调用。其将会触发methodInvocation到ReflectiveMethodInvocation的proceed流程。然后获取到下一个拦截器。</p> 
<pre><code class="prism language-java"><span class="token comment">// MethodInvocationProceedingJoinPoint#proceed()</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>methodInvocation<span class="token punctuation">.</span><span class="token function">invocableClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>第六个拦截器是MethodBeforeAdviceInterceptor。</strong></p> 
<p>其invoke方法如下所示其首先反射调用我们的增强方法，然后触发<code>mi.proceed()</code>尝试获取下一个拦截器，但是目前已经是最后一个拦截器将会触发invokeJoinpoint方法的调用。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">// 这里会触发我们的before增强方法</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>advice<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>mi<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//这里会触发ReflectiveMethodInvocation的proceed方法</span>
	<span class="token keyword">return</span> mi<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>CglibAopProxy的invokeJoinpoint</strong></p> 
<p>如果执行完拦截器，那么ReflectiveMethodInvocation的proceed方法中将会触发CglibAopProxy的invokeJoinpoint方法。</p> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">invokeJoinpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>methodProxy <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>methodProxy<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">invokeJoinpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里的methodProxy如下所示，其将会触发我们真正目标方法（本文这里是HomeController的index方法）的执行。<br> <img src="https://images2.imgbox.com/73/05/cH46IrID_o.png" alt="在这里插入图片描述"><br> 方法执行栈如下所示，从invoke到了index。</p> 
<p><img src="https://images2.imgbox.com/ea/eb/ZKyFPLNq_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>around增强方法的后半部分</strong></p> 
<p>即我们around增强方法中<code> Object result = point.proceed();</code>之后代码的执行。之后就结束around增强。</p> 
<p><img src="https://images2.imgbox.com/ac/e2/XrF8IBSf_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>AspectJAfterAdvice的finally</strong></p> 
<p>这里会触发我们after增强代码。</p> 
<p><img src="https://images2.imgbox.com/cb/9e/k9HyHZHA_o.png" alt="AspectJAfterAdvice"></p> 
<hr> 
<p><strong>AfterReturningAdviceInterceptor后半部分</strong></p> 
<p>如下图所示，这里将会触发<code>AspectJAfterReturningAdvice</code>的 <code>afterReturning</code>方法，即，将会触发我们自己的<code>@AfterReturning</code>增强。<br> <img src="https://images2.imgbox.com/fd/73/rr5IGGjk_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>AspectJAfterThrowingAdvice的catch</strong></p> 
<p>如果上面过程中抛出了异常，那么接下里会触发AspectJAfterThrowingAdvice的catch逻辑。即，将会触发我们<code> @AfterThrowing</code>增强。</p> 
<p>如果没有抛出异常，继续返回。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> mi<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldInvokeOnThrowing</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">invokeAdviceMethod</span><span class="token punctuation">(</span><span class="token function">getJoinPointMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>ExposeInvocationInterceptor的finally</strong></p> 
<p>最终返回到了ExposeInvocationInterceptor的finally方法块。其恢复invocation状态，然后return。</p> 
<p><img src="https://images2.imgbox.com/54/b1/1BGwJ8qV_o.png" alt="在这里插入图片描述"></p> 
<p>接下来就是<code>CglibAopProxy.DynamicAdvisedInterceptor</code>的intercept方法后面部分了，其将会尝试处理返回结果类型，然后return retVal。</p> 
<p><img src="https://images2.imgbox.com/83/cd/Uwn53GUh_o.png" alt="在这里插入图片描述"></p> 
<p>再之后，就交给了springMVC的流程。</p> 
<p><img src="https://images2.imgbox.com/54/14/DH7k1aXE_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3_477"></a>【3】增加了引入通知</h2> 
<p>如下所示，我们增加了引入通知。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogAspect</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@DeclareParents</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.recommend.controller.HomeController"</span><span class="token punctuation">,</span>defaultImpl<span class="token operator">=</span><span class="token class-name">MyDeclareImpl</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">MyDeclareService</span> myDeclareService<span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>    
</code></pre> 
<p>此时我们的执行器链如下所示：</p> 
<p><img src="https://images2.imgbox.com/9d/3f/T31VxWXh_o.png" alt="在这里插入图片描述"></p> 
<p><strong>DelegatePerTargetObjectIntroductionInterceptor如下所示：</strong></p> 
<p><img src="https://images2.imgbox.com/7c/ee/rNmMrX4I_o.png" alt="在这里插入图片描述"></p> 
<p>这里我们看一下<code>DelegatePerTargetObjectIntroductionInterceptor</code>的invoke方法。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 校验目标方法是否为引入通知感兴趣的接口类型的方法</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isMethodOnIntroducedInterface</span><span class="token punctuation">(</span>mi<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 获取增强服务类</span>
		<span class="token class-name">Object</span> delegate <span class="token operator">=</span> <span class="token function">getIntroductionDelegateFor</span><span class="token punctuation">(</span>mi<span class="token punctuation">.</span><span class="token function">getThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Using the following method rather than direct reflection,</span>
		<span class="token comment">// we get correct handling of InvocationTargetException</span>
		<span class="token comment">// if the introduced method throws an exception.</span>
		<span class="token comment">// 调用增强服务类的增强方法</span>
		<span class="token class-name">Object</span> retVal <span class="token operator">=</span> <span class="token class-name">AopUtils</span><span class="token punctuation">.</span><span class="token function">invokeJoinpointUsingReflection</span><span class="token punctuation">(</span>delegate<span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Massage return value if possible: if the delegate returned itself,</span>
		<span class="token comment">// we really want to return the proxy.</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>retVal <span class="token operator">==</span> delegate <span class="token operator">&amp;&amp;</span> mi <span class="token keyword">instanceof</span> <span class="token class-name">ProxyMethodInvocation</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			retVal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ProxyMethodInvocation</span><span class="token punctuation">)</span> mi<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 返回结果</span>
		<span class="token keyword">return</span> retVal<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token comment">// 只是 mi.proceed();</span>
	<span class="token keyword">return</span> <span class="token function">doProceed</span><span class="token punctuation">(</span>mi<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>也就是说首先判断一下目标方法所在类是否为引入通知感兴趣的服务类，如果是则反射调用增强服务类的增强方法，如果不是直接交给<code>mi.proceed();</code>。</p> 
<p>从这里也可以看出引入通知是在不改变目标类的基础上为其增加方法业务逻辑，这种手段可以实现<code>多继承</code>的思想。</p> 
<p>这种手段可以应用在动态为某批服务增加方法的场景，区别于某批服务实现了同一接口，这种更为灵活。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3d79ff89a674fc60d1c2a47521f11b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">aardio内嵌资源的代码写法-以内嵌DLL为例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e80cd528912938b5b45d22311f302096/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">零售连锁门店收银系统源码管理商品分类的功能逻辑分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>