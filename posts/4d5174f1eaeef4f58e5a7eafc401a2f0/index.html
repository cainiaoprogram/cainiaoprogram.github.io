<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VC中对按钮控件的修改[转载] - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VC中对按钮控件的修改[转载]" />
<meta property="og:description" content="VC中对按钮控件的修改 在VC6.0环境下，通过向导设置建立基于MFC AppWizard[exe] 名称为MyClassBTNdemo的project （图1），基于Dialog（图2）。项目建立好了以后，左侧的导航栏点击FILEVIEW,展开的列表文件（图3）,通过文件File－&gt;new添加ClassBTN.cpp和ClassBTN.h文件。我们的主要工作都是在这两个文件夹中设置的。
1、在 ClassBTN.h文件中添加代码：
#if !defined(AFX_CLASSBTN_H__44CD5B2A_756E_4939_9261_E0034E0F2DEF__INCLUDED_)
#define AFX_CLASSBTN_H__44CD5B2A_756E_4939_9261_E0034E0F2DEF__INCLUDED_
#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// ClassBTN.h : header file
//
/
// CClassBTN window
class CClassBTN : public CButton
{
// Construction
public:
CClassBTN();
// Attributes
protected:
//按钮的外边框
CPen m_BoundryPen;
//鼠标指针置于按钮之上时按钮的内边框
CPen m_InsideBoundryPenLeft;
CPen m_InsideBoundryPenRight;
CPen m_InsideBoundryPenTop;
CPen m_InsideBoundryPenBottom;
//按钮获得焦点时按钮的内边框
CPen m_InsideBoundryPenLeftSel;
CPen m_InsideBoundryPenRightSel;
CPen m_InsideBoundryPenTopSel;
CPen m_InsideBoundryPenBottomSel;
//按钮的底色，包括有效和无效两种状态
CBrush m_FillActive;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4d5174f1eaeef4f58e5a7eafc401a2f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2009-12-28T20:10:00+08:00" />
<meta property="article:modified_time" content="2009-12-28T20:10:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VC中对按钮控件的修改[转载]</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>VC中对按钮控件的修改 </p> 
<p>在VC6.0环境下，通过向导设置建立基于MFC AppWizard[exe]  名称为MyClassBTNdemo的project （图1），基于Dialog（图2）。项目建立好了以后，左侧的导航栏点击FILEVIEW,展开的列表文件（图3）,通过文件File－&gt;new添加ClassBTN.cpp和ClassBTN.h文件。我们的主要工作都是在这两个文件夹中设置的。</p> 
<p>1、在 ClassBTN.h文件中添加代码：</p> 
<p> </p> 
<p>#if !defined(AFX_CLASSBTN_H__44CD5B2A_756E_4939_9261_E0034E0F2DEF__INCLUDED_)</p> 
<p>#define AFX_CLASSBTN_H__44CD5B2A_756E_4939_9261_E0034E0F2DEF__INCLUDED_</p> 
<p> </p> 
<p>#if _MSC_VER &gt; 1000</p> 
<p>#pragma once</p> 
<p>#endif // _MSC_VER &gt; 1000</p> 
<p>// ClassBTN.h : header file</p> 
<p>//</p> 
<p> </p> 
<p>/</p> 
<p>// CClassBTN window</p> 
<p> </p> 
<p>class CClassBTN : public CButton</p> 
<p>{<!-- --></p> 
<p>// Construction</p> 
<p>public:</p> 
<p>       CClassBTN();</p> 
<p> </p> 
<p>       // Attributes</p> 
<p>protected:</p> 
<p>       //按钮的外边框</p> 
<p>       CPen m_BoundryPen;</p> 
<p>       </p> 
<p>       //鼠标指针置于按钮之上时按钮的内边框</p> 
<p>       CPen m_InsideBoundryPenLeft;</p> 
<p>       CPen m_InsideBoundryPenRight;</p> 
<p>       CPen m_InsideBoundryPenTop;</p> 
<p>       CPen m_InsideBoundryPenBottom;</p> 
<p>       </p> 
<p>       //按钮获得焦点时按钮的内边框</p> 
<p>       CPen m_InsideBoundryPenLeftSel;</p> 
<p>       CPen m_InsideBoundryPenRightSel;</p> 
<p>       CPen m_InsideBoundryPenTopSel;</p> 
<p>       CPen m_InsideBoundryPenBottomSel;</p> 
<p>       </p> 
<p>       //按钮的底色，包括有效和无效两种状态</p> 
<p>       CBrush m_FillActive;</p> 
<p>       CBrush m_FillInactive;</p> 
<p>       </p> 
<p>       //按钮的状态</p> 
<p>       BOOL m_bOver;    //鼠标位于按钮之上时该值为true，反之为flase</p> 
<p>       BOOL m_bTracking;     //在鼠标按下没有释放时该值为true</p> 
<p>       BOOL m_bSelected;      //按钮被按下是该值为true</p> 
<p>       BOOL m_bFocus;  //按钮为当前焦点所在时该值为true</p> 
<p> </p> 
<p>// Operations</p> 
<p>public:</p> 
<p> </p> 
<p>// Overrides</p> 
<p>       // ClassWizard generated virtual function overrides</p> 
<p>       //{<!-- -->{AFX_VIRTUAL(CClassBTN)</p> 
<p>       protected:</p> 
<p>       virtual void PreSubclassWindow();</p> 
<p>       //}}AFX_VIRTUAL</p> 
<p> </p> 
<p>// Implementation</p> 
<p>public:</p> 
<p>       virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);</p> 
<p>       virtual void DoGradientFill(CDC *pDC, CRect* rect);</p> 
<p>       virtual void DrawInsideBorder(CDC *pDC, CRect* rect);</p> 
<p>       virtual ~CClassBTN();</p> 
<p> </p> 
<p>       // Generated message map functions</p> 
<p>protected:</p> 
<p>       //{<!-- -->{AFX_MSG(CClassBTN)</p> 
<p>       afx_msg void OnMouseMove(UINT nFlags, CPoint point);</p> 
<p>       afx_msg LRESULT OnMouseLeave(WPARAM wParam, LPARAM lParam);</p> 
<p>       afx_msg LRESULT OnMouseHover(WPARAM wParam, LPARAM lParam);</p> 
<p>       </p> 
<p>       //}}AFX_MSG</p> 
<p> </p> 
<p>       DECLARE_MESSAGE_MAP()</p> 
<p>};</p> 
<p> </p> 
<p>/</p> 
<p> </p> 
<p>//{<!-- -->{AFX_INSERT_LOCATION}}</p> 
<p>// Microsoft Visual C++ will insert additional declarations immediately before the previous line.</p> 
<p> </p> 
<p>#endif // !defined(AFX_CLASSBTN_H__44CD5B2A_756E_4939_9261_E0034E0F2DEF__INCLUDED_)</p> 
<p>///</p> 
<p>2、在文件ClassBTN.cpp中添加下列代码</p> 
<p>// ClassBTN.cpp : implementation file</p> 
<p>//</p> 
<p> </p> 
<p>#include "stdafx.h"</p> 
<p>#include "ClassBTN.h"</p> 
<p> </p> 
<p>#ifdef _DEBUG</p> 
<p>#define new DEBUG_NEW</p> 
<p>#undef THIS_FILE</p> 
<p>static char THIS_FILE[] = __FILE__;</p> 
<p>#endif</p> 
<p> </p> 
<p>/</p> 
<p>// CClassBTN</p> 
<p> </p> 
<p>CClassBTN::CClassBTN()</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>       m_BoundryPen.CreatePen(PS_INSIDEFRAME | PS_SOLID, 1, RGB(0, 0, 0));</p> 
<p>       m_InsideBoundryPenLeft.CreatePen(PS_INSIDEFRAME | PS_SOLID, 3, RGB(250, 196, 88)); </p> 
<p>       m_InsideBoundryPenRight.CreatePen(PS_INSIDEFRAME | PS_SOLID, 3, RGB(251, 202, 106));</p> 
<p>       m_InsideBoundryPenTop.CreatePen(PS_INSIDEFRAME | PS_SOLID, 2, RGB(252, 210, 121));</p> 
<p>       m_InsideBoundryPenBottom.CreatePen(PS_INSIDEFRAME | PS_SOLID, 2, RGB(229, 151, 0));</p> 
<p>       </p> 
<p>       m_FillActive.CreateSolidBrush(RGB(223, 222, 236));</p> 
<p>       m_FillInactive.CreateSolidBrush(RGB(222, 223, 236));</p> 
<p>       </p> 
<p>       m_InsideBoundryPenLeftSel.CreatePen(PS_INSIDEFRAME | PS_SOLID, 3, RGB(153, 198, 252)); </p> 
<p>       m_InsideBoundryPenTopSel.CreatePen(PS_INSIDEFRAME | PS_SOLID, 2, RGB(162, 201, 255));</p> 
<p>       m_InsideBoundryPenRightSel.CreatePen(PS_INSIDEFRAME | PS_SOLID, 3, RGB(162, 189, 252));</p> 
<p>       m_InsideBoundryPenBottomSel.CreatePen(PS_INSIDEFRAME | PS_SOLID, 2, RGB(162, 201, 255));</p> 
<p>       </p> 
<p>       m_bOver = m_bSelected = m_bTracking = m_bFocus = FALSE;</p> 
<p>       </p> 
<p>}</p> 
<p>CClassBTN::~CClassBTN()</p> 
<p>{<!-- --></p> 
<p>       m_BoundryPen.DeleteObject();</p> 
<p>       m_InsideBoundryPenLeft.DeleteObject();</p> 
<p>       m_InsideBoundryPenRight.DeleteObject();</p> 
<p>       m_InsideBoundryPenTop.DeleteObject();</p> 
<p>       m_InsideBoundryPenBottom.DeleteObject();</p> 
<p>       </p> 
<p>       m_FillActive.DeleteObject();</p> 
<p>       m_FillInactive.DeleteObject();</p> 
<p>       </p> 
<p>       m_InsideBoundryPenLeftSel.DeleteObject();</p> 
<p>       m_InsideBoundryPenTopSel.DeleteObject();</p> 
<p>       m_InsideBoundryPenRightSel.DeleteObject();</p> 
<p>       m_InsideBoundryPenBottomSel.DeleteObject();</p> 
<p>       </p> 
<p>}</p> 
<p> </p> 
<p> </p> 
<p>BEGIN_MESSAGE_MAP(CClassBTN, CButton)</p> 
<p>       //{<!-- -->{AFX_MSG_MAP(CClassBTN)</p> 
<p>       ON_WM_MOUSEMOVE()</p> 
<p>       ON_MESSAGE(WM_MOUSELEAVE, OnMouseLeave)</p> 
<p>       ON_MESSAGE(WM_MOUSEHOVER, OnMouseHover)</p> 
<p>       //}}AFX_MSG_MAP</p> 
<p>END_MESSAGE_MAP()</p> 
<p> </p> 
<p>/</p> 
<p>// CClassBTN message handlers</p> 
<p> </p> 
<p>//添加Owner Draw属性</p> 
<p>void CClassBTN::PreSubclassWindow() </p> 
<p>{<!-- --></p> 
<p>       // TODO: Add your specialized code here and/or call the base class</p> 
<p>       </p> 
<p>       CButton::PreSubclassWindow();</p> 
<p>       ModifyStyle(0, BS_OWNERDRAW);</p> 
<p>}</p> 
<p> </p> 
<p>void CClassBTN::OnMouseMove(UINT nFlags, CPoint point) </p> 
<p>{<!-- --></p> 
<p>       // TODO: Add your message handler code here and/or call default</p> 
<p>       if (!m_bTracking)</p> 
<p>       {<!-- --></p> 
<p>              TRACKMOUSEEVENT tme;</p> 
<p>              tme.cbSize = sizeof(tme);</p> 
<p>              tme.hwndTrack = m_hWnd;</p> 
<p>              tme.dwFlags = TME_LEAVE | TME_HOVER;</p> 
<p>              tme.dwHoverTime = 1;</p> 
<p>              m_bTracking = _TrackMouseEvent(&amp;tme);</p> 
<p>       }</p> 
<p>       </p> 
<p>       CButton::OnMouseMove(nFlags, point);</p> 
<p>}</p> 
<p> </p> 
<p> </p> 
<p>LRESULT CClassBTN::OnMouseLeave(WPARAM wParam, LPARAM lParam)</p> 
<p>{<!-- --></p> 
<p>       m_bOver = FALSE;</p> 
<p>       m_bTracking = FALSE;</p> 
<p>       InvalidateRect(NULL, FALSE);</p> 
<p>       return 0;</p> 
<p>}</p> 
<p> </p> 
<p>LRESULT CClassBTN::OnMouseHover(WPARAM wParam, LPARAM lParam)</p> 
<p>{<!-- --></p> 
<p>       m_bOver = TRUE;</p> 
<p>       InvalidateRect(NULL);</p> 
<p>       return 0;</p> 
<p>}</p> 
<p> </p> 
<p> </p> 
<p>void CClassBTN::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)</p> 
<p>{<!-- --></p> 
<p>       //从lpDrawItemStruct获取控件的相关信息</p> 
<p>       CRect rect =  lpDrawItemStruct-&gt;rcItem;</p> 
<p>       CDC *pDC=CDC::FromHandle(lpDrawItemStruct-&gt;hDC);</p> 
<p>       int nSaveDC=pDC-&gt;SaveDC();</p> 
<p>       UINT state = lpDrawItemStruct-&gt;itemState;</p> 
<p>       POINT pt ;</p> 
<p>       TCHAR strText[MAX_PATH + 1];</p> 
<p>       ::GetWindowText(m_hWnd, strText, MAX_PATH);</p> 
<p>       </p> 
<p>       //画按钮的外边框，它是一个半径为5的圆角矩形</p> 
<p>       pt.x = 5;</p> 
<p>       pt.y = 5;</p> 
<p>       CPen* hOldPen = pDC-&gt;SelectObject(&amp;m_BoundryPen);</p> 
<p>       pDC-&gt;RoundRect(&amp;rect, pt);</p> 
<p>       </p> 
<p>       //获取按钮的状态</p> 
<p>       if (state &amp; ODS_FOCUS)</p> 
<p>       {<!-- --></p> 
<p>              m_bFocus = TRUE;</p> 
<p>              m_bSelected = TRUE;</p> 
<p>       }</p> 
<p>       else</p> 
<p>       {<!-- --></p> 
<p>              m_bFocus = FALSE;</p> 
<p>              m_bSelected = FALSE;</p> 
<p>       }</p> 
<p>       </p> 
<p>       </p> 
<p>       if (state &amp; ODS_SELECTED || state &amp; ODS_DEFAULT)</p> 
<p>       {<!-- --></p> 
<p>              m_bFocus = TRUE;</p> 
<p>       }</p> 
<p> </p> 
<p>       </p> 
<p>       pDC-&gt;SelectObject(hOldPen);</p> 
<p>       </p> 
<p>       rect.DeflateRect(CSize(GetSystemMetrics(SM_CXEDGE), GetSystemMetrics(SM_CYEDGE)));</p> 
<p>       </p> 
<p>       //根据按钮的状态填充按钮的底色</p> 
<p>       CBrush* pOldBrush;</p> 
<p>       if (m_bOver)</p> 
<p>       {<!-- --></p> 
<p>              pOldBrush = pDC-&gt;SelectObject(&amp;m_FillActive);</p> 
<p>              DoGradientFill(pDC, &amp;rect);</p> 
<p>       }</p> 
<p>       else</p> 
<p>       {<!-- --></p> 
<p>              pOldBrush = pDC-&gt;SelectObject(&amp;m_FillInactive);</p> 
<p>              DoGradientFill(pDC, &amp;rect);</p> 
<p>       }</p> 
<p>       </p> 
<p>       //根据按钮的状态绘制内边框</p> 
<p>       if (m_bOver || m_bSelected)</p> 
<p>              DrawInsideBorder(pDC, &amp;rect);</p> 
<p>                            </p> 
<p>       pDC-&gt;SelectObject(pOldBrush);</p> 
<p>       </p> 
<p>       //显示按钮的文本</p> 
<p>       if (strText!=NULL)</p> 
<p>       {<!-- --></p> 
<p>              CFont* hFont = GetFont();</p> 
<p>              CFont* hOldFont = pDC-&gt;SelectObject(hFont);</p> 
<p>              CSize szExtent = pDC-&gt;GetTextExtent(strText, lstrlen(strText));</p> 
<p>              CPoint pt( rect.CenterPoint().x - szExtent.cx / 2, rect.CenterPoint().y - szExtent.cy / 2);</p> 
<p>              if (state &amp; ODS_SELECTED) </p> 
<p>                     pt.Offset(1, 1);</p> 
<p>              int nMode = pDC-&gt;SetBkMode(TRANSPARENT);</p> 
<p>              if (state &amp; ODS_DISABLED)</p> 
<p>                     pDC-&gt;DrawState(pt, szExtent, strText, DSS_DISABLED, TRUE, 0, (HBRUSH)NULL);</p> 
<p>              else</p> 
<p>                     pDC-&gt;DrawState(pt, szExtent, strText, DSS_NORMAL, TRUE, 0, (HBRUSH)NULL);</p> 
<p>              pDC-&gt;SelectObject(hOldFont);</p> 
<p>              pDC-&gt;SetBkMode(nMode);</p> 
<p>       }</p> 
<p>       </p> 
<p>       </p> 
<p>       pDC-&gt;RestoreDC(nSaveDC);</p> 
<p>}</p> 
<p> </p> 
<p>//绘制按钮的底色</p> 
<p>void CClassBTN::DoGradientFill(CDC *pDC, CRect* rect)</p> 
<p>{<!-- --></p> 
<p>       CBrush brBk[64];</p> 
<p>       int nWidth = rect-&gt;Width();   </p> 
<p>       int nHeight = rect-&gt;Height();</p> 
<p>       CRect rct;</p> 
<p>       </p> 
<p>       for (int i = 0; i &lt; 64; i ++)</p> 
<p>       {<!-- --></p> 
<p>              if (m_bOver)</p> 
<p>              {<!-- --></p> 
<p>                 if (m_bFocus)</p> 
<p>              brBk[i].CreateSolidBrush(RGB(255 - (i / 4), 255 - (i / 4), 255 - (i / 3)));</p> 
<p>                 else</p> 
<p>              brBk[i].CreateSolidBrush(RGB(255 - (i / 4), 255 - (i / 4), 255 - (i / 5)));</p> 
<p>              }</p> 
<p>              else</p> 
<p>              {<!-- --></p> 
<p>                     if (m_bFocus)</p> 
<p>              brBk[i].CreateSolidBrush(RGB(255 - (i / 3), 255 - (i / 3), 255 - (i / 4)));</p> 
<p>                     else</p> 
<p>              brBk[i].CreateSolidBrush(RGB(255 - (i / 3), 255 - (i / 3), 255 - (i / 5)));</p> 
<p>              }</p> 
<p>       } </p> 
<p>       for (i = rect-&gt;top; i &lt;= nHeight + 2; i ++) </p> 
<p>       {             </p> 
<p>              rct.SetRect(rect-&gt;left, i, nWidth + 2, i + 1);</p> 
<p>              pDC-&gt;FillRect(&amp;rct, &amp;brBk[((i * 63) / nHeight)]);</p> 
<p>       }</p> 
<p>              for (i = 0; i &lt; 64; i ++)</p> 
<p>              brBk[i].DeleteObject();</p> 
<p>}</p> 
<p>//绘制按钮的内边框</p> 
<p>void CClassBTN::DrawInsideBorder(CDC *pDC, CRect* rect)</p> 
<p>{<!-- --></p> 
<p>       CPen *pLeft, *pRight, *pTop, *pBottom;</p> 
<p>       </p> 
<p>       if (m_bSelected &amp;&amp; !m_bOver)</p> 
<p>       {<!-- --></p> 
<p>              pLeft = &amp; m_InsideBoundryPenLeftSel;</p> 
<p>              pRight = &amp;m_InsideBoundryPenRightSel;</p> 
<p>              pTop = &amp;m_InsideBoundryPenTopSel;</p> 
<p>              pBottom = &amp;m_InsideBoundryPenBottomSel;</p> 
<p>       }</p> 
<p>       else</p> 
<p>       {<!-- --></p> 
<p>              pLeft = &amp;m_InsideBoundryPenLeft;</p> 
<p>              pRight = &amp;m_InsideBoundryPenRight;</p> 
<p>              pTop = &amp;m_InsideBoundryPenTop;</p> 
<p>              pBottom = &amp;m_InsideBoundryPenBottom;</p> 
<p>       }</p> 
<p>       CPoint oldPoint = pDC-&gt;MoveTo(rect-&gt;left, rect-&gt;bottom - 1);</p> 
<p>       CPen* pOldPen = pDC-&gt;SelectObject(pLeft);</p> 
<p>       pDC-&gt;LineTo(rect-&gt;left, rect-&gt;top + 1);</p> 
<p>       pDC-&gt;SelectObject(pRight);</p> 
<p>       pDC-&gt;MoveTo(rect-&gt;right - 1, rect-&gt;bottom - 1);</p> 
<p>       pDC-&gt;LineTo(rect-&gt;right - 1, rect-&gt;top);</p> 
<p>       pDC-&gt;SelectObject(pTop);</p> 
<p>       pDC-&gt;MoveTo(rect-&gt;left - 1, rect-&gt;top);</p> 
<p>       pDC-&gt;LineTo(rect-&gt;right - 1, rect-&gt;top);</p> 
<p>       pDC-&gt;SelectObject(pBottom);</p> 
<p>       pDC-&gt;MoveTo(rect-&gt;left, rect-&gt;bottom);</p> 
<p>       pDC-&gt;LineTo(rect-&gt;right - 1, rect-&gt;bottom);</p> 
<p>       pDC-&gt;SelectObject(pOldPen);</p> 
<p>       pDC-&gt;MoveTo(oldPoint);</p> 
<p>       if (m_bSelected &amp;&amp; !m_bOver)</p> 
<p>              DrawFocusRect(pDC-&gt;m_hDC,rect);</p> 
<p>}</p> 
<p>3、/*添加头文件*/</p> 
<p>在MyClassBTNdemo.h中添加头文件</p> 
<p>＃include “ClassBTN.h”（如图4）</p> 
<p>4、在ResurseView 下添加相应的按钮控件如图（5）</p> 
<p> </p> 
<p>5、添加变量，按钮真正的达到效果</p> 
<p> 首先在MyClassBTNdemo中添加(图6)</p> 
<p> </p> 
<p>       CClassBTN     m_btnOK;              /*默认按钮 确定*/</p> 
<p>       CClassBTN     m_btnCancel;           /*默认按钮 取消*/</p> 
<p>       CClassBTN     m_btnmakesure;         /*新加按钮 Button1*/</p> 
<p>6、添加相应的对话框消息机制</p> 
<p>在MyClassBTNdemo.cpp中CAboutDlg::DoDataExchange(CDataExchange* pDX)成员函数内添加代码（图7）</p> 
<p>       DDX_Control(pDX, IDOK, m_btnOK);</p> 
<p>       DDX_Control(pDX, IDCANCEL, m_btnCancel);</p> 
<p>       DDX_Control(pDX, IDC_BUTTON4, m_btnmakesure);</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a74c9a2d2e7886cf1aed0c8b85c5c751/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一些常用路由协议默认的AD值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6fe876f480642acacfceceb4b34a23a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于loadrunner安装中的几个问题的解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>