<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式的艺术P1基础—2.4-2.11 面向对象设计原则 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式的艺术P1基础—2.4-2.11 面向对象设计原则" />
<meta property="og:description" content="设计模式的艺术P1基础—2.4-2.11 面向对象设计原则
2.4 面向对象设计原则概述
向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或者源代码的重用，另一方面要确保系统能够易于扩展和修改，具有较好的灵活性。
面向对象设计原则也是用于评价一个设计模式的使用效果的重要指标之一。
表2-2　7种常用的面向对象设计原则
2.5　单一职责原则
单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。
单一职责原则（Single Responsibility Principle，SRP）：一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中；如果多个职责总是同时发生改变，则可将它们封装在同一类中。
一个简单实例：
针对某CRM（Customer Relationship Management，客户关系管理）系统中客户信息图形统计模块提出了如图2-13所示的初始设计方案结构图。
CustomerDataChart类中的方法说明如下：getConnection（）方法用于连接数据库，findCustomers（）方法用于查询所有的客户信息，createChart（）方法用于创建图表，displayChart（）方法用于显示图表。
现使用单一职责原则对其进行重构，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。无论是修改数据库连接方式，还是修改图表显示方式，都需要修改该类，它拥有不止一个引起它变化的原因，违背了单一职责原则。
因此需要对该类进行拆分，使其满足单一职责原则。类CustomerDataChart可拆分为如下3个类。
（1）DBUtil：负责连接数据库，包含数据库连接方法getConnection（）。
（2）CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增／删／改／查等方法，如findCustomers（）。
（3）CustomerDataChart：负责图表的生成和显示，包含方法createChart（）和displayChart（）。
2.6 开闭原则
开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。
开闭原则（Open-Closed Principle，OCP）：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。
为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。
在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。
在对每个模式进行优缺点评价时，都会将开闭原则作为一个重要的评价依据，以判断基于该模式设计的系统是否具备良好的灵活性和可扩展性。
2.7　里氏代换原则
里氏代换原则（Liskov SubstitutionPrinciple，LSP）：所有引用基类（父类）的地方必须能透明地使用其子类的对象。
里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。
例如，我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；
里氏代换原则是实现开闭原则的重要方式之一。由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
2.8　依赖倒转原则
如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。
依赖倒转原则（Dependency Inversion Principle，DIP）：抽象不应该依赖于细节，细节应该依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
依赖倒转原则要求在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。
为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。
在实现依赖倒转原则时，需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependency Injection，DI）的方式注入其他对象中。
依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有3种：构造注入、设值注入（Setter注入）和接口注入。
一个简单实例来加深对开闭原则、里氏代换原则和依赖倒转原则的理解：
该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。
在客户数据操作类中将调用数据格式转换类的方法实现格式转换和数据库插入操作，初始设计方案结构如图：
发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时需要将TXTDataConvertor改为ExcelDataConvertor。此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则。
由于CustomerDAO针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。可以通过引入抽象数据转换类解决该问题。在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程。
更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图：
在大多数情况下，这3个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。
2.9　接口隔离原则
接口隔离原则（Interface Segregation Principle，ISP）：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
根据接口隔离原则，当一个接口太大时，需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。
1）当把“接口”理解成一个类型所提供的所有方法特征的集合时，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫作“角色隔离原则”。
2）如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。
实例：针对某CRM系统的客户数据显示模块设计了如图2-17所示的CustomerDataDisplay接口。其中，方法readData（）用于从文件中读取数据；方法transformToXML（）用于将数据转换成XML格式；方法createChart（）用于创建图表；方法displayChart（）用于显示图表；方法createReport（）用于创建文字报表；方法displayReport（）用于显示文字报表。
由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责。一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程度上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4ffbef1fd5aeb02d6600584f12b7f5a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T21:37:59+08:00" />
<meta property="article:modified_time" content="2024-01-08T21:37:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式的艺术P1基础—2.4-2.11 面向对象设计原则</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>设计模式的艺术P1基础—2.4-2.11 面向对象设计原则</p> 
<p>2.4 面向对象设计原则概述</p> 
<p>向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或者源代码的重用，另一方面要确保系统能够易于扩展和修改，具有较好的灵活性。</p> 
<p>面向对象设计原则也是用于评价一个设计模式的使用效果的重要指标之一。</p> 
<p></p> 
<p>表2-2　7种常用的面向对象设计原则</p> 
<p><img alt="" height="393" src="https://images2.imgbox.com/0d/19/pn5noqER_o.png" width="900"></p> 
<p></p> 
<p>2.5　单一职责原则</p> 
<p>单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p> 
<p>单一职责原则（Single Responsibility Principle，SRP）：一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p> 
<p>将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中；如果多个职责总是同时发生改变，则可将它们封装在同一类中。</p> 
<p>一个简单实例：</p> 
<p>针对某CRM（Customer Relationship Management，客户关系管理）系统中客户信息图形统计模块提出了如图2-13所示的初始设计方案结构图。</p> 
<p>CustomerDataChart类中的方法说明如下：getConnection（）方法用于连接数据库，findCustomers（）方法用于查询所有的客户信息，createChart（）方法用于创建图表，displayChart（）方法用于显示图表。</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/f7/e2/YImM3D1H_o.jpg" width="468"></p> 
<p></p> 
<p>现使用单一职责原则对其进行重构，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。无论是修改数据库连接方式，还是修改图表显示方式，都需要修改该类，它拥有不止一个引起它变化的原因，违背了单一职责原则。</p> 
<p>因此需要对该类进行拆分，使其满足单一职责原则。类CustomerDataChart可拆分为如下3个类。</p> 
<p>（1）DBUtil：负责连接数据库，包含数据库连接方法getConnection（）。</p> 
<p>（2）CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增／删／改／查等方法，如findCustomers（）。</p> 
<p>（3）CustomerDataChart：负责图表的生成和显示，包含方法createChart（）和displayChart（）。</p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/c4/69/1zLRY7Oj_o.png" width="1017"></p> 
<p>2.6 开闭原则</p> 
<p>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。</p> 
<p>开闭原则（Open-Closed Principle，OCP）：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p> 
<p>在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</p> 
<p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。</p> 
<p>在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p> 
<p>在对每个模式进行优缺点评价时，都会将开闭原则作为一个重要的评价依据，以判断基于该模式设计的系统是否具备良好的灵活性和可扩展性。</p> 
<p></p> 
<p>2.7　里氏代换原则</p> 
<p>里氏代换原则（Liskov SubstitutionPrinciple，LSP）：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p> 
<p>里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。</p> 
<p>例如，我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；</p> 
<p></p> 
<p>里氏代换原则是实现开闭原则的重要方式之一。由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p> 
<p></p> 
<p>2.8　依赖倒转原则</p> 
<p>如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</p> 
<p>依赖倒转原则（Dependency Inversion Principle，DIP）：抽象不应该依赖于细节，细节应该依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p> 
<p>依赖倒转原则要求在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p> 
<p></p> 
<p>为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p> 
<p>在实现依赖倒转原则时，需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependency Injection，DI）的方式注入其他对象中。</p> 
<p>依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有3种：构造注入、设值注入（Setter注入）和接口注入。</p> 
<p></p> 
<p>一个简单实例来加深对开闭原则、里氏代换原则和依赖倒转原则的理解：</p> 
<p>该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。</p> 
<p>在客户数据操作类中将调用数据格式转换类的方法实现格式转换和数据库插入操作，初始设计方案结构如图：</p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/ea/f7/58SvE7Di_o.png" width="941"></p> 
<p>发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时需要将TXTDataConvertor改为ExcelDataConvertor。此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则。</p> 
<p>由于CustomerDAO针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。可以通过引入抽象数据转换类解决该问题。在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程。</p> 
<p>更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图：</p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/fa/71/RcSfBsGw_o.png" width="1187"></p> 
<p>在大多数情况下，这3个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。</p> 
<p></p> 
<p>2.9　接口隔离原则</p> 
<p>接口隔离原则（Interface Segregation Principle，ISP）：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p> 
<p></p> 
<p>根据接口隔离原则，当一个接口太大时，需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。</p> 
<p></p> 
<p>1）当把“接口”理解成一个类型所提供的所有方法特征的集合时，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫作“角色隔离原则”。</p> 
<p></p> 
<p>2）如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</p> 
<p></p> 
<p>实例：针对某CRM系统的客户数据显示模块设计了如图2-17所示的CustomerDataDisplay接口。其中，方法readData（）用于从文件中读取数据；方法transformToXML（）用于将数据转换成XML格式；方法createChart（）用于创建图表；方法displayChart（）用于显示图表；方法createReport（）用于创建文字报表；方法displayReport（）用于显示文字报表。</p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/aa/d4/WKIkFVBY_o.jpg" width="900"></p> 
<p></p> 
<p>由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责。一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程度上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口</p> 
<p></p> 
<p>需要将该接口按照接口隔离原则和单一职责原则进行重构，</p> 
<p><img alt="" height="752" src="https://images2.imgbox.com/f0/ee/lJ8BhyU5_o.png" width="1007"></p> 
<p></p> 
<p>2.10　合成复用原则</p> 
<p>合成复用原则又称为组合／聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。</p> 
<p>合成复用原则（Composite Reuse Principle，CRP）：尽量使用对象组合，而不是继承来达到复用的目的。</p> 
<p>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合／聚合关系（关联关系），少用继承。</p> 
<p>组合／聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度。</p> 
<p>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用。</p> 
<p></p> 
<p>一个简单实例：</p> 
<p>在初期的CRM系统设计中，考虑到客户数量不多，系统采用MySQL作为数据库，与数据库操作有关的类（如CustomerDAO类等）都需要连接数据库，连接数据库的方法getConnection（）封装在DBUtil类中。由于需要重用DBUtil类的getConnection（）方法，设计人员将CustomerDAO作为DBUtil类的子类。</p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/f5/b7/cZ6qFLwY_o.png" width="839"></p> 
<p>随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库。由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则（当然也可以修改DBUtil类的源代码，同样会违反开闭原则。）</p> 
<p>根据合成复用原则，在实现复用时应该多用关联，少用继承。因此在本实例中可以使用关联复用来取代继承复用，重构后的结构如图：</p> 
<p><img alt="" height="485" src="https://images2.imgbox.com/6c/01/WUTmGL7J_o.png" width="1134"></p> 
<p>CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入CustomerDAO中，可以使用构造注入，也可以使用设值注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。</p> 
<p></p> 
<p>2.11　迪米特法则</p> 
<p>迪米特法则又称为最少知识原则（Least Knowledge Principle，LKP），其定义如下：迪米特法则（Law of Demeter，LoD）：一个软件实体应当尽可能少地与其他实体发生相互作用。</p> 
<p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易。这是对软件实体之间通信的限制。迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p> 
<p>迪米特法则还有几种定义形式：不要和“陌生人”说话，只与你的直接朋友通信等。</p> 
<p>对于一个对象，其“朋友”包括以下几类：（1）当前对象本身（this）。（2）以参数形式传入到当前对象方法中的对象。（3）当前对象的成员对象。（4）如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。（5）当前对象所创建的对象。</p> 
<p>一个简单实例来加深对迪米特法则的理解：</p> 
<p>CRM系统包含很多业务操作窗口。在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应。例如，当一个按钮（Button）被单击时，对应的列表框（List）、组合框（ComboBox）、文本框（TextBox）、文本标签（Label）等都将发生改变，在初始设计方案中，界面控件之间的交互关系可简化为如图2</p> 
<p><img alt="" height="672" src="https://images2.imgbox.com/49/c2/NYEA5mGu_o.png" width="917"></p> 
<p>现使用迪米特对其进行重构。在本实例中，可以通过引入一个专门用于控制界面控件交互的中间类（Mediator）来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。</p> 
<p><img alt="" height="710" src="https://images2.imgbox.com/d2/bd/SgSaH8u4_o.png" width="987"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5f3b17c6a62e277d7fd3783bbc9f41b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">设计模式的艺术P1基础—2.3 类之间的关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c1e8a0266aa05a5d7a893cc9c3d9155b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络安全之文件上传</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>