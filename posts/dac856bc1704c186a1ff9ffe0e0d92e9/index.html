<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试官问有没有用AJAX,字节跳动面试官：请用JS实现Ajax并发请求控制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试官问有没有用AJAX,字节跳动面试官：请用JS实现Ajax并发请求控制" />
<meta property="og:description" content="最近也好久没输出文章了，原因很简单，最近巨忙，，，，
讲真的，最近也很迷茫。关于技术、关于生活吧。也找了很多在大厂的朋友去聊，想需求一些后期发展的思路。这其中也聊到了面试，聊到了招聘中会给面试者出的一些题目。我正好也好久没面试了，就从中选了几道。最近也会陆续出一系列关于一些面试问题的解析。
今天这道是字节跳动的：
实现一个批量请求函数 multiRequest(urls, maxNum)，要求如下：
• 要求最大并发数 maxNum
• 每当有一个请求返回，就留下一个空位，可以增加新的请求
• 所有请求完成后，结果按照 urls 里面的顺序依次打出
复制代码
这道题目我想很多同学应该都或多或少的见过，下面我会依次从出现的场景、问题的分析到最终的实现，一步步力求深入浅出的给出这道题目的完整解析。
场景
假设现在有这么一种场景：现有 30 个异步请求需要发送，但由于某些原因，我们必须将同一时刻并发请求数量控制在 5 个以内，同时还要尽可能快速的拿到响应结果。
应该怎么做？
首先我们来了解一下 Ajax的串行和并行。
基于 Promise.all 实现 Ajax 的串行和并行
我们平时都是基于promise来封装异步请求的，这里也主要是针对异步请求来展开。
串行：一个异步请求完了之后在进行下一个请求
并行：多个异步请求同时进行
通过定义一些promise实例来具体演示串行/并行。
串行
var p = function (){
return new Promise(function (resolve, reject){
setTimeout(() =&gt; {
console.log(&#39;1000&#39;)
resolve()
}, 1000)
})
}
var p1 = function (){
return new Promise(function (resolve, reject){
setTimeout(() =&gt; {
console.log(&#39;2000&#39;)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dac856bc1704c186a1ff9ffe0e0d92e9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-06T06:12:02+08:00" />
<meta property="article:modified_time" content="2021-08-06T06:12:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试官问有没有用AJAX,字节跳动面试官：请用JS实现Ajax并发请求控制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>最近也好久没输出文章了，原因很简单，最近巨忙，，，，</p> 
 <p align="center"><img src="https://images2.imgbox.com/5b/9a/8Q7l0Bh8_o.png" alt="232505fedd635d805b008b279c73a589.png"></p> 
 <p>讲真的，最近也很迷茫。关于技术、关于生活吧。也找了很多在大厂的朋友去聊，想需求一些后期发展的思路。这其中也聊到了面试，聊到了招聘中会给面试者出的一些题目。我正好也好久没面试了，就从中选了几道。最近也会陆续出一系列关于一些面试问题的解析。</p> 
 <p>今天这道是字节跳动的：</p> 
 <p>实现一个批量请求函数 multiRequest(urls, maxNum)，要求如下：</p> 
 <p>• 要求最大并发数 maxNum</p> 
 <p>• 每当有一个请求返回，就留下一个空位，可以增加新的请求</p> 
 <p>• 所有请求完成后，结果按照 urls 里面的顺序依次打出</p> 
 <p>复制代码</p> 
 <p>这道题目我想很多同学应该都或多或少的见过，下面我会依次从出现的场景、问题的分析到最终的实现，一步步力求深入浅出的给出这道题目的完整解析。</p> 
 <p>场景</p> 
 <p>假设现在有这么一种场景：现有 30 个异步请求需要发送，但由于某些原因，我们必须将同一时刻并发请求数量控制在 5 个以内，同时还要尽可能快速的拿到响应结果。</p> 
 <p>应该怎么做？</p> 
 <p>首先我们来了解一下 Ajax的串行和并行。</p> 
 <p>基于 Promise.all 实现 Ajax 的串行和并行</p> 
 <p>我们平时都是基于promise来封装异步请求的，这里也主要是针对异步请求来展开。</p> 
 <p>串行：一个异步请求完了之后在进行下一个请求</p> 
 <p>并行：多个异步请求同时进行</p> 
 <p>通过定义一些promise实例来具体演示串行/并行。</p> 
 <p>串行</p> 
 <p>var p = function (){<!-- --></p> 
 <p>return new Promise(function (resolve, reject){<!-- --></p> 
 <p>setTimeout(() =&gt; {<!-- --></p> 
 <p>console.log('1000')</p> 
 <p>resolve()</p> 
 <p>}, 1000)</p> 
 <p>})</p> 
 <p>}</p> 
 <p>var p1 = function (){<!-- --></p> 
 <p>return new Promise(function (resolve, reject){<!-- --></p> 
 <p>setTimeout(() =&gt; {<!-- --></p> 
 <p>console.log('2000')</p> 
 <p>resolve()</p> 
 <p>}, 2000)</p> 
 <p>})</p> 
 <p>}</p> 
 <p>var p2 = function (){<!-- --></p> 
 <p>return new Promise(function (resolve, reject){<!-- --></p> 
 <p>setTimeout(() =&gt; {<!-- --></p> 
 <p>console.log('3000')</p> 
 <p>resolve()</p> 
 <p>}, 3000)</p> 
 <p>})</p> 
 <p>}</p> 
 <p>p().then(() =&gt; {<!-- --></p> 
 <p>return p1()</p> 
 <p>}).then(() =&gt; {<!-- --></p> 
 <p>return p2()</p> 
 <p>}).then(() =&gt; {<!-- --></p> 
 <p>console.log('end')</p> 
 <p>})</p> 
 <p>复制代码</p> 
 <p>如示例，串行会从上到下依次执行对应接口请求。</p> 
 <p>并行</p> 
 <p>通常，我们在需要保证代码在多个异步处理之后执行，会用到：</p> 
 <p>Promise.all(promises: []).then(fun: function);</p> 
 <p>复制代码</p> 
 <p>Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执行then回调。</p> 
 <p>var promises = function (){<!-- --></p> 
 <p>return [1000, 2000, 3000].map(current =&gt; {<!-- --></p> 
 <p>return new Promise(function (resolve, reject){<!-- --></p> 
 <p>setTimeout(() =&gt; {<!-- --></p> 
 <p>console.log(current)</p> 
 <p>}, current)</p> 
 <p>})</p> 
 <p>})</p> 
 <p>}</p> 
 <p>Promise.all(promises()).then(() =&gt; {<!-- --></p> 
 <p>console.log('end')</p> 
 <p>})</p> 
 <p>复制代码</p> 
 <p>Promise.all 并发限制</p> 
 <p>这时候考虑一个场景：如果你的promises数组中每个对象都是http请求，而这样的对象有几十万个。</p> 
 <p>那么会出现的情况是，你在瞬间发出几十万个http请求，这样很有可能导致堆积了无数调用栈导致内存溢出。</p> 
 <p>这时候，我们就需要考虑对Promise.all做并发限制。</p> 
 <p>Promise.all并发限制指的是，每个时刻并发执行的promise数量是固定的，最终的执行结果还是保持与原来的Promise.all一致。</p> 
 <p>题目实现</p> 
 <p>思路分析</p> 
 <p>整体采用递归调用来实现：最初发送的请求数量上限为允许的最大值，并且这些请求中的每一个都应该在完成时继续递归发送，通过传入的索引来确定了urls里面具体是那个URL，保证最后输出的顺序不会乱，而是依次输出。</p> 
 <p>代码实现</p> 
 <p>function multiRequest(urls = [], maxNum){<!-- --></p> 
 <p>// 请求总数量</p> 
 <p>const len = urls.length;</p> 
 <p>// 根据请求数量创建一个数组来保存请求的结果</p> 
 <p>const result = new Array(len).fill(false);</p> 
 <p>// 当前完成的数量</p> 
 <p>let count = 0;</p> 
 <p>return new Promise((resolve, reject) =&gt; {<!-- --></p> 
 <p>// 请求maxNum个</p> 
 <p>while (count &lt; maxNum) {<!-- --></p> 
 <p>next();</p> 
 <p>}</p> 
 <p>function next(){<!-- --></p> 
 <p>let current = count++;</p> 
 <p>// 处理边界条件</p> 
 <p>if (current &gt;= len) {<!-- --></p> 
 <p>// 请求全部完成就将promise置为成功状态, 然后将result作为promise值返回</p> 
 <p>!result.includes(false) &amp;&amp; resolve(result);</p> 
 <p>return;</p> 
 <p>}</p> 
 <p>const url = urls[current];</p> 
 <p>console.log(`开始 ${current}`, new Date().toLocaleString());</p> 
 <p>fetch(url)</p> 
 <p>.then((res) =&gt; {<!-- --></p> 
 <p>// 保存请求结果</p> 
 <p>result[current] = res;</p> 
 <p>console.log(`完成 ${current}`, new Date().toLocaleString());</p> 
 <p>// 请求没有全部完成, 就递归</p> 
 <p>if (current &lt; len) {<!-- --></p> 
 <p>next();</p> 
 <p>}</p> 
 <p>})</p> 
 <p>.catch((err) =&gt; {<!-- --></p> 
 <p>console.log(`结束 ${current}`, new Date().toLocaleString());</p> 
 <p>result[current] = err;</p> 
 <p>// 请求没有全部完成, 就递归</p> 
 <p>if (current &lt; len) {<!-- --></p> 
 <p>next();</p> 
 <p>}</p> 
 <p>});</p> 
 <p>}</p> 
 <p>});</p> 
 <p>}</p> 
 <p>复制代码</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a006aeb2a5c320a886eae27dfbf2c3d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ajax技术进行表单验证,ajax制作表单验证示例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/586e09ab68402a012186c015a2e36a56/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">转转参数信息服务器,转转登录服务器异常</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>