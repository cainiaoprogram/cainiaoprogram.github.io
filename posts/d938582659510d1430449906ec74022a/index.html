<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA宝典----多线程(理解记忆) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA宝典----多线程(理解记忆)" />
<meta property="og:description" content="目录
一、什么是线程？它与进程有什么区别？为什么要使用多线程？
二、 同步和异步有什么区别？
三、如何实现Java多线程？
（1）继承Thread类，重写run（）方法
（2）实现Runnable接口，并实现该接口的run（）方法
（3）实现Callable接口，重写call（）方法
四、一个类是否可以同时继承Thread与实现Runnable接口？
五、run（）方法与start（）方法有什么区别？
六、多线程同步的实现方法有哪些？
（1）synchronized关键字
（2）wait（）方法与notify（）方法
（3）Lock
七、sleep（）方法与wait（）方法有什么区别?
八、sleep（）方法与yield（）方法有什么区别？
九、终止线程的方法有哪些？
十、synchronized与Lock有什么异同？
十一、什么是守护线程？
十二、 join（）方法的作用是什么？
一、什么是线程？它与进程有什么区别？为什么要使用多线程？ 线程是指程序在执行过程中，能够执行程序代码的一个执行单元。在Java语言中，线程有4种状态：运行、就绪、挂起和结束。
进程是指一段正在执行的程序。而线程有时也被称为轻量级进程，它是程序执行的最小单元，一个进程可以拥有多个线程，各个线程之间共享程序的内存空间（代码段、数据段和堆空间）及一些进程级的资源（例如打开的文件），但是各个线程拥有自己的栈空间。
在操作系统级别上，程序的执行都是以进程为单位的，而每个进程中通常都会有多个线程互不影响地并发执行，那么为什么要使用多线程呢？原因有以下几个方面的内容：
1）使用多线程可以减少程序的响应时间。在单线程（单线程指的是程序执行过程中只有一个有效操作的序列，不同操作之间都有明确的执行先后顺序）的情况下，如果某个操作很耗时，或者陷入长时间的等待（如等待网络响应），此时程序将不会响应鼠标和键盘等操作，使用多线程后，可以把这个耗时的线程分配到一个单独的线程去执行，从而使程序具备了更好的交互性。
2）与进程相比，线程的创建和切换开销更小。由于启动一个新的线程必须给这个线程分配独立的地址空间，建立许多数据结构来维护线程代码段、数据段等信息，而运行于同一进程内的线程共享代码段、数据段，线程的启动或切换的开销比进程要少很多。同时多线程在数据共享方面效率非常高。
3）多CPU或多核计算机本身就具有执行多线程的能力，如果使用单个线程，将无法重复利用计算机资源，造成资源的巨大浪费。因此在多CPU计算机上使用多线程能提高CPU的利用率。
4）使用多线程能简化程序的结构，使程序便于理解和维护。一个非常复杂的进程可以分成多个线程来执行。
二、 同步和异步有什么区别？ 在多线程的环境中，经常会碰到数据的共享问题，即当多个线程需要访问同一个资源时，它们需要以某种顺序来确保该资源在某一时刻只能被一个线程使用，否则，程序的运行结果将会是不可预料的，在这种情况下就必须对数据进行同步，例如多个线程同时对同一数据进行写操作，即当线程A需要使用某个资源时，如果这个资源正在被线程B使用，同步机制就会让线程A一直等待下去，直到线程B结束对该资源的使用后，线程A才能使用这个资源，由此可见，同步机制能够保证资源的安全。
要想实现同步操作，必须要获得每一个线程对象的锁。获得它可以保证在同一时刻只有一个线程能够进入临界区（访问互斥资源的代码块），并且在这个锁被释放之前，其他线程就不能再进入这个临界区。如果还有其他线程想要获得该对象的锁，只能进入等待队列等待。只有当拥有该对象锁的线程退出临界区时，锁才会被释放，等待队列中优先级最高的线程才能获得该锁，从而进入共享代码区。
Java语言在同步机制中提供了语言级的支持，可以通过使用synchronized关键字来实现同步，它是以很大的系统开销作为代价的，有时候甚至可能造成死锁，所以，同步控制并非越多越好，要尽量避免无谓的同步控制。实现同步的方式有两种：一种是利用同步代码块来实现同步；另一种是利用同步方法来实现同步。
异步与非阻塞类似，由于每个线程都包含了运行时自身所需要的数据或方法，因此，在进行输入输出处理时，不必关心其他线程的状态或行为，也不必等到输入输出处理完毕才返回。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，异步能够提高程序的效率。
三、如何实现Java多线程？ Java虚拟机允许应用程序并发地运行多个线程。在Java语言中，多线程的实现一般有以下3种方法，其中前两种为最常用的方法。
（1）继承Thread类，重写run（）方法 Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start（）方法。start（）方法是一个native（本地）方法，它将启动一个新线程，并执行run（）方法（Thread中提供的run（）方法是一个空方法）。这种方式通过自定义直接extend Thread，并重写run（）方法，就可以启动新线程并执行自己定义的run（）方法。需要注意的是，调用start（）方法后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行多线程代码是由操作系统决定的
public class test { public static void main(String[] args) { MyThread thread = new MyThread(); thread.start();//开启线程 } public static class MyThread extends Thread{ public void run(){ System.out.println(&#34; Thread body&#34;);//线程的函数体 } } } 输出结果：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d938582659510d1430449906ec74022a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-28T15:40:21+08:00" />
<meta property="article:modified_time" content="2023-08-28T15:40:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA宝典----多线程(理解记忆)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%AE%83%E4%B8%8E%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%AE%83%E4%B8%8E%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F" rel="nofollow">一、什么是线程？它与进程有什么区别？为什么要使用多线程？</a></p> 
<p id="%E4%BA%8C%E3%80%81%C2%A0%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%C2%A0%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">二、 同步和异步有什么区别？</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F" rel="nofollow">三、如何实现Java多线程？</a></p> 
<p id="%EF%BC%881%EF%BC%89%E7%BB%A7%E6%89%BFThread%E7%B1%BB%EF%BC%8C%E9%87%8D%E5%86%99run%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E7%BB%A7%E6%89%BFThread%E7%B1%BB%EF%BC%8C%E9%87%8D%E5%86%99run%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95" rel="nofollow">（1）继承Thread类，重写run（）方法</a></p> 
<p id="%C2%A0%EF%BC%882%EF%BC%89%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%AF%A5%E6%8E%A5%E5%8F%A3%E7%9A%84run%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A0%EF%BC%882%EF%BC%89%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%AF%A5%E6%8E%A5%E5%8F%A3%E7%9A%84run%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95" rel="nofollow"> （2）实现Runnable接口，并实现该接口的run（）方法</a></p> 
<p id="%EF%BC%883%EF%BC%89%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%87%8D%E5%86%99call%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%87%8D%E5%86%99call%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95" rel="nofollow">（3）实现Callable接口，重写call（）方法</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%A7%E6%89%BFThread%E4%B8%8E%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%A7%E6%89%BFThread%E4%B8%8E%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%9F" rel="nofollow">四、一个类是否可以同时继承Thread与实现Runnable接口？</a></p> 
<p id="%E4%BA%94%E3%80%81run%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Estart%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81run%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Estart%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">五、run（）方法与start（）方法有什么区别？</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow">六、多线程同步的实现方法有哪些？</a></p> 
<p id="%EF%BC%881%EF%BC%89synchronized%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89synchronized%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">（1）synchronized关键字</a></p> 
<p id="%EF%BC%882%EF%BC%89wait%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Enotify%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89wait%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Enotify%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95" rel="nofollow">（2）wait（）方法与notify（）方法</a></p> 
<p id="%EF%BC%883%EF%BC%89Lock-toc" style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89Lock" rel="nofollow">（3）Lock</a></p> 
<p id="%E4%B8%83%E3%80%81sleep%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Ewait%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81sleep%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Ewait%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F" rel="nofollow">七、sleep（）方法与wait（）方法有什么区别?</a></p> 
<p id="%E5%85%AB%E3%80%81sleep%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Eyield%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81sleep%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Eyield%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">八、sleep（）方法与yield（）方法有什么区别？</a></p> 
<p id="%E4%B9%9D%E3%80%81%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow">九、终止线程的方法有哪些？</a></p> 
<p id="%E5%8D%81%E3%80%81synchronized%E4%B8%8ELock%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E3%80%81synchronized%E4%B8%8ELock%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%EF%BC%9F" rel="nofollow">十、synchronized与Lock有什么异同？</a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9F" rel="nofollow">十一、什么是守护线程？</a></p> 
<p id="%E5%8D%81%E4%BA%8C%E3%80%81%C2%A0join%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%BA%8C%E3%80%81%C2%A0join%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">十二、 join（）方法的作用是什么？</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%AE%83%E4%B8%8E%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F">一、什么是线程？它与进程有什么区别？为什么要使用多线程？</h2> 
<p>        <span style="color:#fe2c24;"><strong>线程</strong></span>是指程序在执行过程中，能够执行程序代码的一个执行单元。<strong><span style="color:#fe2c24;">在Java语言中，线程有4种状态：运行、就绪、挂起和结束</span></strong>。</p> 
<p><span style="color:#fe2c24;"><strong>        进程</strong></span>是指一段正在执行的程序。而线程有时也被称为轻量级进程，它是程序执行的最小单元，一个进程可以拥有多个线程，各个线程之间共享程序的内存空间（代码段、数据段和堆空间）及一些进程级的资源（例如打开的文件），但是各个线程拥有自己的栈空间。</p> 
<p>        在操作系统级别上，程序的执行都是以进程为单位的，而每个进程中通常都会有多个线程互不影响地并发执行，那么为什么要使用多线程呢？原因有以下几个方面的内容：</p> 
<p>1）<span style="color:#fe2c24;"><strong>使用多线程可以减少程序的响应时间</strong></span>。在单线程（单线程指的是程序执行过程中只有一个有效操作的序列，不同操作之间都有明确的执行先后顺序）的情况下，如果某个操作很耗时，或者陷入长时间的等待（如等待网络响应），此时程序将不会响应鼠标和键盘等操作，使用多线程后，可以把这个耗时的线程分配到一个单独的线程去执行，从而使程序具备了更好的交互性。</p> 
<p>2）<span style="color:#fe2c24;"><strong>与进程相比，线程的创建和切换开销更小。</strong></span>由于启动一个新的线程必须给这个线程分配独立的地址空间，建立许多数据结构来维护线程代码段、数据段等信息，而运行于同一进程内的线程共享代码段、数据段，线程的启动或切换的开销比进程要少很多。同时多线程在数据共享方面效率非常高。<br> 3）<span style="color:#fe2c24;"><strong>多CPU或多核计算机本身就具有执行多线程的能力</strong></span>，如果使用单个线程，将无法重复利用计算机资源，造成资源的巨大浪费。因此在多CPU计算机上使用多线程能提高CPU的利用率。<br> 4）<span style="color:#fe2c24;"><strong>使用多线程能简化程序的结构，使程序便于理解和维护</strong></span>。一个非常复杂的进程可以分成多个线程来执行。</p> 
<h2 id="%E4%BA%8C%E3%80%81%C2%A0%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">二、 同步和异步有什么区别？</h2> 
<p>        在多线程的环境中，经常会碰到数据的共享问题，即当多个线程需要访问同一个资源时，它们需要以某种顺序来确保该资源在某一时刻只能被一个线程使用，否则，程序的运行结果将会是不可预料的，在这种情况下就必须对数据进行同步，例如多个线程同时对同一数据进行写操作，即当线程A需要使用某个资源时，如果这个资源正在被线程B使用，同步机制就会让线程A一直等待下去，直到线程B结束对该资源的使用后，线程A才能使用这个资源，由此可见，同步机制能够保证资源的安全。</p> 
<p>        要想实现同步操作，必须要获得每一个线程对象的锁。获得它可以保证在同一时刻只有一个线程能够进入临界区（访问互斥资源的代码块），并且在这个锁被释放之前，其他线程就不能再进入这个临界区。如果还有其他线程想要获得该对象的锁，只能进入等待队列等待。只有当拥有该对象锁的线程退出临界区时，锁才会被释放，等待队列中优先级最高的线程才能获得该锁，从而进入共享代码区。</p> 
<p>        Java语言在同步机制中提供了语言级的支持，可以通过使用synchronized关键字来实现同步，它是以很大的系统开销作为代价的，有时候甚至可能造成死锁，所以，同步控制并非越多越好，要尽量避免无谓的同步控制。<span style="color:#fe2c24;"><strong>实现同步的方式有两种：一种是利用同步代码块来实现同步；另一种是利用同步方法来实现同步</strong></span>。</p> 
<p>        <span style="color:#fe2c24;"><strong>异步</strong></span>与非阻塞类似，由于每个线程都包含了运行时自身所需要的数据或方法，因此，在进行输入输出处理时，不必关心其他线程的状态或行为，也不必等到输入输出处理完毕才返回。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，异步能够提高程序的效率。</p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F">三、如何实现Java多线程？</h2> 
<p><br>         Java虚拟机允许应用程序并发地运行多个线程。在Java语言中，多线程的实现一般有以下3种方法，其中前两种为最常用的方法。</p> 
<h3 id="%EF%BC%881%EF%BC%89%E7%BB%A7%E6%89%BFThread%E7%B1%BB%EF%BC%8C%E9%87%8D%E5%86%99run%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95"><br> （1）继承Thread类，重写run（）方法</h3> 
<p><br>         Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start（）方法。start（）方法是一个native（本地）方法，它将启动一个新线程，并执行run（）方法（Thread中提供的run（）方法是一个空方法）。这种方式通过自定义直接extend Thread，并重写run（）方法，就可以启动新线程并执行自己定义的run（）方法。需要注意的是，调用start（）方法后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行多线程代码是由操作系统决定的</p> 
<p></p> 
<pre><code class="language-java">public class test {
    public static void main(String[] args) {

        MyThread thread = new MyThread();
        thread.start();//开启线程
    }

    public static class MyThread extends Thread{
        public void run(){
            System.out.println(" Thread body");//线程的函数体
        }
}

}</code></pre> 
<blockquote> 
 <p>输出结果：</p> 
 <p>        Thread body</p> 
</blockquote> 
<h3 id="%C2%A0%EF%BC%882%EF%BC%89%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%AF%A5%E6%8E%A5%E5%8F%A3%E7%9A%84run%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95"> （2）实现Runnable接口，并实现该接口的run（）方法</h3> 
<p>以下是主要步骤：</p> 
<p>1）自定义类并实现Runnable接口，实现run（）方法。</p> 
<p>2）创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象。</p> 
<p>3）调用Thread的start（）方法。</p> 
<pre><code class="language-java">public class test {
    public static void main(String[] args) {

        MyThread thread = new MyThread();
        Thread t = new Thread(thread);
        t.start();//开启线程
    }

    public static class MyThread implements Runnable{ //创建线程类
        public void run(){
            System.out.println(" Thread body");//线程的函数体
        }
}

}</code></pre> 
<blockquote> 
 <p>运行结果：</p> 
 <p>        Thread body</p> 
</blockquote> 
<p>其实，不管是通过继承Thread类还是通过使用Runnable接口来实现多线程的方法，最终还是通过Thread的对象的API来控制线程的。</p> 
<h3 id="%EF%BC%883%EF%BC%89%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%87%8D%E5%86%99call%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95"><br> （3）实现Callable接口，重写call（）方法</h3> 
<p><br> Callable接口实际是属于Executor框架中的功能类，Callable接口与Runnable接口的功能类似，但提供了比Runnable更强大的功能，主要表现为以下3点：<br> 1）Callable可以在任务结束后提供一个返回值，Runnable无法提供这个功能。<br> 2）Callable中的call（）方法可以抛出异常，而Runnable的run（）方法不能抛出异常。<br> 3）运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，它提供了检查计算是否完成的方法。由于线程属于异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下，就可以使用Future来监视目标线程调用call（）方法的情况，当调用Fu-ture的get（）方法以获取结果时，当前线程就会阻塞，直到call（）方法结束返回结果。</p> 
<pre><code class="language-java">import java.util.concurrent.Callable;

public class test{
    public static void main(String[] args) throws Exception {
        CallableAndFuture.CallableTest test = new CallableAndFuture.CallableTest();
        test.call();
        System.out.println(test.call());
    }


public static class CallableAndFuture {
    //创建线程类
    public static class CallableTest implements Callable&lt;String&gt; {
        public String call() throws Exception {
            return " Hello World ! ";
        }
    }
}

}</code></pre> 
<blockquote> 
 <p>运行结果：</p> 
 <p>         Hello World ! </p> 
</blockquote> 
<p>以上3种方式中，前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的。当需要实现多线程时，一般推荐实现Runnable接口的方式，其原因是：首先，Thread类定义了多种方法可以被派生类使用或重写。但是只有run（）方法是必须被重写的，在run（）方法中实现这个线程的主要功能。这当然是实现Runnable接口所需的方法。其次，很多Java开发人员认为，一个类仅在他们需要被加强或修改时才会被继承。因此，如果没有必要重写Thread类中的其他方法，那么通过继承Thread的实现方式与实现Runnable接口的效果相同，在这种情况下最好通过实现Runnable接口的方式来创建线程。</p> 
<h2 id="%E5%9B%9B%E3%80%81%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%A7%E6%89%BFThread%E4%B8%8E%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%9F">四、一个类是否可以同时继承Thread与实现Runnable接口？</h2> 
<p>        从上例中可以看出，test类实现了Runnable接口，但是并没有实现接口的run（）方法，可能有些读者会认为这会导致编译错误，但实际它是能够编译通过并运行的，因为Test类从Thread类中继承了run（）方法，这个继承的run（）方法可以被当作对Runnable接口的实现，因此这段代码能够编译通过。当然也可以不使用继承的run（）方法，而是需要通过在Test类中重写run（）方法来实现Runnable接口中的run（）方法，示例如下：</p> 
<pre><code class="language-java">class test extends Thread implements Runnable {
    public static void main(String args[]) {
        Thread t = new Thread(new test());
        t.start();
    }

    public void run() {
        System.out.println(" this is run()");
    }
}</code></pre> 
<blockquote> 
 <p> 运行结果：</p> 
 <p>         this is run()</p> 
</blockquote> 
<h2 id="%E4%BA%94%E3%80%81run%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Estart%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">五、run（）方法与start（）方法有什么区别？</h2> 
<p>        通常，系统通过调用线程类的start（）方法来启动一个线程，此时该线程处于就绪状态，而非运行状态，也就意味着这个线程可以被JVM来调度执行。在调度过程中，JVM通过调用线程类的run（）方法来完成实际的操作，当run（）方法结束后，此线程就会终止。</p> 
<p>        如果直接调用线程类的run（）方法，这会被当作一个普通的函数调用，程序中仍然只有主线程这一个线程，也就是说，start方法（）能够异步地调用run（）方法，但是直接调用run（）方法却是同步的，因此也就无法达到多线程的目的。</p> 
<p>                 举个例子，start()相当于你洗澡和听音乐，可在洗澡时同时进行听音乐; run()相当于 做饭和吃饭，必须等做饭完成才能进行吃饭。</p> 
<p>由此可知，只有通过调用线程类的start（）方法才能真正达到多线程的目的。</p> 
<h2 id="%E5%85%AD%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">六、多线程同步的实现方法有哪些？</h2> 
<p>        当使用多线程访问同一个资源时，非常容易出现线程安全的问题（例如，当多个线程同时对一个数据进行修改时，会导致某些线程对数据的修改丢失）。因此，需要采用同步机制来解决这种问题。Java主要提供了3种实现同步机制的方法：</p> 
<h3 id="%EF%BC%881%EF%BC%89synchronized%E5%85%B3%E9%94%AE%E5%AD%97">（1）synchronized关键字</h3> 
<p>        在Java语言中，每个对象都有一个对象锁与之相关联，该锁表明对象在任何时候只允许被一个线程所拥有，当一个线程调用对象的一段synchronized代码时，需要先获取这个锁，然后去执行相应的代码，执行结束后，释放锁。</p> 
<p>        synchronized关键字主要有两种用法（synchronized方法和synchronized块），此外该关键字还可以作用于静态方法、类或某个实例，但这都对程序的效率有很大的影响。</p> 
<p>1）<span style="color:#fe2c24;"><strong>synchronized方法</strong></span>。在方法的声明前加入synchronized关键字，示例如下：</p> 
<p>public synchronized void mutiThreadAccess（）；</p> 
<p>        只要把多个线程对类需要被同步的资源的操作放到mutiThreadAccess（）方法中，就能保证这个方法在同一时刻只能被一个线程访问，从而保证了多线程访问的安全性。然而，当一个方法的方法体规模非常大时，把该方法声明为synchronized会大大影响程序的执行效率。为了提高程序的效率，Java提供了synchronized块。</p> 
<p>2）<span style="color:#fe2c24;"><strong>synchronized块</strong></span>。synchronized块既可以把任意的代码段声明为synchronized，也可以指定上锁的对象，有非常高的灵活性。其用法如下：</p> 
<p>synchronzed(syncObject)</p> 
<p>{<!-- --></p> 
<p>        访问syncObject的代码</p> 
<p>}</p> 
<h3 id="%EF%BC%882%EF%BC%89wait%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Enotify%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95">（2）wait（）方法与notify（）方法</h3> 
<p>        当使用synchronized来修饰某个共享资源时，如果线程A1在执行synchronized代码，另外一个线程A2也要同时执行同一对象的同一synchronized代码时，线程A2将要等到线程A1执行完成后，才能继续执行。在这种情况下可以使用wait（）方法和notify（）方法。</p> 
<p>        在synchronized代码被执行期间，线程可以调用对象的wait（）方法，释放对象锁，进入等待状态，并且可以调用notify（）方法或notifyAll（）方法通知正在等待的其他线程。notify（）方法仅唤醒一个线程（等待队列中的第一个线程）并允许它去获得锁，notifyAll（）方法唤醒所有等待这个对象的线程并允许它们去获得锁（并不是让所有唤醒线程都获取到锁，而是让它们去竞争）。</p> 
<h3 id="%EF%BC%883%EF%BC%89Lock">（3）Lock</h3> 
<p>        JDK 5新增加了Lock接口以及它的一个实现类ReentrantLock（重入锁），Lock也可以用来实现多线程的同步，具体而言，它提供了如下一些方法来实现多线程的同步：</p> 
<p>1）lock（）。以阻塞的方式获取锁，也就是说，如果获取到了锁，立即返回；如果别的线程持有锁，当前线程等待，直到获取锁后返回。</p> 
<p>2）tryLock（）。以非阻塞的方式获取锁。只是尝试性地去获取一下锁，如果获取到锁，立即返回true，否则，立即返回false。</p> 
<p>3）tryLock（long timeout，TimeUnit unit）。如果获取了锁，立即返回true，否则会等待参数给定的时间单元，在等待的过程中，如果获取了锁，就返回true，如果等待超时，返回false。</p> 
<p>4）lockInterruptibly（）。如果获取了锁，立即返回；如果没有获取锁，当前线程处于休眠状态，直到获得锁，或者当前线程被别的线程中断（会收到InterruptedException异常）。它与lock（）方法最大的区别在于如果lock（）方法获取不到锁，会一直处于阻塞状态，且会忽略in-terrupt（）方法</p> 
<h2 id="%E4%B8%83%E3%80%81sleep%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Ewait%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F">七、sleep（）方法与wait（）方法有什么区别?</h2> 
<p>        sleep（）是使线程暂停执行一段时间的方法。wait（）也是一种使线程暂停执行的方法，例如，当线程交互时，如果线程对一个同步对象x发出一个wait（）调用请求，那么该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间超时。</p> 
<p>具体而言，sleep（）方法与wait（）方法的区别主要表现在以下几个方面：</p> 
<p>1）原理不同。sleep（）方法是Thread类的静态方法，是线程用来控制自身流程的，它会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到计时时间一到，此线程会自动“苏醒”，例如，当线程执行报时功能时，每一秒钟打印出一个时间，那么此时就需要在打印方法前面加上一个sleep（）方法，以便让自己每隔1s执行一次，该过程如同闹钟一样。而wait（）方法是Object类的方法，用于线程间的通信，这个方法会使当前拥有该对象锁的进程等待，直到其他线程调用notify（）方法（或notifyAll方法）时才“醒”来，不过开发人员也可以给它指定一个时间，自动“醒”来。与wait（）方法配套的方法还有notify（）方法和notifyAll（）方法。</p> 
<p>2）对锁的处理机制不同。由于sleep（）方法的主要作用是让线程暂停执行一段时间，时间一到则自动恢复，不涉及线程间的通信，因此，调用sleep（）方法并不会释放锁。而wait（）方法则不同，当调用wait（）方法后，线程会释放掉它所占用的锁，从而使线程所在对象中的其他synchronized数据可被别的线程使用。举个简单例子，如果何昊拿遥控器的期间，可以用自己的sleep（）方法每隔10min调一次频道，而在这10min里，遥控器还在他的手上。</p> 
<p>3）使用区域不同。由于wait（）方法的特殊意义，因此它必须放在同步控制方法或者同步语句块中使用，而sleep（）方法则可以放在任何地方使用。</p> 
<p>sleep（）方法必须捕获异常，而wait（）、notify（）以及notifyall（）不需要捕获异常。在sleep的过程中，有可能被其他对象调用它的interrupt（），产生InterruptedException异常。</p> 
<p>由于sleep不会释放“锁标志”，容易导致死锁问题的发生，因此，一般情况下，不推荐使用sleep（）方法，而推荐使用wait（）方法。</p> 
<h2 id="%E5%85%AB%E3%80%81sleep%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%8Eyield%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">八、sleep（）方法与yield（）方法有什么区别？</h2> 
<p>主要表现在以下几个方面：</p> 
<p>1）sleep（）方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会，而yield（）方法只会给相同优先级或更高优先级的线程以运行的机会。</p> 
<p>2）线程执行sleep（）方法后会转入阻塞状态，所以，执行sleep（）方法的线程在指定的时间内肯定不会被执行，而yield（）方法只是使当前线程重新回到可执行状态，所以执行yield（）方法的线程有可能在进入到可执行状态后马上又被执行。</p> 
<p>3）sleep（）方法声明抛出InterruptedException，而yield（）方法没有声明任何异常。</p> 
<p>4）sleep（）方法比yield（）方法（跟操作系统相关）具有更好的可移植性。</p> 
<h2 id="%E4%B9%9D%E3%80%81%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">九、终止线程的方法有哪些？</h2> 
<p>在Java语言中，可以<span style="color:#fe2c24;"><strong>使用stop（）方法</strong></span>与<span style="color:#fe2c24;"><strong>suspend（）方法</strong></span>来终止线程的执行。</p> 
<p>当用Thread.stop（）来终止线程时，它会释放已经锁定的所有监视资源。如果当前任何一个受这些监视资源保护的对象处于一个不一致的状态，其他线程将会“看”到这个不一致的状态，这可能会导致程序执行的不确定性，并且这种问题很难被定位。</p> 
<p>调用suspend（）方法容易发生死锁。由于调用suspend（）方法不会释放锁，这就会导致一个问题：如果用一个suspend挂起一个有锁的线程，那么在锁恢复之前将不会被释放。</p> 
<p>鉴于以上两种方法的不安全性，Java语言已经不建议使用以上两种方法来终止线程了。</p> 
<p>一般建议采用的方法是让线程自行结束进入Dead状态。一个线程进入Dead状态，即执行完run（）方法，也就是说，如果想要停止一个线程的执行，就要提供某种方式让线程能够自动结束run（）方法的执行。在实现时，可以通过设置一个flag标志来控制循环是否执行，通过这种方法来让线程离开run（）方法从而终止线程。方法虽然能够终止线程，但同样也存在问题：当线程处于非运行状态时（当sleep（）方法被调用或当wait（）方法被调用或当被I/O阻塞时），方法便不可用。</p> 
<p>可以使用interrupt（）方法来打破阻塞的情况，当interrupt（）方法被调用时，会抛出InterruptedException异常，可以通过在run（）方法中捕获这个异常来让线程安全退出，具体实现方式如下：</p> 
<pre><code class="language-java">public class test {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            public void run() {
                System.out.println(" thread go to sleep");
                try {
                    //用休眠来模拟线程被阻塞
                    Thread.sleep(5000);
                    System.out.println(" thread finish");
                } catch (InterruptedException e) {
                    System.out.println(" thread is interupted!");
                }
            }
                });
                thread.start();
                thread.interrupt();
            }
        }

</code></pre> 
<blockquote> 
 <p>运行结果：</p> 
 <p>         thread go to sleep<br>          thread is interupted!</p> 
</blockquote> 
<h2 id="%E5%8D%81%E3%80%81synchronized%E4%B8%8ELock%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%EF%BC%9F">十、synchronized与Lock有什么异同？</h2> 
<p><br>      Java语言提供了两种锁机制来实现对某个共享资源的同步：synchronized和Lock。</p> 
<p>其中，<span style="color:#fe2c24;"><strong>synchronized</strong></span>使用Object对象本身的notify、wait、notityAll调度机制</p> 
<p>而<span style="color:#fe2c24;"><strong>Lock</strong></span>可以使用Condi-tion进行线程之间的调度，完成synchronized实现的所有功能。<br> 具体而言，二者的主要区别主要表现在以下几个方面的内容：<br> 1）用法不一样。在需要同步的对象中加入synchronized控制，synchronized既可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。 </p> 
<p>        而Lock需要显式地指定起始位置和终止位置。synchronized是托管给JVM执行的，而Lock的锁定是通过代码实现的，它有比synchronized更精确的线程语义。<br> 2）性能不一样。在JDK 5中增加了一个Lock接口的实现类ReentrantLock。它不仅拥有和synchronized相同的并发性和内存语义，还多了锁投票、定时锁、等候和中断锁等。它们的性能在不同的情况下会有所不同：在资源竞争不是很激烈的情况下，synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，synchronized的性能会下降得非常快。</p> 
<p>        而ReetrantLock的性能基本保持不变。<br> 3）锁机制不一样。synchronized获得锁和释放的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁，不会因为出了异常而导致锁没有被释放从而引发死锁。</p> 
<p>        而Lock则需要开发人员手动去释放，并且必须在finally块中释放，否则会引起死锁问题的发生。此外，Lock还提供了更强大的功能，它的tryLock（）方法可以采用非阻塞的方式去获取锁。<br> 虽然synchronized与Lock都可以用来实现多线程的同步，但是，最好不要同时使用这两种同步机制，因为ReetrantLock与synchronized所使用的机制不同，所以它们的运行是独立的，相当于两种类型的锁，在使用时互不影响，示例如下：</p> 
<pre><code class="language-java">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class test {
    public static void main(String[] args) {
        final SyncTest st = new SyncTest();//测试synchronized
//        final LockTest st = new LockTest( );//测试Lock
        Thread t1 = new Thread(
                new Runnable() {
                    public void run() {
                        for (int i = 0; i &lt; 5; i++) {
                            st.addValueSync();
                            try {
                                Thread.sleep(20);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
        );
        Thread t2 = new Thread(
                new Runnable() {
                    public void run() {
                        for (int i = 0; i &lt; 5; i++) {
                            st.addValueLock();
                            try {
                                Thread.sleep(20);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
        );
        t1.start();
        t2.start();
    }

    static class SyncTest {
        private int value = 0;
        Lock lock = new ReentrantLock();

        public synchronized void addValueSync() {
            this.value++;
            System.out.println(Thread.currentThread().getName() + " : " + value);
        }

        public void addValueLock() {
            try {
                lock.lock();
                value++;
                System.out.println(Thread.currentThread().getName() + " : " + value);
            } finally {
                lock.unlock();
            }
        }
    }
}
</code></pre> 
<blockquote> 
 <p>运行结果</p> 
 <p></p> 
 <p>Thread-0 : 1<br> Thread-1 : 2<br> Thread-0 : 3<br> Thread-1 : 4<br> Thread-0 : 6<br> Thread-1 : 5<br> Thread-1 : 8<br> Thread-0 : 8<br> Thread-1 : 10</p> 
</blockquote> 
<p>        上例中，并不是每次运行的结果都是相同的，输出结果value的值并不是连续的，这就是因两种上锁方法采用了不同的机制而造成的，因此在实际使用时，最好不要同时使用两种上锁机制。</p> 
<h2 id="%E5%8D%81%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9F">十一、什么是守护线程？</h2> 
<p>        Java提供了两种线程：<span style="color:#fe2c24;"><strong>守护线程</strong></span>与<span style="color:#fe2c24;"><strong>用户线程</strong></span>。守护线程又被称为“服务进程”或“后台线程”，是指在程序运行时在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分。通俗点讲，任何一个守护线程都是整个JVM中所有非守护线程的“保姆”。</p> 
<p>        用户线程和守护线程几乎一样，唯一的不同之处就在于如果用户线程已经全部退出运行，只剩下守护线程存在了，JVM也就退出了。因为当所有非守护线程结束时，没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了，程序也就终止了，同时会“杀死”所有守护线程。也就是说，只要有任何非守护线程还在运行，程序就不会终止。</p> 
<p>在Java语言中，守护线程一般具有较低的优先级，它并非只由JVM内部提供，用户在编写程序时也可以自己设置守护线程，例如，将一个用户线程设置为守护线程的方法就是在调用start（）方法启动线程之前调用对象的setDaemon（true）方法，若将以上参数设置为false，则表示的是用户进程模式。需要注意的是，当在一个守护线程中产生了其他线程，那么这些新产生的线程默认还是守护线程，用户线程也是如此，示例如下：</p> 
<pre><code class="language-java">public class test {
    public static void main(String[] args) {
        System.out.println("test3 : begin");
        Thread t1 = new ThreadDemo();
        t1.setDaemon(true);
        t1.start();
        System.out.println(Thread.currentThread().getName()+":begin");
        System.out.println("test3 ：end");
    }

    static class ThreadDemo extends Thread {
        public void run() {
            System.out.println(Thread.currentThread().getName() + ": begin");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " :end");
        }
    }
}</code></pre> 
<blockquote> 
 <p>程序运行结果为：</p> 
 <p>test3 : begin<br> main:begin<br> test3 ：end<br> Thread-0: begin</p> 
</blockquote> 
<p>从运行结果中可以发现，没有输出Thread-0：end。之所以结果是这样，是在启动线程前将其设置为守护线程了，当程序中只有守护线程存在时，JVM是可以退出的，也就是说，当JVM中只有守护线程运行时，JVM会自动关闭。因此，当test3方法调用结束后，main线程将退出，此时线程t1还处于休眠状态没有运行结束，但是由于此时只有这个守护线程在运行，JVM将会关闭，因此不会输出“Thread-0：end”。<br> 守护线程的一个典型的例子就是垃圾回收器。只要JVM启动，它始终在运行，实时监控和管理系统中可以</p> 
<h2 id="%E5%8D%81%E4%BA%8C%E3%80%81%C2%A0join%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">十二、 join（）方法的作用是什么？</h2> 
<p><br>         在Java语言中，join（）方法的作用是让调用该方法的线程在执行完run（）方法后，再执行join方法后面的代码。简单点说，就是将两个线程合并，用于实现同步功能。具体而言，可以通过线程A的join（）方法来等待线程A的结束，或者使用线程A的join（2000）方法来等待线程A的结束，但最多只等待2s，示例如下：</p> 
<pre><code class="language-java">public class test {
    public static void main(String[] args) {
        Thread t = new Thread(new ThreadImp());
        t.start();
        try {
            t.join(1000);//主线程等待t结束,只等Ⅰ秒
            if (t.isAlive())  //t已经结束
                System.out.println(" t has not finished");
            else
                System.out.println(" t has finished");
            System.out.println(" join Finish");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    static class ThreadImp implements Runnable {
        public void run() {
            try {
                System.out.println(" Begin ThreadImp");
                Thread.sleep(5000);
                System.out.println(" End ThreadImp");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre> 
<blockquote> 
 <p>运行结果为：</p> 
 <p> Begin ThreadImp<br>  t has not finished<br>  joinFinish<br>  End ThreadImp</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b64da2479737ef58aa5d90d4acee7b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何利用matlab自带的函数及工具箱对信号进行频谱分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/68327ff3c154e4eafa75361d594e3da0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JVM-性能优化工具 MAT</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>