<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常见的XML的两种解析方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常见的XML的两种解析方法" />
<meta property="og:description" content="XML优点：平台无关性,语言无关性,系统无关性
XML在不同的语言里解析方式都是一样的,只不过实现的语法不同而已。基本的解析方式有两种,一种叫SAX，另一种叫DOM。SAX是基于事件流的解析,DOM是基于XML文档树结构的解析.假设我们XML的内容和结构如下: &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;employees&gt; &lt;employee&gt; &lt;name&gt;ddviplinux&lt;/name&gt; &lt;sex&gt;m&lt;/sex&gt; &lt;age&gt;30&lt;/age&gt; &lt;/employee&gt; &lt;/employees&gt; 下面是解析XMl常用的Dom和Sex方法：
1.DOM生成和解析XML文档
为 XML 文档的已解析版本定义了一组接口。解析器读入整个文档，然后构建一个驻留内存的树结构，然后代码就可以使用 DOM 接口来操作这个树结构。优点：整个文档树在内存中，便于操作；支持删除、修改、重新排列等多种功能；缺点：将整个文档调入内存（包括无用的节点），浪费时间和空间；使用场合：一旦解析了文档还需多次访问这些数据；硬件资源充足（内存、CPU）。 public void parserXml(String fileName) { try { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();DocumentBuilder db = dbf.newDocumentBuilder(); Document document = db.parse(fileName); NodeList employees = document.getChildNodes(); for (int i = 0; i &lt; employees.getLength(); i&#43;&#43;) { Node employee = employees.item(i); NodeList employeeInfo = employee.getChildNodes(); for (int j = 0; j &lt; employeeInfo.getLength(); j&#43;&#43;) { Node node = employeeInfo." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a7e5dcc2f4b98288343134f59559fcd6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-05-26T15:58:00+08:00" />
<meta property="article:modified_time" content="2011-05-26T15:58:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常见的XML的两种解析方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>XML优点：平台无关性,语言无关性,系统无关性</p> 
<p>XML在不同的语言里解析方式都是一样的,只不过实现的语法不同而已。基本的解析方式有两种,一种叫SAX，另一种叫DOM。SAX是基于事件流的解析,DOM是基于XML文档树结构的解析.假设我们XML的内容和结构如下: </p> 
<p><textarea name="code" class="xhtml:showcolumns:firstline[1]">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;employees&gt; 
&lt;employee&gt; 
&lt;name&gt;ddviplinux&lt;/name&gt; 
&lt;sex&gt;m&lt;/sex&gt; 
&lt;age&gt;30&lt;/age&gt; 
&lt;/employee&gt; 
&lt;/employees&gt; 


</textarea> </p> 
<p>下面是解析XMl常用的Dom和Sex方法：</p> 
<p><strong>1.DOM生成和解析XML文档</strong></p> 
<p>为 XML 文档的已解析版本定义了一组接口。解析器读入整个文档，然后构建一个驻留内存的树结构，然后代码就可以使用 DOM 接口来操作这个树结构。优点：整个文档树在内存中，便于操作；支持删除、修改、重新排列等多种功能；缺点：将整个文档调入内存（包括无用的节点），浪费时间和空间；使用场合：一旦解析了文档还需多次访问这些数据；硬件资源充足（内存、CPU）。 </p> 
<p><textarea name="code" class="java:showcolumns:firstline[1]">public void parserXml(String fileName) { 
  try { 
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    DocumentBuilder db = dbf.newDocumentBuilder(); 
    Document document = db.parse(fileName); 
    NodeList employees = document.getChildNodes(); 
    for (int i = 0; i &lt; employees.getLength(); i++) { 
      Node employee = employees.item(i); 
      NodeList employeeInfo = employee.getChildNodes(); 
      for (int j = 0; j &lt; employeeInfo.getLength(); j++) { 
        Node node = employeeInfo.item(j); 
        NodeList employeeMeta = node.getChildNodes(); 
        for (int k = 0; k &lt; employeeMeta.getLength(); k++) { 
          System.out.println(employeeMeta.item(k).getNodeName() + ":" + employeeMeta.item(k).getTextContent()); 
        } 
      } 
    }
    System.out.println("解析完毕");
  } catch (Exception e) { 
      System.out.println(e.getMessage()); 
  }
}</textarea> </p> 
<p><strong>2.SAX生成和解析XML文档</strong> </p> 
<p>为解决DOM的问题，出现了SAX。SAX ，事件驱动。当解析器发现元素开始、元素结束、文本、文档的开始或结束等时，发送事件，程序员编写响应这些事件的代码，保存数据。优点：不用事先调入整个文档，占用资源少；SAX解析器代码比DOM解析器代码小，适于Applet，下载。缺点：不是持久的；事件过后，若没保存数据，那么数据就丢了；无状态性；从事件中只能得到文本，但不知该文本属于哪个元素；使用场合：Applet;只需XML文档的少量内容，很少回头访问；机器内存少；</p> 
<p> </p> 
<p><textarea name="code" class="java:showcolumns:firstline[1]">public void parserXml(String fileName) { 
  SAXParserFactory saxfac = SAXParserFactory.newInstance(); 
  try { 
    SAXParser saxparser = saxfac.newSAXParser(); 
    InputStream is = new FileInputStream(fileName); 
    saxparser.parse(is, new MySAXHandler()); 
  } catch (Exception e) { 
    e.printStackTrace(); 
  } 
}</textarea> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8af144296c5b6e3f1725563a9ee43152/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">人脸识别发展历史介绍 by 山世光</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98b0976d657a9e8a0869dcd51d56da98/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android创建文件夹和文件的一些经验教训</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>