<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NoSuchMethodError、NoClassDefFoundError的常见原因和通用解决方式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="NoSuchMethodError、NoClassDefFoundError的常见原因和通用解决方式" />
<meta property="og:description" content="目录
环境信息
问题描述
错误分析
解决方法
常见原因
1.第三方包，作用域不对导致应用没导入该包
2.编译时和运行时使用的版本不一样
3.JDK版本不一样
4.多个同路径、同名的类
1.代码复制场景
2.代码移动场景
排查步骤
附录
NoClassDefFoundError
Maven仲裁机制：
JVM类加载机制
环境信息 Spring Boot：2.0.8.RELEASE
Spring Boot内置的tomcat：tomcat-embed-core 8.5.37
问题描述 测试环境，部署打版之后，应用成功启动。可是在收到部分请求的时候，后端报错了，查看日志，发现出现了java.lang.NoSuchMethodError，具体是：
Caused by: java.lang.NoSuchMethodError: com.xxx.utils.IdMakerUtil.getInstance(JJJ)Lcom/x/utilxxs/IdMakerUtil;
at com.xxx.framework.idgenerator.SnowflakeIdGenerator.&lt;init&gt;(SnowflakeIdGenerator.java:18)
at com.xxx.utils.IdUtil.&lt;clinit&gt;(IdUtil.java:19) at com.xxx.framework.web.interceptor.WebRequestBodyAdvice.afterBodyRead(WebRequestBodyAdvice.java:63)
at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyAdviceChain.afterBodyRead(RequestResponseBodyAdviceChain.java:100)
at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters(AbstractMessageConverterMethodArgumentResolver.java:208)
at 错误分析 java.lang.NoSuchMethodError是一种运行时异常（runtime error），发生于一个方法，在编译的时候是存在的，在程序运行时不存在。java的垃圾处理器（GC）无法回收对象创建时申请的空间，有可能会造成OutOfMemoryError。
在这次报错中，提示了找不到的方法是
com.xxx.utils.IdMakerUtil.getInstance(JJJ)Lcom/xxx/utils/IdMakerUtil;
类全路径是com.xxx.utils.IdMakerUtil，方法名是getInstance，(JJJ)代表该方法有三个参数，发生于com/xxx/utils/IdMakerUtil这个类。
打开本地项目，应用正常启动，请求也能正常放回，不会报NoSuchMethodError。
但是仔细查看本地的IdMakerUtil.getInstance()，发现是个无参方法，和报错提示里使用的三个入参不一样，所以提示了NoSuchMethodError。本地的IdMakerUtil和测试环境的运行jar包里的IdMakerUtil是一样的，那么问题可能出现在调用该方法（IdMakerUtil.getInstance(x,x,x)）的地方，即日志里提示的：
com.xxx.framework.idgenerator.SnowflakeIdGenerator.&lt;init&gt;(SnowflakeIdGenerator.java:18)
仔细对比本地和运行jar包里的SnowflakeIdGenerator这个类，在A依赖包里，发现是一样的。但是，并没有在init初始化（构造方法里）调用IdMakerUtil.getInstance(x,x,x)
本地和运行jar包里的SnowflakeIdGenerator：
代码都一样，但是报错了，重点就是运行jar包里SnowflakeIdGenerator的构造方法里，调用了三个入参的IdMakerUtil.getInstance(x,x,x)，和本地代码执行逻辑不一样。
由此可以推断，运行jar包使用的SnowflakeIdGenerator这个类，不是在A依赖包里的，而是另一个同路径、同名的类（com.xxx.framework.idgenerator.SnowflakeIdGenerator）！涉及到了JVM类加载机制，同路径、同名的类，只能加载一个。
此时，想解决问题得找到实际使用的该SnowflakeIdGenerator类是在哪个jar包里，这时可以通过引入Arthas来查看。Arthas的sc命令，可以用来查看 JVM 已加载的类信息。具体的使用可以见官网。
sc | arthas (aliyun.com)
[arthas@2188]$ sc com.xxx.framework.idgenerator.SnowflakeIdGenerator
com.xxx.framework.idgenerator.SnowflakeIdGenerator
Affect(row-cnt:1) cost in 34 ms." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/29044e0c209cf532ef3eeec3cff6d27c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-28T11:20:50+08:00" />
<meta property="article:modified_time" content="2022-11-28T11:20:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">NoSuchMethodError、NoClassDefFoundError的常见原因和通用解决方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF-toc" style="margin-left:0px;"><a href="#%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF" rel="nofollow">环境信息</a></p> 
<p id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" rel="nofollow">问题描述</a></p> 
<p id="%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90" rel="nofollow">错误分析</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" rel="nofollow">解决方法</a></p> 
<p id="%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0-toc" style="margin-left:0px;"><a href="#%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0" rel="nofollow">常见原因</a></p> 
<p id="1.%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8D%E5%AF%B9%E5%AF%BC%E8%87%B4%E5%BA%94%E7%94%A8%E6%B2%A1%E5%AF%BC%E5%85%A5%E8%AF%A5%E5%8C%85-toc" style="margin-left:40px;"><a href="#1.%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8D%E5%AF%B9%E5%AF%BC%E8%87%B4%E5%BA%94%E7%94%A8%E6%B2%A1%E5%AF%BC%E5%85%A5%E8%AF%A5%E5%8C%85" rel="nofollow">1.第三方包，作用域不对导致应用没导入该包</a></p> 
<p id="2.%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8D%E4%B8%80%E6%A0%B7-toc" style="margin-left:40px;"><a href="#2.%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8D%E4%B8%80%E6%A0%B7" rel="nofollow">2.编译时和运行时使用的版本不一样</a></p> 
<p id="3.JDK%E7%89%88%E6%9C%AC%E4%B8%8D%E4%B8%80%E6%A0%B7-toc" style="margin-left:40px;"><a href="#3.JDK%E7%89%88%E6%9C%AC%E4%B8%8D%E4%B8%80%E6%A0%B7" rel="nofollow">3.JDK版本不一样</a></p> 
<p id="4.%E5%A4%9A%E4%B8%AA%E5%90%8C%E8%B7%AF%E5%BE%84%E3%80%81%E5%90%8C%E5%90%8D%E7%9A%84%E7%B1%BB-toc" style="margin-left:40px;"><a href="#4.%E5%A4%9A%E4%B8%AA%E5%90%8C%E8%B7%AF%E5%BE%84%E3%80%81%E5%90%8C%E5%90%8D%E7%9A%84%E7%B1%BB" rel="nofollow">4.多个同路径、同名的类</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E5%9C%BA%E6%99%AF" rel="nofollow">        1.代码复制场景</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E4%BB%A3%E7%A0%81%E7%A7%BB%E5%8A%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E4%BB%A3%E7%A0%81%E7%A7%BB%E5%8A%A8%E5%9C%BA%E6%99%AF" rel="nofollow">        2.代码移动场景</a></p> 
<p id="%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4-toc" style="margin-left:0px;"><a href="#%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4" rel="nofollow">排查步骤</a></p> 
<p id="%E9%99%84%E5%BD%95-toc" style="margin-left:0px;"><a href="#%E9%99%84%E5%BD%95" rel="nofollow">附录</a></p> 
<p id="NoClassDefFoundError-toc" style="margin-left:40px;"><a href="#NoClassDefFoundError" rel="nofollow">NoClassDefFoundError</a></p> 
<p id="Maven%E4%BB%B2%E8%A3%81%E6%9C%BA%E5%88%B6%EF%BC%9A-toc" style="margin-left:40px;"><a href="#Maven%E4%BB%B2%E8%A3%81%E6%9C%BA%E5%88%B6%EF%BC%9A" rel="nofollow">Maven仲裁机制：</a></p> 
<p id="JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6" rel="nofollow">JVM类加载机制</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF">环境信息</h2> 
<p>        Spring Boot：2.0.8.RELEASE</p> 
<p>        Spring Boot内置的tomcat：tomcat-embed-core 8.5.37</p> 
<h2 id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</h2> 
<p>        测试环境，部署打版之后，应用成功启动。可是在收到部分请求的时候，后端报错了，查看日志，发现出现了java.lang.NoSuchMethodError，具体是：</p> 
<blockquote> 
 <p>Caused by: java.lang.NoSuchMethodError: com.xxx.utils.IdMakerUtil.getInstance(JJJ)Lcom/x/utilxxs/IdMakerUtil;<br>     at com.xxx.framework.idgenerator.SnowflakeIdGenerator.&lt;init&gt;(SnowflakeIdGenerator.java:18)<br>     at com.xxx.utils.IdUtil.&lt;clinit&gt;(IdUtil.java:19)  at com.xxx.framework.web.interceptor.WebRequestBodyAdvice.afterBodyRead(WebRequestBodyAdvice.java:63)<br>     at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyAdviceChain.afterBodyRead(RequestResponseBodyAdviceChain.java:100)<br>     at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters(AbstractMessageConverterMethodArgumentResolver.java:208)<br>     at </p> 
</blockquote> 
<h2 id="%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90">错误分析</h2> 
<p>          java.lang.NoSuchMethodError是一种运行时异常（runtime error），发生于一个方法，在编译的时候是存在的，在程序运行时不存在。java的垃圾处理器（GC）无法回收对象创建时申请的空间，有可能会造成OutOfMemoryError。</p> 
<p>        在这次报错中，提示了找不到的方法是</p> 
<p>com.xxx.utils.IdMakerUtil.getInstance(JJJ)Lcom/xxx/utils/IdMakerUtil;</p> 
<p>类全路径是com.xxx.utils.IdMakerUtil，方法名是getInstance，(JJJ)代表该方法有三个参数，发生于com/xxx/utils/IdMakerUtil这个类。</p> 
<p>        打开本地项目，应用正常启动，请求也能正常放回，不会报NoSuchMethodError。</p> 
<p>但是仔细查看本地的IdMakerUtil.getInstance()，发现是个无参方法，和报错提示里使用的三个入参<strong><span style="color:#fe2c24;">不一样</span></strong>，所以提示了NoSuchMethodError。本地的IdMakerUtil和测试环境的运行jar包里的IdMakerUtil是<span style="color:#fe2c24;"><strong>一样</strong></span>的，那么问题可能出现在调用该方法（IdMakerUtil.getInstance(x,x,x)）的地方，即日志里提示的：</p> 
<p>com.xxx.framework.idgenerator.SnowflakeIdGenerator.&lt;init&gt;(SnowflakeIdGenerator.java:18)</p> 
<p>        仔细对比本地和运行jar包里的SnowflakeIdGenerator这个类，在A依赖包里，发现是<strong>一样</strong>的。但是，并没有在init初始化（构造方法里）调用IdMakerUtil.getInstance(x,x,x)</p> 
<p>        本地和运行jar包里的SnowflakeIdGenerator：</p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/06/4f/BZDnAoKS_o.png" width="900"></p> 
<p>        <img alt="" height="657" src="https://images2.imgbox.com/95/42/ZMFXcVFm_o.png" width="1200"></p> 
<p></p> 
<p>        代码都一样，但是报错了，重点就是运行jar包里SnowflakeIdGenerator的<strong>构造方法</strong>里，调用了三个入参的IdMakerUtil.getInstance(x,x,x)，和本地代码<span style="color:#fe2c24;"><strong>执行逻辑不一样</strong></span>。</p> 
<p>        由此可以推断，运行jar包使用的SnowflakeIdGenerator这个类，不是在A依赖包里的，而是另一个<strong><span style="color:#fe2c24;">同路径、同名</span></strong>的类（com.xxx.framework.idgenerator.SnowflakeIdGenerator）！涉及到了JVM类加载机制，同路径、同名的类，只能加载一个。</p> 
<p>        此时，想解决问题得找到实际使用的该SnowflakeIdGenerator类是在哪个jar包里，这时可以通过引入<strong>Arthas</strong>来查看。Arthas的sc命令，可以用来查看 JVM 已加载的类信息。具体的使用可以见官网。</p> 
<p><a href="https://arthas.aliyun.com/doc/sc.html" rel="nofollow" title="sc | arthas (aliyun.com)">sc | arthas (aliyun.com)</a></p> 
<blockquote> 
 <p>[arthas@2188]$ sc com.xxx.framework.idgenerator.SnowflakeIdGenerator<br> com.xxx.framework.idgenerator.SnowflakeIdGenerator<br> Affect(row-cnt:1) cost in 34 ms.<br> [arthas@2188]$ sc -d com.xxx.framework.idgenerator.SnowflakeIdGenerator<br>  class-info        com.xxx.framework.idgenerator.SnowflakeIdGenerator       <br>  code-source       file:/home/p05_dev/tfb-whole-biz-service-app/tfb-whole-biz-service-app-6.0.1-SNAPSHOT.jar!/BOOT-INF/lib/e-module-2.0.0-SNAPSHOT.jar!/<br>  name              com.xxx.framework.idgenerator.SnowflakeIdGenerator       <br>  isInterface      false<br>  isAnnotation      false                          <br>  isEnum            false                    <br>  isAnonymousClass  false<br>  isArray           false<br>  isLocalClass      false<br>  isMemberClass     false<br>  isPrimitive       false<br>  isSynthetic       false<br>  simple-name       SnowflakeIdGenerator<br>  modifier          public              <br>  annotation             <br>  interfaces             <br>  super-class       +-com.xxx.framework.idgenerator.AbstractIdGenerator      <br>                      +-java.lang.Object<br>  class-loader      +-org.springframework.boot.loader.LaunchedURLClassLoader@20a14b55<br>                      +-sun.misc.Launcher$AppClassLoader@18b4aac2                    <br>                        +-sun.misc.Launcher$ExtClassLoader@149b8519                  <br>  classLoaderHash   20a14b55            </p> 
 <p>Affect(row-cnt:1) cost in 53 ms.<br> [arthas@2188]$ </p> 
</blockquote> 
<p>        可以看到，运行时使用的SnowflakeIdGenerator是在e-module-2.0.0-SNAPSHOT.jar包里，检查本地的代码，该包的源码里没有SnowflakeIdGenerator这个类，查看git历史记录发现，该类被<span style="color:#fe2c24;"><strong>移动位置</strong></span>了，从e-module移动到了A模块。但是e-module包<strong>没有发布</strong>到maven仓库里，测试环境打版的时候使用了旧的包。</p> 
<h2 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">解决方法</h2> 
<p>       发布e-module包到仓库里：mvn clean deploy</p> 
<p>注意要先clean 再 deploy，其他同事应该是没有deploy，或者没先clean直接deploy导致发布失败。</p> 
<p>        备注：公司是使用Jenkins来打版的，只是utils、framework框架基础包仅限于几个人修改，不开放给其他同事，修改了代码之后，需要手动在本地发布jar包到maven仓库。这个也是本次测试环境事故的一个原因。</p> 
<p>        之前一个同事将SnowflakeIdGenerator从e-module包，移动到A包，并删除了构造函数里调用IdMakerUtil.getInstance地方，但是忘了将e-module包deploy到maven仓库，只将A包deploy上去。</p> 
<h2 id="%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0">常见原因</h2> 
<h3 id="1.%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8D%E5%AF%B9%E5%AF%BC%E8%87%B4%E5%BA%94%E7%94%A8%E6%B2%A1%E5%AF%BC%E5%85%A5%E8%AF%A5%E5%8C%85">1.第三方包，作用域不对导致应用没导入该包</h3> 
<p><strong>直接现象</strong>：解压运行时的jar包，<strong>找不到</strong>该方法所在的jar包。找不到class文件。</p> 
<p>该方法位于第三方包内，而maven配置文件里，该包的作用域（scope）是provided时，程序打出的jar包是不包含该包的。</p> 
<p>这里要理解scope里的compile、provided、runtime、test、system的区别</p> 
<p>1.compile：（默认），编译、</p> 
<p>2.provided：和compile很像，但是要求JDK或者应用所在的运行容器（比如tomcat、jetty）中包含该jar包。</p> 
<p>3.runtime：运行时。意味着该jar包在编译期间不需要，但是在运行、测试期间需要。maven会在运行、测试的时候，将该jar包加入classpath里，编译的时候不会。</p> 
<p>4.test：测试时。意味着该jar包只用于执行测试案例（src/test/java）的时候用到，比如测试包如JUnit，或者测试时要用的依赖包如IO包。</p> 
<p>5.system：和provided很像，但是要求我们要手动提供该jar包，而永远不会去从maven仓库里查找该包。</p> 
<p>6.import：用于jar类型（packaging）是pom，而且是在&lt;dependencyManagement&gt;域里。一般用于jar包管理里，用于声明会用到的依赖及其版本，编译、打包的时候不会真正的导入该包。其子包可以直接引入该包而不用指定版本号，这时才会真正的导入该包。</p> 
<h3 id="2.%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8D%E4%B8%80%E6%A0%B7">2.编译时和运行时使用的版本不一样</h3> 
<p><strong>直接现象</strong>：解压运行时的jar包，找得到该方法所在的jar包。查看该jar包里的该方法，发现方法的<strong>参数、返回值等不一样</strong>。class版本不一样。</p> 
<p>该方法所在的jar包，编译期间用的版本和运行时使用的版本不一样。</p> 
<p>常见于公司内部的依赖包代码有更新，可是未发布到maven仓库，或者发布的时候没有先clean导致发布失败，造成线上环境使用的依赖包还是旧的依赖包。应该使用命令：mvn clean deploy部署</p> 
<p>或者依赖里没指定jar包的具体版本号，间接依赖使用了旧的版本。</p> 
<h3 id="3.JDK%E7%89%88%E6%9C%AC%E4%B8%8D%E4%B8%80%E6%A0%B7">3.JDK版本不一样</h3> 
<p><strong>直接现象</strong>：class版本不一样。</p> 
<p>编译和运行使用不同版本的JDK，一般是本地编译的JDK版本比较高，线上环境运行的JDK版本比较低。</p> 
<h3 id="4.%E5%A4%9A%E4%B8%AA%E5%90%8C%E8%B7%AF%E5%BE%84%E3%80%81%E5%90%8C%E5%90%8D%E7%9A%84%E7%B1%BB">4.多个同路径、同名的类</h3> 
<p>直接现象：在提示的类路径（package）、类名里找得到指定的方法，而且方法的参数、返回值等 一模一样，可是还是提示NoSuchMethodError。</p> 
<p>这时候可以换个思路来思考：既然在这个类里的这个方法是存在的，那么是不是运行的程序使用的根本不是该类？！</p> 
<p>常见原因：</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E5%9C%BA%E6%99%AF">        1.代码复制场景</h4> 
<p>比如根据开源版本定制开发，添加了自定义内容，可是类的路径没有变，只是打成了新的jar包名。同时，还引入了开源版本包。JVM<strong>类加载器</strong>对于同一个类只会加载一次，实际加载的类和实际环境有关：Jar包依赖的路径、文件加载顺序等，和操作系统、环境里jar包的具体路径等有关，很难排查。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E4%BB%A3%E7%A0%81%E7%A7%BB%E5%8A%A8%E5%9C%BA%E6%99%AF">        2.代码移动场景</h4> 
<p>比如一个类，原本是在Ajar包里，由于重构、功能调整等原因，移动到了Bjar包里，并且改了方法的参数或返回值。部署的时候，Ajar包没有成功发布、打到运行jar包里，Bjar包成功发布并打到运行jar包里。这时候，Ajar包和Bjar包都存在该类（同名、同路径），只是两个类里的方法不一样。运行的时候，可能因为JVM类加载器加载顺序的不同，先加载了Ajar包里的类，这时候，就会出现NoSuchMethodError异常。</p> 
<p>这种情况，是很难排查的，因为查看本地代码的时候，根据类路径、名称找到的该类是在Bjar包里的（因为A包里的该类已经删除掉，看不到了），而解压运行jar包里的Bjar包，会发现该类里的方法是存在的。而查找问题的人如果不是移动该类的开发人员，是很难知道A包里也可能有该类，运行的时候使用的是A包里的类（这时候，如果没有抛出NoSuchMethodError异常，即没有改方法参数，只是改了里面的逻辑，那么更难意识到这里出现了问题！！！）。</p> 
<h2 id="%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4">排查步骤</h2> 
<p>1.解压运行jar包，查看NoSuchMethodError提示的报错类，看该类是否有该方法（参数也一样）;</p> 
<p>2.如果<strong>没有</strong>该方法（参数也一致），如果该类是<strong>公司内部</strong>开发的类，确认<strong>环境打版用的分支</strong>里是否提示没有的方法。如果有，那么是打版问题，将该类所在的包打版上去（根据实际情况，是手动deploy到maven仓库还是直接Jenkins打版、等等）；</p> 
<p>3.如果<strong>没有</strong>该方法（参数也一致），如果该类是<strong>第三方包</strong>里的类，确认下运行jar包里该类对应的jar包版本是否和本地是一样的（即是否是我们想要的版本）。如果版本不一致，那么分析运行环境里使用到该版本的原因（Maven冲突、仲裁等等，比如间接依赖，可以看附录部分）；</p> 
<p>4.如果<strong>有</strong>该方法（参数也一致），那么查看异常日志调用该方法的地方（如本次事故里的SnowflakeIdGenerator.&lt;init&gt;构造方法），和环境打版用的分支里进行对比。如果代码不一致，那么进入2、3步骤。如果代码一致，但是和实际运行时调用的该方法（如此次的IdMakerUtil.getInstance(JJJ)）不一致，那么可以确定实际运行时用的SnowflakeIdGenerator类和我们代码里的SnowflakeIdGenerator类不是同一个。可以通过Arthas的sc实时监控查看使用的具体信息（参考错误分析里的做法）</p> 
<p></p> 
<h2 id="%E9%99%84%E5%BD%95">附录</h2> 
<h3 id="NoClassDefFoundError">NoClassDefFoundError</h3> 
<blockquote> 
 <p>Caused by: java.lang.NoSuchMethodError: com.xxx.utils.IdMakerUtil.getInstance(JJJ)Lcom/x/utilxxs/IdMakerUtil;<br>     at com.xxx.framework.idgenerator.SnowflakeIdGenerator.&lt;init&gt;(SnowflakeIdGenerator.java:18)<br>     at com.xxx.utils.IdUtil.&lt;clinit&gt;(IdUtil.java:19)               </p> 
</blockquote> 
<p>        分析文章开头的这个错误日志，可以看到执行IdUtil.&lt;clinit&gt;时报错了，即IdUtil类加载失败了。</p> 
<p>        <strong>&lt;clinit&gt;</strong>方法，是类初始化过程中，主要是对静态（static）成员变量、静态语句块（static{}）进行初始化的操作。如果执行失败了，那么类加载、初始化就失败了。JVM里不会有该类，后续代码如果使用到该类，会抛出NoClassDefFoundError异常。</p> 
<p>        所以，第二次访问该接口的时候，会抛出不一样的异常（java.lang.<span style="color:#fe2c24;"><strong>NoClassDefFoundError</strong></span>: <strong>Could not initialize class</strong> com.xxx.framework.utils.IdUtil）：</p> 
<blockquote> 
 <p>org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.NoClassDefFoundError: Could not initialize class com.xxx.framework.utils.IdUtil<br>     at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1006)<br>     ...<br>     at java.lang.Thread.run(Unknown Source)<br> Caused by: java.lang.NoClassDefFoundError: Could not initialize class com.xxx.framework.utils.IdUtil<br>     at com.xxx.interceptor.BizLogRequestBodyHandler.wrapperPubOperUserLogModel(BizLogRequestBodyHandler.java:103)<br>     at com.xxx.interceptor.BizLogRequestBodyHandler.doHandle(BizLogRequestBodyHandler.java:92)<br>     at com.xxx.framework.web.interceptor.WebRequestBodyAdvice.afterBodyRead(WebRequestBodyAdvice.java:63)<br>     at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyAdviceChain.afterBodyRead(RequestResponseBodyAdviceChain.java:100)<br>     ...<br>     at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:991)</p> 
</blockquote> 
<p>        如果遇到了java.lang.NoClassDefFoundError: Could not initialize class这个异常，根据提示初始化（initialize）失败了，要在之前的日志里查找先关的报错日志，看下有没有提示信息。一般是执行static静态域、代码块失败了，要根据具体的日志看下是因为什么失败。</p> 
<h3 id="Maven%E4%BB%B2%E8%A3%81%E6%9C%BA%E5%88%B6%EF%BC%9A">Maven仲裁机制：</h3> 
<p><a href="https://developer.aliyun.com/article/1027746" rel="nofollow" title="安全同学讲Maven间接依赖场景的仲裁机制-阿里云开发者社区 (aliyun.com)">安全同学讲Maven间接依赖场景的仲裁机制-阿里云开发者社区 (aliyun.com)</a></p> 
<blockquote> 
 <p><strong>Maven仲裁机制原则</strong></p> 
 <p><strong>1.依赖竞争时，越靠近主干的越优先。</strong></p> 
 <p><strong>2.单颗树在依赖在竞争时(dependencies)（注意：不是dependencyManagement里的dependencies）：</strong></p> 
 <p><strong>当deep=1，即直接依赖。同级是靠后优先。</strong></p> 
 <p><strong>当deep&gt;1，即间接依赖。同级是靠前优先。</strong></p> 
 <p><strong>3.单颗树在依赖管理在竞争时(注意：是dependencyManagement里的dependencies)是靠前优先的。</strong></p> 
 <p><strong>4.maven里最重要的2个关系，分别是继承关系和依赖关系。我们所有的规律都应该只从这2个关系入手。</strong></p> 
 <p>下图中分别是2个子pom文件（方块代表依赖的节点，A-1 表示A这个节点使用的是1版本，字母代表节点，数字代表版本）。</p> 
 <p>左边这个子pom生成的树依赖了 D-1，D-2和D-5。满足依赖竞争原则1，即越靠近树的左侧越优先的原则，所以D-5会竞争成功。</p> 
 <p>但是B-1和B-2同时都位于树的同一深度，并且深度为1，由于B-2更加靠后，所以B-2会竞争成功。</p> 
 <p>右边的子pom生成的树依赖了 D-1和D-2，并且位于同一深度，但由于D-1和D-2是属于间接依赖的范围，deep大于1，所以是靠前优先，那么也就是D-1会竞争成功。</p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/33/ed/bmPRHFl0_o.png"></p> 
<p></p> 
<h3 id="JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">JVM类加载机制</h3> 
<p><img alt="" height="301" src="https://images2.imgbox.com/4e/7a/z4f4TdVx_o.png" width="349"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f250ba14cb2914688af2dfaae20551a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">YOLOv5_5.0训练自己的数据集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed9d77aadefb42c1e53daf5ee4828696/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安卓简单的应用——天气预报</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>