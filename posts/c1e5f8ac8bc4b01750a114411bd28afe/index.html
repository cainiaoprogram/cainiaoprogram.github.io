<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉搜索树介绍以及实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二叉搜索树介绍以及实现" />
<meta property="og:description" content="二叉树无论是在实际运用还是面试题中，都是一种十分热门的数据结构，而二叉搜索树则是进阶版的二叉树，在map和set中也有应用。
什么是二叉搜索树 二叉搜索树又叫二叉排序树，它可以是一颗空树，又或者是有以下三个特点的树。
若它的左子树不为空，则左子树的所有节点的值都小于根节点的值。若它的右子树不为空，则右子树的所有节点的值都大于根节点的值。它的左右子树也都是二叉搜索树。 因为二叉搜索树具有以上三个特性，因此二叉搜索树的最优搜索次数为 O(log^2) ，最差搜索次数为 O(N)。
此外，中序遍历一个二叉搜索树所得到的结果应该是一个有序的数组。
二叉搜索树的实现 二叉搜索树的查找 从根节点开始查找，若查找的 val 大于根节点的值，则向右子树查找，否则向左子树查找最多查找高度次，走到空还没有找到，就返回nullptr,否则就返回这个节点。 pNode find(const T&amp; val) { pNode cur = Root; if (cur-&gt;_data == val) { return cur; } while (cur != nullptr) { if (val &gt; cur-&gt;_data) { cur = cur-&gt;_right; } else if (val &lt; cur-&gt;_data) { cur = cur-&gt;_left; } else { return cur; } } return nullptr; } 二叉搜索树的插入 二叉树的插入需要找到正确的位置。
val大于当前节点的值就向右子树走val小于当前节点的值就向左子树走直到找到一个空节点就插入 bool insert(T val) { pNode cur = new Node(val); pNode root = Root; if (Root!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c1e5f8ac8bc4b01750a114411bd28afe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T17:31:24+08:00" />
<meta property="article:modified_time" content="2024-01-02T17:31:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉搜索树介绍以及实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        二叉树无论是在实际运用还是面试题中，都是一种十分热门的数据结构，而二叉搜索树则是进阶版的二叉树，在map和set中也有应用。</p> 
<h2>什么是二叉搜索树</h2> 
<p>二叉搜索树又叫二叉排序树，它可以是一颗空树，又或者是有以下三个特点的树。</p> 
<ul><li><strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">若它的左子树不为空，则左子树的所有节点的值都小于根节点的值。</span></span></strong></li><li><strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">若它的右子树不为空，则右子树的所有节点的值都大于根节点的值。</span></span></strong></li><li><strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">它的左右子树也都是二叉搜索树。</span></span></strong></li></ul> 
<p>因为二叉搜索树具有以上三个特性，因此二叉搜索树的最优搜索次数为 O(log^2) ，最差搜索次数为 O(N)。</p> 
<p>此外，<strong>中序遍历一个二叉搜索树所得到的结果应该是一个有序的数组</strong>。</p> 
<h2>二叉搜索树的实现</h2> 
<h4>二叉搜索树的查找</h4> 
<ul><li>从根节点开始查找，若查找的 val 大于根节点的值，则向右子树查找，否则向左子树查找</li><li>最多查找高度次，走到空还没有找到，就返回nullptr,否则就返回这个节点。</li></ul> 
<pre><code class="language-cpp">pNode find(const T&amp; val)
{
	pNode cur = Root;
	if (cur-&gt;_data == val)
	{
		return cur;
	}
	while (cur != nullptr)
	{
		if (val &gt; cur-&gt;_data)
		{
			cur = cur-&gt;_right;
		}
		else if (val &lt; cur-&gt;_data)
		{
			cur = cur-&gt;_left;
		}
		else
		{
			return cur;
		}
	}
	return nullptr;
}</code></pre> 
<h4>二叉搜索树的插入</h4> 
<p> 二叉树的插入需要找到正确的位置。</p> 
<ul><li>val大于当前节点的值就向右子树走</li><li>val小于当前节点的值就向左子树走</li><li>直到找到一个空节点就插入</li></ul> 
<pre><code class="language-cpp">bool insert(T val)
{
	pNode cur = new Node(val);
	pNode root = Root;
	if (Root!=nullptr&amp;&amp;find(val) != nullptr)
	{
		return false;
	}
	if (root == nullptr)
	{
		Root = cur;
		return true;
	}

	while (root != nullptr)
	{
		if (val &gt; root-&gt;_data)
		{
			if (root-&gt;_right == nullptr)
			{
				root-&gt;_right = cur;
				break;
			}
			root = root-&gt;_right;
		}
		else if (val &lt; root-&gt;_data)
		{
			if (root-&gt;_left == nullptr)
			{
				root-&gt;_left = cur;
				break;
			}
			root = root-&gt;_left;
		}
	
	}
	return true;
}</code></pre> 
<h4>二叉搜索树的删除</h4> 
<p>二叉搜索树的删除是最难的，需要分情况说明。</p> 
<ul><li>左子树为空，但右子树不为空</li><li>右子树为空，但左子树不为空</li><li>左右都为空</li><li>左右都不为空</li></ul> 
<p>对于最后一种情况来说，这个节点是一个叶子节点，可以<strong>直接删除</strong>。</p> 
<h5>右为空左不为空</h5> 
<p><img alt="" height="361" src="https://images2.imgbox.com/18/4a/2ochMBWz_o.png" width="605"></p> 
<p><strong>当 cur 节点是父节点的左子树，就需要将父节点的左向量连接在cur节点的左子树上。</strong></p> 
<p><strong>        </strong><img alt="" height="460" src="https://images2.imgbox.com/5a/8d/8Izi8Chh_o.png" width="649"></p> 
<p><strong>反之当cur节点是父节点的右子树，就需要将父节点的右向量连接在cur节点的左子树上。</strong></p> 
<h5><strong>左为空右不为空</strong></h5> 
<p><strong>若cur节点的左子树为空</strong>，且cur节点<strong>是父节点的左子树，</strong>就需要将<strong>父节点的左向量连接在cur节点的右子树</strong>上。</p> 
<p><img alt="" height="485" src="https://images2.imgbox.com/07/11/B3x39al2_o.png" width="638"></p> 
<p>若<strong>cur节点是父节点的右子树</strong>，则需要将<strong>父节点的右向量连接在cur节点的右子树</strong>上。</p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/39/c6/hPFhxGyR_o.png" width="616"></p> 
<h5>左右不为空 </h5> 
<p>若节点的左右子树都不是空树，为了不破坏二叉搜索树的结构，就需要利用一个中间变量(minright)来辅助删除。</p> 
<p>minright应是被删节点的右子树中的最左节点。</p> 
<p>1：若minright是被删节点的右节点。</p> 
<p><img alt="" height="360" src="https://images2.imgbox.com/76/0b/S7DYRBIX_o.png" width="627"></p> 
<p>这种情况下就直接交换cur和minright 的值，然后让cur 的右指针指向 minright 的右节点。</p> 
<p>2：minright不是被删节点的右节点。</p> 
<p><img alt="" height="458" src="https://images2.imgbox.com/e4/3d/sWmIDMSp_o.png" width="591"> </p> 
<p>这种情况下，就需要记录 minright 的 parent 节点，让 parent 的左指针指向 minright 的右节点。</p> 
<p>然后再交换 cur 和 minright 的值，再删除 minright 的节点。</p> 
<pre><code class="language-cpp">	bool erase(T val)
	{
		pNode cur = Root;
		pNode parent = nullptr;
		while (cur != nullptr)
		{
			//大于向右走
			if (val &gt; cur-&gt;_data)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			//小于向左走
			else if (val &lt; cur-&gt;_data)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			//等于则开始消除
			else
			{
				if (cur-&gt;_right == nullptr)
				{
					//如果是根节点，就直接拿左节点当根
					if (cur == Root)
					{
						Root = cur-&gt;_left;

					}
					//否则就正常进行
					else
					{
						//如果cur是parent的右节点，就直接拿cur的左节点和parent的右节点相连
						if (cur == parent-&gt;_right)
						{
							parent-&gt;_right = cur-&gt;_left;
						}
						//如果cur是parent的左节点，就拿cur的左节点和parent的左节点相连
						else if (cur == parent-&gt;_left)
						{
							parent-&gt;_left = cur-&gt;_left;
						}
					}
					delete cur;
				}
				else if (cur-&gt;_left == nullptr)
				{
					//如果是根节点
					if (cur == Root)
					{
						Root = cur-&gt;_right;
					}
					//否则就正常进行
					else
					{
						//如果cur是parent的右节点，就直接拿cur的左节点和parent的右节点相连
						if (cur == parent-&gt;_right)
						{
							parent-&gt;_right = cur-&gt;_right;
						}
						//如果cur是parent的左节点，就拿cur的左节点和parent的左节点相连
						else if (cur == parent-&gt;_left)
						{
							parent-&gt;_left = cur-&gt;_right;
						}
					}
					delete cur;
				}
				//左右都不为空
				else
				{
					pNode minright = cur-&gt;_right;
					parent = cur;
					while (minright-&gt;_left)
					{
						parent = minright;
						minright = minright-&gt;_left;
					}
					cur-&gt;_data = minright-&gt;_data;
					if (minright == parent-&gt;_right)
					{
						parent-&gt;_right = minright-&gt;_right;
					}
					else
					{
						parent-&gt;_left = minright-&gt;_right;
					}
					delete minright;
				}
				return true;
			}
			
		}
		return false;
	}</code></pre> 
<p> </p> 
<h2>完整代码</h2> 
<pre><code class="language-cpp">using namespace std;
template&lt;class T&gt;
class BSTNode {
public:
	BSTNode(T data)
		:_left(nullptr),_right(nullptr),_data(data)
	{
	}
	T _data;
	BSTNode&lt;T&gt;* _left;
	BSTNode&lt;T&gt;* _right;
};

template&lt;class T&gt;
class BSTree {
	typedef BSTNode&lt;T&gt; Node;
	typedef Node* pNode;
public:
	BSTree()
		:Root(nullptr)
	{}

	~BSTree()
	{
		destroy(Root);
	}
	void destroy(pNode root)
	{
		if (root-&gt;_left != nullptr)
		{
			destroy(root-&gt;_left);
		}
		if (root-&gt;_right != nullptr)
		{
			destroy(root-&gt;_right);
		}
		delete(root);
	}

	pNode find(const T&amp; val)
	{
		pNode cur = Root;
		if (cur-&gt;_data == val)
		{
			return cur;
		}
		while (cur != nullptr)
		{
			if (val &gt; cur-&gt;_data)
			{
				cur = cur-&gt;_right;
			}
			else if (val &lt; cur-&gt;_data)
			{
				cur = cur-&gt;_left;
			}
			else
			{
				return cur;
			}
		}
		return nullptr;
	}
	bool erase(T val)
	{
		pNode cur = Root;
		pNode parent = nullptr;
		while (cur != nullptr)
		{
			//大于向右走
			if (val &gt; cur-&gt;_data)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			//小于向左走
			else if (val &lt; cur-&gt;_data)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			//等于则开始消除
			else
			{
				if (cur-&gt;_right == nullptr)
				{
					//如果是根节点，就直接拿左节点当根
					if (cur == Root)
					{
						Root = cur-&gt;_left;

					}
					//否则就正常进行
					else
					{
						//如果cur是parent的右节点，就直接拿cur的左节点和parent的右节点相连
						if (cur == parent-&gt;_right)
						{
							parent-&gt;_right = cur-&gt;_left;
						}
						//如果cur是parent的左节点，就拿cur的左节点和parent的左节点相连
						else if (cur == parent-&gt;_left)
						{
							parent-&gt;_left = cur-&gt;_left;
						}
					}
					delete cur;
				}
				else if (cur-&gt;_left == nullptr)
				{
					//如果是根节点
					if (cur == Root)
					{
						Root = cur-&gt;_right;
					}
					//否则就正常进行
					else
					{
						//如果cur是parent的右节点，就直接拿cur的左节点和parent的右节点相连
						if (cur == parent-&gt;_right)
						{
							parent-&gt;_right = cur-&gt;_right;
						}
						//如果cur是parent的左节点，就拿cur的左节点和parent的左节点相连
						else if (cur == parent-&gt;_left)
						{
							parent-&gt;_left = cur-&gt;_right;
						}
					}
					delete cur;
				}
				//左右都不为空
				else
				{
					pNode minright = cur-&gt;_right;
					parent = cur;
					while (minright-&gt;_left)
					{
						parent = minright;
						minright = minright-&gt;_left;
					}
					cur-&gt;_data = minright-&gt;_data;
					if (minright == parent-&gt;_right)
					{
						parent-&gt;_right = minright-&gt;_right;
					}
					else
					{
						parent-&gt;_left = minright-&gt;_right;
					}
					delete minright;
				}
				return true;
			}
			
		}
		return false;
	}
	bool insert(T val)
	{
		pNode cur = new Node(val);
		pNode root = Root;
		if (Root!=nullptr&amp;&amp;find(val) != nullptr)
		{
			return false;
		}
		if (root == nullptr)
		{
			Root = cur;
			return true;
		}

		while (root != nullptr)
		{
			if (val &gt; root-&gt;_data)
			{
				if (root-&gt;_right == nullptr)
				{
					root-&gt;_right = cur;
					break;
				}
				root = root-&gt;_right;
			}
			else if (val &lt; root-&gt;_data)
			{
				if (root-&gt;_left == nullptr)
				{
					root-&gt;_left = cur;
					break;
				}
				root = root-&gt;_left;
			}
		
		}
		return true;
	}
private:
	pNode Root;
};</code></pre> 
<h2>总结</h2> 
<p>二叉搜索树是一种进阶版的二叉树结构，实际应用中十分广泛，面试题中经常出现，而在二叉搜索树之上还有AVL树和红黑树，不过这些都是后话了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8edcf9cd1239ae58bb19a032c7eafbd4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Django(三)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/daa02ff1dae5df9c3c295970fba6a3cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ros2基础学习13 DDS 通信得学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>