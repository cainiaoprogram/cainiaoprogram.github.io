<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RFID防碰撞算法的复习（仅供自己复习回忆，大家参考） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RFID防碰撞算法的复习（仅供自己复习回忆，大家参考）" />
<meta property="og:description" content="RFID防碰撞算法算法复习 书本上的： 1：基于ALOHA的防冲突算法 纯ALOHA算法
阅读器广播识别命令给标签，标签收到阅读器发送命令后，立即以定长的信息包形式向阅读器发送其标识符号。
没有冲突：阅读器正确识别标签识别符并发送确认信息
发生冲突：阅读器向标签发送冲突确认
标签收到成功识别的确认信息，则不再发送标识符
未收到则将会随即独立的等待一段时间后再重新发送标识符，直到成功发送为止
信道利用率：18.4%
时隙ALOHA算法（S-ALOHA）
控制时隙的同步
将纯ALOHA算法的时间分为若干个时隙，每个时隙大于或等于标签识别符发送的时间长度，每个标签只能在时隙开始时刻发送标识符
信道利用率：36.8%
基于帧的时隙ALOHA算法（FSA）
三种类型的时隙：空闲时隙 单时隙 冲突时隙
在S-ALOHA算法的基础上，将若干个时隙组成为一帧，阅读器按帧为单元进行识别。
每一帧开始时，阅读器广播帧的长度f，指明下一个帧包含的时隙个数，并激活其识别区域中的所有标签。每个标签在接受到帧长f之后随机独立地在0--(f-1)中选择一个整数作为自己发送标识符的时隙序列号，并将这个时隙序列号寄存在SN中。在下一帧的每一个时隙中，阅读器通过时隙开始命令启动一个新的时隙，如果标签SN的值等于0则立即发送标识符号，如果不等于0则将其SN值减1而不发送标识符。
对标签而言：
标识符发送成功：标签进入休眠状态
冲突：进入等待状态，在下一帧中重新选择一个时隙发送标签符
信道利用率：当帧长的长度等于阅读器场内未识别标签的数目时，36.8%
动态帧时隙ALOHA算法（DFSA）
动态帧时隙ALOHA算法动态地调整帧长度，在每帧结束后，根据上一帧的反馈情况检测碰撞时隙数，单时隙数和空闲时隙数来估计当前未被正确识别的电子标签数目，然后选择最佳的下一帧的长度，把它的帧长作为下一轮识别的帧长。
2：基于二进制树的防冲突算法 按照递归的方式将冲突的标签集合划分为两个子集，直到集合中只剩下一个标签为止
划分子集合的算法：
随机二进制树算法：标签随机选择所属的集合
查询二进制树算法：按照标签的标识符划分子集
基于随机二进制树的防冲突算法
每个标签需要维持一个计数器，计数器初始值为0。在每个时隙开始时，如果标签的计数器为0则立即发送自己的标识符号，否则该时隙不响应。标签识别成功，进入沉默状态，每个时隙结束时阅读器会将接收到的时隙状态反馈给标签，场内的标签根据结束时阅读器反的结果对自己维持的计数器进行调整。
（1）：冲突时隙：参与响应的标签从0/1中随机选择一个，将其加到自己的计数器上；没有参与的标签计数器加1。由此可以将冲突的标签分为两个集合。
（2）：没有冲突：
单时隙，成功识别，进入沉默状态
没有被识别的标签自己减1
基于查询二进制树的防冲突算法
无状态协议，标签只需要根据阅读器广播的标识符前缀作比较，标签内部不需要标签维持任何状态。阅读器维持一个二进制前缀，初始值为0。每个时隙开始时，阅读器广播二进制前缀，标签将自己的标识符号前几位与此二进制前缀进行比较，相同则发送标识符号。否则，保持沉默。阅读器检测到冲突则在下次查询中将原来的二进制前缀后面增加0/1，重新查询。
3：轮训机制（看标签是否丢失） 基本的轮训机制：
阅读器根据查询列表逐个广播每一个标签的标识符号来检查此标签是否存在与阅读器的阅读范围内。阅读器每广播一个标识符号后就会等待一段时间，如果收到目标标签的确认则证明此标签存在，否则则认为该标签丢失。
这个基本轮训机制存在很大的缺陷：首先就是此机制与EPC C1G2标准中的时隙ALOHA协议不兼容，难以被目前的商用阅读器采用。其次就是当标签规模较大时，标签识别号的位数就会增加，则会导致整体的扫描时间急剧上升，降低了系统轮询的效率。
基于时隙ALOHA协议的轮询机制：
在每一轮中阅读器广播一个随机数r，每个被激活的标签接收到r后随即结合本地的标识符ID进行散列操作，计算出伪随机数s作为选定的时隙序列号。上述的“伪随机性”意味着，对于任一标签，一旦阅读器广播的数值r以及帧的长度f确定下来，该标签在帧中选择的时隙位置被即被确定，那么在这中情况下，阅读器在实施扫描前，可以根据指定的标签集合中的标签ID计算在下一帧中每个时隙的期望状态，那么期望状态和实际状态会存在不一致的情况：（1）期望为单时隙但实际为空时隙，则表明对应于该单时隙的标签丢失；（2）期望为冲突时隙但是实际为空时隙，则表明碰撞时隙全部丢失；（3）若观察到的时隙状态和预期的时隙状态一致，均为冲突时隙，则阅读器无法判断是否有标签丢失。（导致假阳性误判）
1：基准协议
基准协议排除传输过程中标签之间的冲突，并减少标签返回时发送的比特数。阅读器发送一个标签的标识符号，对应标签如果存在则返回一个较短的响应。
2：两阶段协议（TPP）
两段协议极大地减少了需要传输的标签的ID数目。它被分为两个阶段：帧阶段和轮询阶段。
在帧阶段，利用基于帧的时隙ALOHA协议来获得标签的响应。但是只能利用单时隙来判断是否丢失。、
在轮询阶段，执行基准协议进行确认是否丢失标签，自然存在假阳性误判。
3：带标签移除机制的两段协议（TPP/TR）
分为帧阶段和轮询阶段。
帧阶段，阅读器首先像TPP协议那样计算标签映射到对应时隙的情况，对于碰撞时隙（k个碰撞），阅读器随机的移除k-1个标签，让当前的碰撞时隙变为单时隙。对于被移除的标签将会在下一阶段来确认其是否存在。
4：冲突敏感的标签移除三段协议（TPP/CSTR）
此协议分为三个阶段：第一个轮询阶段、帧阶段和第二个轮询阶段。
第一个轮询阶段，阅读器根据标签的标识符号计算标签对应的时隙，对于碰撞时隙k（k&gt;=2），阅读器随机地移除其中的k-2个标签，留下两个标签，对于被移除的标签将在改轮询阶段被确认是否存在，存在的标签给阅读器发送一个短响应。
在帧阶段，标签发送长的响应（区分于单时隙和碰撞时隙）。如果期望为单时隙但是实际为空时隙就丢失，但如果期望为冲突但是实际为空闲时隙就两个都丢失。如果冲突时隙中阅读器只接收到一个标签的响应，则进入第二轮询阶段。
第二轮询阶段，阅读器依次广播这两个ID确认其对应的标签是否存在。
论文上的： 李晓武： 比特时隙ALOHA算法（BSA）
在正式传输标签ID号前需要标签先发送一个时隙预定序列，通过阅读器接收到的预定序列，阅读器可一直打哪些时隙是空闲的或者被预定的，碰撞时隙会被记为“x”
算法步骤：
（1）：阅读器发送查询命令，信号区里的所有标签先生成一个随机数，根据该随机数生成一个随机预定序列，并发送给阅读器
（2）：阅读器收到一个时隙预定序列，根据该序列的碰撞比特
随机后识别现象（RLI）：标签选择了靠后的时隙进行通讯，但是等不到此通讯时隙就要离开阅读区域了，解决需要先来先服务策略，但是标签识别有随机性，这种特性是在共享信道的时分多路访问控制的无线通信网络中是不能改变的，所以实际上标签本质上是不能够实现先来先服务的，但是我们可以考虑对信号区的标签进行顺序化分组（分组操作）,然后在标签组顺序化分组的基础上实现标签组的先来先服务机制
标签移动RFID系统---TMRS（Tag Movement RFID Systems）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/37161215105b508be1453e49ebe9d96b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-18T19:59:01+08:00" />
<meta property="article:modified_time" content="2022-03-18T19:59:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RFID防碰撞算法的复习（仅供自己复习回忆，大家参考）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>RFID防碰撞算法算法复习</h2> 
<h3>书本上的：</h3> 
<hr> 
<p></p> 
<h4>1：基于ALOHA的防冲突算法</h4> 
<p></p> 
<p>纯ALOHA算法</p> 
<p>阅读器广播识别命令给标签，标签收到阅读器发送命令后，立即以定长的信息包形式向阅读器发送其标识符号。</p> 
<p>没有冲突：阅读器正确识别标签识别符并发送确认信息</p> 
<p>发生冲突：阅读器向标签发送冲突确认</p> 
<p>标签收到成功识别的确认信息，则不再发送标识符</p> 
<p>未收到则将会随即独立的等待一段时间后再重新发送标识符，直到成功发送为止</p> 
<p>信道利用率：18.4%</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/57/83/MhJC0Lg0_o.png"></p> 
<p></p> 
<p>时隙ALOHA算法（S-ALOHA）</p> 
<p>控制时隙的同步</p> 
<p>将纯ALOHA算法的时间分为若干个时隙，每个时隙大于或等于标签识别符发送的时间长度，每个标签只能在时隙开始时刻发送标识符</p> 
<p>信道利用率：36.8%</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/72/54/RKJvorPg_o.png"></p> 
<p></p> 
<p>基于帧的时隙ALOHA算法（FSA）</p> 
<p>三种类型的时隙：空闲时隙 单时隙 冲突时隙</p> 
<p>在S-ALOHA算法的基础上，将若干个时隙组成为一帧，阅读器按帧为单元进行识别。</p> 
<p>每一帧开始时，阅读器广播帧的长度f，指明下一个帧包含的时隙个数，并激活其识别区域中的所有标签。每个标签在接受到帧长f之后随机独立地在0--(f-1)中选择一个整数作为自己发送标识符的时隙序列号，并将这个时隙序列号寄存在SN中。在下一帧的每一个时隙中，阅读器通过时隙开始命令启动一个新的时隙，如果标签SN的值等于0则立即发送标识符号，如果不等于0则将其SN值减1而不发送标识符。</p> 
<p>对标签而言：</p> 
<p>标识符发送成功：标签进入休眠状态</p> 
<p>冲突：进入等待状态，在下一帧中重新选择一个时隙发送标签符</p> 
<p>信道利用率：当帧长的长度等于阅读器场内未识别标签的数目时，36.8%</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9f/90/RHb3Jimb_o.png">动态帧时隙ALOHA算法（DFSA）</p> 
<p>动态帧时隙ALOHA算法动态地调整帧长度，在每帧结束后，根据上一帧的反馈情况检测碰撞时隙数，单时隙数和空闲时隙数来估计当前未被正确识别的电子标签数目，然后选择最佳的下一帧的长度，把它的帧长作为下一轮识别的帧长。</p> 
<hr> 
<h4>2：基于二进制树的防冲突算法</h4> 
<p>按照递归的方式将冲突的标签集合划分为两个子集，直到集合中只剩下一个标签为止</p> 
<p>划分子集合的算法：</p> 
<p>随机二进制树算法：标签随机选择所属的集合</p> 
<p>查询二进制树算法：按照标签的标识符划分子集</p> 
<p></p> 
<p>基于随机二进制树的防冲突算法</p> 
<p>每个标签需要维持一个计数器，计数器初始值为0。在每个时隙开始时，如果标签的计数器为0则立即发送自己的标识符号，否则该时隙不响应。标签识别成功，进入沉默状态，每个时隙结束时阅读器会将接收到的时隙状态反馈给标签，场内的标签根据结束时阅读器反的结果对自己维持的计数器进行调整。</p> 
<p>（1）：冲突时隙：参与响应的标签从0/1中随机选择一个，将其加到自己的计数器上；没有参与的标签计数器加1。由此可以将冲突的标签分为两个集合。</p> 
<p>（2）：没有冲突：</p> 
<p>单时隙，成功识别，进入沉默状态</p> 
<p>没有被识别的标签自己减1</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2f/76/SK6yWboz_o.png"></p> 
<p></p> 
<p></p> 
<p>基于查询二进制树的防冲突算法</p> 
<p>无状态协议，标签只需要根据阅读器广播的标识符前缀作比较，标签内部不需要标签维持任何状态。阅读器维持一个二进制前缀，初始值为0。每个时隙开始时，阅读器广播二进制前缀，标签将自己的标识符号前几位与此二进制前缀进行比较，相同则发送标识符号。否则，保持沉默。阅读器检测到冲突则在下次查询中将原来的二进制前缀后面增加0/1，重新查询。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/99/bc/J1UFboQ5_o.png"></p> 
<h4>3：轮训机制（看标签是否丢失）</h4> 
<p>基本的轮训机制：</p> 
<p>阅读器根据查询列表逐个广播每一个标签的标识符号来检查此标签是否存在与阅读器的阅读范围内。阅读器每广播一个标识符号后就会等待一段时间，如果收到目标标签的确认则证明此标签存在，否则则认为该标签丢失。</p> 
<p>这个基本轮训机制存在很大的缺陷：首先就是此机制与EPC C1G2标准中的时隙ALOHA协议不兼容，难以被目前的商用阅读器采用。其次就是当标签规模较大时，标签识别号的位数就会增加，则会导致整体的扫描时间急剧上升，降低了系统轮询的效率。</p> 
<p></p> 
<p>基于时隙ALOHA协议的轮询机制：</p> 
<p>在每一轮中阅读器广播一个随机数r，每个被激活的标签接收到r后随即结合本地的标识符ID进行散列操作，计算出伪随机数s作为选定的时隙序列号。上述的“伪随机性”意味着，对于任一标签，一旦阅读器广播的数值r以及帧的长度f确定下来，该标签在帧中选择的时隙位置被即被确定，那么在这中情况下，阅读器在实施扫描前，可以根据指定的标签集合中的标签ID计算在下一帧中每个时隙的期望状态，那么期望状态和实际状态会存在不一致的情况：（1）期望为单时隙但实际为空时隙，则表明对应于该单时隙的标签丢失；（2）期望为冲突时隙但是实际为空时隙，则表明碰撞时隙全部丢失；（3）若观察到的时隙状态和预期的时隙状态一致，均为冲突时隙，则阅读器无法判断是否有标签丢失。（导致假阳性误判）</p> 
<p></p> 
<p>1：基准协议</p> 
<p>基准协议排除传输过程中标签之间的冲突，并减少标签返回时发送的比特数。阅读器发送一个标签的标识符号，对应标签如果存在则返回一个较短的响应。</p> 
<p>2：两阶段协议（TPP）</p> 
<p>两段协议极大地减少了需要传输的标签的ID数目。它被分为两个阶段：帧阶段和轮询阶段。</p> 
<p>在帧阶段，利用基于帧的时隙ALOHA协议来获得标签的响应。但是只能利用单时隙来判断是否丢失。、</p> 
<p>在轮询阶段，执行基准协议进行确认是否丢失标签，自然存在假阳性误判。</p> 
<p>3：带标签移除机制的两段协议（TPP/TR）</p> 
<p>分为帧阶段和轮询阶段。</p> 
<p>帧阶段，阅读器首先像TPP协议那样计算标签映射到对应时隙的情况，对于碰撞时隙（k个碰撞），阅读器随机的移除k-1个标签，让当前的碰撞时隙变为单时隙。对于被移除的标签将会在下一阶段来确认其是否存在。</p> 
<p>4：冲突敏感的标签移除三段协议（TPP/CSTR）</p> 
<p>此协议分为三个阶段：第一个轮询阶段、帧阶段和第二个轮询阶段。</p> 
<p>第一个轮询阶段，阅读器根据标签的标识符号计算标签对应的时隙，对于碰撞时隙k（k&gt;=2），阅读器随机地移除其中的k-2个标签，留下两个标签，对于被移除的标签将在改轮询阶段被确认是否存在，存在的标签给阅读器发送一个短响应。</p> 
<p>在帧阶段，标签发送长的响应（区分于单时隙和碰撞时隙）。如果期望为单时隙但是实际为空时隙就丢失，但如果期望为冲突但是实际为空闲时隙就两个都丢失。如果冲突时隙中阅读器只接收到一个标签的响应，则进入第二轮询阶段。</p> 
<p>第二轮询阶段，阅读器依次广播这两个ID确认其对应的标签是否存在。</p> 
<hr> 
<hr> 
<h3>论文上的：</h3> 
<p></p> 
<h4>李晓武：</h4> 
<p>比特时隙ALOHA算法（BSA）</p> 
<p>在正式传输标签ID号前需要标签先发送一个时隙预定序列，通过阅读器接收到的预定序列，阅读器可一直打哪些时隙是空闲的或者被预定的，碰撞时隙会被记为“x”</p> 
<p>算法步骤：</p> 
<p>（1）：阅读器发送查询命令，信号区里的所有标签先生成一个随机数，根据该随机数生成一个随机预定序列，并发送给阅读器</p> 
<p>（2）：阅读器收到一个时隙预定序列，根据该序列的碰撞比特</p> 
<p></p> 
<p>随机后识别现象（RLI）：标签选择了靠后的时隙进行通讯，但是等不到此通讯时隙就要离开阅读区域了，解决需要先来先服务策略，但是标签识别有随机性，这种特性是在共享信道的时分多路访问控制的无线通信网络中是不能改变的，所以实际上标签本质上是不能够实现先来先服务的，但是我们可以考虑对信号区的标签进行顺序化分组（分组操作）,然后在标签组顺序化分组的基础上实现标签组的先来先服务机制</p> 
<p>标签移动RFID系统---TMRS（Tag Movement RFID Systems）</p> 
<p></p> 
<p>标签组顺序化策略</p> 
<p>在标签的识别过程中每隔一段时间给进入信号区的标签一个相同的顺序号，这个操作为标签的分组操作，实现了标签组的序列化TGS。这种标签分组操作得到的标签组被叫做时间组或者标签组，分组操作后的标签会拥有顺序号SN被称为时间组顺序号TGSN，分组操作的时间间隔叫做标签组顺序化周期PTGS</p> 
<p>基于队列的标签组顺序化和基于循环队列的标签组序列化（此处就是一个简单的数据结构的知识）</p> 
<p>（1）：队列</p> 
<p>（2）：循环队列</p> 
<p>标签的先来先服务策略---FIFS（first-come first-service）</p> 
<p>标签组的顺序化为先来先服务提供基础，分组后只有最早时间组的标签才能响应阅读器的命令</p> 
<p>每次帧循环有两种结果：</p> 
<p>（1）：全部识别，就下一组，对队头指针加1</p> 
<p>（2）：没有全部识别，队头指针不变</p> 
<hr> 
<p></p> 
<h4>杨林（全）：</h4> 
<p>纯ALOHA（PA）、时隙ALOHA（SA）、帧时隙ALOHA（FSA）、动态帧时隙ALOHA（DFSA）、分组动态帧时隙ALOHA（GDFSA）</p> 
<p>吞吐率：单位时间内成功传送信息的标签数</p> 
<p></p> 
<p>去空闲时隙ALOHA算法（CIFSA）</p> 
<p>Cancel Idle Framed Slotted ALOHA</p> 
<p>基于预约思想的改进算法 ，使用BSA算法可以避免协议在识别过程中产生空闲时隙，在识别标签之前，标签会根据预定义的时隙修改自己随机所选的通讯时隙，将空闲时隙屏蔽掉</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6a/82/lV2vEo0A_o.png"></p> 
<p></p> 
<p>基于先来先服务的去空闲时隙ALOHA算法（FCFS-CIFSA）</p> 
<p>阅读器会进行分组序列化（和CIFSA的区别），标签在收到阅读器的序列化命令后会自己随机选择一个时隙进行预约（数量为一组里面的数量），标签反馈预约时隙信息给到阅读器，阅读器检测收到标签返回的预约序列，进行比对，只要有1，0同时出现的比特位就成为选中位，这样即可计算出空闲时隙的数目。然后阅读起发送包含检测结果的比特序列作为参数的Adjust调整命令，标签根据命令去掉空闲时隙。</p> 
<hr> 
<h3>小结一下：</h3> 
<p>目前为止我们接触到的算法从基础到复杂就是：</p> 
<p>纯ALOHA（PA）</p> 
<p>时隙ALOHA（SA）</p> 
<p>帧时隙ALOHA（FSA）</p> 
<p>动态帧时隙ALOHA（DFSA）</p> 
<p>分组动态帧时隙ALOHA（GDFSA）</p> 
<p>去空闲时隙ALOHA（CIFSA）</p> 
<p>基于先来先服务的去空闲时隙ALOHA（FCFS-CIFSA）</p> 
<hr> 
<p></p> 
<h4>张小红：</h4> 
<p>分组自适应分配时隙的RFID防碰撞算法（GAAS）</p> 
<p>首先让阅读器对标签随机所选的时隙进行扫描统计（估计标签数量---vogt算法估计标签），并将其发送给每一个标签，标签再进行相应地时隙调整，使阅读器跳过空闲时隙和碰撞时隙（时隙预约），自适应地分配有效时隙，进而对标签进行快速识别，当未识别标签较少时，采用动态帧时隙策略进行识别，当未识别标签比较大时，算法采用分组以及动态调整帧长结合（分组、动态调整帧长）等策略，以减少时隙处理时间。（总结就是：首先估计标签数量，然后分组、动态调整帧长、时隙预约以及自适应分配时隙等策略对标签进行识别）</p> 
<p>防碰撞算法可以被分为四类：空分多路、频分多路、码分多路和时分多路法，主要采用时分多路。时分多路中最常用的就是基于二进制树的确定型算法还有基于ALOHA时隙的统计型算法。</p> 
<p>此论文中公式的推导和杨林的较为类似。</p> 
<p>RFID系统的吞吐率是指阅读器在一个识别帧长的时间内成功传输信息的标签数目所占的比例</p> 
<p>当标签数量n远大于1，并且n接近于帧长L时，系统的吞吐率达到最大。</p> 
<p>标签分组原理：n=354是将标签分为一组或者两组的临界值，为了使系统保持较高的吞吐率效率，未识别的标签数n不能大于354，当n大于354时，需要对未识别的标签进行分组。</p> 
<p></p> 
<p>协议流程：</p> 
<p>在进行标签识别前，首先进行时隙扫描操作，记录下标签所预约时隙的情况，然后再标签识别阶段让阅读器跳过碰撞时隙和空闲时隙，而直接分配有效实习，对成功预约的时隙直接进行识别，从而提高了时隙的利用率</p> 
<p>跳过碰撞时隙和空闲时隙的方法：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f8/b2/UOKsEHfs_o.png"></p> 
<p></p> 
<p></p> 
<p>预约时隙序列传送到阅读器之后，阅读器返回一个Slots数组（即标记值），标签根据数组进行预约时隙的调整</p> 
<p>标签1,7碰撞，则将他们的时隙号改为0，不参与本次的通讯。</p> 
<p>2号标签选择在2时隙进行通讯，但是因为Slot数组中2号数组元素前所有元素总和为-1，所以2号标签调整为2-1=1时隙进行通讯。</p> 
<p>同理，3号标签预约3时隙进行通讯，但是由于3号数组前所有元素纵总和为-1，所以3号标签调整为3-1=2时隙和阅读器进行通讯。</p> 
<p>6号标签原本预约的是6时隙，6号数组前所有元素总和为-3，所以6号标签预约时隙号改为3时隙。</p> 
<p>最终调整结果如下，去掉了空闲时隙和碰撞时隙：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0a/79/lAtapMkC_o.png"></p> 
<p></p> 
<hr> 
<p></p> 
<h4>董辉</h4> 
<p>基于标签分组先来先服务的自适应帧时隙ALOHA防碰撞算法（TG-FCFS ADFSA）</p> 
<p>该算法通过对标签分组和先来先服务及帧时隙预约策略，自适应分配成功时隙来快速识别标签，极大提高了RFID系统的性能</p> 
<p>算法实现步骤‘：</p> 
<p>（1）首先，标签数量估计</p> 
<p>然后根据情况进行分组序列化：&lt;=355，用动态帧时隙；&gt;=356使用分组序列化</p> 
<p>（2）判断当前组标签是否识别完毕</p> 
<p>若识别完毕则进行下一组识别，若未识别完毕就当前组的识别</p> 
<p>（3）帧时隙分配</p> 
<p>（4）标签识别</p> 
<p>只有拥有最早时间序列号SN=header的标签才可以响应，识别一组之后才进行下一组的识别</p> 
<p></p> 
<p>**注释一下：这个都为本人自己学习时候做的笔记，就是仅供自己学习和回忆的，如果大家发现有什么问题可以直接在下面告诉我，谢谢大家。还有，如果以上内容有什么侵犯版权或者是不能发布的地方也请及时告诉我，我会及时删除。最后祝大家学习路上永远顺利！**</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4268717291f9859d5e5ea96805198bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小猫爪：S32K3学习笔记13-S32K3之CMU</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/23c60f636933050f3671d3ae6c1eaefd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机中的中断处理流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>