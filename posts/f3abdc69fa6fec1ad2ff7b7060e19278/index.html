<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>类似携程,飞猪机票列表滚动的日期带价格 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="类似携程,飞猪机票列表滚动的日期带价格" />
<meta property="og:description" content="近期在优化我们公司的机票查询的价格日历(跟携程,飞猪的机票列表类似),之前是将所有切换的日期全部展示在网页中,由于默认查询日期是一年,会导致页面上存在大量的&lt;li&gt;,假如哪天产品要求日期默认是10年呢,估计页面要卡死了.
优化结果先看下最终的效果图:
可以看到以下两点:
1.不管怎么滚动,下面的&lt;li&gt;数量永远是固定的,不会随着滚动日期的增加 而累加&lt;li&gt;的数量,大大提高了页面的性能
2.点击了日期后,请求当天的价格,不替换&lt;li&gt;的情况下将&#34;查看价格&#34;赋值为具体的金额
技术支持:
对日期的处理主要使用的是moment.js
好了话不多说,上代码:
首先对日期做处理,设置了初始日期和截止日期,会返回这两个日期之间所有的日期,另外还会补齐已经过期的时间,和不可选择的时间,如果用户设置了当前日期,也会有标识出来,具体代码如下(下面代码要使用moment.js):
// 只负责处理日期,不负责处理业务 /*返回某时间段的所有日期数据，并格式化，并根据是否今天还是明天还是后天加了classname*/ var dateJson = [] function Calendar() { this.settings = { startDate: &#39;2019-05-10&#39;, // 开始时间 endDate: &#39;2019-10-15&#39;,// 结束时间 dateJson: dateJson, // 日期上的标识数据，class名字要和这个标识字段一摸一样，例如json里面的“折”是discount,那么css名字也叫.discount defaultSelectDate: [&#39;2019-07-02&#39;, &#39;2019-07-09&#39;] // 选中的日期 } } Calendar.prototype.init = function (opt) { $.extend(this.settings, opt); return (this.getAllDate(this.settings.startDate, this.settings.endDate)); } Calendar.prototype.pushTag = function (yearMonthDay) { var tags = {}; for (var i = 0; i &lt; this.settings.dateJson.length; i&#43;&#43;) { if (moment(yearMonthDay)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f3abdc69fa6fec1ad2ff7b7060e19278/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-17T13:08:20+08:00" />
<meta property="article:modified_time" content="2019-07-17T13:08:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">类似携程,飞猪机票列表滚动的日期带价格</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>近期在优化我们公司的机票查询的价格日历(跟携程,飞猪的机票列表类似),之前是将所有切换的日期全部展示在网页中,由于默认查询日期是一年,会导致页面上存在大量的&lt;li&gt;,假如哪天产品要求日期默认是10年呢,估计页面要卡死了.<br><br> 优化结果先看下最终的效果图:<br><img alt="" class="has" height="456" src="https://images2.imgbox.com/90/b7/T60BoUz1_o.gif" width="657"></p> 
<p>可以看到以下两点:<br> 1.不管怎么滚动,下面的&lt;li&gt;数量永远是固定的,不会随着滚动日期的增加 而累加&lt;li&gt;的数量,大大提高了页面的性能<br> 2.点击了日期后,请求当天的价格,不替换&lt;li&gt;的情况下将"查看价格"赋值为具体的金额</p> 
<p>技术支持:<br> 对日期的处理主要使用的是moment.js</p> 
<p>好了话不多说,上代码:</p> 
<p>首先对日期做处理,设置了初始日期和截止日期,会返回这两个日期之间所有的日期,另外还会补齐已经过期的时间,和不可选择的时间,如果用户设置了当前日期,也会有标识出来,具体代码如下(下面代码要使用moment.js):</p> 
<pre class="has"><code>// 只负责处理日期,不负责处理业务
/*返回某时间段的所有日期数据，并格式化，并根据是否今天还是明天还是后天加了classname*/
var dateJson = []

function Calendar() {
    this.settings = {
        startDate: '2019-05-10', // 开始时间
        endDate: '2019-10-15',// 结束时间
        dateJson: dateJson, // 日期上的标识数据，class名字要和这个标识字段一摸一样，例如json里面的“折”是discount,那么css名字也叫.discount
        defaultSelectDate: ['2019-07-02', '2019-07-09'] // 选中的日期
    }
}

Calendar.prototype.init = function (opt) {
    $.extend(this.settings, opt);
    return (this.getAllDate(this.settings.startDate, this.settings.endDate));
}

Calendar.prototype.pushTag = function (yearMonthDay) {
    var tags = {};
    for (var i = 0; i &lt; this.settings.dateJson.length; i++) {
        if (moment(yearMonthDay).format('x') === moment(this.settings.dateJson[i].date).format('x')) {
            for (var key in this.settings.dateJson[i]) {
                tags[key] = this.settings.dateJson[i][key];
            }
            break;
        }
    }
    return tags;
}
Calendar.prototype.setClass = function (start, end, i) { //根据日期给div设置样式
    var className = '',daytype='';
    if (i &gt;= moment(start).format('x') &amp;&amp; i &lt;= moment(end)) { // 是否在开始和结束之间
        className = 's_day';daytype='s_day';
        if (moment(i).format('YYYY/MM/DD') === moment().format('YYYY/MM/DD')) { // 今天
            className += ' s_today';
        }
        $.each(this.settings.defaultSelectDate, function (index, item) { // defaultSelectDate
            if (moment(i).format('YYYY/MM/DD') === moment(item).format('YYYY/MM/DD')) {
                className += ' s_curday';
            }
        })
    } else {
        className = 's_pass';daytype='s_pass';
        if (moment(i).format('YYYY/MM/DD') === moment().format('YYYY/MM/DD')) {
            className += ' s_today';
        }
    }
    return {className:className,daytype:daytype};
}

Calendar.prototype.getAllDate = function (start, end) { // 获取两个日期间的所有日期数据
    var sd = Number(moment(start).startOf('month').format('x')); // 本月第一天
    var ed = Number(moment(end).endOf('month').format('x')); // 本月最后一天

    var dataObject = {};

    dataObject[sd] = {title: moment(start).format('YYYY年MM月'), date: []} // 初始第一个月
    // console.log( moment(sd).weekday())
    for (var w = 0; w &lt; moment(sd).weekday(); w++) { // 对本月一号之前的周几补全。
        dataObject[sd].date.push({year: '', month: '', day: '', week: w});// 如果当前月份没有存储当前天数用的数组,就创建一个空数组，如果有，就向里面添加一个空对象; (空对象是用来占位置的，用来填充月份前面的空白)
    }
    for (var i = sd; i &lt;= ed;) {
        var firstDay = Number(moment(i).startOf('month').format('x')); // 当月第一天;--作为每个月的唯一标示

        if (moment(i).format('x') === moment(moment(i).startOf('month').format('YYYY-MM-DD')).format('x') &amp;&amp; i !== sd) { // 如果是当月的第一天,添加下个月的数据
            //   console.log(i, sd)
            var op = {
                title: moment(i).add(1, 'days').format('YYYY年MM月'), // 下个月的第一天
                date: []
            }
            for (var w = 0; w &lt; moment(i).weekday(); w++) { // 对本月一号之前的周几补全。
                op.date.push({year: '', month: '', day: '', week: w});// 如果当前月份没有存储当前天数用的数组,就创建一个空数组，如果有，就向里面添加一个空对象; (空对象是用来占位置的，用来填充月份前面的空白)
            }
            dataObject[i] = op;
        }

        //根据日期给div设置样式
        var className = this.setClass(start, end, i).className;
        var daytype = this.setClass(start, end, i).daytype;
        var tag = this.pushTag(moment(i).format('YYYY/MM/DD')); // 折扣，休息等信息
        var option = {
            year: moment(i).format('YYYY'),
            month: moment(i).format('MM'),
            day: moment(i).format('DD'),
            week: moment(i).weekday(),
            classname: className,
            daytype: daytype,
            tags: tag,
            date: moment(i).format('YYYY/MM/DD')
        }
        dataObject[firstDay].date.push(option);
        i = Number(moment(i).add(1, 'days').format('x')); // 下次赋值
    }
    return dataObject;
}

</code></pre> 
<p>运行下面这段代码试试: </p> 
<pre class="has"><code>var c1 = new Calendar();
 var priceData = [
            {date: '2019-02-11', price: '100'},
            {date: '2019-02-12', price: '100', rest: '休'},
            {date: '2019-02-13', price: '100', discount: '折'}]
console.log(c1.init({
            startDate: '2019-02-06',
            endDate: '2019-04-22',
            defaultSelectDate: ['2019-02-09'],
            dateJson: priceData
        }))</code></pre> 
<p>结果:<br> 1.默认是从周日开始排,2019-02-06是周五,所以前面会加5个空的年月日,<br> 2.设置的初始日期是2019-02-06,所以2019-02-06之前和2019-04-22之后的日期都会加上s_pass的classname标识不可用日期,用以区分样式的,在2019-02-06到2019-04-22之前的日期,则都会加上s_day,表示可用日期,当前日期2019-02-09会加上s_curday<br> 3.如果有json数据,tags里面会会带上来,展示大页面上的时候可以根据tags里面的key设置不同的样式 </p> 
<p><img alt="" class="has" height="761" src="https://images2.imgbox.com/09/90/KtiCKyAH_o.png" width="801"></p> 
<p>得到了日期数据,接下来就是滚动的代码:</p> 
<pre class="has"><code>// 只负责滚动的逻辑,不负责业务
function setLodaDateSwrap() {
    this.CalendarBox = null;
    this.leftNum = null;
    this.rightNum = null;
    this.settings = {
        step:2, // 暂时没用
        fTime:3, // 暂时没用
        Calendar: 'ul',
        prev: '.last-month',
        next: '.next-month',
        prevClick:function(){},
        nextClick:function(){},
    }
}
setLodaDateSwrap.prototype.init = function (obj, opt) {
    $.extend(this.settings, opt);

    var This = this;
    this.CalendarBox = obj;
     this.leftNum = -$(this.settings.Calendar).width() / 2;
    // this.leftNum = -this.settings.step*$(this.settings.Calendar).find('.dayprice').width();

    this.rightNum = 0;
    var prevStr = this.CalendarBox + ' ' + this.settings.prev;
    var nextStr = this.CalendarBox + ' ' + this.settings.next;
    $(document).on('click', prevStr, function () {
        if($(This.settings.Calendar).is(":animated")){
            return;
        }
        var callbackFn = null;
        // 返回布尔值,用来判断前进后退按钮是否禁用
        var scroolBool = This.settings.prevClick(function(callback){
            callbackFn = callback;
        });
        if(!scroolBool){return;}
        This.swrap(This.leftNum, This.rightNum,function(){
            if(callbackFn){callbackFn()}
        });
        This.scroolPrevBool = scroolBool;
    });
    $(document).on('click', nextStr, function () {
        if($(This.settings.Calendar).is(":animated")){
            return;
        }
        var callbackFn = null;
        var scroolBool = This.settings.nextClick(function(callback){
            callbackFn = callback;
        });
        if(!scroolBool){return;}
        This.swrap(This.rightNum, This.leftNum,function(){
            if(callbackFn){callbackFn()}
        });
    });
}
setLodaDateSwrap.prototype.swrap = function (num1, num2,callback) {
    var This = this;
    if (!$(this.settings.Calendar).is(':animated')) {
        $(this.settings.Calendar).css({ left: num1 });
        $(this.settings.Calendar).stop().animate({ left: num2 }, 500, function () {
            $(This.settings.Calendar).css({ left: 0 });
            if(callback){callback()}
        });
    }
}
</code></pre> 
<p> </p> 
<p>滚动的功能做好了,然后就是滚动和日期结合由于涉及到html+css,代码较多,就不一一帖过来了,完整代码请戳<a href="https://github.com/slailcp/DatePriceScroll">https://github.com/slailcp/DatePriceScroll</a></p> 
<p>像这种日期和滚动分开的好处还是很多的,例如下面这种日历形式的也可以做出来,:<br><img alt="" class="has" height="442" src="https://images2.imgbox.com/e9/8e/RvyuVWVs_o.gif" width="670"><br>  </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e33f16c1e5b03cbd6f8d873fa482cdcb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">推荐几个清华交大学霸的公众号</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fea5c5731c7064754dcd1b75fd8644c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小程序中navigator和wx.navigateTo,wx.redirectTo,wx.reLaunch,wx.switchTab,wx.navigateBack的用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>