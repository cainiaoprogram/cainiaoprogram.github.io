<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java16个原子类介绍-基于JDK8 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java16个原子类介绍-基于JDK8" />
<meta property="og:description" content="前言 emmmm，在写文章前我也翻阅了好多资料和书籍，其实大家在对原子类方法的使用介绍基本都没问题，但是对于java中原子类的个数是五花八门，下面我就把自己都认知和书籍资料结合起来给大家简单都介绍下java中原子类的应用。
参考文献
《Java并发编程的艺术》
正文 关于原子类个数说明 在JDK7包括7之前，java原子类有12个，图片如下，有些资料说有13个，多出来的是 AtomicBooleanArray 类，可是我在JDK8之前的源码里并没有发现有这个类，当然我也没去8以上的版本去看，所以这里不确定这个类到底在哪个版本中存在。
在JDK8时出现了4个原子操作类，分别是如下图片所示
原子更新基本类型类 使用原子的方式更新基本类型，Atomic包提供了以下3个类。
AtomicBoolean: 原子更新布尔类型。 AtomicInteger: 原子更新整型。 AtomicLong: 原子更新长整型。 以上3个类提供的方法几乎一模一样，以AtomicInteger为例进行详解，AtomicIngeter的常用方法如下： int addAndGet(int delta): 以原子的方式将输入的数值与实例中的值相加，并返回结果。 boolean compareAndSet(int expect, int update): 如果输入的值等于预期值，则以原子方式将该值设置为输入的值。 int getAndIncrement(): 以原子的方式将当前值加 1，注意，这里返回的是自增前的值，也就是旧值。 void lazySet(int newValue): 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 int getAndSet(int newValue): 以原子的方式设置为newValue,并返回旧值。
代码示例
static AtomicInteger ai =new AtomicInteger(1); public static void main(String[] args) { System.out.println(ai.getAndIncrement()); System.out.println(ai.get()); } 输出结果
1
2
下面我们看看getAndIncrement() 是如何实现原子操作的
public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/05bd32c985e9803b476cb2a3d9ff4fce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-15T17:17:59+08:00" />
<meta property="article:modified_time" content="2019-03-15T17:17:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java16个原子类介绍-基于JDK8</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p style="text-indent:50px;">emmmm，在写文章前我也翻阅了好多资料和书籍，其实大家在对原子类方法的使用介绍基本都没问题，但是对于java中原子类的个数是五花八门，下面我就把自己都认知和书籍资料结合起来给大家简单都介绍下java中原子类的应用。</p> 
<p style="text-indent:50px;">参考文献</p> 
<p style="text-indent:50px;">《Java并发编程的艺术》</p> 
<h3>正文</h3> 
<h4>关于原子类个数说明</h4> 
<p style="text-indent:50px;">在JDK7包括7之前，java原子类有12个，图片如下，有些资料说有13个，多出来的是 AtomicBooleanArray 类，可是我在JDK8之前的源码里并没有发现有这个类，当然我也没去8以上的版本去看，所以这里不确定这个类到底在哪个版本中存在。</p> 
<p><img alt="" class="has" height="196" src="https://images2.imgbox.com/93/39/DH8iWhXk_o.png" width="200"></p> 
<p style="text-indent:50px;">在JDK8时出现了4个原子操作类，分别是如下图片所示</p> 
<p><img alt="" class="has" height="89" src="https://images2.imgbox.com/18/de/i3bL8v0V_o.png" width="247"></p> 
<p> </p> 
<h4>原子更新基本类型类</h4> 
<p>使用原子的方式更新基本类型，Atomic包提供了以下3个类。</p> 
<ul><li>AtomicBoolean:  原子更新布尔类型。 </li><li>AtomicInteger:    原子更新整型。 </li><li>AtomicLong:       原子更新长整型。 </li></ul> 
<p>以上3个类提供的方法几乎一模一样，以AtomicInteger为例进行详解，AtomicIngeter的常用方法如下： </p> 
<ul><li>int addAndGet(int delta): 以原子的方式将输入的数值与实例中的值相加，并返回结果。 </li><li>boolean compareAndSet(int expect, int update): 如果输入的值等于预期值，则以原子方式将该值设置为输入的值。 </li><li>int getAndIncrement(): 以原子的方式将当前值加 1，注意，这里返回的是自增前的值，也就是旧值。 </li><li>void lazySet(int newValue): 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 </li><li>int getAndSet(int newValue): 以原子的方式设置为newValue,并返回旧值。<br>  </li></ul> 
<p><strong>代码示例</strong></p> 
<pre class="has"><code class="language-java">	static AtomicInteger ai =new AtomicInteger(1);
	public static void main(String[] args) {

		System.out.println(ai.getAndIncrement());
		System.out.println(ai.get());
     }</code></pre> 
<p>输出结果</p> 
<p>1</p> 
<p>2</p> 
<p><strong>下面我们看看getAndIncrement() 是如何实现原子操作的</strong></p> 
<pre class="has"><code class="language-java"> public final int getAndIncrement() {
        return unsafe.getAndAddInt(this, valueOffset, 1);
    }


public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

        return var5;
    }</code></pre> 
<p><strong>代码解析</strong></p> 
<p>我们取得了旧值，然后把要加的数传过去，调用getAndAddInt () 进行原子更新操作，实际最核心的方法是 compareAndSwapInt()，使用CAS进行更新。我们Unsafe只提供了3中CAS操作，</p> 
<p><span style="color:#ffbb66;">另外注意，AtomicBoolean 是把Boolean转成整型，在使用 compareAndSwapInt 进行操作的。</span></p> 
<pre class="has"><code class="language-java">/**
 * 如果当前数值是var4，则原子的将java变量更新成var5或var6
 * @return 如果更新成功返回true
 */
public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);

    public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);

    public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);</code></pre> 
<p> </p> 
<h4>原子更新数组</h4> 
<p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下的3个类：</p> 
<p>有的资料说4个，笔者水平有限，真的没有发现第四个，如果哪位大佬知道的话，可以下方留言区指出来。</p> 
<ul><li>AtomicIntegerArray:  原子更新整型数组里的元素。 </li><li>AtomicLongArray:  原子更新长整型数组里的元素。 </li><li>AtomicReferenceArray:  原子更新引用类型数组里的元素。</li></ul> 
<p>这三个类的最常用的方法是如下两个方法： </p> 
<ul><li>　　get(int index)：获取索引为index的元素值。 </li><li>　　compareAndSet(int i, int expect, int update): 如果当前值等于预期值，则以原子方式将数组位置 i 的元素设置为update值。 </li></ul> 
<p>下面以 AtomicReferenceArray 举例如下</p> 
<pre class="has"><code class="language-java">	static int[] value =new int[]{1,2};
	static AtomicIntegerArray ai =new AtomicIntegerArray(value);
	public static void main(String[] args) {

		ai.getAndSet(0,2);
		System.out.println(ai.get(0));
		System.out.println(value[0]);
    }</code></pre> 
<p>输出结果</p> 
<p>3</p> 
<p>1</p> 
<p> </p> 
<h4>原子更新引用类型</h4> 
<p>原子更新基本类型的AtomicInteger，只能更新一个值，如果更新多个值，比如更新一个对象里的值，那么就要用原子更新引用类型提供的类，Atomic包提供了以下三个类：</p> 
<ul><li>AtomicReference:  原子更新引用类型。 </li><li>AtomicReferenceFieldUpdater:  原子更新引用类型的字段。 </li><li>AtomicMarkableReferce:  原子更新带有标记位的引用类型，可以使用构造方法更新一个布尔类型的标记位和引用类型。 <br>  </li></ul> 
<pre class="has"><code class="language-java">  public static AtomicReference&lt;User&gt; ai = new AtomicReference&lt;User&gt;();

    public static void main(String[] args) {

        User u1 = new User("pangHu", 18);
        ai.set(u1);
        User u2 = new User("piKaQiu", 15);
        ai.compareAndSet(u1, u2);
        System.out.println(ai.get().getAge() + ai.get().getName());

    }


static class User {
        private String name;
        private int age;

        public User(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }

</code></pre> 
<p>输出结果</p> 
<p>piKaQiu 15</p> 
<p><strong>代码分析</strong></p> 
<p>我们吧对象放到 AtomicReference 中，然后调用 compareAndSet () 原子操作替换，原理和 AtomicInteger 相同，只是调用的是 compareAndSwapObject()  方法。</p> 
<h4>原子更新字段类</h4> 
<p>如果需要原子的更新类里某个字段时，需要用到原子更新字段类，Atomic包提供了3个类进行原子字段更新： </p> 
<ul><li>AtomicIntegerFieldUpdater:  原子更新整型的字段的更新器。 </li><li>AtomicLongFieldUpdater:  原子更新长整型字段的更新器。 </li><li>AtomicStampedFieldUpdater:  原子更新带有版本号的引用类型。 </li></ul> 
<p> </p> 
<pre class="has"><code class="language-java"> //创建原子更新器，并设置需要更新的对象类和对象的属性
    private static AtomicIntegerFieldUpdater&lt;User&gt; ai = AtomicIntegerFieldUpdater.newUpdater(User.class, "age");

    public static void main(String[] args) {

        User u1 = new User("pangHu", 18);
        //原子更新年龄，+1
        System.out.println(ai.getAndIncrement(u1));
        System.out.println(u1.getAge());
    }



static class User {
        private String name;
        public volatile int age;

        public User(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }</code></pre> 
<p><strong>代码详解</strong></p> 
<p>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，<strong>更新类的字段必须使用 public volatile 修饰</strong>。</p> 
<p>输出结果</p> 
<p>18</p> 
<p>19</p> 
<p> </p> 
<h4>JDK8新增原子类简介</h4> 
<ul><li>DoubleAccumulator</li><li>LongAccumulator</li><li>DoubleAdder</li><li>LongAdder</li></ul> 
<p><strong><span style="color:#ffbb66;">下面以 LongAdder 为例介绍一下，并列出使用注意事项</span></strong></p> 
<p>这些类对应把 AtomicLong 等类的改进。比如 LongAccumulator 与 LongAdder 在高并发环境下比 AtomicLong 更高效。</p> 
<p>Atomic、Adder在低并发环境下，两者性能很相似。但在高并发环境下，Adder 有着明显更高的吞吐量，但是有着更高的空间复杂度。</p> 
<p>LongAdder其实是LongAccumulator的一个特例，调用LongAdder相当使用下面的方式调用LongAccumulator。</p> 
<p>sum()  方法在没有并发的情况下调用，如果在并发情况下使用会存在计数不准，下面有代码为例。</p> 
<p>LongAdder不可以代替AtomicLong<strong>  </strong>，虽然 LongAdder 的 add() 方法可以原子性操作，但是并没有使用 Unsafe 的CAS算法，只是使用了CAS的思想。</p> 
<p>LongAdder其实是LongAccumulator的一个特例，调用LongAdder相当使用下面的方式调用LongAccumulator，LongAccumulator提供了比LongAdder更强大的功能，构造函数其中accumulatorFunction一个双目运算器接口，根据输入的两个参数返回一个计算值，identity则是LongAccumulator累加器的初始值。</p> 
<pre class="has"><code class="language-java">private static ExecutorService executorService = Executors.newFixedThreadPool(5);
    public static void main(String[] args) {
        for (int i = 1; i &lt;= 100; i++) {
            executorService.execute(new Runnable() {
                @Override
                public void run() {
                    counter.add(2);
                }
            });
        }
        System.out.println(counter.sum());
        System.out.println(counter);
    }</code></pre> 
<p>输出结果</p> 
<p><img alt="" class="has" height="140" src="https://images2.imgbox.com/bf/3e/Vm5dOVAB_o.png" width="216"> </p> 
<p> </p> 
<p><img alt="" class="has" height="370" src="https://images2.imgbox.com/9a/ec/dMedRt9J_o.png" width="383"></p> 
<p><strong>图片解释</strong></p> 
<p>如图LongAdder则是内部维护多个变量，每个变量初始化都0，在同等并发量的情况下，争夺单个变量的线程量会减少这是变相的减少了争夺共享资源的并发量，另外多个线程在争夺同一个原子变量时候如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后获取当前值时候是把所有变量的值累加后返回的。<br>  </p> 
<pre class="has"><code class="language-java">//构造函数
LongAdder()
    //创建初始和为零的新加法器。

//方法摘要
void    add(long x)    //添加给定的值。
void    decrement()    //相当于add(-1)。
double  doubleValue() //在扩展原始转换之后返回sum()as double。
float   floatValue()  //在扩展原始转换之后返回sum()as float。
void    increment()  //相当于add(1)。
int intValue()      //返回sum()作为int一个基本收缩转换之后。
long    longValue() //相当于sum()。
void    reset()    //重置将总和保持为零的变量。
long    sum()     //返回当前的总和。
long    sumThenReset()  //等同于sum()后面的效果reset()。
String  toString()   //返回。的字符串表示形式sum()。
</code></pre> 
<p> </p> 
<p>关于更多jdk8新增原子类的学习，推荐看下面几个文章，我也是跟着他们学的。</p> 
<p><a href="https://blog.csdn.net/zhailuxu/article/details/79073469">https://blog.csdn.net/zhailuxu/article/details/79073469</a></p> 
<p><a href="https://blog.csdn.net/yao123long/article/details/63683991">https://blog.csdn.net/yao123long/article/details/63683991</a></p> 
<p><a href="https://blog.csdn.net/panweiwei1994/article/details/78739264">https://blog.csdn.net/panweiwei1994/article/details/78739264</a></p> 
<p><a href="https://blog.csdn.net/zhailuxu/article/details/79073473?utm_source=blogxgwz9">https://blog.csdn.net/zhailuxu/article/details/79073473?utm_source=blogxgwz9</a></p> 
<p>感兴趣可以加微信，带你去大佬云集的交流群</p> 
<p> </p> 
<p> </p> 
<p><img alt="" class="has" height="266" src="https://images2.imgbox.com/36/76/ucKwaGDA_o.jpg" width="200"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6905f09f7bfdc52e9dcb5a8862082953/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">/lib64/libc.so.6: version `GLIBC_2.14&#39; not found问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fa0107ac56e59befad8030f7c7edba40/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决一次服务器病毒被杀的情况</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>