<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【STL】-- 知识总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【STL】-- 知识总结" />
<meta property="og:description" content="目录
STL六大组件介绍
容器
序列式容器
vector
list
知识点考察
关联式容器
map/set
set介绍
set常用接口
map介绍
map常用接口
底层结构：红黑树
unordered_map/set
unordered_map/set介绍
底层结构：哈希表
知识考察
适配器
stack
queue
priority_queue
迭代器
什么是迭代器
迭代器的定义
迭代器失效
迭代器分类
STL六大组件介绍 从使用的角度来看，重点关注容器、算法和迭代器三个组件：
在使用C&#43;&#43;进行程序编写的过程中，容器的使用必不可少，如用vector/list/map等来进行数据的存储。算法可以非常便捷的对容器进行操作，比如用sort对vector中的数据排序，使用find在map中查找元素等等。在通过算法操作容器的时候，不得不提到迭代器，它就像是容器和算法间的粘合剂：
迭代器的存在，首先封装隐藏了底层的实现细节。其次，为用户提供了统一的方式去访问容器，极大的降低了使用的成本。
从底层的角度，分析各个组件的功能及联系：
容器：各种数据结构，如: vector，list，set，map用来存放数据。
算法：各种常用算法如sort，swap，reverse，find等。
迭代器：扮演容器与算法之间的胶合剂。从实现角度来看，迭代器将operator*， operator-&gt;, operator&#43;&#43;, operator--等相关操作进行重载的类。所有STL容器都附带有自己专属的迭代器，用户可以用统一的方式对容器进行访问。
仿函数：实现了operator()，这个类能够像函数一样调用，函数指针可视为狭义的仿函数。可作为算法的某种策略，例如改变sort排序的比较规则，map/set的key比较大小的规则。
配接器：用来修饰容器、仿函数、迭代器接口。如：stack，queue，主要体现了复用。
配置器：负责空间配置与管理，从实现角度来看，配置器实现了动态空间配置，空间管理，空间释放。例如：容器需要频繁的申请和释放小块的内存，这种情况下可以使用空间配置器，提高效率。
容器 序列式容器 vector 介绍：vector是表示可变大小数组的序列式容器，采用连续存储空间来存储元素，支持下标的随机访问，它的大小是可以动态改变的。vector在访问元素、尾插和尾删的场景下相对高效。
如上图所示，vector底层设计通过三个迭代器的指针分别记录数据块的起始位置，末尾有效数据和存储容量的末尾位置。vector的迭代器是原生的指针。
vector常用接口：
push_back:尾插
pop_back：尾删
operator[]：[]重载，使vector可以向数组一样访问。
rsize:改变vector的size，在开辟空间的同时还会初始化。
resrve：改变vector的capacity。
list list的底层结构是双向链表，该容器可以前后双向迭代。list在任意位置插入和删除元素的执行效率更好。
如上图所示，list_node的结构分为三个部分，分别是指向下一个节点的指针Next，执行前一个节点的指针Prev和存储数据的Val。
常用接口：
push_front/pop_front:头插、头删。
push_back/pop_back：尾插、尾删。
insert/erase:在pos位置插入值为val的元素,删除pos位置的元素。
知识点考察 vector和list的区别？
1.底层结构：vector采用连续的空间对数据进行存储（动态顺序表）。list物理结构不连续（带头节点的双向循环链表）。
2.随机访问：vector支持随机访问，访问某个元素的效率是O(1)。list不支持随机访问，访问某个元素的效率是O(n)。
3.迭代器：vector迭代器是原生的指针，list对原生态指针进行了封装。
4.使用场景：vector适合需要高效存储，支持随机访问，不关心插入删除效率的场景（中间插入要挪动数据，效率太低）。而list更适合大量的插入和删除操作，不关心随机访问的场景。
vector如何扩容？
当指向最后一个有效数据位置的迭代器和容量末尾的迭代器重合的时候，代表容器已满，需要进行扩容，在vs下按照1.5倍扩容，g&#43;&#43;下按照2倍扩容。但这仅供参考，具体增长多少是根据具体的需求定义的，vs下是PJ版STL,g&#43;&#43;是SGI版STL。主要原因就是，扩大了空间浪费，扩小了不够用频繁扩容，所以没有固定的标准说一定扩多少。
resize和reserve有什么区别？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/396d510a362dc211c9c353aa4e4583b4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-19T16:20:08+08:00" />
<meta property="article:modified_time" content="2023-08-19T16:20:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【STL】-- 知识总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D" rel="nofollow">STL六大组件介绍</a></p> 
<p id="%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%AE%B9%E5%99%A8" rel="nofollow">容器</a></p> 
<p id="%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8" rel="nofollow">序列式容器</a></p> 
<p id="vector-toc" style="margin-left:80px;"><a href="#vector" rel="nofollow">vector</a></p> 
<p id="list-toc" style="margin-left:80px;"><a href="#list" rel="nofollow">list</a></p> 
<p id="%E7%9F%A5%E8%AF%86%E7%82%B9%E8%80%83%E5%AF%9F-toc" style="margin-left:80px;"><a href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E8%80%83%E5%AF%9F" rel="nofollow">知识点考察</a></p> 
<p id="%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8" rel="nofollow">关联式容器</a></p> 
<p id="map%2Fset-toc" style="margin-left:80px;"><a href="#map%2Fset" rel="nofollow">map/set</a></p> 
<p id="set%E4%BB%8B%E7%BB%8D-toc" style="margin-left:120px;"><a href="#set%E4%BB%8B%E7%BB%8D" rel="nofollow">set介绍</a></p> 
<p id="set%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-toc" style="margin-left:120px;"><a href="#set%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3" rel="nofollow">set常用接口</a></p> 
<p id="map%E4%BB%8B%E7%BB%8D-toc" style="margin-left:120px;"><a href="#map%E4%BB%8B%E7%BB%8D" rel="nofollow">map介绍</a></p> 
<p id="map%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-toc" style="margin-left:120px;"><a href="#map%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3" rel="nofollow">map常用接口</a></p> 
<p id="%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:120px;"><a href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow">底层结构：红黑树</a></p> 
<p id="unordered_map%2Fset-toc" style="margin-left:80px;"><a href="#unordered_map%2Fset" rel="nofollow">unordered_map/set</a></p> 
<p id="unordered_map%2Fset%E4%BB%8B%E7%BB%8D-toc" style="margin-left:120px;"><a href="#unordered_map%2Fset%E4%BB%8B%E7%BB%8D" rel="nofollow">unordered_map/set介绍</a></p> 
<p id="%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8-toc" style="margin-left:120px;"><a href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8" rel="nofollow">底层结构：哈希表</a></p> 
<p id="%E7%9F%A5%E8%AF%86%E8%80%83%E5%AF%9F-toc" style="margin-left:80px;"><a href="#%E7%9F%A5%E8%AF%86%E8%80%83%E5%AF%9F" rel="nofollow">知识考察</a></p> 
<p id="%E9%80%82%E9%85%8D%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E9%80%82%E9%85%8D%E5%99%A8" rel="nofollow">适配器</a></p> 
<p id="stack-toc" style="margin-left:80px;"><a href="#stack" rel="nofollow">stack</a></p> 
<p id="queue-toc" style="margin-left:80px;"><a href="#queue" rel="nofollow">queue</a></p> 
<p id="priority_queue-toc" style="margin-left:80px;"><a href="#priority_queue" rel="nofollow">priority_queue</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">迭代器</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">什么是迭代器</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">迭代器的定义</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88-toc" style="margin-left:40px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88" rel="nofollow">迭代器失效</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB" rel="nofollow">迭代器分类</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D" style="background-color:transparent;">STL六大组件介绍</h2> 
<p>从使用的角度来看，重点关注容器、算法和迭代器三个组件：</p> 
<p>在使用C++进行程序编写的过程中，容器的使用必不可少，如用vector/list/map等来进行数据的存储。算法可以非常便捷的对容器进行操作，比如用sort对vector中的数据排序，使用find在map中查找元素等等。在通过算法操作容器的时候，不得不提到迭代器，它就像是容器和算法间的粘合剂：</p> 
<p class="img-center"><img alt="" height="179" src="https://images2.imgbox.com/c8/00/lhy3xKf9_o.png" width="450"></p> 
<p>迭代器的存在，首先封装隐藏了底层的实现细节。其次，为用户提供了统一的方式去访问容器，极大的降低了使用的成本。</p> 
<p>从底层的角度，分析各个组件的功能及联系：</p> 
<p class="img-center"><img alt="" height="417" src="https://images2.imgbox.com/55/3e/y3odSIcV_o.png" width="491"></p> 
<p><strong>容器</strong>：各种数据结构，如: vector，list，set，map用来存放数据。</p> 
<p><strong>算法</strong>：各种常用算法如sort，swap，reverse，find等。</p> 
<p><strong>迭代器</strong>：扮演容器与算法之间的胶合剂。从实现角度来看，迭代器将operator*， operator-&gt;, operator++, operator--等相关操作进行重载的类。所有STL容器都附带有自己专属的迭代器，用户可以用统一的方式对容器进行访问。</p> 
<p><strong>仿函数</strong>：实现了operator()，这个类能够像函数一样调用，函数指针可视为狭义的仿函数。可作为算法的某种策略，例如改变sort排序的比较规则，map/set的key比较大小的规则。</p> 
<p><strong>配接器</strong>：用来修饰容器、仿函数、迭代器接口。如：stack，queue，主要体现了复用。</p> 
<p><strong>配置器</strong>：负责空间配置与管理，从实现角度来看，配置器实现了动态空间配置，空间管理，空间释放。例如：容器需要频繁的申请和释放小块的内存，这种情况下可以使用空间配置器，提高效率。</p> 
<h2 id="%E5%AE%B9%E5%99%A8" style="background-color:transparent;">容器</h2> 
<h3 id="%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8" style="background-color:transparent;">序列式容器</h3> 
<p class="img-center"><img alt="" height="483" src="https://images2.imgbox.com/58/f8/73Ti053t_o.png" width="1126"></p> 
<h4 id="vector" style="background-color:transparent;">vector</h4> 
<p>介绍：vector是表示可变大小数组的序列式容器，采用连续存储空间来存储元素，支持下标的随机访问，它的大小是可以动态改变的。vector在访问元素、尾插和尾删的场景下相对高效。</p> 
<p class="img-center"><img alt="" height="397" src="https://images2.imgbox.com/dd/ac/RUUyFExW_o.png" width="474"></p> 
<p>如上图所示，vector底层设计通过三个迭代器的指针分别记录数据块的起始位置，末尾有效数据和存储容量的末尾位置。vector的迭代器是原生的指针。</p> 
<p>vector常用接口：</p> 
<p>push_back:尾插</p> 
<p>pop_back：尾删</p> 
<p>operator[]：[]重载，使vector可以向数组一样访问。</p> 
<p>rsize:改变vector的size，在开辟空间的同时还会初始化。</p> 
<p>resrve：改变vector的capacity。</p> 
<h4 id="list">list</h4> 
<p>list的底层结构是双向链表，该容器可以前后双向迭代。list在任意位置插入和删除元素的执行效率更好。</p> 
<p class="img-center"><img alt="" height="438" src="https://images2.imgbox.com/86/c2/hITagBbR_o.png" width="548"></p> 
<p>如上图所示，list_node的结构分为三个部分，分别是指向下一个节点的指针Next，执行前一个节点的指针Prev和存储数据的Val。</p> 
<p>常用接口：</p> 
<p>push_front/pop_front:头插、头删。</p> 
<p>push_back/pop_back：尾插、尾删。</p> 
<p>insert/erase:在pos位置插入值为val的元素,删除pos位置的元素。</p> 
<h4 id="%E7%9F%A5%E8%AF%86%E7%82%B9%E8%80%83%E5%AF%9F">知识点考察</h4> 
<p>vector和list的区别？</p> 
<p>1.底层结构：vector采用连续的空间对数据进行存储（动态顺序表）。list物理结构不连续（带头节点的双向循环链表）。</p> 
<p>2.随机访问：vector支持随机访问，访问某个元素的效率是O(1)。list不支持随机访问，访问某个元素的效率是O(n)。</p> 
<p>3.迭代器：vector迭代器是原生的指针，list对原生态指针进行了封装。</p> 
<p>4.使用场景：vector适合需要高效存储，支持随机访问，不关心插入删除效率的场景（中间插入要挪动数据，效率太低）。而list更适合大量的插入和删除操作，不关心随机访问的场景。</p> 
<p>vector如何扩容？</p> 
<p>当指向最后一个有效数据位置的迭代器和容量末尾的迭代器重合的时候，代表容器已满，需要进行扩容，在vs下按照1.5倍扩容，g++下按照2倍扩容。但这仅供参考，具体增长多少是根据具体的需求定义的，vs下是PJ版STL,g++是SGI版STL。主要原因就是，扩大了空间浪费，扩小了不够用频繁扩容，所以没有固定的标准说一定扩多少。</p> 
<p>resize和reserve有什么区别？</p> 
<p>resize在开辟空间的同时还会初始化，改变size的大小。reserve只负责开辟空间。</p> 
<h3 id="%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8">关联式容器</h3> 
<p class="img-center"><img alt="" height="596" src="https://images2.imgbox.com/2f/14/lQ3MgBPC_o.png" width="1200"></p> 
<h4 id="map%2Fset">map/set</h4> 
<h5 id="set%E4%BB%8B%E7%BB%8D">set介绍</h5> 
<p>1. 与map/multimap不同，map/multimap中存储的是真正的键值对&lt;key, value&gt;，set中只放<br> value，但在底层实际存放的是由&lt;value, value&gt;构成的键值对。                                                    2. set中插入元素时，只需要插入value即可，不需要构造键值对。<br> 3. set中的元素不可以重复(因此可以使用set进行去重)。<br> 4. 使用set的迭代器遍历set中的元素，可以得到有序序列。<br> 5. set中的元素默认按照小于来比较。<br> 6. set中查找某个元素，时间复杂度为：$log_2 n$。<br> 7. set中的元素不允许修改，修改方式是先删除在插入新的元素，直接修改会破坏set的有序性。<br> 8. set中的底层使用二叉搜索树(红黑树)来实现。</p> 
<h5 id="set%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">set常用接口</h5> 
<p>empty：检测set是否为空。</p> 
<p>size:：返回set中有效元素的个数。</p> 
<p>insert：向set中插入元素x。</p> 
<p>erase：删除set中pos位置上的元素。</p> 
<p>find：返回set中值为x的元素的个数。</p> 
<h5 id="map%E4%BB%8B%E7%BB%8D" style="background-color:transparent;">map介绍</h5> 
<p>1. map中的的元素是键值对<br> 2. map中的key是唯一的，并且不能修改<br> 3. 默认按照小于的方式对key进行比较。<br> 4. map中的元素如果用迭代器去遍历，可以得到一个有序的序列<br> 5. map的底层为平衡搜索树(红黑树)，查找效率比较高$O(log_2 N)$<br> 6. 支持[]操作符，operator[]中实际进行插入查找，返回值是key对应的value。</p> 
<h5 id="map%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">map常用接口</h5> 
<p>operator[]:map支持下标访问符，即在[]中放入key，就可以找到与key对应的value。</p> 
<p>empty：检测set是否为空。</p> 
<p>size:：返回set中有效元素的个数。</p> 
<p>insert：向set中插入元素x。</p> 
<p>erase：删除set中pos位置上的元素。</p> 
<p>find：返回set中值为x的元素的个数。</p> 
<h5 id="%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91">底层结构：红黑树</h5> 
<p>在介绍红黑树之前先介绍一下AVl树：</p> 
<p>由于在极端的情况下，二叉搜索树可能会退化成单边树，此时查找效率就会退化成O(N)。AVL树的出现解决了上述问题，当新节点插入到AVL树中后，控制每个节点左右子树的高度差的绝对值不超过1。AVL树是高度平衡的二叉搜索树，搜索数据的时间复杂度为O(log_2 n)。</p> 
<p class="img-center"><img alt="" height="401" src="https://images2.imgbox.com/d6/78/ulDZMdJp_o.png" width="543"></p> 
<pre><code>template&lt;class K,class V&gt;
class AVLTreeNode
{
public:
	AVLTreeNode&lt;K, V&gt;* _left;
	AVLTreeNode&lt;K, V&gt;* _right;
	AVLTreeNode&lt;K, V&gt;* _parent;
	pair&lt;K, V&gt; _data;
	int _bf;
	AVLTreeNode(const pair&lt;K,V&gt;&amp; kv)
		:_left(nullptr), _right(nullptr)
		, _parent(nullptr), _bf(0),_data(kv)
	{}
};
</code></pre> 
<p>AVL树的插入可以简单的分为两步，首先是按照二叉搜索的方式插入新节点，其次就是通过平衡因子调整树的平衡。下面重点关注什么情况下需要调整，如何进行调整。</p> 
<p>节点pCur（新插入的节点）插入后，pParent（新节点的父节点）的平衡因子一定需要调整，在插入之前，pParent的平衡因子分为三种情况：-1，0, 1, 分以下两种情况：<br> 1. 如果pCur插入到pParent的左侧，只需给pParent的平衡因子-1。<br> 2. 如果pCur插入到pParent的右侧，只需给pParent的平衡因子+1。<br> 此时：pParent的平衡因子可能有三种情况：0，正负1， 正负2<br> 1. 如果pParent的平衡因子为0，说明插入之前pParent的平衡因子为正负1，插入后被调整<br> 成0，此时满足AVL树的性质，插入成功<br> 2. 如果pParent的平衡因子为正负1，说明插入前pParent的平衡因子一定为0，插入后被更<br> 新成正负1，此时以pParent为根的树的高度增加，需要继续向上更新调整。<br> 3. 如果pParent的平衡因子为正负2，则pParent的平衡因子违反平衡树的性质，需要对其进<br> 行旋转处理。</p> 
<p>AVl树的旋转可以大致的分为如下几种情况：</p> 
<p><img alt="" height="485" src="https://images2.imgbox.com/b3/19/FeSToBif_o.png" width="1200"></p> 
<p> 以左单旋为例：</p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/62/ac/wZksioVH_o.png" width="1200"></p> 
<p>新节点插入较高左子树的右侧，左边低右边高，以40为根的二叉树不平衡。大致过程如下：<br> 1.subRL变成parent的右孩子。</p> 
<p>2.subR变成根节点。</p> 
<p>3.parent变成subR的左孩子。</p> 
<p>代码实现的过程中要注意几个点：旋转完后subR是该子树的根节点，它可能是整颗树的根节点也可能只是一颗子树。还要注意subRL是否为空。</p> 
<pre><code>void RotateL(Node* parent)
	{
		Node* SubR = parent-&gt;_right;
		Node* SubRL = SubR-&gt;_left;
		
		//cur的左孩子给parent的右
		parent-&gt;_right = SubRL;
		if (SubRL) SubRL-&gt;_parent = parent;
		//cur变成父节点，parent变成cur的左
		Node* ppNode = parent-&gt;_parent;

		parent-&gt;_parent = SubR;
		SubR-&gt;_left = parent;
		if (ppNode == nullptr)
		{
			_root = SubR;
			_root-&gt;_parent = nullptr;
		}
		else
		{
			if (ppNode-&gt;_left == parent)
			{
				ppNode-&gt;_left = SubR;
			}
			else if (ppNode-&gt;_right == parent)
			{
				ppNode-&gt;_right = SubR;
			}
			SubR-&gt;_parent = ppNode;
		}
		parent-&gt;_bf = SubR-&gt;_bf = 0;
	}</code></pre> 
<p>AVL树分析：</p> 
<p>AVL树是一棵绝对平衡的二叉搜索树，其要求每个节点的左右子树高度差的绝对值都不超过1，这<br> 样可以保证查询时高效的时间复杂度，即log_2 N)。</p> 
<p>但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，但结构经常修改，就不太适合。</p> 
<p>红黑树介绍：</p> 
<p>红黑树也是一种二叉搜索树，它的结构是接近平衡的。每个节点要么是红色，要么是黑色。通过对任何一条从根到叶子节点的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，近似平衡，在极端场景下，搜索效率会变成2*log_2 N。</p> 
<p>红黑树的性质：</p> 
<p>1. 每个结点不是红色就是黑色。<br> 2. 根节点是黑色的。<br> 3. 如果一个节点是红色的，则它的两个孩子结点是黑色的。<br> 4. 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。<br> 5. 每个叶子结点都是黑色的(此处的叶子结点指的是空结点。</p> 
<p class="img-center"><img alt="" height="279" src="https://images2.imgbox.com/2e/0b/uNLxhfDh_o.png" width="552"></p> 
<p> 红黑树的插入操作：默认新增节点为红色</p> 
<p>1.按照二叉搜索树的方式插入新节点</p> 
<p>2.检测新节点插入后，红黑树性质是否遭到破坏</p> 
<p>情况1：c为红，p为红，g为黑，u存在且为红。</p> 
<p class="img-center"><img alt="" height="328" src="https://images2.imgbox.com/0d/f1/EbDugQVg_o.png" width="667"></p> 
<p>新节点插入后有连续的红节点出现，处理方法：将p,u改为黑，g改为红，然后把g当成cur，继续向上调整。</p> 
<p>情况2：c为红，p为红，g为黑，u不存在或者存在且为黑（c/p/g成直线）。</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/49/b0/MrclizJh_o.png" width="733"> p为g的左孩子，cur为p的左孩子，则进行右单旋转；相反，<br> p为g的右孩子，cur为p的右孩子，则进行左单旋转<br> p、g变色--p变黑，g变红</p> 
<p>情况3：c为红，p为红，g为黑，u不存在或者存在且为黑（c/p/g成一条折线）。</p> 
<p><img alt="" height="487" src="https://images2.imgbox.com/7a/22/o2y5RfEy_o.png" width="754"> p为g的左孩子，cur为p的右孩子，则针对p做左单旋转；相反，<br> p为g的右孩子，cur为p的左孩子，则针对p做右单旋转<br> 则转换成了情况2，按照情况2进行处理。<br> 红黑树和AVL树对比：<br> 查询效率方面，极端场景下AVL -- log_2 N，红黑树2*log_2 N，AVl树略优。但是由于红黑树不追追求绝对的平衡，降低了旋转次数，在经常需要增删的结构中红黑树更优，实际应用中红黑树更多。</p> 
<h4 id="unordered_map%2Fset">unordered_map/set</h4> 
<h5 id="unordered_map%2Fset%E4%BB%8B%E7%BB%8D" style="background-color:transparent;">unordered_map/set介绍</h5> 
<p>unordered系列的关联式容器在使用方式上和map/set基本相似，只是底层结构不同。上文提到的红黑树效率在查询时效率可以达到logN，当树中节点非常多的时候，查询效率也不理想。unordered系列容器的底层结构使用的是哈希表，查询效率O(1)。</p> 
<h5 id="%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8" style="background-color:transparent;">底层结构：哈希表</h5> 
<p>构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立<br> 一一映射的关系，那么在查找时通过该函数可以很快找到该元素。</p> 
<p><strong>开散列（哈希桶）</strong></p> 
<p>开散列法又叫链地址法(开链法)，首先对关键码集合用散列函数计算散列地址，具有相同地<br> 址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链<br> 接起来，各链表的头结点存储在哈希表中。</p> 
<p class="img-center"><img alt="" height="443" src="https://images2.imgbox.com/57/d1/CGwHkgvd_o.png" width="476"></p> 
<p><strong>哈希冲突</strong>：不同的关键字通过相同的哈希函数计算出相同的哈希地址，该中现象被称为哈希冲突或哈希碰撞。</p> 
<p><strong>哈希函数</strong>：哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突。哈希函数设计原则要注意一下几点：</p> 
<p>1.哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值<br> 域必须在0到m-1之间。<br> 2.哈希函数计算出来的地址能均匀分布在整个空间中。<br> 3.哈希函数应该比较简单。</p> 
<p><strong>直接定址法</strong>：取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B。<br> 优点：简单、均。<br> 缺点：需要事先知道关键字的分布情况。<br> 使用场景：适合查找比较小且连续的情况。</p> 
<p><strong>除留余数法</strong>：设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：Hash(key) = key% p(p&lt;=m),将关键码转换成哈希地址。</p> 
<p><strong>开散列增容</strong>：桶的个数是一定的，随着元素的不断插入，每个桶中元素的个数不断增多，极端情况下，可能会导致一个桶中链表节点非常多，会影响的哈希表的性能，因此在一定条件下需要对哈希<br> 表进行增容，那该条件怎么确认呢？开散列最好的情况是：每个哈希桶中刚好挂一个节点，再继续插入元素时，每一次都会发生哈希冲突，因此，在元素个数刚好等于桶的个数时，可以给哈希表增容。</p> 
<p><strong>开散列与闭散列比较</strong>：应用链地址法处理溢出，需要增设链接指针，似乎增加了存储开销。事实上：由于开地址法必须保持大量的空闲空间以确保搜索效率，如二次探查法要求装载因子a &lt;=<br> 0.7，而表项所占空间又比指针大的多，所以使用链地址法反而比开地址法节省存储空间</p> 
<h4 id="%E7%9F%A5%E8%AF%86%E8%80%83%E5%AF%9F" style="background-color:transparent;">知识考察</h4> 
<p>map和set之间的区别？</p> 
<p>1.map存储的是键值对&lt;k，v&gt;,set中只放value,底层存的是&lt;v,v&gt;的键值对。</p> 
<p>2.map重载了[],可以通过operator[]进行插入查找，返回值是key对应value的引用，可以对value修改。set的修改方式是先删除这个元素在进行插入。</p> 
<p>map和unordered_map之间的区别？<br> 1.底层结构不同，map底层是红黑树，unordered_map的底层是哈希表。</p> 
<p>2.unordered_map使用迭代器遍历，得到的数据是无序的，map遍历得到的是有序的序列。</p> 
<p>3.一般情况下，unordered_map的查询效率比map更快。</p> 
<p>4.从内存存角度来说hash因为底层维护了哈希表的存在，内存消耗远大于红黑树，但是因为哈希表增删查改时的直接映射，使其增删查效率来说可以做到平均O(1),对数据修改较多且不考虑内存问题的场景可以优先考虑hash。</p> 
<p>5.红黑树是基于搜索树设计的，具有天然的有序性，hash因为存在哈希冲突所以不能保证存储的数据有序，那么对数据存储存在有序性需求的优先使用红黑树。</p> 
<p>一个类型想要做map的key，有什么要求吗？</p> 
<p>1.能取模或者配一个仿函数能够转换成整型取模。</p> 
<p>2.支持 == 比较。</p> 
<h2 id="%E9%80%82%E9%85%8D%E5%99%A8">适配器</h2> 
<p class="img-center"><img alt="" height="175" src="https://images2.imgbox.com/42/2e/FfGUF3Qo_o.png" width="436"></p> 
<h4 id="stack">stack</h4> 
<p>stack是一种容器适配器，只能从容器的一端进行元素的插入与提取，后进先出。stack的底层容器可以是任何标准的容器类模板或者一些特定的容器类，这些容器类应该支持如下操作：（empty,back,push_back,pop_back）</p> 
<p class="img-center"><img alt="" height="353" src="https://images2.imgbox.com/ea/b5/WBvhnTTC_o.png" width="515"></p> 
<p>常用接口</p> 
<p>empty:检测stack是否为空。</p> 
<p>size:返回stack中的元素个数。</p> 
<p>top:返回栈顶元素的引用。</p> 
<p>push:将元素val压入stack中。</p> 
<p>pop:将stack中尾部的元素弹出。</p> 
<h4 id="queue">queue</h4> 
<p>队列是一种元素适配器，容器一端插入元素，另一端提取元素，先进先出。queue其底层容器类可以是标准容器类模板之一，也可以是专门设计的容器类，该底层容器类至少要支持如下操作：</p> 
<p>empty、size、front、back、push_back、pop_front。</p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/5a/35/MtDB6PYG_o.png" width="1200"></p> 
<p> 常用接口使用：<br> empty：检测队列是否为空。</p> 
<p>size：返回队列中有效元素个数。</p> 
<p>front：返回队头元素的引用。</p> 
<p>back：返回队尾元素的引用。</p> 
<p>push： 在队尾将元素入队列。</p> 
<p>pop：队头元素出队列。</p> 
<h4 id="priority_queue">priority_queue</h4> 
<p>优先级队列默认使用vector作为其底层存储数据的容器，在vector上又使用了堆算法将vector中元素构造成堆的结构，因此priority_queue就是堆，所有需要用到堆的位置，都可以考虑使用priority_queue。注意：默认情况下priority_queue是大堆。如果想要创建小堆，通过greater改变比较方式。<br> 常用接口：</p> 
<p>empty：判断优先级队列是否为空。</p> 
<p>top：返回堆顶元素。</p> 
<p>push：向优先级队列中插入元素。</p> 
<p>pop：删除堆顶元素。</p> 
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8" style="background-color:transparent;">迭代器</h2> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8" style="background-color:transparent;">什么是迭代器</h3> 
<p>行为像指针一样的类型。可能是指针，也可能是被封装成的指针，让使用者不用关心容器的底层实现细节，可以用统一的方式轻松访问容器。</p> 
<h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89" style="background-color:transparent;">迭代器的定义</h3> 
<p>1.构造函数。</p> 
<p>2.具有指针类似的操作，重载operator*和operator-&gt;。</p> 
<p>3.迭代器要能够比较，重载operator!= 和operator==。</p> 
<p>4.迭代器要能够移动，重载operator++()/operator++(int),根据容器的底层数据结构决定是否要支持前置--和后置--。</p> 
<h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88" style="background-color:transparent;">迭代器失效</h3> 
<p>1.迭代器指向的位置是不可知的，野指针。</p> 
<p>如：vector扩容，导致的野指针问题。list/map删除(erase)节点，导致的野指针问题。</p> 
<p> 以vector扩容为例</p> 
<p class="img-center"><img alt="" height="426" src="https://images2.imgbox.com/e3/f2/PrWkVF5X_o.png" width="1171"></p> 
<p>2.迭代器指向的位置已经不在是原来的位置，意义变了。</p> 
<p>如:vector不扩容，但是挪动数据（插入或者删除），使迭代器指向的位置已经不是原来的位置。</p> 
<p>3.迭代器失效解决办法</p> 
<p>在使用前对迭代器重新赋值。</p> 
<h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB" style="background-color:transparent;">迭代器分类</h3> 
<p>1.单向迭代器：如forward_list、unordered_map/set。</p> 
<p>2.双向迭代器：如map/set、list。</p> 
<p>3.随机迭代器：如vector、string。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03f10b96565cf1fe137996626a8285f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux驱动 多路mdio网关网络问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cbcc9e8c9b656e6626cfc763f3fc1e52/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu18.04安装Nvidia驱动【全网不坑，超全步骤】（亲测～）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>