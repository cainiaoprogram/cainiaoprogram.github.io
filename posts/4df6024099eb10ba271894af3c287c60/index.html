<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>移动开发之Wifi列表获取功能 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="移动开发之Wifi列表获取功能" />
<meta property="og:description" content="一、场景
业务需要通过App给设备配置无线网络连接，所以需要App获取附近的WiFi列表，并进行网络连接验证。
二、安卓端实现
1、阅读谷歌官网文档，关于Wifi 接口使用
https://developer.android.com/guide/topics/connectivity/wifi-scan?hl=zh-cn
文档的使用流程说的相当明了清晰，注册--扫描--获取。
但是其提到了关于Android 10 以上版本的特别说明， 而且看到代码中：
标明接口过期，但是实际调试使用，发现在10以上版本中也是能正常接收到广播获取扫描结果的。只要申请号对应的权限：
&lt;uses-permission android:name=&#34;android.permission.ACCESS_COARSE_LOCATION&#34; /&gt; &lt;uses-permission android:name=&#34;android.permission.ACCESS_FINE_LOCATION&#34; /&gt; &lt;uses-permission android:name=&#34;android.permission.INTERNET&#34; /&gt; &lt;uses-permission android:name=&#34;android.permission.ACCESS_WIFI_STATE&#34; /&gt; &lt;uses-permission android:name=&#34;android.permission.CHANGE_WIFI_STATE&#34; /&gt; &lt;uses-permission android:name=&#34;android.permission.ACCESS_NETWORK_STATE&#34; /&gt; &lt;uses-permission android:name=&#34;android.permission.CHANGE_NETWORK_STATE&#34; /&gt; 权限当然也需要动态申请：
ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION},WIFI_REQUEST_FOR_PERMISSION); Android13 权限额外需求：
https://developer.android.com/guide/topics/connectivity/wifi-permissions
NEARBY_WIFI_DEVICES 这个在实际调试过程中发现，加了和没加都能够获取到wifi列表数据。
另外需要注意的是，定位权限是一回事，手机系统有没有打开定义又是另外一回事，所以在使用此功能前要先判断定位开关是否打开：
// 通过GPS卫星定位，定位级别可以精确到街（通过24颗卫星定位，在室外和空旷的地方定位准确、速度快） boolean gps = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER); // 通过WLAN或移动网络(3G/2G)确定的位置（也称作AGPS，辅助GPS定位。主要用于在室内或遮盖物（建筑群或茂密的深林等）密集的地方定位） boolean network = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER); if (gps || network) { return true; } 再者就是WLAN 的开关有没有打开，安卓10以下的可以直接通过代码设置，10以上的需要跳转到设置界面，引导用户打开：
int wifiState = wifiManager.getWifiState(); if (WifiManager." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4df6024099eb10ba271894af3c287c60/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-27T15:18:21+08:00" />
<meta property="article:modified_time" content="2023-07-27T15:18:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">移动开发之Wifi列表获取功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、场景</p> 
<p>业务需要通过App给设备配置无线网络连接，所以需要App获取附近的WiFi列表，并进行网络连接验证。</p> 
<p></p> 
<p>二、安卓端实现</p> 
<p>1、阅读谷歌官网文档，关于Wifi 接口使用</p> 
<p><a href="https://developer.android.com/guide/topics/connectivity/wifi-scan?hl=zh-cn" rel="nofollow" title="https://developer.android.com/guide/topics/connectivity/wifi-scan?hl=zh-cn">https://developer.android.com/guide/topics/connectivity/wifi-scan?hl=zh-cn</a><img alt="" height="631" src="https://images2.imgbox.com/7d/0f/695hqvqX_o.png" width="1125"></p> 
<p></p> 
<p>文档的使用流程说的相当明了清晰，注册--扫描--获取。</p> 
<p>但是其提到了关于Android 10 以上版本的特别说明， 而且看到代码中：<br><img alt="" height="270" src="https://images2.imgbox.com/0a/4f/oc4ahRJs_o.png" width="903"></p> 
<p>标明接口过期，但是实际调试使用，发现在10以上版本中也是能正常接收到广播获取扫描结果的。只要申请号对应的权限：</p> 
<blockquote> 
 <pre>&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;
&lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
&lt;uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" /&gt;</pre> 
</blockquote> 
<p>权限当然也需要动态申请：</p> 
<blockquote> 
 <pre>ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION},WIFI_REQUEST_FOR_PERMISSION);</pre> 
</blockquote> 
<p></p> 
<p>Android13 权限额外需求：</p> 
<p><a href="https://developer.android.com/guide/topics/connectivity/wifi-permissions" rel="nofollow" title="https://developer.android.com/guide/topics/connectivity/wifi-permissions">https://developer.android.com/guide/topics/connectivity/wifi-permissions</a></p> 
<pre><strong>NEARBY_WIFI_DEVICES</strong></pre> 
<p>这个在实际调试过程中发现，加了和没加都能够获取到wifi列表数据。</p> 
<p></p> 
<p></p> 
<p>另外需要注意的是，定位权限是一回事，手机系统有没有打开定义又是另外一回事，所以在使用此功能前要先判断定位开关是否打开：</p> 
<blockquote> 
 <pre>// 通过GPS卫星定位，定位级别可以精确到街（通过24颗卫星定位，在室外和空旷的地方定位准确、速度快）
boolean gps = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);
// 通过WLAN或移动网络(3G/2G)确定的位置（也称作AGPS，辅助GPS定位。主要用于在室内或遮盖物（建筑群或茂密的深林等）密集的地方定位）
boolean network = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER);
if (gps || network) {
    return true;
}</pre> 
</blockquote> 
<p></p> 
<p>再者就是WLAN 的开关有没有打开，安卓10以下的可以直接通过代码设置，10以上的需要跳转到设置界面，引导用户打开：</p> 
<blockquote> 
 <pre>int wifiState = wifiManager.getWifiState();
if (WifiManager.WIFI_STATE_ENABLED != wifiState){
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {
        ToastUtil.makeText(mContext,"请打开WiFi开关");
        startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
        //startActivity(new Intent(Settings.Panel.ACTION_WIFI));
        finish();
    }else {
        wifiManager.setWifiEnabled(true);
    }
}</pre> 
</blockquote> 
<p></p> 
<p>2、网络连接验证调试</p> 
<p> 为了确认用户输入的密码是正确的，所以想对网络连接进行验证测试，此时就发现安卓10 上下版本的接口差异了：</p> 
<p>API29 以下</p> 
<p><a href="https://developer.android.com/reference/android/net/wifi/WifiManager#addNetwork%28android.net.wifi.WifiConfiguration%29" rel="nofollow" title="https://developer.android.com/reference/android/net/wifi/WifiManager#addNetwork(android.net.wifi.WifiConfiguration)">https://developer.android.com/reference/android/net/wifi/WifiManager#addNetwork(android.net.wifi.WifiConfiguration)</a></p> 
<p><img alt="" height="625" src="https://images2.imgbox.com/91/95/wYpBx8Ob_o.png" width="1176"></p> 
<pre>添加
wifiManager.addNetwork
使能
wifiManager.enableNetwork
移除，此处如果是设置里面原有保存的，则无法移除，需要引导
wifiManager.removeNetwork
</pre> 
<p></p> 
<p>AndroidQ 以后：</p> 
<p><a href="https://developer.android.com/guide/topics/connectivity/wifi-suggest?hl=zh-cn" rel="nofollow" title="https://developer.android.com/guide/topics/connectivity/wifi-suggest?hl=zh-cn">https://developer.android.com/guide/topics/connectivity/wifi-suggest?hl=zh-cn</a></p> 
<blockquote> 
 <pre>/**
 * Android API 29 之后的wifi连接验证
 * @param ssid  账号
 * @param pwd   密码， 目前都是用 WAP2 方式
 */
@RequiresApi(api = Build.VERSION_CODES.Q)
private void connectWifiAfterQ(String ssid, String pwd){
    WifiNetworkSpecifier.Builder builder = new WifiNetworkSpecifier.Builder();
    builder.setSsid(ssid);
    builder.setWpa2Passphrase(pwd);

    WifiNetworkSpecifier wifiNetworkSpecifier = builder.build();

    NetworkRequest.Builder networkRequestBuilder1 = new NetworkRequest.Builder();
    networkRequestBuilder1.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
    //networkRequestBuilder1.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
        networkRequestBuilder1.setNetworkSpecifier(wifiNetworkSpecifier);
    }

    NetworkRequest networkRequest = networkRequestBuilder1.build();
    ConnectivityManager cm = (ConnectivityManager)
            getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE);

    // 自己独有的callback中响应事件
    ConnectivityManager.NetworkCallback networkCallback = new
            ConnectivityManager.NetworkCallback() {
                @Override
                public void onAvailable(Network network) {
                    super.onAvailable(network);
                    Log.d(TAG, "onAvailable:" + network);
                    //让本App能够使用到此网络，此时系统其他应用是无法联网的，不知道是不是bug
                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
                        cm.bindProcessToNetwork(network);
                    }
                }

                @Override
                public void onLost(Network network) {
                    Log.d(TAG, "The application no longer has a default network. The last default network was " + network);
                }

                @Override
                public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                    Log.d(TAG, "The default network changed capabilities: " + networkCapabilities);
                }

                @Override
                public void onLinkPropertiesChanged(Network network, LinkProperties linkProperties) {
                    Log.d(TAG, "The default network changed link properties: " + linkProperties);
                }

                @Override
                public void onUnavailable() {
                    super.onUnavailable();
                    Log.d(TAG, "onUnavailable:");
                    EventBus.getDefault().post("onUnavailable");
                }
            };
    cm.requestNetwork(networkRequest, networkCallback);
}</pre> 
</blockquote> 
<p>这种安卓10以上版本的则需要使用suggestion方式去请求网络，但是目前调试发现一个问题就是通过App成功连接到网络之后，手机系统的其他应用则不能通过WiFi联网，而官网给出的移除网络API使用不生效:</p> 
<p><a href="https://developer.android.com/reference/android/net/wifi/WifiManager#removeNetworkSuggestions%28java.util.List%3Candroid.net.wifi.WifiNetworkSuggestion%3E%29" rel="nofollow" title="https://developer.android.com/reference/android/net/wifi/WifiManager#removeNetworkSuggestions(java.util.List%3Candroid.net.wifi.WifiNetworkSuggestion%3E)">https://developer.android.com/reference/android/net/wifi/WifiManager#removeNetworkSuggestions(java.util.List%3Candroid.net.wifi.WifiNetworkSuggestion%3E)</a></p> 
<p></p> 
<p>查找了一通资料，最后貌似好像看到说是谷歌系统的bug，至今可能还没有修复：</p> 
<p><a href="https://issuetracker.google.com/issues/140398818/resources" rel="nofollow" title="https://issuetracker.google.com/issues/140398818/resources">https://issuetracker.google.com/issues/140398818/resources</a></p> 
<p></p> 
<p>在国内的华米OV几大机型上都测试了，具有系统其他应用不能通过WIFI上网的问题，由此影响用户体验，所以最终不进行网络连接测试，改为上报wifi名称和密码，由设备自己去验证网络连接，然后在APP中展示联网效果，由此来看，其他的IoT设备，例如百度音响，是否也是这么实现，并没有通过App来改变手机本身系统的WiFi连接。</p> 
<p>但是安卓10以下版本是无此问题的。</p> 
<p></p> 
<p>参考实现demo:</p> 
<p><a href="https://github.com/zly394/WifiListDemo" title="https://github.com/zly394/WifiListDemo">https://github.com/zly394/WifiListDemo</a></p> 
<p><a href="https://github.com/lilongweidev/Android13Wifi" title="https://github.com/lilongweidev/Android13Wifi">https://github.com/lilongweidev/Android13Wifi</a></p> 
<p></p> 
<p>三、苹果端实现</p> 
<p><a href="https://developer.apple.com/documentation/networkextension/wi-fi_configuration/" rel="nofollow" title="​​​​​​https://developer.apple.com/documentation/networkextension/wi-fi_configuration/">​​​​​​https://developer.apple.com/documentation/networkextension/wi-fi_configuration/</a></p> 
<p>刚开始看文档，以为会很简单，调用几个接口即可实现。</p> 
<p><img alt="" height="774" src="https://images2.imgbox.com/a0/c4/e8w7tMLN_o.png" width="1200"></p> 
<p> 后来才知道这个所谓的热点助手才能实现获取列表功能，而且这个接口的使用权限要单独申请：<br><a href="https://developer.apple.com/contact/request/hotspot-helper/" rel="nofollow" title="https://developer.apple.com/contact/request/hotspot-helper/">https://developer.apple.com/contact/request/hotspot-helper/</a></p> 
<p>不出意外，这个申请果然被拒了，苹果认为只有运营商或者网络设备制造商才有需要此功能。</p> 
<blockquote> 
 <p>Thank you for your interest in the NEHotspotHelper API. This API is not designed for the use you’ve identified, so this request cannot be approved.<br><br> The NEHotspotHelper API is meant to be used by hotspot network implementers to connect their users to the internet via a large aggregated network of Wi-Fi Hotspots that they manage.</p> 
 <p></p> 
 <p>NEHotspotHelper was designed to facilitate internet hotspot network connections and is not appropriate for apps trying to do IoT accessory integration, Wi-Fi location, or other low-level Wi-Fi tasks like signal strength. Specifically, NEHotspotHelper does not let your app initiate a local Wi-Fi scan, or access iOS’ internal list of nearby SSIDs.  </p> 
 <p></p> 
 <p>Many perceived uses of NEHotspotHelper, such as the configuration of an IoT accessory, can be accomplished with <a href="https://developer.apple.com/documentation/networkextension/wi-fi_configuration" rel="nofollow" title="NEHotspotConfiguration">NEHotspotConfiguration</a>, which does not require an Apple-approved entitlement.</p> 
 <p></p> 
 <p>For information about enabling your app to configure an IoT accessory, please see the following article: <a href="https://developer.apple.com/documentation/networkextension/configuring_a_wi-fi_accessory_to_join_the_user_s_network" rel="nofollow" title="Configuring a Wi-Fi Accessory to Join the User’s Network">Configuring a Wi-Fi Accessory to Join the User’s Network</a></p> 
 <p></p> 
 <p>For a complete explanation of Wi-Fi management APIs on iOS, please see Technote TN3111: <a href="https://developer.apple.com/documentation/dts-technotes/tn3111-ios-wifi-api-overview" rel="nofollow" title="iOS Wi-Fi API Overview">iOS Wi-Fi API Overview</a>.<br><br> For further technical assistance please visit the <a href="https://forums.developer.apple.com/welcome" rel="nofollow" title="Apple Developer Forums">Apple Developer Forums</a>.</p> 
 <p></p> 
 <p>Thank You,</p> 
 <p>Apple Developer Relations</p> 
</blockquote> 
<p>于是只能退而求其次，通过用户手动输入WiFi名称和密码，App端来进行网络连接校验，这其中也遇到了权限问题：</p> 
<blockquote> 
 <p>-(NSString *)getCurrentWifi{<!-- --><br>     NSString * wifiName = @"";<br>     CFArrayRef wifiInterfaces = CNCopySupportedInterfaces();<br>     if (!wifiInterfaces) {<!-- --><br>         wifiName = @"";<br>     }<br>     NSArray *interfaces = (__bridge NSArray *)wifiInterfaces;<br>     for (NSString *interfaceName in interfaces) {<!-- --><br>         CFBridgingRetain(interfaceName);<br>         CFDictionaryRef dictRef = CNCopyCurrentNetworkInfo((__bridge CFStringRef)(interfaceName));<br>         if (dictRef) {<!-- --><br>             NSDictionary *networkInfo = (__bridge NSDictionary *)dictRef;<br>             wifiName = [networkInfo objectForKey:(__bridge NSString *)kCNNetworkInfoKeySSID];<br>             NSLog(@"接口查询当前连接的wifi名称为： %@", wifiName);<br>             CFRelease(dictRef);<br>         }<br>     }<br>     CFRelease(wifiInterfaces);<br>     NSLog(@"最终确认当前连接的wifi名称为： %@", wifiName);<br>     return wifiName;<br> }<br>  </p> 
</blockquote> 
<p>就是如上这段代码刚开始始终是获取不到当前连接的WiFi名称的，而网络上查询的资料大部分都是用此方法。后面无意中在发现一个告警日志：</p> 
<blockquote> 
 <p><br> sent invalid result code [1] for Wi-Fi information request</p> 
</blockquote> 
<p>通过网络搜索，原来需要开启capacity Access wifi information .</p> 
<p>而不只是引入这两个框架即可：</p> 
<blockquote> 
 <p>//连接wifi的框架<br> #import &lt;NetworkExtension/NetworkExtension.h&gt;<br> //获取当前wifi的框架<br> #import &lt;SystemConfiguration/CaptiveNetwork.h&gt;</p> 
</blockquote> 
<p>并且这个方法单独调用也是获取不到当前Wifi名称的，而是需要NEHotspotConfigurationManager 这个请求回调里面执行才可。（不知道是不是也只能查询到自己发起请求连接的WiFi，还是怎么回事）</p> 
<p></p> 
<blockquote> 
 <p> NEHotspotConfiguration * configuration = [[NEHotspotConfiguration alloc] initWithSSID:wifiName passphrase:passwd isWEP:NO];<br>     [[NEHotspotConfigurationManager sharedManager] applyConfiguration:configuration completionHandler:^(NSError * _Nullable error) {<!-- --><br>         <br>         if(error != nil){<!-- --><br>             NSLog(@"apply config error=%@ code=%ld", error.description, (long)error.code);<br>         }else{<!-- --><br>             NSLog(@"apply config success ? wifiName=%@, passwd=%@", wifiName, passwd);<br>         }<br>         //有时无法加入WIFI，没有返回error<br>         if ([[self getCurrentWifi] isEqualToString:wifiName]) {<!-- --><br>             if (error) {<!-- --><br>                 //无法加入网络，需移除<br>                 [[NEHotspotConfigurationManager sharedManager] removeConfigurationForSSID:wifiName];<br>                 if(error.code == NEHotspotConfigurationErrorAlreadyAssociated){<!-- --><br>                     //上报账号密码，这个是正确的连接， 应该不会出现这个逻辑了<br>                     NSLog(@"WiFi之前已经连接成功，不应该走这个逻辑了，前面每次都先移除了");<br>                     //[self ConfigSuccessBack];<br>                 }else{<!-- --><br>                     [self alertConfigInfoError:NSLocalizedString(@"wifiConfigAccountPasswordError", nil)];<br>                 }<br>                 <br>             }else{<!-- --><br>                 //连接wifi成功<br>                 NSLog(@"连接WiFi成功");<br>                 [self ConfigSuccessBack];<br>             }<br>         }else{<!-- --><br>             //无法加入网络，需移除<br>             [[NEHotspotConfigurationManager sharedManager] removeConfigurationForSSID:wifiName];<br>             [self alertConfigInfoError:NSLocalizedString(@"wifiConfigAccountPasswordError", nil)];<br>         }<br>     }];<br>  </p> 
</blockquote> 
<p></p> 
<p>总之一番操作之后，确认需要添加的Capacity 有如下三个：</p> 
<blockquote> 
 <p>+       com.apple.developer.networking.HotspotConfiguration</p> 
 <p>+       com.apple.developer.networking.networkextension</p> 
 <p>+       com.apple.developer.networking.wifi-info</p> 
</blockquote> 
<p>最终苹果端这边还是可以成功验证网络是否正常连接，而且不影响系统重其他应用上网。</p> 
<p></p> 
<p>一个看似很简单的功能，前前后后，各种零散问题分析查阅调试验证，安卓的各种机型和版本，苹果的各种权限和邮件回复，让这个功能还是弄了蛮久，关键是这种功能涉及敏感安全，为了防止滥用，系统平台随着自己的不断完善发展，对其限制要求会越来越严格。</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5eeb546a2c834674827b0b7cf882ceaf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024百度校招内推码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ff48284ac634bfba10be42f5e7f1e94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（二）docker无法访问github但可以访问gitee</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>