<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>泛型的用法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="泛型的用法" />
<meta property="og:description" content="为什么用泛型 早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题。
什么是泛型
● 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。
● 参数化类型，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式，然后在使用/调用时传入具体的类型。
泛型类
泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法.
泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。
一个最普通的泛型类：
public class Demo&lt;T&gt;{ / /T可以为任意标识符，常见的如T、E、K、V等形式的参数常用于表示泛型
private T key; / /key这个成员变量的类型为T,T的类型由外部指定
public Generic(T key) { / /泛型构造方法形参key的类型也为T，T的类型由外部指定
this.key = key;
}
public T getKey(){ / /泛型方法getKey的返回值类型为T，T的类型由外部指定
return key;
}
}
传入的实参类型需与泛型的类型参数类型相同，即为Integer.
Demo&lt;Integer&gt; genericInteger = new Demo&lt;Integer&gt;(123456);
1.泛型的类型参数只能是类类型。
2.泛型的类型参数可以有多个。
3.如果没有定义具体类型,默认为Object。
从泛型类派生子类
子类也是泛型类，子类和父类的泛型类型要一致
class A&lt;T&gt; extends Demo&lt;T&gt;
（1）父类是泛型类（没指定类型）
子类继承父类后，也是泛型类，子类定义类型后，父类类型也随之明确
子类不是泛型类，父类要明确泛型的数据类型
class A extends Demo&lt;String&gt;
（2）子类继承一个泛型类：如果子类 没有定义泛型，那么父类的类型必须在声明时就要明确下来
泛型接口
泛型接口与泛型类的定义及使用基本相同。
public interface Demo&lt;T&gt; { //定义一个泛型接口" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/de59247ea12c33a0adf042ca3065ae91/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-18T22:23:52+08:00" />
<meta property="article:modified_time" content="2023-04-18T22:23:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">泛型的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>为什么用泛型</h3> 
<p>       早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题。</p> 
<p><strong>什么是泛型</strong></p> 
<p>● 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。</p> 
<p>● 参数化类型，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式，然后在使用/调用时传入具体的类型。</p> 
<p><strong>泛型类</strong></p> 
<p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法.</p> 
<p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。</p> 
<p>一个最普通的泛型类：</p> 
<blockquote> 
 <p>public class Demo&lt;T&gt;{ / /T可以为任意标识符，常见的如T、E、K、V等形式的参数常用于表示泛型</p> 
 <p>        private T key; / /key这个成员变量的类型为T,T的类型由外部指定</p> 
 <p></p> 
 <p>public Generic(T key) { / /泛型构造方法形参key的类型也为T，T的类型由外部指定</p> 
 <p>        this.key = key;</p> 
 <p>        }</p> 
 <p></p> 
 <p>public T getKey(){ / /泛型方法getKey的返回值类型为T，T的类型由外部指定</p> 
 <p>    return key;</p> 
 <p>        }</p> 
 <p></p> 
 <p>}</p> 
 <p></p> 
 <p>传入的实参类型需与泛型的类型参数类型相同，即为Integer.</p> 
 <p>Demo&lt;Integer&gt; genericInteger = new Demo&lt;Integer&gt;(123456);</p> 
</blockquote> 
<p>  </p> 
<p>1.泛型的类型参数只能是类类型。</p> 
<p>2.泛型的类型参数可以有多个。</p> 
<p>3.如果没有定义具体类型,默认为Object。</p> 
<p><strong>从泛型类派生子类</strong></p> 
<p>       子类也是泛型类，子类和父类的泛型类型要一致</p> 
<blockquote> 
 <p>class A&lt;T&gt; extends Demo&lt;T&gt;</p> 
</blockquote> 
<p>（1）父类是泛型类（没指定类型）</p> 
<p>子类继承父类后，也是泛型类，子类定义类型后，父类类型也随之明确</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/42/94/8gzJ1xfr_o.png" width="717"></p> 
<p>子类不是泛型类，父类要明确泛型的数据类型</p> 
<blockquote> 
 <p>class A extends Demo&lt;String&gt;</p> 
</blockquote> 
<p>（2）子类继承一个泛型类：如果子类 没有定义泛型，那么父类的类型必须在声明时就要明确下来</p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/30/10/T43wDQg6_o.png" width="639"></p> 
<p><strong>泛型接口</strong></p> 
<p>泛型接口与泛型类的定义及使用基本相同。</p> 
<blockquote> 
 <p>public interface Demo&lt;T&gt; { //定义一个泛型接口</p> 
 <p>      public T next();</p> 
 <p>}</p> 
 <p></p> 
 <p>子类也是泛型类，子类和父类的泛型类型要一致</p> 
 <p>class A&lt;T&gt; implements Demo&lt;T&gt;{<!-- --></p> 
 <p>     @Override</p> 
 <p>       public T next() {<!-- --></p> 
 <p>             return null;</p> 
 <p>                   }</p> 
 <p></p> 
 <p>}</p> 
</blockquote> 
<p>  </p> 
<p><strong>泛型类,泛型接口</strong></p> 
<p>子类不是泛型类，父类要明确泛型的数据类型</p> 
<blockquote> 
 <p>public class A implements Demo&lt;String&gt; {<!-- --></p> 
 <p>      @Override</p> 
 <p>          public String next() {<!-- --></p> 
 <p>          return null;</p> 
 <p>              }</p> 
 <p>}</p> 
</blockquote> 
<h3>泛型通配符</h3> 
<p>● 什么是类型通配符？</p> 
<p>？类型通配符 任意的类型 表示实际参数的类型 （通常用于方法中）</p> 
<p>● 类型通配符一般是使用"？"代替具体的类型实参。</p> 
<p>● 所以，类型通配符是类型实参，而不是类型形参。</p> 
<blockquote> 
 <p>public void showKeyValue1(Demo&lt;Number&gt;  obj){<!-- --></p> 
 <p></p> 
 <p>}</p> 
 <p>Demo&lt;Integer&gt; gInteger = new Demo&lt;Integer&gt;(123);</p> 
 <p>Demo&lt;Number&gt; gNumber = new Demo&lt;Number&gt;(456);</p> 
 <p>showKeyValue(gNumber);</p> 
 <p>showKeyValue(gInteger);这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt;</p> 
</blockquote> 
<h3>重点：</h3> 
<p>● 类型通配符上限</p> 
<blockquote> 
 <p>类/接口&lt;？extends 实参类型&gt;</p> 
</blockquote> 
<p>（问号表示自己传入的实参类型只能是继承后面的实参类型或者和后面的实参类型相同）控制了传入该泛型实际类型的上面的类型要求该泛型的类型，只能是实参类型，或实参类型的子类类型。</p> 
<p><img alt="" height="61" src="https://images2.imgbox.com/e7/bf/UFC04LfJ_o.png" width="835"></p> 
<p>● 类型通配符下限</p> 
<blockquote> 
 <p>类/接口&lt;？super 实参类型&gt;</p> 
</blockquote> 
<p>（问号表示自己传入的实参类型只能是后面的实参类型的父类或者和后面的实参类型相同）控制了传入该泛型实际类型的下面的类型要求该泛型的类型，只能是实参类型，或实参类型的父类类型。</p> 
<h4><strong>类型擦除</strong></h4> 
<p>泛型是Java 1.5版本才引进的概念，在这之前是没有泛型的，但是，泛型代码能够很</p> 
<p>好地和之前版本的代码兼容。那是因为，泛型信息只存在于代码编译阶段，在进入JVM之 前，与泛型相关的信息会被擦除掉，我们称之为一类型擦除。泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p> 
<blockquote> 
 <p>List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();</p> 
 <p>List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();</p> 
 <p>System.out.println(l1.getClass() == l2.getClass());</p> 
</blockquote> 
<blockquote> 
 <p>打印的结果为 true 是因为 List&lt;String&gt;和 List&lt;Integer&gt;在 jvm 中的 Class 都是 List.class。</p> 
</blockquote> 
<p>泛型信息被擦除了。</p> 
<p>泛型类被类型擦除后，相应的类型就被替换成 Object 类型或者上限类型</p> 
<p><strong>类型擦除</strong></p> 
<p>案例:</p> 
<blockquote> 
 <p>public class Erasure &lt;T&gt;{<!-- --></p> 
 <p>       T object;</p> 
 <p>public Erasure(T object) {<!-- --></p> 
 <p>          this.object = object;</p> 
 <p>         }</p> 
 <p>}</p> 
 <p></p> 
 <p>//  Erasure 是一个泛型类，我们查看它在运行时的状态信息可以通过反射。</p> 
 <p>Erasure&lt;String&gt; erasure = new Erasure&lt;String&gt;("hello");</p> 
 <p>Field[] fs = eclz.getDeclaredFields();</p> 
 <p>for ( Field f:fs) {<!-- --></p> 
 <p>System.out.println("Field name "+f.getName()+" type:"+f.getType().getName());</p> 
 <p>}</p> 
</blockquote> 
<p> 输出结果</p> 
<blockquote> 
 <p>Field name object type:java.lang.Object</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/649c1e72fe2347c7693f1997324a2bd9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">using namespace std 是什么意思——C&#43;&#43;命名空间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/77c1215e94f35e3944da709c1f8fa871/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Docker下运行多个ClickHouse容器,在ReplicatedMergeTree引擎中借助Zookeeper同步数据时日志提示“DNS_ERROR”且数据同步失败的解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>