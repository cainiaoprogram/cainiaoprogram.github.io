<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>轻量级卷积神经网络综述 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="轻量级卷积神经网络综述" />
<meta property="og:description" content="inception 最初的版本 Inception/GoogleNet，其核心思想是利用多尺寸卷积核去观察输入数据，
于是我们的网络就变胖了，通过增加网络的宽度，提高了对于不同尺度的适应程度。但这样的话，计算量有点大了。
2.2 Pointwise Conv 为了减少在上面结构的参数量并降低计算量，于是在 Inception V1 的基础版本上加上了 1x1 卷积核，这就形成了 Inception V1 的最终网络结构，如 Figure 2。
这个 1x1 卷积就是 Pointwise Convolution（逐点卷积），简称 PW。利用它的目的主要是为了减少维度，还用于引入更多的非线性。
我们来简单计算下：假定上一层输出的 feature map 维度为 100x100x128，经过256个大小为 5x5 的卷积后，输出的 feature map 大小为 100x100x256。这里卷积参数为 256∗5∗5∗128=819,200。而假如上一层的输出先经过 32 个大小为 1x1 的卷积后，再经过256个大小为 5x5 的卷积，那么输出维度保持不变的情况下，卷积参数减少为 128∗1∗1∗32 &#43; 32∗5∗5∗256=204,800，降低为原来的1/4。
PW 主要用于数据降维，减少参数量。也有使用 PW 做升维的，在 MobileNet v2 中就使用 PW 将 feature map 的宽度扩张了6倍，丰富输入数据的特征。
2.3 Kernel Replace Inception V2 和 V3 版本为了进一步降低卷积参数采用小卷积来替换大卷积，同 VGG 套路。
大尺寸的卷积核可以带来更大的感受野，但也意味着会产生更多的参数，比如 5x5 卷积核的参数有 25 个，3x3 卷积核的参数有 9 个，前者是后者的 25/9=2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e59faf2fa21fae57dec9ac993c2dcd90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-09T17:27:14+08:00" />
<meta property="article:modified_time" content="2020-06-09T17:27:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">轻量级卷积神经网络综述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>inception</h2> 
<p>最初的版本 Inception/GoogleNet，其核心思想是利用多尺寸卷积核去观察输入数据，</p> 
<p><img alt="" src="https://images2.imgbox.com/71/69/vq1LIcTg_o.png"></p> 
<p>于是我们的网络就变胖了，通过增加网络的宽度，提高了对于不同尺度的适应程度。但这样的话，计算量有点大了。</p> 
<h3>2.2 Pointwise Conv</h3> 
<p>为了减少在上面结构的参数量并降低计算量，于是在 Inception V1 的基础版本上加上了 1x1 卷积核，这就形成了 Inception V1 的最终网络结构，如 Figure 2。</p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/0e/16/k1Y8gyQM_o.png" width="513"></p> 
<p>这个 1x1 卷积就是 Pointwise Convolution（逐点卷积），简称 PW。利用它的目的主要是为了减少维度，还用于引入更多的非线性。</p> 
<p>我们来简单计算下：假定上一层输出的 feature map 维度为 100x100x128，经过256个大小为 5x5 的卷积后，输出的 feature map 大小为 100x100x256。这里卷积参数为 256∗5∗5∗128=819,200。而假如上一层的输出先经过 32 个大小为 1x1 的卷积后，再经过256个大小为 5x5 的卷积，那么输出维度保持不变的情况下，卷积参数减少为 128∗1∗1∗32 + 32∗5∗5∗256=204,800，降低为原来的1/4。</p> 
<p>PW 主要用于数据降维，减少参数量。也有使用 PW 做升维的，在 <a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Sandler_MobileNetV2_Inverted_Residuals_CVPR_2018_paper.pdf" rel="nofollow">MobileNet v2</a> 中就使用 PW 将 feature map 的宽度扩张了6倍，丰富输入数据的特征。</p> 
<h3>2.3 Kernel Replace</h3> 
<p>Inception <a href="https://arxiv.org/pdf/1502.03167.pdf" rel="nofollow">V2</a> 和 <a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Szegedy_Rethinking_the_Inception_CVPR_2016_paper.pdf" rel="nofollow">V3</a> 版本为了进一步降低卷积参数采用小卷积来替换大卷积，同 VGG 套路。</p> 
<p><img alt="" src="https://images2.imgbox.com/95/c2/p29DM4GN_o.png"></p> 
<p>大尺寸的卷积核可以带来更大的感受野，但也意味着会产生更多的参数，比如 5x5 卷积核的参数有 25 个，3x3 卷积核的参数有 9 个，前者是后者的 25/9=2.78 倍。因此，GoogLeNet 团队提出可以用 2 个连续的 3x3 卷积层组成的小网络来代替单个的 5x5 卷积层(<a href="http://shu.hipoz.top/2020/06/06/use-2-3-3-replace-5-5/" rel="nofollow">为什么一个5*5的卷积核可以由两个3*3的卷积核替代</a>)，即在保持感受野范围的同时又减少了参数量。除了规整的的正方形，还有分解版本的 3x3 = 3x1 + 1x3，这个效果在深度较深的情况下比规整的卷积核更好（feature map 大小建议在 12 到 20 之间）。</p> 
<h3>2.4 Feature Map Downsample</h3> 
<p>一般情况下，如果想让图像缩小，可以有如下两种方式：</p> 
<p><img alt="" height="215" src="https://images2.imgbox.com/fe/58/RA2B9fLg_o.png" width="432"></p> 
<p>先 pooling 再作 Inception 卷积，或者先作 Inception 卷积再作 Pooling。前者先作 Pooling 会导致特征缺失遇到 bottleneck，后者则相对来说计算量更大。为了同时<strong>保持特征表示且降低计算量</strong>，<strong>将网络结构改为 Figure 5</strong>，使用两个并行化的模块来降低计算量（卷积、池化并行执行，再进行合并）。</p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/f2/bc/0Oiz73e0_o.png" width="792"></p> 
<h3>2.5 Bottleneck</h3> 
<p>Bottleneck 三步走：先 PW 对数据进行降维，再进行常规卷积，最后 PW 对数据进行升维，形如沙漏。</p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/45/f7/AAXlIxrF_o.png" width="292"></p> 
<p>这就是所谓的 <strong>Bottleneck 结构，</strong>上图中后者的计算量 256∗1∗1∗64+64∗3∗3∗64+64∗1∗1∗256=69,632 远小于前者 256∗3∗3∗256=589,824。</p> 
<h3>2.6 Inception + ResNet</h3> 
<p><img alt="" height="324" src="https://images2.imgbox.com/a4/15/5ICoXOVl_o.png" width="526"></p> 
<p>图7: Residual VS Residual+Inception</p> 
<h3>2.7 Group Conv  Depthwise Separable Conv</h3> 
<p>Group Convolution 分组卷积，最早见于AlexNet，当时受限于硬件，Group Convolution被用来切分网络，使其在2个GPU上并行运行。 对于常规卷积，输入为 IxHxW 大小的 Input Features，经过 O 个 KxKxI 大小的卷积核后，输出 Output Features 的通道数也是 O。这里的卷积参数量为 O∗K∗K∗I，输入和输出 map 的连接方式如下图左所示，输出的每个通道都和输入的所有通道相关联：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/d7/1d/qiBwK4E7_o.png" width="685"></p> 
<p>图8 标准卷积(左)和分组卷积(右)。后者通过将输入(和输出)分割成三个不相交的组来实现稀疏模式</p> 
<p>Group Conv 顾名思义，则是对输入 feature map 进行分组，然后每组分别卷积。假设输入 feature map 的尺寸仍为 IxHxW，输出 Output Features 的通道数也是 O，如果设定要分成 G 个 groups，则每组的输入 feature map 数量为I/G,每组的输出 feature map 的数量为O/G,每个卷积核的尺寸为 KxKx1/G,每组卷积核的数量为N/G，每组的卷积核数量为 N/G，卷积核的总数仍为 O 个，卷积核只与其同组的输入 map 进行卷积，卷积核的总参数量为 O∗K∗K∗I/G，可见，总参数量减少为原来的 1/G.</p> 
<p>其连接方式如上图右所示，group1 输出 map 数为 2，有 2 个卷积核，每个卷积核的 channel 数为 4，与 group1 的输入 map 的 channel 数相同，卷积核只与同组的输入 map 卷积，而不与其他组的输入 map 卷积。</p> 
<p>Group Conv 的用途包括：</p> 
<ul><li>减少参数数量，分成 G 组，则该层的参数量减少为原来的 1/G</li><li>Group Conv 可以看成是一种<em>structured</em> <em>sparse</em></li></ul> 
<h3>2.8 Summary</h3> 
<ul><li>多个不同尺寸的卷积核，提高对不同尺度特征的提取。</li><li>PW 卷积，降维或升维的同时，提高网络的表达能力。</li><li>多个小尺寸卷积核替代大卷积核，加深网络的同时减少参数量。</li><li>Bottleneck 结构，大大减少网络参数量。</li><li>DW 设计，再度减少参数量。</li></ul> 
<p> </p> 
<h2>7. Xception</h2> 
<p>  Xception 实际上就是从另一个角度来思考 Inception 的网络结构，同时在 Inception 的基础上将 Depthwise Separable Conv 发扬光大了！</p> 
<h3>7.1. The Inception Hypothesis</h3> 
<p>  初始的 Inception V 1 结构考虑从多尺度卷积核角度来观察输入数据的特征，Inception V3 则是从参数量和计算量角度来尝试改进。但我们也可以把 Inception V3 结构理解为：通过显式地将操作分解为一系列独立的<span style="color:#3399ea;"><strong>通道相关性</strong></span>和<span style="color:#3399ea;"><strong>空间相关性</strong></span>的学习，从而使得学习的过程变得更加简单和高效。具体来说，Inception V1 里各个卷积核需要同时学习空间上的相关性和通道间的相关性，结合了 spatial dimensions 和 channels dimensions；而 Inception V3 结构，先通过一组 1x1 PW 卷积来学习通道相关性，将输入数据映射到多个单独的小空间（降维了）,然后对于所有这些小空间，通过常规的 3×3 卷积，5×5 卷积等来学习空间相关性。因此，Inception 结构背后的基本假设是，通道相关性和空间相关性之间的耦合性已经充分分离，这样的话最好不要将它们联合起来学习。于是便有了 Xception：<strong>将通道相关性和空间相关性分开学习的结构设计。</strong></p> 
<h3>7.2. Extreme Inception</h3> 
<p>在 Inception 中，特征可以通过 1×1 卷积，3×3 卷积，5×5 卷积，pooling 等进行提取，Inception 结构将特征类型的选择留给网络自己训练，也就是将一个输入同时输给几种提取特征方式，然后做 concat 。Inception-v3的结构图如下:</p> 
<p><img alt="" src="https://images2.imgbox.com/df/41/tTBKhBeq_o.png"></p> 
<p>对 Inception-v3 进行简化，去除 Inception-v3 中的 avg pool 后，输入的下一步操作就都是 1×1 PW 卷积了：</p> 
<p><img alt="" src="https://images2.imgbox.com/3a/70/k5lfE3Z9_o.png"> </p> 
<p>再进一步假设，3 个 PW 卷积核统一起来变成共用一个 PW  卷积，后面的三个 3x3 卷积核则分别”负责“一部分通道（Group Conv)：</p> 
<p><img alt="" src="https://images2.imgbox.com/21/80/rtAPk3JJ_o.png"></p> 
<p>最后 Extreme Inception 闪亮登场，对 PW 卷积后的每个channel分别进行 3×3 卷积操作（Depthwise Conv, DW}），最后将结果 concat：</p> 
<p><img alt="" src="https://images2.imgbox.com/45/c5/K9KWe8h4_o.png"></p> 
<p>作者发现，在 Extreme Inception 模块中，用于学习空间相关性的 3×3 的 DW 卷积，和用于学习通道间相关性的 1×1 PW 卷积之间，<span style="color:#3399ea;">不使用非线性激活函数时，收敛过程更快、准确率更高。</span></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f83df51942261105c32f0c1389f80d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">select2的基本用法  allowClear</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/acad429d776e2e37c76244440005e013/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IntelliJ idea  登录和退出账户</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>