<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux驱动开发：uboot移植流程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux驱动开发：uboot移植流程" />
<meta property="og:description" content="前言：Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段 bootloader 程序。而 uboot 作为最常见的 bootloader 选择，是每个 Linux 驱动工程师必需掌握的。本文为博主总结的 uboot 移植笔记，包含作者总结的 uboot 启动流程概述，希望能给大家移植和学习 uboot 的时候提供参考与帮助。
实验硬件：imx6ull；uboot版本：2016.03 一、U-Boot简介 1.1 Bootloader介绍 Linux系统启动的第一个关键程序bootloader，也就是说芯片上电后先运行一段bootloader程序。bootloader 和 Linux 内核的关系 就跟 PC 上的 BIOS 和 Windows 的关系一样，bootloader 就相当于 BIOS。所以Linux 系统移植第一步就需要进行bootloader的移植，现有的bootloader有很多，比如：U-Boot、vivi、RedBoot 等，其中以 U-Boot 使用最为广泛。
常见的Bootloader：
1.2 uboot启动流程 1、uboot的读取方式
(1)、SD卡读取；(2)、Flash读取；(考虑到部分Linux开发板的Flash为NAND Flash每次重写烧入需要反复擦除后重写，为了保证Flash的寿命，大都采用SD卡读取启动的方式)
2、uboot的启动流程
uboot的两大主题：（1）稳定性；（2）速度；
稳定性分析：uboot作为芯片上电第一道运行的程序，如果它出错将导致后续内核启动，根文件系统挂载等都无从谈起。
速度分析：uboot的速度是直接与性能挂钩的，uboot为了提升自身速度，会选择自挂载和挂载内核到内存上运行，提升速度。
★作者将uboot的总体启动流程分为2部分：arch级初始化(架构)和板级初始化。
uboot启动流程总结：
uboot的语言构成：10%的汇编语言；90%的C语言
uboot的启动特性：稳定性；速度
uboot的简化版启动流程：
1、设置状态寄存器 cpsr ，使CPU进入 SVC 特权模式，并且禁止 FIQ 和 IRQ；
2、关闭看门狗、中断、MMU、Cache；
3、初始化部分寄存器和外设（时钟、串口、Flash、内存）；
4、自搬移uboot到内存中运行；
5、设置栈空间并初始化global_data；
6、剩余大部分硬件的初始化；
7、搬移Linux内核到内存；
推荐学习博客：Linux驱动开发：uboot启动流程详解_uboot启动linux_混分巨兽龙某某的博客-CSDN博客" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/43aac739eb81c8e98041745eaf857b8d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-12T11:31:17+08:00" />
<meta property="article:modified_time" content="2023-07-12T11:31:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux驱动开发：uboot移植流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言：</strong><strong>Linux</strong> 系统要启动就必须需要一个 <strong>bootloader </strong>程序，也就说芯片上电以后先运行一段  <strong>bootloader</strong> 程序。而 <strong>uboot </strong>作为最常见的 <strong>bootloader</strong> 选择，是每个 <strong>Linux </strong>驱动工程师必需掌握的。本文为博主总结的<strong> uboot </strong>移植笔记，包含作者总结的 <strong>uboot</strong> 启动流程概述，希望能给大家移植和学习<strong> uboot </strong>的时候提供参考与帮助。</p> 
<p><strong>实验硬件：imx6ull；uboot版本：2016.03</strong> </p> 
<h2>一、U-Boot简介</h2> 
<h3>1.1 Bootloader介绍</h3> 
<p><span style="color:#0d0016;">Linux系统启动的第一个关键程序</span><span style="color:#fe2c24;"><strong>bootloader</strong></span><span style="color:#0d0016;">，也就是说芯片上电后先运行一段</span><span style="color:#000000;">bootloader</span><span style="color:#000000;">程序</span>。<span style="color:#000000;">bootloader </span><span style="color:#000000;">和 </span><span style="color:#000000;">Linux </span><span style="color:#000000;">内核的关系 就跟 </span><span style="color:#000000;">PC </span><span style="color:#000000;">上的 </span><span style="color:#000000;">BIOS </span><span style="color:#000000;">和 </span><span style="color:#000000;">Windows </span><span style="color:#000000;">的关系一样，</span><span style="color:#000000;">bootloader </span><span style="color:#000000;">就相当</span><span style="color:#000000;">于</span><span style="color:#000000;"> BIOS</span><span style="color:#000000;">。所以</span><span style="color:#000000;">Linux </span><span style="color:#000000;">系统移植第一步就需要进行</span><span style="color:#000000;">bootloader</span><span style="color:#000000;">的移植，现有的</span><span style="color:#000000;">bootloader</span><span style="color:#000000;">有很多，比如：</span><span style="color:#000000;">U-Boot</span><span style="color:#000000;">、</span><span style="color:#000000;">vivi</span><span style="color:#000000;">、</span><span style="color:#000000;">RedBoot </span><span style="color:#000000;">等，其中以 </span><span style="color:#000000;">U-Boot </span><span style="color:#000000;">使用最为广泛。</span></p> 
<p><strong>常见的Bootloader：</strong></p> 
<p class="img-center"><img alt="" height="495" src="https://images2.imgbox.com/d3/b8/Pw0L0H6k_o.png" width="1034"></p> 
<h3>1.2 uboot启动流程</h3> 
<p><strong><span style="color:#0d0016;">1、uboot的读取方式</span></strong></p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">(1)、SD卡读取；</span></strong><span style="color:#0d0016;">(2)、Flash读取；(考虑到部分Linux开发板的Flash为NAND Flash每次重写烧入需要反复擦除后重写，为了保证Flash的寿命，大都采用SD卡读取启动的方式)</span></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>2、uboot的启动流程</strong></span></p> 
<blockquote> 
 <p><strong>uboot的两大主题：（1）稳定性；（2）速度；</strong></p> 
 <p><strong>稳定性分析：</strong>uboot作为芯片上电第一道运行的程序，如果它出错将导致后续内核启动，根文件系统挂载等都无从谈起。</p> 
 <p><strong>速度分析</strong>：uboot的速度是直接与性能挂钩的，uboot为了提升自身速度，会选择<span style="color:#fe2c24;"><strong>自挂载</strong></span>和<span style="color:#fe2c24;"><strong>挂载内核</strong></span>到内存上运行，提升速度。</p> 
</blockquote> 
<p><strong>★</strong>作者将uboot的总体启动流程分为2部分：<span style="color:#fe2c24;"><strong>arch级初始化(架构)</strong></span>和<span style="color:#fe2c24;"><strong>板级初始化</strong></span>。</p> 
<p><img alt="" src="https://images2.imgbox.com/c2/ec/ZxskBPU3_o.png"></p> 
<p><strong>uboot启动流程总结：</strong></p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">uboot的语言构成：</span>10%的汇编语言；90%的C语言</strong></p> 
 <p><strong><span style="color:#fe2c24;">uboot的启动特性：</span>稳定性；速度</strong></p> 
 <p><span style="color:#fe2c24;"><strong>uboot的简化版启动流程：</strong></span></p> 
 <p><strong>1、设置状态寄存器 cpsr ，使CPU进入 SVC 特权模式，并且禁止 FIQ 和 IRQ；</strong></p> 
 <p><strong>2、关闭看门狗、中断、MMU、Cache；</strong></p> 
 <p><strong>3、初始化部分寄存器和外设（时钟、串口、Flash、内存）；</strong></p> 
 <p><strong>4、自搬移uboot到内存中运行；</strong></p> 
 <p><strong>5、设置栈空间并初始化global_data；</strong></p> 
 <p><strong>6、剩余大部分硬件的初始化；</strong></p> 
 <p><strong>7、搬移Linux内核到内存；</strong></p> 
</blockquote> 
<p><strong>推荐学习博客：</strong><a href="https://blog.csdn.net/black_sneak/article/details/130292138?spm=1001.2014.3001.5502" title="Linux驱动开发：uboot启动流程详解_uboot启动linux_混分巨兽龙某某的博客-CSDN博客">Linux驱动开发：uboot启动流程详解_uboot启动linux_混分巨兽龙某某的博客-CSDN博客</a></p> 
<h2>二、uboot移植教学</h2> 
<blockquote> 
 <p>嵌入式工程必备的技能就是贯通，需要从一种开发板的学习去学会其他开发板的大致开发流程（以一窥视万物）。</p> 
</blockquote> 
<h3>2.1 NXP官方uboot移植 </h3> 
<p>为了保证产品研发的速度以及降低研发过程中错误率，公司产品一般都会以半导体厂商的开发板作为 ”蓝本“。自然地，uboot 的移植和使用肯定也是可以直接借鉴该 ”蓝本“。</p> 
<p><span style="color:#fe2c24;"><strong>NXP 官方原版的 Uboot 发送到 Ubuntu 中并解压，然后创建 VSCode 工程。</strong></span></p> 
<p>在 NXP 官方原版的 Uboot 中的 configs 中提供了很多的默认配置文件，其中以 mx6ul 开头的是 I.MX6UL 芯片的，mx6ull 开头的是 I.MX6ULL 开发板的。我们以关联性最强的 <span style="color:#fe2c24;"><strong>mx6ull_14x14_evk_emmc_defconfig</strong></span> 作为默认配置文件。</p> 
<p>为了方便后续进行修改编译，作者建议编写如下的 shell 脚本（详情见代码注释），shell 脚本名为 mx6ull_14x14_emmc.sh，代码如下：</p> 
<pre><code class="language-bash">#!/bin/bash
#清理工程，每次编译uboot之前都清理一下工程
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean
#配置uboot，选择与自己开发板最接近的uboot配置文件进行编译，方便后期修改
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig
#“make -j12”也就是使用 12 核来编译 uboot；v=1是设置编译过程的信息输出级别，1完全输出，0/无简化
make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12
</code></pre> 
<p>通过命令行：<span style="color:#fe2c24;"><strong>chmod 777 mx6ull_14x14_emmc.sh</strong></span> 赋予 shell 脚本可执行权限！通过下述命令运行该 shell 脚本：</p> 
<pre><code class="language-bash">./mx6ull_14x14_emmc.sh</code></pre> 
<p>编译完成以后会生成 <strong>u-boot.bin</strong>、<strong>u-boot.imx </strong>等文件，但是这些文件是<strong> NXP</strong> 官方<span style="color:#fe2c24;"><strong> I.MX6ULL EVK</strong></span> 开发板。 </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/cd/fe/JgDZGqVz_o.png" width="1200"></p> 
<p>将 <span style="color:#fe2c24;"><strong>imxdownload </strong></span>软件拷贝到 uboot 源码根目录下，然后使用 <span style="color:#fe2c24;"><strong>imxdownload</strong></span> 软件将 <span style="color:#fe2c24;"><strong>u-boot.bin</strong></span> 烧写到<span style="color:#fe2c24;"><strong> SD</strong></span> 卡中，烧写命令如下：</p> 
<pre><code class="language-bash">chmod 777 imxdownload //给予 imxdownload 可执行权限
./imxdownload u-boot.bin /dev/sdb //烧写到 SD 卡中，不能烧写到/dev/sda 或 sda1 里面</code></pre> 
<blockquote> 
 <p>友情提示：SD 卡在 Linux 系统下的设备名称不一定是sdd亦或是sdb，通过：sudo fdisk -l 命令去检查一下 SD 卡到底是什么之后再进行烧入！</p> 
</blockquote> 
<p><img alt="" height="1048" src="https://images2.imgbox.com/10/13/uLMc4Wyn_o.png" width="1200"></p> 
<p>烧写完成以后将 SD 卡插入 I.MX6U-ALPHA 开发板的 TF 卡槽中，最后设置开发板<span style="color:#fe2c24;"><strong>从 SD 卡启动</strong></span>。打开 <span style="color:#fe2c24;"><strong>MobaXterm</strong></span>，设置好开发板所使用的串口并打开，复位开发板，<span style="color:#fe2c24;"><strong>MobaXterm </strong></span>接收到如下图所示信息：</p> 
<p><img alt="" height="567" src="https://images2.imgbox.com/24/1a/OpTYqRKz_o.png" width="1143"></p> 
<blockquote> 
 <p><strong>uboot </strong>成功加载之后通常需要检查：(1)、SD 卡和 EMMC 驱动是否正常（常规情况下都是正常的），(2)、LCD 屏幕驱动是否正常（问题不大）；<span style="color:#fe2c24;"><strong>(3)、网络驱动是否正常（核心部分）</strong></span></p> 
</blockquote> 
<p>考虑到后续需要通过网络加载 Linux 内核镜像等，所以网络驱动是必不可缺的部分！</p> 
<p><strong>uboot</strong> 启动的时候提示<strong> <span style="color:#fe2c24;">“Board Net Initialization Failed”</span></strong> 和 <span style="color:#fe2c24;"><strong>“No ethernet found.”</strong></span> 这两行，说明网络驱动存在大问题。</p> 
<p><img alt="" height="731" src="https://images2.imgbox.com/84/a2/JvwzkeOz_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>作者概述：</strong>实际工作中， 一般情况下 SD 卡和 EMMC 等内存驱动都不会存在太大问题，核心部分的问题还是出现在<span style="color:#fe2c24;"><strong>网络驱动</strong></span>部分（<strong>比如：S3C2440</strong>）！！！</p> 
</blockquote> 
<h3>2.2 修改NXP官方uboot</h3> 
<p>先在 <strong>configs</strong> 目录下创建默认配置文件，复制 <strong>mx6ull_14x14_evk_emmc_defconfig</strong>，然后重命名为 <span style="color:#fe2c24;"><strong>mx6ull_alientek_emmc_defconfig</strong></span>，命令如下：</p> 
<pre><code class="language-bash">cd configs
cp mx6ull_14x14_evk_emmc_defconfig mx6ull_alientek_emmc_defconfig</code></pre> 
<p>然后将文件 <strong>mx6ull_alientek_emmc_defconfig</strong> 中的内容改成下面的：</p> 
<pre><code class="language-bash">CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_alientek_emmc/imximage.cfg,MX6ULL_EVK_EMMC_REWORK"
CONFIG_ARM=y
CONFIG_ARCH_MX6=y
CONFIG_TARGET_MX6ULL_ALIENTEK_EMMC=y
CONFIG_CMD_GPIO=y</code></pre> 
<p>可以看出，<strong>mx6ull_alientek_emmc_defconfig</strong> 基本和 <strong>mx6ull_14x14_evk_emmc_defconfig</strong> 中的内容一样，只是第 <strong>1</strong> 行和第 <strong>4</strong> 行做了修改。修改的 <strong>2</strong> 行就是编译 <strong>uboot</strong> 配置时可以根据自己复制的副本进行配置编译了！</p> 
<h4>2.2.1 添加开发板对应的头文件</h4> 
<p>在目录<strong> include/configs </strong>下添加 <strong>I.MX6ULL-ALPHA </strong>开 发 板 对 应 的 头 文 件 ， 复 制 <strong>include/configs/mx6ullevk.h</strong>，并重命名为 <strong>mx6ull_alientek_emmc.h</strong>，命令如下：</p> 
<pre><code class="language-bash">cp include/configs/mx6ullevk.h mx6ull_alientek_emmc.h</code></pre> 
<p>修改防止重定义的 <strong>#ifndef </strong>和 <strong>#define</strong> 的预处理代码：</p> 
<p><img alt="" height="1021" src="https://images2.imgbox.com/60/7e/nWCSgPfs_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>mx6ull_alientek_emmc.h</strong> 里面有很多宏定义，这些宏定义基本用于配置 <strong>uboot</strong>，也有一些 <strong>I.MX6ULL </strong>的配置项目。如果我们自己要想使能或者禁止 <strong>uboot</strong> 的某些功能，那就在 <strong>mx6ull_alientek_emmc.h</strong> 里面做修改即可。</p> 
</blockquote> 
<h4>2.2.2 添加开发板对应的板级文件夹</h4> 
<p><strong>uboot </strong>中每个板子都有一个对应的文件夹来存放板级文件，比如开发板上外设驱动文件等等。NXP 的 I.MX 系列芯片的所有板级文件夹都存放在 <span style="color:#fe2c24;"><strong>board/freescale</strong></span> 目录下，在这个目录下有个名为 <strong>mx6ullevk</strong> 的文件夹，这个文件夹就是 NXP 官方 I.MX6ULL EVK 开发板的板级文件夹。复制 mx6ullevk，将其重命名为 <strong>mx6ull_alientek_emmc</strong>，命令如下：</p> 
<pre><code class="language-bash">cd board/freescale/
cp mx6ullevk/ -r mx6ull_alientek_emmc</code></pre> 
<p>进入 <strong>mx6ull_alientek_emmc </strong>目录中 ， 将 其 中 的<strong> mx6ullevk.c </strong>文 件 重 命 名 为 <strong>mx6ull_alientek_emmc.c</strong>，命令如下：</p> 
<pre><code class="language-bash">cd mx6ull_alientek_emmc
mv mx6ullevk.c mx6ull_alientek_emmc.c</code></pre> 
<p><img alt="" height="1049" src="https://images2.imgbox.com/e2/fb/7FZ0ftKC_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>我们还需要对 mx6ull_alientek_emmc 目录下的文件做一些修改：</strong></span></p> 
<p><strong>1、修改 mx6ull_alientek_emmc 目录下的 Makefile 文件</strong></p> 
<p>将 <strong>mx6ull_alientek_emmc</strong> 下的 <span style="color:#fe2c24;"><strong>Makefile</strong></span> 文件内容改为如下所示：</p> 
<p><img alt="" height="725" src="https://images2.imgbox.com/8f/a1/8mKKxtKU_o.png" width="1200"></p> 
<p>第 6 行的 obj-y，改为 <span style="color:#fe2c24;"><strong>mx6ull_alientek_emmc.o</strong></span>，这样才会编译 <strong>mx6ull_alientek_emmc.c</strong> 这个文件。</p> 
<p><strong>2、修改 mx6ull_alientek_emmc 目录下的 imximage.cfg 文件</strong></p> 
<p>将 <strong>imximage.cfg</strong> 中的下面一句：PLUGIN board/freescale/mx6ullevk/plugin.bin 0x00907000</p> 
<p>改为：<strong>PLUGIN    board/freescale/mx6ull-alientek_emmc/plugin.bin 0x00907000</strong></p> 
<p><img alt="" height="1017" src="https://images2.imgbox.com/fa/47/0tPonjBf_o.png" width="1200"></p> 
<p><strong>3、修改 mx6ull_alientek_emmc 目录下的 Kconfig 文件</strong></p> 
<p>修改 <strong>Kconfig</strong> 文件，修改后的内容如下：</p> 
<pre><code class="language-bash">if TARGET_MX6ULL_ALIENTEK_EMMC 

config SYS_BOARD
	default "mx6ull_alientek_emmc"

config SYS_VENDOR
	default "freescale"

config SYS_CONFIG_NAME
	default "mx6ull_alientek_emmc"

endif</code></pre> 
<p><strong>4、修改 mx6ull_alientek_emmc 目录下的 MAINTAINERS 文件</strong></p> 
<p>修改 <strong>MAINTAINERS </strong>文件，修改后的内容如下：</p> 
<pre><code class="language-bash">MX6ULLEVK BOARD
M:	Peng Fan &lt;peng.fan@nxp.com&gt;
S:	Maintained
F:	board/freescale/mx6ull_alientek_emmc/
F:	include/configs/mx6ull_alientek_emmc.h
F:	configs/mx6ull_alientek_emmc_deconfig</code></pre> 
<h4>2.2.3 修改 U-Boot 图形界面配置文件</h4> 
<p><strong>uboot </strong>是支持图形界面配置。修改文件 <span style="color:#fe2c24;"><strong>arch/arm/cpu/armv7/mx6/Kconfig</strong></span> (如果用的 I.MX6UL 的话，应该修改 <strong>arch/arm/Kconfig </strong>这个文件)，在 <strong>207</strong> 行加入如下内容：</p> 
<pre><code class="language-bash">config TARGET_MX6ULL_ALIENTEK_EMMC
	bool "Support mx6ull_alientek_emmc"
	select MX6ULL
	select DM
	select DM_THERMAL	
</code></pre> 
<p>在最后一行的 <strong>endif </strong>的前一行添加如下内容：</p> 
<pre><code class="language-bash">source "board/freescale/mx6ull_alientek_emmc/Kconfig"</code></pre> 
<p><img alt="" height="1025" src="https://images2.imgbox.com/b0/6a/thzRrQE9_o.png" width="1200"></p> 
<blockquote> 
 <p>上述操作都是为了能够创建出自己制作的开发板的编译和配置文件，这样以后就可以在自己创建的副本中改动，不需要在半导体厂商提供的 ”蓝本“ 代码上改动！</p> 
</blockquote> 
<h3>2.3 LCD驱动修改</h3> 
<p>一般 <strong>uboot </strong>中修改驱动基本都是在 <span style="color:#fe2c24;"><strong>xxx.h</strong></span> 和 <span style="color:#fe2c24;"><strong>xxx.c</strong> </span>这两个文件中进行的，<span style="color:#fe2c24;"><strong>xxx 为板子名称</strong></span>，比如 <strong>mx6ull_alientek_emmc.h</strong> 和 <strong>mx6ull_alientek_emmc.c </strong>这两个文件。</p> 
<p><img alt="" height="1076" src="https://images2.imgbox.com/39/b9/Xknn3rlB_o.png" width="1200"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>一般修改 LCD 驱动重点注意以下几点：</strong></span><br><strong>①、</strong>LCD 所使用的 GPIO，查看 uboot 中 LCD 的 IO 配置是否正确。<br><strong>②、</strong>LCD 背光引脚 GPIO 的配置。<br><strong>③、</strong>LCD 配置参数是否正确。</p> 
</blockquote> 
<p>正点原子的 <strong>I.MX6U-ALPHA </strong>开发板 <strong>LCD</strong> 原理图和 <strong>NXP</strong> 官方 <strong>I.MX6ULL</strong> 开发板一致，也就是 LCD 的 IO 和背光 IO 都一样的，所以 IO 部分就不用修改了。需要修改的是 LCD 参数，打开文件 <strong>mx6ull_alientek_emmc.c</strong>，找到如下所示内容：</p> 
<pre><code class="language-cpp">struct display_info_t const displays[] = {<!-- -->{
	.bus = MX6UL_LCDIF1_BASE_ADDR,
	.addr = 0,
	.pixfmt = 24,
	.detect = NULL,
	.enable	= do_enable_parallel_lcd,
	.mode	= {
		.name			= "TFT43AB",
		.xres           = 480,
		.yres           = 272,
		.pixclock       = 108695,
		.left_margin    = 8,
		.right_margin   = 4,
		.upper_margin   = 2,
		.lower_margin   = 4,
		.hsync_len      = 41,
		.vsync_len      = 10,
		.sync           = 0,
		.vmode          = FB_VMODE_NONINTERLACED
        } 
    } 
};</code></pre> 
<p>代码中定义了一个变量 <strong>displays</strong>，类型为 <span style="color:#fe2c24;"><strong>display_info_t</strong></span>，这个结构体是 LCD 信息结构体，其中包括了 LCD 的分辨率，像素格式，LCD 的各个参数等。 我们需要根据自己 LCD 屏幕的参数去修改该 <strong>displays</strong> 变量内的数据，作者是 7 寸屏幕，修改后如下：</p> 
<pre><code class="language-cpp">struct display_info_t const displays[] = {<!-- -->{
	.bus = MX6UL_LCDIF1_BASE_ADDR,
	.addr = 0,
	.pixfmt = 24,
	.detect = NULL,
	.enable	= do_enable_parallel_lcd,
	.mode	= {
		.name			= "TFT7016",
		.xres           = 1024,
		.yres           = 600,
		.pixclock       = 19531,
		.left_margin    = 140,
		.right_margin   = 160,
		.upper_margin   = 20,
		.lower_margin   = 12,
		.hsync_len      = 20,
		.vsync_len      = 3,
		.sync           = 0,
		.vmode          = FB_VMODE_NONINTERLACED
        } 
    } 
};</code></pre> 
<p>打开<strong> mx6ull_alientek_emmc.h</strong>，找到所有如下语句：</p> 
<blockquote> 
 <p><strong>panel = TFT43AB </strong>改为 <span style="color:#fe2c24;"><strong>panel = TFT7016</strong></span></p> 
</blockquote> 
<p><img alt="" height="1132" src="https://images2.imgbox.com/a8/84/A4mwO5WB_o.png" width="1200"></p> 
<h3>2.4 网络驱动修改</h3> 
<blockquote> 
 <p>网络驱动的修改是非常繁琐且重要的，因为后续<strong> Linux</strong> 内核的加载，虚拟根文件系统 <strong>rootfs</strong> 都离不开网络驱动的支持。</p> 
</blockquote> 
<h4>2.4.1 I.MX6U-ALPHA 开发板网络简介</h4> 
<p><strong>I.MX6UL/ULL </strong>内部有个以太网 <strong>MAC</strong> 外设，也就是 <span style="color:#fe2c24;"><strong>ENET</strong></span>，需要外接一个 <span style="color:#fe2c24;"><strong>PHY</strong></span> 芯片来实现网络通信功能，也就是<span style="color:#fe2c24;"><strong>内部 MAC+外部 PHY 芯片</strong></span>的方案。大家可能听过 <strong>DM9000</strong> 这个网络芯片，在一些没有内部 <strong>MAC</strong> 的 <strong>CPU</strong> 中，比如三星的 2440，4412 等，就会采用<strong> DM9000</strong> 来实现联网功能。<strong>DM9000</strong> 提供了一个类似 <strong>SRAM </strong>的访问接口，主控 <strong>CPU</strong> 通过这个接口即可与 <strong>DM9000</strong> 进行通信，<strong>DM9000 </strong>就是一个 <strong>MAC+PHY</strong> 芯片。</p> 
<p><strong>I.MX6UL/ULL </strong>有两个网络接口 <strong>ENET1</strong> 和 <strong>ENET2</strong>，正点原子的<strong> I.MX6U-ALPHA </strong>开发板提供了这两个网络接口，其中<strong> ENET1</strong> 和 <strong>ENET2 </strong>都使用 <strong><span style="color:#fe2c24;">LAN8720A</span> </strong>作为 <strong>PHY</strong> 芯片（正点的外部 PHY 芯片与 NXP 官方的 IMX6ULL 不一样）。</p> 
<blockquote> 
 <p>网络驱动的匹配需要根据硬件的 PCB 原理图来进行分析，需要把握住根据 PHY 芯片的连接引脚与芯片驱动进行修改！</p> 
</blockquote> 
<p>正点原子<strong> IMX6ULL</strong> 的 <strong>ENET1</strong>：</p> 
<p><img alt="" height="1098" src="https://images2.imgbox.com/23/36/2eJ60iQG_o.png" width="1200"></p> 
<p><strong>ENET1 </strong>的网络 <strong>PHY</strong> 芯片为<strong> LAN8720A</strong>，通过<strong> RMII</strong> 接口与<strong> I.MX6ULL</strong> 相连，正点原子 <strong>I.MX6U-ALPHA</strong> 开发板的 <strong>ENET1</strong> 引脚与<strong> NXP</strong> 官方的 <strong>I.MX6ULL EVK</strong> 开发板基本一样，唯独复位引脚不同。从上图可以看出，正点原子 <strong>I.MX6U-ALPHA</strong> 开发板的 <strong>ENET1 </strong>复位引脚 <strong>ENET1_RST</strong> 接到了 <strong>I.M6ULL </strong>的 <strong>SNVS_TAMPER7 </strong>这个引脚上。<strong>I.MX6U-ALPHA</strong> 开发板 <strong>ENET1 </strong>上连接的 <strong>LAN8720A</strong>器件地址为 <span style="color:#fe2c24;"><strong>0X0</strong></span>，所示我们要修改 <strong>ENET1</strong> 网络驱动的话重点就三点：</p> 
<blockquote> 
 <p>①、ENET1 复位引脚初始化。<br> ②、LAN8720A 的器件 ID。<br> ③、LAN8720 驱动</p> 
</blockquote> 
<p>正点原子<strong> IMX6ULL</strong> 的 <strong>ENET2</strong>： </p> 
<p><img alt="" height="824" src="https://images2.imgbox.com/8d/bf/8NbIqQtP_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>关于 ENET2 网络驱动的修改也注意一下三点：</strong></span></p> 
<blockquote> 
 <p>①、ENET2 的复位引脚，从上图可以看出，ENET2 的复位引脚 ENET2_RST 接到了 I.MX6ULL 的 SNVS_TAMPER8 上。<br> ②、ENET2 所使用的 PHY 芯片器件地址，从上图可以看出，PHY 器件地址为 0X1。<br> ③、LAN8720 驱动，ENET1 和 ENET2 都使用的 LAN8720，所以驱动肯定是一样的。</p> 
</blockquote> 
<h4>2.4.2 网络 PHY 地址修改</h4> 
<p>首先修改 <strong>uboot </strong>中的 <strong>ENET1</strong> 和 <strong>ENET2</strong> 的<strong> PHY </strong>地址和驱动，打开 <strong>mx6ull_alientek_emmc.h </strong>这个文件，找到如下代码并进行如下修改：</p> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/5f/ca/TqltIhJB_o.png" width="1200"></p> 
<p>如果要使用<strong> LAN8720A</strong>，那么就得将 <strong>CONFIG_PHY_MICREL</strong> 改为 <strong>CONFIG_PHY_SMSC</strong>，也就是使能<strong> uboot </strong>中的 <strong>SMSC</strong> 公司中的 <strong>PHY</strong> 驱动，因为<strong> LAN8720A</strong> 就是<strong> SMSC</strong> 公司生产的。</p> 
<p>通过宏定义：<strong>CONFIG_FEC_ENET_DEV</strong> 的 <strong>0</strong> 或 <strong>1</strong> 决定是选择启用 <strong>ENET1</strong> 和 <strong> ENET2</strong>；</p> 
<blockquote> 
 <p>需要修改的代码部分如下：</p> 
 <p><strong>1、</strong>修改 ENET1 网络 PHY 的地址。</p> 
 <p><strong>2、</strong>修改 ENET2 网络 PHY 的地址。</p> 
 <p><strong>3、</strong>使能 SMSC 公司的 PHY 驱动。</p> 
</blockquote> 
<h4><strong>2.4.3 删除 uboot 中 74LV595 的驱动代码</strong></h4> 
<p><strong>uboot </strong>中网络 <strong>PHY</strong> 芯片地址修改完成以后就是网络复位引脚的驱动修改了，打开 <strong>mx6ull_alientek_emmc.c</strong>，找到如下代码进行如下修改：</p> 
<p><strong>ENET1 </strong>的复位引脚连接到 <strong>SNVS_TAMPER7 </strong>上，对应 <strong>GPIO5_IO07，ENET2</strong> 的复位引脚连接到 <strong>SNVS_TAMPER8 </strong>上，对应 <strong>GPIO5_IO08</strong>：</p> 
<pre><code class="language-cpp">/* #define IOX_SDI IMX_GPIO_NR(5, 10)
#define IOX_STCP IMX_GPIO_NR(5, 7)
#define IOX_SHCP IMX_GPIO_NR(5, 11)
#define IOX_OE IMX_GPIO_NR(5, 8) */
#define ENET1_RESET IMX_GPIO_NR(5,7)
#define ENET2_RESET IMX_GPIO_NR(5,8)</code></pre> 
<p><img alt="" height="974" src="https://images2.imgbox.com/5e/49/g792poQZ_o.png" width="1200"></p> 
<p>继续在 <strong>mx6ull_alientek_emmc.c</strong> 中找到如下代码也删除：</p> 
<pre><code class="language-cpp">static iomux_v3_cfg_t const iox_pads[] = {
	/* IOX_SDI */
	MX6_PAD_BOOT_MODE0__GPIO5_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
	/* IOX_SHCP */
	MX6_PAD_BOOT_MODE1__GPIO5_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),
	/* IOX_STCP */
	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),
	/* IOX_nOE */
	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
};</code></pre> 
<p>继续在 <strong>mx6ull_alientek_emmc.c </strong>中找到函数 <strong>iox74lv_init</strong>，<span style="color:#fe2c24;"><strong>iox74lv_init </strong></span>函数是 <strong>74LV595</strong> 的初始化函数，<span style="color:#fe2c24;"><strong>iox74lv_set </strong></span>函数用于控制 <strong>74LV595 </strong>的 IO 输出电平，将这两个函数全部删除掉！</p> 
<p>在 <strong>mx6ull_alientek_emmc.c</strong> 中找到<strong> board_init </strong>函数，此函数是板子初始化函数，会被 <span style="color:#fe2c24;"><strong>board_init_r </strong></span>调用，<strong>board_init</strong> 会调用 <strong>imx_iomux_v3_setup_multiple_pads</strong> 和<strong> iox74lv_init</strong> 这两个函数来初始化 74lv595 的 GPIO，将这两行删除掉。至此，mx6ull_alientek_emmc.c 中关于 74LV595 芯片的驱动代码都删除掉了，接下来就是添加 I.MX6U-ALPHA 开发板两个网络复位引脚了。</p> 
<h4>2.4.4 添加 I.MX6U-ALPHA 开发板网络复位引脚驱动</h4> 
<p>在 <strong>mx6ull_alientek_emmc.c </strong>中存在结构体数组<span style="color:#fe2c24;"><strong> fec1_pads </strong></span>和 <span style="color:#fe2c24;"><strong>fec2_pads </strong></span>是 <strong>ENET1</strong> 和<strong> ENET2</strong> 这两个网口的 IO 配置参数，在这两个数组中添加两个网口的复位 IO 配置参数，完成以后如下所示：</p> 
<pre><code class="language-cpp">/*
 * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
 * be used for ENET1 or ENET2, cannot be used for both.
 */
static iomux_v3_cfg_t const fec1_pads[] = {
	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),
};

static iomux_v3_cfg_t const fec2_pads[] = {
	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),

	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),

	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
};</code></pre> 
<p>继续在文件 <strong>mx6ull_alientek_emmc.c</strong> 中找到函数 <strong>setup_iomux_fec</strong>，函数<strong> setup_iomux_fec </strong>就是根据 <strong>fec1_pads </strong>和 <strong>fec2_pads</strong> 这两个网络 IO 配置数组来初始化<strong> I.MX6ULL </strong>的网络 IO。我们需要在其中添加网络复位 IO 的初始化代码，并且复位一下 <strong>PHY</strong> 芯片，修改后的<strong> <span style="color:#fe2c24;">setup_iomux_fec</span></strong> 函数如下：</p> 
<pre><code class="language-cpp">static void setup_iomux_fec(int fec_id)
{
	if (fec_id == 0)
	{
		imx_iomux_v3_setup_multiple_pads(fec1_pads,
						 ARRAY_SIZE(fec1_pads));
		gpio_direction_output(ENET1_RESET,1);
		gpio_set_value(ENET1_RESET,0);
		mdelay(20);
		gpio_set_value(ENET1_RESET,1);
	}
	else
	{
		imx_iomux_v3_setup_multiple_pads(fec2_pads,
						 ARRAY_SIZE(fec2_pads));
		gpio_direction_output(ENET2_RESET,1);
		gpio_set_value(ENET2_RESET,0);
		mdelay(20);
		gpio_set_value(ENET2_RESET,1);
	}		
}</code></pre> 
<p>代码中分别对 <strong>ENET1</strong> 和<strong> ENET2 </strong>的复位<strong> IO </strong>初始化，将这两个 <strong>IO</strong> 设置为输出并且硬件复位一下 <span style="color:#fe2c24;"><strong>LAN8720A</strong></span>，这个硬件复位很重要！否则可能导致 <strong>uboot</strong> 无法识别<span style="color:#fe2c24;"><strong> LAN8720A</strong></span>。</p> 
<h4>2.4.5 修改 drivers/net/phy/phy.c 文件中的函数 genphy_update_link</h4> 
<p>大功基本上告成，还差最后一步，<strong>uboot</strong> 中的 <strong>LAN8720A</strong> 驱动有点问题，打开文件 <strong>drivers/net/phy/phy.c</strong>，找到函数 <strong>genphy_update_link</strong>，这是个通用 <strong>PHY </strong>驱动函数，此函数用于更新 <strong>PHY</strong> 的连接状态和速度。使用 LAN8720A 的时候需要在此函数中添加一些代码，修改后的函数 <span style="color:#fe2c24;"><strong>genphy_update_link </strong></span>如下所示：</p> 
<pre><code class="language-cpp">/**
 * genphy_update_link - update link status in @phydev
 * @phydev: target phy_device struct
 *
 * Description: Update the value in phydev-&gt;link to reflect the
 *   current link value.  In order to do this, we need to read
 *   the status register twice, keeping the second value.
 */
int genphy_update_link(struct phy_device *phydev)
{
	unsigned int mii_reg;

	 static int lan8720_flag = 0;
	 int bmcr_reg = 0;
	 if (lan8720_flag == 0) {
	 bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR); 
	 phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET); 
	 while(phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR) &amp; 0X8000) {
	 udelay(100); 
	 }
	 phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg); 
	 lan8720_flag = 1;
	 }
	/*
	 * Wait if the link is up, and autonegotiation is in progress
	 * (ie - we're capable and it's not done)
	 */
	mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);

	/*
	 * If we already saw the link up, and it hasn't gone down, then
	 * we don't need to wait for autoneg again
	 */
	if (phydev-&gt;link &amp;&amp; mii_reg &amp; BMSR_LSTATUS)
		return 0;

	if ((phydev-&gt;autoneg == AUTONEG_ENABLE) &amp;&amp;
	    !(mii_reg &amp; BMSR_ANEGCOMPLETE)) {
		int i = 0;

		printf("%s Waiting for PHY auto negotiation to complete",
			phydev-&gt;dev-&gt;name);
		while (!(mii_reg &amp; BMSR_ANEGCOMPLETE)) {
			/*
			 * Timeout reached ?
			 */
			if (i &gt; PHY_ANEG_TIMEOUT) {
				printf(" TIMEOUT !\n");
				phydev-&gt;link = 0;
				return 0;
			}

			if (ctrlc()) {
				puts("user interrupt!\n");
				phydev-&gt;link = 0;
				return -EINTR;
			}

			if ((i++ % 500) == 0)
				printf(".");

			udelay(1000);	/* 1 ms */
			mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
		}
		printf(" done\n");
		phydev-&gt;link = 1;
	} else {
		/* Read the link a second time to clear the latched state */
		mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);

		if (mii_reg &amp; BMSR_LSTATUS)
			phydev-&gt;link = 1;
		else
			phydev-&gt;link = 0;
	}

	return 0;
}</code></pre> 
<p>至此网络的复位引脚驱动修改完成，重新编译<strong> uboot</strong>，然后将 <span style="color:#fe2c24;"><strong>u-boot.bin</strong></span> 烧写到 SD 卡中并启动，<strong>uboot </strong>启动信息如图所示： </p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/b8/73/usesOEGY_o.png" width="1200"></p> 
<p><strong>IMX6ULL</strong> 的<strong> LCD</strong> 屏幕上也被成功点亮 NXP 的标志！可是我们同样发现，FEC1 的地址并未设置，该错误原因：未配置网络信息，接下来我们根据自己实际情况配置一下网络信息。为了保证虚拟机下的 <strong>Ubuntu</strong> 和 <strong>PC </strong>以后可以互通，一定要保证在一个网络频段内！</p> 
<p>在 <strong>uboot</strong> 中使用网络之前要先设置几个环境变量，命令如下：</p> 
<pre><code class="language-bash">setenv ipaddr 192.168.163.50 //开发板 IP 地址
setenv ethaddr b8:ae:1d:01:00:00 //开发板网卡 MAC 地址
setenv gatewayip 192.168.163.1 //开发板默认网关
setenv netmask 255.255.255.0 //开发板子网掩码
setenv serverip 192.168.163.129 //服务器地址，也就是 Ubuntu 地址
saveenv //保存环境变量</code></pre> 
<p>之后使用<strong> ping </strong>指令即可<strong> ping </strong>通局域网内其他主机</p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/11/d5/ySwuliWS_o.png" width="1062"></p> 
<h2>三、bootcmd 和 bootargs 环境变量</h2> 
<p><strong>uboot</strong> 中有两个非常重要的环境变量<span style="color:#fe2c24;"><strong> bootcmd</strong></span> 和<span style="color:#fe2c24;"><strong> bootargs</strong></span>，接下来看一下这两个环境变量。<strong>bootcmd </strong>和<strong> bootagrs </strong>是采用类似 <span style="color:#fe2c24;"><strong>shell</strong></span> 脚本语言编写的，里面有很多的变量引用，这些变量其实都 是 环 境 变 量 ， 有 很 多 是 NXP 自 己 定 义 的 。 文 件 <strong>mx6ull_alientek_emmc.h </strong>中的宏<span style="color:#fe2c24;"><strong>CONFIG_EXTRA_ENV_SETTINGS</strong></span> 保存着这些环境变量的默认值</p> 
<h3>3.1 环境变量 bootcmd</h3> 
<p><span style="color:#fe2c24;"><strong>bootcmd </strong></span>保存着 <strong>uboot</strong> 默认命令，<strong>uboot </strong>倒计时结束以后就会执行<strong> bootcmd</strong> 中的命令。这些命令一般都是用来<span style="color:#fe2c24;"><strong>启动 Linux 内核</strong></span>的，比如读取 EMMC 或者 NAND Flash 中的 Linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 Linux 内核。可以在 uboot 启动以后进入命令行设置 bootcmd 环境变量的值。如果 <strong>EMMC</strong> 或者 <strong>NAND</strong> 中没有保存 <strong>bootcmd </strong>的值，那么 <strong>uboot </strong>就会使用默认的值，板子第一次运行 <strong>uboot</strong> 的时候都会使用默认值来设置<strong> bootcmd</strong> 环境变量。</p> 
<p>我们都知道 Linux 内核的成功启动需要 Linux kernel 和 dtb 的配合才行，作者这里采取 tftp 协议去加载 Linux 内核和设备树，并在指定地址内启动，代码命令如下：</p> 
<pre><code class="language-bash">setenv bootcmd 'tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000'</code></pre> 
<h3>3.2 环境变量 bootargs</h3> 
<p><strong>bootargs </strong>保存着<strong> uboot </strong>传递给<strong> Linux </strong>内核的参数，<strong>bootargs </strong>环境变量是由 <strong>mmcargs </strong>设置的，<strong>mmcargs </strong>环境变量如下：</p> 
<pre><code class="language-bash">mmcargs=setenv bootargs console=${console},${baudrate} root=${mmcroot}</code></pre> 
<p>其中 <strong>console=ttymxc0</strong>，<strong>baudrate=115200</strong>，<strong>mmcroot=/dev/mmcblk1p2 rootwait rw</strong>，因此将 <strong>mmcargs</strong> 展开以后就是：</p> 
<pre><code class="language-bash">mmcargs=setenv bootargs console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw</code></pre> 
<p>可以看出环境变量 <strong>mmcargs</strong> 就是设置 <strong>bootargs</strong> 的值为<strong> “console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw”</strong>，<strong>bootargs </strong>就是设置了很多的参数的值，这些参数 Linux 内核会使用到。 </p> 
<h3>3.3 <strong>从网络启动 Linux 系统 </strong></h3> 
<p>为了方便后续 Linux 驱动和应用程序的开发，通常研发阶段都会采用从网络启动 Linux 系统的方式（当然，产品化之后肯定都需要从 EMMC 中启动的），设置 <strong>bootargs</strong> 和 <strong>bootcmd </strong>这两个环境变量，设置如下：</p> 
<pre><code class="language-bash">setenv bootargs 'console=tty1  console=ttymxc0,115200 rw root=/dev/nfs nfsroot=192.168.163.129:/home/senak/linux/nfs/rootfs ip=192.168.163.50:192.168.163.129:192.168.163.1:255.255.255.0::eth0:off'
setenv bootcmd 'tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000'
saveenv</code></pre> 
<p>作者这里的控制台 <strong>console</strong> 使用了串口和屏幕显示，通过 <strong>tftp</strong>下载 <strong>Linux </strong>内核镜像，<strong>nfs </strong>挂载根文件系统；</p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/83/a6/DbS1YGZc_o.png" width="1200"></p> 
<p>之后重启 <strong>uboot</strong> 进行引导 <strong>Linux </strong>内核镜像与设备树，并挂载根文件系统：</p> 
<p><img alt="" height="998" src="https://images2.imgbox.com/f0/57/p4vnybEO_o.png" width="1200"></p> 
<p><img alt="" height="672" src="https://images2.imgbox.com/18/de/YOCVq3NF_o.png" width="1041"></p> 
<h2>四、uboot移植流程总结</h2> 
<p><span style="color:#fe2c24;"><strong>★简单总结一下 uboot 移植的过程：</strong></span></p> 
<blockquote> 
 <p>1、不管是购买的开发板还是自己做的开发板，基本都是参考半导体厂商的 dmeo 板，而半导体厂商会在他们自己的开发板上移植好 <strong>uboot</strong>、<strong>linux kernel </strong>和<strong> rootfs</strong> 等，最终制作好 BSP 包提供给用户。我们可以在官方提供的 <span style="color:#fe2c24;"><strong>BSP</strong></span> 包的基础上添加我们的板子，也就是俗称的移植。<br> 2、我们购买的开发板或者自己做的板子一般都不会原封不动的照抄半导体厂商的 demo 板，都会根据实际的情况来做修改，既然有修改就必然涉及到 uboot 下驱动的移植。<br> 3、一般 <strong>uboot</strong> 中需要解决<strong>串口</strong>、<strong>NAND</strong>、<strong>EMMC</strong> 或 <strong>SD</strong> <strong>卡</strong>、<strong>网络</strong>和<strong> LCD 驱动</strong>，因为 uboot 的主要目的就是启动 Linux 内核，所以不需要考虑太多的外设驱动。<br> 4、在<strong> uboot </strong>中添加自己的板子信息，根据自己板子的实际情况来修改 <strong>uboot</strong> 中的驱动。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad2f9d40feb935ff58f1e3d9bc79b331/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">「RabbitMQ」实现消息确认机制以确保消息的可靠发送、接收和拒收</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9fe169aec0ab3172142e518371c429c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java连接打印机并进行打印</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>