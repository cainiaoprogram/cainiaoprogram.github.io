<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言 -- 链表（企业级，侵入式链表） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言 -- 链表（企业级，侵入式链表）" />
<meta property="og:description" content="目录
节点结构体的实现
初始化链表
插入链表
遍历链表
删除节点、销毁链表
用户test
侵入式链表，内核链表
普通单链表和侵入式单链表的区别在于：
普通的单链表的结点指针域指向的是下一个结点的内存首地址；侵入式单链表的结点指针域指向的是下一个结点的指针域成员变量的内存首地址。 节点结构体的实现 节点结构体只维护指针域，用户需预留4个字节空间，供我们帮助连接数据。
//节点结构体 struct LinkNode { //只维护指针域 struct LinkNode* next; }; //链表结构体 struct LList { struct LinkNode pHeader; //头结点 int m_size; //链表长度 }; //暴露给用户的 typedef void* LinkList; 初始化链表 //初始化链表 LinkList init_LinkList() { struct LList* mylist = malloc(sizeof(struct LList)); if (mylist == NULL) return NULL; mylist-&gt;m_size = 0; mylist-&gt;pHeader.next = NULL; return mylist; } 插入链表 //插入链表 void insert_LinkList(LinkList list, int pos, void* data) { if (list == NULL) return; if (data == NULL) return; struct LList* mylist = list; if (pos&lt;0 || pos&gt;mylist-&gt;m_size - 1) pos = mylist-&gt;m_size; //取出用户数据的前四个字节空间 struct LinkNode* myNode = data; //把void*类型的data转为一个指针，即4个字节大小 //找到待插入位置的前驱节点 struct LinkNode* pCurrent = &amp;mylist-&gt;pHeader; for (int i = 0; i &lt; pos; i&#43;&#43;) { pCurrent = pCurrent-&gt;next; } //更新指针指向 myNode-&gt;next = pCurrent-&gt;next; pCurrent-&gt;next = myNode; mylist-&gt;m_size&#43;&#43;; } 遍历链表 //遍历链表 void foreach_LinkList(LinkList list, void(*myPrint)(void*)) { if (NULL == list) return; struct LList* mylist = list; struct LinkNode* pCurrent = mylist-&gt;pHeader." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1e2e970679188f545f36c6903dce5be5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-04T22:54:24+08:00" />
<meta property="article:modified_time" content="2022-09-04T22:54:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言 -- 链表（企业级，侵入式链表）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">节点结构体的实现</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E8%A1%A8" rel="nofollow">初始化链表</a></p> 
<p id="%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8" rel="nofollow">插入链表</a></p> 
<p id="%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8" rel="nofollow">遍历链表</a></p> 
<p id="%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E3%80%81%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E3%80%81%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8" rel="nofollow">删除节点、销毁链表</a></p> 
<p id="%E7%94%A8%E6%88%B7test-toc" style="margin-left:40px;"><a href="#%E7%94%A8%E6%88%B7test" rel="nofollow">用户test</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><a class="link-info" href="https://liyongjun.blog.csdn.net/article/details/119881209?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-119881209-blog-122216863.pc_relevant_multi_platform_whitelistv6&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-119881209-blog-122216863.pc_relevant_multi_platform_whitelistv6&amp;utm_relevant_index=2" rel="nofollow" title="侵入式链表，内核链表">侵入式链表，内核链表</a></p> 
<p><strong>普通单链表和侵入式单链表的区别在于：</strong></p> 
<ul><li><strong>普通的单链表的结点指针域指向的是下一个结点的内存首地址；</strong></li><li><strong>侵入式单链表的结点指针域指向的是下一个结点的指针域成员变量的内存首地址。</strong></li></ul> 
<p><img alt="" height="302" src="https://images2.imgbox.com/8a/f3/ezPBoX0e_o.png" width="714"></p> 
<p> </p> 
<h2 id="%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0">节点结构体的实现</h2> 
<p>节点结构体只维护指针域，用户需预留4个字节空间，供我们帮助连接数据。</p> 
<pre><code class="language-cpp">//节点结构体
struct LinkNode
{
	//只维护指针域
	struct LinkNode* next;
};
//链表结构体
struct LList
{
	struct LinkNode pHeader; //头结点
	int m_size;  //链表长度
};
//暴露给用户的
typedef void* LinkList;</code></pre> 
<h3 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E8%A1%A8">初始化链表</h3> 
<pre><code class="language-cpp">//初始化链表
LinkList init_LinkList()
{
	struct LList* mylist = malloc(sizeof(struct LList));
	if (mylist == NULL)
		return NULL;

	mylist-&gt;m_size = 0;
	mylist-&gt;pHeader.next = NULL;

	return mylist;
}</code></pre> 
<h3 id="%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8">插入链表</h3> 
<pre><code class="language-cpp">//插入链表
void insert_LinkList(LinkList list, int pos, void* data)
{
	if (list == NULL)
		return;
	if (data == NULL)
		return;
	
	struct LList* mylist = list;
	if (pos&lt;0 || pos&gt;mylist-&gt;m_size - 1)
		pos = mylist-&gt;m_size;

	//取出用户数据的前四个字节空间
	struct LinkNode* myNode = data; //把void*类型的data转为一个指针，即4个字节大小

	//找到待插入位置的前驱节点
	struct LinkNode* pCurrent = &amp;mylist-&gt;pHeader;

	for (int i = 0; i &lt; pos; i++)
	{
		pCurrent = pCurrent-&gt;next;
	}
	//更新指针指向
	myNode-&gt;next = pCurrent-&gt;next;
	pCurrent-&gt;next = myNode;
	mylist-&gt;m_size++;
}</code></pre> 
<h3 id="%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8">遍历链表</h3> 
<pre><code class="language-cpp">//遍历链表
void foreach_LinkList(LinkList list, void(*myPrint)(void*))
{
	if (NULL == list)
		return;
	struct LList* mylist = list;
	struct LinkNode* pCurrent = mylist-&gt;pHeader.next;  //指向第一个有真实数据的节点

	for (int i = 0; i &lt; mylist-&gt;m_size; i++)
	{
		//pCurrent就是用户数据的首地址
		myPrint(pCurrent);
		pCurrent = pCurrent-&gt;next;
	}
}</code></pre> 
<h3 id="%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E3%80%81%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8">删除节点、销毁链表</h3> 
<pre><code class="language-cpp">//删除链表节点之按位置删除
void removeByPos_LinkList(LinkList list, int pos)
{
	if (list == NULL)
		return;
	struct LList* mylist = list;
	if (pos&lt;0 || pos&gt;mylist-&gt;m_size - 1)
		return; //无效位置直接返回
	//找到待删除位置的前驱节点的位置
	struct LinkNode* pCurrent = &amp;mylist-&gt;pHeader;
	for (int i = 0; i &lt; pos; i++)
	{
		pCurrent = pCurrent-&gt;next;
	}
	//PCurrent就是待删除节点的前驱节点
	//利用一个指针记录待删除节点
	struct LinkNode* pDel = pCurrent-&gt;next;
	//更改指针的指向
	pCurrent-&gt;next = pDel-&gt;next;
	
	//free(pDel); //数据本身是用户开辟的，由用户自己管理释放
	mylist-&gt;m_size--;
}

//清空链表
// 用户的数据不需要我们来释放，只需要把头结点指向空即可
void clear_LinkList(LinkList list)
{
	if (list == NULL)
		return;
	struct LList* mylist = list;

	mylist-&gt;pHeader.next = NULL;
	mylist-&gt;m_size = 0;
}

//销毁链表
void destory_LinkList(LinkList list)
{
	if (list == NULL)
		return;

	free(list);
	list = NULL;
}</code></pre> 
<h3 id="%E7%94%A8%E6%88%B7test">用户test</h3> 
<pre><code class="language-cpp">//给用户提供接口获取链表长度
int size_LinkList(LinkList list)
{
	if (list == NULL)
		return -1;
	struct LList* mylist = list;
	return mylist-&gt;m_size;
}


struct Person
{
	struct LinkNode node; //占用用户数据的前四个字节
	char name[32];
	int age;
};
//回调函数打印
void printPerson(void* data)
{
	struct Person* person = data;
	printf("Name:%s, Age:%d\n", person-&gt;name, person-&gt;age);
}


void test03()
{
	//初始化链表
	LinkList mylist = init_LinkList();
	//创建数据
	struct Person p1 = { NULL,"aaa",12 };
	struct Person p2 = { NULL,"bbb",13 };
	struct Person p3 = { NULL,"ccc",14 };
	struct Person p4 = { NULL,"ddd",15 };

	//插入数据
	insert_LinkList(mylist, 0, &amp;p1);
	insert_LinkList(mylist, 0, &amp;p2);
	insert_LinkList(mylist, 1, &amp;p3);
	insert_LinkList(mylist, -1, &amp;p4);

	foreach_LinkList(mylist,printPerson);
	printf("--------------------\n");
	removeByPos_LinkList(mylist,1);
	foreach_LinkList(mylist, printPerson);
	printf("--------------------\n");
	printf("链表长度 = %d\n",size_LinkList(mylist));
	clear_LinkList(mylist);
	printf("链表长度 = %d\n", size_LinkList(mylist));
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dba09efa59032fe4f4ee590e6c3c9ae2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mybatis-Plus之连表查询的基本实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c25d504d41eccfbf3708fe177c24a57/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot Test及注解详解（含Mockito）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>