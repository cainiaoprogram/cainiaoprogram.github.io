<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二维数组与字符串与结构体 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二维数组与字符串与结构体" />
<meta property="og:description" content="指针 指针中的const int const * p; //不能改变指针指向的值
int * const p; //不能改变指针指向的地址
int const * const p //既不能改变值，也不能改变地址
结构体 知识提要 1.传向函数的结构体数组都是指针
2.[]的优先级比*高
3.指针的运算符是-&gt; 而结构体的运算符是.
struct instr { char ina1[10]; int ina2[10]; }; struct str { char a[10]; int b[10]; double c[10]; struct instr instrin; { char b1[10]; int b2; }; }; struct str stru; struct str *pstru=&amp;stru; 1.结构体写法 stru.a[i]; stru.instrin.ina1[i]; stru.b2; 2.指针 pstru-&gt;a[i]; (*pstru).a[i]; pstru-&gt;instrin.ina2; pstru-&gt;b2; 结构体 定义模板 struct name { char fname[10]; char lname[10]; }; 定义结构体变量 struct name myname; 函数定义 void print_sour(struct name myname); //函数定义中的形参是一个结构体，需要传入一个结构体 函数调用 print_sour(myname); //这儿传递的是一整个结构的所有数据 结构体指针， 注意:在函数调用上要与上面的分开 定义模板 struct money { double hand_money; double save_money; } struct name { struct money mymoney; //嵌套结构体必须要有; char fname[10]; char lname[10]; { int num1; double num2; }; //匿名结构体也需要; }; 定义结构体指针 struct name myname_c; struct name *myname; 结构体指针的使用 myname=&amp;myname_c; //对于结构体，结构体不是数组，结构体的名字不代表地址，要用取地址符 printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/234f2aa1bf0e43e31673a568b85a70a3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-05T23:11:56+08:00" />
<meta property="article:modified_time" content="2022-12-05T23:11:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二维数组与字符串与结构体</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>指针</h3> 
<h4><a id="const_1"></a>指针中的const</h4> 
<p>int const * p; //不能改变指针指向的值<br> int * const p; //不能改变指针指向的地址<br> int const * const p //既不能改变值，也不能改变地址</p> 
<h3><a id="_5"></a>结构体</h3> 
<h4><a id="_6"></a>知识提要</h4> 
<p><strong>1.传向函数的结构体数组都是指针</strong></p> 
<p><strong>2.[]的优先级比*高</strong></p> 
<p><strong>3.指针的运算符是-&gt; 而结构体的运算符是.</strong></p> 
<pre><code>struct instr
{   char ina1[10];
    int ina2[10];
};
struct str
{   char a[10];
    int b[10];
    double c[10];
    struct instr instrin;
    {
        char b1[10];
        int b2;
    };
};
struct str stru;
struct str *pstru=&amp;stru;
1.结构体写法   stru.a[i];
stru.instrin.ina1[i];
stru.b2;
2.指针        pstru-&gt;a[i];
            (*pstru).a[i];
pstru-&gt;instrin.ina2;
pstru-&gt;b2;
</code></pre> 
<h4><a id="_37"></a>结构体</h4> 
<pre><code>定义模板
struct name
{   char fname[10];
    char lname[10];
};
定义结构体变量
struct name myname;
函数定义
void print_sour(struct name myname);   //函数定义中的形参是一个结构体，需要传入一个结构体
函数调用
print_sour(myname); //这儿传递的是一整个结构的所有数据
</code></pre> 
<h4><a id="___51"></a>结构体指针， 注意:在函数调用上要与上面的分开</h4> 
<pre><code>定义模板
struct money
{
    double hand_money;
    double save_money;
}
struct name
{ 
    struct money mymoney;     //嵌套结构体必须要有;
    char fname[10];
    char lname[10];
    {
        int num1;
        double num2;
    };      //匿名结构体也需要;
};
定义结构体指针
struct name myname_c;
struct name *myname;
结构体指针的使用
myname=&amp;myname_c;       //对于结构体，结构体不是数组，结构体的名字不代表地址，要用取地址符
printf("%s",myname-&gt;fname);     //myname代表一个结构体指针，用-&gt;
printf("%s",(*myname).fname)    //(*myname)代表一个结构体，用.

printf("%lf",myname-&gt;money.hand_money); //myname-&gt;money相当于一个结构体，后续的成员用.
printf("%d",myname-&gt;num1);      //匿名结构体相当于外层结构体的成员
函数定义
void printf_sour(struct name *myname); //函数定义中形参是个结构体指针，需要传入一个结构体的地址
函数调用
printf_sour(&amp;myname);  //这儿传递的是一个结构体的地址
</code></pre> 
<h4><a id="_84"></a>结构体数组</h4> 
<pre><code>定义模板
struct name
{   char fname[10];
    char lname[10];
};
定义结构体数组
struct name myname[5];
函数定义，  两种写法没有区别，传过去的都是结构体指针
void printf_sour(struct name myname[]);     定义形式1
void printf_sour(struct name *myname);      定义形式2
函数调用
printf_sour(myname);    //myname是一个数组，名称即代表地址
printf_sour(&amp;myname[0]);    //myname[0]是一个结构体，要加取地址符，取得地址
</code></pre> 
<h3><a id="_100"></a>字符串的输入</h3> 
<h4><a id="_101"></a>一维字符串</h4> 
<pre><code>char str[100];
//scanf("%s",str);
//注意！，scanf的%s遇到，空格，tab键，回车会认为输入结束
//不能输入i love you这种有空格的字符串

//gets(str);
//fgets(str,99,stdin);
</code></pre> 
<h4><a id="_111"></a>二维字符串</h4> 
<pre><code>//输入7*7方阵,每行要8个空，7个字符，1个空字符
char str[7][8];
int i=0;
for(i=0;i&lt;n;i++)
{
    scanf("%s",str[i]);
    //fgets(str[i],7,stdin);
}
for(i=0;i&lt;n;i++)
{
    printf("%s\n",str[i]);
}

</code></pre> 
<h3><a id="_127"></a>指针传输数值</h3> 
<pre><code>//目的，获取一个数组内最大值与最小值
函数定义
int tomm(int num[],int n,int *max,int *min);
主函数内调用
int min,max;
tomm(num,n,&amp;max,&amp;min);
</code></pre> 
<h3><a id="_136"></a>一维数组</h3> 
<h4><a id="_137"></a>知识提要</h4> 
<p><strong>1.传向函数的数组都是指针</strong></p> 
<pre><code>定义
int num[10]={0};
函数定义
void print_sour(int num[],int n); //常用写法
void print_sour(int *num,int n); //不常用写法，本质写法    
数组个数需要传入
函数调用
print_sour(num,10);
</code></pre> 
<h3><a id="_149"></a>二维数组</h3> 
<h4><a id="_150"></a>知识提要</h4> 
<p><strong>1.传向函数的数组都是指针</strong></p> 
<p><strong>2.[]的优先级比*高</strong></p> 
<pre><code>int (*pz)[3]
这是一个指针，指针+数组，即为指向一个内含3个int值的数组的指针
int *pz[3]
这是一个数组，数组+指针，即为pz是三个元素的数组，每个元素是个指针

</code></pre> 
<p>*<em>int (<em>pz)[3]的另一种写法是</em></em><br> <strong>int pz[][3],这是一般写法，这个指向数组的指针用来声明二维数组的函数形参</strong></p> 
<h4><a id="_165"></a>二维数组</h4> 
<p>行数rows 列数cols</p> 
<pre><code>定义
int num[rows][cols]={"1,2,3,4,5","1,2,3,4,5","1,2,3,4,5","1,2,3,4,5","1,2,3,4,5"};
函数定义
void print_sour(int num[][cols],int n); //只能省略第一个括号数组     
行号需要传入，列数内置
函数调用
print_sour(num,rows);
</code></pre> 
<h4><a id="_176"></a>二维变长数组定义</h4> 
<pre><code>int n,m;
int num[n][m];
二维变长数组不可编译前初始化，要初始化只能for循环初始化
</code></pre> 
<h4><a id="_182"></a>二维变长数组函数调用</h4> 
<pre><code>定义
int num[5][5]={"1,2,3,4,5","1,2,3,4,5","1,2,3,4,5","1,2,3,4,5","1,2,3,4,5"};
函数定义
void print_sour(int n,int m,int num[n][m]);
函数调用
print_sour(5,5,num);

</code></pre> 
<h3><a id="_192"></a>二维字符串</h3> 
<h4><a id="_194"></a>二维字符串数组,用法和二维数组一样</h4> 
<pre><code>#define lim 100
定义
char str[5][lim]={"abcdefg","wangboyang","blues str","wby wby wby","qwer asdf zxcv"};
函数定义
void print_sour(char str[][lim]);
函数调用
print_sour(str);
</code></pre> 
<h4><a id="_204"></a>二维字符串指针</h4> 
<pre><code>#define SIZE 5
定义
char *str[SIZE]={"abcdefg","wangboyang","blues str","wby wby wby","qwer asdf zxcv"};
函数定义
void print_sour(char* str[SIZE]);
函数调用
print_sour(str);
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95c8e544f4d40588bf6b64da900805a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言错误集合</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/916a0d39531ce230fceac0c1c1ae8b84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">排名赛A题解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>