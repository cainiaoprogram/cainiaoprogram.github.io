<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用EasyExcel导出数据 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用EasyExcel导出数据" />
<meta property="og:description" content="目录
一、引入EasyExcel依赖
二、代码框架实现
1-1、无需复杂处理，直接使用工具类
1-2、创建一批假数据
1-3、使用流的方式导出数据
1-4、使用生成文件的方式导出数据
1-5、验证结果
2-1、自定义表头格式，并对数据做处理
2-2、验证结果
三、问题暴露及修复思路
1、问题原由
The maximum number of cell styles was exceeded. You can define up to 64000 styles
2、将底层实现或是枚举方法Copy重写
3、重新定义实现类
四、百万级别数据导出 处理思路
一、引入EasyExcel依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; 二、代码框架实现 1-1、无需复杂处理，直接使用工具类 定义具体对象，并添加@ExcelProperty，来指定列信息
@Data @Builder @NoArgsConstructor @AllArgsConstructor @ExcelIgnoreUnannotated public static class DemoDataRespVO { @ExcelProperty(value = &#34;数据1&#34;, index = 0) private String data1; @ExcelProperty(value = &#34;数据2&#34;,index = 1) private String data2; @ExcelProperty(&#34;数据3&#34;) private String data3; @ExcelProperty(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1b37677833d0035ffdc13bd0a7e25b86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T11:58:04+08:00" />
<meta property="article:modified_time" content="2024-01-04T11:58:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用EasyExcel导出数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%BC%95%E5%85%A5EasyExcel%E4%BE%9D%E8%B5%96-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%BC%95%E5%85%A5EasyExcel%E4%BE%9D%E8%B5%96" rel="nofollow">一、引入EasyExcel依赖</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0" rel="nofollow">二、代码框架实现</a></p> 
<p id="1-1%E3%80%81%E6%97%A0%E9%9C%80%E5%A4%8D%E6%9D%82%E5%A4%84%E7%90%86%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB-toc" style="margin-left:40px;"><a href="#1-1%E3%80%81%E6%97%A0%E9%9C%80%E5%A4%8D%E6%9D%82%E5%A4%84%E7%90%86%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB" rel="nofollow">1-1、无需复杂处理，直接使用工具类</a></p> 
<p id="1-2%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E6%89%B9%E5%81%87%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#1-2%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E6%89%B9%E5%81%87%E6%95%B0%E6%8D%AE" rel="nofollow">1-2、创建一批假数据</a></p> 
<p id="1-3%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#1-3%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE" rel="nofollow">1-3、使用流的方式导出数据</a></p> 
<p id="1-4%E3%80%81%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#1-4%E3%80%81%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE" rel="nofollow">1-4、使用生成文件的方式导出数据</a></p> 
<p id="1-5%E3%80%81%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#1-5%E3%80%81%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C" rel="nofollow">1-5、验证结果</a></p> 
<p id="2-1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%A4%B4%E6%A0%BC%E5%BC%8F%EF%BC%8C%E5%B9%B6%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%81%9A%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#2-1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%A4%B4%E6%A0%BC%E5%BC%8F%EF%BC%8C%E5%B9%B6%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%81%9A%E5%A4%84%E7%90%86" rel="nofollow">2-1、自定义表头格式，并对数据做处理</a></p> 
<p id="2-2%E3%80%81%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#2-2%E3%80%81%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C" rel="nofollow">2-2、验证结果</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%97%AE%E9%A2%98%E6%9A%B4%E9%9C%B2%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%97%AE%E9%A2%98%E6%9A%B4%E9%9C%B2%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF" rel="nofollow">三、问题暴露及修复思路</a></p> 
<p id="1%E3%80%81%E9%97%AE%E9%A2%98%E5%8E%9F%E7%94%B1-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%97%AE%E9%A2%98%E5%8E%9F%E7%94%B1" rel="nofollow">1、问题原由</a></p> 
<p id="The%20maximum%20number%20of%20cell%20styles%20was%20exceeded.%20You%20can%20define%20up%20to%2064000%20styles-toc" style="margin-left:0px;"><a href="#The%20maximum%20number%20of%20cell%20styles%20was%20exceeded.%20You%20can%20define%20up%20to%2064000%20styles" rel="nofollow">The maximum number of cell styles was exceeded. You can define up to 64000 styles</a></p> 
<p id="2%E3%80%81%E5%B0%86%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%88%96%E6%98%AF%E6%9E%9A%E4%B8%BE%E6%96%B9%E6%B3%95Copy%E9%87%8D%E5%86%99-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%B0%86%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%88%96%E6%98%AF%E6%9E%9A%E4%B8%BE%E6%96%B9%E6%B3%95Copy%E9%87%8D%E5%86%99" rel="nofollow">2、将底层实现或是枚举方法Copy重写</a></p> 
<p id="3%E3%80%81%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E7%B1%BB-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E7%B1%BB" rel="nofollow">3、重新定义实现类</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%C2%A0" rel="nofollow">四、百万级别数据导出 </a></p> 
<p id="%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF" rel="nofollow">处理思路</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p style="margin-left:40px;"></p> 
<hr> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%BC%95%E5%85%A5EasyExcel%E4%BE%9D%E8%B5%96">一、引入EasyExcel依赖</h2> 
<pre><code class="language-java">
    &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;
      &lt;version&gt;3.3.2&lt;/version&gt;
    &lt;/dependency&gt;</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0">二、代码框架实现</h2> 
<h3 id="1-1%E3%80%81%E6%97%A0%E9%9C%80%E5%A4%8D%E6%9D%82%E5%A4%84%E7%90%86%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB">1-1、无需复杂处理，直接使用工具类</h3> 
<p>定义具体对象，并添加@ExcelProperty，来指定列信息</p> 
<pre><code class="language-java">
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @ExcelIgnoreUnannotated
    public static class DemoDataRespVO {

        @ExcelProperty(value = "数据1", index = 0)
        private String data1;

        @ExcelProperty(value = "数据2",index = 1)
        private String data2;

        @ExcelProperty("数据3")
        private String data3;

        @ExcelProperty("数据4")
        private String data4;

        @ExcelProperty("数据5")
        private String data5;

        @ExcelProperty("数据6")
        private String data6;

        @ExcelProperty("数据7")
        private String data7;

        @ExcelProperty("数据8")
        private String data8;

        @ExcelProperty("数据9")
        private String data9;

        @ExcelProperty("数据10")
        private String data10;

    }</code></pre> 
<h3 id="1-2%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E6%89%B9%E5%81%87%E6%95%B0%E6%8D%AE">1-2、创建一批假数据</h3> 
<pre><code class="language-java">private List&lt;DemoDataRespVO&gt; getData() {
        List&lt;DemoDataRespVO&gt; data = new ArrayList&lt;&gt;();
        DemoDataRespVO data1 = DemoDataRespVO.builder()
                .data1("数据1-1").data2("数据2-1").data3("数据3-1").data4("数据4-1").data5("数据5-1")
                .data6("数据6-1").data7("-数据7-1").data8("数据8-1").data9("数据9-1").data10("数据10-1").build();
        data.add(data1);
        DemoDataRespVO data2 = DemoDataRespVO.builder()
                .data1("数据1-2").data2("数据2-2").data3("数据3-2").data4("数据4-2").data5("数据5-2")
                .data6("数据6-2").data7("数据7-2").data8("数据8-2").data9("-数据9-2").data10("数据10-2").build();
        data.add(data2);
        return data;
    }</code></pre> 
<h3 id="1-3%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE">1-3、使用流的方式导出数据</h3> 
<pre><code class="language-java">@RestController
@RequestMapping("/test")
public class TestController {


    @GetMapping("/exportExcel1")
    public void getExportExcel1(HttpServletResponse response) throws IOException {

        String sheetName = "sheet名";
        String fileName = "文件名.xlsx";
        response.addHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(fileName, "UTF-8"));
        response.setContentType("application/vnd.ms-excel;charset=UTF-8");

        List&lt;DemoDataRespVO&gt; dataList = getData();
        EasyExcel.write(response.getOutputStream(), DemoDataRespVO.class)
                .autoCloseStream(false)
                .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()).sheet(sheetName).doWrite(dataList);
    }
}</code></pre> 
<h3 id="1-4%E3%80%81%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE">1-4、使用生成文件的方式导出数据</h3> 
<pre><code class="language-java">@GetMapping("/exportExcel1")
    public void getExportExcel1(HttpServletResponse response) throws IOException {

        File file = new File("H:/test.xls");
        OutputStream outputStream = Files.newOutputStream(file.toPath());
        List&lt;DemoDataRespVO&gt; dataList = getData();
        EasyExcel.write(outputStream, DemoDataRespVO.class)
                .autoCloseStream(false)
                .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()).sheet(sheetName).doWrite(dataList);
    }</code></pre> 
<p>PS：可先上传到文件服务器，再通过返回的下载地址链接返回前端 。</p> 
<h3 id="1-5%E3%80%81%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C">1-5、验证结果</h3> 
<p> localhost:8622/api/v1/test/exportExcel1</p> 
<p><img alt="" height="198" src="https://images2.imgbox.com/e9/90/lFbSPCfQ_o.png" width="876"></p> 
<h3 id="2-1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%A4%B4%E6%A0%BC%E5%BC%8F%EF%BC%8C%E5%B9%B6%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%81%9A%E5%A4%84%E7%90%86">2-1、自定义表头格式，并对数据做处理</h3> 
<pre><code class="language-java">
    @GetMapping("/exportExcel2")
    public void getExportExcel2(HttpServletResponse response) throws IOException {
        exportExcel(response);
    }

    /**
     * 导出Excel流
     *
     * @param response
     * @throws IOException
     */
    public void exportExcel(HttpServletResponse response) throws IOException {

        // 设置响应头
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setHeader("Content-Disposition", "attachment; filename=testName.xlsx");

        // 获取输出流
        response.flushBuffer();
        //创建自定义的表头（可自行判断增减 列）
        ArrayList&lt;List&lt;String&gt;&gt; head = new ArrayList&lt;&gt;();
        head.add(CollectionUtil.newArrayList("标题1", "标题1"));        //0
        head.add(CollectionUtil.newArrayList("标题2", "标题2"));        //1
        head.add(CollectionUtil.newArrayList("标题3", "标题3"));        //2
        head.add(CollectionUtil.newArrayList("标题4", "标题4"));        //3
        head.add(CollectionUtil.newArrayList("标题5", "标题5"));        //4
        //！！！！ 如果是合并表头，数组头一个设置名称一样即可
        head.add(CollectionUtil.newArrayList("合并标题", "子标题1"));      //5
        head.add(CollectionUtil.newArrayList("合并标题", "子标题2"));      //6
        head.add(CollectionUtil.newArrayList("合并标题", "子标题3"));      //7
        head.add(CollectionUtil.newArrayList("合并标题", "子标题4"));      //8
        head.add(CollectionUtil.newArrayList("合并标题", "子标题5"));      //9
        //输出流

        //表头：原本是 write(response.getOutputStream(), XXX.class) ，XXX是默认表头格式
        //表头：现在设置为null, 使用 head 入参 自定义的表头，视情况自行选择
        //registerWriteHandler  自定义表格样式
        // sheet 自定以 sheet名称
        // doWrite(getData()) 行数据，-----！！！ 数据列 需要跟表头一样长度
        EasyExcel.write(response.getOutputStream(), null).head(head)
                .autoCloseStream(false) // 不要自动关闭，交给 Servlet 自己处理
                .registerWriteHandler(new RegisterStyle())
                .sheet("sheetName").doWrite(getData());
    }

    /**
     * 自定义样式
     */
    static class RegisterStyle extends AbstractColumnWidthStyleStrategy {

        @Override
        protected void setColumnWidth(WriteSheetHolder writeSheetHolder, List&lt;WriteCellData&lt;?&gt;&gt; cellDataList, Cell cell,
                                      Head head,
                                      Integer relativeRowIndex, Boolean isHead) {
            //这里有10个字段，所以只是设置10个列的宽度即可
            if (cell.getColumnIndex() &lt; 10) {
                //setColumnWidth （i,j），i是列的下标，从0开始，j是列的宽度，单位是1/256个字符宽度，所以代码中要乘以256
                writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), 256 * 12);
            }
            //只是自定义的，判断那些列需要做处理
            boolean flag = cell.getColumnIndex() == 6 || cell.getColumnIndex() == 8;
            // isHead 表头， “!isHead”：跳过表头行
            if (!isHead &amp;&amp; flag) {
                // 获取当前单元格的数值（存入String格式用 getStringValue 获取）
                // 获取当前单元格的数值（存入Number格式用 getNumberValue 获取）
                String stringValue = cellDataList.get(0).getStringValue();
                //创建单元格
                CellStyle cellStyle = cell.getSheet().getWorkbook().createCellStyle();
                cellStyle.cloneStyleFrom(cell.getCellStyle());
                if (stringValue.startsWith("-")) {
                    // - 开头表示负数
                    //单元格数值小于0的  ， 字体展示为 红色
                    Font font = cell.getSheet().getWorkbook().createFont();
                    font.setColor(IndexedColors.RED.getIndex());
                    cellStyle.setFont(font);
                }
                cell.setCellStyle(cellStyle);
            }
        }

    }</code></pre> 
<h3 id="2-2%E3%80%81%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C">2-2、验证结果</h3> 
<p> localhost:8622/api/v1/test/exportExcel2</p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/b9/81/KRSeN5i7_o.png" width="974"></p> 
<p>效果是跟我们想要的一样，这个时候开始皆大欢喜了。。。。。。<span style="color:#fe2c24;"><strong>错</strong></span>！</p> 
<h2 id="%E4%B8%89%E3%80%81%E9%97%AE%E9%A2%98%E6%9A%B4%E9%9C%B2%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF">三、问题暴露及修复思路</h2> 
<h3 id="1%E3%80%81%E9%97%AE%E9%A2%98%E5%8E%9F%E7%94%B1">1、问题原由</h3> 
<p>本次自定义样式是继承 AbstractColumnWidthStyleStrategy 重写 setColumnWidth 方法实现，但这个实现类底层有自己的限制性条件，如果导出的行数据过多大几千起步且需要<strong><span style="color:#fe2c24;">修改</span></strong>单元格样式（<span style="color:#4da8ee;">不做修改操作是没事的</span>），是会直接报错：</p> 
<h2 id="The%20maximum%20number%20of%20cell%20styles%20was%20exceeded.%20You%20can%20define%20up%20to%2064000%20styles">The maximum number of cell styles was exceeded. You can define up to 64000 styles</h2> 
<p>知其原由，找到限制的位置在：createCellStyle()</p> 
<p>Workbook：</p> 
<pre><code class="language-java">public interface Workbook extends Closeable, Iterable&lt;Sheet&gt; {
    //...................
    CellStyle createCellStyle();
    //...................
}</code></pre> 
<p>XSSFWorkbook：</p> 
<pre><code class="language-java">public class XSSFWorkbook extends POIXMLDocument implements Workbook, Date1904Support {
    //...................
    public XSSFCellStyle createCellStyle() {
        return this.stylesSource.createCellStyle();
    }
    //...................
}</code></pre> 
<p>StylesTable：</p> 
<pre><code class="language-java">public class StylesTable extends POIXMLDocumentPart implements Styles {
    //...................
	public XSSFCellStyle createCellStyle() {
        if (this.getNumCellStyles() &gt; MAXIMUM_STYLE_ID) {
            throw new IllegalStateException("The maximum number of Cell Styles was exceeded. You can define up to " + MAXIMUM_STYLE_ID + " style in a .xlsx Workbook");
        } else {
            int xfSize = this.styleXfs.size();
            CTXf xf = org.openxmlformats.schemas.spreadsheetml.x2006.main.CTXf.Factory.newInstance();
            xf.setNumFmtId(0L);
            xf.setFontId(0L);
            xf.setFillId(0L);
            xf.setBorderId(0L);
            xf.setXfId(0L);
            int indexXf = this.putCellXf(xf);
            return new XSSFCellStyle(indexXf - 1, xfSize - 1, this, this.theme);
        }
    }
    //...................
    //...................
    static {
        MAXIMUM_STYLE_ID = SpreadsheetVersion.EXCEL2007.getMaxCellStyles();
    }
}</code></pre> 
<p>SpreadsheetVersion：</p> 
<pre><code class="language-java">public enum SpreadsheetVersion {
    EXCEL97(65536, 256, 30, 3, 4000, 32767),
    EXCEL2007(1048576, 16384, 255, 2147483647, 64000, 32767);

    //...................
    private SpreadsheetVersion(int maxRows, int maxColumns, int maxFunctionArgs, int maxCondFormats, int maxCellStyles, int maxText) {
        this._maxRows = maxRows;
        this._maxColumns = maxColumns;
        this._maxFunctionArgs = maxFunctionArgs;
        this._maxCondFormats = maxCondFormats;
        this._maxCellStyles = maxCellStyles;
        this._maxTextLength = maxText;
    }
    //...................
    public int getMaxCellStyles() {
        return this._maxCellStyles;
    }
    //...................
}</code></pre> 
<p>定位到方法后，就要想办法处理了。</p> 
<h3 id="2%E3%80%81%E5%B0%86%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%88%96%E6%98%AF%E6%9E%9A%E4%B8%BE%E6%96%B9%E6%B3%95Copy%E9%87%8D%E5%86%99">2、将底层实现或是枚举方法Copy重写</h3> 
<p>        比较费时费力，而且需要熟悉接口层相关的关联依赖</p> 
<h3 id="3%E3%80%81%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E7%B1%BB">3、重新定义实现类</h3> 
<p>    将RegisterStyle 替换为 重写 CellWriteHandler 的另一个自定义实现类 CustomCellStyleHandler</p> 
<pre><code class="language-java">/**
 * excel 自定义样式
 */
public class CustomCellStyleHandler implements CellWriteHandler {
    
    @Override
    public void beforeCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, 
                                 Row row, Head head, Integer columnIndex, Integer relativeRowIndex, Boolean isHead) {
        //此处提醒下 beforeCellCreate 的row.getCell(i) 已经获取不到值了， 只会返回NULL
        Cell cell = row.getCell(columnIndex);
    }

    @Override
    public void afterCellDispose(CellWriteHandlerContext context) {
        if (BooleanUtils.isNotTrue(context.getHead())) {
            // 获取当前行的行号
            Cell cell = context.getCell();
            if (ObjectUtil.isNotNull(cell)) {
                String stringValue = cell.getStringCellValue();
                if (CharSequenceUtil.isNotEmpty(stringValue) &amp;&amp; stringValue.startsWith("-")) {
                    WriteCellData&lt;?&gt; cellData = context.getFirstCellData();
                    WriteCellStyle writeCellStyle = cellData.getOrCreateStyle();
                    WriteFont writeFont = new WriteFont();
                    writeFont.setColor(IndexedColors.RED.getIndex());
                    writeCellStyle.setWriteFont(writeFont);
                }
            }
        } else {
            // 表头自适应列宽
            Cell cell = context.getCell();
            int length = cell.getStringCellValue().getBytes().length;
            WriteSheetHolder writeSheetHolder = context.getWriteSheetHolder();
            writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), length * 300);
        }
    }
}</code></pre> 
<p>测试1W数据，<span style="color:#a2e043;"><strong>成功</strong></span>！！！！！（更大的数据量待各位自行验证）</p> 
<p>遗留问题：2-1 步骤中的文件名 <span style="color:#fe2c24;">fileName=testName </span>如何设置为中文名称</p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%C2%A0">四、百万级别数据导出 </h2> 
<p>参考文章：<a class="link-info" href="https://blog.csdn.net/lisu061714112/article/details/128882244" title="百万级数据excel导出功能如何实现？">百万级数据excel导出功能如何实现？</a></p> 
<p>Controller层</p> 
<p>添加 <span style="color:#ff9900;">@Idempotent </span>注解，防止多次点击，处理幂等</p> 
<pre><code class="language-java">    @GetMapping("/export-excel")
    @Operation(summary = "导出测试 Excel")
    @OperateLog(type = EXPORT)
    @Idempotent
    public void exportTestExcel(@Valid ReqVO reqVO) {
    	//type: 0-待执行，1-执行中，2-成功，3-失败
        downloadReportService.createDownloadResport(DownloadReportDO.builder().type(0).build());
        testService.exportExcel(reqVO);
    }</code></pre> 
<p>Service层</p> 
<pre><code class="language-java">@Async
    @Override
    public void exportExcel(ReqVO reqVO) {
    	//查看是否有待执行下载的文件
        DownloadReportRespVO downLoadInfo = validAndGetInfoByType(reqVO.getType());
        downLoadInfo.setStatus(1);
        //设置文件名
        String filename = LocalDateTimeUtil.format(LocalDateTimeUtil.now(), "yyyyMMdd") + "测试表.xlsx";
        String filePath = 'H://' + filename;
        try {
        	//创建文件
            File file = new File(filePath);
            //目录不存在则创建目录
	        if (!file.getParentFile().exists()) {
	            Files.createDirectories(file.getParentFile().toPath());
	        }
            //文件不存在则创建文件
	        if (!file.exists()) {
	            Files.createFile(file.toPath());
	        }
            OutputStream outputStream = Files.newOutputStream(file.toPath());

           	//此处可往上参考：2-1、自定义表头格式，并对数据做处理
            //获取表头和列展示情况 
            ArrayList&lt;List&lt;String&gt;&gt; headTitleList = getHeadTitle(colMap);

            ExcelWriter excelWriter = EasyExcel.write(outputStream, null).head(headTitleList)
                    .autoCloseStream(false) // 不要自动关闭，交给 Servlet 自己处理
                    .registerWriteHandler(new CustomCellStyleHandler()).build();
            //查询数据总数
            Long totalCount = testMapper.selectCount(reqVO);
            log.info("本次 信息导出，查询到数据有 {} 条", totalCount);

            //此处开始做sheet切分用，每50W切换一个sheet
            long MAX_SINGLE_PAGE = 500000;
            if (ObjectUtil.isNotNull(totalCount) &amp;&amp; totalCount != 0) {
            	//固定分页1，单页查询10W条
                reqVO.setPageNo(1);
                reqVO.setPageSize(100000);
                //计算出总共要几个sheet
                long sheetPageNumber = (totalCount % MAX_SINGLE_PAGE == 0) ? totalCount / MAX_SINGLE_PAGE : (totalCount / MAX_SINGLE_PAGE) + 1;
                List&lt;DemoDataRespVO&gt; dataList = CollUtil.newArrayList();
                WriteSheet writeSheet = null;
                for (int i = 0; i &lt; sheetPageNumber; i++) {
                    writeSheet = EasyExcel.writerSheet("sheet" + i).build();
                    long currentDataTotal = (sheetPageNumber - 1) == i ? totalCount - (MAX_SINGLE_PAGE * i) : MAX_SINGLE_PAGE;
                    for (long tempTotal = 0L; tempTotal &lt; currentDataTotal; ) {
                    	//查询分页接口，此处不例句展示
                        PageResult&lt;DemoDataRespVO&gt; pageReuslt = selecPageList(reqVO);
                        dataList = pageReuslt.getList();
                        if (CollUtil.isEmpty(dataList)) {
                            break;
                        }
                        //获取本次列表中最小的 id 游标，（！！列表数据是 id 倒序排序）
                        long minId = dataList.stream().mapToLong(CollectUserRevenueRespVO::getId).min().orElse(-1);
                        reqVO.setMinId(minId);
                        tempTotal += dataList.size();
                        //此处的getDisposeDataList是做数据的二次封装处理，无需处理的可跳过，这里不详解
                        excelWriter.write(getDisposeDataList(dataList), writeSheet);
                    }
                }
                //处理最后一行合计
                DemoDataRespVO respVO = selectTotal(reqVO);
                respVO.setData0("合计");
                dataList.add(respVO);
                excelWriter.write(getDisposeDataList(dataList, colMap), writeSheet);
                // 结束写入
                excelWriter.finish();

                //Excel处理成功，将表格上次到OSS存储桶位置，然后返回下载链接
                byte[] fileBytes = FileUtil.readBytes(file);
                FileCreateReqDTO fileCreateReqDTO = new FileCreateReqDTO();
                fileCreateReqDTO.setName(filename);
                fileCreateReqDTO.setPath(filePath);
                fileCreateReqDTO.setContent(fileBytes);
                Response&lt;String&gt; fileResult = fileTool.createFile(fileCreateReqDTO);
                if (fileResult.success()) {
                	String downUrl = fileResult.getData();
                	downLoadInfo.setDownUrl(downUrl);
                	downLoadInfo.setStatus(2);
                } else {
                	downLoadInfo.setStatus(3);
                }
            }
        } catch (Exception e) {
            downLoadInfo.setStatus(3);
            log.error("[exportExcel] [测试表 - 导出失败]] - {}", e);
            throw RunException("导出失败");
        } finally {
        	//更新本次导出下载表格的结果
            downloadReportService.updateDownloadResport(downLoadInfo);
        }
    }</code></pre> 
<h3 id="%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF">处理思路</h3> 
<p>对于百万级起步的导出方法exportExcel使用的处理点：<br> 1、service层使用异步，可让Controller层及时响应前端，进度通过中间表（download_report）查询<br> 2、数据切割：按每50W一个sheet操作（上述方法中的数据计算是按50W为一个sheet，查询按每页10W数据处理，可自行优化计算方式，这里偷懒）<br> 3、数据搜索：大数据量直接分页查询越往后越会超时，上述方法分页是ID倒序，每页以最后一个ID作为游标，从此ID定位再开始继续往下搜索，可提升查询效率<br> 4、SQL查询使用ID嵌套定位查询（利用自身的主键索引理念），如下：</p> 
<pre><code class="language-sql">select t1.* 
from test_data t1,
    ( select id from data_collect_user_revenue where id &amp;lt; #{minId} order by create_date desc, id desc limit #{(pageNo-1)*pageSize},#{pageSize}
    ) t2 where t1.id = t2.id</code></pre> 
<p>这里测试数据 1155371 条<br> 上传成功后返回下载链接，点击后结果数据如下：</p> 
<p><img alt="" height="438" src="https://images2.imgbox.com/03/e9/tQkNF53k_o.png" width="1200"><img alt="" height="275" src="https://images2.imgbox.com/40/9a/ldd9jZ5l_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/24cf819553cf8f1d40a30e48866a5c2c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">斜杠/、反斜杠\与转义字符</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5736a286584a1e0ad739e00831ebc96e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分布式（9）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>