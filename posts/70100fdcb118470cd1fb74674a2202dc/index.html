<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>神经网络模型训练及验证套路 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="神经网络模型训练及验证套路" />
<meta property="og:description" content="目录
0. 数据集CIFAR10
1. 神经网络模型训练套路：
1.1 网络模型搭建：
1.2 网络模型训练： 1.3 GPU加速：
法（一）：
法（二）：
1.4 网络模型保存
1.5 训练结果
2. 神经网络模型验证套路
2.1 网络模型加载
2.2 网络模型验证
0. 数据集CIFAR10 以数据集CIFAR10为例，搭建网络模型进行训练、验证。
pytorch上关于CIFAR10数据集的文档： 获取数据集：
train_data = torchvision.datasets.CIFAR10(root=&#34;../dataset&#34;, train=True, transform=torchvision.transforms.ToTensor(), download=True) test_data = torchvision.datasets.CIFAR10(root=&#34;../dataset&#34;, train=False, transform=torchvision.transforms.ToTensor(), download=True) debug结果： 可获取数据集 class 与 targets (即label）的关系。
1. 神经网络模型训练套路： step1. 准备数据集dataset，及数据加载dataloader
step2.搭建网络模型
step3.创建损失函数、优化器
step4.设置训练参数（epoch..)
step5.网络进入训练状态（调用model.train()）
(1) 从train_dataloader中加载数据
(2) 计算损失函数
(3) 反向传播，优化器优化
(4) print, tensorboard 展示输出
step7. 每个epoch训练完成后，网络进入测试状态（调用model.eval())
(1) 在with torch.no_grad下进行（只测试，无梯度优化）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/70100fdcb118470cd1fb74674a2202dc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-18T16:55:45+08:00" />
<meta property="article:modified_time" content="2023-01-18T16:55:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">神经网络模型训练及验证套路</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A00.%20%E6%95%B0%E6%8D%AE%E9%9B%86CIFAR10-toc" style="margin-left:0px;"><a href="#%C2%A00.%20%E6%95%B0%E6%8D%AE%E9%9B%86CIFAR10" rel="nofollow"> 0. 数据集CIFAR10</a></p> 
<p id="1.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%A5%97%E8%B7%AF%EF%BC%9A-toc" style="margin-left:0px;"><a href="#1.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%A5%97%E8%B7%AF%EF%BC%9A" rel="nofollow">1. 神经网络模型训练套路：</a></p> 
<p id="1.1%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.1%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA%EF%BC%9A" rel="nofollow">1.1 网络模型搭建：</a></p> 
<p id="1.2%20%E8%AE%AD%E7%BB%83%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#1.2%20%E8%AE%AD%E7%BB%83%EF%BC%9A%C2%A0" rel="nofollow">1.2 网络模型训练： </a></p> 
<p id="1.3%20GPU%E5%8A%A0%E9%80%9F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.3%20GPU%E5%8A%A0%E9%80%9F%EF%BC%9A" rel="nofollow">1.3 GPU加速：</a></p> 
<p id="%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A" rel="nofollow">法（一）：</a></p> 
<p id="%C2%A0%20%C2%A0%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A" rel="nofollow"> 法（二）：</a></p> 
<p id="1.4%C2%A0%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%BF%9D%E5%AD%98-toc" style="margin-left:40px;"><a href="#1.4%C2%A0%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%BF%9D%E5%AD%98" rel="nofollow">1.4  网络模型保存</a></p> 
<p id="1.4%20%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#1.4%20%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C" rel="nofollow">1.5 训练结果</a></p> 
<p id="2.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E5%A5%97%E8%B7%AF-toc" style="margin-left:0px;"><a href="#2.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E5%A5%97%E8%B7%AF" rel="nofollow">2. 神经网络模型验证套路</a></p> 
<p id="2.1%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD-toc" style="margin-left:40px;"><a href="#2.1%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD" rel="nofollow">2.1 网络模型加载</a></p> 
<p id="2.2%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81-toc" style="margin-left:40px;"><a href="#2.2%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81" rel="nofollow">2.2 网络模型验证</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A00.%20%E6%95%B0%E6%8D%AE%E9%9B%86CIFAR10"> 0. 数据集CIFAR10</h2> 
<p>        以数据集CIFAR10为例，搭建网络模型进行训练、验证。</p> 
<p><img alt="" height="776" src="https://images2.imgbox.com/95/dc/NJMxAIQV_o.png" width="1200"></p> 
<p><strong>pytorch上关于CIFAR10数据集的文档： </strong></p> 
<p><img alt="" height="477" src="https://images2.imgbox.com/3b/a7/SjNwU9VZ_o.png" width="894"></p> 
<p><strong>获取数据集：</strong></p> 
<pre><code class="hljs">train_data = torchvision.datasets.CIFAR10(root="../dataset", train=True, transform=torchvision.transforms.ToTensor(),
                                          download=True)
test_data = torchvision.datasets.CIFAR10(root="../dataset", train=False, transform=torchvision.transforms.ToTensor(),
                                          download=True)</code></pre> 
<p><strong>debug结果： </strong>可获取数据集 class 与 targets (即label）的关系。</p> 
<p><img alt="" height="644" src="https://images2.imgbox.com/8c/35/PxlvnkKM_o.png" width="1200"> </p> 
<p> </p> 
<h2 id="1.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%A5%97%E8%B7%AF%EF%BC%9A"><strong>1. 神经网络模型训练套路：</strong></h2> 
<p>step1. 准备数据集dataset，及数据加载dataloader</p> 
<p>step2.搭建网络模型</p> 
<p>step3.创建损失函数、优化器</p> 
<p>step4.设置训练参数（epoch..)</p> 
<p>step5.网络进入训练状态（调用model.train()）</p> 
<p>        (1) 从train_dataloader中加载数据</p> 
<p>        (2) 计算损失函数</p> 
<p>        (3) 反向传播，优化器优化</p> 
<p>        (4) print, tensorboard 展示输出</p> 
<p>step7. 每个epoch训练完成后，网络进入测试状态（调用model.eval())</p> 
<p>        (1) 在with torch.no_grad下进行（只测试，无梯度优化）</p> 
<p>        (2) 从test_dataloader中加载数据</p> 
<p>        (3) 计算指标（loss,acc)，展示模型效果</p> 
<p>step8. 保存模型</p> 
<p><strong>PS:</strong> model.train() 和model.eval() 只对特定层作用，故可不调用，但网络中出现特定层时，必须调用。</p> 
<p><img alt="" height="153" src="https://images2.imgbox.com/08/77/xVBUKsG2_o.png" width="810"></p> 
<p><img alt="" height="147" src="https://images2.imgbox.com/2f/e8/eHqPK9Zb_o.png" width="797"></p> 
<h3 id="1.1%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA%EF%BC%9A"><strong>1.1 网络模型搭建：</strong></h3> 
<p><strong>参考的网络模型结构：</strong><br> (from:)<a href="https://www.researchgate.net/publication/312170477_On_Classification_of_Distorted_Images_with_Deep_Convolutional_Neural_Networks" rel="nofollow" title="https://www.researchgate.net/publication/312170477_On_Classification_of_Distorted_Images_with_Deep_Convolutional_Neural_Networks">https://www.researchgate.net/publication/312170477_On_Classification_of_Distorted_Images_with_Deep_Convolutional_Neural_Networks</a></p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/39/d6/7xrklDai_o.png" width="1144"></p> 
<pre><code>import torch
from torch import nn


# 搭建神经网络
class MyModel(nn.Module):
    def __init__(self):
        super(MyModel, self).__init__()
        self.model = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=32, kernel_size=5, stride=1, padding=2),
            nn.MaxPool2d(kernel_size=2),
            nn.Conv2d(in_channels=32, out_channels=32, kernel_size=5, stride=1, padding=2),
            nn.MaxPool2d(kernel_size=2),
            nn.Conv2d(in_channels=32, out_channels=64, kernel_size=5, stride=1, padding=2),
            nn.MaxPool2d(kernel_size=2),
            nn.Flatten(),
            nn.Linear(in_features=64 * 4 * 4, out_features=64),
            nn.Linear(in_features=64, out_features=10),
        )

    def forward(self, x):
        x = self.model(x)
        return x


# # 验证模型是否搭建正确：4维张量(64,3,32,32) -&gt; model -&gt; 2维张量(64,10)
# if __name__ == '__main__':
#     myModel = MyModel()
#     input = torch.ones((64, 3, 32, 32))
#     output = myModel(input)
#     print("output.shape: ", output.shape)
#</code></pre> 
<h3 id="1.2%20%E8%AE%AD%E7%BB%83%EF%BC%9A%C2%A0"><strong>1.2 网络模型训练：</strong> </h3> 
<pre><code>import torch
import torchvision
from torch.utils.data import DataLoader
from torch.utils.tensorboard import SummaryWriter
from Mymodel_CIFAR10 import *   # 搭建的神经网络模型

# 定义训练的设备
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# 准备数据集
train_data = torchvision.datasets.CIFAR10(root="../dataset", train=True, transform=torchvision.transforms.ToTensor(),
                                          download=True)
test_data = torchvision.datasets.CIFAR10(root="../dataset", train=False, transform=torchvision.transforms.ToTensor(),
                                          download=True)

# 数据集长度
train_data_size = len(train_data)
test_data_size = len(test_data)
print("train_data_size: {}".format(train_data_size))
print("test_data_size: {}".format(test_data_size))

# Dataloader 加载数据
train_data_loader = DataLoader(train_data, batch_size=64)
test_data_loader = DataLoader(test_data, batch_size=64)

# 搭建网络模型
myModel = MyModel()
myModel.to(device)

# 损失函数--交叉熵
loss_fn = nn.CrossEntropyLoss()
loss_fn.to(device)

# 优化器
learning_rate = 1e-2
optimizer = torch.optim.SGD(myModel.parameters(), lr=learning_rate)

# 设置训练网络的一些参数
# 记录训练的次数
total_train_step = 0
# 记录测试的次数
total_test_step = 0
# 训练的轮数
epoch = 30

# 添加tensorboard
writer = SummaryWriter("train_logs")

for i in range(epoch):
    print("-----------------第{}轮训练开始--------------------".format(i+1))

    # 训练步骤开始
    myModel.train()
    for data in train_data_loader:
        imgs, targets = data
        imgs = imgs.to(device)
        targets = targets.to(device)
        outputs = myModel(imgs)
        loss = loss_fn(outputs, targets)

        # 优化器优化模型
        optimizer.zero_grad()   # 梯度清0
        loss.backward()  # 调用损失，反向传播
        optimizer.step()    # 对每一步进行优化

        total_train_step = total_train_step + 1
        if total_train_step % 100 == 0:
            print("训练次数：{}, Loss: {}".format(total_train_step, loss.item()))
            writer.add_scalar("train_loss", loss.item(), total_train_step)

    # 测试步骤开始：
    # 每跑完一轮，用测试数据测试模型，以测试数据损失及正确率评估该模型是否训练好
    myModel.eval()
    total_test_loss = 0
    total_acc_sum = 0
    with torch.no_grad():
        for data in test_data_loader:
            imgs, targets = data
            imgs = imgs.to(device)
            targets = targets.to(device)
            outputs = myModel(imgs)
            loss = loss_fn(outputs, targets)
            total_test_loss = total_test_loss + loss.item()
            acc_sum = (outputs.argmax(1) == targets).sum()
            total_acc_sum = total_acc_sum + acc_sum

    print("整体测试数据集上的Loss: {}".format(total_test_loss))
    print("整体测试数据集上的acc: {}".format(total_acc_sum/test_data_size))
    total_test_step = i
    writer.add_scalar("test_loss", total_test_loss, total_test_step)
    writer.add_scalar("test_acc", total_acc_sum/test_data_size, total_test_step)

    # 法（一）：保存模型+训练参数
    torch.save(myModel, "saved_models/myModel_{}.path".format(i))
    # # 法（二）：仅保存模型参数
    # torch.save(myModel.state_dict(), "myModel_{}.path".format(i))
    print("模型已保存")

writer.close()
</code></pre> 
<h3 id="1.3%20GPU%E5%8A%A0%E9%80%9F%EF%BC%9A"><strong>1.3 GPU加速：</strong></h3> 
<p>        将网络模型、输入数据（图片和label值) 、损失函数 加载至cuda上。</p> 
<h4 id="%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A"><strong>法（一）：</strong></h4> 
<pre><code># 网络模型
myModel = MyModel()
if torch.cuda.is_available():
    myModel = myModel.cuda()    </code></pre> 
<pre><code># 损失函数
loss_fn = nn.CrossEntropyLoss()
if torch.cuda.is_available():
    loss_fn = loss_fn.cuda()</code></pre> 
<pre><code># 输入数据（图片+label值)
for data in test_data_loader:
    if torch.cuda.is_available():
        imgs, targets = data
        imgs = imgs.cuda()
        targets = targets.cuda()</code></pre> 
<h4 id="%C2%A0%20%C2%A0%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A"><strong> 法（二）：</strong></h4> 
<pre><code># 定义训练的设备
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")</code></pre> 
<pre><code># 网络模型
myModel = MyModel()
myModel.to(device)</code></pre> 
<pre><code># 损失函数
loss_fn = nn.CrossEntropyLoss()
loss_fn.to(device)</code></pre> 
<pre><code># 输入数据（图片+label值)
for data in test_data_loader:
    imgs, targets = data
    imgs = imgs.to(device)
    targets = targets.to(device)</code></pre> 
<h3 id="1.4%C2%A0%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%BF%9D%E5%AD%98">1.4  网络模型保存</h3> 
<p>法（一）</p> 
<pre><code class="hljs"># 模型保存方式1:模型结构+训练参数
torch.save(myModel, "save_models/CIFAR10model_save1.path")</code></pre> 
<p>法（二）</p> 
<pre><code class="hljs"># 模型保存方式2:模型训练参数（官方推荐）
torch.save(myModel.state_dict(), "save_models/CIFAR10model_save2.path")</code></pre> 
<p> </p> 
<h3 id="1.4%20%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C">1.5 训练结果</h3> 
<p>（30 个 epoch）</p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/08/67/HBNkpTLt_o.png" width="1182"></p> 
<p> <img alt="" height="530" src="https://images2.imgbox.com/31/25/JHKcyfj8_o.png" width="1178"></p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/78/05/jYrvPIjF_o.png" width="1178"></p> 
<p> </p> 
<h2 id="2.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E5%A5%97%E8%B7%AF">2. 神经网络模型验证套路</h2> 
<p>step1. 准备用于验证的图片</p> 
<p>step2. 对验证图片进行transform预处理，以满足网络模型的输入要求</p> 
<p>step3. 加载保存的网络模型</p> 
<p>step4. 调用model.eval()，进入验证状态</p> 
<p>         （1） 在with torch.no_grad下进行（只测试，无梯度优化）</p> 
<p>         （2）输入验证图片，验证预测结果</p> 
<h3 id="2.1%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD">2.1 网络模型加载</h3> 
<p>法（一）：对应 模型保存方式1:模型结构+训练参数</p> 
<pre><code class="hljs"># 模型结构+模型参数
model1 = torch.load("save_models/CIFAR10model_save1.path")
print(model1)
</code></pre> 
<p>法（二）： 对应 模型保存方式2:训练参数</p> 
<pre><code class="hljs"># 模型参数
model2 = MyModel() # 定义网络模型结构
model2.load_state_dict(torch.load("save_models/CIFAR10model_save2.path"))
print(model2)</code></pre> 
<h3 id="2.2%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81">2.2 网络模型验证</h3> 
<p>在网上下载一个小狗图片作为<strong>验证图片：</strong></p> 
<p class="img-center"><img alt="" height="278" src="https://images2.imgbox.com/15/eb/I88znYft_o.png" width="300"></p> 
<p><strong>验证代码： </strong></p> 
<pre><code class="hljs">import torch
import torchvision.transforms
from PIL import Image
from Mymodel_CIFAR10 import *   # 搭建的神经网络模型

# 定义设备
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# CIFAR20: class_to_idx
class_to_idx = ['airplane', 'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck']

# 准备用于验证的图片
image_path = "imgs/dog.png"
image = Image.open(image_path)
print(image)
image = image.convert('RGB')    # png图片是4通道
print(image)

# 对验证图片进行预处理，满足网络模型输入要求
transform = torchvision.transforms.Compose([torchvision.transforms.Resize((32, 32)),
                                            torchvision.transforms.ToTensor()])
image = transform(image)
image = torch.reshape(image, (1, 3, 32, 32))    # 3维张量[3,32,32] -&gt; reshape -&gt; 4维张量[1,3,32,32]
print(image.shape)

# 加载保存的网络模型
# （一）模型+模型参数
model = torch.load("saved_models/myModel_29.path")  # GPU网络模型
# # （二）模型参数
# model = MyModel( )  # 定义网络模型结构
# model.to(device)
# model.load_state_dict(torch.load("myData_0.path"))
print(model)

# validate
model.eval()
with torch.no_grad():
    image = image.to(device)    # 将输入数据加载为GPU数据类型
    output = model(image)

output_target = output.argmax(1).item()
print("scores: ", output)
print("prediction target: ", class_to_idx[output_target])

</code></pre> 
<p><strong>验证结果：</strong></p> 
<p><img alt="" height="698" src="https://images2.imgbox.com/e3/47/5jOlyZct_o.png" width="1200"></p> 
<p> </p> 
<p>感谢B站的小土堆导师，入门啦入门啦！</p> 
<p><a href="https://www.bilibili.com/video/BV1hE411t7RN/?p=33&amp;spm_id_from=333.880.my_history.page.click&amp;vd_source=a2b7029e58d3c675b2d4ea72e64ea4f5" rel="nofollow" title="https://www.bilibili.com/video/BV1hE411t7RN?p=32">https://www.bilibili.com/video/BV1hE411t7RN?p=32</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be1963b30181aad1f8b75ab86fdc25d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">82.长短期记忆网络（LSTM）以及代码实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/945b40548e8635c5a768dc5044a5ce41/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pgsql中如何进行循环遍历与执行传递进行的变量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>