<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;11 笔记】关键字剖析 —— this - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;11 笔记】关键字剖析 —— this" />
<meta property="og:description" content="目录
一、this 和 Python-self
二、this 指针
2.1 this 与 类成员
2.2 this 与 const 成员函数
2.3 在成员函数中返回 this
三、小结
3.1 this 指针再叙
3.2 this 指针用途
3.3 this 指针使用
一、this 和 Python-self 在 Python 中定义类时，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将 self 参数作为方法的第一个参数。当然，之所以命名为 self，只是程序员间约定俗成的一种习惯，使代码更具可读性。同一个类可实例化为多个对象，当某个类实例对象调用方法 (即“成员函数”) 时，它会把自身的引用作为第一个参数自动传给该方法，换言之，Python 会自动绑定类方法的第一个参数 self 指向调用该方法的对象。如此，Python 解释器就能知道到底要操作哪个对象的方法了。因此，程序在调用类实例方法和构造方法时，无需手动为第一个参数传值。抛砖引玉，Python 类方法中的 self 参数就相当于 C&#43;&#43; 中的 this 指针。更具体地：
在 C&#43;&#43; 中，每一个类实例对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数 (即“方法”) 的隐含参数。因此，在成员函数内部，this 指针 可用于指向调用该成员函数的类实例对象。
注意，友元函数没有 this 指针，因为友元不是类的成员，只有成员函数才有 this 指针。
二、this 指针 2.1 this 与 类成员 首先，看个例子：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/706d8889bc81927092a922fbfbc11ad0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-22T23:54:56+08:00" />
<meta property="article:modified_time" content="2021-01-22T23:54:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;11 笔记】关键字剖析 —— this</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81this%20%E5%92%8C%20Python-self-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81this%20%E5%92%8C%20Python-self" rel="nofollow">一、this 和 Python-self</a></p> 
<p id="%E4%BA%8C%E3%80%81this%20%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81this%20%E6%8C%87%E9%92%88" rel="nofollow">二、this 指针</a></p> 
<p id="2.1%20this%20%E4%B8%8E%20%E7%B1%BB%E6%88%90%E5%91%98-toc" style="margin-left:40px;"><a href="#2.1%20this%20%E4%B8%8E%20%E7%B1%BB%E6%88%90%E5%91%98" rel="nofollow">2.1 this 与 类成员</a></p> 
<p id="2.2%20this%20%E4%B8%8E%20const%20%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.2%20this%20%E4%B8%8E%20const%20%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">2.2 this 与 const 成员函数</a></p> 
<p id="2.3%20%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%20this-toc" style="margin-left:40px;"><a href="#2.3%20%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%20this" rel="nofollow">2.3 在成员函数中返回 this</a></p> 
<p id="2.4%20%E5%B0%8F%E7%BB%93-toc" style="margin-left:0px;"><a href="#2.4%20%E5%B0%8F%E7%BB%93" rel="nofollow">三、小结</a></p> 
<p id="3.1%20this%20%E6%8C%87%E9%92%88%E5%86%8D%E5%8F%99-toc" style="margin-left:40px;"><a href="#3.1%20this%20%E6%8C%87%E9%92%88%E5%86%8D%E5%8F%99" rel="nofollow">3.1 this 指针再叙</a></p> 
<p id="3.2%20this%20%E6%8C%87%E9%92%88%E7%94%A8%E9%80%94-toc" style="margin-left:40px;"><a href="#3.2%20this%20%E6%8C%87%E9%92%88%E7%94%A8%E9%80%94" rel="nofollow">3.2 this 指针用途</a></p> 
<p id="3.3%20this%20%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#3.3%20this%20%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8" rel="nofollow">3.3 this 指针使用</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%E3%80%81this%20%E5%92%8C%20Python-self">一、this 和 Python-self</h2> 
<p style="text-indent:33px;">在 Python 中定义类时，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将<span style="color:#f33b45;"> <strong>self </strong></span>参数作为方法的第一个参数。当然，之所以命名为 self，只是程序员间约定俗成的一种习惯，使代码更具可读性。<strong>同一个类可实例化为多个对象，当某个类实例对象调用方法 (即“成员函数”) 时，它会把自身的引用作为第一个参数自动传给该方法，换言之，Python 会自动绑定类方法的第一个参数 self 指向调用该方法的对象</strong>。如此，Python 解释器就能知道到底要操作哪个对象的方法了。因此，程序在调用类实例方法和构造方法时，无需手动为第一个参数传值。抛砖引玉，<span style="color:#3399ea;"><strong>Python 类方法中的 self 参数就相当于 C++ 中的 this 指针</strong></span>。更具体地：</p> 
<p style="text-indent:33px;">在 C++ 中，每一个类实例对象都能通过 <span style="color:#f33b45;"><strong>this</strong> </span>指针来访问自己的地址。<strong>this</strong> 指针是所有成员函数<strong> (即“方法”)</strong> 的隐含参数。因此，在成员函数内部，<strong>this</strong> 指针 <strong>可用于指向调用该成员函数的类实例对象</strong>。</p> 
<p style="text-indent:33px;">注意，<span style="color:#7c79e5;"><strong>友元函数没有 this 指针，因为友元不是类的成员，只有成员函数才有 this 指针</strong></span>。</p> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81this%20%E6%8C%87%E9%92%88">二、this 指针</h2> 
<hr> 
<h3 id="2.1%20this%20%E4%B8%8E%20%E7%B1%BB%E6%88%90%E5%91%98">2.1 this 与 类成员</h3> 
<p style="text-indent:33px;">首先，看个例子：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class Banana
{
public:
    // const member function
    int show_num_banana() const { return num_banana; }

private:
    // data member
    int num_banana = 0;
};

int main()
{   
    Banana obj1;
    cout &lt;&lt; obj1.show_num_banana() &lt;&lt; endl;

    system("pause");
    return 0;
}
</code></pre> 
<pre><code>0</code></pre> 
<p style="text-indent:33px;">在上例中，先实例化一个 Banana 类对象 obj1，然后通过点运算符来访问 obj1 对象的常成员函数（即“访问函数”）show_num_banana，然后调用它来访问私有数据成员 num_banana。</p> 
<p style="text-indent:33px;">其实，当调用类的成员函数时，实质是替某个类的实例对象调用它。如果 show_num_banana 指向 Banana 的成员（例如 num_banana），则它 <strong>隐式地指向调用该成员函数的类实例对象的成员</strong>。在上例中，<strong>当 show_num_banana 返回 num_banana 时，实际上它隐式地返回了 obj1.num_banana</strong>。</p> 
<p style="text-indent:33px;">事实上，<span style="color:#3399ea;"><strong>成员函数通过一个名为 this 的额外隐式参数来访问调用它的那个类实例对象</strong></span>，<span style="color:#7c79e5;"><strong>当调用一个成员函数时，用请求该成员函数的类实例对象的地址初始化 this</strong></span>。例如，若调用 obj1.show_num_banana()，则编译器负责把 obj1 的地址传递给 show_num_banana 的隐式形参 this，可等价地认为编译器将该调用重写成了以下形式：</p> 
<pre><code class="language-cpp">// 伪代码, 用于说明调用成员函数的实际执行过程
Banana::show_num_banana(&amp;obj1)
// 其中, 调用 Banana 的 show_num_banana 成员时传入了类实例 obj1 的地址</code></pre> 
<p style="text-indent:33px;"><span style="color:#3399ea;"><strong>在成员函数内部，则可直接使用调用该成员函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为 this 所指的正是这个对象</strong></span>。<strong><span style="color:#7c79e5;">任何对类成员的直接访问都被看作是对 this 的隐式引用</span></strong>。换言之，当 show_num_banana 使用 num_banana 时，它 <strong>隐式地使用 this 所指向的成员</strong>（即 <strong>调用 show_num_banana 的类实例对象的成员</strong>），就像是书写了 <strong>this-&gt;num_banana</strong> 一样。</p> 
<p style="text-indent:33px;">对用户而言，this 形参是隐式定义的。实际上，任何自定义名为 this 的参数或变量的行为都是非法的。成员函数体内，用户可显式地使用 this。因此，尽管没必要，还是能把 show_num_banana 定义成如下形式：</p> 
<pre><code class="language-cpp">int show_num_banana() const { return this-&gt;num_banana; }</code></pre> 
<p style="text-indent:33px;">因为 <span style="color:#3399ea;"><strong>this 的目的是 总指向</strong> <strong>调用类成员的类实例对象</strong></span>，所以<span style="color:#7c79e5;"><strong> this 是一个 (顶层) 常量指针，不允许改变 this 中保存的地址</strong></span>。</p> 
<hr> 
<h3 id="2.2%20this%20%E4%B8%8E%20const%20%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">2.2 this 与 const 成员函数</h3> 
<p style="text-indent:33px;">注意，常成员函数中，紧随形参列表之后的 const 的关键字，其作用是 <span style="color:#3399ea;"><strong>修改隐式 this 指针的类型</strong></span>。</p> 
<p style="text-indent:33px;">默认情况下，this 的类型是 <strong><span style="color:#7c79e5;">指向非常量类类型的常量指针（即顶层常量指针，指针本身是常量，指向非常量）</span></strong>。例如，Banana 中，若 show_num_banana 是非常成员函数，则其 this 的类型是<strong> </strong><span style="color:#e579b6;"><strong>Banana *const（切记不是 Banana const* !!! 二者完全不同）</strong></span>。尽管 this 是隐式的，也仍需遵循初始化规则，因此默认情况下，不能把 this 绑定/指向到一个常量对象上，导致 <strong>无法在一个常量对象上调用普通的成员函数（注意，只有常成员函数可以操作常量/常对象）</strong>。</p> 
<p style="text-indent:33px;">为此，需要把 this 声明成 <span style="color:#e579b6;"><strong>const Banana *const</strong> </span>类型 <strong>以便于 this 可以指向常量</strong>。然而，this 不会出现在成员函数的参数列表中。于是，C++ 允许令 const 紧随成员函数的参数列表之后，以表明 this 是一个指向常量的指针，此时的 const 成员函数即为 <span style="color:#e579b6;"><strong>常成员函数 (const member function)</strong></span>。这也是常成员函数声明中，形参列表后 const 关键字的由来。</p> 
<p style="text-indent:33px;">此时，不妨把 show_num_banana 的函数体想象成如下形式以便理解：</p> 
<pre><code class="language-cpp">// 伪代码, 用于说明隐式 this 指针如何使用
// 以下代码非法, 因为用户无法显式自定义 this 指针, 当然也不会出现在成员函数的参数列表中
// 谨记此处的 this 是一个指向常量的指针，因为 show_num_banana 是一个常量成员
int Banana::show_num_banana(const Banana *const this) { return this-&gt;show_num_banana; }  // 形参列表中, 靠右的是顶层 const, 靠左的是底层 const
</code></pre> 
<p style="text-indent:33px;">可见，<span style="color:#3399ea;"><strong>因为常成员函数的 this 是指向常量的指针（底层 const）</strong></span><strong>，</strong><span style="color:#3399ea;"><strong>所以常成员函数不能改变调用它的类实例对象的内容</strong></span>，这也是常成员函数又称为 “<strong>访问函数</strong>” 的原因（与之相对的是 “<strong>修改函数</strong>”）。相应地，上例的 show_num_coil 可读取调用它的类实例对象如 obj1 的数据成员，但不能更新或写入新值。</p> 
<p style="text-indent:33px;">总之，<span style="color:#7c79e5;"><strong>常量对象、常量对象的引用、常量对象的指针，都只能调用常量成员函数</strong></span>。</p> 
<hr> 
<h3 id="2.3%20%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%20this">2.3 在成员函数中返回 this</h3> 
<p style="text-indent:33px;">现在，再看一个内容稍丰富些的例子：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class Banana
{
public:
    // const member function
    int show_num_banana() const { return num_banana; }
    // common member function decleration
    Banana&amp; combine(const Banana&amp;);

public:
    // data member
    int num_banana = 0;
    double revenue_banana = 0.0;
};

Banana&amp; Banana::combine(const Banana&amp; rhs)
{   
    // 把 rhs 的数据成员加到 this 对象的数据成员上
    num_banana += rhs.num_banana;
    revenue_banana += rhs.revenue_banana;
    // 返回调用该成员函数的对象
    return *this;
}

int main()
{   
    Banana obj1;
    obj1.num_banana = 2;
    obj1.revenue_banana = 4.2;

    Banana obj2;
    obj2.num_banana = 3;
    obj2.revenue_banana = 8.3;

    obj1.combine(obj2);  // 相当于 in-place 操作
    cout &lt;&lt; obj1.num_banana &lt;&lt; " " &lt;&lt; obj1.revenue_banana &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<pre><code>5 12.5</code></pre> 
<p style="text-indent:33px;">可见，成员函数 combine 的设计类似于 += 的用途，但针对的是类实例对象（的数据成员）。<strong>当执行 obj1.combine(obj2); 时，obj1 的地址被绑定到隐式的 this 参数上，而 rhs 绑定到了 obj2 上</strong>。因此，当成员函数内执行 num_banana += rhs.num_banana; 时，效果等同于 obj1.num_banana += obj2.num_banana。</p> 
<p style="text-indent:33px;">其实，成员函数 combine 最值得关注的部分是其 <strong>返回类型 </strong>和 <strong>返回语句</strong>。</p> 
<p style="text-indent:33px;">一方面，当定义的函数类似某个内置运算符时，应令其行为尽量模仿该运算符。<strong>内置的赋值运算符将其左侧运算对象当成左值返回</strong>，因此，为保持一致，<strong>combine 必须返回引用类型</strong>，对应为 Banana&amp;。</p> 
<p style="text-indent:33px;">另一方面，<strong>无需使用隐式的 this 指针访问函数调用者的某个具体成员，而是需要把调用函数的对象当成一个整体来访问</strong> —— return *this;  其中，<strong>return 解引用 this 指针以获取调用和执行本函数的类实例对象</strong>。换言之，上述语句返回 obj1 的引用。</p> 
<hr> 
<h2 id="2.4%20%E5%B0%8F%E7%BB%93">三、小结</h2> 
<hr> 
<h3 id="3.1%20this%20%E6%8C%87%E9%92%88%E5%86%8D%E5%8F%99">3.1 this 指针再叙</h3> 
<blockquote> 
 <ol><li>this 实际是成员函数的一个形参，在调用成员函数时将类实例对象的地址作为实参传递给 this。但 this 形参是隐式的，并不出现在代码中，而是在编译阶段由编译器默默地将其添加到成员函数参数列表中。</li><li>this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数内，且只有在通过类实例对象调用成员函数时才给 this 赋值。此外，用户无法显式定义 this 指针。</li><li>this 默认为指向非常量的常量指针（顶层 const），其保存的之（所指向的类实例对象的地址）不可修改。</li><li>只有当类实例对象被创建后 this 才有意义，因此不能在 static 成员函数中使用，因为 static 成员函数与类相关联，而与具体的类实例对象无关。</li><li>在《<a href="http://c.biancheng.net/view/vip_2220.html" rel="nofollow">C++函数编译原理和成员函数的实现</a>》一节中讲到：成员函数最终被编译成与对象无关的普通函数，会丢失除成员变量外的所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。而这个额外的参数就是 this，它是成员函数和成员变量关联的桥梁。</li></ol> 
</blockquote> 
<h3 id="3.2%20this%20%E6%8C%87%E9%92%88%E7%94%A8%E9%80%94">3.2 this 指针用途</h3> 
<blockquote> 
 <ol><li>一个类实例对象的 this 指针并非该对象本身的一部分，不会影响 sizeof(对象) 的结果。</li><li>this 作用域限于类内部，当 在类的非静态成员函数中 访问类的非静态成员 时，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。换言之，即使没有显式写上 this 指针，编译器编译时也会加上 this。this 作为非静态成员函数的隐式形参，对各成员的访问均通过它进行。this 在成员函数的开始执行前构造，在成员的执行结束后清除。</li></ol> 
</blockquote> 
<h3 id="3.3%20this%20%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8">3.3 this 指针使用</h3> 
<blockquote> 
 <ol><li>在类的非静态成员函数中返回类实例对象本身时，直接使用 return *this。</li><li>当参数与成员变量同名时，如 this-&gt;n = n （不能写成 n = n)。</li></ol> 
</blockquote> 
<hr> 
<p><strong>参考文献</strong></p> 
<p style="text-indent:33px;"><strong>《C++ Primer 5th》</strong></p> 
<p style="text-indent:33px;"><a href="https://light-city.club/sc/basic_content/static/" rel="nofollow">https://light-city.club/sc/basic_content/static/</a></p> 
<p style="text-indent:33px;"><a href="https://www.runoob.com/cplusplus/cpp-this-pointer.html" rel="nofollow">https://www.runoob.com/cplusplus/cpp-this-pointer.html</a></p> 
<p style="text-indent:33px;"><a href="http://c.biancheng.net/view/2226.html" rel="nofollow">http://c.biancheng.net/view/2226.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/011dbfba5e14c2538747cca6f569a481/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">封装是什么意思?_IPFS中的P1,P2,C1,C2是什么意思，封装过程需要多久呢</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/22d799bad69eff934bf47fb26c61a4ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win10和ubuntu双系统下彻底删除ubuntu系统和grub引导</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>