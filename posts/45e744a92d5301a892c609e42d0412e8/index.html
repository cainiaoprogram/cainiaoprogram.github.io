<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>移动端适配 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="移动端适配" />
<meta property="og:description" content="目录
移动端的应用(主要包括三类):
移动端适配的原因
自适应:
响应式:
px、em、rem的理解
Viewport视口 一、视口的划分:
layout viewport 布局视口
visual viewport 视觉视口
ideal viewport 理想视口
二、视口大小的更改​​​​​​​
viewport属性各个参数：
移动端适配方法
一、rem(根倍率) &#43; 动态的根标签的font-size
1、媒体查询设置动态的html标签属性
2、通过JS动态计算html标签中的font-size
3、已经开源的库可以使用
二、vw(视口宽度)---推荐
三、flex(弹性布局)
移动端的应用(主要包括三类): 原生App开发: iOS、Android、RN、uniapp、Flutter等
原理:现在常用的前端框架是HTML、CSS、JS打包,在手机的浏览器中运行;原生app(RN)全是用JS编写,打包成为java或者OC语言,可以直接在手机中运行,不需要依赖浏览器
小程序开发: 微信小程序开发、uniapp等
web页面: Vue开发、React开发、uniapp等
原理:就是上面提到的,移动端的Web页面,可以使用浏览器或者WebView浏览
这里借用一张React-Nactive图片解释:
通过这张图片,我们就可以显而易见的知道两者的区别:
原生App直接与系统进行交互,与WebApp这种中间有浏览器或者WebView的显然要快,缺点也是显而易见的,拿我用过的RN为例,组件库中的组件相对来说比较少,变化和功能相对来说要少,再就是搭建环境和运行环境要比WebApp多,iOS和Android是两套代码,打包为的方式也不同.
移动端适配的原因 最主要的原因:屏幕大小
这里我们可以看见各种手机型号,不同手机型号的屏幕也不经相同,如果使用固定的尺寸,那么不同的App在不同手机上肯定不适配.
再加上现在平板、手表、曲面屏、折叠屏、车机显示屏、大的电视屏幕以及电脑屏幕,不同App想要做好用户体验以及开拓市场,那么App应用的适配性就至关重要.
自适应: 根据不同的设备屏幕大小来自动进行调整
响应式: 当屏幕的宽或者高进行改变时,会自动进行响应,并自动进行根据屏幕进行改变
比如:手机屏幕竖屏调整为横屏; 电脑窗口的宽或者高进行拉伸
px、em、rem的理解 简单的来讲:
px(像素),屏幕的每一个小方块亮的不同颜色的灯组成了屏幕,每一个小方块,就是一个像素em(相对长度单位),电脑的手机当你不给font-size是也会出现字体大小,这个就是设置的默认字体大小,所有未经调整的浏览器都符合: 1em=16px。根据这个计算,就可以算出默认字体大小对应的em,那么不同屏幕的默认不同,就会进行自适应和响应式rem(根元素): root em就可以简单的理解为相对于root &lt;html&gt;元素的单位, 还有一些rpx、fpx等其实都是根据这些出发的,了解了这些再看就会简单
网址:px、em 和 rem 三者区别_cbkting的博客-CSDN博客_rem em px
Viewport视口 一、视口的划分: 这里只针对移动端, pc端没有这种转换和划分
注意:&lt;meta name=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/45e744a92d5301a892c609e42d0412e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-08T20:37:11+08:00" />
<meta property="article:modified_time" content="2022-12-08T20:37:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">移动端适配</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8(%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%E4%B8%89%E7%B1%BB)%3A-toc" style="margin-left:0px;"><a href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8%28%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%E4%B8%89%E7%B1%BB%29%3A" rel="nofollow">移动端的应用(主要包括三类):</a></p> 
<p id="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E7%9A%84%E5%8E%9F%E5%9B%A0-toc" style="margin-left:0px;"><a href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E7%9A%84%E5%8E%9F%E5%9B%A0" rel="nofollow">移动端适配的原因</a></p> 
<p id="%E8%87%AA%E9%80%82%E5%BA%94%3A-toc" style="margin-left:80px;"><a href="#%E8%87%AA%E9%80%82%E5%BA%94%3A" rel="nofollow">自适应:</a></p> 
<p id="%E5%93%8D%E5%BA%94%E5%BC%8F%3A-toc" style="margin-left:80px;"><a href="#%E5%93%8D%E5%BA%94%E5%BC%8F%3A" rel="nofollow">响应式:</a></p> 
<p id="px%E3%80%81em%E3%80%81rem%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:80px;"><a href="#px%E3%80%81em%E3%80%81rem%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">px、em、rem的理解</a></p> 
<p id="Viewport%E8%A7%86%E5%8F%A3%C2%A0-toc" style="margin-left:0px;"><a href="#Viewport%E8%A7%86%E5%8F%A3%C2%A0" rel="nofollow">Viewport视口 </a></p> 
<p id="%E4%B8%80%E3%80%81%E8%A7%86%E5%8F%A3%E7%9A%84%E5%88%92%E5%88%86%3A-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E8%A7%86%E5%8F%A3%E7%9A%84%E5%88%92%E5%88%86%3A" rel="nofollow">一、视口的划分:</a></p> 
<p id="layout%C2%A0viewport%20%E5%B8%83%E5%B1%80%E8%A7%86%E5%8F%A3-toc" style="margin-left:80px;"><a href="#layout%C2%A0viewport%20%E5%B8%83%E5%B1%80%E8%A7%86%E5%8F%A3" rel="nofollow">layout viewport 布局视口</a></p> 
<p id="visual%20viewport%C2%A0%E8%A7%86%E8%A7%89%E8%A7%86%E5%8F%A3-toc" style="margin-left:80px;"><a href="#visual%20viewport%C2%A0%E8%A7%86%E8%A7%89%E8%A7%86%E5%8F%A3" rel="nofollow">visual viewport 视觉视口</a></p> 
<p id="ideal%20viewport%C2%A0%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3-toc" style="margin-left:80px;"><a href="#ideal%20viewport%C2%A0%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3" rel="nofollow">ideal viewport 理想视口</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E8%A7%86%E5%8F%A3%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%9B%B4%E6%94%B9-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E8%A7%86%E5%8F%A3%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%9B%B4%E6%94%B9" rel="nofollow"> 二、视口大小的更改</a>​​​​​​​</p> 
<p id="viewport%E5%B1%9E%E6%80%A7%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#viewport%E5%B1%9E%E6%80%A7%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A" rel="nofollow">viewport属性各个参数：</a></p> 
<p id="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%B3%95" rel="nofollow">移动端适配方法</a></p> 
<p id="%E4%B8%80%E3%80%81rem(%E6%A0%B9%E5%80%8D%E7%8E%87)%20%2B%C2%A0%E5%8A%A8%E6%80%81%E7%9A%84%E6%A0%B9%E6%A0%87%E7%AD%BE%E7%9A%84font-size-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81rem%28%E6%A0%B9%E5%80%8D%E7%8E%87%29%20%2B%C2%A0%E5%8A%A8%E6%80%81%E7%9A%84%E6%A0%B9%E6%A0%87%E7%AD%BE%E7%9A%84font-size" rel="nofollow">一、rem(根倍率) + 动态的根标签的font-size</a></p> 
<p id="1%E3%80%81%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E8%AE%BE%E7%BD%AE%E5%8A%A8%E6%80%81%E7%9A%84html%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E8%AE%BE%E7%BD%AE%E5%8A%A8%E6%80%81%E7%9A%84html%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7" rel="nofollow">1、媒体查询设置动态的html标签属性</a></p> 
<p id="2%E3%80%81%E9%80%9A%E8%BF%87JS%E5%8A%A8%E6%80%81%E8%AE%A1%E7%AE%97%3Chtml%3E%E4%B8%AD%E7%9A%84font-size-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E9%80%9A%E8%BF%87JS%E5%8A%A8%E6%80%81%E8%AE%A1%E7%AE%97%3Chtml%3E%E4%B8%AD%E7%9A%84font-size" rel="nofollow">2、通过JS动态计算html标签中的font-size</a></p> 
<p id="3%E3%80%81%E5%B7%B2%E7%BB%8F%E5%BC%80%E6%BA%90%E7%9A%84%E5%BA%93%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%B7%B2%E7%BB%8F%E5%BC%80%E6%BA%90%E7%9A%84%E5%BA%93%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8" rel="nofollow">3、已经开源的库可以使用</a></p> 
<p id="%E4%BA%8C%E3%80%81vw(%E8%A7%86%E5%8F%A3%E5%AE%BD%E5%BA%A6)-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81vw%28%E8%A7%86%E5%8F%A3%E5%AE%BD%E5%BA%A6%29" rel="nofollow">二、vw(视口宽度)---推荐</a></p> 
<p id="%E4%B8%89%E3%80%81flex(%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80)-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81flex%28%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%29" rel="nofollow">三、flex(弹性布局)</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8(%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%E4%B8%89%E7%B1%BB)%3A">移动端的应用(主要包括三类):</h2> 
<p><strong>原生App开发:  iOS、Android、RN、uniapp、Flutter等</strong></p> 
<p>原理:现在常用的前端框架是HTML、CSS、JS打包,在手机的浏览器中运行;原生app(RN)全是用JS编写,打包成为java或者OC语言,可以直接在手机中运行,不需要依赖浏览器</p> 
<p><strong>小程序开发:  微信小程序开发、uniapp等</strong></p> 
<p><strong>web页面:  Vue开发、React开发、uniapp等</strong></p> 
<p>原理:就是上面提到的,移动端的Web页面,可以使用浏览器或者WebView浏览</p> 
<p></p> 
<p>这里借用一张React-Nactive图片解释:</p> 
<p><img alt="" height="193" src="https://images2.imgbox.com/30/80/0nprBOFP_o.png" width="633"></p> 
<p>通过这张图片,我们就可以显而易见的知道两者的区别:</p> 
<p>        原生App直接与系统进行交互,与WebApp这种中间有浏览器或者WebView的显然要快,缺点也是显而易见的,拿我用过的RN为例,组件库中的组件相对来说比较少,变化和功能相对来说要少,再就是搭建环境和运行环境要比WebApp多,iOS和Android是两套代码,打包为的方式也不同.</p> 
<p></p> 
<h2 id="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E7%9A%84%E5%8E%9F%E5%9B%A0">移动端适配的原因</h2> 
<p><strong>最主要的原因:屏幕大小</strong></p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/dd/04/J6XpGUG2_o.png" width="465"></p> 
<p>        这里我们可以看见各种手机型号,不同手机型号的屏幕也不经相同,如果使用固定的尺寸,那么不同的App在不同手机上肯定不适配.</p> 
<p>       再加上现在平板、手表、曲面屏、折叠屏、车机显示屏、大的电视屏幕以及电脑屏幕,不同App想要做好用户体验以及开拓市场,那么App应用的适配性就至关重要.</p> 
<p></p> 
<h4 id="%E8%87%AA%E9%80%82%E5%BA%94%3A">自适应:</h4> 
<p>根据不同的设备屏幕大小来自动进行调整</p> 
<h4 id="%E5%93%8D%E5%BA%94%E5%BC%8F%3A">响应式:</h4> 
<p>当屏幕的宽或者高进行改变时,会自动进行响应,并自动进行根据屏幕进行改变</p> 
<p>比如:手机屏幕竖屏调整为横屏; 电脑窗口的宽或者高进行拉伸</p> 
<p></p> 
<h4 id="px%E3%80%81em%E3%80%81rem%E7%9A%84%E7%90%86%E8%A7%A3">px、em、rem的理解</h4> 
<p>简单的来讲:</p> 
<ol><li><span style="color:#fe2c24;">px(像素)</span>,屏幕的每一个小方块亮的不同颜色的灯组成了屏幕,每一个小方块,就是一个像素</li><li><span style="color:#fe2c24;">em(相对长度单位)</span>,电脑的手机当你不给font-size是也会出现字体大小,这个就是设置的默认字体大小,所有未经调整的浏览器都符合: 1em=16px。根据这个计算,就可以算出默认字体大小对应的em,那么不同屏幕的默认不同,就会进行自适应和响应式</li><li><span style="color:#fe2c24;">rem(根元素): </span><span style="color:#333333;">root em就可以简单的理解为相对于root &lt;html&gt;元素的单位,</span></li></ol> 
<p><span style="color:#333333;">还有一些rpx、fpx等其实都是根据这些出发的,了解了这些再看就会简单</span></p> 
<p>网址:<a href="https://blog.csdn.net/cbkting/article/details/87579219?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167048389216782395387386%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167048389216782395387386&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-87579219-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_control1&amp;utm_term=px%20em%20rem&amp;spm=1018.2226.3001.4187" title="px、em 和 rem 三者区别_cbkting的博客-CSDN博客_rem em px">px、em 和 rem 三者区别_cbkting的博客-CSDN博客_rem em px</a></p> 
<p></p> 
<h2 id="Viewport%E8%A7%86%E5%8F%A3%C2%A0">Viewport视口 </h2> 
<h3 id="%E4%B8%80%E3%80%81%E8%A7%86%E5%8F%A3%E7%9A%84%E5%88%92%E5%88%86%3A">一、视口的划分:</h3> 
<p>这里只针对移动端, pc端没有这种转换和划分</p> 
<p><span style="color:#fe2c24;">注意:&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></p> 
<p><span style="color:#fe2c24;">实验前把这一行代码删除,该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。</span></p> 
<h4 id="layout%C2%A0viewport%20%E5%B8%83%E5%B1%80%E8%A7%86%E5%8F%A3">layout viewport 布局视口</h4> 
<p><strong>简述:相对于980px布局的这个视口(比如PC视口)</strong></p> 
<p></p> 
<h4 id="visual%20viewport%C2%A0%E8%A7%86%E8%A7%89%E8%A7%86%E5%8F%A3">visual viewport 视觉视口</h4> 
<p><strong>简述:原本的区域是980px X 1743px, 手机端(375px X 667px)如果按照这个显示,肯定只能显示一部分,按比例缩小之后的这个视口称之为"视觉视口"</strong></p> 
<p></p> 
<h4 id="ideal%20viewport%C2%A0%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3">ideal viewport 理想视口</h4> 
<p><strong>默认情况下的layout viewport 布局视口不适合移动端开发, 需要进行转换,利用标签&lt;mate&gt;对布局视口, 设置成我们想要的移动端视口,就是理想视口</strong></p> 
<p></p> 
<p>手机端的视口: 红色方块100px X 100px   手机视口:375 X 667</p> 
<p>显然小方块不是整个视口的1/3左右,那么这100px肯定不是相对于这个视口的</p> 
<p>那么这个100px是相对于layout viewport 布局视口</p> 
<p>当我们从pc端视口---布局视口, 转换为手机视口---可见视口时, 原本980px缩小为375px, 100px也会按照这个比例等比缩小</p> 
<p><img alt="" height="437" src="https://images2.imgbox.com/a6/12/9QEKtW8A_o.png" width="489"></p> 
<p><img alt="" height="499" src="https://images2.imgbox.com/0e/4b/74rqrWul_o.png" width="831"></p> 
<p></p> 
<p></p> 
<p>PC端的视口: 小方块100px X 100px</p> 
<p><img alt="" height="714" src="https://images2.imgbox.com/0c/24/BthRanKJ_o.png" width="1115"></p> 
<p></p> 
<h3 id="%C2%A0%E4%BA%8C%E3%80%81%E8%A7%86%E5%8F%A3%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%9B%B4%E6%94%B9"> 二、视口大小的更改</h3> 
<p>主要还是:<span style="color:#fe2c24;">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></p> 
<p><span style="color:#333333;">content="width=device-width"   布局视口宽度 = 设备的宽度(手机宽度)</span></p> 
<p><span style="color:#333333;">content="width=100px"    布局视口宽度  = 100px</span></p> 
<p><span style="color:#333333;">如图所示:红色方块</span>100px X 100px 占满整个视口</p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/e0/87/CjWVluAs_o.png" width="1200"></p> 
<h4></h4> 
<h4 id="viewport%E5%B1%9E%E6%80%A7%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A"><strong>viewport属性各个参数：</strong></h4> 
<p><br> &lt;meta name="viewport" content="width=device-width, initial-<a href="https://so.csdn.net/so/search?q=scale&amp;spm=1001.2101.3001.7020" title="scale">scale</a>=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; </p> 
<ul><li>width：viewport 的宽度，可以指定为一个像素值，如：600，或者为特殊的值，如：device-width （设备的宽度）。</li><li>height：viewport的高度。</li><li>initial-scale：初始缩放比例，即当浏览器第一次加载页面时的缩放比例。</li><li>maximum-scale：允许浏览者缩放到的最大比例，一般设为1.0。</li><li>minimum-scale：允许浏览者缩放到的最小比例，一般设为1.0。</li><li>user-scalable：浏览者是否可以手动缩放，yes或no。 </li></ul> 
<p></p> 
<h2 id="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%B3%95">移动端适配方法</h2> 
<p><strong>痛点:</strong>移动端适配原因</p> 
<p><strong>改变: </strong>使用px是绝对的大小, 要使用相对的大小才能进行自适应与响应式</p> 
<p><strong>注意:</strong>百分比(%)设置不常用, 不同参照物的百分比很难统一</p> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81rem(%E6%A0%B9%E5%80%8D%E7%8E%87)%20%2B%C2%A0%E5%8A%A8%E6%80%81%E7%9A%84%E6%A0%B9%E6%A0%87%E7%AD%BE%E7%9A%84font-size">一、rem(根倍率) + 动态的根标签的font-size</h3> 
<p><strong>rem(根倍率)</strong>相对于根标签&lt;html&gt;的倍率变化</p> 
<p>那么 --&gt;    375px是视口宽度,  font-size=20px  红色方快100px X 100px  1rem = 20px </p> 
<p>红色方块设置 5rem X 5rem</p> 
<p>现在的视口宽度为 414px  现在的红色方块 5rem X 5rem 只需要设置 font-size=28px</p> 
<p>红色方块实际:140px X 140px</p> 
<p><strong>动态根标签:</strong>当视口变化时, 我们只需要改变&lt;html&gt;中的font-size大小就可以适配</p> 
<h4 id="1%E3%80%81%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E8%AE%BE%E7%BD%AE%E5%8A%A8%E6%80%81%E7%9A%84html%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7">1、媒体查询设置动态的html标签属性</h4> 
<p>这里的媒体查询动态是一个区间: min-width: 375px 至 min-width: 414px都是font-size: 20px;</p> 
<p>所以rem的与font-size一样, 是根据视口的大小达到范围后进行变化, 而不是实时变化</p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;
  &lt;title&gt;viewport&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="box"&gt;&lt;/div&gt;
&lt;/body&gt;

  &lt;style&gt;
    @media screen and (min-width: 320px) {
      html {
        font-size: 12px;
      }
    }
    @media screen and (min-width: 375px) {
      html {
        font-size: 20px;
      }
    }
    @media screen and (min-width: 414px) {
      html {
        font-size: 28px;
      }
    }
    @media screen and (min-width: 480px) {
      html {
        font-size: 30px;
      }
    }
    @media screen and (min-width: 960px) {
      html {
        font-size: 60px;
      }
    }
    body {
      margin: 0;
      padding: 0;
    }
    .box {
      width: 5rem;
      height: 5rem;
      background-color: red;
    }
  &lt;/style&gt;
&lt;/html&gt;</code></pre> 
<h4 id="2%E3%80%81%E9%80%9A%E8%BF%87JS%E5%8A%A8%E6%80%81%E8%AE%A1%E7%AE%97%3Chtml%3E%E4%B8%AD%E7%9A%84font-size">2、通过JS动态计算&lt;html&gt;中的font-size</h4> 
<p>原理: 就是实时监听视口的宽度,拿到这个宽度,然后根据这个宽度就可以设置实时的html标签的font-size的值</p> 
<p>虽然font-size可以实时变化了,但是rem的值计算却很麻烦</p> 
<p>方法一: 引入scss或者less预编辑器, 用到的是可以使用函数</p> 
<p>这里就使用函数相当于转换器, 输入的是px的大小,转换为rem</p> 
<p>方法二: webpack插件(postcss-pxtorem)可以在打包的时候,把你的px换算为rem(原理同上)</p> 
<p>方法三:VScode插件(px to rem &amp; rpx &amp; vw), 输入px值然后按照规定的快捷键</p> 
<p>注意: 需要改根组件font-size的倍率: 37.49(原理同上)</p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/e7/ad/XpuZR9xW_o.png" width="532"></p> 
<p></p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;
  &lt;title&gt;viewport&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="box"&gt;&lt;/div&gt;
&lt;/body&gt;

  &lt;script&gt;
    // 声明常量: 所有的HTML元素赋给htmlEl
    const htmlEl = document.documentElement
    // 声明常量: htmlEl元素的内部宽度
    //clientWidth属性表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。
    // const htmlWidth = htmlEl.clientWidth
    function setResize(){
      const htmlWidth = htmlEl.clientWidth
      const htmlFontSize = htmlWidth / 10
      htmlEl.style.fontSize = htmlFontSize + 'px'
    }

    // 解决第一次调用的问题:第一次是默认的16px
    setResize()

    // 给window添加一个事件监听---两个参数(监听参数的变化, 变化之后执行的函数)
    window.addEventListener('resize', setResize())
  &lt;/script&gt;

  &lt;style lang="scss" scoped&gt;
    pxToRem(@px) {
      result: 1rem * (@px / 37.49);
    }
    body {
      margin: 0;
      padding: 0;
    }
    .box {
      width: pxToRem(100)[result];
      height: pxToRem(100)[result];
      background-color: red;
    }
  &lt;/style&gt;
&lt;/html&gt;</code></pre> 
<h4 id="3%E3%80%81%E5%B7%B2%E7%BB%8F%E5%BC%80%E6%BA%90%E7%9A%84%E5%BA%93%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8">3、已经开源的库可以使用</h4> 
<p><strong>lib-flexble</strong></p> 
<ol><li> <pre>npm install lib-flexible --save</pre> </li><li> <pre>在main.js中引入import 'lib-flexble'</pre> </li></ol> 
<pre><strong>px2rem-loader</strong></pre> 
<ol><li> <pre>npm install px2rem-loader --save-dev</pre> </li><li>在根目录的<strong>vue.config.js</strong>文件中进行配置</li></ol> 
<pre><code>module.exports = {
  chainWebpack: config =&gt; {
    config.module
      .rule('css')
        .test(/\.css$/)
        .oneOf('vue')
        .resourceQuery(/\?vue/)
        .use('px2rem')
          .loader('px2rem-loader')
          .options({
            remUnit: 75
          })
  }
}</code></pre> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81vw(%E8%A7%86%E5%8F%A3%E5%AE%BD%E5%BA%A6)">二、vw(视口宽度)---推荐</h3> 
<p>假设375px的这个设备为我们的设计时的标准设备</p> 
<p>100vw = 375px     1vw = 3.75px</p> 
<p>红色方块是 100px = 100/3.75 vw = 26.6vw</p> 
<p>当变换成为iPone XR 为414px</p> 
<p>100vw = 414px    1vw =  4.14px</p> 
<p>26.6vw = 26.6 X 4.14 px = 110.1px</p> 
<p>这样红色方块在视口中自动按照比例变大</p> 
<p>那么我们在设计的时候,把大小全部使用vw,就可以实现适配</p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/ab/34/s4R05DSR_o.png" width="300"><img alt="" height="365" src="https://images2.imgbox.com/ed/db/C4Iz8sB6_o.png" width="340"></p> 
<p></p> 
<p>接上面的: 上面用的是函数来查取动态的视口宽度viewport width</p> 
<p>vw就是视口宽度  100vw就是设备的视口宽度</p> 
<p>那么设置如下:</p> 
<pre><code>&lt;body&gt;
  &lt;div class="box"&gt;&lt;/div&gt;
&lt;/body&gt;
  &lt;style&gt;
    /* html {
      font-size: 10vw;
    } */
    body {
      margin: 0;
      padding: 0;
    }
    /* 这里的rem = 10vw 2.6667rem = 26.667vw*/
    .box {
      width: 26.667vw;
      height: 26.667vw;
      background-color: red;
    }
  &lt;/style&gt;</code></pre> 
<p></p> 
<h3 id="%E4%B8%89%E3%80%81flex(%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80)">三、flex(弹性布局)</h3> 
<p>display: flex弹性布局</p> 
<p>flex（设置在子元素上） 作用：可以让元素自动占用容器的可用空间，等比划分</p> 
<p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</p> 
<p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</p> 
<p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）</p> 
<p><span style="color:#fe2c24;">flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto</span></p> 
<p></p> 
<p><span style="color:#333333;">通过上面的的方法我们已经可以实现这个页面的不同设备上的适配</span></p> 
<p><span style="color:#333333;">痛点:电脑上是宽长高短, 手机上是宽短高长, 这也就决定了两者除了适配之外, 在布局上为了用户更加方便, 也必须适配</span></p> 
<p><span style="color:#333333;">比如: 在电脑上面如果左侧有一个选项列表, 在移动端就要设计为抽屉</span></p> 
<p><span style="color:#333333;">经典的圣杯布局: PC端的中间部分可能可以很大,但是在手机上中间部分就要小一点</span></p> 
<p><span style="color:#333333;">这里用到最多的就是自适应 flex:1</span></p> 
<p></p> 
<p><span style="color:#333333;">痛点: 如果可以无限的放大或者缩小, 太大还好,当太小时,  有的文字或者一些表单看不见或者按不到,</span></p> 
<p><span style="color:#333333;">解决办法: 要么就禁止缩放, 要么就设置一个最小的font-size的值/视口</span></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f4cb6336338461b338c1b4295d4bdfb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华为云会议实测：经常开远程视频会议，选它就对了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/37ba95781916bbbedb5cba5a5ed470f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">html中表格和表单嵌套以及css基础知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>