<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法 | 单链表的五个常见操作 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法 | 单链表的五个常见操作" />
<meta property="og:description" content="问题：
1.单链表反转：事先存好下一个节点再改变指针
2.链表中环的检测：快慢指针终会相遇
3.两个有序链表的合并：两个链表各一个指针，比较大小后加到最终的链表中（有点快排的感觉）
4.删除链表倒数第K个节点：转化为删除正数第length-K&#43;1个节点
5.求链表的中间节点：快慢指针
思路都在代码的注释中，做链表的画张图就能更好的关注逻辑，比较直观，所以强烈建议画图来看看指针怎么走。
其中只在一种给出运行的例子，2345要运行验证在1的基础上改一改就好。
代码都已检验过没有问题，上代码：
1.单链表反转
//单链表反转 public class ListReverse { public static void main(String[] args) { ListNode node1=new ListNode(1); ListNode node2=new ListNode(2); ListNode node3=new ListNode(3); ListNode node4=new ListNode(4); ListNode node5=new ListNode(5); ListNode node6=new ListNode(6); node1.next=node2; node2.next=node3; node3.next=node4; node4.next=node5; node5.next=node6; reverse(node1); System.out.println(node6.next.val); System.out.println(node5.next.val); System.out.println(node4.next.val); System.out.println(node3.next.val); System.out.println(node2.next.val); System.out.println(node1.next); } public static class ListNode{ int val; ListNode next; ListNode(int x) { val = x; } } public static ListNode reverse(ListNode head){ //单链表反转 ListNode pre=null; ListNode now=head; ListNode next; while (now!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2e5d39c1e4ae2bbd4b892f1e79d33575/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-11T17:10:02+08:00" />
<meta property="article:modified_time" content="2019-04-11T17:10:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法 | 单链表的五个常见操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>问题：</strong></p> 
<p>1.单链表反转：事先存好下一个节点再改变指针</p> 
<p>2.链表中环的检测：快慢指针终会相遇</p> 
<p>3.两个有序链表的合并：两个链表各一个指针，比较大小后加到最终的链表中（有点快排的感觉）</p> 
<p>4.删除链表倒数第K个节点：转化为删除正数第length-K+1个节点</p> 
<p>5.求链表的中间节点：快慢指针</p> 
<hr> 
<p>思路都在代码的注释中，做链表的画张图就能更好的关注逻辑，比较直观，所以强烈建议画图来看看指针怎么走。</p> 
<p>其中只在一种给出运行的例子，2345要运行验证在1的基础上改一改就好。</p> 
<p>代码都已检验过没有问题，上代码：</p> 
<p>1.单链表反转</p> 
<pre class="has"><code>
//单链表反转
public class ListReverse {

    public static void main(String[] args) {
        ListNode node1=new ListNode(1);
        ListNode node2=new ListNode(2);
        ListNode node3=new ListNode(3);
        ListNode node4=new ListNode(4);
        ListNode node5=new ListNode(5);
        ListNode node6=new ListNode(6);
        node1.next=node2;
        node2.next=node3;
        node3.next=node4;
        node4.next=node5;
        node5.next=node6;
        reverse(node1);
        System.out.println(node6.next.val);
        System.out.println(node5.next.val);
        System.out.println(node4.next.val);
        System.out.println(node3.next.val);
        System.out.println(node2.next.val);
        System.out.println(node1.next);

    }

    public static class ListNode{
        int val;
        ListNode next;
        ListNode(int x) { val = x; }
    }

    public static ListNode reverse(ListNode head){
        //单链表反转
        ListNode pre=null;
        ListNode now=head;
        ListNode next;
        while (now!=null){
            next=now.next;
            now.next=pre;
            pre=now;
            now=next;
        }
        System.out.println("反转成功！");
        return pre;

    }
}</code></pre> 
<hr> 
<p>2.链表中环的检测</p> 
<pre class="has"><code>public class CircleInList {

    /*
     思路：快慢指针，如果有环，进入环以后，快慢指针一定会相遇，画图可验证

     */
    public static boolean hasCircle(ListNode head){
        //先做非空判断，只有一个元素也可以成环...
        if (head==null){
            return false;
        }
        //快慢指针
        ListNode fast=head;
        ListNode slow=head;

        while (fast!=null){
            fast=fast.next.next;
            slow=slow.next;
            //先走了再判断
            if (fast==slow){
                return true;
            }
            System.out.println("走了一次");
        }

        return false;
    }

}</code></pre> 
<hr> 
<p>3.两个有序链表的合并</p> 
<pre class="has"><code>//合并两个有序列表
public class ListMerge {

    /*
    思路：两个list各一个指针，比较大小，小的放到新的list中
          当有一个遍历完，则把另一个的剩下的全都加到result这个list中
     */
    public static ListNode merge(ListNode head1, ListNode head2) {
        if (head2 == null || head1 == null) {
            System.out.println("其中有一个List为空");
            return null;
        }

        ListNode ResultHead = null;
        ListNode current = null;
        ListNode Point1 = head1;
        ListNode Point2 = head2;
        //得到头节点
        if (Point1.val &lt; Point2.val) {
            ResultHead = Point1;
            Point1 = Point1.next;
        } else {
            ResultHead = Point2;
            Point2 = Point2.next;
        }
        current = ResultHead;

        while (Point1 != null &amp;&amp; Point2 != null) {
            if (Point1.val &lt; Point2.val) {
                current.next = Point1;
                Point1 = Point1.next;
            } else  {
                current.next = Point2;
                Point2 = Point2.next;
            }
            current = current.next;//当前下标往后移动一个
            System.out.println("合并一次");
        }


        if (Point1 == null) {
            current.next = Point2;
            System.out.println("后面的都合并进去");
        } else {
            current.next = Point1;
            System.out.println("后面的都合并进去");
        }

        return ResultHead;
    }
}</code></pre> 
<hr> 
<p>4.删除链表倒数第K个节点</p> 
<pre class="has"><code>//删除倒数第K个node
public class deleteNode {
    //转化为删除正数length-K+1
    public static void deleteNode(ListNode head, int K){

        if (head==null){
            System.out.println("请勿传入空节点");
            return;
        }
        int length=1;
        int count=1;
        int deleteNumberChanged=0;
        ListNode point=head;

        while(point.next!=null){
            point=point.next;
            length++;
        }

        if (length&lt;K){
            System.out.println("没这么多数字");
            return;
        }

        deleteNumberChanged=length-K+1;
        point=head;
        while (point.next!=null){
            if (count+1==deleteNumberChanged){
                ListNode temp=point.next;
                point.next=null;
                point.next=temp.next;
                System.out.println("删除成功");
                break;
            }
            point=point.next;
            count++;
            System.out.println("往后查找");
        }

    }

}</code></pre> 
<p>5.求链表的中间节点</p> 
<pre class="has"><code>//得到链表的中点
public class getMiddleNode {

    public static ListNode getMiddleNode(ListNode head){

        if (head==null){
            return null;
        }
        /*思路：快慢指针，快的走两步，慢的走一步
         */

        ListNode fast=head;
        ListNode slow=head;

        while(fast.next!=null&amp;&amp;fast.next.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        return slow;
    }

}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a99ce8f953f40f2dd6e73a561632243/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最长单调子序列例题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/434789ee9f5a784f330a87cb15285407/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IPSec协议抓包详解和IPSec NAT穿越报文解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>