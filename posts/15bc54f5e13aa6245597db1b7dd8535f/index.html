<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于STM32F1系列与阿里云的物联网节点 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于STM32F1系列与阿里云的物联网节点" />
<meta property="og:description" content="一、硬件准备
一块STM32F1系列的核心板或开发板
DHT11温湿度传感器一个
BH1750光照强度传感器一个
ESP8266-01S模块一个
TFT彩屏一个(SPI接口)
二、软件准备
准备阿里云物联网平台的开发
准备阿里云物联网Web可视化页面的开发
以及Keil5开发环境和串口调式助手
三、阿里云物联网平台
笔者在写过一篇关于阿里云平台的文章，传送门如下：
(2条消息) ESP8266-01S&#43;MQTT&#43;阿里云数据传输_二筒rrrr的博客-CSDN博客
四、STM32的开发
我们需要准备DHT11传感器与BH1750传感器的代码，废话不多说直接上代码
DHT11.c
#include &#34;bsp_DHT11.h&#34;
xDHT11_TypeDef xDHT11; // 声明全局结构体, 用于记录信息
static GPIO_TypeDef *DHT11_GPIOx = 0; // 引脚端口
static uint32_t DHT11_PINx = 0; // 引脚编号
#define DHT11_BUS_HIGH (DHT11_GPIOx-&gt;BSRR = (uint32_t)DHT11_PINx) // DAT引脚 置高电平
#define DHT11_BUS_LOW (DHT11_GPIOx-&gt;BSRR = ((uint32_t)DHT11_PINx) &lt;&lt; 16) // DAT引脚 置低电平
#define DHT11_BUS_READ ((DHT11_GPIOx-&gt;IDR &amp; DHT11_PINx) ? 1: 0) // 读取引脚的电平
#if DELAY_MODE_TIM2
#include &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/15bc54f5e13aa6245597db1b7dd8535f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-16T10:39:11+08:00" />
<meta property="article:modified_time" content="2023-05-16T10:39:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于STM32F1系列与阿里云的物联网节点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、硬件准备<br> 一块STM32F1系列的核心板或开发板</p> 
<p>DHT11温湿度传感器一个</p> 
<p>BH1750光照强度传感器一个</p> 
<p>ESP8266-01S模块一个</p> 
<p>TFT彩屏一个(SPI接口)</p> 
<p>二、软件准备<br> 准备阿里云物联网平台的开发</p> 
<p>准备阿里云物联网Web可视化页面的开发</p> 
<p>以及Keil5开发环境和串口调式助手</p> 
<p>三、阿里云物联网平台<br> 笔者在写过一篇关于阿里云平台的文章，传送门如下：</p> 
<p>(2条消息) ESP8266-01S+MQTT+阿里云数据传输_二筒rrrr的博客-CSDN博客</p> 
<p>四、STM32的开发<br> 我们需要准备DHT11传感器与BH1750传感器的代码，废话不多说直接上代码</p> 
<p>DHT11.c</p> 
<p> <br>  <br> #include "bsp_DHT11.h"<br>  <br>  <br>  <br> xDHT11_TypeDef       xDHT11;             // 声明全局结构体, 用于记录信息<br>  <br>  <br>  <br> static GPIO_TypeDef *DHT11_GPIOx = 0;    // 引脚端口<br> static uint32_t      DHT11_PINx  = 0;    // 引脚编号<br>  <br>  <br>  <br> #define  DHT11_BUS_HIGH     (DHT11_GPIOx-&gt;BSRR = (uint32_t)DHT11_PINx)           // DAT引脚 置高电平<br> #define  DHT11_BUS_LOW      (DHT11_GPIOx-&gt;BSRR = ((uint32_t)DHT11_PINx) &lt;&lt; 16)   // DAT引脚 置低电平<br> #define  DHT11_BUS_READ     ((DHT11_GPIOx-&gt;IDR &amp; DHT11_PINx) ? 1: 0)             // 读取引脚的电平<br>  <br>  <br>  <br> #if DELAY_MODE_TIM2<br> #include "stm32f10x_tim.h"<br> #include "misc.h"<br> // 定时器初始化配置<br> // 不使用中断<br> void Tim2_Init(uint16_t psc, uint16_t arr, FunctionalState NewState)<br> {<!-- --><br>     TIM_TimeBaseInitTypeDef tim;                         // 结构体<br>  <br>     RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); // 开启TIM时钟<br>     TIM_DeInit(TIM2);<br>     tim.TIM_ClockDivision = TIM_CKD_DIV1;                // 采样分频<br>     tim.TIM_CounterMode   = TIM_CounterMode_Up;          // 向上计数<br>     tim.TIM_Period        = arr;                         // 自动重装载寄存器的值<br>     tim.TIM_Prescaler     = psc - 1;                     // 时钟预分频<br>     TIM_TimeBaseInit(TIM2, &amp;tim);                        // 初始化结构体<br>     TIM2-&gt;SR = (uint16_t)~((uint16_t)0x01);              // 清除更新标志 <br>     TIM2-&gt;CNT = 0;                                       // 清0计数器<br>     TIM_Cmd(TIM2, NewState);                             // 是否开始工作<br> }<br>  <br>  <br>  <br> static void delay_us(uint32_t us)<br> {<!-- --><br>     Tim2_Init(72, us, ENABLE);<br>     while ((TIM2-&gt;SR &amp; 1) == 0);<br>     TIM_Cmd(TIM2, DISABLE);<br> }<br>  <br>  <br>  <br> static void delay_ms(uint32_t ms)<br> {<!-- --><br>     for (uint16_t i = 0; i &lt; ms; i++)<br>     {<!-- --><br>         Tim2_Init(72, 990, ENABLE);<br>         while ((TIM2-&gt;SR &amp; 1) == 0);<br>         TIM_Cmd(TIM2, DISABLE);<br>     }<br> }<br> #else<br>  <br> // 本地US粗略延时函数，减少移植时对外部文件依赖；<br> static void delay_us(uint32_t us)<br> {<!-- --><br>     uint16_t i = 0;<br>     while (us--)<br>     {<!-- --><br>         i = 7;<br>         while (i--);<br>     }<br> }<br>  <br> // 本地MS粗略延时函数，减少移植时对外部文件依赖；<br> static void delay_ms(uint32_t ms)<br> {<!-- --><br>     uint32_t i = 0;<br>     while (ms--)<br>     {<!-- --><br>         i = 12000;<br>         while (i--);<br>     }<br> }<br> #endif // 结束延时<br>  <br>  <br>  <br> static void DHT11_Mode_IPU(void)<br> {<!-- --><br>     GPIO_InitTypeDef GPIO_InitStructure;<br>  <br>     GPIO_InitStructure.GPIO_Pin = DHT11_PINx ;<br>     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU ;<br>     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>     GPIO_Init(DHT11_GPIOx, &amp;GPIO_InitStructure);<br> }<br>  <br> static void DHT11_Mode_Out_PP(void)<br> {<!-- --><br>     GPIO_InitTypeDef GPIO_InitStructure;<br>     GPIO_InitStructure.GPIO_Pin = DHT11_PINx ;<br>     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>     GPIO_Init(DHT11_GPIOx, &amp;GPIO_InitStructure);<br> }<br>  <br> static void DHT11_Init(GPIO_TypeDef *GPIOx, uint32_t PINx)<br> {<!-- --><br>     DHT11_GPIOx = GPIOx;<br>     DHT11_PINx = PINx;<br>  <br>     // 时钟使能：引脚端口;用判断端口的方式使能时钟线, 减少移植时的工作<br>     if (GPIOx == GPIOA)  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br>     if (GPIOx == GPIOB)  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<br>     if (GPIOx == GPIOC)  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);<br>     if (GPIOx == GPIOD)  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);<br>     if (GPIOx == GPIOE)  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);<br>     if (GPIOx == GPIOF)  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);<br>     if (GPIOx == GPIOG)  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);<br>  <br>     DHT11_Mode_Out_PP();<br>     DHT11_BUS_HIGH;<br> }<br>  <br>  <br> // 从DHT11读取一个字节，MSB先行<br> // 1：每bit以50us低电平标置开始，<br> // 2：以26~28us的高电平表示“0”<br> // 3：以70us高电平表示“1”<br> // 4: 通过检测从高电平开后 x us后的电平即可区别这两个状态<br> static uint8_t readByte(void)<br> {<!-- --><br>     uint8_t  temp = 0;<br>  <br>     for (uint8_t i = 0; i &lt; 8; i++)<br>     {<!-- --><br>         while (DHT11_BUS_READ == 0);             // 每bit以50us低电平标置开始，轮询直到从机发出 的50us 低电平 结束<br>         delay_us(40);                             // 延时x us 这个延时需要大于数据0持续的时间即可<br>         temp &lt;&lt;= 1;<br>         if (DHT11_BUS_READ == 1)                 // x us后仍为高电平表示数据“1”<br>         {<!-- --><br>             while (DHT11_BUS_READ == Bit_SET);  // 等待数据1的高电平结束<br>             temp |= 1;                           // 位置“1“<br>         }<br>     }<br>     return temp;<br> }<br>  <br>  <br> /******************************************************************************<br>  * 函  数： DHT11_GetData<br>  * 功  能： 从DHT11中读取数据<br>  * 参  数： 1:<br>  * 说  明： 调用后，获取到的数据，保存到结构体xDHT11中<br>  *          温度值：xDHT11.Temperature (有效范围:0~50℃)<br>  *          湿度值: xDHT11.Humidity    (有效范围:20%~90%)<br>  * 返回值： 0-失败; 1-正常<br>  ******************************************************************************/<br> uint8_t DHT11_GetData(GPIO_TypeDef *GPIOx, uint32_t PINx)<br> {<!-- --><br>     static uint8_t humiInt = 0;        // 湿度的整数部分<br>     static uint8_t humiDec = 0;        // 湿度的小数部分<br>     static uint8_t TempInt = 0;        // 温度的整数部分<br>     static uint8_t TempDec = 0;        // 温度的小数部分<br>     static uint8_t sum = 0;            // 校验和<br>  <br>     DHT11_Init(GPIOx, PINx);<br>  <br>     // 1:主机产生开始信号<br>     DHT11_Mode_Out_PP();               // 输出模式<br>     DHT11_BUS_LOW;                     // 主机拉低电平<br>     delay_ms(25);                      // 延时18~30ms<br>     // 2：主机拉高等待<br>     DHT11_BUS_HIGH;                    // 总线拉高<br>     delay_us(50);                      // 延时20~40us，这里设置50，是因为要直接进入下一个时序（电平状态），以方便检测<br>  <br>     // 3: 从机产生响应和准备信号<br>     DHT11_Mode_IPU();                  // 主机设为输入 判断从机响应信号<br>  <br>     if (DHT11_BUS_READ == 0)           // 判断从机是否产生响应信号_低电平, 如不响应则跳出<br>     {<!-- --><br>         while (DHT11_BUS_READ == 0);   // 等待响应信号结束：低电平持续约80us<br>         while (DHT11_BUS_READ == 1);   // 等待标置信号结束：高电平持续约80us<br>         // 4: 从机连续输出5字节数据<br>         humiInt = readByte();          // 湿度的整数部分// 开始接收数据<br>         humiDec = readByte();          // 湿度的小数部分<br>         TempInt = readByte();          // 温度的整数部分<br>         TempDec = readByte();          // 温度的小数部分<br>         sum     = readByte();          // 校验和<br>  <br>         DHT11_Mode_Out_PP();           // 读取结束，引脚改为输出模式<br>         DHT11_BUS_HIGH;                // 主机拉高<br>  <br>         // 5: 检查读取的数据是否正确<br>         if (sum == (humiInt + humiDec + TempInt + TempDec))<br>         {<!-- --><br>             xDHT11.Humidity = humiInt + humiDec;<br>             xDHT11.Temperature = (float)TempInt  + (float)TempDec / 10;<br>             return SUCCESS;            // 校检正确, 返回：SUCCESS=1<br>         }<br>         return ERROR;                  // 校检错误，返回：ERROR=0<br>     }<br>     return ERROR;                      // 通信错误，返回：ERROR=0<br> }<br>  <br>  <br>  <br>  <br> /******************************************************************************<br>  * 函  数： DHT11_GetTemperature<br>  * 功  能： 从DHT11中读取温度值<br>  * 参  数： GPIO_TypeDef *GPIOx: GPIO端口号，取值范围：GPIOA ~ GPIOG<br>  *          uint32_t     PINx  : 引脚编号，  取值范围：GPIO_Pin_0 ~ GPIO_Pin_15<br>  * 说  明： 温度值有效范围:0~50℃; 精度±2°C; 小数部份无效<br>  * 返回值： 0-失败，非0值-湿度值<br>  ******************************************************************************/<br> float DHT11_GetTemperature(GPIO_TypeDef *GPIOx, uint32_t PINx)<br> { <br>     DHT11_GetData(GPIOx, PINx);<br>     return xDHT11.Temperature;<br> }<br>  <br>  <br> /******************************************************************************<br>  * 函  数： DHT11_GetHumidity<br>  * 功  能： 从DHT11中读取湿度值<br>  * 参  数： GPIO_TypeDef *GPIOx: GPIO端口号，取值范围：GPIOA ~ GPIOG<br>  *          uint32_t     PINx  : 引脚编号，  取值范围：GPIO_Pin_0 ~ GPIO_Pin_15<br>  * 说  明： 湿度值有效范围:20%~90%; 精度±5%; 小数部分无效<br>  * 返回值： 0-失败，非0值-湿度值<br>  ******************************************************************************/<br> float DHT11_GetHumidity(GPIO_TypeDef *GPIOx, uint32_t PINx)<br> {  <br>     DHT11_GetData(GPIOx, PINx);<br>     return xDHT11.Humidity;<br> }</p> 
<p>DHT11.h</p> 
<p>#ifndef __BSP_DHT11_H<br> #define __BSP_DHT11_H<br> /***********************************************************************************************************************************<br>  **【文件名称】  bsp_DHT11.h<br>  **【功能测试】  DHT11-温湿度获取<br>  **【购买链接】  魔女科技   https://demoboard.taobao.com<br>  **【更新分享】  Q群文件夹<br>  ***********************************************************************************************************************************<br>  **【文件名称】  bsp_DHT11.h<br>  **【功能描述】  定义引脚、定义全局结构体、声明全局函数<br>  **<br>  **【适用平台】  STM32F103 + 标准库v3.5 + keil5<br>  **<br>  **【实验操作】  1-模块接线，VCC  接 3.3V 或 5V<br>  **                          DATA 接 PC3<br>  **                          GND  接 GND<br>  **<br>  **【划 重 点】  1-电压范围：3.3V~5.0V，工作电流：0.2~1mA; 待机电流：150uA<br>  **              2-DHT11反应有点慢：上电后1S后进入稳定状态; <br>  **              3-采样周期，不同店家的DHT11，参数不同，一般是1次/秒, 有部分可以数百毫秒间隔采集一次; 当小于采样周期进行重复采集数据，会发生错误;<br>  **              5-DHT11时序要求较高，us级别，当使用delay粗略延时，同一份代码同一个模块，在不同keil里跑也可能发生错误(代码优化设置对while延时的影响)。建议使用TIM的精准延时;<br>  **              4-注意判断使用的DHT11器件，是单独的DHT11元件，还是完整的DHT11模块<br>  **                单独的DHT11元件：蓝色塑料主体、三个引脚，不带上拉电阻；适合低成本工程方案使用，建议测试时引脚使用推挽输出模式；<br>  **                完整的DTH11模块：蓝色塑料主体、三个引脚、PCB底板、上拉电阻、电源指示LED，适合方案搭建；<br>  **              6-精度误差：DHT11分旧版和新版，10元内的绝大部分是旧版，新版约12元左右；<br>  **                          旧版数据稳定，但只有整数部分，新版有小数部分，但数据跳动稍大；<br>  **                          温度0-50°C; 精度±2°C; 小数部份无效<br>  **                          湿度20-80%; 精度±5%; 小数部分无效<br>  **<br>  **<br>  **【文件移植】  步骤1-复制文件：可复制bsp_DHT11.c和bsp_DHT11h两个文件，或复制DHT11文件夹，保存到所需工程目录文件夹下；<br>  **              步骤2-添加文件：在keil工各程左侧文件管理器中，双击某文件夹，以添加bsp_DHT11.c文件;<br>  **              步骤3-添加路径：点击魔术棒工具按钮，在“c/c++"选项页中，点击”Include Path"后面的按键，以添加文件存放所在路径(是文件夹，不是文件);<br>  **　　　　　    步骤4-添加引脚：在所需DHT11功能的代码文件头部，添加：#include "bsp_DHT11.h";<br>  **<br>  **<br>  **【函数使用】  函数2-DHT11_GetData(GPIOx, GPIO_Pin_x);           // 获取数据, 获取的数据存放于结构体xDHT11中，具体使用方法，可参考示例代码<br>  **<br>  **<br>  **【更新记录】  2022-05-13  增加TIM2精准延时，以便于移植<br>  **              2021-12-23  修改初始化函数，使文件移植更方便: DHT11_Init(GPIOx, GPIO_Pin_x);<br>  **              2021-10-26  修改c和h文件文件格式<br>  **              2021-10-26  修改DHT11_GetData()函数<br>  **              2021-05-20  创建文件<br>  **<br> ***********************************************************************************************************************************/<br> #include &lt;stm32f10x.h&gt;<br> #include &lt;stdio.h&gt;<br>  <br>  <br>  <br> /*****************************************************************************<br>  ** 移植修改<br> ****************************************************************************/<br> #define   DELAY_MODE_TIM2   1     // 通信时序中的延时方式：0_使用while方式的粗略延时; 1_使用TIM2进行计时; 注意计时器是否和其它设备有冲突<br>                                   // 0_使用粗略延时：注意本代码是在勾选下列参数状态下调试的：Options / C++ /One ELF Section per Function ;<br>                                   // 1_使用TIM2计时：首选推荐; 注意同一工程中是否有其它功能使用TIM2，以免发生冲突;<br>  <br>  <br>  <br> /*****************************************************************************<br>  ** 声明 全局变量<br> ****************************************************************************/<br> typedef struct<br> {<!-- --><br>     float          Temperature;   // 温度值：在调用DHT11_GetTemp()函数后，获取到的温度值；<br>     float          Humidity;      // 湿度值：在调用DHT11_GetTemp()函数后，获取到的温度值；<br> } xDHT11_TypeDef;<br> extern xDHT11_TypeDef  xDHT11;    // 声明全局结构体, 用于存放读取的结果值<br>  <br>  <br>  <br> /*****************************************************************************<br>  ** 声明  全局函数<br> ****************************************************************************/<br> uint8_t DHT11_GetData(GPIO_TypeDef *GPIOx, uint32_t PINx);<br> float DHT11_GetTemperature(GPIO_TypeDef *GPIOx, uint32_t PINx);<br> float DHT11_GetHumidity(GPIO_TypeDef *GPIOx, uint32_t PINx);<br>  <br> #endif <br>  <br>  <br>  <br>  </p> 
<p>BH1750.C</p> 
<p>/**************************************************************************<br>  * 文件名：bh1750.c<br>  * 功 能 ：光强度传感模块<br>  *<br>  * 作 者 ：魔女科技团队<br> ****************************************************************************/<br> #include "bsp_BH1750.h"<br>  <br> #define SDA_1   (BH1750_SDA_GPIOx -&gt; BSRR = BH1750_SDA_PINx)<br> #define SDA_0   (BH1750_SDA_GPIOx -&gt; BRR  = BH1750_SDA_PINx)<br>  <br> #define SCL_1   (BH1750_SCL_GPIOx -&gt; BSRR = BH1750_SCL_PINx)<br> #define SCL_0   (BH1750_SCL_GPIOx -&gt; BRR  = BH1750_SCL_PINx)<br>  <br>  <br>  <br>  <br> static uint8_t   Buffer[8];       // 接收数据缓存区<br>  <br>  <br>  <br>  <br> static void delay_us(uint32_t times)<br> {<!-- --><br>     times = times * 7;   //  10us内用7;<br>     while (--times)<br>         __nop();<br> }<br>  <br>  <br> static void delay_ms(uint32_t ms)<br> {<!-- --><br>     ms = ms * 6500;<br>     for (u32 i = 0; i &lt; ms; i++); // 72MHz系统时钟下，多少个空循环约耗时1ms<br> }<br>  <br>  <br>  <br>  <br> // 产生IIC开始信号<br> void BH1750_Start()<br> {<!-- --><br>     SDA_1 ;              // 拉高数据线<br>     SCL_1;               // 拉高时钟线<br>     delay_us(5);         // 延时<br>     SDA_0;               // 产生下降沿<br>     delay_us(5);         // 延时<br>     SCL_0;               // 拉低时钟线<br> }<br>  <br> // 产生IIC停止信号<br> void BH1750_Stop()<br> {<!-- --><br>     SDA_0;               // 拉低数据线<br>     SCL_1;               // 拉高时钟线<br>     delay_us(5);         // 延时<br>     SDA_1;               // 产生上升沿<br>     delay_us(5);         // 延时<br> }<br>  <br> // 发送应答信号, 参数:ack (0:ACK 1:NAK)<br> static void BH1750_SendACK(uint8_t ack)<br> {<!-- --><br>     GPIO_InitTypeDef GPIO_InitStruct;<br>  <br>     GPIO_InitStruct.GPIO_Pin   = BH1750_SDA_PINx ;<br>     GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_Out_PP;<br>     GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;<br>     GPIO_Init(BH1750_SDA_GPIOx, &amp;GPIO_InitStruct);<br>  <br>     if (ack == 1)    // 写应答信号<br>         SDA_1;<br>     else <br>         SDA_0;<br>  <br>     SCL_1;           // 拉高时钟线<br>     delay_us(5);     // 延时<br>     SCL_0;           // 拉低时钟线<br>     delay_us(5);     // 延时<br> }<br>  <br> // 接收应答信号<br> static uint8_t BH1750_RecvACK()<br> {<!-- --><br>     uint8_t value = 0;<br>     GPIO_InitTypeDef GPIO_InitStruct;<br>  <br>     GPIO_InitStruct.GPIO_Pin = BH1750_SDA_PINx ;    // 配置为输入模式<br>     GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;      // 上拉输入<br>     GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;<br>     GPIO_Init(BH1750_SDA_GPIOx, &amp;GPIO_InitStruct);<br>  <br>     SCL_1;                                          // 拉高时钟线<br>     delay_us(5);                                    // 延时<br>     if (BH1750_SDA_GPIOx-&gt;IDR &amp; BH1750_SDA_PINx)    // 读应答信号  (GPIO_ReadInputDataBit(GPIOA, sda) == 1)<br>         value = 1 ;<br>     else<br>         value = 0 ;<br>     SCL_0;                                          // 拉低时钟线<br>     delay_us(5);                                    // 延时<br>     GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;   // 配置为输出模式<br>     GPIO_Init(BH1750_SDA_GPIOx, &amp;GPIO_InitStruct);<br>     return value;<br> }<br>  <br> // 向IIC总线发送一个字节数据<br> static void BH1750_SendByte(uint8_t data)<br> {<!-- --><br>     for (uint8_t i = 0; i &lt; 8; i++)     //8位计数器<br>     {<!-- --><br>         if (0X80 &amp; data)<br>             SDA_1;<br>         else<br>             SDA_0;<br>         data &lt;&lt;= 1;<br>         SCL_1;             // 拉高时钟线<br>         delay_us(5);       // 延时<br>         SCL_0;             // 拉低时钟线<br>         delay_us(5);       // 延时<br>     }<br>     BH1750_RecvACK();      // 接收应答信号<br> }<br>  <br> // 向IIC总线接收一个字节<br> static uint8_t BH1750_RecvByte()<br> {<!-- --><br>     uint8_t i;<br>     uint8_t dat = 0;<br>     uint8_t bit;<br>  <br>     GPIO_InitTypeDef GPIO_InitStruct;              <br>     GPIO_InitStruct.GPIO_Pin = BH1750_SDA_PINx ;     // 配置为输入模式<br>     GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;       // 上拉输入 <br>     GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;<br>     GPIO_Init(BH1750_SDA_GPIOx, &amp;GPIO_InitStruct);<br>  <br>     SDA_1;                                           // 上拉,准备读取数据,<br>     for (i = 0; i &lt; 8; i++)                          // 8位计数器<br>     {<!-- --><br>         dat &lt;&lt;= 1;<br>         SCL_1;                                       // 拉高时钟线<br>         delay_us(5);                                 // 延时<br>  <br>         if (BH1750_SDA_GPIOx-&gt;IDR &amp; BH1750_SDA_PINx) <br>             bit = 0X01;<br>         else<br>             bit = 0x00;<br>         dat |= bit;                                  // 读数据<br>         SCL_0;                                       // 拉低时钟线<br>         delay_us(5);                                 // 延时<br>     }<br>     GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;    // 配置为输出模式<br>     GPIO_Init(BH1750_SDA_GPIOx, &amp;GPIO_InitStruct);<br>     return dat;<br> }<br>  <br> static void BH1750_WriteOrder(uint8_t REG_Address)<br> {<!-- --><br>     BH1750_Start();                  //起始信号<br>     BH1750_SendByte(BH1750_ADDR);    //发送设备地址+写信号<br>     BH1750_SendByte(REG_Address);    //内部寄存器地址，请参考中文pdf22页<br> //  BH1750_SendByte(REG_data);       //内部寄存器数据，请参考中文pdf22页<br>     BH1750_Stop();                   //发送停止信号<br> }<br>  <br> //初始化BH1750，根据需要请参考pdf进行修改<br> void BH1750_Init()<br> {<!-- --><br>     /*** 特别地说明：引脚需要在h文件中修改 ***/<br>         <br>     GPIO_InitTypeDef GPIO_InitStruct;<br>     // 使能SDA引脚端口时钟<br>     if (BH1750_SDA_GPIOx == GPIOA)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN;<br>     if (BH1750_SDA_GPIOx == GPIOB)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPBEN;<br>     if (BH1750_SDA_GPIOx == GPIOC)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN;<br>     if (BH1750_SDA_GPIOx == GPIOD)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPDEN;<br>     if (BH1750_SDA_GPIOx == GPIOE)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPEEN;<br>     if (BH1750_SDA_GPIOx == GPIOF)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPFEN;<br>     if (BH1750_SDA_GPIOx == GPIOG)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPGEN;<br>     // 使能SCL引脚端口时钟<br>     if (BH1750_SCL_GPIOx == GPIOA)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN;<br>     if (BH1750_SCL_GPIOx == GPIOB)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPBEN;<br>     if (BH1750_SCL_GPIOx == GPIOC)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN;<br>     if (BH1750_SCL_GPIOx == GPIOD)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPDEN;<br>     if (BH1750_SCL_GPIOx == GPIOE)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPEEN;<br>     if (BH1750_SCL_GPIOx == GPIOF)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPFEN;<br>     if (BH1750_SCL_GPIOx == GPIOG)  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPGEN;<br>  <br>     // 配置SDA引脚工作模式<br>     GPIO_InitStruct.GPIO_Pin   = BH1750_SDA_PINx;<br>     GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_Out_PP;<br>     GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;<br>     GPIO_Init(BH1750_SDA_GPIOx, &amp;GPIO_InitStruct);<br>     // 配置SCL引脚工作模式<br>     GPIO_InitStruct.GPIO_Pin   = BH1750_SCL_PINx;<br>     GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_Out_PP;<br>     GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;<br>     GPIO_Init(BH1750_SCL_GPIOx, &amp;GPIO_InitStruct);<br>  <br>     BH1750_WriteOrder(0x01);<br>     delay_ms(180);                // 延时180ms<br> }<br>  <br> //连续读出BH1750内部数据<br> static void BH1750_ReadData(void)<br> {<!-- --><br>     BH1750_Start();                        // 起始信号<br>     BH1750_SendByte(BH1750_ADDR + 1);      // 发送设备地址+读信号<br>  <br>     for (uint8_t i = 0; i &lt; 3; i++)        // 连续读取6个地址数据，存储buffer中<br>     {<!-- --><br>         Buffer[i] = BH1750_RecvByte();     // buffer[0]存储0x32地址中的数据<br>         if (i == 3)<br>         {<!-- --><br>             BH1750_SendACK(1);             // 最后一个数据需要回NOACK<br>         }<br>         else<br>         {<!-- --><br>             BH1750_SendACK(0);             // 回应ACK<br>         }<br>     }<br>     BH1750_Stop();                         // 停止信号<br>     delay_ms(5);<br> }<br>  <br>  <br>  <br> float BH1750_GetData(void)<br> {<!-- --><br>     uint32_t dataTem;                      // 结果值<br>     static uint8_t flagInit = 0;<br>     if(flagInit==0)<br>     {<!-- --><br>         BH1750_WriteOrder(0x01);           // power on<br>         BH1750_WriteOrder(0x10);           // H- resolution mode<br>         delay_ms(180);                     // 延时180ms<br>         flagInit=1;<br>     }        <br>     BH1750_ReadData();                     // 读取原始数据，存储在Buffer中<br>     dataTem = Buffer[0];<br>     dataTem = (dataTem &lt;&lt; 8) + Buffer[1];  // 转换成结果光强度值<br>     return dataTem / 1.2;<br> }</p> 
<p>BH1750.h</p> 
<p>#ifndef __BSP_BH1750_H__<br> #define __BSP_BH1750_H__<br> #include &lt;stm32f10x.h&gt;<br> #include &lt;stdio.h&gt;<br>  <br>  <br>  <br> //移植参数区 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br> // SDA<br> #define    BH1750_SDA_GPIOx   GPIOB         // 模拟IIC<br> #define    BH1750_SDA_PINx    GPIO_Pin_0<br> // SCL<br> #define    BH1750_SCL_GPIOx   GPIOB         // 模拟IIC<br> #define    BH1750_SCL_PINx    GPIO_Pin_1<br> // IIC器件地址<br> #define    BH1750_ADDR   0x46               // 定义器件在IIC总线中的从地址, 根据ADDR引脚不同修改：当ADDR引脚接GND或空置时地址为0x46，接3.3V时地址为0xB8<br> //END 移植 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br>  <br>  <br>  <br> /*****************************************************************************<br>  ** 声明  全局函数<br> ****************************************************************************/<br> void     BH1750_Init(void);           // 初始化BH1750<br> float    BH1750_GetData(void);                                      // 读取BH1750数据<br>  <br>  <br>  <br>  <br> #endif<br>  <br>  </p> 
<p>主函数代码</p> 
<p>/**==================================================================================================================<br>  **【文件名称】  main.c<br>  **【功能测试】  DHT11-温湿度获取<br>  **==================================================================================================================<br>  **【适用平台】 STM32F103 + KEIL5.27 + 标准库v3.5 + DHT11<br>  **<br>  **【实验操作】  1-模块接线，VCC  接 3.3V 或 5V<br>  **                          DATA 接 PC3<br>  **                          GND  接 GND<br>  **              2-烧录代码至开发板，并重新上电或复位，使新程序运行；<br>  **              3-打开电脑串口上位机，115200-N-8-1, 即可观察到采集的数据；<br>  **              4-注意：DHT11的上电稳定时间约:1~6秒，采集间隔时长约: 0.5~2秒， 不同厂家不同芯片，有所差异;<br>  **<br>  **【划 重 点】  1-电压范围：3.3V~5.0V，工作电流：0.2~1mA; 待机电流：150uA<br>  **              2-DHT11反应有点慢：上电后1S后进入稳定状态;<br>  **              3-采样周期，不同店家的DHT11，参数不同，一般是1次/秒, 有部分可以数百毫秒间隔采集一次; 当小于采样周期进行重复采集数据，会发生错误;<br>  **              5-DHT11时序要求较高，us级别，当使用delay粗略延时，同一份代码同一个模块，在不同keil里跑也可能发生错误(代码优化设置对while延时的影响)。建议使用TIM的精准延时;<br>  **              4-注意判断使用的DHT11器件，是单独的DHT11元件，还是完整的DHT11模块<br>  **                单独的DHT11元件：蓝色塑料主体、三个引脚，不带上拉电阻；适合低成本工程方案使用，建议测试时引脚使用推挽输出模式；<br>  **                完整的DTH11模块：蓝色塑料主体、三个引脚、PCB底板、上拉电阻、电源指示LED，适合方案搭建；<br>  **              6-精度误差：DHT11分旧版和新版，10元内的绝大部分是旧版，新版约12元左右；<br>  **                          旧版数据稳定，但只有整数部分，新版有小数部分，但数据跳动稍大；<br>  **                          温度0-50°C; 精度±2°C; 小数部份无效<br>  **                          湿度20-80%; 精度±5%; 小数部分无效<br>  **<br>  **<br>  **【文件移植】  步骤1-复制文件：可复制bsp_DHT11.c和bsp_DHT11h两个文件，或复制DHT11文件夹，保存到所需工程目录文件夹下；<br>  **              步骤2-添加文件：在keil工各程左侧文件管理器中，双击某文件夹，以添加bsp_DHT11.c文件;<br>  **              步骤3-添加路径：点击魔术棒工具按钮，在“c/c++"选项页中，点击”Include Path"后面的按键，以添加文件存放所在路径(是文件夹，不是文件);<br>  **　　　　　    步骤4-添加引脚：在所需DHT11功能的代码文件头部，添加：#include "bsp_DHT11.h";<br>  **<br>  **<br>  **【函数使用】  函数2-DHT11_GetData(GPIOx, GPIO_Pin_x);           // 获取数据, 获取的数据存放于结构体xDHT11中，具体使用方法，可参考示例代码<br>  **<br>  **<br>  **【备注说明】  代码版权归魔女科技所有，请勿商用，谢谢！<br>  **              https://demoboard.taobao.com<br> ====================================================================================================================*/<br> #include &lt;stm32f10x.h&gt;            // 头文件引用(标准库); 内核、芯片外设....；(stm32f10x.conf.h, 对标准库头文件进行调用)     <br> #include "stm32f10x_conf.h"       // 头文件引用(标准库); 内核、芯片外设....；(stm32f10x.conf.h, 对标准库头文件进行调用) <br> #include "stm32f10x_tim.h"<br> #include "bsp_led.h"              // LED指示灯<br> #include "bsp_usart.h"            // USART1、2、3，UART4、5<br> #include "bsp_lcd_ST7735.h"       // 1.8寸显示屏驱动 <br> #include "bsp_DHT11.h"            // DHT11<br> #include "bsp_BH1750.h"<br> #include "stdio.h"<br> #include "Timer.h"<br>  <br>  <br>  <br> char   strTem[100];               // 用于临时存储字符串<br> uint16_t Temperature=0;<br> uint16_t Humidity=0;<br> float Light=0.0;<br> char Temp_aly[300];        <br>  <br>  <br>  <br> // ms延时函数，减少移植时对外部文件依赖；<br> static void delay_ms(u32 ms)<br> {<!-- --><br>     ms = ms * 6500;<br>     for (u32 i = 0; i &lt; ms; i++); // 72MHz系统时钟下，多少个空循环约耗时1ms<br> }<br>  <br>  <br>  <br> // 主函数<br> int main(void)<br> {<!-- --><br>     USART1_Init(115200);                                        // 串口初始化：USART1(115200-N-8-1), 且工程已把printf重定向至USART1输出<br>     USART2_Init(115200);<br>       BH1750_Init();<br>     Led_Init();                                                 // LED 初始化<br>     LED_RED_ON;                                                 // 点亮红灯   <br>     LCD_Init();                                                // 初始化显示屏-驱动芯片ST7735<br>     Timer_Init();<br>     <br>     <br>       USART2_SendString("AT+RST\r\n");<br>       delay_ms(8000);    <br>     <br>         USART2_SendString("AT+CWMODE=3\r\n");<br>         delay_ms(8000);<br>       printf("%s\r\n",xUSART.USART2ReceivedBuffer);        <br>  <br>       USART2_SendString("AT+CWJAP=\"PCG1\",\"862139..\"\r\n");<br>         delay_ms(8000);<br>       printf("%s\r\n",xUSART.USART2ReceivedBuffer);<br>  <br>       USART2_SendString("AT+MQTTUSERCFG=0,1,\"NULL\",\"ESP8266_Room&amp;a1F60XocNHb\",\"3BD08EC181CD30E09BB01C6B8E4FA0ACB63EF07F\",0,0,\"\"\r\n");<br>         delay_ms(5000);<br>       printf("%s\r\n",xUSART.USART2ReceivedBuffer);                    <br>       USART2_SendString("AT+MQTTCLIENTID=0,\"002211|securemode=3\\,signmethod=hmacsha1\\,timestamp=112200|\"\r\n");<br>         delay_ms(5000);<br>       printf("%s\r\n",xUSART.USART2ReceivedBuffer);                <br>         <br>       USART2_SendString("AT+MQTTCONN=0,\"a1F60XocNHb.iot-as-mqtt.cn-shanghai.aliyuncs.com\",1883,1\r\n");<br>         delay_ms(10000);<br>       printf("%s\r\n",xUSART.USART2ReceivedBuffer);        <br>         <br>     USART2_SendString("ATE0\r\n");<br>         delay_ms(2000);<br>     <br>     LCD_Chinese16ForFile(25,34,5,BLUE,BLACK);<br>     LCD_Chinese16ForFile(25+16,34,7,BLUE,BLACK);<br>  <br>     <br>       LCD_Chinese16ForFile(25,50,6,BLUE,BLACK);<br>     LCD_Chinese16ForFile(25+16,50,7,BLUE,BLACK);<br>     <br>       LCD_Chinese16ForFile(25,70,8,BLUE,BLACK);<br>     LCD_Chinese16ForFile(25+16,70,9,BLUE,BLACK);    <br>       LCD_Chinese16ForFile(25+2*16,70,10,BLUE,BLACK);<br>     LCD_Chinese16ForFile(25+3*16,70,7,BLUE,BLACK);        <br>  <br>  <br>  <br>         if(xUSART.USART2InitFlag)<br>             {<!-- --><br>                 xUSART.USART2InitFlag = 0;<br>                 memset(xUSART.USART2ReceivedBuffer,0,xUSART.USART2ReceivedNum);<br>                 xUSART.USART2ReceivedNum = 0;<br>             }            <br>             <br>             <br>     while (1)                                                   // while函数死循环，不能让main函数运行结束，否则会产生硬件错误<br>     {<!-- --><br>             Temperature=DHT11_GetTemperature(GPIOE,GPIO_Pin_3);<br>             Humidity=DHT11_GetHumidity(GPIOE,GPIO_Pin_3);<br>             Light=BH1750_GetData();<br>             <br>             sprintf(strTem,":%d^C",Temperature);<br>             LCD_String(25+16*2,34,strTem,16,BLUE,BLACK);<br>  <br>             sprintf(strTem,":%d%%",Humidity);<br>             LCD_String(25+16*2,50,strTem,16,BLUE,BLACK);        <br>     <br>             sprintf(strTem,":%.0fLux   ",Light);<br>             LCD_String(25+16*4,70,strTem,16,BLUE,BLACK);                <br>             printf("当前温度为:%d,当前湿度为:%d,当前光照强度为:%.0f\r\n",Temperature,Humidity,Light);<br>       <br>             sprintf(Temp_aly,"AT+MQTTPUB=0,\"/sys/a1F60XocNHb/ESP8266_Room/thing/event/property/post\",\"{\\\"method\\\":\\\"thing.service.property.set\\\"\\\,\\\"id\\\":\\\"2012934117\\\"\\\,\\\"params\\\":{\\\"TEMP\\\":%d\\\,\\\"Light\\\":%d\\\,\\\"Huit\\\":%d}\\\,\\\"version\\\":\\\"1.0.0\\\"}\",1,0\r\n",Temperature,Humidity,(uint16_t)(Light));<br>             USART2_SendString(Temp_aly);<br>       delay_ms(300);<br>     }<br> }<br>  <br> void TIM2_IRQHandler(void)<br> {<!-- --><br>     if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)<br>     {<!-- --><br>  <br>         LED_RED_TOGGLE;<br>         TIM_ClearITPendingBit(TIM2,TIM_IT_Update);        <br>     }<br> }<br>  <br> // 注意：每个代码文件的末尾，要保留一个空行</p> 
<p>在主函数中一定要特别注意字符串的处理</p> 
<p>TFT彩屏的驱动代码这里就不作展示了，在网上都能随便找到</p> 
<p>五、实物演示<br> 阿里云界面</p> 
<p><br> TFT彩屏页面展示</p> 
<p><br> 至此所有工作全部完成，实现预期效果</p> 
<p>在此特别感谢淘宝魔女开发板团队的代码，可移植性很强<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d7310eabcd4b5495faa5f9a4e157b6d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android LeakCanary使用详细教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1eb5d45439785a5060e3ec6d68d9f124/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Glide简单使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>