<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MTK 平台TP 驱动 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MTK 平台TP 驱动" />
<meta property="og:description" content="下面以汇顶gt9xx_driver.c 驱动为例讲解TP 驱动的整个关键点，本篇只讲TP 驱动本身的代码，
在驱动代码涉及的方法技术，因为每一个都牵涉linux内核的设计和知识，后面会逐个展开深入讲解。
首先，我们来总体看下TP 驱动代码初始化流程：
MTK kernel-4.14 TP 驱动初始化和部分工作流程main.cmain.cgt9xx_driver.cgt9xx_driver.cmtk_tpd.cmtk_tpd.ci2c.hi2c.hkthread.hkthread.hwait.hwait.hgt9xx_update.cgt9xx_update.cdo_initcallsmodule_inittpd_driver_inittpd_get_dts_infotpd_driver_addtpd_local_initi2c_add_drivertpd_i2c_probetpd_power_ongtp_init_panelkthread_runtouch_event_handlerwait_event_interruptibletpd_irq_registrationtpd_interrupt_handlerwake_up_interruptiblegup_init_update_proc
首先看TP 驱动模块初始化：
1
2
3
4
5
6
7
8
9
static int __init tpd_driver_init(void)
{
GTP_INFO(&#34;GT9 series touch panel driver init&#34;);
tpd_get_dts_info();
if (tpd_driver_add(&amp;tpd_device_driver) &lt; 0)
GTP_INFO(&#34;add generic driver failed&#34;);
return 0;
}
请注意这个tpd_driver_init 是一个__init 修饰的函数，说明这个函数在编译时会被放到跟其他__init 修饰的函数放到一起，
在系统初始化，一旦内核启动后，就释放这些东西。一般用__init修饰的变量或者函数会编译到专门的一个段里面去，
这个段的数据和函数只有在kernel初始化的时候会被调用，以后一定不会被使用，kernel可能会在以后的某个时候释放掉这个段所占用的内存，
给别的地方使用，是不是设计很巧妙？ 感兴趣的同学可以继续深入分析看看。
那么，我们看到这个函数主要就做了两件事情：
（1）是获取这个TP 所有的DTS 信息，我们看看这个代码的实现：
1
2
3
4
5
6
7
8
9
10
11
12" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/216c3c22d45f9ab989563eb8de8379e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-04T10:25:10+08:00" />
<meta property="article:modified_time" content="2021-04-04T10:25:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MTK 平台TP 驱动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>下面以汇顶gt9xx_driver.c 驱动为例讲解TP 驱动的整个关键点，本篇只讲TP 驱动本身的代码，</p> 
<p>在驱动代码涉及的方法技术，因为每一个都牵涉linux内核的设计和知识，后面会逐个展开深入讲解。</p> 
<p>首先，我们来总体看下TP 驱动代码初始化流程：</p> 
<p><img alt="" height="826" src="https://images2.imgbox.com/e5/67/qJpcYKx3_o.png" width="739"><br> MTK kernel-4.14 TP 驱动初始化和部分工作流程main.cmain.cgt9xx_driver.cgt9xx_driver.cmtk_tpd.cmtk_tpd.ci2c.hi2c.hkthread.hkthread.hwait.hwait.hgt9xx_update.cgt9xx_update.cdo_initcallsmodule_inittpd_driver_inittpd_get_dts_infotpd_driver_addtpd_local_initi2c_add_drivertpd_i2c_probetpd_power_ongtp_init_panelkthread_runtouch_event_handlerwait_event_interruptibletpd_irq_registrationtpd_interrupt_handlerwake_up_interruptiblegup_init_update_proc</p> 
<p>首先看TP 驱动模块初始化：</p> 
<p> </p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> </td><td> <p><code>static</code> <code>int</code> <code>__init tpd_driver_init(</code><code>void</code><code>)</code></p> <p><code>{<!-- --></code></p> <p><code>        </code><code>GTP_INFO(</code><code>"GT9 series touch panel driver init"</code><code>);</code></p> <p><code>        </code><code>tpd_get_dts_info();</code></p> <p><code>        </code><code>if</code> <code>(tpd_driver_add(&amp;tpd_device_driver) &lt; </code><code>0</code><code>)</code></p> <p><code>                </code><code>GTP_INFO(</code><code>"add generic driver failed"</code><code>);</code></p> <p> </p> <p><code>                </code><code>return</code> <code>0</code><code>;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> </p> 
<p> </p> 
<p><br> 请注意这个tpd_driver_init 是一个__init 修饰的函数，说明这个函数在编译时会被放到跟其他__init 修饰的函数放到一起，<br> 在系统初始化，一旦内核启动后，就释放这些东西。一般用__init修饰的变量或者函数会编译到专门的一个段里面去，<br> 这个段的数据和函数只有在kernel初始化的时候会被调用，以后一定不会被使用，kernel可能会在以后的某个时候释放掉这个段所占用的内存，<br> 给别的地方使用，是不是设计很巧妙？ 感兴趣的同学可以继续深入分析看看。</p> 
<p>那么，我们看到这个函数主要就做了两件事情：<br> （1）是获取这个TP 所有的DTS 信息，我们看看这个代码的实现：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> <p>57</p> <p>58</p> <p>59</p> <p>60</p> <p>61</p> <p>62</p> <p>63</p> <p>64</p> <p>65</p> <p>66</p> <p>67</p> <p>68</p> <p>69</p> </td><td> <p><code>void</code> <code>tpd_get_dts_info(</code><code>void</code><code>)</code></p> <p><code>{<!-- --></code></p> <p><code>        </code><code>struct device_node *node1 = NULL;</code></p> <p><code>        </code><code>int</code> <code>key_dim_local[</code><code>16</code><code>], i, ret;</code></p> <p> </p> <p><code>        </code><code>node1 = of_find_matching_node(node1, touch_of_match);</code></p> <p><code>        </code><code>if</code> <code>(node1) {<!-- --></code></p> <p><code>                </code><code>ret = of_property_read_u32(node1, </code><code>"tpd-max-touch-num"</code><code>, &amp;tpd_dts_data.touch_max_num);</code></p> <p><code>                </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                        </code><code>TPD_DEBUG(</code><code>"tpd-max-touch-num not found\n"</code><code>);</code></p> <p><code>                </code><code>ret = of_property_read_u32(node1, </code><code>"use-tpd-button"</code><code>, &amp;tpd_dts_data.use_tpd_button);</code></p> <p><code>                </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                        </code><code>TPD_DEBUG(</code><code>"use-tpd-button not found\n"</code><code>);</code></p> <p><code>                </code><code>else</code></p> <p><code>                        </code><code>TPD_DEBUG(</code><code>"[tpd]use-tpd-button = %d\n"</code><code>, tpd_dts_data.use_tpd_button);</code></p> <p><code>                </code><code>ret = of_property_read_u32_array(node1, </code><code>"tpd-resolution"</code><code>,</code></p> <p><code>                        </code><code>tpd_dts_data.tpd_resolution, ARRAY_SIZE(tpd_dts_data.tpd_resolution));</code></p> <p><code>                </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                        </code><code>TPD_DEBUG(</code><code>"tpd-resolution not found\n"</code><code>);</code></p> <p><code>                </code><code>if</code> <code>(tpd_dts_data.use_tpd_button) {<!-- --></code></p> <p><code>                        </code><code>ret = of_property_read_u32(node1, </code><code>"tpd-key-num"</code><code>, &amp;tpd_dts_data.tpd_key_num);</code></p> <p><code>                        </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                                </code><code>TPD_DEBUG(</code><code>"tpd-key-num not found\n"</code><code>);</code></p> <p><code>                        </code><code>ret = of_property_read_u32_array(node1, </code><code>"tpd-key-local"</code><code>,</code></p> <p><code>                                </code><code>tpd_dts_data.tpd_key_local, ARRAY_SIZE(tpd_dts_data.tpd_key_local));</code></p> <p><code>                        </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                                </code><code>TPD_DEBUG(</code><code>"tpd-key-local not found\n"</code><code>);</code></p> <p><code>                        </code><code>ret = of_property_read_u32_array(node1, </code><code>"tpd-key-dim-local"</code><code>,</code></p> <p><code>                                </code><code>key_dim_local, ARRAY_SIZE(key_dim_local));</code></p> <p><code>                        </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                                </code><code>TPD_DEBUG(</code><code>"tpd-key-dim-local not found\n"</code><code>);</code></p> <p> </p> <p><code>                        </code><code>memcpy(tpd_dts_data.tpd_key_dim_local, key_dim_local, sizeof(key_dim_local));</code></p> <p><code>                        </code><code>for</code> <code>(i = </code><code>0</code><code>; i &lt; </code><code>4</code><code>; i++) {<!-- --></code></p> <p><code>                                </code><code>pr_debug(</code><code>"[tpd]key[%d].key_x = %d\n"</code><code>, i, tpd_dts_data.tpd_key_dim_local[i].key_x);</code></p> <p><code>                                </code><code>pr_debug(</code><code>"[tpd]key[%d].key_y = %d\n"</code><code>, i, tpd_dts_data.tpd_key_dim_local[i].key_y);</code></p> <p><code>                                </code><code>pr_debug(</code><code>"[tpd]key[%d].key_W = %d\n"</code><code>, i, tpd_dts_data.tpd_key_dim_local[i].key_width);</code></p> <p><code>                                </code><code>pr_debug(</code><code>"[tpd]key[%d].key_H = %d\n"</code><code>, i, tpd_dts_data.tpd_key_dim_local[i].key_height);</code></p> <p><code>                        </code><code>}</code></p> <p><code>                </code><code>}</code></p> <p><code>                </code><code>ret = of_property_read_u32(node1, </code><code>"tpd-filter-enable"</code><code>, &amp;tpd_dts_data.touch_filter.enable);</code></p> <p><code>                </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                        </code><code>TPD_DEBUG(</code><code>"tpd-filter-enable not found\n"</code><code>);</code></p> <p><code>                </code><code>if</code> <code>(tpd_dts_data.touch_filter.enable) {<!-- --></code></p> <p><code>                        </code><code>ret = of_property_read_u32(node1, </code><code>"tpd-filter-pixel-density"</code><code>,</code></p> <p><code>                                                 </code><code>&amp;tpd_dts_data.touch_filter.pixel_density);</code></p> <p><code>                        </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                                </code><code>TPD_DEBUG(</code><code>"tpd-filter-pixel-density not found\n"</code><code>);</code></p> <p><code>                        </code><code>ret = of_property_read_u32_array(node1, </code><code>"tpd-filter-custom-prameters"</code><code>,</code></p> <p><code>                                </code><code>(u32 *)tpd_dts_data.touch_filter.W_W, ARRAY_SIZE(tpd_dts_data.touch_filter.W_W));</code></p> <p><code>                        </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                                </code><code>TPD_DEBUG(</code><code>"tpd-filter-custom-prameters not found\n"</code><code>);</code></p> <p><code>                        </code><code>ret = of_property_read_u32_array(node1, </code><code>"tpd-filter-custom-speed"</code><code>,</code></p> <p><code>                                </code><code>tpd_dts_data.touch_filter.VECLOCITY_THRESHOLD,</code></p> <p><code>                                </code><code>ARRAY_SIZE(tpd_dts_data.touch_filter.VECLOCITY_THRESHOLD));</code></p> <p><code>                        </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                                </code><code>TPD_DEBUG(</code><code>"tpd-filter-custom-speed not found\n"</code><code>);</code></p> <p><code>                </code><code>}</code></p> <p><code>                </code><code>memcpy(&amp;tpd_filter, &amp;tpd_dts_data.touch_filter, sizeof(tpd_filter));</code></p> <p><code>                </code><code>TPD_DEBUG(</code><code>"[tpd]tpd-filter-enable = %d, pixel_density = %d\n"</code><code>,</code></p> <p><code>                                        </code><code>tpd_filter.enable, tpd_filter.pixel_density);</code></p> <p><code>                </code><code>tpd_dts_data.tpd_use_ext_gpio = of_property_read_bool(node1, </code><code>"tpd-use-ext-gpio"</code><code>);</code></p> <p><code>                </code><code>ret = of_property_read_u32(node1, </code><code>"tpd-rst-ext-gpio-num"</code><code>, &amp;tpd_dts_data.rst_ext_gpio_num);</code></p> <p><code>                </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                        </code><code>TPD_DEBUG(</code><code>"tpd-rst-ext-gpio-num not found\n"</code><code>);</code></p> <p><code>        </code><code>} </code><code>else</code> <code>{<!-- --></code></p> <p><code>                </code><code>pr_err(</code><code>"[tpd]%s can't find touch compatible custom node\n"</code><code>, __func__);</code></p> <p><code>        </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> </p> 
<p>这个函数看似很长，其实就是在读取我们定义在dts文件里面跟这个TP相关的数据，包括最大手指数：tpd-max-touch-num，对应的数据上报分辨率：tpd_resolution</p> 
<p>复位GPIO 配置：tpd-rst-ext-gpio-num等信息。</p> 
<p> </p> 
<p>我们来看一个相关dts配置信息：</p> 
<p>arch/arm64/boot/dts/mediatek/tb8788p1_64_bsp.dts</p> 
<p> </p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> </td><td> <p><code>&amp;touch {<!-- --></code></p> <p><code>        </code><code>//tpd-resolution = &lt;800 1280&gt;;</code></p> <p><code>        </code><code>tpd-resolution = &lt;</code><code>1920</code> <code>1200</code><code>&gt;;</code></p> <p><code>        </code><code>use-tpd-button = &lt;</code><code>0</code><code>&gt;;</code></p> <p><code>        </code><code>tpd-key-num = &lt;</code><code>3</code><code>&gt;;</code></p> <p><code>        </code><code>tpd-key-local= &lt;</code><code>139</code> <code>172</code> <code>158</code> <code>0</code><code>&gt;;</code></p> <p><code>        </code><code>tpd-key-dim-local = &lt;</code><code>90</code> <code>883</code> <code>100</code> <code>40</code> <code>230</code> <code>883</code> <code>100</code> <code>40</code> <code>370</code> <code>883</code> <code>100</code> <code>40</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code><code>&gt;;</code></p> <p><code>        </code><code>tpd-max-touch-num = &lt;</code><code>5</code><code>&gt;;</code></p> <p><code>        </code><code>tpd-filter-enable = &lt;</code><code>1</code><code>&gt;;</code></p> <p><code>        </code><code>tpd-filter-pixel-density = &lt;</code><code>146</code><code>&gt;;</code></p> <p><code>        </code><code>tpd-filter-custom-prameters = &lt;</code><code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code> <code>0</code><code>&gt;;</code></p> <p><code>        </code><code>tpd-filter-custom-speed = &lt;</code><code>0</code> <code>0</code> <code>0</code><code>&gt;;</code></p> <p><code>        </code><code>pinctrl-names = </code><code>"default"</code><code>, </code><code>"state_eint_as_int"</code><code>, </code><code>"state_eint_output0"</code><code>, </code><code>"state_eint_output1"</code><code>,</code></p> <p><code>                </code><code>"state_rst_output0"</code><code>, </code><code>"state_rst_output1"</code><code>;</code></p> <p><code>        </code><code>pinctrl-</code><code>0</code> <code>= &lt;&amp;ctp_pins_default&gt;;</code></p> <p><code>        </code><code>pinctrl-</code><code>1</code> <code>= &lt;&amp;ctp_pins_eint_as_int&gt;;</code></p> <p><code>        </code><code>pinctrl-</code><code>2</code> <code>= &lt;&amp;ctp_pins_eint_output0&gt;;</code></p> <p><code>        </code><code>pinctrl-</code><code>3</code> <code>= &lt;&amp;ctp_pins_eint_output1&gt;;</code></p> <p><code>        </code><code>pinctrl-</code><code>4</code> <code>= &lt;&amp;ctp_pins_rst_output0&gt;;</code></p> <p><code>        </code><code>pinctrl-</code><code>5</code> <code>= &lt;&amp;ctp_pins_rst_output1&gt;;</code></p> <p><code>        </code><code>status = </code><code>"okay"</code><code>;</code></p> </td></tr></tbody></table> 
<p> </p> 
<p>（2）第二件事情，将这个tpd 的驱动加入到内核里面来：</p> 
<p>tpd_driver_add(&amp;tpd_device_driver)</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>static</code> <code>struct tpd_driver_t tpd_device_driver = {<!-- --></code></p> <p><code>                </code><code>.tpd_device_name = </code><code>"gt9xx"</code><code>,</code></p> <p><code>                </code><code>.tpd_local_init = tpd_local_init,</code></p> <p><code>                </code><code>.suspend = tpd_suspend,</code></p> <p><code>                </code><code>.resume = tpd_resume,</code></p> <p><code>};</code></p> </td></tr></tbody></table> 
<p>这个driver 结构体里面定义了这个触摸屏的真正初始化函数，以及他的睡眠和唤醒函数，</p> 
<p>另外tpd_device_name 名字为gt9xx，这个为以后识别设备，然后加载驱动提供的名字匹配。</p> 
<p>同时，如果看了tpd_driver_add 代码实现，就能发下这个driver会被加入到tpd_driver_list 中。</p> 
<p> </p> 
<p>接下来我们分析TP的真正初始化：tpd_local_init</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> <p>57</p> <p>58</p> <p>59</p> <p>60</p> <p>61</p> <p>62</p> <p>63</p> <p>64</p> <p>65</p> <p>66</p> <p>67</p> <p>68</p> <p>69</p> <p>70</p> <p>71</p> <p>72</p> <p>73</p> <p>74</p> <p>75</p> <p>76</p> <p>77</p> <p>78</p> <p>79</p> <p>80</p> <p>81</p> <p>82</p> </td><td> <p><code>static</code> <code>int</code> <code>tpd_local_init(</code><code>void</code><code>)</code></p> <p><code>{<!-- --></code></p> <p><code>        </code><code>int</code> <code>retval;</code></p> <p> </p> <p><code>        </code><code>gtp_workqueue = create_workqueue(</code><code>"gtp-workqueue"</code><code>);</code></p> <p><code>        </code><code>clk_tick_cnt = </code><code>2</code> <code>* HZ;   </code><code>/* HZ: clock ticks in 1 second generated by system */</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_ESD_PROTECT</code></p> <p><code>        </code><code>GTP_DEBUG(</code><code>"Clock ticks for an esd cycle: %d"</code><code>, clk_tick_cnt);</code></p> <p><code>        </code><code>INIT_DELAYED_WORK(&gt;p_esd_check_work, gtp_esd_check_func);</code></p> <p><code>        </code><code>spin_lock_init(&amp;esd_lock);      </code><code>/* 2.6.39 &amp; later */</code></p> <p><code>#endif</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_CHARGER_DETECT</code></p> <p><code>        </code><code>if</code><code>( (KERNEL_POWER_OFF_CHARGING_BOOT != get_boot_mode() ) &amp;&amp; ( LOW_POWER_OFF_CHARGING_BOOT != get_boot_mode() )  )</code></p> <p><code> </code><code>{<!-- --></code></p> <p><code>printk(</code><code>"###########cwj1*********"</code><code>);</code></p> <p><code>        </code><code>gtp_charger_workqueue = create_workqueue(</code><code>"gtp-charger-workqueue"</code><code>);</code></p> <p><code>        </code><code>clk_tick_cnt1 = </code><code>2</code> <code>* HZ;  </code><code>/* HZ: clock ticks in 1 second generated by system */</code></p> <p><code>        </code><code>INIT_DELAYED_WORK(&gt;p_charger_check_work, gtp_charger_check_func);</code></p> <p><code>        </code><code>queue_delayed_work(gtp_charger_workqueue, &gt;p_charger_check_work, clk_tick_cnt1);</code></p> <p><code> </code><code>}</code></p> <p><code>#endif</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_SUPPORT_I2C_DMA</code></p> <p><code>        </code><code>gpDMABuf_va = (u8 *)dma_alloc_coherent(NULL, GTP_DMA_MAX_TRANSACTION_LENGTH,</code></p> <p><code>                        </code><code>&amp;gpDMABuf_pa, GFP_KERNEL);</code></p> <p><code>        </code><code>if</code> <code>(!gpDMABuf_va)</code></p> <p><code>                </code><code>GTP_INFO(</code><code>"[Error] Allocate DMA I2C Buffer failed!\n"</code><code>);</code></p> <p> </p> <p><code>        </code><code>memset(gpDMABuf_va, </code><code>0</code><code>, GTP_DMA_MAX_TRANSACTION_LENGTH);</code></p> <p><code>#endif</code></p> <p> </p> <p><code>#</code><code>if</code> <code>1</code></p> <p><code>    </code><code>TPD_DMESG(</code><code>"set reg voltage!\n"</code><code>);</code></p> <p><code>        </code><code>tpd-&gt;reg = regulator_get(tpd-&gt;tpd_dev, </code><code>"vtouch"</code><code>);</code></p> <p><code>        </code><code>retval = regulator_set_voltage(tpd-&gt;reg, </code><code>2800000</code><code>, </code><code>2800000</code><code>);</code></p> <p><code>        </code><code>if</code> <code>(retval != </code><code>0</code><code>) {<!-- --></code></p> <p><code>                </code><code>TPD_DMESG(</code><code>"Failed to set reg-vgp6 voltage: %d\n"</code><code>, retval);</code></p> <p><code>                </code><code>return</code> <code>-</code><code>1</code><code>;</code></p> <p><code>        </code><code>}</code></p> <p><code>#endif</code></p> <p> </p> <p> </p> <p><code>        </code><code>if</code> <code>(i2c_add_driver(&amp;tpd_i2c_driver) != </code><code>0</code><code>) {<!-- --></code></p> <p><code>                </code><code>GTP_INFO(</code><code>"unable to add i2c driver."</code><code>);</code></p> <p><code>                </code><code>return</code> <code>-</code><code>1</code><code>;</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p><code>        </code><code>if</code> <code>(tpd_load_status == </code><code>0</code><code>)       {<!-- --></code></p> <p><code>                </code><code>GTP_INFO(</code><code>"add error touch panel driver."</code><code>);</code></p> <p><code>                </code><code>i2c_del_driver(&amp;tpd_i2c_driver);</code></p> <p><code>                </code><code>return</code> <code>-</code><code>1</code><code>;</code></p> <p><code>        </code><code>}</code></p> <p><code>        </code><code>input_set_abs_params(tpd-&gt;dev, ABS_MT_TRACKING_ID, </code><code>0</code><code>, (GTP_MAX_TOUCH-</code><code>1</code><code>), </code><code>0</code><code>, </code><code>0</code><code>);</code></p> <p><code>        </code><code>if</code> <code>(tpd_dts_data.use_tpd_button) {<!-- --></code></p> <p><code>                </code><code>/*initialize tpd button data*/</code></p> <p><code>                </code><code>tpd_button_setting(tpd_dts_data.tpd_key_num, tpd_dts_data.tpd_key_local,</code></p> <p><code>                </code><code>tpd_dts_data.tpd_key_dim_local);</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p><code>#</code><code>if</code> <code>(defined(TPD_WARP_START) &amp;&amp; defined(TPD_WARP_END))</code></p> <p><code>        </code><code>TPD_DO_WARP = </code><code>1</code><code>;</code></p> <p><code>        </code><code>memcpy(tpd_wb_start, tpd_wb_start_local, TPD_WARP_CNT * </code><code>4</code><code>);</code></p> <p><code>        </code><code>memcpy(tpd_wb_end, tpd_wb_start_local, TPD_WARP_CNT * </code><code>4</code><code>);</code></p> <p><code>#endif</code></p> <p> </p> <p><code>#</code><code>if</code> <code>(defined(TPD_HAVE_CALIBRATION) &amp;&amp; !defined(TPD_CUSTOM_CALIBRATION))</code></p> <p><code>        </code><code>memcpy(tpd_calmat, tpd_def_calmat_local, </code><code>8</code> <code>* </code><code>4</code><code>);</code></p> <p><code>        </code><code>memcpy(tpd_def_calmat, tpd_def_calmat_local, </code><code>8</code> <code>* </code><code>4</code><code>);</code></p> <p><code>#endif</code></p> <p> </p> <p><code>        </code><code>/* set vendor string */</code></p> <p><code>        </code><code>tpd-&gt;dev-&gt;id.vendor = </code><code>0x00</code><code>;</code></p> <p><code>        </code><code>tpd-&gt;dev-&gt;id.product = tpd_info.pid;</code></p> <p><code>        </code><code>tpd-&gt;dev-&gt;id.version = tpd_info.vid;</code></p> <p> </p> <p><code>        </code><code>GTP_INFO(</code><code>"end %s, %d"</code><code>, __func__, __LINE__);</code></p> <p><code>        </code><code>tpd_type_cap = </code><code>1</code><code>;</code></p> <p> </p> <p><code>        </code><code>return</code> <code>0</code><code>;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> </p> 
<p>我们看到这个代码里面写了很多个宏，</p> 
<p>GTP_ESD_PROTECT 是用来打开 TP 静电保护功能的，这个功能的主要作用是在TP 遇到高电压的静电时能够恢复工作，而不会影响使用。</p> 
<p>如果对这个静电机制感兴趣，可以再深入研究，后面我再开一篇文章讲解。</p> 
<p> </p> 
<p>第二个宏CONFIG_GTP_CHARGER_DETECT，这个宏看起来是用来充电情况下保证TP工作的，这应该是跟具体TP有关，因为有的TP在</p> 
<p>工作时会受充电器影响，所以这个驱动中加了这个充电检测机制。</p> 
<p> </p> 
<p>第三个宏GTP_SUPPORT_I2C_DMA ，这个主要是申请I2C DMA的空间，用户I2C 传输数据，这个指向的是直接虚拟地址，有利于提高传输数据效率。</p> 
<p> </p> 
<p> </p> 
<p>接下来我们看到 regulator_set_voltage(tpd-&gt;reg, 2800000, 2800000);</p> 
<p>这个是设置TP 的工作电压，这个代码看起来是后面加的，正常是把这个配置放DTS文件就好了，不会直接放到驱动初始化。</p> 
<p> </p> 
<p>再来看驱动真正的注册I2C 驱动，因为大部分TP 设备都是挂着I2C 总线上面，所以驱动里面都是注册I2C驱动</p> 
<p>i2c_add_driver(&amp;tpd_i2c_driver)</p> 
<p> </p> 
<p>i2c_add_driver 是一个宏定义在i2c.h中，其真正的实现在根据平台需要自己的实现中，有兴趣的可以再继续深入研究。</p> 
<p> </p> 
<p>我们来关注tpd_i2c_driver 本身这个结构体的情况：</p> 
<p> </p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> </td><td> <p><code>static</code> <code>struct i2c_driver tpd_i2c_driver = {<!-- --></code></p> <p><code>        </code><code>.driver = {<!-- --></code></p> <p><code>                </code><code>.name = </code><code>"gt9xx"</code><code>,</code></p> <p><code>#ifdef CONFIG_OF</code></p> <p><code>                </code><code>.of_match_table = of_match_ptr(gt9xx_dt_match),</code></p> <p><code>#endif</code></p> <p><code>                </code><code>},</code></p> <p><code>        </code><code>.probe = tpd_i2c_probe,</code></p> <p><code>        </code><code>.remove = tpd_i2c_remove,</code></p> <p><code>        </code><code>.detect = tpd_i2c_detect,</code></p> <p><code>        </code><code>.id_table = tpd_i2c_id,</code></p> <p><code>        </code><code>.address_list = (</code><code>const</code> <code>unsigned </code><code>short</code> <code>*) forces,</code></p> <p><code>};</code></p> </td></tr></tbody></table> 
<p>注意，这个是i2c driver，跟上面讲解的tpd devce driver不是同一个！</p> 
<p>这个结构体里面name同样是用来匹配设备的，另外还有一个of_match_table是用来匹配dts数据信息的</p> 
<p>tpd_i2c_probe 是这个tpd i2c 真正的初始化函数，tpd_i2c_detect主要写入tpd驱动的类型。</p> 
<p> </p> 
<p>static const struct i2c_device_id tpd_i2c_id[] = {<!-- -->{"gt9xx", 0}, {} };</p> 
<p>id_table 是用来列出支持这个驱动的设备列表，与name的意义相似。</p> 
<p> </p> 
<p>接下来我们讲讲这个i2c 驱动的初始化：tpd_i2c_probe</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> <p>57</p> <p>58</p> <p>59</p> <p>60</p> <p>61</p> <p>62</p> <p>63</p> <p>64</p> <p>65</p> <p>66</p> <p>67</p> <p>68</p> <p>69</p> <p>70</p> <p>71</p> <p>72</p> <p>73</p> <p>74</p> <p>75</p> <p>76</p> <p>77</p> <p>78</p> <p>79</p> <p>80</p> <p>81</p> <p>82</p> <p>83</p> <p>84</p> <p>85</p> <p>86</p> <p>87</p> <p>88</p> <p>89</p> <p>90</p> <p>91</p> <p>92</p> <p>93</p> <p>94</p> <p>95</p> <p>96</p> <p>97</p> <p>98</p> <p>99</p> <p>100</p> <p>101</p> <p>102</p> <p>103</p> <p>104</p> <p>105</p> <p>106</p> <p>107</p> <p>108</p> <p>109</p> <p>110</p> </td><td> <p><code>static</code> <code>s32 tpd_i2c_probe(struct i2c_client *client, </code><code>const</code> <code>struct i2c_device_id *id)</code></p> <p><code>{<!-- --></code></p> <p><code>                </code><code>u16 version_info;</code></p> <p><code>#ifdef CONFIG_GTP_HAVE_TOUCH_KEY</code></p> <p><code>                </code><code>s32 idx = </code><code>0</code><code>;</code></p> <p><code>#endif</code></p> <p><code>                </code><code>s32 err = </code><code>0</code><code>;</code></p> <p><code>                </code><code>s32 ret = </code><code>0</code><code>;</code></p> <p><code>#ifdef CONFIG_GTP_PROXIMITY</code></p> <p><code>                </code><code>struct hwmsen_object obj_ps;</code></p> <p><code>#endif</code></p> <p> </p> <p><code>        </code><code>if</code><code>( (KERNEL_POWER_OFF_CHARGING_BOOT == get_boot_mode() ) || ( LOW_POWER_OFF_CHARGING_BOOT == get_boot_mode() )  )</code></p> <p><code>        </code><code>{<!-- --></code></p> <p><code>            </code><code>goto</code> <code>out;</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p> </p> <p><code>        </code><code>i2c_client_point = client;</code></p> <p><code>        </code><code>ret = tpd_power_on(client);</code></p> <p><code>        </code><code>if</code> <code>(ret &lt; </code><code>0</code><code>) {<!-- --></code></p> <p><code>                </code><code>GTP_ERROR(</code><code>"I2C communication ERROR!"</code><code>);</code></p> <p><code>                </code><code>goto</code> <code>out;</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p><code>        </code><code>ret = gtp_read_version(client, &amp;version_info);</code></p> <p><code>        </code><code>if</code> <code>(ret &lt; </code><code>0</code><code>) {<!-- --></code></p> <p><code>                </code><code>GTP_ERROR(</code><code>"Read version failed."</code><code>);</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p><code>        </code><code>ret = gtp_init_panel(client);</code></p> <p><code>        </code><code>if</code> <code>(ret &lt; </code><code>0</code><code>) {<!-- --></code></p> <p><code>                </code><code>GTP_ERROR(</code><code>"GTP init panel failed."</code><code>);</code></p> <p><code>                </code><code>goto</code> <code>out;</code></p> <p><code>        </code><code>}</code></p> <p><code>        </code><code>GTP_DEBUG(</code><code>"gtp_init_panel success"</code><code>);</code></p> <p><code>        </code><code>/* Create proc file system */</code></p> <p><code>        </code><code>gt91xx_config_proc = proc_create(GT91XX_CONFIG_PROC_FILE, </code><code>0660</code><code>, NULL, &gt;_upgrade_proc_fops);</code></p> <p><code>        </code><code>if</code> <code>(gt91xx_config_proc == NULL) {<!-- --></code></p> <p><code>                </code><code>GTP_ERROR(</code><code>"create_proc_entry %s failed"</code><code>, GT91XX_CONFIG_PROC_FILE);</code></p> <p><code>                </code><code>goto</code> <code>out;</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_CREATE_WR_NODE</code></p> <p><code>        </code><code>init_wr_node(client);</code></p> <p><code>#endif</code></p> <p> </p> <p><code>        </code><code>thread = kthread_run(touch_event_handler, </code><code>0</code><code>, TPD_DEVICE);</code></p> <p><code>        </code><code>if</code> <code>(IS_ERR(thread)) {<!-- --></code></p> <p><code>                </code><code>err = PTR_ERR(thread);</code></p> <p><code>                </code><code>GTP_ERROR(TPD_DEVICE </code><code>" failed to create kernel thread: %d"</code><code>, err);</code></p> <p><code>                </code><code>goto</code> <code>out;</code></p> <p><code>        </code><code>}</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_HAVE_TOUCH_KEY</code></p> <p><code>        </code><code>for</code> <code>(idx = </code><code>0</code><code>; idx &lt; GTP_MAX_KEY_NUM; idx++)</code></p> <p><code>                </code><code>input_set_capability(tpd-&gt;dev, EV_KEY, touch_key_array[idx]);</code></p> <p> </p> <p><code>#endif</code></p> <p><code>#ifdef CONFIG_GTP_WITH_HOVER</code></p> <p><code>    </code><code>gtp_pen_init();</code></p> <p><code>#endif</code></p> <p><code>#ifdef CONFIG_GTP_GESTURE_WAKEUP</code></p> <p><code>        </code><code>gtp_extents_init();</code></p> <p><code>        </code><code>input_set_capability(tpd-&gt;dev, EV_KEY, KEY_F2);</code></p> <p><code>        </code><code>input_set_capability(tpd-&gt;dev, EV_KEY, KEY_F3);</code></p> <p><code>#endif</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_WITH_PEN</code></p> <p><code>        </code><code>/* pen support */</code></p> <p><code>        </code><code>__set_bit(BTN_TOOL_PEN, tpd-&gt;dev-&gt;keybit);</code></p> <p><code>        </code><code>__set_bit(INPUT_PROP_DIRECT, tpd-&gt;dev-&gt;propbit);</code></p> <p><code>#endif</code></p> <p> </p> <p><code>        </code><code>msleep(</code><code>50</code><code>);</code></p> <p><code>        </code><code>tpd_irq_registration();</code></p> <p><code>        </code><code>/*gtp_irq_enable();*/</code></p> <p><code>        </code><code>//enable_irq(touch_irq);</code></p> <p><code>    </code><code>msleep(</code><code>50</code><code>);</code></p> <p> </p> <p> </p> <p><code>#ifdef CONFIG_GTP_ESD_PROTECT</code></p> <p><code>        </code><code>gtp_esd_switch(client, SWITCH_ON);</code></p> <p><code>#endif</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_AUTO_UPDATE</code></p> <p><code>        </code><code>ret = gup_init_update_proc(client);</code></p> <p><code>        </code><code>if</code> <code>(ret &lt; </code><code>0</code><code>)</code></p> <p><code>        </code><code>{<!-- --></code></p> <p><code>                </code><code>GTP_ERROR(</code><code>"Create update thread error."</code><code>);</code></p> <p><code>        </code><code>}</code></p> <p><code>#endif</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_PROXIMITY</code></p> <p><code>        </code><code>/* obj_ps.self = cm3623_obj; */</code></p> <p><code>        </code><code>obj_ps.polling = </code><code>0</code><code>;                              </code><code>/* 0--interrupt mode;1--polling mode; */</code></p> <p><code>        </code><code>obj_ps.sensor_operate = tpd_ps_operate;</code></p> <p> </p> <p><code>        </code><code>err = hwmsen_attach(ID_PROXIMITY, &amp;obj_ps);</code></p> <p><code>        </code><code>if</code> <code>(err)</code></p> <p><code>                </code><code>GTP_ERROR(</code><code>"hwmsen attach fail, return:%d."</code><code>, err);</code></p> <p><code>#endif</code></p> <p> </p> <p><code>        </code><code>tpd_load_status = </code><code>1</code><code>;</code></p> <p><code>        </code><code>GTP_INFO(</code><code>"%s, success run Done"</code><code>, __func__);</code></p> <p><code>        </code><code>return</code> <code>0</code><code>;</code></p> <p><code>out:</code></p> <p><code>        </code><code>//gtp_free_gpio_res();</code></p> <p><code>        </code><code>return</code> <code>-</code><code>1</code><code>;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> </p> 
<p>首先我们看到 宏CONFIG_GTP_PROXIMITY ，这个宏意思就是这个TP是否支持距离传感功能，如果支持这个功能，就会在后面通过hwmsen_attach(ID_PROXIMITY, &amp;obj_ps)来注册一个</p> 
<p>ID 为ID_PROXIMITY 的sensor到MTK 设备驱动中，但大部分情况下，我们是用的额外的psensor，这里暂时不做这个psensor研究。</p> 
<p> </p> 
<p>接下来我们看到tpd_power_on 给tp IC上电的流程：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> </td><td> <p><code>static</code> <code>int</code> <code>tpd_power_on(struct i2c_client *client)</code></p> <p><code>{<!-- --></code></p> <p><code>                </code><code>int</code> <code>ret = </code><code>0</code><code>;</code></p> <p><code>                </code><code>int</code> <code>reset_count = </code><code>0</code><code>;</code></p> <p> </p> <p><code>reset_proc:</code></p> <p><code>        </code><code>gtp_gpio_output(GTP_IRQ_GPIO, </code><code>0</code><code>);</code></p> <p><code>        </code><code>gtp_gpio_output(GTP_RST_GPIO, </code><code>0</code><code>);</code></p> <p><code>        </code><code>msleep(</code><code>20</code><code>);</code></p> <p> </p> <p><code>        </code><code>/* power on, need confirm with SA */</code></p> <p><code>        </code><code>GTP_INFO(</code><code>"turn on power reg-vgp\n"</code><code>);</code></p> <p><code>    </code><code>#</code><code>if</code> <code>1</code></p> <p><code>        </code><code>ret = regulator_enable(tpd-&gt;reg);</code></p> <p><code>        </code><code>if</code> <code>(ret != </code><code>0</code><code>)</code></p> <p><code>                </code><code>TPD_DMESG(</code><code>"Failed to enable reg-vgp6: %d\n"</code><code>, ret);</code></p> <p><code>    </code><code>#endif</code></p> <p><code>    </code><code>... ...  </code><code>//省略后续部分</code></p> </td></tr></tbody></table> 
<p> </p> 
<p>这个函数就是对一些GPIO进行操作，比如复位GPIO，使能IRQ的GPIO，同时使能一些regulator来打开电流。</p> 
<p> </p> 
<p>gtp_init_panel 这个 真正的初始化TP IC 的，这个函数的主要就是对TP的一些寄存器进行设置操作，这部分主要由TP FAE来提供，在没有规格书的情况下是无法进行修改的。</p> 
<p> </p> 
<p>创建一个内核线程：</p> 
<p>thread = kthread_run(touch_event_handler, 0, TPD_DEVICE);</p> 
<p>这名为TPD_DEVICE线程thread是为了处理中断传来的数据，</p> 
<p>需要注意的是，判断thread是否有效需要用IS_ERR()来判断，而不是简单的使用(thread == NULL)判断。</p> 
<p> </p> 
<p>我们看看这个线程的真正实现：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> <p>57</p> <p>58</p> <p>59</p> <p>60</p> <p>61</p> <p>62</p> <p>63</p> <p>64</p> <p>65</p> <p>66</p> <p>67</p> <p>68</p> <p>69</p> <p>70</p> <p>71</p> <p>72</p> <p>73</p> <p>74</p> <p>75</p> <p>76</p> <p>77</p> <p>78</p> <p>79</p> <p>80</p> <p>81</p> <p>82</p> <p>83</p> <p>84</p> <p>85</p> <p>86</p> <p>87</p> <p>88</p> <p>89</p> <p>90</p> <p>91</p> <p>92</p> <p>93</p> <p>94</p> <p>95</p> <p>96</p> <p>97</p> <p>98</p> <p>99</p> <p>100</p> <p>101</p> <p>102</p> <p>103</p> <p>104</p> <p>105</p> <p>106</p> <p>107</p> <p>108</p> <p>109</p> <p>110</p> <p>111</p> <p>112</p> <p>113</p> <p>114</p> <p>115</p> <p>116</p> <p>117</p> <p>118</p> <p>119</p> <p>120</p> <p>121</p> <p>122</p> <p>123</p> <p>124</p> <p>125</p> <p>126</p> <p>127</p> <p>128</p> <p>129</p> <p>130</p> <p>131</p> <p>132</p> <p>133</p> <p>134</p> <p>135</p> <p>136</p> </td><td> <p><code>static</code> <code>int</code> <code>touch_event_handler(</code><code>void</code> <code>*unused)</code></p> <p><code>{<!-- --></code></p> <p><code>                </code><code>struct sched_param param = { .sched_priority = </code><code>4</code> <code>};</code></p> <p><code>                </code><code>u8      end_cmd[</code><code>3</code><code>] = {GTP_READ_COOR_ADDR &gt;&gt; </code><code>8</code><code>, GTP_READ_COOR_ADDR &amp; </code><code>0xFF</code><code>, </code><code>0</code><code>};</code></p> <p><code>                </code><code>u8      point_data[</code><code>2</code> <code>+ </code><code>1</code> <code>+ </code><code>8</code> <code>* GTP_MAX_TOUCH + </code><code>1</code><code>] = {<!-- --></code></p> <p><code>                        </code><code>GTP_READ_COOR_ADDR &gt;&gt; </code><code>8</code><code>, GTP_READ_COOR_ADDR &amp; </code><code>0xFF</code><code>};</code></p> <p><code>                </code><code>u8      touch_num = </code><code>0</code><code>, finger = </code><code>0</code><code>, key_value = </code><code>0</code><code>, *coor_data = NULL;</code></p> <p><code>                </code><code>static</code> <code>u8 pre_touch, pre_key;</code></p> <p><code>#ifdef CONFIG_GTP_WITH_PEN</code></p> <p><code>                </code><code>static</code> <code>u8 pre_pen;</code></p> <p><code>#endif</code></p> <p><code>                </code><code>s32 input_x = </code><code>0</code><code>, input_y = </code><code>0</code><code>, input_w = </code><code>0</code><code>;</code></p> <p><code>                </code><code>s32 id = </code><code>0</code><code>, i = </code><code>0</code><code>, ret = -</code><code>1</code><code>;</code></p> <p><code>#ifdef CONFIG_GTP_WITH_HOVER</code></p> <p><code>                </code><code>u8 pen_active = </code><code>0</code><code>;</code></p> <p><code>                </code><code>static</code> <code>u8 pre_pen = </code><code>0</code><code>;</code></p> <p><code>#endif</code></p> <p><code>              </code><code>u8 pre_finger = </code><code>0</code><code>;</code></p> <p><code>                </code><code>u8 dev_active = </code><code>0</code><code>;</code></p> <p><code>#ifdef CONFIG_HOTKNOT_BLOCK_RW</code></p> <p><code>                </code><code>u8 hn_state_buf[</code><code>10</code><code>] = {(u8)(GTP_REG_HN_STATE &gt;&gt; </code><code>8</code><code>),</code></p> <p><code>                                </code><code>(u8)(GTP_REG_HN_STATE &amp; </code><code>0xFF</code><code>), </code><code>0</code><code>};</code></p> <p><code>                </code><code>u8 hn_pxy_state = </code><code>0</code><code>, hn_pxy_state_bak = </code><code>0</code><code>;</code></p> <p><code>                </code><code>u8 hn_paired_cnt = </code><code>0</code><code>;</code></p> <p><code>#endif</code></p> <p> </p> <p><code>        </code><code>sched_setscheduler(current, SCHED_RR, ¶m);</code></p> <p><code>        </code><code>do</code> <code>{<!-- --></code></p> <p><code>                </code><code>set_current_state(TASK_INTERRUPTIBLE);</code></p> <p><code>                </code><code>if</code> <code>(tpd_eint_mode) {<!-- --></code></p> <p><code>                        </code><code>wait_event_interruptible(waiter, tpd_flag != </code><code>0</code><code>);</code></p> <p><code>                        </code><code>tpd_flag = </code><code>0</code><code>;</code></p> <p><code>                        </code><code>msleep(</code><code>1</code><code>);  </code><code>//Neostra huangjialong 170823</code></p> <p><code>                </code><code>} </code><code>else</code> <code>{<!-- --></code></p> <p><code>                        </code><code>msleep(tpd_polling_time);</code></p> <p><code>                </code><code>}</code></p> <p> </p> <p><code>                </code><code>set_current_state(TASK_RUNNING);</code></p> <p><code>                </code><code>mutex_lock(&amp;i2c_access);</code></p> <p><code>        </code><code>//      gtp_irq_disable();</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_GESTURE_WAKEUP</code></p> <p><code>                </code><code>if</code> <code>(gesture_data.enabled) {<!-- --></code></p> <p><code>                        </code><code>ret = gesture_event_handler(tpd-&gt;dev);</code></p> <p><code>                        </code><code>if</code> <code>(ret &gt; </code><code>0</code><code>) { </code><code>/* event handled */</code>                                <code>mutex_unlock(&amp;i2c_access);</code></p> <p><code>                                </code><code>continue</code><code>;</code></p> <p><code>                        </code><code>}</code></p> <p><code>                </code><code>}</code></p> <p><code>#endif</code></p> <p> </p> <p><code>                </code><code>if</code> <code>(tpd_halt || gtp_resetting || gtp_loading_fw) {<!-- --></code></p> <p><code>                        </code><code>GTP_DEBUG(</code><code>"Interrupt exit,halt:%d,reset:%d,ld_fw:%d"</code><code>,</code></p> <p><code>                                </code><code>tpd_halt, gtp_resetting, gtp_loading_fw);</code></p> <p><code>                        </code><code>goto</code> <code>exit_unlock;</code></p> <p><code>                </code><code>}</code></p> <p> </p> <p><code>                </code><code>ret = gtp_i2c_read(i2c_client_point, point_data, </code><code>12</code><code>);</code></p> <p><code>                </code><code>if</code> <code>(ret &lt; </code><code>0</code><code>) {<!-- --></code></p> <p><code>                                </code><code>GTP_ERROR(</code><code>"I2C transfer error. errno:%d\n "</code><code>, ret);</code></p> <p><code>                                </code><code>goto</code> <code>exit_unlock;</code></p> <p><code>                </code><code>}</code></p> <p><code>                </code><code>finger = point_data[GTP_ADDR_LENGTH];</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_COMPATIBLE_MODE</code></p> <p><code>                </code><code>if</code> <code>((finger == </code><code>0x00</code><code>) &amp;&amp; (CHIP_TYPE_GT9F == gtp_chip_type)) {<!-- --></code></p> <p><code>                        </code><code>u8 rqst_data[</code><code>3</code><code>] = {(u8)(GTP_REG_RQST &gt;&gt; </code><code>8</code><code>),</code></p> <p><code>                                                        </code><code>(u8)(GTP_REG_RQST &amp; </code><code>0xFF</code><code>), </code><code>0</code><code>};</code></p> <p> </p> <p><code>                        </code><code>ret = gtp_i2c_read(i2c_client_point, rqst_data, </code><code>3</code><code>);</code></p> <p><code>                        </code><code>if</code> <code>(ret &lt; </code><code>0</code><code>) {<!-- --></code></p> <p><code>                                </code><code>GTP_ERROR(</code><code>"I2C transfer error. errno:%d\n "</code><code>, ret);</code></p> <p><code>                                </code><code>goto</code> <code>exit_unlock;</code></p> <p><code>                        </code><code>}</code></p> <p> </p> <p><code>                        </code><code>switch</code> <code>(rqst_data[</code><code>2</code><code>]&amp;</code><code>0x0F</code><code>) {<!-- --></code></p> <p><code>                        </code><code>case</code> <code>GTP_RQST_BAK_REF:</code></p> <p><code>                                </code><code>GTP_INFO(</code><code>"Request Ref."</code><code>);</code></p> <p><code>                                </code><code>ret = gtp_bak_ref_proc(i2c_client_point, GTP_BAK_REF_SEND);</code></p> <p><code>                                </code><code>if</code> <code>(SUCCESS == ret) {<!-- --></code></p> <p><code>                                        </code><code>GTP_INFO(</code><code>"Send ref success."</code><code>);</code></p> <p><code>                                        </code><code>rqst_data[</code><code>2</code><code>] = GTP_RQST_RESPONDED;</code></p> <p><code>                                        </code><code>gtp_i2c_write(i2c_client_point, rqst_data, </code><code>3</code><code>);</code></p> <p><code>                                </code><code>}</code></p> <p><code>                                </code><code>goto</code> <code>exit_work_func;</code></p> <p><code>                        </code><code>case</code> <code>GTP_RQST_CONFIG:</code></p> <p><code>                                </code><code>GTP_INFO(</code><code>"Request Config."</code><code>);</code></p> <p><code>                                </code><code>ret = gtp_send_cfg(i2c_client_point);</code></p> <p><code>                                </code><code>if</code> <code>(ret &lt; </code><code>0</code><code>) {<!-- --></code></p> <p><code>                                        </code><code>GTP_ERROR(</code><code>"Send config error."</code><code>);</code></p> <p><code>                                </code><code>} </code><code>else</code> <code>{<!-- --></code></p> <p><code>                                       </code><code>GTP_INFO(</code><code>"Send config success."</code><code>);</code></p> <p><code>                                        </code><code>rqst_data[</code><code>2</code><code>] = GTP_RQST_RESPONDED;</code></p> <p><code>                                        </code><code>gtp_i2c_write(i2c_client_point, rqst_data, </code><code>3</code><code>);</code></p> <p><code>                                </code><code>}</code></p> <p><code>                                </code><code>goto</code> <code>exit_work_func;</code></p> <p><code>                        </code><code>case</code> <code>GTP_RQST_MAIN_CLOCK:</code></p> <p><code>                                </code><code>GTP_INFO(</code><code>"Request main clock."</code><code>);</code></p> <p><code>                                </code><code>rqst_processing = </code><code>1</code><code>;</code></p> <p><code>                                </code><code>ret = gtp_main_clk_proc(i2c_client_point);</code></p> <p><code>                                </code><code>if</code> <code>(SUCCESS == ret) {<!-- --></code></p> <p><code>                                        </code><code>GTP_INFO(</code><code>"Send main clk success."</code><code>);</code></p> <p><code>                                        </code><code>rqst_data[</code><code>2</code><code>] = GTP_RQST_RESPONDED;</code></p> <p><code>                                        </code><code>gtp_i2c_write(i2c_client_point, rqst_data, </code><code>3</code><code>);</code></p> <p><code>                                        </code><code>rqst_processing = </code><code>0</code><code>;</code></p> <p><code>                                </code><code>}</code></p> <p><code>                                </code><code>goto</code> <code>exit_work_func;</code></p> <p><code>                        </code><code>case</code> <code>GTP_RQST_RESET:</code></p> <p><code>                                </code><code>GTP_INFO(</code><code>"Request Reset."</code><code>);</code></p> <p><code>                                </code><code>mutex_unlock(&amp;i2c_access);</code></p> <p><code>                                </code><code>gtp_recovery_reset(i2c_client_point);</code></p> <p><code>                                </code><code>goto</code> <code>exit_work_func;</code></p> <p><code>                        </code><code>default</code><code>:</code></p> <p><code>                                </code><code>break</code><code>;</code></p> <p><code>                        </code><code>}</code></p> <p><code>                </code><code>}</code></p> <p><code>#endif</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_HOTKNOT</code></p> <p><code>                </code><code>if</code> <code>(finger == </code><code>0x00</code> <code>&amp;&amp; gtp_hotknot_enabled) {<!-- --></code></p> <p><code>                        </code><code>u8 rqst_data[</code><code>3</code><code>] = {(u8)(GTP_REG_RQST &gt;&gt; </code><code>8</code><code>),</code></p> <p><code>                                                                </code><code>(u8)(GTP_REG_RQST &amp; </code><code>0xFF</code><code>), </code><code>0</code><code>};</code></p> <p> </p> <p><code>                        </code><code>ret = gtp_i2c_read(i2c_client_point, rqst_data, </code><code>3</code><code>);</code></p> <p><code>                        </code><code>if</code> <code>(ret &lt; </code><code>0</code><code>) {<!-- --></code></p> <p><code>                                </code><code>GTP_ERROR(</code><code>"I2C transfer error. errno:%d\n "</code><code>, ret);</code></p> <p><code>                                </code><code>goto</code> <code>exit_unlock;</code></p> <p><code>                        </code><code>}</code></p> <p> </p> <p><code>                        </code><code>if</code> <code>((rqst_data[</code><code>2</code><code>] &amp; </code><code>0x0F</code><code>) == GTP_RQST_HOTKNOT_CODE) {<!-- --></code></p> <p><code>                                </code><code>GTP_INFO(</code><code>"Request HotKnot Code."</code><code>);</code></p> <p><code>                                </code><code>gup_load_hotknot_fw();</code></p> <p><code>                                </code><code>goto</code> <code>exit_unlock;</code></p> <p><code>                        </code><code>}</code></p> <p><code>                </code><code>}</code></p> <p><code>#endif</code></p> <p><code>... ...</code></p> </td></tr></tbody></table> 
<p> </p> 
<p>这个函数非常长，它的主要功能就是当中断发生时，读取坐标、上报坐标、手势识别、按键等等信息。</p> 
<p> </p> 
<p> </p> 
<p>再关注probe函数里面的 tpd_irq_registration 中断注册函数</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> </td><td> <p><code>static</code> <code>int</code> <code>tpd_irq_registration(</code><code>void</code><code>)</code></p> <p><code>{<!-- --></code></p> <p><code>        </code><code>struct device_node *node = NULL;</code></p> <p><code>        </code><code>unsigned </code><code>long</code> <code>irqf_val = </code><code>0</code><code>;</code></p> <p><code>        </code><code>int</code> <code>ret = </code><code>0</code><code>;</code></p> <p> </p> <p><code>        </code><code>tpd_gpio_as_int(GTP_INT_PORT);</code></p> <p><code>        </code><code>msleep(</code><code>50</code><code>);</code></p> <p><code>        </code><code>//node = of_find_compatible_node(NULL, NULL, "mediatek,cap_touch");</code></p> <p><code>        </code><code>node = of_find_matching_node(node, touch_of_match);</code></p> <p><code>        </code><code>if</code> <code>(node) {<!-- --></code></p> <p><code>                </code><code>/*touch_irq = gpio_to_irq(tpd_int_gpio);*/</code></p> <p><code>                </code><code>touch_irq = irq_of_parse_and_map(node, </code><code>0</code><code>);</code></p> <p> </p> <p><code>                </code><code>irqf_val = !int_type ? IRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;</code></p> <p> </p> <p><code>                </code><code>ret = request_irq(touch_irq, tpd_interrupt_handler,</code></p> <p><code>                                </code><code>IRQF_TRIGGER_FALLING, </code><code>"TOUCH_PANEL-eint"</code><code>, NULL);</code></p> <p> </p> <p><code>                </code><code>if</code> <code>(ret &lt; </code><code>0</code><code>)</code></p> <p><code>                        </code><code>GTP_ERROR(</code><code>"tpd request_irq IRQ LINE NOT AVAILABLE!."</code><code>);</code></p> <p><code>        </code><code>} </code><code>else</code> <code>{<!-- --></code></p> <p><code>                </code><code>GTP_ERROR(</code><code>"[%s] tpd request_irq can not find touch eint device node!."</code><code>, __func__);</code></p> <p><code>        </code><code>}</code></p> <p><code>        </code><code>return</code> <code>ret;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> </p> 
<p>这中断的就是TP 工作时，中断的处理，它的处理函数为：</p> 
<p>tpd_interrupt_handler</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>static</code> <code>irqreturn_t tpd_interrupt_handler(</code><code>int</code> <code>irq, </code><code>void</code> <code>*dev_id)</code></p> <p><code>{<!-- --></code></p> <p><code>        </code><code>TPD_DEBUG_PRINT_INT;</code></p> <p><code>        </code><code>tpd_flag = </code><code>1</code><code>;</code></p> <p><code>        </code><code>wake_up_interruptible(&amp;waiter);</code></p> <p><code>        </code><code>return</code> <code>IRQ_HANDLED;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p> </p> 
<p>这个中断处理函数是通过一个 waiter 来处理的，它是一个wait 工作队列</p> 
<p>static DECLARE_WAIT_QUEUE_HEAD(waiter);</p> 
<p> </p> 
<p>TP 固件自动升级函数：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> </td><td> <p><code>u8 gup_init_update_proc(struct i2c_client *client)</code></p> <p><code>{<!-- --></code></p> <p><code>                </code><code>struct task_struct *thread = NULL;</code></p> <p> </p> <p><code>                </code><code>GTP_INFO(</code><code>"Ready to run auto update thread"</code><code>);</code></p> <p> </p> <p><code>#ifdef CONFIG_GTP_COMPATIBLE_MODE</code></p> <p><code>                </code><code>if</code> <code>(CHIP_TYPE_GT9F == gtp_chip_type)</code></p> <p><code>                        </code><code>thread = kthread_run(gup_update_proc, </code><code>"update"</code><code>, </code><code>"fl_auto_update"</code><code>);</code></p> <p><code>                </code><code>else</code></p> <p><code>#endif</code></p> <p><code>                        </code><code>thread = kthread_run(gup_update_proc, (</code><code>void</code> <code>*)NULL, </code><code>"guitar_update"</code><code>);</code></p> <p> </p> <p><code>                </code><code>if</code> <code>(IS_ERR(thread)) {<!-- --></code></p> <p><code>                        </code><code>GTP_ERROR(</code><code>"Failed to create update thread.\n"</code><code>);</code></p> <p><code>                        </code><code>return</code> <code>-</code><code>1</code><code>;</code></p> <p><code>                </code><code>}</code></p> <p> </p> <p><code>                </code><code>return</code> <code>0</code><code>;</code></p> </td></tr></tbody></table> 
<p>也是通过一个thread来进行固件升级，真正的升级流程放在了gup_update_proc函数中。</p> 
<p> </p> 
<p>到这里，所有的TP 主要功能函数都讲解了，具体每个细节后续再通过其他文档补充说明。</p> 
<p> </p> 
<p>最后，我们再来关注一些其他细节情况：</p> 
<p>1、tpd_down()和tpd_up() 这两个函数通过input子系统上报坐标以及上报手指抬起的动；</p> 
<p>2、tpd_suspend()和tpd_resume() 关于休眠和唤醒的内容根据ic的特性设置。如休眠的时候需要关闭中断、配置进入休眠模式。另外唤醒的复位设置也需要关注；</p> 
<p>3、汇顶还实现了gtp_i2c_test 来测试TP设备与I2C 通信是否正常；</p> 
<p>4、GTP_MAX_TOUCH 可以限定TP 最大支持touch数量；</p> 
<p>5、gtp_reset_guitar 可用来对TP的复位，一般在待机唤醒和ESD 静电等其他容易出现异常的情况下使用。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4ad736bbad1ff0d893dd27acd7ac54b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx访问php文件 an error,Nginx访问PHP提示An error occurred.  the page you are looking for is currently unav...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7cf0a9cf3500a336d5ee7cd4a1857307/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TableView设置滚动条不显示问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>