<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA集合（容器）类知识点汇总 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA集合（容器）类知识点汇总" />
<meta property="og:description" content="汇总集合（容器）类的详细知识点 总结写在前面： Java有多种方式保存对象（应该说是对象的引用）。数组将数字与对象联系起来。保存基本类型的数据，保存数据类型明确的对象，取对象时也不需要对对象进行类型转换。它可以是多维的。数组一旦生成容量不能改变。Collection保存单一的元素，Map保存相关联的键值对，通过泛型，可以指定容器中存放的类型，这样获取元素时才不必进行类型转换，否则，获取的元素则为Object对象，需要进行强制类型转换。集合类会自动调整尺寸。容器类不能持有基本类型，但是Java的自动拆箱装箱机制会自动执行基本类型到容器中所持有的包装器类型之间的相互转换。List像数组一样建立数字索引与对象的关联，List是有序的，自动扩充尺寸。如果需要进行大量的随机访问，用ArrayList；如果经常插入或删除元素，用LinkedList。LinkedList提供了方法以支持队列的行为，并且实现了Queue接口。各种Queue和栈的行为，由LinkedList提供支持。Map是将对象与对象关联起来的键值对（key-value）设计。HashMap用来快速访问；TreeMap按照比较结果升序保存键，保持键始终处于排序状态。LinkedHashMap保持元素插入的顺序，但是通过散列提供了快速访问能力。Set不会保存重复的元素。HashSet提供最快的查询速度，TreeSet保持元素处于排序状态。LinkedHashSet以插入顺序保存元素。 借用别人的一张集合框架图 (原地址)：
点线框表示接口，实线框表示普通的类。一共只有四种容器：Map、List、Set、Queue，它们各有2-3个实现版本，常用的容器类四个：ArrayList、LinkedList、HashMap、HashSet。任意的Collection都可以生成Iterator，List可以生成ListIterator（也能生成Iterator，因为List继承自Collection）。
常用集合的元素是否有序，元素是否重复的区别：
一、泛型和类型安全的容器，添加一组元素 未使用泛型时的不安全写法：
class Apple{ public String color; } class Orange{ public int id; } ArrarList apples = new ArrayList(); for(int i = 0;i &lt; 3;i&#43;&#43;) apples.add(new Apple()); apples.add(new Orange()); for(int i = 0;i &lt; apples.size();i&#43;&#43;) Apple a = (Apple)apples.get(i);//Orange只有在遍历到的时候才会检测到 Java中如果一个类没有显式的声明继承自哪个类，那么自动继承自Object(有点万事万物皆对象的意思)。Apple和Orange是有区别的，它们除了是Object之外没有任何共性。因为ArrayList保存的是Object，因此既可以添加Apple，又可以添加Orange，无论在编译期还是运行时都不会有问题。当在使用ArrayList的get()方法来读取对象时，得到的只是Object引用，必须将其强制转型为Apple。当读取到ArrayList中的Orange对象时，试图将Orange转型为Apple就会报错。这样就很不安全了。
使用泛型时的写法：
ArrarList&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); for(int i = 0;i &lt; 3;i&#43;&#43;) apples.add(new Apple()); //apples.add(new Orange()); for(int i = 0;i &lt; apples.size();i&#43;&#43;) Apple a = apples." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/913d963ea51bb53a6d47df86e1fcb14f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-30T18:09:14+08:00" />
<meta property="article:modified_time" content="2017-10-30T18:09:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA集合（容器）类知识点汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="汇总集合容器类的详细知识点">汇总集合（容器）类的详细知识点</h3> 
<h4 id="总结写在前面">总结写在前面：</h4> 
<ol><li>Java有多种方式保存对象（应该说是对象的引用）。数组将数字与对象联系起来。保存基本类型的数据，保存数据类型明确的对象，取对象时也不需要对对象进行类型转换。它可以是多维的。数组一旦生成容量不能改变。</li><li>Collection保存单一的元素，Map保存相关联的键值对，通过泛型，可以指定容器中存放的类型，这样获取元素时才不必进行类型转换，否则，获取的元素则为Object对象，需要进行强制类型转换。集合类会自动调整尺寸。容器类不能持有基本类型，但是Java的自动拆箱装箱机制会自动执行基本类型到容器中所持有的包装器类型之间的相互转换。</li><li>List像数组一样建立数字索引与对象的关联，List是有序的，自动扩充尺寸。</li><li>如果需要进行大量的随机访问，用ArrayList；如果经常插入或删除元素，用LinkedList。</li><li>LinkedList提供了方法以支持队列的行为，并且实现了Queue接口。各种Queue和栈的行为，由LinkedList提供支持。</li><li>Map是将对象与对象关联起来的键值对（key-value）设计。HashMap用来快速访问；TreeMap按照比较结果升序保存键，保持键始终处于排序状态。LinkedHashMap保持元素插入的顺序，但是通过散列提供了快速访问能力。</li><li>Set不会保存重复的元素。HashSet提供最快的查询速度，TreeSet保持元素处于排序状态。LinkedHashSet以插入顺序保存元素。</li></ol> 
<p>借用别人的一张集合框架图 <a href="http://www.cnblogs.com/leeplogs/p/5891861.html." rel="nofollow">(原地址)</a>：</p> 
<p><img src="https://images2.imgbox.com/3f/66/FOoSEnIf_o.png" alt="这里写图片描述" title=""></p> 
<p>点线框表示接口，实线框表示普通的类。一共只有四种容器：Map、List、Set、Queue，它们各有2-3个实现版本，常用的容器类四个：ArrayList、LinkedList、HashMap、HashSet。任意的Collection都可以生成Iterator，List可以生成ListIterator（也能生成Iterator，因为List继承自Collection）。</p> 
<p>常用集合的元素是否有序，元素是否重复的区别：</p> 
<p><img src="https://images2.imgbox.com/78/48/ppQqYL6h_o.png" alt="这里写图片描述" title=""></p> 
<hr> 
<h4 id="一泛型和类型安全的容器添加一组元素">一、泛型和类型安全的容器，添加一组元素</h4> 
<p>未使用泛型时的不安全写法：</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span>{<!-- --></span>
    <span class="hljs-keyword">public</span> String color;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span>{<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;
}

ArrarList apples = <span class="hljs-keyword">new</span> ArrayList();
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++)
    apples.add(<span class="hljs-keyword">new</span> Apple());
apples.add(<span class="hljs-keyword">new</span> Orange());
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; apples.size();i++)
    Apple a = (Apple)apples.<span class="hljs-keyword">get</span>(i);<span class="hljs-comment">//Orange只有在遍历到的时候才会检测到</span></code></pre> 
<p>Java中如果一个类没有显式的声明继承自哪个类，那么自动继承自Object(有点万事万物皆对象的意思)。Apple和Orange是有区别的，它们除了是Object之外没有任何共性。因为ArrayList保存的是Object，因此既可以添加Apple，又可以添加Orange，无论在编译期还是运行时都不会有问题。当在使用ArrayList的get()方法来读取对象时，得到的只是Object引用，必须将其强制转型为Apple。当读取到ArrayList中的Orange对象时，试图将Orange转型为Apple就会报错。这样就很不安全了。</p> 
<p>使用泛型时的写法：</p> 
<pre class="prettyprint"><code class=" hljs cs">ArrarList&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++)
    apples.add(<span class="hljs-keyword">new</span> Apple());
<span class="hljs-comment">//apples.add(new Orange());</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; apples.size();i++)
    Apple a = apples.<span class="hljs-keyword">get</span>(i);
<span class="hljs-keyword">for</span>(Apple c : apples)
    System.<span class="hljs-keyword">out</span>.print(c.color);</code></pre> 
<p>通过使用泛型可以在编译期防止将错误类型的对象放置到容器中了。在将元素从List中取出来时也不需要再进行类型转换了，List知道它保存的是什么类型。</p> 
<p>添加一组元素： <br> 可以在一个Collection中添加一组元素。 <br> Arrays.asList()方法接受一个数组或是一个使用逗号分隔的元素列表，并将其转换成一个Lsit对象。 <br> Collections.addAll()方法接受一个Collection对象，以及一个数组或是一个逗号分隔的列表，并将元素添加到Collection中。</p> 
<pre class="prettyprint"><code class=" hljs cs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
    Collection&lt;Integer&gt; collection =
      <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));
    Integer[] moreInts = { <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> };
    collection.addAll(Arrays.asList(moreInts));
    Collections.addAll(collection, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>);
    Collections.addAll(collection, moreInts);
    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>);
    list.<span class="hljs-keyword">set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">99</span>);
  } </code></pre> 
<p>collection.addAll()成员方法只能接受另一个Collection对象作为参数，因此它不如Arrays.asList()方法和Collections.addAll()方法灵活，这两个方法使用的都是可变参数列表。</p> 
<hr> 
<h4 id="二collection与iterator与listiterator与foreach">二、Collection与Iterator与ListIterator与Foreach</h4> 
<p>Collection是描述所有序列容器的共性的接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了三个接口，就是Set、List、Queue。Java用迭代器而不是Collection来表示容器之间的共性，实现了Collection就意味着需要提供iterator()方法，可逐一访问Collection中每一个元素。</p> 
<h5 id="1collection">1.Collection</h5> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">E</span>&gt; {<!-- --></span>
<span class="hljs-comment">//将指定的对象从集合中移除，移除成功返回true,不成功返回false</span>
<span class="hljs-keyword">boolean</span> remove(Object o);
<span class="hljs-comment">//将指定对象添加到集合中</span>
<span class="hljs-keyword">boolean</span> add(E e);
<span class="hljs-comment">//查看该集合中是否包含指定的对象，包含返回true,不包含返回flase</span>
<span class="hljs-keyword">boolean</span> contains(Object o);
<span class="hljs-comment">//返回集合中存放的对象的个数。返回值为int</span>
<span class="hljs-keyword">int</span> size();
<span class="hljs-comment">//移除该集合中的所有对象，清空该集合</span>
<span class="hljs-keyword">void</span> clear();
<span class="hljs-comment">//返回一个包含所有对象的iterator对象，用来循环遍历</span>
Iterator&lt;E&gt; iterator();
<span class="hljs-comment">//返回一个包含所有对象的数组,类型是Object</span>
Object[] toArray();
<span class="hljs-comment">//返回一个包含所有对象的指定类型的数组</span>
 &lt;T&gt; T[] toArray(T[] a);
}</code></pre> 
<h5 id="2iterator遍历">2.Iterator遍历</h5> 
<p>迭代器是一个对象，它的工作是遍历并选择序列中的对象。Iterator只能向前移动。</p> 
<ol><li>使用iterator()方法要求容器返回一个Iterator。</li><li>使用next()获得序列中的下一个元素。</li><li>使用hasNext()检查序列中是否还有元素。</li><li>使用remove()将迭代器新近返回的元素删除。</li></ol> 
<pre class="prettyprint"><code class=" hljs livecodeserver">Iterator <span class="hljs-keyword">it</span> = collection.iterator(); 
　　<span class="hljs-keyword">while</span>(<span class="hljs-keyword">it</span>.hasNext()) {
　　　Object obj = <span class="hljs-keyword">it</span>.next(); 
　　}</code></pre> 
<h5 id="3listiterator遍历">3.ListIterator遍历</h5> 
<p>ListIterator是一个更加强大的Iterator子类型，它只能用于各种List类的访问。ListIterator可以双向移动。它还可以产生相对于迭代器在列表中指向当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素。可以通过调用listIterator()方法产生一个指向List开始出的ListIterator，还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。 <br> *省略了Pets相关代码下面的Pets.arrayList(8)为生成指定个数的宠物List集合。</p> 
<pre class="prettyprint"><code class=" hljs avrasm"> List&lt;Pet&gt; pets = Pets<span class="hljs-preprocessor">.arrayList</span>(<span class="hljs-number">8</span>)<span class="hljs-comment">;</span>
 ListIterator&lt;Pet&gt; it = pets<span class="hljs-preprocessor">.listIterator</span>()<span class="hljs-comment">;</span>
 while(it<span class="hljs-preprocessor">.hasNext</span>())
   System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.print</span>(it<span class="hljs-preprocessor">.next</span>() + <span class="hljs-string">", "</span> + it<span class="hljs-preprocessor">.nextIndex</span>() +
     <span class="hljs-string">", "</span> + it<span class="hljs-preprocessor">.previousIndex</span>() + <span class="hljs-string">"; "</span>)<span class="hljs-comment">;//Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;</span>
 while(it<span class="hljs-preprocessor">.hasPrevious</span>())
   System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.print</span>(it<span class="hljs-preprocessor">.previous</span>()<span class="hljs-preprocessor">.id</span>() + <span class="hljs-string">" "</span>)<span class="hljs-comment">;//7 6 5 4 3 2 1 0</span>
 System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(pets)<span class="hljs-comment">;//[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]</span>
 it = pets<span class="hljs-preprocessor">.listIterator</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">;//从索引3开始</span>
 while(it<span class="hljs-preprocessor">.hasNext</span>()) {
   it<span class="hljs-preprocessor">.next</span>()<span class="hljs-comment">;</span>
   it<span class="hljs-preprocessor">.set</span>(Pets<span class="hljs-preprocessor">.randomPet</span>())<span class="hljs-comment">;//替换在列表中从位置3开始向前的所有元素</span>
 }
 System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(pets)<span class="hljs-comment">;//[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau]</span></code></pre> 
<h5 id="4foreach遍历">4.foreach遍历</h5> 
<p>foreach语法主要用于遍历数组，但是它也可以应用于任何Collection对象（但是不包括各种Map）。</p> 
<pre class="prettyprint"><code class=" hljs vhdl">Collection&lt;<span class="hljs-typename">String</span>&gt; cs = <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-typename">String</span>&gt;();
Collection.addALL(cs,<span class="hljs-string">"Take the long way home"</span>.split(<span class="hljs-string">" "</span>));
<span class="hljs-keyword">for</span>(<span class="hljs-typename">String</span> s : cs)
    System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">"'"</span> + s + <span class="hljs-string">"' "</span>);</code></pre> 
<h5 id="5for循环遍历">5.for循环遍历</h5> 
<p>for（int i=0;i&lt; collection.size();i++）{…}</p> 
<hr> 
<h4 id="三list">三、List</h4> 
<p>List里存放的对象是有序的，按元素的插入顺序设置元素的索引，元素可以重复，因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所以插入删除数据速度慢。 <br> 有2中类型的List：</p> 
<ul><li>ArrayList，随机访问元素速度快，但是插入和移除元素速度慢。</li><li>LinkedList，随机访问、查询元素速度慢，增删元素速度快。</li><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</li></ul> 
<p>contains()方法用来确定某个对象是否在列表中，remove()移除对象，indexOf()返回对象的位置索引。</p> 
<h5 id="1arraylist">1、ArrayList</h5> 
<pre class="prettyprint"><code class=" hljs avrasm">List&lt;String&gt; list = new ArrayList&lt;String&gt;()<span class="hljs-comment">;</span>
    list<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"啊啊啊!"</span>)<span class="hljs-comment">;</span>
    list<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"别别别!"</span>)<span class="hljs-comment">;</span>
    list<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"吃吃吃!"</span>)<span class="hljs-comment">;</span>
    list<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"对对对"</span>)<span class="hljs-comment">;</span>
    list<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"嗯嗯嗯"</span>)<span class="hljs-comment">;</span>
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(list<span class="hljs-preprocessor">.size</span>())<span class="hljs-comment">;//5</span>
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(list<span class="hljs-preprocessor">.contains</span>(<span class="hljs-string">"abcde"</span>))<span class="hljs-comment">;//false</span>
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(list<span class="hljs-preprocessor">.remove</span>(<span class="hljs-string">"对对对"</span>))<span class="hljs-comment">;</span>
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(list<span class="hljs-preprocessor">.size</span>())<span class="hljs-comment">;//4</span></code></pre> 
<h5 id="2linkedlist">2、LinkedList</h5> 
<p>LinkedList还添加了可以使其用作栈，队列和双端队列的方法。</p> 
<pre class="prettyprint"><code class=" hljs php">LinkedList&lt;Pet&gt; pets = <span class="hljs-keyword">new</span> LinkedList&lt;Pet&gt;(Pets.arrayList(<span class="hljs-number">5</span>));
    <span class="hljs-keyword">print</span>(pets);<span class="hljs-comment">//[Rat, Manx, Cymric, Mutt, Pug]</span>
    <span class="hljs-keyword">print</span>(pets.getFirst());<span class="hljs-comment">//Rat</span>
    <span class="hljs-keyword">print</span>(pets.element());<span class="hljs-comment">//Rat</span>
    <span class="hljs-keyword">print</span>(pets.peek());<span class="hljs-comment">//Rat</span>
    <span class="hljs-keyword">print</span>(pets.remove());<span class="hljs-comment">//Rat</span>
    <span class="hljs-keyword">print</span>(pets.removeFirst());<span class="hljs-comment">//Manx</span>
    <span class="hljs-keyword">print</span>(pets.poll());<span class="hljs-comment">//Cymric</span>
    <span class="hljs-keyword">print</span>(pets);<span class="hljs-comment">//[Mutt, Pug]</span>
    pets.addFirst(<span class="hljs-keyword">new</span> Rat());
    <span class="hljs-keyword">print</span>(pets);<span class="hljs-comment">//[Rat, Mutt, Pug]</span>
    pets.offer(Pets.randomPet());
    <span class="hljs-keyword">print</span>(pets);<span class="hljs-comment">//[Rat, Mutt, Pug, Cymric]</span>
    pets.add(Pets.randomPet());
    <span class="hljs-keyword">print</span>(pets);<span class="hljs-comment">//[Rat, Mutt, Pug, Cymric, Pug]</span>
    pets.addLast(<span class="hljs-keyword">new</span> Hamster());
    <span class="hljs-keyword">print</span>(pets);<span class="hljs-comment">//[Rat, Mutt, Pug, Cymric, Pug, Hamster]</span>
    <span class="hljs-keyword">print</span>(pets.removeLast());<span class="hljs-comment">//Hamster</span></code></pre> 
<p>getFirst()与element()一样，返回列表的头，并不移除它，如果List为空，抛出NoSuchElementException。peek()方法与这两个方法唯一的差异是列表为空时返回null。 <br> removeFirst()与remove()是一样的，移除并返回列表的头，在列表为空时抛出NoSuchElementException。poll()方法与这两个方法唯一的差异是在列表为空时返回null。 <br> addFirst()与add()与addLast()相同，将某个元素插入到列表的尾部。 <br> removeLast()移除并返回列表的最后一个元素。 <br> 此外，LinkedList提供了方法以支持队列的行为，并且实现了Queue接口，稍后记录Queue。</p> 
<h5 id="3stack">3、Stack</h5> 
<p>“栈”通常是指“后进先出LIFO”的容器。最后“压入”栈的元素，最先“弹出”栈。 <br> LinkedList具有能够直接实现栈的所有功能的方法，可以直接将LinkedList作为栈使用。 <br> 写一个自己的Stack：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Stack&lt;T&gt; {
  <span class="hljs-keyword">private</span> LinkedList&lt;T&gt; storage = <span class="hljs-keyword">new</span> LinkedList&lt;T&gt;();
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(T v) { storage.addFirst(v); }<span class="hljs-comment">//把元素插入尾部</span>
  <span class="hljs-keyword">public</span> T <span class="hljs-title">peek</span>() { <span class="hljs-keyword">return</span> storage.getFirst(); }<span class="hljs-comment">//返回第一个元素，不移除它</span>
  <span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span>() { <span class="hljs-keyword">return</span> storage.removeFirst(); }<span class="hljs-comment">//移除并返回列表的第一个元素</span>
  <span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>() { <span class="hljs-keyword">return</span> storage.isEmpty(); }
  <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() { <span class="hljs-keyword">return</span> storage.toString(); }
}</code></pre> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> StackTest {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String [] args){
        Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;String&gt;();
        <span class="hljs-keyword">for</span>(String s : <span class="hljs-string">"我 在 这 里"</span>.split(<span class="hljs-string">" "</span>)){
            stack.push(s);
            System.<span class="hljs-keyword">out</span>.println(stack.toString());
        }
        <span class="hljs-keyword">while</span> (!stack.empty())
                System.<span class="hljs-keyword">out</span>.print(stack.pop() + <span class="hljs-string">"---"</span>);
        System.<span class="hljs-keyword">out</span>.println();
        System.<span class="hljs-keyword">out</span>.println(stack.toString());
    }
}
<span class="hljs-comment">//输出结果</span>
[我]
[在, 我]
[这, 在, 我]
[里, 这, 在, 我]
里---这---在---我---
[]</code></pre> 
<hr> 
<h4 id="四set">四、Set</h4> 
<p>Set不保存重复的元素。Set最常被使用的是测试归属性，可以很容易的询问某个对象是否在某个Set中。查找就成了Set最重要的操作，通常会选择一个HashSet的实现，它专门对快速查找进行的优化。</p> 
<h5 id="1hashset">1、HashSet</h5> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> SetOfInteger {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args){
        Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);
        Set&lt;Integer&gt; intset = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++)
            intset.add(rand.nextInt(<span class="hljs-number">30</span>));
        System.<span class="hljs-keyword">out</span>.println(intset);
    }
}
<span class="hljs-comment">//输出结果</span>
[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">19</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">20</span>, <span class="hljs-number">23</span>, <span class="hljs-number">22</span>, <span class="hljs-number">25</span>, <span class="hljs-number">24</span>, <span class="hljs-number">27</span>, <span class="hljs-number">26</span>, <span class="hljs-number">29</span>, <span class="hljs-number">28</span>]</code></pre> 
<p>每一个数字只有一个实例出现在结果中，输出的顺序也是没有规律的。这是因为HashSet使用了散列，以后在深入学习。TreeSet将元素存储在红-黑书数据结果中，而HashSet使用的是散列函数。LinkedList因为查询速度的原因也是用了散列。</p> 
<h5 id="2treeset">2、TreeSet</h5> 
<p>如果想对结果排序，使用TreeSet：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeSetOfInteger {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] arge){
        Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);
        SortedSet&lt;Integer&gt; intset = <span class="hljs-keyword">new</span> TreeSet&lt;Integer&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++)
            intset.add(rand.nextInt(<span class="hljs-number">30</span>));
        System.<span class="hljs-keyword">out</span>.println(intset);
    }
}
<span class="hljs-comment">//输出结果</span>
[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>]</code></pre> 
<p>TreeSet按照比较结果的升序保存对象。</p> 
<h5 id="3常用方法">3、常用方法</h5> 
<p>最常见的操作就是用contains()测试Set的归属性。</p> 
<pre class="prettyprint"><code class=" hljs bash">public class SetOperations {
  public static void main(String[] args) {
    Set&lt;String&gt; <span class="hljs-keyword">set</span>1 = new HashSet&lt;String&gt;();
    Collections.addAll(<span class="hljs-keyword">set</span>1,<span class="hljs-string">"A B C D E F G H I J K L"</span>.split(<span class="hljs-string">" "</span>));
    <span class="hljs-keyword">set</span>1.add(<span class="hljs-string">"M"</span>);
    print(<span class="hljs-keyword">set</span>1.contains(<span class="hljs-string">"H"</span>));//<span class="hljs-literal">true</span>
    print(<span class="hljs-keyword">set</span>1.contains(<span class="hljs-string">"N"</span>));//<span class="hljs-literal">false</span>
    Set&lt;String&gt; <span class="hljs-keyword">set</span>2 = new HashSet&lt;String&gt;();
    Collections.addAll(<span class="hljs-keyword">set</span>2, <span class="hljs-string">"H I J K L"</span>.split(<span class="hljs-string">" "</span>));
    print(<span class="hljs-keyword">set</span>1.containsAll(<span class="hljs-keyword">set</span>2));//<span class="hljs-literal">true</span>
    <span class="hljs-keyword">set</span>1.remove(<span class="hljs-string">"H"</span>);
    print(<span class="hljs-keyword">set</span>1);//[D, K, C, B, L, G, I, M, A, F, J, E]
    print(<span class="hljs-keyword">set</span>1.containsAll(<span class="hljs-keyword">set</span>2));//<span class="hljs-literal">false</span>
    <span class="hljs-keyword">set</span>1.removeAll(<span class="hljs-keyword">set</span>2);
    print(<span class="hljs-keyword">set</span>1);//[D, C, B, G, M, A, F, E]
    Collections.addAll(<span class="hljs-keyword">set</span>1, <span class="hljs-string">"X Y Z"</span>.split(<span class="hljs-string">" "</span>));
    print(<span class="hljs-keyword">set</span>1);//[Z, D, C, B, G, M, A, F, Y, X, E]
  }
} </code></pre> 
<hr> 
<h4 id="五map">五、Map</h4> 
<p>Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 <br> 利用Random写一个例子：</p> 
<pre class="prettyprint"><code class=" hljs xml">public class MapTest{
  public static void main(String[] args) {
    Random rand = new Random(47);
    Map<span class="hljs-tag">&lt;<span class="hljs-title">Integer,Integer</span>&gt;</span> m = new HashMap<span class="hljs-tag">&lt;<span class="hljs-title">Integer,Integer</span>&gt;</span>();
    for(int i = 0; i <span class="hljs-tag">&lt; <span class="hljs-attribute">10000</span>; <span class="hljs-attribute">i</span>++) {
      <span class="hljs-attribute">int</span> <span class="hljs-attribute">r</span> = <span class="hljs-attribute">rand.nextInt</span>(<span class="hljs-attribute">20</span>);
      <span class="hljs-attribute">Integer</span> <span class="hljs-attribute">freq</span> = <span class="hljs-attribute">m.get</span>(<span class="hljs-attribute">r</span>);
      <span class="hljs-attribute">m.put</span>(<span class="hljs-attribute">r</span>, <span class="hljs-attribute">freq</span> =<span class="hljs-value">=</span> <span class="hljs-attribute">null</span> ? <span class="hljs-attribute">1</span> <span class="hljs-attribute">:</span> <span class="hljs-attribute">freq</span> + <span class="hljs-attribute">1</span>);
    }
    <span class="hljs-attribute">System.out.println</span>(<span class="hljs-attribute">m</span>);
  }
}
//输出结果
{<!-- --><span class="hljs-attribute">0</span>=<span class="hljs-value">481,</span> <span class="hljs-attribute">1</span>=<span class="hljs-value">502,</span> <span class="hljs-attribute">2</span>=<span class="hljs-value">489,</span> <span class="hljs-attribute">3</span>=<span class="hljs-value">508,</span> <span class="hljs-attribute">4</span>=<span class="hljs-value">481,</span> <span class="hljs-attribute">5</span>=<span class="hljs-value">503,</span> <span class="hljs-attribute">6</span>=<span class="hljs-value">519,</span> <span class="hljs-attribute">7</span>=<span class="hljs-value">471,</span> <span class="hljs-attribute">8</span>=<span class="hljs-value">468,</span> <span class="hljs-attribute">9</span>=<span class="hljs-value">549,</span> <span class="hljs-attribute">10</span>=<span class="hljs-value">513,</span> <span class="hljs-attribute">11</span>=<span class="hljs-value">531,</span> <span class="hljs-attribute">12</span>=<span class="hljs-value">521,</span> <span class="hljs-attribute">13</span>=<span class="hljs-value">506,</span> <span class="hljs-attribute">14</span>=<span class="hljs-value">477,</span> <span class="hljs-attribute">15</span>=<span class="hljs-value">497,</span> <span class="hljs-attribute">17</span>=<span class="hljs-value">509,</span> <span class="hljs-attribute">16</span>=<span class="hljs-value">533,</span> <span class="hljs-attribute">19</span>=<span class="hljs-value">464,</span> <span class="hljs-attribute">18</span>=<span class="hljs-value">478}</span></span></code></pre> 
<p>如果键不在容器中，m.get(r)方法将返回null（表示该数字第一次产生）。否则，get()方法将产生于该键相关联的Integer值，这个值+1。覆盖原来的值，保存到m中。</p> 
<p>put(K key, V value) 向集合中添加指定的键值对 <br> putAll (Map&lt; ? extends K,? extends V&gt;t)把一个Map中的所有键值对添加到该集合 <br> containsKey(Object key) 如果包含该键，则返回true <br> containsValue(Object value) 如果包含该值，则返回true <br> get(Object key) 根据键,返回相应的值对象 <br> keySet() 将该集合中的所有键以Set集合形式返回 <br> values() 将该集合中所有的值以Collection形式返回 <br> remove(Object key) 如果存在指定的键，则移除该键值对，返回键所对应的值，如果不存在则返回null <br> clear() 移除Map中的所有键值对，或者说就是清空集合 <br> isEmpty() 查看Map中是否存在键值对 <br> size()查看集合中包含键值对的个数，返回int类型</p> 
<p>HashMap：是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的。在Map 中插入、删除和定位元素，HashMap是最好的选择。 <br> Hashtable ：注意Hashtable中的t是小写的，它是HashMap的线程安全版本，现在已经很少使用。它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。 <br> LinkedHashMap ：保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。 <br> TreeMap ：能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的，如果你需要得到一个有序的结果你就应该使用TreeMap。</p> 
<p>Map与数组和其它的Collection一样，可以很容易的扩展到多维，我们只需将其值设置为Map（这些Map的值可以是其它容器，甚至是其它Map）例如这样：Map&lt; Person，List &lt; Pet &gt;&gt;</p> 
<p>Map的遍历： <br> 第一种：将Map中所有的键存入到set集合中。用迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。取得的键值是没有顺序的。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">Iterator it = map<span class="hljs-preprocessor">.keySet</span>()<span class="hljs-preprocessor">.iterator</span>()<span class="hljs-comment">;//先获取map集合的所有键的set集合，keyset（）</span>
while(it<span class="hljs-preprocessor">.hasNext</span>()){
Object key = it<span class="hljs-preprocessor">.next</span>()<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(map<span class="hljs-preprocessor">.get</span>(key))<span class="hljs-comment">;</span>
}</code></pre> 
<p>第二种：Set&lt; Map.Entry&lt; K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的 Set 视图。（一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。Map.Entry表示映射关系。entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">Iterator it = map<span class="hljs-preprocessor">.entrySet</span>()<span class="hljs-preprocessor">.iterator</span>()<span class="hljs-comment">;</span>
while(it<span class="hljs-preprocessor">.hasNext</span>()){
Entry e =(Entry) it<span class="hljs-preprocessor">.next</span>()<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"键"</span>+e<span class="hljs-preprocessor">.getKey</span> () + <span class="hljs-string">"的值为"</span> + e<span class="hljs-preprocessor">.getValue</span>())<span class="hljs-comment">;</span>
}</code></pre> 
<p>推荐使用第二种方式，即entrySet()方法，效率较高。对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。</p> 
<hr> 
<h4 id="六queue">六、Queue</h4> 
<p>队列是一个典型的“先进先出FIFO”的容器，区分于Stack栈的“后进先出LIFO”。即从容器的一端放入元素，从另一端取出。与Stack的实现一样，这里又可以用到LinkedList，LinkedList提供了方法以支持队列的行为，并且实现了Queue接口。LinkedList可以用做Queue的一种实现。通过LinkedList向上转型为Queue。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printQ</span>(Queue queue) {
    <span class="hljs-keyword">while</span>(queue.peek() != <span class="hljs-keyword">null</span>)
      System.<span class="hljs-keyword">out</span>.print(queue.remove() + <span class="hljs-string">" "</span>);
    System.<span class="hljs-keyword">out</span>.println();
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();
    Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
      queue.offer(rand.nextInt(i + <span class="hljs-number">10</span>));
    printQ(queue);<span class="hljs-comment">//8 1 1 1 5 14 3 1 0 1</span>
    Queue&lt;Character&gt; qc = <span class="hljs-keyword">new</span> LinkedList&lt;Character&gt;();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : <span class="hljs-string">"Brontosaurus"</span>.toCharArray())
      qc.offer(c);
    printQ(qc);<span class="hljs-comment">//B r o n t o s a u r u s</span>
  }</code></pre> 
<p>offer()将一个元素插入到队尾。 <br> peek()和element()在不移除元素的情况下返回队头，peek()方法在队列为空时返回null，element()会抛出NoSuchElementException异常。 <br> poll()和remove()方法移除并返回队头，poll()在队列为空时返回null，remove()会抛出NoSuchElementException异常。</p> 
<p>参考博客： <br> <a href="http://www.cnblogs.com/leeplogs/p/5891861.html." rel="nofollow">JAVA集合类汇总</a> <br> <a href="http://www.cnblogs.com/LittleHann/p/3690187.html" rel="nofollow">Java集合类: Set、List、Map、Queue使用场景梳理</a> <br> <a href="http://www.cnblogs.com/azai/archive/2010/12/09/1901272.html" rel="nofollow">java中的几个集合类</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4ec32c297d75865ae35c185c4e16551/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mybatis查询sql：where语句“查询时间字段书写问题”引发的索引失效</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3a5e5b085128458c994d287f2a42a8ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JS实现html页面点击下载文件（共两种实现方法）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>