<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【笔记】Linux基础 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【笔记】Linux基础" />
<meta property="og:description" content="1.文件和目录的操作 1.1当前工作目录 1.1.1 pwd:返回当前所在目录 1.1.2 cd(change dir):改变当前工作目录 1.2绝对路径和相对路径 1.2.1 绝对路径： 从根开始的路径，沿着绝对路径，沿着目录层级一直到达所期望的路径
1.2.2 相对路径： 相对于当前工作目录的路径
. 当前目录
. . 当前目录的父目录：
cd .. ：返回到当前目录的上一层目录
./b.txt ：在当前目录下找b.txt这个文件，如果当前目录下没有这个文件就会自动new file一个
../b.txt ：在当前目录的父目录下找b.txt这个文件
1.3 操作目录和文件 1.3.1 查看 1）ls （list的缩写）&#43; 路径（缺省为当前路径）:查看目录下所有的文件
-l : 查看目录下所有的文件（不包括隐藏文件）的详细信息-al ：查看目录下所有的文件（包括隐藏文件）的详细信息 ls显示不同类型的文件会显示不同的颜色：
白色：表示普通文件 蓝色：表示目录 绿色：表示可执行文件 红色：表示压缩文件 浅蓝色：链接文件 红色闪烁：表示链接的文件有问题 黄色：表示设备文件 灰色：表示其他文件 2）cat &#43; 文本文件名：直接将文件的内容返回到终端界面（方便查看较小文件，不用每次都要进入文件）
就像这样，我在practice.txt写了一个非常简易的c&#43;&#43;代码，通过cat命令可以很方便的查看 1.3.2 增添 1）mkdir &#43; 目录:创建目录（也就是文件夹）
-p ：创建多层级目录 1.3.3 删除 1） rm [选项] [文件]：删除文件/目录
-f：硬性删除 -r：表明删除的是一个目录 -rf: 硬性删除目录 rm testfile 删除文件testfile" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3a591a276dfc289ba5dd33e43cf772c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-12T14:17:39+08:00" />
<meta property="article:modified_time" content="2023-03-12T14:17:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【笔记】Linux基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"></p> 
<h2 id="1.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C1.1%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%C2%A0">1.文件和目录的操作</h2> 
<h3 id="1.1%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95">1.1当前工作目录</h3> 
<h4 id="1.1.1%20pwd%3A%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95">1.1.1 pwd:返回当前所在目录</h4> 
<h4 id="1.1.2%20cd(change%20dir)%3A%E6%94%B9%E5%8F%98%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><br> 1.1.2 cd(change dir):改变当前工作目录</h4> 
<h3 id="1.2%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84">1.2绝对路径和相对路径</h3> 
<h4 id="1.2.1%20%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%9A">1.2.1 绝对路径：</h4> 
<p>从根开始的路径，沿着绝对路径，沿着目录层级一直到达所期望的路径</p> 
<h4 id="1.2.2%20%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%9A"><br> 1.2.2 相对路径：</h4> 
<p>相对于当前工作目录的路径<br>     <strong>. </strong>当前目录<br>     <strong>. . </strong>当前目录的父目录：<br>         cd .. ：返回到当前目录的上一层目录<br>         ./b.txt ：在当前目录下找b.txt这个文件，如果当前目录下没有这个文件就会自动new file一个<br>         ../b.txt ：在当前目录的父目录下找b.txt这个文件</p> 
<h3 id="1.3%20%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6">1.3 操作目录和文件</h3> 
<h4 id="1.3.1%20%E6%9F%A5%E7%9C%8B">1.3.1 查看</h4> 
<p>1）<strong>ls （list的缩写）+ 路径（缺省为当前路径）</strong>:查看目录下所有的文件</p> 
<ul><li> -l  :  查看目录下所有的文件（不包括隐藏文件）的详细信息</li><li>-al ：查看目录下所有的文件（包括隐藏文件）的详细信息</li></ul> 
<p>ls显示不同类型的文件会显示不同的颜色：</p> 
<blockquote> 
 <pre><strong>白色：表示普通文件
蓝色：表示目录
绿色：表示可执行文件
红色：表示压缩文件
浅蓝色：链接文件
红色闪烁：表示链接的文件有问题
黄色：表示设备文件
灰色：表示其他文件</strong></pre> 
</blockquote> 
<p>2）<strong>cat + 文本文件名</strong>：直接将文件的内容返回到终端界面（方便查看较小文件，不用每次都要进入文件）</p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/bb/ec/5jKt4e0W_o.jpg" width="1102"></p> 
<p><span style="color:#a5a5a5;">就像这样，我在practice.txt写了一个非常简易的c++代码，通过cat命令可以很方便的查看 </span></p> 
<h4 id="1.3.2%20%E5%A2%9E%E6%B7%BB">1.3.2 增添</h4> 
<p>1）<strong>mkdir + 目录</strong>:创建目录（也就是文件夹）</p> 
<ul><li>  -p ：创建多层级目录</li></ul> 
<h4 id="1.3.3%20%E5%88%A0%E9%99%A4">1.3.3 删除 </h4> 
<p>1）<strong> rm [选项] [文件]</strong>：删除文件/目录</p> 
<ul><li> -f：硬性删除   </li><li> -r：表明删除的是一个目录</li><li> -rf:  硬性删除目录</li></ul> 
<blockquote> 
 <p>rm testfile        删除文件testfile</p> 
 <p>rm -r testfile        删除目录testfile</p> 
</blockquote> 
<h4 id="1.3.4%20%E9%80%9A%E9%85%8D%E7%AC%A6">1.3.4 通配符</h4> 
<p>1）<strong>*</strong>:通配符，可指代任意多个字段<br> 2）<strong>？</strong>：只能匹配一个字符<br> 3）<strong>[abcd]</strong> : 只能匹配括号内的任意一个字符</p> 
<p>【例】<strong>rm -f file*.jpg</strong> :<br>      1）file和.jpg要求精确匹配，不匹配的不予考虑<br>      2）满足精确匹配后剩余的文件如果可以用通配符替代即为符合要求的文件<br>      3）通过其他指令对选中文件批量操作，该指令就可实现批量删除<br>   很多命令都可结合通配符使用，比如rm，ls...</p> 
<h4 id="1.3.5%20%E5%A4%8D%E5%88%B6">1.3.5 复制</h4> 
<p>1）<strong>cp + 被拷贝文件名 + 新文件名</strong>：将原来文件的内容拷贝下来并放到新建的文件中</p> 
<p>【灵活运用】——结合路径操作：cp a.py ../b.py:将a.py的内容拷贝到[父目录]新建的b.py中</p> 
<h4 id="1.3.6%20%E7%A7%BB%E5%8A%A8">1.3.6 移动</h4> 
<p><strong>mv p1 p2 :</strong><br><span style="color:#0d0016;">p1,p2可是文件名或目录名，组合不同会有不同的含义：<br> 1）mv file dict 表示将file移动到dict目录中<br> 2）mv file1 file2 表示将file1重命名为file2<br> 3）mv dict1 dict2：</span></p> 
<ul><li> 若dict2在给定路径下存在意为将dict1移动到dict2里面去（dict1变为dict2的子目录）</li><li> 若dict2在给定路径下不存在意为将dict1重命名为dict2</li></ul> 
<h4 id="1.3.7%20%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2">1.3.7 在文件中查找字符串</h4> 
<p><strong>grep + 想查找字符串 + 文本文件：</strong></p> 
<ul><li>-n : 显示行号</li><li>-A + 1，2，3... ：显示字符串所在行以及后面的1，2，3...行（A是after的意思）</li><li>-B + 1，2，3... : 显示字符串所在行以及前面的1，2，3...行（B是before的意思）</li><li>-C + 1，2，3... : 显示字符串所在行以及前后的1，2，3...行</li></ul> 
<p><img alt="" height="655" src="https://images2.imgbox.com/03/d1/AMPSuc3P_o.jpg" width="975"></p> 
<p><span style="color:#a5a5a5;">用前面用的practice.txt演示一下，这里是要查找practice.txt中cout字符串所在的行，通过不同指令会有不同的显示效果。 今后我们可以借助这种手段很方便的定位到比如运行日志中的”error“。</span></p> 
<h2 id="2.%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84">2.用户和用户组</h2> 
<h3 id="2.1root%E7%94%A8%E6%88%B7">2.1root用户</h3> 
<p>root：系统管理员，有系统中的最高权限。</p> 
<p>root用户可以为不同用户分配不同的权限，从而控制他们对系统资源的访问。</p> 
<h4 id="2.1.1%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%9A">2.1.1创建用户：</h4> 
<p><strong>useradd xxx</strong>：创建一个用户的同时会缺省创建一个与用户同名的用户组（因为一个用户一定要对应一个用户组）</p> 
<p><strong>useradd -g yyy xxx</strong>：如果不想缺省创建可以指定把xxx加入到已有的yyy组中。</p> 
<p><strong>· </strong>用户的信息储存在 /etc/passwd文件 中，你可以通过cat指令直接在终端查看该文件：</p> 
<p><img alt="" height="539" src="https://images2.imgbox.com/9a/cc/stios6jw_o.jpg" width="1200"></p> 
<p>如图所示：</p> 
<ol><li>每次你创建完一个用户后，linux会自动在/etc/passwd文件末尾添加上该条用户信息。</li><li>/etc/passwd文件每行对应一个用户的信息。 一行中的字段用":“隔开。各个字段的含义已注释在图片中。</li></ol> 
<p>home目录：用户登陆后就会进入的目录</p> 
<p>也可通过<strong> ls /home</strong>来查看用户（因为每个用户都挂接在了home目录下）</p> 
<h4 id="%E2%80%8B2.1.2%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%C2%A0"><img alt="" height="327" src="https://images2.imgbox.com/f2/b8/gcQKPUjP_o.jpg" width="1200">2.1.2设置密码 </h4> 
<p><strong>1）设置初始密码：passwd xxx</strong></p> 
<p>创建好用户后，请务必记得为它设定好密码，如果密码太过简单，Linux会提示你这是个bad password，但你可以强制设定这个密码。</p> 
<p><strong>2）修改密码 ：同样也是passwd  xxx</strong></p> 
<p>root用户有权重设任何用户的密码，普通用户若要更改密码直接输入passwd指令即可，因为普通用户只有权更改自己的密码，无权限更改他人的密码，因此不会出现歧义。</p> 
<h4 id="2.1.3%20%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7">2.1.3 删除用户</h4> 
<p><strong>userdel xxx</strong></p> 
<p><strong>2.1.4 添加用户组</strong></p> 
<p><strong>groupadd xxx</strong></p> 
<p><strong>· </strong>用户组的信息储存在/etc/group文件中，groupadd会在该文件末尾添加一行信息。</p> 
<p><strong>2.1.5 删除用户组</strong></p> 
<p><strong>groupdel xxx</strong></p> 
<p><strong>2.1.6 改变用户所属组</strong></p> 
<p><strong>usermod -g g user : </strong>把user用户添加到g组中</p> 
<p><strong>usermod -G g1  user：</strong>为用户添加附加组</p> 
<p><strong>【示例】</strong></p> 
<p>leo用户原本属于root组（注：可通过id命令来便捷的查看用户的一些基本信息）</p> 
<p><img alt="" height="85" src="https://images2.imgbox.com/a7/38/nBuEMneW_o.jpg" width="954"></p> 
<p> 现在想让leo同时还属于family组，可通过-G这个option来为leo添加附加组<img alt="" height="105" src="https://images2.imgbox.com/43/7c/2Lndj4eJ_o.jpg" width="1104"></p> 
<p> 看！leo即属于root组又属于family组了！</p> 
<h3 id="2.2%C2%A0%E7%94%A8%E6%88%B7%E9%97%B4%E5%88%87%E6%8D%A2">2.2 用户间切换</h3> 
<p><strong>su - xxx</strong></p> 
<p>- ： 表示要重新创建用户环境。如果不加 - 就会在原用户的环境（主要是环境变量）下，切换到新用户。一般来说 - 都是要加上的，当然不加上linux也可以正常执行。</p> 
<h2 id="3.%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9D%83%E9%99%90">3.文件的属性和权限</h2> 
<h3 id="3.1%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9D%83%E9%99%90%E7%9A%84%E6%A6%82%E5%BF%B5">3.1文件的属性和权限的概念</h3> 
<p>输入ls -al,查看文件的详细信息，借此了解文件的属性和权限（如图）：</p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/a6/95/UEzVR5Ok_o.jpg" width="1050"></p> 
<p>此外，我们再深入了解一下第一栏的具体含义：</p> 
<p style="text-align:center;"><img alt="" height="276" src="https://images2.imgbox.com/5a/2a/47NkJg63_o.jpg" width="142"></p> 
<p>其中：</p> 
<p>r ：读权限-》对文件：读取文件内容的权限        -》对目录：查看目录内容的权限</p> 
<p>w : 写权限  -》对文件：编辑文件的权限      -》对目录 ： 在该目录中创建和删除文件的权限</p> 
<p>x ：执行权限  -》 对文件：用户可以运行这个可执行文件   -》 对目录 ： 用户可cd进入这个目录</p> 
<h3 id="3.2%20%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9D%83%E9%99%90"><span style="color:#333333;">3.2 修改文件属性和权限</span></h3> 
<p><span style="color:#333333;">只有<strong>root</strong>用户和<strong>文件的所有者</strong>才有权限修改文件的访问权限</span></p> 
<h4 id="3.2.1%C2%A0chgrp%EF%BC%9A%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%89%80%E5%B1%9E%E7%94%A8%E6%88%B7%E7%BB%84">3.2.1 chgrp：修改文件所属用户组</h4> 
<p>如图，python这个目录原本是属于root用户组的，chgrp后属于family组了。</p> 
<p><img alt="" height="438" src="https://images2.imgbox.com/09/36/9p9Yrik2_o.jpg" width="1200"></p> 
<p> 但其实有个问题，我们进入到python目录下可以看到，虽然python目录所属用户组改变了，但它的子目录所属组还和之前一样，这在现实使用中未必符合人们的预期，因为这不过是给了个空壳子，里面的内容还是我的，给了但没完全给。</p> 
<p><img alt="" height="149" src="https://images2.imgbox.com/0a/18/4JF129by_o.jpg" width="1200"></p> 
<p> 可使用-R指令来解决这个问题：</p> 
<p><strong>-R:进行递归修改，亦即连同子目录下的所有文件，目录都更新成为这个用户组之意，常常用在修改某一目录内所有文件之情况。</strong></p> 
<p><img alt="" height="170" src="https://images2.imgbox.com/56/41/CKQlQlJL_o.jpg" width="1152"></p> 
<p> 看，我们从来没有操作过web这个目录，但通过对python的操作，web的所属组也一同发生了变化。</p> 
<h4 id="3.2.2%20chown%EF%BC%9A%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8B%A5%E6%9C%89%E8%80%85">3.2.2 chown：修改文件拥有者</h4> 
<p><img alt="" height="237" src="https://images2.imgbox.com/21/8d/OPeWQUvP_o.jpg" width="1200"></p> 
<h4 id="3.2.3chmod%20%5Bwho%5D%5Bop%5D%5Bpermission%5D%20file">3.2.3chmod [who][op][permission] file</h4> 
<p>who:表示用户类型</p> 
<ul><li>u         文件拥有者（user）</li><li>g         与拥有者同住的用户（group）</li><li>o         其他人（other）</li><li>a         所有人（all）</li></ul> 
<p></p> 
<p>op表示动作加上（+）权利还是取消（-）权利</p> 
<p>permission表示存取权限（r , w , x ）</p> 
<p>【示例】</p> 
<h2 id="%E2%80%8B"><img alt="" height="420" src="https://images2.imgbox.com/75/4d/Omk7Wqv2_o.jpg" width="961"></h2> 
<h2 id="4.%E8%BF%9B%E7%A8%8B">4.进程</h2> 
<p>运行着的某一个程序的实例就是一个进程</p> 
<p>操作系统会给每个进程都分配一个id，这个id叫 PID（Process Identification）</p> 
<h3 id="4.1%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF">4.1查看进程信息</h3> 
<h4 id="4.1.1%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4ps%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF">4.1.1通过命令<strong>ps</strong>可以查看进程信息</h4> 
<p><img alt="" height="140" src="https://images2.imgbox.com/6b/ea/gtAnBVjs_o.jpg" width="1200"></p> 
<ul><li>ps -f ：显示<strong>在当前终端运行的</strong>进程的详细信息（换言之，在另一个终端启动的进程用这个指令是看不到的）</li><li>ps -e : 显示<strong>系统中所有正在运行的</strong>进程的信息</li><li>ps -ef ：显示当前系统所有进程的详细信息</li></ul> 
<h4 id="4.1.2%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B">4.1.2父进程和子进程</h4> 
<p>Linux中，如果在一个进程A里面创建出一个新的进程B，那么进程A就叫做进程B的父进程 (parent process)，进程B叫做进程A的子进程（child process）。</p> 
<p>一个进程通常是由另外一个进程创建处理的。就比如我们现在的命令行程序：我们在shell中运行的程序（命令），都是shell进程创建的，所以shell进程就是他们的父进程。</p> 
<p>注：shell:命令解释器，互式命令行程序。 它负责解释我们输入的命令。</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/19/54/eXFGTpXy_o.jpg" width="1200"></p> 
<p>我们通过ps -f查看进程的详细信息，其中bash 就是bash shell；ppid是指父进程的id。”ps -f “ 的PPID和“-bash ”的PID一样，就说明了bash是ps的父进程。</p> 
<h4 id="4.1.3%E6%9F%A5%E6%89%BE%E5%85%B3%E5%BF%83%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%EF%BC%9A%20ps%20-ef%20%7C%20grep%20xxx">4.1.3查找关心的进程信息： ps -ef | grep xxx</h4> 
<p>前面提到过，grep可以抓取字符串，如果我们能grep另外一个命令输出的结果，就能通过查找字符串的方式查找我们关心的进程信息。</p> 
<p>" | "是管道符，能把前一个命令的结果通过管道作为下一个命令的输入。这让我们的想法得以实现。 </p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/62/3d/4rDsLcJz_o.jpg" width="1200"></p> 
<h3 id="4.2%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%89%8D%E5%8F%B0%EF%BC%8C%E5%90%8E%E5%8F%B0%E8%BD%AC%E6%8D%A2">4.2进程的前台，后台转换</h3> 
<p>Linux终端通过Shell程序来接收用户输入的命令，并且执行命令。我们在Shell里正在执行的，<strong>和用户进行人机交互的进程叫前台进程</strong>(foreground process)。</p> 
<p>前台进程可以接收键盘输入并将结果显示在显示器上。用户敲入什么命令，shell就会启动对应的程序，运行在前台 。</p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/fb/34/8K5EPKrl_o.jpg" width="1200"></p> 
<p>但换言之，<strong>前台进程会占据和用户交互的权利。</strong></p> 
<p>对于某些无需与用户交互的程序，如果还要在前台运行，那就意味着在进程结束之前，你都无法与电脑进行交互，除非另外再打开一个终端（或者按ctrl c 提前结束进程）</p> 
<p>对于这样的程序，我们可以将其切换至后台运行，这样程序既能正常运行，又不会占据与用户交互的权利。</p> 
<p>在后台运行程序可通过在指令中加上<strong> &amp; </strong>符。</p> 
<p><strong>&amp;</strong>：可将程序放置在后台运行</p> 
<h3 id="4.3%20nohup%EF%BC%9A%E4%B8%8D%E5%8F%91%E5%87%BAsighup%E2%80%94%E2%80%94%E9%98%B2%E6%AD%A2%E5%85%B3%E9%97%AD%E7%BB%88%E7%AB%AF%E5%90%8E%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F%E8%BF%90%E8%A1%8C">4.3 nohup：不发出sighup——防止关闭终端后进程结束运行</h3> 
<p>当我们关闭终端时，shell会发送SIGHHUP信号给在该终端下运行的进程，进程接收的该信号，如果没有特别的处理，<strong>缺省就会结束运行</strong>。</p> 
<p>可是有些程序我们希望它们始终保持运行的状态（比如web的服务器）</p> 
<p>这对于种情况，我们可以使用nohup指令。</p> 
<p><strong>发出在后台运行某个程序的指令时，如果这样写指令：nohup xxx &amp;，即使终端关闭，程序还会继续在系统中运行。</strong></p> 
<h3 id="4.4%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2">4.4 进程的终止</h3> 
<h4 id="4.4.1%E8%87%AA%E8%A1%8C%E7%BB%88%E6%AD%A2%EF%BC%9A">4.4.1自行终止：</h4> 
<p>一直以来我们敲的所谓命令其实都对应是一段程序的代码，因此每次执行命令都相当于运行一个程序。有些程序执行完一段任务后就会自行终止。</p> 
<h4 id="4.4.2%E5%BC%BA%E8%A1%8C%E7%BB%88%E6%AD%A2%EF%BC%9A">4.4.2强行终止：</h4> 
<ul><li>结束前台进程 ：<strong>组合键：Ctrl C</strong></li><li>结束后台进程： <strong>kill -9 + PID</strong><img alt="" height="989" src="https://images2.imgbox.com/16/50/K0uw4h7C_o.jpg" width="1200"></li></ul> 
<p> 有一种结束后台进程的方法需要掌握：</p> 
<blockquote> 
 <p><strong>ps -ef | grep t2.py </strong></p> 
 <p><strong>kill -9 + PID</strong></p> 
 <p>对于那种一直在系统后台运行的进程，很多时候我们未必能记得它的PID，因为它可能在好久以前的一次shell命令交互中就开始运行了，现在我们想关闭它，就要先查到它的PID，再kill掉它。</p> 
</blockquote> 
<p> <img alt="" height="746" src="https://images2.imgbox.com/02/61/m5DuMwdo_o.jpg" width="1200"></p> 
<h2 id="%C2%A05.%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%AE%A1%E9%81%93"> 5.重定向和管道</h2> 
<h3 id="5.1%E9%87%8D%E5%AE%9A%E5%90%91">5.1重定向</h3> 
<h4 id="5.1.1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">5.1.1基本概念</h4> 
<p>Linux进程在启动后，通常就会打开3个文件句柄:</p> 
<ul><li>标准输入文件<strong>stdin</strong>:用户输入的信息会被添加到stdin文件中，linux再从stdin中读取用户输入的信息</li><li>标准输出文件<strong>stdout：</strong>存留要输出给用户看的信息</li><li>标准错误文件<strong>stderr</strong> ：存留要输出给用户看的<strong>报错</strong>信息</li></ul> 
<p>其中，stdout、stderr 缺省输出到终端（也就是屏幕），stdin缺省由用户输入</p> 
<p><img alt="" height="693" src="https://images2.imgbox.com/24/8e/fbXsAobS_o.jpg" width="1200"></p> 
<p><strong>用户改变系统缺省的设定，指定输入输出位置就叫重定向操作</strong></p> 
<p><strong>5.1.2标准输入输出重定向</strong></p> 
<ul><li>标准输出重定向：&gt;</li></ul> 
<p><img alt="" height="394" src="https://images2.imgbox.com/5a/5b/UzD0KnEe_o.jpg" width="1200"></p> 
<ul><li>标准错误重定向：2&gt;</li></ul> 
<p><img alt="" height="445" src="https://images2.imgbox.com/83/31/LOvV8WYN_o.jpg" width="1200"></p> 
<p><img alt="" height="784" src="https://images2.imgbox.com/de/b1/yKNxgfFI_o.jpg" width="1200"></p> 
<ul><li>同时重定向标准输出和标准错误: &amp;&gt;</li><li>重定向标准输出和标准错误到不同文件：command &gt; out 2&gt;err</li><li>标准输入的重定向（相当于从文件中读取数据）：&lt;</li></ul> 
<h3 id="5.2%20%E7%AE%A1%E9%81%93%20%7C">5.2 管道 |</h3> 
<p>前面已经两次用到过管道了，所谓管道就是把前面的输出作为后面的输入</p> 
<p><img alt="" height="529" src="https://images2.imgbox.com/bd/34/fiLrP1aN_o.jpg" width="1200"></p> 
<h2 id="6.%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86">6.网络管理</h2> 
<h3 id="6.1%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3IP%E5%9C%B0%E5%9D%80">6.1查看网络接口IP地址</h3> 
<h4 id="6.1.1%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3">6.1.1网络接口</h4> 
<p>虚拟的对外进行通讯的接口，一个物理网卡可配置很多网络接口。</p> 
<h4 id="6.1.2%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%9Aip%20addr">6.1.2查看网络接口的IP地址：<strong>ip addr</strong></h4> 
<p>lo: 环回接口——用来给本机上的程序通讯</p> 
<h3 id="6.2%E5%90%AF%E7%94%A8%E3%80%81%E7%A6%81%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3"><strong>6.2启用、禁用网络接口</strong></h3> 
<p><strong>6.2.1ifup + 网络接口名：启用网络接口</strong></p> 
<p><strong>6.2.2ifdown + 网络接口名：禁用网络接口</strong></p> 
<p>【实操】</p> 
<p>在工作环境中，主机一般都是在学校的实验室或是公司的机房中的，因此我们一般都是通过获取机器的ip地址在我们的电脑上远程登陆linux的（当然学习阶段我们的Linux主机可能就是我们的虚拟机，其实也都一样）。</p> 
<p>像我现在就是在putty上远程登陆我的linux虚拟机的，下面我们来演示断开网络接口：</p> 
<p><img alt="" height="726" src="https://images2.imgbox.com/75/4a/ebTL3Hs1_o.jpg" width="1200"></p> 
<p>可见，连接立马就断了，此后在putty上，我们怎么样也都不可能重新连接上Linux了，想要再重新打开网络接口，只能回到主机的终端。</p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/82/f5/YGraCDRw_o.jpg" width="1200"></p> 
<p><img alt="" height="699" src="https://images2.imgbox.com/f1/cc/mQI3lrbU_o.jpg" width="1200"></p> 
<h3 id="6.3%E6%A3%80%E6%9F%A5%E7%BD%91%E7%BB%9C%E6%B5%81%E7%95%85%E6%80%A7%EF%BC%9Aping%2BIP%E5%9C%B0%E5%9D%80%2F%E5%9F%9F%E5%90%8D"><strong>6.3检查网络流畅性：ping+IP地址/域名</strong></h3> 
<h4 id="6.3.1%E5%8E%9F%E7%90%86"><strong>6.3.1原理</strong></h4> 
<p>本机发一个网络包（实际情况肯定是多个包）给被ping的主机，主机也会回复一个网络包，通过记录发出到接受之间的时间来检测网络流畅性</p> 
<h4 id="6.3.2%E9%80%9A%E8%BF%87%E5%9F%9F%E5%90%8D%E9%80%9A%E8%AE%AF">6.3.2通过域名通讯</h4> 
<p><img alt="" height="603" src="https://images2.imgbox.com/a7/73/3HGpDcxx_o.jpg" width="1200"></p> 
<h4 id="6.3.3%E9%80%9A%E8%BF%87ip%E5%9C%B0%E5%9D%80%E9%80%9A%E8%AE%AF">6.3.3通过ip地址通讯</h4> 
<p><img alt="" height="584" src="https://images2.imgbox.com/b4/6a/UgwPx8WW_o.jpg" width="1200"></p> 
<h3 id="6.4%20netstat%EF%BC%9A%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81">6.4 netstat：查看网络状态</h3> 
<h3 id="6.5ssh%EF%BC%9A%E5%9C%A8linux%E4%B8%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E5%8F%A6%E4%B8%80%E5%8F%B0linux%E4%B8%BB%E6%9C%BA">6.5ssh：在linux上远程登陆另一台linux主机</h3> 
<p>无论是直接在Linux主机（或虚拟机）还是远程桌面，我们已经有了一台linux主机，ssh让我们可以在linux主机上登陆另一台linux。</p> 
<p><strong>命令格式：ssh 用户名@IP地址或机器域名</strong></p> 
<p>比如：   [root@localhost ~]$ ssh user1@192.168.1.12</p> 
<p>可以建立连接的话，linux会要求你输入user1的密码，正确输入后就会进入远程登陆的主机了，你可以敲入exit退出远程登陆。</p> 
<h3 id="6.6scp%EF%BC%9A%E5%9C%A8linux%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6">6.6scp：在linux之间相互拷贝文件</h3> 
<p><strong>scp 本机文件的相对路径或绝对路径       它机用户名@ip地址或域名：它机的目录  </strong></p> 
<p><strong>                                                                                                ——  将本机文件拷贝到它机</strong></p> 
<p>比如 ：scp /home/byhy1/abc.txt byhy2@192.168.1.12:/home/byhy2</p> 
<p><strong>scp  它机用户名@ip地址或域名：它机文件的相对路径或绝对路径      本机的目录</strong></p> 
<p><strong>                                                                                                ——将它机文件拷贝到本机</strong></p> 
<p>比如 ：scp byhy2@192.168.1.12:/home/byhy2/123.txt /tmp/</p> 
<h3 id="6.7WinSCP%EF%BC%9Awindows%E5%92%8Clinux%E7%9B%B8%E4%BA%92%E6%8B%B7%E8%B4%9D">6.7WinSCP：windows和linux相互拷贝</h3> 
<p>这主要通过WinSCP软件来实现，由于有图形界面，因此非常直观且方便。</p> 
<p>下载链接：<a class="link-info" href="https://winscp.net/download/WinSCP-5.19.2-Setup.exe" rel="nofollow" title="Downloading WinSCP-5.19.2-Setup.exe :: WinSCP">Downloading WinSCP-5.19.2-Setup.exe :: WinSCP</a></p> 
<h3 id="%E2%80%8B6.8wget%EF%BC%9A%E4%BB%8E%E7%BD%91%E7%BB%9C%E4%B8%8A%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><img alt="" height="1200" src="https://images2.imgbox.com/0f/24/MkXGWLF1_o.jpg" width="1200">6.8wget：从网络上下载文件</h3> 
<p>很多时候，我们下载文件不是要登陆到另一个人的用户，把他的文件拷贝到我们的电脑，我们通常是在网络上下载的。</p> 
<p>Windows上，我们会直接使用浏览器来下载，Linux上由wget命令来实现。</p> 
<p><strong>比如：wget https://mirrors.aliyun.com/centos/timestamp.txt</strong></p> 
<p>其中，https://mirrors.aliyun.com/centos/timestamp.txt是符合http协议的连接地址</p> 
<h2>7.基于CentOS 7的其他命令操作</h2> 
<h3>7.1 启动、重启、安装服务：systemctl</h3> 
<ul><li>启动服务 ：systemctl start mysql<strong>d</strong></li><li>重启服务 ：systemctl restart mysql<strong>d</strong></li><li>查看服务 ：systemctl status mysql<strong>d</strong></li><li>关闭服务 ：systemctl stop mysql<strong>d</strong></li></ul> 
<p>mysqld是服务，mysql是客户端。mysqld其实是SQL后台程序(也就是MySQL服务器)，它是关于服务器端的一个程序，mysqld意思是mysql daemon，在后台运行，监听3306端口，如果你想要使用客户端程序，这个程序必须运行，因为客户端是通过连接服务器来访问数据库的。你只有启动了mysqld.exe，你的mysql数据库才能工作。因此我们在centos上启动的是mysqld。</p> 
<p>什么是服务？</p> 
<h3>7.2 打包和压缩</h3> 
<h4>7.2.1 打包：tar</h4> 
<p>tar可将多个文件、目录打包到一个文件中。但是并不会压缩，压缩需要额外的指令。</p> 
<ul><li>打包：<strong>tar cvf 包的名字 + 要打包的文件或目录名（可加多个）</strong></li><li>解包：<strong>tar xvf 包的名字</strong></li></ul> 
<p>【注意】所谓解包，即在当前目录下创建一份包中所有的文件或目录，而这个包本身依旧还在。</p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/88/02/vAencIpA_o.jpg" width="1200"></p> 
<ul><li>往包中添加文件或目录：<strong>tar rvf 包的名字 文件或目录的名字</strong></li><li>查看包中内容： <strong>tar tvf 包的名字</strong></li><li>同时实现压缩或解压 ：<strong> 加上z指令</strong>，如：</li></ul> 
<p>tar zcvf leo.tar.gz *.txt        打包并压缩指定文件，压缩包名为leo.tar.gz</p> 
<p>tar zxvf leo.tar.gz        解压并解包</p> 
<h4>7.2.2 压缩：gzip </h4> 
<p>gzip命令用于文件的压缩与解压缩，压缩后的文件名后缀为“.gz”</p> 
<ul><li>压缩： gzip file.txt</li><li>解压:    gzip file.txt.gz(file.txt压缩后变为了file.txt.gz)</li></ul> 
<p>【注意】：</p> 
<p>打包是复制：并不会动原内容</p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/60/af/j4ICFnaz_o.jpg" width="1200"></p> 
<p>压缩是覆盖：直接将原内容压缩变为压缩包 </p> 
<p><img alt="" height="170" src="https://images2.imgbox.com/00/fb/3HQTmdpB_o.jpg" width="1200"></p> 
<h3>7.3安装软件包</h3> 
<h4>7.3.1yum安装</h4> 
<p>YUM 是在Fedora、RedHat、SUSE、CentOS中常见的一种安装rpm软件的方式。能够从指定的 yum 源服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p> 
<p>【常见操作】</p> 
<ul><li>yum list :显示所有可安装和已经安装的包</li><li>yum list installed ：显示已经安装的包</li></ul> 
<p>即使只是显示已经安装的包，输出内容也是非常多的，真正使用最好还是要结合grep。</p> 
<ul><li>yum install package ：安装指定package包</li><li>yum remove package ： 卸载指定package包</li></ul> 
<h4>7.3.2通过源代码包编译安装</h4> 
<p>这种源代码包，通常都是放在以 tar.gz tar.bz2 为扩展名的压缩包中。源代码包里面的大都是 c语言代码文件，需要编译后才能安装。</p> 
<p>step1：wget + 网址 从网上获取源码包</p> 
<p>step2：解压包：tar zxf ...</p> 
<p>step3 : 进入解压目录，执行以下命令进行配置、编译和安装：</p> 
<pre><code>./configure ; 
make &amp;&amp; make install</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1764498ff5cbd72ff8a4c201e77a614b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PLC编程0基础入门到精通</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/446788fd7fa16949a2c789c6dc82c3f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IOS真机调试uni.scanCode调用报错，黑屏</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>