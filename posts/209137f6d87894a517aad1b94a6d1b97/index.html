<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>qmake source code 解读 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="qmake source code 解读" />
<meta property="og:description" content="qmake 主要框架流程 qmake的主要功能执行入口在main.cpp中的runQMake(int argc, char **argv)中。其主要框架流程如下:
runQMake(int argc, char **argv){ QMakeVfs vfs; //初始化qmake的文件系统。virtual file system。vfs会为每个文件赋予一个id,并提供根据id进行操作的函数。 Option::vfs = &amp;vfs; QMakeGlobals globals; Option::globals = &amp;globals; globalst提供配置查询环境参数和操作环境变量相关的一些函数。 ....... Option::init(argc, argv); //初始化参数 ..... QMakeProperty prop; //初始化property。构造函数中调用QMakeProperty 的reload函数。 .... QMakeParser parser(&amp;proFileCache, &amp;vfs, &amp;Option::evalHandler);//创建parser对象，parser的主要作用是将脚本代码转换成ProToken类型的数据，并存放到Profile对象中的m_proitems中。 Option::parser = &amp;parser; ...... QMakeProject project;//创建qmake工程，构造函数参数会使用到option::parser，并赋予成员变量其m_parser，结构中的成员最终用于辅助生成makefile //QMakeProject::QMakeProject(): QMakeEvaluator(Option::globals, Option::parser, Option::vfs, &amp;Option::evalHandler){} ....... project.read(fn) //加载和解析(词法语法语义)配置文件（.prl、pri、.conf、.prf），解析工程pro文件 ...... MetaMakefileGenerator *mkfile = MetaMakefileGenerator::createMetaGenerator(&amp;project, QString(), false, &amp;success); //创建makefile对象向，内部通过生成SubdirsMetaMakefileGenerator或BuildsMetaMakefileGenerator对象，初始化并返回。 ..... mkfile-&gt;write() //生成Makefile.Debug、Makefile.Release、Makefile三个文件。 } QMakeProject是整体的架构，他继承与QMakeEvaluator，用于描述一个qt工程，除了完成处理语法和语义分析的QMakeEvaluator的功能，还会做一些工程相关的处理（比如路径、缓存文件）。一个QMakeProject对象含有一个用于处理词法分析的QMakeParser对象成员。QMakeProject做完解析后，作为参数传入MetaMakefileGenerator对象中，生成makefile文件。
解析从QMakeProject的read函数开始，内部会调用QMakeEvaluator::evaluateFile()。开始进行词法和语法分析。
词法分析 QMakeParser对象进行语法分析。QMakeParser主要作用是将qmake language语法的代码进行标记化（tokenized），将原始代码全部解析成ProToken类型的数据，解析内容放到Profile对象的m_proItems成员中。主要操作在QMakeParser::read中，read的调用堆栈如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/209137f6d87894a517aad1b94a6d1b97/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-07T14:44:39+08:00" />
<meta property="article:modified_time" content="2022-12-07T14:44:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">qmake source code 解读</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>qmake 主要框架流程</h2> 
<p>qmake的主要功能执行入口在main.cpp中的runQMake(int argc, char **argv)中。其主要框架流程如下:</p> 
<pre><code>runQMake(int argc, char **argv){
    QMakeVfs vfs;   //初始化qmake的文件系统。virtual file system。vfs会为每个文件赋予一个id,并提供根据id进行操作的函数。
    Option::vfs = &amp;vfs;    
    QMakeGlobals globals;
    Option::globals = &amp;globals;  globalst提供配置查询环境参数和操作环境变量相关的一些函数。
    .......
    Option::init(argc, argv); //初始化参数
    .....
    QMakeProperty prop; //初始化property。构造函数中调用QMakeProperty 的reload函数。
    ....
    QMakeParser parser(&amp;proFileCache, &amp;vfs, &amp;Option::evalHandler);//创建parser对象，parser的主要作用是将脚本代码转换成ProToken类型的数据，并存放到Profile对象中的m_proitems中。
    Option::parser = &amp;parser;
    ......
    QMakeProject project;//创建qmake工程，构造函数参数会使用到option::parser，并赋予成员变量其m_parser，结构中的成员最终用于辅助生成makefile
    //QMakeProject::QMakeProject(): QMakeEvaluator(Option::globals, Option::parser, Option::vfs, &amp;Option::evalHandler){}  
    .......
    project.read(fn)  //加载和解析(词法语法语义)配置文件（.prl、pri、.conf、.prf），解析工程pro文件
    ......
    MetaMakefileGenerator *mkfile = MetaMakefileGenerator::createMetaGenerator(&amp;project,         QString(), false, &amp;success); //创建makefile对象向，内部通过生成SubdirsMetaMakefileGenerator或BuildsMetaMakefileGenerator对象，初始化并返回。
    .....
    mkfile-&gt;write() //生成Makefile.Debug、Makefile.Release、Makefile三个文件。
}</code></pre> 
<p>QMakeProject是整体的架构，他继承与QMakeEvaluator，用于描述一个qt工程，除了完成处理语法和语义分析的QMakeEvaluator的功能，还会做一些工程相关的处理（比如路径、缓存文件）。一个QMakeProject对象含有一个用于处理词法分析的QMakeParser对象成员。QMakeProject做完解析后，作为参数传入MetaMakefileGenerator对象中，生成makefile文件。</p> 
<p>解析从QMakeProject的read函数开始，内部会调用QMakeEvaluator::evaluateFile()。开始进行词法和语法分析。</p> 
<h2>词法分析</h2> 
<p>QMakeParser对象进行语法分析。QMakeParser主要作用是将qmake language语法的代码进行标记化（tokenized），将原始代码全部解析成ProToken类型的数据，解析内容放到Profile对象的m_proItems成员中。主要操作在QMakeParser::read中，read的调用堆栈如下：<br><img alt="" height="128" src="https://images2.imgbox.com/83/fb/toZLkzke_o.png" width="596"></p> 
<pre><code>//E:\workspace\QtWork\qmake\library\qmakeevaluator.cpp
evaluateFile是执行脚本文件的入口函数
QMakeEvaluator::VisitReturn QMakeEvaluator::evaluateFile(
        const QString &amp;fileName, QMakeHandler::EvalFileType type, LoadFlags flags)
{
    QMakeParser::ParseFlags pflags = QMakeParser::ParseUseCache;
    if (!(flags &amp; LoadSilent))
        pflags |= QMakeParser::ParseReportMissing;
    if (ProFile *pro = m_parser-&gt;parsedProFile(fileName, pflags)) {
        ProStringList &amp;tiif = m_valuemapStack.first()[ProKey("QMAKE_VISIT_FILES")];
        ProString tifn(fileName);
        if (!tiif.contains(tifn))
            tiif &lt;&lt; tifn;
        m_locationStack.push(m_current);
        VisitReturn ok = visitProFile(pro, type, flags);
        m_current = m_locationStack.pop();
        pro-&gt;deref();
        if (ok == ReturnTrue &amp;&amp; !(flags &amp; LoadHidden)) {
            ProStringList &amp;iif = m_valuemapStack.first()[ProKey("QMAKE_INTERNAL_INCLUDED_FILES")];
            ProString ifn(fileName);
            if (!iif.contains(ifn))
                iif &lt;&lt; ifn;
        }
        return ok;
    } else {
        debugMsgInternal(0, "failed evaluateing file %s,parse error", qPrintable(fileName));
        return ReturnFalse;
    }
}

--------------------------

parsedProFile作用是判断文件是否已经被解析，未解析会调用readFile将文件内容读取到内存中，存放到content变量中，然后调用parsedProBlock解析读取到的代码块。
ProFile *parsedProFile(const QString &amp;fileName, ParseFlags flags) 

parsedProBlock创建profile对象，对具体的代码块进行解析，然后返回profile对象
ProFile *parsedProBlock(const QStringRef &amp;contents, int id, const QString &amp;name, int line, SubGrammar grammar)
{
    ProFile *pro = new ProFile(id, name);
    read(pro, contents, line, grammar);
    return pro;
}

parsedProBlock对具体的代码块进行解析，可以是一整个文件的代码，也可以是eval中传入的小片代码。
然后返回profile对象。词法分析阶段会进行字符转义操作，和预处理操作。
void QMakeParser::read(ProFile *pro, const QStringRef &amp;in, int line, SubGrammar grammar){.....}</code></pre> 
<p>字符转义和部分特殊变量的预处理在这个阶段进行。引号是否缺乏以及括号是否缺乏会在这个阶段得出结果。</p> 
<h2>语法语义分析</h2> 
<p>对脚本文件的语法和语义分析用QMakeProject中的成员QMakeEvaluator对象进行处理，一个project对象只有一个QMakeEvaluator成员。在evaluateFile函数中，经过QMakeParser的解析出来的Profile传递给QMakeEaluator-&gt;visitprofile，开始对内容进行语法和语义分析。主要操作在visitProBlock中，调用堆栈如下。</p> 
<p> <img alt="" height="105" src="https://images2.imgbox.com/3b/32/jeFE1Zoa_o.png" width="674"></p> 
<pre><code>E:\workspace\QtWork\qmake\library\qmakeevaluator.cpp
visitProfile的作用是在处理工程文件的时候预先加载背后的配置文件，以及处理不同时态（state）的命令行命令。
同时维护一个m_profileStack栈，用于存放parsed的ProFile。
QMakeEvaluator::VisitReturn QMakeEvaluator::visitProFile(ProFile *pro, QMakeHandler::EvalFileType type, LoadFlags flags){}


这个visitProBlock调用下面的visitProBlock
QMakeEvaluator::VisitReturn QMakeEvaluator::visitProBlock(ProFile *pro, const ushort *tokPtr)
{
    m_current.pro = pro;
    m_current.line = 0;
    return visitProBlock(tokPtr);
}

这个visitProBlock是进行词法和语法分析的主要逻辑。所有变量存入到m_valuemapStack中，这是一个栈和链表的功能兼有的数据结构类型的成员。
QMakeEvaluator::VisitReturn QMakeEvaluator::visitProBlock(const ushort *tokPtr)</code></pre> 
<h3>QMakeEvaluator的几个重要数据成员</h3> 
<pre><code>typedef QHash&lt;ProKey, ProStringList&gt; ProValueMap;

class ProValueMapStack : public QLinkedList&lt;ProValueMap&gt;{}

struct ProFunctionDefs {
    QHash&lt;ProKey, ProFunctionDef&gt; testFunctions;
    QHash&lt;ProKey, ProFunctionDef&gt; replaceFunctions;
};

class QMakeEvaluator{
    QStack&lt;ProFile *&gt; m_profileStack; // Includes only
    ProValueMapStack m_valuemapStack;
    ProFunctionDefs m_functionDefs;
    QStack&lt;Location&gt; m_locationStack;
}</code></pre> 
<p>QMakeEvaluator::m_valuemapStack：是存放变量的键值的数据成员，他的类型如下，兼有链表和栈功能操作的数据结构类型的变量，元素类型为ProValueMap类型。ProValueMap是QHash&lt;ProKey, ProStringList&gt; 类型。QMakeEvaluator初始化时会往其中push一个ProValueMap对象，这个对象存放全局的变量和值键值对。<br> 一个ProValueMap中存放的是一个作用域内的所有变量和值的键值对。有子作用域时，会创建一个新的ProValueMap存放该域内的变量名和值。qmake只有两种作用于，一个是全局的，一个是函数内的。 （qmake language脚本语言的作用域与其他的语言的作用域有点差异，可以参考：<a href="https://blog.csdn.net/qiushangren/article/details/127123766" title="qmake language">qmake language</a>）<br> QMakeEvaluator初始化时创建一个ProValueMap对象，用于存放全局变量和其值的键值对；每次调用自定义函数的时候会创建一个ProValueMap对象，存放该函数内的局部变量和键值对。如果函数内有调用的嵌套，会继续为嵌套的函数创建ProValueMap对象，新创建的ProValueMap会push到m_valuemapStack中，函数调用结束后再从其中删除（相应代码逻辑在QMakeEvaluator::evaluateFunction中）。函数内访问某个变量会先从该函数的ProValueMap中查找，未找到会到m_valuemapStack的下一层中寻找，直到找到变量或者遍历完所有变量名。<br> ProKey 存放变量名，ProStringList存放变量的值（qmake language中只有字符串组的数据类型）。<br> 下面是qmake中访问一个变量的函数：</p> 
<pre><code>//E:\workspace\QtWork\qmake\library\qmakeevaluator.cpp
ProStringList QMakeEvaluator::values(const ProKey &amp;variableName) const
{
    ProValueMapStack::ConstIterator vmi = m_valuemapStack.constEnd();
    for (bool first = true; ; first = false) {
        --vmi;
        ProValueMap::ConstIterator it = (*vmi).constFind(variableName);
        if (it != (*vmi).constEnd()) {
            if (it-&gt;constBegin() == statics.fakeValue.constBegin())
                break;
            return *it;
        }
        if (vmi == m_valuemapStack.constBegin())
            break;
        if (first &amp;&amp; isFunctParam(variableName))
            break;
    }
    return ProStringList();
}
</code></pre> 
<p><br> QMakeEvaluator::m_functionDefs ：存放自定义的replace函数和test函数。<br> QStack&lt;Location&gt; m_locationStack：与m_valuemapStack同步使用，用于存放当前解析位置，方便进入子作用域退出后找到解析位置。<br> statics.functions：存放内置的test函数。<br> statics.expands：存放内置的replace函数。</p> 
<p>m_functionDefs.testFunctions类型是QHash&lt;ProKey, ProFunctionDef&gt;，是函数名与函数定义的键值对。ProFunctionDef中也有一个ProFile数据成员对象，用于存放函数定义的Tokens内容，在解析函数的时候会将这个Profile取出来进行解析。</p> 
<p>脚本中调用内建函数cache()函数时qmake中的调用堆栈</p> 
<figure class="image"> 
 <img alt="" height="179" src="https://images2.imgbox.com/68/2d/sYEpxEnE_o.png" width="666"> 
 <figcaption>
   脚本中调用cache函数的调用堆栈 
 </figcaption> 
</figure> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="259" src="https://images2.imgbox.com/2f/b4/TazC5xit_o.png" width="600"> 
  <figcaption>
    脚本中调用自定义的replace函数的调用堆栈 
  </figcaption> 
 </figure> 
</div> 
<p>  qmake访问replace函数和test函数逻辑。</p> 
<pre><code>QMakeEvaluator::VisitReturn QMakeEvaluator::evaluateExpandFunction( const ProKey &amp;func, const ushort *&amp;tokPtr, ProStringList *ret)  访问replace函数
{
    auto isbuildinE = statics.expands.constFind(func);
    if(isbuildinE) evaluateBuiltinExpand(*adef, func, args, *ret);   //expandVariableReferences(tokPtr, 5, &amp;args, true);

    QHash&lt;ProKey, ProFunctionDef&gt;::ConstIterator it =m_functionDefs.replaceFunctions.constFind(func);
    if(it) evaluateFunction(*it, args, ret);  //prepareFunctionArgs(tokPtr, &amp;args);
}

QMakeEvaluator::VisitReturn QMakeEvaluator::evaluateConditionalFunction(const ProKey &amp;func, const ushort *&amp;tokPtr)  访问test函数
{
    auto isbuildinE = statics.functions.constFind(func);
    if(isbuildinT) evaluateBuiltinConditional(*adef, func, args);

    QHash&lt;ProKey, ProFunctionDef&gt;::ConstIterator it =m_functionDefs.testFunctions.constFind(func);
    if(it)  evaluateBoolFunction(*it, args, func);
}

</code></pre> 
<h2>生成makefile</h2> 
<p>qmake 默认生成三个makefile相关的文件BuildsMetaMakefileGenerator::init()函数中会创建debug和release的MakefileGenerator对象，分别用于生成Makefile.Debug、Makefile.Release文件，BuildsMetaMakefileGenerator对象本身则生成Makefile文件。<br> windows下生成Makefile.Debug主要内容在writeStandardParts函数中：</p> 
<pre><code class="hljs">//E:\workspace\QtWork\qmake\generators\win32\winmakefile.cpp
void Win32MakefileGenerator::writeStandardParts(QTextStream &amp;t)
{
    t &lt;&lt; "####### Compiler, tools and options\n\n";
    ......
    t &lt;&lt; "####### Output directory\n\n";
    ......
    t &lt;&lt; "####### Files\n\n";
    ......
    t &lt;&lt; "####### Build rules\n\n";
    writeBuildRulesPart(t);
    writeRcFilePart(t);
    writeMakeQmake(t);
    .......
    writeCleanParts(t);
    writeExtraTargets(t);
    writeExtraCompilerTargets(t);
}</code></pre> 
<p>下面是生成Makefile中，moc调用规则时的堆栈。 </p> 
<figure class="image"> 
 <img alt="" src="https://images2.imgbox.com/51/c9/zSjPkYpy_o.png"> 
 <figcaption>
   qmake组装moc_*.cpp生成规则调用堆栈 
 </figcaption> 
</figure> 
<p><br> 参考：<a class="link-info" href="https://blog.csdn.net/qiushangren/article/details/127686627" title="如何通过pro文件向moc传入参数--------qmake组装makefile中的moc_*.cpp生成规则">如何通过pro文件向moc传入参数--------qmake组装makefile中的moc_*.cpp生成规则</a></p> 
<p></p> 
<h2>编译使用到的宏开关</h2> 
<p>QT_CONFIG(process)<br> PROEVALUATOR_FULL <br> QT_BOOTSTRAPPED <br> QT_BUILD_QMAKE <br> QT_NO_FOREACH <br> PARSER_DEBUG</p> 
<p><a href="https://blog.csdn.net/qiushangren/article/details/127983608" title="qmake 与 配置文件_丘上人的博客-CSDN博客">qmake 与 配置文件_丘上人的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5434ac83f81c62fef6d8ae168bbdbb1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#实现两个线程交替打印1-100</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4f947c60582898eb9566de0b842c8ef4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TVM：一种自动端到端优化的深度学习编译器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>