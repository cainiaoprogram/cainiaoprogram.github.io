<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>利用Redis锁解决并发问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="利用Redis锁解决并发问题" />
<meta property="og:description" content="用redis处理高并发是个很常见的方式，因为redis的访问效率很高（直接访问内存），一般我们会用来处理网站一瞬间的并发量。
那如果要使用redis来进行高并发问题的解决的话，应注意以下几点：
1、首先我们要先知道，我们在存储时，应使用redis的setnx方法，不应该使用set方法，因为setnx拥有原子操作命令（正确点说法应该是使用setnx，根据其属性可以保证共享资源的原子性操作），当资源锁存在不能设置值，则返回0，而当锁不存在，则设置锁，返回1； 但如果使用set方法，则会出现在高并发情况下，进程同时获取锁状态为null，同时设置，锁之间相互覆盖，但是俩进程仍在并发执行业务代码的情况。
2、为了防止死锁，我们不应直接使用jedis.setnx(lock, 1) 来进行简单的加锁，这样会导致当进程执行出现问题，锁未释放，则其他进程永远处于阻塞状态，出现死锁。 为了避免死锁，我们在加锁时带上时间戳，setnx(lock, 时间戳&#43;超时时间)，当发现锁超时了，便可以对锁进行重置，避免死锁。
接下来，实际操作！
设置锁：
//其中currentTimeMullis为当前时间、valideTime为超时时间，key为资源
//对该资源进行锁获取，如果存在锁则会返回false，不存在则设置值并返回true
boolean lock = redisService.setnx(key, currentTimeMullis&#43;valideTime);
//如果不存在并设置了值，则可以直接返回，因为已经获取资源锁成功
//否则，则代表存在这个锁，则进行锁是否超时的判断。获取该资源的锁时间，用于判断是否超时了
String keyTime = redisService.get(key);
if((Long.valueOf(currentTimeMullis)-Long.valueOf(keyTime))&gt;valideTime){
//该判断代表该资源锁已经超时，那么便进行资源锁的重置，也就是进行资源锁的重新设置（删除并重新设置）
//重新设置成功后也返回，因为获取锁成功，可以进行操作啦。
}
//如果以上操作都没有成功，则返回失败，代表获取锁失败，不可以进行操作。
释放锁：
当对资源处理结束后，则调用释放方法释放锁资源
（经提醒，我发现我这里少了个判断逻辑…）
//在删除前，应该先对该资源锁进行获取，判断值与此时释放锁的线程所携带的值是否相等，也就是我们上面创建时用的currentTimeMullis&#43;valideTime。
String keyLockTime = redisService.get(key);
if(keyLockTime!=null&amp;&amp;keyLockTime.equals(currentTimeMullis&#43;valideTime)){
//此时锁还由当前线程保持则释放锁
redisService.del(key);
}else{
//此时说明该资源锁被其他线程重置或释放，已不再拥有锁的释放权
//结束
}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/23491dfbeef9bb123be2b3fa48ba7363/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-11T20:54:18+08:00" />
<meta property="article:modified_time" content="2018-10-11T20:54:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">利用Redis锁解决并发问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>用redis处理高并发是个很常见的方式，因为redis的访问效率很高（直接访问内存），一般我们会用来处理网站一瞬间的并发量。</p> 
<p>那如果要使用redis来进行高并发问题的解决的话，应注意以下几点：</p> 
<p>1、首先我们要先知道，我们在存储时，应使用redis的setnx方法，不应该使用set方法，因为setnx拥有原子操作命令（正确点说法应该是使用setnx，根据其属性可以保证共享资源的原子性操作），当资源锁存在不能设置值，则返回0，而当锁不存在，则设置锁，返回1； 但如果使用set方法，则会出现在高并发情况下，进程同时获取锁状态为null，同时设置，锁之间相互覆盖，但是俩进程仍在并发执行业务代码的情况。</p> 
<p>2、为了防止死锁，我们不应直接使用jedis.setnx(lock, 1) 来进行简单的加锁，这样会导致当进程执行出现问题，锁未释放，则其他进程永远处于阻塞状态，出现死锁。 为了避免死锁，我们在加锁时带上时间戳，setnx(lock, 时间戳+超时时间)，当发现锁超时了，便可以对锁进行重置，避免死锁。</p> 
<p>接下来，实际操作！</p> 
<p>设置锁：</p> 
<p>//其中currentTimeMullis为当前时间、valideTime为超时时间，key为资源</p> 
<p>//对该资源进行锁获取，如果存在锁则会返回false，不存在则设置值并返回true</p> 
<p>boolean lock = redisService.setnx(key, currentTimeMullis+valideTime);</p> 
<p>//如果不存在并设置了值，则可以直接返回，因为已经获取资源锁成功</p> 
<p>//否则，则代表存在这个锁，则进行锁是否超时的判断。获取该资源的锁时间，用于判断是否超时了</p> 
<p>String keyTime = redisService.get(key);</p> 
<p>if((Long.valueOf(currentTimeMullis)-Long.valueOf(keyTime))&gt;valideTime){<!-- --></p> 
<p>//该判断代表该资源锁已经超时，那么便进行资源锁的重置，也就是进行资源锁的重新设置（删除并重新设置）</p> 
<p>//重新设置成功后也返回，因为获取锁成功，可以进行操作啦。</p> 
<p>}</p> 
<p>//如果以上操作都没有成功，则返回失败，代表获取锁失败，不可以进行操作。</p> 
<p>释放锁：</p> 
<p>当对资源处理结束后，则调用释放方法释放锁资源</p> 
<p>（经提醒，我发现我这里少了个判断逻辑…）</p> 
<p>//在删除前，应该先对该资源锁进行获取，判断值与此时释放锁的线程所携带的值是否相等，也就是我们上面创建时用的currentTimeMullis+valideTime。</p> 
<p>String keyLockTime = redisService.get(key);</p> 
<p>if(keyLockTime!=null&amp;&amp;keyLockTime.equals(currentTimeMullis+valideTime)){<!-- --></p> 
<p>//此时锁还由当前线程保持则释放锁</p> 
<p>redisService.del(key);</p> 
<p>}else{<!-- --></p> 
<p>//此时说明该资源锁被其他线程重置或释放，已不再拥有锁的释放权</p> 
<p>//结束</p> 
<p>}</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c73018efcdcfe9f3c12ca926621fae34/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">web-app标签</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a54f7fa7be9cad9f2640822e51e8205/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">生活感悟（转）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>