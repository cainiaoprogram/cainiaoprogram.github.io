<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>跳板(trampoline)实现原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="跳板(trampoline)实现原理" />
<meta property="og:description" content="1.基础知识
1.1.虚拟内存
虚拟内存到物理内存之间的映射
从上面的图中可以得出一些结论：
无论是物理内存还是虚拟内存的管理都是以页为单位来进行管理的，并且一般情况下二者的尺寸保持一致。操作系统为每个进程建立一张进程页表mmu，页表记录着虚拟内存页到物理内存页的映射关系以及相关的权限。并且页表是保存在物理内存页中的。因此所谓的虚拟内存分配其本质就是在页表中建立一个从虚拟内存页到物理内存页的映射关系而已。而所谓的remap就是将不同的虚拟页号映射到同一个物理页号而已。就如例子中进程1的第1页和第4页都是映射在同一个6号物理页中。不同进程之间的不同虚拟页号可以映射到相同的物理页号。操作系统还会维持一个全局物理页空闲信息表，用来记录当前未被分配的物理内存。这样一旦有进程需要分配虚拟内存空间时就从这个表中查找空闲的区域进行快速分配。 iOS的内核系统中有一层Mach子系统，Mach子系统是内核中的内核，它是一种微内核。Mach子系统中将进程(task)、线程、内存的管理都称之为一个对象，并且为每个对象都会分配一个被称之为port的端口号，所有对象之间的通信和功能调用都是通过port为标识的mach message来进行通信的。
1.2vm_remap 做到可以将动态分配出来的内存页具备可执行权限，就需要利用 vm_remap。 它的定义是这样的：
On Darwin, vm_remap() provides support for mapping an existing code page at new address, while retaining the existing page protections; using vm_remap(), we can create multiple copies of existing, executable code, placed at arbitrary addresses.
从定义中我们可以知道两点信息：
vm_remap 可以让内存页具备被 map 的页的特性，如果是可执行页被 map，那新创建的页自然而然页具备了这个权限。vm_remap 也不是肆无忌惮的创建任何可执行的页，通俗理解，它只是一个 copy 映射。 上述图片引用自Implementing imp_implementationWithBlock()
因此，我们可以通过在编写代码的过程中，精心构造、预留在程序二进制的代码页，在运行时不断“复制映射”，来完成特殊的使命。
tramplion实现步骤
1.struct定义dataPage和textPage数据结构 构造textPage页函数实现（汇编或者c实现等等），使用数据结构来进行相关操作
2.vm_remap构造页：vm_allocate分配两页虚拟内存 dataPage数据页 textPage代码页 初始都是读写权限 vm_remap使textPage指向构造好的函数（可以是c实现，汇编实现等等） 3.textPage汇编实现:
• 取出原方法的 IMP A，保存起来" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/905be8f7c7d7c6e8f02e421883c01730/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-03T19:17:05+08:00" />
<meta property="article:modified_time" content="2021-09-03T19:17:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">跳板(trampoline)实现原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.基础知识</p> 
<p>1.1.虚拟内存</p> 
<p></p> 
<p><strong>虚拟内存到物理内存之间的映射</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/01/b1/sbtY6GEr_o.png"></p> 
<p></p> 
<p style="text-align:center;">从上面的图中可以得出一些结论：</p> 
<p></p> 
<p></p> 
<ol><li>无论是物理内存还是虚拟内存的管理都是以页为单位来进行管理的，并且一般情况下二者的尺寸保持一致。</li><li>操作系统为每个进程建立一张进程页表mmu，页表记录着虚拟内存页到物理内存页的映射关系以及相关的权限。并且页表是保存在物理内存页中的。因此所谓的虚拟内存分配其本质就是在页表中建立一个从虚拟内存页到物理内存页的映射关系而已。而所谓的remap就是将不同的虚拟页号映射到同一个物理页号而已。就如例子中进程1的第1页和第4页都是映射在同一个6号物理页中。</li><li>不同进程之间的不同虚拟页号可以映射到相同的物理页号。</li><li>操作系统还会维持一个全局物理页空闲信息表，用来记录当前未被分配的物理内存。这样一旦有进程需要分配虚拟内存空间时就从这个表中查找空闲的区域进行快速分配。</li></ol> 
<p>iOS的内核系统中有一层Mach子系统，Mach子系统是内核中的内核，它是一种微内核。Mach子系统中将进程(task)、线程、内存的管理都称之为一个对象，并且为每个对象都会分配一个被称之为port的端口号，所有对象之间的通信和功能调用都是通过port为标识的mach message来进行通信的。</p> 
<p></p> 
<p></p> 
<p><strong>1.2vm_remap </strong></p> 
<p>做到可以将动态分配出来的内存页具备可执行权限，就需要利用 vm_remap。 它的定义是这样的：</p> 
<p>On Darwin, vm_remap() provides support for mapping an existing code page at new address, while retaining the existing page protections; using vm_remap(), we can create multiple copies of existing, executable code, placed at arbitrary addresses.</p> 
<p>从定义中我们可以知道两点信息：</p> 
<ul><li>vm_remap 可以让内存页具备被 map 的页的特性，如果是可执行页被 map，那新创建的页自然而然页具备了这个权限。</li><li>vm_remap 也不是肆无忌惮的创建任何可执行的页，通俗理解，它只是一个 copy 映射。</li></ul> 
<p></p> 
<p>                                                                                                            <img alt="" src="https://images2.imgbox.com/f6/70/H99qd1Vr_o.png"></p> 
<p> </p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cc/3f/GFnp9qmk_o.png">                                                                                                              </p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p><strong>上述图片引用自</strong><a href="https://landonf.org/code/objc/imp_implementationWithBlock.20110413.html" rel="nofollow"><strong>Implementing imp_implementationWithBlock()</strong></a></p> 
<p>因此，我们可以通过在编写代码的过程中，精心构造、预留在程序二进制的代码页，在运行时不断<strong>“</strong>复制映射”，来完成特殊的使命。</p> 
<p></p> 
<p>tramplion实现步骤</p> 
<p>1.struct定义dataPage和textPage数据结构 构造textPage页函数实现（汇编或者c实现等等），使用数据结构来进行相关操作</p> 
<p>2.<strong>vm_remap</strong>构造页：vm_allocate分配两页虚拟内存 dataPage数据页 textPage代码页 初始都是读写权限  <strong>vm_remap</strong>使textPage指向构造好的函数（可以是c实现，汇编实现等等） </p> 
<p>3.textPage汇编实现:</p> 
<p>• 取出原方法的 IMP A，保存起来</p> 
<p>• 替换原方法 IMP 为一个新地址 B</p> 
<p>• 当执行到该方法时，会跳转到新地址 B</p> 
<p>• 在 B 中做一些自定义的操作</p> 
<p>• 获取原先的 A，跳转过去</p> 
<p>源码解析：</p> 
<p><strong>IMP</strong> imp_implementationWithBlock(<strong>id</strong> block) </p> 
<p>datapage和textpage内存结构</p> 
<p><img alt="" src="https://images2.imgbox.com/f6/fc/JKHU5CdZ_o.png"></p> 
<p></p> 
<p></p> 
<p><strong>union</strong> Payload {<!-- --></p> 
<p>        <strong>id</strong> block;</p> 
<p>        uintptr_t nextAvailable;  // free list</p> 
<p>    };</p> 
<p>一个data页的Payload对应一个TrampolineEntry</p> 
<p>关键代码解析：</p> 
<p>#pragma mark <strong>Public API</strong></p> 
<p><strong>IMP</strong> imp_implementationWithBlock(<strong>id</strong> block) </p> 
<p>{<!-- --></p> 
<p>    // Block object must be copied outside runtimeLock</p> 
<p>    // because it performs arbitrary work.</p> 
<p>    //因为可以执行任意的工作 所以Block_copy必须在runtimeLock之外</p> 
<p>    block = Block_copy(block);</p> 
<p></p> 
<p>    // Trampolines must be initialized outside runtimeLock</p> 
<p>    // because it calls dlopen().</p> 
<p>    //Trampolines是类TrampolinePointerWrapper的别名 Trampolines 初始化</p> 
<p>    Trampolines.Initialize();</p> 
<p>    </p> 
<p>    mutex_locker_t lock(runtimeLock);</p> 
<p></p> 
<p>    <strong>return</strong> _imp_implementationWithBlockNoCopy(block);</p> 
<p>}</p> 
<p>TrampolineBlockPageGroup的初始化</p> 
<p>TrampolineBlockPageGroup就是包含textpage和datapage的类</p> 
<p>#pragma mark <strong>Trampoline Management Functions</strong></p> 
<p><strong>static</strong> TrampolineBlockPageGroup *_allocateTrampolinesAndData()</p> 
<p>{<!-- --></p> 
<p>    runtimeLock.assertLocked();</p> 
<p></p> 
<p>    vm_address_t dataAddress;</p> 
<p>    </p> 
<p>    TrampolineBlockPageGroup::check();</p> 
<p></p> 
<p>    //我们的最终映射大致如下所示：</p> 
<p>    //r/w数据</p> 
<p>    //从libobjc-trampolines.dylib映射的r/o可执行代码 （包含修正的从执行代码到数据之间的偏移值）</p> 
<p>    //</p> 
<p>    //更准确地说，它将如下所示：</p> 
<p>    //1页r/w数据</p> 
<p>    //1页libobjc-trampolines.dylib Mach-O标题</p> 
<p>    //N页蹦床代码，每个Argument模式一页</p> 
<p>    //libobjc trampolines代码段的其余部分为M页。</p> 
<p>    //内核要求我们每次重新remap整个可执行代码段。</p> 
<p>    //我们假设我们的代码从第二个可执行代码页开始，但是非常健壮针对可执行代码段末尾的其他添加。</p> 
<p>    ASSERT(HeadPageGroup == <strong>nil</strong>  ||  HeadPageGroup-&gt;nextAvailablePage == <strong>nil</strong>);</p> 
<p></p> 
<p>    <strong>auto</strong> textSource = Trampolines.textSegment();</p> 
<p>    <strong>auto</strong> textSourceSize = Trampolines.textSegmentSize();</p> 
<p>    <strong>auto</strong> dataSize = Trampolines.dataSize();</p> 
<p></p> 
<p>    // Allocate a single contiguous region big enough to hold data+text.</p> 
<p>    //分配一个足够大的连续区域来容纳数据+可执行代码</p> 
<p>    kern_return_t result;</p> 
<p>    result = vm_allocate(mach_task_self(), &amp;dataAddress,</p> 
<p>                         dataSize + textSourceSize,</p> 
<p>                         VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_MEMORY_FOUNDATION));</p> 
<p>    <strong>if</strong> (result != KERN_SUCCESS) {<!-- --></p> 
<p>        _objc_fatal("vm_allocate trampolines failed (%d)", result);</p> 
<p>    }</p> 
<p></p> 
<p>    // Remap libobjc-trampolines' TEXT segment atop all</p> 
<p>    // but the first of the pages we just allocated:</p> 
<p>    //将libobjc trampolines的文本段重新映射到我们刚才分配的所有页面上，但第一个页除外：</p> 
<p>    //也就是dataSize那块区域除外 只remap textSourceSize那块内存（可执行代码）</p> 
<p>    vm_address_t textDest = dataAddress + dataSize;</p> 
<p>    vm_prot_t currentProtection, maxProtection;</p> 
<p>    result = vm_remap(mach_task_self(), &amp;textDest,</p> 
<p>                      textSourceSize,</p> 
<p>                      0, VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE,</p> 
<p>                      mach_task_self(), textSource, <strong>TRUE</strong>, </p> 
<p>                      &amp;currentProtection, &amp;maxProtection, VM_INHERIT_SHARE);</p> 
<p>    <strong>if</strong> (result != KERN_SUCCESS) {<!-- --></p> 
<p>        _objc_fatal("vm_remap trampolines failed (%d)", result);</p> 
<p>    }</p> 
<p>//把以dataAddress为起点的dataSize + textSourceSize长度的内存区域强转成TrampolineBlockPageGroup实例对象</p> 
<p>    <strong>auto</strong> *pageGroup = <strong>new</strong> ((<strong>void</strong>*)dataAddress) TrampolineBlockPageGroup;</p> 
<p>    //类似链表的数据结构 执行add操作</p> 
<p>    <strong>if</strong> (HeadPageGroup) {//如果已经存在一个头pageGroup，</p> 
<p>        TrampolineBlockPageGroup *lastPageGroup = HeadPageGroup;</p> 
<p>        <strong>while</strong>(lastPageGroup-&gt;nextPageGroup) {//取到链表的最后一个元素</p> 
<p>            lastPageGroup = lastPageGroup-&gt;nextPageGroup;</p> 
<p>        }</p> 
<p>        lastPageGroup-&gt;nextPageGroup = pageGroup;</p> 
<p>        //nextAvailablePage指针方便快速取到可操作的pageGroup</p> 
<p>        HeadPageGroup-&gt;nextAvailablePage = pageGroup;</p> 
<p>    } <strong>else</strong> {//如果不存在一个头pageGroup就自己当头pageGroup，</p> 
<p>        HeadPageGroup = pageGroup;</p> 
<p>    }</p> 
<p>    </p> 
<p>    <strong>return</strong> pageGroup;</p> 
<p>}</p> 
<p>//主要逻辑</p> 
<p><strong>IMP</strong> _imp_implementationWithBlockNoCopy(<strong>id</strong> block)</p> 
<p>{<!-- --></p> 
<p>    runtimeLock.assertLocked();</p> 
<p></p> 
<p>    TrampolineBlockPageGroup *pageGroup = </p> 
<p>        getOrAllocatePageGroupWithNextAvailable();</p> 
<p>//找到数据取可以存block的index</p> 
<p>    uintptr_t index = pageGroup-&gt;nextAvailable;</p> 
<p>    ASSERT(index &gt;= pageGroup-&gt;startIndex()  &amp;&amp;  index &lt; pageGroup-&gt;endIndex());</p> 
<p>    TrampolineBlockPageGroup::Payload *payload = pageGroup-&gt;payload(index);//用于存储原来的block</p> 
<p>    </p> 
<p>    uintptr_t nextAvailableIndex = payload-&gt;nextAvailable;</p> 
<p>    <strong>if</strong> (nextAvailableIndex == 0) {//第一次进入</p> 
<p>        // First time through (unused slots are zero). Fill sequentially.</p> 
<p>        // If the page is now full this will now be endIndex(), handled below.</p> 
<p>        nextAvailableIndex = index + 1;</p> 
<p>    }</p> 
<p>    pageGroup-&gt;nextAvailable = nextAvailableIndex;</p> 
<p>    <strong>if</strong> (nextAvailableIndex == pageGroup-&gt;endIndex()) {//页满</p> 
<p>        // PageGroup is now full (free list or wilderness exhausted)</p> 
<p>        // Remove from available page linked list</p> 
<p>        TrampolineBlockPageGroup *iterator = HeadPageGroup;</p> 
<p>        <strong>while</strong>(iterator &amp;&amp; (iterator-&gt;nextAvailablePage != pageGroup)) {<!-- --></p> 
<p>            iterator = iterator-&gt;nextAvailablePage;</p> 
<p>        }</p> 
<p>        <strong>if</strong> (iterator) {<!-- --></p> 
<p>            iterator-&gt;nextAvailablePage = pageGroup-&gt;nextAvailablePage;</p> 
<p>            pageGroup-&gt;nextAvailablePage = <strong>nil</strong>;</p> 
<p>        }</p> 
<p>    }</p> 
<p>    </p> 
<p>    payload-&gt;block = block;</p> 
<p>    <strong>return</strong> pageGroup-&gt;trampoline(argumentModeForBlock(block), index);</p> 
<p>}</p> 
<p></p> 
<p></p> 
<p></p> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae9acd368e7c132fc13166c7ea7adc39/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu1804系统（xavier、NX）编译opencv报E:Unable to locate package libjasper-dev等最新解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54c2dcbae377c231b9fc2fefe5ca5398/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序 接口wx.redirectto与wx.navigateTo备忘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>