<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java原生项目什么意思_什么是ABA问题？java里面的原生解决方案是什么？原理是什么？... - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java原生项目什么意思_什么是ABA问题？java里面的原生解决方案是什么？原理是什么？..." />
<meta property="og:description" content="AtomicStampedReference是一个带有时间戳的对象引用，能很好的解决CAS机制中的ABA问题，这篇文章将通过案例对其介绍分析。
一、ABA问题
ABA问题是CAS机制中出现的一个问题，他的描述是这样的。我们直接画一张图来演示，
什么意思呢？就是说一个线程把数据A变为了B，然后又重新变成了A。此时另外一个线程读取的时候，发现A没有变化，就误以为是原来的那个A。这就是有名的ABA问题。ABA问题会带来什么后果呢？我们举个例子。
一个小偷，把别人家的钱偷了之后又还了回来，还是原来的钱吗,ABA问题也一样，如果不好好解决就会带来大量的问题。最常见的就是资金问题，也就是别人如果挪用了你的钱，在你发现之前又还了回来。但是别人却已经触犯了法律。
如何去解决这个ABA问题呢，就是使用今天所说的AtomicStampedReference。
二、AtomicStampedReference
1、问题解决
我们先给出一个ABA的例子，对ABA问题进行场景重现。
public class AtomicTest{
private static AtomicInteger index = new AtomicInteger(10);
public static void main(String[] args){
new Thread(() -&gt; {
index.compareAndSet(10, 11);
index.compareAndSet(11, 10);
System.out.println(Thread.currentThread().getName()&#43;
&#34;：10-&gt;11-&gt;10&#34;);
},&#34;张三&#34;).start();
new Thread(() -&gt; {
try {
TimeUnit.SECONDS.sleep(2);
boolean isSuccess = index.compareAndSet(10, 12);
System.out.println(Thread.currentThread().getName()&#43;
&#34;：index是预期的10嘛，&#34;&#43;isSuccess
&#43;&#34; 设置的新值是：&#34;&#43;index.get());
} catch (InterruptedException e) {
e.printStackTrace();
}
},&#34;李四&#34;).start();
}
}
在上面的代码中，我们使用张三线程，对index10-&gt;11-&gt;10的变化，然后李四线程读取index观察是否有变化，并设置新值。运行一下看看结果：
这个案例重现了ABA的问题场景，下面我们看如何使用AtomicStampedReference解决这个问题的。
public class AtomicTest2{
private static AtomicInteger index = new AtomicInteger(10);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b48c4e6553d845e2326f529d0222dfa5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-27T13:22:25+08:00" />
<meta property="article:modified_time" content="2021-02-27T13:22:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java原生项目什么意思_什么是ABA问题？java里面的原生解决方案是什么？原理是什么？...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>AtomicStampedReference是一个带有时间戳的对象引用，能很好的解决CAS机制中的ABA问题，这篇文章将通过案例对其介绍分析。</p> 
 <p>一、ABA问题</p> 
 <p>ABA问题是CAS机制中出现的一个问题，他的描述是这样的。我们直接画一张图来演示，</p> 
 <p align="center"><img src="https://images2.imgbox.com/85/ea/mCypOnvS_o.png" alt="b634328640f7888406abd74c6d211c7f.png"></p> 
 <p>什么意思呢？就是说一个线程把数据A变为了B，然后又重新变成了A。此时另外一个线程读取的时候，发现A没有变化，就误以为是原来的那个A。这就是有名的ABA问题。ABA问题会带来什么后果呢？我们举个例子。</p> 
 <p>一个小偷，把别人家的钱偷了之后又还了回来，还是原来的钱吗,ABA问题也一样，如果不好好解决就会带来大量的问题。最常见的就是资金问题，也就是别人如果挪用了你的钱，在你发现之前又还了回来。但是别人却已经触犯了法律。</p> 
 <p>如何去解决这个ABA问题呢，就是使用今天所说的AtomicStampedReference。</p> 
 <p>二、AtomicStampedReference</p> 
 <p>1、问题解决</p> 
 <p>我们先给出一个ABA的例子，对ABA问题进行场景重现。</p> 
 <p>public class AtomicTest{<!-- --></p> 
 <p>private static AtomicInteger index = new AtomicInteger(10);</p> 
 <p>public static void main(String[] args){<!-- --></p> 
 <p>new Thread(() -&gt; {<!-- --></p> 
 <p>index.compareAndSet(10, 11);</p> 
 <p>index.compareAndSet(11, 10);</p> 
 <p>System.out.println(Thread.currentThread().getName()+</p> 
 <p>"：10-&gt;11-&gt;10");</p> 
 <p>},"张三").start();</p> 
 <p>new Thread(() -&gt; {<!-- --></p> 
 <p>try {<!-- --></p> 
 <p>TimeUnit.SECONDS.sleep(2);</p> 
 <p>boolean isSuccess = index.compareAndSet(10, 12);</p> 
 <p>System.out.println(Thread.currentThread().getName()+</p> 
 <p>"：index是预期的10嘛，"+isSuccess</p> 
 <p>+"   设置的新值是："+index.get());</p> 
 <p>} catch (InterruptedException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>},"李四").start();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>在上面的代码中，我们使用张三线程，对index10-&gt;11-&gt;10的变化，然后李四线程读取index观察是否有变化，并设置新值。运行一下看看结果：</p> 
 <p align="center"><img src="https://images2.imgbox.com/43/8c/402wPTcv_o.png" alt="254c9b054f457cf325be297adfeb9570.png"></p> 
 <p>这个案例重现了ABA的问题场景，下面我们看如何使用AtomicStampedReference解决这个问题的。</p> 
 <p>public class AtomicTest2{<!-- --></p> 
 <p>private static AtomicInteger index = new AtomicInteger(10);</p> 
 <p>static AtomicStampedReference stampRef</p> 
 <p>= new AtomicStampedReference(10, 1);</p> 
 <p>public static void main(String[] args){<!-- --></p> 
 <p>new Thread(() -&gt; {<!-- --></p> 
 <p>int stamp = stampRef.getStamp();</p> 
 <p>System.out.println(Thread.currentThread().getName()</p> 
 <p>+ " 第1次版本号： " + stamp);</p> 
 <p>stampRef.compareAndSet(10, 11,stampRef.getStamp(),stampRef.getStamp()+1);</p> 
 <p>System.out.println(Thread.currentThread().getName()</p> 
 <p>+ " 第2次版本号： " + stampRef.getStamp());</p> 
 <p>stampRef.compareAndSet(11, 10,stampRef.getStamp(),stampRef.getStamp()+1);</p> 
 <p>System.out.println(Thread.currentThread().getName()</p> 
 <p>+ " 第3次版本号： " + stampRef.getStamp());</p> 
 <p>},"张三").start();</p> 
 <p>new Thread(() -&gt; {<!-- --></p> 
 <p>try {<!-- --></p> 
 <p>int stamp = stampRef.getStamp();</p> 
 <p>System.out.println(Thread.currentThread().getName()</p> 
 <p>+ " 第1次版本号： " + stamp);</p> 
 <p>TimeUnit.SECONDS.sleep(2);</p> 
 <p>boolean isSuccess =stampRef.compareAndSet(10, 12,</p> 
 <p>stampRef.getStamp(),stampRef.getStamp()+1);</p> 
 <p>System.out.println(Thread.currentThread().getName()</p> 
 <p>+ " 修改是否成功： "+ isSuccess+" 当前版本 ：" + stampRef.getStamp());</p> 
 <p>System.out.println(Thread.currentThread().getName()</p> 
 <p>+ " 当前实际值： " + stampRef.getReference());</p> 
 <p>} catch (InterruptedException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>},"李四").start();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>上面的代码我们再来分析一下，我们会发现AtomicStampedReference里面增加了一个时间戳，也就是说每一次修改只需要设置不同的版本好即可。我们先运行一边看看：</p> 
 <p align="center"><img src="https://images2.imgbox.com/18/67/hXbSEJM7_o.png" alt="4daa18b193c9bfecf5b3b31e6da02a96.png"></p> 
 <p>这里使用的是AtomicStampedReference的compareAndSet函数，这里面有四个参数：</p> 
 <p>compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)。</p> 
 <p>(1)第一个参数expectedReference：表示预期值。</p> 
 <p>(2)第二个参数newReference：表示要更新的值。</p> 
 <p>(3)第三个参数expectedStamp：表示预期的时间戳。</p> 
 <p>(4)第四个参数newStamp：表示要更新的时间戳。</p> 
 <p>这个compareAndSet方法到底是如何实现的，我们深入到源码中看看。</p> 
 <p>2、源码分析</p> 
 <p>public boolean compareAndSet(V   expectedReference,</p> 
 <p>V   newReference,</p> 
 <p>int expectedStamp,</p> 
 <p>int newStamp){<!-- --></p> 
 <p>Pair current = pair;</p> 
 <p>return</p> 
 <p>expectedReference == current.reference &amp;&amp;</p> 
 <p>expectedStamp == current.stamp &amp;&amp;</p> 
 <p>((newReference == current.reference &amp;&amp;</p> 
 <p>newStamp == current.stamp) ||</p> 
 <p>casPair(current, Pair.of(newReference, newStamp)));</p> 
 <p>}</p> 
 <p>刚刚这四个参数的意思已经说了，我们主要关注的就是实现，首先我们看到的就是这个Pair，因此想要弄清楚，我们再看看这个Pair是什么，</p> 
 <p>private static class Pair{<!-- --></p> 
 <p>final T reference;</p> 
 <p>final int stamp;</p> 
 <p>private Pair(T reference, int stamp){<!-- --></p> 
 <p>this.reference = reference;</p> 
 <p>this.stamp = stamp;</p> 
 <p>}</p> 
 <p>static  Pair of(T reference, int stamp){<!-- --></p> 
 <p>return new Pair(reference, stamp);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>在这里我们会发现Pair里面只是包存了值reference和时间戳stamp。</p> 
 <p>在compareAndSet方法中最后还调用了casPair方法，从名字就可以看到，主要是使用CAS机制更新新的值reference和时间戳stamp。我们可以进入这个方法中看看。</p> 
 <p>//底层调用的是UNSAFE的compareAndSwapObject方法</p> 
 <p>private boolean casPair(Pair cmp, Pair val){<!-- --></p> 
 <p>return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);</p> 
 <p>}</p> 
 <p>三、总结</p> 
 <p>其实除了AtomicStampedReference类，还有一个原子类也可以解决，就是AtomicMarkableReference，它不是维护一个版本号，而是维护一个boolean类型的标记，用法没有AtomicStampedReference灵活。因此也只是在特定的场景下使用。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7095b22b83b9c4c5185f377bbf912585/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">tomcat java 11_Tomcat系列(11)——Tomcat 部署web应用的4种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ef947119b41f647ff2e1d09f93207fb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java新建一个标签_Java创建标签时的JavaFX 11：IllegalAccessError</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>