<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于STM32的ADC采样及各式滤波实现（HAL库，含VOFA&#43;教程） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于STM32的ADC采样及各式滤波实现（HAL库，含VOFA&#43;教程）" />
<meta property="og:description" content="前言：本文为手把手教学ADC采样及各式滤波算法的教程，本教程的MCU采用STM32F103ZET6。以HAL库的ADC采样函数为基础进行教学，通过各式常见滤波的实验结果进行分析对比，搭配VOFA&#43;工具直观的展示滤波效果。ADC与滤波算法都是嵌入式较为常见的，希望这篇博文能给读者朋友的工程项目给予些许帮助。（文末代码开源！）
实验硬件：STM32F103ZET6；
实验效果图：
一、ADC采样 1.1 ADC简介 单片机是数字芯片，只认识由0和1组成的逻辑序列。但实际情况下，生活中还有许多非0和1的模拟物理量存在，例如温度，湿度等。这时候往往需要使用到AD转换，AD转换的英文就是Analog(模拟) to Digital(数字) ，由模拟量转化为数字量；同理DA，则为Digital to Analog，数字量转化为模拟量。
ADC，Analog to Digital Converter 的缩写，中文名称模数转换器。它可以将外部的模拟信号转化成数字信号。使用它去读取IO口上的数值将不再是简单的0或1，而是连续可变的数值。ADC采样就是把随时间连续变化的模拟量转换为时间离散的模拟量。
ADC几个比较重要的参数：
（1）测量范围：测量范围对于 ADC 来说就好比尺子的量程，ADC 测量范围决定了你外接的设备其信号输出电压范围，不能超过 ADC 的测量范围（比如，STM32系列的 ADC 正常就不能超过3.3V）。
（2）分辨率：假如 ADC 的测量范围为 0-5V，分辨率设置为12位，那么我们能测出来的最小电压就是 5V除以 2 的 12 次方，也就是 5/4096=0.00122V。很明显，分辨率越高，采集到的信号越精确，所以分辨率是衡量 ADC 的一个重要指标。
（3）采样时间：当 ADC 在某时刻采集外部电压信号的时候，此时外部的信号应该保持不变，但实际上外部的信号是不停变化的。所以在 ADC 内部有一个保持电路，保持某一时刻的外部信号，这样 ADC 就可以稳定采集了，保持这个信号的时间就是采样时间。
（4）采样率：也就是在一秒的时间内采集多少次。很明显，采样率越高越好，当采样率不够的时候可能会丢失部分信息，所以 ADC 采样率是衡量 ADC 性能的另一个重要指标（详细参考信号处理方向书籍）。
总之，只要是需要模拟信号转为数字信号的场合，那么肯定要用到 ADC。很多数字传感器内部会集成 ADC，传感器内部使用 ADC 来处理原始的模拟信号，最终给用户输出数字信号。
1.2 STM32的ADC STM32 拥有 1~3 个 ADC（STM32F101/102 系列只有 1 个 ADC，STM32F103系列则有3个ADC和1个DAC），这些 ADC 可以独立使用，也可以使用双重模式（提高采样率）。STM32 的 ADC 是 12 位逐次逼近型的模拟数字转换器。它有 18 个通道，可测量 16 个外部和 2 个内部信号源。各通道的 A/D 转换可以单次、连续、扫描或间断模式执行。ADC 的结果可以左对齐或右对齐方式存储在 16 位数据寄存器中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/26d1f6ae58ff838d0dc9946b88ca38a3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-19T22:47:21+08:00" />
<meta property="article:modified_time" content="2023-03-19T22:47:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于STM32的ADC采样及各式滤波实现（HAL库，含VOFA&#43;教程）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        <strong>前言：</strong>本文为手把手教学<span style="color:#fe2c24;"><strong>ADC采样</strong></span>及<span style="color:#fe2c24;"><strong>各式滤波算法</strong></span>的教程，本教程的<strong>MCU</strong>采用<span style="color:#fe2c24;"><strong>STM32F103ZET6</strong></span>。以<strong>HAL库</strong>的<strong>ADC采样</strong>函数为基础进行教学，通过各式<span style="color:#fe2c24;"><strong>常见滤波</strong></span>的实验结果进行分析对比，搭配<span style="color:#fe2c24;"><strong>VOFA+工具</strong></span>直观的展示滤波效果。<strong>ADC</strong>与<strong>滤波算法</strong>都是嵌入式较为常见的，希望这篇博文能给读者朋友的工程项目给予些许帮助。（<strong>文末代码开源！</strong>）</p> 
<p><strong>      实验硬件：</strong>STM32F103ZET6；</p> 
<p><strong>实验效果图：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/90/73/XTFJJqO4_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/79/7e/HssxHr6U_o.png" width="1200"></p> 
<h2>一、ADC采样</h2> 
<h3>1.1 ADC简介</h3> 
<p><span style="color:#0d0016;"><strong>单片机</strong></span>是<strong>数字芯片</strong>，只认识由<strong>0</strong>和<strong>1</strong>组成的逻辑序列。但实际情况下，生活中还有许多<strong>非0和1</strong>的<span style="color:#fe2c24;"><strong>模拟物理量</strong></span>存在，例如温度，湿度等。这时候往往需要使用到<strong>AD转换</strong>，AD转换的英文就是<strong>Analog(模拟) to Digital(数字) </strong>，由模拟量转化为数字量；同理DA，则为Digital to Analog，数字量转化为模拟量。</p> 
<p><strong>ADC</strong>，<strong>Analog to Digital Converter</strong> 的缩写，中文名称模数转换器。它可以将外部的模拟信号转化成数字信号。使用它去读取IO口上的数值将不再是简单的0或1，而是连续可变的数值。ADC采样就是把随<span style="color:#fe2c24;"><strong>时间连续变化</strong></span>的<strong>模拟量</strong>转换为<span style="color:#fe2c24;"><strong>时间离散</strong></span>的<strong>模拟量</strong>。</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>ADC几个比较重要的参数：</strong></span></p> 
 <p><strong>（1）测量范围：</strong>测量范围对于 ADC 来说就好比尺子的量程，ADC 测量范围决定了你外接的设备其信号输出电压范围，不能超过 ADC 的测量范围（<strong>比如，STM32系列的 ADC 正常就不能超过3.3V</strong>）。</p> 
 <p><strong>（2）分辨率：</strong>假如 ADC 的测量范围为 0-5V，分辨率设置为12位，那么我们能测出来的最小电压就是 5V除以 2 的 12 次方，也就是 5/4096=0.00122V。很明显，分辨率越高，采集到的信号越精确，所以分辨率是衡量 ADC 的一个重要指标。</p> 
 <p><strong>（3）采样时间：</strong>当 ADC 在某时刻采集外部电压信号的时候，此时外部的信号应该保持不变，但实际上外部的信号是不停变化的。所以在 ADC 内部有一个保持电路，保持某一时刻的外部信号，这样 ADC 就可以稳定采集了，保持这个信号的时间就是采样时间。</p> 
 <p><strong>（4）采样率：</strong>也就是在一秒的时间内采集多少次。很明显，采样率越高越好，当采样率不够的时候可能会丢失部分信息，所以 ADC 采样率是衡量 ADC 性能的另一个重要指标（<strong>详细参考信号处理方向书籍</strong>）。</p> 
</blockquote> 
<p>总之，只要是需要模拟信号转为数字信号的场合，那么肯定要用到 ADC。很多数字传感器内部会集成 ADC，传感器内部使用 ADC 来处理原始的模拟信号，最终给用户输出数字信号。</p> 
<h3>1.2 STM32的ADC</h3> 
<p><strong>STM32</strong> 拥有 1~3 个 ADC（<strong>STM32F101/102 系列只有 1 个 ADC，STM32F103系列则有3个ADC和1个DAC</strong>），这些 ADC 可以独立使用，也可以使用双重模式（提高采样率）。STM32 的 ADC 是 <span style="color:#fe2c24;"><strong>12 位逐次逼近型</strong></span>的模拟数字转换器。它有 18 个通道，可测量 16 个外部和 2 个内部信号源。各通道的 A/D 转换可以单次、连续、扫描或间断模式执行。ADC 的结果可以左对齐或右对齐方式存储在 16 位数据寄存器中。</p> 
<blockquote> 
 <p><strong>特别说明：</strong> ADC 是12位逐次逼近型模数转换器，输出数值范围是 0 ~ 2^12 -1（0 ~ 4095），满量程是 3.3V ，分辨率就是最低有效位（LSB）的对应输入电压值。<span style="color:#fe2c24;"><strong>分辨率 =3300/4095 ≈ 0.806mV</strong></span>。</p> 
</blockquote> 
<p><strong>STM32F10X 系列</strong>将 ADC 的转换分为 2 个通道组：<span style="color:#fe2c24;"><strong>规则通道组</strong></span>和<span style="color:#fe2c24;"><strong>注入通道组</strong></span>。规则通道相当于正常运行的程序，而注入通道呢，就相当于中断打断式通道选择。在程序正常执行的时候，中断是可以打断程序执行的。同这个类似，注入通道的转换可以打断规则通道的转换， 在注入通道被转换完成之后，规则通道才得以继续转换。</p> 
<p class="img-center"><img alt="" height="493" src="https://images2.imgbox.com/dc/0c/DLKls6xb_o.png" width="952"></p> 
<blockquote> 
 <p>关于 ADC 的模式配置可选择性很高，一般无需太多了解，详情可以参考<span style="color:#fe2c24;"><strong>《STM32 参考手册的》</strong></span>第 155 页，第 11 章。</p> 
</blockquote> 
<h2>二、VOFA+教学</h2> 
<h3>2.1 VOFA+简介</h3> 
<p><span style="color:#fe2c24;"><strong>VOFA+</strong></span>是一款直观、灵活、强大的插件驱动高自由度的<strong>上位机</strong>，在与电气打交道的领域里，如<strong>自动化</strong>、<strong>嵌入式</strong>、<strong>物联网</strong>、<strong>机器人</strong>等，都能看到<span style="color:#fe2c24;"><strong>VOFA+</strong></span>的身影。<strong>VOFA+</strong>的名字来源于：<strong>Volt/伏特</strong>、<strong>Ohm/欧姆</strong>、<strong>Fala/法拉</strong>、<strong>Ampere/安培</strong>，是电气领域的基础单位，与他们的发明者——4位电子物理学领域的科学巨人，分别同名。他们的首字母共同构成了VOFA+的名字。</p> 
<p class="img-center"><img alt="" height="1050" src="https://images2.imgbox.com/45/2c/dWP8Pvyz_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>VOFA+特点概览：</strong></p> 
 <p><strong>平台支持：</strong>Windows、Linux、MacOS；<br><strong>接口支持：</strong>串口（超高波特率，稳定支持）、网口(TCP客户端/服务端，UDP)；<br><strong>协议支持：</strong>协议为插件，已开源，人人可编写。目前已支持CSV风格的字符串协议，和十六进制浮点数组形式的字节流协议；<br><strong>控件支持：</strong>控件为插件，已开源，人人可编写。目前已支持波形图、按钮、状态灯、图片、滑动条、3D立方控件（可更换模型）等；<br><strong>数据维度自由化：</strong>2维度与3维，一个也不能拉下；<br><strong>自主研发的波形控件：</strong>支持每通道百万采样点的绘制，性能强劲；<br><strong>自主研发的波形控件：</strong>无缝嵌入了实时直方统计和点数可设置的傅里叶变换，可以使用VOFA+进行数据分析。</p> 
</blockquote> 
<blockquote> 
 <p><strong>Vofa+网址：</strong><a href="https://www.vofa.plus/" rel="nofollow" title="VOFA+ | VOFA+">VOFA+ | VOFA+</a></p> 
</blockquote> 
<h3>2.2 VOFA+使用方法</h3> 
<p><span style="color:#fe2c24;"><strong>VOFA+</strong></span>的数据协议引擎有<strong>3种</strong>：<strong>FireWater</strong>，<strong>JustFloat</strong>，<strong>RawData</strong>。每种数据协议引擎都有自己特殊的使用效果，读者朋友可以根据自己的实际需要去选择使用。作者这里主要给大家演示一下<span style="color:#fe2c24;"><strong>FireWater协议</strong></span>下的VOFA+使用效果和方法。</p> 
<p><span style="color:#fe2c24;"><strong>FireWater协议</strong></span>是<strong>CSV风格</strong>的字符串流，直观简洁，编程像printf简单。但由于字符串解析消耗更多的运算资源（无论在上位机还是下位机），<strong>建议仅在通道数量不多、发送频率不高的时候使用</strong>。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/0f/14/pnE0paxC_o.png" width="1200"></p> 
<p>将鼠标放到<span style="color:#fe2c24;"><strong>FireWater协议</strong></span>上，可以很贴心的得到使用格式帮助。如上图所示，我们使用printf("simples:%f, %f\n", sin(t1), sin(t2)")函数进行打印测试。</p> 
<p><strong>测试代码：</strong></p> 
<pre><code class="language-cs">#include "math.h"
#include "stdio.h"
....
int main(void)
{
  /* USER CODE BEGIN 1 */
	float t1 = 0;
	float t2 = 0;
  /* USER CODE END 1 */
.......

 while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
		t1 += 0.1;
        t2 += 0.5;
		printf("simples:%f, %f\n", sin(t1), sin(t2)); 		
		HAL_Delay(100);  
  }
  /* USER CODE END 3 */
}</code></pre> 
<p><strong>1、选择串口通讯、端口号、波特率等参数设置；</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e4/54/MC3Bm70d_o.png" width="1200"></p> 
<p><strong>2、去控件中选择波形图，拉入tab中，右键选择Y轴将2个输入I0与I1都选中，之后开启串口连接；</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/86/46/P1CCk7Ns_o.png" width="1200"></p> 
<p><strong>3、运行上位机，使用波形图控件读取下位机参数；</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d0/f0/mgzWHTPV_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>补充：</strong></p> 
 <p>不难看出VOFA+的使用是非常简单快捷的，其自由度也是相当的高，关键还是<strong>免费的</strong>。<span style="color:#fe2c24;"><strong>PID调参</strong></span>，<span style="color:#fe2c24;"><strong>无人机的姿态3D</strong></span>显示等等都可以借助VOFA+实现， 希望该软件可以给读者朋友的日常嵌入式开发提供便捷与帮助。</p> 
</blockquote> 
<h2>三、CubeMX配置</h2> 
<p><strong>1、RCC配置外部高速晶振（精度更高）——HSE；</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f1/78/MKoAzpJq_o.png" width="1200"></p> 
<p><strong>2、SYS配置：Debug设置成Serial Wire</strong>（<strong>否则可能导致芯片自锁</strong>）；</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/23/10/RMwnty2a_o.png" width="1200"></p> 
<p><strong>3、UART1配置：使用串口通讯UART1与VOFA+上位机进行通讯显示；</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/1e/b5/DXYz6PS2_o.png" width="1200"></p> 
<p><strong>4、ADC1配置：利用ADC1的通道IN1进行AD采样，保持独立模式；</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/6f/aa/9bz9Tzg8_o.png" width="1200"></p> 
<p><strong>5、时钟树配置：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/55/b9/iZjKtLfZ_o.png" width="1200"></p> 
<p><strong>6、工程配置：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/bb/8c/kR8wcvlY_o.png" width="1200"></p> 
<h2>四、滤波算法与效果</h2> 
<blockquote> 
 <p><strong>受限于MCU自身的ADC外设缺陷，其精度和稳定性通常较差，很多场景下需要采取滤波补偿。</strong><br><strong>滤波的作用就是减少噪声与干扰对数据测量的影响。</strong></p> 
</blockquote> 
<h3>4.1 未添加滤波算法</h3> 
<p><strong>重写printf函数：</strong></p> 
<pre><code class="language-cs">#include "stdio.h"
//重定义
int fputc(int c,FILE *stream)
{
	uint8_t ch[1]={c};
	HAL_UART_Transmit(&amp;huart1,ch,1,0xFFFF);
	return c;
}</code></pre> 
<p><strong>main函数： </strong></p> 
<pre><code class="language-cs">while(1){	
    HAL_ADC_Start(&amp;hadc1);						//开启ADC1，放置在while循环中
	ADC_value=HAL_ADC_GetValue(&amp;hadc1);			//获取ADC1的数值
	HAL_Delay(10);								//延迟函数，防止采样失效
	printf("ADC_value:%d\n", ADC_value);
}</code></pre> 
<p><strong>VOFA+读取到的数据：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/91/27/FkwXxlgA_o.png" width="1200"></p> 
<p>上图借助VOFA+上位机可以清楚看出未使用滤波的ADC采样波动还是比较明显的，但是作者主观干啥F1系列的ADC确实好像比F4系列的ADC稳定些。（<strong>之所以不是4096可能是因为电源未达到3.3v</strong>）</p> 
<h3>4.2 一阶互补滤波</h3> 
<blockquote> 
 <p>方法：取a=0~1,本次滤波结果=（1-a）本次采样值+a上次滤波结果<br> 优点：对周期性干扰具有良好的抑制作用适用于波动频率较高的场合<br> 缺点：相位滞后，灵敏度低滞后程度取决于a值大小不能消除滤波频率高于采样频率的1/2的干扰信号</p> 
</blockquote> 
<pre><code class="language-cs">//一阶互补滤波
int firstOrderFilter(int newValue, int oldValue, float a)
{
	return a * newValue + (1-a) * oldValue;
}

ADC_value=HAL_ADC_GetValue(&amp;hadc1);			//获取ADC1的数值
//主函数
while(1){
    HAL_ADC_Start(&amp;hadc1);						//开启ADC1，放置在while循环中
    Filtering_Value = firstOrderFilter(HAL_ADC_GetValue(&amp;hadc1),ADC_value,0.3);    //滤波算法
	HAL_Delay(10);								//延迟函数，防止采样失效
	printf("ADC_value:%d\n", ADC_value);
}</code></pre> 
<p><strong>VOFA+软件的效果图：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/69/16/YUVMIBn8_o.png" width="1200"></p> 
<blockquote> 
 <p>一阶互补滤波的局限性还是很大的，效果非常一般。</p> 
</blockquote> 
<h3>4.3 中位值滤波</h3> 
<blockquote> 
 <p>方法：连续采样N次（N取奇数）把N次采样值按大小排列取中间值为本次有效值<br> 优点：能有效克服因偶然因素引起的波动干扰；对温度、液位等变化缓慢的被测参数有良好的滤波效果<br> 缺点：对流量，速度等快速变化的参数不宜</p> 
</blockquote> 
<pre><code class="language-cs">//中值滤波算法
int middleValueFilter(int N)
{
    int value_buf[N];
    int i,j,k,temp;
    for( i = 0; i &lt; N; ++i)
    {
        value_buf[i] = HAL_ADC_GetValue(&amp;hadc1);	
				
    }
    for(j = 0 ; j &lt; N-1; ++j)
    {
        for(k = 0; k &lt; N-j-1; ++k)
        {
            //从小到大排序，冒泡法排序
            if(value_buf[k] &gt; value_buf[k+1])
            {
                temp = value_buf[k];
                value_buf[k] = value_buf[k+1];
                value_buf[k+1] = temp;
            }
        }
    }
		
    return value_buf[(N-1)/2];
}</code></pre> 
<p><strong>VOFA+软件的效果图：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/fa/b3/xreyHBGP_o.png" width="1200"></p> 
<blockquote> 
 <p>中值滤波对消除异常值和平稳化AD采样都具有十分有效的结果。</p> 
</blockquote> 
<h3>4.4 算术平均滤波</h3> 
<blockquote> 
 <p>方法：连续取N个采样值进行算术平均运算;<br> N值较大时：信号平滑度较高，但灵敏度较低<br> N值较小时：信号平滑度较低，但灵敏度较高<br> N值的选取：一般流量，N=12；压力：N=4<br> 优点：试用于对一般具有随机干扰的信号进行滤波。这种信号的特点是有一个平均值，信号在某一数值范围附近上下波动。<br> 缺点：测量速度较慢或要求数据计算较快的实时控制不适用。</p> 
</blockquote> 
<pre><code class="language-cs">//算术平均值滤波
int averageFilter(int N)
{
   int sum = 0;
   short i;
   for(i = 0; i &lt; N; ++i)
   {
        sum += HAL_ADC_GetValue(&amp;hadc1);	
   }
   return sum/N;
}</code></pre> 
<p><strong>VOFA+软件的效果图：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/64/e5/tOrv52uT_o.png" width="1200"></p> 
<blockquote> 
 <p>算术平均滤波表现出了一定的平稳性，同时具有波动的伴随性（合理选择N值可能达到很好的效果）。</p> 
</blockquote> 
<h3>4.5 滑动平均滤波</h3> 
<blockquote> 
 <p>方法：把连续取N个采样值看成一个队列，队列的长度固定为N。每次采样到一个新数据放入队尾，并扔掉原来队首的一次数据(先进先出原则)。把队列中的N个数据进行算术平均运算,就可获得新的滤波结果。<br> N值的选取：流量，N=12；压力：N=4；液面，N=4~12；温度，N=1~4<br> 优点：对周期性干扰有良好的抑制作用，平滑度高；试用于高频振荡的系统<br> 缺点：灵敏度低；对偶然出现的脉冲性干扰的抑制作用较差，不适于脉冲干扰较严重的场合<br> 比较浪费RAM（改进方法，减去的不是队首的值，而是上一次得到的平均值）</p> 
</blockquote> 
<pre><code class="language-cs">//平滑均值滤波
#define N 10
int value_buf[N];
int sum=0;
int curNum=0;
int moveAverageFilter()
{
    if(curNum &lt; N)
    {
        value_buf[curNum] = HAL_ADC_GetValue(&amp;hadc1);
        sum += value_buf[curNum];
			  curNum++;
        return sum/curNum;
    }
    else
    {
        sum -= sum/N;
        sum += HAL_ADC_GetValue(&amp;hadc1);
        return sum/N;
    }
}</code></pre> 
<p><strong>VOFA+软件的效果图：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/3d/2e/pY84oL1g_o.png" width="1200"></p> 
<blockquote> 
 <p>平滑均值滤波相较于普通的算术平均滤波，突出一个平滑特性。可以从上述VOFA+的波形图看出，平滑滤波可以有效抵消AD采样的刺噪并稳定化采集（<strong>据作者同门实战反应平滑滤波的效果还是非常好的，尤其在控制方面</strong>）。</p> 
</blockquote> 
<h3>4.6 限幅平均滤波</h3> 
<blockquote> 
 <p>方法：相当于“限幅滤波法”+“递推平均滤波法”<br> 每次采样到的新数据先进行限幅处理再送入队列进行递推平均滤波处理<br> 优点：对于偶然出现的脉冲性干扰，可消除有其引起的采样值偏差。<br> 缺点：比较浪费RAM</p> 
</blockquote> 
<pre><code class="language-cs">//限幅平均滤波
#define A 50        //限制幅度阈值
#define M 12
int data[M];
int First_flag=0;
int LAverageFilter()
{
  int i;
  int temp,sum,flag=0;
  data[0]=HAL_ADC_GetValue(&amp;hadc1);
	for(i=1;i&lt;M;i++)
	{
		temp=HAL_ADC_GetValue(&amp;hadc1);
		if((temp-data[i-1])&gt;A||((data[i-1]-temp)&gt;A))
		{
		  i--;flag++;
		}
		else
		{
			data[i]=temp;
		}
	}
  for(i=0;i&lt;M;i++)
  {
    sum+=data[i];
  } 
  return  sum/M;
}</code></pre> 
<p><strong>VOFA+软件的效果图：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/64/13/yjxG89h7_o.png" width="1200"></p> 
<blockquote> 
 <p> 限幅平均滤波类似于缝合怪，但是效果是非常显著的，它有效的解决了实际场景下突变噪声对AD采样的影响，但是消耗内存。</p> 
</blockquote> 
<h3>4.7 卡尔曼滤波 </h3> 
<blockquote> 
 <p>核心思想：根据当前的仪器"测量值" 和上一刻的 “预测量” 和 “误差”，计算得到当前的最优量，再预测下一刻的量。里面比较突出的是观点是：把误差纳入计算，而且分为预测误差和测量误差两种，通称为噪声。还有一个非常大的特点是：误差独立存在，始终不受测量数据的影响。</p> 
 <p>优点：巧妙的融合了观测数据与估计数据，对误差进行闭环管理，将误差限定在一定范围。适用性范围很广，时效性和效果都很优秀。</p> 
 <p>缺点：需要调参，参数的大小对滤波的效果影响较大。</p> 
</blockquote> 
<pre><code class="language-cs">//卡尔曼滤波
int KalmanFilter(int inData)
{
		static float prevData = 0;                                 //先前数值
		static float p = 10, q = 0.001, r = 0.001, kGain = 0;      // q控制误差  r控制响应速度 
	
		p = p + q;
		kGain = p / ( p + r );                                     //计算卡尔曼增益
		inData = prevData + ( kGain * ( inData - prevData ) );     //计算本次滤波估计值
		p = ( 1 - kGain ) * p;                                     //更新测量方差
		prevData = inData;
		return inData;                                             //返回滤波值
}</code></pre> 
<p><strong>VOFA+软件的效果图：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/0e/73/TWTFGT41_o.png" width="1200"></p> 
<blockquote> 
 <p>作者本人是非常喜欢卡尔曼滤波的，VOFA+显示的波形图开源看出卡尔曼滤波有一定的去噪稳定特性的，虽然效果不是特别优秀。卡尔曼滤波的普适性很强，尤其在控制与多传感器融合方向，只要参数调整的好，效果出奇优秀。</p> 
</blockquote> 
<h2>五、实验总结</h2> 
<p>ADC作为嵌入式开发过程中必须掌握的外设，往往项目中是需要设置滤波器的。<strong>RC硬件滤波效果一般的话，可以用软件来凑。</strong>同时滤波算法各式各样，原理也各不相同，<span style="color:#fe2c24;"><strong>希望读者朋友在实际的工程项目中，不要盲目的追求各种牛逼的滤波算法，其实适合该工程的滤波就是好滤波。</strong></span></p> 
<h2>六、代码开源</h2> 
<p><strong>代码地址：</strong> <a href="https://download.csdn.net/download/black_sneak/87592779" title="基于STM32的ADC采样及各式滤波实现（HAL库）-嵌入式文档类资源-CSDN文库">基于STM32的ADC采样及各式滤波实现（HAL库）-嵌入式文档类资源-CSDN文库</a></p> 
<p><strong>如果<span style="color:#0d0016;">积分不够的朋友</span>，<span style="color:#fe2c24;">点波关注</span>，<span style="color:#fe2c24;">评论区留下邮箱</span>，作者无偿提供<span style="color:#fe2c24;">源码和后续问题解答</span>。求求啦关注一波吧 ！！！</strong></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/897d6f4641908d05eaf0bd7ebba510af/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">递归函数简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a76a41f159d6f3a26cf39f84aee0de11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Spring-Security框架发送请求出现403错误</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>