<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity API——Application类的详解(二)：数据文件路径 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity API——Application类的详解(二)：数据文件路径" />
<meta property="og:description" content="上一节中将Application类中所有的静态属性和静态方法都一一列举，方便以后查阅。接下将详细介绍Application类的属性和方法。 上一节传送门：Unity API——Application类的详解(一)：列举属性和方法
数据文件路径：总共有四个属性，分别为：dataPath、persistentDataPath、streamingAssetsPath、 temporaryCachePath 基本语法：public static string dataPath { get ;} dataPaht是包含游戏数据文件夹的路径，权限为只读，返回的是一个相对路径，即对于不同的游戏平台返回的路径是不一样的。 Unity Editor: &lt;path tp project folder&gt;/Assets Mac player: &lt;path to player app bundle&gt;/Contents iOS player: &lt;path to player app bundle&gt;/&lt;AppName.app&gt;/Data Android:/data/app/xxx.xxx.xxx.apk
测试代码：
using UnityEngine; using System.Collections; /// &lt;summary&gt; /// 此类用于 dataPath测试 /// &lt;/summary&gt; public class DataPath : MonoBehaviour { private void printDataPath() { Debug.Log(&#34;dataPaht:&#34; &#43; Application.dataPath); } void Start () { printDataPath(); } } 由于设备和条件有限，我只在Unity Editor 和android两个环境下作了测试，测试结果如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5209e5b1993d50aa3f76a14a9bc505a4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-15T15:14:12+08:00" />
<meta property="article:modified_time" content="2017-12-15T15:14:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity API——Application类的详解(二)：数据文件路径</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre> 
 <div>
  
  <blockquote>
   
   <p>上一节中将Application类中所有的静态属性和静态方法都一一列举，方便以后查阅。接下将详细介绍Application类的属性和方法。

上一节传送门：<a target="_blank" href="https://www.jianshu.com/p/617789c9919a" rel="nofollow noopener noreferrer">Unity API——Application类的详解(一)：列举属性和方法</a></p>

  
  </blockquote>

  
  <hr>

  
  <h4>数据文件路径：总共有四个属性，分别为：dataPath、persistentDataPath、streamingAssetsPath、 temporaryCachePath</h4>

  
  <hr>

  
  <blockquote>

   
   <h5>基本语法：public static string dataPath { get ;}</h5>

  
  </blockquote>

  
  <p>dataPaht是包含游戏数据文件夹的路径，权限为<strong>只读</strong>，返回的是一个<strong>相对路径</strong>，即对于不同的游戏平台返回的路径是不一样的。

<em><em>Unity Editor: <em><em>&lt;path tp project folder&gt;/Assets <strong>Mac player:</strong> &lt;path to player app bundle&gt;/Contents <strong>iOS player:</strong> &lt;</em>path to player app bundle</em>&gt;/&lt;</em>AppName.app</em>&gt;/Data

<strong>Android:</strong>/data/app/xxx.xxx.xxx.apk</p>

  
  <p>测试代码：</p>

  
  <pre class="hljs undefined"><code class="C#">using UnityEngine;
using System.Collections;
/// &lt;summary&gt;
/// 此类用于 dataPath测试
/// &lt;/summary&gt;
public class DataPath : MonoBehaviour 
{
    private void printDataPath()
    {
        Debug.Log("dataPaht:" + Application.dataPath);
    }
    void Start () 
    {
        printDataPath();
    }
    
}

</code></pre>
  
  <p>由于设备和条件有限，我只在Unity Editor 和android两个环境下作了测试，测试结果如下：</p>
  
  <ul><li>Unity Editor测试结果：</li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:387px; max-height:42px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:10.85%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    Unity Editor 控制台打印出的日志
   
   </div>
  
  </div>
  
  <ul><li>Android平台测试结果：</li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:494px; max-height:37px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:7.489999999999999%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    LogCat下打印的日志
   
   </div>
  
  </div>
  
  <p><strong>注意</strong>：</p>
  
  <blockquote>
   
   <p>Application.dataPath 返回的路径目录，在移动端是没有访问权限的（既不能访问此目录）。</p>
  
  </blockquote>
  
  <hr>
  
  <blockquote>
   
   <h5>基本语法：public static string persistentDataPath{ get ;}</h5>
  
  </blockquote>
  
  <p>persistentDataPaht返回的是一个持久化数据存储目录，权限为<strong>只读</strong>,在<strong>同一平台</strong>，不用的应用程序访问此属性<strong>返回值相同</strong>，但是不同的平台就不相同了。当应用程序发布到IOS和Android平台中，这个路径会指向一个公共的路径，而且应用每次更新时这里的数据不会被清除。</p>
  
  <p>测试代码：</p>
  
  <pre class="hljs undefined"><code class="C#">using UnityEngine;
using System.Collections;
/// &lt;summary&gt;
/// 此类用于 persistentDataPath测试
/// &lt;/summary&gt;
public class DataPath : MonoBehaviour 
{

    private void printPersistentDataPaht()
    {
        Debug.Log("persistentDataPaht:" + Application.persistentDataPath);
    }
    void Start () 
    {
        printPersistentDataPaht();
    }

    
}


</code></pre>
  
  <ul><li>Unity Editor测试结果：</li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:478px; max-height:37px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:7.739999999999999%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    Unity Editor 控制台打印出的日志
   
   </div>
  
  </div>
  
  <ul><li>Android平台测试结果：</li></ul>
  
  <p></p>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:587px; max-height:31px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:5.28%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    LogCat下打印的日志
   
   </div>
  
  </div>
  
  <br>
  
  <strong>注意</strong>：
  
  <p></p>
  
  <blockquote>
   
   <p>这个路径比较特殊，这个路径下是可读写。而且在IOS上就是应用程序的沙盒，但是在Android可以是程序的沙盒，也可以是sdcard。并且在Android打包的时候，ProjectSetting页面有一个选项Write Access，可以设置它的路径是沙盒还是sdcard。该路径的特点：</p>
  
  </blockquote>
  
  <ul><li>内容可读写，不过只能运行时才能写入或者读取。<strong>提前将数据存入这个路径是不可行的。</strong></li><li>无内容限制。你可以从<strong>StreamingAsset</strong>中读取二进制文件或者从<strong>AssetBundle</strong>读取文件来写入<strong>PersistentDataPath</strong>中。</li><li>写下的文件，可以在电脑上查看。同样也可以清掉。</li></ul>
  
  <hr>
  
  <blockquote>
   
   <h5>基本语法：public static string streamingAssetsPath{ get ;}</h5>
  
  </blockquote>
  
  <p>streamingAssetsPath返回的是流数据的缓存目录，返回路径为<strong>相对路径</strong>适合用来存储一些外部数据文件。</p>
  
  <p>测试代码：</p>
  
  <pre class="hljs undefined"><code class="C#">using UnityEngine;
using System.Collections;
/// &lt;summary&gt;
/// 此类用于 streamingAssetsPath测试
/// &lt;/summary&gt;
public class DataPath : MonoBehaviour 
{
    private void printStreamingAssetsPaht()
    {
        Debug.Log("streamingAssetsPaht:" + Application.streamingAssetsPath);
    }

    void Start () 
    {
        printStreamingAssetsPaht();
    }
}


</code></pre>
  
  <ul><li>Unity Editor测试结果：</li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:498px; max-height:32px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:6.43%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    Unity Editor 控制台打印的日志
   
   </div>
  
  </div>
  
  <ul><li>Android平台测试结果：</li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:687px; max-height:35px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:5.09%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    Logcat打印的日志
   
   </div>
  
  </div>
  
  <hr>
  
  <blockquote>
   
   <h5>基本语法：public static string temporaryCachePath{ get ;}</h5>
  
  </blockquote>
  
  <p>temporaryCachePath返回一个临时数据缓存目录(<strong>只读</strong>)，同一平台不用应用程序访问此属性的返回值相同，不同平台返回值不同。</p>
  
  <p>测试代码：</p>
  
  <pre class="hljs undefined"><code class="C#">using UnityEngine;
using System.Collections;
/// &lt;summary&gt;
/// 此类用于 temporayrCachePaht测试
/// &lt;/summary&gt;
public class DataPath : MonoBehaviour 
{
    private void printTemporaryCachePath()
    {
        Debug.Log("temporaryCachePaht:" + Application.temporaryCachePath);
    }

    void Start () 
    {
        printTemporaryCachePath();
    }

}


</code></pre>
  
  <ul><li>Unity Editor测试结果：</li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:474px; max-height:32px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:6.75%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    Unity Editor 控制台打印的日志
   
   </div>
  
  </div>
  
  <ul><li>Android平台测试结果：</li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:563px; max-height:28px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:4.97%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    LogCat打印的日志
   
   </div>
  
  </div>
  
  <hr>
  
  <blockquote>
   
   <p>将以上四个路径分别在Unity Editor和Android环境下进行一个对比：</p>
  
  </blockquote>
  
  <ul><li>Unity Editor 平台<br><strong>dataPath:　　　　　　D:/unity/workSpace/MyReadBook/Assets</strong><br>persistentDataPath:　 C:/Users/young/AppData/LocalLow/young/datapahttest<br><strong>streamingAssetsPath: D:/unity/workSpace/MyReadBook/Assets/StreamingAssets</strong><br>temporaryCachePath:  C:/Users/young/AppData/Local/Temp/young/datapahttest</li><li>Android 平台<br><strong>dataPath:</strong>　　　　　　　/data/app/com.young.datapahttest-1.apk<br>persistentDataPath: 　 /data/data/com.young.datapahttest/files<br><strong>streamingAssetsPath</strong>:　 jar:file:///data/app/com.young.datapahttest-1.apk!/assets<br>temporaryCachePath: 　/data/data/com.young.datapahttest/cache</li></ul>
  
  <p>从中可以看出，dataPath 和 stremingAssetsPath是相对于程序的安装目录，是相对路径。非常适用于移植平台设置外部数据文件读取路径。而persistentDataPath和temporaryCachePath返回的程序所在平台的固定位置。适用于存储程序运行过程中一些数据。</p>
  
  <h4>总结：</h4>
  
  <hr>
  
  <ul><li>四个路径的含义</li></ul>
  
  <table><thead><tr><th style="text-align:left">属性名称</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td>Application.dataPath</td><td>此属性用于返回程序的数据文件所在文件夹的路径</td></tr><tr><td>Application.streamingAssetsPath</td><td>此属性用于返回流数据的缓存目录，返回路径为相对路径，适合设置一些外部数据文件的路径。</td></tr><tr><td>Application.persistentDataPath</td><td>此属性用于返回一个持久化数据存储目录的路径，可以在此路径下存储一些持久化的数据文件:</td></tr><tr><td>Application.temporaryCachePath</td><td>此属性用于返回一个临时数据的缓存目录。</td></tr></tbody></table>
  
  <ul><li>Android 平台</li></ul>
  
  <table><thead><tr><th style="text-align:left">属性名称</th><th style="text-align:left">返回路径</th></tr></thead><tbody><tr><td>Application.dataPaht</td><td>/data/app/xxx.xxx.xxx.apk</td></tr><tr><td>Application.streamingAssetsPath</td><td>jar:file:///data/app/<a target="_blank" href="https://link.jianshu.com?t=http://xxx.xxx.xxx.apk/!/assets" rel="nofollow noopener noreferrer">xxx.xxx.xxx.apk/!/assets</a></td></tr><tr><td>Application.persistentDataPath</td><td>/data/data/xxx.xxx.xxx/files</td></tr><tr><td>Application.temporaryCachePath</td><td>/data/data/xxx.xxx.xxx/cache</td></tr></tbody></table>
  
  <ul><li>IOS 平台</li></ul>
  
  <table><thead><tr><th style="text-align:left">属性名称</th><th style="text-align:left">返回路径</th></tr></thead><tbody><tr><td>Application.dataPaht</td><td>Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data</td></tr><tr><td>Application.streamingAssetsPath</td><td>Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/Raw</td></tr><tr><td>Application.persistentDataPath</td><td>Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents</td></tr><tr><td>Application.temporaryCachePath</td><td>Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches</td></tr></tbody></table>
  
  <ul><li>Unity Editor平台</li></ul>
  
  <table><thead><tr><th style="text-align:left">属性名称</th><th style="text-align:left">返回路径</th></tr></thead><tbody><tr><td>Application.dataPaht</td><td>Application(工程目录)/Assets</td></tr><tr><td>Application.streamingAssetsPath</td><td>Application(工程目录)/Assets<strong>/StreamingAssets</strong></td></tr><tr><td>Application.persistentDataPath</td><td>系统指定目录1/工程名</td></tr><tr><td>Application.temporaryCachePath</td><td>系统指定目录2/工程名</td></tr></tbody></table>
  
  <hr>
  
  <h4>扩展：Unity资源处理（参考了：<a target="_blank" href="https://link.jianshu.com?t=http://www.cnblogs.com/murongxiaopifu/p/4199541.html" rel="nofollow noopener noreferrer">Unity3D移动平台动态读取外部文件全解析</a>）</h4>
  
  <p>关于资源加载问题要讲到<strong>Resources</strong>、<strong>StreamingAssets</strong>、<strong>AssetBundle</strong>这三个类。</p>
  
  <blockquote>
   
   <p><strong>Resources：</strong><br>它作为一个Unity3D的保留文件夹出现的，也就是如果你新建的文件夹的名字叫Resources，那么里面的内容在打包时都会被无条件的打到发布包中。其特点是：</p>
  
  </blockquote>
  
  <ul><li>只读，即不能动态修改。所以想要动态更新的资源不要放在这里。</li><li>会将文件夹内的资源打包集成到.asset文件里面。因此建议可以放一些Prefab，因为Prefab在打包时会自动过滤掉不需要的资源，有利于减小资源包的大小。</li><li>主线程加载。</li><li>资源读取使用Resources.Load()。</li></ul>
  
  <h5>实例测试</h5>
  
  <ul><li>首先新建一个用于测试的text.xml文件</li></ul>
  
  <pre class="hljs undefined"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;test&gt;
    &lt;name&gt;young&lt;/name&gt;
    &lt;blog&gt;http://www.jianshu.com/users/afda32f1cc9a/latest_articles&lt;/blog&gt;
    &lt;age&gt;21&lt;/age&gt;
    &lt;address&gt;China&lt;/address&gt;
&lt;/test&gt;
</code></pre>
  
  <ul><li>然后在Assets文件夹下新建一个Resources目录,将text.xml放在改目录下，如下图所示：</li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:386px; max-height:184px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:47.67%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption"></div>
  
  </div>
  
  <ul><li>新建一个脚本ReadXMLInResources.cs挂在Main Camera下，脚本代码如下：</li></ul>
  
  <pre class="hljs undefined"><code class="C#">using UnityEngine;
using System.Collections;
using System.Xml;


/// &lt;summary&gt;
/// 此类用于测试 在Resources目录下读取XML文件
/// &lt;/summary&gt;
public class ReadXMLInResources : MonoBehaviour
{

    private string readXMLResult;

    // Use this for initialization
    void Start () {
        LoadXML("text");
        Debug.Log("xml:" + readXMLResult);
    
    }
    
    // Update is called once per frame
    void Update () {
    
    }

    void OnGUI()
    {
        GUIStyle titleStyle = new GUIStyle();
        titleStyle.fontSize = 20;
        titleStyle.normal.textColor = new Color(0, 255, 255);
        GUI.Label(new Rect(400, 10, 500, 200), readXMLResult, titleStyle );
    }

    /// &lt;summary&gt;
    /// 加载Assets/Resources文件夹下resourcesName文件
    /// &lt;/summary&gt;
    /// &lt;param name="resourcesName"&gt;&lt;/param&gt;
    private void LoadXML(string resourcesName)
    {
        readXMLResult = Resources.Load(resourcesName).ToString();

        XmlDocument doc = new XmlDocument();

        doc.LoadXml(readXMLResult);
    }



}

</code></pre>
  
  <ul><li>
    
    <ol><li>在WindowEditor平台下运行结果：</li></ol></li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:700px; max-height:258px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:24.34%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    WindowsEditor运行结果截图
   
   </div>
  
  </div>
  
  <ul><li>2 在Android平台下运行结果：</li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:526px; max-height:229px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:43.54%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    Andorid平台下运行结果截图
   
   </div>
  
  </div>
  
  <hr>
  
  <blockquote>
   
   <p><strong>StreamingAssets：</strong><br>要说到StreamingAssets，其实和Resources还是蛮像的。同样作为一个只读的Unity3D的保留文件夹出现。不过两者也有很大的区别，那就是Resources文件夹中的内容在打包时会被压缩和加密。而StreamingAsset文件夹中的内容则会原封不动的打入包中，因此StreamingAssets主要用来存放一些二进制文件。下面也同样做一个简单的总结：</p>
  
  </blockquote>
  
  <ul><li>只读不可写。</li><li>主要用来存放二进制文件。</li><li>Android平台下一般是通过过WWW类来读取。</li></ul>
  
  <h5>实例测试</h5>
  
  <p>-首先在Assets目录下新建StreamingAssets文件夹，将text.xml放入改目录下（此例金座测试，实际数据文件一般不会放在改文件夹下）如下图所示：</p>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:389px; max-height:168px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:43.19%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    Paste_Image.png
   
   </div>
  
  </div>
  
  <ul><li>然后创建一个ReadXMLInStreamingAssets.cs脚本 挂在Main Camera下，脚本代码如下：</li></ul>
  
  <pre class="hljs undefined"><code class="C#">using UnityEngine;
using System.Collections;
using System.IO;

public class ReadXMLInStreamingAssets : MonoBehaviour
{
    /// &lt;summary&gt;
    /// 读取XML结果
    /// &lt;/summary&gt;
    private string readXmlResult;

    // Use this for initialization
    void Start ()
    {
        loadXML();
        Debug.Log(readXmlResult);
    }
    
    // Update is called once per frame
    void Update () {
    
    }


    void OnGUI()
    {
        GUIStyle titleStyle = new GUIStyle();
        titleStyle.fontSize = 20;
        titleStyle.normal.textColor = new Color(0, 255, 255);
        GUI.Label(new Rect(400, 10, 500, 200), readXmlResult, titleStyle);
    }


    /// &lt;summary&gt;
    /// 根据不同的平台加载StremingAssets文件夹下的XML文件
    /// &lt;/summary&gt;
    private void loadXML()
    {
        if(Application.platform == RuntimePlatform.Android)
        {
            Debug.Log("android platform");
            StartCoroutine("loadXMLWithWWW");
        }
        else if(Application.platform == RuntimePlatform.WindowsEditor)
        {
            Debug.Log("window platform");
            //获得文件路径
            string path = Application.streamingAssetsPath + "/text.xml";
            loadXMLWithStreamReader(path);
        }
        else if(Application.platform == RuntimePlatform.IPhonePlayer)
        {
            Debug.Log("iphone platform");
            //获得文件路径
            string path = Application.streamingAssetsPath +"/text.xml";
            loadXMLWithStreamReader(path);

        }
        //发现所有平台StreamingAssets目录下的文件路径都可以用Application.streamingAssetsPath +"/fileName.xml"来加载，但Android加载方式不一样
    }

    /// &lt;summary&gt;
    /// 使用StreamReader读取文件信息
    /// &lt;/summary&gt;
    /// &lt;param name="path"&gt;读取文件的路径&lt;/param&gt;
    private void loadXMLWithStreamReader(string path)
    {  
        FileInfo fileInfo = new FileInfo(path);
        StreamReader reader = fileInfo.OpenText();
        readXmlResult = reader.ReadToEnd();
        reader.Close();
    }

    /// &lt;summary&gt;
    /// 
    ///对于android平台， streamingAssets中的文件一般只能用www来异步读取
    /// （同时，可以用persistenDataPath来保存streamingassets里读取的数据）
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    IEnumerator loadXMLWithWWW()
    {
        //获得文件路径
        string path = Application.streamingAssetsPath + "/text.xml";
        WWW www = new WWW(path);

        yield return www;

        readXmlResult = www.text;

    }
}

</code></pre>
  
  <ul><li>
    
    <ol><li>在WindowEditor平台下运行结果：</li></ol></li></ul>
  
  <div class="image-package">
   
   <div class="image-container" style="max-width:700px; max-height:223px; background-color:transparent">
    
    <div class="image-container-fill" style="padding-bottom:31.86%"></div>
    
    <div class="image-view">
     
     <img src="" alt="" style="">
    
    </div>
   
   </div>
   
   <div class="image-caption">
    
    WindowEditor平台下运行结果截图
   
   </div>
  
  </div>
  
  <ul><li>2  在Android平台下运行结果：</li></ul>
  
  <h3>
   
   <div class="image-package">
    
    <div class="image-container" style="max-width:571px; max-height:211px; background-color:transparent">
     
     <div class="image-container-fill" style="padding-bottom:36.95%"></div>
     
     <div class="image-view">
      
      <img src="" alt="" style="">
     
     </div>
    
    </div>
    
    <div class="image-caption">
     
     Android平台下运行结果截图
    
    </div>
   
   </div></h3>
  
  <blockquote>
   
   <p><strong>AssetBundle</strong><br>是把prefab或者二进制文件封装成AssetBundle文件（也是一种二进制）。但是也有硬伤，就是在移动端无法更新脚本。下面简单的总结下：</p>
  
  </blockquote>
  
  <ul><li>是Unity3D定义的一种二进制类型。</li><li>最好将prefab封装成AseetBundle，不过上面不是才说了在移动端无法更新脚本吗？那从Assetbundle中拿到的Prefab上挂的脚本是不是就无法运行了？也不一定，只要这个prefab上挂的是本地脚本，就可以。</li><li>使用WWW类来下载。</li></ul>
  
  <h5>实例测试</h5>
  
  <p>待续。。。</p>
  
  <p><strong>特别说明：</strong></p>
  
  <blockquote>
   
   <p>本文案例工程使用的Unity编辑器版本为5.1.1</p>
  
  </blockquote>
 
 </div><br><br>作者：young路在脚下<br>链接：http://www.jianshu.com/p/bbc2690bce30<br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8160bace57c895409451706ca9fa4b30/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring MVC 接收POST表单请求，获取参数总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/31a680713b48e153bfbb7edc4fc5fe31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PostgreSQL 日志文件位置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>