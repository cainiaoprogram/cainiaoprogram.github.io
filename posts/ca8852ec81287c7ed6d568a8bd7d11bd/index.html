<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【SpringCloud原理】OpenFeign之FeignClient动态代理生成原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【SpringCloud原理】OpenFeign之FeignClient动态代理生成原理" />
<meta property="og:description" content="前段时间我发布两篇关于nacos源码的文章，一篇是聊一聊nacos是如何进行服务注册的，另一篇是一文带你看懂nacos是如何整合springcloud -- 注册中心篇。今天就继续接着剖析SpringCloud中OpenFeign组件的源码，来聊一聊OpenFeign是如何工作的。至于其他组件的原理，我也会不断的剖析和更新，有需要的同学关注一下微信公众号 三友的java日记。
一、@EnableFeignClinets作用源码剖析
我们都知道，要使用feign，必须要使用@EnableFeignClinets来激活，这个注解其实就是整个feign的入口，接下来我们着重分析一下这个注解干了什么事。 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @Import(FeignClientsRegistrar.class) public @interface EnableFeignClients { } 这个注解通过@Import注解导入一个配置类FeignClientsRegistrar.class，FeignClientsRegistrar实现了ImportBeanDefinitionRegistrar接口，所以Spring Boot在启动的时候，会去调用FeignClientsRegistrar类中的registerBeanDefinitions来动态往spring容器中注入bean。如果有不懂小伙伴可以看一下我以前写过的一篇文章看Spring源码不得不会的@Enable模块驱动实现原理讲解 ，这里详细讲解了@Import注解的作用。
接下来看一下registerBeanDefinitions的实现
@Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) //这个方式是注入一些配置，就是对EnableFeignClients注解属性的解析 registerDefaultConfiguration(metadata, registry); //这个方法是扫秒加了@FeignClient注解 registerFeignClients(metadata, registry); } 这里我们着重分析registerFeignClients，看一看是如何扫描@FeignClient注解的，然后扫描到之后又做了什么。
public void registerFeignClients(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { ClassPathScanningCandidateComponentProvider scanner = getScanner(); scanner.setResourceLoader(this.resourceLoader); Set&lt;String&gt; basePackages; Map&lt;String, Object&gt; attrs = metadata .getAnnotationAttributes(EnableFeignClients.class.getName()); AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter( FeignClient.class); final Class&lt;?&gt;[] clients = attrs == null ? null : (Class&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ca8852ec81287c7ed6d568a8bd7d11bd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-24T21:18:00+08:00" />
<meta property="article:modified_time" content="2022-04-24T21:18:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【SpringCloud原理】OpenFeign之FeignClient动态代理生成原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前段时间我发布两篇关于nacos源码的文章，一篇是<a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;amp;mid=2247483763&amp;amp;idx=1&amp;amp;sn=78c2abadeb849203c5d50567f70c006f&amp;amp;chksm=cfd952bbf8aedbad23f3747c1a6ebf6f43a4a175fca057caeab1fd35b81630460e5b65103719&amp;token=1311460938&amp;lang=zh_CN#rd" rel="nofollow" title="聊一聊nacos是如何进行服务注册的">聊一聊nacos是如何进行服务注册的</a>，另一篇是<a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;amp;mid=2247483806&amp;amp;idx=1&amp;amp;sn=e58729a71ce589347ce3f1f4d83c75d8&amp;amp;chksm=cfd95256f8aedb40eb6cad8d456feeea062a3f9d6b53cf48e63c91dd387cfe9075f4d7a0341f&amp;token=1311460938&amp;lang=zh_CN#rd" rel="nofollow" title="一文带你看懂nacos是如何整合springcloud -- 注册中心篇">一文带你看懂nacos是如何整合springcloud -- 注册中心篇</a>。今天就继续接着剖析SpringCloud中OpenFeign组件的源码，来聊一聊OpenFeign是如何工作的。至于其他组件的原理，我也会不断的剖析和更新，有需要的同学关注一下微信公众号 三友的java日记。</p> 
<p><strong>一、@EnableFeignClinets作用源码剖析</strong></p> 
<p>我们都知道，要使用feign，必须要使用@EnableFeignClinets来激活，这个注解其实就是整个feign的入口，接下来我们着重分析一下这个注解干了什么事。 </p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Import(FeignClientsRegistrar.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableFeignClients {
}</code></pre> 
</div> 
<p>这个注解通过@Import注解导入一个配置类FeignClientsRegistrar.class，FeignClientsRegistrar实现了ImportBeanDefinitionRegistrar接口，所以Spring Boot在启动的时候，会去调用FeignClientsRegistrar类中的registerBeanDefinitions来动态往spring容器中注入bean。如果有不懂小伙伴可以看一下我以前写过的一篇文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;amp;mid=2247484008&amp;amp;idx=1&amp;amp;sn=6756f595a0569b92d6ab5410049f9273&amp;amp;chksm=cfd951a0f8aed8b663d62f2f6b4322b2d4ec6da2d1128e31652eaccd38a7edb91ed5e5901c20&amp;token=1311460938&amp;lang=zh_CN#rd" rel="nofollow" title="看Spring源码不得不会的@Enable模块驱动实现原理讲解">看Spring源码不得不会的@Enable模块驱动实现原理讲解</a> ，这里详细讲解了@Import注解的作用。</p> 
<p>接下来看一下registerBeanDefinitions的实现</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="function_ hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata,
      BeanDefinitionRegistry registry)</span>
    <span class="hljs-comment">//这个方式是注入一些配置，就是对EnableFeignClients注解属性的解析</span>
    registerDefaultConfiguration(metadata, registry);
    <span class="hljs-comment">//这个方法是扫秒加了@FeignClient注解</span>
    registerFeignClients(metadata, registry);
}</code></pre> 
</div> 
<p>这里我们着重分析registerFeignClients，看一看是如何扫描@FeignClient注解的，然后扫描到之后又做了什么。</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="function_ hljs-title">registerFeignClients</span><span class="hljs-params">(AnnotationMetadata metadata,
      BeanDefinitionRegistry registry)</span> {
    <span class="hljs-type">ClassPathScanningCandidateComponentProvider</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> getScanner();
    scanner.setResourceLoader(<span class="hljs-built_in">this</span>.resourceLoader);

    Set&lt;String&gt; basePackages;

    Map&lt;String, Object&gt; attrs = metadata
        .getAnnotationAttributes(EnableFeignClients.class.getName());
    <span class="hljs-type">AnnotationTypeFilter</span> <span class="hljs-variable">annotationTypeFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="class_ hljs-title">AnnotationTypeFilter</span>(
        FeignClient.class);
    <span class="hljs-keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span>
        : (Class&lt;?&gt;[]) attrs.get(<span class="hljs-string">"clients"</span>);
    <span class="hljs-keyword">if</span> (clients == <span class="hljs-literal">null</span> || clients.length == <span class="hljs-number">0</span>) {
      scanner.addIncludeFilter(annotationTypeFilter);
      basePackages = getBasePackages(metadata);
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">final</span> Set&lt;String&gt; clientClasses = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">HashSet</span>&lt;&gt;();
      basePackages = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">HashSet</span>&lt;&gt;();
      <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : clients) {
        basePackages.add(ClassUtils.getPackageName(clazz));
        clientClasses.add(clazz.getCanonicalName());
      }
      <span class="hljs-type">AbstractClassTestingTypeFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="class_ hljs-title">AbstractClassTestingTypeFilter</span>() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="function_ hljs-title">match</span><span class="hljs-params">(ClassMetadata metadata)</span> {
          <span class="hljs-type">String</span> <span class="hljs-variable">cleaned</span> <span class="hljs-operator">=</span> metadata.getClassName().replaceAll(<span class="hljs-string">"\\$"</span>, <span class="hljs-string">"."</span>);
          <span class="hljs-keyword">return</span> clientClasses.contains(cleaned);
        }
      };
      scanner.addIncludeFilter(
          <span class="hljs-keyword">new</span> <span class="class_ hljs-title">AllTypeFilter</span>(Arrays.asList(filter, annotationTypeFilter)));
    }

    <span class="hljs-keyword">for</span> (String basePackage : basePackages) {
      Set&lt;BeanDefinition&gt; candidateComponents = scanner
          .findCandidateComponents(basePackage);
      <span class="hljs-keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) {
        <span class="hljs-keyword">if</span> (candidateComponent <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) {
          <span class="hljs-comment">// verify annotated class is an interface</span>
          <span class="hljs-type">AnnotatedBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> (AnnotatedBeanDefinition) candidateComponent;
          <span class="hljs-type">AnnotationMetadata</span> <span class="hljs-variable">annotationMetadata</span> <span class="hljs-operator">=</span> beanDefinition.getMetadata();
          Assert.isTrue(annotationMetadata.isInterface(),
              <span class="hljs-string">"@FeignClient can only be specified on an interface"</span>);

          Map&lt;String, Object&gt; attributes = annotationMetadata
              .getAnnotationAttributes(
                  FeignClient.class.getCanonicalName());

          <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> getClientName(attributes);
          registerClientConfiguration(registry, name,
              attributes.get(<span class="hljs-string">"configuration"</span>));

          registerFeignClient(registry, annotationMetadata, attributes);
        }
      }
    }
  }</code></pre> 
</div> 
<p>这段代码我分析一下，先获取到了一个ClassPathScanningCandidateComponentProvider这个对象，这个对象是按照一定的规则来扫描指定目录下的类的，符合这个规则的每个类，会生成一个BeanDefinition，不知道BeanDefinition的小伙伴可以看我之前写的关于bean生命周期的文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;amp;mid=2247483709&amp;amp;idx=1&amp;amp;sn=9309f50cdc546d3be4beeb98b665589f&amp;amp;chksm=cfd952f5f8aedbe3d77549be444e184d51e1953328bea140bfa688b5f1f0adf03eb03464b65a&amp;token=1311460938&amp;lang=zh_CN#rd" rel="nofollow" title="Spring bean到底是如何创建的？（下）">Spring bean到底是如何创建的？（下）</a> 和 ，<a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;amp;mid=2247483709&amp;amp;idx=1&amp;amp;sn=9309f50cdc546d3be4beeb98b665589f&amp;amp;chksm=cfd952f5f8aedbe3d77549be444e184d51e1953328bea140bfa688b5f1f0adf03eb03464b65a&amp;token=1311460938&amp;lang=zh_CN#rd" rel="nofollow" title="Spring bean到底是如何创建的？（下）">Spring bean到底是如何创建的？（下）</a>里面有过对BeanDefinition的描述。</p> 
<p>获取到ClassPathScanningCandidateComponentProvider对象，配置这个对象，指定这个对象需要扫描出来标有@FeignClient注解的类；随后解析EnableFeignClients注解，获取内部的属性，获取到指定的需要扫描包路径下，如果没有指定的，那么就默认是当前注解所在类的所在目录及子目录。</p> 
<p>然后就遍历每个目录，找到每个标有@FeignClient注解的类，对每个类就生成一个BeanDefinition，可以把BeanDefinition看成对每个标有@FeignClient注解的类信息的封装。</p> 
<p>拿到一堆BeanDefinition之后，会遍历BeanDefinition，然后调用registerClientConfiguration和registerFeignClient方法。</p> 
<p>接下来我分别剖析一下这两个方法的作用</p> 
<p>registerClientConfiguration：</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="function_ hljs-title">registerClientConfiguration</span><span class="hljs-params">(BeanDefinitionRegistry registry, Object name,
      Object configuration)</span> {
    <span class="hljs-type">BeanDefinitionBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder
        .genericBeanDefinition(FeignClientSpecification.class);
    builder.addConstructorArgValue(name);
    builder.addConstructorArgValue(configuration);
    registry.registerBeanDefinition(
        name + <span class="hljs-string">"."</span> + FeignClientSpecification.class.getSimpleName(),
        builder.getBeanDefinition());
  }
</code></pre> 
</div> 
<p>这里的作用就是拿出你再@FeignClient指定的配置类，也就是configuration属性，然后构建一个bean class为FeignClientSpecification，传入配置。这个类的最主要作用就是将每个Feign的客户端的配置类封装成一个FeignClientSpecification的BeanDefinition，注册到spring容器中。记住这个FeignClientSpecification，后面会有用。</p> 
<p>registerFeignClient：</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="function_ hljs-title">registerFeignClient</span><span class="hljs-params">(BeanDefinitionRegistry registry,
      AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> annotationMetadata.getClassName();
    <span class="hljs-type">BeanDefinitionBuilder</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder
        .genericBeanDefinition(FeignClientFactoryBean.class);
    validate(attributes);
    definition.addPropertyValue(<span class="hljs-string">"url"</span>, getUrl(attributes));
    definition.addPropertyValue(<span class="hljs-string">"path"</span>, getPath(attributes));
    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> getName(attributes);
    definition.addPropertyValue(<span class="hljs-string">"name"</span>, name);
    <span class="hljs-type">String</span> <span class="hljs-variable">contextId</span> <span class="hljs-operator">=</span> getContextId(attributes);
    definition.addPropertyValue(<span class="hljs-string">"contextId"</span>, contextId);
    definition.addPropertyValue(<span class="hljs-string">"type"</span>, className);
    definition.addPropertyValue(<span class="hljs-string">"decode404"</span>, attributes.get(<span class="hljs-string">"decode404"</span>));
    definition.addPropertyValue(<span class="hljs-string">"fallback"</span>, attributes.get(<span class="hljs-string">"fallback"</span>));
    definition.addPropertyValue(<span class="hljs-string">"fallbackFactory"</span>, attributes.get(<span class="hljs-string">"fallbackFactory"</span>));
    definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);

    <span class="hljs-type">String</span> <span class="hljs-variable">alias</span> <span class="hljs-operator">=</span> contextId + <span class="hljs-string">"FeignClient"</span>;
    <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> definition.getBeanDefinition();

    <span class="hljs-type">boolean</span> <span class="hljs-variable">primary</span> <span class="hljs-operator">=</span> (Boolean) attributes.get(<span class="hljs-string">"primary"</span>); <span class="hljs-comment">// has a default, won't be</span>
                                <span class="hljs-comment">// null</span>

    beanDefinition.setPrimary(primary);

    <span class="hljs-type">String</span> <span class="hljs-variable">qualifier</span> <span class="hljs-operator">=</span> getQualifier(attributes);
    <span class="hljs-keyword">if</span> (StringUtils.hasText(qualifier)) {
      alias = qualifier;
    }

    <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="class_ hljs-title">BeanDefinitionHolder</span>(beanDefinition, className,
        <span class="hljs-keyword">new</span> <span class="class_ hljs-title">String</span>[] { alias });
    BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);
}</code></pre> 
</div> 
<p>registerFeignClient这个方法很重要，我来说一下大概做了哪些事。重新构造了一个BeanDefinition，这个BeanDefinition的指定的class类型是FeignClientFactoryBean，这个类实现了FactoryBean接口，对spring有一定了解的小伙伴应该知道，spring在生成bean的时候，判断BeanDefinition中bean的class如果是FactoryBean的实现的话，会调用这个实现类的getObject来获取对象，这里我就不展开讲了，不了解的同学可以记住这个结论。</p> 
<p>到这一步，@EnableFeignClinets的作用就说完了。这个类的主要作用是扫描指定（不指定就默认路径下的）所有加了@FeignClient注解的类，然后每个类都会生成一个BeanDefinition，随后遍历每个BeanDefinition，然后取出每个@FeignClient注解的属性，构造新的BeanDefinition，传入FeignClientFactoryBean的class，随后注入到spring容器中；同时有配置类的也会将配置类构件出一个bean class为FeignClientSpecification的BeanDefinition注入到spring容器中。</p> 
<p>为了便于理解，我这里画个图来总结一下这个注解干了什么事。</p> 
<div> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/91/20/ix30HQJx_o.png"><span title="点击并拖拽以改变尺寸">​</span></p> 
</div> 
<p><strong>二、Feign客户端接口动态代理的生成源码剖析</strong></p> 
<p><strong>（1）FeignAutoConfiguration源码剖析</strong></p> 
<p>FeignAutoConfiguration是feign在整个springcloud的配置类，我拎出这里面比较核心的代码。</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-meta">@Autowired(required = false)</span>
<span class="hljs-keyword">private</span> List&lt;FeignClientSpecification&gt; configurations = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">ArrayList</span>&lt;&gt;();
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> FeignContext <span class="function_ hljs-title">feignContext</span><span class="hljs-params">()</span> {
    <span class="hljs-type">FeignContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="class_ hljs-title">FeignContext</span>();
    context.setConfigurations(<span class="hljs-built_in">this</span>.configurations);
    <span class="hljs-keyword">return</span> context;
}</code></pre> 
</div> 
<p>注入了一堆FeignClientSpecification，FeignClientSpecification这玩意就是上文提到的调用registerClientConfiguration的时候注入到spring容器中的，一个Feign客户端的配置一个FeignClientSpecification，所以是个集合，然后封装到FeignContext中，最后将FeignContext注入到spring容器中。</p> 
<p>FeignContext也是很重要的一个东西，我们来分析一下它的源码</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="class_ hljs-title">FeignContext</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title">NamedContextFactory</span>&lt;FeignClientSpecification&gt; {
  <span class="hljs-keyword">public</span> <span class="function_ hljs-title">FeignContext</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">super</span>(FeignClientsConfiguration.class, <span class="hljs-string">"feign"</span>, <span class="hljs-string">"feign.client.name"</span>);
  }

}</code></pre> 
</div> 
<p>FeignContext继承了NamedContextFactory，构造的时候，传入了FeignClientsConfiguration，这个玩意也很重要，别急，我们慢慢来分析它们的作用。</p> 
<p><strong>（2）NamedContextFactory源码剖析</strong></p> 
<p>我先来说结论，NamedContextFactory的作用是用来进行配置隔离的，ribbon和feign的配置隔离都依赖这个抽象类。</p> 
<p>何为配置隔离，因为每个Feign客户端都有可能有自己的配置，从@FeignClient注解的属性configuration可以看出，所以写了这个类，用来隔离每个客户端的配置，这就是为什么在构造FeignContext传入一堆FeignClientSpecification的原因，这里封装了每个客户端的配置类。</p> 
<p>那是怎么实现的呢，我拎出来一部分核心的源码，不重要的我就忽略了。</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="class_ hljs-title">NamedContextFactory</span>&lt;C <span class="hljs-keyword">extends</span> <span class="class_ hljs-title">NamedContextFactory</span>.Specification&gt;
    <span class="hljs-keyword">implements</span> <span class="class_ hljs-title">DisposableBean</span>, ApplicationContextAware {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String propertySourceName;

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String propertyName;

  <span class="hljs-keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">ConcurrentHashMap</span>&lt;&gt;();
  <span class="hljs-keyword">private</span> Map&lt;String, C&gt; configurations = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">ConcurrentHashMap</span>&lt;&gt;();
  
  <span class="hljs-comment">//父类 ApplicationContext ，也就是springboot所使用的ApplicationContext</span>
  <span class="hljs-keyword">private</span> ApplicationContext parent;
  <span class="hljs-comment">// 这个是默认的额配置类</span>
  <span class="hljs-keyword">private</span> Class&lt;?&gt; defaultConfigType;

  <span class="hljs-keyword">public</span> <span class="function_ hljs-title">NamedContextFactory</span><span class="hljs-params">(Class&lt;?&gt; defaultConfigType, String propertySourceName,
      String propertyName)</span> {
    <span class="hljs-built_in">this</span>.defaultConfigType = defaultConfigType;
    <span class="hljs-built_in">this</span>.propertySourceName = propertySourceName;
    <span class="hljs-built_in">this</span>.propertyName = propertyName;
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="function_ hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext parent)</span> <span class="hljs-keyword">throws</span> BeansException {
    <span class="hljs-built_in">this</span>.parent = parent;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="function_ hljs-title">setConfigurations</span><span class="hljs-params">(List&lt;C&gt; configurations)</span> {
    <span class="hljs-keyword">for</span> (C client : configurations) {
      <span class="hljs-built_in">this</span>.configurations.put(client.getName(), client);
    }
  }

  <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="function_ hljs-title">getContextNames</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="class_ hljs-title">HashSet</span>&lt;&gt;(<span class="hljs-built_in">this</span>.contexts.keySet());
  }

  <span class="hljs-keyword">protected</span> AnnotationConfigApplicationContext <span class="function_ hljs-title">getContext</span><span class="hljs-params">(String name)</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.contexts.containsKey(name)) {
      <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.contexts) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.contexts.containsKey(name)) {
          <span class="hljs-built_in">this</span>.contexts.put(name, createContext(name));
        }
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.contexts.get(name);
  }

  <span class="hljs-keyword">protected</span> AnnotationConfigApplicationContext <span class="function_ hljs-title">createContext</span><span class="hljs-params">(String name)</span> {
    <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="class_ hljs-title">AnnotationConfigApplicationContext</span>();
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.configurations.containsKey(name)) {
      <span class="hljs-keyword">for</span> (Class&lt;?&gt; configuration : <span class="hljs-built_in">this</span>.configurations.get(name)
          .getConfiguration()) {
        context.register(configuration);
      }
    }
    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="hljs-built_in">this</span>.configurations.entrySet()) {
      <span class="hljs-keyword">if</span> (entry.getKey().startsWith(<span class="hljs-string">"default."</span>)) {
        <span class="hljs-keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) {
          context.register(configuration);
        }
      }
    }
    context.register(PropertyPlaceholderAutoConfiguration.class,
        <span class="hljs-built_in">this</span>.defaultConfigType);
    context.getEnvironment().getPropertySources().addFirst(<span class="hljs-keyword">new</span> <span class="class_ hljs-title">MapPropertySource</span>(
        <span class="hljs-built_in">this</span>.propertySourceName,
        Collections.&lt;String, Object&gt;singletonMap(<span class="hljs-built_in">this</span>.propertyName, name)));
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.parent != <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// Uses Environment from parent as well as beans</span>
      context.setParent(<span class="hljs-built_in">this</span>.parent);
      <span class="hljs-comment">// jdk11 issue</span>
      <span class="hljs-comment">// https://github.com/spring-cloud/spring-cloud-netflix/issues/3101</span>
      context.setClassLoader(<span class="hljs-built_in">this</span>.parent.getClassLoader());
    }
    context.setDisplayName(generateDisplayName(name));
    context.refresh();
    <span class="hljs-keyword">return</span> context;
  }
  
  <span class="hljs-comment">/**
   * Specification with name and configuration.
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="class_ hljs-title">Specification</span> {

    String <span class="function_ hljs-title">getName</span><span class="hljs-params">()</span>;

    Class&lt;?&gt;[] getConfiguration();

  }

}</code></pre> 
</div> 
<p>分析一下每个成员变量的作用：</p> 
<p>contexts：一个客户端一个对应的AnnotationConfigApplicationContext</p> 
<p>configurations:一个客户端一个配置类的封装，对应到Feign的就是FeignClientSpecification</p> 
<p>parent：springboot真正启动的就是这个ApplicationContext</p> 
<p>defaultConfigType：默认的配置类，对应Feign就是构造FeignContext是传入的FeignClientsConfiguration</p> 
<p>分析一下核心的方法：</p> 
<p>getContext：这个方法很简单，就是根据客户端名称从contexts获取对应的AnnotationConfigApplicationContext，获取不到就去创建一个，然后放入contexts</p> 
<p>createContext：就是直接new了一个AnnotationConfigApplicationContext对象，然后按照按照配置的优先级顺序，一步步放入配置类，最后放入parent容器，也就是说每个客户端对应的容器，都有一个共同的父容器，同时如果每个客户端对应的容器获取不到的配置，都会再次从父容器中获取。这个结论还是很重要的。</p> 
<p>其实所谓的配置隔离就是为每个客户端构建一个AnnotationConfigApplicationContext，然后基于这个ApplicationContext来解析配置类，这样就实现了配置隔离。</p> 
<p>不知道大家有么有遇到过这个坑，就是在spring cloud环境中，监听类似ContextRefreshedEvent这种事件的时候，这个事件会无缘无故地触发很多次，其实就是这个原因就在这，因为spring的事件是有传播机制的，每个客户端对应的容器都要进行refresh，refresh完就会发这个事件，然后这个事件就会传给parent容器，也就是springboot启动的容器，就会再次触发，所以如果客户端很多，那么就会触发很多次。解决办法就是进行唯一性校验，只能启动一次就行了。</p> 
<p><strong>（3）FeignClientsConfiguration源码剖析</strong></p> 
<p>说完NamedContextFactory，接下来我们说一下FeignClientsConfiguration的作用。</p> 
<p>这是一个默认的配置类，里面配置了很多bean，这些bean都是生成Feign客户端动态代理的需要的，我说几个重要的。</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@ConditionalOnMissingBean</span>
<span class="hljs-keyword">public</span> Contract <span class="function_ hljs-title">feignContract</span><span class="hljs-params">(ConversionService feignConversionService)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="class_ hljs-title">SpringMvcContract</span>(<span class="hljs-built_in">this</span>.parameterProcessors, feignConversionService);
}</code></pre> 
</div> 
<p>这个的主要作用是用来解析@FeignClient接口中每个方法使用的springmvc的注解的，这也就是为什么FeignClient可以识别springmvc注解的原因。</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@Scope("prototype")</span>
<span class="hljs-meta">@ConditionalOnMissingBean</span>
<span class="hljs-keyword">public</span> Feign.Builder <span class="function_ hljs-title">feignBuilder</span><span class="hljs-params">(Retryer retryer)</span> {
    <span class="hljs-keyword">return</span> Feign.builder().retryer(retryer);
}</code></pre> 
</div> 
<p>用来构建动态代理的类，通过这个类的target方法，就能生成Feign动态代理</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span>
<span class="hljs-meta">@ConditionalOnClass({ HystrixCommand.class, HystrixFeign.class })</span>
  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="class_ hljs-title">HystrixFeignConfiguration</span> {

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Scope("prototype")</span>
    <span class="hljs-meta">@ConditionalOnMissingBean</span>
    <span class="hljs-meta">@ConditionalOnProperty(name = "feign.hystrix.enabled")</span>
    <span class="hljs-keyword">public</span> Feign.Builder <span class="function_ hljs-title">feignHystrixBuilder</span><span class="hljs-params">()</span> {
      <span class="hljs-keyword">return</span> HystrixFeign.builder();
    }

}</code></pre> 
</div> 
<p>这个是FeignClientsConfiguration的内部类，是用来整合hystrix的，@ConditionalOnProperty(name = "feign.hystrix.enabled")，当在配置文件配置了feign.hystrix.enabled=true的时候，就开启了hystrix整合了Feign，然后调用Feign的接口就有了限流、降级的功能。其实hystrix整合Feign很简单，就是在构造动态代理的时候加了点东西而已。其实不光是hystrix，spring cloud alibaba中的sentinel在整合Feign的适合也是按照这个套路来的。</p> 
<p><strong>（4）构建动态代理的过程源码剖析</strong></p> 
<p>说完了前置的内容，接下来我们就来看一看动态代理是如何生成的。从上面我们已经知道了，@EnableFeignClinets会扫描出每个加了@FeignClient注解的接口，然后生成对应的BeanDefinition，最后重新生成一个bean class为FeignClientFactoryBean的BeanDefinition，注册到spring容器。</p> 
<p>接下来就会根据BeanDefinition来生成feign客户端的代理对象了。上面我提到，是通过FeignClientFactoryBean的getObject方法来获取到代理对象，接下来，我们就来着重分析一下getObject方法的实现。</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Object <span class="function_ hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
    <span class="hljs-keyword">return</span> getTarget();
}</code></pre> 
</div> 
<p>getObject是调用getTarget()来获取代理对象的。</p> 
<p>getTarget方法</p> 
<div> 
 <pre><code class="hljs language-java">&lt;T&gt; T <span class="function_ hljs-title">getTarget</span><span class="hljs-params">()</span> {
    <span class="hljs-type">FeignContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationContext.getBean(FeignContext.class);
    Feign.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> feign(context);

    <span class="hljs-keyword">if</span> (!StringUtils.hasText(<span class="hljs-built_in">this</span>.url)) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.name.startsWith(<span class="hljs-string">"http"</span>)) {
        <span class="hljs-built_in">this</span>.url = <span class="hljs-string">"http://"</span> + <span class="hljs-built_in">this</span>.name;
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">this</span>.url = <span class="hljs-built_in">this</span>.name;
      }
      <span class="hljs-built_in">this</span>.url += cleanPath();
      <span class="hljs-keyword">return</span> (T) loadBalance(builder, context,
          <span class="hljs-keyword">new</span> <span class="class_ hljs-title">HardCodedTarget</span>&lt;&gt;(<span class="hljs-built_in">this</span>.type, <span class="hljs-built_in">this</span>.name, <span class="hljs-built_in">this</span>.url));
    }
    <span class="hljs-keyword">if</span> (StringUtils.hasText(<span class="hljs-built_in">this</span>.url) &amp;&amp; !<span class="hljs-built_in">this</span>.url.startsWith(<span class="hljs-string">"http"</span>)) {
      <span class="hljs-built_in">this</span>.url = <span class="hljs-string">"http://"</span> + <span class="hljs-built_in">this</span>.url;
    }
    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.url + cleanPath();
    <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> getOptional(context, Client.class);
    <span class="hljs-keyword">if</span> (client != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (client <span class="hljs-keyword">instanceof</span> LoadBalancerFeignClient) {
        <span class="hljs-comment">// not load balancing because we have a url,</span>
        <span class="hljs-comment">// but ribbon is on the classpath, so unwrap</span>
        client = ((LoadBalancerFeignClient) client).getDelegate();
      }
      <span class="hljs-keyword">if</span> (client <span class="hljs-keyword">instanceof</span> FeignBlockingLoadBalancerClient) {
        <span class="hljs-comment">// not load balancing because we have a url,</span>
        <span class="hljs-comment">// but Spring Cloud LoadBalancer is on the classpath, so unwrap</span>
        client = ((FeignBlockingLoadBalancerClient) client).getDelegate();
      }
      builder.client(client);
    }
    <span class="hljs-type">Targeter</span> <span class="hljs-variable">targeter</span> <span class="hljs-operator">=</span> get(context, Targeter.class);
    <span class="hljs-keyword">return</span> (T) targeter.target(<span class="hljs-built_in">this</span>, builder, context,
        <span class="hljs-keyword">new</span> <span class="class_ hljs-title">HardCodedTarget</span>&lt;&gt;(<span class="hljs-built_in">this</span>.type, <span class="hljs-built_in">this</span>.name, url));
  }</code></pre> 
</div> 
<p>先从ioc容器中获取到FeignContext,FeignContext里面封装了每个Feign的配置，起到配置隔离的作用。</p> 
<p>然后获取到一个Feign.Builder，默认是在FeignClientsConfiguration中配置的。然后调用feign方法。</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-keyword">protected</span> Feign.Builder <span class="function_ hljs-title">feign</span><span class="hljs-params">(FeignContext context)</span> {
    <span class="hljs-type">FeignLoggerFactory</span> <span class="hljs-variable">loggerFactory</span> <span class="hljs-operator">=</span> get(context, FeignLoggerFactory.class);
    <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> loggerFactory.create(<span class="hljs-built_in">this</span>.type);

    <span class="hljs-comment">// @formatter:off</span>
    Feign.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> get(context, Feign.Builder.class)
        <span class="hljs-comment">// required values</span>
        .logger(logger)
        .encoder(get(context, Encoder.class))
        .decoder(get(context, Decoder.class))
        .contract(get(context, Contract.class));
    <span class="hljs-comment">// @formatter:on</span>

    <span class="hljs-comment">//这个是从配置文件中读取feign的配置</span>
    configureFeign(context, builder);

    <span class="hljs-keyword">return</span> builder;
  }</code></pre> 
</div> 
<p>这个方法很简单，就是从每个FeignClient对应的ioc容器中获取到对应的组件，填充到 Feign.Builder中，默认都是FeignClientsConfiguration配置的。configureFeign这个方法不用去care它，它是默认从配置文件读取feign的配置，然后对Feign.Builder进行配置，有可能会覆盖从每个FeignClient对应的ioc容器中获取到对应的组件，所以配置文件的优先级是最高的，但是一般没人这么玩，所以就不用care。</p> 
<p>上面获取到的各种组件都是默认的，如果你有需要替换什么组件，都可以实现，然后通过@FeignClient的configuration配置，就可以替换这些组件。</p> 
<p>接下来就是走这段代码</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-keyword">if</span> (!StringUtils.hasText(<span class="hljs-built_in">this</span>.url)) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.name.startsWith(<span class="hljs-string">"http"</span>)) {
        <span class="hljs-built_in">this</span>.url = <span class="hljs-string">"http://"</span> + <span class="hljs-built_in">this</span>.name;
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">this</span>.url = <span class="hljs-built_in">this</span>.name;
      }
      <span class="hljs-built_in">this</span>.url += cleanPath();
      <span class="hljs-keyword">return</span> (T) loadBalance(builder, context,
          <span class="hljs-keyword">new</span> <span class="class_ hljs-title">HardCodedTarget</span>&lt;&gt;(<span class="hljs-built_in">this</span>.type, <span class="hljs-built_in">this</span>.name, <span class="hljs-built_in">this</span>.url));
}</code></pre> 
</div> 
<p>这段代码就是判断你有没有指定url，url在哪指定的呢，就是在@FeignClient注解中指定的url属性，这个属性是主要是进行feign直连，什么叫直连，就是不通过注册中心，直接访问服务提供者，这个url就是配置服务提供者的ip和端口。在springcloud环境下，一般这个是不配置的，因为得从注册中心发现服务所在的ip和端口列表。所以从这y也可以看出，没有注册中心，feign也是能够跑的，只要指定服务提供者的ip和端口就行。</p> 
<p>所以，一般这个url是空的，也就是会进入这段代码。其实很简单，就是配置一个url，name是服务名，也是在@FeignClient配置的。那这段代码什么意思呢，举个例子来说，假如你的服务名是ServiceA，那么拼出来就是 <a href="https://link.zhihu.com/?target=http%3A//ServiceA" rel="nofollow" title="http://ServiceA">Spring bean到底是如何创建的？（下）</a> ，就是这么简单。得到url之后就会走loadBalance方法，传入一个HardCodedTarget参数，这个参数是封装了Feign客户端接口的类型、服务的名称、还有刚构建的url，接下来进入loadBalance。</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="function_ hljs-title">loadBalance</span><span class="hljs-params">(Feign.Builder builder, FeignContext context,
      HardCodedTarget&lt;T&gt; target)</span> {
    <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> getOptional(context, Client.class);
    <span class="hljs-keyword">if</span> (client != <span class="hljs-literal">null</span>) {
      builder.client(client);
      <span class="hljs-type">Targeter</span> <span class="hljs-variable">targeter</span> <span class="hljs-operator">=</span> get(context, Targeter.class);
      <span class="hljs-keyword">return</span> targeter.target(<span class="hljs-built_in">this</span>, builder, context, target);
    }

    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="class_ hljs-title">IllegalStateException</span>(
        <span class="hljs-string">"No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?"</span>);
  }</code></pre> 
</div> 
<p>这个方法一上来就从feign客户端对应的ioc容器中获取一个Client，但是FeignClientsConfiguration里面没有配置Client这个bean，那是从哪来呢？</p> 
<p>其实loadBalance这个方法名让你想到了什么？当然是负载均衡啦，所以Client需要整合负载均衡的功能，说到负载均衡，当前优先想到ribbon，所以就引入了FeignRibbonClientAutoConfiguration这个配置类，这个类是Feign整合ribbon的配置类，这里我就先不多说，后面再写一篇文章来剖析ribbon的原理和feign整合ribbon的原理。当然目前来说，负载均衡组件不止ribbon，还有springcloud自己实现的spring-cloud-starter-loadbalancer这个组件，其实原理都是一样的。</p> 
<p>这里你就默认获取到了Client，那么接下来就放入Feign.Builder中，接下来获取到Targeter，Targeter是通过FeignAutoConfiguration来配置的，默认是DefaultTargeter，如果整合hystrix就需是HystrixTargeter，当然这里就是默认的DefaultTargeter。</p> 
<p>接下来就会调用DefaultTargeter的target方法</p> 
<div> 
 <pre><code class="hljs language-java"> <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="function_ hljs-title">target</span><span class="hljs-params">(FeignClientFactoryBean factory, Feign.Builder feign,
      FeignContext context, Target.HardCodedTarget&lt;T&gt; target)</span> {
    <span class="hljs-keyword">return</span> feign.target(target);
  }</code></pre> 
</div> 
<p>就是直接调用Feign.Builder的tartget方法，那么就进入这个方法</p> 
<div> 
 <pre><code class="hljs language-java">    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="function_ hljs-title">target</span><span class="hljs-params">(Target&lt;T&gt; target)</span> {
      <span class="hljs-keyword">return</span> build().newInstance(target);
    }

    <span class="hljs-keyword">public</span> Feign <span class="function_ hljs-title">build</span><span class="hljs-params">()</span> {
      SynchronousMethodHandler.<span class="hljs-type">Factory</span> <span class="hljs-variable">synchronousMethodHandlerFactory</span> <span class="hljs-operator">=</span>
          <span class="hljs-keyword">new</span> <span class="class_ hljs-title">SynchronousMethodHandler</span>.Factory(client, retryer, requestInterceptors, logger,
              logLevel, decode404, closeAfterDecode, propagationPolicy);
      <span class="hljs-type">ParseHandlersByName</span> <span class="hljs-variable">handlersByName</span> <span class="hljs-operator">=</span>
          <span class="hljs-keyword">new</span> <span class="class_ hljs-title">ParseHandlersByName</span>(contract, options, encoder, decoder, queryMapEncoder,
              errorDecoder, synchronousMethodHandlerFactory);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="class_ hljs-title">ReflectiveFeign</span>(handlersByName, invocationHandlerFactory, queryMapEncoder);
    }</code></pre> 
</div> 
<p>先调用build方法，这个方法就是将最开始填充到Feign.Builder给封装起来，构建了一个ReflectiveFeign，然后调用ReflectiveFeign的newInstance方法，传入Target&lt;T&gt; target，也就是前面传入的HardCodedTarget。</p> 
<div> 
 <pre><code class="hljs language-java"><span class="hljs-meta">@SuppressWarnings("unchecked")</span>
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="function_ hljs-title">newInstance</span><span class="hljs-params">(Target&lt;T&gt; target)</span> {
    Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);
    Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">LinkedHashMap</span>&lt;Method, MethodHandler&gt;();
    List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">LinkedList</span>&lt;DefaultMethodHandler&gt;();

    <span class="hljs-keyword">for</span> (Method method : target.type().getMethods()) {
      <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) {
        <span class="hljs-keyword">continue</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Util.isDefault(method)) {
        <span class="hljs-type">DefaultMethodHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="class_ hljs-title">DefaultMethodHandler</span>(method);
        defaultMethodHandlers.add(handler);
        methodToHandler.put(method, handler);
      } <span class="hljs-keyword">else</span> {
        methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));
      }
    }
    <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> factory.create(target, methodToHandler);
    <span class="hljs-type">T</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (T) Proxy.newProxyInstance(target.type().getClassLoader(),
        <span class="hljs-keyword">new</span> <span class="class_ hljs-title">Class</span>&lt;?&gt;[] {target.type()}, handler);

    <span class="hljs-keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) {
      defaultMethodHandler.bindTo(proxy);
    }
    <span class="hljs-keyword">return</span> proxy;
  }</code></pre> 
</div> 
<p>这个方法我来解释一下是来干什么的，其实很简单，通过Target拿到接口的类型，然后获取到所有的方法，遍历每个方法，处理之后放入methodToHandler中，然后通过InvocationHandlerFactory的create方法，传入methodToHandler和Target，获取到一个InvocationHandler，之后通过jdk的动态代理，生成一个代理对象，然后返回回去。InvocationHandler默认是ReflectiveFeign.FeignInvocationHandler，这里我就不再继续翻下去了。</p> 
<p>走到这里，我们终于看到了Feign客户端动态代理的生成，整个构造过程还是很复杂的。这里我总结一下代理对象生成的过程，每个Feign客户端都有对应的一个spring容器，用来解析配置类，根据配置从容器获取到一个Feign.Builder，然后再从容器中获取每个组件，填充到Feign.Builder中，最后通过Feign.Builder的build方法来构造动态代理，构造的过程其实是属于feign包底下的。</p> 
<p><strong>三、总结</strong></p> 
<p>本文主要是讲述了，在SpringCloud环境下，OpenFeign对于Feign客户端动态代理的的构造过程。最开始讲解了@EnableFeignClinets注解的作用开始，随后剖析了FeignAutoConfiguration和FeignClientsConfiguration配置类，同时提到了Feign对每个客户端都进行了配置的隔离，最后通过剖析FeignClientFactoryBean的getObject方法，来一步一步屡清楚动态代理的构建过程。</p> 
<p>至于OpenFeign是如何跟ribbon整合的，以及其他SpringCloud组件的原理，我会单独再写几篇文章来剖析，如有需要，欢迎关注微信公众号 三友的java日记 ，好文不错过。</p> 
<p>最后画一张图，来总结一下本文。</p> 
<div> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/11/da/H9ueeJLO_o.png"><span title="点击并拖拽以改变尺寸">​</span></p> 
</div> 
<p>以上就是本篇文章的全部内容，如果你有什么不懂或者想要交流的地方，欢迎关注我的个人的微信公众号 <strong>三友的java日记</strong> 或者添加我的微信 <strong>ZZYNKXJH</strong> 联系我，我们下篇文章再见。</p> 
<p>如果觉得这篇文章对你有所帮助，还请帮忙点赞、在看、转发一下，码字不易，非常感谢！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac83d27ac80af3f72abbec76decea680/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C-数据结构与算法】顺序栈</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f0791be1103cbd1e7b2fb0d0984aa188/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C-数据结构与算法】循环队列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>