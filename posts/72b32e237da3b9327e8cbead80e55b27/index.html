<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java Integer之IntegerCache - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java Integer之IntegerCache" />
<meta property="og:description" content="前两天看了篇帖子，两个Integer对象做比较时，会产生意想不到的结果。想起之前也有遇到这样的情况，一直没有总结，今天简单记录一下。
相信大家一定遇到过这样的问题：==与equals有什么不同？
两者都需要区分基本数据类型与非基本数据类型。
对于==来说，如果是基本数据类型则比较值是否相等，如果是（非基本数据类型）对象则比较指向该对象的引用是否相等。
举个小例子：
Integer a = 100; Integer b = 100; System.out.println(a == b);// true Integer c = 1000; Integer d = 1000; System.out.println(c == d);// false 然而
int e = 1000; int f = 1000; System.out.println(e == f);// true 那么为什么呢？
Java的8中基本类型分别是：byte、short、int、long、float、double、char和boolean。
Integer作为int类型的包装类型，并不属于Java中的8种基本类型。在Java中，除了上面的这8种类型，其他的类型都是对象，保存的是引用，而非数据本身。
至于为什么两次比较的结果不一致，暂且别急，先看看下面的问题：
Integer a = 1000; Integer a = new Integer(1000); // 这两者的区别在哪里？ 区别：
内存使用：对于较小的整数值（在缓存范围内），使用自动装箱的方式可以节省内存空间，而使用显式的构造函数调用方式则会在堆内存中为每个新创建的对象分配不同的内存空间。
对象的唯一性：对于较小的整数值（在缓存范围内），使用自动装箱的方式，每次使用相同的值创建的Integer对象都是同一个对象。而对于较大的整数值，无论使用哪种方式，每次创建的Integer对象都是不同的。
性能：对于较小的整数值（在缓存范围内），自动装箱的方式由于使用了缓存机制，创建和比较对象的速度更快。对于较大的整数值，自动装箱和显式构造函数调用方式都需要在堆内存中分配新的对象，性能相对较低。
对于前者来说，当你将一个基本类型值直接赋给一个包装类型的变量时，编译器会自动进行装箱操作，将基本类型值包装成对应的包装类型对象。
而后者这种方式使用了显式的构造函数调用。在这种情况下，通过使用构造函数new Integer(1000)来创建一个新的Integer对象。这种方式会在堆内存中为每个新创建的对象分配不同的内存空间，即使两个Integer对象的值相同。
要注意的是，前者写法并不是后者的简写形式。对后者来说其正确的简写形式为：
Integer a = Integer.valueOf(1000); 在定义对象a和b时，Java自动调用了Integer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/72b32e237da3b9327e8cbead80e55b27/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T10:54:34+08:00" />
<meta property="article:modified_time" content="2024-01-03T10:54:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java Integer之IntegerCache</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        前两天看了篇帖子，两个Integer对象做比较时，会产生意想不到的结果。想起之前也有遇到这样的情况，一直没有总结，今天简单记录一下。</p> 
<p>相信大家一定遇到过这样的问题：==与equals有什么不同？</p> 
<p>        两者都需要区分基本数据类型与非基本数据类型。</p> 
<p>        对于==来说，如果是基本数据类型则比较值是否相等，如果是（非基本数据类型）对象则比较指向该对象的引用是否相等。</p> 
<p>举个小例子：</p> 
<pre><code class="language-java">Integer a = 100;
Integer b = 100;
System.out.println(a == b);// true

Integer c = 1000;
Integer d = 1000;
System.out.println(c == d);// false</code></pre> 
<p>然而</p> 
<pre><code class="language-java">int e = 1000;
int f = 1000;
System.out.println(e == f);// true</code></pre> 
<p>那么为什么呢？</p> 
<p>        Java的8中基本类型分别是：byte、short、int、long、float、double、char和boolean。</p> 
<p>        Integer作为int类型的包装类型，并不属于Java中的8种基本类型。在Java中，除了上面的这8种类型，其他的类型都是对象，保存的是引用，而非数据本身。</p> 
<p>        至于为什么两次比较的结果不一致，暂且别急，先看看下面的问题：</p> 
<pre><code class="language-java">Integer a = 1000;

Integer a = new Integer(1000);

// 这两者的区别在哪里？</code></pre> 
<p>区别：</p> 
<ul><li> <p>内存使用：对于较小的整数值（在缓存范围内），使用自动装箱的方式可以节省内存空间，而使用显式的构造函数调用方式则会在堆内存中为每个新创建的对象分配不同的内存空间。</p> </li><li> <p>对象的唯一性：对于较小的整数值（在缓存范围内），使用自动装箱的方式，每次使用相同的值创建的Integer对象都是同一个对象。而对于较大的整数值，无论使用哪种方式，每次创建的Integer对象都是不同的。</p> </li><li> <p>性能：对于较小的整数值（在缓存范围内），自动装箱的方式由于使用了缓存机制，创建和比较对象的速度更快。对于较大的整数值，自动装箱和显式构造函数调用方式都需要在堆内存中分配新的对象，性能相对较低。</p> </li></ul> 
<p>        对于前者来说，当你将一个基本类型值直接赋给一个包装类型的变量时，编译器会自动进行装箱操作，将基本类型值包装成对应的包装类型对象。</p> 
<p>        而后者这种方式使用了显式的构造函数调用。在这种情况下，通过使用构造函数new Integer(1000)来创建一个新的Integer对象。这种方式会在堆内存中为每个新创建的对象分配不同的内存空间，即使两个Integer对象的值相同。</p> 
<p>        要注意的是，前者写法并不是后者的简写形式。对后者来说其正确的简写形式为：</p> 
<pre><code class="language-java">Integer a = Integer.valueOf(1000);</code></pre> 
<p>        在定义对象a和b时，Java自动调用了Integer.valueOf来将数字封装成对象。</p> 
<pre><code class="language-java">// Integer中valueOf源码：
@IntrinsicCandidate
public static Integer valueOf(int i) {
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}</code></pre> 
<p>如果数字在low和high之间的话，是直接从IntegerCache缓存中获取的数据。</p> 
<pre><code class="language-java">// IntegerCache源码：
private static class IntegerCache {
	static final int low = -128;
	static final int high;
	static final Integer[] cache;
	static Integer[] archivedCache;

	static {
		// 高值可以由属性配置
		int h = 127;
		String integerCacheHighPropValue =　VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
		if (integerCacheHighPropValue != null) {
            try {
                h = Math.max(parseInt(integerCacheHighPropValue), 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(h, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // 如果无法将属性解析为int，请忽略它。
            }
		}
		high = h;

            // 如果可能，从archive加载IntegerCache.archivedCache
            CDS.initializeFromArchive(IntegerCache.class);
            int size = (high - low) + 1;

        // 如果存档缓存存在并且足够大，请使用它
        if (archivedCache == null || size &gt; archivedCache.length) {
            Integer[] c = new Integer[size];
            int j = low;
            for(int i = 0; i &lt; c.length; i++) {
                c[i] = new Integer(j++);
            }
            archivedCache = c;
        }
        cache = archivedCache;
        // 范围 [-128, 127] 必须保留 (JLS7 5.1.7)
        assert IntegerCache.high &gt;= 127;
	}
    private IntegerCache() {}
}</code></pre> 
<p>        也就是说，如果数字在-128~127，是直接从 缓存 中获取的Integer对象。如果数字超过了这个范围，则是new出来的新对象。</p> 
<p>        文章中的1000，超出了-128~127的范围，所以对象a和b的引用指向了两个不同的地址；而100在-128~127的范围内，对象a和b的引用指向了同一个地址。</p> 
<p></p> 
<p>为什么Integer类会加这个缓存呢？</p> 
<p>        因为-128~127是使用最频繁的数字，如果不做缓存，会在内存中产生大量指向相同数据的对象，会浪费部分内存空间。</p> 
<p></p> 
<p>        总之，对于较小的整数值，推荐使用自动装箱的方式，而对于较大的整数值，可以使用显式的构造函数调用方式，或者直接使用基本类型int，避免不必要的对象创建和内存消耗。</p> 
<p></p> 
<p><a class="link-info" href="https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&amp;mid=2247555802&amp;idx=1&amp;sn=a8299d6a7438c58ee5d5d586fafd724b" rel="nofollow" title="1">1</a>、<a class="link-info" href="https://blog.csdn.net/lfdfhl/article/details/110221963" title="2">2</a>、<a class="link-info" href="https://blog.csdn.net/MinggeQingchun/article/details/120704300" title="3">3</a>、<a class="link-info" href="https://so.csdn.net/so/search?spm=1000.2115.3001.4498&amp;q=IntegerCache&amp;t=blog&amp;u=" title="4">4</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70ddc6e087181933ae067f1d1e006e3c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习期末复习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c8e084ebd216f809c041194018042c85/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【计算机网络】网络基础--协议/网络协议/网络传输流程/地址管理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>