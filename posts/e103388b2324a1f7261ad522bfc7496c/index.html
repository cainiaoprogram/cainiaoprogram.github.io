<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Linux](2)快速入门Linux基础指令 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[Linux](2)快速入门Linux基础指令" />
<meta property="og:description" content="文章目录 ls 指令(list files)pwd 指令(print work directory)cd 指令(change directory)定位文件(路径)cd 指令的使用 touch 指令mkdir 指令(make directory)rmdir 指令、rm 指令(remove)man 指令cp 指令(copy file)mv 指令(move file)cat 指令(concatenate)more 指令、less 指令&gt; 输出重定向、&gt;&gt; 追加重定向&lt; 输入重定向head 指令、tail指令| 管道时间相关指令date 指令显示时间时间戳 cal 指令 find 指令grep 指令zip/unzip 指令tar 指令bc 指令uname 指令几个重要热键关机 ls 指令(list files) 功能
显示指定工作目录下的内容，对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息
语法
ls [选项][目录或文件] 选项
-l 列出文件的详细信息，包括文件名、文件型态、权限、拥有者、文件大小等-a 列出目录下的所有文件，包括以 . 开头的隐藏文件。-i 输出文件的 i 节点的索引信息。-n 用数字的 UID,GID 代替名称。-F 在每个文件名后附上一个字符以说明该文件的类型， “*”表示可执行的普通文件； “/”表示目录； “@”表示符号链接； “|”表示FIFOs； “=”表示套接字(sockets)。-d 将目录象文件一样显示，而不是显示其下的文件。-k 以 k 字节的形式表示文件的大小。-r 对目录反向排序。-t 以时间排序。-s 在 l 文件名后输出该文件的大小。-R 列出所有子目录下的文件。 (递归)-1 一行只输出一个文件。 举例" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e103388b2324a1f7261ad522bfc7496c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-01T22:49:21+08:00" />
<meta property="article:modified_time" content="2022-07-01T22:49:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Linux](2)快速入门Linux基础指令</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#ls_list_files_1" rel="nofollow">ls 指令(list files)</a></li><li><a href="#pwd_print_work_directory_164" rel="nofollow">pwd 指令(print work directory)</a></li><li><a href="#cd_change_directory_183" rel="nofollow">cd 指令(change directory)</a></li><li><ul><li><a href="#_185" rel="nofollow">定位文件(路径)</a></li><li><a href="#cd__207" rel="nofollow">cd 指令的使用</a></li></ul> 
  </li><li><a href="#touch__258" rel="nofollow">touch 指令</a></li><li><a href="#mkdir_make_directory_294" rel="nofollow">mkdir 指令(make directory)</a></li><li><a href="#rmdir_rm_remove_323" rel="nofollow">rmdir 指令、rm 指令(remove)</a></li><li><a href="#man__397" rel="nofollow">man 指令</a></li><li><a href="#cp_copy_file_438" rel="nofollow">cp 指令(copy file)</a></li><li><a href="#mv_move_file_487" rel="nofollow">mv 指令(move file)</a></li><li><a href="#cat_concatenate_551" rel="nofollow">cat 指令(concatenate)</a></li><li><a href="#more_less__599" rel="nofollow">more 指令、less 指令</a></li><li><a href="#___659" rel="nofollow">&gt; 输出重定向、&gt;&gt; 追加重定向</a></li><li><a href="#__701" rel="nofollow">&lt; 输入重定向</a></li><li><a href="#head_tail_754" rel="nofollow">head 指令、tail指令</a></li><li><a href="#__807" rel="nofollow">| 管道</a></li><li><a href="#_843" rel="nofollow">时间相关指令</a></li><li><ul><li><a href="#date__845" rel="nofollow">date 指令</a></li><li><ul><li><a href="#_847" rel="nofollow">显示时间</a></li><li><a href="#_865" rel="nofollow">时间戳</a></li></ul> 
   </li><li><a href="#cal__885" rel="nofollow">cal 指令</a></li></ul> 
  </li><li><a href="#find__917" rel="nofollow">find 指令</a></li><li><a href="#grep__942" rel="nofollow">grep 指令</a></li><li><a href="#zipunzip__1005" rel="nofollow">zip/unzip 指令</a></li><li><a href="#tar__1083" rel="nofollow">tar 指令</a></li><li><a href="#bc__1124" rel="nofollow">bc 指令</a></li><li><a href="#uname__1153" rel="nofollow">uname 指令</a></li><li><a href="#_1171" rel="nofollow">几个重要热键</a></li><li><a href="#_1181" rel="nofollow">关机</a></li></ul> 
</div> 
<p></p> 
<h2><a id="ls_list_files_1"></a>ls 指令(list files)</h2> 
<p><strong>功能</strong></p> 
<p>显示指定工作目录下的内容，对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息</p> 
<p><strong>语法</strong></p> 
<pre><code>ls [选项][目录或文件]
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><strong><code>-l</code></strong> 列出文件的详细信息，包括文件名、文件型态、权限、拥有者、文件大小等</li><li><strong><code>-a</code></strong> 列出目录下的所有文件，包括以 . 开头的隐藏文件。</li><li><code>-i</code> 输出文件的 i 节点的索引信息。</li><li><code>-n</code> 用数字的 UID,GID 代替名称。</li><li><code>-F</code> 在每个文件名后附上一个字符以说明该文件的类型， “*”表示可执行的普通文件； “/”表示目录； “@”表示符号链接； “|”表示FIFOs； “=”表示套接字(sockets)。</li><li><code>-d</code> 将目录象文件一样显示，而不是显示其下的文件。</li><li><code>-k</code> 以 k 字节的形式表示文件的大小。</li><li><code>-r</code> 对目录反向排序。</li><li><code>-t</code> 以时间排序。</li><li><code>-s</code> 在 l 文件名后输出该文件的大小。</li><li><code>-R</code> 列出所有子目录下的文件。 (递归)</li><li><code>-1</code> 一行只输出一个文件。</li></ul> 
<p><strong>举例</strong></p> 
<p>直接使用 <code>ls</code> 表示显示当前目录下的内容，为了方便演示，这里先用 <code>touch</code> 指令创建文件，<code>mkdir</code> 创建目录，<code>pwd</code> 显示当前路径：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos ~]\$ ls					#列出当前目录下的内容
[CegghnnoR@VM-4-13-centos ~]\$ touch mytest.c		#创建文件
[CegghnnoR@VM-4-13-centos ~]\$ ls								
mytest.c
[CegghnnoR@VM-4-13-centos ~]\$ mkdir code			#创建目录
[CegghnnoR@VM-4-13-centos ~]\$ ls
code  mytest.c
[CegghnnoR@VM-4-13-centos ~]\$ pwd					#显示当前路径
/home/CegghnnoR
</code></pre> 
<hr> 
<p><code>-l</code> 展示文件的更多属性：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos ~]$ ls -l					#显示文件的更多属性
total 4
drwxrwxr-x 2 CegghnnoR CegghnnoR 4096 Jun 29 21:42 code
-rw-rw-r-- 1 CegghnnoR CegghnnoR    0 Jun 29 21:27 mytest.c
</code></pre> 
<p>👆：<mark>文件包括文件内容和文件属性</mark>，文件属性同样要在硬盘中占据空间。我们学的所有文件操作无非就两类1.对文件的内容操作 2.对文件的属性操作。<code>ls -l</code> 也可以简写成 <code>ll</code></p> 
<hr> 
<p><code>-a</code> 列出所有文件（包括隐藏文件），选项可以同时使用 <code>ls -a -l</code>，也可以组合 <code>ls -al</code>：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos ~]$ ls -a					#列出所有文件
.  ..  code  mytest.c #其余略。。。
[CegghnnoR@VM-4-13-centos ~]$ ls -al				#列出所有文件及详细信息
total 36
drwx------  5 CegghnnoR CegghnnoR 4096 Jun 29 21:42 .
drwxr-xr-x. 4 root      root      4096 Jun 28 22:46 ..
drwxrwxr-x  2 CegghnnoR CegghnnoR 4096 Jun 29 21:42 code
-rw-rw-r--  1 CegghnnoR CegghnnoR    0 Jun 29 21:27 mytest.c
#其余略。。。
</code></pre> 
<p>👆：以 <code>.</code> 开头的文件为隐藏文件，我们也可以用 <code>touch</code> 创建这样的文件。</p> 
<p>👆：在任意目录下，都会存在两个隐藏文件：<code>.</code> (当前路径)和 <code>..</code> (上级路径)</p> 
<p>使用 cd 命令可以更改所在目录，<code>cd ..</code> 就表示跳到上级目录：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos ~]$ pwd					#显示当前路径
/home/CegghnnoR
[CegghnnoR@VM-4-13-centos ~]$ cd ..					#回到上级路径
[CegghnnoR@VM-4-13-centos home]$ pwd
/home
[CegghnnoR@VM-4-13-centos home]$ cd ..
[CegghnnoR@VM-4-13-centos /]$ pwd
/
[CegghnnoR@VM-4-13-centos /]$ cd ..
[CegghnnoR@VM-4-13-centos /]$ pwd
/
</code></pre> 
<p>👆：Linux 的路径分隔符：<code>/</code>，Windows 的路径分隔符：<code>\</code>。</p> 
<p>👆：退到 <code>/</code> 就不能继续回退了，它叫做根目录。</p> 
<p>回到原来的目录：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos /]$ cd /home/CegghnnoR
[CegghnnoR@VM-4-13-centos ~]$ pwd
/home/CegghnnoR
</code></pre> 
<p>那么 <code>.</code> 有什么用呢？这里稍微演示一下：</p> 
<p>这里使用 vim 在 mytest.c 里编写了一个 hello world 程序（编写过程略，vim 的操作以后讲），然后 gcc 编译会生成一个 a.out 文件，要运行此文件应该输入的指令为 <code>./a.out</code></p> 
<pre><code>[CegghnnoR@VM-4-13-centos ~]$ vim mytest.c
[CegghnnoR@VM-4-13-centos ~]$ gcc mytest.c
[CegghnnoR@VM-4-13-centos ~]$ ls
a.out  code  mytest.c
[CegghnnoR@VM-4-13-centos ~]$ ./a.out
hello world!
</code></pre> 
<p>👆：这里的 <code>./</code> 就代表要执行当前文件下的程序。</p> 
<hr> 
<p><code>-i</code> 会发现列出的文件前面多了一串数字，具体是什么会在以后讲解。</p> 
<pre><code>[CegghnnoR@VM-4-13-centos ~]$ ls -i
656092 a.out  656093 code  658302 mytest.c
[CegghnnoR@VM-4-13-centos ~]$ ls -il
total 20
656092 -rwxrwxr-x 1 CegghnnoR CegghnnoR 8360 Jun 30 13:20 a.out
656093 drwxrwxr-x 2 CegghnnoR CegghnnoR 4096 Jun 29 21:42 code
658302 -rw-rw-r-- 1 CegghnnoR CegghnnoR   78 Jun 30 13:20 mytest.c
</code></pre> 
<hr> 
<p><code>-n</code> 会发现原来的用户名显示被替换成了数字。</p> 
<pre><code>[CegghnnoR@VM-4-13-centos ~]$ ls -nl
total 20
-rwxrwxr-x 1 1001 1001 8360 Jun 30 13:20 a.out
drwxrwxr-x 2 1001 1001 4096 Jun 29 21:42 code
-rw-rw-r-- 1 1001 1001   78 Jun 30 13:20 mytest.c
</code></pre> 
<hr> 
<p><code>-F</code> 在文件后面加一个字符表示文件类型，什么都不加的表示是普通的文本文件。</p> 
<pre><code>[CegghnnoR@VM-4-13-centos ~]$ ls -Fl
total 20
-rwxrwxr-x 1 CegghnnoR CegghnnoR 8360 Jun 30 13:20 a.out*
drwxrwxr-x 2 CegghnnoR CegghnnoR 4096 Jun 29 21:42 code/
-rw-rw-r-- 1 CegghnnoR CegghnnoR   78 Jun 30 13:20 mytest.c
</code></pre> 
<hr> 
<p><strong>总结</strong></p> 
<p>最常用的就是 <code>-a</code> 和 <code>-l</code>，剩下的选项不多演示。以上主要通过了 <code>-a</code> 选项讲解了什么是隐藏文件，隐藏文件 . (当前路径) … (上级路径)的作用。</p> 
<h2><a id="pwd_print_work_directory_164"></a>pwd 指令(print work directory)</h2> 
<p><strong>功能</strong></p> 
<p>显示当前所在的工作目录的绝对路径。</p> 
<p><strong>语法</strong></p> 
<pre><code>pwd
</code></pre> 
<p><strong>举例</strong></p> 
<pre><code>[CegghnnoR@VM-4-13-centos ~]$ pwd
/home/CegghnnoR
</code></pre> 
<h2><a id="cd_change_directory_183"></a>cd 指令(change directory)</h2> 
<h3><a id="_185"></a>定位文件(路径)</h3> 
<p>Linux 的目录结构本质是一棵<mark>多叉树</mark>。（和Windows一样）</p> 
<p><img src="https://images2.imgbox.com/4e/3d/aAOcK1Zz_o.png" alt="img"></p> 
<ol><li>每一个子结点既可以是一个普通文件也可以是一个目录，目录里面可以再放目录或者普通文件，这是递归式的定义。</li><li>这棵多叉树的叶子结点，一定是一个普通文件或者空目录。</li><li>由根目录向下查找的路径为<mark>绝对路径</mark>，对于每一个文件，它的绝对路径是唯一的，比如 <code>/home/CegghnnoR/test.c</code></li><li><mark>相对路径</mark>则是相对于用户所处的路径。比如如果当前处在 <code>CegghnnoR</code> 下，<code>passwd</code> 的相对路径就是 <code>../../etc/passwd</code></li></ol> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ ls /home/CegghnnoR/code/6_29/test.c	#绝对路径
/home/CegghnnoR/code/6_29/test.c
[CegghnnoR@VM-4-13-centos 6_30]$ ls ../6_29/test.c		#相对路径
../6_29/test.c
</code></pre> 
<p>如果是日常使用，建议使用相对路径——简单</p> 
<p>如果是进行添加配置文件，推荐绝对路径——不容易出错</p> 
<h3><a id="cd__207"></a>cd 指令的使用</h3> 
<p><strong>功能</strong></p> 
<p>切换当前工作目录。</p> 
<p><strong>语法</strong></p> 
<pre><code>cd [目录名]
</code></pre> 
<p>目录名表示可以用相对路径也可以用绝对路径。若目录名称省略，则变换至使用者的 home 目录。另外，<code>~</code> 也表示为 home 目录的意思，<code>.</code> 表示当前目录，<code>..</code> 表示上级目录。</p> 
<p><strong>举例</strong></p> 
<p>code 下有 6_29 和 6_30 两个目录，如下分别使用绝对路径和相对路径在两个目录间切换：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ pwd
/home/CegghnnoR/code/6_30
[CegghnnoR@VM-4-13-centos 6_30]$ cd /home/CegghnnoR/code/6_29  #绝对路径
[CegghnnoR@VM-4-13-centos 6_29]$ pwd
/home/CegghnnoR/code/6_29
[CegghnnoR@VM-4-13-centos 6_29]$ cd ../6_30					   #相对路径
[CegghnnoR@VM-4-13-centos 6_30]$ pwd
/home/CegghnnoR/code/6_30
</code></pre> 
<p>使用 <code>cd ~</code> 或 <code>cd</code> 回到当前用户的家目录，也就是登陆时的位置：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ cd ~
[CegghnnoR@VM-4-13-centos ~]$ pwd
/home/CegghnnoR
</code></pre> 
<p>使用 <code>cd -</code> 回到上一次所在的目录：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_29]$ pwd	#当前目录
/home/CegghnnoR/code/6_29
[CegghnnoR@VM-4-13-centos 6_29]$ cd /	#前往根目录
[CegghnnoR@VM-4-13-centos /]$ pwd
/
[CegghnnoR@VM-4-13-centos /]$ cd -		#回到上一次所在目录
/home/CegghnnoR/code/6_29
[CegghnnoR@VM-4-13-centos 6_29]$ pwd
/home/CegghnnoR/code/6_29
</code></pre> 
<h2><a id="touch__258"></a>touch 指令</h2> 
<p><strong>功能</strong></p> 
<p>修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p> 
<p><strong>语法</strong></p> 
<pre><code>touch [选项]... 文件...
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-a</code> 或–time=atime或–time=access或–time=use只更改存取时间。</li><li><code>-c</code> 或–no-create 不建立任何文档。</li><li><code>-d</code> 使用指定的日期时间，而非现在的时间。</li><li><code>-f</code> 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。</li><li><code>-m</code> 或–time=mtime或–time=modify 只更改变动时间。</li><li><code>-r</code> 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。</li><li><code>-t</code> 使用指定的日期时间，而非现在的时间。</li></ul> 
<p><strong>举例</strong></p> 
<p>直接用 <code>touch</code> 新建文件</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ ls
test.c
[CegghnnoR@VM-4-13-centos 6_30]$ touch file.txt		#新建文件
[CegghnnoR@VM-4-13-centos 6_30]$ ls
file.txt  test.c
</code></pre> 
<p>当前只用得到这个用法，其他的选项暂时不看。</p> 
<h2><a id="mkdir_make_directory_294"></a>mkdir 指令(make directory)</h2> 
<p><strong>功能</strong></p> 
<p>创建目录</p> 
<p><strong>语法</strong></p> 
<pre><code>mkdir [选项] dirName
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-p</code> dirname可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录。</li></ul> 
<p><strong>举例</strong></p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ ls
[CegghnnoR@VM-4-13-centos 6_30]$ mkdir dir		#创建一个目录
[CegghnnoR@VM-4-13-centos 6_30]$ ls
dir
[CegghnnoR@VM-4-13-centos 6_30]$ mkdir -p dir/dir1/dir2 #创建一串路径
[CegghnnoR@VM-4-13-centos 6_30]$ cd dir/dir1/dir2
[CegghnnoR@VM-4-13-centos dir2]$ pwd
/home/CegghnnoR/code/6_30/dir/dir1/dir2
</code></pre> 
<h2><a id="rmdir_rm_remove_323"></a>rmdir 指令、rm 指令(remove)</h2> 
<p><code>rmdir</code> 与 <code>mkdir</code> 指令相对，<code>mkdir</code> 建立目录，<code>rmdir</code> 删除目录</p> 
<p>emdir：</p> 
<p><strong>功能</strong></p> 
<p>删除空目录</p> 
<p><strong>适用对象</strong></p> 
<p>具有当前目录操作权限的所有使用者。</p> 
<p><strong>语法</strong></p> 
<pre><code>rmdir [-p] dirName
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-p</code> 当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除。</li></ul> 
<p>👆：因为只能删除空目录，所以不常用。</p> 
<hr> 
<p>rm:</p> 
<p><strong>功能</strong></p> 
<p>删除一个文件或者目录。</p> 
<p><strong>使用权限</strong></p> 
<p>所有使用者</p> 
<p><strong>语法</strong></p> 
<pre><code>rm [options] name...
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-r</code> 删除目录及其下所有文件。</li><li><code>-f</code> 即使文件属性为只读(即写保护)，亦直接删除，不提示是否确认。</li><li><code>-i</code> 删除前逐一询问确认。</li></ul> 
<p><strong>举例</strong></p> 
<p>删除一个普通文本文件：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ ls
a.out  dir  file.txt  test.c
[CegghnnoR@VM-4-13-centos 6_30]$ rm file.txt	#删除文本文件
[CegghnnoR@VM-4-13-centos 6_30]$ ls
a.out  dir  test.c
</code></pre> 
<p>删除目录需要加上 <code>-r</code>：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ rm dir		#直接删除删不了
rm: cannot remove ‘dir’: Is a directory
[CegghnnoR@VM-4-13-centos 6_30]$ rm -r dir	#删除目录
[CegghnnoR@VM-4-13-centos 6_30]$ ls
a.out  test.c
</code></pre> 
<p><strong>提醒</strong>：Linux中如果不是特别确认，不要轻易删除文件，因为LInux没有回收站。</p> 
<h2><a id="man__397"></a>man 指令</h2> 
<p><strong>功能</strong></p> 
<p>man 指令用于查看Linux手册。</p> 
<p>如果没有，要先在root下安装，指令：<code>yum install -y man-pages</code></p> 
<p><strong>语法</strong></p> 
<pre><code>man [选项] [命令]
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-k</code> 根据关键字搜索联机帮助</li><li><code>num</code> 只在第num章节找</li><li><code>-a</code> 将所有章节的都显示出来，比如 man printf 它缺省从第一章开始搜索，知道就停止，用a选项，当按下q退出，他会继续往后面搜索，直到所有章节都搜索完毕。</li><li>man手册分为8章 
  <ol><li>普通的命令</li><li>系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)</li><li>库函数,如printf,fread</li><li>是特殊文件,也就是/dev下的各种设备文件</li><li>指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义</li><li>给游戏留的,由各个游戏自己定义</li><li>附件还有一些变量,比如向environ这种全局变量在这里就有说明</li><li>系统管理用的命令,这些命令只能由root使用,如ifconfig</li></ol> </li></ul> 
<p>我们最常用的是123，不指定章节默认查第一章。</p> 
<p><strong>举例</strong></p> 
<p>用 <code>man</code> 查不同的手册</p> 
<pre><code>man printf		#查printf指令
man 3 printf	#查C语言函数printf
man man			#用man查man
</code></pre> 
<h2><a id="cp_copy_file_438"></a>cp 指令(copy file)</h2> 
<p><strong>功能</strong></p> 
<p>复制文件或目录</p> 
<p><strong>语法</strong></p> 
<pre><code>cp [options] source dest
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-r</code> 递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理</li><li><code>-f</code> 强行复制文件或目录， 不论目的文件或目录是否已经存在</li><li><code>-i</code> 与-f相反，覆盖文件之前先询问用户</li><li><code>-R</code> 递归处理，将指定目录下的文件及子目录一并处理</li></ul> 
<p><strong>举例</strong></p> 
<p>cat可以打印文件内容，后面具体讲。这里首先在file.txt文件里写入了内容，然后使用cp，拷贝的副本叫file-bak.txt，再打印file-bak.txt的内容：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ ls
file.txt
[CegghnnoR@VM-4-13-centos 6_30]$ cat file.txt				#打印原文件
abcdefg
[CegghnnoR@VM-4-13-centos 6_30]$ cp file.txt file-bak.txt	#拷贝
[CegghnnoR@VM-4-13-centos 6_30]$ ls
file-bak.txt  file.txt
[CegghnnoR@VM-4-13-centos 6_30]$ cat file-bak.txt			#打印副本
abcdefg														#内容一样
</code></pre> 
<p>也可以把文件拷贝到其他目录<code>cp file.txt ../file.txt-1</code></p> 
<p>拷贝目录要加上 <code>-r</code> 选项</p> 
<pre><code>[CegghnnoR@VM-4-13-centos code]$ ls
6_29  6_30
[CegghnnoR@VM-4-13-centos code]$ cp 6_30 6_30-bak
cp: omitting directory ‘6_30’							#不能直接拷贝
[CegghnnoR@VM-4-13-centos code]$ cp -r 6_30 6_30-bak	#要加上-r
[CegghnnoR@VM-4-13-centos code]$ ls
6_29  6_30  6_30-bak
</code></pre> 
<h2><a id="mv_move_file_487"></a>mv 指令(move file)</h2> 
<p><strong>功能</strong></p> 
<p>为文件或目录改名、或将文件或目录移入其它位置。</p> 
<p><strong>语法</strong></p> 
<pre><code>mv [options] source dest
mv [options] source... directory
</code></pre> 
<ol><li>视mv命令中第二个参数类型的不同（是目标文件还是目标目录）， mv命令将文件重命名或将其移至一个新的目录中。</li><li>当第二个参数类型是文件时， mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。</li><li>当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个， mv命令将各参数指定的源文件均移至目标目录中。</li></ol> 
<p><strong>选项</strong></p> 
<ul><li><code>-f</code> 如果目标文件已经存在，不会询问而直接覆盖</li><li><code>-i</code> 若目标文件已经存在，则会询问是否覆盖</li></ul> 
<p><strong>举例</strong></p> 
<p>移动文件，类似于剪切功能：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ ls
file-bak.txt  file.txt
[CegghnnoR@VM-4-13-centos 6_30]$ mv file.txt ../	#将文件移到上级目录
[CegghnnoR@VM-4-13-centos 6_30]$ ls
file-bak.txt
[CegghnnoR@VM-4-13-centos 6_30]$ ls ..				#查看上级目录
6_29  6_30  file.txt
</code></pre> 
<p>移动目录：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos code]$ ls
6_29  6_30  file.txt
[CegghnnoR@VM-4-13-centos code]$ mv 6_30 ..		#移到上级目录
[CegghnnoR@VM-4-13-centos code]$ ls ..
6_30  code
</code></pre> 
<p>重命名：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ ls
file-bak.txt
[CegghnnoR@VM-4-13-centos 6_30]$ mv file-bak.txt file.txt-bak	#对文件重命名
[CegghnnoR@VM-4-13-centos 6_30]$ ls
file.txt-bak
</code></pre> 
<pre><code>[CegghnnoR@VM-4-13-centos code]$ ls
6_29  6_30
[CegghnnoR@VM-4-13-centos code]$ mv 6_30 6-30	对目录重命名
[CegghnnoR@VM-4-13-centos code]$ ls
6_29  6-30
</code></pre> 
<h2><a id="cat_concatenate_551"></a>cat 指令(concatenate)</h2> 
<p><strong>功能</strong></p> 
<p>连接文件并打印到标准输出设备上。</p> 
<p>比较<mark>适合查看短文本</mark>，或者代码。</p> 
<p><strong>语法</strong></p> 
<pre><code>cat [选项] [文件]
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-n</code> 对输出的所有行编号。</li><li><code>-b</code> 和 -n 相似，只不过对于空白行不编号。</li><li><code>-s</code> 当遇到有连续两行以上的空白行，就替换为一行的空白行。</li></ul> 
<p><strong>举例</strong></p> 
<p>与 <code>cat</code> 相似，还有个 <code>tac</code> 指令也可以打印文件内容，但是 <code>tac</code> 是从最后一行开始打印。</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ cat file.txt
aaaaaaaaaa
bbbbbbbbbb
cccccccccc
dddddddddd
eeeeeeeeee
[CegghnnoR@VM-4-13-centos 6_30]$ tac file.txt
eeeeeeeeee
dddddddddd
cccccccccc
bbbbbbbbbb
aaaaaaaaaa
</code></pre> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ cat -n file.txt	#带有行号，tac不可以
     1	aaaaaaaaaa
     2	bbbbbbbbbb
     3	cccccccccc
     4	dddddddddd
     5	eeeeeeeeee
</code></pre> 
<h2><a id="more_less__599"></a>more 指令、less 指令</h2> 
<p>more：</p> 
<p><strong>功能</strong></p> 
<p>类似cat。不过会以一页一页的形式显示，更方便使用者逐页阅读、</p> 
<p><strong>语法</strong></p> 
<pre><code>more [选项] [文件]
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-n</code> 对输入的所有行编号 
  <ul><li>使用中按 q 退出</li><li>空格键向下翻页</li><li>b 键向前翻页</li><li>enter 键向下翻一行</li><li>/[字符串] 向下搜索</li><li>h 查看帮助</li></ul> </li></ul> 
<p><strong>举例</strong></p> 
<p>为了演示 <code>more</code> 指令，我们先创建一个 <code>file.txt</code> 文件，然后向里面输入100000行数据。输入数据的代码如下：</p> 
<p><code>cnt=1; while [ $cnt -le 100000 ]; do echo "hello world $cnt"; let cnt++; done &gt; file.txt</code></p> 
<p>然后使用 <code>wc -l file.txt </code>查看里面是不是真的有了100000行数据。</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ cnt=1; while [ $cnt -le 100000 ]; do echo "hello world $cnt"; let cnt++; done &gt; file.txt
[CegghnnoR@VM-4-13-centos 6_30]$ wc -l file.txt
100000 file.txt
</code></pre> 
<p>如果用 <code>cat</code> 查看这个文件就直接刷屏了，显然不合适。</p> 
<pre><code>more file.txt
</code></pre> 
<hr> 
<p>less的功能更加强大，更<mark>推荐使用 <code>less</code></mark></p> 
<p>less支持方向键↑↓翻页</p> 
<p><strong>选项</strong></p> 
<ul><li><code>-i</code> 忽略搜索时的大小写</li><li><code>-N</code> 显示每行的行号 
  <ul><li>/字符串：向下搜索“字符串”的功能</li><li>?字符串：向上搜索“字符串”的功能</li><li>n：重复前一个搜索（与 / 或 ? 有关）</li><li>N：反向重复前一个搜索（与 / 或 ? 有关）</li><li>q：quit</li></ul> </li></ul> 
<h2><a id="___659"></a>&gt; 输出重定向、&gt;&gt; 追加重定向</h2> 
<p>在生成 100000 行数据的代码中，最后有一个 <code>&gt;</code> ，这个 <code>&gt;</code> 是干什么的呢？</p> 
<p>比如我们可以使用 <code>echo</code> 将字符串打印出来：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ echo "hello world"
hello world
</code></pre> 
<p>如果在后面加一个 <code>&gt;</code> 符号再加一个文件名，就会发现它创建了这个文件，并把内容写了进去。</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ echo "hello world" &gt; hello.txt
[CegghnnoR@VM-4-13-centos 6_30]$ ls
file.txt  hello.txt
[CegghnnoR@VM-4-13-centos 6_30]$ cat hello.txt
hello world
</code></pre> 
<p>👆：<mark>本来应该写入到显示器内容，写入到了文件中，这种就叫做输出重定向</mark>。</p> 
<p>当我们将另一个内容再次输入到这个文件中，会发现原来的内容被覆盖了：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ echo "goodbye world" &gt; hello.txt
[CegghnnoR@VM-4-13-centos 6_30]$ cat hello.txt
goodbye world
</code></pre> 
<p>👆：<mark>输出重定向会清空原始文件的内容，进行重新写入</mark>。</p> 
<p><mark><code>&gt;&gt;</code> 则表示追加重定向，不会清空原内容</mark>。</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ echo "hello world" &gt;&gt; hello.txt
[CegghnnoR@VM-4-13-centos 6_30]$ cat hello.txt
goodbye world
hello world
</code></pre> 
<h2><a id="__701"></a>&lt; 输入重定向</h2> 
<p><code>cat</code> 默认从键盘读取</p> 
<p>也就是说，当你直接使用 <code>cat</code> 指令，后面不带文件，那么你输入什么就会打印什么：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ cat
a
a
b
b
cc
cc
dd
dd
</code></pre> 
<p>👆：ctrl+c 终止</p> 
<p>👆<strong>注意</strong>：ctrl+c 是终止。ctrl+z 是暂停，程序依然存在，要想回到这个程序 <code>fg 编号</code> 即可。</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ cat
^Z											#暂停
[1]+  Stopped                 cat
[CegghnnoR@VM-4-13-centos 6_30]$ fg 1		#继续运行1号任务
cat
^C
</code></pre> 
<p>👆：使用 <code>jobs</code> 查看当前暂停的任务：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ jobs
[1]   Stopped                 cat
[2]-  Stopped                 cat
[3]+  Stopped                 cat
</code></pre> 
<p>通过 <code>&lt;</code> 连接一个文件，可以让它打印文件内容，当然这和直接加文件的效果一样</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ cat &lt; hello.txt
goodbye world
hello world
[CegghnnoR@VM-4-13-centos 6_30]$ cat hello.txt
goodbye world
hello world
</code></pre> 
<p><mark>本来应该从键盘中读取数据，改成从指定的文件中读取，这就叫输入重定向</mark>。</p> 
<h2><a id="head_tail_754"></a>head 指令、tail指令</h2> 
<p><strong>功能</strong></p> 
<p>head查看文件的开头部分的内容，默认显示 10 行内容。</p> 
<p>tail查看文件的结尾部分的内容，默认显示 10 行内容。</p> 
<p><strong>语法</strong></p> 
<pre><code>head [选项] [文件]
tail [选项] [文件]
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-行数</code> 表示显示的行数。</li></ul> 
<p><strong>举例</strong></p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ head file.txt		#显示前10行
hello world 1
hello world 2
hello world 3
hello world 4
hello world 5
hello world 6
hello world 7
hello world 8
hello world 9
hello world 10
[CegghnnoR@VM-4-13-centos 6_30]$ head -20 file.txt	#显示前20行
#此处省略20行
</code></pre> 
<p><code>tail</code> 则默认显示后10行：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ tail file.txt		#显示后10行
hello world 99991
hello world 99992
hello world 99993
hello world 99994
hello world 99995
hello world 99996
hello world 99997
hello world 99998
hello world 99999
hello world 100000
</code></pre> 
<h2><a id="__807"></a>| 管道</h2> 
<p>问：如何查看文本的第30000行到第30020行的内容？</p> 
<p>第一种方法：</p> 
<p>取钱30020行放到 <code>temp.txt</code> 文件，然后取 <code>temp.txt</code> 文件的后21行。</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ head -30020 file.txt &gt; temp.txt
[CegghnnoR@VM-4-13-centos 6_30]$ tail -21 temp.txt
#此处省略21行
</code></pre> 
<p>第二种方法：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ head -30020 file.txt | tail -21
#此处省略21行
</code></pre> 
<hr> 
<p>第二种方法直接获取到了想要的内容，其中 <code>|</code> 就是<strong>管道</strong></p> 
<p>管道就类似于第一种方法中的<code>temp.txt</code>，它把左指令的内容存起来，然后让右指令操作。</p> 
<p>它可以让我们级联多个命令，来完成流水线式的数据处理工作：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ head -100 file.txt | tail -15 | head -3
hello world 86
hello world 87
hello world 88
</code></pre> 
<h2><a id="_843"></a>时间相关指令</h2> 
<h3><a id="date__845"></a>date 指令</h3> 
<h4><a id="_847"></a>显示时间</h4> 
<p>使用 <code>date</code> 直接显示时间：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ date 	#默认格式
Fri Jul  1 14:11:57 CST 2022
</code></pre> 
<p>格式控制：</p> 
<p><code>+</code> 号后跟要控制的格式，年：<code>%Y</code> 月：<code>%m</code> 日：<code>%d</code> 时：<code>%H</code> 分：<code>%M</code> 秒：<code>%S</code></p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ date +%Y-%m-%d_%H:%M:%S	#格式控制
2022-07-01_14:19:08
</code></pre> 
<h4><a id="_865"></a>时间戳</h4> 
<p>使用 <code>date +%s</code> 可以显示时间戳：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ date +%s
1656656677
</code></pre> 
<p>时间戳是指世界标准时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</p> 
<p>将时间戳转为日期：<code>date -d@[时间戳]</code></p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ date -d@0	#将时间戳0转换为日期
Thu Jan  1 08:00:00 CST 1970
[CegghnnoR@VM-4-13-centos 6_30]$ date +%Y-%m-%d_%H:%M:%S -d@0   #格式化显示
1970-01-01_08:00:00
</code></pre> 
<h3><a id="cal__885"></a>cal 指令</h3> 
<p><strong>功能</strong></p> 
<p>显示日历</p> 
<p><strong>语法</strong></p> 
<pre><code>cal [参数] [月份] [年份]
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-3</code> 显示系统前一个月，当前月，下一个月的月历</li><li><code>-j</code> 显示在当年中的第几天（一年日期按天算，从1月1号算起，默认显示当前月在一年中的天数）</li><li><code>-y</code> 显示当前年份的日历</li></ul> 
<p><strong>举例</strong></p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ cal
      July 2022     
Su Mo Tu We Th Fr Sa
                1  2
 3  4  5  6  7  8  9
10 11 12 13 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
31
</code></pre> 
<h2><a id="find__917"></a>find 指令</h2> 
<p><strong>功能</strong></p> 
<p>用于在文件树中查找文件，并作出相应的处理（可能访问磁盘）</p> 
<p><strong>语法</strong></p> 
<pre><code>find [pathname] [-options]
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-name</code> 按文件名查找文件</li></ul> 
<p><strong>举例</strong></p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ find /usr/include/ -name stdio.h	#找stdio.h头文件
/usr/include/bits/stdio.h
/usr/include/c++/4.8.2/tr1/stdio.h
/usr/include/stdio.h
</code></pre> 
<h2><a id="grep__942"></a>grep 指令</h2> 
<p><strong>功能</strong></p> 
<p>行文本过滤工具，在文件中搜索字符串，将找到的行打印出来</p> 
<p><strong>语法</strong></p> 
<pre><code>grep [选项] '搜寻字符串' [文件]
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-i</code> 忽略大小写</li><li><code>-v</code> 反向选择，即显示没有 ‘搜寻字符串’ 内容的行</li><li><code>-n</code> 显示行号</li></ul> 
<p><strong>举例</strong></p> 
<p>如下文件内容：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ cat hello.txt
goodbye world
hello world
hello world
hello Linux
hello 世界
c++ C
c
C++
Java
</code></pre> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ grep 'c++' hello.txt
c++ C
</code></pre> 
<p>👆：小写的c++被匹配上了，大写的没有，说明 <code>grep</code> <strong>默认区分大小写</strong></p> 
<p>加上 <code>-i</code> 则不区分大小写：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ grep -i 'c++' hello.txt
c++ C
C++
</code></pre> 
<p>加上 <code>-v</code> ，有c++的行都不见了</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 6_30]$ grep -iv 'c++' hello.txt
goodbye world
hello world
hello world
hello Linux
hello 世界
c
Java
</code></pre> 
<h2><a id="zipunzip__1005"></a>zip/unzip 指令</h2> 
<p><strong>功能</strong></p> 
<p>压缩/解压</p> 
<p><strong>语法</strong></p> 
<pre><code>zip [选项] [压缩文件.zip] [目录或文件]
unzip [压缩文件.zip] [选项] [目录]
</code></pre> 
<p><strong>选项</strong></p> 
<p>zip：</p> 
<ul><li><code>-r</code> 递归处理，将指定目录下的所有文件和子目录一并处理。</li></ul> 
<p>unzip：</p> 
<ul><li><code>-d</code> 解压到指定路径</li></ul> 
<p><strong>举例</strong></p> 
<p>我们先准备好要压缩的目录 <code>tar_package</code> 里面放了5个普通文本文件，其中一个写入了内容。</p> 
<p>然后进行压缩，注意一定要加 <code>-r</code> 否则目录里面的文件不会被压缩：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls
tar_package
[CegghnnoR@VM-4-13-centos 2022_7_1]$ zip -r test.zip tar_package  #压缩
  adding: tar_package/ (stored 0%)
  adding: tar_package/flie4 (stored 0%)
  adding: tar_package/file2 (stored 0%)
  adding: tar_package/file3 (stored 0%)
  adding: tar_package/flie5 (stored 0%)
  adding: tar_package/file1 (stored 0%)
[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls		#压缩包出现
tar_package  test.zip
</code></pre> 
<pre><code>[CegghnnoR@VM-4-13-centos 2022_7_1]$ mv tar_package ..	#将原文件移走
[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls
test.zip												#只剩压缩文件
[CegghnnoR@VM-4-13-centos 2022_7_1]$ unzip test.zip		#解压
Archive:  test.zip
   creating: tar_package/
 extracting: tar_package/flie4       
 extracting: tar_package/file2       
 extracting: tar_package/file3       
 extracting: tar_package/flie5       
 extracting: tar_package/file1       
[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls
tar_package  test.zip									#解压完成
[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls tar_package
file1  file2  file3  flie4  flie5						#该目录下的文件还在
[CegghnnoR@VM-4-13-centos 2022_7_1]$ cat tar_package/file3
hello world												#也可以正常打印
</code></pre> 
<p>默认解压到当前目录，也可以解压到其他目录：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 2022_7_1]$ unzip test.zip -d ../6_30  #解压到昨天的目录里
Archive:  test.zip
   creating: ../6_30/tar_package/
 extracting: ../6_30/tar_package/flie4  
 extracting: ../6_30/tar_package/file2  
 extracting: ../6_30/tar_package/file3  
 extracting: ../6_30/tar_package/flie5  
 extracting: ../6_30/tar_package/file1  
[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls ../6_30
file.txt  hello.txt  tar_package								#确实出现在里面
</code></pre> 
<h2><a id="tar__1083"></a>tar 指令</h2> 
<p>这个指令非常复杂，现阶段主要掌握的是压缩和解压</p> 
<p><strong>选项</strong></p> 
<ul><li><code>-c</code> 建立新的备份文件</li><li><code>-z</code> 通过gzip指令处理备份文件</li><li><code>-f&lt;备份文件&gt;</code> 指定备份文件</li><li><code>-x</code> 解开一个压缩文件的参数指令！</li><li><code>-t</code> 列出备份文件的内容</li><li><code>-v</code> 压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！</li><li><code>-j</code> 是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？</li><li><code>-C</code> 解压到指定目录</li></ul> 
<p>最常用的就是czf和xzf选项，分别表示压缩和解压：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 2022_7_1]$ tar czf test.tgz tar_package	#压缩
[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls
tar_package  test.tgz
[CegghnnoR@VM-4-13-centos 2022_7_1]$ rm -rf tar_package
[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls
test.tgz
[CegghnnoR@VM-4-13-centos 2022_7_1]$ tar xzf test.tgz				#解压
[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls
tar_package  test.tgz
[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls tar_package
file1  file2  file3  flie4  flie5
</code></pre> 
<p>叫 <code>-C</code> 解压到指定目录。</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls
test.tgz
[CegghnnoR@VM-4-13-centos 2022_7_1]$ tar xzf test.tgz -C ../6_30	#解压到指定目录
[CegghnnoR@VM-4-13-centos 2022_7_1]$ ls ../6_30
file.txt  hello.txt  tar_package
</code></pre> 
<h2><a id="bc__1124"></a>bc 指令</h2> 
<p><strong>功能</strong></p> 
<p>计算器</p> 
<p><strong>举例</strong></p> 
<pre><code>[CegghnnoR@VM-4-13-centos 2022_7_1]$ bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'. 
1+1
2
3*8
24
^C
(interrupt) Exiting bc.
</code></pre> 
<p>也可以配合管道：</p> 
<pre><code>[CegghnnoR@VM-4-13-centos 2022_7_1]$ echo "1+2*4" | bc
9
</code></pre> 
<h2><a id="uname__1153"></a>uname 指令</h2> 
<p><strong>功能</strong></p> 
<p>uname用来获取电脑和操作系统的相关信息</p> 
<p><strong>语法</strong></p> 
<pre><code>uname [选项]
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li> <p><code>-a</code> 详细输出所有信息，依次为内核名称，主机名，内核版本号，内核版本，硬件名，处理器类型，硬件平台类型，操作系统名称</p> </li><li> <p><code>-r</code> 显示操作系统的发行编号</p> </li></ul> 
<h2><a id="_1171"></a>几个重要热键</h2> 
<p><code>ctrl+c </code> 终止，在上面输入重定向中讲到过，在程序失控时特别好用。</p> 
<p><code>Tab</code> 命令自动补齐。没补齐就再按一下显示所有以此开头的指令。</p> 
<p><code>ctrl+r</code> 搜索历史命令</p> 
<p><code>ctrl+d</code> 快速退出账户</p> 
<h2><a id="_1181"></a>关机</h2> 
<p><strong>语法</strong></p> 
<pre><code>shutdown [选项]
</code></pre> 
<p><strong>选项</strong></p> 
<ul><li><code>-h</code> 将系统的服务停掉后，立即关机</li><li><code>-r</code> 将系统的服务停掉后，重新启动</li><li><code>-t sec</code> sec秒后关机</li></ul> 
<p>我们使用云服务器的不需要关机。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/64bd9d84fa5d6327adecd67d70163459/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2021-11-30 ensp笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c8ec925494f80518ebd2b4fcbd0b4ad1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2020电赛E题--非线性失真器程序设计--01--算法仿真与STM32FFT数据验证（附工程源码&#43;gitee链接）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>