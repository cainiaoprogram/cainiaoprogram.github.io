<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>宏定义与宏替换 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="宏定义与宏替换" />
<meta property="og:description" content="一. c /c&#43;&#43;语言中使用宏的主要目的主要有 3 个： 1. 提高代码的可读性； 把用到的常量定义成有意义的名字； 2. 无需函数调用，运行效率高； 对于一些简单的操作，无需调用函数，虽然编程是强调模块化，但是函数调用时，需要保护现场和恢复现场。这些都需要耗时。对于复杂的操作来讲，这些耗时可以不计，但是对于简单的操作，则效率低下。利用宏来代替简单的操作，则可以提高程序的运行效率。 3. 可维护行好； 对于用得比较多的常量或者简单操作，一旦需要修改，则只需要修改宏定义处，不需要逐条修改。
二. 宏定义命令 ： #define 1 . #define命令主要是将一个标识符替换为一个字符串，该标识符称为宏名，被替换的字符串被称为替换文本。 2. 用法： 主要有两种格式，一个是简单的宏定义，另一个是带参数的宏定义； 简单的宏定义： #define &lt;宏名&gt; &lt;替换文本&gt; 例： #define pi 3.1415 带参数的宏定义：#define &lt;宏名&gt; （&lt;参数列表&gt;） &lt;宏体&gt; 例： #define A(x) x
三. 宏替换 当宏定义好后，在程序中使用宏名就称为宏替换。当程序进行编译时实际上经过了预处理，编译（生成中间代码，即从源程序翻译为中间语言，即汇编），汇编（将汇编语言翻译成机器代码，即二进制代码），链接（将目标文件生成 .exe文件）。宏替换就发生在预处理（也叫预编译）阶段，也就是说在编译之前（生成二进制文件之前）就已经完成了文本的替换工作。 关于预处理主要完成的工作是： 1.文件包含，将#include包含的文件找到，并在#include处进行展开； 2.条件编译，根据#if #ifdef 等编译命令及其后的条件，将源程序的一部分包含进来或排除在外，通常把排除在外的语句换成空行。 3.宏展开，将程序中所用到的宏展开成宏定义的替换文本。经过宏展开之后的程序与之前的源程序的只是简单的文本替换，并无计算功能。这是理解宏的要点。 四. 使用宏要注意的问题 1.使用简单宏出现的问题
#include&lt;stdio.h&gt; #define n 2&#43;2 int main() { int a = 0; a = n * n; return 0; } 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/36a8d6c749325bc2beb932888a57393b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-11-24T22:26:25+08:00" />
<meta property="article:modified_time" content="2016-11-24T22:26:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">宏定义与宏替换</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一. c /c++语言中使用宏的主要目的主要有 3 个： <br> 1. 提高代码的可读性； <br> 把用到的常量定义成有意义的名字； <br> 2. 无需函数调用，运行效率高； <br> 对于一些简单的操作，无需调用函数，虽然编程是强调模块化，但是函数调用时，需要保护现场和恢复现场。这些都需要耗时。对于复杂的操作来讲，这些耗时可以不计，但是对于简单的操作，则效率低下。利用宏来代替简单的操作，则可以提高程序的运行效率。 <br> 3. 可维护行好； <br> 对于用得比较多的常量或者简单操作，一旦需要修改，则只需要修改宏定义处，不需要逐条修改。</p> 
<p>二. 宏定义命令 ： #define <br> 1 . #define命令主要是将一个标识符替换为一个字符串，该标识符称为<em>宏名</em>，被替换的字符串被称为替换<em>文本</em>。 <br> 2. 用法： <br> 主要有两种格式，一个是简单的宏定义，另一个是带参数的宏定义； <br> 简单的宏定义： #define &lt;宏名&gt; &lt;替换文本&gt; <br> 例： #define pi 3.1415 <br> 带参数的宏定义：#define &lt;宏名&gt; （&lt;参数列表&gt;） &lt;宏体&gt; <br> 例： #define A(x) x</p> 
<p>三. 宏替换 <br> 当宏定义好后，在程序中使用宏名就称为宏替换。当程序进行编译时实际上经过了预处理，编译（生成中间代码，即从源程序翻译为中间语言，即汇编），汇编（将汇编语言翻译成机器代码，即二进制代码），链接（将目标文件生成 .exe文件）。宏替换就发生在预处理（也叫预编译）阶段，也就是说在编译之前（生成二进制文件之前）就已经完成了文本的替换工作。 <br> 关于预处理主要完成的工作是： <br> 1.文件包含，将#include包含的文件找到，并在#include处进行展开； <br> 2.条件编译，根据#if #ifdef 等编译命令及其后的条件，将源程序的一部分包含进来或排除在外，通常把排除在外的语句换成空行。 <br> 3.宏展开，将程序中所用到的宏展开成宏定义的替换文本。经过宏展开之后的程序与之前的源程序的只是简单的文本替换，并无计算功能。这是理解宏的要点。 <br> 四. 使用宏要注意的问题 <br> 1.使用简单宏出现的问题</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#define n  2+2</span>
<span class="hljs-keyword">int</span> main()
{
  <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;
  a = n * n;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>2.使用带参数的宏出现的问题</p> 
<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-comment">#include&lt;stdio.h&gt;</span>
<span class="hljs-comment">#define product(a) a*a</span>
<span class="hljs-keyword">int</span> main()
{
  <span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>;
  <span class="hljs-keyword">int</span> j = product(i++);
  <span class="hljs-keyword">printf</span>(<span class="hljs-string">"i = <span class="hljs-variable">%d</span>\n"</span>,i);
  <span class="hljs-keyword">printf</span>(<span class="hljs-string">"j = <span class="hljs-variable">%d</span>\n"</span>,j);
  j = product(++i);
  <span class="hljs-keyword">printf</span>(<span class="hljs-string">"i = <span class="hljs-variable">%d</span>\n"</span>,i);
  <span class="hljs-keyword">printf</span>(<span class="hljs-string">"j = <span class="hljs-variable">%d</span>\n"</span>,j);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>在vs带的编译器下，程序输出结果 i = 6 j =16 i = 8 j = 64 </p> 
<p>四. 结语 <br> 本文主要讲了宏定义的用法以及要使用时要注意的东西，同时注意到宏替换在预处理阶段完成，只是进行文本替换。</p> 
<p>五. 常用的宏定义</p> 
<p>1 防止一个头文件被重复包含 </p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#ifndef BODYDEF_H </span>
<span class="hljs-preprocessor">#define BODYDEF_H </span>
 <span class="hljs-comment">//头文件内容 </span>
<span class="hljs-preprocessor">#endif</span></code></pre> 
<p>2 得到指定地址上的一个字节或字</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEM_B( x ) ( *( (byte *) (x) ) ) </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEM_W( x ) ( *( (word *) (x) ) )</span></code></pre> 
<p>3 得到一个field在结构体(struct)中的偏移量</p> 
<pre class="prettyprint"><code class=" hljs fsharp">#define OFFSETOF( <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">field</span> ) (</span> (size_t) &amp;(( <span class="hljs-class"><span class="hljs-keyword">type</span> *) 0)-&gt; <span class="hljs-title">field</span> )</span></code></pre> 
<p>4 得到一个结构体中field所占用的字节数 </p> 
<pre class="prettyprint"><code class=" hljs fsharp">#define FSIZ( <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">field</span> ) <span class="hljs-title">sizeof</span>(</span> ((<span class="hljs-class"><span class="hljs-keyword">type</span> *) 0)-&gt;<span class="hljs-title">field</span> )</span></code></pre> 
<p>5 得到一个变量的地址（word宽度）</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-variable">#define</span> B_PTR( <span class="hljs-built_in">var</span> ) ( (byte <span class="hljs-subst">*</span>) (<span class="hljs-literal">void</span> <span class="hljs-subst">*</span>) <span class="hljs-subst">&amp;</span>(<span class="hljs-built_in">var</span>) ) 
<span class="hljs-variable">#define</span> W_PTR( <span class="hljs-built_in">var</span> ) ( (word <span class="hljs-subst">*</span>) (<span class="hljs-literal">void</span> <span class="hljs-subst">*</span>) <span class="hljs-subst">&amp;</span>(<span class="hljs-built_in">var</span>) )</code></pre> 
<p>6 将一个字母转换为大写</p> 
<pre class="prettyprint"><code class=" hljs ruleslanguage"><span class="hljs-array">#define UPCASE</span>( c ) ( ((c) &gt;= <span class="hljs-string">''</span>a<span class="hljs-string">''</span> &amp;&amp; (c) &lt;= <span class="hljs-string">''</span>z<span class="hljs-string">''</span>) ? ((c) - <span class="hljs-number">0x20</span>) : (c) )</code></pre> 
<p>7 判断字符是不是10进值的数字</p> 
<pre class="prettyprint"><code class=" hljs ruleslanguage"><span class="hljs-array">#define DECCHK</span>( c ) ((c) &gt;= <span class="hljs-string">''</span><span class="hljs-number">0</span><span class="hljs-string">''</span> &amp;&amp; (c) &lt;= <span class="hljs-string">''</span><span class="hljs-number">9</span><span class="hljs-string">''</span>)</code></pre> 
<p>8 判断字符是不是16进值的数字 </p> 
<pre class="prettyprint"><code class=" hljs ruleslanguage"><span class="hljs-array">#define HEXCHK</span>( c ) ( ((c) &gt;= <span class="hljs-string">''</span><span class="hljs-number">0</span><span class="hljs-string">''</span> &amp;&amp; (c) &lt;= <span class="hljs-string">''</span><span class="hljs-number">9</span><span class="hljs-string">''</span>) ||((c) &gt;= <span class="hljs-string">''</span>A<span class="hljs-string">''</span> &amp;&amp; (c) &lt;= <span class="hljs-string">''</span>F<span class="hljs-string">''</span>) ||((c) &gt;= <span class="hljs-string">''</span>a<span class="hljs-string">''</span> &amp;&amp; (c) &lt;= <span class="hljs-string">''</span>f<span class="hljs-string">''</span>) )</code></pre> 
<p>9 防止溢出的一个方法</p> 
<pre class="prettyprint"><code class=" hljs fsharp">#define INC_SAT( <span class="hljs-keyword">val</span> ) (<span class="hljs-keyword">val</span> = ((<span class="hljs-keyword">val</span>)+<span class="hljs-number">1</span> &gt; (<span class="hljs-keyword">val</span>)) ? (<span class="hljs-keyword">val</span>)+<span class="hljs-number">1</span> : (<span class="hljs-keyword">val</span>))</code></pre> 
<p>10 返回数组元素的个数</p> 
<pre class="prettyprint"><code class=" hljs autohotkey">#define ARR_SIZE( <span class="hljs-literal">a</span> ) ( sizeof( (<span class="hljs-literal">a</span>) ) / sizeof( (<span class="hljs-literal">a</span>[<span class="hljs-number">0</span>]) ) )</code></pre> 
<p>11 使用一些宏跟踪调试 <br> ANSI标准说明了五个预定义的宏名。它们是</p> 
<pre class="prettyprint"><code class=" hljs cs">_LINE_ <span class="hljs-comment">/*(两个下划线)，对应%d*/</span>
_FILE_ <span class="hljs-comment">/*对应%s*/</span>
_DATE_ <span class="hljs-comment">/*对应%s*/</span>
_TIME_ <span class="hljs-comment">/*对应%s*/</span></code></pre> 
<p>摘自：<a href="http://blog.chinaunix.net/uid-21372424-id-119797.html" rel="nofollow">http://blog.chinaunix.net/uid-21372424-id-119797.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a46d2966499bbe368c0cd561a2da0a78/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 二维码ZXing使用详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3d4ca997cf0bce19b91a832c37dbcf32/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言_“/”和“%”运算符详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>