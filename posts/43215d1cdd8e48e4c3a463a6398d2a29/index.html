<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>互联网网站的反爬虫策略浅析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="互联网网站的反爬虫策略浅析" />
<meta property="og:description" content="因为搜索引擎的流行，网络爬虫已经成了很普及网络技术，除了专门做搜索的Google，Yahoo，微软，百度以外，几乎每个大型门户网站都有自己的搜索引擎，大大小小叫得出来名字得就几十种，还有各种不知名的几千几万种，对于一个内容型驱动的网站来说，受到网络爬虫的光顾是不可避免的。
一些智能的搜索引擎爬虫的爬取频率比较合理，对网站资源消耗比较少，但是很多糟糕的网络爬虫，对网页爬取能力很差，经常并发几十上百个请求循环重复抓取，这种爬虫对中小型网站往往是毁灭性打击，特别是一些缺乏爬虫编写经验的程序员写出来的爬虫破坏力极强，造成的网站访问压力会非常大，会导致网站访问速度缓慢，甚至无法访问。
手工识别和拒绝爬虫的访问 相当多的爬虫对网站会造成非常高的负载，因此识别爬虫的来源IP是很容易的事情。最简单的办法就是用netstat检查80端口的连接：
netstat -nt | grep youhostip:80 | awk &#39;{print $5}&#39; | awk -F&#34;:&#34; &#39;{print $1}&#39;| sort | uniq -c | sort -r -n 这行shell可以按照80端口连接数量对来源IP进行排序，这样可以直观的判断出来网页爬虫。一般来说爬虫的并发连接非常高。
如果使用lighttpd做Web Server，那么就更简单了。lighttpd的mod_status提供了非常直观的并发连接的信息，包括每个连接的来源IP，访问的URL，连接状态和连接时间等信息，只要检查那些处于handle-request状态的高并发IP就可以很快确定爬虫的来源IP了。
拒绝爬虫请求既可以通过内核防火墙来拒绝，也可以在web server拒绝，比方说用iptables拒绝：
iptables -A INPUT -i eth0 -j DROP -p tcp --dport 80 -s 84.80.46.0/24 直接封锁爬虫所在的C网段地址。这是因为一般爬虫都是运行在托管机房里面，可能在一个C段里面的多台服务器上面都有爬虫，而这个C段不可能是用户宽带上网，封锁C段可以很大程度上解决问题。
通过识别爬虫的User-Agent信息来拒绝爬虫 有很多爬虫并不会以很高的并发连接爬取，一般不容易暴露自己；有些爬虫的来源IP分布很广，很难简单的通过封锁IP段地址来解决问题；另外还有很多各种各样的小爬虫，它们在尝试Google以外创新的搜索方式，每个爬虫每天爬取几万的网页，几十个爬虫加起来每天就能消耗掉上百万动态请求的资源，由于每个小爬虫单独的爬取量都很低，所以你很难把它从每天海量的访问IP地址当中把它准确的挖出来。
这种情况下我们可以通过爬虫的User-Agent信息来识别。每个爬虫在爬取网页的时候，会声明自己的User-Agent信息，因此我们就可以通过记录和分析User-Agent信息来挖掘和封锁爬虫。我们需要记录每个请求的User-Agent信息，对于Rails来说我们可以简单的在app/controllers/application.rb里面添加一个全局的before_filter，来记录每个请求的User-Agent信息：
logger.info &#34;HTTP_USER_AGENT #{request.env[&#34;HTTP_USER_AGENT&#34;]}&#34; 然后统计每天的production.log，抽取User-Agent信息，找出访问量最大的那些User-Agent。要注意的是我们只关注那些爬虫的User-Agent信息，而不是真正浏览器User-Agent，所以还要排除掉浏览器User-Agent，要做到这一点仅仅需要一行shell：
grep HTTP_USER_AGENT production.log | grep -v -E &#39;MSIE|Firefox|Chrome|Opera|Safari|Gecko&#39; | sort | uniq -c | sort -r -n | head -n 100 &gt; bot." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/43215d1cdd8e48e4c3a463a6398d2a29/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-04-20T23:50:59+08:00" />
<meta property="article:modified_time" content="2016-04-20T23:50:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">互联网网站的反爬虫策略浅析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="">因为搜索引擎的流行，网络爬虫已经成了很普及网络技术，除了专门做搜索的Google，Yahoo，微软，百度以外，几乎每个大型门户网站都有自己的搜索引擎，大大小小叫得出来名字得就几十种，还有各种不知名的几千几万种，对于一个内容型驱动的网站来说，受到网络爬虫的光顾是不可避免的。</p> 
<p style="">一些智能的搜索引擎爬虫的爬取频率比较合理，对网站资源消耗比较少，但是很多糟糕的网络爬虫，对网页爬取能力很差，经常并发几十上百个请求循环重复抓取，这种爬虫对中小型网站往往是毁灭性打击，特别是一些缺乏爬虫编写经验的程序员写出来的爬虫破坏力极强，造成的网站访问压力会非常大，会导致网站访问速度缓慢，甚至无法访问。</p> 
<h3 style="">手工识别和拒绝爬虫的访问</h3> 
<p style="">相当多的爬虫对网站会造成非常高的负载，因此识别爬虫的来源IP是很容易的事情。最简单的办法就是用netstat检查80端口的连接：</p> 
<pre style=""><code class="ruby" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent"><span class="identifier">netstat</span> -<span class="identifier">nt</span> | <span class="identifier"><span class="keymethods">grep</span></span> <span class="identifier">youhostip</span><span class="symbol" style="color:rgb(153,0,115)">:</span><span class="number" style="color:rgb(0,153,153)">80</span> | <span class="identifier">awk</span> <span class="string" style="color:rgb(221,17,68)">'{print $5}'</span> | <span class="identifier">awk</span> -<span class="constant" style="color:rgb(0,153,153)">F</span><span class="string" style="color:rgb(221,17,68)">":"</span> <span class="string" style="color:rgb(221,17,68)">'{print $1}'</span>| <span class="identifier"><span class="keymethods">sort</span></span> | <span class="identifier"><span class="keymethods">uniq</span></span> -<span class="identifier">c</span> | <span class="identifier"><span class="keymethods">sort</span></span> -<span class="identifier">r</span> -<span class="identifier">n</span> 
</code></pre> 
<p style="">这行shell可以按照80端口连接数量对来源IP进行排序，这样可以直观的判断出来网页爬虫。一般来说爬虫的并发连接非常高。</p> 
<p style="">如果使用lighttpd做Web Server，那么就更简单了。lighttpd的mod_status提供了非常直观的并发连接的信息，包括每个连接的来源IP，访问的URL，连接状态和连接时间等信息，只要检查那些处于handle-request状态的高并发IP就可以很快确定爬虫的来源IP了。</p> 
<p style="">拒绝爬虫请求既可以通过内核防火墙来拒绝，也可以在web server拒绝，比方说用iptables拒绝：</p> 
<pre style=""><code class="perl" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent">iptables -A INPUT -i eth<span class="number" style="color:rgb(0,153,153)">0</span> -j DROP -p tcp --dport <span class="number" style="color:rgb(0,153,153)">80</span> -<span class="keyword" style="color:rgb(51,51,51); font-weight:bold">s</span> <span class="number" style="color:rgb(0,153,153)">84.80</span>.<span class="number" style="color:rgb(0,153,153)">46.0</span>/<span class="number" style="color:rgb(0,153,153)">24</span>  
</code></pre> 
<p style="">直接封锁爬虫所在的C网段地址。这是因为一般爬虫都是运行在托管机房里面，可能在一个C段里面的多台服务器上面都有爬虫，而这个C段不可能是用户宽带上网，封锁C段可以很大程度上解决问题。</p> 
<h3 style="">通过识别爬虫的User-Agent信息来拒绝爬虫</h3> 
<p style="">有很多爬虫并不会以很高的并发连接爬取，一般不容易暴露自己；有些爬虫的来源IP分布很广，很难简单的通过封锁IP段地址来解决问题；另外还有很多各种各样的小爬虫，它们在尝试Google以外创新的搜索方式，每个爬虫每天爬取几万的网页，几十个爬虫加起来每天就能消耗掉上百万动态请求的资源，由于每个小爬虫单独的爬取量都很低，所以你很难把它从每天海量的访问IP地址当中把它准确的挖出来。</p> 
<p style="">这种情况下我们可以通过爬虫的User-Agent信息来识别。每个爬虫在爬取网页的时候，会声明自己的User-Agent信息，因此我们就可以通过记录和分析User-Agent信息来挖掘和封锁爬虫。我们需要记录每个请求的User-Agent信息，对于Rails来说我们可以简单的在app/controllers/application.rb里面添加一个全局的before_filter，来记录每个请求的User-Agent信息：</p> 
<pre style=""><code class="ruby" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent"><span class="identifier">logger</span>.<span class="identifier">info</span> <span class="string" style="color:rgb(221,17,68)">"HTTP_USER_AGENT <span class="subst" style="color:rgb(51,51,51); font-weight:normal">#{<!-- --><span class="identifier">request</span>.<span class="identifier">env</span>[<span class="string" style="color:rgb(221,17,68)">"HTTP_USER_AGENT"</span>]}</span>"</span>  
</code></pre> 
<p style="">然后统计每天的production.log，抽取User-Agent信息，找出访问量最大的那些User-Agent。要注意的是我们只关注那些爬虫的User-Agent信息，而不是真正浏览器User-Agent，所以还要排除掉浏览器User-Agent，要做到这一点仅仅需要一行shell：</p> 
<pre style=""><code class="perl" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">grep</span> HTTP_USER_AGENT production.<span class="keyword" style="color:rgb(51,51,51); font-weight:bold">log</span> | <span class="keyword" style="color:rgb(51,51,51); font-weight:bold">grep</span> -v -E <span class="string" style="color:rgb(221,17,68)">'MSIE|Firefox|Chrome|Opera|Safari|Gecko'</span> | <span class="keyword" style="color:rgb(51,51,51); font-weight:bold">sort</span> | uniq -c | <span class="keyword" style="color:rgb(51,51,51); font-weight:bold">sort</span> -r -n | head -n <span class="number" style="color:rgb(0,153,153)">100</span> &gt; bot.<span class="keyword" style="color:rgb(51,51,51); font-weight:bold">log</span>
</code></pre> 
<p style="">统计结果类似这样：</p> 
<pre style=""><code class="java" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent">  <span class="number" style="color:rgb(0,153,153)">57335</span> HTTP_USER_AGENT Baiduspider+(+http:<span class="comment" style="color:rgb(153,153,136); font-style:italic; padding:20px 40px">//www.baidu.com/search/spider.htm)</span>
  <span class="number" style="color:rgb(0,153,153)">56639</span> HTTP_USER_AGENT Mozilla/<span class="number" style="color:rgb(0,153,153)">5.0</span> (compatible; Googlebot/<span class="number" style="color:rgb(0,153,153)">2.1</span>; +http:<span class="comment" style="color:rgb(153,153,136); font-style:italic; padding:20px 40px">//www.google.com/bot.html)</span>
  <span class="number" style="color:rgb(0,153,153)">42610</span> HTTP_USER_AGENT Mediapartners-Google
  <span class="number" style="color:rgb(0,153,153)">19131</span> HTTP_USER_AGENT msnbot/<span class="number" style="color:rgb(0,153,153)">2.0</span>b (+http:<span class="comment" style="color:rgb(153,153,136); font-style:italic; padding:20px 40px">//search.msn.com/msnbot.htm)    </span>
</code></pre> 
<p style="">从日志就可以直观的看出每个爬虫的请求次数。要根据User-Agent信息来封锁爬虫是件很容易的事情，lighttpd配置如下：</p> 
<pre style=""><code class="perl" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent"><span class="variable" style="color:rgb(0,128,128)">$HTTP</span>[<span class="string" style="color:rgb(221,17,68)">"useragent"</span>] =~ <span class="string" style="color:rgb(221,17,68)">"qihoobot|^Java|Commons-HttpClient|Wget|^PHP|Ruby|Python"</span> {
  url.rewrite = ( <span class="string" style="color:rgb(221,17,68)">"^/(.<span class="variable" style="color:rgb(0,128,128)">*)</span>"</span> =&gt; <span class="string" style="color:rgb(221,17,68)">"/crawler.html"</span> )
}
</code></pre> 
<p style="">使用这种方式来封锁爬虫虽然简单但是非常有效，除了封锁特定的爬虫，还可以封锁常用的编程语言和HTTP类库的User-Agent信息，这样就可以避免很多无谓的程序员用来练手的爬虫程序对网站的骚扰。</p> 
<p style="">还有一种比较常见的情况，就是某个搜索引擎的爬虫对网站爬取频率过高，但是搜索引擎给网站带来了很多流量，我们并不希望简单的封锁爬虫，仅仅是希望降低爬虫的请求频率，减轻爬虫对网站造成的负载，那么我们可以这样做：</p> 
<pre style=""><code class="bash" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent"><span class="variable" style="color:rgb(0,128,128)">$HTTP</span>[<span class="string" style="color:rgb(221,17,68)">"user-agent"</span>] =~ <span class="string" style="color:rgb(221,17,68)">"Baiduspider+"</span> {
    connection.delay-seconds = <span class="number" style="color:rgb(0,153,153)">10</span>
}    
</code></pre> 
<p style="">对百度的爬虫请求延迟10秒钟再进行处理，这样就可以有效降低爬虫对网站的负载了。</p> 
<h3 style="">通过网站流量统计系统和日志分析来识别爬虫</h3> 
<p style="">有些爬虫喜欢修改User-Agent信息来伪装自己，把自己伪装成一个真实浏览器的User-Agent信息，让你无法有效的识别。这种情况下我们可以通过网站流量系统记录的真实用户访问IP来进行识别。</p> 
<p style="">主流的网站流量统计系统不外乎两种实现策略：一种策略是在网页里面嵌入一段js，这段js会向特定的统计服务器发送请求的方式记录访问量；另一种策略是直接分析服务器日志，来统计网站访问量。在理想的情况下，嵌入js的方式统计的网站流量应该高于分析服务器日志，这是因为用户浏览器会有缓存，不一定每次真实用户访问都会触发服务器的处理。但实际情况是，分析服务器日志得到的网站访问量远远高于嵌入js方式，极端情况下，甚至要高出10倍以上。</p> 
<p style="">现在很多网站喜欢采用awstats来分析服务器日志，来计算网站的访问量，但是当他们一旦采用Google Analytics来统计网站流量的时候，却发现GA统计的流量远远低于awstats，为什么GA和awstats统计会有这么大差异呢？罪魁祸首就是把自己伪装成浏览器的网络爬虫。这种情况下awstats无法有效的识别了，所以awstats的统计数据会虚高。</p> 
<p style="">其实作为一个网站来说，如果希望了解自己的网站真实访问量，希望精确了解网站每个频道的访问量和访问用户，应该用页面里面嵌入js的方式来开发自己的网站流量统计系统。自己做一个网站流量统计系统是件很简单的事情，写段服务器程序响应客户段js的请求，分析和识别请求然后写日志的同时做后台的异步统计就搞定了。</p> 
<p style="">通过流量统计系统得到的用户IP基本是真实的用户访问，因为一般情况下爬虫是无法执行网页里面的js代码片段的。所以我们可以拿流量统计系统记录的IP和服务器程序日志记录的IP地址进行比较，如果服务器日志里面某个IP发起了大量的请求，在流量统计系统里面却根本找不到，或者即使找得到，可访问量却只有寥寥几个，那么无疑就是一个网络爬虫。</p> 
<p style="">分析服务器日志统计访问最多的IP地址段一行shell就可以了：</p> 
<pre style=""><code class="perl" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">grep</span> Processing production.<span class="keyword" style="color:rgb(51,51,51); font-weight:bold">log</span> | awk <span class="string" style="color:rgb(221,17,68)">'{print $4}'</span> | awk -F<span class="string" style="color:rgb(221,17,68)">'.'</span> <span class="string" style="color:rgb(221,17,68)">'{print $1"."$2"."$3".0"}'</span> | <span class="keyword" style="color:rgb(51,51,51); font-weight:bold">sort</span> | uniq -c | <span class="keyword" style="color:rgb(51,51,51); font-weight:bold">sort</span> -r -n | head -n <span class="number" style="color:rgb(0,153,153)">200</span> &gt; stat_ip.<span class="keyword" style="color:rgb(51,51,51); font-weight:bold">log</span>
</code></pre> 
<p style="">然后把统计结果和流量统计系统记录的IP地址进行对比，排除真实用户访问IP，再排除我们希望放行的网页爬虫，比方Google，百度，微软msn爬虫等等。最后的分析结果就就得到了爬虫的IP地址了。以下代码段是个简单的实现示意：</p> 
<pre style=""><code class="ruby" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent"><span class="identifier">whitelist</span> = []
<span class="constant" style="color:rgb(0,153,153)">IO</span>.<span class="identifier"><span class="keymethods">foreach</span></span>(<span class="string" style="color:rgb(221,17,68)">"<span class="subst" style="color:rgb(51,51,51); font-weight:normal">#{<!-- --><span class="constant" style="color:rgb(0,153,153)">RAILS_ROOT</span>}</span>/lib/whitelist.txt"</span>) { |<span class="identifier">line</span>| <span class="identifier">whitelist</span> &lt;&lt; <span class="identifier">line</span>.<span class="identifier"><span class="keymethods">split</span></span>[<span class="number" style="color:rgb(0,153,153)">0</span>].<span class="identifier"><span class="keymethods">strip</span></span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">if</span></span> <span class="identifier">line</span> }

<span class="identifier">realiplist</span> = []
<span class="constant" style="color:rgb(0,153,153)">IO</span>.<span class="identifier"><span class="keymethods">foreach</span></span>(<span class="string" style="color:rgb(221,17,68)">"<span class="subst" style="color:rgb(51,51,51); font-weight:normal">#{<!-- --><span class="constant" style="color:rgb(0,153,153)">RAILS_ROOT</span>}</span>/log/visit_ip.log"</span>) { |<span class="identifier">line</span>|  <span class="identifier">realiplist</span> &lt;&lt; <span class="identifier">line</span>.<span class="identifier"><span class="keymethods">strip</span></span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">if</span></span> <span class="identifier">line</span> }

<span class="identifier">iplist</span> = []
<span class="constant" style="color:rgb(0,153,153)">IO</span>.<span class="identifier"><span class="keymethods">foreach</span></span>(<span class="string" style="color:rgb(221,17,68)">"<span class="subst" style="color:rgb(51,51,51); font-weight:normal">#{<!-- --><span class="constant" style="color:rgb(0,153,153)">RAILS_ROOT</span>}</span>/log/stat_ip.log"</span>) <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">do</span></span> |<span class="identifier">line</span>|
  <span class="identifier">ip</span> = <span class="identifier">line</span>.<span class="identifier"><span class="keymethods">split</span></span>[<span class="number" style="color:rgb(0,153,153)">1</span>].<span class="identifier"><span class="keymethods">strip</span></span>
  <span class="identifier">iplist</span> &lt;&lt; <span class="identifier">ip</span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">if</span></span> <span class="identifier">line</span>.<span class="identifier"><span class="keymethods">split</span></span>[<span class="number" style="color:rgb(0,153,153)">0</span>].<span class="identifier"><span class="keymethods">to_i</span></span> &gt; <span class="number" style="color:rgb(0,153,153)">3000</span> &amp;&amp; !<span class="identifier">whitelist</span>.<span class="identifier"><span class="keymethods">include?</span></span>(<span class="identifier">ip</span>) &amp;&amp; !<span class="identifier">realiplist</span>.<span class="identifier"><span class="keymethods">include?</span></span>(<span class="identifier">ip</span>)
<span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">end</span></span> 

<span class="constant" style="color:rgb(0,153,153)">Report</span>.<span class="identifier">deliver_crawler</span>(<span class="identifier">iplist</span>)
</code></pre> 
<p style="">分析服务器日志里面请求次数超过3000次的IP地址段，排除白名单地址和真实访问IP地址，最后得到的就是爬虫IP了，然后可以发送邮件通知管理员进行相应的处理。</p> 
<h3 style="">网站的实时反爬虫防火墙实现策略</h3> 
<p style="">通过分析日志的方式来识别网页爬虫不是一个实时的反爬虫策略。如果一个爬虫非要针对你的网站进行处心积虑的爬取，那么他可能会采用分布式爬取策略，比方说寻找几百上千个国外的代理服务器疯狂的爬取你的网站，从而导致网站无法访问，那么你再分析日志是不可能及时解决问题的。所以必须采取实时反爬虫策略，要能够动态的实时识别和封锁爬虫的访问。</p> 
<p style="">要自己编写一个这样的实时反爬虫系统其实也很简单。比方说我们可以用memcached来做访问计数器，记录每个IP的访问频度，在单位时间之内，如果访问频率超过一个阀值，我们就认为这个IP很可能有问题，那么我们就可以返回一个验证码页面，要求用户填写验证码。如果是爬虫的话，当然不可能填写验证码，所以就被拒掉了，这样很简单就解决了爬虫问题。</p> 
<p style="">用memcache记录每个IP访问计数，单位时间内超过阀值就让用户填写验证码，用Rails编写的示例代码如下：</p> 
<pre style=""><code class="ruby" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent"><span class="identifier">ip_counter</span> = <span class="constant" style="color:rgb(0,153,153)">Rails</span>.<span class="identifier">cache</span>.<span class="identifier">increment</span>(<span class="identifier">request</span>.<span class="identifier">remote_ip</span>)
<span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">if</span></span> !<span class="identifier">ip_counter</span>
  <span class="constant" style="color:rgb(0,153,153)">Rails</span>.<span class="identifier">cache</span>.<span class="identifier"><span class="keymethods">write</span></span>(<span class="identifier">request</span>.<span class="identifier">remote_ip</span>, <span class="number" style="color:rgb(0,153,153)">1</span>, <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">expires_in</span></span> =&gt; <span class="number" style="color:rgb(0,153,153)">30</span>.<span class="identifier">minutes</span>)
<span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">elsif</span></span> <span class="identifier">ip_counter</span> &gt; <span class="number" style="color:rgb(0,153,153)">2000</span>
  <span class="identifier">render</span> <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">template</span></span> =&gt; <span class="string" style="color:rgb(221,17,68)">'test'</span>, <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">status</span></span> =&gt; <span class="number" style="color:rgb(0,153,153)">401</span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">and</span></span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">return</span></span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">false</span></span>
<span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">end</span></span>
</code></pre> 
<p style="">这段程序只是最简单的示例，实际的代码实现我们还会添加很多判断，比方说我们可能要排除白名单IP地址段，要允许特定的User-Agent通过，要针对登录用户和非登录用户，针对有无referer地址采取不同的阀值和计数加速器等等。</p> 
<p style="">此外如果分布式爬虫爬取频率过高的话，过期就允许爬虫再次访问还是会对服务器造成很大的压力，因此我们可以添加一条策略：针对要求用户填写验证码的IP地址，如果该IP地址短时间内继续不停的请求，则判断为爬虫，加入黑名单，后续请求全部拒绝掉。为此，示例代码可以改进一下：</p> 
<pre style=""><code class="ruby" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent"><span class="identifier">before_filter</span> <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">ip_firewall</span></span>, <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">except</span></span> =&gt; <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier"><span class="keymethods">test</span></span></span>
<span class="function"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">def</span> <span class="title" style="color:rgb(153,0,0); font-weight:bold">ip_firewall</span></span>
  <span class="identifier">render</span> <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">file</span></span> =&gt; <span class="string" style="color:rgb(221,17,68)">"<span class="subst" style="color:rgb(51,51,51); font-weight:normal">#{<!-- --><span class="constant" style="color:rgb(0,153,153)">RAILS_ROOT</span>}</span>/public/403.html"</span>, <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">status</span></span> =&gt; <span class="number" style="color:rgb(0,153,153)">403</span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">if</span></span> <span class="constant" style="color:rgb(0,153,153)">BlackList</span>.<span class="identifier"><span class="keymethods">include?</span></span>(<span class="identifier">ip_sec</span>)
<span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">end</span></span>    
</code></pre> 
<p style="">我们可以定义一个全局的过滤器，对所有请求进行过滤，出现在黑名单的IP地址一律拒绝。对非黑名单的IP地址再进行计数和统计：</p> 
<pre style=""><code class="ruby" style="margin:0px; padding:0px; font-style:normal; font-weight:normal; display:block; color:rgb(51,51,51); white-space:pre; border:none; background:transparent"><span class="identifier">ip_counter</span> = <span class="constant" style="color:rgb(0,153,153)">Rails</span>.<span class="identifier">cache</span>.<span class="identifier">increment</span>(<span class="identifier">request</span>.<span class="identifier">remote_ip</span>)
<span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">if</span></span> !<span class="identifier">ip_counter</span>
  <span class="constant" style="color:rgb(0,153,153)">Rails</span>.<span class="identifier">cache</span>.<span class="identifier"><span class="keymethods">write</span></span>(<span class="identifier">request</span>.<span class="identifier">remote_ip</span>, <span class="number" style="color:rgb(0,153,153)">1</span>, <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">expires_in</span></span> =&gt; <span class="number" style="color:rgb(0,153,153)">30</span>.<span class="identifier">minutes</span>)
<span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">elsif</span></span> <span class="identifier">ip_counter</span> &gt; <span class="number" style="color:rgb(0,153,153)">2000</span>
  <span class="identifier">crawler_counter</span> = <span class="constant" style="color:rgb(0,153,153)">Rails</span>.<span class="identifier">cache</span>.<span class="identifier">increment</span>(<span class="string" style="color:rgb(221,17,68)">"crawler/<span class="subst" style="color:rgb(51,51,51); font-weight:normal">#{<!-- --><span class="identifier">request</span>.<span class="identifier">remote_ip</span>}</span>"</span>)
  <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">if</span></span> !<span class="identifier">crawler_counter</span>
    <span class="constant" style="color:rgb(0,153,153)">Rails</span>.<span class="identifier">cache</span>.<span class="identifier"><span class="keymethods">write</span></span>(<span class="string" style="color:rgb(221,17,68)">"crawler/<span class="subst" style="color:rgb(51,51,51); font-weight:normal">#{<!-- --><span class="identifier">request</span>.<span class="identifier">remote_ip</span>}</span>"</span>, <span class="number" style="color:rgb(0,153,153)">1</span>, <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">expires_in</span></span> =&gt; <span class="number" style="color:rgb(0,153,153)">10</span>.<span class="identifier">minutes</span>)
  <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">elsif</span></span> <span class="identifier">crawler_counter</span> &gt; <span class="number" style="color:rgb(0,153,153)">50</span>
    <span class="constant" style="color:rgb(0,153,153)">BlackList</span>.<span class="identifier">add</span>(<span class="identifier">ip_sec</span>)
    <span class="identifier">render</span> <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">file</span></span> =&gt; <span class="string" style="color:rgb(221,17,68)">"<span class="subst" style="color:rgb(51,51,51); font-weight:normal">#{<!-- --><span class="constant" style="color:rgb(0,153,153)">RAILS_ROOT</span>}</span>/public/403.html"</span>, <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">status</span></span> =&gt; <span class="number" style="color:rgb(0,153,153)">403</span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">and</span></span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">return</span></span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">false</span></span>
  <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">end</span></span>
  <span class="identifier">render</span> <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">template</span></span> =&gt; <span class="string" style="color:rgb(221,17,68)">'test'</span>, <span class="symbol" style="color:rgb(153,0,115)">:<span class="identifier">status</span></span> =&gt; <span class="number" style="color:rgb(0,153,153)">401</span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">and</span></span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">return</span></span> <span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">false</span></span>
<span class="identifier"><span class="keyword" style="color:rgb(51,51,51); font-weight:bold">end</span></span>
</code></pre> 
<p style="">如果某个IP地址单位时间内访问频率超过阀值，再增加一个计数器，跟踪他会不会立刻填写验证码，如果他不填写验证码，在短时间内还是高频率访问，就把这个IP地址段加入黑名单，除非用户填写验证码激活，否则所有请求全部拒绝。这样我们就可以通过在程序里面维护黑名单的方式来动态的跟踪爬虫的情况，甚至我们可以自己写个后台来手工管理黑名单列表，了解网站爬虫的情况。</p> 
<p style="">关于这个通用反爬虫的功能，我们开发一个开源的插件：<a target="_blank" href="https://github.com/csdn-dev/limiter" style="color:rgb(255,102,0); text-decoration:none" rel="noopener noreferrer">https://github.com/csdn-dev/limiter</a></p> 
<p style="">这个策略已经比较智能了，但是还不够好！我们还可以继续改进：</p> 
<p style="">1、用网站流量统计系统来改进实时反爬虫系统</p> 
<p style="">还记得吗？网站流量统计系统记录的IP地址是真实用户访问IP，所以我们在网站流量统计系统里面也去操作memcached，但是这次不是增加计数值，而是减少计数值。在网站流量统计系统里面每接收到一个IP请求，就相应的cache.decrement(key)。所以对于真实用户的IP来说，它的计数值总是加1然后就减1，不可能很高。这样我们就可以大大降低判断爬虫的阀值，可以更加快速准确的识别和拒绝掉爬虫。</p> 
<p style="">2、用时间窗口来改进实时反爬虫系统</p> 
<p style="">爬虫爬取网页的频率都是比较固定的，不像人去访问网页，中间的间隔时间比较无规则，所以我们可以给每个IP地址建立一个时间窗口，记录IP地址最近12次访问时间，每记录一次就滑动一次窗口，比较最近访问时间和当前时间，如果间隔时间很长判断不是爬虫，清除时间窗口，如果间隔不长，就回溯计算指定时间段的访问频率，如果访问频率超过阀值，就转向验证码页面让用户填写验证码。</p> 
<p style="">最终这个实时反爬虫系统就相当完善了，它可以很快的识别并且自动封锁爬虫的访问，保护网站的正常访问。不过有些爬虫可能相当狡猾，它也许会通过大量的爬虫测试来试探出来你的访问阀值，以低于阀值的爬取速度抓取你的网页，因此我们还需要辅助第3种办法，用日志来做后期的分析和识别，就算爬虫爬的再慢，它累计一天的爬取量也会超过你的阀值被你日志分析程序识别出来。</p> 
<p style="">总之我们综合运用上面的四种反爬虫策略，可以很大程度上缓解爬虫对网站造成的负面影响，保证网站的正常访问。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c99f3dcde4669686fb6065c36f962e38/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL启动报“[Warning] Buffered warning: Changed limits: max_open_files: 1024 (requested 15000)”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed11ed4949d9284e2d71ca5cfe5c081c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">how to create proxies pool</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>