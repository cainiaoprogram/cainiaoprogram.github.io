<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络（3） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机网络（3）" />
<meta property="og:description" content="面向连接的运输：TCP TCP连接 定义：两个应用进程通信之前必须建立“握手”连接，初始化TCP连接参数。逻辑连接，其连接的共同状态只保留在两个通信端系统的TCP程序中，即TCP协议只运行在端系统中，对底层透明。特点： 面向字节流：TCP将数据看成无结构的、有序的字节流流水线机制：TCP拥塞控制、流量控制、设置窗口大小·全双工服务(full-duplex service)：A、B具有TCP连接，则数据可在A、B间双向传递点对点(point-to-point)：只能在单个发送方、单个接收方之间连接，所以不能实现“多播”三次握手(three-way handshake)：客户首先发出特殊的TCP报文段，服务器反馈一个TCP报文段，客户再使用第三个TCP报文段作为响应。（前两个不包含数据，第三个可以包含数据。）最大报文段长度(Maximum Segment Size,MSS)： TCP从发送缓存中取出并放入报文段中的应用层数据的最大长度。最大传输单元(Maximum Transmission Unit,MTU)： MSS受限于链路层的帧长度。在以太网和PPP链路层协议中，MTU 为1500B，TCP/IP首部长度为40B，因此MSS长度为1460B。路径MTU，是指从源到目的地的所有链路中的发送的最大链路层帧。 组成：发送方主机缓存、变量、与进程连接的套接字，接收方主机缓存、变量、与进程连接的套接字。TCP只运行在端系统中，所以主机之间的其他网络设备都不包含缓存、变量。
TCP报文段结构 源端口号/目的端口号：2B，实现多路复用与分解，端口是传输层和应用层的服务接口。
检验和：2B，实现差错检测，检验范围包括首部和数据，为计算方便，可添加12B的伪首部。
序号：4B，实现可靠数据传输。序号是建立在传送的字节流之上，不是报文段的序列，即序号是指该报文段首字节的字节流编号。
例1：数据流为500000B的文件，MSS为1000B，则TCP将该数据分为500个报文段。第一个报文段序号为0，第二个报文段序号为1000，第三个为2000。
例2：TCP传输时，初始序列号总是从0开始吗？如果不是，为什么？
答：不是，连接双方都可以随机产生的初始序列号，防止攻击者对TCP序列进行预测攻击！
确认号：4B，实现可靠数据传输。确认号建立在全双工服务上，主机A的确认号是主机A期望从主机B接收到的下一字节的序号。
例1：A已经收到B的0~535的所有字节，正常情况。此时A打算向B发送一个报文段，则该报文段中的确认号为536
例2：A收到B的0~535和900 ~1000的所有字节，但还没有收到536 ~ 899的报文段，报文丢失。TCP采用累积确认，所以仍将等待字节536（和其后的所有字节），故A打算发送给B的报文段的确认号为536
例3：主机A先后收到0~535，900 ~ 1000，536 ~899字节的报文段，失序到达。RFC文档中并未明确规定处理原则，交给编程人员处理。①接收方立即丢弃失序报文段，操作简单但是无意义②接收方缓冲失序的字节，等待缺少的字节以填补该间隔，更有效，符合实践要求
接收窗口：2B，实现流量控制，指示接收方期望接收的字节数量。
数据偏移：1B，指示该TCP首部的长度，以32bit的字位单位。由于选项字段可变，所以TCP首部长度是可变的。
选项：可选并且可变长，实现协商MSS或调节窗口大小。
标志字段：6bit。
URG：紧急，当URG=1时，表明本报文段的数据中的紧急数据占多少字节，紧急数据放在数据的最前面，由紧急指针指出。当紧急数据存在并给出了指向紧急数据尾指针的时候，TCP通知接收方的应用层（在实践中，URG和紧急指针并不使用）；ACK：确认，当ACK=1时，表明对已被成功接收报文段的确认。PSH：立即推送，当PSH=1时，表明接收方应立即将数据交给上层。RST：复位，当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新连接。SYN：建立连接，当SYN=1时，表明该报文段是连接请求或连接接收报文。FIN：终止连接，当FIN=1时，表明该报文段的数据已发送完毕，并要求释放连接。 填充：使首部长度为4B的整数倍。
TCP抓取：
往返时间的估计与超时 估计往返时间： 样本RTT(SampleRTT)：报文段发出到收到确认之间的时间量，只做一次SampleRTT测量，忽略重传的报文段；会随路由器的拥塞和端系统的负载的变化，而随之波动变化；典型RTT(EstimatedRTT)：平滑处理，使用样本RTT的加权均值，该方法在统计学中称为指数加权移动平均(EWMA)
计算公式： E s t i m a t e d R T T = ( 1 − α ) ∗ E s t i m a t e d R T T &#43; α ∗ S a m p l e R T T EstimatedRTT =(1-α)*EstimatedRTT&#43;α*SampleRTT EstimatedRTT=(1−α)∗EstimatedRTT&#43;α∗SampleRTT，α的推荐值为0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/48df16bc78f6014c1f988504b74df530/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-07T09:39:59+08:00" />
<meta property="article:modified_time" content="2023-02-07T09:39:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络（3）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="TCP_0"></a>面向连接的运输：TCP</h3> 
<h4><a id="TCP_1"></a>TCP连接</h4> 
<ul><li>定义：两个应用进程通信之前必须建立“握手”连接，初始化TCP连接参数。逻辑连接，其连接的共同状态只保留在两个通信端系统的TCP程序中，即<font color="red">TCP协议只运行在端系统中，对底层透明。</font></li><li>特点： 
  <ul><li>面向字节流：TCP将数据看成无结构的、有序的字节流</li><li>流水线机制：TCP拥塞控制、流量控制、设置窗口大小·</li><li>全双工服务(full-duplex service)：A、B具有TCP连接，则数据可在A、B间双向传递</li><li>点对点(point-to-point)：<font color="red">只能在单个发送方、单个接收方之间连接，所以不能实现“多播”</font></li><li>三次握手(three-way handshake)：客户首先发出特殊的TCP报文段，服务器反馈一个TCP报文段，客户再使用第三个TCP报文段作为响应。（前两个不包含数据，第三个可以包含数据。）</li><li><strong>最大报文段长度(Maximum Segment Size,MSS)：</strong> TCP从发送缓存中取出并放入报文段中的<font color="red">应用层数据的最大长度</font>。</li><li><strong>最大传输单元(Maximum Transmission Unit,MTU)：</strong> MSS受限于链路层的帧长度。在以太网和PPP链路层协议中，MTU 为1500B，TCP/IP首部长度为40B，因此MSS长度为1460B。路径MTU，是指从源到目的地的所有链路中的发送的最大链路层帧。</li></ul> </li><li>组成：发送方主机缓存、变量、与进程连接的套接字，接收方主机缓存、变量、与进程连接的套接字。<font color="red">TCP只运行在端系统中，所以主机之间的其他网络设备都不包含缓存、变量。</font><br> <img src="https://images2.imgbox.com/c4/97/ph6yV4y3_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="TCP_14"></a>TCP报文段结构</h4> 
<ul><li> <p>源端口号/目的端口号：2B，实现多路复用与分解，端口是传输层和应用层的服务接口。</p> </li><li> <p>检验和：2B，实现差错检测，检验范围包括首部和数据，为计算方便，可添加12B的伪首部。</p> </li><li> <p><font color="red">序号：4B，实现可靠数据传输。序号是建立在传送的字节流之上，不是报文段的序列，即序号是指该报文段首字节的字节流编号。</font></p> 
  <blockquote> 
   <p>例1：数据流为500000B的文件，MSS为1000B，则TCP将该数据分为500个报文段。第一个报文段序号为0，第二个报文段序号为1000，第三个为2000。<br> <font color="red">例2：TCP传输时，初始序列号总是从0开始吗？如果不是，为什么？</font><br> 答：不是，连接双方都可以随机产生的初始序列号，防止攻击者对TCP序列进行预测攻击！</p> 
  </blockquote> </li><li> <p><font color="red">确认号：4B，实现可靠数据传输。确认号建立在全双工服务上，主机A的确认号是主机A期望从主机B接收到的下一字节的序号。</font></p> 
  <blockquote> 
   <p>例1：A已经收到B的0~535的所有字节，<strong>正常情况</strong>。此时A打算向B发送一个报文段，则该报文段中的确认号为536<br> 例2：A收到B的0~535和900 ~1000的所有字节，但还没有收到536 ~ 899的报文段，<strong>报文丢失</strong>。TCP采用累积确认，所以仍将等待字节536（和其后的所有字节），故A打算发送给B的报文段的确认号为536<br> 例3：主机A先后收到0~535，900 ~ 1000，536 ~899字节的报文段，<strong>失序到达</strong>。RFC文档中并未明确规定处理原则，交给编程人员处理。①接收方立即丢弃失序报文段，操作简单但是无意义②接收方缓冲失序的字节，等待缺少的字节以填补该间隔，更有效，符合实践要求</p> 
  </blockquote> </li><li> <p>接收窗口：2B，实现流量控制，指示接收方期望接收的字节数量。</p> </li><li> <p>数据偏移：1B，指示该TCP首部的长度，以32bit的字位单位。由于选项字段可变，所以TCP首部长度是可变的。</p> </li><li> <p>选项：可选并且可变长，实现协商MSS或调节窗口大小。</p> </li><li> <p>标志字段：6bit。</p> 
  <ul><li>URG：紧急，当URG=1时，表明本报文段的数据中的紧急数据占多少字节，紧急数据放在数据的最前面，由紧急指针指出。当紧急数据存在并给出了指向紧急数据尾指针的时候，TCP通知接收方的应用层（在实践中，URG和紧急指针并不使用）；</li><li>ACK：确认，当ACK=1时，表明对已被成功接收报文段的确认。</li><li>PSH：立即推送，当PSH=1时，表明接收方应立即将数据交给上层。</li><li>RST：复位，当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新连接。</li><li>SYN：建立连接，当SYN=1时，表明该报文段是连接请求或连接接收报文。</li><li>FIN：终止连接，当FIN=1时，表明该报文段的数据已发送完毕，并要求释放连接。</li></ul> </li><li> <p>填充：使首部长度为4B的整数倍。<br> <img src="https://images2.imgbox.com/9d/b8/oW2Xkdsl_o.png" alt="在这里插入图片描述"></p> </li><li> <p>TCP抓取：<br> <img src="https://images2.imgbox.com/82/04/dwcK0aAW_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h4><a id="_41"></a>往返时间的估计与超时</h4> 
<ul><li>估计往返时间： 
  <ul><li><strong>样本RTT(SampleRTT)</strong>：报文段发出到收到确认之间的时间量，只做一次SampleRTT测量，忽略重传的报文段；会随路由器的拥塞和端系统的负载的变化，而随之波动变化；</li><li><strong>典型RTT(EstimatedRTT)</strong>：平滑处理，使用样本RTT的加权均值，该方法在统计学中称为<strong>指数加权移动平均(EWMA)</strong><br> 计算公式：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            E 
           
          
            s 
           
          
            t 
           
          
            i 
           
          
            m 
           
          
            a 
           
          
            t 
           
          
            e 
           
          
            d 
           
          
            R 
           
          
            T 
           
          
            T 
           
          
            = 
           
          
            ( 
           
          
            1 
           
          
            − 
           
          
            α 
           
          
            ) 
           
          
            ∗ 
           
          
            E 
           
          
            s 
           
          
            t 
           
          
            i 
           
          
            m 
           
          
            a 
           
          
            t 
           
          
            e 
           
          
            d 
           
          
            R 
           
          
            T 
           
          
            T 
           
          
            + 
           
          
            α 
           
          
            ∗ 
           
          
            S 
           
          
            a 
           
          
            m 
           
          
            p 
           
          
            l 
           
          
            e 
           
          
            R 
           
          
            T 
           
          
            T 
           
          
         
           EstimatedRTT =(1-α)*EstimatedRTT+α*SampleRTT 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ima</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right: 0.1389em;">RTT</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ima</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right: 0.1389em;">RTT</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4653em;"></span><span class="mord mathnormal" style="margin-right: 0.0037em;">α</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right: 0.0197em;">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1389em;">RTT</span></span></span></span></span>，α的推荐值为0.125</li></ul> </li><li>测量RTT的变化 ： 
  <ul><li><strong>偏差RTT(DeviationRTT,DevRTT)</strong>：估算SampleRTT偏离EstimatedRTT的程度<br> 计算公式：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            D 
           
          
            e 
           
          
            v 
           
          
            R 
           
          
            T 
           
          
            T 
           
          
            = 
           
          
            ( 
           
          
            1 
           
          
            − 
           
          
            β 
           
          
            ) 
           
          
            ∗ 
           
          
            D 
           
          
            e 
           
          
            v 
           
          
            R 
           
          
            T 
           
          
            T 
           
          
            + 
           
          
            β 
           
          
            ∗ 
           
          
            a 
           
          
            b 
           
          
            s 
           
          
            ( 
           
          
            S 
           
          
            a 
           
          
            m 
           
          
            p 
           
          
            l 
           
          
            e 
           
          
            R 
           
          
            T 
           
          
            T 
           
          
            − 
           
          
            E 
           
          
            s 
           
          
            t 
           
          
            i 
           
          
            m 
           
          
            a 
           
          
            t 
           
          
            e 
           
          
            d 
           
          
            R 
           
          
            T 
           
          
            T 
           
          
            ) 
           
          
         
           DevRTT =(1-β)*DevRTT + β*abs(SampleRTT -EstimatedRTT) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal" style="margin-right: 0.1389em;">RTT</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0528em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal" style="margin-right: 0.1389em;">RTT</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0528em;">β</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">ab</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right: 0.0197em;">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1389em;">RTT</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ima</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right: 0.1389em;">RTT</span><span class="mclose">)</span></span></span></span></span>，β的推荐值为0.5</li></ul> </li><li>设置超时间隔： 
  <ul><li>超时估计的原则：①比EstimatedRTT略大；②不能太小，否则不必要重传产生冗余分组；③不能太大，对数据段丢失响应不及时，导致传输时延较大。</li><li>计算公式：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            T 
           
          
            i 
           
          
            m 
           
          
            e 
           
          
            o 
           
          
            u 
           
          
            t 
           
          
            I 
           
          
            n 
           
          
            t 
           
          
            e 
           
          
            r 
           
          
            v 
           
          
            a 
           
          
            l 
           
          
            = 
           
          
            E 
           
          
            s 
           
          
            t 
           
          
            i 
           
          
            m 
           
          
            a 
           
          
            t 
           
          
            e 
           
          
            d 
           
          
            R 
           
          
            T 
           
          
            T 
           
          
            + 
           
          
            4 
           
          
            ∗ 
           
          
            D 
           
          
            e 
           
          
            v 
           
          
            R 
           
          
            T 
           
          
            T 
           
          
         
           TimeoutInterval = EstimatedRTT + 4*DevRTT 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">im</span><span class="mord mathnormal">eo</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">er</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ima</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right: 0.1389em;">RTT</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal" style="margin-right: 0.1389em;">RTT</span></span></span></span></span></li><li>操作：初始化设置TimeoutInterval为 1s，当出现超时后，TimeoutInterval值将加倍。当获得第一个样本RTT后，更新EstimatedRTT = SampleRTT,DevRTT = SampleRTT / 2，则 TimeoutInterval = EstimatedRTT + max(G，K*DevRTT) (K = 4,G是用户设置的时间粒度)</li></ul> </li></ul> 
<h4><a id="_54"></a>可靠数据传输</h4> 
<ul><li>理解：在不可靠的IP之上实现可靠数据传输，保证数据流是无损坏、无间隙、非冗余、按序</li><li>技术支撑：流水线机制、累积确认、单个重传定时器、超时重传等</li></ul> 
<h5><a id="TCP_57"></a>TCP发送方特殊事件</h5> 
<p>事件一：从上层应用程序接收数据——创建具有序号的报文段、启动定时器、设置超时间隔<br> 事件二：定时器超时——重传报文、重启定时器<br> 事件三：收到ACK——累积确认、与SendBase进行比较</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/32/41/vHxstTdy_o.png" alt="在这里插入图片描述"><br> 注意：<br> ①第二种情况中，只要ACK120在第二次超时前完成，则第二个报文段不会重传。第三种情况中，尽管ACK100丢失，但ACK120的累积确认，主机A不会重传报文，发送成功。<br> ②<font color="red">只有第二种超时情况，才会使用超时间隔加倍；另外两种仍然的间隔时间（TimeoutInterval）使用的是EstimatedRTT和DevRTT的加权值</font></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/96/db/wO1KrQFo_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_67"></a>超时重传——超时间隔加倍</h5> 
<ul><li>定义：当超时事件发生时，需要重传具有最小序号的未确认报文（SendBase），<font color="red">TCP重传每次将下一次的超时间隔设置为上次的2倍，而不是用EstimatedRTT 和 DevRTT</font>，呈指数型增长</li><li>缺点：超时周期越来越长，导致网络拥塞，增加了网络时延。</li></ul> 
<pre><code class="prism language-html">	例如：假定当定时器第一次过期时，与最早的未被确认的报文段相关联的 TimeoutInterval=0.75s
	TCP重传该报文后，并将新的过期时间设置为1.5s，再为3s...
</code></pre> 
<h4><a id="_75"></a>快速重传</h4> 
<ul><li>冗余ACK：发送方在超时事件发生前，通过注意是否有接收方发出的冗余ACK来检测是否已经丢包。</li><li>丢包：当TCP接收方收到的报文序号比预期的、按需的序号大，则报文段丢失。</li><li>丢包响应：TCP是rdt协议，不使用NAK机制，所以通过接收方重发最后一个确认的ACK（即冗余ACK）</li></ul> 
<h5><a id="_79"></a>快速重传机制</h5> 
<p>TCP发送方收到接收方的<font color="red"><strong>3个冗余ACK</strong></font>时，TCP就执行快速重传，即<font color="red">在该报文段的定时器到期之前就重传该丢失报文段</font></p> 
<blockquote> 
 <p><font color="red">问：为什么是3个冗余ACK？</font><br> 答：假定通信双方如下，A发送4个TCP Segment 给B，编号如下，N-1成功到达，因为A收到B的ACK(N)，其它按照到达顺序，分别收到ACK(N)的数目。A方发送顺序N-1，N，N+1，N+2<br> </p> 
 <div> 
  <br> 
  <img src="https://images2.imgbox.com/6f/fe/2j7B8xTL_o.png" width="300"> 
  <br> 
  <img src="https://images2.imgbox.com/02/13/4k0G3FkL_o.png" width="230"> 
  <br> 
  <img src="https://images2.imgbox.com/b8/1e/VpWQL4nf_o.png" width="300"> 
  <br> 
 </div> 
 <br> TCP乱序中有2/5=40%的概率是3次ACK，而当TCP丢包时，100%是3次ACK。所以根据统计得出规律， 
 <font color="red">2次ACK一定是乱序，3次ACK一定是丢包！</font> 
 <p></p> 
</blockquote> 
<h5><a id="TCPGBNSR_89"></a>TCP是GBN与SR的结合</h5> 
<ul><li>GBN回退N步： 
  <ul><li>相似： TCP发送方只需维护已发送但未确认的最小序号（SendBase）和下一个要发送的字节序号（NextSeqNum）</li><li>区别：TCP将失序到达的分组缓存起来；丢失重传的处理也不太相同</li></ul> </li><li>SR选择重传： 
  <ul><li>相似：允许TCP接收方选择性确认失序报文段，而不是累积确认最后一个报文</li></ul> </li></ul> 
<h4><a id="_96"></a>流量控制</h4> 
<h5><a id="flowcontrol_service_97"></a>流量控制服务(flow-control service)</h5> 
<ul><li>作用：使发送方速率与接收方应用程序的速率相匹配，避免接收方缓存溢出。</li></ul> 
<h5><a id="congestion_service_99"></a>拥塞控制(congestion service)</h5> 
<ul><li>作用：避免TCP发送方因为IP网络的拥塞。</li><li>原理：TCP是全双工通信，连接两端的主机都有发送窗口，通过TCP首部的窗口大小字段进行管理。各个发送方维护一个接收窗口来提供流量控制，指示接收方可用的缓存空间。<br> <img src="https://images2.imgbox.com/ea/e2/bSIMuz9T_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="_103"></a>区别</h5> 
<ul><li>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li><li>流量控制只是一个端到端的问题。</li></ul> 
<h4><a id="TCP_106"></a>TCP连接管理</h4> 
<h5><a id="_107"></a>三次握手</h5> 
<ul><li>第一次：客户端TCP向服务器端TCP发送<font color="red">特殊报文段——SYN报文段；</font>该报文段中<strong>不含数据</strong>，仅仅是首部 <strong>SYN字段</strong>设置为1。 同时客户端会<font color="red">随机初始化序号(client_isn)</font>，放置在TCP首部的 <strong>序号字段</strong>中。</li><li>第二次：包含SYN报文段的IP数据报达到接收方，接收方会从IP数据报中提取SYN报文段，并为本次TCP连接 <strong>分配缓存和变量。</strong> 同时向客户端发送<font color="red">允许连接的报文段——SYNACK报文段</font>；该报文段 <strong>不含数据</strong>，首部 <strong>SYN字段</strong>设置为1，首部的 <strong>确认号</strong>为client_isn +1，服务器端<font color="red">随机初始化序号(service_isn)</font>，放置在首部 <strong>序号字段</strong>中。<code>注意：分配缓存和变量，容易出现SYN洪泛的拒绝服务攻击！！！</code></li><li>第三次：收到SYNACK报文段后，客户端发出最后一个报文段，<font color="red">对服务器的SYN报文段进行确认</font>，并为该TCP连接<strong>分配缓存和变量</strong>；该报文段<strong>可以携带数据</strong>，首部的<strong>SYN字段</strong>被置为0（因为已经建立起了连接），首部的 <strong>“确认号</strong>为server_isn +1。 
  <blockquote> 
   <p><font color="red">问：为什么从第三次的报文段开始，SYN字段就被设置为0？</font><br> 答：因为TCP连接已经完成，双方可以相互发送数据。</p> 
  </blockquote> </li></ul> 
<h5><a id="_113"></a>四次挥手</h5> 
<ul><li>第一次：客户TCP向服务器发出一个特殊TCP报文段——首部的<strong>FIN字段</strong>为1。(<font color="red"><strong>双方都能主动发起关闭连接</strong></font>)</li><li>第二次：服务器接受到关闭请求报文段后，服务器端反馈一个确认报文段</li><li>第三次：服务器同样发出终止报文段——首部<strong>FIN字段</strong>为1</li><li>第四次：客户端反馈确认报文段。此时两台主机的用于连接的所有<font color="red">资源都释放（缓存和变量）</font></li></ul> 
<h5><a id="_118"></a>图例</h5> 
<div> 
 <img src="https://images2.imgbox.com/85/17/WBm9yPDd_o.png" width="424"> 
 <img src="https://images2.imgbox.com/27/20/d4mIVd9v_o.png" width="400"> 
 <center>
   TCP建立连接与关闭连接：三次握手与四次挥手 
 </center> 
</div> 
<div> 
 <img src="https://images2.imgbox.com/a5/c4/7bg4SUYf_o.png" width="380"> 
 <img src="https://images2.imgbox.com/94/d2/RdVx9CGd_o.png" width="446"> 
 <center>
   TCP典型状态序列：客户端与服务器端 
 </center> 
</div> 
<h5><a id="SYN_131"></a>SYN洪泛攻击</h5> 
<ul><li>攻击原理： 在TCP三次握手中，客户端不进行第三步的ACK确认。攻击者使用大量的SYN报文段连接服务器，但是不完成其中的第三步！</li><li>服务器：<font color="red">服务器已经为半开连接分配了缓存和变量</font>，但是从未被客户端使用，导致服务器的资源被耗尽。</li><li>SYN cookie——部署在操作系统中，防御SYN攻击 
  <ul><li>当服务器收到SYN报文段时，由于未知客户端是否合法，<font color="red">此时服务器不再建立半开放连接。</font></li><li>相反，服务器生成一个初始TCP序列号，该特殊初始序列称为"cookie" ，服务器将具有该序列号的SYNACK分组发送给客户端，但是服务器并不记忆该cookie和SYN的其他状态信息。<br> <font size="2"> 其中RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost, localport, remotehost, remoteport)。</font></li><li>对客户端合法性进行判断。如为合法用户，则客户端必须返回ACK确认报文段，服务器端接收到ACK中的确认字段等于service_isn + 1，而服务器端使用散列函数计算得出cookie + 1与其相等，则认为该链接是合法的，<font color="red">此时服务器才建立全开连接。</font>否则为非法用户，不会返回ACK确认报文，则服务器规避，不分配资源。</li></ul> </li></ul> 
<h4><a id="_140"></a>拥塞控制原理</h4> 
<h5><a id="_141"></a>拥塞控制原因与代价</h5> 
<ul><li>情况一： 两个发送方和一台具有无穷大缓存的路由器 
  <ul><li>初始条件：假设主机A、B都以 λ<font size="2">in</font>字节/秒 的速率将应用数据发送到连接中，来自A、B的分组经过一台路由器，在一段容量为 R 的共享式输出链路上传输。</li><li>结果：<br> ①当发送速率在0~R/2 之间时，接收方的吞吐量等于发送速率<br> ②当发送速率超过 R/2 时，接收方的吞吐量达到上限R/2。由此，吞吐量上限是由共享链路的容量R决定的。<br> ③但是当吞吐量达到上限时，路由器的平均排队分组数将无限增长，平均时延将无限增大。</li><li>结论：<font color="red">网络拥塞的一种代价，当分组的发送速率接近链路容量时，排队时延很大</font></li></ul> </li></ul> 
<center> 
 <img src="https://images2.imgbox.com/b8/98/pji94Rr6_o.png"> 
</center> 
<ul><li>情况二：两个发送方和一台具有有限缓存的路由器 
  <ul><li> <p>初始条件：存在路由器缓存满，分组溢出丢弃，TCP重传。λ<font size="2">in</font> 字节/秒表示应用程序将原始数据发送到套接字中的速率。引入λ’<font size="2">in</font> 字节/秒表示分组丢失，传输层向IP网络中发送报文段的速率。</p> </li><li> <p>结果：<br> ①不真实的情况：假设主机A已知路由器是否有缓存空闲，每次都不产生丢包，则与情况一相同。<br> ②较为真实的情况：发送方仅在确定了一个分组已经丢失时才重传。当以λ’<font size="2">in</font> = R/2时，应用程序接收速率约为R/3。</p> 
    <blockquote> 
     <p>例：发送0.5R单位数据中，平均来看，0.333R 字节/s 为初始数据，0.166R 字节/s 为重传数据。</p> 
    </blockquote> <p>③发送方因为超时间隔太短，提前超时并重传被推迟但未丢失的分组。初始数据分组和重传分组都可到达接受方，其中重传分组会被丢弃，链路资源被浪费。当λ’<font size="2">in</font> = R/2时，由于重传导致每个分组被重传两次，此时吞吐量为R/4。</p> </li><li> <p>结论：<br> <font color="red">网络拥塞的一种代价，发送方必须执行重传以补偿因为缓存溢出而丢失的分组。</font><br> <font color="red">网络拥塞的一种代价，发送方在遇到大时延时的不必要重传会引起路由器转发不必要的分组副本。</font></p> </li></ul> </li></ul> 
<center> 
 <img src="https://images2.imgbox.com/da/00/g1HAIvxC_o.png"> 
</center> 
<ul><li>情况三：4个发送方和具有有限缓存的多台路由器及多跳路径 
  <ul><li>结果：当路由器选择分组转发时，优先选择那些已经经过一定跳数的路由器的分组，充分使用资源。</li><li>结论：网络拥塞而丢弃分组的另一种代价，当一个分组沿一条路径被丢弃时，其上游路由器中的资源被浪费。<br> <img src="https://images2.imgbox.com/35/83/6TsWZ3sL_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h5><a id="_168"></a>拥塞控制方法</h5> 
<ul><li>端到端的拥塞控制： 
  <ul><li>无显示支持：网络层没有为运输层拥塞控制提供显示支持。当网络中存在拥塞，端系统需要观察网络行为（分组丢失与时延）来判断。进一步<font color="red">通过超时或3次冗余ACK确定分组丢失</font>并相应地减少窗口大小；<font color="r">通过增加RTT判断网络拥塞增加的程度。</font></li></ul> </li><li>网络辅助的拥塞控制： 
  <ul><li>显示支持：网络层中的路由器需要为发送方显示提供网络拥塞的情况。</li><li>拥塞信息反馈给发送方的两种方式： 
    <ul><li>方法一：直接反馈信息，由网络路由器发给发送方。</li><li>方法二：经由接收方的网络反馈，路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的发生。当接收方收到一个<font color="red">标记分组</font>后，接收方就会向发送方通知该网络出现拥塞。</li></ul> </li></ul> </li><li><font color="red">TCP/IP使用端到端拥塞控制</font></li></ul> 
<h4><a id="TCP_178"></a>TCP拥塞控制</h4> 
<ul><li>方法：TCP通过让发送方感知网络的拥塞程度来限制其向连接发送的速率。 
  <blockquote> 
   <p><font color="red">问：TCP发送方如何限制发送流量的速率？</font><br> 答：TCP连接的每一端都是由一个接收缓存、一个发送缓存、几个变量组成。发送方需要额外维护一个<strong>拥塞窗口（congestion window，cwnd）。</strong> 拥塞窗口限制发送方的发送速率，在一个发送方中<font color="red"><strong>未被确认的数据量不会超过cwnd和rwnd中的最小值</strong>，</font>即LastByteSent−LastByteAcked≤min{cwnd,rwnd}，rwnd表示接收窗口大小。因此，发送方的发送速率大概是cwndRTT字节/秒，通过调节cwnd的值限制发送速率。<br> <font color="red">问：TCP发送方如何感知路径上的拥塞？</font><br> 答：当网络拥塞时，路径上的路由器的缓存会溢出，导致丢包事件。丢包可以通过超时或3次冗余ACK判断。<br> <font color="red">问：TCP使用何种算法来改变其发送速率？</font><br> 答：基于以下原则<br> ①当报文丢失时意味着拥塞，降低TCP发送方的速率，减小发送方的拥塞窗口。<br> ②当确认报文段到达意味着顺利，增加TCP发送方的速率，增大拥塞窗口。<br> ③带宽探测。TCP增加发送速率以及时响应ACK，TCP减少发送速率以响应丢包。为探测拥塞开始出现的速率，向增大发送速率，达到变化临界后，适当减少发送速率，再又进行探测。</p> 
  </blockquote> </li></ul> 
<h5><a id="slowstart_190"></a>慢启动（slow-start）</h5> 
<ul><li>引入：当一条TCP连接开始时，cwnd的值通常初始为一个最小报文段长度（MSS）的较小值，则初始发送速率约为 MSS/RTT，但理论上TCP可用带宽比 MSS/RTT大得多。</li><li>原理：cwnd的值以一个MSS开始并且每当传输的报文段被确认后，<font color="red">cwnd大小指数型增长。</font> 
  <blockquote> 
   <p>例：主机A发送第一个报文段并等待确认，当确认完毕后，TCP发送方的拥塞窗口大小为2个MSS。主机A再发送2个报文段并等待确认，当两个报文段确认完毕后，TCP发送方的每个确认报文段的拥塞窗口加一个，则总共有4个MSS。如此，呈指数增长。</p> 
  </blockquote> </li><li><strong>作用</strong>：是一种算法，用于检测数据包传输的可用带宽，并平衡网络连接的速度。它防止出现最初能力未知的网络拥塞，并缓慢增加传播的信息量，直到找到网络的最大容量。</li><li>停止增长的三种方法：<br> ①丢包事件：当增长速率使得网络出现拥塞，导致丢包时，TCP发送方将cwnd重置为1并重新开始慢启动。并且将ssthresh( 慢启动阈值 )的值设置为 峰值cwnd/2<br> ②达到阈值：当cwnd的值等于ssthresh时，结束慢启动并且TCP状态转移到“拥塞避免”状态。当进入“拥塞避免”状态后，cwnd的增加机制将更加谨慎严格。<br> ③3个冗余ACK：TCP执行快速重传，ssthresh = cwnd/2，cwnd = ssthresh +3.MSS，进入“快速恢复”状态。<br> <img src="https://images2.imgbox.com/a8/cb/b4VCLtI8_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="_200"></a>拥塞避免</h5> 
<ul><li>原理：TCP不再将cwnd的值翻倍，而是对每一个RTT只将cwnd的值增加一个单位的MSS。 
  <blockquote> 
   <p>例如：MSS =1460字节，cwnd = 14600字节，则在一个RTT内可以发送10个报文段。对于TCP发送方收到一个ACK确认后，就增加1/10的MSS，10个ACK全部确认后就增加1个MSS。</p> 
  </blockquote> </li><li>拥塞线性增长的结束：<br> ①超时事件：与慢启动一样，cwnd的值重置为1。<br> ②丢包事件：cwnd的值减半，并且当收到3个冗余的ACK时，将ssthresh的值记录为cwnd的值的一半在进入“快速恢复”状态。</li></ul> 
<h5><a id="_206"></a>快速恢复</h5> 
<h6><a id="_207"></a>快速恢复是推荐的，但不是必需的！</h6> 
<ul><li>原理：如果是丢失报文段导致冗余ACK，则对每一个ACK，其cwnd大小增加一个MSS。直到当丢失报文段重传确认后，cwnd降低并进入“拥塞避免”状态。如果是超时事件，则ssthresh = cwnd / 2,cwnd =1，并进入“慢启动”状态。</li><li>理解：<br> ①当cwnd&lt;ssthresh时，慢启动阶段，指数增长<br> ②当cwnd≥ssthresh时，拥塞避免阶段，线性增长<br> ③3个ACK，ssthresh = cwnd/2，并且cwnd重置为特定值（参照具体TCP版本）<br> ④超时，ssthresh =cwnd/2，并且cwnd置为1MSS</li></ul> 
<center> 
 <img src="https://images2.imgbox.com/57/f3/A0nC7PyT_o.png"> 
</center> 
<center>
  TCP拥塞窗口的演化 
</center> 
<h4><a id="TCP_217"></a>TCP拥塞控制：回顾</h4> 
<h5><a id="AdditiveIncreaseMultiplicativeDecreaseAIMD_218"></a>加性增、乘性减（Additive-Increase,Multiplicative-Decrease,AIMD）</h5> 
<ul><li>理解：当丢包是由3次ACK而不是超时指示时，TCP的拥塞控制是：每个RTT内cwnd线性增加1MSS（加性增），然后出现3个冗余ACK时cwnd减半（乘性减）。</li><li>AIMD引起“锯齿”行为</li></ul> 
<center> 
 <img src="https://images2.imgbox.com/a0/4e/pmuxF2ZO_o.png"> 
</center> 
<ul><li>平均吞吐量：忽略慢启动，窗口大小为W，当前往返时间为RTT，则吞吐量为W / RTT。丢包发生后，窗口大小降低为W/2，则吞吐量为W/(2*RTT)，然后继续增大到W/RTT后再次发生丢包，如此重复。故平均吞吐量为0.75* W/RTT。</li></ul> 
<h5><a id="TCPreno_226"></a>许多TCP采用reno算法</h5> 
<h5><a id="TCP_228"></a>TCP具有公平性</h5> 
<ul><li>定义：K条TCP连接，每条都有不同的端到端路径，但是都经过一段传输速率为R的瓶颈链路。假设每条连接传输大文件的TCP，若每条连接的平均传输速率接近R/K，则认为每条连接都平分带宽资源，即该拥塞控制机制是公平的。</li><li>理解：TCP拥塞控制会在面临拥塞时，降低其传输速率至“公平”级别并且不丢失任何分组；运行在UDP之上的多媒体应用则是不公平的，因为它们不与其他连接合作。</li><li><font color="red">并行TCP连接：不公平，因为不能阻止某个应用程序使用并行TCP连接，导致一个应用程序占用较多的带宽。通常出现在Web浏览器传输网页对象</font> 
  <blockquote> 
   <p>例如：假设一条在线客户—服务器已有9个应用连接，速率为R。若新应用要求一个TCP连接，则10个用户几乎均分带宽。若新应用要求11个并行TCP连接，则新应用实际获得11/20的带宽，不公平的分配。</p> 
  </blockquote> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/667c4a7a1362aa00acb4229ad1878417/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp小程序/APP接入蓝牙设备（踩坑记录）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e549af3b0c6234936e7a33db195a9094/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pytorch&#43;win10(无GPU)&#43;pycharm环境搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>