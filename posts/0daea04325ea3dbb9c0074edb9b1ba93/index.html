<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>函数的递归 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="函数的递归" />
<meta property="og:description" content="函数递归 这是本章的重点内容
目录
函数递归 一．什么是递归？
二．两个例子帮助我们理解递归函数
三．求ｎ的阶乘
四.求第n个斐波那契数。
五.递归的几个练习 一．什么是递归？ 大师 L. Peter Deutsch 说过：To Iterate is Human, to Recurse, Divine.中文译为：
人理解迭代，神理解递归。 人理解迭代，神理解递归。毋庸置疑地，递归确实是一个奇妙的思维方式。 简单理解递归与循环：
递归：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，你继续打开它。若干次之后，你打开面前的门后，发现只有一间屋子，没有门了。然后，你开始原路返回，每走回一间屋子，你数一次，走到入口的时候，你可以回答出你到底用这你把钥匙打开了几扇门。 循环：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门（若前面两扇门都一样，那么这扇门和前两扇门也一样；如果第二扇门比第一扇门小，那么这扇门也比第二扇门小，你继续打开这扇门，一直这样继续下去直到打开所有的门。但是，入口处的人始终等不到你回去告诉他答案。 递归的内涵
1、定义 (什么是递归？)
在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。
2、递归思想的内涵(递归的精髓是什么？)
正如上面所描述的场景，递归就是有去（递去）有回（归来），如下图所示。“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决，就像上面例子中的钥匙可以打开后面所有门上的锁一样；“有回”是指 : 这些问题的，演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回到原点，原问题解决。　毋庸置疑地，递归确实是一个奇妙的思维方式。对一些简单的递归问题，我们总是惊叹于递归描述问题的能力和编写代码的简洁，但要想真正领悟递归的精髓、灵活地运用递归思想来解决问题却并不是一件容易的事情。 递归的作用
它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解， 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 递归的主要思考方式在于：把大事化小
二．两个例子帮助我们理解递归函数 这里我们举一个具体的例子
接受一个整型值（无符号），按照顺序打印它的每一位。 例如： 输入：123，输出 1 2 3
void print(unsigned int n) { if (n &gt; 9) { print(n / 10); } printf(&#34;%d &#34;, n % 10); } int main() { unsigned int num = 0; scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0daea04325ea3dbb9c0074edb9b1ba93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-03T20:31:37+08:00" />
<meta property="article:modified_time" content="2021-11-03T20:31:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">函数的递归</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%C2%A0%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92%C2%A0"> 函数递归 </h2> 
<p>这是本章的重点内容</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92%C2%A0-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92%C2%A0" rel="nofollow" title=" 函数递归 "> 函数递归 </a></p> 
<p id="%E4%B8%80%EF%BC%8E%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%8E%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92%EF%BC%9F" rel="nofollow" title="一．什么是递归？">一．什么是递归？</a></p> 
<p id="%E4%BA%8C%EF%BC%8E%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%8E%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0" rel="nofollow" title="二．两个例子帮助我们理解递归函数">二．两个例子帮助我们理解递归函数</a></p> 
<p id="%E4%B8%89%EF%BC%8E%E6%B1%82%EF%BD%8E%E7%9A%84%E9%98%B6%E4%B9%98-toc" style="margin-left:0px;"><a href="#%E4%B8%89%EF%BC%8E%E6%B1%82%EF%BD%8E%E7%9A%84%E9%98%B6%E4%B9%98" rel="nofollow" title="三．求ｎ的阶乘">三．求ｎ的阶乘</a></p> 
<p id="%E5%9B%9B.%E6%B1%82%E7%AC%ACn%E4%B8%AA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E3%80%82-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E6%B1%82%E7%AC%ACn%E4%B8%AA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E3%80%82" rel="nofollow" title="四.求第n个斐波那契数。">四.求第n个斐波那契数。</a></p> 
<p id="%E4%BA%94.%E9%80%92%E5%BD%92%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%83%E4%B9%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%E9%80%92%E5%BD%92%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%83%E4%B9%A0%C2%A0" rel="nofollow" title="五.递归的几个练习 ">五.递归的几个练习 </a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%EF%BC%8E%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92%EF%BC%9F"><span style="background-color:#ffd900;">一．什么是递归？</span></h2> 
<blockquote> 
 <p><strong>      </strong><span style="color:#fe2c24;"><strong>  大师  L. Peter Deutsch</strong></span> 说过：To Iterate is Human, to Recurse, Divine.中文译为：</p> 
 <p><strong>人理解迭代，神理解递归。 </strong></p> 
</blockquote> 
<p>人理解迭代，神理解递归。毋庸置疑地，递归确实是一个奇妙的思维方式。 </p> 
<p><strong>简单理解递归与循环：</strong></p> 
<ul><li><strong>递归：</strong>你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，你继续打开它。若干次之后，你打开面前的门后，发现只有一间屋子，没有门了。然后，你开始原路返回，每走回一间屋子，你数一次，走到入口的时候，你可以回答出你到底用这你把钥匙打开了几扇门。</li><li><strong> 循环：</strong>你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门（若前面两扇门都一样，那么这扇门和前两扇门也一样；如果第二扇门比第一扇门小，那么这扇门也比第二扇门小，你继续打开这扇门，一直这样继续下去直到打开所有的门。但是，入口处的人始终等不到你回去告诉他答案。 </li></ul> 
<blockquote> 
 <p><strong> 递归的内涵</strong></p> 
 <p><span style="color:#ad720d;"><strong>1、定义 (什么是递归？)</strong></span></p> 
 <p>　　 在数学与计算机科学中，递归(Recursion)是指<strong>在函数的定义中使用函数自身的方法</strong>。实际上，递归，顾名思义，其包含了两个意思：<strong>递 和 归</strong>，这正是递归思想的精华所在。</p> 
 <p><span style="color:#ad720d;"><strong>2、递归思想的内涵(递归的精髓是什么？)</strong></span></p> 
 <p>　　 正如上面所描述的场景，<strong>递归就是有去（递去）有回（归来），如下图所示。“有去”是指：递归问题必须可以分解为<span style="color:#4da8ee;">若干个规模较小，与原问题形式相同的子问题</span>，这些子问题可以用<span style="color:#4da8ee;">相同的解题思路</span>来解决，就像上面例子中的<span style="color:#4da8ee;">钥匙可以打开后面所有门上的锁一样</span>；“有回”是指 : 这些问题的，<span style="color:#4da8ee;">演化过程是一个从大到小，由近及远的过程</span>，并且会有一个明确的终点(临界点)，一旦<span style="color:#4da8ee;">到达了这个临界点</span>，就不用再往更小、更远的地方走下去。最后，<span style="color:#4da8ee;">从这个临界点开始，原路返回到原点，原问题解决。　　</span></strong></p> 
 <p></p> 
</blockquote> 
<p><strong>  毋庸置疑地，递归确实是一个奇妙的思维方式。对一些简单的递归问题，我们总是惊叹于递归描述问题的能力和编写代码的简洁，但要想真正领悟递归的精髓、灵活地运用递归思想来解决问题却并不是一件容易的事情。 </strong></p> 
<blockquote> 
 <p><strong>递归的作用</strong></p> 
 <ul><li>它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解， 递归策略</li><li>只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 </li></ul> 
 <p> <strong>递归的主要思考方式在于：把大事化小</strong></p> 
</blockquote> 
<h2 id="%E4%BA%8C%EF%BC%8E%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><span style="background-color:#ffd900;">二．两个例子帮助我们理解递归函数</span></span></h2> 
<p>这里我们举一个具体的例子</p> 
<p>接受一个整型值（无符号），按照顺序打印它的每一位。 例如： 输入：123，输出 1 2 3</p> 
<pre><code class="language-cpp">void print(unsigned int n)
{
	if (n &gt; 9)
	{
		print(n / 10);
	}
	printf("%d ", n % 10);
}

int main()
{
	unsigned int num = 0;
	scanf("%u", &amp;num);//123
	print(num);
}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cb/85/FsXxTTLK_o.png"></p> 
<p style="text-align:center;">该怎么理解呢？我们画个图帮助理解<img alt="" src="https://images2.imgbox.com/7a/f0/z2v3Z4lg_o.png"> </p> 
<p><strong>注意递归的归 ：从哪里调用，就回到哪里去，然后继续执行返回处下面的语句 </strong></p> 
<p> 或许，下面这张图能帮助我们理解递归（图片来自网上）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a6/7c/2SFsKwyg_o.png"></p> 
<p></p> 
<blockquote> 
 <p><span style="color:#ad720d;"><strong>递归的两个必要条件：</strong></span></p> 
 <ul><li>存在限制条件，当满足这个限制条件的时候，递归便不再继续。</li><li>每次递归调用之后越来越接近这个限制条件。 </li></ul> 
</blockquote> 
<p>我们在用一个代码来加深我们对递归的理解:</p> 
<blockquote> 
 <p><span style="color:#7b7f82;"><strong>编写函数，不允许创建临时变量，求字符串的长度。 </strong></span></p> 
</blockquote> 
<pre><code class="language-cpp">int my_strlen(char*s)
{
	if (*s == '\0')
		return 0;
	else
		return 1 + my_strlen(s + 1);
}

int main()
{
	char arr[] = "abc";
	int len = my_strlen(arr);
	printf("%d\n", len);
	return 0;
}</code></pre> 
<p>这里我们需要求字符串"arr"的长度 </p> 
<p> 首先需要说明的是arr是数组名，<strong>数组名是数组首元素的地址 </strong></p> 
<p>所以函数my_strlen里的参数应是 char*s</p> 
<p><strong>接着，我们再来分析一下这里的递归是怎么用的：</strong></p> 
<p>该开始*s指向的字符是a，如果想要*s指向b就要s+1</p> 
<p>为什么是+1呢？因为我们这是char*的指针，char*的指针+1就会跳一个字符</p> 
<p>如果是int*的指针要+4，因为char*+1我们想要让它跳过一个字符，一个字符是1个字节，一个整型是4个字节，一个double型的指针要跳过一个8</p> 
<p>下面用一张图给出我们的思路，我们用这样的递归方式、</p> 
<p style="text-align:center;"><img alt="" height="400" src="https://images2.imgbox.com/6f/ed/tq3og1p5_o.png" width="284"></p> 
<p style="text-align:center;"><img alt="" height="480" src="https://images2.imgbox.com/17/b0/DADuw8yk_o.png" width="708"></p> 
<p>这里我们还是用一张图帮助我们理解，红色的线代表递，绿色的线是归 ，相信通过这张图就可以理解递归函数在这道题的运用了</p> 
<p>下面我们再来看几道题目</p> 
<h2 id="%E4%B8%89%EF%BC%8E%E6%B1%82%EF%BD%8E%E7%9A%84%E9%98%B6%E4%B9%98"><span style="background-color:#ffd900;">三．求ｎ的阶乘</span></h2> 
<p>求ｎ的阶乘这道题目在之前我们已经见识过，但今天我们要用递归的方式实现它</p> 
<p>首先我们分析一下：</p> 
<p>n!=1*2*3*4*5*6*...*n</p> 
<p>(n-1)!=1*2*3*4*...*(n-1)</p> 
<p>所以我们可以得到 ：n！=n*(n-1)!</p> 
<p>我们便可以得到函数f(x)的表达式</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f6/cf/JtwJ4VdP_o.png"></p> 
<p>下面我们用函数的递归来实现</p> 
<pre><code class="language-cpp">int fac(int n)
{
	if (n &lt;= 1)
		return 1;
	else
		return n * fac(n - 1);
}

int main()
{
	int n = 0;
	scanf("%d", &amp;n);
	int ret = fac(n);
	printf("%d\n", ret);
	return 0;
}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0f/76/ajjUqwbU_o.png"></p> 
<h2 id="%E5%9B%9B.%E6%B1%82%E7%AC%ACn%E4%B8%AA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E3%80%82"><span style="background-color:#ffd900;">四.求第n个斐波那契数。</span></h2> 
<p>我们知道斐波那契数列是 1，1，2，3，5，8，13，21，34，55...</p> 
<p>我们可以总结一下它的规律，</p> 
<blockquote> 
 <p><strong>当n&lt;=2时，为1</strong></p> 
 <p><strong>当n&gt;2时，为前两项之和</strong></p> 
</blockquote> 
<p>我们开始用函数的递归写代码 </p> 
<pre><code class="language-cpp">int fib(int n)
{
	if (n &lt;= 2)
		return 1;
	else
		return fib(n - 2) + fib(n - 1);
}

int main()
{
	int n = 0;
	scanf("%d", &amp;n);
	int ret = fib(n);
	printf("%d\n", ret);
	return 0;
}</code></pre> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/4a/65/ZfXl64OW_o.png"></p> 
<p><strong>这样我们就完成了这道题目，但是我们发现有问题：</strong></p> 
<ul><li><strong>在使用 fib 这个函数的时候如果我们要计算第50个斐波那契数字的时候特别耗费时间。</strong></li><li><strong>使用 factorial 函数求10000的阶乘（不考虑结果的正确性），程序会崩溃。</strong></li></ul> 
<p><strong>为什么呢？ </strong></p> 
<p><strong> 我们发现 fib 函数在调用的过程中很多计算其实在一直重复。</strong></p> 
<p><strong>在调试 factorial 函数的时候，如果你的参数比较大，那就会报错： stack overflow（栈溢出）这样的信息。 系统分配给程序的栈空间是有限的，但是如果出现了死循环，或者（死递归），这样有可能导致一 直开辟栈空间，最终产生栈空间耗尽的情况，这样的现象我们称为栈溢出</strong>。</p> 
<p><span style="color:#1c7331;"><strong> 每一次调用函数都会在内存的栈区申请一块空间</strong></span><span style="color:#a2e043;"><strong> </strong></span></p> 
<p>当我们一直不停地开辟空间，总有一天，栈空间的内存耗光了，没有空间可以开辟了，</p> 
<p>这个时候就会出现 <strong>栈溢出（stackoverflow）的问题</strong></p> 
<p style="text-align:center;"><img alt="" height="300" src="https://images2.imgbox.com/3d/ba/jk6d7rhe_o.png" width="195"></p> 
<p><strong>那么我们应该如何解决这个问题呢？</strong></p> 
<blockquote> 
 <p><strong>1. 将递归改写成非递归。</strong></p> 
 <p><strong>2. 使用static对象替代 nonstatic 局部对象。在递归函数设计中，可以使用 static 对象替代 nonstatic 局部对象（即栈对象），这不 仅可以减少每次递归调用和返回时产生和释放 nonstatic 对象的开销，而且 static 对象还可以保 存递归调用的中间状态，并且可为 各个调用层所访问。</strong></p> 
</blockquote> 
<p><strong>比如，下面代码就采用了，非递归的方式来实现： </strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/1c/2a/8JjJBI8c_o.png"></strong></p> 
<p>这是我们的分析，我们通过这样的方式不断地改变a和b，从而得到c</p> 
<pre><code class="language-cpp">int fib(int n)
{
	int a = 1;
	int b = 1;
	int c = 1;
	while(n&gt;2)
	{
		c = a + b;
		a = b;
		b = c;
		n--;
	}
	return c;
}

int main()
{
	int n = 0;
		scanf("%d", &amp;n);
	int ret = fib(n);
	printf("%d\n", ret);

	return 0;
}</code></pre> 
<p></p> 
<blockquote> 
 <p> <strong><span style="background-color:#fe2c24;">提示： </span></strong></p> 
 <p><strong>1. 许多问题是以递归的形式进行解释的，这只是因为它比非递归的形式更为清晰。</strong></p> 
 <p><strong>2. 但是这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性稍微差些。</strong></p> 
 <p><strong>3. 当一个问题相当复杂，难以用迭代实现时，此时递归实现的简洁性便可以补偿它所带来的运行时开销。</strong></p> 
</blockquote> 
<h2 id="%E4%BA%94.%E9%80%92%E5%BD%92%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%83%E4%B9%A0%C2%A0"><span style="background-color:#ffd900;">五.递归的几个练习 </span></h2> 
<p><strong>1.写一个递归函数DigitSum(n)，输入一个非负整数，返回组成它的数字之和</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
//写一个递归函数DigitSum(n)，输入一个非负整数，返回组成它的数字之和
int DigitSum(int n)
{
	if (n &gt; 9)
	{
		return  DigitSum(n / 10) + n % 10;
	}
	else
		return n;
}
int main()
{
	int n = 0;
	scanf("%d", &amp;n);
	int sum= DigitSum(n);
	printf("%d", sum);
	return 0;
}</code></pre> 
<p style="text-align:center;"><img alt="" height="303" src="https://images2.imgbox.com/bc/08/bZVwo6IU_o.png" width="400"></p> 
<hr> 
<p> </p> 
<p><strong>2.递归实现n的k次方 </strong></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
double Pow(int n, int k)
{
	if (k == 0)
	{
		return 1;
	}
	else if (k &gt;= 1)
	{
		return n * Pow(n, k - 1);
	}
	else
		return 1.0 / Pow(n, -k);
}
int main()
{
	int n = 0;
	int k = 0;
	scanf("%d %d", &amp;n, &amp;k);
	double ret = Pow(n, k);
	printf("%lf\n", ret);
	return 0;
}</code></pre> 
<p><img alt="" height="307" src="https://images2.imgbox.com/d0/7d/QAk0MjUA_o.png" width="460"></p> 
<p><img alt="" height="239" src="https://images2.imgbox.com/5f/66/Vtv3AVZL_o.png" width="311"> </p> 
<p> </p> 
<hr> 
<p><strong>3.编写一个函数 reverse_string(char * string)（递归实现）</strong></p> 
<p><strong>实现</strong>：将参数字符串中的字符反向排列，<strong>不是逆序打印。</strong></p> 
<p><strong>要求：</strong>不能使用C函数库中的字符串操作函数。</p> 
<p>比如:</p> 
<blockquote> 
 <pre>char arr[] = "abcdef";
</pre> 
</blockquote> 
<p>逆序之后数组的内容变成：fedcba</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
//递归版本
int my_strlen(char*s)
{
	int count = 0;
	while (*s != '\0')
	{
		count++;
		s++;
	}
	return count;
}
void reverse_string(char*arr)
{
	int len = my_strlen(arr);
	char tmp = *arr;
	*arr = *(arr + len - 1);  //把g放到a的位置上
	*(arr + len - 1) = '\0';
	if (my_strlen(arr + 1) &gt; 1)
	{
		reverse_string(arr + 1);
	}
	*(arr + len - 1) = tmp;
}

int main()
{
	char arr[] = "abcdefg";
	reverse_string(arr);
	printf("%s", arr);
}</code></pre> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68d0c306be23e4f8f9d8b7fd7e7c5cae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Invalid character found in the request target. The valid characters are defi</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb5dd2ffc91fa3446be4afbae03d8fd3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C#，反序列化，找不到程序集，无法加载进行反序列化所需的类型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>