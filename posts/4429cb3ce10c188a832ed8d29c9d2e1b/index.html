<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode第529题：扫雷游戏 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode第529题：扫雷游戏" />
<meta property="og:description" content="让我们一起来玩扫雷游戏！
给你一个大小为 m x n 二维字符矩阵 board ，表示扫雷游戏的盘面，其中：
&#39;M&#39; 代表一个 未挖出的 地雷，
&#39;E&#39; 代表一个 未挖出的 空方块，
&#39;B&#39; 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 已挖出的 空白方块，
数字（&#39;1&#39; 到 &#39;8&#39;）表示有多少地雷与这块 已挖出的 方块相邻，
&#39;X&#39; 则表示一个 已挖出的 地雷。
给你一个整数数组 click ，其中 click = [clickr, clickc] 表示在所有 未挖出的 方块（&#39;M&#39; 或者 &#39;E&#39;）中的下一个点击位置（clickr 是行下标，clickc 是列下标）。
根据以下规则，返回相应位置被点击后对应的盘面：
如果一个地雷（&#39;M&#39;）被挖出，游戏就结束了- 把它改为 &#39;X&#39; 。
如果一个 没有相邻地雷 的空方块（&#39;E&#39;）被挖出，修改它为（&#39;B&#39;），并且所有和其相邻的 未挖出 方块都应该被递归地揭露。
如果一个 至少与一个地雷相邻 的空方块（&#39;E&#39;）被挖出，修改它为数字（&#39;1&#39; 到 &#39;8&#39; ），表示相邻地雷的数量。
如果在此次点击中，若无更多方块可被揭露，则返回盘面。
来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/minesweeper
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
解题思路： 题目要求点击一个方块时，若该方块周围（最多8个方块）都不是雷，则需要点击周围方块。
所以采用递归的方式点击。
构建递归函数void dfs(....)。需传递矩阵board信息和点击位置(x,y)。
1、检测位置是否合法。越界 或者 该位置已被点开，直接退出。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4429cb3ce10c188a832ed8d29c9d2e1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-18T19:38:04+08:00" />
<meta property="article:modified_time" content="2023-02-18T19:38:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode第529题：扫雷游戏</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>让我们一起来玩扫雷游戏！</p> 
<p>给你一个大小为 m x n 二维字符矩阵 board ，表示扫雷游戏的盘面，其中：</p> 
<p>'M' 代表一个 未挖出的 地雷，<br> 'E' 代表一个 未挖出的 空方块，<br> 'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 已挖出的 空白方块，<br> 数字（'1' 到 '8'）表示有多少地雷与这块 已挖出的 方块相邻，<br> 'X' 则表示一个 已挖出的 地雷。<br> 给你一个整数数组 click ，其中 click = [clickr, clickc] 表示在所有 未挖出的 方块（'M' 或者 'E'）中的下一个点击位置（clickr 是行下标，clickc 是列下标）。</p> 
<p>根据以下规则，返回相应位置被点击后对应的盘面：</p> 
<p>如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X' 。<br> 如果一个 没有相邻地雷 的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的 未挖出 方块都应该被递归地揭露。<br> 如果一个 至少与一个地雷相邻 的空方块（'E'）被挖出，修改它为数字（'1' 到 '8' ），表示相邻地雷的数量。<br> 如果在此次点击中，若无更多方块可被揭露，则返回盘面。</p> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode.cn/problems/minesweeper<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p><img alt="" height="351" src="https://images2.imgbox.com/fc/38/6GjFAxW5_o.png" width="855"></p> 
<p><strong>解题思路： </strong></p> 
<p>        题目要求点击一个方块时，若该方块周围（最多8个方块）都不是雷，则需要点击周围方块。</p> 
<p>所以采用递归的方式点击。</p> 
<p>        构建递归函数void dfs(....)。需传递矩阵board信息和点击位置(x,y)。</p> 
<p>1、检测位置是否合法。越界 或者 该位置已被点开，直接退出。</p> 
<p>2、检测是否点到了地雷。是地雷则只需简单修改该位置的值，然后退出。</p> 
<p>3、不是雷。获取周围有地雷个数num（构建一个新的函数实现）。</p> 
<p>        若num&gt;0:周围有地雷，只需简单修改矩阵信息即可退出，不用点击周围的方块。</p> 
<p>        若num== 0：要递归点击周围的方块。遍历周围8个格子，依次调用dfs。</p> 
<pre><code class="hljs">//获取周围地雷个数
int get_bombs(char** board,int m,int n,int x,int y){
    int new_x,new_y;
    int num = 0;
    for(int i = -1;i&lt;2;i++)
        for(int j = -1 ;j&lt;2;j++){
            if(i==0 &amp;&amp; j==0)
                continue;
            new_x = x + i;
            new_y = y + j;
            if(new_x &lt; 0 || new_x &gt;= m || new_y &lt; 0 || new_y &gt;= n)  //出界了
                continue;
            if(board[new_x][new_y] == 'M')
                num++;
        }
    return num;
}


//递归点击
void dfs(char**board,int m, int n,int x,int y){
    //该位置已被点击，直接退出
    if(board[x][y] != 'M' &amp;&amp; board[x][y] != 'E')
        return board;
    //点到地雷
    if(board[x][y] == 'M'){
        board[x][y] = 'X';
        return;
    }
    //不是地雷
    int num = get_bombs(board,m,n,x,y); // 获取x,y周围地雷个数
    if(num &gt; 0){
        board[x][y] = '0' + num;
        return;
    }
    //周围没雷，需递归点击周围每个格子
    board[x][y] = 'B';
    int new_x,new_y;
    for(int i  = -1;i&lt;2;i++)
        for(int j = -1;j&lt;2;j++){
            if(i == 0 &amp;&amp; j == 0)
                continue;
            new_x = x + i;
            new_y = y + j;
            if(new_x &lt; 0 || new_x &gt;= m || new_y &lt; 0 || new_y &gt;= n)  //出界了
                continue;
            dfs(board,m,n,new_x,new_y);
        }
    return;
}

char** updateBoard(char** board, int boardSize, int* boardColSize, int* click, int clickSize, int* returnSize, int** returnColumnSizes){
    int m = boardSize,n = boardColSize[0];
    *returnSize = boardSize;
    (*returnColumnSizes) = malloc(sizeof(int)*m);
    for(int i =0;i&lt;m;i++)
        (*returnColumnSizes)[i] = boardColSize[i];

    if(clickSize &lt; 2)
        return board;
    //点击位置不对
    int x = click[0],y = click[1];
    if(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n)
        return board;

    //点击(x,y)处
    dfs(board,m,n,x,y);

    return board;

}</code></pre> 
<p>运行结果如下：</p> 
<p><img alt="" height="322" src="https://images2.imgbox.com/1b/47/G9Wk8ppU_o.png" width="863"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3ea378844de7ee2df294d5db4e9ebe8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NSIS入门教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c5d5bdd2919a99f9995a13596483767e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ReentrantLock公平锁和非公平锁</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>