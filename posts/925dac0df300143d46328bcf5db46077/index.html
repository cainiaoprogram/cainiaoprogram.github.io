<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】数据结构中应用题大全（完结） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】数据结构中应用题大全（完结）" />
<meta property="og:description" content="自己在学习过程中总结了DS中几乎所有的应用题，可以用于速通期末考/考研/各种考试。很多方法来源于B站大佬，底层原理本文不做过多介绍，建议自己研究。例题大部分选自紫皮严书。pdf版在主页资源 一、递归时间/空间分析 1.时间复杂度的分析 设 F a c t ( n ) Fact(n) Fact(n)的执行时间是 T ( n ) T(n) T(n)。
if(n==0) return 1; 的执行时间是 O ( 1 ) O(1) O(1),
F a c t ( n − 1 ) Fact(n-1) Fact(n−1)的执行时间是 T ( n − 1 ) T(n-1) T(n−1),
所以else return n ∗ F a c t ( n − 1 ) n*Fact(n-1) n∗Fact(n−1); 的执行时间是 O ( 1 ) &#43; T ( n − 1 ) O(1)&#43;T(n-1) O(1)&#43;T(n−1)。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/925dac0df300143d46328bcf5db46077/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T16:51:40+08:00" />
<meta property="article:modified_time" content="2024-01-08T16:51:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】数据结构中应用题大全（完结）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <ul><li>自己在学习过程中总结了DS中几乎所有的应用题，可以用于速通期末考/考研/各种考试。</li><li>很多方法来源于B站大佬，底层原理本文不做过多介绍，建议自己研究。</li><li>例题大部分选自紫皮严书。</li><li>pdf版在主页资源</li></ul> 
</blockquote> 
<h3><a id="_5"></a>一、递归时间/空间分析</h3> 
<h4><a id="1_6"></a>1.时间复杂度的分析</h4> 
<p>设<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         a 
        
       
         c 
        
       
         t 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        Fact(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>的执行时间是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        T(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>。<br> if(n==0) return 1; 的执行时间是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         1 
        
       
         ) 
        
       
      
        O(1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>,<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         a 
        
       
         c 
        
       
         t 
        
       
         ( 
        
       
         n 
        
       
         − 
        
       
         1 
        
       
         ) 
        
       
      
        Fact(n-1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>的执行时间是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         ( 
        
       
         n 
        
       
         − 
        
       
         1 
        
       
         ) 
        
       
      
        T(n-1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>,<br> 所以else return <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         ∗ 
        
       
         F 
        
       
         a 
        
       
         c 
        
       
         t 
        
       
         ( 
        
       
         n 
        
       
         − 
        
       
         1 
        
       
         ) 
        
       
      
        n*Fact(n-1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4653em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>; 的执行时间是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         1 
        
       
         ) 
        
       
         + 
        
       
         T 
        
       
         ( 
        
       
         n 
        
       
         − 
        
       
         1 
        
       
         ) 
        
       
      
        O(1)+T(n-1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。<br> <img src="https://images2.imgbox.com/36/ff/KOH9ewxO_o.png" alt="在这里插入图片描述"></p> 
<p>推出：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
         = 
        
       
         n 
        
       
         C 
        
       
         + 
        
       
         T 
        
       
         ( 
        
       
         0 
        
       
         ) 
        
       
         = 
        
       
         n 
        
       
         C 
        
       
         + 
        
       
         D 
        
       
      
        T(n)=nC+T(0)=nC+D 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
         = 
        
       
         O 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        T(n)=O(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p> 
<pre><code>【小结论】：Fibonacci数列和Hanoi塔问题递归算法的时间复杂度均为O(2^n)。
</code></pre> 
<h4><a id="2_18"></a>2.空间复杂度分析</h4> 
<p>空间复杂度<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
         = 
        
       
         O 
        
       
         ( 
        
       
         f 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
         ) 
        
       
      
        S(n)=O(f(n)) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span>，其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        f(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>为“递归工作栈”中工作记录的个数与问题规模 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 的函数关系。</p> 
<pre><code>【小结论】：阶乘间题、Fibonacci数列问题、Hanoi塔问题的递归算法的空间复杂度均为O(n)。
</code></pre> 
<h3><a id="KMPnextnextval_24"></a>二、KMP算法求next数组和nextval</h3> 
<h4><a id="1nexti_25"></a>1.next[i]</h4> 
<p>前2位一般为：0,1<br> i位看前i-1位最大公共部分末尾坐标+1</p> 
<h4><a id="2nexvali_28"></a>2.nexval[i]</h4> 
<p>前1位一般为：0<br> t[next[i]]位置元素是不是和t[i]一样，一样的话将t[next[i]]的nextval写在当前nextval[i]；不一样的话就将当前的next[i]里面数写在nextval[i]</p> 
<blockquote> 
 <p>例题1已知模式串t=“abcaabbabcab”, 写出用KMP法求得的每个字符对应的next和nextval函数值。<br> <img src="https://images2.imgbox.com/a9/1e/Ixggh64d_o.png" alt="在这里插入图片描述"><br> 例题2、3<br> <img src="https://images2.imgbox.com/92/42/Hm81FReL_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_37"></a>三、数组存贮（选择&amp;简答）</h3> 
<h4><a id="1_38"></a>1.对称矩阵</h4> 
<p><img src="https://images2.imgbox.com/a8/3a/qjpHKn7q_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_40"></a>2.三角矩阵</h4> 
<p>(1)上三角<br> <img src="https://images2.imgbox.com/f5/c9/EbKA411L_o.png" alt="在这里插入图片描述"></p> 
<p>(2)下三角<br> <img src="https://images2.imgbox.com/58/51/StlK4rc5_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>例题1假设以行序为主序存储二维数组 A = array[ 1…100, 1…100] , 设每个数据元素占2个存储单元，基地址为10, 则 LOC[5,5] = ( )。<br> <font color="dd0000">【解析】LOC[5,5]有(5-1)满行，最后一行有(5-1)个</font><br> Loc[5,5]=(4*100+4)*2+10=818</p> 
</blockquote> 
<blockquote> 
 <p>例题2数组A中，每个元素A[i,j]的长度均为32个二进制位，行下标从-1~9, 列下标从1 ~11,从首地址S开始连续存放在主存储器中，主存储器字长为16位。<br> 求：<br> （1）存放该数组所需多少单元？<br> 32/16=2字<br> 11 * 11 * 2=242<br> （2）存放数组第4列所有元素至少需多少单元？<br> 11*2=22<br> （3）数组按行存放时，元素A[7,4]的起始地址是多少？<br> <font color="dd0000">【解析】A[7,4]有(7-1+2)满行，最后一行有(4)个</font><br> S+((6+2)*11+4-1)*2=S+182<br> （4）数组按列存放时，元素 A[4, 7]的起始地址是多少？<br> <font color="dd0000">【解析】A[4, 7]有6满列，最后一列有(4+2)个</font><br> S+((7-1)*11+(4+2)-1)*2=S+142</p> 
</blockquote> 
<blockquote> 
 <p>例题3设有一个 10 阶的对称矩阵 A , 采用压缩存储方式以行序为主存储，a11为第一元素， 其存储地址为1,每个元素占一个地址空间，则a85的地址为( )。<br> <img src="https://images2.imgbox.com/a1/8a/zWkXdppc_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>(易错)若对n阶对称矩阵A以行序为主序方式将其下三角形的元素（包括主对角线上所有元素）依次存放于一维数组 B[1…(n (n+1))/2]中，则在B中确定aij (i&lt;j)的位置k的关系为（）<br> 本来是i (i -1)/2 + j，但是(i&lt;j) 所以j(j-1)/2+i</p> 
</blockquote> 
<h3><a id="_75"></a>四、广义表—求表头/表尾/长度/深度（选择&amp;简答）</h3> 
<h4><a id="1HeadA_76"></a>1.取表头Head(A)</h4> 
<p>就取A的第一个元素</p> 
<h4><a id="2TailA_78"></a>2.取表尾Tail(A)</h4> 
<p>就是扣掉第一个元素，留下的所有的（包含A最外面的大括号）</p> 
<h4><a id="3_80"></a>3.长度</h4> 
<p>就是元素的个数</p> 
<blockquote> 
 <p>//严书例子<br> (1) A = ()—A 是一个空表， 其长度为零。<br> (2) B=(e)—B 只有一个原子 e, 其长度为1。<br> (3) C= (a, (b, c, d))—C的长度为2, 两个元素分别为原子 a 和子表(b,c, d)。<br> (4) D = (A, B, C)—D 的长度为3,3个元素都是广义表。显然，将子表的值代入后，则有 D = ((), (e), (a, (b, c, d)))。<br> (5) E = (a, E)—这是一个递归的表，其长度为2。E 相当千一个无限的广义表 E=(a, (a, (a, ···)))。</p> 
</blockquote> 
<h4><a id="4_90"></a>4.深度</h4> 
<p>就是数左or右括号的个数</p> 
<blockquote> 
 <p>例题1设广义表 L = ((a,b,c)), 则 L 的长度和深度分别为( )<br> 长度就是元素个数=1<br> 深度就是数括号个数=2</p> 
</blockquote> 
<blockquote> 
 <p>例题2广义表((a,b,c,d))的表头是( ),表尾是( )<br> 取表头Head(A)就取A的第一个元素=(a,b,c,d)<br> 取表尾Tail(A)就是扣掉第一个元素，留下的所有的（包含A最外面的大括号）=( )</p> 
</blockquote> 
<blockquote> 
 <p>例题3广义表 A= (a,b,(c,d),(e,(f,g))), 则 Head(Tail(Head(Tail(Tail(A)))))的值为( )。<br> Tail(A)= (b,(c,d),(e,(f,g)))<br> Tail(Tail(A))= ( (c,d),(e,(f,g)))<br> Head(Tail(Tail(A)))= (c,d)<br> Tail(Head(Tail(Tail(A))))= (d)<br> Head(Tail(Head(Tail(Tail(A)))))=d</p> 
</blockquote> 
<blockquote> 
 <p>例题4请将香蕉 banana 用工具H( )—Head( ), T()—Tail( )从L中取出。<br> L = (apple, (orange, (strawberry, (banana)), peach), pear)<br> <img src="https://images2.imgbox.com/e8/81/NLP7tl5h_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_114"></a>五、前/中/后/层序遍历二叉树+先后根遍历森林</h3> 
<h4><a id="1_115"></a>1.前序/前缀表达式/波兰式</h4> 
<p>树：根左右<br> 森林：根左到右<br> <img src="https://images2.imgbox.com/06/85/tjyH21nE_o.png" alt="在这里插入图片描述"><br> RADEBCFGHK</p> 
<h4><a id="2_120"></a>2.中序/中缀表示</h4> 
<p>树：左根右<br> 把一个树拍扁了就是中序~</p> 
<h4><a id="3_124"></a>3.后序/后缀表达式/逆波兰式</h4> 
<p>树：左右根<br> 森林：左到右根<br> <img src="https://images2.imgbox.com/63/5e/pkzFMulx_o.png" alt="在这里插入图片描述"><br> DEABGHKFCR</p> 
<blockquote> 
 <p>例题1试找出满足下列条件的二叉树<br> ①先序序列与后序序列相同<br> <font color="dd0000">【解析】根<s>左右</s> ，<s>左右</s> 根（不能删根！）</font><br> 空树，只有根。<br> ②中序序列与后序序列相同。<br> <font color="dd0000">【解析】：左根<s>右</s> ，左<s>右</s> 根，根左右（不能删根！）</font><br> 空树，只有左子树<br> ③先序序列与中序序列相同。<br> <font color="dd0000">【解析】：根<s>左</s> 右，<s>左</s> 根右（不能删根！）</font><br> 空树，只有右子树<br> ④中序序列与层次遍历序列相同。<br> <font color="dd0000">【解析】：<s>左</s> 根右，层序先输出根（不能删根！）</font><br> 空树，只有右子树</p> 
</blockquote> 
<h3><a id="_145"></a>六、前/后/层次+中序确定二叉树</h3> 
<h4><a id="1_146"></a>1.前序+中序</h4> 
<blockquote> 
 <p>例题1设一棵二叉树的先序序列：ABDFCEGH，中序序列：BFDAGEHC。<br> ①画出这棵二叉树。<br> <img src="https://images2.imgbox.com/eb/50/TdWT14hz_o.png" alt="在这里插入图片描述"><br> ②画出这棵二叉树的后序线索树。（后面）<br> ③将这棵二叉树转换成对应的树（或森林）。（后面）</p> 
</blockquote> 
<h4><a id="2_154"></a>2.后序+中序</h4> 
<blockquote> 
 <p>例题2已知后序序列：DABEC，中序序列：DEBAC，求二叉树<br> <img src="https://images2.imgbox.com/c4/02/ETiGa5rs_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="3_159"></a>3.层次+中序</h4> 
<blockquote> 
 <p>例题3已知层序序列：ABCDEF，中序序列：BADCFE，求二叉树<br> <img src="https://images2.imgbox.com/b7/da/bCrPQVes_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="4_164"></a>4.拓展</h4> 
<p>①已知前序有多少种二叉树?<br> 入栈出栈个数：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
         / 
        
       
         ( 
        
       
         n 
        
       
         + 
        
       
         1 
        
       
         ) 
        
        
        
          C 
         
        
          2 
         
        
        
        
          n 
         
        
          n 
         
        
       
      
        1/(n+1) C_2n^n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1/</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0715em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.6644em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>种（n为结点个数）</p> 
<h3><a id="_170"></a>七、前中后序线索二叉树的构建</h3> 
<h4><a id="1_171"></a>1.线索二叉树构建方法</h4> 
<p>Step1：写出对应的先/中/后序遍历<br> Step2：如果结点左孩子为空，结点左链连接序列左边的元素；如果结点右孩子为空，结点右链连接序列右边的元素；</p> 
<blockquote> 
 <p>例题1设一棵二叉树的先序序列：ABDFCEGH，中序序列：BFDAGEHC。<br> ①画出这棵二叉树。<br> ②画出这棵二叉树的后序线索树。<br> <img src="https://images2.imgbox.com/64/fd/vScoZocE_o.png" alt="在这里插入图片描述"><br> ③将这棵二叉树转换成对应的树（或森林）。（后面）</p> 
</blockquote> 
<h3><a id="_184"></a>八、树/森林与二叉树的转换</h3> 
<p>变森林/树：删右腿<br> 变二叉树：连右兄弟</p> 
<h4><a id="1_188"></a>1.树→二叉树</h4> 
<p><img src="https://images2.imgbox.com/9b/1a/Npw26ffm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__191"></a>2. 二叉树→树</h4> 
<p><img src="https://images2.imgbox.com/c2/28/3WYm1eYI_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_195"></a>3.森林转→二叉树</h4> 
<p><img src="https://images2.imgbox.com/33/2c/L1HdBvjo_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_198"></a>4.二叉树→森林</h4> 
<p><img src="https://images2.imgbox.com/3b/04/disZ9697_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>例题1设一棵二叉树的先序序列：ABDFCEGH，中序序列：BFDAGEHC。<br> ①画出这棵二叉树。<br> ②画出这棵二叉树的后序线索树。<br> ③将这棵二叉树转换成对应的树（或森林）。<br> <img src="https://images2.imgbox.com/15/a9/TH08fWXa_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/59/fc/4Ehem8LM_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="WPLHT_215"></a>九、哈夫曼树——构造/WPL/HT初始和终结状态</h3> 
<blockquote> 
 <p>例题1已知w = (5,29,7,8,14,23,3,11), 构造一棵哈夫曼树，计算树的带权路径长度，并给出其构造过程中存储结构HT的初始状态和终结状态。<br> ①哈夫曼树：<br> <img src="https://images2.imgbox.com/80/4e/yDCOMAci_o.png" alt="在这里插入图片描述"><br> 或<br> <img src="https://images2.imgbox.com/62/95/KyVibTZH_o.png" alt="在这里插入图片描述"><br> ②WPL=29<em>2+11</em>3+7<em>4+5</em>5+3<em>5+8</em>3+14<em>3+23</em>2= 271<br> ③ <img src="https://images2.imgbox.com/f1/00/xU6skoUl_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>例题2假设用于通信的电文仅由8个字母组成，字母在电文中出现的频率分别为0.07, 0.19, 0.02, 0.06, 0.32, 0.03, 0.21 , 0.10。<br> ①试为这8个字母设计哈夫曼编码。<br> <img src="https://images2.imgbox.com/12/bd/qS2Pu4jm_o.png" alt="在这里插入图片描述"><br> ②试设计另一种由二进制表示的等长编码方案。<br> 等长编码需要3位2进制<br> ③对于上述实例，比较两种方案的优缺点。<br> 哈夫曼WPL=2*(0.19+0.21+0.32)+4*(0.07+0.10+0.06)+5*(0.02+0.03)=2.61（平均码长）<br> 等长WPL=3*(0.19+0.32+0.21+0.07+0.06+0.10+0.02+0.03)=3（平均码长）</p> 
</blockquote> 
<h3><a id="_234"></a>十、邻接矩阵/邻接表/逆邻接表/十字链表—构建、出入度</h3> 
<h4><a id="1_235"></a>1.邻接矩阵</h4> 
<p>①无向图<br> <img src="https://images2.imgbox.com/2c/87/iH2PbusZ_o.png" alt="在这里插入图片描述"></p> 
<p>出入度：第i行or第j列非零元素的个数是顶点i的度</p> 
<p>②有向图<br> <img src="https://images2.imgbox.com/23/61/DhMWu08u_o.png" alt="在这里插入图片描述"></p> 
<p>出入度：第i行非零元素的个数是顶点i的出度；第j列非零元素的个数正好是顶点i的入度</p> 
<h4><a id="2_246"></a>2.邻接表</h4> 
<p>①无向图<br> <img src="https://images2.imgbox.com/54/64/Srrdf4Hi_o.png" alt="在这里插入图片描述"></p> 
<p>info是权重<br> <img src="https://images2.imgbox.com/5c/93/ws41sZVl_o.png" alt="在这里插入图片描述"></p> 
<p>出入度：遍历“一行”</p> 
<p>②有向图<br> <img src="https://images2.imgbox.com/4e/fc/4JlBD8xw_o.png" alt="在这里插入图片描述"></p> 
<p>出度：遍历“一行”<br> 入度：遍历v的每行</p> 
<h4><a id="3_261"></a>3.逆邻接表</h4> 
<p>与邻接表箭头相反<br> <img src="https://images2.imgbox.com/1e/30/GR8ut6fF_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_265"></a>4.十字链表</h4> 
<p><img src="https://images2.imgbox.com/a4/c0/DtONufiN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9d/17/MxnS5cOd_o.png" alt="在这里插入图片描述"></p> 
<p>十字链表的画法<br> Step1.编号<br> Step2.组队：编号结点出去的箭头<br> Step3.连线：前同横线，后同竖线<br> <img src="https://images2.imgbox.com/2b/fd/JDXu8PWc_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>例题1已知有向图，请给出：<br> <img src="https://images2.imgbox.com/90/ad/Vnmte43M_o.png" alt="在这里插入图片描述"><br> ①每个顶点的入度和出度；<br> 1的出：0；入：3<br> 2的出：2；入：2<br> 3的出：2；入：1<br> 4的出：3；入：1<br> 5的出：1；入：2<br> 6的出：3；入：2<br> ②邻接矩阵；<br> 1 2 3 4 5 6<br> 1 0 0 0 0 0 0<br> 2 1 0 0 1 0 0<br> 3 0 1 0 0 0 1<br> 4 0 0 1 0 1 1<br> 5 1 0 0 0 0 0<br> 6 1 1 0 0 1 0<br> ③邻接表；<br> <img src="https://images2.imgbox.com/fa/0b/8cUmVpfT_o.png" alt="在这里插入图片描述"><br> ④逆邻接表。<br> <img src="https://images2.imgbox.com/3a/2d/zT6f9TTU_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>例题2已知无向网，请给出：<br> <img src="https://images2.imgbox.com/f2/72/NQORN2fa_o.png" alt="在这里插入图片描述"><br> ①邻接矩阵；<br> <img src="https://images2.imgbox.com/dd/7a/l9UaZus2_o.png" alt="在这里插入图片描述"><br> ②邻接表；<br> <img src="https://images2.imgbox.com/f6/d6/xyb0PwS9_o.png" alt="在这里插入图片描述"><br> ③最小生成树。（后面）</p> 
</blockquote> 
<h3><a id="_315"></a>十一、生成树—深度优先/广度优先</h3> 
<blockquote> 
 <p>已知图的邻接矩阵。试分别画出自顶点1出发进行遍历所得的深度优先生成树和广度优先生成树。<br> <img src="https://images2.imgbox.com/c0/40/whTazDqV_o.png" alt="在这里插入图片描述"><br> 深度优先<img src="https://images2.imgbox.com/46/ed/6yAFmrl3_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ba/ee/tTsMcNUI_o.png" alt="在这里插入图片描述"><br> 广度优先<br> <img src="https://images2.imgbox.com/3c/65/fR1xXG3D_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="PrimKruskal_331"></a>十二、最小生成树—Prim/Kruskal</h3> 
<h4><a id="1_Prim__332"></a>1.普里姆 (Prim) 算法</h4> 
<p>从某点出发，找最短的边加入集合，再以集合为整体继续加入边。过程中不能出现回路！</p> 
<blockquote> 
 <p>例题1<br> <img src="https://images2.imgbox.com/37/0e/pA4Aop2H_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c0/f1/SedYX5hn_o.png" alt="在这里插入图片描述">1→6→5→2→3→4（不唯一）</p> 
</blockquote> 
<h4><a id="2_Kruskal__339"></a>2.克鲁斯卡尔 (Kruskal) 算法</h4> 
<p>直接找最小的边，过程中不能出现回路！</p> 
<blockquote> 
 <p>例题1<br> <img src="https://images2.imgbox.com/6c/bf/7HFCQ26F_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a2/bb/zsFfYXjp_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>例题2<br> 已知无向网，请给出：<br> <img src="https://images2.imgbox.com/62/85/Zsw2RE8V_o.png" alt="在这里插入图片描述"><br> ②邻接表；<br> ③最小生成树。<br> <img src="https://images2.imgbox.com/3d/0e/KqqzCFUL_o.png" alt="在这里插入图片描述"><br> ③Kruskal</p> 
</blockquote> 
<h3><a id="DijkstraFloyd_355"></a>十三、最短路径—Dijkstra/Floyd</h3> 
<h4><a id="1Dijkstra_356"></a>1.从某个源点到其余各顶点的最短路径迪杰斯特拉（Dijkstra）算法</h4> 
<p>从某点出发，找最短的边加入集合，再以集合为整体继续加入边。<br> 与Prim不同的是，Prim只用看集合相连的最短，Dijkstra还要算一算。</p> 
<blockquote> 
 <p>例题1试用迪杰斯特拉算法求出从顶点a到其他各顶点间的最短路径<br> <img src="https://images2.imgbox.com/37/d4/N2hqMCjb_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/73/52/VYXmZGeR_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9f/33/rySR3los_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="2Floyd_371"></a>2.每一对顶点之间的最短路径弗洛伊德(Floyd)算法</h4> 
<p>不断基于对角线上元素画“十字”计算的过程<br> Step1.从第一个对角线元素开始不断画十字<br> Step2.十字和它∞部分对应的行列值不变<br> Step3.更新值（值比原来元素小才更新）与路径，取下一个对角线元素继续重复</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/57/53/qHPyx5ee_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7a/4e/UXSG6c4H_o.png" alt="在这里插入图片描述"><br> 对于更新路径：A1中[5,2]从∞(5_31→2_12)更新为7(5→1→2)</p> 
</blockquote> 
<h3><a id="_380"></a>十四、拓扑排序/逆拓扑排序</h3> 
<h4><a id="1AOV_381"></a>1.AOV-网</h4> 
<p>这种用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网。AOV-网是无环的有向图(DAG)</p> 
<h4><a id="2__383"></a>2. 拓扑排序</h4> 
<p>就是将AOV-网中所有顶点排成一个线性序列，该序列满足：若在AOV-网中由顶点Vi到顶点Vj有一条路径,则在该线性序列中的顶点Vi必定在顶点Vj之前。</p> 
<p>拓扑排序做法<br> Step1.在有向图中选一个无前驱的顶点且输出它。<br> Step2.从图中删除该顶点和所有以它为尾的弧。<br> Step3.重复1.和2.直至不存在无前驱的顶点。<br> 若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环，否则输出的顶点序列即为一个拓扑序列。</p> 
<p>逆拓扑排序做法<br> 在有向图中选一个无后继的顶点且输出它。（其余和拓扑排序一样）<br> <img src="https://images2.imgbox.com/6a/c9/2w8ZNN74_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>例题1<img src="https://images2.imgbox.com/09/93/pj50WXMp_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e2/4b/yCZOASMy_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="AOE_404"></a>十五、AOE-网—事件&amp;活动最早/最迟/时间余量/关键活动/关键路径</h3> 
<h4><a id="1_AOE_405"></a>1. AOE-网</h4> 
<p>AOE-网是一个带权的有向无环图，其中，顶点表示事件，弧表示活动，权表示活动持续的时间</p> 
<p>ve(1):事件v_1的最早发生时间<br> vl(1):事件v_1的最迟发生时间<br> <img src="https://images2.imgbox.com/04/96/IAcI9Pgb_o.png" alt="在这里插入图片描述"></p> 
<p><strong>早顺迟逆；早+迟-；早大迟小<br> 说明：最早时间从源点顺着往汇点走<br> 最迟时间从汇点逆着往源点走<br> 最早时间顺着走的时候遇到两条道路选相加最大的<br> 最迟时间逆着走的时候遇到两条道路选相减最小的</strong></p> 
<p>e(1):活动a_1的最早开始时间<br> l(1): 活动a_1的最迟开始时间<br> <strong>早=弧尾早；迟=弧头迟-权值<br> 说明：最早时间是&lt;x,y&gt;弧尾事件的最早开始时间<br> 最迟时间是&lt;x,y&gt;弧头事件的最迟开始时间-&lt;x,y&gt;的权值</strong></p> 
<h4><a id="2_423"></a>2.关键路径</h4> 
<p>关键路径上的活动没有时间余量，即l(1)-e(1)=0<br> 关键路径：路径长度最长的路径，完成工程至少需要的时间<br> 关键路径上的活动是影响工程的关键活动</p> 
<blockquote> 
 <p>例题1<br> <img src="https://images2.imgbox.com/cf/a4/XBUkeMg1_o.png" alt="在这里插入图片描述"><br> ①求这个工程最早可能在什么时间结束；<br> <img src="https://images2.imgbox.com/ef/c1/2XPHaBgy_o.png" alt="在这里插入图片描述"><br> ve(i) vl(i)<br> 1 0 <br> 2 19 <br> 3 15 <br> 4 29 <br> 5 38 <br> 6 43 <br> <img src="https://images2.imgbox.com/85/f7/wcYbjVt7_o.png" alt="在这里插入图片描述"><br> ve(i) vl(i)<br> 1 0 0<br> 2 19 19<br> 3 15 15<br> 4 29 37<br> 5 38 38<br> 6 43 43<br> 最早结束时间:43<br> ②求每个活动的最早开始时间和最早开始时间；<br> <img src="https://images2.imgbox.com/8a/f8/OB21AvvQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e7/50/6sX6DVAv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d0/30/2xe1xyin_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/61/63/WtuDg492_o.png" alt="在这里插入图片描述">③确定哪些活动是关键活动。<br> &lt;1,3&gt;&lt;3,2&gt;&lt;2,5&gt;&lt;5,6&gt;<br> ④关键路径<br> 1,3,2,5,6</p> 
</blockquote> 
<blockquote> 
 <p>例题2<br> <img src="https://images2.imgbox.com/47/3f/JcZ8Z7i8_o.png" alt="在这里插入图片描述"><br> acg18<br> aeh 18<br> bfh 27<br> bdcg 27<br> bdeh 27<br> 关键路径：路径长度最长的路径。<br> 答案：C</p> 
</blockquote> 
<h3><a id="_467"></a>十六、顺序查找—顺序/折半/分块</h3> 
<h4><a id="1_468"></a>1.顺序</h4> 
<p>(1)普通顺序查找<br> ASL成功=<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         ( 
        
       
         1 
        
       
         + 
        
       
         2 
        
       
         + 
        
       
         3 
        
       
         + 
        
       
         ⋯ 
        
       
         + 
        
       
         n 
        
       
         ) 
        
       
         ) 
        
       
         / 
        
       
         n 
        
       
         = 
        
       
         ( 
        
       
         1 
        
       
         + 
        
       
         n 
        
       
         ) 
        
       
         / 
        
       
         2 
        
       
      
        ((1+2+3+⋯+n))/n=(1+n)/2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">((</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span></span><br> ASL不成功=<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
         + 
        
       
         1 
        
       
      
        n+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span><br> 时间复杂度:<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        O(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p> 
<p>(2)有序表的顺序查找</p> 
<p>ASL不成功=<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         ( 
        
       
         1 
        
       
         + 
        
       
         2 
        
       
         + 
        
       
         3 
        
       
         + 
        
       
         ⋯ 
        
       
         + 
        
       
         n 
        
       
         + 
        
       
         n 
        
       
         ) 
        
       
         ) 
        
       
         / 
        
       
         ( 
        
       
         n 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
         = 
        
       
         n 
        
       
         / 
        
       
         2 
        
       
         + 
        
       
         n 
        
       
         / 
        
       
         ( 
        
       
         n 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
      
        ((1+2+3+⋯+n+n))/(n+1)=n/2+n/(n+1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">((</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span><img src="https://images2.imgbox.com/7f/92/m2tEk4WO_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_480"></a>2.折半</h4> 
<p>要求：线性表必须采用顺序存储结构，而且表中元素按关键字有序排列<br> <img src="https://images2.imgbox.com/a3/7a/dgQ4t6Uz_o.png" alt="在这里插入图片描述"></p> 
<p>ASL成功=<img src="https://images2.imgbox.com/ba/a3/LpKD1Ud8_o.png" alt="在这里插入图片描述"></p> 
<pre><code>时间复杂度为:$O(log_2 n)$
</code></pre> 
<h4><a id="3_488"></a>3.分块</h4> 
<p><img src="https://images2.imgbox.com/49/fd/ptTRMEvT_o.png" alt="在这里插入图片描述"></p> 
<p>ASL成功= Lb+Lw<br> Lb为查找索引表确定所在块的平均查找长度，Lw为在块中查找元素的平均查找长度</p> 
<blockquote> 
 <p>例题1<br> 假定对有序表：(3, 4, 5, 7, 24, 30, 42, 54, 63, 72, 87, 95) 进行折半查找，试回答下列问题。（编号从1开始）<br> ①画出描述折半查找过程的判定树。<br> <img src="https://images2.imgbox.com/74/d8/whm2mLEw_o.png" alt="在这里插入图片描述"><br> ②若查找元素54, 需依次与哪些元素比较？ 30,63,42,54<br> ③若查找元素90, 需依次与哪些元素比较？ 30,63,87,95<br> ④假定每个元素的查找概率相等，求查找成功时的平均查找长度。<br> ASL成功=(1<em>1+2</em>2+3<em>4+4</em>5)/12=37/12</p> 
</blockquote> 
<h3><a id="BTSAVLBB_503"></a>十七、树表的查找—BTS/AVL/B/B+</h3> 
<h4><a id="1BTS_504"></a>1.二叉排序树(BTS)</h4> 
<p>(1)定义<br> ①若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br> ②若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br> ③它的左、右子树也分别为二叉排序树。</p> 
<p>(2)性质<br> 中序遍历一棵二叉树时可以得到一个结点值递增的有序序列<br> <img src="https://images2.imgbox.com/b0/bb/1rUY9qnh_o.png" alt="在这里插入图片描述"></p> 
<p>(3)插入<br> <img src="https://images2.imgbox.com/b8/fa/iLTJxoxN_o.png" alt="在这里插入图片描述"><br> 插入一定是叶子结点</p> 
<p>(4)构造<br> <img src="https://images2.imgbox.com/47/91/vwTQGkiT_o.png" alt="在这里插入图片描述"></p> 
<p>(5)删除<br> ①删叶子，直接删<br> ②删无左孩子/无右孩子，孩子替换要删的结点<br> ③删有左右孩子，找中序遍历的直接前驱/后继，替换要删的结点，删去这个前驱/后继，变为①②<br> 【说明】：反正保证二叉排序树中序遍历有序就行<br> <img src="https://images2.imgbox.com/7a/54/gbjFEN3Q_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ff/50/c3EMomHA_o.png" alt="在这里插入图片描述"><br> (6)ASL O()<br> <img src="https://images2.imgbox.com/9f/72/MvNTyQxg_o.png" alt="在这里插入图片描述"></p> 
<p>ASLa成功=(1<em>1+2</em>2+3<em>4+4</em>3)/10=2.9<br> ASLa不成功=(3<em>5+4</em>6)/11=3.545</p> 
<p>若二叉排序树左右子树高度只差的绝对值不超过1(平衡二叉树),它的平均查找长度为O(log2n)。<br> 若二叉排序树是一个只有右（左）孩子的单支树（类似于有序的单链表)，则其平均查找长度为O(n)。</p> 
<h4><a id="2AVL_539"></a>2.平衡二叉树AVL</h4> 
<p>(1)定义<br> 结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。</p> 
<p>(2)插入<br> 从接入的点往上找“最小不平衡子树”的根，找根在这条路径上最近的3个结点调整，调整完剩余结点按定义去放<br> ①LR：<br> <img src="https://images2.imgbox.com/00/d5/aZ4qpHGy_o.png" alt="在这里插入图片描述"></p> 
<p>②LL：<br> <img src="https://images2.imgbox.com/0d/e7/LJyJ5y2n_o.png" alt="在这里插入图片描述"></p> 
<p>③RR：<br> <img src="https://images2.imgbox.com/46/01/3BlsvgJZ_o.png" alt="在这里插入图片描述"></p> 
<p>④RL：<br> <img src="https://images2.imgbox.com/91/e0/fhhvnYQ1_o.png" alt="在这里插入图片描述"></p> 
<p>(3)O()<br> 时间复杂度O(log2n)</p> 
<h4><a id="3B_560"></a>3.B-树</h4> 
<p>(1)定义<br> 一棵m阶的B树，或为空树，是所有结点的平衡因子=0的m路平衡查找树<br> <img src="https://images2.imgbox.com/3c/2d/ppbLLpyL_o.png" alt="在这里插入图片描述"></p> 
<p>①树中每个结点至多有m棵子树，最多有m-1个关键字<br> ②若根结点不是叶子结点，则至少有两棵子树；<br> ③除根之外的所有非终端结点至少有 个子树，至少含有 个关键字；<br> ④所有的叶子结点都出现在同一层次上，并且不带信息，通常称为失败结点（失败结点并不存在，指向这些结点的指针为空。引入失败结点是为了便于分析B-树的查找性能）；</p> 
<h4><a id="4B_570"></a>4.B+树</h4> 
<p><img src="https://images2.imgbox.com/92/ff/stgoMQzq_o.png" alt="在这里插入图片描述"></p> 
<p>B+树和B-树的差异<br> (1)有n棵子树的结点中含有n个关键字；<br> (2)所有的叶子结点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶 子结点本身依关键字的大小自小而大顺序链接；<br> (3)所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。</p> 
<blockquote> 
 <p>例题1<br> 在一棵空的二叉排序树中依次插入关键字序列为 12, 7, 17, 11, 16, 2, 13, 9, 21, 4, 请画出所得到的二叉排序树。<br> <img src="https://images2.imgbox.com/05/28/9NyHNQKc_o.png" alt="在这里插入图片描述"><br> 说明：验算办法用中序遍历应得到排序结果:2,4,7,9,11,12,13,16,17,21</p> 
</blockquote> 
<h3><a id="_585"></a>十八、散列表—构造/冲突/查找</h3> 
<p>①散列函数和散列地址：在记录的存储位置p和其关键字key之间建立一个确定的对应关系H, 使p=H(key), 称这个对应关系H为散列函数，p为散列地址。</p> 
<h4><a id="1_588"></a>1.构造方法</h4> 
<p>除留余数法：假设散列表表长为m, 选择一个不大于m的数p, 用p去除关键字，除后所得余数为散列地址，即H(key) = key%p。一般情况下，可以选p为小于表长的最大质数。</p> 
<h4><a id="2_591"></a>2.处理冲突的方法</h4> 
<p>(1)开放地址法<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          H 
         
        
          i 
         
        
       
         = 
        
       
         ( 
        
       
         H 
        
       
         ( 
        
       
         k 
        
       
         e 
        
       
         y 
        
       
         ) 
        
       
         + 
        
        
        
          d 
         
        
          i 
         
        
       
         ) 
        
       
      
        H_i= (H(key) +d_i)%m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mord mathnormal" style="margin-right: 0.0359em;">ey</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span><br> ①线性探测法：d_i = l, 2, 3, …, m-1<br> ②二次探测法：<img src="https://images2.imgbox.com/8c/52/VrcUT27s_o.png" alt="在这里插入图片描述"></p> 
<p>(2)链地址法</p> 
<h4><a id="3__600"></a>3. 查找</h4> 
<p>查找过程中需和给定值进行比较的关键字的个数取决于三个因素：散列函数、处理冲突 的方法和散列表的装填因子a<br> 列表的装填因子a定义为 a=表中填入的记录数/散列表的长度</p> 
<blockquote> 
 <p>例题1<br> 对于的关键字(19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79), 设散列函数为 H(key)= key %13, 用线性探测法处理冲突。设表长为16, 试构造这组关键字的散列表，并计算查找成功和查找失败时的平均查找长度。<br> H(19)=6,H(14)=1,H(23)=10<br> H(1)=1发生冲突,H(1)=(1+1)%13=2<br> H(68)=3,H(20)=7,H(84)=8<br> H(27)=1发生冲突,H(27)=(1+1)%13=2发生冲突,H(27)=(1+2)%13=3发生冲突,H(27)=(1+3)%13=4<br> H(55)=3发生冲突,H(55)=(3+1)%13=4发生冲突,H(55)=(3+2)%13=5<br> H(11)=11<br> H(10)=10发生冲突,H(10)=(10+1)%13=11发生冲突, H(10)=(10+2)%13=12<br> H(79)=1发生冲突,H(79)=(1+1)%13=2发生冲突, H(79)=(1+2)%13=3发生冲突, H(79)=(1+3)%13=4发生冲突, H(79)=(1+5)%13=5发生冲突,….,直到H(79)=(1+8)%13=9</p> 
 <p>散列地址 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15<br> 关键字 14 1 68 27 55 19 20 84 79 23 11 10 <br> 比较次数 1 2 1 4 3 1 1 3 9 1 1 3 <br> ASL成功=(1+2+1+4+3+1+1+3+9+1+1+3)/12=2.5<br> 比较次数相加/占有散列地址的个数<br> ASL失败=(1+13+12+11+10+9+8+7+6 +5+4+3+2)/13<br> 0查找1次失败<br> 1查找13次失败，2查找12次失败，<br> <img src="https://images2.imgbox.com/52/bb/HDpggSGh_o.png" alt="在这里插入图片描述"><br> …<br> 对于 <img src="https://images2.imgbox.com/b6/db/lB67WEVM_o.png" alt="在这里插入图片描述"><br> 注意 1查找失败2次</p> 
</blockquote> 
<blockquote> 
 <p>例题2<br> 已知一组关键字为 (19, 14, 23, 1, 68, 20, 8 4, 27, 55, 11, 10 , 79), 设散列函数 H(key) = key %13, 用链地址法处理冲突，试构造这组关键字的散列表，计算查找成功和查找失败时的平均查找长度。<br> <img src="https://images2.imgbox.com/8e/4f/KvZWiA2M_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/68/f2/949hWYUT_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>例题3<br> 设散列表的地址范围为0～17，散列函数为:H(key)=key%16。用线性探测法处理冲突,输入关键字序列:(10,24,32,17,31,30,46,47,40,63,49)，构造散列表,试回答下列问题:<br> ①画出散列表的示意图。<br> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17<br> 关键字 32 17 63 49 24 40 10 30 31 46 47<br> 比较次数 1 1 6 3 1 2 1 1 1 3 3<br> ②若查找关键字63，需要依次与哪些关键字进行比较? 31,46,47,32,17,63<br> ③若查找关键字60，需要依次与哪些关键字进行比较? H(60)=12,与空对比<br> ④假定每个关键字的查找概率相等，求查找成功时的平均查找长度。<br> ASL成功=(1+1+6+3+1+2+1+1+1+3+3)/11=23/11</p> 
</blockquote> 
<blockquote> 
 <p>例题4<br> 设有一组关键字 (9, 1, 23, 14, 55, 20, 84, 27), 采用散列函数：H(key) = key%7, 表长为 10, 用开放地址法的二次探测法处理冲突。要求：对该关键字序列构造散列表，并计算查找成功的平均查找长度。<br> H(84)=84%7=0，H(84)=(0+1)%7=1, H(84)=(0-1)%7=6，H(84)=(0+4)%7=4<br> H(27)=27%7=6，H(27)=(6+1)%7=0, H(27)=(6-1)%7=5<br> 0 1 2 3 4 5 6 7 8 9<br> 关键字 14 1 9 23 84 27 55 20 <br> 比较次数 1 1 1 2 4 3 1 2 <br> ASLsucc=(1+1+1+2+4+3+1+2)/8=15/8</p> 
</blockquote> 
<blockquote> 
 <p>例题5<br> 散列函数H(K) = 3K % 11 , 散列地址空间为 0~10, 对关键字序列 (32, 13, 49, 24, 38, 21, 4, 12), 按下述两种解决冲突的方法构造散列表，并分别求出等概率下查找成功时和查找失败时的平均查找长度 ASLsucc和 ASLunsucc<br> ①线性探测法。<br> 0 1 2 3 4 5 6 7 8 9 10<br> 关键字 4 12 49 38 13 24 32 21 <br> 比较次数 1 1 1 2 1 2 1 2 <br> ASLsucc=(1+1+1+2+1+2+1+2)/8=11/8<br> ASLunsucc=(1+2+1+8+7+6+5+4+3+2+1)/11=40/11<br> ②链地址法。<br> <img src="https://images2.imgbox.com/7c/70/nv5dGkkD_o.png" alt="在这里插入图片描述"><br> ASLsucc=(1<em>5+2</em>3)/8=11/8<br> ASLunsucc=(1<em>6+2</em>2+3*3)/11=19/11</p> 
</blockquote> 
<h3><a id="_669"></a>十九、插入排序—直接插入/折半插入/希尔</h3> 
<h4><a id="1_670"></a>1.直接插入排序</h4> 
<p>后面没有排好的一个一个往排好的里面丢，比较时候根排好的最后一个元素比<br> <img src="https://images2.imgbox.com/e2/43/IIhwC3Jc_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_675"></a>2.折半插入排序</h4> 
<p>后面没有排好的一个一个往排好的里面丢，比较时候根排好的中间元素比<br> 但对于数据量不很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序仅减少了比较元素的次数约O(nlogn)，元素的移动次数并未改变，它依赖于待排序表的初始状态。</p> 
<h4><a id="3_680"></a>3.希尔排序</h4> 
<p>Step1.定义增量序列Dk : Dm&gt;Dm-1&gt;…&gt;D1=1（互质）<br> Step2.对每个Dk进行Dk间隔插入排序<br> <img src="https://images2.imgbox.com/ab/5a/iShKefZq_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>例题1<br> 设待排序的关键字序列为{12,2,16,30,28,10,16*,20,6,18}, 试分别写出使用以下排序方法， 每趟排序结束后关键字序列的状态。<br> ①直接插入排序<br> {12,2,16,30,28,10,16,20,6,18}<br> 第1趟：{(2,12,)16,30,28,10,16,20,6,18}<br> 第2趟：{(2,12,16,)30,28,10,16,20,6,18}<br> 第3趟：{(2,12,16,30,)28,10,16,20,6,18}<br> 第4趟：{(2,12,16,28,30,)10,16,20,6,18}<br> 第5趟：{(2,10,12,16,28,30,)16,20,6,18}<br> 第6趟：{(2,10,12,16,16,28,30,)20,6,18}<br> 第7趟：{(2,10,12,16,16,20,28,30,)6,18}<br> 第8趟：{(2,6,10,12,16,16,20,28,30,)18}<br> 第9趟：{(2,6,10,12,16,16,18,20,28,30)}<br> ②折半插入排序<br> 与①过程一样只是在比较时候比的位置不一样，第一个是最后一个，第二个是中间<br> ③希尔排序（增量选取5,3,1)<br> 增量为5:{12,2,16,30,28,10,16,20,6,18}<br> {10,2,16,6,18,12,16,20,30,28}<br> 增量为3:{10,2,16,6,18,12,16,20,30,28}<br> {6,2,12,10,18,16,16,20,30,28}<br> 增量为1:{10,2,16,6,18,12,16,20,30,28}<br> {2,6,10,12,16,16,18,20,28,30}</p> 
</blockquote> 
<h3><a id="_710"></a>二十、交换排序—冒泡/快速</h3> 
<h4><a id="1_711"></a>1.冒泡排序</h4> 
<p>从前两两对比，大的往后放</p> 
<h4><a id="2_714"></a>2.快速排序</h4> 
<blockquote> 
 <p>例题1<br> 设待排序的关键字序列为{12,2,16,30,28,10,16*,20,6,18}, 试分别写出使用以下排序方法， 每趟排序结束后关键字序列的状态。<br> ①冒泡排序<br> {12,2,16,30,28,10,16,20,6,18}<br> 第1趟：{2, 12,16, 28, 10, 16,20,6,18,30}<br> 第2趟：{2, 12,16, 10, 16, 20, 6,18, 28,30}<br> 第3趟：{2, 12, 10, 16,16, 6,18, 20, 28,30}<br> 第4趟：{2, 10, 12, 16, 6, 16, 18, 20, 28,30}<br> 第5趟：{2, 10, 12, 6, 16,16, 18, 20, 28,30}<br> 第6趟：{2, 10, 6, 12, 16,16, 18, 20, 28,30}<br> 第7趟：{2, 6, 10, 12, 16,16, 18, 20, 28,30}<br> 第8趟：{2, 6, 10, 12, 16,16, 18, 20, 28,30}<br> 第9趟：{2, 6, 10, 12, 16,16, 18, 20, 28,30}<br> 第10趟：{2, 6, 10, 12, 16,16, 18, 20, 28,30}<br> ②快速排序<br> {12,2,16,30,28,10,16,20,6,18}<br> 第一趟：<br> <img src="https://images2.imgbox.com/eb/c6/uJLYJkT7_o.png" alt="在这里插入图片描述"><br> 第二趟：<br> <img src="https://images2.imgbox.com/f6/d9/BGtGaYBx_o.png" alt="在这里插入图片描述"><br> 第三趟：<br> {2,6,10,12,18,16,16,20,28,30}<br> 第四趟：<br> {2,6,10,12, 16, 16,18,20,28,30}<br> 第五趟：<br> {2,6,10,12, 16, 16,18,20,28,30}<br> 左子序列递归深度为1,右子序列递归深度为3</p> 
</blockquote> 
<h3><a id="_744"></a>二十一、选择排序—简单选择/堆排</h3> 
<h4><a id="1__745"></a>1. 简单选择排序</h4> 
<p>遍历找小的放前面</p> 
<h4><a id="2__748"></a>2. 堆排序</h4> 
<p><img src="https://images2.imgbox.com/e7/9d/o49vzCZs_o.png" alt="在这里插入图片描述"></p> 
<p>(1)建堆（例题1）<br> (2)重建堆（堆排序过程）（例题1）<br> 根与最后一个元素换位置，输出最后一个元素（也就是根），然后建堆</p> 
<blockquote> 
 <p>例题1<br> 设待排序的关键字序列为{12,2,16,30,28,10,16*,20,6,18}, 试分别写出使用以下排序方法， 每趟排序结束后关键字序列的状态。<br> ①简单选择排序<br> {12,2,16,30,28,10,16*,20,6,18}<br> 第1趟：{2, 12,16,30,28,10,16,20,6,18}<br> 第2趟：{2,6,12,16,30,28,10,16,20,18}<br> 第3趟：{2,6,10,12,16,30,28,16,20,18}<br> 第4趟：{2,6,10,12,16,30,28,16,20,18}<br> 第5趟：{2,6,10,12,16,30,28,16,20,18}<br> 第6趟：{2,6,10,12,16,16,30,28,20,18}<br> 第7趟：{2,6,10,12,16,16,18,30,28,20}<br> 第8趟：{2,6,10,12,16,16,18,20,30,28}<br> 第9趟：{2,6,10,12,16,16,18,20,28,30}<br> 第10趟：{2,6,10,12,16,16,18,20,28,30}<br> ②堆排序<br> (1)初始堆<br> <img src="https://images2.imgbox.com/4c/38/YjvIEt8F_o.png" alt="在这里插入图片描述"><br> (2)重建堆<br> <img src="https://images2.imgbox.com/9d/0b/Whs7FZiL_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_777"></a>二十二、归并排序</h3> 
<p>两路归并就是两个两个排序，排好之后，再四个四个排，以此类推</p> 
<blockquote> 
 <p>例题1<br> 设待排序的关键字序列为{12,2,16,30,28,10,16*,20,6,18}, 试分别写出使用以下排序方法， 每趟排序结束后关键字序列的状态。<br> ①二路归并排序<br> {12,2,16,30,28,10,16*,20,6,18}<br> 第1次：{2,12,16,30,10,28,16*,20,6,18}<br> {2,12,16,30,10,28,16*,20,6,18}<br> 第2次： {2,12,16,30,10,16*,20,28,6,18}<br> {2,12,16,30,10,16*,20,28,6,18}<br> 第3次：{2,10,12,16,16*,20,28,30,6,18}<br> {2,10,12,16,16*,20,28,30,6,18}<br> 第4次：{2,6,10,12,16,16*,18,20,28,30}</p> 
</blockquote> 
<h3><a id="_792"></a>二十三、基数排序</h3> 
<blockquote> 
 <p>例题1<br> 给出如下关键字序列 {321,156, 57, 46, 28, 7,331, 33, 34, 63}, 试按链式基数排序方法， 列出每一趟分配和收集的过程。<br> 第一趟：<br> 分配：<br> <img src="https://images2.imgbox.com/ee/86/isSOnuJB_o.png" alt="在这里插入图片描述"><br> 收集：321,331,33,63,34,156,46,57,7,28<br> 第二趟<br> 分配<br> <img src="https://images2.imgbox.com/1f/85/AQkK2HGL_o.png" alt="在这里插入图片描述"><br> 收集：7,321,28,331,33,34,46,156,57,63<br> 第三趟<br> 分配<img src="https://images2.imgbox.com/e4/af/jLqYxSsl_o.png" alt="在这里插入图片描述"><br> 收集：7,28,33,46,57,63,156,321,331</p> 
</blockquote> 
<h3><a id="_808"></a>二十四、排序算法时间/空间/稳定性记忆</h3> 
<p>B站： BV1NL4y1t7Do<br> <img src="https://images2.imgbox.com/79/88/G7QXAWHL_o.png" alt="在这里插入图片描述"></p> 
<p>稳定性：插帽龟(插入冒泡归并)🐢，统计鸡(桶排计数基数)🐓<br> 时间复杂度：插帽龟选择帽子插（选择冒泡插入）的时候，恩姓长老就方了（n^2），大喊“快归堆”（快速归并堆排）（logn）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e0a463b33fe53748e1e99a93c2c3b222/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">真的干不过，00后整顿职场已经给我卷麻了，想离职了...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/31b08d08fba54670a94e5af3c22bcfad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">spring Security源码讲解-Sevlet过滤器调用springSecurty过滤器的流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>