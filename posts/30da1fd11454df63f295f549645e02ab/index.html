<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>InfluxDB：时序型数据库学习笔记，就这一篇吧o(╥﹏╥)o - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="InfluxDB：时序型数据库学习笔记，就这一篇吧o(╥﹏╥)o" />
<meta property="og:description" content="一、什么是时序型数据库 ​时序数据库全称为时间序列数据库。时间序列数据库指主要用于处理带时间标签（按照时间的顺序变化，即时间序列化）的数据，带时间标签的数据也称为时间序列数据。
时间序列数据主要由电力行业、化工行业、气象行业、地理信息等各类型实时监测、检查与分析设备所采集、产生的数据，这些工业数据的典型特点是：产生频率快（每一个监测点一秒钟内可产生多条数据）、严重依赖于采集时间（每一条数据均要求对应唯一的时间）、测点多信息量大（常规的实时监测系统均有成千上万的监测点，监测点每秒钟都产生数据，每天产生几十GB的数据量）。基于时间序列数据的特点，关系型数据库无法满足对时间序列数据的有效存储与处理，因此迫切需要一种专门针对时间序列数据来做优化的数据库系统，即时间序列数据库。
​InfluxDB是一个开源的、高性能的时序型数据库，在时序型数据库DB-Engines Ranking上排名第一。
二、InfluxDB 相关概念 InfluxDB是一个由InfluxData开发的开源时序型数据。它由Go写成，着力于高性能地查询与存储时序型数据。
名称说明organization组织Member用户，可设置权限API TOKEN调用API时使用的tokenbucket数据桶（数据库）measurement数据表point数据点，表示单条数据记录，point由时间戳（time）、数据（field）、标签（tag）三类字段组成retention policy数据保留策略，可以定义数据保留的时长，每个数据库可以有多个数据保留策略，但只能有一个默认策略time代表每条数据的时间字段，是measurement中的数据主键，因此time字段具有索引属性。一条point只能有一个timefield代表各种数据的字段，例如气温、压力、股价等。field字段没有索引属性，一条point可以包括多个fieldtag代表各类非数据字段，例如设备编码、地区、姓名等。tag字段有索引属性，一条point可以包括多个tag（tag只能为字符串类型） InfluxDB与常用的关系型数据库（MySQL）的概念对比：
MySQLInfluxDB数据库databasebucket表名tablemeasurement记录rowspoint字段columnstime&#43;tag&#43;field 三、Linux环境下安装InfluxDB 本人使用的是influxDB V2.3.0版本，想下载的朋友点这里：influxDB V2.3.0 镜像包
1、镜像包拷贝到Linux服务器上，加载镜像 docker load -i influx.tar.gz &gt;/dev/null 2、启动容器 docker run -d --name influxdb \ -p 8086:8086 \ --restart=always \ -v /mnt/influxdb/data:/var/lib/influxdb2 \ -v /etc/localtime:/etc/localtime \ influxdb &gt;/dev/null 接下来是重点喽！！！
（1）influxDB 1.x 版本，配置文件在 etc/influxdb/influxdb.conf，而到了 2.x 版本，进入容器中，通过执行 influxd print-config 命令查看 influxdb 的默认配置。当然也可以手动创建一个名为 config.*的文件，config支持json，toml，yaml格式，将config.*文件放到 etc/influxdb2/文件夹下，启动容器时修改环境变量，指定配置文件读取的路径 --env INFLUXD_CONFIG_PATH=/etc/influxdb2，influxdb启动时会自动检测这个文件。同样可以进入容器，执行 influxd print-config 查看你自定义的配置是否生效；
docker run -d --name influxdb \ -p 8086:8086 \ --restart=always \ --env INFLUXD_CONFIG_PATH=/etc/influxdb2 \ -v /opt/mountdir/influxdb/config/:/etc/influxdb2 \ -v /mnt/influxdb/data:/var/lib/influxdb2 \ -v /etc/localtime:/etc/localtime \ influxdb &gt;/dev/null 四、Springboot 整合 InfluxDB 1、pom." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/30da1fd11454df63f295f549645e02ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-20T18:12:27+08:00" />
<meta property="article:modified_time" content="2023-03-20T18:12:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">InfluxDB：时序型数据库学习笔记，就这一篇吧o(╥﹏╥)o</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、什么是时序型数据库</h3> 
<p><span style="background-color:#fefcd8;">​时序数据库全称为</span><span style="color:#6eaad7;"><strong><span style="background-color:#fefcd8;">时间序列数据库</span></strong></span><span style="background-color:#fefcd8;">。时间序列数据库指主要用于处理带时间标签（按照时间的顺序变化，即时间序列化）的数据，带时间标签的数据也称为时间序列数据。</span></p> 
<p>时间序列数据主要由电力行业、化工行业、气象行业、地理信息等各类型实时监测、检查与分析设备所采集、产生的数据，这些工业数据的典型特点是：产生频率快（每一个监测点一秒钟内可产生多条数据）、严重依赖于采集时间（每一条数据均要求对应唯一的时间）、测点多信息量大（常规的实时监测系统均有成千上万的监测点，监测点每秒钟都产生数据，每天产生几十GB的数据量）。<span style="background-color:#fefcd8;">基于时间序列数据的特点，关系型数据库无法满足对时间序列数据的有效存储与处理，因此迫切需要一种专门针对时间序列数据来做优化的数据库系统，即时间序列数据库。</span></p> 
<p>​<strong>InfluxDB是一个开源的、高性能的时序型数据库，在时序型数据库DB-Engines Ranking上排名第一。</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0c/f0/Ve0dew6Y_o.jpg"></p> 
<h3>二、InfluxDB 相关概念</h3> 
<p>InfluxDB是一个由InfluxData开发的开源时序型数据。它由Go写成，着力于高性能地查询与存储时序型数据。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td><strong>名称</strong></td><td><strong>说明</strong></td></tr><tr><td>organization</td><td>组织</td></tr><tr><td>Member</td><td>用户，可设置权限</td></tr><tr><td>API TOKEN</td><td>调用API时使用的token</td></tr><tr><td>bucket</td><td>数据桶（数据库）</td></tr><tr><td>measurement</td><td>数据表</td></tr><tr><td>point</td><td>数据点，表示单条数据记录，point由时间戳（time）、数据（field）、标签（tag）三类字段组成</td></tr><tr><td>retention policy</td><td>数据保留策略，可以定义数据保留的时长，每个数据库可以有多个数据保留策略，但只能有一个默认策略</td></tr><tr><td>time</td><td>代表每条数据的时间字段，是measurement中的数据主键，因此<span style="background-color:#fefcd8;">time字段具有索引属性。一条point只能有一个time</span></td></tr><tr><td>field</td><td>代表各种数据的字段，例如气温、压力、股价等。<span style="background-color:#fefcd8;">field字段没有索引属性，一条point可以包括多个field</span></td></tr><tr><td>tag</td><td>代表各类非数据字段，例如设备编码、地区、姓名等。<span style="background-color:#fefcd8;">tag字段有索引属性，一条point可以包括多个tag（tag只能为字符串类型）</span></td></tr></tbody></table> 
<p>InfluxDB与常用的关系型数据库（MySQL）的概念对比：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td></td><td><strong>MySQL</strong></td><td><strong>InfluxDB</strong></td></tr><tr><td>数据库</td><td>database</td><td>bucket</td></tr><tr><td>表名</td><td>table</td><td>measurement</td></tr><tr><td>记录</td><td>rows</td><td>point</td></tr><tr><td>字段</td><td>columns</td><td>time+tag+field</td></tr></tbody></table> 
<h3>三、Linux环境下安装InfluxDB</h3> 
<blockquote> 
 <p> 本人使用的是influxDB V2.3.0版本，想下载的朋友点这里：<a class="link-info" href="https://download.csdn.net/download/ZhangXS9722/86746909" title="influxDB V2.3.0 镜像包">influxDB V2.3.0 镜像包</a></p> 
</blockquote> 
<h4>1、镜像包拷贝到Linux服务器上，加载镜像</h4> 
<pre><code class="language-java">docker load -i influx.tar.gz &gt;/dev/null</code></pre> 
<h4>2、启动容器</h4> 
<pre><code class="language-java">docker run -d --name influxdb \
-p 8086:8086 \
--restart=always \
-v /mnt/influxdb/data:/var/lib/influxdb2 \
-v /etc/localtime:/etc/localtime \
influxdb &gt;/dev/null</code></pre> 
<p><strong><span style="color:#fe2c24;">接下来是重点喽！！！</span></strong></p> 
<p>（1）influxDB 1.x 版本，配置文件在 etc/influxdb/influxdb.conf，而到了 2.x 版本，进入容器中，通过执行<span style="background-color:#fbd4d0;"> influxd print-config </span>命令查看 influxdb 的默认配置。当然也可以手动创建一个名为 config.*的文件，config支持json，toml，yaml格式，将config.*文件放到 etc/influxdb2/文件夹下，启动容器时修改环境变量，指定配置文件读取的路径 --env INFLUXD_CONFIG_PATH=/etc/influxdb2，influxdb启动时会自动检测这个文件。同样可以进入容器，执行 influxd print-config 查看你自定义的配置是否生效；</p> 
<pre><code class="language-java">docker run -d --name influxdb \
-p 8086:8086 \
--restart=always \
--env INFLUXD_CONFIG_PATH=/etc/influxdb2 \
-v /opt/mountdir/influxdb/config/:/etc/influxdb2 \
-v /mnt/influxdb/data:/var/lib/influxdb2 \
-v /etc/localtime:/etc/localtime \
influxdb &gt;/dev/null</code></pre> 
<h3>四、Springboot 整合 InfluxDB</h3> 
<h4>1、pom.xml引入依赖包 </h4> 
<pre><code class="language-java">        &lt;!--influxdb --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.influxdb&lt;/groupId&gt;
            &lt;artifactId&gt;influxdb-client-java&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- org.jetbrains.kotlin/kotlin-stdlib --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
            &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;
            &lt;version&gt;1.3.70&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<h4>2、yml中添加配置</h4> 
<pre><code class="language-java">spring:
  influx:
    ip: 192.3.1.21
    port: 8086
    user: admin
    password: admin
    database: text
    token: oTC_PvFCAnojh8xjX7Rz53B2O9ogneggDWNTZ76VkWS9fgveUODgpOFiFvmoDLoxK7vuSNPstA0SJOWKbvlLsw==</code></pre> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">【注】</span></strong>该 token 值来源：安装 InfluxDB 后，浏览器登录 http://ip:8086 ，找到 [API Tokens]</p> 
 <p>--&gt; [ admin's Token] 中复制出来；</p> 
</blockquote> 
<h4>3、启动时注入</h4> 
<pre><code class="language-java">@Component
@Slf4j
@Data
public class InfluxDbConfig {

    @Value("${spring.influx.ip:''}")
    private String ip;

    @Value("${spring.influx.port:''}")
    private Integer port;

    @Value("${spring.influx.user:''}")
    private String userName;

    @Value("${spring.influx.password:''}")
    private String password;

    @Value("${spring.influx.database:''}")
    private String database;

    @Value("${spring.influx.token}")
    private String token;

    public static final String MY_BUCKET = "my_bucket";

    public static final String ORG_NAME = "my_org";

    public static final int TIME_OUT = 60;

    public static  String ORGANIZATION_ID= "";


    public static final ConnectionPool CONNECTION_POOL = new ConnectionPool(10, 3L, TimeUnit.MINUTES);

    public static OkHttpClient getHttpClient() {
        return new OkHttpClient().newBuilder()
                .connectTimeout(TIME_OUT, TimeUnit.SECONDS)
                .readTimeout(TIME_OUT, TimeUnit.SECONDS)
                .writeTimeout(TIME_OUT, TimeUnit.SECONDS)
                .retryOnConnectionFailure(true)
                .connectionPool(CONNECTION_POOL)
                .addInterceptor(new NetInterceptor()).build();
    }


    /**
     * 创建连接
     *
     * @return
     */
    @Bean
    public InfluxDBClient influxDBClient() {
        InfluxDBClientOptions influxDBClientOptions = new InfluxDBClientOptions.Builder()
                .url(getInfluxDBUrl(ip, port))
                .authenticateToken(token.toCharArray())
                .bucket(ORG_NAME)
                .okHttpClient(getHttpClient().newBuilder()).build();
        InfluxDBClient influxDBClient = InfluxDBClientFactory.create(influxDBClientOptions);
        if (checkHealth(influxDBClient)) {
            log.info("【influxdb】connect influxdb success!");
        }
        return influxDBClient;
    }


    /**
     * 组合 influxdb 的 URL
     *
     * @param ip
     * @param port
     * @return
     */

    public String getInfluxDBUrl(String ip, Integer port) {
        StringBuilder stringBuilder = new StringBuilder();
        return stringBuilder.append("http://").append(ip).append(":").append(port).toString();
    }


    /**
     * 检查健康
     *
     * @param influxDBClient
     * @return
     */
    public boolean checkHealth(InfluxDBClient influxDBClient) {
        HealthCheck health = influxDBClient.health();
        return "pass".equals(health.getStatus().getValue());
    }



    /**
     * 获取 organizationId
     *
     * @param influxDBClient
     * @param orgName
     * @return
     */
    public static String getOrganizationId(InfluxDBClient influxDBClient, String orgName) {
        List&lt;Organization&gt; organizations = influxDBClient.getOrganizationsApi().findOrganizations();
        String orgId = "";
        for (Organization organization : organizations) {
            if (organization.getName().equals(orgName)) {
                orgId = organization.getId();
            }
        }
        return orgId;
    }

}
</code></pre> 
<h4>4、代码太多，粘贴些关键的API</h4> 
<p>（1）创建bucket</p> 
<pre><code class="language-java">public BaseResult createDataBase(InfluxDBClient influxDBClient) {
       // 这里先按名称查询 MY_BUCKET 数据库，如果存在就不创建
        Bucket bucket = influxDBClient.getBucketsApi().findBucketByName(MY_BUCKET);
        if (ObjectUtils.isEmpty(bucket)) {
       // 创建 bucket 并设置数据保留策略为1年
            bucket = influxDBClient.getBucketsApi().createBucket(MY_BUCKET, new BucketRetentionRules().everySeconds(3600 * 24 * 365), ORGANIZATION_ID);
           if (ObjectUtils.isEmpty(bucket)) {
                return BaseResult.fail("influxdb create measurement failed……");
            }
        }
        return BaseResult.success();
    }
</code></pre> 
<p>（2）写入数据</p> 
<pre><code class="language-java">    /**
     * 数据插入
     *
     * @param bucket      数据库名称
     * @param orgName     组织名称
     * @param measurement 表名
     * @param tag         索引字段
     * @param fields      字段
     * @param time        查询事件
     */

    public void insert(String bucket, String orgName, String measurement, String tag, Map&lt;String, Object&gt; fields, long time) {
        Point point = Point.measurement(measurement);
        point.addTag("tag", tag);
        point.addFields(fields);
        // 纳秒值
        point.time(TimeUnit.MILLISECONDS.toNanos(time), WritePrecision.NS);

        writeApi.writePoint(bucket, ORGANIZATION_ID, point);
    }
</code></pre> 
<p>（3）数据查询，得到List&lt;FluxTable&gt;后，再根据自己的业务，转成需要的实体对象。值得一提的是：<strong><span style="background-color:#f9eda6;">influxDB从2.0版本之后，就使用了 Flux 语法来查询数据。</span></strong></p> 
<pre><code class="language-java">   /**
     * 数据查询
     *
     * @param bucket
     * @param orgName
     * @param measurement
     * @param flux
     * @return
     */
     public static List&lt;FluxTable&gt; query(String bucket, String orgName, String measurement, String flux) {
        // 构建FLUX语句
        List&lt;FluxTable&gt; fluxTables = new ArrayList&lt;&gt;();
        try {
            String organizationId = getOrganizationId(influxDBClient, orgName);
            fluxTables = influxDBClient.getQueryApi().query(flux, organizationId);
        } catch (Exception e) {
            log.error("【influxdb】 query influxdb data failed:", e);
        }
        return fluxTables;
    }</code></pre> 
<h2>五、FLUX语法</h2> 
<p>Flux 是 InfluxData 的功能性数据脚本语言，设计用于查询、分析和处理数据，它是InfluxQL 和其他类似 SQL 的查询语言的替代品。</p> 
<p>1、from() ：选择数据源 bucket</p> 
<pre><code class="language-java">from(bucket: "hrecord_bucket")</code></pre> 
<p>2、range()：限定时间范围</p> 
<pre><code class="language-java">// 配合InfluxDB客户端中的时间控件使用 
|&gt; range(start: v.timeRangeStart, stop: v.timeRangeStop)

//查询具体时间段
|&gt; range(start: 2022-09-26T01:14:00.000Z, stop: 2022-09-30T01:14:00.000Z)

// 查询过去一小时
|&gt; range(start: -1h)</code></pre> 
<p>3.filter()：条件筛选</p> 
<pre><code class="language-java">// 筛选数据表 
|&gt; filter(fn: (r) =&gt; r["_measurement"] == "tbl_hrecord")

//筛选车牌号
|&gt; filter(fn: (r) =&gt; r["plate_code"] == "京FGS002")</code></pre> 
<p>4. sort()：排序</p> 
<pre><code class="language-java">// 按照时间降序排列，desc:false 为升序 
|&gt; sort(columns:["_time"], desc: true)</code></pre> 
<p>5.limit()：限制返回结果条数，可用于分页查询</p> 
<pre><code class="language-java">//查询前十条
|&gt; limit(n: 10, offset: 0) </code></pre> 
<p>6.pivot()：将列值转为行</p> 
<pre><code class="language-java">  |&gt; pivot(columnKey: ["_field"], rowKey: ["recordId","_time"], valueColumn: "_value")</code></pre> 
<p>7.group()：分组</p> 
<pre><code class="language-java">// 按车牌号码和车牌颜色分组
|&gt; group(columns:["plate_code","plate_color"] , mode: "by")</code></pre> 
<p>8.更多查看：<a class="link-info" href="https://docs.influxdata.com/flux/v0.x/get-started/" rel="nofollow" title="官方文档：Flux的基本使用">官方文档：Flux的基本使用</a></p> 
<hr> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/09/c5/zRuOD8Kx_o.jpg"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/433db2f9122e4cd94a9bd5ff0b12e975/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">这对情侣火了，你猜是因为啥</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4be622b48091a9c3fb7dfcb9da875d69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java框架 | Spring和MyBatis中的#与$</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>