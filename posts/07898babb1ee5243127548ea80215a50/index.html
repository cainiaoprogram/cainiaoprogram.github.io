<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件设计师（3）--＞数据库 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件设计师（3）--＞数据库" />
<meta property="og:description" content="目录
数据库
一、三级模式两级映像
二、数据库的设计过程
三、ER模型
四、关系代数
五、规范化理论
六、并发控制
七、数据库完整性约束
八、数据库安全
九、数据备份
十、数据库故障与恢复
十一、数据仓库
3、数据仓库与数据库的对比​编辑十二、数据挖掘
十三、反规范化技术
十四、大数据技术
数据库 一、三级模式两级映像 &gt;三级模式结构：数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成。
①模式（schema）：
模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。它是数据库系统模式结构的中间层，既不涉及数据的物理存储细节，右与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。
模式实际上是数据库数据在逻辑上的视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，同意综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。定义模式时不仅要定义数据的逻辑结构，例如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等；而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。
数据库管理系统提供模式数据定义语言（模式DDL）来严格地定义模式。
②外模式（external schema）：
外模式也称子模式（subschema）或用户模式，它是数据库用固话（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。
外模式通常是模式的子集。一个数据库可以有多个外模式。由于它是各个用户的数据视图，如果不同的用户在应用需求、看待数据的方式、对数据保密的要求等方面存在差异，则其外模式描述就是不同的。即使对模式中同一数据，在外模式的结构、类型、长度、保密等级等都可以不同。另一方面，同一外模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式。
外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据是不可见的。
③内模式（internal schema）：
内模式也称存储模式（storage schema），一个数据库只有一个内模式。它是数据物理存储和存储方式的描述，是数据在数据库内部的组织方式。例如，记录的存储方式是堆存储还是按照某个（些）属性值的升（降）序存储，或按照属性值聚簇（cluster）存储；索引按照什么方式组织，是B&#43;树索引还是hash索引；数据是否压缩存储，是否加密；数据的存储记录结构有何规定，如定长结构还是变长结构，一个记录不能跨物理页存储；等等。
&gt;数据库中的二级映像功能与数据独立性：
数据库系统的三级模式是数据的三个抽象级别，它把数据的具体祖冲之留给数据库管理系统管理，使用户能逻辑地、抽象地处理数据，而不必关心数据在计算机中的具体表示方式和存储方式。为了能够在系统内部实现这三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。
正式这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。
①外模式/模式映像：
模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对应于同一个模式可以有任意多个外模式。对于每一个外模式，数据库系统都会有一个外模式/模式映像，它定义了该外模式和模式之间的对应关系。这些映像定义通常包含在各自外模式的描述中。
当模式改变时（例如增加新的关系、新的属性、改变属性的数据类型等），由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是根据数据的外模式编写的，从而应用程序不用修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。
②模式/内模式映像：
数据库只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的。该映像定义通常包含在模式描述中。当数据库的存储结构改变时（例如选用了另一种存储结构），由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序之间的物理独立性，简称数据的物理独立性。
二、数据库的设计过程 数据库设计通常分为6个阶段：
①需求分析：分析用户的需求，包括数据、功能和性能需求；
②概念结构设计：主要采用E-R模型进行设计，包括画E-R图；
③逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；
④数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；
⑤数据库的实施：包括编程、测试和试运行；
⑥数据库运行与维护：系统的运行与数据库的日常维护。
三、ER模型 ER图分为实体、属性、关系三个核心部分。实体是长方形体现，而属性则是椭圆形，关系为菱形。
ER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。
ER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。
ER图的关系（relationship）用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。
ER图中关联关系有三种：
1对1（1:1） ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。
1对多（1:N） ：1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。
多对多（M:N） ：多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。
&gt;ER模型转换关系模式
①一对一关系的转换" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/07898babb1ee5243127548ea80215a50/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-18T10:05:53+08:00" />
<meta property="article:modified_time" content="2022-09-18T10:05:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件设计师（3）--＞数据库</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E6%95%B0%E6%8D%AE%E5%BA%93-toc" style="margin-left:0px;"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow">数据库</a></p> 
<p id="%E4%B8%80%E3%80%81%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%83%8F-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%83%8F" rel="nofollow">一、三级模式两级映像</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B" rel="nofollow">二、数据库的设计过程</a></p> 
<p id="%E4%B8%89%E3%80%81ER%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81ER%E6%A8%A1%E5%9E%8B" rel="nofollow">三、ER模型</a></p> 
<p id="%C2%A0%E5%9B%9B%E3%80%81%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%9B%9B%E3%80%81%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0" rel="nofollow"> 四、关系代数</a></p> 
<p id="%E4%BA%94%E3%80%81%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA" rel="nofollow">五、规范化理论</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" rel="nofollow">六、并发控制</a></p> 
<p id="%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F" rel="nofollow">七、数据库完整性约束</a></p> 
<p id="%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8-toc" style="margin-left:40px;"><a href="#%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8" rel="nofollow">八、数据库安全</a></p> 
<p id="%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD-toc" style="margin-left:40px;"><a href="#%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD" rel="nofollow">九、数据备份</a></p> 
<p id="%E5%8D%81%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%85%E9%9A%9C%E4%B8%8E%E6%81%A2%E5%A4%8D-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%85%E9%9A%9C%E4%B8%8E%E6%81%A2%E5%A4%8D" rel="nofollow">十、数据库故障与恢复</a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93" rel="nofollow">十一、数据仓库</a></p> 
<p id="3%E3%80%81%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94%E2%80%8B%E7%BC%96%E8%BE%91%E5%8D%81%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94%E2%80%8B%E7%BC%96%E8%BE%91%E5%8D%81%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98" rel="nofollow">3、数据仓库与数据库的对比​编辑十二、数据挖掘</a></p> 
<p id="%E5%8D%81%E4%B8%89%E3%80%81%E5%8F%8D%E8%A7%84%E8%8C%83%E5%8C%96%E6%8A%80%E6%9C%AF-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B8%89%E3%80%81%E5%8F%8D%E8%A7%84%E8%8C%83%E5%8C%96%E6%8A%80%E6%9C%AF" rel="nofollow">十三、反规范化技术</a></p> 
<p id="%E5%8D%81%E5%9B%9B%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E5%9B%9B%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF" rel="nofollow">十四、大数据技术</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</h2> 
<h3 id="%E4%B8%80%E3%80%81%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%83%8F">一、三级模式两级映像</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/85/ff/08VovMfG_o.png"></p> 
<p>&gt;三级模式结构：数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成。</p> 
<p>①模式（schema）：<br>        模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。它是数据库系统模式结构的中间层，既不涉及数据的物理存储细节，右与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。</p> 
<p>       模式实际上是数据库数据在逻辑上的视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，同意综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。定义模式时不仅要定义数据的逻辑结构，例如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等；而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。</p> 
<p>       数据库管理系统提供模式数据定义语言（模式DDL）来严格地定义模式。</p> 
<p>②外模式（external schema）：<br>        外模式也称子模式（subschema）或用户模式，它是数据库用固话（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p> 
<p>       外模式通常是模式的子集。一个数据库可以有多个外模式。由于它是各个用户的数据视图，如果不同的用户在应用需求、看待数据的方式、对数据保密的要求等方面存在差异，则其外模式描述就是不同的。即使对模式中同一数据，在外模式的结构、类型、长度、保密等级等都可以不同。另一方面，同一外模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式。</p> 
<p>       外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据是不可见的。</p> 
<p>③内模式（internal schema）：<br>        内模式也称存储模式（storage schema），一个数据库只有一个内模式。它是数据物理存储和存储方式的描述，是数据在数据库内部的组织方式。例如，记录的存储方式是堆存储还是按照某个（些）属性值的升（降）序存储，或按照属性值聚簇（cluster）存储；索引按照什么方式组织，是B+树索引还是hash索引；数据是否压缩存储，是否加密；数据的存储记录结构有何规定，如定长结构还是变长结构，一个记录不能跨物理页存储；等等。</p> 
<p>&gt;数据库中的二级映像功能与数据独立性：<br>        数据库系统的三级模式是数据的三个抽象级别，它把数据的具体祖冲之留给数据库管理系统管理，使用户能逻辑地、抽象地处理数据，而不必关心数据在计算机中的具体表示方式和存储方式。为了能够在系统内部实现这三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。</p> 
<p>       正式这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。</p> 
<p>①外模式/模式映像：<br>        模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对应于同一个模式可以有任意多个外模式。对于每一个外模式，数据库系统都会有一个外模式/模式映像，它定义了该外模式和模式之间的对应关系。这些映像定义通常包含在各自外模式的描述中。</p> 
<p>当模式改变时（例如增加新的关系、新的属性、改变属性的数据类型等），由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是根据数据的外模式编写的，从而应用程序不用修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</p> 
<p>②模式/内模式映像：<br> 数据库只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的。该映像定义通常包含在模式描述中。当数据库的存储结构改变时（例如选用了另一种存储结构），由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序之间的物理独立性，简称数据的物理独立性。</p> 
<h3 id="%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B">二、数据库的设计过程</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/01/67/vNY6cXxA_o.png"></p> 
<p>数据库设计通常分为6个阶段：</p> 
<p>①需求分析：分析用户的需求，包括数据、功能和性能需求；</p> 
<p>②概念结构设计：主要采用E-R模型进行设计，包括画E-R图；</p> 
<p>③逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；</p> 
<p>④数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；</p> 
<p>⑤数据库的实施：包括编程、测试和试运行；</p> 
<p>⑥数据库运行与维护：系统的运行与数据库的日常维护。</p> 
<h3 id="%E4%B8%89%E3%80%81ER%E6%A8%A1%E5%9E%8B">三、ER模型</h3> 
<p>ER图分为实体、属性、关系三个核心部分。实体是长方形体现，而属性则是椭圆形，关系为菱形。<br> ER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。</p> 
<p>ER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。</p> 
<p>ER图的关系（relationship）用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。</p> 
<p>ER图中关联关系有三种：</p> 
<p>1对1（1:1） ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。</p> 
<p>1对多（1:N） ：1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。</p> 
<p>多对多（M:N） ：多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。</p> 
<p>&gt;ER模型转换关系模式</p> 
<p>①一对一关系的转换</p> 
<p>转换时选择一个合适的实体，在其中加入另一实体的码。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/83/2c/UgCuahGW_o.jpg"></p> 
<p>②一对多关系的转换</p> 
<p>转换时在“多”的那端实体中加入“一”的那端实体的码。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6d/cb/3xd4QQUv_o.jpg"></p> 
<p>③多对多关系的转换</p> 
<p style="text-align:center;">转换时将“关系”也转换为关系模式，其属性为两端实体的码加上“关系”自身的属性，新的关系模式的码为两端实体的码的组合。<br><img alt="" src="https://images2.imgbox.com/57/d2/61hEszYP_o.jpg"></p> 
<p>例：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d6/70/Yp8EHPUd_o.png"></p> 
<p>答案：C</p> 
<p>解析：三个实体，三个关系模式。m:n关系转换为一个关系模式。共四个关系模式。 </p> 
<h3 id="%C2%A0%E5%9B%9B%E3%80%81%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"> 四、关系代数</h3> 
<p>&gt;并 : R∪S = { t| t∈Rt∈R ∨ t∈St∈S }</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e9/81/bD8m4aXO_o.png"></p> 
<p> &gt;交 : R∩S = { t| t∈Rt∈R ∧ t∉St∉S }</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/bd/55EHRBcq_o.png"></p> 
<p>&gt;差 : R-S = { t| t∈Rt∈R ∨ t∉St∉S }</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d9/f3/vnkXNAPy_o.png"></p> 
<p>&gt;笛卡儿积 :</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4d/e7/aPYH73eZ_o.png"></p> 
<p>&gt;投影（从列的角度进行的运算）<br> 投影的作用是按照指定的顺序从左到右依次取出关系R中相关的属性列，删掉重复元组，<strong>组成新的关系</strong>（即列）。<br> πA(R) = { t[A] | t∈R }</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/00/42/GDeKGGxM_o.jpg"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/67/73/YfreFxEO_o.jpg"></p> 
<p>&gt;选择 (从行的角度进行的运算）<br> 选择运算是根据某些条件挑选出元组（即行）。<br> σF(R) = {t|t∈Rt∈R∧F(t)= ‘真’}<br> F是一个选择条件，即从R中选出满足F为真的行。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c1/b8/3ugXVtXQ_o.jpg"></p> 
<p>  &gt;连接 </p> 
<p>①等值连接</p> 
<p>从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/37/1d/6xhaRUV2_o.png"></p> 
<p>②自然连接<br> 自然连接是一种特殊的等值连接，a.两个关系中进行比较的分量必须是相同的属性组 b.在结果中把重复的属性列去掉。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/51/a1/DaafMjjf_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b2/9d/miPHb3rs_o.png"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/59/59/vR29ng6A_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ad/b1/kjM39LWN_o.png"></p> 
<h3 id="%E4%BA%94%E3%80%81%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA">五、规范化理论</h3> 
<p>（1）函数依赖</p> 
<p>函数依赖：是指关系中属性间（或者说是表中字段间）的对应关系。<br> 定义：设 R 为任一给定关系，如果对于 R 中属性 X 的每一个值，R 中的属性 Y 只有唯一值与之对应，则称 X 函数决定 Y 或称 Y 函数依赖于 X ，记作 X—&gt;Y。其中，X 称为决定因素。<br> 通俗一点，就是给定一个 X 都有唯一的 Y。可以理解为函数 y = f(x); 对于任意的 x 都有唯一的 y ，且 y 的取值由 x 决定。<br> 例如：学生号—&gt;学生姓名，学生年龄等等有关该学生的所有信息<br> 反之，像学生姓名不能决定唯一的学生，因为存在同名的可能，这种情况就不能称作函数依赖。</p> 
<p>类型：完全函数依赖、部分函数依赖、传递函数依赖</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/63/bb/Jod5GHVj_o.jpg"></p> 
<p>（2）候选码的求解</p> 
<p>1、超键</p> 
<p>能唯一标识元组的属性集，其中一个属性可以为作为一个超键，多个属性组合也可以作为一个超键。</p> 
<p>2、候选码</p> 
<p>候选键有两个要求：1.始终能够确保在关系中能唯一标识元组。2.在属性集中找不出真子集能够满足条件。</p> 
<p>其中第一个条件就是超键的标准，所以我们可以把候选键理解为不能再“缩小”的超键。</p> 
<p>3、主键</p> 
<p>在一个关系中的候选键中指定一个来表示，但是主键不能为空值，也不能重复。</p> 
<p>4、外键</p> 
<p>在一个关系A中，有一个属性b不是关系A主键或候选键，但是是另一关系B的主键，这中情况属性b则是关系A中的外键。</p> 
<p>5、求R中候选码的方法</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/19/61/lp5bzQDc_o.png"></p> 
<p>例题：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f7/48/sb1tLdAb_o.jpg"></p> 
<p>（3）范式 </p> 
<p>&gt;1NF：在关系模式中，当且仅当所有域只包含原子值，即每个分量都是不可再分的数据项。</p> 
<p>&gt;2NF：若R∈1NF，且每个非主属性完全函数依赖于任何一个候选码（不存在部分依赖），则R∈2NF。</p> 
<p>&gt;3NF:3NF 在 2NF 的基础之上，消除了非主属性对于主键（复合主键）的传递依赖。</p> 
<p>&gt;BCNF:在3NF基础上，消除主属性对码的部分和传递函数依赖。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/5a/Mw2iyqXS_o.jpg"></p> 
<p>例题：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/67/24/o66QEgca_o.png"></p> 
<p>解析：</p> 
<p>1）C。1NF-&gt;2NF，消除非主属性对码的部分函数依赖。2NF-&gt;3NF，消除非主属性对码的传递函数依赖。</p> 
<p>2）D。</p> 
<p>3）A。由表4月销售额可确定，商品号，日期，数量为销售的属性。</p> 
<p>(4）模式分解</p> 
<p>&gt;保存函数依赖分解：设数据库模式p={R1,R2,...,Rk}是关系模式R的一个分解，F是R上的函数依赖集，p中每个模式Ri上的FD集是Fi。如果{F1，F2，...,Fk}是与F等价的（即相互逻辑蕴涵），那么称分解p保持FD。</p> 
<p>&gt;有损分解不能还原；无损分解可以还原。</p> 
<p>&gt;无损连接分解：指将一个关系模式分解成若干个关系模式后，通过自然连接和投影等运算仍然还能还原到原来的关系模式。</p> 
<p>例1：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e9/37/mkmYoSVP_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c3/f8/JkllPmvc_o.png"></p> 
<p>例2：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/96/01/aaliIJ4I_o.png"></p> 
<p>适用于一分为二的。 </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/de/49/U7sTxDqY_o.png"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/87/20/8avEMB84_o.png"></p> 
<h3 id="%E5%85%AD%E3%80%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6">六、并发控制</h3> 
<p>（1）事务</p> 
<p>事务是一个操作序列，是数据库环境中不可分割的逻辑工作单位。一般一个程序课包含多个事务。</p> 
<p>事务定义的语句：</p> 
<p>①BEGIN TRANSACTION：事务开始。</p> 
<p>②COMMIT：事务提交。</p> 
<p>③ROLLBACK：事务回滚。</p> 
<p>事务的性质：</p> 
<p>①原子性：事务是原子的，要么做，要么不做。</p> 
<p>②一致性：事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性状态。因此，当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。</p> 
<p>③隔离性：事物相互隔离。当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的。 </p> 
<p>④持久性：一旦事务提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。</p> 
<p>（2）并发控制带来的问题</p> 
<p>①丢失修改</p> 
<p>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a8/39/bhhVfz4B_o.png"></p> 
<p></p> 
<p>②不可重复读</p> 
<p><strong>指在一个事务内多次读同一数据</strong>。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/84/93/XZrw8Img_o.png"></p> 
<p>③“脏”读 </p> 
<p>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b9/a0/d7LlBdH7_o.png"></p> 
<p>④幻读</p> 
<p><a href="https://so.csdn.net/so/search?q=%E5%B9%BB%E8%AF%BB&amp;spm=1001.2101.3001.7020" title="幻读">幻读</a>与不可重复读类似。它发生在<strong>一个</strong>事务（T1）读取了<strong>几行数据</strong>，接着<strong>另一个</strong>并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 </p> 
<p>（3）封锁协议</p> 
<p>①X锁:写锁，排它锁(exclusive locks独家排它)<br> T对R加X锁，T只能读取和修改，其他事务不能对R+任何锁。</p> 
<p>②S锁:读锁，共享锁(share locks)<br> T对R+S锁，T只能读，不能改，其他事务可以对R+S锁。</p> 
<p>③一级封锁协议：事务T在修改数据R之前必须加上X锁，直到事务结束的时候才释放，可以<strong>防止丢失修改。</strong></p> 
<p>④二级封锁协议：在一级封锁协议的基础上，加上事务T读取R之前必须先对其加上S锁，读完后立即释放S锁，可以<strong>防止丢失修改和读“脏”数据</strong>。</p> 
<p>⑤三级封锁协议：在一级封锁协议的基础上，加上事务T读取R之前必须先对其加上S锁，直到事务结束才释放S锁，可以<strong>防止丢失修改、读“脏”数据，不可重复读。</strong></p> 
<p>⑥两段锁协议：是指所有的事务必须分两个阶段对数据项加锁和解锁。即<code>事务分两个阶段</code>，第一个阶段是<code>获得封锁</code>。事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是<code>释放封锁</code>，事务可以释放任何数据项上的任何类型的锁，但不能申请。</p> 
<p>（3）死锁</p> 
<p>&gt;死锁：指当两个以上的事务分别请求封锁对方已经封锁的数据，导致了长期等待而无法继续运行下去的现象。</p> 
<p>&gt;死锁产生的原因</p> 
<p>①系统资源的竞争</p> 
<p>只有对不可剥夺资源的竞争（如打印机） 才可能产生死锁，对可剥夺资源的竞争是不会产生死锁的。</p> 
<p>②进程推进顺序非法</p> 
<p>进程在运行过程中，请求和释放资源的顺序不当，同样会导致死锁。如1.1的例子。</p> 
<p>③死锁产生的必要条件： 死锁产生必须同时满足以下四个条件，任意一条不成立，便不会产生死锁：</p> 
<p>1、互斥条件： 各个进程必须互斥的对系统分配的资源（临界资源）进行排他性使用。<br> 2、不可剥夺条件： 进程使用完临界资源之前，不能被其他资源强行夺走，只能自行释放。<br> 3、请求并保持条件：进程已经保持了一个临界资源，但又提出了新的申请临界资源要求，而该临界资源被其他进程占有，此时，请求进程被阻塞，但又保持对自己占有的临界资源保持不放。<br> 4、循环等待条件: 存在一种进程资源的循环等待链条，每个进程已获得的临界资源同时被下一个资源所请求。<br> &gt;死锁的预防</p> 
<p>预防死锁只需要破坏死锁的四个必要条件之一即可：</p> 
<p>①破坏互斥条件</p> 
<p>②破坏不可剥夺条件： 当进程的新资源不可取得时，释放自己已有的资源，待以后需要时重新申请。 但这种方法可能导致迁移阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。</p> 
<p>③破坏请求并保持条件：进程在运行前一次申请完它所需要的全部资源，在它的资源为满足前，不把它投入运行。一旦投入运行，这些资源都归它所有，不能被剥夺。但这种方法系统资源被严重浪费，而且可能导致饥饿现象，由于个别进程长时间占用某个资源，导致等待该资源的进程迟迟无法运行。</p> 
<p>④破坏循环等待条件： 给资源编号，规定每个进程必须按编号递增地顺序请求资源，同类资源一次性申请完。这种方法存在问题是发生作业使用资源地顺序与系统规定的顺序不同，造成系统地浪费，并且给编程带来麻烦。</p> 
<p>这四种方法都有各自的缺陷，我们一般不采用。<br> &gt;死锁的避免</p> 
<p>避免死锁同样属于事先预防地策略，但不是破坏死锁地必要条件，而是在资源动态分配过程中，<strong>防止系统进入不安全状态，以避免发生死锁。</strong></p> 
<h3 id="%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F">七、数据库完整性约束</h3> 
<p> 1、实体完整性约束</p> 
<p>保证关系中的每个元组都是可识别的和惟一的 • 指关系数据库中所有的表都必须有主键，而且表中不允许存在如下记录：无主键值的记录、 主键值相同的记录。<br> 原因：实体必须可区分。</p> 
<p>2、参照完整性约束</p> 
<p>也称为引用完整性。现实世界中的实体之间往往存在着某种联系，在关系模型中，实体以及实体之间的联系都是用关系来表示的，这样就自然存在着关系与关系之间的引用；参照完整性就是描述实体之间的联系的；参照完整性一般是指多个实体或关系之间的关联关系。</p> 
<p>3、用户自定义完整性约束</p> 
<p>也称为域完整性或语义完整性；是针对某一具体应用领域定义的数据约束条件；反映某一具体应用所涉及的数据必须满足应用语义的要求；实际上就是指明关系中属性的取值范围，防止属性的值与应用语义矛盾；关系模型应提供定义和检验这类完整性的机制，以便用统一的系统方法处理它们，而不要由应用程序承担这一功能。</p> 
<p>4、触发器</p> 
<p>触发器（Trigger）<br> 触发器是一种特殊类型的存储过程，不由用户直接调用。创建触发器时会对其进行定义，以便在对特定表或列作特定类型的数据修改时执行。触发器可以查询其他表，而且可以包含复杂的 SQL 语句。 它们主要用于强制服从复杂的业务规则或要求。 例如，您可以根据客户当前的帐户状态，控制是否允许插入新订单。<br> 触发器也可用于强制引用完整性，以便在多个表中添加、更新或删除行时，保留在这些表之间所定义的关系</p> 
<p>优点：触发器可通过数据库中的相关表实现级联更改；通过级联引用完整性约束可以更有效地执行这些更改；触发器可以强制比用 CHECK 约束定义的约束更为复杂的约束。与 CHECK 约束不同，触发器可以引用其它表中的列。例如，触发器可以使用另一个表中的 SELECT 比较插入或更新的数据，以及执行其它操作，如修改数据或显示用户定义错误信息；触发器还可以强制执行业务规则；触发器也可以评估数据修改前后的表状态，并根据其差异采取对策；<br> 缺点：过多的触发器使得数据逻辑变得复杂；数据操作比较隐含，不易进行调整修改；<br> 触发器的功能逐渐在代码逻辑或事务中替代实现，更符合面向对象的思想。<br> 基本操作<br> 注意：本文的SQL 在 MySQL 8.0版本中测试通过</p> 
<p>创建触发器<br><strong>CREATE<br>     [DEFINER = {user | CURRENT_USER}]<br>     TRIGGER trigger_name<br>     trigger_time trigger_event<br>     ON Table_name FOR EACH ROW<br>     trigger_body</strong><br> DEFINER：定义可以激活触发器的用户</p> 
<p>trigger_time：值只有两个，即before和after，表示触发器执行的时间在事件发生前或发生后</p> 
<p>trigger_event：值只有三个，即insert，update和delete，表示触发触发器的事件</p> 
<p>ON Table_name：触发器是关联在那个表上的</p> 
<p>FOR EACH ROW：表示触发器执行的间隔，这里表示每个修改的记录都会触发触发器</p> 
<p>trigger_body：代表触发器所要触发的动作</p> 
<p>查看触发器<br> show triggers;<br> 删除触发器<br> drop trigger [if exists] trigger_name;</p> 
<h3 id="%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8">八、数据库安全</h3> 
<p>1、用户标识和鉴定：最外层的安全保护措施，可以使用用户账号、口令及随机数检验等方式。</p> 
<p>2、存取控制：对用户进行授权，包括操作类型（如查找、插入、删除、修改等动作）和数据对象（主要是数据范围的权限）。</p> 
<p>3、密码存储和传输：对远程终端信息用密码传输。</p> 
<p>4、视图的保护：对视图进行授权。</p> 
<p>5、审计：使用一个专用文件或数据库，自动将用户对数据库的所有操作记录下来。</p> 
<h3 id="%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD">九、数据备份</h3> 
<p>1、冷备份：也称静态备份，是将数据库正常关闭，在停止状态下，将数据库的文件全部备份（复制）下来。</p> 
<p>&gt;优点：</p> 
<p>非常快速的备份方法（只需复制文件）；</p> 
<p>容易归档（简单复制即可）；</p> 
<p>容易恢复到某个时间点上（只需将文件再赋值回去）；</p> 
<p>能与归档方法相结合和，做数据库“最佳状态”的恢复；</p> 
<p>低度维护，高度安全；</p> 
<p>&gt;缺点：</p> 
<p>单独使用时，只能提供到某一时间点上的恢复；</p> 
<p>在实施备份的全过程中，数据库必须要作备份而不能做其他工作；</p> 
<p>若磁盘空间有限只能复制到磁带等其他外部存储设备上，速度会很慢；</p> 
<p>不能按表或用户恢复；</p> 
<p>2、热备份：也称动态备份，是利用备份软件，在数据库正常运行的状态下，将数据库中的数据文件备份出来。</p> 
<p>&gt;优点：</p> 
<p>可在表空间或数据库文件级备份，备份的时间短；</p> 
<p>备份时数据库仍可以使用；</p> 
<p>可达到秒级恢复（恢复到某一时间点上）；</p> 
<p>可对几乎所有数据库实体做恢复；</p> 
<p>恢复是快速的；</p> 
<p>&gt;缺点：</p> 
<p>不能出错，否则后果严重；</p> 
<p>若热备份不成功所得结果不可用于时间点的恢复；</p> 
<p>困难于维护，所以要特别小心，不允许“以失败告终”；</p> 
<p>3、完全备份：备份所有数据；</p> 
<p>      差量备份：仅备份上一次完全备份之后变化的数据；</p> 
<p>      增量备份：备份上一次备份之后变化的数据；</p> 
<p>4、静态海量转储：在系统中无运行事务时进行，每次转存全部数据库。</p> 
<p>      静态增量转储：在系统中无运行事务时进行，每次只转储上一次转储后更新过的数据。</p> 
<p>      动态海量转储：转储期间允许对数据库进行存取或修改，每次转储全部数据库。</p> 
<p>      动态增量转储：转储期间允许对数据库进行存取或修改，每次只转储上一次转储后更新过的数据。</p> 
<p>5、日志文件：事务日志是针对数据库改变所做的记录，它可以记录针对数据库的任何操作，并将结果保存在独立的文件中。</p> 
<h3 id="%E5%8D%81%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%85%E9%9A%9C%E4%B8%8E%E6%81%A2%E5%A4%8D">十、数据库故障与恢复</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/05/d4/M7HNMp2g_o.png"><br>  </p> 
<h3 id="%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93">十一、数据仓库</h3> 
<p>1、企业的需求背景<br>         在数据的处理过程中，当数据量过于庞大，Excel表格无法处理时，需要有一个替代方案，既能查看历史数据，又能提供对应的具有时效性的数据指标给不同业务部门。而数据仓库能满足这些需求。</p> 
<p>2、数据仓库的功能和概念<br> &gt;功能：1）采集数据并存储（含历史数据）。</p> 
<p>        2）对存储的历史数据进行分析，并将数据进行校准和整合的处理，来得出各业务部门所需要的不同需求的指标。</p> 
<p>        3）将处理好的数据分门别类的输出给应用程序（看板）。</p> 
<p>&gt;概念：<br>         数据仓库是<strong>面向主题</strong>、把数据<strong>集成</strong>在一起的、<strong>相对稳定的</strong>、可以<strong>反映历史变化</strong>的数据集合，它能够为管理决策赋能。</p> 
<p>        1）数据仓库是面向主题的，比如金融行业、房地产行业、智慧城市等，他们业务需求各不相同，都会有相匹配的主题的数据仓库建模。</p> 
<p>        2）数据仓库是集成的，他把数据从多个（数据库）等不同的数据源头统一收集到一起管理。</p> 
<p>        3）数据仓库也是相对稳定的，被数据仓库收集并存储下来的数据不能被任意的修改。</p> 
<p>        4）数据仓库能反映数据的历史变化。</p> 
<h3 id="3%E3%80%81%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94%E2%80%8B%E7%BC%96%E8%BE%91%E5%8D%81%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98">3、数据仓库与数据库的对比<br><img alt="" src="https://images2.imgbox.com/11/25/pye4AzgX_o.png"><br> 十二、数据挖掘</h3> 
<p>1、数据挖掘的概念</p> 
<p>   数据挖掘是从大量的、不完全的、有噪声的、模糊的、随机的实际数据中，提取出蕴涵在其中的，人们事先不知道的，但是具有潜在有用性的信息和知识的过程。</p> 
<p>  用来进行数据挖掘的数据源必须是真实的和大量的，并且可能不完整和包括一些干扰数据项。发现的信息和知识必须是用户感兴趣和有用的。一般来讲，数据挖掘的结果并不要求是完全准确的知识，而是发现一种大的趋势。</p> 
<p>  数据挖掘可简单地理解为通过对大量数据的操作，发现有用的知识的过程。它是一门涉及面很广的交叉学科，包括机器学习、数理统计、神经网络、数据库、模式识别、粗糙集、模糊数学等相关技术。</p> 
<p>  2、数据发掘的应用</p> 
<p>  就具体应用而言，数据挖掘是一个利用各种分析工具在海量数据中发现模型和数据间关系的过程，这些模型和关系可以用来做预测。</p> 
<p>  数据挖掘的知识发现，不是要去发现放之四海而皆淮的真理，也不是要去发现崭新的自然科学定理和纯数学公式，更不是什么机器定理证明。实际上，所有发现的知识都是相对的，是有特定前提和约束条件，面向特定领域的，同时还要能够易于被用户理解，最好能用自然语言表达所发现的结果。</p> 
<p>  数据挖掘其实是一类深层次的数据分析方法。数据分析本身已经有很多年的历史，只不过在  过去，数据收集和分析的目的是用于科学研究。另外，由于当时计算能力的限制，对大数据量进行分析的复杂数据分析方法受到了很大限制。</p> 
<h3 id="%E5%8D%81%E4%B8%89%E3%80%81%E5%8F%8D%E8%A7%84%E8%8C%83%E5%8C%96%E6%8A%80%E6%9C%AF">十三、反规范化技术</h3> 
<p>由于规范化会使表不断的拆分，从而导致数据表过多。这样虽然减少了数据冗余，提高了增删改的速度，但会增加查询的工作量。系统需要进行多次连接，才能进行查询操作，使得系统效率大大下降。</p> 
<p>&gt;技术手段</p> 
<p>增加派生性冗余列；增加冗余列；重新组表；分割表</p> 
<h3 id="%E5%8D%81%E5%9B%9B%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF">十四、大数据技术</h3> 
<p>大数据的基本概念：大数据是以容量大、类型多、存取速度快、应用价值高为主要特征的数据集合，正快速发展为对数量巨大、来源分散、格式多样的数据进行采集、存储和关联分析，从中发现新知识、创造新价值、提升新能力的新一代信息技术和服务业态。——《促进大数据发展行动纲要》（2015）</p> 
<p>广泛应用：它产生于互联网领域，并逐步推广到电信、医疗、金融、交通等领域，大数据技术在众多行业中产生了实用价值。</p> 
<p>互联网领域的三大场景：搜索引擎、推荐系统和广告系统。<br> 电信领域：网络管理和优化、市场与精准营销、客户关系管理、企业运营管理、数据商业化。<br> 医疗领域：临床数据对比、药品研发、临床决策支持、实时统计分析、基本药物临床应用分析、远程病人数据分析、人口统计学分析、新农合基金数据分析、就诊行为分析、新的服务模式等。<br> 金融领域： 客户画像应用、精准营销、风险管控、运营优化。<br> 大数据尝试从海量数据中，通过一定的分布式技术手段，挖掘出有价值的信息，最终提供给用户，进而产生实用价值和商业价值。<br> &gt;大数据处理系统应该具有的重要特征：</p> 
<p>高度可扩展性、高性能、高度容错、支持异构环境、较短的分析延迟、易用且开放的接口、较低成本、向下兼容性。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c7316cbcc66335ab8590139f6422333/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python 小例题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c6b3545518dea37ef1d11ce842b0223/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python语法之列表生成式的13个练习题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>