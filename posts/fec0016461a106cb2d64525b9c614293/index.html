<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Boot 系列 - WebSocket 简单使用（建立一个网页聊天室） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Boot 系列 - WebSocket 简单使用（建立一个网页聊天室）" />
<meta property="og:description" content="在实现消息推送的项目中往往需要 WebSocket，以下简单讲解在 Spring boot 中使用 WebSocket。
1、pom.xml 中引入 spring-boot-starter-websocket &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 2、往 spring 容器中注入 ServerEndpointExporter package com.example.mywebsocket.common.websocket; /** * 类功能说明 * * @author * @date 2023/6/1 16:56 */ import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.server.standard.ServerEndpointExporter; /** * WebSocket配置 * &lt;p&gt; * 自动注册使用了@ServerEndpoint注解声明的Websocket endpoint * 要注意，如果使用独立的servlet容器，而不是直接使用springboot的内置容器，就不要注入ServerEndpointExporter，因为它将由容器自己提供和管理。 * * @author sam * @since 2017/9/13 */ @Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 3、Endpoint 具体实现 package com." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fec0016461a106cb2d64525b9c614293/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-05T16:01:53+08:00" />
<meta property="article:modified_time" content="2023-06-05T16:01:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Boot 系列 - WebSocket 简单使用（建立一个网页聊天室）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>在实现消息推送的项目中往往需要 WebSocket，以下简单讲解在 Spring boot 中使用 WebSocket。</p> 
</blockquote> 
<h3>1、pom.xml 中引入 spring-boot-starter-websocket</h3> 
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<h3>2、往 spring 容器中注入 ServerEndpointExporter</h3> 
<pre><code>package com.example.mywebsocket.common.websocket;

/**
 * 类功能说明
 *
 * @author
 * @date 2023/6/1 16:56
 */
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

/**
 * WebSocket配置
 * &lt;p&gt;
 * 自动注册使用了@ServerEndpoint注解声明的Websocket endpoint
 * 要注意，如果使用独立的servlet容器，而不是直接使用springboot的内置容器，就不要注入ServerEndpointExporter，因为它将由容器自己提供和管理。
 *
 * @author sam
 * @since 2017/9/13
 */

@Configuration
public class WebSocketConfig {
    @Bean
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }

}
</code></pre> 
<h3>3、Endpoint 具体实现</h3> 
<pre><code>package com.example.mywebsocket.controller;

/**
 * 类功能说明
 *
 * @author
 * @date 2023/6/1 16:57
 */
import org.springframework.stereotype.Component;

import javax.websocket.*;
import javax.websocket.server.PathParam;
import javax.websocket.server.ServerEndpoint;
import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * ServerEndpoint
 * &lt;p&gt;
 * 使用springboot的唯一区别是要@Component声明下，而使用独立容器是由容器自己管理websocket的，但在springboot中连容器都是spring管理的。
 * &lt;p&gt;
 * 虽然@Component默认是单例模式的，但springboot还是会为每个websocket连接初始化一个bean，所以可以用一个静态set保存起来。
 *
 * @author sam
 * @since 2017/9/13
 */
@ServerEndpoint("/ws/chatRoom/{userName}") //WebSocket客户端建立连接的地址
@Component
public class ChatRoomServerEndpoint {

    /**
     * 存活的session集合（使用线程安全的map保存）
     */
    private static Map&lt;String, Session&gt; livingSessions = new ConcurrentHashMap&lt;&gt;();

    /**
     * 建立连接的回调方法
     *
     * @param session  与客户端的WebSocket连接会话
     * @param userName 用户名，WebSocket支持路径参数
     */
    @OnOpen
    public void onOpen(Session session, @PathParam("userName") String userName) {
        livingSessions.put(session.getId(), session);
        sendMessageToAll(userName + " 加入聊天室");
    }

    /**
     * 收到客户端消息的回调方法
     *
     * @param message 客户端传过来的消息
     * @param session 对应的session
     */
    @OnMessage
    public void onMessage(String message, Session session, @PathParam("userName") String userName) {
        sendMessageToAll(userName + " : " + message);
    }


    /**
     * 发生错误的回调方法
     *
     * @param session
     * @param error
     */
    @OnError
    public void onError(Session session, Throwable error) {
        System.out.println("发生错误");
        error.printStackTrace();
    }

    /**
     * 关闭连接的回调方法
     */
    @OnClose
    public void onClose(Session session, @PathParam("userName") String userName) {
        livingSessions.remove(session.getId());
        sendMessageToAll(userName + " 退出聊天室");
    }


    /**
     * 单独发送消息
     *
     * @param session
     * @param message
     */
    public void sendMessage(Session session, String message) {
        try {
            session.getBasicRemote().sendText(message);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 群发消息
     *
     * @param message
     */
    public void sendMessageToAll(String message) {
        livingSessions.forEach((sessionId, session) -&gt; {
            sendMessage(session, message);
        });
    }

}
</code></pre> 
<h3>4、前端页面实现</h3> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;聊天室&lt;/title&gt;
    &lt;script src="http://code.jquery.com/jquery-1.8.0.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;聊天室&lt;/h1&gt;

&lt;textarea id="chat_content" readonly="readonly" cols="100" rows="9"&gt;

&lt;/textarea&gt;

&lt;br&gt;

用户：&lt;input type="text" id="user_name" value="" name="userName"/&gt;
&lt;button id="btn_join"&gt;加入聊天室&lt;/button&gt;
&lt;button id="btn_exit"&gt;退出聊天室&lt;/button&gt;

&lt;br&gt;

消息：&lt;input type="text" id="send_text" value="" name="sendText"/&gt;
&lt;button id="btn_send"&gt;发送&lt;/button&gt;

&lt;/body&gt;
&lt;/html&gt;

&lt;script&gt;
    $(function () {

        var prefixUrl = 'ws://127.0.0.1:8080/ws/chatRoom/';

        var ws;//WebSocket连接对象

        //判断当前浏览器是否支持WebSocket
        if (!('WebSocket' in window)) {
            alert('Not support websocket');
        }

        $('#btn_join').click(function () {

            var userName = $('#user_name').val();

            //创建WebSocket连接对象
            ws = new WebSocket(prefixUrl + userName);

            //连接成功建立的回调方法
            ws.onopen = function (event) {
                console.log('建立连接')
            }

            //接收到消息的回调方法
            ws.onmessage = function (event) {
                console.log('接收到内容：' + event.data)
                $('#chat_content').append(event.data + '\n')
            }

            //连接发生错误的回调方法
            ws.onerror = function (event) {
                console.log('发生错误')
            }

            //连接关闭的回调方法
            ws.onclose = function (event) {
                console.log('关闭连接')
            }

        })

        //发送消息
        function sendMessage(message) {
            ws.send(message);
        }

        //关闭连接
        function closeWebSocket() {
            ws.close();
        }

        //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
        window.onbeforeunload = function () {
            wx.close();
        }


        //发送消息
        $('#btn_send').click(function () {
            sendMessage($('#send_text').val())
        })

        //点击退出聊天室
        $('#btn_exit').click(function () {
            closeWebSocket();
        })
    })
&lt;/script&gt;
</code></pre> 
<p>demo项目源码如下：</p> 
<p><a href="https://download.csdn.net/download/asd051377305/87853400" title="https://download.csdn.net/download/asd051377305/87853400">https://download.csdn.net/download/asd051377305/87853400</a></p> 
<p></p> 
<h3>5、使用方法：启动application启动类，然后右键在浏览器中打开chat.html，可以打开2个页面，这样就可以双人聊天交流</h3> 
<p><img alt="" height="681" src="https://images2.imgbox.com/23/95/GwCkgdWX_o.png" width="655"></p> 
<p></p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/3d/cf/WVDsDAKL_o.png" width="1200"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3fe03d91ce3f639b0b12fdb2bc72d47/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一文学会如何在Mac上安装brew</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a89b8a5e1a7cda6cdd8b0cfd39adf4b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android-Fragment详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>