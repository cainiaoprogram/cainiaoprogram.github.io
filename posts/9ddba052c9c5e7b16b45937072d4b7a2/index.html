<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unsupervised Learning | 对比学习——13篇论文综述 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unsupervised Learning | 对比学习——13篇论文综述" />
<meta property="og:description" content="文章目录 1. 第一阶段：百花齐放1.1 InstDisc1.2 InvaSpread1.3 CPC1.4 CMC 2. 第二阶段：CV双雄2.1 MoCov12.2 SimCLRv12.3 MoCov22.4 SimCLRv22.5 SWaV2.6 Other 3. 第三阶段：不用负样本3.1 BYOL3.2 SimSiam 4. 第四阶段：Transformer4.1 MoCov34.2 DINO 5. 总结 1. 第一阶段：百花齐放 在第一阶段上，方法模型都没有统一，目标函数，代理任务也没有统一，所以说是一个百花齐放的年代。
1.1 InstDisc paper：Unsupervised Feature Learning via Non-Parametric Instance Discrimination
InstDisc的工作是受到了有监督学习结果的启发，如果把豹子的图片喂给一个已经用有监督学习方式训练好的分类器，会发现它给出来的分类结果排名前几的全部都是跟豹子相关的（比如猎豹和雪豹），而排名靠后的判断往往是和豹子一点关系也没有的类别。
InstDisc认为，让这些图片聚集在一起的原因，并不是这些图片有相似的语义标签信息，而是因为这些图片长得比较像。猎豹雪豹就是长得相似，和其他就是不相似，所以才会导致这里的分类分数。因此，作者将这种有监督的任务发挥到极致，提出了个体判别任务，作者将每一张图片都看作是一个类别，希望模型可以学习图片的表征，从而把各种图片都区分出来。
简单概括InstDisc的思想，通过一个卷积神经网络来将图片进行编码成一个低维特征，然后使得这些特征在特征空间上都尽可能的区分开，因为个体判别认为每张图片都是自成一类，结构图如下所示：
训练这个神经网络的方法是对比学习，所以需要有正样本，需要有负样本。正样本就是图像本身，可能经过数据增强，负样本就是数据集中其余的所有图片，该文章使用一个memroy bank存储这些负样本，imagenet中有128w的数据，意味着memory bank有128w行，因为负样本太多了，如果使用较高的维度表示图片的话，对于负样本的存储代价过高，因此作者让向量维度为128维。
简单的走一下这个前向传播的过程，假设模型的batchsize是256，有256张图片进入CNN网络，将256张图片编码为128维的向量。因为batchsize是256，因此有256个正样本。负样本来自memory bank，每次从memory bank中随机采样出4096个负数样本，利用infoNCE loss去更新CNN的参数。本次更新结束后，会将CNN编码得到的向量替换掉memory bank中原有的存储。就这样循环往复的更新CNN和memory bank，最后让模型收敛，就训练好一个CNN encoder了。
在InstDisc还有其他的细节，比如Proximal Regularizatio，给模型的训练增加了一个约束，从而可以让memory bank里面的特征进行动量式更新，保持一致性。
InstDisc中还有超参数的设定：
τ = 0.07 ；
passive numbers = 4096；
epoch = 200 ；
batch size = 256；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9ddba052c9c5e7b16b45937072d4b7a2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-29T03:18:42+08:00" />
<meta property="article:modified_time" content="2022-01-29T03:18:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unsupervised Learning | 对比学习——13篇论文综述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__2" rel="nofollow">1. 第一阶段：百花齐放</a></li><li><ul><li><a href="#11_InstDisc_7" rel="nofollow">1.1 InstDisc</a></li><li><a href="#12_InvaSpread_31" rel="nofollow">1.2 InvaSpread</a></li><li><a href="#13_CPC_44" rel="nofollow">1.3 CPC</a></li><li><a href="#14_CMC_54" rel="nofollow">1.4 CMC</a></li></ul> 
  </li><li><a href="#2_CV_73" rel="nofollow">2. 第二阶段：CV双雄</a></li><li><ul><li><a href="#21_MoCov1_75" rel="nofollow">2.1 MoCov1</a></li><li><a href="#22_SimCLRv1_86" rel="nofollow">2.2 SimCLRv1</a></li><li><a href="#23_MoCov2_110" rel="nofollow">2.3 MoCov2</a></li><li><a href="#24_SimCLRv2_122" rel="nofollow">2.4 SimCLRv2</a></li><li><a href="#25_SWaV_142" rel="nofollow">2.5 SWaV</a></li><li><a href="#26_Other_172" rel="nofollow">2.6 Other</a></li></ul> 
  </li><li><a href="#3__184" rel="nofollow">3. 第三阶段：不用负样本</a></li><li><ul><li><a href="#31_BYOL_189" rel="nofollow">3.1 BYOL</a></li><li><a href="#32_SimSiam_237" rel="nofollow">3.2 SimSiam</a></li></ul> 
  </li><li><a href="#4_Transformer_283" rel="nofollow">4. 第四阶段：Transformer</a></li><li><ul><li><a href="#41_MoCov3_288" rel="nofollow">4.1 MoCov3</a></li><li><a href="#42_DINO_328" rel="nofollow">4.2 DINO</a></li></ul> 
  </li><li><a href="#5__374" rel="nofollow">5. 总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__2"></a>1. 第一阶段：百花齐放</h2> 
<hr> 
<blockquote> 
 <p>在第一阶段上，方法模型都没有统一，目标函数，代理任务也没有统一，所以说是一个百花齐放的年代。</p> 
</blockquote> 
<h3><a id="11_InstDisc_7"></a>1.1 InstDisc</h3> 
<p>paper：<a href="https://arxiv.org/pdf/1805.01978.pdf" rel="nofollow">Unsupervised Feature Learning via Non-Parametric Instance Discrimination</a></p> 
<p>InstDisc的工作是受到了有监督学习结果的启发，如果把豹子的图片喂给一个已经用有监督学习方式训练好的分类器，会发现它给出来的分类结果排名前几的全部都是跟豹子相关的（比如猎豹和雪豹），而排名靠后的判断往往是和豹子一点关系也没有的类别。<br> <img src="https://images2.imgbox.com/bd/a1/scw14C7r_o.png" alt="在这里插入图片描述"><br> InstDisc认为，让这些图片聚集在一起的原因，并不是这些图片有相似的语义标签信息，而是因为这些图片长得比较像。猎豹雪豹就是长得相似，和其他就是不相似，所以才会导致这里的分类分数。因此，作者将这种有监督的任务发挥到极致，提出了个体判别任务，作者将每一张图片都看作是一个类别，希望模型可以学习图片的表征，从而把各种图片都区分出来。</p> 
<p><strong>简单概括InstDisc的思想，通过一个卷积神经网络来将图片进行编码成一个低维特征，然后使得这些特征在特征空间上都尽可能的区分开，因为个体判别认为每张图片都是自成一类</strong>，结构图如下所示：<br> <img src="https://images2.imgbox.com/dd/ae/sHj7rahR_o.png" alt="在这里插入图片描述"><br> 训练这个神经网络的方法是对比学习，所以需要有正样本，需要有负样本。正样本就是图像本身，可能经过数据增强，负样本就是数据集中其余的所有图片，该文章使用一个memroy bank存储这些负样本，imagenet中有128w的数据，意味着memory bank有128w行，因为负样本太多了，如果使用较高的维度表示图片的话，对于负样本的存储代价过高，因此作者让向量维度为128维。</p> 
<p>简单的走一下这个前向传播的过程，假设模型的batchsize是256，有256张图片进入CNN网络，将256张图片编码为128维的向量。因为batchsize是256，因此有256个正样本。负样本来自memory bank，每次从memory bank中随机采样出4096个负数样本，利用infoNCE loss去更新CNN的参数。本次更新结束后，会将CNN编码得到的向量替换掉memory bank中原有的存储。就这样循环往复的更新CNN和memory bank，最后让模型收敛，就训练好一个CNN encoder了。</p> 
<p>在InstDisc还有其他的细节，比如<code>Proximal Regularizatio</code>，给模型的训练增加了一个约束，从而可以让memory bank里面的特征进行动量式更新，保持一致性。<br> <img src="https://images2.imgbox.com/d0/bb/fhlPaczI_o.png" alt="在这里插入图片描述"><br> InstDisc中还有超参数的设定：</p> 
<blockquote> 
 <p>τ = 0.07 ；<br> passive numbers = 4096；<br> epoch = 200 ；<br> batch size = 256；<br> orgin learning rate = 0.03<img src="https://images2.imgbox.com/dc/a4/OJssezvD_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>InstDise提出了个体判别这个代理任务，而且用这个代理任务和nce loss去做对比学习取得了不错的无监督表征学习的结果，同时提出了用别的结构存储这些大量的负样本，以及如何进行动量的更新，为后续的对比学习的工作产生了推进的作用。</p> 
<h3><a id="12_InvaSpread_31"></a>1.2 InvaSpread</h3> 
<p>paper：<a href="https://arxiv.org/pdf/1904.03436.pdf" rel="nofollow">Unsupervised Embedding Learning via Invariant and Spreading Instance Feature</a></p> 
<p>InvaSpread可以理解为是SimeCLR的前身。InvaSpread并没有用额外的数据结构存储大量的负样本，他就是用mini batch中的数据作为负样本，而且使用一个编码器进行端到端的学习。</p> 
<p>InvaSpread的想法就是最基本的对比学习，同样的图片通过编码器其特征应该比较类似，而不同的图片通过编码器的特征就应该不类似。对于相似的图片或者物体，其特征应该保持不变形<code>Invariant</code> ，而对于不相似的图片或者是物体其特征应该分散开<code>Spreading</code>。<br> <img src="https://images2.imgbox.com/3b/b3/My9CUyJ5_o.png" alt="在这里插入图片描述"><br> InvaSpread的代理任务也是<code>Instance Discrimination</code>，这里着重讲一下该文章中正例和负例的选择。该文章设置的batchsize是256。首先利用数据增广，将每个图片增广一次，也就是将256张图片变为512个图片了。之后将512张图片通过CNN编码为向量，并使用一个全连接层将数据的维度降低。之后将<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          i 
         
        
       
      
        x_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和其经过增广后的图片<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           x 
          
         
           ~ 
          
         
        
          i 
         
        
       
      
        \widetilde{x}_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.69056em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span class="svg-align" style="width: calc(100% - 0.05556em); margin-left: 0.05556em; top: -3.43056em;"><span class="pstrut" style="height: 3em;"></span><span class="" style="height: 0.26em;"> 
            <svg width="100%" height="0.26em" viewbox="0 0 600 260" preserveaspectratio="none"> 
             <path d="M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z"></path> 
            </svg></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>作为正样本，其余的<code>512-2</code>张图片都认为是负样本。所以总计有<code>256</code>个正例，有<code>2×（256-1）</code>张负例。之后的<strong>在特征空间中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           x 
          
         
           i 
          
         
        
       
         x_{i} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            x 
           
          
            ~ 
           
          
         
           i 
          
         
        
       
         \widetilde{x}_{i} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.69056em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span class="svg-align" style="width: calc(100% - 0.05556em); margin-left: 0.05556em; top: -3.43056em;"><span class="pstrut" style="height: 3em;"></span><span class="" style="height: 0.26em;"> 
             <svg width="100%" height="0.26em" viewbox="0 0 600 260" preserveaspectratio="none"> 
              <path d="M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z"></path> 
             </svg></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的距离应该尽可能相近，而<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           x 
          
         
           i 
          
         
        
       
         x_{i} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            x 
           
          
            ~ 
           
          
         
           j 
          
         
        
       
         \widetilde{x}_{j} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.976668em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.69056em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span class="svg-align" style="width: calc(100% - 0.05556em); margin-left: 0.05556em; top: -3.43056em;"><span class="pstrut" style="height: 3em;"></span><span class="" style="height: 0.26em;"> 
             <svg width="100%" height="0.26em" viewbox="0 0 600 260" preserveaspectratio="none"> 
              <path d="M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z"></path> 
             </svg></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的距离应该尽可能相远。</strong><br> <img src="https://images2.imgbox.com/0f/59/epFREkQH_o.png" alt="在这里插入图片描述"><br> 该文章的思路和SimCLR的思路差不多，都设计用batch中的数据作为正例和负例，但是该文章取得的效果没有SimCLR的效果那般炸裂。主要是因为本文所选取的字典长度不够大，batchsize仅为256，本文也没有设计SimCLR那种投影函数和多样的数据增广方法，因此本文取得的效果不如SimCLR那么好。</p> 
<p>以上两篇工作都是使用个体判别<code>Instance Discrimination</code>作为代理任务的，接下来介绍的这篇文章是利用其他代理任务进行对比学习的。</p> 
<h3><a id="13_CPC_44"></a>1.3 CPC</h3> 
<p>paper：<a href="https://arxiv.org/pdf/1807.03748.pdf" rel="nofollow">Representation Learning with Contrastive Predictive Coding</a></p> 
<p>一般机器学习分为生成式模型与判别式模型，个体判别<code>Instance Discrimination</code>属于判别式的范畴，那么肯定也会出现生成式的代理任务，这里的CPC就是属于生成式的代理任务。</p> 
<p>CPC是一个很通用的结构，不光可以处理音频，图片，文字，还可以在强化学习里使用。其主要的想法是，有一个持续的序列，把之前时刻的输入喂给编码器，返回的特征再喂给一个自回归模型<code>gar</code>（<code>auto-regressive</code>，一般的自回归模型是RNN或LSTM），然后得到一个<code>context representation</code>，这是一个代表上下文的特征表示。如果<code>context representation</code>足够好，那么其应该可以做出一些合理的预测，所以可以用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          c 
         
        
          t 
         
        
       
      
        c_{t} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>预测未来时刻的特征输出<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
         
         
           t 
          
         
           + 
          
         
           i 
          
         
        
       
      
        z_{t+i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.638891em; vertical-align: -0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span></span></span></span></span>.<br> <img src="https://images2.imgbox.com/f4/a8/XNMedUVg_o.png" alt="在这里插入图片描述"><br> 对比学习需要正负样本的对比，所以在CPC中，这里的正样本就是通过编码器之后得到未来时刻的特征输出<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
         
         
           t 
          
         
           + 
          
         
           i 
          
         
        
       
      
        z_{t+i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.638891em; vertical-align: -0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，将其他的序列作为负例，进行对比学习的训练。</p> 
<p>CPC的思想比较朴实，把序列输入换成一个句子，就可以用前面的单词预测后面单词的特征输出。如果把序列换成一个图片的patch，那么就可以用上半部分的图片特征去预测后半部分的图片特征。</p> 
<h3><a id="14_CMC_54"></a>1.4 CMC</h3> 
<p>paper：<a href="https://arxiv.org/pdf/1906.05849.pdf" rel="nofollow">Contrastive Multiview Coding</a></p> 
<p>CMC提出一个想法，人通过很多的传感器来观察这个世界（比如眼睛或者是耳朵），来给大脑提供不同的信号，然后每一个视角都是带有噪声的，而且有可能是不完整的。但是最重要的那些信息，其实是在这些信息中共享的。比如说基础的物理定律，或者几何形状，或者是它们的语义信息，这些都是共享的。比如一只狗即可以被看见，也可以被听见，也可以被感受到。</p> 
<p>基于这个现象，CMC想学一个非常强大的特征，其具有视角的不变性（不管是看见了一只狗，还是听到了狗叫声，都能判断出这是个狗）。所以，CMC的工作目的就是去增大这个互信息，就是所有视角之间的互信息。如果能学到一种特征，能够抓住所有视角下的这个关键的因素，那么这个特征就比较好。</p> 
<p>CMC使用的数据集是NYU RGBD数据集，该数据集包含一张图片的四种view数据增强结果（包含原始的图像，以及这个图像对应的深度信息，SwAV ace normal，语义分割）。虽然这些不同的输入view来自于不同的传感器，或者说是不同的模态，但是这些所有的输入其实对应的都是一整的图片，一个东西，那么它们就应该互为正样本，相互配对。而这些相互配对的视角在特征空间中应该尽可能的相近，而与其他的视角尽可能的远离。<br> <img src="https://images2.imgbox.com/ec/aa/k4e92nGF_o.png" alt="在这里插入图片描述"><br> CMC定义正负样本的方式：将不同的view作为正例，将其他图片以及其他图片的views作为负例子，进行训练。</p> 
<p>CMC的成功，让我们认识到对比学习可以如此的灵活，Open AI团队的工作CLIP将图片-文本对作为输入，将互相匹配的图像-文本对作为正例，将不匹配的作为负例。同时CMC的原班人马利用对比学习做知识蒸馏，他们认为相同的样本在不同的编码器下得到的结果应该尽可能的相似，因此设计的teacher和student编码得到的相同图片的向量互为正例，不同图片得到的输出作为负例，利用对比学习的思路进行知识蒸馏。</p> 
<p>但是问题在于multi view的工作可能需要多个编码器进行编码，训练代价可能有点高。比如CLIP，就是用大型的语言编码器BERT对语言模型进行编码，用视觉模型VIT对视觉信息进行编码。</p> 
<p><strong>小结：</strong></p> 
<p>第一阶段介绍以上四篇工作，可以看到以上的工作代理任务不尽相同，其中有个体判别，有预测未来，还有多视角多模态。使用的目标函数也不尽相同，有NCE，infoNCE以及其变体。使用的模型也可以是不同的，比如InvaSpread使用的是相同的编码器对key和query进行编码，CMC对key和query使用的是不同的编码，是百花齐放的。</p> 
<h2><a id="2_CV_73"></a>2. 第二阶段：CV双雄</h2> 
<hr> 
<h3><a id="21_MoCov1_75"></a>2.1 MoCov1</h3> 
<p>paper：<a href="https://arxiv.org/pdf/1911.05722.pdf" rel="nofollow">Momentum Contrast for Unsupervised Visual Representation Learning</a></p> 
<p>主要贡献就是把之前对比学习的一些方法归纳为一个字典查询问题。提出了一个队列，一个动量编码器，从而形成一个又大又一致的字典，帮助更好的进行对比学习。<br> <img src="https://images2.imgbox.com/13/88/i7oDsnYp_o.png" alt="在这里插入图片描述"><br> MOCO和InstDise有很多类似的地方，从模型的角度上都是用了残差网络，基线模型用的都是Res50，模型都是一样的。每个图片的特征维度都是128维，也对所有的特征作了L2归一化。至于目标函数，MoCo采用的是info NCE，InstDisc采用的是NCE，但是算loss的温度都是用了0.07。MOCO训练的学习率，epoch数，以及数据增强都是借鉴了InstDisc。但是MOCO对InstDise的改进可以说是简单又有效，其提出用队列替换memory bank以及提出了动量更新的方式，对效果有显著的提升，同时对后续工作也产生了深远的影响。</p> 
<p>MoCo与之前工作的对比图：<br> <img src="https://images2.imgbox.com/38/3d/NczClLcM_o.png" alt="在这里插入图片描述"><br> 其他有关MoCo的详细介绍，见：<a href="https://blog.csdn.net/weixin_44751294/article/details/122720525">Unsupervised Learning | 对比学习——MoCo</a></p> 
<h3><a id="22_SimCLRv1_86"></a>2.2 SimCLRv1</h3> 
<p>paper：<a href="https://arxiv.org/pdf/2002.05709.pdf" rel="nofollow">A Simple Framework for Contrastive Learning of Visual Representations<br> </a></p> 
<p>SimCLR方法比较简单，概念上也更容易理解，方法上也很容易解释，但是缺点就是<code>batch size</code>太大，一般人不好上手。</p> 
<p>SimCLR结构如下图所示：<br> <img src="https://images2.imgbox.com/77/c2/cs8pbTHt_o.png" alt="在这里插入图片描述"><br> 假如有一个minibatch的图片，对整个minibatch的所有图片做数据增强，对图片<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>做不同的数据增强就会得到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          i 
         
        
       
      
        x_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          j 
         
        
       
      
        x_{j} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.716668em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 。同一个图片延申得到的两个图片就是正样本，比如batchsize是n的话，那么正样本就是n，这个batchsize剩下的所有的样本以及其经过数据增强后得到的都是负样本，也就是2（n-1）。有了正负样本之后，对其进行编码，通过一个编码器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         ⋅ 
        
       
         ) 
        
       
      
        f(·) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mclose">)</span></span></span></span></span>得到正负样本的编码结果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         h 
        
       
      
        h 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span></span></span></span></span> 。SimCLR的创新点就是在得到数据的编码之后在后面加了一个编码层<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         ( 
        
       
         ⋅ 
        
       
         ) 
        
       
      
        g(·) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mclose">)</span></span></span></span></span>函数，就是一个MLP层，得到较低维度的特征<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          i 
         
        
       
      
        z_{i} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          j 
         
        
       
      
        z_{j} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.716668em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span> ，用其进行对比学习，拉近正例之间的距离，拉远负例之间的距离。但是需要注意的一点就是投影函数仅仅在训练的时候才使用，在测试的时候是不使用的，测试的时候仅仅使用编码器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         ⋅ 
        
       
         ) 
        
       
      
        f(·) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mclose">)</span></span></span></span></span> 。加上投影函数的目的也仅仅是想让模型训练的更好。</p> 
<p>可以发现，其实SimCLR与之前的InvaSpread是比较相似的，不同之处在于：<br> 1）SimCLR使用了更多的数据增强<br> 2）加入了投影的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         ( 
        
       
         ⋅ 
        
       
         ) 
        
       
      
        g(·) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mclose">)</span></span></span></span></span>函数<br> 3）就是SimCLR用了更大的batchsize，且训练的时间更久</p> 
<p>SimCLR使用了以下的数据增强方式：<br> <img src="https://images2.imgbox.com/03/07/UwOA8tZG_o.png" alt="在这里插入图片描述"><br> 不同数据增强方式之间的消融实验：<br> <img src="https://images2.imgbox.com/eb/78/0oteHpn3_o.png" alt="在这里插入图片描述"><br> 这个消融实验证明随机的裁剪以及随机的色彩变换的必要性，其他的数据增强最后都只是锦上添花可有可无。</p> 
<p>此外，SimCLR里还对这个投影层做了一些实验，这里的Linear表示不带relu；Non-linear表示带relu；None表示没有Projection。可以看到使用非线性变化的效果是十分显著的，同时对于对比学习维度变化，似乎并不会对效果产生影响，所以一般128维就足够了。<br> <img src="https://images2.imgbox.com/4e/09/WqKpSYWh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23_MoCov2_110"></a>2.3 MoCov2</h3> 
<p>paper：<a href="https://arxiv.org/pdf/2003.04297.pdf" rel="nofollow">Improved Baselines with Momentum Contrastive Learning</a></p> 
<p>MoCov2其实是一篇只有两页的技术报告，严格上说并不是一篇论文，但是信息量还是比较大的。</p> 
<p>MOCO v2相当于是把SimCLR中值得借鉴的地方拿来借鉴，比如其中MLP的投影层，更多的数据增强方式，cosine learning rate schedule，以及更多的迭代epoch。其中supervised是backbone在有监督训练中进行训练的结果。在加入了SimCLR的一些改进点后，确实取得了模型性能的进步。<br> <img src="https://images2.imgbox.com/17/98/OiGRKQ4x_o.png" alt="在这里插入图片描述"><br> paper对比了MOCO v2和SimCLR在相同的epoch和batch下的效果对比，在较小的batch和epoch下，MOCO v2取得了较好的效果，在较大的batch和epoch下，也取得了较好的效果。也就是说，MoCo可以更好的利用数据，可以在更短的时间内取得更好的结果。<br> <img src="https://images2.imgbox.com/a8/69/pNMBA7yo_o.png" alt="在这里插入图片描述"><br> paper又将MOCO v2和SimCLR的算力作对比，再一次强调MoCo的优越性。SimCLR在batch较少的情况下无法发挥效果，在batch多的情况下才可以出效果，但是算力要求太高了。所以MOCO是一个对于计算资源要求不是很高，但是却很有效的模型。<br> <img src="https://images2.imgbox.com/23/57/oBwV9SjH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24_SimCLRv2_122"></a>2.4 SimCLRv2</h3> 
<p>paper：<a href="https://arxiv.org/pdf/2006.10029.pdf" rel="nofollow">Big Self-Supervised Models are Strong Semi-Supervised Learners</a></p> 
<p>SimCLRv2只是paper中很小的一部分，只是说了一下怎么从v1变到v2，只是一个模型上的改进，而其他大部分的内容都是在讲如何去做这个半监督的学习。</p> 
<p>SimCLR v2文章提出了一套用自监督网络作半监督训练的流程，该流程是用大网络（SimCLR v2）作自监督的预训练，预训练部分是没有特定下游任务的，因此不具备下游任务知识；之后使用少部分有标注的数据对模型进行微调，从而让模型学习下游任务的特定知识；让微调的模型作为teacher模型，为更多的数据生成伪标签，从而实现自学习。<br> <img src="https://images2.imgbox.com/cf/89/5Feayw6c_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>ps：这里的半监督训练流程借鉴了<code>noisy student self-distillation</code>的工作，核心思想是指用标签的数据训练一个模型，然后用这个模型去预测一个大的没有标号的数据集，然后把那些置信度比较高的数据拿出来，跟之前的有标号的数据集一起拼成一个更大的数据。然后利用这个扩充的数据集重新再训练出一个模型出来。这样等价于数据集变大了，然后可以重复做很多次。</p> 
 <p>这里的关键点是需要加噪声进去，不然的话如果之前的模型预测一个样本预测错了，但是其置信度又比较高，那么这个错误的监督信号就会进去到训练样本中，使得下一次训练的时候可以在这个错误上更加的错误。而如果加入大量的噪声，比如数据增强，甚至是把标签做一些改变的话，模型就会可以比较好的处理这些不正确的标签。</p> 
</blockquote> 
<p>SimCLR v1是升级到SimCLR v2的流程：<br> 1）如果使用更大的模型，则无监督训练就会训练的更好，所以SimCLR v2使用了ResNet-152并且使用了selective kernels（也就是SE网络），从而让骨干网络更加强悍<br> 2）原来的非线性投影层是十分有效的，那么更深的非线性层会不会更加有效呢？于是作者尝试使用2层，3层，最后发现2层的效果是最好的<br> 3）作者尝试了MOCO的动量编码器，发现效果是有提升的，但是提升的不是非常显著，大概是一个百分点，原因是SimCLR v2已经有很大的batchsize了，所以不需要太多的动量以及队列的负样本了</p> 
<p>总的来说，SimCLRv2相比SimCLRv1就是用了更大的模型，加深了projection head，最后用了半监督编码器。</p> 
<h3><a id="25_SWaV_142"></a>2.5 SWaV</h3> 
<p>paper：<a href="https://arxiv.org/pdf/2006.09882.pdf" rel="nofollow">Unsupervised Learning of Visual Features by Contrasting Cluster Assignments</a></p> 
<p>SWaV（Swap Assignment Views）的想法是，给定同样的一张图片，如果去生成不同的视角（views），希望可以用一个视角得到的特征去预测另外一个视角的得到的特征，因为所有的这些视角的特征按道理来说都应该是非常接近的。然后SWaV将对比学习和之前的聚类的方法合在的一起，这样做也不是偶然，因为聚类也是无监督特征表示学习的方法，而且它也希望相似的物体都聚集在一个聚类中心附近，不相似的物体推到别的聚类中心。</p> 
<p>SWaV如何与聚类相联系呢？下面是对比学习与SWaV的区别：<br> <img src="https://images2.imgbox.com/b9/b0/KU6Wkepq_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>Contrastive instance learning<br> 以往的基于对比学习的方法都是将一个实例<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           x 
          
         
        
          x 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>通过两次数据增强变为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            x 
           
          
            1 
           
          
         
        
          x_{1} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            x 
           
          
            2 
           
          
         
        
          x_{2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，之后利用编码器对其进行编码，从而得到嵌入向量<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            1 
           
          
         
        
          z_{1} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            2 
           
          
         
        
          z_{2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，之后使用对比学习的loss更新这个encoder。</p> </li><li> <p>SwAV<br> 即使以往的工作是非常有效并且简洁的，但是因为负样本太多了，从而造成资源的浪费，即使是MOCO这样用近似的方式用6w个负样本，但是总共还是有128w个负样本的，6w个负样本只是一种近视。所以SwAV的作者去想，能不能不做近似呢？可不可以使用先验信息，不去和大量的负样本对比，而是和一些更加简洁的东西去比呢？所以SwAV的作者想，可以和聚类的中心进行对比。这个聚类中心就是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           C 
          
         
        
          C 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span></span></span></span></span> ，维度是3000×向量为度，3000表示聚类中心的数量。<br> 这里的聚类中心<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           C 
          
         
        
          C 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span></span></span></span></span>就是<code>Prototypes</code>，作为一个矩阵维度是dxk（d是特征的维度128维，k是聚类中心的数目3000）<br> SwAV前向过程依旧是一个实例<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           x 
          
         
        
          x 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>通过两次数据增强变为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            x 
           
          
            1 
           
          
         
        
          x_{1} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            x 
           
          
            2 
           
          
         
        
          x_{2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，之后利用编码器对其进行编码，从而得到嵌入向量<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            1 
           
          
         
        
          z_{1} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            2 
           
          
         
        
          z_{2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。但是有了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            1 
           
          
         
        
          z_{1} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            2 
           
          
         
        
          z_{2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>之后，并不是直接在特征上去做对比学习的loss，而且让<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            1 
           
          
         
        
          z_{1} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            2 
           
          
         
        
          z_{2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和聚类中心<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           C 
          
         
        
          C 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span></span></span></span></span>进行聚类，从而得到<code>ground truth</code>的标签<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            Q 
           
          
            1 
           
          
         
        
          Q_{1} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            Q 
           
          
            2 
           
          
         
        
          Q_{2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。如果说两个特征比较相似或者是含有等量的信息，按道理来说应该是可以相互预测的。也就是说，用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            1 
           
          
         
        
          z_{1} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           C 
          
         
        
          C 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span></span></span></span></span>作点乘按道理是可以去预测<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            Q 
           
          
            2 
           
          
         
        
          Q_{2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的，反过来用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            2 
           
          
         
        
          z_{2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           C 
          
         
        
          C 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span></span></span></span></span>作点乘按道理是可以去预测<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            Q 
           
          
            1 
           
          
         
        
          Q_{1} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的，SwAV通过这种换位交叉预测的方法来对模型进行训练更新参数。</p> </li></ul> 
<p>SwAV的优势在于：<br> 1）如果是和负例进行对比的话，需要和成千上万个负例进行对比，即使是MOCO中6w个负例，也只是一个近似的值，但是聚类的话，就仅仅需要和三千个聚类核心即可。<br> 2）这些聚类中心是有含义的，而如果像之前一样用负样本进行对比学习的话，有的负样本不均衡，有的还可能是正样本，不如聚类中心有效。</p> 
<p>SwAV的性能优势不仅仅是与聚类的方法融合了在一起，其还有另外的一个性能提升点<code>Multi-crop</code>：<br> <img src="https://images2.imgbox.com/ce/e3/HfrgzeLR_o.png" alt="在这里插入图片描述"></p> 
<ul><li>Multi-crop<br> 以往的对比学习方法都是在一张256×256的图片上用两个224×224的crop求两个正样本，但是因为crop过大了，所选取的crop都是基于全局特征的，所以可能忽视了局部特征。所以SwAV使用了一种multi-crop的思路进行操作，即选择了两个160×160的crop去注意全局特征，选择四个96×96的crop去注意局部特征。这样在计算量变化不大的情况下，可以获取更多的正样本，也可以同时注意了全局特征与局部的特征。</li></ul> 
<p>此外，<code>Multi-crop</code>对于其他的技术同样有用，如下图所示：<br> <img src="https://images2.imgbox.com/9e/f2/TVAaRhro_o.png" alt="在这里插入图片描述"><br> 但是从图也可以看到，用纯聚类的方法或者说聚类和对比学习的方法结合在一起其实也并没有什么优势，真正提点的是<code>Multi-crop</code>这个技术。而且<code>Multi-crop</code>比较朴实，就是同时关注了全局特征与局部特征，想起Focal Transformer的工作就是提出了要同时结合粗粒度与细粒度的特征，所以看得出来结合全局与局部特征是比较有效果的。</p> 
<p>有关Focal Transformer的笔记，见：<a href="https://blog.csdn.net/weixin_44751294/article/details/121055664">论文阅读笔记 | Transformer系列——Focal Transformer</a></p> 
<h3><a id="26_Other_172"></a>2.6 Other</h3> 
<ul><li> <p>CPCv2<br> 简单说一下，CPCv2也融合了比较多的技巧。用了更大的模型，用了更大的图片块，做了更多方向上的预测任务，把BatchNorm换成了LayerNorm，还使用了更多的数据增强。CPCv2在这些工作之后，把CPCv1从40+提高到70+的准确率。</p> </li><li> <p>InfoMin<br> InfoMin是CMC的作者做的一个分析型的延伸性工作，paper叫《what makes for good views for contrastice learning》，选一个什么样的视角才能对对比学习最好。主要是提出了一个InfoMin的原则，最小化互信息<code>minimi mutual information</code>。<br> InfoMin的本意是不能一味的最大化这个互信息，而是要不多不少刚刚好，去选择合适的数据增强与合适的对比学习的视角。</p> </li></ul> 
<p><strong>小结</strong>：</p> 
<p>到了第二阶段，其实很多细节都趋于统一了，比如目标函数都是使用infoNCE，模型都归一为用一个encoder+projection head了，大家都采用了一个更强的数据增强，都想用一个动量编码器，也都尝试训练更久，最后在ImageNet上的准确度也逐渐逼近于有监督的基线模型。</p> 
<h2><a id="3__184"></a>3. 第三阶段：不用负样本</h2> 
<hr> 
<blockquote> 
 <p>其实SwAV已经是不用负样本了，但是他还是和一个聚类的中心这样明确的对比对象进行比较，一下介绍的BYOL和SimSiam就是正样本自己在和自己玩，已经没有正样本，或者聚类中心这样明确的对比对象了。</p> 
</blockquote> 
<h3><a id="31_BYOL_189"></a>3.1 BYOL</h3> 
<p>paper：<a href="https://arxiv.org/pdf/2006.07733.pdf" rel="nofollow">Bootstrap Your Own Latent A New Approach to Self-Supervised Learning</a></p> 
<ul><li><strong>BYOL的神奇之处</strong></li></ul> 
<p>在对比学习中的负样本是一个约束，如果在算目标函数的时候只有一个正样本，这时候就只有一个目的，就是让相似的物体他们的特征也尽可能的相似。这时候就可能会有一个明显的捷径解，如果一个模型无论给什么样的输入，他都返回相同的输出，这样出来的所有特征，都是一模一样的，这样去计算对比学习的loss就全为0，模型这样躺平是学习不到实例的特征的，是无效的。</p> 
<p>因此需要添加了负样本对模型造成一个约束，这样如果模型躺平直接输出输入的话，对于正样本的loss为0，但是对于负样本来说loss就无穷大，这样子模型才会学习如何权衡让正负样本的loss都往下降，达到一个最优解。所以负样本在模型中是一个必须的东西，可以防止模型躺平，学到这个捷径解。</p> 
<p>BYOL的神奇之处在于模型没有使用负样本，仅仅是模型自己和自己去学，但是也实现了很不错的效果。</p> 
<ul><li><strong>BYOL的前向过程</strong><br> <img src="https://images2.imgbox.com/4c/9d/xsWiR07Z_o.png" alt="在这里插入图片描述"></li></ul> 
<p>首先有一个<code>mini-batch</code>的输入<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>，经过两次不同的数据增强之后得到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         v 
        
       
      
        v 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          v 
         
         
          
         
           ′ 
          
         
        
       
      
        v^{'} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.94248em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.94248em;"><span class="" style="top: -2.94248em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class=""></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.827829em;"><span class="" style="top: -2.931em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，然后通过编码器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
        
          θ 
         
        
       
      
        f_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
        
          ξ 
         
        
       
      
        f_{\xi} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.980548em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.04601em;">ξ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>分别得到特征<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          y 
         
        
          θ 
         
        
       
      
        y_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          y 
         
        
          ξ 
         
         
          
         
           ′ 
          
         
        
       
      
        y_{\xi}^{'} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.3617em; vertical-align: -0.419216em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.94248em;"><span class="" style="top: -2.41689em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.04601em;">ξ</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class=""></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.827829em;"><span class="" style="top: -2.931em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.419216em;"><span class=""></span></span></span></span></span></span></span></span></span></span>（如果是ResNet50，就是得到了一个2048维的特征）。这里的编码器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
        
          θ 
         
        
       
      
        f_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
        
          ξ 
         
        
       
      
        f_{\xi} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.980548em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.04601em;">ξ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>使用的相同的网络架构，但是其参数是不同的，也就是分别独立，没有共享参数，只是架构相同而已。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
        
          θ 
         
        
       
      
        f_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是随着梯度更新而更新的，而<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
        
          ξ 
         
        
       
      
        f_{\xi} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.980548em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.04601em;">ξ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>与MoCo一样，是用<code>moving average</code>的这种形式去更新的，其实也就是使用了动量编码器。</p> 
<p>接下来与SimCLR一样，用了<code>projection head</code>编码器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          g 
         
        
          θ 
         
        
       
      
        g_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          g 
         
        
          ξ 
         
        
       
      
        g_{\xi} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.716668em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.04601em;">ξ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>（这里称为<code>projector</code>，其实就是一个MLP层）再得到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          θ 
         
        
       
      
        z_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          ξ 
         
         
          
         
           ′ 
          
         
        
       
      
        z_{\xi}^{'} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.3617em; vertical-align: -0.419216em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.94248em;"><span class="" style="top: -2.41689em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.04601em;">ξ</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class=""></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.827829em;"><span class="" style="top: -2.931em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.419216em;"><span class=""></span></span></span></span></span></span></span></span></span></span>特征（这里是256维）。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          g 
         
        
          θ 
         
        
       
      
        g_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          g 
         
        
          ξ 
         
        
       
      
        g_{\xi} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.716668em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.04601em;">ξ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>同样也是一样的网络结构，但是参数不一样。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          g 
         
        
          ξ 
         
        
       
      
        g_{\xi} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.716668em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.04601em;">ξ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>也是通过动量的这种方式去更新的。</p> 
<p>在之前的对比学习工作中，是让<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          θ 
         
        
       
      
        z_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          ξ 
         
         
          
         
           ′ 
          
         
        
       
      
        z_{\xi}^{'} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.3617em; vertical-align: -0.419216em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.94248em;"><span class="" style="top: -2.41689em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.04601em;">ξ</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class=""></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.827829em;"><span class="" style="top: -2.931em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.419216em;"><span class=""></span></span></span></span></span></span></span></span></span></span>尽可能的相似，而在BYOL这里，又加了一层<code>predictor</code>的全连接层<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          q 
         
        
          θ 
         
        
       
      
        q_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          q 
         
        
          θ 
         
        
       
      
        q_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的网络结构和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          g 
         
        
          θ 
         
        
       
      
        g_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的网络结构是完全一样的。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          θ 
         
        
       
      
        z_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>通过<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          q 
         
        
          θ 
         
        
       
      
        q_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>又得到了一个新的特征<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          q 
         
        
          θ 
         
        
       
         ( 
        
        
        
          z 
         
        
          θ 
         
        
       
         ) 
        
       
      
        q_{\theta}(z_{\theta}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，现在的目的是想让特征<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          q 
         
        
          θ 
         
        
       
         ( 
        
        
        
          z 
         
        
          θ 
         
        
       
         ) 
        
       
      
        q_{\theta}(z_{\theta}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          ξ 
         
         
          
         
           ′ 
          
         
        
       
      
        z_{\xi}^{'} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.3617em; vertical-align: -0.419216em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.94248em;"><span class="" style="top: -2.41689em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.04601em;">ξ</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class=""></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.827829em;"><span class="" style="top: -2.931em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.419216em;"><span class=""></span></span></span></span></span></span></span></span></span></span>尽可能的相似。这相当于把原来匹配的问题，换成了现在一个预测的问题。</p> 
<p>图中的sg表示<code>stop gradient</code>，这里是没有梯度的。这与MoCo很像，模型的上一支相当于<code>query</code>编码器，下面一支相当于<code>key</code>编码器，而<code>key</code>编码器都是通过<code>query</code>编码器来动量更新。不同是代理任务不一样，BYOL相当于是自己一个视角的特征去预测另外一个视角的特征，通过这种预测性的任务来完成模型的训练。</p> 
<p>以上就是BYLO的训练流程，当训练结束后，只有编码器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
        
          θ 
         
        
       
      
        f_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>留下了，这相当于是一个特征提取器，其余的全部拿走。然后通过编码器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
        
          θ 
         
        
       
      
        f_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>输出的特征<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          y 
         
        
          θ 
         
        
       
      
        y_{\theta} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>去做其他的下游任务。目标函数用的是MSE（<code>mean squared error</code>），因为目的就是让两个向量尽可能的接近，所以mse loss就可以了，公式如下图：<br> <img src="https://images2.imgbox.com/52/d0/wbmG8dAk_o.png" alt="在这里插入图片描述"><br> BYLO使用的目标函数与其他的对比学习都不一样，而且其不需要负样本，这是其创新性。</p> 
<ul><li><strong>BYLO中关于BatchNorm的插曲</strong></li></ul> 
<p>在一篇博客上，<a href="https://generallyintelligent.ai/blog/2020-08-24-understanding-self-supervised-contrastive-learning/" rel="nofollow">Understanding Self-Supervised and Contrastive Learning with “Bootstrap Your Own Latent” (BYOL)</a>发现了<code>BatchNorm</code>的一个问题。首先对比一下SimCLR，MoCov2，BYOL中关于<code>projection head</code>的具体结构图。</p> 
<p>1）SimCLR中的<code>projection head</code>有两个<code>BatchNorm</code><br> <img src="https://images2.imgbox.com/38/af/87o8O9Il_o.png" alt="在这里插入图片描述"><br> 2）MoCov2中的<code>projection head</code>没有<code>BatchNorm</code><br> <img src="https://images2.imgbox.com/4b/44/8KXwACgi_o.png" alt="在这里插入图片描述"><br> 3）BYOL中的<code>projection head</code>只有一个<code>BatchNorm</code>）<br> <img src="https://images2.imgbox.com/75/25/iJEACinB_o.png" alt="在这里插入图片描述"><br> 当BYOL的<code>projection head</code>不使用<code>BatchNorm</code>时，会发生模型坍塌的情况，博客作者作了一下实验：<br> <img src="https://images2.imgbox.com/73/55/jivv7fuX_o.png" alt="在这里插入图片描述"><br> 实验发现，在BYOL里，当在任意一个<code>projection head</code>使用<code>BatchNorm</code>时，模型就不会坍塌。博客对这个情况作了一个解释，<code>BatchNorm</code>会吧一个<code>batch</code>里所有样本的特征计算均值方差，也就是<code>running mean</code>和<code>running variance</code>。然后用整个<code>batch</code>算来的均值和方差去作归一化。这就说明，当用某个正样本的loss时，其实也看见了其他样本的特征，也就是发生了信息泄露。由于这种信息泄露的存在，可以把这个<code>batch</code>中的其他样本看成是一种隐式的负样本。所以BYOL就可以看出是当前的样本和平均图片有什么差别，平均图片就是<code>BatchNorm</code>产生的，这里的平均图片和SwAV的聚类中心的说法有点相似。</p> 
<p>总的来说，这篇博客认为<code>BatchNorm</code>是BYOL成功的关键，相当于提供了一种隐式的正负样本学习。</p> 
<ul><li><strong>BYOL的回应</strong></li></ul> 
<p><img src="https://images2.imgbox.com/c7/47/SREsoMnn_o.png" alt="在这里插入图片描述"><br> 这里对于SimCLR，及时提供了显式的负样本，没有BN还是失败，所以说明BN并不是提供了一种隐式的负样本。最后的结果是，<code>BatchNorm</code>可以提高模型的训练稳健性，从而导致不会模型坍塌，也就是如果一开始模型的初始化就比较好（比如使用<code>group norm</code>与<code>weight standardization</code>），那么BYOL其实没有<code>BatchNorm</code>也是可以正常训练的。</p> 
<h3><a id="32_SimSiam_237"></a>3.2 SimSiam</h3> 
<p>paper：<a href="https://arxiv.org/pdf/2011.10566.pdf" rel="nofollow">Exploring Simple Siamese Representation Learning</a></p> 
<p>SimSiam 不需要用负样本，不需要大的batchsize，不需要动量编码器，即使在这种条件下，SimSiam不仅没有模型谈谈，反而取得了很好的模型效果。</p> 
<ul><li>SimSiam的网络结构图如下：</li></ul> 
<p><img src="https://images2.imgbox.com/ff/e9/ONjMcGv4_o.png" alt="在这里插入图片描述">前向过程是一个实例<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>经过数据增强变为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          1 
         
        
       
      
        x_{1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          2 
         
        
       
      
        x_{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，之后经过孪生的编码器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         ⋅ 
        
       
         ) 
        
       
      
        f(·) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mclose">)</span></span></span></span></span>，得到嵌入<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          1 
         
        
       
      
        z_{1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          2 
         
        
       
      
        z_{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> ，之后经过预测层得到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          1 
         
        
       
      
        p_{1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          2 
         
        
       
      
        p_{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> ，之后让<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          1 
         
        
       
      
        p_{1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>预测<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          2 
         
        
       
      
        z_{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> ，用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          2 
         
        
       
      
        p_{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>去预测<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          z 
         
        
          1 
         
        
       
      
        z_{1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.04398em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，进行模型的训练。</p> 
<ul><li>SimSiam的伪代码如下：</li></ul> 
<pre><code class="prism language-python"><span class="token comment"># f: backbone + projection mlp</span>
<span class="token comment"># h: prediction mlp</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> loader<span class="token punctuation">:</span> <span class="token comment"># load a minibatch x with n samples</span>
	x1<span class="token punctuation">,</span> x2 <span class="token operator">=</span> aug<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> aug<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment"># random augmentation</span>
	z1<span class="token punctuation">,</span> z2 <span class="token operator">=</span> f<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">,</span> f<span class="token punctuation">(</span>x2<span class="token punctuation">)</span> <span class="token comment"># projections, n-by-d</span>
	p1<span class="token punctuation">,</span> p2 <span class="token operator">=</span> h<span class="token punctuation">(</span>z1<span class="token punctuation">)</span><span class="token punctuation">,</span> h<span class="token punctuation">(</span>z2<span class="token punctuation">)</span> <span class="token comment"># predictions, n-by-d</span>
	
	L <span class="token operator">=</span> D<span class="token punctuation">(</span>p1<span class="token punctuation">,</span> z2<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> D<span class="token punctuation">(</span>p2<span class="token punctuation">,</span> z1<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token comment"># loss</span>
	
	L<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># back-propagate</span>
	update<span class="token punctuation">(</span>f<span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token comment"># SGD update</span>
	
<span class="token keyword">def</span> <span class="token function">D</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># negative cosine similarity</span>
	z <span class="token operator">=</span> z<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># stop gradient</span>
	
	p <span class="token operator">=</span> normalize<span class="token punctuation">(</span>p<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># l2-normalize</span>
	z <span class="token operator">=</span> normalize<span class="token punctuation">(</span>z<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># l2-normalize</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token punctuation">(</span>p<span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>SimSiam能够成功训练的原因，不会发生模型坍塌，主要就是因为有<code>stop gradient</code>这个操作的存在。由于<code>stop gradient</code>，可以将SimSiam的结构看成是一个EM算法，相当于是在解决两个子问题，而模型更新也在交替进行，相当于不断的更新聚类中心。</p> 
<ul><li> <p>SimSiam与其他结构的对比：<br> <img src="https://images2.imgbox.com/b2/5f/Hikgvqzp_o.png" alt="在这里插入图片描述"><br> 1）SimCLR使用的是端到端的训练，两个encoder，提出了<code>projection head</code><br> 2）SwAV是和聚类中心进行对比的（通过<code>Sinkhorn-Knopp</code>算法生成聚类中心）<br> 3）BYOL是一个预测任务，其使用的是动量编码器，没有使用负样本，创新性地将匹配问题变成预测问题<br> 4）SimSiam也是预测任务，但是使用的是stop gradiant的方式进行预测的，并且使用孪生网络，不需要动量编码器</p> </li><li> <p>SimSiam与其他结构的效果对比：<br> <img src="https://images2.imgbox.com/4b/53/7jug2ctI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cb/29/8CWwenGN_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h2><a id="4_Transformer_283"></a>4. 第四阶段：Transformer</h2> 
<hr> 
<blockquote> 
 <p>在vision transformer之后，因为其大大提升了encoder的效果，所以很多对比学习任务打算使用vision transformer作为backbone进行对比学习，涌现出了两篇工作，分别是MoCov3和DINO。</p> 
</blockquote> 
<h3><a id="41_MoCov3_288"></a>4.1 MoCov3</h3> 
<p>paper：<a href="https://arxiv.org/pdf/2104.02057.pdf" rel="nofollow">An Empirical Study of Training Self-Supervised Vision Transformers<br> </a></p> 
<p>MoCov3中大部分的篇幅都在将如何做Vision Transformers的自监督训练，而且由于MoCov3没有结构图，只能看伪代码：</p> 
<pre><code class="prism language-python"><span class="token comment"># f_q: encoder: backbone + proj mlp + pred mlp</span>
<span class="token comment"># f_k: momentum encoder: backbone + proj mlp</span>
<span class="token comment"># m: momentum coefficient</span>
<span class="token comment"># tau: temperature</span>

<span class="token keyword">for</span> x <span class="token keyword">in</span> loader<span class="token punctuation">:</span> <span class="token comment"># load a minibatch x with N samples</span>
	x1<span class="token punctuation">,</span> x2 <span class="token operator">=</span> aug<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> aug<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment"># augmentation</span>
	q1<span class="token punctuation">,</span> q2 <span class="token operator">=</span> f_q<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">,</span> f_q<span class="token punctuation">(</span>x2<span class="token punctuation">)</span> <span class="token comment"># queries: [N, C] each</span>
	k1<span class="token punctuation">,</span> k2 <span class="token operator">=</span> f_k<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">,</span> f_k<span class="token punctuation">(</span>x2<span class="token punctuation">)</span> <span class="token comment"># keys: [N, C] each</span>
	
	loss <span class="token operator">=</span> ctr<span class="token punctuation">(</span>q1<span class="token punctuation">,</span> k2<span class="token punctuation">)</span> <span class="token operator">+</span> ctr<span class="token punctuation">(</span>q2<span class="token punctuation">,</span> k1<span class="token punctuation">)</span> <span class="token comment"># symmetrized</span>
	loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>
	
	update<span class="token punctuation">(</span>f_q<span class="token punctuation">)</span> <span class="token comment"># optimizer update: f_q</span>
	f_k <span class="token operator">=</span> m<span class="token operator">*</span>f_k <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>m<span class="token punctuation">)</span><span class="token operator">*</span>f_q <span class="token comment"># momentum update: f_k</span>
	
<span class="token comment"># contrastive loss</span>
<span class="token keyword">def</span> <span class="token function">ctr</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
	logits <span class="token operator">=</span> mm<span class="token punctuation">(</span>q<span class="token punctuation">,</span> k<span class="token punctuation">.</span>t<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># [N, N] pairs</span>
	labels <span class="token operator">=</span> <span class="token builtin">range</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token comment"># positives are in diagonal</span>
	loss <span class="token operator">=</span> CrossEntropyLoss<span class="token punctuation">(</span>logits<span class="token operator">/</span>tau<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> tau <span class="token operator">*</span> loss
	
<span class="token comment"># Notes: mm is matrix multiplication. k.t() is k’s transpose. The prediction head is excluded from f k (and thus the momentum update).</span>
</code></pre> 
<p>可以发现，MoCov3有点像MoCov2和SimSiam的结合。<br> 1）整体的网络还是有两个编码器，一个<code>query</code>编码器，一个是<code>key</code>编码器，而且<code>key</code>编码器是一个动量编码器，而且最后的目标函数用的是对比学习的loss。<br> 2）而且编码器结构用还使用了<code>projection head</code>和<code>prediction head</code>，而且目标函数也是一个对称性，就是相互预测，计算<code>query1</code>到<code>key2</code>，也计算<code>query2</code>到<code>key1</code>。</p> 
<p>当把backbone将残差网络换成是Vit时，在<code>batch size</code>比较小时，训练还算比较稳定，曲线比较平滑；但是一旦<code>batch size</code>变大，模型就出现了不稳定的情况，虽然最后也会回复上去，但是准确率会差很多，如下图所示：<br> <img src="https://images2.imgbox.com/28/90/yXBQ117W_o.png" alt="在这里插入图片描述"><br> 作者观察了一下模型梯度回传时候的梯度情况。当每次loss有大幅的震动，导致准确度大幅下降的时候，梯度也会有一个波峰，波峰发生在第一层，在作<code>patch projection</code>的时候，因为这一层经常出现问题，所以作者尝试将这一层冻结住（也就是不再训练这层的参数）。解决的办法就是随机初始化了这个<code>patch projection</code>层，然后对其冻结，随后的训练过程中参数保持不变，然后问题就解决了，获得了平滑了训练曲线。</p> 
<h3><a id="42_DINO_328"></a>4.2 DINO</h3> 
<p>paper：<a href="https://arxiv.org/pdf/2104.14294.pdf" rel="nofollow">Emerging Properties in Self-Supervised Vision Transformers</a></p> 
<p>DINO也是用自监督来训练Vision Transformers的方式，其主要卖点是说Vision Transformers在自监督训练的情况下，会有一些非常有趣的特性，然后把这些图片放在了图1，如下所示：<br> <img src="https://images2.imgbox.com/f5/3b/565AXEAb_o.png" alt="在这里插入图片描述"><br> 这里想表达的意思是一个完全不用任何标签信息训练出来的Vision Transformers，如果将其自注意力图拿出来进行可视化，可以发现其可以非常准确的抓住每个物体的轮廓，这个效果甚至可以直接匹配对这个物体作语义分割。</p> 
<p>DINO全称为<code>Self-distillation with no labels</code>，其将整个框架称为一个蒸馏的框架，结构如图所示：<br> <img src="https://images2.imgbox.com/d9/cb/ulvZrGzg_o.png" alt="在这里插入图片描述"><br> DINO的前向过程都是类似的，当有一个图片<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>的两个视角<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          1 
         
        
       
      
        x_{1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          2 
         
        
       
      
        x_{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>之后，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          1 
         
        
       
      
        x_{1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          2 
         
        
       
      
        x_{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>分别通过学生网络编码器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          g 
         
         
         
           θ 
          
         
           s 
          
         
        
       
      
        g_{\theta s} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和教师网络编码器<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          g 
         
         
         
           θ 
          
         
           t 
          
         
        
       
      
        g_{\theta t} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>得到两个特征<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          1 
         
        
       
      
        p_{1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          2 
         
        
       
      
        p_{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，其中编码器结构中同样包含<code>projection head</code>和<code>prediction head</code>。而为了避免模型的坍塌，DINO做了一个额外的工作<code>centering</code>，这个操作就是把整个batch里的样本都算一个均值，然后减掉这个均值其实就是<code>centering</code>。最后也是有一个<code>stop gradient</code>的操作，然后用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          1 
         
        
       
      
        p_{1} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>预测<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          p 
         
        
          2 
         
        
       
      
        p_{2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。</p> 
<ul><li>DINO的伪代码：</li></ul> 
<pre><code class="prism language-python"><span class="token comment"># gs, gt: student and teacher networks</span>
<span class="token comment"># C: center (K)</span>
<span class="token comment"># tps, tpt: student and teacher temperatures</span>
<span class="token comment"># l, m: network and center momentum rates</span>

gt<span class="token punctuation">.</span>params <span class="token operator">=</span> gs<span class="token punctuation">.</span>params
<span class="token keyword">for</span> x <span class="token keyword">in</span> loader<span class="token punctuation">:</span> <span class="token comment"># load a minibatch x with n samples</span>
	x1<span class="token punctuation">,</span> x2 <span class="token operator">=</span> augment<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> augment<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment"># random views</span>
	
	s1<span class="token punctuation">,</span> s2 <span class="token operator">=</span> gs<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">,</span> gs<span class="token punctuation">(</span>x2<span class="token punctuation">)</span> <span class="token comment"># student output n-by-K</span>
	t1<span class="token punctuation">,</span> t2 <span class="token operator">=</span> gt<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">,</span> gt<span class="token punctuation">(</span>x2<span class="token punctuation">)</span> <span class="token comment"># teacher output n-by-K</span>
	
	loss <span class="token operator">=</span> H<span class="token punctuation">(</span>t1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> H<span class="token punctuation">(</span>t2<span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>
	loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># back-propagate</span>
	
	<span class="token comment"># student, teacher and center updates</span>
	update<span class="token punctuation">(</span>gs<span class="token punctuation">)</span> <span class="token comment"># SGD</span>
	gt<span class="token punctuation">.</span>params <span class="token operator">=</span> l<span class="token operator">*</span>gt<span class="token punctuation">.</span>params <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">*</span>gs<span class="token punctuation">.</span>params
	C <span class="token operator">=</span> m<span class="token operator">*</span>C <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>m<span class="token punctuation">)</span><span class="token operator">*</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
	
<span class="token keyword">def</span> <span class="token function">H</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>
	t <span class="token operator">=</span> t<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># stop gradient</span>
	s <span class="token operator">=</span> softmax<span class="token punctuation">(</span>s <span class="token operator">/</span> tps<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
	t <span class="token operator">=</span> softmax<span class="token punctuation">(</span><span class="token punctuation">(</span>t <span class="token operator">-</span> C<span class="token punctuation">)</span> <span class="token operator">/</span> tpt<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># center + sharpen</span>
	<span class="token keyword">return</span> <span class="token operator">-</span> <span class="token punctuation">(</span>t <span class="token operator">*</span> log<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>伪代码和MoCo比较像的，主要是目标函数上面有一点不同。</p> 
<p><strong>小结：</strong></p> 
<p>最后的这个阶段，从方法和模型的角度上来说，其实和第三阶段基本是一模一样的，主要就是融合了Vision Transformers。</p> 
<h2><a id="5__374"></a>5. 总结</h2> 
<p>下面，再把整个对比学习的发展脉络理一遍<br> <img src="https://images2.imgbox.com/82/a0/1ykfbpUl_o.png" alt="在这里插入图片描述"></p> 
<ul><li>第一阶段 
  <ul><li>InstDisc：提出了个体判别任务， 而且提出用一个<code>memory bank</code>这么一个外部数据结构去存储负样本，从而得到一个又大又一致的字典去做对比学习。</li><li>InvaSpread：不用外部结构，使用端到端的学习，只用一个编码器。但是受限于<code>batch size</code>太小，所以性能不够好。</li><li>CPCv1：提出infoNCE这个目标函数，而且其是一个预测型的代理任务，不仅可以做图像、音频，还可以视频、文字和强化学习，是一个非常全能的结构。</li><li>CMC：将两个视角的任务扩展到多个视角，从而为之后的多视角或者多模态的对比学习打下了铺垫。</li></ul> </li><li>第二阶段 
  <ul><li>MoCov1：算是InstDisc的延伸工作，把<code>memory bank</code>变成了一个队列，也是属于使用外部数据结构，然后把动量更新特征变成了动量更新编码器，从而能预训练一个很好的模型。MoCov1也是很多视觉下游任务上让一个无监督预训练模型比有监督预训练模型表现好的方法。</li><li>SimCLRv1：与InvaSpread方法很像，但是用了很多技术，比如说加大了<code>batch size</code>，用了更多的数据正确，加了一个<code>projection head</code>，训练得更长时间，总之这些技术堆起来让SimCLRv1在ImageNet上有一个非常好的结果。</li><li>CPCv2：CPCv2把这些新技术用了一遍，直接从40多点提升到70多点。</li><li>Infomin：CMC提出了Infomin的原则，两个样本或者两个视角之间的互信息要不多不少才是最好的。</li><li>MoCov2：MoCov2把SimCLRv1这些即插即用的计算用了起来，MoCov2的效果就比MoCov1和SimCLRv1的效果都要好。</li><li>SimCLRv2：SimCLR对模型进行了一点改动得到了SimCLRv2，其主要是做半监督学习的。</li><li>SwAV：把聚类学习和对比学习结合了起来也取得了不错的结果，但是这个结果主要是来自其提出的<code>multi crop</code>这个技术，如果没有这个技术，其与MoCov2与SimCLRv1是差不多的。</li></ul> </li><li>第三阶段 
  <ul><li>BYOL：处理负样本过于麻烦，自己与自己学，把一个对比任务变成了一个预测任务。而且目标函数也比较简单，不再使用info NCE，而且用一个简单的mse loss就可以训练出来。</li><li>BN Blog：由于BYOL有点不可思议，提出BYOL能够工作主要是因为有<code>batch norm</code>，<code>batch norm</code>提供了一种隐式的负样本，所以BYOL可以正常训练而不会模型坍塌。</li><li>BYOLv2：BYOL用来回应BN Blog的论文，其通过做了一系列实验之后，最后说<code>batch norm</code>只是帮助了模型的训练，如果能用另外一种方式能提供一个更好的模型初始化，BYOL不需要提供batch的那些统计量照样能工作，这样就把blog的假设给打破了。</li><li>SimSiam：把之前的工作总结了一下，因为技术堆得过多就不好分析了，这个领域就不好继续推进了，所以其化繁为简，又提出了一个很简单的孪生网络的学习方法。其既不需要大的<code>batch size</code>，也不需要动量编码器，也不需要负样本照样能取得不错的结果。其提出了一个假设<code>stop gradient</code>这个操作是至关重要的，因为这个操作的存在，所以SimSiam可以看出是一种EM算法，通过这种逐步更新的方式避免模型坍塌。</li><li>Barlow twins：主要是更换了一个目标函数，把之前的对比或者是预测变成了两个矩阵之间的对比相似性。</li></ul> </li><li>第四阶段 
  <ul><li>其实都是把backbone从残差网络换成 Vision Transformers，主要的学习方法其实没有改变，但是换成了Vision Transformers之后面临的问题都是说是训练不稳定或者是不好训练，所以各自提出了方法。两种方法都可以有效的提高模型训练的稳健性，防止模型坍塌，让 Vision Transformers用自监督的方法也可以训练得很好。</li><li>MoCov3：提出把<code>patch projection layer</code>给冻结</li><li>DINO： 把teacher网络的输出先做一下归一化，也就是<code>centering</code>操作</li></ul> </li></ul> 
<p><strong>参考资料：</strong></p> 
<p>1）视频讲解：https://www.bilibili.com/video/BV19S4y1M7hm/?spm_id_from=333.788<br> 2）视频笔记：https://zhuanlan.zhihu.com/p/452087382</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ebdde28dc95974cfac9ab04eeb82779e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">redis配置远程连接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2257757a762cf6ee579f29d2d5f681f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言结构体变量——struct</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>