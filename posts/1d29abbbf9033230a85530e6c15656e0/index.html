<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>文本相似度计算——Simhash算法（python实现） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="文本相似度计算——Simhash算法（python实现）" />
<meta property="og:description" content="互联网网页存在着大量重复内容，必须有一套高效的去重算法，否则爬虫将做非常多的无用功，工作时效性无法得到保证，更重要的是用户体验也不好。业界关于文本指纹去重的算法众多，如 k-shingle 算法、google 提出的simhash 算法、Minhash 算法、百度top k 最长句子签名算法等等，本文主要介绍simhash算法以及python应用.
simhash 与传统hash 的区别
传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统的hash算法产生的两个签名，如果原始内容在一定概率下是相等的；如果不相等，除了说明原始内容不相等外，不提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大。所以传统的Hash是无法在签名的维度上来衡量原内容的相似度，而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。
我们主要解决的是文本相似度计算，我们降维生成hash签名也是用于这个目的。看到这里估计大家就明白了，我们使用的simhash就算把文章中的字符串变成 01 串也还是可以用于计算相似度的，而传统的hash却不行。我们可以来做个测试，两个相差只有两个字符的文本串，“你妈妈喊你回家吃饭哦” 和 “你妈妈叫你回家吃饭啦”。
通过simhash计算结果为：
1000010010101101111111100000101011010001001111100001001011001011
1000010010101101011111100000101011010001001111100001101010001011
通过传统hash计算为：
0001000001100110100111011011110
1010010001111111110010110011101
大家可以看得出来，相似的文本simhash只有部分 01 串变化了，而普通的hash却不能做到，这个就是局部敏感哈希的魅力。
simhash简介
simhash 是 google 用来处理海量文本去重的算法。 simhash 可以将一个文档转换成一个 64 位的字节，暂且称之为特征字。判断文档是否重复，只需要判断文档特征字之间的汉明距离。根据经验，一般当两个文档特征字之间的汉明距离小于 3， 就可以判定两个文档相似。
主要步骤：在新拿到文本之后需要先进行分词，这是因为需要挑出TopN个词来表征这篇文本，并且分词的权重不一样，可以使用相应数据集的tf-idf值作为分词的权重，这样就分成了带权重的分词结果。
之后对所有分词进行哈希运算获取二值化的hash结果，再将权重与哈希值相乘，获得带权重的哈希值，最后进行累加以及二值化处理.
分词 使用分词手段将文本分割成关键词的特征向量，分词方法有很多一般都是实词，也就是把停用词等都去掉之后的部分，使用者可以根据自己的需求选择.最后形成去掉噪音词的单词序列并为每个词加上权重. 例如:
傲游AI 专注 于 游戏 领域 多年 AI技术 积淀 一站式 提供 文本 图片 音视频 内容 审核 游戏AI 以及 数据 平台 服务
目前的词只是进行了分割，但是词与词含有的信息量是不一样的，比如傲游AI 游戏 审核 这三个词就比 专注 服务 以及更能表达文本的主旨含义，这也就是所谓信息熵的概念。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1d29abbbf9033230a85530e6c15656e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-04T08:49:04+08:00" />
<meta property="article:modified_time" content="2021-02-04T08:49:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">文本相似度计算——Simhash算法（python实现）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"><span style="color:#121212;">互联网网页存在着大量重复内容，必须有一套高效的去重算法，否则爬虫将做非常多的无用功，工作时效性无法得到保证，更重要的是用户体验也不好。业界关于文本指纹去重的算法众多，如 k-shingle 算法、google 提出的simhash 算法、Minhash 算法、百度top k 最长句子签名算法等等，本文主要介绍simhash算法以及python应用.</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#121212;">simhash </span></strong><strong><span style="color:#121212;">与传统hash 的区别</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统的hash算法产生的两个签名，如果原始内容在一定概率下是相等的；如果不相等，除了说明原始内容不相等外，不提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大。所以传统的Hash是无法在签名的维度上来衡量原内容的相似度，而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">我们主要解决的是文本相似度计算，我们降维生成hash签名也是用于这个目的。看到这里估计大家就明白了，我们使用的simhash就算把文章中的字符串变成 01 串也还是可以用于计算相似度的，而传统的hash却不行。我们可以来做个测试，两个相差只有两个字符的文本串，“你妈妈喊你回家吃饭哦” 和 “你妈妈叫你回家吃饭啦”。</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">通过simhash计算结果为：</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">1000010010101101</span><strong><span style="color:#ff0000;">1</span></strong><span style="color:#121212;">11111100000101011010001001111100001</span><strong><span style="color:#ff0000;">0</span></strong><span style="color:#121212;">0101</span><strong><span style="color:#ff0000;">1</span></strong><span style="color:#121212;">001011</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">1000010010101101</span><strong><span style="color:#ff0000;">0</span></strong><span style="color:#121212;">11111100000101011010001001111100001</span><strong><span style="color:#ff0000;">1</span></strong><span style="color:#121212;">0101</span><strong><span style="color:#ff0000;">0</span></strong><span style="color:#121212;">001011</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">通过传统hash计算为：</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#ff0000;">0</span></strong><span style="color:#121212;">0</span><strong><span style="color:#ff0000;">01</span></strong><span style="color:#121212;">0</span><strong><span style="color:#ff0000;">0</span></strong><span style="color:#121212;">00011</span><strong><span style="color:#ff0000;">00</span></strong><span style="color:#121212;">11</span><strong><span style="color:#ff0000;">0</span></strong><span style="color:#121212;">1</span><strong><span style="color:#ff0000;">0</span></strong><span style="color:#121212;">0</span><strong><span style="color:#ff0000;">1</span></strong><span style="color:#121212;">11</span><strong><span style="color:#ff0000;">0</span></strong><span style="color:#121212;">1</span><strong><span style="color:#ff0000;">1</span></strong><span style="color:#121212;">0111</span><strong><span style="color:#ff0000;">10</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#ff0000;">1</span></strong><span style="color:#121212;">0</span><strong><span style="color:#ff0000;">10</span></strong><span style="color:#121212;">0</span><strong><span style="color:#ff0000;">1</span></strong><span style="color:#121212;">00011</span><strong><span style="color:#ff0000;">11</span></strong><span style="color:#121212;">11</span><strong><span style="color:#ff0000;">1</span></strong><span style="color:#121212;">1</span><strong><span style="color:#ff0000;">1</span></strong><span style="color:#121212;">0</span><strong><span style="color:#ff0000;">0</span></strong><span style="color:#121212;">10</span><strong><span style="color:#ff0000;">1</span></strong><span style="color:#121212;">1</span><strong><span style="color:#ff0000;">0</span></strong><span style="color:#121212;">0111</span><strong><span style="color:#ff0000;">01</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">大家可以看得出来，相似的文本simhash只有部分 01 串变化了，而普通的hash却不能做到，这个就是局部敏感哈希的魅力。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#121212;">simhash</span></strong><strong><span style="color:#121212;">简介</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">simhash </span><span style="color:#121212;">是 google 用来处理海量文本去重的算法。 simhash 可以将一个文档转换成一个 64 位的字节，暂且称之为特征字。判断文档是否重复，只需要判断文档特征字之间的<strong>汉明距离</strong>。根据经验，一般当两个文档特征字之间的汉明距离小于 3， 就可以判定两个文档相似。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#121212;">主要步骤</span></strong><span style="color:#121212;">：在新拿到文本之后需要先进行分词，这是因为需要挑出TopN个词来表征这篇文本，并且分词的权重不一样，可以使用相应数据集的tf-idf值作为分词的权重，这样就分成了带权重的分词结果。</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">之后对所有分词进行哈希运算获取二值化的hash结果，再将权重与哈希值相乘，获得带权重的哈希值，最后进行累加以及二值化处理.</span></p> 
<p style="margin-left:0cm;"><img alt="" height="260" src="https://images2.imgbox.com/b5/c6/CmUjW3Wt_o.png" width="554"></p> 
<ul><li><span style="color:#121212;"><strong>分词</strong></span></li></ul> 
<p style="margin-left:0cm;"><span style="color:#121212;">使用分词手段将文本分割成关键词的特征向量，分词方法有很多一般都是实词，也就是把停用词等都去掉之后的部分，使用者可以根据自己的需求选择.最后形成去掉噪音词的单词序列并为每个词加上权重. 例如:</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">傲游AI 专注 于 游戏 领域 多年 AI技术 积淀 一站式 提供 文本 图片 音视频 内容 审核 游戏AI 以及 数据 平台 服务</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">目前的词只是进行了分割，但是词与词含有的信息量是不一样的，比如傲游AI 游戏 审核 这三个词就比 专注 服务 以及更能表达文本的主旨含义，这也就是所谓信息熵的概念。</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">为此我们还需要设定特征词的权重，简单一点的可以使用绝对词频来表示，也就是某个关键词出现的次数，但是事实上出现次数少的所含有的信息量可能更多.总之需要选择一种加权方法，否则效果会打折扣。</span></p> 
<ul><li><span style="color:#121212;"><strong>哈希和权重化</strong></span></li></ul> 
<p style="margin-left:0cm;"><span style="color:#121212;">前面我们使用分词方法和权重分配将文本就分割成若干个带权重的实词，比如权重使用1-5的数字表示，1最低5最高</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">傲游AI(5) 专注(2) 于(1) 游戏(3) 领域(1) ......</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">对各个特征词进行二值化哈希值计算, 再将所有的哈希值累加，最后将累加结果二值化.</span></p> 
<p style="margin-left:0cm;"><img alt="" height="465" src="https://images2.imgbox.com/d7/82/kQ1pOuDE_o.jpg" width="796"></p> 
<ul><li><span style="color:#121212;"><strong>汉明距离</strong></span></li></ul> 
<p style="margin-left:0cm;"><span style="color:#646464;">在信息论中，两个等长字符串之间的汉明距离（英语：Hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。 汉明重量是字符串相对于同样长度的零字符串的汉明距离，也就是说，它是字符串中非零的元素个数：对于二进制字符串来说，就是1的个数，所以11101的汉明重量是4。 对于二进制字符串a与b来说，它等于a 异或b后所得二进制字符串中“1”的个数。 汉明距离是以理查德·卫斯里·汉明的名字命名的，汉明在误差检测与校正码的基础性论文中首次引入这个概念。 在通信中累计定长二进制字中发生翻转的错误数据位，所以它也被称为信号距离。汉明重量分析在包括信息论、编码理论、密码学等领域都有应用。但是，如果要比较两个不同长度的字符串，不仅要进行替换，而且要进行插入与删除的运算，在这种场合下，通常使用更加复杂的编辑距离等算法。</span></p> 
<p style="margin-left:0cm;"><span style="color:#121212;">谷歌经过工程验证认为当两个64bit的二值化simhash值的汉明距离超过3则认为不相似，所以判重问题就转换为求两个哈希值的汉明距离问题。</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#121212;">Simhash</span></strong><strong><span style="color:#121212;">局限</span></strong></p> 
<p style="margin-left:0cm;">simhash也有其局限性：</p> 
<p style="margin-left:0cm;">　　1. SimHash处理短文本内容准确率往往不能得到保证。由于simhash是局部敏感的hash，其可能不适合做这种短标题的重复度判断，会存在一定的误差，当文本内容较长时，使用SimHash准确率很高（即文本越长判断的准确率越高）。在处理小于500字的短文本时，simhash的表现并不是很好，所以在使用simhash前一定要注意这个细节。</p> 
<p style="margin-left:0cm;">2. 文本内容中每个term对应的权重如何确定要根据实际的项目需求，一般是可以使用IDF权重来进行计算</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#121212;">Python</span></strong><strong><span style="color:#121212;">实现</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#121212;">1. 调包实现</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#cc7832;">from </span><span style="color:#a9b7c6;">simhash </span><span style="color:#cc7832;">import </span><span style="color:#a9b7c6;">Simhash</span><br><br><br><span style="color:#cc7832;">def </span><span style="color:#ffc66d;">simhash_demo</span><span style="color:#a9b7c6;">(text_a</span><span style="color:#cc7832;">, </span><span style="color:#a9b7c6;">text_b):<br>     </span><em><span style="color:#629755;">"""<br>     </span></em><em><span style="color:#629755;">求两文本的相似度<br>     </span></em><strong><em><span style="color:#629755;">:param</span></em></strong><em><span style="color:#629755;"> text_a:<br>     <strong>:param</strong> text_b:<br>     <strong>:return</strong>:<br>     """<br>     </span></em><span style="color:#a9b7c6;">a_simhash = Simhash(text_a)<br>     b_simhash = Simhash(text_b)<br>     max_hashbit = </span><span style="color:#8888c6;">max</span><span style="color:#a9b7c6;">(</span><span style="color:#8888c6;">len</span><span style="color:#a9b7c6;">(</span><span style="color:#8888c6;">bin</span><span style="color:#a9b7c6;">(a_simhash.value))</span><span style="color:#cc7832;">, </span><span style="color:#8888c6;">len</span><span style="color:#a9b7c6;">(</span><span style="color:#8888c6;">bin</span><span style="color:#a9b7c6;">(b_simhash.value)))<br>     </span><span style="color:#808080;"># </span><span style="color:#808080;">汉明距离<br>     </span><span style="color:#a9b7c6;">distince = a_simhash.distance(b_simhash)<br>     </span><span style="color:#8888c6;">print</span><span style="color:#a9b7c6;">(distince)<br>     similar = </span><span style="color:#6897bb;">1 </span><span style="color:#a9b7c6;">- distince / max_hashbit<br>     </span><span style="color:#cc7832;">return </span><span style="color:#a9b7c6;">similar</span><br><br><br><span style="color:#cc7832;">if </span><span style="color:#a9b7c6;">__name__ == </span><span style="color:#6a8759;">'__main__'</span><span style="color:#a9b7c6;">:<br>     text1 = </span><span style="color:#6a8759;">"</span><span style="color:#6a8759;">傲游</span><span style="color:#6a8759;">AI</span><span style="color:#6a8759;">专注于游戏领域</span><span style="color:#6a8759;">,</span><span style="color:#6a8759;">多年的</span><span style="color:#6a8759;">AI</span><span style="color:#6a8759;">技术积淀</span><span style="color:#6a8759;">,</span><span style="color:#6a8759;">一站式提供文本、图片、音</span><span style="color:#6a8759;">/</span><span style="color:#6a8759;">视频内容审核</span><span style="color:#6a8759;">,</span><span style="color:#6a8759;">游戏</span><span style="color:#6a8759;">AI</span><span style="color:#6a8759;">以及数据平台服务</span><span style="color:#6a8759;">"<br>     </span><span style="color:#a9b7c6;">text2 = </span><span style="color:#6a8759;">"</span><span style="color:#6a8759;">傲游</span><span style="color:#6a8759;">AI</span><span style="color:#6a8759;">专注于游戏领域</span><span style="color:#6a8759;">,</span><span style="color:#6a8759;">多年的</span><span style="color:#6a8759;">AI</span><span style="color:#6a8759;">技术积淀</span><span style="color:#6a8759;">,</span><span style="color:#6a8759;">二站式提供文本、图片、音 视频内容审核</span><span style="color:#6a8759;">,</span><span style="color:#6a8759;">游戏</span><span style="color:#6a8759;">AI</span><span style="color:#6a8759;">以及数据平台服务</span><span style="color:#6a8759;">"<br>     </span><span style="color:#a9b7c6;">text3 = </span><span style="color:#6a8759;">'"</span><span style="color:#6a8759;">傲游</span><span style="color:#6a8759;">AI</span><span style="color:#6a8759;">专注于游戏领域</span><span style="color:#6a8759;">,</span><span style="color:#6a8759;">多年的</span><span style="color:#6a8759;">AI</span><span style="color:#6a8759;">技术积淀</span><span style="color:#6a8759;">,</span><span style="color:#6a8759;">三站式提供文本、图片、音视频内容审核，游戏</span><span style="color:#6a8759;">AI</span><span style="color:#6a8759;">以及数据平台服务</span><span style="color:#6a8759;">"'<br>     </span><span style="color:#a9b7c6;">similar = simhash_demo(text1</span><span style="color:#cc7832;">, </span><span style="color:#a9b7c6;">text2)<br>     similar2 = simhash_demo(text1</span><span style="color:#cc7832;">, </span><span style="color:#a9b7c6;">text3)<br>     similar3 = simhash_demo(text2</span><span style="color:#cc7832;">, </span><span style="color:#a9b7c6;">text3)<br>     </span><span style="color:#8888c6;">print</span><span style="color:#a9b7c6;">(similar)<br>     </span><span style="color:#8888c6;">print</span><span style="color:#a9b7c6;">(similar2)<br>     </span><span style="color:#8888c6;">print</span><span style="color:#a9b7c6;">(similar3)</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#121212;">2. 自主实现</span></strong></p> 
<pre>#!/usr/bin/python
# coding=utf-8
class simhash:
    # 构造函数
    def __init__(self, tokens='', hashbits=128):                      
        self.hashbits = hashbits
        self.hash = self.simhash(tokens)

    # toString函数
    def __str__(self):
        return str(self.hash)

    # 生成simhash值
    def simhash(self, tokens):
        v = [0] * self.hashbits
        for t in [self._string_hash(x) for x in tokens]:  # t为token的普通hash值
            for i in range(self.hashbits):
                bitmask = 1 &lt;&lt; i
                if t &amp; bitmask:
                    v[i] += 1  # 查看当前bit位是否为1,是的话将该位+1
                else:
                    v[i] -= 1  # 否则的话,该位-1
        fingerprint = 0
        for i in range(self.hashbits):
            if v[i] &gt;= 0:
                fingerprint += 1 &lt;&lt; i
        return fingerprint  # 整个文档的fingerprint为最终各个位&gt;=0的和

    # 求海明距离
    def hamming_distance(self, other):
        x = (self.hash ^ other.hash) &amp; ((1 &lt;&lt; self.hashbits) - 1)
        tot = 0
        while x :
            tot += 1
            x &amp;= x - 1
        return tot

    # 求相似度
    def similarity (self, other):
        a = float(self.hash)
        b = float(other.hash)
        if a &gt; b:
            return b / a
        else:
            return a / b

    # 针对source生成hash值               (一个可变长度版本的Python的内置散列)
    def _string_hash(self, source):
        if source == "":
            return 0
        else:
            x = ord(source[0]) &lt;&lt; 7
            m = 1000003
            mask = 2 ** self.hashbits - 1
            for c in source:
                x = ((x * m) ^ ord(c)) &amp; mask
                x ^= len(source)
                if x == -1:
                    x = -2
                return x


if __name__ == '__main__':
        s1 = "傲游AI专注于游戏领域,多年的AI技术积淀,一站式提供文本、图片、音/视频内容审核，游戏AI以及数据平台服务"
        hash1 = simhash(s1.split())
        s2 = "傲游AI专注于游戏领域,多年的AI技术积淀,二站式提供文本、图片、音 视频内容审核,游戏AI以及数据平台服务"
        hash2 = simhash(s2.split())
        s3 = '"傲游AI专注于游戏领域,多年的AI技术积淀,三站式提供文本、图片、音视频内容审核，游戏AI以及数据平台服务"'
        hash3 = simhash(s3.split())
        print(hash1.hamming_distance(hash2) , "               " , hash1.similarity(hash2))
        print(hash1.hamming_distance(hash3) , "               " , hash1.similarity(hash3))
        print(hash2.hamming_distance(hash3) , "               " , hash2.similarity(hash3))
</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4a5e1308aaeb39e5aff3ac62ceb8cdef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python支持向量机实验_Python SVM(支持向量机)实现方法完整示例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4bfe1cdab12a4a984145b88ded9d2489/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringMVC的工作原理图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>