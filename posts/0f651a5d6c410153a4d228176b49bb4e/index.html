<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hibernate 的级联更新 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hibernate 的级联更新" />
<meta property="og:description" content="Hibernate 的级联更新 引言 上一篇文章中，我提到 Hibernate 的查询可以不用 SQL，而本篇，我要分享的是 Hibernate 的实体更新。因为 Hibernate 的这一特性，同样让我在开发的过程中，感受到了省心和劳心。
Hibernate 内实体的四种状态 什么是实体？其实就是对象。而 Hibernate 内的实体分为四种状态：临时态、持久态、游离态、删除态，
临时态(transient)：刚用 new 语句创建，还没有被持久化，并且不处于 Sesssion 的缓存中。处于临时状态的 Java 对象被称为临时对象。
持久态(persistent)：已经被持久化，并且加入到 Session 的缓存中。处于持久化状态的 Java 对象被称为持久化对象。
游离态(detached)：已经被持久化，但不再处于 Session 的缓存中。处于游离状态的 Java 对象被称为游离对象。
删除态(removed)：不再处于 Session 的缓存中，并且 Session 已经计划将其从数据库中删除。处于删除状态的 Java 对象被称为删除对象。
各状态之间的切换，我仅给出一张图进行简单说明，建议想深入了解的朋友查阅有关文章。
持久态下，针对该实体任何属性的更改都会直接影响到数据库表中一条记录对应字段的更新，即与数据库表同步。同步的时机也建议查询下相关文章，不在赘述。
这是很方便的一个特性。举个例子 Book：
public class Book implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) Integer id; @Column(nullable = false, insertable = false, updatable = false) Integer peopleId; @ManyToOne(fetch = FetchType." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0f651a5d6c410153a4d228176b49bb4e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-21T22:30:55+08:00" />
<meta property="article:modified_time" content="2019-11-21T22:30:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hibernate 的级联更新</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Hibernate__0"></a>Hibernate 的级联更新</h2> 
<center> 
 <img src="https://images2.imgbox.com/e1/f8/diTJ64Js_o.gif" width="70%"> 
</center> 
<h3><a id="_5"></a>引言</h3> 
<p>上一篇文章中，我提到 Hibernate 的查询可以不用 SQL，而本篇，我要分享的是 Hibernate 的实体更新。因为 Hibernate 的这一特性，同样让我在开发的过程中，感受到了省心和劳心。</p> 
<h3><a id="Hibernate__9"></a>Hibernate 内实体的四种状态</h3> 
<p>什么是实体？其实就是对象。而 Hibernate 内的实体分为四种状态：<code>临时态、持久态、游离态、删除态</code>，</p> 
<p><code>临时态(transient)</code>：刚用 new 语句创建，还没有被持久化，并且不处于 Sesssion 的缓存中。处于临时状态的 Java 对象被称为临时对象。</p> 
<p><code>持久态(persistent)</code>：已经被持久化，并且加入到 Session 的缓存中。处于持久化状态的 Java 对象被称为持久化对象。</p> 
<p><code>游离态(detached)</code>：已经被持久化，但不再处于 Session 的缓存中。处于游离状态的 Java 对象被称为游离对象。</p> 
<p><code>删除态(removed)</code>：不再处于 Session 的缓存中，并且 Session 已经计划将其从数据库中删除。处于删除状态的 Java 对象被称为删除对象。</p> 
<p>各状态之间的切换，我仅给出一张图进行简单说明，建议想深入了解的朋友查阅有关文章。</p> 
<center> 
 <img src="https://images2.imgbox.com/cf/7b/nZyWbtrm_o.png" width="80%"> 
</center> 
<p><code>持久态下，针对该实体任何属性的更改都会直接影响到数据库表中一条记录对应字段的更新，即与数据库表同步。</code>同步的时机也建议查询下相关文章，不在赘述。</p> 
<p>这是很方便的一个特性。举个例子 Book：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>
    Integer id<span class="token punctuation">;</span>
  
  	<span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>nullable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> insertable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
    Integer peopleId<span class="token punctuation">;</span>
  
  	<span class="token annotation punctuation">@ManyToOne</span><span class="token punctuation">(</span>fetch <span class="token operator">=</span> FetchType<span class="token punctuation">.</span>LAZY<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"peopleId"</span><span class="token punctuation">)</span>
    People people<span class="token punctuation">;</span>
  
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在一个服务中，如果需要进行修改书的名称，几行代码搞定：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Integer Id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Book book <span class="token operator">=</span> bookRepository<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>Id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        book<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"New Name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>是的，当实体处于持久态下，如果需要更新实体的一些属性，直接 set 就好了，十分方便。</p> 
<h3><a id="_58"></a>问题及解决</h3> 
<p>但是，只要是对象，就无可避免的会与其他对象进行关联。我引入一个新对象 People 来说明由此引发的一些问题：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>
    Integer id<span class="token punctuation">;</span>
  
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在一个服务中，如果需要修改与 Book 关联的 People，使用同样的 set 方法是不行的，会报错：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updatePeople</span><span class="token punctuation">(</span>Integer Id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Book book <span class="token operator">=</span> bookRepository<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>Id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        book<span class="token punctuation">.</span><span class="token function">setPeopleId</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意这行注解：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>nullable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> insertable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
Integer peopleId<span class="token punctuation">;</span>
</code></pre> 
<p>在 Hibernate 中，如果对象需要关联，那么，关联的键值必须添加<code>Column(nullable = false, insertable = false, updatable = false)</code>注解，但是一旦添加上此注解，set 是不允许的，那么，如果要进行关联对象更新，如何做到呢，正确的方式如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updatePeople</span><span class="token punctuation">(</span>Integer Id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Book book <span class="token operator">=</span> bookRepository<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>Id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        book<span class="token punctuation">.</span><span class="token function">setPeople</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>是的，直接更新关联对象，而不是更新关联键值，这才是正确的 Hibernate 进行关联对象更新的方式。</p> 
<h3><a id="_101"></a>参考</h3> 
<ol><li><a href="https://blog.csdn.net/qq_40748545/article/details/82461433">hibernate 四种状态（临时状态，持久化状态，游离状态，删除状态——LMotos</a></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32b768534c7b753e8795e6c94f21d07c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Entity Framework Core 数据库优先(DB First)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/daaadcd4bf2abdd463d1b3a21dc9ee35/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;中的“引用”详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>