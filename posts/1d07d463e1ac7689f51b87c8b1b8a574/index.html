<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自建ocr接口动态识别验证码 配bp进行验证码爆破 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="自建ocr接口动态识别验证码 配bp进行验证码爆破" />
<meta property="og:description" content="一. 声明：本文仅限学习研究讨论，切忌做非法乱纪之事！
一、插件简介
captcha-killer要解决的问题是让burp能用上各种验证码识别技术！
注意：
插件目前针对的图片型验证码，其他类型目前不支持。
captcha-killer本身无法识别验证码，它专注于对各种验证码识别接口的调用
二、下载地址：
burp2020前使用：
https://github.com/c0ny1/captcha-killer/tree/0.1.2
burp2020后的版本使用：
https://github.com/Ta0ing/captcha-killer-java8
1.下载插件并加载
下载DDDDdocr API 服务器{kali环境下有docker环境}
地址：https://github.com/sml2h3/ocr_api_server.git
git clone https://github.com/sml2h3/ocr_api_server.git cd ocr_api_server # 修改entrypoint.sh中的参数，具体参数往上翻，默认9898端口，同时开启ocr模块以及目标检测模块 # 编译镜像 docker build -t ocr_server:v1 . # 运行镜像 docker run -p 9898:9898 -d ocr_server:v1 部署好之后，docker ps -a看看
映射到9898端口了，接下来验证连通性
curl -v http://ip:9898/ping 返回pong，表示成功
访问验证码的链接地址，抓验证码的请求包,并发送到插件
然后到切换到captcha-killer插件面板，点击获取即可拿到要识别的验证码图片内容（下方验证码url栏处，直接点击获取验证码也行，无需复制验证码url，再点击获取）
注意：获取验证码的cookie一定要和intruder发送的cookie相同！
配置识别接口的地址和请求包
接口地址：http://api.ttshitu.com:80
请求包，username，password处去http://ttshitu.com注册账号，该平台识别500次一元钱：
POST /predict HTTP/1.1
Host: api.ttshitu.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0
Accept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,*/*;q=0.8" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1d07d463e1ac7689f51b87c8b1b8a574/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-08T10:26:00+08:00" />
<meta property="article:modified_time" content="2023-12-08T10:26:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自建ocr接口动态识别验证码 配bp进行验证码爆破</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一. <strong>声明：本文仅限学习研究讨论，切忌做非法乱纪之事！</strong></p> 
<p></p> 
<p><strong>一、插件简介<br> captcha-killer要解决的问题是让burp能用上各种验证码识别技术！</strong></p> 
<p><strong>注意：</strong></p> 
<p><strong>插件目前针对的图片型验证码，其他类型目前不支持。<br> captcha-killer本身无法识别验证码，它专注于对各种验证码识别接口的调用<br> 二、下载地址：<br> burp2020前使用：</strong></p> 
<p><strong>https://github.com/c0ny1/captcha-killer/tree/0.1.2<br> burp2020后的版本使用：</strong></p> 
<p><strong>https://github.com/Ta0ing/captcha-killer-java8</strong><br> 1.下载插件并加载</p> 
<p><img alt="" height="1012" src="https://images2.imgbox.com/71/04/73gDEY0g_o.png" width="1200"></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:rgba(0,0,0,.9);"><span style="background-color:#ffffff;">下载DDDDdocr API 服务器{kali环境下有docker环境}</span></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:rgba(0,0,0,.9);"><span style="background-color:#ffffff;"><em>地址：<span style="color:#24292f;">https://github.com/sml2h3/ocr_api_server.git</span></em></span></span></p> 
<pre style="margin-left:0;"><span style="background-color:#ffffff;"><span style="color:#24292f;">git clone https://github.com/sml2h3/ocr_api_server.git
cd ocr_api_server
# 修改entrypoint.sh中的参数，具体参数往上翻，默认9898端口，同时开启ocr模块以及目标检测模块
# 编译镜像
docker build -t ocr_server:v1 .
# 运行镜像
docker run -p 9898:9898 -d ocr_server:v1</span></span></pre> 
<p style="margin-left:0;text-align:justify;"><span style="color:rgba(0,0,0,.9);"><span style="background-color:#ffffff;">部署好之后，docker ps -a看看</span></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/94/71/DaAdqtNw_o.png"></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:rgba(0,0,0,.9);"><span style="background-color:#ffffff;">映射到9898端口了，接下来验证连通性</span></span></p> 
<pre class="code-snippet__js" style="margin-left:0;"><code>curl -v http://ip:9898/ping</code></pre> 
<p style="margin-left:0;text-align:justify;"><span style="color:rgba(0,0,0,.9);"><span style="background-color:#ffffff;">返回pong，表示成功</span></span></p> 
<p><img alt="" height="384" src="https://images2.imgbox.com/8f/e7/3VRhCiCW_o.png" width="1200"></p> 
<p>访问验证码的链接地址，抓验证码的请求包,并发送到插件</p> 
<p><img alt="" height="915" src="https://images2.imgbox.com/3b/b8/EOTWdAuu_o.png" width="1200"></p> 
<p></p> 
<p>然后到切换到captcha-killer插件面板，点击获取即可拿到要识别的验证码图片内容（下方验证码url栏处，直接点击获取验证码也行，无需复制验证码url，再点击获取）</p> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/49/6d/R1vIkAcO_o.png" width="1200"></p> 
<p> <strong>注意：获取验证码的cookie一定要和intruder发送的cookie相同！</strong></p> 
<p><strong>配置识别接口的地址和请求包</strong></p> 
<p><strong>接口地址：http://api.ttshitu.com:80</strong></p> 
<p><strong>请求包，username，password处去http://ttshitu.com注册账号，该平台识别500次一元钱：</strong></p> 
<p>POST /predict HTTP/1.1<br> Host: api.ttshitu.com<br> User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0<br> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br> Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<br> Accept-Encoding: gzip, deflate<br> DNT: 1<br> Connection: close<br> Upgrade-Insecure-Requests: 1<br> Content-Type: application/json;charset=UTF-8<br> Content-Length: 1443</p> 
<p>{"username":"****","password":"****","typeid":"3","image":"&lt;@BASE64&gt;&lt;@IMG_RAW&gt;&lt;/@IMG_RAW&gt;&lt;/@BASE64&gt;"}</p> 
<p>（我们的上面的代码可以直接粘贴使用）<br><strong>注意：有一种情况，作者没有粘贴代码，而是把代码放到写作框里，所以代码header与body中间的空行，里面有个空格一定要删掉。（CSDN的原因空行自带一个空格)</strong></p> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/35/a6/HKnoJoMG_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p></p> 
<p><strong>但是开头我们自己搭建了一个ocr接口可以直接免费使用,</strong></p> 
<p><strong>以下是成功图</strong></p> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/eb/1d/GWJ1Pzcu_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p> 这个是我们的请求包</p> 
<ul><li> <p>POST /ocr/b64/json HTTP/1.1<br> Host: ip:port<br> Authorization:Basic f0ngauth<br> User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:97.0) Gecko/20100101 Firefox/97.0<br> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8<br> Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br> Accept-Encoding: gzip, deflate<br> Connection: keep-alive<br> Upgrade-Insecure-Requests: 1<br> Content-Type: application/x-www-form-urlencoded<br> Content-Length: 8332</p> <p>&lt;@BASE64&gt;&lt;@IMG_RAW&gt;&lt;/@IMG_RAW&gt;&lt;/@BASE64&gt;</p> </li></ul> 
<p></p> 
<pre><code><span style="color:#4d4d4d;">匹配识别结果</span>
</code></pre> 
<p>通过判断我们知道，接口返回的json数据中，字段<strong><code>result</code></strong>的值为识别结果。我们这里使用<strong><code>Regular expression</code>(正则表达式)</strong>来匹配，然后选择YX7L右键<strong><code>标记为识别结果</code></strong>，系统会自动生成正则表达式规则<code>t"\:(.*?)","</code>。</p> 
<p><img alt="" height="980" src="https://images2.imgbox.com/0c/29/phV0JBNa_o.png" width="1200"></p> 
<p> 到达这步建议将配置好常用接口的url，数据包已经匹配规则保存为模版，方便下次直接通过右键<code>模板库</code>中快速设置。</p> 
<p>这时抓包登录界面的请求包，</p> 
<p><img alt="" height="1050" src="https://images2.imgbox.com/63/ca/QXrbN8kA_o.png" width="1200"></p> 
<p></p> 
<p> 然后发送到攻击器</p> 
<p> 设置Intruder的爆破模式和payload位置</p> 
<p><img alt="" height="1042" src="https://images2.imgbox.com/04/05/kLs7u1TE_o.png" width="1200"></p> 
<p></p> 
<pre> 验证码payload选择通过插件来生成</pre> 
<p><img alt="" height="1042" src="https://images2.imgbox.com/44/95/shgiZIiM_o.png" width="1200"></p> 
<p></p> 
<p>设置线程</p> 
<p> 多线程会导致大量验证码错误，验证码还没识别完成，已经被另一个线程刷新改变了<img alt="" height="1050" src="https://images2.imgbox.com/e0/cb/QtY3aFio_o.png" width="1200"></p> 
<p>开始爆破</p> 
<p><img alt="" height="1029" src="https://images2.imgbox.com/ab/6d/HRTPVetk_o.png" width="1200"></p> 
<p></p> 
<p> 备注： 1.本来想爆破pikachu的  但是pikachu的验证码不好识别（10个里面能错4个，不管是收费还是免费的ocr接口）</p> 
<p>             2.爆破图形验证码，得看看验证码好不好识别，然后再去爆破。（基本四位数，看着清楚的，随便爆破就完了）</p> 
<p>             </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b36976e90c25f3cf1aaa9c7b8a78ec4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Shell脚本中if [[-f ]]什么意思</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3495aa758b59156605d6ada7517ba06a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">位(bit)、字节(byte)、字符、编码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>