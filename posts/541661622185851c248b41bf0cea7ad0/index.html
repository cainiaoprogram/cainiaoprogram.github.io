<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kafka - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="kafka" />
<meta property="og:description" content="目录
官方文档：
一、简介：
高性能
分区的设计
顺序读写
零拷贝技术
减少网络传输上的开销
基础组件：
kafka节点：broker
主题：topic
分区：partition
副本：Replication
同步副本集合ISR（in-sync replicas）
概念：
特点：
非同步状态副本OSR（Outof-sync Replicas）
partition中leader replication的选举：
Kafka 为何不采用大多数投票机制(quorum算法)来选举leader 。
Unclean 领导者选举（Unclean Leader Election）
follower同步leader的数据：
同步方式：
优点：
常见配置：
producer
数据发送方式：
consumer
接收数据方式：
拉模式的优点：
推模式(push-based)消费的缺点：
consumer group
配置
Producer配置
acks：
batch.size
Broker配置
优化
producer如何优化打入速度
consumer如何优化消费速度
Kafka中的ZooKeeper
管理 Broker 、Consumer Group、Consumer、Producer
思考
为什么Kafka不支持读写分离？
官方文档： Apache KafkaKafka 中文文档 - ApacheCN重点关注 4. 设计思想 一、简介： 以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。 高性能 分区的设计 负载均衡：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/541661622185851c248b41bf0cea7ad0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-19T02:00:16+08:00" />
<meta property="article:modified_time" content="2022-05-19T02:00:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kafka</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9A" rel="nofollow">官方文档：</a></p> 
<p id="%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B%EF%BC%9A" rel="nofollow">一、简介：</a></p> 
<p id="%E9%AB%98%E6%80%A7%E8%83%BD-toc" style="margin-left:40px;"><a href="#%E9%AB%98%E6%80%A7%E8%83%BD" rel="nofollow">高性能</a></p> 
<p id="%E5%88%86%E5%8C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#%E5%88%86%E5%8C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1" rel="nofollow">分区的设计</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99-toc" style="margin-left:80px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99" rel="nofollow">顺序读写</a></p> 
<p id="%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF-toc" style="margin-left:80px;"><a href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF" rel="nofollow">零拷贝技术</a></p> 
<p id="%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%8A%E7%9A%84%E5%BC%80%E9%94%80-toc" style="margin-left:80px;"><a href="#%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%8A%E7%9A%84%E5%BC%80%E9%94%80" rel="nofollow">减少网络传输上的开销</a></p> 
<p id="%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%EF%BC%9A" rel="nofollow">基础组件：</a></p> 
<p id="kafka%E8%8A%82%E7%82%B9%EF%BC%9Abroker-toc" style="margin-left:0px;"><a href="#kafka%E8%8A%82%E7%82%B9%EF%BC%9Abroker" rel="nofollow">kafka节点：broker</a></p> 
<p id="%E4%B8%BB%E9%A2%98%EF%BC%9Atopic-toc" style="margin-left:0px;"><a href="#%E4%B8%BB%E9%A2%98%EF%BC%9Atopic" rel="nofollow">主题：topic</a></p> 
<p id="%E5%88%86%E5%8C%BA%EF%BC%9Apartition-toc" style="margin-left:0px;"><a href="#%E5%88%86%E5%8C%BA%EF%BC%9Apartition" rel="nofollow">分区：partition</a></p> 
<p id="%E5%89%AF%E6%9C%AC%EF%BC%9AReplication-toc" style="margin-left:0px;"><a href="#%E5%89%AF%E6%9C%AC%EF%BC%9AReplication" rel="nofollow">副本：Replication</a></p> 
<p id="%E5%90%8C%E6%AD%A5%E5%89%AF%E6%9C%AC%E9%9B%86%E5%90%88ISR%EF%BC%88in-sync%20replicas%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E5%90%8C%E6%AD%A5%E5%89%AF%E6%9C%AC%E9%9B%86%E5%90%88ISR%EF%BC%88in-sync%20replicas%EF%BC%89" rel="nofollow">同步副本集合ISR（in-sync replicas）</a></p> 
<p id="%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow">概念：</a></p> 
<p id="%E7%89%B9%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%89%B9%E7%82%B9%EF%BC%9A" rel="nofollow">特点：</a></p> 
<p id="%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E5%89%AF%E6%9C%ACOSR%EF%BC%88Outof-sync%20Replicas%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E5%89%AF%E6%9C%ACOSR%EF%BC%88Outof-sync%20Replicas%EF%BC%89" rel="nofollow">非同步状态副本OSR（Outof-sync Replicas）</a></p> 
<p id="partition%E4%B8%ADleader%20replication%E7%9A%84%E9%80%89%E4%B8%BE%EF%BC%9A-toc" style="margin-left:40px;"><a href="#partition%E4%B8%ADleader%20replication%E7%9A%84%E9%80%89%E4%B8%BE%EF%BC%9A" rel="nofollow">partition中leader replication的选举：</a></p> 
<p id="Kafka%20%E4%B8%BA%E4%BD%95%E4%B8%8D%E9%87%87%E7%94%A8%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E6%9C%BA%E5%88%B6(quorum%E7%AE%97%E6%B3%95)%E6%9D%A5%E9%80%89%E4%B8%BEleader%20%E3%80%82%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B-toc" style="margin-left:80px;"><a href="#Kafka%20%E4%B8%BA%E4%BD%95%E4%B8%8D%E9%87%87%E7%94%A8%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E6%9C%BA%E5%88%B6%28quorum%E7%AE%97%E6%B3%95%29%E6%9D%A5%E9%80%89%E4%B8%BEleader%20%E3%80%82%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B" rel="nofollow">Kafka 为何不采用大多数投票机制(quorum算法)来选举leader 。</a></p> 
<p id="Unclean%20%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE%EF%BC%88Unclean%20Leader%20Election%EF%BC%89-toc" style="margin-left:80px;"><a href="#Unclean%20%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE%EF%BC%88Unclean%20Leader%20Election%EF%BC%89" rel="nofollow">Unclean 领导者选举（Unclean Leader Election）</a></p> 
<p id="follower%E5%90%8C%E6%AD%A5leader%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A-toc" style="margin-left:40px;"><a href="#follower%E5%90%8C%E6%AD%A5leader%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A" rel="nofollow">follower同步leader的数据：</a></p> 
<p id="%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%9A" rel="nofollow">同步方式：</a></p> 
<p id="%E4%BC%98%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BC%98%E7%82%B9%EF%BC%9A" rel="nofollow">优点：</a></p> 
<p id="%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%EF%BC%9A" rel="nofollow">常见配置：</a></p> 
<p id="producer-toc" style="margin-left:0px;"><a href="#producer" rel="nofollow">producer</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%96%B9%E5%BC%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%96%B9%E5%BC%8F%EF%BC%9A" rel="nofollow">数据发送方式：</a></p> 
<p id="consumer-toc" style="margin-left:0px;"><a href="#consumer" rel="nofollow">consumer</a></p> 
<p id="%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F%EF%BC%9A" rel="nofollow">接收数据方式：</a></p> 
<p id="%E6%8B%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%8B%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A" rel="nofollow">拉模式的优点：</a></p> 
<p id="%E6%8E%A8%E6%A8%A1%E5%BC%8F(push-based)%E6%B6%88%E8%B4%B9%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%8E%A8%E6%A8%A1%E5%BC%8F%28push-based%29%E6%B6%88%E8%B4%B9%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A" rel="nofollow">推模式(push-based)消费的缺点：</a></p> 
<p id="consumer%20group-toc" style="margin-left:40px;"><a href="#consumer%20group" rel="nofollow">consumer group</a></p> 
<p id="%E9%85%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#%E9%85%8D%E7%BD%AE" rel="nofollow">配置</a></p> 
<p id="Producer%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#Producer%E9%85%8D%E7%BD%AE" rel="nofollow">Producer配置</a></p> 
<p id="acks%EF%BC%9A-toc" style="margin-left:80px;"><a href="#acks%EF%BC%9A" rel="nofollow">acks：</a></p> 
<p id="batch.size-toc" style="margin-left:80px;"><a href="#batch.size" rel="nofollow">batch.size</a></p> 
<p id="Broker%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#Broker%E9%85%8D%E7%BD%AE" rel="nofollow">Broker配置</a></p> 
<p id="%E4%BC%98%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E4%BC%98%E5%8C%96" rel="nofollow">优化</a></p> 
<p id="producer%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%89%93%E5%85%A5%E9%80%9F%E5%BA%A6-toc" style="margin-left:40px;"><a href="#producer%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%89%93%E5%85%A5%E9%80%9F%E5%BA%A6" rel="nofollow">producer如何优化打入速度</a></p> 
<p id="consumer%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%B6%88%E8%B4%B9%E9%80%9F%E5%BA%A6-toc" style="margin-left:40px;"><a href="#consumer%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%B6%88%E8%B4%B9%E9%80%9F%E5%BA%A6" rel="nofollow">consumer如何优化消费速度</a></p> 
<p id="Kafka%E4%B8%AD%E7%9A%84ZooKeeper-toc" style="margin-left:0px;"><a href="#Kafka%E4%B8%AD%E7%9A%84ZooKeeper" rel="nofollow">Kafka中的ZooKeeper</a></p> 
<p id="%E7%AE%A1%E7%90%86%20Broker%20%E3%80%81Consumer%20Group%E3%80%81Consumer%E3%80%81Producer-toc" style="margin-left:40px;"><a href="#%E7%AE%A1%E7%90%86%20Broker%20%E3%80%81Consumer%20Group%E3%80%81Consumer%E3%80%81Producer" rel="nofollow">管理 Broker 、Consumer Group、Consumer、Producer</a></p> 
<p id="%E6%80%9D%E8%80%83-toc" style="margin-left:0px;"><a href="#%E6%80%9D%E8%80%83" rel="nofollow">思考</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88Kafka%E4%B8%8D%E6%94%AF%E6%8C%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88Kafka%E4%B8%8D%E6%94%AF%E6%8C%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9F" rel="nofollow">为什么Kafka不支持读写分离？</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>官方文档：</h2> 
<ul><li><a href="https://kafka.apache.org/documentation.html" rel="nofollow" title="Apache Kafka">Apache Kafka</a></li><li><a href="https://kafka.apachecn.org/documentation.html" rel="nofollow" title="Kafka 中文文档 - ApacheCN">Kafka 中文文档 - ApacheCN</a></li><li>重点关注 <a href="https://kafka.apachecn.org/documentation.html#design" rel="nofollow" title="4. 设计思想">4. 设计思想</a></li></ul> 
<h2 id="%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B%EF%BC%9A">一、简介：</h2> 
<ul><li>以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。</li></ul> 
<h3 id="%E9%AB%98%E6%80%A7%E8%83%BD">高性能</h3> 
<h4 id="%E5%88%86%E5%8C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1">分区的设计</h4> 
<p>负载均衡：</p> 
<ul><li>kafka将分区均匀地分布在Kafka集群中的每个服务器上，每个服务器在处理数据和请求时，共享这些分区。</li></ul> 
<p>分区容错性：</p> 
<ul><li>每一个分区都会在已配置的服务器上进行备份，当生产者向对应主题传递消息，消息通过负载均衡机制传递到不同的分区以减轻单个服务器实例的压力。</li></ul> 
<p>消费组并行消费：</p> 
<ul><li>一个Consumer Group中可以有多个consumer，多个consumer可以同时消费不同分区的消息，大大的提高了消费者的并行消费能力。注意：但是一个分区中的消息只能被一个Consumer Group中的一个consumer消费。</li></ul> 
<h4 id="%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99">顺序读写</h4> 
<ul><li>kafka将消息追加到日志文件中，利用了磁盘的顺序读写高效的特性，来提高读写效率。 
  <ul><li>磁盘的顺序写大多数情况下比随机写内存还要快。</li></ul></li></ul> 
<h4 id="%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF">零拷贝技术</h4> 
<ul><li>零拷贝将文件内容从磁盘(通过DMA引擎)复制到内核缓冲区，而且没有把数据复制到socket缓冲区，只是将数据位置和长度信息的描述符复制到了socket缓存区，然后直接将数据传输到网络接口，最后发送。</li><li>这样大大减小了拷贝的次数，提高了效率。</li><li> <p id="mmap%20%E5%92%8C%20sendfile%E6%80%BB%E7%BB%93"><strong>mmap 和 sendfile总结</strong></p> 
  <ul><li>都是Linux内核提供、实现零拷贝的API；</li><li>sendfile 是将读到内核空间的数据，转到socket buffer，进行网络发送；</li><li>mmap将磁盘文件映射到内存，支持读和写，对内存的操作会反映在磁盘文件上。（RocketMQ 在消费消息时，使用了 mmap）</li></ul></li><li>kafka中producer生产的数据持久化到broker，采用mmap文件映射，实现顺序的快速写入；</li><li>kafka中customer从broker读取数据，采用sendfile，将磁盘文件读到OS内核缓冲区后，直接转到socket buffer进行网络发送（调用linux系统给出的sendfile系统调用来使用零拷贝）。</li></ul> 
<h4 id="%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%8A%E7%9A%84%E5%BC%80%E9%94%80">减少网络传输上的开销</h4> 
<p id="%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%EF%BC%9A"><strong>批量发送：</strong></p> 
<ul><li>kafka会先将消息缓存在内存中，当超过一个的大小或者超过一定的时间，那么会将这些消息进行批量发送。 
  <ul><li>在发送消息的时候，kafka不会直接将少量数据发送出去，否则每次发送少量的数据会增加网络传输频率，降低网络传输效率。</li></ul></li></ul> 
<p id="%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8E%8B%E7%BC%A9%EF%BC%9A"><strong>端到端压缩：</strong></p> 
<ul><li> <p>kafka将批量的数据进行压缩后才会发送给broker服务器，数据在broker上还是一压缩的形式存储的，消费者拉取数据时也是直接获取这些压缩后的数据。这样整个传输过程中，数据都是以压缩后的形式来传输的。</p> </li></ul> 
<p></p> 
<p></p> 
<h2 id="%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%EF%BC%9A">基础组件：</h2> 
<h2 id="kafka%E8%8A%82%E7%82%B9%EF%BC%9Abroker">kafka节点：broker</h2> 
<ul><li>broker是消息的代理，producers往brokers里面的指定topic中写消息，consumers从brokers里面拉取指定topic的消息，然后进行业务处理，broker在中间起到一个代理保存消息的中转站。</li><li>一个kafka节点就是一个broker，多个broker组成一个Kafka集群。</li></ul> 
<h2 id="%E4%B8%BB%E9%A2%98%EF%BC%9Atopic">主题：topic</h2> 
<ul><li>逻辑上的概念，代表了一类消息，每个消息都会对应一个topic。</li></ul> 
<h2 id="%E5%88%86%E5%8C%BA%EF%BC%9Apartition">分区：partition</h2> 
<ul><li>物理上的概念，每个topic包含一个或多个partition，partition是用来存储消息的队列，同一个partition中消息是按序存储的。</li><li>parttion上的每条消息都会被分配一个唯一的偏离量(offset)，这个偏离量是从0开始递增的整数，我们可以通过&lt;topic,partition,offset&gt;三元组定位到任意一条消息。</li></ul> 
<p><img alt="" src="https://images2.imgbox.com/3e/85/QvPCYCuM_o.png"></p> 
<ul><li>作用：提高系统的吞吐量。每个单独的parttion都受限于主机的文件大小限制，一个topic可以有多个partition，因此kafka可以处理无限量的数据。</li><li>高可用：每个partition都是冗余存储的，每个partition都会有一个或多个副本(Replication)。</li></ul> 
<h2 id="%E5%89%AF%E6%9C%AC%EF%BC%9AReplication">副本：Replication</h2> 
<ul><li><strong>每个partition都有一个 leader replication（下文直接称为leader）和零或多个 followers replication（下文直接称为follower）。</strong></li><li><strong>所有的读写操作都由 leader</strong><strong>处理。</strong></li><li>各分区的 leader 均匀的分布在brokers 中。</li><li>replication 和 ZooKeeper 的连接没有断掉则认为replication是存活状态。</li></ul> 
<h3 id="%E5%90%8C%E6%AD%A5%E5%89%AF%E6%9C%AC%E9%9B%86%E5%90%88ISR%EF%BC%88in-sync%20replicas%EF%BC%89">同步副本集合ISR（in-sync replicas）<strong> </strong></h3> 
<h4 id="%E6%A6%82%E5%BF%B5%EF%BC%9A"><strong>概念：</strong></h4> 
<ul><li><strong>数据与leader保持同步的replication被称为同步状态的副本，</strong>所有同步状态的replication组成同步副本集合(a set of in-sync replicas) ，简称ISR。</li></ul> 
<h4 id="%E7%89%B9%E7%82%B9%EF%BC%9A"><strong>特点：</strong></h4> 
<ul><li><strong>ISR中的节点都是和 leader 保持高度一致的，只有ISR的成员才有资格被选举为 leader，一条消息必须被ISR中所有的副本读取并追加到日志中后，这条消息才能视为提交。</strong> 
  <ul><li>leader会追踪所有同步状态的replication，如果有replication挂掉了或比leader落后太多，则leader就会把它从ISR中移除。</li><li>ISR发生的变化会在 ZooKeeper 中进行持久化，正因为如此，ISR中的任何一个replication都有资格被选为 leader。</li></ul></li><li><strong>只要ISR至少有一个replication存活，那么提交的消息就不会丢失。</strong></li></ul> 
<h4 id="%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E5%89%AF%E6%9C%ACOSR%EF%BC%88Outof-sync%20Replicas%EF%BC%89">非同步状态副本OSR（Outof-sync Replicas）</h4> 
<ul><li>概念：非同步状态的replication组成的集合，简称OSR(Outof-Sync Replicas)。</li><li>说明： 
  <ul><li>新加入的follower replication会先存放在OSR中。</li><li>leader replication会将超过阈值的follower replication 踢出ISR，然后将其添加到 OSR中。</li></ul></li><li>AR（Assigned Replicas） 
  <ul><li>partition中所有的replication组成的集合称为 AR（Assigned Replicas）。</li><li>AR=ISR+OSR</li></ul></li></ul> 
<h3 id="partition%E4%B8%ADleader%20replication%E7%9A%84%E9%80%89%E4%B8%BE%EF%BC%9A"><strong>partition中leader replication的选举：</strong></h3> 
<h4 id="Kafka%20%E4%B8%BA%E4%BD%95%E4%B8%8D%E9%87%87%E7%94%A8%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E6%9C%BA%E5%88%B6(quorum%E7%AE%97%E6%B3%95)%E6%9D%A5%E9%80%89%E4%B8%BEleader%20%E3%80%82%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B"><strong>Kafka 为何不采用大多数投票机制(quorum算法)来选举leader 。</strong>​​​​​​​</h4> 
<ul><li>quorum算法的缺点是：冗余单点故障需要三份数据，冗余两个故障则需要五份的数据，quorum算法的代价是比较高的。故quorum算法常常用于数据量不大的共享集群配置(如 ZooKeeper)，而不适用于原始数据的存储。</li><li>如果kafka采用quorum算法，那么避免单点故障的代价就是系统吞吐量降低到1/3，这对于kafka这种处理海量数据的场景是不切实际的。</li></ul> 
<h4 id="Unclean%20%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE%EF%BC%88Unclean%20Leader%20Election%EF%BC%89"><strong>Unclean 领导者选举（Unclean Leader Election）</strong></h4> 
<ul><li>当ISR中所有的副本都挂掉时，kafka支持有两种策略： 
  <ul><li>等待一个 ISR 副本重新恢复正常服务，并选择这个副本作为领 leader，因为挂掉的ISR有极大可能拥有全部数据。</li><li>选择一个正常服务的OSR副本作为leader，这个选举的过程称为 <strong>Unclean 领导者选举。</strong></li></ul></li><li>开启 Unclean 领导者选举，不至于服务长时间宕机，提升了服务的高可用性，但是可能会造成数据丢失。</li><li>禁止 Unclean 领导者选举，可以避免消息丢失，保证数据的一致性，但是牺牲了服务的高可用性。</li></ul> 
<p></p> 
<h3 id="follower%E5%90%8C%E6%AD%A5leader%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A"><span style="color:#fe2c24;">follower同步leader的数据：</span></h3> 
<h4 id="%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%9A">同步方式：</h4> 
<ul><li>kafka认为ISR中的follower都同步完数据后，就认为消息被commit了，这样的方式很好的均衡了确保数据不丢失以及吞吐率。 
  <ul><li>若所有follower都复制完才认为消息被commit，则严重影响kafka集群的吞吐率。</li><li>若leader写入log后消息就被认为commit，则当leader挂掉后，会造成数据丢失。</li></ul></li></ul> 
<h4 id="%E4%BC%98%E7%82%B9%EF%BC%9A">优点：</h4> 
<ul><li>follower可以批量的从leader复制数据，而且leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大减少了follower与leader的消息量差。</li></ul> 
<h3 id="%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%EF%BC%9A">常见配置：</h3> 
<ul><li>两个集群，每个集群n个分区，每个分区两个同步副本(ISR集合大小为2)</li></ul> 
<h2 id="producer"><br> producer</h2> 
<p>概念：消息生产者，向broker发送消息的客户端。</p> 
<h3 id="%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%96%B9%E5%BC%8F%EF%BC%9A"><strong>数据发送方式：</strong></h3> 
<ul><li><strong>producer 把数据 push 到 broker，然后 consumer 从 broker 中 pull 数据。</strong></li></ul> 
<p>特点：可以大批量生产要发送给 consumer 的数据。</p> 
<p></p> 
<p></p> 
<h2 id="consumer">consumer</h2> 
<h3 id="%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F%EF%BC%9A">接收数据方式：</h3> 
<ul><li> <p>kafka consumer采用拉模式(pull-based)消费消息，consumer通过向 broker 发出一个“fetch”请求来获取它想要消费的 partition。</p> </li></ul> 
<h4 id="%E6%8B%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A">拉模式的优点：</h4> 
<ul><li> <p>consumer 可自主控制消费消息的速率，同时 Consumer 可以自己控制消费方式——即可批量消费也可逐条消费。</p> </li><li> <p>支持消息回溯：consumer请求时会指定partition对应的offset，并接收从该位置开始的一大块数据。通过这样的方式，consumer可以在需要的时候通过回退到该位置再次消费对应的数据。</p> </li></ul> 
<h4 id="%E6%8E%A8%E6%A8%A1%E5%BC%8F(push-based)%E6%B6%88%E8%B4%B9%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A">推模式(push-based)消费的缺点：</h4> 
<ul><li>推模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。</li><li>推模式的目标是尽可能以最快速度传递消息，但是这样很容易造成 Consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。</li></ul> 
<h3 id="consumer%20group">consumer group</h3> 
<p>概念：</p> 
<ul><li> <p>每个consumer属于一个特定的consumer group，一条消息可以发送到多个不同的consumer group，但是同一个consumer group中只能有一个consumer能够消费该消息。</p> </li></ul> 
<p>说明：</p> 
<ul><li>kafka默认一个partition在同一个group内只能被一个consumer消费，将partition调整为1可以保证topic中所有的消息有序。</li><li>consumer group中consumer的数量通常不超过partition的数量。</li></ul> 
<p></p> 
<h2 id="%E9%85%8D%E7%BD%AE">配置</h2> 
<ul><li>文档：<a href="https://kafka.apachecn.org/documentation.html#configuration" rel="nofollow" title="Kafka 中文文档 - ApacheCN">Kafka 中文文档 - ApacheCN</a></li></ul> 
<h3 id="Producer%E9%85%8D%E7%BD%AE">Producer配置</h3> 
<h4 id="acks%EF%BC%9A">acks：</h4> 
<p>概念：</p> 
<ul><li>此配置是 Producer 在确认一个请求发送完成之前需要收到的反馈信息的数量，这个配置是为了保证发送请求的可靠性。</li></ul> 
<p>取值：</p> 
<ul><li><code>acks=0：</code>producer 不会等待服务器的反馈。该消息会被立刻添加到 socket buffer 中并认为已经发送完成。在这种情况下，服务器是否收到请求是没法保证的，并且参数<code>retries</code>也不会生效（因为客户端无法获得失败信息）。每个记录返回的 offset 总是被设置为-1。</li><li><code>acks=1：</code>leader节点会将记录写入本地日志，并且在所有 follower 节点反馈之前就先确认成功。在这种情况下，如果 leader 节点在接收记录之后，并且在 follower 节点复制数据完成之前产生错误，则这条记录会丢失。</li><li><strong><code>acks=all 或 </code>acks=-1<code>：</code>leader节点会等待所有同步状态的副本确认之后再确认这条记录是否发送完成。只要至少有一个同步副本存在，记录就不会丢失。这种方式是对请求传递的最有效保证。</strong>。</li></ul> 
<h4 id="batch.size">batch.size</h4> 
<p>概念：</p> 
<ul><li>将多个记录被发送到同一个分区时， producer会将多个记录组合到一个请求中发送。批量发送的方式有助于提高生产者和消费者的性能。</li><li>batch.size 控制一个批次的默认大小，单位是字节。</li></ul> 
<p>取值：</p> 
<ul><li>当记录的大小超过了配置的字节数， producer 将不再尝试往批次增加记录。</li><li>batch.size如果设置的太小，可能会降低吞吐量（batch.size=0 表示禁用批处理)。</li><li>batch.size如果设置的太大，可能造成内存浪费。</li></ul> 
<h3 id="Broker%E9%85%8D%E7%BD%AE">Broker配置</h3> 
<ul><li> <p>num.replica.fetchers：从源broker复制消息的拉取器的线程数。增加这个值可以增加follow broker的I/O并行度。</p> </li><li> <p>unclean.leader.election.enable：控制是否允许 Unclean 领导者选举。</p> </li></ul> 
<p></p> 
<h2 id="%E4%BC%98%E5%8C%96">优化</h2> 
<h3 id="producer%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%89%93%E5%85%A5%E9%80%9F%E5%BA%A6"><strong>producer如何优化打入速度</strong></h3> 
<ul><li>增加更多 producer 实例、增加分区(partition)数量。</li><li>适当调大 batch.size</li><li>跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。        </li></ul> 
<h3 id="consumer%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%B6%88%E8%B4%B9%E9%80%9F%E5%BA%A6"><strong>consumer如何优化消费速度</strong></h3> 
<ul><li>并行消费：consumer收到消息后，将消费逻辑放到线程池中并行执行。</li></ul> 
<p></p> 
<h2 id="Kafka%E4%B8%AD%E7%9A%84ZooKeeper">Kafka中的ZooKeeper</h2> 
<h3 id="%E7%AE%A1%E7%90%86%20Broker%20%E3%80%81Consumer%20Group%E3%80%81Consumer%E3%80%81Producer">管理 Broker 、Consumer Group、Consumer、Producer</h3> 
<p>目录：<a href="https://kafka.apachecn.org/documentation.html#impl_zookeeper" rel="nofollow" title="Kafka 中文文档 - ApacheCN">Kafka 中文文档 - ApacheCN</a></p> 
<ul><li> <p>记录Broker</p> 
  <ul><li> <p>路径为 <code>/brokers，</code>Kafka 会将该 Broker 相关的信息存入其中，包括 <code>broker.name</code> 、端口号。</p> </li></ul></li><li> <p>记录topic：</p> 
  <ul><li> <p>路径为/brokers/topics/{topic_name} 。</p> </li></ul></li><li> <p>记录Consumer Group</p> 
  <ul><li> <p>Consumer Group 注册路径为 <code>/consumers/{group_id}，该节点是一个目录</code></p> </li></ul></li><li> <p>记录Consumer</p> 
  <ul><li> <p>路径 <code>/consumers/{group_id}/ids/{c</code>onsumer_id<code>}</code></p> </li></ul></li><li> <p>记录消费进度 Offset</p> 
  <ul><li> <p>路径：/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</p> </li><li> <p>说明：节点内容就是Offset的值。</p> </li><li> <p>在 Kafka 的最新版本 Kafka 2.0 中，Offset 信息不再记录于 ZooKeeper，而是保存于 Kafka 的 Topic 中，路径如下：__consumer_offsets(/brokers/topics/__consumer_offsets)</p> </li></ul></li><li> <p>记录 Partition 与 Consumer 的关系：</p> 
  <ul><li> <p>同一个 Group 订阅的 Topic 下的任一 Partition 都只能分配给一个 Consumer。</p> </li><li> <p>路径：/consumers/[group_id]/owners/[topic]/[broker_id-partition_id] 该节点为临时节点。</p> </li></ul></li><li> <p>Producers 启动后同样也要进行注册（依然是创建一个专属的临时节点）</p> </li></ul> 
<p></p> 
<h2 id="%E6%80%9D%E8%80%83">思考</h2> 
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88Kafka%E4%B8%8D%E6%94%AF%E6%8C%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9F">为什么Kafka不支持读写分离？</h3> 
<ul><li>在Kafka集群中，如果存在多个副本，经过合理的配置，可以让leader副本均匀的分布在各个broker上面，使每个 broker 上的读写负载都是一样的，故也就没有必要支持读写分离了。</li><li>另一方面：读写分离还会带来主从延迟的问题，这样就更加没有理由要支持读写分离了。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e13c59d61a868d3a88986f7bbbe7b32f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Javascript中Json的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/feeb360d38064fe9d0400b3ac51d4719/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VMware虚拟机扩展磁盘容量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>