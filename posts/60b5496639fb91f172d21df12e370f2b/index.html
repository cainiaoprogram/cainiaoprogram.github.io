<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（十一）51单片机——用AT24C02实现存储秒表数据（附成果展示） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（十一）51单片机——用AT24C02实现存储秒表数据（附成果展示）" />
<meta property="og:description" content="目录
存储器
RAM
ROM
存储器简化模型
AT24C02介绍
引脚及应用电路
内部结构框图
I２C总线
I2C总线介绍
I2C电路规范
I2C时序结构
起始条件
终止条件
发送一个字节 接受一个字节 发送应答 接收应答
I2C数据帧
AT24C02数据帧
字节写
随机读
代码部分
遇到的问题 代码 硬件
今天我们来介绍一下AT24C02，首先呢，它是一种可以实现掉电不丢失的存储器，可用于保存单片机运行时想要永久保存的数据信息，在介绍AT24C02之前，我们先来介绍一下存储器！
存储器 先来简单介绍一下RAM（随机存储器）以及ROM（只读存储器）的优缺点吧！
优点缺点RAM储存速度快掉电丢失ROM存储速度慢掉电不丢失 RAM RAM主要分为SRAM（静态RAM）和DRAM（动态RAM），SRAM主要用于电脑CPU以及我们的单片机CPU；而DRAM主要用在电脑内存条以及手机的运行内存，因为电容器会掉电，所以需要不断进行扫描。
组成优点缺点SRAM触发器存储速度较快容量小，成本较高DRAM电容存储速度较慢容量大，成本较低 ROM ROM主要分为Mask ROM（掩膜ROM），PROM（可编程ROM），EPROM（可擦除可编程ROM ），E2PROM （电可擦除可编程ROM ），这四个是一家的，还有Flash（闪存），硬盘、软盘、光盘等，其中Flash目前使用十分广泛，基本上打败了ROM一家。
特点Mask ROM只能读PROM可以写，但只能一次EPROM可以写多次，但要紫外线照射３０分钟E2PROM可以写多次，并且只要几毫秒即可Flash与E２PROM类似，但集成度更高硬盘、软盘、光盘等软盘和光盘目前见的比较少了 存储器简化模型 这个地方涉及到了数电的知识，稍后会出数电寄存器一章的笔记，目前我们只能简单的讲解一下。左边是地址总线，下面是数据总线，首先我们选择地址总线，比如像赋值１０００００００，相当于打开了第一行，之后选择连接的结点（之前都没有连接上），将其连上，Mask　ROM使用的方法是一个二极管（这么做的原因是防止电流经过上面的节点导致数据混乱），而PROM使用了两个二极管（一个二极管和保险丝），但是其中一个二极管（保险丝）比较容易击穿，当给高电压的时候，蓝色电容（保险丝熔断）击穿，实现数据写入。这也是我们“烧录”的由来，然后我们现在的就是属于给电之后会恢复，实现反复写入，具体是怎么样的，我们在稍后的数电笔记中进行详细的介绍。 AT24C02介绍 接下来我们来简单介绍一下AT24C02吧！ AT24C02是一种可以实现掉电不丢失的存储器，可用于保存单片机运行时想要永久保存的数据信息存储介质：E2PROM通讯接口：I2C总线容量：256字节 引脚及应用电路 内部结构框图 接下来我们来简单的介绍一下内部结构，我们从每个部分进行讲解！
第一个就是我们刚刚介绍的存储器简化模型那样，网状结构第二个是一个译码器，用于输入地址第三个是输入输出端，通过Y　DEC将数据输出第四个也是译码器，用来帮助MUX输出数据，然后就直接输出数据第五个是用来擦除数据用的第六个是用来设置地址的，里面有个寄存器是用来存储地址的，每写入和读出寄存器自动加一，读出不指定地址，默认拿出寄存器的地址第七个是开始结束逻辑第八个是一个地址比较器第九个是一个控制串行逻辑 I２C总线 I2C总线介绍 I2C总线(Inter IC BUS)是由Philips公司开发的一种通用数据总线两根通信线:SCL(Serial Clock)、SDA(Serial Data)同步、半双工，带数据应答通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度 I2C电路规范 其中一个IC的内部结构
我们来抽象一下I2C的通信方式
通信规则：
1、杠子在上方代表1，下方代表0
2、每个人只能拉杆子或者松开手
3、每个人需要地址进行通信
I2C时序结构 接下来我们来介绍一下六个时序结构，只要集齐了这六个时序结构，就可以召唤数据帧了！
起始条件 起始条件：SCL高电平期间，SDA从高电平切换到低电平（相当于告诉大家我要发送信息了） 终止条件 终止条件：SCL高电平期间，SDA从低电平切换到高电平（相当于告诉大家我要停止了）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/60b5496639fb91f172d21df12e370f2b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-21T19:20:50+08:00" />
<meta property="article:modified_time" content="2022-07-21T19:20:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（十一）51单片机——用AT24C02实现存储秒表数据（附成果展示）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%AD%98%E5%82%A8%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%AD%98%E5%82%A8%E5%99%A8" rel="nofollow">存储器</a></p> 
<p id="RAM-toc" style="margin-left:40px;"><a href="#RAM" rel="nofollow">RAM</a></p> 
<p id="ROM-toc" style="margin-left:40px;"><a href="#ROM" rel="nofollow">ROM</a></p> 
<p id="%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%80%E5%8C%96%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%80%E5%8C%96%E6%A8%A1%E5%9E%8B" rel="nofollow">存储器简化模型</a></p> 
<p id="AT24C02%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#AT24C02%E4%BB%8B%E7%BB%8D" rel="nofollow">AT24C02介绍</a></p> 
<p id="%C2%A0%E5%BC%95%E8%84%9A%E5%8F%8A%E5%BA%94%E7%94%A8%E7%94%B5%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%BC%95%E8%84%9A%E5%8F%8A%E5%BA%94%E7%94%A8%E7%94%B5%E8%B7%AF" rel="nofollow"> 引脚及应用电路</a></p> 
<p id="%C2%A0%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE" rel="nofollow"> 内部结构框图</a></p> 
<p id="I%EF%BC%92C%E6%80%BB%E7%BA%BF-toc" style="margin-left:0px;"><a href="#I%EF%BC%92C%E6%80%BB%E7%BA%BF" rel="nofollow">I２C总线</a></p> 
<p id="I2C%E6%80%BB%E7%BA%BF%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#I2C%E6%80%BB%E7%BA%BF%E4%BB%8B%E7%BB%8D" rel="nofollow">I2C总线介绍</a></p> 
<p id="I2C%E7%94%B5%E8%B7%AF%E8%A7%84%E8%8C%83-toc" style="margin-left:40px;"><a href="#I2C%E7%94%B5%E8%B7%AF%E8%A7%84%E8%8C%83" rel="nofollow">I2C电路规范</a></p> 
<p id="%C2%A0I2C%E6%97%B6%E5%BA%8F%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%C2%A0I2C%E6%97%B6%E5%BA%8F%E7%BB%93%E6%9E%84" rel="nofollow">I2C时序结构</a></p> 
<p id="%E8%B5%B7%E5%A7%8B%E6%9D%A1%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%E8%B5%B7%E5%A7%8B%E6%9D%A1%E4%BB%B6" rel="nofollow">起始条件</a></p> 
<p id="%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6" rel="nofollow">终止条件</a></p> 
<p id="%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%C2%A0" rel="nofollow">发送一个字节 </a></p> 
<p id="%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%C2%A0" rel="nofollow">接受一个字节 </a></p> 
<p id="%E5%8F%91%E9%80%81%E5%BA%94%E7%AD%94%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%8F%91%E9%80%81%E5%BA%94%E7%AD%94%C2%A0" rel="nofollow">发送应答 </a></p> 
<p id="%E6%8E%A5%E6%94%B6%E5%BA%94%E7%AD%94-toc" style="margin-left:80px;"><a href="#%E6%8E%A5%E6%94%B6%E5%BA%94%E7%AD%94" rel="nofollow">接收应答</a></p> 
<p id="I2C%E6%95%B0%E6%8D%AE%E5%B8%A7-toc" style="margin-left:40px;"><a href="#I2C%E6%95%B0%E6%8D%AE%E5%B8%A7" rel="nofollow">I2C数据帧</a></p> 
<p id="AT24C02%E6%95%B0%E6%8D%AE%E5%B8%A7-toc" style="margin-left:40px;"><a href="#AT24C02%E6%95%B0%E6%8D%AE%E5%B8%A7" rel="nofollow">AT24C02数据帧</a></p> 
<p id="%E5%AD%97%E8%8A%82%E5%86%99-toc" style="margin-left:80px;"><a href="#%E5%AD%97%E8%8A%82%E5%86%99" rel="nofollow">字节写</a></p> 
<p id="%E9%9A%8F%E6%9C%BA%E8%AF%BB-toc" style="margin-left:80px;"><a href="#%E9%9A%8F%E6%9C%BA%E8%AF%BB" rel="nofollow">随机读</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86-toc" style="margin-left:0px;"><a href="#%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86" rel="nofollow">代码部分</a></p> 
<p id="%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:0px;"><a href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">遇到的问题 </a></p> 
<p id="%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">代码 </a></p> 
<p id="%E7%A1%AC%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%E7%A1%AC%E4%BB%B6" rel="nofollow">硬件</a></p> 
<hr id="hr-toc"> 
<p>    </p> 
<p>        今天我们来介绍一下AT24C02，首先呢，它是一种<span style="color:#000000;">可以实现掉电不丢失的<strong>存储器</strong>，可用于保存单片机运行时想要永久保存的数据信息，在介绍</span>AT24C02之前，我们<span style="color:#000000;">先来介绍一下存储器！</span></p> 
<h2 id="%E5%AD%98%E5%82%A8%E5%99%A8"><span style="color:#000000;">存储器</span></h2> 
<p><img alt="" height="721" src="https://images2.imgbox.com/6a/10/QMhEEsrk_o.png" width="1167"></p> 
<p>        先来简单介绍一下<strong>RAM</strong>（随机存储器）以及<strong>ROM</strong>（只读存储器）的优缺点吧！</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><th>RAM</th><td>储存速度快</td><td>掉电丢失</td></tr><tr><th>ROM</th><td>存储速度慢</td><td>掉电不丢失</td></tr></tbody></table> 
<h3 id="RAM">RAM</h3> 
<p>        RAM主要分为SRAM（静态RAM）和DRAM（动态RAM），SRAM主要用于电脑CPU以及我们的单片机CPU；而DRAM主要用在电脑内存条以及手机的运行内存，因为电容器会掉电，所以需要不断进行扫描。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th></th><th>组成</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><th>SRAM</th><td>触发器</td><td>存储速度较快</td><td>容量小，成本较高</td></tr><tr><th>DRAM</th><td>电容</td><td>存储速度较慢</td><td>容量大，成本较低</td></tr></tbody></table> 
<h3 id="ROM">ROM</h3> 
<p>        ROM主要分为<span style="color:#0d0016;">Mask ROM（掩膜ROM），PROM（可编程ROM），EPROM（可擦除可编程ROM<span style="color:#ffffff;"> </span>），E2PROM （电可擦除可编程ROM ），这四个是一家的，还有Flash（闪存），硬盘、软盘、光盘等，其中Flash目前使用十分广泛，基本上打败了ROM一家。</span></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th></th><th>特点</th></tr></thead><tbody><tr><th><span style="color:#0d0016;">Mask ROM</span></th><td>只能读</td></tr><tr><th><span style="color:#0d0016;">PROM</span></th><td>可以写，但只能一次</td></tr><tr><th><span style="color:#0d0016;">EPROM</span></th><td>可以写多次，但要紫外线照射３０分钟</td></tr><tr><th><span style="color:#0d0016;">E2PROM</span></th><td>可以写多次，并且只要几毫秒即可</td></tr><tr><th><span style="color:#0d0016;">Flash</span></th><td>与E２PROM类似，但集成度更高</td></tr><tr><th><span style="color:#0d0016;">硬盘、软盘、光盘等</span></th><td>软盘和光盘目前见的比较少了</td></tr></tbody></table> 
<h3 id="%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%80%E5%8C%96%E6%A8%A1%E5%9E%8B">存储器简化模型</h3> 
<p><img alt="" height="582" src="https://images2.imgbox.com/b7/a5/l2jzFy8f_o.png" width="1189"><img alt="" height="741" src="https://images2.imgbox.com/87/ee/rqXpCSkZ_o.png" width="1190"></p> 
<blockquote> 
 <p>        这个地方涉及到了数电的知识，稍后会出数电寄存器一章的笔记，目前我们只能简单的讲解一下。左边是<strong>地址总线</strong>，下面是<strong>数据总线</strong>，首先我们选择地址总线，比如像赋值１０００００００，相当于打开了第一行，之后选择连接的结点（之前都没有连接上），将其连上，Mask　ROM使用的方法是一个二极管（这么做的原因是防止电流经过上面的节点导致数据混乱），而PROM使用了两个二极管（一个二极管和保险丝），但是其中一个二极管（保险丝）比较容易击穿，当给高电压的时候，蓝色电容（保险丝熔断）击穿，实现数据写入。这也是我们“烧录”的由来，然后我们现在的就是属于给电之后会恢复，实现反复写入，具体是怎么样的，我们在稍后的数电笔记中进行详细的介绍。 </p> 
</blockquote> 
<h2 id="AT24C02%E4%BB%8B%E7%BB%8D">AT24C02介绍</h2> 
<p>          接下来我们来简单介绍一下<span style="color:#000000;"><strong>AT24C02</strong>吧！</span> </p> 
<ul><li><span style="color:#000000;">AT24C02是一种可以实现掉电不丢失的存储器，可用于保存单片机运行时想要永久保存的数据信息</span></li><li><span style="color:#000000;">存储介质：E2PROM</span></li><li><span style="color:#000000;">通讯接口：I2C</span><span style="color:#000000;">总线</span></li><li><span style="color:#000000;">容量：256</span><span style="color:#000000;">字节</span></li></ul> 
<p><img alt="" height="297" src="https://images2.imgbox.com/cc/24/tieguLfI_o.png" width="1090"></p> 
<h3 id="%C2%A0%E5%BC%95%E8%84%9A%E5%8F%8A%E5%BA%94%E7%94%A8%E7%94%B5%E8%B7%AF"> 引脚及应用电路</h3> 
<p><img alt="" height="795" src="https://images2.imgbox.com/70/0f/uHSHkpi4_o.png" width="872"></p> 
<h3 id="%C2%A0%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE"><strong> 内部结构框图</strong></h3> 
<p><img alt="" height="588" src="https://images2.imgbox.com/32/3a/TNvX0Jqe_o.jpg" width="748"></p> 
<blockquote> 
 <p>接下来我们来简单的介绍一下内部结构，我们从每个部分进行讲解！</p> 
 <ol><li>第一个就是我们刚刚介绍的存储器简化模型那样，网状结构</li><li>第二个是一个译码器，用于输入地址</li><li>第三个是输入输出端，通过Y　DEC将数据输出</li><li>第四个也是译码器，用来帮助MUX输出数据，然后就直接输出数据</li><li>第五个是用来擦除数据用的</li><li>第六个是用来设置地址的，里面有个寄存器是用来存储地址的，每写入和读出寄存器自动加一，读出不指定地址，默认拿出寄存器的地址</li><li>第七个是开始结束逻辑</li><li>第八个是一个地址比较器</li><li>第九个是一个控制串行逻辑</li></ol> 
</blockquote> 
<h2 id="I%EF%BC%92C%E6%80%BB%E7%BA%BF">I２C总线</h2> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <ul><li style="margin-left:0px;"> <h3 id="I2C%E6%80%BB%E7%BA%BF%E4%BB%8B%E7%BB%8D">I2C总线介绍</h3> </li><li style="margin-left:0px;">I2C总线(Inter IC BUS)是由Philips公司开发的一种通用数据总线</li><li style="margin-left:0px;">两根通信线:SCL(Serial Clock)、SDA(Serial Data)</li><li style="margin-left:0px;">同步、半双工，带数据应答</li><li style="margin-left:0px;">通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度</li></ul> 
   <div> 
    <div style="margin-left:0in;"> 
     <div style="margin-left:0in;"> 
      <h3 id="I2C%E7%94%B5%E8%B7%AF%E8%A7%84%E8%8C%83" style="margin-left:0px;">I2C电路规范</h3> 
      <div> 
       <div style="margin-left:0in;"> 
        <div style="margin-left:0in;"> 
         <img alt="" height="1154" src="https://images2.imgbox.com/56/31/FkRoKVYg_o.png" width="972"> 
        </div> 
        <div style="margin-left:.0215in;"> 
         <p style="margin-left:0;text-align:center;"><strong>其中一个</strong><strong>IC</strong><strong>的内部结构</strong></p> 
         <div> 
          <div style="margin-left:0in;"> 
           <div style="margin-left:0in;"> 
            <p style="margin-left:0;"><img alt="" height="619" src="https://images2.imgbox.com/4c/7d/nVnKBvoI_o.png" width="914"></p> 
            <div> 
             <div style="margin-left:0in;"> 
              <div style="margin-left:.5833in;"> 
               <p style="margin-left:0px;text-align:center;">我们来抽象一下I2C的通信方式</p> 
              </div> 
              <div style="margin-left:0in;"> 
               <blockquote> 
                <p style="margin-left:0;">通信规则：</p> 
                <p style="margin-left:0;">1、杠子在上方代表1，下方代表0</p> 
                <p style="margin-left:0;">2、每个人只能拉杆子或者松开手</p> 
                <p style="margin-left:0;">3、每个人需要地址进行通信</p> 
               </blockquote> 
              </div> 
             </div> 
            </div> 
            <div> 
             <div style="margin-left:0in;"> 
              <div style="margin-left:0in;"> 
               <img alt="" height="657" src="https://images2.imgbox.com/0c/2c/D1p7TRGJ_o.png" width="817"> 
              </div> 
             </div> 
            </div> 
            <h3 id="%C2%A0I2C%E6%97%B6%E5%BA%8F%E7%BB%93%E6%9E%84">I2C时序结构</h3> 
            <blockquote> 
             <p style="margin-left:0;">        接下来我们来介绍一下六个时序结构，只要集齐了这六个时序结构，就可以召唤数据帧了！</p> 
            </blockquote> 
            <h4 id="%E8%B5%B7%E5%A7%8B%E6%9D%A1%E4%BB%B6">起始条件</h4> 
            <blockquote> 
             <p><span style="color:#000000;">        起始条件：SCL高电平期间，SDA从高电平切换到低电平（相当于告诉大家我要发送信息了）</span> </p> 
            </blockquote> 
           </div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
      <p style="margin-left:0;"></p> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <img alt="" height="860" src="https://images2.imgbox.com/c6/6a/PfLon2oX_o.png" width="1017"> 
  </div> 
 </div> 
</div> 
<h4 id="%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6">终止条件</h4> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#000000;">        终止条件：SCL高电平期间，SDA从低电平切换到高电平（相当于告诉大家我要停止了）</span></p> 
</blockquote> 
<p><img alt="" height="500" src="https://images2.imgbox.com/1c/62/vLmTkPKS_o.png" width="624"></p> 
<h4 id="%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%C2%A0">发送一个字节 </h4> 
<blockquote> 
 <p><span style="color:#000000;">        发送一个字节：SCL低电平期间，主机将数据位依次放到SDA线上（高位在前），然后拉高SCL，从机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节</span></p> 
</blockquote> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <img alt="" height="339" src="https://images2.imgbox.com/53/96/cwmQVrP0_o.png" width="968"> 
  </div> 
 </div> 
</div> 
<h4 id="%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%C2%A0">接受一个字节 </h4> 
<blockquote> 
 <p style="margin-left:0;">        接收一个字节：SCL低电平期间，从机将数据位依次放到SDA线上（高位在前），然后拉高SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）</p> 
</blockquote> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <img alt="" height="277" src="https://images2.imgbox.com/b5/0e/M1Ad6FBl_o.png" width="968"> 
  </div> 
 </div> 
</div> 
<h4 id="%E5%8F%91%E9%80%81%E5%BA%94%E7%AD%94%C2%A0">发送应答 </h4> 
<blockquote> 
 <p>        发送应答(SA)：在接收完一个字节之后，主机在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答（相当于一个回应）</p> 
</blockquote> 
<h4 id="%E6%8E%A5%E6%94%B6%E5%BA%94%E7%AD%94">接收应答</h4> 
<blockquote> 
 <p>        接收应答(RA)：在发送完一个字节之后，主机在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA） </p> 
</blockquote> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <p style="margin-left:0;"><img alt="" height="416" src="https://images2.imgbox.com/c2/2f/6iFvsPr0_o.png" width="1200"></p> 
  </div> 
 </div> 
</div> 
<h3 id="I2C%E6%95%B0%E6%8D%AE%E5%B8%A7">I2C数据帧</h3> 
<blockquote> 
 <p>        I2C数据帧其实就是上面六个部分拼合在一起，把数据帧拆分开来看，就比较好理解了。</p> 
</blockquote> 
<p><strong>发送一帧数据 </strong></p> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <img alt="" height="408" src="https://images2.imgbox.com/8d/6d/REExqZ62_o.png" width="968"> 
  </div> 
 </div> 
</div> 
<blockquote> 
 <p>        相当于老师在讲课，我们给老师回复</p> 
</blockquote> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <strong>接收一帧数据</strong> 
  </div> 
  <div style="margin-left:0in;"> 
   <img alt="" height="460" src="https://images2.imgbox.com/b4/20/fRFTe8UN_o.png" width="971"> 
  </div> 
 </div> 
</div> 
<blockquote> 
 <p>        相当于老师叫人回答问题 </p> 
</blockquote> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <strong>复合格式</strong> 
   <img alt="" height="457" src="https://images2.imgbox.com/cb/8b/VvM5LLQF_o.png" width="968"> 
  </div> 
 </div> 
</div> 
<blockquote> 
 <p>像是一个完整的回答过程，老师提出问题，学生回答 </p> 
</blockquote> 
<h3 id="AT24C02%E6%95%B0%E6%8D%AE%E5%B8%A7">AT24C02数据帧</h3> 
<blockquote> 
 <p>        AT24C02数据帧，其实不止这几个，但我们在这里就简单介绍一下这两种！</p> 
</blockquote> 
<h4 id="%E5%AD%97%E8%8A%82%E5%86%99"><span style="color:#000000;">字节写</span></h4> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#000000;">字节写：在</span><span style="color:#000000;">WORD A</span><span style="color:#0d0016;">DDRESS处写入数据DATA</span></p> 
</blockquote> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <img alt="" height="531" src="https://images2.imgbox.com/0b/1a/2ZtW2Njn_o.png" width="968"> 
  </div> 
 </div> 
</div> 
<h4 id="%E9%9A%8F%E6%9C%BA%E8%AF%BB"><span style="color:#000000;">随机读</span></h4> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#000000;">随机读：读出在WORD ADDRESS处的数据DATA</span></p> 
</blockquote> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><img alt="" height="224" src="https://images2.imgbox.com/69/87/Pp9hF5MT_o.png" width="1200"></p> 
<p style="margin-left:0;"></p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/61/42/rFWaCG3q_o.png" width="838"></p> 
<blockquote> 
 <p>        <span style="color:#0d0016;">AT24C02的固定地址为1010，可配置地址本开发板上为000，所以SLAVE ADDRESS+W为0xA0，SLAVE ADDRESS+R为0xA1</span></p> 
</blockquote> 
<h2 id="%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86">代码部分</h2> 
<blockquote> 
 <p><span style="color:#0d0016;">        这节内容的代码有一点点面向对象的思想，因为AT24C02的时序帧是根据I2C的六个时序结构拼接而成，所以AT24C02时序帧只需要将他们拼装起来，有点类似与接口和继承的味道，好了，我们先将代码给出！</span></p> 
</blockquote> 
<pre><code class="language-cpp">// I2C.c
#include &lt;REGX52.H&gt;
// 在引脚部分介绍过了，SCL是P21，SDA是P20；
sbit I2C_SCL=P2^1;
sbit I2C_SDA=P2^0;

// 单片机比较慢无需delay，这个就是按照时序图来的，按图来就行
/**
  * @brief  I2C开始
  * @param  无
  * @retval 无
  */
void I2C_Start(void)
{
	// 可以理解为初始化，确保一定为高电平
	I2C_SDA = 1;
	I2C_SCL = 1;
	// 按照时序图可得，先SDA为0，再SCL为0
	I2C_SDA = 0;
	I2C_SCL = 0;
}

/**
  * @brief  I2C停止
  * @param  无
  * @retval 无
  */
void I2C_Stop(void)
{
	I2C_SDA = 0;
	I2C_SCL = 1;
	I2C_SDA = 1;
}

/**
  * @brief  I2C发送一个字节
  * @param  Byte 要发送的字节
  * @retval 无
  */
void I2C_SendByte(unsigned char Byte)
{
	unsigned char i;
	for(i = 0;i &lt; 8;i++){
		I2C_SDA = Byte &amp; (0x80 &gt;&gt; i);
		I2C_SCL = 1;
		I2C_SCL = 0;
	}
}

/**
  * @brief  I2C接收一个字节
  * @param  无
  * @retval 接收到的一个字节数据
  */
unsigned char I2C_ReceiveByte(void)
{
	unsigned char i,Byte = 0x00;
	// 释放SDA
	I2C_SDA = 1;
	
	for(i = 0; i &lt; 8; i++)
	{
		I2C_SCL=1;
		if(I2C_SDA){Byte|=(0x80&gt;&gt;i);}
		I2C_SCL=0;
	}
	return Byte;
}

/**
  * @brief  I2C发送应答
  * @param  AckBit 应答位，0为应答，1为非应答
  * @retval 无
  */
void I2C_SendAck(unsigned char AckBit)
{
	I2C_SDA = AckBit;
	I2C_SCL = 1;
	I2C_SCL = 0;
}

/**
  * @brief  I2C接收应答位
  * @param  无
  * @retval 接收到的应答位，0为应答，1为非应答
  */
unsigned char I2C_ReceiveAck(void)
{
	unsigned char AckBit;
	// 释放SDA
	I2C_SDA = 1;
	I2C_SCL = 1;
	AckBit = I2C_SDA;
	I2C_SCL = 0;
	return AckBit;
}</code></pre> 
<hr> 
<pre><code class="language-cpp">// AT24C02.c
#include &lt;REGX52.H&gt;
#include "I2C.h"

// SLAVE ADDRESS+W为0xA0，SLAVE ADDRESS+R为0xA1
#define AT24C02_ADDRESS_READ		0xA0
#define AT24C02_ADDRESS_WRITE		0xA1

/**
  * @brief  AT24C02写入一个字节
  * @param  WordAddress 要写入字节的地址
  * @param  Data 要写入的数据
  * @retval 无
  */
void AT24C02_WriteByte(unsigned char WordAddress,Data)
{
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS_READ);
	I2C_ReceiveAck();
	I2C_SendByte(WordAddress);
	I2C_ReceiveAck();
	I2C_SendByte(Data);
	I2C_ReceiveAck();
	I2C_Stop();
}

/**
  * @brief  AT24C02读取一个字节
  * @param  WordAddress 要读出字节的地址
  * @retval 读出的数据
  */
unsigned char AT24C02_ReadByte(unsigned char WordAddress)
{
	unsigned char Data;
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS_READ);
	I2C_ReceiveAck();
	I2C_SendByte(WordAddress);
	I2C_ReceiveAck();
	I2C_Start();
	// 读地址
	I2C_SendByte(AT24C02_ADDRESS_WRITE);
	I2C_ReceiveAck();
	Data=I2C_ReceiveByte();
	I2C_SendAck(1);
	I2C_Stop();
	return Data;
}</code></pre> 
<hr> 
<blockquote> 
 <p>接下来我们使用这些代码实现一个数据储存器，代码如下所示：</p> 
</blockquote> 
<pre><code class="language-cpp">//main.c
#include &lt;REGX52.H&gt;
#include "LCD1602.h"
#include "Key.h"
#include "Delay.h"
#include "AT24C02.h"

void main(){
	unsigned char KeyNum;
	unsigned int Num;
	LCD_Init();
	LCD_ShowNum(1,1,0,5);
	while(1){
		KeyNum = Key();
		if(KeyNum == 1)
		{
			Num++;
			LCD_ShowNum(1,1,Num,5);
		}
		if(KeyNum == 2)
		{
			Num--;
			LCD_ShowNum(1,1,Num,5);
		}
		if(KeyNum == 3)
		{
			AT24C02_WriteByte(0,Num%256);// 取低八位
			Delay(5);// 因为读周期为5毫秒，如果不延时，将读不出结果
			AT24C02_WriteByte(1,Num/256);// 取高八位
			Delay(5);
			LCD_ShowString(2,1,"Write OK");
			Delay(1000);
			LCD_ShowString(2,1,"          ");
		}
		if(KeyNum == 4)
		{
			Num = AT24C02_ReadByte(0);// 读低八位
			Num |= AT24C02_ReadByte(1) &lt;&lt; 8;// 读高八位
			LCD_ShowNum(1,1,Num,5);
			LCD_ShowString(2,1,"Read OK");
			Delay(1000);
			LCD_ShowString(2,1,"          ");

		}
	}
}</code></pre> 
<p>运行效果如下所示：</p> 
<div class="csdn-video-box"> 
 <iframe id="Dt9PZQF5-1658400678278" frameborder="0" src="https://live.csdn.net/v/embed/225848" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p>AT24C02存储</p> 
</div> 
<hr> 
<blockquote> 
 <p>        接下来，我们将会改进之前动态数码管的实现，使用定时器来扫描，然后实现一个具有记忆功能的秒表。</p> 
</blockquote> 
<p><strong>思路 </strong></p> 
<blockquote> 
 <p style="margin-left:0;">        我们使用定时器来扫描按键以及数码管，所以按键以及数码管都需要用到定时器的功能，具体内容如下所示：</p> 
</blockquote> 
<p></p> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <img alt="" height="487" src="https://images2.imgbox.com/dc/ca/NSbND0LU_o.png" width="751"> 
  </div> 
 </div> 
</div> 
<blockquote> 
 <p style="margin-left:0;">        但我们只有一个中断函数，这样很容易出错，而且不能达到目的，并且代码耦合性过高，所以我们采用另一种方式，如下所示。就是将定时函数放到主函数里面去，再每隔一段时间调用各个部分的函数以达到目的，好了，接下来我们看看代码是如何实现的吧！</p> 
</blockquote> 
<div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <img alt="" height="487" src="https://images2.imgbox.com/70/12/HX7jI9QR_o.png" width="727"> 
  </div> 
 </div> 
</div> 
<pre><code class="language-cpp">//Nixie.c
#include &lt;REGX52.H&gt;
#include "Delay.h"

// 存放数码管显示缓存区
unsigned char Nixie_Buf[9] = {0, 10, 10, 10, 10, 10, 10, 10, 10};
/**
  * @brief  设置显示缓存区
  * @param  Location 要设置的位置，范围：1~8
  * @param  Number 要设置的数字，范围：段码表索引范围
  * @retval 无
  */
void  Nixie_SetBuf(unsigned char Location, unsigned char Number)
{
	Nixie_Buf[Location] = Number;
}

/**
  * @brief  数码管扫描显示
  * @param  Location 要显示的位置，范围：1~8
  * @param  Number 要显示的数字，范围：段码表索引范围
  * @retval 无
  */

void Nixie_Scan(unsigned char Location, unsigned char Number)
{
	unsigned char NixieTable[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x00,0x40};
	P0 = 0x00;//段码清0，消影
	switch(Location)//位码输出
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0 = NixieTable[Number];//段码输出
}
// 数码管扫描
void Nixie_Loop(void)
{
	static unsigned char i = 1;
	Nixie_Scan(i,Nixie_Buf[i]);
	i++;
	if(i&gt;=9){i = 1;}
}</code></pre> 
<hr> 
<pre><code class="language-cpp">//Key.c
#include &lt;REGX52.H&gt;
#include "Delay.h"

unsigned char Key_KeyNumber;
/**
  * @brief  获取独立按键键码
  * @param  无
  * @retval 按下按键的键码，范围：0~4，无按键按下时返回值为0
  */
unsigned char Key_GetState()
{
	unsigned char KeyNumber=0;
	
	if(P3_1==0){KeyNumber=1;}
	if(P3_0==0){KeyNumber=2;}
	if(P3_2==0){KeyNumber=3;}
	if(P3_3==0){KeyNumber=4;}
	
	return KeyNumber;
}
// 循环调用函数，用来判断哪个键被按下
void Key_Loop(void)
{
	static unsigned char NowState, LastState;
	LastState = NowState;
	NowState = Key_GetState();
	// 上一次按键1被按下，然后按键松开，完成一次按键识别
	if(LastState == 1 &amp;&amp; NowState == 0)
	{
		Key_KeyNumber = 1;
	}
	if(LastState == 2 &amp;&amp; NowState == 0)
	{
		Key_KeyNumber = 2;
	}
	if(LastState == 3 &amp;&amp; NowState == 0)
	{
		Key_KeyNumber = 3;
	}
	if(LastState == 4 &amp;&amp; NowState == 0)
	{
		Key_KeyNumber = 4;
	}
}
unsigned char Key(void){
	unsigned char Temp = 0;
	Temp = Key_KeyNumber;
	// 将Key_KeyNumber置0，因为Key_KeyNumber不会刷新
	Key_KeyNumber = 0;
	return Temp;
}</code></pre> 
<hr> 
<pre><code class="language-cpp">//main.c
#include &lt;REGX52.H&gt;
#include "Time0.h"
#include "Key.h"
#include "Nixie.h"
#include "Delay.h"
#include "AT24C02.h"

unsigned char KeyNum,Min, Sec, MiniSec,RunFlag;

void main(){
	Timer0_Init();
	while(1){
		KeyNum = Key();
		if(KeyNum == 1)//K1按键按下
		{
				RunFlag =!RunFlag;//启动标志位翻转
		}
		if(KeyNum == 2)//K2按键按下
		{
			//分秒清0
				Min = 0;
			Sec = 0;
			MiniSec = 0;
		}
		if(KeyNum == 3)//K3按键按下
		{
			//将分秒写入AT24C02
				AT24C02_WriteByte(0,Min);
			Delay(5);
			AT24C02_WriteByte(1,Sec);
			Delay(5);
			AT24C02_WriteByte(2,MiniSec);
			Delay(5);
		}
		if(KeyNum == 4)//K4按键按下
		{
			//读出AT24C02数据
				Min = AT24C02_ReadByte(0);
				Sec = AT24C02_ReadByte(1);
				MiniSec = AT24C02_ReadByte(2);
		}
		//设置显示缓存，显示数据
			Nixie_SetBuf(1,Min/10);
			Nixie_SetBuf(2,Min%10);
			Nixie_SetBuf(3,11);
			Nixie_SetBuf(4,Sec/10);
			Nixie_SetBuf(5,Sec%10);
			Nixie_SetBuf(6,11);
			Nixie_SetBuf(7,MiniSec/10);
			Nixie_SetBuf(8,MiniSec%10);

	}
}

void Sec_Loop(void)
{
	if(RunFlag){
	MiniSec++;
	if(MiniSec &gt;= 100)
	{
		MiniSec = 0;
		Sec++;
		if(Sec&gt;=60)
		{
			Sec = 0;
			Min++;
			if(Min&gt;=60)
			{
				Min = 0;
			}
		}
	}
}
}


// 定时函数里面的函数千万不能有延时，因为每一毫秒都要进来一次，会卡住
void Timer0_Routine() interrupt 1
{
	static unsigned int T0Count,T0Count1,T0Count2;
	TL0 = 0x66;		//设置定时初始值
	TH0 = 0xFC;	
	// 20ms一次按键扫描
	T0Count++;
	if(T0Count &gt;= 20){
		T0Count = 0;		
		Key_Loop();
	}
	// 2ms一次数码管扫描
	T0Count1++;
	if(T0Count1 &gt;= 2){
		T0Count1 = 0;		
		Nixie_Loop();
	}
	//10ms调用一次数秒表驱动函数
	T0Count2++;
	if(T0Count2 &gt;= 10){
		T0Count2 = 0;		
		Sec_Loop();
	}
}</code></pre> 
<p>运行结果如下所示：</p> 
<div class="csdn-video-box"> 
 <iframe id="qd8mt0dU-1658401499157" frameborder="0" src="https://live.csdn.net/v/embed/226015" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p>秒表</p> 
</div> 
<blockquote> 
 <p>        好了，我们关于AT24C02的知识点就先介绍到这里，接下来还会继续分享关于51单片机的知识！</p> 
</blockquote> 
<h2 id="%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0">遇到的问题 </h2> 
<h3 id="%E4%BB%A3%E7%A0%81%C2%A0">代码 </h3> 
<blockquote> 
 <p>        编写程序的整个过程中，不小心在中途把Keil的一些启动文件给删了，然后花了一小时重新下载；而且因为这次涉及的模块比较多，而且采用了定时器扫描的思路，导致编写代码过程比较艰难，但不断调试和细心纠错，还是能慢慢找到问题的。 </p> 
</blockquote> 
<h3 id="%E7%A1%AC%E4%BB%B6">硬件</h3> 
<blockquote> 
 <p>        第一次使用单片机的时候就烧坏过CPU，然后点阵屏也出过问题，然后这次编写代码过程中LCD1602以及数码管也出了问题，一直没有办法，都准备换一个单片机了，最后移动了一下CPU，就恢复了，硬件出问题，真的太痛苦了。 </p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/588dcaded97c23e8f19529e1553c0425/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows C/C&#43;&#43; 开发环境搭建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a98939e3679113e6a2f594322a187b16/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring框架AOP学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>