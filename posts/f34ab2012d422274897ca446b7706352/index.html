<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Note详细图解】中缀表达式如何转为后缀表达式？数据结构 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Note详细图解】中缀表达式如何转为后缀表达式？数据结构" />
<meta property="og:description" content="中缀表达式 中缀表达式（中缀记法）是一个通用的算术或逻辑公式表示方法，操作符是以中缀形式处于操作数的中间（例：3 &#43; 4），中缀表达式是人们常用的算术表示方法。
前缀或后缀记法不同的是，中缀记法中括号是必需的。计算过程中必须用括号将操作符和对应的操作数括起来，用于指示运算的次序。
后缀表达式 逆波兰表示法（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。
中缀表达式转后缀表达式 中缀转后缀思路 初始化两个栈：运算符栈S1；操作数栈S2从左向右扫描中缀表达式遇到操作数时，将其压入到操作数栈S2遇到运算符时，比较其与运算符栈S1栈顶运算符的优先级如果运算符栈S1为空，或栈顶运算符为左括号“ ( ”，或者优先级比栈顶运算符的优先级较高，则直接将此运算符压入栈中否则，将运算符栈S1中栈顶的运算符弹入并压到操作数栈S2中，再次进行与运算符栈S1栈顶运算符的优先级比较遇到括号时，如果遇到了左括号“ ( ”，则直接压入运算符栈S1；如果遇到右括号“ ) ”，则依次弹出运算符栈S1栈顶的运算符，并压入操作数栈S2，直到遇到左括号&#34; ( &#34;为止，此时将这一对括号丢弃重复步骤2至8，直到表达式的最右边将运算符栈S1剩余的运算符依次弹出并压入操作数栈S2拼接操作数栈S2中的元素并输出，结果即为中缀表达式所对应的后缀表达式 中缀转后缀图示 下图是以9-2*3&#43;(5-2)*2为例子的完整过程。
中缀转后缀流程图 中缀转后缀代码分析 主函数 先初始化一下需要转化为后缀记法的字符串，然后给一个用来存储后缀表达式的数组，假设中缀转后缀的函数为MidtoLast，给这个函数传入中缀表达式的字符数组midstr，以及存储后缀表达式的字符数组laststr：
int main() { char midstr[] = &#34;9-2*3&#43;(5-2)*2&#34;;//中缀表达式 printf(&#34;中缀表达式为：%s\n&#34;, midstr); char laststr[100];//后缀表达式 MidtoLast(laststr, midstr); printf(&#34;后缀表达式为：%s\n&#34;, laststr); return 0; } 遇到操作数 遍历整个中缀字符串数组，遇到数字字符就直接进行存储，这里我们利用isdigit函数来判断是否数字字符，在下面相关总结的部分，会为大家详细讲解函数的使用方式，这里只先需要知道它的头文件是#include &lt;ctype.h&gt;；
for (int i = 0; midstr[i] != &#39;\0&#39;;)//i有的情况是不&#43;&#43;的 { if (isdigit(midstr[i]))//数字字符直接放到后缀表达式里 { laststr[j&#43;&#43;] = midstr[i&#43;&#43;]; } } 遇到运算符 在遇到运算符的时候：遇到第一个操作符就直接压入栈中，根据优先级来判断是谁先出栈谁后出栈，“*”“/”的优先级高于“&#43;”“-”的优先级：
遇到括号 并且在遇到操作符（不是“)”）想要进栈，并且栈顶是“(”，就直接压入栈中：
for (int i = 0; midstr[i] !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f34ab2012d422274897ca446b7706352/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-27T18:09:22+08:00" />
<meta property="article:modified_time" content="2023-10-27T18:09:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Note详细图解】中缀表达式如何转为后缀表达式？数据结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>中缀表达式</h2> 
<p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">中缀表达式</span></strong></span>（中缀记法）是一个通用的算术或逻辑公式表示方法，<span style="color:#be191c;"><strong>操作符</strong></span>是以中缀形式处于<span style="color:#b95514;"><strong>操作数的中间</strong></span>（例：3 + 4），中缀表达式是人们常用的算术表示方法。</p> 
<p>前缀或后缀记法不同的是，中缀记法中括号是必需的。计算过程中必须用括号将操作符和对应的操作数括起来，用于指示运算的次序。</p> 
<h2>后缀表达式</h2> 
<p>逆波兰表示法（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，<strong>在</strong><span style="color:#1c7331;"><strong><span style="background-color:#edf6e8;">逆波兰记法</span></strong></span><strong>中，所有操作符置于操作数的后面，因此也被称为后缀表示法</strong>。逆波兰记法不需要括号来标识操作符的优先级。</p> 
<h2>中缀表达式转后缀表达式</h2> 
<h3>中缀转后缀思路</h3> 
<ol><li>初始化两个栈：<span style="color:#b95514;"><span style="background-color:#fff5e6;">运算符栈S1</span></span>；<span style="color:#ad720d;"><span style="background-color:#fefcd8;">操作数栈S2</span></span></li><li>从左向右扫描中缀表达式</li><li>遇到操作数时，将其压入到<span style="color:#ad720d;"><span style="background-color:#fefcd8;">操作数栈S2</span></span></li><li>遇到运算符时，比较其与<span style="color:#b95514;"><span style="background-color:#fff5e6;">运算符栈S1</span></span>栈顶运算符的优先级</li><li>如果<span style="color:#b95514;"><span style="background-color:#fff5e6;">运算符栈S1</span></span>为空，或栈顶运算符为左括号“ ( ”，或者优先级比栈顶运算符的优先级较高，则直接将此运算符压入栈中</li><li>否则，将<span style="color:#b95514;"><span style="background-color:#fff5e6;">运算符栈S1</span></span>中栈顶的运算符弹入并压到<span style="color:#ad720d;"><span style="background-color:#fefcd8;">操作数栈S2</span></span>中，再次进行与<span style="color:#b95514;"><span style="background-color:#fff5e6;">运算符栈S1</span></span>栈顶运算符的优先级比较</li><li>遇到括号时，如果遇到了左括号“ ( ”，则直接压入<span style="color:#b95514;"><span style="background-color:#fff5e6;">运算符栈S1</span></span>；</li><li>如果遇到右括号“ ) ”，则依次弹出<span style="color:#b95514;"><span style="background-color:#fff5e6;">运算符栈S1</span></span>栈顶的运算符，并压入<span style="color:#ad720d;"><span style="background-color:#fefcd8;">操作数栈S2</span></span>，直到遇到左括号" ( "为止，此时将这一对括号丢弃</li><li>重复步骤2至8，直到表达式的最右边</li><li>将<span style="color:#b95514;"><span style="background-color:#fff5e6;">运算符栈S1</span></span>剩余的运算符依次弹出并压入<span style="color:#ad720d;"><span style="background-color:#fefcd8;">操作数栈S2</span></span></li><li>拼接<span style="color:#ad720d;"><span style="background-color:#fefcd8;">操作数栈S2</span></span>中的元素并输出，结果即为中缀表达式所对应的后缀表达式</li></ol> 
<h3>中缀转后缀图示</h3> 
<p>下图是以9-2*3+(5-2)*2为例子的完整过程。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/8e/e5/MKeoQ9D9_o.gif" width="1200"></p> 
<h3>中缀转后缀流程图</h3> 
<p><img alt="" height="1108" src="https://images2.imgbox.com/86/4c/zUYZwmtd_o.png" width="1200"></p> 
<h3>中缀转后缀代码分析</h3> 
<h4>主函数</h4> 
<p>先初始化一下需要转化为后缀记法的字符串，然后给一个用来存储后缀表达式的数组，假设中缀转后缀的函数为MidtoLast，给这个函数传入中缀表达式的字符数组midstr，以及存储后缀表达式的字符数组laststr：</p> 
<pre><code class="language-cs">int main()
{
	char midstr[] = "9-2*3+(5-2)*2";//中缀表达式
	printf("中缀表达式为：%s\n", midstr);
	char laststr[100];//后缀表达式
	MidtoLast(laststr, midstr);
	printf("后缀表达式为：%s\n", laststr);

	return 0;
}</code></pre> 
<h4>遇到操作数</h4> 
<p>遍历整个中缀字符串数组，遇到数字字符就直接进行存储，这里我们利用<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">isdigit函数</span></strong></span>来判断是否数字字符，在下面相关总结的部分，会为大家详细讲解函数的使用方式，这里只先需要知道它的头文件是<span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">#include &lt;ctype.h&gt;</span></strong></span>；</p> 
<pre><code class="language-cs">for (int i = 0; midstr[i] != '\0';)//i有的情况是不++的
{
	if (isdigit(midstr[i]))//数字字符直接放到后缀表达式里
    {
        laststr[j++] = midstr[i++];
    }
}</code></pre> 
<h4>遇到运算符</h4> 
<p>在遇到运算符的时候：遇到第一个操作符就直接压入栈中，根据优先级来判断是谁先出栈谁后出栈，“*”“/”的优先级高于“+”“-”的优先级：</p> 
<h4>遇到括号</h4> 
<p>并且在遇到操作符（不是“)”）想要进栈，并且栈顶是“(”，就直接压入栈中：</p> 
<pre><code class="language-cs">for (int i = 0; midstr[i] != '\0';)//i有的情况是不++的
{
	else if (  top == 0 ||
			   midstr[i] == '(' ||
			   (midstr[i] == '*' || midstr[i] == '/') &amp;&amp; (mystack[top - 1] == '+' || mystack[top - 1] == '-') || 
               mystack[top - 1] == '(' &amp;&amp; midstr[i] != ')')
			   
    {
         mystack[top++] = midstr[i++];
    }	  
}</code></pre> 
<h4>出栈</h4> 
<p> 遇到“)”，并且栈顶元素为“(”，则直接抵消：</p> 
<pre><code class="language-cs">for (int i = 0; midstr[i] != '\0';)//i有的情况是不++的
{
	else if (midstr[i] == ')' &amp;&amp; mystack[top - 1] == '(')//直接抵消
		{
			i++;
			top--;
		}
}</code></pre> 
<h4>剩余运算符全部出栈</h4> 
<p>将栈中的剩余元素都全部依次出栈：</p> 
<pre><code class="language-cs">else//直接出栈
{
    laststr[j++] = mystack[--top];
}

while (top &gt; 0)
{
	laststr[j++] = mystack[--top];
}

laststr[j] = '\0';//变为字符串</code></pre> 
<h3>中缀转后缀完整代码</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

void MidtoLast(char* laststr, const char* midstr)
{
	int j = 0;//后缀表达式
	char mystack[100];//模拟栈
	int top = 0;//栈顶指针，当前可以存放数据的下标

	for (int i = 0; midstr[i] != '\0';)//i有的情况是不++的
	{
		if (isdigit(midstr[i]))//数字字符直接放到后缀表达式里
			laststr[j++] = midstr[i++];
		else if (top == 0 ||
			midstr[i] == '(' ||
			(midstr[i] == '*' || midstr[i] == '/') &amp;&amp; (mystack[top - 1] == '+' || mystack[top - 1] == '-') ||
			mystack[top - 1] == '(' &amp;&amp; midstr[i] != ')')
			mystack[top++] = midstr[i++];
		else if (midstr[i] == ')' &amp;&amp; mystack[top - 1] == '(')//直接抵消
		{
			i++;
			top--;
		}
		else//直接出栈
			laststr[j++] = mystack[--top];
	}

	while (top &gt; 0)
	{
		laststr[j++] = mystack[--top];
	}
	laststr[j] = '\0';//变为字符串
}

int main()
{
	char midstr[] = "9-2*3+(5-2)*2";//中缀表达式
	printf("中缀表达式为：%s\n", midstr);
	char laststr[100];//后缀表达式
	MidtoLast(laststr, midstr);
	printf("后缀表达式为：%s\n", laststr);

	return 0;
}
</code></pre> 
<h2>相关知识点</h2> 
<h3>isdigit函数：</h3> 
<p><img alt="" height="1014" src="https://images2.imgbox.com/a0/69/8nyjgfA6_o.png" width="1200"></p> 
<p>实例：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
int main()
{
    char str[] = "1776ad";
    int year;
    if (isdigit(str[0]))
    {
        year = atoi(str);
        printf("The year that followed %d was %d.\n", year, year + 1);
    }
    return 0;
}
</code></pre> 
<p>运行结果： </p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/49/d9/PTYWi0u5_o.png" width="1200"> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab738844b0c52ba433538ed4ada497e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue2循环的列表商品选择后的商品禁用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50069566bf934fb6e733ed2d6aa0b01d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">`AUTH` failed: ERR AUTH ＜password＞ called without any password configured fo 的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>