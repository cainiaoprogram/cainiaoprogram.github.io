<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android中的左右滑动 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android中的左右滑动" />
<meta property="og:description" content="iphone中有很多应用都能够左右滑动，非常cool，关键是实现起来非常简单。android比起来就差远了，网上有不少帖子。 我在这边重新分享下自己的经验吧，将实现细节详细解释下。 FlingGallery这个类摘自网上，有少许修改。 Java代码 package com.nuomi.ui; import java.util.HashSet; import java.util.Set; import android.content.Context; import android.view.GestureDetector; import android.view.KeyEvent; import android.view.MotionEvent; import android.view.View; import android.view.animation.Animation; import android.view.animation.AnimationUtils; import android.view.animation.Interpolator; import android.view.animation.Transformation; import android.widget.Adapter; import android.widget.FrameLayout; import android.widget.LinearLayout; public class FlingGallery extends FrameLayout { private Set&lt;OnGalleryChangeListener&gt; listeners; private final int swipe_min_distance = 120; private final int swipe_max_off_path = 250; private final int swipe_threshold_veloicty = 400; private int mViewPaddingWidth = 0; private int mAnimationDuration = 250; private float mSnapBorderRatio = 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a783f998dfd5627e0e36f13957c9b9e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-04-23T16:07:59+08:00" />
<meta property="article:modified_time" content="2012-04-23T16:07:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android中的左右滑动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    iphone中有很多应用都能够左右滑动，非常cool，关键是实现起来非常简单。android比起来就差远了，网上有不少帖子。 我在这边重新分享下自己的经验吧，将实现细节详细解释下。 
<br> 
<br> FlingGallery这个类摘自网上，有少许修改。 
<br> 
<div id="" class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    Java代码   
   <a title="收藏这段代码"><img class="star" src="https://images2.imgbox.com/4b/cf/IooVzPny_o.png" alt="收藏代码"></a> 
  </div> 
 </div> 
 <ol class="dp-j" start="1"><li><span class="keyword">package</span> com.nuomi.ui;  </li><li>  </li><li><span class="keyword">import</span> java.util.HashSet;  </li><li><span class="keyword">import</span> java.util.Set;  </li><li>  </li><li><span class="keyword">import</span> android.content.Context;  </li><li><span class="keyword">import</span> android.view.GestureDetector;  </li><li><span class="keyword">import</span> android.view.KeyEvent;  </li><li><span class="keyword">import</span> android.view.MotionEvent;  </li><li><span class="keyword">import</span> android.view.View;  </li><li><span class="keyword">import</span> android.view.animation.Animation;  </li><li><span class="keyword">import</span> android.view.animation.AnimationUtils;  </li><li><span class="keyword">import</span> android.view.animation.Interpolator;  </li><li><span class="keyword">import</span> android.view.animation.Transformation;  </li><li><span class="keyword">import</span> android.widget.Adapter;  </li><li><span class="keyword">import</span> android.widget.FrameLayout;  </li><li><span class="keyword">import</span> android.widget.LinearLayout;  </li><li>  </li><li>  </li><li><span class="keyword">public</span> <span class="keyword">class</span> FlingGallery <span class="keyword">extends</span> FrameLayout  </li><li>{  </li><li>      </li><li>    <span class="keyword">private</span> Set&lt;OnGalleryChangeListener&gt; listeners;  </li><li>    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> swipe_min_distance = <span class="number">120</span>;  </li><li>    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> swipe_max_off_path = <span class="number">250</span>;  </li><li>    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> swipe_threshold_veloicty = <span class="number">400</span>;  </li><li>  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> mViewPaddingWidth = <span class="number">0</span>;  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> mAnimationDuration = <span class="number">250</span>;  </li><li>    <span class="keyword">private</span> <span class="keyword">float</span> mSnapBorderRatio = <span class="number">0</span>.5f;  </li><li>    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsGalleryCircular = <span class="keyword">true</span>;  </li><li>  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> mGalleryWidth = <span class="number">0</span>;  </li><li>    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsTouched = <span class="keyword">false</span>;  </li><li>    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsDragging = <span class="keyword">false</span>;  </li><li>    <span class="keyword">private</span> <span class="keyword">float</span> mCurrentOffset = <span class="number">0</span>.0f;  </li><li>    <span class="keyword">private</span> <span class="keyword">long</span> mScrollTimestamp = <span class="number">0</span>;  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> mFlingDirection = <span class="number">0</span>;  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentPosition = <span class="number">0</span>;  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentViewNumber = <span class="number">0</span>;  </li><li>  </li><li>    <span class="keyword">private</span> Context mContext;  </li><li>    <span class="keyword">private</span> Adapter mAdapter;  </li><li>    <span class="keyword">private</span> FlingGalleryView[] mViews;  </li><li>    <span class="keyword">private</span> FlingGalleryAnimation mAnimation;  </li><li>    <span class="keyword">private</span> GestureDetector mGestureDetector;  </li><li>    <span class="keyword">private</span> Interpolator mDecelerateInterpolater;  </li><li>  </li><li>    <span class="keyword">public</span> FlingGallery(Context context)  </li><li>    {  </li><li>        <span class="keyword">super</span>(context);  </li><li>  </li><li>        listeners = <span class="keyword">new</span> HashSet&lt;OnGalleryChangeListener&gt;();  </li><li>          </li><li>        mContext = context;  </li><li>        mAdapter = <span class="keyword">null</span>;  </li><li>          </li><li>        mViews = <span class="keyword">new</span> FlingGalleryView[<span class="number">3</span>];  </li><li>        mViews[<span class="number">0</span>] = <span class="keyword">new</span> FlingGalleryView(<span class="number">0</span>, <span class="keyword">this</span>);  </li><li>        mViews[<span class="number">1</span>] = <span class="keyword">new</span> FlingGalleryView(<span class="number">1</span>, <span class="keyword">this</span>);  </li><li>        mViews[<span class="number">2</span>] = <span class="keyword">new</span> FlingGalleryView(<span class="number">2</span>, <span class="keyword">this</span>);  </li><li>  </li><li>        mAnimation = <span class="keyword">new</span> FlingGalleryAnimation();  </li><li>        mGestureDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">new</span> FlingGestureDetector());  </li><li>        mDecelerateInterpolater = AnimationUtils.loadInterpolator(mContext, android.R.anim.decelerate_interpolator);  </li><li>    }  </li><li>  </li><li>    <span class="keyword">public</span> <span class="keyword">void</span> addGalleryChangeListener(OnGalleryChangeListener listener){  </li><li>        listeners.add(listener);  </li><li>    }  </li><li>      </li><li>    <span class="keyword">public</span> <span class="keyword">void</span> setPaddingWidth(<span class="keyword">int</span> viewPaddingWidth)  </li><li>    {  </li><li>        mViewPaddingWidth = viewPaddingWidth;  </li><li>    }  </li><li>  </li><li>    <span class="keyword">public</span> <span class="keyword">void</span> setAnimationDuration(<span class="keyword">int</span> animationDuration)  </li><li>    {  </li><li>        mAnimationDuration = animationDuration;  </li><li>    }  </li><li>      </li><li>    <span class="keyword">public</span> <span class="keyword">void</span> setSnapBorderRatio(<span class="keyword">float</span> snapBorderRatio)  </li><li>    {  </li><li>        mSnapBorderRatio = snapBorderRatio;  </li><li>    }  </li><li>  </li><li>    <span class="keyword">public</span> <span class="keyword">void</span> setIsGalleryCircular(<span class="keyword">boolean</span> isGalleryCircular)   </li><li>    {  </li><li>        <span class="keyword">if</span> (mIsGalleryCircular != isGalleryCircular)  </li><li>        {  </li><li>            mIsGalleryCircular = isGalleryCircular;  </li><li>      </li><li>            <span class="keyword">if</span> (mCurrentPosition == getFirstPosition())  </li><li>            {  </li><li>                <span class="comment">// We need to reload the view immediately to the left to change it to circular view or blank</span>  </li><li>                mViews[getPrevViewNumber(mCurrentViewNumber)].recycleView(getPrevPosition(mCurrentPosition));             </li><li>            }  </li><li>      </li><li>            <span class="keyword">if</span> (mCurrentPosition == getLastPosition())  </li><li>            {  </li><li>                <span class="comment">// We need to reload the view immediately to the right to change it to circular view or blank</span>  </li><li>                mViews[getNextViewNumber(mCurrentViewNumber)].recycleView(getNextPosition(mCurrentPosition));             </li><li>            }  </li><li>        }  </li><li>    }  </li><li>  </li><li>    <span class="keyword">public</span> <span class="keyword">int</span> getGalleryCount()  </li><li>    {  </li><li>        <span class="keyword">return</span> (mAdapter == <span class="keyword">null</span>) ? <span class="number">0</span> : mAdapter.getCount();  </li><li>    }  </li><li>  </li><li>    <span class="keyword">public</span> <span class="keyword">int</span> getFirstPosition()  </li><li>    {  </li><li>        <span class="keyword">return</span> <span class="number">0</span>;  </li><li>    }  </li><li>  </li><li>    <span class="keyword">public</span> <span class="keyword">int</span> getLastPosition()  </li><li>    {  </li><li>        <span class="keyword">return</span> (getGalleryCount() == <span class="number">0</span>) ? <span class="number">0</span> : getGalleryCount() - <span class="number">1</span>;  </li><li>    }  </li><li>  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> getPrevPosition(<span class="keyword">int</span> relativePosition)  </li><li>    {  </li><li>        <span class="keyword">int</span> prevPosition = relativePosition - <span class="number">1</span>;  </li><li>  </li><li>        <span class="keyword">if</span> (prevPosition &lt; getFirstPosition())  </li><li>        {  </li><li>            prevPosition = getFirstPosition() - <span class="number">1</span>;  </li><li>  </li><li>            <span class="keyword">if</span> (mIsGalleryCircular == <span class="keyword">true</span>)  </li><li>            {  </li><li>                prevPosition = getLastPosition();  </li><li>            }  </li><li>        }  </li><li>        NotifyGalleryChange();  </li><li>        <span class="keyword">return</span> prevPosition;  </li><li>    }  </li><li>  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> getNextPosition(<span class="keyword">int</span> relativePosition)  </li><li>    {  </li><li>        <span class="keyword">int</span> nextPosition = relativePosition + <span class="number">1</span>;  </li><li>  </li><li>        <span class="keyword">if</span> (nextPosition &gt; getLastPosition())  </li><li>        {  </li><li>            nextPosition = getLastPosition() + <span class="number">1</span>;  </li><li>  </li><li>            <span class="keyword">if</span> (mIsGalleryCircular == <span class="keyword">true</span>)  </li><li>            {  </li><li>                nextPosition = getFirstPosition();  </li><li>            }  </li><li>        }  </li><li>        NotifyGalleryChange();  </li><li>        <span class="keyword">return</span> nextPosition;  </li><li>    }  </li><li>  </li><li>    <span class="comment">//</span>  </li><li>    <span class="keyword">private</span> <span class="keyword">void</span> NotifyGalleryChange() {  </li><li>        <span class="keyword">for</span> (OnGalleryChangeListener listener :listeners) {  </li><li>            listener.onGalleryChange(mCurrentPosition);  </li><li>        }  </li><li>    }  </li><li>  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> getPrevViewNumber(<span class="keyword">int</span> relativeViewNumber)  </li><li>    {  </li><li>        <span class="keyword">return</span> (relativeViewNumber == <span class="number">0</span>) ? <span class="number">2</span> : relativeViewNumber - <span class="number">1</span>;  </li><li>    }  </li><li>  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> getNextViewNumber(<span class="keyword">int</span> relativeViewNumber)  </li><li>    {  </li><li>        <span class="keyword">return</span> (relativeViewNumber == <span class="number">2</span>) ? <span class="number">0</span> : relativeViewNumber + <span class="number">1</span>;  </li><li>    }  </li><li>      </li><li>    <span class="annotation">@Override</span>  </li><li>    <span class="keyword">protected</span> <span class="keyword">void</span> onLayout(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)  </li><li>    {  </li><li>        <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);  </li><li>  </li><li>        <span class="comment">// Calculate our view width</span>  </li><li>        mGalleryWidth = right - left;  </li><li>  </li><li>        <span class="keyword">if</span> (changed)  </li><li>        {  </li><li>            <span class="comment">// Position views at correct starting offsets</span>  </li><li>            mViews[<span class="number">0</span>].setOffset(<span class="number">0</span>, <span class="number">0</span>, mCurrentViewNumber);  </li><li>            mViews[<span class="number">1</span>].setOffset(<span class="number">0</span>, <span class="number">0</span>, mCurrentViewNumber);  </li><li>            mViews[<span class="number">2</span>].setOffset(<span class="number">0</span>, <span class="number">0</span>, mCurrentViewNumber);  </li><li>        }  </li><li>    }  </li><li>  </li><li>    <span class="keyword">public</span> <span class="keyword">void</span> setAdapter(Adapter adapter)  </li><li>    {  </li><li>        mAdapter = adapter;  </li><li>        mCurrentPosition = <span class="number">0</span>;  </li><li>        mCurrentViewNumber = <span class="number">0</span>;  </li><li>  </li><li>        <span class="comment">// Load the initial views from adapter</span>  </li><li>        mViews[<span class="number">0</span>].recycleView(mCurrentPosition);  </li><li>        mViews[<span class="number">1</span>].recycleView(getNextPosition(mCurrentPosition));  </li><li>        mViews[<span class="number">2</span>].recycleView(getPrevPosition(mCurrentPosition));  </li><li>  </li><li>        <span class="comment">// Position views at correct starting offsets</span>  </li><li>        mViews[<span class="number">0</span>].setOffset(<span class="number">0</span>, <span class="number">0</span>, mCurrentViewNumber);  </li><li>        mViews[<span class="number">1</span>].setOffset(<span class="number">0</span>, <span class="number">0</span>, mCurrentViewNumber);  </li><li>        mViews[<span class="number">2</span>].setOffset(<span class="number">0</span>, <span class="number">0</span>, mCurrentViewNumber);  </li><li>    }  </li><li>  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> getViewOffset(<span class="keyword">int</span> viewNumber, <span class="keyword">int</span> relativeViewNumber)  </li><li>    {  </li><li>        <span class="comment">// Determine width including configured padding width</span>  </li><li>        <span class="keyword">int</span> offsetWidth = mGalleryWidth + mViewPaddingWidth;  </li><li>  </li><li>        <span class="comment">// Position the previous view one measured width to left</span>  </li><li>        <span class="keyword">if</span> (viewNumber == getPrevViewNumber(relativeViewNumber))  </li><li>        {  </li><li>            <span class="keyword">return</span> offsetWidth;  </li><li>        }  </li><li>  </li><li>        <span class="comment">// Position the next view one measured width to the right</span>  </li><li>        <span class="keyword">if</span> (viewNumber == getNextViewNumber(relativeViewNumber))  </li><li>        {  </li><li>            <span class="keyword">return</span> offsetWidth * -<span class="number">1</span>;  </li><li>        }  </li><li>  </li><li>        <span class="keyword">return</span> <span class="number">0</span>;  </li><li>    }  </li><li>  </li><li>    <span class="keyword">void</span> movePrevious()  </li><li>    {  </li><li>        <span class="comment">// Slide to previous view</span>  </li><li>        mFlingDirection = <span class="number">1</span>;  </li><li>        processGesture();  </li><li>    }  </li><li>  </li><li>    <span class="keyword">void</span> moveNext()  </li><li>    {  </li><li>        <span class="comment">// Slide to next view</span>  </li><li>        mFlingDirection = -<span class="number">1</span>;  </li><li>        processGesture();  </li><li>    }  </li><li>  </li><li>     <span class="annotation">@Override</span>  </li><li>     <span class="keyword">public</span> <span class="keyword">boolean</span> onKeyDown(<span class="keyword">int</span> keyCode, KeyEvent event)  </li><li>     {  </li><li>        <span class="keyword">switch</span> (keyCode)  </li><li>        {  </li><li>        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_LEFT:  </li><li>            movePrevious();  </li><li>            <span class="keyword">return</span> <span class="keyword">true</span>;  </li><li>      </li><li>        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_RIGHT:  </li><li>            moveNext();  </li><li>            <span class="keyword">return</span> <span class="keyword">true</span>;  </li><li>      </li><li>        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_CENTER:  </li><li>        <span class="keyword">case</span> KeyEvent.KEYCODE_ENTER:  </li><li>        }  </li><li>  </li><li>        <span class="keyword">return</span> <span class="keyword">super</span>.onKeyDown(keyCode, event);  </li><li>    }  </li><li>  </li><li>    <span class="keyword">public</span> <span class="keyword">boolean</span> onGalleryTouchEvent(MotionEvent event)  </li><li>    {  </li><li>        <span class="keyword">boolean</span> consumed = mGestureDetector.onTouchEvent(event);  </li><li>          </li><li>        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP)  </li><li>        {  </li><li>            <span class="keyword">if</span> (mIsTouched || mIsDragging)  </li><li>            {  </li><li>                processScrollSnap();  </li><li>                processGesture();  </li><li>            }  </li><li>        }  </li><li>          </li><li>        <span class="keyword">return</span> consumed;  </li><li>    }  </li><li>  </li><li>    <span class="keyword">void</span> processGesture()  </li><li>    {  </li><li>        <span class="keyword">int</span> newViewNumber = mCurrentViewNumber;  </li><li>        <span class="keyword">int</span> reloadViewNumber = <span class="number">0</span>;  </li><li>        <span class="keyword">int</span> reloadPosition = <span class="number">0</span>;  </li><li>  </li><li>        mIsTouched = <span class="keyword">false</span>;  </li><li>        mIsDragging = <span class="keyword">false</span>;  </li><li>  </li><li>        <span class="keyword">if</span> (mFlingDirection &gt; <span class="number">0</span>)  </li><li>        {  </li><li>            <span class="keyword">if</span> (mCurrentPosition &gt; getFirstPosition() || mIsGalleryCircular == <span class="keyword">true</span>)  </li><li>            {  </li><li>                <span class="comment">// Determine previous view and outgoing view to recycle</span>  </li><li>                newViewNumber = getPrevViewNumber(mCurrentViewNumber);  </li><li>                mCurrentPosition = getPrevPosition(mCurrentPosition);  </li><li>                reloadViewNumber = getNextViewNumber(mCurrentViewNumber);   </li><li>                reloadPosition = getPrevPosition(mCurrentPosition);  </li><li>            }  </li><li>        }  </li><li>  </li><li>        <span class="keyword">if</span> (mFlingDirection &lt; <span class="number">0</span>)  </li><li>        {  </li><li>            <span class="keyword">if</span> (mCurrentPosition &lt; getLastPosition() || mIsGalleryCircular == <span class="keyword">true</span>)  </li><li>            {  </li><li>                <span class="comment">// Determine the next view and outgoing view to recycle</span>  </li><li>                newViewNumber = getNextViewNumber(mCurrentViewNumber);  </li><li>                mCurrentPosition = getNextPosition(mCurrentPosition);  </li><li>                reloadViewNumber = getPrevViewNumber(mCurrentViewNumber);  </li><li>                reloadPosition = getNextPosition(mCurrentPosition);  </li><li>            }  </li><li>        }  </li><li>  </li><li>        <span class="keyword">if</span> (newViewNumber != mCurrentViewNumber)  </li><li>        {  </li><li>            mCurrentViewNumber = newViewNumber;   </li><li>  </li><li>            <span class="comment">// Reload outgoing view from adapter in new position</span>  </li><li>            mViews[reloadViewNumber].recycleView(reloadPosition);  </li><li>        }  </li><li>  </li><li>        <span class="comment">// Ensure input focus on the current view</span>  </li><li>        mViews[mCurrentViewNumber].requestFocus();  </li><li>  </li><li>        <span class="comment">// Run the slide animations for view transitions</span>  </li><li>        mAnimation.prepareAnimation(mCurrentViewNumber);  </li><li>        <span class="keyword">this</span>.startAnimation(mAnimation);  </li><li>  </li><li>        <span class="comment">// Reset fling state</span>  </li><li>        mFlingDirection = <span class="number">0</span>;  </li><li>    }  </li><li>  </li><li>    <span class="keyword">void</span> processScrollSnap()  </li><li>    {  </li><li>        <span class="comment">// Snap to next view if scrolled passed snap position</span>  </li><li>        <span class="keyword">float</span> rollEdgeWidth = mGalleryWidth * mSnapBorderRatio;  </li><li>        <span class="keyword">int</span> rollOffset = mGalleryWidth - (<span class="keyword">int</span>) rollEdgeWidth;  </li><li>        <span class="keyword">int</span> currentOffset = mViews[mCurrentViewNumber].getCurrentOffset();  </li><li>  </li><li>        <span class="keyword">if</span> (currentOffset &lt;= rollOffset * -<span class="number">1</span>)  </li><li>        {  </li><li>            <span class="comment">// Snap to previous view</span>  </li><li>            mFlingDirection = <span class="number">1</span>;  </li><li>        }  </li><li>  </li><li>        <span class="keyword">if</span> (currentOffset &gt;= rollOffset)  </li><li>        {  </li><li>            <span class="comment">// Snap to next view</span>  </li><li>            mFlingDirection = -<span class="number">1</span>;  </li><li>        }  </li><li>    }  </li><li>  </li><li>    <span class="keyword">private</span> <span class="keyword">class</span> FlingGalleryView  </li><li>    {  </li><li>        <span class="keyword">private</span> <span class="keyword">int</span> mViewNumber;  </li><li>        <span class="keyword">private</span> FrameLayout mParentLayout;  </li><li>          </li><li>        <span class="keyword">private</span> FrameLayout mInvalidLayout = <span class="keyword">null</span>;  </li><li>        <span class="keyword">private</span> LinearLayout mInternalLayout = <span class="keyword">null</span>;  </li><li>        <span class="keyword">private</span> View mExternalView = <span class="keyword">null</span>;  </li><li>  </li><li>        <span class="keyword">public</span> FlingGalleryView(<span class="keyword">int</span> viewNumber, FrameLayout parentLayout)  </li><li>        {  </li><li>            mViewNumber = viewNumber;  </li><li>            mParentLayout = parentLayout;  </li><li>  </li><li>            <span class="comment">// Invalid layout is used when outside gallery</span>  </li><li>            mInvalidLayout = <span class="keyword">new</span> FrameLayout(mContext);  </li><li>            mInvalidLayout.setLayoutParams(<span class="keyword">new</span> LinearLayout.LayoutParams(   </li><li>                    LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));  </li><li>  </li><li>            <span class="comment">// Internal layout is permanent for duration</span>  </li><li>            mInternalLayout = <span class="keyword">new</span> LinearLayout(mContext);  </li><li>            mInternalLayout.setLayoutParams(<span class="keyword">new</span> LinearLayout.LayoutParams(   </li><li>                    LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));  </li><li>  </li><li>            mParentLayout.addView(mInternalLayout);  </li><li>        }  </li><li>  </li><li>        <span class="keyword">public</span> <span class="keyword">void</span> recycleView(<span class="keyword">int</span> newPosition)  </li><li>        {  </li><li>            <span class="keyword">if</span> (mExternalView != <span class="keyword">null</span>)  </li><li>            {  </li><li>                mInternalLayout.removeView(mExternalView);  </li><li>            }  </li><li>  </li><li>            <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>)  </li><li>            {  </li><li>                <span class="keyword">if</span> (newPosition &gt;= getFirstPosition() &amp;&amp; newPosition &lt;= getLastPosition())  </li><li>                {  </li><li>                    mExternalView = mAdapter.getView(newPosition, mExternalView, mInternalLayout);  </li><li>                }  </li><li>                <span class="keyword">else</span>  </li><li>                {  </li><li>                    mExternalView = mInvalidLayout;  </li><li>                }  </li><li>            }  </li><li>  </li><li>            <span class="keyword">if</span> (mExternalView != <span class="keyword">null</span>)  </li><li>            {  </li><li>                mInternalLayout.addView(mExternalView, <span class="keyword">new</span> LinearLayout.LayoutParams(   </li><li>                    LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));  </li><li>            }  </li><li>        }  </li><li>  </li><li>        <span class="keyword">public</span> <span class="keyword">void</span> setOffset(<span class="keyword">int</span> xOffset, <span class="keyword">int</span> yOffset, <span class="keyword">int</span> relativeViewNumber)  </li><li>        {  </li><li>            <span class="comment">// Scroll the target view relative to its own position relative to currently displayed view</span>  </li><li>            mInternalLayout.scrollTo(getViewOffset(mViewNumber, relativeViewNumber) + xOffset, yOffset);  </li><li>        }  </li><li>          </li><li>        <span class="keyword">public</span> <span class="keyword">int</span> getCurrentOffset()  </li><li>        {  </li><li>            <span class="comment">// Return the current scroll position</span>  </li><li>            <span class="keyword">return</span> mInternalLayout.getScrollX();  </li><li>        }  </li><li>  </li><li>        <span class="keyword">public</span> <span class="keyword">void</span> requestFocus()  </li><li>        {  </li><li>            mInternalLayout.requestFocus();  </li><li>        }  </li><li>    }  </li><li>  </li><li>    <span class="keyword">private</span> <span class="keyword">class</span> FlingGalleryAnimation <span class="keyword">extends</span> Animation  </li><li>    {  </li><li>        <span class="keyword">private</span> <span class="keyword">boolean</span> mIsAnimationInProgres;  </li><li>        <span class="keyword">private</span> <span class="keyword">int</span> mRelativeViewNumber;  </li><li>        <span class="keyword">private</span> <span class="keyword">int</span> mInitialOffset;  </li><li>        <span class="keyword">private</span> <span class="keyword">int</span> mTargetOffset;  </li><li>        <span class="keyword">private</span> <span class="keyword">int</span> mTargetDistance;      </li><li>   </li><li>        <span class="keyword">public</span> FlingGalleryAnimation()  </li><li>        {  </li><li>            mIsAnimationInProgres = <span class="keyword">false</span>;  </li><li>            mRelativeViewNumber = <span class="number">0</span>;  </li><li>            mInitialOffset = <span class="number">0</span>;  </li><li>            mTargetOffset = <span class="number">0</span>;  </li><li>            mTargetDistance = <span class="number">0</span>;  </li><li>        }  </li><li>   </li><li>        <span class="keyword">public</span> <span class="keyword">void</span> prepareAnimation(<span class="keyword">int</span> relativeViewNumber)  </li><li>        {  </li><li>            <span class="comment">// If we are animating relative to a new view</span>  </li><li>            <span class="keyword">if</span> (mRelativeViewNumber != relativeViewNumber)  </li><li>            {  </li><li>                <span class="keyword">if</span> (mIsAnimationInProgres == <span class="keyword">true</span>)  </li><li>                {  </li><li>                    <span class="comment">// We only have three views so if requested again to animate in same direction we must snap </span>  </li><li>                    <span class="keyword">int</span> newDirection = (relativeViewNumber == getPrevViewNumber(mRelativeViewNumber)) ? <span class="number">1</span> : -<span class="number">1</span>;  </li><li>                    <span class="keyword">int</span> animDirection = (mTargetDistance &lt; <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;   </li><li>  </li><li>                    <span class="comment">// If animation in same direction</span>  </li><li>                    <span class="keyword">if</span> (animDirection == newDirection)  </li><li>                    {  </li><li>                        <span class="comment">// Ran out of time to animate so snap to the target offset</span>  </li><li>                        mViews[<span class="number">0</span>].setOffset(mTargetOffset, <span class="number">0</span>, mRelativeViewNumber);  </li><li>                        mViews[<span class="number">1</span>].setOffset(mTargetOffset, <span class="number">0</span>, mRelativeViewNumber);  </li><li>                        mViews[<span class="number">2</span>].setOffset(mTargetOffset, <span class="number">0</span>, mRelativeViewNumber);   </li><li>                    }  </li><li>                }  </li><li>      </li><li>                <span class="comment">// Set relative view number for animation</span>  </li><li>                mRelativeViewNumber = relativeViewNumber;  </li><li>            }  </li><li>  </li><li>            <span class="comment">// Note: In this implementation the targetOffset will always be zero</span>  </li><li>            <span class="comment">// as we are centering the view; but we include the calculations of</span>  </li><li>            <span class="comment">// targetOffset and targetDistance for use in future implementations</span>  </li><li>  </li><li>            mInitialOffset = mViews[mRelativeViewNumber].getCurrentOffset();  </li><li>            mTargetOffset = getViewOffset(mRelativeViewNumber, mRelativeViewNumber);  </li><li>            mTargetDistance = mTargetOffset - mInitialOffset;  </li><li>  </li><li>            <span class="comment">// Configure base animation properties</span>  </li><li>            <span class="keyword">this</span>.setDuration(mAnimationDuration);  </li><li>            <span class="keyword">this</span>.setInterpolator(mDecelerateInterpolater);  </li><li>  </li><li>            <span class="comment">// Start/continued animation</span>  </li><li>            mIsAnimationInProgres = <span class="keyword">true</span>;  </li><li>        }  </li><li>  </li><li>        <span class="annotation">@Override</span>  </li><li>        <span class="keyword">protected</span> <span class="keyword">void</span> applyTransformation(<span class="keyword">float</span> interpolatedTime, Transformation transformation)  </li><li>        {  </li><li>            <span class="comment">// Ensure interpolatedTime does not over-shoot then calculate new offset</span>  </li><li>            interpolatedTime = (interpolatedTime &gt; <span class="number">1</span>.0f) ? <span class="number">1</span>.0f : interpolatedTime;  </li><li>            <span class="keyword">int</span> offset = mInitialOffset + (<span class="keyword">int</span>) (mTargetDistance * interpolatedTime);  </li><li>  </li><li>            <span class="keyword">for</span> (<span class="keyword">int</span> viewNumber = <span class="number">0</span>; viewNumber &lt; <span class="number">3</span>; viewNumber++)  </li><li>            {  </li><li>                <span class="comment">// Only need to animate the visible views as the other view will always be off-screen</span>  </li><li>                <span class="keyword">if</span> ((mTargetDistance &gt; <span class="number">0</span> &amp;&amp; viewNumber != getNextViewNumber(mRelativeViewNumber)) ||  </li><li>                    (mTargetDistance &lt; <span class="number">0</span> &amp;&amp; viewNumber != getPrevViewNumber(mRelativeViewNumber)))  </li><li>                {  </li><li>                    mViews[viewNumber].setOffset(offset, <span class="number">0</span>, mRelativeViewNumber);  </li><li>                }  </li><li>            }  </li><li>        }  </li><li>  </li><li>        <span class="annotation">@Override</span>  </li><li>        <span class="keyword">public</span> <span class="keyword">boolean</span> getTransformation(<span class="keyword">long</span> currentTime, Transformation outTransformation)  </li><li>        {  </li><li>            <span class="keyword">if</span> (<span class="keyword">super</span>.getTransformation(currentTime, outTransformation) == <span class="keyword">false</span>)  </li><li>            {  </li><li>                <span class="comment">// Perform final adjustment to offsets to cleanup animation</span>  </li><li>                mViews[<span class="number">0</span>].setOffset(mTargetOffset, <span class="number">0</span>, mRelativeViewNumber);  </li><li>                mViews[<span class="number">1</span>].setOffset(mTargetOffset, <span class="number">0</span>, mRelativeViewNumber);  </li><li>                mViews[<span class="number">2</span>].setOffset(mTargetOffset, <span class="number">0</span>, mRelativeViewNumber);  </li><li>  </li><li>                <span class="comment">// Reached the animation target</span>  </li><li>                mIsAnimationInProgres = <span class="keyword">false</span>;  </li><li>  </li><li>                <span class="keyword">return</span> <span class="keyword">false</span>;  </li><li>            }  </li><li>   </li><li>            <span class="comment">// Cancel if the screen touched</span>  </li><li>            <span class="keyword">if</span> (mIsTouched || mIsDragging)  </li><li>            {  </li><li>                <span class="comment">// Note that at this point we still consider ourselves to be animating</span>  </li><li>                <span class="comment">// because we have not yet reached the target offset; its just that the</span>  </li><li>                <span class="comment">// user has temporarily interrupted the animation with a touch gesture</span>  </li><li>  </li><li>                <span class="keyword">return</span> <span class="keyword">false</span>;  </li><li>            }  </li><li>  </li><li>            <span class="keyword">return</span> <span class="keyword">true</span>;  </li><li>        }  </li><li>    }  </li><li>  </li><li>    <span class="keyword">private</span> <span class="keyword">class</span> FlingGestureDetector <span class="keyword">extends</span> GestureDetector.SimpleOnGestureListener  </li><li>    {  </li><li>        <span class="annotation">@Override</span>  </li><li>        <span class="keyword">public</span> <span class="keyword">boolean</span> onDown(MotionEvent e)  </li><li>        {  </li><li>            <span class="comment">// Stop animation</span>  </li><li>            mIsTouched = <span class="keyword">true</span>;  </li><li>  </li><li>            <span class="comment">// Reset fling state</span>  </li><li>            mFlingDirection = <span class="number">0</span>;  </li><li>            <span class="keyword">return</span> <span class="keyword">true</span>;  </li><li>        }  </li><li>  </li><li>        <span class="annotation">@Override</span>  </li><li>        <span class="keyword">public</span> <span class="keyword">boolean</span> onScroll(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)  </li><li>        {  </li><li>            <span class="keyword">if</span> (e2.getAction() == MotionEvent.ACTION_MOVE)  </li><li>            {  </li><li>                <span class="keyword">if</span> (mIsDragging == <span class="keyword">false</span>)  </li><li>                {  </li><li>                    <span class="comment">// Stop animation</span>  </li><li>                    mIsTouched = <span class="keyword">true</span>;  </li><li>       </li><li>                    <span class="comment">// Reconfigure scroll</span>  </li><li>                    mIsDragging = <span class="keyword">true</span>;  </li><li>                    mFlingDirection = <span class="number">0</span>;  </li><li>                    mScrollTimestamp = System.currentTimeMillis();  </li><li>                    mCurrentOffset = mViews[mCurrentViewNumber].getCurrentOffset();  </li><li>                }  </li><li>  </li><li>                <span class="keyword">float</span> maxVelocity = mGalleryWidth / (mAnimationDuration / <span class="number">1000</span>.0f);  </li><li>                <span class="keyword">long</span> timestampDelta = System.currentTimeMillis() - mScrollTimestamp;  </li><li>                <span class="keyword">float</span> maxScrollDelta = maxVelocity * (timestampDelta / <span class="number">1000</span>.0f);   </li><li>                <span class="keyword">float</span> currentScrollDelta = e1.getX() - e2.getX();  </li><li>  </li><li>                <span class="keyword">if</span> (currentScrollDelta &lt; maxScrollDelta * -<span class="number">1</span>) currentScrollDelta = maxScrollDelta * -<span class="number">1</span>;  </li><li>                <span class="keyword">if</span> (currentScrollDelta &gt; maxScrollDelta) currentScrollDelta = maxScrollDelta;  </li><li>                <span class="keyword">int</span> scrollOffset = Math.round(mCurrentOffset + currentScrollDelta);  </li><li>  </li><li>                <span class="comment">// We can't scroll more than the width of our own frame layout</span>  </li><li>                <span class="keyword">if</span> (scrollOffset &gt;= mGalleryWidth) scrollOffset = mGalleryWidth;  </li><li>                <span class="keyword">if</span> (scrollOffset &lt;= mGalleryWidth * -<span class="number">1</span>) scrollOffset = mGalleryWidth * -<span class="number">1</span>;  </li><li>                  </li><li>                mViews[<span class="number">0</span>].setOffset(scrollOffset, <span class="number">0</span>, mCurrentViewNumber);  </li><li>                mViews[<span class="number">1</span>].setOffset(scrollOffset, <span class="number">0</span>, mCurrentViewNumber);  </li><li>                mViews[<span class="number">2</span>].setOffset(scrollOffset, <span class="number">0</span>, mCurrentViewNumber);  </li><li>            }  </li><li>  </li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;  </li><li>        }  </li><li>  </li><li>        <span class="annotation">@Override</span>  </li><li>        <span class="keyword">public</span> <span class="keyword">boolean</span> onFling(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)  </li><li>        {  </li><li>            <span class="keyword">if</span> (Math.abs(e1.getY() - e2.getY()) &lt;= swipe_max_off_path)  </li><li>            {  </li><li>                <span class="keyword">if</span> (e2.getX() - e1.getX() &gt; swipe_min_distance &amp;&amp; Math.abs(velocityX) &gt; swipe_threshold_veloicty)  </li><li>                {  </li><li>                    movePrevious();  </li><li>                }  </li><li>  </li><li>                <span class="keyword">if</span>(e1.getX() - e2.getX() &gt; swipe_min_distance &amp;&amp; Math.abs(velocityX) &gt; swipe_threshold_veloicty)  </li><li>                {  </li><li>                    moveNext();  </li><li>                }  </li><li>            }  </li><li>  </li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;  </li><li>        }  </li><li>  </li><li>        <span class="annotation">@Override</span>  </li><li>        <span class="keyword">public</span> <span class="keyword">void</span> onLongPress(MotionEvent e)  </li><li>        {  </li><li>            <span class="comment">// Finalise scrolling</span>  </li><li>            mFlingDirection = <span class="number">0</span>;  </li><li>            processGesture();  </li><li>        }  </li><li>  </li><li>        <span class="annotation">@Override</span>  </li><li>        <span class="keyword">public</span> <span class="keyword">void</span> onShowPress(MotionEvent e)  </li><li>        {  </li><li>        }  </li><li>  </li><li>        <span class="annotation">@Override</span>  </li><li>        <span class="keyword">public</span> <span class="keyword">boolean</span> onSingleTapUp(MotionEvent e)  </li><li>        {  </li><li>            <span class="comment">// Reset fling state</span>  </li><li>            mFlingDirection = <span class="number">0</span>;  </li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;  </li><li>        }  </li><li>          </li><li>    }  </li><li>  </li><li>    <span class="keyword">public</span> GestureDetector getMGestureDetector() {  </li><li>        <span class="keyword">return</span> mGestureDetector;  </li><li>    }  </li><li>      </li><li>}  </li></ol> 
</div> 
<br> 
<br> 由于我需要在滑动页面时，改动title中的文字，这里采用了观察者模式，加了个OnGalleryChangeListener，有同样需求的同学可以参考下。 
<br> 
<div id="" class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    Java代码   
   <a title="收藏这段代码"><img class="star" src="https://images2.imgbox.com/74/70/jvMLWv1K_o.png" alt="收藏代码"></a> 
  </div> 
 </div> 
 <ol class="dp-j" start="1"><li><span class="keyword">public</span> <span class="keyword">interface</span> OnGalleryChangeListener {  </li><li>      </li><li>    <span class="keyword">public</span> <span class="keyword">void</span> onGalleryChange(<span class="keyword">int</span> currentItem);  </li><li>}  </li></ol> 
</div> 
<br> 在Activity中， 
<br> 
<div id="" class="dp-highlighter"> 
 <div class="bar"> 
  <div class="tools">
    Java代码   
   <a title="收藏这段代码"><img class="star" src="https://images2.imgbox.com/50/14/69n63yKz_o.png" alt="收藏代码"></a> 
  </div> 
 </div> 
 <ol class="dp-j" start="1"><li>FlingGallery gallery = <span class="keyword">new</span> FlingGallery(<span class="keyword">this</span>);  </li><li>  </li><li>        gallery.setAdapter(<span class="keyword">new</span> ArrayAdapter&lt;String&gt;(getApplicationContext(),  </li><li>                android.R.layout.simple_list_item_1, <span class="keyword">new</span> String[xxxx]) {  </li><li>            <span class="keyword">public</span> View getView(<span class="keyword">int</span> position, View convertView, ViewGroup parent) {  </li><li>                               <span class="comment">// 返回滑动的deal</span>  </li><li>                <span class="keyword">return</span> dealViews[position];  </li><li>            }  </li><li>        });  </li><li>        gallery.addGalleryChangeListener(<span class="keyword">new</span> OnGalleryChangeListener() {  </li><li>  </li><li>            <span class="annotation">@Override</span>  </li><li>            <span class="keyword">public</span> <span class="keyword">void</span> onGalleryChange(<span class="keyword">int</span> currentItem) {  </li><li>                <span class="comment">// 干些想干的事件</span>  </li><li>  </li><li>            }  </li><li>  </li><li>        });  </li></ol> 
</div> 
<br> 将gallery加到Activity中的最终需要显示的类中。 
<br> Adapter中的getView方法中，将需要用来滑动的view添加进来。在GalleryChangeListener中，可以干一些自己想要的滑动后的事情。我在这里改动了标题的文字，进行了我的view中图片的lazyloading。 
<br> 这里提一下另一个问题。我的这个类，最终嵌入到了tab中，需要在你的tabActivity中dispatchKeyEvent一下，将按键事件分发下去。 
<br> 最开始，我的滑动的view写得比较通用，所以包含了ScrollView来满足比较长的屏幕,导致手势监听会出一些问题，会出现抖动。当时的解决方案是针对不同屏幕尽量保证一屏能够显示，在res目录下，增加layout-800x480之类的目录，针对每个不同屏幕设计单独的layout，放弃上下滑动，效果也不错。 
<br> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8e2c791fe68922e5d8b360ee5a4e26c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">重新启动postgre报错时，解决方案   ( 由备份文件占用空间太大造成 ) (linux 命令 df -h 查看磁盘空间)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/49cb1d7006314a9bb32cc175dd0609b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Django 树形结构实现方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>