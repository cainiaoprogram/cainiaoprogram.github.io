<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Part5-1-3 Nodejs 通信 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Part5-1-3 Nodejs 通信" />
<meta property="og:description" content="通信必要条件 主机之间需要有传输介质（网线，wifi，蓝牙）
主机上必须有网卡设备（调制与解调制，将电压与二进制数据进行转换）
主机之间需要协商网络速率
常见通讯方式 交换机通讯
路由器通讯
建立多台主机互联 定位局域网中的其他主机 通过 Mac 地址来唯一标识一台主机
但是交换机无法满足互联网需求：
交换机的接口数量有上限
局域网存在大量主机会造成广播风暴
明确目标主机 IP 地址
网络层次模型 OSI七层模型：
应用层：用户与网络的接口
表示层：数据加密、转换、压缩
会话层：控制网络连接建立与终止
传输层：控制数据传输可靠性
网络层：确定目标网络
数据链路层：确定目标主机
物理层：各种物理设备和标准
数据从 A 至 B，先封装再解封
TCP协议 TCP 属于传输层协议
TCP 是面向连接的协议
TCP 用于处理实时通信
常见控制字段 SYN = 1 表示请求建立连接
FIN = 1 表示请求断开连接
ACK = 1 表示数据信息确认
三次握手 创建 TCP 通信 Net 模块实现了底层通信接口
通信过程：
创建服务端：接收和回写客户端数据
创建客户端：发送和接收服务端数据
数据传输：内置服务事件和方法读写数据
通信事件：
listening 事件：调用 server.listen 方法之后触发
connection 事件：新的连接建立时触发
close 事件：当 server 关闭时触发" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e22f971b3139c64b466963b47003d1ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-24T16:27:50+08:00" />
<meta property="article:modified_time" content="2022-04-24T16:27:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Part5-1-3 Nodejs 通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>通信必要条件</h2> 
<p>主机之间需要有传输介质（网线，wifi，蓝牙）</p> 
<p>主机上必须有网卡设备（调制与解调制，将电压与二进制数据进行转换）</p> 
<p>主机之间需要协商网络速率</p> 
<p><img alt="" height="895" src="https://images2.imgbox.com/fe/fb/qdRinGv8_o.png" width="1200"></p> 
<p></p> 
<h2>常见通讯方式</h2> 
<p>交换机通讯</p> 
<p>路由器通讯</p> 
<p></p> 
<h2>建立多台主机互联</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/dd/af/kYD0lcDL_o.png" width="1200"></p> 
<p></p> 
<h2>定位局域网中的其他主机</h2> 
<p>通过 Mac 地址来唯一标识一台主机</p> 
<p></p> 
<p><strong>但是交换机无法满足互联网需求：</strong></p> 
<p>交换机的接口数量有上限</p> 
<p>局域网存在大量主机会造成广播风暴</p> 
<p><img alt="" height="810" src="https://images2.imgbox.com/5c/07/SvCfSEJv_o.png" width="1200"></p> 
<p> 明确目标主机 IP 地址</p> 
<p></p> 
<h2>网络层次模型</h2> 
<p><strong>OSI七层模型：</strong></p> 
<p>应用层：用户与网络的接口</p> 
<p>表示层：数据加密、转换、压缩</p> 
<p>会话层：控制网络连接建立与终止</p> 
<p>传输层：控制数据传输可靠性</p> 
<p>网络层：确定目标网络</p> 
<p>数据链路层：确定目标主机</p> 
<p>物理层：各种物理设备和标准</p> 
<p></p> 
<p>数据从 A 至 B，先封装再解封</p> 
<p></p> 
<h2>TCP协议</h2> 
<p>TCP 属于传输层协议</p> 
<p>TCP 是面向连接的协议</p> 
<p>TCP 用于处理实时通信</p> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/20/ec/5PSiwiqk_o.png" width="1200"></p> 
<p></p> 
<h2>常见控制字段</h2> 
<p>SYN = 1 表示请求建立连接</p> 
<p>FIN = 1 表示请求断开连接</p> 
<p>ACK = 1 表示数据信息确认</p> 
<p></p> 
<h2>三次握手</h2> 
<p><img alt="" height="781" src="https://images2.imgbox.com/16/7c/JCDtm9Qt_o.png" width="1170"></p> 
<p></p> 
<h2>创建 TCP 通信</h2> 
<p>Net 模块实现了底层通信接口</p> 
<p><strong>通信过程：</strong></p> 
<p>创建服务端：接收和回写客户端数据</p> 
<p>创建客户端：发送和接收服务端数据</p> 
<p>数据传输：内置服务事件和方法读写数据</p> 
<p></p> 
<p><strong>通信事件：</strong></p> 
<p>listening 事件：调用 server.listen 方法之后触发</p> 
<p>connection 事件：新的连接建立时触发</p> 
<p>close 事件：当 server 关闭时触发</p> 
<p>error 事件：当错误出现的时候触发</p> 
<p></p> 
<p><strong>通信事件 &amp; 方法：</strong></p> 
<p>data 事件：当接收到数据的时候触发该事件</p> 
<p>write 方法：在 socket 上发送数据，默认是 utf8 编码</p> 
<p>end 操作：当 socket 的一端发送 FIN 包时触发，结束可读端</p> 
<p></p> 
<p><strong>server.js</strong></p> 
<pre><code>const net = require('net')

// 创建服务端实例
const server = net.createServer()

const PORT = 1234
const HOST = 'localhost'

server.listen(PORT, HOST)

server.on('listening', () =&gt; {
  console.log(`服务端已经开启在 ${HOST}: ${PORT}`)
})

// 接收消息 回写消息
server.on('connection', (socket) =&gt; {
  socket.on('data', (chunk) =&gt; {
    const msg = chunk.toString()
    console.log(msg)

    // 回数据
    socket.write(Buffer.from('您好' + msg))
  })
})

server.on('close', () =&gt; {
  console.log('服务端关闭了')
})

server.on('error', (err) =&gt; {
  if (err.code == 'EADDRINUSE') {
    console.log('地址正在被使用')
  }else{
    console.log(err)
  }
})</code></pre> 
<p><strong>client.js</strong></p> 
<pre><code>const net = require('net')

const client = net.createConnection({
  port: 1234, 
  host: '127.0.0.1'
})

client.on('connect', () =&gt; {
  client.write('前端工程')
})

client.on('data', (chunk) =&gt; {
  console.log(chunk.toString())
})

client.on('error', (err) =&gt; {
  console.log(err)
})

client.on('close', () =&gt; {
  console.log('客户端断开连接')
})</code></pre> 
<h2>TCP 数据粘包</h2> 
<p>通信包含数据发送端和接收端</p> 
<p>发送端累积数据统一发送</p> 
<p>接收端缓冲数据之后再消费</p> 
<p>所以对于数据的使用就会产生粘包的问题</p> 
<p>TCP拥塞机制决定发送时机</p> 
<p><strong>client.js</strong></p> 
<pre><code>const net = require('net')

const client = net.createConnection({
  port: 1234, 
  host: '127.0.0.1'
})

let dataArr = [
  '前端工程2', 
  '前端工程3', 
  '前端工程4', 
  '前端工程5', 
]

client.on('connect', () =&gt; {
  client.write('前端工程1')
  for(let i=0; i&lt;dataArr.length; i++) {
    (function (val, index) {
      setTimeout(() =&gt; {
        client.write(val)
      }, 1000 * (index +1))
    })(dataArr[i], i)
  }
})

client.on('data', (chunk) =&gt; {
  console.log(chunk.toString())
})

client.on('error', (err) =&gt; {
  console.log(err)
})

client.on('close', () =&gt; {
  console.log('客户端断开连接')
})</code></pre> 
<h2>数据的封包与拆包</h2> 
<p><strong>数据传输过程</strong></p> 
<p>进行数据编码，获取二进制数据包</p> 
<p>按规则拆解数据，获取指定长度的数据</p> 
<p></p> 
<p><strong>Buffer 数据读写</strong></p> 
<p>writelnt16BE：将 value 从指定位置写入</p> 
<p>readInt16BE：从指定位置开始读取数据</p> 
<p></p> 
<h2>封包解决粘包</h2> 
<p><strong>myTransform.js</strong></p> 
<pre><code>class MyTransformCode{
  constructor() {
    this.packageHeaderLen = 4
    this.serialNum = 0
    this.serialLen = 2
  }

  // 编码
  encode(data, serialNum) {
    const body = Buffer.from(data)

    // 01 先按照指定的长度来申请一片内存空间做为 header 来使用
    const headerBuf = Buffer.alloc(this.packageHeaderLen)

    // 02 
    headerBuf.writeInt16BE(serialNum || this.serialNum)

    headerBuf.writeInt16BE(body.length, this.serialLen)

    if (serialNum == undefined) {
      this.serialNum++
    }

    return Buffer.concat([headerBuf, body])
  }

  // 解码
  decode(buffer) {
    const headerBuf = buffer.slice(0, this.packageHeaderLen)
    const bodyBuf = buffer.slice(this.packageHeaderLen)

    return {
      serialNum: headerBuf.readInt16BE(),
      bodyLength: headerBuf.readInt16BE(this.serialLen),
      body: bodyBuf.toString()
    }
  }

  // 获取包长度的方法
  getPackageLen(buffer) {
    if (buffer.length &lt; this.packageHeaderLen) {
      return 0
    } else {
      return this.packageHeaderLen + buffer.readInt16BE(this.serialLen)
    }
  }
}

module.exports = MyTransformCode</code></pre> 
<p><strong>server.js</strong></p> 
<pre><code>const net = require('net')
const MyTransform = require('./myTransform.js')

const server = net.createServer()

let overageBuffer = null
let ts = new MyTransform()

server.listen('1234', 'localhost')

server.on('listening', () =&gt; {
  console.log('服务端运行在 localhost:1234')
})

server.on('connection', (socket) =&gt; {
  socket.on('data', (chunk) =&gt; {
    if (overageBuffer) {
      chunk = Buffer.concat([overageBuffer, chunk])
    }
    let packageLen = 0
    while(packageLen = ts.getPackageLen(chunk)) {
      const packageCon = chunk.slice(0, packageLen)
      chunk = chunk.slice(packageLen)

      const ret = ts.decode(packageCon)
      console.log(ret)

      socket.write(ts.encode(ret.body, ret.serialNum))
    }
    overageBuffer = chunk
  })
})</code></pre> 
<p><strong>client.js</strong></p> 
<pre><code>const net = require('net')
const MyTransform = require('./myTransform.js')

let overageBuffer = null 
let ts = new MyTransform()

const client = net.createConnection({
  host: 'localhost', 
  port: 1234
})

client.write(ts.encode('前端工程1'))
client.write(ts.encode('前端工程2'))
client.write(ts.encode('前端工程3'))
client.write(ts.encode('前端工程4'))
client.write(ts.encode('前端工程5'))

client.on('data', (chunk) =&gt; {
  if (overageBuffer) {
    chunk = Buffer.concat([overageBuffer, chunk])
  }
  let packageLen = 0
  while(packageLen = ts.getPackageLen(chunk)) {
    const packageCon = chunk.slice(0, packageLen)
    chunk = chunk.slice(packageLen)

    const ret = ts.decode(packageCon)
    console.log(ret)
  }
  overageBuffer = chunk
})</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>1</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/267907741a81eae2b8ca531599cfe481/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python3&#43;RIDE&#43;RobotFramework安装思路及排错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9091ed67f20f851c3f7f79a4e6079435/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解释器与编译器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>