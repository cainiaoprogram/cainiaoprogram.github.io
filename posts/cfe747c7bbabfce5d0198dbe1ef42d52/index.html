<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>shell sed的用法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="shell sed的用法" />
<meta property="og:description" content="Sed命令是linux下的一个非常有用的命令，特别是在shell脚本中经常会使用到他。
熟悉他你会觉得非常有趣哦！
1.sed -n &#39;2&#39;p filename 打印文件的第二行。 2.sed -n &#39;1,3&#39;p filename 打印文件的1到3行 3. sed -n &#39;/Neave/&#39;p filename 打印匹配Neave的行(模糊匹配) 4. sed -n &#39;4,/The/&#39;p filename 在第4行查询模式The 5. sed -n &#39;1,$&#39;p filename 打印整个文件，$表示最后一行。 6. sed -n &#39;/.*ing/&#39;p filename 匹配任意字母，并以ing结尾的单词(点号不能少) 7 sed -n / -e &#39;/music/&#39;= filename 打印匹配行的行号，-e 会打印文件的内容，同时在匹配行的前面标志行号。-n只打印出实际的行号。 8.sed -n -e &#39;/music/&#39;p -e &#39;/music/&#39;= filename 打印匹配的行和行号，行号在内容的下面 9.sed &#39;/company/&#39; a\ &#34;Then suddenly it happend&#34; filename 选择含有company的行，将后面的内容&#34;Then suddenly it happend&#34;加入下一行。注意：它并不改变文件，所有操作在缓冲区，如果要保存输出，重定向到一个文件。 10. sed &#39;/company/&#39; i\ &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cfe747c7bbabfce5d0198dbe1ef42d52/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-09-10T00:40:56+08:00" />
<meta property="article:modified_time" content="2012-09-10T00:40:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">shell sed的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Sed命令是linux下的一个非常有用的命令，特别是在shell脚本中经常会使用到他。<br> 熟悉他你会觉得非常有趣哦！<br> 1.sed -n '2'p filename <br> 打印文件的第二行。 <br> 2.sed -n '1,3'p filename <br> 打印文件的1到3行 <br> 3. sed -n '/Neave/'p filename <br> 打印匹配Neave的行(模糊匹配) <br> 4. sed -n '4,/The/'p filename <br> 在第4行查询模式The <br> 5. sed -n '1,$'p filename <br> 打印整个文件，$表示最后一行。 <br> 6. sed -n '/.*ing/'p filename <br> 匹配任意字母，并以ing结尾的单词(点号不能少) <br> 7 sed -n / -e '/music/'= filename <br> 打印匹配行的行号，-e 会打印文件的内容，同时在匹配行的前面标志行号。-n只打印出实际的行号。 <br> 8.sed -n -e '/music/'p -e '/music/'= filename <br> 打印匹配的行和行号，行号在内容的下面 <br> 9.sed '/company/' a\ "Then suddenly it happend" filename <br> 选择含有company的行，将后面的内容"Then suddenly it happend"加入下一行。注意：它并不改变文件，所有操作在缓冲区，如果要保存输出，重定向到一个文件。 <br> 10. sed '/company/' i\ "Then suddenly it happend" filename <br> 同9，只是在匹配的行前插入 <br> 11.sed '/company/' c\ "Then suddenly it happend" filename <br> 用"Then suddenly it happend"替换匹配company的行的内容。 <br> 12.sed '1'd ( '1,3'd '$'d '/Neave/'d) filename <br> 删除第一行(1到3行，最后一行，匹配Neave的行) <br> 13.[ address [，address]] s/ pattern-to-find /replacement-pattern/[g p w n] <br> s选项通知s e d这是一个替换操作，并查询pattern-to-find，成功后用replacement-pattern替换它。 <br> 替换选项如下： <br> g 缺省情况下只替换第一次出现模式，使用g选项替换全局所有出现模式。 <br> p 缺省s e d将所有被替换行写入标准输出，加p选项将使- n选项无效。- n选项不打印输出结果。 <br> w 文件名使用此选项将输出定向到一个文件。(注意只将匹配替换的行写入文件，而不是整个内容) <br> 14.sed s'/nurse/"hello "&amp;/' filename <br> 将'hello '增加到'nurse' 的前面。 <br> 15. sed '/company/r append.txt' filename <br> 在匹配company的行的下一行开始加入文件append.txt的内容。 <br> 16. sed '/company/'q filename <br> 首次匹配company后就退出sed程序<br> 只所以看sed命令，是因为我遇到了这个一个问题。 <br> 网上有很多教程，他们发表了很多程序代码，但是作者为了解释方便，都对程序作了行号编码，就像下面这样： <br> 代码::<br> 1:#!/bin/bash <br> 2:#rename file extesions <br> 3:# <br> 4:#     rfe old_extensions new_extension<br> 假设这个文件名是tmp，那么我们可以使用下面的命令来去掉这个行号和冒号(：) <br> 代码::<br> sed -e  s'/^[0-9]\{1,\}://g' tmp<br> 不过上面的命令的命令有一个缺点，那就是如果这个行号不是数字开头，而是有空格的话，那就需要修改匹配规则，规则应该修改为匹配第一个非空白字符是数字开始，后面接一个冒号的配对。命令如下： <br> 代码::<br> sed -e  s'/^[^0-9a-zA-Z]*[0-9]\{1,\}://g' tmp<br> 这令我很兴奋，于是想看看sed到底有多厉害，看了以后，明白的是不是sed有多厉害，就像awk一样，他们只是把正规表达式用到了极致。<br> 以 Redhat6.0 为测试环境 <br> 事实上在solaris下的sed命令要比linux强，但因为没有测试 <br> 环境，我这里只给在linux下经过测试的用法。 <br> ★ 命令行参数简介 <br> ★ 首先假设我们有这样一个文本文件 sedtest.txt<br> ★ 输出指定范围的行 p <br> ★ 在每一行前面增加一个制表符(^I) <br> ★ 在每一行后面增加--end <br> ★ 显示指定模式匹配行的行号 [/pattern/]= <br> ★ 在匹配行后面增加文本 [/pattern/]a\ 或者 [address]a\ <br> ★ 删除匹配行 [/pattern/]d 或者 [address1][,address2]d <br> ★ 替换匹配行 [/pattern/]c\ 或者 [address1][,address2]c\ <br> ★ 在匹配行前面插入文本 [/pattern/]i\ 或者 [address]i\ <br> ★ 替换匹配串(注意不再是匹配行) [addr1][,addr2]s/old/new/g <br> ★ 限定范围后的模式匹配 <br> ★ 指定替换每一行中匹配的第几次出现 <br> ★ &amp;代表最后匹配 <br> ★ 利用sed修改PATH环境变量 <br> ★ 测试并提高sed命令运行效率 <br> ★ 指定输出文件 [address1][,address2]w outputfile <br> ★ 指定输入文件 [address]r inputfile <br> ★ 替换相应字符 [address1][,address2]y/old/new/ <br> ★ !号的使用 <br> ★ \c正则表达式c 的使用 <br> ★ sed命令中正则表达式的复杂性 <br> ★ 转换man手册成普通文本格式(新) <br> ★ sed的man手册(用的就是上面的方法) <br> ★ 命令行参数简介 <br> sed <br> -e script 指定sed编辑命令 <br> -f scriptfile 指定的文件中是sed编辑命令 <br> -n 寂静模式，抑制来自sed命令执行过程中的冗余输出信息，比如只 <br> 显示那些被改变的行。 <br> 不明白？不要紧，把这些肮脏丢到一边，跟我往下走，不过下面的介绍里 <br> 不包括正则表达式的解释，如果你不明白，可能有点麻烦。 <br> ★ 首先假设我们有这样一个文本文件 sedtest.txt <br> cat &gt; sedtest.txt <br> Sed is a stream editor <br> ---------------------- <br> A stream editor is used to perform basic text transformations on an input stream <br> -------------------------------------------------------------------------------- <br> While in some ways similar to an editor which permits scripted edits (such as ed <br> ) <br> , <br> -------------------------------------------------------------------------------- <br> - <br> - <br> sed works by making only one pass over the input(s), and is consequently more <br> ----------------------------------------------------------------------------- <br> efficient. But it is sed's ability to filter text in a pipeline which particular <br> l <br> y <br> -------------------------------------------------------------------------------- <br> - <br> ★ 输出指定范围的行 p other types of editors. <br> sed -e "1,4p" -n sedtest.txt <br> sed -e "/from/p" -n sedtest.txt <br> sed -e "1,/from/p" -n sedtest.txt <br> ★ 在每一行前面增加一个制表符(^I) <br> sed "s/^/^I/g" sedtest.txt <br> 注意^I的输入方法是ctrl-v ctrl-i <br> 单个^表示行首 <br> ★ 在每一行后面增加--end <br> sed "s/$/--end/g" sedtest.txt <br> 单个$表示行尾 <br> ★ 显示指定模式匹配行的行号 [/pattern/]= <br> sed -e '/is/=' sedtest.txt <br> 1 <br> Sed is a stream editor <br> ---------------------- <br> 3 <br> A stream editor is used to perform basic text transformations on an input stream <br> -------------------------------------------------------------------------------- <br> While in some ways similar to an editor which permits scripted edits (such as ed<br> ) <br> , <br> -------------------------------------------------------------------------------- <br> - <br> - <br> 7 <br> sed works by making only one pass over the input(s), and is consequently more <br> ----------------------------------------------------------------------------- <br> 9 <br> efficient. But it is sed's ability to filter text in a pipeline which particular <br> l <br> y <br> -------------------------------------------------------------------------------- <br> - <br> - <br> 意思是分析sedtest.txt，显示那些包含is串的匹配行的行号，注意11行中出现了is字符串 <br> 这个输出是面向stdout的，如果不做重定向处理，则不影响原来的sedtest.txt <br> ★ 在匹配行后面增加文本 [/pattern/]a\ 或者 [address]a\ <br> ^D <br> sed -f sedadd.script sedtest.txt <br> Sed is a stream editor <br> A stream editor is used to perform basic text transformations on an input stream <br> While in some ways similar to an editor which permits scripted edits (such as ed <br> ) <br> , <br> -------------------------------------------------------------------------------- <br> - <br> - <br> sed works by making only one pass over the input(s), and is consequently more <br> ----------------------------------------------------------------------------- <br> efficient. But it is sed's ability to filter text in a pipeline which particular <br> l <br> y <br> -------------------------------------------------------------------------------- <br> - <br> - <br> [scz@ /home/scz/src]&gt; sed -e "a\\ <br> +++++++++ <br> --------------------------------------------- <br> 找到包含from字符串的行，在该行的下一行增加+++++++++。 <br> 这个输出是面向stdout的，如果不做重定向处理，则不影响原来的sedtest.txt <br> 很多人想在命令行上直接完成这个操作而不是多一个sedadd.script，不幸的是，这需要用?nbsp; <br> ?nbsp; <br> 续行符\， <br> [scz@ /home/scz/src]&gt; sed -e "/from/a\\ <br> ＞ +++++++++" sedtest.txt <br> [scz@ /home/scz/src]&gt; sed -e "a\\ <br> ＞ +++++++++" sedtest.txt <br> 上面这条命令将在所有行后增加一个新行+++++++++ <br> [scz@ /home/scz/src]&gt; sed -e "1 a\\ <br> ＞ +++++++++" sedtest.txt <br> 把下面这两行copy/paste到一个shell命令行上，效果一样 <br> +++++++++" sedtest.txt <br> [address]a\ 只接受一个地址指定 <br> 对于a命令，不支持单引号，只能用双引号，而对于d命令等其他命令，同时 <br> ★ 删除匹配行 [/pattern/]d 或者 [address1][,address2]d <br> sed -e '/---------------------------------------------/d' sedtest.txt <br> Sed is a stream editor <br> A stream editor is used to perform basic text transformations on an input stream <br> While in some ways similar to an editor which permits scripted edits (such as ed <br> ) <br> , <br> sed works by making only one pass over the input(s), and is consequently more <br> efficient. But it is sed's ability to filter text in a pipeline which particular <br> l <br> y <br> sed -e '6,10d' sedtest.txt <br> 删除6-10行的内容，包括6和10 <br> sed -e "2d" sedtest.txt<br> 删除第2行的内容 <br> sed "1,/^$/d" sedtest.txt <br> 删除从第一行到第一个空行之间的所有内容 <br> 注意这个命令很容易带来意外的结果，当sedtest.txt中从第一行开始并没有空行，则sed删 <br> ?nbsp; <br> ?nbsp; <br> sed "1,/from/d" sedtest.txt <br> 删除从第一行到第一个包含from字符串的行之间的所有内容，包括第一个包含 <br> from字符串的行。 <br> ★ 替换匹配行 [/pattern/]c\ 或者 [address1][,address2]c\ <br> sed -e "/is/c\\ <br> **********" sedtest.txt <br> 寻找所有包含is字符串的匹配行，替换成********** <br> ********** <br> ---------------------- <br> ********** <br> -------------------------------------------------------------------------------- <br> While in some ways similar to an editor which permits scripted edits (such as ed <br> ) <br> , <br> -------------------------------------------------------------------------------- <br> - <br> - <br> ********** <br> ----------------------------------------------------------------------------- <br> ********** <br> -------------------------------------------------------------------------------- <br> - <br> sed -e "1,11c\\ <br> **********" sedtest.txt---------------------- <br> 在1-12行内搜索所有from字符串，分别替换成****字符串 <br> ★ 限定范围后的模式匹配 <br> sed "/But/s/is/are/g" sedtest.txt <br> 对那些包含But字符串的行，把is替换成are <br> sed "/is/s/t/T/" sedtest.txt <br> 对那些包含is字符串的行，把每行第一个出现的t替换成T <br> sed "/While/,/from/p" sedtest.txt -n <br> 输出在这两个模式匹配行之间的所有内容 <br> ★ 指定替换每一行中匹配的第几次出现 <br> sed "s/is/are/5" sedtest.txt <br> 把每行的is字符串的第5次出现替换成are <br> ★ &amp;代表最后匹配 <br> sed "s/^$/(&amp;)/" sedtest.txt <br> 给所有空行增加一对() <br> sed "s/is/(&amp;)/g" sedtest.txt <br> 给所有is字符串外增加() <br> sed "s/.*/(&amp;)/" sedtest.txt <br> 给所有行增加一对() <br> sed "/is/s/.*/(&amp;)/" sedtest.txt <br> 给所有包含is字符串的行增加一对() <br> ★ 利用sed修改PATH环境变量 <br> 先查看PATH环境变量 <br> [scz@ /home/scz/src]&gt; echo $PATH <br> /usr/bin:/usr/bin:/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/X11R6/bin:. <br> 去掉尾部的{ :/usr/X11R6/bin:. } <br> [scz@ /home/scz/src]&gt; echo $PATH | sed "s/^\(.*\):\/usr[/]X11R6\/bin:[.]$/\1/" <br> /usr/bin:/usr/bin:/bin:/usr/local/bin:/sbin:/usr/sbin <br> 去掉中间的{ :/bin: } <br> [scz@ /home/scz/src]&gt; echo $PATH | sed "s/^\(.*\):\/bin:\(.*\)$/\1\2/" <br> /usr/bin:/usr/bin/usr/local/bin:/sbin:/usr/sbin:/usr/X11R6/bin:. <br> [/]表示/失去特殊意义 <br> \/同样表示/失去意义 <br> \1表示子匹配的第一次出现 <br> \2表示子匹配的第二次出现 <br> \(.*\)表示子匹配 <br> 去掉尾部的:，然后增加新的路径 <br> PATH=`echo $PATH | sed 's/\(.*\):$/\1/'`:$HOME/src <br> 注意反引号`和单引号'的区别。 <br> ★ 测试并提高sed命令运行效率 <br> time sed -n "1,12p" webkeeper.db &gt; /dev/null <br> time sed 12q webkeeper.db &gt; /dev/null可以看出后者比前者效率高。 <br> [address]q 当碰上指定行时退出sed执行 <br> ★ 指定输出文件 [address1][,address2]w outputfile <br> sed "1,10w sed.out" sedtest.txt -n <br> 将sedtest.txt中1-10行的内容写到sed.out文件中。 <br> ★ 指定输入文件 [address]r inputfile <br> sed "1r sedappend.txt" sedtest.txt <br> 将sedappend.txt中的内容附加到sedtest.txt文件的第一行之后 <br> ★ 替换相应字符 [address1][,address2]y/old/new/ <br> sed "y/abcdef/ABCDEF/" sedtest.txt <br> 将sedtest.txt中所有的abcdef小写字母替换成ABCDEF大写字母。 <br> ★ !号的使用 <br> sed -e '3,7!d' sedtest.txt <br> 删除3-7行之外的所有行 <br> sed -e '1,/from/!d' sedtest.txt <br> 找到包含from字符串的行，删除其后的所有行 <br> ★ \c正则表达式c 的使用 <br> sed -e "\:from:d" sedtest.txt <br> 等价于 sed -e "/from/d" sedtest.txt <br> ★ sed命令中正则表达式的复杂性 <br> cat &gt; sedtest.txt <br> ^\/[}]{.*}[\(]$\) <br> ^D <br> 如何才能把该行替换成 <br> \(]$\)\/[}]{.*}^[ <br> ★ 转换man手册成普通文本格式(新) <br> man sed | col -b &gt; sed.txt <br> sed -e "s/^H//g" -e "/^$/d" -e "s/^^I/ /g" -e "s/^I/ /g" sed.txt &gt; sedman <br> txt <br> 删除所有退格键、空行，把行首的制表符替换成8个空格，其余制表符替换成一个空格。 <br> ★ sed的man手册(用的就是上面的方法) <br> NAME <br> sed - a Stream EDitor <br> SYNOPSIS <br> sed [-n] [-V] [--quiet] [--silent] [--version] [--help] <br> [-e script] [--expression=script] <br> [-f script-file] [--file=script-file] <br> [script-if-no-other-script] <br> [file...] <br> DESCRIPTION <br> Sed is a stream editor. A stream editor is used to per- <br> form basic text transformations on an input stream (a file <br> or input from a pipeline). While in some ways similar to <br> an editor which permits scripted edits (such as ed), sed <br> works by making only one pass over the input(s), and is <br> consequently more efficient. But it is sed's ability to <br> filter text in a pipeline which particularly distinguishes <br> it from other types of editors. <br> OPTIONS <br> Sed may be invoked with the following command-line <br> options: <br> -V <br> --version <br> Print out the version of sed that is being run and <br> a copyright notice, then exit. <br> -h <br> --help Print a usage message briefly summarizing these <br> command-line options and the bug-reporting address, <br> then exit. <br> -n <br> --quiet <br> --silent <br> By default, sed will print out the pattern space at <br> the end of each cycle through the script. These <br> options disable this automatic printing, and sed <br> will only produce output when explicitly told to <br> via the p command. <br> -e script <br> --expression=script <br> Add the commands in script to the set of commands <br> to be run while processing the input. <br> -f script-file <br> --file=script-file <br> Add the commands contained in the file script-file <br> to the set of commands to be run while processingthe input. <br> If no -e,-f,--expression, or --file options are given on <br> the command-line, then the first non-option argument on <br> the command line is taken to be the script to be executed. <br> If any command-line parameters remain after processing the <br> above, these parameters are interpreted as the names of <br> input files to be processed. A file name of - refers to <br> the standard input stream. The standard input will pro- <br> cessed if no file names are specified. <br> Command Synopsis <br> This is just a brief synopsis of sed commands to serve as <br> a reminder to those who already know sed; other documenta- <br> tion (such as the texinfo document) must be consulted for <br> fuller descriptions. <br> Zero-address ``commands'' <br> : label <br> Label for b and t commands. <br> #comment <br> The comment extends until the next newline (or the <br> end of a -e script fragment). <br> } The closing bracket of a { } block. <br> Zero- or One- address commands <br> = Print the current line number. <br> a \ <br> text Append text, which has each embedded newline pre- <br> ceeded by a backslash. <br> i \ <br> text Insert text, which has each embedded newline pre- <br> ceeded by a backslash. <br> q Immediately quit the sed script without processing <br> any more input, except that if auto-print is not <br> diabled the current pattern space will be printed. <br> r filename <br> Append text read from filename. <br> Commands which accept address ranges <br> { Begin a block of commands (end with a }). <br> b label <br> Branch to label; if label is omitted, branch to end <br> of script. <br> t label <br> If a s/// has done a successful substitution since <br> the last input line was read and since the last t <br> command, then branch to label; if label is omitted, <br> branch to end of script. <br> c \ <br> text Replace the selected lines with text, which has <br> each embedded newline preceeded by a backslash. <br> d Delete pattern space. Start next cycle. <br> D Delete up to the first embedded newline in the pat- <br> tern space. Start next cycle, but skip reading <br> from the input if there is still data in the pat- <br> tern space. <br> h H Copy/append pattern space to hold space. <br> g G Copy/append hold space to pattern space. <br> x Exchange the contents of the hold and pattern <br> spaces. <br> l List out the current line in a ``visually unambigu- <br> ous'' form. <br> n N Read/append the next line of input into the pattern <br> space. <br> p Print the current pattern space. <br> P Print up to the first embedded newline of the cur- <br> rent pattern space. <br> s/regexp/replacement/ <br> Attempt to match regexp against the pattern space. <br> If successful, replace that portion matched with <br> replacement. The replacement may contain the spe- <br> cial character &amp; to refer to that portion of the <br> pattern space which matched, and the special <br> escapes \1 through \9 to refer to the corresponding<br> matching sub-expressions in the regexp. <br> w filename Write the current pattern space to file- <br> name. <br> y/source/dest/ <br> Transliterate the characters in the pattern space <br> which appear in source to the corresponding charac- <br> ter in dest. <br> Addresses <br> Sed commands can be given with no addresses, in which case <br> the command will be executed for all input lines; with one <br> address, in which case the command will only be executed <br> for input lines which match that address; or with two <br> addresses, in which case the command will be executed for <br> all input lines which match the inclusive range of lines <br> starting from the first address and continuing to the sec- <br> ond address. Three things to note about address ranges: <br> the syntax is addr1,addr2 (i.e., the addresses are sepa- <br> rated by a comma); the line which addr1 matched will <br> always be accepted, even if addr2 selects an earlier line; <br> and if addr2 is a regexp, it will not be tested against <br> the line that addr1 matched. <br> After the address (or address-range), and before the com- <br> mand, a ! may be inserted, which specifies that the com- <br> mand shall only be executed if the address (or address- <br> range) does not match. <br> The following address types are supported: <br> number Match only the specified line number. <br> first~step <br> Match every step'th line starting with line first. <br> For example, ``sed -n 1~2p'' will print all the <br> odd-numbered lines in the input stream, and the <br> address 2~5 will match every fifth line, starting <br> with the second. (This is a GNU extension.) <br> $ Match the last line. <br> /regexp/ <br> Match lines matching the regular expression regexp. <br> \cregexpc <br> Match lines matching the regular expression regexp. <br> The c may be any character. <br> Regular expressions <br> POSIX.2 BREs should be supported, but they aren't com- <br> pletely yet. The \n sequence in a regular expression <br> matches the newline character. There are also some GNU <br> extensions. [XXX FIXME: more needs to be said. At the <br> very least, a reference to another document which <br> describes what is supported should be given.] <br> Miscellaneous notes <br> This version of sed supports a \ sequence in all <br> regular expressions, the replacement part of a substitute <br> (s) command, and in the source and dest parts of a <br> transliterate (y) command. The \ is stripped, and the <br> newline is kept. <br> SEE ALSO <br> awk(1), ed(1), expr(1), emacs(1), perl(1), tr(1), vi(1), <br> regex(5) [well, one ought to be written... XXX], sed.info, <br> any of various books on sed, the sed FAQ <br> (<a href="http://www.wollery.demon.co.uk/sedtut10.txt" rel="nofollow">http://www.wollery.demon.co.uk/sedtut10.txt</a>, <br> <a href="http://www.ptug.org/sed/sedfaq.htm" rel="nofollow">http://www.ptug.org/sed/sedfaq.htm</a>). <br> BUGS <br> E-mail bug reports to <a href="mailto:bug-gnu-utils@gnu.org" rel="nofollow">bug-gnu-utils@gnu.org</a>. Be sure to <br> include the word ``sed'' somewhere in the ``Subject:'' <br> field.<br> Sed学习笔记<br> 作者：Jims of</p> 
<p><br> 肥肥世家</p> 
<p>Table of Contents<br> 1. Sed简介</p> 
<p>2. 定址</p> 
<p>3. Sed命令</p> 
<p>4. 选项</p> 
<p>5. 元字符集</p> 
<p>6. 实例</p> 
<p>7. 脚本<br> 1. Sed简介<br> sed是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。以下介绍的是Gnu版本的Sed 3.02。<br> 2. 定址<br> 可以通过定址来定位你所希望编辑的行，该地址用数字构成，用逗号分隔的两个行数表示以这两行为起止的行的范围（包括行数表示的那两行）。如1，3表示1，2，3行，美元符号($)表示最后一行。范围可以通过数据，正则表达式或者二者结合的方式确定 。<br> 3. Sed命令<br> 调用sed命令有两种形式： <br> sed [options] 'command' file(s)<br> sed [options] -f scriptfile file(s)<br> a\ <br> 在当前行后面加入一行文本。<br> b lable <br> 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。<br> c\ <br> 用新的文本改变本行的文本。<br> d <br> 从模板块（Pattern space）位置删除行。<br> D <br> 删除模板块的第一行。<br> i\ <br> 在当前行上面插入文本。<br> h <br> 拷贝模板块的内容到内存中的缓冲区。<br> H <br> 追加模板块的内容到内存中的缓冲区<br> g <br> 获得内存缓冲区的内容，并替代当前模板块中的文本。<br> G <br> 获得内存缓冲区的内容，并追加到当前模板块文本的后面。<br> l <br> 列表不能打印字符的清单。<br> n <br> 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。<br> N <br> 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。<br> p <br> 打印模板块的行。<br> P（大写） <br> 打印模板块的第一行。<br> q <br> 退出Sed。<br> r file <br> 从file中读行。<br> t label <br> if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。<br> T label <br> 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。<br> w file <br> 写并追加模板块到file末尾。<br> W file <br> 写并追加模板块的第一行到file末尾。<br> ! <br> 表示后面的命令对所有没有被选定的行发生作用。<br> s/re/string <br> 用string替换正则表达式re。<br> = <br> 打印当前行号码。<br> # <br> 把注释扩展到下一个换行符以前。<br> 以下的是替换标记 <br> g表示行内全面替换。<br> p表示打印行。<br> w表示把行写入一个文件。<br> x表示互换模板块中的文本和缓冲区中的文本。<br> y表示把一个字符翻译为另外的字符（但是不用于正则表达式）<br> 4. 选项<br> -e command, --expression=command <br> 允许多台编辑。<br> -h, --help <br> 打印帮助，并显示bug列表的地址。<br> -n, --quiet, --silent <br> 取消默认输出。<br> -f, --filer=script-file <br> 引导sed脚本文件名。<br> -V, --version<br> 打印版本和版权信息。<br> 5. 元字符集<br> ^ 锚定行的开始 如：/^sed/匹配所有以sed开头的行。 <br> $ 锚定行的结束 如：/sed$/匹配所有以sed结尾的行。 <br> . 匹配一个非换行符的字符 如：/s.d/匹配s后接一个任意字符，然后是d。 <br> * 匹配零或多个字符 如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 <br> [] 匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。 <br> [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。 <br> \(..\) 保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。 <br> &amp; 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 <br> \ 锚定单词的开始，如:/\匹配包含以love开头的单词的行。 <br> \&gt; 锚定单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。 <br> x\{m\}重复字符x，m次，如：/0\{5\}/匹配包含5个o的行。 <br> x\{m,\} 重复字符x,至少m次，如：/o\{5,\}/匹配至少有5个o的行。 <br> x\{m,n\}重复字符x，至少m次，不多于n次，如：/o\{5,10\}/匹配5--10个o的行。<br> 6. 实例<br> 删除：d命令 <br> $ sed '2d' example-----删除example文件的第二行。<br> $ sed '2,$d' example-----删除example文件的第二行到末尾所有行。<br> $ sed '$d' example-----删除example文件的最后一行。<br> $ sed '/test/'d example-----删除example文件所有包含test的行。<br> 替换：s命令 <br> $ sed 's/test/mytest/g' example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。<br> $ sed -n 's/^test/mytest/p' example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。<br> $ sed 's/^192.168.0.1/&amp;localhost/' example-----&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加localhost，变成192.168.0.1localhost。<br> $ sed -n 's/\(love\)able/\1rs/p' example-----love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。<br> $ sed 's#10#100#g' example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。<br> 选定行的范围：逗号 <br> $ sed -n '/test/,/check/p' example-----所有在模板test和check所确定的范围内的行都被打印。<br> $ sed -n '5,/^test/p' example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。<br> $ sed '/test/,/check/s/$/sed test/' example-----对于模板test和west之间的行，每行的末尾用字符串sed test替换。<br> 多点编辑：e命令 <br> $ sed -e '1,5d' -e 's/test/check/' example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。<br> $ sed --expression='s/test/check/' --expression='/love/d' example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。<br> 从文件读入：r命令 <br> $ sed '/test/r file' example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。<br> 写入文件：w命令 <br> $ sed -n '/test/w file' example-----在example中所有包含test的行都被写入file里。<br> 追加命令：a命令 <br> $ sed '/^test/a\\---&gt;this is a example' example被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。<br> 插入：i命令 <br> $ sed '/test/i\\<br> new line<br> -------------------------' example<br> 如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。<br> 下一个：n命令 <br> $ sed '/test/{ n; s/aa/bb/; }' example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。<br> 变形：y命令 <br> $ sed '1,10y/abcde/ABCDE/' example-----把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。<br> 退出：q命令 <br> $ sed '10q' example-----打印完第10行后，退出sed。<br> 保持和获取：h命令和G命令 <br> $ sed -e '/test/h' -e '$G example-----在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。<br> 保持和互换：h命令和x命令 <br> $ sed -e '/test/h' -e '/check/x' example -----互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。<br> 7. 脚本<br> Sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。</p> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8293771f7ded7e8a9529b846e460af84/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言中realloc()函数解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/29d340b8a12f62bacdd20c9500d910ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何判断一个tcp连接已经断开</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>