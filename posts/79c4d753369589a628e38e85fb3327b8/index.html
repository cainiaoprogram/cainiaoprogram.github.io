<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ 消息确认机制 ——可靠抵达（发送端） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RabbitMQ 消息确认机制 ——可靠抵达（发送端）" />
<meta property="og:description" content="前言 ： rabbitMQ为了防止消息不丢失的情况，可以使用事物消息，但是性能下降250倍，为此引入确认机制 如上图所示：
一、publisher confirmCallBack确认模式
springboot开启rabbitmq可靠抵达 ——confirmCallBack spring: rabbitmq: publisher-confirm-type: correlated 当我们的publisher 到达 broker (服务器时候) ，返回confirmCallback，当消息没有抵达broker的时候返回true,并会给出失败原因。
public class MyRabbitConfig { @Autowired RabbitTemplate rabbitTemplate; /** * 使用json序列化 将消息转为json * @return */ @Bean public MessageConverter messageConverter(){ return new Jackson2JsonMessageConverter(); } /** * MyRabbitConfig 方法创建完成之后 执行 postConstruct */ @PostConstruct public void initRabbitTemplate(){ /** * 设置确认回调 */ rabbitTemplate. setConfirmCallback(new RabbitTemplate.ConfirmCallback() { /** * 只要 消息到达 broker(服务器) 就返回true ，如果不抵达返回false * @param correlationData 消息关联数据（通过id关联） * @param b 消息是否成功收到 * @param s 失败的原因 */ @Override public void confirm(CorrelationData correlationData, boolean b, String s) { } }); } } 二、publisher returnCallBack 确认模式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/79c4d753369589a628e38e85fb3327b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-21T10:34:52+08:00" />
<meta property="article:modified_time" content="2021-10-21T10:34:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ 消息确认机制 ——可靠抵达（发送端）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3></h3> 
<h3>前言 ： rabbitMQ为了防止消息不丢失的情况，可以使用事物消息，但是性能下降250倍，为此引入确认机制</h3> 
<p></p> 
<p><img alt="" height="167" src="https://images2.imgbox.com/de/e3/PJvvTUra_o.png" width="845"><br>  如上图所示：</p> 
<blockquote> 
 <p><span style="color:#38d8f0;"><strong>一、publisher   confirmCallBack确认模式</strong></span></p> 
</blockquote> 
<p> springboot开启rabbitmq可靠抵达 ——<span style="color:#38d8f0;"><strong>confirmCallBack </strong></span></p> 
<pre><code class="language-java">spring:
  rabbitmq:
    publisher-confirm-type: correlated
</code></pre> 
<p>当我们的publisher 到达 broker (服务器时候) ，返回confirmCallback，当消息没有抵达broker的时候返回true,并会给出失败原因。</p> 
<pre><code class="language-java">public class MyRabbitConfig {

    @Autowired
    RabbitTemplate rabbitTemplate;

    /**
     * 使用json序列化 将消息转为json
     * @return
     */
    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }


    /**
     *   MyRabbitConfig 方法创建完成之后 执行 postConstruct
     */
    @PostConstruct
    public void initRabbitTemplate(){
        /**
         * 设置确认回调
         */
        rabbitTemplate. setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
            /**
             *  只要 消息到达 broker(服务器) 就返回true  ，如果不抵达返回false
             * @param correlationData 消息关联数据（通过id关联）
             * @param b 消息是否成功收到
             * @param s  失败的原因
             */
            @Override
            public void confirm(CorrelationData correlationData, boolean b, String s) {
                
            }
        });

    }





}</code></pre> 
<blockquote> 
 <p><span style="color:#38d8f0;"><strong>二、publisher   returnCallBack 确认模式</strong></span></p> 
</blockquote> 
<p>springboot开启rabbitmq可靠抵达 —— <span style="color:#38d8f0;"><strong>returnCallBack </strong></span></p> 
<p>当我们开启publisher-returns 时候，将 <span style="color:#4da8ee;">spring.rabbitmq.template.mandatory </span>开启</p> 
<p>作用：只要消息抵达队列 ，以异步方式优先回调 rerunConfirm</p> 
<pre><code class="language-XML">spring:
  rabbitmq:
    publisher-returns: true
    #只要消息抵达队列 ，以异步方式优先回调 rerunConfirm
    template:
      mandatory: true
</code></pre> 
<p> 设置broker 抵达 queue 时候的returnCallBack回调</p> 
<p><span style="color:#38d8f0;"><strong>只要消息没有投递给指定的队列，就触发这个失败回调</strong></span></p> 
<pre><code class="language-java">        /**
         * 第二步：设置broker 抵达 queue 时候的returnCallBack回调
         */
        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {
            /**
             * 只要消息没有投递给指定的队列，就触发这个失败回调
             *
             * @param returnedMessage 返回消息失败的实体
             */
            @Override
            public void returnedMessage(ReturnedMessage returnedMessage) {

            }
        });</code></pre> 
<p>贴上RetrunedMessage实体返回的内容（此处为rabbitMQ自带实体，非自建）</p> 
<pre><code class="language-java">public class ReturnedMessage {
    //投递失败的消息详细信息
    private final Message message;  
    //回复的状态码
    private final int replyCode;
    //回复的文本内容
    private final String replyText;
    //当时这个消息发给哪个交换机
    private final String exchange;
    //当时这个消息用哪个路由键
    private final String routingKey;

    public ReturnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
        this.message = message;
        this.replyCode = replyCode;
        this.replyText = replyText;
        this.exchange = exchange;
        this.routingKey = routingKey;
    }

    public Message getMessage() {
        return this.message;
    }

    public int getReplyCode() {
        return this.replyCode;
    }

    public String getReplyText() {
        return this.replyText;
    }

    public String getExchange() {
        return this.exchange;
    }

    public String getRoutingKey() {
        return this.routingKey;
    }

    public String toString() {
        return "ReturnedMessage [message=" + this.message + ", replyCode=" + this.replyCode + ", replyText=" + this.replyText + ", exchange=" + this.exchange + ", routingKey=" + this.routingKey + "]";
    }
}</code></pre> 
<p>路由键绑定为 ：</p> 
<pre><code class="language-java">    /**
     * 绑定交换机和队列
     */
    @Test
    void bindingQueueExchange(){
        /**
         * String destination   【目的地】
         *  Binding.DestinationType destinationType,  【目的地绑定类型】
         *  String exchange,  【交换机】
         *  String routingKey, 【路由键】
         *  @Nullable Map&lt;String, Object&gt; argument  【自定义参数】
         */
        Binding binding = new Binding(queueName, Binding.DestinationType.QUEUE,exchange,"chendazui.#",null);
        amqpAdmin.declareBinding(binding);
        log.info("[{}]绑定成功","chendazui-binding");
    }</code></pre> 
<p>当我们将路由键修改后：</p> 
<pre><code class="language-java">    @Test
    void sendMessage(){
        MessageUtil messageUtil = new MessageUtil();
        messageUtil.setCode("1");
        messageUtil.setMsg("我到了");
        messageUtil.setOrder("陈大嘴的订单");
        messageUtil.setUser("陈大嘴");
        messageUtil.setDateTime(new Date());
        /**
         * 发送消息实体类必须要序列化
         */
        rabbitTemplate.convertAndSend(exchange,"chendazui1.#",messageUtil);
        log.info("[{}]消息已经发出",messageUtil);
    }</code></pre> 
<p>这个时候我们测试结果如下：</p> 
<pre><code class="language-XML">当前指向的交换机==&gt;chendazui-exchange投递失败消息详情(Body:'{"code":"1","msg":"我到了","order":"陈大嘴的订单","user":"陈大嘴","dateTime":1634780951481}' MessageProperties [headers={__TypeId__=com.example.demo.util.MessageUtil}, contentType=application/json, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0])回复的文本内容NO_ROUTE路由键chendazui1.#回复的状态码=&gt;312</code></pre> 
<p><strong><span style="color:#a2e043;">这时候我们returnCallBack机制捕捉到失败消息，消息未抵达队列queue。</span></strong></p> 
<p>相关代码地址：</p> 
<p><a href="https://gitee.com/chen_da_zhu/rabbit-mq-demo" rel="nofollow" title="RabbitMQ    Demo: rabbitmq 代码示例">RabbitMQ Demo: rabbitmq 代码示例</a></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/90e7ca2f02130851c2d4cded81ffef03/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Android】ActionBar监听返回按钮</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d3583bba740845a38db16bf61141551c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">为什么经常把VARCHAR长度设置成255，而不是更大</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>