<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法设计与分析回溯算法之装载问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法设计与分析回溯算法之装载问题" />
<meta property="og:description" content="回溯算法之装载问题 问题描述 给定n个集装箱要装上一艘载重量为c的轮船，其中集装箱i的重量为wi。集装箱装载问题要求确定在不超过轮船载重量的前提下，将尽可能多的集装箱装上轮船（贪心算法中的装载问题讨论的是装载件数；本题讨论的是最大装载重量。）
由于集装箱问题是从n个集装箱里选择一部分集装箱，假设解向量为X(x1, x2, …, xn)，其中xi∈{0, 1}， xi =1表示集装箱i装上轮船， xi =0表示集装箱i不装上轮船。
输入
每组测试数据：第1行有2个整数c和n。C是轮船的载重量（0＜c＜30000），n是集装箱的个数（n≤20）。第2行有n个整数w1, w2, …, wn，分别表示n个集装箱的重量。
输出
对每个测试例，输出两行：第1行是装载到轮船的最大载重量，第2行是集装箱的编号。
输入样例
34 3
21 10 5
输出（考虑最大装载量的最优解）
31（重量）
1 2
考虑最大装载件数的最优解
2（件）
5 10
算法分析 该问题的形式化描述为：
用回溯法解装载问题时，其解空间是一棵子集树，与0 - 1背包问题的解空间树相同。
可行性约束函数可剪去不满足约束条件的子树：
令cw(t)表示从根结点到第t层结点为止装入轮船的重量，即部分解(x1, x2 , …, xt)的重量：
当cw(t)&gt;c时，表示该子树中所有结点都不满足约束条件，可将该子树剪去。
代码 #include &lt;iostream&gt; using namespace std; class goods{ int weight; public: goods(int w=0):weight(w) {} int get_w(){ return weight; } void set(int w){ weight=w; } }; //goods *g,集装箱列表 //int *best,待求解的最优装载方案 //int t,子集树数的层号。根节点在第0层，叶节点在第n层 //int n,集装箱的总数 //int &amp;cw, 当前的轮船的荷载 //int bestcw ,当前的最大荷载 //int *x,满足当前最大荷载的装载方案 //int r剩余的集装箱重量和 void load(goods *g, int *x, int t, int n,int cw, int &amp;bestcw ,int *best,int r,int c){ if(t&gt;n) { //已经遍历的到叶子结点，得到了一个解决方案 if(cw&gt;bestcw)	{ for(int i=0;i&lt;n;i&#43;&#43;) best[i]=x[i]; bestcw=cw; } }	else{ //每个结点可以有两个分支，分别利用约束规则和限界规则进行剪枝 r=r-g[t]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b81057cbe5e119286c477f2933efd771/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-23T08:46:17+08:00" />
<meta property="article:modified_time" content="2019-10-23T08:46:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法设计与分析回溯算法之装载问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>回溯算法之装载问题</h2> 
<h3><a id="_1"></a>问题描述</h3> 
<p>给定n个集装箱要装上一艘载重量为c的轮船，其中集装箱i的重量为wi。集装箱装载问题要求确定在不超过轮船载重量的前提下，将尽可能多的集装箱装上轮船（贪心算法中的装载问题讨论的是装载件数；本题讨论的是最大装载重量。）<br> 由于集装箱问题是从n个集装箱里选择一部分集装箱，假设解向量为X(x1, x2, …, xn)，其中xi∈{0, 1}， xi =1表示集装箱i装上轮船， xi =0表示集装箱i不装上轮船。<br> 输入<br> 每组测试数据：第1行有2个整数c和n。C是轮船的载重量（0＜c＜30000），n是集装箱的个数（n≤20）。第2行有n个整数w1, w2, …, wn，分别表示n个集装箱的重量。<br> 输出<br> 对每个测试例，输出两行：第1行是装载到轮船的最大载重量，第2行是集装箱的编号。</p> 
<p>输入样例<br> 34 3<br> 21 10 5<br> 输出（考虑最大装载量的最优解）<br> 31（重量）<br> 1 2</p> 
<p>考虑最大装载件数的最优解<br> 2（件）<br> 5 10</p> 
<h3><a id="_21"></a>算法分析</h3> 
<p>该问题的形式化描述为：<br> <img src="https://images2.imgbox.com/91/03/gDsbcrou_o.png" alt="在这里插入图片描述"><br> 用回溯法解装载问题时，其解空间是一棵子集树，与0 - 1背包问题的解空间树相同。<br> <img src="https://images2.imgbox.com/04/7d/p06In0PX_o.png" alt="在这里插入图片描述"><br> 可行性<strong>约束函数</strong>可剪去<strong>不</strong>满足约束条件的子树：<br> <img src="https://images2.imgbox.com/03/2a/y1gRLxuV_o.png" alt="在这里插入图片描述"></p> 
<p>令cw(t)表示从根结点到<strong>第t层结点</strong>为止装入轮船的重量，即部分解(x1, x2 , …, xt)的重量：<br> <img src="https://images2.imgbox.com/1f/80/A8ZiPeCb_o.png" alt="在这里插入图片描述"></p> 
<p>当<strong>cw(t)&gt;c</strong>时，表示该子树中所有结点<strong>都不满足</strong>约束条件，可将该子树剪去。</p> 
<h3><a id="_33"></a>代码</h3> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
class goods{
	int weight;
public:
	goods(int w=0):weight(w)
	{}
	int get_w(){
		return weight;
	}
	void set(int w){
		weight=w;
	}
	
};

//goods *g,集装箱列表
 //int *best,待求解的最优装载方案
 //int t,子集树数的层号。根节点在第0层，叶节点在第n层
 //int n,集装箱的总数
//int &amp;cw, 当前的轮船的荷载
//int bestcw ,当前的最大荷载
//int *x,满足当前最大荷载的装载方案
//int r剩余的集装箱重量和
void load(goods *g, int *x, int t, int n,int cw, int &amp;bestcw ,int *best,int r,int c){
	if(t&gt;n) {     //已经遍历的到叶子结点，得到了一个解决方案
	    if(cw&gt;bestcw)	{
		for(int i=0;i&lt;n;i++)
	       	    best[i]=x[i];
		    bestcw=cw;
		}
	}	
   else{ //每个结点可以有两个分支，分别利用约束规则和限界规则进行剪枝
	r=r-g[t].get_w();//剩余未处理的物品的重量和，与是否选取当前物品无关
	if(cw+g[t].get_w()&lt;=c){ //  根据题意中的约束条件进行剪枝
	  	x[t]=1;
		cw=cw+g[t].get_w(); //当前装入的物品的重量和
		load(g,x,t+1,n,cw,bestcw,best,r,c);
		cw=cw-g[t].get_w(); //回溯的需要
	}
	if(cw+r&gt;bestcw) {    //限界规则
		x[t]=0;
		load(g,x,t+1,n,cw,bestcw,best,r,c);
	}
	r=r+g[t].get_w(); //回溯的需要
      }
   }
int main(){
	int n,c,bestcw=0;
	int *x,*best, r=0;
	cout&lt;&lt;“请输入物品的件数和轮船的装载重量：";
	cin&gt;&gt;n&gt;&gt;c;
	goods *g;
	g=new goods[n];
	x=new int [n];
	best=new int[n];
	cout&lt;&lt;"请输入每件物品的重量：";
	for(int i=0;i&lt;n;i++)	{
		int w;	cin&gt;&gt;w;  g[i].set(w);r=r+w;
	}
	load(g,x,0,n,0,bestcw,best,r,c);
	cout&lt;&lt;bestcw&lt;&lt;endl;
	for(i=0;i&lt;n;i++)
		cout&lt;&lt;best[i]&lt;&lt;"  ";
	cout&lt;&lt;endl;
	return 0;
}

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad7fa6b82b5876f6e20b83c8b0cb52ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【复杂网络社团发现】GN算法边介数详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03bab4d2d89fa748a964528633e98289/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">实时处理中帧之间的拼接问题即端点效应咋解决啊？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>