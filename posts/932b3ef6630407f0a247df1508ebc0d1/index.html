<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GNU Radio教程 9.QPSK调制解调 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GNU Radio教程 9.QPSK调制解调" />
<meta property="og:description" content="MPSK解调教程
在本教程中，我们将专注于模拟而不是无线传输。它将讨论在发送和接收具有真实硬件和通道效果的信号时所涉及的许多问题。我们将通过设置我们的模拟，然后逐步如何恢复信号。
在本教程中，请记住，这只是处理数字信号接收的一种方法。已经为这些步骤设计了各种算法和方法，不同类型的数字信号将表现不同。在这里，我们经历了一系列阶段，并使用 GNU Radio 中现成的算法进行 PSK 信号接收和解调。但是，本教程绝不应暗示这是完成此任务的唯一方法。
内容：
1 Objectives 目标
2 Prerequisites 先决条件
3 Notes 笔记
4 Transmitting a Signal 发送信号
5 Adding Channel Impairments 添加信道障碍
6 Recovering Timing
6.1 Details of the Polyphase Clock Sync Block
6.2 Using the Polyphase Clock Sync Block in Our Receiver
7 Multipath 多路径
8 Equalizers 均衡器
9 Phase and Fine Frequency Correction 相位和频率矫正
10 Decoding 解码
一、目标
理解信号失真和信道造成的影响。
认识恢复信号所需的阶段。
定时恢复 Time recovery" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/932b3ef6630407f0a247df1508ebc0d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-17T18:45:46+08:00" />
<meta property="article:modified_time" content="2022-11-17T18:45:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GNU Radio教程 9.QPSK调制解调</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:center;"><strong>MPSK</strong><strong>解调教程</strong></p> 
<p style="margin-left:0;text-align:justify;">在本教程中，我们将专注于模拟而不是无线传输。它将讨论在发送和接收具有真实硬件和通道效果的信号时所涉及的许多问题。我们将通过设置我们的模拟，然后逐步如何恢复信号。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">在本教程中，请记住，这只是处理数字信号接收的一种方法。已经为这些步骤设计了各种算法和方法，不同类型的数字信号将表现不同。在这里，我们经历了一系列阶段，并使用 GNU Radio 中现成的算法进行 PSK 信号接收和解调。但是，本教程绝不应暗示这是完成此任务的唯一方法。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>内容：</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>1  Objectives    </strong><strong>目标</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>2  Prerequisites     </strong><strong>先决条件</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>3  Notes             </strong><strong>笔记</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>4  Transmitting a Signal            </strong><strong>发送信号</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>5  Adding Channel Impairments        </strong><strong>添加信道障碍</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>6  Recovering Timing</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>6.1 Details of the Polyphase Clock Sync Block</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>6.2 Using the Polyphase Clock Sync Block in Our Receiver</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>7  Multipath        </strong><strong>多路径</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>8  Equalizers        </strong><strong>均衡器</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>9  Phase and Fine Frequency Correction        </strong><strong>相位和频率矫正</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>10 Decoding        </strong><strong>解码</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>一、目标</strong></p> 
<p style="margin-left:0;text-align:justify;">理解信号失真和信道造成的影响。</p> 
<p style="margin-left:0;text-align:justify;">认识恢复信号所需的阶段。</p> 
<p style="margin-left:0;text-align:justify;"><strong>定时恢复 Time recovery</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>多径信道 Multipath channels</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>相位和频率校正  Phase and frequency correction</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>解符号和位排序  Decoding symbols and bit ording</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>二、先决条件</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="228" src="https://images2.imgbox.com/04/c5/XKLhzK3t_o.png" width="738"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>三、Notes</strong></p> 
<p style="margin-left:0;text-align:justify;">当前教程已针对 GNU Radio 版本 3.9 进行了更新。CMA 均衡器和 LMS DD 均衡器已在 3.9 中弃用，并将在未来的版本中删除。它们已被Linear_Equalizer和Adaptive_Algorithm取代。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">目的是让读者研究流程图和结果输出，但不一定要构建每一个。如果需要参考，可以在[2]中找到 3.7 版的原始流程图。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>四、发送信号</strong></p> 
<p style="margin-left:0;text-align:justify;">第一阶段是发送 QPSK 信号。我们生成一个比特流并将其调制到一个复数星座上。为此，我们使用<span style="color:#ff0000;">Constellation Modulator </span><span style="color:#ff0000;">模块，该模块使用Constellation Rect. Object和其他设置来控制发送的信号</span>。Constellation Modulator 的 Constellation 参数是 Constellation Rect.Objectid。对象 (qpsk_const)，即使它在流程图上显示为其他内容。</p> 
<p style="margin-left:0;text-align:justify;">Constellation object允许我们确定符号的编码方式。然后，调制器模块可以使用这种调制方案带或不带<span style="color:#ff0000;">差分编码</span>。星座调制器模块期望输入打包的字节，因此我们有一个随机源生成器，提供值为 0 - 255 的字节。</p> 
<p style="margin-left:0;text-align:justify;">在处理每个符号的样本数量时，我们希望使该值尽可能小（最小值为 2）。通常，我们可以使用此值来帮助我们将所需的比特率与我们将使用的硬件设备的采样率相匹配。由于我们使用的是仿真，每个符号的样本数仅在确保我们在整个流程图中匹配此速率时才重要。我们将在这里使用 4，这比我们需要的要大，但对于可视化不同域中的信号很有用。</p> 
<p style="margin-left:0;text-align:justify;">最后，我们设置excess bandwidth value。星座调制器模块使用<span style="color:#ff0000;">根升余弦 (RRC) 脉冲整形滤波器</span>，它为我们提供了一个参数来调整the roll-off factor of the filter，通常在数学上称为“alpha”。下面的 mpsk_rrc_rolloff.grc 流程图生成了一个图示，显示了不同的values of the excess bandwidth。典型值介于 0.2（红色迹线）和 0.35（绿色迹线）之间。</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="377" src="https://images2.imgbox.com/9b/91/8VNLsTUw_o.png" width="594"></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="429" src="https://images2.imgbox.com/2d/1c/htgAixBk_o.png" width="603"></p> 
<p style="margin-left:0;text-align:justify;">示例流程图 mpsk_stage1.grc 传输 QPSK 星座调制信号。它绘制了发射信号和部分the receiver chain的时域、频域图，还有星座图。变量</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="27" src="https://images2.imgbox.com/aa/7f/sCgWpMuv_o.png" width="614"></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="353" src="https://images2.imgbox.com/be/38/2Wu6JlPd_o.png" width="661"></p> 
<p style="margin-left:0;text-align:justify;">在星座图中，我们看到了up-sampling（每个符号生成 4 个样本）的效果和过滤过程。在这种情况下，RRC 滤波器会添加有意的自干扰，称为符号间干扰 (ISI)。ISI 对接收信号不利，因为它将符号模糊在一起。我们将在时序恢复部分深入研究这一点。现在，让我们看看我们对信号做了什么。如果您只是从该图中查看传输的信号，那么<span style="color:#ff0000;">您应该会看到频率图显示了一个形状很好的信号，并且该信号会滚降到噪声中</span>。<span style="color:#ff0000;">如果我们不对信号放置整形滤波器，我们将在相邻信道中发射大能量的方波。通过减少带外发射，我们的信号现在可以很好地保持在我们通道的带宽内。</span></p> 
<p style="margin-left:0;text-align:justify;">在接收端，我们通过使用另一个过滤器来消除 ISI。基本上，我们所做的是有目的地在发射机上使用一个滤波器，即 RRC 滤波器，它创建了 ISI。但是当我们将两个 RRC 滤波器卷积在一起时，我们会得到一个升余弦滤波器，它是奈奎斯特滤波器的一种形式。因此，知道了发送 RRC 滤波器的这一特性，我们可以在接收器处使用另一个 RRC 滤波器。<span style="color:#ff0000;">滤波在这里只是一个卷积，因此接收侧 RRC 滤波器的输出是一个升余弦脉冲整形信号，具有最小的 ISI。</span>另一个好处是，在没有信道影响的情况下，我们正在做的是在接收器处使用匹配滤波器。</p> 
<p style="margin-left:0;text-align:justify;"><strong>五、添加信道影响</strong></p> 
<p style="margin-left:0;text-align:justify;">第一阶段的例子只涉及发射 QPSK 信号的机制。我们现在将研究通道的影响，以及信号在传输时和我们在接收器中看到信号时是如何失真的。第一步是在mpsk_stage2.grc添加一个信道模型。首先，我们将使用 GNU Radio 最基本的Channel Model模块。</p> 
<p style="margin-left:0;text-align:justify;">这个模块允许我们模拟一些我们必须处理的主要问题。接收器的第一个问题是噪音。我们接收器中的热噪声会导致我们称之为<span style="color:#ff0000;">加性高斯白噪声 (AWGN)</span>的噪声。我们通过调整信道模型的噪声电压值来设置噪声功率。我们在这里指定电压而不是功率，因为​​我们需要知道信号的带宽才能正确计算功率。GNU Radio模块的特点之一是独立性，因此信道模型对输入信号一无所知。我们可以根据仿真的其他参数从所需的功率水平计算噪声电压。</p> 
<p style="margin-left:0;text-align:justify;">两个无线电之间的另一个重要问题是驱动无线电频率的<span style="color:#ff0000;">不同时钟</span>。一方面，时钟是不完美的，因此在无线电之间是不同的。一个无线电名义上以 fc（例如 450 MHz）传输，但缺陷意味着它实际上是在 fc + f_delta_1 传输。同时，另一个无线电具有不同的时钟，因此具有不同的偏移量 f_delta_2。当它设置为 fc 时，实际频率为 fc + f_delta_2。最后，接收到的信号将是 f_delta_1 + f_delta_2 ，我们认为它应该是（这些增量可能是正的或负的）。</p> 
<p style="margin-left:0;text-align:justify;">与时钟问题相关的是理想的采样点。我们已经在发射机中对我们的信号进行了<span style="color:#ff0000;">up-sampled</span>并对其进行整形，但是在接收它时，我们需要在原始采样点对信号进行采样，以最大限度地提高信号功率并最大限度地减少码间干扰。就像我们在添加第二个 RRC 滤波器后的第 1 阶段模拟中一样，我们可以看到在每个符号的 4 个样本中，其中一个位于 +1、-1 或 0 的理想采样点。但同样，两个无线电是以不同的速度运行，因此<span style="color:#ff0000;">理想的采样点</span>是未知的。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">我们仿真的第二阶段允许我们使用这些<span style="color:#ff0000;">附加噪声、频率偏移和时间偏移</span>的影响。当我们运行此图时，我们添加了一些噪声 (0.2)、一些频率偏移 0.025) 和一些时间偏移 (1.0005) 以查看结果信号。</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="301" src="https://images2.imgbox.com/42/62/uJMaEuFq_o.png" width="784"></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="473" src="https://images2.imgbox.com/12/3e/3l2ZhZw8_o.png" width="835"></p> 
<p style="margin-left:0;text-align:justify;">星座图向我们展示了一堆样本，比我们在上一阶段开始的情况要糟糕得多。<span style="color:#ff0000;">从这个接收到的信号中，我们现在必须撤消所有这些影响。</span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">六、Recovering Timing</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">现在我们将介绍恢复过程。请记住，我们可以使用许多算法来恢复每个阶段。有些可以同时进行多个阶段的联合恢复。我们将在这里</span><span style="color:#ff0000;">使用the polyphase clock recovery algorithm多相时钟恢复算法</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">我们将从timing recovery开始。我们试图找到对输入信号进行采样的最佳时间，这将最大化每个样本的信噪比 (SNR) 并减少符号间干扰 (ISI) 的影响。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">我们可以使用示例流程图 symbol_sampling.grc 来说明 ISI 问题，其中我们只需create four separate symbols of 1's in a row and then filter them。过滤的第一阶段对每个符号的“sps”样本进行up-samples，并使用根升余弦滤波器。我们使用另一个不改变速率的根升余弦滤波器来遵循这一点。此处的第二个 RRC 滤波器将使用非 Nyquist RRC 滤波器的信号转换为我们在本教程第一阶段讨论的 Nyquist 升余弦 (RC) 滤波器。输出如下图所示，显示了 RRC 和 RC 滤波符号之间的差异。如果没有奈奎斯特滤波，我们可以看到在每个符号的理想采样点，其他符号如何具有一些能量。如果我们像在连续的样本流中那样将这些符号加在一起，那么其他样本的能量会加在一起并在该点扭曲符号。相反，在 RC 滤波输出中，来自其他样本的能量在给定符号时间的理想采样点处为 0。这意味着如果我们在正确的采样点进行采样，我们只会从当前符号中获取能量，而不会受到流中其他符号的干扰。同样，我们看到的是时序恢复如何应用匹配滤波器来满足 Nyquist ISI 标准。这意味着如果我们在正确的采样点进行采样，我们只会从当前符号中获取能量，而不会受到流中其他符号的干扰。同样，我们看到的是时序恢复如何应用匹配滤波器来满足 Nyquist ISI 标准。这意味着如果我们在正确的采样点进行采样，我们只会从当前符号中获取能量，而不会受到流中其他符号的干扰。同样，我们看到的是时序恢复如何应用匹配滤波器来满足 Nyquist ISI 标准。</span></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="350" src="https://images2.imgbox.com/3e/fc/hcKsJeyd_o.png" width="714"></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="351" src="https://images2.imgbox.com/79/65/vspCuC2d_o.png" width="696"></p> 
<p style="margin-left:0;text-align:justify;">这种仿真使我们能够轻松调整每个符号的样本数、RRC 滤波器的excess bandwidth以及taps数。然后我们可以使用这些不同的值来查看它们如何影响采样点的行为。</p> 
<p style="margin-left:0;text-align:justify;">接下来，让我们看看由于不同的时钟影响,发送器和接收器之间的采样点会发生什么。使用 symbol_sampling_diff.grc 中的示例流程图，我们模拟了发送器和接收器中不同时钟的影响。每个时钟都是不完美的，因此（a）将在不同的时间点开始，（b）相对于其他时钟漂移。我们通过添加一个重采样器来模拟这一点，该重采样器可以稍微调整传输信号（在上面的传输图像中）和接收器之间的符号采样时间，如下所示。此处显示的 1.125 的时钟差异是极端的，作为在此设置中作为可视化技术显示它的一种方式。实际上，时间差异大约为百万分之几。但在这里，请注意，由于样本是在不同时间点收集的，</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="363" src="https://images2.imgbox.com/48/2b/owgkysud_o.png" width="800"></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="345" src="https://images2.imgbox.com/f1/3d/s20q2kPp_o.png" width="722"></p> 
<p style="margin-left:0;text-align:justify;">我们这里的任务是<span style="color:#ff0000;">仅使用来自输入样本的接收器信息</span>来同步发送和接收器时钟。这项工作称为时钟或timing recovery。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">6.1 Details of the Polyphase Clock Sync Block   </p> 
<p style="margin-left:0;text-align:justify;">多相时钟同步模块的详细信息</p> 
<p style="margin-left:0;text-align:justify;">6.2 Using the Polyphase Clock Sync Block in Our Receiver</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="267" src="https://images2.imgbox.com/a9/74/qZnVzM5Q_o.png" width="564"></p> 
<p style="margin-left:0;text-align:justify;">运行此流程图时，我们看到左侧的星座是timing recovery前的接收信号，右侧是timing recovery后的接收信号。It's still a little noisy as a result of the ISI after the 32 filters, which is quickly absorbed by noise once we adjust the channels Noise Voltage setting to be more than 0.（32 个滤波器之后的 ISI，仍然有点噪声影响，一旦我们将信道的噪声电压设置调整为大于 0，它就会很快被噪声吸收。）</p> 
<p style="margin-left:0;text-align:justify;">然后我们可以改变时间和频率偏移。<span style="color:#ff0000;">左右移动timing bar向我们展示了clock sync block如何在时域保持信号并将输出信号锁定（或非常接近）理想星座点处。</span>当我们添加频率偏移时，我们可以看到星座变成了一个圆圈。星座仍然在单位圆上，这表示时域仍是正确的，但是该模块不允许我们校正频率偏移。稍后我们仍然需要处理这个。</p> 
<p style="margin-left:0;text-align:justify;">同样，我们可以通过更改我们使用的 taps 变量的版本来更改多路径仿真环境。添加多路径将向我们展示时钟恢复模块对多路径的鲁棒性，但不会对其进行纠正，因此我们需要其他东西来处理它。</p> 
<p style="margin-left:0;text-align:justify;"><strong>七、多路径</strong></p> 
<p style="margin-left:0;text-align:justify;">让我们首先了解什么是多路径。关于多路径的主题已经写了很多，我们将在这里充分探索它，以大致了解它的来源以及它如何影响我们的通信能力。我们不会详细介绍真实衰落通道或如何分析它们的属性。</p> 
<p style="margin-left:0;text-align:justify;">多路径源于这样一个事实，即在大多数通信环境中，我们没有单一的路径让信号从发射器传播到接收器。如下图所示，只要有物体反射信号，就可以在两个节点之间建立新路径。建筑物、标志、树木、人等表面都可以产生信号反射。根据路径的长度，这些反射路径中的每一个都将在不同的时间出现在接收器上。在接收器处将这些加在一起会导致失真，无论是建设性的还是破坏性的。</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="282" src="https://images2.imgbox.com/16/01/KBluO4fF_o.png" width="473"></p> 
<p style="margin-left:0;text-align:justify;">这些信号在接收器处组合的影响是信号失真。如果反射之间的时间差相对于符号的宽度足够小，则失真可能在符号内——intra-symbol interference符号内干扰。当反射比符号时间长时，一个符号的反射会影响后面的信号——这是inter-symbol interference符号间干扰的另一个原因。</p> 
<p style="margin-left:0;text-align:justify;">我们需要纠正这种行为，我们可以使用一种非常类似于立体声均衡器的机制来做到这一点。事实上，我们称它们为<span style="color:#ff0000;">均衡器</span>。使用立体声均衡器，我们可以改变某些频率的增益来抑制或增强这些信号——低音和高音是常见的。我创建了一个名为 multipath_sim.grc 的非常简单的示例来帮助我们探索它在频域中的样子。</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="411" src="https://images2.imgbox.com/ee/52/6NcIe5GI_o.png" width="767"><br> 这个模拟设置了一个通道模型，为一个通道提供五个均衡器控件，我们可以更改其中四个。这些控件的频率设置相同，我们可以将它们从 0 调整到 1。值为 1 时，控件将允许这些频率不受阻碍地通过。在值为 0 时，它们将在频谱中产生一个深度零点，这将影响它周围的所有频率。频率图设置为平均。</p> 
<p style="margin-left:0;text-align:justify;">    虽然在此示例中，我们明确控制频域，但我们真正在玩的是创建均衡器的能力，该均衡器可以校正或调整接收信号的频率响应。最终，目标如下图所示，其中多径信道会在信号中产生一些失真，如频域所示。均衡器的任务是反转该通道。基本上，我们想要消除由通道引起的失真，使均衡器的输出是平坦的。但是，我们不是手动调整水龙头，而是有算法为我们更新这些水龙头。我们的工作是使用正确的均衡器算法并设置参数。这里的一个重要参数是均衡器中的抽头数。正如我们在模拟中看到的，五个抽头对频率响应进行了相当粗略的控制。或者，抽头越多，计算抽头以及针对信号运行均衡器所需的时间就越多。</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="547" src="https://images2.imgbox.com/62/d4/VFuZAHM7_o.png" width="777"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>八、均衡器</strong></p> 
<p style="margin-left:0;text-align:justify;">CMA 均衡器和 LMS DD 均衡器已在 3.9 中弃用，并将在未来的版本中删除。它们已被Linear_Equalizer和Adaptive_Algorithm取代。自适应算法具有 CMA 算法类型，因此它可以直接替代 CMA 均衡器。CMA 或恒定模数算法是一种盲均衡器，但它仅适用于具有恒定幅度或模数的信号。这意味着像 MPSK 这样的数字信号是很好的候选者，因为它们仅在单位圆上有点（回想一下我们所做的实验，我们锁定了信号时序但有频率偏移；我们看到的是单位圆）。</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="344" src="https://images2.imgbox.com/6f/9d/e31vOmaw_o.png" width="719"></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="424" src="https://images2.imgbox.com/e7/e7/A1yL3vST_o.png" width="726"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>九、相位和频率偏移矫正</strong></p> 
<p style="margin-left:0;text-align:justify;">    鉴于我们已经均衡了通道，我们仍然存在相位和频率偏移的问题。均衡器往往不能快速适应，因此频率偏移很容易超出均衡器跟上的能力。此外，如果我们只是运行 CMA 均衡器，它所关心的只是收敛到单位圆。它不知道星座，所以当它锁定时，它将锁定在任何给定的相位。我们现在需要校正任何相位偏移以及任何频率偏移。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>十、解码</strong></p> 
<p style="margin-left:0;text-align:justify;">    现在困难的部分已经完成，我们开始解码信号。首先，我们在 Costas 循环之后插入一个星座解码器，但我们的工作还没有完成。此时，我们得到从 0 到 3 的符号，因为这是 QPSK 方案中字母表的大小。但是，在那些 0-3 个符号中，我们如何确定我们具有与传输时相同的符号到星座点的映射？请注意，在我们上面的讨论中，我们所做的任何事情都不知道传输的符号到星座映射，这意味着我们可能在星座中有 90 度的模糊度。幸运的是，我们通过传输差分符号避免了这个问题. 我们实际上并没有传输星座本身，我们通过将星座调制器模块中的差分设置设置为真来传输星座符号之间的差异。所以现在我们撤消它。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/043381ec35195a7c57fd4f62956cf6f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用python将pdf转化为长图片</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a5576ffb2ce818c7a9d79ec00ce5a9a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mac M1pro芯片安装vmware虚拟机及centos8(界面化&#43;黑窗口)详细教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>