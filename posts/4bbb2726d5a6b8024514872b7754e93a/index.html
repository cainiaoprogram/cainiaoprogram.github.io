<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>集美大学计算机组成原理复习(软件工程专业) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="集美大学计算机组成原理复习(软件工程专业)" />
<meta property="og:description" content="第一章
1. 冯诺依曼体系三大要点：二进制，存储程序，五大部件 P2
（1）采用二进制代码表示数据和指令，即数据和指令的数字化。
（2）采用存储程序工作方式，即事先编制程序，事先存储程序，自动、连续地执行程序。（3）由存储器、运算器、控制器、输入设备、输出设备5大部件组成计算机硬件系统
存储程序工作方式三点含义 P3 1.事先编制程序
将求解问题的处理过程用程序来实现。在程序中规定计算机需要做哪些事，按什么步骤去做。预先编好的程序最终变成：指令序列和有关的原始数据。
2.事先存储程序
编好的程序经由输入设备送入计算机，存放在存储器中。
3.自动、连续地执行程序
由于程序已经事先存储在存储器中，启动计算机并运行程序后，计算机就可以依照一定顺序从存储器中逐条读取指令，按照指令的要求执行操作，直到运行的程序执行完毕。
3. CPU区分数据和指令，指令的连续执行基本方式，ALU ，两大类控制器 P6-7
1. 区分数据和指令 指令的连续执行基本方式
在CPU中有一个程序计数器PC，存放着当前指令所在存储单元的地址。如果程序是顺序执行，在读取一个或连续几个存储单元的指令代码后，PC的内容就加1或加几，以指出下一条指令的地址：如果程序需要转移，则将转移地址送入PC。因此，PC就像一个指针，指引着程序的执行顺序。可按照PC中的地址信息去读取指令，再按照指令给出的操作数地址去读取数据。
2. ALU
CPU内有一个或多个算术逻辑部件ALU。通常按照指令的要求将有关数据送入ALU，进行指定的算术或逻辑运算，然后将运算结果送到主存单元，或暂存在CPU内的寄存器中。
3.两大类控制器
组合逻辑控制器和微程序控制器。
组合逻辑控制器完全靠若干组合逻辑电路产生微命令序列。其优点是形成微命令的速度快。
微程序控制器是将微命令序列以代码形式编制成微程序，存入一个控制存储器中；当CPU执行指令时，通过读取并执行对应的一段微程序，产生微命令序列，控制完成指定的操作。微程序控制方式比较规整，硬件代价较小，易于扩充功能，但速度较慢。
4. 主存储器（内存）的单元组成与地址 P7
主存储器划分为许多单元，通常每个单元存放8位二进制数，称为1字节。每个单元都有一个唯一的编号，称为存储单元地址，简称地址。向主存储器送出某个地址编码，就能根据地址选中对应的一个单元。主存储器的一项重要特性是：能按地址存取内容，也就是允许CPU直接编址访问。
5. 总线的三大类型 P8
系统总线可分为三组，即地址总线、数据总线和控制总线
地址总线: CPU如果需要访问主存，就向地址总线送出地址码以选择某个主存单元：
数据总线: 通过数据总线送出数据，写入主存：或从主存读出数据，通过数据总线送入CPU的寄存器。
控制总线: 大部分控制信号是由CPU提供的，它们通过控制总线送往主存和IO设备：也有些信号是IO设备提供的，其中有些信号也送往CPU。
6. 语言处理的两种类型：解释与编译，具体含义，区别 P10-11
解释方式: 边解释边执行。将源程序输入计算机后，启动并执行解释器，逐步分析源程序中的语句，执行一个等价的机器语言指令序列，直到整个源程序都被扫描一遍，并被解释执行完毕。
优点: 支持人机对话方式的程序设计，可以边执行边修改：所需主存较小。
缺点: 执行速度较慢，不能解释那些前后关联较多、较难理解的程序设计语言。
编译方式: 将源程序输入计算机后，先启动编译器将源程序全部翻译成机器语言指令序列。执行时，计算机将直接执行目标程序，不再需要源程序与翻译程序。
优点: 运行用户程序时，所需主存较小，执行速度较快。
缺点: 在编译过程中，所需主存较多：花费时间较长。
7. 虚拟机的概念，JVM虚拟机工作原理与其意义 P15
虚拟机是通过配置软件扩充机器功能后所形成的一台计算机。实际硬件在物理功能级上并不具备这种机器功能，因而称为虚拟机。采用虚拟机概念是计算机设计中的又一重要策略，它将功能抽象出来，使其脱离具体的物理机器，这有利于摆脱真实物理机细节的束缚，获得超越物理机的功能。
8. 软硬件逻辑等价的意义 P15
有许多功能既可以直接由硬件实现，也可以在硬件支持下靠软件实现，对用户来说在功能上是等价的，我们称为软、硬件在功能上的逻辑等价。
设计指令系统时，选择恰当的软、硬件功能分配,使计算机结构简单而又具有较强的功能或有更高的处理速度; 在软件支持下具有更强的功能
9. 指令执行过程 P17-18" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4bbb2726d5a6b8024514872b7754e93a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-30T21:44:27+08:00" />
<meta property="article:modified_time" content="2023-10-30T21:44:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">集美大学计算机组成原理复习(软件工程专业)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:justify;"><strong>第一章</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>1. </strong><strong>冯诺依曼体系三大要点：二进制，存储程序，五大部件 P2</strong></p> 
<p style="margin-left:0;text-align:justify;">（1）采用二进制代码表示数据和指令，即数据和指令的数字化。</p> 
<p style="margin-left:0;text-align:justify;">（2）采用存储程序工作方式，即事先编制程序，事先存储程序，自动、连续地执行程序。（3）由存储器、运算器、控制器、输入设备、输出设备5大部件组成计算机硬件系统</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><strong>存储程序工作方式三点含义 P3</strong></li></ol> 
<p style="margin-left:0;text-align:justify;">1.事先编制程序</p> 
<p style="margin-left:0;text-align:justify;">将求解问题的处理过程用程序来实现。在程序中规定计算机需要做哪些事，按什么步骤去做。预先编好的程序最终变成：指令序列和有关的原始数据。</p> 
<p style="margin-left:0;text-align:justify;">2.事先存储程序</p> 
<p style="margin-left:0;text-align:justify;">编好的程序经由输入设备送入计算机，存放在存储器中。</p> 
<p style="margin-left:0;text-align:justify;">3.自动、连续地执行程序</p> 
<p style="margin-left:0;text-align:justify;">由于程序已经事先存储在存储器中，启动计算机并运行程序后，计算机就可以依照一定顺序从存储器中逐条读取指令，按照指令的要求执行操作，直到运行的程序执行完毕。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>3. CPU</strong><a name="_Hlk125637134"><strong>区分数据和指令</strong></a><strong>，指令的连续执行基本方式，ALU ，两大类控制器 P6-7</strong></p> 
<p style="margin-left:0;text-align:justify;">1. 区分数据和指令 指令的连续执行基本方式</p> 
<p style="margin-left:0;text-align:justify;">在CPU中有一个程序计数器PC，存放着当前指令所在存储单元的地址。如果程序是顺序执行，在读取一个或连续几个存储单元的指令代码后，PC的内容就加1或加几，以指出下一条指令的地址：如果程序需要转移，则将转移地址送入PC。因此，PC就像一个指针，指引着程序的执行顺序。可按照PC中的地址信息去读取指令，再按照指令给出的操作数地址去读取数据。</p> 
<p style="margin-left:0;text-align:justify;">2. ALU</p> 
<p style="margin-left:0;text-align:justify;">CPU内有一个或多个算术逻辑部件ALU。通常按照指令的要求将有关数据送入ALU，进行指定的算术或逻辑运算，然后将运算结果送到主存单元，或暂存在CPU内的寄存器中。</p> 
<p style="margin-left:0;text-align:justify;">3.两大类控制器</p> 
<p style="margin-left:0;text-align:justify;">组合逻辑控制器和微程序控制器。</p> 
<p style="margin-left:0;text-align:justify;">组合逻辑控制器完全靠若干组合逻辑电路产生微命令序列。其优点是形成微命令的速度快。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">微程序控制器是将微命令序列以代码形式编制成微程序，存入一个控制存储器中；当CPU执行指令时，通过读取并执行对应的一段微程序，产生微命令序列，控制完成指定的操作。微程序控制方式比较规整，硬件代价较小，易于扩充功能，但速度较慢。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>4. </strong><strong>主存储器（内存）的单元组成与地址 P7</strong></p> 
<p style="margin-left:0;text-align:justify;">主存储器划分为许多单元，通常每个单元存放8位二进制数，称为1字节。每个单元都有一个唯一的编号，称为存储单元地址，简称地址。向主存储器送出某个地址编码，就能根据地址选中对应的一个单元。主存储器的一项重要特性是：能按地址存取内容，也就是允许CPU直接编址访问。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>5. </strong><strong>总线的三大类型 P8</strong></p> 
<p style="margin-left:0;text-align:justify;">系统总线可分为三组，即地址总线、数据总线和控制总线</p> 
<p style="margin-left:0;text-align:justify;">地址总线: CPU如果需要访问主存，就向地址总线送出地址码以选择某个主存单元：</p> 
<p style="margin-left:0;text-align:justify;">数据总线: 通过数据总线送出数据，写入主存：或从主存读出数据，通过数据总线送入CPU的寄存器。</p> 
<p style="margin-left:0;text-align:justify;">控制总线: 大部分控制信号是由CPU提供的，它们通过控制总线送往主存和IO设备：也有些信号是IO设备提供的，其中有些信号也送往CPU。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>6. </strong><strong>语言处理的两种类型：解释与编译，具体含义，区别 P10-11</strong></p> 
<p style="margin-left:0;text-align:justify;">解释方式: 边解释边执行。将源程序输入计算机后，启动并执行解释器，逐步分析源程序中的语句，执行一个等价的机器语言指令序列，直到整个源程序都被扫描一遍，并被解释执行完毕。</p> 
<p style="margin-left:0;text-align:justify;">优点: 支持人机对话方式的程序设计，可以边执行边修改：所需主存较小。</p> 
<p style="margin-left:0;text-align:justify;">缺点: 执行速度较慢，不能解释那些前后关联较多、较难理解的程序设计语言。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">编译方式: 将源程序输入计算机后，先启动编译器将源程序全部翻译成机器语言指令序列。执行时，计算机将直接执行目标程序，不再需要源程序与翻译程序。</p> 
<p style="margin-left:0;text-align:justify;">优点: 运行用户程序时，所需主存较小，执行速度较快。</p> 
<p style="margin-left:0;text-align:justify;">缺点: 在编译过程中，所需主存较多：花费时间较长。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>7. </strong><strong>虚拟机的概念，JVM虚拟机工作原理与其意义 P15</strong></p> 
<p style="margin-left:0;text-align:justify;">虚拟机是通过配置软件扩充机器功能后所形成的一台计算机。实际硬件在物理功能级上并不具备这种机器功能，因而称为虚拟机。采用虚拟机概念是计算机设计中的又一重要策略，它将功能抽象出来，使其脱离具体的物理机器，这有利于摆脱真实物理机细节的束缚，获得超越物理机的功能。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>8. </strong><strong>软硬件逻辑等价的意义 P15</strong></p> 
<p style="margin-left:0;text-align:justify;">有许多功能既可以直接由硬件实现，也可以在硬件支持下靠软件实现，对用户来说在功能上是等价的，我们称为软、硬件在功能上的逻辑等价。</p> 
<p style="margin-left:0;text-align:justify;">设计指令系统时，选择恰当的软、硬件功能分配,使计算机结构简单而又具有较强的功能或有更高的处理速度; 在软件支持下具有更强的功能</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>9. </strong><strong>指令执行过程 P17-18</strong></p> 
<p style="margin-left:0;text-align:justify;">取指令与指令分析-&gt;读取操作数-&gt;运算-&gt;后继指令地址</p> 
<p style="margin-left:0;text-align:justify;">1.取指令与指令分析</p> 
<p style="margin-left:0;text-align:justify;">CPU中有一个程序计数器PC，它存放着当前指令所在主存单元的地址码。每当读取指令时，先将PC的内容送入主存储器的地址寄存器中，访问主存单元读出指令，然后送入指令寄存器。一条指令代码可能存储在1个或n个存储单元中,PC就相应加1或加n，这时PC指示的就是下一条指令在主存的位置。</p> 
<p style="margin-left:0;text-align:justify;">当指令代码读入到IR之后，指令译码器就自动分析：这是一条什么指令？有关的操作数存于何处？控制器分步发出微操作命令，以实现该指令的功能。</p> 
<p style="margin-left:0;text-align:justify;">2.读取操作数</p> 
<p style="margin-left:0;text-align:justify;">先将指令提供的操作数地址码送入主存的地址寄存器，从该存储单元读出一个操作数，送入CPU中的一个暂存器。</p> 
<p style="margin-left:0;text-align:justify;">另一个操作数存放在CPU的寄存器中，运算后改存运算结果，原来存放的操作数不再保留。</p> 
<p style="margin-left:0;text-align:justify;">3.运算</p> 
<p style="margin-left:0;text-align:justify;">将操作数送入运算器然后将结果送回寄存器</p> 
<p style="margin-left:0;text-align:justify;">4.后继指令地址</p> 
<p style="margin-left:0;text-align:justify;">在读取指令时PC的内容已自动修改，本例不需要转移指令地址，所以PC修改后的内容就是后继指令地址，即下一条待执行指令所在存储单元的地址。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>10. </strong><strong>主存储器容量表示方法 P20</strong></p> 
<p style="margin-left:0;text-align:justify;">(1)字节数</p> 
<p style="margin-left:0;text-align:justify;">按字节编址，即每个编址单元存放8位二进制数，称为1字节，表示为1B。用字节数表示存储容量的大小。</p> 
<p style="margin-left:0;text-align:justify;">(2)字数x 位数</p> 
<p style="margin-left:0;text-align:justify;">按字编址，即每个编址单元存放一个字，其位数等于基本字长。采用字数x位数来表示存储容量的大小。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>第二章</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/8b/e4/TsL3Ut6J_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消<br><strong>1.</strong><strong>原码表示法，只考虑整数 P28</strong></p> 
<p style="margin-left:0;text-align:justify;">原码:补全机器字长,添加符号位</p> 
<p style="margin-left:0;text-align:justify;">十进制:71     真值:1000111     原码:01000111</p> 
<p style="margin-left:0;text-align:justify;">十进制:-71   真值:-1000111    原码:11000111</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>2.</strong><strong>补码表示法，只考虑整数 ,注意补码最高符号位的意义，掌握补码不同位数能够表达的数值范围计算方法 P32 图2-2</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>补码最高符号位意义</strong></p> 
<p style="margin-left:0;text-align:justify;">补码的符号位是通过模运算得到的，它是数值的一部分，可直接参与运算</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>补码不同位数能够表达的数值范围计算方法</strong></p> 
<p style="margin-left:0;text-align:justify;">字长n+1位</p> 
<p style="margin-left:0;text-align:justify;">最小值二进制补码1000…(n个0) 值为-2^n</p> 
<p style="margin-left:0;text-align:justify;">最大二进制补码 0111…(n个1) 值为2^n-1</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">假设机器字长8位</p> 
<p style="margin-left:0;text-align:justify;">正数补码就是原码</p> 
<p style="margin-left:0;text-align:justify;">负数补码变原码:符号位不变,其余各位变反,末位+1(此方法不能用来求最小值)</p> 
<p style="margin-left:0;text-align:justify;">用“取反加一”求－0 或－128 的补码，都是行不通的。</p> 
<p style="margin-left:0;text-align:justify;">用“取反加一”求补码 1000 0000 对应的原码，也是不灵的。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/b1/e4/3P8DQNoW_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;">[-128]补=-128+2^8=-128+256=128(补码的十进制形式)=10000000</p> 
<p style="margin-left:0;text-align:justify;">这个数值是八位原码的最小值,只能这样转化</p> 
<p style="margin-left:0;text-align:justify;">01111111(补)-&gt;01111111(原)</p> 
<p style="margin-left:0;text-align:justify;">这个数值是八位原码的最大值</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">原码和补码都是除符号位以外取反+1进行转化</p> 
<p style="margin-left:0;text-align:justify;">十进制:71     真值:1000111     补码:01000111-&gt;原码:01000111</p> 
<p style="margin-left:0;text-align:justify;">十进制:-71   真值:-1000111    补码:10111001-&gt;原码:11000111</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">十进制:71     真值:1000111     原码:01000111-&gt;补码:01000111</p> 
<p style="margin-left:0;text-align:justify;">十进制:-71   真值:-1000111    原码:11000111-&gt;补码:10111001</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>3.IEEE</strong><strong>浮点数的定义格式 P38 图2-10及其解释，公式（2-10），</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>注意数符、阶码与尾数的意义。</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>注意<a name="_Hlk126159499">二进制小数转为浮点数的方法</a>（例2-20），进而衍生至<a name="_Hlk126159550">普通实数转换为浮点数的方法</a>（信息表示与计算方法作业第3题）</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>IEEE</strong><strong>浮点数定义格式</strong>:数符+阶码+尾数</p> 
<p style="margin-left:0;text-align:justify;"><strong>意义</strong></p> 
<p style="margin-left:0;text-align:justify;">短浮点数:32=1+8+23</p> 
<p style="margin-left:0;text-align:justify;">数符:表示正(0)负(1)</p> 
<p style="margin-left:0;text-align:justify;">阶码:阶码真值+127 表示二进制下科学计数法尾数应该平移位数</p> 
<p style="margin-left:0;text-align:justify;">尾数:尾数真值-1 表示二进制下科学计数法小数点后的值</p> 
<p style="margin-left:0;text-align:justify;"><strong>二进制小数转为浮点数的方法</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>普通实数转换为浮点数的方法</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>见题目</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>4.</strong><strong>现有字符编码方案，了解已有方案即可，包括字符与汉字 P39-41</strong></p> 
<p style="margin-left:0;text-align:justify;">ASCII码 美国常用字符</p> 
<p style="margin-left:0;text-align:justify;">Unicode码 世界常用字符</p> 
<p style="margin-left:0;text-align:justify;">汉字编码:汉字输入码 汉字交换码 汉字内部码</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>5.</strong><strong>基本寻址方式 P47-50, 8种方式的具体含义都要理解，结合汇编语言。</strong></p> 
<p style="margin-left:0;text-align:justify;">1.立即寻址</p> 
<p style="margin-left:0;text-align:justify;">指令中包含操作数,取指令就取出操作数</p> 
<p style="margin-left:0;text-align:justify;">MOV AX,1234H</p> 
<p style="margin-left:0;text-align:justify;">2.直接寻址</p> 
<p style="margin-left:0;text-align:justify;">指令直接给出操作数地址,根据地址在主存中取出操作数</p> 
<p style="margin-left:0;text-align:justify;">MOV AX,[DS:0x00000001H]</p> 
<p style="margin-left:0;text-align:justify;">3.寄存器寻址</p> 
<p style="margin-left:0;text-align:justify;">指令给出寄存器地址,从寄存器读取操作数</p> 
<p style="margin-left:0;text-align:justify;">MOV AX,BX</p> 
<p style="margin-left:0;text-align:justify;">4.间接寻址</p> 
<p style="margin-left:0;text-align:justify;">指令给出间址单元地址A1,在主存中访问A1读取操作数地址A2,然后在主存中访问A2所指向的存储单元,读取操作数</p> 
<p style="margin-left:0;text-align:justify;">5.寄存器间址及其变型</p> 
<p style="margin-left:0;text-align:justify;">指令给出寄存器地址(寄存器号R0),根据R0读取寄存器中的地址A,再根据A访问主存单元读取操作数</p> 
<p style="margin-left:0;text-align:justify;">mov AX,[BX] (BX中存的是操作数的地址)</p> 
<p style="margin-left:0;text-align:justify;">6.变址寻址</p> 
<p style="margin-left:0;text-align:justify;">指令分别给出寄存器地址R0和一个形式地址(位移量)D,,根据R0读取变址量N, 将N和D送入加法器得到A=N+D,根据A访问相应主存单元读取操作数</p> 
<p style="margin-left:0;text-align:justify;">7.相对寻址</p> 
<p style="margin-left:0;text-align:justify;">指令中给出位移量d,将PC中存放的当前指令地址A和d送入加法器,得到A+d,根据A+d访问主存读取操作数</p> 
<p style="margin-left:0;text-align:justify;">8.堆栈寻址</p> 
<p style="margin-left:0;text-align:justify;">指令隐含堆栈指针SP寄存器提供地址,根据SP提供的堆栈栈顶地址,在主存堆栈区栈顶存取操作数</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>第三章</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>1. CPU</strong><strong>各功能组件及其作用 P61-62，其中要特别注意PC与PSW。</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>(</strong><strong>在实际汇编语言面向的CPU中，以寄存器CS和IP代替PC的作用，以FLAG代替PSW的作用，具体第四章要注意联系)</strong></p> 
<p style="margin-left:0;text-align:justify;">CPU通常由以下几部分构成；</p> 
<p style="margin-left:0;text-align:justify;">①控制器              产生一系列控制信号，以控制计算机中各部件完成取指令、分析指令、执行指令的操作。</p> 
<p style="margin-left:0;text-align:justify;">②算术逻辑部件   ALU实现指令所指定的各种算术和逻辑运算</p> 
<p style="margin-left:0;text-align:justify;">③各种寄存器      存放指令、指令地址、操作数及运算结果。</p> 
<p style="margin-left:0;text-align:justify;">④CPU内部总线  连接CPU内部各部件，为信息传送提供通路。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">PC程序计数器(指令指针IP) 存放当前或下一条指令在主存中的地址</p> 
<p style="margin-left:0;text-align:justify;">PSW程序状态字,存放当前程序的运行状态和工作方式,参与控制程序执行的重要依据</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>2. </strong><strong>指令分段执行过程P64，</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>注意和第一章的联系，这部分详细说明之前第一章概念性的东西在具体CPU上如何工作，关联哪些部件，要有概念。</strong></p> 
<p style="margin-left:0;text-align:justify;">指令执行过程如下：(具体内容会用自己语言表述就行,到时候根据分值决定写多少)</p> 
<ol><li style="text-align:justify;">取指令</li><li style="text-align:justify;">分析指令</li><li style="text-align:justify;">执行指令</li></ol> 
<p style="margin-left:0;text-align:justify;">①取操作数</p> 
<p style="margin-left:0;text-align:justify;">②执行操作</p> 
<p style="margin-left:0;text-align:justify;">③形成下一条指令地址</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>3. </strong><strong>指令流水线，P69图3-8以及对应说明。</strong></p> 
<p style="margin-left:0;text-align:justify;">指令的执行过程可分为以下阶段：</p> 
<ul><li style="text-align:justify;">取指令（FD）读下一个预期的指令到缓冲器。</li></ul> 
<p style="margin-left:0;text-align:justify;">②译码指令（DI）分析操作码和操作数寻址方式。</p> 
<p style="margin-left:0;text-align:justify;">③计算操作数地址（CO）计算每个源操作数的有效地址，这可能涉及到位移量、寄存器间址、间址或其他形式的地址计算。</p> 
<p style="margin-left:0;text-align:justify;">④取操作数（FO）根据操作数地址从存储器取操作数。寄存器中的操作数不需要取。</p> 
<p style="margin-left:0;text-align:justify;">⑤执行指令（EI）完成操作码指定的操作。若有指定的目标操作数位置，则将结果写入此位置。</p> 
<p style="margin-left:0;text-align:justify;">⑥写操作数（WO）将结果存入存储器。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/1b/2b/IKQHKYML_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>4. </strong><strong>补码加减法运算和溢出判别P75-77</strong></p> 
<ol><li style="text-align:justify;">补码加减运算</li></ol> 
<ol><li style="text-align:justify;">参加运算操作数用补码表示</li><li style="text-align:justify;">符号位参加运算</li><li style="text-align:justify;">若指令操作数为加,则两数直接相加</li></ol> 
<p style="margin-left:0;text-align:justify;">若操作码为减,则将 减数连同符号位取反加一 后与 被减数相加</p> 
<ol><li style="text-align:justify;">运算结果用补码表示</li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>自行完成例3-3</strong></p> 
<ol><li style="text-align:justify;">溢出判别</li></ol> 
<ol><li style="text-align:justify;">采用一个符号位判断</li></ol> 
<p style="margin-left:0;text-align:justify;">当两个同号数相加,所得结果符号与两数符号不同时, 表明发生溢出</p> 
<ol><li style="text-align:justify;">采用最高有效位的进位判断</li></ol> 
<p style="margin-left:0;text-align:justify;">两正数相加，最高有效位有进位，符号位无进位，表明发生溢出</p> 
<p style="margin-left:0;text-align:justify;">两负数相加，最高有效位无进位，符号位有进位，表明发生溢出</p> 
<ol><li style="text-align:justify;">采用变形补码判断</li></ol> 
<p style="margin-left:0;text-align:justify;">将符号位扩充为两位,双符号位含义:</p> 
<p style="margin-left:0;text-align:justify;">00 结果为正,无溢出    </p> 
<p style="margin-left:0;text-align:justify;">01 结果正溢出</p> 
<p style="margin-left:0;text-align:justify;">10 结果负溢出</p> 
<p style="margin-left:0;text-align:justify;">11 结果为负,无溢出</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>5. </strong><strong>四种情况下数据在内存与CPU内部的数据传送路径P88-89</strong></p> 
<p style="margin-left:0;text-align:justify;">1.寄存器之间的数据传送</p> 
<p style="margin-left:0;text-align:justify;">模型机中,寄存器之间可直接通过ALU总线传送数据</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">2.主存数据传送到CPU</p> 
<p style="margin-left:0;text-align:justify;">CPU首先把所取数据地址送入MAR,然后将MAR中的地址输出到地址总线上,同时发读命令到主存;主存完成读操作后将读出的16位数据送到数据总线上,再将数据总线上的信息放入MDR</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">3.CPU数据传送到主存</p> 
<p style="margin-left:0;text-align:justify;">首先将寄存器中的数据装入MDR,然后将写入主存单元的地址送入MAR,然后发写命令. 主存按MAR中的地址把MDR的内容写入对应单元中.</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">4.执行算数或逻辑操作</p> 
<p style="margin-left:0;text-align:justify;">先将一个操作数经ALU总线送入暂存器D保存起来,D的内容在ALU的输入端A始终有效,再将另一个操作数经总线直接送到ALU的输出端B,这样两个操作数都送入了ALU,结果存储在暂存器Z中</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>第四章</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>1. 80X86 CPU</strong><strong>寄存器分类 通用寄存器，4个16位寄存器用途P126</strong></p> 
<p style="margin-left:0;text-align:justify;">(1)80x86CPU的内部寄存器可分为以下三大类：</p> 
<p style="margin-left:0;text-align:justify;">①基本结构寄存器组  </p> 
<p style="margin-left:0;text-align:justify;">②系统级寄存器组     </p> 
<p style="margin-left:0;text-align:justify;">③浮点寄存器组         </p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">(2)通用寄存器</p> 
<p style="margin-left:0;text-align:justify;">4个16位的寄存器AX、BX、CX、DX可称为数据寄存器</p> 
<p style="margin-left:0;text-align:justify;"><strong>AX</strong>作为累加器用，所以它是算术运算的主要寄存器。在乘除等指令中指定用来存放操作数。另外，所有的IO指令都使用这一寄存器与外部设备传送信息。</p> 
<p style="margin-left:0;text-align:justify;"><strong>BX</strong>可以作为通用寄存器使用。此外，在计算存储器地址时，它经常用作基址寄存器。</p> 
<p style="margin-left:0;text-align:justify;"><strong>CX</strong>可以作为通用寄存器使用。此外，它还常用来保存计数值，如在移位指令、循环（LOOP）和串处理指令中用作隐含的计数器。</p> 
<p style="margin-left:0;text-align:justify;"><strong>DX</strong>可以作为通用寄存器使用。一般在做双字长运算时把DX和AX组合在一起存放一个双字长数，DX用来存放高位字。此外，对某些IO操作，DX可用来存放IO的端口地址。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>2. </strong><strong>四个段寄存器CS,DS,ES与SS的意义 P127 P132</strong></p> 
<p style="margin-left:0;text-align:justify;">每个段寄存器可以确定一个段的起始地址，而这些段则各有各的用途。</p> 
<p style="margin-left:0;text-align:justify;"><strong>代码段(CS)</strong>存放当前正在运行的程序。</p> 
<p style="margin-left:0;text-align:justify;"><strong>数据段(DS)</strong>存放当前运行程序所用的数据，如果程序中使用了串处理指令，则其源操作数也存放在数据段中。</p> 
<p style="margin-left:0;text-align:justify;"><strong>堆栈段(SS)</strong>定义了堆栈的所在区域。</p> 
<p style="margin-left:0;text-align:justify;"><strong>附加段(ES)</strong>是附加的数据段，它是一个辅助的数据区，也是串处理指令的目的操作数存放区。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>3. IP</strong><strong>寄存器的意义，IP寄存器如何使指令连续执行 ( 注意与第三章PC联系，CS:IP为PC的实际实现 ) P128</strong></p> 
<p style="margin-left:0;text-align:justify;">IP为指令指针寄存器，用来存放代码段中的偏移地址。其作用类似于其他计算机中的程序计数器PC，当现行指令执行完毕时，由IP提供下一条指令地址。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">在指令按顺序执行时，每当CPU按CS、IP内容合成的指令地址从主存读取一条指令后，就自动修改IP中的值，使IP内容为下一条指令所在主存单元的偏移地址。</p> 
<p style="margin-left:0;text-align:justify;">当遇转移、转子指令时，就需要改变程序的执行顺序。CPU执行这类指令时，若需转移，则将指令提供的转移地址的偏移地址送入IP，作为下一条指令地址的偏移地址。可见，IP寄存器就是用来控制指令序列的执行流程的。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>4. FLAGS</strong><strong>寄存器的意义，为第三章PSW的实际实现，注意几个核心标志位的意义OF,SF,ZF,CF P128-129</strong></p> 
<p style="margin-left:0;text-align:justify;">FLAGS为标志寄存器，这是一个存放条件码标志、控制标志和系统标志的寄存器。</p> 
<p style="margin-left:0;text-align:justify;"><strong>OF</strong>溢出标志，将参加算术运算的数看作带符号数，运算结果溢出时, OF置1:否则OF置0</p> 
<p style="margin-left:0;text-align:justify;"><strong>SF</strong>符号标志，把指令执行结果看作带符号数, 如结果为负, 则SF置1; 结果为正, 则SF置0</p> 
<p style="margin-left:0;text-align:justify;"><strong>ZF</strong>零标志，如指令执行结果各位全为0时，则ZF置1：否则ZF置0</p> 
<p style="margin-left:0;text-align:justify;"><strong>CF</strong>进位标志，在进行算术运算时，如最高位产生进位或借位时，则CF置1；否则置0。在移位类指令中，CF用来存放移出的代码（0或1）</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>5. </strong><strong>存储单元的地址和内容的关系，P131</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>(</strong><strong>存储单元字节与物理地址的表示（第一段），<a name="_Hlk126329978">地址范围与总线宽度关系</a>（第二段），结合图4-11，同样的地址0004H在以字节（DB,8位）和字（DW,16位）下读取结果的不同，说明数据高位放高地址，低位放低地址（345段）</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>存储单元的地址和内容的关系:</strong></p> 
<p style="margin-left:0;text-align:justify;">在存储器里以字节为单位存储信息。为了正确地存放或取得信息，每一字节单元给予一个唯一的编号即存储器地址，称为物理地址。每一字节单元有一个二进制数表示地址, 一个存储单元中存放的信息称为该存储单元的内容。</p> 
<p style="margin-left:0;text-align:justify;"><strong>地址范围与总线宽度关系: 看书理解如何根据宽度计算范围</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>6. </strong><strong>存储器物理地址如何与段基址+偏移地址进行转换 P132，图4-12与对应解说。</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>看不懂请看书</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/3b/94/5X3Qrsjc_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;">段内地址即偏移地址，可以定义为一个主存单元与所在段的段基址之间的字节距离，通常由CPU按指令的寻址方式计算得到或由指令指针IP提供。当CPU访问某个主存单元时，必须指明由哪个段寄存器提供段基值，同时给出偏移地址。然后将16位段基值左移4位后与16位偏移地址相加，形成20位主存单元的物理地址，这一过程如图4-12所示。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>7. </strong><strong>段寄存器与偏移地址组合关系，以及该组合指向的段内容。P133</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/e8/0f/fxG4kKtD_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>8. </strong><strong>各种寻址方式的范例P141-147,与第二章寻址方式部分结合看</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>看书看书</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong><em>所有指令能够描述其对应功能应该就可以</em></strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>9. MOV</strong><strong>传送指令，注意后面所有指令要点均为格式、功能、受影响的标志位（即是否改变FLAGS寄存器中对应的位），以及注意事项P149</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/9d/e4/jhO99tQA_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/23/de/vJVJYzJM_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>10. PUSH,POP</strong><strong>指令 P149</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>提示: </strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>数字5678H中 56H是高位 78H是低位</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>地址0001H 0002H中 0002H是高地址 0001H是低地址</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/90/1f/TROCKBsF_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/82/da/efCPRvyo_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>11. ADD</strong><strong>指令，ADC指令 P157-158，注意例4-30如何使用两个16位寄存器实现32位加法。</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/5d/0e/Q5EXA5U1_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/45/d0/3HN6uJ52_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/72/ef/tFbKkeHV_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>12. SUB</strong><strong>指令，SBB指令，NEG指令，CMP指令 P160</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/ac/af/9CDhzTyP_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/ca/c1/Lmv2Yibp_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/ef/c1/TSuRNQew_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/c1/2d/iRsL9AfW_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>13. MUL</strong><strong>指令，DIV指令，要特别注意乘数/除数为8位和16位时被乘数、被除数的情况，注意积、商、余数存放的位置。P161-162</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/6f/90/23JGTiA3_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/83/03/wxCVyNGG_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/45/5b/9EP46CAp_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>14. </strong><strong>逻辑移位指令和算术移位指令，特别是算术右移指令P168-169</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/3d/27/xovLHEFv_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/1b/94/EvPqIkUO_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>15. </strong><strong>串操作指令：MOVS,CMPS,STOS,LODS的实现细节、关联寄存器，以及其与REP,REPE和REPNE的组合关系</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/8e/a2/hjbxWdup_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/f4/53/kXokQQgE_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/6b/27/i49xgr83_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/8c/39/ahGG0mN0_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/9e/73/8hUeWaOv_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/e5/75/d6X33S6O_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>与REP,REPE和REPNE的组合关系在P174-P175页,自行查看</strong></p> 
<p style="margin-left:0;text-align:justify;">REP CX为计数器 CX=0停止</p> 
<p style="margin-left:0;text-align:justify;">REPE CX为计数器 CX=0停止 相等继续</p> 
<p style="margin-left:0;text-align:justify;">REPNE CX为计数器 CX=0停止 不相等继续</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>第五章</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>1. </strong><strong>汇编语言的基本结构定义（数据段，代码段）P181-182</strong></p> 
<p style="margin-left:0;text-align:justify;">1.变量定义</p> 
<p style="margin-left:0;text-align:justify;">2.符号定义</p> 
<p style="margin-left:0;text-align:justify;">3.段定义</p> 
<p style="margin-left:0;text-align:justify;">4.定位类型</p> 
<p style="margin-left:0;text-align:justify;">5.组合类型</p> 
<p style="margin-left:0;text-align:justify;">6.伪指令</p> 
<p style="margin-left:0;text-align:justify;">参考链接: https://blog.csdn.net/qq_41115702/article/details/104295498</p> 
<p style="margin-left:0;text-align:justify;">S= (A+B)(C-D)运算的汇编语言程序如下:</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/b9/2e/pEfMjqhl_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/a8/c9/vHjCfpyT_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>2. </strong><strong>变量的定义与变量的三个属性P185-186</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>(1)</strong><strong>变量的定义</strong></p> 
<p style="margin-left:0;text-align:justify;">定义变量就是分配存储单元，这些存储单元可以预置数据初值或仅保留若干存储单元。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/82/88/JzcqQT0s_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>(2)</strong><strong>变量的三个属性</strong></p> 
<p style="margin-left:0;text-align:justify;">①段属性（SEG）段属性表示变量存放在哪一个逻辑段中，用变量所在段的段基值来表示</p> 
<ul><li style="text-align:justify;">偏移地址属性（OFFSET）偏移地址属性表示变量在逻辑段中离段起始单元的距离(字节数)</li><li style="text-align:justify;">类型属性（TYPE）类型属性表示一个变量的数据大小</li></ul> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>3. </strong><strong>变量定义后在内存中的存储方式 P186 </strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>（数值表达式与字符串定义部分，注意要懂得画出变量在内存中的存储图，结合汇编语言作业第2题）</strong></p> 
<p style="margin-left:0;text-align:justify;">数据定义伪指令(DB、DW等)在为数据分配存储单元的同时，还可以给这些存储单元预置初值，每个初值由相应的表达式确定。</p> 
<p style="margin-left:0;text-align:justify;">DB—字节 / DW—字 / DD—双字 / DF—6字节 / DQ—8字节 / DT—10字节</p> 
<p style="margin-left:0;text-align:justify;">①数值表达式      伪指令可以在单一存储单元或连续若干存储单元中设置数据</p> 
<p style="margin-left:0;text-align:justify;">②字符串表达式   字符串表达式中的字符串必须用引号括起来，字符串中各字符均以ASCII码形式存放在相应的存储单元中</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>4. </strong><strong>变量的使用方式P188</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>①组成地址表达式</strong> 在指令语句的操作数字段中，引用的变量名作为地址表达式的组成部分之一。</p> 
<p style="margin-left:0;text-align:justify;"><strong>②作为被引用变量地址</strong>      在DW或DD数据定义语句的操作数字段上引用了变量名，那么在为DW或DD伪指令分配的存储单元中，将预置被引用变量名的地址部分（段基值和偏移地址)</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>5. </strong><strong>标号的概念与三个属性P188-189</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>1</strong><strong>概念：</strong></p> 
<p style="margin-left:0;text-align:justify;">标号是一条指令的符号地址。在无条件转移指令、条件转移指令和循环指令的操作数位置上，通常用标号作为程序转移指令的目标地址。</p> 
<p style="margin-left:0;text-align:justify;"><strong>2</strong><strong>三个属性：</strong></p> 
<p style="margin-left:0;text-align:justify;">(1）段属性（SEG）表示指令在哪个逻辑段中。</p> 
<p style="margin-left:0;text-align:justify;">(2）偏移地址属性（OFFSET）表示这条指令离段起始单元之间的字节数</p> 
<p style="margin-left:0;text-align:justify;">(3）类型属性（TYPE）表示它的转移特性，即该标号是作为段内转移指令还是段间转移指令的目标地址。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>6. </strong><strong>段寄存器的装载 P197-199</strong></p> 
<p style="margin-left:0;text-align:justify;">（1）DS和 ES的装载</p> 
<p style="margin-left:0;text-align:justify;">如在指令的操作数字段上引用段名，就是将该段的段基值以立即数形式出现在操作数字段中。MOV传送指令不能把立即数直接传送给段寄存器，只能把段基值先送给一个通用寄存器，然后再转送给段寄存器DS或ES</p> 
<p style="margin-left:0;text-align:justify;">（2）SS的装载</p> 
<p style="margin-left:0;text-align:justify;">SS是堆栈段寄存器，它的装载就是对堆栈的设置。</p> 
<p style="margin-left:0;text-align:justify;">对SS的装载有如下两种办法:</p> 
<p style="margin-left:0;text-align:justify;">①自动装载。</p> 
<p style="margin-left:0;text-align:justify;">在段定义伪指令（SEGMENT）的组合类型中选择“STACK”参数，指示这个段是堆栈段</p> 
<p style="margin-left:0;text-align:justify;">②用执行指令的方法装载</p> 
<p style="margin-left:0;text-align:justify;">在程序执行过程中，要调换另一个堆栈段，可用类似于DS、ES的装载方法，对SS和 SP进行修改、设置</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">（3）CS的装载</p> 
<p style="margin-left:0;text-align:justify;">①使用结束伪指令。任何一个源程序都必须用结束伪指令 END作为源程序的最后一个语句。</p> 
<p style="margin-left:0;text-align:justify;">结束伪指令语句格式如下:</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/3a/7b/fVIOFrBK_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消 地址表达式的值是这个程序要执行的第1条指令语句的地址</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">②执行段间程序转移指令时，CPU将自动修改CS 和IP的内容。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>7. </strong><strong>顺序程序 P212-213两个程序</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>自行看书，理解就好</strong></p> 
<p style="margin-left:0;text-align:justify;">【例5-1】</p> 
<p style="margin-left:0;text-align:justify;">【例5-2】</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>8. </strong><strong>分支程序转移条件P216,记住JE,JNE,JA,JAE,JB,JBE,JG,JGE,JL,JLE即可</strong></p> 
<p style="margin-left:0;text-align:justify;">条件转移指令都是以标志寄存器中某一个或几个标志位(除AF外)的状态作为判断条件。表5-3给出了条件转移指令及其判断条件，按其判断功能划分，可分为三种:①简单条件转移指令;②无符号数条件转移指令;③带符号数条件转移指令。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/5b/5b/XIX4905v_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"><strong>9. P217-219</strong><strong>，分支程序例题               </strong></p> 
<p style="margin-left:0;text-align:justify;">【例5-4】自行查看</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>10. LOOP,LOOPE,LOOPNE</strong><strong>指令用法与课本例题P222</strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/d3/07/dFQTdG9P_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;">【例5-7】</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/29/cb/G9RG2VNo_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;">【例5-8】</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/65/45/HABv8ezG_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;">【例5-9】</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>11. </strong><strong>用条件控制循环例题 P228 </strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>( </strong><strong>注意例题是如何使用JMP实现满足特定条件时终止循环的 ) </strong></p> 
<p style="margin-left:0;text-align:justify;">(2）用条件控制循环</p> 
<p style="margin-left:0;text-align:justify;">在问题的求解过程中，找出一个终止循环的条件。每循环一次，便对条件进行一次检测，如满足终止循环的条件，便退出循环，否则继续循环。在这种情况下编制的循环程序，通常是选用条件转移指令来判断、控制循环的结束。</p> 
<p style="margin-left:0;text-align:justify;">【例5-11】P228</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>12. </strong><strong>子程序的具体定义方法 P233， CALL与RET的实际工作（段内调用）P230</strong></p> 
<p style="margin-left:0;text-align:justify;">自己看书理解即可</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>第六章</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>1. </strong><strong>多级存储架构不同层次存储器的特点P253</strong></p> 
<p style="margin-left:0;text-align:justify;">在一个计算机系统中，常采用几种不同的存储器，构成多级存储体系，以适应不同层次的需要。通常，对CPU直接访问的一级，其速度尽可能快些，而容量相对有限；作为后援的一级其容量尽可能大些，而速度可以相对慢些。经过合理的搭配和组织，对用户来说，整个存储系统能够提供足够大的存储容量和较快的存取速度。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>2. </strong><strong>存储器的位扩展与字数扩展P264</strong></p> 
<p style="margin-left:0;text-align:justify;">（1）位扩展       </p> 
<p style="margin-left:0;text-align:justify;">位扩展是指用多个存储芯片对字长进行扩展。</p> 
<p style="margin-left:0;text-align:justify;">（2）字数（编址空间）扩展   </p> 
<p style="margin-left:0;text-align:justify;">如果每片的字数不够，需用若干芯片组成总容量更大的存储器，称为字数扩展。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>3. Cache</strong><strong>的工作原理（局部性）P276-277</strong></p> 
<p style="margin-left:0;text-align:justify;">Cache的工作原理基于程序和数据访问的局部性。在一个较短的时间间隔内，地址往往集中在存储器逻辑地址空间的很小范围里。程序地址的分布本来就是连续的，再加上循环程序段和子程序段要重复执行多次，因此对程序地址的访问就自然地具有相对集中的倾向。数据分布的这种集中倾向不如指令明显，但对数组的存储和访问及对工作单元的选择都可以使存储器地址相对集中。这种对局部范围的存储器地址频繁访问，而对此范围以外的地址访问很少的现象称为程序访问的局部性。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>4. Cache</strong><strong>三种映像方式 P277-279</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>具体看书</strong></p> 
<p style="margin-left:0;text-align:justify;">(1) 直接映射</p> 
<p style="margin-left:0;text-align:justify;">(2) 全相联映射</p> 
<p style="margin-left:0;text-align:justify;">(3) 组相联映射</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>5. </strong><strong>替换算法 P280</strong></p> 
<p style="margin-left:0;text-align:justify;">（1）先进先出算法（FIFO）</p> 
<p style="margin-left:0;text-align:justify;">这种替换算法的思想是：按块调入Cache的先后次序决定淘汰的顺序，即在需要更新时，将最先调入Cache的块内容予以淘汰。这种方法简单，容易实现，不需要随时记录各个块的使用情况，系统开销少。但这种方法不一定合理，因为有些内容虽然调入较早，但可能仍需使用。</p> 
<p style="margin-left:0;text-align:justify;">（2）近期最少使用算法（LRU）</p> 
<p style="margin-left:0;text-align:justify;">为Cache的各个块建立一个调用情况记录表，称为LRU目录。当需要替换时，将在最近一段时间内使用最少的块内容予以淘汰。它按调用频繁程度决定淘汰算法，访问命中率较高相对合理，因而使用较多。但它较前一种算法复杂，系统开销较大，通常是为每个块设置计数器，以记录该块的使用情况。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>6. Cache</strong><strong>读写过程，写回与写直达P280</strong></p> 
<p style="margin-left:0;text-align:justify;">①写回法（标志交换方式）。</p> 
<p style="margin-left:0;text-align:justify;">当需将信息写入主存时，暂时先只写入Cache的有关单元，并用标志注明，直到该块内容需从Cache中替换出来时，再一次性地写入主存。这种方式的写操作速度快，使得Cache真正在读/写两方面都在CPU和主存之间起到了高速缓存的作用。</p> 
<p style="margin-left:0;text-align:justify;">如果CPU写Cache未命中，则为欲写的主存块在Cache中分配一行，将此块整个复制到Cache后再对其进行修改。主存的写操作统一地留到换出时再进行。显然这种写Cache方式可以显著地减少写主存的次数，但因在写回主存之前，主存中的块未经随时修改而可能失效。</p> 
<ul><li style="text-align:justify;">写直达法（通过式写入）。</li></ul> 
<p style="margin-left:0;text-align:justify;">每次写入Cache时，也同时写入主存，使主存与Cache相关块内容始终保持一致。这种方式比较简单，能保持主存与Cache的一致性，并且无需为Cache中的每一行设置标志位；但插入慢速的访主存操作，影响工作速度，并且有可能增加多次不必要的向主存的写  操作，降低了Cache的功效。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/b5/3c/FCudmEfs_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>7. </strong><strong>虚拟存储器的工作原理P299</strong></p> 
<p style="margin-left:0;text-align:justify;">从用户界面看，用户可使用位数较长的编程地址进行编程，这种地址面向程序的需要，不必考虑程序将来在主存储器中的实际位置，因而称为逻辑地址。它是面向虚拟存储器的，所以又称为虚地址。在用户看来，CPU可按虚地址访问一个很大的存储器，其容量甚至可达整个辅存容量，显然这是一种虚拟层次。</p> 
<p style="margin-left:0;text-align:justify;">在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前急需运行的部分调入主存，供CPU操作，其余暂不运行部分留在磁盘中，随程序执行的需要，操作系统自动地按一定替换算法进行调度，将当前暂不运行部分调回磁盘，将新的模块由磁盘调入主存。这一层次上的工作，对用户是透明的。</p> 
<p style="margin-left:0;text-align:justify;">CPU执行程序时，需将程序提供的虚地址变换为主存的实地址, 一般是先由存储管理部件判断该地址的内容是否在主存中，若已调入主存，则通过地址变换机制将虚地址转换为实地址，然后访问主存单元；若尚未调入主存，则通过缺页中断程序，以页为单位调入后实现主存内容调换。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>8. </strong><strong>三种虚拟存储器的特点P299-301</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>需要看书理解</strong></p> 
<ol><li style="text-align:justify;"> 页式虚拟存储器</li></ol> 
<p style="margin-left:0;text-align:justify;">采取面向存储器本身物理结构分页的策略，有利于存储空间的利用与调度，存储空间的零头小于一个页面。但是页的大小固定，这种划分不能反映程序的逻辑结构，这给程序的执行、保护与共享带来不便。</p> 
<ol><li style="text-align:justify;"> 段式虚拟存储器</li></ol> 
<p style="margin-left:0;text-align:justify;">是面向用户程序逻辑结构，以段为单位进行调度、传送、定位，这有利于对程序的编译处理、执行、共享与保护。但段的大小可变，不利于存储空间的管理与调度，它比页式虚拟存储器复杂；存储空间的零头可能较大，存储空间利用率低。</p> 
<ol><li style="text-align:justify;"> 段页式虚拟存储器</li></ol> 
<p style="margin-left:0;text-align:justify;">将程序按其逻辑结构分段，每段再分为若干大小相同的页；主存空间也划分为若干同样大小的页。相应地，建立段表与页表，分两级查表实现虚实地址转换。以页为单位调进或调出主存，按段共享与保护程序和数据。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>第七章</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>1. I/O</strong><strong>接口的部分功能P308-309</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>具体内容理解看书</strong></p> 
<p style="margin-left:0;text-align:justify;">①寻址功能</p> 
<p style="margin-left:0;text-align:justify;">②输入/输出功能</p> 
<p style="margin-left:0;text-align:justify;">③支持主机采取程序查询、中断、DMA等访问方式</p> 
<p style="margin-left:0;text-align:justify;">④提供主机和IO设备所需的缓冲、暂存和驱动能力，满足一定的负载要求和时序要求</p> 
<p style="margin-left:0;text-align:justify;">⑤进行数据类型、格式等方面的转换</p> 
<p style="margin-left:0;text-align:justify;">⑥联络功能</p> 
<p style="margin-left:0;text-align:justify;">⑦复位功能</p> 
<p style="margin-left:0;text-align:justify;">⑧可编程功能</p> 
<p style="margin-left:0;text-align:justify;">⑨错误检测功能</p> 
<p style="margin-left:0;text-align:justify;"><strong>2. </strong><strong>程序查询方式工作原理P314 缺陷P316</strong></p> 
<p style="margin-left:0;text-align:justify;">工作原理:</p> 
<p style="margin-left:0;text-align:justify;">首先，在I/O接口中要设置状态位以表示外设的工作状态。</p> 
<p style="margin-left:0;text-align:justify;">在相应的IO程序中必须进行下列3步操作：</p> 
<p style="margin-left:0;text-align:justify;">①读取外设状态信息。</p> 
<p style="margin-left:0;text-align:justify;">②判断是否可进行新的操作。如果设备尚未准备好，则返回第①步：若已准备好，就进行下一步。</p> 
<p style="margin-left:0;text-align:justify;">③执行所需的IO操作</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">缺陷:</p> 
<p style="margin-left:0;text-align:justify;">在程序查询方式中，CPU的利用率不高，这是因为CPU会对外设执行大量无效的查询。如果CPU采取不断查询的方法，则长期处于等待状态，不能做别的处理，也不能对其他事件及时做出响应。</p> 
<p style="margin-left:0;text-align:justify;">即使采取定时查询的方法，也不能完全克服上述缺点，因为它仍然存在大量的无效查询。如果查询的时间间隔选取得较长，也不能对外部状态的改变及时做出响应；若两次查询之间出现多次事件，就会丢失信息。如果查询的时间间隔选取得较短，则无效查询急剧增加，CPU效率下降。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>3.</strong><strong>向量中断法，中断入口地址生成 P320-321</strong></p> 
<ol><li style="text-align:justify;">向量中断法</li></ol> 
<p style="margin-left:0;text-align:justify;">中断源通过有关控制逻辑给出一个相应的向量码，CPU据此通过一系列变换得到中断处理程序的入口地址，无需软件查询。</p> 
<ol><li style="text-align:justify;">中断入口地址生成(具体理解看书)</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="uploading.4e448015.gif" class="img-loading" height="3" src="https://images2.imgbox.com/da/08/rdPOUPF1_o.gif" width="306"></p> 
<p style="margin-left:0;text-align:justify;">正在上传…重新上传取消</p> 
<p style="margin-left:0;text-align:justify;">按8086CPU的地址形成方法产生20位入口地址码，从而可以据此转入中断处理程序。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>4. </strong><strong>中断的过程 P322-323，重点是中断响应与中断返回的具体工作</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>看书看书</strong></p> 
<p style="margin-left:0;text-align:justify;">1.中断请求 2.中断排优 3.中断响应4.中断处理和中断返回</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>5.DMA</strong><strong>方式 P335</strong></p> 
<p style="margin-left:0;text-align:justify;">DMA方式是为在主存储器与IO设备间进行高速批量数据交换而设置的，它的基本思想是：通过硬件控制实现主存与IO设备间的直接数据传送，在传送过程中无需CPU程序干预。</p> 
<p style="margin-left:0;text-align:justify;">由于每次DMA传送的工作很简单，所以一次DMA传送过程是很快的，一般只占一个存储器读写周期。因此DMA方式适合于高速数据传送。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>6. </strong><strong>通道与IOP的概念P347-348</strong></p> 
<p style="margin-left:0;text-align:justify;">通道是一种专用控制器，它通过执行通道程序进行I/O操作的管理，为主机与IO设备提供一种数据传输通道，故称为“通道”。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">IOP的指令系统更丰富、更通用、功能更强：IOP的结构更接近于常规CPU，更具独立性，可有独立的局部存储器；除了能够完成传统通道的数据输入/输出功能外，还能进行一些较复杂的预处理。</p> 
<p style="margin-left:0;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/427b651726233ede7f4aa0a934e6f042/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Qt 路径处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ccec99ff9a3aacb84f993f52ecbd7b0f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cocos tilemap的setTileGIDAt方法不实时更新</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>