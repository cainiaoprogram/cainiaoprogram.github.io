<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>原来count(*)是接口性能差的真凶 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="原来count(*)是接口性能差的真凶" />
<meta property="og:description" content="前言 最近我在公司优化过几个慢查询接口的性能，总结了一些心得体会拿出来跟大家一起分享一下，希望对你会有所帮助。
我们使用的数据库是Mysql8，使用的存储引擎是Innodb。这次优化除了优化索引之外，更多的是在优化count(*)。
通常情况下，分页接口一般会查询两次数据库，第一次是获取具体数据，第二次是获取总的记录行数，然后把结果整合之后，再返回。
查询具体数据的sql，比如是这样的：`
select id,name from user limit 1,20; 它没有性能问题。
但另外一条使用count(*)查询总记录行数的sql，例如：
select count(*) from user; 却存在性能差的问题。
为什么会出现这种情况呢？
1 count(*)为什么性能差？ 在Mysql中，count(*)的作用是统计表中记录的总行数。
而count(*)的性能跟存储引擎有直接关系，并非所有的存储引擎，count(*)的性能都很差。
在Mysql中使用最多的存储引擎是：innodb和myisam。
在myisam中会把总行数保存到磁盘上，使用count(*)时，只需要返回那个数据即可，无需额外的计算，所以执行效率很高。
而innodb则不同，由于它支持事务，有MVCC（即多版本并发控制）的存在，在同一个时间点的不同事务中，同一条查询sql，返回的记录行数可能是不确定的。
在innodb使用count(*)时，需要从存储引擎中一行行的读出数据，然后累加起来，所以执行效率很低。
如果表中数据量小还好，一旦表中数据量很大，innodb存储引擎使用count(*)统计数据时，性能就会很差。
2 如何优化count(*)性能？ 从上面得知，既然count(*)存在性能问题，那么我们该如何优化呢？
我们可以从以下几个方面着手。
2.1 增加redis缓存 对于简单的count(*)，比如：统计浏览总次数或者浏览总人数，我们可以直接将接口使用redis缓存起来，没必要实时统计。
当用户打开指定页面时，在缓存中每次都设置成count = count&#43;1即可。
用户第一次访问页面时，redis中的count值设置成1。用户以后每访问一次页面，都让count加1，最后重新设置到redis中。
这样在需要展示数量的地方，从redis中查出count值返回即可。
该场景无需从数据埋点表中使用count(*)实时统计数据，性能将会得到极大的提升。
不过在高并发的情况下，可能会存在缓存和数据库的数据不一致的问题。
但对于统计浏览总次数或者浏览总人数这种业务场景，对数据的准确性要求并不高，容忍数据不一致的情况存在。
2.2 加二级缓存 对于有些业务场景，新增数据很少，大部分是统计数量操作，而且查询条件很多。这时候使用传统的count(*)实时统计数据，性能肯定不会好。
假如在页面中可以通过id、name、状态、时间、来源等，一个或多个条件，统计品牌数量。
这种情况下用户的组合条件比较多，增加联合索引也没用，用户可以选择其中一个或者多个查询条件，有时候联合索引也会失效，只能尽量满足用户使用频率最高的条件增加索引。
也就是有些组合条件可以走索引，有些组合条件没法走索引，这些没法走索引的场景，该如何优化呢？
答：使用二级缓存。
二级缓存其实就是内存缓存。
我们可以使用caffine或者guava实现二级缓存的功能。
目前SpringBoot已经集成了caffine，使用起来非常方便。
只需在需要增加二级缓存的查询方法中，使用@Cacheable注解即可。
@Cacheable(value = &#34;brand&#34;, , keyGenerator = &#34;cacheKeyGenerator&#34;) public BrandModel getBrand(Condition condition) { return getBrandByCondition(condition); } 然后自定义cacheKeyGenerator，用于指定缓存的key。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e95155bcba026038b0dae35062b0899b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-26T14:12:37+08:00" />
<meta property="article:modified_time" content="2023-12-26T14:12:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">原来count(*)是接口性能差的真凶</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>最近我在公司优化过几个慢查询接口的性能，总结了一些心得体会拿出来跟大家一起分享一下，希望对你会有所帮助。</p> 
<p>我们使用的数据库是<code>Mysql8</code>，使用的存储引擎是<code>Innodb</code>。这次优化除了<code>优化索引</code>之外，更多的是在优化<code>count(*)</code>。</p> 
<p>通常情况下，分页接口一般会查询两次数据库，第一次是获取具体数据，第二次是获取总的记录行数，然后把结果整合之后，再返回。</p> 
<p>查询具体数据的sql，比如是这样的：`</p> 
<pre><code>select id,name from user limit 1,20;
</code></pre> 
<p>它没有性能问题。</p> 
<p>但另外一条使用count(*)查询总记录行数的sql，例如：</p> 
<pre><code>select count(*) from user;
</code></pre> 
<p>却存在性能差的问题。</p> 
<p>为什么会出现这种情况呢？</p> 
<h3>1 count(*)为什么性能差？</h3> 
<p>在Mysql中，<code>count(*)</code>的作用是统计表中记录的总行数。</p> 
<p>而<code>count(*)</code>的性能跟存储引擎有直接关系，并非所有的存储引擎，<code>count(*)</code>的性能都很差。</p> 
<p>在Mysql中使用最多的存储引擎是：<code>innodb</code>和<code>myisam</code>。</p> 
<p>在myisam中会把总行数保存到磁盘上，使用count(*)时，只需要返回那个数据即可，无需额外的计算，所以执行效率很高。</p> 
<p>而innodb则不同，由于它支持事务，有<code>MVCC</code>（即多版本并发控制）的存在，在同一个时间点的不同事务中，同一条查询sql，返回的记录行数可能是不确定的。</p> 
<p>在innodb使用count(*)时，需要从存储引擎中一行行的读出数据，然后累加起来，所以执行效率很低。</p> 
<p>如果表中数据量小还好，一旦表中数据量很大，innodb存储引擎使用count(*)统计数据时，性能就会很差。</p> 
<h3>2 如何优化count(*)性能？</h3> 
<p>从上面得知，既然<code>count(*)</code>存在性能问题，那么我们该如何优化呢？</p> 
<p>我们可以从以下几个方面着手。</p> 
<h4>2.1 增加redis缓存</h4> 
<p>对于简单的count(*)，比如：统计浏览总次数或者浏览总人数，我们可以直接将接口使用redis缓存起来，没必要实时统计。</p> 
<p>当用户打开指定页面时，在缓存中每次都设置成count = count+1即可。</p> 
<p>用户第一次访问页面时，redis中的count值设置成1。用户以后每访问一次页面，都让count加1，最后重新设置到redis中。</p> 
<p class="img-center"><img alt="图片" height="572" src="https://images2.imgbox.com/75/e7/0sP6vEZq_o.png" width="626"></p> 
<p>这样在需要展示数量的地方，从redis中查出count值返回即可。</p> 
<p>该场景无需从数据埋点表中使用count(*)实时统计数据，性能将会得到极大的提升。</p> 
<p>不过在高并发的情况下，可能会存在缓存和数据库的数据不一致的问题。</p> 
<p>但对于统计浏览总次数或者浏览总人数这种业务场景，对数据的准确性要求并不高，容忍数据不一致的情况存在。</p> 
<h4>2.2 加二级缓存</h4> 
<p>对于有些业务场景，新增数据很少，大部分是统计数量操作，而且查询条件很多。这时候使用传统的count(*)实时统计数据，性能肯定不会好。</p> 
<p>假如在页面中可以通过id、name、状态、时间、来源等，一个或多个条件，统计品牌数量。</p> 
<p>这种情况下用户的组合条件比较多，增加联合索引也没用，用户可以选择其中一个或者多个查询条件，有时候联合索引也会失效，只能尽量满足用户使用频率最高的条件增加索引。</p> 
<p>也就是有些组合条件可以走索引，有些组合条件没法走索引，这些没法走索引的场景，该如何优化呢？</p> 
<p>答：使用<code>二级缓存</code>。</p> 
<p>二级缓存其实就是内存缓存。</p> 
<p>我们可以使用<code>caffine</code>或者<code>guava</code>实现二级缓存的功能。</p> 
<p>目前<code>SpringBoot</code>已经集成了caffine，使用起来非常方便。</p> 
<p>只需在需要增加二级缓存的查询方法中，使用<code>@Cacheable</code>注解即可。</p> 
<pre><code> @Cacheable(value = "brand", , keyGenerator = "cacheKeyGenerator")
   public BrandModel getBrand(Condition condition) {
       return getBrandByCondition(condition);
   }
</code></pre> 
<p>然后自定义cacheKeyGenerator，用于指定缓存的key。</p> 
<pre><code>public class CacheKeyGenerator implements KeyGenerator {
    @Override
    public Object generate(Object target, Method method, Object... params) {
        return target.getClass().getSimpleName() + UNDERLINE
                + method.getName() + ","
                + StringUtils.arrayToDelimitedString(params, ",");
    }
}
</code></pre> 
<p>这个key是由各个条件组合而成。</p> 
<p>这样通过某个条件组合查询出品牌的数据之后，会把结果缓存到内存中，设置过期时间为5分钟。</p> 
<p>后面用户在5分钟内，使用相同的条件，重新查询数据时，可以直接从二级缓存中查出数据，直接返回了。</p> 
<p>这样能够极大的提示count(*)的查询效率。</p> 
<p>但是如果使用二级缓存，可能存在不同的服务器上，数据不一样的情况。我们需要根据实际业务场景来选择，没法适用于所有业务场景。</p> 
<h4>2.3 多线程执行</h4> 
<p>不知道你有没有做过这样的需求：统计有效订单有多少，无效订单有多少。</p> 
<p>这种情况一般需要写两条sql，统计有效订单的sql如下：</p> 
<pre><code>select count(*) from order where status=1;
</code></pre> 
<p>统计无效订单的sql如下：</p> 
<pre><code>select count(*) from order where status=0;
</code></pre> 
<p>但如果在一个接口中，同步执行这两条sql效率会非常低。</p> 
<p>这时候，可以改成成一条sql：</p> 
<pre><code>select count(*),status from order
group by status;
</code></pre> 
<p>使用<code>group by</code>关键字分组统计相同status的数量，只会产生两条记录，一条记录是有效订单数量，另外一条记录是无效订单数量。</p> 
<p>但有个问题：status字段只有1和0两个值，重复度很高，区分度非常低，不能走索引，会全表扫描，效率也不高。</p> 
<p>还有其他的解决方案不？</p> 
<p>答：使用多线程处理。</p> 
<p>我们可以使用<code>CompleteFuture</code>使用两个<code>线程</code>异步调用统计有效订单的sql和统计无效订单的sql，最后汇总数据，这样能够提升查询接口的性能。</p> 
<p>最近我建了新的技术交流群，打算将它打造成高质量的活跃群，欢迎小伙伴们加入。</p> 
<p><strong>我以往的技术群里技术氛围非常不错，大佬很多。</strong></p> 
<p></p> 
<p class="img-center"><img alt="image.png" height="1200" src="https://images2.imgbox.com/14/0c/x4AloWkJ_o.png" width="828"></p> 
<p>加微信：su_san_java，备注：加群，即可加入该群。</p> 
<h4>2.4 减少join的表</h4> 
<p>大部分的情况下，使用count(*)是为了实时统计总数量的。</p> 
<p>但如果表本身的数据量不多，但join的表太多，也可能会影响count(*)的效率。</p> 
<p>比如在查询商品信息时，需要根据商品名称、单位、品牌、分类等信息查询数据。</p> 
<p>这时候写一条sql可以查出想要的数据，比如下面这样的：</p> 
<pre><code>select count(*)
from product p
inner join unit u on p.unit_id = u.id
inner join brand b on p.brand_id = b.id
inner join category c on p.category_id = c.id
where p.name='测试商品' and u.id=123 and b.id=124 and c.id=125;
</code></pre> 
<p>使用product表去<code>join</code>了unit、brand和category这三张表。</p> 
<p>其实这些查询条件，在product表中都能查询出数据，没必要join额外的表。</p> 
<p>我们可以把sql改成这样：</p> 
<pre><code>select count(*)
from product
where name='测试商品' and unit_id=123 and brand_id=124 and category_id=125;
</code></pre> 
<p>在count(*)时只查product单表即可，去掉多余的表join，让查询效率可以提升不少。</p> 
<h4>2.5 改成ClickHouse</h4> 
<p>有些时候，join的表实在太多，没法去掉多余的join，该怎么办呢？</p> 
<p>比如上面的例子中，查询商品信息时，需要根据商品名称、单位名称、品牌名称、分类名称等信息查询数据。</p> 
<p>这时候根据product单表是没法查询出数据的，必须要去<code>join</code>：unit、brand和category这三张表，这时候该如何优化呢？</p> 
<p>答：可以将数据保存到<code>ClickHouse</code>。</p> 
<p>ClickHouse是基于<code>列存储</code>的数据库，不支持事务，查询性能非常高，号称查询十几亿的数据，能够秒级返回。</p> 
<p>为了避免对业务代码的嵌入性，可以使用<code>Canal</code>监听<code>Mysql</code>的<code>binlog</code>日志。当product表有数据新增时，需要同时查询出单位、品牌和分类的数据，生成一个新的结果集，保存到ClickHouse当中。</p> 
<p>查询数据时，从ClickHouse当中查询，这样使用count(*)的查询效率能够提升N倍。</p> 
<blockquote> 
 <p>需要特别提醒一下：使用ClickHouse时，新增数据不要太频繁，尽量批量插入数据。</p> 
</blockquote> 
<p>其实如果查询条件非常多，使用ClickHouse也不是特别合适，这时候可以改成<code>ElasticSearch</code>，不过它跟Mysql一样，存在<code>深分页</code>问题。</p> 
<h3>3 count的各种用法性能对比</h3> 
<p>既然说到count(*)，就不能不说一下count家族的其他成员，比如：count(1)、count(id)、count(普通索引列)、count(未加索引列)。</p> 
<p>那么它们有什么区别呢？</p> 
<ul><li> <p>count(*) ：它会获取所有行的数据，不做任何处理，行数加1。</p> </li><li> <p>count(1)：它会获取所有行的数据，每行固定值1，也是行数加1。</p> </li><li> <p>count(id)：id代表主键，它需要从所有行的数据中解析出id字段，其中id肯定都不为NULL，行数加1。</p> </li><li> <p>count(普通索引列)：它需要从所有行的数据中解析出普通索引列，然后判断是否为NULL，如果不是NULL，则行数+1。</p> </li><li> <p>count(未加索引列)：它会全表扫描获取所有数据，解析中未加索引列，然后判断是否为NULL，如果不是NULL，则行数+1。</p> </li></ul> 
<p>由此，最后count的性能从高到低是：</p> 
<blockquote> 
 <p>count(*) ≈ count(1) &gt; count(id) &gt; count(普通索引列) &gt; count(未加索引列)</p> 
</blockquote> 
<p>所以，其实<code>count(*)</code>是最快的。</p> 
<p>意不意外，惊不惊喜？</p> 
<p>千万别跟<code>select *</code> 搞混了。</p> 
<p></p> 
<h4>最后说一句(求关注，别白嫖我)</h4> 
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。</p> 
<p>求一键三连：点赞、转发、在看。</p> 
<p>关注公众号：【苏三说技术】，在公众号中回复：面试、代码神器、开发手册、时间管理有超赞的粉丝福利，另外回复：加群，可以跟很多BAT大厂的前辈交流和学习。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/12972e3c3071430de8d83b134a083790/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">03.生成Kubernetes集群证书文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5507f3d79743bd88e0e2122061f09668/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">qt中子窗口最小化后再恢复显示，子窗口显示为大白框，看不到任何子控件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>