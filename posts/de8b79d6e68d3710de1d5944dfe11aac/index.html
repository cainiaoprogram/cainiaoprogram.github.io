<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库系统概论----第六章：关系数据理论（依赖、候选码、第几范式、最小依赖集、模式的分解） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库系统概论----第六章：关系数据理论（依赖、候选码、第几范式、最小依赖集、模式的分解）" />
<meta property="og:description" content="文章目录 1.非平凡依赖&#43;平凡依赖2.完全函数依赖&#43;部分函数依赖3.求关系模式候选码的方法3.0 补充：求闭包3.1 具体解题步骤（看这个，绝对有用 ）3.2 例: R(U)=(ABCDEG),F={AB-&gt;C,CD-&gt;E,E-&gt;A,A-&gt;G},求候选码。(根据3.1）3.x 补充：超码、候选码、主码、主属性、非主属性、全码的区别 4.判断关系模式属于第几范式的方法4.0 求范式（看这个，绝对有用 ）4.1例题4.2 补充：1NF、2NF、3NF、BCNF4.2.1 第一范式：1NF4.2.2 第二范式：2NF4.2.3 第三范式：3NF4.2.4 BCNF范式 5.公理系统（就是里面的结论直接用）6.求最小函数的依赖集6.1 例题1 (就按这个来解题）6.2 例题2 7. 模式的分解7.1 白话理解7.2判断是否为 : 无损连接分解 / 保持函数依赖7.3 U=(A,B,C,D,E,G) F={BG-&gt;C，BD-&gt;E，DG-&gt;C，ADG-&gt;BC，AG-&gt;B，B-&gt;D} 若R不是3NF，将R分解为无损且保持函数依赖的3NF。7.4 U=(A,B,C,D,E) F={AB-&gt;C，C-&gt;B，D-&gt;E，D-&gt;C} 若R不是3NF，将R分解为无损且保持函数依赖的3NF。 为什么引⼊范式?
1数据冗余
2更新异常
3插⼊异常
4删除异常
范式分类
设计关系数据库时，遵从不同的规范要求，这些不同的规范要求被称为不同的范式， 各种范式呈递次规范，越⾼的范式数据库冗余越⼩。
⽬前关系数据库有六种范式：
第⼀范式（1NF）、第⼆范式（2NF）、第三范式（3NF）、 巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，⼜称完美范式）。
⼀般来说，数据库只需满⾜第三范式(3NF）就⾏了。
1.非平凡依赖&#43;平凡依赖 2.完全函数依赖&#43;部分函数依赖 3.求关系模式候选码的方法 3.0 补充：求闭包 参考博客：https://wonzwang.blog.csdn.net/article/details/80464466
候选码的概念: 可以推出所有属性
如何选出候选码?
只出现在左边的⼀定是候选码只出现在右边的⼀定不是候选码左右都出现的不⼀定左右都不出现的⼀定是候选码再求确定的候选码的闭包，如果可以推出全部，那么当前确定的就是候选码，否则就不是 3.1 具体解题步骤（看这个，绝对有用 ） 参考博客：求候选键/候选码
3.2 例: R(U)=(ABCDEG),F={AB-&gt;C,CD-&gt;E,E-&gt;A,A-&gt;G},求候选码。(根据3.1） 解答：
故候选码为ABD、BCD、BDE
3.x 补充：超码、候选码、主码、主属性、非主属性、全码的区别 以3.2的例题为例
超码: 能表示出所有属性的集合, ⽐如 (ABD),(BDC),(BDE) BDCA BDEA ABCDE" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/de8b79d6e68d3710de1d5944dfe11aac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-14T08:43:21+08:00" />
<meta property="article:modified_time" content="2021-10-14T08:43:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库系统概论----第六章：关系数据理论（依赖、候选码、第几范式、最小依赖集、模式的分解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1_19" rel="nofollow">1.非平凡依赖+平凡依赖</a></li><li><a href="#2_24" rel="nofollow">2.完全函数依赖+部分函数依赖</a></li><li><a href="#3_28" rel="nofollow">3.求关系模式候选码的方法</a></li><li><ul><li><a href="#30__34" rel="nofollow">3.0 补充：求闭包</a></li><li><a href="#31___50" rel="nofollow">3.1 具体解题步骤（看这个，绝对有用 ）</a></li><li><a href="#32__RUABCDEGFABCCDEEAAG31_55" rel="nofollow">3.2 例: R(U)=(ABCDEG),F={AB-&gt;C,CD-&gt;E,E-&gt;A,A-&gt;G},求候选码。(根据3.1）</a></li><li><a href="#3x__64" rel="nofollow">3.x 补充：超码、候选码、主码、主属性、非主属性、全码的区别</a></li></ul> 
   </li><li><a href="#4_76" rel="nofollow">4.判断关系模式属于第几范式的方法</a></li><li><ul><li><a href="#40___77" rel="nofollow">4.0 求范式（看这个，绝对有用 ）</a></li><li><a href="#41_79" rel="nofollow">4.1例题</a></li><li><a href="#42_1NF2NF3NFBCNF_93" rel="nofollow">4.2 补充：1NF、2NF、3NF、BCNF</a></li><li><ul><li><a href="#421_1NF_98" rel="nofollow">4.2.1 第一范式：1NF</a></li><li><a href="#422_2NF_106" rel="nofollow">4.2.2 第二范式：2NF</a></li><li><a href="#423_3NF_120" rel="nofollow">4.2.3 第三范式：3NF</a></li><li><a href="#424_BCNF_128" rel="nofollow">4.2.4 BCNF范式</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5_131" rel="nofollow">5.公理系统（就是里面的结论直接用）</a></li><li><a href="#6_139" rel="nofollow">6.求最小函数的依赖集</a></li><li><ul><li><a href="#61_1__148" rel="nofollow">6.1 例题1 (就按这个来解题）</a></li><li><a href="#62_2_158" rel="nofollow">6.2 例题2</a></li></ul> 
   </li><li><a href="#7__165" rel="nofollow">7. 模式的分解</a></li><li><ul><li><a href="#71__166" rel="nofollow">7.1 白话理解</a></li><li><a href="#72________169" rel="nofollow">7.2判断是否为 : 无损连接分解 / 保持函数依赖</a></li><li><a href="#73__UABCDEG___FBGCBDEDGCADGBCAGBBD___R3NFR3NF_180" rel="nofollow">7.3 U=(A,B,C,D,E,G) F={BG-&gt;C，BD-&gt;E，DG-&gt;C，ADG-&gt;BC，AG-&gt;B，B-&gt;D} 若R不是3NF，将R分解为无损且保持函数依赖的3NF。</a></li><li><a href="#74_UABCDE___FABCCBDEDC___R3NFR3NF_184" rel="nofollow">7.4 U=(A,B,C,D,E) F={AB-&gt;C，C-&gt;B，D-&gt;E，D-&gt;C} 若R不是3NF，将R分解为无损且保持函数依赖的3NF。</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>为什么引⼊范式?</p> 
<blockquote> 
 <p>1数据冗余<br> 2更新异常<br> 3插⼊异常<br> 4删除异常</p> 
</blockquote> 
<p>范式分类</p> 
<blockquote> 
 <p>设计关系数据库时，遵从不同的规范要求，这些不同的规范要求被称为不同的范式， 各种范式呈递次规范，越⾼的范式数据库冗余越⼩。<br>  <br> ⽬前关系数据库有六种范式：<br> <code>第⼀范式（1NF）、第⼆范式（2NF）、第三范式（3NF）、 巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，⼜称完美范式）</code>。<br>  <br> ⼀般来说，数据库只需满⾜第三范式(3NF）就⾏了。</p> 
</blockquote> 
<h3><a id="1_19"></a>1.非平凡依赖+平凡依赖</h3> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/76/43/fzXJlG2p_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/56/73/kjac3ElD_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="2_24"></a>2.完全函数依赖+部分函数依赖</h3> 
<p><img src="https://images2.imgbox.com/5f/e3/1zjLb8om_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_28"></a>3.求关系模式候选码的方法</h3> 
<h4><a id="30__34"></a>3.0 补充：求闭包</h4> 
<blockquote> 
 <p>参考博客：<a href="https://wonzwang.blog.csdn.net/article/details/80464466" rel="nofollow">https://wonzwang.blog.csdn.net/article/details/80464466</a></p> 
</blockquote> 
<br> 
<p><mark>候选码的概念: 可以推出所有属性</mark></p> 
<blockquote> 
 <p><strong>如何选出候选码?</strong></p> 
 <ol><li><strong>只出现在左边的⼀定是候选码</strong></li><li><strong>只出现在右边的⼀定不是候选码</strong></li><li><strong>左右都出现的不⼀定</strong></li><li><strong><code>左右都不出现的⼀定是候选码</code></strong></li><li><strong>再求确定的候选码的闭包，如果可以推出全部，那么当前确定的就是候选码，否则就不是</strong></li></ol> 
</blockquote> 
<br> 
<h4><a id="31___50"></a>3.1 具体解题步骤（看这个，绝对有用 ）</h4> 
<blockquote> 
 <p>参考博客：<a href="https://wonzwang.blog.csdn.net/article/details/80464679" rel="nofollow">求候选键/候选码</a></p> 
</blockquote> 
<p><br><br></p> 
<h4><a id="32__RUABCDEGFABCCDEEAAG31_55"></a>3.2 例: R(U)=(ABCDEG),F={AB-&gt;C,CD-&gt;E,E-&gt;A,A-&gt;G},求候选码。(根据3.1）</h4> 
<p>解答：</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/bb/2b/pHKpxSGv_o.png" alt="在这里插入图片描述"><br> 故候选码为ABD、BCD、BDE</p> 
</blockquote> 
<h4><a id="3x__64"></a>3.x 补充：超码、候选码、主码、主属性、非主属性、全码的区别</h4> 
<p>以3.2的例题为例</p> 
<blockquote> 
 <p><code>超码</code>: 能表示出所有属性的集合, ⽐如 (ABD),(BDC),(BDE) BDCA BDEA ABCDE<br> <code>候选码</code>:是最⼩的超码<br> <code>主码</code>: 从候选码⾥⾯任意跳出⼀个 作为主码<br> <code>主属性</code>: 包含在所有候选码的属性 ⽐如ABCDE<br> <code>⾮主属性</code>: 不包含在候选码中的属性 ,上题为G<br> <code>全码</code>: 所有的属性都是主码</p> 
</blockquote> 
<br> 
<br> 
<br> 
<br> 
<br> 
<h3><a id="4_76"></a>4.判断关系模式属于第几范式的方法</h3> 
<h4><a id="40___77"></a>4.0 求范式（看这个，绝对有用 ）</h4> 
<blockquote> 
 <p>参考博客：<a href="https://wonzwang.blog.csdn.net/article/details/80464822" rel="nofollow">求范式</a></p> 
</blockquote> 
<h4><a id="41_79"></a>4.1例题</h4> 
<p><em>R(U)=(ABCDEG),F={AB-&gt;C,CD-&gt;E,E-&gt;A,A-&gt;G}</em>，判断关系模式R(U，F)属于第几范式？<br> 解答：</p> 
<ol><li>确定R(U,F)的候选码(3.2 例题已解决)。<br> 三个候选码：ABD、BDC、BDE。</li><li>属性集U分成两个集合：<br> 码属性集：ABCDE<br> 非码属性集：G</li><li>根据范式定义判断</li></ol> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/d4/22/8oR6kBMQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3e/a8/CiSEBdU4_o.png" alt="在这里插入图片描述"><br> 显然，只有一个非主属性G，A-&gt;G，G部分依赖于候选码，所以，R(U,F)属于1NF。</p> 
</blockquote> 
<h4><a id="42_1NF2NF3NFBCNF_93"></a>4.2 补充：1NF、2NF、3NF、BCNF</h4> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/bc/35/evDEzvBw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/02/1e/utdbE9tS_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="421_1NF_98"></a>4.2.1 第一范式：1NF</h5> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/0a/f5/NNQcJRWW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/19/98/4CY9jlRs_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="422_2NF_106"></a>4.2.2 第二范式：2NF</h5> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/5d/f6/T3OLdzGH_o.png" alt="在这里插入图片描述"><br> 将关系S-L-C规范化，使其满足2NF。<br> 解决方法：将S-L-C分解为两个关系模式，以消除这些部分函数依赖。<br> <img src="https://images2.imgbox.com/2d/c3/0tn4VvNF_o.png" alt="在这里插入图片描述"></p> 
 <hr> 
 <p>另一个例子：<img src="https://images2.imgbox.com/40/ae/iU4IRy86_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ad/eb/Vg5UJMB9_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="423_3NF_120"></a>4.2.3 第三范式：3NF</h5> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/b9/bc/K63sJeGa_o.png" alt="在这里插入图片描述"><br> 例子（消除传递函数依赖）：<br> <img src="https://images2.imgbox.com/79/0a/mEtg29re_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/48/30/R88Z6sUw_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="424_BCNF_128"></a>4.2.4 BCNF范式</h5> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/da/b0/O15fxU44_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="5_131"></a>5.公理系统（就是里面的结论直接用）</h3> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/f6/40/9VNOBGOc_o.png" alt="在这里插入图片描述"><br> 自反性：可根据<code>平凡函数依赖</code>来理解</p> 
</blockquote> 
<br> 
<br> 
<br> 
<br> 
<br> 
<h3><a id="6_139"></a>6.求最小函数的依赖集</h3> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/b8/fd/0GBT6P9W_o.png" alt="在这里插入图片描述"><br> 如何求最⼩依赖集?</p> 
 <ol><li><code>拆右边为多个元素的</code> ⽐如A-&gt;BC 拆为 A-&gt;B 和A-&gt;C</li><li><code>除去一个依赖 temp（从左往右）</code> <mark>【设：temp的左边取名为t1，右边为t2】</mark>，求 t1 的闭包，看“ (t1)+ ”能不能推出“t2”，<br> 若能，该依赖就去掉，否则保留。<code>循环执行</code>（即每一个依赖都要这样做）</li><li><code>左边最小化</code>，比如：<br> <img src="https://images2.imgbox.com/1b/2a/cvvs7Q7L_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h4><a id="61_1__148"></a>6.1 例题1 (就按这个来解题）</h4> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/c2/2e/KN0fuYzG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7b/8f/xhDTaKHL_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/16/c4/E29KhN3L_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/be/ea/ACU9UEfw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/68/2c/kQkiIx23_o.png" alt="在这里插入图片描述"><br> 最终的F即最小函数的依赖集</p> 
</blockquote> 
<h4><a id="62_2_158"></a>6.2 例题2</h4> 
<blockquote> 
 <p>参考博客：<a href="https://wonzwang.blog.csdn.net/article/details/80465245" rel="nofollow">求最小依赖集</a></p> 
</blockquote> 
<p><br><br><br><br><br><br><br></p> 
<h3><a id="7__165"></a>7. 模式的分解</h3> 
<h4><a id="71__166"></a>7.1 白话理解</h4> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/63/79/rMMc2gXR_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="72________169"></a>7.2判断是否为 : 无损连接分解 / 保持函数依赖</h4> 
<p>无损连接分解(方法一：判定表法）</p> 
<blockquote> 
 <p>参考博客：<a href="https://wonzwang.blog.csdn.net/article/details/80502746" rel="nofollow">判断是否为无损连接分解</a></p> 
</blockquote> 
<p>无损连接分解(方法二：无损连接定理）+ 保持函数依赖的证明</p> 
<blockquote> 
 <p>参考博客：<a href="https://blog.csdn.net/Stillboring/article/details/105360003">判断是否为无损连接，保持函数依赖</a><br> <img src="https://images2.imgbox.com/bf/8e/m9ybNYUN_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="73__UABCDEG___FBGCBDEDGCADGBCAGBBD___R3NFR3NF_180"></a>7.3 U=(A,B,C,D,E,G) F={BG-&gt;C，BD-&gt;E，DG-&gt;C，ADG-&gt;BC，AG-&gt;B，B-&gt;D} 若R不是3NF，将R分解为无损且保持函数依赖的3NF。</h4> 
<h4><a id="74_UABCDE___FABCCBDEDC___R3NFR3NF_184"></a>7.4 U=(A,B,C,D,E) F={AB-&gt;C，C-&gt;B，D-&gt;E，D-&gt;C} 若R不是3NF，将R分解为无损且保持函数依赖的3NF。</h4> 
<blockquote> 
 <p>7.3和7.4解答----参考博客：<a href="https://wonzwang.blog.csdn.net/article/details/80466282" rel="nofollow">求模式分解</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9d076901c5a9e55c7326537734d3b49/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">yolov4的全面详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1602dae8f9cad32133e5aeaa034b5982/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">golang 参数校验方法设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>