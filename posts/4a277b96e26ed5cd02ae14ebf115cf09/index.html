<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux 内核链表操作 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux 内核链表操作" />
<meta property="og:description" content="操作系统内核, 如同其他程序, 常常需要维护数据结构的列表. 有时, Linux 内核已经同
时有几个列表实现. 为减少复制代码的数量, 内核开发者已经创建了一个标准环形的, 双
链表; 鼓励需要操作列表的人使用这个设施.
当使用链表接口时, 你应当一直记住列表函数不做加锁. 如果你的驱动可能试图对同一个
列表并发操作, 你有责任实现一个加锁方案. 可选项( 破坏的列表结构, 数据丢失, 内核
崩溃) 肯定是难以诊断的.
为使用列表机制, 你的驱动必须包含文件 &lt;linux/list.h&gt;. 这个文件定义了一个简单的
类型 list_head 结构:
struct list_head { struct list_head *next, *prev; };
真实代码中使用的链表几乎是不变地由几个结构类型组成, 每一个描述一个链表中的入口
项. 为在你的代码中使用 Linux 列表, 你只需要嵌入一个 list_head 在构成这个链表的
结构里面. 假设, 如果你的驱动维护一个列表, 它的声明可能看起来象这样:
struct todo_struct
{
struct list_head list;
int priority; /* driver specific */
/* ... add other driver-specific fields */" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4a277b96e26ed5cd02ae14ebf115cf09/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T19:29:19+08:00" />
<meta property="article:modified_time" content="2024-01-03T19:29:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux 内核链表操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>操作系统内核, 如同其他程序, 常常需要维护数据结构的列表. 有时, Linux 内核已经同<br> 时有几个列表实现. 为减少复制代码的数量, 内核开发者已经创建了一个标准环形的, 双<br> 链表; 鼓励需要操作列表的人使用这个设施.<br> 当使用链表接口时, 你应当一直记住列表函数不做加锁. 如果你的驱动可能试图对同一个<br> 列表并发操作, 你有责任实现一个加锁方案. 可选项( 破坏的列表结构, 数据丢失, 内核<br> 崩溃) 肯定是难以诊断的.<br> 为使用列表机制, 你的驱动必须包含文件 &lt;linux/list.h&gt;. 这个文件定义了一个简单的<br> 类型 list_head 结构:<br> struct list_head { struct list_head *next, *prev; };<br> 真实代码中使用的链表几乎是不变地由几个结构类型组成, 每一个描述一个链表中的入口<br> 项. 为在你的代码中使用 Linux 列表, 你只需要嵌入一个 list_head 在构成这个链表的<br> 结构里面. 假设, 如果你的驱动维护一个列表, 它的声明可能看起来象这样:<br> struct todo_struct<br> {<!-- --><br> struct list_head list;<br> int priority; /* driver specific */<br> /* ... add other driver-specific fields */<br> };<br> 列表的头常常是一个独立的 list_head 结构. 图链表头数据结构显示了这个简单的<br> struct list_head 是如何用来维护一个数据结构的列表的.</p> 
<p><img alt="" height="348" src="https://images2.imgbox.com/a2/60/NU0cdL1X_o.png" width="586"></p> 
<p>                                                     <strong>     链表头数据结构</strong></p> 
<p>链表头必须在使用前用 INIT_LIST_HEAD 宏来初始化. 一个"要做的事情"的链表头可能声<br> 明并且初始化用:<br> struct list_head todo_list;<br> INIT_LIST_HEAD(&amp;todo_list);<br> &lt;para&gt;可选地, 链表可在编译时初始化:&lt;/para&gt;<br> LIST_HEAD(todo_list);<br> 几个使用链表的函数定义在 &lt;linux/list.h&gt;:<br> list_add(struct list_head *new, struct list_head *head);<br> 在紧接着链表 head 后面增加新入口项 -- 正常地在链表的开头. 因此, 它可用来<br> 构建堆栈. 但是, 注意, head 不需要是链表名义上的头; 如果你传递一个<br> list_head 结构, 它在链表某处的中间, 新的项紧靠在它后面. 因为 Linux 链表<br> 是环形的, 链表的头通常和任何其他的项没有区别.<br> list_add_tail(struct list_head *new, struct list_head *head);<br> 刚好在给定链表头前面增加一个新入口项 -- 在链表的尾部, 换句话说.<br> list_add_tail 能够, 因此, 用来构建先入先出队列.<br> list_del(struct list_head *entry);<br> list_del_init(struct list_head *entry);<br> 给定的项从队列中去除. 如果入口项可能注册在另外的链表中, 你应当使用<br> list_del_init, 它重新初始化这个链表指针.<br> list_move(struct list_head *entry, struct list_head *head);<br> list_move_tail(struct list_head *entry, struct list_head *head);</p> 
<p>给定的入口项从它当前的链表里去除并且增加到 head 的开始. 为安放入口项在新<br> 链表的末尾, 使用 list_move_tail 代替.<br> list_empty(struct list_head *head);<br> 如果给定链表是空, 返回一个非零值.<br> list_splice(struct list_head *list, struct list_head *head);<br> 将 list 紧接在 head 之后来连接 2 个链表.<br> list_head 结构对于实现一个相似结构的链表是好的, 但是调用程序常常感兴趣更大的结<br> 构, 它组成链表作为一个整体. 一个宏定义, list_entry, 映射一个 list_head 结构指<br> 针到一个指向包含它的结构的指针. 它如下被调用:<br> list_entry(struct list_head *ptr, type_of_struct, field_name);<br> 这里 ptr 是一个指向使用的 struct list_head 的指针, type_of_struct 是包含 ptr<br> 的结构的类型, field_name 是结构中列表成员的名子. 在我们之前的 todo_struct 结构<br> 中, 链表成员称为简单列表. 因此, 我们应当转变一个列表入口项为它的包含结构, 使用<br> 这样一行:<br> struct todo_struct *todo_ptr = list_entry(listptr, struct todo_struct, list);<br> list_entry 宏定义使用了一些习惯的东西但是不难用.<br> 链表的遍历是容易的: 只要跟随 prev 和 next 指针. 作为一个例子, 假设我们想保持<br> todo_struct 项的列表已降序的优先级顺序排列. 一个函数来添加新项应当看来如此:<br> void todo_add_entry(struct todo_struct *new)<br> {<!-- --><br> struct list_head *ptr;<br> struct todo_struct *entry;<br> for (ptr = todo_list.next; ptr != &amp;todo_list; ptr = ptr-&gt;next)<br> {<!-- --><br> entry = list_entry(ptr, struct todo_struct, list);<br> if (entry-&gt;priority &lt; new-&gt;priority) {<!-- --><br> list_add_tail(&amp;new-&gt;list, ptr);<br> return;<br> }<br> }<br> list_add_tail(&amp;new-&gt;list, &amp;todo_struct)<br> }</p> 
<p></p> 
<p>但是, 作为一个通用的规则, 最好使用一个预定义的宏来创建循环, 它遍历链表. 前一个<br> 循环, 例如, 可这样编码:<br> void todo_add_entry(struct todo_struct *new)<br> {<!-- --><br> struct list_head *ptr;<br> struct todo_struct *entry;<br> list_for_each(ptr, &amp;todo_list)<br> {<!-- --><br> entry = list_entry(ptr, struct todo_struct, list);<br> if (entry-&gt;priority &lt; new-&gt;priority) {<!-- --><br> list_add_tail(&amp;new-&gt;list, ptr);<br> return;<br> }<br> }<br> list_add_tail(&amp;new-&gt;list, &amp;todo_struct)<br> }<br> 使用提供的宏帮助避免简单的编程错误; 宏的开发者也已做了些努力来保证它们进行正常.<br> 存在几个变体:<br> list_for_each(struct list_head *cursor, struct list_head *list)<br> 这个宏创建一个 for 循环, 执行一次, cursor 指向链表中的每个连续的入口项.<br> 小心改变列表在遍历它时.<br> list_for_each_prev(struct list_head *cursor, struct list_head *list)<br> 这个版本后向遍历链表.<br> list_for_each_safe(struct list_head *cursor, struct list_head *next, struct<br> list_head *list)<br> 如果你的循环可能删除列表中的项, 使用这个版本. 它简单的存储列表 next 中下<br> 一个项, 在循环的开始, 因此如果 cursor 指向的入口项被删除, 它不会被搞乱.<br> list_for_each_entry(type *cursor, struct list_head *list, member)<br> list_for_each_entry_safe(type *cursor, type *next, struct list_head *list,<br> member)<br> 这些宏定义减轻了对一个包含给定结构类型的列表的处理. 这里, cursor 是一个<br> 指向包含数据类型的指针, member 是包含结构中 list_head 结构的名子. 有了这<br> 些宏, 没有必要安放 list_entry 调用在循环里了.</p> 
<p>如果你查看 &lt;linux/list.h&gt; 里面, 你看到有一些附加的声明. hlist 类型是一个有一个<br> 单独的, 单指针列表头类型的双向链表; 它常用作创建哈希表和类型结构. 还有宏用来遍<br> 历 2 种列表类型, 打算作使用 读取-拷贝-更新 机制(在第 5 章的"读取-拷贝-更新"一<br> 节中描述 ). 这些原语在设备驱动中不可能有用; 看头文件如果你愿意知道更多信息关于<br> 它们是如何工作的.</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/acbce9d26b6e0cf1f85f66ab68299d71/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu清理存储空间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58739963b18c63f5c0732cbe0755edc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【性能测试入门必看】性能测试流程简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>