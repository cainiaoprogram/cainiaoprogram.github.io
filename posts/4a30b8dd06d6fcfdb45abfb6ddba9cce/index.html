<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于MCAL中API的关键字总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于MCAL中API的关键字总结" />
<meta property="og:description" content="因为要做MCAL的测试方面的东西，所以要从Driver层下手，因此对自己将要用到的API做了一个总结，后续还会去更新一下工程方面的东西。主要做的事下面的这几个模块：
因为是测试，所以只是总结了set，get以及初始话方面的关键字。
DIO：Dio_GetVersionInfo：获取版本信息，指向存储此模块版本信息的位置。
void Dio_GetVersionInfo( Std_VersionInfoType* VersionInfo ) Dio_ReadChannel ：返回指定的DIO通道的值。
Dio_LevelType Dio_ReadChannel( Dio_ChannelType ChannelId ) Dio_WriteChannel：通过服务来设置一个通道的级别。 void Dio_WriteChannel( Dio_ChannelType ChannelId, Dio_LevelType Level )
Dio_ReadPort ：返回该端口的所有通道的级别。
Dio_PortLevelType Dio_ReadPort( Dio_PortType PortId ) Dio_WritePort ：使用服务来设置端口的值。
void Dio_WritePort( Dio_PortType PortId, Dio_PortLevelType Level ) Dio_ReadChannelGroup ：此服务读取一个端口的相邻位的一个子集。
Dio_PortLevelType Dio_ReadChannelGroup( const Dio_ChannelGroupType* ChannelGroupIdPtr ) Dio_WriteChannelGroup ：将端口的相邻位的子集设置为指定级别的服务。
void Dio_WriteChannelGroup( const Dio_ChannelGroupType* ChannelGroupIdPtr, Dio_PortLevelType Level )
ADC：Adc_Init ：初始化ADC硬件单元和驱动程序。
void Adc_Init( const Adc_ConfigType* ConfigPtr ) Adc_SetupResultBuffer：使用将存储转换结果的组特定结果缓冲区启动地址初始化ADC驱动程序。应用程序必须确保DataBufferPtr所指向的应用程序缓冲区能够保存指定组的所有转换结果。在重置后，需要使用Adc_SetupResultBuffer进行初始化，然后才能启动组转换。
Std_ReturnType Adc_SetupResultBuffer( Adc_GroupType Group, const Adc_ValueGroupType* DataBufferPtr ) Return value: E_OK：结果缓冲区指针初始化正确E_NOT_OK：操作失败或发生开发错误描述" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4a30b8dd06d6fcfdb45abfb6ddba9cce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-07T14:04:49+08:00" />
<meta property="article:modified_time" content="2022-06-07T14:04:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于MCAL中API的关键字总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;">   因为要做MCAL的测试方面的东西，所以要从Driver层下手，因此对自己将要用到的API做了一个总结，后续还会去更新一下工程方面的东西。主要做的事下面的这几个模块：<img alt="" src="https://images2.imgbox.com/b9/89/INRuGPWJ_o.png"></p> 
<p> 因为是测试，所以只是总结了set，get以及初始话方面的关键字。</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">DIO：</span><strong><span style="color:#000000;"><strong>Dio_GetVersionInfo</strong></span></strong><strong><span style="color:#000000;"><strong>：获取版本信息，指向存储此模块版本信息的位置。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Dio_GetVersionInfo( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_VersionInfoType* VersionInfo </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Dio_ReadChannel </strong></span></strong><strong><span style="color:#000000;"><strong>：返回指定的DIO通道的值</strong></span></strong><span style="color:#000000;">。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dio_LevelType Dio_ReadChannel( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dio_ChannelType ChannelId </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Dio_WriteChannel</strong></span></strong><strong><span style="color:#000000;"><strong>：通过服务来设置一个通道的级别。</strong></span></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Dio_WriteChannel( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dio_ChannelType ChannelId, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dio_LevelType Level </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Dio_ReadPort </strong></span></strong><strong><span style="color:#000000;"><strong>：返回该端口的所有通道的级别。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dio_PortLevelType Dio_ReadPort( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dio_PortType PortId </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Dio_WritePort</strong></span></strong><strong><span style="color:#000000;"><strong> ：使用服务来设置端口的值。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Dio_WritePort( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dio_PortType PortId, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dio_PortLevelType Level </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Dio_ReadChannelGroup</strong></span></strong><strong><span style="color:#000000;"><strong> ：此服务读取一个端口的相邻位的一个子集。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dio_PortLevelType Dio_ReadChannelGroup( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">const Dio_ChannelGroupType* ChannelGroupIdPtr </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Dio_WriteChannelGroup </strong></span></strong><strong><span style="color:#000000;"><strong>：将端口的相邻位的子集设置为指定级别的服务。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Dio_WriteChannelGroup( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">const Dio_ChannelGroupType* ChannelGroupIdPtr, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Dio_PortLevelType Level </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">ADC：</span><strong><span style="color:#000000;"><strong>Adc_Init </strong></span></strong><strong><span style="color:#000000;"><strong>：初始化ADC硬件单元和驱动程序。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Adc_Init( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">const Adc_ConfigType* ConfigPtr </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Adc_SetupResultBuffer</strong></span></strong><strong><span style="color:#000000;"><strong>：使用将存储转换结果的组特定结果缓冲区启动地址初始化ADC驱动程序。应用程序必须确保DataBufferPtr所指向的应用程序缓冲区能够保存指定组的所有转换结果。在重置后，需要使用Adc_SetupResultBuffer进行初始化，然后才能启动组转换。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_ReturnType Adc_SetupResultBuffer( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_GroupType Group, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">const Adc_ValueGroupType* DataBufferPtr </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Return value: </strong></span></strong><strong><span style="color:#000000;"><strong>E_OK：结果缓冲区指针初始化正确E_NOT_OK：操作失败或发生开发错误描述</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Adc_DeInit </strong></span></strong><strong><span style="color:#000000;"><strong>：将所有ADCHW单元返回到与其电源重置状态相当的状态。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Adc_ReadGroup </strong></span></strong><strong><span style="color:#000000;"><strong>：读取请求组最后完成的转换轮的组转换结果，并从数据bufferPtr地址开始存储通道值。组通道值按通道号递增的顺序存储（如果配置了流媒体访问，则与结果缓冲区的存储布局相反）。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_ReturnType Adc_ReadGroup( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_GroupType Group, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_ValueGroupType* DataBufferPtr </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Adc_GetGroupStatus </strong></span></strong><strong><span style="color:#000000;"><strong>：返回所请求的ADC通道组的转换状态。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_StatusType Adc_GetGroupStatus( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_GroupType Group </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Adc_GetStreamLastPointer</strong></span></strong><strong><span style="color:#000000;"><strong>：返回存储在结果缓冲区中的每个通道的有效样本数。读取一个指向组结果缓冲区中的一个位置的指针。使用指针位置，可以访问最后一次完成的转换轮的所有组通道的结果。使用指针和返回值，就可以访问所有有效的组转换结果（用户必须考虑结果缓冲区的布局）。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_StreamNumSampleType Adc_GetStreamLastPointer( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_GroupType Group, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_ValueGroupType** PtrToSamplePtr </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Adc_GetVersionInfo</strong></span></strong><strong><span style="color:#000000;"><strong>：返回此模块的版本信息。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Adc_GetVersionInfo( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_VersionInfoType* versioninfo </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Adc_SetPowerState </strong></span></strong><strong><span style="color:#000000;"><strong>：此API配置Adc模块，使其进入已经准备好的电源状态，在预定义配置的配置电源集之间进行选择。返回OK表示电源值已经被更改，返回NOT_OK表示请求被拒绝</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_ReturnType Adc_SetPowerState( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_PowerStateRequestResultType* Result </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Adc_GetCurrentPowerState </strong></span></strong><strong><span style="color:#000000;"><strong>：此API返回ADCHW单元的当前电源的功率状态。返回OK是可以读取，返回NOT OK是功能被拒绝。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_ReturnType Adc_GetCurrentPowerState( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_PowerStateType* CurrentPowerState, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_PowerStateRequestResultType* Result </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Adc_GetTargetPowerState</strong></span></strong><strong><span style="color:#000000;"><strong> ：此API返回ADCHW单元的目标电源功率状态。返回值同上。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_ReturnType Adc_GetTargetPowerState( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_PowerStateType* TargetPowerState, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_PowerStateRequestResultType* Result </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Adc_PreparePowerState </strong></span></strong><strong><span style="color:#000000;"><strong>：此API将启动所需的进程，以允许ADCHW模块进入所请求的电源状态。返回值同上。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_ReturnType Adc_PreparePowerState( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_PowerStateType PowerState, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Adc_PowerStateRequestResultType* Result </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">PWM：</span><strong><span style="color:#000000;"><strong>Pwm_Init </strong></span></strong><strong><span style="color:#000000;"><strong>：PWM初始化服务。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Pwm_Init( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">const Pwm_ConfigType* ConfigPtr </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Pwm_DeInit </strong></span></strong><strong><span style="color:#000000;"><strong>：用于PWM去初始化的服务。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Pwm_SetDutyCycle</strong></span></strong><strong><span style="color:#000000;"><strong>：服务设置PWM通道的占空比。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Pwm_SetDutyCycle( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_ChannelType ChannelNumber, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">uint16 DutyCycle </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Pwm_SetPeriodAndDuty </strong></span></strong><strong><span style="color:#000000;"><strong>：服务设置一个PWM通道标签</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Pwm_SetPeriodAndDuty( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_ChannelType ChannelNumber, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_PeriodType Period, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">uint16 DutyCycle </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Pwm_SetOutputToIdle </strong></span></strong><strong><span style="color:#000000;"><strong>：会将PWM输出设置为的空闲状态。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Pwm_SetOutputToIdle( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_ChannelType ChannelNumber </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Pwm_GetOutputState </strong></span></strong><strong><span style="color:#000000;"><strong>：使用服务来读取PWM输出信号的内部状态。PWM_HIGHPWM输出状态高PWM_LOWPWM输出状态低</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_OutputStateType Pwm_GetOutputState( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_ChannelType ChannelNumber </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Pwm_SetPowerState </strong></span></strong><strong><span style="color:#000000;"><strong>：此API配置Pwm模块，使其进入已经准备好的电源状态，在预定义的配置电源集之间进行选择。E_OK：电源模式改变，E_NOT_OK：请求被拒绝，如果API返回E_OK：PWM_SERVICE_ACCEPTED：Power状态更改。如果API返回E_NOT_OK：PWM_NOT_INIT：PWM模块未初始化。PWM_SEQUENCE_ERROR：错误的API调用序列。PWM_HW_FAILURE：硬件模块出现故障，无法进入所需的电源状态。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_ReturnType Pwm_SetPowerState( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_PowerStateRequestResultType* Result </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Pwm_GetCurrentPowerState </strong></span></strong><strong><span style="color:#000000;"><strong>：此API返回PWMHW单元的当前电源状态。返回值同上。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_ReturnType Pwm_GetCurrentPowerState( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_PowerStateType* CurrentPowerState, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_PowerStateRequestResultType* Result </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Pwm_GetTargetPowerState </strong></span></strong><strong><span style="color:#000000;"><strong>：此API返回PWMHW单元的目标功率状态。返回值同上</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_ReturnType Pwm_GetTargetPowerState( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_PowerStateType* TargetPowerState, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_PowerStateRequestResultType* Result </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Pwm_PreparePowerState</strong></span></strong><strong><span style="color:#000000;"><strong>：此API将启动所需的进程，以允许PWMHW模块进入所请求的电源状态。返回值同上。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_ReturnType Pwm_PreparePowerState( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_PowerStateType PowerState, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Pwm_PowerStateRequestResultType* Result </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Pwm_GetVersionInfo </strong></span></strong><strong><span style="color:#000000;"><strong>：服务部门将返回此模块的版本信息。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Pwm_GetVersionInfo( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_VersionInfoType* versioninfo </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Port_Init </strong></span></strong><strong><span style="color:#000000;"><strong>：初始化端口驱动程序模块。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Port_Init( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">const Port_ConfigType* ConfigPtr </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Port_SetPinDirection </strong></span></strong><strong><span style="color:#000000;"><strong>：设置引脚</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Port_SetPinDirection( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Port_PinType Pin, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Port_PinDirectionType Direction </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Port_RefreshPortDirection </strong></span></strong><strong><span style="color:#000000;"><strong>：刷新端口</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Port_RefreshPortDirection( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Port_GetVersionInfo </strong></span></strong><strong><span style="color:#000000;"><strong>：返回此模块的版本信息。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Port_GetVersionInfo( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Std_VersionInfoType* versioninfo </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>Port_SetPinMode</strong></span></strong><strong><span style="color:#000000;"><strong>：设置端口引脚模式。</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void Port_SetPinMode( </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Port_PinType Pin, </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">Port_PinModeType Mode </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/574d2c1514209825e3e546ec9e038b5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mybatis报错mapkey is required解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/760e3dbb1c2efa6ba6a84784e6c04f19/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网工必备命令：思科、华为、H3C交换机巡检命令全收录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>