<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MoveIt教程[10]：Motion Planning Pipeline - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MoveIt教程[10]：Motion Planning Pipeline" />
<meta property="og:description" content="在MoveIt中，motion planners被设置为规划路径。然而，在很多情况下，可能希望对运动规划请求进行预处理，或者对规划的路径进行后处理[例如，对时间参数化]。在这种情况下，使用规划管道，其中链的motion planner与预处理和后处理阶段。预处理和后处理阶段称为计划请求适配器，可以通过ROS参数服务器的名称进行配置。在本教程中，将运行C&#43;&#43;代码来实例化和调用这样的规划管道。
一.Running the Code
Roslaunch launch文件运行代码直接从moveit_tutorials：
roslaunch moveit_tutorials motion_planning_pipeline_tutorial.launch 注意：本教程使用RvizVisualToolsGui面板逐步演示。要将此面板添加到RViz，请遵循可视化教程中的说明。
过一会儿，RViz窗口应该会出现，并且看起来与页面顶部的窗口相似。要完成每个演示步骤，要么按下屏幕底部RvizVisualToolsGui面板中的Next按钮，要么在屏幕顶部的Tools面板中选择Key Tool，然后在RViz聚焦时按键盘上的N。
二.Expected Output
在RViz中，应该能够看到三种最终被重放的轨迹：
[1]robot将它的右臂移动到它前面的姿势目标
[2]robot将右臂移动到关节目标的一侧
[3]robot将它的右臂移动回它前面的初始姿势目标
三.The Entire Code
全部代码参考文献[2]。
1.Start
设置开始使用规划管道非常简单。在加载规划器之前，需要两个对象，一个RobotModel和一个PlanningScene。
将从实例化一个RobotModelLoader对象开始，该对象将在ROS参数服务器上查找robot描述并构造一个供使用的RobotModel。
robot_model_loader::RobotModelLoader robot_model_loader(&#34;robot_description&#34;); robot_model::RobotModelPtr robot_model = robot_model_loader.getModel(); 利用RobotModel，可以构建一个保持世界状态[包括机器人]的PlanningScene。
planning_scene::PlanningScenePtr planning_scene(new planning_scene::PlanningScene(robot_model)); 现在可以设置PlanningPipeline对象，它将使用ROS参数服务器来确定要使用的请求适配器集和planning插件。
planning_pipeline::PlanningPipelinePtr planning_pipeline( new planning_pipeline::PlanningPipeline(robot_model, node_handle, &#34;planning_plugin&#34;, &#34;request_adapters&#34;)); 2.Visualization
MoveItVisualTools包提供了许多在RViz中可视化对象、机器人和轨迹的功能，还提供了调试工具，比如脚本的分步内省。
namespace rvt = rviz_visual_tools; moveit_visual_tools::MoveItVisualTools visual_tools(&#34;panda_link0&#34;); visual_tools.deleteAllMarkers(); /* Remote control is an introspection tool that allows users to step through a high level script via buttons and keyboard shortcuts in RViz */ visual_tools." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d93ec9ff7b0a7d254388822dc90bd904/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-07T09:46:54+08:00" />
<meta property="article:modified_time" content="2020-01-07T09:46:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MoveIt教程[10]：Motion Planning Pipeline</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在MoveIt中，motion planners被设置为规划路径。然而，在很多情况下，可能希望对运动规划请求进行预处理，或者对规划的路径进行后处理[例如，对时间参数化]。在这种情况下，使用规划管道，其中链的motion planner与预处理和后处理阶段。预处理和后处理阶段称为计划请求适配器，可以通过ROS参数服务器的名称进行配置。在本教程中，将运行C++代码来实例化和调用这样的规划管道。<br> <strong>一.Running the Code</strong><br> Roslaunch launch文件运行代码直接从moveit_tutorials：</p> 
<pre><code>roslaunch moveit_tutorials motion_planning_pipeline_tutorial.launch
</code></pre> 
<p>注意：本教程使用RvizVisualToolsGui面板逐步演示。要将此面板添加到RViz，请遵循<a href="http://docs.ros.org/kinetic/api/moveit_tutorials/html/doc/quickstart_in_rviz/quickstart_in_rviz_tutorial.html#rviz-visual-tools" rel="nofollow">可视化教程</a>中的说明。<br> 过一会儿，RViz窗口应该会出现，并且看起来与页面顶部的窗口相似。要完成每个演示步骤，要么按下屏幕底部RvizVisualToolsGui面板中的Next按钮，要么在屏幕顶部的Tools面板中选择Key Tool，然后在RViz聚焦时按键盘上的N。</p> 
<p><strong>二.Expected Output</strong><br> 在RViz中，应该能够看到三种最终被重放的轨迹：<br> [1]robot将它的右臂移动到它前面的姿势目标<br> [2]robot将右臂移动到关节目标的一侧<br> [3]robot将它的右臂移动回它前面的初始姿势目标</p> 
<p><strong>三.The Entire Code</strong><br> 全部代码参考文献[2]。<br> 1.Start<br> 设置开始使用规划管道非常简单。在加载规划器之前，需要两个对象，一个RobotModel和一个PlanningScene。<br> 将从实例化一个RobotModelLoader对象开始，该对象将在ROS参数服务器上查找robot描述并构造一个供使用的RobotModel。</p> 
<pre><code>robot_model_loader::RobotModelLoader robot_model_loader("robot_description");
robot_model::RobotModelPtr robot_model = robot_model_loader.getModel();
</code></pre> 
<p>利用RobotModel，可以构建一个保持世界状态[包括机器人]的PlanningScene。</p> 
<pre><code>planning_scene::PlanningScenePtr planning_scene(new planning_scene::PlanningScene(robot_model));
</code></pre> 
<p>现在可以设置PlanningPipeline对象，它将使用ROS参数服务器来确定要使用的请求适配器集和planning插件。</p> 
<pre><code>planning_pipeline::PlanningPipelinePtr planning_pipeline(
    new planning_pipeline::PlanningPipeline(robot_model, node_handle, "planning_plugin", "request_adapters"));
</code></pre> 
<p>2.Visualization<br> MoveItVisualTools包提供了许多在RViz中可视化对象、机器人和轨迹的功能，还提供了调试工具，比如脚本的分步内省。</p> 
<pre><code>namespace rvt = rviz_visual_tools;
moveit_visual_tools::MoveItVisualTools visual_tools("panda_link0");
visual_tools.deleteAllMarkers();

/* Remote control is an introspection tool that allows users to step through a high level script
   via buttons and keyboard shortcuts in RViz */
visual_tools.loadRemoteControl();

/* RViz provides many types of markers, in this demo we will use text, cylinders, and spheres*/
Eigen::Affine3d text_pose = Eigen::Affine3d::Identity();
text_pose.translation().z() = 1.75;
visual_tools.publishText(text_pose, "Motion Planning Pipeline Demo", rvt::WHITE, rvt::XLARGE);

/* Batch publishing is used to reduce the number of messages being sent to RViz for large visualizations */
visual_tools.trigger();

/* Sleep a little to allow time to startup rviz, etc..
   This ensures that visual_tools.prompt() isn't lost in a sea of logs*/
ros::Duration(10).sleep();

/* We can also use visual_tools to wait for user input */
visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window to start the demo");
</code></pre> 
<p>3.Pose Goal<br> 现在，将为Panda的右臂创建一个运动计划请求，指定所需的末端执行器的姿势作为输入。</p> 
<pre><code>planning_interface::MotionPlanRequest req;
planning_interface::MotionPlanResponse res;
geometry_msgs::PoseStamped pose;
pose.header.frame_id = "panda_link0";
pose.pose.position.x = 0.3;
pose.pose.position.y = 0.0;
pose.pose.position.z = 0.75;
pose.pose.orientation.w = 1.0;
</code></pre> 
<p>位置公差0.01m，方向公差0.01弧度。</p> 
<pre><code>std::vector&lt;double&gt; tolerance_pose(3, 0.01);
std::vector&lt;double&gt; tolerance_angle(3, 0.01);
</code></pre> 
<p>将使用kinematic_constraints包中提供的帮助函数创建请求作为约束。</p> 
<pre><code>req.group_name = "panda_arm";
moveit_msgs::Constraints pose_goal =
    kinematic_constraints::constructGoalConstraints("panda_link8", pose, tolerance_pose, tolerance_angle);
req.goal_constraints.push_back(pose_goal);
</code></pre> 
<p>现在，调用管道并检查规划是否成功。</p> 
<pre><code>planning_pipeline-&gt;generatePlan(planning_scene, req, res);
/* Check that the planning was successful */
if (res.error_code_.val != res.error_code_.SUCCESS)
{
  ROS_ERROR("Could not compute plan successfully");
  return 0;
}
</code></pre> 
<p>4.Visualize the result</p> 
<pre><code>ros::Publisher display_publisher =
    node_handle.advertise&lt;moveit_msgs::DisplayTrajectory&gt;("/move_group/display_planned_path", 1, true);
moveit_msgs::DisplayTrajectory display_trajectory;

/* Visualize the trajectory */
ROS_INFO("Visualizing the trajectory");
moveit_msgs::MotionPlanResponse response;
res.getMessage(response);

display_trajectory.trajectory_start = response.trajectory_start;
display_trajectory.trajectory.push_back(response.trajectory);
display_publisher.publish(display_trajectory);

/* Wait for user input */
visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window to continue the demo");
</code></pre> 
<p>5.Joint Space Goals</p> 
<pre><code>/* First, set the state in the planning scene to the final state of the last plan */
robot_state::RobotState&amp; robot_state = planning_scene-&gt;getCurrentStateNonConst();
planning_scene-&gt;setCurrentState(response.trajectory_start);
const robot_model::JointModelGroup* joint_model_group = robot_state.getJointModelGroup("panda_arm");
robot_state.setJointGroupPositions(joint_model_group, response.trajectory.joint_trajectory.points.back().positions);
</code></pre> 
<p>现在，建立一个关节空间目标：</p> 
<pre><code>robot_state::RobotState goal_state(robot_model);
std::vector&lt;double&gt; joint_values = { -1.0, 0.7, 0.7, -1.5, -0.7, 2.0, 0.0 };
goal_state.setJointGroupPositions(joint_model_group, joint_values);
moveit_msgs::Constraints joint_goal = kinematic_constraints::constructGoalConstraints(goal_state, joint_model_group);

req.goal_constraints.clear();
req.goal_constraints.push_back(joint_goal);
</code></pre> 
<p>调用管道并可视化轨迹：</p> 
<pre><code>planning_pipeline-&gt;generatePlan(planning_scene, req, res);
/* Check that the planning was successful */
if (res.error_code_.val != res.error_code_.SUCCESS)
{
  ROS_ERROR("Could not compute plan successfully");
  return 0;
}
/* Visualize the trajectory */
ROS_INFO("Visualizing the trajectory");
res.getMessage(response);
display_trajectory.trajectory_start = response.trajectory_start;
display_trajectory.trajectory.push_back(response.trajectory);
</code></pre> 
<p>现在应该看到两个规划的轨迹串联在一起：</p> 
<pre><code>display_publisher.publish(display_trajectory);

/* Wait for user input */
visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window to continue the demo");
</code></pre> 
<p>6.Using a Planning Request Adapter<br> 规划请求适配器允许指定一系列操作，这些操作应该在规划发生之前或在对结果路径进行规划之后发生。</p> 
<pre><code>/* First, set the state in the planning scene to the final state of the last plan */
robot_state = planning_scene-&gt;getCurrentStateNonConst();
planning_scene-&gt;setCurrentState(response.trajectory_start);
robot_state.setJointGroupPositions(joint_model_group, response.trajectory.joint_trajectory.points.back().positions);
</code></pre> 
<p>现在，设置一个关节稍微超出其上限：</p> 
<pre><code>const robot_model::JointModel* joint_model = joint_model_group-&gt;getJointModel("panda_joint3");
const robot_model::JointModel::Bounds&amp; joint_bounds = joint_model-&gt;getVariableBounds();
std::vector&lt;double&gt; tmp_values(1, 0.0);
tmp_values[0] = joint_bounds[0].min_position_ - 0.01;
robot_state.setJointPositions(joint_model, tmp_values);
req.goal_constraints.clear();
req.goal_constraints.push_back(pose_goal);
</code></pre> 
<p>再次调用planner，并可视化轨迹：</p> 
<pre><code> planning_pipeline-&gt;generatePlan(planning_scene, req, res);
  if (res.error_code_.val != res.error_code_.SUCCESS)
  {
    ROS_ERROR("Could not compute plan successfully");
    return 0;
  }
  /* Visualize the trajectory */
  ROS_INFO("Visualizing the trajectory");
  res.getMessage(response);
  display_trajectory.trajectory_start = response.trajectory_start;
  display_trajectory.trajectory.push_back(response.trajectory);
  /* Now you should see three planned trajectories in series*/
  display_publisher.publish(display_trajectory);

  /* Wait for user input */
  visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window to finish the demo");

  ROS_INFO("Done");
  return 0;
}
</code></pre> 
<p><strong>四.The Launch File</strong><br> 全部launch文件参考文献[3]。本教程中的所有代码都可以从moveit_tutorials包[MoveIt的一部分]编译并运行设置。</p> 
<p><strong>参考文献：</strong><br> [1]Motion Planning Pipeline：http://docs.ros.org/kinetic/api/moveit_tutorials/html/doc/motion_planning_pipeline/motion_planning_pipeline_tutorial.html<br> [2]motion_planning_pipeline：https://github.com/ros-planning/moveit_tutorials/tree/kinetic-devel/doc/motion_planning_pipeline<br> [3]motion_planning_pipeline_tutorial：https://github.com/ros-planning/moveit_tutorials/tree/kinetic-devel/doc/motion_planning_pipeline/launch/motion_planning_pipeline_tutorial.launch</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2546de94f2edcb0cc1b248fbd0bd8b9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">超简单的内网穿透ngrok</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e7bcc012b985fcdc077277a634a4cf0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Vue和Vant-ui开发的移动端周历日期选择器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>