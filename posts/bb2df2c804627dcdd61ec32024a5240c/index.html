<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python(基础--函数) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python(基础--函数)" />
<meta property="og:description" content="函数 普通函数
函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。
函数能提高应用的模块性，和代码的重复利用率。
规则：
以 def 关键词开头，后接函数标识符名称和圆括号 ()。
任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。（参数可以没有）
函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
函数名所有都小写
函数内容以冒号起始，并且缩进。
return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。
注意：若定义的函数名在程序前面定义的函数名相同则将程序前面的函数名覆盖
def 函数名（参数列表）:
函数体
函数调用
你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。
参数传递
注意：类型属于对象，变量是没有类型的
a=[1,2,3]
a=“Runoob”
解析: [1,2,3] 是 List 类型，“Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。
固定参数：
形参：定义函数时，括号里的参数，没有具体值
补充：1.形参可以有默认值，调用时，该参数可以不赋值，如果赋值就会覆盖掉默认值
2.如果形参有默认值，那么该形参后面的参数也必须有默认值
实参：调用函数时，括号里的参数，有具体值
位置参数：函数调用时实参的顺序是和形参一一对应的，那么就是位置参数
默认参数：有默认值的参数(默认参数必须放在最后面否则报错SyntaxError: non-default argument follows default argument)
关键字参数：实参赋值时，如果标明参数名字=值，那么该参数就成为了关键字参数,不需要按照顺序赋值
非固定参数：
如果定义参数时，参数个数不固定，可以定义非固定参数，一般写*args
注意：函数参数赋值时，如果非固定参数后还有参数，那么该参数的赋值必须用关键字参数赋值
1.加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。我们也可以不向函数传递未命名的变量,如果在函数调用时没有指定参数，它就是一个空元组。
def printinfo( arg1, *vartuple ):
“打印任何传入的参数”
print (&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bb2df2c804627dcdd61ec32024a5240c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-18T19:10:09+08:00" />
<meta property="article:modified_time" content="2018-11-18T19:10:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python(基础--函数)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>函数</h3> 
<p>普通函数<br> 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。<br> 函数能提高应用的模块性，和代码的重复利用率。<br> 规则：<br> 以 def 关键词开头，后接函数标识符名称和圆括号 ()。<br> 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。（参数可以没有）<br> 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。<br> 函数名所有都小写<br> 函数内容以冒号起始，并且缩进。<br> return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。<br> 注意：若定义的函数名在程序前面定义的函数名相同则将程序前面的函数名覆盖<br> def 函数名（参数列表）:<br> 函数体<br> 函数调用<br> 你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。<br> 参数传递<br> 注意：类型属于对象，变量是没有类型的<br> a=[1,2,3]<br> a=“Runoob”<br> 解析: [1,2,3] 是 List 类型，“Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。<br> 固定参数：<br> 形参：定义函数时，括号里的参数，没有具体值<br> 补充：1.形参可以有默认值，调用时，该参数可以不赋值，如果赋值就会覆盖掉默认值<br> 2.如果形参有默认值，那么该形参后面的参数也必须有默认值<br> 实参：调用函数时，括号里的参数，有具体值<br> 位置参数：函数调用时实参的顺序是和形参一一对应的，那么就是位置参数<br> 默认参数：有默认值的参数(默认参数必须放在最后面否则报错SyntaxError: non-default argument follows default argument)<br> 关键字参数：实参赋值时，如果标明参数名字=值，那么该参数就成为了关键字参数,不需要按照顺序赋值<br> 非固定参数：<br> 如果定义参数时，参数个数不固定，可以定义非固定参数，一般写*args<br> 注意：函数参数赋值时，如果非固定参数后还有参数，那么该参数的赋值必须用关键字参数赋值<br> 1.加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。我们也可以不向函数传递未命名的变量,如果在函数调用时没有指定参数，它就是一个空元组。<br> def printinfo( arg1, *vartuple ):<br> “打印任何传入的参数”<br> print ("输出: ")<br> print (arg1)<br> print (vartuple)</p> 
<h2><a id="printinfo__39"></a>调用printinfo 函数</h2> 
<p>printinfo( 70, 60, 50 )<br> 输出:<br> 70<br> (60, 50)<br> 2. 加了两个星号 ** 的参数会以字典的形式导入。<br> def printinfo( arg1, **vardict ):<br> “打印任何传入的参数”<br> print ("输出: ")<br> print (arg1)<br> print (vardict)</p> 
<h2><a id="printinfo__50"></a>调用printinfo 函数</h2> 
<p>printinfo(1, a=2,b=3)<br> 输出:<br> 1<br> {‘a’: 2, ‘b’: 3}<br> 3. 声明函数时，参数中星号 * 可以单独出现，如果单独出现星号 ,* 后的参数必须用关键字传入。<br> 可更改(mutable)与不可更改(immutable)对象<br> 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。<br> 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响<br> 严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。<br> 匿名函数<br> 定义：使用 lambda 来创建匿名函数。不再使用 def 语句这样标准的形式定义一个函数。<br> 规则：<br> 1.lambda 只是一个表达式，函数体比 def 简单很多。<br> 2.lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。<br> 3.lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。<br> 补充：虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。<br> lambda [arg1 [,arg2,…argn]]:expression<br> 可以使用"关键字参数"进行参数传递<br> g= lambda x,y : x<strong>2+y</strong>2</p> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>g(y=3,x=2)<br> 13<br> 变量作用域<br> Python的作用域一共有4种，分别是：<br> L （Local） 局部作用域<br> E （Enclosing） 闭包函数外的函数中<br> G （Global） 全局作用域<br> B （Built-in） 内建作用域<br> 以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>x = int(2.9) # 内建作用域<br> g_count = 0 # 全局作用域<br> def outer():<br> o_count = 1 # 闭包函数外的函数中<br> def inner():<br> i_count = 2 # 局部作用域<br> 内建作用域<br> 内置作用域是通过一个名为builtin的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量:<br> import builtins<br> dir(builtins)<br> 全局变量，局部变量举例<br> def changeme(mylist):<br> # “修改传入的列表”<br> mylist.append([1, 2, 3, 4]) # 这里没有定义，也没有报错，说明milist以已经存在，修改的是全局变量<br> print("函数内取值1: ", mylist)<br> print(“2”, id(mylist))<br> # mylist.clear()<br> mylist = [9,8,7,6,] # 这里定义的是局部变量，和函数外定义的同名列表的id是不一样的，一个是局部变量一个是全局变量，以下在修改是局部变量，和全局变量没有关系。对可更改类型的引用进行修改，结果就不一样了。<br> print("函数内取值2: ", mylist)<br> print(“3”, id(mylist))<br> return mylist</p> 
<h2><a id="changeme_101"></a>调用changeme函数</h2> 
<p>mylist = [10, 20, 30]<br> print(“1”, id(mylist))<br> print(“4”, id(changeme(mylist)))<br> print("函数外取值: ", mylist)<br> print(“5”, id(mylist))</p> 
<p>global 和 nonlocal关键字<br> global：当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。</p> 
<p>Nonlocal：如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了（在二层函数中修改一层函数的局部变量）</p> 
<p>闭包函数<br> 闭包：<br> 在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。<br> 1 外函数返回了内函数的引用：<br> 当我们在python中定义一个函数def demo(): 的时候，内存当中会开辟一些空间，存下这个函数的代码、内部的局部变量等等。这个demo只不过是一个变量名字，它里面存了这个函数所在位置的引用而已。我们还可以进行x = demo， y = demo， 这样的操作就相当于，把demo里存的东西赋值给x和y，这样x 和y 都指向了demo函数所在的引用，在这之后我们可以用x() 或者 y() 来调用我们自己创建的demo() ，调用的实际上根本就是一个函数，x、y和demo三个变量名存了同一个函数的引用。<br> 同时我们发现，一个函数，如果函数名后紧跟一对括号，相当于现在我就要调用这个函数，如果不跟括号，相当于只是一个函数的名字，里面存了函数所在位置的引用。<br> 2 外函数把临时变量绑定给内函数：<br> 一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。<br> Python中一切都是对象，虽然函数我们只定义了一次，但是外函数在运行的时候，实际上是按照里面代码执行的，外函数里创建了一个函数，我们每次调用外函数，它都创建一个内函数，虽然代码一样，但是却创建了不同的对象，并且把每次传入的临时变量数值绑定给内函数，再把内函数引用返回。虽然内函数代码是一样的，但其实，我们每次调用外函数，都返回不同的实例对象的引用，他们的功能是一样的，但是它们实际上不是同一个函数对象。<br> Eg1<br> def outer(x):<br> a = 10<br> def inner(y):<br> nonlocal x<br> x = y + x + a<br> return x<br> return inner<br> print(outer(10)(3))<br> print(outer(20)(5))<br> print(outer(10)(3))<br> 实行结果:<br> 23<br> 35<br> 23<br> 闭包中内函数修改外函数局部变量：<br> 1 在python3中，可以用nonlocal 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。<br> 2 在python2中，没有nonlocal这个关键字，我们可以把闭包变量改成可变类型数据进行修改，比如列表。<br> 还有一点需要注意：使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量<br> Eg2<br> def outer(x):<br> a = 10<br> def inner(y):<br> nonlocal x<br> x = y + x + a<br> return x<br> return inner</p> 
<p>a = outer(10)<br> print(a(1))<br> print(a(3))<br> print(a(3))<br> 实行结果：<br> 21<br> 34<br> 47<br> 注解：a = outer(10)这行代码是将外部函数的x赋值并绑定到内部函数中，并将内部函数的引用赋值给a<br> print(a(1))是直接调用内部函数，参数1是对应定义内部函数形参y的值<br> 因为x是外部函数的形参，绑定到内部函数中，并且内部函数中使用了nonlocal，所以x是可以更改的，闭包函数每次调用都是使用同一份闭包变量，所以x的值不断增加(都是使用a进行调用闭包函数)。所以，a（3）和a（3）的结果不一样。Eg2中外部函数每次都会重新进行实例化，所以不会被重复调用</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa36202aa8c110d790597cf2eb53cbe4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在malloc函数中为什么常用sizeof来设定内存分配的大小？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39bdae7632af429f1ecc487f4cfc48a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信支付-免充值立减与折扣(下篇)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>