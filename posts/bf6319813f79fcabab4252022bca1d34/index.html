<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript模块的导出和导入之export和module.exports的区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaScript模块的导出和导入之export和module.exports的区别" />
<meta property="og:description" content="目录
export和module.exports
**exports **返回的是模块函数
**module.exports **返回的是模块对象本身，返回的是一个类
关键字
模块规范
CommonJS模块规范
module.exports 和 exports
require
ES6模块规范
export 和 export default
import
Node为何支持export / import
总结
export和module.exports (注意：前面的export没有“s”,后面的module.exports 有“s”)
使用两者根本区别是
**exports **返回的是模块函数 **module.exports **返回的是模块对象本身，返回的是一个类 使用上的区别是
exports的方法可以直接调用
module.exports需要new对象之后才可以调用
关键字 在js编程中经常会有模块的导出导入，涉及到一些导入导出关键字
导出关键字 module.exportsexportsexportexport default导入关键字 require const xxx = require(&#34;模块名&#34;)import import { xxx } from &#34;模块名&#34;import xxx from &#34;模块名&#34;import xxx1, {xxx2, xxx3,...} from &#34;模块名&#34;import * from &#34;模块名&#34; 因为在实际开发中经常会混淆这些用法，所以想要弄清楚这些的区别，让自己明白自己到底在写什么。本文作为学习笔记输出。
模块规范 JS模块化编程分了两种规范：CommonJS模块规范和ES6模块规范。
CommonJS模块规范 —— CommonJS规范中，以module.exports导出接口，以require引入模块ES6模块规范 —— ES6标准规范中，以export指令导出接口，以import引入模块 在Node." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bf6319813f79fcabab4252022bca1d34/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-13T10:16:20+08:00" />
<meta property="article:modified_time" content="2023-05-13T10:16:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript模块的导出和导入之export和module.exports的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="export%E5%92%8Cmodule.exports-toc" style="margin-left:40px;"><a href="#export%E5%92%8Cmodule.exports" rel="nofollow">export和module.exports</a></p> 
<p id="**exports%20**%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#**exports%20**%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0" rel="nofollow">**exports **返回的是模块函数</a></p> 
<p id="**module.exports%20**%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%BA%AB%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB-toc" style="margin-left:40px;"><a href="#**module.exports%20**%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%BA%AB%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB" rel="nofollow">**module.exports **返回的是模块对象本身，返回的是一个类</a></p> 
<p id="%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">关键字</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83-toc" style="margin-left:40px;"><a href="#%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83" rel="nofollow">模块规范</a></p> 
<p id="CommonJS%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83-toc" style="margin-left:40px;"><a href="#CommonJS%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83" rel="nofollow">CommonJS模块规范</a></p> 
<p id="module.exports%20%E5%92%8C%20exports-toc" style="margin-left:40px;"><a href="#module.exports%20%E5%92%8C%20exports" rel="nofollow">module.exports 和 exports</a></p> 
<p id="require-toc" style="margin-left:40px;"><a href="#require" rel="nofollow">require</a></p> 
<p id="ES6%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83-toc" style="margin-left:0px;"><a href="#ES6%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83" rel="nofollow">ES6模块规范</a></p> 
<p id="export%20%E5%92%8C%20export%20default-toc" style="margin-left:40px;"><a href="#export%20%E5%92%8C%20export%20default" rel="nofollow">export 和 export default</a></p> 
<p id="import-toc" style="margin-left:40px;"><a href="#import" rel="nofollow">import</a></p> 
<p id="Node%E4%B8%BA%E4%BD%95%E6%94%AF%E6%8C%81export%20%2F%20import-toc" style="margin-left:0px;"><a href="#Node%E4%B8%BA%E4%BD%95%E6%94%AF%E6%8C%81export%20%2F%20import" rel="nofollow">Node为何支持export / import</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="export%E5%92%8Cmodule.exports"><strong>export和module.exports</strong></h3> 
<p><em>         (注意：前面的export没有“s”,后面的module.exports 有“s”)</em></p> 
<p>使用两者根本区别是</p> 
<blockquote> 
 <h3 id="**exports%20**%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0">**exports **返回的是模块函数</h3> 
 <h3 id="**module.exports%20**%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%BA%AB%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB">**module.exports **返回的是模块对象本身，返回的是一个类</h3> 
</blockquote> 
<p>使用上的区别是<br><strong>exports的方法可以直接调用</strong><br><strong>module.exports需要new对象之后才可以调用</strong></p> 
<h3 id="%E5%85%B3%E9%94%AE%E5%AD%97"><br> 关键字</h3> 
<p id="%E5%9C%A8js%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%BB%8F%E5%B8%B8%E4%BC%9A%E6%9C%89%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%EF%BC%8C%E6%B6%89%E5%8F%8A%E5%88%B0%E4%B8%80%E4%BA%9B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%85%B3%E9%94%AE%E5%AD%97">在js编程中经常会有模块的导出导入，涉及到一些导入导出关键字</p> 
<ul><li>导出关键字 
  <ul><li>module.exports</li><li>exports</li><li>export</li><li>export default</li></ul></li><li>导入关键字 
  <ul><li>require 
    <ul><li>const xxx = require("模块名")</li></ul></li><li>import 
    <ul><li>import { xxx } from "模块名"</li><li>import xxx from "模块名"</li><li>import xxx1, {xxx2, xxx3,...} from "模块名"</li><li>import * from "模块名"</li></ul></li></ul></li></ul> 
<p>因为在实际开发中经常会混淆这些用法，所以想要弄清楚这些的区别，让自己明白自己到底在写什么。本文作为学习笔记输出。</p> 
<h2></h2> 
<h3 id="%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83">模块规范</h3> 
<p>JS模块化编程分了两种规范：CommonJS模块规范和ES6模块规范。</p> 
<ul><li>CommonJS模块规范 —— CommonJS规范中，以module.exports导出接口，以require引入模块</li><li>ES6模块规范 —— ES6标准规范中，以export指令导出接口，以import引入模块</li></ul> 
<p>在Node.js编程中，Node模块系统遵循的是CommonJS规范。</p> 
<h3 id="CommonJS%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83">CommonJS模块规范</h3> 
<p>CommonJS规范规定: 每个js文件就是一个模块，有自己的作用域。<br> 在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<br> 如果要暴露给其他程序，需要以module.exports导出接口，以require引入模块。</p> 
<h3 id="module.exports%20%E5%92%8C%20exports">module.exports 和 exports</h3> 
<blockquote> 
 <p>module.exports / exports: 只有 Node 支持的导出<br> 模块导出的时候，导出的是module.exports，不是exports<br> module.exports可以导出所有的类型。对象，函数，字符串、数值等。</p> 
</blockquote> 
<p>每一个js文件通过node执行时，都自动创建一个module变量和一个exports变量。<br> module变量代表当前模块。这个变量是一个对象，同时，module对象会创建一个叫exports的属性（即module.exports），该属性初始化的值是 {}，是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p> 
<pre><code>//logtes.js
console.log("我是外部js,没有使用export")
console.log(module)
</code></pre> 
<p>执行node test1.js的打印结果：</p> 
<pre><code> path: 'C:\\Users\\xxwang\\Documents\\pmms\\TS\\tsdemo\\day01',               
  exports: {},                                                                    
  filename: 'C:\\Users\\xxwang\\Documents\\pmms\\TS\\tsdemo\\day01\\logtes.js',
  loaded: false,                                                                  
  children: [],                                                                   
  paths: [                                                                        
    'C:\\Users\\xxwang\\Documents\\pmms\\TS\\tsdemo\\day01\\node_modules',     
    'C:\\Users\\xxwang\\Documents\\pmms\\TS\\tsdemo\\node_modules',            
    'C:\\Users\\xxwang\\Documents\\pmms\\TS\\node_modules',                    
    'C:\\Users\\xxwang\\Documents\\pmms\\node_modules',                        
    'C:\\Users\\xxwang\\Documents\\node_modules',                              
    'C:\\Users\\xxwang\\node_modules',                                         
    'C:\\Users\\node_modules',                                                    
    'C:\\node_modules'                                                            
  ]                                                                               
}                                                                                 

Process finished with exit code 0
</code></pre> 
<p>默认exports变量是对module.exports的引用，即exports和module.exports指向同一个内存块。 这等同在每个模块头部，有一行这样的命令。</p> 
<pre><code>var exports = module.exports;</code></pre> 
<ul><li>当通过exports去改变内存块里内容时，module.exports的值也会改变</li><li>当通过module.exports去改变内存块里内容时，exports的值也会改变</li><li>当module.exports被改变的时候，exports不会被改变</li><li>当exports被改变的时候，module.exports不会被改变</li></ul> 
<p>所以，exports属性的出现应该可以直接向exports对象添加方法，从而方便对外输出模块接口。不过当module.exports改变时，exports与module.exports也就断开了链接，所以最好不要采用这种方式，统一采用module.exports方式。</p> 
<pre><code>// module_export_demo.js
module.exports.a = 100
console.log("log1: " + exports.a)  // log1: 100

exports.a = 200; 
console.log("log2: " + module.exports.a)  // log2: 200

module.exports = "hello"
console.log("log3: " + JSON.stringify(exports)) // log3: {"a":200}
复制代码
</code></pre> 
<p>module.exports可以导出所有的类型。对象，函数，字符串、数值等。 语法示例：</p> 
<pre><code>// module_export_demo2.js
var x = 5

var str = "hello"

var addX = function (value) {
  return value + x
};

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}

// module.exports.x = x
// module.exports.str = str
// module.exports.addX = addX
// module.exports.Point = Point

module.exports = {
  x: x,
  str: str,
  addX: addX,
  Point: Point
}

// require时对比下两种方式x的值到底取哪个
exports = {
  x: 10,
}
复制代码
</code></pre> 
<h3 id="require">require</h3> 
<p>requirer用于加载模块，是node的一个全局方法，使用非常简单</p> 
<pre><code>const xxx = require("模块名")
复制代码
</code></pre> 
<p>读入并执行一个JavaScript文件，返回模块的exports对象。如果没有发现指定模块，会报错。</p> 
<p>require方法接受以下几种参数的传递：</p> 
<ul><li>原生模块，如http、fs、path等</li><li>相对路径的文件模块，如./mod或../mod</li><li>绝对路径的文件模块，如 /pathtomodule/mod</li><li>第三方模块，如koa等</li></ul> 
<p>在模块目录中通常有一个package.json文件，并且将入口文件写入main字段</p> 
<pre><code>    // package.json
    { "name" : "some-library",
      "main" : "./lib/some-library.js" }
复制代码
</code></pre> 
<p>require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。<br> 如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件</p> 
<p>因为模块导出的实际是module.exports，所以require只能看到通过 module.exports 导出的内容，看不到通过exports导出的内容。它相当于module.exports的传送门，module.exports后面的内容是什么，require的结果就是什么，对象、数字、字符串、函数...再把require的结果赋值给某个变量。 针对上面的 module_export_domo2.js 文件，引入模块示例</p> 
<pre><code>// node require_demo2.js
const demo2 = require("./module_export_demo2")

console.log(demo2.x)  // 5 也证明了引入的是module.export的内容
console.log(demo2.str)  // hello
console.log(demo2.addX(15)) // 20  = 5 + 15 

let point = new demo2.Point(3, 4)
console.log(point.toString()) //  (3, 4)
复制代码
</code></pre> 
<p>require 是运行时的，其参数可以是表达式</p> 
<pre><code>let value = 2
const demo2 = require("./module_export" + "_demo" + value)
复制代码
</code></pre> 
<p>require函数加载模块</p> 
<ol><li> <p>require函数加载模块顺序按照其在代码中出现的顺序</p> </li><li> <p>require函数加载模块是同步的，只有加载完成，才能执行后面的操作</p> </li><li> <p>require函数加载的模块是被输出的值的拷贝，不会受到模块内容变化影响</p> <pre><code> // module_export_demo3.js
 var counter = 3;
 function incCounter() {
   counter++;
 }
 module.exports = {
   counter: counter,
   incCounter: incCounter,
 };
复制代码
</code></pre> <pre><code> const demo3 = require("./module_export_demo3")
 console.log(demo3.counter);  // 3
 demo3.incCounter();
 console.log(demo3.counter); // 3
复制代码
</code></pre> <p>counter输出结果说明module_export_demo3模块内部的变化就影响不到counter了</p> </li><li> <p>模块第一次被加载时会执行一次，后续被加载时不会再执行，都是从缓存中获取的</p> <pre><code>// module_export_demo3.js
console.log("hello")
module.exports = "wrold"
复制代码
</code></pre> <pre><code>const demo3 = require("./module_export_demo3")
const demo3_1 = require("./module_export_demo3")
const demo3_2 = require("./module_export_demo3")
const demo3_3 = require("./module_export_demo3")
const demo3_4 = require("./module_export_demo3")
const demo3_5 = require("./module_export_demo3")
console.log(demo3)
console.log(demo3_1)

// hello
// wrold
// wrold
复制代码
</code></pre> <p>hello只会被打印一次说明console.log("hello")语句只执行了一次，module_export_demo3.js只被加载了一次。</p> </li></ol> 
<h2 id="ES6%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83">ES6模块规范</h2> 
<p>ES6发布的module并没有直接采用CommonJS，甚至连require都没有采用，也就是说require仍然只是node的一个私有的全局方法，module.exports也只是node私有的一个全局变量属性，跟标准什么关系都没有。<br> ES6模块规范是，在创建JS模块时，export 语句用于从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。</p> 
<h3 id="export%20%E5%92%8C%20export%20default">export 和 export default</h3> 
<p>ES6模块导出有两种方式：export(命名导出) 和 export default(默认导出)。 在导出多个值时，命名导出非常有用。在导入时，必须使用相应对象的相同名称。但是，可以使用任何名称导入默认导出。</p> 
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fimport" rel="nofollow" title="export语法介绍">export语法介绍</a></p> 
<pre><code>// 导出单个特性
export let name1, name2, …, nameN; // also var, const
export let name1 = …, name2 = …, …, nameN; // also var, const
export function FunctionName(){...}
export class ClassName {...}

// 导出列表
export { name1, name2, …, nameN };

// 重命名导出
export { variable1 as name1, variable2 as name2, …, nameN };

// 默认导出
export default expression;
export default function (…) { … } // also class, function*
export default function name1(…) { … } // also class, function*
export { name1 as default, … };

// 导出"引入模块的导出值"
export { name1, name2, …, nameN } from …;
export { import1 as name1, import2 as name2, …, nameN } from …;
export * from …; // 导出"引入模块的所有导出值"，不包括模块的默认导出值
export { default } from …; // 导出"引入模块的默认导出值"
复制代码
</code></pre> 
<ul><li>export与export default均可用于导出常量、函数、文件、模块等</li><li>通过export方式导出，在导入时要加{ }，export default则不需要</li><li>在一个文件中，export可以有多个，export default仅有一个</li><li>大部分风格建议，模块中最好在末尾用一个export导出所有的接口</li></ul> 
<pre><code>export 1 // 这种写法错误

// 正确的写法
const value = 1
export { value }

// 或者
export const value = 1

// 或者
const value = 1
export default value

// 或者
export default 1
复制代码
</code></pre> 
<p>export default是别名的语法糖，这个语法糖的好处在是</p> 
<ul><li>import的时候，可以省去花括号{}。</li><li>import的时候, 可以起任何变量名表示引入变量</li></ul> 
<p>所以如果import的时候，你发现某个变量没有花括号括起来（除了* 号），是因为该变量是通过export default 导出的。</p> 
<pre><code>// d.js
// 导出函数
export default function() {}

// 等效于：
// function a() {};
// export {a as default};

复制代码
</code></pre> 
<pre><code>import a from "d.js" // a 是 {defalut as a}的替代写法。
复制代码
</code></pre> 
<p>所以使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名。</p> 
<pre><code>// a.js
let sex = "boy";
export default sex //sex不能加大括号 等价于 export {sex as default}
复制代码
</code></pre> 
<p>本质上，a.js文件的export default输出一个叫做default的变量，然后系统允许你为它取任意名字。 自然default只能有一个值，所以一个文件内不能有多个export default。</p> 
<pre><code>// b.js
import any from "./a.js"
import any12 from "./a.js" 
console.log(any, any12)   // boy,boy
复制代码
</code></pre> 
<h3 id="import">import</h3> 
<p>require 和 import是完全不同的两种概念。require是赋值过程，import是解构过程 const xxx = require("模块名") import { xxx } from "模块名"</p> 
<ul><li>import是编译时的, 必须放在文件开头，否则会报错</li><li>import后面跟上花括号的形式是最基本的用法，花括号里面的变量与export后面的变量一一对应。</li></ul> 
<pre><code>import {a} from ..
复制代码
</code></pre> 
<ul><li>支持给变量取别名。因为有的时候不同的两个模块可能有相同的接口，可以给这个变量取一个别名，方便在当前的文件里面使用。</li></ul> 
<pre><code>import {a as a_a} from ..
复制代码
</code></pre> 
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fimport" rel="nofollow" title="import介绍语法">import介绍语法</a></p> 
<pre><code>import defaultExport from "module-name";
import * as name from "module-name";
import { export1 } from "module-name";
import { export1 as alias1 } from "module-name";
import { export1 , export2 } from "module-name";
import { foo , bar } from "module-name/path/to/specific/un-exported/file";
import { export1 , export2 as alias2 , [...] } from "module-name";
import defaultExport, { export1 [ , [...] ] } from "module-name";
import defaultExport, * as name from "module-name";
import "module-name";
var promise = import("module-name"); // 动态模块加载，返回的是一个promise对象
复制代码
</code></pre> 
<h2 id="Node%E4%B8%BA%E4%BD%95%E6%94%AF%E6%8C%81export%20%2F%20import">Node为何支持export / import</h2> 
<p>我们经常会看到在node中也会用export / import，这是什么呢？ 我们在node中使用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2F" rel="nofollow" title="babel">babel</a>支持ES6，仅仅是将ES6转码为ES5再执行，import语法会被转码为require。因为目前所有的引擎都还没有实现export / import。<br> 如何让Node.js支持ES6的语法具体参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F6844904017764548622" rel="nofollow" title="在node环境中支持ES6代码">在node环境中支持ES6代码</a></p> 
<pre><code>// ES6语法
import {a} from "./demo.js"
// 转码ES5后
var _demo = require("./demo.js")
复制代码
</code></pre> 
<p>这也是为什么在使用module.exports模块导出时，在引入模块时使用import仍然起效，因为本质上，import会被转码为require去执行。</p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p>CommonJS规范中，建议尽量都用 module.exports 导出，然后用require导入 ES6规则中，大部分风格建议，模块中最好在末尾用一个export导出所有的接口</p> 
<ul><li>module.exports / exports: 只有 Node 支持的导出</li><li>require: Node 和 ES6 都支持的引入</li><li>export / import : 只有ES6 支持的导出引入</li></ul> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07cc2d87b2c9119aae461559974d8adf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Element Plus介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2a4ef8aceb33f053b72d356f226ee9a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">项目中引入@ConfigurationProperties()后idea上方报红</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>