<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql并发写 主键重复_数据库“锁”事一例：并发情景下重复主键问题方案讨论... - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql并发写 主键重复_数据库“锁”事一例：并发情景下重复主键问题方案讨论..." />
<meta property="og:description" content="在做的一个账单计息功能，其中，账单表的主键是BillId，varchar类型，BillId取值形如B0000001，生成规则是每次新增记录时先从账单表里计算出最大的BillId数字，然后&#43;1再转换后作为新增记录的BillId。例如，B0000001、B0000002。
逻辑很简单，但考虑到并发，技术上就要费点心了。
为了简化场景，这里我写了一些测试用例，涉及到一个包含两个字段的表student(id int, sno varchar(32)),PK是id。数据库是引擎为InnoDB的Mysql5。InnoDB支持事务操作。
并发处理之lock
这段逻辑用程序来实现的话，用lock关键字，就可以保证多线程情况下同时只能有一个线程来访问资源。
static object syncRoot = new object();private void AddStudent_Lock(stringname)
{lock(syncRoot)
{object maxId = ExecuteScalar(&#34;select max(id) from student&#34;);if (maxId == null || maxId ==DBNull.Value)
{
maxId= 0;
}int newId = Convert.ToInt32(maxId) &#43; 1;string sql = &#34;INSERT INTO student VALUES(&#34; &#43; newId &#43; &#34;,&#39;&#34; &#43; name &#43; &#34;&#39;);&#34;;
ExecuteNonQuery(sql);
}
}
测试用例：
[TestMethod]public voidTest3()
{
ExecuteScalar(&#34;DROP TABLE IF Exists student;&#34;);
ExecuteScalar(&#34;CREATE TABLE student(id INT NOT NULL,sno varchar(255),PRIMARY KEY (id));&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/63f39baa259dd3bc201febb456236d14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-04T01:49:35+08:00" />
<meta property="article:modified_time" content="2021-02-04T01:49:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql并发写 主键重复_数据库“锁”事一例：并发情景下重复主键问题方案讨论...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>在做的一个账单计息功能，其中，账单表的主键是BillId，varchar类型，BillId取值形如B0000001，生成规则是每次新增记录时先从账单表里计算出最大的BillId数字，然后+1再转换后作为新增记录的BillId。例如，B0000001、B0000002。</p> 
 <p>逻辑很简单，但考虑到并发，技术上就要费点心了。</p> 
 <p>为了简化场景，这里我写了一些测试用例，涉及到一个包含两个字段的表student(id int, sno varchar(32)),PK是id。数据库是引擎为InnoDB的Mysql5。InnoDB支持事务操作。</p> 
 <p>并发处理之lock</p> 
 <p>这段逻辑用程序来实现的话，用lock关键字，就可以保证多线程情况下同时只能有一个线程来访问资源。</p> 
 <p>static object syncRoot = new object();private void AddStudent_Lock(stringname)</p> 
 <p>{lock(syncRoot)</p> 
 <p>{object maxId = ExecuteScalar("select max(id) from student");if (maxId == null || maxId ==DBNull.Value)</p> 
 <p>{<!-- --></p> 
 <p>maxId= 0;</p> 
 <p>}int newId = Convert.ToInt32(maxId) + 1;string sql = "INSERT INTO student VALUES(" + newId + ",'" + name + "');";</p> 
 <p>ExecuteNonQuery(sql);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>测试用例：</p> 
 <p>[TestMethod]public voidTest3()</p> 
 <p>{<!-- --></p> 
 <p>ExecuteScalar("DROP TABLE IF Exists student;");</p> 
 <p>ExecuteScalar("CREATE TABLE student(id INT NOT NULL,sno varchar(255),PRIMARY KEY (id));");</p> 
 <p>ExecuteScalar("truncate table student;");//Stopwatch watch = new Stopwatch();//watch.Start();</p> 
 <p>List ths = new List();for (int i = 0; i &lt; 10; i++)</p> 
 <p>{var thread = new Thread(() =&gt;{try{for (int j = 0; j &lt; 500; j++)</p> 
 <p>AddStudent(Thread.CurrentThread.Name+ "--" +j);</p> 
 <p>}catch(Exception ex)</p> 
 <p>{<!-- --></p> 
 <p>Console.WriteLine(Thread.CurrentThread.Name+ "--" +ex.Message);</p> 
 <p>}</p> 
 <p>});</p> 
 <p>thread.Name= "thread" +i;</p> 
 <p>ths.Add(thread);</p> 
 <p>}</p> 
 <p>ths.ForEach(t=&gt;t.Start());</p> 
 <p>Thread.Sleep(15 * 1000);</p> 
 <p>}</p> 
 <p>运行测试，ok。</p> 
 <p>这个方案解决了多线程下(同一进程内)的并发问题。但，在分布式系统的场景下，项目中的若干应用系统都涉及到生成账单的逻辑，这个方案显然就无能为力了。</p> 
 <p>数据库锁</p> 
 <p>看来，如果多个系统都涉及到生成账单的逻辑，其中一个方案是封装这个生成账单的逻辑，然后通过rpc来实现。另一个方案，假定这个逻辑在每个系统里都有，就要在数据库层面来控制了。这里，我要介绍的是后者。</p> 
 <p>为了避免多个进程同时访问这段逻辑出现重复主键冲突，所以，需要锁表。mysql语句见下：</p> 
 <p>public void AddStudent(stringname)</p> 
 <p>{string sql = @"LOCK TABLES student WRITE;</p> 
 <p>SELECT @maxid:= MAX(id) FROM student for update;</p> 
 <p>SET @maxid:=IF(@maxid IS NULL,0,@maxid);</p> 
 <p>INSERT student VALUES(@maxid+1,@name);</p> 
 <p>UNLOCK TABLES;";</p> 
 <p>ExecuteNonQuery(sql,new MySqlParameter("@name",name));</p> 
 <p>}</p> 
 <p>同样用上面的测试用例来测试，ok。</p> 
 <p>以上是用mysql实现的。 在SqlServer里，因为t-sql和pl/sql是两大派系，其sql语句是这样子的：</p> 
 <p>public void AddStudent(stringname)</p> 
 <p>{string sql = @"BEGIN Tran;</p> 
 <p>declare @maxid int;</p> 
 <p>SELECT @maxid= MAX(id) FROM student with(TABLOCKX);</p> 
 <p>SET @maxid=case when @maxid IS NULL then 0 else @maxid end;</p> 
 <p>INSERT student VALUES(@maxid+1,@name);</p> 
 <p>COMMIT;";</p> 
 <p>ExecuteNonQuery(sql,new SqlParameter("@name", name));</p> 
 <p>}</p> 
 <p>为表加了TABLOCKX锁后，其他事务将无法对表做任何读写操作。TABLOCKX与HOLDLOCK是有区别的，如果换成HOLDLOCK，运行测试用例，会出现死锁“事务(进程id xx)与另一个进程被死锁在 锁 资源上,并且已被选作死锁牺牲品。请重新运行该事务。”，见下截图：</p> 
 <p align="center"><img src="https://images2.imgbox.com/5b/d1/0ur2BkSp_o.png" alt="f232e9f623854edd14f68a6a0c3b4556.png"></p> 
 <p>一同学说，用存储过程就可以解决这种并发冲突，不过经过测试，这种说法是不对的，即时是在存储过程里，也要加上TABLOCKX和事务。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/332191067d86e3fa43945b71794afd0d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python怎么输出计算结果_在Python中我们最常用的用来在屏幕上输出计算结果的功能函数是____________。(2.5分)_学小易找答案...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a5e1308aaeb39e5aff3ac62ceb8cdef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python支持向量机实验_Python SVM(支持向量机)实现方法完整示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>