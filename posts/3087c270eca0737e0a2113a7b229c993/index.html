<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ES7标准  fetch请求封装 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ES7标准  fetch请求封装" />
<meta property="og:description" content="原文地址：http://blog.csdn.net/BingHongChaZuoAn/article/details/52851980 作为一个程序猿，一定要养成一个爱学习的好习惯，因为程序员是一个终身学习的职业，要时刻把Live and learn作为一种信仰。I can’t change the world，only change myself。
闲话少说，言归正传，今天跟大家分享下我自己封装的延用ES7标准的 fetch请求，不好之处忘大家见谅。
首先是 Header model类型，配置文件 header.js。
let Header = { &#39;Accept&#39;: &#39;application/json&#39;, //json形式 &#39;Content-Type&#39;: &#39;application/json&#39; } module.exports = Header; netTools.js
export default { /*检查对象是否为空*/ isEmpty(obj){ for (var r in obj){return false;} return true; }, /*把String转化成对象*/ toObj(obj){ if(typeof obj === &#39;object&#39;){ return obj; }else{ return eval(&#39;(&#39;&#43;obj&#43;&#39;)&#39;); } }, /*判断对象是否为空*/ isNull(obj){ return (!obj &amp;&amp; typeof(obj)!=&#34;undefined&#34; &amp;&amp; obj!=0)?true:false; }, } NetUtil.js
&#39;use strict&#39;; import React, { Component} from &#39;react&#39;; var Header = require(&#39;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3087c270eca0737e0a2113a7b229c993/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-10-18T19:51:33+08:00" />
<meta property="article:modified_time" content="2016-10-18T19:51:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ES7标准  fetch请求封装</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>原文地址：<a href="http://blog.csdn.net/BingHongChaZuoAn/article/details/52851980">http://blog.csdn.net/BingHongChaZuoAn/article/details/52851980</a> <br> 作为一个程序猿，一定要养成一个爱学习的好习惯，因为程序员是一个终身学习的职业，要时刻把Live and learn作为一种信仰。I can’t change the world，only change myself。</p> 
<p>闲话少说，言归正传，今天跟大家分享下我自己封装的延用ES7标准的 fetch请求，不好之处忘大家见谅。</p> 
<p>首先是 Header model类型，配置文件 header.js。</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">let</span> <span class="hljs-keyword">Header</span> <span class="hljs-subst">=</span> {
  <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'application/json'</span>,
  <span class="hljs-comment">//json形式</span>
  <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
}

module<span class="hljs-built_in">.</span>exports <span class="hljs-subst">=</span> <span class="hljs-keyword">Header</span>;</code></pre> 
<p>netTools.js</p> 
<pre class="prettyprint"><code class=" hljs javascript">export <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">/*检查对象是否为空*/</span>
   isEmpty(obj){
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> r <span class="hljs-keyword">in</span> obj){<!-- --><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;}
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  },

  <span class="hljs-comment">/*把String转化成对象*/</span>
  toObj(obj){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span>){
        <span class="hljs-keyword">return</span> obj;
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">'('</span>+obj+<span class="hljs-string">')'</span>);
    }
  },

  <span class="hljs-comment">/*判断对象是否为空*/</span>
  isNull(obj){
    <span class="hljs-keyword">return</span> (!obj &amp;&amp; <span class="hljs-keyword">typeof</span>(obj)!=<span class="hljs-string">"undefined"</span> &amp;&amp; obj!=<span class="hljs-number">0</span>)?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;
  },

}</code></pre> 
<p>NetUtil.js</p> 
<pre class="prettyprint"><code class=" hljs scala"><span class="hljs-string">'use strict'</span>;

<span class="hljs-keyword">import</span> React, { Component} from <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">var</span> Header = require(<span class="hljs-string">'./header'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetUitl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> {<!-- --></span>

  constructor(props){
      <span class="hljs-keyword">super</span>(props);
      <span class="hljs-keyword">this</span>.state ={
        headers:Header,<span class="hljs-comment">//选中的位置</span>
      };

  }

  <span class="hljs-javadoc">/**
  *url :请求地址
  *data:参数(Json对象)
  *callback:回调函数
  */</span>
static async fetchAsync (hostUrl, methodUrl, method, data, callback) {

    let   fetchOptions;

    <span class="hljs-keyword">if</span>(method === <span class="hljs-string">'get'</span>){
      fetchOptions = {
        method: <span class="hljs-string">'GET'</span>,
        mode: <span class="hljs-string">"cors"</span>,
        headers: Header,
        credentials: <span class="hljs-string">'include'</span>,
      };
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(method === <span class="hljs-string">'post'</span>){
      fetchOptions = {
        method: <span class="hljs-string">'POST'</span>,
        mode: <span class="hljs-string">"cors"</span>,
        headers: Header,
        credentials: <span class="hljs-string">'include'</span>,
        body: JSON.stringify(data),
      };
    }

  <span class="hljs-comment">//  alert(JSON.stringify(fetchOptions));</span>
  let LOGIN_REQUEST= <span class="hljs-keyword">this</span>.transform(hostUrl,methodUrl,data);
  LOGIN_REQUEST = encodeURI(LOGIN_REQUEST);
<span class="hljs-comment">//由于我们的服务器有点问题，只支持url拼接参数的方式传值，所以只能这么写了</span>
  <span class="hljs-keyword">try</span> {
     let response = await fetch(LOGIN_REQUEST, fetchOptions);
     let responseJson = await response.json();
    <span class="hljs-comment">//  alert(JSON.stringify(responseJson));</span>
     callback(responseJson);
   } <span class="hljs-keyword">catch</span>(error) {
     console.error(error);
   }

  }

  static addHeaders(obj)
  {
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> r in obj){
      eval(<span class="hljs-string">"Header."</span>+r+<span class="hljs-string">"=obj."</span>+r);
      }
      <span class="hljs-keyword">return</span> Header;
  }

  static clearHeader(){
    Header={};
    <span class="hljs-keyword">return</span> Header;
  }

  static changeHeader(key,value)
  {
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> r in Header){
        <span class="hljs-keyword">if</span>(r==key){
          eval(<span class="hljs-string">"Header."</span>+key+<span class="hljs-string">"="</span>+JSON.stringify(value));
          <span class="hljs-keyword">return</span> Header;
        }
      }
      console.log(<span class="hljs-string">'not find header:'</span>+key);
  }

  static deleteHeader(key)
  {
    eval(<span class="hljs-string">"Header."</span>+key+<span class="hljs-string">"=undefined"</span>);
    <span class="hljs-keyword">return</span> Header;
  }

<span class="hljs-javadoc">/**
* 对象解析变换，目前只支持简单对象变换。
*/</span>
  static transform(hostUrl, methodUrl, obj){

    let responseUrl = hostUrl+ methodUrl+<span class="hljs-string">'?'</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key in obj){<!-- --><span class="hljs-comment">//用javascript的for/in循环遍历对象的属性</span>
      responseUrl += key+<span class="hljs-string">"="</span>+obj[key]+<span class="hljs-string">"&amp;"</span>;
    }
    <span class="hljs-comment">// alert(responseUrl);</span>
    let index = responseUrl.lastIndexOf(<span class="hljs-string">'&amp;'</span>);
    responseUrl = responseUrl.substring(<span class="hljs-number">0</span>,index);
    <span class="hljs-keyword">return</span> responseUrl;

  }


}

module.exports = NetUitl;```



</code></pre> 
<p>http.js</p> 
<pre class="prettyprint"><code class=" hljs actionscript">let NetUitl = require(<span class="hljs-string">'./NetUtil'</span>);
<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> Tools from './netTools';</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAction</span><span class="hljs-params">(<span class="hljs-rest_arg">...props</span>)</span> {<!-- --></span>
  <span class="hljs-keyword">this</span>.hostUrl = props.shift(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">this</span>.methodUrl = props.shift(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">this</span>.method = props.shift(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">this</span>.header = props.shift(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">this</span>.params = props.shift(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">this</span>.callback = props.shift(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// this.failureDo = props.shift(1);</span>
  <span class="hljs-comment">// this.finallyDo = props.shift(1);</span>

  <span class="hljs-comment">// alert(!Tools.isEmpty(this.header));</span>

  <span class="hljs-keyword">if</span>(!Tools.isEmpty(<span class="hljs-keyword">this</span>.header)){
    NetUitl.addHeaders(<span class="hljs-keyword">this</span>.header);
  }

  NetUitl.fetchAsync(<span class="hljs-keyword">this</span>.hostUrl, <span class="hljs-keyword">this</span>.methodUrl,<span class="hljs-keyword">this</span>.method, <span class="hljs-keyword">this</span>.params,
    (code, msg, data)=&gt;{<!-- --><span class="hljs-keyword">this</span>.callback(code, msg, data);},
    );
}
export <span class="hljs-keyword">default</span> {

  post(hostUrl,methodUrl, params,callback){
    fetchAction(hostUrl,methodUrl, <span class="hljs-string">'post'</span>,<span class="hljs-literal">null</span>, params,callback);
  },

  postWithHeader(hostUrl,methodUrl, headers, params,callback){
      fetchAction(hostUrl,methodUrl, <span class="hljs-string">'post'</span>, headers, params,callback);
  },

  <span class="hljs-keyword">get</span>(hostUrl,methodUrl, params,callback){
    fetchAction(hostUrl,methodUrl, <span class="hljs-string">'get'</span>, <span class="hljs-literal">null</span>, params,callback);
  },

  getWithHeader(hostUrl,methodUrl, headers, params,callback){
      fetchAction(hostUrl,methodUrl,<span class="hljs-string">'get'</span>, headers, params,callback);
  },

}</code></pre> 
<p>API.js</p> 
<pre class="prettyprint"><code class=" hljs cs">
onst HOSTURL= <span class="hljs-string">'http://xxxx'</span>;

import Http <span class="hljs-keyword">from</span> <span class="hljs-string">'./http'</span>;

export <span class="hljs-keyword">default</span> {

  getDetail(<span class="hljs-keyword">params</span>,callback) {
    <span class="hljs-keyword">let</span> methodUrl = <span class="hljs-string">'xxxx'</span>;
    <span class="hljs-keyword">let</span> header = {xxx:xxx};
     Http.post(HOSTURL,methodUrl, <span class="hljs-keyword">params</span>,callback);
     <span class="hljs-comment">//Http.post(HOSTURL,methodUrl, header ,params,callback);</span>
      <span class="hljs-comment">//Http.get(HOSTURL,methodUrl, params,callback);</span>
     <span class="hljs-comment">//Http.get(HOSTURL,methodUrl, header ,params,callback);</span>
  },
}

</code></pre> 
<p>上述已经封装完成。接下来，看看如何调用吧。</p> 
<pre class="prettyprint"><code class=" hljs coffeescript">
<span class="hljs-reserved">let</span> params={<!-- --><span class="hljs-string">'kw'</span>:<span class="hljs-string">'w'</span>};
     Api.getDetail<span class="hljs-function"><span class="hljs-params">(params,(response)=&gt;{
             alert(JSON.stringify(response));
         },
     )</span>;</span></code></pre> 
<p>“`</p> 
<p>以上基本完成了fetch请求的封装，包括动态添加、删除、修改header。允许携带cookie。之所以没有让fetch可以动态设置cookie，是因为fetch请求本身不太完善，需要做一些设置，git上有一套方案，不过好像用了他的，header就不能动态设置了，最近比较忙，也没时间深入研究，暂时就这样吧，以后深入研究下人家的东西，再慢慢优化。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fe86fee6ec4d69c798163d861f171289/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">golang实践-目录结构与工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7d1e617babba75a4ef85f86095f202c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Oracle11g Http请求报错 ORA-24247: 网络访问被访问控制列表 (ACL) 拒绝 ORA-29273:HTTP 请求失败</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>