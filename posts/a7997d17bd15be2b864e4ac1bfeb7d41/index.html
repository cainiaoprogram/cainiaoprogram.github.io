<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>22 C&#43;&#43; RTTI, dynamic_cast, typeid, type_info类，虚函数表 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="22 C&#43;&#43; RTTI, dynamic_cast, typeid, type_info类，虚函数表" />
<meta property="og:description" content="RTTI run time type identification 运行时类型识别
作用是：通过运行时类型识别，程序能够使用基类的指针或者引用来检查这些指针或者引用所指向的对象的时机派生类别。
提供了 dynamic_cast运算符 和 typeid 运算符 让user 来做这个事情
dynamic_cast运算符： 能够让父类指针安全的指向一个子类.如果转换不成功，会返回null
//如果dynamic_cast 处理的是引用。使用try catch处理，在对于引用 转换的时候失败的时候，会有std::bad_cast error
Child31 * child311 = dynamic_cast&lt;Child31 *&gt;(pa);
Child31 &amp; pa33 = dynamic_cast&lt;Child31 &amp;&gt;(pa22);
void main() { Parent3 *pa = new Child31(20,&#34;child31&#34;,89.9,40,&#34;parent3&#34;,80.9); Parent3 &amp; qa = *pa;//用父类的指针的* 得到父类的引用。但是实际上开发者是知道*pa指向的是一个child的。 //假设当前的需求就是我们使用子类自己的方法 -》 child31publiceat，应该怎么做呢？ //qa.child31publiceat();目前是不行的 //C语言的做法是强行转换 Child31 &amp; qchild31 = (Child31&amp;)*pa; qchild31.child31publiceat(); //执行结果为： //Parent3 构造方法被执行 //	Child31构造方法执行 //	Child31 自己的 public 方法执行 cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a7997d17bd15be2b864e4ac1bfeb7d41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T23:17:10+08:00" />
<meta property="article:modified_time" content="2023-12-28T23:17:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">22 C&#43;&#43; RTTI, dynamic_cast, typeid, type_info类，虚函数表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">RTTI</h2> 
<p>run time type identification 运行时类型识别</p> 
<p>作用是：通过运行时类型识别，程序能够使用基类的指针或者引用来检查这些指针或者引用所指向的对象的时机派生类别。</p> 
<p>提供了 dynamic_cast运算符 和 typeid 运算符 让user 来做这个事情</p> 
<p></p> 
<h2>dynamic_cast运算符：</h2> 
<p>能够让父类指针安全的指向一个子类.如果转换不成功，会返回null</p> 
<p>//如果dynamic_cast 处理的是引用。使用try catch处理，在对于引用 转换的时候失败的时候，会有std::bad_cast error</p> 
<p>Child31 * child311 = dynamic_cast&lt;Child31 *&gt;(pa);</p> 
<p>Child31 &amp; pa33 = dynamic_cast&lt;Child31 &amp;&gt;(pa22);</p> 
<pre><code class="hljs">void main() {
	Parent3 *pa = new Child31(20,"child31",89.9,40,"parent3",80.9);
	Parent3 &amp; qa = *pa;//用父类的指针的* 得到父类的引用。但是实际上开发者是知道*pa指向的是一个child的。
	//假设当前的需求就是我们使用子类自己的方法 -》 child31publiceat，应该怎么做呢？
	//qa.child31publiceat();目前是不行的
	//C语言的做法是强行转换
	Child31 &amp; qchild31 = (Child31&amp;)*pa;
	qchild31.child31publiceat();

	//执行结果为：
	//Parent3 构造方法被执行
	//	Child31构造方法执行
	//	Child31 自己的 public 方法执行


	cout &lt;&lt; "-------分割线-------" &lt;&lt; endl;
	//那么C语言风格的强行转换既然能处理这个问题，为什么C++还要发明一个呢？
	//这是因为这玩意不安全，我们想转啥就转啥，例如转成Teacher9，但是我们知道这玩意肯定不是Teacher9呀，一旦使用就会有不可预知的事情发生，甚至有可能是run time exception
	//Teacher9 &amp; qchild311111 = (Teacher9&amp;)*pa;//也能这么转，build pass
	//qchild311111.printTeacher9();//结果是这：address = 000002CC26026200 age = 691174864 name =
	//dynamic_cast 运算符，能够让父类指针或者父类引用安全的指向一个子类.如果转换不成功，会返回null
	Child31 * child311 = dynamic_cast&lt;Child31 *&gt;(pa);
	if (nullptr == child311 || NULL == child311) {
		cout &lt;&lt; "转换不成功" &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; "转换成功" &lt;&lt; endl;
		child311-&gt;child31publiceat();
	}

	//dynamic_cast的好处，如果转换不成功，则为 null
	Teacher9 * child4 = dynamic_cast&lt;Teacher9 *&gt;(pa);
	if (nullptr == child4 || NULL == child4) {
		cout &lt;&lt; "转换不成功..." &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; "转换成功..." &lt;&lt; endl;
		child311-&gt;child31publiceat();
	}



	//如果dynamic_cast 处理的是引用应该如何处理呢？使用try catch处理，在对于引用 转换的时候失败的时候，会有std::bad_cast error

	Parent3 *pa11 = new Child31(20, "child31", 89.9, 40, "parent3", 80.9);
	Parent3 &amp; pa22 = *pa11;

	try {
		cout &lt;&lt; "转换success 。。。。。" &lt;&lt; endl;
		Child31 &amp; pa33 = dynamic_cast&lt;Child31 &amp;&gt;(pa22);
		pa33.child31publiceat();
		
	}
	catch (std::bad_cast) {
		cout &lt;&lt; "转换失败.....bad_cast" &lt;&lt; endl;
	}</code></pre> 
<p></p> 
<h2 style="background-color:transparent;">typeid 运算符：</h2> 
<p>返回指针或者引用所指向对象的实际类型。</p> 
<p></p> 
<pre><code class="hljs">cout &lt;&lt; "----------" &lt;&lt; endl;

	Parent3* pa66 = new Child31(20, "child31", 89.9, 40, "parent3", 80.9);
	//Parent3*是类型，pa66是变量名，因此typeid(pa66).name()是
	cout &lt;&lt; typeid(pa66).name() &lt;&lt; endl; //注意这里结果：Parent3 * __ptr64

	// *pa66 是将pa66指针指向的 那部分取出来，通过typeid求，那当然是 child31了
	cout&lt;&lt;typeid(*pa66).name()&lt;&lt;endl; //注意这里结果：class Child31


	cout &lt;&lt; "-----111-----" &lt;&lt; endl;
	//typeid的返回值是： type_info的一个常量引用
	const type_info &amp;a = typeid(*pa66);


	cout &lt;&lt; "-----222-----" &lt;&lt; endl;
	//typeid运算符的用法如下：
	Parent3* pa77 = new Child31(120, "child31", 189.9, 140, "parent3", 8220.9);
	Parent3* pa88 = new Child32(220, "child32", 289.9, 420, "parent3", 8110.9);

	if (typeid(*pa66) == typeid(*pa77)) {
		cout &lt;&lt; "typeid(*pa66) == typeid(*pa77)" &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; "typeid(*pa66) != typeid(*pa77)" &lt;&lt; endl;
	}

	if (typeid(*pa88) == typeid(*pa77)) {
		cout &lt;&lt; "typeid(*pa88) == typeid(*pa77)" &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; "typeid(*pa88) != typeid(*pa77)" &lt;&lt; endl;
	}

	if (typeid(*pa88) == typeid(Child32)) {
		cout &lt;&lt; "typeid(*pa88) == typeid(Child32)" &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; "typeid(*pa88) != typeid(Child32)" &lt;&lt; endl;
	}
</code></pre> 
<p></p> 
<h2>如上两个运算符要能得到正确的值--需要父类和子类之间有虚函数</h2> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2>虚函数表。</h2> 
<p>只要类有虚函数存在，编译器就会对该类产生一个虚函数表。</p> 
<p>这个虚函数表中的第一项，指向的是这个类所关联的 type_info对象。</p> 
<p>虚函数表的其他项，都对应一个虚函数。</p> 
<p>当我们使用</p> 
<p>Parent *pa = new Son;</p> 
<p>的时候，pa对象有一个隐藏指针，指向son里面的虚函数表。</p> 
<p></p> 
<p>那么 就很好理解了，pa 这个隐藏指针----&gt;指向son 的虚函数表，</p> 
<p>该函数表 的第一项就指向 son</p> 
<p>其他项都指向 虚函数。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3719ae406d8ceb891925b00fe5ae1020/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Obsidian 快捷方式总结 ——提升你的工作效率</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99e98c85230cf88b38d890cab69c4519/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第 374 场周赛 解题报告 | 珂学家 | 拆位前缀和优化&#43;分组滑窗&#43;组合数学</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>