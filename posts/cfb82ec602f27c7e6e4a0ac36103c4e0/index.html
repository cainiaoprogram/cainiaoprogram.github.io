<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之顺序表 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构之顺序表" />
<meta property="og:description" content="目录
1.线性表
2.顺序表
2.1概念及结构
1. 静态顺序表：使用定长数组存储元素。
2. 动态顺序表：使用动态开辟的数组存储。
2.2接口实现
销毁顺序表
打印顺序表
增加数据
头插
尾插
指定下标位置插入
删除数据
头删
尾删
指定下标位置删除
查找数据
修改数据
1.线性表 线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使 用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串... 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储。 2.顺序表 2.1概念及结构 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存 储。在数组上完成数据的增删查改。 顺序表一般可以分为： 1. 静态顺序表：使用定长数组存储元素。 2. 动态顺序表：使用动态开辟的数组存储。 实用动态内存开辟函数去开辟空间的时候，每次空间不够的时候都会扩容，每次扩容都会付出一定程度上的代价。所以每次扩容可以稍微多扩容一点点，减少扩容的频率。扩容是根据需求扩容，那我们最常用的扩容倍数就是：2倍 1.5倍。但是不是一定要求是这些倍数。2倍数是一个相对合适的量，扩容的频率会越来越低，具体情况具体分析！ 2.2接口实现 静态顺序表只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致N定大了，空 间开多了浪费，开少了不够用。所以现实中基本都是使用动态顺序表，根据需要动态的分配空间 大小，所以下面我们实现动态顺序表。 第一步：初始化顺序表 typedef int SLDataType;//本篇博客以存放整型数据为例 typedef struct SeqList { SLDataType* a;//声明了一个指向顺序表的指针，姑且称它为“顺序表指针” int size;//记录当前顺序表内元素个数 int capacity;//记录当前顺序表的最大容量 }SeqList; 接着开始初始化
//初始化顺序表 void SeqListInit(SeqList* ps) { assert(ps); ps-&gt;a = NULL;//刚开始时顺序表为空，顺序表指针为NULL ps-&gt;size = 0;//起始时元素个数为0 ps-&gt;capacity = 0;//容量为0 } 销毁顺序表 因为顺序表所用的内存空间是动态开辟在堆区的，所以我们在使用完后需要及时对其进行释放，避免造成内存泄漏。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cfb82ec602f27c7e6e4a0ac36103c4e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-17T20:36:47+08:00" />
<meta property="article:modified_time" content="2023-12-17T20:36:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之顺序表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:40px;"> </p> 
<p style="margin-left:40px;"><a href="#1.%E7%BA%BF%E6%80%A7%E8%A1%A8" rel="nofollow">1.线性表</a></p> 
<p style="margin-left:40px;"><a href="#2.%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">2.顺序表</a></p> 
<p style="margin-left:80px;"><a href="#2.1%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">2.1概念及结构</a></p> 
<p style="margin-left:80px;"><a href="#1.%20%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E3%80%82" rel="nofollow">1. 静态顺序表：使用定长数组存储元素。</a></p> 
<p style="margin-left:80px;"><a href="#2.%20%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%9A%84%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E3%80%82" rel="nofollow">2. 动态顺序表：使用动态开辟的数组存储。</a></p> 
<p style="margin-left:80px;"><a href="#2.2%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0" rel="nofollow">2.2接口实现</a></p> 
<p style="margin-left:80px;"><a href="#%E9%94%80%E6%AF%81%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">销毁顺序表</a></p> 
<p style="margin-left:80px;"><a href="#%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">打印顺序表</a></p> 
<p style="margin-left:80px;"><a href="#%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE" rel="nofollow">增加数据</a></p> 
<p style="margin-left:120px;"><a href="#%E5%A4%B4%E6%8F%92" rel="nofollow">头插</a></p> 
<p style="margin-left:120px;"><a href="#%E5%B0%BE%E6%8F%92" rel="nofollow">尾插</a></p> 
<p style="margin-left:80px;"><a href="#%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5" rel="nofollow">指定下标位置插入</a></p> 
<p style="margin-left:80px;"><a href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE" rel="nofollow">删除数据</a></p> 
<p style="margin-left:120px;"><a href="#%E5%A4%B4%E5%88%A0" rel="nofollow">头删</a></p> 
<p style="margin-left:120px;"><a href="#%E5%B0%BE%E5%88%A0" rel="nofollow">尾删</a></p> 
<p style="margin-left:80px;"><a href="#%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4" rel="nofollow">指定下标位置删除</a></p> 
<p style="margin-left:80px;"><a href="#%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE" rel="nofollow">查找数据</a></p> 
<p style="margin-left:80px;"><a href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE" rel="nofollow">修改数据</a></p> 
<hr> 
<p> </p> 
<h3><strong>1.</strong><strong>线性表</strong></h3> 
<div> 
 <div> 
  <strong>线性表（<em>linear list</em>）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使 </strong> 
 </div> 
 <div> 
  <strong>用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串... </strong> 
 </div> 
 <div> 
  <strong>线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的， </strong> 
 </div> 
 <div> 
  <strong>线性表在物理上存储时，通常以数组和链式结构的形式存储。</strong> 
 </div> 
 <div>
     
 </div> 
 <h3>2.顺序表</h3> 
 <h4>2.1<strong>概念及结构 </strong></h4> 
 <div> 
  <div>
      
   <strong>顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存 </strong> 
  </div> 
  <div> 
   <strong>储。在数组上完成数据的增删查改。</strong>   
  </div> 
  <div>
    顺序表一般可以分为： 
  </div> 
  <h4>1. <strong>静态顺序表：使用定长数组存储元素</strong>。</h4> 
  <div> 
   <img src="https://images2.imgbox.com/28/96/vQ6gXz7c_o.png" alt="af4406e8633146d0981a20932cb3a8fb.png"> 
  </div> 
  <div>
      
  </div> 
  <div>
      
  </div> 
  <div> 
   <h4>2. <strong>动态顺序表：使用动态开辟的数组存储。</strong></h4> 
   <div> 
    <strong>实用动态内存开辟函数去开辟空间的时候，每次空间不够的时候都会扩容，每次扩容都会付出一定程度上的代价。所以每次扩容可以稍微多扩容一点点，减少扩容的频率。扩容是根据需求扩容，那我们最常用的扩容倍数就是：2倍 1.5倍。但是不是一定要求是这些倍数。2倍数是一个相对合适的量，扩容的频率会越来越低，具体情况具体分析！</strong> 
    <br>   
   </div> 
   <div> 
    <img src="https://images2.imgbox.com/ec/c2/DaChPwTF_o.png" alt="64309de5125d431a955f94cea5a55049.png"> 
   </div> 
   <div>
       
   </div> 
   <h4>2.2接口实现</h4> 
   <div> 
    <div>
      静态顺序表只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致N定大了，空 
    </div> 
    <div>
      间开多了浪费，开少了不够用。所以现实中基本都是使用动态顺序表，根据需要动态的分配空间 
    </div> 
    <div>
      大小，所以下面我们实现动态顺序表。 
    </div> 
    <div>
      第一步：初始化顺序表 
    </div> 
    <div> 
     <pre><code>typedef int SLDataType;//本篇博客以存放整型数据为例

typedef struct SeqList
{
	SLDataType* a;//声明了一个指向顺序表的指针，姑且称它为“顺序表指针”
	int size;//记录当前顺序表内元素个数
	int capacity;//记录当前顺序表的最大容量
}SeqList;
</code></pre> 
     <p>接着开始初始化</p> 
     <pre><code>//初始化顺序表
void SeqListInit(SeqList* ps)
{
	assert(ps);
	ps-&gt;a = NULL;//刚开始时顺序表为空，顺序表指针为NULL
	ps-&gt;size = 0;//起始时元素个数为0
	ps-&gt;capacity = 0;//容量为0
}
</code></pre> 
     <h4>销毁顺序表</h4> 
     <p>因为顺序表所用的内存空间是动态开辟在堆区的，所以我们在使用完后需要及时对其进行释放，<strong>避免造成内存泄漏</strong>。</p> 
     <pre><code>//销毁顺序表
void SeqListDestory(SeqList* ps)
{
	assert(ps);
	free(ps-&gt;a);//释放顺序表指针指向的空间
	ps-&gt;a = NULL;//及时置空
	ps-&gt;size = 0;//元素个数置0
	ps-&gt;capacity = 0;//容量置0
}
</code></pre> 
     <h4>打印顺序表</h4> 
     <p>循环打印size个元素即可</p> 
     <pre><code>//打印顺序表
void SeqListPrint(SeqList* ps)
{
	assert(ps);
	int i = 0;
	//循环打印顺序表指针指向的数据
	for (i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;a[i]);
	}
	printf("\n");
}
</code></pre> 
     <h4>增加数据</h4> 
     <p>仔细想想，我们每次需要增加数据的时候，首先都应该<strong>先检查顺序表内元素个数是否已达顺序表容量上限</strong>。若已达上限，那么我们就需要先对顺序表进行扩容，然后才能增加数据。</p> 
     <pre><code>//检查顺序表容量是否已满，若已满，则增容
void SeqCheckCapacity(SeqList* ps)
{
	if (ps-&gt;size == ps-&gt;capacity)//满了，需要增容
	{
		//判断顺序表容量是否为0，若为0，则先开辟用于存放4个元素的空间大小，若不为0，则扩容为原来容量的两倍
		int newcapacity = ps-&gt;capacity == 0 ? 4 : 2 * ps-&gt;capacity;
		SLDataType* newA = realloc(ps-&gt;a, newcapacity*sizeof(SLDataType));
		if (newA == NULL)
		{
			printf("realloc fail\n");
			exit(-1);
		}
		ps-&gt;a = newA;//开辟成功，将顺序表指针更新
		ps-&gt;capacity = newcapacity;//容量更新
	}
}
</code></pre> 
     <p><strong>若传入realloc的指针为空指针(NULL)，则realloc函数的作用相当于malloc函数，这样也不会对新开辟的空间进行初始化</strong></p> 
     <p>头插</p> 
     <p>要想在顺序表的表头插入数据，那么就需要先将顺序表原有的数据从后往前依次向后挪动一位，最后再将数据插入表头。</p> 
     <pre><code>//头插
void SeqListPushFront(SeqList* ps, SLDataType x)
{
	assert(ps);
	SeqCheckCapacity(ps);//检查容量
	int i = 0;
	for (i = ps-&gt;size; i &gt; 0; i--)//将数据从后往前依次向后挪
	{
		ps-&gt;a[i] = ps-&gt;a[i - 1];
	}
	ps-&gt;a[0] = x;
	ps-&gt;size++;//顺序表元素个数加一
}
</code></pre> 
     <p><strong>挪动数据的时候应从后向前依次挪动，若从前向后挪动，会导致后一个数据被覆盖。</strong></p> 
     <p>尾插</p> 
     <p>尾插相对于头插就比较简单了，直接在表尾插入数据即可</p> 
     <pre><code>//尾插
void SeqListPushBack(SeqList* ps, SLDataType x)
{
	assert(ps);
	SeqCheckCapacity(ps);//检查容量
	ps-&gt;a[ps-&gt;size] = x;
	ps-&gt;size++;//顺序表元素个数加一
}
</code></pre> 
     <h4>指定下标位置插入</h4> 
     <p>要做到在指定下标位置插入数据，首先我们需要得到一个下标位置，然后从该下标位置开始（包括该位置），其后的数据从后往前依次向后挪动一位，最后将数据插入到该下标位置。</p> 
     <pre><code>//指定下标位置插入
void SeqListInsert(SeqList* ps, int pos, SLDataType x)
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);//检查输入下标的合法性
	SeqCheckCapacity(ps);//检查容量
	int i = 0;
	for (i = ps-&gt;size; i &gt; pos; i--)//从pos下标位置开始，其后的数据从后往前依次向后挪
	{
		ps-&gt;a[i] = ps-&gt;a[i - 1];
	}
	ps-&gt;a[pos] = x;
	ps-&gt;size++;//顺序表元素个数加一
}
</code></pre> 
     <p>观察到，头插和尾插实际就是再下标为0和下标为size的地方进行插入，意味着我们可以统一使用该函数来实现</p> 
     <pre><code>//头插
void SeqListPushFront(SeqList* ps, SLDataType x)
{
	SeqListInsert(ps, 0, x);//在下标为0的位置插入数据
}
//尾插
void SeqListPushBack(SeqList* ps, SLDataType x)
{
	SeqListInsert(ps, ps-&gt;size, x);//在下标为ps-&gt;size的位置插入数据
}
</code></pre> 
     <h4>删除数据</h4> 
     <p>删除数据，其实可以理解为：<strong>从某个位置开始，数据依次向前覆盖</strong>。这样一来，该位置的数据就相当于删除了</p> 
     <p>头删</p> 
     <p>要删除表头的数据，我们可以从下标为1的位置开始，依次将数据向前覆盖即可。</p> 
     <pre><code>//头删
void SeqListPopFront(SeqList* ps)
{
	assert(ps);
	assert(ps-&gt;size &gt; 0);//保证顺序表不为空
	int i = 0;
	for (i = 0; i &lt; ps-&gt;size - 1; i++)//将数据从前往后依次向前覆盖
	{
		ps-&gt;a[i] = ps-&gt;a[i + 1];
	}
	ps-&gt;size--;//顺序表元素个数减一
}
</code></pre> 
     <p><strong>注意：数据覆盖的时候应从前向后依次覆盖，若从后向前覆盖，会导致前一个数据被覆盖。</strong></p> 
     <p>尾删</p> 
     <p>尾删就更简单了，直接将顺序表的元素个数减一即可</p> 
     <pre><code>//尾删
void SeqListPopBack(SeqList* ps)
{
	assert(ps);
	assert(ps-&gt;size &gt; 0);//保证顺序表不为空
	ps-&gt;size--;//顺序表元素个数减一
}
</code></pre> 
     <h4>指定下标位置删除</h4> 
     <p>要删除指定下标位置的数据，我们只需要从下标位置开始，其后的数据从前向后依次覆盖即可。</p> 
     <pre><code>//指定下标位置删除
void SeqListErase(SeqList* ps, int pos)
{
	assert(ps);
	assert(ps-&gt;size &gt; 0);//保证顺序表不为空
	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);
	int i = 0;
	for (i = pos; i &lt; ps-&gt;size - 1; i++)//从pos下标位置开始，其后的数据从前往后依次向前覆盖
	{
		ps-&gt;a[i] = ps-&gt;a[i + 1];
	}
	ps-&gt;size--;//顺序表元素个数减一
}
</code></pre> 
     <p>同样的道理，头删和尾删实际上也就是删除下标为0的位置和下标为ps-&gt;size - 1的位置的数据，也就意味着我们可以统一使用该函数来实现头删和尾删。</p> 
     <pre><code>//头删
void SeqListPopFront(SeqList* ps)
{
	SeqListErase(ps, 0);//删除下标为0的位置的数据
}
//尾删
void SeqListPopBack(SeqList* ps)
{
	SeqListErase(ps, ps-&gt;size - 1);//删除下标为ps-&gt;size - 1的位置的数据
}
</code></pre> 
     <h4>查找数据</h4> 
     <p>查找数据也相对简单，直接遍历一次顺序表即可，若找到了目标数据，则停止遍历，并返回该数据的下标，否则返回-1。</p> 
     <pre><code>//查找元素，若有，返回下标，否则返回-1
int SeqListFind(SeqList* ps, SLDataType x)
{
	assert(ps);
	int i = 0;
	for (i = 0; i &lt; ps-&gt;size; i++)//遍历顺序表进行查找
	{
		if (ps-&gt;a[i] == x)
			return i;//找到该数据，返回下标
	}
	return -1;//未找到，返回-1
}
</code></pre> 
     <h4>修改数据</h4> 
     <p>修改数据，就直接对该位置的数据进行再次赋值即可。</p> 
     <pre><code>//修改指定下标位置元素
void SeqListModify(SeqList* ps, int pos, SLDataType x)
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);//检查输入下标的合法性
	ps-&gt;a[pos] = x;//修改数据
}
</code></pre> 
     <p> </p> 
     <p> </p> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ab6c8f7a8eff8b6c6187a12c6b2f483/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">租用GPU进行YOLOV5训练</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/013d5fc8e2b9329375e42432ba4b722f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ansible-playbook编译.yml脚本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>