<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;实现集群聊天服务器 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;实现集群聊天服务器" />
<meta property="og:description" content="C&#43;&#43;实现集群聊天服务器 JSON Json是一种轻量级的数据交换模式（也叫做数据序列化方式）。Json采用完全独立于编程语言的文本格式来存储和表示数据。见解和清晰的层次结构使得Json称为理想的数据交换语言。易于阅读和编写。同时也易于支持机器解析和生成，有效地提升网络传出效率。
这里讲的网络传输，就涉及到序列化和反序列化。以客户端和服务器端通信为例，一般情况下，客户端给服务器端发送信息，发送的信息可能是字符串、整型等信息，需要先转化为字节流数据，这就是序列化；同样，服务器接收到客户端发来的字节流信息，需要转化成原始的数据格式，这就是反序列化。
JSON for Modern C&#43;&#43;是一个C&#43;&#43;下的JSON库，具有以下特点：直观的语法、仅需使用头文件json.hpp依赖、C&#43;&#43;11标准编写、类似于STL使用json、STL和json可以互相转化、严谨的测试（所有类都经过严格的单元测试）。
数据序列化 在网络中，常见的数据传输序列化格式有XML、Json、ProtoBuf，其中ProtoBuf最为常用，其数据压缩编码传输占用带宽小，同样的数据信息，是Json的1/10，XML的1/20，但是使用起来稍微比Json复杂。
Json使用 头文件引入和重命名#include&#34;json.hpp&#34; using json = nlohmann::json;。然后就可以是使用json类似于对象的使用方法使用json了。
#include&#34;json.hpp&#34; using json = nlohmann::json; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; void func1() { json js; js[&#34;from&#34;] = &#34;zhangsan&#34;; js[&#34;message_type&#34;] = 2; js[&#34;to&#34;] = &#34;lisi&#34;; js[&#34;message&#34;] = &#34;Hi, what are you doing?&#34;; cout &lt;&lt; js &lt;&lt; endl; string str=js.dump();//序列化，转化成字符串格式 cout&lt;&lt;str.c_str()&lt;&lt;endl; // 模拟从网络接收到json字符串，通过json::parse函数把json字符串字节流转化为json对象 json js2 = json::parse(temp); cout &lt;&lt; js2 &lt;&lt; endl; } void func2() { json js; js[&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4c31ecb1b5afedde707dbffe552e62b6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-01T09:54:23+08:00" />
<meta property="article:modified_time" content="2023-10-01T09:54:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;实现集群聊天服务器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="C_0"></a>C++实现集群聊天服务器</h2> 
<h3><a id="JSON_1"></a>JSON</h3> 
<p>Json是一种轻量级的数据交换模式（也叫做数据序列化方式）。Json采用完全独立于编程语言的文本格式来存储和表示数据。见解和清晰的层次结构使得Json称为理想的数据交换语言。易于阅读和编写。同时也易于支持机器解析和生成，有效地提升网络传出效率。</p> 
<p>这里讲的网络传输，就涉及到<strong>序列化和反序列化</strong>。以客户端和服务器端通信为例，一般情况下，客户端给服务器端发送信息，发送的信息可能是字符串、整型等信息，需要先转化为字节流数据，这就是序列化；同样，服务器接收到客户端发来的字节流信息，需要转化成原始的数据格式，这就是反序列化。</p> 
<p>JSON for Modern C++是一个C++下的JSON库，具有以下特点：直观的语法、仅需使用头文件<code>json.hpp</code>依赖、C++11标准编写、类似于STL使用json、STL和json可以互相转化、严谨的测试（所有类都经过严格的单元测试）。</p> 
<h4><a id="_8"></a>数据序列化</h4> 
<p>在网络中，常见的数据传输序列化格式有XML、Json、ProtoBuf，其中ProtoBuf最为常用，其数据压缩编码传输占用带宽小，同样的数据信息，是Json的1/10，XML的1/20，但是使用起来稍微比Json复杂。</p> 
<h4><a id="Json_11"></a>Json使用</h4> 
<p>头文件引入和重命名<code>#include"json.hpp" using json = nlohmann::json;</code>。然后就可以是使用json类似于对象的使用方法使用json了。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"json.hpp"</span></span>
<span class="token keyword">using</span> json <span class="token operator">=</span> nlohmann<span class="token double-colon punctuation">::</span>json<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    json js<span class="token punctuation">;</span>
    js<span class="token punctuation">[</span><span class="token string">"from"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"zhangsan"</span><span class="token punctuation">;</span>
    js<span class="token punctuation">[</span><span class="token string">"message_type"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    js<span class="token punctuation">[</span><span class="token string">"to"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"lisi"</span><span class="token punctuation">;</span>
    js<span class="token punctuation">[</span><span class="token string">"message"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hi, what are you doing?"</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> js <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	string str<span class="token operator">=</span>js<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//序列化，转化成字符串格式</span>
	cout<span class="token operator">&lt;&lt;</span>str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// 模拟从网络接收到json字符串，通过json::parse函数把json字符串字节流转化为json对象</span>
    json js2 <span class="token operator">=</span> json<span class="token double-colon punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> js2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    json js<span class="token punctuation">;</span>
    js<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    js<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"zhang san"</span><span class="token punctuation">;</span>
    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"zhang san"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"liu shuo"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello china"</span><span class="token punctuation">;</span>
    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span><span class="token string">"zhang san"</span><span class="token punctuation">,</span> <span class="token string">"hello world"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token string">"liu shuo"</span><span class="token punctuation">,</span> <span class="token string">"hello china"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> js <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>key采用哈希表，是无顺序的结构。</p> 
<p>json的序列化——<code>json_obj.dump()</code>。json反序列化——<code>json::parse(json_str)</code>。</p> 
<h3><a id="cmake_56"></a>cmake常规使用</h3> 
<p>首先给出一个代码样例，通过代码样例基本上可以看懂一些常用的cmake命令：</p> 
<pre><code class="prism language-sh">cmake_minimum_required<span class="token punctuation">(</span>VERSION <span class="token number">3.0</span><span class="token punctuation">)</span> <span class="token comment">#CMake最小版本</span>

project<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token comment">#定义当前工程的名字</span>

<span class="token comment"># set表示创建一个变量，并初始化对应的值</span>
set<span class="token punctuation">(</span>CMAKE_CXX_FLAGS <span class="token variable">${CMAKE_CXX_FLAGS}</span> -g<span class="token punctuation">)</span> <span class="token comment">#配置编译选项</span>

<span class="token comment"># include_directories()#头文件搜索目录</span>

<span class="token comment"># link_directories() #库文件搜索目录</span>

<span class="token comment"># 设置需要编译的源文件列表，其实也就是定义一个SRC_LIST变量名</span>
set<span class="token punctuation">(</span>SRC_LIST ./muduo_server.cpp<span class="token punctuation">)</span>

<span class="token comment"># 设置可执行文件最终存储的目录</span>
set<span class="token punctuation">(</span>EXECUTABLE_OUTPUT_PATH <span class="token variable">${PROJECT_SOURCE_DIR}</span>/bin<span class="token punctuation">)</span>


<span class="token comment"># 把指定目录下的所有源文件名字放入变量名SRC_LIST里面</span>
<span class="token comment"># aux_source_directory(./ SRC_LIST)</span>

<span class="token comment"># 表示生成可执行文件server，由SRC_LIST变量所定义的源文件编译而来</span>
add_executable<span class="token punctuation">(</span>server <span class="token variable">${SRC_LIST}</span><span class="token punctuation">)</span>

<span class="token comment"># 表示这个server目标程序，需要连接 muduo_net muduo_base pthread 等库文件</span>
target_link_libraries<span class="token punctuation">(</span>server muduo_net muduo_base pthread<span class="token punctuation">)</span>
</code></pre> 
<p>一般C++开源项目标准目录结构如下图所示：<br> <img src="https://images2.imgbox.com/69/32/PF57EWNI_o.png" alt=" "><br> 一般在build目录下进行<code>cmake ..</code>进行编译，然后会在build目录下生成编译过程中的中间文件，其中会存在一个<code>Makefile</code>文件，在执行<code>make</code>命令来生成最终的可执行文件。</p> 
<p><code>PROJECT_NAME</code> : 通过 project() 指定项目名称<br> <code>PROJECT_SOURCE_DIR</code> : 工程的根目录<br> <code>PROJECT_BINARY_DIR</code> : 执行 cmake 命令的目录<br> <code>CMAKE_CURRENT_SOURCE_DIR</code> : 当前 CMakeList.txt 文件所在的目录<br> <code>CMAKE_CURRENT_BINARY_DIR</code> : 编译目录，可使用 add subdirectory 来修改<br> <code>EXECUTABLE_OUTPUT_PATH</code> : 二进制可执行文件输出位置<br> <code>LIBRARY_OUTPUT_PATH</code> : 库文件输出位置<br> <code>BUILD_SHARED_LIBS</code> : 默认的库编译方式 ( shared 或 static ) ，默认为 static<br> <code>CMAKE_C_FLAGS</code> : 设置 C 编译选项<br> <code>CMAKE_CXX_FLAGS</code> : 设置 C++ 编译选项<br> <code>CMAKE_CXX_FLAGS_DEBUG</code> : 设置编译类型 Debug 时的编译选项<br> <code>CMAKE_CXX_FLAGS_RELEASE</code> : 设置编译类型 Release 时的编译选项<br> <code>CMAKE_GENERATOR</code> : 编译器名称<br> <code>CMAKE_COMMAND</code> : CMake 可执行文件本身的全路径<br> <code>CMAKE_BUILD_TYPE</code> : 工程编译生成的版本， Debug / Release</p> 
<h3><a id="Muduo_106"></a>Muduo</h3> 
<p>muduo网络库给用户提供了两个主要的类：</p> 
<ol><li>TcpServer：用于编写服务器程序的</li><li>TcpClient：用于编写客户端程序的</li></ol> 
<p>epoll+线程池：<br> 优点：<strong>能够把网络I/O的代码和业务代码区分开、用户的断开和连接，用户可读写事件</strong></p> 
<h4><a id="Muduo_115"></a>Muduo服务端</h4> 
<p>下面提供了muduo进行服务器I/O和worker线程分离的代码示例：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;muduo/net/TcpServer.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;muduo/net/EventLoop.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> muduo<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> muduo<span class="token double-colon punctuation">::</span>net<span class="token punctuation">;</span>

<span class="token comment">// 通用模板</span>
<span class="token keyword">class</span> <span class="token class-name">ChatServer</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">ChatServer</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span>
               <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>listenAddr<span class="token punctuation">,</span>
               <span class="token keyword">const</span> string <span class="token operator">&amp;</span>nameArg<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_tcpserver</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> listenAddr<span class="token punctuation">,</span> nameArg<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_loop</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 给服务器注册用户连接的创建和断开的回调</span>
        _tcpserver<span class="token punctuation">.</span><span class="token function">setConnectionCallback</span><span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ChatServer<span class="token double-colon punctuation">::</span>onConnection<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 给服务器注册用户读写事件回调</span>
        _tcpserver<span class="token punctuation">.</span><span class="token function">setMessageCallback</span><span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ChatServer<span class="token double-colon punctuation">::</span>onMessage<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 设置服务器线程数量，1个I/O线程，3个worker线程</span>
        _tcpserver<span class="token punctuation">.</span><span class="token function">setThreadNum</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//开启事件循环</span>
    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _tcpserver<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">// 专门处理用户的连接创建和断开  epoll、listenfd、accept</span>
    <span class="token keyword">void</span> <span class="token function">onConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>conn<span class="token operator">-&gt;</span><span class="token function">connected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            cout <span class="token operator">&lt;&lt;</span> conn<span class="token operator">-&gt;</span><span class="token function">peerAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" -&gt; "</span> <span class="token operator">&lt;&lt;</span> conn<span class="token operator">-&gt;</span><span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" state online;"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            cout <span class="token operator">&lt;&lt;</span> conn<span class="token operator">-&gt;</span><span class="token function">peerAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" -&gt; "</span> <span class="token operator">&lt;&lt;</span> conn<span class="token operator">-&gt;</span><span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" state offline;"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            conn<span class="token operator">-&gt;</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭连接</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 专门处理用户的读写事件</span>
    <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">,</span> <span class="token comment">// 连接</span>
                   Buffer <span class="token operator">*</span>buffer<span class="token punctuation">,</span>                 <span class="token comment">// 缓冲区</span>
                   Timestamp time<span class="token punctuation">)</span>               <span class="token comment">// 接收到信息的时间信息</span>
    <span class="token punctuation">{<!-- --></span>
        string buf <span class="token operator">=</span> buffer<span class="token operator">-&gt;</span><span class="token function">retrieveAllAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"recv data: "</span> <span class="token operator">&lt;&lt;</span> buf <span class="token operator">&lt;&lt;</span> <span class="token string">" time: "</span> <span class="token operator">&lt;&lt;</span> time<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        conn<span class="token operator">-&gt;</span><span class="token function">send</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    TcpServer _tcpserver<span class="token punctuation">;</span>
    EventLoop <span class="token operator">*</span>_loop<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    EventLoop loop<span class="token punctuation">;</span>
    InetAddress <span class="token function">addr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//本机地址</span>
    ChatServer <span class="token function">server</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token punctuation">,</span>addr<span class="token punctuation">,</span><span class="token string">"ChatServer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将listenfd通过epoll_ctl -&gt;(传递给) epoll</span>
    server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//按照epoll_wait以阻塞方式等待新用户连接，已连接用户的读写事件等</span>
    loop<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译命令：</p> 
<pre><code class="prism language-sh">server:muduo_server.cpp
	g++ $+ <span class="token parameter variable">-o</span> <span class="token variable">$@</span> <span class="token parameter variable">-lmuduo_net</span> <span class="token parameter variable">-lmuduo_base</span> <span class="token parameter variable">-lpthread</span> <span class="token parameter variable">-std</span><span class="token operator">=</span>c++11
</code></pre> 
<p><code>$+</code> ：表示依赖项，这里表示muduo_server.cpp 。<code>$@</code>：表示目标项，这里表示server。</p> 
<p><strong>基于muduo网络库开发服务器程序</strong>，大概步骤如下：<br> 1、组合TcpServer对象<br> 2、创建EventLoop事件循环对象的指针<br> 3、明确TcpServer构造函数需要什么参数（TcpServer无默认构造函数），输出ChatServer构造函数<br> 4、在当前服务器的构造函数中，注册处理连接的回调函数和处理事件的连接函数<br> 5、设置合适的服务器端线程数量，muduo会自己分配I/O线程和worker线程（一般设置1个I/O，n-1个worker线程）</p> 
<h4><a id="_202"></a>负载均衡器</h4> 
<p>一台服务器在32位Linx系统环境下，大致的并发量sockfd大约是1024个，大约支持20000个人进行同时聊天。使用<code>ulimit -n</code>命令查看系统允许当前用户进程打开的文件数限制，一般情况下每个进程最多允许打开1024个文件，还需要去除给当前用户进程必然打开的标准输入、标准输出、标准错误、服务器监听、进程通信等文件，剩下可以给客户端socket连接的文件数大概只有1014个左右，也就是说，基于Linux的通信程序最多运行同时1024个TCP并发连接。<a href="https://zhuanlan.zhihu.com/p/165554130" rel="nofollow">Linux下高并发socket最大连接数所受的各种限制</a>点击查看更多。</p> 
<p>在实际环境中可能会存在多个服务器同时在后台运行，当开始通信时，需要选定聊天的服务器。</p> 
<p><img src="https://images2.imgbox.com/b0/b6/gOPexI1U_o.png" alt=" "><br> LVS：负载均衡器常使用的设备。</p> 
<p>nginx负载均衡器：相当于把服务器串联起来，在用户连接服务器后，ngnix负载均衡器将对client分配服务器，如果一台服务器时支持2W用户的连接，那么三台服务器就支持6W用户的连接。</p> 
<p>聊天服务器属于长连接的业务。</p> 
<p>redis是<strong>基于发布-订阅模式</strong>，类似于设计模式的<strong>观察者模式</strong>。</p> 
<h4><a id="nginx_218"></a>nginx安装</h4> 
<p>nginx在1.9版本之前只支持HTTP协议的web服务器的负载均衡，之后的版本开始支持TCP长连接的负载均衡。但是，nginx默认情况下没有编译TCP负载均衡模块，需要使用<code>--with-stream</code>进行激活。</p> 
<p>进入<a href="https://nginx.org/en/download.html" rel="nofollow">nginx官网</a>下载对应的nginx的压缩包。<br> <img src="https://images2.imgbox.com/a7/38/AXYGUFoU_o.png" alt=" "><br> 我们使用的ubuntu系统，所以下载第二列的<code>nginx-1.25.2</code>版本，下载后得到安装包。使用<code>tar -zxvf nginx-1.25.2.tar.gz</code>进行解压。解压后目录里面存在<code>auto CHANGES CHANGES.ru conf configure contrib html LICENSE man README src</code>等文件夹和文件。在执行<code>./configure --with-stream</code>开启基于TCP的负载均衡。</p> 
<p>安装过程中可能存在库文件的丢失，这里我遇到了zlib，PCRE等缺失。可以按照下方命令进行安装：</p> 
<pre><code class="prism language-sh"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> zlib1g
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> zlib1g-dev
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libpcre3 libpcre3-dev
</code></pre> 
<p>然后再执行命令（可能需要管理员权限）：</p> 
<pre><code class="prism language-sh">./configure --with-stream
<span class="token function">make</span>
<span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<pre><code class="prism language-sh">nginx <span class="token parameter variable">-s</span> reload <span class="token comment">#重新加载配置文件，例如添加服务器配置</span>
nginx <span class="token parameter variable">-s</span> stop <span class="token comment">#停止nginx服务</span>
</code></pre> 
<p>需要在nginx的配置文件加入以下内容（nginx配置文件在<code>/usr/local/nginx/conf/nginx.conf</code>，可执行文件在<code>/usr/local/nginx/sbin/nginx</code>）</p> 
<pre><code>stream {
    upstream MyServer {
        server 127.0.0.1:6000 weight=1 max_fails=3 fail_timeout=30s;
        server 127.0.0.1:6002 weight=1 max_fails=3 fail_timeout=30s;
    }
    server {
        proxy_connect_timeout 1s;
        listen 8000;
        proxy_pass MyServer;
        tcp_nodelay on;
    }
}
</code></pre> 
<p>上图显示了一个客户端连接服务器（连接的是nginx提供的ip和port），nginx将会给每个服务器按照配置进行分发客户端相应，间接等于客户端直连服务器（还是需要通过负载均衡器nginx），不影响用户之间的通信（非跨服务器通信）。</p> 
<p>配置之后需要进行重新加载配置<code>nginx -s reload</code>。</p> 
<h4><a id="redis_262"></a>redis安装</h4> 
<p>ubuntu安装redis非常简单：</p> 
<pre><code class="prism language-sh"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> redis-server
</code></pre> 
<p>查看redis的运行</p> 
<pre><code class="prism language-sh"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> redis
<span class="token function">netstat</span> <span class="token parameter variable">-tanp</span>
</code></pre> 
<p>默认运行在6379端口<code>tcp 0 0 127.0.0.1:6379 0.0.0.0:* LISTEN 144028/redis-server</code>。</p> 
<p>redis是一个强大的缓存服务器，支持多种数据结构，如字符串、list列表、set集合、map映射表等结构，支持数据的持久化存储（存储在硬盘中），经常被用于高并发的服务器环境设计中。</p> 
<p>redis其实类似于mysql，是client/server设计的。redis本身支持事务处理，多线程对key自增自减是线程安全的。</p> 
<pre><code class="prism language-sql">redis<span class="token operator">-</span>cli <span class="token comment">#启动redis客户端</span>
</code></pre> 
<p>key-value</p> 
<pre><code class="prism language-sql">root<span class="token variable">@xiehou</span><span class="token comment">--ubuntu:~# redis-cli</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>:<span class="token number">6379</span><span class="token operator">&gt;</span> get <span class="token string">"abc"</span>
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>:<span class="token number">6379</span><span class="token operator">&gt;</span> <span class="token keyword">set</span> <span class="token string">"abc"</span> <span class="token number">122</span>
OK
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>:<span class="token number">6379</span><span class="token operator">&gt;</span> get <span class="token string">"abc"</span>
<span class="token string">"122"</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/80/b2/nxru64by_o.png" alt=" "><br> <img src="https://images2.imgbox.com/e4/ca/CrbNOgT9_o.png" alt=" "></p> 
<p>redis的发布-订阅机制：发布-订阅模式包含了两种角色，分别是消息的发布者和消息的订阅者。订阅者可以定义一个或者多个频道channel，发布者可以指向向某个频道channel发送消息，所有订阅此频道的订阅者都会收到此消息。</p> 
<p>订阅的命令是subscribe。进入订阅模式后，处于此状态的客户端不能使用除subscribe、unsubscribe、psubscribe和punsubscribe这四个属于发布订阅的命令之外，否则就会报错。</p> 
<p>进入订阅状态后客户端可能收到3种类型的回复。每种类型的回复都包含3个值，第一个值是消息的<br> 类型，根据消类型的不同，第二个和第三个参数的含义可能不同。消息类型的取值可能是以下3个:</p> 
<ol><li>subscribe:表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</li><li>message:表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</li><li>unsubscribe:表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非"发布/订阅"模式的命令了。</li></ol> 
<p><img src="https://images2.imgbox.com/b8/0d/WgsUvQtQ_o.png" alt=" "><br> 带输入参数的调试<code>gdb --args ./chatserver 127.0.0.1 8000</code>。或者先运行<code>gdb ./chatserver</code>，然后在<code>run 127.0.0.1 8000</code>。在某个cpp文件中打断点<code>break chatservice.cpp:23</code>。</p> 
<p>项目地址：https://gitee.com/xiehou-design/ChatServer</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1f9a4a71d7c4dbc10548f4ee5f56d0c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IBIS 模型简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00a49d2c546ed1a3c02d28b17d6d2928/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uni-app_消息推送_华为厂商_unipush离线消息推送</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>