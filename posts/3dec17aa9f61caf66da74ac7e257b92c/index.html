<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python的映射类型tuple_【Python 秘籍】映射名称到序列元素 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python的映射类型tuple_【Python 秘籍】映射名称到序列元素" />
<meta property="og:description" content="原标题：【Python 秘籍】映射名称到序列元素
学Python,用RPA
艺赛旗RPA2020.1版本 正在免费下载使用中，欢迎下载使用
艺赛旗-RPA机器人免费下载
www.i-search.com.cn/index.html?from=line1
问题
你有一段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代码难以阅读，于是你想通过名称来访问元素。
解决方案
collections.namedtuple() 函数通过使用一个普通的元组对象来帮你解决这个问题。这个函数实际上是一个返回 Python 中标准元组类型子类的一个工厂方法。你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。代码示例：
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Subscriber = namedtuple(&#39;Subscriber&#39;, [&#39;addr&#39;, &#39;joined&#39;])
&gt;&gt;&gt; sub = Subscriber(&#39;jonesy@example.com&#39;, &#39;2012-10-19&#39;)
&gt;&gt;&gt; sub
Subscriber(addr=&#39;jonesy@example.com&#39;, joined=&#39;2012-10-19&#39;)
&gt;&gt;&gt; sub.addr
&#39;jonesy@example.com&#39;
&gt;&gt;&gt; sub.joined
&#39;2012-10-19&#39;
&gt;&gt;&gt;
尽管 namedtuple 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。比如：
&gt;&gt;&gt; len(sub)
2
&gt;&gt;&gt; addr, joined = sub
&gt;&gt;&gt; addr
&#39;jonesy@example.com&#39;
&gt;&gt;&gt; joined
&#39;2012-10-19&#39;
&gt;&gt;&gt;
命名元组的一个主要用途是将你的代码从下标操作中解脱出来。因此，如果你有一个很大的元组列表，通过下标去操作其中的元素，当这个元组的结构发生调整的时候你的代码可能就会出错了。但是如果你使用了命名元组，那么就不会有这样的顾虑。
为了说明清楚，下面是使用普通元组的代码：
# 其中records是一个元素为元组的列表
def compute_cost(records):
total = 0.0
for rec in records:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3dec17aa9f61caf66da74ac7e257b92c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-08T11:54:16+08:00" />
<meta property="article:modified_time" content="2020-12-08T11:54:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python的映射类型tuple_【Python 秘籍】映射名称到序列元素</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>原标题：【Python 秘籍】映射名称到序列元素</p> 
 <p>学Python,用RPA</p> 
 <p>艺赛旗RPA2020.1版本 正在免费下载使用中，欢迎下载使用</p> 
 <p>艺赛旗-RPA机器人免费下载</p> 
 <p>www.i-search.com.cn/index.html?from=line1</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>问题</p> 
 <p>你有一段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代码难以阅读，于是你想通过名称来访问元素。</p> 
 <p>解决方案</p> 
 <p>collections.namedtuple() 函数通过使用一个普通的元组对象来帮你解决这个问题。这个函数实际上是一个返回 Python 中标准元组类型子类的一个工厂方法。你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。代码示例：</p> 
 <p>&gt;&gt;&gt; from collections import namedtuple</p> 
 <p>&gt;&gt;&gt; Subscriber = namedtuple('Subscriber', ['addr', 'joined'])</p> 
 <p>&gt;&gt;&gt; sub = Subscriber('jonesy@example.com', '2012-10-19')</p> 
 <p>&gt;&gt;&gt; sub</p> 
 <p>Subscriber(addr='jonesy@example.com', joined='2012-10-19')</p> 
 <p>&gt;&gt;&gt; sub.addr</p> 
 <p>'jonesy@example.com'</p> 
 <p>&gt;&gt;&gt; sub.joined</p> 
 <p>'2012-10-19'</p> 
 <p>&gt;&gt;&gt;</p> 
 <p>尽管 namedtuple 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。比如：</p> 
 <p>&gt;&gt;&gt; len(sub)</p> 
 <p>2</p> 
 <p>&gt;&gt;&gt; addr, joined = sub</p> 
 <p>&gt;&gt;&gt; addr</p> 
 <p>'jonesy@example.com'</p> 
 <p>&gt;&gt;&gt; joined</p> 
 <p>'2012-10-19'</p> 
 <p>&gt;&gt;&gt;</p> 
 <p>命名元组的一个主要用途是将你的代码从下标操作中解脱出来。因此，如果你有一个很大的元组列表，通过下标去操作其中的元素，当这个元组的结构发生调整的时候你的代码可能就会出错了。但是如果你使用了命名元组，那么就不会有这样的顾虑。</p> 
 <p>为了说明清楚，下面是使用普通元组的代码：</p> 
 <p># 其中records是一个元素为元组的列表</p> 
 <p>def compute_cost(records):</p> 
 <p>total = 0.0</p> 
 <p>for rec in records:</p> 
 <p>total += rec[1] * rec[2]</p> 
 <p>return total</p> 
 <p>下标操作通常会让代码表意不清晰，并且非常依赖记录的结构。下面是使用命名元组的版本：</p> 
 <p>from collections import namedtuple</p> 
 <p>Stock = namedtuple('Stock', ['name', 'shares', 'price'])</p> 
 <p>def compute_cost(records):</p> 
 <p>total = 0.0</p> 
 <p>for rec in records:</p> 
 <p>s = Stock(*rec)</p> 
 <p>total += s.shares * s.price</p> 
 <p>return total</p> 
 <p>讨论</p> 
 <p>命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间。如果你需要构建一个非常大的包含字典的数据结构，那么使用命名元组会更加高效。但是需要注意的是，不像字典那样，一个命名元组是不可更改的。比如：</p> 
 <p>&gt;&gt;&gt; s = Stock('ACME', 100, 123.45)</p> 
 <p>&gt;&gt;&gt; s</p> 
 <p>Stock(name='ACME', shares=100, price=123.45)</p> 
 <p>&gt;&gt;&gt; s.shares = 75</p> 
 <p>Traceback (most recent call last):</p> 
 <p>File "", line 1, in </p> 
 <p>AttributeError: can't set attribute</p> 
 <p>&gt;&gt;&gt;</p> 
 <p>如果你真的需要改变属性的值，那么可以使用命名元组实例的 _replace() 方法， 它会创建一个全新的命名元组并将对应的字段用新的值取代。比如：</p> 
 <p>&gt;&gt;&gt; s = s._replace(shares=75)</p> 
 <p>&gt;&gt;&gt; s</p> 
 <p>Stock(name='ACME', shares=75, price=123.45)</p> 
 <p>&gt;&gt;&gt;</p> 
 <p>_replace() 方法还有一个很有用的特性就是当你的命名元组拥有可选或者缺失字段时候，它是一个非常方便的填充数据的方法。你可以先创建一个包含缺省值的原型元组，然后使用 _replace() 方法创建新的值被更新过的实例。比如：</p> 
 <p>from collections import namedtuple</p> 
 <p>Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])</p> 
 <p># Create a prototype instance</p> 
 <p>stock_prototype = Stock('', 0, 0.0, None, None)</p> 
 <p># Function to convert a dictionary to a Stock</p> 
 <p>def dict_to_stock(s):</p> 
 <p>return stock_prototype._replace(**s)</p> 
 <p>下面是它的使用方法：</p> 
 <p>&gt;&gt;&gt; a = {'name': 'ACME', 'shares': 100, 'price': 123.45}</p> 
 <p>&gt;&gt;&gt; dict_to_stock(a)</p> 
 <p>Stock(name='ACME', shares=100, price=123.45, date=None, time=None)</p> 
 <p>&gt;&gt;&gt; b = {'name': 'ACME', 'shares': 100, 'price': 123.45, 'date': '12/17/2012'}</p> 
 <p>&gt;&gt;&gt; dict_to_stock(b)</p> 
 <p>Stock(name='ACME', shares=100, price=123.45, date='12/17/2012', time=None)</p> 
 <p>&gt;&gt;&gt;</p> 
 <p>最后要说的是，如果你的目标是定义一个需要更新很多实例属性的高效数据结构，那么命名元组并不是你的最佳选择。这时候你应该考虑定义一个包含 __slots__ 方法的类。返回搜狐，查看更多</p> 
 <p>责任编辑：</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d7d50afca017dbaf6362af3f9de8a720/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WireShark 抓包日期格式如何设置？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c4cd8a38ec8f722e631f0bbcd8be601/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JAVA Thread.sleep模拟网络延时</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>