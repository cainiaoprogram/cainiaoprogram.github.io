<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt开发-用于表格QTableView的模型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt开发-用于表格QTableView的模型" />
<meta property="og:description" content="如果想使用表格来呈现数据，Qt提供了一个方便的部件QTableWidget，但是直接用它实现一些功能可能比较困难。这里将介绍一种强大、灵活的方式来操作表格。
一、模型/视图架构 在这个架构中，模型用于存储数据，视图用于呈现数据，除此之外，还有一个称为委托的部分，委托显示视图中的每一项，并为可编辑的项提供合适的编辑器。
三者的关系如下图所示——
这篇博客只介绍模型/视图的部分，接下来用一个简单的例子来说明如何使用。
二、要实现的功能 以网易云音乐为例，它的部分搜索界面是这样的：
现在，我们依照网易云音乐做一个下面的窗口，并实现额外的一些功能。
要实现的功能：
1.网上搜索：从网上搜索歌曲的数据并呈现在左边的表格中；
2.本地搜索并选中：在左边的表格中进行搜索，选中与关键字相匹配的行；
3.本地搜索并过滤：在左边的表格中进行搜索，只显示与关键字相匹配的行，过滤隐藏不匹配的行。
三、联网搜索 1.准备工作 左边的表格使用 QTableView 。
为了存储数据，需要使用合适的模型，在这里我们使用 QStandardItemModel 。
同时为了实现过滤，需要另一个代理模型 QSortFilterProxyModel 。
//数据模型 class MusicInfoModel : public QStandardItemModel { public: void loadData(const QString &amp;strKeyword);//用于加载网上搜索得到的数据 } //主窗口 class MainWidget : public QWidget { private slots: void searchOnlineSlot(); //网上搜索 void searchAndSelcLocalSlot(); //本地搜索并选择 void searchAndFilterLocalSlot(); //本地搜索并过滤 private: MusicInfoModel *m_pInfoModel; //数据模型 QSortFilterProxyModel *m_pFilterModel; //过滤代理模型 } 以上只列出重要的成员变量和成员函数。
为了方便加载数据，我们将QStandardItemModel子类化，在子类中声明一个加载数据的函数 loadData 。
在主窗口的构造函数中初始化视图和模型——
m_pInfoModel = new MusicInfoModel(this); m_pFilterModel = new QSortFilterProxyModel(this); m_pFilterModel-&gt;setSourceModel(m_pInfoModel); ui." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2f76ab0e39f26754317c868d694d0675/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-23T14:25:50+08:00" />
<meta property="article:modified_time" content="2023-02-23T14:25:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt开发-用于表格QTableView的模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="">如果想使用表格来呈现数据，Qt提供了一个方便的部件QTableWidget，但是直接用它实现一些功能可能比较困难。这里将介绍一种强大、灵活的方式来操作表格。</p> 
 <h2 style="text-align:left;">一、模型/视图架构</h2> 
 <p style="">在这个架构中，<span class="kdocs-bold" style="font-weight:bold;">模型</span>用于存储数据，<span class="kdocs-bold" style="font-weight:bold;">视图</span>用于呈现数据，除此之外，还有一个称为<span class="kdocs-bold" style="font-weight:bold;">委托</span>的部分，委托显示视图中的每一项，并为可编辑的项提供合适的编辑器。</p> 
 <p style="">三者的关系如下图所示——</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:21.486486%;height:0;"> 
    <img src="https://images2.imgbox.com/97/23/TP0Wx5Ba_o.jpg" style="margin-left:;display:block;width:740px;margin-top:-21.486486%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">这篇博客只介绍模型/视图的部分，接下来用一个简单的例子来说明如何使用。</p> 
 <h2 style="text-align:left;">二、要实现的功能</h2> 
 <p style="">以网易云音乐为例，它的部分搜索界面是这样的：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:34.054054%;height:0;"> 
    <img src="https://images2.imgbox.com/42/25/bUZmO0om_o.png" style="margin-left:;display:block;width:740px;margin-top:-34.054054%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">现在，我们依照网易云音乐做一个下面的窗口，并实现额外的一些功能。</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:703px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:32.147938%;height:0;"> 
    <img src="https://images2.imgbox.com/e2/d3/ngAplweW_o.png" style="margin-left:;display:block;width:703px;margin-top:-32.147938%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">要实现的功能：</p> 
 <p style="">1.<span class="kdocs-bold" style="font-weight:bold;">网上搜索</span>：从网上搜索歌曲的数据并呈现在左边的表格中；</p> 
 <p style="">2.<span class="kdocs-bold" style="font-weight:bold;">本地搜索并选中</span>：在左边的表格中进行搜索，<span class="kdocs-bold" style="font-weight:bold;">选中</span>与关键字相匹配的行；</p> 
 <p style="">3.<span class="kdocs-bold" style="font-weight:bold;">本地搜索并过滤</span>：在左边的表格中进行搜索，只显示与关键字相匹配的行，过滤隐藏不匹配的行。</p> 
 <h2 style="text-align:left;">三、联网搜索</h2> 
 <h2 style="text-align:left;">1.准备工作</h2> 
 <p style="">左边的表格使用 QTableView 。</p> 
 <p style="">为了存储数据，需要使用合适的模型，在这里我们使用 QStandardItemModel 。</p> 
 <p style="">同时为了实现过滤，需要另一个代理模型 QSortFilterProxyModel 。</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">//数据模型
class MusicInfoModel : public QStandardItemModel
{
public:
void loadData(const QString &amp;strKeyword);//用于加载网上搜索得到的数据
}
//主窗口
class MainWidget : public QWidget
{
private slots:
void searchOnlineSlot(); //网上搜索
void searchAndSelcLocalSlot(); //本地搜索并选择
void searchAndFilterLocalSlot(); //本地搜索并过滤
private:
MusicInfoModel *m_pInfoModel; //数据模型
QSortFilterProxyModel *m_pFilterModel; //过滤代理模型
}</code></pre> 
 <p style="">以上只列出重要的成员变量和成员函数。</p> 
 <p style="">为了方便加载数据，我们将QStandardItemModel<span class="kdocs-bold" style="font-weight:bold;">子类化</span>，在子类中声明一个加载数据的函数 loadData 。</p> 
 <p style="">在主窗口的构造函数中初始化视图和模型——</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">m_pInfoModel = new MusicInfoModel(this);
m_pFilterModel = new QSortFilterProxyModel(this);
m_pFilterModel-&gt;setSourceModel(m_pInfoModel);
ui.musicInfoTblView-&gt;setModel(m_pFilterModel);</code></pre> 
 <p style="">从上面可以看到，表格的视图模型是代理模型filterModel，而不是实际包含数据的模型infoModel。</p> 
 <h2 style="text-align:left;">2.加载数据</h2> 
 <p style="">接下来网上搜索，获得数据并加载到表格中</p> 
 <p style="">首先定义歌曲信息的数据结构</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">//歌曲信息的数据结构
struct SongInfo
{
public:
QString strName; //歌曲标题
QString strSinger; //歌手名字
QString strAlbum; //专辑名称
};</code></pre> 
 <p style="">完成数据模型中加载数据的函数：</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">void MusicInfoModel::loadData(const QString &amp;strKeyword)
{
QList&lt;SongInfo&gt; listSongInfo; //歌曲信息的list
//...省略的步骤
//根据关键字strKeyword从网上搜索
//并将搜索结果存储到listSongInfo中
//清除数据模型中之前存在的数据，并重新设置表头（因为clear会把表头也清除掉）
clear();
setHorizontalHeaderLabels(QStringList() &lt;&lt; QString::fromLocal8Bit("音乐标题") &lt;&lt; QString::fromLocal8Bit("歌手") &lt;&lt; QString::fromLocal8Bit("专辑"));
//遍历list，将数据存在表中
for (SongInfo songItem : listSongInfo)
{
QList&lt;QStandardItem *&gt; listItems;
QStandardItem *pTitle = new QStandardItem(songItem.strName);
QStandardItem *pSinger = new QStandardItem(songItem.strSinger);
QStandardItem *pAlbum = new QStandardItem(songItem.strAlbum);
listItems &lt;&lt; pTitle &lt;&lt; pSinger &lt;&lt; pAlbum;
appendRow(listItems);//加载一行数据
}
}</code></pre> 
 <h2 style="text-align:left;">注意：表中的每一项是一个QStandardItem，在加载一行之前，需要先把他们存储在一个QList中，然后调用appendRow函数，一次完成加载3列。</h2> 
 <p style="">接下来，我们在主界面中调用数据模型对象的loadData函数，即可将数据全部填到表格中。</p> 
 <h2 style="text-align:left;">四、本地搜索并过滤</h2> 
 <p style="">过滤很简单，只需要使用<span class="kdocs-bold" style="font-weight:bold;">QSortFilterProxyModel</span>中的相关函数。</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">void MainWidget::searchAndFilterLocalSlot()
{
QString strKeyword = ui.textEdit-&gt;text();
m_pFilterModel-&gt;setFilterFixedString(strKeyword);//根据字符串过滤
}</code></pre> 
 <p style="">一些有用的函数：</p> 
 <p style="">void setFilterKeyColumn(int column) ：设置根据表的哪一列进行过滤，默认值为0，如果设置成-1，则会根据所有列进行搜索。</p> 
 <p style="">setFilterFixedString(const QString &amp;) ：根据固定的字符串进行过滤。</p> 
 <p style="">setFilterRegExp(const QRegExp &amp;) ：根据正则表达式进行过滤。</p> 
 <h2 style="text-align:left;">五、本地搜索并选中</h2> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">void MainWidget::searchAndSelcLocalSlot()
{
QItemSelection selection;
int iFirstSelcRow = -1;
for (int i = 0; i &lt; m_pFilterModel-&gt;rowCount(); ++i)
{
//获得每一行的歌名、歌手名、专辑名
QModelIndex songIndex = m_pFilterModel-&gt;index(i, 0);
QModelIndex singerIndex = m_pFilterModel-&gt;index(i, 1);
QModelIndex albumnIndex = m_pFilterModel-&gt;index(i, 2);
QString strSong = m_pFilterModel-&gt;data(songIndex).toString();
QString strSinger = m_pFilterModel-&gt;data(singerIndex).toString();
QString strAlbumn = m_pFilterModel-&gt;data(albumnIndex).toString();
//判断是否符合条件
if (strSong.contains(strKeyword) || strSinger.contains(strKeyword) || strAlbumn.contains(strKeyword))
{
if (iFirstSelcRow == -1)
{
iFirstSelcRow = i;
}
//增加选中项
QItemSelection rowSelc(songIndex, songIndex);
selection.merge(rowSelc, QItemSelectionModel::Select);
}
}
//清除之前所有选中项，并选中现在的所有匹配项
QItemSelectionModel *pSelcModel = ui.musicInfoTblView-&gt;selectionModel();
pSelcModel-&gt;clearSelection();
pSelcModel-&gt;select(selection, QItemSelectionModel::Rows | QItemSelectionModel::Select);
//视图滚动到第一个选中项的位置
if (iFirstSelcRow != -1)
{
ui.musicInfoTblView-&gt;scrollTo(m_pFilterModel-&gt;index(iFirstSelcRow, 0));
}
}</code></pre> 
 <p style="">最终的简陋窗口：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:703px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:55.47653%;height:0;"> 
    <img src="https://images2.imgbox.com/8f/34/MMCgH4bn_o.png" style="margin-left:;display:block;width:703px;margin-top:-55.47653%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">以上只是视图/模型的使用作简单介绍，更多用法还请在实践中自行查找官方文档。</p> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d7f1d00336adf4a7a4f512378eaa1bdb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习环境配置指南/YOLOv8目标检测实践</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d4f6acb0db73bda7bafc711f11a0587/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">高级信息系统项目管理师（高项）高分通过经验分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>