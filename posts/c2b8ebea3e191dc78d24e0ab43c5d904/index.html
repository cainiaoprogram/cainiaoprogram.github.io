<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32：基本定时器原理和定时程序 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32：基本定时器原理和定时程序" />
<meta property="og:description" content="一、初识定时器TIM 定时器就是计数器，定时器的作用就是设置一个时间，然后时间到后就会通过中断等方式通知STM32执行某些程序。定时器除了可以实现普通的定时功能，还可以实现捕获脉冲宽度，计算PWM占空比，输出PWM波形，编码器计数等。
STM32共11个定时器，2个高级控制定时器TIM1和TIM8，4个通用定时器TIM2~TIM5，两个基本定时器TIM6和TIM7，两个看门狗定时器和一个系统滴答定时器Systick.
高级定时器TIM1和TIM8的时钟由APB1产生，其它六个通用定时器的时钟由APB2产生。它们的最大频率都可以配置成系统时钟的频率。
定时器种类位数计数模式捕获/比较通道应用场景通用定时器
TIM2~TIM516向上，向下，双向4定时计数，PWM,输入捕获，输出比较高级定时器
TIM1和TIM816向上，向下，双向4在通用的基础上，多了刹车信号输入，死区时间互补输出等工业电机功能基本定时器
TIM6和TIM716向上，向下，双向4定时计数 二、基本定时器 (1)计数功能原理 在上一期文章提到，时钟树提供稳定频率的方波信号，APB1上的时钟线连接了基本定时器和通用寄存器，APB2上的时钟线连接了高级定时器。
对于实现计数功能，只需要一个寄存器就可以满足，寄存器只需要读到时钟信号的上升沿数值就加1。假如72MHZ的时钟信号作为输入，当该寄存器数值累加到7.2*10^7，就代表时间过去了1秒。但是寄存器通常只有16bit，最多能计数 65536个数。因此在该寄存器前面还要加一个类似的计数器，当计数满足条件时才往后续电路发送高电平，预分频器就可以充当这个角色，其本质也是一个16bit的计数器。当只需要将其设置为n-1，就可以进行n分频，从0开始计数，一直计数到n-1才会向后续电路发送高电平。预分频器最多可以进行65536分频。因此一个由预分频器和一个计数器组合成的定时器，最多可以计数65536^2次。m个定时器串联，就可以计数65536^（2*m）次。 (2) 自动重装载寄存器 自动重装载寄存器，它的作用就是实时监控计数器的值是否与自己的值相同。当计数器的值与自己的值相同时，便将计数器重置为0，并触发定时器更新中断。
(3)影子寄存器 所谓的影子寄存器就是某个寄存器的拷贝。在上图中工作在一线的预分频器和自动重装载寄存器其实都是自己的影子寄存器。当定时器正在工作时，如果重新设置预分频器值或者重新这是自动重装载寄存器的值，那么只有当计数器和自动重装载寄存器的值一样时才会将新值更新到自身影子寄存器中。也就是给定时器设置的新参数值要等下个计数周期才生效。
自动重装载寄存器可以根据程序员选择是否开启影子寄存器。如果不开启，那么将自动重装载寄存器数值调小时，可能会错过计数器的值，使计数器一路上到65536才会归0。
三、定时程序 (1)准备工作 为了发送数据进行模拟,需打开USART2用于设置模式为“异步”，在NVIC Settings中打开中断，打上√，在DMA Settings,打开DMA传输功能，添加传输通道。
为提高计数精度，将外部时钟源设置为&#34;晶振&#34;，在时钟设置界面中的HCLK的频率设置为72MHZ，自动调整其它器件的时钟频率。
对于我使用的STM32F108T6芯片只有4个定时器，即1个高级，3个通用寄存器。虽然没有基本定时器，但是这些定时器都包含了基本定时器功能。只需要对定时器的时钟源选择 Internal Clock （内部时钟源）就算打开了定时器。因为本次模拟的时钟频率是72MHZ，设置预分频器7200，自动重装载寄存器为10000，那么完成一个周期的计数就是1s，也就是1s触发一次定时器更新中断。同第一步类似，TIM也可以开启中断和DMA通道。保存并生成代码。
(2)实现定时任务和获取计数器数值： 以下示例代码为开启TIM中断和USART2中断实现,以及开启了自动重装载寄存器的影子寄存器
1.开启定时器 HAL_TIM_Base_Start(&amp;htim); //用阻塞的方式开始定时器
HAL_TIM_Base_Start_IT(&amp;htim); //用中断(非阻塞)的方式开始定时器
HAL_TIM_Base_Start_DMA(&amp;htim); //用DMA(非阻塞)的方式开始定时器
2.中断回调函数 在路径 ~/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c中
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
当计数器数值和自动重装载寄存器值一样时调用
3.读写定时器中寄存器的宏定义操作 __HAL_TIM_GET_ANTORELOAD //获取自动重装载寄存器数值
__HAL_TIM_SET_ANTORELOAD //设置自动重装载寄存器数值
__HAL_TIM_GET_COUNTER //获取计数器数值
__HAL_TIM_SET_COUNTER //设置计数器数值
__HAL_TIM_SET_PRESCALER //设置预分频器数值
4.示例代码 /* USER CODE BEGIN Includes */ #include &lt;string.h&gt; #include &lt;stdio.h&gt; /* USER CODE END Includes */ /* Private typedef -----------------------------------------------------------*/ /* USER CODE BEGIN PTD */ /* USER CODE END PTD */ /* Private define ------------------------------------------------------------*/ /* USER CODE BEGIN PD */ /* USER CODE END PD */ /* Private macro -------------------------------------------------------------*/ /* USER CODE BEGIN PM */ /* USER CODE END PM */ /* Private variables ---------------------------------------------------------*/ TIM_HandleTypeDef htim4; UART_HandleTypeDef huart2; DMA_HandleTypeDef hdma_usart2_rx; DMA_HandleTypeDef hdma_usart2_tx; /* USER CODE BEGIN PV */ /* USER CODE END PV */ /* Private function prototypes -----------------------------------------------*/ void SystemClock_Config(void); static void MX_GPIO_Init(void); static void MX_DMA_Init(void); static void MX_USART2_UART_Init(void); static void MX_TIM4_Init(void); /* USER CODE BEGIN PFP */ /* USER CODE END PFP */ /* Private user code ---------------------------------------------------------*/ /* USER CODE BEGIN 0 */ char message2[]=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c2b8ebea3e191dc78d24e0ab43c5d904/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-23T21:58:13+08:00" />
<meta property="article:modified_time" content="2023-11-23T21:58:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32：基本定时器原理和定时程序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、初识定时器TIM</h2> 
<p>        定时器就是计数器，定时器的作用就是设置一个时间，然后时间到后就会通过中断等方式通知STM32执行某些程序。定时器除了可以实现普通的定时功能，还可以实现捕获脉冲宽度，计算PWM占空比，输出PWM波形，编码器计数等。</p> 
<p>STM32共11个定时器，2个高级控制定时器TIM1和TIM8，4个通用定时器TIM2~TIM5，两个基本定时器TIM6和TIM7，两个看门狗定时器和一个系统滴答定时器Systick.<br> 高级定时器TIM1和TIM8的时钟由APB1产生，其它六个通用定时器的时钟由APB2产生。它们的最大频率都可以配置成系统时钟的频率。</p> 
<table><thead><tr><th>定时器种类</th><th>位数</th><th>计数模式</th><th>捕获/比较通道</th><th>应用场景</th></tr></thead><tbody><tr><td>通用定时器<br> TIM2~TIM5</td><td>16</td><td>向上，向下，双向</td><td>4</td><td>定时计数，PWM,输入捕获，输出比较</td></tr><tr><td>高级定时器<br> TIM1和TIM8</td><td>16</td><td>向上，向下，双向</td><td>4</td><td>在通用的基础上，多了刹车信号输入，死区时间互补输出等工业电机功能</td></tr><tr><td>基本定时器<br> TIM6和TIM7</td><td>16</td><td>向上，向下，双向</td><td>4</td><td>定时计数</td></tr></tbody></table> 
<p></p> 
<h2>二、基本定时器</h2> 
<h3>(1)计数功能原理</h3> 
<p>        在上一期文章提到，时钟树提供稳定频率的方波信号，APB1上的时钟线连接了基本定时器和通用寄存器，APB2上的时钟线连接了高级定时器。</p> 
<p><img alt="" height="1159" src="https://images2.imgbox.com/ea/8c/2jajSrk1_o.png" width="1200"></p> 
<p>        对于实现计数功能，只需要一个寄存器就可以满足，寄存器只需要读到时钟信号的上升沿数值就加1。假如72MHZ的时钟信号作为输入，当该寄存器数值累加到7.2*10^7，就代表时间过去了1秒。但是寄存器通常只有16bit，最多能计数 65536个数。因此在该寄存器前面还要加一个类似的计数器，当计数满足条件时才往后续电路发送高电平，预分频器就可以充当这个角色，其本质也是一个16bit的计数器。当只需要将其设置为n-1，就可以进行n分频，从0开始计数，一直计数到n-1才会向后续电路发送高电平。预分频器最多可以进行65536分频。因此一个由预分频器和一个计数器组合成的定时器，最多可以计数65536^2次。m个定时器串联，就可以计数65536^（2*m）次。 </p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/56/3d/qz68f9QI_o.png" width="1048"></p> 
<h3>(2) 自动重装载寄存器</h3> 
<p>         自动重装载寄存器，它的作用就是实时监控计数器的值是否与自己的值相同。当计数器的值与自己的值相同时，便将计数器重置为0，并触发定时器更新中断。</p> 
<p><img alt="" height="757" src="https://images2.imgbox.com/b7/5e/Kx5csJYQ_o.png" width="1200"></p> 
<h3>(3)影子寄存器</h3> 
<p>        所谓的影子寄存器就是某个寄存器的拷贝。在上图中<strong>工作在一线的预分频器和自动重装载寄存器其实都是自己的影子寄存器</strong>。当定时器正在工作时，如果重新设置预分频器值或者重新这是自动重装载寄存器的值，那么<strong>只有当计数器和自动重装载寄存器的值一样时才会将新值更新</strong>到自身影子寄存器中。也就是给定时器设置的新参数值要等下个计数周期才生效。</p> 
<p>        自动重装载寄存器可以根据程序员选择是否开启影子寄存器。如果不开启，那么将自动重装载寄存器数值调小时，可能会错过计数器的值，使计数器一路上到65536才会归0。</p> 
<p></p> 
<h2>三、定时程序</h2> 
<h3>(1)准备工作</h3> 
<p>为了发送数据进行模拟,需打开USART2用于设置模式为“异步”，在NVIC Settings中打开中断，打上√，在DMA Settings,打开DMA传输功能，添加传输通道。</p> 
<p><img alt="" height="1014" src="https://images2.imgbox.com/35/0e/Sm0L2C7F_o.png" width="852"></p> 
<p>为提高计数精度，将外部时钟源设置为"晶振"，在时钟设置界面中的HCLK的频率设置为72MHZ，自动调整其它器件的时钟频率。</p> 
<p><img alt="" height="520" src="https://images2.imgbox.com/fe/27/ggm8Fc74_o.png" width="877"></p> 
<p><img alt="" height="871" src="https://images2.imgbox.com/c6/9b/GMmZ5WZ5_o.png" width="1200"></p> 
<p></p> 
<p>对于我使用的STM32F108T6芯片只有4个定时器，即1个高级，3个通用寄存器。虽然没有基本定时器，但是这些定时器都包含了基本定时器功能。只需要对定时器的时钟源选择 Internal Clock （内部时钟源）就算打开了定时器。因为本次模拟的时钟频率是72MHZ，设置预分频器7200，自动重装载寄存器为10000，那么完成一个周期的计数就是1s，也就是1s触发一次定时器更新中断。同第一步类似，TIM也可以开启中断和DMA通道。保存并生成代码。</p> 
<p><img alt="" height="1093" src="https://images2.imgbox.com/5f/20/OvbOfLbO_o.png" width="1000"></p> 
<h3>(2)实现定时任务和获取计数器数值：</h3> 
<p>以下示例代码为开启TIM中断和USART2中断实现,以及开启了自动重装载寄存器的影子寄存器</p> 
<h4>1.开启定时器</h4> 
<blockquote> 
 <p>HAL_TIM_Base_Start(&amp;htim);        //用阻塞的方式开始定时器</p> 
 <p>HAL_TIM_Base_Start_IT(&amp;htim);        //用中断(非阻塞)的方式开始定时器</p> 
 <p>HAL_TIM_Base_Start_DMA(&amp;htim);    //用DMA(非阻塞)的方式开始定时器</p> 
</blockquote> 
<h4>2.中断回调函数</h4> 
<blockquote> 
 <p>在路径 ~/Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c中</p> 
 <p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</p> 
 <p>当计数器数值和自动重装载寄存器值一样时调用</p> 
</blockquote> 
<h4>3.读写定时器中寄存器的宏定义操作</h4> 
<blockquote> 
 <p>__HAL_TIM_GET_ANTORELOAD //获取自动重装载寄存器数值</p> 
 <p>__HAL_TIM_SET_ANTORELOAD //设置自动重装载寄存器数值</p> 
 <p>__HAL_TIM_GET_COUNTER        //获取计数器数值</p> 
 <p>__HAL_TIM_SET_COUNTER        //设置计数器数值</p> 
 <p>__HAL_TIM_SET_PRESCALER    //设置预分频器数值</p> 
</blockquote> 
<h4>4.示例代码</h4> 
<pre><code class="language-cpp">/* USER CODE BEGIN Includes */
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef htim4;

UART_HandleTypeDef huart2;
DMA_HandleTypeDef hdma_usart2_rx;
DMA_HandleTypeDef hdma_usart2_tx;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_TIM4_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
char message2[]="☺☹";
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
	if(htim == &amp;htim4){
		HAL_UART_Transmit_IT(&amp;huart2, (uint8_t*)message2,strlen(message2));
	}
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_USART2_UART_Init();
  //TIM4的初始化
  MX_TIM4_Init();
  /* USER CODE BEGIN 2 */
  //用中断的方式开启定时器
  HAL_TIM_Base_Start_IT(&amp;htim4);
  int counter = 0;
  char message[20];
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  counter = __HAL_TIM_GET_COUNTER(&amp;htim4);
	  sprintf(message,"counter:%d",counter);
	  //每隔100ms发送 counter计数器数值
	  //HAL_UART_Transmit_IT(&amp;huart2, (uint8_t*)message,strlen(message));
	  //延迟100ms
	  HAL_Delay(100-1);
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4c6b243573840c408035fd42c5d8affc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是知识图谱？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b73b87ed630923e0f9e0cc52ec1bfd5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">81基于matlab GUI的图像处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>