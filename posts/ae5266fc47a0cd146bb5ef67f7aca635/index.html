<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Spring AOP】面向切面编程的概念,实践,原理详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Spring AOP】面向切面编程的概念,实践,原理详解" />
<meta property="og:description" content="AOP概念 AOP的全名是aspect-oriented programming面向切面编程,它是面对对象编程(OOP)的一种方式
这个AOP的思想主要是指对一个事务的集中处理.将多个类都要完成的功能都在一个类中统一完成.如用户登录的校验功能,每一个页面其实都要进行这个校验,AOP技术就是单独在一个另外的类中统一的进行校验
AOP技术是一种思想,Spring AOP是这个思想的一个技术实现
AOP主要完成的事务 AOP主要可以完成以下几种事务:
统一日志记录统一方法执行时间统计统一的方法返回结果设置统一的异常处理事务的开启和提交 组成 切面Aspect 切面是由切点和通知组成的.
主要就是一个包含了一些实现功能的AOP集合类,不仅包括了切点和通知,还包含了连接点的定义
连接点 Join Point 程序中调用切面的一个位置,叫做连接点,这个连接点可以是方法调用,可以是抛出异常时,可以是修改参数时
切点 Pointcut Pointcut 的作⽤就是提供⼀组规则（使⽤ AspectJ pointcut expression language 来描述）来匹 配 Join Point，给满⾜规则的 Join Point 添加 Advice。
切点相当于保存了众多连接点的⼀个集合（如果把切点看成⼀个表，⽽连接点就是表中⼀条⼀条 的数据
通配符 AspectJ ⽀持三种通配符
* 匹配任意字符，只匹配⼀个元素（包，类，或⽅法，⽅法参数）
..匹配任意字符，可以匹配多个元素 ，在表示类时，必须和 * 联合使⽤。 &#43; 表示按照类型匹配指定类的所有类，必须跟在类名后⾯，如 com.cad.Car&#43; ,表示继承该类的 所有⼦类包括本身 切点表达式:
切点表达式由切点函数组成，其中 execution() 是最常⽤的切点函数，⽤来匹配⽅法，语法为:
execution(&lt;修饰符&gt;&lt;返回类型&gt;&lt;包.类.⽅法(参数)&gt;&lt;异常&gt;)
修饰符,异常一般省略
包,类一般不省略
返回类型,方法名,参数不可以省略
通知 Advice 切点的方法体的实现就是通知.
Spring AOP中有以下几种通知:
前置通知@Before 通知方法会在目标方法之前进行执行
后置通知@After 通知方法在目标方法返回之后或者异常抛出之后
返回之后通知@AfterReturning 通知方法在目标方法返回之后通知
抛异常后通知@AfterThrowing 通知方法在目标方法抛出异常之后执行" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ae5266fc47a0cd146bb5ef67f7aca635/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-05T16:21:09+08:00" />
<meta property="article:modified_time" content="2022-09-05T16:21:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Spring AOP】面向切面编程的概念,实践,原理详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="AOP_0"></a>AOP概念</h2> 
<p>AOP的全名是aspect-oriented programming面向切面编程,它是面对对象编程(OOP)的一种方式</p> 
<p>这个AOP的思想主要是指对一个事务的集中处理.将多个类都要完成的功能都在一个类中统一完成.如用户登录的校验功能,每一个页面其实都要进行这个校验,AOP技术就是单独在一个另外的类中统一的进行校验</p> 
<p>AOP技术是一种思想,Spring AOP是这个思想的一个技术实现</p> 
<h3><a id="AOP_8"></a>AOP主要完成的事务</h3> 
<p>AOP主要可以完成以下几种事务:</p> 
<ol><li>统一日志记录</li><li>统一方法执行时间统计</li><li>统一的方法返回结果设置</li><li>统一的异常处理</li><li>事务的开启和提交</li></ol> 
<h3><a id="_18"></a>组成</h3> 
<h4><a id="Aspect_20"></a>切面Aspect</h4> 
<p>切面是由切点和通知组成的.</p> 
<p>主要就是一个包含了一些实现功能的AOP集合类,不仅包括了切点和通知,还包含了连接点的定义</p> 
<h4><a id="_Join_Point_26"></a>连接点 Join Point</h4> 
<p>程序中调用切面的一个位置,叫做连接点,这个连接点可以是方法调用,可以是抛出异常时,可以是修改参数时</p> 
<h4><a id="_Pointcut_30"></a>切点 Pointcut</h4> 
<p>Pointcut 的作⽤就是提供⼀组规则（使⽤ AspectJ pointcut expression language 来描述）来匹 配 Join Point，给满⾜规则的 Join Point 添加 Advice。</p> 
<p>切点相当于保存了众多连接点的⼀个集合（如果把切点看成⼀个表，⽽连接点就是表中⼀条⼀条 的数据</p> 
<h5><a id="_36"></a>通配符</h5> 
<p>AspectJ ⽀持三种通配符</p> 
<ul><li><code> *</code> 匹配任意字符，只匹配⼀个元素（包，类，或⽅法，⽅法参数）<br> <code>..</code>匹配任意字符，可以匹配多个元素 ，在表示类时，必须和 * 联合使⽤。</li></ul> 
<ul><li><code>+ </code>表示按照类型匹配指定类的所有类，必须跟在类名后⾯，如 com.cad.Car+ ,表示继承该类的 所有⼦类包括本身</li></ul> 
<p>切点表达式:<br> 切点表达式由切点函数组成，其中 execution() 是最常⽤的切点函数，⽤来匹配⽅法，语法为:</p> 
<blockquote> 
 <p>execution(&lt;修饰符&gt;&lt;返回类型&gt;&lt;包.类.⽅法(参数)&gt;&lt;异常&gt;)</p> 
</blockquote> 
<p>修饰符,异常一般省略<br> 包,类一般不省略<br> 返回类型,方法名,参数不可以省略</p> 
<h4><a id="_Advice_52"></a>通知 Advice</h4> 
<p>切点的方法体的实现就是通知.</p> 
<p>Spring AOP中有以下几种通知:</p> 
<h5><a id="Before_58"></a>前置通知@Before</h5> 
<p>通知方法会在目标方法之前进行执行</p> 
<h5><a id="After_62"></a>后置通知@After</h5> 
<p>通知方法在目标方法返回之后或者异常抛出之后</p> 
<h5><a id="AfterReturning_66"></a>返回之后通知@AfterReturning</h5> 
<p>通知方法在目标方法返回之后通知</p> 
<h5><a id="AfterThrowing_70"></a>抛异常后通知@AfterThrowing</h5> 
<p>通知方法在目标方法抛出异常之后执行</p> 
<h5><a id="Around_74"></a>环绕通知@Around</h5> 
<p>通知方法在目标方法执行之前和执行之后都通知</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Aspect</span><span class="token comment">//加上Aspect就表示它是一个切面  </span>
<span class="token annotation punctuation">@Component</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAspect</span> <span class="token punctuation">{<!-- --></span>  
  
    <span class="token annotation punctuation">@Autowired</span>  
    <span class="token class-name">UserController</span> userController<span class="token punctuation">;</span>  
  
    <span class="token comment">//定义切点,并设置切点的范围  </span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.demo.controller.UserController.*(..))"</span><span class="token punctuation">)</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token comment">//切点没有方法体  </span>
  
    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pointcut()"</span><span class="token punctuation">)</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行before方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"pointcut()"</span><span class="token punctuation">)</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行after方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"pointcut()"</span><span class="token punctuation">)</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfterReturning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行AfterReturning"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span><span class="token string">"pointcut()"</span><span class="token punctuation">)</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfterThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行AfterThrow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">doAround</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">Object</span> object<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行around方法之前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>  
            object<span class="token operator">=</span>joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> throwable<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
            throwable<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行around方法之后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> object<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
<span class="token punctuation">}</span>
</code></pre> 
<p>当有异常抛出时,如果同时有上面的这些通知,那么这些通知的顺序是什么呢?</p> 
<blockquote></blockquote> 
<p>执行before方法<br> 执行AfterThrow<br> 执行after方法</p> 
<p>先执Before通知,在执行抛出异常通知,最后执行After通知.<br> 因为程序没有正常的结束,所以不会执行AfterReturn通知</p> 
<p>这也就说明了:</p> 
<p><strong>after通知无论如何都会执行,但是afterReturn在遇到异常之后不会正常执行,这个是两者的区别</strong></p> 
<hr> 
<p>对于Around通知来说,如果加上了它,这些通知的执行顺序是什么呢?</p> 
<pre><code>执行around方法之前
执行before方法
目标文件执行
执行AfterReturning
执行after方法
执行around方法之后
</code></pre> 
<ol><li>环绕通知的优先级最高</li><li>接着是前置通知</li><li>执行目标函数</li><li>执行afterReturn通知</li><li>执行后置通知</li><li>最后是有环绕通知结尾</li></ol> 
<p>也就是说,环绕通知最先出现,最晚离开<br> 在正常执行的情况下,afterReturn出现在后置通知之前</p> 
<hr> 
<p>使用around注解完成执行时间的统计</p> 
<p>使用spring提供的stopWatch和joinPoint来进行统计时间</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"pointcut()"</span><span class="token punctuation">)</span>  
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">doAround</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
    <span class="token class-name">Object</span> object<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>  
    <span class="token class-name">StopWatch</span> stopWatch<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行around方法之前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>  
        stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        object<span class="token operator">=</span>joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> throwable<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        throwable<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaringType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"."</span><span class="token operator">+</span>  
                            joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行了"</span><span class="token operator">+</span>stopWatch<span class="token punctuation">.</span><span class="token function">getTotalTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行around方法之后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> object<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_189"></a>四大组成的联系</h4> 
<p><img src="https://images2.imgbox.com/26/2d/c8D4wBpw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f2/1e/2EyNOgrB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Spring_AOP_193"></a>Spring AOP的实现</h3> 
<p>主要分为以下四个步骤:</p> 
<h4><a id="SpringBoot_AOP_197"></a>一.创建SpringBoot AOP框架</h4> 
<p>还是在pom.xml中引入SPringBoot框架的AOP依赖,我们可以去Maven中央仓库中找到这个依赖,然后赋值到项目的pom.xml中.</p> 
<pre><code class="prism language-xml"><span class="token comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

</code></pre> 
<p>记住,一定时SpringBoot的依赖,不要添加成Spring的依赖了,因为现在大多数的项目都是使用SpringBoot较多hh</p> 
<h4><a id="_213"></a>二.创建切面</h4> 
<p>切面是一个类,在类的前面加上注解@Aspect就表示这是一个切面类.</p> 
<p>同时,它也要加上五大类注解@Component</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Aspect</span><span class="token comment">//加上Aspect就表示它是一个切面  </span>
<span class="token annotation punctuation">@Component</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAspect</span> <span class="token punctuation">{<!-- --></span>  
    
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_227"></a>三.创建切点</h4> 
<p>在函数的前面加上@Pointcut表示是一个切点.</p> 
<p>@Pointcut的后面是指定该切点函数的范围.</p> 
<pre><code class="prism language-java">    <span class="token comment">//定义切点,并设置切点的范围  </span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.demo.controller.UserController.*(..))"</span><span class="token punctuation">)</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token comment">//切点没有方法体  </span>
</code></pre> 
<p>括号里面的内容是AspectJ语言,<br> execution(返回类型 包名 类名 方法名 参数类型)</p> 
<pre><code>execution(*(返回类型) com.example.demo.controller(包名).UserController(类名).*(方法名)(..)(参数类型))
</code></pre> 
<h4><a id="_246"></a>四.实现通知</h4> 
<p>直接在切面类中,创建通知函数就可以,在方法的前面加上通知类型.</p> 
<p>通知类型的括号里面写通知对应的切点是谁.</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pointcut()"</span><span class="token punctuation">)</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">UserLoginOrNot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行before方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
</code></pre> 
<p>整体代码:</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Aspect</span><span class="token comment">//加上Aspect就表示它是一个切面  </span>
<span class="token annotation punctuation">@Component</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAspect</span> <span class="token punctuation">{<!-- --></span>  
  
    <span class="token annotation punctuation">@Autowired</span>  
    <span class="token class-name">UserController</span> userController<span class="token punctuation">;</span>  
  
    <span class="token comment">//定义切点,并设置切点的范围  </span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.demo.controller.UserController.*(..))"</span><span class="token punctuation">)</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token comment">//切点没有方法体  </span>
  
    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pointcut()"</span><span class="token punctuation">)</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">UserLoginOrNot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行before方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_280"></a>实现原理</h3> 
<p>SpringAOP是基于动态代理的方式实现的.</p> 
<p>在没有AOP之前,前端直接和后端进行交互,但是在引入了AOP之后,要先经过AOP的一些通知,这就是动态代理.</p> 
<p><img src="https://images2.imgbox.com/6d/d3/stxTZye5_o.png" alt="在这里插入图片描述"></p> 
<p>主要有两种原理实现:</p> 
<ol><li>JDK proxy</li><li>CGLIB proxy</li></ol> 
<p>这两个原理相对来说,大部分时间还是使用CGLIB proxy的,因为它的效率高,当CGLIB无法完成的时候再使用JDK proxy</p> 
<p>CGLIB是通过继承目标类来实现动态代理的,对于哪些不可以被继承的类(被final修饰的类) 我们就只好使用JDK proxy</p> 
<h3><a id="_297"></a>织入</h3> 
<p>织入是创建新的代理对象的过程，切⾯在指定的连接点被织⼊到⽬标对 象中。 在⽬标对象的⽣命周期⾥有多个点可以进⾏织⼊：</p> 
<p>编译期：切⾯在⽬标类编译时被织⼊。这种⽅式需要特殊的编译器。AspectJ的织⼊编译器就 是以这种⽅式织⼊切⾯的。</p> 
<p>类加载器：切⾯在⽬标类加载到JVM时被织⼊。这种⽅式需要特殊的类加载器 （ClassLoader）,它可以在⽬标类被引⼊应⽤之前增强该⽬标类的字节码。AspectJ5的加载 时织⼊（load-time weaving. LTW）就⽀持以这种⽅式织⼊切⾯。</p> 
<p>运⾏期：切⾯在应⽤运⾏的某⼀时刻被织⼊。⼀般情况下，在织⼊切⾯时，AOP容器会为⽬标对象动态创建⼀个代理对象。SpringAOP就是以这种⽅式织⼊切⾯的。</p> 
<p>这两种方法都是在运行时发挥动态代理的</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c99bc174d57caef885d49140634f82cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ACL的基本介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d30af97528ed7868b100180bdaa7711/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Rockchip PX30/RK3326 Android开机时间优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>