<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【转】探究芯片中的寄存器 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【转】探究芯片中的寄存器" />
<meta property="og:description" content="转前辈博客：https://mp.weixin.qq.com/s/VVzDYlFRrOywS9i-cwUXgA
前言 作为一个芯片相关行业的从业者，有时候一直好奇我口中的嵌入式的角度去配置的寄存器，和芯片设计人员口中的寄存器是不是一个东西，正好看见前辈发了这个文章。希望关注的前辈早点更新下一篇，下面来学习一下。
芯片设计中，寄存器(register)基本上是随处可见。无论是承担软件配置的寄存器，还是硬件状态上报的寄存器，亦或是其他类型的寄存器，在芯片的软/硬交互中，起到了桥梁的作用。
(这里的register指对软件或者core可见的寄存器。在芯片内部还存在数量巨大的内部register，但只是芯片工作中的硬件信息存储，core或者软件不可见)
(这里的软件指底层软件或者驱动部分的软件，在应用层的软件一般不会直接操作芯片的寄存器，大多是使用底软开放的API接口)
寄存器简介 寄存器它们同时受到软件和硬件的控制和访问，用于实现数据的传输、处理和存储，并在软硬件之间传递信息。
软件可以使用指令来访问寄存器，以读取或写入数据或状态信息，而硬件则通过总线连接寄存器。
做soc或者ip验证，验证工作常见的可能就是配寄存器，调试配置的顺序。（是的，SOCFPGA验证，呜呜呜）
比如软件改变看门狗的计数周期，需要向模块寄存器写操作；
软件读取芯片内部温度，则需要读取模块的寄存器。
一个寄存器占据一个地址单位，宽度一般为8bit、16bit、32bit等。而且一般会包含多个位域(field)，不同的field代表不同的逻辑功能。
一般来说，一个寄存器中的多个位域具有业务相关性，但也不一定是。比如考虑面积因素，也可以将多个不相关的field放在一起，在soc的一些misc模块比较常见。 （之前总有一些misc模块，我说这个名字是啥意思来着，这模块怎么什么都能干）
不同的寄存器类型也即代表了业务类型的差别，以及软硬交互的特点。
寄存器类型多样性 使用场景区分 寄存器按照使用场景或者业务划分，可以分为如下几类：
中断寄存器 中断寄存器是很常见一种类型寄存器，指模块产生中断信号送给Core之后，软件在中断响应函数里，会进行一系列中断寄存器的查询、判断和清除动作。
常见的中断配套寄存器有：
enable寄存器，控制是否产生中断信号。mask寄存器，屏蔽或打开中断。raw寄存器，指示mask之前的中断状态。sta寄存器，指示mask之后的中断标志。clr寄存器，中断清除寄存器。 参数配置寄存器 几乎所有的module都会有参数配置模块，定时器的周期参数，滤波器的系数，总线idle等待cycle数，缓存大小配置，PLL的分频比参数等等。
参数配置寄存器一般跟业务强相关，有的参数可能还会有些约束，比如两个寄存器配置值之间需要满足大小关系，时钟分频比需要和业务模式一致等。
关于参数配置寄存器，有一类需要重点关注的特性，动/静态配置属性。
1、静态参数。有些参数需要在业务启动前配置好，工作过程中保持稳定。此类参数的设计、验证难度尚可，只要根据约束配置即可。 2、动态参数。某些参数是可以在一次业务中进行改配的，软件根据需要实时刷新参数。此类参数的设计、验证复杂度比较高。
设计中需要考虑参数变化的锁存问题；验证则需要考虑参数动态变化的时刻位置，变化时刻位置不准，经常会导致RTL和RM的计算不一致。 系统控制寄存器 还有一类寄存器用于系统的启动及其他状态控制，比如：
系统时钟选择寄存器core启动模式配置寄存器电源域isolation使能寄存器IP模块外部使能控制寄存器 此类寄存器不能放在各IP内部，一般在SOC中实现，用于系统的场景化配置。而且系统控制寄存器没有太多“随机化”的需求，大多和系统的实际场景需求保持一致即可。
时钟/复位寄存器 时钟和复位相关的寄存器也是芯片中一类重要的寄存器，这些寄存器控制着各个子系统或IP模块的时钟/复位信号的产生和关闭。
芯片的时钟和复位结构对中后端实现影响较大，时钟的频率、同步/异步时钟域、复位结构一般也会和中后端达成一致。
时钟/复位相关一般包括如下几类寄存器：
时钟使能，去使能寄存器复位，解复位寄存器时钟使能状态上报寄存器复位状态上报寄存器时钟分频比配置寄存器 时钟/复位寄存器在设计和验证需要关注如下几点：
时钟/复位寄存器的默认值。该默认值如果设置的不合理，子系统或者core没有工作时钟，芯片无法boot。时钟选择模块的无毛刺设计**。对于时钟切换的模块，必须保证在切换过程中无毛刺，一般情况，对于时钟切换，也会有严格的切换配置流程，不能随意动态切换。** dummy寄存器 子系统或者IP模块内部都会预留一些dummy寄存器，一般情况下不会使用。如果有，可能会有如下的使用需求：
软件debug使用。如果在软件调试中，觉得某个IP模块或者系统总线访问有问题，可以对这些dummy寄存器进行读写测试，以排除一些总线通路问题。
ECO预留使用。在RTL freeze之后，如果有bug需要修复，只能通过ECO方式直接修改netlist，此时预留的一些dummy寄存器可以派上用场，做出新的逻辑或者连线等等。
根据修复内容类别来分类，可以分为功能ECO和Timing ECO。功能ECO是修改芯片逻辑功能，Timing ECO是修复Setup/hold Time。 功能ECO可以手改，也可以用工具，比如cadence conformal eco，nandigits的gof eco。 Timing ECO可以直接在后端工具（Innovus、ICC/ICC2）里改，也可以用PrimeTime等STA工具来自动Fix，还可以手工Fix一小部分（有时Timing不满足，也可能是Transition或者cap太大）。 当然如果Timing相差太大，就需要从芯片架构、时钟树结构等方面进一步优化。也可能是达到了工艺的速度极限，该换工艺了。 根据芯片是否已流片，可以分为PreMask ECO和PostMask ECO。Mask就是光罩的意义，制造光罩之前和之后。PreMask ECO可以改动制造的所有的层，而PostMask ECO只能更改金属层，甚至指定的少数金属层。 在芯片设计时，总有一些不确定性，我们就需要考虑预留多种备选方案。比如，提前预留OTP/MTP来trim电路参数和逻辑，私有寄存器来切换备选功能和模式，利用TOP Metal Option、EEPROM、Flash等也是常见好用的方法。只要BUG能用软件修复或者绕过去，或者降低工作时钟频率，或者调节Process corner，反正不影响客户使用的芯片就是好芯片。实在有些影响的小BUG，让销售降低点价格也行。 ———————————————— 版权声明：本文为CSDN博主「NanDigits」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/77e3e44a767ee39d1f4bdf765ee6939d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-22T12:06:50+08:00" />
<meta property="article:modified_time" content="2023-06-22T12:06:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【转】探究芯片中的寄存器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>转前辈博客：https://mp.weixin.qq.com/s/VVzDYlFRrOywS9i-cwUXgA</p> 
<h2><a id="_2"></a>前言</h2> 
<p>作为一个芯片相关行业的从业者，有时候一直好奇我口中的嵌入式的角度去配置的寄存器，和芯片设计人员口中的寄存器是不是一个东西，正好看见前辈发了这个文章。希望关注的前辈早点更新下一篇，下面来学习一下。</p> 
<p>芯片设计中，寄存器(register)基本上是随处可见。<strong>无论是承担软件配置的寄存器</strong>，还是<strong>硬件状态上报的寄存器</strong>，亦或是其他类型的寄存器，<strong>在芯片的软/硬交互中，起到了桥梁的作用。</strong></p> 
<p>(这里的<strong>register指对软件或者core可见的寄存器</strong>。<strong>在芯片内部还存在数量巨大的内部register，但只是芯片工作中的硬件信息存储，core或者软件不可见</strong>)</p> 
<p>(这里的软件指底层软件或者驱动部分的软件，在应用层的软件一般不会直接操作芯片的寄存器，大多是使用底软开放的API接口)</p> 
<h2><a id="_11"></a>寄存器简介</h2> 
<p>寄存器它们同时受到软件和硬件的控制和访问，用于实现数据的传输、处理和存储，<strong>并在软硬件之间传递信息</strong>。</p> 
<p><strong>软件可以使用指令来访问寄存器，以读取或写入数据或状态信息，而硬件则通过总线连接寄存器。</strong></p> 
<p>做soc或者ip验证，<strong>验证工作常见的可能就是配寄存器，调试配置的顺序</strong>。（是的，SOCFPGA验证，呜呜呜）</p> 
<p><strong>比如软件改变看门狗的计数周期，需要向模块寄存器写操作</strong>；</p> 
<p><strong>软件读取芯片内部温度，则需要读取模块的寄存器</strong>。</p> 
<p><img src="https://images2.imgbox.com/78/10/uhBSQXoI_o.png" alt="在这里插入图片描述"><br> <strong>一个寄存器占据一个地址单位，宽度一般为8bit、16bit、32bit等</strong>。而且一般会包含多个位域(field)，不同的field代表不同的逻辑功能。</p> 
<p>一般来说，<strong>一个寄存器中的多个位域具有业务相关性</strong>，但也不一定是。比如考虑面积因素，<strong>也可以将多个不相关的field放在一起，在soc的一些misc模块比较常见。</strong> （之前总有一些misc模块，我说这个名字是啥意思来着，这模块怎么什么都能干）</p> 
<p>不同的寄存器类型也即代表了业务类型的差别，以及软硬交互的特点。</p> 
<h2><a id="_31"></a>寄存器类型多样性</h2> 
<h3><a id="_32"></a>使用场景区分</h3> 
<p>寄存器按照使用场景或者业务划分，可以分为如下几类：</p> 
<h4><a id="_35"></a>中断寄存器</h4> 
<p>中断寄存器是很常见一种类型寄存器，<strong>指模块产生中断信号送给Core之后</strong>，软件在中断响应函数里，会进行<strong>一系列中断寄存器的查询、判断和清除动作</strong>。</p> 
<p>常见的中断配套寄存器有：</p> 
<ul><li>enable寄存器，控制是否产生中断信号。</li><li>mask寄存器，屏蔽或打开中断。</li><li>raw寄存器，指示mask之前的中断状态。</li><li>sta寄存器，指示mask之后的中断标志。</li><li>clr寄存器，中断清除寄存器。</li></ul> 
<p><img src="https://images2.imgbox.com/de/1f/XKD0EQFc_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_49"></a>参数配置寄存器</h4> 
<p>几乎所有的module都会有参数配置模块，定时器的周期参数，滤波器的系数，总线idle等待cycle数，缓存大小配置，PLL的分频比参数等等。</p> 
<p>参数配置寄存器一般跟业务强相关，<strong>有的参数可能还会有些约束，比如两个寄存器配置值之间需要满足大小关系，时钟分频比需要和业务模式一致等</strong>。</p> 
<p><strong>关于参数配置寄存器，有一类需要重点关注的特性，动/静态配置属性。</strong></p> 
<ul><li>1、静态参数。<strong>有些参数需要在业务启动前配置好，工作过程中保持稳定</strong>。此类参数的设计、验证难度尚可，只要根据约束配置即可。</li></ul> 
<p><img src="https://images2.imgbox.com/13/ab/a2IOLzDW_o.png" alt="在这里插入图片描述"></p> 
<ul><li>2、动态参数。<strong>某些参数是可以在一次业务中进行改配的，软件根据需要实时刷新参数</strong>。此类参数的设计、验证复杂度比较高。<br> 设计中需要考虑参数变化的锁存问题；验证则需要考虑参数动态变化的时刻位置，<strong>变化时刻位置不准，经常会导致RTL和RM的计算不一致。</strong></li></ul> 
<h4><a id="_64"></a>系统控制寄存器</h4> 
<p>还有一类寄存器用于系统的启动及其他状态控制，比如：</p> 
<ul><li>系统时钟选择寄存器</li><li>core启动模式配置寄存器</li><li>电源域isolation使能寄存器</li><li>IP模块外部使能控制寄存器</li></ul> 
<p><strong>此类寄存器不能放在各IP内部，一般在SOC中实现，用于系统的场景化配置</strong>。而且系统控制寄存器没有太多“随机化”的需求，大多和系统的实际场景需求保持一致即可。</p> 
<h4><a id="_76"></a>时钟/复位寄存器</h4> 
<p><strong>时钟和复位相关的寄存器也是芯片中一类重要的寄存器，这些寄存器控制着各个子系统或IP模块的时钟/复位信号的产生和关闭。</strong></p> 
<p>芯片的时钟和复位结构对中后端实现影响较大，时钟的频率、同步/异步时钟域、复位结构一般也会和中后端达成一致。</p> 
<p>时钟/复位相关一般包括如下几类寄存器：</p> 
<ul><li>时钟使能，去使能寄存器</li><li>复位，解复位寄存器</li><li>时钟使能状态上报寄存器</li><li>复位状态上报寄存器</li><li>时钟分频比配置寄存器</li></ul> 
<p>时钟/复位寄存器在设计和验证需要关注如下几点：</p> 
<ul><li>时钟/复位寄存器的默认值。该默认值如果设置的不合理，子系统或者core没有工作时钟，芯片无法boot。</li><li>时钟选择模块的无毛刺设计**。对于时钟切换的模块，必须保证在切换过程中无毛刺，一般情况，对于时钟切换，也会有严格的切换配置流程，不能随意动态切换。**</li></ul> 
<h4><a id="dummy_98"></a>dummy寄存器</h4> 
<p>子系统或者IP模块内部都会预留一些<strong>dummy寄存器，一般情况下不会使用。如果有，可能会有如下的使用需求：</strong></p> 
<ul><li> <p>软件debug使用。如果在软件调试中，觉得某个IP模块或者系统总线访问有问题，可以对这些dummy寄存器进行读写测试，以排除一些总线通路问题。</p> </li><li> <p>ECO预留使用。在RTL freeze之后，如果有bug需要修复，只能通过ECO方式直接修改netlist，此时预留的一些dummy寄存器可以派上用场，做出新的逻辑或者连线等等。</p> </li></ul> 
<pre><code>根据修复内容类别来分类，可以分为功能ECO和Timing ECO。功能ECO是修改芯片逻辑功能，Timing ECO是修复Setup/hold Time。
功能ECO可以手改，也可以用工具，比如cadence conformal eco，nandigits的gof eco。
Timing ECO可以直接在后端工具（Innovus、ICC/ICC2）里改，也可以用PrimeTime等STA工具来自动Fix，还可以手工Fix一小部分（有时Timing不满足，也可能是Transition或者cap太大）。

当然如果Timing相差太大，就需要从芯片架构、时钟树结构等方面进一步优化。也可能是达到了工艺的速度极限，该换工艺了。

根据芯片是否已流片，可以分为PreMask ECO和PostMask ECO。Mask就是光罩的意义，制造光罩之前和之后。PreMask ECO可以改动制造的所有的层，而PostMask ECO只能更改金属层，甚至指定的少数金属层。

在芯片设计时，总有一些不确定性，我们就需要考虑预留多种备选方案。比如，提前预留OTP/MTP来trim电路参数和逻辑，私有寄存器来切换备选功能和模式，利用TOP Metal Option、EEPROM、Flash等也是常见好用的方法。只要BUG能用软件修复或者绕过去，或者降低工作时钟频率，或者调节Process corner，反正不影响客户使用的芯片就是好芯片。实在有些影响的小BUG，让销售降低点价格也行。
————————————————
版权声明：本文为CSDN博主「NanDigits」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/NanDigits/article/details/122888385
</code></pre> 
<p><img src="https://images2.imgbox.com/97/16/b3Z6AC1G_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_122"></a>寄存器属性区分</h3> 
<p>从对寄存器的访问方向来看，<strong>有写寄存器和读寄存器之分</strong>。这个比较好理解，<strong>写寄存器就是core或者软件向硬件寄存器写数据，</strong> 读<strong>寄存器就是core或软件从硬件寄存器中读取数据</strong>。</p> 
<p><img src="https://images2.imgbox.com/cd/52/ONNaWsW2_o.png" alt="在这里插入图片描述"><br> 这里需要注意，总线上对寄存器读写的数据和寄存器存储的值(寄存器域值)，并不总是一致的，这和寄存器的类型属性有关，即上图中的process部分的代码逻辑相关。</p> 
<p><strong>process code也正是寄存器属性类型众多的原因所在：读写操作对寄存器域值的影响不一。</strong></p> 
<h4><a id="UVM_131"></a>UVM中的寄存器类型</h4> 
<p>UVM定义的寄存器访问属性共有25个，其含义如下：</p> 
<ul><li>RO<br> 只读寄存器，写操作不影响寄存器域值；</li></ul> 
<p>读操作时，总线上的读数据等于寄存器域值。</p> 
<p><strong>一般用于芯片的状态上报，如中断的sta、raw寄存器。</strong></p> 
<ul><li>RW<br> 可读写寄存器。<strong>写操作时，寄存器域值将会更新为总线上的写数据；读操作时，总线读数据等于寄存器域值。</strong></li></ul> 
<p>此类型的寄存器，可能是芯片中应用最为广泛的寄存器类型，像参数配置寄存器、dummy寄存器等，一般都是RW类型。</p> 
<ul><li> <p>RC/RS<br> 读清/读置位-寄存器。写操作对寄存器域值没有影响。</p> 
  <ul><li> <p>RC：读操作时，<strong>会首先将寄存器的域值传输给总线，然后将寄存器的域值清零</strong>。</p> </li><li> <p>RS：读操作时，<strong>会首先将寄存器的域值传输给总线，然后将寄存器的域值置为1。</strong></p> </li></ul> <p>RC寄存器从某种意义上讲，减轻了软件的操作负载，只需要发起一笔读操作，就可以完成寄存器域值的获取和清除的效果。</p> </li><li> <p>WRC/WRS<br> 读清/读置位-可写-寄存器。</p> 
  <ul><li> <p>WRC：写操作会将寄存器域值更新为总线上的写数据；读操作效果同RC。</p> </li><li> <p>WRS：和RS相比，写操作会将寄存器域值更新为总线上的写数据；读操作效果同RS。</p> </li></ul> </li><li> <p>WC/WS<br> 写清/写置位-寄存器。读操作将寄存器域值读出，寄存器域值本身不变。</p> 
  <ul><li> <p>WC：进行写操作时，会将寄存器域值清零。</p> </li><li> <p>WS：进行写操作时，会将寄存器域值置1。</p> </li></ul> </li><li> <p>WSRC/WCRS<br> 写置位/写清-读清/读置位-寄存器。</p> 
  <ul><li>WSRC：写操作效果同WS，读操作效果同RC。</li><li>WCRS：写操作效果同WC，读操作效果同RS。</li></ul> </li><li> <p>W1C/W0C/W1S/W0S<br> 写1/0清/写1/0置位-寄存器。读操作将寄存器域值读出，寄存器域值本身不变。</p> 
  <ul><li> <p>W1C：写1时，将寄存器域值清零。</p> </li><li> <p>W1S：写1时，将寄存器域值置1。</p> </li><li> <p>W0C：写0时，将寄存器域值清零。</p> </li><li> <p>W0S：写0时，将寄存器域值置1。</p> </li></ul> </li><li> <p>W1T/W0T<br> 写1/写0-翻转寄存器。读操作将寄存器域值读出，寄存器域值本身不变。</p> 
  <ul><li>W1T：写1时，会将寄存器的域值进行翻转。</li><li>W0T：写0时，会将寄存器的域值进行翻转。</li></ul> </li><li> <p>W1SRC/W0SRC,W1CRS/W0CRS</p> 
  <ul><li> <p>W1SRC：写1置位读清寄存器。写1时，将寄存器域值置1；读操作将寄存器域值读出，同时将寄存器域值清零。</p> </li><li> <p>W0SRC：写0置位读清寄存器。写0时，将寄存器域值置位；读操作将寄存器域值读出，同时将寄存器域值清零。</p> </li><li> <p>W1CRS：写1清零读置位寄存器。写1时，将寄存器域值清零；读操作将寄存器域值读出，同时将寄存器域值置1。</p> </li><li> <p>W0CRS：写0清零读置位寄存器。写0时，将寄存器域值清零；读操作将寄存器域值读出，同时将寄存器域值置1。</p> </li></ul> </li><li> <p>WO<br> 只写寄存器。写操作将寄存器域值更新，读操作时出错。</p> </li><li> <p>WOC/WOS<br> 只写清/置位-寄存器。读操作时出错。</p> 
  <ul><li> <p>WOC：写操作将寄存器域值清零。</p> </li><li> <p>WOS：写操作将寄存器域值置1。</p> </li></ul> </li><li> <p>W1<br> 写1次寄存器。读操作将寄存器域值读出，寄存器域值不变；解除复位后，第一次写，寄存器域值更新，后续的写操作无影响，不改变寄存器域值。</p> </li><li> <p>WO1<br> 只写1次寄存器。读操作将会报错；解除复位后，第一次写，寄存器域值更新，后续的写操作无影响，不改变寄存器域值。</p> </li></ul> 
<h4><a id="_217"></a>其他寄存器类型</h4> 
<p>除了UVM中介绍的25钟寄存器以外，还有一些其他的寄存器类型，介绍如下。</p> 
<ul><li>mask读写寄存器<br> 如果担心由于软件误操作，**会将寄存器进行误改写，寄存器可以设计成mask写。**在一个寄存器内，同时设有field位域和field对应得mask bit位，只有field对应得bit位写1时，才可以将field的域值更新。</li></ul> 
<p>比如reg0：bit[31:16] len_mask bit[15:0]<br> len 只有当reg0写入32‘hFFFF_5A5A时，才可以将len配置为5A5A，直接写5A5A不会生效。</p> 
<ul><li> <p>lock寄存器<br> **担心软件误操作的另外一种办法是设置lock寄存器，**只有lock寄存器配置为1或者0，<strong>其他寄存器才可以写入。lock寄存器会控制某个IP模块或部分寄存器，lock寄存器本身大多数是RW类型。</strong></p> </li><li> <p>脉冲寄存器<br> 和W1T/W0T寄存器不同，pulse寄存器被写入后，会产生一个脉冲信号。<strong>此类寄存器可以用于软件主动产生一个脉冲中断，或者用于启动业务模块。</strong></p> </li><li> <p>set/clr/sta寄存器<br> 一个寄存器中包含多个位域，仅向其中某一个位域写数据时，如果时RW类型寄存器，则需要实时记录寄存器的域值或者先将寄存器值读出，将部分bit值进行改写，才可以达到只修改部分位域，不影响其他位域的效果。</p> </li></ul> 
<p>对于此，set/clr寄存器的操作会简单很多，某个寄存器配套set寄存器，clr寄存器以及sta寄存器。<br> <img src="https://images2.imgbox.com/9c/58/aRMjpEoD_o.png" alt="在这里插入图片描述"><br> 当set寄存器的bit写1时，对应位域置1，写0时不影响；</p> 
<p>clr寄存器的bit写1时，对应位域清零，写0时不影响。</p> 
<p>读sta寄存器则将会将寄存器值读出，不影响寄存器的域值。</p> 
<h2><a id="_244"></a>芯片验证中的寄存器测试</h2> 
<h3><a id="_245"></a>寄存器地址排布</h3> 
<h4><a id="_247"></a>业务相关性</h4> 
<p>寄存器业务相关性排布有两个原则：</p> 
<ul><li>同一个寄存器内的不同位域尽量具有业务相关性；</li><li>业务相关的寄存器组，尽量连续排布，<strong>便于总线的burst操作</strong>，提高访问效率；</li></ul> 
<h4><a id="_253"></a>位域类型一致性</h4> 
<p>同一个寄存器内的不同位域的类型尽量保持一致，这样利于软件操作和DV验证。</p> 
<h4><a id="_256"></a>地址空洞</h4> 
<p>寄存器排布时尽量减少寄存器地址之间的空洞，把不使用的地址空间放到尾部。</p> 
<h4><a id="_259"></a>相邻寄存器类型</h4> 
<p>对于读清寄存器，其前后尽量避免带有R类型的寄存器。在某些总线系统内，对于非总线宽度的非对齐访问，可能会多读。</p> 
<h3><a id="DV_263"></a>DV的寄存器模型</h3> 
<p>UVM中的寄存器模式给寄存器测试带来了便捷，在block、SOC的验证中经常使用。关于UVM寄存器模型的细节不在此叙述，倒是想讲一讲UVM寄存器模型的缺点。</p> 
<ul><li>在大规模的SOC或芯片中，UVM寄存器模型的仿真内存负载不可忽视；UVM寄存器模型中，每个位域都会创建一个class对象；</li><li>寄存器变动需要重新编译，由于寄存器信息在编译阶段就已经固化了，所以一旦有改动，就需要重新编译TB；</li><li>API接口“过于丰富”，write，update，peek，poke…</li></ul> 
<p>在一些公司中，也会自行编写寄存器模型，和实际业务相结合，提升寄存器模型的存储、访问和迭代效率。</p> 
<h3><a id="_273"></a>寄存器测试关注点</h3> 
<p>uvm reg中的寄存器测试sequence有如下几种：</p> 
<p><img src="https://images2.imgbox.com/08/83/V2kQGXXQ_o.png" alt="在这里插入图片描述"><br> 除此外，还有些corner可以关注：</p> 
<ul><li>只要读或写不回error，<strong>尽量都对所有寄存器都进行读写操作；</strong></li><li><strong>地中空洞需要测试，尤其关注无效地址读操作的返回值；无效地址范围较大时，选择头、尾和中间即可；</strong></li><li><strong>对于地址排布相邻的不同module，覆盖burst操作跨module的corner</strong>；</li></ul> 
<h3><a id="_284"></a>寄存器的自动化工具</h3> 
<p>常见的寄存器相关工具有systemRDL和relgen。</p> 
<p>SystemRDL 是一种寄存器描述语言，由Accellera标准组织发布，通<strong>过一些工具可以自动化产生verilog代码和UVM寄存器模型。</strong></p> 
<p>ralgen则是VCS自带的工具，通过解析ralf格式的寄存器描述文件，可以产生uvm寄存器模型。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/286b74340fb7a1204ae68746f4a27c54/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux基础（二）—— 怎么在VMware/WSL中安装Ubuntu系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f2a3ca55a0e02238118b2807fdbab57/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot&#43;MinIO 实现文件上传、读取、下载、删除</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>