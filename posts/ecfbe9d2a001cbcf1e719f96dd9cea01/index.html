<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>stm32学习笔记---ADC电压采集 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="stm32学习笔记---ADC电压采集" />
<meta property="og:description" content="1. ①电压输入范围
ADC 输入范围为：VREF- ≤ VIN ≤ VREF&#43;。由 VREF-、VREF&#43; 、VDDA 、VSSA、这四个外部
引脚决定。
我们在设计原理图的时候一般把 VSSA 和 VREF-接地，把 VREF&#43;和 VDDA 接 3V3，得到
ADC 的输入电压范围为：0~3.3V。
如果我们想让输入的电压范围变宽，去到可以测试负电压或者更高的正电压，我们可
以在外部加一个电压调理电路，把需要转换的电压抬升或者降压到 0~3.3V，这样 ADC 就
可以测量了。
2. ②输入通道
我们确定好 ADC 输入电压之后，那么电压怎么输入到 ADC？这里我们引入通道的概念，
STM32 的 ADC 多达 18 个通道，其中外部的 16 个通道就是框图中的 ADCx_IN0 、
ADCx_IN1...ADCx_IN5。这 16 个通道对应着不同的 IO 口，具体是哪一个 IO 口可以从手
册查询到。其中 ADC1/2/3 还有内部通道：ADC1 的通道 16 连接到了芯片内部的温度传感
器，Vrefint 连接到了通道 17。ADC2 的模拟通道 16 和 17 连接到了内部的 VSS。
ADC3 的模拟通道 9、14、15、16 和 17 连接到了内部的 VSS。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ecfbe9d2a001cbcf1e719f96dd9cea01/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-12T22:03:05+08:00" />
<meta property="article:modified_time" content="2018-09-12T22:03:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">stm32学习笔记---ADC电压采集</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" class="has" height="196" src="https://images2.imgbox.com/11/04/i2Bu3Zfj_o.png" width="802"></p> 
<p><img alt="" class="has" height="748" src="https://images2.imgbox.com/4b/3b/qvW4ucCn_o.png" width="573"></p> 
<p> 1.  ①电压输入范围<br> ADC 输入范围为：VREF- ≤ VIN ≤ VREF+。由 VREF-、VREF+ 、VDDA 、VSSA、这四个外部<br> 引脚决定。<br> 我们在设计原理图的时候一般把 VSSA 和 VREF-接地，把 VREF+和 VDDA 接 3V3，得到<br> ADC 的输入电压范围为：0~3.3V。<br> 如果我们想让输入的电压范围变宽，去到可以测试负电压或者更高的正电压，我们可<br> 以在外部加一个电压调理电路，把需要转换的电压抬升或者降压到 0~3.3V，这样 ADC 就<br> 可以测量了。<br> 2.  ②输入通道<br> 我们确定好 ADC 输入电压之后，那么电压怎么输入到 ADC？这里我们引入通道的概念，<br> STM32 的 ADC 多达 18 个通道，其中外部的 16 个通道就是框图中的 ADCx_IN0 、<br> ADCx_IN1...ADCx_IN5。这 16 个通道对应着不同的 IO 口，具体是哪一个 IO 口可以从手<br> 册查询到。其中 ADC1/2/3 还有内部通道：ADC1 的通道 16 连接到了芯片内部的温度传感<br> 器，Vrefint 连接到了通道 17。ADC2 的模拟通道 16 和 17 连接到了内部的 VSS。<br> ADC3 的模拟通道 9、14、15、16 和 17 连接到了内部的 VSS。</p> 
<p><img alt="" class="has" height="411" src="https://images2.imgbox.com/58/2c/YL0ctmve_o.png" width="658"></p> 
<p>外部的 16 个通道在转换的时候又分为规则通道和注入通道，其中规则通道最多有 16<br> 路，注入通道最多有 4 路。那这两个通道有什么区别？在什么时候使用？<br> 规则通道<br> 规则通道：顾名思意，规则通道就是很规矩的意思，我们平时一般使用的就是这个通<br> 道，或者应该说我们用到的都是这个通道，没有什么特别要注意的可讲。</p> 
<p>注入通道<br> 注入，可以理解为插入，插队的意思，是一种不安分的通道。它是一种在规则通道转<br> 换的时候强行插入要转换的一种。如果在规则通道转换过程中，有注入通道插队，那么就<br> 要先转换完注入通道，等注入通道转换完成后，再回到规则通道的转换流程。这点跟中断<br> 程序很像，都是不安分的主。所以，注入通道只有在规则通道存在时才会出现。<br> 3.  ③转换顺序<br> 规则序列<br> 规则序列寄存器有 3 个，分别为 SQR3、SQR2、SQR1。SQR3 控制着规则序列中的第<br> 一个到第六个转换，对应的位为：SQ1[4:0]~SQ6[4:0]，第一次转换的是位 4:0 SQ1[4:0]，如<br> 果通道 16 想第一次转换，那么在 SQ1[4:0]写 16 即可。SQR2 控制着规则序列中的第 7 到第<br> 12 个转换，对应的位为：SQ7[4:0]~SQ12[4:0]，如果通道 1 想第 8 个转换，则 SQ8[4:0]写 1<br> 即可。SQR1 控制着规则序列中的第 13 到第 16 个转换，对应位为：SQ13[4:0]~SQ16[4:0]，<br> 如果通道 6 想第 10 个转换，则 SQ10[4:0]写 6 即可。具体使用多少个通道，由 SQR1 的位<br> L[3:0]决定，最多 16 个通道。</p> 
<p><img alt="" class="has" height="518" src="https://images2.imgbox.com/ab/c8/yixGOVlH_o.png" width="667"></p> 
<p>注入序列<br> 注入序列寄存器 JSQR 只有一个，最多支持 4 个通道，具体多少个由 JSQR 的 JL[2:0]<br> 决定。如果 JL 的  值小于 4 的话，则 JSQR 跟 SQR 决定转换顺序的设置不一样，第一次转<br> 换的不是 JSQR1[4:0]，而是 JCQRx[4:0] ，x = （4-JL），跟 SQR 刚好相反。如果 JL=00（1</p> 
<p>个转换），那么转换的顺序是从 JSQR4[4:0]开始，而不是从 JSQR1[4:0]开始，这个要注意，<br> 编程的时候不要搞错。当 JL 等于 4 时，跟 SQR 一样。</p> 
<p><img alt="" class="has" height="243" src="https://images2.imgbox.com/9b/a8/IYmp3jrw_o.png" width="688"></p> 
<p>4.  ④触发源<br> 通道选好了，转换的顺序也设置好了，那接下来就该开始转换了。ADC 转换可以由<br> ADC 控制寄存器 2:  ADC_CR2 的 ADON 这个位来控制，写 1 的时候开始转换，写 0 的时候<br> 停止转换，这个是最简单也是最好理解的开启 ADC 转换的控制方式，理解起来没啥技术含<br> 量。<br> 除了这种庶民式的控制方法，ADC 还支持触发转换，这个触发包括内部定时器触发和<br> 外部 IO 触发。触发源有很多，具体选择哪一种触发源，由 ADC 控制寄存器 2:ADC_CR2 的<br> EXTSEL[2:0] 和 JEXTSEL[2:0] 位 来控制 。 EXTSEL[2:0] 用于 选择 规则 通道 的触发源，<br> JEXTSEL[2:0]用于选择注入通道的触发源。选定好触发源之后，触发源是否要激活，则由<br> ADC 控制寄存器 2:ADC_CR2 的 EXTTRIG 和 JEXTTRIG 这两位来激活。其中 ADC3 的规则<br> 转换和注入转换的触发源与 ADC1/2 的有所不同，在框图上已经表示出来。<br> 5.  ⑤转换时间<br> ADC 时钟<br> ADC 输入时钟 ADC_CLK 由 PCLK2 经过分频产生，最大是 14M，分频因子由 RCC 时<br> 钟配置寄存器 RCC_CFGR 的位 15:14   ADCPRE[1:0]设置，可以是 2/4/6/8 分频，注意这里<br> 没有 1 分频。一般我们设置 PCLK2=HCLK=72M。<br> 采样时间<br> ADC 使用若干个 ADC_CLK 周期对输入的电压进行采样，采样的周期数可通过 ADC <br> 采样时间寄存器 ADC_SMPR1 和 ADC_SMPR2 中的 SMP[2:0]位设置，ADC_SMPR2 控制<br> 的是通道 0~9，ADC_SMPR1 控制的是通道 10~17。每个通道可以分别用不同的时间采样。<br> 其中采样周期最小是 1.5 个，即如果我们要达到最快的采样，那么应该设置采样周期为 1.5<br> 个周期，这里说的周期就是 1/ADC_CLK。</p> 
<p>ADC 的转换时间跟 ADC 的输入时钟和采样时间有关，公式为：Tconv  =  采样时间  + <br> 12.5 个周期。当 ADCLK  =  14MHZ  （最高），采样时间设置为 1.5 周期（最快），那么总<br> 的转换时间（最短）Tconv = 1.5 周期 + 12.5 周期 = 14 周期 = 1us。<br> 一般我们设置 PCLK2=72M，经过 ADC 预分频器能分频到最大的时钟只能是 12M，采<br> 样周期设置为 1.5 个周期，算出最短的转换时间为 1.17us，这个才是最常用的。<br> 6.  ⑥数据寄存器<br> 一切准备就绪后，ADC 转换后的数据根据转换组的不同，规则组的数据放在 ADC_DR<br> 寄存器，注入组的数据放在 JDRx。<br> 规则数据寄存器<br> ADC 规则组数据寄存器 ADC_DR 只有一个，是一个 32 位的寄存器，低 16 位在单 ADC<br> 时使用，高 16 位是在 ADC1 中双模式下保存 ADC2 转换的规则数据，双模式就是 ADC1 和<br> ADC2 同时使用。在单模式下，ADC1/2/3 都不使用高 16 位。因为 ADC 的精度是 12 位，<br> 无论 ADC_DR 的高 16 或者低 16 位都放不满，只能左对齐或者右对齐，具体是以哪一种方<br> 式存放，由 ADC_CR2 的 11 位 ALIGN 设置。<br> 规则通道可以有 16 个这么多，可规则数据寄存器只有一个，如果使用多通道转换，那<br> 转换的数据就全部都挤在了 DR 里面，前一个时间点转换的通道数据，就会被下一个时间<br> 点的另外一个通道转换的数据覆盖掉，所以当通道转换完成后就应该把数据取走，或者开<br> 启 DMA 模式，把数据传输到内存里面，不然就会造成数据的覆盖。最常用的做法就是开<br> 启 DMA 传输。<br> 注入数据寄存器<br> ADC 注入组最多有 4 个通道，刚好注入数据寄存器也有 4 个，每个通道对应着自己的<br> 寄存器，不会跟规则寄存器那样产生数据覆盖的问题。ADC_JDRx 是 32 位的，低 16 位有<br> 效，高 16 位保留，数据同样分为左对齐和右对齐，具体是以哪一种方式存放，由<br> ADC_CR2 的 11 位 ALIGN 设置。<br> 7.  ⑦中断<br> 转换结束中断<br> 数据转换结束后，可以产生中断，中断分为三种：规则通道转换结束中断，注入转换<br> 通道转换结束中断，模拟看门狗中断。其中转换结束中断很好理解，跟我们平时接触的中<br> 断一样，有相应的中断标志位和中断使能位，我们还可以根据中断类型写相应配套的中断<br> 服务程序。<br> 模拟看门狗中断<br> 当被 ADC 转换的模拟电压低于低阈值或者高于高阈值时，就会产生中断，前提是我<br> 们开启了模拟看门狗中断，其中低阈值和高阈值由 ADC_LTR 和 ADC_HTR 设置。例如我</p> 
<p>们设置高阈值是 2.5V，那么模拟电压超过 2.5V 的时候，就会产生模拟看门狗中断，反之<br> 低阈值也一样。<br> DMA 请求<br> 规则和注入通道转换结束后，除了产生中断外，还可以产生 DMA 请求，把转换好的<br> 数据直接存储在内存里面。要注意的是只有 ADC1 和 ADC3 可以产生 DMA 请求。有关<br> DMA 请求需要配合《STM32F10X-中文参考手册》DMA 控制器这一章节来学习。一般我<br> 们在使用 ADC 的时候都会开启 DMA 传输。<br> 8.  ⑧电压转换<br> 模拟电压经过 ADC 转换后，是一个 12 位的数字值，如果通过串口以 16 进制打印出来<br> 的话，可读性比较差，那么有时候我们就需要把数字电压转换成模拟电压，也可以跟实际<br> 的模拟电压（用万用表测）对比，看看转换是否准确。<br> 我们一般在设计原理图的时候会把 ADC 的输入电压范围设定在：0~3.3v，因为 ADC<br> 是 12 位的，那么 12 位满量程对应的就是 3.3V，12 位满量程对应的数字值是：2^12。数值<br> 0 对应的就是 0V。如果转换后的数值为  X ，X 对应的模拟电压为 Y，那么会有这么一个等<br> 式成立：  2^12 / 3.3 = X / Y，=&gt; Y = (3.3 * X ) / 2^12。</p> 
<p><img alt="" class="has" height="257" src="https://images2.imgbox.com/6d/7b/GkrAsZMW_o.png" width="379"></p> 
<p><img alt="" class="has" height="494" src="https://images2.imgbox.com/c8/06/tBme0Z8Y_o.png" width="672"></p> 
<p> <img alt="" class="has" height="141" src="https://images2.imgbox.com/bc/e4/8EtiTLsj_o.png" width="547"></p> 
<p><img alt="" class="has" height="359" src="https://images2.imgbox.com/4a/2b/dz8NXVxO_o.png" width="654"></p> 
<h4>31.4  独立模式单通道采集实验</h4> 
<pre class="has"><code>#include "bsp_adc.h"

static void ADCx_GPIO_Config(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	
	// 打开 ADC IO端口时钟
	ADC_GPIO_APBxClock_FUN ( ADC_GPIO_CLK, ENABLE );
	
	// 配置 ADC IO 引脚模式
	// 必须为模拟输入
	GPIO_InitStructure.GPIO_Pin = ADC_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
	
	// 初始化 ADC IO
	GPIO_Init(ADC_PORT, &amp;GPIO_InitStructure);	
}

static void ADCx_Mode_Config(void)
{
	ADC_InitTypeDef ADC_InitStruct;
	
	ADC_APBxClock_FUN ( ADC_CLK, ENABLE );
	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;
	ADC_InitStruct.ADC_ScanConvMode = DISABLE;
	ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;	
	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStruct.ADC_NbrOfChannel = 1;
	
	ADC_Init(ADC_x, &amp;ADC_InitStruct);
	
	RCC_ADCCLKConfig(RCC_PCLK2_Div8);
	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL, 1, ADC_SampleTime_55Cycles5);
	
	ADC_ITConfig(ADC_x, ADC_IT_EOC, ENABLE);
	ADC_Cmd(ADC_x, ENABLE);
	
  // ADC开始校准
	ADC_StartCalibration(ADC_x);
	// 等待校准完成
	while(ADC_GetCalibrationStatus(ADC_x));
	
	ADC_SoftwareStartConvCmd(ADC_x, ENABLE);
}

static void ADC_NVIC_Config(void)
{
  NVIC_InitTypeDef NVIC_InitStructure;
	// 优先级分组
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);

  // 配置中断优先级
  NVIC_InitStructure.NVIC_IRQChannel = ADC_IRQ;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&amp;NVIC_InitStructure);
}

void ADCx_Init(void)
{
	ADC_NVIC_Config();
	ADCx_GPIO_Config();
	ADCx_Mode_Config();
}</code></pre> 
<pre class="has"><code>
/**
  ******************************************************************************
  * @file    main.c
  * @author  fire
  * @version V1.0
  * @date    2013-xx-xx
  * @brief   串口中断接收测试
  ******************************************************************************
  * @attention
  *
  * 实验平台:秉火 F103-霸道 STM32 开发板 
  * 论坛    :http://www.firebbs.cn
  * 淘宝    :http://firestm32.taobao.com
  *
  ******************************************************************************
  */ 
 
 
#include "stm32f10x.h"
#include "bsp_usart.h"
#include "bsp_adc.h"


extern __IO uint16_t ADC_ConvertedValue;

// 局部变量，用于保存转换计算后的电压值 	 
float ADC_ConvertedValueLocal;        

// 软件延时
void Delay(__IO uint32_t nCount)
{
  for(; nCount != 0; nCount--);
} 

/**
  * @brief  主函数
  * @param  无
  * @retval 无
  */
int main(void)
{	
  /*初始化USART 配置模式为 115200 8-N-1，中断接收*/
  USART_Config();
	printf("欢迎使用秉火STM32开发板\n\n\n\n");
	
	ADCx_Init();
	
  while(1)
	{	
		ADC_ConvertedValueLocal =(float) ADC_ConvertedValue/4096*3.3; 
	
		printf("\r\n The current AD value = 0x%04X \r\n",ADC_ConvertedValue); 
		printf("\r\n The current AD value = %f V \r\n",ADC_ConvertedValueLocal); 
		printf("\r\n\r\n");

		Delay(0xffffee); 
	}	
}

// 作业

// 1-把程序改成 ADC1/3
// 2-换成其他的通道试一试











/*********************************************END OF FILE**********************/
</code></pre> 
<pre class="has"><code>void ADC_IRQHandler(void)
{
	if( ADC_GetITStatus(ADC_x, ADC_IT_EOC) == SET)
  {
		ADC_ConvertedValue = ADC_GetConversionValue(ADC_x);
	}
	ADC_ClearITPendingBit(ADC_x, ADC_IT_EOC);
}</code></pre> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/983fd01f81c1b1d12863bb51d63ad3c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">cnpm 搭建私有库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/abd6f36d0cdf4b921c743e6fca1270ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安卓开发 Fragment的简单使用与解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>