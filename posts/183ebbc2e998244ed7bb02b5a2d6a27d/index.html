<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【高级篇】Java JVM实战 之 内存调优 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【高级篇】Java JVM实战 之 内存调优" />
<meta property="og:description" content="文章目录 一、通过Jprofiler调式Dump文件错误⛅ 什么是Jprofiler？⚡使用Jprofiler调试Dump文件 二、堆内存调优三、 GC垃圾回收器四、GC常用算法❄️引用计数法⛄复制算法♨️标记清除算法⛽标记压缩⚠️标记清除压缩 五、JMM⛵小结 一、通过Jprofiler调式Dump文件错误 ⛅ 什么是Jprofiler？ JProfiler 是一个 用于分析运行JVM内部情况的专业工具。 在开发中你可以使用它，用于质量保证，也可以解决你的生产系统遇到的问题
JProfiler处理四个主要问题：
方法调用
这通常被称为&#34;CPU分析&#34;。方法调用可以通过不同的方式进行测量和可视化， 分析方法调用可以帮助了解你的应用程序正在做什么，并找到提高其性能的方法。
分配
分析堆上对象的分配、引用链和垃圾回收属于&#34;内存分析&#34;的范畴。 这个功能可以让你解决内存泄漏，总之使用更少的内存，分配更少的临时对象。
线程和锁
线程可以持有锁，例如通过在一个对象上做同步。当多个线程协作时，可能会出现死锁，JProfiler可以为你可视化这种情况。 此外，锁可能被争用，这意味着线程在获得锁之前必须等待。通过JProfiler可以深入了解线程及其各种锁情形。
高层子系统
许多性能问题发生在更高的语义层面。例如，对于JDBC调用，你可能想找出哪条SQL语句是最慢的。 对于这样的子系统，JProfiler提供了&#34;探针&#34;，将特定有效载荷附加到调用树。
JProfiler的UI是一个桌面应用程序。你可以以交互的方式实时分析JVM，也可以在不使用UI的情况下，自动化分析。 保存在快照中的分析数据，可以通过JProfiler UI打开。此外，命令行工具和构建工具集成可以帮助你自动分析会话。
⚡使用Jprofiler调试Dump文件 OOM错误
import java.util.ArrayList; //-Xms 设置初始化内存大小，默认是1/64 //-Xms 设置最大分配内存，默认是1/4 //-XX:&#43;PrintGCDetail 打印GC垃圾回收的相关信息 //-XX:&#43;HeapDumpOnOutOfMemoryError 打印OOM的错误，并Dump //-Xms1m -Xms8m -XX:&#43;HeapDumpOnOutOfMemoryError public class Demo03 { byte[] bytes = new byte[1*1024*1024]; public static void main(String[] args) { ArrayList&lt;Demo03&gt; objects = new ArrayList&lt;&gt;(); int count = 0; try { while (true) { objects." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/183ebbc2e998244ed7bb02b5a2d6a27d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-21T08:39:04+08:00" />
<meta property="article:modified_time" content="2022-11-21T08:39:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【高级篇】Java JVM实战 之 内存调优</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#JprofilerDump_1" rel="nofollow">一、通过Jprofiler调式Dump文件错误</a></li><li><ul><li><a href="#_Jprofiler_2" rel="nofollow">⛅ 什么是Jprofiler？</a></li><li><a href="#JprofilerDump_24" rel="nofollow">⚡使用Jprofiler调试Dump文件</a></li></ul> 
  </li><li><a href="#_92" rel="nofollow">二、堆内存调优</a></li><li><a href="#_GC_178" rel="nofollow">三、 GC垃圾回收器</a></li><li><a href="#GC_201" rel="nofollow">四、GC常用算法</a></li><li><ul><li><a href="#_203" rel="nofollow">❄️引用计数法</a></li><li><a href="#_209" rel="nofollow">⛄复制算法</a></li><li><a href="#_225" rel="nofollow">♨️标记清除算法</a></li><li><a href="#_235" rel="nofollow">⛽标记压缩</a></li><li><a href="#_243" rel="nofollow">⚠️标记清除压缩</a></li></ul> 
  </li><li><a href="#JMM_277" rel="nofollow">五、JMM</a></li><li><a href="#_330" rel="nofollow">⛵小结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="JprofilerDump_1"></a>一、通过Jprofiler调式Dump文件错误</h2> 
<h3><a id="_Jprofiler_2"></a>⛅ 什么是Jprofiler？</h3> 
<p>JProfiler 是一个 <strong>用于分析运行JVM内部情况的专业工具</strong>。 在<strong>开发中你可以使用它，用于质量保证，也可以解决你的生产系统遇到的问题</strong></p> 
<blockquote> 
 <p><strong>JProfiler处理四个主要问题</strong>：</p> 
</blockquote> 
<p><strong>方法调用</strong></p> 
<p>这通常被称为"CPU分析"。方法调用可以通过不同的方式进行测量和可视化， 分析方法调用可以帮助了解你的应用程序正在做什么，并找到提高其性能的方法。</p> 
<p><strong>分配</strong></p> 
<p>分析堆上对象的分配、引用链和垃圾回收属于"内存分析"的范畴。 这个功能可以让你解决内存泄漏，总之使用更少的内存，分配更少的临时对象。</p> 
<p><strong>线程和锁</strong></p> 
<p>线程可以持有锁，例如通过在一个对象上做同步。当多个线程协作时，可能会出现死锁，JProfiler可以为你可视化这种情况。 此外，锁可能被争用，这意味着线程在获得锁之前必须等待。通过JProfiler可以深入了解线程及其各种锁情形。</p> 
<p><strong>高层子系统</strong></p> 
<p>许多性能问题发生在更高的语义层面。例如，对于JDBC调用，你可能想找出哪条SQL语句是最慢的。 对于这样的子系统，JProfiler提供了"探针"，将特定有效载荷附加到调用树。</p> 
<p>JProfiler的<strong>UI是一个桌面应用程序</strong>。你可以<strong>以交互的方式实时分析JVM</strong>，也可以在不使用UI的情况下，自动化分析。 保存在快照中的分析数据，可以通过JProfiler UI打开。此外，<strong>命令行工具和构建工具集成可以帮助你自动分析会话。</strong></p> 
<h3><a id="JprofilerDump_24"></a>⚡使用Jprofiler调试Dump文件</h3> 
<p><strong>OOM错误</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>

<span class="token comment">//-Xms  设置初始化内存大小，默认是1/64</span>
<span class="token comment">//-Xms  设置最大分配内存，默认是1/4</span>
<span class="token comment">//-XX:+PrintGCDetail    打印GC垃圾回收的相关信息</span>
<span class="token comment">//-XX:+HeapDumpOnOutOfMemoryError   打印OOM的错误，并Dump</span>
<span class="token comment">//-Xms1m -Xms8m -XX:+HeapDumpOnOutOfMemoryError</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo03</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Demo03</span><span class="token punctuation">&gt;</span></span> objects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                objects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Demo03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>下载JProfiler</strong></p> 
<p><a href="https://www.ej-technologies.com/download/jprofiler/files" rel="nofollow">Jprofiler下载</a></p> 
<p><strong>无脑式下一步安装即可</strong></p> 
<p><strong>然后IDEA下载 Jprofiler插件</strong></p> 
<p><img src="https://images2.imgbox.com/59/0d/m3cQznjb_o.png" alt="在这里插入图片描述"></p> 
<p><strong>下载完后程序我们去tools配置下载的客户端Jprofiler</strong></p> 
<p><strong>IDEA会自动配置</strong></p> 
<p><img src="https://images2.imgbox.com/7d/be/zIMXZuPL_o.png" alt="在这里插入图片描述"></p> 
<p><strong>在执行程序时加上以下参数</strong></p> 
<p><img src="https://images2.imgbox.com/18/4c/abidTdDu_o.png" alt="在这里插入图片描述"></p> 
<p>执行完毕后会dump下来文件</p> 
<p><img src="https://images2.imgbox.com/7b/13/O0O9dVlv_o.png" alt="在这里插入图片描述"></p> 
<p><strong>打开项目根目录找到dump文件</strong></p> 
<p><img src="https://images2.imgbox.com/b1/e4/OH7B3bel_o.png" alt="在这里插入图片描述"></p> 
<p><strong>打开分析错误</strong></p> 
<p><img src="https://images2.imgbox.com/aa/34/9nAi5KZa_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_92"></a>二、堆内存调优</h2> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//返回虚拟机试图使用的最大内存</span>
        <span class="token keyword">long</span> max <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//返回虚拟机的初始化内存</span>
        <span class="token keyword">long</span> totalMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"虚拟机试图使用的最大内存："</span> <span class="token operator">+</span> max <span class="token operator">+</span> <span class="token string">"字节，"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>max<span class="token operator">/</span><span class="token number">1024</span><span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"MB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"虚拟机的初始化内存："</span> <span class="token operator">+</span> totalMemory <span class="token operator">+</span> <span class="token string">"字节，"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>totalMemory<span class="token operator">/</span><span class="token number">1024</span><span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"MB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//在启动时配置JVM参数</span>
        <span class="token comment">//-Xms8m -Xms8m -XX:+PrintGCDetails</span>

        <span class="token comment">//伊甸园区+老年区=堆内存  元空间 逻辑上存在，物理上不存在</span>
        <span class="token comment">//305664K + 699392K = 1,005,056K = 981.5MB</span>
        
        <span class="token comment">//默认情况下，分配的总内存 是电脑内存的 1/4 而初始内存是 1/64</span>
        
        <span class="token comment">//OOM错误解决</span>
        <span class="token comment">//1.尝试扩大堆内存，看结果</span>
        <span class="token comment">//2.分析内存，看那个地方出现了问题（专业工具）</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/03/77/Ia65e1Uc_o.png" alt="在这里插入图片描述"></p> 
<p><strong>设置JVM参数启动</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//返回虚拟机试图使用的最大内存</span>
        <span class="token keyword">long</span> max <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//返回虚拟机的初始化内存</span>
        <span class="token keyword">long</span> totalMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"虚拟机试图使用的最大内存："</span> <span class="token operator">+</span> max <span class="token operator">+</span> <span class="token string">"字节，"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>max<span class="token operator">/</span><span class="token number">1024</span><span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"MB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"虚拟机的初始化内存："</span> <span class="token operator">+</span> totalMemory <span class="token operator">+</span> <span class="token string">"字节，"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>totalMemory<span class="token operator">/</span><span class="token number">1024</span><span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"MB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//-Xms8m -Xms8m -XX:+PrintGCDetails</span>

        <span class="token comment">//伊甸园区+老年区=堆内存  元空间 逻辑上存在，物理上不存在</span>
        <span class="token comment">//305664K + 699392K = 1,005,056K = 981.5MB</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<p><strong>设置JVM参数</strong></p> 
<p><img src="https://images2.imgbox.com/d7/ae/MJp4hSf3_o.png" alt="在这里插入图片描述"></p> 
<p><strong>单击 modiy options</strong></p> 
<p><img src="https://images2.imgbox.com/73/c2/cVnasd6u_o.png" alt="在这里插入图片描述"></p> 
<p><strong>选择JVM参数</strong><br> <img src="https://images2.imgbox.com/46/05/4iSvVBJH_o.png" alt="在这里插入图片描述"></p> 
<p><strong>写入参数名称</strong></p> 
<p><img src="https://images2.imgbox.com/55/8a/HBTMtGWV_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Apply同意并保存</strong></p> 
<p>执行代码</p> 
<p><img src="https://images2.imgbox.com/c4/fc/5fxK7apg_o.png" alt="在这里插入图片描述"></p> 
<p><strong>我们可以得出，伊甸园区内存大小+老年代内存大小=981.5</strong></p> 
<p><strong>所以说，元空间，逻辑上存在，物理上不存在</strong></p> 
<h2><a id="_GC_178"></a>三、 GC垃圾回收器</h2> 
<p><img src="https://images2.imgbox.com/0d/b0/xaXXc3Oz_o.png" alt="在这里插入图片描述"></p> 
<p>JVM在进行GC垃圾回收时，并不是对这三个区域同意回收，大部分回收都是新生代</p> 
<ul><li>新生代</li><li>幸存区（from to）</li><li>老年区</li></ul> 
<p>GC两种类型：轻GC（普通的GC） 重GC（全局GC）</p> 
<p>GC题目：</p> 
<ul><li>JVM的内存模型和分区，详细到每个区放什么？</li><li>堆里面的区有哪些？Eden，form，to，老年区，说说他们的特点！</li><li>GC的算法有哪些？标记清除法，标记压缩，复制算法，引用计数器 怎么用的？</li><li>轻GC和重GC分别在什么时候发生？</li></ul> 
<h2><a id="GC_201"></a>四、GC常用算法</h2> 
<h3><a id="_203"></a>❄️引用计数法</h3> 
<p><img src="https://images2.imgbox.com/dd/39/2WKjBGye_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_209"></a>⛄复制算法</h3> 
<p><img src="https://images2.imgbox.com/fd/c5/PIcxwHOh_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/76/c1/1siXivlF_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>好处：没有内存的碎片</p> </li><li> <p>坏处：浪费了内存空间，多了一半空间永远是空的。假设对象100%存活（极端情况）</p> </li></ul> 
<p>复制算法最佳使用场景：对象存活度较低的时候；新生区~</p> 
<h3><a id="_225"></a>♨️标记清除算法</h3> 
<p><img src="https://images2.imgbox.com/59/07/MAhuzGYS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>优点：</strong> 不需要额外的空间，把复制算法的缺点弥补了</p> 
<p><strong>缺点：</strong> 两次扫描严重浪费时间，会产生内存碎片，hash定位需要成本</p> 
<h3><a id="_235"></a>⛽标记压缩</h3> 
<p>再次优化</p> 
<p><img src="https://images2.imgbox.com/40/95/jfjTRitd_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_243"></a>⚠️标记清除压缩</h3> 
<p>先标记清除几次</p> 
<p><img src="https://images2.imgbox.com/b0/ae/FgY3sXLA_o.png" alt="在这里插入图片描述"></p> 
<p><strong>再压缩</strong></p> 
<p><img src="https://images2.imgbox.com/45/d2/oiNtan3I_o.png" alt="在这里插入图片描述"></p> 
<p>内存效率：复制算法 —&gt; 标记清除算法 —&gt; 标记压缩算法（时间复杂度）</p> 
<p>内容整齐度：复制算法 = 标记压缩算法 —&gt; 标记清除算法</p> 
<p>内容利用率：标记压缩算法 = 标记清除算法 —&gt; 复制算法</p> 
<p>没有最优算法吗？</p> 
<p>没有，没有最好的算法，只有最合适的算法， —&gt; GC：分代收集算法</p> 
<p>年轻代：</p> 
<ul><li>存活率低</li><li>复制算法</li></ul> 
<p>老年代：</p> 
<ul><li>区域大：存活率高</li><li>标记清除（内存碎片不是太多）+标记压缩混合实现</li></ul> 
<h2><a id="JMM_277"></a>五、JMM</h2> 
<ol><li> <p><strong>什么是JMM</strong>：Java Memory Model</p> </li><li> <p>它是干嘛的？：官方，博客，对应的视频</p> <p>作用：缓存一致性协议，用于定义数据读写的规则（遵守，找到规则）</p> <p>JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的共享变量存储在主内存中（Main Memory）中，</p> <p>每个线程都有一个私有的工作内存(Local Memory)</p> </li></ol> 
<p><img src="https://images2.imgbox.com/b1/df/77UMHHUN_o.png" alt="在这里插入图片描述"></p> 
<p>​ 解决共享对象可见性的问题：volatile</p> 
<ol start="4"><li> <p>它该如何学习</p> <p>​ JMM是一个抽象的概念，理论</p> <p>可见性</p> <p><strong>volatile关键字</strong></p> </li></ol> 
<p>​ 指令重排</p> 
<p>​ <strong>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</strong></p> 
<ul><li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul> 
<p><strong>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</strong></p> 
<ul><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul> 
<h2><a id="_330"></a>⛵小结</h2> 
<p>以上就是【<strong>Bug 终结者</strong>】对 <strong>【高级篇】Java JVM实战 之 内存调优</strong> 的简单介绍，JVM 内存优化，偏底层知识，认真研究，虚心进步，加油，走过的艰难终将铺向成功的道路，<strong>学习JVM可了解Java程序的运行方式以及运行原理，更深层次的理解可提高自己对Java知识再上高峰，JVM 内存调优，进阶必备！</strong></p> 
<blockquote> 
 <p>如果这篇【文章】有帮助到你，希望可以给【<strong>Bug 终结者</strong>】点个赞👍，创作不易，如果有对【<strong>后端技术</strong>】、【<strong>前端领域</strong>】感兴趣的小可爱，也欢迎关注❤️❤️❤️ 【<strong>Bug 终结者</strong>】❤️❤️❤️，我将会给你带来巨大的【收获与惊喜】💝💝💝！</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ee2ffccf8f53f71293d8881f2657206/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">跨模态神经搜索实践VCED 基于Streamlit实现前端页面设计和逻辑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4131a65cbaf16542fe791aa1e32061a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spoon Kettle 合并排序详解（Merge join）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>