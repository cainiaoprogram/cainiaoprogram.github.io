<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于视觉的无人机自主降落系统设计 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于视觉的无人机自主降落系统设计" />
<meta property="og:description" content="文章目录 摘 要第一章 绪论1.1 课题开发背景1.1.1 课题的意义1.1.2 国内外发展状况 1.2 课题研究内容1.3 课题研究步骤1.4 本章小节 第二章 MatlabGUI的搭建2.1 下载安装Matlab2.2 在Matlab中搭建GUI平台2.2.1 GUI介绍2.2.2 GUI的组成2.2.3 GUI搭建步骤2.2.4 GUI的使用 2.3 matlab坐标轴绘制2.4 本章小节 第三章 图像识别算法介绍3.1 二值化 3.2 直方图均衡化3.3 knn算法分析3.3.1 knn简介3.3.2 knn的优缺点 3.4 自主降落系统设计3.4.1 单目地标识别算法-点特征定位3.4.2 双目降落区域选择 3.5 matlab路径规划仿真验证3.6 本章小节 第四章 无人机自主降落环境识别算法4.1 算法流程图4.2 具体步骤4.3 系统流程 第五章 无人机自主降落的环境测试5.1 测试的意义和方法5.2 系统的配置5.3 程序分析5.3 本章小节 第六章 总结与展望 摘 要 无人机的自主化降落过程里，从传统的地标识别法里面可以看到，实验需要大量的实验测试。为了解决这一问题，提出了一种基于仿射不变矩和支持向量机的方法。第一，六个以某个半径画圆将其组合为整体图标，可以被认为是无人机自主降落的地面标识。这是因为无人机自主降落时选择目标图像的特征，它提取与输入具有主要特征类似的地面图像的相关不变矩。支持向量机用于识别前一周期的像素对应点。该方法有效地提高了识别的准确率，减少了识别和测试的时间，对地标的识别有很好的效果。
对于无人机能否在某个区域内进行自主降落的问题，提出了一些关于无人机自主降落控制系统的相关系统结构。提出两种结构，分别是横向控制回路和纵向控制回路。提出了一种很有效的关于飞行距离的降落地面方针，将着降落轨道分为了四中不同的阶段：进入飞行段和直线滑道。指数平滑段和跑道滑道段。计算出了各种飞行阶段的纵向轨道公式。在Matlab环境下对无人机着陆阶段的低速仿真结果表明，无人机着陆轨道和设计着陆轨迹控制方法有效地实现了无人机的安全着陆。无人机的稳定降落，这完全能够符合预定标准的硬性要求。
关键字：无人机、自主降落、着陆轨迹、地标设计、matlab
DESIGN OF AUTONOMOUS LANDING SYSTEM FOR UAV BASED ON VISION
ABSTRACT
In the autonomous landing process of UAVs, we can see from the traditional landmark recognition method that the experiment needs a lot of experimental tests." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/aa89b772c351cdcae46cc9c7e2506a0b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T09:50:53+08:00" />
<meta property="article:modified_time" content="2024-01-05T09:50:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于视觉的无人机自主降落系统设计</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#__1" rel="nofollow">摘 要</a></li><li><a href="#__21" rel="nofollow">第一章 绪论</a></li><li><ul><li><a href="#11__23" rel="nofollow">1.1 课题开发背景</a></li><li><ul><li><a href="#111__25" rel="nofollow">1.1.1 课题的意义</a></li><li><a href="#112__30" rel="nofollow">1.1.2 国内外发展状况</a></li></ul> 
    </li><li><a href="#12__39" rel="nofollow">1.2 课题研究内容</a></li><li><a href="#13__43" rel="nofollow">1.3 课题研究步骤</a></li><li><a href="#14__49" rel="nofollow">1.4 本章小节</a></li></ul> 
   </li><li><a href="#_MatlabGUI_53" rel="nofollow">第二章 MatlabGUI的搭建</a></li><li><ul><li><a href="#21_Matlab_54" rel="nofollow">2.1 下载安装Matlab</a></li><li><a href="#22_MatlabGUI_79" rel="nofollow">2.2 在Matlab中搭建GUI平台</a></li><li><ul><li><a href="#221_GUI_80" rel="nofollow">2.2.1 GUI介绍</a></li><li><a href="#222_GUI_82" rel="nofollow">2.2.2 GUI的组成</a></li><li><a href="#223_GUI_94" rel="nofollow">2.2.3 GUI搭建步骤</a></li><li><a href="#224_GUI_107" rel="nofollow">2.2.4 GUI的使用</a></li></ul> 
    </li><li><a href="#23_matlab_113" rel="nofollow">2.3 matlab坐标轴绘制</a></li><li><a href="#24__126" rel="nofollow">2.4 本章小节</a></li></ul> 
   </li><li><a href="#__130" rel="nofollow">第三章 图像识别算法介绍</a></li><li><ul><li><a href="#31__132" rel="nofollow">3.1 二值化</a></li></ul> 
   </li><li><a href="#32__136" rel="nofollow">3.2 直方图均衡化</a></li><li><ul><li><a href="#33_knn_157" rel="nofollow">3.3 knn算法分析</a></li><li><ul><li><a href="#331_knn_159" rel="nofollow">3.3.1 knn简介</a></li><li><a href="#332_knn_187" rel="nofollow">3.3.2 knn的优缺点</a></li></ul> 
    </li><li><a href="#34__194" rel="nofollow">3.4 自主降落系统设计</a></li><li><ul><li><a href="#341__204" rel="nofollow">3.4.1 单目地标识别算法-点特征定位</a></li><li><a href="#342__213" rel="nofollow">3.4.2 双目降落区域选择</a></li></ul> 
    </li><li><a href="#35_matlab_219" rel="nofollow">3.5 matlab路径规划仿真验证</a></li><li><a href="#36__223" rel="nofollow">3.6 本章小节</a></li></ul> 
   </li><li><a href="#__227" rel="nofollow">第四章 无人机自主降落环境识别算法</a></li><li><ul><li><a href="#41__229" rel="nofollow">4.1 算法流程图</a></li><li><a href="#42__245" rel="nofollow">4.2 具体步骤</a></li><li><a href="#43__257" rel="nofollow">4.3 系统流程</a></li></ul> 
   </li><li><a href="#__267" rel="nofollow">第五章 无人机自主降落的环境测试</a></li><li><ul><li><a href="#51__269" rel="nofollow">5.1 测试的意义和方法</a></li><li><a href="#52__276" rel="nofollow">5.2 系统的配置</a></li><li><a href="#53__286" rel="nofollow">5.3 程序分析</a></li><li><a href="#53__377" rel="nofollow">5.3 本章小节</a></li></ul> 
   </li><li><a href="#__383" rel="nofollow">第六章 总结与展望</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="__1"></a>摘 要</h3> 
<p>无人机的自主化降落过程里，从传统的地标识别法里面可以看到，实验需要大量的实验测试。为了解决这一问题，提出了一种基于仿射不变矩和支持向量机的方法。第一，六个以某个半径画圆将其组合为整体图标，可以被认为是无人机自主降落的地面标识。这是因为无人机自主降落时选择目标图像的特征，它提取与输入具有主要特征类似的地面图像的相关不变矩。支持向量机用于识别前一周期的像素对应点。该方法有效地提高了识别的准确率，减少了识别和测试的时间，对地标的识别有很好的效果。<br> 对于无人机能否在某个区域内进行自主降落的问题，提出了一些关于无人机自主降落控制系统的相关系统结构。提出两种结构，分别是横向控制回路和纵向控制回路。提出了一种很有效的关于飞行距离的降落地面方针，将着降落轨道分为了四中不同的阶段：进入飞行段和直线滑道。指数平滑段和跑道滑道段。计算出了各种飞行阶段的纵向轨道公式。在Matlab环境下对无人机着陆阶段的低速仿真结果表明，无人机着陆轨道和设计着陆轨迹控制方法有效地实现了无人机的安全着陆。无人机的稳定降落，这完全能够符合预定标准的硬性要求。</p> 
<p>关键字：无人机、自主降落、着陆轨迹、地标设计、matlab</p> 
<p>DESIGN OF AUTONOMOUS LANDING SYSTEM FOR UAV BASED ON VISION</p> 
<p>ABSTRACT<br> In the autonomous landing process of UAVs, we can see from the traditional landmark recognition method that the experiment needs a lot of experimental tests. In order to solve this problem, a method based on affine moment invariants and support vector machines is proposed. First, the six circular combination icons are marked as autonomous landing landmark for UAVs. It is because the UAV chooses the characteristics of the target image that it extracts the landmark affine invariant moments as the main feature of the input. Support vector machine (SVM) is used to identify the corresponding landmarks. Compared with the old geometric invariant moments and the neural networks in today’s era, this method can effectively improve the accuracy of the recognition of the landmark, effectively reduce the time of identification and test, and has a very good practical effect on the landmark recognition.</p> 
<p>For the UAV can reach the related problems of autonomous landing, some related system structure of UAV autonomous landing control system is put forward. Many effective control methods for lateral control loop and longitudinal control loop are designed. A very effective approach to landing ground on the flight distance is proposed. The landing orbit is divided into four different stages: entering the flight section and the straight line. The index smooth segment and the runway slideway section. The longitudinal orbit formulas for various flight phases are calculated. The simulation results of the low speed unmanned aerial vehicle (UAV) landing stage in the MATLAB environment show that the landing orbit of the UAV and the designed landing orbit control method can effectively realize the unmanned aerial vehicle (UAV) landing safely. The stable landing of UAV can meet the predetermined standard’s rigid requirements.</p> 
<p>Key words: UAV, autonomous landing, landing trajectory, landmark design, matlab</p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#__1" rel="nofollow">摘 要</a></li><li><a href="#__21" rel="nofollow">第一章 绪论</a></li><li><ul><li><a href="#11__23" rel="nofollow">1.1 课题开发背景</a></li><li><ul><li><a href="#111__25" rel="nofollow">1.1.1 课题的意义</a></li><li><a href="#112__30" rel="nofollow">1.1.2 国内外发展状况</a></li></ul> 
    </li><li><a href="#12__39" rel="nofollow">1.2 课题研究内容</a></li><li><a href="#13__43" rel="nofollow">1.3 课题研究步骤</a></li><li><a href="#14__49" rel="nofollow">1.4 本章小节</a></li></ul> 
   </li><li><a href="#_MatlabGUI_53" rel="nofollow">第二章 MatlabGUI的搭建</a></li><li><ul><li><a href="#21_Matlab_54" rel="nofollow">2.1 下载安装Matlab</a></li><li><a href="#22_MatlabGUI_79" rel="nofollow">2.2 在Matlab中搭建GUI平台</a></li><li><ul><li><a href="#221_GUI_80" rel="nofollow">2.2.1 GUI介绍</a></li><li><a href="#222_GUI_82" rel="nofollow">2.2.2 GUI的组成</a></li><li><a href="#223_GUI_94" rel="nofollow">2.2.3 GUI搭建步骤</a></li><li><a href="#224_GUI_107" rel="nofollow">2.2.4 GUI的使用</a></li></ul> 
    </li><li><a href="#23_matlab_113" rel="nofollow">2.3 matlab坐标轴绘制</a></li><li><a href="#24__126" rel="nofollow">2.4 本章小节</a></li></ul> 
   </li><li><a href="#__130" rel="nofollow">第三章 图像识别算法介绍</a></li><li><ul><li><a href="#31__132" rel="nofollow">3.1 二值化</a></li></ul> 
   </li><li><a href="#32__136" rel="nofollow">3.2 直方图均衡化</a></li><li><ul><li><a href="#33_knn_157" rel="nofollow">3.3 knn算法分析</a></li><li><ul><li><a href="#331_knn_159" rel="nofollow">3.3.1 knn简介</a></li><li><a href="#332_knn_187" rel="nofollow">3.3.2 knn的优缺点</a></li></ul> 
    </li><li><a href="#34__194" rel="nofollow">3.4 自主降落系统设计</a></li><li><ul><li><a href="#341__204" rel="nofollow">3.4.1 单目地标识别算法-点特征定位</a></li><li><a href="#342__213" rel="nofollow">3.4.2 双目降落区域选择</a></li></ul> 
    </li><li><a href="#35_matlab_219" rel="nofollow">3.5 matlab路径规划仿真验证</a></li><li><a href="#36__223" rel="nofollow">3.6 本章小节</a></li></ul> 
   </li><li><a href="#__227" rel="nofollow">第四章 无人机自主降落环境识别算法</a></li><li><ul><li><a href="#41__229" rel="nofollow">4.1 算法流程图</a></li><li><a href="#42__245" rel="nofollow">4.2 具体步骤</a></li><li><a href="#43__257" rel="nofollow">4.3 系统流程</a></li></ul> 
   </li><li><a href="#__267" rel="nofollow">第五章 无人机自主降落的环境测试</a></li><li><ul><li><a href="#51__269" rel="nofollow">5.1 测试的意义和方法</a></li><li><a href="#52__276" rel="nofollow">5.2 系统的配置</a></li><li><a href="#53__286" rel="nofollow">5.3 程序分析</a></li><li><a href="#53__377" rel="nofollow">5.3 本章小节</a></li></ul> 
   </li><li><a href="#__383" rel="nofollow">第六章 总结与展望</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="__21"></a>第一章 绪论</h3> 
<h4><a id="11__23"></a>1.1 课题开发背景</h4> 
<h5><a id="111__25"></a>1.1.1 课题的意义</h5> 
<p>在最近几年，传感器技术、嵌入式处理器技术、远程数字图像传输技术等技术的发展迅速，这些都与随着与无人机的发展密切相关，无人机（UAV）已经开始步入实验室和多类工业应用领域。在高端军事市场也有一席之地。同时在航空摄影、电力线路巡检、农业植保、测绘、航空侦察、等方面取得了突破性进展。全球无人驾驶飞机市场出现井喷的景象。在这日新月异的时代，小型多旋翼无人机（UAV）的生产具备许多优点，例如结构简单、维修方便、成本低、飞行灵活的特点，而且，最好的是能够适应复杂的飞行环境。<br> 无人机的制作成本不高、它可以低速飞行，也可以悬停空中进行高空作业，因此不仅可以适用于民用，在工业应用领域也可以进行大规模研发[1]。在农业领域，无人机能够在农业中进行喷洒农药的工作，可以高速有效地提高喷洒农药的效率，采用无人机喷洒，也可以最大程度上减少农药对人体的危害，可以通过无人机对电力线进行研究，也可以找出潜在的风险[[2]。<br> 在消防领域，可以通过安装红外摄像机来实现对火灾的检测。同时在如今物流发展迅猛的时代，研究无人机可以在某些地区实行高空物流。随着工业无人机智能化的快速发展，已经被提上议事日程，但是无人机没有视觉导航，这成为限制无人机发展的一个重要方面，因此，视觉导航的研究更受关注[ 3 ]。</p> 
<h5><a id="112__30"></a>1.1.2 国内外发展状况</h5> 
<p>人类视觉获得的信息占信息总量的80%左右，智能机器人可以通过摄像机获取大量传感器无法获得的信息。视觉信息的细节丰富，信息量大，利用视觉传感器获取外部信息，提取实时环境特征成为机器视觉。计算机视觉的研究始于上个世纪50年代。计算机视觉经过二十多年的发展，引起了世界各国的广泛关注。到1985，有关理论的研究已经相对成熟，并从各个方面形成了全面的理论研究。计算机视觉采用计算机科学的研究方法，结合了神经生理学和心理学等重要成果的其他学科的研究成果，形成了较为完善的理论基础。<br> 麻省理工学院曾对这部分内容进行研究，并将视觉发展分为三个时期，由最开始的3D模型转换为借助于计算能力实现视觉识别。在这个时期，计算能力已经与人类的思维能力相扑相处，计算机智能程度大大提高。美国对其高瞻远瞩的研究，也使该国家的无人机导航一直处于世界领先地位。在美国对其进行深入研究时，欧洲澳大利亚等国家的大学或者是研究机构也都开始了无人机导航的研究，百花齐放的理论推动无人机视觉发展迅猛。<br> 南加州大学对无人机也是很感兴趣，他们对无人机的憧憬于1991年便开始了。该校着重研究的是无人机自动降落问题。事实证明，他们通过结合相机和相机处理平台，通过拍摄降落环境来进行是否可以自主下落的判断，也是与本文密切相关的研究方向。<br> 如果说无人机视觉导航，最具有代表性的研究应该是在瑞士，他们在相机平台上进行位置区域与地图的结合，采用双目视觉传感器，来均衡飞行速度和飞行方向，不仅在室外高空可以飞行，在室内也可以进行自主探索。甚至到后期，该大学研发出无人机贴墙边的飞行方式。且可以向接收站传输视频信号。<br> 香港科技大学的研究团队搭建的无人机视觉导航平台，采用了精妙的算法，结合Atom的处理器完成算法计算，同时借助于测距仪和传感器实现自主飞行的效果。<br> 在国内的浙江大学，徐伟杰等人也提出了县级的无人机视觉导航方案，通过拍摄的建筑物图像，分析建筑物竖直轮廓消影店来计算出无人机的位置和姿态，结合视觉的单目SLAM，也与实际效果高度拟合。<br> 在哈尔滨工业大学，研究的是小型多旋翼无人机视觉导航，他们研制出的无人机视觉导航平台是很先进的平台，他们采用的多旋翼也是无人机领域的一大进展，借助于多旋翼可以得到更广泛的数据信息，搭载运动摄像机的同时，也对移动目标进行追踪拍摄。</p> 
<h4><a id="12__39"></a>1.2 课题研究内容</h4> 
<p>无人机飞行事故60%以上都是在着落过程中发生的，因此，无人机的自主降落系统中的技术是提高无人机安全性的关键，是无人机技术发展的重中之重。本文针对无人机自主着陆环境进行检测，自主降落过程中，在某个规定的点上实现接地，为保证无人机安全着陆，在降落之前对地面环境进行检测是很有必要的。<br> 在无人机自主着陆系统技术中，无人机飞行过程中的事故，60%以上的无人机进行降落的时候发生的，飞行降落环境检测是提高无人机安全性的关键。无人机在着陆阶段是在某个特定的基础上进行的，为了保证了无人机的安全着陆，有必要在自主降落之前确定地下降落环境。</p> 
<h4><a id="13__43"></a>1.3 课题研究步骤</h4> 
<p>1、统规划阶段：查阅相关资料，系统地了解基于无人机的自主着陆系统的工作原理，并在此基础上了解并学习实现该技术。认真学习和开发工具和语言，这样可以为日后理论与实践上，打下良好的基础。<br> 2、分析总结阶段：认真分析现有无人机自主着陆系统，总结各种方法的优缺点，弥补其优缺点，并根据自身的实际发展能力确定发展方向并加以发展。环境。<br> 3、系统设计阶段：确定了系统的开发方向后，对系统进行了详细设计，划分了功能模块，并给出了详细的开发方案。<br> 4、系统实现阶段：编程实现各功能模块的具体功能，实现各功能模块的连接、调试和调试。然后对系统进行了测试，并对程序进行了调试。只靠单一的测试是不可以的，所以重复的测试虽然繁杂，但是也可以在最大程度上保证了系统的正常运行。</p> 
<h4><a id="14__49"></a>1.4 本章小节</h4> 
<p>本章对视觉的无人机自主降落的课题进行了分析，对课题的研发背景进行了详细的调查，分别从国内外进行分析研究，并且详述了课题的意义和内容，结合本系统的研发内容，阶段性的列出了课题研究的具体步骤。</p> 
<h3><a id="_MatlabGUI_53"></a>第二章 MatlabGUI的搭建</h3> 
<h4><a id="21_Matlab_54"></a>2.1 下载安装Matlab</h4> 
<ol><li>进入https://www.mathworks.com，找到下载界面<br> 下载完成后打开<br> <img src="https://images2.imgbox.com/45/d1/QnVDuT8a_o.gif" alt="在这里插入图片描述"><br> 图2.1 安装界面</li><li>使用电子邮件地址登录MathWorks账户，点击下一步<br> <img src="https://images2.imgbox.com/f7/89/H3N8fHxu_o.gif" alt="在这里插入图片描述"></li><li>选择许可证，点击下一步<br> <img src="https://images2.imgbox.com/94/27/UKZFXIaA_o.gif" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/25/3e/WhUtI3hR_o.gif" alt="在这里插入图片描述"><br> 图2.2许可证填写</li></ol> 
<p>4、选择安装方法，使用mathworks账户登录<br> <img src="https://images2.imgbox.com/dd/81/F8YJlkWy_o.gif" alt="在这里插入图片描述"><br> 图2.3 mathworks账户登录</p> 
<p>5、选择安装位置<br> 图2.4 安装位置<br> 　图 2.5 下载组件<br> <img src="https://images2.imgbox.com/1e/11/nBNVf1LO_o.gif" alt="在这里插入图片描述"></p> 
<h4><a id="22_MatlabGUI_79"></a>2.2 在Matlab中搭建GUI平台</h4> 
<h5><a id="221_GUI_80"></a>2.2.1 GUI介绍</h5> 
<p>GUI是一种特殊的图形用户界面，它指的是图形用户界面的用户接口。与早期计算机研发时，操作时所使用的命令行接口比较可知，图形界面简洁方便，更适应于非计算机人才的使用。所以，GUI的推广异常迅猛，这也可以称为是当今计算机发展的一大成果。这是一个方便非专业用户使用的绝佳利器。不再需要记住很多命令。相反，通过简洁的窗口、明了的菜单、标识的按钮等组件，使用户操作很方便的。嵌入式GUI的优点很明显，它的小组件特性使它成为轻量级的图像用户界面、同时它占用很少的资源、在移植性上也是超越其他的命令行、同时不要求更高的配置环境。</p> 
<h5><a id="222_GUI_82"></a>2.2.2 GUI的组成</h5> 
<p>图形用户界面从字面意义上可知，它是指用户借助于图形界面对计算机进行操作，用户可以使用鼠标或者是其他触摸屏，来操纵计算机的任务，例如可以进行单选项的选择，也可以复制文本、粘贴文本、启动某个程序、移动某个图像或者其他操作。GUI的组件种类简单，可以分为以下部分：<br> 当启动桌面界面的时候是最低级别，有时它意味着桌面环境，包括Windows和文件浏览器。一般来说，基于这个图标有大量的应用程序和数据，用户可以开始工作。<br> Windows，在一个图形用户界面，使用的数据基本单元是类似于计划和集成数据的窗口。使用Windows的用户，可以在Windows下的操作不同的应用程序，进行管理，创建和编辑数据信息。<br> 单文件接口——在计算机屏幕的窗口中，数据在一个窗口中完成的方式是多样的，并不是全体单一化处理。若要想在其它应用程序的界面中也想使用某种数据数据，将会按照顺序生成新的窗口，所以有很多窗口和复杂的管理。</p> 
<p>多文件接口——一种在单个窗口中管理多个数据的方法。在这种情况下，窗口的管理是相对简单的，但是操作会变得十分复杂</p> 
<p>一个界面，可以用来管理数据文件，界面标题是通过标签保存在窗口中，并显示了必要的数据，用于选择标题，这使得访问数据更加方便。<br> 菜单-命令界面的可视化系统。图片通常放置在上面或下面，几乎所有的东西都可以用来斤西瓜程序的执行与命令。重要性是一般来说就是从左到右，左边的相对重要性高。<br> 菜单按钮，利用命令来提供图形，在程序中实现配置，并成为一个按钮。</p> 
<h5><a id="223_GUI_94"></a>2.2.3 GUI搭建步骤</h5> 
<p>1、打开Matlab程序并等待它完成负载<br> 2、单击发射器上的“Matlab”以展开列表，然后双击向导（GUI Builder）。<br> 3、如果你看不到发射器，点击看发射台。GUI生成器将出现<br> 4、点击窗口左边的“OK”按钮。这将允许你拖放一个按钮。<br> 5、将鼠标移动到灰色区域中的窗口中心。<br> 6、单击一次，按住左键并拖动鼠标直到正方形，这是窗体的大小。<br> 7、放开鼠标按钮，你会看到你的按钮出现。<br> 8、双击刚才创建的按钮。物业经理会突然出现<br> 9、找到“字符串字段”，然后点击该区域的右侧，然后键入“hello”。另外，标签也改为“按钮”。<br> 10、找到左侧标记为“TXT”的按钮，再次执行同样的步骤8<br> 11、现在点击文件并保存到保存。这也会弹出代码程序。<br> 12、找到的代码编辑器是写在函数VARGAUD= = StudioButn1CalBe后撤（H，EVENDATA，句柄，Valgin行）。这是回调函数。只要用户按下按钮，下面的任何代码都将被执行。</p> 
<h5><a id="224_GUI_107"></a>2.2.4 GUI的使用</h5> 
<p>第一步：GUI在主函数（例如，图形设计、装配等控件的创建）中进行创建，控件CreatFcn自动默认为%automatic，只调用一次，在初始阶段的时候，CEATFCN的主要功能是会多次调用主功能。然后再由主函数去调用控件CREATFCN，这样就可以顺利完成完成GUI的创建。<br> 第二步：执行OpenGfCN，OpenGfCN中变量的初始化和主程序输入变量VARGARIN的处理。<br> 第三步：是执行OutPutfCN（也称为main函数），它可以处理OutputFcn中的输出变量ValAGOUT。<br> 第四步：等待外部事件触发，主函数响应事件（如按键和鼠标事件），主函数调用回调函数回调以完成响应。</p> 
<h4><a id="23_matlab_113"></a>2.3 matlab坐标轴绘制</h4> 
<p>1 坐标系显示<br> 关于MATLAB坐标轴的绘制，在前面的讨论中，我们提出了一种用直线绘制函数（直线）直接绘制轴的方法。但其实，在Matlab中有一种方法，并不需要用直线直接进行绘制，而是通过步步调用函数来达到绘制坐标系的目的。</p> 
<p>今天<br> 图2.6 matlab普通坐标系<br> 2 移动坐标轴到原点<br> 2.1 案例1<br> 由图2.7可见，对于数学图形，这种坐标与平时我们熟悉的数学坐标系是由很大的区别的。我们倾向于更倾向于通过原点穿过坐标，并在正方向上有一个箭头。为了解决这个视觉效果以及常识问题，可以编写一种函数，将坐标轴移动到坐标原点。结果如下图2.7所示</p> 
<p>图2.7 移动坐标轴之后效果图</p> 
<h4><a id="24__126"></a>2.4 本章小节</h4> 
<p>本章介绍了Matlab中GUI环境的搭建，首先简单地介绍了如何下载安装Matlab，在第二小节详细介绍了如何在Matlab中搭建GUI平台，在该小节中，分成了两部分，首先对GUI进行了介绍，对GUI的组成进行分析，接着就是GUI的搭建步骤以及使用步骤。在第三小节，对matlab坐标轴绘制进行分析，为后续程序介绍做好了理论铺垫。</p> 
<h3><a id="__130"></a>第三章 图像识别算法介绍</h3> 
<h4><a id="31__132"></a>3.1 二值化</h4> 
<p>最常用的方法是K值的第二次值处理，平均值超过像素的k值，作为图像的每个像素的值的扫描，像素的值为255（白色），并且值小于或等于k为值0（像素黑色）。然而，由于平均值的两个阈值的使用有很大的缺陷，所以可能丢失一些像素或背景像素的对象。根据二值化的结果可知，并不是每一次处理，都能反映信息的来源。</p> 
<h3><a id="32__136"></a>3.2 直方图均衡化</h3> 
<p>如果图像中的像素以灰度和均匀分布的方式占据了大量的这些图像，则经常会出现高对比度，并且可以改变灰度直方图均衡化，是一种只需要通过输入直方图的信息就可以完成转换框策略变化的函数。其基本思想是扩大图像的像素数，使图像中的多个像素压缩，从而扩大像素值变化范围的动态性，从而提高灰度和颜色变化的对比度，实现图像的清晰化。<br> 图像对比度增强的方法有两种：一种是直接的，另一种是间接的。但是无论是直接的还是间接的，采用对比度增强方法。直方图的研究集方法和直方图均衡化，是目前比较常用的两种对比方法，可以是间接的。对比扩大展展，以最大化直方图，与灰色背景之间的差异，而不是增加，用于图像分析。这种方法完全线性或非线性，可以借助于函数累加函数进行灰度调整，这就可以实现直方图均衡化。<br> 直方图均衡化的主要思想就是将原始图像的直方图，将其设法转换为另一种方式。灰度值有一个动态范围，在这个范围内，可以借助与均衡化，增强图像的整体对比度。如果将原始图像的灰度（x，y）设置为f。当图像被改变为G时，图像增强方法可以被描述为将灰度F映射到（x，y）到g。从直方图均衡处理到图像的映射函数可以定义为g＝eq（f）和映射。G函数需要满足两个条件（L是图像的灰度序列）：<br> （1）Eq（m）是在0 m以内或小于T-1范围内的单值递增的函数。这是为了确保增强处理不会破坏原始图像的灰度级，并且原始图像的原始灰度级在变换之后仍然由黑色变为白色（或由白色变为黑色）。</p> 
<p>(2)对于0≤m≤T-1有0≤h≤T-1，这个范围可以保证，改变前和改变后灰度值变化范围的具有统一性。<br> 累积分布函数，这个函数最优先的地方就是可以同时达到上面两个条件，并且通过此 函数就可以将原来的图像m的分布转换成h分布。从而得出直方图均衡化的映射函数为下式:<br> = EQ( ) = (ni/n) = pm( ) ，<br> (k=0，1，2，…，T-1)</p> 
<p>根据方程，求和范围是0和K值，每个像素可以处理每个像素的灰度值.直接从原始的原始图像的直方图和灰度分布的统计分析，根据红外射线和重复计算的累积分布，源图像映射到地图的规模的结果的直方图均衡，灰度实现源图像像素的源图像可以通过转换成灰色度的规模。<br> 如果我们想实现直方图的均衡，这可以解释的具体公式计算直方图的方法来观察，仅仅通过数学公式不能完全解释从数学的角度来看。</p> 
<p>总之，均衡化是找到相应的函数S＝m（R），R作为输入信号，输出图像信号的图像，我们的目标是找到M公式，想象一个小图像区域的直方图分布在为处理图像部分。按照常识我们可知，柱状图很窄。如果想要将柱状图变成一个非常宽的直方图，这个时候就需要一个 拉伸函数。当然，可以直接使用绘制功能，不改变尺寸或改变图像中的像素的顺序，直接修改的错误是在图像内容的表示这样是便于理解，也是非常必要的。在正常情况下，图像的像素值是在0～255之间，如果我们尽可能将像素分布在0～255之间，值的灰度图像的灰度分布是不同的，当像素值形成一个新的原始图像的直方图时，将像素值的灰度分布扩大到0～255。</p> 
<p>该方法更适应于解决背景图像亮、前景模糊的图像。特别是在X射线图像中可以显示出更好的结构，并且即使图片曝光率较高，或者是不足，也可以在最大程度上更好地显示细节。这种方法的最先进之处是因为它是一种比较直观的技术，同时最独特的是它的操作是可逆的，在知道平衡函数的前提下，甚至可以还原出最初的直方图，并且计算 量很小。<br> 这种方法的一个缺点是它不选择处理过的数据。它可以增大背景噪声的对比度，减少有用信号的<br> 为了减少灰度值的变换，消除一些细节；直方图等图像具有峰值，并且处理后的对比度自然过度增强。</p> 
<h4><a id="33_knn_157"></a>3.3 knn算法分析</h4> 
<h5><a id="331_knn_159"></a>3.3.1 knn简介</h5> 
<p>最邻近元法是一种非常简单的插值方法，以简单快捷著称。其与其他的插值方法最大的差别在 于去不需要复杂的计算，使其对硬件要求更低，且反应更迅速。一个图像中的像素，是4个相邻像素为a，b，c，d，最近已在最近的像素像素像素像素的U＋V（i，j，j + V是大于零的整数，小于1的U，V和数字十进制数相同），待坐标像素的PIXEL，F值（J +灰色+ U，V）如图 3.1所示[3]:</p> 
<p><img src="https://images2.imgbox.com/fa/a8/3H2CkAOj_o.gif" alt="在这里插入图片描述"></p> 
<p>图3.1 像素坐标最邻近元法<br> 如果(i+u, j+v)落在A区，即u<em>0.5, v</em>0.5，然后，将左上角像素的灰度值给予需要的像素。同样，将右上角的像素灰度值给予B区域，并在C区域中给出左下角像素的灰度值，并将右下角像素的灰度值给予D区域，并且像素的灰度值为。<br> 最邻近元法的简便性是由于计算量较小，但是计算量小，也会造成缺陷的，例如，在灰度方面<br> ，采用最邻近元法就无法形成平滑的线，甚至在某些部分地方会出现锯齿形的线条。<br> <img src="https://images2.imgbox.com/42/2e/1PS0zgZX_o.gif" alt="在这里插入图片描述"></p> 
<p>图3.2 双线性内插<br> 由于 (i, j+v)，f(i, j) 到 f(i, j+1) 之间的灰度值变化为线性关系，就有了以下的公式:<br> f(i, j+v) = [f(i, j+1) - f(i, j)] * v + f(i, j)<br> 由此可以推出 (i+1, j+v) 以下式子:<br> f(i+1, j+v) = [f(i+1, j+1) - f(i+1, j)] * v + f(i+1, j)<br> 有上式可知，从f(i, j+v) 到 f(i+1, j+v) 之间的变化也为线性关系，由此可得出以下式子<br> f(i+u, j+v) = (1-u) * (1-v) * f(i, j) + (1-u) * v * f(i, j+1) + u * (1-v) * f(i+1, j) + u * v * f(i+1, j+1)。<br> <img src="https://images2.imgbox.com/7e/78/eqycp9I3_o.gif" alt="在这里插入图片描述"></p> 
<p>图3.3 最邻近插值放大图片<br> <img src="https://images2.imgbox.com/ac/3a/a1TF0wkk_o.gif" alt="在这里插入图片描述"></p> 
<p>图3.4 双线型内插值放大图片</p> 
<h5><a id="332_knn_187"></a>3.3.2 knn的优缺点</h5> 
<p>双线性内插法与最邻近点法相反，计算量很多，但是也是有优点的，相较于内插法，不会出现灰度不连续的情况。它具备着一部分性质，例如低通滤波，这样会直接导致高频分量的部分损坏，图<br> 像轮廓不会是高清，不是那么清楚。<br> 在进行比较后，本毕设选用计算量更少，更易得出结果的最邻近点法作为图像缩放的插值方法。 本系统尚存在不足，由于会出现灰度不连续的情况，偶尔会出现识别错误。<br> <img src="https://images2.imgbox.com/4d/76/J23WFgeZ_o.gif" alt="在这里插入图片描述"><br> 图 3.6 错误实例</p> 
<h4><a id="34__194"></a>3.4 自主降落系统设计</h4> 
<p>本文的内容主要从以下三个方面来进行介绍：<br> （1）基于地标的单目着陆<br> 使用张正- Yu标定方法，对摄像机进行位置标识，并在标记之前，对图像进行预处理。根据地标的几何特征，提出了一种基于轮廓拟合的地标识别算法，并在识别地标I的基础上实时计算了相机平面相对于地标表面的姿态和位置。信息。考虑到部分地标的可能性，分析了一些地标的特点。通过设置约束来识别一些地标，并根据一些地标来分析下一时刻无人机的平移方向和平移大小。<br> （2）基于双目视觉的无人直升机着陆<br> 基于密集视差图，双目自主着陆是空间点的三维重建，然后分析该区域的平面度和倾斜角。为此，建立了具有平行光轴的双目系统，并通过校准板校准。为了获得视差，分析了常用的立体匹配方法和极线校正方法。最后，通过视差图选择候选着陆区域，并对候选区域进行筛选以获得合适的着陆区域，跟踪区域之后是帧间点的前后匹配。<br> （3）通过MATLAB对中小型无人机自主降落过程中的进行模拟仿真，改进自主着陆算法。<br> 相对于实用性来说，因为无人机不同类型的不一样飞行模式和不相同摄像机器的不一样的图像属性，对无人机的真实自主降落地标识别的精度和时间指标没有相同的标准。其基本原理是在最短时间内能够最准确地识别着陆点。</p> 
<h5><a id="341__204"></a>3.4.1 单目地标识别算法-点特征定位</h5> 
<p>单目地标识别算法需要考虑两个方面。<br> 一是实时考虑无人机的姿态快速变化和大幅度振动等因素，要求算法能够快速有效地处理图像，获得位置和姿态INF。无人机当前框架的构建。<br> 二是与相机的图像噪声强，在求解姿态时依赖于离散角度，该算法抗干扰能力强，结果稳定。<br> 在传统模型的基础上的H的识别参考，提出了一种基于模式识别算法。该算法构建一个简单的几何模型来识别和选择的目的地，借助于摄像机的成像原理，图像坐标与摄像机成像模型，可以计算每一时刻的无人机，形状和地理位置的相对准确的参照点和分析有关情况。<br> 关于特征和定位是成为一个PnP问题，无人机的视野是一个相对复杂的部分。根据相机的特点，确定相应的地理位置和实时的描述看来，特别是相机校准和模型的小孔，以一个对象的坐标系统中的坐标， 且这n个图像点的坐标已知，就可以确认这n个空间点在相机坐标系下的坐标。<br> 这项研究基于解决问题的线性算法和PNP两方面。多数研究是关于确定性和线性算法两个方面的问题。并且，P5P P3P是非常有益的探索。结论如下：此时存在无穷大解，既不能确定两点，在摄像机坐标系的位置，在同一时刻，多个空间点在同一平面内的解是唯一的。四个不同的空间点，将有一系列的解决方案。该解决方案可以达到的上限是5，它具有测量精度高、测量速度快的特点，适合于空间和地面下，鲁棒性和特征点提取，通常设计的四点人工提高图标特征提取特征点的鲁棒性，相机的位置是唯一的，因为摄像机的唯一位置可以从同一平面获得。</p> 
<h5><a id="342__213"></a>3.4.2 双目降落区域选择</h5> 
<p>双目着陆区域的选择包括双目重建和着陆区域选择两部分。<br> 双目重建是通过两个摄像机恢复空间点的深度信息和三维坐标的过程。用于建立本文的双目模型都是具有相同摄像机类型的平行同轴系统。双目重建主要分为双目标定、极线校正、图像匹配和三维重建等步骤。双目标和极线校正主要涉及双目系统投影矩阵的计算和校正。图像点的计算是基于图像匹配和三维重建的。<br> 着陆区选择：两个相机的共同视觉假设书平面和墙是平坦区域。应满足要求的面积：直径为50cm的圆形区域，平面度小于5cm，倾斜到摄像机平面小于30度。经过三个阶段的区域预选、区域选择和区域跟踪，完成了登陆。</p> 
<h4><a id="35_matlab_219"></a>3.5 matlab路径规划仿真验证</h4> 
<p>Matlab发布了一个用于科学计算、可视化和交互式编程的高技术计算环境。它统计了数值的技术统计、矩阵计算、科学数据视觉化、非线性动态流动系统的建造模型和仿真的强大功能。它为一个易于使用的窗口环境提供了科学研究和工程设计的综合解决方案。许多科学领域必须是有效的。自创建以来，Matlab具备数据可视化功能，在图形中不仅可以显示矢量，也可以呈现出矩阵，并对图形进行标记和打印。高画图包括2D和3D可视化、图像处理、动画和面部表情映射。可用于科学计算和工程制图。新版本的MATLAB极大地改进和完善了整个图形处理功能，使其不仅在一般数据可视化软件的功能上更完美，如三维曲面的绘制和处理，而且还适用于其他软件，如LIG图形，HT处理。MATLAB还具有良好的加工能力。同时，对一些特殊的要求，如对话，图形显示，包括相应的MATLAB功能，确保用户可以在完全不同的需求层次之间都可以使用。新版本的MATLAB软件的图形用户界面（GUI）的创建中取得了巨大的成就，在这一领域，也可以满足具有特殊要求的用户。讲述了无人机航迹规划的基本思想。将路径点彼此连接，以限制每个路径点的无人机的起点和终点，并将其应用于无人机路径规划。网络图中寻找最短路径算法。由于该算法利用条件的线之间的连接点，而不是整个空间的最优路径规划算法，然后使用一个调整算法寻找最短路径的，使每个点在相应的OBST上滑动。可以通过列出的规则确定LE端线和相应的路径点，也就是说，可以确定新的路径点。路径点作为最优路径连接到路径点。</p> 
<h4><a id="36__223"></a>3.6 本章小节</h4> 
<p>本章是本文最重要的一部分，讲解了无人机自主着陆过程中，地面的情况的识别所涉及到的算法。首先在第一节，介绍了二值化，通过二值化，将图像灰度化，十分方便图像的后续好处理。在第二节，详细讲述了直方图的均衡化，将这种仅由输入直方图信息就可以自动的实现这种效果的变换函数进行分析。在扩大图像中的像素数之后，压缩灰度级，从而有效扩大像素值的动态范围，能够有效提高对比度和灰度色调的区别，使图像更加清楚。第三节就是讲述knn算法，并分别从理论方面，优缺点方面，结合图像识别效果进行分析。第四节描述的是自主降落系统设计的部分知识，在第一小部分介绍单目地标识别算法，即点特征定位。第二小节进行双目降落区域选择判断。第五小节是借助于matlab进行路径规划的仿真检测。</p> 
<h3><a id="__227"></a>第四章 无人机自主降落环境识别算法</h3> 
<h4><a id="41__229"></a>4.1 算法流程图</h4> 
<p>在实践中，K近邻分类器需要找到一个范围值L1或L2范数，或需要使用选择标准的计算距离的超参数，这些参数在参数整定过程中测试集是不可以进行任何调整的，因为它会过度拟合的模型试验，模型的泛化能力将会大大降低。因此，测试数据集，仅仅使用一次，即在训练完成后，便对最终的模型进行评估。</p> 
<p>培训的比例在50%～90%的训练在训练和验证，包括验证模型对训练集的调整超参数的选择。例如，在超参数K，K值为完全不同的训练，然后使用测试和分析哪个K值是最好的，然后使用的k值为真正的运行试验，并评估算法。</p> 
<p>交叉验证，有时训练集的数量较小，这时候可以采用一种交叉验证的方法，这是一种比较复杂的方式。在前一个例子中，如果它是交叉验证集，就不再需要100个图像来进行 检测，取而代之的是将训练集划分为五个，其中四个用于训练，一个用来做实验的验证。最后，将所有实验的五个测试结果的平均值作为算法验证的结果。<br> 当然在实际应用中，事实上，在研究中很少使用交叉验证，因为它消耗了更多的计算资源。一般情况下，训练集按比例为40%～80%来将其分为训练集和验证集。但这也是根据具体的一些情况来分析的：如果拥有大量的参数，则可能需要更多的验证数据来验证实验分析，而验证集的数量显然是没有那么多的，那么最好采用的就是交叉验证的方法。至于具体分为几个部分，通常是分为三, 五部分和十部分。</p> 
<p>这种方法十分的简单有效，而且精度极高，对离群点不敏感，没有数据输入假设这一说法。<br> 但是这种方法计算复杂度很高，而且相对于空间的复杂程度也很高，由于需要对数据集中每个数据集的距离值进行计算，因此在实际使用中会非常消耗时间；此外，它不能提供关于数据的基本结构的任何信息，所以有些时候不知道样本的经典样本具体有哪些。</p> 
<h4><a id="42__245"></a>4.2 具体步骤</h4> 
<p>（1）数据样本采集：可采用与之相关的任何方法；<br> （2）相关需要准备数据：距离计算需要的数值，最好采用结构化数据格式。<br> （3）数据提取分析：用计算机对采集的图片进行分析；<br> （4）训练knn算法：采用大量图面，输入基准图片，进行算法训练。<br> （5）测试knn算法：计算knn算法的错误率；<br> （6）使用该算法：首先，需要输入样本数据和结构化输出结果，然后运行Knn算法来确定属于哪个类别的输入数据，然后将后续处理应用到计算的分类中。<br> 在测试算法中，对相关预测试的180幅图像进行了研究。证明了无人机能够在图像的某一部分上着陆，成功地实现了该功能。但在180个测试结果中，可以看出识别成功率不高，识别错误极少，正确率约为75%，证明了该程序算法仍有很大的推广空间。</p> 
<p>图4.1 knn算法准确率</p> 
<h4><a id="43__257"></a>4.3 系统流程</h4> 
<p>对不确定属性的数据集中的每个点都执行下面的操作：</p> 
<p>（1）计算数据点集和当前点距离。<br> （2）按照生长顺序的距离缓慢，依次选择分布；<br> （3）电流点之间的最小距离的选择。<br> （4）确定第一类K点的频率点；<br> （5）在返回到较高频率点之前，作为当前的分类预测。</p> 
<h3><a id="__267"></a>第五章 无人机自主降落的环境测试</h3> 
<h4><a id="51__269"></a>5.1 测试的意义和方法</h4> 
<p>一般来说，系统测试是执行程序以检测错误的过程。成功的测试是发现尚未发现的错误测试[19]。换句话说，测试是为了找到系统的错误[17]。测试就是检查程序。在这样的过程中，每一个故障被发现是快乐的，因为它也可以排除潜在的危险，并且如果系统被投入使用后发现系统是错误的，系统将花费更多的物质和财力资源。要解决这个问题，无疑会增加投资成本，甚至更为严重，甚至导致以前投资的浪费。因此，在系统投入使用之前，尽可能彻底地对系统进行测试无疑是必要和重要的。</p> 
<p>在实际生产和生活中，在实际的系统工作环境中，通过与以往的需求分析相比较，检查功能的实现是否满足需求分析的要求，是否满足客户的要求，从而达到本课题的目的。<br> 从程序内部结构的角度，将软件测试分为黑盒测试和白盒测试。黑盒测试简单来说就是指程序作为一个黑盒子，里面看不到，只关心输入和输出结果的正确性[18]。白盒测试将程序视为透明框，然后分析程序的内部操作是否正确[12]。这两种方法各有优缺点，但本课题主要采用黑盒测试。</p> 
<h4><a id="52__276"></a>5.2 系统的配置</h4> 
<p>1、硬件配置要求：<br> CPU：2GHz以上。<br> 内存：1GB以上。<br> 硬盘：256GB或以上（能够使用的空间最好在60GB以上）。</p> 
<p>2、软件配置要求：<br> Windowsxp或win7系统。</p> 
<h4><a id="53__286"></a>5.3 程序分析</h4> 
<p>代码文件 列举函数 代码功能 说明<br> classify.m function [class] = classify(image) 识别图片 利用 fitcknn，predict<br> get_features.m rgb2hsv,imhist 绘制直方图 获取二值化图像区域特征<br> recognition.m testfea，samplefea 识别 利用颜色特征，欧式距离最小<br> RGB2bw.m rgb2gray,graythresh 二值化彩色图像 将彩色图像转化成灰度图<br> main.m main_OutputFcn,open_Callback 对输入图像的尺寸做调整,识别地形 按照图片特征识别地形</p> 
<p>表 5.1 代码文件介绍</p> 
<p>1、在识别图片部分，使用湖泊，沙漠，草地，水泥地进行识别，可以得出最终的识别效果。<br> function [class] = classify(image)<br> %UNTITLED 此处显示有关此函数的摘要<br> % 输入600<em>400</em>3 的图像<br> im=image(😃;%转成1列<br> traindata=importdata(‘traindata.mat’);<br> label =importdata(‘label.mat’);</p> 
<pre><code>kNNClassifier = fitcknn(traindata', label', 'NumNeighbors',1) ;
class = predict(kNNClassifier, double(im'));
</code></pre> 
<p>% str = {‘识别结果为:湖泊’,‘识别结果为:沙漠’,‘识别结果为:水泥地’,‘识别结果为:草地’};<br> end</p> 
<p>2、在绘制直方图的时候，利用二值化区域对象特征进行分析：</p> 
<p>function tfeat = get_features(colorimg, mask)<br> % 特征提取函数<br> %coloring: 彩色RGB图像数据<br> %mask ：二值化后图像数据<br> hsvimg = rgb2hsv(colorimg);<br> h = hsvimg(:,:,1);<br> mask1 = mask(😃; %转化成一列数据<br> index = mask1&gt;0 ;zh<br> [counts,x] = imhist(h(index)); %绘制直方图<br> %获取直方图信息，counts为每一级灰度像素个数<br> Hue = find(counts == max(counts));<br> % ShapeValue = regionprops(mask, ‘majoraxislength’,‘minoraxislength’);<br> % Shape = ShapeValue.MajorAxisLength/ShapeValue.MinorAxisLength;<br> ShapeValue = regionprops(mask, ‘eccentricity’);%获取二值化图像区域特征<br> Shape = ShapeValue.Eccentricity;<br> tfeat = [Hue, Shape ];<br> %tfeat = [feat1 feat2 f.Orientation f2.Eccentricity f1.Extent];</p> 
<p>3、利用颜色特征，来计算出最小距离，从而规划出最优路线：<br> function index = recognition(testfea, samplefea)<br> % 识别<br> % 利用颜色特征，欧式距离最小<br> th = testfea(:,1);<br> sh = samplefea(:,1);<br> for i=1:4<br> for j=1:4<br> Dis(j) = norm(th(i)-sh(j));<br> end<br> [data index1(i)] = min(Dis);<br> end</p> 
<p>tS = testfea(:,2);<br> sS = samplefea(:,2);<br> for i=1:4<br> for j=1:4<br> Dis(j) = norm(tS(i)-sS(j));<br> end<br> [data index2(i)] = min(Dis);<br> end</p> 
<p>index = index1;</p> 
<p>4、二值化彩色图像，调用rgb2gray()函数将彩色图像转化成灰度图，然后调用graythresh()函数计算阈值，创建5 * 5 的结构元素对象：<br> function bwpic = RGB2bw(img)<br> grayimg = rgb2gray(img);<br> level = graythresh(grayimg);<br> bwpic=imbinarize(grayimg,level);<br> SE = strel(‘rectangle’, [4 4]);<br> bwpic = imerode(bwpic, SE);<br> bwpic = imdilate(bwpic, SE);<br> % imshow(bwpic)<br> end<br> 5.2 测试结果分析<br> 针对部分图片进行了测试：<br> 测试结果如下：</p> 
<p>图像含有特征，灰色平底，识别地形为：水泥地，无人机当前下降速度为 2m/s<br> 图5.4<br> 图片含有特征 绿草 识别地形为 草地 无人机当前下降速度为8m/s<br> 图5.5</p> 
<h4><a id="53__377"></a>5.3 本章小节</h4> 
<p>本章对一些图片进行测试，因为测试就是为程序进行把关，在测试过程中，发现了一些错误，这可以排除了一个潜在的隐患，同时系统如果要是经过测试投入使用后再发现系统的错误，那么将会花费更多的物力和财力才能解决问题，这样无疑会造成投入成本增加，更严重的甚至导致该系统不能使用白白浪费了之前的投入。所以本章首先对程序进行分析，classify.m，get_features.m，recognition.m，RGB2bw.m，main.m，接着，测试一些图片的准确度。</p> 
<h3><a id="__383"></a>第六章 总结与展望</h3> 
<p>本文针对无人机着陆控制问题，深入研究了图片识别分析，在MATLAB环境下，对无人机图片识别进行了大量的实验研究，给出了相应结果。数字结果、无人机降落时的速度以及能够进行地形分析，从某种意义上来说是非常合理的，如果不进行人工干扰，着陆点的控制方法和控制参数的规律是正确的。它能够正确的分析图片上面的地形并且能够满足要求。本人认为在无人机识别图片方向具有很大效果。<br> 鉴于无人机在飞行中具有最大的机会点不能找到地标，特地采用了六个基准图作为地形标准。为了解决飞行过程中拍摄大型图片的无人机位置的识别问题，可以在某个半径的不变化部分，作为提取的特点，进行与标准图片进行分析。从而可以进行真实地形的测试，由此可以得出以下结论：在地形比较大的情况下，用摄像机采取小块地形选择，与标准图片对比看无人机是否可以降落。根据数据库可以对训练集进行培训，使样本可以智能化的区分地形。与其他实验办法相比，这种办法即有效成功率又高，可以在飞行过程中提高无人机的分类识别精度，从而减少时间，提高识别效率。<br> 因此，我们必须继续研究基于视觉的无人机降落方法，从而能够提取无人机更好的降落手段，在采用摄像机的条件上，进行降落目标的坐标系的图像坐标，让无人机在想要降落的时候每一刻都在计算无人机与可降落位置之间的关系，达到最好的降落效果。</p> 
<p>参考文献</p> 
<p>[1] 刘奇图像拼接技术及其在医学图像处理中的应用[D]. 西北工业大学,2015.<br> [2] Wei J, Li C F, Hu S M, et al. Fisheye Video Correction[J]. IEEE Transactions on Visualization &amp; Computer Graphics, 2016, 18(10):1771-1783.<br> [3] Carroll R, Agrawal M, Agarwala A. Optimizing content-preserving projections for wide-angle images[J]. ACM Transactions on Graphics (TOG), 2015, 28(3):1-9.<br> [4] 万明.基于视觉导航的无人机自主着陆飞行参数估计方法[D].南京航空航天大学, 2015.<br> [5] 宋琳.无人机飞行途中视觉导航关键技术研究[D]. 西北工业大学, 2015.<br> [6] 朱玮. 基于视觉的四旋翼飞行器目标识别及跟踪[D]. 南京航空航天大学, 2014.<br> [7] 刘士清，胡春华，朱纪洪. 基于计算机视觉的无人直升机位姿估计方法研究[J]. 计算机工程与设计，2016, 25(4):564 568.<br> [8] 梁焜.电力巡线无人机地面监控技术研究[D].南京航空航天大学,2016.<br> [9] 朱富丽.MATLAB在数字图像处理技术方面的应用[J].计算机光盘软件与应用，2016,7(4):42-44.<br> [10] 毛涛涛.精通MATLAB GUI设计[M].北京:电子工业出版社,2017.</p> 
<p>附录<br> 1.classify.m<br> function [class] = classify(image)<br> %UNTITLED 此处显示有关此函数的摘要<br> % 输入600<em>400</em>3 的图像<br> im=image(😃;%转成1列<br> traindata=importdata(‘traindata.mat’);<br> label =importdata(‘label.mat’);</p> 
<pre><code>kNNClassifier = fitcknn(traindata', label', 'NumNeighbors',1) ;
class = predict(kNNClassifier, double(im'));
</code></pre> 
<p>% str = {‘识别结果为:湖泊’,‘识别结果为:沙漠’,‘识别结果为:水泥地’,‘识别结果为:草地’};</p> 
<p>end</p> 
<p>2.get_features.m<br> function tfeat = get_features(colorimg, mask)<br> % 特征提取函数<br> %coloring: 彩色RGB图像数据<br> %mask ：二值化后图像数据<br> hsvimg = rgb2hsv(colorimg);<br> h = hsvimg(:,:,1);<br> mask1 = mask(😃; %转化成一列数据<br> index = mask1&gt;0 ;zh<br> [counts,x] = imhist(h(index)); %绘制直方图<br> %获取直方图信息，counts为每一级灰度像素个数<br> Hue = find(counts == max(counts));<br> % ShapeValue = regionprops(mask, ‘majoraxislength’,‘minoraxislength’);<br> % Shape = ShapeValue.MajorAxisLength/ShapeValue.MinorAxisLength;<br> ShapeValue = regionprops(mask, ‘eccentricity’);%获取二值化图像区域特征<br> Shape = ShapeValue.Eccentricity;<br> tfeat = [Hue, Shape ];<br> %tfeat = [feat1 feat2 f.Orientation f2.Eccentricity f1.Extent];</p> 
<p>3.main.m</p> 
<p>function varargout = main(varargin)<br> % MAIN MATLAB code for main.fig<br> % MAIN, by itself, creates a new MAIN or raises the existing<br> % singleton*.<br> %<br> % H = MAIN returns the handle to a new MAIN or the handle to<br> % the existing singleton*.<br> %<br> % MAIN(‘CALLBACK’,hObject,eventData,handles,…) calls the local<br> % function named CALLBACK in MAIN.M with the given input arguments.<br> %<br> % MAIN(‘Property’,‘Value’,…) creates a new MAIN or raises the<br> % existing singleton*. Starting from the left, property value pairs are<br> % applied to the GUI before main_OpeningFcn gets called. An<br> % unrecognized property name or invalid value makes property application<br> % stop. All inputs are passed to main_OpeningFcn via varargin.<br> %<br> % *See GUI Options on GUIDE’s Tools menu. Choose “GUI allows only one<br> % instance to run (singleton)”.<br> %<br> % See also: GUIDE, GUIDATA, GUIHANDLES</p> 
<p>% Edit the above text to modify the response to help main</p> 
<p>% Last Modified by GUIDE v2.5 06-Mar-2018 09:18:50</p> 
<p>% Begin initialization code - DO NOT EDIT<br> gui_Singleton = 1;<br> gui_State = struct(‘gui_Name’, mfilename, …<br> ‘gui_Singleton’, gui_Singleton, …<br> ‘gui_OpeningFcn’, @main_OpeningFcn, …<br> ‘gui_OutputFcn’, @main_OutputFcn, …<br> ‘gui_LayoutFcn’, [] , …<br> ‘gui_Callback’, []);<br> if nargin &amp;&amp; ischar(varargin{1})<br> gui_State.gui_Callback = str2func(varargin{1});<br> end</p> 
<p>if nargout<br> [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});<br> else<br> gui_mainfcn(gui_State, varargin{:});<br> end<br> % End initialization code - DO NOT EDIT</p> 
<p>% — Executes just before main is made visible.<br> function main_OpeningFcn(hObject, eventdata, handles, varargin)<br> % This function has no output args, see OutputFcn.<br> % hObject handle to figure<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles structure with handles and user data (see GUIDATA)<br> % varargin command line arguments to main (see VARARGIN)</p> 
<p>% Choose default command line output for main<br> handles.output = hObject;</p> 
<p>% Update handles structure<br> guidata(hObject, handles);</p> 
<p>% UIWAIT makes main wait for user response (see UIRESUME)<br> % uiwait(handles.figure1);</p> 
<p>% — Outputs from this function are returned to the command line.<br> function varargout = main_OutputFcn(hObject, eventdata, handles)<br> % varargout cell array for returning output args (see VARARGOUT);<br> % hObject handle to figure<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles structure with handles and user data (see GUIDATA)</p> 
<p>% Get default command line output from handles structure<br> varargout{1} = handles.output;</p> 
<p>% — Executes on button press in open.<br> function open_Callback(hObject, eventdata, handles)<br> % hObject handle to open (see GCBO)<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles structure with handles and user data (see GUIDATA)<br> global image;<br> % cla(handles.axes1);<br> [filename,pathname]=uigetfile({‘<em>.jpg’;'</em>.bmp’;‘*.gif’},‘选择图片’);<br> if isequal(filename,0)<br> disp(‘Users Selected Canceled’);<br> else<br> str=[pathname filename];<br> image = imread(str);<br> axes(handles.axes1);%axes1是坐标轴的标示<br> imshow(image);<br> end;<br> set(handles.showname,‘string’,‘识别结果为…’);<br> set(handles.feature,‘string’,‘识别结果为…’);<br> % — Executes on button press in classify.<br> function classify_Callback(hObject, eventdata, handles)<br> % hObject handle to classify (see GCBO)<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles structure with handles and user data (see GUIDATA)<br> %<br> global image ;<br> imsize=size(image);<br> im=imresize(image,[400,600]);%对输入图像的尺寸做调整<br> im=im(😃;%转成1列<br> traindata=importdata(‘traindata.mat’);<br> label =importdata(‘label.mat’);<br> %草地=1；湖泊=2；沙漠=3；水泥地=4；障碍物碎石=5；湖泊=6；<br> kNNClassifier = fitcknn(traindata’, label’, ‘NumNeighbors’,1) ;<br> class = predict(kNNClassifier, double(im’));<br> % str = {‘识别结果为:草地’,‘识别结果为:湖泊’,‘识别结果为:沙漠’,‘识别结果为:水泥地’,‘识别结果为:障碍物碎石’,‘识别结果为:湖泊’};<br> str2={'无人机当前下降速度:10m/s ','禁止无人机下落 ','无人机当前下降速度:5m/s ','无人机当前下降速度:2m/s ','无人机当前下降速度:1m/s ','禁止无人机下落 '};<br> str3={‘图片含有特征 绿草,识别地形为：草地,’,‘图片含有特征 水面,识别地形为：湖泊’,‘图片含有特征 黄沙,识别地形为：沙漠’,‘图片含有特征 灰色平地,识别地形为：水泥地’,‘图片含有特征sh 碎石,识别地形为：障碍物碎石’,‘图片含有特征 水面,识别地形为：沼泽’};<br> set(handles.showname,‘string’,str2(class));<br> set(handles.feature,‘string’,str3(class));</p> 
<p>if class<mark>1<br> hold on ;<br> alpha=0:pi/20:2<em>pi;%角度[0,2</em>pi]<br> R=80;%半径<br> x=R<em>cos(alpha);<br> y=R</em>sin(alpha);<br> plot(300+x,200+y,‘r-’,‘linewidth’,3)<br> hold off;<br> elseif class</mark>2<br> hold on ;<br> % x1=imsize(2)<em>0.25:1:imsize(2)<em>0.75;<br> % y1=(imsize(1)/imsize(2))<em>x1;<br> %<br> % x2=imsize(2)<em>0.25:1:imsize(2)<em>0.75;<br> % y2=-(imsize(1)/imsize(2))<em>x2+imsize(1);<br> %<br> % plot(x1,y1,‘r’,‘linewidth’,3);<br> % plot(x2,y2,‘r’,‘linewidth’,3);<br> alpha=0:pi/20:2</em>pi;%角度[0,2</em>pi]<br> R=80;%半径<br> x=R</em>cos(alpha);<br> y=R</em>sin(alpha);<br> plot(400+x,500+y,‘r-’,‘linewidth’,3)<br> hold off;<br> elseif class==3<br> hold on ;<br> alpha=0:pi/20:2</em>pi;%角度[0,2</em>pi]<br> R=60;%半径<br> x=R<em>cos(alpha);<br> y=R</em>sin(alpha);<br> plot(400+x,250+y,‘r-’,‘linewidth’,3)<br> hold off;<br> elseif class<mark>4<br> hold on ;<br> alpha=0:pi/20:2<em>pi;%角度[0,2</em>pi]<br> R=60;%半径<br> x=R<em>cos(alpha);<br> y=R</em>sin(alpha);<br> plot(150+x,230+y,‘r-’,‘linewidth’,3)<br> hold off;<br> elseif class</mark>5<br> hold on ;<br> alpha=0:pi/20:2<em>pi;%角度[0,2</em>pi]<br> R=100;%半径<br> x=R<em>cos(alpha);<br> y=R</em>sin(alpha);<br> plot(530+x,320+y,‘r-’,‘linewidth’,3)<br> hold off;<br> elseif class==6<br> hold on ;<br> % x1=imsize(2)*0.25:1:imsize(2)*0.75;<br> % y1=(imsize(1)/imsize(2))<em>x1;<br> %<br> % x2=imsize(2)<em>0.25:1:imsize(2)<em>0.75;<br> % y2=-(imsize(1)/imsize(2))<em>x2+imsize(1);<br> %<br> % plot(x1,y1,‘r’,‘linewidth’,3);<br> % plot(x2,y2,‘r’,‘linewidth’,3);<br> alpha=0:pi/20:2</em>pi;%角度[0,2</em>pi]<br> R=60;%半径<br> x=R</em>cos(alpha);<br> y=R</em>sin(alpha);<br> plot(150+x,360+y,‘r-’,‘linewidth’,3)<br> hold off;<br> end</p> 
<p>% — Executes on button press in esc.<br> function esc_Callback(hObject, eventdata, handles)<br> % hObject handle to esc (see GCBO)<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles structure with handles and user data (see GUIDATA)<br> close;</p> 
<p>% — Executes during object creation, after setting all properties.<br> function figure1_CreateFcn(hObject, eventdata, handles)<br> % hObject handle to figure1 (see GCBO)<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles empty - handles not created until after all CreateFcns called</p> 
<p>% — Executes during object creation, after setting all properties.<br> function feature_CreateFcn(hObject, eventdata, handles)<br> % hObject handle to feature (see GCBO)<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles empty - handles not created until after all CreateFcns called</p> 
<p>4.recognition.m<br> function index = recognition(testfea, samplefea)<br> % 识别<br> % 利用颜色特征，欧式距离最小<br> th = testfea(:,1);<br> sh = samplefea(:,1);<br> for i=1:4<br> for j=1:4<br> Dis(j) = norm(th(i)-sh(j));<br> end<br> [data index1(i)] = min(Dis);<br> end</p> 
<p>tS = testfea(:,2);<br> sS = samplefea(:,2);<br> for i=1:4<br> for j=1:4<br> Dis(j) = norm(tS(i)-sS(j));<br> end<br> [data index2(i)] = min(Dis);<br> end</p> 
<p>index = index1;</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c847a986ea72ac614b1ed992490447a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Proteus仿真】【Arduino单片机】水箱液位监控系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bb9b8a5f7d96b9a919a03ed14bba75c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pulsar原来是这样操作topic的</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>