<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>dma_buf_export - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="dma_buf_export" />
<meta property="og:description" content="/**
* DOC: dma buf device access
*
* For device DMA access to a shared DMA buffer the usual sequence of operations
* is fairly simple:
*
* 1. The exporter defines his exporter instance using
* DEFINE_DMA_BUF_EXPORT_INFO() and calls dma_buf_export() to wrap a private
* buffer object into a &amp;dma_buf. It then exports that &amp;dma_buf to userspace
* as a file descriptor by calling dma_buf_fd().
*
* 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/88862990d6c5ba6df46aaa87131d7d7b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-10T22:58:27+08:00" />
<meta property="article:modified_time" content="2022-06-10T22:58:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">dma_buf_export</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>/**<br>  * DOC: dma buf device access<br>  *<br>  * For device DMA access to a shared DMA buffer the usual sequence of operations<br>  * is fairly simple:<br>  *<br>  * 1. The exporter defines his exporter instance using<br>  *    DEFINE_DMA_BUF_EXPORT_INFO() and calls dma_buf_export() to wrap a private<br>  *    buffer object into a &amp;dma_buf. It then exports that &amp;dma_buf to userspace<br>  *    as a file descriptor by calling dma_buf_fd().<br>  *<br>  * 2. Userspace passes this file-descriptors to all drivers it wants this buffer<br>  *    to share with: First the filedescriptor is converted to a &amp;dma_buf using<br>  *    dma_buf_get(). Then the buffer is attached to the device using<br>  *    dma_buf_attach().<br>  *<br>  *    Up to this stage the exporter is still free to migrate or reallocate the<br>  *    backing storage.<br>  *<br>  * 3. Once the buffer is attached to all devices userspace can initiate DMA<br>  *    access to the shared buffer. In the kernel this is done by calling<br>  *    dma_buf_map_attachment() and dma_buf_unmap_attachment().<br>  *<br>  * 4. Once a driver is done with a shared buffer it needs to call<br>  *    dma_buf_detach() (after cleaning up any mappings) and then release the<br>  *    reference acquired with dma_buf_get by calling dma_buf_put().<br>  *<br>  * For the detailed semantics exporters are expected to implement see<br>  * &amp;dma_buf_ops.<br>  */</p> 
<p>/**<br>  * dma_buf_export - Creates a new dma_buf, and associates an anon file<br>  * with this buffer, so it can be exported.<br>  * Also connect the allocator specific data and ops to the buffer.<br>  * Additionally, provide a name string for exporter; useful in debugging.<br>  *<br>  * @exp_info:    [in]    holds all the export related information provided<br>  *            by the exporter. see &amp;struct dma_buf_export_info<br>  *            for further details.<br>  *<br>  * Returns, on success, a newly created dma_buf object, which wraps the<br>  * supplied private data and operations for dma_buf_ops. On either missing<br>  * ops, or error in allocating struct dma_buf, will return negative error.<br>  *<br>  * For most cases the easiest way to create @exp_info is through the<br>  * %DEFINE_DMA_BUF_EXPORT_INFO macro.<br>  */<br> struct dma_buf *<span style="color:#fe2c24;">dma_buf_export</span>(const struct dma_buf_export_info *exp_info)<br> {<!-- --><br>     struct dma_buf *dmabuf;<br>     struct dma_resv *resv = exp_info-&gt;resv;<br>     struct file *file;<br>     size_t alloc_size = sizeof(struct dma_buf);<br>     int ret;</p> 
<p>    if (!exp_info-&gt;resv)<br>         alloc_size += sizeof(struct dma_resv);<br>     else<br>         /* prevent &amp;dma_buf[1] == dma_buf-&gt;resv */<br>         alloc_size += 1;</p> 
<p>    if (WARN_ON(!exp_info-&gt;priv<br>               || !exp_info-&gt;ops<br>               || !exp_info-&gt;ops-&gt;map_dma_buf<br>               || !exp_info-&gt;ops-&gt;unmap_dma_buf<br>               || !exp_info-&gt;ops-&gt;release)) {<!-- --><br>         return ERR_PTR(-EINVAL);<br>     }</p> 
<p>    if (!try_module_get(exp_info-&gt;owner))<br>         return ERR_PTR(-ENOENT);</p> 
<p>    dmabuf = kzalloc(alloc_size, GFP_KERNEL);<br>     if (!dmabuf) {<!-- --><br>         ret = -ENOMEM;<br>         goto err_module;<br>     }</p> 
<p>    dmabuf-&gt;priv = exp_info-&gt;priv;<br>     dmabuf-&gt;ops = exp_info-&gt;ops;<br>     dmabuf-&gt;size = exp_info-&gt;size;<br>     dmabuf-&gt;exp_name = exp_info-&gt;exp_name;<br>     dmabuf-&gt;owner = exp_info-&gt;owner;<br>     spin_lock_init(&amp;dmabuf-&gt;name_lock);<br>     init_waitqueue_head(&amp;dmabuf-&gt;poll);<br>     dmabuf-&gt;cb_excl.poll = dmabuf-&gt;cb_shared.poll = &amp;dmabuf-&gt;poll;<br>     dmabuf-&gt;cb_excl.active = dmabuf-&gt;cb_shared.active = 0;</p> 
<p>    if (!resv) {<!-- --><br>         resv = (struct dma_resv *)&amp;dmabuf[1];<br>         dma_resv_init(resv);<br>     }<br>     dmabuf-&gt;resv = resv;</p> 
<p>    file = <span style="color:#fe2c24;">dma_buf_getfile</span>(dmabuf, exp_info-&gt;flags);<br>     if (IS_ERR(file)) {<!-- --><br>         ret = PTR_ERR(file);<br>         goto err_dmabuf;<br>     }</p> 
<p>    file-&gt;f_mode |= FMODE_LSEEK;<br>     dmabuf-&gt;file = file;</p> 
<p>    mutex_init(&amp;dmabuf-&gt;lock);<br>     INIT_LIST_HEAD(&amp;dmabuf-&gt;attachments);</p> 
<p>    mutex_lock(&amp;db_list.lock);<br>     list_add(&amp;dmabuf-&gt;list_node, &amp;db_list.head);<br>     mutex_unlock(&amp;db_list.lock);</p> 
<p>    return dmabuf;</p> 
<p>err_dmabuf:<br>     kfree(dmabuf);<br> err_module:<br>     module_put(exp_info-&gt;owner);<br>     return ERR_PTR(ret);</p> 
<p></p> 
<p>static struct file *<span style="color:#fe2c24;">dma_buf_getfile</span>(struct dma_buf *dmabuf, int flags)<br> {<!-- --><br>     struct file *file;<br>     struct inode *inode = alloc_anon_inode(dma_buf_mnt-&gt;mnt_sb);</p> 
<p>    if (IS_ERR(inode))<br>         return ERR_CAST(inode);</p> 
<p>    inode-&gt;i_size = dmabuf-&gt;size;<br>     inode_set_bytes(inode, dmabuf-&gt;size);</p> 
<p>    file = alloc_file_pseudo(inode, dma_buf_mnt, "dmabuf",<br>                  flags, &amp;<span style="color:#fe2c24;">dma_buf_fops</span>);<br>     if (IS_ERR(file))<br>         goto err_alloc_file;<br>     file-&gt;f_flags = flags &amp; (O_ACCMODE | O_NONBLOCK);<br>     file-&gt;private_data = dmabuf;<br>     file-&gt;f_path.dentry-&gt;d_fsdata = dmabuf;</p> 
<p>    return file;</p> 
<p>err_alloc_file:<br>     iput(inode);<br>     return file;<br> }</p> 
<p>static const struct <span style="color:#fe2c24;">file_operations dma_buf_fops </span>= {<!-- --><br>     .release    = dma_buf_file_release,<br>     .mmap        = dma_buf_mmap_internal,<br>     .llseek        = dma_buf_llseek,<br>     .poll        = dma_buf_poll,<br>     .unlocked_ioctl    = dma_buf_ioctl,<br> #ifdef CONFIG_COMPAT<br>     .compat_ioctl    = dma_buf_ioctl,<br> #endif<br>     .show_fdinfo    = dma_buf_show_fdinfo,<br> };</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8940caafc28197fb2c8ce1cd942925b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">原生微信小程序自定义组件以及组件间通讯</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/484e54231a718914a185b6df7477e827/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue.js nextTick 源码分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>