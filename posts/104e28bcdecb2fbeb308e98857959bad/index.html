<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【百战GAN】StyleGAN人脸属性（表情年龄性别）编辑代码实战 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【百战GAN】StyleGAN人脸属性（表情年龄性别）编辑代码实战" />
<meta property="og:description" content="大家好，欢迎来到专栏《百战GAN》，在这个专栏里，我们会进行GAN相关项目的核心思想讲解，代码的详解，模型的训练和测试等内容。
作者&amp;编辑 | 言有三
本文资源与生成结果展示
本文篇幅：7000字
背景要求：会使用Python和Pytorch
附带资料：参考论文和项目，视频讲解
1 项目背景
作为一门新兴的技术，GAN在很多人脸图像任务中有着广泛的应用，下面列举了一些典型的方向。
比如使用SRGAN进行人脸超分辨，使用BeautyGAN进行人脸美颜，使用Deepfake进行换脸。如今，基于人脸属性编辑的技术在抖音快手等应用中都是非常受欢迎的技术，比如可以体验让人变老变小，如下图年龄的更改。
年龄编辑
这背后的核心技术之一就是在生成模型的Latent空间进行属性向量的编辑，然后通过生成模型来获取最终结果图，其中最典型的代表性框架就是StyleGAN，本次我们来实战使用StyleGAN进行人脸属性编辑。
在阅读接下来的内容之前，请大家务必回顾之前StyleGAN人脸生成的内容，没有这一部分内容基础，无法学习接下来的内容。
【百战GAN】StyleGAN原理详解与人脸图像生成代码实战
【项目实战课】基于Pytorch的StyleGAN v1人脸图像生成实战
2 原理简介
现在我们要使用StyleGAN进行真实人脸的编辑，需要解决2个关键问题。
(1) 如何获得真实人脸的潜在编码向量，它对应StyleGAN中的映射网络（mapping network）的输入Z或者输出W。
(2) 如何通过修改Z或者W向量，控制生成人脸图像的高层语义属性。
接下来我们重点介绍潜在编码向量的求解，并在下一节中实验基于潜在编码向量的属性编辑。
当前对真实人脸编码向量的求取基本上基于两种思路，一种是学习一个编码器来实现映射，一种是直接对向量进行优化求解。
2.1 基于编码器的求解
基于编码器的求解框架如下图所示，由两部分模块组成。
Encoder表示需要训练的编码器，Decoder表示已经训练完的生成模型，如StyleGAN的生成器部分。真实图像输入编码器得到Z或者W，再输入生成器得到生成的人脸，完成人脸图像的重建。
通过直接学习一个编码器，可以不需要对每一张图都进行优化，实现一次训练，对任意图像都能提取潜在编码向量，但是也容易在训练数据集上发生过拟合。
2.2 基于优化求解的方法
另外一种方法就是基于优化求解，直接对每一张图片优化出对应的W，在StyleGAN v2，Image2StyleGAN等框架中采用了这种方案，并且512维的W被拓展成W&#43;, W&#43;为18×512维的矩阵，这样就可以对每一个自适应实例归一化（AdaIN）风格模块都使用不同W，实现更自由的属性编辑。
基于优化求解的方法包括以下几步：
(1) 给定图片I，以及预训练好的生成器G。
(2) 初始化潜在编码向量，如W，其初始值可以使用计算得到的统计平均值。
(3) 根据优化目标进行反复迭代，直到达到预设的终止条件。
优化目标的常见形式为：
其中Lpercept为特征空间中的感知损失距离，是很通用的问题，具体形式不再赘述。lamda用于平衡感知损失和MSE损失之间的权重比。可以使用梯度下降算法进行求解。
基于优化求解方法的优点是精度较高，但是优化速度慢，而且对每一个图片都必须进行优化迭代。
在求解得到了潜在编码向量后，我们就可以通过编辑向量来编辑人脸的高层语义属性，对于StyleGAN架构来说，潜在编码向量可以是Z也可以是W，一般基于W进行编码会有更好的效果。
3 人脸属性编辑实战
接下来我们实践基于StyleGAN模型的人脸属性编辑。
3.1 人脸重建
要使用StyleGAN来进行人脸编辑，首先我们需要将人脸投射到潜在编码向量空间，下面我们采用的方法是基于优化的方法，即对每一张人脸图片，单独优化求解出潜在编码向量，基本思想前面已经介绍过。
接下来我们来看人脸重建的求解，核心代码如下：
if __name__ == &#34;__main__&#34;:
## 预训练模型权重
parser.add_argument(
&#34;--ckpt&#34;, type=str, required=True, help=&#34;path to the model checkpoint&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/104e28bcdecb2fbeb308e98857959bad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-28T11:03:59+08:00" />
<meta property="article:modified_time" content="2022-07-28T11:03:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【百战GAN】StyleGAN人脸属性（表情年龄性别）编辑代码实战</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>大家好，欢迎来到专栏《百战GAN》，在这个专栏里，我们会进行GAN相关项目的核心思想讲解，代码的详解，模型的训练和测试等内容。</p> 
 <p style="text-align:right;">作者&amp;编辑 | 言有三</p> 
 <p><img src="https://images2.imgbox.com/d2/25/FvwpVkn8_o.jpg" alt="d9fa773126cfbc1fd19a7d171c79499c.jpeg"></p> 
 <p>本文资源与生成结果展示</p> 
 <p>本文篇幅：7000字</p> 
 <p>背景要求：会使用Python和Pytorch</p> 
 <p>附带资料：参考论文和项目，视频讲解</p> 
 <p><strong>1 项目背景</strong></p> 
 <p>作为一门新兴的技术，GAN在很多人脸图像任务中有着广泛的应用，下面列举了一些典型的方向。</p> 
 <p><img src="https://images2.imgbox.com/3b/84/DgGDdDqU_o.png" alt="a1d751f53c8fbb28fd0174ff7440511d.png"></p> 
 <p>比如使用SRGAN进行人脸超分辨，使用BeautyGAN进行人脸美颜，使用Deepfake进行换脸。如今，基于人脸属性编辑的技术在抖音快手等应用中都是非常受欢迎的技术，比如可以体验让人变老变小，如下图年龄的更改。</p> 
 <p><img src="https://images2.imgbox.com/40/3f/b5GYim5I_o.jpg" alt="69588bc5ea8c2fcaf94994722f2dfc45.jpeg"></p> 
 <p style="text-align:center;">年龄编辑</p> 
 <p style="text-align:left;">这背后的核心技术之一就是在生成模型的Latent空间进行属性向量的编辑，然后通过生成模型来获取最终结果图，其中最典型的代表性框架就是StyleGAN，本次我们来实战使用StyleGAN进行人脸属性编辑。</p> 
 <p><strong>在阅读接下来的内容之前，请大家务必回顾之前StyleGAN人脸生成的内容，没有这一部分内容基础，无法学习接下来的内容。</strong></p> 
 <p><a href="" rel="nofollow"><strong>【百战GAN】StyleGAN原理详解与人脸图像生成代码实战</strong></a><br></p> 
 <p><a href="" rel="nofollow"><strong>【项目实战课】基于Pytorch的StyleGAN v1人脸图像生成实战</strong></a><br></p> 
 <p><img src="https://images2.imgbox.com/67/a0/7kR6RXIS_o.jpg" alt="df321c97fbdc32cd894f86bb40534d04.jpeg"></p> 
 <p><strong>2 原理简介</strong></p> 
 <p>现在我们要使用StyleGAN进行真实人脸的编辑，需要解决2个关键问题。</p> 
 <p><img src="https://images2.imgbox.com/36/1a/O61kLXXc_o.png" alt="b92e9014c06a10f95df4bbef6528f247.png"></p> 
 <p>(1) 如何获得真实人脸的潜在编码向量，它对应StyleGAN中的映射网络（mapping network）的输入Z或者输出W。</p> 
 <p>(2) 如何通过修改Z或者W向量，控制生成人脸图像的高层语义属性。</p> 
 <p>接下来我们重点介绍潜在编码向量的求解，并在下一节中实验基于潜在编码向量的属性编辑。</p> 
 <p>当前对真实人脸编码向量的求取基本上基于两种思路，一种是学习一个编码器来实现映射，一种是直接对向量进行优化求解。</p> 
 <p><strong>2.1 基于编码器的求解</strong></p> 
 <p>基于编码器的求解框架如下图所示，由两部分模块组成。</p> 
 <p><img src="https://images2.imgbox.com/82/5f/hIU1H3Yc_o.png" alt="4a488f5cb30ebd5da5c50903e19bf242.png"></p> 
 <p>Encoder表示需要训练的编码器，Decoder表示已经训练完的生成模型，如StyleGAN的生成器部分。真实图像输入编码器得到Z或者W，再输入生成器得到生成的人脸，完成人脸图像的重建。</p> 
 <p>通过直接学习一个编码器，可以不需要对每一张图都进行优化，实现一次训练，对任意图像都能提取潜在编码向量，但是也容易在训练数据集上发生过拟合。</p> 
 <p><strong>2.2 基于优化求解的方法</strong></p> 
 <p>另外一种方法就是基于优化求解，直接对每一张图片优化出对应的W，在StyleGAN v2，Image2StyleGAN等框架中采用了这种方案，并且512维的W被拓展成W+, W+为18×512维的矩阵，这样就可以对每一个自适应实例归一化（AdaIN）风格模块都使用不同W，实现更自由的属性编辑。</p> 
 <p>基于优化求解的方法包括以下几步：</p> 
 <p>(1) 给定图片I，以及预训练好的生成器G。</p> 
 <p>(2) 初始化潜在编码向量，如W，其初始值可以使用计算得到的统计平均值。</p> 
 <p>(3) 根据优化目标进行反复迭代，直到达到预设的终止条件。</p> 
 <p>优化目标的常见形式为：</p> 
 <p><img src="https://images2.imgbox.com/2c/b2/pnwQbScH_o.png" alt="eac1386c4097b608d6ee87ceda633b3d.png"></p> 
 <p>其中Lpercept为特征空间中的感知损失距离，是很通用的问题，具体形式不再赘述。lamda用于平衡感知损失和MSE损失之间的权重比。可以使用梯度下降算法进行求解。</p> 
 <p>基于优化求解方法的优点是精度较高，但是优化速度慢，而且对每一个图片都必须进行优化迭代。</p> 
 <p>在求解得到了潜在编码向量后，我们就可以通过编辑向量来编辑人脸的高层语义属性，对于StyleGAN架构来说，潜在编码向量可以是Z也可以是W，一般基于W进行编码会有更好的效果。</p> 
 <p><strong>3 人脸属性编辑实战</strong></p> 
 <p>接下来我们实践基于StyleGAN模型的人脸属性编辑。</p> 
 <p><strong>3.1 人脸重建</strong><br></p> 
 <p>要使用StyleGAN来进行人脸编辑，首先我们需要将人脸投射到潜在编码向量空间，下面我们采用的方法是基于优化的方法，即对每一张人脸图片，单独优化求解出潜在编码向量，基本思想前面已经介绍过。</p> 
 <p>接下来我们来看人脸重建的求解，核心代码如下：</p> 
 <p>if __name__ == "__main__":</p> 
 <p>    ## 预训练模型权重</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--ckpt", type=str, required=True, help="path to the model checkpoint"</p> 
 <p>    )</p> 
 <p>    ## 输出图像尺寸</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--size", type=int, default=256, help="output image sizes of the generator"</p> 
 <p>    )</p> 
 <p>    ## 学习率参数</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--lr_rampup",</p> 
 <p>        type=float,</p> 
 <p>        default=0.05,</p> 
 <p>        help="duration of the learning rate warmup",</p> 
 <p>    )</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--lr_rampdown",</p> 
 <p>        type=float,</p> 
 <p>        default=0.25,</p> 
 <p>        help="duration of the learning rate decay",</p> 
 <p>    )</p> 
 <p>    parser.add_argument("--lr", type=float, default=0.1, help="learning rate")</p> 
 <p>    ## 噪声相关参数，噪声水平，噪声衰减范围，噪声正则化</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--noise", type=float, default=0.05, help="strength of the noise level"</p> 
 <p>    )</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--noise_ramp",</p> 
 <p>        type=float,</p> 
 <p>        default=1.0,</p> 
 <p>        help="duration of the noise level decay",</p> 
 <p>    )</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--noise_regularize",</p> 
 <p>        type=float,</p> 
 <p>        default=10000,</p> 
 <p>        help="weight of the noise regularization",</p> 
 <p>    )</p> 
 <p>    ## MSE损失</p> 
 <p>    parser.add_argument("--mse", type=float, default=0.5, help="weight of the mse loss")</p> 
 <p>    ## 迭代次数</p> 
 <p>    parser.add_argument("--step", type=int, default=1000, help="optimize iterations")</p> 
 <p>    ## 重建图像</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--files", type=str, help="path to image files to be projected"</p> 
 <p>    )</p> 
 <p>    ## 重建结果</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--results", type=str, help="path to results files to be stored"</p> 
 <p>    )</p> 
 <p>## 计算学习率</p> 
 <p>def get_lr(t, initial_lr, rampdown=0.25, rampup=0.05):</p> 
 <p>    lr_ramp = min(1, (1 - t) / rampdown)</p> 
 <p>    lr_ramp = 0.5 - 0.5 * math.cos(lr_ramp * math.pi)</p> 
 <p>lr_ramp = lr_ramp * min(1, t / rampup)</p> 
 <p>return initial_lr * lr_ramp</p> 
 <p>## 合并latent向量和噪声</p> 
 <p>def latent_noise(latent, strength):</p> 
 <p>noise = torch.randn_like(latent) * strength</p> 
 <p>    return latent + noise</p> 
 <p>## 生成图片</p> 
 <p>def make_image(tensor):</p> 
 <p>    return (</p> 
 <p>        tensor.detach()</p> 
 <p>        .clamp_(min=-1, max=1)</p> 
 <p>        .add(1)</p> 
 <p>        .div_(2)</p> 
 <p>        .mul(255)</p> 
 <p>        .type(torch.uint8)</p> 
 <p>        .permute(0, 2, 3, 1)</p> 
 <p>        .to("cpu")</p> 
 <p>        .numpy()</p> 
 <p>    )</p> 
 <p>## 生成与图像大小相等的噪声</p> 
 <p>def make_noise(device,size):</p> 
 <p>    noises = []</p> 
 <p>    step = int(math.log(size, 2)) - 2</p> 
 <p>    for i in range(step + 1):</p> 
 <p>            size = 4 * 2 ** i</p> 
 <p>            noises.append(torch.randn(1, 1, size, size, device=device))</p> 
 <p>return noises</p> 
 <p>## 噪声归一化</p> 
 <p>def noise_normalize_(noises):</p> 
 <p>    for noise in noises:</p> 
 <p>        mean = noise.mean()</p> 
 <p>        std = noise.std()</p> 
 <p>        noise.data.add_(-mean).div_(std)</p> 
 <p>args = parser.parse_args()</p> 
 <p>    device = "cpu"</p> 
 <p>    ## 计算latent向量的平均次数</p> 
 <p>    n_mean_latent = 10000</p> 
 <p>    ## 获得用于计算损失的最小图像尺寸</p> 
 <p>    resize = min(args.size, 256)</p> 
 <p>    ## 预处理函数</p> 
 <p>    transform = transforms.Compose(</p> 
 <p>        [</p> 
 <p>            transforms.Resize(resize),</p> 
 <p>            transforms.CenterCrop(resize),</p> 
 <p>            transforms.ToTensor(),</p> 
 <p>            transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]),</p> 
 <p>        ]</p> 
 <p>    )</p> 
 <p>    ## 投影的人脸图片,将图片处理成一个batch</p> 
 <p>    imgs = []</p> 
 <p>    imgfiles = os.listdir(args.files)</p> 
 <p>    for imgfile in imgfiles:</p> 
 <p>        img = transform(Image.open(os.path.join(args.files,imgfile)).convert("RGB"))</p> 
 <p>        imgs.append(img)</p> 
 <p>    imgs = torch.stack(imgs, 0).to(device)</p> 
 <p>    ## 载入模型</p> 
 <p>    netG = StyledGenerator(512,8)</p> 
 <p>    netG.load_state_dict(torch.load(args.ckpt,map_location=device)["g_running"], strict=False)</p> 
 <p>    netG.eval()</p> 
 <p>    netG = netG.to(device)</p> 
 <p>    step = int(math.log(args.size, 2)) - 2</p> 
 <p>    with torch.no_grad():</p> 
 <p>        noise_sample = torch.randn(n_mean_latent, 512, device=device)</p> 
 <p>        latent_out = netG.style(noise_sample) ##输入噪声向量Z，输出latent向量W=latent_out</p> 
 <p>        latent_mean = latent_out.mean(0)</p> 
 <p>        latent_std = ((latent_out - latent_mean).pow(2).sum() / n_mean_latent) ** 0.5</p> 
 <p>    ## 感知损失计算</p> 
 <p>    percept = lpips.PerceptualLoss(</p> 
 <p>        model="net-lin", net="vgg", use_gpu=device.startswith("cuda")</p> 
 <p>    )</p> 
 <p>    ## 构建噪声输入</p> 
 <p>    noises_single = make_noise(device,args.size)</p> 
 <p>    noises = []</p> 
 <p>    for noise in noises_single:</p> 
 <p>        noises.append(noise.repeat(imgs.shape[0], 1, 1, 1).normal_())</p> 
 <p>    ## 初始化Z向量</p> 
 <p>    latent_in = latent_mean.detach().clone().unsqueeze(0).repeat(imgs.shape[0], 1)</p> 
 <p>    latent_in.requires_grad = True</p> 
 <p>    for noise in noises:</p> 
 <p>        noise.requires_grad = True</p> 
 <p>    optimizer = optim.Adam([latent_in] + noises, lr=args.lr)</p> 
 <p>    pbar = tqdm(range(args.step))</p> 
 <p>    ## 优化学习Z向量</p> 
 <p>    for i in pbar:</p> 
 <p>        t = i / args.step ## t的范围是(0,1)</p> 
 <p>        lr = get_lr(t, args.lr)</p> 
 <p>        optimizer.param_groups[0]["lr"] = lr</p> 
 <p>## 噪声衰减</p> 
 <p>        noise_strength = latent_std * args.noise * max(0, 1 - t / args.noise_ramp) ** 2</p> 
 <p>        latent_n = latent_noise(latent_in, noise_strength.item())</p> 
 <p>        latent_n.to(device)</p> 
 <p>        img_gen = netG([latent_n], noise=noises, step=step) ## 生成的图片</p> 
 <p>        batch, channel, height, width = img_gen.shape</p> 
 <p>## 在不超过256的分辨率上计算损失</p> 
 <p>        if height &gt; 256:</p> 
 <p>            factor = height // 256</p> 
 <p>            img_gen = img_gen.reshape(</p> 
 <p>                batch, channel, height // factor, factor, width // factor, factor</p> 
 <p>            )</p> 
 <p>            img_gen = img_gen.mean([3, 5])</p> 
 <p>        p_loss = percept(img_gen, imgs).sum()  ## 感知损失</p> 
 <p>        n_loss = noise_regularize(noises)      ## 噪声损失</p> 
 <p>        mse_loss = F.mse_loss(img_gen, imgs)   ## MSE损失</p> 
 <p>        loss = p_loss + args.noise_regularize * n_loss + args.mse * mse_loss</p> 
 <p>        optimizer.zero_grad()</p> 
 <p>        loss.backward()</p> 
 <p>        optimizer.step()</p> 
 <p>        noise_normalize_(noises)</p> 
 <p>        pbar.set_description(</p> 
 <p>            (</p> 
 <p>                f"perceptual: {p_loss.item():.4f}; noise regularize: {n_loss.item():.4f};"</p> 
 <p>                f" mse: {mse_loss.item():.4f}; loss: {loss.item():.4f}; lr: {lr:.4f}"</p> 
 <p>            )</p> 
 <p>        )</p> 
 <p>    ## 重新生成高分辨率图片</p> 
 <p>    img_gen = netG([latent_in], noise=noises,step=step)</p> 
 <p>    img_ar = make_image(img_gen)</p> 
 <p>    result_file = {}</p> 
 <p>    for i, input_name in enumerate(imgfiles):</p> 
 <p>        noise_single = []</p> 
 <p>        for noise in noises:</p> 
 <p>            noise_single.append(noise[i : i + 1])</p> 
 <p>        print("i="+str(i)+"; len of imgs:"+str(len(img_gen)))</p> 
 <p>        result_file[input_name] = {<!-- --></p> 
 <p>            "img": img_gen[i],</p> 
 <p>            "latent": latent_in[i],</p> 
 <p>            "noise": noise_single,</p> 
 <p>        }</p> 
 <p>        img_name = os.path.join(args.results,input_name)</p> 
 <p>        pil_img = Image.fromarray(img_ar[i])</p> 
 <p>        pil_img.save(img_name) ##存储图片</p> 
 <p>        np.save(os.path.join(args.results,input_name.split('.')[0]+'.npy'),latent_in[i].detach().numpy())##存储latent向量</p> 
 <p>在上面的代码中，latent_in就是要优化学习的潜在变量，当使用netG([latent_n], noise=noises, step=step)的调用方式时，latent_n是映射网络（mapping network）的向量Z，它由latent_in和随着迭代不断衰减的噪声向量组成，此时没有输入平均风格向量。</p> 
 <p>根据之前我们对生成器模型结构的解读，此时只有latent_n会影响生成的风格，因此为基于向量Z的重建方法。</p> 
 <p>当然我们也可以通过将latent_n设为平均风格向量，将混合权重style_weight设置为0，这样也只有latent_n会影响生成的风格，并且它会作为生成网络（synthetis network）的输入，即向量W，此时就是基于向量W的重建方法。</p> 
 <p><strong>关于感知损失的计算，以及预训练模型的解读，请大家自行完成，或者阅读文后的讲解视频。</strong></p> 
 <p>下面我们会比较这两种重建方法的差异。</p> 
 <p>学习率采用warmup策略,即先增大再减小，最大不超过0.1。感知损失、MSE损失、噪声正则化损失的权重分别为1.0，1.0,10000,噪声相关的幅度、衰减范围因子分别为0.05，1。</p> 
 <p>下图展示了随机选取的图像的人脸重建结果图。</p> 
 <p><img src="https://images2.imgbox.com/12/14/omL7gJ0e_o.png" alt="89fe6315ddde09412bd83c5c6122a253.png"></p> 
 <p>上图中第一行是原图，第二行是基于向量Z的重建图，第三行是基于向量W的重建图。</p> 
 <p>下图展示了一幅图像基于Z和基于W向量的3部分训练损失曲线图，其中实线对应W，虚线对应Z，需要注意的是噪声损失没有乘以对应的权重，如果乘以对应的权重，最终收敛的时候三部分损失的幅度相当。</p> 
 <p><img src="https://images2.imgbox.com/ab/17/p9coeZuz_o.png" alt="55d1afe4745bf8d6d2fc8d4ab7d13059.png"></p> 
 <p>从结果上来看，两种方法中人脸图像的总体姿态、肤色、发型、脸型、背景重建效果都比较好，基于向量Z的重建方法中人脸的清晰度更高，但是身份没有得到保持。这主要是因为所学习的特征向量为Z，它还需要经过非线性的映射网络（mapping network）得到W，相比于直接学习W的难度更高，许多研究都表明使用W向量可以得到更好的重建效果。</p> 
 <p>从损失曲线可以看出，基于W向量的重建训练损失可以获得更低的值，但是感知损失的收敛更慢，MSE的实际损失更低，可见在获得了更精确的身份重建的基础上，牺牲了一定的感知质量，使得当编辑W向量时会比较敏感。</p> 
 <p>接下来我们使用基于向量Z的重建结果来进行人脸的属性编辑，因为这样可以比较基于Z和W来编辑属性的差异性，基于向量W的重建结果中无法获得对应的Z向量，因为映射网络是无法从输出获得输入的。</p> 
 <p><strong>3.2 人脸属性混合与插值</strong></p> 
 <p>接下来我们进行人脸属性的混合与插值，这是在多张图片之间进行属性的混合操作。</p> 
 <p><strong>(1) 人脸属性样式混合</strong></p> 
 <p>我们首先体验人脸属性样式混合，样式混合操作可以通过下式的向量运算实现。</p> 
 <p><img src="https://images2.imgbox.com/d9/b4/HsoeifNU_o.png" alt="5dd83b7d09365d492782ee203c5cbcdc.png"></p> 
 <p>其中[0:m]表示取向量的前m维，[m:n]表示取向量的第m到n维，两者通过拼接得到新的向量。<br></p> 
 <p>值得注意的是，这里的W并不是映射网络的输出向量，而是对于不同风格化层的AdaIN缩放和偏移系数，即风格系数。我们之前介绍过，不同分辨率的风格模块对应着不同层级的人脸特征，在这里我们使用两张人脸图像对应的风格系数进行混合，体验不同层级特征的样式混合。</p> 
 <p><img src="https://images2.imgbox.com/c2/33/mX9QkcEn_o.png" alt="e2b1392392da22e4a2c2fb4a203c4471.png"></p> 
 <p>图中第1列表示源图，第5列表示目标图，第2列、第3列、第4列表示在对应分辨率的风格层使用源图的风格，其他分辨率的风格层使用目标图的风格。</p> 
 <p>第2列表示分辨率为4×4，8×8的风格化模块的风格向量来自于源图，其他分辨率模块的风格向量来自于目标图。可以看出，结果图有源图的粗粒度特征，如人脸姿态、发型特征，以及目标图的细粒度特征，如发丝、眼睛颜色。</p> 
 <p>第3列表示分辨率为16×16，32×32的风格化模块的风格向量来自于源图，其他分辨率模块的风格向量来自于目标图。可以看出，保留了源图的中等粒度特征，如眼睛形态、嘴唇颜色等特征。</p> 
 <p>第4列表示分辨率为64×64到1024×1024之间的风格化模块的风格向量来自于源图，其他分辨率模块的风格向量来自于目标图。可以看出，结果图有源图的细粒度特征，如头发和皮肤的颜色与纹理等特征，以及目标图的粗粒度特征，如姿态、发型。</p> 
 <p><strong>(2) 人脸样式插值</strong></p> 
 <p>接下来我们体验人脸样式插值，样式插值操作可以通过下面的W向量运算实现。</p> 
 <p><img src="https://images2.imgbox.com/3f/74/tzCc2cuI_o.png" alt="1cd14b993a1c6b3f44f4353b011f8891.png"></p> 
 <p>下图分别展示了基于向量Z和向量W的人脸样式插值结果。</p> 
 <p><img src="https://images2.imgbox.com/b7/0d/vgdFIm8Z_o.png" alt="04a925d91b843ef0115c09ed02a67e62.png"></p> 
 <p style="text-align:center;">基于Z向量的人脸样式插值</p> 
 <p><img src="https://images2.imgbox.com/ed/8c/8c1NMgn1_o.png" alt="ce880a39a6daba12d41e9512c1eb9ce4.png"></p> 
 <p style="text-align:center;">基于W向量的人脸样式插值</p> 
 <p>第1列表示A域图像，对应n维的列向量 。第6列表示B域图像，对应n维的列向量，第2，3，4，5列表示在不同权重下对两张图片的向量进行加权后生成的图像，可以看出都可以实现了样式过度，但是基于W向量的结果明显要比基于Z向量的结果更加平滑。</p> 
 <p><strong>3.2 人脸属性编辑</strong></p> 
 <p>上面介绍的人脸样式混合可以直接通过两幅图片的潜在向量运算来实现人脸属性的混合，而如果想要对单张人脸的属性进行精确编辑，就需要首先找到潜在向量的编辑方向，称之为方向向量。下面我们介绍方向向量的求解与基于方向向量的属性编辑。</p> 
 <p>接下来的属性编辑建立在以下假设的基础上：在方向向量上，线性的改变潜在编码向量，则生成的图像及语义内容也是连续变化的，因此可以使用线性模型来进行属性更改：</p> 
 <p><img src="https://images2.imgbox.com/6b/76/s7Ep0VjU_o.png" alt="727718e5b06aab175c01db52efb9d65d.png"></p> 
 <p>W表示结果编码，W0表示人脸特征码，alpha表示偏移系数，n表示方向向量。</p> 
 <p>接下来需要解决的问题就是方向向量n的求解，具体的步骤为：</p> 
 <p>(1) 随机采样潜在编码向量，生成人脸图片，保存人脸图片和对应的潜在编码向量。</p> 
 <p>(2) 对生成的人脸图片，训练想要编辑的人脸属性CNN分类模型。任意一个二值语义都存在一个超平面可以作为语义类别的分类边界，在超平面的一侧改变潜在编码向量不会改变对应的语义类别，这个超平面可以用单位法线矢量表示。</p> 
 <p>(3) 根据CNN分类模型获得的标签，对潜在编码向量训练出线性回归模型，获得方向向量，如下图所示。</p> 
 <p><img src="https://images2.imgbox.com/17/68/W1uFG8uq_o.png" alt="617c0ed98be3a31c8a6ee433d52ebd1d.png"></p> 
 <p>上图展示了0和1这两类样本，它就是潜在编码向量W。求解完线性回归模型的权重 ，它实际上就是方向向量。得到方向向量后，就可以进行人脸相关属性的编辑。</p> 
 <p>以人脸表情编辑为例：首先我们使用StyleGAN随机生成了50000张人脸图片，接下来我们需要将图片分为有表情和无表情两类，需要使用一个预训练好的2分类表情识别模型。为了保证模型有较高的准确率，训练时采用的方法是首先提取出人脸嘴唇区域，然后对嘴唇区域进行训练。</p> 
 <p>该表情识别模型大家可以参考阅读：</p> 
 <p><a href="" rel="nofollow">【项目实战课】AI零基础，人人免费可学！基于Pytorch的SimpleNet人脸表情识别实战</a><br></p> 
 <p><img src="https://images2.imgbox.com/3d/e6/NFRymEzs_o.gif" alt="b8001a4a755c8391167a69ba15c5b6e2.gif"></p> 
 <p>下图就是基于微笑表情模型分类出的有微笑和无微笑两类图片的一些样本展示。<br></p> 
 <p><img src="https://images2.imgbox.com/ed/e5/3ThXEktg_o.png" alt="6fb93b02d5fd91524543f2a12bcb62c7.png"></p> 
 <p>训练好模型后，我们就得到了图片的标签，然后对其对应的潜在向量学习一个线性分类器，得到方向向量。完整代码请大家参考文后资料。</p> 
 <p>因为潜在向量维度是1×512，所以得到的方向向量也是1×512维，然后我们就可以基于方向向量进行属性编辑，基于Z向量编辑的核心代码如下：</p> 
 <p>from model import StyledGenerator</p> 
 <p>if __name__ == "__main__":</p> 
 <p>    device = "cpu"</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--ckpt", type=str, required=True, help="path to the model checkpoint"</p> 
 <p>    )</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--size", type=int, default=1024, help="output image sizes of the generator"</p> 
 <p>    )</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--files", type=str, help="path to image files to be projected"</p> 
 <p>    )</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--direction", type=str, help="direction file to be read"</p> 
 <p>    )</p> 
 <p>    parser.add_argument(</p> 
 <p>        "--directionscale", type=float, help="direction scale"</p> 
 <p>    )</p> 
 <p>    args = parser.parse_args()</p> 
 <p>    ## 载入模型</p> 
 <p>    netG = StyledGenerator(512)</p> 
 <p>    netG.load_state_dict(torch.load(args.ckpt,map_location=device)["g_running"], strict=False)</p> 
 <p>    netG.eval()</p> 
 <p>    netG = netG.to(device)</p> 
 <p>    step = int(math.log(args.size, 2)) - 2</p> 
 <p>    ## 载入方向向量</p> 
 <p>    direction = np.load(args.direction)</p> 
 <p>    directiontype = args.direction.split('/')[-1].split('.')[0]</p> 
 <p>    editscale = args.directionscale</p> 
 <p>    npys = glob.glob(args.files+"*.npy")</p> 
 <p>    for npyfile in npys:</p> 
 <p>        latent = torch.from_numpy(np.load(npyfile))</p> 
 <p>        if len(latent.shape) == 1:</p> 
 <p>            latent = latent.unsqueeze(0)</p> 
 <p>        latent = latent + torch.from_numpy((editscale*direction[0]).astype(np.float32))</p> 
 <p>        latent.to(device)</p> 
 <p>        img_gen = netG([latent], step=step) ##生成的图片</p> 
 <p>        img_name = os.path.join(npyfile.replace('.npy','_'+directiontype+'_'+str(editscale)+'.jpg'))</p> 
 <p>        utils.save_image(img_gen, img_name, normalize=True)</p> 
 <p>        np.save(img_name.replace('.jpg','.npy'),latent)</p> 
 <p>下图分别展示了基于Z向量和W向量的编辑结果。</p> 
 <p><img src="https://images2.imgbox.com/0c/ee/dP5w9uwN_o.png" alt="3194ccf9b27701fd5636e5c7036e7ad3.png"></p> 
 <p style="text-align:center;">基于Z向量的人脸微笑属性编辑</p> 
 <p><img src="https://images2.imgbox.com/4f/ae/4VUeJShh_o.png" alt="705d7f6295934263e467412c67195688.png"></p> 
 <p style="text-align:center;">基于W向量的人脸微笑属性编辑</p> 
 <p>第1行表示原图，第2行表示减小微笑表情幅度，第3行表示增大微笑表情幅度。</p> 
 <p>可以看出基于Z向量和W向量，都能够实现微笑表情的编辑。不过基于Z向量的模型，明显地更改了其他的属性，比如发型、人脸身份等，这说明基于向量Z的编辑不能很好地实现表情属性与其他属性的解耦合，存在非常大的改进空间，而基于W向量能够比较好的保护其他属性信息。</p> 
 <p>由于不同的人脸有不同的属性，我们也可以基于此进行属性的添加与移除，W向量运算如下式，</p> 
 <p>其中W3和W2来自于同一个人，相减得到某个属性的向量，然后将其添加到W1，表示给对应的人脸添加对应的属性。</p> 
 <p><img src="https://images2.imgbox.com/31/d2/ACbLiR01_o.png" alt="f7f94decdff0da38c5ccd75e277168d9.png"></p> 
 <p>下图分别展示了基于Z向量和W向量的人脸微笑属性添加与移除结果。</p> 
 <p><img src="https://images2.imgbox.com/bb/bf/PPycuId2_o.png" alt="d1982249c316b844172c446115a0a536.png"></p> 
 <p style="text-align:center;">基于Z向量的表情添加与移除</p> 
 <p><img src="https://images2.imgbox.com/3f/82/KcLuUj4F_o.png" alt="7a6b91d9cb4e7311b16e528c7fb15afe.png"></p> 
 <p style="text-align:center;">基于W向量的表情添加与移除</p> 
 <p>第1列表示源图，对应n维的列向量 。第2列和第3列分别表示目标图，对应n维的列向量和。第4列表示生成的图像，可以看出基于Z向量虽然可以一定程度上实现微笑属性的添加与移除，但是会修改人脸的身份。而基于W向量可以很好地实现微笑属性的添加与移除。</p> 
 <p>本文参考的文献如下：</p> 
 <p>[1] Abdal R ,  Qin Y ,  Wonka P . Image2StyleGAN: How to Embed Images Into the StyleGAN Latent Space?[J]. IEEE, 2019.</p> 
 <p>[2] Shen Y ,  Gu J ,  Tang X , et al. Interpreting the Latent Space of GANs for Semantic Face Editing[C]// 2020 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR). IEEE, 2020.</p> 
 <p>本文视频讲解和代码，请大家移步：</p> 
 <p><a href="" rel="nofollow">【项目实战课】基于Pytorch的StyleGAN人脸属性（表情、年龄、性别）编辑实战</a><br></p> 
 <p><img src="https://images2.imgbox.com/eb/1f/CZ6cRxAN_o.gif" alt="7571c6a9bcddc5ec533737dbdcbaa8b2.gif"></p> 
 <p><img src="https://images2.imgbox.com/4d/27/gxCJtOZM_o.png" alt="25e10ee9906ee19f55e86d5dd35be3a3.jpeg"></p> 
 <p><strong>总结</strong></p> 
 <p>本次我们使用StyleGAN模型实践了人脸属性的编辑，取得了预期的实验结果，不过该方法还存在许多可以改进的地方，大家可以使用更新的StyleGAN模型，以及更新的属性编辑模型来进行改进，欢迎大家以后持续关注《百战GAN专栏》。</p> 
 <p>如何系统性地学习生成对抗网络GAN</p> 
 <p>欢迎大家关注有三AI-CV秋季划GAN小组，可以系统性学习GAN相关的内容，包括GAN的基础理论，《深度学习之图像生成GAN：理论与实践篇》，《深度学习之图像翻译GAN：理论与实践篇》以及各类GAN任务的实战。</p> 
 <p>介绍如下：<a href="" rel="nofollow"><strong>【CV秋季划】生成对抗网络GAN有哪些研究和应用，如何循序渐进地学习好（2022年言有三一对一辅导）？</strong></a></p> 
 <p><img src="https://images2.imgbox.com/63/2d/vD2WWOpS_o.png" alt="767537860ddcfe7533d756cd74b5b50b.png"></p> 
 <p style="text-align:center;">转载文章请后台联系</p> 
 <p style="text-align:center;">侵权必究</p> 
 <p><img src="https://images2.imgbox.com/f5/8b/5n5yX6eq_o.gif" alt="07248c58cc7229eafc2b59b1ea553a3d.gif"></p> 
 <p><img src="https://images2.imgbox.com/46/ad/rZYjbjmw_o.png" alt="90ad6d60ca3f8d098a1bd2b116a16145.png"></p> 
 <p><img src="https://images2.imgbox.com/25/d2/lpANBId4_o.png" alt="7430f330e4a4e3bb2ff24f13c857ffdf.png"></p> 
 <ul><li><p><a href="" rel="nofollow">【CV夏季划】2022年正式入夏，从理论到实践，如何系统性进阶CV？（产学研一体的超硬核培养方式）</a></p></li><li><p><a href="" rel="nofollow">【CV秋季划】模型算法与落地很重要，如何循序渐进地学习好（2022年言有三一对一辅导）？</a></p></li><li><p><a href="" rel="nofollow">【CV秋季划】人脸算法那么多，如何循序渐进地学习好？</a></p></li><li><p><a href="" rel="nofollow">【CV秋季划】图像质量提升与编辑有哪些研究和应用，如何循序渐进地学习好？</a></p></li><li><p><a href="" rel="nofollow">【CV冬季划】终极进阶，超30个项目实战+3本书+3年知识星球</a></p></li></ul> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1ba3c030d6f80f21db1b7e68abad6272/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">虚拟化&#43;docker概念基本介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44fd795c79f3e46c62c80a9b1347c68b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Setup Factory打包教程整合</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>