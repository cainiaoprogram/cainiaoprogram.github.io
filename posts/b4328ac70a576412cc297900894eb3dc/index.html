<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java算法---华为oj迷宫问题求解（广度优先搜索） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java算法---华为oj迷宫问题求解（广度优先搜索）" />
<meta property="og:description" content="一万年太久，只争朝夕，只有坚持，才能胜利，经过昨天的努力，解决了广度优先算法实现迷宫问题，题目在这里不赘述，如果不知道题目的请看我的上一篇博客Java算法---华为oj迷宫问题求解，这里面说的很详细，下来就直奔主题，说说广度优先搜索。
一般谈起广搜，我的第一反应就是求最短路径，因为广搜是由内向外逐层扩散，最后肯定能找到一个最短的路径，其实用法也不难，我的这篇博客中也讲到了广搜，可以看下Java算法---求面积，今天说的广搜和之前的不同之处在于，之前求最短路径，最终只需给出一个数字表示最短的长度，而不需要输出具体的路径是什么，也就是怎么走，而今天的广搜是需要输出路径，要是谈起这个路径问题，我想大部分人可能觉得深搜比较好，的确，我也是这样觉得，但是我们要灵活运行多种方法去解决一个问题，下来说说具体的题目吧。
广搜的套路就是利用一个队列，每次将当前点的邻居节点加入队列，然后出队，在将当前点加入队列，一直讲所有路径搜索完毕，直到队列为空停止。同时还需要一个数组去保存该节点是否访问，做个标记。但是怎样输出路径呢，我采取的办法是每次我们需要保存一下当前节点的前驱节点，可以这样设计一个类保存当前坐标和前驱坐标：
&lt;span style=&#34;font-family:SimSun;font-size:18px;&#34;&gt;&lt;span style=&#34;font-size:18px;&#34;&gt;class Node{ int x; int y; int prex; int prey; }&lt;/span&gt;&lt;/span&gt; 这样最终我们可以通过前驱节点来输出整个的路径。具体怎样做请往下看，就拿迷宫问题给的样例来说吧，每次将所有出队的节点保存在一个arrayList中，最终arrayList中保存了所有出队的节点，我们怎样从这些节点确定一条路径呢？
输入 5 5 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0
arrayList中会保存13个节点，分别是
（0,0,0,0）
（1,0,0,0）
（2,0,1,0）
（3,0,2,0）
（2,1,2,0）
（4,0,3,0）
（2,2,2,1）
（4,1,4,0）
（2,3,2,2）
（4,2,4,1）
（2,4,2,3）
（3,4,2,4）
（4,4,3,4）
前两个坐标代表当前坐标位置，后两个代表前驱坐标位置，然后按照从目的节点往起始节点找路径，如下图：
这样最终找到了一条路径(0,0)（1,0)(2,0)(2,1)(2,2)(2,3)(2,4)(3,4)(4,4)，即是我们最终要求解的问题。这样广度搜索也实现了路径的问题，下来就是写代码了，具体怎么实现每个人都不一样，下面贴上我自己的代码：
&lt;span style=&#34;font-family:SimSun;&#34;&gt;import java.util.*; /** * Created by Administrator on 2015/12/21." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b4328ac70a576412cc297900894eb3dc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-12-22T11:38:11+08:00" />
<meta property="article:modified_time" content="2015-12-22T11:38:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java算法---华为oj迷宫问题求解（广度优先搜索）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-family:SimSun; font-size:18px">  一万年太久，只争朝夕，只有坚持，才能胜利，经过昨天的努力，解决了广度优先算法实现迷宫问题，题目在这里不赘述，如果不知道题目的请看我的上一篇博客<a target="_blank" href="http://http://blog.csdn.net/csdn_yaobo/article/details/50369983" rel="noopener noreferrer">Java算法---华为oj迷宫问题求解</a>，这里面说的很详细，下来就直奔主题，说说广度优先搜索。</span></p> 
<p><span style="font-family:SimSun; font-size:18px">  一般谈起广搜，我的第一反应就是求最短路径，因为广搜是由内向外逐层扩散，最后肯定能找到一个最短的路径，其实用法也不难，我的这篇博客中也讲到了广搜，可以看下<a target="_blank" href="http://http://blog.csdn.net/csdn_yaobo/article/details/50143529" rel="noopener noreferrer">Java算法---求面积</a>，今天说的广搜和之前的不同之处在于，之前求最短路径，最终只需给出一个数字表示最短的长度，而不需要输出具体的路径是什么，也就是怎么走，而今天的广搜是需要输出路径，要是谈起这个路径问题，我想大部分人可能觉得深搜比较好，的确，我也是这样觉得，但是我们要灵活运行多种方法去解决一个问题，下来说说具体的题目吧。</span></p> 
<p><span style="font-family:SimSun; font-size:18px">  广搜的套路就是利用一个队列，每次将当前点的邻居节点加入队列，然后出队，在将当前点加入队列，一直讲所有路径搜索完毕，直到队列为空停止。同时还需要一个数组去保存该节点是否访问，做个标记。但是怎样输出路径呢，我采取的办法是每次我们需要保存一下当前节点的前驱节点，可以这样设计一个类保存当前坐标和前驱坐标：</span></p> 
<pre><code class="language-java">&lt;span style="font-family:SimSun;font-size:18px;"&gt;&lt;span style="font-size:18px;"&gt;class Node{
    int x;
    int y;
    int prex;
    int prey;
}&lt;/span&gt;&lt;/span&gt;</code></pre> 
<p></p> 
<p><span style="font-family:SimSun; font-size:18px">  这样最终我们可以通过前驱节点来输出整个的路径。具体怎样做请往下看，就拿迷宫问题给的样例来说吧，每次将所有出队的节点保存在一个arrayList中，最终arrayList中保存了所有出队的节点，我们怎样从这些节点确定一条路径呢？<br> 输入  5 5 </span></p> 
<p><span style="font-family:SimSun; font-size:18px">   0 1 0 0 0 </span></p> 
<p><span style="font-family:SimSun; font-size:18px">   0 1 0 1 0 </span></p> 
<p><span style="font-family:SimSun; font-size:18px">   0 0 0 0 0 </span></p> 
<p><span style="font-family:SimSun; font-size:18px">   0 1 1 1 0 </span></p> 
<p><span style="font-family:SimSun; font-size:18px">   0 0 0 1 0</span></p> 
<p><span style="font-family:SimSun; font-size:18px">arrayList中会保存13个节点，分别是</span></p> 
<p><span style="font-family:SimSun; font-size:18px">（0,0,0,0）</span></p> 
<p><span style="font-family:SimSun; font-size:18px">（1,0,0,0）<br> </span></p> 
<p><span style="font-family:SimSun; font-size:18px">（2,0,1,0）<br> </span></p> 
<p><span style="font-family:SimSun; font-size:18px">（3,0,2,0）</span></p> 
<p><span style="font-family:SimSun; font-size:18px">（2,1,2,0）<br> </span></p> 
<p><span style="font-family:SimSun; font-size:18px">（4,0,3,0）<br> </span></p> 
<p><span style="font-family:SimSun; font-size:18px">（2,2,2,1）<br> </span></p> 
<p><span style="font-family:SimSun; font-size:18px">（4,1,4,0）<br> </span></p> 
<p><span style="font-family:SimSun; font-size:18px">（2,3,2,2）<br> </span></p> 
<p><span style="font-family:SimSun; font-size:18px">（4,2,4,1）<br> </span></p> 
<p><span style="font-family:SimSun; font-size:18px">（2,4,2,3）<br> </span></p> 
<p><span style="font-family:SimSun; font-size:18px">（3,4,2,4）</span></p> 
<p><span style="font-family:SimSun; font-size:18px">（4,4,3,4）<br> </span></p> 
<p><span style="font-family:SimSun; font-size:18px">前两个坐标代表当前坐标位置，后两个代表前驱坐标位置，然后按照从目的节点往起始节点找路径，如下图：</span></p> 
<p><span style="font-family:SimSun; font-size:18px"><img src="https://images2.imgbox.com/54/4b/AWqKG80b_o.png" alt=""><span style="white-space:pre"> </span><br> </span></p> 
<p><span style="font-size:18px"><span style="font-family:SimSun">这样最终找到了一条路径(0,0)（1,0)(2,0)(2,1)(2,2)(2,3)(2,4)(3,4)(4,4)，即是我们最终要求解的问题。这样广度搜索也实现了路径的问题，下来就是写代码了，具体怎么实现每个人都不一样，下面贴上我自己的代码：</span></span></p> 
<pre><code class="language-java">&lt;span style="font-family:SimSun;"&gt;import java.util.*;

/**
 * Created by Administrator on 2015/12/21.
 */
public class BFS {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        while (sc.hasNext()){
            int m=sc.nextInt();
            int n=sc.nextInt();
            int[][] map = new int[m][n];
            for (int i = 0; i &lt; m; i++) {
                for (int j = 0; j &lt; n; j++) {
                    map[i][j] = sc.nextInt();
                }
            }
            int[][] dir = {<!-- -->{1, 0}, {0, 1}};
            int[][] visited=new int[m][n];
            Node start=new Node(0,0);
            Node end=new Node(m-1,n-1);
            Queue&lt;Node&gt; queue=new LinkedList&lt;Node&gt;();
            ArrayList&lt;Node&gt; arrayList=new ArrayList&lt;Node&gt;();//用来保存每一个出队列的节点
            queue.offer(start);
            while (!queue.isEmpty()){
                Node local=queue.remove();
                arrayList.add(local);
                for (int i=0;i&lt;2;i++){
                    Node nbr=new Node(local.x+dir[i][0],local.y+dir[i][1]);
                    if(nbr.x&gt;=0&amp;&amp;nbr.x&lt;m&amp;&amp;nbr.y&gt;=0&amp;&amp;nbr.y&lt;n&amp;&amp;map[nbr.x][nbr.y]==0&amp;&amp;visited[nbr.x][nbr.y]==0){
                        visited[nbr.x][nbr.y]=1;
                        queue.offer(nbr);
                        nbr.prex=local.x;//保存前驱节点
                        nbr.prey=local.y;//保存前驱节点
                    }
                }
            }
            Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;();
            int  px=arrayList.get(arrayList.size()-1).prex;//获得目的节点的前驱节点
            int  py=arrayList.get(arrayList.size()-1).prey;
            stack.push(arrayList.size()-1);//将目的节点在arrayList中的位置记录下来，便于输出
            while (true){
                if(px==0&amp;&amp;py==0){//找到起始节点就停止
                    break;
                }
                for(int i=0;i&lt;arrayList.size();i++){//循环找出每一个节点的前驱，找到就跳出当前循环
                    if(arrayList.get(i).x==px&amp;&amp;arrayList.get(i).y==py){
                        px=arrayList.get(i).prex;
                        py=arrayList.get(i).prey;
                        stack.push(i);//保存节点在arrayList中的位置
                        break;
                    }
                }
            }
            System.out.println("(0,0)");
            while (!stack.isEmpty()){
                System.out.println("("+arrayList.get(stack.peek()).x+","+arrayList.get(stack.peek()).y+")");
                stack.pop();
            }

        }
    }
}

class Node{
    int x;
    int y;
    int prex;//保存前驱节点位置
    int prey;
    Node(int x,int y){
        this.x=x;
        this.y=y;
    }
}&lt;/span&gt;</code></pre> 
<span style="font-family:SimSun">      如果有什么问题，欢迎评论。</span> 
<p></p> 
<span style="font-size:18px"></span>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10f343e22dbdc86d51e3aa8ba67e0368/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JAVA修改excel的内容</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b4c2cb305271f7cc5e8ea888665a4a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[UE4]鼠标左键右键不触发事件的原因</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>