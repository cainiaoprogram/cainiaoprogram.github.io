<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android R 如何访问Android/data目录 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android R 如何访问Android/data目录" />
<meta property="og:description" content="前言
Android R上分区存储的限制得到进一步加强，无论APP的targetsdkversion是多少，都将无法访问Android/data和Android/obb这二个应用私有目录。这无疑对会部分APP的业务场景及用户体验造成冲击，典型的如下
文件管理类软件：微信、QQ传输的文件无法展示给用户以便捷使用垃圾清理类软件：清理缓存功能受阻 “你有你的张良计，我有我的过墙梯”，现市面上文件管理类软件（如MT管理器）已解决上述系统限制，本文将浅析其实现方案，并主要分析以下2个问题：
SAF是通过何种方式访问文件系统的，MediaStore API ? File API ? Native Code ？SAF为何能访问Android/data目录 实现方案
其实现方案很简单，就是通过Intent ACTION_OPEN_DOCUMENT_TREE，启动SAF让用户授权访问Android/data目录，属于官方公开的方法。
前提是APP的targetsdkversion要小于30。
文档链接：
文档访问限制
授予对目录内容的访问权限
基本使用
通过Intent启动SAF授权界面，注意URI的百分号编解码（%3A和%2F），别随意替换，否则SAF无法导航到Android/data目录 @TargetApi(26) private void requestAccessAndroidData(Activity activity){ try { Uri uri = Uri.parse(&#34;content://com.android.externalstorage.documents/document/primary%3AAndroid%2Fdata&#34;); Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE); intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI, uri); //flag看实际业务需要可再补充 intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION); activity.startActivityForResult(intent, 6666); } catch (Exception e) { e.printStackTrace(); } } 授权申请
在用户同意授权后，持久化uri权限（否则关机重启或授权界面finish后，APP就无权限访问了），并只能通过DocumentFile进行业务操作，File API操作是无效的，此授权只是授权uri操作，并未授权文件系统，后续章节有说明。 implementation &#34;androidx.documentfile:documentfile:1.0.1&#34; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0de726563bbc29b63b0f2630e57a7c7e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-02T20:31:17+08:00" />
<meta property="article:modified_time" content="2021-09-02T20:31:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android R 如何访问Android/data目录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前言</p> 
<p>Android R上分区存储的限制得到进一步加强，无论APP的targetsdkversion是多少，都将无法访问Android/data和Android/obb这二个应用私有目录。这无疑对会部分APP的业务场景及用户体验造成冲击，典型的如下</p> 
<ul><li>文件管理类软件：微信、QQ传输的文件无法展示给用户以便捷使用</li><li>垃圾清理类软件：清理缓存功能受阻</li></ul> 
<p>“你有你的张良计，我有我的过墙梯”，现市面上文件管理类软件（如MT管理器）已解决上述系统限制，本文将浅析其实现方案，并主要分析以下2个问题：</p> 
<ul><li>SAF是通过何种方式访问文件系统的，MediaStore API ? File API ? Native Code ？</li><li>SAF为何能访问Android/data目录</li></ul> 
<p>实现方案</p> 
<p>其实现方案很简单，就是通过Intent <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fcontent%2FIntent%23ACTION_OPEN_DOCUMENT_TREE" rel="nofollow">ACTION_OPEN_DOCUMENT_TREE</a>，启动SAF让用户授权访问Android/data目录，属于官方公开的方法。<br><strong>前提是APP的targetsdkversion要小于30</strong>。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c6/dd/R4Ll2vUs_o.png"></p> 
<p></p> 
<p></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/12/00/2etzkLq4_o.png"></p> 
<p></p> 
<p><strong>文档链接：</strong><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.com%2Fabout%2Fversions%2F11%2Fprivacy%2Fstorage%23file-directory-restrictions" rel="nofollow">文档访问限制</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.com%2Ftraining%2Fdata-storage%2Fshared%2Fdocuments-files%23grant-access-directory" rel="nofollow">授予对目录内容的访问权限</a></p> 
<p>基本使用</p> 
<ol><li>通过Intent启动SAF授权界面，注意URI的百分号编解码（%3A和%2F），别随意替换，否则SAF无法导航到Android/data目录</li></ol> 
<p></p> 
<pre><code>     @TargetApi(26)
    private void requestAccessAndroidData(Activity activity){
        try {
            Uri uri = Uri.parse("content://com.android.externalstorage.documents/document/primary%3AAndroid%2Fdata");
            Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE);
            intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI, uri);
            //flag看实际业务需要可再补充
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION
                            | Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                            | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
            activity.startActivityForResult(intent, 6666);
        } catch (Exception e) {
            e.printStackTrace();
        }
    } 
</code></pre> 
<p></p> 
<p>授权申请</p> 
<ol><li>在用户同意授权后，持久化uri权限（否则关机重启或授权界面finish后，APP就无权限访问了），并只能通过DocumentFile进行业务操作，File API操作是无效的，此授权只是授权uri操作，并未授权文件系统，后续章节有说明。</li></ol> 
<p></p> 
<pre><code> implementation "androidx.documentfile:documentfile:1.0.1"
</code></pre> 
<p></p> 
<pre><code>  @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case 6666:
                if (resultCode == Activity.RESULT_OK) {
                    //persist uri 
                    getContentResolver().takePersistableUriPermission(data.getData(),
                            Intent.FLAG_GRANT_READ_URI_PERMISSION
                                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);

                    //now use DocumentFile to do some file op
                    DocumentFile documentFile = DocumentFile
                            .fromTreeUri(this, data.getData());
                    DocumentFile[] files = documentFile.listFiles();
                    ......
                }
                break;
            default:
                break;
        }
    }
</code></pre> 
<ol><li>注意这个授权用户是可以撤回的，通过点击应用信息界面的存储，就会看到撤回界面，所以业务需要去动态判断</li></ol> 
<p></p> 
<pre><code> public boolean isGrantAndroidData(Context context) {
        for (UriPermission persistedUriPermission : context.getContentResolver().getPersistedUriPermissions()) {
            if (persistedUriPermission.getUri().toString().
                    equals("content://com.android.externalstorage.documents/tree/primary%3AAndroid%2Fdata")) {
                return true;
            }
        }
        return false;
    }
</code></pre> 
<p></p> 
<p>授权撤回</p> 
<p>拓展</p> 
<p>通过前面二个章节，已经介绍了实现方案的基本使用，下面就该分析本文的亮点内容了</p> 
<ul><li>SAF是通过何种方式访问文件系统的，MediaStore API ? File API ? Native Code ？</li><li>SAF为何能访问Android/data目录</li></ul> 
<p>存储访问框架（SAF）简介</p> 
<p>为方便后续讲解，先简单回顾下SAF</p> 
<p></p> 
<p>SAF架构</p> 
<p><strong>APP：</strong><br> com.example.photos就是我们自己的APP</p> 
<p><strong>System UI：</strong><br> com.google.android.documentsui，一般称作DoucmentUI，就是上文中启动的授权界面APP，它只是个UI壳子</p> 
<p><strong>DocumentProvider:</strong><br> DocumentUI中数据的提供者，这个Provider可以有很多<br> com.android.externalstorage，是本地文件系统的Provider</p> 
<p>关于SAF更详细介绍，请参考官方<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.com%2Fguide%2Ftopics%2Fproviders%2Fdocument-provider%3Fhl%3Dzh-cn" rel="nofollow">存储访问框架</a><br> 经过SAF的简单介绍，分析目标很明确，那就是com.android.externalstorage</p> 
<p>SAF是通过何种方式访问文件系统的</p> 
<p>先安利几个AOSP源码查看网址：<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcs.android.com%2Fandroid%2Fplatform%2Fsuperproject%2F" rel="nofollow">官方的Android Code Search</a><br><a href="https://links.jianshu.com/go?to=http%3A%2F%2Faospxref.com%2F" rel="nofollow">国内的AOSP XREF</a></p> 
<p><strong>PS:</strong>后文源码链接都用的是XREF，方便国内查看</p> 
<p>从DocumentFile#listFile入手，经过源码跟踪会发现最终会调用 DocumentsProvider#queryChildDocuments方法</p> 
<p></p> 
<pre><code>public abstract class DocumentsProvider extends ContentProvider {
 .......
 @Override
    public final Cursor query(
            Uri uri, String[] projection, Bundle queryArgs, CancellationSignal cancellationSignal) {
       switch (mMatcher.match(uri)) {
                ......
                case MATCH_CHILDREN:
                case MATCH_CHILDREN_TREE:
                        .......
                        return queryChildDocuments(getDocumentId(uri), projection, queryArgs);
                        ......
                default:
                    throw new UnsupportedOperationException("Unsupported Uri " + uri);
            }
        } catch (FileNotFoundException e) {
            Log.w(TAG, "Failed during query", e);
            return null;
        }      
   }
 ......
}
</code></pre> 
<p>接下来看看com.android.externalstorage中DocumentProvider的实现类<br><a href="https://links.jianshu.com/go?to=http%3A%2F%2Faospxref.com%2Fandroid-11.0.0_r21%2Fxref%2Fframeworks%2Fbase%2Fpackages%2FExternalStorageProvider%2Fsrc%2Fcom%2Fandroid%2Fexternalstorage%2FExternalStorageProvider.java%3Fr%3D%26mo%3D2285%26fi%3D67%2367" rel="nofollow">ExternalStorageProvider</a>：<br> frameworks/base/packages/ExternalStorageProvider/src/com/android/externalstorage/ExternalStorageProvider.java</p> 
<p></p> 
<pre><code>import com.android.internal.content.FileSystemProvider;
public class ExternalStorageProvider extends FileSystemProvider 
</code></pre> 
<p>queryChildDocuments的实现位于其父类 <a href="https://links.jianshu.com/go?to=%255Bhttp%3A%2F%2Faospxref.com%2Fandroid-11.0.0_r21%2Fxref%2Fframeworks%2Fbase%2Fcore%2Fjava%2Fcom%2Fandroid%2Finternal%2Fcontent%2FFileSystemProvider.java%23439%255D%28http%3A%2F%2Faospxref.com%2Fandroid-11.0.0_r21%2Fxref%2Fframeworks%2Fbase%2Fcore%2Fjava%2Fcom%2Fandroid%2Finternal%2Fcontent%2FFileSystemProvider.java%23439%29" rel="nofollow">FileSystemProvider</a></p> 
<p></p> 
<pre><code>public abstract class FileSystemProvider extends DocumentsProvider {
  ......
  private Cursor queryChildDocuments(
            String parentDocumentId, String[] projection, String sortOrder,
            @NonNull Predicate&lt;File&gt; filter) throws FileNotFoundException {
        final File parent = getFileForDocId(parentDocumentId);
        final MatrixCursor result = new DirectoryCursor(
                resolveProjection(projection), parentDocumentId, parent);
        if (parent.isDirectory()) {
            //重点是这行
            for (File file : FileUtils.listFilesOrEmpty(parent)) {
                if (filter.test(file)) {
                    includeFile(result, null, file);
                }
            }
        } else {
            Log.w(TAG, "parentDocumentId '" + parentDocumentId + "' is not Directory");
        }
        return result;
    }
 ......
}
</code></pre> 
<p><a href="https://links.jianshu.com/go?to=http%3A%2F%2Faospxref.com%2Fandroid-11.0.0_r21%2Fxref%2Fframeworks%2Fbase%2Fcore%2Fjava%2Fandroid%2Fos%2FFileUtils.java%231222" rel="nofollow">FileUtils#listFilesOrEmpty</a></p> 
<p></p> 
<pre><code>    /** {@hide} */
    public static @NonNull File[] listFilesOrEmpty(@Nullable File dir) {
        return (dir != null) ? ArrayUtils.defeatNullable(dir.listFiles())
                : ArrayUtils.EMPTY_FILE;
    }
</code></pre> 
<p>至此，第一个问题，已经理清：<br> SAF的<a href="https://links.jianshu.com/go?to=http%3A%2F%2Faospxref.com%2Fandroid-11.0.0_r21%2Fxref%2Fframeworks%2Fbase%2Fpackages%2FExternalStorageProvider%2Fsrc%2Fcom%2Fandroid%2Fexternalstorage%2FExternalStorageProvider.java%3Fr%3D%26mo%3D2285%26fi%3D67%2367" rel="nofollow">ExternalStorageProvider</a>最终也是通过File API来访问文件系统的</p> 
<p>那么第二个问题，就很自然的来了，都是File API操作，为何我们的APP就不能访问呢？</p> 
<p>SAF为何能访问Android/data目录</p> 
<p>既然，SAF和我们的APP都是File API操作，那我们就去看看com.android.externalstorage属于哪些用户组。<br> adb shell 查查com.android.externalstorage进程的用户组</p> 
<p></p> 
<pre><code>#查进程ID
generic_x86_arm:/ $ ps -A|grep com.android.external
u0_a64        16233    296 1256792  85960 0                   0 S com.android.externalstorage
#查进程所属的用户组
generic_x86_arm:/ $ cat /proc/16233/status
Name:   externalstorage
Umask:  0077
State:  S (sleeping)
Tgid:   16233
Ngid:   0
Pid:    16233
PPid:   296
TracerPid:      0
Uid:    10064   10064   10064   10064
Gid:    10064   10064   10064   10064
FDSize: 64
#重点关注这行输出
Groups: 1015 1077 1078 1079 9997 20064 50064
</code></pre> 
<p>拿着这些神秘的GID在前面介绍的网址中一搜，就会很容易的发现GID的定义类<br><a href="https://links.jianshu.com/go?to=http%3A%2F%2Faospxref.com%2Fandroid-11.0.0_r21%2Fxref%2Fsystem%2Fcore%2Finclude%2Fprivate%2Fandroid_filesystem_config.h" rel="nofollow">android_filesystem_config.h</a></p> 
<p></p> 
<pre><code>#define AID_SDCARD_RW 1015       /* external storage write access */
#define AID_EXTERNAL_STORAGE 1077 /* Full external storage access including USB OTG volumes */
#define AID_EXT_DATA_RW 1078      /* GID for app-private data directories on external storage */
#define AID_EXT_OBB_RW 1079       /* GID for OBB directories on external storage */
#define AID_EVERYBODY 9997        /* shared between all apps in the same profile */
</code></pre> 
<p>其中1078和1079分别对应Android/data和Android/obb的访问权限<br> 如果我们APP能通过某种方式获取到1078和1079的用户组权限，岂不妙哉？<br> 遗憾的是，对于三方APP这是不可能的，除非是手机厂商的预置的系统APP</p> 
<p>总结</p> 
<ul><li>Android R上可通过SAF获得访问Android/data和Android/obb目录的权限，前提是APP targetsdkversion 小于30</li><li>SAF的底层实现<a href="https://links.jianshu.com/go?to=http%3A%2F%2Faospxref.com%2Fandroid-11.0.0_r21%2Fxref%2Fframeworks%2Fbase%2Fpackages%2FExternalStorageProvider%2Fsrc%2Fcom%2Fandroid%2Fexternalstorage%2FExternalStorageProvider.java%3Fr%3D%26mo%3D2285%26fi%3D67%2367" rel="nofollow">ExternalStorageProvider</a>也是通过File API来访问文件系统的</li><li>SAF之所以能访问Android/data和Android/obb是因为<a href="https://links.jianshu.com/go?to=http%3A%2F%2Faospxref.com%2Fandroid-11.0.0_r21%2Fxref%2Fframeworks%2Fbase%2Fpackages%2FExternalStorageProvider%2Fsrc%2Fcom%2Fandroid%2Fexternalstorage%2FExternalStorageProvider.java%3Fr%3D%26mo%3D2285%26fi%3D67%2367" rel="nofollow">ExternalStorageProvider</a><br> 进程具有GID 1078 和1079，三方APP是不可能拥有这些GID的</li></ul> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2c8386e8a4498581201e0cff2ebccf5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">The C Programming Language</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a2a4544aa24d661dc1c993b3837d29af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">操作系统中的IO控制方式详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>