<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SREXT 实现分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SREXT 实现分析" />
<meta property="og:description" content="要在 linux 中实现 SRv6 SFC 的模型， linux 从4.10版本开始已经支持了 SRv6 协议栈，大部分 SRv6 的转发节点功能都具备。不过目前要使用 SFC ，还有许多服务未支持 SRv6 甚至未支持 IPv6 ，也就是许多服务还是 unaware SRv6 类型的。
为了能让 unaware SRv6 SFC 也能接入，需要有一个代理来完成 SRv6 剥除并且记录通信值如指针等， SREXT 就实现了这个功能。
SREXT 以模块的方式载入内核，维护了一个本地 SID 表，如果是下一跳 SFC 是 unaware 类型，就剥除 SRv6 并记录指针、 SID List 等内容，待下一跳返回后重新封装 SRv6 ，使用记录的 SID List ，和记录的指针值再减一写入 SRH 中。
本文将研究 SREXT 的实现原理。
代码库： https://github.com/netgroup/SRv6-net-prog/tree/kernel-4_18
安装步骤：
$ git clone https://github.com/netgroup/SRv6-net-prog $ cd srv6-net-prog/srext/ $ sudo make $ sudo make install $ sudo depmod -a $ sudo modprobe srext 卸载步骤：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5055cd70594aa0824ff36f4a11a3615d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-05T06:13:04+08:00" />
<meta property="article:modified_time" content="2023-01-05T06:13:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SREXT 实现分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style=""> 要在 linux 中实现 SRv6 SFC 的模型， linux 从4.10版本开始已经支持了 SRv6 协议栈，大部分 SRv6 的转发节点功能都具备。不过目前要使用 SFC ，还有许多服务未支持 SRv6 甚至未支持 IPv6 ，也就是许多服务还是 unaware SRv6 类型的。</p> 
 <p style=""> 为了能让 unaware SRv6 SFC 也能接入，需要有一个代理来完成 SRv6 剥除并且记录通信值如指针等， SREXT 就实现了这个功能。</p> 
 <p style=""> SREXT 以模块的方式载入内核，维护了一个本地 SID 表，如果是下一跳 SFC 是 unaware 类型，就剥除 SRv6 并记录指针、 SID List 等内容，待下一跳返回后重新封装 SRv6 ，使用记录的 SID List ，和记录的指针值再减一写入 SRH 中。</p> 
 <p style=""> 本文将研究 SREXT 的实现原理。</p> 
 <p style=""></p> 
 <h2 style="text-align:left;">代码库：</h2> 
 <p style="text-indent:1.4em;"><a class="kdocs-link" style="color:#0A6CFF;" href="https://github.com/netgroup/SRv6-net-prog/tree/kernel-4_18" target="_blank" rel="noopener noreferrer">https://github.com/netgroup/SRv6-net-prog/tree/kernel-4_18</a></p> 
 <p style=""> 安装步骤：</p> 
 <pre class="kdocs-bash"><code class="language-bash">$ git clone https://github.com/netgroup/SRv6-net-prog 
$ cd srv6-net-prog/srext/
$ sudo make 
$ sudo make install
$ sudo depmod -a
$ sudo modprobe srext</code></pre> 
 <p style=""></p> 
 <p style=""> 卸载步骤：</p> 
 <pre class="kdocs-bash"><code class="language-bash">$ sudo rmmod srext
$ sudo make deinstall
$ sudo make clean</code></pre> 
 <h2 style="text-align:left;">测试部署：</h2> 
 <p style=""> <a class="kdocs-link" style="color:#0A6CFF;" href="https://netgroup.github.io/SRv6-net-prog/testbed-basic.html" rel="nofollow noopener noreferrer" target="_blank">https://netgroup.github.io/SRv6-net-prog/testbed-basic.html</a></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:740;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:27.297297%;height:0;"> 
    <img src="https://images2.imgbox.com/f1/cb/LrOVvUa3_o.png" style="margin-left:;display:block;width:100.0%;margin-top:-27.297297%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""> 部署运行步骤：</p> 
 <pre class="kdocs-bash"><code class="language-bash">$ vagrant box add srv6-net-prog http://cs.gssi.infn.it/files/SFC/srv6-net-prog.box
$ cd SRv6-net-prog/vagrant-box/testbed1/
$ vagrant up # 需要等待比较长的时间，如果中间有 ssh 相关的错误，有可能安装完机器后登录退出卡住了，多运行几次就可以。</code></pre> 
 <p style=""> 如果部署成功，运行 vagrant status 可以看到如下效果：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:569;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:21.441126%;height:0;"> 
    <img src="https://images2.imgbox.com/21/1b/kGRwh3qv_o.png" style="margin-left:;display:block;width:100.0%;margin-top:-21.441126%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""> 执行如下步骤来初始化 ingress 虚机：</p> 
 <pre class="kdocs-bash"><code class="language-bash">$ vagrant ssh ingress 
$ cd SRv6-net-prog/srext/scripts/testbed1/
$ sudo ./setup_ingress_testbed1.sh</code></pre> 
 <p style=""> 执行如下步骤来初始化 nfv 虚机：</p> 
 <pre class="kdocs-bash"><code class="language-bash">$ vagrant ssh nfv 
$ cd SRv6-net-prog/srext/scripts/testbed1/
$ sudo ./setup_nfv_testbed1.sh</code></pre> 
 <p style=""> 执行如下步骤来初始化 egress 虚机：</p> 
 <pre class="kdocs-bash"><code class="language-bash">$ vagrant ssh egress 
$ cd SRv6-net-prog/srext/scripts/testbed1/
$ sudo ./setup_egress_testbed1.sh</code></pre> 
 <p style=""> 执行完上述步骤后，模型就部署成功了，接下来就可以在 ingress 虚机中执行 $ sudo ip netns exec client ping6 b::2 验证测试了。</p> 
 <p style=""></p> 
 <h2 style="text-align:left;">流量模型：</h2> 
 <p style=""> 在 ingress 虚机中执行 $ sudo ip netns exec client ping6 b::2 时，流量模型如下：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:599;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:100.0%;height:0;"> 
    <img src="https://images2.imgbox.com/2f/14/eyH03ep4_o.png" style="margin-left:;display:block;width:100.0%;margin-top:-100.0%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""> 请求过程：</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在 ingress 虚机中，数据包通过 ip route 的 encap 配置封装了 srV6 报文；</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在 nfv 虚机中，srext 模块依据 Local SID Table 的配置将数据包剥除 SRv6 部分并转发给各个 unaware vnf 节点，在 unaware vnf 节点中抓包，抓到的是 client 发出的源数据包。 Srext 剥除 SRv6 时，会记录好数据包的 SID List 和指针信息。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>当 unaware vnf 将数据包处理完之后， srext 接收到该报文，依据 Local SID Table 的配置，取出之前存储记录的数据，将剥除了的 SRv6 报文再次加上，并且指针值减一，目的地址更新为下一跳 SID ；</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在 egress 虚机中， srext 模块依据 Local SID Table 的配置剥除数据包 SRv6 部分，并转发给目的 server 。</p></li></ol> 
 <p style=""> 应答过程与请求过程相似。</p> 
 <p style=""></p> 
 <h2 style="text-align:left;">代码分析：</h2> 
 <h3 style="text-align:left;">Srext 模块与 linux 系统协议栈的交互流程：</h3> 
 <p style=""> 在上述三个节点中， srext 的运作流程如下：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:740;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:41.351353%;height:0;"> 
    <img src="https://images2.imgbox.com/21/71/eeonyFvE_o.png" style="margin-left:;display:block;width:100.0%;margin-top:-41.351353%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>Srext 模块注册了两个钩子函数在 IP_PRE_ROUTING 结点上，分别是处理 ipv4 协议的 hook_v4_pre_routing 和处理 ipv6 协议的 sr_pre_routing 函数。在示例中，主要使用 ipv6 的 sr_pre_routing 函数。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>sr_pre_routing 函数负责从本地 SID 表，并执行其中的节点操作：</p></li></ol> 
 <ol start="1"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>首先使用接口名称去查表，如果接口在 Local SID Table 中有记录，则执行 behaviour 字段的操作;</p></li></ol> 
 <ol start="2"><li style="margin-left:2.8em;list-style-type:lower-alpha;text-indent:0;"><p>如果接口名称查表查不到，就拿数据包的目的 IP 再去查询 Local SID Table ，查到则执行 behaviour 字段操作；</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数据包在 sr_pre_routing 如果有命中 Local SID Table ，执行完数据包操作之后会发往 IP_LOCAL_INPUT 本机接收；如果没有命中 Local SID Table ，则会查询 route 子系统，继续 linux 系统的转发操作。</p></li></ol> 
 <p style=""></p> 
 <h4 style="text-align:left;">代码调用流程：</h4> 
 <pre class="kdocs-bash"><code class="language-bash">srext_init
|_ nf_register_net_hook(&amp;init_net,&amp;sr_ops_pre);

# 注册了 sr_pre_routing 钩子函数
sr_ops_pre.hook = sr_pre_routing;
sr_ops_pre.pf = PF_INET6;
sr_ops_pre.hooknum = NF_INET_PRE_ROUTING;
sr_ops_pre.priority = NF_IP_PRI_LAST;

sr_pre_routing
|_ sdev = sdev_lookup(skb-&gt;dev-&gt;name); # 依据接口名称查表
   |_ if (sdev == NULL) # 如果找不到就按目的地址查找
   |  |_ s6 = sid_lookup(iph-&gt;daddr);
   |     |_ if (s6 == NULL) # 如果目的地址也找不到，就退出 sr_pre_routing 继续执行 linux 系统流程
   |     |  |_ return NF_ACCEPT;
   |     |_ else # 如果依据目的地址查找成功，就执行 sid table 中配置的操作
   |        |_ s6-&gt;func(skb, s6))
   |_ sdev-&gt;func(skb, sdev); # 如果依据接口查表成功，就执行 sid table 中配置的操作</code></pre> 
 <p style=""></p> 
 <h3 style="text-align:left;">Linux 协议栈 ip 层处理流程：</h3> 
 <p style=""> 测试例子中，第一个节点在 srext 中是没有命中 Local SID Table 的，那么它会结束 srext 调用，继续执行 linux 协议栈的操作。当目的地址非本机时，数据包会进入路由查询流程然后转发，此时，在节点上使用 ip route 命令配置的封包操作就生效了。</p> 
 <p style=""> 以下时 ip route 模块在整个 linux 协议栈中的位置：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:421;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:141.5677%;height:0;"> 
    <img src="https://images2.imgbox.com/5e/75/33SJd7pT_o.png" style="margin-left:;display:block;width:100.0%;margin-top:-141.5677%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <h4 style="text-align:left;">代码调用流程：</h4> 
 <p style=""> 在例子中，使用了两个 route 命令，分别是：</p> 
 <pre class="kdocs-bash"><code class="language-bash">sudo ip -6 route add b::/64 via 1:2::2 encap seg6 mode encap segs 2::AD6:F1,2::AD6:F2,2::AD6:F3,3::D6
sudo ip -6 route add a::/64 via 2:3::1 encap seg6 mode encap segs 2::,1::D6</code></pre> 
 <p style=""> 这两个命令都作用在本地发出包后的 ip route 中，即上图 IP_LOCAL_OUT 流程之后调用。相关代码如下：</p> 
 <pre class="kdocs-bash"><code class="language-bash">ipv6_exthdrs_init # 扩展头初始化
|_ inet6_add_protocol(&amp;rthdr_protocol, IPPROTO_ROUTING); # 添加 srh 协议

static const struct inet6_protocol rthdr_protocol = {
        .handler        =        ipv6_rthdr_rcv,
        .flags          =        INET6_PROTO_NOPOLICY,
};

ipv6_rthdr_rcv
|_ ipv6_srh_rcv
   |_ ip6_route_input       seg6_lookup_nexthop
      |_ ip6_route_input_lookup
         |_ fib6_rule_lookup
            |_ lookup(net-&gt;ipv6.fib6_local_tbl) # 本地路由一般都配置在 fib local table 中。
            |_ lookup(net-&gt;ipv6.fib6_main_tbl) # 非本地路由一般都配置在 fib main table 中。</code></pre> 
 <h3 style="text-align:left;">Linux 添加路由过程：</h3> 
 <pre class="kdocs-bash"><code class="language-bash">fn_hash_insert

ip6_route_add
|_ ip6_route_info_create # 初始化 fib6_info 结构体
   |_ fib6_new_table # 如果 table 不存在的话
   |_ fib6_info_alloc


fib6_lookup
|_ fib6_table_lookup
   |_ fib6_node_lookup
   </code></pre> 
 <p style=""></p> 
 <p style=""></p> 
 <h2 style="text-align:left;">Reference</h2> 
 <p style=""><a class="kdocs-link" style="color:#0A6CFF;" href="https://www.man7.org/linux/man-pages/man8/ip-route.8.html" rel="nofollow noopener noreferrer" target="_blank">https://www.man7.org/linux/man-pages/man8/ip-route.8.html</a></p> 
 <p style=""><a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/weixin_42652361/article/details/110007778" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_42652361/article/details/110007778</a></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/541d1678ccb69e83728a4478d7f8d3b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">多卡训练中的BN(BatchNorm)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09a4a1bf38cfbdd9dea6fa95f04d27ef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringData JPA中@OneToMany和@ManyToOne的用法详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>