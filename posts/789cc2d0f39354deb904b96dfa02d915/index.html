<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中的五种构造函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中的五种构造函数" />
<meta property="og:description" content="这里写目录标题 默认构造函数何时生成默认的构造函数 普通构造函数拷贝构造函数何时生成默认的拷贝构造函数拷贝构造函数调用的时机 转换构造函数移动构造函数 C&#43;&#43;中的构造函数可以分为5类：默认构造函数、普通构造函数、拷贝构造函数、转换构造函数、移动构造函数。 默认构造函数 未提供显式初始值时，用来创建对象的构造函数。以Student类为例，默认构造函数的原型为
Student();//没有参数 Student(int num=0;int age=0);//所有参数均有默认值 何时生成默认的构造函数 当一个类没有构造函数时，如果满足以下四个条件其中之一，则编译器会为该类自动生成一个默认的构造函数：
该类含有一个类类型（非内置类型）的成员变量，且该类型含有默认构造函数。该类继承自含有默认构造函数的基类。该类继承或声明了虚函数。该类含有虚基类。 普通构造函数 C&#43;&#43;用于构建类的新对象时需要调用的函数
Student(int num，int age）;//有参数 拷贝构造函数 何时生成默认的拷贝构造函数 当一个类没有拷贝构造函数时，如果满足以下四个条件其中之一，则编译器会为该类自动生成一个默认的拷贝构造函数：
该类含有一个类类型（非内置类型）的成员变量，且该类型含有拷贝构造函数。该类继承自含有拷贝构造函数的基类。该类继承或声明了虚函数。该类含有虚基类。 需要注意的是，默认的拷贝构造函数实现的是浅拷贝。
拷贝构造函数调用的时机 拷贝构造函数在以下三种情况下会被调用。
1).当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。例如，下面的两条语句都会引发复制构造函数的调用，用以初始化 c2。
Complex c2(c1); Complex c2 = c1; 这两条语句是等价的。
注意，第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，赋值语句不会引发复制构造函数的调用。例如：
Complex c1, c2; c1=c2; 这条语句不会引发复制构造函数的调用，因为 c1 早已生成，已经初始化过了。
2).如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的类A的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。
#include&lt;iostream&gt; using namespace std; class A{ public: A(){}; A(A &amp; a){ cout&lt;&lt;&#34;Copy constructor called&#34;&lt;&lt;endl; } }; void Func(A a){ } int main(){ A a; Func(a); return 0; } 程序的输出结果为：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/789cc2d0f39354deb904b96dfa02d915/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-07T19:46:41+08:00" />
<meta property="article:modified_time" content="2022-09-07T19:46:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中的五种构造函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>这里写目录标题</h4> 
 <ul><li><a href="#_3" rel="nofollow">默认构造函数</a></li><li><ul><li><a href="#_9" rel="nofollow">何时生成默认的构造函数</a></li></ul> 
  </li><li><a href="#_16" rel="nofollow">普通构造函数</a></li><li><a href="#_22" rel="nofollow">拷贝构造函数</a></li><li><ul><li><a href="#_23" rel="nofollow">何时生成默认的拷贝构造函数</a></li><li><a href="#_33" rel="nofollow">拷贝构造函数调用的时机</a></li></ul> 
  </li><li><a href="#_123" rel="nofollow">转换构造函数</a></li><li><a href="#_133" rel="nofollow">移动构造函数</a></li></ul> 
</div> 
<br> 
<strong>C++中的构造函数可以分为5类：默认构造函数、普通构造函数、拷贝构造函数、转换构造函数、移动构造函数。</strong> 
<p></p> 
<h2><a id="_3"></a>默认构造函数</h2> 
<p>未提供显式初始值时，用来创建对象的构造函数。以Student类为例，默认构造函数的原型为</p> 
<pre><code class="prism language-cpp"><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//没有参数</span>
<span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//所有参数均有默认值</span>
</code></pre> 
<h3><a id="_9"></a>何时生成默认的构造函数</h3> 
<p>当一个类<strong>没有构造函数</strong>时，如果满足以下四个条件其中之一，则编译器会为该类自动生成一个默认的构造函数：</p> 
<ol><li>该类含有一个类类型（非内置类型）的成员变量，且该类型含有默认构造函数。</li><li>该类继承自含有默认构造函数的基类。</li><li>该类继承或声明了虚函数。</li><li>该类含有虚基类。</li></ol> 
<h2><a id="_16"></a>普通构造函数</h2> 
<p>C++用于构建类的新对象时需要调用的函数</p> 
<pre><code class="prism language-cpp"><span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> num，<span class="token keyword">int</span> age）<span class="token punctuation">;</span><span class="token comment">//有参数</span>
</code></pre> 
<h2><a id="_22"></a>拷贝构造函数</h2> 
<h3><a id="_23"></a>何时生成默认的拷贝构造函数</h3> 
<p>当一个类<strong>没有拷贝构造函数</strong>时，如果满足以下四个条件其中之一，则编译器会为该类自动生成一个默认的拷贝构造函数：</p> 
<ol><li>该类含有一个类类型（非内置类型）的成员变量，且该类型含有拷贝构造函数。</li><li>该类继承自含有拷贝构造函数的基类。</li><li>该类继承或声明了虚函数。</li><li>该类含有虚基类。</li></ol> 
<p>需要注意的是，默认的拷贝构造函数实现的是<strong>浅拷贝</strong>。</p> 
<h3><a id="_33"></a>拷贝构造函数调用的时机</h3> 
<p><strong>拷贝构造函数在以下三种情况下会被调用</strong>。</p> 
<p>1).当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。例如，下面的两条语句都会引发复制构造函数的调用，用以初始化 c2。</p> 
<pre><code class="prism language-cpp">Complex <span class="token function">c2</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span>
Complex c2 <span class="token operator">=</span> c1<span class="token punctuation">;</span>
</code></pre> 
<p>这两条语句是等价的。</p> 
<p>注意，<strong>第二条语句是初始化语句，不是赋值语句</strong>。赋值语句的等号左边是一个早已有定义的变量，<strong>赋值语句不会引发复制构造函数的调用</strong>。例如：</p> 
<pre><code class="prism language-cpp">Complex c1<span class="token punctuation">,</span> c2<span class="token punctuation">;</span>
c1<span class="token operator">=</span>c2<span class="token punctuation">;</span>
</code></pre> 
<p><strong>这条语句不会引发复制构造函数的调用</strong>，因为 c1 早已生成，已经初始化过了。</p> 
<p>2).如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，<strong>作为形参的类A的对象，是用复制构造函数初始化的</strong>，而且调用复制构造函数时的参数，就是调用函数时所给的实参。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span>A <span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Copy constructor called"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    A a<span class="token punctuation">;</span>
    <span class="token function">Func</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>程序的输出结果为：</p> 
<pre><code class="prism language-cpp">Copy constructor called
</code></pre> 
<p>这是因为 Func 函数的形参 a 在初始化时调用了复制构造函数。</p> 
<p>前面说过，函数的形参的值等于函数调用时对应的实参，现在可以知道这不一定是正确的。如果形参是一个对象，那么形参的值是否等于实参，取决于该对象所属的类的复制构造函数是如何实现的。例如上面的例子，Func 函数的形参 a 的值在进入函数时是随机的，未必等于实参，因为复制构造函数没有做复制的工作。</p> 
<p>以对象作为函数的形参，在函数被调用时，生成的形参要用复制构造函数初始化，这会带来时间上的开销。如果用对象的引用而不是对象作为形参，就没有这个问题了。但是以引用作为形参有一定的风险，因为这种情况下如果形参的值发生改变，实参的值也会跟着改变。</p> 
<p><strong>如果要确保实参的值不会改变，又希望避免复制构造函数带来的开销，解决办法就是将形参声明为对象的 const 引用</strong>。例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Function</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3). 如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，<strong>作为函数返回值的对象是用复制构造函数初始化 的</strong>，而调用复制构造函数时的实参，就是 return 语句所返回的对象。例如下面的程序：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> v<span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> v <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        v <span class="token operator">=</span> a<span class="token punctuation">.</span>v<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Copy constructor called"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>v <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>程序的输出结果是：</p> 
<pre><code class="prism language-cpp">Copy constructor called
<span class="token number">4</span>
</code></pre> 
<h2><a id="_123"></a>转换构造函数</h2> 
<p>一个构造函数接收一个不同于其类类型的形参，可以视为将其形参转换成类的一个对象。像这样的构造函数称为转换构造函数。在 C++ <strong>string 类中可以找到使用转换构造函数的实用示例</strong>。string 类提供一个将 C 字符串转换为 string 的转换构造函数</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">string</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//仅显示转换构造函数</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">string</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//形参时其他类型变量，且只有一个形参</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_133"></a>移动构造函数</h2> 
<p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用<strong>临时对象初始化新对象时</strong>，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Str</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span>
        <span class="token function">Str</span><span class="token punctuation">(</span>Str <span class="token operator">&amp;&amp;</span>s<span class="token punctuation">)</span><span class="token comment">//移动构造函数</span>
        <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">}</span>
        <span class="token operator">~</span><span class="token function">Str</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c7ca1abb01df1de4f6504dc4e31461af/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Git命令创建新分支</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/420e0fe5b7df7106a3e14cba510e3355/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【java锁】synchronized</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>