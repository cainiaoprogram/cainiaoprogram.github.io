<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>速度之王 — LZ4压缩算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="速度之王 — LZ4压缩算法" />
<meta property="og:description" content="LZ4 (Extremely Fast Compression algorithm) 项目：http://code.google.com/p/lz4/ 作者：Yann Collet 本文作者：zhangskd @ csdn blog
简介
LZ4 is a very fast lossless compression algorithm, providing compression speed at 400MB/s per core, scalable with multi-cores CPU. It also features an extremely fast decoder, with speed in multiple GB/s per core, typically reaching RAM speed limits on multi-core systems. A high compression derivative, called LZ4_HC, is also provided. It trades CPU time for compression ratio." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7056950a2d0091322fe6e428d9f94cb6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-08-05T16:42:20+08:00" />
<meta property="article:modified_time" content="2015-08-05T16:42:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">速度之王 — LZ4压缩算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>LZ4 (Extremely Fast Compression algorithm) <br> 项目：<a href="http://code.google.com/p/lz4/" rel="nofollow">http://code.google.com/p/lz4/</a> <br> 作者：Yann Collet <br> 本文作者：zhangskd @ csdn blog</p> 
<p>简介</p> 
<p>LZ4 is a very fast lossless compression algorithm, providing compression speed at 400MB/s per core, <br> scalable with multi-cores CPU. It also features an extremely fast decoder, with speed in multiple GB/s per core, <br> typically reaching RAM speed limits on multi-core systems. <br> A high compression derivative, called LZ4_HC, is also provided. It trades CPU time for compression ratio.</p> 
<p>(1) 横向对比 <br> Quick comparison: single thread, Core i5-3340M @2.7GHz, using the Open-Source Benchmark by m^2 (v0.14.2) <br> compiled with GCC v4.6.1 on Linux Ubuntu 64-bits v11.10, using the Silesia Corpus. <br> 对比当前流行的压缩工具，可以看到LZ4具有最快的压缩和解压速度，尽管压缩比一般。</p> 
<p>QuickLZ官网：<a href="http://www.quicklz.com/" rel="nofollow">http://www.quicklz.com/</a> <br> QuickLZ is the world’s fastest compression library, reaching 308MB/s per core. <br> QuickLZ自称是世界上最快的压缩算法，然而我们看到它和LZ4还是有差距的，特别是解压速度。</p> 
<p>snappy项目：<a href="https://code.google.com/p/snappy/" rel="nofollow">https://code.google.com/p/snappy/</a> <br> snappy is developed by Google based on ideas from LZ77 and open-sourced in 2011. <br> It was designed to be very fast and stable, but not to achieve a high compression ratio. <br> Compression speed is 250MB/s and decompression speed is 500MB/s using a single threaded, <br> 64-bit core i7 processor. The compression ratio is 20-100% lower than gzip. <br> snappy追求的是速度，压缩比并不高。</p> 
<p>(2) 纵向对比 <br> LZ4能很好的支持多线程环境，获得更高的压缩和解压速度。</p> 
<p>(3) 技术背景 <br> 多媒体技术 -&gt; 无损压缩 -&gt; 词典编码 -&gt; LZ77算法 -&gt; LZ4 <br> 词典编码(Dictionary Encoding)，根据的是数据本身包含有重复代码序列这个特性。 <br> 主要分为两类： <br> 1. 查找正在压缩的字符序列是否在前面输入数据中出现过，如果是，则用指向早期出现过的字符串的“指针”替代 <br> 重复的字符串。这里的“词典”是指以前处理过的数据。（LZ77、LZSS）。 <br> 2. 从输入的数据中创建一个“短语词典”，编码数据过程中当遇到已经在词典中出现过的“短语”时，编码器就输 <br> 出这个词典中的短语的“索引号”，而不是短语本身。（LZ78、LZW）</p> 
<p>(4) 其它格式 <br> 以下是一些常用的压缩格式。 <br> 1. zip <br> zlib库，可通过包含zlib.h使用。 <br> zip原名为Deflate，仅支持一个LZ77的变种算法Deflate。 <br> zip/unzip，后缀为.zip。zip也是Windows下常见的压缩格式。 <br> 2. gzip <br> gzip/gunzip是GNU程序，后缀为.gz。Web也常用GZIP压缩技术。 <br> 首先使用LZ77算法进行压缩，对结果再使用huffman编码进行压缩。 <br> tar中用-z来调用： <br> tar -czf pic.tar.gz *.jpg <br> tar -xzf pic.tar.gz <br> 3. bzip2 <br> bzip2/bunzip2，后缀为.bz2。 <br> 相比于gzip，压缩比更高，压缩效果比传统的LZ77/LZ78更好，但压缩速度较慢。 <br> 首先使用Burrows-Wheeler变换（BWT，块排序文本压缩），然后使用哈夫曼编码进行压缩。 <br> tar中使用-j来调用： <br> tar -cjf pic.tar.bz2 *.jpg <br> tar -xjf pic.tar.bz2 <br> 4. compress <br> compress/uncompress，后缀为.Z，现在已经不再流行了。 <br> 使用LZ78算法的变种LZW。 <br> tar中使用-Z来调用。 <br> 6. rar <br> rar/unrar，后缀为.rar。 <br> rar格式较zip格式的压缩比高。 <br> 注意RAR非免费，是Windows下常见压缩格式，也有RAR for Linux。 <br> rar a pic *.jpg // pic.rar <br> rar e pic.rar // pic <br> 7. 7z <br> 7-Zip，后缀为.7z。 <br> 和rar、zip一样，7z也是Windows下常见的压缩格式。 <br> 使用改良与优化后的LZ77算法LZMA、LZMA2，压缩比高于zip。 <br> 8. xz <br> xz，后缀为.xz。 <br> 如果说LZ4是压缩速度之王，xz则是压缩比之王。 <br> 一般来说，用xz压缩后的文件，能比用gzip压缩的小30%，比用bzip2压缩的小15%。 <br> 主要使用LZMA2压缩算法。 <br> tar不支持xz格式，xz / xz -d。</p> 
<p>LZ77</p> 
<p>我们看到很多压缩格式都是基于LZ77的，所以先来了解下LZ77算法，这里引用了较多的网上资料：） <br> 1977年，Jacob Ziv和Abraham Lempel描述了一种基于滑动窗口缓存的技术，该缓存用于保存最近刚刚处理的文本。 <br> LZ77编码的核心是查找从前向缓冲器开始的最长的匹配串。</p> 
<p>压缩算法使用了两个缓存： <br> 1. 滑动历史缓存，包含了前面处理过的N个源字符。 <br> 2. 前向缓存，包含了将要处理的下面L个字符。</p> 
<p>压缩过程 <br> 算法尝试将前向缓存开始的两个或多个字符与滑动历史缓存中的字符串相匹配。 <br> 如果没有发现匹配，前向缓存的第一个字符作为9bit的字符输出并且移入滑动窗口，滑动窗口中最久的字符被移除。 <br> 如果找到匹配，算法继续扫描以找到最长的匹配。然后匹配字符串作为三元组输出(选项、指针和长度)。对于K个字符 <br> 的字符串，滑动窗口中最久的K个字符被移出，并且被编码的K个字符被移入窗口。</p> 
<p>更具体来说： <br> 1. 从当前压缩位置开始，查看未编码的数据，并试图在滑动窗口中找出最长的匹配字符串，如果找到，则进行步骤2，否则进行步骤3。 <br> 2. 输出三元符号组(off, len, c)。其中off为窗口中匹配字符串相对窗口边界的偏移，len为可匹配的长度，c为下一个字符。 <br> 然后将窗口向后滑动len + 1个字符，继续步骤1。 <br> 3. 输出三元符合组(0, 0, c)。其中c为下一个字符。然后将窗口向后滑动len + 1个字符，继续步骤1。</p> 
<p>实例 <br> 假设窗口大小为10个字符，我们刚编码过的字符(滑动窗口)是：abcdbbccaa，即将编码的字符(前向缓存)是：abaeaaabaee。 <br> 1. 和编码字符匹配的最长串为ab，下一个字符为a，输出三元组(0, 2, a)。 <br> 窗口向后滑动3个字符为：dbbccaaaba，前向缓存为：eaaabaee。 <br> 2. 字符e在窗口中无匹配，输出三元组(0, 0, e)，窗口向后滑动1个字符为：bbccaaabae，前向缓存为：aaabaee。 <br> 3. 前向缓存的最长匹配串为aaabae，下一个字符为e，输出三元组(4, 6, e)，完成编码。</p> 
<p>解压过程 <br> 解压算法必须保存解压输出的最后N个字符（滑动窗口）。 <br> 当碰到编码字符串时，使用指针和长度字段，将编码替换成实际的正文字符串。</p> 
<p>评价 <br> 算法使用了有限的窗口在以前的文本中查找匹配，对于相对于窗口大小来说非常长的文本块，很多可能的匹配就会被丢掉。 <br> 窗口大小可以增加，但这会带来两个损失： <br> 1. 算法的处理时间会增加，因为它必须为滑动窗口的每个位置进行一次与前向缓存的字符串匹配的工作。 <br> 2. 指针字段必须更长，以允许更长的跳转。</p> 
<p>在多数情况下，lz77拥有较高的压缩效率。而在待压缩文件中绝大多数是些超长匹配，并且相同的超长匹配高频率地反复 <br> 出现时，lzw更具优势。GIF就是采用了lzw算法来压缩背景单一、图形简单的图片。zip是用来压缩通用文件的，这就是它 <br> 采用对大多数文件有更高压缩率的lz77算法的原因。</p> 
<p>优化 <br> 精心设计三元组(off, len, c)中每个分量的表示方法，才能达到较好的效果。 <br> (1) off <br> off为窗口内的偏移，通常的经验是，偏移接近窗口尾部的情况要多于接近窗口头部的情况，这是因为字符串在与其接近的 <br> 位置容易找到匹配串，但对于普通的窗口大小(如4096字节)来说，偏移值基本还是均匀分布的，我们完全可以用固定的位 <br> 数来表示它。 <br> (2) len <br> len为字符串长度，它在大多数时候不会太大，少数情况下才会发生大字符串的匹配。显然可以使用一种变长编码方式来表 <br> 示该长度值。要输出变长的编码，该编码必须满足前缀码的条件。Huffman编码可以用于此处，但不是最好的选择。 <br> Golomb编码应用比较广泛，对于较小的数用较短的编码，对较大的数用较大的编码表示。 <br> (3) c <br> c为前向缓存中的不匹配字符。直接用8个二进制位编码。 <br> (4) 输出格式 <br> LZ77的原始算法采用三元组输出每一个匹配串及其后续字符，即使没有匹配，仍需要输出一个len=0的三元组来表示单个字符。 <br> 实验表明，这种方式对于某些特殊情况(例如同一字符不断重复的情形)有着较好的适应能力。 <br> 对一般数据，有一种更有效的输出方式。 <br> 将每一个输出分成匹配串和单个字符两种类型，并首先输出一个二进制位对其加以区分。例如，输出0表示下面是一个匹配串， <br> 输出1表示下面是一个单个字符。之后，如果要输出的是单个字符，我们直接输出该字符的字节值，需要8个二进制位。 <br> 也就是说，输出一个单个的字符共需要9个二进制位。 <br> 如果要输出的是匹配串，则输出off和len。off可以用定长编码，也可以用变长前缀码。len用变长前缀码。有时候我们可以对匹配 <br> 长度加以限制，例如，限制最少匹配3个字符。因为对于2个字符的匹配串，我们使用匹配串的输出方式不一定比我们直接输出2 <br> 个单个字符(共需18位)节省空间。 <br> 这种输出方式的优点是：输出单个字符的时候比较节省空间。另外，因为不强求每次都外带一个后续字符，可以适应一些较长 <br> 匹配的情况。 <br> (5) 查找匹配串 <br> 在滑动窗口中查找最长的匹配串，是LZ77算法中的核心问题，关系着空间和时间复杂度。</p> 
<p>golomb</p> 
<p>哥伦布编码。主要针对整数进行编码，对较小的数用较短的编码，对较大的数用较大的编码表示。 <br> 假设x为要进行编码的整数，当x趋于较小的取值时候，此时的Golomb编码较短，可以有效的节省空间。</p> 
<p>压缩算法： <br> 1. 选定参数m，b = 2^m，注意m是要在压缩前指定的。 <br> 2. q = ((x - 1) / b)，表示取整。 <br> 3. r = x - qb - 1，所以x = qb + r + 1。(注意这个1不用存储，只要默认恢复出来的数据加1即可) <br> 4. 这样要编码的x由两部分组成： <br> a. 第一部分由q个1加上一个0组成，表示q。 <br> b. 第二部分由m个位组成，表示r。</p> 
<p>恢复算法： <br> 如果读入1，则继续往后读，直到读入0，此时读入的1的个数就是q。 <br> 之后的m位(m事先约定了)为r。 <br> 所以可以计算出x = qb + 1 + r = q * 2^m + r + 1。</p> 
<p>Reference</p> 
<p>[1]. <a href="http://fastcompression.blogspot.com/p/lz4.html" rel="nofollow">http://fastcompression.blogspot.com/p/lz4.html</a> <br> [2]. <a href="http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_1.htm" rel="nofollow">http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_1.htm</a> <br> [3]. <a href="http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_2.htm" rel="nofollow">http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_2.htm</a> <br> [4]. <a href="http://hi.baidu.com/guoliqiang2006/item/127c8f989b494b4ef14215db" rel="nofollow">http://hi.baidu.com/guoliqiang2006/item/127c8f989b494b4ef14215db</a> <br> [5]. <a href="http://blog.chinaunix.net/uid-17240700-id-3347894.html" rel="nofollow">http://blog.chinaunix.net/uid-17240700-id-3347894.html</a> <br> [6]. <a href="http://jpkc.zust.edu.cn/2007/dmt/course/Mmt03_02_2.htm" rel="nofollow">http://jpkc.zust.edu.cn/2007/dmt/course/Mmt03_02_2.htm</a> <br> [7]. <a href="http://tukaani.org/xz/" rel="nofollow">http://tukaani.org/xz/</a> <br> LZ4格式</p> 
<p>The compressed block is composed of sequences. <br> 每个数据块可以压缩成若干个序列，格式如下：</p> 
<p>(1) literals <br> length of literals. If it is 0, then there is no literal. If it is 15, then we need to add some more bytes to indicate the <br> full length. Each additional byte then represent a value of 0 to 255, which is added to the previous value to produce <br> a total length. When the byte value is 255, another byte is output. <br> literals are uncompressed bytes, to be copied as-is.</p> 
<p>(2) match <br> offset. It represents the position of the match to be copied from. <br> Note that 0 is an invalid value, never used. 1 means “current position - 1 byte”. <br> The maximum offset value is really 65535. The value is stored using “little endian” format. <br> matchlength. There is an baselength to apply, which is the minimum length of a match called minmatch. <br> This minimum is 4. As a consequence, a value of 0 means a match length of 4 bytes, and a value of 15 means a <br> match length of 19+ bytes. (Similar to literal length)</p> 
<p>(3) rules <br> 1. The last 5 bytes are always literals. <br> 2. The last match cannot start within the last 12 bytes. <br> So a file within less than 13 bytes can only be represented as literals.</p> 
<p>(4) scan strategy <br> a single-cell wide hash table. <br> Each position in the input data block gets “hashed”, using the first 4 bytes (minimatch). Then the position is stored <br> at the hashed position. Obviously, the smaller the table, the more collisions we get, reducing compression <br> effectiveness. The decoder do not care of the method used to find matches, and requires no addtional memory.</p> 
<p>(5) Streaming format</p> 
<p>实现</p> 
<p>(1) 哈希表 <br> Each position in the input data block gets “hashed”, using the first 4 bytes (minimatch). Then the position is stored <br> at the hashed position. Obviously, the smaller the table, the more collisions we get, reducing compression <br> effectiveness. The decoder do not care of the method used to find matches, and requires no addtional memory.</p> 
<p>LZ4使用哈希表来查找匹配字符串。这个哈希表的映射关系(key, value)： <br> key为4个字节的二进制值。 <br> value为这4个字节在块中的位置。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> /* Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache。 <br> * Increasing memory usage improves compression ratio <br> * Reduced memory usage can improve speed, due to cache effect <br> */ </p> 
<h2 id="define-memoryusage-14">define MEMORY_USAGE 14</h2> 
<h2 id="define-lz4hashlog-memoryusage-2-哈希桶位数12">define LZ4_HASHLOG (MEMORY_USAGE - 2) /* 哈希桶位数12 */</h2> 
<h2 id="define-hashtablesize-1-memoryusage-哈希表大小214-16k">define HASHTABLESIZE (1 &lt;&lt; MEMORY_USAGE) /* 哈希表大小2^14 = 16K */</h2> 
<h2 id="define-hashnbcells4-1-lz4hashlog-哈希桶个数212-4k">define HASHNBCELLS4 (1 &lt;&lt; LZ4_HASHLOG) /* 哈希桶个数2^12 = 4K */</h2> 
<p>选择哈希表的大小时，要做一个权衡： <br> 1. 侧重压缩比，则哈希表可以大一些。 <br> 2. 侧重压缩速度，则哈希表应该适中，以便能装入L1 cache。 <br> 默认的哈希表使用的内存为16KB，能装进L1 cache，这也是LZ4压缩速度快的一个原因。 <br> 当前主流的Intel X86 L1 Data Cache为32KB，所以建议哈希表不要超过此大小。</p> 
<p>typedef enum { byPtr, byU32, byU16} tableType_t; <br> 哈希表存储的数据为“位置”，分三种情况： <br> 1. inputSize小于64KB时，使用byU16，表示16位的偏移值即可。 <br> 2. inputSize大于64KB时： <br> 2.1 指针大小为8字节，使用byU32，表示32位的偏移值，如果用指针不划算。 <br> 2.2 指针大小为4字节，使用byPtr，表示32位的指针。</p> 
<p>采用整数哈希算法。 <br> 2654435761U是2到2^32的黄金分割素数，2654435761 / 4294967296 = 0.618033987。 <br> 计算哈希值，输入为4个字节，输出可分为2字节值、4字节值两种哈希值。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> FORCE_INLINE int LZ4_hashSequence(U32 sequence, tableType_t tableType) <br> { <br> if (tableType == byU16) <br> /* 哈希表为16K，如果哈希value为16位 =&gt; 哈希key为13位 */ <br> return (((sequence) * 2654435761U) &gt;&gt; ((MINMATCH * 8) - (LZ4_HASHLOG + 1))); <br> else <br> /* 哈希表为16K，如果哈希value为32位 =&gt; 哈希key为12位 */ <br> return (((sequence) * 2654435761U) &gt;&gt; ((MINMATCH * 8) - LZ4_HASHLOG)); <br> } </p> 
<p>FORCE_INLINE int LZ4_hashPosition(const BYTE *p, tableType_t tableType) \ <br> { return LZ4_hashSequence(A32(p), tableType); } <br> 把地址存入到哈希表中。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> FORCE_INLINE void LZ4_putPositionOnHash(const BYTE *p, U32 h, void *tableBase, tableType_t tableType, <br> const BYTE *srcBase) <br> { <br> switch(tableType) <br> { <br> case byPtr: { const BYTE <strong>hashTable = (const BYTE </strong>) tableBase; hashTable[h] = p; break; } <br> case byU32: { U32 <em>hashTable = (U32 </em>) tableBase; hashTable[h] = (U32) (p - srcBase); break; } <br> case byU16: { U16 <em>hashTable = (U16 </em>) tableBase; hashTable[h] = (U16) (p - srcBase); break; } <br> } <br> } <br> 计算指针p指向的4字节的哈希值，然后把它的位置存入哈希表中。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> FORCE_INLINE void LZ4_putPosition(const BYTE *p, void *tableBase, tableType_t tableType, const BYTE *srcBase) <br> { <br> U32 h = LZ4_hashPosition(p, tableType); /* 计算哈希值 */ <br> LZ4_putPositionOnHash(p, h, tableBase, tableType, srcBase); /* 把地址存入哈希表 */ <br> } <br> 根据哈希值，获取地址。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> FORCE_INLINE const BYTE *LZ4_getPositionOnHash(U32 h, void *tableBase, tableType_t tableType, <br> const BYTE *srcBase) <br> { <br> if (tableType == byPtr) { const BYTE <strong>hashTable = (const BYTE </strong>) tableBase; return hashTable[h]; } <br> if (tableType == byU32) { U32 <em>hashTable = (U32 </em>) tableBase; return hashTable[h] + srcBase; } <br> { U16 <em>hashTable = (U16 </em>) tableBase; return hashTable[h] + srcBase; } /* default, to ensure a return */ <br> } <br> 根据指针p指向的4字节，计算哈希值，并查找此哈希桶是否已有赋值。 <br> 如果此哈希桶已有赋值，则说明此时的4字节和上次的4字节很可能是一样的（如果是冲突，则是不一样的）。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> FORCE_INLINE const BYTE *LZ4_getPosition(const BYTE *p, void *tableBase, tableType, const BYTE *srcBase) <br> { <br> U32 h = LZ4_hashPosition(p, tableType); <br> return LZ4_getPositionOnHash(h, tableBase, tableType, srcBase); <br> } </p> 
<p>(2) 压缩 <br> LZ4_compress()是压缩的一个入口函数，先申请哈希表，然后调用LZ4_compress_generic()。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> /* LZ4_compress(): <br> * Compress inputSize bytes from source into dest. <br> * Destination buffer must be already allocated, and must be sized to handle worst cases situations <br> * (input data not compressible) <br> * Worst case size evaluation is provided by function LZ4_compressBound() <br> * inputSize: Max support value is LZ4_MAX_INPUT_VALUE <br> * return: the number of bytes written in buffer dest or 0 if the compression fails. <br> */ </p> 
<p>int LZ4_compress(const char *source, char *dest, int inputSize) <br> { </p> 
<h2 id="if-heapmode-在堆中给哈希表分配内存">if (HEAPMODE) /* 在堆中给哈希表分配内存 */</h2> 
<pre><code>void *ctx = ALLOCATOR(HASHNBCELLS4, 4); /* Aligned on 4-bytes boundaries */  
</code></pre> 
<h2 id="else-在栈中给哈希表分配内存比较快默认">else /* 在栈中给哈希表分配内存，比较快，默认 */</h2> 
<pre><code>U32 ctx[1U &lt;&lt; (MEMORY_USAGE - 2) ] = {0}; /* Ensure data is aligned on 4-bytes boundaries */  
</code></pre> 
<h2 id="endif">endif</h2> 
<pre><code>int result;  

/* 输入小于64K+11，则用16位来表示滑动窗口，否则用32位*/  
if (inputSize &lt; (int) LZ4_64KLIMIT)   
    result = LZ4_compress_generic((void *)ctx, source, dest, inputSize, 0, notLimited, byU16, noPrefix);  
else  
    result = LZ4_compress_generic((void *)ctx, source, dest, inputSize, 0, notLimited,  
                        (sizeof(void *) == 8 ? byU32 : byPtr, noPrefix);  
</code></pre> 
<h2 id="if-heapmode">if (HEAPMODE)</h2> 
<pre><code>FREE(ctx);  
</code></pre> 
<h2 id="endif-1">endif</h2> 
<pre><code>return result;  
</code></pre> 
<p>} <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片</p> 
<h2 id="define-minmatch-4-以4字节为单位查找哈希表">define MINMATCH 4 /* 以4字节为单位查找哈希表 */</h2> 
<h2 id="define-copylength-8">define COPYLENGTH 8</h2> 
<h2 id="define-lastliterals-5">define LASTLITERALS 5</h2> 
<h2 id="define-mflimit-copylength-minmatch-对于最后的12个字节不进行查找匹配">define MFLIMIT (COPYLENGTH + MINMATCH) /* 对于最后的12个字节，不进行查找匹配 */</h2> 
<p>const int LZ4_minLength = (MFLIMIT + 1); /* 一个块要&gt;=13个字符，才会进行查找匹配 */ </p> 
<h2 id="define-lz464klimit-116-mflimit-1-64k-11">define LZ4_64KLIMIT ((1&lt;&lt;16) + (MFLIMIT - 1)) /* 64K + 11 */</h2> 
<p>/* Increasing this value will make the compression run slower on incompressible data。 <br> * 用于控制查找匹配时的前进幅度，如果一直没找到匹配，则加大前进幅度。 <br> */ </p> 
<h2 id="define-skipstrength-6">define SKIPSTRENGTH 6</h2> 
<p>LZ4_compress_generic()是主要的压缩函数，根据指定的参数，可以执行多种不同的压缩方案。</p> 
<p>匹配算法 <br> 1. 当前的地址为ip，它的哈希值为h。 <br> 2. 下个地址为forwardIp，它的哈希值为forwardH (下个循环赋值给ip、h)。 <br> 3. 按照哈希值h，获取哈希表中的值ref。 <br> 3.1 ref为初始值，没有匹配，A32(ip) != A32(ref)，继续。 <br> 3.2 ref不为初始值，有匹配。 <br> 3.2.1 ref不在滑动窗口内，放弃，继续。 <br> 3.2.2 ref对应的U32和ip对应的U32不一样，是冲突，继续。 <br> 3.3.3 ref在滑动窗口内，且对应的U32一样，找到了match，退出。 <br> 4. 保存ip和h的对应关系。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> FORCE_INLINE int LZ4_compress_generic(void *ctx, const char *source, char *dest, int inputSize, <br> int maxOutputSize, limitedOutput_directive limitedOutput, tableType_t tableType, <br> prefix64k_directive prefix) <br> { <br> const BYTE <em>ip = (const BYTE </em>) source; <br> /* 用作哈希表中的srcBase */ <br> const BYTE <em>const base = (prefix == withPrefix) ? ((LZ4_Data_Structure </em>)ctx)-&gt;base : (const BYTE *)source); <br> /* 前向窗口的起始地址 */ <br> const BYTE <em>const lowLimit = ((prefix == withPrefix) ? ((LZ4_Data_Structure </em>)ctx)-&gt;bufferStart : (const BYTE *)source); <br> const BYTE <em>anchor = (const BYTE </em>)source; <br> const BYTE <em>const iend = ip + inputSize; /</em> 输入的结束地址 */ <br> const BYTE <em>const mflimit = iend - MFLIMIT; /</em> iend - 12，超过此处不允许再启动一次匹配 */ <br> const BYTE <em>const matchlimit = iend - LASTLITERALS; /</em> iend - 5，最后5个字符不允许匹配 */ </p> 
<pre><code>BYTE *op = (BYTE *) dest; /* 用于操作输出缓存 */  
BYTE *const oend = op + maxOutputSize; /* 输出缓存的边界，如果有的话 */  

int length;  
const int skipStrength = SKIPSTRENGTH; /* 6 */  
U32 forwardH;  

/* Init conditions */  
if ((U32) inputSize &gt; (U32) LZ4_MAX_INPUT_SIZE) return 0; /* 输入长度过大 */  
/* must continue from end of previous block */  
if ((prefix == withPrefix) &amp;&amp; (ip != ((LZ4_Data_Structure *)ctx)-&gt;nextBlock)) return 0;  
/* do it now, due to potential early exit. 保存下一个块的起始地址 */  
if (prefix == withPrefix) ((LZ4_Data_Structure *)ctx)-&gt;nextBlock = iend;  
if ((tableType == byU16) &amp;&amp; (inputSize &gt;= LZ4_64KLIMIT)) return 0; /* Size too large (not within 64K limit) */  
if (inputSize &lt; LZ4_minlength) goto _last_literals; /* 如果输入长度小于13，则不查找匹配 */  

/* First Byte */  
LZ4_putPosition(ip, ctx, tableType, base); /* 计算以第一个字节开头的U32的哈希值，保存其位置 */  
ip++; forwardH = LZ4_hashPosition(ip, tableType); /* 计算以第二个字节开头的U32的哈希值 */  

/* Main loop，每次循环查找一个匹配，产生一个序列 */  
for ( ; ; )  
{  
    int findMatchAttempts = (1U &lt;&lt; skipStrength) + 3;  
    const BYTE *forwardIp = ip;  
    const BYTE *ref;  
    BYTE *token;  

    /* Find a match，查找一个匹配，或者到了尽头mflimit */  
    do {  
        U32 h = forwardH; /* 当前ip对应的哈希值 */  
        int step = findMatchAttempts++ &gt;&gt; skipStrength; /* forwardIp的偏移，一般是1 */  
        ip = forwardIp;  
        forwardIp = ip + step; /* 前向缓存中下个将检查的地址 */  

        if unlikely(forwardIp &gt; mflimit) { goto _last_literals; } /* &gt;=12字节才会去匹配 */  
        forwardH = LZ4_hashPosition(forwardIp, tableType); /* forwardIp的哈希值 */   

        /* 这里是查找的关键：按照哈希值h，获取地址ref。 
         * 1. 没有匹配，ref为srcBase。 
         * 2. 有匹配。 
         *     2.1 不在滑动窗口内，继续。 
         *     2.2 对应的U32不一样，是冲突，继续。 
         *     2.3 在滑动窗口内，且对应的U32一样，找到了match，退出。 
         */   
        ref = LZ4_getPositionOnHash(h, ctx, tableType, base);   
        LZ4_putPositionOnHash(ip, h, ctx, tableType, base); /* 保存ip、h这个对应关系 */  
    } while ((ref + MAX_DISTANCE &lt; ip) || (A32(ref) != A32(ip)));  

    /* 找到匹配之后，看能否向前扩大匹配 */  
    while((ip &gt; anchor) &amp;&amp; (ref &gt; lowLimit) &amp;&amp; unlikely(ip[-1] == ref[-1])) { ip--; ref--; }  

    /* Encode Literal length，赋值Literal length */  
    length = (int) (ip - anchor);  
    token = op++;  

    /* Check output limit */  
    if ((limitedOutput) &amp; unlikely(op + length + 2 + (1 + LASTLITERALS) + (length&gt;&gt;8) &gt; oend)) return 0;  

    if (length &gt;= (int) RUN_MASK) {  
        int len = length - RUN_MASK;  
        *token = (RUN_MASK &lt;&lt; ML_BITS);  
        for(; len &gt;= 255; len -= 255) *op++ = 255;  
        *op++ = (BYTE) len;  
    } else  
        *token = (BYTE) (length &lt;&lt; ML_BITS);  

    /* Copy Literals，复制不可编码字符 */  
    { BYTE * end = (op) + (length); LZ4_WILDCOPY(op, anchor, end); op = end; }  
</code></pre> 
<p>_next_match: /* 向后扩展匹配 */ <br> /* Encode Offset，赋值offset，op += 2 */ <br> LZ4_WRITE_LITTLEENDIAN_16(op, (U16) (ip - ref)); </p> 
<pre><code>    /* Start Counting */  
    ip += MINMATCH; ref += MINMATCH; /* MinMatch already verified */  
    anchor = ip;  

    while likely(ip &lt; matchlimit - (STEPSIZE - 1)) {  
        size_t diff = AARCH(ref) ^ AARCH(ip); /* 异或，值为零表示相同 */  
        if (! diff) { ip += STEPSIZE; ref += STEPSIZE; continue; }  
        ip += LZ4_NbCommonBytes(diff); /* STEPSIZE不同，看其中有多少个字节是相同的 */  
        goto _endCount;  
    }  

    if (LZ4_ARCH64)   
        if ((ip &lt; (matchlimit - 3)) &amp;&amp; (A32(ref) == A32(ip))) { ip += 4; ref += 4; }  
    if ((ip &lt; matchlimit - 1)) &amp;&amp; (A16(ref) == A16(ip))) { ip += 2; ref += 2; }  
    if ((ip &lt; matchlimit) &amp;&amp; (*ref == *ip)) ip++;  
</code></pre> 
<p>_endCount: <br> /* Ecode MatchLength，赋值match length */ <br> length = (int) (ip - anchor); <br> /* Check output limit */ <br> if ((limitedOutput) &amp;&amp; unlikely(op + (1 + LASTLITERALS) + (length &gt;&gt; 8) &gt; oend)) return 0; </p> 
<pre><code>    if (length &gt;= (int) ML_MASK) {  
        *token += ML_MASK;  
        length -= ML_MASK;  
        for (; length &gt; 509; length -= 510) { *op++ = 255; *op++ = 255; }  
        if (length &gt;= 255) { length -= 255; *op++ = 255; }  
        *op++ = (BYTE) (length);  
    } else  
        *token += (BYTE) (length);  

    /* Test end of chunk */  
    if (ip &gt; mflimit) { anchor = ip; break; } /* 不再进行匹配了 */  
    /* Fill table，顺便保存 */  
    LZ4_putPosition(ip - 2, ctx, tableType, base);     

    /* Test next position，尝试着找匹配 */  
    ref = LZ4_getPosition(ip, ctx, tableType, base);  
    LZ4_putPosition(ip, ctx, tableType, base);  
    /* 如果找到匹配，说明没有literals，可以直接跳过查找、赋值literal length */  
    if ((ref + MAX_DISTANCE &gt;= ip) &amp;&amp; (A32(ref) == A32(ip))) { token = op++; *token = 0; goto _next_match; }     

    /* Prepare next loop，准备进行下个循环 */  
    anchor = ip++;  
    forwardH = LZ4_hashPosition(ip, tableType);  
}  
</code></pre> 
<p>_last_literals: <br> /* Encode Last Literals */ <br> { <br> int lastRun = (int) (iend - anchor); /* 最后原字符串长度 */ </p> 
<pre><code>    if ((limitedOutput) &amp;&amp; (((char *)op - dest) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) &gt;   
            (U32) maxOutputSize))  
        return 0; /* check output limit */  

    if (lastRun &gt;= (int) RUN_MASK) {   
        *op ++ = (RUN_MASK &lt;&lt; ML_BITS);   
        lastRun -= RUN_MASK;  
        for (; lastRun &gt;= 255; lastRun -=255) *op++ = 255;  
        *op++ = (BYTE) lastRun;  
    } else  
        *op++ = (BYTE) (lastRun &lt;&lt; ML_BITS);  

    memcpy(op, anchor, iend - anchor); /* 复制literals */  
    op += iend - anchor;  
}  

/* End */  
return (int) (((char *)op) - dest); /* 返回压缩后的长度 */  
</code></pre> 
<p>} </p> 
<h2 id="define-lz4maxinputsize-0x7e000000-2-113-929-216-bytes">define LZ4_MAX_INPUT_SIZE 0x7E000000 /* 2 113 929 216 bytes */</h2> 
<h2 id="define-mlbits-4-token-4-low-bits-match-length">define ML_BITS 4 /* Token: 4-low-bits, match length */</h2> 
<h2 id="define-mlmask-1u-mlbits-1">define ML_MASK ((1U &lt;&lt; ML_BITS) - 1)</h2> 
<h2 id="define-runbits-8-mlbits-token-4-high-bits-literal-length">define RUN_BITS (8 - ML_BITS) /* Token: 4-high-bits, literal length */</h2> 
<h2 id="define-runmask-1u-runbits-1">define RUN_MASK ((1U &lt;&lt; RUN_BITS) - 1)</h2> 
<h2 id="define-maxdlog-16-滑动窗口的位数">define MAXD_LOG 16 /* 滑动窗口的位数 */</h2> 
<h2 id="define-maxdistance-1-maxdlog-1-滑动窗口的最大值">define MAX_DISTANCE ((1 &lt;&lt; MAXD_LOG) - 1) /* 滑动窗口的最大值 */</h2> 
<p>实现</p> 
<p>(3) 流操作 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> typedef struct { <br> U32 hashTable[HASHNBCELLS4]; /* 哈希表 */ <br> const BYTE <em>bufferStart; /</em> 类似于前向缓存 */ <br> const BYTE <em>base; /</em> 哈希表中采用的基准地址srcBase */ <br> const BYTE <em>nextBlock; /</em> 下一个块的地址 */ <br> } LZ4_Data_Structure; <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> FORCE_INLINE void LZ4_init(LZ4_Data_Structure *lz4ds, const BYTE *base) <br> { <br> MEM_INIT(lz4ds-&gt;hashTable, 0, sizeof(lz4ds-&gt;hashTable)); <br> lz4ds-&gt;bufferStart = base; <br> lz4ds-&gt;base = base; <br> lz4ds-&gt;nextBlock = base; <br> } <br> 创建和初始化LZ4_Data_Structure实例。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> void *LZ4_create(const char *inputBuffer) <br> { <br> void *lz4ds = ALLOCATOR(1, sizeof(LZ4_Data_Structure)); <br> LZ4_init((LZ4_Data_Structure <em>)lz4ds, (const BYTE </em>)inputBuffer); <br> return lz4ds; <br> } <br> 释放LZ4_Data_Structure实例。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> int LZ4_free(void *LZ4_Data) <br> { <br> FREEMEM(LZ4_Data); <br> return 0; <br> } <br> 当输入缓存不够的时候，进行调整。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> char *LZ4_slideInputBuffer(void *LZ4_Data) <br> { <br> LZ4_Data_Structure <em>lz4ds = (LZ4_Data_Structure </em>) LZ4_Data; <br> size_t delta = lz4ds-&gt;nextBlock - (lz4ds-&gt;bufferStart + 64KB); /* 调整后地址的偏移 */ </p> 
<pre><code>if ((lz4ds-&gt;base - delta &gt; lz4ds-&gt;base) ||                  /* underflow control */  
     (size_t) (lz4ds-&gt;nextBlock - (lz4ds-&gt;base) &gt; 0xE0000000)) /* close to 32-bit limit */  
{  
    size_t deltaLimit = (lz4ds-&gt;nextBlock - 64KB) - lz4ds-&gt;base;  
    int nH;  
    for (nH = 0; nH &lt; HASHNBCELLS4; nH++) {  
        if ((size_t) (lz4ds-&gt;hashTable[nH]) &lt; deltaLimit) lz4ds-&gt;hashTable[nH] = 0;  
        else lz4ds-&gt;hashTable[nH] -= (U32) deltaLimit;  
    }  

    memcpy((void *)(lz4ds-&gt;bufferStart), (const void *)(lz4ds-&gt;nextBlock - 64KB), 64KB);  
    lz4ds-&gt;base = lz4ds-&gt;bufferStart;  
    lz4ds-&gt;nextBlock = lz4ds-&gt;base + 64KB;  

} else {  
    /* 把下个块之前的64KB数据拷贝到buffer的头部 */  
    memcpy((void *)(lz4ds-&gt;bufferStart), (const void *)(lz4ds-&gt;nextBlock - 64KB), 64KB);  
    lz4ds-&gt;nextBlock -= delta; /* 更新下个块的地址 */  
    /* 哈希表中的value为偏移值offset。 
     * pos = base + offset，现在offset -= delta，但是我们又不想去更新offset (更新哈希表)。 
     * 可以让base -= delta，这样可以不改变offset而取得正确的pos。 
     * pos是真实的地址。 
     */  
    lz4ds-&gt;base -= delta;   
}  

return (char *) (lz4ds-&gt;nextBlock);  
</code></pre> 
<p>} </p> 
<p>(4) 解压 <br> LZ4_decompress_generic()是通用的解压算法，只要符合压缩格式就可以解压，无需考虑匹配算法。 <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> typedef enum { endOnOutputSize = 0, endOnInputSize = 1 } endCondition_directive; <br> typedef enum { full = 0, partial = 1 } earlyEnd_directive; </p> 
<p>If endOnInput == endOnInputSize, outputSize is the max size of Output Buffer. <br> targetOutputSize only used if partialDecoding == partial. <br> [java] view plaincopy在CODE上查看代码片派生到我的代码片 <br> FORCE_INLINE int LZ4_decompress_generic( const char *source, char *dest, int inputSize, <br> int outputSize, int endOnInput, int prefix64k, int partialDecoding, int targetOutputSize) <br> { <br> /* Local variables */ <br> const BYTE <em>restrict ip = (const BYTE </em>) source; <br> const BYTE *ref; <br> const BYTE *const iend = ip + inputSize; </p> 
<pre><code>BYTE *op = (BYTE *) dest;  
BYTE *const oend = op + outputSize;  
BYTE *cpy;  
BYTE *oexit = op + targetOutputSize;  

/* static reduces speed for LZ4_compress_safe() on GCC64. */  
const size_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};  
static const size_t dec64table[] = {0, 0, 0, (size_t) - 1, 0, 1, 2, 3};  

/* Special cases */  
/* targetOutputSize too high =&gt; decode everything */  
if ((partialDecoding) &amp;&amp; (oexit &gt; oend - MFLIMIT)) oexit = oend - MFLIMIT;  
/* Empty output buffer */  
if ((endOnInput) &amp;&amp; unlikey(outputSize == 0)) return ((inputSize == 1) &amp;&amp; (*ip == 0)) ? 0 : -1;  
if ((! endOnInput) &amp;&amp; unlikely(outputSize == 0)) return (*ip == 0 ? 1 : -1);  

/* Main loop，每次循环解压一个序列 */  
while(1) {  
    unsigned token;  
    size_t length;  

    /* get runlength，获取literal length */  
    token = *ip++;  

    if ((length = (token &gt;&gt; ML_BITS)) == RUN_MASK) {  
        unsigned s = 255;  
        while (((endOnInput) ? ip &lt; iend : 1) &amp;&amp; (s == 255)) {  
            s = *ip++;  
            length += s;  
        }  
    }  

    /* copy literals */  
    cpy = op + length;  

    if (((endOnInput) &amp;&amp; ((cpy &gt; (partialDecoding ? oexit : oend - MFLIMIT)) ||   
        (ip + length &gt; iend - (2+1+LASTLITERALS))))  
        || ((! endOnInput) &amp;&amp; (cpy &gt; oend - COPYLENGTH)))  
    {  
        if (partialDecoding) {  
            if (cpy &gt; oend) goto _output_error; /* write attempt beyond end of output buffer */  
            if ((endOnInput) &amp;&amp; (ip + length &gt; iend)) goto _out_error; /* read attempt beyond end of input buffer */  

        } else {  
            if ((! endOnInput) &amp;&amp; (cpy != oend)) goto _output_error; /* block decoding must stop exactly there */  
            if ((endOnInput) &amp;&amp; ((ip + length != iend) || (cpy &gt; oend))) goto _output_error; /* input must be consumed */  
        }  

        memcpy(op, ip, length);  
        ip += length;  
        op += length;  
        break; /* 注意，这里是退出口 */  
    }  
    LZ4_WILDCOPY(op, ip, cpy); ip -= (op - cpy); op = cpy; /* 拷贝literals */  

    /* get offset，获取偏移值 */  
    LZ4_READ_LITTLEENDIAN_16(ref, cpy, ip); ip += 2;  

    /* offset outside destination buffer */  
    if ((prefix64k == noPrefix) &amp;&amp; unlikely(ref &lt; (BYTE *const) dest)) goto _output_error;  

    /* get matchlength，获取match length */  
    if ((length = (token &amp; ML_MASK)) == ML_MASK) {  
        /* Ensure enough bytes remain for LASTLITERALS + token */  
        while((! endOnInput) || (ip &lt; iend - (LASTLITERALS + 1))) {  
            unsigned s = *ip++;  
            length += s;  
            if (s == 255) continue;  
            break;  
        }  
    }  

    /* copy repeated sequence，拷贝匹配match */  
    if unlikely((op - ref) &lt; (int) STEPSIZE)  { /* 匹配和自身重叠的情况，拷贝STEPSIZE大小 */  
        const size_t dec64 = dec64table[(sizeof(void *) == 4 ? 0 : op - ref];  
        op[0] = ref[0]; op[1] = ref[1]; op[2] = ref[2]; op[3] = ref[3];  
        op += 4; ref += 4;  
        ref -= dec32table[op - ref];  
        A32(op) = A32(ref);  
        op += STEPSIZE - 4; ref -= dec64;  
    } else  
        LZ4_COPYSTEP(op, ref);  

    cpy = op + length - STEPSIZE + 4; /* match length + 4才是实际match大小*/   

    if unlikely(cpy &gt; oend - COPYLENGTH - (STEPSIZE - 4)) {  
        if (cpy &gt; oend - LASTLITERALS) goto _output_error; /* last 5 bytes must be literals */  
        LZ4_SECURECOPY(op, ref, (oend - COPYLENGTH));  
        while(op &lt; cpy) *op++ = *ref++;  
        op = cpy;  
        continue;  
    }  

    LZ4_WILDCOPY(op, ref, cpy);  
    op = cpy; /* correction */  
}  

/* end of decoding */  
if (endOnInput)  
    return (int) (((char *)op) - dest); /* Nb of output bytes decoded，解压得到了多少字符 */  
else  
    return (int) (((char *)op) - source); /* Nb of input bytes read，读了多少个压缩字符 */  
</code></pre> 
<p>/* Overflow error detected */ <br> _output_error: <br> return (int) (-(((char <em>) ip) - source)) - 1; /</em> 负号表示出错，值表示Nb of input bytes read */ <br> } </p> 
<p>符合以下任一条件退出： <br> 1. endOnInputSize <br> 1.1 partial、cpy &gt; oexit。出错情况：cpy &gt; oend，或ip + length &gt; iend。 <br> 1.2 full、cpy &gt; oend - 12、ip + length == iend。出错情况：ip + length != iend，或cpy &gt; oend。 <br> 1.3 ip + length &gt; iend - 2 - (1 + 5) <br> 1.3.1 partial。出错情况：cpy &gt; oend，或ip + length &gt; iend。 <br> 1.3.2 full、ip + length == iend。出错情况：ip + length != iend，或cpy &gt; oend。 <br> 2. endOnOutputSize <br> 2.1 cpy &gt; oend - 8。 <br> 2.1.1 partial。出错情况：cpy &gt; oend。 <br> 2.1.2 full、cpy == oend。出错情况：cpy != oend。</p> 
<p>LZ4使用</p> 
<p>make / make clean <br> 得到可执行程序：lz4、lz4c</p> 
<p>Usage: <br> ./lz4 [arg] [input] [output] <br> input : a filename <br> Arguments : <br> -1 : Fast compression (default) <br> -9: High compression <br> -d : decompression (default for .lz4 extension) <br> -z : force compression <br> -f : overwrite output without prompting <br> -h/-H : display help/long help and exit</p> 
<p>LZ4的输入只能为文件，不能为文件夹，毕竟一般压缩工具都不提供tar功能的。 <br> -b file1 [file2] 可以用来测量压缩和解压速度。 <br> 比较遗憾的是，没有看可以指定线程数的参数，所以接下来没有测试多线程环境下的效果。</p> 
<p>LZ4测试</p> 
<p>Xeon E5504 @ 2.00GHz，X84_64，8核CPU，只用了一个。</p> 
<p>(1) 速度</p> 
<p>可以看到压缩速度和解压速度都很快，而且对日志文件的压缩比相当高。</p> 
<p>(2) 压缩比 <br> 原始文件为linux-3.6.10.tar，大小为467MB。 <br> 用gzip压缩后为linux-3.6.10.tar.gz，大小为101MB，压缩比为21.62%。 <br> 用bzip2压缩后为linux-3.6.10.tar.bz2，大小为79MB，压缩比为16.91%。 <br> 用lz4压缩后为linux-3.6.10.tar.lz4，大小为166MB，压缩比为35.38%。 <br> 用lz4_HC压缩后为linux-3.6.10.tar.lz4，大小为117MB，压缩比为25.03%。</p> 
<p>可以看到在压缩比上：lz4 &lt; lz4_HC &lt; gzip &lt; bzip2。 <br> 然而在压缩过程中，笔者可以感觉到lz4的压缩时间比其它的要少一个数量级，几乎是瞬间完成：） <br> 所以LZ4的优势在于压缩和解压速度，而不是压缩比。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e599162645ed43dc92114880e90d79b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【LIS】【严格递增和非严格递增】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2adc2c13e024790504c00e323a925d00/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CPN神经网络学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>