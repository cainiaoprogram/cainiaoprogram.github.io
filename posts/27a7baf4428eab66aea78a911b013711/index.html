<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java公共私人4属性,关于java：Getter / Setter与公共列表的私人列表 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java公共私人4属性,关于java：Getter / Setter与公共列表的私人列表" />
<meta property="og:description" content="将类中的全局列表设为私有并使用getter和setter方法会更好吗？或者将它公开更好吗？ Java中的标准是什么？
我被教导要将变量设为私有，并且只使用getter和setter方法，但访问公共列表肯定比私有列表更好。
public exampleclassThatContainsTheList.goodieList.add(&#34;Candy&#34;);
private exampleclassThatContainsTheList.setGoodieList(exampleclassThatContainsTheList.getGoodieList().add(&#34;Candy&#34;));
这是我的看法，但当然我更倾向于遵循标准，而不是通过看起来不错的东西。
它是使用私有实例成员以及公共getter / setter的好方法，以避免对变量状态进行不必要的修改。这里setter方法用作安全防护。它提供单点联系。阅读有关封装的更多信息
为什么不使用方法add()来获取对象&#34;Candy&#34;并将其添加到列表中？ classThatContainsTheList.add(&#34;Candy&#34;);？
虽然不是一成不变的，但得墨忒耳法在这些情况下提供了一些很好的建议。
@AntonH如果我这样做了，我不会被要求添加与集合相关的所有其他方法吗？不是必需的，但如果我打算使用它们，我也可以。
这称为封装。好处很多，但通常属于抽象的范畴。您可以在不破坏依赖类的情况下更改get方法的功能。您无法通过直接成员访问来执行此操作。
@dalawh您可以添加提供所需功能的方法。如果您只需要添加和删除，只需要有方法来执行这些操作。这些方法将以经典方式作用于列表。我不是说它是最好的方式，但可以考虑。
@MarkPeters如果我为私有列表提供getter和setter方法，它最终会是一样的吗？
@dalawh：仅实现客户端需要的优点是您可以在以后更改底层实现细节。例如，如果要将其更改为Set而不是List，则可以执行此操作。但是如果你公开列表并且客户开始依赖，比方说，getGoodieList().get(2)，你就无法做到这一点。
@BoristheSpider我知道这一点，但我不打算在功能上增加额外功能。回到你的陈述;你推荐我私有吗？
@AntonH明白了。
@MarkPeters明白了。
首先，你不应该直接使用public字段，除非它们是常量(static final)字段并确保它们的状态不会改变。应该使用Encapsulation公开它们，以避免类的客户端修改状态。这是一个通过以防御方式实现getter / setter编写自己的框架的示例，以便不改变List的当前状态：
public class Foo {
private List stringList;
public Foo() {
//always initialized, never null
this.stringList = new ArrayList&lt;&gt;();
}
public List getStringList() {
//defensive implementation
//do not let clients to alter the state of the list
//for example, avoiding clear the list through getStringList()." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/27a7baf4428eab66aea78a911b013711/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-12T07:06:05+08:00" />
<meta property="article:modified_time" content="2021-03-12T07:06:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java公共私人4属性,关于java：Getter / Setter与公共列表的私人列表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>将类中的全局列表设为私有并使用getter和setter方法会更好吗？或者将它公开更好吗？ Java中的标准是什么？</p> 
 <p>我被教导要将变量设为私有，并且只使用getter和setter方法，但访问公共列表肯定比私有列表更好。</p> 
 <p>public exampleclassThatContainsTheList.goodieList.add("Candy");</p> 
 <p>private exampleclassThatContainsTheList.setGoodieList(exampleclassThatContainsTheList.getGoodieList().add("Candy"));</p> 
 <p>这是我的看法，但当然我更倾向于遵循标准，而不是通过看起来不错的东西。</p> 
 <p>它是使用私有实例成员以及公共getter / setter的好方法，以避免对变量状态进行不必要的修改。这里setter方法用作安全防护。它提供单点联系。阅读有关封装的更多信息</p> 
 <p>为什么不使用方法add()来获取对象"Candy"并将其添加到列表中？ classThatContainsTheList.add("Candy");？</p> 
 <p>虽然不是一成不变的，但得墨忒耳法在这些情况下提供了一些很好的建议。</p> 
 <p>@AntonH如果我这样做了，我不会被要求添加与集合相关的所有其他方法吗？不是必需的，但如果我打算使用它们，我也可以。</p> 
 <p>这称为封装。好处很多，但通常属于抽象的范畴。您可以在不破坏依赖类的情况下更改get方法的功能。您无法通过直接成员访问来执行此操作。</p> 
 <p>@dalawh您可以添加提供所需功能的方法。如果您只需要添加和删除，只需要有方法来执行这些操作。这些方法将以经典方式作用于列表。我不是说它是最好的方式，但可以考虑。</p> 
 <p>@MarkPeters如果我为私有列表提供getter和setter方法，它最终会是一样的吗？</p> 
 <p>@dalawh：仅实现客户端需要的优点是您可以在以后更改底层实现细节。例如，如果要将其更改为Set而不是List，则可以执行此操作。但是如果你公开列表并且客户开始依赖，比方说，getGoodieList().get(2)，你就无法做到这一点。</p> 
 <p>@BoristheSpider我知道这一点，但我不打算在功能上增加额外功能。回到你的陈述;你推荐我私有吗？</p> 
 <p>@AntonH明白了。</p> 
 <p>@MarkPeters明白了。</p> 
 <p>首先，你不应该直接使用public字段，除非它们是常量(static final)字段并确保它们的状态不会改变。应该使用Encapsulation公开它们，以避免类的客户端修改状态。这是一个通过以防御方式实现getter / setter编写自己的框架的示例，以便不改变List的当前状态：</p> 
 <p>public class Foo {<!-- --></p> 
 <p>private List stringList;</p> 
 <p>public Foo() {<!-- --></p> 
 <p>//always initialized, never null</p> 
 <p>this.stringList = new ArrayList&lt;&gt;();</p> 
 <p>}</p> 
 <p>public List getStringList() {<!-- --></p> 
 <p>//defensive implementation</p> 
 <p>//do not let clients to alter the state of the list</p> 
 <p>//for example, avoiding clear the list through getStringList().clear()</p> 
 <p>return new ArrayList(stringList);</p> 
 <p>}</p> 
 <p>public void setStringList(List stringList) {<!-- --></p> 
 <p>//defensive implementation</p> 
 <p>//do not let clients to pass a null parameter</p> 
 <p>this.stringList = (stringList == null) ? new ArrayList&lt;&gt;() : new ArrayList&lt;&gt;(stringList);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>除此之外，JavaBean规范声明Java类中的字段不应该是public，并且它们的访问应该通过getter和setter方法。</p> 
 <p>7 Properties</p> 
 <p>Properties are discrete, named attributes of a Java Bean that can affect its appearance or its behavior. For example, a GUI button might have a property named"Label" that represents the text displayed in the button.</p> 
 <p>Properties show up in a number of ways:</p> 
 <p>Properties may be exposed in scripting environments as though they were fields of</p> 
 <p>objects. So in a Javascript environment I might do"b.Label = foo" to set the value of a</p> 
 <p>property.</p> 
 <p>Properties can be accessed programmatically by other components calling their getter</p> 
 <p>and setter methods (see Section 7.1 below).</p> 
 <p>(...)</p> 
 <p>7.1 Accessor methods</p> 
 <p>Properties are always accessed via method calls on their owning object. For readable properties there will be a getter method to read the property value. For writable properties there will be a setter method to allow the property value to be updated.</p> 
 <p>有些框架遵循这些规范，以允许通过反射注入/检索类字段的值。例如，Spring和JSF。</p> 
 <p>通过XML配置的Spring示例：</p> 
 <p>Hello</p> 
 <p>World</p> 
 <p>以及相关的Java类：</p> 
 <p>package my.package;</p> 
 <p>public class Foo {<!-- --></p> 
 <p>private List stringList;</p> 
 <p>public String getStringList() {<!-- --></p> 
 <p>return this.stringList;</p> 
 <p>}</p> 
 <p>//allows Spring to set the value of stringList through reflection</p> 
 <p>public void setStringList(List stringList) {<!-- --></p> 
 <p>this.stringList = stringList;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>使用表达式语言进行字段绑定的JSF示例：</p> 
 <p>#{value}</p> 
 <p>以及相关的Java类：</p> 
 <p>package my.package;</p> 
 <p>@ManagedBean</p> 
 <p>@ViewScoped</p> 
 <p>public class Foo {<!-- --></p> 
 <p>private List stringList;</p> 
 <p>@PostConstruct</p> 
 <p>public void init() {<!-- --></p> 
 <p>stringList = new List&lt;&gt;();</p> 
 <p>stringList.add("Hello");</p> 
 <p>stringList.add("world");</p> 
 <p>}</p> 
 <p>public String getStringList() {<!-- --></p> 
 <p>return this.stringList;</p> 
 <p>}</p> 
 <p>public void setStringList(List stringList) {<!-- --></p> 
 <p>this.stringList = stringList;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>使用哪个选项：防御性getter / setter或常见的getter / setter？这取决于你在做什么。</p> 
 <p>这个答案非常清楚，代码示例说明并解释了需要完美完成的工作。 谢谢。</p> 
 <p>标准是拥有私有实例变量和公共getter / setter方法(就像你被教导的那样)。您总是希望封装或"隐藏"数据，这是OOP的基本概念之一。这个(以及其他)的主要好处之一是修改我们实现的代码，而不会破坏可能使用相同代码的其他开发人员的代码。这种方法还将增加可维护性。</p> 
 <p>最好在类中创建一个私有List并使用getter和setter方法</p> 
 <p>使用getter / setter有一些优点</p> 
 <p>getter和setter可以在其中进行验证，字段不能</p> 
 <p>使用getter，您可以获得所需类的子类。</p> 
 <p>getter和setter是多态的，字段不是</p> 
 <p>调试可以简单得多，因为可以放置断点</p> 
 <p>在一个方法中，不在该给定字段的许多引用附近。</p> 
 <p>他们可以隐藏实施变更</p> 
 <p>要了解更多详细信息，请访问以下链接</p> 
 <p>set和get方法与public变量的优点</p> 
 <p>为什么要使用getter和setter？</p> 
 <p>：</p> 
 <p>我会更进一步：</p> 
 <p>为什么有人知道你如何存储你的数据？信息隐藏是关键字。在您的示例中，有关数据类型泄漏到外部的详细信息。关键字列表泄漏了有关实现的详细信息，即1)不必要的信息 - 您甚至可以将其命名为treasurechest 2)您的类的可能用户是否对实现做出假设，这是一件坏事。给你的类一个类似于好东西的域名，并命名像put / pull这样的方法。如果你想添加多个元素，我会使用更通用的接口，如Iterable。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cadf553f95b92503743cea743ace8f0a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">笔记本电脑升级内存指南（如何选择内存条）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e3f710be4e24047d93a044b52d738bc0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot 中LocalDateTime日期格式化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>