<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法复杂度代码示例 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法复杂度代码示例" />
<meta property="og:description" content="一、算法复杂度及代码运行步骤
确定决定算法运行时间的组成步骤。找到执行该步骤的代码，标记为 1。查看标记为 1 的代码的下一行代码。如果下一行代码是一个循环，则将标记 1 修改为 1 倍于循环的次数 1 * n。如果包含多个嵌套的循环，则将继续计算倍数，例如 1 * n * m。找到标记到的最大的值，就是运行时间的最大值，即算法复杂度描述的上界。 二、代码示例
1. 代码(1)
decimal Factorial(int n) { if (n == 0) return 1; else return n * Factorial(n - 1); } 阶乘（factorial），给定规模 n，算法基本步骤执行的数量为 n，所以算法复杂度为 O(n)。
2. 代码(2)
int FindMaxElement(int[] array) { int max = array[0]; for (int i = 0; i &lt; array.Length; i&#43;&#43;) { if (array[i] &gt; max) { max = array[i]; } } return max; } 这里，n 为数组 array 的大小，则最坏情况下需要比较 n 次以得到最大值，所以算法复杂度为 O(n)。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/634986f33269f0ee4cbaea2023a7335b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-31T21:08:25+08:00" />
<meta property="article:modified_time" content="2023-12-31T21:08:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法复杂度代码示例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>一、算法复杂度及代码运行步骤</strong></p> 
<ol><li>确定决定算法运行时间的组成步骤。</li><li>找到执行该步骤的代码，标记为 1。</li><li>查看标记为 1 的代码的下一行代码。如果下一行代码是一个循环，则将标记 1 修改为 1 倍于循环的次数 1 * n。如果包含多个嵌套的循环，则将继续计算倍数，例如 1 * n * m。</li><li>找到标记到的最大的值，就是运行时间的最大值，即算法复杂度描述的上界。</li></ol> 
<p><strong>二、代码示例</strong></p> 
<p>1. 代码(1)</p> 
<pre><code class="language-cpp">decimal Factorial(int n)
    {
      if (n == 0)
        return 1;
      else
        return n * Factorial(n - 1);
    }</code></pre> 
<p>         阶乘（factorial），给定规模 n，算法基本步骤执行的数量为 n，所以算法复杂度为 O(n)。</p> 
<p>2. 代码(2)</p> 
<pre><code class="language-cpp">int FindMaxElement(int[] array)
    {
      int max = array[0];
      for (int i = 0; i &lt; array.Length; i++)
      {
        if (array[i] &gt; max)
        {
          max = array[i];
        }
      }
      return max;
    }</code></pre> 
<p>         这里，n 为数组 array 的大小，则最坏情况下需要比较 n 次以得到最大值，所以算法复杂度为 O(n)。</p> 
<p>3. 代码(3)</p> 
<pre><code class="language-cpp">long FindInversions(int[] array)
    {
      long inversions = 0;
      for (int i = 0; i &lt; array.Length; i++)
        for (int j = i + 1; j &lt; array.Length; j++)
          if (array[i] &gt; array[j])
            inversions++;
      return inversions;
    }</code></pre> 
<p>         这里，n 为数组 array 的大小，则基本步骤的执行数量约为 n*(n-1)/2，所以算法复杂度为 O(n2)。</p> 
<p>4.代码(4)</p> 
<pre><code class="language-cpp">long SumMN(int n, int m)
    {
      long sum = 0;
      for (int x = 0; x &lt; n; x++)
        for (int y = 0; y &lt; m; y++)
          sum += x * y;
      return sum;
    }</code></pre> 
<p>         给定规模 n 和 m，则基本步骤的执行数量为 n*m，所以算法复杂度为 O(n2)。</p> 
<p>5.代码(5)</p> 
<pre><code class="language-cpp">decimal Sum3(int n)
    {
      decimal sum = 0;
      for (int a = 0; a &lt; n; a++)
        for (int b = 0; b &lt; n; b++)
          for (int c = 0; c &lt; n; c++)
            sum += a * b * c;
      return sum;
    }</code></pre> 
<p>         这里，给定规模 n，则基本步骤的执行数量约为 n*n*n ，所以算法复杂度为 O(n3)。</p> 
<p>6.代码(6)</p> 
<pre><code class="language-cpp">decimal Calculation(int n)
    {
      decimal result = 0;
      for (int i = 0; i &lt; (1 &lt;&lt; n); i++)
        result += i;
      return result;
    }</code></pre> 
<p>         这里，给定规模 n，则基本步骤的执行数量为 2n，所以算法复杂度为 O(2n)。</p> 
<p>7.代码(7)</p> 
<p>斐波那契数列：</p> 
<ul><li>Fib(0) = 0</li><li>Fib(1) = 1</li><li>Fib(n) = Fib(n-1) + Fib(n-2)</li></ul> 
<p>F() = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ...</p> 
<pre><code class="language-cpp">int Fibonacci(int n)
    {
      if (n &lt;= 1)
        return n;
      else
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    }</code></pre> 
<p>        这里，给定规模 n，计算 Fib(n) 所需的时间为计算 Fib(n-1) 的时间和计算 Fib(n-2) 的时间的和。</p> 
<p>T(n&lt;=1) = O(1)</p> 
<p>T(n) = T(n-1) + T(n-2) + O(1)</p> 
<pre><code class="language-cpp">            fib(5)   
                 /             \     
           fib(4)                fib(3)   
         /      \                /     \
     fib(3)      fib(2)         fib(2)    fib(1)
    /     \        /    \       /    \  </code></pre> 
<p>        通过使用递归树的结构描述可知算法复杂度为 O(2n)。</p> 
<p>8.代码(8)</p> 
<pre><code class="language-cpp">int Fibonacci(int n)
    {
      if (n &lt;= 1)
        return n;
      else
      {
        int[] f = new int[n + 1];
        f[0] = 0;
        f[1] = 1;

        for (int i = 2; i &lt;= n; i++)
        {
          f[i] = f[i - 1] + f[i - 2];
        }

        return f[n];
      }
    }</code></pre> 
<p>        同样是斐波那契数列，我们使用数组 f 来存储计算结果，这样算法复杂度优化为 O(n)。</p> 
<p> 9.代码(9)</p> 
<pre><code class="language-cpp">int Fibonacci(int n)
    {
      if (n &lt;= 1)
        return n;
      else
      {
        int iter1 = 0;
        int iter2 = 1;
        int f = 0;

        for (int i = 2; i &lt;= n; i++)
        {
          f = iter1 + iter2;
          iter1 = iter2;
          iter2 = f;
        }

        return f;
      }
    }</code></pre> 
<p>        同样是斐波那契数列，由于实际只有前两个计算结果有用，我们可以使用中间变量来存储，这样就不用创建数组以节省空间。同样算法复杂度优化为 O(n)。</p> 
<p>  10.代码(10)</p> 
<p>        通过使用矩阵乘方的算法来优化斐波那契数列算法。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int fibonacci(int n) {
    int fib[n+1];
    fib[0] = 0;
    fib[1] = 1;
    for (int i = 2; i &lt;= n; i++) {
        fib[i] = fib[i-1] + fib[i-2];
    }
    return fib[n];
}

int main() {
    int n = 10;
    cout &lt;&lt; "Fibonacci number at position " &lt;&lt; n &lt;&lt; " is: " &lt;&lt; fibonacci(n) &lt;&lt; endl;
    return 0;
}
</code></pre> 
<p>  11.代码(11)</p> 
<p>        插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的有序数据。算法适用于少量数据的排序，时间复杂度为 O(n2)。</p> 
<pre><code class="language-cpp">void insertionSort(int arr[], int n) {
    for (int i = 1; i &lt; n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/694b8b71fe72db555cdbe0e99b17e85a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">轻量封装WebGPU渲染系统示例＜55＞- 顶点数据更新</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/56acbf8451e6af25c610d0a3b9e045b6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">A. Odd One Out</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>