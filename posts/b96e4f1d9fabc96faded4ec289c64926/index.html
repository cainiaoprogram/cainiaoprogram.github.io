<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mysql锁详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mysql锁详解" />
<meta property="og:description" content="01 | Mysql事物 1.1 ACID 1、 原子性（Atomicity） ：事务是一个原子操作单元，对数据的修改，要么全都执行，要么全都不执行。2、 一致性（Consistency） ：指的是事务开始之前和事务结束之后，数据库的完整性限制未被破坏。一致性包括两方面的内容，分别是约束一致性和数据一致性。3、 隔离性（Isolation） ：指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。4、持久性（Durability） ：指的是一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，后续的操作或故障不应该对其有任何影响，不会丢失。 1.2 MVCC（Multi Version Concurrency Control） MVCC：多版本并发控制，是指在数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。MVCC使用的是Copy on Write的思想，支持读读、读写、写读的并行处理。
实现原理 MVCC最大的好处是读不加锁，读写不冲突。在读多写少的系统应用中，读写不冲突是非常重要的，极大的提升系统的并发性能，这也是为什么现阶段几乎所有的关系型数据库都支持 MVCC 的原因，不过目前MVCC只在 Read Commited 和 Repeatable Read 两种隔离级别下工作。
在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。
快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select）当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发修改这条记录。（select… for update 或lock in share mode，insert/delete/update） 1.3 事物隔离级别 事物隔离级别脏读不可重复读幻读读未提交可能发生可能发生可能发生读已提交X可能发生可能发生可重复读XX可能发生串行化XXX 读未提交（Read Uncommitted）：解决了回滚覆盖类型的更新丢失，但可能发生脏读现象，也就是可能读取到其他会话中未提交事务修改的数据。读已提交（Read Committed）（Oracle、SQLServer默认隔离级别） ：只能读取到其他会话中已经提交的数据，解决了脏读。但可能发生不可重复读现象，也就是可能在一个事务中两次查询结果不一致。
可重复度可重复读（Repeatable Read）（mysql默认隔离级别） ：解决了不可重复读，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上会出现幻读，简单的说幻读指的的当用户读取某一范围的数据行时，另一个事务又在该范围插入了新行，当用户在读取该范围的数据时会发现有新的幻影行。
可串行化串行化（Serializable）：所有的增删改查串行执行。它通过强制事务排序，解决相互冲突，从而解决
幻度的问题。这个级别可能导致大量的超时现象的和锁竞争，效率低下。 Mysql隔离级别控制 -- 查看当前隔离级别 show variables like &#39;tx_isolation&#39;; -- 设置隔离级别 set tx_isolation=&#39;READ-UNCOMMITTED&#39;; set tx_isolation=&#39;READ-COMMITTED&#39;; set tx_isolation=&#39;REPEATABLE-READ&#39;; set tx_isolation=&#39;SERIALIZABLE&#39;; 02 | 锁机制 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b96e4f1d9fabc96faded4ec289c64926/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-04T09:20:32+08:00" />
<meta property="article:modified_time" content="2020-08-04T09:20:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mysql锁详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="01__Mysql_1"></a>01 | Mysql事物</h4> 
<h5><a id="11_ACID_2"></a>1.1 ACID</h5> 
<ul><li>1、 <strong>原子性（Atomicity）</strong> ：事务是一个原子操作单元，对数据的修改，要么全都执行，要么全都不执行。</li><li>2、 <strong>一致性（Consistency）</strong> ：指的是事务开始之前和事务结束之后，数据库的完整性限制未被破坏。一致性包括两方面的内容，分别是约束一致性和数据一致性。</li><li>3、 <strong>隔离性（Isolation）</strong> ：指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。</li><li>4、<strong>持久性（Durability）</strong> ：指的是一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，后续的操作或故障不应该对其有任何影响，不会丢失。</li></ul> 
<h5><a id="12_MVCCMulti_Version_Concurrency_Control_8"></a>1.2 MVCC（Multi Version Concurrency Control）</h5> 
<p>MVCC：多版本并发控制，是指在数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。MVCC使用的是Copy on Write的思想，支持读读、读写、写读的并行处理。</p> 
<h6><a id="_11"></a>实现原理</h6> 
<p>MVCC最大的好处是读不加锁，读写不冲突。在读多写少的系统应用中，读写不冲突是非常重要的，极大的提升系统的并发性能，这也是为什么现阶段几乎所有的关系型数据库都支持 MVCC 的原因，不过目前MVCC只在 Read Commited 和 Repeatable Read 两种隔离级别下工作。<br> 在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。</p> 
<ul><li>快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select）</li><li>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发修改这条记录。（select… for update 或lock in share mode，insert/delete/update）</li></ul> 
<h5><a id="13__17"></a>1.3 事物隔离级别</h5> 
<table><thead><tr><th>事物隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>可能发生</td><td>可能发生</td><td>可能发生</td></tr><tr><td>读已提交</td><td>X</td><td>可能发生</td><td>可能发生</td></tr><tr><td>可重复读</td><td>X</td><td>X</td><td>可能发生</td></tr><tr><td>串行化</td><td>X</td><td>X</td><td>X</td></tr></tbody></table> 
<ul><li><strong>读未提交（Read Uncommitted）</strong>：解决了回滚覆盖类型的更新丢失，但可能发生脏读现象，也就是可能读取到其他会话中未提交事务修改的数据。</li><li><strong>读已提交（Read Committed）（Oracle、SQLServer默认隔离级别）</strong> ：只能读取到其他会话中已经提交的数据，解决了脏读。但可能发生不可重复读现象，也就是可能在一个事务中两次查询结果不一致。<br> 可重复度</li><li><strong>可重复读（Repeatable Read）（mysql默认隔离级别）</strong> ：解决了不可重复读，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上会出现幻读，简单的说幻读指的的当用户读取某一范围的数据行时，另一个事务又在该范围插入了新行，当用户在读取该范围的数据时会发现有新的幻影行。<br> 可串行化</li><li><strong>串行化（Serializable）</strong>：所有的增删改查串行执行。它通过强制事务排序，解决相互冲突，从而解决<br> 幻度的问题。这个级别可能导致大量的超时现象的和锁竞争，效率低下。</li></ul> 
<h6><a id="Mysql_33"></a>Mysql隔离级别控制</h6> 
<pre><code class="prism language-sql"><span class="token comment">-- 查看当前隔离级别</span>
<span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'tx_isolation'</span><span class="token punctuation">;</span>
<span class="token comment">-- 设置隔离级别</span>
<span class="token keyword">set</span> tx_isolation<span class="token operator">=</span><span class="token string">'READ-UNCOMMITTED'</span><span class="token punctuation">;</span>
<span class="token keyword">set</span> tx_isolation<span class="token operator">=</span><span class="token string">'READ-COMMITTED'</span><span class="token punctuation">;</span>
<span class="token keyword">set</span> tx_isolation<span class="token operator">=</span><span class="token string">'REPEATABLE-READ'</span><span class="token punctuation">;</span>
<span class="token keyword">set</span> tx_isolation<span class="token operator">=</span><span class="token string">'SERIALIZABLE'</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="02___44"></a>02 | 锁机制</h4> 
<h5><a id="21__45"></a>2.1 锁分类</h5> 
<h6><a id="_46"></a>按操作粒度可分为：</h6> 
<ul><li><strong>表级锁</strong>：每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB 等存储引擎中。</li><li><strong>行级锁</strong>：每次操作锁住一行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB 存储引擎中。</li><li><strong>页级锁</strong>：每次锁定相邻的一组记录，锁定粒度界于表锁和行锁之间，开销和加锁时间界于表锁和行锁之间，并发度一般。应用在BDB 存储引擎中。</li></ul> 
<table><thead><tr><th>存储引擎</th><th>表锁</th><th>页锁</th><th>行锁</th></tr></thead><tbody><tr><td>InnoDB</td><td>支持</td><td>X</td><td>支持</td></tr><tr><td>MyISAM</td><td>支持</td><td>X</td><td>X</td></tr><tr><td>BDB</td><td>支持</td><td>支持</td><td>X</td></tr></tbody></table> 
<h6><a id="_57"></a>按操作类型可分为：</h6> 
<ul><li><strong>读锁</strong>（S锁）：共享锁，针对同一份数据，多个读操作可以同时进行而不会互相影响。</li><li><strong>写锁</strong>（X锁）：排他锁，当前写操作没有完成前，它会阻断其他写锁和读锁。</li></ul> 
<h6><a id="_61"></a>按操作性能可分为：</h6> 
<ul><li><strong>乐观锁</strong>：一般的实现方式是对记录数据版本进行比对，在数据更新提交的时候才会进行冲突检测，如果发现冲突了，则提示错误信息。</li><li><strong>悲观锁</strong>：在对一条数据修改的时候，为了避免同时被其他人修改，在修改数据之前先锁定，再修改的控制方式。共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴。</li></ul> 
<h5><a id="22__65"></a>2.2 行锁原理</h5> 
<p>InnoDB行锁是通过对<strong>索引</strong>数据页上的记录加锁实现的，即使用行锁的前提是建立索引，主要实现算法有以下3种：</p> 
<ul><li><strong>行锁（RecordLock）</strong>：锁定单个行记录的锁，分为读锁和写锁，如下表（RC、RR隔离级别都支持）</li></ul> 
<table><thead><tr><th></th><th>读锁</th><th>写锁</th></tr></thead><tbody><tr><td>读锁</td><td>兼容</td><td>冲突</td></tr><tr><td>写锁</td><td>冲突</td><td>冲突</td></tr></tbody></table> 
<p>注：这里读锁写锁冲突是指当前读锁，而不是MVCC中的快照读锁</p> 
<ul><li> <p><strong>间隙锁（Gap Lock）</strong>：间隙锁，锁定索引记录间隙，确保索引记录的间隙不变，根间隙锁存在冲突关系的是“往这个间隙中插入一个记录”这个操作，换句话说就是间隙锁只会影响<strong>insert</strong>操作而不会影响<strong>update</strong>和<strong>select</strong>操作，间隙锁的引入是为了解决幻读问题，但需要锁住更大的范围，降低了并发读。（注：间隙锁只有在<strong>RR隔离级别</strong>下才会生效，如果把隔离级别设置为读提交，就没有间隙锁了，但同时，可能会出现数据和日志不一致的情况，需要将binlog的格式设置为row）</p> </li><li> <p><strong>Next-key Lock 锁</strong>：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围，next-key lock 是前开后闭区间。（RR隔离级别支持）</p> </li></ul> 
<h6><a id="_79"></a>加锁的基本规则:</h6> 
<ul><li>1、加锁的基本单位是 next-key lock</li><li>2、查找过程中访问到的对象才会加锁</li><li>3、索引上的等值查询，给唯一索引加锁的时候，若记录存在next-key lock 则退化为行锁</li><li>4、索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54b828a1f334d3423417ea1afe97b28c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【信息系统项目管理师】中高项历年真题汇总题目书</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e7aaeba4bd1405f2739b99cc6fe2763/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">elasticsearch  ik分词器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>