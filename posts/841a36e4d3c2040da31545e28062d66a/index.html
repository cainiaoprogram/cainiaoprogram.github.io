<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DP（1） ---  数塔 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DP（1） ---  数塔" />
<meta property="og:description" content="数塔问题
1. 基本模型 （HDU 2084）
如上图所示数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？
数塔思想：自顶向下分析，自底向上计算。
H(i) 表示第i层的最大值。要得到H（i &#43; 1），则考虑上一层结点，到其相邻节点可取得的值，取最大值作为H(i &#43; 1)。
如果按照上述做法，从顶到底算起，则时间复杂度为 O(2^(n – 1))；
考虑从底部算起，计算每个结点到底层的最大值，即上一层结点与其相邻节点的最大值，以这个最大值作为上一层结点的值，重复这一过程，直到塔顶。时间复杂度为O（n）
2. 简单应用
a. 多少条路径 (HDU 2151) 猴子爬树，最初猴子在第一棵树上，每过一分钟，猴子会跳到相邻的树上。现在这里有n棵树，求过了m分钟，有多少种不同的跳法跳到第T棵树。（HDU2151）考虑以下	图形， 是不是很像一个数塔？ b. 多顶点型数塔（例题 HDU 1176） 免费馅饼，有0—10个位置，起始时，人在5处，每一秒都会有几个馅饼落下来，每秒人可以移动到相邻的位置，问最多可以接多少个馅饼？考虑如下算法： dp[i][j] 表示从第i秒起第j个位置可得到的馅饼； pie[i][j] 表示第i秒第j个位置落下的馅饼 从最后一秒算起，dp[i][j] = max（dp[i &#43; 1][j], max（dp[i &#43; 1][j - 1], dp[i &#43; 1][j &#43; 1]））&#43; pie[i][j] 重复这一过程知道t = 0；最后这会形成一个多顶点的数塔，每个位置都是一个顶点。 3. 例题代码 HDU 2084 #include &lt;stdio.h&gt; int tower[100][100]; int main() { int i, j; int T, N; int v1, v2; scanf (&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/841a36e4d3c2040da31545e28062d66a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-10-04T08:04:43+08:00" />
<meta property="article:modified_time" content="2012-10-04T08:04:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DP（1） ---  数塔</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><span style="font-size:24px">数塔问题</span></strong></p> 
<p><span style="font-size:18px">1. 基本模型 （HDU 2084）</span></p> 
<pre>        <img alt="" src="https://images2.imgbox.com/7f/90/nLnPsRAL_o.jpg"></pre> 
<pre> 	<p><span style="font-size:14px"><span style="color:#000000">  如上图所示数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？</span></span></p><p><span style="font-size:14px"><span style="color:#000000">  数塔思想：</span><span style="color:red">自顶向下分析，</span><span style="color:red">自底向上计算</span>。</span></p><p><span style="font-family:Calibri; font-size:14px">      <span style="color:#000000"><span style="font-size:18px">H(i) </span></span></span><span style="font-size:18px; color:#000000">表示第<span style="font-family:Calibri">i</span>层的最大值。要得到<span style="font-family:Calibri">H</span>（<span style="font-family:Calibri">i + 1</span>），则考虑上一层结点，到其相邻节点可取得的值，取最大值作为<span style="font-family:Calibri">H(i + 1)</span>。</span></p><p><span style="font-size:18px"><span style="color:#000000"><span style="font-family:Calibri">     </span>如果按照上述做法，从顶到底算起，则时间复杂度为<span style="font-family:Calibri"> O(2^(n – 1))</span>；</span></span></p><p><span style="color:#000000"><span style="font-size:18px"><span style="font-family:Calibri">     </span>考虑从底部算起，计算每个结点到底层的最大值，即上一层结点与其相邻节点的最大值，以这个最大值作为上一层结点的值，重复这一过程，直到塔顶。时间复杂度为<span style="font-family:Calibri">O</span>（<span style="font-family:Calibri">n）</span></span></span></p></pre> 
<p><span style="font-size:18px">2. 简单应用</span></p> 
<pre><span style="font-size:18px">  a. 多少条路径 (HDU 2151)</span></pre> 
<div align="left"> 
 <pre><span style="font-size:18px"><span style="font-size:14px"><span style="font-size:18px">    </span>猴子爬树，最初猴子在第一棵树上，每过一分钟，猴子会跳到相邻的树上。现在这里有<span style="font-family:Calibri">n</span>棵树，求过了<span style="font-family:Calibri">m</span>分钟，有多少种不同的跳法跳到第<span style="font-family:Calibri">T</span>棵树。（<span style="font-family:Calibri">HDU2151</span>）</span>考虑以下	图形， 是不是很像一个数塔？</span></pre> 
</div> 
<pre><span style="font-size:18px">		<img alt="" src="https://images2.imgbox.com/de/36/tpEKvrfp_o.jpg"></span></pre> 
<pre><span style="font-size:18px">  b. 多顶点型数塔（例题 HDU 1176）</span></pre> 
<div dir="ltr" style="margin-right:0px"> 
 <p dir="ltr" style="margin-right:0px"></p> 
 <pre><span style="font-size:18px">    免费馅饼，有<span style="font-family:Calibri">0</span>—<span style="font-family:Calibri">10</span>个位置，起始时，人在<span style="font-family:Calibri">5</span>处，每一秒都会有几个馅饼落下来，每秒人可以移动到相邻的位置，问最多可以接多少个馅饼？考虑如下算法：</span></pre> 
 <p></p> 
</div> 
<pre><span style="font-size:18px"><span style="font-family:Calibri">          dp[i][j] </span>表示从第<span style="font-family:Calibri">i</span>秒起第<span style="font-family:Calibri">j</span>个位置可得到的馅饼；</span></pre> 
<pre><span style="font-size:18px"><span style="font-family:Calibri">          pie[i][j] </span>表示第<span style="font-family:Calibri">i</span>秒第<span style="font-family:Calibri">j</span>个位置落下的馅饼</span></pre> 
<pre><span style="font-size:18px"><span style="font-family:Calibri">          </span>从最后一秒算起，<span style="font-family:Calibri">dp[i][j] = max</span>（<span style="font-family:Calibri">dp[i + 1][j], max</span>（<span style="font-family:Calibri">dp[i + 1][j - 1],  dp[i + 1][j + 1]</span>））<span style="font-family:Calibri">+ pie[i][j]</span></span></pre> 
<pre><span style="font-size:18px"><span style="font-family:Calibri">          </span>重复这一过程知道<span style="font-family:Calibri">t = 0</span>；最后这会形成一个多顶点的数塔，每个位置都是一个顶点。</span></pre> 
<pre><span style="font-size:18px"></span> </pre> 
<pre><span style="font-size:18px">3. 例题代码</span></pre> 
<pre><span style="font-size:18px">	HDU 2084</span></pre> 
<pre>	</pre> 
<pre><code class="language-cpp"><span style="font-size:14px;">#include &lt;stdio.h&gt;
int tower[100][100];
int main()
{
	int i, j;
	int T, N;
	int v1, v2;
	scanf ("%d", &amp;T);
	while (T --)
	{
		scanf ("%d", &amp;N);
		for (i = 1; i &lt;= N; i ++)
		{
			for (j = 1; j &lt;= i; j ++)
			{
				scanf ("%d", &amp;tower[i][j]);
			}
		}
		for (i = N - 1; i &gt;= 1; i --)   // 自底向上计算每一层的最大值
		{
			for (j = 1; j &lt;= i + 1; j ++)
			{
				v1 = tower[i + 1][j] + tower[i][j];
				v2 = tower[i + 1][j + 1] + tower[i][j];
				tower[i][j] = v1;
				if (v1 &lt; v2)
				{
					tower[i][j] = v2;
				}
			}
		}
		printf ("%d\n", tower[1][1]);
	}
	return 0;
}</span></code></pre> 
<pre>	</pre> 
<pre><span style="font-size:18px">	HDU 2151</span></pre> 
<pre> </pre> 
<pre><code class="language-cpp"><span style="font-size:14px;">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main()
{
	int i, j, k;
	int numbers;
	int N, P, M, T;
	int tree[2][101];
	int times[2][101];
	while (scanf ("%d%d%d%d", &amp;N, &amp;P, &amp;M, &amp;T) == 4)
	{
		memset (times, 0, sizeof (times));
		tree[0][0] = P;
		times[0][P] = 1;
		numbers = 1;
		k = 0;
		while (M --)
		{
			j = 0;
			k %= 2;
			for (i = 0; i &lt; numbers; i ++)
			{
				if (tree[k][i] &gt; 1)
				{
					if (times[k ^ 1][tree[k][i] - 1] == 0)
					{

						tree[k ^ 1][j ++] = tree[k][i] - 1;
					}
					times[k ^ 1][tree[k][i] - 1] += times[k][tree[k][i]];
				}
				if (tree[k][i] &lt; N)
				{
					if (times[k ^ 1][tree[k][i] + 1]== 0)
					{
						tree[k ^ 1][j ++] = tree[k][i] + 1;
					}
					times[k ^ 1][tree[k][i] + 1] += times[k][tree[k][i]];
				}
				times[k][tree[k][i]] = 0;
			}
			numbers = j;
			k ++;
		}
		printf ("%d\n", times[k % 2][T]);
	}
	return  0;
}</span></code></pre> 
<pre>
<span style="font-size:18px">	HDU 1176</span></pre> 
<pre><span style="font-size:18px"></span> </pre> 
<pre><code class="language-cpp"><span style="font-size:14px;">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define MAX 100002
int pie[MAX][13];
int dp[MAX][13];
int max_v (int a, int b);
int main()
{
	int n;
	int i, j;
	int t, x;
	int max_t;
	while (scanf ("%d", &amp;n) == 1 &amp;&amp; n)
	{
		memset (pie, 0, sizeof (pie));
		memset (dp, 0, sizeof (dp));
		max_t = 0;
		for (i = 0; i &lt; n; i ++)
		{
			scanf ("%d%d", &amp;x, &amp;t);
			if (max_t &lt; t)
			{
				max_t = t;
			}
			pie[t][x + 1] ++;
		}
		for (i = max_t; i &gt;= 0; i --)
		{
			for (j = 1; j &lt; 12; j ++)
			{
				dp[i][j] = max_v (dp[i + 1][j - 1], max_v (dp[i + 1][j], dp[i + 1][j + 1])) + pie[i][j];
			}
		}
		printf ("%d\n", dp[0][6]);
	}
	return 0;
}
int max_v (int a, int b)
{
	if (a &gt; b)
	{
		return a;
	}
	return b;
}</span></code></pre> 
<pre>

 </pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e1ffd868752b09cbab18c185df8b7866/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">oracle 创建数据库实例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f08f593469f75961ecfbf1aff99aa1bb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DP --  最大连续子段和</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>