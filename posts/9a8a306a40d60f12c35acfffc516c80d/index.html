<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【VUE3源码学习】nextTick 实现原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【VUE3源码学习】nextTick 实现原理" />
<meta property="og:description" content="什么是nextTick? 定义: 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
看完这个定义不免心生疑问：
下次 DOM 更新循环结束之后是什么时候?执行延迟回调?更新后的 DOM? 基于以上问题和平时的使用经验可以基本解答疑问：
vue 更新DOM的策略是异步更新nextTick 可以接收一个函数做为入参nextTick 后能拿到最新的数据 那么nextTick 是怎么实现的呢？既然是异步更新，这涉及到了 js 的执行机制，下面一起复习一下js执行机制。
JS 执行机制 我们都知道 JS 是单线程语言，即指某一时间内只能干一件事，即为同步。
而JS为什么是单线程的呢？这就要提及JS的主要用途了。JS自诞生之日起，其主要用途是与用户互动和DOM操作，如果同一时间，一个添加了 DOM，一个删除了 DOM, 这个时候语言就不知道是该添还是该删了，所以从应用场景来看 JS 只能是单线程，否则会带来复杂的同步问题。
单线程就意味着所有的任务都需要排队，后面的任务需要等前面的任务执行完才能执行，如果前面的任务耗时过长，后面的任务就需要一直等，一些从用户角度上不需要等待的任务就会一直等待，这个从体验角度上来讲是不可接受的，所以JS中就出现了异步的概念。
概念
同步任务：指排队在主线程上依次执行的任务
异步任务：不进入主线程，而进入任务队列的任务，又分为宏任务和微任务
宏任务： 渲染事件、请求、script、setTimeout、setInterval、Node中的setImmediate 等
微任务： Promise.then、MutationObserver(监听DOM)、Node 中的 Process.nextTick等
执行机制
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
（2）主线程之外，还存在一个&#34;任务队列&#34;（task queue）。只要异步任务有了运行结果，就在&#34;任务队列&#34;之中放置一个事件。
（3）一旦&#34;执行栈&#34;中的所有同步任务执行完毕，系统就会读取&#34;任务队列&#34;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。
只要主线程空了，就会去读取&#34;任务队列&#34;，这就是JavaScript的运行机制。
当执行栈中的同步任务执行完后，就会去任务队列中拿一个宏任务放到执行栈中执行，执行完该宏任务中的所有微任务，再到任务队列中拿宏任务，即一个宏任务、所有微任务、渲染、一个宏任务、所有微任务、渲染…(不是所有微任务之后都会执行渲染)，如此形成循环，即事件循环(EventLoop)。
nextTick 就是创建一个异步任务，那么它自然要等到同步任务执行完成后才执行。
nextTick 用法 先看个例子，点击按钮更新 DOM 内容，并获取最新的 DOM 内容
&lt;template&gt; &lt;div ref=&#34;test&#34;&gt;{{name}}&lt;/div&gt; &lt;el-button @click=&#34;handleClick&#34;&gt;按钮&lt;/el-button&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, nextTick } from &#39;vue&#39; const name = ref(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9a8a306a40d60f12c35acfffc516c80d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-15T16:36:44+08:00" />
<meta property="article:modified_time" content="2022-02-15T16:36:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【VUE3源码学习】nextTick 实现原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="nextTick_1"></a>什么是<code>nextTick</code>?</h3> 
<blockquote> 
 <p>定义: 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p> 
</blockquote> 
<p>看完这个定义不免心生疑问：</p> 
<ul><li>下次 DOM 更新循环结束之后是什么时候?</li><li>执行延迟回调?</li><li>更新后的 DOM?</li></ul> 
<p>基于以上问题和平时的使用经验可以基本解答疑问：</p> 
<ul><li>vue 更新DOM的策略是异步更新</li><li>nextTick 可以接收一个函数做为入参</li><li>nextTick 后能拿到最新的数据</li></ul> 
<p>那么<code>nextTick</code> 是怎么实现的呢？既然是异步更新，这涉及到了 <code>js</code> 的执行机制，下面一起复习一下js执行机制。</p> 
<h3><a id="JS__17"></a>JS 执行机制</h3> 
<p>我们都知道 JS 是单线程语言，即指某一时间内只能干一件事，即为<strong>同步</strong>。</p> 
<p>而JS为什么是单线程的呢？这就要提及JS的主要用途了。JS自诞生之日起，其主要用途是与用户互动和DOM操作，如果同一时间，一个添加了 <code>DOM</code>，一个删除了 <code>DOM</code>, 这个时候语言就不知道是该添还是该删了，所以从应用场景来看 <code>JS</code> 只能是单线程，否则会带来复杂的同步问题。</p> 
<p>单线程就意味着所有的任务都需要排队，后面的任务需要等前面的任务执行完才能执行，如果前面的任务耗时过长，后面的任务就需要一直等，一些从用户角度上不需要等待的任务就会一直等待，这个从体验角度上来讲是不可接受的，所以<code>JS</code>中就出现了异步的概念。</p> 
<p><strong>概念</strong></p> 
<p><code>同步任务</code>：指排队在主线程上依次执行的任务<br> <code>异步任务</code>：不进入主线程，而进入任务队列的任务，又分为宏任务和微任务<br> <code>宏任务</code>： 渲染事件、请求、script、setTimeout、setInterval、Node中的setImmediate 等<br> <code>微任务</code>： Promise.then、MutationObserver(监听DOM)、Node 中的 Process.nextTick等</p> 
<p><strong>执行机制</strong></p> 
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br> （2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。<br> （3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br> （4）主线程不断重复上面的第三步。<br> 只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。</p> 
<p>当执行栈中的同步任务执行完后，就会去任务队列中拿一个宏任务放到执行栈中执行，执行完该宏任务中的所有微任务，再到任务队列中拿宏任务，即一个宏任务、所有微任务、渲染、一个宏任务、所有微任务、渲染…(不是所有微任务之后都会执行渲染)，如此形成循环，即<code>事件循环(EventLoop)</code>。</p> 
<p><code>nextTick</code> 就是创建一个异步任务，那么它自然要等到同步任务执行完成后才执行。</p> 
<h3><a id="nextTick__44"></a>nextTick 用法</h3> 
<p>先看个例子，点击按钮更新 DOM 内容，并获取最新的 DOM 内容</p> 
<pre><code class="prism language-js"> <span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token string">"test"</span><span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>name<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>el<span class="token operator">-</span>button @click<span class="token operator">=</span><span class="token string">"handleClick"</span><span class="token operator">&gt;</span>按钮<span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>button<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
     <span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> ref<span class="token punctuation">,</span> nextTick <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
     <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">"initName"</span><span class="token punctuation">)</span>
     <span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
     <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
         name<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">'newName'</span>
         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>value<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span> <span class="token comment">// initName</span>
         <span class="token keyword">await</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>value<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span> <span class="token comment">// newName</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> name<span class="token punctuation">,</span> test<span class="token punctuation">,</span> handleClick <span class="token punctuation">}</span>
 <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="nextTick__66"></a>nextTick 源码剖析</h3> 
<p><code>nextTick</code>实现完全基于语言执行机制实现，直接创建一个异步任务，那么nextTick自然就达到在同步任务后执行的目的</p> 
<p>源码版本：<code>3.2.22</code>，源码地址：<code>packages/runtime-core/src/sheduler.ts</code></p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> resolvedPromise<span class="token operator">:</span> Promise<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> currentFlushPromise<span class="token operator">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> nextTick<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> fn<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">this</span><span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> p <span class="token operator">=</span> currentFlushPromise <span class="token operator">||</span> resolvedPromise
  <span class="token keyword">return</span> fn <span class="token operator">?</span> p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">?</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">:</span> fn<span class="token punctuation">)</span> <span class="token operator">:</span> p
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看出 <code>nextTick</code> 接受一个函数为参数，同时会创建一个<code>Promise</code>微任务。所以，页面调用 <code>nextTick</code> 的时候，会把的参数 <code>fn</code> 赋值给 <code>p.then(fn)</code>，在队列<code>currentFlushPromise || resolvedPromise</code>的任务完成后，执行<code>fn</code>。</p> 
<p><code>vue3</code>中<code>nextTick</code>的队列由几个方法维护，基本执行顺序是这样的：<code>queueJob</code> -&gt; <code>queueFlush</code> -&gt; <code>flushJobs</code> -&gt; <code>nextTick参数的 fn</code></p> 
<p>先有个印象即可，后面按照执行顺序依次分析。</p> 
<h5><a id="nextTick_86"></a>nextTick调用位置</h5> 
<p>入口函数 <code>queueJob</code> 是在<code>renderer</code>函数中调用：</p> 
<pre><code class="prism language-js"><span class="token comment">// packages/runtime-core/src/renderer.ts - 1555行</span>
<span class="token keyword">function</span> <span class="token function">baseCreateRenderer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> setupRenderEffect<span class="token operator">:</span> <span class="token function-variable function">SetupRenderEffectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> effect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReactiveEffect</span><span class="token punctuation">(</span>
      componentUpdateFn<span class="token punctuation">,</span>
      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">queueJob</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>update<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 当作参数传入</span>
      instance<span class="token punctuation">.</span>scope
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里先看一下<code>ReactiveEffect</code>类的构造函数：</p> 
<pre><code class="prism language-ts"><span class="token comment">// packages/reactivity/src/effect.ts - 53行</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ReactiveEffect<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// ...</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span>
    <span class="token keyword">public</span> <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span>
    <span class="token keyword">public</span> scheduler<span class="token operator">:</span> EffectScheduler <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    scope<span class="token operator">?</span><span class="token operator">:</span> EffectScope <span class="token operator">|</span> <span class="token keyword">null</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">recordEffectScope</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> scope<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
 <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在 <code>ReactiveEffect</code> 这边接收过来的第二个形参就是 <code>scheduler</code>，最终被用到响应式源码的派发更新。</p> 
<p>当响应式对象发生改变后，如果执行 <code>effect</code> 有 <code>scheduler</code> 这个参数，会执行这个 <code>scheduler</code> 函数，并且把 <code>effect</code> 当做参数传入</p> 
<pre><code class="prism language-js"><span class="token comment">// packages/reactivity/src/effect.ts - 330行</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">triggerEffects</span><span class="token punctuation">(</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    effect<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    effect<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后看 <code>queueJob</code>具体做了什么。</p> 
<h5><a id="queueJob_137"></a>queueJob()</h5> 
<p>该方法<strong>负责维护主任务队列</strong>，接受一个函数作为参数，为待入队任务，会将参数 <code>push</code> 到 <code>queue</code> 队列中，有唯一性判断。会在当前宏任务执行结束后，清空队列</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> queue<span class="token operator">:</span> SchedulerJob<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> isFlushing <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 是否正在执行</span>
<span class="token keyword">let</span> isFlushPending <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 是否正在等待执行</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">queueJob</span><span class="token punctuation">(</span><span class="token parameter">job<span class="token operator">:</span> SchedulerJob</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 判断条件：主任务队列为空 或者 有正在执行的任务且没有在主任务队列中  &amp;&amp; job 不能和当前正在执行任务及后面待执行任务相同</span>
  <span class="token comment">// 重复数据删除：</span>
  <span class="token comment">// - 使用Array.includes(Obj, startIndex) 的 起始索引参数：startIndex</span>
  <span class="token comment">// - startIndex默认为包含当前正在运行job的index，此时，它不能再次递归触发自身</span>
  <span class="token comment">// - 如果job是一个watch()回调函数或者当前job允许递归触发，则搜索索引将+1，以允许他递归触发自身-用户需要确保回调函数不会死循环</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span>length <span class="token operator">||</span>
      <span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>
        job<span class="token punctuation">,</span>
        isFlushing <span class="token operator">&amp;&amp;</span> job<span class="token punctuation">.</span>allowRecurse <span class="token operator">?</span> flushIndex <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> flushIndex
      <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    job <span class="token operator">!==</span> currentPreFlushParentJob
  <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 判断当前job id 是否存在 不存在则添加到主任务队列</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>job<span class="token punctuation">.</span>id <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 存在则从当前任务队列中查到位置并删除替换</span>
      queue<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token function">findInsertionIndex</span><span class="token punctuation">(</span>job<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> job<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 创建微任务</span>
    <span class="token function">queueFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="queueFlush_172"></a>queueFlush()</h5> 
<p>该方法<strong>负责尝试创建微任务</strong>，等待任务队列执行</p> 
<pre><code class="prism language-js"><span class="token keyword">let</span> isFlushing <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 是否正在执行</span>
<span class="token keyword">let</span> isFlushPending <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 是否正在等待执行</span>
<span class="token keyword">const</span> resolvedPromise<span class="token operator">:</span> Promise<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 微任务创建器</span>
<span class="token keyword">let</span> currentFlushPromise<span class="token operator">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 当前任务</span>

<span class="token keyword">function</span> <span class="token function">queueFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 当前没有微任务</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isFlushing <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isFlushPending<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 避免在事件循环周期内多次创建新的微任务</span>
    isFlushPending <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment">// 创建微任务，把 flushJobs 推入任务队列等待执行</span>
    currentFlushPromise <span class="token operator">=</span> resolvedPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>flushJobs<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="flushJobs_193"></a>flushJobs()</h5> 
<p>该方法负责处理队列任务，主要逻辑如下：</p> 
<ul><li>先处理前置任务队列</li><li>根据 <code>Id</code> 进行队列排序，并遍历执行队列任务，执行完毕后清空并重置队列</li><li>执行后置队列任务</li><li>如果队列没有被清空会递归调用<code>flushJobs</code>清空队列</li></ul> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">flushJobs</span><span class="token punctuation">(</span><span class="token parameter">seen<span class="token operator">?</span><span class="token operator">:</span> CountMap</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  isFlushPending <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 是否正在等待执行</span>
  isFlushing <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 正在执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    seen <span class="token operator">=</span> seen <span class="token operator">||</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 开发环境下</span>
  <span class="token punctuation">}</span>

  <span class="token function">flushPreFlushCbs</span><span class="token punctuation">(</span>seen<span class="token punctuation">)</span> <span class="token comment">// 执行前置任务队列</span>

  <span class="token comment">// 根据 id 排序队列，这是为了一下两点：</span>
  <span class="token comment">// 1. 组件更新顺序为：父到子，因为父级总是在子级前面先创建，它的渲染效果具有较小的优先级数</span>
  <span class="token comment">// 2. 如果父组件更新期间卸载了子组件，则改子组件更新将跳过</span>
  queue<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getId</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">getId</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>


  <span class="token comment">// checkRecursiveUpdate 的条件使用必须在 try ... catch 块外中确定，因为 Rollup 默认会在 try-catch 中取消优化 treeshaking。</span>
  <span class="token keyword">const</span> check <span class="token operator">=</span> __DEV__
    <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token parameter">job<span class="token operator">:</span> SchedulerJob</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">checkRecursiveUpdates</span><span class="token punctuation">(</span>seen<span class="token operator">!</span><span class="token punctuation">,</span> job<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token constant">NOOP</span>

  <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 遍历主任务队列，批量执行更新任务</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>flushIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> flushIndex <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> flushIndex<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">const</span> job <span class="token operator">=</span> queue<span class="token punctuation">[</span>flushIndex<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">&amp;&amp;</span> job<span class="token punctuation">.</span>active <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__ <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">continue</span>
        <span class="token punctuation">}</span>
        <span class="token function">callWithErrorHandling</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ErrorCodes<span class="token punctuation">.</span><span class="token constant">SCHEDULER</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
    flushIndex <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 队列任务执行完，重置队列索引</span>
    queue<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 清空队列</span>

    <span class="token function">flushPostFlushCbs</span><span class="token punctuation">(</span>seen<span class="token punctuation">)</span> <span class="token comment">// 执行后置队列任务</span>

    isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>  <span class="token comment">// 重置队列执行状态</span>
    currentFlushPromise <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 重置当前微任务为 Null</span>
    <span class="token comment">// some postFlushCb queued jobs!</span>
    <span class="token comment">// keep flushing until it drains.</span>
    <span class="token comment">// 如果主任务队列、前置和后置任务队列还有没被清空，就继续递归执行</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      queue<span class="token punctuation">.</span>length <span class="token operator">||</span>
      pendingPreFlushCbs<span class="token punctuation">.</span>length <span class="token operator">||</span>
      pendingPostFlushCbs<span class="token punctuation">.</span>length
    <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">flushJobs</span><span class="token punctuation">(</span>seen<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="flushPreFlushCbs_254"></a>flushPreFlushCbs()</h5> 
<p>该方法负责执行前置任务队列，说明都写在注释里了</p> 
<ul><li>待处理前置任务队列不为空是，备份并清空前置任务队列</li><li>并遍历执行待处理前置队列任务，执行完毕后当前任务队列</li><li>如果队列没有被清空会递归调用<code>flushJobs</code>清空队列</li></ul> 
<pre><code class="prism language-js"><span class="token keyword">const</span> pendingPreFlushCbs<span class="token operator">:</span> SchedulerJob<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> activePreFlushCbs<span class="token operator">:</span> SchedulerJob<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">let</span> preFlushIndex <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">flushPreFlushCbs</span><span class="token punctuation">(</span>
  <span class="token parameter">seen<span class="token operator">?</span><span class="token operator">:</span> CountMap<span class="token punctuation">,</span>
  parentJob<span class="token operator">:</span> SchedulerJob <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 待处理前置任务队列不为空</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingPreFlushCbs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    currentPreFlushParentJob <span class="token operator">=</span> parentJob
    activePreFlushCbs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>pendingPreFlushCbs<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment">// 待处理前置任务队列去重备份为activePreFlushCbs</span>
    pendingPreFlushCbs<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 待处理前置任务队列重置</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      seen <span class="token operator">=</span> seen <span class="token operator">||</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历执行队列里的任务</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>
      preFlushIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      preFlushIndex <span class="token operator">&lt;</span> activePreFlushCbs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
      preFlushIndex<span class="token operator">++</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>
        __DEV__ <span class="token operator">&amp;&amp;</span>
        <span class="token function">checkRecursiveUpdates</span><span class="token punctuation">(</span>seen<span class="token operator">!</span><span class="token punctuation">,</span> activePreFlushCbs<span class="token punctuation">[</span>preFlushIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">continue</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 任务执行</span>
      activePreFlushCbs<span class="token punctuation">[</span>preFlushIndex<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 清空当前活动的任务队列</span>
    activePreFlushCbs <span class="token operator">=</span> <span class="token keyword">null</span> 
    preFlushIndex <span class="token operator">=</span> <span class="token number">0</span>
    currentPreFlushParentJob <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token comment">// 递归执行，直到清空前置任务队列</span>
    <span class="token function">flushPreFlushCbs</span><span class="token punctuation">(</span>seen<span class="token punctuation">,</span> parentJob<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="flushPostFlushCbs_302"></a>flushPostFlushCbs()</h5> 
<p>该方法负责执行后置任务队列，说明都写在注释里了</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> pendingPostFlushCbs<span class="token operator">:</span> SchedulerJob<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> activePostFlushCbs<span class="token operator">:</span> SchedulerJob<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">let</span> postFlushIndex <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">flushPostFlushCbs</span><span class="token punctuation">(</span><span class="token parameter">seen<span class="token operator">?</span><span class="token operator">:</span> CountMap</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 待处理后置任务队列队列不为空</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingPostFlushCbs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 待处理后置任务队列去重备份为deduped</span>
    <span class="token keyword">const</span> deduped <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>pendingPostFlushCbs<span class="token punctuation">)</span><span class="token punctuation">]</span>
    pendingPostFlushCbs<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 待处理后置任务队列重置</span>

    <span class="token comment">// #1947 already has active queue, nested flushPostFlushCbs call</span>
    <span class="token comment">// 如果当前已经有活动的队列，就添加到执行队列的末尾，并返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>activePostFlushCbs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      activePostFlushCbs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>deduped<span class="token punctuation">)</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 赋值为当前活动队列</span>
    activePostFlushCbs <span class="token operator">=</span> deduped
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      seen <span class="token operator">=</span> seen <span class="token operator">||</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 队列排序</span>
    activePostFlushCbs<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getId</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">getId</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 遍历执行队列里的任务</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>
      postFlushIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      postFlushIndex <span class="token operator">&lt;</span> activePostFlushCbs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
      postFlushIndex<span class="token operator">++</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>
        __DEV__ <span class="token operator">&amp;&amp;</span>
        <span class="token function">checkRecursiveUpdates</span><span class="token punctuation">(</span>seen<span class="token operator">!</span><span class="token punctuation">,</span> activePostFlushCbs<span class="token punctuation">[</span>postFlushIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">continue</span>
      <span class="token punctuation">}</span>
      activePostFlushCbs<span class="token punctuation">[</span>postFlushIndex<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 清空当前活动的任务队列</span>
    activePostFlushCbs <span class="token operator">=</span> <span class="token keyword">null</span>
    postFlushIndex <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>整个 nextTick 的源码到这就解析完啦</p> 
<h3><a id="nextTick_356"></a>为什么要nextTick</h3> 
<p>一个例子让大家明白，如果没有 <code>nextTick</code> 更新机制，那么 <code>num</code> 每次更新值都会触发视图更新，有了<code>nextTick</code>机制，只需要更新一次。</p> 
<pre><code class="prism language-js"><span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>num<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	num <span class="token operator">=</span> i
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_364"></a>总结</h3> 
<p><code>nextTick</code>是 <code>vue</code> 中的更新策略，也是性能优化手段，基于JS执行机制实现</p> 
<p><code>vue</code> 中我们改变数据时不会立即触发视图，如果需要实时获取到最新的<code>DOM</code>，可以手动调用 <code>nextTick</code>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f30a55599ea229a3971f69a4b0ebdfbe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何使用filter过滤器对入参进行处理（完整版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6b9f468a019246cee0aff9b43f1533d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">医疗知识图谱问答系统探究（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>