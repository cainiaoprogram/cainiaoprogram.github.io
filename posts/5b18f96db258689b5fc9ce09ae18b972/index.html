<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据挖掘案例（1）：泰坦尼克号-数据挖掘流程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据挖掘案例（1）：泰坦尼克号-数据挖掘流程" />
<meta property="og:description" content="数据挖掘案例（1）：泰坦尼克号-数据挖掘流程_ZhuNian的学习乐园-CSDN博客
内容分为四个部分：
第一部分：数据读取与展示
第二部分：特征理解分析
第三部分：数据清洗与预处理
第四部分：建立模型
数据和源码 移步到Github ： https://github.com/Stormzudi/Data-Mining-Case
邮箱：442395572@qq.com
目录
前言：
1. 泰坦尼克号-数据挖掘案例解读
2. 数据挖掘流程
3. 挑选兵器
第一部分：数据读取与展示
1. 原始数据展示
第二部分：特征理解分析
1. 数据特征分为：连续值和离散值
1.1 Sex --&gt; 讨论：性别跟获救情况的关系
1.2 Pclass --&gt; 讨论：船舱等级跟获救情况的关系
1.3 Age --&gt; 讨论：连续值特征对结果的影响
第三部分：数据清洗与预处理
1. 缺失值填充
1.1 Embarked --&gt; 分析：登船地点跟获救情况的关系
1.2 sibsip --&gt;分析：兄弟姐妹的数量
1.3 Parch --&gt; 分析： 父母和孩子的数量
1.4 Fare --&gt; 分析： 船票的价格
2. 特征工程和数据清洗
2.1 特征相关性的热度图
2.2 特征工程和数据清洗
Age：年龄特征
Family_size：家庭总人数
Fare：船票价格
第四部分：建立模型
1. 交叉验证" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5b18f96db258689b5fc9ce09ae18b972/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-23T16:15:52+08:00" />
<meta property="article:modified_time" content="2022-01-23T16:15:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据挖掘案例（1）：泰坦尼克号-数据挖掘流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://blog.csdn.net/qq_41709378/article/details/107642570" title="数据挖掘案例（1）：泰坦尼克号-数据挖掘流程_ZhuNian的学习乐园-CSDN博客">数据挖掘案例（1）：泰坦尼克号-数据挖掘流程_ZhuNian的学习乐园-CSDN博客</a></p> 
<p></p> 
<p>内容分为四个部分：<br> 　　　　第一部分：数据读取与展示<br> 　　　　第二部分：特征理解分析<br> 　　　　第三部分：数据清洗与预处理<br> 　　　　第四部分：建立模型<br>  <br> 数据和源码 移步到Github ： https://github.com/Stormzudi/Data-Mining-Case<br> 邮箱：442395572@qq.com<br>  </p> 
<p>目录<br> 前言：<br> 1. 泰坦尼克号-数据挖掘案例解读<br> 2. 数据挖掘流程<br> 3. 挑选兵器<br> 第一部分：数据读取与展示<br> 1. 原始数据展示<br> 第二部分：特征理解分析<br> 1. 数据特征分为：连续值和离散值<br> 1.1 Sex --&gt; 讨论：性别跟获救情况的关系<br> 1.2 Pclass --&gt; 讨论：船舱等级跟获救情况的关系<br> 1.3 Age --&gt; 讨论：连续值特征对结果的影响<br> 第三部分：数据清洗与预处理<br> 1. 缺失值填充<br> 1.1 Embarked --&gt; 分析：登船地点跟获救情况的关系<br> 1.2 sibsip --&gt;分析：兄弟姐妹的数量<br> 1.3 Parch --&gt; 分析： 父母和孩子的数量<br> 1.4 Fare --&gt; 分析： 船票的价格<br> 2. 特征工程和数据清洗<br> 2.1 特征相关性的热度图<br> 2.2 特征工程和数据清洗<br> Age：年龄特征<br> Family_size：家庭总人数<br> Fare：船票价格<br> 第四部分：建立模型<br> 1. 交叉验证<br> 2. 超参数整定<br> 3. 集成</p> 
<p> <br> 前言：<br> 1. 泰坦尼克号-数据挖掘案例解读<br> 2. 数据挖掘流程<br> （一）数据读取与展示</p> 
<p>读取数据，并进行展示<br> 统计数据各项指标<br> 明确数据规模与要完成任务<br> （二）特征理解分析</p> 
<p>单特征分析，逐个变量分析其对结果的影响<br> 多变量统计分析，综合考虑多种情况影响<br> 统计绘图得出结论<br> （三）数据清洗与预处理</p> 
<p>对缺失值进行填充<br> 特征标准化/归一化<br> 筛选有价值的特征<br> 分析特征之间的相关性<br> （四）建立模型</p> 
<p>特征数据与标签准备<br> 数据集切分<br> 多种建模算法对比<br> 集成策略等方案改进<br>  <br>  </p> 
<p>3. 挑选兵器<br> 任务已经明确下达，接下来的目的就是挑选几个合适的兵器去进行预测的工作啦，咱们的主线是使用Python，因为在数据分析与机器学习界Python已经成为一哥啦！首先介绍下咱们的兵器谱!</p> 
<p>Numpy-科学计算库 主要用来做矩阵运算，什么？你不知道哪里会用到矩阵，那么这样想吧，咱们的数据就是行（样本）和列（特征）组成的，那么数据本身不就是一个矩阵嘛。</p> 
<p>Pandas-数据分析处理库 很多小伙伴都在说用python处理数据很容易，那么容易在哪呢？其实有了pandas很复杂的操作我们也可以一行代码去解决掉！</p> 
<p>Matplotlib-可视化库 无论是分析还是建模，光靠好记性可不行，很有必要把结果和过程可视化的展示出来。</p> 
<p>Seaborn-可视化库 更简单的可视化库封装上Matplot基础之上。</p> 
<p>Scikit-Learn-机器学习库 非常实用的机器学习算法库，这里面包含了基本你觉得你能用上所有机器学习算法啦。但还远不止如此，还有很多预处理和评估的模块等你来挖掘的！</p> 
<p> <br>  </p> 
<p>第一部分：数据读取与展示<br> 1. 原始数据展示<br> 导入需要的模块</p> 
<p>import numpy as np <br> import pandas as pd<br> import matplotlib.pyplot as plt<br> import seaborn as sns<br> plt.style.use('fivethirtyeight')<br> import warnings<br> warnings.filterwarnings('ignore')<br> %matplotlib inline<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 数据读起来，先看看数据有些啥东西</p> 
<p>data=pd.read_csv('train.csv')<br> data.head()<br> 1<br> 2</p> 
<p>瞅一瞅有木有缺失值</p> 
<p>data.isnull().sum() #checking for total null values<br> 1</p> 
<p>从结果中可以看出有两列指标（Age、Cabin）存在大量的缺失值。</p> 
<p>进行一次数据报表，整体看看数据时啥规模。</p> 
<p>data.describe()<br> 1</p> 
<p>不是要预测这大船的获救情况嘛，先看看获救比例咋样</p> 
<p>f,ax=plt.subplots(1,2,figsize=(18,8))<br> data['Survived'].value_counts().plot.pie(explode=[0,0.1],autopct='%1.1f%%',ax=ax[0],shadow=True)<br> ax[0].set_title('Survived')<br> ax[0].set_ylabel('')<br> sns.countplot('Survived',data=data,ax=ax[1])<br> ax[1].set_title('Survived')<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7</p> 
<p>显然，这次事故中没有多少乘客幸免于难。</p> 
<p>在训练集的891名乘客中，只有大约350人幸存下来，只有38.4%的机组人员在空难中幸存下来。我们需要从数据中挖掘出更多的信息，看看哪些类别的乘客幸存下来，哪些没有。</p> 
<p>我们将尝试使用数据集的不同特性来检查生存率。比如性别，年龄，登船地点等，但是首先我们得来理解下数据中的特征！</p> 
<p> <br>  </p> 
<p>第二部分：特征理解分析<br> 1. 数据特征分为：连续值和离散值<br> 离散值：数据特征的值只能在几种类别中选择。例如：性别（男，女） 登船地点（S,Q,C）<br> 连续值：数据值的取值是在某一范围内的任意值。例如：年龄，船票价格<br> 1.1 Sex --&gt; 讨论：性别跟获救情况的关系<br> data.groupby(['Sex','Survived'])['Survived'].count()<br> 1</p> 
<p>从结果可以看出，女性获救与男性获救情况有所不同，女性能被获救的几率大。</p> 
<p>用图像展示</p> 
<p>f,ax=plt.subplots(1,2,figsize=(18,8))<br> data[['Sex','Survived']].groupby(['Sex']).mean().plot.bar(ax=ax[0])<br> ax[0].set_title('Survived vs Sex')<br> sns.countplot('Sex',hue='Survived',data=data,ax=ax[1])<br> ax[1].set_title('Sex:Survived vs Dead')<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6</p> 
<p><br> 这看起来很有趣。船上的男人比女人多得多。不过，挽救的女性人数几乎是男性的两倍。生存率为一个女人在船上是75%左右，而男性在18-19%左右。（“让妇女和儿童先走”，虽然电影忘得差不多了，这句话还记着。。。确实是这样的）</p> 
<p>这看起来是建模的一个非常重要的特性。一会我们会用上他的！</p> 
<p></p> 
<p>1.2 Pclass --&gt; 讨论：船舱等级跟获救情况的关系<br> pd.crosstab(data.Pclass,data.Survived,margins=True).style.background_gradient(cmap='summer_r').data<br> 1</p> 
<p>初步了解到，Pclass=1的船舱里获救的几率最大，Pclass=2其次，Pclass获救的概率最小。</p> 
<p>用图像展示</p> 
<p>f,ax=plt.subplots(1,2,figsize=(18,8))<br> data['Pclass'].value_counts().plot.bar(color=['#CD7F32','#FFDF00','#D3D3D3'],ax=ax[0])<br> ax[0].set_title('Number Of Passengers By Pclass')<br> ax[0].set_ylabel('Count')<br> sns.countplot('Pclass',hue='Survived',data=data,ax=ax[1])<br> ax[1].set_title('Pclass:Survived vs Dead')<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7</p> 
<p>人们说金钱不能买到一切。但我们可以清楚地看到，船舱等级为1的被给予很高的优先级而救援。尽管数量在pClass 3乘客高了很多，仍然存活数从他们是非常低的，大约25%。</p> 
<p>对于pClass1来说存活是63%左右，而pclass2大约是48%。所以金钱和地位很重要。这样一个物欲横流的世界。</p> 
<p>那这些又和性别有关吗？接下来我们再来看看船舱等级和性别对结果的影响</p> 
<p>pd.crosstab([data.Sex,data.Survived],data.Pclass,margins=True).style.background_gradient(cmap='summer_r').data<br> 1</p> 
<p>sns.factorplot('Pclass','Survived',hue='Sex',data=data)<br> plt.show()<br> 1<br> 2</p> 
<p>我们用factorplot这个图，看起来更直观一些。</p> 
<p>我们可以很容易地推断，从pclass1女性生存是95-96%，如94人中只有3的女性从pclass1没获救。</p> 
<p>显而易见的是，不论pClass，女性优先考虑。</p> 
<p>看来Pclass也是一个重要的特征。让我们分析其他特征</p> 
<p></p> 
<p>1.3 Age --&gt; 讨论：连续值特征对结果的影响<br> print('Oldest Passenger was of:',data['Age'].max(),'Years')<br> print('Youngest Passenger was of:',data['Age'].min(),'Years')<br> print('Average Age on the ship:',data['Age'].mean(),'Years')<br> 1<br> 2<br> 3</p> 
<p>从结果可以看出，最小的年龄只有半岁，最大的年龄达到80岁，平均年龄在30岁。<br> 通过绘制“小提琴”图，来分析不同等级、不同性别下年龄段的获救情况。</p> 
<p>f,ax=plt.subplots(1,2,figsize=(18,8))<br> sns.violinplot("Pclass","Age", hue="Survived", data=data,split=True,ax=ax[0])<br> ax[0].set_title('Pclass and Age vs Survived')<br> ax[0].set_yticks(range(0,110,10))<br> sns.violinplot("Sex","Age", hue="Survived", data=data,split=True,ax=ax[1])<br> ax[1].set_title('Sex and Age vs Survived')<br> ax[1].set_yticks(range(0,110,10))<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8</p> 
<p><br> 结果：¶<br> 1）10岁以下儿童的存活率随passenegers数量增加。<br> 2）生存为20-50岁获救几率更高一些。<br> 3）对男性来说，随着年龄的增长，存活率降低。</p> 
<p> <br>  </p> 
<p>第三部分：数据清洗与预处理<br> 1. 缺失值填充<br> 平均值<br> 经验值<br> 回归模型预测<br> 剔除掉<br> 正如我们前面看到的，年龄特征有177个空值。为了替换这些缺失值，我们可以给它们分配数据集的平均年龄。</p> 
<p>但问题是，有许多不同年龄的人。最好的办法是找到一个合适的年龄段！</p> 
<p>我们可以检查名字特征。根据这个特征，我们可以看到名字有像先生或夫人这样的称呼，这样我们就可以把先生和夫人的平均值分配给各自的组。</p> 
<p>data['Initial']=0<br> for i in data:<br>     data['Initial']=data.Name.str.extract('([A-Za-z]+)\.')  # 匹配一个或多个字母并且以.结尾的所有字符串组合<br> print(data['Initial'])<br> 1<br> 2<br> 3<br> 4<br> 好了，这里我们使用正则表达式：([A-Za-z] +）来提取信息</p> 
<p>pd.crosstab(data.Initial,data.Sex).T.style.background_gradient(cmap='summer_r') #Checking the Initials with the Sex<br> 1</p> 
<p>增加一列[‘Initial’]后的数据展示为：</p> 
<p><br> 统计不同 ‘Initial’ 下年龄的平均值</p> 
<p>data.groupby('Initial')['Age'].mean() #lets check the average age by Initials<br> 1</p> 
<p>下一步，就是按照名字中出现的 ‘Initial’ 来填充缺失值。</p> 
<p>## 使用每组的均值来进行填充<br> data.loc[(data.Age.isnull())&amp;(data.Initial=='Mr'),'Age']=33<br> data.loc[(data.Age.isnull())&amp;(data.Initial=='Mrs'),'Age']=36<br> data.loc[(data.Age.isnull())&amp;(data.Initial=='Master'),'Age']=5<br> data.loc[(data.Age.isnull())&amp;(data.Initial=='Miss'),'Age']=22<br> data.loc[(data.Age.isnull())&amp;(data.Initial=='Other'),'Age']=46<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> data.Age.isnull().any() #看看填充完了咋样<br> 1<br> 返回 True ；说明 ‘Age’ 列中不存在缺失值了。</p> 
<p>填补完后，接下来，用图形展示不同年龄段获救情况，来分析哪个年龄段获救概率更高？！?</p> 
<p>f,ax=plt.subplots(1,2,figsize=(20,10))<br> data[data['Survived']==0].Age.plot.hist(ax=ax[0],bins=20,edgecolor='black',color='red')<br> ax[0].set_title('Survived= 0')<br> x1=list(range(0,85,5))<br> ax[0].set_xticks(x1)<br> data[data['Survived']==1].Age.plot.hist(ax=ax[1],color='green',bins=20,edgecolor='black')<br> ax[1].set_title('Survived= 1')<br> x2=list(range(0,85,5))<br> ax[1].set_xticks(x2)<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10</p> 
<p><br> 观察:</p> 
<p>1）幼儿（年龄在5岁以下）获救的还是蛮多的（妇女和儿童优先政策）。<br> 2）最老的乘客得救了（80年）。<br> 3）死亡人数最高的是30-40岁年龄组。</p> 
<p>sns.factorplot('Pclass','Survived',col='Initial',data=data)<br> plt.show()<br> 1<br> 2</p> 
<p><br> 因此，无论性别如何，妇女和儿童第一政策都是正确的，她们会第一时间被救出。</p> 
<p> <br>  </p> 
<p>1.1 Embarked --&gt; 分析：登船地点跟获救情况的关系<br> pd.crosstab([data.Embarked,data.Pclass],[data.Sex,data.Survived],margins=True).style.background_gradient(cmap='summer_r')<br> 1</p> 
<p>sns.factorplot('Embarked','Survived',data=data)<br> fig=plt.gcf()<br> fig.set_size_inches(5,3)<br> plt.show()<br> 1<br> 2<br> 3<br> 4</p> 
<p>C港生存的可能性最高在0.55左右，而S的生存率最低。</p> 
<p>于是，我们就会想什么原因导致了C港出现如此高的生存率？！？</p> 
<p>我们可以从不同港湾，上船的船票等级、性别、上船人数进行分析。</p> 
<p>f,ax=plt.subplots(2,2,figsize=(20,15))<br> sns.countplot('Embarked',data=data,ax=ax[0,0])<br> ax[0,0].set_title('No. Of Passengers Boarded')<br> sns.countplot('Embarked',hue='Sex',data=data,ax=ax[0,1])<br> ax[0,1].set_title('Male-Female Split for Embarked')<br> sns.countplot('Embarked',hue='Survived',data=data,ax=ax[1,0])<br> ax[1,0].set_title('Embarked vs Survived')<br> sns.countplot('Embarked',hue='Pclass',data=data,ax=ax[1,1])<br> ax[1,1].set_title('Embarked vs Pclass')<br> plt.subplots_adjust(wspace=0.2,hspace=0.5)<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11</p> 
<p>观察:</p> 
<p>1）大部分人的船舱等级是3。<br> 2）C的乘客看起来很幸运，他们中的一部分幸存下来。<br> 3）S港口的富人蛮多的。仍然生存的机会很低。<br> 4）港口Q几乎有95%的乘客都是穷人。</p> 
<p>sns.factorplot('Pclass','Survived',hue='Sex',col='Embarked',data=data)<br> plt.show()<br> 1<br> 2</p> 
<p><br> 观察:</p> 
<p>1）存活的几率几乎为1 在pclass1和pclass2中的女人。<br> 2）pclass3 的乘客中男性和女性的生存率都是很偏低的。<br> 3）端口Q很不幸，因为那里都是3等舱的乘客。</p> 
<p>港口中也存在缺失值，在这里我用众数来进行填充了，因为S登船人最多呀</p> 
<p>data['Embarked'].fillna('S',inplace=True)<br> data.Embarked.isnull().any()<br> 1<br> 2<br>  <br>  </p> 
<p>1.2 sibsip --&gt;分析：兄弟姐妹的数量<br> 这个特征表示一个人是独自一人还是与他的家人在一起。</p> 
<p>pd.crosstab([data.SibSp],data.Survived).style.background_gradient(cmap='summer_r')<br> 1</p> 
<p>上述只是表示了兄弟姐妹个数与是否获救之间的关系，初步判断，单独一个人获救的概率会大些。</p> 
<p>f,ax=plt.subplots(1,2,figsize=(20,8))<br> sns.barplot('SibSp','Survived',data=data,ax=ax[0])<br> ax[0].set_title('SibSp vs Survived')<br> sns.factorplot('SibSp','Survived',data=data,ax=ax[1])<br> ax[1].set_title('SibSp vs Survived')<br> plt.close(2)<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7</p> 
<p><br> pd.crosstab(data.SibSp,data.Pclass).style.background_gradient(cmap='summer_r')<br> 1</p> 
<p>观察:</p> 
<p>barplot和factorplot表明，如果乘客是孤独的船上没有兄弟姐妹，他有34.5%的存活率。如果兄弟姐妹的数量增加，该图大致减少。这是有道理的。</p> 
<p>也就是说，如果我有一个家庭在船上，我会尽力拯救他们，而不是先救自己。但是令人惊讶的是，5-8名成员家庭的存活率为0%。原因可能是他们在pclass=3的船舱？</p> 
<p> <br>  </p> 
<p>1.3 Parch --&gt; 分析： 父母和孩子的数量<br> 这个特征表示一个人是独自一人还是与他的家人在一起。</p> 
<p>pd.crosstab(data.Parch,data.Pclass).style.background_gradient(cmap='summer_r')<br> 1</p> 
<p>再次表明，大家庭都在pclass3。</p> 
<p>f,ax=plt.subplots(1,2,figsize=(20,8))<br> sns.barplot('Parch','Survived',data=data,ax=ax[0])<br> ax[0].set_title('Parch vs Survived')<br> sns.factorplot('Parch','Survived',data=data,ax=ax[1])<br> ax[1].set_title('Parch vs Survived')<br> plt.close(2)<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7</p> 
<p>观察:</p> 
<p>这里的结果也很相似。带着父母的乘客有更大的生存机会。然而，它随着数字的增加而减少。</p> 
<p>在船上的家庭父母人数中有1-3个的人的生存机会是好的。独自一人也证明是致命的，当船上有4个父母时，生存的机会就会减少。</p> 
<p> <br>  </p> 
<p>1.4 Fare --&gt; 分析： 船票的价格<br> 这个特征表示船票价格是否与获救之间有这密切关系。</p> 
<p>print('Highest Fare was:',data['Fare'].max())<br> print('Lowest Fare was:',data['Fare'].min())<br> print('Average Fare was:',data['Fare'].mean())<br> 1<br> 2<br> 3</p> 
<p>最低票价是0英镑。这价格我也能去！</p> 
<p>f,ax=plt.subplots(1,3,figsize=(20,8))<br> sns.distplot(data[data['Pclass']==1].Fare,ax=ax[0])<br> ax[0].set_title('Fares in Pclass 1')<br> sns.distplot(data[data['Pclass']==2].Fare,ax=ax[1])<br> ax[1].set_title('Fares in Pclass 2')<br> sns.distplot(data[data['Pclass']==3].Fare,ax=ax[2])<br> ax[2].set_title('Fares in Pclass 3')<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8</p> 
<p><br>  <br> 概括地观察所有的特征： 性别：与男性相比，女性的生存机会很高。</p> 
<p>Pclass： 有，第一类乘客给你更好的生存机会的一个明显趋势。对于pclass3成活率很低。对于女性来说，从pclass1生存的机会几乎是。</p> 
<p>年龄： 小于5-10岁的儿童存活率高。年龄在15到35岁之间的乘客死亡很多。</p> 
<p>港口： 上来的仓位也有区别，死亡率也很大！</p> 
<p>家庭： 有1-2的兄弟姐妹、配偶或父母上1-3显示而不是独自一人或有一个大家庭旅行，你有更大的概率存活。</p> 
<p> <br>  </p> 
<p>2. 特征工程和数据清洗<br> 2.1 特征相关性的热度图<br> sns.heatmap(data.corr(),annot=True,cmap='RdYlGn',linewidths=0.2) #data.corr()--&gt;correlation matrix<br> fig=plt.gcf()<br> fig.set_size_inches(10,8)<br> plt.show()<br> 1<br> 2<br> 3<br> 4</p> 
<p>首先要注意的是，只有数值特征进行比较</p> 
<p>正相关：如果特征A的增加导致特征b的增加，那么它们呈正相关。值1表示完全正相关。</p> 
<p>负相关：如果特征A的增加导致特征b的减少，则呈负相关。值-1表示完全负相关。</p> 
<p>现在让我们说两个特性是高度或完全相关的，所以一个增加导致另一个增加。这意味着两个特征都包含高度相似的信息，并且信息很少或没有变化。这样的特征对我们来说是没有价值的！</p> 
<p>那么你认为我们应该同时使用它们吗？。在制作或训练模型时，我们应该尽量减少冗余特性，因为它减少了训练时间和许多优点。</p> 
<p>现在，从上面的图，我们可以看到，特征不显著相关。</p> 
<p></p> 
<p>2.2 特征工程和数据清洗<br> 当我们得到一个具有特征的数据集时，是不是所有的特性都很重要？可能有许多冗余的特征应该被消除，我们还可以通过观察或从其他特征中提取信息来获得或添加新特性。<br>  </p> 
<p>Age：年龄特征<br> 正如我前面提到的，年龄是连续的特征，在机器学习模型中存在连续变量的问题。</p> 
<p>如果我说通过性别来组织或安排体育运动，我们可以很容易地把他们分成男女分开。</p> 
<p>如果我说按他们的年龄分组，你会怎么做？如果有30个人，可能有30个年龄值。</p> 
<p>我们需要对连续值进行离散化来分组。</p> 
<p>好的，乘客的最大年龄是80岁。所以我们将范围从0-80成5箱。所以80/5＝16。</p> 
<p>data['Age_band']=0<br> data.loc[data['Age']&lt;=16,'Age_band']=0<br> data.loc[(data['Age']&gt;16)&amp;(data['Age']&lt;=32),'Age_band']=1<br> data.loc[(data['Age']&gt;32)&amp;(data['Age']&lt;=48),'Age_band']=2<br> data.loc[(data['Age']&gt;48)&amp;(data['Age']&lt;=64),'Age_band']=3<br> data.loc[data['Age']&gt;64,'Age_band']=4<br> data<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7</p> 
<p>我们再统计各年龄段的人数。</p> 
<p>data['Age_band'].value_counts().to_frame().style.background_gradient(cmap='summer')  # checking the number of passenegers in each band<br> 1</p> 
<p>统计不同等级下的，不同年龄段的获救情况。</p> 
<p>sns.factorplot('Age_band','Survived',data=data,col='Pclass')<br> plt.show()<br> 1<br> 2</p> 
<p>结果发现了，生存率随年龄的增加而减少，不论在哪个Pclass。</p> 
<p></p> 
<p>Family_size：家庭总人数<br> 光看兄弟姐妹和老人孩子看不太直接，咱们直接看全家的人数</p> 
<p>data['Family_Size']=0<br> data['Family_Size']=data['Parch']+data['SibSp']  # family size<br> data['Alone']=0<br> data.loc[data.Family_Size==0,'Alone']=1  # Alone</p> 
<p>f,ax=plt.subplots(1,2,figsize=(18,6))<br> sns.factorplot('Family_Size','Survived',data=data,ax=ax[0])<br> ax[0].set_title('Family_Size vs Survived')<br> sns.factorplot('Alone','Survived',data=data,ax=ax[1])<br> ax[1].set_title('Alone vs Survived')<br> plt.close(2)<br> plt.close(3)<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13</p> 
<p><br> family_size = 0意味着passeneger是孤独的。显然，如果你是单独或family_size = 0，那么生存的机会很低。家庭规模4以上，机会也减少。这看起来也是模型的一个重要特性。让我们进一步研究这个问题。</p> 
<p>sns.factorplot('Alone','Survived',data=data,hue='Sex',col='Pclass')<br> plt.show()<br> 1<br> 2</p> 
<p></p> 
<p>Fare：船票价格<br> 因为票价也是连续的特性，所以我们需要将它转换为数值。</p> 
<p>pandas.qcut</p> 
<p>data['Fare_Range']=pd.qcut(data['Fare'],4)  # 分解成四个部分<br> data.groupby(['Fare_Range'])['Survived'].mean().to_frame().style.background_gradient(cmap='summer_r')<br> 1<br> 2</p> 
<p>如上所述，我们可以清楚地看到，随着船票价格增加，生存的机会增加。</p> 
<p>data['Fare_cat']=0<br> data.loc[data['Fare']&lt;=7.91,'Fare_cat']=0<br> data.loc[(data['Fare']&gt;7.91)&amp;(data['Fare']&lt;=14.454),'Fare_cat']=1<br> data.loc[(data['Fare']&gt;14.454)&amp;(data['Fare']&lt;=31),'Fare_cat']=2<br> data.loc[(data['Fare']&gt;31)&amp;(data['Fare']&lt;=513),'Fare_cat']=3<br> 1<br> 2<br> 3<br> 4<br> 5<br> sns.factorplot('Fare_cat','Survived',data=data,hue='Sex')<br> plt.show()<br> 1<br> 2</p> 
<p>显然，随着fare_cat增加，存活的几率增加。随着性别的变化，这一特性可能成为建模过程中的一个重要特征。</p> 
<p>将字符串值转换为数字 因为我们不能把字符串一个机器学习模型</p> 
<p>data['Sex'].replace(['male','female'],[0,1],inplace=True)<br> data['Embarked'].replace(['S','C','Q'],[0,1,2],inplace=True)<br> data['Initial'].replace(['Mr','Mrs','Miss','Master','Other'],[0,1,2,3,4],inplace=True)<br> 1<br> 2<br> 3<br> 去掉不必要的特征</p> 
<p>名称&gt; 我们不需要name特性，因为它不能转换成任何分类值</p> 
<p>年龄——&gt; 我们有age_band特征，所以不需要这个</p> 
<p>票号 --&gt; 这是任意的字符串，不能被归类</p> 
<p>票价 ——&gt; 我们有fare_cat特征，所以不需要</p> 
<p>船仓号 ——&gt; 这个也不要没啥含义</p> 
<p>passengerid --&gt; 不能被归类</p> 
<p>data.drop(['Name','Age','Ticket','Fare','Cabin','Fare_Range','PassengerId'],axis=1,inplace=True)<br> sns.heatmap(data.corr(),annot=True,cmap='RdYlGn',linewidths=0.2,annot_kws={'size':20})<br> fig=plt.gcf()<br> fig.set_size_inches(18,15)<br> plt.xticks(fontsize=14)<br> plt.yticks(fontsize=14)<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7</p> 
<p>以上就是建立模型所需要的特征。</p> 
<p>现在以上的相关图，我们可以看到一些正相关的特征。他们中的一些人SibSp和family_size、Parch和family_size、一些负面的Alone和family_size。</p> 
<p>展示预处理后的特征数据。</p> 
<p><br>  <br>  <br> 数据和源码 移步到Github ： https://github.com/Stormzudi/Data-Mining-Case<br> 邮箱：442395572@qq.com<br>  <br>  </p> 
<p>第四部分：建立模型<br> 我们从EDA部分获得了一些见解。但是，我们不能准确地预测或判断一个乘客是否会幸存或死亡。现在我们将使用一些很好的分类算法来预测乘客是否能生存下来：</p> 
<p>1）logistic回归</p> 
<p>2）支持向量机（线性和径向）</p> 
<p>3）随机森林</p> 
<p>4）k-近邻</p> 
<p>5）朴素贝叶斯</p> 
<p>6）决策树</p> 
<p>7）神经网络</p> 
<p></p> 
<p>导入模块</p> 
<p>#importing all the required ML packages<br> from sklearn.linear_model import LogisticRegression #logistic regression<br> from sklearn import svm #support vector Machine<br> from sklearn.ensemble import RandomForestClassifier #Random Forest<br> from sklearn.neighbors import KNeighborsClassifier #KNN<br> from sklearn.naive_bayes import GaussianNB #Naive bayes<br> from sklearn.tree import DecisionTreeClassifier #Decision Tree<br> from sklearn.model_selection import train_test_split #training and testing data split<br> from sklearn import metrics #accuracy measure<br> from sklearn.metrics import confusion_matrix #for confusion matrix<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 从训练集中拆分成训练集和测试集</p> 
<p>train,test=train_test_split(data,test_size=0.3,random_state=0,stratify=data['Survived'])<br> train_X=train[train.columns[1:]]<br> train_Y=train[train.columns[:1]]<br> test_X=test[test.columns[1:]]<br> test_Y=test[test.columns[:1]]<br> X=data[data.columns[1:]]<br> Y=data['Survived']<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br>  <br>  <br> 接下来就是要运用机器学习的模型进行分析。</p> 
<p>（1）Radial Support Vector Machines(rbf-SVM)</p> 
<p>model=svm.SVC(kernel='rbf',C=1,gamma=0.1)<br> model.fit(train_X,train_Y)<br> prediction1=model.predict(test_X)<br> print('Accuracy for rbf SVM is ',metrics.accuracy_score(prediction1,test_Y))<br> 1<br> 2<br> 3<br> 4<br> Accuracy for rbf SVM is 0.835820895522388</p> 
<p> <br> （2）Linear Support Vector Machine(linear-SVM)</p> 
<p>model=svm.SVC(kernel='linear',C=0.1,gamma=0.1)<br> model.fit(train_X,train_Y)<br> prediction2=model.predict(test_X)<br> print('Accuracy for linear SVM is',metrics.accuracy_score(prediction2,test_Y))<br> 1<br> 2<br> 3<br> 4<br> Accuracy for linear SVM is 0.8171641791044776</p> 
<p> <br> （3）Logistic Regression</p> 
<p>model = LogisticRegression()<br> model.fit(train_X,train_Y)<br> prediction3=model.predict(test_X)<br> print('The accuracy of the Logistic Regression is',metrics.accuracy_score(prediction3,test_Y))<br> 1<br> 2<br> 3<br> 4<br> The accuracy of the Logistic Regression is 0.817164179104<br>  </p> 
<p>（4）Decision Tree</p> 
<p>model=DecisionTreeClassifier()<br> model.fit(train_X,train_Y)<br> prediction4=model.predict(test_X)<br> print('The accuracy of the Decision Tree is',metrics.accuracy_score(prediction4,test_Y))<br> 1<br> 2<br> 3<br> 4<br> The accuracy of the Decision Tree is 0.805970149254<br>  </p> 
<p>（5）K-Nearest Neighbours(KNN)</p> 
<p>model=KNeighborsClassifier() <br> model.fit(train_X,train_Y)<br> prediction5=model.predict(test_X)<br> print('The accuracy of the KNN is',metrics.accuracy_score(prediction5,test_Y))<br> 1<br> 2<br> 3<br> 4<br> The accuracy of the KNN is 0.832089552239<br>  <br> 现在的精度为KNN模型的变化，我们改变n_neighbours值属性。默认值是5。让我们检查的精度在n_neighbours不同时的结果。</p> 
<p>a_index=list(range(1,11))<br> a=pd.Series()<br> x=[0,1,2,3,4,5,6,7,8,9,10]<br> for i in list(range(1,11)):<br>     model=KNeighborsClassifier(n_neighbors=i) <br>     model.fit(train_X,train_Y)<br>     prediction=model.predict(test_X)<br>     a=a.append(pd.Series(metrics.accuracy_score(prediction,test_Y)))<br> plt.plot(a_index, a)<br> plt.xticks(x)<br> fig=plt.gcf()<br> fig.set_size_inches(12,6)<br> plt.show()<br> print('Accuracies for different values of n are:',a.values,'with the max value as ',a.values.max())<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14</p> 
<p>Accuracies for different values of n are: [ 0.75746269 0.79104478 0.80970149 0.80223881 0.83208955 0.81716418 0.82835821 0.83208955 0.8358209 0.83208955] with the max value as 0.835820895522</p> 
<p>选取默认值是5，取得最大精度值0.835820895522。</p> 
<p> <br> （6）NaiveBayes</p> 
<p>model=GaussianNB()<br> model.fit(train_X,train_Y)<br> prediction6=model.predict(test_X)<br> print('The accuracy of the NaiveBayes is',metrics.accuracy_score(prediction6,test_Y))<br> 1<br> 2<br> 3<br> 4<br> The accuracy of the NaiveBayes is 0.813432835821<br>  </p> 
<p>（7）Random Forest</p> 
<p>model=RandomForestClassifier(n_estimators=100)<br> model.fit(train_X,train_Y)<br> prediction7=model.predict(test_X)<br> print('The accuracy of the Random Forests is',metrics.accuracy_score(prediction7,test_Y))<br> 1<br> 2<br> 3<br> 4<br> The accuracy of the Random Forests is 0.820895522388<br>  </p> 
<p>模型的精度并不是决定分类器效果的唯一因素。假设分类器在训练数据上进行训练，需要在测试集上进行测试才有效果</p> 
<p>现在这个分类器的精确度很高，但是我们可以确认所有的新测试集都是90%吗？答案是否定的，因为我们不能确定分类器在不同数据源上的结果。当训练和测试数据发生变化时，精确度也会改变。它可能会增加或减少。</p> 
<p>为了克服这一点，得到一个广义模型，我们使用交叉验证。</p> 
<p> <br>  </p> 
<p>1. 交叉验证<br> 一个测试集看起来不太够呀，多轮求均值是一个好的策略！</p> 
<p>1）的交叉验证的工作原理是首先将数据集分成k-subsets。</p> 
<p>2）假设我们将数据集划分为（k＝5）部分。我们预留1个部分进行测试，并对这4个部分进行训练。</p> 
<p>3）我们通过在每次迭代中改变测试部分并在其他部分中训练算法来继续这个过程。然后对衡量结果求平均值，得到算法的平均精度。</p> 
<p>这就是所谓的交叉验证。</p> 
<p>from sklearn.model_selection import KFold #for K-fold cross validation<br> from sklearn.model_selection import cross_val_score #score evaluation<br> from sklearn.model_selection import cross_val_predict #prediction<br> kfold = KFold(n_splits=10, random_state=22) # k=10, split the data into 10 equal parts<br> xyz=[]<br> accuracy=[]<br> std=[]<br> classifiers=['Linear Svm','Radial Svm','Logistic Regression','KNN','Decision Tree','Naive Bayes','Random Forest']<br> models=[svm.SVC(kernel='linear'),svm.SVC(kernel='rbf'),LogisticRegression(),KNeighborsClassifier(n_neighbors=9),DecisionTreeClassifier(),GaussianNB(),RandomForestClassifier(n_estimators=100)]<br> for i in models:<br>     model = i<br>     cv_result = cross_val_score(model,X,Y, cv = kfold,scoring = "accuracy")<br>     cv_result=cv_result<br>     xyz.append(cv_result.mean())<br>     std.append(cv_result.std())<br>     accuracy.append(cv_result)<br> new_models_dataframe2=pd.DataFrame({'CV Mean':xyz,'Std':std},index=classifiers)       <br> new_models_dataframe2<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18</p> 
<p>绘制箱图</p> 
<p>plt.subplots(figsize=(12,6))<br> box=pd.DataFrame(accuracy,index=[classifiers])<br> box.T.boxplot()<br> 1<br> 2<br> 3</p> 
<p><br> new_models_dataframe2['CV Mean'].plot.barh(width=0.8)<br> plt.title('Average CV Mean Accuracy')<br> fig=plt.gcf()<br> fig.set_size_inches(8,5)<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5</p> 
<p><br> 混淆矩阵 它给出分类器的正确和不正确分类的数量。</p> 
<p>f,ax=plt.subplots(3,3,figsize=(12,10))<br> y_pred = cross_val_predict(svm.SVC(kernel='rbf'),X,Y,cv=10)<br> sns.heatmap(confusion_matrix(Y,y_pred),ax=ax[0,0],annot=True,fmt='2.0f')<br> ax[0,0].set_title('Matrix for rbf-SVM')<br> y_pred = cross_val_predict(svm.SVC(kernel='linear'),X,Y,cv=10)<br> sns.heatmap(confusion_matrix(Y,y_pred),ax=ax[0,1],annot=True,fmt='2.0f')<br> ax[0,1].set_title('Matrix for Linear-SVM')<br> y_pred = cross_val_predict(KNeighborsClassifier(n_neighbors=9),X,Y,cv=10)<br> sns.heatmap(confusion_matrix(Y,y_pred),ax=ax[0,2],annot=True,fmt='2.0f')<br> ax[0,2].set_title('Matrix for KNN')<br> y_pred = cross_val_predict(RandomForestClassifier(n_estimators=100),X,Y,cv=10)<br> sns.heatmap(confusion_matrix(Y,y_pred),ax=ax[1,0],annot=True,fmt='2.0f')<br> ax[1,0].set_title('Matrix for Random-Forests')<br> y_pred = cross_val_predict(LogisticRegression(),X,Y,cv=10)<br> sns.heatmap(confusion_matrix(Y,y_pred),ax=ax[1,1],annot=True,fmt='2.0f')<br> ax[1,1].set_title('Matrix for Logistic Regression')<br> y_pred = cross_val_predict(DecisionTreeClassifier(),X,Y,cv=10)<br> sns.heatmap(confusion_matrix(Y,y_pred),ax=ax[1,2],annot=True,fmt='2.0f')<br> ax[1,2].set_title('Matrix for Decision Tree')<br> y_pred = cross_val_predict(GaussianNB(),X,Y,cv=10)<br> sns.heatmap(confusion_matrix(Y,y_pred),ax=ax[2,0],annot=True,fmt='2.0f')<br> ax[2,0].set_title('Matrix for Naive Bayes')<br> plt.subplots_adjust(hspace=0.2,wspace=0.2)<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24</p> 
<p>解释混淆矩阵：来看第一个图</p> 
<p>1）预测的正确率为491（死亡）+ 247（存活），预测错误数为：95 + 58；平均CV准确率为（491+247）/ 891＝82.8%。</p> 
<p>2）58和95都是咱们预测错误的。</p> 
<p></p> 
<p>2. 超参数整定<br> 机器学习模型就像一个黑盒子。这个黑盒有一些默认参数值，我们可以调整或更改以获得更好的模型。比如支持向量机模型中的C和γ，我们称之为超参数，他们对结果可能产生非常大的影响。</p> 
<p>所以，需要训练模型来找到最优的C和γ。</p> 
<p>（1）SVM</p> 
<p>from sklearn.model_selection import GridSearchCV<br> C=[0.05,0.1,0.2,0.3,0.25,0.4,0.5,0.6,0.7,0.8,0.9,1]<br> gamma=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]<br> kernel=['rbf','linear']<br> hyper={'kernel':kernel,'C':C,'gamma':gamma}<br> gd=GridSearchCV(estimator=svm.SVC(),param_grid=hyper,verbose=True)<br> gd.fit(X,Y)<br> print(gd.best_score_)<br> print(gd.best_estimator_)<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9</p> 
<p>RBF支持向量机的最佳得分为82.82%，C＝0.4，γ＝0.2。<br>  </p> 
<p>（2）Random Forests</p> 
<p>n_estimators=range(100,1000,100)<br> hyper={'n_estimators':n_estimators}<br> gd=GridSearchCV(estimator=RandomForestClassifier(random_state=0),param_grid=hyper,verbose=True)<br> gd.fit(X,Y)<br> print(gd.best_score_)<br> print(gd.best_estimator_)<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6</p> 
<p>RandomForest，成绩是81.9%，n_estimators=300。</p> 
<p> <br>  </p> 
<p>3. 集成<br> 集成是提高模型的精度和性能的一个很好的方式。简单地说，是各种简单模型的结合创造了一个强大的模型。</p> 
<p>1）随机森林类型的，并行的集成</p> 
<p>2）提升类型</p> 
<p>3）堆叠类型</p> 
<p></p> 
<p>(1) 投票分类器： 这是将许多不同的简单机器学习模型的预测结合起来的最简单方法。它给出了一个平均预测结果基于各子模型的预测。</p> 
<p>from sklearn.ensemble import VotingClassifier<br> ensemble_lin_rbf=VotingClassifier(estimators=[('KNN',KNeighborsClassifier(n_neighbors=10)),<br>                                               ('RBF',svm.SVC(probability=True,kernel='rbf',C=0.5,gamma=0.1)),<br>                                               ('RFor',RandomForestClassifier(n_estimators=500,random_state=0)),<br>                                               ('LR',LogisticRegression(C=0.05)),<br>                                               ('DT',DecisionTreeClassifier(random_state=0)),<br>                                               ('NB',GaussianNB()),<br>                                               ('svm',svm.SVC(kernel='linear',probability=True))<br>                                              ], <br>                        voting='soft').fit(train_X,train_Y)<br> print('The accuracy for ensembled model is:',ensemble_lin_rbf.score(test_X,test_Y))<br> cross=cross_val_score(ensemble_lin_rbf,X,Y, cv = 10,scoring = "accuracy")<br> print('The cross validated score is',cross.mean())<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> The accuracy for ensembled model is: 0.824626865672<br> The cross validated score is 0.823766031097</p> 
<p></p> 
<p>（2）Bagged KNN</p> 
<p>from sklearn.ensemble import BaggingClassifier<br> model=BaggingClassifier(base_estimator=KNeighborsClassifier(n_neighbors=3),random_state=0,n_estimators=700)<br> model.fit(train_X,train_Y)<br> prediction=model.predict(test_X)<br> print('The accuracy for bagged KNN is:',metrics.accuracy_score(prediction,test_Y))<br> result=cross_val_score(model,X,Y,cv=10,scoring='accuracy')<br> print('The cross validated score for bagged KNN is:',result.mean())<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> The accuracy for bagged KNN is: 0.835820895522<br> The cross validated score for bagged KNN is: 0.814889342867</p> 
<p></p> 
<p>（3）Bagged DecisionTree</p> 
<p>model=BaggingClassifier(base_estimator=DecisionTreeClassifier(),random_state=0,n_estimators=100)<br> model.fit(train_X,train_Y)<br> prediction=model.predict(test_X)<br> print('The accuracy for bagged Decision Tree is:',metrics.accuracy_score(prediction,test_Y))<br> result=cross_val_score(model,X,Y,cv=10,scoring='accuracy')<br> print('The cross validated score for bagged Decision Tree is:',result.mean())<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> The accuracy for bagged Decision Tree is: 0.824626865672<br> The cross validated score for bagged Decision Tree is: 0.820482635342</p> 
<p></p> 
<p>（4）提升是一个逐步增强的弱模型：</p> 
<p>首先对完整的数据集进行训练。现在模型会得到一些实例，而有些错误。现在，在下一次迭代中，学习者将更多地关注错误预测的实例或赋予它更多的权重</p> 
<p>AdaBoost（自适应增强）:在这种情况下，弱学习或估计是一个决策树。但我们可以改变缺省base_estimator任何算法的选择。</p> 
<p>from sklearn.ensemble import AdaBoostClassifier<br> ada=AdaBoostClassifier(n_estimators=200,random_state=0,learning_rate=0.1)<br> result=cross_val_score(ada,X,Y,cv=10,scoring='accuracy')<br> print('The cross validated score for AdaBoost is:',result.mean())<br> 1<br> 2<br> 3<br> 4<br> The cross validated score for AdaBoost is: 0.824952616048</p> 
<p>from sklearn.ensemble import GradientBoostingClassifier<br> grad=GradientBoostingClassifier(n_estimators=500,random_state=0,learning_rate=0.1)<br> result=cross_val_score(grad,X,Y,cv=10,scoring='accuracy')<br> print('The cross validated score for Gradient Boosting is:',result.mean())<br> 1<br> 2<br> 3<br> 4<br> The cross validated score for Gradient Boosting is: 0.818286233118</p> 
<p>我们得到了最高的精度为AdaBoost。我们将尝试用超参数调整来增加它。</p> 
<p>n_estimators=list(range(100,1100,100))<br> learn_rate=[0.05,0.1,0.2,0.3,0.25,0.4,0.5,0.6,0.7,0.8,0.9,1]<br> hyper={'n_estimators':n_estimators,'learning_rate':learn_rate}<br> gd=GridSearchCV(estimator=AdaBoostClassifier(),param_grid=hyper,verbose=True)<br> gd.fit(X,Y)<br> print(gd.best_score_)<br> print(gd.best_estimator_)<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7</p> 
<p>我们可以从AdaBoost的最高精度是83.16%，n_estimators = 200 和 learning_rate = 0.05</p> 
<p>Confusion Matrix for the Best Model¶</p> 
<p>ada=AdaBoostClassifier(n_estimators=200,random_state=0,learning_rate=0.05)<br> result=cross_val_predict(ada,X,Y,cv=10)<br> sns.heatmap(confusion_matrix(Y,result),cmap='winter',annot=True,fmt='2.0f')<br> plt.show()<br> 1<br> 2<br> 3<br> 4</p> 
<p>从结果可以看出，集成学习的效果还是很不错的，准确率达到了83%。</p> 
<p> <br>  <br> 接下来可以寻找到，在各自模型中，各个特征对模型的影响程度</p> 
<p>Feature Importance</p> 
<p>f,ax=plt.subplots(2,2,figsize=(15,12))<br> model=RandomForestClassifier(n_estimators=500,random_state=0)<br> model.fit(X,Y)<br> pd.Series(model.feature_importances_,X.columns).sort_values(ascending=True).plot.barh(width=0.8,ax=ax[0,0])<br> ax[0,0].set_title('Feature Importance in Random Forests')<br> model=AdaBoostClassifier(n_estimators=200,learning_rate=0.05,random_state=0)<br> model.fit(X,Y)<br> pd.Series(model.feature_importances_,X.columns).sort_values(ascending=True).plot.barh(width=0.8,ax=ax[0,1],color='#ddff11')<br> ax[0,1].set_title('Feature Importance in AdaBoost')<br> model=GradientBoostingClassifier(n_estimators=500,learning_rate=0.1,random_state=0)<br> model.fit(X,Y)<br> pd.Series(model.feature_importances_,X.columns).sort_values(ascending=True).plot.barh(width=0.8,ax=ax[1,0],cmap='RdYlGn_r')<br> ax[1,0].set_title('Feature Importance in Gradient Boosting')<br> model=xg.XGBClassifier(n_estimators=900,learning_rate=0.1)<br> model.fit(X,Y)<br> pd.Series(model.feature_importances_,X.columns).sort_values(ascending=True).plot.barh(width=0.8,ax=ax[1,1],color='#FD0F00')<br> ax[1,1].set_title('Feature Importance in XgBoost')<br> plt.show()<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18</p> 
<p><br>  <br> 到这里模型就大致分析完毕了，我们比较了机器学习中常见的算法，可以选取分析过程中你认为的最优秀的算法对test数据集进行预测。<br> ————————————————<br> 版权声明：本文为CSDN博主「Stormzudi」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/qq_41709378/article/details/107642570</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/efef43b76faddcddc820ccc0b37c6b47/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL注入之MySQL注入姿势及绕过</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f44ccf7d114328bac1d656f7ee13e4e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GBase8s 索引入门之原理分析（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>