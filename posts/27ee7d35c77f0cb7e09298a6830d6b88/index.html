<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32物联网项目——TM1620驱动数码管显示 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32物联网项目——TM1620驱动数码管显示" />
<meta property="og:description" content="程序功能：
TM1620
这里主要说说关于TM1620指令与数据传输，其他概述等内容详细见TM1620手册：
链接：https://pan.baidu.com/s/1C4I_oy9n9QjSPu8UD-FJRg 提取码：9ec0 --来自百度网盘超级会员V2的分享
TM1620一共有4条指令：
(1) 显示模式命令设置： 该指令用来设置选择段和位的个数（4～6 位,8～10 段）。当该指令被执行时,显示被强制关闭。在显示模式不变时,显存内的数据不会被改变,显示控制命令控制显示开关。
本项目使用的是6位8段的数码管，即0x020。
(2) 数据命令设置： 该指令用来设置数据写和读,B1和B0位不允许设置01或11。
(3) 显示控制命令设置： 该指令用来设置显示的开关以及显示亮度调节。共有8级辉度可供选择进行调节。 (4) 地址命令设置： 该指令用来设置显示寄存器的地址。 最多有效地址为12位(00H-0BH)。上电时,地址默认设为00H。
▲注意：芯片显示寄存器在上电瞬间其内部保存的值可能是随机不确定的,此时我们直接发送开屏命令,将有可能出现显示乱码。所以建议对显示寄存器进行一次上电清零操作,即上电后向12位显存地址（00H-0BH）中全部写入数据0x00。具体操作方法是：初始化TM1620时使用（2）数据命令中的自动地址增加命令，依次给所有地址写0x00.
串行数据传输格式
空闲时，时钟和STB线均被拉高；STB线拉低，准备发送数据；CLK线拉低，此时准备数据位，之后拉高CLK线，发送数据（在CLK上升沿发送数据），循环此步骤8次，可发送1Byte数据。
两种地址模式的传输
两种模式的区别就是发送数据时，固定地址模式必须先发送地址地址命令，才能发送数据，而地址增加模式不用。
强调：起始地址命令字发送完毕,“STB”不需要置高紧跟着传数据,最多14BYTE,数据传送完毕才将“STB”置高。
数码管
本项目使用的是共阴极数码管，即单片机发送高电平点亮。
若想让数码管显示“0”字样，只需要向00H（GRID1）地址中从低位开
始写入0x3F数据点亮相应的段选位，低位到高位依次对应图中的a、b、c、d、e、f、g、dp或SEG1~SEG8。
数码管位选与地址关系如图：
即GRID1的低4位为00HL，高4位为00HU...
功能实现
硬件电路：
TM1620的STB、CLK、DIN引脚分别连接单片机的PC0、PC1、PC2引脚。
初始化：
初始化TM1620的3个输出引脚：
初始化Key1按键引脚并在NVIC中打开外部中断0：
代码部分：
定义结构体类型：
typedef struct { Brightness_level_t Brightness; void (*TM1620_Init)(void); //TM1620初始化 void (*Disp)(Disp_NUM_t,uint8_t,Disp_DP_Status_t); //数码管显示 } Display_t; 还定义了6个枚举，分别定义了显示模式、写数据地址模式、辉度等级、显示寄存器地址、数码管编号、小数点状态（即数码管dp段），这里就不一一列举。
写入字节函数：
/* * @name TM1620_Write_Byte * @brief TM1620写入字节 * @param dat -&gt; 待写入数据 * @retval None */ static void TM1620_Write_Byte(uint8_t dat) { uint8_t i = 0; CLR_STB; for(i=0;i&lt;8;i&#43;&#43;) { CLR_CLK; //准备数据位 if((dat &amp; BIT0) == BIT0) //BIT0为宏定义，为0x01 SET_DIN; else CLR_DIN; dat = dat &gt;&gt; 1; //移位，为发送下一位做准备 //拉高CLK，发送数据	SET_CLK;	__nop(); }	} TM1620初始化函数：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/27ee7d35c77f0cb7e09298a6830d6b88/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-03T20:23:07+08:00" />
<meta property="article:modified_time" content="2023-10-03T20:23:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32物联网项目——TM1620驱动数码管显示</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>程序功能：</strong></p> 
<p><strong>    </strong><img alt="" height="147" src="https://images2.imgbox.com/6a/6c/s9ovoaMK_o.png" width="757"></p> 
<blockquote> 
 <p><strong> TM1620</strong></p> 
</blockquote> 
<p>这里主要说说关于TM1620指令与数据传输，其他概述等内容详细见TM1620手册：</p> 
<p>链接：https://pan.baidu.com/s/1C4I_oy9n9QjSPu8UD-FJRg <br> 提取码：9ec0 <br> --来自百度网盘超级会员V2的分享</p> 
<p>TM1620一共有4条指令：</p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/9e/7a/zLRwQhPe_o.png" width="672"></p> 
<p>(1) 显示模式命令设置： <br> 该指令用来设置选择段和位的个数（4～6 位,8～10 段）。当该指令被执行时,显示被强制关闭。在显示模式不变时,显存内的数据不会被改变,显示控制命令控制显示开关。</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/6f/c4/wAvUrggA_o.png" width="784"></p> 
<p> 本项目使用的是6位8段的数码管，即0x020。</p> 
<p>(2) 数据命令设置： <br> 该指令用来设置数据写和读,B1和B0位不允许设置01或11。</p> 
<p><img alt="" height="247" src="https://images2.imgbox.com/bf/9a/CMfcsFNO_o.png" width="868"></p> 
<p>(3) 显示控制命令设置： <br> 该指令用来设置显示的开关以及显示亮度调节。共有8级辉度可供选择进行调节。  </p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/c8/31/dLeo9j0T_o.png" width="886"></p> 
<p>(4) 地址命令设置： <br> 该指令用来设置显示寄存器的地址。 最多有效地址为12位(00H-0BH)。上电时,地址默认设为00H。</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/95/f5/8LJeLILh_o.png" width="656"></p> 
<p> ▲注意：芯片显示寄存器在上电瞬间其内部保存的值可能是随机不确定的,此时我们直接发送开屏命令,将有可能出现显示乱码。所以建议对显示寄存器进行一次上电清零操作,即上电后向12位显存地址（00H-0BH）中全部写入数据0x00。<span style="color:#fe2c24;">具体操作方法是：初始化TM1620时使用（2）数据命令中的自动地址增加命令，依次给所有地址写0x00.</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>串行数据传输格式</strong></span></p> 
</blockquote> 
<p><img alt="" height="403" src="https://images2.imgbox.com/b8/66/W3XChT6v_o.png" width="1200"></p> 
<p>空闲时，时钟和STB线均被拉高；STB线拉低，准备发送数据；CLK线拉低，此时准备数据位，之后拉高CLK线，发送数据（在CLK上升沿发送数据），循环此步骤8次，可发送1Byte数据。</p> 
<blockquote> 
 <p><strong>两种地址模式的传输</strong></p> 
</blockquote> 
<p><img alt="" height="486" src="https://images2.imgbox.com/55/ad/i9cTtg3x_o.png" width="1200"></p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/92/37/6Zq9iEne_o.png" width="1200"> 两种模式的区别就是发送数据时，固定地址模式必须先发送地址地址命令，才能发送数据，而地址增加模式不用。</p> 
<p><span style="color:#fe2c24;">强调：起始地址命令字发送完毕,“STB”不需要置高紧跟着传数据,最多14BYTE,数据传送完毕才将“STB”置高。</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">数码管</span></strong></p> 
</blockquote> 
<p>本项目使用的是共阴极数码管，即单片机发送高电平点亮。</p> 
<p><img alt="" height="345" src="https://images2.imgbox.com/60/11/WcDVk0h3_o.png" width="244"></p> 
<p><img alt="" height="247" src="https://images2.imgbox.com/ca/31/MLoUXkhR_o.png" width="319"></p> 
<p> 若想让数码管显示“0”字样，只需要向00H（GRID1）地址中从低位开<br> 始写入0x3F数据点亮相应的段选位，低位到高位依次对应图中的a、b、c、d、e、f、g、dp或SEG1~SEG8。</p> 
<p>数码管位选与地址关系如图：</p> 
<p><img alt="" height="432" src="https://images2.imgbox.com/51/0f/fmET5w4U_o.png" width="1200"></p> 
<p> 即GRID1的低4位为00HL，高4位为00HU...</p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">功能实现</span></strong></p> 
</blockquote> 
<p> 硬件电路：</p> 
<p><img alt="" height="640" src="https://images2.imgbox.com/78/0d/9cmGbNfX_o.png" width="1068"></p> 
<p> TM1620的STB、CLK、DIN引脚分别连接单片机的PC0、PC1、PC2引脚。</p> 
<p> 初始化：</p> 
<p>初始化TM1620的3个输出引脚：</p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/9b/f8/mtwmUHuP_o.png" width="686"></p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/7c/a9/ycNdAaOi_o.png" width="683"> 初始化Key1按键引脚并在NVIC中打开外部中断0：</p> 
<p><img alt="" height="220" src="https://images2.imgbox.com/4b/49/1YdmgvO2_o.png" width="671"></p> 
<p> <img alt="" height="37" src="https://images2.imgbox.com/e1/b4/UaJD4TBD_o.png" width="662"></p> 
<p> 代码部分：</p> 
<p>定义结构体类型：</p> 
<pre><code class="language-cs">typedef struct
{
	Brightness_level_t  Brightness;
	
	void (*TM1620_Init)(void);                          //TM1620初始化
	void (*Disp)(Disp_NUM_t,uint8_t,Disp_DP_Status_t);  //数码管显示
} Display_t;</code></pre> 
<p> 还定义了6个枚举，分别定义了显示模式、写数据地址模式、辉度等级、显示寄存器地址、数码管编号、小数点状态（即数码管dp段），这里就不一一列举。</p> 
<p>写入字节函数：</p> 
<pre><code class="language-cs">/*
	* @name   TM1620_Write_Byte
	* @brief  TM1620写入字节
	* @param  dat -&gt; 待写入数据
	* @retval None      
*/
static void TM1620_Write_Byte(uint8_t dat) 
{
	uint8_t i = 0;

	
	CLR_STB;
	
	for(i=0;i&lt;8;i++)
	{
		CLR_CLK;
		//准备数据位
		if((dat &amp; BIT0) == BIT0) //BIT0为宏定义，为0x01
			SET_DIN;
		else
			CLR_DIN;
		dat = dat &gt;&gt; 1; //移位，为发送下一位做准备
		//拉高CLK，发送数据	
		SET_CLK;	
		__nop();
	}	
}</code></pre> 
<p>TM1620初始化函数：</p> 
<pre><code class="language-cs">/*
	* @name   TM1620_Init
	* @brief  TM1620初始化
	* @param  None
	* @retval None      
*/
static void TM1620_Init() 
{
	uint8_t i = 0;
	
	//设置显示模式
	TM1620_Write_Byte(Disp_Mode_GRID6_SEG8); 
	SET_STB;  
	
    //设置地址自动增加模式
	TM1620_Write_Byte(Write_Data_Addr_Auto_Add); 
	SET_STB;
	
	//利用循环清除显示寄存器地址
	TM1620_Write_Byte(Disp_SFR_Addr_00H); //首地址

	for(i=0;i&lt;Disp_SFR_Addr_Num;i++)
		TM1620_Write_Byte(0x00); 
    SET_STB; 

	//调节数码管辉度
    TM1620_Write_Byte(Display.Brightness);
	SET_STB; 
}</code></pre> 
<p>数码管显示函数：</p> 
<pre><code class="language-cs">/*
	* @name   Disp
	* @brief  数码管显示
  * @param  Disp_NUM:       数码管编号
            Dat             数据0~F
            Disp_DP_Status  小数点显示状态
	* @retval None      
*/
static void Disp(Disp_NUM_t Disp_NUM,uint8_t Dat,Disp_DP_Status_t Disp_DP_Status) 
{
	//检查参数范围
	if(Dat &gt; 0x0F)
	{
		System.Assert_Failed();
	}
	
	//设置显示模式
	TM1620_Write_Byte(Disp_Mode_GRID6_SEG8); 
	SET_STB;
	
	//设置地址固定模式
	TM1620_Write_Byte(Write_Data_Addr_Fix); 
	SET_STB;
	
	//写地址（数码管编号）
	TM1620_Write_Byte(Disp_NUM);
	//写数据，并判断有无小数点
	if(Disp_DP_Status == Disp_DP_ON)
		TM1620_Write_Byte(Disp_Decode[Dat] + 0x80); 
    //Disp_Decode数组存贮的是数码管显示“0”~“F”的译码。
	else
		TM1620_Write_Byte(Disp_Decode[Dat]);
	SET_STB;
	
	//设置辉度
  TM1620_Write_Byte(Display.Brightness);
	SET_STB; 
}</code></pre> 
<p> 外部中断0回调函数：</p> 
<pre><code class="language-cs">void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	if(GPIO_Pin == KEY1_Pin)
	{
		LED.LED_Flip(LED2);
		
		switch(Display.Brightness)
		{
			case Brightness_level_1: Display.Brightness = Brightness_level_2; break;
			case Brightness_level_2: Display.Brightness = Brightness_level_3; break;
			case Brightness_level_3: Display.Brightness = Brightness_level_4; break;
			case Brightness_level_4: Display.Brightness = Brightness_level_5; break;
			case Brightness_level_5: Display.Brightness = Brightness_level_6; break;
			case Brightness_level_6: Display.Brightness = Brightness_level_7; break;
			case Brightness_level_7: Display.Brightness = Brightness_level_8; break;
			case Brightness_level_8: Display.Brightness = Brightness_level_1; break;
			default: Display.Brightness = Brightness_level_3;
		}
	}
}</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cbc5859e6be87ee72886038523912917/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Luogu P4107 [HEOI2015] 兔子与樱花</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be2fa9b7264478b6e05744b38e282adb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一篇文章带你弄懂Kafka基本原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>