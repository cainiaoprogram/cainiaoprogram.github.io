<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>efm32 c语言1 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="efm32 c语言1" />
<meta property="og:description" content="寥寥数笔，记录我的C语言盲点笔记，只为曾经经历过，亦有误，可交流。
1.typedef来定义一个函数指针类型的方法，定义一个新的函数指针类型。 ：建立一个类型别名的方法很简单，在传统的变量声明表达式里用类型名替代变量名，然后把关键字typedef加在该语句的开头”。
typedef int (*PFUN)(): 定义PFUN这个函数指针类型,由编译器自动来完成，比如PFUN pfun;定义了一个函数指针，类似于抽象出一种新的变量类型。
typedef unsigned short (*pTaskEventHandlerFn)( unsigned char task_id, unsigned short event );
pTaskEventHandlerFn tasksArr[];//申明函数指针的数组
使用typedef将一个类型名字替代原先申明时的变量名，然后类型名可以用来申明定义变量。
2.有初始化的数组定义可以省略方括号中的数组大小。
例如，下面的代码中数组定义为5个元素：
int a[]={2，4，6，8，10}；
编译时必须知道数组的大小。通常，声明数组时方括号内的数字决定了数组的大小。有初始化的数组定义又省略方括号中的数组大小时，编译器统计花括号之间的元素个数，以求出数组的大小。
例如，下面的代码产生相同的结果：
static int a1[5]={1，2，3，4，5};
static int a2[]={1，2，3，4，5}；
2，栈顶一般为低地址，函数入栈一般参数从右往左进行。
3.for(a;b;c){e}执行顺序：
先进行a, 然后是b, 执行e, 在执行c.进一步执行b,执行e,c.直到b不再满足退出循环。
4.union数据类型，内存是重叠的，完全一样
typedef union {
uint32 time32;
uint16 time16[2];
uint8 time8[4];
} osalTime_t;
对time32的赋值后，访问其他类型时依旧是原来的内存。三个成员占据一样的数据空间，起始地址都是一样的，一旦一个成员数值变化就会出现其他成员取值也发生变化
5.inline内联函数总结
内联函数具有代码量小且直接编译进可执行文件中，不进行call调用，也就是在不同的文件的函数如果调用内联函数，则不同的函数都会出现该内联函数的可执行代码。
但是，如果不重复调用的话，内联函数带来的好处就是执行更加快速，无需再call，以及函数参数的出入栈SP，保护栈帧，跳出函数，清空栈帧等各种耗时。起到快速执行的效果。故内联函数的代码量都较小。
总之是以增加执行文件大小来获取程序执行速度的提高。
6.（int *）0，表示指向一个整形的地址，地址值为0，即空指针所在的地方，该处一般不允许写操作，以免破坏系统，但可以读取。
7.如果一个函数要被其他文件中函数使用，定义时加extern关键字，在没有加extern和static关键字时，一般编译器会默认是extern类型的，因此你在其他函数里调用也可以使用。
8.结构体之offsetof宏详细解析 ，#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE*)0)-&gt;MEMBER) (include/linux/stddef.h)
9.32位机读取一个字节，实际底层的汇编做了进一步的处理。
比如读取一个字节，实际返回的是一个32位，经过屏蔽移位取得你要的地址所在的数。写入时也一样，会先保持4字节其他字节不变，然后单独把要写入的字节做改变。由编译器根据你的数据类型来完成实际的实现。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2ee2261a1d49cd77650a5b0274436bf3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-24T09:50:45+08:00" />
<meta property="article:modified_time" content="2017-06-24T09:50:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">efm32 c语言1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>寥寥数笔，记录我的C语言盲点笔记，只为曾经经历过，亦有误，可交流。</p> 
1.typedef来定义一个函数指针类型的方法，定义一个新的函数指针类型。 
<p>：建立一个类型别名的方法很简单，在传统的变量声明表达式里用类型名替代变量名，然后把关键字typedef加在该语句的开头”。</p> 
<p>typedef int (*PFUN)(): 定义PFUN这个函数指针类型,由编译器自动来完成，比如PFUN pfun;定义了一个函数指针，类似于抽象出一种新的变量类型。</p> 
<p>typedef unsigned short (*pTaskEventHandlerFn)( unsigned char task_id, unsigned short event );<br> </p> 
<p>pTaskEventHandlerFn tasksArr[];//申明函数指针的数组</p> 
<p>使用typedef将一个类型名字替代原先申明时的变量名，然后类型名可以用来申明定义变量。</p> 
<p>2.有初始化的数组定义可以省略方括号中的数组大小。</p> 
<p>例如，下面的代码中数组定义为5个元素：<br> int a[]={2，4，6，8，10}；<br> <strong>编译时必须知道数组的大小。</strong>通常，声明数组时方括号内的数字决定了数组的大小。有初始化的数组定义又省略方括号中的数组大小时，编译器统计花括号之间的元素个数，以求出数组的大小。<br> 例如，下面的代码产生相同的结果：<br> static int a1[5]={1，2，3，4，5};<br> static int a2[]={1，2，3，4，5}；</p> 
<p>2，栈顶一般为低地址，函数入栈一般参数从右往左进行。</p> 
<p>3.for(a;b;c){e}执行顺序：</p> 
<p>先进行a, 然后是b, 执行e, 在执行c.进一步执行b,执行e,c.直到b不再满足退出循环。</p> 
<p>4.union数据类型，内存是重叠的，完全一样</p> 
<p>typedef union {<!-- --><br>   uint32 time32;<br>   uint16 time16[2];<br>   uint8 time8[4];<br> } osalTime_t;</p> 
<p>对time32的赋值后，访问其他类型时依旧是原来的内存。三个成员占据一样的数据空间，起始地址都是一样的，一旦一个成员数值变化就会出现其他成员取值也发生变化</p> 
<p>5.inline内联函数总结</p> 
<p>内联函数具有代码量小且直接编译进可执行文件中，不进行call调用，也就是在不同的文件的函数如果调用内联函数，则不同的函数都会出现该内联函数的可执行代码。</p> 
<p>但是，如果不重复调用的话，内联函数带来的好处就是执行更加快速，无需再call，以及函数参数的出入栈SP，保护栈帧，跳出函数，清空栈帧等各种耗时。起到快速执行的效果。故内联函数的代码量都较小。</p> 
<p>总之是以增加执行文件大小来获取程序执行速度的提高。</p> 
<p>6.（int *）0，表示指向一个整形的地址，地址值为0，即空指针所在的地方，该处一般不允许写操作，以免破坏系统，但可以读取。</p> 
<p>7.如果一个函数要被其他文件中函数使用，定义时加extern关键字，在没有加extern和static关键字时，一般编译器会默认是extern类型的，因此你在其他函数里调用也可以使用。</p> 
<p>8.结构体之offsetof宏详细解析 ，#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE*)0)-&gt;MEMBER) (include/linux/stddef.h)</p> 
<p>9.32位机读取一个字节，实际底层的汇编做了进一步的处理。</p> 
<p>比如读取一个字节，实际返回的是一个32位，经过屏蔽移位取得你要的地址所在的数。写入时也一样，会先保持4字节其他字节不变，然后单独把要写入的字节做改变。由编译器根据你的数据类型来完成实际的实现。</p> 
<p>32字节的读取最为高效。</p> 
<p>10.中断发生时，未完成服务程序的处理时，将会忽略挂起Pending，优先级高的中断可以获取中断使用权。</p> 
<p>另一个同样的中断发生，直到当前中断处理完成，才允许再次中断进入。</p> 
<p>11.switch case误区。</p> 
<p>switch case往往对不同的命令进行分类操作，但是如果出现遇到对应case做完处理后，如果没有遇到break就会接着默认执行下面的case内容（不再去case，因为只有刚进入switch才会去匹配case，已经进入后，case匹配忽略）。直到遇到带break后为止跳出case，否则一直执行完。</p> 
<p>因为只在第一次才做switch判断跳到对应的内容去执行。所以，好的程序基本是需要break的，但是有些情况（多个情况对应处理的内容要一样，即前面的几个类型可以不做处理，不需要break，直到最后一个做处理，实现多个类型执行相同的功能，但不增加代码量，更直接）。</p> 
<p>总之，只有在第一次才做判断与选择，进入以后就是安装顺序执行，不break会一直执行到switch结束</p> 
<p>12 C语言中的感叹号！逻辑取反，不同于~的按位取反</p> 
<p>！=：表示不等于。！(1)表示为0，！(0)表示为1，有取反之意，但只能用在0和1上面。不等于0的会变为0，等于0的变为1</p> 
<p>13.C语言+和&lt;&lt;遇到的一个BUG问题。</p> 
<p>在这里+的优先级高于&lt;&lt;左右移。所以比如a&lt;&lt;8+b,实际是从右往左赋值，8+b相加后来移动a,所以不实现两个字节合并为一个16位的数据。故要加(a&lt;&lt;8)+b才能实现本来的意图，这个误区需要注意。</p> 
<p>14.：#define PINMUX0_31_28 0x00000001u，0x00000001UL</p> 
<p>u表示无符号，UL unsigned long int 32位，unsigned long long 64位</p> 
<p>15数组指针和指针数组的区别</p> 
<p>数组指针，为一个指针，int (*a)[10];指向一个数组，类似于函数指针</p> 
<p>指针数组，为一个数组，int* a[10];类似于指针函数，返回的是一个指针。</p> 
<p>16.window下面绝对路径的文件需要用双斜杠来表示//</p> 
<p>17 printf("c=%#x/n",c);什么意思？</p> 
<pre><span style="font-family:monospace; color:#ff4635"><span style="white-space:pre">%#表示的输出提示方式，如果是8进制，在前面加0，如果是十进制，不加任何字符，如果是十六进制，会自动加上0x</span></span></pre> 
<p>18 静态变量在编译的时候初始化，所以初值必须是常量（可以是常数、定义成常数的宏、C++编译器中用const修饰的常量），静态变量不能用变量赋初始值，但在运行时是可以用变量赋值的。</p> 
<p>19 assert函数，用于判断是否为真，满足就继续执行，不然直接终止程序的运行</p> 
<p>20.做到4个字节对齐，使用如下方式：</p> 
<p>((CSL_CacheRegsOvly)CSL_CACHE_REGS)-&gt;L1DIWC  = ((byteCnt+3)&gt;&gt;2);</p> 
<p>字节数不为4的倍数时，需要多保留一个字的数量，故加3，1+3，2+3,3+3.4字节对齐的方式，</p> 
<p>获得4字节对齐后的字节数字：</p> 
<p>byte_num = (byte + 3) &amp; 0xfc; 这样字节数必为4的倍数。</p> 
<p>21 for循环中如果break，则i++不再执行。</p> 
<p>22.temp = (temp+1)&amp;7.表示temp从0到7变化，循环。类似于temp=8时赋值回0.</p> 
<p>23.unsigned char *p;</p> 
<p>unsigned char a[];</p> p=a;这样正确。 
<p>unsigned int p1= a；错误，因为是指针类型赋值给了整形的数据类型，类型不匹配。</p> 
<p>unsigned char * p[10]:申明一个指针数组，10个指针，每个指针指向char类型的空间。</p> 
<p>unsigned char (*p)[10]申明一个数组指针，指向含有10个char类型的空间，指针维护一个10的空间，偏移1加10个空间。</p> 24. 
<p>多个if会进行分支处理，分别判断后进行是否执行。</p> 
<p>而if 和多个else if等配合时，一旦出现某个满足条件时，不再执行下面的else if的判断，确保只进入一个分支。</p> 
<p>25. char a[3][4]. char **p =a;出现编译错误，类型不匹配不能赋值</p> 
<p>因为a表示的是一个指向一维数组的指针，即char (*a)[3]这个类型.a+1是会偏移3个单位。</p> 
<p>p是一个指针的指针，称为二级指针。所以两者类型不一样。</p> 
<p>26.数组名取地址</p> 
<p>在《C和指针》p142中说到，在以下两中场合下，数组名并不是用指针常量来表示，就是当数组名作为sizeof操作符和单目操作符&amp;的操作数时。 sizeof返回整个数组的长度，而不是指向数组的指针的长度。 取一个数组名的地址所产生的是一个指向数组的指针，而不是一个指向某个指针常量的指针。<br> 所以&amp;a后返回的指针便是指向数组的指针（类似于（*p)[3]），跟a（一个指向a[0]元素的指针）在指针的类型上是有区别的。&amp;a+1是偏移一个数组sizeof大小的尺寸，因为&amp;a是指向数组指针的地址，是一个数值指针。</p> 
<p>但是作为形参时，一级数组名就转为了一个普通的一级指针而已。</p> 
<p>27. 二维数组名不能简单的理解为2级指针，而是要从数组的系统结构上去了解。</p> 
<p>个人认为二维数组名其实就是一个指针，但是他指向的数据类型是一维数组的这么个数据类型。即数值指针，其实可以理解为功能和二维数组名类似。至于数据访问，完全是编译器来自动完成栈区的访问。</p> 
<p>28.数值名不能修改，是因为在栈区域内已经定好了ebp，基地址。访 问数组都是基于这个ebp来进行的。所以，给数组名赋值变得没有意义，肯定不允许修改ebp的。所以在编译阶段就报错。</p> 29. 
<p>fseek和发tell配合来完成确定文件大小的过程。</p> 
<p>fseek(fPtr,0,SEEK_END);</p> 
<p>file_size = ftell(fPtr);</p> 
<p>fseek(fPtr,0,SEEK_SET），位置指针复位进行读写操作</p> 
<p>30.两数交换不使用第三个缓冲区，三条代码的方法：主要通过运算符来实现。</p> A = A^B;B = A^B;A = B^A;A = A+B;B = A-B;A = A-B;
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51dfa65813268a81037fc1fb9040220b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WebRTC的噪声抑制（noise suppression，NS）算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/641fde601d75734de8c44bd150d4d7c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java实用方法系列 从源数组考贝到目标数组 边界检查的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>