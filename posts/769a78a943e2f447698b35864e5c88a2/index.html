<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity | HybridCLR 热更新（Windows端） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity | HybridCLR 热更新（Windows端）" />
<meta property="og:description" content="目录
一、准备工作
1.环境相关
2.Unity中配置
二、热更新
1.创建 HotUpdate 热更新模块
2.安装和配置HybridCLR
3.配置PlayerSettings
4.创建热更新相关脚本
5.打包dll
6.测试热更新
三、官方文档
四、补充
1. 调用非静态成员函数
2. 官方示例项目
★ LoadDll流程解释
一、准备工作 1.环境相关 安装git环境。Win下需要安装visual studio 2019或更高版本。安装时至少要包含 使用Unity的游戏开发 和 使用c&#43;&#43;的游戏开发 组件。 本文涉及到的Unity版本是2022.3.14f1c1。unity模块必须安装 Windows端：Windows Build Support(IL2CPP)或Mac端：Mac Build Support(IL2CPP)
2.Unity中配置 在unity中创建场景main，并配置好脚本ConsoleToScreen.cs，它可以打印日志到屏幕上，方便定位错误。 using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class ConsoleToScreen : MonoBehaviour { const int maxLines = 50; const int maxLineLength = 120; private string _logStr = &#34;&#34;; private readonly List&lt;string&gt; _lines = new List&lt;string&gt;(); public int fontSize = 15; void OnEnable() { Application." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/769a78a943e2f447698b35864e5c88a2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-10T16:21:11+08:00" />
<meta property="article:modified_time" content="2024-01-10T16:21:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity | HybridCLR 热更新（Windows端）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" rel="nofollow">一、准备工作</a></p> 
<p id="1.%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3-toc" style="margin-left:40px;"><a href="#1.%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3" rel="nofollow">1.环境相关</a></p> 
<p id="2.Unity%E4%B8%AD%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#2.Unity%E4%B8%AD%E9%85%8D%E7%BD%AE" rel="nofollow">2.Unity中配置</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%83%AD%E6%9B%B4%E6%96%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%83%AD%E6%9B%B4%E6%96%B0" rel="nofollow">二、热更新</a></p> 
<p id="1.%E5%88%9B%E5%BB%BA%20HotUpdate%20%E7%83%AD%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%9D%97-toc" style="margin-left:40px;"><a href="#1.%E5%88%9B%E5%BB%BA%20HotUpdate%20%E7%83%AD%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%9D%97" rel="nofollow">1.创建 HotUpdate 热更新模块</a></p> 
<p id="2.%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEHybridCLR-toc" style="margin-left:40px;"><a href="#2.%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEHybridCLR" rel="nofollow">2.安装和配置HybridCLR</a></p> 
<p id="3.%E9%85%8D%E7%BD%AEPlayerSettings-toc" style="margin-left:40px;"><a href="#3.%E9%85%8D%E7%BD%AEPlayerSettings" rel="nofollow">3.配置PlayerSettings</a></p> 
<p id="4.%E5%88%9B%E5%BB%BA%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9B%B8%E5%85%B3%E8%84%9A%E6%9C%AC-toc" style="margin-left:40px;"><a href="#4.%E5%88%9B%E5%BB%BA%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9B%B8%E5%85%B3%E8%84%9A%E6%9C%AC" rel="nofollow">4.创建热更新相关脚本</a></p> 
<p id="5.%E6%89%93%E5%8C%85dll-toc" style="margin-left:40px;"><a href="#5.%E6%89%93%E5%8C%85dll" rel="nofollow">5.打包dll</a></p> 
<p id="%C2%A06.%E6%B5%8B%E8%AF%95%E7%83%AD%E6%9B%B4%E6%96%B0-toc" style="margin-left:40px;"><a href="#%C2%A06.%E6%B5%8B%E8%AF%95%E7%83%AD%E6%9B%B4%E6%96%B0" rel="nofollow">6.测试热更新</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" rel="nofollow">三、官方文档</a></p> 
<p id="%E5%9B%9B%E3%80%81%E8%A1%A5%E5%85%85-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E8%A1%A5%E5%85%85" rel="nofollow">四、补充</a></p> 
<p id="%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">1. 调用非静态成员函数</a></p> 
<p id="%C2%A02.%20%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE-toc" style="margin-left:40px;"><a href="#%C2%A02.%20%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE" rel="nofollow"> 2. 官方示例项目</a></p> 
<p id="%E2%98%85%20LoadDll%E6%B5%81%E7%A8%8B%E8%A7%A3%E9%87%8A-toc" style="margin-left:80px;"><a href="#%E2%98%85%20LoadDll%E6%B5%81%E7%A8%8B%E8%A7%A3%E9%87%8A" rel="nofollow">★ LoadDll流程解释</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2><span style="color:#333333;">一、准备工作</span></h2> 
<h3 id="1.%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3"><span style="color:#333333;">1.环境相关</span></h3> 
<ul><li><span style="color:#333333;">安装git环境。</span></li><li><span style="color:#333333;">Win下需要安装visual studio 2019或更高版本。安装时至少要包含 使用Unity的游戏开发 和 使用c++的游戏开发 组件。</span></li><li> <p><span style="color:#333333;">本文涉及到的Unity版本是2022.3.14f1c1。unity模块必须安装 Windows端：Windows Build Support(IL2CPP)或Mac端：Mac Build Support(IL2CPP)</span></p> </li></ul> 
<h3 id="2.Unity%E4%B8%AD%E9%85%8D%E7%BD%AE">2.Unity中配置</h3> 
<ul><li>在unity中创建场景main，并配置好脚本ConsoleToScreen.cs，它可以打印日志到屏幕上，方便定位错误。</li></ul> 
<pre><code class="language-cs">using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ConsoleToScreen : MonoBehaviour
{
	const int maxLines = 50;
    const int maxLineLength = 120;
    private string _logStr = "";

    private readonly List&lt;string&gt; _lines = new List&lt;string&gt;();

    public int fontSize = 15;

    void OnEnable() { Application.logMessageReceived += Log; }
    void OnDisable() { Application.logMessageReceived -= Log; }


    public void Log(string logString, string stackTrace, LogType type)
    {
        foreach (var line in logString.Split('\n'))
        {
            if (line.Length &lt;= maxLineLength)
            {
                _lines.Add(line);
                continue;
            }
            var lineCount = line.Length / maxLineLength + 1;
            for (int i = 0; i &lt; lineCount; i++)
            {
                if ((i + 1) * maxLineLength &lt;= line.Length)
                {
                    _lines.Add(line.Substring(i * maxLineLength, maxLineLength));
                }
                else
                {
                    _lines.Add(line.Substring(i * maxLineLength, line.Length - i * maxLineLength));
                }
            }
        }
        if (_lines.Count &gt; maxLines)
        {
            _lines.RemoveRange(0, _lines.Count - maxLines);
        }
        _logStr = string.Join("\n", _lines);
    }

    void OnGUI()
    {
        GUI.matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity,
           new Vector3(Screen.width / 1200.0f, Screen.height / 800.0f, 1.0f));
        GUI.Label(new Rect(10, 10, 800, 370), _logStr, new GUIStyle() { fontSize = Math.Max(10, fontSize) });
    }

}
</code></pre> 
<ul><li>在Build Settings中添加main场景到打包场景列表。</li></ul> 
<h2 id="%E4%BA%8C%E3%80%81%E7%83%AD%E6%9B%B4%E6%96%B0">二、热更新</h2> 
<h3 id="1.%E5%88%9B%E5%BB%BA%20HotUpdate%20%E7%83%AD%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%9D%97">1.创建 HotUpdate 热更新模块</h3> 
<ul><li>创建 Assets/HotUpdate 目录（目录名称不做要求，可随便起）</li><li>在HotUpdate 目录下右键 Create/Assembly Definition，创建一个名为HotUpdate（名称不做要求）的程序集模块。</li></ul> 
<blockquote> 
 <p><span style="color:#fe2c24;">        当自己创建一个新的程序集定义文件（.asmdef）时，该文件所在目录以及其子目录下的所有C#脚本都会被默认包含进这个新的程序集中。但是，如果子目录下有另一个.asmdef文件，则那个子目录将会成为另一个独立的程序集。</span></p> 
</blockquote> 
<h3 id="2.%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEHybridCLR">2.安装和配置HybridCLR</h3> 
<ul><li>主菜单中点击Windows/Package Manager打开包管理器。点击Add package from git URL...，填入https://gitee.com/focus-creative-games/hybridclr_unity.git 或 https://github.com/focus-creative-games/hybridclr_unity.git。</li><li>打开菜单HybridCLR/Installer...， 点击安装按钮进行安装。安装完成后会在最后打印 安装成功日志。</li></ul> 
<p class="img-center"><img alt="" height="170" src="https://images2.imgbox.com/5d/41/HlhblsGZ_o.png" width="666"></p> 
<ul><li>配置HybridCLR：打开菜单ProjectSetting / HybridCLR Settings， 在Hot Update Assemblies配置项中添加HotUpdate程序集。</li></ul> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/01/5a/EoxRQ4tL_o.png" width="666"></p> 
<h3 id="3.%E9%85%8D%E7%BD%AEPlayerSettings">3.配置PlayerSettings</h3> 
<ul><li>如果你用的hybridclr包低于v4.0.0版本，需要关闭增量式GC(Use Incremental GC) 选项</li><li>Scripting Backend 切换为 IL2CPP</li><li>Api Compatability Level 切换为 .Net 4.x(Unity 2019-2020) 或 .Net Framework（Unity 2021+）</li></ul> 
<p class="img-center"><img alt="" height="292" src="https://images2.imgbox.com/31/b2/9uGB9iv1_o.png" width="666"></p> 
<h3 id="4.%E5%88%9B%E5%BB%BA%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9B%B8%E5%85%B3%E8%84%9A%E6%9C%AC">4.创建热更新相关脚本</h3> 
<ul><li>创建 Assets/HotUpdate/Hello.cs 文件，该文件用于测试是否热更新：</li></ul> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Hello : MonoBehaviour
{
    public static void Run()
    {
        Debug.Log("Hello, HybridCLR, V1.0.0");
    }
}
</code></pre> 
<ul><li>创建Assets/LoadDll.cs脚本，用来加载热更新程序集：</li></ul> 
<pre><code class="language-cs">using HybridCLR;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;

public class LoadDll : MonoBehaviour
{
    void Start()
    {
        // Editor环境下，HotUpdate.dll.bytes已经被自动加载，不需要加载，重复加载反而会出问题。
#if !UNITY_EDITOR
        Assembly hotUpdateAss = Assembly.Load(File.ReadAllBytes($"{Application.streamingAssetsPath}/HotUpdate.dll.bytes"));
#else
        // Editor下无需加载，直接查找获得HotUpdate程序集
        Assembly hotUpdateAss = System.AppDomain.CurrentDomain.GetAssemblies().First(a =&gt; a.GetName().Name == "HotUpdate");
#endif
        //通过反射来调用热更新代码
        Type type = hotUpdateAss.GetType("Hello");
        if (type == null)
        {
            Debug.Log("Hello assembly is null");
        }
        else
        {
            type.GetMethod("Run").Invoke(null, null);
        }

    }
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>        HybridCLR是原生运行时实现，因此调用Assembly Assembly.Load(byte[])即可加载热更新程序集。（</strong>为了简化演示，我们不通过http服务器下载HotUpdate.dll，而是直接将HotUpdate.dll放到StreamingAssets目录下</span><span style="color:#fe2c24;"><strong>）</strong></span></p> 
<h3 id="5.%E6%89%93%E5%8C%85dll">5.打包dll</h3> 
<p>        如果配置正确，Editor运行和打包后运行的效果一样。</p> 
<ul><li><span style="color:#fe2c24;">运行菜单 HybridCLR/Generate/All 进行必要的生成操作</span>。</li><li>将{proj}/HybridCLRData/HotUpdateDlls/StandaloneWindows64(MacOS下为StandaloneMacXxx)目录下的HotUpdate.dll复制到Assets/StreamingAssets/HotUpdate.dll.bytes，<span style="color:#fe2c24;">注意，要加.bytes后缀</span>。</li></ul> 
<p class="img-center"><img alt="" height="451" src="https://images2.imgbox.com/8f/5e/JLrAJnV4_o.png" width="666"></p> 
<ul><li>打开Build Settings对话框，点击Build And Run，打包并且运行热更新示例工程。</li></ul> 
<p>        如果打包成功，并且屏幕上显示 'Hello, HybridCLR, V1.0.0'，表示热更新代码被顺利执行！</p> 
<p class="img-center"><img alt="" height="371" src="https://images2.imgbox.com/e9/ce/SbNgBxSK_o.png" width="666"></p> 
<h3 id="%C2%A06.%E6%B5%8B%E8%AF%95%E7%83%AD%E6%9B%B4%E6%96%B0">6.测试热更新</h3> 
<ul><li>修改Assets/HotUpdate/Hello.cs的Run函数中Debug.Log("Hello, HybridCLR, V1.0.0");代码，改成Debug.Log("Hello, HybridCLR, V1.1.0");。</li><li><span style="color:#fe2c24;">运行菜单命令HybridCLR/CompileDll/ActiveBulidTarget重新编译热更新代码</span>。</li><li>将{proj}/HybridCLRData/HotUpdateDlls/StandaloneWindows64(MacOS下为StandaloneMacXxx)目录下的HotUpdate.dll复制为刚才的打包输出目录的 XXX_Data/StreamingAssets/HotUpdate.dll.bytes。</li><li>重新运行程序，会发现屏幕中显示Hello, HybridCLR, V1.1.0，表示热更新代码生效了！</li></ul> 
<p class="img-center"><img alt="" height="374" src="https://images2.imgbox.com/9d/05/DvVHt3jk_o.png" width="666"></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3">三、官方文档</h2> 
<ul><li><a href="https://hybridclr.doc.code-philosophy.com/docs/beginner/quickstart#%E5%88%9B%E5%BB%BA-hotupdate-%E7%83%AD%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%9D%97" rel="nofollow" title="快速上手 | HybridCLR">快速上手 | HybridCLR</a></li></ul> 
<h2 id="%E5%9B%9B%E3%80%81%E8%A1%A5%E5%85%85">四、补充</h2> 
<h3 id="%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" style="background-color:transparent;">1. 调用非静态成员函数</h3> 
<p>        修改Hello.cs为如下：</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Hello
{
    public static void Run()
    {
        Debug.Log("Hello, HybridCLR, V1.1.0");
    }
    public void TestNonStatic()
    {
        Debug.Log("Hello, HybridCLR, 非静态成员函数");
    }
}</code></pre> 
<p>         LoadDll.cs代码如下：</p> 
<pre><code class="language-cs">        Type type = hotUpdateAss.GetType("Hello");
        if (type == null)
        {
            Debug.Log("Hello is null");
        }
        else
        {
            type.GetMethod("Run").Invoke(null, null);
            //调用TestNonStatic
            type.GetMethod("TestNonStatic").Invoke(Activator.CreateInstance(type), null);
        }</code></pre> 
<blockquote> 
 <p>        GetMethod会返回一个MethodInfo 对象，但不能直接方法一样调用它，因为 MethodInfo 是一个描述方法的元数据对象，而不是方法本身。此时需要用到Invoke方法。</p> 
 <p><code>  Invoke</code>方法的第一个参数是要对其调用方法的对象（如果调用静态方法，则为<code>null</code>），第二个参数是一个<code>object[]</code>数组，包含要传递给方法的参数。如果方法不需要参数，则传递<code>null</code>或空数组。 </p> 
</blockquote> 
<p>        需要注意Hello类不可继承自MonoBehaviour，否则会警告：You are trying to create a MonoBehaviour using the 'new' keyword.  This is not allowed.  MonoBehaviours can only be added using AddComponent(). Alternatively, your script can inherit from ScriptableObject or no base class at all.</p> 
<blockquote> 
 <p>        因为在Unity中，MonoBehaviour是一种特殊的类，它代表附加到游戏对象上的组件。要创建并添加一个新的MonoBehaviour到一个GameObject上，需要使用AddComponent()方法。</p> 
 <p>        如果想要创建一个没有任何依赖性或者不需要附加到特定游戏对象上的类，那么将其改为继承自 ScriptableObject 或者没有基类都是可行的。</p> 
</blockquote> 
<h3 id="%C2%A02.%20%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE"> 2. 官方示例项目</h3> 
<ul><li><a href="https://gitee.com/focus-creative-games" rel="nofollow" title="https://gitee.com/focus-creative-games">https://gitee.com/focus-creative-games</a></li></ul> 
<p class="img-center"><img alt="" height="275" src="https://images2.imgbox.com/50/81/7ZsM75Rh_o.png" width="666"></p> 
<p class="img-center"><img alt="" height="404" src="https://images2.imgbox.com/f4/7d/eg1RuknX_o.png" width="333"></p> 
<ul><li>HotUpdate：热更新代码模块</li><li>Main：AOT主包模块，对应常规项目的主项目，资源更新模块</li></ul> 
<p>        根据文档进行操作：</p> 
<p class="img-center"><img alt="" height="389" src="https://images2.imgbox.com/89/e5/wIzbpnTv_o.png" width="666"></p> 
<p> 运行结果：</p> 
<p class="img-center"><img alt="" height="372" src="https://images2.imgbox.com/e6/61/BUKARFOE_o.png" width="666"></p> 
<h4 id="%E2%98%85%20LoadDll%E6%B5%81%E7%A8%8B%E8%A7%A3%E9%87%8A">★ LoadDll流程解释</h4> 
<p>        首先，通过UnityWebRequest加载五个文件，包括热更新模块的2个文件："prefabs"、 "HotUpdate.dll.bytes" 和AOT主包模块的三个文件："mscorlib.dll.bytes"、 "System.dll.bytes"、 "System.Core.dll.bytes"。</p> 
<p>        然后补充AOT模块的元数据，代码如下：</p> 
<pre><code class="language-cs"> private static void LoadMetadataForAOTAssemblies()
    {
        /// 注意，补充元数据是给AOT dll补充元数据，而不是给热更新dll补充元数据。
        /// 热更新dll不缺元数据，不需要补充，如果调用LoadMetadataForAOTAssembly会返回错误
        /// 
        HomologousImageMode mode = HomologousImageMode.SuperSet;
        foreach (var aotDllName in AOTMetaAssemblyFiles)
        {
            byte[] dllBytes = ReadBytesFromStreamingAssets(aotDllName);
            // 加载assembly对应的dll，会自动为它hook。一旦aot泛型函数的native函数不存在，用解释器版本代码
            LoadImageErrorCode err = RuntimeApi.LoadMetadataForAOTAssembly(dllBytes, mode);//用来加载预先编译的程序集的元数据，这样就可以在运行时为 AOT 泛型函数生成缺失的 native 函数。
            Debug.Log($"LoadMetadataForAOTAssembly:{aotDllName}. mode:{mode} ret:{err}");
        }
    }</code></pre> 
<blockquote> 
 <p>         AOT 编译过程中并不是所有的代码都能被直接转换成本地代码。例如，泛型类型和方法在编译时可能不会全部实例化，因为它们的具体类型可能直到运行时才能确定。<br>         因此，即使 DLL 文件中包含了元数据，HybridCLR 等运行时环境在执行 AOT 编译的程序集时，仍然需要额外的步骤来加载这些元数据。这样做的目的是为了：</p> 
 <ul><li>动态类型实例化：运行时可以使用元数据来动态地实例化泛型类型或方法，即使它们在 AOT 编译过程中没有被实例化。</li><li>反射支持：运行时可以使用元数据来支持反射操作，允许程序在运行时查询和操作类型信息。</li><li>完整性和安全性：确保运行时环境能够访问所有必要的类型信息，以保证程序的正常运行和安全性。</li></ul> 
 <p>        RuntimeApi.LoadMetadataForAOTAssembly 函数的作用就是在运行时加载这些必要的元数据，确保即使在 AOT 环境中，程序也能够正常使用泛型和反射等功能。</p> 
</blockquote> 
<p>        最后调用热更新模块中Entry类中的Start函数，并实例化Prefab：</p> 
<pre><code class="language-cs">    void StartGame()
    {
        LoadMetadataForAOTAssemblies();
#if !UNITY_EDITOR
        _hotUpdateAss = Assembly.Load(ReadBytesFromStreamingAssets("HotUpdate.dll.bytes"));
#else
        _hotUpdateAss = System.AppDomain.CurrentDomain.GetAssemblies().First(a =&gt; a.GetName().Name == "HotUpdate");
#endif
        Type entryType = _hotUpdateAss.GetType("Entry");
        entryType.GetMethod("Start").Invoke(null, null);

        Run_InstantiateComponentByAsset();
    }

    private static void Run_InstantiateComponentByAsset()
    {
        // 通过实例化assetbundle中的资源，还原资源上的热更新脚本
        AssetBundle ab = AssetBundle.LoadFromMemory(LoadDll.ReadBytesFromStreamingAssets("prefabs"));
        GameObject cube = ab.LoadAsset&lt;GameObject&gt;("Cube");
        GameObject.Instantiate(cube);
    }</code></pre> 
<pre><code class="language-cs">_hotUpdateAss = System.AppDomain.CurrentDomain.GetAssemblies().First(a =&gt; a.GetName().Name == "HotUpdate");</code></pre> 
<p>        这行代码用于从当前应用程序域中检索一个名为 "HotUpdate" 的程序集。</p> 
<ul><li> <p><strong><code>System.AppDomain.CurrentDomain：</code></strong>这部分引用了当前线程正在运行的应用程序域。在 .NET 中，应用程序域（AppDomain）是一个隔离的环境，用于运行应用程序代码，一个进程可以包含多个应用程序域。</p> </li><li> <p><strong><code>GetAssemblies()：</code></strong>这是 <code>AppDomain</code> 类的一个方法，返回当前应用程序域中已加载的程序集数组。程序集是包含代码和资源的单元，通常是以 DLL 或 EXE 形式存在。</p> </li><li> <p><strong><code>First(a =&gt; a.GetName().Name == "HotUpdate")</code>：</strong>这是一个 LINQ 查询表达式，它使用 <code>First</code> 方法来遍历程序集数组，并查找第一个其名称匹配 "HotUpdate" 的程序集。<code>a</code> 是一个范围变量，代表数组中的一个程序集。<code>a.GetName()</code> 获取程序集的名称，<code>a.GetName().Name</code> 获取程序集名称的字符串表示。如果没有找到任何匹配的程序集，<code>First</code> 方法将抛出一个异常。</p> </li><li> <p><strong><code>_hotUpdateAss</code>：</strong>这个变量用于存储找到的程序集。</p> </li></ul> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56a66c45bff91ba686cbe7e5b4a6ed76/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker（网络，网络通信，资源控制，数据管理，CPU优化，端口映射，容器互联）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/679569658c5775a3ceecb86bd606535e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1.10 Unity中的数据存储 XML</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>