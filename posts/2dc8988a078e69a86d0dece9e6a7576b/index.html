<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>jwt令牌的运行机制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="jwt令牌的运行机制" />
<meta property="og:description" content="一、jwt的组成部分 1、Header（头部） 常见的属性有：alg（签名加密使用的算法），typ（标识token，默认为JWT），是json字符串类型。
2、Payload（有效荷载） 用来承载传递的数据，是josn字符串类型。它的属性值对是Claim类，调用Payload的属性值对时，采用DecodedJWT类的getClaim方法，可以用asString方法转换成String类型。
3、Signture（签名） 就是使用base64编码后的header和payload数据，通过header中alg属性指定的算法进行加密生成哈希。
二、JWT运行机制 1、发送第一次请求，携带用户信息的username和password。当有拦截器拦截路径时，第一次访问只能访问未被拦截的地址。
//拦截器 @Configuration public class WebMvcConfig extends WebMvcConfigurationSupport { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new JWTInterceptor()) .addPathPatterns(&#34;/**&#34;) .excludePathPatterns(&#34;/login1&#34;); super.addInterceptors(registry); } } 2、当用户信息的username和password登录成功时，通过JWT工具生成token。在jwt工具中可以设置header和payload的属性，withClaim方法用来放入数据，sgin方法中放入使用算法（一般使用HMAC256算法，该算法需要设置盐值（密钥））签名加密。
//设置盐值（密钥） private static String salt=&#34;oiaho2h434&#34;; //生成token public static String createToken(LoginUser user){ LoginUser user1 = getLoginUser(); //创建一个JWT JWTCreator.Builder builder = JWT.create(); //设置JWT的头部 alg typ Map map1 = new HashMap(); map1.put(&#34;alg&#34;,&#34;HMAC256&#34;); map1.put(&#34;typ&#34;,&#34;JWT&#34;); builder.withHeader(map1); //设置 JWT的有效荷载 Payload Map map2 = new HashMap(); map2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2dc8988a078e69a86d0dece9e6a7576b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-18T23:56:16+08:00" />
<meta property="article:modified_time" content="2023-05-18T23:56:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">jwt令牌的运行机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、jwt的组成部分</h2> 
<h3>1、Header（头部）</h3> 
<p>        常见的属性有：alg（签名加密使用的算法），typ（标识token，默认为JWT），是json字符串类型。</p> 
<h3>2、Payload（有效荷载）</h3> 
<p>        用来承载传递的数据，是josn字符串类型。它的属性值对是Claim类，调用Payload的属性值对时，采用DecodedJWT类的getClaim方法，可以用asString方法转换成String类型。</p> 
<h3>3、Signture（签名）</h3> 
<p>        就是使用base64编码后的header和payload数据，通过header中alg属性指定的算法进行加密生成哈希。</p> 
<h2>二、JWT运行机制</h2> 
<p>1、发送第一次请求，携带用户信息的username和password。当有拦截器拦截路径时，第一次访问只能访问未被拦截的地址。</p> 
<pre><code class="language-java">//拦截器
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new JWTInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/login1");

        super.addInterceptors(registry);
    }
}</code></pre> 
<p>2、当用户信息的username和password登录成功时，通过JWT工具生成token。在jwt工具中可以设置header和payload的属性，withClaim方法用来放入数据，sgin方法中放入使用算法（一般使用HMAC256算法，该算法需要设置盐值（密钥））签名加密。</p> 
<pre><code class="language-java">//设置盐值（密钥）
private static String salt="oiaho2h434";

//生成token
    public static String createToken(LoginUser user){
        LoginUser user1 = getLoginUser();
        //创建一个JWT
        JWTCreator.Builder builder = JWT.create();
        //设置JWT的头部  alg typ
        Map map1 = new HashMap();
        map1.put("alg","HMAC256");
        map1.put("typ","JWT");
        builder.withHeader(map1);
        //设置 JWT的有效荷载  Payload
        Map map2 = new HashMap();
        map2.put("username",user1.getUsername());
        map2.put("password",user1.getPassword());
        builder.withPayload(map2);
        //给JWT加密
        builder.withClaim("salt",salt).withClaim("user",user.getUsername());
        String token = builder.sign(Algorithm.HMAC256(salt));
        return token;
    }</code></pre> 
<p>3、后端每次收到请求的时候，验证是否存在JWT 。如果存在，通过携带JWT 访问被拦截的路径，这时不会被拦截器拦截。JWT串会在JWT工具中被解析成用户信息，进行最终校验。主要是判断JWT中的token，需要注意token是否为null，token的报错信息。最后是解析过后的用户信息的判断用户是否存在，用户账号和密码是否一致。</p> 
<pre><code class="language-java">public static Map verifyToken(String token){

        //判断token是否为空
        if(token == null){
            System.out.println("token不能为空");
        }
        //把JWT进行解密 得到  DecodedJWT 这个就是JWT
        //JWT.build构建内部类
        JWTVerifier verifier = JWT.require(Algorithm.HMAC256(salt)).build();


        //解密的过程如果token出错了，有错误信息
        Map map = new HashMap();
        try {
         //   DecodedJWT decodedJWT = JWTUtils.verifyToken(token);

            DecodedJWT verify = verifier.verify(token);

            //从JWT对象中获取我需要的部分  有效荷载
            // 有效荷载 用户名+用户密码

            String username = verify.getClaim("username").asString();
            String password = verify.getClaim("password").asString();

            //如果出现错误：错误信息：用户相关的错误信息
            LoginUser user1 = getLoginUser();
            //判断用户是否存在
            if(username.equals(user1.getUsername())){
                //区判断用户的账号密码是否一致
                if (username.equals(user1.getUsername()) &amp;&amp; password.equals(user1.getPassword())){
                    map.put("success","true" );
                    map.put("msg","登录成功");
                }else{
                    map.put("msg","密码错误");
                }
            }else{
                map.put("msg","用户不存在");
            }

            return map;

        }catch (SignatureVerificationException e){
            map.put("msg","无效签名1");
        }catch (TokenExpiredException e){
            map.put("msg","token过期!");
        }catch (AlgorithmMismatchException e){
            map.put("msg","token加密算法不一致");
        }catch (Exception e){
            map.put("msg","无效签名2");
        }

        return map;

    }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a20ed9647ba80eedbdef1ec33a2f6520/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于 AT89C51 单片机的数字时钟设计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b19bd8d0d5ef93d2bc84c8e391dd7fb5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux的软链接具体如何使用？具体步骤是怎样的？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>