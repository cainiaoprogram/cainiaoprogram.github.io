<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis安装整理(window平台和Linux平台) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis安装整理(window平台和Linux平台)" />
<meta property="og:description" content="[b]window平台Redis安装 [/b] [b]redis windows安装文件下载地址[/b]:[url]http://code.google.com/p/servicestack/wiki/RedisWindowsDownload#Download_32bit_Cygwin_builds_for_Windows[/url] 我选择的redis为最新版的安装文件，见下图： [img]http://dl.iteye.com/upload/attachment/0065/8339/76cba281-426f-3be8-b739-089269408eae.jpg[/img] [b]Redis安装文件解压后，有以下几个文件。见下图[/b] [img]http://dl.iteye.com/upload/attachment/0065/8335/9992dac5-202b-3c46-b712-bb43e4eb66e5.jpg[/img] redis-server.exe：服务程序 redis-check-dump.exe：本地数据库检查 redis-check-aof.exe：更新日志检查 redis-benchmark.exe：性能测试，用以模拟同时由N个客户端发送M个 SETs/GETs 查询 (类似于 Apache 的ab 工具). 在解压好redis的安装文件到E:\根目录后，还需要在redis根目录增加一个redis的配置文件redis.conf，文件具体内容附件中有，不过这里我仍然把配置文件的内容贴上来： # Redis configuration file example
# By default Redis does not run as a daemon. Use &#39;yes&#39; if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
daemonize no
# When run as a daemon, Redis write a pid file in /var/run/redis.pid by default." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1ffd02d24c138c31498252019bcfc45b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-03-31T16:21:56+08:00" />
<meta property="article:modified_time" content="2012-03-31T16:21:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis安装整理(window平台和Linux平台)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    [b]window平台Redis安装 [/b] 
<br> 
<br>[b]redis windows安装文件下载地址[/b]:[url]http://code.google.com/p/servicestack/wiki/RedisWindowsDownload#Download_32bit_Cygwin_builds_for_Windows[/url] 
<br>我选择的redis为最新版的安装文件，见下图： 
<br>[img]http://dl.iteye.com/upload/attachment/0065/8339/76cba281-426f-3be8-b739-089269408eae.jpg[/img] 
<br> 
<br>[b]Redis安装文件解压后，有以下几个文件。见下图[/b] 
<br>[img]http://dl.iteye.com/upload/attachment/0065/8335/9992dac5-202b-3c46-b712-bb43e4eb66e5.jpg[/img] 
<br>redis-server.exe：服务程序 
<br>redis-check-dump.exe：本地数据库检查 
<br>redis-check-aof.exe：更新日志检查 
<br>redis-benchmark.exe：性能测试，用以模拟同时由N个客户端发送M个 SETs/GETs 查询 (类似于 Apache 的ab 工具). 
<br> 
<br>在解压好redis的安装文件到E:\根目录后，还需要在redis根目录增加一个redis的配置文件redis.conf，文件具体内容附件中有，不过这里我仍然把配置文件的内容贴上来： 
<br> 
<pre><code class="language-java"><br># Redis configuration file example<br><br># By default Redis does not run as a daemon. Use 'yes' if you need it.<br># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.<br>daemonize no<br><br># When run as a daemon, Redis write a pid file in /var/run/redis.pid by default.<br># You can specify a custom pid file location here.<br>pidfile /var/run/redis.pid<br><br># Accept connections on the specified port, default is 6379<br>port 6379<br><br># If you want you can bind a single interface, if the bind option is not<br># specified all the interfaces will listen for connections.<br>#<br># bind 127.0.0.1<br><br># Close the connection after a client is idle for N seconds (0 to disable)<br>timeout 300<br><br># Set server verbosity to 'debug'<br># it can be one of:<br># debug (a lot of information, useful for development/testing)<br># notice (moderately verbose, what you want in production probably)<br># warning (only very important / critical messages are logged)<br>loglevel debug<br><br># Specify the log file name. Also 'stdout' can be used to force<br># the demon to log on the standard output. Note that if you use standard<br># output for logging but daemonize, logs will be sent to /dev/null<br>logfile stdout<br><br># Set the number of databases. The default database is DB 0, you can select<br># a different one on a per-connection basis using SELECT &lt;dbid&gt; where<br># dbid is a number between 0 and 'databases'-1<br>databases 16<br><br>################################ SNAPSHOTTING  #################################<br>#<br># Save the DB on disk:<br>#<br>#   save &lt;seconds&gt; &lt;changes&gt;<br>#<br>#   Will save the DB if both the given number of seconds and the given<br>#   number of write operations against the DB occurred.<br>#<br>#   In the example below the behaviour will be to save:<br>#   after 900 sec (15 min) if at least 1 key changed<br>#   after 300 sec (5 min) if at least 10 keys changed<br>#   after 60 sec if at least 10000 keys changed<br>save 900 1<br>save 300 10<br>save 60 10000<br><br># Compress string objects using LZF when dump .rdb databases?<br># For default that's set to 'yes' as it's almost always a win.<br># If you want to save some CPU in the saving child set it to 'no' but<br># the dataset will likely be bigger if you have compressible values or keys.<br>rdbcompression yes<br><br># The filename where to dump the DB<br>dbfilename dump.rdb<br><br># For default save/load DB in/from the working directory<br># Note that you must specify a directory not a file name.<br>dir ./<br><br>################################# REPLICATION #################################<br><br># Master-Slave replication. Use slaveof to make a Redis instance a copy of<br># another Redis server. Note that the configuration is local to the slave<br># so for example it is possible to configure the slave to save the DB with a<br># different interval, or to listen to another port, and so on.<br>#<br># slaveof &lt;masterip&gt; &lt;masterport&gt;<br><br># If the master is password protected (using the "requirepass" configuration<br># directive below) it is possible to tell the slave to authenticate before<br># starting the replication synchronization process, otherwise the master will<br># refuse the slave request.<br>#<br># masterauth &lt;master-password&gt;<br><br>################################## SECURITY ###################################<br><br># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other<br># commands.  This might be useful in environments in which you do not trust<br># others with access to the host running redis-server.<br>#<br># This should stay commented out for backward compatibility and because most<br># people do not need auth (e.g. they run their own servers).<br>#<br># requirepass foobared<br><br>################################### LIMITS ####################################<br><br># Set the max number of connected clients at the same time. By default there<br># is no limit, and it's up to the number of file descriptors the Redis process<br># is able to open. The special value '0' means no limts.<br># Once the limit is reached Redis will close all the new connections sending<br># an error 'max number of clients reached'.<br>#<br># maxclients 128<br><br># Don't use more memory than the specified amount of bytes.<br># When the memory limit is reached Redis will try to remove keys with an<br># EXPIRE set. It will try to start freeing keys that are going to expire<br># in little time and preserve keys with a longer time to live.<br># Redis will also try to remove objects from free lists if possible.<br>#<br># If all this fails, Redis will start to reply with errors to commands<br># that will use more memory, like SET, LPUSH, and so on, and will continue<br># to reply to most read-only commands like GET.<br>#<br># WARNING: maxmemory can be a good idea mainly if you want to use Redis as a<br># 'state' server or cache, not as a real DB. When Redis is used as a real<br># database the memory usage will grow over the weeks, it will be obvious if<br># it is going to use too much memory in the long run, and you'll have the time<br># to upgrade. With maxmemory after the limit is reached you'll start to get<br># errors for write operations, and this may even lead to DB inconsistency.<br>#<br># maxmemory &lt;bytes&gt;<br><br>############################## APPEND ONLY MODE ###############################<br><br># By default Redis asynchronously dumps the dataset on disk. If you can live<br># with the idea that the latest records will be lost if something like a crash<br># happens this is the preferred way to run Redis. If instead you care a lot<br># about your data and don't want to that a single record can get lost you should<br># enable the append only mode: when this mode is enabled Redis will append<br># every write operation received in the file appendonly.log. This file will<br># be read on startup in order to rebuild the full dataset in memory.<br>#<br># Note that you can have both the async dumps and the append only file if you<br># like (you have to comment the "save" statements above to disable the dumps).<br># Still if append only mode is enabled Redis will load the data from the<br># log file at startup ignoring the dump.rdb file.<br>#<br># The name of the append only file is "appendonly.log"<br>#<br># IMPORTANT: Check the BGREWRITEAOF to check how to rewrite the append<br># log file in background when it gets too big.<br><br>appendonly no<br><br># The fsync() call tells the Operating System to actually write data on disk<br># instead to wait for more data in the output buffer. Some OS will really flush<br># data on disk, some other OS will just try to do it ASAP.<br>#<br># Redis supports three different modes:<br>#<br># no: don't fsync, just let the OS flush the data when it wants. Faster.<br># always: fsync after every write to the append only log . Slow, Safest.<br># everysec: fsync only if one second passed since the last fsync. Compromise.<br>#<br># The default is "always" that's the safer of the options. It's up to you to<br># understand if you can relax this to "everysec" that will fsync every second<br># or to "no" that will let the operating system flush the output buffer when<br># it want, for better performances (but if you can live with the idea of<br># some data loss consider the default persistence mode that's snapshotting).<br><br>appendfsync always<br># appendfsync everysec<br># appendfsync no<br><br>############################### ADVANCED CONFIG ###############################<br><br># Glue small output buffers together in order to send small replies in a<br># single TCP packet. Uses a bit more CPU but most of the times it is a win<br># in terms of number of queries per second. Use 'yes' if unsure.<br>glueoutputbuf yes<br><br># Use object sharing. Can save a lot of memory if you have many common<br># string in your dataset, but performs lookups against the shared objects<br># pool so it uses more CPU and can be a bit slower. Usually it's a good<br># idea.<br>#<br># When object sharing is enabled (shareobjects yes) you can use<br># shareobjectspoolsize to control the size of the pool used in order to try<br># object sharing. A bigger pool size will lead to better sharing capabilities.<br># In general you want this value to be at least the double of the number of<br># very common strings you have in your dataset.<br>#<br># WARNING: object sharing is experimental, don't enable this feature<br># in production before of Redis 1.0-stable. Still please try this feature in<br># your development environment so that we can test it better.<br># shareobjects no<br># shareobjectspoolsize 1024<br></code></pre> 
<br> 
<br>将附件中的redis_conf.rar解压下来放到redis的根目录中即可。到此，redis的安装已经完毕。下面开始使用redis数据库。 
<br> 
<br>[b]启动redis：[/b] 
<br>输入命令：redis-server.exe redis.conf 
<br>启动后如下图所示： 
<br>[img]http://dl.iteye.com/upload/attachment/0065/8348/f18c9013-4761-30c8-8377-3781e37e1cb8.jpg[/img] 
<br> 
<br>[color=red]启动cmd窗口要一直开着，关闭后则Redis服务关闭。[/color] 
<br>这时服务开启着，另外开一个窗口进行，设置客户端： 
<br>输入命令：redis-cli.exe -h 202.117.16.133 -p 6379 
<br>输入后如下图所示： 
<br>[img]http://dl.iteye.com/upload/attachment/0065/8358/ce41fd2b-8bdd-3876-af26-7bd14c4e05c2.jpg[/img] 
<br>然后可以开始玩了： 
<br> 
<br>设置一个Key并获取返回的值: 
<br> 
<pre><code class="language-java"><br>$ ./redis-cli set mykey somevalue<br>OK<br>$ ./redis-cli get mykey<br>Somevalue<br></code></pre> 
<br> 
<br>如何添加值到list: 
<br> 
<pre><code class="language-java"><br>$ ./redis-cli lpush mylist firstvalue<br>OK<br>$ ./redis-cli lpush mylist secondvalue<br>OK<br>$ ./redis-cli lpush mylist thirdvalue<br>OK<br>$ ./redis-cli lrange mylist 0 -1<br>. thirdvalue<br>. secondvalue<br>. firstvalue<br>$ ./redis-cli rpop mylist<br>firstvalue<br>$ ./redis-cli lrange mylist 0 -1<br>. thirdvalue<br>. secondvalue<br></code></pre> 
<br> 
<br>redis-benchmark.exe：性能测试，用以模拟同时由N个客户端发送M个 SETs/GETs 查询 (类似于 Apache 的 ab 工具). 
<br> 
<pre><code class="language-java"><br>./redis-benchmark -n 100000 –c 50<br>    ====== SET ======<br>    100007 requests completed in 0.88 seconds （译者注：100004 查询完成于 1.14 秒 ）<br>50 parallel clients （译者注：50个并发客户端）<br>3 bytes payload （译者注：3字节有效载荷)<br>keep alive: 1 （译者注：保持1个连接)<br>58.50% &lt;= 0 milliseconds（译者注：毫秒）<br>99.17% &lt;= 1 milliseconds<br>99.58% &lt;= 2 milliseconds<br>99.85% &lt;= 3 milliseconds<br>99.90% &lt;= 6 milliseconds<br>100.00% &lt;= 9 milliseconds<br>114293.71 requests per second（译者注：每秒 114293.71 次查询）<br></code></pre> 
<br>Windows下测试并发客户端极限为60 
<br> 
<br>======================================================================== 
<br> 
<br>[b]linux平台Redis安装：[/b] 
<br> 
<pre><code class="language-java"><br>wget http://code.google.com/p/redis/downloads/detail?name=redis-2.0.4.tar.gz<br>tar xvzf redis-2.0.4.tar.gz<br>cd  redis-2.0.4<br>make<br>mkdir /home/redis<br>cp redis-server  /home/redis<br>cp redis-benchmark  /home/redis<br>cp redis-cli  /home/redis<br>cp redis.conf  /home/redis<br>cd  /home/redis<br></code></pre> 
<br> 
<br>在安装过程中可能需要用到sudo命令，可能新装的redhat虚拟机中新用户还不能使用sudo命令，因此需要手动的修改/etc/sudoers文件，命令如下： 
<br> 
<pre><code class="language-java"><br>cd /etc<br>su root ##切换为root用户，同时输入密码<br>chmod u+w sudoers ##放开sudoers文件的写权限<br>##在root ALL = (ALL) ALL下面一行增加 "你的用户名" ALL = (ALL) ALL<br>:wq ##保存退出<br>chmod u-w sudoers ##取消修改权限<br></code></pre> 
<br> 
<br>启动 
<br>./redis-server redis.conf 
<br>进入命令交互模式，两种： 
<br>1: ./redis-cli 
<br>2: telnet 127.0.0.1 6379 (ip接端口) 
<br> 
<br>============================================================= 
<br>[b]配置文件参数说明: [/b] 
<br> 
<br>1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 
<br> [color=red]daemonize no[/color] 
<br>2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 
<br> [color=red]pidfile /var/run/redis.pid[/color] 
<br>3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 
<br> [color=red]port 6379[/color] 
<br>4. 绑定的主机地址 
<br> [color=red]bind 127.0.0.1[/color] 
<br>5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 
<br> [color=red]timeout 300[/color] 
<br>6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose 
<br> [color=red]loglevel verbose[/color] 
<br>7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null 
<br> [color=red]logfile stdout[/color] 
<br>8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id 
<br> [color=red]databases 16[/color] 
<br>9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 
<br> save &lt;seconds&gt; &lt;changes&gt; 
<br> Redis默认配置文件中提供了三个条件： 
<br> [color=red]save 900 1 
<br> save 300 10 
<br> save 60 10000[/color] 
<br> 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 
<br> 
<br>10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 
<br> [color=red]rdbcompression yes[/color] 
<br>11. 指定本地数据库文件名，默认值为dump.rdb 
<br> [color=red]dbfilename dump.rdb[/color] 
<br>12. 指定本地数据库存放目录 
<br> [color=red]dir ./[/color] 
<br>13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 
<br> [color=red]slaveof &lt;masterip&gt; &lt;masterport&gt;[/color] 
<br>14. 当master服务设置了密码保护时，slav服务连接master的密码 
<br> [color=red]masterauth &lt;master-password&gt;[/color] 
<br>15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭 
<br> [color=red]requirepass foobared[/color] 
<br>16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 
<br> [color=red]maxclients 128[/color] 
<br>17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 
<br> [color=red]maxmemory &lt;bytes&gt;[/color] 
<br>18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no 
<br> [color=red]appendonly no[/color] 
<br>19. 指定更新日志文件名，默认为appendonly.aof 
<br> [color=red]appendfilename appendonly.aof[/color] 
<br>20. 指定更新日志条件，共有3个可选值： 
<br> [color=red]no[/color]：表示等操作系统进行数据缓存同步到磁盘（快） 
<br> [color=red]always[/color]：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） 
<br> [color=red]everysec[/color]：表示每秒同步一次（折衷，默认值） 
<br> [color=red]appendfsync everysec[/color] 
<br> 
<br>21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） 
<br> [color=red]vm-enabled no[/color] 
<br>22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 
<br> [color=red]vm-swap-file /tmp/redis.swap[/color] 
<br>23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 
<br> [color=red]vm-max-memory 0[/color] 
<br>24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 
<br> [color=red]vm-page-size 32[/color] 
<br>25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 
<br> [color=red]vm-pages 134217728[/color] 
<br>26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 
<br> [color=red]vm-max-threads 4[/color] 
<br>27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 
<br> [color=red]glueoutputbuf yes[/color] 
<br>28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 
<br> [color=red]hash-max-zipmap-entries 64 
<br> hash-max-zipmap-value 512[/color] 
<br>29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） 
<br> [color=red]activerehashing yes[/color] 
<br>30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 
<br> [color=red]include /path/to/local.conf[/color]
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4ff2c0318f251b68d8cb8b0fa9d625a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手把手教你用C#编写一个简单的文本编辑器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e6e1fe75d037fb4a212068a667ac407a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">路由中的管理距离</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>