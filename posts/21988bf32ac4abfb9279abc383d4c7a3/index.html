<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>R2机器人加载棋盘与棋子模型，对urdf、sdf的解释(区分srdf) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="R2机器人加载棋盘与棋子模型，对urdf、sdf的解释(区分srdf)" />
<meta property="og:description" content="1、概述 urdf、sdf、srdf文件都属于xml的规范格式，解释分别如下：
urdf(unified robot description format)叫做&#34;统一机器人描述格式&#34;，主要目的就是提供一种尽可能通用的机器人描述规范，这样对于机器人的描述就可以互相移植，比较方便。
sdf(simulation description format)能够描述机器人、静态和动态物体、照明、地形甚至物理学的各方面的信息。sdf可以精确描述机器人的各类性质，除了传统的运动学特性之外，还可以为机器人定义传感器、表面属性、纹理、关节摩擦等，还提供了定义各种环境的方法，包括环境光照、地形，OpenStreetMaps中的街道以及The Prop Shop中提供的任何模型
从仿真角度讲，urdf文档不能描述不属于机器人的属性，即使其可能与机器人仿真十分相关，如环境光线、机器人在世界坐标系下的位姿、多个机器人之间的相对位姿等，算是对urdf的补充升级。
srdf(semantic robot description format)叫做&#34;语义机器人描述格式&#34;，是MoveIt针对控制机器人关节运动使用的一种机器人描述文件格式。有兴趣的可以查阅:ROS仿真R2机器人之安装运行及MoveIt的介绍 使用命令：
rosrun moveit_setup_assistant moveit_setup_assistant 就可以打开MoveIt辅助安装工具，其中就有加载和生成srdf文件的操作。主要内容包括，关节组(joint groups)，默认状态配置(default robot configurations)，额外的碰撞检测信息(additional collision checking information)，额外的坐标系变换(additional transforms)等
我们重点来讲解下urdf对机器人的描述格式文件，连杆是带有质量属性的刚体，也就是不能发生形变，比如手臂，而关节是连接、限制两个刚体相对运动的结构，可以旋转，比如人的腕关节。关节也叫运动副。通过关节将连杆依次连接起来，就构成了一个个运动链，主要包括如下内容：
机器人模型的运动学与动力学描述
机器人的几何表示
机器人的碰撞模型 2、urdf示例 比如一个简单的描述如下：
&lt;?xml version=&#34;1.0&#34;?&gt; &lt;robot name=&#34;mybot&#34;&gt; &lt;link name=&#34;base_link&#34;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;cylinder length=&#34;0.8&#34; radius=&#34;0.1&#34;/&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/link&gt; &lt;/robot&gt; 那么这个机器人的名称叫mybot，link属性就是连杆的意思，所以是一根名为base_link的连杆，visual是可视化节点，geometry是几何学，对机器人关节的描述，这里就是该连杆的形状是cylinder圆柱体，其长度为0.8、横截面半径为0.1。
单位制度采用的是&#34;米-千克-秒&#34;，所以上面的长度和半径的大小是0.8米和0.1米。
上面的示例是一个连杆，再来看一个带关节的连接两个连杆的机器人：
&lt;?xml version=&#34;1.0&#34;?&gt; &lt;robot name=&#34;mybot2&#34;&gt; &lt;link name=&#34;link_0&#34;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;cylinder length=&#34;0.8&#34; radius=&#34;0.1&#34;/&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/link&gt; &lt;link name=&#34;link_1&#34;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;cylinder length=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/21988bf32ac4abfb9279abc383d4c7a3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-10T08:50:33+08:00" />
<meta property="article:modified_time" content="2024-01-10T08:50:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">R2机器人加载棋盘与棋子模型，对urdf、sdf的解释(区分srdf)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1、概述</h3> 
<p>urdf、sdf、srdf文件都属于xml的规范格式，解释分别如下：<br><span style="color:#be191c;"><strong>urdf(unified robot description format)</strong></span>叫做"统一机器人描述格式"，主要目的就是提供一种尽可能通用的机器人描述规范，这样对于机器人的描述就可以互相移植，比较方便。</p> 
<p><span style="color:#be191c;"><strong>sdf(simulation description format)</strong></span>能够描述机器人、静态和动态物体、照明、地形甚至物理学的各方面的信息。sdf可以精确描述机器人的各类性质，除了传统的运动学特性之外，还可以为机器人定义传感器、表面属性、纹理、关节摩擦等，还提供了定义各种环境的方法，包括环境光照、地形，OpenStreetMaps中的街道以及The Prop Shop中提供的任何模型<br> 从仿真角度讲，urdf文档不能描述不属于机器人的属性，即使其可能与机器人仿真十分相关，如环境光线、机器人在世界坐标系下的位姿、多个机器人之间的相对位姿等，算是对urdf的补充升级。</p> 
<p><span style="color:#be191c;"><strong>srdf(semantic robot description format)</strong></span>叫做"语义机器人描述格式"，是MoveIt针对控制机器人关节运动使用的一种机器人描述文件格式。有兴趣的可以查阅:<a class="link-info" href="https://blog.csdn.net/weixin_41896770/article/details/135295359" title="ROS仿真R2机器人之安装运行及MoveIt的介绍">ROS仿真R2机器人之安装运行及MoveIt的介绍</a> <br> 使用命令：</p> 
<pre><code class="language-bash">rosrun moveit_setup_assistant moveit_setup_assistant</code></pre> 
<p>就可以打开<strong>MoveIt</strong>辅助安装工具，其中就有加载和生成srdf文件的操作。主要内容包括，<strong>关节组</strong>(joint groups)，<strong>默认状态配置</strong>(default robot configurations)，额外的碰撞检测信息<strong>(additional collision checking information)</strong>，<strong>额外的坐标系变换</strong>(additional transforms)等</p> 
<p>我们重点来讲解下<span style="color:#be191c;"><strong>urdf</strong></span>对机器人的描述格式文件，<strong><span style="color:#fe2c24;">连杆</span></strong>是带有质量属性的刚体，也就是不能发生形变，比如手臂，而关节是连接、限制两个刚体相对运动的结构，可以旋转，比如人的腕关节。<strong><span style="color:#fe2c24;">关节</span></strong>也叫运动副。通过关节将连杆依次连接起来，就构成了一个个运动链，主要包括如下内容：</p> 
<blockquote> 
 <p>机器人模型的运动学与动力学描述<br> 机器人的几何表示<br> 机器人的碰撞模型 </p> 
</blockquote> 
<h3>2、urdf示例</h3> 
<p> 比如一个简单的描述如下：</p> 
<pre><code class="language-XML">&lt;?xml version="1.0"?&gt;
&lt;robot name="mybot"&gt;  
    &lt;link name="base_link"&gt;    
        &lt;visual&gt;      
            &lt;geometry&gt;        
                &lt;cylinder length="0.8" radius="0.1"/&gt;      
            &lt;/geometry&gt;    
        &lt;/visual&gt;  
    &lt;/link&gt;
&lt;/robot&gt;</code></pre> 
<p>那么这个机器人的名称叫mybot，<strong>link</strong>属性就是连杆的意思，所以是一根名为base_link的连杆，<strong>visual</strong>是可视化节点，<strong>geometry</strong>是几何学，对机器人关节的描述，这里就是该连杆的形状是<strong>cylinder</strong>圆柱体，其长度为0.8、横截面半径为0.1。<br> 单位制度采用的是<span style="color:#be191c;"><strong>"米-千克-秒"</strong></span>，所以上面的长度和半径的大小是0.8米和0.1米。</p> 
<p>上面的示例是一个连杆，再来看一个带关节的连接两个连杆的机器人：</p> 
<pre><code class="language-XML">&lt;?xml version="1.0"?&gt;
&lt;robot name="mybot2"&gt;
    &lt;link name="link_0"&gt;
        &lt;visual&gt;
            &lt;geometry&gt;
                &lt;cylinder length="0.8" radius="0.1"/&gt;
            &lt;/geometry&gt;
        &lt;/visual&gt;
    &lt;/link&gt;
    
    &lt;link name="link_1"&gt;
        &lt;visual&gt;
            &lt;geometry&gt;
                &lt;cylinder length="0.8" radius="0.1"/&gt;
            &lt;/geometry&gt;
        &lt;/visual&gt;
    &lt;/link&gt;
    
    &lt;joint name="joint_0" type="revolute"&gt;
        &lt;axis xyz="0 0 1"/&gt;
        &lt;limit effort="100.0" lower="0.0" upper="0.5" velocity="0.5"/&gt;
        &lt;origin rpy="0 0 0" xyz="0.0 0.0 0.3"/&gt;
        &lt;parent link="link_0"/&gt;
        &lt;child link="link_1"/&gt;
    &lt;/joint&gt;
&lt;/robot&gt;</code></pre> 
<p>这里可以看到增加了一个名为joint_0的关节，类型是revolute，也就是说是可以旋转的。定义中我们知道是用来连接两个连杆的，可以叫做父连杆和子连杆，这里的父连杆是名为link_0，子连杆是名为link_1。<br> 其中类型除了<strong>revolute</strong>之外还包括以下几种：</p> 
<blockquote> 
 <p><strong>continuous</strong>：旋转，不受限制<br><strong>revolute</strong>：旋转，转动角度受到限制<br><strong>prismatic</strong>：平滑的<br><strong>fixed</strong>: 固定关节<br><strong>floating</strong>: 浮动关节，允许六个自由度的运动</p> 
</blockquote> 
<h3>3、棋盘与棋子</h3> 
<p>接下来我们看下sdf在实际当中的应用，我们在仿真平台中看下如何给下棋机器人画一个棋盘和棋子。下面一些代码是沿着<a class="link-info" href="https://blog.csdn.net/weixin_41896770/article/details/135295359" title="上一篇文章">上一篇文章</a>的一些代码，是针对机器人的一些操作，有兴趣的可以一起看过来</p> 
<h4 style="background-color:transparent;">3.1、bash操作</h4> 
<pre><code class="language-bash">cd ~/chessbot/src
gedit r2_cli.py</code></pre> 
<pre><code class="language-python">#!/usr/bin/env python
import sys,rospy,tf,moveit_commander,random
from geometry_msgs.msg import Pose,Point,Quaternion

class R2Wrapper:
    def __init__(self):
        self.group={'left':moveit_commander.MoveGroupCommander('left_arm'),
                    'right':moveit_commander.MoveGroupCommander('right_arm')}

    def setPose(self,arm,x,y,z,phi,theta,psi):
        if arm!='left' and arm!='right':
            raise ValueError("unknow arm:'%s'"%arm)
        orient=Quaternion(*tf.transformations.quaternion_from_euler(phi,theta,psi))
        pose=Pose(Point(x,y,z),orient)
        self.group[arm].set_pose_target(pose)
        self.group[arm].go(True)

if __name__=='__main__':
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node('r2_cli',anonymous=True)
    argv=rospy.myargv(argv=sys.argv)
    if len(argv)!=8:
        print('usage:r2_cli.py arm x y z phi theta psi')
        sys.exit(1)
    r2w=R2Wrapper()
    r2w.setPose(argv[1],*[float(num) for num in sys.argv[2:]])
    moveit_commander.roscpp_shutdown()</code></pre> 
<pre><code class="language-bash">chmod u+x r2_cli.py
./r2_cli.py left 0.5 -0.5 1.3 3.14 -1.5 -1.57
./r2_cli.py right -0.4 -0.6 1.4 3.14 -1.5 -1.57
./r2_cli.py left 0.4 -0.4 1.2 3.14 -1.5 -1.57</code></pre> 
<p>这里是对机器人做一些移动操作，也可以将这些命令写入到bash文件中，<strong>r2.bash</strong></p> 
<pre><code class="language-bash">#!/bin/bash
alias r2lhome="./r2_cli.py left 0.5 -0.5 1.3 3.14 -1.5 -1.57"
alias r2rhome="./r2_cli.py right -0.4 -0.6 1.4 3.14 -1.5 -1.57"
alias r2home="r2lhome;r2rhome"</code></pre> 
<p>然后通过<span style="color:#be191c;"><span style="background-color:#fef2f0;">source ./r2.bash</span></span> 加载这些别名即可，这样就只需要输入 <span style="color:#be191c;"><strong>r2home</strong></span>，机器人就会规划一条通向起始位置的安全路径，并沿着它平滑地移动过去。对大多数机器人来说，一般都会设置一些常用的姿势，这样在日常操作、维护和任务当中都非常的实用方便。</p> 
<p>启动一个空白的gazebo仿真界面</p> 
<pre><code class="language-bash">cd ~/chessbot
source devel/setup.bash
roslaunch gazebo_ros empty_world.launch</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/6f/fa/dzMuvBZr_o.png">然后将R2机器人给加载进来</p> 
<pre><code class="language-bash">cd ~/chessbot
source devel/setup.bash
rosrun gazebo_ros spawn_model -file ~/chessbot/src/1.urdf -urdf -model r2</code></pre> 
<p> 接下来可以规划它运动了</p> 
<pre><code class="language-bash">cd ~/chessbot
source devel/setup.bash
roslaunch mybot move_group.launch


cd ~/chessbot
source devel/setup.bash
cd ~/chessbot/src
source ./r2.bash
r2home</code></pre> 
<h4>3.2、画棋盘</h4> 
<pre><code class="language-bash">gedit chess_board.sdf</code></pre> 
<pre><code class="language-XML">&lt;?xml version='1.0'?&gt;
&lt;sdf version='1.4'&gt;
&lt;model name='box'&gt;
&lt;!--&lt;pose frame=''&gt;1 0 2 0 0 0&lt;/pose&gt;--&gt;
  &lt;static&gt;true&lt;/static&gt;
  &lt;link name='link'&gt;
    &lt;collision name='collision'&gt;
      &lt;geometry&gt;
        &lt;box&gt;&lt;size&gt;0.5 0.5 0.02&lt;/size&gt;&lt;/box&gt;
      &lt;/geometry&gt;
      &lt;surface&gt;
        &lt;friction&gt;
          &lt;ode&gt;
            &lt;mu&gt;0.1&lt;/mu&gt;
             &lt;mu2&gt;0.1&lt;/mu2&gt;
          &lt;/ode&gt;
        &lt;/friction&gt;
        &lt;contact&gt;
          &lt;ode&gt;
            &lt;max_vel&gt;0.1&lt;/max_vel&gt;
            &lt;min_depth&gt;0.001&lt;/min_depth&gt;
          &lt;/ode&gt;
        &lt;/contact&gt;
    &lt;/surface&gt;
    &lt;/collision&gt;
   &lt;visual name='visual'&gt;
     &lt;geometry&gt;&lt;box&gt;&lt;size&gt;0.5 0.5 0.02&lt;/size&gt;&lt;/box&gt;&lt;/geometry&gt;
   &lt;/visual&gt;
  &lt;/link&gt;
&lt;/model&gt;
&lt;/sdf&gt;</code></pre> 
<p>加载进来看下：</p> 
<pre><code class="language-bash">rosrun gazebo_ros spawn_model -file ~/chessbot/src/chess_board.sdf -sdf -model box</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/a9/57/6o43ZE1l_o.png"></p> 
<p>这里就是在sdf节点下，最常见的就是model节点，可以进行嵌套，这样就可以插入多个机器人了。可以看到节点属性比urdf多了，这也是其中一部分的节点，其余的还有light灯光效果，gravity重力加速度，scene场景参数，比如背景、阴影等，kinematic运动学等等。<br> 其中static表示这个东西是静态的不能移动，pose可以自定义位姿，geometry里面定义物体的大小(长宽高)，collision碰撞检测里面包括了常见的物理特性，friction摩擦力，里面定义两个摩擦系数，contact节点里面的max_vel表示接触的最大速度，min_depth表示接触的最小深度 </p> 
<h4>3.3、画棋子</h4> 
<pre><code class="language-bash">gedit chess_piece.sdf</code></pre> 
<pre><code class="language-XML">&lt;?xml version='1.0'?&gt;
&lt;sdf version='1.4'&gt;
&lt;model name='piece'&gt;
  &lt;link name='link'&gt;
    &lt;inertial&gt;
      &lt;mass&gt;0.001&lt;/mass&gt;
      &lt;inertial&gt;
        &lt;ixx&gt;0.0000001667&lt;/ixx&gt;
        &lt;ixy&gt;0&lt;/ixy&gt;
        &lt;ixz&gt;0&lt;/ixz&gt;
        &lt;iyy&gt;0.00000001667&lt;/iyy&gt;
        &lt;izz&gt;0.0000001667&lt;/izz&gt;
      &lt;/inertial&gt;
    &lt;/inertial&gt;
    &lt;collision name='collision'&gt;
      &lt;geometry&gt;
        &lt;box&gt;&lt;size&gt;0.02 0.02 0.04&lt;/size&gt;&lt;/box&gt;
      &lt;/geometry&gt;
      &lt;surface&gt;
        &lt;friction&gt;
          &lt;ode&gt;
            &lt;mu&gt;0.4&lt;/mu&gt;
             &lt;mu2&gt;0.4&lt;/mu2&gt;
          &lt;/ode&gt;
        &lt;/friction&gt;
        &lt;contact&gt;
          &lt;ode&gt;
            &lt;max_vel&gt;0.1&lt;/max_vel&gt;
            &lt;min_depth&gt;0.0001&lt;/min_depth&gt;
          &lt;/ode&gt;
        &lt;/contact&gt;
     &lt;/surface&gt;
   &lt;/collision&gt;
   &lt;visual name='visual'&gt;
     &lt;geometry&gt;&lt;box&gt;&lt;size&gt;0.02 0.02 0.04&lt;/size&gt;&lt;/box&gt;&lt;/geometry&gt;
   &lt;/visual&gt;
  &lt;/link&gt;
&lt;/model&gt;
&lt;/sdf&gt;</code></pre> 
<p>这里定义了棋子的质量<strong>mass</strong>为0.001，也就是1克，有一个惯性节点<strong>inertial</strong>，定义了物体的惯性矩阵，<strong>ixx, iyy, izz</strong>表示三个方向上的惯性，而<strong>ixy, ixz, iyz</strong>表示扭矩作用下的惯性力矩。<br> 棋子比较多，我们使用代码循环生成棋子，落在棋盘上，这里会使用到服务，所以我们可以先来查看下有哪些服务列表：<span style="color:#be191c;"><span style="background-color:#fef2f0;">rosservice list</span></span>，挺多的，如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/90/39/7XpctTa7_o.png"></p> 
<p>其中我们需要用到<strong>/gazebo/delete_model</strong>和<strong>/gazebo/spawn_sdf_model </strong></p> 
<pre><code class="language-bash">gedit spawn_chessboard.py </code></pre> 
<pre><code class="language-python">#!/usr/bin/env python
import sys,rospy,tf
from gazebo_msgs.srv import *
from geometry_msgs.msg import *
from copy import deepcopy

if __name__=='__main__':
    rospy.init_node("spawn_chessboard")
    rospy.wait_for_service("gazebo/delete_model")
    rospy.wait_for_service("gazebo/spawn_sdf_model")
    delete_model=rospy.ServiceProxy("gazebo/delete_model",DeleteModel)
    delete_model("chessboard")
    s=rospy.ServiceProxy("gazebo/spawn_sdf_model",SpawnModel)
    orient=Quaternion(*tf.transformations.quaternion_from_euler(0,0,0))
    board_pose=Pose(Point(0.25,1.39,0.90),orient)
    unit=0.05
    with open("chess_board.sdf",'r') as f:
        board_xml=f.read()
    with open("chess_piece.sdf",'r') as f:
        piece_xml=f.read()
    print(s("chessboard",board_xml,"",board_pose,"world"))
    for row in [0,1,6,7]:
        for col in xrange(0,8):
            piece_name="piece_%d_%d"%(row,col)
            delete_model(piece_name)
            pose=deepcopy(board_pose)
            pose.position.x=board_pose.position.x-3.5*unit+col*unit
            pose.position.y=board_pose.position.y-3.5*unit+row*unit
            pose.position.z+=0.02
            s(piece_name,piece_xml,"",pose,"world")</code></pre> 
<p>这样就相当于先定位一个棋盘，然后就在棋盘中的对应位置，一个一个的画出棋子了。</p> 
<p>加个可执行权限：<span style="color:#be191c;"><span style="background-color:#fef2f0;">chmod u+x spawn_chessboard.py</span></span><br> 然后执行这个Python文件：<span style="color:#be191c;"><span style="background-color:#fef2f0;">./spawn_chessboard.p</span></span></p> 
<blockquote> 
 <p>success: True<br> status_message: "SpawnModel: Successfully spawned entity" </p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8a/f0/6DSoXfDI_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db37a09094a51c3c52a5e444799a3af6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue 缓存Hook：提高接口性能，减少重复请求</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c242c6b073beba498cbec4b226a5cfdd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu设置国内镜像源</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>