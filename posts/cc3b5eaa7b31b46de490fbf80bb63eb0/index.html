<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用EF.Core将同一模型映射到多个表 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用EF.Core将同一模型映射到多个表" />
<meta property="og:description" content="在 EntityFramework Core 中，我们可以使用属性或Fluent API来配置模型映射。有一天，我遇到了一个新的需求，有一个系统每天会生成大量数据，每天生成一个新的表存储数据。例如，数据库如下所示：
所有表都具有相同的结构。那么，如何更改映射以避免创建多个模型呢？
在本文中，我将向您展示如何更改映射以处理这种情况。您也可以使用此方法扩展出更多的用法。
创建 .NET Core 3.1 项目 现在，我们可以使用.NET Core 3.1，它是.NET Core的LTS版本，将来可以轻松将其升级到.NET 5。
假设您已经在计算机上安装了最新的.NET Core SDK。如果没有，则可以从https://dotnet.microsoft.com/download下载。然后，您可以使用dotnet CLI创建项目。对于此示例，我将使用.NET Core 3.1。
让我们创建一个名为DynamicModelDemo的新.NET Core Console项目:
dotnet new console --name DynamicModelDemo 然后用以下命令创建一个新的解决方案:
dotnet new sln --name DynamicModelDemo 接下来使用以下命令把刚才创建的项目添加到解决方案：
dotnet sln add &#34;DynamicModelDemo/DynamicModelDemo.csproj&#34; 接下来可以用Visual Studio打开解决方案了。
创建模型 该模型非常简单。在项目中添加一个名为ConfigurableEntity.cs的新文件：
using System; namespaceDynamicModelDemo { publicclassConfigurableEntity { publicint Id { get; set; } publicstring Title { get; set; } publicstring Content { get; set; } public DateTime CreateDateTime { get; set; } } } 我们将使用CreateDateTime属性来确定模型应该映射到哪个表。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cc3b5eaa7b31b46de490fbf80bb63eb0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-03T23:59:25+08:00" />
<meta property="article:modified_time" content="2020-04-03T23:59:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用EF.Core将同一模型映射到多个表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在 EntityFramework Core 中，我们可以使用属性或Fluent API来配置模型映射。有一天，我遇到了一个新的需求，有一个系统每天会生成大量数据，每天生成一个新的表存储数据。例如，数据库如下所示：<img alt="" src="https://images2.imgbox.com/5b/6e/KTRbiKvT_o.png"></p> 
<p>所有表都具有相同的结构。那么，如何更改映射以避免创建多个模型呢？</p> 
<p>在本文中，我将向您展示如何更改映射以处理这种情况。您也可以使用此方法扩展出更多的用法。</p> 
<h3>创建 .NET Core 3.1 项目</h3> 
<p>现在，我们可以使用.NET Core 3.1，它是.NET Core的LTS版本，将来可以轻松将其升级到.NET 5。</p> 
<p>假设您已经在计算机上安装了最新的.NET Core SDK。如果没有，则可以从https://dotnet.microsoft.com/download下载。然后，您可以使用<code>dotnet CLI</code>创建项目。对于此示例，我将使用.NET Core 3.1。</p> 
<p>让我们创建一个名为<code>DynamicModelDemo</code>的新.NET Core Console项目:</p> 
<pre><code>dotnet new console --name DynamicModelDemo
</code></pre> 
<p>然后用以下命令创建一个新的解决方案:</p> 
<pre><code>dotnet new sln --name DynamicModelDemo
</code></pre> 
<p>接下来使用以下命令把刚才创建的项目添加到解决方案：</p> 
<pre><code>dotnet sln add "DynamicModelDemo/DynamicModelDemo.csproj"
</code></pre> 
<p>接下来可以用Visual Studio打开解决方案了。</p> 
<h3>创建模型</h3> 
<p>该模型非常简单。在项目中添加一个名为<code>ConfigurableEntity.cs</code>的新文件：</p> 
<pre><code>using System;

namespaceDynamicModelDemo
{
    publicclassConfigurableEntity
    {
        publicint Id { get; set; }
        publicstring Title { get; set; }
        publicstring Content { get; set; }
        public DateTime CreateDateTime { get; set; }
    }
}
</code></pre> 
<p>我们将使用<code>CreateDateTime</code>属性来确定模型应该映射到哪个表。</p> 
<h3>添加 EntityFramework Core</h3> 
<p>导航到项目目录并使用以下命令添加所需的EF.Core packages:</p> 
<pre><code>dotnet add package Microsoft.EntityFrameworkCore.SqlSever
dotnet add package Microsoft.EntityFrameworkCore.Design
</code></pre> 
<p>如果您还没有安装 ef tool，请运行以下命令来安装：</p> 
<pre><code>dotnet tool install --global dotnet-ef
</code></pre> 
<p>这样您就可以使用 dotnet ef 工具创建迁移或通过应用迁移来更新数据库。</p> 
<h3>创建 DbContext</h3> 
<p>向项目添加一个名为<code>DynamicContext.cs</code>的新类文件。内容如下所示：</p> 
<pre><code>using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using System;

namespaceDynamicModelDemo
{
    publicclassDynamicContext : DbContext
    {
        public DbSet&lt;ConfigurableEntity&gt; Entities { get; set; }

        #region OnConfiguring
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            =&gt; optionsBuilder
                .UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=DynamicContext;Trusted_Connection=True;");
        #endregion

        #region OnModelCreating
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity&lt;ConfigurableEntity&gt;(b =&gt;
            {
                b.HasKey(p =&gt; p.Id);
            });
        }
        #endregion
    }
}
</code></pre> 
<p>目前，这只是EF.Core的基本配置。它使用默认映射，这意味着模型将映射到名为<code>Entities</code>的表。那么，如果我们想基于其<code>CreateDateTime</code>属性将模型映射到不同的表，该怎么办呢？</p> 
<p>您可能知道我们可以使用<code>ToTable()</code>方法来更改表名，但是如何在<code>OnModelCreating</code>方法中更改所有模型的表名呢？EF建立模型时，只会执行一次OnModelCreating。所以这种方式是无法实现的。</p> 
<p>对于这种情况，我们需要使用<code>IModelCacheKeyFactory</code>来更改默认映射，通过这个接口我们可以定制模型缓存机制，以便EF能够根据其属性创建不同的模型。</p> 
<h3><code>IModelCacheKeyFactory</code>是什么？</h3> 
<p>这是微软官方的文档解释：</p> 
<blockquote> 
 <p>EF uses <code>IModelCacheKeyFactory</code> to generate cache keys for models.</p> 
</blockquote> 
<p>默认情况下，EF假定对于任何给定的上下文类型，模型都是相同的。但是对于我们的方案，模型将有所不同，因为它映射到了不同的表。因此，我们需要用我们的实现替换<code>IModelCacheKeyFactory</code>服务，该实现会比较缓存键以将模型映射到正确的表。</p> 
<p>请注意，该接口通常由数据库提供程序和其他扩展使用，一般不在应用程序代码中使用。但是对于我们的场景来说，这是一种可行的方法。</p> 
<h3>实现<code>IModelCacheKeyFactory</code></h3> 
<p>我们需要使用<code>CreateDateTime</code>来区分表。在<code>DynamicContext</code>类中添加一个属性：</p> 
<pre><code>public DateTime CreateDateTime { get; set; }
</code></pre> 
<p>在项目中添加一个名为<code>DynamicModelCacheKeyFactory.cs</code>的新类文件。代码如下所示：</p> 
<pre><code>using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;

namespaceDynamicModelDemo
{
    publicclassDynamicModelCacheKeyFactory : IModelCacheKeyFactory
    {
        public object Create(DbContext context)
            =&gt; context is DynamicContext dynamicContext
                ? (context.GetType(), dynamicContext.CreateDateTime)
                : (object)context.GetType();
    }
}
</code></pre> 
<p>在生成模型缓存键时，此实现将考虑<code>CreateDateTime</code>属性。</p> 
<h3>应用<code>IModelCacheKeyFactory</code></h3> 
<p>接下来，我们可以在上下文中注册新的<code>IModelCacheKeyFactory</code>：</p> 
<pre><code>#region OnConfiguring
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            =&gt; optionsBuilder
                .UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=DynamicContext;Trusted_Connection=True;")
                .ReplaceService&lt;IModelCacheKeyFactory, DynamicModelCacheKeyFactory&gt;();
#endregion
</code></pre> 
<p>这样我们就可以在<code>OnModelCreating</code>方法中分别映射表名了：</p> 
<pre><code>#region OnModelCreating
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
      modelBuilder.Entity&lt;ConfigurableEntity&gt;(b =&gt;
            {
                b.ToTable(CreateDateTime.ToString("yyyyMMdd"));
                b.HasKey(p =&gt; p.Id);
            });
}
#endregion
</code></pre> 
<p><code>CreateDateTime</code>来自<code>DynamicContext</code>的属性。</p> 
<p>我们可以在创建<code>DynamicContext</code>时指定<code>CreateDateTime</code>属性：</p> 
<pre><code>var context = new DynamicContext { CreateDateTime = datetime };
</code></pre> 
<p>如果<code>datetime</code>为<code>2020/03/27</code>，则<code>context</code>的模型将映射到名为<code>20200327</code>的表。</p> 
<h3>创建数据库</h3> 
<p>在验证代码之前，我们需要首先创建数据库。但是，EF迁移并不是这种情况的最佳解决方案，因为随着时间的流逝，系统将生成更多表。我们只是使用它来创建一些示例表来验证映射。实际上，系统应该具有另一种每天动态生成表的方式。</p> 
<p>运行以下命令以创建第一个迁移：</p> 
<pre><code>dotnet ef migrations add InitialCreate
</code></pre> 
<p>您会看到在<code>Migrations</code>文件夹中生成了两个文件。打开<code>xxx_InitialCreate.cs</code>文件，并通过以下代码更新Up方法：</p> 
<pre><code>protected override void Up(MigrationBuilder migrationBuilder)
{
      for (int i = 0; i &lt; 30; i++)
      {
           var index = i;
           migrationBuilder.CreateTable(
               name: DateTime.Now.AddDays(-index).ToString("yyyyMMdd"),
               columns: table =&gt; new
               {
                    Id = table.Column&lt;int&gt;(nullable: false)
                            .Annotation("SqlServer:Identity", "1, 1"),
                    Title = table.Column&lt;string&gt;(nullable: true),
                    Content = table.Column&lt;string&gt;(nullable: true),
                    CreateDateTime = table.Column&lt;DateTime&gt;(nullable: false)
               },
               constraints: table =&gt;
               {
                    table.PrimaryKey($"PK_{DateTime.Now.AddDays(-index):yyyyMMdd}", x =&gt; x.Id);
               });
        }
    }
</code></pre> 
<p>所做的更改是为了确保数据库中可以有足够的表进行测试。请注意，<strong>我们不应该在生产环境中使用这种方式</strong>。</p> 
<p>接下来，我们可以使用此命令来创建和更新数据库：</p> 
<pre><code>dotnet ef database update
</code></pre> 
<p>您会看到它在数据库中生成了最近30天的表。</p> 
<h3>验证映射</h3> 
<p>现在该验证新映射了。通过以下代码更新<code>Program.cs</code>中的<code>Main</code>方法：</p> 
<pre><code>static void Main(string[] args)
{
    DateTime datetime1 = DateTime.Now;
    using (var context = new DynamicContext { CreateDateTime = datetime1 })
    {
        context.Entities.Add(new ConfigurableEntity { Title = "Great News One", Content = $"Hello World! I am the news of {datetime1}", CreateDateTime = datetime1 });
        context.SaveChanges();
    }
    DateTime datetime2 = DateTime.Now.AddDays(-1);
    using (var context = new DynamicContext { CreateDateTime = datetime2 })
    {
        context.Entities.Add(new ConfigurableEntity { Title = "Great News Two", Content = $"Hello World! I am the news of {datetime2}", CreateDateTime = datetime2 });
        context.SaveChanges();
    }

    using (var context = new DynamicContext { CreateDateTime = datetime1 })
    {
        var entity = context.Entities.Single();
          // Writes news of today
        Console.WriteLine($"{entity.Title} {entity.Content} {entity.CreateDateTime}");
    }

    using (var context = new DynamicContext { CreateDateTime = datetime2 })
    {
        var entity = context.Entities.Single();
        // Writes news of yesterday
        Console.WriteLine($"{entity.Title} {entity.Content} {entity.CreateDateTime}");
    }
}
</code></pre> 
<p>您将会看到如下输出：<img alt="" src="https://images2.imgbox.com/e5/99/QbfFjqjw_o.png"></p> 
<p>现在，我们可以通过传递<code>CreateDateTime</code>属性来使用相同的<code>DbContext</code>来表示不同的模型了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/57f68cadbd403e5f6a7795d61967cf3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android移动开发应用笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e22d51eaf99d6ac72d0d83546393fc1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">破解公钥加密</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>