<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何简单地理解Python中的if __name__ == &#39;__main__&#39; - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何简单地理解Python中的if __name__ == &#39;__main__&#39;" />
<meta property="og:description" content="1. 摘要 通俗的理解__name__ == &#39;__main__&#39;：假如你叫小明.py，在朋友眼中，你是小明(__name__ == &#39;小明&#39;)；在你自己眼中，你是你自己(__name__ == &#39;__main__&#39;)。
if __name__ == &#39;__main__&#39;的意思是：当.py文件被直接运行时，if __name__ == &#39;__main__&#39;之下的代码块将被运行；当.py文件以模块形式被导入时，if __name__ == &#39;__main__&#39;之下的代码块不被运行。
2. 程序入口 对于很多编程语言来说，程序都必须要有一个入口，比如C，C&#43;&#43;，以及完全面向对象的编程语言Java，C#等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C，C&#43;&#43;都需要有一个main函数作为程序的入口，也就是程序的运行会从main函数开始。同样，Java，C#必须要有一个包含Main方法的主类，作为程序入口。
而Python则不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。
一个Python源码文件（.py）除了可以被直接运行外，还可以作为模块（也就是库），被其他.py文件导入。不管是直接运行还是被导入，.py文件的最顶层代码都会被运行（Python用缩进来区分代码层次），而当一个.py文件作为模块被导入时，我们可能不希望一部分代码被运行。
2.1 一个.py文件被其他.py文件引用 假设我们有一个const.py文件，内容如下：
PI = 3.14 def main(): print(&#34;PI:&#34;, PI) main() # 运行结果：PI: 3.14 现在，我们写一个用于计算圆面积的area.py文件，area.py文件需要用到const.py文件中的PI变量。从const.py中，我们把PI变量导入area.py：
from const import PI def calc_round_area(radius): return PI * (radius ** 2) def main(): print(&#34;round area: &#34;, calc_round_area(2)) main() &#39;&#39;&#39; 运行结果： PI: 3.14 round area: 12.56 &#39;&#39;&#39; 2.2 修改const.py，添加if __name__ == &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/971a810be15fa9e686bde11b51388088/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-09T22:35:42+08:00" />
<meta property="article:modified_time" content="2017-09-09T22:35:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何简单地理解Python中的if __name__ == &#39;__main__&#39;</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="1-摘要">1. 摘要</h3> 
<p>通俗的理解<code>__name__ == '__main__'</code>：假如你叫小明.py，在朋友眼中，你是小明<code>(__name__ == '小明')</code>；在你自己眼中，你是你自己<code>(__name__ == '__main__')</code>。</p> 
<p><code>if __name__ == '__main__'</code>的意思是：当.py文件被直接运行时，<code>if __name__ == '__main__'</code>之下的代码块将被运行；当.py文件以模块形式被导入时，<code>if __name__ == '__main__'</code>之下的代码块不被运行。</p> 
<p><br></p> 
<h3 id="2-程序入口">2. 程序入口</h3> 
<p>对于很多编程语言来说，程序都必须要有一个入口，比如C，C++，以及完全面向对象的编程语言Java，C#等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C，C++都需要有一个main函数作为程序的入口，也就是程序的运行会从main函数开始。同样，Java，C#必须要有一个包含Main方法的主类，作为程序入口。</p> 
<p>而Python则不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。</p> 
<p>一个Python源码文件（.py）除了可以被直接运行外，还可以作为模块（也就是库），被其他.py文件导入。不管是直接运行还是被导入，.py文件的最顶层代码都会被运行（Python用缩进来区分代码层次），而当一个.py文件作为模块被导入时，我们可能不希望一部分代码被运行。</p> 
<h4 id="21-一个py文件被其他py文件引用">2.1 一个.py文件被其他.py文件引用</h4> 
<p>假设我们有一个const.py文件，内容如下：</p> 
<pre class="prettyprint"><code class="language-python hljs ">PI = <span class="hljs-number">3.14</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    print(<span class="hljs-string">"PI:"</span>, PI)

main()

<span class="hljs-comment"># 运行结果：PI: 3.14</span></code></pre> 
<p>现在，我们写一个用于计算圆面积的area.py文件，area.py文件需要用到const.py文件中的PI变量。从const.py中，我们把PI变量导入area.py：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">from</span> const <span class="hljs-keyword">import</span> PI

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_round_area</span><span class="hljs-params">(radius)</span>:</span>
    <span class="hljs-keyword">return</span> PI * (radius ** <span class="hljs-number">2</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    print(<span class="hljs-string">"round area: "</span>, calc_round_area(<span class="hljs-number">2</span>))

main()

<span class="hljs-string">'''
运行结果：
PI: 3.14
round area:  12.56
'''</span></code></pre> 
<h4 id="22-修改constpy添加if-name-main">2.2 修改const.py，添加<code>if __name__ == "__main__"</code></h4> 
<p>我们看到const.py中的main函数也被运行了，实际上我们不希望它被运行，因为const.py提供的main函数只是为了测试常量定义。这时<code>if __name__ == '__main__'</code>派上了用场，我们把const.py改一下，添加<code>if __name__ == "__main__"</code>：</p> 
<pre class="prettyprint"><code class="language-python hljs ">PI = <span class="hljs-number">3.14</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    print(<span class="hljs-string">"PI:"</span>, PI)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()</code></pre> 
<p>运行const.py，输出如下：</p> 
<pre class="prettyprint"><code class="language-python hljs ">PI: <span class="hljs-number">3.14</span></code></pre> 
<p>运行area.py，输出如下：</p> 
<pre class="prettyprint"><code class="language-python hljs ">round area:  <span class="hljs-number">12.56</span></code></pre> 
<p>如上，我们可以看到<code>if __name__ == '__main__'</code>相当于Python模拟的程序入口，Python本身并没有这么规定，这只是一种编码习惯。由于模块之间相互引用，不同模块可能有这样的定义，而程序入口只有一个。到底哪个程序入口被选中，这取决于<code>__name__</code>的值。 <br> <br></p> 
<h3 id="3-name">3. <code>__name__</code></h3> 
<h4 id="31-name反映一个包的结构">3.1 <code>__name__</code>反映一个包的结构</h4> 
<p><code>__name__</code>是内置变量，可用于反映一个包的结构。假设我们有一个包a，包的结构如下：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">a
├── b
│   ├── c<span class="hljs-preprocessor">.py</span>
│   └── __init__<span class="hljs-preprocessor">.py</span>
└── __init__<span class="hljs-preprocessor">.py</span></code></pre> 
<p>在包a中，文件<code>c.py，__init__.py，__init__.py</code>的内容都为：</p> 
<pre class="prettyprint"><code class="language-python hljs ">print(__name__)</code></pre> 
<p>当一个.py文件（模块）被其他.py文件（模块）导入时，我们在命令行执行</p> 
<pre class="prettyprint"><code class="language-shell hljs mel"><span class="hljs-keyword">python</span> -c <span class="hljs-string">"import a.b.c"</span></code></pre> 
<p>输出结果：</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-operator">a</span>
<span class="hljs-operator">a</span>.b
<span class="hljs-operator">a</span>.b.c</code></pre> 
<p>由此可见，<code>__name__</code>可以清晰地反映一个模块在包中的层次。</p> 
<h4 id="32-name表示当前模块的名字">3.2 <code>__name__</code>表示当前模块的名字</h4> 
<p><code>__name__</code>是内置变量，可用于表示当前模块的名字。我们直接运行一个.py文件（模块）</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver">python <span class="hljs-operator">a</span>/b/c.py</code></pre> 
<p>输出结果：</p> 
<pre class="prettyprint"><code class=" hljs markdown"><span class="hljs-strong">__main__</span></code></pre> 
<p>由此我们可知：如果一个.py文件（模块）被直接运行时，则其没有包结构，其<code>__name__</code>值为<code>__main__</code>，即模块名为<code>__main__</code>。 </p> 
<p>所以，<code>if __name__ == '__main__'</code>的意思是：当.py文件被直接运行时，<code>if __name__ == '__main__'</code>之下的代码块将被运行；当.py文件以模块形式被导入时，<code>if __name__ == '__main__'</code>之下的代码块不被运行。</p> 
<p><br></p> 
<h3 id="4-mainpy文件与python-m">4. <code>__main__.py</code>文件与<code>python -m</code></h3> 
<p>Python的-m参数用于将一个模块或者包作为一个脚本运行，而<code>__main__.py</code>文件相当于是一个包的“入口程序“。</p> 
<h4 id="41-运行python程序的两种方式">4.1 运行Python程序的两种方式</h4> 
<ul><li><code>python xxx.py</code>，直接运行xxx.py文件</li><li><code>python -m xxx.py</code>，把xxx.py当做模块运行</li></ul> 
<p>假设我们有一个文件run.py，内容如下：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> sys

print(sys.path)</code></pre> 
<p>我们用直接运行的方式启动</p> 
<pre class="prettyprint"><code class=" hljs avrasm">python run<span class="hljs-preprocessor">.py</span></code></pre> 
<p>输出结果(为了说明问题，输出结果只截取了重要部分，下同)：</p> 
<pre class="prettyprint"><code class=" hljs r">[<span class="hljs-string">'/home/huoty/aboutme/pythonstudy/main'</span>, <span class="hljs-keyword">...</span>]</code></pre> 
<p>然后以模块的方式运行:</p> 
<pre class="prettyprint"><code class="language-shell hljs avrasm">python -m run<span class="hljs-preprocessor">.py</span></code></pre> 
<p>输出内容</p> 
<pre class="prettyprint"><code class=" hljs r">[<span class="hljs-string">''</span>, <span class="hljs-keyword">...</span>]
/usr/bin/python: No module named run.py</code></pre> 
<p>由于输出结果只列出了关键的部分，应该很容易看出他们之间的差异：</p> 
<ul><li><p>直接运行方式是把run.py文件所在的目录放到了sys.path属性中</p></li><li><p>以模块方式运行是把你输入命令的目录（也就是当前工作路径），放到了 sys.path 属性中。</p></li></ul> 
<p>以模块方式运行还有一个不同的地方：多出了一行<code>No module named run.py</code>的错误。实际上以模块方式运行时，Python先对run.py执行一遍 import，所以<code>print(sys.path)</code>被成功执行，然后Python才尝试运行run.py模块，但是在path变量中并没有run.py这个模块，所以报错。正确的运行方式，应该是<code>python -m run</code>。</p> 
<h4 id="42-mainpy的作用">4.2 <code>__main__.py</code>的作用</h4> 
<p>仍然先看例子，假设我们有如下一个包package：</p> 
<pre class="prettyprint"><code class=" hljs markdown">package
├── <span class="hljs-strong">__init__</span>.py
└── <span class="hljs-strong">__main__</span>.py</code></pre> 
<p>其中，文件<code>__init__.py</code>的内容</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> sys

print(<span class="hljs-string">"__init__"</span>)
print(sys.path)</code></pre> 
<p>其中，文件<code>__main__.py</code>的内容</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> sys

print(<span class="hljs-string">"__main__"</span>)
print(sys.path)</code></pre> 
<p>接下来，我们运行这个package，使用<code>python -m package</code>运行，输出结果：</p> 
<pre class="prettyprint"><code class=" hljs r">__init__
[<span class="hljs-string">''</span>, <span class="hljs-keyword">...</span>]

__main__
[<span class="hljs-string">''</span>, <span class="hljs-keyword">...</span>]</code></pre> 
<p>使用<code>python package</code>运行，输出结果：</p> 
<pre class="prettyprint"><code class=" hljs r">__main__
[<span class="hljs-string">'package'</span>, <span class="hljs-keyword">...</span>]</code></pre> 
<p>总结一下</p> 
<ul><li><p>当加上-m参数时，Python会把当前工作目录添加到sys.path中；而不加-m时，Python则会把脚本所在目录添加到sys.path中。</p></li><li><p>当加上-m参数时，Python会先将模块或者包导入，然后再执行。</p></li><li><p><code>__main__.py</code>文件是一个包或者目录的入口程序。不管是用<code>python package</code>还是用<code>python -m package</code>运行，<code>__main__.py</code>文件总是被执行。 <br> <br></p></li></ul> 
<h3 id="5-参考文章">5. 参考文章</h3> 
<p><a href="http://blog.konghy.cn/2017/04/24/python-entry-program/" rel="nofollow noopener noreferrer" target="_blank">1. Python 中的 if <strong>name</strong> == ‘<strong>main</strong>’ 该如何理解</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9730cee1ef328d0057aa961755f3bd67/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">bootstrap-关于class的理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03a2542328db6b841ccff1ef29cce2fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">6-2 单链表元素定位（12 分）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>