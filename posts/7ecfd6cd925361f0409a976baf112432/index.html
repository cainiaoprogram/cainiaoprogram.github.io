<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大话 JavaScript（Speaking JavaScript）：第二十六章到第三十章 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="大话 JavaScript（Speaking JavaScript）：第二十六章到第三十章" />
<meta property="og:description" content="第四部分：提示，工具和库 原文：IV. Tips, Tools, and Libraries
译者：飞龙
协议：CC BY-NC-SA 4.0
本部分提供了使用 JavaScript 的技巧（最佳实践，高级技术和学习资源），并描述了一些重要的工具和库。
第二十六章：元代码风格指南 原文：26. A Meta Code Style Guide
译者：飞龙
协议：CC BY-NC-SA 4.0
JavaScript 有许多优秀的风格指南。因此，没有必要再写一个。相反，本章描述了元风格规则，并调查了现有的风格指南和已建立的最佳实践。它还提到了我喜欢的一些更有争议的做法。这个想法是为了补充现有的风格指南，而不是取代它们。
现有的风格指南 这些是我喜欢的风格指南：
Idiomatic.js：编写一致的、惯用的 JavaScript 的原则
Google JavaScript 风格指南
jQuery JavaScript 风格指南
Airbnb JavaScript 风格指南
此外，还有两个元风格指南：
GitHub 上的流行约定分析 GitHub 代码，找出最常用的编码约定。
JavaScript，获胜的风格检查了几种流行风格指南的大多数推荐。
一般提示 本节将涵盖一些一般的代码编写技巧。
代码应该一致 编写一致代码的两个重要规则。第一条规则是，如果你开始一个新项目，你应该想出一个风格，记录下来，并在任何地方都遵循它。团队越大，检查对风格的自动遵循就越重要，可以通过诸如 JSHint 之类的工具实现。在风格方面，有许多决定要做。其中大多数都有普遍认可的答案。其他必须根据项目定义。例如：
有多少空格（括号后，语句之间等）
缩进（例如，每级缩进多少空格）
如何在哪里编写var语句
第二条规则是，如果你加入一个现有项目，你应该严格遵循它的规则（即使你不同意它们）。
代码应该易于理解 每个人都知道调试比一开始编写程序要困难两倍。因此，如果你在编写时越聪明，那么你将如何调试呢？ ——Brian Kernighan
对于大多数代码，用于阅读的时间远远大于用于编写的时间。因此，使前者尽可能简单非常重要。以下是一些指导方针：
更短并不总是更好
有时写更多意味着事情实际上更容易阅读。让我们考虑两个例子。首先，熟悉的事物更容易理解。这意味着使用熟悉的、稍微更冗长的结构可能更可取。其次，人类读取标记，而不是字符。因此，redBalloon比rdBlln更容易阅读。
好的代码就像教科书
大多数代码库都充满了新的想法和概念。这意味着如果你想要使用一个代码库，你需要学习这些想法和概念。与教科书相比，代码的额外挑战在于人们不会线性阅读它。他们会随时跳进来，应该能够大致理解发生了什么。代码库的三个部分有所帮助：
代码应该解释*发生了什么；它应该是不言自明的。为了编写这样的代码，使用描述性标识符，并将长函数（或方法）分解为更小的子函数。如果这些函数足够小并且有意义的名称，你通常可以避免注释。
注释应该解释为什么事情发生。如果你需要了解一个概念才能理解代码，你可以在标识符中包含该概念的名称，或者在注释中提到它。阅读代码的人可以查阅文档，了解更多关于该概念的信息。
文档应填补代码和注释留下的空白。它应该告诉你如何开始使用代码库，并为你提供大局观。它还应包含所有重要概念的词汇表。
不要聪明；不要让我思考" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7ecfd6cd925361f0409a976baf112432/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T12:50:40+08:00" />
<meta property="article:modified_time" content="2024-01-11T12:50:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大话 JavaScript（Speaking JavaScript）：第二十六章到第三十章</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a>第四部分：提示，工具和库</h2> 
<blockquote> 
 <p>原文：<a href="https://exploringjs.com/es5/pt04.html" rel="nofollow">IV. Tips, Tools, and Libraries</a></p> 
 <p>译者：<a href="https://github.com/wizardforcel">飞龙</a></p> 
 <p>协议：<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow">CC BY-NC-SA 4.0</a></p> 
</blockquote> 
<p>本部分提供了使用 JavaScript 的技巧（最佳实践，高级技术和学习资源），并描述了一些重要的工具和库。</p> 
<h3><a id="_13"></a>第二十六章：元代码风格指南</h3> 
<blockquote> 
 <p>原文：<a href="https://exploringjs.com/es5/ch26.html" rel="nofollow">26. A Meta Code Style Guide</a></p> 
 <p>译者：<a href="https://github.com/wizardforcel">飞龙</a></p> 
 <p>协议：<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow">CC BY-NC-SA 4.0</a></p> 
</blockquote> 
<p>JavaScript 有许多优秀的风格指南。因此，没有必要再写一个。相反，本章描述了元风格规则，并调查了现有的风格指南和已建立的最佳实践。它还提到了我喜欢的一些更有争议的做法。这个想法是为了补充现有的风格指南，而不是取代它们。</p> 
<h3><a id="_24"></a>现有的风格指南</h3> 
<p>这些是我喜欢的风格指南：</p> 
<ul><li> <p><a href="https://github.com/rwaldron/idiomatic.js/">Idiomatic.js：编写一致的、惯用的 JavaScript 的原则</a></p> </li><li> <p><a href="http://bit.ly/1oOEfQ7" rel="nofollow">Google JavaScript 风格指南</a></p> </li><li> <p><a href="http://contribute.jquery.org/style-guide/js/" rel="nofollow">jQuery JavaScript 风格指南</a></p> </li><li> <p><a href="https://github.com/airbnb/javascript">Airbnb JavaScript 风格指南</a></p> </li></ul> 
<p>此外，还有两个元风格指南：</p> 
<ul><li> <p><a href="http://sideeffect.kr/popularconvention/" rel="nofollow">GitHub 上的流行约定</a>分析 GitHub 代码，找出最常用的编码约定。</p> </li><li> <p><a href="http://seravo.fi/2013/javascript-the-winning-style" rel="nofollow">JavaScript，获胜的风格</a>检查了几种流行风格指南的大多数推荐。</p> </li></ul> 
<h3><a id="_42"></a>一般提示</h3> 
<p>本节将涵盖一些一般的代码编写技巧。</p> 
<h4><a id="_46"></a>代码应该一致</h4> 
<p>编写一致代码的两个重要规则。第一条规则是，如果你开始一个新项目，你应该想出一个风格，记录下来，并在任何地方都遵循它。团队越大，检查对风格的自动遵循就越重要，可以通过诸如 JSHint 之类的工具实现。在风格方面，有许多决定要做。其中大多数都有普遍认可的答案。其他必须根据项目定义。例如：</p> 
<ul><li> <p>有多少空格（括号后，语句之间等）</p> </li><li> <p>缩进（例如，每级缩进多少空格）</p> </li><li> <p>如何在哪里编写<code>var</code>语句</p> </li></ul> 
<p>第二条规则是，如果你加入一个现有项目，你应该严格遵循它的规则（即使你不同意它们）。</p> 
<h4><a id="_58"></a>代码应该易于理解</h4> 
<blockquote> 
 <p>每个人都知道调试比一开始编写程序要困难两倍。因此，如果你在编写时越聪明，那么你将如何调试呢？ ——Brian Kernighan</p> 
</blockquote> 
<p>对于大多数代码，用于阅读的时间远远大于用于编写的时间。因此，使前者尽可能简单非常重要。以下是一些指导方针：</p> 
<p>更短并不总是更好</p> 
<p>有时写<em>更多</em>意味着事情实际上更容易阅读。让我们考虑两个例子。首先，熟悉的事物更容易理解。这意味着使用熟悉的、稍微更冗长的结构可能更可取。其次，人类读取标记，而不是字符。因此，<code>redBalloon</code>比<code>rdBlln</code>更容易阅读。</p> 
<p>好的代码就像教科书</p> 
<p>大多数代码库都充满了新的想法和概念。这意味着如果你想要使用一个代码库，你需要学习这些想法和概念。与教科书相比，代码的额外挑战在于人们不会线性阅读它。他们会随时跳进来，应该能够大致理解发生了什么。代码库的三个部分有所帮助：</p> 
<ul><li> <p><em>代码</em>应该解释*发生了什么；它应该是不言自明的。为了编写这样的代码，使用描述性标识符，并将长函数（或方法）分解为更小的子函数。如果这些函数足够小并且有意义的名称，你通常可以避免注释。</p> </li><li> <p><em>注释</em>应该解释<em>为什么</em>事情发生。如果你需要了解一个概念才能理解代码，你可以在标识符中包含该概念的名称，或者在注释中提到它。阅读代码的人可以查阅文档，了解更多关于该概念的信息。</p> </li><li> <p><em>文档</em>应填补代码和注释留下的空白。它应该告诉你如何开始使用代码库，并为你提供大局观。它还应包含所有重要概念的词汇表。</p> </li></ul> 
<p>不要聪明；不要让我思考</p> 
<p>有很多巧妙的代码利用对语言的深入了解来实现令人印象深刻的简洁性。这样的代码通常像一个谜题，很难理解。你会遇到这样的观点，如果人们不理解这样的代码，也许他们真的应该先学习 JavaScript。但这不是这篇文章要讨论的。无论你有多聪明，进入其他人的思维世界总是具有挑战性的。所以简单的代码并不愚蠢，它是大部分努力都花在让一切易于理解的代码。</p> 
<p>避免为速度或代码大小进行优化</p> 
<p>许多巧妙的技巧都是针对这些优化的。然而，你通常不需要它们。一方面，JavaScript 引擎变得越来越智能，自动优化遵循已建立模式的代码的速度。另一方面，缩小工具（第三十二章）重写你的代码，使其尽可能小。在这两种情况下，工具都是为你聪明的，这样你就不必自己聪明了。</p> 
<p>有时你别无选择，只能优化代码的性能。如果你这样做，请确保测量和优化正确的部分。在浏览器中，问题通常与 DOM 和 HTML 相关，而不是语言本身。</p> 
<h3><a id="_88"></a>常见的最佳实践</h3> 
<p>大多数 JavaScript 程序员都同意以下最佳实践：</p> 
<ul><li> <p>使用严格模式。它使 JavaScript 成为一种更清洁的语言（参见<a href="ch07.html#strict_mode" rel="nofollow" title="严格模式">严格模式</a>）。</p> </li><li> <p>始终使用分号。避免自动分号插入的陷阱（参见<a href="ch07.html#automatic_semicolon_insertion" rel="nofollow" title="自动分号插入">自动分号插入</a>）。</p> </li><li> <p>始终使用严格相等（<code>===</code>）和严格不等（<code>!==</code>）。我建议永远不要偏离这个规则。即使它们是等价的，我甚至更喜欢以下两个条件中的第一个：</p> <pre><code class="prism language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">...</span>  <span class="token comment">// my choice</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">...</span>  <span class="token comment">// equivalent</span>
</code></pre> </li><li> <p>要么只使用空格，要么只使用制表符进行缩进，但不要混合使用它们。</p> </li><li> <p>引用字符串：在 JavaScript 中，你可以用单引号或双引号写字符串文字。单引号更常见。它们使得处理 HTML 代码更容易（通常 HTML 代码中的属性值是双引号）。其他考虑因素在<a href="ch12.html#quoting_strings" rel="nofollow" title="字符串文字">字符串文字</a>中提到。</p> </li><li> <p>避免全局变量（<a href="ch16.html#avoid_global_variables" rel="nofollow" title="最佳实践：避免创建全局变量">最佳实践：避免创建全局变量</a>）。</p> </li></ul> 
<h4><a id="_109"></a>括号样式</h4> 
<p>在大括号界定代码块的语言中，括号样式决定你放置这些括号的位置。在类 C 语言（如 Java 和 JavaScript）中，有两种最常见的括号样式：Allman 样式和 1TBS。</p> 
<h5><a id="Allman__113"></a>Allman 样式</h5> 
<p>如果一个语句包含一个块，那么该块被认为与语句的头部有些分离：它的左大括号在自己的一行上，与头部的缩进级别相同。例如：</p> 
<pre><code class="prism language-js"><span class="token comment">// Allman brace style</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="1TBS_133"></a>1TBS（真正的括号样式）</h5> 
<p>在这里，一个块与其语句的标题更紧密地关联在一起；它在同一行之后开始。控制流语句的主体总是放在大括号中，即使只有一个语句。例如：</p> 
<pre><code class="prism language-js"><span class="token comment">// One True Brace Style</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>1TBS 是(Kernighan 和 Ritchie)样式的一个变体。在 K&amp;R 样式中，函数以 Allman 样式编写，并且在不必要的情况下省略大括号，例如，在单语句<code>then</code>情况下：</p> 
<pre><code class="prism language-js"><span class="token comment">// K&amp;R brace style</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="JavaScript_164"></a>JavaScript</h5> 
<p>JavaScript 世界中的事实标准是 1TBS。它是从 Java 继承而来，大多数风格指南都推荐使用它。其中一个原因是客观的。如果你返回一个对象字面量，你必须将开括号放在与关键字<code>return</code>相同的行上，就像这样（否则，自动分号插入会在<code>return</code>后插入一个分号，意味着什么也没有返回；参见<a href="ch07.html#asi_after_return" rel="nofollow" title="Pitfall: ASI can unexpectedly break up statements">Pitfall: ASI can unexpectedly break up statements</a>）：</p> 
<pre><code class="prism language-js"><span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Jane'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>显然，对象字面量不是一个代码块，但如果两者格式化方式相同，看起来更一致，你犯错的可能性就更小。</p> 
<p>我的个人风格和偏好是：</p> 
<ul><li> <p>1TBS（这意味着你应该尽可能使用大括号）。</p> </li><li> <p>作为例外，如果一个语句可以写在一行上，我会省略大括号。例如：</p> <pre><code class="prism language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span>
</code></pre> </li></ul> 
<h4><a id="_186"></a>更喜欢字面量而不是构造函数</h4> 
<p>几个字面量产生的对象也可以通过构造函数创建。然而，后者通常是更好的选择：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// no</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// yes</span>

<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// no</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// yes</span>

<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// avoid if possible</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">abc</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> <span class="token comment">// yes</span>
</code></pre> 
<p>永远不要使用构造函数<code>Array</code>来创建具有给定元素的数组。<a href="ch18.html#avoid_array_constructor" rel="nofollow" title="初始化具有元素的数组（避免！）">初始化具有元素的数组（避免！）</a>解释了原因：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// never ever</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// yes</span>
</code></pre> 
<h4><a id="_208"></a>不要聪明</h4> 
<p>本节收集了一些不推荐的聪明用法。</p> 
<h5><a id="_212"></a>条件运算符</h5> 
<p>不要嵌套条件运算符：</p> 
<pre><code class="prism language-js"><span class="token comment">// Don’t:</span>
<span class="token keyword">return</span> x <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">'red'</span> <span class="token operator">:</span> x <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">'green'</span> <span class="token operator">:</span> <span class="token string">'blue'</span><span class="token punctuation">;</span>

<span class="token comment">// Better:</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'red'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'green'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'blue'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Best:</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token string">'red'</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token string">'green'</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token string">'blue'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_if__240"></a>缩写 if 语句</h5> 
<p>不要通过逻辑运算符缩写<code>if</code>语句：</p> 
<pre><code class="prism language-js">foo <span class="token operator">&amp;&amp;</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// no</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yes</span>

foo <span class="token operator">||</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// no</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>foo<span class="token punctuation">)</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yes</span>
</code></pre> 
<h5><a id="_252"></a>增量运算符</h5> 
<p>如果可能的话，使用增量运算符（<code>++</code>）和减量运算符（<code>--</code>）作为语句；不要将它们用作表达式。在后一种情况下，它们会返回一个值，虽然有一个助记符，但你仍然需要思考来弄清楚发生了什么：</p> 
<pre><code class="prism language-js"><span class="token comment">// Unsure: what is happening?</span>
<span class="token keyword">return</span> <span class="token operator">++</span>foo<span class="token punctuation">;</span>

<span class="token comment">// Easy to understand</span>
<span class="token operator">++</span>foo<span class="token punctuation">;</span>
<span class="token keyword">return</span> foo<span class="token punctuation">;</span>
</code></pre> 
<h5><a id="_265"></a>检查未定义</h5> 
<pre><code class="prism language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// not necessary in ES5</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// preferable</span>
</code></pre> 
<p>从 ECMAScript 5 开始，第二种检查方式更好。<a href="ch08.html#changing_undefined" rel="nofollow" title="更改未定义">更改未定义</a>解释了为什么。</p> 
<h5><a id="_274"></a>将数字转换为整数</h5> 
<pre><code class="prism language-js"><span class="token keyword">return</span> x <span class="token operator">&gt;&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// no</span>
<span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yes</span>
</code></pre> 
<p>移位运算符可以用来将数字转换为整数。然而，通常最好使用更明确的替代方法，比如<code>Math.round()</code>。<a href="ch11.html#converting_to_integer" rel="nofollow" title="转换为整数">转换为整数</a>概述了所有转换为整数的方法。</p> 
<h4><a id="_283"></a>可接受的聪明用法</h4> 
<p>有时候你可以在 JavaScript 中很聪明——如果这种聪明已经成为一种已经建立的模式。</p> 
<h5><a id="_287"></a>默认值</h5> 
<p>使用或（<code>||</code>）运算符提供默认值是一种常见的模式——例如，对于参数：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    x <span class="token operator">=</span> x <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>有关详细信息和更多示例，请参阅<a href="ch10.html#default_via_or" rel="nofollow" title="模式：提供默认值">模式：提供默认值</a>。</p> 
<h5><a id="_300"></a>通用方法</h5> 
<p>如果你通用地使用方法，你可以将<code>Object.prototype</code>缩写为<code>{}</code>。以下两个表达式是等价的：</p> 
<pre><code class="prism language-js"><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> propKey</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> propKey<span class="token punctuation">)</span>
</code></pre> 
<p><code>Array.prototype</code>可以缩写为<code>[]</code>：</p> 
<pre><code class="prism language-js"><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
</code></pre> 
<p>我对这个持观望态度。这是一个技巧（你正在通过一个实例访问原型属性）。但它减少了混乱，我期望引擎最终会优化这种模式。</p> 
<h5><a id="ECMAScript_5_318"></a>ECMAScript 5：尾随逗号</h5> 
<p>在 ECMAScript 5 中，对象字面量中的尾随逗号是合法的：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">first</span><span class="token operator">:</span> <span class="token string">'Jane'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">last</span><span class="token operator">:</span> <span class="token string">'Doe'</span><span class="token punctuation">,</span> <span class="token comment">// legal: trailing comma</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="ECMAScript_5_329"></a>ECMAScript 5：保留字</h5> 
<p>ECMAScript 5 还允许你使用保留字（如<code>new</code>）作为属性键：</p> 
<pre><code class="prism language-js"><span class="token operator">&gt;</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">new</span><span class="token operator">:</span> <span class="token string">'abc'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&gt;</span> obj<span class="token punctuation">.</span>new
<span class="token string">'abc'</span>
</code></pre> 
<h3><a id="_339"></a>有争议的规则</h3> 
<p>让我们看看一些我喜欢的、有点具有争议的惯例。</p> 
<h4><a id="_343"></a>语法</h4> 
<p>我们将从语法惯例开始：</p> 
<p>紧凑的空格</p> 
<p>我喜欢<em>相对</em>紧凑的空格。这个模型是用英语写的：在开括号后和闭括号前没有空格。逗号后有空格：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对于匿名函数，我遵循道格拉斯·克罗克福德的规则，在关键字<code>function</code>后面加一个空格。理由是，如果去掉名字，这就是一个命名函数表达式的样子：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token operator">...</span> <span class="token punctuation">}</span>  <span class="token comment">// named function expression</span>
<span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token operator">...</span> <span class="token punctuation">}</span>     <span class="token comment">// anonymous function expression</span>
</code></pre> 
<p>每个缩进级别四个空格</p> 
<p>我看到的大多数代码都使用空格缩进，因为制表符在应用程序和操作系统之间显示的方式有很大不同。我更喜欢每级缩进四个空格，因为这样缩进更加明显。</p> 
<p>将条件操作符放在括号中</p> 
<p>这有助于阅读，因为更容易确定操作符的范围：</p> 
<pre><code class="prism language-js"><span class="token keyword">return</span> result <span class="token operator">?</span> result <span class="token operator">:</span> theDefault<span class="token punctuation">;</span>  <span class="token comment">// no</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span>result <span class="token operator">?</span> result <span class="token operator">:</span> theDefault<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// yes</span>
</code></pre> 
<h4><a id="_379"></a>变量</h4> 
<p>接下来，我将介绍变量的约定：</p> 
<p>每行只声明一个变量</p> 
<p>不要用单个声明声明多个变量：</p> 
<pre><code class="prism language-js"><span class="token comment">// no</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
    bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
    baz<span class="token punctuation">;</span>

<span class="token comment">// yes</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> baz<span class="token punctuation">;</span>
</code></pre> 
<p>这种方法的优势在于删除、插入和重新排列行更简单，行也会自动正确缩进。</p> 
<p>保持变量声明局部</p> 
<p>如果你的函数不太长（无论如何都不应该太长），那么你可以在提升方面放松一些，假装<code>var</code>声明是块作用域的。换句话说，你可以在使用变量的上下文中声明变量（在循环内，在<code>then</code>块或<code>else</code>块内等）。这种局部封装使得代码片段更容易理解。也更容易删除代码片段或将其移动到其他地方。</p> 
<p>如果你在一个块内，就待在那个块内</p> 
<p>作为前一条规则的补充：不要在两个不同的块中声明相同的变量。例如：</p> 
<pre><code class="prism language-js"><span class="token comment">// Don’t do this</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">doSomethingWith</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>前面的代码和下面的代码有相同的效果和意图，所以应该这样写：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> x<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    x <span class="token operator">=</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">doSomethingWith</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_431"></a>面向对象</h4> 
<p>现在我们将讨论与面向对象有关的约定。</p> 
<p>优先使用构造函数而不是其他实例创建模式</p> 
<p>我建议你：</p> 
<ul><li> <p>总是使用构造函数。</p> </li><li> <p>创建实例时总是使用<code>new</code>。</p> </li></ul> 
<p>这样做的主要优势是：</p> 
<ul><li> <p>你的代码更适合 JavaScript 主流，更有可能在不同框架之间移植。</p> </li><li> <p>在现代引擎中，使用构造函数的实例非常快（例如，通过<a href="http://bit.ly/1oOEAlZ" rel="nofollow">hidden classes</a>）。</p> </li><li> <p>在即将到来的 ECMAScript 6 中，类将是默认的继承构造。</p> </li></ul> 
<p>对于构造函数，使用严格模式很重要，因为它可以防止你忘记实例化时使用<code>new</code>操作符。你应该知道你可以在构造函数中返回任何对象。有关使用构造函数的更多提示，请参阅<a href="ch17_split_001.html#constructor_tips" rel="nofollow" title="Tips for Implementing Constructors">实现构造函数的提示</a>。</p> 
<p>避免使用闭包来处理私有数据</p> 
<p>如果你希望对象的私有数据完全安全，你必须使用闭包。否则，你可以使用普通属性。一个常见的做法是在私有属性的名称前加下划线。闭包的问题在于代码变得更加复杂（除非你将所有方法都放在实例中，这是不符合惯例且慢的），而且速度更慢（访问闭包中的数据目前比访问属性更慢）。<a href="ch17_split_001.html#private_data_for_objects" rel="nofollow" title="Keeping Data Private">保持数据私有</a>更详细地介绍了这个主题。</p> 
<p>如果构造函数没有参数，写括号</p> 
<p>我发现这样的构造函数调用用括号看起来更清晰：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">;</span>  <span class="token comment">// no</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// yes</span>
</code></pre> 
<p>小心操作符优先级</p> 
<p>使用括号，这样两个操作符就不会相互竞争——结果并不总是你所期望的：</p> 
<pre><code class="prism language-js"><span class="token operator">&gt;</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span> <span class="token operator">||</span> <span class="token boolean">true</span>
<span class="token boolean">true</span>
<span class="token operator">&gt;</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token boolean">false</span>
<span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token boolean">true</span>
<span class="token boolean">true</span>
</code></pre> 
<p><code>instanceof</code>特别棘手：</p> 
<pre><code class="prism language-js"><span class="token operator">&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
<span class="token boolean">false</span>
<span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
<span class="token boolean">false</span>
<span class="token operator">&gt;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>
</code></pre> 
<p>然而，我发现构造函数后的方法调用并不成问题：</p> 
<pre><code class="prism language-js"><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span>
<span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// not necessary</span>
</code></pre> 
<h4><a id="_497"></a>杂项</h4> 
<p>这一部分收集了各种提示：</p> 
<p>强制转换</p> 
<p>通过<code>Boolean</code>、<code>Number</code>、<code>String()</code>、<code>Object()</code>（作为函数使用——永远不要将这些函数用作构造函数）将值强制转换为类型。理由是这种约定更具描述性：</p> 
<pre><code class="prism language-js"><span class="token operator">&gt;</span> <span class="token operator">+</span><span class="token string">'123'</span>  <span class="token comment">// no</span>
<span class="token number">123</span>
<span class="token operator">&gt;</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span>  <span class="token comment">// yes</span>
<span class="token number">123</span>

<span class="token operator">&gt;</span> <span class="token string">''</span><span class="token operator">+</span><span class="token boolean">true</span>  <span class="token comment">// no</span>
<span class="token string">'true'</span>
<span class="token operator">&gt;</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment">// yes</span>
<span class="token string">'true'</span>
</code></pre> 
<p>避免使用<code>this</code>作为隐式参数</p> 
<p><code>this</code>应该只指当前方法调用的接收者；不应滥用作为隐式参数。理由是这样的函数更容易调用和理解。我也喜欢保持面向对象和函数机制分开：</p> 
<pre><code class="prism language-js"><span class="token comment">// Avoid:</span>
<span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">logError</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Prefer:</span>
<span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    context<span class="token punctuation">.</span><span class="token function">logError</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过<code>in</code>和<code>hasOwnProperty</code>检查属性的存在（参见<a href="ch17_split_000.html#iterate_and_detect_properties" rel="nofollow" title="Iteration and Detection of Properties">Iteration and Detection of Properties</a>）</p> 
<p>这比与<code>undefined</code>进行比较或检查真实性更加自明和安全：</p> 
<pre><code class="prism language-js"><span class="token comment">// All properties:</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>  <span class="token comment">// no</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span>  <span class="token comment">// no</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'foo'</span> <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token operator">...</span> <span class="token comment">// yes</span>

<span class="token comment">// Own properties:</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">...</span> <span class="token comment">// risky for arbitrary objects</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">...</span> <span class="token comment">// safe</span>
</code></pre> 
<p>快速失败</p> 
<p>如果可以的话，最好是快速失败，而不是悄悄失败。JavaScript 只是如此宽容（例如，除以零），因为 ECMAScript 的第一个版本没有异常。例如，不要强制转换值；抛出异常。但是，当您的代码处于生产状态时，您必须找到从失败中恢复的方法。</p> 
<h3><a id="_552"></a>结论</h3> 
<p>每当您考虑样式问题时，请问自己：什么使我的代码更容易理解？抵制诱惑，不要聪明，把大部分机械聪明留给 JavaScript 引擎和缩小器（参见第三十二章）。</p> 
<hr> 
<p>¹⁹ 甚至有人说它们是同义词，1TBS 是一种戏谑地指代 K&amp;R 的方式。</p> 
<h3><a id="_561"></a>第二十七章：调试的语言机制</h3> 
<blockquote> 
 <p>原文：<a href="https://exploringjs.com/es5/ch27.html" rel="nofollow">27. Language Mechanisms for Debugging</a></p> 
 <p>译者：<a href="https://github.com/wizardforcel">飞龙</a></p> 
 <p>协议：<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow">CC BY-NC-SA 4.0</a></p> 
</blockquote> 
<p>以下三种语言结构有助于调试。它们显然应该由适当的调试器补充：</p> 
<ul><li> <p><code>debugger</code>语句的行为类似于断点，并启动调试器。</p> </li><li> <p><code>console.log(x)</code>将值<code>x</code>记录到 JavaScript 引擎的控制台中。</p> </li><li> <p><code>console.trace()</code>将堆栈跟踪打印到引擎的控制台中。</p> </li></ul> 
<p>控制台 API 提供了更多的调试帮助，并在<a href="ch23.html#console_api" rel="nofollow" title="The Console API">The Console API</a>中有更详细的文档。异常处理在第十四章中有解释。</p> 
<h3><a id="_581"></a>第二十八章：内置子类</h3> 
<blockquote> 
 <p>原文：<a href="https://exploringjs.com/es5/ch28.html" rel="nofollow">28. Subclassing Built-ins</a></p> 
 <p>译者：<a href="https://github.com/wizardforcel">飞龙</a></p> 
 <p>协议：<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow">CC BY-NC-SA 4.0</a></p> 
</blockquote> 
<p>JavaScript 的内置构造函数很难进行子类化。本章解释了原因并提出了解决方案。</p> 
<h3><a id="_592"></a>术语</h3> 
<p>我们使用短语<em>subclass a built-in</em>并避免术语<em>extend</em>，因为它在 JavaScript 中被使用：</p> 
<p>子类化内置<code>A</code></p> 
<p>创建给定内置构造函数<code>A</code>的子构造函数<code>B</code>。<code>B</code>的实例也是<code>A</code>的实例。</p> 
<p>扩展对象<code>obj</code></p> 
<p>将一个对象的属性复制到另一个对象。Underscore.js <a href="http://underscorejs.org/#extend" rel="nofollow">使用这个术语</a>，延续了 Prototype 框架建立的传统。</p> 
<p>子类化内置有两个障碍：具有内部属性的实例和无法作为函数调用的构造函数。</p> 
<h3><a id="_1_606"></a>障碍 1：具有内部属性的实例</h3> 
<p>大多数内置构造函数都有所谓的<em>内部属性</em>的实例（参见<a href="ch17_split_000.html#kinds_of_properties" rel="nofollow" title="Kinds of Properties">Kinds of Properties</a>），它们的名称用双方括号写成，像这样：<code>[[PrimitiveValue]]</code>。内部属性由 JavaScript 引擎管理，通常在 JavaScript 中无法直接访问。JavaScript 中的正常子类化技术是使用<code>this</code>的子构造函数调用超级构造函数（参见<a href="ch17_split_001.html#constructor_inheritance" rel="nofollow" title="Layer 4: Inheritance Between Constructors">Layer 4: Inheritance Between Constructors</a>）：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// (1)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// (1)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Add superproperties to subinstance</span>
    <span class="token function">Super</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// (2)</span>
    <span class="token comment">// Add subproperty</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>大多数内置忽略作为<code>this</code>传入的子实例（2），这是下一节描述的一个障碍。此外，向现有实例添加内部属性（1）通常是不可能的，因为它们往往会从根本上改变实例的性质。因此，不能使用（2）处的调用来添加内部属性。以下构造函数具有具有内部属性的实例：</p> 
<p>包装构造函数</p> 
<p><code>Boolean</code>，<code>Number</code>和<code>String</code>的实例包装原始值。它们都有内部属性<code>[[PrimitiveValue]]</code>，其值由<code>valueOf()</code>返回；<code>String</code>还有两个额外的实例属性：</p> 
<ul><li> <p><code>Boolean</code>：内部实例属性<code>[[PrimitiveValue]]</code>。</p> </li><li> <p><code>Number</code>：内部实例属性<code>[[PrimitiveValue]]</code>。</p> </li><li> <p><code>String</code>：内部实例属性<code>[[PrimitiveValue]]</code>，自定义内部实例方法<code>[[GetOwnProperty]]</code>，普通实例属性<code>length</code>。<code>[[GetOwnProperty]]</code>使得可以通过使用数组索引时从包装字符串中读取字符来进行索引访问。</p> </li></ul> 
<p><code>Array</code></p> 
<p>自定义的内部实例方法<code>[[DefineOwnProperty]]</code>拦截正在设置的属性。它确保<code>length</code>属性正常工作，通过在添加数组元素时保持<code>length</code>的最新状态，并在<code>length</code>变小时删除多余的元素。</p> 
<p><code>Date</code></p> 
<p>内部实例属性<code>[[PrimitiveValue]]</code>存储由日期实例表示的时间（自 1970 年 1 月 1 日 00:00:00 UTC 以来的毫秒数）。</p> 
<p><code>Function</code></p> 
<p>内部实例属性<code>[[Call]]</code>（实例被调用时要执行的代码）和可能还有其他属性。</p> 
<p><code>RegExp</code></p> 
<p>内部实例属性<code>[[Match]]</code>，以及两个非内部实例属性。来自 ECMAScript 规范：</p> 
<blockquote> 
 <p><code>[[Match]]</code>内部属性的值是<code>RegExp</code>对象的模式的实现相关表示。</p> 
</blockquote> 
<p>唯一没有内部属性的内置构造函数是<code>Error</code>和<code>Object</code>。</p> 
<h4><a id="_1_655"></a>解决障碍 1</h4> 
<p><code>MyArray</code>是<code>Array</code>的子类。它有一个 getter <code>size</code>，返回数组中的实际元素，忽略了空洞（其中<code>length</code>考虑了空洞）。实现<code>MyArray</code>的技巧是创建一个数组实例，并将其方法复制到其中：²⁰</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">MyArray</span><span class="token punctuation">(</span><span class="token comment">/*arguments*/</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// Don’t use Array constructor to set up elements (doesn’t always work)</span>
    <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// (1)</span>
    <span class="token function">copyOwnPropertiesFrom</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> MyArray<span class="token punctuation">.</span>methods<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
MyArray<span class="token punctuation">.</span>methods <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">get</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">var</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">)</span> size<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此代码使用辅助函数<code>copyOwnPropertiesFrom()</code>，该函数在<a href="ch17_split_000.html#code_copyOwnPropertiesFrom" rel="nofollow" title="Copying an Object">Copying an Object</a>中显示和解释。</p> 
<p>我们在第（1）行不调用<code>Array</code>构造函数，因为有一个怪癖：如果它以一个数字作为单个参数调用，那么这个数字不会成为一个元素，而是确定一个空数组的长度（参见<a href="ch18.html#avoid_array_constructor" rel="nofollow" title="Initializing an array with elements (avoid!)">Initializing an array with elements (avoid!)</a>）。</p> 
<p>以下是交互：</p> 
<pre><code class="prism language-js"><span class="token operator">&gt;</span> <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyArray</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span>
<span class="token operator">&gt;</span> a<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token operator">&gt;</span> a<span class="token punctuation">.</span>length
<span class="token number">4</span>
<span class="token operator">&gt;</span> a<span class="token punctuation">.</span>size
<span class="token number">2</span>
</code></pre> 
<h4><a id="_693"></a>注意事项</h4> 
<p>将方法复制到实例会导致冗余，如果可以使用原型，则可以避免这种情况。此外，<code>MyArray</code>创建的对象不是其实例：</p> 
<pre><code class="prism language-js"><span class="token operator">&gt;</span> a <span class="token keyword">instanceof</span> <span class="token class-name">MyArray</span>
<span class="token boolean">false</span>
<span class="token operator">&gt;</span> a <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
<span class="token boolean">true</span>
</code></pre> 
<h3><a id="_2_704"></a>障碍 2：无法将构造函数作为函数调用</h3> 
<p>即使<code>Error</code>和子类没有具有内部属性的实例，您仍然无法轻松地对其进行子类化，因为子类化的标准模式不起作用（与之前重复）：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Add superproperties to subinstance</span>
    <span class="token function">Super</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// (1)</span>
    <span class="token comment">// Add subproperty</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>问题在于<code>Error</code>总是产生一个新实例，即使作为函数调用（1）；也就是说，它忽略了通过<code>call()</code>传递给它的<code>this</code>参数：</p> 
<pre><code class="prism language-js"><span class="token operator">&gt;</span> <span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&gt;</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token function">Error</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// new instance</span>
<span class="token punctuation">[</span> <span class="token string">'stack'</span><span class="token punctuation">,</span> <span class="token string">'arguments'</span><span class="token punctuation">,</span> <span class="token string">'type'</span> <span class="token punctuation">]</span>
<span class="token operator">&gt;</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token comment">// unchanged</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre> 
<p>在前面的交互中，<code>Error</code>返回了一个具有自己属性的实例，但它是一个新实例，而不是<code>e</code>。如果<code>Error</code>将自己的属性添加到<code>this</code>（在前面的情况下是<code>e</code>），那么子类化模式将起作用。</p> 
<h4><a id="_2_733"></a>解决障碍 2</h4> 
<p>在子构造函数内部，创建一个新的超级实例，并将其自己的属性复制到子实例中：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Use Error as a function</span>
    <span class="token keyword">var</span> superInstance <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">copyOwnPropertiesFrom</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> superInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">MyError</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Error</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MyError</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> MyError<span class="token punctuation">;</span>
</code></pre> 
<p>辅助函数<code>copyOwnPropertiesFrom()</code>在<a href="ch17_split_000.html#code_copyOwnPropertiesFrom" rel="nofollow" title="Copying an Object">Copying an Object</a>中显示。尝试<code>MyError</code>：</p> 
<pre><code class="prism language-js"><span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyError</span><span class="token punctuation">(</span><span class="token string">'Something happened'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Properties: '</span><span class="token operator">+</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这是在 Node.js 上的输出：</p> 
<pre><code class="prism language-js"><span class="token literal-property property">Properties</span><span class="token operator">:</span> stack<span class="token punctuation">,</span>arguments<span class="token punctuation">,</span>message<span class="token punctuation">,</span>type
</code></pre> 
<p><code>instanceof</code>关系应该是正常的：</p> 
<pre><code class="prism language-js"><span class="token operator">&gt;</span> <span class="token keyword">new</span> <span class="token class-name">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Error</span>
<span class="token boolean">true</span>
<span class="token operator">&gt;</span> <span class="token keyword">new</span> <span class="token class-name">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">MyError</span>
<span class="token boolean">true</span>
</code></pre> 
<h3><a id="_772"></a>另一种解决方案：委托</h3> 
<p>委托是子类化的一个非常干净的替代方法。例如，要创建自己的数组构造函数，您可以在属性中保留一个数组：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">MyArray</span><span class="token punctuation">(</span><span class="token comment">/*arguments*/</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span><span class="token class-name">MyArray</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">var</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">)</span> size<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> size<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">.</span>length <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>显而易见的限制是，您无法通过方括号访问<code>MyArray</code>的元素；您必须使用方法来这样做：</p> 
<pre><code class="prism language-js"><span class="token class-name">MyArray</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">MyArray</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">index<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以通过以下元编程的方法传递<code>Array.prototype</code>的普通方法：</p> 
<pre><code class="prism language-js"><span class="token punctuation">[</span> <span class="token string">'toString'</span><span class="token punctuation">,</span> <span class="token string">'push'</span><span class="token punctuation">,</span> <span class="token string">'pop'</span> <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">MyArray</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们通过在存储在<code>MyArray</code>实例中的数组<code>this.array</code>上调用它们，从<code>Array</code>方法派生<code>MyArray</code>方法。</p> 
<p>使用<code>MyArray</code>：</p> 
<pre><code class="prism language-js"><span class="token operator">&gt;</span> <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyArray</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&gt;</span> a<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token operator">&gt;</span> a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span>
<span class="token number">5</span>
<span class="token operator">&gt;</span> a<span class="token punctuation">.</span>length
<span class="token number">5</span>
<span class="token operator">&gt;</span> a<span class="token punctuation">.</span>size
<span class="token number">3</span>
<span class="token operator">&gt;</span> a<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&gt;</span> a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'x,b,,,c'</span>
</code></pre> 
<hr> 
<p>²⁰受<a href="http://bit.ly/1oOERFo" rel="nofollow">Ben Nadel</a>的一篇博文的启发。</p> 
<h3><a id="JSDoc_API__846"></a>第二十九章：JSDoc：生成 API 文档</h3> 
<blockquote> 
 <p>原文：<a href="https://exploringjs.com/es5/ch29.html" rel="nofollow">29. JSDoc: Generating API Documentation</a></p> 
 <p>译者：<a href="https://github.com/wizardforcel">飞龙</a></p> 
 <p>协议：<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow">CC BY-NC-SA 4.0</a></p> 
</blockquote> 
<p>这是一个常见的开发问题：您已经编写了 JavaScript 代码，其他人需要使用它，并且需要一个漂亮的 HTML 文档来描述其 API。在 JavaScript 世界中生成 API 文档的事实标准工具是<a href="http://usejsdoc.org" rel="nofollow"><em>JSDoc</em></a>。²¹ 它是模仿其 Java 模拟品 JavaDoc 而建立的。</p> 
<p>JSDoc 接受带有<code>/** */</code>注释的 JavaScript 代码（以星号开头的普通块注释）并为其生成 HTML 文档。例如，给定以下代码：</p> 
<pre><code class="prism language-js"><span class="token comment">/** @namespace */</span>
<span class="token keyword">var</span> util <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/**
 * Repeat &lt;tt&gt;str&lt;/tt&gt; several times.
 * @param {string} str The string to repeat.
 * @param {number} [times=1] How many times to repeat the string.
 * @returns {string}
 */</span>
    <span class="token function-variable function">repeat</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> times</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>times <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">||</span> times <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            times <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>times<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>生成的 HTML 在 Web 浏览器中显示如<a href="ch29.html#figjsdoc_screen" rel="nofollow" title="图 29-1. JSDoc 生成的 HTML 输出。">图 29-1</a>所示。</p> 
<p><img src="https://images2.imgbox.com/0f/ce/de21JsFK_o.jpg" alt="JSDoc 生成的 HTML 输出。"></p> 
<p>图 29-1. JSDoc 生成的 HTML 输出。</p> 
<p>JSDoc 网站上的<a href="http://usejsdoc.org/about-jsdoc3.html" rel="nofollow">自述文件</a>解释了如何安装和调用这个工具。</p> 
<h3><a id="JSDoc__885"></a>JSDoc 的基础知识</h3> 
<p>JSDoc 的全部内容都是关于文档化<em>实体</em>（函数、方法、构造函数等）。这是通过在实体之前的注释中实现的，这些注释以<code>/**</code>开头。</p> 
<h4><a id="_889"></a>语法</h4> 
<p>让我们回顾一下开头显示的注释：</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Repeat &lt;tt&gt;str&lt;/tt&gt; several times.
 * @param {string} str The string to repeat.
 * @param {number} [times=1] How many times to repeat the string.
 * @returns {string}
 */</span>
</code></pre> 
<p>这演示了一些 JSDoc 的语法，包括以下部分：</p> 
<p>JSDoc 注释</p> 
<p>这是一个 JavaScript 块注释，其第一个字符是星号。这会产生一个假象，即<code>/**</code>标记开始了这样的注释。</p> 
<p>标签</p> 
<p>您可以通过以@符号为前缀的<em>标签</em>开始行来构造注释。在前面的代码中，<code>@param</code>就是一个例子。</p> 
<p>HTML</p> 
<p>您可以在 JSDoc 注释中自由使用 HTML。例如，<code>&lt;tt&gt;</code>显示单词的等宽字体。</p> 
<p>类型注释</p> 
<p>您可以通过大括号中的类型名称来记录实体的类型。变化包括：</p> 
<ul><li> <p>单一类型：<code>@param {string} name</code></p> </li><li> <p>多种类型：<code>@param {string|number} idCode</code></p> </li><li> <p>类型为数组：<code>@param {string[]} names</code></p> </li></ul> 
<p>名称路径</p> 
<p>在 JSDoc 注释中，所谓的<em>namepaths</em>用于引用实体。这些路径的语法如下：</p> 
<pre><code class="prism language-js">myFunction
MyClass
MyClass<span class="token punctuation">.</span>staticMember
MyClass#instanceMember
</code></pre> 
<p><em>类</em>通常（由）构造函数实现。静态成员是构造函数的属性。JSDoc 对<em>实例成员</em>有一个广泛的定义。它意味着可以通过实例访问的一切。因此，实例成员包括实例属性和原型属性。</p> 
<h4><a id="_939"></a>命名类型</h4> 
<p>实体的类型要么是基本类型，要么是类。前者的名称总是以小写字母开头；后者的名称总是以大写字母开头。换句话说，基本类型的类型名称是<code>boolean</code>、<code>number</code>和<code>string</code>，就像<code>typeof</code>运算符返回的结果一样。这样，您就不会混淆字符串（基本类型）和构造函数<code>String</code>的实例（对象）。</p> 
<h3><a id="_943"></a>基本标签</h3> 
<p>以下是基本的元数据标签：</p> 
<p><code>@fileOverview description</code></p> 
<p>标记描述整个文件的 JSDoc 注释。例如：</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * @fileOverview Various tool functions.
 * @author &lt;a href="mailto:jd@example.com"&gt;John Doe&lt;/a&gt;
 * @version 3.1.2
 */</span>
</code></pre> 
<p><code>@author</code></p> 
<p>指的是谁编写了正在被记录的实体。</p> 
<p><code>@deprecated</code></p> 
<p>指示实体不再受支持。记录应该使用什么是一个很好的做法。</p> 
<p><code>@example</code></p> 
<p>包含一个代码示例，说明给定的实体应该如何使用：</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * @example
 * var str = 'abc';
 * console.log(repeat(str, 3)); // abcabcabc
 */</span>
</code></pre> 
<p>用于链接的基本标签如下：</p> 
<p><code>@see</code></p> 
<p>指向相关资源：</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * @see MyConstructor#myMethod
 * @see The &lt;a href="http://example.com"&gt;Example Project&lt;/a&gt;.
 */</span>
</code></pre> 
<p><code>{@link ...}</code></p> 
<p>像<code>@see</code>一样工作，但可以在其他标签内使用。</p> 
<p><code>@requires resourceDescription</code></p> 
<p>指示文档实体需要的资源。资源描述可以是名称路径或自然语言描述。</p> 
<p>版本标签包括以下内容：</p> 
<p><code>@version versionNumber</code></p> 
<p>指示文档实体的版本。例如：</p> 
<pre><code class="prism language-js">@version <span class="token number">10.3</span><span class="token number">.1</span>
</code></pre> 
<p><code>@since versionNumber</code></p> 
<p>指示文档实体可用的版本。例如：</p> 
<pre><code class="prism language-js">@since <span class="token number">10.2</span><span class="token number">.0</span>
</code></pre> 
<h3><a id="_1018"></a>文档化函数和方法</h3> 
<p>对于函数和方法，您可以记录参数、返回值和可能抛出的异常：</p> 
<p><code>@param {paramType} paramName description</code></p> 
<p>描述了参数的名称为<code>paramName</code>。类型和描述是可选的。以下是一些例子：</p> 
<pre><code class="prism language-js">@param str The string to repeat<span class="token punctuation">.</span>
@param <span class="token punctuation">{<!-- --></span>string<span class="token punctuation">}</span> str
@param <span class="token punctuation">{<!-- --></span>string<span class="token punctuation">}</span> str The string to repeat<span class="token punctuation">.</span>
</code></pre> 
<p>高级特性：</p> 
<ul><li> <p>可选参数：</p> <pre><code class="prism language-js">@param <span class="token punctuation">{<!-- --></span>number<span class="token punctuation">}</span> <span class="token punctuation">[</span>times<span class="token punctuation">]</span> The number <span class="token keyword">of</span> times is optional<span class="token punctuation">.</span>
</code></pre> </li><li> <p>带有默认值的可选参数：</p> <pre><code class="prism language-js">@param <span class="token punctuation">{<!-- --></span>number<span class="token punctuation">}</span> <span class="token punctuation">[</span>times<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">]</span> The number <span class="token keyword">of</span> times is optional<span class="token punctuation">.</span>
</code></pre> </li></ul> 
<p><code>@returns {returnType} description</code></p> 
<p>描述函数或方法的返回值。类型或描述可以省略。</p> 
<p><code>@throws {exceptionType} description</code></p> 
<p>描述在函数或方法执行过程中可能抛出的异常。类型或描述可以省略。</p> 
<h3><a id="_1054"></a>内联类型信息（“内联文档注释”）</h3> 
<p>为参数和返回值提供类型信息有两种方式。首先，您可以在<code>@param</code>和<code>@returns</code>中添加类型注释：</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * @param {String} name
 * @returns {Object}
 */</span>
<span class="token keyword">function</span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其次，您可以内联类型信息：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token comment">/**String*/</span> name<span class="token punctuation">)</span> <span class="token comment">/**Object*/</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_1074"></a>记录变量、参数和实例属性</h3> 
<p>以下标签用于记录变量、参数和实例属性：</p> 
<p><code>@type {typeName}</code></p> 
<p>所记录的变量的类型是什么？例如：</p> 
<pre><code class="prism language-js"><span class="token comment">/** @type {number} */</span>
<span class="token keyword">var</span> carCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre> 
<p>此标签也可用于记录函数的返回类型，但在这种情况下，<code>@returns</code>更可取。</p> 
<p><code>@constant</code></p> 
<p>指示所记录的变量具有常量值的标志。</p> 
<pre><code class="prism language-js"><span class="token comment">/** @constant */</span>
<span class="token keyword">var</span> <span class="token constant">FORD</span> <span class="token operator">=</span> <span class="token string">'Ford'</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>@property {propType} propKey description</code></p> 
<p>在构造函数注释中记录实例属性。例如：</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * @constructor
 * @property {string} name The name of the person.
 */</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>另外，实例属性可以如下记录：</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * @class
 */</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/**
 * The name of the person.
 * @type {string}
 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用哪种风格取决于个人偏好。</p> 
<p><code>@default defaultValue</code></p> 
<p>参数或实例属性的默认值是什么？例如：</p> 
<pre><code class="prism language-js"><span class="token comment">/** @constructor */</span>
<span class="token keyword">function</span> <span class="token function">Page</span><span class="token punctuation">(</span><span class="token parameter">title</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/**
 * @default 'Untitled'
 */</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title <span class="token operator">||</span> <span class="token string">'Untitled'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_1143"></a>记录类</h3> 
<p>JSDoc 区分类和构造函数。前者更像是一种类型，而构造函数是实现类的一种方式。JavaScript 内置的定义类的方法有限，这就是为什么有许多 API 来帮助完成这个任务。这些 API 有所不同，通常差异很大，因此您必须帮助 JSDoc 弄清楚发生了什么。以下标签让您可以做到这一点：</p> 
<p><code>@constructor</code></p> 
<p>将函数标记为构造函数。</p> 
<p><code>@class</code></p> 
<p>将变量或函数标记为类。在后一种情况下，<code>@class</code>是<code>@constructor</code>的同义词。</p> 
<p><code>@constructs</code></p> 
<p>记录方法设置实例数据。如果存在这样的方法，则在该类中记录。</p> 
<p><code>@lends namePath</code></p> 
<p>指定以下对象文字贡献给哪个类。有两种贡献的方式。</p> 
<ul><li> <p><code>@lends Person#</code>：对象文字为<code>Person</code>贡献实例成员。</p> </li><li> <p><code>@lends Person</code>：对象文字为<code>Person</code>贡献静态成员。</p> </li></ul> 
<p><code>@memberof parentNamePath</code></p> 
<p>所记录的实体是指定对象的成员。<code>@lends MyClass#</code>，应用于对象文字，与使用<code>@memberof MyClass#</code>标记该文字的每个属性具有相同的效果。</p> 
<p>定义类最常见的方式是：通过构造函数、通过对象文字以及通过具有<code>@constructs</code>方法的对象文字。</p> 
<h4><a id="_1173"></a>通过构造函数定义类</h4> 
<p>要通过构造函数定义类，必须标记构造函数；否则，它将不会被文档化为类。仅仅大小写不足以标记函数为构造函数：</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * A class for managing persons.
 * @constructor
 */</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_1186"></a>通过对象文字定义类</h4> 
<p>要通过对象文字定义类，需要两个标记。首先，您需要告诉 JSDoc 给定的变量持有一个类。其次，您需要标记一个对象文字为定义类。您可以通过<code>@lends</code>标签来实现后者：</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * A class for managing persons.
 * @class
 */</span>
<span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token function">makeClass</span><span class="token punctuation">(</span>
    <span class="token comment">/** @lends Person# */</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function-variable function">say</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token string">'This person says: '</span> <span class="token operator">+</span> message<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="constructs__1205"></a>通过具有@constructs 方法的对象文字定义类</h4> 
<p>如果对象文字有一个<code>@constructs</code>方法，您需要告诉 JSDoc 关于它，这样它才能找到实例属性的文档。类的文档移到该方法中：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token function">makeClass</span><span class="token punctuation">(</span>
    <span class="token comment">/** @lends Person# */</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/**
 * A class for managing persons.
 * @constructs
 */</span>
        <span class="token function-variable function">initialize</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">say</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' says: '</span> <span class="token operator">+</span> message<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果省略<code>@lends</code>，则必须指定方法属于哪个类：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token function">makeClass</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">/**
 * A class for managing persons.
 * @constructs Person
 */</span>
        <span class="token function-variable function">initialize</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">/** @memberof Person# */</span>
        <span class="token function-variable function">say</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' says: '</span> <span class="token operator">+</span> message<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_1246"></a>子类化</h4> 
<p>JavaScript 没有内置的子类化支持。当您在代码中进行子类化（无论是手动还是通过库），您必须告诉 JSDoc 发生了什么：</p> 
<p><code>@extends namePath</code></p> 
<p>指示所记录的类是另一个类的子类的标志。例如：</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * @constructor
 * @extends Person
 */</span>
<span class="token keyword">function</span> <span class="token function">Programmer</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
<span class="token comment">// Remaining code for subclassing omitted</span>
</code></pre> 
<h3><a id="_1266"></a>其他有用的标签</h3> 
<p>所有这些标签都在<a href="http://usejsdoc.org/" rel="nofollow">JSDoc 网站</a>上有文档：</p> 
<ul><li> <p>模块化：<code>@module</code>，<code>@exports</code>，<code>@namespace</code></p> </li><li> <p>自定义类型（用于虚拟实体，如回调，其签名可以由您记录）：<code>@typedef</code>，<code>@callback</code></p> </li><li> <p>法律事务：<code>@copyright</code>，<code>@license</code></p> </li><li> <p>各种对象：<code>@mixin</code>，<code>@enum</code></p> </li></ul> 
<hr> 
<p>²¹ JSDoc 网站是本章的主要来源；其中一些示例是从该网站借用的。</p> 
<h3><a id="_1283"></a>第三十章：库</h3> 
<blockquote> 
 <p>原文：<a href="https://exploringjs.com/es5/ch30.html" rel="nofollow">30. Libraries</a></p> 
 <p>译者：<a href="https://github.com/wizardforcel">飞龙</a></p> 
 <p>协议：<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow">CC BY-NC-SA 4.0</a></p> 
</blockquote> 
<p>本章介绍了 JavaScript 库。首先解释了 shim 和 polyfill 是什么，这两种特殊的库。然后列出了一些核心库。最后，指向了其他与库相关的资源。</p> 
<h3><a id="Shim__Polyfill__1294"></a>Shim 与 Polyfill 的区别</h3> 
<p>Shim 和 polyfill 是在旧的 JavaScript 引擎上改进新功能的库：</p> 
<ul><li> <p><em>Shim</em>是一个库，它将新的 API 引入到旧的环境中，只使用该环境的手段。</p> </li><li> <p><em>填充物</em>是浏览器 API 的替代品。它通常检查浏览器是否支持 API。如果不支持，填充物会安装自己的实现。这样你就可以在任何情况下使用 API。术语<em>填充物</em>来自于家居改进产品；根据<a href="http://bit.ly/MmZZmZ" rel="nofollow">Remy Sharp</a>的说法：</p> </li></ul> 
<blockquote> 
 <p>Polyfilla 是一种在美国被称为 Spackling Paste 的英国产品。考虑到这一点：把浏览器想象成有裂缝的墙。这些[填充物]有助于填平裂缝，使我们得到一个漂亮平滑的浏览器墙来使用。</p> 
</blockquote> 
<p>示例包括：</p> 
<ul><li> <p><a href="http://bit.ly/1oOGuTE" rel="nofollow">“HTML5 跨浏览器填充物”</a>：由 Paul Irish 编制的列表。</p> </li><li> <p><a href="http://bit.ly/1oOGxi4" rel="nofollow">es5-shim</a>是一个（非填充物）shim，它在 ECMAScript 3 引擎上改进了 ECMAScript 5 的功能。它纯粹与语言相关，无论是在 Node.js 上还是在浏览器上都是有意义的。</p> </li></ul> 
<h3><a id="_1310"></a>四种语言库</h3> 
<p>以下库已经相当成熟并且接近语言。了解它们是有用的：</p> 
<ul><li> <p>ECMAScript 国际化 API 有助于处理与国际化相关的任务：排序和搜索字符串、数字格式化以及日期和时间格式化。下一节将更详细地解释此 API。</p> </li><li> <p><a href="http://underscorejs.org" rel="nofollow">Underscore.js</a>通过数组、对象、函数等工具函数来补充 JavaScript 相对稀疏的标准库。由于 Underscore 早于 ECMAScript 5，因此与标准库存在一些重叠。然而，这是一个特性：在旧版浏览器上，您可以获得通常只有 ECMAScript-5 才有的功能；在 ECMAScript 5 上，相关函数简单地转发到标准库。</p> </li><li> <p><a href="http://lodash.com" rel="nofollow">Lo-Dash</a>是 Underscore.js API 的另一种实现，具有一些额外的功能。访问网站了解它是否比 Underscore.js 更适合您。</p> </li><li> <p><a href="http://xregexp.com" rel="nofollow">XRegExp</a>是一个具有多个高级功能的正则表达式库，例如命名捕获和自由间隔（允许您将正则表达式分布在多行并逐行记录）。在幕后，增强的正则表达式被转换为普通的正则表达式，这意味着您在使用 XRegExp 时不会付出性能代价。</p> </li></ul> 
<h3><a id="ECMAScript__API_1322"></a>ECMAScript 国际化 API</h3> 
<p>ECMAScript 国际化 API 是一个标准的 JavaScript API，用于处理与国际化相关的任务：排序和搜索字符串、数字格式化以及日期和时间格式化。本节简要概述并指向更多阅读材料。</p> 
<h4><a id="ECMAScript__API_1__1326"></a>ECMAScript 国际化 API，第 1 版</h4> 
<p>API 的第一版提供了以下服务：</p> 
<ul><li> <p><em>排序</em>支持两种场景：对一组字符串进行排序和在一组字符串中进行搜索。排序是由区域设置参数化的，并且了解 Unicode。</p> </li><li> <p><em>数字格式化</em>。参数包括：</p> </li><li> <p>格式化样式：十进制、货币（由其他参数确定的货币种类和如何引用）</p> </li><li> <p>区域设置（直接指定或最佳匹配，通过匹配器对象搜索）</p> </li><li> <p>编号系统（西方数字、阿拉伯数字、泰国数字等）</p> </li><li> <p>精度：整数位数、小数位数、有效数字位数</p> </li><li> <p>分组分隔符打开或关闭</p> </li><li> <p><em>日期和时间格式</em>。参数包括：</p> </li><li> <p>要格式化的信息以及使用哪种样式（短、长、数字等）</p> </li><li> <p>一个区域设置</p> </li><li> <p>一个时区</p> </li></ul> 
<p>大部分功能通过全局变量<code>Intl</code>中的对象访问，但 API 还增强了以下方法：</p> 
<ul><li> <p><code>String.prototype.localeCompare</code></p> </li><li> <p><code>Number.prototype.toLocaleString</code></p> </li><li> <p><code>Date.prototype.toLocaleString</code></p> </li><li> <p><code>Date.prototype.toLocaleDateString</code></p> </li><li> <p><code>Date.prototype.toLocaleTimeString</code></p> </li></ul> 
<h4><a id="_1364"></a>它是什么样的标准？</h4> 
<p>标准“ECMAScript 国际化 API”（EIA）的编号是 ECMA-402。它由 Ecma International 托管，该协会还托管 ECMA-262，即 ECMAScript 语言规范。这两个标准都由 TC39 维护。因此，EIA 是最接近语言的标准，而不是 ECMA-262 的一部分。该 API 已经设计用于与 ECMAScript 5 和 ECMAScript 6 一起使用。一套一致性测试补充了标准，并确保 API 的各种实现是兼容的（ECMA-262 有类似的测试套件）。</p> 
<h4><a id="_1368"></a>我什么时候可以使用它？</h4> 
<p>大多数现代浏览器已经支持它，或者正在支持它的过程中。David Storey 创建了一个详细的<a href="http://bit.ly/1oOGIdo" rel="nofollow">兼容性表</a>（指示哪些浏览器支持哪些区域设置等）。</p> 
<h4><a id="_1372"></a>进一步阅读</h4> 
<p>ECMAScript 国际化 API 的<a href="http://bit.ly/1oOGQth" rel="nofollow">规范</a>由 Norbert Lindenberg 编辑。它以 PDF、HTML 和 EPUB 格式提供。此外，还有几篇全面的介绍性文章：</p> 
<ul><li> <p><a href="http://bit.ly/1oOGT8C" rel="nofollow">“ECMAScript 国际化 API”</a> by Norbert Lindenberg</p> </li><li> <p><a href="http://bit.ly/1oOGYcc" rel="nofollow">“ECMAScript 国际化 API”</a> by David Storey</p> </li><li> <p><a href="http://bit.ly/1oOH2sz" rel="nofollow">“使用 JavaScript 国际化 API”</a> by Marcos Caceres</p> </li></ul> 
<h3><a id="JavaScript__1382"></a>JavaScript 资源目录</h3> 
<p>本节描述了收集 JavaScript 资源信息的网站。有几种这样的目录。</p> 
<p>以下是 JavaScript 的一般目录列表：</p> 
<ul><li> <p><a href="http://www.javascriptoo.com/" rel="nofollow">“JavaScriptOO：您应该关注的每个 JavaScript 项目”</a></p> </li><li> <p><a href="http://www.jsdb.io/" rel="nofollow">JSDB</a>：最好的 JavaScript 库集合</p> </li><li> <p><a href="http://jster.net/" rel="nofollow">JSter</a>：JavaScript 库和开发工具目录</p> </li><li> <p><a href="http://bit.ly/1oOH7MW" rel="nofollow">“HTML5、JavaScript 和 CSS 资源的主列表”</a></p> </li></ul> 
<p>专门的目录包括：</p> 
<ul><li> <p><a href="http://microjs.com/" rel="nofollow">“Microjs：出色的微框架和微库，用于娱乐和利润”</a></p> </li><li> <p><a href="http://www.unheap.com/" rel="nofollow">“Unheap：整洁的 jQuery 插件存储库”</a></p> </li></ul> 
<p>显然，您可以直接浏览包管理器的注册表：</p> 
<ul><li> <p><a href="https://npmjs.org/" rel="nofollow">npm</a>（Node Packaged Modules）</p> </li><li> <p><a href="http://bower.io/" rel="nofollow">Bower</a></p> </li></ul> 
<p>CDN（内容交付网络）和 CDN 内容的目录包括：</p> 
<ul><li> <p><a href="http://www.jsdelivr.com/" rel="nofollow">jsDelivr</a>：JavaScript 库、jQuery 插件、CSS 框架、字体等的免费 CDN</p> </li><li> <p><a href="http://cdnjs.com/" rel="nofollow">“cdnjs：JavaScript 和 CSS 的缺失 CDN”</a>（托管不太流行的库）</p> </li></ul> 
<h4><a id="_1414"></a>致谢</h4> 
<p>以下人员为本节做出了贡献：Kyle Simpson（@getify），Gildas Lormeau（@check_ca），Fredrik Sogaard（@fredrik_sogaard），Gene Loparco（@gloparco），Manuel Strehl（@m_strehl）和 Elijah Manor（@elijahmanor）。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91e97c2215f940ceea5daa936490adcc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大话 JavaScript（Speaking JavaScript）：第十一章到第十五章</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25774fd683c704954309634bd5b78d1c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Syslog发送日志&#43;Logstash处理日志</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>