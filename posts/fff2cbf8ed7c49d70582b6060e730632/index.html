<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue3.0实现前进刷新后退不刷新 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue3.0实现前进刷新后退不刷新" />
<meta property="og:description" content="前言 vue2.0实现前进刷新，后退缓存的例子有很多，但是vue3.0版本的没有找到，刚好有一个同学咨询这个问题，所以现在有空了写一篇文章来谈谈，怎么用vue3.0的轮子去实现前进刷新后退缓存。
场景 项目里有三个页面，分别为一级首页、二级列表页和三级详情页，从首页进入列表页刷新，从列表页进入详情页刷新，但是从详情页返回列表页不刷新，所以需要缓存的是二级列表页。
理论 通过keep-alive缓存组件；组件路由里定义一个变量isKeepAlive来控制组件的缓存；通过路由独享守卫根据条件修改缓存变量，选择性缓存组件。 实现 比方说三级页面分别为A、B和C，我们需要对B页面根据路由信息进行条件缓存
1、路由的配置 B组件的路由里定义一个变量isKeepAlive，同时还有一个路由独享守卫方法beforeEnter，当进入B页面时触发beforeEnter，我们判断如果是从C页面进入B页面，修改isKeepAlive为True使B页面缓存起来。
{ path: &#39;/a&#39;, name: &#39;A&#39;, component: ()=&gt; import(&#39;../views/A.vue&#39;), meta: { title: &#39;A Page&#39; } }, { path: &#39;/b&#39;, name: &#39;B&#39;, component: ()=&gt; import(&#39;../views/B.vue&#39;), meta: { title: &#39;B Page&#39;, isKeepAlive: false, }, // 路由独享守卫 beforeEnter: (to, from) =&gt; { to.meta.isKeepAlive = to.name===&#39;B&#39; &amp;&amp; from.name==&#39;C&#39; ? true : false return true }, }, { path: &#39;/c&#39;, name: &#39;C&#39;, component: ()=&gt; import(&#39;../views/C.vue&#39;), meta: { title: &#39;C Page&#39; } } （注：路由的初始化略）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fff2cbf8ed7c49d70582b6060e730632/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-31T09:57:25+08:00" />
<meta property="article:modified_time" content="2022-07-31T09:57:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue3.0实现前进刷新后退不刷新</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言 </h2> 
<p>vue2.0实现前进刷新，后退缓存的例子有很多，但是vue3.0版本的没有找到，刚好有一个同学咨询这个问题，所以现在有空了写一篇文章来谈谈，怎么用vue3.0的轮子去实现前进刷新后退缓存。</p> 
<h2>场景</h2> 
<p>项目里有三个页面，分别为一级首页、二级列表页和三级详情页，从首页进入列表页刷新，从列表页进入详情页刷新，但是从详情页返回列表页不刷新，所以需要缓存的是二级列表页。</p> 
<h2>理论</h2> 
<ol><li>通过keep-alive缓存组件；</li><li>组件路由里定义一个变量isKeepAlive来控制组件的缓存；</li><li>通过路由独享守卫根据条件修改缓存变量，选择性缓存组件。</li></ol> 
<h2>实现 </h2> 
<p>比方说三级页面分别为A、B和C，我们需要对B页面根据路由信息进行条件缓存</p> 
<h3> 1、路由的配置</h3> 
<p>B组件的路由里<span style="color:#fe2c24;">定义一个变量isKeepAlive</span>，同时还有一个路由独享守卫方法beforeEnter，当进入B页面时触发beforeEnter，我们判断如果是<span style="color:#fe2c24;">从C页面进入B页面，修改isKeepAlive为True使B页面缓存</span>起来。</p> 
<pre><code>{
  path: '/a',
  name: 'A',
  component: ()=&gt; import('../views/A.vue'),
  meta: {
    title: 'A Page'
  }
},
{
  path: '/b',
  name: 'B',
  component: ()=&gt; import('../views/B.vue'),
  meta: {
    title: 'B Page',
    isKeepAlive: false,
  },
  // 路由独享守卫
  beforeEnter: (to, from) =&gt; {
    to.meta.isKeepAlive =  to.name==='B' &amp;&amp; from.name=='C' ? true : false
    return true
  },
},
{
  path: '/c',
  name: 'C',
  component: ()=&gt; import('../views/C.vue'),
  meta: {
    title: 'C Page'
  }
}</code></pre> 
<p>（注：路由的初始化略）</p> 
<h3>2、配置keep-alive</h3> 
<pre><code>// App.vue
&lt;router-view v-slot="{Component, route}"&gt;
  &lt;keep-alive&gt;
    &lt;component :is="Component" v-if="route.meta.isKeepAlive"/&gt;
  &lt;/keep-alive&gt;
  &lt;component :is="Component" v-if="!route.meta.isKeepAlive" /&gt;
&lt;/router-view&gt;</code></pre> 
<h3> 3、B页面根据isKeepAlive来请求数据</h3> 
<pre><code>import { onMounted } from 'vue';
import { useRoute } from 'vue-router'

const route = useRoute()

onMounted(()=&gt; {
    if(route.meta.isKeepAlive) return
    console.log('init data')    // 获取列表数据
})</code></pre> 
<p>（完）</p> 
<p>参考文献：</p> 
<p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB" rel="nofollow" title="导航守卫 | Vue Router">导航守卫 | Vue Router</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/98ff99b227d80af584f7d7c5ba94f456/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">1. Python 的 print( )输出函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1fc0416112672099231424f0e180bc6e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL4</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>