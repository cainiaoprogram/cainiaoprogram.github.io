<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Comparison method violates its general contract! - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Comparison method violates its general contract!" />
<meta property="og:description" content="最近项目中有许多地方用到了集合排序，不是自然排序，必须的自己实现排序逻辑了。
java提供实现排序接口有两个Comparable与Comparator。
我简单理解：
1.Comparable接口是实现在需要排序的单个对象上的，例如：Student学生类，根据学号或其他属性排序，Student类就要implements实现Comparable接口，并重写int compareTo(T o) 方法。你排序所依赖的所有元素都需要包含在Student类里，换言之就是依赖在Student类里能获取到的资源。然后直接调用Collections.sort(List&lt;T&gt; list) 方法就行了，比较方便。
但是，有一点需要注意，Comparable接口比较局限，就是继承Comparable接口类只能实现Student的一种排序，换一种排序，你就需要重新编写Student基础类了。
2.Comparator接口是可以单独拿来实现的，每个实现Comparator接口都可以有一种排序的逻辑。继承Comparator接口需要实现 int compare(String o1, String o2)方法。然后直接调用Collections.sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)方法。
Comparator接口就比较自由了，每个实现Comparator接口都可以有自己实现逻辑，无需修改需要排序的对象，比较灵活。并且所依赖的元素不局限于需要排序对象本身的属性，可以把需要的资源任意添加实现Comparator接口的类中。
例如：
class SchoolRoomComparator implements Comparator&lt;String&gt;{ Map&lt;String,SchoolRoom&gt; schoolRoomMap; public SchoolRoomComparator(){ this.schoolRoomMap = schoolRoomMap； } @Override public int compare(String o1, String o2) { return schoolRoomMap.get(o1).getXuhao() - schoolRoomMap.get(o2).getXuhao(); } } 用到了出了需要排序的String对象外，还依赖schoolRoomMap属性。
下面我说说我程序报的异常吧。
异常：Comparison method violates its general contract!
我这里就简单阐述一下，我用的是Comparator接口实现的排序。由于业务需要，在比较Double对象大小时，我用了Math.ceil(double a) 方法，错误的把需要比较的Double对象转化成了整数，忽略了小数部分。违反了Comparator 要满足自反性，传递性，对称性。
参考博客：https://blog.csdn.net/wangxueming/article/details/80967341" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a8a3d62a9372edd1b301d03692c4af01/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-23T16:19:29+08:00" />
<meta property="article:modified_time" content="2019-05-23T16:19:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Comparison method violates its general contract!</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>    最近项目中有许多地方用到了集合排序，不是自然排序，必须的自己实现排序逻辑了。</p> 
<p>    java提供实现排序接口有两个Comparable与Comparator。</p> 
<p>    我简单理解：</p> 
<p>    1.Comparable接口是实现在需要排序的单个对象上的，例如：Student学生类，根据学号或其他属性排序，Student类就要implements实现Comparable接口，并重写int compareTo(T o) 方法。你排序所依赖的所有元素都需要包含在Student类里，换言之就是依赖在Student类里能获取到的资源。然后直接调用Collections.sort(List&lt;T&gt; list) 方法就行了，比较方便。<br>     但是，有一点需要注意，Comparable接口比较局限，就是继承Comparable接口类只能实现Student的一种排序，换一种排序，你就需要重新编写Student基础类了。<br>     2.Comparator接口是可以单独拿来实现的，每个实现Comparator接口都可以有一种排序的逻辑。继承Comparator接口需要实现 int compare(String o1, String o2)方法。然后直接调用Collections.sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)方法。<br>     Comparator接口就比较自由了，每个实现Comparator接口都可以有自己实现逻辑，无需修改需要排序的对象，比较灵活。并且所依赖的元素不局限于需要排序对象本身的属性，可以把需要的资源任意添加实现Comparator接口的类中。</p> 
<p>例如：</p> 
<pre>class SchoolRoomComparator implements Comparator&lt;String&gt;{

    Map&lt;String,SchoolRoom&gt; schoolRoomMap;

    public SchoolRoomComparator(){
        this.schoolRoomMap = schoolRoomMap；
    }

    @Override
    public int compare(String o1, String o2) {
        return schoolRoomMap.get(o1).getXuhao() - schoolRoomMap.get(o2).getXuhao();
    }
}</pre> 
<p>用到了出了需要排序的String对象外，还依赖schoolRoomMap属性。</p> 
<p> </p> 
<p>下面我说说我程序报的异常吧。</p> 
<p>异常：Comparison method violates its general contract!</p> 
<p>我这里就简单阐述一下，我用的是Comparator接口实现的排序。由于业务需要，在比较Double对象大小时，我用了Math.<code><strong>ceil</strong>(double a)</code> 方法，错误的把需要比较的Double对象转化成了整数，忽略了小数部分。违反了Comparator 要满足自反性，传递性，对称性。</p> 
<p>参考博客：<a href="https://blog.csdn.net/wangxueming/article/details/80967341">https://blog.csdn.net/wangxueming/article/details/80967341</a></p> 
<pre> </pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8fa83e0cbe6e27354b0d65325301c2b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win7系统，ENVI5.2安装中出现the installation of msvc_2005_sp1_x86 has failed 解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6626e0266f4290d791bd40db075e3023/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HDU 4745 Two Rabbits</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>