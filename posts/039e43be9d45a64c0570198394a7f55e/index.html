<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iframe跨域没有权限_浏览器同源策略及跨域（一） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="iframe跨域没有权限_浏览器同源策略及跨域（一）" />
<meta property="og:description" content="什么是同源策略 同源策略最早是由Netscape提出的一种安全策略，目前所有支持JavaScript的浏览器都使用这个策略。
同源策略要求：客户端脚本在没有明确授权的情况下，不能读写不同源网址的数据和资源（如HTTP头、Cookie、DOM、localStorage等）。
同源策略只是一个规范，并不是强制要求，各大厂商的浏览器只是针对同源策略的一种实现。它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。 同源是指：
域名相同协议相同端口相同 例：ziv.com
协议是 http://
域名是 ziv.com
端口是 80 （默认端口）
以下网址与 ziv.com的同源情况如：
http://www.ziv.com/pc/demo.html 同源 http://ziv.com/h5/demo.html 不同源 域名不同 http://www.ziv.com:81/h5/demo.html 不同源 端口不同 https://www.ziv.com/h5/demo.html 不同源 协议不同 同源策略的意义
当两个网址是非同源时，它们之间的交互会有以下限制：
Cookie、LocalStorage和IndexDB无法相互读取DOM无法相互获取AJAX请求不能发送 这些限制都是出于对安全的考虑，都是有必要的。比如，你登录了知乎账号，然后打开了另一个网站，这个网站上的JavaScript可以跨域读取你的知乎账号数据，那这样就毫无隐私可言。又比如，一个恶意网站嵌入了银行账号登录页面，如果没有同源限制，恶意网页的JavaScript就可以获取用户登录的用户信息，想象一下如果是这样后果是不是很严重。
当然，同源策略也会带来一些弊端，导致我们合理的用途也会受到影响。因此，在开发过程中，我们常常需要通过跨域来规避限制。
几种跨域的方法： document.domain
document.domain 可以用来得到当前网页的域名，同时市场上主流浏览器都支持domain可写，但是只能赋值为当前域名或者基础域名，如果赋值成当前域名的子域名就会报错。
如果两个网页一级域名相同，二级域名不同，则可以通过设置相同的document.domain实现cookie共享和iframe窗口（或window.open打开的窗口）与父窗口之间的通信。
比如，a网页是 http://a.ziv.com/a.html，b网页是http://b.ziv.com/b.html，然后设置它们的document.domain为：
document 那么，a网页设置的cookie，在b网页可以通过js拿到，同样b网页设置的cookie，在a网页也可以通过js拿到。它们的cookie是相互共享的。
如果在a网页通过iframe将b网页设置为a的子窗口：
&lt;iframe id=&#34;iframe&#34; src=&#34;http://b.ziv.com/b.html&#34;&gt;&lt;/iframe&gt; 那么，a、b窗口可以相互获得彼此的DOM。
在a网页中
document.getElementById(&#34;iframe&#34;).contentWindow.document 通过上面的代码可以获取b窗口的DOM。
在b窗口中
window 通过上面的代码可以获取a窗口的DOM。
注意：domain的使用必须在一级域名相同时，才能规避同源限制 window.name
window.name是浏览器窗口的一个属性，在一个窗口的生命周期里，不论是否同源，窗口里载入的所有页面都有权限对window.name进行读写。利用这一特性，我们可以实现在同一个窗口里，载入的不同网页之间的通信。
下面举个实例说明下如何使用window.name进行跨域：
原理：这里用到两个特性，
在一个窗口下，先后载入的页面都可以对window.name进行读写同源或者一级域名相同并且domain相同的父子窗口可以相互获得DOM 首先，需要三个页面
http://a.ziv.com/a.html 获得数据、处理数据的页面http://a.ziv.com/proxy.html 中间（代理）页面，一般是没有内容的html文件，必须与a页面一级域名相同，为了使a页面能够获得window.name这个属性http://b.viz.com/data.html 拥有数据的页面 具体步骤如下：
在数据页面data.html中通过window.name，设置需要的数据。
&lt;script type=&#34;text/javascript&#34;&gt;
window.name = &#39;data!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/039e43be9d45a64c0570198394a7f55e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-01T17:09:54+08:00" />
<meta property="article:modified_time" content="2020-12-01T17:09:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iframe跨域没有权限_浏览器同源策略及跨域（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <h3>什么是同源策略</h3> 
 <p>同源策略最早是由Netscape提出的一种安全策略，目前所有支持JavaScript的浏览器都使用这个策略。</p> 
 <p>同源策略要求：客户端脚本在没有明确授权的情况下，不能读写不同源网址的数据和资源（如HTTP头、Cookie、DOM、localStorage等）。</p> 
 <div class="has"> 
  <pre><code>同源策略只是一个规范，并不是强制要求，各大厂商的浏览器只是针对同源策略的一种实现。它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。
</code></pre> 
 </div> 
 <p>同源是指：</p> 
 <ul><li>域名相同</li><li>协议相同</li><li>端口相同</li></ul> 
 <p>例：ziv.com</p> 
 <p>协议是 http://</p> 
 <p>域名是 ziv.com</p> 
 <p>端口是 80 （默认端口）</p> 
 <p>以下网址与 ziv.com的同源情况如：</p> 
 <div class="has"> 
  <pre><code>http://www.ziv.com/pc/demo.html       同源

http://ziv.com/h5/demo.html           不同源 域名不同

http://www.ziv.com:81/h5/demo.html    不同源 端口不同

https://www.ziv.com/h5/demo.html      不同源 协议不同
</code></pre> 
 </div> 
 <p>同源策略的意义</p> 
 <p>当两个网址是非同源时，它们之间的交互会有以下限制：</p> 
 <ul><li>Cookie、LocalStorage和IndexDB无法相互读取</li><li>DOM无法相互获取</li><li>AJAX请求不能发送</li></ul> 
 <p>这些限制都是出于对安全的考虑，都是有必要的。比如，你登录了知乎账号，然后打开了另一个网站，这个网站上的JavaScript可以跨域读取你的知乎账号数据，那这样就毫无隐私可言。又比如，一个恶意网站嵌入了银行账号登录页面，如果没有同源限制，恶意网页的JavaScript就可以获取用户登录的用户信息，想象一下如果是这样后果是不是很严重。</p> 
 <p>当然，同源策略也会带来一些弊端，导致我们合理的用途也会受到影响。因此，在开发过程中，我们常常需要通过跨域来规避限制。</p> 
 <h3>几种跨域的方法：</h3> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/a3/54/pMuPHs0h_o.png" alt="230ee85677a961b55ea1d79d0dbec134.png"> 
 </div> 
 <p><b>document.domain</b></p> 
 <p>document.domain 可以用来得到当前网页的域名，同时市场上主流浏览器都支持domain可写，但是只能赋值为当前域名或者基础域名，如果赋值成当前域名的子域名就会报错。</p> 
 <p>如果两个网页一级域名相同，二级域名不同，则可以通过设置相同的document.domain实现cookie共享和iframe窗口（或window.open打开的窗口）与父窗口之间的通信。</p> 
 <p>比如，a网页是 http://a.ziv.com/a.html，b网页是http://b.ziv.com/b.html，然后设置它们的document.domain为：</p> 
 <div class="has"> 
  <pre class="has"><code>document</code></pre> 
 </div> 
 <p>那么，a网页设置的cookie，在b网页可以通过js拿到，同样b网页设置的cookie，在a网页也可以通过js拿到。它们的cookie是相互共享的。</p> 
 <p>如果在a网页通过iframe将b网页设置为a的子窗口：</p> 
 <div class="has"> 
  <pre><code>&lt;iframe id="iframe" src="http://b.ziv.com/b.html"&gt;&lt;/iframe&gt;
</code></pre> 
 </div> 
 <p>那么，a、b窗口可以相互获得彼此的DOM。</p> 
 <p>在a网页中</p> 
 <div class="has"> 
  <pre><code>document.getElementById("iframe").contentWindow.document
</code></pre> 
 </div> 
 <p>通过上面的代码可以获取b窗口的DOM。</p> 
 <p>在b窗口中</p> 
 <div class="has"> 
  <pre class="has"><code>window</code></pre> 
 </div> 
 <p>通过上面的代码可以获取a窗口的DOM。</p> 
 <div class="has"> 
  <pre><code>注意：domain的使用必须在一级域名相同时，才能规避同源限制
</code></pre> 
 </div> 
 <p><b>window.name</b></p> 
 <p>window.name是浏览器窗口的一个属性，在一个窗口的生命周期里，不论是否同源，窗口里载入的所有页面都有权限对window.name进行读写。利用这一特性，我们可以实现在同一个窗口里，载入的不同网页之间的通信。</p> 
 <p>下面举个实例说明下如何使用window.name进行跨域：</p> 
 <p>原理：这里用到两个特性，</p> 
 <ul><li>在一个窗口下，先后载入的页面都可以对window.name进行读写</li><li>同源或者一级域名相同并且domain相同的父子窗口可以相互获得DOM</li></ul> 
 <p>首先，需要三个页面</p> 
 <ul><li>http://a.ziv.com/a.html 获得数据、处理数据的页面</li><li>http://a.ziv.com/proxy.html 中间（代理）页面，一般是没有内容的html文件，必须与a页面一级域名相同，为了使a页面能够获得window.name这个属性</li><li>http://b.viz.com/data.html 拥有数据的页面</li></ul> 
 <p>具体步骤如下：</p> 
 <ol><li>在数据页面data.html中通过window.name，设置需要的数据。<br>&lt;script type="text/javascript"&gt;<br>window.name = 'data!'; //需要传输的数据，浏览器一般支持2m的大小，这里数据<br> //格式可以是json、xml、字符串等类型数据。<br>&lt;/script&gt;</li><li>在处理数据的页面a.html中创建一个iframe，设置其src为数据页面http://b.viz.com/data.html；然后在a.html中监听iframe的onload事件，在事件触发时将iframe的src指向代理页面http://a.ziv.com/proxy.html；这个时候就可以通过iframe的window.name获得数据了。</li><li>获得数据后要销毁iframe，即释放内存，也保证安全，免得被后续的页面拿到window.name信息。<br>&lt;script type="text/javascript"&gt;<br> var state = 0, <br> iframe = document.createElement('iframe'),<br> loadfn = function() {<!-- --><br> if (state === 1) {<!-- --><br> var data = iframe.contentWindow.name; // 读取数据<br> console.log(data); //'data!'<br> //第三步的代码，销毁iframe，保证安全<br> iframe.contentWindow.document.write('');<br> iframe.contentWindow.close();<br> document.body.removeChild(iframe);<br> } else if (state === 0) {<!-- --><br> state = 1;<br> // 设置iframe src为中间页面<br> iframe.contentWindow.location = "http://a.ziv.com/proxy.html";<br> } <br> };<br> iframe.src = 'http://b.viz.com/data.html';<br> if (iframe.attachEvent) {<!-- --><br> iframe.attachEvent('onload', loadfn); //兼容ie7、ie8<br> } else {<!-- --><br> iframe.onload = loadfn;<br> }<br> document.body.appendChild(iframe);<br>&lt;/script&gt;</li></ol> 
 <p>关于window.name数据格式：</p> 
 <p>json格式</p> 
 <div class="has"> 
  <pre><code>&lt;script type="text/javascript"&gt;
        window.name='{"name":"ziv"}'; 
&lt;/script&gt;
</code></pre> 
 </div> 
 <p>json格式应该是程序猿的写法</p> 
 <div class="has"> 
  <pre><code>&lt;html&gt;
    &lt;script type="text/javascript"&gt;
        window.name = document.getElementsByTagName("script")      [0].innerHTML.match(/temps*=([wW]*)/)[1];
        temp= {
            name:"ziv", 
            age:"24"
        }  
    &lt;/script&gt; 
&lt;/html&gt;
</code></pre> 
 </div> 
 <p>HTML/XML数据格式</p> 
 <div class="has"> 
  <pre><code>&lt;html&gt;
    &lt;body&gt;
        &lt;p id="data"&gt;  
            this is &lt;strong&gt;html/xml-style&lt;/strong&gt; data  
        &lt;/p&gt;  
    &lt;/body&gt;  
    &lt;script type="text/javascript"&gt; 
        window.name = document.getElementById("data").innerHTML;  
    &lt;/script&gt;
&lt;/html&gt;
</code></pre> 
 </div> 
 <p>使用window.name的优缺点</p> 
 <p>优点</p> 
 <ul><li>安全</li><li>比使用片段识别符快</li><li>容量大，可以支持2M左右的数据量</li></ul> 
 <p>缺点</p> 
 <ul><li>需要监听子窗口window.name属性变化，影响网页性能</li></ul> 
 <p><b>window.postMessage</b></p> 
 <p>window.postMessage是HTML5的新特性。HTML5支持的跨文档通信API为window对象新增了一个postMessage方法，该方法支持跨窗口通信，不论是否同源。</p> 
 <p>postMessage使用语法</p> 
 <div class="has"> 
  <pre class="has"><code>otherWindow</code></pre> 
 </div> 
 <p><i><u>otherWindow</u></i>：目标窗口的一个引用（指的是给哪个窗口发消息），比如比如iframe的contentWindow属性，window.open返回的窗口对象。</p> 
 <p><i><u>message</u></i>：需要发送的数据，通过结构化克隆算法序列化。</p> 
 <p><i><u>targetOrigin</u></i>：用来指定接收消息的窗口，值可以是字符串“*”或者一个url，“*”表示无限制，url表示接收消息的窗口必须与这个url同源。一般情况下，能确定targetOrigin就不要设置为“*”，免得导致数据泄露。</p> 
 <p><i><u>transfer</u></i>（可选）：一串和message同时传递的transferable对象。传递后，对象的所有权就转移给了消息接收方，发送方不在保留。</p> 
 <p>接下来我们举个例子具体说明一下，</p> 
 <p>a网页是 http://aaa.com，b网页是http://bbb.com，在a网页中通过iframe设置b网页为子窗口</p> 
 <div class="has"> 
  <pre class="has"><code>&lt;</code></pre> 
 </div> 
 <p>那么，a、b窗口可以相互获得彼此的DOM。</p> 
 <p>在a网页中</p> 
 <div class="has"> 
  <pre class="has"><code>bWindow </code></pre> 
 </div> 
 <p>通过上面的代码，a网页可以往b网页发送消息。</p> 
 <p>b网页往a网页发送消息如下：</p> 
 <div class="has"> 
  <pre><code>window.parent.postMessage('hi~', 'http://aaa.com');
</code></pre> 
 </div> 
 <p>a、b窗口需要通过监听message事件得到彼此发送的消息。</p> 
 <div class="has"> 
  <pre class="has"><code>window</code></pre> 
 </div> 
 <p>message的事件对象有三个属性：</p> 
 <div class="has"> 
  <pre class="has"><code>event</code></pre> 
 </div> 
 <p>b窗口可以通过message事件对象的属性source来指定回复消息的url，a、b可以通过origin属性过滤不是给自己发送的消息。</p> 
 <div class="has"> 
  <pre class="has"><code>window</code></pre> 
 </div> 
 <p><b>片段识别符</b></p> 
 <p>片段识别符是url #号后面的部分，比如：</p> 
 <div class="has"> 
  <pre><code>http://www.ziv.com/a.html#hello</code></pre> 
 </div> 
 <p>#后面的hello就是片段识别符，也称为hash</p> 
 <p>片段识别符有几个特点：</p> 
 <ul><li>修改片段识别符，页面不会重新刷新</li><li>父窗口可以改变子窗口的片段识别符</li><li>子窗口可以改变父窗口的片段识别符</li><li>通过hashchange事件可以监听片段识别符的变化 </li></ul> 
 <p>根据片段识别符的特点，我们可以完成父子窗口通信</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fd0e75f7a7aa8c06afc43e5280bfbf55/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python中strip()函数和split()函数用法：</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6aa283de6b1ed2d2aa4ad9bc84393d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">和菜鸟一起学linux总线驱动之初识USB鼠标抓包数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>