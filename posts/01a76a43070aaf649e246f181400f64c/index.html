<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;位运算符 | &amp;  ^  ~ &amp;&amp; ||,补码，反码 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;位运算符 | &amp;  ^  ~ &amp;&amp; ||,补码，反码" />
<meta property="og:description" content="一：简介 1 位逻辑运算符：
&amp; （位 “与”） and ^ （位 “异或”） | （位 “或”） or ~ （位 “取反”） 2 移位运算符： &lt;&lt;（左移） &gt;&gt;（右移）
优先级
位“与”、位“或”和位“异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、| 二：位逻辑运算 &amp; 运算 ----------------------- -2个都为1-》1 0&amp;1 =0; 0&amp;0 =0; 1&amp;0 =0; 1&amp;1 =1;
00111
&amp; =00100
11100
&amp;运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。
这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数
----------------------------------------------------------------- | 运算---------------------------1个为1--》1
0|0=0; 0|1=1; 1|0=1; 1|1=1;
00111
| =11111
11100
| 运算通常用于二进制特定位上的无条件赋值，例如一个数|1的结果就是把二进制最末位强行变为1
如果需要把二进制最末位变成0，对这个数 |1之后再减一就可以了，其实际意义就是把这个数强行变成最近接的偶数
--------------------------------------------------------------------
^ 运算---------------------------不同则为1，相同则为0 // 当且仅当两个运算值中有一个为1但不同时为1时，返回值为1
0^1=1；
1^0=1；
1^1=0；
0^0=0；
00111
^ =11011" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/01a76a43070aaf649e246f181400f64c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-03-02T14:49:49+08:00" />
<meta property="article:modified_time" content="2012-03-02T14:49:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;位运算符 | &amp;  ^  ~ &amp;&amp; ||,补码，反码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一：简介</h3> 
<p>1 位逻辑运算符：</p>       
<strong>&amp;</strong> （位   “与”）  and 
<br>       
<strong> ^</strong>  （位   “异或”） 
<br>     
<strong>  | </strong>  （位    “或”）   or 
<br>     
<strong>  ~ </strong> （位   “取反”） 
<br> 2 移位运算符： 
<br>       
<strong>&lt;&lt;</strong>（左移） 
<br> 
<p>     <strong> &gt;&gt;</strong>（右移）</p> 
<p><strong>优先级</strong><br> </p> 位“与”、位“或”和位“异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、|  
<br> 
<br> 
<h3>二：位逻辑运算</h3> 
<div> 
 <strong>&amp; 运算   </strong>----------------------- 
 <strong>-2个都为1-》1</strong> 
</div> 
<div> 
 <strong><br> </strong> 
</div> 0&amp;1 =0;    
<br> 0&amp;0 =0; 
<br> 1&amp;0 =0; 
<br> 
<p>1&amp;1 =1;</p> 
<p><br> </p> 
<p>00111</p> 
<p>&amp;            =00100</p> 
<p>11100</p> 
<p></p> 
<p>&amp;运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。</p> 
<p>这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数</p> 
<br> ----------------------------------------------------------------- 
<br> 
<p><strong>| 运算</strong>---------------------------<strong>1个为1--》1</strong></p> 
<p><strong><br> </strong></p> 0|0=0;    
<br> 0|1=1; 
<br> 1|0=1; 
<br> 
<p>1|1=1;</p> 
<p>00111</p> 
<p>|           =11111</p> 
<p>11100</p> 
<p>| 运算通常用于二进制特定位上的无条件赋值，例如一个数|1的结果就是把二进制最末位强行变为1</p> 
<p>如果需要把二进制最末位变成0，对这个数 |1之后再减一就可以了，其实际意义就是把这个数强行变成最近接的偶数</p> 
<p>--------------------------------------------------------------------</p> 
<p><strong>^ 运算</strong>---------------------------<strong>不同则为1，相同则为0 // 当且仅当两个运算值中有一个为1但不同时为1时，返回值为1</strong></p> 
<p><strong><br> </strong></p> 
<p>0^1=1；<br> </p> 
<p>1^0=1；</p> 
<p>1^1=0；</p> 
<p>0^0=0；</p> 
<p>00111</p> 
<p> ^           =11011<br> </p> 
<p>11100</p> 
<p>^运算通常用于对二进制的特定一位进行取反操作，^运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即（a^b)^b=a；</p> 
<p>^运算可以用于<span style="color:#000099">简单的加密</span>，比如原始值int a = 19880516;密钥 int key =1314520; 进行加密 int data=key^a = 20665500;解密 data^key == a；<br> </p> 
<p>^运算还可以实现<span style="color:#3333ff">两个值的交换</span>而不需要中间变量，例如：</p> 
<p>先看加减法中交换实现<br> </p> 
<p>void swap(long int &amp;a,long int &amp;b)</p> 
<p>{<!-- --></p> 
<p>     a = a+b;</p> 
<p>     b = a-b;</p> 
<p>     a = a-b;</p> 
<p>}</p> 
<p>void swap(long int &amp;a,long int &amp;b)</p> 
<p>{<!-- --></p> 
<p>    a = a^b;</p> 
<p>    b = a^b;</p> 
<p>    a = a^b;</p> 
<p>}</p> 
<p>所以 ^运算可以理解成类似加法（+）记忆 ， 1+1 =0，1+0 =1，0+1 =1；0+0 =0；//因为机器码是二进制，1+1=2%2 =0，其实不然</p> 
<p>---------------------------------------------------------------------------------------------------</p> 
<p><strong>~运算</strong></p> 
<p>~运算的定义把内存中的0和1全部取反，所以~运算时要格外小心，你需要注意整数类型有没符号，如果~的对象是无符号整数（不能表示负数），那么他的值就是它与它的上界限的之差，因为无符号类型的数是用$0000到$FFFF依次表示的。</p> 
<p>下面的两个程序（仅语言不同）均返回65435。</p> 
<p>var</p> 
<p>     a:word;</p> 
<p>begin</p> 
<p>      a:=100;</p> 
<p>      a:=not  a;</p> 
<p>     writenln(a);</p> 
<p>end.</p> 
<p><br> </p> 
<p>#include &lt;iostream&gt;</p> 
<p>using namespace std;</p> 
<p><br> </p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>       unsingned short a = 100;</p> 
<p>        a = ~a;</p> 
<p>        printf("%d\n",a);</p> 
<p>        return 0;</p> 
<p>}</p> 
<p><span style="color:#ff0000">如果 ~的对象是有符号的整数，情况就不一样了，详见最后面整数类型的存储</span></p> 
<p></p> 
<h3>三：位移运算</h3> 
<div> 
 <strong>&lt;&lt;运算</strong> 
</div> 
<p>a&lt;&lt;b 表示把a转为二进制后左移b位（在后面添加 b个0）。例如100的二进制表示为1100100，100左移2位后（后面加2个零）：1100100&lt;&lt;2 =110010000 =400，可以看出，a&lt;&lt;b的值实际上就是a乘以2的b次方，因为在二进制数后面添加一个0就相当该数乘以2，2个零即2的2次方 等于4。通常认为a&lt;&lt;1比a*2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作尽量用左移一位来代替。</p> 
<p>定义一些常量可能会用到&lt;&lt;运算。你可以方便的用1&lt;&lt;16 -1 来表示65535（unsingned int  最大值16位系统）。很多算法和数据结构要求数据模块必须是2的幂，此时就可以用&lt;&lt;来定义MAX_N等常量。</p> 
<p><strong>&gt;&gt;运算</strong></p> 
<p>和&lt;&lt;相似，a&gt;&gt;b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们经常用&gt;&gt;1来代替 /2（div 2),比如二分查找、堆的插入操作等等。想办法用&gt;&gt;代替除法运算可以使程序的效率大大提高。最大公约数的二进制算法用除以2操作来代替慢的出奇的%（mod）运算，<span style="color:#3333ff">效率可以提高60%</span>。</p> 
<p>int a =100;</p> 
<p>a/4 ==a&gt;&gt;2;</p> 
<p><strong>位移运算运用 例子</strong></p> 
<p><strong>1.合并数据</strong></p> 
<p>缩短数据：int a =4; int b=2;  可以将数据 a,b 保存于一个变量 int c中,在此int 类型为32位</p> 
<p>a=0x0000 0004; / /十六进制</p> 
<p>b=0x0000 0002;</p> 
<p>int c = a&lt;&lt;16;//左移操作-将a数据向左移动16位=0x0004 0000</p> 
<p> c |=b;  // （|）操作，一个为1 则为1，所以高16位不变，低16位值为 b值，即c = 0x0004 0002;完成数据的合并</p> 
<p><strong>2.解析数据</strong></p> 
<p>上面c = 0x0004 0002;</p> 
<p>读取高位：int a1 = c&gt;&gt;16; / / 右移16位，消除低位数据，读取高位数据 a1 = 0x0000 0004</p> 
<p>读取低位：int a2 = c&amp;0xFFFF; //（&amp;）操作，2个都为1 则为1，所以0xFFFF 即 0X0000 FFFF, 所以高位全为0，低位的 1不变，0还是0，a2=0x0000 0002,读取低位成功</p> 
<p>读取低位2：int a2 = c&lt;&lt;16; 消除高位，低位存入高位，a2=0x0002 0000;</p> 
<p>                                 a2 = a2&gt;&gt;16;高位存入低位，消除低位; a2 = 0x0000 0002;</p> 
<p><strong>下面列举一些常见的二进制位的变换操作</strong></p> 
<p> </p> 
<table border="1" width="400" cellspacing="1" cellpadding="1"><tbody><tr><td>去掉最后一位</td><td>101101-&gt;10110</td><td>x&gt;&gt;1</td></tr><tr><td>在最后加一个0</td><td>101101-&gt;1011010</td><td>x&lt;&lt;1</td></tr><tr><td>在最后加一个1</td><td>101101-&gt;1011011</td><td>(x&lt;&lt;1)+1</td></tr><tr><td>把最后一位变成1</td><td>101100-&gt;101101</td><td>x | 1</td></tr><tr><td>把最后一位变成0</td><td>101101-&gt;101100</td><td>(x |1) - 1</td></tr><tr><td>最后一位取反</td><td>101101-&gt;101100</td><td>x ^ 1</td></tr><tr><td>把右数第K位变成1</td><td>101001-&gt;101101,k=3</td><td>x  | (1&lt;&lt;(k-1))</td></tr><tr><td>把右数第K位变成0</td><td>101101-&gt;101101,k=3</td><td>x &amp; ~(1&lt;&lt;(k-1))</td></tr><tr><td>右数第k位取反</td><td>101001-&gt;101101,k=3</td><td>x ^ (1&lt;&lt;(k-1))</td></tr><tr><td>取末三位</td><td>1101101-&gt;101</td><td>x &amp;7</td></tr><tr><td>取末k位</td><td>1101101-&gt;1101,k=5</td><td>x &amp; (1&lt;&lt;k-1)</td></tr><tr><td>取右数第k位</td><td>1101101-&gt;1,k=4</td><td>x &gt;&gt; (k-1)&amp;1</td></tr><tr><td>把末k位变成1</td><td>101001-&gt;101111,k=4</td><td>x|(1&lt;&lt;k-1)</td></tr><tr><td>末k位取反</td><td>101001-&gt;100110,k=4</td><td>x^(1&lt;&lt;k-1)</td></tr><tr><td>把右边连续的1变成0</td><td>100101111-&gt;100100000</td><td>x&amp;(x+1)</td></tr><tr><td>把右起第一个0变成1</td><td>100101111-&gt;100111111</td><td>x|(x+1)</td></tr><tr><td>把右边连续的0变成1</td><td>11011000-&gt;11011111</td><td>x|(x-1)</td></tr><tr><td>取右边连续的1</td><td>100101111-&gt;1111</td><td>(x^(x+1))&gt;&gt;1</td></tr><tr><td>去掉右起第一个1的左边</td><td>100101000-&gt;1000</td><td>x&amp;(x^(x-1))</td></tr><tr><td> </td><td> </td><td> </td></tr></tbody></table> 
<strong></strong> 
<p></p> 
<p><span style="font-size:16px"></span></p> 
<p>最后一个会在树状数组中用到</p> 
<p><strong>整数类型的储存</strong></p> 
<p>前面 所说的位运算都没有涉及负数，都假设这些运算是在unsingned/word类型（只能表示正数的整型）上进行操作。</p> 
<p>但计算机如何处理有正负符号的整型呢？这个设计到补码，反码知识点，请看下面</p> 
<p>       假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为：00000000 00000000 00000000 00000101<br> 5转换成二进制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。<br>        现在想知道，-5在计算机中如何表示？<br> <span style="color:#cc0000">      <strong>在计算机中，负数以其正值的补码形式表达</strong>。</span></p> 
<p>      什么叫补码呢？这得从原码，反码说起。</p> 
<p><strong>四：反码，补码</strong></p> 
<div> 
 <strong>      </strong> 反码和补码的目的就是为了解决负数的问题 
</div> 
<div>
         在计算机内，定点数有3种表示法：原码、反码和补码 
</div> 
<div> 
 <p>       所谓原码就是前面所介绍的二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 </p> 
 <p><br> </p> 
 <p><strong>反码表示法规定</strong>：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 </p> 
 <p><strong>补码表示法规定</strong>：正数的补码与其原码相同；负数的补码是在其反码的末位加1。</p> 
 <p></p> 
 <p>      有原码就可以了，为什么还需要反码和补码？</p>         
 <p>      反码是用来算补码的，原码和补码都是用在CPU的基本运算里的，比如数据类型是short：   <br>       计算5   -   2，并由于实际上CPU没有实现减法电路（注：计算机的硬件结构中只有加法器，所以大部分的运算都必须最终转换为加法，原码没有办法做减法，而在我们使用的汇编、C等其他高级语言中使用的都是原码，原码转换成补码都是在计算机的最底层进行的）。原码计算是   5＋（－2）</p> 
 <p>     0101</p> 
 <p>  ＋1010</p> 
 <p>  -------  </p> 
 <p>      1111  </p> 
 <p><br>   ＝－7？显然出错<br>  所以不管正数还是负数，都使用补码来表示（正数原码和补码是一样的），  2的补码是1110，然后用5补   +   2补   <br>       0101   <br>   +  1110   <br>   ------   <br>       0011   </p> 
 <p>  ＝3，正确</p> 
 <p>《<a href="http://blog.csdn.net/wuguai4/article/details/7321440">补码的运算方法详见此链接</a>》<br> 所以理论上（也仅仅是理论上）我们只要让减数通过一个求反电路，再通过一个+1电路，然后通过加法电路就可以实现减法了。  </p> 
 <p>所以补码的设计目的是: <br> ⑴使符号位能与有效值部分一起参加运算,从而简化运算规则. <br> ⑵使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计</p> 
 <br> 
</div> 
<p><strong>        原码</strong>：在数值前直接加一符号位的表示法。</p> 
<p></p> 
<div class="spctrl"></div> 　　            例如： 符号位 数值位 
<div class="spctrl"></div> 　　                       [+7]原= 0 0000111 B 
<div class="spctrl"></div> 　　                       [-7]原= 1 0000111 B 
<br> 
<p></p> 
<p>        注意：a： 数0的原码有两种形式：<br>                            [+0]原=00000000B </p> 
<p>                           [<a href="http://baike.baidu.com/view/1199203.htm" rel="nofollow noopener noreferrer" target="_blank">-0</a>]原=10000000B</p> 
<p></p> 
<div class="spctrl"></div> 　   　        b： 8位二进制原码的表示范围：-127～+127 
<br> 
<p></p> 
<p><br> 　　<strong>反码</strong>：正数：正数的反码与原码相同。</p> 
<div class="spctrl"></div> 
<p>　　            负数：负数的反码，符号位为“1”，数值部分按位取反。</p> 
<p>                   例如： 符号位 数值位 </p> 
<div class="spctrl"></div> 　                        　[+7]反= 0 0000111 B 
<div class="spctrl"></div> 　　                        [-7]反= 1 1111000 B 
<div class="spctrl"></div> 　   注意：a：数0的反码也有两种形式，即 
<div class="spctrl"></div> 　            　     [+0]反=00000000B 
<div class="spctrl"></div> 　   　              [- 0]反=11111111B 
<div class="spctrl"></div> 　          　b.：8位二进制反码的表示范围：-127～+127 
<br> 
<p></p> 
<p></p> 
<p><br>       <strong> 补码：</strong></p> 
<p><strong>         1）</strong>模的概念：把一个计量单位称之为模或模数。例如，时钟是以12进制进行计数循环的，即以12为模。在时钟上，时针加上（正拨）12的整数位或减去（反拨）12的整数位，时针的位置不变。14点钟在舍去模12后，成为（下午）2点钟（14=14-12=2）。从0点出发逆时针拨10格即减去10小时，也可看成从0点出发顺时针拨2格（加 上2时），即2点（0-10=-10=-10+12=2）。因此，在模12的前提下，-10可映射为+2。由此可见，对于一个模数为12的循环系统来说，加2和减10的效果是一样的； 因此，在以12为模的系统中，凡是减10的运算都可以用加2来代替，这就把减法问题转化成加法问题了（<span style="color:#ff0000">注：计算机的硬件结构中只有加法器，所以大部分的运算都必 须最终转换为加法</span>）。10和2对模12而言互为补数。</p> 
<p>  </p> 
<div class="spctrl"></div> 　　        同理，计算机的运算部件与寄存器都有一定字长的限制（假设字长为8），因此它的运算也是一种模运算。当计数器计满8位也就是256个数后会产生溢出，又从头开始                 计数。产生溢出的量就是计数器的模，显然，8位二进制数，它的模数为8=256。在计算中，两个互补的数称为“补码”。 
<p></p> 
<p>　    <strong>2）</strong>补码的表示： </p> 
<div class="spctrl"></div> 　　       正数：正数的补码和原码相同。 
<div class="spctrl"></div> 　　       负数：负数的补码则是符号位为“1”。并且，这个“1”既是符号位，也是数值位。数值部分按位取反后再在末位（最低位）加1。也就是“反码+1”。 
<div class="spctrl"></div> 　　 例如： 符号位 数值位 
<div class="spctrl"></div> 　　             [+7]补= 0 0000111 B 
<div class="spctrl"></div> 
<p>　　             [-7]补= 1 1111001 B </p> 
<p><br> </p> 
<div class="spctrl"></div> 　　 
<span style="color:#ff6666; background-color:rgb(51,102,255)">补码在微型机中是一种重要的编码形式，请注意：</span> 
<div class="spctrl"></div> 
<p>　　<strong>a：</strong> 采用补码后，可以方便地将减法运算转化成加法运算，运算过程得到简化。正数的补码即是它所表示的数的真值，而负数的补码的数值部份却不是它所表示的数的真                    值。采用补码进行运算，所得结果仍为补码。</p> 
<p><br> </p> 
<div class="spctrl"></div> 
<p>　　<strong>b.：</strong>与原码、反码不同，数值0的补码只有一个，即 [0]补=00000000B。</p> 
<p><br> </p> 
<div class="spctrl"></div> 
<p>　　<strong>c.：</strong>若字长为8位，则补码所表示的范围为-128～+127；进行补码运算时，应注意所得结果不应超过补码所能表示数的范围。</p> 
<p><br> </p> 
<p><strong>源码、反码和补码之间的转化</strong></p> 
<p><strong>        </strong>由于正数的源码、反码、补码表示方法相同，不需转换。</p> 
<p>       <span style="color:#ff0000">  <span style="background-color:rgb(51,102,255)">在此，仅以负数情况分析。</span></span></p> 
<p>          <strong>1）已知原码，求补码</strong></p> 
<p><strong>                 </strong>例：已知某数X的源码为10110100B，试求X的补码和反码。</p> 
<p>                 解：由【X】原=10110100B看出，X为负数。求其反码时，符号位不变，数值部分按位求反；求其补码时，再在其反码的末位加1。</p> 
<p>                  10110100 原码</p> 
<p>                   11001011反码，符号位不变，数值取反</p> 
<p>                  1+1</p> 
<p>                  11001100 补码</p> 
<p>                 故：【X】补 = 11001100B，【X】反 = 11001011B。</p> 
<p>           <strong>2）已知补码，求原码。</strong></p> 
<p><strong>                 </strong>分析：按照求负数补码的你过程，数值部分应是最低位减1，然后取反。但是对二进制数来说，先减1后取反和先取反后加1得到的结果是一样的，故仍可采用取反加1                    的方法。</p> 
<p>                 例：已知某数X的补码1110110B，试求其原码。</p> 
<p>                解：由【X】补 = 11101110B知，X为负数。</p> 
<p>                 采用逆推法</p> 
<p>                 11101110 补码</p> 
<p>                 11101101反码（符号位不变，数值取反加1）</p> 
<p>                 10010010原码（符号位不变，数值取反）</p> 
<p>                   算法2：</p> 
<p>                  设源码 =  A；可见A为负数</p> 
<p>                  设反码 = B；</p> 
<p>                  因为补码 = 反码+1；所以</p> 
<p>                   B +1 = 11101110；</p> 
<p>                   B = 11101110 - 1 </p> 
<p>                       = 11101101;</p> 
<p>                   A =B取反（符号位不变） = 10010010；</p> 
<p><br> </p> 
<p><strong>有符号数运算时的溢出问题，看下下面两个题目</strong></p> 
<p>两个数相加怎么变成了负数？？？</p> 
<p><strong>1）</strong> （+72）+（+98）=？ </p> 
<div class="spctrl"></div> 　　0 1 0 0 1 0 0 0 B +72 
<div class="spctrl"></div> 
<p>　　+</p> 
<p>        0 1 1 0 0 0 1 0 B +98</p> 
<div class="spctrl"></div> 　　1 0 1 0 1 0 1 0 B -86 
<div class="spctrl"></div> 　　两负数相加怎么会得出正数？？？  
<div class="spctrl"></div> 
<strong>2）</strong>（-83）+（-80）=？ 
<div class="spctrl"></div> 　　1 0 1 0 1 1 0 1 B -83 
<div class="spctrl"></div> 
<p>　　+</p> 
<p>        1 0 1 1 0 0 0 0 B -80</p> 
<div class="spctrl"></div> 　　0 1 0 1 1 1 0 1 B +93 
<div class="spctrl"></div> 　　思考：这两个题目，按照正常的法则来运算，但结果显然不正确，这是怎么回事呢？ 
<p></p> 
<p><br>   </p> 
<div class="spctrl"></div> 　　答案：这是因为发生了溢出。 
<p></p> 
<p><br>   </p> 
<div class="spctrl"></div> 　　如果计算机的字长为n位，n位二进制数的最高位为符号位，其余n-1位为数值位，采用补码表示法时，可表示的数X的范围是 -2的 
<em>n-1</em>次幂≤X≤2的 
<em>n-1</em>次幂-1 
<div class="spctrl"></div> 　　当n=8时，可表示的有符号数的范围为-128～+127。两个有符号数进行加法运算时，如果运算结果超出可表示的有符号数的范围时，就会发生溢出，使计算结果出错。很显然，溢出只能出现在两个同符号数相加或两个异符号数相减的情况下。 
<div class="spctrl"></div> 　　对于加法运算，如果次高位（数值部分最高位）形成进位加入最高位，而最高位（符号位）相加（包括次高位的进位）却没有进位输出时，或者反过来，次高位没有进位加入最高位，但最高位却有进位输出时，都将发生溢出。因为这两种情况是：两个正数相加，结果超出了范围，形式上变成了负数；两负数相加，结果超出了范围，形式上变成了正数。 
<div class="spctrl"></div> 　　而对于减法运算，当次高位不需从最高位借位，但最高位却需借位（正数减负数，差超出范围），或者反过来，次高位需从最高位借位，但最高位不需借位（负数减正数，差超出范围），也会出现溢出。 
<div class="spctrl"></div> 　　在计算机中，数据是以补码的形式存储的，所以补码在 
<a href="http://baike.baidu.com/view/1219.htm" rel="nofollow noopener noreferrer" target="_blank">c语言</a>的教学中有比较重要的地位，而讲解补码必须涉及到原码、反码。本部分演示作何一个整数的原码、反码、补码。过程与结果显示在列表框中，结果比较少，不必自动清除，而过程是相同的，没有必要清除。故需设清除各部分及清除全部的按钮。测试时注意最大、最小正负数。用户使用时注意讲解不会溢出：当有一个数的反码的全部位是1才会溢出，那么它的原码是10000...，它不是负数，故不会溢出。 
<div class="spctrl"></div> 　　在n位的机器数中，最高位为符号位，该位为零表示为正，为一表示为负；其余n-1位为数值位，各位的值可为零或一。当真值为正时，原码、反码、补码数值位完全相同；当真值为负时，原码的数值位保持原样，反码的数值位是原码数值位的各位取反，补码则是反码的最低位加一。注意符号位不变。 
<div class="bpctrl"></div> 
<h3 class="headline-1 bk-sidecatalog-title"><span class="headline-content">总结</span></h3> 　　提示信息不要太少，可“某某数的反码是某某”，而不是只显示数值。 
<div class="spctrl"></div> 
<p>　　1.原码的求法:</p> 
<p>        (1)对于正数,转化为二进制数,在最前面添加一符号位(这是规定的),用1表示负数,0表示正数.如:0000 0000是一个字节,其中0为符号位,表示是正数,其它七位表示二进制的值.其实,机器不管这些,什么符号位还是值,机器统统看作是值来计算. 正数的原码、反码、补码是同一个数!</p> 
<div class="spctrl"></div> 　　(2)对于负数,转化为二进制数,前面符号位为1.表示是负数. 
<div class="spctrl"></div> 　　计算原码只要在转化的二进制数前面加上相应的符号位就行了. 
<div class="spctrl"></div> 　　2.反码的求法:对于负数,将原码各位取反,符号位不变. 
<div class="spctrl"></div> 　　3.补码的求法:对于负数,将反码加上二进制的1即可,也就是反码在最后一位上加上1就是补码了. 
<br> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/607473a0cf89f5b51b2318c9301959c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">视频码率,帧率和分辨率的联系与区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a66ff4e55a94542944f853e3fce51f24/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AFX_MANAGE_STATE(AfxGetStaticModuleState())讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>