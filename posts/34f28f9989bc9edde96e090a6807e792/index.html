<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mybatisPlus中apply的使用以进行联表等复杂sql语句 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mybatisPlus中apply的使用以进行联表等复杂sql语句" />
<meta property="og:description" content="在 MyBatis-Plus 中，`apply()` 方法可以用于添加任意的 SQL 片段，包括联表查询。因此，你可以使用 `apply()` 方法来处理各种类型的联表查询。
使用 `apply()` 方法的好处是可以在查询条件中直接添加原生的 SQL 片段，而不受 MyBatis-Plus 提供的常规查询条件构建方法的限制。这使得你可以更灵活地构建复杂的联表查询语句，满足特定的查询需求。
但是需要注意的是，使用 `apply()` 方法需要谨慎处理。由于 `apply()` 方法允许添加原生的 SQL 片段，这可能导致 SQL 注入等安全问题。为了避免潜在的安全风险，需要确保你添加的 SQL 片段是可信的，并且进行合适的参数化处理。
另外，使用 `apply()` 方法可能会导致查询性能下降，特别是在处理大量数据时。如果可能，建议优先考虑使用 MyBatis-Plus 提供的常规查询条件构建方法，以充分利用框架的优化能力。
综上所述，虽然 `apply()` 方法可以用于处理各种联表查询，但在使用时需要谨慎考虑安全性和性能方面的问题。
比如我想左联三张表，最后以时间倒序排序，怎么写？举例子
假设你有三张表：`user`、`order` 和 `product`，它们之间的关系是 `user` 表和 `order` 表通过 `user_id` 进行关联，`order` 表和 `product` 表通过 `product_id` 进行关联。你想要进行左联三张表，并按照时间倒序排序。
你可以使用 `apply()` 方法添加原生的 SQL 片段，来构建这个查询。
```java
QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
queryWrapper
.select(&#34;user.*, order.*, product.*&#34;) // 选择需要的列
.apply(&#34;LEFT JOIN `order` ON `user`." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/34f28f9989bc9edde96e090a6807e792/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-24T22:54:33+08:00" />
<meta property="article:modified_time" content="2023-06-24T22:54:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mybatisPlus中apply的使用以进行联表等复杂sql语句</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在 MyBatis-Plus 中，`apply()` 方法可以用于添加任意的 SQL 片段，包括联表查询。因此，你可以使用 `apply()` 方法来处理各种类型的联表查询。</p> 
<p>使用 `apply()` 方法的好处是可以在查询条件中直接添加原生的 SQL 片段，而不受 MyBatis-Plus 提供的常规查询条件构建方法的限制。这使得你可以更灵活地构建复杂的联表查询语句，满足特定的查询需求。</p> 
<p>但是需要注意的是，使用 `apply()` 方法需要谨慎处理。由于 `apply()` 方法允许添加原生的 SQL 片段，这可能导致 SQL 注入等安全问题。为了避免潜在的安全风险，需要确保你添加的 SQL 片段是可信的，并且进行合适的参数化处理。</p> 
<p>另外，使用 `apply()` 方法可能会导致查询性能下降，特别是在处理大量数据时。如果可能，建议优先考虑使用 MyBatis-Plus 提供的常规查询条件构建方法，以充分利用框架的优化能力。</p> 
<p>综上所述，虽然 `apply()` 方法可以用于处理各种联表查询，但在使用时需要谨慎考虑安全性和性能方面的问题。</p> 
<p>比如我想左联三张表，最后以时间倒序排序，怎么写？举例子</p> 
<p>假设你有三张表：`user`、`order` 和 `product`，它们之间的关系是 `user` 表和 `order` 表通过 `user_id` 进行关联，`order` 表和 `product` 表通过 `product_id` 进行关联。你想要进行左联三张表，并按照时间倒序排序。</p> 
<p>你可以使用 `apply()` 方法添加原生的 SQL 片段，来构建这个查询。</p> 
<p>```java<br> QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();<br> queryWrapper<br>   .select("user.*, order.*, product.*")  // 选择需要的列<br>   .apply("LEFT JOIN `order` ON `user`.id = `order`.user_id")<br>   .apply("LEFT JOIN `product` ON `order`.product_id = `product`.id")<br>   .orderByDesc("`order`.create_time");<br>   <br> List&lt;User&gt; userList = userMapper.selectList(queryWrapper);<br> ```</p> 
<p>在上述示例中，我们创建了一个 `QueryWrapper` 对象，并使用 `apply()` 方法添加了两个左联操作的 SQL 片段。`select()` 方法用于选择需要返回的列，这里我们选择了 `user.*`、`order.*` 和 `product.*`，即返回三张表的所有列。`orderByDesc()` 方法用于按照 `order` 表的 `create_time` 字段进行时间倒序排序。</p> 
<p>最后，我们使用 `selectList()` 方法执行查询，并将结果存储在 `userList` 中。</p> 
<p>请注意，在实际使用中，你需要根据表的实际结构和字段名进行相应的调整。同时，还要确保表名和字段名在 SQL 语句中使用反引号 ` 来包裹，以避免与 MySQL 的关键字冲突。</p> 
<p>希望这个示例能够帮助你理解如何使用 `apply()` 方法进行左联查询，并按照时间倒序排序。</p> 
<p>如果你想在联表查询中进行 GROUP BY 操作，并使用 HAVING 子句进行筛选，你可以使用 MyBatis-Plus 的 `groupBy()` 和 `having()` 方法来实现。</p> 
<p>以下是一个示例，假设你要对 `user` 表和 `order` 表进行联表查询，按照 `user_id` 进行分组，并筛选出总订单金额大于 1000 的用户：</p> 
<p>```java<br> QueryWrapper&lt;Order&gt; queryWrapper = new QueryWrapper&lt;&gt;();<br> queryWrapper<br>   .select("user.id, user.name, SUM(order.amount) AS total_amount")<br>   .eq("order.status", "completed")<br>   .groupBy("user.id")<br>   .having("total_amount &gt; 1000");<br>   <br> List&lt;Map&lt;String, Object&gt;&gt; resultList = orderMapper.selectMaps(queryWrapper);<br> ```</p> 
<p>在上述示例中，我们创建了一个 `QueryWrapper` 对象，并使用 `select()` 方法选择需要返回的列，这里我们选择了 `user.id`、`user.name` 和 `SUM(order.amount) AS total_amount`，即返回用户的 ID、姓名和总订单金额。`eq()` 方法用于添加查询条件，这里我们筛选出 `order` 表中状态为 "completed" 的订单。`groupBy()` 方法用于指定按照 `user.id` 进行分组。`having()` 方法用于添加 HAVING 子句，这里我们筛选出总订单金额大于 1000 的用户。</p> 
<p>最后，我们使用 `selectMaps()` 方法执行查询，并将结果存储在 `resultList` 中。`selectMaps()` 方法返回的是一个 List&lt;Map&lt;String, Object&gt;&gt;，每个 Map 对应一条记录，其中键是列名，值是对应的值。</p> 
<p>请注意，在实际使用中，你需要根据表的实际结构和字段名进行相应的调整。</p> 
<p>希望这个示例能够帮助你理解如何在联表查询中进行 GROUP BY 操作，并使用 HAVING 子句进行筛选。</p> 
<p> </p> 
<p>在 MyBatis-Plus 中，`apply()` 和 `last()` 都是 QueryWrapper 类的方法，但它们的作用和使用场景有所不同。</p> 
<p>1. `apply()` 方法用于在查询条件中添加自定义的 SQL 片段。你可以使用 `apply()` 方法来添加原生的 SQL 片段，以满足特定的查询需求，例如联表查询、自定义的条件表达式等。</p> 
<p>2. `last()` 方法用于在查询语句的最后添加原生的 SQL 片段。你可以使用 `last()` 方法来添加原生的 SQL 片段，以在查询语句的最后位置添加自定义的 SQL 语句，例如排序、分页等。</p> 
<p>下面是一个示例，展示了 `apply()` 和 `last()` 方法的使用：</p> 
<p>```java<br> QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();<br> queryWrapper<br>   .apply("LEFT JOIN `order` ON `user`.id = `order`.user_id")<br>   .last("ORDER BY `order`.create_time DESC");<br>   <br> List&lt;User&gt; userList = userMapper.selectList(queryWrapper);<br> ```</p> 
<p>在上述示例中，我们使用 `apply()` 方法添加了一个联表操作的 SQL 片段，将 `user` 表和 `order` 表进行左联。然后，使用 `last()` 方法在查询语句的最后添加了一个原生的 SQL 片段，指定了按照 `order` 表的 `create_time` 字段进行降序排序。</p> 
<p>需要注意的是，使用 `last()` 方法需要谨慎处理，因为它直接将原生的 SQL 片段拼接到查询语句的最后，可能会导致 SQL 注入等安全问题。为了避免潜在的安全风险，需要确保添加的 SQL 片段是可信的，并进行合适的参数化处理。</p> 
<p>综上所述，`apply()` 方法用于添加自定义的 SQL 片段到查询条件中，而 `last()` 方法用于在查询语句的最后添加原生的 SQL 片段。它们分别用于不同的场景和目的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58919e0d081ef3dea1157936c3406579/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python中.ix（）函数的作用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e42970354a628f3ee2ba95516cebd693/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JAVA宝典----关键字(理解记忆)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>