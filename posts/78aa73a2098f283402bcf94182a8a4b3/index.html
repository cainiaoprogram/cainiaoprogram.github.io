<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件开发面试题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件开发面试题" />
<meta property="og:description" content="1.Windows内存管理方法 windows内存管理方式主要分为:页式管理，段式管理，段页式管理。
2.IP和 Mac的解析协议是什么? IP和Mac的解析协议是地址解析协议ARP，是根据IP地址获取物理地址的一个TCP/IP协议。
3.解释VPN VPN的英文全称是“Virtual Private Networ议，为虚拟专用网络，虚拟专用网(VPN〉被定义为通过一个公用网络（通常是因特网）建立一个临时的、安全的连接，是一条穿过混乱的公用网络的安全、稳定的隧道。虚拟专用网是对企业内部网的扩展。虚拟专用网可以帮助
4.继承和多态 (1)继承:当两个或两个以上的类，具有部分相同的内容(属性和方法)并且可抽象出另一个类彼此之间满足is-a关系，这种关系就是继承。在继承关系中，父类更通用、子类更具体更有一版特性和行为，而子类除了具有父类的特性和行为，还具有一些自己的特殊的特征和行为。在子类继承父类中构造方法和私有方法不能被继承。继承具有代码的可重用性、父类的属性和方法可用于子类、设计应用程序变得更加简单、可以轻松地自定义子类。
(2)多态:同一个实现接口，使用不同的实例而执行不同的操作。多态不仅能减少编码的工作量，也能大大提高程序的可维护性及可扩展性。能改善代码结构，提高其可读性。多态是从类的角度来处理逻辑上的分离。能把多个类(派生同一个基类)当做一个类来处理。这样就能作用于不同的类型了。
5.排序算法的种类 (1)插入排序:每次将一个待排序的数据元素，插入到前面已经排好序的数列中的适当位置，使数列依然有序，直到待排序数据元素全部插入完为止。
(2〉选择排序:每一趟从待排序的数据元素中选出最小(或最大〉的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。
(3）冒泡排序:两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没有反序的数据元素为止。
(4〉快速排序:在当前无序区中任取一个数据元素作为比较的&#34;基准&#34;，用此基准将当前无序区划分为左右两个较小的无序区，且左边的无序子区中数据元素均小于等于基准元素，右边的无序子区中数据元素均大于等于基准元素，而基准则位于最终排序的位置上，直至所有无序子区中的数据元素均已排序为止。
(5）堆排序:堆排序是一树形选择排序，在排序过程中，将数据看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。
(6）分配排序、归并排序、希尔排序
6.进程和线程的区别 一个程序至少有一个进程，一个进程至少有一个线程。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源。进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程.
7.软件开发模型 软件开发模型是指软件开发全部过程﹑活动和任务的结构框架。软件开发包括需求、设计、编码和测试等阶段，有时也包括维护阶段。软件开发模型能清晰﹑直观地表达软件开发全过程，明确规定了要完成的主要活动和任务，用来作为软件项目工作的基础o
(1）瀑布模型:每个软件过程顺序衔接、一次性通过。最常用。需求明确且很少变更的项目，如二次开发或升级型项目。
(2〉螺旋模型:以原型为基础沿螺线旋转﹑每转―圈都经过计划/风险分析/实施/评估等过程且得到相应新版本、经过若干次螺旋上升得到最终版本。需求经常变化的大型复杂系统。
(3）增里模型:采用随时间进展而交错的线性序列﹑每个序列产生一个可发布的增里﹑每个增里产生一个可操作的产品﹑第一个增里是核心产品。需求经常发生改变的软件开发过程。
(4）快速原型模型:快速构建可运行的软件模型﹐以便理解和澄清问题，进一步细化需求﹐在新获取需求基础上进行系统开发。用户需求模糊不明的情况下。
(5〉迭代模型:一次迭代过程包括了所有软件开发流程﹑每一次迭代均产生一个可发布的产品、该产品为最终产品的一个子集。适用于事先不能完整定义产品的所有需求，计划多期开发的项目。
(6〉喷泉模型:以用户需求为动力、以对象为驱动的模型，支持软件复用及多项开发活动的集成，主要支持面向对象的开发方法。
8.TCP三次握手 TCP 是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:位码即tcp标志位,有6种*示:SYN(synchronous建立联机)ACK(acknowledgement确认) PSH(push传送) FIN(finish结束)RST(reset重置)URG(urgent 紧急)Sequencnumber(顺序号码y Acknowledge numbei确认号码)。
第一次握手∶主机A发送位码为syn =1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机
第二次握手:主机B收到请求后要确认联机信息，向A发送ack numbere=住机A的seq&#43;1)syn=1,ack=1,随机产生seq=7654321的包。
第三次握手:主机A收到后检查ack number是否正确，即第一次发送的seq number&#43;1以及位码ack 是否为1，若正确。主机A会再发送acnumbere=(主机B的seq&#43;1),ack=1，主机B收到后确认seq值与ack=-1则连接建立成功。
完成三次握手，主机A与主机B开始传送数据。第一次握手∶建立连接时，客户端发送syn 包(yn=j)到服务器﹐并进入SYN_SEND 状态，等待服务器确认﹔第二次握手:服务器收到sy包，必须确认客户的SYN (ack=j&#43;1)，同时自己也发送一个SYN包(syn=k)，即SYN&#43;ACK包，此时服务器进入SYN_RECV状态﹔第:次握手∶客户端收到服务器的SYN&#43;ACK包，向服务器发送确认包ACK(ack=t±1)，此包发送完毕，客户端和服务器进入ESTABLISHEI状态,完成三次握手。完成三次握手,客户端与朋务器开始传送数据。
9.osi七层模型 第一层:物理层比特流设备之间比特流的传输,物理接口，电气特性等。
第二层:数据链路层帧将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正。
第三层:网络层包提供逻辑地址（P)、选路，数据从源端到目的端的传输。
第四层:传输层段实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流里控制等。
第五层:会话层数据允许不同机器上的用户之间建立会话关系，如WINDOws
第六层:表示层数据数据的表现形式，特定功能的实现，如数据加密。
第七层:应用层数据用户接口,提供用户程序“接口”。
10.谈谈Overload和l Override 的区别。 方法的重写Overriding 和重载Overloading 是 Java 多态性的不同表现。
重写Overriding是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被&#34;屏蔽&#34;了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/78aa73a2098f283402bcf94182a8a4b3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-16T11:04:41+08:00" />
<meta property="article:modified_time" content="2020-12-16T11:04:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件开发面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1Windows_0"></a>1.Windows内存管理方法</h3> 
<p>  windows内存管理方式主要分为:页式管理，段式管理，段页式管理。</p> 
<h3><a id="2IP_Mac_2"></a>2.IP和 Mac的解析协议是什么?</h3> 
<p>  IP和Mac的解析协议是地址解析协议ARP，是根据IP地址获取物理地址的一个TCP/IP协议。</p> 
<h3><a id="3VPN_5"></a>3.解释VPN</h3> 
<p>  VPN的英文全称是“Virtual Private Networ议，为虚拟专用网络，虚拟专用网(VPN〉被定义为通过一个公用网络（通常是因特网）建立一个临时的、安全的连接，是一条穿过混乱的公用网络的安全、稳定的隧道。虚拟专用网是对企业内部网的扩展。虚拟专用网可以帮助</p> 
<h3><a id="4_7"></a>4.继承和多态</h3> 
<p>  (1)继承:当两个或两个以上的类，具有部分相同的内容(属性和方法)并且可抽象出另一个类彼此之间满足is-a关系，这种关系就是继承。在继承关系中，父类更通用、子类更具体更有一版特性和行为，而子类除了具有父类的特性和行为，还具有一些自己的特殊的特征和行为。在子类继承父类中构造方法和私有方法不能被继承。继承具有代码的可重用性、父类的属性和方法可用于子类、设计应用程序变得更加简单、可以轻松地自定义子类。<br>   (2)多态:同一个实现接口，使用不同的实例而执行不同的操作。多态不仅能减少编码的工作量，也能大大提高程序的可维护性及可扩展性。能改善代码结构，提高其可读性。多态是从类的角度来处理逻辑上的分离。能把多个类(派生同一个基类)当做一个类来处理。这样就能作用于不同的类型了。</p> 
<h3><a id="5_10"></a>5.排序算法的种类</h3> 
<p>  (1)插入排序:每次将一个待排序的数据元素，插入到前面已经排好序的数列中的适当位置，使数列依然有序，直到待排序数据元素全部插入完为止。<br>   (2〉选择排序:每一趟从待排序的数据元素中选出最小(或最大〉的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。<br>   (3）冒泡排序:两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没有反序的数据元素为止。<br>   (4〉快速排序:在当前无序区中任取一个数据元素作为比较的"基准"，用此基准将当前无序区划分为左右两个较小的无序区，且左边的无序子区中数据元素均小于等于基准元素，右边的无序子区中数据元素均大于等于基准元素，而基准则位于最终排序的位置上，直至所有无序子区中的数据元素均已排序为止。<br>   (5）堆排序:堆排序是一树形选择排序，在排序过程中，将数据看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。<br>   (6）分配排序、归并排序、希尔排序</p> 
<h3><a id="6_17"></a>6.进程和线程的区别</h3> 
<p>  一个程序至少有一个进程，一个进程至少有一个线程。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源。进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程.</p> 
<h3><a id="7_19"></a>7.软件开发模型</h3> 
<p>  软件开发模型是指软件开发全部过程﹑活动和任务的结构框架。软件开发包括需求、设计、编码和测试等阶段，有时也包括维护阶段。软件开发模型能清晰﹑直观地表达软件开发全过程，明确规定了要完成的主要活动和任务，用来作为软件项目工作的基础o<br>   (1）瀑布模型:每个软件过程顺序衔接、一次性通过。最常用。需求明确且很少变更的项目，如二次开发或升级型项目。<br>   (2〉螺旋模型:以原型为基础沿螺线旋转﹑每转―圈都经过计划/风险分析/实施/评估等过程且得到相应新版本、经过若干次螺旋上升得到最终版本。需求经常变化的大型复杂系统。<br>   (3）增里模型:采用随时间进展而交错的线性序列﹑每个序列产生一个可发布的增里﹑每个增里产生一个可操作的产品﹑第一个增里是核心产品。需求经常发生改变的软件开发过程。<br>   (4）快速原型模型:快速构建可运行的软件模型﹐以便理解和澄清问题，进一步细化需求﹐在新获取需求基础上进行系统开发。用户需求模糊不明的情况下。<br>   (5〉迭代模型:一次迭代过程包括了所有软件开发流程﹑每一次迭代均产生一个可发布的产品、该产品为最终产品的一个子集。适用于事先不能完整定义产品的所有需求，计划多期开发的项目。<br>   (6〉喷泉模型:以用户需求为动力、以对象为驱动的模型，支持软件复用及多项开发活动的集成，主要支持面向对象的开发方法。</p> 
<h3><a id="8TCP_27"></a>8.TCP三次握手</h3> 
<p>  TCP 是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:位码即tcp标志位,有6种*示:SYN(synchronous建立联机)ACK(acknowledgement确认) PSH(push传送) FIN(finish结束)RST(reset重置)URG(urgent 紧急)Sequencnumber(顺序号码y Acknowledge numbei确认号码)。<br>   第一次握手∶主机A发送位码为syn =1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机<br>   第二次握手:主机B收到请求后要确认联机信息，向A发送ack numbere=住机A的seq+1)syn=1,ack=1,随机产生seq=7654321的包。<br>   第三次握手:主机A收到后检查ack number是否正确，即第一次发送的seq number+1以及位码ack 是否为1，若正确。主机A会再发送acnumbere=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=-1则连接建立成功。<br>   完成三次握手，主机A与主机B开始传送数据。第一次握手∶建立连接时，客户端发送syn 包(yn=j)到服务器﹐并进入SYN_SEND 状态，等待服务器确认﹔第二次握手:服务器收到sy包，必须确认客户的SYN (ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态﹔第:次握手∶客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=t±1)，此包发送完毕，客户端和服务器进入ESTABLISHEI状态,完成三次握手。完成三次握手,客户端与朋务器开始传送数据。</p> 
<h3><a id="9osi_33"></a>9.osi七层模型</h3> 
<p>  第一层:物理层比特流设备之间比特流的传输,物理接口，电气特性等。<br>   第二层:数据链路层帧将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正。<br>   第三层:网络层包提供逻辑地址（P)、选路，数据从源端到目的端的传输。<br>   第四层:传输层段实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流里控制等。<br>   第五层:会话层数据允许不同机器上的用户之间建立会话关系，如WINDOws<br>   第六层:表示层数据数据的表现形式，特定功能的实现，如数据加密。<br>   第七层:应用层数据用户接口,提供用户程序“接口”。</p> 
<h3><a id="10Overloadl_Override__42"></a>10.谈谈Overload和l Override 的区别。</h3> 
<p>  方法的重写Overriding 和重载Overloading 是 Java 多态性的不同表现。<br>   重写Overriding是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p> 
<h3><a id="11HashMap_Hashtable_45"></a>11.谈谈HashMap和 Hashtable的区别。</h3> 
<p>   HashMap是轻量级的(线程不安全的，效率高的)集合，Hashtable是重量级的(线程安全的，效率低的）集合。<br>   都属于Map接口的类，实现了将惟一键映射到特定的值上。<br>   HashMap类没有分类或者排序。它允许一个null键和多个null 值。<br>   Hashtable类似于HashMap，但是不允许null键和 null 值。它也比 HashMap慢，因为它是同步的。</p> 
<h3><a id="12abstract_classinterface_50"></a>12.请问abstract class和interface有什么区别?</h3> 
<p>  1)接口没有任何的实现,而抽象类它可以有部分的实现也可以没有;<br>   2)如果需要复用或者共享部分代码,应该用抽象类而不是接口;<br>   3)继承无法解决类型的转换问题,接口就是为了解决这一问题而产生的(Java的单继承是接口产生的根本原因)接口是一种抽象的第三方规范,跟对象没什么直接关系。</p> 
<h3><a id="13_54"></a>13.请问类与对象有什么区别?</h3> 
<p>  类就是某一种事物的一般性的集合体，是相同或相似的各个事物共同特性的一种抽象。<br>   在面向对象概念中，对象 （Object )是类的实例( instance )。对象与类的关系就像变量与数据类型的关系一样。</p> 
<h3><a id="14publicprivateprotected__default__57"></a>14.public,private,protected , default 访问权限</h3> 
<p>public :全局可见<br> protected :继承体系结构之间可见<br> default (或不写):同包可见<br> private :本类可见。</p> 
<h3><a id="15Java_Servlet_API_forward__redirect_62"></a>15.Java Servlet API中 forward( 与 redirect()的区别</h3> 
<p>  前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址;<br>   后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。</p> 
<h3><a id="16_65"></a>16.类的核心特性有哪些?</h3> 
<p>  类具有封装性、继承性和多态性。<br>   封装性:<br>   类的封装性为类的成员提供公有、缺省、保护和私有等多级访问权限，目的是隐藏类中的私有变量和类中方法的实现细节。<br>   继承性:<br>   类的继承性提供从已存在的类创建新类的机制，继承( inheritance )使一个新类自动拥有被继承类(父类）的全部成员。<br>   多态性:<br>   类的多态性提供类中方法执行的多样性，多态性有两种表现形式:重载和覆盖。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/63707ad69955524082ba703bd73a1e8b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CASA方法估算NPP（IDL&#43;ENVI）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b503fd4da7c7f2a2e28e445e7d8263c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">让NotePad&#43;&#43;添加到右键快捷方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>