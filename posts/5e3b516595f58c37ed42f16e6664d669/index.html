<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>1.动态内存开辟  malloc  calloc  realloc  free  函数 2.动态存储通讯录 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="1.动态内存开辟  malloc  calloc  realloc  free  函数 2.动态存储通讯录" />
<meta property="og:description" content="malloc： void* malloc (size_t size); 这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。
如果开辟成功，则返回一个指向开辟好空间的指针。 如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。 返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。 如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。 free： free函数用来释放动态开辟的内存。 如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。 如果参数 ptr 是NULL指针，则函数什么事都不做。
malloc和free都声明在 stdlib.h 头文件中。 #include &lt;stdio.h&gt; int main() { //代码1 int num = 0; scanf(&#34;%d&#34;, &amp;num); int arr[num] = {0}; //代码2 int* ptr = NULL; ptr = (int*)malloc(num*sizeof(int)); if(NULL != ptr)//判断ptr指针是否为空 { int i = 0; for(i=0; i&lt;num; i&#43;&#43;) { *(ptr&#43;i) = 0； } } free(ptr);//释放ptr所指向的动态内存 ptr = NULL;//有必要 return 0; } calloc： 原型： void* calloc (size_t num, size_t size); 函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。 与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。 realloc： realloc函数的出现让动态内存管理更加灵活。 有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候内存，我 们一定会对内存的大小做灵活的调整。那 realloc 函数就可以做到对动态开辟内存大小的调整。 原型： void* realloc (void* ptr, size_t size); ptr 是要调整的内存地址 size 调整之后新大小 返回值为调整之后的内存起始位置。 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。 realloc在调整内存空间的是存在两种情况： 情况1：原有空间之后有足够大的空间" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5e3b516595f58c37ed42f16e6664d669/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-06T00:03:21+08:00" />
<meta property="article:modified_time" content="2019-07-06T00:03:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">1.动态内存开辟  malloc  calloc  realloc  free  函数 2.动态存储通讯录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#f33b45;">malloc：</span></h2> 
<pre class="has"><code>void* malloc (size_t size);</code></pre> 
<h4><span style="color:#3399ea;">这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。</span><br>如果开辟成功，则返回一个指向开辟好空间的指针。 如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。 返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。 如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。</h4> 
<h2><span style="color:#f33b45;">free：</span></h2> 
<h4><span style="color:#3399ea;">free函数用来释放动态开辟的内存。</span></h4> 
<h4>如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。 如果参数 ptr 是NULL指针，则函数什么事都不做。<br><span style="color:#3399ea;">malloc和free都声明在 stdlib.h 头文件中。</span></h4> 
<pre class="has"><code>#include &lt;stdio.h&gt;
int main() 
{    
    //代码1    
    int num = 0;    
    scanf("%d", &amp;num);    
    int arr[num] = {0};
    //代码2    
    int* ptr = NULL;
    ptr = (int*)malloc(num*sizeof(int));
    if(NULL != ptr)//判断ptr指针是否为空
    {        
        int i = 0; 
       for(i=0; i&lt;num; i++)    
        {        
        *(ptr+i) = 0；    
        }  
    }   
    free(ptr);//释放ptr所指向的动态内存  
    ptr = NULL;//有必要  
    return 0; 
}</code></pre> 
<h2><span style="color:#f33b45;">calloc：</span></h2> 
<h4>原型：</h4> 
<pre class="has"><code>void* calloc (size_t num, size_t size);</code></pre> 
<h4>函数的功能是为 num 个大小为 size 的元素开辟一块空间，<span style="color:#f33b45;">并且把空间的每个字节初始化为0。</span> 与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。 </h4> 
<h2><span style="color:#f33b45;">realloc：</span></h2> 
<h4>realloc函数的出现让动态内存管理更加灵活。 </h4> 
<h4>有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候内存，我 们一定会对内存的大小做灵活的调整。那 realloc 函数就可以做到对动态开辟内存大小的调整。 </h4> 
<h4>原型：</h4> 
<pre class="has"><code>void* realloc (void* ptr, size_t size);</code></pre> 
<h4>ptr 是要调整的内存地址</h4> 
<h4>size 调整之后新大小 </h4> 
<h4>返回值为调整之后的内存起始位置。 </h4> 
<h4>这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。</h4> 
<h4>realloc在调整内存空间的是存在两种情况：</h4> 
<h4>情况1：原有空间之后有足够大的空间<br><br> 情况2：原有空间之后没有足够大的空间</h4> 
<p><img alt="" class="has" height="130" src="https://images2.imgbox.com/e9/80/veplnVCA_o.png" width="249"></p> 
<pre class="has"><code>#include &lt;stdio.h&gt;
int main()
{   
    int *ptr = malloc(100);   
    if(ptr != NULL)  
    {       
         //业务处理  
    }    
    else  
    {        
         exit(EXIT_FAILURE);    
    }  
    //扩展容量   
    //代码1   
    ptr = realloc(ptr, 1000);//这样不可以(如果申请失败将会造成内存泄漏)    
    //代码2    
    int*p = NULL;    
    p = realloc(ptr, 1000);   
   if(p != NULL)  //申请成功
   {      
       ptr = p;  
   }   
    //业务处理    
    free(ptr);   
    return 0; 
} 
</code></pre> 
<h2><span style="color:#f33b45;">2.动态存储通讯录</span></h2> 
<pre class="has"><code>#define _CRT_SECURE_NO_WARNINGS 1
#ifndef __CONTACT_H__
#define __CONTACT_H__
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
enum OP
{
EXIT,
ADD,
DEL,
MODIFY,
SEARCH,
DISPLAY,
SORT,
CLEAR
};
#define NAME_MAX 20
#define SEX_MAX 5
#define TELE_MAX 12
#define ADDR_MAX 25
#define MAX 1000
#define MAX_INIT 2
#define MAX_RISE 2
typedef struct PerInfo
{
char name[NAME_MAX];
int age;
char sex[SEX_MAX];
char tele[TELE_MAX];
char addr[ADDR_MAX];
}PeoInfo;
typedef struct Contact
{
PeoInfo data[MAX];
int size;
int i;
}Contact,*Pcon;
void init_contact(Pcon pcon);
void _add_contact(Pcon pcon);
void _display_contact(Pcon pcon);
void _del_contact(Pcon pcon);
void _search_contact(Pcon pcon);
void _modify_contact(Pcon pcon);
void _sort_contact(Pcon pcon);
void _clear_contact(Pcon pcon);
#endif //__CONTACT_H__</code></pre> 
<pre class="has"><code>#define _CRT_SECURE_NO_WARNINGS 1
#include "Contact.h"
void init_contact(Pcon pcon)
{
//memset(pcon-&gt;data, 0, MAX*sizeof(PeoInfo));
//pcon-&gt;size = 0;
pcon-&gt;data=(PerInfo *)malloc(MAX_INIT*sizeof(PerInfo));  
    if(pcon-&gt;data == NULL)  
    {  
        printf("out of menory");  
        exit(EXIT_FAILURE);  
    }  
    pcon-&gt;size=0;  
    pcon-&gt;capacity=MAX_INIT;  
}
void _add_contact(Pcon pcon)
{
/*if(pcon-&gt;size &gt;= MAX)
{
printf("电话本满了\n");
return;
}*/
if(pcon-&gt;size &gt;= pcon-&gt;i)  
    {  
        PerInfo *tmp=(PerInfo *)realloc(pcon-&gt;data,(pcon-&gt;i+MAX_RISE)*sizeof(PerInfo));    
        //当实际联系人个数和初始化的容量相等时用realloc增容  
        if(tmp == NULL)  
        {  
            printf("out of menory\n");  
            exit(EXIT_FAILURE);  
        }  
        else  
        {  
            pcon-&gt;data=tmp;  
            pcon-&gt;capacity+=MAX_RISE;  
        }  
printf("请输入名字：&gt;");
scanf("%s",pcon-&gt;data[pcon-&gt;size].name);
printf("请输入年龄：&gt;");
scanf("%d",&amp;(pcon-&gt;data[pcon-&gt;size].age));
printf("请输入性别：&gt;");
scanf("%s",pcon-&gt;data[pcon-&gt;size].sex);
printf("请输入电话：&gt;");
scanf("%s",pcon-&gt;data[pcon-&gt;size].tele);
printf("请输入地址：&gt;");
scanf("%s",pcon-&gt;data[pcon-&gt;size].addr);
pcon-&gt;size++;
printf("添加成功\n");
}
void _display_contact(Pcon pcon)
{
int i = 0;
printf("%9s\t%3s\t%4s\t%11s\t%10s\n","name","age","sex","tele","addr");
for(i = 0;i&lt;pcon-&gt;size;i++)
{
printf("%9s\t%3d\t%4s\t%11s\t%10s\n",
pcon-&gt;data[i].name,
pcon-&gt;data[i].age,
pcon-&gt;data[i].sex,
pcon-&gt;data[i].tele,
pcon-&gt;data[i].addr);
}
}
static int find_entry(Pcon pcon, char *name)
{
int i = 0;
for(i = 0;i&lt;pcon-&gt;size; i++)
{
if(strcmp(pcon-&gt;data[i].name,name) == 0)
{
return i;
}
}
return -1;
}
void _del_contact(Pcon pcon)
{
int pos = 0;
int index = 0;
char name[NAME_MAX];
if(pcon-&gt;size == 0)
{
printf("电话本空\n");
return;
}
printf("请输入要删除人的名字:&gt;");
scanf("%s",name);
pos = find_entry(pcon, name);
if(pos == -1)
{
printf("找不到要删除的人\n");
return;
}
//
for(index = pos; index &lt; pcon-&gt;size; index++)
{
pcon-&gt;data[index] = pcon-&gt;data[index+1];
}
pcon-&gt;size--;
printf("删除成功\n");
}
void _search_contact(Pcon pcon)
{
char  name[NAME_MAX] = {0};
int pos = 0;
printf("请输入要查找人的名字:&gt;");
scanf("%s",name);
pos = find_entry(pcon, name);
if(pos == -1)
{
printf("指定联系人不存在\n");
return;
}
else
{
printf("%9s\t%3s\t%4s\t%11s\t%10s\n","name","age","sex","tele","addr");
printf("%9s\t%3d\t%4s\t%11s\t%10s\n",
pcon-&gt;data[pos].name,
pcon-&gt;data[pos].age,
pcon-&gt;data[pos].sex,
pcon-&gt;data[pos].tele,
pcon-&gt;data[pos].addr);
}
}
void _modify_contact(Pcon pcon)
{
char  name[NAME_MAX] = {0};
int pos = 0;
printf("请输入要修改人的名字:&gt;");
scanf("%s",name);
pos = find_entry(pcon, name);
if(pos == -1)
{
printf("指定联系人不存在\n");
return;
}
else
{
printf("请输入名字：&gt;");
scanf("%s",pcon-&gt;data[pos].name);
printf("请输入年龄：&gt;");
scanf("%d",&amp;(pcon-&gt;data[pos].age));
printf("请输入性别：&gt;");
scanf("%s",pcon-&gt;data[pos].sex);
printf("请输入电话：&gt;");
scanf("%s",pcon-&gt;data[pos].tele);
printf("请输入地址：&gt;");
scanf("%s",pcon-&gt;data[pos].addr);
}
}
//volatile
void _sort_contact(Pcon pcon)
{
int i = 0;
int j = 0;
for(i = 0;i&lt;pcon-&gt;size-1; i++)//控制排序趟数
{
for(j = 0; j&lt;pcon-&gt;size-1-i; j++)
{
if(strcmp(pcon-&gt;data[j].name,pcon-&gt;data[j+1].name) &gt; 0)
{
PeoInfo tmp = {0};
tmp = pcon-&gt;data[j];
pcon-&gt;data[j] = pcon-&gt;data[j+1];
pcon-&gt;data[j+1] = tmp;
}
}
}
}
void _clear_contact(Pcon pcon)
{
pcon-&gt;size = 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/61192bbe85fffb4e884fb7b66933b8b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">扑克排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/20c8652c33da3e127f53b9fe193fd2a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpeedFan 控制风扇转速</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>