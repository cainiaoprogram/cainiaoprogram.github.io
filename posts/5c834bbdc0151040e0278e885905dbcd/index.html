<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库中间件介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库中间件介绍" />
<meta property="og:description" content=" 文章目录 什么是数据库中间件？Smart-client 模式优点缺点 Proxy 模式优点缺点 单元化架构优点缺点 总结 数据库中间件是连接数据库和应用程序之间的软件层，用于简化数据库管理、提高性能和可伸缩性，同时提供额外的功能和服务。在分布式系统和大规模应用中，数据库中间件发挥着重要的作用。 什么是数据库中间件？ 数据库中间件是一种介于数据库系统和应用程序之间的软件层。它充当了一个抽象层，屏蔽了底层数据库的细节，为应用程序提供了更简化的接口。数据库中间件的主要目标是提供更高的性能、可用性、可扩展性，并简化数据库管理。
典型的数据库中间件设计方案有3种：proxy、smart-client、单元化架构
Smart-client 模式 通过独立的逻辑层建立数据分片和路由规则，实现单体数据库的初步管理，使应用能够对接多个单体数据库，实现并发、存储能力的扩展。其作为应用系统的一部分，对业务侵入比较深。这种客户端组件的典型产品是 Sharding-JDBC。
优点 实现简单。大多数据数据库厂商已经针对不同的语言提供了相应的数据库驱动driver，例如mysql针对java语言提供了mysql-connector-java驱动，针对python提供了mysql-connector-python驱动，客户端的通信协议已经在driver层面做过了。因此smart-client模式的中间件，通常只需要在此基础上进行封装即可。
天然去中心化。smart-client的方式，由于本身以sdk的方式，被应用直接引入，随着应用部署到不同的节点上，且直连数据库，中间不需要有代理层。因此除了网络资源之外，基本上不存在任何其他资源的竞争，也不需要考虑高可用的问题。只要应用的节点没有全部宕机，就可以访问数据库。
缺点 通常仅支持某一种语言。例如tddl、zebra、sharding-jdbc都是使用java语言开发，因此对于使用其他语言的用户，就无法使用这些中间件。如果其他语言要使用，那么就要开发多语言客户端。
版本升级困难。因为应用使用数据源代理就是引入一个jar包的依赖，在有多个应用都对某个版本的jar包产生依赖时，一旦这个版本有bug，所有的应用都需要升级。而数据库代理升级则相对容易，因为服务是单独部署的，只要升级这个代理服务器，所有连接到这个代理的应用自然也就相当于都升级了。
Proxy 模式 以独立中间件的方式，管理数据规则和路由规则，以独立进程存在，与业务应用层和单体数据库相隔离，减少了对应用的影响。随着代理中间件的发展，还会衍生出部分分布式事务处理能力。这种中间件的典型产品是 MyCat。
优点 多语言支持。不论你用的php、java或是其他语言，都可以支持。以mysql数据库为例，如果proxy本身实现了mysql的通信协议，那么你可以就将其看成一个mysql 服务器。mysql官方团队为不同语言提供了不同的客户端驱动，如java语言的mysql-connector-java，python语言的mysql-connector-python等等。因此不同语言的开发者都可以使用mysql官方提供的对应的驱动来与这个代理服务器建通信。
对业务开发同学透明。由于可以把proxy当成mysql服务器，理论上业务同学不需要进行太多代码改造，既可以完成接入。
缺点 实现复杂。因为proxy需要实现被代理的数据库server端的通信协议，实现难度较大。通常我们看到一些proxy模式的数据库中间件，实际上只能代理某一种数据库，如mysql。几乎没有数据库中间件，可以同时代理多种数据库(sqlserver、PostgreSQL、Oracle)。
proxy本身需要保证高可用。由于应用本来是直接访问数据库，现在改成了访问proxy，意味着proxy必须保证高可用。否则，proxy挂了，导致数据库无法正常访问，就尴尬了。
租户隔离。可能有多个应用访问proxy代理的底层数据库，必然会对proxy自身的内存、网络、cpu等产生资源竞争，proxy需要需要具备隔离的能力。
单元化架构 单元化架构是对业务应用系统的彻底重构，应用系统被拆分成若干实例，配置独立的单体数据库，让每个实例管理一定范围的数据。例如对于外卖系统，可以为每个城市搭建独立的应用实例，管理各自的数据。当出现跨城市业务时，通过迁移用户信息进行下单。
优点 灵活扩展。单元化架构通过统一的切分规则，将应用层和数据层进行立体拆分，无论是弹性扩缩容场景，还是多地多中心场景，都可以根据数据中心容量自由划分逻辑“切片”的多少。
网络耗时低，链路稳定性高。单元化架构通过“单元”，将逻辑调用和数据访问在“单元”内形成闭环，只有少数特定场景的调用会跨单元访问，这样几乎大部分的请求在地域内就可以返回，极大程度地减少了访问耗时，避免了跨异地访问链路拥堵造成的服务夯死，提高了链路稳定性。重要的是单元带来的显著的故障隔离效果，链路的可观测性方面也得到了明显改善，即从链路访问层面屏蔽了跨地域访问所带来的上述问题。
缺点 复杂的调度管理。首先需要确定一个统一的单元化规则中心，用于存储和下发单元化规则。实现方式可以是自身实现单元化规则服务，也可以借助注册配置中心，或者两者共存。单元化规则启用后很难再进行更改，所以在选择单元化切片的切分维度时需要慎重。
改造成本高。单元化需要从全局视角思考基础设施改造，建设意味着现在或未来需要买更多的机器、建更多的机房、搭更多的框架平台做支撑，以及架构升级过程中带来的各种各样的问题，这就需要更多的钱、人、时间。
风险高。单元化改造的参与者众多、落地时间周期长、业务影响面大，比如架构师需要重新做架构设计、研发人员需要针对单元化做适配开发、运维人员需要采购和部署、测试人员需要全量回归所有业务等等，其中某一环出现问题就可能造成延期或者埋下隐患。
总结 方式优点缺点Proxy 模式1.多语言支持
2.对业务开发透明1.实现复杂 2.Proxy 需要保证高可用 3.租户隔离需要考虑Smart-client 模式1.实现简单，易于使用
2.天然去中心化1.通常仅支持某一种语言
2.版本升级困难单元化1.灵活扩展
2.网络耗时低，链路稳定性高1.需要复杂的管理和调度
2.改造成本高3.风险大 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5c834bbdc0151040e0278e885905dbcd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-24T19:17:57+08:00" />
<meta property="article:modified_time" content="2023-12-24T19:17:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库中间件介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">什么是数据库中间件？</a></li><li><a href="#Smartclient__5" rel="nofollow">Smart-client 模式</a></li><li><ul><li><a href="#_9" rel="nofollow">优点</a></li><li><a href="#_18" rel="nofollow">缺点</a></li></ul> 
  </li><li><a href="#Proxy__23" rel="nofollow">Proxy 模式</a></li><li><ul><li><a href="#_27" rel="nofollow">优点</a></li><li><a href="#_32" rel="nofollow">缺点</a></li></ul> 
  </li><li><a href="#_38" rel="nofollow">单元化架构</a></li><li><ul><li><a href="#_42" rel="nofollow">优点</a></li><li><a href="#_47" rel="nofollow">缺点</a></li></ul> 
  </li><li><a href="#_53" rel="nofollow">总结</a></li></ul> 
</div> 
<br> 数据库中间件是连接数据库和应用程序之间的软件层，用于简化数据库管理、提高性能和可伸缩性，同时提供额外的功能和服务。在分布式系统和大规模应用中，数据库中间件发挥着重要的作用。 
<p></p> 
<h2><a id="_2"></a>什么是数据库中间件？</h2> 
<p>数据库中间件是一种介于数据库系统和应用程序之间的软件层。它充当了一个抽象层，屏蔽了底层数据库的细节，为应用程序提供了更简化的接口。数据库中间件的主要目标是提供更高的性能、可用性、可扩展性，并简化数据库管理。<br> 典型的数据库中间件设计方案有3种：proxy、smart-client、单元化架构</p> 
<h2><a id="Smartclient__5"></a>Smart-client 模式</h2> 
<p>通过独立的逻辑层建立数据分片和路由规则，实现单体数据库的初步管理，使应用能够对接多个单体数据库，实现并发、存储能力的扩展。其作为应用系统的一部分，对业务侵入比较深。这种客户端组件的典型产品是 Sharding-JDBC。<br> <img src="https://images2.imgbox.com/20/89/mDWladem_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_9"></a>优点</h3> 
<p>实现简单。大多数据数据库厂商已经针对不同的语言提供了相应的数据库驱动driver，例如mysql针对java语言提供了mysql-connector-java驱动，针对python提供了mysql-connector-python驱动，客户端的通信协议已经在driver层面做过了。因此smart-client模式的中间件，通常只需要在此基础上进行封装即可。</p> 
<p>天然去中心化。smart-client的方式，由于本身以sdk的方式，被应用直接引入，随着应用部署到不同的节点上，且直连数据库，中间不需要有代理层。因此除了网络资源之外，基本上不存在任何其他资源的竞争，也不需要考虑高可用的问题。只要应用的节点没有全部宕机，就可以访问数据库。</p> 
<h3><a id="_18"></a>缺点</h3> 
<p>通常仅支持某一种语言。例如tddl、zebra、sharding-jdbc都是使用java语言开发，因此对于使用其他语言的用户，就无法使用这些中间件。如果其他语言要使用，那么就要开发多语言客户端。<br> 版本升级困难。因为应用使用数据源代理就是引入一个jar包的依赖，在有多个应用都对某个版本的jar包产生依赖时，一旦这个版本有bug，所有的应用都需要升级。而数据库代理升级则相对容易，因为服务是单独部署的，只要升级这个代理服务器，所有连接到这个代理的应用自然也就相当于都升级了。</p> 
<h2><a id="Proxy__23"></a>Proxy 模式</h2> 
<p>以独立中间件的方式，管理数据规则和路由规则，以独立进程存在，与业务应用层和单体数据库相隔离，减少了对应用的影响。随着代理中间件的发展，还会衍生出部分分布式事务处理能力。这种中间件的典型产品是 MyCat。<br> <img src="https://images2.imgbox.com/96/2f/mZmRHPVM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_27"></a>优点</h3> 
<p>多语言支持。不论你用的php、java或是其他语言，都可以支持。以mysql数据库为例，如果proxy本身实现了mysql的通信协议，那么你可以就将其看成一个mysql 服务器。mysql官方团队为不同语言提供了不同的客户端驱动，如java语言的mysql-connector-java，python语言的mysql-connector-python等等。因此不同语言的开发者都可以使用mysql官方提供的对应的驱动来与这个代理服务器建通信。<br> 对业务开发同学透明。由于可以把proxy当成mysql服务器，理论上业务同学不需要进行太多代码改造，既可以完成接入。</p> 
<h3><a id="_32"></a>缺点</h3> 
<p>实现复杂。因为proxy需要实现被代理的数据库server端的通信协议，实现难度较大。通常我们看到一些proxy模式的数据库中间件，实际上只能代理某一种数据库，如mysql。几乎没有数据库中间件，可以同时代理多种数据库(sqlserver、PostgreSQL、Oracle)。<br> proxy本身需要保证高可用。由于应用本来是直接访问数据库，现在改成了访问proxy，意味着proxy必须保证高可用。否则，proxy挂了，导致数据库无法正常访问，就尴尬了。<br> 租户隔离。可能有多个应用访问proxy代理的底层数据库，必然会对proxy自身的内存、网络、cpu等产生资源竞争，proxy需要需要具备隔离的能力。</p> 
<h2><a id="_38"></a>单元化架构</h2> 
<p>单元化架构是对业务应用系统的彻底重构，应用系统被拆分成若干实例，配置独立的单体数据库，让每个实例管理一定范围的数据。例如对于外卖系统，可以为每个城市搭建独立的应用实例，管理各自的数据。当出现跨城市业务时，通过迁移用户信息进行下单。<br> <img src="https://images2.imgbox.com/ff/9c/T5PfilDz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_42"></a>优点</h3> 
<p>灵活扩展。单元化架构通过统一的切分规则，将应用层和数据层进行立体拆分，无论是弹性扩缩容场景，还是多地多中心场景，都可以根据数据中心容量自由划分逻辑“切片”的多少。<br> 网络耗时低，链路稳定性高。单元化架构通过“单元”，将逻辑调用和数据访问在“单元”内形成闭环，只有少数特定场景的调用会跨单元访问，这样几乎大部分的请求在地域内就可以返回，极大程度地减少了访问耗时，避免了跨异地访问链路拥堵造成的服务夯死，提高了链路稳定性。重要的是单元带来的显著的故障隔离效果，链路的可观测性方面也得到了明显改善，即从链路访问层面屏蔽了跨地域访问所带来的上述问题。</p> 
<h3><a id="_47"></a>缺点</h3> 
<p>复杂的调度管理。首先需要确定一个统一的单元化规则中心，用于存储和下发单元化规则。实现方式可以是自身实现单元化规则服务，也可以借助注册配置中心，或者两者共存。单元化规则启用后很难再进行更改，所以在选择单元化切片的切分维度时需要慎重。<br> 改造成本高。单元化需要从全局视角思考基础设施改造，建设意味着现在或未来需要买更多的机器、建更多的机房、搭更多的框架平台做支撑，以及架构升级过程中带来的各种各样的问题，这就需要更多的钱、人、时间。<br> 风险高。单元化改造的参与者众多、落地时间周期长、业务影响面大，比如架构师需要重新做架构设计、研发人员需要针对单元化做适配开发、运维人员需要采购和部署、测试人员需要全量回归所有业务等等，其中某一环出现问题就可能造成延期或者埋下隐患。</p> 
<h2><a id="_53"></a>总结</h2> 
<table><thead><tr><th align="left">方式</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">Proxy 模式</td><td align="left">1.多语言支持<br>2.对业务开发透明</td><td align="left">1.实现复杂 <br>2.Proxy 需要保证高可用 <br>3.租户隔离需要考虑</td></tr><tr><td align="left">Smart-client 模式</td><td align="left">1.实现简单，易于使用<br>2.天然去中心化</td><td align="left">1.通常仅支持某一种语言<br>2.版本升级困难</td></tr><tr><td align="left">单元化</td><td align="left">1.灵活扩展<br>2.网络耗时低，链路稳定性高</td><td align="left">1.需要复杂的管理和调度<br>2.改造成本高3.风险大</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/482f8dbd19a4ee1fd7f7fefde78af7d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2023年第6届传智杯省赛第二场复赛 解题报告 | 珂学家</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3920f90e7bab519ab35360a686bb4540/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">四. 基于环视Camera的BEV感知算法-BEVDepth</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>