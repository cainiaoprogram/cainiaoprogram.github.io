<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【IAR 】MSP430 IAR 编译报错：error - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【IAR 】MSP430 IAR 编译报错：error" />
<meta property="og:description" content="关于转载的说明：原文内容可能会不断更新，要想得到最新的内容请跳到到原文看。
无编号警告类型：
1、Sat Jun 23, 2012 17:41:05: The stack pointer for stack &#39;Stack&#39; (currently Memory:0xF5336) is
原因：新浪博客
IAR相关设置：Tools-&gt;Option-&gt;Stack-&gt;Warn when stack pointer is out of bounds.
The stack pointer for stack is outside the stack range
( 2012-06-24 20:36:38)
1、
Debugging using IAR Embedded Workbench
Because the IAR debugger is not presently aware of Micrium’s μC/OS-III operating system, the
following error may be reported when the debugger is halted:
Mon Sep 20 16:24:14 2010: The stack pointer for stack &#39;CSTACK&#39; (currently" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/92a2ccf3063f904ed85c4fc81c261b5c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-04T01:31:00+08:00" />
<meta property="article:modified_time" content="2022-10-04T01:31:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【IAR 】MSP430 IAR 编译报错：error</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="font-size: 16px;"> 
 <div id="sina_keyword_ad_area2"> 
  <p><strong>关于转载的说明：原文内容可能会不断更新，要想得到最新的内容请跳到到原文看。</strong></p> 
  <p><strong>无编号警告类型：</strong></p> 
  <p>1、Sat Jun 23, 2012 17:41:05: The stack pointer for stack 'Stack' (currently Memory:0xF5336) is<br> 原因：<a href="http://blog.sina.com.cn/s/blog_4c0cb1c0010153l9.html" rel="noopener" title="新浪博客">新浪博客</a></p> 
  <p>IAR相关设置：Tools-&gt;Option-&gt;Stack-&gt;Warn when stack pointer is out of bounds.</p> 
  <p id="articleContentId"><strong>The stack pointer for stack is outside the stack range</strong></p> 
  <p>( 2012-06-24 20:36:38)</p> 
  <p>1、</p> 
  <p>Debugging using IAR Embedded Workbench</p> 
  <p><br> Because the IAR debugger is not presently aware of Micrium’s μC/OS-III operating system, the<br> following error may be reported when the debugger is halted:<br> Mon Sep 20 16:24:14 2010: The stack pointer for stack 'CSTACK' (currently<br> 0x200023D8) is outside the stack range (0x20000000 to 0x20000400)<br> Ignore this error message as it does not affect debugging.</p> 
  <p>原文：http://www.ti.com/lit/ug/spmu164a/spmu164a.pdf</p> 
  <p>outside the stack range (Memory:0x5400 to Memory:0x5C00)</p> 
  <p>2、</p> 
  <p>在使用iar for msp430调试msp430f247的时候，在仿真过程中出现上述的warnning，觉得很奇怪。因为我只是跳入一个子程序而已，不应该占用这么多的堆栈空间。被调用的子程序开头如下：<br> void spitest()<br> {<!-- --><br>     unsigned char firstdata[128];<br>     unsigned char seconddata[128];<br>     unsigned char i;<br>     Led_Init();<br>     Led_On();<br>     Led_Off();<br>     .........<br> }<br>     仔细查看该段代码对应的汇编，如下：<br> spitest:<br>     0081E8    8031 0100        sub.w    #0x100,SP<br>     0081EC    12B0 871C        call    #Led_Init<br>     0081F0    12B0 8716        call    #Led_On<br>     0081F4    12B0 8710       call    #Led_Off<br>     .........<br> 总结：出现该warrning的是编译器的原因，编译器优化初始化数组的方法为占用堆栈，即汇编中的代码“sub.w #100,SP ” ，占用的实在太多，所有导致warrning。同时注意到当spitest子程序跑完后，sp指针会重新恢复正常，所有这个仿真警告是不影响正常程序的。</p> 
  <p>2、无法查看结构体/共同体/联合体 变量[Syntax error, unexpected $end, expecting COLON2] column 1</p> 
  <p>  struct drpoint<br>   {<!-- --><br>      uint16 x;<br>      uint16 y; <br>   }drpoint[10];</p> 
  <p>改成：</p> 
  <p>  struct  </p> 
  <p>  {<!-- --><br>      uint16 x;<br>      uint16 y; <br>   }drpoint[10];</p> 
  <p>参考：<a href="http://tech.groups.yahoo.com/group/lpc2000/messages/34213?threaded=1&amp;m=e&amp;var=1&amp;tidx=1" rel="noopener" title="http://tech.groups.yahoo.com/group/lpc2000/messages/34213?threaded=1&amp;m=e&amp;var=1&amp;tidx=1">http://tech.groups.yahoo.com/group/lpc2000/messages/34213?threaded=1&amp;m=e&amp;var=1&amp;tidx=1</a></p> 
  <p>UESTC 2012.12</p> 
  <p>IAR 各版本BUG错误修正历史：<a rel="noopener">ftp://efo-6.ip.peterstar.net/pub/efo-ftp/TMP/pub/atmel/_AVR32_MCUs_32bit/Compilers/IAR/IAR_2.20/Install software/EWAVR32-KS-CD-220A/doc/common/doc/CorrectedProblems.pdf</a></p> 
  <p><strong>有编号警告类型：</strong></p> 
  <p>Error[e16]: Segment XDATA_Z (size: 0x19a1 align: 0) is too long for segment definition. At least 0xe4c more bytes needed. The problem occurred while processing the segment placement command<br> "-Z(XDATA)XDATA_N,XDATA_Z,XDATA_I=_XDATA_START-_XDATA_END", where at the moment of placement the available memory ranges were "XDATA:f1ff-fd53"</p> 
  <p>Reserved ranges relevant to this placement:<br> XDATA:f000-f1fe XSTACK<br> XDATA:f1ff-fd53 XDATA_N<br> BIT:0-7 BREG<br> BIT:80-97 SFR_AN<br> BIT:a8-af SFR_AN<br> BIT:b8-c7 SFR_AN<br> BIT:d8-df SFR_AN<br> BIT:e8-ef SFR_AN</p> 
  <p>A：</p> 
  <p>其实这个问题并不是你的程序本身有问题，主要是因为你编写的程序太大了，超出了芯片本身的定义。今天在群里学习了一招，就是将数组定义到code里，我们看一下例子。我们定义一个5100个元素的数组，有以下两种方法：</p> 
  <p>mermaid提出的方法是：</p> 
  <p>typedef unsigned char const __code INT8U;</p> 
  <p>extern INT8U shuzi[5100];</p> 
  <p>文晶提出的方法是</p> 
  <p>INT8U code shuzi[5100];</p> 
  <p>这两种方法其实效果是一致的，定义完数组之后，调用的部分就是需要用指针来调用数组里面的数值了。</p> 
  <table><tbody><tr><td> 
      <div> 
       <p>Error[e16]: Segment DATA16_I (size: 0xa80 align: 0x1) is too long for segment definition. At least 0x27f more bytes needed. The<br> pro××em occurred while processing the segment placement command<br> "-Z(DATA)DATA16_I,DATA16_Z,DATA16_N,HEAP+_HEAP_SIZE=0200-0A00", where at the moment of placement the ××aila××e<br> memory ranges were "CODE:200-A00"</p> 
       <p>经过验证是由于RAM耗尽，程序里估计有很大的数据量，最好使用const定义到FLASH里面，问题基本可以解决。</p> 
      </div> </td></tr></tbody></table> 
  <p>Error[e16]: Segment DATA16_Z (size: 0x6b9 align: 0x1) is too long for segment definition. At least 0x317 more bytes needed. The problem occurred <br> while processing the segment placement command <br> "-Z(DATA)DATA16_I,DATA16_Z,DATA16_N,TLS16_I,DATA16_HEAP+_DATA16_HEAP_SIZE=0200-09FF", where at the moment of placement the <br> available memory ranges were <br> "CODE:5ce-5ff,CODE:602-605,CODE:609-60b,CODE:60d-60d,CODE:60f-61b,CODE:61e-63f,CODE:642-645,CODE:649-64b,CODE:64d-64d,CODE:64<br> f-65b,CODE:65e-9ff"<br>    Reserved ranges relevant to this placement:</p> 
  <p>可能的原因：1、设置的某个数组过大，超过了设置的堆栈。</p> 
  <p>            2、设置的堆栈不够大</p> 
  <p>            3、选择的型号不对(编写的程序是用在RAM较大的一个单片机上的，IAR里选择的却是RAM较小的一个型号)</p> 
  <p>UESTC 2013.3.8 </p> 
  <p>2Q： </p> 
  <p>烧写程序时无法跳入断点<br> 为什么我每次烧程序都出现：The stack plug-in failed to set a breakpoint on "main". The Stack window will not be able to display stack contents. (You can change this setting in the Tool&gt;Options dialog box.)的警告。但是程序能烧进去，只是不能调试。</p> 
  <p>A：</p> 
  <p>确认设置没有问题(和好用的工程相比)这是设置不对,请找下面顺序修改:</p> 
  <p>iar-&gt;options-&gt;linker-&gt;output-&gt;format;<br> 选择 Debug information for c-SPY选项</p> 
  <p>3Q：</p> 
  <p>错误提示：</p> 
  <p>Fatal Error[Cp001]: Copy protecTIon check, No valid license found for this product [20]</p> 
  <p>A：</p> 
  <p>可以将IAR全部安装上，但是在编译文件时却会报这个错，原因是安装的时候没有把注册机的0x.....字串的小写字母改为大写字母。</p> 
  <p>4Q：“Error[e16]: Segment CSTACK (size: 0x50 align: 0x1) is too long for segment definition. At least 0x50 more bytes needed. The problem occurred while processing the segment placement command "-Z(DATA)CSTACK+_STACK_SIZE#", ”</p> 
  <p>A：</p> 
  <p><br> 此错误是所定义的全局变量和数组缓冲区等所占的RAM超出硬件支持所致：size: 0x50为超出的大小。只要减少不不要的全局变量和尽量缩小数组缓冲区就可以了！</p> 
  <p>5Q：</p> 
  <p>7Q:</p> 
  <p><strong>Error[Pe018]:</strong> expected a ")" C:\Documents and Settings\Administrator\桌面\Crane\Crane\塔吊防碰撞系统1.1版(SIM908 倾角查询)\5438A塔吊防碰撞1.1\api_function.h 5</p> 
  <p>1、函数或者语句中有变量名复用：</p> 
  <p>#define length 50                   // 吊臂长度</p> 
  <p>extern int dec_to_bcd(int dec_dat, unsigned char *bcd, int length);</p> 
  <p>将以上的变量名之一换做别的即可解决。</p> 
  <p>UESTC 2012.3.27</p> 
  <p> Error[e27]:(变量没有extern声明外部可调用)  uestc</p> 
  <p><a href="http://blog.sina.com.cn/s/blog_4c0cb1c00100z0w1.html" rel="noopener" title="新浪博客">新浪博客</a><br> Error[e27]: Entry "ER_WARN" in module AD (……) redefined in module FINGERPRINT (……)</p> 
  <p>解决方法是把变量定义在其中一个cpp文件里面，<br> 然后在另一个文件里面用extern来引用。<br> sample:</p> 
  <p>文件一：<br> int a=0;</p> 
  <p>文件二：<br> extern int a;  //此处不能使他等于某个数就可以了,如果此处a再赋值extern int a=0；就会报错e27</p> 
  <p>以为我在x.h文件中定义有变量，然后x.h放入 config.h中，config.h被其他的各个.c文件包含，就造成了，x.h中的变量在各个.c中定义，造成了重复定义。 UESTC 2012.3.27</p> 
  <p>相关问答：</p> 
  <p><a href="http://topic.csdn.net/u/20120222/22/c9b258d3-f58e-49dc-bf97-630271a26dfc.html" rel="noopener" title="http://topic.csdn.net/u/20120222/22/c9b258d3-f58e-49dc-bf97-630271a26dfc.html">http://topic.csdn.net/u/20120222/22/c9b258d3-f58e-49dc-bf97-630271a26dfc.html</a></p> 
  <p>14Q：Error[e46]:</p> 
  <p>   Undefined external "__program_start" referred in ?ABS_ENTRY_MOD ( )</p> 
  <p>A：该问题应该是IAR设置问题，具体设置如下：<br> Project-&gt;Option-&gt;Linker-&gt;Config 勾选"Override default program"<br> 再选择"Defined by application"</p> 
  <p> B、 static  (const)变量是不能被外部文件调用的 ( ? )</p> 
  <p> C、只包含了.h文件， .c文件没有添加进工程</p> 
  <p>从debug切换到release出现错误：release不会自动继承debug的设置，需要自己重新设置：</p> 
  <p>snprintf、fmax、fmin这些函数都能在IAR帮助中找到，但是却出现下面错误：</p> 
  <p>Error[e46]: Undefined external "fmax" referred in cacu_protect ( C:\Documents and Settings\Administrator\桌面\塔吊安全监控系统-终版\塔吊安全监控系统-终版\<br> Release\Obj\cacu_protect.r43 )<br> Error[e46]: Undefined external "fmin" referred in cacu_protect ( C:\Documents and Settings\Administrator\桌面\塔吊安全监控系统-终版\塔吊安全监控系统-终版\<br> Release\Obj\cacu_protect.r43 )<br> Error[e46]: Undefined external "snprintf" referred in gprs_8 ( C:\Documents and Settings\Administrator\桌面\塔吊安全监控系统-终版\塔吊安全监控系统-终版\<br> Release\Obj\gprs_8.r43 )<br> Error while running Linker</p> 
  <p>错误原因：链接库的设置不对：</p> 
  <p>Error[Pe077]:</p> 
  <p>this declaration has no storage class or type specifier</p> 
  <div>
       不同的版本，就有不同的写法，就像环境不一样，中断函数的名字也不一样，我遇到过这样的情况(两个不同版本下定时器初始化时寄存器的名称不同). 
  </div> 
  <div>
       如I/O口中断函数的名的两种版本： 
  </div> 
  <div>
     版本1：interrupt[PORT2_VECTOR] void PORT2 (void) 
  </div> 
  <div>
     版本2：#pragma vector=PORT1_VECTOR 
   <br>         __interrupt void PORT1_ISR (void) 
  </div> 
  <p>2012.2.x UESTC</p> 
  <p><br> 8Q：</p> 
  <p>Error[Pe136]:</p> 
  <p>     struct "" has no field "SampleApp_Periodic_DstAddr" D:\Program Files\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Samples\SampleApp\Source\SampleApp.c 417</p> 
  <p><br> //--------------------------------------------//<br> afAddrType_t dstAddr;<br> dstAddr.addrMode = afAddrBroadcast;<br> dstAddr.addr.shortAddr = 0xFFFF; // 广播发送 cdwxl<br> dstAddr.endpoint = SAMPLEAPP_ENDPOINT; //error所在<br> //--------------------------------------------//</p> 
  <p>A：</p> 
  <p><br> 我们看看afAddrType_t这个结构就明白错在哪里了。</p> 
  <p>typedef struct<br> {<!-- --><br> union<br> {<!-- --><br> uint16 shortAddr;<br> } addr;<br> afAddrMode_taddrMode;<br> byteendPoint;<br> } afAddrType_t;</p> 
  <p>居然是 endPoint 大小写错误，Ω 。</p> 
  <p>9Q：</p> 
  <p><br> 我最开始也是IAR仿真时找不到main函数，<br> 显示：<br> Fri Jun 11 14:37:00 2010: Error (col 1): Unknown or ambiguous symbol. main<br> Fri Jun 11 14:37:01 2010: Error (col 1): Unknown or ambiguous symbol. main<br> Fri Jun 11 14:37:01 2010: Couldn't go to 'main'.</p> 
  <p>之后在project＝＝&gt;options＝＝&gt;linker里面的format设成debug，没有这个问题了，但是<br> 程序又不能通过TI的那个Flash Programmer下载到板子里了，说是Could not open specified HEX file</p> 
  <p>A：</p> 
  <p>这个烧录工具只认release code. 而且扩展名必须是.hex。</p> 
  <p>所以要用这个烧录工具来烧录必须做两件事：</p> 
  <p>1. output file设为release version<br> 2. output file 扩展名改为.hex, 默认的是.a51</p> 
  <p>测试学习阶段可以不用.但产品量产就必须生成二进制文件.<br> 同时programmer还有些其它的功能会常用的</p> 
  <p> Error[Pe142]: expression must have pointer-to-object type </p> 
  <p>表达式两边的类型不一样。2012.2.x uestc</p> 
  <p>例如：</p> 
  <p> “编译的错误是指第一个‘*’的后面应该是指针，却给了是非指针表达式。<br> 如果p是个指针，那么*(p+i)是p后面第i个域或单元的元素，这个域与p所指的变量类型有关，<br> 也就是说'*(p+i)+j'是数，而非指针。与*结合就错了。 ”</p> 
  <p><a href="http://www.ourdev.cn/bbs/bbs_content.jsp?bbs_sn=931945" rel="noopener" title="http://www.ourdev.cn/bbs/bbs_content.jsp?bbs_sn=931945">http://www.ourdev.cn/bbs/bbs_content.jsp?bbs_sn=931945</a></p> 
  <p>C++的该错误：</p> 
  <p>http://efreedom.com/Question/1-4943607/Expression-Must-Pointer-Object-Type-Subscript-Requires-Array-Pointer-Type</p> 
  <p>Error[Pe148]:</p> 
  <p>variable "TA1R_OVERFLOW" has already been initialized</p> 
  <p>"unsigned char TA1R_OVERFLOW=0; " 声明可外部调用需要赋值</p> 
  <p>Error[Pe159]: declaration is incompatible with previous</p> 
  <p>  没加头文件，或者主函数内有子函数，而子函数定义在主函数后边而木有在主函数前声明一下。</p> 
  <p><strong>Error[Pe169]: expected a declaration</strong></p> 
  <p>错误原因可能性：</p> 
  <p>1、void read_gprs_return()<strong>;</strong></p> 
  <p>{<!-- --></p> 
  <p>……</p> 
  <p>}</p> 
  <p>定义函数的时候，结尾多了一个分号：；。</p> 
  <p><strong>Error[Pe852]:</strong></p> 
  <p><strong>Error[Pe852]:</strong>expression must be a pointer to a complete object type</p> 
  <p><a href="http://bbs.lierda.com/showthread.php?t=19387" rel="noopener" title="请教关于结构体数组的引用出错">请教关于结构体数组的引用出错</a></p> 
  <div> 
   <div> 
    <div> 
     yanzhongwang 
    </div> 
    <div>
      2006-02-24, 14:30 
    </div> 
   </div> 
   <div>
     定义结构体数组 
    <br> var.c: 
    <br> struct StructDisData 
    <br> { 
    <br> unsigned int AddrDisData; 
    <br> unsigned int TypeDisChar; 
    <br> unsigned int TypeDisUnit; 
    <br> unsigned char LengthDisData; 
    <br> }; 
    <br> const struct StructDisData StrDisData[254]={.....}; 
    <br> var.h: 
    <br> const extern struct StructDisData StrDisData[254]; 
    <br> 在Lunxian.c中引用： 
    <br> #include "var.h" 
    <br> unsigned int vAdd; 
    <br> void Sub1(void) 
    <br> { 
    <br> unsigned int disptr; 
    <br> disptr =...; 
    <br> vAdd =StrDisData[disptr].AddrDisData; //编译时在此处出错 Error[Pe852]: expression must be a pointer to a complete object type 
    <br> } 
    <br> 各位大虾请帮我分析一下 谢谢！ 
   </div> 
  </div> 
  <div> 
   <div> 
    <div>
      erlking 
    </div> 
    <div>
      2006-02-24, 14:41 
    </div> 
   </div> 
   <div>
     改成 
    <br> vAdd =StrDisData[disptr]－&gt;AddrDisData; 
    <br> 试试？ 
   </div> 
  </div> 
  <div> 
   <div> 
    <div>
      yanzhongwang 
    </div> 
    <div>
      2006-02-24, 14:58 
    </div> 
   </div> 
   <div>
     谢谢erking这么快的回复！ 
    <br> 我改了试了一下 还是一样的错误 
    <br> 好像-&gt;是用指针方式调用才用到 
   </div> 
  </div> 
  <div> 
   <div> 
    <div>
      li_hai_tao930 
    </div> 
    <div>
      2006-02-24, 23:19 
    </div> 
   </div> 
   <div>
     声明结构体时用typedef 定义结构类型名试试 
   </div> 
  </div> 
  <div> 
   <div> 
    <div>
      iltgcl 
    </div> 
    <div>
      2006-02-27, 08:36 
    </div> 
   </div> 
   <div>
     将结构定义 
    <br> struct StructDisData 
    <br> { 
    <br> unsigned int AddrDisData; 
    <br> unsigned int TypeDisChar; 
    <br> unsigned int TypeDisUnit; 
    <br> unsigned char LengthDisData; 
    <br> }; 
    <br> 放到头文件中，即.h文件中 
   </div> 
  </div> 
  <div> 
   <div> 
    <div>
      yanzhongwang 
    </div> 
    <div>
      2006-02-27, 10:59 
    </div> 
   </div> 
   <div>
     谢谢楼上的各位！ 
    <br> 用iltgcl的方法试了一下 编译没问题了！ 
   </div> 
  </div> 
  <div> 
   <div> 
    <div>
      yanzhongwang 
    </div> 
    <div>
      2006-02-27, 11:22 
    </div> 
   </div> 
   <div>
     改正后的文件结构如下 
    <br> var.c: 
    <br> var.h: 
    <br> struct StructDisData 
    <br> { 
    <br> unsigned int AddrDisData; 
    <br> unsigned int TypeDisChar; 
    <br> unsigned int TypeDisUnit; 
    <br> unsigned char LengthDisData; 
    <br> }; 
    <br> Lunxian.c： 
    <br> #include "var.h" 
    <br> unsigned int vAdd; 
    <br> const struct StructDisData StrDisData[254]={.....}; 
    <br> void Sub1(void) 
    <br> { 
    <br> unsigned int disptr; 
    <br> disptr =...; 
    <br> vAdd =StrDisData[disptr].AddrDisData;  
    <br> } 
    <br> 再次谢谢各位工程师的热心指点！ 
   </div> 
  </div> 
  <div> 
   <div> 
    <div>
      readyaiming 
    </div> 
    <div>
      2006-03-03, 15:23 
    </div> 
   </div> 
   <div>
     不错不错。 
   </div> 
  </div> 
  <p>Error[Pe260]:</p> 
  <p>   explicit type is missing ("int" assumed) C:\Documents and Settings\Administrator\桌面\下位机\塔吊防碰撞系统1.1版(SIM908 倾角查询)\5438A塔吊防碰撞1.1\LCD(SmallFonts).c 898</p> 
  <p>问题例子1：定义一个函数，落了红字部分声明</p> 
  <p>void DrawSector(int x,int y,int R1,int R2,float Ds ,float De,int fill,uchar color)<br> {<!-- --><br>     ……</p> 
  <p>}</p> 
  <p>11Q：Error[Pe513]:</p> 
  <p>   a value of type "int (*)(uint8, uint8)" cannot be assigned to an entity of type "halUARTCBack_t" D:\Program Files\Texas Instruments\ZStack-1.4.3-1.2.1\Components\stack\sapi\sapi.c 968</p> 
  <p>A：估计是一个函数本没有返回值即void类型，而你却将这个函数赋给了一个int型变量了。。</p> 
  <p>static rxCB( uint8 port,uint8 event )改为<br> static void rxCB( uint8 port,uint8 event )</p> 
  <p>12Q：</p> 
  <p><strong>Fatal Error[e72]:</strong> Segment BANK_RELAYS must be defined in a segment definition option (-Z, -b or -P)</p> 
  <p>A：</p> 
  <p><br> 使用无线龙的串口互发，发现上述错误，原因是版本太高，具体原因不清，下载一下7.20H就可以了</p> 
  <p>Fatal Error[e89]: Too much object code produced (more than 0x1000 bytes) for this package</p> 
  <p>是4K限制版，请使用有非限制版的。</p> 
  <p>IAR常见错误请先从如下几方面入手：</p> 
  <p>1序列号是否正确。</p> 
  <p>2使用版本是否正确，应该使用7.30B打开的工程文件不能使用7.20H打开。</p> 
  <p>       3尽量不要使用中文路径。</p> 
  <p>       4ZigBee协议栈文件夹需要放在IAR安装盘根目录下。</p> 
  <p>       5请确定当前编译文件夹是否具有读写权限。</p> 
  <p>       6使用的版本是否是限制版</p> 
  <p>Fatal Error[Pe005]: could not open source file "stdio.h" 这是什么原因？谢谢了</p> 
  <p>是因为头文件路径不对造成，改正的方法是在设置选项卡的C/C++ Compiler -&gt; Preprocessor选项里，将$TOOLKIT_DIR$\INC\CLIB\添到Include paths中。($TOOLKIT_DIR$指IAR的安装路径，一般用到标准库函数时要将它写入Include paths里面)</p> 
  <p>Fatal Error[Pe005]: could not open source file "hal.h" C:\Users\user\Desktop\例子程序\无线通信综合测试\Library\cc2430\HAL\source\setTimer34Period.c 7</p> 
  <p>先检查 C:\Users\user\Desktop\例子程序\无线通信综合测试\Library\cc2430\HAL\source\有无setTimer34Period.c 这个文件，若有，则是因为IAR对中文路径支持不好的缘故，你把这个工程复制到全英文路径下编译应该就不会报错了。</p> 
  <p>Fatal Error[Pe1696]: cannot open source file "config.h"</p> 
  <p>注意config.h 存放的位置，最好与main同处于一个文件夹</p> 
  <p>15Q：</p> 
  <p>Fatal Error[Cp001]:</p> 
  <p>   Copy protection check, No valid license found for this product [24]<br> XP下装的IAR，到了Win7下出来的问题。</p> 
  <p>A：这个问题是使用注册机带来的，系统换了，本机ID也要改了。</p> 
  <p>、、单击IARID.EXE得到本机的ID号<br> 、、右键点Key.cmd，选择编辑，打开，将ID修改为本机ID<br> 、、运行KEY.cmd，在key.txt中的含有EW8051-EV的序列号就是7.30的序列号</p> 
  <p>16Q：</p> 
  <p>在用iar debug 下载进已有程序板子出现的</p> 
  <p>A：将核心板与扩展板分开，只烧写核心板。</p> 
  <p>17Q：</p> 
  <p><br> ‍<br> A：自小峰关于协议栈XDATA溢出的小结<br> (1)减小程序；</p> 
  <p>(2)把配置文件f8w2430.xcl/f8w2430pm.xcl中的-D_CODE_END改大点：<br> ********************<br> f8w2430.xcl：<br> // CODE<br> //<br> // These settings determine the size/location of the ROOT segment.<br> // Increase _CODE_END to increase ROOT memory, i.e. for constants.<br> -D_CODE_START=0x0000 // Code size = 128k for CC2430-F128<br> -D_CODE_END=0x4000 // Last address for ROOT bank<br> ********************<br> f8w2430pm.xcl：<br> // CODE<br> //<br> // These settings determine the size/location of the ROOT segment.<br> // Increase _CODE_END to increase ROOT memory, i.e. for constants.<br> -D_CODE_START=0x0000 // Code size = 128k for CC2430-F128<br> -D_CODE_END=0x29FF //(原0x28FF) Last address for ROOT bank</p> 
  <p>Warning[Pe001]: last line of file ends without a newline F:\emoTion\IAR\PK升级\CC1110-8\main.c 179<br> A：</p> 
  <p>在使用IAR时常常会弹出类似这样一个警告,其实只要在最后一行多加一个回车就不会再有这个警告了.</p> 
  <p>6Q：</p> 
  <p>在编写一个串口程序时：编译没有错，但MAKE时就出现下面的错误</p> 
  <p>undefined external“UART1_ISR”referred in startup</p> 
  <p>A：</p> 
  <p>串口1中断向量没有定义,实际上是串口1中断向量定义其他名称,而不是UART1_ISR.</p> 
  <p>出现这样的调试IAR错误时：Fatal error: Unknown exception in driver (#E1)，是因为IAR软件没有跟Texas Instruments文件放在同一个系统盘下</p> 
  <p>Warnin[w6]: </p> 
  <p>   Type conflict for external/entry "_A_PORTD", in module _ultrasonic against external/entry in module _ST7920; class/struct/union types have  <br> different numbers of fields/bases </p> 
  <table border="0" cellpadding="6" cellspacing="0"><tbody><tr><td>你看看你的源代码里函数是不是这样写：void XXX(void)<br> 而.h代码里这样声明：void XXX()；<br> .h代码应该这样声明：void XXX(void)；</td></tr><tr><td>　</td></tr></tbody></table> 
  <p>分析：一般Warnin[w6]:问题出在头文件里头，可能有：</p> 
  <p>1、声明了外部变量，但是用到那个函数的.c文件没有包含那个头文件</p> 
  <p>2、源代码函数和.h里声明的函数不一样：.c里 void XXX(void)，头文件中：void XXX()；或者：笔误.hz中  Wight_warn (); .c中： Weight_warn();<br> 3、在.C中定义了，但是没有extern void clean_uart2_rx_buff();声明外部可调用，然后外部调用了它，就有可能出现。 2012.3.26 UESTC</p> 
  <p>Warning[Pe009]: nested comment is not allowed    </p> 
  <p>注释最好不要嵌套<br> 例如注释1后半部*/</p> 
  <p>就是最好不要这样     uestc</p> 
  <div> 
   <div> 
    <div> 
     <p> Warning[Pa082]:</p> 
     <p> undefined behavior: the order of volatile accesses is undefined in this statement</p> 
     <p>运算符两边都是volatile变量的警告</p> 
     <p>这警告有意义.<br> volatile 意思是：易变的。<br> 用volatile修饰的变量一般不直接参与运算(在运算中值可能在变化)，volatile就以为这个变量在运算过程中有可能已经改变了</p> 
     <p><br> 例如：想计算a * b 要这样:</p> 
     <div> 
      <pre><code class="has"> (x * y);
</code> 
     </pre> 
      <div>
        复制代码 
      </div> 
     </div> 
     <p>建议使用另外一个变量参与计算：</p> 
     <div> 
      <pre><code class="has"> xxx * yyy

}
</code> 
     </pre> 
      <div>
        复制代码 
      </div> 
      <div> 
       <strong>Warning[Pe175]: </strong> 
      </div> 
      <div> 
       <div> 
        <div> 
         <p>编译错误：Warning[Pe175]: subscript out of range </p> 
         <p>          原因： 定义了 float value[6] ； 既我们定义的了 value[0]、 value[1]…… value[5]，默认从0开始的，而实际中我们用到了value[6]，越界了。</p> 
        </div> 
       </div> 
      </div> 
      <div> 
       <p>2011年 6月2日 </p> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
  <p> Warning[Pe177]:</p> 
  <p>    function "rxCB" was declared but never referenced D:\Program Files\Texas Instruments\ZStack-1.4.3-1.2.1\Components\stack\sapi\sapi.c 982</p> 
  <p>A：函数虽定义但从未被引用(使用)。如果你需要使用该函数，就需要检查；否则略过。</p> 
  <p>13Q：<br> Fri Jun 11 14:37:00 2010: Error (col 1): Unknown or ambiguous symbol. main<br> Fri Jun 11 14:37:01 2010: Error (col 1): Unknown or ambiguous symbol. main<br> Fri Jun 11 14:37:01 2010: Couldn't go to 'main'.</p> 
  <p>A：project＝＝&gt;options＝＝&gt;linker 看看里面的format是不是设成debug<br> 详见<a href="http://www.feibit.com/bbs/viewthread.php" rel="noopener" title="www.feibit.com/bbs/viewthread.php">www.feibit.com/bbs/viewthread.php</a></p> 
  <p> Warning[Pe186]: pointless comparison of unsigned integer with zero</p> 
  <p>无符号整数不可能小于0的……</p> 
  <p>10Q：Warning[Pe188]:</p> 
  <p>     enumerated type mixed with another type D:\Program Files\Texas Instruments\ZStack-1.4.3\Projects\zstack\Samples\SampleApp\Source\SampleApp.c 206</p> 
  <p>A： SampleApp_Periodic_DstAddr.addrMode = Addr16Bit;//(afAddrMode_t)afAddrGroup;<br> typedef enum<br> {<!-- --><br> afAddrNotPresent = AddrNotPresent,<br> afAddr16Bit = Addr16Bit,<br> afAddrGroup = AddrGroup,<br> afAddrBroadcast = AddrBroadcast<br> } afAddrMode_t;<br> 问题就在于Addr16Bit未加afAddrMode_t这个套子。</p> 
  <p>Warning[Pe1072]: a declaration cannot have a label  </p> 
  <div>
    在switch case:后直接定义变量了 
  </div> 
  <div>
     switch (check_storce_status()) 
   <br>   { 
   <br>   case 0: 
   <br>     break; 
   <br>   case 1: 
  </div> 
  <div>
      
   int fash; 
  </div> 
  <div>
       break; 
  </div> 
  <div>
     case 2: 
  </div> 
  <div>
      break; 
  </div> 
  <div>
    } 
  </div> 
  <div>
    解决方法： 
  </div> 
  <div>
    前后加个括号即可。 
  </div> 
  <div> 
   <div>
      switch (check_storce_status()) 
    <br>   { 
    <br>   case 0: 
    <br>     break; 
    <br>   case 1: 
   </div> 
   <div>
       
    {<!-- --> 
   </div> 
   <div>
         
    int fash; 
   </div> 
   <div>
        break; 
   </div> 
   <div>
       
    } 
   </div> 
   <div> 
    <div>
       case 2: 
    </div> 
    <div>
        break; 
    </div> 
    <div>
       } 
    </div> 
    <div>
       UESTC 2012.3.19 
    </div> 
   </div> 
  </div> 
  <p><strong>Fatal Error[Pe1696]:</strong></p> 
  <p>Fatal Error[Pe1696]: cannot open source file "time.h" C:\Documents and Settings\Administrator\桌面\塔吊安全监控系统-终版\塔吊安全监控系统-终版\config.h 53 <br> searched: "C:\Documents and Settings\Administrator\桌面\塔吊安全监控系统-终版\塔吊安全监控系统-终版\"<br> searched: "C:\Program Files\IAR Systems\Embedded Workbench 6.0 Evaluation_0\430\inc\clib\"<br> searched: "C:\Program Files\IAR Systems\Embedded Workbench 6.0 Evaluation_0\430\inc\"<br> Error while running C/C++ compiler</p> 
  <p>出错原因是编译器在上面列出的路径内的文件夹下面找不到time.h</p> 
  <p>首先确定是不是真的存在这两个头文件(没有就自行下载或者编写吧)。然后可以采取以下两种解决方法：<br> 1、include时写上完整的路径名。如：<br> #include "D:\headers\msp430x14x.h"<br> 2、在编译器的默认头文件路径中添加你自定义的头文件存放路径。一般是你所用的IDE的某项功能，这就看你用的是什么IDe了。</p> 
  <p>3、将头需要的头文件复制到编译器搜索的目录(一般debug能通过，release通不过的时候多是这个原因)：</p> 
  <p>第一步：找头文件所在的地方</p> 
  <p><br> 第二步：复制(另存为)到IAR 搜索的目录：<br> searched: "C:\Program Files\IAR Systems\Embedded Workbench 6.0 Evaluation_0\430\inc\clib\"</p> 
  <p>UESTC 2013.3.11 </p> 
  <p><strong>18.2 编译警告消息<br> 下表列出了编译警告消息</strong></p> 
  <p>编号警告消息建议<br> 0 Macro ‘name’ redefined 宏 ‘name’被<br> 重新定义<br> 用#define 定义的符号被用不同的参数<br> 或形式表重新定义</p> 
  <p><br> 1 Macro formal partameter ‘name’ is<br> never referenced 宏形式参数 ‘name’<br> 被重新定义<br> #define 形式参数从未在参数字符串中<br> 出现</p> 
  <p><br> 2 Macro ‘name’ is already#undef 宏<br> ‘name’被重新定义<br> #undef 被用于不是宏观的符号</p> 
  <p><br> 3 Macro ‘name’ called with empty<br> parameter(s) 用空参数调用宏 ‘name’<br> 用零长度(zero-length)的参数不清调<br> 用在#define 中定义的参数化宏观</p> 
  <p><br> 4 Macro ‘name’ is called recursively;<br> not expanded 宏 ‘name’ 被递归调用<br> 不扩展<br> 递归宏调用使预处理器停止该宏的进一<br> 步扩展</p> 
  <p><br> 5 Undefined symbol ‘name’ in #if or<br> #elif; assumed zero 在#if 或#elif<br> 中未定义的符号 ‘name’;假设为零<br> 在#if 或#elif 表达式中把非宏符号作<br> 为零来处理被认为是错误的编程实践<br> 使用以下两个中任一个#ifdef symbol<br> 或#if defined(symbol)</p> 
  <p><br> 6 Unkown escape seguence ‘\c’ ;assume’<br> c’ 未知的转义序列‘\c’ 假设为’c’<br> 在字符常数中发现反斜杠\ 或字符<br> 文字后随未知的转义字符</p> 
  <p><br> 7 Nested comment found without using<br> the’c’ option 发现嵌套的注释未使用’c’<br> 选项<br> 在注释中发现字符序列<br> 无条件转移或返回在一条或多条语名之<br> 前使得这条或多条语句从来不会被执<br> 行</p> 
  <p>21 Unreachable statement(s) at<br> unreachable label ‘name’ 在未卜先知<br> 被引用的标号‘name’处不能到达的语句<br> 例如<br> Break;<br> Here:<br> I=2;<br> 无条件转移或返回在有标号的一条或多<br> 条语句之前但是标号从未被引用所<br> 以这条或多余语句从来不会被执行</p> 
  <p>22 Non-void function: explicit “return”<br> ; expected 非空函数<br> 显式的 “return”&lt;表达式&gt; 被预期<br> 非空non-void 函数产生隐含返回<br> 这可能是从循环或开关语句中非预期的<br> 退出注意不带default 的开关语句<br> 总是被编译器当作可退出的而不管<br> case 的结构如何</p> 
  <p>23 Undeclared function ‘name’; assumed<br> “extern” “int” 未声明的函数‘name’;<br> 假设为“extern” “int”<br> 对未声明函数的引用导致使用缺省的声<br> 明函数被假设为具有K&amp;R 类型具有<br> 外部存储类别并返回int 整型</p> 
  <p>24 Static memory option converts local<br> “auto” or “register” to “static”(静<br> 态存储器选项把局部 “auto”或<br> “register”转换为 “static”)<br> 用于静态存储器分配的命令行选项使<br> auto 自动和register 寄存器声<br> 明被当作static 静态来处理</p> 
  <p>25 Inconsistent use of K&amp;R functionvarying<br> number of parameters(K&amp;R 函<br> 数的不一致使用-改变了参数的数目)<br> 用改变了的参数类型调用K&amp;R 函数</p> 
  <p>26 Inconsistent use of K&amp;R functionchanging<br> type of parameter K&amp;R 函数<br> 用改变了的参数类型调用K&amp;R 函数<br> MSP430 系列C 编译器编程指南<br> 利尔达电子中国有限公司 TEL 0571-88800000 FAX 0571-88805970 - 116 -<br> 的不一致使用改变了参数的类型<br> 例如<br> myfunc(34);<br> myfunc(34.6);</p> 
  <p>27 Size of “extern” object ‘name’ is<br> unknown 外部对象‘name’的大小未知<br> Extern 外部数组应当用size 声明</p> 
  <p>28 Constant [index] outside array bound<br> 常数[索引]超出数组边界<br> 存在超出已声明数组边界的常数索引</p> 
  <p>29 Hexadecimal escape sequence larger<br> than “char” 十六进制转义序列大于<br> “char”<br> 转义序列被截断以适合于放入char 字<br> 符中</p> 
  <p>30 Attribute ignored 属性被忽略<br> 例子<br> 因为const 常量或volatile 易失<br> 的是对象的属性所以当它们与<br> structure 结构,union 联合或<br> enumeration(枚举)标签定义一起给出<br> 时将被忽略上述定义没有和对象同时<br> 声明而且函数被认为不能返回const<br> 或volatile</p> 
  <p>31 Incompatible parameters of K&amp;R<br> functions K&amp;R 函数的参数不兼容在<br> 下列范围之一使用指针<br> 指向函数的指针可能是间接的或K&amp;R<br> 函数声明具有不兼容的参数类型</p> 
  <p>32 Incompatible numbers parameters of<br> K&amp;R functions(K&amp;R 函数的参数数目不兼<br> 容)在下列范围之一使用指针<br> 指向函数的指针可能是间接的或K&amp;R<br> 函数声明具有不同数目的参数</p> 
  <p>33 Local or formal ‘name’ was never 在函数定义中未使用形式参数或局部变<br> referenced(局部或形式参数‘name’从未被引用)<br> 量对象</p> 
  <p>34 Non-printable character ‘\xhh’ found<br> in literal or character constant 在<br> 文字或字符常数中发现不可打印字符号<br> ‘\xhh’<br> 在字符串文字或字符常数中使用不可打<br> 印non-printable 字符被认为是一<br> 种不好的编程习惯为了得到同样的结<br> 果可使用‘\0xhhh’</p> 
  <p>35 Old-style(K&amp;R) type of function<br> declarator (老式(K&amp;R)类型的函数声明)<br> 发现老式(K&amp;R)函数声明只有正在使<br> 用-gA 选项时才发出这种警告</p> 
  <p>36 Floating point constant out of<br> range(浮点常数超出范围)<br> 浮点值太大或太小以致不能使用目标的<br> 浮点系统来表示</p> 
  <p>37 Illegal float operation :division by<br> zero not allowed(非法浮点运算不允<br> 许除以零)<br> 在常数算术运算时发现除零</p> 
  <p>38 Tag identifier ‘name’ was never<br> defined(从未定义标签识别符‘name’)</p> 
  <p>39 Dummy statement. Optimized away! 发现多余的代码这通常表示用户代码<br> 中打印错误或可能产生于使用有点不太<br> 通用的宏时这不是错误<br> 例如<br> a+b</p> 
  <p>40 Possible bug! “if” statement<br> terminated(可能是缺陷if”语句被中<br> 止)<br> 这通常表示用户代码中的打印错误例<br> 如<br> if (a= =b);<br> {<!-- --><br> }</p> 
  <p>41 Possible bug! Unintialized variable<br> 可能是缺陷未初始化的变量<br> 在初始化之前使用变量变量具有随机<br> 值<br> 例如<br> void func(p1)<br> {<!-- --><br> short a;<br> p1+=a;<br> }</p> 
  <p>42 止消息被废弃</p> 
  <p>43 Possible bug! Integer promotion may<br> cause problems. Use cast to avoid it<br> 可能是缺陷整数提升可能产生问题<br> 使用cast 以避免此问题<br> 例如<br> 整数提升规则指出所有整数运算必须产<br> 生这样的结果当它们具有比int 整<br> 型低的精度时就好像它们是int 整<br> 型一样这有时可能导致未预期的结<br> 果<br> MSP430 系列C 编译器编程指南<br> 利尔达电子中国有限公司 TEL 0571-88800000 FAX 0571-88805970 - 118 -<br> 此例将始终返回1 即使对于数值0xff 也是如此其原因是整数提升首先使变量a<br> 变为0x00ff 然后执行位非bit not<br> 整数提升被许多其他C 编译器所忽略因此当用IAR 系统编译器重新编译已有的程<br> 序时可能产生此警告</p> 
  <p>44 Possible bug! Single ‘=’ instead of ‘=<br> =’used in “if” statement 可能是缺陷<br> 在 “if”语句中用‘= =’ 代替单个‘=’<br> 这通常表示用户代码中的打印错误<br> 例如<br> if (a=1)<br> {<!-- --><br> }</p> 
  <p>45 Redundant expression.<br> Example:multiply with 1. Add with 0(多<br> 余的表达式例如乘以1 加上0)<br> 这可能表示用户代码中的打印错误但<br> 是它也是可能是由case 工具产生的<br> 错误代码的结果</p> 
  <p>46 Possible bug! Strange or faulty<br> expression. Example: division by zero<br> 可能是缺陷奇怪或错误的表达式<br> 例如除以零<br> 这通常表示用户代码中的缺陷</p> 
  <p>47 Unreachable code deleted by the<br> global optimizer 由全局优化删除不<br> 能到达的代码<br> 例如除以零<br> 在用户代码中多余的代码块它可能是<br> bug 缺陷的结果但通常仅是不完<br> 善代码的信号</p> 
  <p>48 Unreachable returns. The function<br> will never return 不能到达的返回<br> 函数将永远不返回<br> 函数将永远不能返回到调用的函数这<br> 可能是程序缺陷的结果但通常当在<br> RTOS 系统中具有永不结束循环时产生</p> 
  <p>49 Unsigned compare always true/false<br> 无符号的比较总是为真/假<br> 这表示用户代码中的缺陷通常的原因<br> 是遗漏了-c 编译器开关<br> 例如<br> for (uc=10; uc&gt;=uc--);<br> {<!-- --><br> }<br> 因为无符号的值永远大于或等于零所<br> 以这是永不结束的循环</p> 
  <p>50 Signed compare always true/false 有<br> 符号的比较总是为真/假<br> 这表示用户代码中的缺陷</p> 
  <p>更多错误信息查看文档：<a href="http://pan.baidu.com/share/link?shareid=247562&amp;uk=3523275049" rel="noopener" title="IAR_编译错误信息表(1).pdf_免费高速下载|百度网盘-分享无限制">IAR_编译错误信息表(1).pdf_免费高速下载|百度网盘-分享无限制</a>：</p> 
  <h4>警告：Wed Sep 21 03:16:21 2011: Fatal error: Failed to initialize device.   Session aborted!</h4> 
  <p>原因分析：将仿真器从单片机上拔下来，然后下载出现的警告一样，所以判断是线路出了问题，线路连接没有问题，所以判断驱动出了问题。</p> 
  <p>将驱动重新安装，重启电脑，正常！</p> 
  <p>(2011.11.19:以上问题有新判断，现在判断为线路插口接触不好所致。</p> 
  <p>注意：重新编译的时候，请将记录有错误记忆的“Debug”文件夹删除掉。</p> 
  <p>2011.11.19：</p> 
  <h4><strong>Warning[w6]:</strong> Type conflict for external/entry "MyDangerStatus", in module TurnSendCode against external/entry in module UART0; prototyped function </h4> 
  <p>你看看你的源代码里函数是不是这样写：void XXX(void)<br> 而.h代码里这样声明：void XXX()；<br> .h代码应该这样声明：void XXX(void)；</p> 
  <h4>Error[e16]: Segment INTVEC 错误</h4> 
  <p> Error[e16]: Segment INTVEC (size: 0xec align: 0x2) is too long for segment definition. At least 0xac more bytes needed.  <br> The problem occurred while processing the segment placement command "-Z(CODE)INTVEC=00-3F", where at the  <br> moment of placement the available memory ranges were "CODE:0-3f"<br>    Reserved ranges relevant to this placement:<br>    0-3f                 INTVEC<br> Total number of errors: 1<br> Total number of warnings: 1</p> 
  <p>错误原因：系统包含的文件和工程设置不一致。一个是默认的MSP430 149 一个是MSP430 5438。</p> 
  <p>解决办法：将工程设置按相应的硬件设置。</p> 
  <p>参考：<a href="http://www.stmfans.com/bbs/viewthread.php?tid=1031&amp;extra=page=1" rel="noopener" title="StmFans.com is for sale | HugeDomains">StmFans.com is for sale | HugeDomains</a></p> 
  <h4>Warning[Pe550]: variable " " was set but never used </h4> 
  <p> IAR编译器一个警告信息-Warning[Pe550]: variable "变量" was set but never used <br> 2010-12-30 14:55<br> 一般我们开始学习使用一门语言或者一个新的编译器的时候，都会先写的些非常简单的程序去体验一下。比如C语言：<br> int main(void)<br> {<!-- --><br>   int a=1,b=2;<br>   int c;<br>   c=a+b;<br>   return 0;<br> }<br> 这样一个简单的程序，在C430里编译的时候却会出现这样的警告信息：<br> Warning[Pe550]: variable "c" was set but never used<br> MSP430的编译器是很特别的。如果定义了一个变量，只是赋个值给他，之后再也不使用它了，编译器往往就会认为它没有使用过。这应该是编译器对空间的优化，且对变量C不分配存储空间(你可以软件仿真下，右键“Add to Watch ”，可以看到C的值是unavailable(难以获得 ))因为只是赋个值给他,这样变量确实是没什么用的。我想这个警告只是个提示，对开发者的提醒。如果是一个很大的程序，难免有些变量定义赋值后就再也没有使用过。这样既浪费资源，又影响速度，有这样一个WARNING会好很多~~<br> 在论坛上的发问： </p> 
  <p><a href="http://topic.csdn.net/u/20110913/17/8b5581b4-4bf4-4c05-8615-9ab17263ac2c.html" rel="noopener" title="http://topic.csdn.net/u/20110913/17/8b5581b4-4bf4-4c05-8615-9ab17263ac2c.html">http://topic.csdn.net/u/20110913/17/8b5581b4-4bf4-4c05-8615-9ab17263ac2c.html</a></p> 
  <h4>Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined...</h4> 
  <p>经典嵌入式笔试题</p> 
  <p>8. 关键字volatile有什么含意?并给出三个不同的例子。</p> 
  <p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p> 
  <p>1) 并行设备的硬件寄存器(如：状态寄存器)</p> 
  <p>2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</p> 
  <p>3) 多线程应用中被几个任务共享的变量</p> 
  <p>未证实。</p> 
  <p>Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined in this statement</p> 
  <p>见解一：</p> 
  <p>这警告有意义.<br> 用volatile修饰的变量一般不直接参与运算，volatile 修饰变量,IAR就以为着这个变量在运算过程中有可能会改变导致结果错误，所以警告用户。</p> 
  <p>(volatile：易变的)</p> 
  <p>例如：想计算a * b 要这样:<br> volatile unsigned char a;<br> volatile unsigned char b;<br> unsigned char x,y;<br> x = a;<br> y = b;<br> return (x * y);<br> 建议使用另外一个变量参与计算：<br> volatile char VVV = 9;<br> char fun()<br> {<!-- --><br>     char xxx;<br>     char yyy = 9;<br>     xxx = VVV;<br>     return xxx * yyy<br> }</p> 
  <p><a href="http://www.ourdev.cn/bbs/bbs_content.jsp?bbs_sn=823896" rel="noopener" title="http://www.ourdev.cn/bbs/bbs_content.jsp?bbs_sn=823896">http://www.ourdev.cn/bbs/bbs_content.jsp?bbs_sn=823896</a></p> 
  <p><strong>见解二：</strong></p> 
  <p><strong>再会 volatile 关键字——the order of volatile accesses is undefined</strong></p> 
  <p>作者: 奔跑 日期: 2011 年 08 月 06 日 261 views <a href="http://www.elecbench.com/?p=358#respond" rel="noopener" title="发表评论">发表评论</a> (0) <a href="http://www.elecbench.com/?p=358#comments" rel="noopener" title="查看评论">查看评论</a></p> 
  <p>1.问题描述：<br> 在编译代码时出现以下警告。<br> Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined in this statement</p> 
  <p>警告处代码如下：<br> if ((TAR+CcrCont) &gt; TACCR0)<br> {<!-- --><br> return FALSE;<br> }</p> 
  <p>警告的意思大体是说，对 volatile 的访问没有被定义。</p> 
  <p>2.问题分析：<br> 看到 volatile ，才想起以前看过的关于volatile的资料。由于 TAR 是会随时被硬件改变的，所以在使用TAR时应该先拷贝该值到一个临时变量，然后再使用。<br> 所以代码应该修改如下：<br> u16 Temp = 0;<br> Temp = TAR;<br> if ((Temp+CcrCont) &gt; TACCR0)<br> {<!-- --><br> return FALSE;<br> }</p> 
  <p>另外，这个报警还提醒了我，我的有些变量应该加上 volatile 关键字。</p> 
  <p><strong><a href="http://www.cnblogs.com/geneil/archive/2011/12/15/2289073.html" rel="noopener" title="嵌入式volatile关键字">嵌入式volatile关键字</a></strong></p> 
  <p>   今天在看S3C2440开发板的初始化代码时，对#define A (* (volatile unsigned long *) 0x48000000这种形式的定义方式有困惑，于是求助GOOGLE大神,在网上搜到了一些文章，觉得以下三篇文章对理解这个有些作用：<br> 文章一：<br>     对于不同的计算机体系结构，设备可能是端口映射，也可能是内存映射的。如果系统结构支持独立的IO地址空间，并且是端口映射，就必须使用汇编语言完成实际对设备的控制，因为C语言并没有提供真正的“端口”的概念。如果是内存映射，那就方便的多了。<br>     以 #define IOPIN   (*((volatile unsigned long *) 0xE0028000))为例：作为一个宏定义语句，define是定义一个变量或常量的伪指令。首先( volatile unsigned long * )的意思是将后面的那个地址强制转换成 volatile unsigned long * ，unsigned long * 是无符号长整形，volatile 是一个类型限定符，如const一样，当使用volatile限定时，表示这个变量是依赖系统实现的，以为着这个变量会被其他程序或者计算机硬件修改，由于地址依赖于硬件，volatile就表示他的值会依赖于硬件。<br>     volatile 类型是这样的，其数据确实可能在未知的情况下发生变化。比如，硬件设备的终端更改了它，现在硬件设备往往也有自己的私有内存地址，比如显存，他们一般是通过映象的方式，反映到一段特定的内存地址当中，这样，在某些条件下，程序就可以直接访问这些私有内存了。另外，比如共享的内存地址，多个程序都对它操作的时候。你的程序并不知道，这个内存何时被改变了。如果不加这个voliatile修饰，程序是利用catch当中的数据，那个可能是过时的了，加了 voliatile，就在需要用的时候，程序重新去那个地址去提取，保证是最新的。归纳起来如下：<br> 1. volatile变量可变 允许除了程序之外的比如硬件来修改他的内容；<br> 2. 访问该数据任何时候都会直接访问该地址处内容，即通过cache提高访问速度的优化被取消；<br>      对于((volatile unsigned long *) 0xE0028000)为随硬件需要定义的一种地址，前面加上“*”指针，为直接指向该地址，整个定义约定符号IOPIN代替，调用的时候直接对指向的地址寄存器写内容既可。这实际上就是内存映射机制的方便性了。其中volatile关键字是嵌入式系统开发的一个重要特点。上述表达式拆开来分析，首先(volatile unsigned long *) 0xE0028000的意思是把0xE0028000强制转换成volatile unsigned long类型的指针，暂记为p，那么就是#define A *p，即A为P指针指向位置的内容了。这里就是通过内存寻址访问到寄存器A，可以读/写操作。<br>     对于(volatile unsigned char *)0x20我们再分析一下，它是由两部分组成： <br> 1)(unsigned char *)0x20，0x20只是个值，前面加(unsigned char *)表示0x20是个地址，而且这个地址类型是unsigned char ，意思是说读写这个地址时，要写进unsigned char 的值，读出也是unsigned char 。 <br> 2)volatile，关键字volatile 确保本条指令不会因C 编译器的优化而被省略，且要求每次直接读值。例如用 while((unsigned char *)0x20)时，有时系统可能不真正去读0x20的值，而是用第一次读出的值，如果这样，那这个循环可能是个死循环。用了volatile 则要求每次都去读0x20的实际值。 那么(volatile unsigned char *)0x20是一个固定的指针，是不可变的，不是变量。而char  *u则是个指针变量。再在前面加"*"：*(volatile unsigned char *)0x20则变成了变量(普通的unsigned char变量，不是指针变量)，如果#define i (*(volatile unsigned char *)0x20),那么与unsigned char i是一样了，只不过前面的i的地址是固定的。<br> 那么你的问题就可解答了，(*(volatile unsigned char *)0x20)可看作是一个普通变量，这个变量有固定的地址，指向0x20。而0x20只是个常量，不是指针更不是变量。<br> 文章二：<br> 对于不同的计算机体系结构，设备可能是端口映射，也可能是内存映射的。如果系统结构支持独立的IO地址空间，并且是端口映射，就必须使用汇编语言完成实际对设备的控制，因为C语言并没有提供真正的“端口”的概念。如果是内存映射，那就方便的多了。<br>     举个例子，比如像寄存器A(地址假定为0x48000000)写入数据0x01，那么就可以这样设置了。<br> #define A (*(volatile unsigned long *) 0x48000000 )<br> ...<br>      A = 0x01;<br> ...<br>     这实际上就是内存映射机制的方便性了。其中volatile关键字是嵌入式系统开发的一个重要特点。volatile(可变的)这个关键字说明这变量可能会被意想不到地改变，这样编译器就不会去假设这个变量的值了。这种“意想不到地改变”，不是由程序去改变，而是由硬件去改变。<br>     volatile 限定编译器不对这个指针的指向的存储单元进行优化, 即不用通用寄存器暂时代替这个指针的指向的存储单元,而是每次取值都直接到指针的指向的存储单元取值.volatile 主要用于变量会异步改变的情况下,主要有三个方面:1.cpu外设寄存器 2.中断和主循环都会用到的全局变量   3.操作系统中的线程间都会用到的公共变量.上述表达式拆开来分析，首先(volatile unsigned long *) 0x48000000的意思是把0x48000000强制转换成volatile unsigned long类型的指针，即对指针的操作的范围是从0x48000000开始的4个字节(long型).暂记为p，那么就是#define A   *p，即A为P指针指向位置的内容了。这里就是通过内存寻址访问到寄存器A，可以读/写操作!<br> 文章三：<br> 理解嵌入式中#define rRTCCON (*(volatile unsigned char *))0x57000043<br>             #define rRTCCON    (*(volatile unsigned char *)0x57000043) //RTC control<br>     理解#define rRTCCON (*(volatile unsigned char *)0x57000043) //RTC control 这样的定义，总是感觉很奇怪，今天终于有了一点点心得， 嵌入式系统编程，要求程序员能够利用C语言访问固定的内存地址。既然是个地址，那么按照C语言的语法规则，这个表示地址的量应该是指针类型。所以，知道要访问的内存地址后，比如0x57000043:<br>     第一步是要把它强制转换为指针类型(unsigned char *)0x57000043，s3c2410的rRTCCON是单字节访问的，所以0x57000043强制转换为指向unsigned char类型。volatile(可变的)这个关键字说明这变量可能会被意想不到地改变，这样编译器就不会去假设这个变量的值了。这种“意想不到地改变”，不是由程序去改变，而是由硬件去改变——意想不到。<br>      第二步，对指针变量解引用，就能操作指针所指向的地址的内容了；<br>             *(volatile unsigned char *)0x57000043<br>      第三步，小心地把#define宏中的参数用括号括起来，这是一个很好的习惯。<br>     在嵌入式系统中经常使用到Volatile,对于volatile的用法,我根据自己的理解做如下阐述,希望大家可以发表评论：<br>     在c语言中,volatile关键字是一种类型修饰符, 用它声明的类型变量表示该变量可以被某些编译器未知的外部因素(比如:操作系统、硬件或者其它线程)更改. 遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址(定义的变量在内存中的地址)的稳定访问。<br>     编译器对代码的优化是指:CPU在执行的过程中,因为访问内存的速度远没有cpu的执行速度快,为了提高效率,引入了高速缓存cache. C编译器在编译时如果不知道变量会被其它外部因素(操作系统、硬件或者其它线程)修改,那么就会对该变量进行标识,即优化.那么这个变量在CPU的执行过程中,就会被放到高速缓存cache去,进而达到对变量的快速访问. 在了解了优化的概念后,试想如果我们事先就知道该变量会被外部因素改变,那么我们就在这个变量定义前加上Volatile,这样编译器就不会对该变量进行优化.这样该变量在cpu处理的过程当中,就不会被放到高速缓存cache中。<br>      为什么要让变量在执行的过程中不被放到cache中去呢?如果变量是被外部因素改变,那么cpu就无法判断出这个变量已经被改变,那么程序在执行的过程中如果使用到该变量,还会继续使用cache中的变量,但是这个变量其实已经被改变了.需要到内存地址中更新其内容了.还有一个原因,在一些寄存器变量或数据端口的使用中,因为寄存器变量本身也是靠cache来处理,为了避免引起错误,也可以使用volatile修饰符.(简单的说使用volatile的目的就是:让对volatile 变量的存取不能缓存到寄存器，每次使用时需要重新存取。</p> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/644c715dd5ff0bcb8478a16d3b985023/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MSP430中断】MSP430的IO口中断/中断特性|Px中断进不去 原因</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9bb8700322102c45c68a9245af4a95f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mimics-基础操作教程-1</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>