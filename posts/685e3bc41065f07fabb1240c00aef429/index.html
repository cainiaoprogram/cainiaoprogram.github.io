<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法与数据结构--二叉搜索树与自平衡二叉搜索树 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法与数据结构--二叉搜索树与自平衡二叉搜索树" />
<meta property="og:description" content="0.字典（即c&#43;&#43;的map） 注：字典的 &#34;member运算&#34; 指的是检查字典中是否存在某个特定的键的操作，即查询操作。
如果我们使用数组来实现字典/map，虽然使用二分法查询也可以达到logn，但是的话插入和删除太慢了。使用链表实现的话虽然插入和删除是O(1)，但是查询的话达到了O(n)，也不可取。
因此人们发明了自平衡二叉查找树，在保证查找效率的同时，又保证了插入和删除的效率，从而更好的实现字典。
c&#43;&#43;的map和set就是用红黑树来实现的（一种特殊的自平衡二叉搜索树）。而unorder_map使用哈希表实现的。
1.二叉查找树--BST 在讲自平衡二叉搜索树之前，我们要先明白什么是二叉搜索树。
二叉查找树（Binary Search Tree），是具有如下性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。
二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。
复杂度：使用二叉搜索树进行添加，删除，搜索的平均时间复杂度都为O(logn)
特点：
2.自平衡二叉查找树--AVL树 1.为什么要有AVL树 二叉查找树虽然平均添加，删除，查找效率为O(logn)，但是却不稳定，比如像上面这张图，在最坏的情况下，也就是该二叉树不平衡的时候，效率又降到了O(n)。
所以我们要想办法让这颗二叉查找树平衡，让结点平均地分布在树的两侧，从而提高算法的稳定性，于是就发明了自平衡二叉搜索树，即AVL树。
2.AVL树的定义 3.如何构建AVL树 具体流程： 元素插入二叉搜索树中-&gt;判断结点是否平衡，具体是那种情况的不平衡-&gt;根据所处的不平衡情况进行不同的调整策略
当遇到结点不平衡时：
根据插入元素的落点，调整策略分为四种情况，插入元素落入以下4个子树的情况分别对应着四种状态。
【1】右旋--LL型状态 这时候对A结点，也就是根结点使用右旋操作进行调整。A连接左子树的右子树，A称为B的右子树。
【2】左旋--RR型状态 这时候对根结点使用左旋操作。
【3】先左旋后右旋--LR型状态 采用LR双旋。
这个操作等效与先对B结点作左旋操作，再对A结点作右旋操作。 【4】先右旋后左旋--RL型状态 采用RL双旋。
RL双旋等效于先对C右旋，再对A左旋。
具体代码 gpt生成，以后有时间再自己写一遍
#include &lt;iostream&gt; #include &lt;algorithm&gt; // AVL节点的定义 struct AVLNode { int data; AVLNode* left; AVLNode* right; int height; AVLNode(int value) : data(value), left(nullptr), right(nullptr), height(1) {} }; // 获取节点的高度 int getHeight(AVLNode* node) { if (node == nullptr) return 0; return node-&gt;height; } // 计算平衡因子 int getBalanceFactor(AVLNode* node) { if (node == nullptr) return 0; return getHeight(node-&gt;left) - getHeight(node-&gt;right); } // 更新节点的高度 void updateHeight(AVLNode* node) { if (node !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/685e3bc41065f07fabb1240c00aef429/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T10:19:27+08:00" />
<meta property="article:modified_time" content="2024-01-11T10:19:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法与数据结构--二叉搜索树与自平衡二叉搜索树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>0.字典（即c++的map）</h2> 
<p><img alt="" height="173" src="https://images2.imgbox.com/56/6b/VEUpggwa_o.png" width="332"></p> 
<p>注：字典的 "member运算" 指的是检查字典中是否存在某个特定的键的操作，即查询操作。</p> 
<p><strong>如果我们使用数组来实现字典/map，虽然使用二分法查询也可以达到logn，但是的话插入和删除太慢了。使用链表实现的话虽然插入和删除是O(1)，但是查询的话达到了O(n)，也不可取。</strong></p> 
<p><strong>因此人们发明了自平衡二叉查找树，在保证查找效率的同时，又保证了插入和删除的效率，从而更好的实现字典。</strong></p> 
<p><strong>c++的map和set就是用红黑树来实现的（一种特殊的自平衡二叉搜索树）。而unorder_map使用哈希表实现的。</strong></p> 
<h2 id="%E5%85%AB.%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" style="background-color:transparent;">1.二叉查找树--BST</h2> 
<p>在讲自平衡二叉搜索树之前，我们要先明白什么是二叉搜索树。</p> 
<p><strong>二叉查找树（Binary Search Tree），是具有如下性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</strong></p> 
<p>二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p> 
<p>复杂度：<strong>使用二叉搜索树进行添加，删除，搜索的平均时间复杂度都为O(logn)</strong></p> 
<p><strong>特点：</strong></p> 
<h2>2.自平衡二叉查找树--AVL树</h2> 
<h3>1.为什么要有AVL树</h3> 
<p><img alt="" height="227" src="https://images2.imgbox.com/4f/b1/3M2BYzww_o.png" width="200"></p> 
<p><strong>二叉查找树虽然平均添加，删除，查找效率为O(logn)，但是却不稳定，比如像上面这张图，在最坏的情况下，也就是该二叉树不平衡的时候，效率又降到了O(n)。</strong></p> 
<p><strong>所以我们要想办法让这颗二叉查找树平衡，让结点平均地分布在树的两侧，从而提高算法的稳定性，于是就发明了自平衡二叉搜索树，即AVL树。</strong></p> 
<h3><strong>2.AVL树的定义</strong></h3> 
<p><img alt="" height="203" src="https://images2.imgbox.com/f1/a4/pTkxYPoB_o.png" width="508"></p> 
<h3>3.如何构建AVL树</h3> 
<h4><strong>具体流程：</strong></h4> 
<p><strong>元素插入二叉搜索树中-&gt;判断结点是否平衡，具体是那种情况的不平衡-&gt;根据所处的不平衡情况进行不同的调整策略</strong></p> 
<p><strong>当遇到结点不平衡时：</strong></p> 
<p>根据插入元素的落点，调整策略分为四种情况，插入元素落入以下4个子树的情况分别对应着四种状态。<br><img alt="" height="161" src="https://images2.imgbox.com/bd/ff/Qi8kQ9DX_o.png" width="229"></p> 
<h4>【1】右旋--LL型状态</h4> 
<p><img alt="" height="276" src="https://images2.imgbox.com/ed/8b/605MzrXR_o.png" width="282"></p> 
<p>这时候对A结点，也就是根结点使用右旋操作进行调整。A连接左子树的右子树，A称为B的右子树。<br><img alt="" height="168" src="https://images2.imgbox.com/33/0a/xMS3Bgh4_o.png" width="312"></p> 
<h4>【2】左旋--RR型状态</h4> 
<p><img alt="" height="230" src="https://images2.imgbox.com/11/d4/9WwUaOqL_o.png" width="243"></p> 
<p>这时候对根结点使用左旋操作。</p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/5a/87/EIj76PSc_o.png" width="357"></p> 
<h4>【3】先左旋后右旋--LR型状态</h4> 
<p><img alt="" height="218" src="https://images2.imgbox.com/f4/22/dn32ipOK_o.png" width="233"></p> 
<p>采用LR双旋。</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/02/96/VR7esvd0_o.png" width="268"><img alt="" height="191" src="https://images2.imgbox.com/2c/dd/t5c0kiC6_o.png" width="355"></p> 
<div> 
 <strong>这个操作等效与先对B结点作左旋操作，再对A结点作右旋操作。</strong> 
</div> 
<div></div> 
<h4>【4】先右旋后左旋--RL型状态</h4> 
<p><img alt="" height="202" src="https://images2.imgbox.com/e2/dc/i6kvFFRW_o.png" width="219"></p> 
<p>采用RL双旋。</p> 
<p><img alt="" height="196" src="https://images2.imgbox.com/28/af/YoRpjj61_o.png" width="285"><img alt="" height="195" src="https://images2.imgbox.com/d3/06/WfkHmjPJ_o.png" width="371"></p> 
<p><strong>RL双旋等效于先对C右旋，再对A左旋。</strong></p> 
<h4><strong>具体代码</strong></h4> 
<p>gpt生成，以后有时间再自己写一遍</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

// AVL节点的定义
struct AVLNode {
    int data;
    AVLNode* left;
    AVLNode* right;
    int height;

    AVLNode(int value) : data(value), left(nullptr), right(nullptr), height(1) {}
};

// 获取节点的高度
int getHeight(AVLNode* node) {
    if (node == nullptr)
        return 0;
    return node-&gt;height;
}

// 计算平衡因子
int getBalanceFactor(AVLNode* node) {
    if (node == nullptr)
        return 0;
    return getHeight(node-&gt;left) - getHeight(node-&gt;right);
}

// 更新节点的高度
void updateHeight(AVLNode* node) {
    if (node != nullptr) {
        node-&gt;height = 1 + std::max(getHeight(node-&gt;left), getHeight(node-&gt;right));
    }
}

// 右旋转
AVLNode* rightRotate(AVLNode* y) {
    AVLNode* x = y-&gt;left;
    AVLNode* T2 = x-&gt;right;

    x-&gt;right = y;
    y-&gt;left = T2;

    updateHeight(y);
    updateHeight(x);

    return x;
}

// 左旋转
AVLNode* leftRotate(AVLNode* x) {
    AVLNode* y = x-&gt;right;
    AVLNode* T2 = y-&gt;left;

    y-&gt;left = x;
    x-&gt;right = T2;

    updateHeight(x);
    updateHeight(y);

    return y;
}

// 插入节点
AVLNode* insertNode(AVLNode* root, int key) {
    if (root == nullptr) {
        return new AVLNode(key);
    }

    if (key &lt; root-&gt;data) {
        root-&gt;left = insertNode(root-&gt;left, key);
    } else if (key &gt; root-&gt;data) {
        root-&gt;right = insertNode(root-&gt;right, key);
    } else {
        // 重复的键值不允许插入
        return root;
    }

    // 更新节点的高度
    updateHeight(root);

    // 获取平衡因子
    int balance = getBalanceFactor(root);

    // 进行旋转操作以保持平衡
    // 左子树不平衡
    if (balance &gt; 1) {
        if (key &lt; root-&gt;left-&gt;data) {
            // 左-左情况，进行右旋转
            return rightRotate(root);
        } else {
            // 左-右情况，先左旋转，再右旋转
            root-&gt;left = leftRotate(root-&gt;left);
            return rightRotate(root);
        }
    }

    // 右子树不平衡
    if (balance &lt; -1) {
        if (key &gt; root-&gt;right-&gt;data) {
            // 右-右情况，进行左旋转
            return leftRotate(root);
        } else {
            // 右-左情况，先右旋转，再左旋转
            root-&gt;right = rightRotate(root-&gt;right);
            return leftRotate(root);
        }
    }

    // 树保持平衡，直接返回根节点
    return root;
}

// 中序遍历 AVL 树
void inOrderTraversal(AVLNode* root) {
    if (root != nullptr) {
        inOrderTraversal(root-&gt;left);
        std::cout &lt;&lt; root-&gt;data &lt;&lt; " ";
        inOrderTraversal(root-&gt;right);
    }
}

int main() {
    AVLNode* root = nullptr;

    // 插入一些节点
    root = insertNode(root, 10);
    root = insertNode(root, 20);
    root = insertNode(root, 30);
    root = insertNode(root, 15);
    root = insertNode(root, 5);

    // 输出中序遍历结果
    std::cout &lt;&lt; "In-order traversal of AVL tree: ";
    inOrderTraversal(root);
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2533085c93c68595c22dc00b1e9e9ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">flink升级1.18后 flink-table-planner中 org.apache.calcite.sql.SqlBasicCall 的 operands 方法不存在</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9072a921ee2e81bd535fb7ad44b0dc62/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">专业140&#43;总410&#43;哈尔滨工业大学803信号与系统和数字逻辑电路考研经验哈工大电子信息（信息与通信工程-信通）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>