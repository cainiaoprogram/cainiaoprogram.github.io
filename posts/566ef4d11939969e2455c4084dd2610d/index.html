<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android View转换为Bitmap，实现截屏效果 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android View转换为Bitmap，实现截屏效果" />
<meta property="og:description" content="前言 安卓设备一般都自带截图功能，但是用户体验有不好之处。就是会连带着状态栏📶、🔋、时间日期、其他不必要页面中信息，等等与用户想截屏的内容不符的信息也会被保存下来。通常，截图后用户会再次裁剪一次才能想把真正需求分享出去。
因此，咱们技术研发会遇到针对性的会做一些应用内的截屏功能。
一、getDrawingCache getDrawingCache()是其中一种截图手段，使用方便，主要针对应用内截图。
1、创建View
fun getShareView() : View { val shareView: View = LayoutInflater.from(context).inflate(R.layout.share_layout, null) //内容... return shareView } 注意：一般大家实现思路都是点击事件里进行创建View绘制，很可能会遇到网络图片还未加载完的情况。因此，建议做延迟处理，或在点击前前置创建好。
2、测试和绘制
public static void layoutView(View v, int width, int height) { v.layout(0, 0, width, height); int measuredWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY); int measuredHeight = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY); v.measure(measuredWidth, measuredHeight); v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); } 如果不走这个方法，bitmap转换时会没有视图(黑屏情况)。 调用方法：
// 设置视图的dp宽高 layoutView(share_view, dp2px(210), dp2px(180)); public static int dp2px(float dp) { float scale = Resources." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/566ef4d11939969e2455c4084dd2610d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-08T16:44:30+08:00" />
<meta property="article:modified_time" content="2022-09-08T16:44:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android View转换为Bitmap，实现截屏效果</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>        安卓设备一般都自带截图功能，但是用户体验有不好之处。就是会连带着状态栏📶、🔋、时间日期、其他不必要页面中信息，等等与用户想截屏的内容不符的信息也会被保存下来。通常，截图后用户会再次裁剪一次才能想把真正需求分享出去。</p> 
<p>        因此，咱们技术研发会遇到针对性的会做一些应用内的截屏功能。</p> 
<hr> 
<h3>一、getDrawingCache</h3> 
<p>   getDrawingCache()是其中一种截图手段，使用方便，主要针对应用内截图。</p> 
<p>1、创建View</p> 
<pre><code class="language-Kotlin">fun getShareView() : View {
     val shareView: View =
            LayoutInflater.from(context).inflate(R.layout.share_layout, null)
     //内容...
     return  shareView
}</code></pre> 
<p>注意：一般大家实现思路都是点击事件里进行创建View绘制，很可能会遇到网络图片还未加载完的情况。因此，建议做延迟处理，或在点击前前置创建好。</p> 
<p></p> 
<p>2、测试和绘制</p> 
<pre><code class="language-java"> public static void layoutView(View v, int width, int height) {
        v.layout(0, 0, width, height);
        int measuredWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY);
        int measuredHeight = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY);
        v.measure(measuredWidth, measuredHeight);
        v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());
    }</code></pre> 
<p>如果不走这个方法，bitmap转换时会没有视图(黑屏情况)。 </p> 
<p>调用方法：</p> 
<pre><code class="language-java">// 设置视图的dp宽高
layoutView(share_view, dp2px(210), dp2px(180));</code></pre> 
<pre><code class="language-java">  public static int dp2px(float dp) {
        float scale = Resources.getSystem().getDisplayMetrics().density;
        return (int) (dp * scale + 0.5f);
    }</code></pre> 
<p>3、转换Bitmap</p> 
<pre><code class="language-java"> public static Bitmap getCacheBitmapFromView(View view) {
        final boolean drawingCacheEnabled = true;
        view.setDrawingCacheEnabled(drawingCacheEnabled);
      //设置背景色  //view.setBackgroundColor(CommonUtils.getContext().getResources().getColor(R.color.half_white));
        view.buildDrawingCache(drawingCacheEnabled);
        final Bitmap drawingCache = view.getDrawingCache();
        Bitmap bitmap;
        if (drawingCache != null) {
            bitmap = Bitmap.createBitmap(drawingCache);
            view.setDrawingCacheEnabled(false);
        } else {
            bitmap = null;
        }
        return bitmap;
    }</code></pre> 
<p></p> 
<h3>二、黑屏问题</h3> 
<p>        一般情况下，上面的代码能够正常实现效果。但有时候，生成Bitmap会出现问题(Bitmap全黑色)。主要原因是drawingCache的值大于系统给定的值。我们可以看一下buildDrawingCache()方法中的一段代码：</p> 
<pre><code class="language-java">    //所要cache的view绘制的宽度和高度
if (width &lt;= 0 || height &lt;= 0 ||
    //计算的是当前所需要的drawingCache 大小
    (width * height * (opaque &amp;&amp; !translucentWindow ? 2 : 4) &gt; 
    //得到的是系统所提供的最大的DrawingCache的值
   ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {

    destroyDrawingCache();

    return;
}</code></pre> 
<p>当所需要的<span style="color:#fe2c24;"><strong>drawingCache  &gt; 系统所提供的最大DrawingCache</strong></span>值时，生成Bitmap就会出现问题，此时获取的Bitmap就为null。</p> 
<p>所以在只需要修改所需的cache值就可以解决问题了。于是我们引入第二种方法：</p> 
<p>解决方案:</p> 
<pre><code class="language-java">public static Bitmap convertViewToBitmap(View view){

    view.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED),
MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));

    view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());

    view.buildDrawingCache();

    Bitmap bitmap = view.getDrawingCache();

    return bitmap;

}</code></pre> 
<p>view 使用 "getMeasuredWidth()"、 "getMeasuredHeight()"方法计算长宽。此时，Bitmap就能正确获取了。</p> 
<p></p> 
<h3>三、源码分析</h3> 
<pre><code class="language-java">    public void buildDrawingCache() {
        buildDrawingCache(false);
    }
	
    public Bitmap getDrawingCache() {
        return getDrawingCache(false);
    }
	
    public Bitmap getDrawingCache(boolean autoScale) {
        if ((mViewFlags &amp; WILL_NOT_CACHE_DRAWING) == WILL_NOT_CACHE_DRAWING) {
            return null;
        }
        if ((mViewFlags &amp; DRAWING_CACHE_ENABLED) == DRAWING_CACHE_ENABLED) {
            buildDrawingCache(autoScale);
        }
        return autoScale ? mDrawingCache : mUnscaledDrawingCache;
    }   

    public void buildDrawingCache(boolean autoScale) {
        if ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ?
                mDrawingCache == null : mUnscaledDrawingCache == null)) {
            if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
                Trace.traceBegin(Trace.TRACE_TAG_VIEW,
                        "buildDrawingCache/SW Layer for " + getClass().getSimpleName());
            }
            try {
                buildDrawingCacheImpl(autoScale);
            } finally {
                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
            }
        }
    }
	
    private void buildDrawingCacheImpl(boolean autoScale) {
        mCachingFailed = false;
 
        int width = mRight - mLeft;
        int height = mBottom - mTop;
 
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null &amp;&amp; attachInfo.mScalingRequired;
 
        if (autoScale &amp;&amp; scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
 
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null &amp;&amp; attachInfo.mUse32BitDrawingCache;
 
        final long projectedBitmapSize = width * height * (opaque &amp;&amp; !use32BitCache ? 2 : 4);
        final long drawingCacheSize =
                ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize();
        if (width &lt;= 0 || height &lt;= 0 || projectedBitmapSize &gt; drawingCacheSize) {
            if (width &gt; 0 &amp;&amp; height &gt; 0) {
                Log.w(VIEW_LOG_TAG, getClass().getSimpleName() + " not displayed because it is"
                        + " too large to fit into a software layer (or drawing cache), needs "
                        + projectedBitmapSize + " bytes, only "
                        + drawingCacheSize + " available");
            }
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
     ..检测drawingCache原有数据操作..
	    try {
                bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(),
                        width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque &amp;&amp; use32BitCache) bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // If there is not enough memory to create the bitmap cache, just
                // ignore the issue as bitmap caches are not required to draw the
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
	..执行Bitmap写入autoScale ? mDrawingCache : mUnscaledDrawingCache操作..
    }
</code></pre> 
<p>   从以上源码中，可以看到getDrawingcache = null 的条件共有四个： <br>       1、(mViewFlags &amp; WILL_NOT_CACHE_DRAWING) == WILL_NOT_CACHE_DRAWING为true <br>       2、没有设置setDrawingCacheEnabled(true) <br>       3、width &lt;= 0 || height &lt;= 0 || projectedBitmapSize &gt; drawingCacheSize为true <br>       4、OutOfMemory <br>  </p> 
<p>        除了第一个条件，其他的都是buildDrawingCache执行时才会触发。下面来分析下条件三。既然子布局可以正常显示，那么一定是满足width&gt;0和height&gt;0的， drawingCacheSize肯定是一个固定值，就是当前设备系统所允许的最大绘制缓存值。projectedBitmapSize的计算方式为width * height * (opaque &amp;&amp; !use32BitCache ? 2 : 4)，顾名思义，就是当前计划缓存的图片大小，(opaque &amp;&amp; !use32BitCache ? 2 : 4)不可能为0，也不可能是导致计划缓存值变大的主因，width就是屏幕的宽，这个没有变动的条件，那么可以肯定就是height出现了异常，对于视图高度的计算，android源码表示如下：</p> 
<pre><code class="language-java">@ViewDebug.ExportedProperty(category = "layout")
public final int getHeight() {
  return mBottom - mTop;
}

</code></pre> 
<p>一个View的高度getHeight()就是底-高，其中mBottom指的是视图自身的底边到父视图顶边的距离，mTop指的是视图自身的顶边到父视图顶边的距离。</p> 
<p></p> 
<h3>四、View转Canvas转Bitmap</h3> 
<pre><code class="language-java">    Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(bitmap);
    view.measure(View.MeasureSpec.makeMeasureSpec(view.getWidth(), View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(view.getHeight(), View.MeasureSpec.EXACTLY));
    view.layout((int) view.getX(), (int) view.getY(), (int) view.getX() + view.getMeasuredWidth(), (int) view.getY() + view.getMeasuredHeight());
    view.draw(canvas);
    return bitmap;</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2205d8183b3167dadfdd9265759bf59f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Token_JWT</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/153867c7abac45db4e01c2de58283d25/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何复制另一个PCB到当前的PCB中</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>