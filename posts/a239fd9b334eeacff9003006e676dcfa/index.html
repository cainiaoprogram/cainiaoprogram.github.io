<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mybatis查询一对多数据 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mybatis查询一对多数据" />
<meta property="og:description" content="mybatis解析-association实现原理详解_龚厂长的博客-CSDN博客_mybatis association
可以使用association标签或者collection来完成,之前开发的时候经常会需要返回这种嵌套的结构的数据比如查询用户列表,然后用户的联系人集合 大概结构如下:
用户:{ id:用户id, name:用户名称 phone:用户手机 contactList:[ {联系人json数据1},{联系人json数据2},{联系人json数据3} ] } 如果先查询一个用户的集合,然后遍历根据每个用户的ID再去关联查询联系人表则效率受影响,而且一般公司也禁止这么去做,那么我之前的做法就是先查询出用户列表集合:
List&lt;Long&gt; userIds =userList.stream().map(user-&gt;user.getId()).collect(Collection.toList); ContactList 联系人结果List= 联系人Mapper.selectUserByIds(userIds); 然后用用户的集合和联系人的结果双向遍历,如果用户的id等于联系人的用户ID,就往用户的联系人集合里put 这样其实也是能解决问题的,但是写起来的话就比较麻烦 其实可以使用mybatis里的映射来做 会简单很多,开发这么些年 其实还真没有用过这个功能 下面我就以collection这个标签来举例
首先是返回的实体对象1-项目表
@Data public class BusiProjectInitiationParam extends BaseParam { /** * */ @NotNull(message = &#34;不能为空，请检查id参数&#34;, groups = {edit.class, delete.class, detail.class}) private Long projectId; /** * 操作id */ @NotNull(message = &#34;操作id不能为空，请检查optId参数&#34;, groups = {add.class, edit.class}) private Long busiOptId; /** * 项目编号 */ @NotBlank(message = &#34;项目编号不能为空，请检查code参数&#34;, groups = {add." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a239fd9b334eeacff9003006e676dcfa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-11T17:11:28+08:00" />
<meta property="article:modified_time" content="2022-11-11T17:11:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mybatis查询一对多数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://blog.csdn.net/weixin_38308374/article/details/113917812" title="mybatis解析-association实现原理详解_龚厂长的博客-CSDN博客_mybatis association">mybatis解析-association实现原理详解_龚厂长的博客-CSDN博客_mybatis association</a></p> 
<p>可以使用association标签或者collection来完成,之前开发的时候经常会需要返回这种嵌套的结构的数据比如查询用户列表,然后用户的联系人集合 大概结构如下:</p> 
<pre><code class="language-html">用户:{

      id:用户id,

      name:用户名称

      phone:用户手机

      contactList:[
           {联系人json数据1},{联系人json数据2},{联系人json数据3}

      ]
}</code></pre> 
<p> 如果先查询一个用户的集合,然后遍历根据每个用户的ID再去关联查询联系人表则效率受影响,而且一般公司也禁止这么去做,那么我之前的做法就是先查询出用户列表集合:</p> 
<pre><code class="language-html">List&lt;Long&gt; userIds =userList.stream().map(user-&gt;user.getId()).collect(Collection.toList);
ContactList  联系人结果List= 联系人Mapper.selectUserByIds(userIds);</code></pre> 
<p>然后用用户的集合和联系人的结果双向遍历,如果用户的id等于联系人的用户ID,就往用户的联系人集合里put 这样其实也是能解决问题的,但是写起来的话就比较麻烦 其实可以使用mybatis里的映射来做 会简单很多,开发这么些年 其实还真没有用过这个功能 下面我就以collection这个标签来举例</p> 
<p>首先是返回的实体对象1-项目表</p> 
<pre><code class="language-html">@Data
public class BusiProjectInitiationParam extends BaseParam {

    /**
     * 
     */
    @NotNull(message = "不能为空，请检查id参数", groups = {edit.class, delete.class, detail.class})
    private Long projectId;

    /**
     * 操作id
     */
    @NotNull(message = "操作id不能为空，请检查optId参数", groups = {add.class, edit.class})
    private Long busiOptId;

    /**
     * 项目编号
     */
    @NotBlank(message = "项目编号不能为空，请检查code参数", groups = {add.class, edit.class})
    private String code;

    /**
     * 项目名称
     */
    @NotBlank(message = "项目名称不能为空，请检查name参数", groups = {add.class, edit.class})
    private String name;

    /**
     * 租赁类型
     */
    @NotBlank(message = "租赁类型不能为空，请检查rentType参数", groups = {add.class, edit.class})
    private String rentType;

    /**
     * 项目金额（元）
     */
    @NotNull(message = "项目金额（元）不能为空，请检查amount参数", groups = {add.class, edit.class})
    private BigDecimal amount;

    /**
     * 业务经理
     */
    @NotNull(message = "业务经理不能为空，请检查busiManager参数", groups = {add.class, edit.class})
    private Long busiManager;

    /**
     * 所属部门
     */
    @NotNull(message = "所属部门不能为空，请检查busiDept参数", groups = {add.class, edit.class})
    private Long busiDept;

    /**
     * 是否有担保
     */
    @NotBlank(message = "是否有担保不能为空，请检查isGuarantee参数", groups = {add.class, edit.class})
    private String isGuarantee;

    /**
     * 还款来源
     */
    @NotBlank(message = "还款来源不能为空，请检查repaySource参数", groups = {add.class, edit.class})
    private String repaySource;

    /**
     * 项目综述（优劣势分析）
     */
    @NotBlank(message = "项目综述（优劣势分析）不能为空，请检查analysisNote参数", groups = {add.class, edit.class})
    private String analysisNote;

    

    //项目参与人
    @NotNull(message = "项目参与人不能为空，请检查updateUser参数", groups = {add.class, edit.class})
	private List&lt;BusiProjectInitiationParterParam&gt; parterList;



}</code></pre> 
<p>然后下面是项目参与人的实体:</p> 
<pre><code class="language-html">@Data
public class BusiProjectInitiationParterParam extends BaseParam {

    /**
     * 
     */
    @NotNull(message = "不能为空，请检查id参数", groups = {edit.class, delete.class, detail.class})
    private Long parterId;

    /**
     * 项目主键
     */
    @NotNull(message = "项目主键不能为空，请检查projectId参数", groups = {add.class, edit.class})
    private Long projectId;

    /**
     * 客户ID
     */
    @NotNull(message = "客户ID不能为空，请检查customerId参数", groups = {add.class, edit.class})
    private Long customerId;

	/**
	 * 客户名称
	 */
	@NotNull(message = "客户ID不能为空，请检查customerId参数", groups = {add.class, edit.class})
	private String customerName;

    /**
     * 参与角色
     */
    @NotBlank(message = "参与角色不能为空，请检查role参数", groups = {add.class, edit.class})
    private String role;

	/**
	 * 类型
	 */
	private String type;



    /**
     * 
     */
    @NotNull(message = "不能为空，请检查isDelete参数", groups = {add.class, edit.class})
    private Integer isDelete;

    /**
     * 
     */
    @NotNull(message = "不能为空，请检查createTime参数", groups = {add.class, edit.class})
    private String createTime;

    /**
     * 
     */
    @NotNull(message = "不能为空，请检查createUser参数", groups = {add.class, edit.class})
    private Long createUser;

    /**
     * 
     */
    @NotNull(message = "不能为空，请检查createDept参数", groups = {add.class, edit.class})
    private Long createDept;

    /**
     * 
     */
    @NotNull(message = "不能为空，请检查updateTime参数", groups = {add.class, edit.class})
    private String updateTime;

    /**
     * 
     */
    @NotNull(message = "不能为空，请检查updateUser参数", groups = {add.class, edit.class})
    private Long updateUser;

}</code></pre> 
<p>查询项目列表的同时 查询每个项目的参与人集合,下面是mybatis配置:</p> 
<pre><code class="language-XML">&lt;select id="selectProjectPageNew" resultMap="associationResultMap"&gt;
select 项目表.字段信息,参与人表.字段信息 from 项目表 left join 项目参与人表 on 项目表.id=项目参与方表.项目id 

&lt;/select&gt;</code></pre> 
<p>然后接下来是resultMap里的配置信息</p> 
<pre><code class="language-XML">&lt;resultMap id="associationResultMap" type="项目表的全路径"&gt;
		&lt;id column="project_id(项目表主键数据库字段)"  property="projectId(项目表POJO属性字段)" /&gt;
		&lt;result column="项目表普通字段"  property="对应的POJO属性" /&gt;
		......//把需要查询的项目字段罗列下去
		&lt;collection property="parterList(项目表对象里参与方的集合属性名称)" column="project_id(项目表和参与方表关联的数据库字段)" ofType="参与方的全路径"&gt;
			&lt;id column="参与方数据库字段(parter_id)"  property="参与方POJI属性(parterId)" /&gt;
			......//把需要查询的参与方字段罗列下去
		&lt;/collection&gt;
	&lt;/resultMap&gt;</code></pre> 
<p>上面的伪代码大致说明了配置信息,然后其他查询入参和正常一样,该怎么传就怎么传</p> 
<p>最后我想看看目前大多数朋友在做这种一对多结果查询的时候 是使用的哪一种方式来完成的?</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bdeed4ecc83f7f8d8c971fcef13c1234/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【51单片机】花式流水灯</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0fd30bb50a8b7262c293cbca753dfa2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">蓝牙HID——Android手机注册HID时出现 Could not bind to Bluetooth (HID Device) Service with Intent * 的问题分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>