<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;模板：静多态 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;模板：静多态" />
<meta property="og:description" content="一般，使用虚函数和继承实现的是动多态，即在运行期间确定调用者的类型。使用模板，可以实现静多态，在编译期间确定调用者的类型。
例如我们要对某一类对象进行统一处理，使用虚函数可以这样实现：
class BaseType { public: virtual void action1(){...} virtual void action2(){...} } class SubType1 : BaseType { public: virtual void action1(){...} virtual void action2(){...} } class SubType2 : BaseType { public: virtual void action1(){...} virtual void action2(){...} } // 统一处理 void DoAction1(BaseType const&amp; type) { type.action1(); } void DoAction2(BaseType* type) { type-&gt;action2(); } // 可以处理异类集合 void DoActions(std::vector&lt;BaseType*&gt; list) { ... } 如果使用模板来实现，就会变成这样
class SubType1 { public: void action1(){...} void action2(){." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/baa145fdf9fc984941ac562e45c3b207/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-10T15:16:43+08:00" />
<meta property="article:modified_time" content="2021-07-10T15:16:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;模板：静多态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一般，使用虚函数和继承实现的是动多态，即在运行期间确定调用者的类型。使用模板，可以实现静多态，在编译期间确定调用者的类型。</p> 
<p>例如我们要对某一类对象进行统一处理，使用虚函数可以这样实现：</p> 
<pre><code class="prism language-c++">class BaseType
{
public:
	virtual void action1(){...}
    virtual void action2(){...}
}

class SubType1 : BaseType
{
public:
    virtual void action1(){...}
    virtual void action2(){...}
}

class SubType2 : BaseType
{
public:
    virtual void action1(){...}
    virtual void action2(){...}
}

// 统一处理
void DoAction1(BaseType const&amp; type)
{
    type.action1();
}

void DoAction2(BaseType* type)
{
    type-&gt;action2();
}

// 可以处理异类集合
void DoActions(std::vector&lt;BaseType*&gt; list) 
{
    ...
}
</code></pre> 
<p>如果使用模板来实现，就会变成这样</p> 
<pre><code class="prism language-c++">class SubType1
{
public:
    void action1(){...}
    void action2(){...}
}

class SubType2
{
public:
    void action1(){...}
    void action2(){...}
}

// 统一处理
template&lt;typename BaseType&gt;
void DoAction1(BaseType const&amp; type)
{
    type.action1();
}

template&lt;typename BaseType&gt;
void DoAction2(BaseType* type)
{
    type-&gt;action2();
}

// 不可以处理异类集合，因为要在编译期间确定，vector只能为一个类型的集合
template&lt;typename BaseType&gt;
void DoActions(std::vector&lt;BaseType*&gt; list)  // 处理异类集合会报错
{
    ...
}
</code></pre> 
<h5><a id="_84"></a>动多态和静多态两者的优点</h5> 
<p><strong>动多态：</strong></p> 
<ol><li>可以处理异类集合</li><li>生成的代码比较小，只需要一个多态函数，而静多态会生成多个实例化函数</li></ol> 
<p><strong>静多态：</strong></p> 
<ol><li>不需要和公共基类绑定，可以自由实现处理类型</li><li>代码运行效率更高，直接调用函数，虚函数间接调用；比虚函数拥有更多内联的机会</li></ol> 
<h5><a id="Bridge_Pattern_98"></a>使用模板实现Bridge Pattern</h5> 
<p>用一个指针引用具体的实现，然后把所有的调用都委托给这个(包含这个指针)的类。</p> 
<p>使用多态实现：</p> 
<pre><code class="prism language-c++">// 实现的接口基类
class Implementation
{
	virtual operationA() = 0;
    virtual operationB() = 0;
    virtual operationC() = 0;
}

// 实现A
class ImplementationA : Implementation
{
    virtual operationA(){...}
    virtual operationB(){...}
    virtual operationC(){...}
}

// 实现B
class ImplementationB : Implementation
{
    virtual operationA(){...}
    virtual operationB(){...}
    virtual operationC(){...}
}

class Bridge
{
public:
    // 通过将body指向不同的实现类来调用不同的实现
    Implementation* body;
    
    void operationA()
    {
        body-&gt;operationA();
    }
    
    void operationB()
    {
        body-&gt;operationB();
    }
}
</code></pre> 
<p>使用模板实现，即使用静多态：</p> 
<pre><code class="prism language-c++">// 实现A
class ImplementationA : Implementation
{
    virtual operationA(){...}
    virtual operationB(){...}
    virtual operationC(){...}
}

// 实现B
class ImplementationB : Implementation
{
    virtual operationA(){...}
    virtual operationB(){...}
    virtual operationC(){...}
}

template&lt;typename Implementation&gt;
class Bridge
{
public:
    // 使用不同的类型来生成不同实现的实例化类
    Implementation* body;
    
    void operationA()
    {
        body-&gt;operationA();
    }
    
    void operationB()
    {
        body-&gt;operationB();
    }   
}
</code></pre> 
<p>使用模板实现桥接模式的一个例子就是C++STL的迭代器，通过迭代器间接执行元素的操作。在容器扩容的时候，有时会重新申请一块内存，并将原来的数据转移过去，如果外面有指针指向容器内的元素，那么这个指针就会失效，如果是指向迭代器，那么就不会有问题。</p> 
<pre><code class="prism language-c++">template&lt;typename T&gt;
class Iterator
{
private:
	T value;
public:
    T operator+(T const&amp; right){...}
    ...
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/994fc1da529f5a535192ffc8e2cbbbff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python3 ---------各种常见内置函数的时间复杂度总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b797ec8c7b2bf9cf9280bea32b7fdfb5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">云服务器CENTOS7安装 docker</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>