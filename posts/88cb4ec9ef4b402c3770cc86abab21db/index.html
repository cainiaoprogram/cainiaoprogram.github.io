<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2020-10-26：自定义3个注解解决项目的3个Swagger难题（转载） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2020-10-26：自定义3个注解解决项目的3个Swagger难题（转载）" />
<meta property="og:description" content="原文链接：https://cloud.tencent.com/developer/article/1700641 14天自定义3个注解扩展Swagger的3个功能的经历 14天自定义3个注解扩展Swagger的3个功能的经历.png
前言 （一）本文针对的小伙伴 点开此文章的小伙伴们请注意了，本片文章针对的是对Swagger有一定基础的小伙伴；
你应该具备或者已经具备的：
1、有过Swagger的使用经历；2、了解过Swagger，动手去集成过SpringBoot；3、对自定义注解解决业务需求有想迫切了解的兴趣。4、......。 （二）通过本文能了解或者学到什么 本篇文章是我通过大量的实践，摸索、查资料、Debug源代码一步一步的摸索出来的，整理一份比较详细的资料，以便也有利于他人，少走弯路。
通过本文你将会：
1、了解到SpringBoot项目中如何自定义注解并且使用；2、掌握如何扩展Swagger的功能，并成功的用在项目上；3、了解到自定义注解的流程，以及如果应用的过程；4、少走一些坑。 14天自定义3个注解扩展Swagger的3个功能的经历.png
一、第一部分：基础(可跳过) （一）swagger简介 swagger确实是个好东西。
为什么是个好东西呢？
因为：
1、可以跟据业务代码自动生成相关的api接口文档，尤其用于restful风格中的项目；2、开发人员几乎可以不用专门去维护rest api，这个框架可以自动为你的业务代码生成restfut风格的api；3、而且还提供相应的测试界面，自动显示json格式的响应。4、大大方便了后台开发人员与前端的沟通与联调成本。 因为：
1、可以跟据业务代码自动生成相关的api接口文档，尤其用于restful风格中的项目；2、开发人员几乎可以不用专门去维护rest api，这个框架可以自动为你的业务代码生成restfut风格的api；3、而且还提供相应的测试界面，自动显示json格式的响应。4、大大方便了后台开发人员与前端的沟通与联调成本。 1、springfox-swagger简介 签于swagger的强大功能，java开源界大牛spring框架迅速跟上，它充分利用自已的优势，把swagger集成到自己的项目里，整了一个spring-swagger，后来便演变成springfox。springfox本身只是利用自身的aop的特点，通过plug的方式把swagger集成了进来，它本身对业务api的生成，还是依靠swagger来实现。 关于这个框架的文档，网上的资料比较少，大部分是入门级的简单使用。本人在集成这个框架到自己项目的过程中，遇到了不少坑，为了解决这些坑，我不得不扒开它的源码来看个究竟。此文，就是记述本人在使用springfox过程中对springfox的一些理解以及需要注意的地方。 2、springfox大致原理 springfox的大致原理就是，在项目启动的过程中，spring上下文在初始化的过程，框架自动跟据配置加载一些swagger相关的bean到当前的上下文中，并自动扫描系统中可能需要生成api文档那些类，并生成相应的信息缓存起来。如果项目MVC控制层用的是springMvc那么会自动扫描所有Controller类，跟据这些Controller类中的方法生成相应的api文档。 （二）SpringBoot集成Swagger springfox-swagger-ui依赖并不是必须的，可以使用第三方的UI，也可以自己写一套前端的UI集成进来。 我们就可以使用一个基于bootstrap写的UI。
1、引入相关依赖 &lt;!-- 引入swgger相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springfox的UI。此依赖不是必须的 --&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; --&gt; 截至到目前2020.9.9日springfox-swagger2:2.9.2的版本主要引入了下面这些依赖：
io.swagger:swagger-annotations:1.5.20io.swagger:swagger-models:1.5.20io.springfox:springfox-spi:2.9.2io.springfox:springfox-schema:2.9.2io.springfox:springfox-swagger-common:2.9.2io.springfox:springfox-spring-web:2.9.2com.google.guava:guava:20.0com.fasterxml:classmate:1.3.3org.slf4j:slf4j-api:1.7.24org.springframework.plugin:spring-plugin-core:1.2.0.RELEASEorg.springframework.plugin:spring-plugin-metadata:1.2.0.RELEASEorg.mapstruct:mapstruct:1.2.0.Finalio.springfox:springfox-core:2.9.2net.bytebuddy:byte-buddy:1.8.12 为了页面好看，我们也可以引入这个基于Bootstrap的前端UI：
&lt;!--基于BootStrap的UI框架--&gt; &lt;!--2.x.x版本的swagger-bootstrap-ui引用包方式如下 1.9.x和2.x.x选择一个包引用就行--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;!--在引用时请在maven中央仓库搜索最新版本号--&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; 默认的swagger界面：
引入第三方Bootstrap编写的UI：
2.配置相关配置文件
/** * SwaggerConfig file * zhenghui */ @Configuration @EnableSwagger2 @EnableKnife4j //UI public class Swagger2Config { @Bean public Docket appApi() { return new Docket(DocumentationType." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/88cb4ec9ef4b402c3770cc86abab21db/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-26T15:49:08+08:00" />
<meta property="article:modified_time" content="2020-10-26T15:49:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2020-10-26：自定义3个注解解决项目的3个Swagger难题（转载）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>原文链接：<a href="https://cloud.tencent.com/developer/article/1700641?sharedUid=3741329" rel="nofollow">https://cloud.tencent.com/developer/article/1700641</a></h2> 
<p> </p> 
<h2 id="14%E5%A4%A9%E8%87%AA%E5%AE%9A%E4%B9%893%E4%B8%AA%E6%B3%A8%E8%A7%A3%E6%89%A9%E5%B1%95Swagger%E7%9A%843%E4%B8%AA%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BB%8F%E5%8E%86">14天自定义3个注解扩展Swagger的3个功能的经历</h2> 
<p><img alt="" height="719" src="https://images2.imgbox.com/a3/5e/rgvYpKrP_o.png" width="1014"></p> 
<p> </p> 
<p>                                                         14天自定义3个注解扩展Swagger的3个功能的经历.png</p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%AC%E6%96%87%E9%92%88%E5%AF%B9%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4">（一）本文针对的小伙伴</h3> 
<p>点开此文章的小伙伴们请注意了，本片文章针对的是对Swagger有一定基础的小伙伴；</p> 
<p>你应该具备或者已经具备的：</p> 
<ul><li>1、有过Swagger的使用经历；</li><li>2、了解过Swagger，动手去集成过SpringBoot；</li><li>3、对自定义注解解决业务需求有想迫切了解的兴趣。</li><li>4、......。</li></ul> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E8%BF%87%E6%9C%AC%E6%96%87%E8%83%BD%E4%BA%86%E8%A7%A3%E6%88%96%E8%80%85%E5%AD%A6%E5%88%B0%E4%BB%80%E4%B9%88">（二）通过本文能了解或者学到什么</h3> 
<p>本篇文章是我通过大量的实践，摸索、查资料、Debug源代码一步一步的摸索出来的，整理一份比较详细的资料，以便也有利于他人，少走弯路。</p> 
<p>通过本文你将会：</p> 
<ul><li>1、了解到SpringBoot项目中如何自定义注解并且使用；</li><li>2、掌握如何扩展Swagger的功能，并成功的用在项目上；</li><li>3、了解到自定义注解的流程，以及如果应用的过程；</li><li>4、少走一些坑。</li></ul> 
<p><img alt="" height="719" src="https://images2.imgbox.com/33/f0/N4zBzUSf_o.png" width="1009"></p> 
<p>                                                                    14天自定义3个注解扩展Swagger的3个功能的经历.png</p> 
<p> </p> 
<h2 id="%E4%B8%80%E3%80%81%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80(%E5%8F%AF%E8%B7%B3%E8%BF%87)">一、第一部分：基础(可跳过)</h2> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89swagger%E7%AE%80%E4%BB%8B">（一）swagger简介</h3> 
<blockquote> 
 <p>swagger确实是个好东西。</p> 
</blockquote> 
<p><strong>为什么是个好东西呢？</strong></p> 
<p> </p> 
<p><strong>因为：</strong></p> 
<ul><li>1、可以跟据业务代码自动生成相关的api接口文档，尤其用于restful风格中的项目；</li><li>2、开发人员几乎可以不用专门去维护rest api，这个框架可以自动为你的业务代码生成restfut风格的api；</li><li>3、而且还提供相应的测试界面，自动显示json格式的响应。</li><li>4、大大方便了后台开发人员与前端的沟通与联调成本。</li></ul> 
<p> </p> 
<p><strong>因为：</strong></p> 
<ul><li>1、可以跟据业务代码自动生成相关的api接口文档，尤其用于restful风格中的项目；</li><li>2、开发人员几乎可以不用专门去维护rest api，这个框架可以自动为你的业务代码生成restfut风格的api；</li><li>3、而且还提供相应的测试界面，自动显示json格式的响应。</li><li>4、大大方便了后台开发人员与前端的沟通与联调成本。</li></ul> 
<h4 id="1%E3%80%81springfox-swagger%E7%AE%80%E4%BB%8B">1、springfox-swagger简介</h4> 
<pre><code class="language-bash">签于swagger的强大功能，java开源界大牛spring框架迅速跟上，它充分利用自已的优势，把swagger集成到自己的项目里，整了一个spring-swagger，后来便演变成springfox。springfox本身只是利用自身的aop的特点，通过plug的方式把swagger集成了进来，它本身对业务api的生成，还是依靠swagger来实现。


关于这个框架的文档，网上的资料比较少，大部分是入门级的简单使用。本人在集成这个框架到自己项目的过程中，遇到了不少坑，为了解决这些坑，我不得不扒开它的源码来看个究竟。此文，就是记述本人在使用springfox过程中对springfox的一些理解以及需要注意的地方。</code></pre> 
<h4 id="2%E3%80%81springfox%E5%A4%A7%E8%87%B4%E5%8E%9F%E7%90%86">2、springfox大致原理</h4> 
<pre><code>springfox的大致原理就是，在项目启动的过程中，spring上下文在初始化的过程，框架自动跟据配置加载一些swagger相关的bean到当前的上下文中，并自动扫描系统中可能需要生成api文档那些类，并生成相应的信息缓存起来。如果项目MVC控制层用的是springMvc那么会自动扫描所有Controller类，跟据这些Controller类中的方法生成相应的api文档。</code></pre> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89SpringBoot%E9%9B%86%E6%88%90Swagger">（二）SpringBoot集成Swagger</h3> 
<blockquote> 
 <p>springfox-swagger-ui依赖并不是必须的，可以使用第三方的UI，也可以自己写一套前端的UI集成进来。 我们就可以使用一个基于bootstrap写的UI。</p> 
</blockquote> 
<h4 id="1%E3%80%81%E5%BC%95%E5%85%A5%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96">1、引入相关依赖</h4> 
<pre><code class="language-bash">&lt;!-- 引入swgger相关依赖       --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
    &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- springfox的UI。此依赖不是必须的 --&gt;
&lt;!--
   &lt;dependency&gt;
        &lt;groupId&gt;io.springfox&lt;/groupId&gt;
        &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
        &lt;version&gt;2.9.2&lt;/version&gt;
    &lt;/dependency&gt;
--&gt;</code></pre> 
<p>截至到目前2020.9.9日springfox-swagger2:2.9.2的版本主要引入了下面这些依赖：</p> 
<ul><li>io.swagger:swagger-annotations:1.5.20</li><li>io.swagger:swagger-models:1.5.20</li><li>io.springfox:springfox-spi:2.9.2</li><li>io.springfox:springfox-schema:2.9.2</li><li>io.springfox:springfox-swagger-common:2.9.2</li><li>io.springfox:springfox-spring-web:2.9.2</li><li>com.google.guava:guava:20.0</li><li>com.fasterxml:classmate:1.3.3</li><li>org.slf4j:slf4j-api:1.7.24</li><li>org.springframework.plugin:spring-plugin-core:1.2.0.RELEASE</li><li>org.springframework.plugin:spring-plugin-metadata:1.2.0.RELEASE</li><li>org.mapstruct:mapstruct:1.2.0.Final</li><li>io.springfox:springfox-core:2.9.2</li><li>net.bytebuddy:byte-buddy:1.8.12</li></ul> 
<p>为了页面好看，我们也可以引入这个基于Bootstrap的前端UI：</p> 
<pre><code class="language-css">&lt;!--基于BootStrap的UI框架--&gt;
&lt;!--2.x.x版本的swagger-bootstrap-ui引用包方式如下 1.9.x和2.x.x选择一个包引用就行--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
    &lt;!--在引用时请在maven中央仓库搜索最新版本号--&gt;
    &lt;version&gt;2.0.4&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>默认的swagger界面：</p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/9c/ca/G8JxM2QG_o.png" width="1200"></p> 
<p> </p> 
<p> </p> 
<p>引入第三方Bootstrap编写的UI：</p> 
<p><img alt="" height="678" src="https://images2.imgbox.com/0d/86/1ayPYqqw_o.png" width="1200"></p> 
<p> </p> 
<p>2.配置相关配置文件</p> 
<pre><code class="language-java">/**
 * SwaggerConfig file
 * zhenghui
 */
@Configuration
@EnableSwagger2
@EnableKnife4j //UI
public class Swagger2Config {

    @Bean
    public Docket appApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .useDefaultResponseMessages(false) //去掉默认的状态响应码
                .groupName("知识库")
                .apiInfo(apiInfo())
                .select()

                //扫描指定的包
//                .apis(RequestHandlerSelectors.basePackage("com.glodon.demo.mybatis")) //扫描的包
            
                //扫描只包含Swagger的注解，这种方式灵活
                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
                .paths(PathSelectors.any())
                .build();

    }



    /**
     * 配置Swagger信息
     * @return
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("知识库接口文档")
                .description("该文档主要提供知识库后端的接口 \r\n\n")
                .contact(new springfox.documentation.service.Contact("我们是机器人&lt;----q'(^_^)'p----&gt;业务后台开发组", "https://www.glodon.com/", null))
                .version("0.0.1")
                .build();
    }


}</code></pre> 
<p>在这里需要注意的是，需要扫描的位置：</p> 
<blockquote> 
 <p>有以下两种方式</p> 
</blockquote> 
<pre><code class="language-java">//扫描指定的包
//.apis(RequestHandlerSelectors.basePackage("com.glodon.demo.mybatis")) //扫描的包
            
//扫描只包含Swagger的注解，这种方式灵活
.apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</code></pre> 
<blockquote> 
 <p>如何使用了第一种，那么就会扫描固定的包下的所有的Controller类，会全部自动生成相应的API示例，例如下图所示： 好处是只要你在Controller控制层的类中定义了某个接口，或者定义了多个接口，就会直接扫描出来。<code>简单</code>，<code>方便</code>，<code>快捷</code>。 有好处的到来，就相当于要带来不好的问题，那么就是：<code>会造成一团乱麻</code>，全部生成的API，也会很乱。</p> 
</blockquote> 
<p><img alt="" height="651" src="https://images2.imgbox.com/d0/d3/TLmcKJNc_o.png" width="1200"></p> 
<p> </p> 
<p>只配置了这些还不够，还需要配置MVC模式来显示网页：</p> 
<pre><code class="language-java">@Configuration
public class SwaggerWebMvcConfigurer implements WebMvcConfigurer {
    
    // UI界面的配置
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        
        //原始的swagger 如果没有用到原始的可以不用谢
//        registry.addResourceHandler("swagger-ui.html")
//              .addResourceLocations("classpath:/META-INF/resources/");

        registry.addResourceHandler("doc.html").
                addResourceLocations("classpath:/META-INF/resources/");

        registry.addResourceHandler("/webjars/**").
                addResourceLocations("classpath:/META-INF/resources/webjars/");
    }
}</code></pre> 
<h3 id="%EF%BC%88%E4%B8%89%EF%BC%89Swagger%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E5%BD%92%E7%BA%B3">（三）Swagger常用注解的使用简单归纳</h3> 
<ul><li>1、@Api</li><li>2、@ApiOperation</li><li>3、@ApiOperation</li><li>4、@ApiImplicitParams、@ApiImplicitParam</li><li>5、@ApiResponses、@ApiResponse</li><li>6、@ApiModel、@ApiModelProperty</li><li>7、 @PathVariable</li><li>8、 @RequestParam</li></ul> 
<h4 id="1%E3%80%81@APi">1、@APi</h4> 
<p><strong>描述：</strong></p> 
<blockquote> 
 <p>@Api 注解用于标注一个Controller（Class）。</p> 
</blockquote> 
<p><strong>主要属性</strong>：</p> 
<table><thead><tr><th> <p>属性</p> </th><th> <p>描述</p> </th></tr></thead><tbody><tr><td> <p>value</p> </td><td> <p>url的路径值</p> </td></tr><tr><td> <p>tags</p> </td><td> <p>如果设置这个值、value的值会被覆盖</p> </td></tr><tr><td> <p>description</p> </td><td> <p>对api资源的描述</p> </td></tr><tr><td> <p>basePath</p> </td><td> <p>基本路径可以不配置</p> </td></tr><tr><td> <p>position</p> </td><td> <p>如果配置多个Api 想改变显示的顺序位置</p> </td></tr><tr><td> <p>produces</p> </td><td> <p>For example, "application/json, application/xml"</p> </td></tr><tr><td> <p>consumes</p> </td><td> <p>For example, "application/json, application/xml"</p> </td></tr><tr><td> <p>protocols</p> </td><td> <p>Possible values: http, https, ws, wss.</p> </td></tr><tr><td> <p>authorizations</p> </td><td> <p>高级特性认证时配置</p> </td></tr><tr><td> <p>hidden</p> </td><td> <p>配置为true 将在文档中隐藏</p> </td></tr></tbody></table> 
<p><strong>例子</strong>：</p> 
<pre><code class="language-java">@Controller
@Api(tags = "请求测试API",position = 1)
public class TestController {
    
}</code></pre> 
<p><strong>效果:</strong></p> 
<blockquote> 
 <p>加上@Api注解就代表你这Controller允许被Swagger相关组件扫描到。</p> 
</blockquote> 
<p><img alt="" height="258" src="https://images2.imgbox.com/bd/55/TTANmYiA_o.png" width="379"></p> 
<p> </p> 
<h4 id="2%E3%80%81@ApiOperation">2、@ApiOperation</h4> 
<p><strong>描述：</strong></p> 
<blockquote> 
 <p>@ApiOperation 注解在用于对一个操作或HTTP方法进行描述。具有相同路径的不同操作会被归组为同一个操作对象。不同的HTTP请求方法及路径组合构成一个唯一操作。</p> 
</blockquote> 
<p><strong>主要属性</strong>：</p> 
<table><thead><tr><th> <p>属性</p> </th><th> <p>描述</p> </th></tr></thead><tbody><tr><td> <p>value</p> </td><td> <p>url的路径值</p> </td></tr><tr><td> <p>tags</p> </td><td> <p>如果设置这个值、value的值会被覆盖</p> </td></tr><tr><td> <p>description</p> </td><td> <p>对api资源的描述</p> </td></tr><tr><td> <p>basePath</p> </td><td> <p>基本路径可以不配置</p> </td></tr><tr><td> <p>position</p> </td><td> <p>如果配置多个Api 想改变显示的顺序位置</p> </td></tr><tr><td> <p>produces</p> </td><td> <p>For example, "application/json, application/xml"</p> </td></tr><tr><td> <p>consumes</p> </td><td> <p>For example, "application/json, application/xml"</p> </td></tr><tr><td> <p>protocols</p> </td><td> <p>Possible values: http, https, ws, wss.</p> </td></tr><tr><td> <p>authorizations</p> </td><td> <p>高级特性认证时配置</p> </td></tr><tr><td> <p>hidden</p> </td><td> <p>配置为true 将在文档中隐藏</p> </td></tr><tr><td> <p>response</p> </td><td> <p>返回的对象</p> </td></tr><tr><td> <p>responseContainer</p> </td><td> <p>这些对象是有效的 "List", "Set" or "Map".，其他无效</p> </td></tr><tr><td> <p>httpMethod</p> </td><td> <p>"GET", "HEAD", "POST", "PUT", "DELETE", "OPTIONS" and "PATCH"</p> </td></tr><tr><td> <p>code</p> </td><td> <p>http的状态码 默认 200</p> </td></tr><tr><td> <p>extensions</p> </td><td> <p>扩展属性</p> </td></tr></tbody></table> 
<p><strong>例子</strong>：</p> 
<pre><code class="language-java">@GetMapping("/get")
@ResponseBody
@ApiOperation(value = "get请求测试",notes = "get请求",position = 1)
public String get(String name){
    JSONObject json = new JSONObject();
    json.put("requestType","getType");
    json.put("name",name);
    return json.toString();
}</code></pre> 
<p><strong>效果:</strong></p> 
<p><img alt="" height="649" src="https://images2.imgbox.com/1f/7e/jUvM4gQx_o.png" width="1200"></p> 
<p> </p> 
<h4 id="3%E3%80%81@ApiParam">3、@ApiParam</h4> 
<p><strong>描述：</strong></p> 
<blockquote> 
 <p>@ApiParam作用于请求方法上，定义api参数的注解。</p> 
</blockquote> 
<p><strong>主要属性</strong>：</p> 
<table><thead><tr><th> <p>属性</p> </th><th> <p>描述</p> </th></tr></thead><tbody><tr><td> <p>name</p> </td><td> <p>属性名称</p> </td></tr><tr><td> <p>value</p> </td><td> <p>属性值</p> </td></tr><tr><td> <p>defaultValue</p> </td><td> <p>默认属性值</p> </td></tr><tr><td> <p>allowableValues</p> </td><td> <p>可以不配置</p> </td></tr><tr><td> <p>required</p> </td><td> <p>是否属性必填</p> </td></tr><tr><td> <p>access</p> </td><td> <p>不过多描述</p> </td></tr><tr><td> <p>allowMultiple</p> </td><td> <p>默认为false</p> </td></tr><tr><td> <p>hidden</p> </td><td> <p>隐藏该属性</p> </td></tr><tr><td> <p>example</p> </td><td> <p>举例子</p> </td></tr></tbody></table> 
<p><strong>例子</strong>：</p> 
<pre><code class="language-java">@GetMapping("/get")
@ResponseBody
@ApiOperation(value = "get请求测试",notes = "get请求",position = 1)
public String get(@ApiParam(required = true,value = "name",example = "张三",name = "name") String name){
    JSONObject json = new JSONObject();
    json.put("requestType","getType");
    json.put("name",name);

    return json.toString();
}</code></pre> 
<p><strong>效果:</strong></p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/5d/be/XNkg02HC_o.png" width="1200"></p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/a5/87/HkZ965rA_o.png" width="1200"></p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/ce/35/5BFwtYuA_o.png" width="1200"></p> 
<h4 id="4%E3%80%81@ApiImplicitParams%E3%80%81@ApiImplicitParam">4、@ApiImplicitParams、@ApiImplicitParam</h4> 
<p><strong>描述：</strong></p> 
<blockquote> 
 <p>@ApiImplicitParams：用在请求的方法上，包含一组参数说明 @ApiImplicitParam：对单个参数的说明</p> 
</blockquote> 
<p><strong>主要属性</strong>：</p> 
<table><thead><tr><th> <p>属性</p> </th><th> <p>描述</p> </th></tr></thead><tbody><tr><td> <p>name</p> </td><td> <p>参数名</p> </td></tr><tr><td> <p>value</p> </td><td> <p>参数的说明、描述</p> </td></tr><tr><td> <p>required</p> </td><td> <p>参数是否必须必填</p> </td></tr><tr><td> <p>paramType</p> </td><td> <p>参数放在哪个地方 query --&gt; 请求参数的获取：@RequestParam header --&gt; 请求参数的获取：@RequestHeader path（用于restful接口）--&gt; 请求参数的获取：@PathVariable body（请求体）--&gt; @RequestBody User user form（普通表单提交）</p> </td></tr><tr><td> <p>dataType</p> </td><td> <p>参数类型，默认String，其它值dataType="Integer"</p> </td></tr><tr><td> <p>defaultValue</p> </td><td> <p>参数的默认值</p> </td></tr></tbody></table> 
<p><strong>例子</strong>：</p> 
<pre><code class="language-java">@ApiImplicitParams({
    @ApiImplicitParam(name="mobile",value="手机号",required=true,paramType="form"),
    @ApiImplicitParam(name="password",value="密码",required=true,paramType="form"),
    @ApiImplicitParam(name="age",value="年龄",required=true,paramType="form",dataType="Integer")
})
@PostMapping("/login")
public JsonResult login(@RequestParam String mobile, @RequestParam String password,
                        @RequestParam Integer age){
    //...
    return JsonResult.ok(map);
}</code></pre> 
<p><strong>效果:</strong></p> 
<blockquote> 
 <p>和上一个一样，就是换了个位置来表达而已。</p> 
</blockquote> 
<p> </p> 
<h4 id="5%E3%80%81@ApiResponses%E3%80%81@ApiResponse">5、@ApiResponses、@ApiResponse</h4> 
<p><strong>描述：</strong></p> 
<blockquote> 
 <p>@ApiResponses、@ApiResponse进行方法返回对象的说明。</p> 
</blockquote> 
<p><strong>主要属性</strong>：</p> 
<table><thead><tr><th> <p>属性</p> </th><th> <p>描述</p> </th></tr></thead><tbody><tr><td> <p>code</p> </td><td> <p>数字，例如400</p> </td></tr><tr><td> <p>message</p> </td><td> <p>信息，例如"请求参数没填好"</p> </td></tr><tr><td> <p>response</p> </td><td> <p>自定义的schema的实体类</p> </td></tr></tbody></table> 
<p><strong>例子</strong>：</p> 
<pre><code class="language-java">@RequestMapping(value = "/ceshia", method = RequestMethod.POST)
@ResponseBody
@ApiOperation(value = "post请求测试",notes = "测试2",position = 2)
@ApiResponses({
    @ApiResponse(code = 200,message = "success",response = RequestCode200.class),
    @ApiResponse(code = 509,message = "服务器校验错误",response = RequestCode509.class),
    @ApiResponse(code = 410,message = "参数错误",response = RequestCode410.class),
    @ApiResponse(code = 510,message = "系统错误",response = RequestCode510.class)
})
public String ceshia(@RequestBody String str){
    JSONObject json = new JSONObject();
    json.put("requestType","postType");
    json.put("body",str);

    return json.toString();
}</code></pre> 
<p><strong>效果:</strong></p> 
<p><img alt="" height="716" src="https://images2.imgbox.com/0c/a5/jEAOKBcW_o.png" width="1200"></p> 
<p> </p> 
<h4 id="6%E3%80%81@ApiModel%E3%80%81@ApiModelProperty">6、@ApiModel、@ApiModelProperty</h4> 
<p><strong>描述：</strong></p> 
<blockquote> 
 <p>@ApiModel用于描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候）。 @ApiModelProperty用来描述一个Model的属性。</p> 
</blockquote> 
<p><strong>主要属性</strong>：</p> 
<p><strong>例子</strong>：</p> 
<pre><code class="language-java">package com.github.swaggerplugin.codes;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

/**
 * 200 请求成功
 */
@ApiModel("RequestCode200")
public class RequestCode200 {


    @ApiModelProperty(value = "响应码",name = "messageCode",example = "200")
    private Integer messageCode;

    @ApiModelProperty(value = "返回消息",name = "message",example = "success")
    private String message;


    public Integer getMessageCode() {
        return messageCode;
    }

    public void setMessageCode(Integer messageCode) {
        this.messageCode = messageCode;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

}</code></pre> 
<p><strong>效果:</strong></p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/59/4b/Hcm6bM75_o.png" width="1200"></p> 
<p> </p> 
<h4 id="7%E3%80%81@PathVariable">7、@PathVariable</h4> 
<p><strong>描述：</strong></p> 
<blockquote> 
 <p>@PathVariable用于获取get请求url路径上的参数，即参数绑定的作用，通俗的说是url中"?"前面绑定的参数。例如：www.baidu.com/name=zhenghui</p> 
</blockquote> 
<p><strong>例子</strong>：</p> 
<pre><code class="language-java">@GetMapping("/get")
@ResponseBody
@ApiOperation(value = "get请求测试",notes = "get请求",position = 1)
public String get(@ApiParam(required = true,value = "name",example = "张三",name = "name") @PathVariable("name") String name){
    JSONObject json = new JSONObject();
    json.put("requestType","getType");
    json.put("name",name);
    json.put("id","123");

    return json.toString();
}</code></pre> 
<p>注：如果不加这个的话，默认就是body类型的，body类型也就是接收的是json格式的数据。</p> 
<h4 id="8%E3%80%81@RequestParam">8、@RequestParam</h4> 
<p><strong>描述：</strong></p> 
<blockquote> 
 <p>@RequestParam用于获取前端传过来的参数，可以是get、post请求，通俗的说是url中"?"后面拼接的每个参数。</p> 
</blockquote> 
<p><strong>例子</strong>：</p> 
<pre><code class="language-java">@GetMapping("/get")
@ResponseBody
@ApiOperation(value = "get请求测试",notes = "get请求",position = 1)
public String get(@ApiParam(required = true,value = "name",example = "张三",name = "name") @RequestParam("name") String name){
    JSONObject json = new JSONObject();
    json.put("requestType","getType");
    json.put("name",name);
    json.put("id","123");

    return json.toString();
}</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E6%89%A9%E5%B1%95Swagger%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%8C%E6%88%90%E7%89%B9%E5%AE%9A%E7%9A%84%E9%9C%80%E6%B1%82">二、第二部分：自定义注解扩展Swagger的功能完成特定的需求</h2> 
<p> </p> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E6%B3%A8%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%9F">（一）注解是什么？如何自定义注解？</h3> 
<p>对于注解的讲解部分，我之前整理过一篇比较详细的文章，此处就不在过多的说明了，可以参考我的下列文章：</p> 
<p>WX公众号：<a href="https://mp.weixin.qq.com/s?__biz=MzI0OTQ5NTk0OQ==&amp;mid=2247484136&amp;idx=1&amp;sn=f93d3d10825f17b24df96dd687951406&amp;chksm=e991ea0adee6631cd5a952d58bdc1667ceaa8e41ed7c172049279302a61878fb1906e455aa3d&amp;mpshare=1&amp;scene=23&amp;srcid=09207mx4MrN9ggkyKum9PXB3&amp;sharer_sharetime=1600569065755&amp;sharer_shareid=11da4dccc61e426c126739760bb9c8ac#rd" rel="nofollow">什么是注解？如何定义注解</a></p> 
<p>CSDM：<a href="https://blog.csdn.net/qq_17623363/article/details/108436543?ops_request_misc=%25252525257B%252525252522request%25252525255Fid%252525252522%25252525253A%252525252522160056918519725254004548%252525252522%25252525252C%252525252522scm%252525252522%25252525253A%25252525252220140713.130102334.pc%25252525255Fall.%252525252522%25252525257D&amp;request_id=160056918519725254004548&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v2-1-108436543.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=%25252525E6%25252525B3%25252525A8%25252525E8%25252525A7%25252525A3+truedei&amp;spm=1018.2118.3001.4187">你说啥什么?注解你还不会？</a></p> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%89%A9%E5%B1%95Swagger%E5%8A%9F%E8%83%BD%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%B1%95%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C">（二）为什么要扩展Swagger功能以及扩展后的效果</h3> 
<p><strong>答：</strong></p> 
<blockquote> 
 <p>当然是Swagger当前的功能不能满足我们当前项目的现状了。</p> 
</blockquote> 
<p>其实Swagger的已有的功能也能满足我们的需求，但是对<code>代码的侵入性太大</code>了。</p> 
<p><strong>一句话了解侵入性：</strong></p> 
<blockquote> 
 <p>当你的代码引入了一个组件,导致其它代码或者设计,要做相应的<strong>更改以适应新组件</strong>.这样的情况我们就认为这个新组件具有<code>侵入性</code>同时,这里又涉及到一个设计方面的概念,就是<strong>耦合性</strong>的问题. 我们代码设计的思路是"<strong>高内聚,低耦合</strong>",为了实现这个思路,就必须<code>降低</code>代码的<code>侵入性</code>. 摘自：<a href="https://blog.csdn.net/nrbw_gzm/article/details/80720496">一句话让你明白代码的侵入性</a></p> 
</blockquote> 
<p>Swagger的优点有很多，有优点，必定有缺点，这是谁也改变不了的，我们能做到的就是减少缺点。</p> 
<p>优点前面已经说了，我总结如下，当然了还有其他的：</p> 
<ul><li>1、可以跟据业务代码自动生成相关的api接口文档，尤其用于restful风格中的项目；</li><li>2、开发人员几乎可以不用专门去维护rest api，这个框架可以自动为你的业务代码生成restfut风格的api；</li><li>3、而且还提供相应的测试界面，自动显示json格式的响应。</li><li>4、大大方便了后台开发人员与前端的沟通与联调成本。</li></ul> 
<p>对于缺点：</p> 
<ul><li>1、不方便维护（当接口变动了，每次都需要去修改相应的参数配置）；</li><li>2、关于Swagger的代码太多，严重的覆盖了原有的java逻辑代码（重点）；</li><li>3、当一个接口有多个响应实例是，不能显示多个，只能显示一个（例如自定义的响应参数：401的响应码就包括：密码错误，参数错误，id错误等）；</li><li>4、当接口接收的参数为json字符串的时候，在Swagger的UI中不能显示JSON字符串中具体的参数（与前端交接会出现问题，前端会不知道他要传递给你什么）；</li></ul> 
<p>本文要解决的问题也是对于缺点的弥补，通过扩展Swagger的功能来解决这些问题。</p> 
<p><strong>反例：</strong></p> 
<blockquote> 
 <p>天哪，这只是一个接口，就占了80多行。</p> 
</blockquote> 
<pre><code class="language-java">@ResponseBody
@RequestMapping(method = RequestMethod.GET)
@ApiOperation(position = 2,value = "9.2.获取人工监管配置",notes = "&lt;p&gt;&lt;strong&gt;请求的url:&lt;/strong&gt;&lt;/p&gt;\n" +
              "&lt;p&gt;/api/background/config/robotMonitorConfig&lt;/p&gt;\n" +
              "&lt;p&gt;&lt;strong&gt;返回的成功数据:&lt;/strong&gt;&lt;/p&gt;\n" +
              "&lt;details&gt; \n" +
              "&lt;summary&gt;点击展开查看&lt;/summary&gt; \n" +
              "&lt;pre&gt;&lt;code class=\"language-json\"&gt;{\n" +
              "\n" +
              "    message: &amp;quot;success&amp;quot;,\n" +
              "\n" +
              "    messageCode:&amp;quot;200&amp;quot;,\n" +
              "\n" +
              "    result: [\n" +
              "\n" +
              "        {\n" +
              "\n" +
              "            id: 1,\n" +
              "\n" +
              "            robotId: 18,\n" +
              "\n" +
              "            authStatus: 1,\n" +
              "\n" +
              "            warnStatus: 1,\n" +
              "\n" +
              "            warnRule: \n" +
              "\n" +
              "            {\n" +
              "\n" +
              "                &amp;quot;angry&amp;quot;:1,\n" +
              "\n" +
              "                &amp;quot;unknown&amp;quot;:1,\n" +
              "\n" +
              "                &amp;quot;down&amp;quot;:1,\n" +
              "\n" +
              "                &amp;quot;sameAnswer&amp;quot;:1,\n" +
              "\n" +
              "                &amp;quot;noClick&amp;quot;:1,\n" +
              "\n" +
              "                &amp;quot;keywords&amp;quot;:1\n" +
              "\n" +
              "            },\n" +
              "\n" +
              "            warnKeywords: \n" +
              "\n" +
              "            [\n" +
              "\n" +
              "                &amp;quot;转人工&amp;quot;,\n" +
              "\n" +
              "                &amp;quot;人工回复&amp;quot;\n" +
              "\n" +
              "            ],\n" +
              "\n" +
              "            operatorId: &amp;quot;qubb&amp;quot;,\n" +
              "\n" +
              "            lastModifyTime: 231431341343123\n" +
              "\n" +
              "        }\n" +
              "\n" +
              "    ]\n" +
              "\n" +
              "}\n" +
              "\n" +
              "&lt;/code&gt;&lt;/pre&gt;\n" +
              "&lt;/details&gt;\n" +
              "&lt;p&gt;&lt;strong&gt;返回的失败数据:&lt;/strong&gt;&lt;/p&gt;\n" +
              "&lt;details&gt; \n" +
              "&lt;summary&gt;点击展开查看&lt;/summary&gt; \n" +
              "&lt;pre&gt;&lt;code class=\"language-json\"&gt;{\n" +
              "    message: &amp;quot;当前用户已退出登陆，请登陆后重试&amp;quot;,\n" +
              "    messageCode:&amp;quot;509&amp;quot;\n" +
              "}\n" +
              "\n" +
              "{\n" +
              "    message: &amp;quot;param robotId error&amp;quot;,\n" +
              "    messageCode:&amp;quot;410&amp;quot;\n" +
              "}\n" +
              "\n" +
              "{\n" +
              "    message: &amp;quot;system error&amp;quot;,\n" +
              "    messageCode:&amp;quot;510&amp;quot;\n" +
              "}\n" +
              "\n" +
              "&lt;/code&gt;&lt;/pre&gt;\n" +
              "&lt;/details&gt;\n" +
              "\n" +
              "\n" +
              "\n")
public Object xxx(@ApiParam(value = "机器人ID",defaultValue = "7",required = true) @RequestParam(value = "robotId", required = false) String robotIdStr) {

}</code></pre> 
<p><strong>经过我对功能的扩展：</strong></p> 
<blockquote> 
 <p>一行代码轻松搞定</p> 
</blockquote> 
<pre><code class="language-java">@APiFileInfo("/xxx")</code></pre> 
<h3 id="%EF%BC%88%E4%B8%89%EF%BC%89%E5%89%8D%E5%A5%8F%E5%87%86%E5%A4%87">（三）前奏准备</h3> 
<h4 id="1%E3%80%81%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84Spring%E7%9A%84%E4%B8%89%E4%B8%AA%E6%B3%A8%E8%A7%A3">1、必须要了解的Spring的三个注解</h4> 
<ul><li>（1）@Component（把普通pojo实例化到spring容器中，相当于配置文件中的）</li><li>（2）@Order(1) （调整这个类被注入的顺序，也可以说是优先级）</li><li>（3）@Configuration （用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。）</li></ul> 
<h4 id="2%E3%80%81Swagger%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6">2、Swagger的可扩展组件</h4> 
<p>在源码中：可以看到下图所示的一些Plugin结尾的接口文件，我们就是要在这些上面做文章的。</p> 
<p>关于具体的介绍，可以去本文最后，去查看另一篇文章，对于这些接口的详细分析，本文不再说明。</p> 
<p><img alt="" height="719" src="https://images2.imgbox.com/1e/40/mO3Ji3uH_o.png" width="631"></p> 
<p> </p> 
<h2 id="%E4%B8%89%E3%80%81%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E5%AE%9E%E6%88%98">三、第三部分：实战</h2> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%9E%E6%88%98%E4%B8%80%EF%BC%9A%E9%92%88%E5%AF%B9%E4%BC%A0%E9%80%92json%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BD%BF%E5%85%B6%E5%85%B7%E6%9C%89%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%8A%9F%E8%83%BD">（一）实战一：针对传递json字符串的参数，使其具有相关参数的描述的功能</h3> 
<h4 id="1%E3%80%81%E9%9C%80%E6%B1%82%E6%9D%A5%E6%BA%90">1、需求来源</h4> 
<blockquote> 
 <p>有需求，就有需求来源或者说是需求的产生。首先要知道为什么会有这个需求呢？我们先来看为什么会有这个需求。</p> 
</blockquote> 
<p>我们拿三个接口做示范吧：</p> 
<pre><code class="language-java">@Controller("/studentController")
@Api(tags = "学生Controller",position = 1)
public class StudentController {

    /**
     * 根据学生ID获取学生信息
     * @param id 学生id
     * @return 返回查询的结果
     */
    @GetMapping("/getStudentById")
    @ApiOperation(value = "根据学生ID获取学生信息",notes = "根据传入的学生ID获取学生信息",position = 1)
    public Object getStudentById(String id){
        return "id="+id;
    }

    /**
     * 添加学生信息
     * @param student 学生的信息
     * @return 返回是否添加成功
     */
    @PostMapping("/addStudent")
    @ApiOperation(value = "添加学生信息",notes = "添加学生信息",position = 1)
    public Object addStudent(@RequestBody Student student){
        return "student="+student.toString();
    }


    /**
     * 含有特殊字段的，添加学生信息
     * @param str 包含两种信息，1：学生信息，2：其他的特殊字段
     * @return 返回是否添加成功
     */
    @PostMapping("/addStudent2")
    @ApiOperation(value = "含有特殊字段的，添加学生信息",notes = "含有特殊字段的，添加学生信息",position = 1)
    public Object addStudentStr(@RequestBody String str){
        return "str="+str;
    }

}</code></pre> 
<p>分析1：</p> 
<blockquote> 
 <p>getStudentById(String id)接口只传递一个id。</p> 
</blockquote> 
<p>页面效果如下：</p> 
<p><img alt="" height="480" src="https://images2.imgbox.com/21/c3/vySU5iBq_o.png" width="1200"></p> 
<p>测试功能页面如下：</p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/ff/d4/7B2jSyx8_o.png" width="1200"></p> 
<p>分析2：</p> 
<blockquote> 
 <p>addStudent(@RequestBody Student student)接口需要传递一个json数据类型的对象。</p> 
</blockquote> 
<p>页面效果如下：</p> 
<p><img alt="" height="694" src="https://images2.imgbox.com/b4/04/za50fEqJ_o.png" width="1200"></p> 
<p>测试功能页面如下：</p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/11/4d/W5KxWxb3_o.png" width="1200"></p> 
<p> </p> 
<p>分析3：（<code>问题就出在这了，注意看哦</code>）</p> 
<blockquote> 
 <p>addStudentStr(@RequestBody String str)接口需要传递一个json数据类型字符串。</p> 
</blockquote> 
<p>页面效果如下：</p> 
<p><img alt="" height="695" src="https://images2.imgbox.com/85/ee/IsrzELkJ_o.png" width="1200"></p> 
<p> </p> 
<p>测试功能页面如下：</p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/85/97/FTnK0KCR_o.png" width="1200"></p> 
<p> </p> 
<h4 id="2%E3%80%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">2、需求分析</h4> 
<p>通过<code>分析1</code>、<code>分析2</code>和<code>分析3</code>，三个实例可知，<code>当传递参数为json字符串的时候，是不会显示具体的参数的。这就造成了前端人员根本就无法知道传递的是什么</code>。</p> 
<p>我们的需求，简单，明了，直接。就是<code>针对传递的参数为json字符串格式的参数时</code>，<code>实现有相关参数的描述的功能</code>。</p> 
<h4 id="3%E3%80%81%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF">3、开发思路</h4> 
<p>（1）走的弯路</p> 
<p>你首先可能想到的是：在自定义一个类呗，里面写上你需求的字段，这样不就有了吗。</p> 
<p>首先这种办法是可以的；</p> 
<p>但是存在的问题也是相当大的，如果我只有几个接口的话，还可以。但是<code>一个项目有几百个接口就需要定义几百个类</code>。经过团队讨论，这种方法被kill了。</p> 
<p> </p> 
<p> </p> 
<p>（2）正确的路</p> 
<blockquote> 
 <p>可以自定义一个注解，把注解加在需要加的参数上。然后通过注解的传值，去自动生成类。</p> 
</blockquote> 
<p>这种方法是可行的。</p> 
<p>有很多可以动态创建类的方法，经过我亲自实践，选择了：<code>Javassist的ClassPool机制</code>。</p> 
<p>如果对ClassPool有兴趣的话，可以自行查阅资料去了解下，此处就不在过多赘述了。</p> 
<h4 id="4%E3%80%81%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81">4、关键代码</h4> 
<p>关于自定义的注解，描述的很详细，就不多说了。</p> 
<p><code>@Apicp注解的定义</code>：</p> 
<pre><code class="language-java">package com.github.swaggerplugin.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author zhenghui
 * @date 2020年9月17日17:00:25
 * @desc 需要的属性的值
 */
@Target({ElementType.PARAMETER, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Apicp {
    Class&lt;?&gt; classPath();//对象的原始class地址，必填
    String modelName();//自定义 Model的名字，必填
    String values()[]; //原始对象中已经存在的对象属性名字 ，必填
    String noValues()[] default {} ;//原始对象中不存在的对象属性名字，非必填
    String noValueTypes()[] default {};//原始对象中不存在的对象属性的类型，基本类型例如：String等，非必填
    String noVlaueExplains()[] default {};//自定义变量的参数说明 非必填
}</code></pre> 
<p><code>@ApiIgp注解的定义</code>：</p> 
<pre><code class="language-java">package com.github.swaggerplugin.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author zhenghui
 * @date 2020年9月17日17:00:49
 * @desc 排除不需要的属性的值
 */
@Target({ElementType.PARAMETER, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface ApiIgp {
    Class&lt;?&gt; classPath();//对象的原始class地址，必填
    String modelName();//自定义 Model的名字，必填
    String values()[]; //原始对象中已经存在的对象属性名字 ，必填
    String noValues()[] default {} ;//原始对象中不存在的对象属性名字，非必填
    String noValueTypes()[] default {};//原始对象中不存在的对象属性的类型，基本类型例如：String等，非必填
    String noVlaueExplains()[] default {};//自定义变量的参数说明 非必填
}</code></pre> 
<p>自定义完了注解，但是怎么让他起作用呢？这是一步最关键的地方。</p> 
<p>在Spring中的自动装配原理，可以去了解下。在本项目中，我们使用的是Spring的<code>@Component</code>注解或者<code>@Configuration</code>注解来实现的自动注入到pojo中。前面已经介绍了这俩注解的作用。</p> 
<p>通过翻阅<code>SpringFox（Swagger）</code>和<code>knife4j-spring-boot</code>的源代码，我发现如果自定义扩展功能的话，只需要实现某个<code>xxxPlugin</code>的接口中的<code>apply</code>方法就可以。<code>apply</code>方法中我们去手动扫描我们自定义的注解，然后加上相关实现的逻辑即可。</p> 
<p>代码是没放全的，太长了，只选择了部分来放。感兴趣的话，可以去我的github上拉取，随后我还会说如何直接应用的办法。</p> 
<pre><code class="language-java">/**
 * 针对传值的参数自定义注解
 * @author zhenghui
 * @date 2020年9月13日13:25:18
 * @desc 读取自定义的属性并动态生成model
 */
@Configuration
@Order(-19999)   //plugin加载顺序，默认是最后加载
public class SwaggerModelReader implements ParameterBuilderPlugin {

    @Autowired
    private TypeResolver typeResolver;

    static final Map&lt;String,String&gt; MAPS = new HashMap&lt;&gt;();
    static {
        MAPS.put("byte","java.lang.Byte");
        MAPS.put("short","java.lang.Short");
        MAPS.put("integer","java.lang.Integer");
        MAPS.put("long","java.lang.Long");
        MAPS.put("float","java.lang.Float");
        MAPS.put("double","java.lang.Double");
        MAPS.put("char","java.lang.Character");
        MAPS.put("string","java.lang.String");
        MAPS.put("boolean","java.lang.Boolean");
    }

    //根据用户自定义的类型拿到该类型所在的包的class位置
    static public String getTypePath(String key){
        return key==null || !MAPS.containsKey(key.toLowerCase()) ? null :  MAPS.get(key.toLowerCase());
    }


    @Override
    public void apply(ParameterContext context) {
        ResolvedMethodParameter methodParameter = context.resolvedMethodParameter();

        //自定义的注解
        Optional&lt;ApiIgp&gt; apiIgp = methodParameter.findAnnotation(ApiIgp.class);
        Optional&lt;Apicp&gt; apicp = methodParameter.findAnnotation(Apicp.class);



        if (apiIgp.isPresent() || apicp.isPresent()) {
            Class originClass = null;
            String[] properties = null; //注解传递的参数
            Integer annoType = 0;//注解的类型
            String name = null + "Model" + 1;  //model 名称  //参数名称

            String[] noValues = null;
            String[] noValueTypes = null;
            String[] noVlaueExplains = null;
            //拿到自定义注解传递的参数
            if (apiIgp.isPresent()){
                properties = apiIgp.get().values(); //排除的
                originClass = apiIgp.get().classPath();//原始对象的class
                name = apiIgp.get().modelName() ;  //model 名称  //参数名称

                noValues = apiIgp.get().noValues();
                noValueTypes = apiIgp.get().noValueTypes();
                noVlaueExplains = apiIgp.get().noVlaueExplains();

            }else {
                properties = apicp.get().values(); //需要的
                annoType = 1;
                originClass = apicp.get().classPath();//原始对象的class
                name = apicp.get().modelName() ;//自定义类的名字
                noValues = apicp.get().noValues();
                noValueTypes = apicp.get().noValueTypes();
                noVlaueExplains = apicp.get().noVlaueExplains();
            }

            //生成一个新的类
            Class newClass = createRefModelIgp(properties, noValues, noValueTypes, noVlaueExplains, name, originClass, annoType);


            context.getDocumentationContext()
                    .getAdditionalModels()
                    .add(typeResolver.resolve(newClass));  //向documentContext的Models中添加我们新生成的Class


            context.parameterBuilder()  //修改model参数的ModelRef为我们动态生成的class
                    .parameterType("body")
                    .modelRef(new ModelRef(name))
                    .name(name);

        }


    }

    /**
     *
     * @param properties annoType=1:需要的  annoType=0:排除的
     * @param noValues
     * @param noValueTypes
     * @param noVlaueExplains
     * @param name 创建的mode的名称
     * @param origin
     * @param annoType 注解的类型
     * @return
     */
    private Class createRefModelIgp(String[] properties, String[] noValues, String[] noValueTypes, String[] noVlaueExplains, String name, Class origin, Integer annoType) {
       ..........
    }


    @Override
    public boolean supports(DocumentationType delimiter) {
        return true;
    }

    /**
     * 根据propertys中的值动态生成含有Swagger注解的javaBeen
     *
     * @param dealFileds  原始对象中已经存在的对象属性名字
     * @param noDealFileds  原始对象中不存在的对象属性名字
     * @param noDealFiledTypes 原始对象中不存在的对象属性的类型，八大基本类型例如：dounle等，还有String
     * @param noDealFiledExplains  自定义变量的参数说明
     * @param ctClass 源class
     * @throws CannotCompileException
     * @throws NotFoundException
     * @throws ClassNotFoundException
     */
    public void createCtFileds(List&lt;Field&gt; dealFileds, List&lt;String&gt; noDealFileds, List&lt;String&gt; noDealFiledTypes,List&lt;String&gt; noDealFiledExplains, CtClass ctClass, Integer annoType) {
    ........

    }
}</code></pre> 
<h4 id="5%E3%80%81%E5%AE%9E%E6%88%98%E6%88%90%E6%9E%9C">5、实战成果</h4> 
<p>我们修改接口如下：</p> 
<pre><code class="language-java">/**
* 含有特殊字段的，添加学生信息
* @param str 包含两种信息，1：学生信息，2：其他的特殊字段
* @return 返回是否添加成功
*/
@PostMapping("/addStudent2")
@ApiOperation(value = "含有特殊字段的，添加学生信息",notes = "含有特殊字段的，添加学生信息",position = 1)
public Object addStudentStr(@Apicp(values = {"Id","name"}, //Student类中已经存在的
                                   modelName = "addStudent2", //自定义Model的名字，也是要生成的类名
                                   classPath = Student.class, //原始的类
                                   noValues = {"lala","haha","xixi"}, //原始的类中没有的参数
                                   noValueTypes = {"string","integer","double"},//原始的类中没有的参数的类型
                                   noVlaueExplains = {"啦啦","哈哈","嘻嘻"})//原始的类中没有的参数的描述
                            @RequestBody String str){
    return "str="+str;
}</code></pre> 
<p> </p> 
<p>效果：</p> 
<blockquote> 
 <p>可以看到，我们自定义的注解起作用了，而且参数名称，参数说明，数据类型都有了。 注：是否必须这个选项，下次升级，就会有了。</p> 
</blockquote> 
<p><img alt="" height="713" src="https://images2.imgbox.com/d4/47/u3Ss4P5k_o.png" width="1200"></p> 
<p>在调试的时候，也可以看到，也有了：</p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/6a/33/tl8lG0Ba_o.png" width="1200"></p> 
<p> </p> 
<p>这样就不用我们再去手动为几百个接口创建几百个类了。</p> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AE%9E%E6%88%98%E4%BA%8C%EF%BC%9A%E5%87%8F%E5%B0%91%E5%9C%A8Controller%E4%B8%ADSwagger%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%BF%E5%85%B6%E5%8F%AF%E4%BB%A5%E4%BB%8E%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AESwagge%E7%9A%84%E5%8A%9F%E8%83%BD">（二）实战二：减少在Controller中Swagger的代码，使其可以从某些文件中读取信息，自动配置Swagge的功能</h3> 
<h4>1、需求来源</h4> 
<p>我们需要对接口的返回值进行描述，例如：</p> 
<p>code为200的返回值：（来源：我从简书上的api返回的结果拷贝过来的）</p> 
<pre><code class="language-java">[
    {
        "id":62564697,
        "slug":"09c7db472fa6",
        "title":"Java的SPI机制",
        "view_count":42,
        "user":{
            "id":12724216,
            "nickname":"bdqfork",
            "slug":"a2329f464833",
            "avatar":"https://upload.jianshu.io/users/upload_avatars/12724216/6f2b07cc-e9bf-440d-a6ad-49fbaa3b49ce.jpg"
        }
    },
    {
        "id":62564140,
        "slug":"ec3bd614dcb0",
        "title":"SLF4J日志级别以及使用场景",
        "view_count":381,
        "user":{
            "id":12724216,
            "nickname":"bdqfork",
            "slug":"a2329f464833",
            "avatar":"https://upload.jianshu.io/users/upload_avatars/12724216/6f2b07cc-e9bf-440d-a6ad-49fbaa3b49ce.jpg"
        }
    }
]</code></pre> 
<p>code为410的返回值：</p> 
<pre><code class="language-java">{
    "messageCode": 410,
    "message": "姓名不能为空"
}</code></pre> 
<p>code为509的返回值：</p> 
<pre><code class="language-java">{
    "messageCode": 509,
    "message": "姓名长度不超过15"
}

{
    "messageCode": 509,
    "message": "姓名数量不能超过15个"
}

{
    "messageCode": 509,
    "message": "姓名已存在"
}

{
    "messageCode": 509,
    "message": "存在姓名，暂不可新增"
}</code></pre> 
<p>code为510的返回值：</p> 
<pre><code class="language-java">{
    "messageCode": 510,
    "message": "system error"
}</code></pre> 
<p>我们可以这样加：</p> 
<pre><code class="language-java">  /**
     * 根据学生ID获取学生信息
     * @param id 学生id
     * @return 返回查询的结果
     */
    @GetMapping("/getStudentById")
    @ApiOperation(value = "根据学生ID获取学生信息",notes = "" +
            "[\n" +
            "    {\n" +
            "        \"id\":62564697,\n" +
            "        \"slug\":\"09c7db472fa6\",\n" +
            "        \"title\":\"Java的SPI机制\",\n" +
            "        \"view_count\":42,\n" +
            "        \"user\":{\n" +
            "            \"id\":12724216,\n" +
            "            \"nickname\":\"bdqfork\",\n" +
            "            \"slug\":\"a2329f464833\",\n" +
            "            \"avatar\":\"https://upload.jianshu.io/users/upload_avatars/12724216/6f2b07cc-e9bf-440d-a6ad-49fbaa3b49ce.jpg\"\n" +
            "        }\n" +
            "    },\n" +
            "    {\n" +
            "        \"id\":62564140,\n" +
            "        \"slug\":\"ec3bd614dcb0\",\n" +
            "        \"title\":\"SLF4J日志级别以及使用场景\",\n" +
            "        \"view_count\":381,\n" +
            "        \"user\":{\n" +
            "            \"id\":12724216,\n" +
            "            \"nickname\":\"bdqfork\",\n" +
            "            \"slug\":\"a2329f464833\",\n" +
            "            \"avatar\":\"https://upload.jianshu.io/users/upload_avatars/12724216/6f2b07cc-e9bf-440d-a6ad-49fbaa3b49ce.jpg\"\n" +
            "        }\n" +
            "    }\n" +
            "]",position = 1)
    
    public Object getStudentById(String id){
        return "id="+id;
    }</code></pre> 
<p>页面效果：</p> 
<p><img alt="" height="571" src="https://images2.imgbox.com/39/5b/B4cTg1ZL_o.png" width="1200"></p> 
<p>我们要做的就是来纠正这个。</p> 
<p>而且这一个200的接口描述就占了一个屏幕：</p> 
<p><img alt="" height="712" src="https://images2.imgbox.com/5a/00/5UXjbi8F_o.png" width="1157"></p> 
<p> </p> 
<p>当一个controller有好多个接口该如何是好的，一定会被接口的描述所覆盖的。这就是我们需求的来源。</p> 
<h4>2、需求分析</h4> 
<p>看到页面效果</p> 
<p>你可能会有疑惑为什么加了\n也不能回车显示，我去查阅了Swagger的UI源码是如何展现出来的。原理是通过makdown的方式，通过渲染得到的。所以我们可以把makdown的语法转换成html语法进行实现，经过我编写的转换小工具之后，发现是可以的。</p> 
<h4>3、开发思路</h4> 
<p>先去网上查查是否有相应的转换工具。</p> 
<p>我们先引入一下，就是通过这个来做转换的:</p> 
<pre><code class="language-java">&lt;!--makdown to html--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.vladsch.flexmark&lt;/groupId&gt;
    &lt;artifactId&gt;flexmark-all&lt;/artifactId&gt;
    &lt;version&gt;0.50.42&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>实现的代码很简单：</p> 
<pre><code class="language-java">//makdown语法转换成html语法的工具
MutableDataSet options = new MutableDataSet();
Parser parser = Parser.builder(options).build();
HtmlRenderer renderer = HtmlRenderer.builder(options).build();

// You can re-use parser and renderer instances
Node document = parser.parse(mdBody.toString());

//转换成html
String html = renderer.render(document);  // "&lt;p&gt;This is &lt;em&gt;Sparta&lt;/em&gt;&lt;/p&gt;\n"</code></pre> 
<p>运行之后就会得到转换后的html语法：</p> 
<p><img alt="" height="654" src="https://images2.imgbox.com/cd/53/B8D5RoD1_o.png" width="1200"></p> 
<p>我们把转换后的html代码复制到接口描述中：</p> 
<pre><code class="language-java">/**
     * 根据学生ID获取学生信息
     * @param id 学生id
     * @return 返回查询的结果
     */
@GetMapping("/getStudentById")
@ApiOperation(value = "根据学生ID获取学生信息",notes = "" +
              "&lt;pre&gt;&lt;code class=\"language-json\"&gt;[\n" +
              "    {\n" +
              "        &amp;quot;id&amp;quot;:62564697,\n" +
              "        &amp;quot;slug&amp;quot;:&amp;quot;09c7db472fa6&amp;quot;,\n" +
              "        &amp;quot;title&amp;quot;:&amp;quot;Java的SPI机制&amp;quot;,\n" +
              "        &amp;quot;view_count&amp;quot;:42,\n" +
              "        &amp;quot;user&amp;quot;:{\n" +
              "            &amp;quot;id&amp;quot;:12724216,\n" +
              "            &amp;quot;nickname&amp;quot;:&amp;quot;bdqfork&amp;quot;,\n" +
              "            &amp;quot;slug&amp;quot;:&amp;quot;a2329f464833&amp;quot;,\n" +
              "            &amp;quot;avatar&amp;quot;:&amp;quot;https://upload.jianshu.io/users/upload_avatars/12724216/6f2b07cc-e9bf-440d-a6ad-49fbaa3b49ce.jpg&amp;quot;\n" +
              "        }\n" +
              "    },\n" +
              "    {\n" +
              "        &amp;quot;id&amp;quot;:62564140,\n" +
              "        &amp;quot;slug&amp;quot;:&amp;quot;ec3bd614dcb0&amp;quot;,\n" +
              "        &amp;quot;title&amp;quot;:&amp;quot;SLF4J日志级别以及使用场景&amp;quot;,\n" +
              "        &amp;quot;view_count&amp;quot;:381,\n" +
              "        &amp;quot;user&amp;quot;:{\n" +
              "            &amp;quot;id&amp;quot;:12724216,\n" +
              "            &amp;quot;nickname&amp;quot;:&amp;quot;bdqfork&amp;quot;,\n" +
              "            &amp;quot;slug&amp;quot;:&amp;quot;a2329f464833&amp;quot;,\n" +
              "            &amp;quot;avatar&amp;quot;:&amp;quot;https://upload.jianshu.io/users/upload_avatars/12724216/6f2b07cc-e9bf-440d-a6ad-49fbaa3b49ce.jpg&amp;quot;\n" +
              "        }\n" +
              "    }\n" +
              "]\n" +
              "&lt;/code&gt;&lt;/pre&gt;\n" +
              "\n" +
              "\n" +
              "",position = 1)
public Object getStudentById(String id){
    return "id="+id;
}</code></pre> 
<p>再次看一下效果：</p> 
<p><img alt="" height="712" src="https://images2.imgbox.com/47/5a/tv33K8MN_o.png" width="1200"></p> 
<p> </p> 
<p>果然是可以的。</p> 
<hr> 
<p><code>但是如果有几百个接口的话，你还去一个一个去复制粘贴吗？</code></p> 
<p>下面就是来解决当有大量接口的时候如何办的问题。</p> 
<h4>4、关键代码</h4> 
<p>关于makdown转换成html语法的代码如下：</p> 
<blockquote> 
 <p>我是做了升级的，当遇到代码块的时候会变成折叠的。</p> 
</blockquote> 
<pre><code class="language-java">public class MdToHtml {
    /**
     * @param md makdown语法
     * @return html语法
     */
    public final static String makdownToHtml(String md) {
        StringBuilder mdBody = new StringBuilder();

        //遍历传递过来的md，查找到```xxx开头的 一直到```结尾的
        for (int i = 0; i &lt; md.length() ; i++) {
            //重新构造一个```json  ```代码块
            StringBuilder newCodeBody = new StringBuilder();
            newCodeBody.append("\n\n");
            newCodeBody.append("&lt;details&gt; \n");
            newCodeBody.append("\n");
            newCodeBody.append("&lt;summary&gt;点击展开查看&lt;/summary&gt; \n");

            //code body start  ```开始
            if(md.charAt(i)=='`' &amp;&amp; md.charAt(i+1)=='`' &amp;&amp; md.charAt(i+2)=='`'){

                String temp = md.substring(i+3);//开始分割```
                int strIndex = findStrIndex(temp);//查找```之后的代码类型例如：```java，```json等，查找结束的位置

                String codeType = md.substring(i + 3, i + 3 + strIndex);//保留代码的类型

                newCodeBody.append("\n```"+codeType+"\n");//重新合并类型

                //从代码块的类型开始例如：```json之后开始  +1：代码块类型之后的回车   ```结束
                for (int j = i+3+strIndex+1; j &lt; md.length() ; j++) {
                    //code body end  遇到```代码块结束了
                    if(md.charAt(j)=='`' &amp;&amp; md.charAt(j+1)=='`' &amp;&amp; md.charAt(j+2)=='`'){
                        i=j+3; //让i跳过去```json  到```中的代码

                        //追加上```代码块的结尾
                        newCodeBody.append("\n```\n");

                        //追加上折叠代码块的结尾
                        newCodeBody.append("\n");
                        newCodeBody.append("&lt;/details&gt;");
                        newCodeBody.append("\n");

                        break;//跳出本次循环 代表```json  此代码块 ```  结束了
                    }else{
                        //组合code body内的代码
                        newCodeBody.append(md.charAt(j));
                    }
                }

                //代码整合结束后，把整合后的代码追加到makdown的Body中
                mdBody.append(newCodeBody.toString());

            }else{
                //其他的代码一律直接追加到makdown body中
                mdBody.append(md.charAt(i));
            }
        }

        //makdown语法转换成html语法的工具
        MutableDataSet options = new MutableDataSet();
        Parser parser = Parser.builder(options).build();
        HtmlRenderer renderer = HtmlRenderer.builder(options).build();

        // You can re-use parser and renderer instances
        Node document = parser.parse(mdBody.toString());

        //转换成html
        String html = renderer.render(document);  // "&lt;p&gt;This is &lt;em&gt;Sparta&lt;/em&gt;&lt;/p&gt;\n"

        return html;
    }

    static private int findStrIndex(String str){
        int sum = 0;
        for (int i = 0; i &lt;str.length() ; i++) {
            if(str.charAt(i)=='\n')
                return sum++;
            else
                sum++;
        }
        return -1;
    }
    
}</code></pre> 
<p>如果用了，效果会是这样：</p> 
<p><img alt="" height="649" src="https://images2.imgbox.com/20/4c/WcimW4XF_o.png" width="1200"></p> 
<p> </p> 
<p>可以展开，可以合上。</p> 
<blockquote> 
 <p>纯粹是利用了makdown的语法来实现的。</p> 
</blockquote> 
<p><img alt="" height="682" src="https://images2.imgbox.com/bb/01/ZMx7hv4h_o.png" width="1183"></p> 
<p> </p> 
<p>依然首先自定义一个注解：</p> 
<pre><code class="language-java">package com.github.swaggerplugin.annotation;


import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.PARAMETER, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface APiFileInfo {

    String value() default "";//url,flag 在某文档中存放的一个标志
}</code></pre> 
<p>该注解的实现：</p> 
<blockquote> 
 <p><code>实现是非常简单的</code>，<code>难的是如何解析。</code></p> 
</blockquote> 
<pre><code class="language-java">/**
 * 针对方法自定义注解
 * @author zhenghui
 * @date 2020年9月13日13:25:18
 * @desc 读取自定义的属性并动态生成model
 * OperationBuilderPlugin：对方法起作用
 */
@Component
@Order(1)
public class OperationPositionBulderPlugin implements OperationBuilderPlugin {
    @Autowired
    private TypeResolver typeResolver;

    static Map&lt;String,Map&lt;Integer, APiFileInfoBean&gt;&gt; apiFileInfoMaps = null;


    public static String swaggerMdPaths  = "src/main/resources/md";

    private static boolean flag = false;

    @Value("${swagger.md.paths}")
    private void setSwaggerMdPaths(String swaggerMdPaths){
        OperationPositionBulderPlugin.swaggerMdPaths = swaggerMdPaths;
    }

    // 解析文件
    public OperationPositionBulderPlugin() {
        String[] paths = swaggerMdPaths.split(",");

        System.out.println("开始解析文件了------------&gt;&gt;&gt;&gt;");
        System.out.println("文件地址："+Arrays.toString(paths));
//        Map&lt;String,Map&lt;Integer,APiFileInfoBean&gt;&gt; apiFileInfoMaps = initFile(new String[]{"src/main/resources/md/md.md"});
        if(apiFileInfoMaps==null) {
            apiFileInfoMaps = ReadFromFile.initFileOrDirectory(paths);
            flag=apiFileInfoMaps==null?false:true;
        }
    }

    @Override
    public void apply(OperationContext context) {

        if(flag){
            System.out.println("有文件，加载："+flag);

        //1、查找是否定义了说明文件的所在位置
//        Optional&lt;ApiFIleURI&gt; apiFIleURIOptional = context.findAnnotation(ApiFIleURI.class);
//        if(apiFIleURIOptional.isPresent()){

//            String mdFileURIs[] = apiFIleURIOptional.get().vlaue();//拿到文件的所在位置

            //2、查找APiFileInfo注解，
            Optional&lt;APiFileInfo&gt; apiFileInfoOptional = context.findAnnotation(APiFileInfo.class);

            if (apiFileInfoOptional.isPresent()) {

                String flag = null;//获取URL（URL作用是定位到）

                System.out.println("apiFileInfoOptional---&gt;"+apiFileInfoOptional.get().value());
                flag = apiFileInfoOptional.get().value();//获取标志，标志：在文件中所在的位置

                //构建消息
                context.operationBuilder()
                        .responseMessages(buildResponseMessage(flag, apiFileInfoMaps));
            }

//        }


        }else {
            System.out.println("没有文件，不加载");
        }
    }

    /**
     * 构造ResponseMessage
     * @param flag 该消息说明描述的文本所在的位置
     * @param apiFileInfoMaps
     * @return
     */
    private Set&lt;ResponseMessage&gt; buildResponseMessage(String flag, Map&lt;String, Map&lt;Integer,APiFileInfoBean&gt;&gt; apiFileInfoMaps) {

        Map&lt;Integer,APiFileInfoBean&gt; aPiFileInfoBean = apiFileInfoMaps.get(flag);
        Set&lt;ResponseMessage&gt; set = new HashSet&lt;&gt;();
        ResponseMessage responseMessage = null;
        if(aPiFileInfoBean!=null)
        for (Integer code : aPiFileInfoBean.keySet()) {

            APiFileInfoBean fileInfoBean = aPiFileInfoBean.get(code);
            responseMessage = new ResponseMessageBuilder()
                                    .code(code)
                                    .message(MdToHtml.makdownToHtml(fileInfoBean.getMessage()))
                                    .responseModel(new ModelRef("UpdateRobotModel"))
                                    .build();
//            responseMessage = new ResponseMessage(code, MdToHtml.makdownToHtml(fileInfoBean.getMessage()), null,new HashMap&lt;&gt;(),new LinkedList&lt;&gt;());
            set.add(responseMessage);
        }

        return set;
    }


}</code></pre> 
<p>解析文件内容：</p> 
<blockquote> 
 <p>代码中有很多遗留的debug的打印语句，可以忽略。</p> 
</blockquote> 
<pre><code class="language-java">package com.github.swaggerplugin.util;



import com.github.swaggerplugin.bean.APiFileInfoBean;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

//文件解析工具
public class ReadFromFile {

    /**
     * 解析文件
     * @param mdFileURIs
     * @return
     */
    public static Map&lt;String, Map&lt;Integer, APiFileInfoBean&gt;&gt; initFileOrDirectory(String[] mdFileURIs) {

        Map&lt;String, Map&lt;Integer,APiFileInfoBean&gt;&gt; map = new HashMap&lt;&gt;();

        for (String fileURIs : mdFileURIs) {
            File file = new File(fileURIs);

            //是文件夹
            if(file!=null &amp;&amp; !file.isFile()){
                //解析目录中的文件
                initDirectory(map,file);
                //是文件
            }else if(file!=null &amp;&amp; file.isFile()){
                //解析单个文件
                initFile(map,file);
            }
        }

        return map.size()&lt;=0?null:map;
    }


    
..........
   
}</code></pre> 
<h4>5、实战成果</h4> 
<p>我们的成果就是完成了一个注解。</p> 
<p>注解：<code>APiFileInfo("flag")</code></p> 
<p>然后该注解就会从相应的文件中按规则进行解析出来。</p> 
<p>xxxx.md文件存放在<code>src/main/resources/md</code>下，内容如下：</p> 
<pre><code class="language-java"># URL:/getStudentById

---

code:200

**这是200响应码的描述**

```json
 [

{
"id":62564697,

"slug":"09c7db472fa6",

"title":"Java的SPI机制",

"view_count":42,

"user":{

"id":12724216,
"nickname":"bdqfork",
"slug":"a2329f464833",
"avatar":"[https://upload.jianshu.io/users/upload\_avatars/12724216/6f2b07cc-e9bf-440d-a6ad-49fbaa3b49ce.jpg](https://upload.jianshu.io/users/upload_avatars/12724216/6f2b07cc-e9bf-440d-a6ad-49fbaa3b49ce.jpg)"
}

},
{
"id":62564140,

"slug":"ec3bd614dcb0",

"title":"SLF4J日志级别以及使用场景",

"view_count":381,

"user":{

"id":12724216,
"nickname":"bdqfork",
"slug":"a2329f464833",
"avatar":"[https://upload.jianshu.io/users/upload\_avatars/12724216/6f2b07cc-e9bf-440d-a6ad-49fbaa3b49ce.jpg](https://upload.jianshu.io/users/upload_avatars/12724216/6f2b07cc-e9bf-440d-a6ad-49fbaa3b49ce.jpg)"
}

}
]

---

code:410

### 517状态码的描述
{
"messageCode": 410,

"message": "姓名不能为空"

}
code:509

510测试描述
{
"messageCode": 509,

"message": "姓名长度不超过15"

}

{
"messageCode": 509,

"message": "姓名数量不能超过15个"

}

{
"messageCode": 509,

"message": "姓名已存在"

}

{
"messageCode": 509,

"message": "存在姓名，暂不可新增"

}
</code></pre> 
<pre><code class="language-java">接口代码修改如下：

&gt; 这样是不是就很方便了，不在有大批量的代码，也不会显得特别的乱了。/\*\* \* 根据学生ID获取学生信息
&gt;  \* @param id 学生id
&gt;  \* @return 返回查询的结果
&gt;  \*/@GetMapping("/getStudentById")
&gt; @ApiOperation(value = "根据学生ID获取学生信息",notes = "",position = 1)
&gt; @APiFileInfo("/getStudentById")
&gt; public Object getStudentById(String id){
&gt;     return "id="+id;
&gt; }效果如下：

![image-20200920231253773.png](https://ask8088-private-1251520898.cn-south.myqcloud.com/developer-images/article/1150278/mw5xi83jyz.png?q-sign-algorithm=sha1&amp;q-ak=AKID2uZ1FGBdx1pNgjE3KK4YliPpzyjLZvug&amp;q-sign-time=1600618420;1600625620&amp;q-key-time=1600618420;1600625620&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=be2b935f1933d95715d6cd4ac23cffc263259b53)

是不是很方便了，看着还有多余的状态码，401,403这些事系统默认的，我们可以关闭：

![image-20200920231454557.png](https://ask8088-private-1251520898.cn-south.myqcloud.com/developer-images/article/1150278/evj4uz9zdn.png?q-sign-algorithm=sha1&amp;q-ak=AKID2uZ1FGBdx1pNgjE3KK4YliPpzyjLZvug&amp;q-sign-time=1600618432;1600625632&amp;q-key-time=1600618432;1600625632&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=67789070a834c1b786b283ac7afa13dd86b66c2f) return new Docket(DocumentationType.SWAGGER\_2)
        .useDefaultResponseMessages(false)再来看就比较简洁了：
![image-20200920231538323.png](https://ask8088-private-1251520898.cn-south.myqcloud.com/developer-images/article/1150278/wfukxooki5.png?q-sign-algorithm=sha1&amp;q-ak=AKID2uZ1FGBdx1pNgjE3KK4YliPpzyjLZvug&amp;q-sign-time=1600618443;1600625643&amp;q-key-time=1600618443;1600625643&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=5f8bcea5c7cef639f4ee13c21b784e6e3f0a6e9d)

# 四、第四部分：如何直接在项目中应用

1、持续关注此GitHub仓库：[https://github.com/8042965/swagger-plugin](https://github.com/8042965/swagger-plugin)

2、拉取该仓库代码；

3、想办法引入到你的项目中；

4、使用步骤很简单和前面第三部分实战环节的一样，通过注解就可以了。

也可以加我的微信进行交流：weiyi3700，QQ也行：8042965

也可以关注我的微信公众号：TrueDei，回复swagger-plugin也可以拿到。

# 五、第五部分：应该注意的地方

## 1、自定义注解时，@Order()注解如何有效的使用？

&gt; 如何你想调整这个类被注入的顺序，也可以说是优先级。
&gt; 那么我们可以通过调整@Order的值来调整类执行顺序的优先级，即执行的先后。
&gt; 这就是@Order注解的作用。

该注解默认的优先级：

&gt; 如果不指定，那么就会使用默认的这个优先级级别。
&gt; 可想而知，如果你有个东西需要先加载的话，如果不指定，或者指定的优先级级别很低，那么很`有可能加载不出来`。我就遇到了这个问题。@Retention(RetentionPolicy.RUNTIME)
&gt; @Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})

@Documented

public @interface Order {
int value() default 2147483647;

}再来看一下`Ordered`这个接口：public interface Ordered {
int HIGHEST_PRECEDENCE = -2147483648;

int LOWEST_PRECEDENCE = 2147483647;

int getOrder();
}

这个类可把我害惨了，具体怎么参的，请看：

当我自定义一个注解，并想使用Spring注入到bean中：

&gt; 我从网上查的是使用@Order(Ordered.HIGHEST\_PRECEDENCE)这个注解来指定顺序，由于指定好之后并没有去看一下具体是做什么的，就导致有些参数是无法被加载到的。@Component@Order(Ordered.HIGHEST\_PRECEDENCE)//@Order(1)public class OperationPositionBulderPlugin implements OperationBuilderPlugin {	.........忽略代码
}

可以看到我已经指定好了200的相关数据，但是并没有起到效果。

![image-20200917150646589.png](https://ask8088-private-1251520898.cn-south.myqcloud.com/developer-images/article/1150278/wkm7yajxlm.png?q-sign-algorithm=sha1&amp;q-ak=AKID2uZ1FGBdx1pNgjE3KK4YliPpzyjLZvug&amp;q-sign-time=1600618459;1600625659&amp;q-key-time=1600618459;1600625659&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=3516aaf4ebde6c2912a30eb2ad5824fe70e8268a)

解决办法：切换个高优先级：
@Component

//@Order(Ordered.HIGHEST_PRECEDENCE)

@Order(999999)

public class OperationPositionBulderPlugin implements OperationBuilderPlugin {

........

}

再来看一下：

![image-20200917150831898.png](https://ask8088-private-1251520898.cn-south.myqcloud.com/developer-images/article/1150278/ovfvvyas89.png?q-sign-algorithm=sha1&amp;q-ak=AKID2uZ1FGBdx1pNgjE3KK4YliPpzyjLZvug&amp;q-sign-time=1600618471;1600625671&amp;q-key-time=1600618471;1600625671&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=c0c4d91e9ed0c5b5c8757e880b54aa39f880bcc0)

@Order实验，来源：

[https://blog.csdn.net/yaomingyang/article/details/86649072](https://blog.csdn.net/yaomingyang/article/details/86649072)
@Component

@Order(1)

public class BlackPersion implements CommandLineRunner {

@Override
public void run(String... args) throws Exception {
System.out.println("----BlackPersion----");

}
}

@Component

@Order(0)

public class YellowPersion implements CommandLineRunner {

@Override
public void run(String... args) throws Exception {
System.out.println("----YellowPersion----");

}
}

打印结果：
----YellowPersion----

----BlackPersion----

</code></pre> 
<h2 id="%E5%85%AD%E3%80%81%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%EF%BC%9A%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5%E3%80%81%E8%B5%84%E6%96%99%E7%AD%89">六、第六部分：相关链接、资料等</h2> 
<p>1、<a href="https://www.xiaominfo.com/2019/05/20/springfox-0/" rel="nofollow">八一菜刀springfox源码解读</a></p> 
<p>2、<a href="https://www.cnblogs.com/three-fighter/p/12346184.html" rel="nofollow">Swagger常用注解</a></p> 
<p>3、<a href="https://blog.csdn.net/nrbw_gzm/article/details/80720496">一句话让你明白代码的侵入性</a></p> 
<p>所有的代码均放在：</p> 
<p>GitHub仓库：<a href="https://github.com/8042965/swagger-plugin">https://github.com/8042965/swagger-plugin</a></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35eac2bff82510b26c4251f70cb31293/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue遍历map对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fd12dd5175ec7afcc96a90942b2ea2f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一、Python复习教程（重点）- 基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>