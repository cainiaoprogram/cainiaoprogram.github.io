<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（五）如何设置收件人信息 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（五）如何设置收件人信息" />
<meta property="og:description" content="发件人和收件人是邮件和消息很常用的几个属性之一，关于发件人的设置和获取是很简单的，只需要处理PR_SENDER_EMAIL_ADDRESS属性即可，下面主要讲述的收件人的设置和获取。
MAPI收件人结构如图（摘自MSDN）:
每一个Entry代表了一个收件人信息组，每个信息组又可以有多项信息组成，举个例子，下面的代码代表了一个收件人的信息：
aEntries[0].rgPropVals[0].ulPropTag = PR_RECIPIENT_TYPE; //类型，MAPI_TO代表是设置到TO字段上的，相应的还有MAPI_CC和MAPI_BCC。
aEntries[0].rgPropVals[0].Value.ul = MAPI_TO;
aEntries[0].rgPropVals[1].ulPropTag = PR_ADDRTYPE; //设置地址类型，一般为SMTP
aEntries[0].rgPropVals[1].Value.LPSZ = _T(&#34;SMTP&#34;);
aEntries[0].rgPropVals[2].ulPropTag = PR_EMAIL_ADDRESS; //收件人地址
aEntries[0].rgPropVals[2].Value.LPSZ = _T(&#34;1234567&#34;);
设置收件人是通过IMessage:: ModifyRecipients来实现的，以下的代码举例说明了如何设置TO、CC和BCC属性：
INT nRecipientCount = 3; //表示有3个联系人信息
INT nListBufSize = CbNewADRLIST(nRecipientCount); //计算3个联系人需要的存储空间
LPADRLIST pAddressList = NULL;
MAPIAllocateBuffer(nListBufSize, (LPVOID FAR *)&amp;pAddressList)); //分配空间
memset(pAddressList, 0, nBufSize); pAddressList-&gt;cEntries = 3; //表明一共有3个联系人信息
//设置To
INT nCurIndex = 0;
MAPIAllocateBuffer(sizeof(SPropValue) * 3, (LPVOID FAR *)&amp;pAddressList-&gt;aEntries[nCurIndex].rgPropVals)); //分配空间 memset(pAddressList-&gt;aEntries[nCurIndex].rgPropVals, 0, sizeof(SPropValue) * 3);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2447ba462166878600310cc16f0d5b52/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-01-19T10:46:00+08:00" />
<meta property="article:modified_time" content="2011-01-19T10:46:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（五）如何设置收件人信息</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>发件人和收件人是邮件和消息很常用的几个属性之一，关于发件人的设置和获取是很简单的，只需要处理PR_SENDER_EMAIL_ADDRESS属性即可，下面主要讲述的收件人的设置和获取。</p> 
<p>       MAPI收件人结构如图（摘自MSDN）:</p> 
<p>      </p> 
<p> </p> 
<p>       每一个Entry代表了一个收件人信息组，每个信息组又可以有多项信息组成，举个例子，下面的代码代表了一个收件人的信息：</p> 
<p>       aEntries[0].rgPropVals[0].ulPropTag     = PR_RECIPIENT_TYPE;   //类型，MAPI_TO代表是设置到TO字段上的，相应的还有MAPI_CC和MAPI_BCC。</p> 
<p>       aEntries[0].rgPropVals[0].Value.ul        = MAPI_TO;</p> 
<p> </p> 
<p>       aEntries[0].rgPropVals[1].ulPropTag    = PR_ADDRTYPE;              //设置地址类型，一般为SMTP</p> 
<p>       aEntries[0].rgPropVals[1].Value.LPSZ   = _T("SMTP");</p> 
<p> </p> 
<p>       aEntries[0].rgPropVals[2].ulPropTag    = PR_EMAIL_ADDRESS;   //收件人地址</p> 
<p>       aEntries[0].rgPropVals[2].Value.LPSZ = _T("1234567");</p> 
<p> </p> 
<p>       设置收件人是通过IMessage:: ModifyRecipients来实现的，以下的代码举例说明了如何设置TO、CC和BCC属性：</p> 
<p>       INT              nRecipientCount    = 3;        //表示有3个联系人信息</p> 
<p>       INT               nListBufSize          = CbNewADRLIST(nRecipientCount);       //计算3个联系人需要的存储空间</p> 
<p>       LPADRLIST   pAddressList         = NULL;</p> 
<p>       MAPIAllocateBuffer(nListBufSize, (LPVOID FAR *)&amp;pAddressList));            //分配空间</p> 
<p>       memset(pAddressList, 0, nBufSize);           </p> 
<p> </p> 
<p>       pAddressList-&gt;cEntries               = 3;        //表明一共有3个联系人信息</p> 
<p>       //设置To</p> 
<p>       INT nCurIndex     = 0;</p> 
<p>       MAPIAllocateBuffer(sizeof(SPropValue) * 3, (LPVOID FAR *)&amp;pAddressList-&gt;aEntries[nCurIndex].rgPropVals));      //分配空间       memset(pAddressList-&gt;aEntries[nCurIndex].rgPropVals, 0, sizeof(SPropValue) * 3);</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[0].ulPropTag           = PR_RECIPIENT_TYPE;</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[0].Value.ul               = MAPI_TO;               //表明是写到To</p> 
<p> </p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[1].ulPropTag          = PR_ADDRTYPE;</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[1].Value.LPSZ = _T("SMTP");</p> 
<p> </p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[2].ulPropTag           = PR_EMAIL_ADDRESS;</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[2].Value.LPSZ = _T("1234567");</p> 
<p> </p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].cValues = 3;        //表明改联系人有3个属性要设置</p> 
<p> </p> 
<p> </p> 
<p>       //同上，现在设置CC</p> 
<p>       nCurIndex            = 1;</p> 
<p>       MAPIAllocateBuffer(sizeof(SPropValue) * 3, (LPVOID FAR *)&amp;pAddressList-&gt;aEntries[nCurIndex].rgPropVals));      //分配空间       memset(pAddressList-&gt;aEntries[nCurIndex].rgPropVals, 0, sizeof(SPropValue) * 3);</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[0].ulPropTag           = PR_RECIPIENT_TYPE;</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[0].Value.ul               = MAPI_CC;               //表明是写到CC</p> 
<p> </p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[1].ulPropTag          = PR_ADDRTYPE;</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[1].Value.LPSZ        = _T("SMTP");</p> 
<p> </p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[2].ulPropTag           = PR_EMAIL_ADDRESS;</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[2].Value.LPSZ        = _T("7654321");</p> 
<p> </p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].cValues = 3;        //表明改联系人有3个属性要设置</p> 
<p> </p> 
<p>       //同上，现在设置BCC</p> 
<p>       nCurIndex            = 2;</p> 
<p>       MAPIAllocateBuffer(sizeof(SPropValue) * 3, (LPVOID FAR *)&amp;pAddressList-&gt;aEntries[nCurIndex].rgPropVals));      //分配空间       memset(pAddressList-&gt;aEntries[nCurIndex].rgPropVals, 0, sizeof(SPropValue) * 3);</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[0].ulPropTag           = PR_RECIPIENT_TYPE;</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[0].Value.ul               = MAPI_BCC;            //表明是写到CC</p> 
<p> </p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[1].ulPropTag          = PR_ADDRTYPE;</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[1].Value.LPSZ         = _T("SMTP");</p> 
<p> </p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[2].ulPropTag           = PR_EMAIL_ADDRESS;</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].rgPropVals[2].Value.LPSZ         = _T("88888888");</p> 
<p>       pAddressList-&gt;aEntries[nCurIndex].cValues = 3;        //表明改联系人有3个属性要设置</p> 
<p> </p> 
<p>       //调用ModifyRecipients添加联系人，完了记的释放申请的内存，pMsg为你想操作的Message的对象实例，关于如何获取可以参考以前的文章。       pMsg-&gt;ModifyRecipients(MODRECIP_ADD, pAddressList)</p> 
<p> </p> 
<p> </p> 
<p>       for(INT i = 0; i &lt; nRecipientCount; i++)</p> 
<p>              MAPIFreeBuffer(pAddressList-&gt;aEntries[i].rgPropVals);</p> 
<p> </p> 
<p>       MAPIFreeBuffer(pAddressList);</p> 
<p>（六）如何获取收件人信息</p> 
<p>接下来开始讲讲如何获取联系人信息，它与设置信息比较相近，以下举例说明：</p> 
<p>       IMAPITable* pTable = NULL;</p> 
<p>     //通过GetRecipientTable获取联系人信息列表</p> 
<p>     pMsg-&gt;GetRecipientTable( NULL, &amp;pTable );</p> 
<p> </p> 
<p>     LPADRLIST pRecipentRows          = NULL;</p> 
<p>     //获取每个联系人信息，这里的做法可以看出和枚举Folder等都相似</p> 
<p>     while(!FAILED(hr = pTable-&gt;QueryRows(1, 0, (LPSRowSet*)&amp;pRecipentRows)))</p> 
<p>     {<!-- --></p> 
<p>         if( pRecipentRows-&gt;cEntries == 0 )</p> 
<p>              break;</p> 
<p> </p> 
<p>         for(int n = 0; n &lt; pRecipentRows-&gt;cEntries; n++ )</p> 
<p>         {<!-- --></p> 
<p>              //每个Entry代表一个联系人信息，每个联系人信息又有多个属性组成</p> 
<p>              for(int i = 0; i &lt; pRecipentRows-&gt;aEntries[n].cValues ; i++)</p> 
<p>              {<!-- --></p> 
<p>                   //判断如果是PR_EMAIL_ADDRESS属性，那么就找到了联系人地址</p> 
<p>                   if( PR_EMAIL_ADDRESS == pRecipentRows-&gt;aEntries[n].rgPropVals[i].ulPropTag )</p> 
<p>                   {<!-- --></p> 
<p>                       //联系人地址</p> 
<p>                       CString strContact     = pRecipentRows-&gt;aEntries[n].rgPropVals[i].Value.lpszW;</p> 
<p>                        //后续操作</p> 
<p>                   }</p> 
<p>              }</p> 
<p>         }</p> 
<p>         //完了记得要释放pRecipentRows和它里面的内容，释放方法见上一篇关于设置联系人信息的介绍。</p> 
<p>         ……</p> 
<p>     }</p> 
<p> </p> 
<p>     上面的代码片段只简单演示了获取联系人信息的基本操作步骤，通过这个例子也可以熟悉IMAPITable的用法，MAPI里面还是有很多地方会用到这个接口，用处还是比较大的。</p> 
<p>（七）设置Message附件</p> 
<p>本篇主要介绍如何设置Message的附件内容，下一篇会介绍如何获取附件。长话短说，下面的例子将完成如下的事情：</p> 
<p>1） 准备工作，在Temp目录下先放上几张图片，在这个例子里面，我在Temp目录放两张JPG图片，1.jpg,2.jpg，我将把这两张图片放到一个Message里面，生成两个附件。</p> 
<p>2） 在Outlook草稿箱里面创建出一条新的Message。</p> 
<p>3） 为Message添加附件。</p> 
<p> </p> 
<p>如何在Outlook草稿箱里面创建一条新的Message，我想通过前面的文章已经解释清楚了，这里就不罗嗦了，以下假设我们已经获取了IMessage*对象指针。首先提出一个帮助函数：MAPIHelp_AddAttachment，该函数作用是为指定的Message添加指定文件作为附件，定义如下:</p> 
<p>       BOOL          MAPIHelp_AddAttachment( IMessage* pMsg, LPCTSTR szFilePath, LPCTSTR szFileName );</p> 
<p>       pMsg : Message目标对象指针</p> 
<p>     szFilePath : 需要作为附件添加的文件全路径</p> 
<p>     szFileName : 需要作为附件添加的文件名称，作为附件的名称</p> 
<p>以下是函数具体实现：</p> 
<p>     BOOL MAPIHelp_AddAttachment( IMessage* pMsg, LPCTSTR szFilePath, LPCTSTR szFileName )</p> 
<p>     {<!-- --></p> 
<p>          if( NULL == pMsg || NULL == szFilePath )</p> 
<p>               return FALSE;</p> 
<p> </p> 
<p>          BOOL bRet          = FALSE;</p> 
<p>          ULONG ulAttachNum = 0;</p> 
<p>          LPATTACH pAttach   = NULL;</p> 
<p>          IStream* pStream   = NULL;</p> 
<p>          HANDLE hFile       = NULL;</p> 
<p>          SPropValue rgpropsTo[1] = {0};</p> 
<p>          DWORD dwChunkSize = 4096;</p> 
<p>          DWORD dwSizeRead   = 0;</p> 
<p>         //预备BUFFER，用来读写文件内容</p> 
<p>          LPBYTE pData       = new BYTE[dwChunkSize];</p> 
<p>          if( NULL == pData )</p> 
<p>              return FALSE;</p> 
<p> </p> 
<p>         //创建附件，返回IAttach对象，每个IAttach对象对应于一个附件, ulAttachNum是这个对象的标识，我们可以通过IMessage:: OpenAttach时传入这个ID来读取这个附件，具体的方法会在下篇时介绍。</p> 
<p>          if( FAILED(pMsg-&gt;CreateAttach( NULL, NULL, &amp;ulAttachNum, &amp;pAttach )) )</p> 
<p>              goto Exit;</p> 
<p>    </p> 
<p>         //设置附件名称</p> 
<p>          rgpropsTo[0].ulPropTag      = PR_ATTACH_FILENAME;</p> 
<p>          rgpropsTo[0].Value.lpszW    = (LPTSTR)szFileName;</p> 
<p>          if( FAILED(pAttach-&gt;SetProps(1, rgpropsTo, NULL)) )</p> 
<p>              goto Exit;</p> 
<p> </p> 
<p>         //通过OpenProperty获取IStream对象，有了IStream对象，我们就可以读写数据。对于IAttach:: OpenProperty,CE上只支持PR_ATTACH_DATA_BIN属性。</p> 
<p>          if( FAILED(pAttach-&gt;OpenProperty( PR_ATTACH_DATA_BIN, NULL, NULL, MAPI_MODIFY, (LPUNKNOWN *)&amp;pStream )) )</p> 
<p>              goto Exit;</p> 
<p> </p> 
<p>         //下面部分是文件读写部分，从原始文件里读出数据，再写到附件里面去</p> 
<p>          hFile                  = ::CreateFile( szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );</p> 
<p>          if( INVALID_HANDLE_VALUE == hFile )</p> 
<p>              goto Exit;</p> 
<p> </p> 
<p>          while( ReadFile( hFile, pData, dwChunkSize, &amp;dwSizeRead, NULL ) )</p> 
<p>          {<!-- --></p> 
<p>              if( 0 &gt;= dwSizeRead )</p> 
<p>                   break;</p> 
<p>              pStream-&gt;Write( pData, dwSizeRead, &amp;dwSizeRead );</p> 
<p>          }</p> 
<p> </p> 
<p>          bRet               = TRUE;</p> 
<p>     Exit:</p> 
<p>         //完毕以后记的释放获取的对象。</p> 
<p>          RELEASE_OBJ(pStream);</p> 
<p>          RELEASE_OBJ(pAttach);</p> 
<p>          DELETE_OBJ(pData);</p> 
<p>          if( INVALID_HANDLE_VALUE != hFile )</p> 
<p>              ::CloseHandle( hFile );</p> 
<p>          return bRet;</p> 
<p>}</p> 
<p> </p> 
<p>有了上面的帮助函数，当我们想为一条Message添加附件时，可以按照如下调用:</p> 
<p>     MAPIHelp_AddAttachment( pMsg, _T("<a rel="nofollow">//Temp//1.jpg</a>"), _T("1.jpg") );</p> 
<p>MAPIHelp_AddAttachment( pMsg, _T("<a rel="nofollow">//Temp//2.jpg</a>"), _T("2.jpg") );</p> 
<p>（八）读取Message附件</p> 
<p>在上一篇里面讲述了如何为一条MESSAGE设置附件，下面将继续关于附件的话题，利用上一个例子，我们接下来来看看如何获取一条MESSAGE的附件信息。下面将通过两个帮助函数来完成：</p> 
<p>       BOOL MAPIHelp_SaveAttachFile( LPATTACH pAttach, LPCTSTR szFile )</p> 
<p>     作用：读取单个附件文件内容，并保存到指定位置</p> 
<p>     pAttach: 附件对象</p> 
<p>     szFile: 保存文件名</p> 
<p> </p> 
<p>     BOOL MAPIHelp_GetAttachment( IMessage* pMsg, LPCTSTR szFilePath )</p> 
<p>     作用：获取一条Message的全部附件，并保存到指定目录下</p> 
<p>     pMsg: 目标消息对象</p> 
<p>     szFilePath: 目标目录</p> 
<p> </p> 
<p>     下面来看看具体实现：</p> 
<p>     BOOL MAPIHelp_SaveAttachFile( LPATTACH pAttach, LPCTSTR szFile )</p> 
<p>     {<!-- --></p> 
<p>          if( NULL == pAttach || NULL == szFile )</p> 
<p>              return FALSE;</p> 
<p>         HANDLE   hFile              = INVALID_HANDLE_VALUE;</p> 
<p>          IStream* pstmAttachment     = NULL;</p> 
<p>          char *    pBuffer            = NULL; </p> 
<p>          int      i                  = 0;</p> 
<p>          DWORD    dwWrite            = 0;</p> 
<p>          BOOL     bRet               = FALSE;</p> 
<p>          ULONG    ulRead             = 0;</p> 
<p> </p> 
<p>         //打开附件，获取IStream对象，用于获取文件内容，根据MSDN的解释，这里只支持PR_ATTACH_DATA_BIN属性。</p> 
<p>          if(FAILED(pAttach-&gt;OpenProperty (PR_ATTACH_DATA_BIN, NULL, STGM_READ, MAPI_MODIFY,</p> 
<p>                                         reinterpret_cast &lt;IUnknown **&gt; (&amp;pstmAttachment))))</p> 
<p>          {<!-- --></p> 
<p>              goto EXIT;</p> 
<p>          }   </p> 
<p>         //创建目标文件</p> 
<p>          hFile = ::CreateFile(szFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</p> 
<p>         if(INVALID_HANDLE_VALUE == hFile)</p> 
<p>          {<!-- --></p> 
<p>              goto EXIT;</p> 
<p>          }   </p> 
<p>    </p> 
<p>         //缓冲区，用于文件拷贝</p> 
<p>          pBuffer = new char[4096];</p> 
<p>          if(NULL == pBuffer)   </p> 
<p>          {<!-- --></p> 
<p>              goto EXIT;</p> 
<p>          }</p> 
<p> </p> 
<p>         //附件内容拷贝</p> 
<p>          while(SUCCEEDED(pstmAttachment-&gt;Read(pBuffer, 4096, &amp;ulRead)))</p> 
<p>          {<!-- --></p> 
<p>              if(ulRead &lt;= 0)</p> 
<p>                   break;</p> 
<p>              ::WriteFile(hFile, pBuffer, ulRead, &amp;dwWrite, NULL);</p> 
<p>          }</p> 
<p>         bRet     = TRUE;</p> 
<p>     EXIT:</p> 
<p>          if(INVALID_HANDLE_VALUE != hFile)</p> 
<p>          {<!-- --></p> 
<p>              ::CloseHandle(hFile);</p> 
<p>          }</p> 
<p>          if(NULL != pBuffer)</p> 
<p>          {<!-- --></p> 
<p>              delete []pBuffer;</p> 
<p>          }</p> 
<p>          if(NULL != pstmAttachment)</p> 
<p>          {<!-- --></p> 
<p>              pstmAttachment-&gt;Release();</p> 
<p>          }</p> 
<p>          return bRet;</p> 
<p>     }</p> 
<p> </p> 
<p>     BOOL MAPIHelp_GetAttachment( IMessage* pMsg, LPCTSTR szFilePath )</p> 
<p>     {<!-- --></p> 
<p>          if( NULL == pMsg || NULL == szFilePath )</p> 
<p>              return FALSE;</p> 
<p> </p> 
<p>          LPMAPITABLE pAttachTbl      = NULL;     </p> 
<p>          SRowSet* psrs               = NULL;</p> 
<p>          LPATTACH pAttach            = NULL; </p> 
<p>          LONG     lAttachNum         = 0;</p> 
<p>          BOOL     bRet               = FALSE;</p> 
<p>    </p> 
<p>         //获取附件列表</p> 
<p>          if(FAILED(pMsg-&gt;GetAttachmentTable(0, &amp;pAttachTbl)))</p> 
<p>          {<!-- --></p> 
<p>              goto EXIT;</p> 
<p>          }       </p> 
<p> </p> 
<p>         //接下来的查询过程是不是很眼熟？</p> 
<p>          while(SUCCEEDED(pAttachTbl-&gt;QueryRows (1, 0, &amp;psrs)))</p> 
<p>          {<!-- --></p> 
<p>              //即使查询返回成功，可能记录数也为0，需要排除这种CASE</p> 
<p>              if (NULL == psrs || psrs-&gt;cRows != 1)</p> 
<p>              {<!-- --></p> 
<p>                   break;</p> 
<p>              }</p> 
<p>              TCHAR szFile[MAX_PATH];</p> 
<p>              //遍历所有属性，找出附件ID和名称</p> 
<p>              for(int i = 0; i &lt; (int)(psrs-&gt;aRow[0].cValues); ++i)</p> 
<p>              {<!-- --></p> 
<p>                   if(PR_ATTACH_NUM == psrs-&gt;aRow[0].lpProps[i].ulPropTag)              </p> 
<p>                   {<!-- --></p> 
<p>                       //找到附件ID，并打开附件对象        </p> 
<p>                        if(FAILED(pMsg-&gt;OpenAttach(psrs-&gt;aRow[0].lpProps[i].Value.l,</p> 
<p>                                                   NULL,</p> 
<p>                                                   MAPI_BEST_ACCESS,</p> 
<p>                                                   &amp;pAttach)))                </p> 
<p>                        {<!-- --></p> 
<p>                            goto EXIT;</p> 
<p>                        }  </p> 
<p>                        lAttachNum = psrs-&gt;aRow[0].lpProps[i].Value.l;</p> 
<p>                   }</p> 
<p>                   else if(PR_ATTACH_FILENAME == psrs-&gt;aRow[0].lpProps[i].ulPropTag)</p> 
<p>                   {<!-- --></p> 
<p>                       //获取附件名称，生成保存路径</p> 
<p>                        _stprintf( szFile, _T("%s%s"), szFilePath, psrs-&gt;aRow[0].lpProps[i].Value.lpszW );</p> 
<p>                   }</p> 
<p>              }   </p> 
<p> </p> 
<p>              if(pAttach)</p> 
<p>              {<!-- --></p> 
<p>                   //保存文件</p> 
<p>                   MAPIHelp_SaveAttachFile( pAttach, szFile );</p> 
<p>                   pAttach-&gt;Release();</p> 
<p>                   pAttach       = NULL;</p> 
<p>              }</p> 
<p>              FreeProws(psrs);</p> 
<p>              psrs = NULL;</p> 
<p>          }</p> 
<p> </p> 
<p>          bRet     = TRUE;</p> 
<p> </p> 
<p>     EXIT:</p> 
<p>          if(NULL != psrs)</p> 
<p>          {<!-- --></p> 
<p>              FreeProws(psrs);</p> 
<p>          }</p> 
<p>          if(NULL != pAttach)</p> 
<p>          {<!-- --></p> 
<p>              pAttach-&gt;Release();</p> 
<p>          }</p> 
<p>          if(NULL != pAttachTbl)</p> 
<p>          {       </p> 
<p>              pAttachTbl-&gt;Release();</p> 
<p>          }</p> 
<p>          return bRet;</p> 
<p>     }</p> 
<p> </p> 
<p>     外面调用时候很简单，只需要获取IMessage对象，再调用MAPIHelp_GetAttachment即可。</p> 
<p>（九）Custom Form介绍</p> 
<p>一直很想写些关于Custom Form和Transport方面的东西，但是一方面这几个部分东西比较多，一篇两篇也讲不完，另外一方面感觉用的人不多，写了也是白写，所以一直没动手。最近有不少网友通过MAIL或者在CSDN论坛上都提到了Custom Form的用法（主要是想实现自己的类如MMS之类的客户端），在这里我简单介绍一下Custom Form的使用方法，希望对有需要的朋友能有所帮助。</p> 
<p>       实际上在微软的2005 SDK SAMPLE已经有了一个比较详细的例子，叫做Customform，大家可以在SDK安装目录/wce500/Windows Mobile 5.0 Pocket PC SDK/Samples/CPP/Win32下面找到这个例子，所以详细代码我就略过了，我们从系统对一个Custom Form的调用逻辑讲起。</p> 
<p>1.       用户点击New或者某条已经存在的Message再编辑，tmail查阅对应的Message Type,比如是IPM.SMSText(SMS)还是IPM.Note(Outlook Email)或者还是其它，然后查询注册表Message Type注册的位置(HKEY_CURRENT_USER/Software/Microsoft/Inbox/MsgTypes/IPM)找到正确的Form Dll.</p> 
<p>2.       每个Form DLL必须实现FormFactoryEx输出函数，tmail调用FormFactoryEx获取IFormProviderEx对象。</p> 
<p>3.       根据不同的需求，调用IFormProviderEx不同的函数，比如如果是新建或者再编辑一条Message，将会调用IFormProviderEx:: CreateComposeForm，如果是播放，则调用IFormProviderEx:: CreateReadForm，如果是获取Message Icon，则调用IFormProviderEx:: GetMsgStatusIconIndex(可以参考《Pocket PC &amp; Smartphone 短信图标轻松换》一文)。</p> 
<p> </p> 
<p>       要实现自己的编辑客户端，如果才能让用户方便的创建你定义的Message呢？微软的Sample里面没有涉及到这一点，它所走的流程是：</p> 
<p>1.         通过IMailRuleClient截获EMS消息，把它的Message Type改成IPM.SMStext.SDKEMS。</p> 
<p>2.         编辑或者播放时，因为类型是IPM.SMStext.SDKEMS,所以会调用自己一注册的EMS Custom Form。</p> 
<p> </p> 
<p>它略过了创建IPM.SMStext.SDKEMS类型Message的细节，那么要如何创建这种类型的消息呢？一种比较方便的方法就是在SMS基础上添加EMS的支持，如下图：</p> 
<p> </p> 
<p>这样，一旦用户点了EMS，那么创建的就是自定义的EMS消息，想要实现它其实很简单，在Customform例子的基础上，我们新建Message Type，比如叫IPM.EMS,替换掉Customform里面所有的IPM.SMStext.SDKEMS,接下来我们只需要对注册表做少许的修改：</p> 
<p>以下是IPM.EMS类型的注册：</p> 
<p>[HKEY_CURRENT_USER/Software/Microsoft/Inbox/MsgTypes/IPM/EMS]</p> 
<p>"GlyphInfo"=hex:/</p> 
<p>      20,00,00,00,64,00,00,00,64,00,00,00,00,00,00,00,01,00,00,00,03,00,00,00,02,/</p> 
<p>      00,00,00,00,00,00,00</p> 
<p>"DLL"="EMSViewerForm.dll"</p> 
<p>"Name"="EMS"</p> 
<p> </p> 
<p>在[HKEY_LOCAL_MACHINE/Software/Microsoft/Inbox/Svc/SMS/MsgClasses]下面添加键值：</p> 
<p>"IPM.EMS"=dword:00000001</p> 
<p> </p> 
<p>OK，我们单独的EMS 编辑器就成功了。</p> 
<p>(十) MAPI的一些问题</p> 
<p>1. tmail的后台启动模式：</p> 
<p>    前几天有网友问，他想通过SubmitMessage发送message,但是如果tmail没有起来，message只会被放到outbox里面等待发送，但是又不想在自己程序里面点发送就启动tmail界面，也有其他网友也问过类似的问题，希望调用MAPI一些功能，又不想开启tmail UI，我记的以前找到过tmail的后台启动模式，今天翻了出来，希望对大家有所帮助：</p> 
<p>::CreateProcess(_T("tmail.exe"), _T("-RunInBKG"),NULL, NULL, FALSE, 0, NULL, NULL, NULL, NULL);</p> 
<p>2.tmail的一些命令行参数介绍：</p> 
<p>    -service: 调用类型，比如MMS,SMS等</p> 
<p>    -attach: 添加附件</p> 
<p>    -subject: 添加subject</p> 
<p>    -to: 添加目标地址</p> 
<p>    举个例子：</p> 
<p>    const szCMD[] = _T(" -service /"MMS/" -to /"<a href="mailto:test@sina.com;13800571505" rel="nofollow">test@sina.com;13800571505/</a>"");</p> 
<p>    CreateProcess(_T(<a rel="nofollow">//Windows//tmail.exe</a>), szCMD, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL)</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/84addd82207e9834f521c101c991f7ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">简单的C语言程序之加法程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/88f45d5c5c08fb2740b3dedd28d10935/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C# 回车（键盘）事件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>