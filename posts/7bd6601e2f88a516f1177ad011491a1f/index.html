<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python实用技法第17篇：将名称映射到序列的元素中 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python实用技法第17篇：将名称映射到序列的元素中" />
<meta property="og:description" content="上一篇文章： Python实用技法第16篇：从字典中提取子集 下一篇文章： Python实用技法第18篇：同时对数据做转换和换算 1、需求? 我们的代码是通过位置（即索引或下标）来访问列表会元组的，但有时候这会让代码变得有些难以阅读。我们希望可以通过名称来访问元素，以此减少结构中对位置的依赖性。 2、解决方案? 相比普通的元组，collections.namedtuple()(命名元组)只增加了极少的开销就提供了这些便利。实际上collections.namedtuple()是一个工厂方法，它返回的是Python中标准元组类型的子类。我们提供给它一个类型名称以及相应的字段，它就返回一个可实例化的类、为你已经定义好的字段传入值等。
from collections import namedtuple Subscriber=namedtuple(&#39;Subsciber&#39;,[&#39;addr&#39;,&#39;joined&#39;]) sub=Subscriber(&#34;1782980833@qq.com&#34;,&#34;2018-10-23&#34;) print(sub) print(sub.addr) print(sub.joined) print(len(sub)) addr,joined=sub print(addr) print(joined) #下面错误，以为你namedtuple是不可变的 #sub.joined=&#34;2019&#34; 结果：
Subsciber(addr=&#39;1782980833@qq.com&#39;, joined=&#39;2018-10-23&#39;) 1782980833@qq.com 2018-10-23 2 1782980833@qq.com 2018-10-23 尽管namedtuple的实例看起来就像一个普通的类实例，但它的实例与普通的元组是可互换的，而且支持所有普通元组所支持的操作。
命名元组的主要作用在于将代码同它所控制的元素位置间解耦。所以，如果从数据库调用中得到了一个大型的元组列表，而且通过元素的位置来访问元素，那么假如在表单中新增了一列数据，那么代码就会崩溃，但如果首先将返回的元组转换为命名元组，就不会出现问题。
为了说明这个问题，下面有一些使用普通元组的代码：
def compute_cost(records): total=0.0 for rec in records: total&#43;=rec[1]*rec[2] return total 通过位置来引用元素常常使得代码的表达力不够强，而且也很依赖于记录的具体结构。
下面是使用命名元组的版本：
from collections import namedtuple Stock=namedtuple(&#39;Stock&#39;,[&#39;name&#39;,&#39;shares&#39;,&#39;price&#39;]) def compute_cost(records): total=0.0 for rec in records: s=Stock(*rec) total&#43;=s.shares*s.price return total 3、分析? namedtuple的一种可能用法是作为字典的替代，后者需要更多的空间来存储。因此，如果要构建设计字典的大型数据，使用namedtuple会更加高效，但是请注意，与字典不同的是，namedtuple是不可变的。
如果需要修改任何属性，可以通过使用namedtuple实例_replace()方法来实现。该方法会创建一个全新的命名元组，并对相应的值做替换。
from collections import namedtuple Subscriber=namedtuple(&#39;Subsciber&#39;,[&#39;addr&#39;,&#39;joined&#39;]) sub=Subscriber(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7bd6601e2f88a516f1177ad011491a1f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-23T03:23:48+08:00" />
<meta property="article:modified_time" content="2018-10-23T03:23:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python实用技法第17篇：将名称映射到序列的元素中</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article fmt article__content"> 
 <blockquote>
   上一篇文章： 
  <a href="https://segmentfault.com/a/1190000016769014" rel="nofollow">Python实用技法第16篇：从字典中提取子集</a> 
  <br>下一篇文章： 
  <a href="https://segmentfault.com/a/1190000017145891" rel="nofollow">Python实用技法第18篇：同时对数据做转换和换算</a> 
 </blockquote> 
 <h2>1、需求?</h2> 
 <blockquote>
   我们的代码是通过位置（即索引或下标）来访问列表会元组的，但有时候这会让代码变得有些难以阅读。我们希望可以通过名称来访问元素，以此减少结构中对位置的依赖性。 
 </blockquote> 
 <h2>2、解决方案?</h2> 
 <p>相比普通的元组，collections.namedtuple()(命名元组)只增加了极少的开销就提供了这些便利。实际上collections.namedtuple()是一个工厂方法，它返回的是Python中标准元组类型的子类。我们提供给它一个类型名称以及相应的字段，它就返回一个可实例化的类、为你已经定义好的字段传入值等。</p> 
 <pre><code>from collections import namedtuple
Subscriber=namedtuple('Subsciber',['addr','joined'])
sub=Subscriber("1782980833@qq.com","2018-10-23")

print(sub)
print(sub.addr)
print(sub.joined)

print(len(sub))
addr,joined=sub
print(addr)
print(joined)

#下面错误，以为你namedtuple是不可变的
#sub.joined="2019"</code></pre> 
 <p>结果：</p> 
 <pre><code>Subsciber(addr='1782980833@qq.com', joined='2018-10-23')
1782980833@qq.com
2018-10-23
2
1782980833@qq.com
2018-10-23</code></pre> 
 <p>尽管namedtuple的实例看起来就像一个普通的类实例，但它的实例与普通的元组是可互换的，而且支持所有普通元组所支持的操作。</p> 
 <p>命名元组的主要作用在于将代码同它所控制的元素位置间解耦。所以，如果从数据库调用中得到了一个大型的元组列表，而且通过元素的位置来访问元素，那么假如在表单中新增了一列数据，那么代码就会崩溃，但如果首先将返回的元组转换为命名元组，就不会出现问题。</p> 
 <p>为了说明这个问题，下面有一些使用普通元组的代码：</p> 
 <pre><code>def compute_cost(records):
    total=0.0
    for rec in records:
        total+=rec[1]*rec[2]
    return total</code></pre> 
 <p>通过位置来引用元素常常使得代码的表达力不够强，而且也很依赖于记录的具体结构。</p> 
 <p>下面是使用命名元组的版本：</p> 
 <pre><code>from collections import namedtuple
Stock=namedtuple('Stock',['name','shares','price'])
def compute_cost(records):
    total=0.0
    for rec in records:
        s=Stock(*rec)
        total+=s.shares*s.price
    return total</code></pre> 
 <h2>3、分析?</h2> 
 <p>namedtuple的一种可能用法是作为字典的替代，后者需要更多的空间来存储。因此，如果要构建设计字典的大型数据，使用namedtuple会更加高效，但是请注意，与字典不同的是，namedtuple是不可变的。</p> 
 <p>如果需要修改任何属性，可以通过使用namedtuple实例_replace()方法来实现。该方法会创建一个全新的命名元组，并对相应的值做替换。</p> 
 <pre><code>from collections import namedtuple
Subscriber=namedtuple('Subsciber',['addr','joined'])
sub=Subscriber("1782980833@qq.com","2018-10-23")

print(sub)

sub=sub._replace(joined="2018-10-24")
print(sub)</code></pre> 
 <p>结果：</p> 
 <pre><code>Subsciber(addr='1782980833@qq.com', joined='2018-10-23')
Subsciber(addr='1782980833@qq.com', joined='2018-10-24')</code></pre> 
 <p>_<em>replace()方法有一个微妙的用途，那就是它可以作为一种简单的方法填充具有可选或缺失字段的命名元组。要做到这点，首先创建一个包含默认值得原型数组，然后使用</em>_replace()方法创建一个新的实例，把相应的值替换掉。</p> 
 <pre><code>from collections import namedtuple
Subscriber=namedtuple('Subsciber',['addr','joined','age'])
sub=Subscriber("",None,0)

def dict_to_stock(s):
    return sub._replace(**s)

a={"addr":"111111@qq.com","joined":"1111-11-11","age":11}
a=dict_to_stock(a)
print(a)

b={"addr":"111111@qq.com","joined":"1111-11-11"}
b=dict_to_stock(b)
print(b)
</code></pre> 
 <p>结果：</p> 
 <pre><code>Subsciber(addr='111111@qq.com', joined='1111-11-11', age=11)
Subsciber(addr='111111@qq.com', joined='1111-11-11', age=0)</code></pre> 
 <p>最后，也是相当重要的是，应该要注意如果我们的目标是定义一个高效的数据结构，而且将来会修改各种实例属性，那么使用namedtuple并不是最佳选择，相反，可以考虑顶一个使用了__<em>slots</em>__属性的类。</p> 
 <blockquote>
   上一篇文章： 
  <a href="https://segmentfault.com/a/1190000016769014" rel="nofollow">Python实用技法第16篇：从字典中提取子集</a> 
  <br>下一篇文章： 
  <a href="https://segmentfault.com/a/1190000017145891" rel="nofollow">Python实用技法第18篇：同时对数据做转换和换算</a> 
 </blockquote> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f77a0d4aca067ea2338293b0b70e893b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux学习笔记（共享内存 &#43;⽂件锁 &#43; 信号量 &#43;Shell脚本编程 &#43;云服务器⼊⻔）之云服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe0b978dba57164054de0887cdfe7e1e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">postgresql 查询所有表名</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>