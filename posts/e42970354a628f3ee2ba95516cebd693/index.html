<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA宝典----关键字(理解记忆) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA宝典----关键字(理解记忆)" />
<meta property="og:description" content="目录
一、 final、finally和finalize有什么区别
二、JDK中哪些类是不能继承的？
三、 assert有什么作用？
四、static关键字有哪些作用？
1.什么是实例变量？什么是局部变量？什么是类变量？什么是final变量？
2.static与final结合使用表示什么意思？
五、volatile有什么作用？
六、 instanceof有什么作用？
七、 strictfp有什么作用？
一、 final、finally和finalize有什么区别 final、finally和finalize的区别如下：
1）final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承（不能再派生出新的子类）。
final属性：被final修饰的变量不可变。由于不可变有两重含义：一是引用不可变；二是对象不可变，final指的是引用的不可变性，即它只能指向初始时指向的那个对象，而不关心指向对象内容的变化。所以，被final修饰的变量必须被初始化。一般可以通过以下几种方式对其进行初始化：
①在定义的时候初始化。
②final成员变量可以在初始化块中初始化，但不可在静态初始化块中初始化。
③静态final成员变量可以在静态初始化块中初始化，但不可在初始化块中初始化。
④在类的构造器中初始化，但静态final成员变量不可以在构造函数中初始化。
final方法：当一个方法声明为final时，该方法不允许任何子类重写这个方法，但子类仍然可以使用这个方法。另外，还有一种被称为inline（内联）的机制，当调用一个被声明为fi-nal的方法时，直接将方法主体插入到调用处，而不是进行方法调用（类似于C&#43;&#43;中的in-line），这样做能提高程序的效率。
final参数：用来表示这个参数在这个函数内部不允许被修改。
2）finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定被执行，经常被用在需要释放资源的情况下。
3）finalize是Object类的一个方法，在垃圾回收器执行时会调用被回收对象的finalize（）方法，可以覆盖此方法来实现对其他资源的回收，例如关闭文件等。需要注意的是，一旦垃圾回收器准备好释放对象占用的空间，将首先调用其finalize（）方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。
二、JDK中哪些类是不能继承的？ 从上面的介绍可以知道，不能继承的类是那些用final关键字修饰的类。一般比较基本的类型为防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在JDK中，String、StringBuffer等都是基本类型，所以，String、StringBuffer等类是不能继承的。
三、 assert有什么作用？ 断言（assert）作为一种软件调试的方法，提供了一种在代码中进行正确性检查的机制，目前很多开发语言都支持这种机制。它的主要作用是对一个boolean表达式进行检查，一个正确运行的程序必须保证这个boolean表达式的值为true，若boolean表达式的值为false，则说明程序已经处于一种不正确的状态下，系统需要提供告警信息并且退出程序。在实际的开发中，assert主要用来保证程序的正确性，通常在程序开发和测试时使用。为了提高程序运行的效率，在软件发布后，assert检查默认是被关闭的。
assert包括两种表达式，分别为assert expression1与assert expression2，其中
expression1表示一个boolean表达式expression2表示一个基本类型或者是一个对象，基本类型包括boolean、char、double、float、int和long
assert的应用范围很多，主要包括
①检查控制流；
②检查输入参数是否有效；
③检查函数结果是否有效；
④检查程序不变量。
虽然assert的功能与if判断类似，但二者存在着本质的区别：assert一般在调试程序时使用，但如果不小心用assert来控制了程序的业务流程，那在调试结束后去掉assert就意味着修改了程序的正常逻辑，这样的做法是非常危险的；而if判断是逻辑判断，本身就是用以控制程序流程的。
需要注意的是，在Java语言中，assert与C语言中的assert尽管功能类似，但也不完全一样，具体表现为两个方面的不同：
①Java语言中是使用assert关键字去实现其功能，而C语言中使用的是库函数；
②C语言中的assert是在编译时开启，而Java语言中则是在运行时开启。
四、static关键字有哪些作用？ static关键字主要有两种作用：
第一，为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。
第二，实现某个方法或属性与类而不是对象关联在一起，也就是说，在不创建对象的情况下就可以通过类来直接调用方法或使用类的属性。
具体而言，在Java语言中，static主要有4种使用情况：成员变量、成员方法、代码块和内部类。
（1）static成员变量
虽然Java语言中没有全局的概念，但可以通过static关键字来达到全局的效果。Java类提供了两种类型的变量：用static关键字修饰的静态变量和不用static关键字修饰的实例变量。静态变量属于类，在内存中只有一个复制（所有实例都指向同一个内存地址），只要静态变量所在的类被加载，这个静态变量就会被分配空间，因此就可以被使用了。对静态变量的引用有两种方式，分别为“类.静态变量”和“对象.静态变量”。
实例变量属于对象，只有对象被创建后，实例变量才会被分配空间，才能被使用，它在内存中存在多个复制。只能用“对象.实例变量”的方式来引用
从上例可以看出，静态变量只有一个，被类拥有，所有对象都共享这个静态变量，而实例对象是与具体对象相关的。需要注意的是，与C&#43;&#43;语言不同的是，在Java语言中，不能在方法体中定义static变量。
（2）static成员方法
与变量类似，Java类同时也提供了static方法与非static方法。static方法是类的方法，不需要创建对象就可以被调用，而非static方法是对象的方法，只有对象被创建出来后才可以被使用。
static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和成员方法，因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法。同理，static方法也不能访问非static类型的变量。
static一个很重要的用途是实现单例模式。单例模式的特点是该类只能有一个实例，为了实现这一功能，必须隐藏类的构造函数，即把构造函数声明为private，并提供一个创建对象的方法，由于构造对象被声明为private，外界无法直接创建这个类型的对象，只能通过该类提供的方法来获取类的对象，要达到这样的目的只能把创建对象的方法声明为static
用public修饰的static变量和方法本质上都是全局的，若在static变量前用private修饰，则表示这个变量可以在类的静态代码块或者类的其他静态成员方法中使用，但是不能在其他类中通过类名来直接引用。
（3）static代码块
static代码块（静态代码块）在类中是独立于成员变量和成员函数的代码块的。它不在任何一个方法体内，JVM在加载类时会执行static代码块，如果有多个static代码块，JVM将会按顺序来执行。static代码块经常被用来初始化静态变量
（4）static内部类
static内部类是指被声明为static的内部类，它可以不依赖于外部类实例对象而被实例化，而通常的内部类需要在外部类实例化后才能实例化。静态内部类不能与外部类有相同的名字，不能访问外部类的普通成员变量，只能访问外部类中的静态成员和静态方法（包括私有类型）
需要注意的是，只有内部类才能被定义为static。
1.什么是实例变量？什么是局部变量？什么是类变量？什么是final变量？ 实例变量：变量归对象所有（只有在实例化对象后才可以）。每当实例化一个对象时，会创建一个副本并初始化，如果没有显示初始化，那么会初始化一个默认值。各个对象中的实例变量互不影响。
局部变量：在方法中定义的变量，在使用前必须初始化。
类变量：用static可修饰的属性、变量归类所有，只要类被加载，这个变量就可以被使用（类名.变量名）。所有实例化的对象共享类变量。
final变量：表示这个变量为常量，不能被修改。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e42970354a628f3ee2ba95516cebd693/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-24T23:18:14+08:00" />
<meta property="article:modified_time" content="2023-06-24T23:18:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA宝典----关键字(理解记忆)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%C2%A0final%E3%80%81finally%E5%92%8Cfinalize%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" rel="nofollow">一、 final、finally和finalize有什么区别</a></p> 
<p style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81JDK%E4%B8%AD%E5%93%AA%E4%BA%9B%E7%B1%BB%E6%98%AF%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF%E7%9A%84%EF%BC%9F" rel="nofollow">二、JDK中哪些类是不能继承的？</a></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%C2%A0assert%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F" rel="nofollow">三、 assert有什么作用？</a></p> 
<p style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%EF%BC%9F" rel="nofollow">四、static关键字有哪些作用？</a></p> 
<p style="margin-left:40px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFfinal%E5%8F%98%E9%87%8F%EF%BC%9F" rel="nofollow">1.什么是实例变量？什么是局部变量？什么是类变量？什么是final变量？</a></p> 
<p style="margin-left:40px;"><a href="#2.static%E4%B8%8Efinal%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F" rel="nofollow">2.static与final结合使用表示什么意思？</a></p> 
<p style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81volatile%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F" rel="nofollow">五、volatile有什么作用？</a></p> 
<p style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%C2%A0instanceof%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F" rel="nofollow">六、 instanceof有什么作用？</a></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%C2%A0strictfp%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F" rel="nofollow">七、 strictfp有什么作用？</a></p> 
<hr> 
<p> </p> 
<h2>一、 final、finally和finalize有什么区别</h2> 
<p>    final、finally和finalize的区别如下：</p> 
<p>1）final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承（不能再派生出新的子类）。</p> 
<p>        final属性：被final修饰的变量不可变。由于不可变有两重含义：一是引用不可变；二是对象不可变，final指的是引用的不可变性，即它只能指向初始时指向的那个对象，而不关心指向对象内容的变化。所以，被final修饰的变量必须被初始化。一般可以通过以下几种方式对其进行初始化：</p> 
<p>①在定义的时候初始化。</p> 
<p>②final成员变量可以在初始化块中初始化，但不可在静态初始化块中初始化。</p> 
<p>③静态final成员变量可以在静态初始化块中初始化，但不可在初始化块中初始化。</p> 
<p>④在类的构造器中初始化，但静态final成员变量不可以在构造函数中初始化。</p> 
<p><br>         final方法：当一个方法声明为final时，该方法不允许任何子类重写这个方法，但子类仍然可以使用这个方法。另外，还有一种被称为inline（内联）的机制，当调用一个被声明为fi-nal的方法时，直接将方法主体插入到调用处，而不是进行方法调用（类似于C++中的in-line），这样做能提高程序的效率。<br> final参数：用来表示这个参数在这个函数内部不允许被修改。</p> 
<p>2）finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定被执行，经常被用在需要释放资源的情况下。</p> 
<p>3）finalize是Object类的一个方法，在垃圾回收器执行时会调用被回收对象的finalize（）方法，可以覆盖此方法来实现对其他资源的回收，例如关闭文件等。需要注意的是，一旦垃圾回收器准备好释放对象占用的空间，将首先调用其finalize（）方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。</p> 
<h2>二、JDK中哪些类是不能继承的？</h2> 
<p>        从上面的介绍可以知道，不能继承的类是那些用final关键字修饰的类。一般比较基本的类型为防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在JDK中，String、StringBuffer等都是基本类型，所以，String、StringBuffer等类是不能继承的。</p> 
<p> </p> 
<h2>三、 assert有什么作用？</h2> 
<p>        断言（assert）作为一种软件调试的方法，提供了一种在代码中进行正确性检查的机制，目前很多开发语言都支持这种机制。它的主要作用是对一个boolean表达式进行检查，一个正确运行的程序必须保证这个boolean表达式的值为true，若boolean表达式的值为false，则说明程序已经处于一种不正确的状态下，系统需要提供告警信息并且退出程序。在实际的开发中，assert主要用来保证程序的正确性，通常在程序开发和测试时使用。为了提高程序运行的效率，在软件发布后，assert检查默认是被关闭的。<br> assert包括两种表达式，分别为assert expression1与assert expression2，其中</p> 
<p>expression1表示一个boolean表达式expression2表示一个基本类型或者是一个对象，基本类型包括boolean、char、double、float、int和long</p> 
<p>assert的应用范围很多，主要包括</p> 
<p>①检查控制流；</p> 
<p>②检查输入参数是否有效；</p> 
<p>③检查函数结果是否有效；</p> 
<p>④检查程序不变量。</p> 
<p>        虽然assert的功能与if判断类似，但二者存在着本质的区别：assert一般在调试程序时使用，但如果不小心用assert来控制了程序的业务流程，那在调试结束后去掉assert就意味着修改了程序的正常逻辑，这样的做法是非常危险的；而if判断是逻辑判断，本身就是用以控制程序流程的。<br> 需要注意的是，在Java语言中，assert与C语言中的assert尽管功能类似，但也不完全一样，具体表现为两个方面的不同：</p> 
<p>①Java语言中是使用assert关键字去实现其功能，而C语言中使用的是库函数；</p> 
<p>②C语言中的assert是在编译时开启，而Java语言中则是在运行时开启。</p> 
<p> </p> 
<h2>四、static关键字有哪些作用？</h2> 
<p>static关键字主要有两种作用：</p> 
<p>第一，为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。</p> 
<p>第二，实现某个方法或属性与类而不是对象关联在一起，也就是说，在不创建对象的情况下就可以通过类来直接调用方法或使用类的属性。</p> 
<p>具体而言，在Java语言中，static主要有4种使用情况：成员变量、成员方法、代码块和内部类。</p> 
<p><br> （1）static成员变量<br>         虽然Java语言中没有全局的概念，但可以通过static关键字来达到全局的效果。Java类提供了两种类型的变量：用static关键字修饰的静态变量和不用static关键字修饰的实例变量。静态变量属于类，在内存中只有一个复制（所有实例都指向同一个内存地址），只要静态变量所在的类被加载，这个静态变量就会被分配空间，因此就可以被使用了。对静态变量的引用有两种方式，分别为“类.静态变量”和“对象.静态变量”。<br> 实例变量属于对象，只有对象被创建后，实例变量才会被分配空间，才能被使用，它在内存中存在多个复制。只能用“对象.实例变量”的方式来引用</p> 
<p>        从上例可以看出，静态变量只有一个，被类拥有，所有对象都共享这个静态变量，而实例对象是与具体对象相关的。需要注意的是，与C++语言不同的是，在Java语言中，不能在方法体中定义static变量。</p> 
<p>（2）static成员方法</p> 
<p>        与变量类似，Java类同时也提供了static方法与非static方法。static方法是类的方法，不需要创建对象就可以被调用，而非static方法是对象的方法，只有对象被创建出来后才可以被使用。</p> 
<p>        static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和成员方法，因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法。同理，static方法也不能访问非static类型的变量。</p> 
<p>        static一个很重要的用途是实现单例模式。单例模式的特点是该类只能有一个实例，为了实现这一功能，必须隐藏类的构造函数，即把构造函数声明为private，并提供一个创建对象的方法，由于构造对象被声明为private，外界无法直接创建这个类型的对象，只能通过该类提供的方法来获取类的对象，要达到这样的目的只能把创建对象的方法声明为static</p> 
<p>        用public修饰的static变量和方法本质上都是全局的，若在static变量前用private修饰，则表示这个变量可以在类的静态代码块或者类的其他静态成员方法中使用，但是不能在其他类中通过类名来直接引用。</p> 
<p>（3）static代码块<br>         static代码块（静态代码块）在类中是独立于成员变量和成员函数的代码块的。它不在任何一个方法体内，JVM在加载类时会执行static代码块，如果有多个static代码块，JVM将会按顺序来执行。static代码块经常被用来初始化静态变量</p> 
<p>（4）static内部类<br>         static内部类是指被声明为static的内部类，它可以不依赖于外部类实例对象而被实例化，而通常的内部类需要在外部类实例化后才能实例化。静态内部类不能与外部类有相同的名字，不能访问外部类的普通成员变量，只能访问外部类中的静态成员和静态方法（包括私有类型）</p> 
<p>需要注意的是，只有内部类才能被定义为static。</p> 
<h3><br> 1.什么是实例变量？什么是局部变量？什么是类变量？什么是final变量？</h3> 
<p> </p> 
<p>        实例变量：变量归对象所有（只有在实例化对象后才可以）。每当实例化一个对象时，会创建一个副本并初始化，如果没有显示初始化，那么会初始化一个默认值。各个对象中的实例变量互不影响。<br>         局部变量：在方法中定义的变量，在使用前必须初始化。<br>         类变量：用static可修饰的属性、变量归类所有，只要类被加载，这个变量就可以被使用（类名.变量名）。所有实例化的对象共享类变量。<br> final变量：表示这个变量为常量，不能被修改。</p> 
<h3><br> 2.static与final结合使用表示什么意思？</h3> 
<h3> </h3> 
<p>        在Java语言中，static关键字常与final关键字结合使用，用来修饰成员变量与成员方法，有点类似于C/C++语言中的“全局常量”。对于变量，若使用static final修饰，则表示一旦赋值，就不可修改，并且通过类名可以访问。对于方法，若使用static final修饰，则表示该方法不可覆盖，并且可以通过类名直接访问。</p> 
<p>        而不会去内存中读取。这样做的一个好处是提高了程序的运行效率，但当遇到多线程编程时，变量的值可能因为别的线程而改变了，而该缓存的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致，例如，在本次线程内，当读取一个变量时，为提高存取速度，会先把变量读取到一个缓存中，当以后再取变量值时，就直接从缓存中取值，当变量值在本线程里改变时，会同时把变量的新值复制到该缓存中，以便保持一致。</p> 
<h2>五、volatile有什么作用？</h2> 
<p>        volatile是一个类型修饰符，它是被设计用来修饰被不同线程访问和修改的变量。被volatile类型定义的变量，系统每次用到它时都是直接从对应的内存当中提取，而不会利用缓存。在使用了volatile修饰成员变量后，所有线程在任何时候所看到变量的值都是相同的<br>         需要注意的是，由于volatile不能保证操作的原子性，因此，一般情况下volatile不能代替sychronized。此外，使用volatile会阻止编译器对代码的优化，因此会降低程序的执行效率。所以，除非迫不得已，否则，能不使用volatile就尽量不要使用volatile。</p> 
<h2>六、 instanceof有什么作用？</h2> 
<p>        instanceof是Java语言中的一个二元运算符，它的作用是判断一个引用类型的变量所指向的对象是否是一个类（或接口、抽象类、父类）的实例，即它左边的对象是否是它右边的类的实例该运算符返回boolean类型的数据。</p> 
<p>        常见的用法为：</p> 
<p>result＝object instanceof class。</p> 
<p>如果object是class的一个实例，那么</p> 
<p>instanceof运算符返回true；如果object不是class的一个实例，或者object是null，那么instanceof运算符返回false。</p> 
<h2>七、 strictfp有什么作用？</h2> 
<p><br>         关键字strictfp是strict float point的缩写，指的是精确浮点，它用来确保浮点数运算的准确性。JVM在执行浮点数运算时，如果没有指定strictfp关键字，此时计算结果可能会不精确，而且计算结果在不同平台或厂商的虚拟机上会有不同的结果，导致意想不到的错误。而一旦使用了strictfp来声明一个类、接口或者方法，那么在所声明的范围内，Java编译器以及运行环境会完全依照IEEE二进制浮点数算术标准（IEEE 754）来执行，在这个关键字声明的范围内所有浮点数的计算都是精确的。需要注意的是，当一个类被strictfp修饰时，所有方法都会自动被strictfp修饰。因此，strictfp可以保证浮点数运算的精确性，而且在不同的硬件平台上会有一致的运行结果。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/34f28f9989bc9edde96e090a6807e792/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mybatisPlus中apply的使用以进行联表等复杂sql语句</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08408647ece72ea38d31d4c84c936e2b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Qt】【qDebug】输出std::string字符串</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>