<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>int &amp; 到底是个啥？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="int &amp; 到底是个啥？" />
<meta property="og:description" content="感觉自己很废，很懒。不懂得东西模棱两可就过去了，废物，垃圾。现在的知识盲区大了吧！大家敬请鄙视我吧！ 故事是这样的： #include&lt;stdio.h&gt; void change1 (int *a,int *b) { int c; c=*a; *a=*b; *b=c; } void change2 (int &amp;m,int &amp;n) { int c; c=m; m=n; n=c; } int main() { int a=1;int m=1; int b=2;int n=2; change1(&amp;a,&amp;b); printf(&#34;-a-%d--\n&#34;,a); printf(&#34;-b-%d--\n\n\n&#34;,b); change2(&amp;m,&amp;n); //错误，错误，错误 printf(&#34;-m-%d--\n&#34;,m); printf(&#34;-n-%d--\n\n\n&#34;,n); return 0; } 哎，chang2里面的形参不是需要两个地址吗？ &amp;m,&amp;n，不是取地址吗？对啊！我传入两个地址，没毛病啊！这是当初学C语言心中的疑惑，但是我是个废柴！哦，书上说不用写&amp;，直接写m，n就行了。好了我记住了！but！but！but！废柴是不知道原理是什么的，只知道这样子去用。好了，今天遇到问题报错了吧！废柴开始紧张了！ 在这里不得不吐槽教科书，垃圾，就写一句“注意int &amp;不是取地址，是引用，详情自主百度”不就交代的很清楚了吗？害我这个废柴找了半天答案。垃圾教科书。 这里引用“落辰衰”大佬的解释：
1、int;
int是C&#43;&#43;关键字，表示整型，其大小是32位有符号整型，表示的范围是-2,147,483,648 到 2,147,483,647；在声明和定义变量时使用，它表示的意思是所声明或所定义的变量为整型变量。
如果其用于函数参数时，其传递方向为值传递，即只能将实参的值传递给形参，而不能将
形参的值传递给实参。
例如：通过这种方式去进行交换两个数是无法达到目的的。
例子1：
#include&lt;iostream&gt;
using namespace std; voidswap1(inta,intb)
{ inttmp; tmp = a; a = b; b = tmp; } int main(){ inta = 1; intb = 2; swap1(a, b); cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1016d56ede8f56a5f6a04d1379e6a9f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-04T12:42:43+08:00" />
<meta property="article:modified_time" content="2018-11-04T12:42:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">int &amp; 到底是个啥？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>     <span style="color:#f33b45;">    感觉自己很废，很懒。不懂得东西模棱两可就过去了，废物，垃圾。现在的知识盲区大了吧！大家敬请鄙视我吧！</span></h4> 
<h4><span style="color:#f33b45;">       </span>  故事是这样的：</h4> 
<pre class="has"><code class="language-cpp"> #include&lt;stdio.h&gt;
 
 void change1 (int *a,int *b)
 {
 	int c;
 	c=*a;
 	*a=*b;
 	*b=c;
 }
 
 
  void change2 (int &amp;m,int &amp;n)
 {
 	int c;
 	c=m;
 	m=n;
 	n=c;
 }
 
 
 int main()
 {
 	int a=1;int m=1;
 	int b=2;int n=2;
 	
 	change1(&amp;a,&amp;b);
 	printf("-a-%d--\n",a);
 	printf("-b-%d--\n\n\n",b);
 	
 	change2(&amp;m,&amp;n);                //错误，错误，错误
 	printf("-m-%d--\n",m);
 	printf("-n-%d--\n\n\n",n);
 	return 0;
 }</code></pre> 
<h4>哎，chang2里面的形参不是需要两个地址吗？ &amp;m,&amp;n，不是取地址吗？对啊！我传入两个地址，没毛病啊！这是当初学C语言心中的疑惑，但是我是个废柴！哦，书上说不用写&amp;，直接写m，n就行了。好了我记住了！but！but！but！废柴是不知道原理是什么的，只知道这样子去用。好了，今天遇到问题报错了吧！废柴开始紧张了！</h4> 
<h4>在这里不得不吐槽教科书，垃圾，就写一句“注意int &amp;不是取地址，是引用，详情自主百度”不就交代的很清楚了吗？害我这个废柴找了半天答案。垃圾教科书。</h4> 
<blockquote> 
 <p>这里引用“落辰衰”大佬的解释：</p> 
 <p>1、int;</p> 
 <p>int是C++关键字，表示整型，其大小是32位有符号整型，表示的范围是-2,147,483,648 到 </p> 
 <p>2,147,483,647；在声明和定义变量时使用，它表示的意思是所声明或所定义的变量为整型变量。</p> 
 <p>如果其用于函数参数时，其传递方向为值传递，即只能将实参的值传递给形参，而不能将</p> 
 <p>形参的值传递给实参。</p> 
 <p>例如：通过这种方式去进行交换两个数是无法达到目的的。</p> 
 <p>例子1：</p> 
 <p> </p> 
 <p>#include&lt;iostream&gt;<br> using namespace std;            <br> voidswap1(inta,intb)<br> {   <br>      inttmp;   <br>      tmp = a;    <br>      a = b;    <br>      b = tmp;    <br>  }   <br>  int main(){   <br>      inta = 1;    <br>      intb = 2;    <br>      swap1(a, b);    <br>      cout&lt;&lt;"a = "&lt;&lt;a&lt;&lt;endl;   <br>      cout&lt;&lt;"b = "&lt;&lt;b&lt;&lt;endl;   <br>      system("pause");   <br>      return0;   <br>  }</p> 
 <p>结果为：a=1</p> 
 <p>b=2</p> 
 <p>因为传递的方式为值传递(单向传递)；</p> 
 <p>2、int&amp;;</p> 
 <p>这里的&amp;不是取地址符号，而是引用符号，引用是C++对C的一个重要补充。变量的引用就是</p> 
 <p>变量的别名，讲的通俗一点就是另外一个名字，比如：“张三这个人在家里，老爸老妈叫他</p> 
 <p>三娃子，那么这个三娃子就是指张三这个人，如果叫张三去做某事，就是叫三娃子去做某事，</p> 
 <p>这两个名字指的是同一个人。”同样可以理解如果变量b是变量a的引用 那么无论a，b中任</p> 
 <p>何一个值改变，另外一个也相应的改变，在声明一个引用时，必须同时使之初始化，即声</p> 
 <p>明它代表哪一个变量。请注意：由于引用不是独立的变量，编译系统不给它单独分配存</p> 
 <p>储单元，因此在建立引用时只有声明没有定义，只是声明它与原有的某一变量的关系。</p> 
 <p>在声明一个变量的引用后，在本函数执行期间，该引用一直与其代表的变量相联系，不能</p> 
 <p>再作为其他变量的别名。说得简单点：张三和三娃子是指同一个人，不能李四也叫三娃子，</p> 
 <p>如果可以这样，叫三娃子去做什么，是叫李四呢还是张三呢，这就会乱套了。所以在C++中</p> 
 <p>一个引用变量只能对应一个原始的变量，不能对应两个或多个原始的变量；</p> 
 <p>下面简单说明引用：</p> 
 <p>a)声明引用时必须指定它代表的是哪一个变量，即对它初始化。</p> 
 <p>int &amp;a=b;这样是声明a是变量b的引用</p> 
 <p>如果是int &amp;a;这样就是错的，没有指定a代表哪一个变量。</p> 
 <p>b)引用与其所代表的变量共享同一内存单元，系统并不为引用另外分配存储单元；</p> 
 <p>这个应该好理解；就像前面所说的，张三和三娃子都是同一个人，三娃子只是张三的别名。</p> 
 <p>因此，对于 int &amp;a=b;这个例子来说，要输出a和b 的地址，肯定是相同的。</p> 
 <p>c)怎样区分&amp;是引用还是取地址符呢？方法是：判断&amp;a这样的形式前是否有类型符即</p> 
 <p>int &amp;a=b;如果有类型符(int)则是引用，否则是取地址运算符。</p> 
 <p>d)对引用的初始化，可以是一个变量名，也可以是另一个引用。</p> 
 <p>换句话说：张三的别名可以是三娃子，三小子……及其他多个别名</p> 
 <p>而三娃子也可以有其他的别名，比如说：老三，小三等</p> 
 <p>用程序可以这样：</p> 
 <p>int a=1; //这里是定义一个整形变量</p> 
 <p>int &amp;b=a;//声明b是整型变量a的别名</p> 
 <p>int &amp;c=b;//声明c是整型引用变量b的别名</p> 
 <p>int &amp;d=a;//声明d是整型变量a的别名</p> 
 <p>e)引用初始化后不能再被重新声明为另一变量的别名</p> 
 <p>即三娃子既然是指张三这个人，就不能让其他人也叫三娃子</p> 
 <p>即一个别名只能对应一个原始变量，但是一个原始变量可以有多个别名，而且别名也可以</p> 
 <p>由自己的别名。</p> 
 <p> </p> 
 <p>C++中增加引用主要是作为函数参数，进行数据传递的功能；</p> 
 <p>我们知道如果用变量名作为实参，其传递方向是单向的，而用引用作为实参其传递方向</p> 
 <p>是双向的；</p> 
 <p>也许你会问，在c语言中不是有指针吗，用指针进行参数传递不也是双向的吗？其实其</p> 
 <p>本质上也是值传递，只不过是将变量的地址传给指针，通过指针获取变量的值，这样做</p> 
 <p>虽能得到结果，但通过指针运算符去访问有关变量，比较麻烦。</p> 
 <p>下面分析一下使用引用和使用指针变量作为函数形参的不同(以例子1中的swap函数为例)：</p> 
 <p>1、如果使用引用，则不必在swap函数设立指针变量，指针变量要另外开辟内存单元，其</p> 
 <p>内容是地址。而引用不是一个独立的变量，并不占用内存单元</p> 
 <p>2、在main函数中调用swap函数时实参不必再变量名前加&amp;以表示地址，系统传递的是</p> 
 <p>实参的地址不是实参的值。</p> 
 <p>3、使用指针变量时，为了表示指针变量所指向的变量，必须使用指针运算符*，而使用</p> 
 <p>引用时，引用就代表该变量，不必使用指针运算符*；</p> 
 <p>4、用引用完成的工作，用指针也能完成。但引用比指针的使用直观、方便，直截了当，</p> 
 <p>不必“兜圈子”，容易理解。有些过去只能用指针来处理的问题，现在可以用引用来代替，</p> 
 <p>从而降低了程序设计的难度。</p> 
 <p>对引用进一步说明：</p> 
 <p>1、不能建立void类型的引用。</p> 
 <p>因为任何实际存在的变量都是属于非void类型的，void的含义是无类型或空类型，</p> 
 <p>void只是在语法上相当于一个类型而已。</p> 
 <p>2、不能建立引用的数组。</p> 
 <p>如：char c[6]="hello";</p> 
 <p>char &amp;rc=c;//错误</p> 
 <p>因为数组名是数组首元素的地址，本身不是一个占有存储空间的变量。</p> 
 <p>3、可以将变量的引用的地址赋给一个指针，此时指针指向的是原来的变量。</p> 
 <p>这句话可以这样说：将引用变量的地址赋给一个指针，此时指针指向的是引用变量，</p> 
 <p>相当于指向原来的变量</p> 
 <p>int a=2;</p> 
 <p>int &amp;b=a;//这个声明语句中的&amp;是一个引用</p> 
 <p>int *p=&amp;b;//这个指针初始化语句中的&amp;是取地址运算符</p> 
 <p>上面一行等价于 int *p=&amp;a;</p> 
 <p>但是不能定义指向引用类型的指针变量，不能写成</p> 
 <p>int &amp; *p=&amp;a;//企图定义指向引用类型的指针变量p，错误</p> 
 <p>因为引用不是一种独立的数据类型，因此不能建立指向引用类型的指针变量。</p> 
 <p>4、可以建立指针变量的引用如</p> 
 <p>int i=5;</p> 
 <p>int *p=&amp;i;</p> 
 <p>int * &amp;pt=p;//建立指针变量p的引用pt</p> 
 <p>引用变量pt代表一个int *类型的数据对象(即指针变量)</p> 
 <p>5、可以用const对引用加以限定，不允许直接改变该引用的值，但是可以改变原</p> 
 <p>变量的值去改变引用的值；</p> 
 <p>int i=5;</p> 
 <p>const int &amp;a=i;</p> 
 <p>a=3;//错误，因为引用a是const int 类型不能直接改变引用的值</p> 
 <p>但是可以这样修改：</p> 
 <p>i=3;</p> 
 <p>此时输出i和a都是3</p> 
 <p>6、可以用常量或表达式对引用进行初始化，但此时必须用const作声明。</p> 
 <p>int i=5;</p> 
 <p>const int &amp;a=i+1;</p> 
 <p>此时编译系统是这样处理的：生成一个临时变量，用来存放该表达式的值，引用是</p> 
 <p>该临时变量的别名、系统将“const int &amp;a=i+1;”转换为</p> 
 <p>int temp=i+1;</p> 
 <p>const int &amp;a=temp;</p> 
 <p>临时变量是在内部实现的，用户不能访问临时变量；</p> 
 <p>用这种办法不仅可以用表达式对引用进行初始化，还可以用不同类型的变量对之</p> 
 <p>初始化；如</p> 
 <p>double d=3.1415926;</p> 
 <p>const int &amp;a=d;</p> 
 <p>以上等价为：</p> 
 <p>double d=3.1415926;</p> 
 <p>int temp=d;</p> 
 <p>const int &amp;a=temp;</p> 
 <p>如果在上面不用const则会发生错误</p> 
 <p>double d=3.1415926;</p> 
 <p>int &amp;a=d;//未加const，错误</p> 
 <p>为什么？因为如果可以这样做，那么修改引用a的值(如a=3.56),则临时变量temp的值也</p> 
 <p>变为3.56，即修改了临时变量temp的值，但不能修改变量d的值，这往往不是用户所希望</p> 
 <p>的，即存在二义性。与其允许修改引用的值而不能实现用户的目的，还不如不允许修改</p> 
 <p>引用的值。这就是C++规定对这类引用必须加const的原因。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/019bb866c12082c55a719bc84c742fae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MarkDown中的表格在jekyll的pages博客中不能正常显示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c4cd0535393d8b8a7deb8f1ae0b79af3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">04748JAVA语言程序设计实践考试复习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>