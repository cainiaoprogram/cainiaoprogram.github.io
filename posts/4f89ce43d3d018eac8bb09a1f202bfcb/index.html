<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; STL基本容器的使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; STL基本容器的使用" />
<meta property="og:description" content="C&#43;&#43;中有两种类型的容器：顺序容器和关联容器。顺序容器主要有vector、list、deque等。其中vector表示一段连续的内存，基于数组实现，list表示非连续的内存，基于链表实现，deque与vector类似，但是对首元素提供插入和删除的双向支持。关联容器主要有map和set。map是key-value形式，set是单值。map和set只能存放唯一的key，multimap和multiset可以存放多个相同的key。
容器类自动申请和释放内存，因此无需new和delete操作。
一、vector
vector基于模板实现，需包含头文件vector。
1.定义和初始化
//1.定义和初始化
vector&lt;int&gt; vec1; //默认初始化，vec1为空
vector&lt;int&gt; vec2(vec1); //使用vec1初始化vec2
vector&lt;int&gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2
vector&lt;int&gt; vec4(10); //10个值为的元素
vector&lt;int&gt; vec5(10,4); //10个值为的元素
//2.常用操作方法
vec1.push_back(100); //添加元素
int size = vec1.size(); //元素个数
bool isEmpty = vec1.empty(); //判断是否为空
cout&lt;&lt;vec1[0]&lt;&lt;endl; //取得第一个元素
vec1.insert(vec1.end(),5,3); //从vec1.back位置插入个值为的元素
//vec1.pop_back(); //删除末尾元素
//vec1.erase(vec1.begin(),vec1.end());//删除之间的元素，其他元素前移
cout&lt;&lt;(vec1==vec2)?true:false; //判断是否相等==、！=、&gt;=、&lt;=...
vector&lt;int&gt;::iterator iter = vec1.begin(); //获取迭代器首地址
vector&lt;int&gt;::const_iterator c_iter = vec1.begin(); //获取const类型迭代器
//vec1.clear(); //清空元素
//3.遍历
//下标法
int length = vec1.size();
for(int i=0;i&lt;length;i&#43;&#43;)
{
cout&lt;&lt;vec1[i];
}
cout&lt;&lt;endl&lt;&lt;endl;
//迭代器法
vector&lt;int&gt;::const_iterator iterator = vec1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4f89ce43d3d018eac8bb09a1f202bfcb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-04-09T21:01:58+08:00" />
<meta property="article:modified_time" content="2014-04-09T21:01:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; STL基本容器的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px">C++中有两种类型的容器：<span style="background:yellow">顺序容器</span>和<span style="background:yellow">关联容器</span>。顺序容器主要有<span style="color:red">vector</span>、<span style="color:red">list</span>、<span style="color:red">deque</span>等。其中vector表示一段连续的内存，基于数组实现，list表示非连续的内存，基于链表实现，deque与vector类似，但是对首元素提供插入和删除的双向支持。关联容器主要有<span style="color:red">map</span>和<span style="color:red">set</span>。map是key-value形式，set是单值。map和set只能存放唯一的key，multimap和multiset可以存放多个相同的key。</span></p> 
<p><span style="font-size:18px">容器类自动申请和释放内存，因此无需new和delete操作。</span></p> 
<p><span style="font-size:18px">一、vector</span></p> 
<p><span style="font-size:18px">vector基于模板实现，需包含头文件vector。</span></p> 
<p><span style="font-size:18px">1.定义和初始化</span></p> 
<table border="1" cellspacing="0" cellpadding="0" width="672"><tbody><tr><td> <p align="left"><span style="font-size:18px">    <span style="color:green">//1.</span><span style="color:green">定义和初始化</span></span></p> <p align="left"><span style="font-size:18px">    vector&lt;<span style="color:blue">int</span>&gt; vec1;    <span style="color:green">//</span><span style="color:green">默认初始化，vec1</span>为空</span></p> <p align="left"><span style="font-size:18px">    vector&lt;<span style="color:blue">int</span>&gt; vec2(vec1);  <span style="color:green">//</span><span style="color:green">使用vec1</span>初始化vec2</span></p> <p align="left"><span style="font-size:18px">    vector&lt;<span style="color:blue">int</span>&gt; vec3(vec1.begin(),vec1.end());<span style="color:green">//</span><span style="color:green">使用vec1</span>初始化vec2</span></p> <p align="left"><span style="font-size:18px">    vector&lt;<span style="color:blue">int</span>&gt; vec4(10);    <span style="color:green">//10</span><span style="color:green">个值为的元素</span></span></p> <p align="left"><span style="font-size:18px">    vector&lt;<span style="color:blue">int</span>&gt; vec5(10,4);  <span style="color:green">//10</span><span style="color:green">个值为的元素</span></span></p> <p align="left"><span style="color:green"><span style="font-size:18px"> </span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//2.</span><span style="color:green">常用操作方法</span></span></p> <p align="left"><span style="font-size:18px">    vec1.push_back(100);            <span style="color:green"> //</span><span style="color:green">添加元素</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:blue">int</span> size = vec1.size();         <span style="color:green">//</span><span style="color:green">元素个数</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:blue">bool</span> isEmpty = vec1.empty();    <span style="color:green">//</span><span style="color:green">判断是否为空</span></span></p> <p align="left"><span style="font-size:18px">    cout&lt;&lt;vec1[0]&lt;&lt;endl;        <span style="color:green"> //</span><span style="color:green">取得第一个元素</span></span></p> <p align="left"><span style="font-size:18px">    vec1.insert(vec1.end(),5,3);    <span style="color:green"> //</span><span style="color:green">从vec1.back</span>位置插入个值为的元素</span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//vec1.pop_back();              //</span><span style="color:green">删除末尾元素</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//vec1.erase(vec1.begin(),vec1.end());//</span><span style="color:green">删除之间的元素，其他元素前移</span></span></p> <p align="left"><span style="font-size:18px">    cout&lt;&lt;(vec1==vec2)?<span style="color:blue">true</span>:<span style="color:blue">false</span>;  <span style="color:green">//</span><span style="color:green">判断是否相等==</span>、！=、&gt;=、&lt;=...</span></p> <p align="left"><span style="font-size:18px">    vector&lt;<span style="color:blue">int</span>&gt;::iterator iter = vec1.begin();    <span style="color:green">//</span><span style="color:green">获取迭代器首地址</span></span></p> <p align="left"><span style="font-size:18px">    vector&lt;<span style="color:blue">int</span>&gt;::const_iterator c_iter = vec1.begin();   <span style="color:green">//</span><span style="color:green">获取const</span>类型迭代器</span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//vec1.clear();                 //</span><span style="color:green">清空元素</span></span></p> <p align="left"><span style="color:green"><span style="font-size:18px"> </span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//3.</span><span style="color:green">遍历</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//</span><span style="color:green">下标法</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:blue">int</span> length = vec1.size();</span></p> <p align="left"><span style="font-size:18px">    <span style="color:blue">for</span>(<span style="color:blue">int</span> i=0;i&lt;length;i++)</span></p> <p align="left"><span style="font-size:18px">    {<!-- --></span></p> <p align="left"><span style="font-size:18px">       cout&lt;&lt;vec1[i];</span></p> <p align="left"><span style="font-size:18px">    }</span></p> <p align="left"><span style="font-size:18px">    cout&lt;&lt;endl&lt;&lt;endl;</span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//</span><span style="color:green">迭代器法</span></span></p> <p align="left"><span style="font-size:18px">    vector&lt;<span style="color:blue">int</span>&gt;::const_iterator iterator = vec1.begin();</span></p> <p align="left"><span style="font-size:18px">    <span style="color:blue">for</span>(;iterator != vec1.end();iterator++)</span></p> <p align="left"><span style="font-size:18px">    {<!-- --></span></p> <p align="left"><span style="font-size:18px">       cout&lt;&lt;*iterator;</span></p> <p><span style="font-size:18px">    }</span></p> </td></tr></tbody></table> 
<p><span style="font-size:18px">二、list</span></p> 
<p><span style="font-size:18px">List是stl实现的双向链表，与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。需要添加头文件list</span></p> 
<table border="1" cellspacing="0" cellpadding="0" width="672"><tbody><tr><td> <p align="left"><span style="font-size:18px">    <span style="color:green">//1.</span><span style="color:green">定义和初始化</span></span></p> <p align="left"><span style="font-size:18px">    list&lt;<span style="color:blue">int</span>&gt; lst1;          <span style="color:green">//</span><span style="color:green">创建空list</span></span></p> <p align="left"><span style="font-size:18px">    list&lt;<span style="color:blue">int</span>&gt; lst2(3);       <span style="color:green">//</span><span style="color:green">创建含有三个元素的list</span></span></p> <p align="left"><span style="font-size:18px">    list&lt;<span style="color:blue">int</span>&gt; lst3(3,2); <span style="color:green">//</span><span style="color:green">创建含有三个元素的list</span></span></p> <p align="left"><span style="font-size:18px">    list&lt;<span style="color:blue">int</span>&gt; lst4(lst2);    <span style="color:green">//</span><span style="color:green">使用lst2</span>初始化lst4</span></p> <p align="left"><span style="font-size:18px">    list&lt;<span style="color:blue">int</span>&gt; lst5(lst2.begin(),lst2.end());  <span style="color:green">//</span><span style="color:green">同lst4</span></span></p> <p align="left"><span style="color:green"><span style="font-size:18px"> </span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//2.</span><span style="color:green">常用操作方法</span></span></p> <p align="left"><span style="font-size:18px">    lst1.assign(lst2.begin(),lst2.end());  <span style="color:green">//</span><span style="color:green">分配值</span></span></p> <p align="left"><span style="font-size:18px">    lst1.push_back(10);                    <span style="color:green">//</span><span style="color:green">添加值</span></span></p> <p align="left"><span style="font-size:18px">    lst1.pop_back();                   <span style="color:green">//</span><span style="color:green">删除末尾值</span></span></p> <p align="left"><span style="font-size:18px">    lst1.begin();                      <span style="color:green">//</span><span style="color:green">返回首值的迭代器</span></span></p> <p align="left"><span style="font-size:18px">    lst1.end();                            <span style="color:green">//</span><span style="color:green">返回尾值的迭代器</span></span></p> <p align="left"><span style="font-size:18px">    lst1.clear();                      <span style="color:green">//</span><span style="color:green">清空值</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:blue">bool</span> isEmpty1 = lst1.empty();          <span style="color:green">//</span><span style="color:green">判断为空</span></span></p> <p align="left"><span style="font-size:18px">    lst1.erase(lst1.begin(),lst1.end());                        <span style="color:green">//</span><span style="color:green">删除元素</span></span></p> <p align="left"><span style="font-size:18px">    lst1.front();                      <span style="color:green">//</span><span style="color:green">返回第一个元素的引用</span></span></p> <p align="left"><span style="font-size:18px">    lst1.back();                       <span style="color:green">//</span><span style="color:green">返回最后一个元素的引用</span></span></p> <p align="left"><span style="font-size:18px">    lst1.insert(lst1.begin(),3,2);         <span style="color:green">//</span><span style="color:green">从指定位置插入个</span></span></p> <p align="left"><span style="font-size:18px">    lst1.rbegin();                         <span style="color:green">//</span><span style="color:green">返回第一个元素的前向指针</span></span></p> <p align="left"><span style="font-size:18px">    lst1.remove(2);                        <span style="color:green">//</span><span style="color:green">相同的元素全部删除</span></span></p> <p align="left"><span style="font-size:18px">    lst1.reverse();                        <span style="color:green">//</span><span style="color:green">反转</span></span></p> <p align="left"><span style="font-size:18px">    lst1.size();                       <span style="color:green">//</span><span style="color:green">含有元素个数</span></span></p> <p align="left"><span style="font-size:18px">    lst1.sort();                       <span style="color:green">//</span><span style="color:green">排序</span></span></p> <p align="left"><span style="font-size:18px">    lst1.unique();                         <span style="color:green">//</span><span style="color:green">删除相邻重复元素</span></span></p> <p align="left"><span style="color:green"><span style="font-size:18px"> </span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//3.</span><span style="color:green">遍历</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//</span><span style="color:green">迭代器法</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:blue">for</span>(list&lt;<span style="color:blue">int</span>&gt;::const_iterator iter = lst1.begin();iter != lst1.end();iter++)</span></p> <p align="left"><span style="font-size:18px">    {<!-- --></span></p> <p align="left"><span style="font-size:18px">       cout&lt;&lt;*iter;</span></p> <p align="left"><span style="font-size:18px">    }</span></p> <p><span style="font-size:18px">    cout&lt;&lt;endl;</span></p> </td></tr></tbody></table> 
<p><span style="font-size:18px">三、deque</span></p> 
<p><span style="font-size:18px"><span style="color:#333333; background:white">deque</span><span style="color:#333333; background:white">容器类与</span><span style="color:#333333; background:white">vector</span><span style="color:#333333; background:white">类似，支持随机访问和快速插入删除，它在容器中某一位置上的操作所花费的是线性时间。与</span><span style="color:#333333; background:white">vector</span><span style="color:#333333; background:white">不同的是，</span><span style="color:#333333; background:white">deque</span><span style="color:#333333; background:white">还支持从开始端插入数据：</span><span style="color:#333333; background:white">push_front()</span><span style="color:#333333; background:white">。其余类似</span><span style="color:#333333; background:white">vector</span><span style="color:#333333; background:white">操作方法的使用。</span></span></p> 
<p><span style="font-size:18px"><span style="color:#333333; background:white">四、</span><span style="color:#333333; background:white">map</span></span></p> 
<p><span style="font-size:18px">C++中map容器提供一个键值对（key/value）容器，map与multimap差别仅仅在于multiple允许一个键对应多个值。需要包含头文件map。<span style="color:#333333; background:white">对于迭代器来说，可以修改实值，而不能修改</span><span style="color:#333333; background:white">key</span><span style="color:#333333; background:white">。</span><span style="color:red; background:white">Map</span><span style="color:red; background:white">会根据</span><span style="color:red; background:white">key</span><span style="color:red; background:white">自动排序。</span></span></p> 
<table border="1" cellspacing="0" cellpadding="0" width="672"><tbody><tr><td> <p align="left"><span style="font-size:18px">    <span style="color:green">//1.</span><span style="color:green">定义和初始化</span></span></p> <p align="left"><span style="font-size:18px">    map&lt;<span style="color:blue">int</span>,string&gt; map1;                  <span style="color:green">//</span><span style="color:green">空map</span></span></p> <p align="left"><span style="font-size:18px">    </span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//2.</span><span style="color:green">常用操作方法</span></span></p> <p align="left"><span style="font-size:18px">    map1[3] = <span style="color:maroon"> "Saniya"</span>;                    <span style="color:green">//</span><span style="color:green">添加元素</span></span></p> <p align="left"><span style="font-size:18px">    map1.insert(map&lt;<span style="color:blue">int</span>,string&gt;::value_type(2,<span style="color:maroon">"Diyabi"</span>));<span style="color:green">//</span><span style="color:green">插入元素</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//map1.insert(pair&lt;int,string&gt;(1,"Siqinsini"));</span></span></p> <p align="left"><span style="font-size:18px">    map1.insert(make_pair&lt;<span style="color:blue">int</span>,string&gt;(4,<span style="color:maroon">"V5"</span>));</span></p> <p align="left"><span style="font-size:18px">    string str = map1[3];                  <span style="color:green">//</span><span style="color:green">根据key</span>取得value，key不能修改</span></p> <p align="left"><span style="font-size:18px">    map&lt;<span style="color:blue">int</span>,string&gt;::iterator iter_map = map1.begin();<span style="color:green">//</span><span style="color:green">取得迭代器首地址</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:blue">int</span> key = iter_map-&gt;first;             <span style="color:green">//</span><span style="color:green">取得eky</span></span></p> <p align="left"><span style="font-size:18px">    string value = iter_map-&gt;second;       <span style="color:green">//</span><span style="color:green">取得value</span></span></p> <p align="left"><span style="font-size:18px">    map1.erase(iter_map);                  <span style="color:green">//</span><span style="color:green">删除迭代器数据</span></span></p> <p align="left"><span style="font-size:18px">    map1.erase(3);                         <span style="color:green">//</span><span style="color:green">根据key</span>删除value</span></p> <p align="left"><span style="font-size:18px">    map1.size();                       <span style="color:green">//</span><span style="color:green">元素个数</span></span></p> <p align="left"><span style="font-size:18px">    map1.empty();                       <span style="color:green">//</span><span style="color:green">判断空</span></span></p> <p align="left"><span style="font-size:18px">    map1.clear();                      <span style="color:green">//</span><span style="color:green">清空所有元素</span></span></p> <p align="left"><span style="color:green"><span style="font-size:18px"> </span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:green">//3.</span><span style="color:green">遍历</span></span></p> <p align="left"><span style="font-size:18px">    <span style="color:blue">for</span>(map&lt;<span style="color:blue">int</span>,string&gt;::iterator iter = map1.begin();iter!=map1.end();iter++)</span></p> <p align="left"><span style="font-size:18px">    {<!-- --></span></p> <p align="left"><span style="font-size:18px">       <span style="color:blue">int</span> keyk = iter-&gt;first;</span></p> <p align="left"><span style="font-size:18px">       string valuev = iter-&gt;second;</span></p> <p><span style="font-size:18px">    }</span></p> </td></tr></tbody></table> 
<p><span style="font-size:18px">五、set</span></p> 
<p><span style="font-size:18px">set的含义是集合，它是一个有序的容器，里面的元素都是排序好的，支持插入，删除，查找等操作，就像一个集合一样。所有的操作的都是严格在logn时间之内完成，效率非常高。set和multiset的区别是：set插入的元素不能相同，但是multiset可以相同。Set默认自动排序。使用方法类似list。</span></p> 
<p><span style="font-size:18px">六、各种容器总结（转自：http://hi.baidu.com/ewook/item/514fc22ecde5940e73863e65）</span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(1) </span><strong>vector</strong><br> <span style="color:#454545">内部数据结构：</span><span style="color:red">数组</span><span style="color:#454545">。</span><span style="color:#454545"><br> </span><span style="color:#454545">随机访问每个元素，所需要的时间为常量。</span><span style="color:#454545"><br> </span><span style="color:#454545">在末尾增加或删除元素所需时间与元素数目无关，在中间或开头增加或删除元素所需时间随元素数目呈线性变化。</span><span style="color:#454545"><br> </span><span style="color:#454545">可动态增加或减少元素，内存管理自动完成，但程序员可以使用</span><span style="color:#454545">reserve()</span><span style="color:#454545">成员函数来管理内存。</span><span style="color:#454545"><br> vector</span><span style="color:#454545">的迭代器在内存重新分配时将失效（它所指向的元素在该操作的前后不再相同）。当把超过</span><span style="color:#454545">capacity()-size()</span><span style="color:#454545">个元素插入</span><span style="color:#454545">vector</span><span style="color:#454545">中时，内存会重新分配，所有的迭代器都将失效；否则，指向当前元素以后的任何元素的迭代器都将失效。当删除元素时，指向被删除元素以后的任何元素的迭代器都将失效。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(2)<strong>deque</strong><br> </span><span style="color:#454545">内部数据结构：</span><span style="color:red">数组</span><span style="color:#454545">。</span><span style="color:#454545"><br> </span><span style="color:#454545">随机访问每个元素，所需要的时间为常量。</span><span style="color:#454545"><br> </span><span style="color:#454545">在开头和末尾增加元素所需时间与元素数目无关，在中间增加或删除元素所需时间随元素数目呈线性变化。</span><span style="color:#454545"><br> </span><span style="color:#454545">可动态增加或减少元素，内存管理自动完成，不提供用于内存管理的成员函数。</span><span style="color:#454545"><br> </span><span style="color:#454545">增加任何元素都将使</span><span style="color:#454545">deque</span><span style="color:#454545">的迭代器失效。在</span><span style="color:#454545">deque</span><span style="color:#454545">的中间删除元素将使迭代器失效。在</span><span style="color:#454545">deque</span><span style="color:#454545">的头或尾删除元素时，只有指向该元素的迭代器失效。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(3)<strong>list</strong><br> </span><span style="color:#454545">内部数据结构：</span><span style="color:red">双向环状链表</span><span style="color:#454545">。</span><span style="color:#454545"><br> </span><span style="color:#454545">不能随机访问一个元素。</span><span style="color:#454545"><br> </span><span style="color:#454545">可双向遍历。</span><span style="color:#454545"><br> </span><span style="color:#454545">在开头、末尾和中间任何地方增加或删除元素所需时间都为常量。</span><span style="color:#454545"><br> </span><span style="color:#454545">可动态增加或减少元素，内存管理自动完成。</span><span style="color:#454545"><br> </span><span style="color:#454545">增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(4)<strong>slist</strong><br> </span><span style="color:#454545">内部数据结构：</span><span style="color:red">单向链表</span><span style="color:#454545">。</span><span style="color:#454545"><br> </span><span style="color:#454545">不可双向遍历，只能从前到后地遍历。</span><span style="color:#454545"><br> </span><span style="color:#454545">其它的特性同</span><span style="color:#454545">list</span><span style="color:#454545">相似。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(5)<strong>stack</strong><br> </span><span style="color:#454545">适配器，它可以将任意类型的序列容器转换为一个</span><span style="color:red">堆栈</span><span style="color:#454545">，一般使用</span><span style="color:#454545">deque</span><span style="color:#454545">作为支持的序列容器。</span><span style="color:#454545"><br> </span><span style="color:#454545">元素只能后进先出（</span><span style="color:#454545">LIFO</span><span style="color:#454545">）。</span><span style="color:#454545"><br> </span><span style="color:#454545">不能遍历整个</span><span style="color:#454545">stack</span><span style="color:#454545">。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(6)<strong>queue</strong><br> </span><span style="color:#454545">适配器，它可以将任意类型的</span><span style="color:red">序列容器转换为一个队列</span><span style="color:#454545">，一般使用</span><span style="color:#454545">deque</span><span style="color:#454545">作为支持的序列容器。</span><span style="color:#454545"><br> </span><span style="color:#454545">元素只能先进先出（</span><span style="color:#454545">FIFO</span><span style="color:#454545">）。</span><span style="color:#454545"><br> </span><span style="color:#454545">不能遍历整个</span><span style="color:#454545">queue</span><span style="color:#454545">。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(7)<strong>priority_queue</strong><br> </span><span style="color:#454545">适配器，它可以将任意类型的序列容器转换为一个优先级队列，一般使用</span><span style="color:#454545">vector</span><span style="color:#454545">作为底层存储方式。</span><span style="color:#454545"><br> </span><span style="color:#454545">只能访问第一个元素，不能遍历整个</span><span style="color:#454545">priority_queue</span><span style="color:#454545">。</span><span style="color:#454545"><br> </span><span style="color:#454545">第一个元素始终是优先级最高的一个元素。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(8)<strong>set</strong><br> </span><span style="color:#454545">键和值相等。</span><span style="color:#454545"><br> </span><span style="color:#454545">键唯一。</span><span style="color:#454545"><br> </span><span style="color:#454545">元素默认按升序排列。</span><span style="color:#454545"><br> </span><span style="color:#454545">如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(9)<strong>multiset</strong><br> </span><span style="color:#454545">键可以不唯一。</span><span style="color:#454545"><br> </span><span style="color:#454545">其它特点与</span><span style="color:#454545">set</span><span style="color:#454545">相同。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(10)<strong>hash_set</strong><br> </span><span style="color:#454545">与</span><span style="color:#454545">set</span><span style="color:#454545">相比较，它里面的元素不一定是经过排序的，而是按照所用的</span><span style="color:#454545">hash</span><span style="color:#454545">函数分派的，它能提供更快的搜索速度（当然跟</span><span style="color:#454545">hash</span><span style="color:#454545">函数有关）。</span><span style="color:#454545"><br> </span><span style="color:#454545">其它特点与</span><span style="color:#454545">set</span><span style="color:#454545">相同。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(11)<strong>hash_multiset</strong><br> </span><span style="color:#454545">键可以不唯一。</span><span style="color:#454545"><br> </span><span style="color:#454545">其它特点与</span><span style="color:#454545">hash_set</span><span style="color:#454545">相同。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(12)<strong>map</strong><br> </span><span style="color:#454545">键唯一。</span><span style="color:#454545"><br> </span><span style="color:#454545">元素默认按键的升序排列。</span><span style="color:#454545"><br> </span><span style="color:#454545">如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(13)<strong>multimap</strong><br> </span><span style="color:#454545">键可以不唯一。</span><span style="color:#454545"><br> </span><span style="color:#454545">其它特点与</span><span style="color:#454545">map</span><span style="color:#454545">相同。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(14)<strong>hash_map</strong><br> </span><span style="color:#454545">与</span><span style="color:#454545">map</span><span style="color:#454545">相比较，它里面的元素不一定是按键值排序的，而是按照所用的</span><span style="color:#454545">hash</span><span style="color:#454545">函数分派的，它能提供更快的搜索速度（当然也跟</span><span style="color:#454545">hash</span><span style="color:#454545">函数有关）。</span><span style="color:#454545"><br> </span><span style="color:#454545">其它特点与</span><span style="color:#454545">map</span><span style="color:#454545">相同。</span></span></p> 
<p style="background:white"><span style="font-size:18px"><span style="color:#454545">(15)<strong>hash_multimap</strong><br> </span><span style="color:#454545">键可以不唯一。</span><span style="color:#454545"><br> </span><span style="color:#454545">其它特点与</span><span style="color:#454545">hash_map</span><span style="color:#454545">相同。</span></span></p> 
<p><span style="font-size:18px"> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29350159581179ee2e4efae81fcc4bb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于android交互设计的那点事</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2c461fb9b9f929138fa0ac4e83d472c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">移动设备网络代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>