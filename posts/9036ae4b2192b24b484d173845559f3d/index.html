<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM8  bootloader（boot和app皆可使用中断） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM8  bootloader（boot和app皆可使用中断）" />
<meta property="og:description" content="STM8 In Application Programming IAP编写的三个要点：
分析STM8启动过程和C运行时环境建立规划bootloader和application以及各自向量表在内存中的分布如何重定位STM8中断向量表 思路： 要编写IAP程序首先需要解决的问题是程序在运行过程中，当发生异常时，如何保证程序正常的跳转到相应的异常服务函数（不论程序是运行在bootloader还是application）。
但STM8没有类似NVIC之类的中断控制器管理中断向量的地址，STM8的向量表固定在0x008000，因此在IAP中需要重定位向量表来实现（为了bootLoader和application都可以使用中断，因此，选择将向量表重定位到RAM中）
规划内存分布 针对于STM8L052C6（2K RAM/32K FLASH）
FLASH分布
0x8000bootloader_startbootloader0xBFFFbootloader_end0xC000app_startapp0xFFFFapp_end 在0x8000开始的前128个字节，放置着bootloader重定位过的向量表（bootloader的真正的向量表放置在另外的地方）
在0xC000开始的前128个字节，放置着application的向量表
RAM分布
0x0000reload_vector0x0080.data/.bss/.textrw0x07FF 在0x000000开始的128个字节，放置着真正的向量表。（因此，不论在bootloader还是application都要在编译阶段告知链接器保留0x00~0x80这段内存空间）
利用RAM的特性(rwx)，当bootloader运行时，放置bootloader的向量表，当application运行时，放置application的向量表。
详细的分布规则，请参考config目录下的lnkstm8l052c6.icf文件
链接脚本语法请参考IARforSTM8/stm8/doc目录下的EWSTM8_DevelopmentGuide.pdf文件
重定位STM8中断向量表 由于STM8的向量表固定在0x008000~0x008080的位置，想要实现重定位向量表，则必须在固定的向量表中填入真正的向量表地址，方法如下：（参考src目录下的stm8l15x_interrupt.s文件）
/* * The interrupt vector table. */ SECTION `.intvec`:CONST define_vector MACRO DC8 0x82 DC24 _interrupt_\1 ENDM PUBLIC __intvec EXTERN __iar_program_start __intvec: DC8 0x82 DC24 __iar_program_start ;; RESET 0x8000 DC8 0x82 DC24 0x0004 DC8 0x82 DC24 0x0008 DC8 0x82 DC24 0x000C DC8 0x82 DC24 0x0010 DC8 0x82 DC24 0x0014 DC8 0x82 DC24 0x0018 DC8 0x82 DC24 0x001C DC8 0x82 DC24 0x0020 DC8 0x82 DC24 0x0024 DC8 0x82 DC24 0x0028 DC8 0x82 DC24 0x002C DC8 0x82 DC24 0x0030 DC8 0x82 DC24 0x0034 DC8 0x82 DC24 0x0038 DC8 0x82 DC24 0x003C DC8 0x82 DC24 0x0040 DC8 0x82 DC24 0x0044 DC8 0x82 DC24 0x0048 DC8 0x82 DC24 0x004C DC8 0x82 DC24 0x0050 DC8 0x82 DC24 0x0054 DC8 0x82 DC24 0x0058 DC8 0x82 DC24 0x005C DC8 0x82 DC24 0x0060 DC8 0x82 DC24 0x0064 DC8 0x82 DC24 0x0068 DC8 0x82 DC24 0x006C DC8 0x82 DC24 0x0070 DC8 0x82 DC24 0x0074 DC8 0x82 DC24 0x0078 DC8 0x82 DC24 0x007C 汇编语法请参考IARforSTM8/stm8/doc目录下的EWSTM8_AssemblerReference." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9036ae4b2192b24b484d173845559f3d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-29T15:38:52+08:00" />
<meta property="article:modified_time" content="2019-03-29T15:38:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM8  bootloader（boot和app皆可使用中断）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="STM8_In_Application_Programming_1"></a>STM8 In Application Programming</h2> 
<p>IAP编写的三个要点：</p> 
<ol><li>分析STM8启动过程和C运行时环境建立</li><li>规划bootloader和application以及各自向量表在内存中的分布</li><li>如何重定位STM8中断向量表</li></ol> 
<h3><a id="_9"></a>思路：</h3> 
<p>要编写IAP程序首先需要解决的问题是<strong>程序在运行过程中，当发生异常时，如何保证程序正常的跳转到相应的异常服务函数（不论程序是运行在bootloader还是application）</strong>。</p> 
<p>但STM8没有类似NVIC之类的中断控制器管理中断向量的地址，STM8的向量表固定在<strong>0x008000</strong>，因此在IAP中需要重定位向量表来实现（为了bootLoader和application都可以使用中断，因此，选择将向量表重定位到RAM中）</p> 
<h3><a id="_15"></a>规划内存分布</h3> 
<p>针对于STM8L052C6（2K RAM/32K FLASH）</p> 
<p>FLASH分布</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>0x8000</td><td>bootloader_start</td></tr><tr><td></td><td>bootloader</td></tr><tr><td>0xBFFF</td><td>bootloader_end</td></tr><tr><td>0xC000</td><td>app_start</td></tr><tr><td></td><td>app</td></tr><tr><td>0xFFFF</td><td>app_end</td></tr></tbody></table> 
<p>在0x8000开始的前128个字节，放置着bootloader重定位过的向量表（bootloader的真正的向量表放置在另外的地方）</p> 
<p>在0xC000开始的前128个字节，放置着application的向量表</p> 
<p>RAM分布</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>0x0000</td><td></td></tr><tr><td></td><td>reload_vector</td></tr><tr><td>0x0080</td><td></td></tr><tr><td></td><td>.data/.bss/.textrw</td></tr><tr><td>0x07FF</td><td></td></tr></tbody></table> 
<p>在0x000000开始的128个字节，放置着真正的向量表。（因此，不论在bootloader还是application都要在编译阶段告知链接器保留0x00~0x80这段内存空间）</p> 
<p>利用RAM的特性(rwx)，当bootloader运行时，放置bootloader的向量表，当application运行时，放置application的向量表。</p> 
<p><strong>详细的分布规则，请参考config目录下的lnkstm8l052c6.icf文件</strong></p> 
<p>链接脚本语法请参考<strong>IARforSTM8/stm8/doc</strong>目录下的<strong>EWSTM8_DevelopmentGuide.pdf</strong>文件</p> 
<h3><a id="STM8_51"></a>重定位STM8中断向量表</h3> 
<p>由于STM8的向量表固定在0x008000~0x008080的位置，想要实现重定位向量表，则必须在固定的向量表中填入真正的向量表地址，方法如下：（参考src目录下的stm8l15x_interrupt.s文件）</p> 
<pre><code>/*
 * The interrupt vector table.
 */


        SECTION `.intvec`:CONST

define_vector MACRO
        DC8     0x82
        DC24    _interrupt_\1
        ENDM

        PUBLIC  __intvec
        EXTERN   __iar_program_start
        


__intvec:
        DC8     0x82
        DC24    __iar_program_start          ;; RESET    0x8000
        DC8     0x82
        DC24    0x0004
        DC8     0x82
        DC24    0x0008
        DC8     0x82
        DC24    0x000C
        DC8     0x82
        DC24    0x0010
        DC8     0x82
        DC24    0x0014
        DC8     0x82
        DC24    0x0018
        DC8     0x82
        DC24    0x001C
        DC8     0x82
        DC24    0x0020
        DC8     0x82
        DC24    0x0024
        DC8     0x82
        DC24    0x0028
        DC8     0x82
        DC24    0x002C
        DC8     0x82
        DC24    0x0030
        DC8     0x82
        DC24    0x0034
        DC8     0x82
        DC24    0x0038
        DC8     0x82
        DC24    0x003C
        DC8     0x82
        DC24    0x0040
        DC8     0x82
        DC24    0x0044
        DC8     0x82
        DC24    0x0048
        DC8     0x82
        DC24    0x004C
        DC8     0x82
        DC24    0x0050
        DC8     0x82
        DC24    0x0054
        DC8     0x82
        DC24    0x0058
        DC8     0x82
        DC24    0x005C
        DC8     0x82
        DC24    0x0060
        DC8     0x82
        DC24    0x0064
        DC8     0x82
        DC24    0x0068
        DC8     0x82
        DC24    0x006C
        DC8     0x82
        DC24    0x0070
        DC8     0x82
        DC24    0x0074
        DC8     0x82
        DC24    0x0078
        DC8     0x82
    	DC24    0x007C
</code></pre> 
<p>汇编语法请参考<strong>IARforSTM8/stm8/doc</strong>目录下的<strong>EWSTM8_AssemblerReference.pdf</strong>文件</p> 
<h4><a id="_140"></a>说明：</h4> 
<p>以TRAP中断为例，当发送TRAP中断时，PC指针首先指向0x008004地址（FLASH/硬件自动完成）去取指，取到的指令操作码为 <code>82 00 00 04</code>，这段操作码对应的指令为<code>INT 0x000004</code>，操作为将目标地址（0x000004）加载到PC寄存器中，效果等于PC指针指向0x000004地址（RAM）去取指，同样的，在0x000004地址处（RAM）存放着指令操作码<code>82 00 b8 db</code>，其中在0x00b8db地址处（FLASH）存放着真正的TRAP中断服务程序，当PC指针指向0x00b8db地址后，从而执行TRAP中断服务函数。</p> 
<p>STM8命令集及操作码请参考：<br> <a href="http://www.st.com/content/ccc/resource/technical/document/programming_manual/43/24/13/9a/89/df/45/ed/CD00161709.pdf/files/CD00161709.pdf/jcr:content/translations/en.CD00161709.pdf" rel="nofollow" title="STM8 CPU programming manual">http://www.st.com/content/ccc/resource/technical/document/programming_manual/43/24/13/9a/89/df/45/ed/CD00161709.pdf/files/CD00161709.pdf/jcr:content/translations/en.CD00161709.pdf</a></p> 
<h4><a id="RAMbootloader_147"></a>在RAM中放置bootloader的向量表</h4> 
<pre><code>typedef void (INTERRUPT *interrupt_handler_t)(void);
struct interrupt_vector {
    unsigned char interrupt_instruction;
    unsigned char reserve;
    interrupt_handler_t interrupt_handler;
};
struct interrupt_vector isr_handler[32] @".memvectab" = {
    {0x82, 0x00, __iar_program_start},
    {0x82, 0x00, TRAP_IRQHandler},
    {0x82, 0x00, NMI_IRQHandler},
    {0x82, 0x00, FLASH_IRQHandler},
    {0x82, 0x00, DMA1_CHANNEL0_1_IRQHandler},
    {0x82, 0x00, DMA1_CHANNEL2_3_IRQHandler},
    {0x82, 0x00, RTC_CSSLSE_IRQHandler},
    {0x82, 0x00, EXTIE_F_PVD_IRQHandler},
    {0x82, 0x00, EXTIB_G_IRQHandler},
    {0x82, 0x00, EXTID_H_IRQHandler},
    {0x82, 0x00, EXTI0_IRQHandler},
    {0x82, 0x00, EXTI1_IRQHandler},
    {0x82, 0x00, EXTI2_IRQHandler},
    {0x82, 0x00, EXTI3_IRQHandler},
    {0x82, 0x00, EXTI4_IRQHandler},
    {0x82, 0x00, EXTI5_IRQHandler},
    {0x82, 0x00, EXTI6_IRQHandler},
    {0x82, 0x00, EXTI7_IRQHandler},
    {0x82, 0x00, LCD_AES_IRQHandler},
    {0x82, 0x00, SWITCH_CSS_BREAK_DAC_IRQHandler},
    {0x82, 0x00, ADC1_COMP_IRQHandler},
    {0x82, 0x00, TIM2_UPD_OVF_TRG_BRK_USART2_TX_IRQHandler},
    {0x82, 0x00, TIM2_CC_USART2_RX_IRQHandler},
    {0x82, 0x00, TIM3_UPD_OVF_TRG_BRK_USART3_TX_IRQHandler},
    {0x82, 0x00, TIM3_CC_USART3_RX_IRQHandler},
    {0x82, 0x00, TIM1_UPD_OVF_TRG_COM_IRQHandler},
    {0x82, 0x00, TIM1_CC_IRQHandler},
    {0x82, 0x00, TIM4_UPD_OVF_TRG_IRQHandler},
    {0x82, 0x00, SPI1_IRQHandler},
    {0x82, 0x00, USART1_TX_TIM5_UPD_OVF_TRG_BRK_IRQHandler},
    {0x82, 0x00, USART1_RX_TIM5_CC_IRQHandler},
    {0x82, 0x00, I2C1_SPI2_IRQHandler}
};
</code></pre> 
<p>同时，在链接脚本中，将<code>.memvectab</code>这个section 放置在RAM的0x000000地址处。</p> 
<h3><a id="STM8_191"></a>STM8启动过程</h3> 
<p>在上面两部分中介绍的，在RAM的0x00~0x80地址处会在不同阶段时放置bootloader和application的两张向量表，因此必然涉及到两张向量表的互相覆盖。</p> 
<p>在STM8启动时，会执行__iar_program_start这个函数（此函数由IAR提供），这个函数负责建立C运行时环境和数据的拷贝，因此，在这个阶段会将bootloader真正的向量表从FLASH拷贝到RAM的0x00 ~ 0x80地址处（由链接脚本指定），当需要跳转到application时，运行以下代码将application的向量表拷贝到RAM的0x00 ~ 0x80地址处然后跳转：</p> 
<pre><code>void reload_interrupr_vectortable(void)
{
	uint8_t *check = (uint8_t *)APPLICATION_ADDRESS;

	if(*check == 0x82) {
        uint8_t *src = (uint8_t *)APPLICATION_ADDRESS;
        uint8_t *dst = (uint8_t *)VECTAB_RELOAD_START;
        uint16_t cnt = sizeof(isr_handler);

    	/* disable interrupt, interrupt will be enable in application */
    	sim();
        platform_peripherals_deinit();
        /* reload interrupt vector table(application) from flash to memory */
        for(; cnt &gt; 0; cnt--) {
            *dst++ = *src++;
        }

        /* reset stack pointer (lower byte - because compiler decreases SP with some bytes) */
        asm("LDW X,  SP ");
        asm("LD  A,  $FF");
        asm("LD  XL, A  ");
        asm("LDW SP, X  ");
        asm("JPF $C000  "); /* APPLICATION_ADDRESS */
	}
}
</code></pre> 
<p>通过汇编指令<code>asm("JPF $C000")</code>跳转到application的起始地址处，开始运行application。</p> 
<p>当复位时，会重新执行__iar_program_start函数，将bootloader的向量表再次拷贝到RAM的0x00~0x80地址处，覆盖application的向量表。</p> 
<p>至此，IAP编写的难点都已解决。</p> 
<p>附连接脚本</p> 
<pre><code>/
//      Example ILINK command file for
//      STM8 IAR C/C++ Compiler and Assembler.
//
//      Copyright 2017 HinsShum.
//
//      $Revision: 1623 $
//
/

/*-Symbol-*/
define symbol __intvec_start__      = 0x000000;
define symbol __region_TINY_start__ = 0x000000;
define symbol __region_TINY_end__   = 0x0000FF;
define symbol __region_ROM_start__  = 0x008000;
define symbol __region_ROM_end__    = 0x00BFFF; /* 16K bootloader flash region */
define symbol __region_RAM_start__  = 0x000000;
define symbol __region_RAM_end__    = 0x000FFF; /* 4K RAM region */
define symbol __RAMCACHE_start__    = 0x000100;

/*-Memory Regions-*/
define memory mem with size = 16M;
define region TinyData   = mem:[from __region_TINY_start__ to __region_TINY_end__];
define region ROM_region = mem:[from __region_ROM_start__ to __region_ROM_end__];
define region RAM_region = mem:[from __region_RAM_start__ to __region_RAM_end__];

/

define block CSTACK     with size    = _CSTACK_SIZE, alignment = 1 {};
define block HEAP       with size    = _HEAP_SIZE,   alignment = 1 {};
define block INTVEC     with size    = 0x80,         alignment = 4 { ro section .intvec };
define block INTVECMEM  with size    = 0x80,         alignment = 4 { rw section .memvectab };
define block RAMCACHE   with size    = 0x40,         alignment = 1 {};
define block MD5API     with size    = 0x06,         alignment = 2 { ro section .md5_api };

initialize by copy { rw section .*.textrw, rw data, zi };
do not initialize { rw section vregs, rw section .noinit };

// Keep section
keep { section .memvectab };
keep { block RAMCACHE };
keep { section .md5_api };

// Placement
place at start of ROM_region    { block INTVEC };
place in ROM_region             { ro code, ro data };     // includes ro code and data
place at end of ROM_region      { block MD5API };         // provide md5 api to application

place at address mem: __intvec_start__ { block INTVECMEM };
place in TinyData               { rw section .vregs };
place at address mem: __RAMCACHE_start__ { block RAMCACHE };
place in RAM_region             { rw code, rw data, rw section .*.textrw };
place in RAM_region             { zi };
place in RAM_region             { block HEAP };
place at end of RAM_region      { block CSTACK };
/
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af3ca36da0859be90fdf6a1b6c1d314f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">外部访问docker容器(docker run -p/-P 指令)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cd896c3c97c641e42b65095df0b4443e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">岛屿的个数-Java实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>