<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构笔记】数据结构基础—链表 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构笔记】数据结构基础—链表" />
<meta property="og:description" content="1.线性表的链式存储结构 特点：下一节点data的起始地址存在了上一节点的next中，所以链表末尾的指针一定会指向NULL
将线性表中各元素分布在存储器的不同存储块，成为节点，通过地址或指针建立元素之间的联系。
节点的data域存放数据元素，而next域是一个指针，指向直接后继所在的节点。
节点类型描述：
typedef struct node{ data_t data; //结点的数据域// struct node *next; //结点的后继指针域// }listnode, *linklist; 设p指向链表中节点，
获取 ：p-&gt;data
获取：p-&gt;next-&gt;data
若指针p的值为NULL，则它不指向任何节点，此时取p-&gt;data或p-&gt;next-&gt;data是错误的，会报段错误。
向系统申请节点的存储空间：
linklist p; p = (linklist)malloc(sizeof(listnode)); 2.单链表的基本操作 创建 ①申请内存 ②赋值 ③返回头部指针
linklist list_create() { linklist H; H = (linklist)malloc(sizeof(listnode)); if (H == NULL) { printf(&#34;malloc failed\n&#34;); return H; } H-&gt;data = 0; H-&gt;next = NULL; return H; } 尾部插入 ①建一个新节点
②找尾节点
③尾部插入
int list_tail_insert(linklist H, data_t value) { linklist p; linklist q; if (H == NULL) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/aa504d109f53bb1fe262bbe2fb28bd44/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-26T21:34:31+08:00" />
<meta property="article:modified_time" content="2021-08-26T21:34:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构笔记】数据结构基础—链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.线性表的链式存储结构</h2> 
<p>        <strong>特点</strong>：下一节点data的起始地址存在了上一节点的next中，所以链表末尾的指针一定会指向NULL</p> 
<p>        将线性表<img alt="L=(a_{0},a_{1},.......,a_{n-1})" class="mathcode" src="https://images2.imgbox.com/24/a8/5haeUfAU_o.png">中各元素分布在存储器的不同存储块，成为节点，通过地址或指针建立元素之间的联系。</p> 
<p style="text-align:center;"><img alt="" height="53" src="https://images2.imgbox.com/b3/32/MjJraI9O_o.png" width="292"></p> 
<p> 节点的data域存放数据元素<img alt="a_{i}" class="mathcode" src="https://images2.imgbox.com/aa/a9/37xsSjcT_o.png">，而next域是一个指针，指向直接后继<img alt="a_{i+1}" class="mathcode" src="https://images2.imgbox.com/20/73/zIrUtSjM_o.png">所在的节点。</p> 
<p style="text-align:center;"><img alt="" height="100" src="https://images2.imgbox.com/9b/0a/9sqb4D7Y_o.png" width="986"></p> 
<p><strong> 节点类型描述</strong>：</p> 
<pre><code class="language-cpp">typedef struct node{  
    data_t data;   //结点的数据域//
    struct node *next;  //结点的后继指针域//
}listnode, *linklist; </code></pre> 
<p> 设p指向链表中节点<img alt="a_{i}" class="mathcode" src="https://images2.imgbox.com/78/d0/XWY5eFDG_o.png">，</p> 
<p style="text-align:center;"><img alt="" height="78" src="https://images2.imgbox.com/f6/29/3pGRy1cg_o.png" width="475"></p> 
<p><strong>获取<img alt="a_{i}" class="mathcode" src="https://images2.imgbox.com/11/8e/Dq2JOd4Y_o.png"> </strong>：p-&gt;data</p> 
<p><strong>获取<img alt="a_{i+1}" class="mathcode" src="https://images2.imgbox.com/88/cb/uRz6XDl6_o.png"></strong>：p-&gt;next-&gt;data</p> 
<p>若指针p的值为NULL，则它不指向任何节点，此时取p-&gt;data或p-&gt;next-&gt;data是错误的，会报段错误。</p> 
<p><strong>向系统申请节点的存储空间：</strong></p> 
<pre><code class="language-cpp">linklist p;
p = (linklist)malloc(sizeof(listnode));</code></pre> 
<h2>2.单链表的基本操作</h2> 
<h3> 创建</h3> 
<p><img alt="" height="237" src="https://images2.imgbox.com/d9/00/P2EPB1G7_o.png" width="1200"></p> 
<p>①申请内存 ②赋值 ③返回头部指针</p> 
<pre><code class="language-cpp">linklist list_create() {
	linklist H;

	H = (linklist)malloc(sizeof(listnode));
	if (H == NULL) {
		printf("malloc failed\n");
		return H;
	}
	
	H-&gt;data = 0;
	H-&gt;next = NULL;

	return H;
}</code></pre> 
<h3>尾部插入</h3> 
<p>①建一个新节点</p> 
<p>②找尾节点</p> 
<p>③尾部插入</p> 
<pre><code class="language-cpp">int list_tail_insert(linklist H, data_t value) {
	linklist p;
	linklist q;

	if (H == NULL) {
		printf("H is NULL\n");
		return -1;
	}

	//1 new node p
	if ((p = (linklist)malloc(sizeof(listnode))) == NULL) {
		printf("malloc failed\n");
		return -1;
	}
	p-&gt;data = value;
	p-&gt;next = NULL;
	
	//2 寻找尾节点，尾节点的特征是它的next指针指向NULL
// 这里最好不要理解为赋值，而是理解为q也指向了H所指向的地方
	q = H; // 这里要让q也指向头节点，后面用q去遍历链表，不能用H，因为H必须一直指向头节点
	while (q-&gt;next != NULL) {
		q = q-&gt;next;  // 挨个节点的遍历
	}

	//3 insert
	q-&gt;next = p;

	return 0;
}</code></pre> 
<h3>输出链表中的元素值</h3> 
<pre><code class="language-cpp">int list_show(linklist H) {
	linklist p;

	if (H == NULL) {
		printf("H is NULL\n");
		return -1;
	}

	p = H; // p同样也指向了链表头部的指针，头部是没有值的，但它指向后一个节点的元素值

	while (p-&gt;next != NULL) {
		printf("%d ", p-&gt;next-&gt;data);
		p = p-&gt;next;
	}
	puts("");

	return 0;
}</code></pre> 
<h3>按位置插入</h3> 
<p><img alt="" height="600" src="https://images2.imgbox.com/4c/20/GuAHKha7_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>注</strong></span>：插入时，先让q指向<img alt="a_{i}" class="mathcode" src="https://images2.imgbox.com/f2/eb/UZVHUQmp_o.png">，再让p指向q，这样的话链表的逻辑关系不会断，没有风险，否则若先让p指向q，那么链表就断了，会有风险。</p> 
<p><span style="color:#fe2c24;"><strong>注</strong></span>：H是指向头节点的指针，头节点的值不重要，因为这个头节点中的next（即H-&gt;next）指向的才是<img alt="a_{0}" class="mathcode" src="https://images2.imgbox.com/12/13/K1F6I2iU_o.png">，H-&gt;data是多少无所谓，这里链表的元素还没开始呢，符号-&gt;表示调用结构体指针中的成员变量。</p> 
<p><strong>链表查找</strong></p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/82/c4/DpnAxLAN_o.png" width="1200"></p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/54/00/OqrrRyzn_o.png" width="1200"></p> 
<p> 先考虑特殊情况：①H == NULL ②pos = -1</p> 
<pre><code class="language-cpp">// 找位置索引为pos的节点，找到后，返回指向pos位置的值的指针
// 即pos位置节点的前一个节点的next
linklist list_get(linklist H, int pos) {
	linklist p;
	int i;

	if (H == NULL) {
		printf("H is NULL\n");
		return NULL;
	}

	if (pos == -1) {
		return H;
	}

	p = H;
	i = -1;  
	while (i &lt; pos) { // 如果第一个有值的节点的索引（序号）是0的话，到pos索引需要运行pos+1次p = p-&gt;next
		p = p-&gt;next;   // 这里要计算一下，i从-1到pos的次数决定了p = p-&gt;next的次数，即最终指向的值
		if (p == NULL) {
			printf("pos is invalid\n");
			return NULL;
		}
		i++;
	}

	return p;
}</code></pre> 
<p><strong>按位置插入</strong></p> 
<pre><code class="language-cpp">int list_insert(linklist H, data_t value, int pos) {
	linklist p;
	linklist q;

	if (H == NULL) {
		printf("H is NULL\n");
		return -1;
	}

	//1 locate node p (pos-1)
	p = list_get(H, pos-1); // 找到目标节点的前一个位置
	if (p == NULL) {
		return -1;
	}

	//2 new node q
	if ((q = (linklist)malloc(sizeof(listnode))) == NULL) {
		printf("malloc failed\n");
		return -1;
	}
	q-&gt;data = value;
	q-&gt;next = NULL;

	//3 insert ，这里注意顺序
	q-&gt;next = p-&gt;next;
	p-&gt;next = q;

	return 0;
}</code></pre> 
<h3>按位置删除</h3> 
<p><img alt="" height="365" src="https://images2.imgbox.com/0e/50/W4dYHvP9_o.png" width="1200"></p> 
<p> 即 <img alt="p\rightarrow next = p\rightarrow next\rightarrow next" class="mathcode" src="https://images2.imgbox.com/bb/c6/Q3xsZKlE_o.png">,（其中p指向待删除节点的前驱节点），但这样做中间节点就不会被释放。要这样：</p> 
<p>①<img alt="q = p\rightarrow next" class="mathcode" src="https://images2.imgbox.com/29/3d/DKAF9ZWU_o.png"></p> 
<p>②<img alt="p\rightarrow next = q\rightarrow next" class="mathcode" src="https://images2.imgbox.com/6d/da/HuCY1Srb_o.png"></p> 
<p>③free q</p> 
<pre><code class="language-cpp">int list_delete(linklist H, int pos) {
	linklist p;
	linklist q;

	//1
	if (H == NULL) {
		printf("H is NULL\n");
		return -1;
	}

	//2 locate prior
	p = list_get(H, pos-1);
	if (p == NULL) 
		return -1;
	if (p-&gt;next == NULL) { //即，此时前驱是链表的最后一个节点
		printf("delete pos is invalid\n");
		return -1;
	}

	//3 update list
	q = p-&gt;next;
	p-&gt;next = q-&gt;next;//p-&gt;next = p-&gt;next-&gt;next;

	//4 free
	printf("free:%d\n", q-&gt;data);
	free(q);
	q = NULL;

	return 0;
}</code></pre> 
<h3> 链表释放</h3> 
<pre><code class="language-cpp">linklist list_free(linklist H) {
	linklist p;

	if (H == NULL) 
		return NULL;

	p = H;

	printf("free:");
	while (H != NULL) { // 这里不能用H-&gt;next != NULL，因为这是释放整个链表，头节点也不能跑
		p = H;
		printf("%d ", p-&gt;data);
		free(p);
		H = H-&gt;next;
	}
	puts("");

	return NULL;
}</code></pre> 
<h2>3.单链表的复杂操作</h2> 
<h3>链表的反转</h3> 
<p><img alt="" height="442" src="https://images2.imgbox.com/c6/92/RFkizMbj_o.png" width="1200"></p> 
<pre><code class="language-cpp">int list_reverse(linklist H) {
	linklist p;
	linklist q;

	if (H == NULL) { // 特殊情况1：链表为空
		printf("H is NULL\n");
		return -1;
	}

// 特殊情况2：链表只有头指针，或只有一个元素，H-&gt;next是指向链表第一个元素的指针，H-&gt;next-&gt;next指向第二个元素
	if (H-&gt;next == NULL || H-&gt;next-&gt;next == NULL) { 
		return 0;
	}
	
// 这里要注意先后顺序，要先复制指向第二个元素的指针，再断开该指针
// 这样链表的逻辑不会断
	p = H-&gt;next-&gt;next;
	H-&gt;next-&gt;next = NULL; 

	while (p != NULL) {
		
// p负责往后遍历节点，指向待操作节点，如果节点非空，就传给q，通过q把这个节点插到H后面
		q = p;
		p = p-&gt;next;

// 将q插入到H节点之后，这里同样注意顺序，先让q的next指针和H的next指针指向同一个地方
// 再让H的next指针指向q，就完成了节点的插入
		q-&gt;next = H-&gt;next;
		H-&gt;next = q;
	}

	return 0;
}</code></pre> 
<h3>链表求相邻两个节点最大值</h3> 
<p><img alt="" height="534" src="https://images2.imgbox.com/55/3a/WXlC8ZK9_o.png" width="1200"></p> 
<pre><code class="language-cpp">linklist list_adjmax(linklist H, data_t *value) {
	linklist p, q, r;
	data_t sum;

	if (H == NULL){  // 特殊情况：头指针都没有
		printf("H is NULL\n");
		return NULL;
	}
  // 特殊情况：1.有头指针但没元素 2.只有一个元素 3.只有两个元素
	if (H-&gt;next == NULL || H-&gt;next-&gt;next == NULL || H-&gt;next-&gt;next-&gt;next == NULL) {
		return H;
	}

	q = H-&gt;next;
	p = H-&gt;next-&gt;next;//p = q-&gt;next;
	r = q;  // r用来存放要返回的指针，即 靠前的那个
	sum = q-&gt;data + p-&gt;data;

	while (p-&gt;next != NULL) {
		p = p-&gt;next;
		q = q-&gt;next;
		if (sum &lt; q-&gt;data + p-&gt;data) {
			sum = q-&gt;data + p-&gt;data;
			r = q;
		}
	}

	*value = sum;

	return r;
}</code></pre> 
<h3>有序链表合并</h3> 
<p><img alt="" height="602" src="https://images2.imgbox.com/dc/1a/a35oIHWz_o.png" width="1200"></p> 
<pre><code class="language-cpp">int list_merge(linklist H1, linklist H2) {
	linklist p, q, r;

	if (H1 == NULL || H2 == NULL) {
		printf("H1 || H2 is NULL\n");
		return -1;
	}

	p = H1-&gt;next; //指向第一个元素
	q = H2-&gt;next;
	r = H1;  // 令r指向头指针，这里是指针之间的赋值，被指对象的改变，会同时影响r和H1
	H1-&gt;next = NULL; // 此时r-&gt;next也被置为了NULL，只有先断开了，才能往后面加节点
	H2-&gt;next = NULL; // 往H1里加节点，H2之后就不用了

	while (p &amp;&amp; q) {
		if (p-&gt;data &lt;= q-&gt;data) {
			r-&gt;next = p;
			p = p-&gt;next; 
			r = r-&gt;next; // r往下一个位置指，即r指向刚插入的节点p，p有两个参数，一个是data，一个是next，data已知，next应为NULL
			r-&gt;next = NULL; // p的next即 r-&gt;next应该设置为NULL
		} else {
			r -&gt;next = q;
			q = q-&gt;next;
			r = r-&gt;next;
			r-&gt;next = NULL;
		}
	}

	if (p == NULL) {
		r-&gt;next = q;
	}else {
		r-&gt;next = p;
	}

	return 0;
}</code></pre> 
<h2></h2> 
<h2> 相关题目</h2> 
<p>1、请简述你的解决方案：设指针变量p指向单链表中节点A，若删除单链表中的节点A，该怎么办？<br> 2、写一个函数，实现删除单链表中的所有节点；</p> 
<p>3.写一个函数，实现链表的排序（使链表中元素的从无序到有序，要求从小到大）；</p> 
<p></p> 
<p>1.方案一：首先要找到节点A的直接前驱节点B，设指针q指向节点B，其次，令q-&gt;next = p-&gt;next，最后释放节点A（freeq(p)）。</p> 
<p>方案二：可以把下一个节点的值复制到当前节点，然后删除下一个节点，这样就不需要遍历整个链表了；</p> 
<p>2.p和H指向同一个节点，通过p释放了，就不要再通过H访问了，H=H-&gt;next要放到free之前。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct node{
	int data;
	struct node* next;
}*linklist,listnode;

linklist list_free(linklist H);

int main(int argc,const char* argv[]){
	return 0;
}

linklist list_free(linklist H) {
	linklist q;
	while (H != NULL) {
		q = H;
		H = H-&gt;next;
		free(q);
		//H = H-&gt;next;
	}
	return NULL;
}</code></pre> 
<p>3.</p> 
<pre><code class="language-cpp">int list_sort(linklist H){
	linklist p;
	linklist q;

	p = H-&gt;next;
	q = H-&gt;next-&gt;next;

	while (p-&gt;next != NULL) {
		while (q != NULL) {
			if (p-&gt;data &gt; q-&gt;data) {
				int temp;
				temp = q-&gt;data;
				q-&gt;data = p-&gt;data;
				p-&gt;data = temp;
				//printf("?");
			}
			q = q-&gt;next;
		}
		p = p-&gt;next;
		q = p-&gt;next;
	}
	
	return 0;
}</code></pre> 
<pre><code class="language-cpp">int list_order(linklist H){ 
    linklist p,q,r; 
    int t; 
    if(H == NULL) { 
        printf("H is NULL"); 
        return -1; 
    } 
    p = H-&gt;next; 
    H-&gt;next = NULL; 
    r = H; 
    while(p != NULL) { 
        q = p; 
        p = p-&gt;next; 
        r = H; 
        while(r-&gt;next &amp;&amp; r-&gt;next-&gt;data &lt; q-&gt;data) 
            r = r-&gt;next; 
            q-&gt;next = r-&gt;next; 
            r-&gt;next = q; 
    } 
    return 0; 
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6617e798298c8fe80f995b2275a2a224/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">wifihal的实现原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71eef146dd3cdb8f35c9c4dc3a04a84a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java Web面试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>