<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>并发编程2：Java 加锁的原理和JVM对锁的优化 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="并发编程2：Java 加锁的原理和JVM对锁的优化" />
<meta property="og:description" content="为什么要加锁 在多进程的环境下，如果一个资源被多个进程共享，那么对资源的使用往往会表现的随机和无序，这显然是不行的。例如多个线程同时对控制台输出，每个线程都输出的是完整的句子但是多个线程同时同时输出，则输出的内容就会被完全打乱，获取不到本来的信息了。对于这种共享资源，需要进行同步管理，资源在被一个线程占用时，其他线程只能阻塞等待。Java 的同步就是使用的对象锁机制来实现的，要使用资源则先获取资源对应的锁后才能操作。
一、 Synchronized 关键字的作用是给对象加锁 java 中的多线程同步机制通过对象锁来实现，Synchronized 关键字则是实现对对象加锁来实现对共享资源的互斥访问。synchronized 关键字实现的是独占锁或者称为排它锁，锁在同一时间只能被一个线程持有。JVM 的同步是基于进入和退出监视器对象(Monitor 也叫管城对象)来实现的，每个对象实例都有一个 Monitor 对象，和 Java 对象一起创建并一起销毁。Java 编译器，在编译到带有synchronizedg 关键字的代码块后，会插入 monitorenter 和 monitorexit 指令到字节码中，monitorenter 也就是加锁的入口了，线程会为锁对象关联一个 ObjectMonitor 对象。
二、对象基于 ObjectMonitor 加锁的原理 2.1 对象在内存中的布局 2.2 ObjectMonitor 监视器 //结构体如下 ObjectMonitor::ObjectMonitor() { _header = NULL; _count = 0; _waiters = 0, _recursions = 0; //线程的重入次数 _object = NULL; _owner = NULL; //标识拥有该monitor的线程 _WaitSet = NULL; //等待线程组成的双向循环链表，_WaitSet是第一个节点 _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; //多线程竞争锁进入时的单向链表 FreeNext = NULL ; _EntryList = NULL ; //_owner从该双向循环链表中唤醒线程结点，_EntryList是第一个节点 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; } ObjectMonitor 是 Java 中的一种同步机制，通常被描述为一个对象，和 Java 对象一起创建一同销毁。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cac31f5f6e926c51b90b4bf55ebc5e03/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-03T23:38:10+08:00" />
<meta property="article:modified_time" content="2023-12-03T23:38:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">并发编程2：Java 加锁的原理和JVM对锁的优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a>为什么要加锁</h2> 
<ul><li>在多进程的环境下，如果一个资源被多个进程共享，那么对资源的使用往往会表现的随机和无序，这显然是不行的。例如多个线程同时对控制台输出，每个线程都输出的是完整的句子但是多个线程同时同时输出，则输出的内容就会被完全打乱，获取不到本来的信息了。</li><li>对于这种共享资源，需要进行同步管理，资源在被一个线程占用时，其他线程只能阻塞等待。</li><li>Java 的同步就是使用的对象锁机制来实现的，要使用资源则先获取资源对应的锁后才能操作。<br> <br><br></li></ul> 
<h2><a id="_Synchronized__7"></a>一、 Synchronized 关键字的作用是给对象加锁</h2> 
<ol><li>java 中的多线程同步机制通过对象锁来实现，Synchronized 关键字则是实现对对象加锁来实现对共享资源的互斥访问。</li><li>synchronized 关键字实现的是独占锁或者称为排它锁，锁在同一时间只能被一个线程持有。</li><li>JVM 的同步是基于进入和退出监视器对象(Monitor 也叫管城对象)来实现的，每个对象实例都有一个 Monitor 对象，和 Java 对象一起创建并一起销毁。</li><li>Java 编译器，在编译到带有synchronizedg 关键字的代码块后，会插入 monitorenter 和 monitorexit 指令到字节码中，monitorenter 也就是加锁的入口了，线程会为锁对象关联一个 ObjectMonitor 对象。<br> <br><br></li></ol> 
<h2><a id="_ObjectMonitor__14"></a>二、对象基于 ObjectMonitor 加锁的原理</h2> 
<br> 
<h3><a id="21__17"></a>2.1 对象在内存中的布局</h3> 
<p><img src="https://images2.imgbox.com/32/6a/xppYcI1K_o.jpg" alt=""></p> 
<br> 
<h3><a id="22_ObjectMonitor__22"></a>2.2 ObjectMonitor 监视器</h3> 
<pre><code class="prism language-cpp"><span class="token comment">//结构体如下</span>
<span class="token class-name">ObjectMonitor</span><span class="token double-colon punctuation">::</span><span class="token function">ObjectMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
    _header       <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  
    _count       <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    _waiters      <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>  
    _recursions   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   	 <span class="token comment">//线程的重入次数</span>
    _object       <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  
    _owner        <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//标识拥有该monitor的线程</span>
    _WaitSet      <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//等待线程组成的双向循环链表，_WaitSet是第一个节点</span>
    _WaitSetLock  <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>  
    _Responsible  <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>  
    _succ         <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>  
    _cxq          <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>    <span class="token comment">//多线程竞争锁进入时的单向链表</span>
    FreeNext      <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>  
    _EntryList    <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>    <span class="token comment">//_owner从该双向循环链表中唤醒线程结点，_EntryList是第一个节点</span>
    _SpinFreq     <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>  
    _SpinClock    <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>  
    OwnerIsThread <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
</code></pre> 
<ol><li> <p>ObjectMonitor 是 Java 中的一种同步机制，通常被描述为一个对象，和 Java 对象一起创建一同销毁。</p> </li><li> <p>每一个 Java 对象就有一把看不见的锁，称为内部锁或者 Monitor 锁。</p> </li><li> <p>ObjectMonitor 象是一个 C++的结构体，用来维护当前持有锁的线程、阻塞等待锁释放的线程链表、调用了 wait 阻塞等待 notify 的线程链表。</p> </li><li> <p>其中有几个关键属性** EntryList、WaitSet、cxq、owner、recursions**</p> </li><li> <p><strong>_cxq 竞争列表</strong>：单项链表结构，竞争锁失败的线程，会通过 CAS 将包装成 ObjectWaiter 写入到链表头部，同时为了避免 插入和取出元素的竞争，Owner 会从列表尾部取出元素。</p> </li><li> <p><strong>EntryList 锁候选者列表</strong>：双向链表结构，如果 EntryList 为空 Cxq 不为空，那么线程释放锁的时候，会将 cxq 中的数据移动到 EntryList 中，并制定 EntryList 列表的头结点线程作为 OnDeck 线程。</p> 
  <ol><li><strong>OnDeck</strong> 是可以进行锁竞争的线程，如果线程是 OnDeck 状态，那么可以进行 tryLock 操作，如果失败则重新回到 EntryList 的头部。</li><li>因为 cxq 中的线程可以自旋，所以 OndeckThread 仍然有可能竞争失败。</li></ol> </li><li><li> <p><strong>WaitSet</strong>：双向链表结构，保存由于不满足执行条件获取锁后主动释放锁 wait 的线程，在被 notify/notifyAll 后会重新参与锁竞争。</p> </li><li> <p>owner：指向持有 ObjectMonitor 对象的线程</p> </li><li> <p>recursions：记录当前锁的重入次数<br> <br></p> </li></ol> 
<h3><a id="23__ObjectMonitor__59"></a>2.3 ObjectMonitor 基本工作机制</h3> 
<p><img src="https://images2.imgbox.com/ab/a0/HPucKAxD_o.png" alt=""></p> 
<ol><li>所有期待获得锁的线程，在锁已经被其它线程拥有的时候，这些期待获得锁的线程就进入了对象锁的entry set区域。</li><li>所有曾经获得过锁，但是由于其它必要条件不满足而需要wait的时候，线程就进入了对象锁的wait set区域 。</li><li>在wait set区域的线程获得Notify/notifyAll通知的时候，随机的一个Thread（Notify）或者是全部的Thread（NotifyALL）从对象锁的wait set区域进入了entry set中。</li><li>在当前拥有锁的线程释放掉锁的时候，处于该对象锁的entryset区域的线程都会抢占该锁，但是只能有任意的一个Thread能取得该锁，而其他线程依然在entry set中等待下次来抢占到锁之后再执行。</li></ol> 
<br> 
<h3><a id="24__69"></a>2.4 执行流程图</h3> 
<p><img src="https://images2.imgbox.com/ad/66/et0ZyHOn_o.jpg" alt=""></p> 
<h3><a id="25_ObjectMonitorenter__71"></a>2.5 ObjectMonitor::enter() 加锁的过程</h3> 
<ol><li>如果当前线程已经是 owner 则加锁直接成功，只是加锁重入次数recursions+1</li><li>如果当前线程没有被加锁 即 owner 为空，则尝试 CAS 竞争加锁</li><li>如果当前线程已经被锁定，则阻塞进入等待队列EntryList 等待释放后再竞争锁，如果 EntryList 超出阈值线程将会阻塞一直到线程数量减少或被其他线程唤醒。</li></ol> 
<h3><a id="26_ObjectMonitor__76"></a>2.6 ObjectMonitor 竞争锁的过程</h3> 
<ol><li>加锁的过程就是多个线程尝试 CAS 操作将 ObjectMonitor 的 owner 设置为自身，并增加重入次数。</li><li>如果当前线程加锁失败，未能获取到锁，则线程会启动自适应自旋，会循环尝试加锁。这是为了避免线程阻塞的开销。</li><li>自旋结束仍未获取到锁，则会被包装成 ObjectWaiter 对象，通过 addwaiter 方法加入到 _cxq 竞争队列的头部</li><li>加入 cxq 队列后，线程仍会再次尝试 CAS 加锁操作，失败后就会被 park 挂起。直到被唤醒重新竞争锁。</li></ol> 
<h3><a id="27_ObjectMonitorwait__83"></a>2.7 ObjectMonitor::wait() 让出锁</h3> 
<ol><li>如果线程执行后判断不满足后续运行条件，会选择调用 wait 进入等待状态</li><li>线程会被封装成 ObjectWaiter 对象，最后会被使用 park 方法挂起。</li><li>调用 wait 第一步会将自身加入到 _waitSet 这个双向链表，后续再调用ObjectMonitor::exit() 来释放锁</li></ol> 
<h3><a id="28_ObjectMonitorexit__88"></a>2.8 ObjectMonitor::exit() 释放锁的过程</h3> 
<ol><li>持有锁的线程执行完 加锁的临界区代码后，会使用ObjectMonitor::exit()来释放锁。</li><li>释放锁会将当前的 _owner 设置为空</li><li>会根据策略，选择将 cxq 队列中的线程移动到 EntryList 队列中唤醒 EntryList 的头部节点 或者直接唤醒 cxq 队列的头部节点让其竞争锁。</li><li>锁被成功释放后，会将栈帧中的 MarkWord 替换回原来的对象头中。</li></ol> 
<h3><a id="29_Objectnotify___94"></a>2.9 Object::notify 方法 执行过程</h3> 
<ol><li>如果 waitSet 为空，则直接结束</li><li>从 waitSet 头部取出线程节点一个 ObjectWaiter 对象，根据策略 QMode 决定，将线程节点放在哪儿可能放在 cxq 队列头部或者 EntryList 的头部或者尾部，或者被直接唤醒开始竞争锁。</li><li>这样下次锁被释放时，它就能重新参与竞争锁了。<br> <br><br></li></ol> 
<h2><a id="_Java__100"></a>三、 Java 对同步机制的优化</h2> 
<p>在 jdk1.6 之前，对于并发控制就只有synchronized 这种办法，如果一个线程已经获得锁，另一个线程就只能阻塞进入等待，后续的线程调度就只能由操作系统来控制了。操作系统对线程的调度，需要频繁的上下文切换，所以效率很低。<br> 来到 jdk1.6 JVM 对加锁进行了一系列的优化</p> 
<h3><a id="31___103"></a>3.1 锁的升级机制</h3> 
<p><img src="https://images2.imgbox.com/30/28/43oN3qHv_o.png" alt=""></p> 
<h3><a id="32_32__JVM__markWord__105"></a>3.2 32 位 JVM 的 markWord 结构</h3> 
<p><img src="https://images2.imgbox.com/6a/1f/CzHFkJjU_o.png" alt="yuque_diagram.png"></p> 
<h3><a id="33__107"></a>3.3 偏向锁机制</h3> 
<ol><li>JDK 1.6 默认开启偏向锁，但是在 JDk15 之后就是默认关闭了，因为偏向锁给 JVM 增加了巨大的复杂性。</li><li>未加锁时，锁标志位是 01 并且 markword 中包含 HashCode 值的位置</li><li>施加偏向锁后，markword 中会保存锁的线程 id、epoh 时间戳等信息，同时偏向锁标识变为 1</li><li>开启偏向锁后，进行加锁会判断偏向锁的线程 id 是否和 markword 线程 id 一致，一致则说明加锁成功可以执行临界区代码；</li><li>如果不一致则检查是否已偏向某个线程，未偏向则使用 CAS 加锁；<strong>未偏向的情况下加锁失败或者存在偏向但不一致，则说明存在竞争。锁会升级成轻量级锁，或者重新偏向。</strong></li><li>偏向锁只有在出现其他线程竞争时，才会释放，线程不会主动释放偏向锁。</li><li>偏向锁在调用 wait 方法时会直接升级成重量级锁，因为 wait 方法是重量级锁独有的。</li><li>hashcode 一般会在第一次调用时填入 markword，如果对象已经计算过 hashcode 那么永远无法进入偏向锁状态。如果已经处于偏向锁状态收到计算 Hashcode 的请求，则会膨胀成为重量级锁，对象头指向重量级锁，重量级锁 ObjectMonitor 类中有字段可以记录未加锁状态的 MarkWord</li></ol> 
<h3><a id="34___117"></a>3.4 轻量级锁</h3> 
<p>如果竞争不激烈，一次获取锁失败就立即进入阻塞状态，那么可能刚进入阻塞状态就立即被唤醒进行加锁。这就会带来上下文的切换，所以轻量级锁获取锁失败时，会进行一定次数或时间的自旋尝试反复获取锁。如果失败则再进入阻塞。</p> 
<ul><li>当发生多个线程竞争时，偏向锁会变为轻量级锁，锁标志位为00</li><li>获得锁的线程会先将偏向锁撤销(在安全点)，并在栈桢中创建锁记录LockRecord，对象的MarkWord被复制到刚创建的LockRecord，然后CAS尝试将记录LockRecord的owner指向锁对象，再将锁对象的MarkWord指向锁，加锁成功</li><li>如果CAS加锁失败，线程会<strong>自旋一定次数加锁</strong>，再失败则升级为重量级锁</li></ul> 
<h3><a id="35_Synchronize__123"></a>3.5 重量级锁(Synchronize 基于监视器实现的锁机制)</h3> 
<ul><li>竞争线程激烈，锁则继续膨胀，变为重量级锁，也是互斥锁，锁标志位为10，MarkWord其余内容被替换为一个指向对象锁Monitor的指针</li></ul> 
<h3><a id="36__126"></a>3.6 锁粗化</h3> 
<p>多次加锁操作在JVM内部也是种消耗，如果多个加锁可以合并为一个锁，就可减少不必要的开销。例如一个方法中将代码分成两个加锁的代码块并且是同一个锁对象，则可以合并为一次加锁过程。</p> 
<h3><a id="37__128"></a>3.7 锁消除</h3> 
<p>如果涉及变量只是一个线程的栈变量，不是共享变量，编译器会尝试消除锁</p> 
<h3><a id="38__130"></a>3.8 分段锁</h3> 
<p>分段锁不是真正的某种锁，而是使用锁的一种方式；主要就是将大对象拆成小对象，对大对象的加锁变成了对小对象的加锁，避免锁住整个对象。CurrentHashMap 就是这种操作</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cc28a85b8b3395297db0ffda6ca20570/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于ZigBee的农业大棚环境监控系统设计与实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dfbcb976f065a719ceb8ed4fa617455f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">van-list的onload事件多次触发的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>