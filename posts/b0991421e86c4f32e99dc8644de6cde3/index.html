<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FML32 API - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FML32 API" />
<meta property="og:description" content="FML32 API 索引：1.概述 2.域表文件 3.域头文件 4.mkfldhdr（32）工具 5.环境变量 6.Falloc（Falloc32） 7.Fsizeof（Fsizeof32） 8.Fneeded（Fneeded32） 9.Finit（Finit32） 10.Fadd（Fadd32） 11.Fchg（Fchg32） 12.Fget（Fget32） 13.Fcpy（Fcpy32） 14.输入/输出函数 15.Fvftos（Fvftos32） 16.Fvstof（Fvstof32） 1.概述基本概念Field Manipulation Language (FML)或(FML32)可以定义多个有名字的域，它是一张属性和值的表。 支持的域数据类型有：short、char、long、float、double、string、carray。
FML（FML32）buffer通过一套API来管理，大约有60多个函数接口。
FML有较强大的功能，使用也很灵活。缺点是接口较复杂，有很多的处理函数，而且使用效率较VIEW等要慢。
FML的基本组成部分FML buffer的域通过域ID（数字）来访问。处理FML buffer至少需要如下四个部分： 域表文件。提供名字-数字映射； 域头文件。提供C程序一些生成的宏而不是数字来访问域； 环境变量FIELDTBLS（32）和FLDTBLDIR（32）定位表文件； C语言接口： 库：libfml.a和libfml32.a； 头文件：fml.h和fml32.h；
处理16位到32位转换代码：fml1632.h。
FML buffer的结构一个域buffer有三部分组成：buffer头部、数据域和索引项。 处理FML的流程定义所有的域名字、对应的数据类型和数字标识。数字标识100以下为系统保留，对16位buffer，数字标识的范围是100-8191，32位buffer是100-33,554,431。 根据这些定义编辑一个域表文件。
使用mkfldhdr（32）生成域头文件。
编译应用程序，使用生成的头文件和fml.h（fml32.h），链接libfml.a（libfml32.a）。
正确设置环境变量FIELDTBLS（32）和FLDTBLDIR（32）。
2.域表文件文件形式如下： *base 100 # name number type flags comments ACCOUNT_ID 10 long - - ACCT_TYPE 11 char - - ADDRESS 09 string - - AMOUNT 16 float - - 文件中以#开头的行被忽略。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b0991421e86c4f32e99dc8644de6cde3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-10-17T16:01:49+08:00" />
<meta property="article:modified_time" content="2012-10-17T16:01:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FML32 API</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 class="title content-title">FML32 API</h3> 
<br> 索引：1.概述 
<br> 2.域表文件 
<br> 3.域头文件 
<br> 4.mkfldhdr（32）工具 
<br> 5.环境变量 
<br> 6.Falloc（Falloc32） 
<br> 7.Fsizeof（Fsizeof32） 
<br> 8.Fneeded（Fneeded32） 
<br> 9.Finit（Finit32） 
<br> 10.Fadd（Fadd32） 
<br> 11.Fchg（Fchg32） 
<br> 12.Fget（Fget32） 
<br> 13.Fcpy（Fcpy32） 
<br> 14.输入/输出函数 
<br> 15.Fvftos（Fvftos32） 
<br> 16.Fvstof（Fvstof32） 
<br> 
<hr> 
<p><a name="item001"></a></p> 1.概述基本概念Field Manipulation Language (FML)或(FML32)可以定义多个有名字的域，它是一张属性和值的表。 
<br> 
<p>支持的域数据类型有：short、char、long、float、double、string、carray。<br> </p> 
<p>FML（FML32）buffer通过一套API来管理，大约有60多个函数接口。<br> </p> 
<p>FML有较强大的功能，使用也很灵活。缺点是接口较复杂，有很多的处理函数，而且使用效率较VIEW等要慢。<br> </p> 
<p></p> 
<p></p> FML的基本组成部分FML buffer的域通过域ID（数字）来访问。处理FML buffer至少需要如下四个部分： 
<br> 
<ul><li>域表文件。提供名字-数字映射； </li><li>域头文件。提供C程序一些生成的宏而不是数字来访问域； </li><li>环境变量FIELDTBLS（32）和FLDTBLDIR（32）定位表文件； </li><li>C语言接口： </li></ul> 库：libfml.a和libfml32.a； 
<br> 
<p>头文件：fml.h和fml32.h；<br> </p> 
<p>处理16位到32位转换代码：fml1632.h。<br> </p> 
<p></p> 
<p></p> FML buffer的结构一个域buffer有三部分组成：buffer头部、数据域和索引项。 
<br> 
<p></p> 
<p></p> 处理FML的流程定义所有的域名字、对应的数据类型和数字标识。数字标识100以下为系统保留，对16位buffer，数字标识的范围是100-8191，32位buffer是100-33,554,431。 
<br> 
<p>根据这些定义编辑一个域表文件。<br> </p> 
<p>使用mkfldhdr（32）生成域头文件。<br> </p> 
<p>编译应用程序，使用生成的头文件和fml.h（fml32.h），链接libfml.a（libfml32.a）。<br> </p> 
<p>正确设置环境变量FIELDTBLS（32）和FLDTBLDIR（32）。<br> </p> 
<hr> 
<a name="item002"></a>2.域表文件文件形式如下： 
<br> *base 100 
<br> # name number type flags comments 
<br> ACCOUNT_ID 10 long - - 
<br> ACCT_TYPE 11 char - - 
<br> ADDRESS 09 string - - 
<br> AMOUNT 16 float - - 
<br> 
<p>文件中以#开头的行被忽略。<br> </p> 
<p>文件中以$开头的行也被忽略，但会被拷贝到后面生成的头文件。<br> </p> 
<p>文件以*base开头的行指出后面的域号的基本偏移。<br> </p> 
<p>每个域有以下部分组成：<br> </p> 
<ul><li>name：域的名字； </li><li>rel-number：域的编号，它是一个相对当前base的数字； </li><li>type：数据类型； </li><li>flag：标志。保留； </li><li>comment：注释。 </li></ul> 该文件用来生成头文件，并在函数调用里使用。 
<br> 
<hr> 
<a name="item003"></a>3.域头文件与域表文件对应的头文件形式如下： 
<br> /* fname fldid */ 
<br> /* ----- ----- */ 
<br> #define ACCOUNT_ID ((FLDID)8302) 
<br> /* number: 110 type: long */ 
<br> #define ACCT_TYPE ((FLDID)16495) 
<br> /* number: 111 type: char */ 
<br> #define ADDRESS ((FLDID)41069) 
<br> /* number: 109 type: string */ 
<br> #define AMOUNT ((FLDID)24692) 
<br> /* number: 116 type: float */ 
<br> 
<hr> 
<a name="item004"></a>4.mkfldhdr（32）工具mkfldhdr（mkfldhdr32）工具将环境变量FIELDTBLS指定的域表文件对应生成一个C头文件，头文件的命名是在域表文件名后加后缀（.h）。缺省目标文件放在当前目录下，可以指定选项-d来指定生成的头文件存放位置。 
<br> 
<p>使用举例：<br> FLDTBLDIR=/project/fldtbls; export FLDTBLDIR<br> FIELDTBLS=maskftbl,DBftbl,miscftbl; export FIELDTBLS<br> mkfldhdr maskftbl<br> mkfldhdr DBftbl<br> mkfldhdr miscftbl<br> </p> 
<hr> 
<a name="item005"></a>5.环境变量FIELDTBLS (FIELDTBLS32)：以逗号分隔每个域表文件； 
<br> FLDTBLDIR (FLDTBLDIR32)：以冒号分隔域表文件存放的路径列表。 
<br> 
<p>注意列表中间不能插入空白字符。<br> </p> 
<hr> 
<a name="item006"></a>6.Falloc（Falloc32）使用malloc动态分配fielded buffer的存储空间并调用Finit进行初始化。 
<br> 
<p>#include &lt;stdio.h&gt;<br> #include &lt;fml.h&gt;<br> FBFR *Falloc (FLDOCC F, FLDLEN V);<br> #include &lt;fml32.h&gt;<br> FBFR32 *Falloc32 (FLDOCC32 F, FLDLEN32 V);<br> </p> 
<p>参数分别是域的个数和空间的字节数。<br> </p> 
<p>失败时返回NULL并设置全局变量Ferror。<br> </p> 
<p>失败原因：<br> </p> 
<ul><li>FMALLOC：malloc失败； </li><li>FEINVAL：参数非法。 </li></ul> 注意：该函数分配的空间只用于内部处理，不能用于tpcall()和tpacall()。 
<br> 
<hr> 
<a name="item007"></a>7.Fsizeof（Fsizeof32）返回给定的FML buffer的大小。 
<br> 
<p>long Fsizeof (FBFR *fbfr);<br> long Fsizeof32 (FBFR32 *fbfr32);<br> </p> 
<p>参数说明：<br> fbfr：buffer指针。<br> </p> 
<hr> 
<a name="item008"></a>8.Fneeded（Fneeded32）计算buffer需要的空间大小。 
<br> 
<p>#include &lt;stdio.h&gt;<br> #include &lt;fml.h&gt;<br> long Fneeded (FLDOCC F, FLDLEN V);<br> #include &lt;fml32.h&gt;<br> long Fneeded32 (FLDOCC32 F, FLDLEN32 V);<br> </p> 
<p>失败返回-1。<br> </p> 
<p>失败原因：<br> FEINVAL：非法参数。<br> </p> 
<hr> 
<a name="item009"></a>9.Finit（Finit32）用于清除一个存在FML buffer的内容以便重新使用它。对于使用Falloc和tpalloc分配的buffer该函数不是必须的。 
<br> 
<p>int Finit(FBFR *fbfr, FLDLEN buflen)；<br> int Finit32(FBFR32 *fbfr, FLDLEN32 buflen)；<br> </p> 
<p>参数说明：<br> bffr：要处理的buffer指针；<br> buflen：清理的空间字节数。<br> </p> 
<p>使用举例：<br> FBFR * fbfr;<br> fbfr = (FBFR *) tpalloc(“FML”,NULL,Fneeded(5,200));<br> ...<br> Finit(fbfr,Fsizeof(fbfr));<br> </p> 
<hr> 
<a name="item010"></a>10.Fadd（Fadd32）往buffer中的某个域填值，同一个域可以填多次，按下标0、1，2…依次存放。 
<br> 
<p>int Fadd(FBFR *fbfr, FLDID fieldid, char *value, FLDLEN len);<br> int Fadd32(FBFR32 *fbfr, FLDID32 fieldid, char *value, FLDLEN32 len);<br> </p> 
<p>参数说明：<br> fbfr：FML buffer指针；<br> fieldid：域ID号；<br> value：值存放的地址（char *类型）。当数据不是string或carray时要强制转化；<br> len：域长度。只对carray类型有效。<br> </p> 
<p>失败返回-1。<br> </p> 
<p>使用举例：<br> long db_id;<br> ...<br> (void)Fadd(reqfb, ACCOUNT_ID, (char *)&amp;db_id, (FLDLEN)0);<br> char *t_amts;<br> ...<br> if (Fadd(reqfb, SAMOUNT, t_amts, (FLDLEN)0) == -1)<br>      (void)printf(“Fadd failed with error: %d\n”, Ferror);<br> char *t_amts;<br> ...<br> if (Fadd32(reqfb, SAMOUNT, t_amts, (FLDLEN32)0) == -1)<br>      (void)printf(“Fadd32 failed with error: %d\n”, Ferror32);<br> </p> 
<hr> 
<a name="item011"></a>11.Fchg（Fchg32）修改域的值。 
<br> 
<p>int Fchg(FBFR *fbfr, FLDID fieldid,int occ, char *value, FLDLEN len);<br> int Fchg32(FBFR32 *fbfr, FLDID32 fieldid,int occ, char *value, FLDLEN32 len);<br> </p> 
<p>参数说明：<br> fbfr：FML buffer指针；<br> fieldid：域ID号；<br> occ：域的下标。从0开始计算，-1表示增加值；<br> value：值的地址（char *）；<br> len：域长度。只对carray类型有效。<br> </p> 
<p>失败返回-1。<br> </p> 
<p>若域指定下标当前没有值，则增加该下标的值。<br> </p> 
<p>使用举例：<br> char *t_amts;<br> ...<br> if (Fchg(reqfb,SAMOUNT, 0, t_amts,(FLDLEN)0) == -1)<br>      (void)printf(“Fchg failed with error: %s”,Fstrerror(Ferror));<br> </p> 
<hr> 
<a name="item012"></a>12.Fget（Fget32）取域的值。 
<br> 
<p>int Fget(FBFR *fbfr, FLDID fieldid,int occ, char *value, FLDLEN *maxlen);<br> int Fget32(FBFR32 *fbfr, FLDID32 fieldid,int occ, char *value, FLDLEN32 *maxlen);<br> </p> 
<p>参数说明：<br> fbfr：FML buffer指针；<br> fieldid：域ID号；<br> occ：域的下标。从0开始计算，-1表示增加值；<br> value：存放地址（char *）；<br> maxlen：最大长度的指针，返回时被置为实际长度。<br> </p> 
<p>失败返回-1。<br> </p> 
<p>若当前空间不足以存放实际的值，函数并不截断数据，而是返回-1。<br> </p> 
<p>使用举例：<br> FLDLEN len2;<br> long amount;<br> . . .<br> len2 = sizeof(amount);<br> (void)Fget(transf, MID_INIT, 3, (char *) &amp;amount, &amp;len2);<br> </p> 
<hr> 
<a name="item013"></a>13.Fcpy（Fcpy32）进行FML buffer的拷贝。 
<br> 
<p>int Fcpy(FBFR *dest, FBFR *src);<br> int Fcpy32(FBFR32 *dest, FBFR32 *src);<br> </p> 
<p>失败返回-1。<br> </p> 
<p>函数认为两者都是FML buffer，当目标buffer足够大时进行复制。<br> </p> 
<hr> 
<a name="item014"></a>14.输入/输出函数int Fprint(FBFR *fbfr); 
<br> int Fprint32(FBFR32 *fbfr); 
<br> 以可读形式打印FML buffer的内容，输出到标准输出。 
<br> 
<p>int Ffprint(FBFR *fbfr, FILE *iop);<br> int Ffprint32(FBFR32 *fbfr, FILE *iop);<br> 同上，但输出到指定的流中。<br> </p> 
<p>int Fextread(FBFR *fbfr, FILE *iop);<br> int Fextread32(FBFR32 *fbfr, FILE *iop);<br> 从流中读取数据到buffer中。<br> </p> 
<p>参数说明：<br> fbfr：buffer指针；<br> iop：输入/输出流。<br> 格式的说明见ud部分的说明。<br> </p> 
<hr> 
<a name="item015"></a>15.Fvftos（Fvftos32）把FML buffer的数据拷贝到VIEW C结构中。 
<br> 
<p>int Fvftos(FBFR *fbfr, char *cstruct, char *view);<br> int Fvftos32 (FBFR32 *fbfr, char *cstruct, char *view);<br> </p> 
<p>参数说明：<br> fbfr：要拷贝的FML buffer指针；<br> cstruct：指向C结构数据的指针；<br> view：VIEW名称。<br> </p> 
<p>若FML中的域在结构中没有对应的项，则忽略。对于多记录的域，相应结构的域要是一个数组，如果buffer中的记录数小于结构中域数组的个数，则结构中多余部分置为null值。如果buffer记录数大于数组个数，则多余的值被忽略。<br> </p> 
<hr> 
<a name="item016"></a>16.Fvstof（Fvstof32）把VIEW结构中的数据拷贝到FML buffer中。 
<br> 
<p>int Fvstof(FBFR *fbfr, char *cstruct, int mode, char *view);<br> int Fvstof32(FBFR32 *fbfr, char *cstruct, int mode, char *view);<br> </p> 
<p>参数说明：<br> fbfr：FML buffer地址；<br> struct：C结构数据地址；<br> mode：拷贝模式。有以下可选值：<br> </p> 
<ul><li>FJOIN：把结构和FML buffer匹配的域中结构的值拷贝到结果buffer中； </li><li>FOJOIN：执行FJOIN功能之外，也把FML buffer中其他内容拷贝到结果buffer 中； </li><li>FUPDATE：执行FJOIN功能之外，也把FML buffer和结构的其他内容拷贝到结果buffer中； </li><li>FCONCAT：把结构和FML buffer的全部内容都拷贝到结果buffer中。 </li></ul> view：VIEW名称。 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d779e7cff8e10e1e3170def3f12ea4a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux后台运行命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8078c98d3455e19400cddbb166b0158e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql 去掉换行符，回车符</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>