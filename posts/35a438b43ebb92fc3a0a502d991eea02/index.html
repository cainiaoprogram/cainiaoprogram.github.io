<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FeignClientSpecification的注入原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FeignClientSpecification的注入原理" />
<meta property="og:description" content="研究FeignClient原理的时候遇到一个问题，就是FeignClientSpecification这个类型的bean是如何被注入到Spring的容器中的，花了很多时间才弄明白。
@Configuration @ConditionalOnClass(Feign.class) @EnableConfigurationProperties({FeignClientProperties.class, FeignHttpClientProperties.class}) public class FeignAutoConfiguration { @Autowired(required = false) private List&lt;FeignClientSpecification&gt; configurations = new ArrayList&lt;&gt;(); ... } class FeignClientSpecification implements NamedContextFactory.Specification { private String name; private Class&lt;?&gt;[] configuration; public FeignClientSpecification() {} public FeignClientSpecification(String name, Class&lt;?&gt;[] configuration) { this.name = name; this.configuration = configuration; } FeignAutoConfiguration 是FeignClient的自动配置类，在这个配置bean中注入了FeignClientSpecification类型的所有bean对象。FeignClientSpecification类没有被Spring的@Component、@Configuration等注解标记，而且它没有任何的子类，那么这个类型的bean是如何被注入到Spring容器呢。我当时主要被这里卡住了，没有认识到其实Spring有很多种注册bean的方法，不仅仅局限于使用注解。
class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware { // patterned after Spring Integration IntegrationComponentScanRegistrar // and RibbonClientsConfigurationRegistgrar private ResourceLoader resourceLoader; private ClassLoader classLoader; private Environment environment; public FeignClientsRegistrar() { } @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { registerDefaultConfiguration(metadata, registry); registerFeignClients(metadata, registry); } public void registerFeignClients(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { ClassPathScanningCandidateComponentProvider scanner = getScanner(); scanner." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/35a438b43ebb92fc3a0a502d991eea02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-08T10:38:42+08:00" />
<meta property="article:modified_time" content="2023-06-08T10:38:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FeignClientSpecification的注入原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>研究FeignClient原理的时候遇到一个问题，就是FeignClientSpecification这个类型的bean是如何被注入到Spring的容器中的，花了很多时间才弄明白。</p> 
<pre><code>@Configuration
@ConditionalOnClass(Feign.class)
@EnableConfigurationProperties({FeignClientProperties.class, FeignHttpClientProperties.class})
public class FeignAutoConfiguration {

	@Autowired(required = false)
	private List&lt;FeignClientSpecification&gt; configurations = new ArrayList&lt;&gt;();
...
}
</code></pre> 
<pre><code>class FeignClientSpecification implements NamedContextFactory.Specification {

	private String name;

	private Class&lt;?&gt;[] configuration;

	public FeignClientSpecification() {}

	public FeignClientSpecification(String name, Class&lt;?&gt;[] configuration) {
		this.name = name;
		this.configuration = configuration;
	}
</code></pre> 
<p>FeignAutoConfiguration 是FeignClient的自动配置类，在这个配置bean中注入了FeignClientSpecification类型的所有bean对象。FeignClientSpecification类没有被Spring的@Component、@Configuration等注解标记，而且它没有任何的子类，那么这个类型的bean是如何被注入到Spring容器呢。我当时主要被这里卡住了，没有认识到其实Spring有很多种注册bean的方法，不仅仅局限于使用注解。</p> 
<pre><code>class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar,
		ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {

	// patterned after Spring Integration IntegrationComponentScanRegistrar
	// and RibbonClientsConfigurationRegistgrar

	private ResourceLoader resourceLoader;

	private ClassLoader classLoader;

	private Environment environment;

	public FeignClientsRegistrar() {
	}


	@Override
	public void registerBeanDefinitions(AnnotationMetadata metadata,
			BeanDefinitionRegistry registry) {
		registerDefaultConfiguration(metadata, registry);
		registerFeignClients(metadata, registry);
	}


	public void registerFeignClients(AnnotationMetadata metadata,
			BeanDefinitionRegistry registry) {
		ClassPathScanningCandidateComponentProvider scanner = getScanner();
		scanner.setResourceLoader(this.resourceLoader);

		Set&lt;String&gt; basePackages;

		Map&lt;String, Object&gt; attrs = metadata
				.getAnnotationAttributes(EnableFeignClients.class.getName());
		AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter(
				FeignClient.class);
		final Class&lt;?&gt;[] clients = attrs == null ? null
				: (Class&lt;?&gt;[]) attrs.get("clients");
		if (clients == null || clients.length == 0) {
			scanner.addIncludeFilter(annotationTypeFilter);
			basePackages = getBasePackages(metadata);
		}
		else {
			final Set&lt;String&gt; clientClasses = new HashSet&lt;&gt;();
			basePackages = new HashSet&lt;&gt;();
			for (Class&lt;?&gt; clazz : clients) {
				basePackages.add(ClassUtils.getPackageName(clazz));
				clientClasses.add(clazz.getCanonicalName());
			}
			AbstractClassTestingTypeFilter filter = new AbstractClassTestingTypeFilter() {
				@Override
				protected boolean match(ClassMetadata metadata) {
					String cleaned = metadata.getClassName().replaceAll("\\$", ".");
					return clientClasses.contains(cleaned);
				}
			};
			scanner.addIncludeFilter(
					new AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));
		}

		for (String basePackage : basePackages) {
			Set&lt;BeanDefinition&gt; candidateComponents = scanner
					.findCandidateComponents(basePackage);
			for (BeanDefinition candidateComponent : candidateComponents) {
				if (candidateComponent instanceof AnnotatedBeanDefinition) {
					// verify annotated class is an interface
					AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;
					AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();
					Assert.isTrue(annotationMetadata.isInterface(),
							"@FeignClient can only be specified on an interface");

					Map&lt;String, Object&gt; attributes = annotationMetadata
							.getAnnotationAttributes(
									FeignClient.class.getCanonicalName());

					String name = getClientName(attributes);
					registerClientConfiguration(registry, name,
							attributes.get("configuration"));

					registerFeignClient(registry, annotationMetadata, attributes);
				}
			}
		}
	}

	private void registerFeignClient(BeanDefinitionRegistry registry,
			AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) {
		String className = annotationMetadata.getClassName();
		BeanDefinitionBuilder definition = BeanDefinitionBuilder
				.genericBeanDefinition(FeignClientFactoryBean.class);
		validate(attributes);
		definition.addPropertyValue("url", getUrl(attributes));
		definition.addPropertyValue("path", getPath(attributes));
		String name = getName(attributes);
		definition.addPropertyValue("name", name);
		definition.addPropertyValue("type", className);
		definition.addPropertyValue("decode404", attributes.get("decode404"));
		definition.addPropertyValue("fallback", attributes.get("fallback"));
		definition.addPropertyValue("fallbackFactory", attributes.get("fallbackFactory"));
		definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);

		String alias = name + "FeignClient";
		AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();

		boolean primary = (Boolean)attributes.get("primary"); // has a default, won't be null

		beanDefinition.setPrimary(primary);

		String qualifier = getQualifier(attributes);
		if (StringUtils.hasText(qualifier)) {
			alias = qualifier;
		}

		BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className,
				new String[] { alias });
		BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);
	}

	private void registerClientConfiguration(BeanDefinitionRegistry registry, Object name,
			Object configuration) {
		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.genericBeanDefinition(FeignClientSpecification.class);
		builder.addConstructorArgValue(name);
		builder.addConstructorArgValue(configuration);
		registry.registerBeanDefinition(
				name + "." + FeignClientSpecification.class.getSimpleName(),
				builder.getBeanDefinition());
	}
</code></pre> 
<p>FeignClientsRegistrar主要用于注册FeignClient及其配置类的bean定义信息。主要看registerClientConfiguration方法，这里就是我们要寻找的注册FeignClientSpecification的bean定义信息的地方。</p> 
<p>可以看到方法中使用了BeanDefinitionBuilder这个builder来构造BeanDefinition对象，另外注意看name和configuration两个入参，就是FeignClientSpecification的构造器的两个入参。当Spring创建FeignClientSpecification的bean对象时，会将FeignClientSpecification的BeanDefinition中封装的name和configuration两个对象作为构造FeignClientSpecification bean对象的参数。</p> 
<p>到此，我们都已经知道FeignClientSpecification类型的Bean是如何注入Spring容器了吧。与使用注解添加Bean不一样，使用BeanDefinitionRegistry 注册相关bean的定义信息比较麻烦，但是也更加灵活。使用注解注入bean本质上只是给类打上bean标识，Spring会扫描所有带标记的类，然后注册到BeanDefinitionRegistry中，当这个bean被注入时，将会根据bean的定义信息创建bean对象。注解是Spring框架的上层封装，可以使框架的使用更加轻松，最后还是得使用类似的方法把bean的定义信息注册到BeanDefinitionRegistry 中。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e51319860d0c211f88ea986951575035/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Druid的数据库连接池技术，两种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/895dbbd231770b175f3913bd81776fc6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows 下挂载使用 CephFS</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>