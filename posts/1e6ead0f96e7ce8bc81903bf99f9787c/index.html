<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>核函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="核函数" />
<meta property="og:description" content="核函数简介
根据模式识别理论，低维空间线性不可分的模式通过非线性映射到高维特征空间则可能实现线性可分，但是如果直接采用这种技术在高维空间进行分类或回归，则存在确定非线性映射函数的形式和参数、特征空间维数等问题，而最大的障碍则是在高维特征空间运算时存在的“维数灾难”，采用核函数技术可以有效地解决这样问题。
1.直接非线性映射
线性回归：
我们称该对象有n个属性(attribute)，可以将该属性直接作为特征(feature)来使用，也可以将该属性做出映射，例如映射为feature：
而之后在每一个需要使用x的地方以来替代。
2.在含有点积的计算过程中使用核函数
例如在svm分类器中,推导出(只举例，不详述推导过程)：
应此分类函数为： 这里的形式的有趣之处在于，对于新点 x的预测，只需要计算它与训练数据点的内积即可，这就是所谓 Supporting Vector ，所有非Supporting Vector 所对应的系数都是等于零的，因此对于新点的内积计算实际上只要针对少量的“支持向量”，非支持向量的训练数据对超平面没有影响。
原始特征内积为：，依据(1)中的映射，得到映射后的特征内积为：
然而这种计算方式是非常低效的。
定义:
但是该核函数只能在选择该映射函数时才能够等价于映射后特征的内积。
由于计算的是内积：
所以向量之间夹角越小，核函数值越大。
在上述的例子中，通过推导出k(x,z)与Φ(x)的关系来证明该核函数是有效的。那么给定任意一个核函数，如何判断它的有效性呢，也就是说，能否找到一个Φ，使得对于所有的x和z，都满足？
3.核函数的有效性判定
必要条件
假设有n个训练样本，每个样本对应的特征向量为：
计算任意两个样本的核函数值为：
这样可以得到一个n*n的核函数矩阵，该核函数矩阵是一个对称矩阵。
假设核函数是有效的，也就是说满足条件：
那么对于任意向量a：
所以核矩阵为半正定矩阵是该核函数有效的必要条件。
充分条件
Mercer定理表明为了证明K是有效的核函数，那么我们不用去寻找Φ，而只需要在训练集上求出各个Kij，然后判断矩阵K是否是半正定（使用左上角主子式大于等于零等方法）即可。
所以核矩阵为半正定矩阵是该核函数有效的充分必要条件。
4.常见核函数
线性核：
多项式核：
径向基核函数：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1e6ead0f96e7ce8bc81903bf99f9787c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-05-15T17:36:24+08:00" />
<meta property="article:modified_time" content="2017-05-15T17:36:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">核函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>核函数简介</strong></p> 
<p>根据模式识别理论，低维空间线性不可分的模式通过非线性映射到高维特征空间则可能实现线性可分，但是如果直接采用这种技术在高维空间进行分类或回归，则存在确定<span style="color:#0000ff;">非线性映射函数的形式和参数、特征空间维数</span>等问题，而最大的障碍则是在高维特征空间运算时存在的“维数灾难”，采用核函数技术可以有效地解决这样问题。</p> 
<p> </p> 
<p>1.<strong>直接非线性映射</strong></p> 
<p>线性回归：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/de/ce/hblV8naa_o.png"></p> 
<p> </p> 
<p>我们称该对象有n个属性(attribute)，可以将该属性直接作为特征(feature)来使用，也可以将该属性做出映射，例如映射为feature：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/d9/80/8XpdYHjw_o.png"></p> 
<p> </p> 
<p>而之后在每一个需要使用x的地方以<img alt="" class="has" src="https://images2.imgbox.com/23/73/x3v38hjd_o.png">来替代。</p> 
<p> </p> 
<p>2.<strong>在含有点积的计算过程中使用核函数</strong></p> 
<p>例如在svm分类器中,推导出(只举例，不详述推导过程)：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/92/77/xrOsTay6_o.png"></p> 
<p> </p> 
<p>应此分类函数为： </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/b2/f7/faD1e44N_o.png"></p> 
<p> </p> 
<p> 这里的形式的有趣之处在于，对于新点 x的预测，只需要计算它与训练数据点的内积即可，这就是所谓 Supporting Vector ，所有非Supporting Vector 所对应的系数都是等于零的，因此对于新点的内积计算实际上只要针对少量的“支持向量”，非支持向量的训练数据对超平面没有影响。</p> 
<p>原始特征内积为：<img alt="" class="has" src="https://images2.imgbox.com/9c/27/JDxNJhVn_o.png">，依据(1)中的映射，得到映射后的特征内积为：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/39/a0/UySGFvc5_o.png"></p> 
<p> </p> 
<p>然而这种计算方式是非常低效的。</p> 
<p>定义:</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/31/77/tLqPNd8G_o.png"></p> 
<p> </p> 
<p>但是该核函数只能在选择该映射函数时才能够等价于映射后特征的内积。</p> 
<p>由于计算的是内积：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/7a/ad/7ml0pBfS_o.png"></p> 
<p> </p> 
<p>所以向量之间夹角越小，核函数值越大。</p> 
<p>    在上述的例子中，通过推导出k(x,z)与Φ(x)的关系来证明该核函数是有效的。那么给定任意一个核函数，如何判断它的有效性呢，也就是说，能否找到一个Φ，使得对于所有的x和z，都满足<img alt="" class="has" src="https://images2.imgbox.com/2a/df/PamEGOnI_o.png">？</p> 
<p>3.<strong>核函数的有效性判定</strong></p> 
<p><strong>必要条件</strong></p> 
<p>假设有n个训练样本，每个样本对应的特征向量为<img alt="" class="has" src="https://images2.imgbox.com/3f/6e/NIQpix9W_o.png">：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/5b/a3/K541EdNP_o.png"></p> 
<p> </p> 
<p>计算任意两个样本的核函数值为：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/91/0a/whcGFCJN_o.png"></p> 
<p> </p> 
<p>这样可以得到一个n*n的核函数矩阵，该核函数矩阵是一个对称矩阵。</p> 
<p>假设核函数是有效的，也就是说满足条件：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/87/bd/izzQjqsJ_o.png"></p> 
<p> </p> 
<p>那么对于任意向量a：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/6d/d0/ZOm1kNA1_o.png"></p> 
<p> </p> 
<p>所以核矩阵为半正定矩阵是该核函数有效的必要条件。</p> 
<p> </p> 
<p><strong>充分条件</strong></p> 
<p><span style="color:#0000ff;">Mercer定理</span>表明为了证明K是有效的核函数，那么我们不用去寻找Φ，而只需要在训练集上求出各个Kij，然后判断矩阵K是否是半正定（使用左上角主子式大于等于零等方法）即可。</p> 
<p>所以核矩阵为半正定矩阵是该核函数有效的充分必要条件。</p> 
<p> </p> 
<p><strong>4.常见核函数</strong></p> 
<p>线性核：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/4b/86/AHv8DRJZ_o.png"></p> 
<p>多项式核：</p> 
<p> </p> 
<p> <img alt="" class="has" src="https://images2.imgbox.com/28/af/RPZSeRMt_o.png"></p> 
<p>径向基核函数：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/96/15/AFE9Zmsa_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/76b03a96c8505460db38baea90adcf67/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Myeclipse10用不了jdk1.8和tomcat8</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2410640c55a79133eba677a004442c9a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pycharm连接Oracle数据库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>