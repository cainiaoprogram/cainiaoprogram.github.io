<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring AOP通知（Advice）详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring AOP通知（Advice）详解" />
<meta property="og:description" content="Spring 的 AOP 功能中一个关键概念是通知（Advice），与切点（Pointcut）表达式相关联在特定节点织入一些逻辑，Spring 提供了五种类型的通知。
理解 AOP 概念参阅：
《Spring的AOP和动态代理》
配置 AOP 参阅：
《Spring基于注解配置AOP》
《Spring基于XML配置AOP》
一、概述 AOP 中的通知是基于连接点（Join point）业务逻辑的一种增强，Spring AOP 提供了下面五种通知类型：
Before advice（前置通知）：连接点前面执行，不能终止后续流程，除非抛异常
After returning advice（后置通知）：连接点正常返回时执行，有异常不执行
Around advice（环绕通知）：围绕连接点前后执行，也能捕获异常处理
After advice（最终通知）：连接点退出时执行，无论是正常退出还是异常退出
After throwing advice（异常通知）：连接点方法抛出异常时执行
AOP 的连接点一般是指目标类的方法，五种通知类型执行的节点如下：
二、通知的定义 Spring AOP 可以基于 XML 方式和基于注解方式定义，只是写法不同，这里只使用注解的方式来讲解通知的详细用法。
1. 前置通知 在 @Aspect 切面类中使用 @Before 注解简单地定义一个前置通知。
@Aspect @Component public class DemoAspect { @Before(&#34;execution(* cn.codeartist.spring.aop.advice.*.*(..))&#34;) public void doBefore() { // 自定义逻辑 } } 2. 后置通知 方法正常返回，会执行后置通知，使用 @AfterReturning 注解定义后置通知。
@AfterReturning(&#34;execution(* cn." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/54d476e8078bd73bac9c06a2a1ded185/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-04T20:41:24+08:00" />
<meta property="article:modified_time" content="2023-06-04T20:41:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring AOP通知（Advice）详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Spring 的 AOP 功能中一个关键概念是通知（Advice），与切点（Pointcut）表达式相关联在特定节点织入一些逻辑，Spring 提供了五种类型的通知。</p> 
<p>理解 AOP 概念参阅：</p> 
<p>《<a href="https://mp.weixin.qq.com/s?__biz=MzU1MzQ0NjU0Ng==&amp;mid=2247485294&amp;idx=1&amp;sn=bf931565df839c98ff12b1bfdd14f89f&amp;scene=21#wechat_redirect" rel="nofollow" title="Spring的AOP和动态代理">Spring的AOP和动态代理</a>》</p> 
<p>配置 AOP 参阅：</p> 
<p>《<a href="https://mp.weixin.qq.com/s?__biz=MzU1MzQ0NjU0Ng==&amp;mid=2247485299&amp;idx=1&amp;sn=59bdee65bb2249fcdcf0df7334a14507&amp;scene=21#wechat_redirect" rel="nofollow" title="Spring基于注解配置AOP">Spring基于注解配置AOP</a>》</p> 
<p>《<a href="https://mp.weixin.qq.com/s?__biz=MzU1MzQ0NjU0Ng==&amp;mid=2247485304&amp;idx=1&amp;sn=251274a9a0ffed57abbd9ae013801057&amp;scene=21#wechat_redirect" rel="nofollow" title="Spring基于XML配置AOP">Spring基于XML配置AOP</a>》</p> 
<h3>一、概述</h3> 
<p>AOP 中的通知是基于连接点（Join point）业务逻辑的一种增强，Spring AOP 提供了下面五种通知类型：</p> 
<ul><li> <p><strong>Before advice（前置通知）</strong>：连接点前面执行，不能终止后续流程，除非抛异常</p> </li><li> <p><strong>After returning advice（后置通知）</strong>：连接点正常返回时执行，有异常不执行</p> </li><li> <p><strong>Around advice（环绕通知）</strong>：围绕连接点前后执行，也能捕获异常处理</p> </li><li> <p><strong>After advice（最终通知）</strong>：连接点退出时执行，无论是正常退出还是异常退出</p> </li><li> <p><strong>After throwing advice（异常通知）</strong>：连接点方法抛出异常时执行</p> </li></ul> 
<p>AOP 的连接点一般是指目标类的方法，五种通知类型执行的节点如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d4/91/q5kcVCRL_o.png"></p> 
<h3>二、通知的定义</h3> 
<p>Spring AOP 可以基于 XML 方式和基于注解方式定义，只是写法不同，这里只使用注解的方式来讲解通知的详细用法。</p> 
<h4>1. 前置通知</h4> 
<p>在 <code>@Aspect</code> 切面类中使用 <code>@Before</code> 注解简单地定义一个前置通知。</p> 
<pre><code class="language-java">@Aspect
@Component
public class DemoAspect {

    @Before("execution(* cn.codeartist.spring.aop.advice.*.*(..))")
    public void doBefore() {
        // 自定义逻辑
    }
}</code></pre> 
<h4>2. 后置通知</h4> 
<p>方法正常返回，会执行后置通知，使用 <code>@AfterReturning</code> 注解定义后置通知。</p> 
<pre><code class="language-java">@AfterReturning("execution(* cn.codeartist.spring.aop.advice.*.*(..))")
public void doAfterReturning() {
    // 自定义逻辑
}</code></pre> 
<p>注解的 <code>returning</code> 属性可以绑定目标方法返回值，用于在通知中获取目标方法执行完成后的返回结果。</p> 
<pre><code class="language-java">@AfterReturning(pointcut = "pointcut()", returning = "retVal")
public void doAfterReturning(Object retVal) {
    // 自定义逻辑（通过参数绑定方法切入点方法的返回值）
}</code></pre> 
<p>当注解使用了 <code>returning</code> 属性时，<strong>切入点会增加返回值类型的限制</strong>，上面使用的 <code>Object</code> 类型可以匹配到所有返回值类型的目标方法。</p> 
<p>例如下面的情况，后置通知的代码不会被执行：</p> 
<pre><code class="language-java">// 目标方法
public String doService() {
    return "码匠公众号";
}

// 后置通知定义
@AfterReturning(pointcut = "pointcut()", returning = "retVal")
public void doAfterReturning(Integer retVal) {
    // 目标方法返回值是String类型，结果参数绑定类型是Integer，该通知不会被执行
}</code></pre> 
<h4>3. 环绕通知</h4> 
<p>环绕通知可以在方法执行的任何节点添加逻辑，它可以实现另外 4 种通知的功能。</p> 
<p>如果需要以线程安全的方式在方法执行前后共享状态，可以使用环绕通知。</p> 
<p>用 <code>@Around</code> 注解来定义环绕通知，需要使用 <code>ProceedingJoinPoint</code> 作为参数，来执行目标方法调用。</p> 
<pre><code class="language-java">@Around("execution(* cn.codeartist.spring.aop.advice.*.*(..))")
public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {
    // 方法执行前逻辑
    Object retVal = joinPoint.proceed();
    // 方法执行后逻辑
    return retVal;
}</code></pre> 
<p><code>joinPoint.proceed()</code> 会调用目标方法，或者是调用另一个切面。</p> 
<blockquote> 
 <p>虽然环绕通知可以实现另外几种通知的功能，但在使用中都能实现功能的情况下，优先使用其他通知方式。</p> 
</blockquote> 
<h4>4. 最终通知</h4> 
<p>最终通知在方法退出的时候执行，使用 <code>@After</code> 注解定义，最终通知在方法正常退出和抛出异常时都会执行，通常用于资源的释放。</p> 
<pre><code class="language-java">@After("execution(* cn.codeartist.spring.aop.advice.*.*(..))")
public void doAfter() {
    // 自定义逻辑
}</code></pre> 
<h4>5. 异常通知</h4> 
<p>方法抛出异常的时候会执行异常通知，使用 <code>@AfterThrowing</code> 定义异常通知。</p> 
<pre><code class="language-java">@AfterThrowing("execution(* cn.codeartist.spring.aop.advice.*.*(..))")
public void doAfterThrowing() {
    // 自定义逻辑
}</code></pre> 
<p>注解的 <code>throwing</code> 属性用来绑定目标方法抛出的异常，用于在通知中获取目标方法抛出的异常实例。</p> 
<pre><code class="language-java">@AfterThrowing(pointcut = "pointcut()", throwing = "ex")
public void doAfterThrowing(Throwable ex) {
    // 自定义逻辑（通过参数绑定方法切入点方法抛出的异常）
}</code></pre> 
<p>当注解使用了 <code>throwing</code> 属性时，<strong>切入点会增加异常类型的限制</strong>，上面使用的 <code>Throwable</code> 类型可以匹配到所有异常类型。</p> 
<p>例如下面的情况，异常通知的代码不会被执行：</p> 
<pre><code class="language-java">// 目标方法
public void doServiceThrow() {
    throw new RuntimeException("Test exception");
}

// 异常通知定义
@AfterThrowing(pointcut = "pointcut()", throwing = "ex")
public void doAfterThrowing(NullPointerException ex) {
    // 目标方法抛出的是RuntimeException，参数绑定类型是NullPointerException，该通知不会被执行
}</code></pre> 
<h3>三、通知的参数</h3> 
<p>在定义通知的方法签名上可以指定参数来绑定目标方法的一些信息（例如前面讲到的后置通知和异常通知）。</p> 
<h4>1. 切入点</h4> 
<p>在定义通知方法的时候，一般可以使用 <code>JoinPoint</code> 作为参数，环绕通知使用 <code>ProceedingJoinPoint</code>。常用接口方法如下：</p> 
<p><strong>JoinPoint</strong></p> 
<pre><code class="language-java">public interface JoinPoint {

  // 获取代理对象
    Object getThis();

    // 获取目标对象
    Object getTarget();

    // 获取连接点方法的参数
    Object[] getArgs();

    // 获取连接点方法的签名
    Signature getSignature();

}</code></pre> 
<p><strong>ProceedingJoinPoint</strong></p> 
<pre><code class="language-java">public interface ProceedingJoinPoint extends JoinPoint {

    // 执行下一个切面的通知或者目标方法
    public Object proceed() throws Throwable;

    // 执行下一个切面的通知或者目标方法（带参数）
    public Object proceed(Object[] args) throws Throwable;

}</code></pre> 
<blockquote> 
 <p>切面的切入点一般为方法，所以 <code>Signature</code> 可以转换为 <code>MethodSignature</code> 使用。</p> 
</blockquote> 
<h4>2. 通知的参数传递</h4> 
<p>通知的参数可以通过切点表达式 <code>args</code> 来指定，具体用法会在后面切点表达式详解中讲到。</p> 
<pre><code class="language-java">@Before("pointcut() &amp;&amp; args(name,..)")
public void doBefore(String name) {
    // 切点表达式增加参数匹配
}</code></pre> 
<p><code>args(name,..)</code> 也会增加切入点的限制，目标方法的参数个数至少为一个，且第一个参数类型为 <code>String</code>。</p> 
<h3>四、通知的顺序</h3> 
<p>Spring AOP 中一个目标类可以被多个切面切入，多个切面也可以切入一个目标类。</p> 
<p>使用 <code>@Order</code> 注解来指定切面的优先级，来控制切面的执行顺序。</p> 
<p>在注册切面 Bean 的时候指定 <code>@Order</code>，如下：</p> 
<pre><code class="language-java">@Order(1)
@Aspect
@Component
public class FirstAspect {

    // ......
}</code></pre> 
<p>优先级高的切面先执行，通知执行的顺序如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/42/fgyRhACY_o.png"></p> 
<p>可以得出：</p> 
<ul><li> <p>优先级高的切面，前置通知先执行</p> </li><li> <p>优先级低的切面，后置通知先执行</p> </li></ul> 
<blockquote> 
 <p><code>Order</code> 值越小，优先级越大。</p> 
</blockquote> 
<p>Spring AOP 是基于动态代理的拦截器模式实现的，切面模型与拦截器模型相似，如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/63/9b/7BWDy0SU_o.png"></p> 
<h3>五、附录</h3> 
<h4>1. 常用注解</h4> 
<table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td><code>@Aspect</code></td><td>定义切面类</td></tr><tr><td><code>@Before</code></td><td>定义前置通知</td></tr><tr><td><code>@AfterReturning</code></td><td>定义后置通知</td></tr><tr><td><code>@Around</code></td><td>定义环绕通知</td></tr><tr><td><code>@After</code></td><td>定义最终通知</td></tr><tr><td><code>@AfterThrowing</code></td><td>定义异常通知</td></tr></tbody></table> 
<p>表格可以左右滑动</p> 
<h4>2. 示例代码</h4> 
<p>Gitee 仓库：</p> 
<p>https://gitee.com/code_artist/spring</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b56b623d76d9d01ddc9f5340fa43db3e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">eNSP基础常用命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e94c79648acc3d98952b27bd347615c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023年最新react面试题 附详细答案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>