<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于Matlab的有限元网格自动生成算法 | Q4、Q8、Abaqus单元网格 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于Matlab的有限元网格自动生成算法 | Q4、Q8、Abaqus单元网格" />
<meta property="og:description" content="今日给大家带来的主要内容是二维问题下四边形单元有限元网格如何自动生成？
单元网格的形成实际上属于有限元计算中的前处理部分，即确定单元节点信息，当模型较为复杂时，用户可在Abaqus、Ansys等大型商业有限元软件中进行建模，导出网格信息。
当模型较为简单时，如二维平面板模型，用户可基于一些较为基础的网格生成算法，在自己的程序中通过控制模型长、宽等信息，即可生成有限元网格。
看似应用有限，但是在一些比较复杂的领域内，往往需要先在简单的模型中得到理论验证，如此以来，有利于自编程代码的完整性，即前处理、内核计算、后处理于一体。
本篇推文，木木就带着大家学习一下Q4、Q8单元网格的自动生成以及Abaqus网格节点顺序解读。
代码获取： 基于Matlab的有限元网格自动生成算法 | Q4、Q8、Abaqus单元网格
Q4单元网格 单元自动网格划分 如下图所示，为4节点四边形单元网格生成示意图，图中NXE和NYE分别是模型横向和纵向单元个数，dhx和dhy分别是单元的横向、纵向长度。
单元自动网格划分
平面板模型被划分为若干个小矩形区域，共有4个节点，分别是 、、、，一个矩形中是1个四边形单元。
该模型总的单元数目和节点数目分别为 ， 。
网格生成算法代码（纵向排序）
global nnd nel nne nodof eldof n global geom connec dee nf Nodal_loads global Length Width NXE NYE X_origin Y_origin dhx dhy % % nnd = 0; k = 0; % 纵向排序 for i = 1:NXE for j=1:NYE k = k &#43; 1; n1 = j &#43; (i-1)*(NYE &#43; 1); geom(n1,:) = [(i-1)*dhx - X_origin (j-1)*dhy - Y_origin ]; n2 = j &#43; i*(NYE&#43;1); geom(n2,:) = [i*dhx - X_origin (j-1)*dhy - Y_origin ]; n3 = n1 &#43; 1; geom(n3,:) = [(i-1)*dhx - X_origin j*dhy - Y_origin ]; n4 = n2 &#43; 1; geom(n4,:) = [i*dhx- X_origin j*dhy - Y_origin ]; nel = k; connec(nel,:) = [n1 n2 n4 n3]; nnd = n4; end end 代码解读" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3e0210768c948bba885ba37672db3c2a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-09T19:09:24+08:00" />
<meta property="article:modified_time" content="2023-02-09T19:09:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于Matlab的有限元网格自动生成算法 | Q4、Q8、Abaqus单元网格</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>今日给大家带来的主要内容是<strong>二维问题下四边形单元有限元网格如何自动生成？</strong></p> 
<p>单元网格的形成实际上属于有限元计算中的前处理部分，即<strong>确定单元节点信息</strong>，当模型较为复杂时，用户可在Abaqus、Ansys等大型商业有限元软件中进行建模，导出网格信息。</p> 
<p>当模型较为简单时，如二维平面板模型，用户可基于一些较为基础的<strong>网格生成算法</strong>，在自己的程序中通过控制模型长、宽等信息，即可生成有限元网格。</p> 
<p>看似应用有限，但是在一些比较复杂的领域内，往往需要先在简单的模型中得到理论验证，如此以来，有利于自编程代码的完整性，即<strong>前处理、内核计算、后处理</strong>于一体。</p> 
<p>本篇推文，木木就带着大家学习一下<strong>Q4、Q8单元网格的自动生成以及Abaqus网格节点顺序解读</strong>。</p> 
<h3><strong>代码获取：</strong></h3> 
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODM0ODc2Mw==&amp;mid=2247488984&amp;idx=1&amp;sn=0de83192e24afb83975ca2cc3ba69f55&amp;chksm=ceacf3ecf9db7afa1c82bf84b93cb5a9177f5e8bff517a85e1022113f6f749423ed018a3508b&amp;token=250269511&amp;lang=zh_CN#rd" rel="nofollow" title="基于Matlab的有限元网格自动生成算法 | Q4、Q8、Abaqus单元网格">基于Matlab的有限元网格自动生成算法 | Q4、Q8、Abaqus单元网格</a></p> 
<hr> 
<h3>Q4单元网格</h3> 
<h4>单元自动网格划分</h4> 
<p>如下图所示，为4节点四边形单元网格生成示意图，图中<code>NXE</code>和<code>NYE</code>分别是模型横向和纵向单元个数，<code>dhx</code>和<code>dhy</code>分别是单元的横向、纵向长度。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a7/9a/nCOA1CB6_o.png"></p> 
<p>单元自动网格划分</p> 
<p>平面板模型被划分为若干个小矩形区域，共有4个节点，分别是 、、、，一个矩形中是1个四边形单元。</p> 
<p>该模型总的单元数目和节点数目分别为 ， 。</p> 
<p>网格生成算法代码（纵向排序）</p> 
<pre><code>global nnd nel nne  nodof eldof  n 
global geom connec dee nf Nodal_loads
global Length Width NXE NYE X_origin Y_origin dhx dhy 
%
%
nnd = 0;
k = 0;
% 纵向排序
for i = 1:NXE
   for j=1:NYE
        k = k + 1;
        n1 = j + (i-1)*(NYE + 1);
        geom(n1,:) = [(i-1)*dhx - X_origin    (j-1)*dhy - Y_origin ];
        n2 = j + i*(NYE+1);
        geom(n2,:) = [i*dhx - X_origin       (j-1)*dhy - Y_origin  ];
        n3 = n1 + 1;
        geom(n3,:) = [(i-1)*dhx - X_origin       j*dhy - Y_origin  ];
        n4 = n2 + 1;
        geom(n4,:) = [i*dhx- X_origin       j*dhy - Y_origin       ];
        nel = k;
        connec(nel,:) = [n1  n2  n4  n3];
        nnd = n4;
        end
end
</code></pre> 
<p><strong>代码解读</strong></p> 
<ol><li> <p>采用全局变量 <code>global</code>的形式，进行变量的传递；</p> </li><li> <p>从两层循环结构上看，最外层是 <code>for i = 1:NXE...end</code>说明网格划分的过程中，x不动，遍历每一个y，节点 <strong>纵向排序</strong>；</p> </li><li> <p>先确定节点号 和 ， <code>n3 = n1 + 1</code>、 <code>n4 = n2 + 1</code>说明 和 在 和 的基础上，编码加1；</p> </li><li> <p><code>n1 = j + (i-1)*(NYE + 1)</code>行不动，每次按照列增加，说明 按照纵向排序；</p> </li><li> <p><code>n2 = j + i*(NYE+1)</code>比 多了一列的节点，说明 与 同行；</p> </li><li> <p>、、、的坐标 <code>geom</code>由 <strong>相对位置-坐标轴原点</strong> <code>(X_origin,Y_origin)</code>，该数值由主程序中给出；</p> </li><li> <p><code>nel = k</code>指的是每次循环中矩形个数，当两层循环结束时， <code>nel</code>指的是全部四边形单元的个数；</p> </li><li> <p><code>connec(nel,:)</code>指的是四边形单元节点编码顺序；</p> </li><li> <p><code>connec(nel,:) = [n1  n2  n4 n3]</code>指的是该单元由 、、、节点组成， <strong>并不是固定的</strong>，按照一定的顺序即可（顺时针或者逆时针）；</p> </li><li> <p><code>nnd = n4</code>当循环结束时， 的数值就是节点的最大值，也就是节点的个数。</p> </li></ol> 
<p><em><strong>网格绘制</strong></em></p> 
<pre><code>figure('Name','Q4单元有限元网格模型');
patch('Faces', connec, 'Vertices', geom,  'Facecolor','none','EdgeColor','b',...   'LineWidth',2,'Marker','pentagram','MarkerSize',8,'MarkerFaceColor','r',...
    'MarkerEdgeColor','r');
axis off
% 节点编号显示
for i=1:nnd
    txt =num2str(i);
    text(geom(i,1)+dhx/10,geom(i,2)+dhy/10,txt);
end
% 单元编号显示(与单元节点编码顺序有关)
for j=1:nel
    txt1 = num2str(j);
    text(geom(connec(j,1),1)+dhx/2,geom(connec(j,1),2)+dhy/2,txt1,'Color','red','FontWeight', 'bold');
end
</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/56/6e/SAKThPVM_o.png"></p> 
<p>Q4单元网格生成（纵向排序）</p> 
<p>网格生成算法代码（横向排序）</p> 
<p>书中所给的代码一律纵向排序，我稍微修改了一下，使得单元按照 方向横向排序，具体如下：</p> 
<pre><code>global nnd nel nne  nodof eldof  n 
global geom connec dee nf Nodal_loads
global Length Width NXE NYE X_origin Y_origin dhx dhy 
%
%
nnd = 0;
k = 0;
% 横向排序
for i = 1:NYE
   for j=1:NXE
        k = k + 1;
        n1 = j + (i-1)*(NXE + 1);
        geom(n1,:) = [(j-1)*dhx - X_origin    (i-1)*dhy - Y_origin ];
        n2 = n1 + 1;
        geom(n2,:) = [j*dhx - X_origin       (i-1)*dhy - Y_origin  ];        
        n3 = j + i*(NXE+1);
        geom(n3,:) = [(j-1)*dhx - X_origin       i*dhy - Y_origin  ];
        n4 = n3 + 1;
        geom(n4,:) = [j*dhx- X_origin       i*dhy - Y_origin       ];
        nel = k;
        connec(nel,:) = [n1  n2  n4  n3];
        nnd = n4;
        end
end
</code></pre> 
<p><strong>代码解读</strong></p> 
<ol><li> <p>从两层循环结构上看，最外层是 <code>for i = 1:NYE...end</code>说明网格划分的过程中，y不动，遍历每一个x，节点 <strong>横向排序</strong>；</p> </li><li> <p>先确定节点号 和 ， <code>n2 = n1 + 1</code>、 <code>n4 = n3 + 1</code>说明 和 在 和 的基础上，编码加1；</p> </li><li> <p><code>n1 = j + (i-1)*(NXE + 1)</code>列不动，每次按照行增加，说明 按照横向排序；</p> </li><li> <p><code>n3 = j + i*(NXE+1)</code>比 多了一行的节点，说明 与 同列；</p> </li><li> <p>、、、的坐标 <code>geom</code>由 <strong>相对位置-坐标轴原点</strong> <code>(X_origin,Y_origin)</code>，该数值由主程序中给出；</p> </li><li> <p><code>nel = k</code>指的是每次循环中矩形个数，当两层循环结束时， <code>nel</code>指的是全部四边形单元的个数；</p> </li><li> <p><code>connec(nel,:)</code>指的是四边形单元节点编码顺序；</p> </li><li> <p><code>connec(nel,:) = [n1  n2  n4 n3]</code>指的是该单元由 、、节点组成， <strong>并不是固定的</strong>，按照一定的顺序即可（顺时针或者逆时针）；</p> </li><li> <p><code>nnd = n4</code>当循环结束时， 的数值就是节点的最大值，也就是节点的个数。</p> </li></ol> 
<p><em><strong>网格绘制</strong></em></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/69/9f/n6dXBqMW_o.png"></p> 
<p>Q4单元网格生成（横向排序）</p> 
<p><em><strong>绘图修饰</strong></em></p> 
<p>众所周知，Matlab的可视化能力强的一批，接下来木木稍微修改一下<code>patch</code>函数里面的参数，即可更改填充面的颜色以及标记的形状：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5d/8f/bJtfdZtq_o.png"></p> 
<p>修改绘图细节</p> 
<h4>Abaqus-Q4单元</h4> 
<p>在这个小节，木木想要依据自己的理解，解释一下:</p> 
<blockquote> 
 <p><strong>Abaqus-Q4单元节点编码顺序为什么是1-2-4-3，而不是按照顺时针或逆时针的顺序编排</strong>。</p> 
</blockquote> 
<p>如下图所示，是在Abaqus中建立一个CPS4(Q4)单元的节点顺序：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9d/89/f5bm87YO_o.png"></p> 
<p>Abaqus-CPS4单元节点顺序</p> 
<p>模型节点读取</p> 
<p>在Abaqus建立平面板模型，划分为 个单元，节点、单元编码如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b8/48/shKOkrdv_o.png"></p> 
<p>Abaqus划分网格的节点单元编码</p> 
<p>由上图可知，Abaqus在进行CPS4单元节点编码时，时一排一排地排序，所以说，在一个单元中节点编码先是同一方向上的1-2，再是第二行的3-4。</p> 
<p>在Matlab中使用<code>Readmesh.m</code>函数，将.inp文件的节点、单元信息导入进Matlab中，命令如下：</p> 
<pre><code>[geom,connec] = Readmesh('Q4_abaqus.inp');
</code></pre> 
<p>网格绘制</p> 
<pre><code>figure('Name','Q4单元有限元网格模型');
patch('Faces', connec, 'Vertices', geom,  'Facecolor','c','Marker','o','MarkerSize',4,'MarkerFaceColor','k');
axis off
% 节点编号显示
[nnd,ntemp] = size(geom);
[nel,netemp] = size(connec);
for i=1:nnd
    txt =num2str(i);
    text(geom(i,1)+0.5,geom(i,2)+0.5,txt);
end
% 单元编号显示(与单元节点编码顺序有关)
for j=1:nel
    txt1 = num2str(j);
    text(geom(connec(j,1),1)-2.5,geom(connec(j,1),2)-2,txt1,'Color','red','FontWeight', 'bold');
end
</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6e/65/5Cy3tDVu_o.png"></p> 
<p>Abaqus网格信息导入进Matlab</p> 
<p>由上图可看到，节点、单元顺序与Abaqus显示一致。</p> 
<h3>Q8单元网格</h3> 
<h4>单元自动网格划分</h4> 
<p>如下图所示，为8节点三角形单元网格生成示意图，图中<code>NXE</code>和<code>NYE</code>分别是模型横向和纵向单元个数，<code>dhx</code>和<code>dhy</code>分别是单元的横向、纵向长度。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/46/da/Wf6L4vTy_o.png"></p> 
<p>单元自动网格划分</p> 
<p>平面板模型被划分为若干个小矩形区域，共有8个节点，分别是 、、、、、、、 ，一个矩形就是一个四边形单元。</p> 
<h4>网格生成算法代码</h4> 
<pre><code>global nnd nel nne  nodof eldof  n 
global geom connec dee nf Nodal_loads
global Length Width NXE NYE X_origin Y_origin dhx dhy 
%
%
nnd = 0;
k = 0;
for i = 1:NXE
   for j=1:NYE
    k = k + 1;
%
     n1 = (i-1)*(3*NYE+2)+2*j - 1;
     n2 = i*(3*NYE+2)+j - NYE - 1;
     n3 = i*(3*NYE+2)+2*j-1; 
     n4 = n3 + 1;
     n5 = n3 + 2;
     n6 = n2 + 1;
     n7 = n1 + 2;
     n8 = n1 + 1;
 %
    geom(n1,:) = [(i-1)*dhx - X_origin    (j-1)*dhy - Y_origin ];
    geom(n3,:) = [i*dhx - X_origin       (j-1)*dhy - Y_origin  ]; 
    geom(n2,:) = [(geom(n1,1)+geom(n3,1))/2  (geom(n1,2)+geom(n3,2))/2];
    geom(n5,:) = [i*dhx- X_origin       j*dhy - Y_origin ]; 
    geom(n4,:) = [(geom(n3,1)+ geom(n5,1))/2  (geom(n3,2)+ geom(n5,2))/2];
    geom(n7,:) = [(i-1)*dhx - X_origin       j*dhy - Y_origin  ];
    geom(n6,:) = [(geom(n5,1)+ geom(n7,1))/2  (geom(n5,2)+ geom(n7,2))/2];    
    geom(n8,:) = [(geom(n1,1)+ geom(n7,1))/2  (geom(n1,2)+ geom(n7,2))/2];  
 %    
    nel = k;       
    nnd = n5;
    connec(k,:) = [n1 n2 n3 n4 n5 n6 n7 n8];
   end
end
</code></pre> 
<p><strong>代码解读</strong></p> 
<ol><li> <p>先确定节点号 、 、  ， <code>n4 = n3 + 1</code>、 <code>n5 = n3 + 2</code>、 <code>n6 = n2 + 1</code>、 <code>n7 = n1 + 2</code>、 <code>n8 = n1 + 1</code>说明 、 、 、 、 在 、 、 的基础上，编码加1、加2；</p> </li><li> <p>注意 <code>n1</code>、 <code>n2</code>、 <code>n3</code>的编码结构，与上面示意图相符；</p> </li><li> <p>的坐标 <code>geom</code>由 <strong>相对位置-坐标轴原点</strong> <code>(X_origin,Y_origin)</code>，该数值由主程序中给出；</p> </li><li> <p><code>nel = k</code>指的是每次循环中单元个数，当两层循环结束时， <code>nel</code>指的是全部四边形单元的个数；</p> </li><li> <p><code>connec(k,:)</code>指的是8节点四边形单元节点编码顺序；</p> </li><li> <p><code>connec(k,:) = [n1 n2 n3 n4 n5 n6 n7 n8]</code>指的是该单元由 、、、、、、、 节点组成， <strong>并不是固定的</strong>，按照一定的顺序即可（顺时针或者逆时针）；</p> </li><li> <p><code>nnd = n5</code>循环结束后，节点总个数等于最后一次循环的 <code>n5</code>编码号。</p> </li></ol> 
<h4>网格绘制</h4> 
<pre><code>figure('Name','Q8单元有限元网格模型');
patch('Faces', connec, 'Vertices', geom,  'Facecolor','c','Marker','o','MarkerSize',4,'MarkerFaceColor','k');
axis off
% 节点编号显示
for i=1:nnd
    txt =num2str(i);
    text(geom(i,1)+dhx/10,geom(i,2)+dhy/10,txt);
end
% 单元编号显示(与单元节点编码顺序有关)
for j=1:nel
    txt1 = num2str(j);
    text(geom(connec(j,1),1)+dhx/2,geom(connec(j,1),2)+dhy/2,txt1,'Color','red','FontWeight', 'bold');
end
</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f6/bb/7i0GFuAq_o.png"></p> 
<p>Q8单元网格自动生成</p> 
<p>本文的主要参考内容及Matlab代码均来自<em><strong>Amar Khennane</strong></em>编写的<em>《Introduction to Finite Element Analysis Using MATLAB and Abaqus》</em>，想要进一步了解有限元编程的小伙伴可以入手，强烈推荐！</p> 
<p>往期推荐</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1b/2b/cWYX2wQ5_o.png"></p> 
<p></p> 
<hr> 
<p>文章来源：技术邻 - 易木木响叮当</p> 
<p>原文链接：<a href="https://www.jishulink.com/post/1896465" rel="nofollow" title="基于Matlab的有限元网格自动生成算法 | Q4、Q8、Abaqus单元网格- 技术邻">基于Matlab的有限元网格自动生成算法 | Q4、Q8、Abaqus单元网格- 技术邻</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72343d6dc373438d8e0ce5042cc9cf7f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Git上传项目到gitee(码云)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4b484a7126f8cb80ba79975a36f272af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一维数组（数组）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>