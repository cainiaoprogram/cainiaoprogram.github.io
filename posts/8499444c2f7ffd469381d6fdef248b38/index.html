<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pytorch 模型训练（以CIFAR10数据集为例） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pytorch 模型训练（以CIFAR10数据集为例）" />
<meta property="og:description" content="在pytorch模型训练时，基本的训练步骤可以大致地归纳为：
准备数据集---&gt;搭建神经网络---&gt;创建网络模型---&gt;创建损失函数---&gt;设置优化器---&gt;训练步骤开始---&gt;测试步骤开始
本文以pytorch官网中torchvision中的CIFAR10数据集为例进行讲解。
需要用到的库为（这里说一个小技巧，比如可以在没有import对应库的情况下先输入&#34;torch&#34;,，之后将光标移到torch处单击，这时左边就会出现一个红色的小灯泡，点开它就可以import对应的库了）：
import torch import torchvision from torch import nn from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter 准备数据集 数据集分为“训练数据集”&#43;“测试数据集”。CIFAR数据集是由50000训练集和10000测试集组成。这里可以调用torchvision.datasets对CIFAR10数据集进行获取：
#训练数据集 train_data=torchvision.datasets.CIFAR10(root=&#39;./dataset&#39;,train=True,transform=torchvision.transforms.ToTensor(),download=True) #测试数据集 test_data=torchvision.datasets.CIFAR10(root=&#39;./dataset&#39;,train=False,transform=torchvision.transforms.ToTensor(),download=True) #利用dataloader来加载数据集 train_data_loader=DataLoader(train_data,batch_size=64) test_data_loader=DataLoader(test_data,batch_size=64) root是数据集保存的路径，这里笔者使用的是相对路径；对于训练集train=True，而测试集train=False；transform是将数据集的类型转换为tensor类型；download一般设置为True。之后利用DataLoader对数据集进行加载即可，其中batch_size表示单次传递给程序用以训练的数据（样本）个数。
（这里可以再获取下测试集数据的长度，这样后面在测试步骤时就可以通过计算得到整体测试集上的准确率）
搭建神经网络 pytorch官网提供了一个神经网络的简单实例：
import torch.nn as nn import torch.nn.functional as F class Model(nn.Module): def __init__(self): super().__init__() self.conv1 = nn.Conv2d(1, 20, 5) self.conv2 = nn.Conv2d(20, 20, 5) def forward(self, x): x = F.relu(self.conv1(x)) return F.relu(self.conv2(x)) 这个实例展示了神经网络的基本架构。
从百度上我们可以搜索到CIFAR10数据集的网络基本架构：
从原理图中可以看到，该网络从输入（inputs）到输出（outputs）先后经过了
卷积(Convolution)---&gt;最大池化(Max-pooling)---&gt;卷积---&gt;最大池化---&gt;卷积---&gt;最大池化---&gt;展平(Flatten)---&gt;2次线性层
由此可以开始搭建神经网络，笔者将网络命名为MXC：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8499444c2f7ffd469381d6fdef248b38/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-20T12:10:18+08:00" />
<meta property="article:modified_time" content="2022-12-20T12:10:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pytorch 模型训练（以CIFAR10数据集为例）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在pytorch模型训练时，基本的训练步骤可以大致地归纳为：</p> 
<p><strong>准备数据集---&gt;搭建神经网络---&gt;创建网络模型---&gt;创建损失函数---&gt;设置优化器---&gt;训练步骤开始---&gt;测试步骤开始</strong></p> 
<p>本文以pytorch官网中torchvision中的<strong>CIFAR10</strong>数据集为例进行讲解。</p> 
<p><img alt="" src="https://images2.imgbox.com/d0/92/TieHs4Vg_o.png"></p> 
<p>需要用到的库为（这里说一个小技巧，比如可以在没有import对应库的情况下先输入"torch",，之后将光标移到torch处单击，这时左边就会出现一个红色的小灯泡，点开它就可以import对应的库了）：</p> 
<pre><code class="language-python">import torch
import torchvision
from torch import nn
from torch.utils.data import DataLoader
from torch.utils.tensorboard import SummaryWriter</code></pre> 
<h4> 准备数据集</h4> 
<p>数据集分为“训练数据集”+“测试数据集”。CIFAR数据集是由50000训练集和10000测试集组成。这里可以调用torchvision.datasets对CIFAR10数据集进行获取：</p> 
<pre><code class="language-python">#训练数据集
train_data=torchvision.datasets.CIFAR10(root='./dataset',train=True,transform=torchvision.transforms.ToTensor(),download=True)
#测试数据集
test_data=torchvision.datasets.CIFAR10(root='./dataset',train=False,transform=torchvision.transforms.ToTensor(),download=True)

#利用dataloader来加载数据集
train_data_loader=DataLoader(train_data,batch_size=64)
test_data_loader=DataLoader(test_data,batch_size=64)</code></pre> 
<p>root是数据集保存的路径，这里笔者使用的是相对路径；对于训练集train=True，而测试集train=False；transform是将数据集的类型转换为tensor类型；download一般设置为True。之后利用DataLoader对数据集进行加载即可，其中<strong>batch_size</strong>表示单次传递给程序用以训练的数据（样本）个数。</p> 
<p>（这里可以再获取下测试集数据的长度，这样后面在测试步骤时就可以通过计算得到<strong>整体测试集上的准确率</strong>）</p> 
<h4>搭建神经网络</h4> 
<p>pytorch官网提供了一个神经网络的简单实例：</p> 
<pre><code class="language-python">import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))</code></pre> 
<p>这个实例展示了神经网络的基本架构。</p> 
<p>从百度上我们可以搜索到CIFAR10数据集的网络基本架构：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/52/c3/7DJvBIfM_o.png"></p> 
<p> 从原理图中可以看到，该网络从输入（inputs）到输出（outputs）先后经过了</p> 
<p><strong>卷积(Convolution)---&gt;最大池化(Max-pooling)---&gt;卷积---&gt;最大池化---&gt;卷积---&gt;最大池化---&gt;展平(Flatten)---&gt;2次线性层</strong></p> 
<p>由此可以开始搭建神经网络，笔者将网络命名为MXC：</p> 
<pre><code class="language-python">class Flatten(nn.Module):
    def forward(self, input):
        return input.view(input.size(0), -1)</code></pre> 
<pre><code class="language-python">#搭建神经网络
class MXC(nn.Module):
    def __init__(self):
        super(MXC, self).__init__()
        self.model=nn.Sequential(
            nn.Conv2d(3,32,5,1,2),
            nn.MaxPool2d(2),
            nn.Conv2d(32,32,5,1,2),
            nn.MaxPool2d(2),
            nn.Conv2d(32,64,5,1,2),
            nn.MaxPool2d(2),
            Flatten(),
            nn.Linear(64*4*4,64),
            nn.Linear(64,10)
        )

    def forward(self,x):
        x=self.model(x)
        return x</code></pre> 
<p>注：这里<strong>Flatten</strong>类自己写的原因是笔者使用的torch版本中没有展平类，因此需要自己构建，可以参考<a href="https://blog.csdn.net/weixin_44589540/article/details/122871715" title="解决 ImportError: cannot import name ‘Flatten‘ from ‘torch.nn‘_全幼儿园最聪明的博客-CSDN博客">解决 ImportError: cannot import name ‘Flatten‘ from ‘torch.nn‘_全幼儿园最聪明的博客-CSDN博客</a></p> 
<h4>创建网络模型</h4> 
<pre><code class="language-python">mxc=MXC()</code></pre> 
<h4>创建损失函数</h4> 
<pre><code class="language-python">loss_fn=nn.CrossEntropyLoss()</code></pre> 
<h4><strong>设置优化器</strong></h4> 
<pre><code class="language-python">learning_rate=1e-2
optimizer=torch.optim.SGD(params=mxc.parameters(),lr=learning_rate)</code></pre> 
<p>这里params是网络模型；lr是学习速率，一般设置小一些（0.01）。</p> 
<h4><strong>训练步骤+测试步骤开始</strong></h4> 
<p>先设置一些参数</p> 
<pre><code class="language-python">#设置训练网络的一些参数
#记录训练的次数
total_train_step=0
#记录测试的次数
total_test_step=0
#记录测试的准确率
total_accuracy=0
#训练的轮数
epoch=10</code></pre> 
<p>将训练步骤和测试步骤放入一个大循环中，进入循环开始训练：</p> 
<pre><code class="language-python">for i in range(epoch):
    print("-----第{}轮训练开始------".format(i+1))

    #训练步骤开始
    for data in train_data_loader:
        imgs,targets=data
        output=mxc(imgs)
        loss=loss_fn(output,targets)

        #优化器优化模型
        optimizer.zero_grad()#梯度清零
        loss.backward()#反向传播
        optimizer.step()#参数优化


        total_train_step=total_train_step+1
        if total_train_step%100==0:
            print("训练次数:{} , Loss:{}".format(total_train_step, loss))  # 更正规的可以写成loss.item()
         

    #测试步骤开始
    total_test_loss=0
    with torch.no_grad():
        for data in test_data_loader:
            imgs,targets=data
            output=mxc(imgs)
            loss=loss_fn(output,targets)
            total_test_loss=total_test_loss+loss
            accuracy=(output.argmax(1)==targets).sum()
            total_accuracy=total_accuracy+accuracy
    print("整体测试集上的Loss:{}".format(total_test_loss))
    print("整体测试集上的准确率:{}".format(total_accuracy/test_data_size))
    total_test_step=total_test_step+1#测试的次数，其实就是第几轮


    #保存模型
    torch.save(mxc,"mxc_cpu{}.pth".format(i+1))#mxc_1是cpu版的
    print("模型已保存")</code></pre> 
<p>这里每一个<strong>data</strong>中包含有<strong>图片+标签，</strong>需要将图片（imgs）放入之前搭建好的神经网络模型<strong>mxc</strong>中去。笔者这里设置的是每训练100次打印1次，训练完一轮后会将模型进行保存，注意文件类型是<strong>pth格式。</strong></p> 
<p>如果想让训练后的结果可视化，有两种方法：</p> 
<p>1.在循环前调用<strong>SummaryWriter</strong>添加tensorboard：</p> 
<pre><code class="language-python">#添加tensorboard
writer=SummaryWriter('./logs_train')</code></pre> 
<p>并在循环的适当位置中插入<strong>writer.add_scalar</strong>：</p> 
<pre><code class="language-python">        if total_train_step%100==0:
            print("训练次数:{} , Loss:{}".format(total_train_step, loss))  # 更正规的可以写成loss.item()
            writer.add_scalar("train_loss",loss.item(),total_train_step)</code></pre> 
<pre><code class="language-python">print("整体测试集上的Loss:{}".format(total_test_loss))
print("整体测试集上的准确率:{}".format(total_accuracy/test_data_size))
total_test_step=total_test_step+1#测试的次数，其实就是第几轮
writer.add_scalar("test_loss",total_test_loss,total_test_step)
writer.add_scalar("test_accuracy",total_accuracy/test_data_size,total_test_step)</code></pre> 
<p>在运行结束后，打开Terminal输入（注意，前面需要显示pytorch，因为只有在pytorch环境下才可以，如果没有显示还要切换到pytorch才行，可以输入<span style="color:#fe2c24;">activate pytorch</span>）：</p> 
<p><span style="color:#fe2c24;">                                                tensorboard --logdir=logs_train --port=6007</span></p> 
<p>这里的“logs_train”是在SummaryWriter中设置的保存路径。运行之后，就可以在tensorboard中查看随着训练次数的增加测试集上的Loss和准确率的趋势图像。</p> 
<p>2.调用matlab库自己进行绘制</p> 
<h4>总结</h4> 
<p>本文简要介绍了pytorch模型训练的一个基本流程，并以CIFAR10数据集进行了演示。但这种方法是在CPU（device=“cpu”）上进行训练的，训练速度比较慢，如果数据集十分庞大不建议使用这种方法，应该在GPU（device=“cuda”）上进行训练。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ae52d74e98b6b7ff5ff0f3a61d5d59a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">新型企业级分布式数据库oceanbase介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/06e381590ac756f1ce2f1804977811d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">读取excel文件read_excel()--Pandas</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>