<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Syslog发送日志&#43;Logstash处理日志 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Syslog发送日志&#43;Logstash处理日志" />
<meta property="og:description" content="Syslog发送日志 Syslog（System Logging Protocol）是一种用于计算机系统日志记录的标准协议。它允许设备（如服务器、路由器、防火墙等）将事件消息发送到指定的日志收集服务器，以便集中管理和分析。通过使用Syslog，您可以跟踪您的网络中的活动并在出现问题时快速识别和解决问题。
要将告警日志发送到某台机器的某个端口，您需要在发送端（产生日志的设备）和接收端（日志收集服务器）上配置Syslog。以下是详细方案：
安装和配置Syslog服务器（接收端）： 这里我们以rsyslog为例，rsyslog是Linux系统上常用的Syslog服务器。如果您使用的是Windows系统，可以考虑使用Kiwi Syslog Server或其他适用于Windows的Syslog服务器。
（1）安装rsyslog：
对于大多数Linux发行版，rsyslog已经是默认安装的。如果没有，可以使用以下命令安装：
对于基于Debian的系统（如Ubuntu）： sudo apt-get update sudo apt-get install rsyslog 对于基于RHEL的系统（如CentOS）： sudo yum install rsyslog （2）配置rsyslog以接收远程日志：
编辑rsyslog配置文件（通常位于/etc/rsyslog.conf）：
sudo nano /etc/rsyslog.conf 取消以下行的注释以启用UDP和/或TCP日志接收：
module(load=&#34;imudp&#34;) input(type=&#34;imudp&#34; port=&#34;514&#34;) module(load=&#34;imtcp&#34;) input(type=&#34;imtcp&#34; port=&#34;514&#34;) 保存并退出。
（3）重启rsyslog服务：
sudo systemctl restart rsyslog 配置发送端设备发送告警日志到Syslog服务器： 这里以Linux系统为例，配置rsyslog将告警日志发送到远程服务器。
（1）编辑rsyslog配置文件：
sudo nano /etc/rsyslog.conf （2）添加以下行以将告警日志发送到远程服务器：
*.alert @remote_server_IP:514 请将remote_server_IP替换为实际的Syslog服务器IP地址。*.alert表示发送所有告警级别的日志。@表示使用UDP协议，如果要使用TCP协议，请使用@@。
（3）重启rsyslog服务：
sudo systemctl restart rsyslog 现在，您的发送端设备将告警日志发送到指定的Syslog服务器和端口。您可以在Syslog服务器上查看和分析这些日志。
如果您的设备不是Linux系统，您需要查找针对该设备的Syslog配置方法。通常，您可以在设备的管理界面或配置文件中找到相应的设置。
在发送端发送指定的日志：
首先，您需要确定要发送的日志文件的路径。例如，假设您要发送的日志文件位于/var/log/myapp.log。
编辑rsyslog配置文件：
sudo nano /etc/rsyslog.conf 在配置文件中添加以下内容，以将指定日志文件发送到远程服务器： $ModLoad imfile $InputFileName /var/log/myapp." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/25774fd683c704954309634bd5b78d1c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T13:06:15+08:00" />
<meta property="article:modified_time" content="2024-01-11T13:06:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Syslog发送日志&#43;Logstash处理日志</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Syslog_0"></a>Syslog发送日志</h2> 
<p>Syslog（System Logging Protocol）是一种用于计算机系统日志记录的标准协议。它允许设备（如服务器、路由器、防火墙等）将事件消息发送到指定的日志收集服务器，以便集中管理和分析。通过使用Syslog，您可以跟踪您的网络中的活动并在出现问题时快速识别和解决问题。</p> 
<p>要将告警日志发送到某台机器的某个端口，您需要在发送端（产生日志的设备）和接收端（日志收集服务器）上配置Syslog。以下是详细方案：</p> 
<ol><li>安装和配置Syslog服务器（接收端）：</li></ol> 
<p>这里我们以rsyslog为例，rsyslog是Linux系统上常用的Syslog服务器。如果您使用的是Windows系统，可以考虑使用Kiwi Syslog Server或其他适用于Windows的Syslog服务器。</p> 
<p>（1）安装rsyslog：</p> 
<p>对于大多数Linux发行版，rsyslog已经是默认安装的。如果没有，可以使用以下命令安装：</p> 
<ul><li>对于基于Debian的系统（如Ubuntu）：</li></ul> 
<pre><code>sudo apt-get update
sudo apt-get install rsyslog
</code></pre> 
<ul><li>对于基于RHEL的系统（如CentOS）：</li></ul> 
<pre><code>sudo yum install rsyslog
</code></pre> 
<p>（2）配置rsyslog以接收远程日志：</p> 
<p>编辑rsyslog配置文件（通常位于<code>/etc/rsyslog.conf</code>）：</p> 
<pre><code>sudo nano /etc/rsyslog.conf
</code></pre> 
<p>取消以下行的注释以启用UDP和/或TCP日志接收：</p> 
<pre><code>module(load="imudp")
input(type="imudp" port="514")

module(load="imtcp")
input(type="imtcp" port="514")
</code></pre> 
<p>保存并退出。</p> 
<p>（3）重启rsyslog服务：</p> 
<pre><code>sudo systemctl restart rsyslog
</code></pre> 
<ol start="2"><li>配置发送端设备发送告警日志到Syslog服务器：</li></ol> 
<p>这里以Linux系统为例，配置rsyslog将告警日志发送到远程服务器。</p> 
<p>（1）编辑rsyslog配置文件：</p> 
<pre><code>sudo nano /etc/rsyslog.conf
</code></pre> 
<p>（2）添加以下行以将告警日志发送到远程服务器：</p> 
<pre><code>*.alert @remote_server_IP:514
</code></pre> 
<p>请将<code>remote_server_IP</code>替换为实际的Syslog服务器IP地址。<code>*.alert</code>表示发送所有告警级别的日志。<code>@</code>表示使用UDP协议，如果要使用TCP协议，请使用<code>@@</code>。</p> 
<p>（3）重启rsyslog服务：</p> 
<pre><code>sudo systemctl restart rsyslog
</code></pre> 
<p>现在，您的发送端设备将告警日志发送到指定的Syslog服务器和端口。您可以在Syslog服务器上查看和分析这些日志。</p> 
<p>如果您的设备不是Linux系统，您需要查找针对该设备的Syslog配置方法。通常，您可以在设备的管理界面或配置文件中找到相应的设置。</p> 
<p>在发送端发送指定的日志：</p> 
<ol><li> <p>首先，您需要确定要发送的日志文件的路径。例如，假设您要发送的日志文件位于<code>/var/log/myapp.log</code>。</p> </li><li> <p>编辑rsyslog配置文件：</p> </li></ol> 
<pre><code>sudo nano /etc/rsyslog.conf
</code></pre> 
<ol start="3"><li>在配置文件中添加以下内容，以将指定日志文件发送到远程服务器：</li></ol> 
<pre><code>$ModLoad imfile
$InputFileName /var/log/myapp.log
$InputFileTag myapp:
$InputFileStateFile myapp_state
$InputFileSeverity info
$InputRunFileMonitor
if $programname == 'myapp' then @remote_server_IP:514
</code></pre> 
<p>请将<code>remote_server_IP</code>替换为实际的Syslog服务器IP地址。<code>@</code>表示使用UDP协议，如果要使用TCP协议，请使用<code>@@</code>。</p> 
<p>这段配置是将发送端的指定日志文件（<code>/var/log/myapp.log</code>）通过rsyslog发送到远程Syslog服务器。下面是每行配置的解释：</p> 
<ul><li><code>$ModLoad imfile</code>：加载<code>imfile</code>模块，该模块用于从文件中读取日志。</li><li><code>$InputFileName /var/log/myapp.log</code>：指定要读取的日志文件路径（<code>/var/log/myapp.log</code>）。</li><li><code>$InputFileTag myapp:</code>：为从该日志文件读取的消息添加一个标签（<code>myapp</code>）。</li><li><code>$InputFileStateFile myapp_state</code>：指定状态文件（<code>myapp_state</code>），用于记录文件读取的位置，以防rsyslog重启时能从上次读取的位置继续读取。</li><li><code>$InputFileSeverity info</code>：指定读取的日志消息的默认严重级别（<code>info</code>）。</li><li><code>$InputRunFileMonitor</code>：启动文件监视器，以便实时读取日志文件的新消息。</li><li><code>if $programname == 'myapp' then @remote_server_IP:514</code>：如果消息的标签（<code>programname</code>）等于<code>myapp</code>，则将消息发送到远程Syslog服务器的指定IP地址和端口。请将<code>remote_server_IP</code>替换为实际的Syslog服务器IP地址。<code>@</code>表示使用UDP协议，如果要使用TCP协议，请使用<code>@@</code>。</li></ul> 
<p>将此配置添加到发送端设备的<code>/etc/rsyslog.conf</code>文件中，然后重启rsyslog服务，即可将指定日志文件发送到远程Syslog服务器。</p> 
<ol start="4"><li>重启rsyslog服务：</li></ol> 
<pre><code>sudo systemctl restart rsyslog
</code></pre> 
<p>现在，发送端将指定的日志文件<code>/var/log/myapp.log</code>发送到远程服务器。</p> 
<p>在接收端查看日志：</p> 
<ol><li>默认情况下，rsyslog会将接收到的日志存储在<code>/var/log</code>目录下。您可以在<code>/etc/rsyslog.conf</code>配置文件中找到具体的日志存储路径。例如，以下配置表示将接收到的日志存储在<code>/var/log/remote</code>目录下：</li></ol> 
<pre><code>$template RemoteLogs,"/var/log/remote/%HOSTNAME%/%PROGRAMNAME%.log"
*.* ?RemoteLogs
</code></pre> 
<ol start="2"><li>您可以使用<code>cat</code>、<code>tail</code>、<code>less</code>等命令查看日志文件。例如，查看名为<code>myapp.log</code>的日志文件：</li></ol> 
<pre><code>cat /var/log/remote/sender_hostname/myapp.log
</code></pre> 
<p>请将<code>sender_hostname</code>替换为发送端设备的主机名。</p> 
<ol start="3"><li>您还可以使用日志分析工具（如Logstash、Graylog等）对接收到的日志进行处理、分析和可视化。这些工具可以帮助您更有效地管理和监控日志。</li></ol> 
<h2><a id="Logstash_142"></a>Logstash处理日志</h2> 
<p>Logstash是一个开源的数据收集、处理和转发工具，它可以轻松地从各种来源接收日志数据，对其进行处理和转换，并将其发送到不同的目标，如Elasticsearch、Kafka等。以下是使用Logstash处理接收到的日志的详细步骤和方法：</p> 
<ol><li>安装Logstash：</li></ol> 
<p>这里以安装在基于Debian的系统（如Ubuntu）为例：</p> 
<p>（1）导入Elasticsearch的GPG密钥：</p> 
<pre><code>wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
</code></pre> 
<p>（2）安装HTTPS传输：</p> 
<pre><code>sudo apt-get install apt-transport-https
</code></pre> 
<p>（3）将Elasticsearch存储库添加到系统：</p> 
<pre><code>echo "deb https://artifacts.elastic.co/packages/7.x/apt stable main" | sudo tee -a /etc/apt/sources.list.d/elastic-7.x.list
</code></pre> 
<p>（4）更新软件包列表并安装Logstash：</p> 
<pre><code>sudo apt-get update
sudo apt-get install logstash
</code></pre> 
<ol start="2"><li>配置Logstash：</li></ol> 
<p>Logstash的配置文件通常位于<code>/etc/logstash/conf.d/</code>目录。我们需要创建一个配置文件，包含三个部分：输入（input）、过滤器（filter）和输出（output）。</p> 
<p>（1）创建配置文件：</p> 
<pre><code>sudo nano /etc/logstash/conf.d/logstash.conf
</code></pre> 
<p>（2）配置输入：</p> 
<p>在配置文件中添加以下内容，以从Syslog服务器接收日志：</p> 
<pre><code>input {
  syslog {
    port =&gt; 5140
    type =&gt; "syslog"
  }
}
</code></pre> 
<p>这里我们使用端口<code>5140</code>作为Logstash的Syslog输入端口。您可以根据需要选择其他端口。</p> 
<p>（3）配置过滤器（可选）：</p> 
<p>过滤器用于对日志进行处理和转换。例如，您可以使用<code>grok</code>过滤器解析日志消息，提取有用的字段：</p> 
<pre><code>filter {
  if [type] == "syslog" {
    grok {
      match =&gt; { "message" =&gt; "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
      add_field =&gt; [ "received_at", "%{@timestamp}" ]
      add_field =&gt; [ "received_from", "%{host}" ]
    }
    date {
      match =&gt; [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
  }
}
</code></pre> 
<p>这个例子中，我们使用<code>grok</code>过滤器解析Syslog消息，并提取诸如时间戳、主机名、程序名等字段。</p> 
<p>（4）配置输出：</p> 
<p>配置输出部分，以将处理后的日志发送到目标。例如，将日志发送到Elasticsearch：</p> 
<pre><code>output {
  elasticsearch {
    hosts =&gt; ["localhost:9200"]
    index =&gt; "logstash-%{+YYYY.MM.dd}"
  }
}
</code></pre> 
<p>这里，我们将日志发送到本地运行的Elasticsearch实例，并使用按日期分割的索引。</p> 
<ol start="3"><li>启动Logstash：</li></ol> 
<p>启动Logstash并将其设置为在系统启动时自动运行：</p> 
<pre><code>sudo systemctl start logstash
sudo systemctl enable logstash
</code></pre> 
<ol start="4"><li>修改Syslog服务器配置：</li></ol> 
<p>为了将日志从Syslog服务器转发到Logstash，您需要修改Syslog服务器的配置。以rsyslog为例：</p> 
<p>编辑rsyslog配置文件：</p> 
<pre><code>sudo nano /etc/rsyslog.conf
</code></pre> 
<p>将以下内容添加到配置文件中，以将日志转发到Logstash：</p> 
<pre><code>*.* @@localhost:5140
</code></pre> 
<p>这里，我们使用<code>@@</code>将日志通过TCP协议发送到本地运行的Logstash实例的端口<code>5140</code>。</p> 
<p>重启rsyslog服务：</p> 
<pre><code>sudo systemctl restart rsyslog
</code></pre> 
<p>现在，Syslog服务器将接收到的日志转发到Logstash进行处理，然后将处理后的日志发送到Elasticsearch。您可以使用Kibana等工具对这些日</p> 
<h2><a id="Logstash_269"></a>Logstash字段说明</h2> 
<p>Logstash支持多种输入、过滤器和输出插件，每个插件都有自己的参数。以下是一些常见插件的参数及其用法示例：</p> 
<ol><li>输入（input）插件：</li></ol> 
<ul><li> <p><code>file</code>：从文件中读取日志。</p> <p>参数：</p> 
  <ul><li><code>path</code>：要读取的文件路径，可以使用通配符。</li><li><code>start_position</code>：从文件的哪个位置开始读取，可以是<code>beginning</code>（从头开始）或<code>end</code>（从末尾开始）。</li></ul> <p>示例：</p> <pre><code>input {
  file {
    path =&gt; "/var/log/*.log"
    start_position =&gt; "beginning"
  }
}
</code></pre> </li><li> <p><code>syslog</code>：从Syslog协议中读取日志。</p> <p>参数：</p> 
  <ul><li><code>port</code>：要监听的端口。</li><li><code>type</code>：为事件分配的类型。</li></ul> <p>示例：</p> <pre><code>input {
  syslog {
    port =&gt; 5140
    type =&gt; "syslog"
  }
}
</code></pre> </li><li> <p><code>beats</code>：从Filebeat或其他Beats中读取日志。</p> <p>参数：</p> 
  <ul><li><code>port</code>：要监听的端口。</li></ul> <p>示例：</p> <pre><code>input {
  beats {
    port =&gt; 5044
  }
}
</code></pre> </li></ul> 
<ol start="2"><li>过滤器（filter）插件：</li></ol> 
<ul><li> <p><code>grok</code>：使用正则表达式解析日志。</p> <p>参数：</p> 
  <ul><li><code>match</code>：一个哈希，包含要匹配的字段和正则表达式模式。</li></ul> <p>示例：</p> <pre><code>filter {
  grok {
    match =&gt; { "message" =&gt; "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
  }
}
</code></pre> </li><li> <p><code>date</code>：解析日期并将其设置为事件的时间戳。</p> <p>参数：</p> 
  <ul><li><code>match</code>：一个数组，包含要解析的字段和日期格式。</li></ul> <p>示例：</p> <pre><code>filter {
  date {
    match =&gt; [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
  }
}
</code></pre> </li><li> <p><code>mutate</code>：对事件执行通用转换。</p> <p>参数：</p> 
  <ul><li><code>add_field</code>：添加新字段。</li><li><code>remove_field</code>：删除字段。</li><li><code>rename</code>：重命名字段。</li></ul> <p>示例：</p> <pre><code>filter {
  mutate {
    add_field =&gt; { "new_field" =&gt; "new_value" }
    remove_field =&gt; [ "old_field" ]
    rename =&gt; { "old_name" =&gt; "new_name" }
  }
}
</code></pre> </li></ul> 
<p>在Logstash的配置文件中，<code>=&gt;</code>是键值对的分隔符，用于指定参数的名称和值。例如，在<code>hosts =&gt; ["localhost:9200"]</code>中，<code>hosts</code>是参数名称，<code>["localhost:9200"]</code>是参数值。</p> 
<p><code>match</code>参数后面的字段是一个哈希，用于指定要匹配的字段和正则表达式模式。哈希中的键是字段名称，值是正则表达式模式。</p> 
<p>例如，在以下配置中：</p> 
<pre><code>grok {
  match =&gt; { "message" =&gt; "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
}
</code></pre> 
<p><code>message</code>是要匹配的字段，<code>"%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}"</code>是正则表达式模式。</p> 
<p>这个正则表达式模式使用了多个<code>grok</code>模式：</p> 
<ul><li><code>%{SYSLOGTIMESTAMP:syslog_timestamp}</code>：匹配Syslog时间戳，并将匹配的值保存到<code>syslog_timestamp</code>字段。</li><li><code>%{SYSLOGHOST:syslog_hostname}</code>：匹配Syslog主机名，并将匹配的值保存到<code>syslog_hostname</code>字段。</li><li><code>%{DATA:syslog_program}</code>：匹配任意非空白字符，并将匹配的值保存到<code>syslog_program</code>字段。</li><li><code>(?:\[%{POSINT:syslog_pid}\])?</code>：匹配可选的进程ID（在方括号中），并将匹配的值保存到<code>syslog_pid</code>字段。</li><li><code>%{GREEDYDATA:syslog_message}</code>：匹配任意字符，并将匹配的值保存到<code>syslog_message</code>字段。</li></ul> 
<p>这个正则表达式模式会对<code>message</code>字段的值进行解析，并提取出各个部分的值保存到新的字段中。例如，对于以下的Syslog消息：</p> 
<pre><code>Oct 11 22:14:15 myhost myprogram[123]: This is a message
</code></pre> 
<p>解析后的结果将是：</p> 
<ul><li><code>syslog_timestamp</code>：<code>Oct 11 22:14:15</code></li><li><code>syslog_hostname</code>：<code>myhost</code></li><li><code>syslog_program</code>：<code>myprogram</code></li><li><code>syslog_pid</code>：<code>123</code></li><li><code>syslog_message</code>：<code>This is a message</code></li></ul> 
<ol start="3"><li>输出（output）插件：</li></ol> 
<ul><li> <p><code>elasticsearch</code>：将事件发送到Elasticsearch。</p> <p>参数：</p> 
  <ul><li><code>hosts</code>：一个数组，包含Elasticsearch实例的地址和端口。</li><li><code>index</code>：要写入的索引名称。</li></ul> <p>示例：</p> <pre><code>output {
  elasticsearch {
    hosts =&gt; ["localhost:9200"]
    index =&gt; "logstash-%{+YYYY.MM.dd}"
  }
}
</code></pre> </li><li> <p><code>file</code>：将事件写入文件。</p> <p>参数：</p> 
  <ul><li><code>path</code>：要写入的文件路径。</li></ul> <p>示例：</p> <pre><code>output {
  file {
    path =&gt; "/var/log/output.log"
  }
}
</code></pre> </li><li> <p><code>stdout</code>：将事件输出到标准输出。</p> <p>参数：</p> 
  <ul><li><code>codec</code>：输出格式，例如<code>rubydebug</code>（易于阅读的文本格式）。</li></ul> <p>示例：</p> <pre><code>output {
  stdout {
    codec =&gt; rubydebug
  }
}
</code></pre> </li></ul> 
<p>这些示例仅涵盖了部分插件和参数。Logstash支持许多其他插件和选项，您可以根据需要进行组合和配置。请参阅<a href="https://www.elastic.co/guide/en/logstash/current/index.html" rel="nofollow">官方文档</a>以获取更多信息和示例。</p> 
<h2><a id="Syslog_455"></a>Syslog日志格式说明</h2> 
<p>Syslog是一种标准的日志传输协议，它定义了日志消息的格式和传输方式。Syslog可以使用UDP（用户数据报协议）或TCP（传输控制协议）作为其下层的传输协议。</p> 
<p>Syslog over UDP和Syslog over TCP的主要区别在于它们的传输可靠性和资源消耗：</p> 
<ul><li> <p>Syslog over UDP：UDP是一种无连接的协议，它不保证消息的到达和顺序。因此，如果网络状况不佳，Syslog消息可能会丢失或到达的顺序可能会打乱。然而，UDP的优点是它的开销较小，对于大量的日志消息，使用UDP可能会更有效率。</p> </li><li> <p>Syslog over TCP：TCP是一种可靠的连接协议，它保证了消息的到达和顺序。如果网络状况允许，使用TCP可以确保所有的Syslog消息都能正确地到达接收端。然而，TCP的缺点是它的开销较大，对于大量的日志消息，使用TCP可能会消耗更多的网络资源和处理器时间。</p> </li></ul> 
<p>Syslog消息的格式由RFC 5424定义，主要包含以下字段：</p> 
<ul><li> <p>PRI（Priority）：一个数字，表示消息的优先级。它是由设施代码（Facility Code）和严重性级别（Severity Level）组合而成的。</p> </li><li> <p>HEADER：包含两个字段，TIMESTAMP（时间戳）和 HOSTNAME（主机名）。</p> </li><li> <p>MSG：消息部分，包含TAG（标签）和 CONTENT（内容）。</p> </li></ul> 
<p>Syslog over UDP和Syslog over TCP的消息格式是相同的，它们都遵循RFC 5424的规定。然而，由于TCP是一种流协议，所以Syslog over TCP还需要一种方法来确定消息的边界。这通常通过在每个消息后面添加一个特殊的分隔符（如换行符）来实现。</p> 
<p>Syslog消息主要包含以下几部分：</p> 
<ol><li> <p>PRI（Priority）：一个由设施代码（Facility Code）和严重性级别（Severity Level）组合而成的数字，表示消息的优先级。</p> </li><li> <p>VERSION：Syslog协议的版本号。</p> </li><li> <p>TIMESTAMP：消息的时间戳。</p> </li><li> <p>HOSTNAME：发送消息的设备的主机名。</p> </li><li> <p>APP-NAME：生成消息的应用程序的名称。</p> </li><li> <p>PROCID：生成消息的进程的ID。</p> </li><li> <p>MSGID：消息的ID。</p> </li><li> <p>STRUCTURED-DATA：结构化的数据，可选。</p> </li><li> <p>MSG：消息的内容。</p> </li></ol> 
<p>以下是一个Syslog消息的例子：</p> 
<pre><code>&lt;34&gt;1 2003-10-11T22:14:15.003Z mymachine.example.com su - ID47 - 'su root' failed for lonvick on /dev/pts/8
</code></pre> 
<ul><li> <p><code>&lt;34&gt;</code>是PRI，表示优先级。这个数字是由设施代码和严重性级别计算得出的。例如，设施代码为4（auth）和严重性级别为2（critical）计算得出的优先级为34。</p> </li><li> <p><code>1</code>是VERSION，表示Syslog协议的版本。</p> </li><li> <p><code>2003-10-11T22:14:15.003Z</code>是TIMESTAMP，表示消息的时间戳。</p> </li><li> <p><code>mymachine.example.com</code>是HOSTNAME，表示发送消息的设备的主机名。</p> </li><li> <p><code>su</code>是APP-NAME，表示生成消息的应用程序的名称。</p> </li><li> <p><code>-</code>是PROCID，表示生成消息的进程的ID。在这个例子中，进程ID未知，所以用<code>-</code>表示。</p> </li><li> <p><code>ID47</code>是MSGID，表示消息的ID。</p> </li><li> <p><code>-</code>是STRUCTURED-DATA，表示结构化的数据。在这个例子中，没有结构化的数据，所以用<code>-</code>表示。</p> </li><li> <p><code>'su root' failed for lonvick on /dev/pts/8</code>是MSG，表示消息的内容。</p> </li></ul> 
<p>这个消息的含义是，在<code>mymachine.example.com</code>上，用户<code>lonvick</code>尝试使用<code>su</code>命令切换到<code>root</code>用户，但是失败了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ecfd6cd925361f0409a976baf112432/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大话 JavaScript（Speaking JavaScript）：第二十六章到第三十章</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5102d14ec41c6c8d294d0cfcdc8b13aa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">副作用操作是什么</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>