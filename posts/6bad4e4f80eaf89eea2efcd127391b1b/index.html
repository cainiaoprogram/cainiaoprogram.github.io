<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux内核SPI子系统驱动框架详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux内核SPI子系统驱动框架详解" />
<meta property="og:description" content="目录
1 spi子系统整体架构图
2 SPI控制器驱动和SPI设备驱动软件架构
3 SPI控制器驱动的整理流程
4 SPI发送数据过程
5 SPI设备驱动
6 spidev万能驱动
7 费曼学习法：我录制了一个SPI子系统驱动框架讲解视频
8 OLED驱动程序
8.1写代码
8.1.1 font.h
8.1.2 oled_drv.c
8.1.3 spi_oled.c
8.1.4 spi_oled.h
8.1.5 Makfile
8.1.6 修改设备树文件
8.2 实验
8.2.1 编译设备树
8.2.2 编译驱动程序和测试程序
8.2.3 测试
8.3 报错：insmod: ERROR: could not insert module oled_drv.ko: Invalid parameters
9 使用spidev万能驱动操作OLED
9.1 font.h
9.2 spi_oled.h
9.3 spi_oled.c
10 参考文献：
1 spi子系统整体架构图 如上图所示是我画的一个spi子系统的整体架构图主要分为用户空间，内核空间 和硬件三大部分，
用户空间就是我们的应用程序，内核空间又分为设备驱动层、SPI核心层和SPI控制器驱动层，其中设备驱动层就是具体的SPI设备驱动，这个一般是由普通的驱动工程师负责，然后SPI核心层是内核自带的代码，SPI核心层起到一个承上启下的作用，往下给控制器驱动层提供控制器驱动的注册函数，往上提供标准的SPI收发API以及设备注册函数。然后是SPI控制器驱动层，SPI控制器驱动一般是由芯片原厂编写。硬件空间就是具体的硬件， 当我们在应用程序中调用比如write函数的时候，其实调用的就是spi设备驱动注册进去的file_operations结构体里面的write函数，也就是图中的spidev_write函数，这个spidev_write函数进一步调用的就是spi_write函数，这个spi_write函数就就是在SPI核心层定义的，然后spi_write函数进一步调用的就是SPI控制器驱动程序中的spi_sync函数。
2 SPI控制器驱动和SPI设备驱动软件架构 如上图所示是spi控制器和spi设备的软件架构图，左边是SPI控制器驱动软件结构，右边是SPI设备的软件结构，
SPI控制器驱动，SPI控制器驱动和SPI控制器设备是挂载到platform_bus_type上的，其中SPI控制器是platform_driver驱动，SPI控制器设备是platform_device类型结构体，内核中的of_platform_default_populate(NULL, NULL, parent);函数会解析设备树中的SPI控制器节点，转换成platform_device结构体，然后会将platform_device增加到内核的设备链表中，platform_driver结构体会被注册到内核的驱动链表中，当增加设备或者驱动的时候，会调用platform_bus_type中的match函数，根据compatible属性进行匹配，当匹配成功后，会调用驱动里面的spi_imx_probe函数，在probe函数里面分配一个spi_master结构体，设置spi_master结构体，调用spi_register_master(spi_master_get(master));注册结构体，然后具体在spi_register_master(spi_master_get(master));函数里面首先会用device_add函数将master-&gt;dev注册到内核中，然后还会调用of_register_spi_devices(master);这个函数增加spi_device的，增加spi_device的函数是在register master的时候做的。因为像I2C SPI节点下面的子节点都是由I2C SPI来管理的。然后调用spi_master_initialize_queue(master);，这个函数内部是设置了一些传送函数，后面会重点分析spi_master_initialize_queue(master);。SPI设备驱动，首先of_register_spi_devices(struct spi_master *master)函数会解析设备树中的SPI下面的子节点，将子节点转换为spi_device，然后增加到spi_bus_type，另外spi_driver驱动也会被注册到spi_bus_type中，当增加设备或者驱动时，会调用spi_bus_type中的match函数，根据compatible属性进行匹配，匹配成功后probe函数就会被调用，然后再probe函数里面会分配、设置、注册一个file_operation结构体，在这个结构体中就包含了具体的设备的读写函数。 3 SPI控制器驱动的整理流程 如上图所示是SPI控制器的驱动，当增加设备或者驱动时，会调用platform_bus_type中match函数，然后根据compatible属性进行匹配，匹配成功之后probe函数被调用，然后再probe函数中其实主要就是做了分配、设置、注册一个结构体，具体来看在probe函数中" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6bad4e4f80eaf89eea2efcd127391b1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-02T17:55:34+08:00" />
<meta property="article:modified_time" content="2023-11-02T17:55:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux内核SPI子系统驱动框架详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%20spi%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE-toc" style="margin-left:0px;"><a href="#1%20spi%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE" rel="nofollow">1 spi子系统整体架构图</a></p> 
<p id="2%20SPI%E6%8E%A7%E5%88%B6%E5%99%A8%E9%A9%B1%E5%8A%A8%E5%92%8CSPI%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84-toc" style="margin-left:0px;"><a href="#2%20SPI%E6%8E%A7%E5%88%B6%E5%99%A8%E9%A9%B1%E5%8A%A8%E5%92%8CSPI%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" rel="nofollow">2 SPI控制器驱动和SPI设备驱动软件架构</a></p> 
<p id="3%20SPI%E6%8E%A7%E5%88%B6%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%95%B4%E7%90%86%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px;"><a href="#3%20SPI%E6%8E%A7%E5%88%B6%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%95%B4%E7%90%86%E6%B5%81%E7%A8%8B" rel="nofollow">3 SPI控制器驱动的整理流程</a></p> 
<p id="4%20SPI%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B-toc" style="margin-left:0px;"><a href="#4%20SPI%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B" rel="nofollow">4 SPI发送数据过程</a></p> 
<p id="5%20SPI%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-toc" style="margin-left:0px;"><a href="#5%20SPI%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8" rel="nofollow">5 SPI设备驱动</a></p> 
<p id="6spidev%E4%B8%87%E8%83%BD%E9%A9%B1%E5%8A%A8-toc" style="margin-left:0px;"><a href="#6spidev%E4%B8%87%E8%83%BD%E9%A9%B1%E5%8A%A8" rel="nofollow">6 spidev万能驱动</a></p> 
<p id="7%20%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%9A%E6%88%91%E5%BD%95%E5%88%B6%E4%BA%86%E4%B8%80%E4%B8%AASPI%E5%AD%90%E7%B3%BB%E7%BB%9F%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E8%AE%B2%E8%A7%A3%E8%A7%86%E9%A2%91-toc" style="margin-left:0px;"><a href="#7%20%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%9A%E6%88%91%E5%BD%95%E5%88%B6%E4%BA%86%E4%B8%80%E4%B8%AASPI%E5%AD%90%E7%B3%BB%E7%BB%9F%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E8%AE%B2%E8%A7%A3%E8%A7%86%E9%A2%91" rel="nofollow">7 费曼学习法：我录制了一个SPI子系统驱动框架讲解视频</a></p> 
<p id="8%20OLED%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F-toc" style="margin-left:0px;"><a href="#8%20OLED%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F" rel="nofollow">8 OLED驱动程序</a></p> 
<p id="8.1%E5%86%99%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#8.1%E5%86%99%E4%BB%A3%E7%A0%81" rel="nofollow">8.1写代码</a></p> 
<p id="8.1.1%20font.h-toc" style="margin-left:80px;"><a href="#8.1.1%20font.h" rel="nofollow">8.1.1 font.h</a></p> 
<p id="8.1.2%20oled_drv.c-toc" style="margin-left:80px;"><a href="#8.1.2%20oled_drv.c" rel="nofollow">8.1.2 oled_drv.c</a></p> 
<p id="8.1.3%C2%A0spi_oled.c-toc" style="margin-left:80px;"><a href="#8.1.3%C2%A0spi_oled.c" rel="nofollow">8.1.3 spi_oled.c</a></p> 
<p id="8.1.4%20spi_oled.h-toc" style="margin-left:80px;"><a href="#8.1.4%20spi_oled.h" rel="nofollow">8.1.4 spi_oled.h</a></p> 
<p id="8.1.5%20Makfile-toc" style="margin-left:80px;"><a href="#8.1.5%20Makfile" rel="nofollow">8.1.5 Makfile</a></p> 
<p id="8.1.6%20%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#8.1.6%20%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6" rel="nofollow">8.1.6 修改设备树文件</a></p> 
<p id="8.2%20%E5%AE%9E%E9%AA%8C-toc" style="margin-left:40px;"><a href="#8.2%20%E5%AE%9E%E9%AA%8C" rel="nofollow">8.2 实验</a></p> 
<p id="8.2.1%20%E7%BC%96%E8%AF%91%E8%AE%BE%E5%A4%87%E6%A0%91-toc" style="margin-left:40px;"><a href="#8.2.1%20%E7%BC%96%E8%AF%91%E8%AE%BE%E5%A4%87%E6%A0%91" rel="nofollow">8.2.1 编译设备树</a></p> 
<p id="8.2.2%20%E7%BC%96%E8%AF%91%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F-toc" style="margin-left:80px;"><a href="#8.2.2%20%E7%BC%96%E8%AF%91%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F" rel="nofollow">8.2.2 编译驱动程序和测试程序</a></p> 
<p id="8.2.3%20%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#8.2.3%20%E6%B5%8B%E8%AF%95" rel="nofollow">8.2.3 测试</a></p> 
<p id="8.3%20%E6%8A%A5%E9%94%99%EF%BC%9Ainsmod%3A%20ERROR%3A%20could%20not%20insert%20module%20oled_drv.ko%3A%20Invalid%20parameters-toc" style="margin-left:40px;"><a href="#8.3%20%E6%8A%A5%E9%94%99%EF%BC%9Ainsmod%3A%20ERROR%3A%20could%20not%20insert%20module%20oled_drv.ko%3A%20Invalid%20parameters" rel="nofollow">8.3 报错：insmod: ERROR: could not insert module oled_drv.ko: Invalid parameters</a></p> 
<p id="9%20%E4%BD%BF%E7%94%A8spidev%E4%B8%87%E8%83%BD%E9%A9%B1%E5%8A%A8%E6%93%8D%E4%BD%9COLED-toc" style="margin-left:0px;"><a href="#9%20%E4%BD%BF%E7%94%A8spidev%E4%B8%87%E8%83%BD%E9%A9%B1%E5%8A%A8%E6%93%8D%E4%BD%9COLED" rel="nofollow">9 使用spidev万能驱动操作OLED</a></p> 
<p id="9.1%20font.h-toc" style="margin-left:40px;"><a href="#9.1%20font.h" rel="nofollow">9.1 font.h</a></p> 
<p id="9.2%20spi_oled.h-toc" style="margin-left:40px;"><a href="#9.2%20spi_oled.h" rel="nofollow">9.2 spi_oled.h</a></p> 
<p id="9.3%C2%A0spi_oled.c-toc" style="margin-left:40px;"><a href="#9.3%C2%A0spi_oled.c" rel="nofollow">9.3 spi_oled.c</a></p> 
<p id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%EF%BC%9A" rel="nofollow">10 参考文献：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%20spi%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE">1 spi子系统整体架构图</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/29/67/QllBZakt_o.png" width="1200"></p> 
<p>如上图所示是我画的一个spi子系统的整体架构图主要分为用户空间，内核空间 和硬件三大部分，</p> 
<ul><li>用户空间就是我们的应用程序，</li><li>内核空间又分为设备驱动层、SPI核心层和SPI控制器驱动层，其中设备驱动层就是具体的SPI设备驱动，这个一般是由普通的驱动工程师负责，然后SPI核心层是内核自带的代码，SPI核心层起到一个承上启下的作用，往下给控制器驱动层提供控制器驱动的注册函数，往上提供标准的SPI收发API以及设备注册函数。然后是SPI控制器驱动层，SPI控制器驱动一般是由芯片原厂编写。</li><li>硬件空间就是具体的硬件，</li></ul> 
<p>当我们在应用程序中调用比如write函数的时候，其实调用的就是spi设备驱动注册进去的file_operations结构体里面的write函数，也就是图中的spidev_write函数，这个spidev_write函数进一步调用的就是spi_write函数，这个spi_write函数就就是在SPI核心层定义的，然后spi_write函数进一步调用的就是SPI控制器驱动程序中的spi_sync函数。</p> 
<h2 id="2%20SPI%E6%8E%A7%E5%88%B6%E5%99%A8%E9%A9%B1%E5%8A%A8%E5%92%8CSPI%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">2 SPI控制器驱动和SPI设备驱动软件架构</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/19/b1/NlKwZj5i_o.png" width="1200"></p> 
<p>如上图所示是spi控制器和spi设备的软件架构图，左边是SPI控制器驱动软件结构，右边是SPI设备的软件结构，</p> 
<ul><li>SPI控制器驱动，SPI控制器驱动和SPI控制器设备是挂载到platform_bus_type上的，其中SPI控制器是platform_driver驱动，SPI控制器设备是platform_device类型结构体，内核中的of_platform_default_populate(NULL, NULL, parent);函数会解析设备树中的SPI控制器节点，转换成platform_device结构体，然后会将platform_device增加到内核的设备链表中，platform_driver结构体会被注册到内核的驱动链表中，当增加设备或者驱动的时候，会调用platform_bus_type中的match函数，根据compatible属性进行匹配，当匹配成功后，会调用驱动里面的spi_imx_probe函数，在probe函数里面分配一个spi_master结构体，设置spi_master结构体，调用spi_register_master(spi_master_get(master));注册结构体，然后具体在spi_register_master(spi_master_get(master));函数里面首先会用device_add函数将master-&gt;dev注册到内核中，然后还会调用of_register_spi_devices(master);这个函数增加spi_device的，增加spi_device的函数是在register master的时候做的。因为像I2C SPI节点下面的子节点都是由I2C SPI来管理的。然后调用spi_master_initialize_queue(master);，这个函数内部是设置了一些传送函数，后面会重点分析spi_master_initialize_queue(master);。</li><li>SPI设备驱动，首先of_register_spi_devices(struct spi_master *master)函数会解析设备树中的SPI下面的子节点，将子节点转换为spi_device，然后增加到spi_bus_type，另外spi_driver驱动也会被注册到spi_bus_type中，当增加设备或者驱动时，会调用spi_bus_type中的match函数，根据compatible属性进行匹配，匹配成功后probe函数就会被调用，然后再probe函数里面会分配、设置、注册一个file_operation结构体，在这个结构体中就包含了具体的设备的读写函数。</li></ul> 
<h2 id="3%20SPI%E6%8E%A7%E5%88%B6%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%95%B4%E7%90%86%E6%B5%81%E7%A8%8B">3 SPI控制器驱动的整理流程</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c8/49/Im8Sru5N_o.png" width="1200"></p> 
<p>如上图所示是SPI控制器的驱动，当增加设备或者驱动时，会调用platform_bus_type中match函数，然后根据compatible属性进行匹配，匹配成功之后probe函数被调用，然后再probe函数中其实主要就是做了分配、设置、注册一个结构体，具体来看在probe函数中</p> 
<ul><li>首先master = spi_alloc_master(&amp;pdev-&gt;dev, sizeof(struct spi_imx_data));分配了一个结构体，然后解析设备书中的控制器的相关信息，比如片选，比如寄存器地址，然后把这些东西赋值给master。</li><li>然后设置了很多函数，比如spi_imx_setupxfer;函数，这个函数其实就是设置发送接收函数，从上图可以看到这个函数经过一系列的调用，最终调用writel(val, spi_imx-&gt;base + MXC_CSPITXDATA); 这就是直接写寄存器的函数了。</li><li>还有比如spi_imx_transfer;;函数，这个函数其实最终调用的就是上面spi_imx_setupxfer设置的发送接收函数。</li><li>然后调用rspi_bitbang_start(&amp;spi_imx-&gt;bitbang);在这个函数里面首先也是设置了一些函数，比如spi_bitbang_transfer_one;，其实这个函数最终的调用的就是前面spi_imx_setupxfer设置的函数，然后在rspi_bitbang_start(&amp;spi_imx-&gt;bitbang);函数里面又调用了spi_register_master(spi_master_get(master));函数，在spi_register_master(spi_master_get(master));函数中主要又调用了device_add函数将设备增加到内核中，然后调用了spi_master_initialize_queue(master);接下来专门用一张图重点看一下spi_master_initialize_queue(master);做了什么。</li></ul> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/4f/71/v3YChrwJ_o.png" width="1200"></p> 
<p>spi_register_master(spi_master_get(master));函数中主要调用了device_add函数将设备增加到内核中，然后调用了spi_master_initialize_queue(master);接下来重点看一下spi_master_initialize_queue(master)做了什么。</p> 
<ul><li>在spi_master_initialize_queue(master)里面首先是赋值了master-&gt;transfer = spi_queued_transfer这个函数，spi_queued_transfer里面其实是一个传送函数，里面首先会把消息添加到queue的队列，然后检查是否需要启动消息处理：如果master-&gt;busy为假且need_pump为真，那么使用kthread_queue_work将master-&gt;pump_messages添加到工作队列，以便在稍后的某个时间点处理。</li><li>然后master-&gt;transfer_one_message = spi_transfer_one_message，这里是设置了spi_transfer_one_message函数，这个函数进一步看其实就是master-&gt;transfer_one(master, msg-&gt;spi, xfer);，那也就是上一张图中的master-&gt;transfer_one = spi_bitbang_transfer_one;</li><li>然后spi_init_queue(master);函数，  spi_init_queue函数先初始化kthread_worker，为kthread_worker创建一个内核线程来处理work，随后初始化kthread_work,设置work执行函数，work执行函数为spi_pump_messages。</li><li> <p>然后是spi_start_queue(master)函数，spi_start_queue就相对简单了，只是唤醒该工作线程而已；自此，队列化的相关工作已经完成，系统等待message请求被发起，然后在工作线程中处理message的传送工作。</p> </li></ul> 
<h2 id="4%20SPI%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B">4 SPI发送数据过程</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/eb/73/lHlpOW4v_o.png" width="1200"></p> 
<p>我们发送数据的时候，最小单位是spi_transfer,我们将发送数据buf赋值给spi_transfer，然后spi_transfer又会被放到spi_message里面，然后调用__spi_sync函数进行发送，然后在__spi_sync函数里面，</p> 
<ul><li>设置spi_message完成后回调函数，回调函数中仅仅调用complete函数，唤醒等待唤醒的线程。意思就是，当发送spi_message的工作线程完成发送后，唤醒在等待的spi发送完成的spi_sync函数所在的线程。</li><li>调用__spi_queued_transfer(spi, message, false)函数，这个函数里面就是将数据添加到发送队列中，检查是否需要启动消息处理：如果master-&gt;busy为假且need_pump为真，那么使用kthread_queue_work将master-&gt;pump_messages添加到工作队列，以便在稍后的某个时间点处理。</li><li>__spi_pump_messages(master, false);函数，__spi_pump_messages(master, false)，false意思是标记不在工作线程中执行该函数。调用该函数，把spi_message发出去，该函数中会判断当前状态，如果可以直接发，则直接在当前线程中发送，如果不能直接发，则唤醒工作线程，稍后发送。</li><li>wait_for_completion(&amp;done);,睡眠等待发送完成函数释放的完成信号量，当接收到信号量时，证明发送完成唤醒并结束spi_sync函数。</li></ul> 
<h2 id="5%20SPI%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8">5 SPI设备驱动</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/8c/3e/uqMOD2xW_o.png" width="1200"></p> 
<p>接下来看一下spi设备驱动，首先在前面spi控制器驱动中已经解析了spi子节点的内容转换成了spi_device了，然后我们这里编写spi设备驱动，然后当增加设备或者驱动的时候，会调用spi_bus_type里面的match函数，根据compatible属性进行匹配，匹配成功之后会得调用probe函数，在probe函数里面会注册字符设备，然后字符设备里面就有相应的write函数。</p> 
<h2 id="6spidev%E4%B8%87%E8%83%BD%E9%A9%B1%E5%8A%A8">6 spidev万能驱动</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/26/eb/hiP6MFiX_o.png" width="1200"></p> 
<p>前面的方式，我们如果想操作一个spi外设，那么由驱动开发人员编写一个spi设备驱动，然后应用开发人员直接使用open/read/write就可以操作相应的spi设备，应用开发人员不需要知道spi设备的具体配置，就把spi设备当成一个文件进行处理。</p> 
<p>但是在spidev.c里面的万能驱动采用的是另一种方式，所谓万能驱动，就是我们不需要编写spi_driver，而是在应用程序里面直接操作硬件，这种情况下要求应用编写人员需要去阅读芯片手册，需要知道怎么操作具体的spi外设。</p> 
<h2 id="7%20%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%9A%E6%88%91%E5%BD%95%E5%88%B6%E4%BA%86%E4%B8%80%E4%B8%AASPI%E5%AD%90%E7%B3%BB%E7%BB%9F%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E8%AE%B2%E8%A7%A3%E8%A7%86%E9%A2%91">7 费曼学习法：我录制了一个SPI子系统驱动框架讲解视频</h2> 
<p> 根据费曼学习法，把知识点讲出来能够加深对知识点的理解，于是我录制了一个spi子系统驱动框架的讲解视频。</p> 
<p><a href="https://www.bilibili.com/video/BV1wh4y1Y7NW/?spm_id_from=333.999.0.0&amp;vd_source=ad92041b1b4452eed564be6b47d7237d" title="22分钟彻底讲解Linux内核SPI子系统驱动_哔哩哔哩_bilibili">22分钟彻底讲解Linux内核SPI子系统驱动_哔哩哔哩_bilibili</a></p> 
<h2 id="8%20OLED%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">8 OLED驱动程序</h2> 
<h3 id="8.1%E5%86%99%E4%BB%A3%E7%A0%81">8.1写代码</h3> 
<h4 id="8.1.1%20font.h">8.1.1 font.h</h4> 
<pre><code class="language-cpp">#ifndef  _FONT_H_
#define _FONT_H_
const unsigned char oled_asc2_8x16[95][16]=
{
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// 0
    {0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00},//!1
    {0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"2
    {0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00},//#3
    {0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00},//$4
    {0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00},//%5
    {0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10},//&amp;6
    {0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//'7
    {0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},//(8
    {0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},//)9
    {0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},//*10
    {0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00},//+11
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00},//,12
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01},//-13
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},//.14
    {0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00},///15
    {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},//016
    {0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//117
    {0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},//218
    {0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00},//319
    {0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00},//420
    {0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00},//521
    {0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00},//622
    {0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00},//723
    {0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},//824
    {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00},//925
    {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},//:26
    {0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00},//;27
    {0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},//&lt;28
    {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00},//=29
    {0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},//&gt;30
    {0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00},//?31
    {0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00},//@32
    {0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},//A33
    {0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},//B34
    {0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},//C35
    {0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},//D36
    {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},//E37
    {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},//F38
    {0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},//G39
    {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},//H40
    {0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//I41
    {0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},//J42
    {0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},//K43
    {0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},//L44
    {0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00},//M45
    {0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},//N46
    {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},//O47
    {0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},//P48
    {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00},//Q49
    {0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},//R50
    {0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},//S51
    {0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},//T52
    {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},//U53
    {0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},//V54
    {0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00},//W55
    {0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},//X56
    {0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},//Y57
    {0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},//Z58
    {0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},//[59
    {0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},//\60
    {0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},//]61
    {0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//^62
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},//_63
    {0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//`64
    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20},//a65
    {0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},//b66
    {0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},//c67
    {0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20},//d68
    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00},//e69
    {0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//f70
    {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},//g71
    {0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},//h72
    {0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//i73
    {0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},//j74
    {0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00},//k75
    {0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//l76
    {0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},//m77
    {0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},//n78
    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},//o79
    {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00},//p80
    {0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80},//q81
    {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},//r82
    {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},//s83
    {0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00},//t84
    {0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},//u85
    {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00},//v86
    {0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00},//w87
    {0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00},//x88
    {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00},//y89
    {0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},//z90
    {0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40},//{91
    {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},//|92
    {0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00},//}93
    {0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//~94
};      
const unsigned char hz_1616[][32]={
{0x02,0x00,0x02,0x00,0xE2,0xFF,0x22,0x42,0x22,0x42,0x32,0x42,0x2A,0x42,0x26,0x42,0x22,0x42,0x22,0x42,0x22,0x42,0x22,0x42,0xE2,0xFF,0x02,0x00,0x02,0x00,0x00,0x00},/*"百",0*/
{0x00,0x00,0xF8,0xFF,0x01,0x00,0x02,0x00,0x00,0x00,0xE2,0x1F,0x22,0x08,0x22,0x08,0x22,0x08,0xE2,0x1F,0x02,0x00,0x02,0x40,0x02,0x80,0xFE,0x7F,0x00,0x00,0x00,0x00},/*"问",1*/
{0x00,0x00,0xFE,0xFF,0x02,0x10,0x22,0x08,0x42,0x06,0x82,0x01,0x72,0x0E,0x02,0x10,0x22,0x08,0x42,0x06,0x82,0x01,0x72,0x4E,0x02,0x80,0xFE,0x7F,0x00,0x00,0x00,0x00},/*"网",2*/
};
#endif
</code></pre> 
<h4 id="8.1.2%20oled_drv.c">8.1.2 oled_drv.c</h4> 
<pre><code class="language-cpp">/*
 * Simple synchronous userspace interface to SPI devices
 *
 * Copyright (C) 2006 SWAPP
 *	Andrea Paterniani &lt;a.paterniani@swapp-eng.it&gt;
 * Copyright (C) 2007 David Brownell (simplification, cleanup)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/ioctl.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/err.h&gt;
#include &lt;linux/list.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/compat.h&gt;
#include &lt;linux/of.h&gt;
#include &lt;linux/of_device.h&gt;
#include &lt;linux/acpi.h&gt;

#include &lt;linux/spi/spi.h&gt;
#include &lt;linux/spi/spidev.h&gt;

#include &lt;linux/uaccess.h&gt;
#include &lt;linux/gpio/consumer.h&gt;


#define OLED_IOC_INIT 			123
#define OLED_IOC_SET_POS 		124

//为0 表示命令，为1表示数据
#define OLED_CMD 	0
#define OLED_DATA 	1



/*-------------------------------------------------------------------------*/

static struct spi_device *oled;
static int major;
static struct gpio_desc *dc_gpio;

static void dc_pin_init(void)
{
	gpiod_direction_output(dc_gpio, 1);
}

static void oled_set_dc_pin(int val)
{
	gpiod_set_value(dc_gpio, val);
}

static void spi_write_datas(const unsigned char *buf, int len)
{
	spi_write(oled, buf, len);
}


/**********************************************************************
	 * 函数名称： oled_write_cmd
	 * 功能描述： oled向特定地址写入数据或者命令
	 * 输入参数：@uc_data :要写入的数据
	 			@uc_cmd:为1则表示写入数据，为0表示写入命令
	 * 输出参数：无
	 * 返 回 值： 无
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/04		 V1.0	  芯晓		  创建
 ***********************************************************************/
static void oled_write_cmd_data(unsigned char uc_data,unsigned char uc_cmd)
{
	if(uc_cmd==0)
	{
		oled_set_dc_pin(0);
	}
	else
	{
		oled_set_dc_pin(1);//拉高，表示写入数据
	}
	spi_write_datas(&amp;uc_data, 1);//写入
}


/**********************************************************************
	 * 函数名称： oled_init
	 * 功能描述： oled_init的初始化，包括SPI控制器得初始化
	 * 输入参数：无
	 * 输出参数： 初始化的结果
	 * 返 回 值： 成功则返回0，否则返回-1
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
static int oled_init(void)
{
	oled_write_cmd_data(0xae,OLED_CMD);//关闭显示

	oled_write_cmd_data(0x00,OLED_CMD);//设置 lower column address
	oled_write_cmd_data(0x10,OLED_CMD);//设置 higher column address

	oled_write_cmd_data(0x40,OLED_CMD);//设置 display start line

	oled_write_cmd_data(0xB0,OLED_CMD);//设置page address

	oled_write_cmd_data(0x81,OLED_CMD);// contract control
	oled_write_cmd_data(0x66,OLED_CMD);//128

	oled_write_cmd_data(0xa1,OLED_CMD);//设置 segment remap

	oled_write_cmd_data(0xa6,OLED_CMD);//normal /reverse

	oled_write_cmd_data(0xa8,OLED_CMD);//multiple ratio
	oled_write_cmd_data(0x3f,OLED_CMD);//duty = 1/64

	oled_write_cmd_data(0xc8,OLED_CMD);//com scan direction

	oled_write_cmd_data(0xd3,OLED_CMD);//set displat offset
	oled_write_cmd_data(0x00,OLED_CMD);//

	oled_write_cmd_data(0xd5,OLED_CMD);//set osc division
	oled_write_cmd_data(0x80,OLED_CMD);//

	oled_write_cmd_data(0xd9,OLED_CMD);//ser pre-charge period
	oled_write_cmd_data(0x1f,OLED_CMD);//

	oled_write_cmd_data(0xda,OLED_CMD);//set com pins
	oled_write_cmd_data(0x12,OLED_CMD);//

	oled_write_cmd_data(0xdb,OLED_CMD);//set vcomh
	oled_write_cmd_data(0x30,OLED_CMD);//

	oled_write_cmd_data(0x8d,OLED_CMD);//set charge pump disable 
	oled_write_cmd_data(0x14,OLED_CMD);//

	oled_write_cmd_data(0xaf,OLED_CMD);//set dispkay on

	return 0;
}		  			 		  						  					  				 	   		  	  	 	  

//坐标设置
/**********************************************************************
	 * 函数名称： OLED_DIsp_Set_Pos
	 * 功能描述：设置要显示的位置
	 * 输入参数：@ x ：要显示的column address
	 			@y :要显示的page address
	 * 输出参数： 无
	 * 返 回 值： 
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
static void OLED_DIsp_Set_Pos(int x, int y)
{ 	oled_write_cmd_data(0xb0+y,OLED_CMD);
	oled_write_cmd_data((x&amp;0x0f),OLED_CMD); 
	oled_write_cmd_data(((x&amp;0xf0)&gt;&gt;4)|0x10,OLED_CMD);
}   	      	   			 


static long
spidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	int x, y;
	
	/* 根据cmd操作硬件 */
	switch (cmd)
	{
		case OLED_IOC_INIT: /* init */
		{
			dc_pin_init();
			oled_init();
			break;
		}

		case OLED_IOC_SET_POS: /* set pos */
		{
			x = arg &amp; 0xff;
			y = (arg &gt;&gt; 8) &amp; 0xff;
			OLED_DIsp_Set_Pos(x, y);
			break;
		}

	}

	return 0;
}

static ssize_t
spidev_write(struct file *filp, const char __user *buf,
		size_t count, loff_t *f_pos)
{
	char *ker_buf;
	int err;

	ker_buf = kmalloc(count, GFP_KERNEL);
	err = copy_from_user(ker_buf, buf, count);
	
	oled_set_dc_pin(1);//拉高，表示写入数据
	spi_write_datas(ker_buf, count);
	kfree(ker_buf);
	return count;
}

static const struct file_operations spidev_fops = {
	.owner =	THIS_MODULE,
	/* REVISIT switch to aio primitives, so that userspace
	 * gets more complete API coverage.  It'll simplify things
	 * too, except for the locking.
	 */
	.write =	spidev_write,
	.unlocked_ioctl = spidev_ioctl,
};

/*-------------------------------------------------------------------------*/

/* The main reason to have this class is to make mdev/udev create the
 * /dev/spidevB.C character device nodes exposing our userspace API.
 * It also simplifies memory management.
 */

static struct class *spidev_class;

static const struct of_device_id spidev_dt_ids[] = {
	{ .compatible = "cumtchw,oled" },
	{},
};


/*-------------------------------------------------------------------------*/

static int spidev_probe(struct spi_device *spi)
{
	/* 1. 记录spi_device */
	oled = spi;

	/* 2. 注册字符设备 */
	major = register_chrdev(0, "cumtchw_oled", &amp;spidev_fops);
	spidev_class = class_create(THIS_MODULE, "cumtchw_oled");
	device_create(spidev_class, NULL, MKDEV(major, 0), NULL, "cumtchw_oled");	

	/* 3. 获得GPIO引脚 */
	dc_gpio = gpiod_get(&amp;spi-&gt;dev, "dc", 0);

	return 0;
}

static int spidev_remove(struct spi_device *spi)
{
	gpiod_put(dc_gpio);
	
	/* 反注册字符设备 */
	device_destroy(spidev_class, MKDEV(major, 0));
	class_destroy(spidev_class);
	unregister_chrdev(major, "cumtchw_oled");

	return 0;
}

static struct spi_driver spidev_spi_driver = {
	.driver = {
		.name =		"cumtchw_spi_oled_drv",
		.of_match_table = of_match_ptr(spidev_dt_ids),
	},
	.probe =	spidev_probe,
	.remove =	spidev_remove,

	/* NOTE:  suspend/resume methods are not necessary here.
	 * We don't do anything except pass the requests to/from
	 * the underlying controller.  The refrigerator handles
	 * most issues; the controller driver handles the rest.
	 */
};

/*-------------------------------------------------------------------------*/

static int __init spidev_init(void)
{
	int status;

	status = spi_register_driver(&amp;spidev_spi_driver);
	if (status &lt; 0) {
	}
	return status;
}
module_init(spidev_init);

static void __exit spidev_exit(void)
{
	spi_unregister_driver(&amp;spidev_spi_driver);
}
module_exit(spidev_exit);

MODULE_LICENSE("GPL");

</code></pre> 
<h4 id="8.1.3%C2%A0spi_oled.c">8.1.3 spi_oled.c</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;

#include &lt;sys/ioctl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#include &lt;linux/types.h&gt;
#include &lt;linux/spi/spidev.h&gt;

#include "font.h"

#define OLED_IOC_INIT 			123
#define OLED_IOC_SET_POS 		124


//为0 表示命令，为1表示数据
#define OLED_CMD 	0
#define OLED_DATA 	1

static int fd_spidev;
static int dc_pin_num;


void OLED_DIsp_Set_Pos(int x, int y);

void oled_write_datas(const unsigned char *buf, int len)
{
	write(fd_spidev, buf, len);
}

		  			 		  						  					  				 	   		  	  	 	  		  			 		  						  					  				 	   		  	  	 	  

/**********************************************************************
	 * 函数名称： OLED_DIsp_Clear
	 * 功能描述： 整个屏幕显示数据清0
	 * 输入参数：无
	 * 输出参数： 无
	 * 返 回 值： 
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
void OLED_DIsp_Clear(void)  
{
    unsigned char x, y;
	char buf[128];

	memset(buf, 0, 128);
	
    for (y = 0; y &lt; 8; y++)
    {
        OLED_DIsp_Set_Pos(0, y);
        oled_write_datas(buf, 128);
    }
}

/**********************************************************************
	 * 函数名称： OLED_DIsp_All
	 * 功能描述： 整个屏幕显示全部点亮，可以用于检查坏点
	 * 输入参数：无
	 * 输出参数：无 
	 * 返 回 值：
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
void OLED_DIsp_All(void)  
{
    unsigned char x, y;
	char buf[128];

	memset(buf, 0xff, 128);
	
    for (y = 0; y &lt; 8; y++)
    {
        OLED_DIsp_Set_Pos(0, y);
        oled_write_datas(buf, 128);
    }



}

//坐标设置
/**********************************************************************
	 * 函数名称： OLED_DIsp_Set_Pos
	 * 功能描述：设置要显示的位置
	 * 输入参数：@ x ：要显示的column address
	 			@y :要显示的page address
	 * 输出参数： 无
	 * 返 回 值： 
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
void OLED_DIsp_Set_Pos(int x, int y)
{ 	
	ioctl(fd_spidev, OLED_IOC_SET_POS, x  | (y &lt;&lt; 8));
}   	      	   			 
/**********************************************************************
	  * 函数名称： OLED_DIsp_Char
	  * 功能描述：在某个位置显示字符 1-9
	  * 输入参数：@ x ：要显示的column address
		 			@y :要显示的page address
		 			@c ：要显示的字符的ascii码
	  * 输出参数： 无
	  * 返 回 值： 
	  * 修改日期		版本号	  修改人 	   修改内容
	  * -----------------------------------------------
	  * 2020/03/15		  V1.0	   芯晓		   创建
***********************************************************************/
void OLED_DIsp_Char(int x, int y, unsigned char c)
{
	int i = 0;
	/* 得到字模 */
	const unsigned char *dots = oled_asc2_8x16[c - ' '];

	/* 发给OLED */
	OLED_DIsp_Set_Pos(x, y);
	/* 发出8字节数据 */
	//for (i = 0; i &lt; 8; i++)
	//	oled_write_cmd_data(dots[i], OLED_DATA);
	oled_write_datas(&amp;dots[0], 8);

	OLED_DIsp_Set_Pos(x, y+1);
	/* 发出8字节数据 */
	//for (i = 0; i &lt; 8; i++)
		//oled_write_cmd_data(dots[i+8], OLED_DATA);
	oled_write_datas(&amp;dots[8], 8);
}


/**********************************************************************
	 * 函数名称： OLED_DIsp_String
	 * 功能描述： 在指定位置显示字符串
	 * 输入参数：@ x ：要显示的column address
		 			@y :要显示的page address
		 			@str ：要显示的字符串
	 * 输出参数： 无
	 * 返 回 值： 无
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
***********************************************************************/
void OLED_DIsp_String(int x, int y, char *str)
{
	unsigned char j=0;
	while (str[j])
	{		
		OLED_DIsp_Char(x, y, str[j]);//显示单个字符
		x += 8;
		if(x &gt; 127)
		{
			x = 0;
			y += 2;
		}//移动显示位置
		j++;
	}
}
/**********************************************************************
	 * 函数名称： OLED_DIsp_CHinese
	 * 功能描述：在指定位置显示汉字
	 * 输入参数：@ x ：要显示的column address
		 			@y :要显示的page address
		 			@chr ：要显示的汉字，三个汉字“百问网”中选择一个
	 * 输出参数： 无
	 * 返 回 值： 无
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/

void OLED_DIsp_CHinese(unsigned char x,unsigned char y,unsigned char no)
{      			    
	unsigned char t,adder=0;
	OLED_DIsp_Set_Pos(x,y);	
    for(t=0;t&lt;16;t++)
	{//显示上半截字符	
		oled_write_datas(&amp;hz_1616[no][t*2], 1);
		adder+=1;
    }	
	OLED_DIsp_Set_Pos(x,y+1);	
    for(t=0;t&lt;16;t++)
	{//显示下半截字符
		oled_write_datas(&amp;hz_1616[no][t*2+1], 1);
		adder+=1;
    }					
}
/**********************************************************************
	 * 函数名称： OLED_DIsp_Test
	 * 功能描述： 整个屏幕显示测试
	 * 输入参数：无
	 * 输出参数： 无
	 * 返 回 值： 无
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
void OLED_DIsp_Test(void)
{ 	
	int i;
	
	OLED_DIsp_String(0, 0, "https://blog.csdn.net/u013171226");
	
} 

/* spi_oled /dev/cumtchw_oled */
int main(int argc, char **argv)
{	
	if (argc != 2)
	{
		printf("Usage: %s /dev/cumtchw_oled\n", argv[0]);
		return -1;
	}

	fd_spidev = open(argv[1], O_RDWR);
	if (fd_spidev &lt; 0) {
		printf("open %s err\n", argv[1]);
		return -1;
	}


	ioctl(fd_spidev, OLED_IOC_INIT);

	OLED_DIsp_Clear();
	
	OLED_DIsp_Test();

	return 0;
}

</code></pre> 
<h4 id="8.1.4%20spi_oled.h">8.1.4 spi_oled.h</h4> 
<pre><code class="language-cpp">#ifndef _OLED_H_
#define _OLED_H_

void oled_write_cmd_data(unsigned char uc_data,unsigned char uc_cmd);
int oled_init(void);
int oled_fill_data(unsigned char fill_Data);
void OLED_DIsp_Clear(void);
void OLED_DIsp_All(void);
void OLED_DIsp_Set_Pos(int x, int y);
void OLED_DIsp_Char(int x, int y, unsigned char c);
void OLED_DIsp_String(int x, int y, char *str);
void OLED_DIsp_CHinese(unsigned char x,unsigned char y,unsigned char no);
void OLED_DIsp_Test();

		  			 		  						  					  				 	   		  	  	 	  
#endif
</code></pre> 
<h4 id="8.1.5%20Makfile">8.1.5 Makfile</h4> 
<pre><code class="language-bash"># 1. 使用不同的开发板内核时, 一定要修改KERN_DIR
# 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:
# 2.1 ARCH,          比如: export ARCH=arm64
# 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-
# 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin 
# 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,
#       请参考各开发板的高级用户使用手册

KERN_DIR = /data/chw/imx6ull_20230512/bsp/100ask_imx6ull-sdk/Linux-4.9.88

all:
	make -C $(KERN_DIR) M=`pwd` modules 
	$(CROSS_COMPILE)gcc -o spi_oled spi_oled.c

clean:
	make -C $(KERN_DIR) M=`pwd` modules clean
	rm -rf modules.order spi_oled

obj-m	+= oled_drv.o

</code></pre> 
<h4 id="8.1.6%20%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6">8.1.6 修改设备树文件</h4> 
<p>在spi1节点下面增加oled的子节点</p> 
<pre><code class="language-cpp">&amp;ecspi1 {
    pinctrl-names = "default";
    pinctrl-0 = &lt;&amp;pinctrl_ecspi1&gt;;

    fsl,spi-num-chipselects = &lt;2&gt;;
    cs-gpios = &lt;&amp;gpio4 26 GPIO_ACTIVE_LOW&gt;, &lt;&amp;gpio4 24 GPIO_ACTIVE_LOW&gt;;
    status = "okay";

    oled: oled {
        compatible = "cumtchw,oled";
        reg = &lt;0&gt;;
        spi-max-frequency = &lt;10000000&gt;;
        dc-gpios = &lt;&amp;gpio4 20 GPIO_ACTIVE_HIGH&gt;; 
    };
};</code></pre> 
<h3 id="8.2%20%E5%AE%9E%E9%AA%8C">8.2 实验</h3> 
<h3 id="8.2.1%20%E7%BC%96%E8%AF%91%E8%AE%BE%E5%A4%87%E6%A0%91">8.2.1 编译设备树</h3> 
<pre><code class="language-bash">export ARCH=arm
export CROSS_COMPILE=arm-buildroot-linux-gnueabihf-
make dtbs
cp arch/arm/boot/dts/100ask_imx6ull-14x14.dtb /data/chw/imx6ull_20230512/nfs_rootfs/
</code></pre> 
<h4 id="8.2.2%20%E7%BC%96%E8%AF%91%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F">8.2.2 编译驱动程序和测试程序</h4> 
<pre><code class="language-bash">export CROSS_COMPILE=arm-buildroot-linux-gnueabihf-
make clean
make all
cp oled_drv.ko spi_oled /data/chw/imx6ull_20230512/nfs_rootfs</code></pre> 
<h4 id="8.2.3%20%E6%B5%8B%E8%AF%95">8.2.3 测试</h4> 
<pre><code class="language-bash">udhcpc  -i  eth1
mount -t nfs -o nolock,vers=3 192.168.1.10:/data/chw/imx6ull_20230512/nfs_rootfs /mnt
ls /mnt
cp /mnt/100ask_imx6ull-14x14.dtb  /boot
cp /mnt/oled_drv.ko  ./
cp /mnt/spi_oled  ./
</code></pre> 
<p><img alt="" height="149" src="https://images2.imgbox.com/16/b9/BzkJngrl_o.png" width="770"></p> 
<p>挂载</p> 
<p><img alt="" height="30" src="https://images2.imgbox.com/37/19/0GMEhaIs_o.png" width="724"></p> 
<h3 id="8.3%20%E6%8A%A5%E9%94%99%EF%BC%9Ainsmod%3A%20ERROR%3A%20could%20not%20insert%20module%20oled_drv.ko%3A%20Invalid%20parameters">8.3 报错：insmod: ERROR: could not insert module oled_drv.ko: Invalid parameters</h3> 
<p>检查了一下为什么我从/mnt拷贝到./目录后，文件大小是0</p> 
<p><img alt="" height="451" src="https://images2.imgbox.com/9f/93/8SURYSNQ_o.png" width="1049"></p> 
<p>这里不知道是什么原因，还有的时候我拷贝完，然后我重启开发板，也会发现他可能变成0了。</p> 
<p>重新拷贝</p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/f0/7c/TXzt0yvk_o.png" width="1002"></p> 
<p>然后重新加载</p> 
<p><img alt="" height="526" src="https://images2.imgbox.com/93/82/9zgskKXF_o.png" width="1200"></p> 
<p>出现设备节点了，cumtchw是我的名字。 </p> 
<p>然后测试</p> 
<blockquote> 
 <p>./spi_oled  /dev/cumtchw_oled</p> 
</blockquote> 
<p>如下图所示，显示的是我的csdn博客网址 </p> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/e8/13/H20tcnla_o.jpg" width="1200"></p> 
<h2 id="9%20%E4%BD%BF%E7%94%A8spidev%E4%B8%87%E8%83%BD%E9%A9%B1%E5%8A%A8%E6%93%8D%E4%BD%9COLED">9 使用spidev万能驱动操作OLED</h2> 
<h3 id="9.1%20font.h">9.1 font.h</h3> 
<pre><code class="language-cpp">#ifndef  _FONT_H_
#define _FONT_H_
const unsigned char oled_asc2_8x16[95][16]=
{
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// 0
    {0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00},//!1
    {0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"2
    {0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00},//#3
    {0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00},//$4
    {0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00},//%5
    {0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10},//&amp;6
    {0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//'7
    {0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},//(8
    {0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},//)9
    {0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},//*10
    {0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00},//+11
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00},//,12
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01},//-13
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},//.14
    {0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00},///15
    {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},//016
    {0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//117
    {0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},//218
    {0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00},//319
    {0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00},//420
    {0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00},//521
    {0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00},//622
    {0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00},//723
    {0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},//824
    {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00},//925
    {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},//:26
    {0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00},//;27
    {0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},//&lt;28
    {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00},//=29
    {0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},//&gt;30
    {0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00},//?31
    {0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00},//@32
    {0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},//A33
    {0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},//B34
    {0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},//C35
    {0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},//D36
    {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},//E37
    {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},//F38
    {0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},//G39
    {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},//H40
    {0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//I41
    {0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},//J42
    {0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},//K43
    {0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},//L44
    {0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00},//M45
    {0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},//N46
    {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},//O47
    {0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},//P48
    {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00},//Q49
    {0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},//R50
    {0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},//S51
    {0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},//T52
    {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},//U53
    {0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},//V54
    {0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00},//W55
    {0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},//X56
    {0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},//Y57
    {0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},//Z58
    {0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},//[59
    {0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},//\60
    {0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},//]61
    {0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//^62
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},//_63
    {0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//`64
    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20},//a65
    {0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},//b66
    {0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},//c67
    {0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20},//d68
    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00},//e69
    {0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//f70
    {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},//g71
    {0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},//h72
    {0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//i73
    {0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},//j74
    {0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00},//k75
    {0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//l76
    {0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},//m77
    {0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},//n78
    {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},//o79
    {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00},//p80
    {0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80},//q81
    {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},//r82
    {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},//s83
    {0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00},//t84
    {0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},//u85
    {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00},//v86
    {0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00},//w87
    {0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00},//x88
    {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00},//y89
    {0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},//z90
    {0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40},//{91
    {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},//|92
    {0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00},//}93
    {0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//~94
};      
const unsigned char hz_1616[][32]={
{0x02,0x00,0x02,0x00,0xE2,0xFF,0x22,0x42,0x22,0x42,0x32,0x42,0x2A,0x42,0x26,0x42,0x22,0x42,0x22,0x42,0x22,0x42,0x22,0x42,0xE2,0xFF,0x02,0x00,0x02,0x00,0x00,0x00},/*"百",0*/
{0x00,0x00,0xF8,0xFF,0x01,0x00,0x02,0x00,0x00,0x00,0xE2,0x1F,0x22,0x08,0x22,0x08,0x22,0x08,0xE2,0x1F,0x02,0x00,0x02,0x40,0x02,0x80,0xFE,0x7F,0x00,0x00,0x00,0x00},/*"问",1*/
{0x00,0x00,0xFE,0xFF,0x02,0x10,0x22,0x08,0x42,0x06,0x82,0x01,0x72,0x0E,0x02,0x10,0x22,0x08,0x42,0x06,0x82,0x01,0x72,0x4E,0x02,0x80,0xFE,0x7F,0x00,0x00,0x00,0x00},/*"网",2*/
};
#endif
</code></pre> 
<h3 id="9.2%20spi_oled.h">9.2 spi_oled.h</h3> 
<pre><code class="language-cpp">#ifndef _OLED_H_
#define _OLED_H_

void oled_write_cmd_data(unsigned char uc_data,unsigned char uc_cmd);
int oled_init(void);
int oled_fill_data(unsigned char fill_Data);
void OLED_DIsp_Clear(void);
void OLED_DIsp_All(void);
void OLED_DIsp_Set_Pos(int x, int y);
void OLED_DIsp_Char(int x, int y, unsigned char c);
void OLED_DIsp_String(int x, int y, char *str);
void OLED_DIsp_CHinese(unsigned char x,unsigned char y,unsigned char no);
void OLED_DIsp_Test();

		  			 		  						  					  				 	   		  	  	 	  
#endif

</code></pre> 
<h3 id="9.3%C2%A0spi_oled.c">9.3 spi_oled.c</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;

#include &lt;sys/ioctl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#include &lt;linux/types.h&gt;
#include &lt;linux/spi/spidev.h&gt;

#include "font.h"

static int fd_spidev;
static int dc_pin_num;

void OLED_DIsp_Set_Pos(int x, int y);


void dc_pin_init(int number)
{
	// echo 509 &gt; /sys/class/gpio/export
	// echo out &gt; /sys/class/gpio/gpio509/direction	

	char cmd[100];

	dc_pin_num = number;

	sprintf(cmd, "echo %d &gt; /sys/class/gpio/export", number);
	system(cmd);

	sprintf(cmd, "echo out &gt; /sys/class/gpio/gpio%d/direction", number);
	system(cmd);	
}

void oled_set_dc_pin(int val)
{
	/* echo 1 &gt; /sys/class/gpio/gpio509/value
	 * echo 0 &gt; /sys/class/gpio/gpio509/value
	 */
	char cmd[100];
	sprintf(cmd, "echo %d &gt; /sys/class/gpio/gpio%d/value", val, dc_pin_num);
	system(cmd);	
}

void spi_write_datas(const unsigned char *buf, int len)
{
	write(fd_spidev, buf, len);
}

void oled_write_datas(const unsigned char *buf, int len)
{
	oled_set_dc_pin(1);//拉高，表示写入数据
	spi_write_datas(buf, len);
}

		  			 		  						  					  				 	   		  	  	 	  
/**********************************************************************
	 * 函数名称： oled_write_cmd
	 * 功能描述： oled向特定地址写入数据或者命令
	 * 输入参数：@uc_data :要写入的数据
	 			@uc_cmd:为1则表示写入数据，为0表示写入命令
	 * 输出参数：无
	 * 返 回 值： 无
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/04		 V1.0	  芯晓		  创建
 ***********************************************************************/
void oled_write_cmd_data(unsigned char uc_data,unsigned char uc_cmd)
{
	unsigned char uc_read=0;
	if(uc_cmd==0)
	{
		oled_set_dc_pin(0);
	}
	else
	{
		oled_set_dc_pin(1);//拉高，表示写入数据
	}
	spi_write_datas(&amp;uc_data, 1);//写入
}
/**********************************************************************
	 * 函数名称： oled_init
	 * 功能描述： oled_init的初始化，包括SPI控制器得初始化
	 * 输入参数：无
	 * 输出参数： 初始化的结果
	 * 返 回 值： 成功则返回0，否则返回-1
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
int oled_init(void)
{
	unsigned char uc_dev_id = 0;
		  			 		  						  					  				 	   		  	  	 	  
	oled_write_cmd_data(0xae,OLED_CMD);//关闭显示

	oled_write_cmd_data(0x00,OLED_CMD);//设置 lower column address
	oled_write_cmd_data(0x10,OLED_CMD);//设置 higher column address

	oled_write_cmd_data(0x40,OLED_CMD);//设置 display start line

	oled_write_cmd_data(0xB0,OLED_CMD);//设置page address

	oled_write_cmd_data(0x81,OLED_CMD);// contract control
	oled_write_cmd_data(0x66,OLED_CMD);//128

	oled_write_cmd_data(0xa1,OLED_CMD);//设置 segment remap

	oled_write_cmd_data(0xa6,OLED_CMD);//normal /reverse

	oled_write_cmd_data(0xa8,OLED_CMD);//multiple ratio
	oled_write_cmd_data(0x3f,OLED_CMD);//duty = 1/64

	oled_write_cmd_data(0xc8,OLED_CMD);//com scan direction

	oled_write_cmd_data(0xd3,OLED_CMD);//set displat offset
	oled_write_cmd_data(0x00,OLED_CMD);//

	oled_write_cmd_data(0xd5,OLED_CMD);//set osc division
	oled_write_cmd_data(0x80,OLED_CMD);//

	oled_write_cmd_data(0xd9,OLED_CMD);//ser pre-charge period
	oled_write_cmd_data(0x1f,OLED_CMD);//

	oled_write_cmd_data(0xda,OLED_CMD);//set com pins
	oled_write_cmd_data(0x12,OLED_CMD);//

	oled_write_cmd_data(0xdb,OLED_CMD);//set vcomh
	oled_write_cmd_data(0x30,OLED_CMD);//

	oled_write_cmd_data(0x8d,OLED_CMD);//set charge pump disable 
	oled_write_cmd_data(0x14,OLED_CMD);//

	oled_write_cmd_data(0xaf,OLED_CMD);//set dispkay on

	return 0;
}		  			 		  						  					  				 	   		  	  	 	  
/**********************************************************************
	 * 函数名称： oled_fill_data
	 * 功能描述： 整个屏幕显示填充某个固定数据
	 * 输入参数：@fill_Data：要填充的数据
	 * 输出参数： 填充结果
	 * 返 回 值： 成功则返回0
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
int oled_fill_data(unsigned char fill_Data)
{
	unsigned char x,y;
	for(x=0;x&lt;8;x++)
	{
	
		oled_write_cmd_data(0xb0+x,OLED_CMD);		//page0-page1
		oled_write_cmd_data(0x00,OLED_CMD);		//low column start address
		oled_write_cmd_data(0x10,OLED_CMD);		//high column start address	
		for(y=0;y&lt;128;y++)
		{
			oled_write_cmd_data(fill_Data,OLED_DATA);//填充数据
		}				
	}
	return 0;
}
/**********************************************************************
	 * 函数名称： OLED_DIsp_Clear
	 * 功能描述： 整个屏幕显示数据清0
	 * 输入参数：无
	 * 输出参数： 无
	 * 返 回 值： 
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
void OLED_DIsp_Clear(void)  
{
    unsigned char x, y;
	char buf[128];

	memset(buf, 0, 128);
	
    for (y = 0; y &lt; 8; y++)
    {
        OLED_DIsp_Set_Pos(0, y);
        //for (x = 0; x &lt; 128; x++)
        //    oled_write_cmd_data(0, OLED_DATA); /* 清零 */
        oled_write_datas(buf, 128);
    }
}

/**********************************************************************
	 * 函数名称： OLED_DIsp_All
	 * 功能描述： 整个屏幕显示全部点亮，可以用于检查坏点
	 * 输入参数：无
	 * 输出参数：无 
	 * 返 回 值：
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
void OLED_DIsp_All(void)  
{
	unsigned char x, y;
	for (y = 0; y &lt; 8; y++)
	{
		OLED_DIsp_Set_Pos(0, y);
		for (x = 0; x &lt; 128; x++)
			oled_write_cmd_data(0xff, OLED_DATA); /* 全点亮 */
	}
}

//坐标设置
/**********************************************************************
	 * 函数名称： OLED_DIsp_Set_Pos
	 * 功能描述：设置要显示的位置
	 * 输入参数：@ x ：要显示的column address
	 			@y :要显示的page address
	 * 输出参数： 无
	 * 返 回 值： 
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
void OLED_DIsp_Set_Pos(int x, int y)
{ 	oled_write_cmd_data(0xb0+y,OLED_CMD);
	oled_write_cmd_data((x&amp;0x0f),OLED_CMD); 
	oled_write_cmd_data(((x&amp;0xf0)&gt;&gt;4)|0x10,OLED_CMD);
}   	      	   			 
/**********************************************************************
	  * 函数名称： OLED_DIsp_Char
	  * 功能描述：在某个位置显示字符 1-9
	  * 输入参数：@ x ：要显示的column address
		 			@y :要显示的page address
		 			@c ：要显示的字符的ascii码
	  * 输出参数： 无
	  * 返 回 值： 
	  * 修改日期		版本号	  修改人 	   修改内容
	  * -----------------------------------------------
	  * 2020/03/15		  V1.0	   芯晓		   创建
***********************************************************************/
void OLED_DIsp_Char(int x, int y, unsigned char c)
{
	int i = 0;
	/* 得到字模 */
	const unsigned char *dots = oled_asc2_8x16[c - ' '];

	/* 发给OLED */
	OLED_DIsp_Set_Pos(x, y);
	/* 发出8字节数据 */
	//for (i = 0; i &lt; 8; i++)
	//	oled_write_cmd_data(dots[i], OLED_DATA);
	oled_write_datas(&amp;dots[0], 8);

	OLED_DIsp_Set_Pos(x, y+1);
	/* 发出8字节数据 */
	//for (i = 0; i &lt; 8; i++)
		//oled_write_cmd_data(dots[i+8], OLED_DATA);
	oled_write_datas(&amp;dots[8], 8);
}


/**********************************************************************
	 * 函数名称： OLED_DIsp_String
	 * 功能描述： 在指定位置显示字符串
	 * 输入参数：@ x ：要显示的column address
		 			@y :要显示的page address
		 			@str ：要显示的字符串
	 * 输出参数： 无
	 * 返 回 值： 无
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
***********************************************************************/
void OLED_DIsp_String(int x, int y, char *str)
{
	unsigned char j=0;
	while (str[j])
	{		
		OLED_DIsp_Char(x, y, str[j]);//显示单个字符
		x += 8;
		if(x &gt; 127)
		{
			x = 0;
			y += 2;
		}//移动显示位置
		j++;
	}
}
/**********************************************************************
	 * 函数名称： OLED_DIsp_CHinese
	 * 功能描述：在指定位置显示汉字
	 * 输入参数：@ x ：要显示的column address
		 			@y :要显示的page address
		 			@chr ：要显示的汉字，三个汉字“百问网”中选择一个
	 * 输出参数： 无
	 * 返 回 值： 无
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/

void OLED_DIsp_CHinese(unsigned char x,unsigned char y,unsigned char no)
{      			    
	unsigned char t,adder=0;
	OLED_DIsp_Set_Pos(x,y);	
    for(t=0;t&lt;16;t++)
	{//显示上半截字符	
		oled_write_cmd_data(hz_1616[no][t*2],OLED_DATA);
		adder+=1;
    }	
	OLED_DIsp_Set_Pos(x,y+1);	
    for(t=0;t&lt;16;t++)
	{//显示下半截字符
		oled_write_cmd_data(hz_1616[no][t*2+1],OLED_DATA);
		adder+=1;
    }					
}
/**********************************************************************
	 * 函数名称： OLED_DIsp_Test
	 * 功能描述： 整个屏幕显示测试
	 * 输入参数：无
	 * 输出参数： 无
	 * 返 回 值： 无
	 * 修改日期 	   版本号	 修改人		  修改内容
	 * -----------------------------------------------
	 * 2020/03/15		 V1.0	  芯晓		  创建
 ***********************************************************************/
void OLED_DIsp_Test(void)
{ 	
	int i;
	
	OLED_DIsp_String(0, 0, "wiki.100ask.net");
	OLED_DIsp_String(0, 2, "book.100ask.net");
	OLED_DIsp_String(0, 4, "bbs.100ask.net");
	
	for(i = 0; i &lt; 3; i++)
	{   //显示汉字 百问网
		OLED_DIsp_CHinese(32+i*16, 6, i);
	}
} 

/* spi_oled /dev/spidevB.D &lt;DC_pin_number&gt; */
int main(int argc, char **argv)
{
	int dc_pin;
	
	if (argc != 3)
	{
		printf("Usage: %s &lt;dev/spidevB.D&gt; &lt;DC_pin_number&gt;\n", argv[0]);
		return -1;
	}

	fd_spidev = open(argv[1], O_RDWR);
	if (fd_spidev &lt; 0) {
		printf("open %s err\n", argv[1]);
		return -1;
	}

	dc_pin = strtoul(argv[2], NULL, 0);
	dc_pin_init(dc_pin);

	oled_init();

	OLED_DIsp_Clear();
	
	OLED_DIsp_Test();

	return 0;
}

</code></pre> 
<h2 id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%EF%BC%9A">10 参考文献：</h2> 
<p>正点原子驱动开发手册</p> 
<p>韦东山老师驱动开发大全学习视频</p> 
<p>Linux4.9.88内核源码</p> 
<p><a href="https://blog.csdn.net/weixin_42262944/article/details/102944484" title="Linux SPI驱动框架(1)——核心层_linux spi驱动模型_绍兴小贵宁的博客-CSDN博客">Linux SPI驱动框架(1)——核心层_linux spi驱动模型_绍兴小贵宁的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/758d0cf76fbe0822a5ec7cbbdce74832/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java的字节流InputStream（字节输入流），OutputStream（字节输出流）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70c2775e4d44ae3fb19cdda43db9ac18/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决VS中文编译时出现：常量中有换行符</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>