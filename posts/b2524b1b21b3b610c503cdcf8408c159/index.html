<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第10章 Spark - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第10章 Spark" />
<meta property="og:description" content="10.1 Spark概述 10.1.1 Spark简介 Spark具有如下几个主要特点：
•运行速度快：使用DAG执行引擎以支持循环数据流与内存计算
•容易使用：支持使用Scala、Java、Python和R语言进行编程，可以通过 Spark Shell进行交互式编程
•通用性：Spark提供了完整而强大的技术栈，包括SQL查询、流式计算 、机器学习和图算法组件
•运行模式多样：可运行于独立的集群模式中，可运行于Hadoop中，也 可运行于Amazon EC2等云环境中，并且可以访问HDFS、Cassandra、 HBase、Hive等多种数据源
10.1.2 Scala简介 Scala是一门现代的多范式编程语言，运行于Java平台（JVM， Java 虚拟机），并兼容现有的Java程序
Scala的特性：
•Scala具备强大的并发性，支持函数式编程，可以更好地支持分布式系统
•Scala语法简洁，能提供优雅的API Scala兼容Java，运行速度快，且能融合到Hadoop生态圈中
•Scala是Spark的主要编程语言，但Spark还支持Java、Python、R作为编程语言
•Scala的优势是提供了REPL（Read-Eval-Print Loop，交互式解释器），提高程序开发效率
10.1.3 Spark与Hadoop的对比 Hadoop存在如下一些缺点：
•表达能力有限
•磁盘IO开销大
•延迟高
相比于Hadoop MapReduce，Spark主要具有如下优点：
•Spark的计算模式也属于MapReduce，但不局限于Map和Reduce操作，还提供了多种数据集操作类型，编程模型比Hadoop MapReduce更灵活
•Spark提供了内存计算，可将中间结果放到内存中，对于迭代运算效率更高
•Spark基于DAG的任务调度执行机制，要优于Hadoop MapReduce的迭代 执行机制
使用Hadoop进行迭代计算非常耗资源
Spark将数据载入内存后，之后的迭代计算都可以直接使用内存中的中间 结果作运算，避免从磁盘中频繁读取数据
10.2 Spark生态系统 在实际应用中，大数据处理主要包括以下三个类型：
•复杂的批量数据处理：通常时间跨度在数十分钟到数小时之间
•基于历史数据的交互式查询：通常时间跨度在数十秒到数分钟之间
•基于实时数据流的数据处理：通常时间跨度在数百毫秒到数秒之间
•Spark的设计遵循“一个软件栈满足不同应用场景”的理念，逐渐形成了一套完整的生态系统
•既能够提供内存计算框架，也可以支持SQL即席查询、实时流式计算、机器学习和图计算等
•Spark可以部署在资源管理器YARN之上，提供一站式的大数据解决方案
•因此，Spark所提供的生态系统足以应对上述三种场景，即同时支持批处理、交互式查询和流数据处理
Spark的生态系统主要包含了Spark Core、Spark SQL、Spark Streaming、 MLLib和GraphX 等组件。
10.3 Spark运行架构 10.3.1 基本概念 •RDD：是Resillient Distributed Dataset（弹性分布式数据集）的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型
•DAG：是Directed Acyclic Graph（有向无环图）的简称，反映RDD之间的依赖关系" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b2524b1b21b3b610c503cdcf8408c159/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-29T12:54:07+08:00" />
<meta property="article:modified_time" content="2022-07-29T12:54:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第10章 Spark</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="101_Spark_0"></a>10.1 Spark概述</h4> 
<h5><a id="1011_Spark_2"></a>10.1.1 Spark简介</h5> 
<p>Spark具有如下几个<strong>主要特点</strong>：</p> 
<p>•运行速度快：使用DAG执行引擎以支持循环数据流与内存计算</p> 
<p>•容易使用：支持使用Scala、Java、Python和R语言进行编程，可以通过 Spark Shell进行交互式编程</p> 
<p>•通用性：Spark提供了完整而强大的技术栈，包括SQL查询、流式计算 、机器学习和图算法组件</p> 
<p>•运行模式多样：可运行于独立的集群模式中，可运行于Hadoop中，也 可运行于Amazon EC2等云环境中，并且可以访问HDFS、Cassandra、 HBase、Hive等多种数据源</p> 
<hr> 
<h5><a id="1012_Scala_16"></a>10.1.2 Scala简介</h5> 
<p>Scala是一门现代的多范式编程语言，运行于Java平台（JVM， Java 虚拟机），并兼容现有的Java程序</p> 
<p>Scala的<strong>特性</strong>：</p> 
<p>•Scala具备强大的并发性，支持函数式编程，可以更好地支持分布式系统</p> 
<p>•Scala语法简洁，能提供优雅的API Scala兼容Java，运行速度快，且能融合到Hadoop生态圈中</p> 
<p>•Scala是Spark的主要编程语言，但Spark还支持Java、Python、R作为编程语言</p> 
<p>•Scala的优势是提供了REPL（Read-Eval-Print Loop，交互式解释器），提高程序开发效率</p> 
<hr> 
<h5><a id="1013_SparkHadoop_32"></a>10.1.3 Spark与Hadoop的对比</h5> 
<p><strong>Hadoop</strong>存在如下一些<strong>缺点</strong>：</p> 
<p>•表达能力有限</p> 
<p>•磁盘IO开销大</p> 
<p>•延迟高</p> 
<p>相比于Hadoop MapReduce，<strong>Spark</strong>主要具有如下<strong>优点</strong>：</p> 
<p>•Spark的计算模式也属于MapReduce，但不局限于Map和Reduce操作，还提供了多种数据集操作类型，编程模型比Hadoop MapReduce更灵活</p> 
<p>•Spark提供了内存计算，可将中间结果放到内存中，对于迭代运算效率更高</p> 
<p>•Spark基于DAG的任务调度执行机制，要优于Hadoop MapReduce的迭代 执行机制</p> 
<p><img src="https://images2.imgbox.com/ee/65/pkwlVyff_o.png" alt="在这里插入图片描述"></p> 
<p>使用Hadoop进行迭代计算非常耗资源</p> 
<p>Spark将数据载入内存后，之后的迭代计算都可以直接使用内存中的中间 结果作运算，避免从磁盘中频繁读取数据</p> 
<hr> 
<h4><a id="102_Spark_61"></a>10.2 Spark生态系统</h4> 
<p>在实际应用中，大数据处理主要包括以下三个类型：</p> 
<p>•复杂的批量数据处理：通常时间跨度在数十分钟到数小时之间</p> 
<p>•基于历史数据的交互式查询：通常时间跨度在数十秒到数分钟之间</p> 
<p>•基于实时数据流的数据处理：通常时间跨度在数百毫秒到数秒之间</p> 
<p>•Spark的设计遵循“一个软件栈满足不同应用场景”的理念，逐渐形成了一套完整的生态系统</p> 
<p>•既能够提供内存计算框架，也可以支持SQL即席查询、实时流式计算、机器学习和图计算等</p> 
<p>•Spark可以部署在资源管理器YARN之上，提供一站式的大数据解决方案</p> 
<p>•因此，Spark所提供的生态系统足以应对上述三种场景，即同时支持批处理、交互式查询和流数据处理</p> 
<p>Spark的生态系统主要包含了Spark Core、Spark SQL、Spark Streaming、 MLLib和GraphX 等组件。</p> 
<p><img src="https://images2.imgbox.com/33/47/SkuX1oZV_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="103_Spark_89"></a>10.3 Spark运行架构</h4> 
<h5><a id="1031__91"></a>10.3.1 基本概念</h5> 
<p><strong>•RDD</strong>：是Resillient Distributed Dataset（弹性分布式数据集）的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型</p> 
<p><strong>•DAG</strong>：是Directed Acyclic Graph（有向无环图）的简称，反映RDD之间的依赖关系</p> 
<p><strong>•Executor</strong>：是运行在工作节点（WorkerNode）的一个进程，负责运行Task</p> 
<p><strong>•Application</strong>：用户编写的Spark应用程序</p> 
<p><strong>•Task</strong>：运行在Executor上的工作单元</p> 
<p><strong>•Job</strong>：一个Job包含多个RDD及作用于相应RDD上的各种操作</p> 
<p><strong>•Stage</strong>：是Job的基本调度单位，一个Job会分为多组Task，每组Task被称为 Stage，或者也被称为TaskSet，代表了一组关联的、相互之间没有Shuffle依赖关系的任务组成的任务集</p> 
<hr> 
<h5><a id="1032__109"></a>10.3.2 架构设计</h5> 
<p><img src="https://images2.imgbox.com/e3/7f/WyudAx8Q_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Spark运行架构</strong>包括<strong>集群资源管理器（Cluster Manager）</strong>、运行作业任务的<strong>工作节点 （Worker Node）</strong>、每个应用的<strong>任务控制节点（Driver）<strong>和每个工作节点上负责具体任务的</strong>执行进程（Executor）</strong></p> 
<p>资源管理器可以自带或Mesos或YARN，与Hadoop MapReduce计算框架相比，Spark所采用的Executor有两个优点：</p> 
<p>•一是利用多线程来执行具体的任务，减少任务的启动开销</p> 
<p>•二是Executor中有一个BlockManager存储模块，会将内存和磁盘共同作为存储设备， 有效减少IO开销</p> 
<p><img src="https://images2.imgbox.com/d5/1b/CVowtXaU_o.png" alt="在这里插入图片描述"></p> 
<p>•一个Application由一个Driver和若干个Job构成，一个Job由多个Stage构成，一个Stage由多个没有Shuffle关系的Task组成</p> 
<p>•当执行一个Application时，Driver会向集群管理器申请资源，启动Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行Task，运行结束后，执行结果会返回给Driver，或者写到HDFS或者其他数据库中</p> 
<h5><a id="1033_Spark_129"></a>10.3.3 Spark运行基本流程</h5> 
<p><img src="https://images2.imgbox.com/2d/d1/7Y0rN5UJ_o.png" alt="在这里插入图片描述"></p> 
<p>（1）首先为应用构建起基本的运行环境，即由Driver创建一个SparkContext， 进行资源的申请、任务的分配和监控</p> 
<p>（2）资源管理器为Executor分配资源， 并启动Executor进程</p> 
<p>（3）SparkContext根据RDD的依赖关系 构建DAG图，DAG图提交给 DAGScheduler解析成Stage，然后把一个个TaskSet提交给底层调度器 TaskScheduler处理；Executor向 SparkContext申请Task，Task Scheduler 将Task发放给Executor运行，并提供应用程序代码</p> 
<p>（4）Task在Executor上运行，把执行结果反馈给TaskScheduler，然后反馈给 DAGScheduler，运行完毕后写入数据并释放所有资源</p> 
<p>总体而言，Spark运行架构具有以下<strong>特点</strong>：</p> 
<p>（1）每个Application都有自己专属的Executor进程，并且该进程在Application运行期间一直驻留。Executor进程以多线程的方式运行Task</p> 
<p>（2）Spark运行过程与资源管理器无关，只要能够获取 Executor进程并保持通信即可</p> 
<p>（3）Task采用了数据本地性和推测执行等优化机制</p> 
<hr> 
<h5><a id="1034_RDD_155"></a>10.3.4 RDD运行原理</h5> 
<p><strong>1.RDD概念</strong></p> 
<p>•一个RDD就是一个分布式对象集合，本质上是一个<strong>只读</strong>的分区记录集 合，每个RDD可分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算</p> 
<p>•RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集创建RDD， 或者通过在其他RDD上执行确定的转换操作（如map、join和group by） 而创建得到新的RDD</p> 
<p>•RDD提供了一组丰富的操作以支持常见的数据运算，分为**“动作” （Action）<strong>和</strong>“转换”（Transformation）**两种类型</p> 
<p>•RDD提供的转换接口都非常简单，都是类似map、filter、groupBy、join 等粗粒度的数据转换操作，而不是针对某个数据项的细粒度修改（不适合网页爬虫）</p> 
<p>•表面上RDD的功能很受限、不够强大，实际上RDD已经被实践证明可以高效地表达许多框架的编程模型（比如MapReduce、SQL、Pregel）</p> 
<p>•Spark用Scala语言实现了RDD的API，程序员可以通过调用API实现对RDD的各种操作</p> 
<hr> 
<p><strong>2.RDD典型的执行过程</strong></p> 
<p>•RDD读入外部数据源进行创建</p> 
<p>•RDD经过一系列的转换（Transformation）操作，每一次都会产生不同的 RDD，供给下一个转换操作使用</p> 
<p>•最后一个RDD经过“动作”操作进行转换，并输出到外部数据源</p> 
<p>这一系列处理称为一个Lineage（血缘关系），即DAG拓扑排序的结果</p> 
<p><strong>优点</strong>：惰性调用（到“动作”操作时才进行计算）、管道化、避免同步等待、不需要保存中间结果、每次操作变得简单</p> 
<p><img src="https://images2.imgbox.com/fb/da/jeJ4MiGM_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>3.RDD特性</strong></p> 
<p>Spark采用RDD以后能够实现高效计算的原因主要在于：</p> 
<p>（1）高效的容错性</p> 
<p>​ •现有容错机制：数据复制或者记录日志</p> 
<p>​ •RDD：血缘关系、重新计算丢失分区、无需回滚系统、重算过程在不同节点之间并行、只记录粗粒度的操作</p> 
<p>（2）中间结果持久化到内存，数据在内存中的多个RDD操作之间 进行传递，避免了不必要的读写磁盘开销</p> 
<p>（3）存放的数据可以是Java对象，避免了不必要的对象序列化和反序列化</p> 
<hr> 
<p><strong>4.RDD之间的依赖关系</strong><br> <img src="https://images2.imgbox.com/6c/aa/Iy9pW3L2_o.png" alt="在这里插入图片描述"></p> 
<p><strong>•窄依赖</strong>表现为一个父RDD的分区对应于一个子RDD的分区或多个父RDD的分区对应于一个 RDD的分区**（一对一）**</p> 
<p><strong>•宽依赖</strong>则表现为存 在一个父RDD的一个分区对应一个子RDD的多分区**（一对多）**</p> 
<hr> 
<p><strong>5.Stage的划分</strong></p> 
<p>Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分Stage，具体<strong>划分方法</strong>是：</p> 
<p>•在DAG中进行反向解析，遇到宽依赖就断开</p> 
<p>•遇到窄依赖就把当前的RDD加入到Stage中</p> 
<p>•将窄依赖尽量划分在同一个Stage中，可以实现流水线计算</p> 
<p><img src="https://images2.imgbox.com/c9/ea/dErIXCOs_o.png" alt="在这里插入图片描述"></p> 
<p>​ 假设从HDFS中读入数据生成3个不同的RDD（即A、C 和 E），通过一些列转换操作后再将计算结果保存回HDFS。对DAG进行解析时，在依赖图中进行反向解析，由于从<strong>RDD A</strong>到<strong>RDD B</strong>的转换以及从（<strong>RDD B</strong>和<strong>RDD F</strong>）到<strong>RDD G</strong>的转换都属于宽依赖，因此在宽依赖处断开后可以得到3个阶段，即Stage1、Stage2、Stage3。</p> 
<p>​ 在Stage2中，从map到union都是窄依赖，这两步操作可以形成一个流水线操作。比如分区7通过map操作生成分区9，可以不用等待分区8到分区10这个转换操作的计算技术，而是继续进行union操作，转换得到分区13，这样流水线执行大大提高了计算的效率。</p> 
<p>Stage的类型包括两种：ShuffleMapStage和ResultStage，具体如下：</p> 
<p>（1）ShuffleMapStage：不是最终的Stage，在它之后还有其他Stage， 所以，它的输出一定需要经过Shuffle过程，并作为后续Stage的输入；这种Stage是以Shuffle为输出边界，其输入边界可以是从外部获取数据，也 可以是另一个ShuffleMapStage的输出，其输出可以是另一个Stage的开 始；在一个Job里可能有该类型的Stage，也可能没有该类型Stage；</p> 
<p>（2）ResultStage：最终的Stage，没有输出，而是直接产生结果或存储。 这种Stage是直接输出结果，其输入边界可以是从外部获取数据，也可以 是另一个ShuffleMapStage的输出。在一个Job里必定有该类型Stage。</p> 
<p>因此，一个Job含有一个或多个Stage，其中至少含有一个ResultStage。</p> 
<hr> 
<p><strong>6.RDD运行过程</strong></p> 
<p>总结一下RDD在Spark架构中的运行过程：</p> 
<p>（1）创建RDD对象；</p> 
<p>（2）SparkContext负责计算RDD之间的依赖关系，构建DAG；</p> 
<p>（3）DAGScheduler负责把DAG图分解成多个Stage，每个Stage中包含了多个 Task，每个Task会被TaskScheduler分发给各个WorkerNode上的Executor去执 行。</p> 
<p><img src="https://images2.imgbox.com/13/af/0NW6HeHh_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="104_Spark_SQL_259"></a>10.4 Spark SQL</h4> 
<h5><a id="1041_Shark_261"></a>10.4.1 Shark</h5> 
<p>•Shark即Hive on Spark，为了实现与Hive兼容， Shark在HiveQL方面重用了Hive中HiveQL的解析、逻辑执行计划翻译、执行计划优化等逻辑， <strong>可以近似认为仅将物理执行计划从MapReduce作 业替换成了Spark作业，通过Hive的HiveQL解析，把HiveQL翻译成Spark上的RDD操作。</strong></p> 
<p>•Shark的设计导致了两个问题：</p> 
<p>​ •一是执行计划优化完全依赖于Hive，不方便添加新的优化策略；</p> 
<p>​ •二是因为Spark是线程级并行，而 MapReduce是进程级并行，因此，Spark在兼容Hive的实现上存在线程安全问题，导致 Shark不得不使用另外一套独立维护的打了补丁的Hive源码分支</p> 
<hr> 
<h5><a id="1042_Spark_SQL_273"></a>10.4.2 Spark SQL</h5> 
<p>Spark SQL在Hive兼容层面仅依赖HiveQL解析、Hive元数据，也就是说，从 HQL被解析成抽象语法树（AST）起，就全部由Spark SQL接管了。Spark SQL执行计划生成和优化都由Catalyst（函数式关系查询优化框架）负责</p> 
<p><img src="https://images2.imgbox.com/b2/cb/sQZKC9tf_o.png" alt="在这里插入图片描述"></p> 
<p>•Spark SQL增加了SchemaRDD（即带有Schema信息的RDD），使用户可 以在Spark SQL中执行SQL语句，数据既可以来自RDD，也可以是Hive、 HDFS、Cassandra等外部数据源，还可以是JSON格式的数据</p> 
<p>•Spark SQL目前支持Scala、Java、Python三种语言，支持SQL-92规范<br> <img src="https://images2.imgbox.com/08/92/fteZOM9H_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="105_Spark_287"></a>10.5 Spark的部署和应用方式</h4> 
<h5><a id="1051_Spark_289"></a>10.5.1 Spark三种部署方式</h5> 
<p>Spark支持三种不同类型的部署方式，包括：</p> 
<p><strong>•Standalone</strong>（类似于MapReduce1.0，slot为资源分配单位）</p> 
<p><strong>•Spark on Mesos</strong>（和Spark有血缘关系，更好支持Mesos）</p> 
<p><strong>•Spark on YARN</strong></p> 
<p><img src="https://images2.imgbox.com/fe/8e/syF7nC8g_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="1052_HadoopStormSpark_303"></a>10.5.2 从Hadoop+Storm架构转向Spark架构</h5> 
<p>用Spark架构具有如下<strong>优点：</strong></p> 
<p>•实现一键式安装和配置、线程级别的任务监控和告警</p> 
<p>•降低硬件集群、软件维护、任务监 控和应用开发的难度</p> 
<p>•便于做成统一的硬件、计算平台资源池</p> 
<p>需要说明的是，Spark Streaming无法实现毫秒级的流计算，因此，对于需要毫秒级实时响应的企业应用 而言，仍然需要采用流计算框架 （如Storm）</p> 
<p>（Spark Streaming的原理是将流数据分解成一系列短小的批处理作业，每个短小的批处理作业使用面向批处理的Spark Core进行处理，通过这种方式变相实现六流计算，而<strong>不是真正实时的流计算</strong>）<br> <img src="https://images2.imgbox.com/7f/0d/6wRdoAeX_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="1053_HadoopSpark_320"></a>10.5.3 Hadoop和Spark的统一部署</h5> 
<p>•由于Hadoop生态系统中的一些组件所实现的功能，目前还是无法由Spark 取代的，比如，Storm</p> 
<p>现有的Hadoop组件开发的应用，完全转移到Spark上需要一定的成本，不同的计算框架统一运行在YARN中，可以带来如下好处：</p> 
<p>•计算资源按需伸缩</p> 
<p>•不用负载应用混搭，集群利用率高</p> 
<p>•共享底层存储，避免数据跨集群迁移</p> 
<p><img src="https://images2.imgbox.com/41/38/jErG84Mj_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_336"></a></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/83b693cef08ea4c29ee81d6f29b974d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第6章 云数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f4b9fbbf36e5cbebd14b1c4c46fbee89/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Centos8.x yum 源配置 解决 yum 不可用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>