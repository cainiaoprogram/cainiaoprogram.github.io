<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构知识点整理（类C语言实现）（在更新） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构知识点整理（类C语言实现）（在更新）" />
<meta property="og:description" content="注意：类C语言使用引用传参(&amp;)，是借用C&#43;&#43;语法中的内容，C语言实现时使用指针(*）传参，与类C代码有很大不同 2.线性表 案例：稀疏多项式的运算 创建一个新数组c分别从头遍历比较a和b的每一项 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项指数不相同：则将较小项复制到c中 当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可 线性表的基本操作： InitList(&amp;L)
线性表的初始化操作结果：构建一个空的线性表L DestroyList(&amp;L)
初始条件：线性表L已经存在操作结果：销毁线性表L（表本身消失） ClearList(&amp;L)
初始条件：线性表L已经存在操作结果：将线性表L重置为空表（表仍存在） ListEmpty(L)
初始条件：线性表L已经存在操作结果：若线性表为空，则返回TURE；否则返回FALSE ListLength(L)
初始条件：线性表L已经存在操作结果：返回线性表中元素个数 GetElem(L,i,&amp;e)
初始条件：线性表L已经存在，1&lt;=i&lt;=ListLength(L)操作结果：用e返回线性表L中第i个元素的值 LocateElem(L,e,compare())
初始条件：线性表L已经存在，compare()是数据元素判定函数操作结果：返回L中第一个与e满足compare()的数据元素的位序，若不存在，则返回0 PriorElem(L,cur_e,&amp;pre_e)
初始条件：线性表L已经存在操作结果：若cur_e，是L的数据元素，且不是第一个，则用pre_e返回他的前驱，否则操作失败，pre_e无意义 NextElem(L,cur_e,&amp;next_e)
初始条件：线性表L已经存在
操作结果：若cur_e，是L的数据元素，且不是最后一个，则用next_e返回他的前驱，否则操作失败，next_e无意义
ListInsert(&amp;L,i,e)
初始条件：线性表L已经存在，i&lt;=i&lt;=ListLength(L)&#43;1操作结果：在L的第i个位置前插入新的元素e，L的长度加一 ListDelete(&amp;L,i,&amp;e)
初始条件：线性表L已经存在，i&lt;=i&lt;=ListLength(L)操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一 ListTraverse(&amp;L,visited())
初始条件：线性表L已经存在操作结果：依次对线性表L中每个元素调用visited() 算法中用到的预定义常量和类型 //函数结果状态代码 #define TURE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 //Status 是函数的类型，其值是函数结果状态代码 typedef int Status; typedef char ElemType; 顺序表 1.顺序表中元素存储位置的计算 假设线性表的每个元素需占用i个存储单元，则第i&#43;j个元素的存储位置和第i个元素的存储位置之间满足关系： LOC(a(n&#43;1))=LOC(a(n))&#43;i 2.顺序表的特点 以物理位置相邻表示逻辑关系，任一元素均可随机存取 3.顺序表 地址连续依次存放随机存取类型相同 4.顺序表的类C语言代码实现 #define LIST_INIT_SIZE 100//线性表存储空间的初始分配量 typedef struct { ElemType elem[LIST_INIT_SIZE];//方案1：静态数组方式 ElemType *elem;//方案2：动态内存分配方式 int length;//当前长度 }SqList; SqList L;//定义变量L，L是SqList这种类型的变量，L是个顺序表 L." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c44db0d87166a07cb1b0971300121b8f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-08T18:03:21+08:00" />
<meta property="article:modified_time" content="2023-11-08T18:03:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构知识点整理（类C语言实现）（在更新）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ul><li>注意：类C语言使用引用传参(&amp;)，是借用C++语法中的内容，C语言实现时使用指针(*）传参，与类C代码有很大不同</li></ul> 
<h2><a id="2_4"></a>2.线性表</h2> 
<h3><a id="_6"></a>案例：稀疏多项式的运算</h3> 
<ul><li>创建一个新数组c</li><li>分别从头遍历比较a和b的每一项 
  <ul><li>指数相同：对应系数相加，若其和不为零，则在c中增加一个新项</li><li>指数不相同：则将较小项复制到c中</li></ul> </li><li>当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可</li></ul> 
<h3><a id="_14"></a>线性表的基本操作：</h3> 
<ol><li> <p>InitList(&amp;L)</p> 
  <ul><li>线性表的初始化</li><li>操作结果：构建一个空的线性表L</li></ul> </li><li> <p>DestroyList(&amp;L)</p> 
  <ul><li>初始条件：线性表L已经存在</li><li>操作结果：销毁线性表L（表本身消失）</li></ul> </li><li> <p>ClearList(&amp;L)</p> 
  <ul><li>初始条件：线性表L已经存在</li><li>操作结果：将线性表L重置为空表（表仍存在）</li></ul> </li><li> <p>ListEmpty(L)</p> 
  <ul><li>初始条件：线性表L已经存在</li><li>操作结果：若线性表为空，则返回TURE；否则返回FALSE</li></ul> </li><li> <p>ListLength(L)</p> 
  <ul><li>初始条件：线性表L已经存在</li><li>操作结果：返回线性表中元素个数</li></ul> </li><li> <p>GetElem(L,i,&amp;e)</p> 
  <ul><li>初始条件：线性表L已经存在，1&lt;=i&lt;=ListLength(L)</li><li>操作结果：用e返回线性表L中第i个元素的值</li></ul> </li><li> <p>LocateElem(L,e,compare())</p> 
  <ul><li>初始条件：线性表L已经存在，compare()是数据元素判定函数</li><li>操作结果：返回L中第一个与e满足compare()的数据元素的位序，若不存在，则返回0</li></ul> </li><li> <p>PriorElem(L,cur_e,&amp;pre_e)</p> 
  <ul><li>初始条件：线性表L已经存在</li><li>操作结果：若cur_e，是L的数据元素，且不是第一个，则用pre_e返回他的前驱，否则操作失败，pre_e无意义</li></ul> </li><li> <p>NextElem(L,cur_e,&amp;next_e)</p> 
  <ul><li> <p>初始条件：线性表L已经存在</p> </li><li> <p>操作结果：若cur_e，是L的数据元素，且不是最后一个，则用next_e返回他的前驱，否则操作失败，next_e无意义</p> </li></ul> </li><li> <p>ListInsert(&amp;L,i,e)</p> 
  <ul><li>初始条件：线性表L已经存在，i&lt;=i&lt;=ListLength(L)+1</li><li>操作结果：在L的第i个位置前插入新的元素e，L的长度加一</li></ul> </li><li> <p>ListDelete(&amp;L,i,&amp;e)</p> 
  <ul><li>初始条件：线性表L已经存在，i&lt;=i&lt;=ListLength(L)</li><li>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一</li></ul> </li><li> <p>ListTraverse(&amp;L,visited())</p> 
  <ul><li>初始条件：线性表L已经存在</li><li>操作结果：依次对线性表L中每个元素调用visited()</li></ul> </li></ol> 
<h3><a id="_77"></a>算法中用到的预定义常量和类型</h3> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">//函数结果状态代码</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TURE</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OK</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INFEASIBLE</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OVERFLOW</span> <span class="token expression"><span class="token operator">-</span><span class="token number">2</span></span></span>
<span class="token comment">//Status 是函数的类型，其值是函数结果状态代码</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">char</span> ElemType<span class="token punctuation">;</span>
</code></pre> </li></ul> 
<h3><a id="_92"></a>顺序表</h3> 
<h4><a id="1_94"></a>1.顺序表中元素存储位置的计算</h4> 
<ul><li>假设线性表的每个元素需占用i个存储单元，则第i+j个元素的存储位置和第i个元素的存储位置之间满足关系： 
  <ul><li>LOC(a(n+1))=LOC(a(n))+i</li></ul> </li></ul> 
<h4><a id="2_99"></a>2.顺序表的特点</h4> 
<ul><li>以物理位置相邻表示逻辑关系，任一元素均可随机存取</li></ul> 
<h4><a id="3_103"></a>3.顺序表</h4> 
<ol><li>地址连续</li><li>依次存放</li><li>随机存取</li><li>类型相同</li></ol> 
<h4><a id="4C_110"></a>4.顺序表的类C语言代码实现</h4> 
<ul><li> <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LIST_INIT_SIZE</span> <span class="token expression"><span class="token number">100</span></span><span class="token comment">//线性表存储空间的初始分配量</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    ElemType elem<span class="token punctuation">[</span>LIST_INIT_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//方案1：静态数组方式</span>
    ElemType <span class="token operator">*</span>elem<span class="token punctuation">;</span><span class="token comment">//方案2：动态内存分配方式</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token comment">//当前长度</span>
<span class="token punctuation">}</span>SqList<span class="token punctuation">;</span>
SqList L<span class="token punctuation">;</span><span class="token comment">//定义变量L，L是SqList这种类型的变量，L是个顺序表</span>
L<span class="token punctuation">.</span>elem<span class="token operator">=</span><span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span><span class="token operator">*</span>MAXSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//动态内存分配</span>
</code></pre> </li><li> <p>多项式的顺序存储结构类型定义</p> 
  <ul><li> <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">1000</span>  </span><span class="token comment">//多项式可能达到的最大长度</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>  <span class="token comment">//多项式非零项的定义</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">float</span> p<span class="token punctuation">;</span><span class="token comment">//系数</span>
    <span class="token keyword">int</span> e<span class="token punctuation">;</span><span class="token comment">//指数</span>
<span class="token punctuation">}</span>Polynomial<span class="token punctuation">;</span><span class="token comment">//多项式</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    Polynomial <span class="token operator">*</span>elem<span class="token punctuation">;</span><span class="token comment">//存储空间的首地址，以自定义数据类型建立的数组</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token comment">//多项式中当前项的个数</span>
<span class="token punctuation">}</span>SqList<span class="token punctuation">;</span><span class="token comment">//多项式的顺序存储结构类型为SqList</span>
</code></pre> </li></ul> </li><li> <p>图书表的顺序存储结构类型定义</p> 
  <ul><li> <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">10000</span>  </span><span class="token comment">//图书表可能达到的最大长度</span></span>
<span class="token keyword">typedef</span> stcuct  <span class="token comment">//单本图书信息定义</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> no<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//图书ISBN</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//图书名字</span>
    <span class="token keyword">float</span> price<span class="token punctuation">;</span> <span class="token comment">//图书价格</span>
<span class="token punctuation">}</span>Book<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    Book <span class="token operator">*</span>elem<span class="token punctuation">;</span> <span class="token comment">//存储空间的基地址</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">//图书表中的当前图书个数</span>
<span class="token punctuation">}</span>SqList<span class="token punctuation">;</span> <span class="token comment">//图书表的顺序存储结构为SqList</span>
</code></pre> </li></ul> </li><li> <p>操作算法中用到的预定常量和类型</p> 
  <ul><li> <pre><code class="prism language-c"><span class="token comment">//函数结果状态代码</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TURE</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OK</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INFEASIBLE</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OVERFLOW</span> <span class="token expression"><span class="token operator">-</span><span class="token number">2</span></span></span>
<span class="token comment">//Status 是函数的类型，其值的函数结果代码</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status
<span class="token keyword">typedef</span> <span class="token keyword">char</span> ElemType    
</code></pre> </li></ul> </li></ul> 
<h4><a id="5C_172"></a>5.顺序表基本操作的实现（类C语言代码）</h4> 
<h5><a id="1L_174"></a>算法1：线性表L的初始化（参数用引用）</h5> 
<pre><code class="prism language-c">Status <span class="token function">InitList_Sq</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span>		<span class="token comment">//构造一个空的顺序表L</span>
<span class="token punctuation">{<!-- --></span>
    L<span class="token punctuation">.</span>elem<span class="token operator">=</span>new ElemType<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//为顺序表分配空间，C++类型？？</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">)</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>OverFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//存储分配失败,异常处理</span>
    L<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>						<span class="token comment">//空表长度为0</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2L_187"></a>算法2：销毁线性表L</h5> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">DestroyList</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">)</span>
          delete L<span class="token punctuation">.</span>elem<span class="token punctuation">;</span>  <span class="token comment">//释放空间，C++语法，具体C语言代码实现不是这样</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="3L_197"></a>算法3：清空线性表L</h5> 
<pre><code class="prism language-c">  <span class="token keyword">void</span> <span class="token function">ClearList</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
      L<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//将线性表长度置为0</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="4_206"></a>算法4：求线性表长度</h5> 
<pre><code class="prism language-c">  <span class="token keyword">int</span> <span class="token function">GetLength</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="5L_215"></a>算法5：判断线性表L是否为空</h5> 
<pre><code class="prism language-c">  <span class="token keyword">int</span> <span class="token function">IsEmpty</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
          <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//若为空，则返回1</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="6ie_226"></a>算法6：顺序表取值（根须位置i获取相应位置数据元素的值，用e返回）</h5> 
<pre><code class="prism language-c"> Status <span class="token function">GetElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">&gt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
          <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>  <span class="token comment">//判断i值是否合理，若不合理，返回ERROR</span>
      e<span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//第i-1个单元存储着第i个数据</span>
      <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//随机存取，时间复杂度为O(1)</span>
</code></pre> 
<h5><a id="7_239"></a>算法7：顺序表的查找</h5> 
<pre><code class="prism language-c">  <span class="token comment">//在线性表L中查找与指定值e相同的数据元素的位置</span>
  <span class="token comment">//从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，则返回0</span>
  <span class="token keyword">int</span> <span class="token function">LocateElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>e<span class="token punctuation">)</span>
              <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//eg:数组a[0]的位置序号是1</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//未找到，返回0</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="8_255"></a>算法8：顺序表的插入</h5> 
<pre><code class="prism language-c"> <span class="token comment">/*算法思想：
  1.判断插入位置i是否合法(i&lt;1||i&gt;L.length+1)
  2.判断顺序表的存储空间是否已满，若已满则返回ERROR
  3.将第n至第i位的元素依次向后移动一个位置，空出第i个位置
  4.将要插入的新元素放入第i个位置
  */</span>
  Status <span class="token function">ListInsert_Sq</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">&gt;</span>L<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
          <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>   <span class="token comment">//i值不合法</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token operator">==</span>MAXSIZE<span class="token punctuation">)</span>
          <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>   <span class="token comment">//当前存储空间已满</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>L<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
          L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//插入位置及之后元素后移</span>
      L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span>  <span class="token comment">//将新元素e放入第i个位置</span>
      L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment">//表长加一</span>
      <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="9_278"></a>算法9：顺序表的删除</h5> 
<pre><code class="prism language-c">  <span class="token comment">/*算法思想：
  1.判断删除位置是否合法(1&lt;i&lt;n)
  2.将第i+1至n位的元素依次向前移动一个位置
  3.表长减一，返回OK
  */</span>
  Status <span class="token function">ListDelete_Sq</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">&gt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
          <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>   <span class="token comment">//i值不合法</span>
     <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
          L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//元素前移</span>
      L<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_296"></a>链表</h3> 
<h4><a id="1_298"></a>1.在链表中设置头结点有什么好处？</h4> 
<ol><li>便于首元结点的处理 
  <ul><li>首元结点的地址保存在头结点的指针域中，所以在链表第一个位置上的操作和其他位置一致，无需进行特殊处理</li></ul> </li><li>便于空表和非空表的统一处理 
  <ul><li>无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了</li></ul> </li></ol> 
<h4><a id="2_305"></a>2.单链表结点的定义：</h4> 
<ul><li> <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Lnode</span>
<span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">;</span> <span class="token comment">//结点的数据域</span>
    <span class="token keyword">struct</span> <span class="token class-name">Lnode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//结点的指针域</span>
<span class="token punctuation">}</span>Lnode<span class="token punctuation">,</span><span class="token operator">*</span>LinkList<span class="token punctuation">;</span> <span class="token comment">//LinkList为指向结构体Lnode的指针类型</span>
<span class="token comment">//定义一个结构体类型指针的两种方式</span>
Lnode <span class="token operator">*</span>p<span class="token punctuation">;</span>
LinkList L<span class="token punctuation">;</span>
<span class="token comment">//一般区分使用:</span>
<span class="token comment">//定义链表L</span>
LinkList L<span class="token punctuation">;</span>
<span class="token comment">//定义结点指针p:</span>
Lnode <span class="token operator">*</span>p<span class="token punctuation">;</span>
</code></pre> </li></ul> 
<h4><a id="3_323"></a>3.单链表结构的定义和表示</h4> 
<ul><li> <p>eg：存储学生学号、姓名、成绩的单链表结点类型定义</p> 
  <ul><li> <p>方式a：不常用，因为存在多个数据域</p> 
    <ul><li> <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">student</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> num<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//学号</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//姓名</span>
    <span class="token keyword">int</span> score<span class="token punctuation">;</span><span class="token comment">//成绩</span>
    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指针域</span>
<span class="token punctuation">}</span>Lnode<span class="token punctuation">,</span><span class="token operator">*</span>LinkList<span class="token punctuation">;</span>

LinkList L<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>方式b：常用，将多个数据的内容先定义成一个结构体</p> 
    <ul><li> <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> num<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//学号</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//姓名</span>
    <span class="token keyword">int</span> score<span class="token punctuation">;</span><span class="token comment">//成绩</span>
<span class="token punctuation">}</span>ElemType<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Lnode</span>
<span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Lnode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>Lnode<span class="token punctuation">,</span><span class="token operator">*</span>LinkList<span class="token punctuation">;</span>
</code></pre> </li></ul> </li></ul> </li></ul> 
<h4><a id="4C_357"></a>4.单链表基本操作的类C语言实现</h4> 
<h5><a id="1_359"></a>算法1：单链表的初始化</h5> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">/*算法步骤：
1.生成新节点作为头结点，用头指针L指向头结点
2.将头结点的指针域置空
*/</span>
Status <span class="token function">InitList_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    L<span class="token operator">=</span><span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Lnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    L<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="2_374"></a>算法2：判断链表是否为空</h5> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">//空表：链表中无元素，但头指针和头结点仍存在</span>
<span class="token comment">//算法思路：判断头结点指针域是否为空</span>
<span class="token keyword">int</span> <span class="token function">ListEmpty</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">)</span> <span class="token comment">//若为空返回1，否则返回0</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="3_388"></a>算法3：单链表的销毁，销毁后不存在</h5> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">//算法思路：从头指针开始，依次释放所有结点</span>
Status <span class="token function">DestroyList_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Lnode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        p<span class="token operator">=</span>L<span class="token punctuation">;</span>
        L<span class="token operator">=</span>L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="4_405"></a>算法4：清空单链表</h5> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">//依次释放所有结点，并将头结点指针域设置为空</span>
Status <span class="token function">ClearList_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Lnode <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token operator">*</span>q<span class="token punctuation">;</span>
    p<span class="token operator">=</span>L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
   	 	q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    	<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token operator">=</span>q<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    L<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="5_424"></a>算法5：求单链表表长</h5> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">//算法思路：从首元结点开始，依次计数所有结点</span>
<span class="token keyword">int</span> <span class="token function">ListLength_L</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Lnode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    p<span class="token operator">=</span>L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//p指向第一个结点</span>
    i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="6i_442"></a>算法6：取第i个元素的值</h5> 
<ul><li> <p>按位查找：</p> 
  <ul><li> <pre><code class="prism language-c">Status <span class="token function">GetElem_L</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    p<span class="token operator">=</span>L<span class="token operator">-</span>next<span class="token punctuation">;</span>  <span class="token comment">//p指向首元结点</span>
    j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">)</span> <span class="token comment">//向后扫描直到p指向第i个元素或p为空</span>
    <span class="token punctuation">{<!-- --></span>
        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token operator">++</span>j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">&gt;</span>i<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//第i个元素不存在</span>
    e<span class="token operator">=</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li><li> <p>按值查找：根据指定数据获取该数据所在的位置(地址或序号)</p> 
  <ul><li> <p>返回地址</p> <pre><code class="prism language-c">Lnode <span class="token operator">*</span><span class="token function">LocateElem_L</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    p<span class="token operator">=</span>L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>p<span class="token operator">-&gt;</span>data<span class="token operator">!=</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>返回序号</p> <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">LocateElem_L</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    p<span class="token operator">=</span>L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>p<span class="token operator">-&gt;</span>data<span class="token operator">!=</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token comment">//如果没找到，则p为空</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
        <span class="token keyword">return</span> j<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//查找失败返回0</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li></ul> 
<h5><a id="7ie_497"></a>算法7：插入结点（在第i个结点前插入值为e的新结点）</h5> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">ListInsert_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    p<span class="token operator">=</span>L<span class="token punctuation">;</span>
    j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//寻找第i-1个结点，p指向i-1结点</span>
    <span class="token punctuation">{<!-- --></span>
        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">&gt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>  <span class="token comment">//i大于表长+1或小于1，插入位置非法</span>
    s<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>Lnode<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Lnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//新建一个s结点（可能有问题）</span>
    s<span class="token operator">-&gt;</span>data<span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment">//生成新结点，将结点的数据域置为e</span>
    s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">//顺序不可颠倒</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="8ii_519"></a>算法8：删除第i个结点（删除第i个元素）</h5> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">ListDelete_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    p<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment">//指向头结点</span>
    j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> 
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//寻找第i-1个结点，且第i个结点不能为空</span>
    <span class="token punctuation">{<!-- --></span>
        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token operator">||</span>j<span class="token operator">&gt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//临时保存被删结点的地址以备释放</span>
    p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>q<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    e<span class="token operator">=</span>q<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span> <span class="token comment">//存放删除结点的数据</span>
    <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放删除结点的空间</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="9_541"></a>算法9：头插法建立单链表</h5> 
<ul><li> <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">CreateList_H</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment">//n 为插入的元素个数</span>
<span class="token punctuation">{<!-- --></span>
    L<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>Lnode<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Lnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//头结点</span>
    L<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token punctuation">;</span>i<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span><span class="token number">0</span>
        p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>Lnode<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Lnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//新结点</span>
        <span class="token comment">//输入元素，存在p-&gt;data;</span>
        p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        L<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token comment">//时间复杂度O(n)</span>
</code></pre> </li></ul> 
<h5><a id="10_558"></a>算法10：尾插法建立单链表</h5> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">/*
1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表尾部
2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点
*/</span>
<span class="token keyword">void</span> <span class="token function">CreateList_R</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    L<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>Lnode<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Lnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//头结点</span>
    L<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    r<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment">//尾指针指向头结点</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>Lnode<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Lnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//新结点</span>
        <span class="token comment">//输入元素，存在p-&gt;data;</span>
        p<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
        r<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>
        r<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">//尾指针指向新的尾结点</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token comment">//时间复杂度O(n)</span>
</code></pre> </li></ul> 
<h4><a id="5_581"></a>5.循环链表：头尾相接的链表（最后一个结点的指针域指向头结点，整个链表形成一个环）</h4> 
<ul><li> <p>优点：从表中任一结点出发均可找到表中其他结点</p> </li><li> <p>注意：循环链表中没有NULL指针，故涉及遍历操作时，终止条件为是否等于头指针</p> </li><li> <p>eg：带尾指针循环链表的合并（尾指针Ta和Tb）</p> 
  <ul><li> <p>操作步骤：</p> 
    <ol><li>p存Ta的表头结点：p=Ta-&gt;next</li><li>Tb表头连接到Ta表尾：Ta-&gt;next=Tb-&gt;next-&gt;next</li><li>释放Tb表头结点：free(Tb-next)</li><li>Tb指向Ta的头结点：Tb-&gt;next=p</li></ol> </li><li> <pre><code class="prism language-c">  LinkList <span class="token function">Connect</span><span class="token punctuation">(</span>LinkList Ta<span class="token punctuation">,</span>LinkList Tb<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
      p<span class="token operator">=</span>Ta<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
      Ta<span class="token operator">-&gt;</span>next<span class="token operator">=</span>Tb<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
      <span class="token function">free</span><span class="token punctuation">(</span>Tb<span class="token operator">-</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
      Tb<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>
      <span class="token keyword">return</span> Tb<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> </li></ul> </li></ul> 
<h4><a id="6prior_607"></a>6.双向链表：在单链表的每个结点里再增加一个指向其直接前驱的指针域prior</h4> 
<ul><li> <p>双向链表的结构定义：</p> 
  <ul><li> <pre><code class="prism language-c">  <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DuLnode</span>
  <span class="token punctuation">{<!-- --></span>
      ElemType data<span class="token punctuation">;</span>
      <span class="token keyword">struct</span> <span class="token class-name">DuLnode</span> <span class="token operator">*</span>prior<span class="token punctuation">,</span><span class="token operator">*</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>DuLnode<span class="token punctuation">,</span><span class="token operator">*</span>DuLinkList<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>双向链表的对称性：</p> 
  <ul><li>p-&gt;prior-&gt;next=p=p-&gt;next-&gt;prior</li></ul> </li><li> <p>双向链表中，插入、删除操作需要同时修改两个方向上的指针</p> 
  <ul><li> <p>双向链表的插入操作：</p> 
    <ul><li> <pre><code class="prism language-c">  <span class="token keyword">void</span> <span class="token function">ListInsert_DuL</span><span class="token punctuation">(</span>DuLinkList <span class="token operator">&amp;</span>L<span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span>ElemType e<span class="token punctuation">)</span> <span class="token comment">//在带头结点的双向链表L的第i个位置前插入元素e</span>
  <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p<span class="token operator">=</span><span class="token function">GetElemP_DuL</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//找到第i个元素</span>
          <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
      s<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>DuLnode<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DuLnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      s<span class="token operator">-&gt;</span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>
      s<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token operator">-&gt;</span>prior<span class="token punctuation">;</span> <span class="token comment">//将新结点的前驱改为p的前驱</span>
      p<span class="token operator">-&gt;</span>prior<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">//将p的前驱的后继改为新结点</span>
      p<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">//p的前驱改为新结点s</span>
      s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">//新结点s的后继改为p</span>
  <span class="token punctuation">}</span>
</code></pre> </li></ul> </li><li> <p>双向链表的删除：</p> 
    <ul><li> <pre><code class="prism language-c">  <span class="token keyword">void</span> <span class="token function">ListDelete_DuL</span><span class="token punctuation">(</span>DuLinkList <span class="token operator">&amp;</span>L<span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token comment">//删除第i个元素，并用e返回</span>
  <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p<span class="token operator">=</span><span class="token function">GetElemP_DuL</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//找到第i个元素</span>
          <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
      e<span class="token operator">=</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>prior<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//p的前驱的后继改为p的后继</span>
      p<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token operator">-&gt;</span>prior<span class="token punctuation">;</span> <span class="token comment">//p的后继的前驱改为p的前驱</span>
      <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> </li></ul> </li></ul> </li></ul> 
<h4><a id="7_655"></a>7.单链表、循环链表和双向链表的时间效率比较</h4> 
<ul><li> 
  <table><thead><tr><th></th><th align="center">查找首元结点</th><th align="center">查找表尾结点</th><th align="center">查找结点*p的前驱结点</th></tr></thead><tbody><tr><td>带头结点的单链表L</td><td align="center">L-&gt;next 时间复杂度O(1)</td><td align="center">从L-&gt;next依次向后遍历，时间复杂度O(n)</td><td align="center">通过p-&gt;next无法找到前驱</td></tr><tr><td>带头结点仅设头指针L的循环单链表</td><td align="center">L-&gt;next 时间复杂度O(1)</td><td align="center">从L-&gt;next依次向后遍历，时间复杂度O(n)</td><td align="center">通过p-&gt;next可以找到前驱，时间复杂度O(n)</td></tr><tr><td>带头结点仅设尾指针R的循环单链表</td><td align="center">R-&gt;next-&gt;next 时间复杂度O(1)</td><td align="center">R，时间复杂度O(1)</td><td align="center">通过p-&gt;next可以找到前驱，时间复杂度O(n)</td></tr><tr><td>带头指针的双向循环链表L</td><td align="center">L-&gt;next 时间复杂度O(1)</td><td align="center">L-&gt;prior，时间复杂度O(1)</td><td align="center">p-&gt;prior，时间复杂度O(1)顺序表和链表的比较</td></tr></tbody></table></li></ul> 
<h4><a id="8_664"></a>8常见问题：</h4> 
<ol><li> <p>为什么单链表初始化时用二级指针，而插入操作时用一级指针？</p> 
  <ul><li> <p>在初始化过程中，需要修改头指针，因此要用到二级指针传递头指针的地址，这样才能修改头指针。这与普通变量类似，当需要修改普通变量的值，需传递其地址。使用二级指针，很方便就修改了传入的结点一级指针的值。 如果用一级指针，则只能通过指针修改指针所指内容，却无法修改指针的值，也就是指针所指的内存块。</p> </li><li> <p>在使用带头结点的单链表时<br> 1、初始化链表头部指针需要用二级指针<br> 2、销毁链表需要用到二级指针<br> 3、插入、删除、遍历、清空结点用一级指针即可</p> <p>注意：<br> 如果是不带头结点的单链表，插入、删除和清空结点也需要二级指针（比如往空链表中插入一个节点时，新插入的节点就是链表的头指针，此时会改动头指针。同理，删除第一个结点和清空结点都会改动头指针）。</p> </li></ul> </li><li></ol> 
<h3><a id="_680"></a>顺序表的链表的比较</h3> 
<ul><li>链式存储结构： 
  <ul><li>优点： 
    <ul><li>节点空间可以动态申请和释放</li><li>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素</li></ul> </li><li>缺点： 
    <ul><li>存储密度小，每个结点的指针域需额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大（存储密度=结点数据所占空间/结点所占的空间总量）</li><li>链式存储结构时非随机存取结构》对任意结点的操作都要从头指针依指针链查找到该结点</li></ul> </li></ul> </li><li>空间： 
  <ul><li>存储空间： 
    <ul><li>顺序表：预先分配，会导致空闲限制或溢出</li><li>链表：动态分配，不会出现存储空间闲置或溢出</li></ul> </li><li>存储密度： 
    <ul><li>顺序表：不用为表示结点间的逻辑关系而额外增加存储开销，存储密度为1</li><li>链表：需要借助指针来体现元素间的逻辑关系，存储密度小于1</li></ul> </li></ul> </li><li>时间： 
  <ul><li>存取元素： 
    <ul><li>顺序表：随机存取，按位置访问元素时间复杂度为O(1)</li><li>链表：顺序存取，按位置访问元素时间复杂度为O(n)</li></ul> </li><li>插入、删除： 
    <ul><li>顺序表：平均移动表中一半元素，时间复杂度为O(n)</li><li>链表：不需要移动元素，确定位置后，时间复杂度为O(1)</li></ul> </li></ul> </li><li>使用情况： 
  <ul><li>顺序表： 
    <ol><li>表长变化不大，且能事先确定变化的范围</li><li>很少进行插入或删除的操作，经常按元素位置序号访问数据元素</li></ol> </li><li>链表： 
    <ol><li>长度变化很大</li><li>频繁进行插入或删除操作</li></ol> </li></ul> </li></ul> 
<h3><a id="_711"></a>线性表的应用</h3> 
<h4><a id="1_713"></a>1.线性表的合并</h4> 
<ul><li> <p>算法步骤：</p> 
  <ul><li>依次取出Lb中的每个元素，执行以下操作： 
    <ol><li>在La中查找该元素</li><li>如果找不到，则将其插入到La的最后</li></ol> </li></ul> </li><li> <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token keyword">union</span><span class="token punctuation">(</span>List <span class="token operator">&amp;</span>La<span class="token punctuation">,</span>List Lb<span class="token punctuation">)</span><span class="token comment">//仅表示思路</span>
<span class="token punctuation">{<!-- --></span>
    La_len<span class="token operator">=</span><span class="token function">ListLength</span><span class="token punctuation">(</span>La<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//求线性表La的长度</span>
    Lb_len<span class="token operator">=</span><span class="token function">ListLength</span><span class="token punctuation">(</span>Lb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Lb_len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//遍历Lb中元素</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">GetElem</span><span class="token punctuation">(</span>Lb<span class="token punctuation">,</span>i<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">LocateElem</span><span class="token punctuation">(</span>La<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//执行条件为，在La中找不到元素e</span>
            <span class="token function">ListInsert</span><span class="token punctuation">(</span>La<span class="token punctuation">,</span><span class="token operator">++</span>La_len<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//插入到第表长加一个位置</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h4><a id="2_735"></a>2.有序表的合并（顺序表）</h4> 
<ul><li> <p>已知线性表La和Lb中的数据元素非递减有序排列，现要求将两表归并为一个新的非递减有序排列</p> </li><li> <p>算法步骤：</p> 
  <ol><li>创建一个空表c</li><li>依次从La和Lb中摘取元素值较小的结点插入到Lc表的最后，直至其中一个表为空</li><li>继续将没有空的那个表的剩余结点插入到Lc表的最后</li></ol> </li><li> <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">MergeList_Sq</span><span class="token punctuation">(</span>SqList LA<span class="token punctuation">,</span>SqList LB<span class="token punctuation">,</span>SqList <span class="token operator">&amp;</span>LC<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    pa<span class="token operator">=</span>LA<span class="token punctuation">.</span>elem<span class="token punctuation">;</span>
    pb<span class="token operator">=</span>LA<span class="token punctuation">.</span>elem<span class="token punctuation">;</span><span class="token comment">//指针pa、pb分别指向两个表的第一个元素</span>
    LC<span class="token punctuation">.</span>length<span class="token operator">=</span>LA<span class="token punctuation">.</span>length<span class="token operator">+</span>LB<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    LC<span class="token punctuation">.</span>elem<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>ElemType<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>LC<span class="token punctuation">.</span>length<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elemtype<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pc<span class="token operator">=</span>LC<span class="token punctuation">.</span>elem<span class="token punctuation">;</span><span class="token comment">//</span>
    pa_last<span class="token operator">=</span>LA<span class="token punctuation">.</span>elem<span class="token operator">+</span>LA<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//指向LA表最后一个元素，用来记录是否遍历到了表尾</span>
    pb_last<span class="token operator">=</span>LB<span class="token punctuation">.</span>elem<span class="token operator">+</span>LB<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pa<span class="token operator">&lt;=</span>pa_last<span class="token operator">&amp;&amp;</span>pb<span class="token operator">&lt;=</span>pb_last<span class="token punctuation">)</span><span class="token comment">//两表都不为空时</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>pa<span class="token operator">&lt;=</span><span class="token operator">*</span>pb<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token operator">*</span>pc<span class="token operator">=</span><span class="token operator">*</span>pa<span class="token punctuation">;</span>
            pc<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//指针右移</span>
            pa<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">//或直接写成：*pc++=*pa++;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token operator">*</span>pc<span class="token operator">=</span><span class="token operator">*</span>pb<span class="token punctuation">;</span>
            pc<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//指针右移</span>
            pb<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">//或直接写成：*pc++=*pb++;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>pa<span class="token operator">&lt;=</span>pa_last<span class="token punctuation">)</span><span class="token comment">//此时LB表已遍历完,将LA中剩余元素加入LC</span>
            <span class="token operator">*</span>pc<span class="token operator">++</span><span class="token operator">=</span><span class="token operator">*</span>pa<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>pb<span class="token operator">&lt;=</span>pb_last<span class="token punctuation">)</span><span class="token comment">//此时LA表已遍历完,将LB中剩余元素加入LC</span>
            <span class="token operator">*</span>pc<span class="token operator">++</span><span class="token operator">=</span><span class="token operator">*</span>pb<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h4><a id="3_777"></a>3.有序表的合并（链表）</h4> 
<ul><li> <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">MergeList_L</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>La<span class="token punctuation">,</span>LinkList <span class="token operator">&amp;</span>Lb<span class="token punctuation">,</span>LinkList <span class="token operator">&amp;</span>Lc<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    pa<span class="token operator">=</span>La<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//pa指针指向La的首元结点</span>
    pb<span class="token operator">=</span>Lb<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    pc<span class="token operator">=</span>Lc<span class="token operator">=</span>La<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pa <span class="token operator">&amp;&amp;</span> pb<span class="token punctuation">)</span><span class="token comment">//两表都不为空时</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pa<span class="token operator">-&gt;</span>data<span class="token operator">&lt;</span>pb<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            pc<span class="token operator">-&gt;</span>next<span class="token operator">=</span>pa<span class="token punctuation">;</span><span class="token comment">//将pa接在pc之后</span>
            pc<span class="token operator">=</span>pa<span class="token punctuation">;</span><span class="token comment">//pc移动到pa</span>
            pa<span class="token operator">=</span>pa<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//pa后移</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            pc<span class="token operator">-&gt;</span>next<span class="token operator">=</span>pb<span class="token punctuation">;</span>
            pc<span class="token operator">=</span>pb<span class="token punctuation">;</span>
            pb<span class="token operator">=</span>pb<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    pc<span class="token operator">-&gt;</span>next<span class="token operator">=</span>pa<span class="token operator">?</span>pa<span class="token operator">:</span>pb<span class="token punctuation">;</span><span class="token comment">//pa不为空则指向pa</span>
    <span class="token function">free</span><span class="token punctuation">(</span>Lb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放Lb的头结点</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h3><a id="_805"></a>案例分析和实现</h3> 
<h4><a id="_807"></a>案例一：一元多项式的运算</h4> 
<ul><li>实现两个多项式加、减、乘运算</li></ul> 
<h4><a id="_811"></a>案例二：稀疏多项式的运算</h4> 
<h5><a id="_813"></a>顺序表实现</h5> 
<ul><li> <p>算法思路：</p> 
  <ol><li>创建一个新数组c</li><li>分别从头遍历比较a和b的每一项 
    <ul><li>指数相同：对应系数相加，若其和不为零，则在c中增加一个新项</li><li>指数不相同：则将较小项复制到c中</li></ul> </li><li>当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可</li></ol> </li><li> <p>问题分析：</p> 
  <ul><li>顺序存储结构存在问题： 
    <ul><li>存储空间分配不灵活</li><li>运算空间复杂度高</li></ul> </li></ul> </li><li> <p>算法实现：</p> 
  <ul><li> <pre><code class="prism language-c"></code></pre> </li></ul> </li></ul> 
<h5><a id="_834"></a>链表实现</h5> 
<ul><li> <p>算法思路：</p> 
  <ol><li>创建一个只有头结点的空链表</li><li>根据多项式的个数n，循环n次执行以下操作： 
    <ol><li>生成一个新结点s</li><li>输入多项式当前项的系数和指数赋值给新结点s的数据域</li><li>设置一个前驱指针pre，用于指向待找到的第一个大于输出项指数的结点的前驱，pre初值指向头结点</li><li>指针q初始化，指向首元结点</li><li>循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输出项的结点q</li><li>将输入项结点s插入到结点q之前</li></ol> </li></ol> </li><li> <p>算法描述：</p> 
  <ul><li> <p>多项式结点的定义：</p> 
    <ul><li> <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PNode</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">float</span> coef<span class="token punctuation">;</span><span class="token comment">//系数</span>
    <span class="token keyword">int</span> expn<span class="token punctuation">;</span><span class="token comment">//指数</span>
    <span class="token keyword">struct</span> <span class="token class-name">PNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token comment">//指针域</span>
<span class="token punctuation">}</span>PNode<span class="token punctuation">,</span><span class="token operator">*</span>polynomial<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>多项式创建：</p> 
    <ul><li> <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">Createpolyn</span><span class="token punctuation">(</span>Polynomial <span class="token operator">&amp;</span>P<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    P<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>PNode<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>PNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先建立一个带头结点的单链表</span>
    P<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        s<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>PNode<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>PNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成新结点</span>
        <span class="token comment">//输入系数和指数</span>
        pre<span class="token operator">=</span>P<span class="token punctuation">;</span><span class="token comment">//pre用于保存q的前驱，初值为头结点</span>
        q<span class="token operator">=</span>P<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//q指向首元结点</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>q <span class="token operator">&amp;&amp;</span> q<span class="token operator">-&gt;</span>expn<span class="token operator">&lt;</span>s<span class="token operator">-&gt;</span>expn<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            pre<span class="token operator">=</span>q<span class="token punctuation">;</span>
            q<span class="token operator">=</span>q<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>q<span class="token punctuation">;</span><span class="token comment">//将输入项s插入到q和其前驱结点pre之间</span>
        pre<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li><li> <p>多项式相加：</p> 
    <ul><li>算法步骤： 
      <ol><li>指针p1和p2初始化，分别指向Pa和Pb的首元结点</li><li>p3指向和多项式的当前节点，初值为Pa的头结点</li><li>当指针p1和p2均未到达相应表尾时，循环比较p1和p2所指结点对应的指数(p1-&gt;expn和p2-&gt;expn)，有三种情况 
        <ol><li>当p1-&gt;expn==p2-&gt;expn时，则将两个结点中的系数相加 
          <ol><li>若和不为零，则修改p1所对应的结点的系数值，同时删除p2所指结点</li><li>若和为零，则删除p1和p2所指结点</li></ol> </li><li>当p1-&gt;expnexpn时，则摘取p1所指结点到“和多项式”链表中</li><li>当p1-&gt;expn&gt;p2-&gt;expn时，则摘取p2所指结点到“和多项式”链表中</li></ol> </li><li>将非空多项式剩余段插入p3所指结点之后</li><li>释放Pb的头结点</li></ol> </li></ul> </li></ul> </li></ul> 
<h4><a id="_898"></a>案例三：图书信息管理</h4> 
<ul><li> <p>结构类型定义</p> 
  <ul><li> <pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">Book</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> id<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//ISBN</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//书名</span>
    <span class="token keyword">int</span> price<span class="token punctuation">;</span><span class="token comment">//定价</span>
<span class="token punctuation">}</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    Book <span class="token operator">*</span>elem<span class="token punctuation">;</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>SqList<span class="token punctuation">;</span><span class="token comment">//顺序表定义</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span>
<span class="token punctuation">{<!-- --></span>
    Book data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LNode<span class="token punctuation">,</span><span class="token operator">*</span>LinkList<span class="token punctuation">;</span><span class="token comment">//链表定义</span>
</code></pre> </li></ul> </li></ul> 
<h2><a id="3_923"></a>3.栈和队列</h2> 
<h3><a id="_925"></a>栈和队列的定义和特点</h3> 
<ul><li> <p>栈和队列是限定插入和删除只能在表的端点进行的线性表</p> </li><li> <p>栈(stack)是一个特殊的线性表，是限定在一端进行插入和删除的线性表，后进先出(Last In First Out)，简称(LIFO)</p> 
  <ul><li>栈仅在表尾（栈顶）进行插入、删除</li><li>表尾(an)称为栈顶（Top），表头(a1)称为（Base）</li><li>eg：栈 s=(a1,a2,…an);</li><li>插入到栈顶称为入栈，从栈顶删除叫出栈</li></ul> </li><li> <p>队列(queue)，是一种先进先出(First In First Out)的线性表(FIFO)，在表一端（表尾）插入，在另一端（表头）删除</p> </li></ul> 
<h4><a id="_936"></a>栈的应用</h4> 
<ul><li> <p>“先进后出，后进先出”</p> 
  <ul><li> <p>数值转换</p> </li><li> <p>表达式求值</p> </li><li> <p>括号匹配的检验</p> </li><li> <p>八皇后问题</p> </li><li> <p>行编辑程序</p> </li><li> <p>函数调用</p> </li><li> <p>迷宫求解</p> </li><li> <p>递归调用的实现</p> </li></ul> </li></ul> 
<h4><a id="_956"></a>队列的应用</h4> 
<ul><li>“先进先出，后进后出”，类似排队问题 
  <ul><li>脱机打印：按申请的先后顺序依次输出</li><li>多用户系统中，多个用户排队，分别循环使用CPU和主存</li><li>按用户的优先级排成队，每个优先级一个队列</li><li>实时控制系统，信号按接收的先后顺序依次处理</li><li>网络电文传输，按到达的时间先后顺序依次处理</li></ul> </li></ul> 
<h3><a id="_965"></a>案例引入</h3> 
<h4><a id="_967"></a>案例一：进制转换</h4> 
<h4><a id="_969"></a>案例二：括号匹配的检验</h4> 
<h4><a id="_971"></a>案例三：表达式求值</h4> 
<h4><a id="_973"></a>案例四：舞伴问题</h4> 
<h3><a id="_975"></a>栈的表示和实现</h3> 
<h4><a id="_977"></a>栈的抽象数据类型定义</h4> 
<ul><li> <pre><code class="prism language-c">ADT Stack<span class="token punctuation">{<!-- --></span>
    数据对象：
        D<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>ai<span class="token operator">|</span>ai∈ElemSet，i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    数据关系
        R1<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token operator">&lt;</span>ai<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ai<span class="token operator">&gt;</span><span class="token operator">|</span>ai<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ai∈D<span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">}</span><span class="token punctuation">;</span>
    基本操作：初始化、进栈、出栈、取栈顶元素等<span class="token punctuation">;</span>
<span class="token punctuation">}</span>ADT Stack
</code></pre> </li></ul> 
<h4><a id="_989"></a>栈的基本操作</h4> 
<ol><li>InitStack(&amp;S) 
  <ul><li>栈的初始化</li><li>操作结果：构造一个空栈S</li></ul> </li><li>DestroyStack(&amp;S) 
  <ul><li>栈的销毁</li><li>初始条件：栈S已经存在</li><li>操作结果：栈S被销毁</li></ul> </li><li>StackEmpty(S) 
  <ul><li>判定栈S是否为空栈</li><li>初始条件：栈S已经存在</li><li>操作结果：若栈S为空栈，则返回TURE；否则返回FALSE</li></ul> </li><li>StackLength(S) 
  <ul><li>求栈的长度</li><li>初始条件：栈S已经存在</li><li>操作结果：返回S的元素个数，即栈的长度</li></ul> </li><li>GetTop(S,&amp;e) 
  <ul><li>取栈顶元素</li><li>初始条件：栈S已经存在，且非空</li><li>操作结果：用e返回S的栈顶元素</li></ul> </li><li>ClearStack(&amp;S) 
  <ul><li>清空栈</li><li>初始条件：栈S已经存在</li><li>操作结果：将栈S清空</li></ul> </li><li>Push(&amp;S,e) 
  <ul><li>入栈</li><li>初始条件：栈S已经存在</li><li>操作结果：插入元素e为新的栈顶元素</li></ul> </li><li>Pop(&amp;S,&amp;e) 
  <ul><li>出栈</li><li>初始条件：栈S已经存在</li><li>操作结果：删除栈顶元素an，并用e返回其值</li></ul> </li></ol> 
<h4><a id="_1023"></a>顺序栈的表示和实现</h4> 
<h5><a id="_1025"></a>存储方式：</h5> 
<ul><li> <p>同一般线性表的顺序存储结构完全相同</p> 
  <ul><li> <p>利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，栈底一般在低地址处</p> </li><li> <p>附设top指针，指示栈顶元素在顺序栈中的位置</p> </li><li> <p>另设base指针，指示栈底元素在顺序栈中的位置</p> </li><li> <p>但是为了方便操作，通常top指示真正的栈顶元素之上的下标地址</p> </li><li> <p>另外，用stacksize表示栈可使用的最大容量</p> </li><li> <p>空栈标志：top==base</p> </li><li> <p>栈满标志：top-base==stacksize</p> 
    <ul><li>栈满时的处理方法： 
      <ol><li>报错，返回操作系统</li><li>分配更大空间作为栈的存储空间，将原栈的内容移入新栈</li></ol> </li></ul> </li><li> <p>上溢(overflow)：栈已满，还要压入元素</p> </li><li> <p>下溢(underflow)：栈已空，还要弹出元素</p> </li><li> <p>注意：上溢是一种错误，使问题无法继续执行；而下溢一般认为是一种结束条件，使问题处理结束</p> </li></ul> </li></ul> 
<h5><a id="C_1053"></a>顺序栈的表示（类C）</h5> 
<ul><li> <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    SElemType <span class="token operator">*</span>base<span class="token punctuation">;</span><span class="token comment">//栈底指针</span>
    SElemType <span class="token operator">*</span>top<span class="token punctuation">;</span><span class="token comment">//栈顶指针</span>
    <span class="token keyword">int</span> stacksize<span class="token punctuation">;</span><span class="token comment">//栈可用最大容量</span>
<span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span>
</code></pre> </li></ul> 
<h5><a id="_1065"></a>顺序栈的基本操作实现</h5> 
<h6><a id="1_1067"></a>算法1：顺序栈的初始化</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    S<span class="token punctuation">.</span>base<span class="token operator">=</span><span class="token punctuation">(</span>SElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>MAXSIZE<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SElemType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//存储分配失败</span>
    S<span class="token punctuation">.</span>top<span class="token operator">=</span>S<span class="token punctuation">.</span>base<span class="token punctuation">;</span><span class="token comment">//栈顶指针等于栈底指针</span>
    S<span class="token punctuation">.</span>stacksize<span class="token operator">=</span>MAXSIZE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="2_1081"></a>算法2：顺序栈判断是否为空</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">StackEmpty</span><span class="token punctuation">(</span>SqStack S<span class="token punctuation">)</span> <span class="token comment">//若栈为空，返回TURE;若不为空，返回FALSE</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
        <span class="token keyword">return</span> TURE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="3_1092"></a>算法3：求顺序栈长度</h6> 
<ul><li> <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">StackLength</span><span class="token punctuation">(</span>SqStack S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> S<span class="token punctuation">.</span>top<span class="token operator">-</span>S<span class="token punctuation">.</span>base<span class="token punctuation">;</span><span class="token comment">//涉及指针减指针这一特殊情况</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="4_1101"></a>算法4：清空栈</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">ClearStack</span><span class="token punctuation">(</span>SqStack S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
        S<span class="token punctuation">.</span>top<span class="token operator">=</span>S<span class="token punctuation">.</span>base<span class="token punctuation">;</span><span class="token comment">//直接将栈顶指针指向栈底指针</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="5_1112"></a>算法5：销毁栈</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">DestroyStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">free</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
        S<span class="token punctuation">.</span>stacksize<span class="token operator">=</span><span class="token number">0</span>
            <span class="token punctuation">;</span>
        S<span class="token punctuation">.</span>base<span class="token operator">=</span>S<span class="token punctuation">.</span>top<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="6_1128"></a>算法6：顺序栈的入栈</h6> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">/*
1.判断是否栈满，若满则返回上溢
2.元素e压入栈顶
3.栈顶指针加一
*/</span>
Status <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span>SElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">-</span>S<span class="token punctuation">.</span>base <span class="token operator">==</span> stacksize<span class="token punctuation">)</span>
    	<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment">//或OVERFLOW</span>
    <span class="token operator">*</span>S<span class="token punctuation">.</span>top<span class="token operator">=</span>e<span class="token punctuation">;</span>
    S<span class="token punctuation">.</span>top<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="7_1146"></a>算法7：顺序栈的出栈</h6> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">/*
1.判断是否栈空，若空则下溢
2.获取栈顶元素e
3.栈顶指针减一
*/</span>
Status <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span>SElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
    	<span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    <span class="token operator">--</span>S<span class="token punctuation">.</span>top<span class="token punctuation">;</span>
    e<span class="token operator">=</span><span class="token operator">*</span>S<span class="token punctuation">.</span>top<span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h4><a id="_1164"></a>链栈的表示和实现</h4> 
<h5><a id="_1166"></a>链栈的表示</h5> 
<ul><li> <p>链栈是操作受限的单链表，只能在链表头部进行操作</p> </li><li> <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">StackNode</span>
<span class="token punctuation">{<!-- --></span>
    SElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">StackNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>StackNode<span class="token punctuation">,</span><span class="token operator">*</span>LinkStack<span class="token punctuation">;</span>

LinkNode S<span class="token punctuation">;</span><span class="token comment">//</span>
</code></pre> </li><li> <p>链表的头指针就是栈顶</p> </li><li> <p>不需要头结点</p> </li><li> <p>基本不存在栈满的情况</p> </li><li> <p>空栈相当于头指针指向空</p> </li><li> <p>插入和删除仅在栈顶处执行</p> </li></ul> 
<h5><a id="_1190"></a>链栈的基本操作实现</h5> 
<h6><a id="1_1192"></a>算法1：链栈的初始化</h6> 
<ul><li> <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>LinkStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//构建一个空栈，栈顶指针置空</span>
    S<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="2_1203"></a>算法2：判断链栈是否为空</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">StackEmpty</span><span class="token punctuation">(</span>LinkStack S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> TURE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="3_1214"></a>算法3：链栈的入栈</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">StackPush</span><span class="token punctuation">(</span>LinkStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span>SElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    p<span class="token operator">=</span><span class="token punctuation">(</span>StackNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>StackNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成新结点</span>
    p<span class="token operator">-&gt;</span>data<span class="token operator">=</span>e<span class="token punctuation">;</span><span class="token comment">//将新结点数据域置为e</span>
    p<span class="token operator">-</span>next<span class="token operator">=</span>S<span class="token punctuation">;</span><span class="token comment">//将新结点插入栈顶</span>
    S<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token comment">//修改栈顶指针</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="4_1227"></a>算法4：链栈的出栈</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">StackPop</span><span class="token punctuation">(</span>LinkStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span>SElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    e<span class="token operator">=</span>S<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    p<span class="token operator">=</span>S<span class="token punctuation">;</span><span class="token comment">//新建一个结点存放要释放的栈顶结点</span>
    S<span class="token operator">=</span>S<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//栈顶指针下移</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放要删除的结点</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="5_1242"></a>算法5：取栈顶元素</h6> 
<ul><li> <pre><code class="prism language-c">SElemType <span class="token function">GetTop</span><span class="token punctuation">(</span>LinkStack S<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> S<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h3><a id="_1252"></a>栈和递归</h3> 
<h4><a id="_1254"></a>递归的定义</h4> 
<ul><li>若一个对象部分的包含他自己，或用他自己给自己定义，则称这个对象是递归的</li><li>若一个过程之间或间接地调用自己，则称这个过程是递归的过程 
  <ul><li>ed：递归求n的阶乘</li></ul> </li></ul> 
<h4><a id="_1260"></a>常用递归方法的情况</h4> 
<ol><li>递归定义的数学函数 
  <ol><li>阶乘函数</li><li>斐波那契数列</li></ol> </li><li>具有递归特性的数据结构 
  <ol><li>二叉树</li><li>广义表</li></ol> </li><li>可递归求解的问题 
  <ol><li>迷宫问题</li><li>汉诺塔问题</li></ol> </li></ol> 
<h4><a id="_1272"></a>递归问题</h4> 
<ul><li>用分治法求解 
  <ul><li>分治法：对于一个较复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解</li></ul> </li><li>必备的三个条件： 
  <ol><li>能够将一个问题转变成一个新问题，且新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是有变化规律的</li><li>可以通过上述转化使问题简化</li><li>必须有一个明确的递归出口，或称为递归的边界</li></ol> </li></ul> 
<h4><a id="_1281"></a>函数调用过程</h4> 
<ul><li>调用前，系统完成： 
  <ol><li>将实参、返回地址等传递给被调用函数</li><li>为被调函数的局部变量分配存储区域</li><li>将控制转移到被调函数的入口</li></ol> </li><li>调用后，系统完成： 
  <ol><li>保存被调函数的计算结果</li><li>释放被调函数的数据区</li><li>依照被调函数保存的返回地址将控制转移到被调函数</li></ol> </li></ul> 
<h3><a id="_1292"></a>队列的表示和实现</h3> 
<h4><a id="_1294"></a>队列的抽象数据类型：</h4> 
<ul><li> <pre><code class="prism language-c"></code></pre> </li></ul> 
<h4><a id="_1299"></a>顺序队列的基本操作实现</h4> 
<h5><a id="_1301"></a>队列的顺序表示</h5> 
<ul><li> <p>用一维数组base[MAXSIZE]</p> </li><li> <p>循环队列的结构</p> 
  <ul><li> <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">100</span></span><span class="token comment">//最大队列长度</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
	QElemType <span class="token operator">*</span>base<span class="token punctuation">;</span><span class="token comment">//初始化动态分配存储空间</span>
    <span class="token keyword">int</span> front<span class="token punctuation">;</span><span class="token comment">//头指针（实际是队头元素下标）</span>
    <span class="token keyword">int</span> rear<span class="token punctuation">;</span><span class="token comment">//尾指针（实际是队尾元素下标）</span>
<span class="token punctuation">}</span>SqQueue<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>初始:</p> 
  <ul><li> <pre><code class="prism language-c">cfront<span class="token operator">=</span>rear<span class="token operator">=</span><span class="token number">0</span>
</code></pre> </li></ul> </li><li> <p>入队</p> 
  <ul><li> <pre><code class="prism language-c">base<span class="token punctuation">[</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>
rear<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>出队</p> 
  <ul><li> <pre><code class="prism language-c">x<span class="token operator">=</span>base<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
front<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token comment">//空队标志</span>
front<span class="token operator">==</span>rear<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>真溢出</p> 
  <ul><li> <pre><code class="prism language-c">front<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
rear<span class="token operator">=</span>MAXSIZE<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>假溢出</p> 
  <ul><li> <pre><code class="prism language-c">front<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">;</span>
rear<span class="token operator">=</span>MAXSIZE<span class="token punctuation">;</span>
</code></pre> </li></ul> </li></ul> 
<h5><a id="_1353"></a>解决假上溢的方法</h5> 
<ol><li> <p>将队中元素依次向队头方向移动</p> 
  <ul><li>缺点：浪费时间，每移动一次，队中元素都要移动</li></ul> </li><li> <p>将队空间想象成一个循环的表，即分配给队列的m个存储单元可以循环使用，当rear为MAXSIZE时，若向量的开始端空着，则又可以开始从头使用空着的空间，当front为MAXSIZE时，也是一样</p> 
  <ul><li> <p>引入循环队列：base[0]接在base[MAXSIZE-1]之后，若rear+1==M，则令rear=0;</p> 
    <ul><li> <p>实现方法：利用模运算</p> </li><li> <p>插入元素：</p> 
      <ul><li> <pre><code class="prism language-c">Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>
Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>删除元素：</p> 
      <ul><li> <pre><code class="prism language-c">x<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
Q<span class="token punctuation">.</span>front<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>循环队列队空队满标志冲突</p> 
      <ul><li>front==rear</li><li>解决方案： 
        <ol><li>另外设一个标志以区别队空队满</li><li>另设一个变量，记录元素个数</li><li>少用一个元素空间（采用） 
          <ul><li>队空：front==rear</li><li>队满：（rear+1）%MAXSIZE==front</li></ul> </li></ol> </li></ul> </li></ul> </li></ul> </li></ol> 
<h5><a id="_1390"></a>循环队列的操作</h5> 
<h6><a id="1_1392"></a>算法1：队列的初始化</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">InitQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Q<span class="token punctuation">.</span>base<span class="token operator">=</span><span class="token punctuation">(</span>QElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>MAXSIZE<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>QElemType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配数组空间</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//存储分配失败</span>
    Q<span class="token punctuation">.</span>front<span class="token operator">=</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//头指针尾指针都置为零，队列为空</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="2_1405"></a>算法2：求队列长度</h6> 
<ul><li> <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">QueueLength</span><span class="token punctuation">(</span>SqQueue Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span>MAXSIZE<span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token punctuation">;</span><span class="token comment">//解决了循环队列中尾指针到头指针前面的情况</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="3_1414"></a>算法3：循环队列入队</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">EnQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>QElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token operator">==</span>front<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment">//判断队满</span>
    Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span><span class="token comment">//新元素加入队尾</span>
    Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="4_1427"></a>算法4：循环队列出队</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">OutQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>QElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">==</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment">//判断队空</span>
    e<span class="token operator">=</span>Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//保存队头元素</span>
    Q<span class="token punctuation">.</span>front<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token punctuation">;</span><span class="token comment">//队头指针加一（但不会超过MAXSIZE-1）</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="5_1440"></a>算法5：取队头元素</h6> 
<ul><li> <pre><code class="prism language-c">SElemType <span class="token function">GetHead</span><span class="token punctuation">(</span>SqQueue Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">==</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    <span class="token keyword">return</span> Q<span class="token punctuation">.</span>base<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//返回队头元素的值，队头指针不动</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h4><a id="_1451"></a>链式队列的表示和实现</h4> 
<ul><li>若用户无法估计所用队列的长度，则采用链队列</li></ul> 
<h5><a id="_1455"></a>链队列的类型定义</h5> 
<ul><li> <pre><code class="prism language-c">tepedef <span class="token keyword">struct</span> <span class="token class-name">QNode</span>
<span class="token punctuation">{<!-- --></span>
    QElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">QNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>QNode<span class="token punctuation">,</span><span class="token operator">*</span>QueuePtr<span class="token punctuation">;</span><span class="token comment">//链队列结点，链队列指针</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    QueuePtr front<span class="token punctuation">;</span><span class="token comment">//队头指针</span>
    QueuePtr rear<span class="token punctuation">;</span><span class="token comment">//队尾指针</span>
<span class="token punctuation">}</span>LinkQueue<span class="token punctuation">;</span><span class="token comment">//链队列</span>
</code></pre> </li></ul> 
<h5><a id="_1470"></a>链队列的基本操作</h5> 
<h6><a id="1_1472"></a>算法1：链队列初始化</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">InitQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Q<span class="token punctuation">.</span>front<span class="token operator">=</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>QNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>QNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//队头指针置空</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="2_1485"></a>算法2：销毁链队列</h6> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">//从队头结点开始依次释放所有结点</span>
Status <span class="token function">DestroyQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        p<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//存放下一个结点，否则直接删除Q.front会找不到下一结点</span>
        <span class="token function">free</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Q<span class="token punctuation">.</span>front<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token comment">//移动队头结点</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="3_1501"></a>算法3：链队列的入队</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">EnQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>QElemType e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    p<span class="token operator">=</span><span class="token punctuation">(</span>QNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>QNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    Q<span class="token punctuation">.</span>rear<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>
    Q<span class="token punctuation">.</span>rear<span class="token operator">=</span>p<span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="4_1519"></a>算法4：链队列的出队</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">DeQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>QElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment">//判断队空</span>
    p<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    e<span class="token operator">=</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> p<span class="token punctuation">)</span><span class="token comment">//如果链队列中元素个数为零了，还需要修改尾指针</span>
        Q<span class="token punctuation">.</span>rear<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="5_1536"></a>算法5：求链队列的队头元素</h6> 
<ul><li> <pre><code class="prism language-c">Status <span class="token function">GetHead</span><span class="token punctuation">(</span>LinkQueue Q<span class="token punctuation">,</span>QElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment">//判断队空</span>
    e<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h2><a id="4_1548"></a>4.串、数组和广义表</h2> 
<h3><a id="_1550"></a>串</h3> 
<h4><a id="_1552"></a>串的定义：</h4> 
<ul><li>零个或多个任意字符组成的有限序列</li><li>eg：S=“abcdefg” (n&gt;=0) 
  <ul><li>S为串名</li><li>abcdefg为串值</li><li>n为串长；若n为零，则称为空串</li></ul> </li><li>几个术语： 
  <ul><li>空格串：是只包含空格的串，可以有一个或多个空格 
    <ul><li>注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格</li></ul> </li><li>子串与主串：串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串 
    <ul><li>真字串：不包含自身的所有子串</li></ul> </li><li>字符位置：字符在序列中的序号为该字符在串中的位置</li><li>子串位置：子串的第一个字符在主串中的序号</li><li>串相等：当且仅当两个串的长度相等且对应位置上的字符都相同时，这两个串才相等 
    <ul><li>所有的空串都相等</li></ul> </li></ul> </li></ul> 
<h4><a id="_1569"></a>案例引入</h4> 
<ul><li>案例一：病毒感染检测 
  <ul><li>案例实现： 
    <ul><li>对于每一个待检测的任务，假设病毒DNA序列的长度是m，因为病毒DNA序列是环状的，为了线性取到每个可行的长度为m的字符串，可将存储病毒DNA序列的字符串长度扩大到2m，将病毒DNA序列连续存储两次</li><li>然后循环m次，依次取得每个长度为m的环状字符串，将此字符作为模式串，将人的DNA序列作为主串，调用BF算法进行模式匹配</li><li>只要匹配成功，即可终止循环，表明该人感染了病毒；否则，循环m次结束后，可通过BF算法的返回值判断该人是否感染了对应的病毒</li></ul> </li></ul> </li></ul> 
<h4><a id="_1579"></a>串的抽象数据类型定义</h4> 
<ul><li> <pre><code class="prism language-c">ADT String
<span class="token punctuation">{<!-- --></span>
    数据对象：D<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>ai<span class="token operator">|</span>ai∈CharacterSet<span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">}</span>
    数据关系：
    基本操作：
        <span class="token number">1.</span><span class="token function">StrAssign</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span>chars<span class="token punctuation">)</span><span class="token comment">//串赋值</span>
        <span class="token number">2.</span><span class="token function">StrCompare</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token comment">//串比较</span>
        <span class="token number">3.</span><span class="token function">StrLength</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token comment">//求串长</span>
        <span class="token number">4.</span><span class="token function">Concat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span>S1<span class="token punctuation">,</span>S2<span class="token punctuation">)</span><span class="token comment">//串连结</span>
        <span class="token number">5.</span><span class="token function">SubString</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Sub<span class="token punctuation">,</span>pos<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token comment">//求子串</span>
        <span class="token number">6.</span><span class="token function">StrCopy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token comment">//串拷贝</span>
        <span class="token number">7.</span><span class="token function">StrEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token comment">//串判空</span>
        <span class="token number">8.</span><span class="token function">ClearString</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token comment">//清空串</span>
        <span class="token number">9.</span><span class="token function">lndex</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>T<span class="token punctuation">,</span>pos<span class="token punctuation">)</span><span class="token comment">//子串的位置</span>
        <span class="token number">10.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>T<span class="token punctuation">,</span>V<span class="token punctuation">)</span><span class="token comment">//串替换</span>
        <span class="token number">11.</span><span class="token function">StrInsert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>pos<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token comment">//子串插入</span>
        <span class="token number">12.</span><span class="token function">StrDelete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>pos<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token comment">//子串删除</span>
        <span class="token number">13.</span><span class="token function">DestroyString</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token comment">//串销毁</span>
<span class="token punctuation">}</span>ADT String
</code></pre> </li></ul> 
<h4><a id="_1603"></a>顺序串</h4> 
<h5><a id="_1605"></a>顺序串的存储结构</h5> 
<ul><li> <p>用的更多，因为字符串操作很少需要插入删除</p> </li><li> <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">255</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> ch<span class="token punctuation">[</span>MAXSIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存储串的一维数组，下标为0的位置闲置（在某些算法中会带来简便），从下标为1的位置开始存放</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token comment">//串的当前长度</span>
<span class="token punctuation">}</span>SString<span class="token punctuation">;</span><span class="token comment">//第一个S表示“顺序”</span>
</code></pre> </li></ul> 
<h4><a id="_1618"></a>链串</h4> 
<h5><a id="_1620"></a>链串的存储结构—块链结构</h5> 
<ul><li> <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CHUNKSIZE</span> <span class="token expression"><span class="token number">80</span> </span><span class="token comment">//块的大小由用户定义</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Chunk</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> ch<span class="token punctuation">[</span>CHUNKSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Chunk</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>Chunk<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    Chunk <span class="token operator">*</span>head<span class="token punctuation">,</span><span class="token operator">*</span>tail<span class="token punctuation">;</span> <span class="token comment">//串的头指针和尾指针</span>
    <span class="token keyword">int</span> curlen<span class="token punctuation">;</span> <span class="token comment">//串的当前长度</span>
<span class="token punctuation">}</span>LString<span class="token punctuation">;</span> <span class="token comment">//字符串的块链结构</span>
</code></pre> 
  <ul><li>优点：操作方便</li><li>缺点：存储密度较低</li><li>可以将多个字符存放在一个结点内，以克服存储密度较低的缺点</li></ul> </li></ul> 
<h4><a id="BFKMP_1640"></a>串的模式匹配算法（BF和KMP)</h4> 
<ul><li> <p>算法目的：</p> 
  <ul><li>确定主串中所含子串第一个出现的位置（定位）</li></ul> </li><li> <p>算法应用：</p> 
  <ul><li>搜索引擎、拼写检查、语言翻译、数据压缩</li></ul> </li><li> <p>算法种类：</p> 
  <ul><li> <p>BF算法（Brute-Force，又称古典的、经典的、朴素的、穷举的）</p> 
    <ul><li> <p>又称简单匹配算法，采用穷举的思路</p> </li><li> <p>算法思路：从S（主串：正文串）的每一个字符开始依次与T（子串：模式）的字符进行匹配</p> 
      <ul><li>lndex(S,T,pos) 
        <ul><li>将主串的第pos个字符与模式串的第一个字符比较 
          <ul><li>若相等，继续逐个比较后续字符</li><li>若不相等，从主串下一个字符起，重新与模式串的第一个字符比较</li></ul> </li><li>直到主串的一个连续子串字符序列与模式串相等，返回值为S与T中匹配的子序列第一个字符的序号，即匹配成功</li><li>否则，匹配失败，返回0</li></ul> </li></ul> </li><li> <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">lndex_BF</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span>SString T<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>S<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//比较成功时，主串和子串依次匹配下一个字符</span>
           <span class="token punctuation">{<!-- --></span>
               <span class="token operator">++</span>i<span class="token punctuation">;</span>
               <span class="token operator">++</span>j<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token comment">//主串、子串指针回溯，重新开始下一次匹配      </span>
        <span class="token punctuation">{<!-- --></span>
            i<span class="token operator">=</span>i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//i-(j-1)+1</span>
            j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        <span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token comment">//返回匹配的第一个字符下标</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//未匹配成功</span>
<span class="token punctuation">}</span>	
</code></pre> </li><li> <p>BF算法的时间复杂度：</p> 
      <ul><li>若主串长度为n，子串长度为n，最坏情况下：主串前面n-m个位置都匹配到了子串的最后一位，即n-m个位置各比较了m次，最后m位也各比较了1次 
        <ul><li>总次数为：(n-m)*m+m</li><li>若m&lt;&lt;n，则算法的时间复杂度为Q(n*m)</li></ul> </li></ul> </li></ul> </li><li> <p>KMP算法（特点：速度快）</p> 
    <ul><li> <p>较BF算法有较大改进，主串S的指针i不再回溯，可提速至O(m+n)</p> </li><li> <p>需要定义next[j]函数，表明当模式中第i个字符与主串中相应字符不匹配时，在模式中需重新和主串中该字符进行比较的字符位置</p> 
      <ul><li>next[j] = 
        <ul><li> <p>max{ k | 1&lt;k&lt;j ,且 p1p2p3p4…pk-1 = pj-k-1…pj-1}</p> </li><li> <p>0 当j=1时</p> </li><li> <p>1 其他情况</p> </li></ul> </li></ul> </li><li> <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">lndex_KMP</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span>SString T<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>S<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//比较成功时，主串和子串依次匹配下一个字符</span>
           <span class="token punctuation">{<!-- --></span>
               <span class="token operator">++</span>i<span class="token punctuation">;</span>
               <span class="token operator">++</span>j<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token comment">//主串、子串指针回溯，重新开始下一次匹配      </span>
        <span class="token punctuation">{<!-- --></span>
            j<span class="token operator">=</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        <span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token comment">//返回匹配的第一个字符下标</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//未匹配成功</span>
<span class="token punctuation">}</span>	
<span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span>SString T<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>T<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token operator">++</span>i<span class="token punctuation">;</span>
            <span class="token operator">++</span>j<span class="token punctuation">;</span>
            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
            j<span class="token operator">=</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li></ul> </li></ul> 
<h3><a id="_1748"></a>数组</h3> 
<ul><li> <p>结论：线性表结构是数组元素的一个特例，而数组结构又是线性表结构的拓展</p> </li><li> <p>数组特点：结构固定，定义后维数和维界不再改变</p> </li><li> <p>数组基本操作：</p> 
  <ul><li>除了结构的初始化和销毁之外，只有去元素和修改元素值的操作</li></ul> </li></ul> 
<h4><a id="n_1758"></a>n维数组的抽象数据类型</h4> 
<ul><li> <pre><code class="prism language-c">ADT Array
<span class="token punctuation">{<!-- --></span>
    数据对象：
    数据关系：
    基本操作：
        <span class="token number">1.</span><span class="token function">InitArray</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">,</span>n<span class="token punctuation">,</span>bound1<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>boundn<span class="token punctuation">)</span> <span class="token comment">//构建数组A</span>
        <span class="token number">2.</span><span class="token function">DestroyArray</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">)</span> <span class="token comment">//销毁数组A</span>
        <span class="token number">3.</span><span class="token function">Value</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">,</span>index1<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>indexn<span class="token punctuation">)</span> <span class="token comment">//去数组元素值</span>
        <span class="token number">4.</span><span class="token function">Assign</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">,</span>index1<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>indexn<span class="token punctuation">)</span> <span class="token comment">//给数组元素赋值</span>
<span class="token punctuation">}</span>ADT Array
</code></pre> </li></ul> 
<h4><a id="_1773"></a>数组的顺序存储</h4> 
<ul><li>一般都采用顺序存储结构来表示数组</li><li>数组可以是多维的，但存储数据元素的内存单元地址的一维的，因此在存储数据结构之前，需要解决多维关系映射到一维关系的问题</li><li>二维数组两种顺序存储方式： 
  <ul><li>以行序为主序（低下标优先）：BASIC、COBOL、PASCAL、Java、C 
    <ul><li><code>数组元素a[i][j]的存储位置是:LOC(i,j)=LOC(0,0)+(n*i+j)*L</code></li></ul> </li><li>以行序为主序（高下标优先）：FORTRAN</li></ul> </li></ul> 
<h4><a id="_1782"></a>特殊矩阵的压缩存储</h4> 
<ul><li>不适宜常规存储的矩阵：值相同的元素且呈某种规律分布；零元素多</li><li>矩阵的压缩存储：为多个相同的非零元素只分配一个存储空间；对零元素不分配空间</li><li>什么样的矩阵能压缩存储： 
  <ul><li>对称矩阵 
    <ul><li>特点：a(ij)=a(ji) (沿对角线对称)</li><li>存储方法：只存储下三角（或上三角）（包括主对角线）的元素。共占用n(n+1)/2个元素空间</li><li>存储结构：以行序为主序将元素存在一个一维数组sa[n(n+1)/2]中</li></ul> </li><li>对角矩阵 
    <ul><li>特点：在n×n的方阵中，所有元素都集中在以主对角线为中心的带状区域中，区域外的值全为0 
      <ul><li>常见的有：三对角矩阵、五对角矩阵。七对角矩阵</li><li>存储方法：以对角线的顺序存储</li></ul> </li></ul> </li><li>三角矩阵 
    <ul><li>特点：对角线以上（或以下）的数据元素（不包括对角线）全部为常数C</li><li>存储方法：重复元素共享一个存储空间，共占用n(n+1)/2+1个元素空间</li><li>存储结构：以行序为主序将元素存在一个一维数组sa[n(n+1)/2+1]中</li><li>下三角矩阵的元素位序k= 
      <ul><li>i*(i-1)/2+j i&gt;=j（对角线及下半区）</li><li>n(n+1)/2+1 i&lt;j（上半区）</li></ul> </li><li>上三角矩阵的元素位序k= 
      <ul><li>(i-1)*(2n-i)/2+j-i+1 i&lt;=j (对角线及上半区） ***未推导</li><li>n(n+1)/2+1 i&lt;j（下半区）</li></ul> </li></ul> </li><li>稀疏矩阵：矩阵中非零元素少于百分之五 
    <ul><li>方法一：三元组顺序表（又称有序的双下标法） 
      <ul><li>压缩存储原则：存各非零元的值，行列位置和矩阵的行列数</li><li>注意：为更可靠描述，通常再加一个总体信息，即总行数、总列数、总元素数</li><li>优点：非零元在表中按行序有序储存，因此便于进行依行顺序处理的矩阵运算</li><li>缺点：不能随机存取，若按行号存取某一行中的非零元，则需从头开始查找</li></ul> </li><li>方法二：十字链表 
      <ul><li>优点：能够灵活地插入因运算产生的的非零元素，删除运算产生的新零元素</li><li>在十字链表中，矩阵的每一个非零元素用一个结点表示，该结点除了（行，列，数值），还要有两个域： 
        <ul><li>right：用于链接同一行的下一个非零元素</li><li>down：用于链接同一列的下一个非零元素</li></ul> </li></ul> </li></ul> </li></ul> </li></ul> 
<h3><a id="_1817"></a>广义表</h3> 
<h4><a id="_1819"></a>广义表的定义</h4> 
<ul><li>广义表（又称列表Lists），是n&gt;=0个元素a0,a1,a2,…,an-1的有限序列，其中每个元素是一个原子或一个广义表</li><li>广义表通常记为 LS=(a1,a2,a3,…,an) 
  <ul><li>LS为表名，n为长度，每一个ai为表的元素</li><li>表头：若LS非空，则第一个元素a1为表头 
    <ul><li>记作：head(LS)=a1 (注意：表头可以是原子，也可以是子表)</li></ul> </li><li>表尾：除表头的其他元素组成的表 
    <ul><li>记作：tail(LS)=(a2,a3,…,an) (注意：表尾不是最后一个元素，而是一个子表)</li></ul> </li></ul> </li></ul> 
<h4><a id="_1829"></a>广义表的性质</h4> 
<ul><li>广义表中的数据元素有相对次序，一个直接前驱和一个直接后继</li><li>广义表的长度定义为最外层所包含元素的个数</li><li>广义表的深度定义为该广义表展开后所包含的括号重数 
  <ul><li>注：原子的深度为0，空表的深度为1</li></ul> </li><li>广义表可以和其他广义表共享</li><li>广义表可以是一个递归的表</li><li>广义表是一个多层次的结构，广义表的元素可以是单元素、也可以是子表，子表的元素还可以是子表</li></ul> 
<h4><a id="_1839"></a>广义表和线性表的区别</h4> 
<ul><li>广义表可以看成是线性表的推广，线性表是广义表的特例</li></ul> 
<h4><a id="_1843"></a>广义表的运算</h4> 
<ul><li>求表头运算GetHead(L)：非空广义表的第一个元素可以是一个原子，也可以是一个子表</li><li>求表尾运算GetTail(L)：非空广义表除去表头元素以外其他元素所构成的表，表尾一定是一个表</li></ul> 
<h2><a id="5_1848"></a>5.树和二叉树</h2> 
<h3><a id="_1850"></a>树和二叉树的定义</h3> 
<h4><a id="_1852"></a>树的定义</h4> 
<ul><li>树是(Tree)n(n&gt;=0)个结点的有限集（树的定义是一个递归的定义） 
  <ul><li>若n=0，称为空树</li><li>n&gt;0，则它满足两个条件： 
    <ol><li>有且仅有一个特定的称为根(Root)的结点</li><li>其余结点可分为m个互不相交的有限集T1,T2,T3…,Tm,其中每个集合本身又是一棵树，并称为根的子树(SubTree)</li></ol> </li></ul> </li></ul> 
<h4><a id="_1860"></a>树的基本术语</h4> 
<ul><li>根结点：非空树中无直接前驱的结点</li><li>结点的度：结点拥有的子树数</li><li>树的度：树内各结点的度的最大值</li><li>叶子结点（终端结点）：度为零的结点</li><li>分支结点/非终端结点：度！=0的结点</li><li>内部节点：根节点之外的分支节点</li><li>结点的子树的根称为该结点的<strong>孩子</strong>，该结点称为孩子的<strong>双亲</strong></li><li>兄弟结点：有共同双亲的结点</li><li>堂兄弟结点：双亲在同一层的结点</li><li>结点的祖先：从根到该节点所经分支上的任一结点</li><li>结点的子孙：以该结点为根的子树中的任一结点</li><li>树的深度：树中结点的最大层次</li><li>有序树：树中结点的各子树从左至右有次序（最左边为第一个孩子）</li><li>无序树：树中结点的各子树无次序</li><li>森林：m(m&gt;=0)棵互不相交的树的集合 
  <ul><li>把树的结点删除，树就变成了森林</li><li>给森林中的各子树加上一个双亲结点，森林就变成了树</li><li>一棵树可以看作是一个特殊的森林</li><li>树一定是森林，森林不一定是树</li></ul> </li></ul> 
<h4><a id="_1883"></a>二叉树的定义</h4> 
<ul><li> <p>二叉树是n(n&gt;=0)个结点的有限集，它由空集或由一个根结点及两颗互不相交的分别称为左子树和右子树的二叉树组成</p> 
  <ul><li>特点： 
    <ol><li>每个结点最多有两个孩子（二叉树中不存在在度大于2的结点）</li><li>子树有左右之分，次序不能颠倒</li><li>二叉树可以是空集，根可以有空的左子树或空的右子树</li></ol> </li><li>注意：二叉树不是树的特殊情况，它们是两个概念 
    <ul><li>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要说明它是左子树还是右子树</li><li>树当结点只有一个孩子是，无须区分它是左是右</li><li>ed：具有三个结点的二叉树有5种不同形态，普通树则只有两种不同形态</li></ul> </li></ul> </li><li> <p>为什么要重点研究二叉树？</p> 
  <ul><li>普通树若不转化为二叉树，则运算很难实现</li><li>二叉树结构最简单，规律性最强</li><li>所有的树都可以转化成唯一对应的二叉树，不失一般性</li></ul> </li></ul> 
<h3><a id="_1900"></a>案例引入</h3> 
<h4><a id="_1902"></a>案例一：数据压缩问题</h4> 
<ul><li>将数据文件转换成由0、1组成的二进制编码</li></ul> 
<h4><a id="_1906"></a>案例二：利用二叉树求解表达式的值</h4> 
<ul><li></ul> 
<h3><a id="_1910"></a>树和二叉树的抽象数据类型定义</h3> 
<h4><a id="_1912"></a>二叉树的抽象数据类型定义</h4> 
<ul><li> <pre><code class="prism language-c">ADT BinaryTree
<span class="token punctuation">{<!-- --></span>
    数据对象：D是具有相同特性的数据元素的集合
    数据关系：若D<span class="token operator">=</span>Ø，则R<span class="token operator">=</span>Ø<span class="token punctuation">;</span>
        	 若D<span class="token operator">!=</span>Ø<span class="token punctuation">,</span>则R<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>H<span class="token punctuation">}</span><span class="token punctuation">;</span>H是如下二元关系：
                 <span class="token number">1.</span><span class="token comment">//关于树的说明</span>
                 <span class="token number">2.</span><span class="token comment">//关于子树不相交的说明</span>
                 <span class="token number">3.</span><span class="token comment">//关于数据元素的说明</span>
                 <span class="token number">4.</span><span class="token comment">//关于左子树和右子树的说明</span>
    基本操作P：  
             <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span>definition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立二叉树</span>
    		<span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先序遍历</span>
    		<span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//中序遍历</span>
    		<span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//后序遍历</span>
    		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>ADT BinaryTree
</code></pre> </li></ul> 
<h3><a id="_1933"></a>二叉树的性质和存储结构</h3> 
<h4><a id="123_1935"></a>二叉树的性质（1，2，3）</h4> 
<ol><li>在二叉树的第i层上至多有2的i-1次方个结点（第1层：2的0次方；第2层：2的1次方）</li><li>深度为k的结点至多有2的k次方减1个结点（等比数列），至少有k个结点</li><li>对任何一颗二叉树T，如果其叶子节点为n0,度为2的结点个数为n2，则n0=n2+1 （？？？）</li></ol> 
<h4><a id="_1941"></a>两种特殊的二叉树</h4> 
<h5><a id="_1943"></a>满二叉树</h5> 
<ul><li>定义：一棵深度为k，且有2的k次方减1个结点的二叉树</li><li>特点： 
  <ol><li>每一层上的结点数都是最大结点数</li><li>叶子结点全部在最底层</li></ol> </li><li>对满二叉树结点位置进行编号： 
  <ul><li>编号规则：从根节点开始，自上而下，自左至右</li><li>每一个结点位置都有元素</li></ul> </li><li>满二叉树在同样深度的二叉树中结点个数最多，叶子结点个数也最多</li></ul> 
<h5><a id="_1954"></a>完全二叉树</h5> 
<ul><li>深度为k的具有n个结点的二叉树，当且仅当其每个结点都与深度为k的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树</li><li>注：在满二叉树中，从最后一个结点开始，<em>连续</em>去掉任意个结点，得到的就是一棵完全二叉树</li><li>特点： 
  <ol><li>叶子结点只可能分布在层次最大的两层上</li><li>对任一结点，如果其右子树的最大层次为i，则其左子树最大层次必为i或i-1</li></ol> </li><li>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</li></ul> 
<h4><a id="45_1963"></a>完全二叉树的性质（4，5）</h4> 
<ol start="4"><li>具有n个结点的完全二叉树的深度为：（不大于logn的最大整数+1）</li><li>完全二叉树中双亲结点编号与孩子结点的编号之间的关系，如果对一棵有n个结点的完全二叉树的结点按层序编号，则对任一结点： 
  <ol><li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点：（不大于i/2的 最大整数)</li><li>如果2i&gt;n，则结点i是叶子结点，无左孩子；否则，其左孩子是结点：2i</li><li>如果2i+1&gt;n，则结点i无右孩子；否则，其右孩子是结点2i+1</li></ol> </li></ol> 
<h4><a id="_1971"></a>二叉树的顺序存储</h4> 
<ul><li> <p>实现：按二叉树的结点层次编号，依次存放二叉树中的数据元素</p> 
  <ul><li> <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> TElemType SqBiTree<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
SqBiTree bt<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>二叉树顺序存储缺点：</p> 
  <ul><li>最坏情况：深度为k且只有k个结点的单支树，需要2的k次方减1的一维数组</li></ul> </li><li> <p>特点：结点关系蕴含在其存储位置中，浪费空间，适合满二叉树和完全二叉树</p> </li></ul> 
<h4><a id="_1987"></a>二叉树的链式存储结构</h4> 
<h5><a id="1__1989"></a>1. 二叉链表</h5> 
<ul><li> <p>二叉链表中空指针域的数量（假设n个结点）</p> 
  <ul><li>具有n个结点的二叉链表中，一共有2n个指针域；n个结点一共有n-1个孩子，即有n-1个指针用来指向结点的左右孩子，其余n+1个指针域为空</li></ul> </li><li> <pre><code class="prism language-c"><span class="token comment">//二叉链表</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiNode</span>
<span class="token punctuation">{<!-- --></span>
    TElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">BiNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token comment">//左右孩子指针</span>
<span class="token punctuation">}</span>BiNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree0
</code></pre> </li></ul> 
<h5><a id="2_2003"></a>2.三叉链表</h5> 
<ul><li> <pre><code class="prism language-c"><span class="token comment">//三叉链表</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TriTNode</span>
<span class="token punctuation">{<!-- --></span>
    TElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TriTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>parent <span class="token operator">*</span>rchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>TriTNode<span class="token punctuation">,</span><span class="token operator">*</span>TriTree<span class="token punctuation">;</span>
</code></pre> </li></ul> 
<h3><a id="_2014"></a>遍历二叉树和线索二叉树</h3> 
<h4><a id="_2016"></a>遍历的定义：</h4> 
<ul><li>顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅访问一次</li></ul> 
<h4><a id="_2020"></a>遍历的目的：</h4> 
<ul><li>得到树中所有结点的一个线性排列</li></ul> 
<h4><a id="_2024"></a>遍历的用途：</h4> 
<ul><li>树结构的插入、删除、修改、查找和排序的前提，是二叉树一切运算的基础和核心</li></ul> 
<h4><a id="_2028"></a>遍历二叉树算法描述：</h4> 
<ul><li>根结点（D）</li><li>左子树（L）</li><li>右子树（R）</li></ul> 
<h5><a id="1DLR_2034"></a>1.DLR—先序遍历</h5> 
<ul><li> <p>若二叉树为空，则空操作；否则：</p> 
  <ol><li>访问根节点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol> </li><li> <p>先序遍历算法(递归实现)</p> 
  <ul><li> <pre><code class="prism language-c">Status <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token comment">//空二叉树</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问根节点，可以是输出或其他操作</span>
    <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归遍历左子树</span>
    <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归遍历右子树</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li></ul> 
<h5><a id="2LDR_2054"></a>2.LDR—中序遍历</h5> 
<ul><li> <p>若二叉树为空，则空操作；否则：</p> 
  <ol><li>中序遍历左子树</li><li>访问根节点</li><li>中序遍历右子树</li></ol> </li><li> <p>中序遍历算法(递归实现)</p> 
  <ul><li> <pre><code class="prism language-c">Status <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token comment">//空二叉树</span>
    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归遍历左子树</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问根节点，可以是输出或其他操作</span>
    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归遍历右子树</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li><li> <p>中序遍历算法（非递归算法)</p> 
  <ul><li> <p>基本思想：</p> 
    <ol><li>建立一个栈</li><li>根结点进栈，遍历左子树</li><li>根结点出栈，输出根结点，遍历右子树</li></ol> </li><li> <pre><code class="prism language-c">Status <span class="token function">InorderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BiTree p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">=</span>T<span class="token punctuation">;</span><span class="token comment">//p指向根结点</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//树不为空，或栈不为空，终止条件为树和栈都空</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token comment">//根结点不为空</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根结点入栈</span>
            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span><span class="token comment">//指针指向左子树根结点，开始遍历左子树</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span><span class="token comment">//根结点为空</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根结点出栈</span>
            <span class="token function">visit</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问根结点</span>
            p<span class="token operator">=</span>q<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span><span class="token comment">//指针指向右子树根结点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li></ul> 
<h5><a id="3LRD_2106"></a>3.LRD—后序遍历</h5> 
<ul><li> <p>若二叉树为空，则空操作；否则：</p> 
  <ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根节点</li></ol> </li><li> <p>后序遍历算法(递归实现)</p> 
  <ul><li> <pre><code class="prism language-c">Status <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token comment">//空二叉树</span>
    <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归遍历左子树</span>
    <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归遍历右子树</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问根节点，可以是输出或其他操作</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li></ul> 
<h5><a id="4_2126"></a>4.层次遍历</h5> 
<ul><li> <p>对于一棵二叉树，从根节点开始，从上到下，从左到右的顺序访问每一个结点，且每个结点仅访问一次</p> </li><li> <p>算法设计思路：</p> 
  <ol><li>将根结点入队</li><li>队不空时循环：从队列中出列一个结点*p，访问它： 
    <ol><li>若它有左孩子结点，将左孩子结点入队</li><li>若它有右孩子结点，将右孩子入队</li></ol> </li></ol> </li><li> <pre><code class="prism language-c"><span class="token comment">//队列类型定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    BTNode data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> front<span class="token punctuation">,</span>rear<span class="token punctuation">;</span>
<span class="token punctuation">}</span>SqQueue<span class="token punctuation">;</span>
<span class="token comment">//层次遍历算法</span>
<span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BTNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    SqQueue <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token function">InitQueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化队列</span>
    <span class="token function">enQueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根结点指针入队</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>qu<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">deQueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根结点出队</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token function">enQueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//有左孩子时将其入队</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token function">enQueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//有右孩子时将其入队</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="5_2163"></a>5.二叉树的建立（按先序序列建立）</h5> 
<ul><li> <p>步骤：</p> 
  <ol><li>键盘输入二叉树的结点信息，建立二叉树的存储结构</li><li>在建立二叉树的过程中按照二叉树先序的方式建立</li></ol> </li><li> <pre><code class="prism language-c">Status <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>BiTree <span class="token operator">&amp;</span>T<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">"#"</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        T<span class="token operator">=</span><span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
        T<span class="token operator">-&gt;</span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span>
        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建左子树</span>
        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建右子树</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="6_2191"></a>6.复制二叉树</h5> 
<ul><li> <p>如果是空树，递归结束；否则：</p> 
  <ul><li>申请新结点空间</li><li>复制根结点</li><li>递归复制左子树</li><li>递归复制右子树</li></ul> </li><li> <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">Copy</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span>BiTree <span class="token operator">&amp;</span>NewT<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        NewT<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        NewT<span class="token operator">=</span><span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        NewT<span class="token operator">-&gt;</span>data<span class="token operator">=</span>T<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
        <span class="token function">Copy</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">,</span>NewT<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Copy</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">,</span>NewT<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="7_2219"></a>7.计算二叉树的深度</h5> 
<ul><li> <p>算法思想：</p> 
  <ul><li>如果是空树，则深度为零</li><li>否则，递归计算左子树的深度m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大值加一</li></ul> </li><li> <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">Depth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    m<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//遍历左子树</span>
    n<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//遍历右子树</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">&gt;</span>n<span class="token punctuation">)</span>
        <span class="token keyword">return</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="8_2239"></a>8.计算二叉树结点总数</h5> 
<ul><li> <p>算法思想：</p> 
  <ul><li>如果是空树，则结点个数为零</li><li>否则，结点个数为：左子树结点个数+右子树结点个数+1</li></ul> </li><li> <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">NodeCount</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//加一加的是作为当前根结点的结点</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="9_2255"></a>9.计算二叉树叶子结点总数</h6> 
<ul><li> <p>算法思想：</p> 
  <ul><li>如果是空树，则叶子结点个数为0</li><li>否则，叶子结点总数为：左子树叶子结点个数+右子树叶子结点个数</li></ul> </li><li> <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">LeafCount</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token operator">==</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> T<span class="token operator">-&gt;</span>rchild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//是叶子节点</span>
    <span class="token keyword">return</span> <span class="token function">LeafCount</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">LeafCount</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不是叶子节点，则分别统计左右子树叶子结点个数</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h4><a id="_2273"></a>根据遍历序列确定二叉树</h4> 
<ul><li>若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的。由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以唯一确定一棵二叉树（但由先序序列和后序序列不可以） 
  <ol><li>先序和中序 
    <ul><li>由先序确定根，由中序确定左右子树</li></ul> </li><li>后序和中序 
    <ul><li>由后序确定根，由中序确定左右子树</li><li>后序遍历，根结点必在后序序列尾部</li></ul> </li></ol> </li></ul> 
<h4><a id="_2282"></a>线索二叉树</h4> 
<ul><li> <p>为什么要研究线索二叉树？</p> 
  <ul><li>当使用二叉链表作为二叉树的存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，无法直接找到该结点在某种遍历序列中的前驱和后继结点</li></ul> </li><li> <p>如何寻找特定遍历序列中二叉树结点的前驱和后继？</p> 
  <ul><li>解决方法： 
    <ol><li>通过遍历寻找（费时间）</li><li>再增设前驱、后继指针域（费空间）（增加了存储负担）</li><li>利用二叉链表中的空指针域： 
      <ul><li>如果某个结点左孩子为空，则将空的左孩子域改为指向其前驱；</li><li>如果某个结点右孩子为空，则将空的右孩子域改为指向其后继；</li><li>注：这种改变指向的指针称为“线索”，这种加了线索的二叉树称为<strong>线索二叉树</strong>，对二叉树某种遍历次序使其变为线索二叉树的过程叫<strong>线索化</strong></li><li>为区分lchild和rchild 指针到底是指向孩子的指针，还是指向前驱和后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定： 
        <ul><li>ltag=0：lchild指向该结点的左孩子</li><li>ltag=1：lchild指向该结点的前驱</li><li>rtag=0：rchild指向该结点的右孩子</li><li>rtag=1：rhild指向该结点的后继</li></ul> </li></ul> </li></ol> </li></ul> </li><li> <p>线索二叉树结点结构：</p> 
  <ul><li> <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ltag<span class="token punctuation">,</span>rtag<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>BiThrNode<span class="token punctuation">,</span><span class="token operator">*</span>BiThrTree<span class="token punctuation">;</span>
</code></pre> </li><li> <p>为避免悬空态，增设了一个头结点</p> 
    <ul><li>ltag=0，lchild指向根结点</li><li>rtag=1，rchild指向遍历序列的最后一个结点</li><li>遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点</li></ul> </li></ul> </li></ul> 
<h3><a id="_2320"></a>树和森林</h3> 
<h4><a id="1_2322"></a>1.树的存储结构</h4> 
<ol><li> <p>双亲表示法</p> 
  <ul><li> <p>实现：</p> 
    <ul><li>定义数组，存放树的结点，每个结点含两个域： 
      <ul><li>数据域：存放结点本身信息</li><li>双亲域：指示本结点的双亲结点在数组中的位置</li></ul> </li></ul> </li><li> <p>特点：找双亲容易，找孩子难</p> </li><li> <p>结点结构类型：</p> 
    <ul><li> <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PTNode</span>
<span class="token punctuation">{<!-- --></span>
    TElemType data<span class="token punctuation">;</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">;</span><span class="token comment">//双亲位置域（数组下标）</span>
<span class="token punctuation">}</span>PTNode<span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>树结构：</p> 
    <ul><li> <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_TREE_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{<!-- --></span>
    PTNode nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">,</span>n<span class="token punctuation">;</span><span class="token comment">//根结点位置，结点个数</span>
<span class="token punctuation">}</span>PTree<span class="token punctuation">;</span>
</code></pre> </li></ul> </li></ul> </li><li> <p>孩子链表</p> 
  <ul><li>把每个结点的孩子结点排列起来，看成一共线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表），而n个头指针又组成一共线性表，用顺序表（含n个元素的结构数组）存储</li></ul> </li></ol> 
<h3><a id="_2359"></a>哈夫曼树及其应用</h3> 
<h3><a id="_2361"></a>案例分析与实现</h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f52b0d6cccd427c7496acd40f5606be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用css画勾和叉</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67a180c259d9c64f2d47b96e76d9ecbd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Markdown常用语法及常见问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>