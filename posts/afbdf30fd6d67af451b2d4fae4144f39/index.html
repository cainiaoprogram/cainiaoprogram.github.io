<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>部署基于docker和cri-dockerd的Kubernetes v1.25.3 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="部署基于docker和cri-dockerd的Kubernetes v1.25.3" />
<meta property="og:description" content="目录
设定时钟同步 主机名称解析
禁用Swap设备
禁用默认的防火墙服务
安装程序包
安装cri-dockerd
安装kubelet、kubeadm和kubectl
安装kubelet、kubeadm和kubectl
整合kubelet和cri-dockerd
配置cri-dockerd
配置kubelet
初始化第一个主节点
初始化方式一
初始化方式二 初始化完成后的操作步骤 介绍
设定kubectl
部署网络插件
验证master节点已经就绪
添加节点到集群中
验证节点添加结果
测试应用编排及服务访问 相关命令 列：拉nginx
使用kubeadm部署Kubernetes集群的前提条件
支持Kubernetes运行的Linux主机，例如Debian、RedHat及其变体等
每主机2GB以上的内存，以及2颗以上的CPU各主机间能够通过网络无障碍通信独占的hostname、MAC地址以及product_uuid，主机名能够正常解析放行由Kubernetes使用到的各端口，或直接禁用iptables禁用各主机的上的Swap设备各主机时间同步 设定时钟同步 若节点可直接访问互联网，安装chrony程序包后，可直接启动chronyd系统服务，并设定其随系统引导而启动。随后，chronyd服务即能够从默认的时间服务器同步时间。
~# apt install chrony
~# systemctl start chrony.service 建议用户配置使用本地的的时间服务器，在节点数量众多时尤其如此。存在可用的本地时间服务器时，修改节点的/etc/chrony/chrony.conf配置文件，并将时间服务器指向相应的主机即可，配置格式如下
server CHRONY-SERVER-NAME-OR-IP iburst
主机名称解析 出于简化配置步骤的目的，本测试环境使用hosts文件进行各节点名称解析，文件内容如下所示。其中，我们使用kubeapi主机名作为API Server在高可用环境中的专用接入名称，也为控制平面的高可用配置留下便于配置的余地。 10.0.0.101 k8s-master01 k8s-master01.wang.org kubeapi.wang.org kubeapi 10.0.0.102 k8s-master02 k8s-master02.wang.org 10.0.0.103 k8s-master03 k8s-master03.wang.org 10.0.0.104 k8s-node01 k8s-node01.wang.org 10.0.0.105 k8s-node02 k8s-node02.wang.org 10.0.0.106 k8s-node03 k8s-node03.wang.org 禁用Swap设备 部署集群时，kubeadm默认会预先检查当前主机是否禁用了Swap设备，并在未禁用时强制终止部署过程。因此，在主机内存资源充裕的条件下，需要禁用所有的Swap设备，否则，就需要在后文的kubeadm init及kubeadm join命令执行时额外使用相关的选项忽略检查错误。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/afbdf30fd6d67af451b2d4fae4144f39/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-09T22:32:28+08:00" />
<meta property="article:modified_time" content="2022-11-09T22:32:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">部署基于docker和cri-dockerd的Kubernetes v1.25.3</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%AE%BE%E5%AE%9A%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5%20%C2%A0-toc" style="margin-left:80px;"><a href="#%E8%AE%BE%E5%AE%9A%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5%20%C2%A0" rel="nofollow">设定时钟同步  </a></p> 
<p id="%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90-toc" style="margin-left:80px;"><a href="#%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90" rel="nofollow">主机名称解析</a></p> 
<p id="%E7%A6%81%E7%94%A8Swap%E8%AE%BE%E5%A4%87-toc" style="margin-left:80px;"><a href="#%E7%A6%81%E7%94%A8Swap%E8%AE%BE%E5%A4%87" rel="nofollow">禁用Swap设备</a></p> 
<p id="%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99%E6%9C%8D%E5%8A%A1" rel="nofollow">禁用默认的防火墙服务</a></p> 
<p id="%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%E5%8C%85-toc" style="margin-left:80px;"><a href="#%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%E5%8C%85" rel="nofollow">安装程序包</a></p> 
<p id="%E5%AE%89%E8%A3%85cri-dockerd-toc" style="margin-left:80px;"><a href="#%E5%AE%89%E8%A3%85cri-dockerd" rel="nofollow">安装cri-dockerd</a></p> 
<p id="%E5%AE%89%E8%A3%85kubelet%E3%80%81kubeadm%E5%92%8Ckubectl-toc" style="margin-left:80px;"><a href="#%E5%AE%89%E8%A3%85kubelet%E3%80%81kubeadm%E5%92%8Ckubectl" rel="nofollow">安装kubelet、kubeadm和kubectl</a></p> 
<p id="%C2%A0%E5%AE%89%E8%A3%85kubelet%E3%80%81kubeadm%E5%92%8Ckubectl-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%AE%89%E8%A3%85kubelet%E3%80%81kubeadm%E5%92%8Ckubectl" rel="nofollow"> 安装kubelet、kubeadm和kubectl</a></p> 
<p id="%E6%95%B4%E5%90%88kubelet%E5%92%8Ccri-dockerd-toc" style="margin-left:40px;"><a href="#%E6%95%B4%E5%90%88kubelet%E5%92%8Ccri-dockerd" rel="nofollow">整合kubelet和cri-dockerd</a></p> 
<p id="%E9%85%8D%E7%BD%AEcri-dockerd-toc" style="margin-left:80px;"><a href="#%E9%85%8D%E7%BD%AEcri-dockerd" rel="nofollow">配置cri-dockerd</a></p> 
<p id="%E9%85%8D%E7%BD%AEkubelet-toc" style="margin-left:80px;"><a href="#%E9%85%8D%E7%BD%AEkubelet" rel="nofollow">配置kubelet</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%BB%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%BB%E8%8A%82%E7%82%B9" rel="nofollow">初始化第一个主节点</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B8%80-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B8%80" rel="nofollow">初始化方式一</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E4%BA%8C%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E4%BA%8C%C2%A0" rel="nofollow">初始化方式二 </a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%C2%A0%20%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%C2%A0%20%E4%BB%8B%E7%BB%8D" rel="nofollow">初始化完成后的操作步骤  介绍</a></p> 
<p id="%E8%AE%BE%E5%AE%9Akubectl-toc" style="margin-left:80px;"><a href="#%E8%AE%BE%E5%AE%9Akubectl" rel="nofollow">设定kubectl</a></p> 
<p id="%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6" rel="nofollow">部署网络插件</a></p> 
<p id="%E9%AA%8C%E8%AF%81master%E8%8A%82%E7%82%B9%E5%B7%B2%E7%BB%8F%E5%B0%B1%E7%BB%AA-toc" style="margin-left:80px;"><a href="#%E9%AA%8C%E8%AF%81master%E8%8A%82%E7%82%B9%E5%B7%B2%E7%BB%8F%E5%B0%B1%E7%BB%AA" rel="nofollow">验证master节点已经就绪</a></p> 
<p id="%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%88%B0%E9%9B%86%E7%BE%A4%E4%B8%AD-toc" style="margin-left:80px;"><a href="#%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%88%B0%E9%9B%86%E7%BE%A4%E4%B8%AD" rel="nofollow">添加节点到集群中</a></p> 
<p id="%E9%AA%8C%E8%AF%81%E8%8A%82%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%9C-toc" style="margin-left:80px;"><a href="#%E9%AA%8C%E8%AF%81%E8%8A%82%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%9C" rel="nofollow">验证节点添加结果</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E5%8F%8A%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E5%8F%8A%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%C2%A0" rel="nofollow">测试应用编排及服务访问 </a></p> 
<p id="%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%20%E5%88%97%EF%BC%9A%E6%8B%89nginx-toc" style="margin-left:80px;"><a href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%20%E5%88%97%EF%BC%9A%E6%8B%89nginx" rel="nofollow">相关命令 列：拉nginx</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>使用kubeadm部署Kubernetes集群的前提条件</p> 
<p>支持Kubernetes运行的Linux主机，例如Debian、RedHat及其变体等</p> 
<ul><li>每主机2GB以上的内存，以及2颗以上的CPU</li><li>各主机间能够通过网络无障碍通信</li><li>独占的hostname、MAC地址以及product_uuid，主机名能够正常解析</li><li>放行由Kubernetes使用到的各端口，或直接禁用iptables</li><li>禁用各主机的上的Swap设备</li><li>各主机时间同步 </li></ul> 
<p><img alt="" height="274" src="https://images2.imgbox.com/59/1d/wuTNcJeR_o.png" width="611"></p> 
<p></p> 
<h4 id="%E8%AE%BE%E5%AE%9A%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5%20%C2%A0">设定时钟同步  </h4> 
<p>若节点可直接访问互联网，安装chrony程序包后，可直接启动chronyd系统服务，并设定其随系统引导而启动。随后，chronyd服务即能够从默认的时间服务器同步时间。</p> 
<p> ~# apt install chrony</p> 
<p> ~# systemctl start chrony.service  </p> 
<p>建议用户配置使用本地的的时间服务器，在节点数量众多时尤其如此。存在可用的本地时间服务器时，修改节点的/etc/chrony/chrony.conf配置文件，并将时间服务器指向相应的主机即可，配置格式如下</p> 
<blockquote> 
 <p>server CHRONY-SERVER-NAME-OR-IP iburst</p> 
</blockquote> 
<h4 id="%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90">主机名称解析</h4> 
<p>出于简化配置步骤的目的，本测试环境使用hosts文件进行各节点名称解析，文件内容如下所示。其中，我们使用kubeapi主机名作为API Server在高可用环境中的专用接入名称，也为控制平面的高可用配置留下便于配置的余地。 </p> 
<pre><code>10.0.0.101 k8s-master01 k8s-master01.wang.org kubeapi.wang.org kubeapi
10.0.0.102 k8s-master02 k8s-master02.wang.org
10.0.0.103 k8s-master03 k8s-master03.wang.org
10.0.0.104 k8s-node01 k8s-node01.wang.org
10.0.0.105 k8s-node02 k8s-node02.wang.org
10.0.0.106 k8s-node03 k8s-node03.wang.org
</code></pre> 
<h4 id="%E7%A6%81%E7%94%A8Swap%E8%AE%BE%E5%A4%87">禁用Swap设备</h4> 
<p>部署集群时，kubeadm默认会预先检查当前主机是否禁用了Swap设备，并在未禁用时强制终止部署过程。因此，在主机内存资源充裕的条件下，需要禁用所有的Swap设备，否则，就需要在后文的kubeadm init及kubeadm join命令执行时额外使用相关的选项忽略检查错误。</p> 
<p>关闭Swap设备，需要分两步完成。首先是关闭当前已启用的所有Swap设备：</p> 
<blockquote> 
 <p>root@k8s-master01 ~]# sed -r -i '/\/swap/s@^@#@' /etc/fstab</p> 
 <p>~# swapoff -a</p> 
</blockquote> 
<p>而后编辑/etc/fstab配置文件，注释用于挂载Swap设备的所有行。另外，在Ubuntu 2004及之后版本的系统上，若要彻底禁用Swap，可以需要类似如下命令进一步完成。</p> 
<blockquote> 
 <p>~# systemctl --type swap</p> 
</blockquote> 
<p>而后，将上面命令列出的每个设备，使用systemctl mask命令加以禁用。</p> 
<blockquote> 
 <p>~# systemctl mask SWAP_DEV</p> 
</blockquote> 
<p>若确需在节点上使用Swap设备，也可选择让kubeam忽略Swap设备的相关设定。我们编辑kubelet的配置文件/etc/default/kubelet，设置其忽略Swap启用的状态错误即可，文件内容如下：</p> 
<blockquote> 
 <p>KUBELET_EXTRA_ARGS="--fail-swap-on=false"</p> 
</blockquote> 
<h4 id="%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99%E6%9C%8D%E5%8A%A1">禁用默认的防火墙服务</h4> 
<p>Ubuntu和Debian等Linux发行版默认使用ufw（Uncomplicated FireWall）作为前端来简化 iptables的使用，处于启用状态时，它默认会生成一些规则以加强系统安全。出于降低配置复杂度之目的，本文选择直接将其禁用。</p> 
<blockquote> 
 <p>~# ufw disable      #禁用</p> 
 <p>~# ufw status        #查看</p> 
</blockquote> 
<h4>安装并启动docker</h4> 
<p>首先，生成docker-ce相关程序包的仓库，这里以阿里云的镜像服务器为例进行说明：所有机器</p> 
<blockquote> 
 <p> ~# apt update</p> 
 <p>#安装必要的一些系统工具</p> 
 <p>~# apt -y install apt-transport-https ca-certificates curl software-properties-common</p> 
 <p>#安装GPG证书</p> 
 <p> ~# curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -</p> 
 <p> #写入软件源信息</p> 
 <p> ~# add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</p> 
</blockquote> 
<p>接着，安装相关的程序包，Ubuntu 20.04上要使用的程序包名称为docker-ce：</p> 
<blockquote> 
 <p> ~# apt install docker-ce -y</p> 
</blockquote> 
<p>kubelet需要让docker容器引擎使用systemd作为CGroup的驱动，其默认值为cgroupfs，因而，我们还需要编辑docker的配置文件/etc/docker/daemon.json，添加如下内容，其中的registry-mirrors用于指明使用的镜像加速服务。</p> 
<pre><code>{
"registry-mirrors": [                        #加速服务
  "https://docker.mirrors.ustc.edu.cn",
  "https://hub-mirror.c.163.com",
  "https://reg-mirror.qiniu.com",
  "https://registry.docker-cn.com"
],
"exec-opts": ["native.cgroupdriver=systemd"],     #官方建议指定
"log-driver": "json-file",                         #JSON格式以方便后面erk收集
"log-opts": {
  "max-size": "200m"
},
"storage-driver": "overlay2"                      #存储驱动
}   </code></pre> 
<ul><li>提示：自Kubernetes v1.22版本开始，未明确设置kubelet的cgroup driver时，则默认即会将其设置为systemd。</li></ul> 
<p>配置完成后即可启动docker服务，并将其设置为随系统启动而自动引导：</p> 
<blockquote> 
 <p> ~# systemctl daemon-reload</p> 
 <p> ~# systemctl start docker.service</p> 
 <p> ~# systemctl enable docker.service</p> 
 <p> ~# docker version</p> 
 <p>  Client: Docker Engine - Community   Version:           20.10.21</p> 
 <p>#注：kubeadm部署Kubernetes集群的过程中，默认使用Google的Registry服务k8s.gcr.io上的镜像,由于2022年仓库已经改为registry.k8s.io，国内可以直接访问，所以现在不需要镜像加速或者绿色上网就可以拉镜像了，如果使用国内镜像请参考https://blog.51cto.com/dayu/5811307</p> 
</blockquote> 
<h4 id="%E5%AE%89%E8%A3%85cri-dockerd">安装cri-dockerd</h4> 
<p>注意是每个节点都要安装</p> 
<p>Kubernetes自v1.24移除了对docker-shim的支持，而Docker Engine默认又不支持CRI规范，因而二者将无法直接完成整合。为此，Mirantis和Docker联合创建了cri-dockerd项目，用于为Docker Engine提供一个能够支持到CRI规范的垫片，从而能够让Kubernetes基于CRI控制Docker 。</p> 
<blockquote> 
 <p>项目地址：https://github.com/Mirantis/cri-dockerd     命令下载不下来可以手动</p> 
 <p>[root@ubuntu2004 ~]#lsb_release -rc    查看当前时候版本<br> Release:    20.04<br> Codename:    focal<br><img alt="" height="853" src="https://images2.imgbox.com/34/98/9svorbQp_o.png" width="1200"><img alt="" height="727" src="https://images2.imgbox.com/d3/d8/W1BAr3Xf_o.png" width="1200"></p> 
</blockquote> 
<p>cri-dockerd项目提供了预制的二制格式的程序包，用户按需下载相应的系统和对应平台的版本即可完成安装，这里以Ubuntu 2004 64bits系统环境，以及cri-dockerd目前最新的程序版本v0.2.6为例。</p> 
<blockquote> 
 <p>~# curl -LO https://github.com/Mirantis/cri-dockerd/releases/download/v0.2.6/cri-dockerd_0.2.6.3-0-0.ubuntu-focal_amd64.deb</p> 
 <p>~# apt install ./cri-dockerd_0.2.6.3-0.ubuntu-focal_amd64.deb</p> 
 <p>dpkg -i cri-dockerd_0.2.6.3-0.ubuntu-focal_amd64.deb</p> 
</blockquote> 
<p>完成安装后，相应的服务cri-dockerd.service便会自动启动。</p> 
<h4 id="%E5%AE%89%E8%A3%85kubelet%E3%80%81kubeadm%E5%92%8Ckubectl">安装kubelet、kubeadm和kubectl</h4> 
<p>首先，在各主机上生成kubelet和kubeadm等相关程序包的仓库，这里以阿里云的镜像服务为例：</p> 
<p> <a href="https://mirrors.huaweicloud.com/home" rel="nofollow" title="华为开源镜像站_软件开发服务_华为云 (huaweicloud.com)">华为开源镜像站_软件开发服务_华为云 (huaweicloud.com)</a></p> 
<p>配置个华为加速</p> 
<blockquote> 
 <p>cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.list <br> deb https://repo.huaweicloud.com/kubernetes/apt/ kubernetes-xenial main<br> EOF</p> 
</blockquote> 
<h4 id="%C2%A0%E5%AE%89%E8%A3%85kubelet%E3%80%81kubeadm%E5%92%8Ckubectl"> 安装kubelet、kubeadm和kubectl</h4> 
<p>首先，在各主机上生成kubelet和kubeadm等相关程序包的仓库，这里以阿里云的镜像服务为例：</p> 
<pre><code>~# apt update &amp;&amp; apt install -y apt-transport-https curl

 ~# curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -

  ~# cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list

deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main

EOF

 ~# apt update</code></pre> 
<p>接着，在各主机安装kubelet、kubeadm和kubectl等程序包，并将其设置为随系统启动而自动引导：</p> 
<blockquote> 
 <p> ~# apt install -y kubelet kubeadm kubectl</p> 
 <p>#注意：先不要启动，只是设置开机自启动</p> 
 <p> ~# systemctl enable kubelet</p> 
 <p>#确定kubeadm等程序文件的版本</p> 
 <p> ~#  [root@k8s-master01 ~]# kubeadm version  </p> 
 <p>kubeadm version: &amp;version.Info{Major:"1", Minor:"25", GitVersion:"v1.25.3",</p> 
</blockquote> 
<p>安装完成后，要确保kubeadm等程序文件的版本，这将也是后面初始化Kubernetes集群时需要明确指定的版本号。</p> 
<p></p> 
<h3 id="%E6%95%B4%E5%90%88kubelet%E5%92%8Ccri-dockerd">整合kubelet和cri-dockerd</h3> 
<h4 id="%E9%85%8D%E7%BD%AEcri-dockerd">配置cri-dockerd</h4> 
<p>配置cri-dockerd，确保其能够正确加载到CNI插件。编辑/usr/lib/systemd/system/cri-docker.service文件，确保其[Service]配置段中的ExecStart的值类似如下内容。</p> 
<pre><code>#所有节点执行：
 ​
[root@k8s-master01 ~]# vim /usr/lib/systemd/system/cri-docker.service

ExecStart=/usr/bin/cri-dockerd --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.8 --container-runtime-endpoint fd:// --network-plugin=cni --cni-bin-dir=/opt/cni/bin --cni-cache-dir=/var/lib/cni/cache --cni-conf-dir=/etc/cni/net.d
</code></pre> 
<p>需要添加的各配置参数（各参数的值要与系统部署的CNI插件的实际路径相对应）：</p> 
<ul><li> <p>--network-plugin：指定网络插件规范的类型，这里要使用CNI；</p> </li><li> <p>--cni-bin-dir：指定CNI插件二进制程序文件的搜索目录；</p> </li><li> <p>--cni-cache-dir：CNI插件使用的缓存目录；</p> </li><li> <p>--cni-conf-dir：CNI插件加载配置文件的目录；</p> </li></ul> 
<p>配置完成后，重载并重启cri-docker.service服务。</p> 
<blockquote> 
 <p>~# systemctl daemon-reload &amp;&amp; systemctl restart cri-docker.service</p> 
 <p>~# systemctl status cri-docker</p> 
</blockquote> 
<h4 id="%E9%85%8D%E7%BD%AEkubelet">配置kubelet</h4> 
<p>配置kubelet，为其指定cri-dockerd在本地打开的Unix Sock文件的路径，该路径一般默认为“/run/cri-dockerd.sock“。编辑文件/etc/sysconfig/kubelet，为其添加 如下指定参数。</p> 
<blockquote> 
 <p>提示：若/etc/sysconfig目录不存在，则需要先创建该目录。</p> 
</blockquote> 
<pre><code>#所有节点执行：
mkdir /etc/sysconfig

vim /etc/sysconfig/kubelet

KUBELET_KUBEADM_ARGS="--container-runtime=remote --container-runtime-endpoint=/run/cri-dockerd.sock"

#--container-runtime=remote  容器运行时是远程的
#--container-runtime-endpoint=/run/cri-dockerd.sock      #远程的容器运行时在哪里
主要用于对接docker的运行时文件 ，在ls/run/下有以及 ls/var/run/下也有都一样</code></pre> 
<p>需要说明的是，该配置也可不进行，而是直接在后面的各kubeadm命令上使用“--cri-socket unix:///run/cri-dockerd.sock”选项。</p> 
<h3 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%BB%E8%8A%82%E7%82%B9">初始化第一个主节点</h3> 
<p>该步骤开始尝试构建Kubernetes集群的master节点，配置完成后，各worker节点直接加入到集群中的即可。需要特别说明的是，由kubeadm部署的Kubernetes集群上，集群核心组件kube-apiserver、kube-controller-manager、kube-scheduler和etcd等均会以静态Pod的形式运行，它们所依赖的镜像文件默认来自于k8s.gcr.io这一Registry服务之上。但我们无法直接访问该服务，常用的解决办法有如下两种，本示例将选择使用更易于使用的前一种方式。</p> 
<ul><li> <p>使用能够到达该服务的代理服务；</p> </li><li> <p>使用国内的镜像服务器上的服务，例如registry.aliyuncs.com/google_containers等。</p> </li></ul> 
<p><strong>初始化master节点（在master01上完成如下操作）</strong></p> 
<p>在运行初始化命令之前先运行如下命令单独获取相关的镜像文件，而后再运行后面的kubeadm init命令，以便于观察到镜像文件的下载过程。</p> 
<p>~# kubeadm config images list</p> 
<p>上面的命令会列出类似如下的Image信息。</p> 
<blockquote> 
 <p>registry.k8s.io/kube-apiserver:v1.25.3<br> registry.k8s.io/kube-controller-manager:v1.25.3<br> registry.k8s.io/kube-scheduler:v1.25.3<br> registry.k8s.io/kube-proxy:v1.25.3<br> registry.k8s.io/pause:3.8<br> registry.k8s.io/etcd:3.5.4-0<br> registry.k8s.io/coredns/coredns:v1.9.3</p> 
</blockquote> 
<p>~# kubeadm config images pull --cri-socket unix:///run/cri-dockerd.sock</p> 
<blockquote> 
 <p>#使用阿里云拉取所需镜像  </p> 
 <p>[root@k8s-master01 ~]# kubeadm config images pull --image-repository=registry.aliyuncs.com/google_containers --cri-socket unix:///run/cri-dockerd.sock</p> 
</blockquote> 
<blockquote> 
 <p>[config/images] Pulled registry.aliyuncs.com/google_containers/kube-apiserver:v1.25.3<br> [config/images] Pulled registry.aliyuncs.com/google_containers/kube-controller-manager:v1.25.3<br> [config/images] Pulled registry.aliyuncs.com/google_containers/kube-scheduler:v1.25.3<br> [config/images] Pulled registry.aliyuncs.com/google_containers/kube-proxy:v1.25.3<br> [config/images] Pulled registry.aliyuncs.com/google_containers/pause:3.8<br> [config/images] Pulled registry.aliyuncs.com/google_containers/etcd:3.5.4-0<br> [config/images] Pulled registry.aliyuncs.com/google_containers/coredns:v1.9.3</p> 
</blockquote> 
<p>而后即可进行master节点初始化。kubeadm init命令支持两种初始化方式，一是通过命令行选项传递关键的部署设定，另一个是基于yaml格式的专用配置文件，后一种允许用户自定义各个部署参数，在配置上更为灵活和便捷。下面分别给出了两种实现方式的配置步骤，建议读者采用第二种方式进行。</p> 
<h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B8%80"><strong>初始化方式一</strong></h4> 
<p>运行</p> 
<blockquote> 
 <p>systemctl daemon-reload</p> 
 <p>systemctl restart cri-docker.service</p> 
</blockquote> 
<p>运行如下命令完成k8s-master01节点的初始化：</p> 
<pre><code>kubeadm init --control-plane-endpoint="k8s-master01.wang.com" --kubernetes-version=v1.25.3 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --token-ttl=0 --cri-socket unix:///run/cri-dockerd.sock --upload-certs --image-repository registry.aliyuncs.com/google_containers</code></pre> 
<p>重置集群：提示：先重置工作节点，再重置主节点； 如果报错重做的话 （没启动的情况下）</p> 
<pre><code>重做：
kubeadm reset --cri-socket unix:///run/cri-dockerd.sock &amp;&amp; rm -rf /etc/kubernetes/ /var/lib/kubelet /var/lib/dockershim /var/run/kubernetes /var/lib/cni /etc/cni/net.d

rm -rf /var/lib/etcd 如果出问题重做，记得清空相关依赖包
docker rm -f `docker ps -qa`   #删除相关无用镜像</code></pre> 
<p>命令中的各选项简单说明如下：</p> 
<ul><li> <p>--image-repository：指定要使用的镜像仓库，默认为gcr.io；</p> </li><li> <p>--kubernetes-version：kubernetes程序组件的版本号，它必须要与安装的kubelet程序包的版本号相同；</p> </li><li> <p>--control-plane-endpoint：控制平面的固定访问端点，可以是IP地址或DNS名称，会被用于集群管理员及集群组件的kubeconfig配置文件的API Server的访问地址；单控制平面部署时可以不使用该选项；</p> </li><li> <p>--pod-network-cidr：Pod网络的地址范围，其值为CIDR格式的网络地址，通常，Flannel网络插件的默认为10.244.0.0/16，Project Calico插件的默认值为192.168.0.0/16；</p> </li><li> <p>--service-cidr：Service的网络地址范围，其值为CIDR格式的网络地址，默认为10.96.0.0/12；通常，仅Flannel一类的网络插件需要手动指定该地址；</p> </li><li> <p>--apiserver-advertise-address：apiserver通告给其他组件的IP地址，一般应该为Master节点的用于集群内部通信的IP地址，0.0.0.0表示节点上所有可用地址；</p> </li><li> <p>--token-ttl：共享令牌（token）的过期时长，默认为24小时，0表示永不过期；为防止不安全存储等原因导致的令牌泄露危及集群安全，建议为其设定过期时长。未设定该选项时，在token过期后，若期望再向集群中加入其它节点，可以使用如下命令重新创建token，并生成节点加入命令。</p> </li><li> <p>--upload-certs  上传私有ca的证书，和ca的相关信息的，传改第二个节点和第三个节点使用的</p> </li><li> 
  <blockquote> 
   <p>kubeadm token create --print-join-command</p> 
  </blockquote> </li></ul> 
<blockquote> 
 <p>提示：无法访问grc.io时，可以在上面的命令中使用“--image-repository=registry.aliyuncs.com/google_containers”选项，以便从国内的镜像服务中获取各Image；</p> 
</blockquote> 
<blockquote> 
 <p>注意：若各节点未禁用Swap设备，还需要附加选项“--ignore-preflight-errors=Swap”，从而让kubeadm忽略该错误设定；</p> 
</blockquote> 
<h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E4%BA%8C%C2%A0">初始化方式二 </h4> 
<p>kubeadm也可通过配置文件加载配置，以定制更丰富的部署选项。获取内置的初始配置文件的命令</p> 
<pre><code>kubeadm config print init-defaults</code></pre> 
<p>下面的配置示例，是以上面命令的输出结果为框架进行修改的，它明确定义了kubeProxy的模式为ipvs，并支持通过修改imageRepository的值修改获取系统镜像时使用的镜像仓库。</p> 
<pre><code>apiVersion: kubeadm.k8s.io/v1beta3
bootstrapTokens:
kind: InitConfiguration
localAPIEndpoint:
  # 这里的地址即为初始化的控制平面第一个节点的IP地址；
  advertiseAddress: 172.29.1.1
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///run/cri-dockerd.sock
  imagePullPolicy: IfNotPresent
  # 第一个控制平面节点的主机名称；
  name: k8s-master01.magedu.com
  taints: 
  - effect: NoSchedule
    key: node-role.kubernetes.io/master
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
---
apiServer:
  timeoutForControlPlane: 4m0s
apiVersion: kubeadm.k8s.io/v1beta3
# 控制平面的接入端点，我们这里选择适配到kubeapi.magedu.com这一域名上；
controlPlaneEndpoint: "kubeapi.magedu.com:6443"
certificatesDir: /etc/kubernetes/pki
clusterName: kubernetes
controllerManager: {}
dns: {}
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.aliyuncs.com/google_containers
kind: ClusterConfiguration
kubernetesVersion: v1.24.3
networking:
  dnsDomain: cluster.local
  serviceSubnet: 10.96.0.0/12
  podSubnet: 10.244.0.0/16
scheduler: {}
---
apiVersion: kubeproxy.config.k8s.io/v1alpha1
kind: KubeProxyConfiguration
# 用于配置kube-proxy上为Service指定的代理模式，默认为iptables；
mode: "ipvs"</code></pre> 
<p>将上面的内容保存于配置文件中，例如kubeadm-config.yaml，而后执行如下命令即能实现类似前一种初始化方式中的集群初始配置，但这里将Service的代理模式设定为了ipvs。</p> 
<pre><code>  ~# kubeadm init --config kubeadm-config.yaml --upload-certs</code></pre> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%C2%A0%20%E4%BB%8B%E7%BB%8D"><strong>初始化完成后的操作步骤  <span style="color:#ffd900;">介绍</span></strong></p> 
<p>对于Kubernetes系统的新用户来说，无论使用上述哪种方法，命令运行结束后，请记录最后的kubeadm join命令输出的最后提示的操作步骤。下面的内容是需要用户记录的一个命令输出示例，它提示了后续需要的操作步骤。</p> 
<pre><code># 下面是成功完成第一个控制平面节点初始化的提示信息及后续需要完成的步骤
Your Kubernetes control-plane has initialized successfully!

# 为了完成初始化操作，管理员需要额外手动完成几个必要的步骤
To start using your cluster, you need to run the following as a regular user:

# 第1个步骤提示， Kubernetes集群管理员认证到Kubernetes集群时使用的kubeconfig配置文件
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

# 我们也可以不做上述设定，而使用环境变量KUBECONFIG为kubectl等指定默认使用的kubeconfig；
Alternatively, if you are the root user, you can run:

export KUBECONFIG=/etc/kubernetes/admin.conf

# 第2个步骤提示，为Kubernetes集群部署一个网络插件，具体选用的插件则取决于管理员；
You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

# 第3个步骤提示，向集群添加额外的控制平面节点，但本文会略过该步骤，并将在其它文章介绍其实现方式。
You can now join any number of the control-plane node running the following command on each as root:

# 在部署好kubeadm等程序包的其他控制平面节点上以root用户的身份运行类似如下命令，
# 命令中的hash信息对于不同的部署环境来说会各不相同；该步骤只能在其它控制平面节点上执行；
# 提示：与cri-dockerd结合使用docker-ce作为container runtime时，通常需要为下面的命令
#      额外附加“--cri-socket unix:///run/cri-dockerd.sock”选项；
  kubeadm join kubeapi.magedu.com:6443 --token emvhys.9d7623w48vgm99qz \
        --discovery-token-ca-cert-hash sha256:f13e30d459bf18fa4415f30822a09fe95ab84b213d6dc77d29beb0542bed4cee \
        --control-plane --certificate-key e1996b2c9bf3e60fb75a622c9245539c6d82904fd2dd89f12c6efe459edd0c5b

# 因为在初始化命令“kubeadm init”中使用了“--upload-certs”选项，因而初始化过程会自动上传添加其它Master时用到的数字证书等信息；
# 出于安全考虑，这些内容会在2小时之后自动删除；
Please note that the certificate-key gives access to cluster sensitive data, keep it secret!
As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use
"kubeadm init phase upload-certs --upload-certs" to reload certs afterward.

# 第4个步骤提示，向集群添加工作节点
Then you can join any number of worker nodes by running the following on each as root:

# 在部署好kubeadm等程序包的各工作节点上以root用户运行类似如下命令；
# 提示：与cri-dockerd结合使用docker-ce作为container runtime时，通常需要为下面的命令
#      额外附加“--cri-socket unix:///run/cri-dockerd.sock”选项；
kubeadm join kubeapi.magedu.com:6443 --token emvhys.9d7623w48vgm99qz \
        --discovery-token-ca-cert-hash sha256:f13e30d459bf18fa4415f30822a09fe95ab84b213d6dc77d29beb0542bed4cee</code></pre> 
<p>另外，kubeadm init命令完整参考指南请移步官方文档，地址为https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/。</p> 
<pre><code>mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6a/b7/qR5ZHwNN_o.png"></p> 
<h4 id="%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6">部署网络插件</h4> 
<p>Kubernetes系统上Pod网络的实现依赖于第三方插件进行，这类插件有近数十种之多，较为著名的有flannel、calico、canal和kube-router等，简单易用的实现是为CoreOS提供的flannel项目。下面的命令用于在线部署flannel至Kubernetes系统之上：</p> 
<p>首先，下载适配系统及硬件平台环境的flanneld至每个节点，并放置于/opt/bin/目录下。我们这里选用flanneld-amd64，目前最新的版本为v0.19.1，因而，我们需要在集群的每个节点上执行如下命令：</p> 
<pre><code>#所有节点执行：

#下载链接：
 https://github.com/flannel-io/flannel/releases


curl -L https://github.com/flannel-io/flannel/releases/download/v0.20.1/flanneld-amd64 -o /opt/bin/flanneld      #也可以用迅雷快一些

[root@k8s-master01 ~]# cp flanneld-amd64 /opt/bin/flanneld
[root@k8s-master01 ~]# chmod +x /opt/bin/flanneld
[root@k8s-master01 ~]# ll /opt/bin/flanneld
-rwxr-xr-x 1 root root 39358256 11月  7 21:57 /opt/bin/flanneld*</code></pre> 
<p>随后，在初始化的<strong>第一个</strong>master节点k8s-master01上运行如下命令，向Kubernetes部署kube-flannel。    # 在官方文档里复制最新网络插件命令 略  https://github.com/flannel-io/flannel/</p> 
<pre><code>kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml
</code></pre> 
<p>而后使用如下命令确认其输出结果中Pod的状态为“Running”</p> 
<blockquote> 
 <p>~# kubectl get pods -n kube-flannel</p> 
</blockquote> 
<p>上面的命令应该会得到类似如下输出，这表示kube-flannel已然正常运行。</p> 
<pre><code>[root@ubuntu2004 bin]#kubectl get pods -n kube-flannel
NAME                    READY   STATUS    RESTARTS   AGE
kube-flannel-ds-zv4ww   1/1     Running   0          2m36s</code></pre> 
<h4 id="%E9%AA%8C%E8%AF%81master%E8%8A%82%E7%82%B9%E5%B7%B2%E7%BB%8F%E5%B0%B1%E7%BB%AA">验证master节点已经就绪</h4> 
<p>~# kubectl get nodes</p> 
<p>上面的命令应该会得到类似如下输出，这表示k8s-master01节点已经就绪。</p> 
<pre><code>NAME                     STATUS   ROLES           AGE   VERSION
k8s-master01.magedu.com   Ready   control-plane   56m   v1.24.3</code></pre> 
<h4 id="%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%88%B0%E9%9B%86%E7%BE%A4%E4%B8%AD">添加节点到集群中</h4> 
<p>下面的两个步骤，需要分别在k8s-node01、k8s-node02和k8s-node03上各自完成。</p> 
<p>1、若未禁用Swap设备，编辑kubelet的配置文件/etc/default/kubelet，设置其忽略Swap启用的状态错误，内容如下：KUBELET_EXTRA_ARGS="--fail-swap-on=false"</p> 
<p>2、将节点加入第二步中创建的master的集群中，要使用主节点初始化过程中记录的kubeadm join命令；</p> 
<p>主节点的2 3上<img alt="" height="192" src="https://images2.imgbox.com/b2/78/v9yNE7hV_o.png" width="1026"></p> 
<p>节点的复制，都指向一 </p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/f0/fd/aZMfn9zd_o.png" width="1085"></p> 
<pre><code>kubeadm join k8s-master01.wang.com:6443 --token 012fih.q9ou5hs24vzmaht8 \
	--discovery-token-ca-cert-hash sha256:83b17914eb714bde398b88b2da4c1e64f2f9c466d10cf43b48b35925ebcbcc61 \
	--control-plane --certificate-key 013010cc024e12b1e8e191f35a2ab0491f099a252619805ee572fc3eee191a2a --cri-socket unix:///run/cri-dockerd.sock
#这里不能直接执行需要对接--cri-socket unix:///run/cri-dockerd.sock  所以需要加在后面

辅的节点复制
[root@k8s-node03 ~]#kubeadm join k8s-master01.wang.com:6443 --token vg7do6.wtxkz0xktr22o8lo \
&gt; --discovery-token-ca-cert-hash sha256:59c2608d15ade0130f299f6521a05cb6bf6d66ee9f3dae22e84f4e4f1eda8ed7 \
&gt; --cri-socket unix:///run/cri-dockerd.sock
[preflight] Running pre-flight checks</code></pre> 
<ul><li>提示：在未禁用Swap设备的情况下，还需要为上面的命令额外附加“--ignore-preflight-errors=Swap”选项。  <h4 id="%E9%AA%8C%E8%AF%81%E8%8A%82%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%9C">验证节点添加结果</h4> <p>在每个节点添加完成后，即可通过kubectl验证添加结果。下面的命令及其输出是在所有的三个节点均添加完成后运行的，其输出结果表明三个Worker Node已经准备就绪。</p> 
  <blockquote> 
   <p>~# kubectl get nodes</p> 
  </blockquote> </li></ul> 
<pre><code>[root@master01 ~]#kubectl get node
NAME         STATUS     ROLES           AGE    VERSION
k8s-node02   Ready      &lt;none&gt;          2m6s   v1.25.3
k8s-node03   NotReady   &lt;none&gt;          68s    v1.25.3
master01     Ready      control-plane   38m    v1.25.3
master02     Ready      control-plane   35m    v1.25.3
master03     Ready      control-plane   30m    v1.25.3
ubuntu2004   Ready      &lt;none&gt;          23m    v1.25.3  #Ready代表完成
</code></pre> 
<h4>这样完成了</h4> 
<h4></h4> 
<h4></h4> 
<h4></h4> 
<h4 id="%E6%B5%8B%E8%AF%95%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E5%8F%8A%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%C2%A0">测试应用编排及服务访问 </h4> 
<p>到此为止，一个master，并附带有三个worker的kubernetes集群基础设施已经部署完成，用户随后即可测试其核心功能。例如，下面的命令可将demoapp以Pod的形式编排运行于集群之上，并通过在集群外部进行访问：</p> 
<pre><code>~# kubectl create deployment demoapp --image=ikubernetes/demoapp:v1.0 --replicas=3

~# kubectl create service nodeport demoapp --tcp=80:80</code></pre> 
<p>而后，使用如下命令了解Service对象demoapp使用的NodePort，以便于在集群外部进行访问：</p> 
<pre><code>~# kubectl get svc -l app=demoapp  

NAME      TYPE    CLUSTER-IP    EXTERNAL-IP  PORT(S)     AGE
NAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE
demoapp   NodePort   10.98.15.56   &lt;none&gt;        80:31009/TCP   13s</code></pre> 
<p>demoapp是一个web应用，因此，用户可以于集群外部通过“http://NodeIP:31009”这个URL访问demoapp上的应用，例如于集群外通过浏览器访问“http://172.29.1.11:31009”。</p> 
<p>我们也可以在Kubernetes集群上启动一个临时的客户端，对demoapp服务发起访问测试。</p> 
<pre><code>~# kubectl run client-$RANDOM --image=ikubernetes/admin-box:v1.2 --rm --restart=Never -it --command -- /bin/bash</code></pre> 
<p>而后，在打开的交互式接口中，运行如下命令，对demoapp.default.svc服务发起访问请求，验证其负载均衡的效果。</p> 
<blockquote> 
 <p>root@client-5229 ~# while true; do curl demoapp.default.svc; sleep 1; done</p> 
</blockquote> 
<p>该命令会持续返回类似如下的结果，这可以证明CoreDNS名称解析功能，以及Service的服务发现及负载均衡功能均已经正常工作。</p> 
<h4 id="%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%20%E5%88%97%EF%BC%9A%E6%8B%89nginx">相关命令 列：拉nginx</h4> 
<blockquote> 
 <p>[root@master01 ~]#kubectl get pods        #查看pods</p> 
 <p>[root@master01 ~]#kubectl delete pods nginx-55f494c486-pl8br     #删除指定pods</p> 
 <p>[root@master01 ~]#kubectl get pods -o wide       #详细查看</p> 
 <p></p> 
</blockquote> 
<blockquote> 
 <p>kubectl create deployment nginx --image nginx:alpine --replcas=3</p> 
 <p>#kubectl create 创建新的资源对象，如果再次运行该命令，则会抛出错误，因为资源名称在名称空间中应该是唯一的，支持JSON和YAML格式的文件。</p> 
 <p>#deployment    命名标签</p> 
 <p>#--replcas=3    运行几个副本</p> 
 <p></p> 
 <p> kubectl get deployment    显示</p> 
 <p>NAME    READY   UP-TO-DATE   AVAILABLE   AGE<br> mysql   0/1     1            0           15m<br> nginx   3/3     3            3           44m<br>  </p> 
</blockquote> 
<p><strong>部署nginx </strong></p> 
<pre><code>[root@master01 ~]#kubectl create deployment nginx --image nginx:alpine --replicas=3
deployment.apps/nginx created
[root@master01 ~]#kubectl get pods
NAME                     READY   STATUS              RESTARTS   AGE
nginx-55f494c486-4vkm7   0/1     ContainerCreating   0          21s
nginx-55f494c486-gwk8l   0/1     ContainerCreating   0          21s
nginx-55f494c486-pl8br   0/1     ContainerCreating   0          21s

[root@master01 ~]#kubectl get pods -o wide
NAME                     READY   STATUS    RESTARTS   AGE     IP           NODE         NOMINATED NODE   READINESS GATES
nginx-55f494c486-4vkm7   1/1     Running   0          3m46s   10.244.5.2   k8s-node03   &lt;none&gt;           &lt;none&gt;
nginx-55f494c486-gwk8l   1/1     Running   0          3m46s   10.244.3.2   ubuntu2004   &lt;none&gt;           &lt;none&gt;
nginx-55f494c486-pl8br   1/1     Running   0          3m46s   10.244.4.2   k8s-node02   &lt;none&gt;           &lt;none&gt;

[root@master01 ~]#curl 10.244.3.2     #访问那个ip都一样
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
#因为指定三个，哪怕删除了也会自己拉起来
[root@master01 ~]#kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
nginx-55f494c486-4vkm7   1/1     Running   0          7m15s
nginx-55f494c486-gwk8l   1/1     Running   0          7m15s
nginx-55f494c486-pl8br   1/1     Running   0          7m15s
[root@master01 ~]#kubectl delete pods nginx-55f494c486-pl8br pod "nginx-55f494c486-pl8br" deleted
[root@master01 ~]#kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
nginx-55f494c486-4vkm7   1/1     Running   0          7m57s
nginx-55f494c486-gwk8l   1/1     Running   0          7m57s
nginx-55f494c486-l7dnd   1/1     Running   0          4s

外部访问 需要指定service
#Service 一种可以访问它们的方式。这一组Pod能通过Service被访问到
#nodeport 外部流量访问K8s的一种方式，是提供给外部流量访问K8s集群资源的一种方式。
#--type=NodePort
[root@master01 ~]#kubectl create service nodeport nginx --tcp=80:80
service/nginx created

[root@master01 ~]#kubectl get service
NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP        71m
nginx        NodePort    10.100.104.235   &lt;none&gt;        80:32102/TCP   21s   
#10.100.104.235 通过它可以调度到每一组pods上去curl 10.100.104.235 
#10.0.0.105:32102 随便一个ip地址跟端口就可以访问nginx


</code></pre> 
<p>一键部署#kubectl apply -f ***</p> 
<pre><code>git cline https://github.com/iKubernetes/learning-k8s.git
处理 delta 中: 100% (38/38), 完成.

[root@master01 ~]#cd learning-k8s/wordpress/

[root@master01 wordpress]#ls
mysql  nginx  README.md  wordpress

[root@master01 wordpress]#/ll
lib/        lib32/      lib64/      libx32/     lost+found/ 

[root@master01 wordpress]#kubectl apply -f mysql/
secret/mysql-user-pass created
persistentvolumeclaim/mysql-data created
service/mysql created
deployment.apps/mysql created

[root@master01 wordpress]#kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
mysql-9d74fbb9b-6wb5v    0/1     Pending   0          23s
nginx-55f494c486-4vkm7   1/1     Running   0          28m
nginx-55f494c486-gwk8l   1/1     Running   0          28m
nginx-55f494c486-l7dnd   1/1     Running   0          20m
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13ac2579b5f0e5ea89fee858e70a70b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Win10 安装系统跳过创建用户，直接启用 Administrator</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/515a133d973deb8a7884d66530a13761/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用c语言实现整数加法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>