<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenCV快速入门：特征点检测与匹配 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenCV快速入门：特征点检测与匹配" />
<meta property="og:description" content="文章目录 前言一、角点检测1.1 角点特征1.1.1 角点特征概念1.1.2 角点的特点1.1.3 关键点绘制代码实现1.1.4 函数解析 1.2 Harris角点检测1.2.1 Harris角点检测原理1.2.2 Harris角点检测公式1.2.3 代码实现1.2.4 函数解析 1.3 Shi-Tomasi角点检测1.3.1 Shi-Tomasi角点检测原理1.3.2 Shi-Tomasi角点检测公式1.3.3 代码实现1.3.4 函数解析 1.4 FAST角点检测1.4.1 FAST角点检测原理1.4.2 FAST角点检测特点和应用1.4.3 代码实现1.4.4 函数解析 1.5 亚像素角点检测1.5.1 亚像素角点检测原理1.5.2 亚像素角点检测公式1.5.3 代码实现1.5.4 函数解析 二、特征点检测2.1 SIFT（尺度不变特征变换）2.1.1 SIFT原理2.1.2 代码实现2.1.3 函数解析 2.2 SURF（加速稳健特征）2.2.1 SURF原理2.2.2 代码实现2.2.3 函数解析 2.3 ORB（方向快速和旋转二进制）2.3.1 ORB原理2.3.2 代码实现2.3.3 函数解析 三、特征点匹配3.1 BF匹配器3.1.1 BF匹配器原理3.1.2 代码实现3.1.3 函数解析 3.2 FLANN匹配器3.2.1 FLANN匹配器原理3.2.2 代码实现3.2.3 函数解析 3.3 RANSAC特征点匹配3.3.1 RANSAC原理3.3.2 代码实现3.3.3 函数解析 总结 前言 在计算机视觉领域，特征点检测与匹配是解决多种问题的核心，包括图像识别、跟踪、三维重建和运动分析。OpenCV作为一个功能强大的视觉处理库，提供了丰富的功能来处理这些任务。本博客旨在提供一个关于OpenCV中特征点检测与匹配方法的快速入门指南。
我们将从角点检测开始，探讨如Harris、Shi-Tomasi和FAST等经典算法，介绍它们的原理、公式和代码实现。接着，我们将深入到特征点检测的高级话题，覆盖如SIFT、SURF和ORB等算法。每种方法都会有详细的函数解析，帮助理解其背后的工作原理。最后，我们将讨论特征点匹配技术，包括BF匹配器、FLANN匹配器和RANSAC匹配方法，它们在处理不同图像间的特征点对应关系时至关重要。
一、角点检测 角点检测（Corner Detection）是计算机视觉和图像处理中的一个基本概念，指的是在图像中识别出具有明显角点特征的点。在OpenCV中，我们通常使用Harris 角点检测或Shi-Tomasi角点检测来实现这一功能。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c707130aa4ac2cd8b1166ec5652d857e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-24T22:14:50+08:00" />
<meta property="article:modified_time" content="2023-11-24T22:14:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenCV快速入门：特征点检测与匹配</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#_13" rel="nofollow">一、角点检测</a></li><li><ul><li><a href="#11__15" rel="nofollow">1.1 角点特征</a></li><li><ul><li><a href="#111__16" rel="nofollow">1.1.1 角点特征概念</a></li><li><a href="#112__20" rel="nofollow">1.1.2 角点的特点</a></li><li><a href="#113__26" rel="nofollow">1.1.3 关键点绘制代码实现</a></li><li><a href="#114__54" rel="nofollow">1.1.4 函数解析</a></li></ul> 
   </li><li><a href="#12_Harris_70" rel="nofollow">1.2 Harris角点检测</a></li><li><ul><li><a href="#121_Harris_71" rel="nofollow">1.2.1 Harris角点检测原理</a></li><li><a href="#122_Harris_85" rel="nofollow">1.2.2 Harris角点检测公式</a></li><li><a href="#123__147" rel="nofollow">1.2.3 代码实现</a></li><li><a href="#124__183" rel="nofollow">1.2.4 函数解析</a></li></ul> 
   </li><li><a href="#13_ShiTomasi_201" rel="nofollow">1.3 Shi-Tomasi角点检测</a></li><li><ul><li><a href="#131_ShiTomasi_204" rel="nofollow">1.3.1 Shi-Tomasi角点检测原理</a></li><li><a href="#132_ShiTomasi_210" rel="nofollow">1.3.2 Shi-Tomasi角点检测公式</a></li><li><a href="#133__218" rel="nofollow">1.3.3 代码实现</a></li><li><a href="#134__248" rel="nofollow">1.3.4 函数解析</a></li></ul> 
   </li><li><a href="#14_FAST_270" rel="nofollow">1.4 FAST角点检测</a></li><li><ul><li><a href="#141_FAST_273" rel="nofollow">1.4.1 FAST角点检测原理</a></li><li><a href="#142_FAST_281" rel="nofollow">1.4.2 FAST角点检测特点和应用</a></li><li><a href="#143__287" rel="nofollow">1.4.3 代码实现</a></li><li><a href="#144__313" rel="nofollow">1.4.4 函数解析</a></li></ul> 
   </li><li><a href="#15__323" rel="nofollow">1.5 亚像素角点检测</a></li><li><ul><li><a href="#151__327" rel="nofollow">1.5.1 亚像素角点检测原理</a></li><li><a href="#152__339" rel="nofollow">1.5.2 亚像素角点检测公式</a></li><li><a href="#153__349" rel="nofollow">1.5.3 代码实现</a></li><li><a href="#154__383" rel="nofollow">1.5.4 函数解析</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_418" rel="nofollow">二、特征点检测</a></li><li><ul><li><a href="#21_SIFT_473" rel="nofollow">2.1 SIFT（尺度不变特征变换）</a></li><li><ul><li><a href="#211_SIFT_476" rel="nofollow">2.1.1 SIFT原理</a></li><li><a href="#212__484" rel="nofollow">2.1.2 代码实现</a></li><li><a href="#213__501" rel="nofollow">2.1.3 函数解析</a></li></ul> 
   </li><li><a href="#22_SURF_533" rel="nofollow">2.2 SURF（加速稳健特征）</a></li><li><ul><li><a href="#221_SURF_536" rel="nofollow">2.2.1 SURF原理</a></li><li><a href="#222__543" rel="nofollow">2.2.2 代码实现</a></li><li><a href="#223__559" rel="nofollow">2.2.3 函数解析</a></li></ul> 
   </li><li><a href="#23_ORB_573" rel="nofollow">2.3 ORB（方向快速和旋转二进制）</a></li><li><ul><li><a href="#231_ORB_576" rel="nofollow">2.3.1 ORB原理</a></li><li><a href="#232__583" rel="nofollow">2.3.2 代码实现</a></li><li><a href="#233__599" rel="nofollow">2.3.3 函数解析</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_622" rel="nofollow">三、特征点匹配</a></li><li><ul><li><a href="#31_BF_626" rel="nofollow">3.1 BF匹配器</a></li><li><ul><li><a href="#311_BF_630" rel="nofollow">3.1.1 BF匹配器原理</a></li><li><a href="#312__636" rel="nofollow">3.1.2 代码实现</a></li><li><a href="#313__673" rel="nofollow">3.1.3 函数解析</a></li></ul> 
   </li><li><a href="#32_FLANN_695" rel="nofollow">3.2 FLANN匹配器</a></li><li><ul><li><a href="#321_FLANN_699" rel="nofollow">3.2.1 FLANN匹配器原理</a></li><li><a href="#322__704" rel="nofollow">3.2.2 代码实现</a></li><li><a href="#323__746" rel="nofollow">3.2.3 函数解析</a></li></ul> 
   </li><li><a href="#33_RANSAC_770" rel="nofollow">3.3 RANSAC特征点匹配</a></li><li><ul><li><a href="#331_RANSAC_774" rel="nofollow">3.3.1 RANSAC原理</a></li><li><a href="#332__786" rel="nofollow">3.3.2 代码实现</a></li><li><a href="#333__838" rel="nofollow">3.3.3 函数解析</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_867" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_4"></a>前言</h2> 
<p>在计算机视觉领域，特征点检测与匹配是解决多种问题的核心，包括图像识别、跟踪、三维重建和运动分析。OpenCV作为一个功能强大的视觉处理库，提供了丰富的功能来处理这些任务。本博客旨在提供一个关于OpenCV中特征点检测与匹配方法的快速入门指南。</p> 
<p>我们将从角点检测开始，探讨如Harris、Shi-Tomasi和FAST等经典算法，介绍它们的原理、公式和代码实现。接着，我们将深入到特征点检测的高级话题，覆盖如SIFT、SURF和ORB等算法。每种方法都会有详细的函数解析，帮助理解其背后的工作原理。最后，我们将讨论特征点匹配技术，包括BF匹配器、FLANN匹配器和RANSAC匹配方法，它们在处理不同图像间的特征点对应关系时至关重要。<br> <img src="https://images2.imgbox.com/29/19/AfA4NoTv_o.jpg" alt="OpenCV Logo"></p> 
<hr> 
<h2><a id="_13"></a>一、角点检测</h2> 
<p>角点检测（Corner Detection）是计算机视觉和图像处理中的一个基本概念，指的是在图像中识别出具有明显角点特征的点。在OpenCV中，我们通常使用Harris 角点检测或Shi-Tomasi角点检测来实现这一功能。</p> 
<h3><a id="11__15"></a>1.1 角点特征</h3> 
<h4><a id="111__16"></a>1.1.1 角点特征概念</h4> 
<p>角点特征是指在图像中那些局部特征明显、在多个方向上具有变化的点。在计算机视觉中，角点是图像中最重要的特征之一，因为它们通常对图像的变化（如视角、光照、尺度等）保持不变性。角点特征在图像处理、模式识别、三维建模、运动追踪等领域有着广泛的应用。</p> 
<h4><a id="112__20"></a>1.1.2 角点的特点</h4> 
<blockquote> 
 <ul><li><strong>局部特征</strong>：角点是图像中局部特征的重要表示，能够代表图像的关键信息。</li><li><strong>不变性</strong>：它们相对稳定，对光照、旋转、缩放等图像变化具有一定的抵抗力。</li><li><strong>高信息量</strong>：角点包含了丰富的信息，适合用于图像匹配、目标跟踪等。</li></ul> 
</blockquote> 
<h4><a id="113__26"></a>1.1.3 关键点绘制代码实现</h4> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2
<span class="token keyword">import</span> random

<span class="token comment"># 读取图像</span>
image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">)</span>

<span class="token comment"># 生成随机关键点</span>
keypoints <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
num_keypoints <span class="token operator">=</span> <span class="token number">50</span>  <span class="token comment"># 假设我们想生成50个关键点</span>
<span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_keypoints<span class="token punctuation">)</span><span class="token punctuation">:</span>
    x <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    y <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    keypoints<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>KeyPoint<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 使用 drawKeypoints 绘制关键点</span>
keypoint_image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawKeypoints<span class="token punctuation">(</span>image<span class="token punctuation">,</span> keypoints<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment"># 显示图像</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'Random Keypoints'</span><span class="token punctuation">,</span> keypoint_image<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/d3/3b/2Dv68VfO_o.png" alt="Random Keypoints" width="300"><br> 在这个示例中，我创建了50个随机位置的关键点。<code>cv2.KeyPoint</code> 需要 x 和 y 坐标以及关键点的大小（这里设置为 1）。这些点将以绿色标记在图像上。</p> 
<h4><a id="114__54"></a>1.1.4 函数解析</h4> 
<p><code>drawKeypoints</code> 函数是 OpenCV 库中用于在图像上绘制关键点的一个函数。这个函数的目的是将检测到的关键点可视化，使得这些点在图像上更容易被识别。</p> 
<blockquote> 
 <p><code>def drawKeypoints(image, keypoints, outImage, color=None, flags=None)</code></p> 
 <ol><li> <p><strong>image</strong>： 这是源图像，即你想在其上绘制关键点的图像。这个图像应该是一个标准的 OpenCV 图像格式，通常是使用 <code>cv2.imread</code> 读取的。</p> </li><li> <p><strong>keypoints</strong>： 这个参数是一个关键点的列表。这些关键点通常是通过特征检测算法（如 SIFT, SURF, ORB 等）得到的。每个关键点通常包含了图像中一个特定点的位置（x, y 坐标）和其他信息（如方向、大小等）。</p> </li><li> <p><strong>outImage</strong>： 这是输出图像。函数会在这个图像上绘制关键点，并将其返回。如果这个参数是 None，OpenCV 通常会直接在源图像上绘制关键点。</p> </li><li> <p><strong>color</strong>： 这个可选参数定义了关键点的颜色。如果未指定，将使用默认颜色。颜色通常以 (B, G, R) 格式指定，其中 B、G、R 分别代表蓝色、绿色和红色的强度。</p> </li><li> <p><strong>flags</strong>： 这个可选参数定义了绘制关键点时的一些特性。OpenCV 提供了几个不同的标志来控制如何绘制关键点。<br> 例如，<code>cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS</code> 会绘制关键点的大小和方向，<br> 而 <code>cv2.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS</code> 将不会绘制单个的关键点。</p> </li></ol> 
</blockquote> 
<h3><a id="12_Harris_70"></a>1.2 Harris角点检测</h3> 
<h4><a id="121_Harris_71"></a>1.2.1 Harris角点检测原理</h4> 
<p>Harris角点检测的基本原理是观察窗口移动时，窗口内像素灰度变化的程度。具体来说，它计算了窗口在各个方向上移动时灰度变化的二阶矩阵，并通过此矩阵来判断一个点是否为角点。角点的特征是无论窗口向哪个方向移动，窗口内的灰度变化都很大。</p> 
<p>基本检测原理如下：</p> 
<ol><li><strong>图像窗口和移动</strong>：</li></ol> 
<blockquote> 
 <ul><li>假设有一个小窗口（或掩模），在整个图像上移动。</li><li>对于窗口中的每个像素，我们希望了解当窗口在各个方向上移动小距离时，像素强度的变化情况。</li></ul> 
</blockquote> 
<ol start="2"><li><strong>强度变化函数</strong>：</li></ol> 
<blockquote> 
 <ul><li>强度变化可以用函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           E 
          
         
           ( 
          
         
           u 
          
         
           , 
          
         
           v 
          
         
           ) 
          
         
        
          E(u,v) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mclose">)</span></span></span></span></span>来描述，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           u 
          
         
        
          u 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           v 
          
         
        
          v 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span></span></span></span></span> 是窗口在x和y方向上的移动量。</li></ul> 
</blockquote> 
<h4><a id="122_Harris_85"></a>1.2.2 Harris角点检测公式</h4> 
<p>Harris角点检测的核心是计算每个像素的Harris响应值。数学公式为：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          E 
         
        
          ( 
         
        
          u 
         
        
          , 
         
        
          v 
         
        
          ) 
         
        
          = 
         
         
         
           ∑ 
          
          
          
            x 
           
          
            , 
           
          
            y 
           
          
         
        
          w 
         
        
          ( 
         
        
          x 
         
        
          , 
         
        
          y 
         
        
          ) 
         
        
          [ 
         
        
          I 
         
        
          ( 
         
        
          x 
         
        
          + 
         
        
          u 
         
        
          , 
         
        
          y 
         
        
          + 
         
        
          v 
         
        
          ) 
         
        
          − 
         
        
          I 
         
        
          ( 
         
        
          x 
         
        
          , 
         
        
          y 
         
        
          ) 
         
         
         
           ] 
          
         
           2 
          
         
        
       
         E(u,v) = \sum_{x,y} w(x, y)[I(x + u, y + v) - I(x, y)]^2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.4361em; vertical-align: -1.3861em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05em;"><span class="" style="top: -1.9em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">y</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.3861em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.1141em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><br> 其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         I 
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         y 
        
       
         ) 
        
       
      
        I(x, y) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span></span></span></span></span> 是像素点 (x, y) 的强度，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         y 
        
       
         ) 
        
       
      
        w(x, y) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span></span></span></span></span> 是窗口函数（通常是高斯窗口），用于赋予窗口中心附近的像素更高的权重。<br> 这个公式可以通过泰勒级数展开并简化，最终表示为：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          E 
         
        
          ( 
         
        
          u 
         
        
          , 
         
        
          v 
         
        
          ) 
         
        
          ≈ 
         
        
          [ 
         
        
          u 
         
        
          , 
         
        
          v 
         
        
          ] 
         
        
          M 
         
        
          [ 
         
        
          u 
         
        
          , 
         
        
          v 
         
         
         
           ] 
          
         
           T 
          
         
        
       
         E(u,v) ≈ [u, v] M [u, v]^T 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">E</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.1413em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mclose">]</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8913em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.1389em;">T</span></span></span></span></span></span></span></span></span></span></span></span></span><br> 其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         M 
        
       
      
        M 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span></span></span></span></span> 是由图像的梯度导数计算得出的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
         × 
        
       
         2 
        
       
      
        2 \times 2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>矩阵。</p> 
<p>Harris响应值的计算可以通过以下步骤进行：</p> 
<ol><li><strong>计算图像梯度</strong>：</li></ol> 
<blockquote> 
 <ul><li>需要计算图像在x和y方向的梯度，通常用Sobel算子来完成。这可以表示为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            I 
           
          
            x 
           
          
         
        
          I_x 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            I 
           
          
            y 
           
          
         
        
          I_y 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9694em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。</li></ul> 
</blockquote> 
<ol start="2"><li><strong>计算梯度的乘积</strong>：</li></ol> 
<blockquote> 
 <ul><li>计算梯度的乘积 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            I 
           
          
            x 
           
          
            2 
           
          
         
           , 
          
          
          
            I 
           
          
            y 
           
          
            2 
           
          
         
        
          I_x^2, I_y^2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.1972em; vertical-align: -0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -2.453em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.247em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -2.453em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">y</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            I 
           
          
            x 
           
          
          
          
            I 
           
          
            y 
           
          
         
        
          I_xI_y 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9694em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>。</li></ul> 
</blockquote> 
<ol start="3"><li><strong>应用高斯滤波</strong>：</li></ol> 
<blockquote> 
 <ul><li>对这些乘积应用高斯滤波（窗口函数），以在局部区域内平滑它们。这里使用高斯窗口是为了给图像的局部区域赋予更多的权重。</li></ul> 
</blockquote> 
<ol start="4"><li><strong>构造Harris矩阵</strong>：</li></ol> 
<blockquote> 
 <ul><li> <p>使用上述结果构造Harris矩阵（也称为结构张量），其一般形式为：</p> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             M 
            
           
             = 
            
            
            
              ( 
             
             
              
               
                
                 
                 
                   ∑ 
                  
                  
                  
                    I 
                   
                  
                    x 
                   
                  
                    2 
                   
                  
                 
                
               
               
                
                 
                 
                   ∑ 
                  
                  
                  
                    I 
                   
                  
                    x 
                   
                  
                  
                  
                    I 
                   
                  
                    y 
                   
                  
                 
                
               
              
              
               
                
                 
                 
                   ∑ 
                  
                  
                  
                    I 
                   
                  
                    x 
                   
                  
                  
                  
                    I 
                   
                  
                    y 
                   
                  
                 
                
               
               
                
                 
                 
                   ∑ 
                  
                  
                  
                    I 
                   
                  
                    y 
                   
                  
                    2 
                   
                  
                 
                
               
              
             
            
              ) 
             
            
           
          
            M = \begin{pmatrix} \sum I_x^2 &amp; \sum I_xI_y \\ \sum I_xI_y &amp; \sum I_y^2 \end{pmatrix} 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.4231em; vertical-align: -0.9616em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.4616em;"><span class="" style="top: -3.6216em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -2.453em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.247em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.4216em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.9616em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.4616em;"><span class="" style="top: -3.6216em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.4216em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -2.453em; margin-left: -0.0785em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">y</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3831em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.9616em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></span></p> </li><li> <p>其中，求和表示在窗口内对应像素值的求和。</p> </li></ul> 
</blockquote> 
<ol start="5"><li><strong>计算Harris响应值</strong>：</li></ol> 
<blockquote> 
 <ul><li> <p>计算每个像素的Harris响应值 R：</p> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             R 
            
           
             = 
            
           
             det 
            
           
             ( 
            
           
             M 
            
           
             ) 
            
           
             − 
            
           
             k 
            
           
             ⋅ 
            
           
             ( 
            
           
             trace 
            
           
             ( 
            
           
             M 
            
           
             ) 
            
            
            
              ) 
             
            
              2 
             
            
           
          
            R = \text{det}(M) - k \cdot (\text{trace}(M))^2 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">det</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.1141em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">trace</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p> </li><li> <p>其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            det 
           
          
            ( 
           
          
            M 
           
          
            ) 
           
          
         
           \text{det}(M) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">det</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mclose">)</span></span></span></span></span>是矩阵M的行列式，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            trace 
           
          
            ( 
           
          
            M 
           
          
            ) 
           
          
         
           \text{trace}(M) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">trace</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mclose">)</span></span></span></span></span>是矩阵的迹（即对角线元素的和），k是一个经验常数（通常介于0.04到0.06之间）。</p> </li></ul> 
</blockquote> 
<p>为了理解这个公式如何与M的特征值相关联，我们可以考虑矩阵M的特征分解。矩阵M的两个特征值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          λ 
         
        
          1 
         
        
       
      
        \lambda_1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          λ 
         
        
          2 
         
        
       
      
        \lambda_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 描述了图像在该点的两个主要方向的梯度强度。矩阵M的行列式是这两个特征值的乘积：</p> 
<blockquote> 
 <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           det 
          
         
           ( 
          
         
           M 
          
         
           ) 
          
         
           = 
          
          
          
            λ 
           
          
            1 
           
          
         
           ⋅ 
          
          
          
            λ 
           
          
            2 
           
          
         
        
          \text{det}(M) = \lambda_1 \cdot \lambda_2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">det</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></p> 
</blockquote> 
<p>而矩阵的迹是这两个特征值的和：</p> 
<blockquote> 
 <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           trace 
          
         
           ( 
          
         
           M 
          
         
           ) 
          
         
           = 
          
          
          
            λ 
           
          
            1 
           
          
         
           + 
          
          
          
            λ 
           
          
            2 
           
          
         
        
          \text{trace}(M) = \lambda_1 + \lambda_2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">trace</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></p> 
</blockquote> 
<p>因此，Harris响应值R可以重写为：</p> 
<blockquote> 
 <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           R 
          
         
           = 
          
          
          
            λ 
           
          
            1 
           
          
          
          
            λ 
           
          
            2 
           
          
         
           − 
          
         
           k 
          
         
           ( 
          
          
          
            λ 
           
          
            1 
           
          
         
           + 
          
          
          
            λ 
           
          
            2 
           
          
          
          
            ) 
           
          
            2 
           
          
         
        
          R = \lambda_1 \lambda_2 - k (\lambda_1 + \lambda_2)^2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.1141em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p> 
</blockquote> 
<ol start="6"><li><strong>角点的识别</strong></li></ol> 
<blockquote> 
 <ul><li>根据Harris响应值R，可以判断每个像素是否是角点： 
   <ul><li>如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             R 
            
           
          
            R 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span></span></span></span></span> 很大，那么该点可能是角点。</li><li>如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             R 
            
           
          
            R 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span></span></span></span></span> 很小或接近零，那么该点可能是平坦区域。</li><li>如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             R 
            
           
          
            R 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span></span></span></span></span> 为负值，那么该点可能是边缘。</li></ul> </li></ul> 
</blockquote> 
<p><strong>Harris角点检测限制：</strong><br> 尽管Harris角点检测是一种强大的工具，但它也有局限性。例如，它不是尺度不变的，这意味着在图像尺度显著变化时，检测到的角点可能会变化。此外，它对噪声比较敏感，并且在处理高度结构化的图像时可能会产生误检。</p> 
<h4><a id="123__147"></a>1.2.3 代码实现</h4> 
<p>在OpenCV中，可以通过<code>cv2.cornerHarris()</code>函数实现Harris角点检测。下面是一个简单的示例代码：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token comment"># 读取图像</span>
img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">)</span>
gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>

<span class="token comment"># Harris角点检测</span>
gray <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>gray<span class="token punctuation">)</span>
dst <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cornerHarris<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> blockSize<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> ksize<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">0.04</span><span class="token punctuation">)</span>

<span class="token comment"># 结果阈值化以确定角点位置</span>
dst <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
thresh <span class="token operator">=</span> <span class="token number">0.01</span> <span class="token operator">*</span> dst<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
img<span class="token punctuation">[</span>dst <span class="token operator">&gt;</span> thresh<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">]</span>

<span class="token comment"># 绘制圆圈标记角点</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> dst<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> thresh<span class="token punctuation">:</span>
            <span class="token comment"># 绘制圆圈</span>
            cv2<span class="token punctuation">.</span>circle<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> radius<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> thickness<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token comment"># 显示图像</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'Harris Corners'</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>在这段代码中，<code>cv2.cornerHarris()</code>函数接受几个参数：输入图像、邻域大小（blockSize）、用于边缘检测的Sobel算子的孔径大小（ksize）和Harris检测器的自由参数（k）。函数返回每个像素的Harris响应值。通过设置一个阈值，可以选择性地显示角点。<br> <img src="https://images2.imgbox.com/41/11/FGwomeDy_o.png" alt="Harris Corners" width="300"></p> 
<h4><a id="124__183"></a>1.2.4 函数解析</h4> 
<p><code>cornerHarris</code> 用于角点检测的一个函数。它实现了 Harris 角点检测算法，该算法能够在图像中有效地识别角点。</p> 
<blockquote> 
 <p><code>def cornerHarris(src, blockSize, ksize, k, dst=None, borderType=None)</code></p> 
 <ol><li> <p><strong>src (Source Image)</strong>： 输入图像，它应该是单通道（灰度）的，数据类型可以是 8 位或者浮点型。这是函数进行处理的原始图像。</p> </li><li> <p><strong>blockSize</strong>： 它指的是用于角点检测的邻域大小。简单来说，它是在每个像素周围考虑用于角点检测的像素块的大小。较大的块将考虑更多的像素，可能更适合于检测大的角点特征。</p> </li><li> <p><strong>ksize (Kernel Size)</strong>： Sobel算子的孔径参数。这个参数决定了用于计算图像梯度的Sobel卷积核的大小。这直接影响到图像梯度的计算，进而影响角点检测的结果。</p> </li><li> <p><strong>k</strong>： Harris检测器的自由参数，用于在响应函数中加权角点的测量。它影响了角点检测的敏感度，通常在 0.04 到 0.06 之间。</p> </li><li> <p><strong>dst (Destination Image)</strong>： 用于存储 Harris 检测器响应的图像。它的类型是 <code>CV_32FC1</code>，与输入图像 <code>src</code> 有相同的大小。</p> </li><li> <p><strong>borderType</strong>： 像素外推法的类型。在进行图像梯度计算时，需要对边缘像素周围进行像素值的外推。这个参数指定了所使用的外推方法。常见的外推方法包括反射外推、常量外推等。</p> </li></ol> 
 <p>函数的主要功能是在输入图像上运行 Harris 角点检测器。它会计算每个像素的响应值，这些响应值可以用来确定图像中的角点位置。角点可以被识别为这些响应值的局部最大值。</p> 
</blockquote> 
<h3><a id="13_ShiTomasi_201"></a>1.3 Shi-Tomasi角点检测</h3> 
<p>Shi-Tomasi角点检测方法是基于Harris角点检测的一种改进，它在多个方面提供了更好的性能和精度。Shi-Tomasi方法的核心思想是通过评估图像的最小特征值来识别角点。</p> 
<h4><a id="131_ShiTomasi_204"></a>1.3.1 Shi-Tomasi角点检测原理</h4> 
<p>Shi-Tomasi方法的基本原理与Harris角点检测类似，都是基于图像局部区域的自相关矩阵。不同之处在于，Shi-Tomasi方法使用了自相关矩阵的最小特征值来评估角点的质量。</p> 
<p>对于图像中的每个点，首先计算其周围区域的自相关矩阵。然后，计算该矩阵的两个特征值（记为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          λ 
         
        
          1 
         
        
       
      
        \lambda_1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          λ 
         
        
          2 
         
        
       
      
        \lambda_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>）。在Shi-Tomasi方法中，如果这两个特征值都大于某个阈值，则该点被认为是角点。</p> 
<h4><a id="132_ShiTomasi_210"></a>1.3.2 Shi-Tomasi角点检测公式</h4> 
<p>Shi-Tomasi方法的角点响应函数定义为：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          R 
         
        
          = 
         
        
          min 
         
        
          ⁡ 
         
        
          ( 
         
         
         
           λ 
          
         
           1 
          
         
        
          , 
         
         
         
           λ 
          
         
           2 
          
         
        
          ) 
         
        
       
         R = \min(\lambda_1, \lambda_2) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p> 
<p>其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          λ 
         
        
          1 
         
        
       
         , 
        
        
        
          λ 
         
        
          2 
         
        
       
      
        \lambda_1, \lambda_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是自相关矩阵的特征值。</p> 
<h4><a id="133__218"></a>1.3.3 代码实现</h4> 
<p>在OpenCV中，Shi-Tomasi角点检测可以通过 <code>cv2.goodFeaturesToTrack()</code> 函数实现。以下是一个简单的示例代码：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2

<span class="token comment"># 读取图像</span>
img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">)</span>
gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>

<span class="token comment"># Shi-Tomasi角点检测</span>
corners <span class="token operator">=</span> cv2<span class="token punctuation">.</span>goodFeaturesToTrack<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> maxCorners<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> qualityLevel<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> minDistance<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>

<span class="token comment"># 绘制角点</span>
<span class="token keyword">for</span> corner <span class="token keyword">in</span> corners<span class="token punctuation">:</span>
    x<span class="token punctuation">,</span> y <span class="token operator">=</span> corner<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span>
    cv2<span class="token punctuation">.</span>circle<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token comment"># 显示图像</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'Shi-Tomasi Corners'</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/5d/28/eJ7DYKHW_o.png" alt="Shi-Tomasi Corners" width="300"></p> 
<p>在这段代码中：</p> 
<ul><li><code>cv2.goodFeaturesToTrack()</code> 函数接收几个参数：输入图像、要检测的角点最大数量（<code>maxCorners</code>）、角点质量等级（<code>qualityLevel</code>，一个介于 0 到 1 之间的数，代表最小特征值的相对值）和角点之间的最小距离（<code>minDistance</code>）。</li><li>检测到的角点以 <code>(x, y)</code> 坐标的形式返回。</li></ul> 
<h4><a id="134__248"></a>1.3.4 函数解析</h4> 
<p><code>goodFeaturesToTrack</code> 用于角点检测的函数，它实现了 Shi-Tomasi 方法。下面是该函数各个参数的简要说明：</p> 
<blockquote> 
 <p><code>def goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance, corners=None, mask=None, blockSize=None, useHarrisDetector=None, k=None)</code></p> 
 <ol><li> <p><strong>image</strong>： 输入的图像。它应该是单通道的8位或者浮点型32位图像。</p> </li><li> <p><strong>maxCorners</strong>： 要返回的角点的最大数量。如果检测到的角点多于此数值，将返回最强的 <code>maxCorners</code> 个角点。如果 <code>maxCorners &lt;= 0</code>，则返回检测到的所有角点。</p> </li><li> <p><strong>qualityLevel</strong>： 角点质量的特征值阈值。这个参数乘以图像中最佳角点的质量测量值（最小特征值或哈里斯函数响应），得到的乘积用于剔除质量较低的角点。</p> </li><li> <p><strong>minDistance</strong>： 返回角点之间的最小可能欧几里得距离。这用于确保选取的角点之间有一定的空间分隔。</p> </li><li> <p><strong>corners</strong>： 检测到的角点的输出向量。</p> </li><li> <p><strong>mask</strong>： 感兴趣区域的掩码。如果提供，它必须是类型为 <code>CV_8UC1</code> 且大小与 <code>image</code> 相同的二值图像。在掩码非零的区域内检测角点。</p> </li><li> <p><strong>blockSize</strong>： 计算导数协方差矩阵时考虑的邻域大小。</p> </li><li> <p><strong>useHarrisDetector</strong>： 指示是否使用哈里斯角点检测器。如果不使用，则应用最小特征值方法（Shi-Tomasi方法）。</p> </li><li> <p><strong>k</strong>： 仅当使用哈里斯检测器时使用的自由参数。</p> </li></ol> 
</blockquote> 
<h3><a id="14_FAST_270"></a>1.4 FAST角点检测</h3> 
<p>FAST（Features from Accelerated Segment Test）算法是一种广泛使用的角点检测方法。它以高速和简洁著称，在许多实时图像处理系统中发挥着重要作用。</p> 
<h4><a id="141_FAST_273"></a>1.4.1 FAST角点检测原理</h4> 
<blockquote> 
 <ol><li><strong>选择像素点</strong>： 选择图像中的一个像素点P作为检测的中心点。</li><li><strong>设置亮度阈值</strong>： 设定一个阈值T，用于与中心像素点P的亮度进行比较。</li><li><strong>环形邻域检测</strong>： 在中心点P周围选择一个圆形邻域（通常包含16个像素点），用于判断P是否为角点。</li><li><strong>连续性检查</strong>： 检查圆形邻域上是否有至少N个连续的像素点其亮度高于（或低于）P的亮度加上（或减去）阈值T。通常N设为12。</li><li><strong>非极大值抑制</strong>： 应用非极大值抑制（Non-Maximum Suppression）技术，去除响应较弱的角点，只保留最显著的角点。</li></ol> 
</blockquote> 
<h4><a id="142_FAST_281"></a>1.4.2 FAST角点检测特点和应用</h4> 
<ul><li><strong>速度快</strong>： 简洁的算法结构使得FAST算法执行速度非常快，适用于实时系统和高帧率视频。</li><li><strong>广泛应用</strong>： 在机器人导航、视频追踪、三维建模和运动检测等领域有广泛应用。</li><li><strong>局限性</strong>： 对噪声敏感，不具备尺度不变性。常与其他算法结合使用以克服这些限制。</li></ul> 
<h4><a id="143__287"></a>1.4.3 代码实现</h4> 
<p>下面是一个基本的代码示例：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2

<span class="token comment"># 读取图像</span>
image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">)</span>

<span class="token comment"># 初始化FAST对象</span>
fast <span class="token operator">=</span> cv2<span class="token punctuation">.</span>FastFeatureDetector_create<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>

<span class="token comment"># 检测角点</span>
keypoints <span class="token operator">=</span> fast<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>image<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>

<span class="token comment"># 在图像上绘制角点</span>
image_with_keypoints <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawKeypoints<span class="token punctuation">(</span>image<span class="token punctuation">,</span> keypoints<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 显示图像</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'FAST Keypoints'</span><span class="token punctuation">,</span> image_with_keypoints<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d8/ab/q6KyIvcV_o.png" alt="FAST Keypoints" width="300"></p> 
<h4><a id="144__313"></a>1.4.4 函数解析</h4> 
<p><code>FastFeatureDetector_create</code> 用于创建 FAST检测器的函数。</p> 
<blockquote> 
 <p><code>def FastFeatureDetector_create(threshold=None, nonmaxSuppression=None, type=None)</code></p> 
 <ol><li> <p><strong>threshold</strong>： 用于决定角点的阈值。它是用来判断一个像素是否为角点的亮度或颜色强度变化的阈值。阈值越高，检测到的角点越少，但质量可能更高。</p> </li><li> <p><strong>nonmaxSuppression</strong>： 非极大值抑制。当设置为 <code>True</code> 时，算法会在检测到的角点周围使用非极大值抑制，以确保检测到的角点是局部最大值，这样可以避免在角点附近检测到多个相邻的角点。通常，启用非极大值抑制会得到更好的结果。</p> </li><li> <p><strong>type</strong>： 指定 FAST 算法的类型。OpenCV 提供了不同版本的 FAST 算法，例如，TYPE_9_16、TYPE_7_12 等。这些类型指定了用于角点检测的圆形邻域的不同大小。</p> </li></ol> 
</blockquote> 
<h3><a id="15__323"></a>1.5 亚像素角点检测</h3> 
<p>亚像素角点检测是一种提高角点定位精度到亚像素级别的技术。传统的角点检测方法，如哈里斯角点检测，通常只能定位到像素级别的精度。而在一些应用中，如高精度的图像对准和三维重建，需要更高精度的角点定位。亚像素角点检测通过对角点周围的像素进行精细分析，实现了这一目标。</p> 
<h4><a id="151__327"></a>1.5.1 亚像素角点检测原理</h4> 
<p>亚像素角点检测的基本原理是利用图像局部区域的灰度分布信息来精细调整角点的位置。它通常包括以下几个步骤：</p> 
<blockquote> 
 <ol><li> <p><strong>初步角点检测</strong>：首先使用常规方法（如哈里斯角点检测）在图像中定位角点的大致位置。</p> </li><li> <p><strong>定义局部窗口</strong>：围绕每个初步检测到的角点，定义一个小的局部窗口。</p> </li><li> <p><strong>灰度质心计算</strong>：在这个局部窗口中，计算灰度质心，这可以视为图像局部区域质量的“中心”。基于灰度质心的位置，可以对初步检测到的角点位置进行微调。</p> </li><li> <p><strong>迭代优化</strong>：通过迭代的方式细化角点位置，直到满足一定的精度要求。</p> </li></ol> 
</blockquote> 
<h4><a id="152__339"></a>1.5.2 亚像素角点检测公式</h4> 
<p>亚像素角点检测的关键公式是灰度质心的计算。灰度质心的坐标 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
        
        
          x 
         
        
          c 
         
        
       
         , 
        
        
        
          y 
         
        
          c 
         
        
       
         ) 
        
       
      
        (x_c, y_c) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 可以用下面的公式计算：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           x 
          
         
           c 
          
         
        
          = 
         
         
          
          
            ∑ 
           
           
           
             x 
            
           
             i 
            
           
           
           
             w 
            
           
             i 
            
           
          
          
          
            ∑ 
           
           
           
             w 
            
           
             i 
            
           
          
         
        
          , 
         
         
         
         
           y 
          
         
           c 
          
         
        
          = 
         
         
          
          
            ∑ 
           
           
           
             y 
            
           
             i 
            
           
           
           
             w 
            
           
             i 
            
           
          
          
          
            ∑ 
           
           
           
             w 
            
           
             i 
            
           
          
         
        
       
         x_c = \frac{\sum x_i w_i}{\sum w_i}, \quad y_c = \frac{\sum y_i w_i}{\sum w_i} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.363em; vertical-align: -0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.427em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.936em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.363em; vertical-align: -0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.427em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.936em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<p>其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          i 
         
        
       
         , 
        
        
        
          y 
         
        
          i 
         
        
       
      
        x_i, y_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是局部窗口中像素的坐标，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          w 
         
        
          i 
         
        
       
      
        w_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是相应像素的灰度值。</p> 
<h4><a id="153__349"></a>1.5.3 代码实现</h4> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token comment"># 读取图像</span>
img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">)</span>
gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>

<span class="token comment"># Harris角点检测</span>
gray <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>gray<span class="token punctuation">)</span>
dst <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cornerHarris<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> blockSize<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> ksize<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">0.04</span><span class="token punctuation">)</span>

<span class="token comment"># 结果阈值化，获取角点位置</span>
dst <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
_<span class="token punctuation">,</span> dst <span class="token operator">=</span> cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token number">0.01</span> <span class="token operator">*</span> dst<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
dst <span class="token operator">=</span> np<span class="token punctuation">.</span>uint8<span class="token punctuation">(</span>dst<span class="token punctuation">)</span>

<span class="token comment"># 寻找质心并创建关键点集</span>
_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> centroids <span class="token operator">=</span> cv2<span class="token punctuation">.</span>connectedComponentsWithStats<span class="token punctuation">(</span>dst<span class="token punctuation">)</span>
criteria <span class="token operator">=</span> <span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>TERM_CRITERIA_EPS <span class="token operator">+</span> cv2<span class="token punctuation">.</span>TERM_CRITERIA_MAX_ITER<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span>
corners <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cornerSubPix<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>centroids<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> criteria<span class="token punctuation">)</span>
keypoints <span class="token operator">=</span> <span class="token punctuation">[</span>cv2<span class="token punctuation">.</span>KeyPoint<span class="token punctuation">(</span>x<span class="token operator">=</span>corner<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span>corner<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> _size<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">for</span> corner <span class="token keyword">in</span> corners<span class="token punctuation">]</span>

<span class="token comment"># 使用drawKeypoints绘制关键点</span>
img_keypoints <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawKeypoints<span class="token punctuation">(</span>img<span class="token punctuation">,</span> keypoints<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 显示图像</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'Harris Corners'</span><span class="token punctuation">,</span> img_keypoints<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2d/7b/52MpOh49_o.png" alt="Harris Corners" width="300"><br> 这段代码的目的是在使用 Harris 角点检测后，找到检测到的角点的精确位置，并将它们转换为关键点对象，以便进一步处理或可视化。</p> 
<h4><a id="154__383"></a>1.5.4 函数解析</h4> 
<p><strong>1. <code>cv2.connectedComponentsWithStats</code></strong></p> 
<pre><code class="prism language-python">ret<span class="token punctuation">,</span> labels<span class="token punctuation">,</span> stats<span class="token punctuation">,</span> centroids <span class="token operator">=</span> cv2<span class="token punctuation">.</span>connectedComponentsWithStats<span class="token punctuation">(</span>dst<span class="token punctuation">)</span>
</code></pre> 
<ul><li><code>cv2.connectedComponentsWithStats</code> 函数用于分析二值图像，并找出图像中所有连通区域（即相互连接的像素块）。</li><li><code>dst</code> 是 Harris 角点检测的结果，通常经过阈值处理以获得二值图像。</li><li>函数返回几个值： 
  <ul><li><code>ret</code>： 连通区域的数量。</li><li><code>labels</code>： 图像大小的数组，其中的每个元素表示对应像素属于的连通区域的标签。</li><li><code>stats</code>： 每个连通区域的统计信息，如区域的大小、边界框等。</li><li><code>centroids</code>： 每个连通区域的质心（中心点）坐标。</li></ul> </li></ul> 
<p><strong>2. <code>cv2.cornerSubPix</code></strong> 亚像素检测函数</p> 
<pre><code class="prism language-python">criteria <span class="token operator">=</span> <span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>TERM_CRITERIA_EPS <span class="token operator">+</span> cv2<span class="token punctuation">.</span>TERM_CRITERIA_MAX_ITER<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span>
corners <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cornerSubPix<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>centroids<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> criteria<span class="token punctuation">)</span>
</code></pre> 
<ul><li>这部分代码首先设置了迭代寻找角点的标准，即 <code>criteria</code>。这里使用了两个条件：迭代次数达到 100 或者角点位置变化小于 0.001。</li><li><code>cv2.cornerSubPix</code> 函数用于进一步精细化角点的位置。它基于初始的质心位置（即 <code>centroids</code>），在一个小的邻域内寻找更精确的角点位置。</li><li>参数 <code>gray</code> 是原始的灰度图像，<code>np.float32(centroids)</code> 是上一步得到的质心坐标，<code>(5,5)</code> 是搜索窗口的大小，<code>(-1,-1)</code> 是死区的半径，通常不需要更改。</li></ul> 
<p><strong>3. 创建关键点对象</strong></p> 
<pre><code class="prism language-python">keypoints <span class="token operator">=</span> <span class="token punctuation">[</span>cv2<span class="token punctuation">.</span>KeyPoint<span class="token punctuation">(</span>x<span class="token operator">=</span>corner<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span>corner<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> _size<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">for</span> corner <span class="token keyword">in</span> corners<span class="token punctuation">]</span>
</code></pre> 
<ul><li>这行代码将 <code>cv2.cornerSubPix</code> 函数找到的角点坐标转换为 OpenCV 的 <code>KeyPoint</code> 对象。</li><li>每个 <code>KeyPoint</code> 对象包含了角点的位置和其他属性（如大小、方向等）。这里，我们只设置了位置（<code>x</code> 和 <code>y</code> 坐标）和大小（<code>_size</code>），大小设为 20 仅为了可视化时更容易观察。</li></ul> 
<h2><a id="_418"></a>二、特征点检测</h2> 
<p>特征点检测是指在图像中寻找具有独特属性的点，这些点在不同图像之间可以被匹配和识别。OpenCV提供了几种常用的特征点检测方法，如SIFT、SURF和ORB。</p> 
<p><mark>环境检查</mark><br> 运行本章代码时，请先检查Python和OpenCV的版本。<br> 尤其在遇到报错：<code>AttributeError: module 'cv2' has no attribute 'xfeatures2d_SIFT'</code>或者<code>AttributeError: module 'cv2' has no attribute 'xfeatures2d'</code>的时候，参考下面的内容。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> sys

<span class="token comment"># 检查当前Python的版本</span>
current_python_version <span class="token operator">=</span> sys<span class="token punctuation">.</span>version_info

<span class="token comment"># 检查Python版本是否是3.6</span>
<span class="token keyword">if</span> current_python_version<span class="token punctuation">.</span>major <span class="token operator">!=</span> <span class="token number">3</span> <span class="token keyword">or</span> current_python_version<span class="token punctuation">.</span>minor <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">:</span>
    python_version_message <span class="token operator">=</span> <span class="token string">"当前Python版本不是3.6，建议安装Python 3.6版本。"</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    python_version_message <span class="token operator">=</span> <span class="token string">"当前Python版本是3.6。满足运行环境。"</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>python_version_message<span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-python"><span class="token keyword">import</span> pkg_resources

<span class="token comment"># 设置所需检查的OpenCV版本</span>
required_opencv_version <span class="token operator">=</span> <span class="token string">"3.4.2.16"</span>
required_opencv_contrib_version <span class="token operator">=</span> <span class="token string">"3.4.2.16"</span>

<span class="token comment"># 检查安装的OpenCV和opencv-contrib-python版本</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    installed_opencv_version <span class="token operator">=</span> pkg_resources<span class="token punctuation">.</span>get_distribution<span class="token punctuation">(</span><span class="token string">"opencv-python"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>version
<span class="token keyword">except</span> pkg_resources<span class="token punctuation">.</span>DistributionNotFound<span class="token punctuation">:</span>
    installed_opencv_version <span class="token operator">=</span> <span class="token boolean">None</span>

<span class="token keyword">try</span><span class="token punctuation">:</span>
    installed_opencv_contrib_version <span class="token operator">=</span> pkg_resources<span class="token punctuation">.</span>get_distribution<span class="token punctuation">(</span><span class="token string">"opencv-contrib-python"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>version
<span class="token keyword">except</span> pkg_resources<span class="token punctuation">.</span>DistributionNotFound<span class="token punctuation">:</span>
    installed_opencv_contrib_version <span class="token operator">=</span> <span class="token boolean">None</span>

<span class="token comment"># 构造安装提示信息</span>
<span class="token keyword">if</span> installed_opencv_version <span class="token operator">!=</span> required_opencv_version <span class="token keyword">or</span> installed_opencv_contrib_version <span class="token operator">!=</span> required_opencv_contrib_version<span class="token punctuation">:</span>
    opencv_installation_message <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
    # 卸载之前的OpenCV 
    pip uninstall opencv-python
    
    # 安装指定版本的OpenCV和opencv-contrib-python
    pip install opencv-python==3.4.2.16
    pip install opencv-contrib-python==3.4.2.16
    """</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    opencv_installation_message <span class="token operator">=</span> <span class="token string">"OpenCV和opencv-contrib-python版本正确。"</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>opencv_installation_message<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="21_SIFT_473"></a>2.1 SIFT（尺度不变特征变换）</h3> 
<p>SIFT是一种用于检测和描述图像中的局部特征的算法。它在不同尺度的图像上查找关键点，并对每个关键点周围的区域进行特征描述。</p> 
<h4><a id="211_SIFT_476"></a>2.1.1 SIFT原理</h4> 
<p>SIFT算法的主要思想是在不同尺度空间上寻找关键点，并计算这些关键点的方向直方图作为特征。这些关键点对尺度和旋转具有不变性。</p> 
<blockquote> 
 <ol><li><strong>尺度空间极值检测</strong>：通过高斯差分函数在不同尺度空间查找潜在的兴趣点。</li><li><strong>关键点定位</strong>：精确确定关键点的位置和尺度，去除低对比度的点和边缘响应点以增强匹配稳定性。</li><li><strong>方向赋值</strong>：为每个关键点赋予一个或多个方向，基于局部图像梯度方向。</li><li><strong>关键点描述</strong>：在每个关键点周围的区域内，计算其局部梯度的方向和幅度，生成描述符。</li></ol> 
</blockquote> 
<h4><a id="212__484"></a>2.1.2 代码实现</h4> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2

img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">)</span>
gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>

sift <span class="token operator">=</span> cv2<span class="token punctuation">.</span>xfeatures2d<span class="token punctuation">.</span>SIFT_create<span class="token punctuation">(</span><span class="token punctuation">)</span>
keypoints<span class="token punctuation">,</span> descriptors <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>

img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawKeypoints<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> keypoints<span class="token punctuation">,</span> img<span class="token punctuation">,</span>flags<span class="token operator">=</span>cv2<span class="token punctuation">.</span>DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'SIFT Features'</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/26/74/R9FMv7Xq_o.png" alt="SIFT Features" width="300"></p> 
<h4><a id="213__501"></a>2.1.3 函数解析</h4> 
<p><strong>SIFT_create</strong></p> 
<p><code>SIFT_create</code> 函数用于创建一个 SIFT 检测器对象。</p> 
<blockquote> 
 <p><code>def SIFT_create(nfeatures=None, nOctaveLayers=None, contrastThreshold=None, edgeThreshold=None, sigma=None)</code></p> 
 <ol><li> <p><strong>nfeatures</strong>： 要保留的最佳特征数量。特征按其分数（在 SIFT 算法中作为局部对比度测量）排名。</p> </li><li> <p><strong>nOctaveLayers</strong>： 每个八度中的层数。D. Lowe 的论文中使用的值是3。八度的数量是根据图像分辨率自动计算的。</p> </li><li> <p><strong>contrastThreshold</strong>： 用于过滤掉半均匀（低对比度）区域中的弱特征的对比度阈值。阈值越大，检测器产生的特征越少。</p> </li><li> <p><strong>edgeThreshold</strong>： 用于过滤掉边缘特征的阈值。注意其含义与 contrastThreshold 不同，即 edgeThreshold 越大，过滤掉的特征越少（保留的特征越多）。</p> </li><li> <p><strong>sigma</strong>： 应用于第0个八度的输入图像的高斯模糊的 sigma 值。如果您的图像是用软镜头拍摄的低品质相机捕获的，可能需要减小这个值。</p> </li></ol> 
</blockquote> 
<p><strong>detectAndCompute</strong></p> 
<p><code>detectAndCompute</code> 方法用于在图像中检测关键点并为它们计算描述符。</p> 
<blockquote> 
 <p><code>def detectAndCompute(self, image, mask, descriptors=None, useProvidedKeypoints=None)</code></p> 
 <ol><li> <p><strong>image</strong>： 要处理的图像。</p> </li><li> <p><strong>mask</strong>： 掩码图像，用于定义图像中要处理的区域。</p> </li><li> <p><strong>descriptors</strong>： 计算得到的描述符将被存储在这里。</p> </li><li> <p><strong>useProvidedKeypoints</strong>： 如果为 True，则该方法只计算指定关键点的描述符而不检测新的关键点。</p> </li></ol> 
</blockquote> 
<p>这两个函数结合使用，可以在图像中检测并描述关键点，这些关键点及其描述符可用于后续的图像匹配和识别任务。</p> 
<h3><a id="22_SURF_533"></a>2.2 SURF（加速稳健特征）</h3> 
<p>SURF是一种比SIFT更快的特征检测算法，同时保持了相似的特征描述能力。它对于快速和高效的图像匹配非常有用。</p> 
<h4><a id="221_SURF_536"></a>2.2.1 SURF原理</h4> 
<p>SURF算法改进了SIFT的计算效率。它使用积分图像快速计算高斯哈尔小波响应，并在多个尺度上寻找关键点。</p> 
<blockquote> 
 <ol><li><strong>尺度空间构建</strong>：利用积分图像提高了尺度空间构建的速度。</li><li><strong>关键点检测</strong>：在不同尺度上使用盒子滤波器（近似高斯滤波器）查找关键点。</li><li><strong>关键点描述</strong>：计算关键点周围的简化的Haar波特征描述符。</li></ol> 
</blockquote> 
<h4><a id="222__543"></a>2.2.2 代码实现</h4> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2

img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">)</span>
gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>

surf <span class="token operator">=</span> cv2<span class="token punctuation">.</span>xfeatures2d<span class="token punctuation">.</span>SURF_create<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
keypoints<span class="token punctuation">,</span> descriptors <span class="token operator">=</span> surf<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>

img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawKeypoints<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> keypoints<span class="token punctuation">,</span> img<span class="token punctuation">,</span>flags<span class="token operator">=</span>cv2<span class="token punctuation">.</span>DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'SURF Features'</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/58/50/CO6JyiQk_o.png" alt="SURF Features" width="300"></p> 
<h4><a id="223__559"></a>2.2.3 函数解析</h4> 
<p><code>SURF_create</code> 函数用于创建一个 SURF 检测器对象。</p> 
<blockquote> 
 <p><code>def SURF_create(hessianThreshold=None, nOctaves=None, nOctaveLayers=None, extended=None, upright=None)</code></p> 
 <ol><li> <p><strong>hessianThreshold</strong>： 用于 Hessian 关键点检测器的阈值。该值决定了关键点的选择——阈值越高，检测到的特征点越少但更显著。</p> </li><li> <p><strong>nOctaves</strong>： 关键点检测器将使用的金字塔八度数。金字塔的每个八度包含图像的一个下采样版本。</p> </li><li> <p><strong>nOctaveLayers</strong>： 每个八度内的层数。这影响到特征检测的尺度敏感性。</p> </li><li> <p><strong>extended</strong>： 扩展描述符标志（true - 使用扩展的128元素描述符；false - 使用64元素描述符）。扩展描述符提供更多的特征信息，但也增加了计算复杂度。</p> </li><li> <p><strong>upright</strong>： 是否计算特征的方向（true - 不计算特征的方向；false - 计算方向）。如果图像不会出现旋转变换，设置为 true 可以加快特征检测速度。</p> </li></ol> 
</blockquote> 
<p>SURF可以在图像中检测并描述关键点，这些关键点及其描述符可用于图像匹配、对象识别等后续任务。SURF 由于其计算效率，经常用于实时或资源受限的应用场景。</p> 
<h3><a id="23_ORB_573"></a>2.3 ORB（方向快速和旋转二进制）</h3> 
<p>ORB是一种结合了FAST关键点检测和BRIEF关键点描述的算法，以其速度和效率而著称。</p> 
<h4><a id="231_ORB_576"></a>2.3.1 ORB原理</h4> 
<p>ORB算法通过结合FAST算法的关键点检测和BRIEF算法的描述子，提供了一种快速且有效的特征点检测和描述方法。</p> 
<ol><li><strong>FAST关键点检测</strong>：使用FAST算法检测角点。</li><li><strong>BRIEF描述子</strong>：通过一种旋转不变的方式计算关键点的BRIEF描述子。</li><li><strong>多尺度特征</strong>：在不同尺度上重复检测过程以确保尺度不变性。</li></ol> 
<h4><a id="232__583"></a>2.3.2 代码实现</h4> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2

img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">)</span>
gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>

orb <span class="token operator">=</span> cv2<span class="token punctuation">.</span>ORB_create<span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span>
keypoints<span class="token punctuation">,</span> descriptors <span class="token operator">=</span> orb<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>

img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawKeypoints<span class="token punctuation">(</span>gray<span class="token punctuation">,</span> keypoints<span class="token punctuation">,</span> img<span class="token punctuation">,</span> flags<span class="token operator">=</span>cv2<span class="token punctuation">.</span>DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'ORB Features'</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/37/3c/fhrAHT4o_o.png" alt="ORB Features" width="300"></p> 
<h4><a id="233__599"></a>2.3.3 函数解析</h4> 
<p><code>ORB_create</code> 函数用于创建一个 ORB 检测器对象。</p> 
<blockquote> 
 <p><code>def ORB_create(nfeatures=None, scaleFactor=None, nlevels=None, edgeThreshold=None, firstLevel=None, WTA_K=None, scoreType=None, patchSize=None, fastThreshold=None)</code></p> 
 <ol><li> <p><strong>nfeatures</strong>： 要保留的最大特征点数。</p> </li><li> <p><strong>scaleFactor</strong>： 金字塔降采样比例，大于1。标准金字塔中scaleFactor=2，意味着每个级别的像素是前一个级别的1/4。</p> </li><li> <p><strong>nlevels</strong>： 金字塔的层数。最小层的尺寸等于输入图像尺寸除以scaleFactor的nlevels - firstLevel次方。</p> </li><li> <p><strong>edgeThreshold</strong>： 不检测特征的边缘大小，应大致匹配patchSize参数。</p> </li><li> <p><strong>firstLevel</strong>： 将原始图像放置在金字塔的哪一层。前面的层由放大的原图填充。</p> </li><li> <p><strong>WTA_K</strong>： 用于生成每个BRIEF描述符元素的点数。默认值为2，意味着对亮度进行简单的比较。</p> </li><li> <p><strong>scoreType</strong>： 特征点评分类型。HARRIS_SCORE 使用 Harris 算法对特征点进行评分；FAST_SCORE 是另一种稍不稳定但计算速度更快的选项。</p> </li><li> <p><strong>patchSize</strong>： 用于计算BRIEF描述符的补丁大小。</p> </li><li> <p><strong>fastThreshold</strong>： FAST 算子的阈值。</p> </li></ol> 
</blockquote> 
<p>ORB 的使用可以快速有效地在图像中检测和描述关键点，这些关键点及其描述符可用于图像匹配、对象识别等任务。ORB 算法因其高效性在移动和实时应用中特别受欢迎。</p> 
<h2><a id="_622"></a>三、特征点匹配</h2> 
<p>特征点匹配是在不同图像中找到相同特征点的过程。在OpenCV中，常用的方法包括BF匹配器（Brute-Force Matcher）和FLANN匹配器（Fast Library for Approximate Nearest Neighbors）。</p> 
<h3><a id="31_BF_626"></a>3.1 BF匹配器</h3> 
<p>BF匹配器是一种简单直接的匹配方法，主要通过计算一个特征描述子与其他所有描述子之间的距离，然后选择距离最小的匹配对。</p> 
<h4><a id="311_BF_630"></a>3.1.1 BF匹配器原理</h4> 
<blockquote> 
 <ul><li><strong>距离计算</strong>：BF匹配器对一个特征集合中的每个特征描述子，计算它与另一个特征集合中所有特征描述子之间的距离。</li><li><strong>最佳匹配选择</strong>：然后，选择距离最小的特征对作为匹配对。</li><li><strong>距离度量</strong>：常用的距离度量包括欧氏距离、哈明距离等，具体使用哪种距离度量取决于描述子的类型。</li></ul> 
</blockquote> 
<h4><a id="312__636"></a>3.1.2 代码实现</h4> 
<p><code>tulips_template.jpg</code><br> <img src="https://images2.imgbox.com/80/46/CnywCt36_o.jpg" alt="tulips_template"></p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token comment"># 读取图像</span>
img1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
img2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips_template.jpg'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
img2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span>img2<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>ROTATE_90_COUNTERCLOCKWISE<span class="token punctuation">)</span>
<span class="token comment"># 初始化SIFT检测器</span>
sift <span class="token operator">=</span> cv2<span class="token punctuation">.</span>xfeatures2d_SIFT<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 使用SIFT找到关键点和描述子</span>
kp1<span class="token punctuation">,</span> des1 <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
kp2<span class="token punctuation">,</span> des2 <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>

<span class="token comment"># 创建BF匹配器对象</span>
bf <span class="token operator">=</span> cv2<span class="token punctuation">.</span>BFMatcher<span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>NORM_L2<span class="token punctuation">,</span> crossCheck<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

<span class="token comment"># 执行匹配</span>
matches <span class="token operator">=</span> bf<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span>des1<span class="token punctuation">,</span> des2<span class="token punctuation">)</span>

<span class="token comment"># 绘制匹配</span>
img3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawMatches<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> kp1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> matches<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>cv2<span class="token punctuation">.</span>DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS<span class="token punctuation">)</span>

<span class="token comment"># 展示结果</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'BF Matcher'</span><span class="token punctuation">,</span> img3<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/97/74/pknjf5Yg_o.png" alt="BF Matcher" width="400"><br> 示例代码创建了一个 <code>BFMatcher</code> 对象，用 <code>NORM_L2</code> 作为距离度量，并启用了 <code>crossCheck</code>。然后，使用 <code>match</code> 方法在两组描述符 <code>des1</code> 和 <code>des2</code> 之间找到最佳匹配。这种匹配方法特别适用于小型或中等大小的数据集，以及在需要高精度匹配时。</p> 
<h4><a id="313__673"></a>3.1.3 函数解析</h4> 
<p><strong>BFMatcher</strong></p> 
<p><code>BFMatcher</code> 是一个暴力匹配器（Brute-Force Matcher），用于匹配不同图像中的描述符。它通过计算每个描述符之间的距离来查找匹配项。参数说明如下：</p> 
<blockquote> 
 <p><code>def create(cls, normType=None, crossCheck=None)</code></p> 
 <ol><li> <p><strong>normType</strong>： 指定用于比较描述符的距离度量。常用的选项有 <code>NORM_L1</code>, <code>NORM_L2</code>, <code>NORM_HAMMING</code>, <code>NORM_HAMMING2</code>。<code>NORM_L1</code> 和 <code>NORM_L2</code> 适合用于 SIFT 和 SURF<br> 描述符，而 <code>NORM_HAMMING</code> 适合于 ORB, BRISK 和 BRIEF。<code>NORM_HAMMING2</code> 适用于 ORB 的<br> WTA_K 为 3 或 4 时。</p> </li><li> <p><strong>crossCheck</strong>： 如果设置为 <code>True</code>，则只返回互相匹配的描述符对（即对于每个查询描述符，在训练描述符集中找到最近的匹配，并且对于找到的匹配，在查询描述符集中也是最近的）。这通常会产生质量更高的匹配，但匹配数量可能较少。</p> </li></ol> 
</blockquote> 
<p><strong>match</strong></p> 
<p><code>match</code> 方法用于查找两组描述符之间的最佳匹配。</p> 
<blockquote> 
 <p><code>def match(self, queryDescriptors, trainDescriptors, mask=None)</code></p> 
 <ol><li> <p><strong>queryDescriptors</strong>： 查询描述符集合。</p> </li><li> <p><strong>trainDescriptors</strong>： 训练描述符集合。这组描述符不会被添加到类对象存储的训练描述符集合中。</p> </li><li> <p><strong>mask</strong>： 指定允许匹配的查询和训练描述符之间的掩码。如果查询描述符在掩码中被屏蔽，则此描述符不会添加匹配。因此，匹配的数量可能小于查询描述符的数量。</p> </li></ol> 
</blockquote> 
<h3><a id="32_FLANN_695"></a>3.2 FLANN匹配器</h3> 
<p>FLANN匹配器是一种更快的近似匹配方法，适用于大规模数据集。它使用优化的算法快速找到测试数据和训练集中的近似最近邻。</p> 
<h4><a id="321_FLANN_699"></a>3.2.1 FLANN匹配器原理</h4> 
<blockquote> 
 <ul><li><strong>近似最近邻搜索</strong>：FLANN是基于多种优化算法（比如KD树、层次k均值树等）的集合，用于快速近似查找最近邻。</li><li><strong>自动参数选择</strong>：FLANN能够根据数据自动选择最合适的算法和参数，优化搜索效率。</li></ul> 
</blockquote> 
<h4><a id="322__704"></a>3.2.2 代码实现</h4> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

img1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
img2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips_template.jpg'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
img2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>ROTATE_90_COUNTERCLOCKWISE<span class="token punctuation">)</span>
<span class="token comment"># 初始化SIFT检测器</span>
sift <span class="token operator">=</span> cv2<span class="token punctuation">.</span>xfeatures2d_SIFT<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 使用SIFT找到关键点和描述子</span>
kp1<span class="token punctuation">,</span> des1 <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
kp2<span class="token punctuation">,</span> des2 <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>

<span class="token comment"># FLANN参数</span>
FLANN_INDEX_KDTREE <span class="token operator">=</span> <span class="token number">1</span>
index_params <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>algorithm<span class="token operator">=</span>FLANN_INDEX_KDTREE<span class="token punctuation">,</span> trees<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
search_params <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>checks<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span>

<span class="token comment"># 创建FLANN匹配器对象</span>
flann <span class="token operator">=</span> cv2<span class="token punctuation">.</span>FlannBasedMatcher<span class="token punctuation">(</span>index_params<span class="token punctuation">,</span> search_params<span class="token punctuation">)</span>

<span class="token comment"># 执行匹配</span>
matches <span class="token operator">=</span> flann<span class="token punctuation">.</span>knnMatch<span class="token punctuation">(</span>des1<span class="token punctuation">,</span> des2<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>

<span class="token comment"># 仅保留好的匹配</span>
good_matches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> m<span class="token punctuation">,</span> n <span class="token keyword">in</span> matches<span class="token punctuation">:</span>
    <span class="token keyword">if</span> m<span class="token punctuation">.</span>distance <span class="token operator">&lt;</span> <span class="token number">0.7</span> <span class="token operator">*</span> n<span class="token punctuation">.</span>distance<span class="token punctuation">:</span>
        good_matches<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>

<span class="token comment"># 绘制匹配</span>
img3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawMatches<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> kp1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> good_matches<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>

<span class="token comment"># 展示结果</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'FLANN Matcher'</span><span class="token punctuation">,</span> img3<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/61/62/jiSctIiA_o.png" alt="FLANN Matcher" width="400"><br> 示例代码创建了一个 <code>FlannBasedMatcher</code> 对象，使用 KDTREE 算法和相关参数。然后，使用 <code>knnMatch</code> 方法在两组描述符 <code>des1</code> 和 <code>des2</code> 之间找到每个描述符的 2 个最近邻（即 k=2）。这种方法特别适用于处理大型数据集，在寻找近似最近邻时可以获得更好的性能和效率。</p> 
<h4><a id="323__746"></a>3.2.3 函数解析</h4> 
<p><strong>FlannBasedMatcher</strong></p> 
<p><code>FlannBasedMatcher</code> 是用于特征匹配的类。相比 <code>BFMatcher</code>（暴力匹配器），它在处理大量数据时更加高效，尤其是当描述符数量很大时。参数说明如下：</p> 
<blockquote> 
 <ul><li> <p><code>index_params</code>： 字典格式的参数，用于指定索引参数。对于不同的算法，这些参数会有所不同。例如，当使用 KDTREE 算法时，可以设置 <code>trees</code> 的数量。</p> </li><li> <p><code>search_params</code>： 字典格式的参数，用于指定搜索时的参数。例如，<code>checks</code> 参数控制着搜索时的迭代次数，影响搜索的准确性和效率。</p> </li></ul> 
</blockquote> 
<p><strong>knnMatch</strong></p> 
<p><code>knnMatch</code> 方法用于找到每个查询描述符的 k 个最佳匹配项。参数如下：</p> 
<blockquote> 
 <ol><li> <p><strong>queryDescriptors</strong>： 查询描述符集合。</p> </li><li> <p><strong>trainDescriptors</strong>： 训练描述符集合。这组描述符不会被添加到类对象存储的训练描述符集合中。</p> </li><li> <p><strong>k</strong>： 每个查询描述符要查找的最近邻个数。</p> </li><li> <p><strong>mask</strong>： 一个掩码，指定允许的查询和训练描述符之间的匹配。</p> </li><li> <p><strong>compactResult</strong>： 当掩码不为空时使用的参数。如果为 <code>False</code>，则返回的匹配向量与查询描述符的行数相同。如果为 <code>True</code>，则不包含对于完全被掩码屏蔽的查询描述符的匹配。</p> </li></ol> 
</blockquote> 
<h3><a id="33_RANSAC_770"></a>3.3 RANSAC特征点匹配</h3> 
<p>RANSAC（随机抽样一致性算法）是一种鲁棒的特征点匹配算法，广泛用于处理含有大量噪声的数据。在特征点匹配过程中，RANSAC能有效地识别出正确的匹配点对（内点），并排除错误的匹配（外点）。</p> 
<h4><a id="331_RANSAC_774"></a>3.3.1 RANSAC原理</h4> 
<blockquote> 
 <ol><li> <p><strong>随机抽样</strong>：从所有匹配点对中随机选择一个小的子集来估计变换模型。例如，在计算两幅图像间的单应性（Homography）时，通常选择4对匹配点。</p> </li><li> <p><strong>模型估计</strong>：使用这个子集来计算变换模型。例如，如果是计算单应性矩阵，这个步骤会产生一个单应性矩阵H。</p> </li><li> <p><strong>内点计数</strong>：使用估计的模型测试所有的数据点，并计算模型一致的点的数量（内点）。这些点的集合称为一致性集。</p> </li><li> <p><strong>模型验证</strong>：重复上述过程固定次数。每次重复后，如果一致性集的大小超过了之前的最大值，则更新最佳模型为当前模型。</p> </li><li> <p><strong>最优模型</strong>：最后，使用内点集合来重新估计最优模型。</p> </li></ol> 
</blockquote> 
<h4><a id="332__786"></a>3.3.2 代码实现</h4> 
<p>以下是使用OpenCV进行RANSAC特征点匹配的代码实例。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token comment"># 读取图像</span>
img1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips.jpg'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
img2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'tulips_template.jpg'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
img2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>ROTATE_90_COUNTERCLOCKWISE<span class="token punctuation">)</span>

<span class="token comment"># 初始化SIFT检测器</span>
sift <span class="token operator">=</span> cv2<span class="token punctuation">.</span>xfeatures2d_SIFT<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 使用SIFT找到关键点和描述子</span>
kp1<span class="token punctuation">,</span> des1 <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
kp2<span class="token punctuation">,</span> des2 <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>

<span class="token comment"># 创建FLANN匹配器对象</span>
flann <span class="token operator">=</span> cv2<span class="token punctuation">.</span>FlannBasedMatcher<span class="token punctuation">(</span><span class="token builtin">dict</span><span class="token punctuation">(</span>algorithm<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> trees<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>checks<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

matches <span class="token operator">=</span> flann<span class="token punctuation">.</span>knnMatch<span class="token punctuation">(</span>des1<span class="token punctuation">,</span> des2<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>

<span class="token comment"># 筛选好的匹配点</span>
good_matches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> m<span class="token punctuation">,</span> n <span class="token keyword">in</span> matches<span class="token punctuation">:</span>
    <span class="token keyword">if</span> m<span class="token punctuation">.</span>distance <span class="token operator">&lt;</span> <span class="token number">0.7</span> <span class="token operator">*</span> n<span class="token punctuation">.</span>distance<span class="token punctuation">:</span>
        good_matches<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>

<span class="token comment"># 提取匹配点的位置</span>
src_pts <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span>kp1<span class="token punctuation">[</span>m<span class="token punctuation">.</span>queryIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>pt <span class="token keyword">for</span> m <span class="token keyword">in</span> good_matches<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
dst_pts <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span>kp2<span class="token punctuation">[</span>m<span class="token punctuation">.</span>trainIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>pt <span class="token keyword">for</span> m <span class="token keyword">in</span> good_matches<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>

<span class="token comment"># 使用RANSAC找到单应性矩阵</span>
M<span class="token punctuation">,</span> mask <span class="token operator">=</span> cv2<span class="token punctuation">.</span>findHomography<span class="token punctuation">(</span>src_pts<span class="token punctuation">,</span> dst_pts<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>RANSAC<span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span>

matchesMask <span class="token operator">=</span> mask<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 绘制匹配结果</span>
draw_params <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>matchColor<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> singlePointColor<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> matchesMask<span class="token operator">=</span>matchesMask<span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
img3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawMatches<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> kp1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> good_matches<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">**</span>draw_params<span class="token punctuation">)</span>

<span class="token comment"># 展示结果</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'RANSAC Matcher'</span><span class="token punctuation">,</span> img3<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>在这段代码中，使用SIFT算法检测特征点，并通过FLANN匹配器进行匹配。然后，使用<code>cv2.findHomography</code>函数结合RANSAC算法找到最佳单应性矩阵。其中， <code>src_pts</code> 和 <code>dst_pts</code> 是匹配点对，<code>5.0</code> 是 RANSAC 重投影误差的阈值。使用 RANSAC 方法可以有效处理异常值或外点，提高单应性矩阵估计的准确性。<br> <img src="https://images2.imgbox.com/8c/a4/5nMnWFp4_o.png" alt="RANSAC Matcher" width="400"></p> 
<h4><a id="333__838"></a>3.3.3 函数解析</h4> 
<p><code>findHomography</code> 函数用于寻找两个平面之间的透视变换（单应性矩阵）的方法。这个函数常用于图像配准、3D重建和计算机视觉中的许多其他应用。以下是该函数的参数说明：</p> 
<blockquote> 
 <p><code>def findHomography(srcPoints, dstPoints, method=None, ransacReprojThreshold=None, mask=None, maxIters=None, confidence=None)</code></p> 
 <ol><li> <p><strong>srcPoints</strong>： 原始平面中点的坐标。这可以是 <code>CV_32FC2</code> 类型的矩阵或 <code>vector&lt;Point2f&gt;</code>。</p> </li><li> <p><strong>dstPoints</strong>： 目标平面中点的坐标，格式与 <code>srcPoints</code> 相同。</p> </li><li> <p><strong>method</strong>：计算单应性矩阵的方法。可用的方法包括：</p> 
   <ul><li><code>0</code>： 使用所有点的普通最小二乘法。</li><li><code>cv2.RANSAC</code>： 基于 RANSAC 的鲁棒方法。</li><li><code>cv2.LMEDS</code>： 最小中值鲁棒方法。</li><li><code>cv2.RHO</code>： 基于 PROSAC 的鲁棒方法。</li></ul> </li><li> <p><strong>ransacReprojThreshold</strong>（可选，仅在使用 RANSAC 或 RHO 时）： 允许的最大重投影误差，用于将点对视为内点。在像素中测量时，这个值通常设置在 1 到 10 的范围内。</p> </li><li> <p><strong>mask</strong>：由鲁棒方法（RANSAC 或 LMEDS）设置的可选输出掩码。掩码中的非零值表示内点。</p> </li><li> <p><strong>maxIters</strong>：RANSAC 的最大迭代次数。</p> </li><li> <p><strong>confidence</strong>：置信度水平，介于 0 和 1 之间。</p> </li></ol> 
</blockquote> 
<p>函数返回值：</p> 
<blockquote> 
 <ul><li><strong>retval</strong>： 单应性矩阵，如果无法估算则返回空矩阵。</li><li><strong>mask</strong>： 输出掩码，标识每个点对是内点还是外点。</li></ul> 
</blockquote> 
<hr> 
<h2><a id="_867"></a>总结</h2> 
<p>在本博客中，我们详细探讨了OpenCV中用于特征点检测与匹配的多种方法。从基本的角点检测到复杂的特征点描述和匹配，这些方法在处理实际计算机视觉问题时发挥着至关重要的作用。通过对每种方法的原理、公式和代码实现的分析，我们可以更好地理解它们各自的优势和适用场景。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/46f5496bbf5b3741e03e9c11c8e6fb9d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Streamlit构建机器学习模型界面(更新 2023.11.24)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c1e2f5a4a0fae0c4dc8418747781f57/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">疑似威胁人类？OpenAI神秘Q*项目更多信息曝光，马斯克、Lecun下场争论…</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>