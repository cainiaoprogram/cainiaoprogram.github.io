<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker学习二之主要命令 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker学习二之主要命令" />
<meta property="og:description" content="Docker 学习2 Docker 是什么？ 我们在理解 Docker 之前，首先得先区分清楚两个概念，容器和虚拟机。
可能很多读者朋友都用过虚拟机，而对容器这个概念比较的陌生。我们用的传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件。
每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。
每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。
而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。
容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。
容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。
通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。
容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。
容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。
通过下面这幅图，我们可以很直观的反映出这两者的区别所在：
Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。
而 Linux 容器是 Linux 发展出的另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。
对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。
Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。
程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker ，就不用担心环境问题。
总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。
Docker 的优势 Docker 相比于传统虚拟化方式具有更多的优势：
Docker 启动快速属于秒级别。虚拟机通常需要几分钟去启动。
Docker 需要的资源更少。Docker 在操作系统级别进行虚拟化，Docker 容器和内核交互，几乎没有性能损耗，性能优于通过 Hypervisor 层与内核层的虚拟化。
Docker 更轻量。Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。
与虚拟机相比，Docker 隔离性更弱。Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。
安全性。Docker 的安全性也更弱，Docker 的租户 Root 和宿主机 Root 等同，一旦容器内的用户从普通用户权限提升为 Root 权限，它就直接具备了宿主机的 Root 权限，进而可进行无限制的操作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f81be6ca59097eba0b161847a30cabd2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-11T15:30:54+08:00" />
<meta property="article:modified_time" content="2020-03-11T15:30:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker学习二之主要命令</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Docker__2_0"></a>Docker 学习2</h3> 
<h4><a id="Docker__2"></a>Docker 是什么？</h4> 
<p>我们在理解 Docker 之前，首先得先区分清楚两个概念，容器和虚拟机。</p> 
<p>可能很多读者朋友都用过虚拟机，而对容器这个概念比较的陌生。我们用的传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件。</p> 
<p>每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。</p> 
<p>每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p> 
<p>而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。</p> 
<p>容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p> 
<p>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。</p> 
<p>通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。</p> 
<p>容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。</p> 
<p>容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。</p> 
<p>通过下面这幅图，我们可以很直观的反映出这两者的区别所在：<br> <img src="https://images2.imgbox.com/13/47/vVKj6o0t_o.png" alt=""></p> 
<p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p> 
<p>而 Linux 容器是 Linux 发展出的另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。</p> 
<p>对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p> 
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。</p> 
<p>程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker ，就不用担心环境问题。</p> 
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p> 
<h4><a id="Docker__40"></a>Docker 的优势</h4> 
<p>Docker 相比于传统虚拟化方式具有更多的优势：</p> 
<p>Docker 启动快速属于秒级别。虚拟机通常需要几分钟去启动。</p> 
<p>Docker 需要的资源更少。Docker 在操作系统级别进行虚拟化，Docker 容器和内核交互，几乎没有性能损耗，性能优于通过 Hypervisor 层与内核层的虚拟化。</p> 
<p>Docker 更轻量。Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。</p> 
<p>与虚拟机相比，Docker 隔离性更弱。Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。</p> 
<p>安全性。Docker 的安全性也更弱，Docker 的租户 Root 和宿主机 Root 等同，一旦容器内的用户从普通用户权限提升为 Root 权限，它就直接具备了宿主机的 Root 权限，进而可进行无限制的操作。</p> 
<p>虚拟机租户 Root 权限和宿主机的 Root 虚拟机权限是分离的，并且虚拟机利用如 Intel 的 VT-d 和 VT-x 的 ring-1 硬件隔离技术。</p> 
<p>这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</p> 
<p>可管理性。Docker 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 VMware vCenter 提供完备的虚拟机管理能力。</p> 
<p>高可用和可恢复性。Docker 对业务的高可用支持是通过快速重新部署实现的。</p> 
<p>虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， VMware 可承诺虚拟机 99.999% 高可用，保证业务连续性。</p> 
<p>快速创建、删除。虚拟化创建是分钟级别的，Docker 容器创建是秒级别的，Docker 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间</p> 
<p>交付、部署。虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。Docker 在 Dockerfile 中记录了容器构建过程，可在集群中实现快速分发和快速部署。</p> 
<p><img src="https://images2.imgbox.com/a5/a0/9xVuju9C_o.png" alt=""></p> 
<h4><a id="Docker__71"></a>Docker 的三个基本概念</h4> 
<p><img src="https://images2.imgbox.com/a9/b9/3FvfdPLs_o.png" alt=""></p> 
<p>从上图我们可以看到，Docker 中包括三个基本的概念：</p> 
<ul><li> <p>Image(镜像)</p> </li><li> <p>Container(容器)</p> </li><li> <p>Repository(仓库)</p> </li></ul> 
<h5><a id="Image_83"></a>Image(镜像)</h5> 
<p>那么镜像到底是什么呢？Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p> 
<p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义：</p> 
<p><img src="https://images2.imgbox.com/74/37/hlOjnQTK_o.png" alt=""></p> 
<p>从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其他层都会有一个指针指向下一层。这些层是 Docker 内部的实现细节，并且能够在主机的文件系统上访问到。</p> 
<p>统一文件系统(Union File System)技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角。</p> 
<p>这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p> 
<h5><a id="Container_98"></a>Container(容器)</h5> 
<p>容器(Container)的定义和镜像(Image)几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。<br> <img src="https://images2.imgbox.com/e9/65/HkYK0eX8_o.png" alt=""></p> 
<p>由于容器的定义并没有提及是否要运行容器，所以实际上，<strong>容器 = 镜像 + 读写层。</strong></p> 
<h5><a id="Repository_105"></a>Repository(仓库)</h5> 
<p>Docker 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行。</p> 
<p>但是， 如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry(仓库注册服务器)就是这样的服务。</p> 
<p>有时候会把仓库(Repository)和仓库注册服务器(Registry)混为一谈，并不严格区分。</p> 
<p>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p> 
<p>实际上，一个 Docker Registry 中可以包含多个仓库(Repository)，每个仓库可以包含多个标签(Tag)，每个标签对应着一个镜像。</p> 
<p>所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</p> 
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。</p> 
<p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 Latest 作为默认标签。</p> 
<p>仓库又可以分为两种形式：</p> 
<ul><li> <p>Public(公有仓库)</p> </li><li> <p>Private(私有仓库)</p> </li></ul> 
<p>Docker Registry 公有仓库是开放给用户使用、允许用户管理镜像的 Registry 服务。</p> 
<p>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p> 
<p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p> 
<p>当用户创建了自己的镜像之后就可以使用 Push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 Pull 下来就可以了。</p> 
<p>我们主要把 Docker 的一些常见概念如 Image，Container，Repository 做了详细的阐述，也从传统虚拟化方式的角度阐述了 Docker 的优势。</p> 
<p>我们从下图可以直观地看到 Docker 的架构：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-be97XTMf-1583911757815)(<img src="https://images2.imgbox.com/31/18/1XTQLEvc_o.png" alt="在这里插入图片描述">])</p> 
<p>Docker 使用 C/S 结构，即客户端/服务器体系结构。Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。</p> 
<p>Docker 客户端和服务端可以运行在一台机器上，也可以通过 RESTful 、 Stock 或网络接口与远程 Docker 服务端进行通信。</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8TXtnlqC-1583911757819)(<img src="https://images2.imgbox.com/d8/1b/zB5t2hFW_o.png" alt="在这里插入图片描述">])</p> 
<p>这张图展示了 Docker 客户端、服务端和 Docker 仓库（即 Docker Hub 和 Docker Cloud ），默认情况下 Docker 会在 Docker 中央仓库寻找镜像文件。</p> 
<p>这种利用仓库管理镜像的设计理念类似于 Git ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</p> 
<h4><a id="Docker__154"></a>Docker 的安装和使用</h4> 
<p>Docker 的安装和使用有一些前提条件，主要体现在体系架构和内核的支持上。</p> 
<p>对于体系架构，除了 Docker 一开始就支持的 X86-64 ，其他体系架构的支持则一直在不断地完善和推进中。</p> 
<p>Docker 分为 CE 和 EE 两大版本。CE 即社区版，免费支持周期 7 个月；EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p> 
<p>我们在安装前可以参看官方文档获取最新的 Docker 支持情况，官方文档在这里：</p> 
<p>https://docs.docker.com/install/</p> 
<p>Docker 对于内核支持的功能，即内核的配置选项也有一定的要求(比如必须开启 Cgroup 和 Namespace 相关选项，以及其他的网络和存储驱动等)。</p> 
<p>Docker 源码中提供了一个检测脚本来检测和指导内核的配置，脚本链接在这里：</p> 
<p>https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh</p> 
<p>在满足前提条件后，安装就变得非常的简单了。</p> 
<p>Docker CE 的安装请参考官方文档：</p> 
<p>MacOS：https://docs.docker.com/docker-for-mac/install/</p> 
<p>Windows：https://docs.docker.com/docker-for-windows/install/</p> 
<p>Ubuntu：https://docs.docker.com/install/linux/docker-ce/ubuntu/</p> 
<p>Debian：https://docs.docker.com/install/linux/docker-ce/debian/</p> 
<p>CentOS：https://docs.docker.com/install/linux/docker-ce/centos/</p> 
<p>Fedora：https://docs.docker.com/install/linux/docker-ce/fedora/</p> 
<p>其他 Linux 发行版：https://docs.docker.com/install/linux/docker-ce/binaries/</p> 
<h5><a id="_Docker_190"></a>安装 Docker</h5> 
<p>Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装 Docker，只需要运行下面的 yum 命令：</p> 
<pre><code>$ sudo yum install docker
</code></pre> 
<p>当然在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：</p> 
<pre><code>curl -fsSL get.docker.com -o get-docker.sh
sh get-docker.sh
</code></pre> 
<p>具体可以参看 docker-install 的脚本：</p> 
<p>https://github.com/docker/docker-install</p> 
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。</p> 
<p>安装完成后，运行下面的命令，验证是否安装成功：</p> 
<pre><code>docker version 

</code></pre> 
<p>启动 Docker-CE：</p> 
<pre><code>$ sudo systemctl enable docker$ sudo systemctl start docker

</code></pre> 
<h5><a id="Docker__Hello_World_223"></a>Docker 的简单运用 Hello World</h5> 
<p>我们通过最简单的 Image 文件 Hello World，感受一下 Docker 的魅力吧！</p> 
<p>我们直接运行下面的命令，将名为 hello-world 的 image 文件从仓库抓取到本地：</p> 
<pre><code>docker pull library/hello-world

</code></pre> 
<p>docker pull images 是抓取 image 文件，library/hello-world 是 image 文件在仓库里面的位置，其中 library 是 image 文件所在的组，hello-world 是 image 文件的名字。</p> 
<p><img src="https://images2.imgbox.com/27/2f/Qc5e8P11_o.png" alt="在这里插入图片描述"></p> 
<p>抓取成功以后，就可以在本机看到这个 image 文件了：</p> 
<pre><code>docker images
</code></pre> 
<p><img src="https://images2.imgbox.com/97/a7/KgUwiY2o_o.png" alt="在这里插入图片描述"></p> 
<p>现在，我们可以运行 hello-world 这个 image 文件：</p> 
<pre><code>docker run hello-world
</code></pre> 
<p>我们可以看到如下结果:</p> 
<p><img src="https://images2.imgbox.com/26/a1/XUPgEYM5_o.png" alt="在这里插入图片描述"></p> 
<p>输出这段提示以后，hello world 就会停止运行，容器自动终止。有些容器不会自动终止，因为提供的是服务，比如 MySQL 镜像等。</p> 
<h4><a id="_262"></a>配置镜像加速器</h4> 
<p>http://www.itmuch.com/docker/03-docker-mirror/</p> 
<h5><a id="_266"></a>常见命令</h5> 
<p>systemctl命令是系统服务管理器指令</p> 
<p>启动docker：<br> systemctl start docker</p> 
<p>停止docker：<br> systemctl stop docker</p> 
<p>重启docker：<br> systemctl restart docker</p> 
<p>查看docker状态：<br> systemctl status docker</p> 
<p>开机启动：<br> systemctl enable docker</p> 
<p>查看docker概要信息<br> docker info</p> 
<h4><a id="Docker_289"></a>Docker镜像常用命令</h4> 
<h5><a id="_291"></a>搜索镜像</h5> 
<p>可使用docker search 命令搜索存放在Docker Hub中的镜像。</p> 
<p>命令格式：</p> 
<pre><code>docker search [OPTIONS] TERM
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–automated</td><td align="left">false</td><td align="left">只列出自动构建的镜像</td></tr><tr><td align="left">–filter, -f</td><td align="left"></td><td align="left">根据指定条件过滤结果</td></tr><tr><td align="left">–limit</td><td align="left">25</td><td align="left">搜索结果的最大条数</td></tr><tr><td align="left">–no-trunc</td><td align="left">false</td><td align="left">不截断输出，显示完整的输出</td></tr><tr><td align="left">–stars, -s</td><td align="left">0</td><td align="left">只展示Star不低于该数值的结果 (废弃)</td></tr></tbody></table> 
<p>示例:</p> 
<pre><code>docker search -filter=stars=10 java

</code></pre> 
<h5><a id="_316"></a>下载镜像[重要]</h5> 
<pre><code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]

</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–all-tags, -a</td><td align="left">false</td><td align="left">下载所有标签的镜像</td></tr><tr><td align="left">–disable-content-trust</td><td align="left">true</td><td align="left">忽略镜像的校验</td></tr></tbody></table> 
<p>示例:</p> 
<pre><code>docker pull reg.itmuch.com/java:7
</code></pre> 
<h5><a id="inspect_336"></a>使用inspect命令查看详细信息</h5> 
<p>如</p> 
<pre><code>docker inspect nginx 
</code></pre> 
<h5><a id="_344"></a>列出镜像[重要]</h5> 
<pre><code>docker images
</code></pre> 
<p>命令格式：</p> 
<pre><code>docker images [OPTIONS] [REPOSITORY[:TAG]]
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–all, -a</td><td align="left">false</td><td align="left">列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）</td></tr><tr><td align="left">–digests</td><td align="left">false</td><td align="left">显示摘要信息</td></tr><tr><td align="left">–filter, -f</td><td align="left"></td><td align="left">显示满足条件的镜像</td></tr><tr><td align="left">–format</td><td align="left">通过Go语言模板文件展示镜像</td><td align="left"></td></tr><tr><td align="left">–no-trunc</td><td align="left">false</td><td align="left">不截断输出，显示完整的镜像信息</td></tr><tr><td align="left">–quiet, -q</td><td align="left">false</td><td align="left">只显示镜像ID</td></tr></tbody></table> 
<p>示例：</p> 
<pre><code>docker images
docker images java
docker images java:8
docker images --digests
docker images --filter "dangling=true"   # 展示虚悬镜像
</code></pre> 
<h5><a id="_378"></a>删除本地镜像[重要]</h5> 
<p>命令格式：</p> 
<pre><code>docker rmi [OPTIONS] IMAGE [IMAGE...]
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–force, -f</td><td align="left">false</td><td align="left">强制删除</td></tr><tr><td align="left">–no-prune</td><td align="left">false</td><td align="left">不移除该镜像的过程镜像，默认移除</td></tr></tbody></table> 
<p>例1：删除指定名称的镜像。</p> 
<pre><code>docker rmi hello-world
</code></pre> 
<p>表示删除hello-world这个镜像。</p> 
<p>例2：删除所有镜像。</p> 
<pre><code>docker rmi -f $(docker images)
</code></pre> 
<p>-f参数表示强制删除。</p> 
<h5><a id="_406"></a>保存镜像</h5> 
<p>使用docker save 即可保存镜像。</p> 
<p>命令格式：</p> 
<pre><code>docker save [OPTIONS] IMAGE [IMAGE...]
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–output, -o</td><td align="left"></td><td align="left">Write to a file, instead of STDOUT</td></tr></tbody></table> 
<p>例1：</p> 
<pre><code>docker save busybox &gt; busybox.tar
docker save --output busybox.tar busybox
</code></pre> 
<h4><a id="_425"></a>加载镜像</h4> 
<p>使用docer load 命令即可加载镜像。</p> 
<p>命令格式：</p> 
<pre><code>docker load [OPTIONS]
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–input, -i</td><td align="left"></td><td align="left">从文件加载而非STDIN</td></tr><tr><td align="left">–quiet, -q</td><td align="left">false</td><td align="left">静默加载</td></tr></tbody></table> 
<h5><a id="_443"></a>构建镜像[重要]</h5> 
<p>通过Dockerfile构建镜像。</p> 
<p>命令格式：</p> 
<pre><code>docker build [OPTIONS] PATH | URL | -
</code></pre> 
<p>参数：<br> http://www.itmuch.com/docker/04-docker-command-images/</p> 
<h4><a id="_455"></a>容器常用命令</h4> 
<h5><a id="_457"></a>新建并启动容器[重要]</h5> 
<p>使用以下docker run 命令即可新建并启动一个容器。</p> 
<p>① -d选项：表示后台运行</p> 
<p>② -P选项：随机端口映射</p> 
<p>③ -p选项：指定端口映射，有以下四种格式。</p> 
<p>ip:hostPort:containerPort</p> 
<p>ip::containerPort</p> 
<p>hostPort:containerPort</p> 
<p>containerPort</p> 
<p>④ –network选项：指定网络模式，该选项有以下可选参数：</p> 
<p>–network=bridge： 默认选项，表示连接到默认的网桥。</p> 
<p>–network=host：容器使用宿主机的网络。</p> 
<p>–network=container:NAME_or_ID：告诉Docker让新建的容器使用已有容器的网络配置。</p> 
<p>–network=none：不配置该容器的网络，用户可自定义网络配置。</p> 
<p>示例1：</p> 
<pre><code>docker run java /bin/echo 'Hello World'

</code></pre> 
<p>示例:</p> 
<pre><code>docker run -d -p 91:80 nginx

</code></pre> 
<h5><a id="_498"></a>列出容器[重要]</h5> 
<p>使用docker ps 命令即可列出运行中的容器。执行该命令后，可看到类似于如下的表格。</p> 
<pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES
784fd3b294d7        nginx               "nginx -g 'daemon off"   20 minutes ago      Up 2 seconds        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes
</code></pre> 
<p>该表格包含了七列，含义如下：</p> 
<p>① CONTAINER_ID：表示容器ID。</p> 
<p>② IMAGE：表示镜像名称。</p> 
<p>③ COMMAND：表示启动容器时运行的命令。</p> 
<p>④ CREATED：表示容器的创建时间。</p> 
<p>⑤ STATUS：表示容器运行的状态。Up表示运行中，Exited表示已停止。</p> 
<p>⑥ PORTS：表示容器对外的端口号。</p> 
<p>⑦ NAMES：表示容器名称。该名称默认由Docker自动生成，也可使用docker run命令的–name选项自行指定。</p> 
<p>命令格式：</p> 
<pre><code>docker ps [OPTIONS]
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–all, -a</td><td align="left">false</td><td align="left">列出所有容器，包括未运行的容器，默认只展示运行的容器</td></tr><tr><td align="left">–filter, -f</td><td align="left"></td><td align="left">根据条件过滤显示内容</td></tr><tr><td align="left">–format</td><td align="left"></td><td align="left">通过Go语言模板文件展示镜像</td></tr><tr><td align="left">–last, -n</td><td align="left">-1</td><td align="left">显示最近创建n个容器（包含所有状态）</td></tr><tr><td align="left">–latest,</td><td align="left">-l false</td><td align="left">显示最近创建的容器（包含所有状态）</td></tr><tr><td align="left">–no-trunc</td><td align="left">false</td><td align="left">不截断输出</td></tr><tr><td align="left">–quiet, -q</td><td align="left">false</td><td align="left">静默模式，只展示容器的编号</td></tr><tr><td align="left">–size, -s</td><td align="left">false</td><td align="left">显示总文件大小</td></tr></tbody></table> 
<h5><a id="_542"></a>停止容器[重要]</h5> 
<p>使用docker stop 命令，即可停止容器。</p> 
<p>命令格式：</p> 
<pre><code>docker stop [OPTIONS] CONTAINER [CONTAINER...]
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–time, -t</td><td align="left">10</td><td align="left">强制杀死容器前等待的时间，单位是秒</td></tr></tbody></table> 
<h5><a id="_557"></a>强制停止容器[重要]</h5> 
<p>可使用docker kill 命令停止一个或更多运行着的容器。</p> 
<p>命令格式：</p> 
<pre><code>docker kill [OPTIONS] CONTAINER [CONTAINER...]
</code></pre> 
<p>参数：</p> 
<p>|Name, shorthand| Default| Description|<br> |–signal, -s| KILL| 向容器发送一个信号|</p> 
<h5><a id="_572"></a>启动已停止的容器[重要]</h5> 
<p>使用docker run 命令，即可新建并启动一个容器。对于已停止的容器，可使用docker start 命令来启动。</p> 
<p>命令格式：</p> 
<pre><code>docker start [OPTIONS] CONTAINER [CONTAINER...]
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–attach, -a</td><td align="left">false</td><td align="left">连接STDOUT/STDERR并转发信号</td></tr><tr><td align="left">–checkpoint</td><td align="left"></td><td align="left">从该检查点还原</td></tr><tr><td align="left">–checkpoint-dir</td><td align="left"></td><td align="left">使用自定义的检查点存储目录</td></tr><tr><td align="left">–detach-keys</td><td align="left"></td><td align="left">覆盖断开容器的关键顺序</td></tr><tr><td align="left">–interactive, -i</td><td align="left">false</td><td align="left">连接容器的STDIN</td></tr></tbody></table> 
<h5><a id="_590"></a>重启容器[重要]</h5> 
<p>可使用docker restart 命令来重启容器。该命令实际上是先执行了docker stop 命令，然后执行了docker start 命令。</p> 
<p>命令格式：</p> 
<pre><code>docker restart [OPTIONS] CONTAINER [CONTAINER...]
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–time, -t 10</td><td align="left">关闭容器前等待的时间，单位是秒</td><td align="left"></td></tr></tbody></table> 
<p>示例:</p> 
<pre><code>docker restart --time=10  08dc7fe747f6
```

#### 进入容器[重要]
某场景下，我们可能需要进入运行中的容器。

① 使用`docker attach` 命令进入容器。

例如：
```
docker attach 784fd3b294d7
</code></pre> 
<p>很多场景下，使用docker attach 命令并不方便。当多个窗口同时attach到同一个容器时，所有窗口都会同步显示。同理，如果某个窗口发生阻塞，其他窗口也无法执行操作。</p> 
<p>② 使用nsenter 进入容器</p> 
<p>nsenter工具包含在util-linux 2.23或更高版本中。为了连接到容器，我们需要找到容器第一个进程的PID，可通过以下命令获取：</p> 
<pre><code>docker inspect --format "{<!-- -->{.State.Pid}}" $CONTAINER_ID
</code></pre> 
<p>获得PID后，就可使用nsenter命令进入容器了：</p> 
<pre><code>nsenter --target "$PID" --mount --uts --ipc --net --pid
</code></pre> 
<p>下面给出一个完整的例子：</p> 
<pre><code>[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES
784fd3b294d7        nginx               "nginx -g 'daemon off"   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes
[root@localhost ~]# docker inspect --format "{<!-- -->{.State.Pid}}" 784fd3b294d7
95492
[root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pid
root@784fd3b294d7:/#
</code></pre> 
<p>读者也可将以上两条命令封装成一个Shell，从而简化进入容器的过程。</p> 
<p>③ docker exec</p> 
<pre><code>docker exec -it 容器id /bin/bash
</code></pre> 
<h5><a id="_648"></a>退出容器[重要]</h5> 
<p>ctl+d 退出容器</p> 
<h5><a id="_653"></a>删除容器[重要]</h5> 
<p>使用docker rm 命令即可删除指定容器。</p> 
<p>命令格式</p> 
<pre><code>docker rm [OPTIONS] CONTAINER [CONTAINER...]
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–force, -f</td><td align="left">false</td><td align="left">通过SIGKILL信号强制删除正在运行中的容器</td></tr><tr><td align="left">–link, -l</td><td align="left">false</td><td align="left">删除容器间的网络连接</td></tr><tr><td align="left">–volumes, -v</td><td align="left">false</td><td align="left">删除与容器关联的卷</td></tr></tbody></table> 
<p>例1：删除指定容器。</p> 
<pre><code>docker rm 784fd3b294d7
</code></pre> 
<p>该命令只能删除已停止的容器，如需删除正在运行的容器，可使用-f参数。</p> 
<p>例2：删除所有的容器。</p> 
<pre><code>docker rm -f $(docker ps -a -q)
</code></pre> 
<h5><a id="_683"></a>导出容器</h5> 
<p>将容器导出成一个压缩包文件。</p> 
<p>命令格式：</p> 
<pre><code>docker export [OPTIONS] CONTAINER
</code></pre> 
<p>参数：</p> 
<table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–output, -o</td><td align="left"></td><td align="left">将内容写到文件而非STDOUT</td></tr></tbody></table> 
<p>示例：</p> 
<pre><code>docker export red_panda &gt; latest.tar
docker export --output="latest.tar" red_panda
</code></pre> 
<h5><a id="_703"></a>导入容器</h5> 
<p>使用docker import 命令即可从归档文件导入内容并创建镜像。</p> 
<p>命令格式：</p> 
<pre><code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]
</code></pre> 
<p>参数：</p> 
<p>|Name, shorthand |Default |Description|<br> |–change, -c| |将Dockerfile指令应用到创建的镜像|<br> |–message, -m| |为导入的镜像设置提交信息|</p> 
<p>示例：</p> 
<pre><code>docker import nginx2.tar nginx
</code></pre> 
<h4><a id="nginx_722"></a>访问nginx</h4> 
<p>https://blog.csdn.net/ShelleyLittlehero/article/details/104794738</p> 
<h4><a id="Dockerfile_725"></a>Dockerfile指令详解</h4> 
<p>什么是 Dockerfile？<br> Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p> 
<h5><a id="ADD__730"></a>ADD 复制文件</h5> 
<p>DD指令用于复制文件，格式为：</p> 
<pre><code>ADD &lt;src&gt;... &lt;dest&gt;
ADD ["&lt;src&gt;",... "&lt;dest&gt;"]
</code></pre> 
<p>注意 :</p> 
<p>① src必须在构建的上下文内，不能使用例如：ADD …/somethine /something 这样的命令，因为docker build 命令首先会将上下文路径和其子目录发送到docker daemon。</p> 
<p>② 如果src是一个URL，同时dest不以斜杠结尾，dest将会被视为文件，src对应内容文件将会被下载到dest。</p> 
<p>③ 如果src是一个URL，同时dest以斜杠结尾，dest将被视为目录，src对应内容将会被下载到dest目录。</p> 
<p>④ 如果src是一个目录，那么整个目录下的内容将会被拷贝，包括文件系统元数据。</p> 
<p>⑤ 如果文件是可识别的压缩包格式，则docker会自动解压。</p> 
<p>示例:</p> 
<pre><code>ADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar app.jar

</code></pre> 
<h5><a id="ARG__761"></a>ARG 设置构建参数</h5> 
<p>ARG指令用于设置构建参数，类似于ENV。和ARG不同的是，ARG设置的是构建时的环境变量，在容器运行时是不会存在这些变量的。</p> 
<p>格式为：</p> 
<pre><code>ARG &lt;name&gt;[=&lt;default value&gt;]
</code></pre> 
<p>示例：</p> 
<pre><code>ARG user1=someuser
</code></pre> 
<p>详细介绍文档：https://www.centos.bz/2016/12/dockerfile-arg-instruction/</p> 
<h5><a id="CMD__778"></a>CMD 容器启动命令</h5> 
<p>CMD指令用于为执行容器提供默认值。每个Dockerfile只有一个CMD命令，如果指定了多个CMD命令，那么只有最后一条会被执行，如果启动容器的时候指定了运行的命令，则会覆盖掉CMD指定的命令。</p> 
<p>支持三种格式：</p> 
<pre><code>CMD ["executable","param1","param2"] (推荐使用)

CMD ["param1","param2"] (为ENTRYPOINT指令提供预设参数)

CMD command param1 param2 (在shell中执行)
</code></pre> 
<p>示例：</p> 
<pre><code>CMD echo "This is a test." | wc -
</code></pre> 
<h5><a id="COPY__796"></a>COPY 复制文件</h5> 
<p>复制文件，格式为：</p> 
<pre><code>COPY &lt;src&gt;... &lt;dest&gt;
COPY ["&lt;src&gt;",... "&lt;dest&gt;"]
</code></pre> 
<p>复制本地端的src到容器的dest。COPY指令和ADD指令类似，COPY不支持URL和压缩包。</p> 
<h5><a id="ENTRYPOINT__805"></a>ENTRYPOINT 入口点</h5> 
<p>格式为：</p> 
<pre><code>ENTRYPOINT ["executable", "param1", "param2"]
ENTRYPOINT command param1 param2
</code></pre> 
<p>ENTRYPOINT和CMD指令的目的一样，都是指定Docker容器启动时执行的命令，可多次设置，但只有最后一个有效。ENTRYPOINT不可被重写覆盖。</p> 
<p>ENTRYPOINT、CMD区别：http://blog.csdn.net/newjueqi/article/details/51355510</p> 
<p>ENV 设置环境变量<br> ENV指令用于设置环境变量，格式为：</p> 
<pre><code>ENV &lt;key&gt; &lt;value&gt;
ENV &lt;key&gt;=&lt;value&gt; ...
</code></pre> 
<p>示例：</p> 
<pre><code>ENV JAVA_HOME /path/to/java
</code></pre> 
<h5><a id="EXPOSE__830"></a>EXPOSE 声明暴露的端口</h5> 
<p>EXPOSE指令用于声明在运行时容器提供服务的端口，格式为：</p> 
<pre><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]
</code></pre> 
<p>需要注意的是，这只是一个声明，运行时并不会因为该声明就打开相应端口。该指令的作用主要是帮助镜像使用者理解该镜像服务的守护端口；其次是当运行时使用随机映射时，会自动映射EXPOSE的端口。示例：</p> 
<pre><code># 声明暴露一个端口示例
EXPOSE port1
# 相应的运行容器使用的命令
docker run -p port1 image
# 也可使用-P选项启动
docker run -P image

# 声明暴露多个端口示例
EXPOSE port1 port2 port3
# 相应的运行容器使用的命令
docker run -p port1 -p port2 -p port3 image
# 也可指定需要映射到宿主机器上的端口号  
docker run -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image

</code></pre> 
<h5><a id="FROM__855"></a>FROM 指定基础镜像</h5> 
<p>使用FROM指令指定基础镜像，FROM指令有点像Java里面的“extends”关键字。需要注意的是，FROM指令必须指定且需要写在其他指令之前。FROM指令后的所有指令都依赖于该指令所指定的镜像。</p> 
<p>支持三种格式：</p> 
<pre><code>FROM &lt;image&gt;
FROM &lt;image&gt;:&lt;tag&gt;
FROM &lt;image&gt;@&lt;digest&gt;
</code></pre> 
<h5><a id="LABEL__865"></a>LABEL 为镜像添加元数据</h5> 
<p>LABEL指令用于为镜像添加元数据。</p> 
<p>格式为：</p> 
<pre><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...
</code></pre> 
<p>使用 ””“和”\“转换命令行，示例：</p> 
<pre><code>LABEL "com.example.vendor"="ACME Incorporated"
LABEL com.example.label-with-value="foo"
LABEL version="1.0"
LABEL description="This text illustrates \
that label-values can span multiple lines."
</code></pre> 
<h5><a id="MAINTAINER__883"></a>MAINTAINER 指定维护者的信息（已过时）</h5> 
<p>注：该指令已过时，建议使用如下形式：</p> 
<pre><code>LABEL maintainer="SvenDowideit@home.org.au"
</code></pre> 
<h5><a id="RUN__891"></a>RUN 执行命令</h5> 
<p>该指令支持两种格式：</p> 
<pre><code>RUN &lt;command&gt;
RUN ["executable", "param1", "param2"]
RUN &lt;command&gt; 在shell终端中运行，在Linux中默认是/bin/sh -c ，在Windows中是 cmd /s /c ，使用这种格式，就像直接在命令行中输入命令一样。
RUN ["executable", "param1", "param2"] 使用exec执行，这种方式类似于函数调用。指定其他终端可以通过该方式操作，例如：RUN ["/bin/bash", "-c", "echo hello"] ，该方式必须使用双引号[“]而不能使用单引号[‘]，因为该方式会被转换成一个JSON 数组。
</code></pre> 
<h5><a id="USER__902"></a>USER 设置用户</h5> 
<p>该指令用于设置启动镜像时的用户或者UID，写在该指令后的RUN、CMD以及ENTRYPOINT指令都将使用该用户执行命令。</p> 
<p>格式为：</p> 
<p>USER 用户名<br> 示例：</p> 
<pre><code>USER daemon
</code></pre> 
<h5><a id="VOLUME__914"></a>VOLUME 指定挂载点</h5> 
<p>该指令使容器中的一个目录具有持久化存储的功能，该目录可被容器本身使用，也可共享给其他容器。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。格式为：</p> 
<pre><code>VOLUME ["/data"]
</code></pre> 
<p>示例：</p> 
<pre><code>VOLUME /data
</code></pre> 
<p>使用示例：</p> 
<pre><code>FROM nginx
VOLUME /tmp
</code></pre> 
<p>当该Dockerfile被构建成镜像后，/tmp目录中的数据即使容器关闭也依然存在。如果另一个容器也有持久化的需求，并且想使用以上容器/tmp目录中的内容，则可使用如下命令启动容器：</p> 
<pre><code>docker run -volume-from 容器ID 镜像名称  # 容器ID是di一个容器的ID，镜像是第二个容器所使用的镜像。
</code></pre> 
<h5><a id="WORKDIR__935"></a>WORKDIR 指定工作目录</h5> 
<p>格式为：</p> 
<pre><code>WORKDIR /path/to/workdir
</code></pre> 
<p>切换目录指令，类似于cd命令，写在该指令后的RUN，CMD以及ENTRYPOINT指令都将该目录作为当前目录，并执行相应的命令。</p> 
<h4><a id="Docker_Registry_944"></a>使用Docker Registry管理镜像</h4> 
<p>可使用docker-registry项目或者Docker Registry 2.0来搭建私有仓库，但docker-registry已被官方标记为过时，并且已有2年不维护了，不建议使用。</p> 
<p>我们先用Docker Registry 2.0搭建一个私有仓库，然后将Docker镜像推送到私有仓库。</p> 
<h5><a id="Docker_Registry_20_950"></a>搭建Docker Registry 2.0</h5> 
<p>Docker Registry 2.0的搭建非常简单，只需执行以下命令即可新建并启动一个Docker Registry 2.0。</p> 
<pre><code>docker run -d -p 5000:5000 --restart=always --name registry2 registry:2
</code></pre> 
<h5><a id="Docker_Registry_20_956"></a>将镜像推送到Docker Registry 2.0</h5> 
<p>前文我们使用docker push 命令将镜像推送到了Docker Hub，现在我们将前文构建的itmuch/microservice-discovery-eureka:0.0.1推送到私有仓库。</p> 
<p>只需指定私有仓库的地址，即可将镜像推送到私有仓库。</p> 
<pre><code>docker push localhost:5000/itmuch/microservice-discovery-eureka:0.0.1
</code></pre> 
<p>执行以上命令，我们发现推送并没有成功，且提示以下内容：</p> 
<pre><code>The push refers to a repository [localhost:5000/itmuch/microservice-discovery-eureka]
An image does not exist locally with the tag: localhost:5000/itmuch/microservice-discovery-eureka
</code></pre> 
<p>我们知道，Docker Hub是默认的Docker Registry，因此，itmuch/microservice-discovery-eureka:0.0.1相当于docker.io/itmuch/microservice-discovery-eureka:0.0.1。因此，要想将镜像推送到私有仓库，需要修改镜像标签，命令如下：</p> 
<pre><code>docker tag itmuch/microservice-discovery-eureka:0.0.1 localhost:5000/itmuch/microservice-discovery-eureka:0.0.1
</code></pre> 
<p>修改镜像标签后，再次执行以下命令，即可将镜像推送到私有仓库。</p> 
<pre><code>docker push localhost:5000/itmuch/microservice-discovery-eureka:0.0.1
</code></pre> 
<p>文章主要参考:<br> http://www.itmuch.com/docker/00-docker-lession-index/</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20ff0f696b4eb8e388d46aed75f86487/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">51单片机重定向printf函数 打印数值不正确问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a1bd3562ed9eff995b5c01b7052e3a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">centos网络配置（包含4种类型）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>