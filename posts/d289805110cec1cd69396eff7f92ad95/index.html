<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【pytorch】常用图像处理与数据增强方法合集（torchvision.transforms） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【pytorch】常用图像处理与数据增强方法合集（torchvision.transforms）" />
<meta property="og:description" content="【pytorch】常用图像处理与数据增强方法合集（torchvision.transforms）
文章目录
张量化（ToTensor）
灰度化（Grayscale）
标准化（Normalize）
组合转换（Compose）
中心裁剪（CenterCrop）
边缘拓展（Pad）
随机裁剪（RandomCrop）
尺寸缩放（Resize）
随机旋转（RandomRotation）
水平翻转（RandomHorizontalFlip）
垂直翻转（RandomVerticalFlip）
色彩抖动（ColorJitter）
高斯模糊（GaussianBlur）
仿射变换（RandomAffine）（包含平移）
张量化
torchvision.transforms.ToTensor
描述
将PIL.Image或numpy.ndarray类型的图片转为torch.Tensor类型，如果图片的灰度级在[0, 255]，会除以255.0，归一化到[0.0, 1.0]。这个基本上每个数据集都会用到。
参数
不用给参数。
示例
from torchvision import transforms
import numpy as np
a = np.array([[255, 199, 30]], dtype=np.uint8)
a
array([[255, 199, 30]], dtype=uint8)
t = transforms.ToTensor()
b = t(a)
b
tensor([[[1.0000, 0.7804, 0.1176]]])
灰度化
torchvision.transforms.Grayscale(num_output_channels=1)
描述
将彩色图片转为灰度图片。图片必须是PIL.Image或torch.Tensor类型。
参数
如果num_output_channels=1，返回单通道灰度图片；如果num_output_channels=3，返回三通道的灰度图片，其中r == g == b。一般我们不用设置，默认为1就行了。
示例
from PIL import Image" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d289805110cec1cd69396eff7f92ad95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T17:17:51+08:00" />
<meta property="article:modified_time" content="2023-12-25T17:17:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【pytorch】常用图像处理与数据增强方法合集（torchvision.transforms）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>【pytorch】常用图像处理与数据增强方法合集（torchvision.transforms）</strong><br> 文章目录<br> 张量化（ToTensor）<br> 灰度化（Grayscale）<br> 标准化（Normalize）<br> 组合转换（Compose）<br> 中心裁剪（CenterCrop）<br> 边缘拓展（Pad）<br> 随机裁剪（RandomCrop）<br> 尺寸缩放（Resize）<br> 随机旋转（RandomRotation）<br> 水平翻转（RandomHorizontalFlip）<br> 垂直翻转（RandomVerticalFlip）<br> 色彩抖动（ColorJitter）<br> 高斯模糊（GaussianBlur）<br> 仿射变换（RandomAffine）（包含平移）<br> 张量化<br> torchvision.transforms.ToTensor</p> 
<p>描述<br> 将PIL.Image或numpy.ndarray类型的图片转为torch.Tensor类型，如果图片的灰度级在[0, 255]，会除以255.0，归一化到[0.0, 1.0]。这个基本上每个数据集都会用到。</p> 
<p>参数<br> 不用给参数。</p> 
<p>示例</p> 
<blockquote> 
 <blockquote> 
  <blockquote> 
   <p>from torchvision import transforms<br> import numpy as np<br> a = np.array([[255, 199, 30]], dtype=np.uint8)<br> a<br> array([[255, 199, 30]], dtype=uint8)<br> t = transforms.ToTensor()<br> b = t(a)<br> b<br> tensor([[[1.0000, 0.7804, 0.1176]]])<br> 灰度化<br> torchvision.transforms.Grayscale(num_output_channels=1)</p> 
  </blockquote> 
 </blockquote> 
</blockquote> 
<p>描述<br> 将彩色图片转为灰度图片。图片必须是PIL.Image或torch.Tensor类型。</p> 
<p>参数<br> 如果num_output_channels=1，返回单通道灰度图片；如果num_output_channels=3，返回三通道的灰度图片，其中r == g == b。一般我们不用设置，默认为1就行了。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)<br> transform = transforms.Grayscale()<br> img = transform(img)<br> 绘图</p> 
<p>标准化<br> torchvision.transforms.Normalize(mean, std, inplace=False)</p> 
<p>描述<br> 用均值和标准差标准化数据，将数据映射到区间[-1, 1]，能加快模型的收敛速度，一般加到ToTensor后面。仅限torch.Tensor类型。</p> 
<p>参数<br> mean (sequence)：各通道的均值。<br> std (sequence)：各通道的标准差。<br> inplace：是否直接在原数据上操作。</p> 
<p>组合转换<br> torchvision.transforms.Compose(transforms)</p> 
<p>描述<br> 将若干个转换方法组合起来。</p> 
<p>参数<br> transforms：带组合的转换方法</p> 
<p>示例</p> 
<h2><a id="mnist__0130703081_74"></a>以mnist数据集为例, 单通道, 其均值和标准差分别为0.1307和0.3081</h2> 
<p>train_file = datasets.MNIST(<br> root=‘./dataset/’,<br> train=True,<br> transform=transforms.Compose([<br> transforms.ToTensor(),<br> transforms.Normalize((0.1307,), (0.3081,))<br> ])<br> )<br> 中心裁剪<br> torchvision.transforms.CenterCrop(size)</p> 
<p>描述<br> 对图片进行中心裁剪。中心就是图片高和宽二分之一的交点。图片必须是PIL.Image或torch.Tensor类型。</p> 
<p>参数<br> size是输出图片的高、宽。你可以给一个整型的数字，比如3，表示输出3x3的图片；你也可以给一个元组，比如(3, 5)，表示输出高为3，宽为5的图片。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)</p> 
<h2><a id="300x300_96"></a>300x300</h2> 
<p>transform_1 = transforms.CenterCrop(300)<br> img_1 = transform_1(img)</p> 
<h2><a id="500x500_99"></a>500x500</h2> 
<p>transform_2 = transforms.CenterCrop(500)<br> img_2 = transform_2(img)</p> 
<h2><a id="500x300_102"></a>500x300</h2> 
<p>transform_3 = transforms.CenterCrop((500,300))<br> img_3 = transform_3(img)<br> 绘图</p> 
<p>边缘拓展<br> torchvision.transforms.Pad(padding, fill=0, padding_mode=‘constant’)</p> 
<p>描述<br> 对图像边缘进行拓展填充。</p> 
<p>参数<br> padding：拓展宽度。如果是整型，则所有边都拓展；如果是二元组，则指定左右和上下的拓展宽度。如果是四元组，则指定左、上、右、下的拓展宽度。<br> fill：像素填充的值，默认是0，代表黑色。可以指定整型，也可以用三元组表示分别填充RGB通道。<br> padding_mode：拓展模式，默认为constant，表示所有填的所有值都一样。edge表示用边缘值填充；reflecty以边缘为对称轴进行轴对称填充（边缘不重复），如在[1, 2, 3, 4]的两边填充2个元素就是[3, 2, 1, 2, 3, 4, 3, 2]；symmetricy以边缘为对称轴进行轴对称填充（边缘重复），如在[1, 2, 3, 4]的两边填充2个元素就是[2, 1, 1, 2, 3, 4, 4, 3]。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)<br> transform = transforms.Pad(100, (255, 0, 0))<br> img = transform(img)<br> 绘图</p> 
<p>随机裁剪<br> torchvision.transforms.RandomCrop(size, padding=None, pad_if_needed=False, fill=0, padding_mode=‘constant’)</p> 
<p>描述<br> 在随机位置对图像进行裁剪</p> 
<p>参数<br> size：输出图片的高、宽。与中心裁剪的参数定义一致。<br> padding：拓展宽度。与边缘拓展的参数定义一致。<br> pad_if_needed：如果设置为True，当图像小于目标尺寸时会先填充再随机裁剪。<br> fill：像素填充值。与边缘拓展的参数定义一致。<br> padding_mode：拓展模式。与边缘拓展的参数定义一致。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)<br> transform = transforms.RandomCrop(300)<br> img_1 = transform(img)<br> img_2 = transform(img)<br> img_3 = transform(img)<br> 绘图</p> 
<p>尺寸缩放<br> torchvision.transforms.Resize(size, interpolation=2)</p> 
<p>描述<br> 调整图像的大小到指定尺寸。图像必须是PIL.Image或torch.Tensor类型。这个也用的比较多，训练是按批的，必须保证每批图像的尺寸是相同，所以一般都会在训练前进行resize操作。</p> 
<p>参数<br> size: 可以输入一个元组，表示图像的高、宽。比如(300, 500)，返回高为300，宽为500的图片；也可以只输入一个整型的数字，短边就是这个数字，然后长边按照相同的长宽比进行调整。比如一张高、宽分别为400、200的图片，指定size = 300，那么返回的图像高、宽分别是600、300。计算过程：∵ with &lt; height ∴ width = size = 300, height = size<em>height/width = 300</em>400*200 = 600。<br> interpolation：插值法，默认即可。</p> 
<p>注意<br> 尺寸缩放的size参数如果只给定一个整数值，返回的图像不一定是方形的。要注意和中心裁剪的size参数区分开来。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)<br> transform = transforms.Resize((720, 720))<br> img = transform(img)<br> img.save(‘img.jpg’)<br> 绘图</p> 
<p>随机旋转<br> torchvision.transforms.RandomRotation(degrees, resample=False, expand=False, center=None, fill=None)</p> 
<p>描述<br> 按角度随机旋转图像。图像必须是PIL.Image或torch.Tensor类型。</p> 
<p>参数<br> degrees： 旋转的角度范围。如果只填一个整型或浮点型的数字，比如90，表示在-90°和90°之间随机旋转。也可以给一个序列类型的值，比如(45, 90)，表示逆时针旋转，旋转角度从45°到90°之间随机取一个值。<br> resample：重采样方法，默认即可。<br> expand：是否扩展。默认为False表示输出图和输入图大小一样，旋转超出区域就丢掉不要了；设置为True表示扩展边界以保证显示整个原图。<br> center：旋转中心的坐标，可接受的输入是元组或列表类型。默认是图片的中心，比如1280x720的图片中心就是(640, 360)。<br> fill：图像外部区域的填充颜色。默认是0也就是黑色，也支持RGB格式的颜色，比如(255, 0, 0)就表示用红色填充。</p> 
<p>拓展<br> 官方只给了按角度随机旋转的方法，并没有给指定角度旋转的方法，但指定角度旋转也可以通过通过设置随机旋转的参数实现。比如图像顺时针旋转90°，只需要设置degrees=(-90, -90)。官方确实很聪明，只用一个函数就把随机旋转和定向旋转都实现了。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)</p> 
<h2><a id="45_195"></a>逆时针旋转45°</h2> 
<p>transform_1 = transforms.RandomRotation(degrees=(45, 45))<br> img_1 = transform_1(img)</p> 
<h2><a id="45_198"></a>逆时针旋转45°，启动拓展</h2> 
<p>transform_2 = transforms.RandomRotation(degrees=(45, 45), expand=True)<br> img_2 = transform_2(img)</p> 
<h2><a id="45_201"></a>逆时针旋转45°，绿色填充</h2> 
<p>transform_3 = transforms.RandomRotation(degrees=(45, 45), fill=(255, 0, 0))<br> img_3 = transform_3(img)<br> 绘图</p> 
<p>水平翻转<br> torchvision.transforms.RandomHorizontalFlip(p=0.5)</p> 
<p>描述<br> 字面意思，就是水平翻转图像。不过是否翻转是随机的。</p> 
<p>参数<br> p：水平翻转的概率，如果是1就一定翻转，如果给0就一定不翻转，如果其它值则按概率随机选择是否翻转。比如0.5，那么就有一半的可能翻转，一般的可能不翻转。图像必须是PIL.Image或torch.Tensor类型。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)<br> transform = transforms.RandomHorizontalFlip(p=1)<br> img = transform(img)<br> img.save(‘img.jpg’)<br> 绘图</p> 
<p>垂直翻转<br> torchvision.transforms.RandomVerticalFlip(p=0.5)</p> 
<p>描述<br> 字面意思，就是垂直翻转图像。不过是否翻转是随机的。</p> 
<p>参数<br> p：垂直翻转的概率，如果是1就一定翻转，如果给0就一定不翻转，如果其它值则按概率随机选择是否翻转。比如0.5，那么就有一半的可能翻转，一般的可能不翻转。图像必须是PIL.Image或torch.Tensor类型。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)<br> transform = transforms.RandomVerticalFlip(p=1)<br> img = transform(img)<br> img.save(‘img.jpg’)<br> 绘图</p> 
<p>色彩抖动<br> torchvision.transforms.ColorJitter(brightness=0, contrast=0, saturation=0, hue=0)</p> 
<p>描述<br> 随机改变图片的亮度，对比度和饱和度。</p> 
<p>参数<br> brightness：亮度；允许输入浮点型或二元组(min, max)。如果是浮点型，那么亮度在[max(0, 1 ## brightness), 1 + brightness]区间随机变换；如果是元组，亮度在给定的元组间随机变换。不允许输入负值。<br> contrast：对比度。允许输入规则和亮度一致。<br> saturation：饱和度。允许输入规则和亮度一致。<br> hue：色调。允许输入浮点型或二元组(min, max)。如果是浮点型，那么亮度在[-hue, hue]区间随机变换；如果是元组，亮度在给定的元组间随机变换。不允许输入负值。必须满足0&lt;= hue &lt;= 0.5 or -0.5 &lt;= min &lt;= max &lt;= 0.5。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)</p> 
<h2><a id="2_261"></a>亮度设置为2</h2> 
<p>transform_1 = transforms.ColorJitter(brightness=(2, 2))<br> img_1 = transform_1(img)</p> 
<h2><a id="2_264"></a>对比度设置为2</h2> 
<p>transform_2 = transforms.ColorJitter(contrast=(2, 2))<br> img_2 = transform_2(img)</p> 
<h2><a id="2_267"></a>饱和度设置为2</h2> 
<p>transform_3 = transforms.ColorJitter(saturation=(2, 2))<br> img_3 = transform_3(img)<br> 绘图</p> 
<p>高斯模糊<br> torchvision.transforms.GaussianBlur(kernel_size, sigma=(0.1, 2.0))</p> 
<p>描述<br> 对图像应用高斯模糊</p> 
<p>参数<br> kernel_size：模糊半径。必须是奇数。<br> sigma：正态分布的标准差。如果是浮点型，则固定；如果是二元组(min, max)，sigma在区间中随机选取一个值。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)</p> 
<h2><a id="___287"></a>模糊半径越大, 正态分布标准差越大, 图像就越模糊</h2> 
<p>transform_1 = transforms.GaussianBlur(21, 10)<br> img_1 = transform_1(img)<br> transform_2 = transforms.GaussianBlur(101, 10)<br> img_2 = transform_2(img)<br> transform_3 = transforms.GaussianBlur(101, 100)<br> img_3 = transform_3(img)<br> 绘图<br> 在这里插入图片描述</p> 
<p>仿射变换<br> torchvision.transforms.RandomAffine(degrees, translate=None, scale=None, shear=None, resample=0, fillcolor=0)</p> 
<p>描述<br> 汇总了旋转、平移、缩放、扭曲等图像变换方法，并且支持叠加。比如旋转的同时又进行平移或缩放等。</p> 
<p>参数<br> degrees (sequence or float or int)：随机旋转的角度范围。和随机旋转的参数定义一致。设置为0表示不旋转。<br> translate (tuple, optional) ：水平和垂直平移的因子。如(a, b)，表示在img_width * a &lt; dx &lt; img_width * a范围内随机水平平移，在-img_height * b &lt; dy &lt; img_height * b范围内随机垂直平移。<br> scale (tuple, optional)：缩放因子。如(a, b)，表示在a &lt;= scale &lt;= b随机缩放。<br> shear (sequence or float or int, optional)：随机扭曲的角度范围。如(45, 90)，表示在45~90范围内随机选取一个角度进行与横轴平行的扭曲。<br> resample (int, optional) ：重采样。<br> fillcolor (tuple or int) ：填充色。默认为0，也就是黑色。支持三元组的RGB颜色。</p> 
<p>示例<br> from PIL import Image<br> from torchvision import transforms<br> img = Image.open(‘test.jpg’)</p> 
<h2><a id="_315"></a>随机旋转</h2> 
<p>transform_1 = transforms.RandomAffine(90)<br> img_1 = transform_1(img)</p> 
<h2><a id="_318"></a>随机平移</h2> 
<p>transform_2 = transforms.RandomAffine(0, (0.1, 0))<br> img_2 = transform_2(img)</p> 
<h2><a id="_321"></a>随机缩放</h2> 
<p>transform_3 = transforms.RandomAffine(0, None, (0.5, 2))<br> img_3 = transform_3(img)</p> 
<h2><a id="_324"></a>随机扭曲</h2> 
<p>transform_4 = transforms.RandomAffine(0, None, None, (45, 90))<br> img_4 = transform_4(img)<br> 绘图<br> 在这里插入图片描述</p> 
<p>测试样例<br> 名称 尺寸<br> test.jpg 1280x720</p> 
<p>注意事项<br> 数据增强的transform操作会增加样本量吗？需不需要单独的把数据集拿出来增强一下再训练？</p> 
<p>如果tranform里面有随机的方法，那么每个epoch训练的数据集将会不同，就相当于增加了样本数量，所以直接训练即可，不用单独拿出来做增强。</p> 
<p>温馨提示<br> 如果是对批数据进行变换，那么该批的所有变换都是相同的。为什么要这样说？之前不是提到随机旋转这些随机的操作嘛，pytorch在训练前需要把数据做成批数据，然后用数据加载器喂到模型中训练，也就是说这些随机的方法对于同一批数据的随机是相同，比如要旋转45°的话就都旋转45°，而不同批可能会不同。</p> 
<p>来源连接：<br> https://www.cnblogs.com/ghgxj/p/14219097.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a0cddc0cb86d696b08db48e1ffa95c9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习（手写数字识别）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b6e60261a8be386d82adf6771c2b819f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">8、SpringCloud高频面试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>