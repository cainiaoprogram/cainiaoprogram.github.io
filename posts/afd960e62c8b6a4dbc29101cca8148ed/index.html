<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JDBC结果集ResultSet映射为实体类(对象) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JDBC结果集ResultSet映射为实体类(对象)" />
<meta property="og:description" content="1.方法抽取
public static List&lt;Object&gt; handler(ResultSet rs, Class&lt;?&gt; clazz) { List&lt;Object&gt; list = new ArrayList&lt;&gt;(); Object obj = null; try { while (rs.next()) { // 创建一个clazz对象实例并将其赋给要返回的那个返回值。 obj = clazz.newInstance(); // 获取结果集的数据源 ResultSetMetaData rsmeta = rs.getMetaData(); // 获取结果集中的字段数 int count = rsmeta.getColumnCount(); // 循环取出个字段的名字以及他们的值并将其作为值赋给对应的实体对象的属性 for (int i = 0; i &lt; count; i&#43;&#43;) { // 获取字段名 String name = rsmeta.getColumnName(i &#43; 1); // 利用反射将结果集中的字段名与实体对象中的属性名相对应，由于 // 对象的属性都是私有的所以要想访问必须加上getDeclaredField(name)和 Field f = obj.getClass().getDeclaredField(name); f.setAccessible(true); // 将结果集中的值赋给相应的对象实体的属性 f." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/afd960e62c8b6a4dbc29101cca8148ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-26T18:50:43+08:00" />
<meta property="article:modified_time" content="2019-03-26T18:50:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JDBC结果集ResultSet映射为实体类(对象)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>1.方法抽取</strong></p> 
<pre class="has"><code class="language-java">public static List&lt;Object&gt; handler(ResultSet rs, Class&lt;?&gt; clazz) {
        List&lt;Object&gt; list = new ArrayList&lt;&gt;();
        Object obj = null;
        try {
            while (rs.next()) {
                // 创建一个clazz对象实例并将其赋给要返回的那个返回值。
                obj = clazz.newInstance();
                // 获取结果集的数据源
                ResultSetMetaData rsmeta = rs.getMetaData();

                // 获取结果集中的字段数
                int count = rsmeta.getColumnCount();

                // 循环取出个字段的名字以及他们的值并将其作为值赋给对应的实体对象的属性
                for (int i = 0; i &lt; count; i++) {
                    // 获取字段名
                    String name = rsmeta.getColumnName(i + 1);
                    // 利用反射将结果集中的字段名与实体对象中的属性名相对应，由于
                    // 对象的属性都是私有的所以要想访问必须加上getDeclaredField(name)和
                    Field f = obj.getClass().getDeclaredField(name);
                    f.setAccessible(true);
                    // 将结果集中的值赋给相应的对象实体的属性
                    f.set(obj, rs.getObject(name));
                }
                list.add(obj);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return list;
    }</code></pre> 
<p><strong>2.版本2</strong></p> 
<pre class="has"><code class="language-java"> //resultToList方法
public static &lt;T&gt; List&lt;T&gt; resultToList(ResultSet resultSet, Class&lt;T&gt; clazz) {  
          //创建一个 T 类型的数组
        List&lt;T&gt; list = new ArrayList&lt;&gt;();
        try {
             //通过反射获取对象的实例
            T t = clazz.getConstructor().newInstance();
            //获取resultSet 的列的信息
            ResultSetMetaData metaData = resultSet.getMetaData();
            //遍历resultSet
            while (resultSet.next()) {
                  //遍历每一列
                for (int i = 0; i &lt; metaData.getColumnCount(); i++) {
                    //获取列的名字
                    String fName = metaData.getColumnLabel(i + 1);
                    //因为列的名字和我们EMP中的属性名是一样的，所以通过列的名字获得其EMP中属性
                    Field field = clazz.getDeclaredField(fName.toLowerCase());
                    //因为属性是私有的，所有获得其对应的set 方法。set+属性名首字母大写+其他小写
                    String setName = "set" + fName.toUpperCase().substring(0, 1) + fName.substring(1).toLowerCase();
                    //因为属性的类型和set方法的参数类型一致，所以可以获得set方法
                    Method setMethod = clazz.getMethod(setName, field.getType());
                    //执行set方法，把resultSet中的值传入emp中，  再继续循环传值
                    setMethod.invoke(t, resultSet.getObject(fName));
                }
                //把赋值后的对象 加入到list集合中
                list.add(t);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        // 返回list
    return list;
    }</code></pre> 
<p><strong>3.版本三</strong></p> 
<pre class="has"><code class="language-java">  public static List Populate(ResultSet rs,Class cc) throws SQLException, InstantiationException, IllegalAccessException{
         
         //结果集 中列的名称和类型的信息
         ResultSetMetaData rsm = rs.getMetaData();
         int colNumber = rsm.getColumnCount();
         List list = new ArrayList();
         Field[] fields = cc.getDeclaredFields();
         
         //遍历每条记录
         while(rs.next()){
             //实例化对象
             Object obj = cc.newInstance();
             //取出每一个字段进行赋值
             for(int i=1;i&lt;=colNumber;i++){
                 Object value = rs.getObject(i);
                 //匹配实体类中对应的属性
                 for(int j = 0;j&lt;fields.length;j++){
                     Field f = fields[j];
                     if(f.getName().equals(rsm.getColumnName(i))){
                         boolean flag = f.isAccessible();
                         f.setAccessible(true);
                         f.set(obj, value);
                         f.setAccessible(flag);
                         break;
                     }
                 }
                  
             }
             list.add(obj);
         }
         return list;
     }</code></pre> 
<p><strong>4.版本四</strong></p> 
<pre class="has"><code class="language-java">    public static &lt;T&gt; ArrayList&lt;T&gt; putResult(ResultSet rs, Class&lt;T&gt; obj) throws FrameException {
        try {
            ArrayList&lt;T&gt; arrayList = new ArrayList&lt;T&gt;();
            ResultSetMetaData metaData = rs.getMetaData();
            //获取总列数,确定为对象赋值遍历次数
            int count = metaData.getColumnCount();
            while (rs.next()) {
                // 创建对象实例
                T newInstance = obj.newInstance();
                // 开始为一个对象赋值
                for (int i = 1; i &lt;= count; i++) {
                    // 给对象的某个属性赋值
                    String name = metaData.getColumnName(i).toLowerCase();
                    // 改变列名格式成java命名格式
                    name = toJavaField(name);
                    // 首字母大写
                    String substring = name.substring(0, 1);
                    String replace = name.replaceFirst(substring, substring.toUpperCase());
                    // 获取字段类型
                    Class&lt;?&gt; type = obj.getDeclaredField(name).getType();
                    Method method = obj.getMethod("set" + replace, type);
                    //判断读取数据的类型
                    if (type.isAssignableFrom(String.class)) {
                        method.invoke(newInstance, rs.getString(i));
                    } else if (type.isAssignableFrom(int.class) || type.isAssignableFrom(Integer.class)) {
                        method.invoke(newInstance, rs.getInt(i));
                    } else if (type.isAssignableFrom(Boolean.class) || type.isAssignableFrom(boolean.class)) {
                        method.invoke(newInstance, rs.getBoolean(i));
                    } else if (type.isAssignableFrom(Date.class)) {
                        method.invoke(newInstance, rs.getDate(i));
                    } else if (type.isAssignableFrom(BigDecimal.class)) {
                        method.invoke(newInstance, rs.getBigDecimal(i));
                    }
                }
                arrayList.add(newInstance);
            }
            return arrayList;
        } catch (Exception e) {
            logger.error(e);
            throw new FrameException("内部错误，请与管理员联系，对象赋值错误");
        }</code></pre> 
<p><strong>注意：</strong></p> 
<p><strong>实体类中的属性类型一定要和数据库中的字段类型保持一致，否则会转换失败，当遇到实体类中的成员属性过多时，可以考虑用map集合封装</strong></p> 
<p><strong>实体类要重写HashCode()和equals()方法，确保一致性</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/681f1af27e6bb35c44ab5f5100ec5d77/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ASCII、Unicode、UTF-8</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6426b0fe50df644b67d1db08978a08d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">树类算法之--XGBoost算法原理&amp;代码实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>