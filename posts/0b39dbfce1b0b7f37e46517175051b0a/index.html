<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何列出目录的所有文件？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何列出目录的所有文件？" />
<meta property="og:description" content="这篇文章是社区维基 。 编辑现有答案以改善此职位。 它当前不接受新的答案。 了解更多 。 如何在Python中列出目录的所有文件并将它们添加到list ？ #1楼 dircache是“自2.6版起不推荐使用：dircache模块已在Python 3.0中删除。” import dircache list = dircache.listdir(pathname) i = 0 check = len(list[0]) temp = [] count = len(list) while count != 0: if len(list[i]) != check: temp.append(list[i-1]) check = len(list[i]) else: i = i &#43; 1 count = count - 1 print temp #2楼 从目录及其所有子目录获取完整的文件路径 import os def get_filepaths(directory): &#34;&#34;&#34; This function will generate the file names in a directory tree by walking the tree either top-down or bottom-up." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0b39dbfce1b0b7f37e46517175051b0a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-01T14:04:23+08:00" />
<meta property="article:modified_time" content="2019-12-01T14:04:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何列出目录的所有文件？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="grid fw-nowrap"> 
 <div class="grid--cell mr8"> 
 </div> 
 <div class="grid fw-nowrap fd-column"> 
  <div class="grid--cell fl1 lh-lg">
    这篇文章是社区维基 。 编辑现有答案以改善此职位。 它当前不接受新的答案。 
   <a href="/help/locked-posts" rel="nofollow">了解更多</a> 。 
  </div> 
 </div> 
</div> 
<p> 如何在<a href="http://www.javaxxz.com/thread-364542-1-1.html" rel="nofollow">Python</a>中列出目录的所有文件并将它们添加到<code>list</code> ？ </p> 
<hr> 
<h4>#1楼</h4> 
<p> <em><a href="http://docs.python.org/release/2.6.7/library/dircache.html" rel="nofollow">dircache</a>是“自2.6版起不推荐使用：dircache模块已在Python 3.0中删除。”</em> </p> 
<pre><code>import dircache
list = dircache.listdir(pathname)
i = 0
check = len(list[0])
temp = []
count = len(list)
while count != 0:
  if len(list[i]) != check:
     temp.append(list[i-1])
     check = len(list[i])
  else:
    i = i + 1
    count = count - 1

print temp
</code></pre> 
<hr> 
<h4>#2楼</h4> 
<p> <strong>从目录及其所有子目录获取完整的文件路径</strong> </p> 
<pre><code>import os

def get_filepaths(<a href="http://www.javaxxz.com/thread-380868-1-1.html" rel="nofollow">directory</a>):
    """
    This function will generate the file names in a directory 
    tree by walking the tree either top-down or bottom-up. For each 
    directory in the tree rooted at directory top (including top itself), 
    it yields a 3-tuple (dirpath, dirnames, filenames).
    """
    file_paths = []  # List which will store all of the full filepaths.

    # Walk the tree.
    for root, directories, files in os.walk(directory):
        for filename in files:
            # Join the two strings in order to form the full filepath.
            filepath = os.path.join(root, filename)
            file_paths.append(filepath)  # Add it to the list.

    return file_paths  # Self-explanatory.

# Run the above function and store its results in a variable.   
full_file_paths = get_filepaths("/Users/johnny/Desktop/TEST")
</code></pre> 
<hr> 
<ul><li> 我在上述函数中提供的路径包含3个文件-其中两个在根目录中，另一个在子文件夹“ SUBFOLDER”中。 您现在可以执行以下操作： </li><li><p> <code>print full_file_paths</code>将打印列表： </p> 
  <ul><li> <code>['/Users/johnny/Desktop/TEST/file1.txt', '/Users/johnny/Desktop/TEST/file2.txt', '/Users/johnny/Desktop/TEST/SUBFOLDER/file3.dat']</code> </li></ul></li></ul> 
<p> 如果愿意，您可以打开和阅读内容，或者仅关注扩展名为“ .dat”的文件，如以下代码所示： </p> 
<pre><code>for f in full_file_paths:
  if f.endswith(".dat"):
    print f
</code></pre> 
<p> <code>/Users/johnny/Desktop/TEST/SUBFOLDER/file3.dat</code> </p> 
<hr> 
<h4>#3楼</h4> 
<p> 一种<strong>仅</strong>获取<strong>文件列表</strong> （不包含子目录）的单行解决方案： </p> 
<pre class="lang-py prettyprint-override"><code>filenames = next(os.walk(path))[2]
</code></pre> 
<p> 或绝对路径名： </p> 
<pre class="lang-py prettyprint-override"><code>paths = [os.path.join(path, fn) for fn in next(os.walk(path))[2]]
</code></pre> 
<hr> 
<h4>#4楼</h4> 
<p> 如果您正在寻找<strong>find</strong>的Python实现，这是我经常使用的食谱： </p> 
<pre><code>from findtools.find_files import (find_files, Match)

# Recursively find all *.sh files in **/usr/bin**
sh_files_pattern = Match(filetype='f', name='*.sh')
found_files = find_files(path='/usr/bin', match=sh_files_pattern)

for found_file in found_files:
    print found_file
</code></pre> 
<p> 因此，我用它制作了一个PyPI <a href="https://pypi.python.org/pypi/findtools/" rel="nofollow">软件包</a> ，并且还有一个<a href="https://github.com/ewiger/findtools">GitHub存储库</a> 。 我希望有人发现它可能对该代码有用。 </p> 
<hr> 
<h4>#5楼</h4> 
<pre><code>def list_files(path):
    # returns a list of names (with extension, without full path) of all files 
    # in folder path
    files = []
    for name in os.listdir(path):
        if os.path.isfile(os.path.join(path, name)):
            files.append(name)
    return files 
</code></pre> 
<hr> 
<h4>#6楼</h4> 
<p> <strong>返回绝对文件路径的列表，不会递归到子目录中</strong> </p> 
<pre><code>L = [os.path.join(os.getcwd(),f) for f in os.listdir('.') if os.path.isfile(os.path.join(os.getcwd(),f))]
</code></pre> 
<hr> 
<h4>#7楼</h4> 
<p> 我真的很喜欢<a href="https://stackoverflow.com/a/3215392/901641" rel="nofollow">adamk的答案</a> ，建议您使用同名模块中的<code>glob()</code> 。 这使您可以使用<code>*</code> s进行模式匹配。 </p> 
<p> 但是正如其他人在评论中指出的那样， <code>glob()</code>可能会在不一致的斜杠方向上绊倒。 为了解决这个问题，建议您使用<code>os.path</code>模块中的<code>join()</code>和<code>expanduser()</code>函数，以及<code>os</code>模块中的<code>getcwd()</code>函数。 </p> 
<p> 例如： </p> 
<pre><code>from glob import glob

# Return everything under C:\Users\admin that contains a folder called wlp.
glob('C:\Users\admin\*\wlp')
</code></pre> 
<p> 上面的代码很糟糕-路径已经过硬编码，并且只能在Windows上的驱动器名称和被硬编码到路径之间的<code>\\</code> 。 </p> 
<pre><code>from glob    import glob
from os.path import join

# Return everything under Users, admin, that contains a folder called wlp.
glob(join('Users', 'admin', '*', 'wlp'))
</code></pre> 
<p> 上面的方法效果更好，但是它依赖于Windows上常见的文件夹名称<code>Users</code> ，而在其他OS上则不常见。 它还依赖于具有特定名称<code>admin</code>的用户。 </p> 
<pre><code>from glob    import glob
from os.path import expanduser, join

# Return everything under the user directory that contains a folder called wlp.
glob(join(expanduser('~'), '*', 'wlp'))
</code></pre> 
<p> 这可以在所有平台上完美运行。 </p> 
<p> 另一个很好的示例，它可以在各种平台上完美运行，并且有所不同： </p> 
<pre><code>from glob    import glob
from os      import getcwd
from os.path import join

# Return everything under the current directory that contains a folder called wlp.
glob(join(getcwd(), '*', 'wlp'))
</code></pre> 
<p> 希望这些示例可以帮助您了解在标准Python库模块中可以找到的一些功能的强大功能。 </p> 
<hr> 
<h4>#8楼</h4> 
<p> 从3.4版开始，有内置的<em>迭代器</em> ，比<a href="http://docs.python.org/3/library/os.html#os.listdir" rel="nofollow"><code>os.listdir()</code></a>效率更高： </p> 
<p> <a href="http://docs.python.org/3/library/pathlib.html" rel="nofollow"><code>pathlib</code></a> ： <em>版本3.4中的新增功能。</em> </p> 
<pre><code>&gt;&gt;&gt; import pathlib
&gt;&gt;&gt; [p for p in pathlib.Path('.').iterdir() if p.is_file()]
</code></pre> 
<p> 根据<a href="http://www.python.org/dev/peps/pep-0428/" rel="nofollow">PEP 428</a> ， <a href="http://docs.python.org/3/library/pathlib.html" rel="nofollow"><code>pathlib</code></a>库的目的是提供一个简单的类层次结构，以处理文件系统路径以及用户对其进行的常见操作。 </p> 
<p> <a href="http://docs.python.org/3/library/os.html#os.scandir" rel="nofollow"><code>os.scandir()</code></a> ： <em>3.5版中的新功能。</em> </p> 
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; [entry for entry in os.scandir('.') if entry.is_file()]
</code></pre> 
<p> 请注意，从3.5版开始， <a href="http://docs.python.org/3/library/os.html#os.walk" rel="nofollow"><code>os.walk()</code></a>使用<a href="http://docs.python.org/3/library/os.html#os.scandir" rel="nofollow"><code>os.scandir()</code></a>而不是<a href="http://docs.python.org/3/library/os.html#os.listdir" rel="nofollow"><code>os.listdir()</code></a> ，根据<a href="http://www.python.org/dev/peps/pep-0471/" rel="nofollow">PEP 471</a> ，其速度提高了2-20倍。 </p> 
<p> 我也建议您阅读下面的ShadowRanger评论。 </p> 
<hr> 
<h4>#9楼</h4> 
<pre><code>import os
os.listdir("somedirectory")
</code></pre> 
<p> 将返回“ somedirectory”中所有文件和目录的列表。 </p> 
<hr> 
<h4>#10楼</h4> 
<p> <a href="https://docs.python.org/2/library/os.html#os.listdir" rel="nofollow" title="os.listdir"><code>os.listdir()</code></a>将为您提供目录中的所有内容-文件和目录。 </p> 
<p> 如果<em>只需要</em>文件，则可以使用<a href="https://docs.python.org/2/library/os.path.html#module-os.path" rel="nofollow"><code>os.path</code></a>将其过滤掉： </p> 
<pre><code>from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]
</code></pre> 
<p> 或者您可以使用<a href="https://docs.python.org/2/library/os.html#os.walk" rel="nofollow" title="步行"><code>os.walk()</code></a> ，它将为它访问的每个目录生成两个列表-为您拆分为文件和目录。 如果只需要顶层目录，可以在第一次生成目录时中断 </p> 
<pre><code>from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break
</code></pre> 
<hr> 
<h4>#11楼</h4> 
<p> 我更喜欢使用<a href="https://docs.python.org/library/glob.html" rel="nofollow"><code>glob</code></a>模块，因为它可以进行模式匹配和扩展。 </p> 
<pre><code>import glob
print(glob.glob("/home/adam/*.txt"))
</code></pre> 
<p> 它将返回包含查询文件的列表： </p> 
<pre><code>['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]
</code></pre> 
<hr> 
<h4>#12楼</h4> 
<p> 使用发电机 </p> 
<pre><code>import os
def get_files(search_path):
     for (dirpath, _, filenames) in os.walk(search_path):
         for filename in filenames:
             yield os.path.join(dirpath, filename)
list_files = get_files('.')
for filename in list_files:
    print(filename)
</code></pre> 
<hr> 
<h4>#13楼</h4> 
<blockquote> 
 <h2> 使用Python 2和3获取文件列表 </h2> 
</blockquote> 
<hr> 
<blockquote> 
 <h2> <code>os.listdir()</code> </h2> 
</blockquote> 
<p> 如何获取当前目录中的所有文件（和目录）（Python 3） </p> 
<p> 以下是在Python 3中使用<code>os</code>和<code>listdir()</code>函数仅检索当前目录中文件的简单方法。进一步的探索将演示如何返回目录中的文件夹，但子目录中没有文件，为此您可以使用步行-稍后讨论）。 </p> 
<pre><code> import os
 arr = os.listdir()
 print(arr)

 &gt;&gt;&gt; ['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']
</code></pre> 
<blockquote> 
 <h2> <code>glob</code> </h2> 
</blockquote> 
<p> <em>我发现glob更容易选择相同类型或有共同点的文件。</em> <em>看下面的例子：</em> </p> 
<pre><code>import glob

txtfiles = []
for file in glob.glob("*.txt"):
    txtfiles.append(file)
</code></pre> 
<blockquote> 
 <h3> 具有列表理解的<code>glob</code> </h3> 
</blockquote> 
<pre><code>import glob

mylist = [f for f in glob.glob("*.txt")]
</code></pre> 
<blockquote> 
 <h3> 具有功能的<code>glob</code> </h3> 
</blockquote> 
<pre><code>import glob

def filebrowser():
    return [f for f in glob.glob("*")]

x = filebrowser()
print(x)

&gt;&gt;&gt; ['example.txt', 'fb.py', 'filebrowser.py', 'help']
</code></pre> 
<blockquote> 
 <h3> 扩展先前代码的<code>glob</code> </h3> 
</blockquote> 
<p> 该函数现在返回与您作为参数传递的字符串匹配的文件列表 </p> 
<pre><code>import glob

def filebrowser(word=""):
    """Returns a list with all files with the word/extension in it"""
    file = []
    for f in glob.glob("*"):
        if word in f:
            file.append(f)
            return file

flist = filebrowser("example")
print(flist)
flist = filebrowser(".py")
print(flist)

&gt;&gt;&gt; ['example.txt']
&gt;&gt;&gt; ['fb.py', 'filebrowser.py']
</code></pre> 
<blockquote> 
 <h3> 使用<code>os.path.abspath</code>获取完整的路径名 </h3> 
</blockquote> 
<p> 正如您所注意到的，上面的代码中没有文件的完整路径。 如果需要绝对路径，则可以使用<code>os.path</code>模块的另一个函数<code>_getfullpathname</code> ，将从<code>os.listdir()</code>获得的文件作为参数。 还有其他完整路径的方法，稍后我们将进行检查（如mexmex所建议，我将_getfullpathname替换为<code>abspath</code> ）。 </p> 
<pre><code> import os
 files_path = [os.path.abspath(x) for x in os.listdir()]
 print(files_path)

 &gt;&gt;&gt; ['F:\\documenti\applications.txt', 'F:\\documenti\collections.txt']
</code></pre> 
<blockquote> 
 <h3> 使用<code>walk</code>获取所有子目录中文件类型的完整路径名 </h3> 
</blockquote> 
<p> 我发现在很多目录中查找内容非常有用，它有助于我找到一个我不记得其名称的文件： </p> 
<pre><code>import os

# Getting the current work directory (cwd)
thisdir = os.getcwd()

# r=root, d=directories, f = files
for r, d, f in os.walk(thisdir):
    for file in f:
        if ".docx" in file:
            print(os.path.join(r, file))
</code></pre> 
<blockquote> 
 <h4> <code>os.listdir()</code> ：获取当前目录中的文件（Python 2） </h4> 
</blockquote> 
<p> 在Python 2中，如果要在当前目录中列出文件列表，则必须将参数指定为“。”。 或os.listdir方法中的os.getcwd（）。 </p> 
<pre><code> import os
 arr = os.listdir('.')
 print(arr)

 &gt;&gt;&gt; ['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']
</code></pre> 
<blockquote> 
 <h4> 进入目录树 </h4> 
</blockquote> 
<pre><code># Method 1
x = os.listdir('..')

# Method 2
x= os.listdir('/')
</code></pre> 
<blockquote> 
 <h4> 获取文件：特定目录中的<code>os.listdir()</code> （Python 2和3） </h4> 
</blockquote> 
<pre><code> import os
 arr = os.listdir('F:\\python')
 print(arr)

 &gt;&gt;&gt; ['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']
</code></pre> 
<blockquote> 
 <h4> 使用<code>os.listdir()</code>获取特定子目录的文件 </h4> 
</blockquote> 
<pre><code>import os

x = os.listdir("./content")
</code></pre> 
<blockquote> 
 <h4> <code>os.walk('.')</code> -当前目录 </h4> 
</blockquote> 
<pre><code> import os
 arr = next(os.walk('.'))[2]
 print(arr)

 &gt;&gt;&gt; ['5bs_Turismo1.pdf', '5bs_Turismo1.pptx', 'esperienza.txt']
</code></pre> 
<blockquote> 
 <h4> <code>next(os.walk('.'))</code>和<code>os.path.join('dir', 'file')</code> </h4> 
</blockquote> 
<pre><code> import os
 arr = []
 for d,r,f in next(os.walk("F:\\_python")):
     for file in f:
         arr.append(os.path.join(r,file))

 for f in arr:
     print(files)

&gt;&gt;&gt; F:\\_python\\dict_class.py
&gt;&gt;&gt; F:\\_python\\programmi.txt
</code></pre> 
<blockquote> 
 <h4> <code>next(os.walk('F:\\\\')</code> -获取完整路径-列表理解 </h4> 
</blockquote> 
<pre><code> [os.path.join(r,file) for r,d,f in next(os.walk("F:\\_python")) for file in f]

 &gt;&gt;&gt; ['F:\\_python\\dict_class.py', 'F:\\_python\\programmi.txt']
</code></pre> 
<blockquote> 
 <h4> <code>os.walk</code>获取完整路径-sub dirs中的所有文件** </h4> 
</blockquote> 
<pre><code>x = [os.path.join(r,file) for r,d,f in os.walk("F:\\_python") for file in f]
print(x)

&gt;&gt;&gt; ['F:\\_python\\dict.py', 'F:\\_python\\progr.txt', 'F:\\_python\\readl.py']
</code></pre> 
<blockquote> 
 <h4> <code>os.listdir()</code> -仅获取txt文件 </h4> 
</blockquote> 
<pre><code> arr_txt = [x for x in os.listdir() if x.endswith(".txt")]
 print(arr_txt)

 &gt;&gt;&gt; ['work.txt', '3ebooks.txt']
</code></pre> 
<blockquote> 
 <h3> 使用<code>glob</code>获取文件的完整路径 </h3> 
</blockquote> 
<p> 如果我需要文件的绝对路径： </p> 
<pre><code>from path import path
from glob import glob
x = [path(f).abspath() for f in glob("F:\\*.txt")]
for f in x:
    print(f)

&gt;&gt;&gt; F:\acquistionline.txt
&gt;&gt;&gt; F:\acquisti_2018.txt
&gt;&gt;&gt; F:\bootstrap_jquery_ecc.txt
</code></pre> 
<blockquote> 
 <h3> 使用<code>os.path.isfile</code>避免列表中的目录 </h3> 
</blockquote> 
<pre><code>import os.path
listOfFiles = [f for f in os.listdir() if os.path.isfile(f)]
print(listOfFiles)

&gt;&gt;&gt; ['a simple game.py', 'data.txt', 'decorator.py']
</code></pre> 
<blockquote> 
 <h3> 从Python 3.4使用<code>pathlib</code> </h3> 
</blockquote> 
<pre><code>import pathlib

flist = []
for p in pathlib.Path('.').iterdir():
    if p.is_file():
        print(p)
        flist.append(p)

 &gt;&gt;&gt; error.PNG
 &gt;&gt;&gt; exemaker.bat
 &gt;&gt;&gt; guiprova.mp3
 &gt;&gt;&gt; setup.py
 &gt;&gt;&gt; speak_gui2.py
 &gt;&gt;&gt; thumb.PNG
</code></pre> 
<p> 具有<code>list comprehension</code> ： </p> 
<pre><code>flist = [p for p in pathlib.Path('.').iterdir() if p.is_file()]
</code></pre> 
<p> <em>或者，使用<code>pathlib.Path()</code>代替<code>pathlib.Path(".")</code></em> </p> 
<blockquote> 
 <h3> 在pathlib.Path（）中使用glob方法 </h3> 
</blockquote> 
<pre><code>import pathlib

py = pathlib.Path().glob("*.py")
for file in py:
    print(file)

&gt;&gt;&gt; stack_overflow_list.py
&gt;&gt;&gt; stack_overflow_list_tkinter.py
</code></pre> 
<blockquote> 
 <h3> 使用os.walk获取所有文件 </h3> 
</blockquote> 
<pre><code>import os
x = [i[2] for i in os.walk('.')]
y=[]
for t in x:
    for f in t:
        y.append(f)
print(y)

&gt;&gt;&gt; ['append_to_list.py', 'data.txt', 'data1.txt', 'data2.txt', 'data_180617', 'os_walk.py', 'READ2.py', 'read_data.py', 'somma_defaltdic.py', 'substitute_words.py', 'sum_data.py', 'data.txt', 'data1.txt', 'data_180617']
</code></pre> 
<blockquote> 
 <h3> 仅获取具有next的文件并进入目录 </h3> 
</blockquote> 
<pre><code> import os
 x = next(os.walk('F://python'))[2]
 print(x)

 &gt;&gt;&gt; ['calculator.bat','calculator.py']
</code></pre> 
<blockquote> 
 <h3> 仅获取具有next的目录并进入目录 </h3> 
</blockquote> 
<pre><code> import os
 next(os.walk('F://python'))[1] # for the current dir use ('.')

 &gt;&gt;&gt; ['python3','others']
</code></pre> 
<blockquote> 
 <h3> 使用<code>walk</code>获取所有子目录名称 </h3> 
</blockquote> 
<pre><code>for r,d,f in os.walk("F:\\_python"):
    for dirs in d:
        print(dirs)

&gt;&gt;&gt; .vscode
&gt;&gt;&gt; pyexcel
&gt;&gt;&gt; pyschool.py
&gt;&gt;&gt; subtitles
&gt;&gt;&gt; _metaprogramming
&gt;&gt;&gt; .ipynb_checkpoints
</code></pre> 
<blockquote> 
 <h3> python 3.5及更高版本中的<code>os.scandir()</code> </h3> 
</blockquote> 
<pre><code>import os
x = [f.name for f in os.scandir() if f.is_file()]
print(x)

&gt;&gt;&gt; ['calculator.bat','calculator.py']

# Another example with scandir (a little variation from docs.python.org)
# This one is more efficient than os.listdir.
# In this case, it shows the files only in the current directory
# where the script is executed.

import os
with os.scandir() as i:
    for entry in i:
        if entry.is_file():
            print(entry.name)

&gt;&gt;&gt; ebookmaker.py
&gt;&gt;&gt; error.PNG
&gt;&gt;&gt; exemaker.bat
&gt;&gt;&gt; guiprova.mp3
&gt;&gt;&gt; setup.py
&gt;&gt;&gt; speakgui4.py
&gt;&gt;&gt; speak_gui2.py
&gt;&gt;&gt; speak_gui3.py
&gt;&gt;&gt; thumb.PNG
</code></pre> 
<blockquote> 
 <h2> 例子： </h2> 
 <h3> 例如 1：子目录中有多少个文件？ </h3> 
</blockquote> 
<p> 在此示例中，我们查找所有目录及其子目录中包含的文件数。 </p> 
<pre><code>import os

def count(dir, counter=0):
    "returns number of files in dir and subdirs"
    for pack in os.walk(dir):
        for f in pack[2]:
            counter += 1
    return dir + " : " + str(counter) + "files"

print(count("F:\\python"))

&gt;&gt;&gt; 'F:\\\python' : 12057 files'
</code></pre> 
<blockquote> 
 <h3> 例2：如何将所有文件从一个目录复制到另一个目录？ </h3> 
</blockquote> 
<p> 用于在计算机中排序的脚本，以查找一种类型的所有文件（默认值：pptx）并将其复制到新文件夹中。 </p> 
<pre><code>import os
import shutil
from path import path

destination = "F:\\file_copied"
# os.makedirs(destination)

def copyfile(dir, filetype='pptx', counter=0):
    "Searches for pptx (or other - pptx is the default) files and copies them"
    for pack in os.walk(dir):
        for f in pack[2]:
            if f.endswith(filetype):
                fullpath = pack[0] + "\\" + f
                print(fullpath)
                shutil.copy(fullpath, destination)
                counter += 1
    if counter &gt; 0:
        print('-' * 30)
        print("\t==&gt; Found in: `" + dir + "` : " + str(counter) + " files\n")

for dir in os.listdir():
    "searches for folders that starts with `_`"
    if dir[0] == '_':
        # copyfile(dir, filetype='pdf')
        copyfile(dir, filetype='txt')


&gt;&gt;&gt; _compiti18\Compito Contabilità 1\conti.txt
&gt;&gt;&gt; _compiti18\Compito Contabilità 1\modula4.txt
&gt;&gt;&gt; _compiti18\Compito Contabilità 1\moduloa4.txt
&gt;&gt;&gt; ------------------------
&gt;&gt;&gt; ==&gt; Found in: `_compiti18` : 3 files
</code></pre> 
<blockquote> 
 <h3> 例如 3：如何获取txt文件中的所有文件 </h3> 
</blockquote> 
<p> 如果要使用所有文件名创建一个txt文件，请执行以下操作： </p> 
<pre><code>import os
mylist = ""
with open("filelist.txt", "w", encoding="utf-8") as file:
    for eachfile in os.listdir():
        mylist += eachfile + "\n"
    file.write(mylist)
</code></pre> 
<blockquote> 
 <h3> 示例：包含硬盘驱动器所有文件的txt </h3> 
</blockquote> 
<pre><code>"""
We are going to save a txt file with all the files in your directory.
We will use the function walk()
"""

import os

# see all the methods of os
# print(*dir(os), sep=", ")
listafile = []
percorso = []
with open("lista_file.txt", "w", encoding='utf-8') as testo:
    for root, dirs, files in os.walk("D:\\"):
        for file in files:
            listafile.append(file)
            percorso.append(root + "\\" + file)
            testo.write(file + "\n")
listafile.sort()
print("N. of files", len(listafile))
with open("lista_file_ordinata.txt", "w", encoding="utf-8") as testo_ordinato:
    for file in listafile:
        testo_ordinato.write(file + "\n")

with open("percorso.txt", "w", encoding="utf-8") as file_percorso:
    for file in percorso:
        file_percorso.write(file + "\n")

os.system("lista_file.txt")
os.system("lista_file_ordinata.txt")
os.system("percorso.txt")
</code></pre> 
<blockquote> 
 <h3> C：\\的所有文件都在一个文本文件中 </h3> 
 <p> 这是先前代码的简短版本。 如果您需要从另一个位置开始，请更改开始查找文件的文件夹。 这段代码在我的计算机上的文本文件上生成了50 mb的内容，其中包含完整路径的文件少于500.000行。 </p> 
</blockquote> 
<pre><code>import os

with open("file.txt", "w", encoding="utf-8") as filewrite:
    for r, d, f in os.walk("C:\\"):
        for file in f:
            filewrite.write(f"{r + file}\n")
</code></pre> 
<blockquote> 
 <h3> 如何在一个类型的文件夹中写入所有路径的文件 </h3> 
</blockquote> 
<p> 使用此功能，您可以创建一个txt文件，该文件将具有您要查找的文件类型的名称（例如pngfile.txt），并带有该类型所有文件的所有完整路径。 我认为有时候它会很有用。 </p> 
<pre><code>import os

def searchfiles(extension='.ttf', folder='H:\\'):
    "Create a txt file with all the file of a type"
    with open(extension[1:] + "file.txt", "w", encoding="utf-8") as filewrite:
        for r, d, f in os.walk(folder):
            for file in f:
                if file.endswith(extension):
                    filewrite.write(f"{r + file}\n")

# looking for png file (fonts) in the hard disk H:\
searchfiles('.png', 'H:\\')

&gt;&gt;&gt; H:\4bs_18\Dolphins5.png
&gt;&gt;&gt; H:\4bs_18\Dolphins6.png
&gt;&gt;&gt; H:\4bs_18\Dolphins7.png
&gt;&gt;&gt; H:\5_18\marketing html\assets\imageslogo2.png
&gt;&gt;&gt; H:\7z001.png
&gt;&gt;&gt; H:\7z002.png
</code></pre> 
<blockquote> 
 <h3> （新）找到所有文件并使用tkinter GUI打开它们 </h3> 
 <p> 我只是想在这个2019年添加一个小应用程序来搜索目录中的所有文件，并能够通过双击列表中文件的名称来打开它们。 <a href="https://i.stack.imgur.com/7WT22.png" rel="nofollow"><img src="https://images2.imgbox.com/1e/89/GNE6ENHR_o.png" alt="在此处输入图片说明"></a> </p> 
</blockquote> 
<pre><code>import tkinter as tk
import os

def searchfiles(extension='.txt', folder='H:\\'):
    "insert all files in the listbox"
    for r, d, f in os.walk(folder):
        for file in f:
            if file.endswith(extension):
                lb.insert(0, r + "\\" + file)

def open_file():
    os.startfile(lb.get(lb.curselection()[0]))

root = tk.Tk()
root.geometry("400x400")
bt = tk.Button(root, text="Search", command=lambda:searchfiles('.png', 'H:\\'))
bt.pack()
lb = tk.Listbox(root)
lb.pack(fill="both", expand=1)
lb.bind("&lt;Double-Button&gt;", lambda x: open_file())
root.mainloop()
</code></pre> 
<hr> 
<h4>#14楼</h4> 
<p> 这是我的通用功能。 它返回文件路径而不是文件名的列表，因为我发现它更有用。 它具有一些可选参数，使其具有通用性。 例如，我经常将其与<code>pattern='*.txt'</code>或<code>subfolders=True</code> 。 </p> 
<pre><code>import os
import fnmatch

def list_paths(folder='.', pattern='*', case_sensitive=False, subfolders=False):
    """Return a list of the file paths matching the pattern in the specified 
    folder, optionally including files inside subfolders.
    """
    match = fnmatch.fnmatchcase if case_sensitive else fnmatch.fnmatch
    walked = os.walk(folder) if subfolders else [next(os.walk(folder))]
    return [os.path.join(root, f)
            for root, dirnames, filenames in walked
            for f in filenames if match(f, pattern)]
</code></pre> 
<hr> 
<h4>#15楼</h4> 
<p> 我将提供一个示例liner，其中可以提供sourcepath和文件类型作为输入。 该代码返回带有csv扩展名的文件名列表。 使用<em>。</em> 万一需要返回所有文件。 这还将递归扫描子目录。 </p> 
<p> <code>[y for x in os.walk(sourcePath) for y in glob(os.path.join(x[0], '*.csv'))]</code> </p> 
<p> 根据需要修改文件扩展名和源路径。 </p> 
<hr> 
<h4>#16楼</h4> 
<h3> 初步说明 </h3> 
<ul><li> 尽管问题文本中的<em>文件</em>和<em>目录</em>术语之间存在明显区别，但有些人可能会认为目录实际上是特殊文件 </li><li> 语句：“ <em>目录的所有文件</em> ”可以用两种方式解释： 
  <ol><li> <strong>只有</strong>所有<strong>直接</strong> （或1级）的后裔 </li><li> 整个目录树中的所有子代（包括子目录中的子代） </li></ol></li><li><p> 提出问题时，我认为<em>Python <strong>2</strong></em>是<em>LTS</em>版本，但是代码示例将由<em>Python <strong>3</strong> （ <strong>.5</strong> ）运行</em> （我将使其尽可能与<em>Python 2</em>兼容；此外，属于我要发布的<em>Python</em>来自<strong>v3.5.4-</strong>除非另有说明）。 结果与问题中的另一个关键字相关：“ <em>将它们添加到<strong>列表中</strong></em> ”： </p> 
  <ul><li> 在<em>Python 2.2之前的</em>版本中，序列（可迭代）主要由列表（元组，集合等）表示。 </li><li> 在<em>Python 2.2中</em> ， <a href="https://wiki.python.org/moin/Generators" rel="nofollow">引入</a>了<strong>生成器</strong> （ <a href="https://wiki.python.org/moin/Generators" rel="nofollow">[Python.Wiki]：Generators</a> ）的概念-由<a href="https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement" rel="nofollow">[Python 3]：yield语句提供</a> 。 随着时间的流逝，对于返回/使用列表的函数，生成器对应对象开始出现 </li><li> 在<em>Python 3中</em> ，generator是默认行为 </li><li> 不知道返回列表是否仍然是强制性的（或者生成器也可以执行），但是将生成器传递给<em>列表</em>构造函数会从<em>列表</em>构造器中创建列表（并消耗列表）。 以下示例说明了<a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow">[Python 3]</a>的区别<a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow">： <strong>map</strong> （ <em>function，iterable，...</em> ）</a> </li></ul> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>&gt;&gt;&gt; import sys &gt;&gt;&gt; sys.version '2.7.10 (default, Mar 8 2016, 15:02:46) [MSC v.1600 64 bit (AMD64)]' &gt;&gt;&gt; m = map(lambda x: x, [1, 2, 3]) # Just a dummy lambda function &gt;&gt;&gt; m, type(m) ([1, 2, 3], &lt;type 'list'&gt;) &gt;&gt;&gt; len(m) 3</code> </pre> 
  </blockquote><p><br></p> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>&gt;&gt;&gt; import sys &gt;&gt;&gt; sys.version '3.5.4 (v3.5.4:3f56838, Aug 8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)]' &gt;&gt;&gt; m = map(lambda x: x, [1, 2, 3]) &gt;&gt;&gt; m, type(m) (&lt;map object at 0x000001B4257342B0&gt;, &lt;class 'map'&gt;) &gt;&gt;&gt; len(m) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: object of type 'map' has no len() &gt;&gt;&gt; lm0 = list(m) # Build a list from the generator &gt;&gt;&gt; lm0, type(lm0) ([1, 2, 3], &lt;class 'list'&gt;) &gt;&gt;&gt; &gt;&gt;&gt; lm1 = list(m) # Build a list from the same generator &gt;&gt;&gt; lm1, type(lm1) # Empty list now - generator already consumed ([], &lt;class 'list'&gt;)</code> </pre> 
  </blockquote></li><li><p> 这些示例将基于具有以下结构的名为<em>root_dir</em>的目录（此示例适用于<em>Win</em> ，但我也在<em>Lnx</em>上使用同一棵树）： </p> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>E:\\Work\\Dev\\StackOverflow\\q003207219&gt;tree /f "root_dir" Folder PATH listing for volume Work Volume serial number is 00000029 3655:6FED E:\\WORK\\DEV\\STACKOVERFLOW\\Q003207219\\ROOT_DIR ¦ file0 ¦ file1 ¦ +---dir0 ¦ +---dir00 ¦ ¦ ¦ file000 ¦ ¦ ¦ ¦ ¦ +---dir000 ¦ ¦ file0000 ¦ ¦ ¦ +---dir01 ¦ ¦ file010 ¦ ¦ file011 ¦ ¦ ¦ +---dir02 ¦ +---dir020 ¦ +---dir0200 +---dir1 ¦ file10 ¦ file11 ¦ file12 ¦ +---dir2 ¦ ¦ file20 ¦ ¦ ¦ +---dir20 ¦ file200 ¦ +---dir3</code> </pre> 
  </blockquote></li></ul> 
<p><br></p> 
<h3> 解决方案 </h3> 
<h4> 程序化方法： </h4> 
<ol><li><p> <a href="https://docs.python.org/3/library/os.html#os.listdir" rel="nofollow">[Python 3]：操作系统。</a> <a href="https://docs.python.org/3/library/os.html#os.listdir" rel="nofollow"><strong>listdir</strong> （ <em>path ='。'</em> ）</a> </p> 
  <blockquote> 
   <p> 返回一个列表，其中包含由path给出的目录中条目的名称。 该列表按任意顺序排列，并且不包含特殊条目<code>'.'</code> 和<code>'..'</code> </p> 
  </blockquote><p><br></p> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>&gt;&gt;&gt; import os &gt;&gt;&gt; root_dir = "root_dir" # Path relative to current dir (os.getcwd()) &gt;&gt;&gt; &gt;&gt;&gt; os.listdir(root_dir) # List all the items in root_dir ['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1'] &gt;&gt;&gt; &gt;&gt;&gt; [item for item in os.listdir(root_dir) if os.path.isfile(os.path.join(root_dir, item))] # Filter items and only keep files (strip out directories) ['file0', 'file1']</code> </pre> 
  </blockquote><p> 一个更详细的示例（ <em>code_os_listdir.py</em> ）： </p><pre class="lang-py prettyprint-override"> <code>import os from pprint import pformat def _get_dir_content(path, include_folders, recursive): entries = os.listdir(path) for entry in entries: entry_with_path = os.path.join(path, entry) if os.path.isdir(entry_with_path): if include_folders: yield entry_with_path if recursive: for sub_entry in _get_dir_content(entry_with_path, include_folders, recursive): yield sub_entry else: yield entry_with_path def get_dir_content(path, include_folders=True, recursive=True, prepend_folder_name=True): path_len = len(path) + len(os.path.sep) for item in _get_dir_content(path, include_folders, recursive): yield item if prepend_folder_name else item[path_len:] def _get_dir_content_old(path, include_folders, recursive): entries = os.listdir(path) ret = list() for entry in entries: entry_with_path = os.path.join(path, entry) if os.path.isdir(entry_with_path): if include_folders: ret.append(entry_with_path) if recursive: ret.extend(_get_dir_content_old(entry_with_path, include_folders, recursive)) else: ret.append(entry_with_path) return ret def get_dir_content_old(path, include_folders=True, recursive=True, prepend_folder_name=True): path_len = len(path) + len(os.path.sep) return [item if prepend_folder_name else item[path_len:] for item in _get_dir_content_old(path, include_folders, recursive)] def main(): root_dir = "root_dir" ret0 = get_dir_content(root_dir, include_folders=True, recursive=True, prepend_folder_name=True) lret0 = list(ret0) print(ret0, len(lret0), pformat(lret0)) ret1 = get_dir_content_old(root_dir, include_folders=False, recursive=True, prepend_folder_name=False) print(len(ret1), pformat(ret1)) if __name__ == "__main__": main()</code> </pre><p> <strong>注意事项</strong> ： </p> 
  <ul><li> 有两种实现： 
    <ul><li> 使用生成器的生成器（当然这里似乎没有用，因为我立即将结果转换为列表） </li><li> 经典的（函数名称以<strong>_old</strong>结尾） </li></ul></li><li> 使用递归（进入子目录） </li><li> 对于每种实现，都有两个功能： 
    <ul><li> 以<em>下划线</em> （ <strong>_</strong> ） <em>开头的代码</em> ：“ private”（不应直接调用）-完成所有工作 </li><li> 公共的（包装上一个）：它只是从返回的条目中剥离出初始路径（如果需要）。 这是一个丑陋的实现，但这是我目前唯一能想到的想法 </li></ul></li><li> 在性能方面，生成器通常要快一些（考虑<em>创建</em>和<em>迭代</em>时间），但是我没有在递归函数中对其进行测试，而且我还在内部生成器上迭代函数内部-不知道性能如何友好的是 </li><li> 玩弄参数以获得不同的结果 </li></ul><p><br></p><p> <strong>输出</strong> ： </p> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>(py35x64_test) E:\\Work\\Dev\\StackOverflow\\q003207219&gt;"e:\\Work\\Dev\\VEnvs\\py35x64_test\\Scripts\\python.exe" "code_os_listdir.py" &lt;generator object get_dir_content at 0x000001BDDBB3DF10&gt; 22 ['root_dir\\\\dir0', 'root_dir\\\\dir0\\\\dir00', 'root_dir\\\\dir0\\\\dir00\\\\dir000', 'root_dir\\\\dir0\\\\dir00\\\\dir000\\\\file0000', 'root_dir\\\\dir0\\\\dir00\\\\file000', 'root_dir\\\\dir0\\\\dir01', 'root_dir\\\\dir0\\\\dir01\\\\file010', 'root_dir\\\\dir0\\\\dir01\\\\file011', 'root_dir\\\\dir0\\\\dir02', 'root_dir\\\\dir0\\\\dir02\\\\dir020', 'root_dir\\\\dir0\\\\dir02\\\\dir020\\\\dir0200', 'root_dir\\\\dir1', 'root_dir\\\\dir1\\\\file10', 'root_dir\\\\dir1\\\\file11', 'root_dir\\\\dir1\\\\file12', 'root_dir\\\\dir2', 'root_dir\\\\dir2\\\\dir20', 'root_dir\\\\dir2\\\\dir20\\\\file200', 'root_dir\\\\dir2\\\\file20', 'root_dir\\\\dir3', 'root_dir\\\\file0', 'root_dir\\\\file1'] 11 ['dir0\\\\dir00\\\\dir000\\\\file0000', 'dir0\\\\dir00\\\\file000', 'dir0\\\\dir01\\\\file010', 'dir0\\\\dir01\\\\file011', 'dir1\\\\file10', 'dir1\\\\file11', 'dir1\\\\file12', 'dir2\\\\dir20\\\\file200', 'dir2\\\\file20', 'file0', 'file1']</code> </pre> 
  </blockquote></li></ol> 
<p><br></p> 
<ol start="2"><li><p> <a href="https://docs.python.org/3/library/os.html#os.scandir" rel="nofollow">[Python 3]：操作系统。</a> <a href="https://docs.python.org/3/library/os.html#os.scandir" rel="nofollow"><strong>scandir</strong> （ <em>path ='。'</em> ）</a> （ <em>Python <strong>3.5</strong></em> +，backport： <a href="https://pypi.org/project/scandir" rel="nofollow">[PyPI]：scandir</a> ） </p> 
  <blockquote> 
   <p> 返回与<em>path</em>指定的目录中的条目相对应的<a href="https://docs.python.org/3/library/os.html#os.DirEntry" rel="nofollow">os.DirEntry</a>对象的迭代器。 条目以任意顺序产生，特殊条目为<code>'.'</code> 和<code>'..'</code>不包括在内。 </p> 
   <p> 使用<a href="https://docs.python.org/3/library/os.html#os.scandir" rel="nofollow">scandir（）</a>而不是<a href="https://docs.python.org/3/library/os.html#os.listdir" rel="nofollow">listdir（）</a>可以显着提高还需要文件类型或文件属性信息的代码的性能，因为如果操作系统在扫描目录时提供了<a href="https://docs.python.org/3/library/os.html#os.DirEntry" rel="nofollow">os.DirEntry</a>对象，则该信息会公开。 所有的<a href="https://docs.python.org/3/library/os.html#os.DirEntry" rel="nofollow">os.DirEntry</a>方法都可以执行系统调用，但是<a href="https://docs.python.org/3/library/os.html#os.DirEntry.is_dir" rel="nofollow">is_dir（）</a>和<a href="https://docs.python.org/3/library/os.html#os.DirEntry.is_file" rel="nofollow">is_file（）</a>通常只需要系统调用即可进行符号链接。 <a href="https://docs.python.org/3/library/os.html#os.DirEntry.stat" rel="nofollow">os.DirEntry.stat（）</a>在Unix上始终需要系统调用，而在Windows上只需要一个系统调用即可。 </p> 
  </blockquote><p><br></p> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>&gt;&gt;&gt; import os &gt;&gt;&gt; root_dir = os.path.join(".", "root_dir") # Explicitly prepending current directory &gt;&gt;&gt; root_dir '.\\\\root_dir' &gt;&gt;&gt; &gt;&gt;&gt; scandir_iterator = os.scandir(root_dir) &gt;&gt;&gt; scandir_iterator &lt;nt.ScandirIterator object at 0x00000268CF4BC140&gt; &gt;&gt;&gt; [item.path for item in scandir_iterator] ['.\\\\root_dir\\\\dir0', '.\\\\root_dir\\\\dir1', '.\\\\root_dir\\\\dir2', '.\\\\root_dir\\\\dir3', '.\\\\root_dir\\\\file0', '.\\\\root_dir\\\\file1'] &gt;&gt;&gt; &gt;&gt;&gt; [item.path for item in scandir_iterator] # Will yield an empty list as it was consumed by previous iteration (automatically performed by the list comprehension) [] &gt;&gt;&gt; &gt;&gt;&gt; scandir_iterator = os.scandir(root_dir) # Reinitialize the generator &gt;&gt;&gt; for item in scandir_iterator : ... if os.path.isfile(item.path): ... print(item.name) ... file0 file1</code> </pre> 
  </blockquote><p> <strong>注意事项</strong> ： </p> 
  <ul><li> 它类似于<code>os.listdir</code> </li><li> 但是它也更灵活（并提供更多功能），更多<em>Python</em> ic（在某些情况下还更快） </li></ul></li></ol> 
<p><br></p> 
<ol start="3"><li><p> <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow">[Python 3]：操作系统。</a> <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow"><strong>步行</strong> （ <em>top，topdown = True，onerror = None，followlinks = False</em> ）</a> </p> 
  <blockquote> 
   <p> 通过自上而下或自下而上移动目录树来生成文件名。 对于以目录<em>顶部</em> （包括<em>顶部</em>本身）为根的树中的每个目录，它都会生成一个<code>dirpath</code>组（ <code>dirpath</code> ， <code>dirnames</code> ， <code>filenames</code> ）。 </p> 
  </blockquote><p><br></p> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>&gt;&gt;&gt; import os &gt;&gt;&gt; root_dir = os.path.join(os.getcwd(), "root_dir") # Specify the full path &gt;&gt;&gt; root_dir 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir' &gt;&gt;&gt; &gt;&gt;&gt; walk_generator = os.walk(root_dir) &gt;&gt;&gt; root_dir_entry = next(walk_generator) # First entry corresponds to the root dir (passed as an argument) &gt;&gt;&gt; root_dir_entry ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir', ['dir0', 'dir1', 'dir2', 'dir3'], ['file0', 'file1']) &gt;&gt;&gt; &gt;&gt;&gt; root_dir_entry[1] + root_dir_entry[2] # Display dirs and files (direct descendants) in a single list ['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1'] &gt;&gt;&gt; &gt;&gt;&gt; [os.path.join(root_dir_entry[0], item) for item in root_dir_entry[1] + root_dir_entry[2]] # Display all the entries in the previous list by their full path ['E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0', 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir1', 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir2', 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir3', 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\file0', 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\file1'] &gt;&gt;&gt; &gt;&gt;&gt; for entry in walk_generator: # Display the rest of the elements (corresponding to every subdir) ... print(entry) ... ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0', ['dir00', 'dir01', 'dir02'], []) ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir00', ['dir000'], ['file000']) ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir00\\\\dir000', [], ['file0000']) ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir01', [], ['file010', 'file011']) ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir02', ['dir020'], []) ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir02\\\\dir020', ['dir0200'], []) ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir02\\\\dir020\\\\dir0200', [], []) ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir1', [], ['file10', 'file11', 'file12']) ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir2', ['dir20'], ['file20']) ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir2\\\\dir20', [], ['file200']) ('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir3', [], [])</code> </pre> 
  </blockquote><p> <strong>注意事项</strong> ： </p> 
  <ul><li> 在幕后，它使用<code>os.scandir</code> （旧版本上为<code>os.listdir</code> ） </li><li> 它通过重复子文件夹来完成繁重的工作 </li></ul></li></ol> 
<p><br></p> 
<ol start="4"><li><p> <a href="https://docs.python.org/3/library/glob.html#glob.glob" rel="nofollow">[Python 3]：glob。</a> <a href="https://docs.python.org/3/library/glob.html#glob.glob" rel="nofollow"><strong>glob</strong> （ <em>pathname，*，recursive = False</em> ）</a> （ <a href="https://docs.python.org/3/library/glob.html#glob.glob" rel="nofollow">[Python 3]： <strong>glob。iglob</strong> （ <em>pathname，*，recursive = False</em> ）</a> ） </p> 
  <blockquote> 
   <p> 返回与<em>pathname</em>匹配的路径名的可能为空的列表，该列表必须是包含路径说明的字符串。 <em>路径名</em>可以是绝对<em>路径</em> （例如<code>/usr/src/Python-1.5/Makefile</code> ），也可以是相对<em>路径</em> （例如<code>../../Tools/*/*.gif</code> ），并且可以包含shell样式的通配符。 损坏的符号链接包含在结果中（如在shell中）。 <br> ... <br><strong><em>在版本3.5中更改</em></strong> ：支持使用“ <code>**</code> ”的递归glob。 </p> 
  </blockquote><p><br></p> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>&gt;&gt;&gt; import glob, os &gt;&gt;&gt; wildcard_pattern = "*" &gt;&gt;&gt; root_dir = os.path.join("root_dir", wildcard_pattern) # Match every file/dir name &gt;&gt;&gt; root_dir 'root_dir\\\\*' &gt;&gt;&gt; &gt;&gt;&gt; glob_list = glob.glob(root_dir) &gt;&gt;&gt; glob_list ['root_dir\\\\dir0', 'root_dir\\\\dir1', 'root_dir\\\\dir2', 'root_dir\\\\dir3', 'root_dir\\\\file0', 'root_dir\\\\file1'] &gt;&gt;&gt; &gt;&gt;&gt; [item.replace("root_dir" + os.path.sep, "") for item in glob_list] # Strip the dir name and the path separator from begining ['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1'] &gt;&gt;&gt; &gt;&gt;&gt; for entry in glob.iglob(root_dir + "*", recursive=True): ... print(entry) ... root_dir\\ root_dir\\dir0 root_dir\\dir0\\dir00 root_dir\\dir0\\dir00\\dir000 root_dir\\dir0\\dir00\\dir000\\file0000 root_dir\\dir0\\dir00\\file000 root_dir\\dir0\\dir01 root_dir\\dir0\\dir01\\file010 root_dir\\dir0\\dir01\\file011 root_dir\\dir0\\dir02 root_dir\\dir0\\dir02\\dir020 root_dir\\dir0\\dir02\\dir020\\dir0200 root_dir\\dir1 root_dir\\dir1\\file10 root_dir\\dir1\\file11 root_dir\\dir1\\file12 root_dir\\dir2 root_dir\\dir2\\dir20 root_dir\\dir2\\dir20\\file200 root_dir\\dir2\\file20 root_dir\\dir3 root_dir\\file0 root_dir\\file1</code> </pre> 
  </blockquote><p> <strong>注意事项</strong> ： </p> 
  <ul><li> 使用<code>os.listdir</code> </li><li> 对于大树（尤其是在启用<em>递归的</em>情况下），首选<em>iglob</em> </li><li> 允许基于名称进行高级过滤（由于通配符） </li></ul></li></ol> 
<p><br></p> 
<ol start="5"><li><p> <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" rel="nofollow">[Python 3]：类pathlib。</a> <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" rel="nofollow"><strong>路径</strong> （ <em>* pathsegments</em> ）</a> （ <em>Python <strong>3.4</strong></em> +，backport： <a href="https://pypi.org/project/pathlib2" rel="nofollow">[PyPI]：pathlib2</a> ） </p> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>&gt;&gt;&gt; import pathlib &gt;&gt;&gt; root_dir = "root_dir" &gt;&gt;&gt; root_dir_instance = pathlib.Path(root_dir) &gt;&gt;&gt; root_dir_instance WindowsPath('root_dir') &gt;&gt;&gt; root_dir_instance.name 'root_dir' &gt;&gt;&gt; root_dir_instance.is_dir() True &gt;&gt;&gt; &gt;&gt;&gt; [item.name for item in root_dir_instance.glob("*")] # Wildcard searching for all direct descendants ['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1'] &gt;&gt;&gt; &gt;&gt;&gt; [os.path.join(item.parent.name, item.name) for item in root_dir_instance.glob("*") if not item.is_dir()] # Display paths (including parent) for files only ['root_dir\\\\file0', 'root_dir\\\\file1']</code> </pre> 
  </blockquote><p> <strong>注意事项</strong> ： </p> 
  <ul><li> 这是实现我们目标的<em>一种</em>方式 </li><li> 这是处理路径的<em>OOP</em>风格 </li><li> 提供许多功能 </li></ul></li></ol> 
<p><br></p> 
<ol start="6"><li><p> <a href="https://docs.python.org/2/library/dircache.html#dircache.listdir" rel="nofollow">[Python 2]：dircache.listdir（path）</a> （仅<em>Python <strong>2</strong></em> ） </p> 
  <ul><li> 但是，根据<a href="https://github.com/python/cpython/blob/2.7/Lib/dircache.py">[GitHub]：python / cpython-（2.7）cpython / Lib / dircache.py</a> ，它只是对<code>os.listdir</code>的（薄）包装（带有缓存） </li></ul><p><br></p><pre class="lang-py prettyprint-override"> <code>def listdir(path): """List directory contents, using cache.""" try: cached_mtime, list = cache[path] del cache[path] except KeyError: cached_mtime, list = -1, [] mtime = os.stat(path).st_mtime if mtime != cached_mtime: list = os.listdir(path) list.sort() cache[path] = mtime, list return list</code> </pre></li></ol> 
<p><br></p> 
<ol start="7"><li><p> <a href="http://man7.org/linux/man-pages/man3/opendir.3.html" rel="nofollow">[man7]：OPENDIR（3）</a> / <a href="http://man7.org/linux/man-pages/man3/readdir.3.html" rel="nofollow">[man7]：READDIR（3）</a> / <a href="http://man7.org/linux/man-pages/man3/closedir.3.html" rel="nofollow">[man7]：CLOSEDIR（3）</a>通过<a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow">[Python 3]：ctypes-Python的外部函数库</a> （特定<a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow">于</a> <em>POSIX</em> ） </p> 
  <blockquote> 
   <p> <a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow">ctypes</a>是Python的外部函数库。 它提供C兼容的数据类型，并允许在DLL或共享库中调用函数。 它可以用于将这些库包装在纯Python中。 </p> 
  </blockquote><p> <em>code_ctypes.py</em> ： </p><pre class="lang-py prettyprint-override"> <code>#!/usr/bin/env python3 import sys from ctypes import Structure, \\ c_ulonglong, c_longlong, c_ushort, c_ubyte, c_char, c_int, \\ CDLL, POINTER, \\ create_string_buffer, get_errno, set_errno, cast DT_DIR = 4 DT_REG = 8 char256 = c_char * 256 class LinuxDirent64(Structure): _fields_ = [ ("d_ino", c_ulonglong), ("d_off", c_longlong), ("d_reclen", c_ushort), ("d_type", c_ubyte), ("d_name", char256), ] LinuxDirent64Ptr = POINTER(LinuxDirent64) libc_dll = this_process = CDLL(None, use_errno=True) # ALWAYS set argtypes and restype for functions, otherwise it's UB!!! opendir = libc_dll.opendir readdir = libc_dll.readdir closedir = libc_dll.closedir def get_dir_content(path): ret = [path, list(), list()] dir_stream = opendir(create_string_buffer(path.encode())) if (dir_stream == 0): print("opendir returned NULL (errno: {:d})".format(get_errno())) return ret set_errno(0) dirent_addr = readdir(dir_stream) while dirent_addr: dirent_ptr = cast(dirent_addr, LinuxDirent64Ptr) dirent = dirent_ptr.contents name = dirent.d_name.decode() if dirent.d_type &amp; DT_DIR: if name not in (".", ".."): ret[1].append(name) elif dirent.d_type &amp; DT_REG: ret[2].append(name) dirent_addr = readdir(dir_stream) if get_errno(): print("readdir returned NULL (errno: {:d})".format(get_errno())) closedir(dir_stream) return ret def main(): print("{:s} on {:s}\\n".format(sys.version, sys.platform)) root_dir = "root_dir" entries = get_dir_content(root_dir) print(entries) if __name__ == "__main__": main()</code> </pre><p> <strong>注意事项</strong> ： </p> 
  <ul><li> 它从<em>libc</em>加载三个函数（在当前进程中加载​​）并调用它们（有关更多详细信息，请检查<a href="https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-using-python/44661513#44661513" rel="nofollow">[SO]：如何检查文件是否存在无异常？（@ CristiFati的回答）</a> - <strong><em>第4</em></strong>项的最后说明<strong><em>。</em></strong> ）。 这将使这种方法非常接近<em>Python</em> / <em>C</em>边缘 </li><li> <em>LinuxDirent64</em>是从<em>结构dirent64</em>的<em>ctypes的</em>表示<a href="http://man7.org/linux/man-pages/man0/dirent.h.0p.html" rel="nofollow">[man7]：dirent.h（0P）</a>从我的机器（等等都是<em>DT_</em>常数<em>）：Ubtu 16 <em>64（4.10.0-40</em></em> <em>泛型</em>和<em>libc6的-dev的：AMD64）。</em> 在其他风味/版本上，结构定义可能会有所不同，如果有，则应更新<em>ctypes</em>别名，否则将产生<strong>未定义行为</strong> </li><li> 它以<code>os.walk</code>的格式返回数据。 我没有麻烦使其递归，但是从现有代码开始，这将是一个相当琐碎的任务 </li><li> 一切在<em>Win</em>上也都可行，数据（库，函数，结构，常量等）不同 </li></ul><p><br></p><p> <strong>输出</strong> ： </p> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q003207219]&gt; ./code_ctypes.py 3.5.2 (default, Nov 12 2018, 13:43:14) [GCC 5.4.0 20160609] on linux ['root_dir', ['dir2', 'dir1', 'dir3', 'dir0'], ['file1', 'file0']]</code> </pre> 
  </blockquote></li></ol> 
<p><br></p> 
<ol start="8"><li><p> <a href="https://docs.activestate.com/activepython/3.1/pywin32/win32file__FindFilesW_meth.html" rel="nofollow">[ActiveState.Docs]：win32file.FindFilesW</a> （特定<a href="https://docs.activestate.com/activepython/3.1/pywin32/win32file__FindFilesW_meth.html" rel="nofollow">于</a> <em>Win</em> ） </p> 
  <blockquote> 
   <p> 使用Windows Unicode API检索匹配文件名的列表。 API FindFirstFileW / FindNextFileW / Find关闭函数的接口。 </p> 
  </blockquote><p><br></p> 
  <blockquote> 
   <pre class="lang-py prettyprint-override"> <code>&gt;&gt;&gt; import os, win32file, win32con &gt;&gt;&gt; root_dir = "root_dir" &gt;&gt;&gt; wildcard = "*" &gt;&gt;&gt; root_dir_wildcard = os.path.join(root_dir, wildcard) &gt;&gt;&gt; entry_list = win32file.FindFilesW(root_dir_wildcard) &gt;&gt;&gt; len(entry_list) # Don't display the whole content as it's too long 8 &gt;&gt;&gt; [entry[-2] for entry in entry_list] # Only display the entry names ['.', '..', 'dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1'] &gt;&gt;&gt; &gt;&gt;&gt; [entry[-2] for entry in entry_list if entry[0] &amp; win32con.FILE_ATTRIBUTE_DIRECTORY and entry[-2] not in (".", "..")] # Filter entries and only display dir names (except self and parent) ['dir0', 'dir1', 'dir2', 'dir3'] &gt;&gt;&gt; &gt;&gt;&gt; [os.path.join(root_dir, entry[-2]) for entry in entry_list if entry[0] &amp; (win32con.FILE_ATTRIBUTE_NORMAL | win32con.FILE_ATTRIBUTE_ARCHIVE)] # Only display file "full" names ['root_dir\\\\file0', 'root_dir\\\\file1']</code> </pre> 
  </blockquote><p> <strong>注意事项</strong> ： </p> 
  <ul><li> <code>win32file.FindFilesW</code>是<a href="https://github.com/mhammond/pywin32">[GitHub]的</a>一部分<a href="https://github.com/mhammond/pywin32">：mhammond / pywin32-Windows的Python（pywin32）扩展</a> ，它是<em>WINAPI</em>的<em>Python</em>包装器 </li><li> 文档链接来自<a href="https://www.activestate.com" rel="nofollow">ActiveState</a> ，因为我没有找到任何<em>PyWin32</em>官方文档 </li></ul></li></ol> 
<p><br></p> 
<ol start="9"><li> 安装一些（其他）第三方软件包即可 
  <ul><li> 最有可能会依赖于上述一项（或多项）（可能需要进行一些自定义） </li></ul></li></ol> 
<p><br></p> 
<p> <strong>注意事项</strong> ： </p> 
<ul><li><p> 代码应具有可移植性（针对特定区域的地方-带有标记的地方除外）或交叉的： </p> 
  <ul><li> 平台（ <em>Nix</em> ， <em>Win</em> ，） </li><li> <em>Python</em>版本（2、3，） </li></ul></li><li><p> 在上述变体中使用了多种路径样式（绝对路径，相对路径），以说明以下事实：所使用的“工具”在此方向上是灵活的 </p></li><li><p> <code>os.listdir</code>和<code>os.scandir</code>使用<em>opendir</em> / <em>readdir</em> / <em>closedir</em> （ <a href="https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew" rel="nofollow">[MS.Docs]：FindFirstFileW函数</a> / <a href="https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew" rel="nofollow">[MS.Docs]：FindNextFileW函数</a> / <a href="https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose" rel="nofollow">[MS.Docs]：FindClose函数</a> ）（通过<a href="https://github.com/python/cpython/blob/master/Modules/posixmodule.c">[GitHub]：python / cpython -（主）cpython / Modules / posixmodule.c</a> ） </p></li><li><p> <code>win32file.FindFilesW</code>使用这些（特定于<em>Win的</em> ）函数（通过<a href="https://github.com/mhammond/pywin32/blob/master/win32/src/win32file.i">[GitHub]：mhammond / pywin32-（主）pywin32 / win32 / src / win32file.i</a> ） </p></li><li><p> <em>_get_dir_content</em> （从<strong><em>第1</em></strong>点开始）可以使用以下任何一种方法来实现（有些需要更多的工作，有些需要更少的工作） </p> 
  <ul><li> 一些先进的过滤（而不仅仅是文件<em>与</em>目录）可以做：由另一个例如<em>include_folders</em>争论可能会被替换（如<em>filter_func），</em>这将是一个函数，作为参数的路径： <code>filter_func=lambda x: True</code> （这不会删除任何内容），并且在<em>_get_dir_content</em>内<em>包含</em>类似内容： <code>if not filter_func(entry_with_path): continue</code> （如果该函数对一项失败，则将被跳过），但是代码越复杂，花费的时间就越长执行 </li></ul></li><li><p> <strong>诺娜·贝恩！</strong> 由于使用了递归，所以我必须提到，我在笔记本电脑（ <em>Win 10 x64</em> ）上进行了一些测试，这与该问题完全无关，并且当递归级别达到<em>（990 .. 1000）</em>范围内的某个值时（ <em>recursionlimit</em> -1000 （默认）），我得到了<em>StackOverflow</em> :)。 如果目录树超过了该限制（我不是<em>FS</em>专家，所以我什至不知道那是否可能），那可能是个问题。 <br> 我还必须提到，我没有尝试增加<em>递归限制，</em>因为我没有该领域的经验（在必须同时在<em>OS</em>级别上增加堆栈之前，我可以增加多少），​​但是从理论上讲，总有可能如果dir深度大于最大可能的<em>递归限制</em> （在该计算机上），则失败 </p></li><li><p> 代码示例仅用于说明目的。 这意味着我没有考虑错误处理（我不认为有任何<strong><em>try</em></strong> / <strong><em>除了</em></strong> / <strong><em>else</em></strong> / <strong><em>finally</em></strong>块），因此代码并不健壮（原因是：使其尽可能简单和简短） ）。 对于<em>生产</em> ，还应添加错误处理 </p></li></ul> 
<h4> 其他方法： </h4> 
<ol><li><p> 仅将<em>Python</em>用作包装器 </p> 
  <ul><li> 一切都使用另一种技术完成 </li><li> 该技术是从<em>Python</em>调用的 </li><li><p> 我所知道的最著名的味道是我所说的<em>系统管理员</em>方法： </p> 
    <ul><li> 使用<em>Python</em> （或与此相关的任何编程语言）执行<em>Shell</em>命令（并解析其输出） </li><li> 有人认为这是一个很好的技巧 </li><li> 我认为这更像是一种<em>me脚的</em>解决方法（ <em>gainarie</em> ），因为操作本身是从<em>shell</em> （在这种情况下为<em>cmd</em> ）执行的，因此与<em>Python</em>无关。 </li><li> 过滤（ <code>grep</code> / <code>findstr</code> ）或输出格式化都可以在两面进行，但是我不会坚持使用它。 另外，我刻意用<code>os.system</code>代替<code>subprocess.Popen</code> 。 </li></ul> 
    <blockquote> 
     <pre class="lang-py prettyprint-override"> <code>(py35x64_test) E:\\Work\\Dev\\StackOverflow\\q003207219&gt;"e:\\Work\\Dev\\VEnvs\\py35x64_test\\Scripts\\python.exe" -c "import os;os.system(\\"dir /b root_dir\\")" dir0 dir1 dir2 dir3 file0 file1</code> </pre> 
    </blockquote></li></ul><p> 通常应避免这种方法，因为如果某些命令输出格式在<em>OS</em>版本/风格之间略有不同，则解析代码也应进行调整；例如， 更不用说语言环境之间的差异了）。 </p></li></ol> 
<hr> 
<h4>#17楼</h4> 
<p> Python 3.4+的另一个非常易读的变体是使用pathlib.Path.glob： </p> 
<pre><code>from pathlib import Path
folder = '/foo'
[f for f in Path(folder).glob('*') if f.is_file()]
</code></pre> 
<p> 进行更具体的描述很简单，例如，在所有子目录中仅查找不是符号链接的Python源文件： </p> 
<pre><code>[f for f in Path(folder).glob('**/*.py') if not f.is_symlink()]
</code></pre> 
<hr> 
<h4>#18楼</h4> 
<pre><code>import os
import os.path


def get_files(target_dir):
    item_list = os.listdir(target_dir)

    file_list = list()
    for item in item_list:
        item_dir = os.path.join(target_dir,item)
        if os.path.isdir(item_dir):
            file_list += get_files(item_dir)
        else:
            file_list.append(item_dir)
    return file_list
</code></pre> 
<p> 在这里，我使用递归结构。 </p> 
<hr> 
<h4>#19楼</h4> 
<p> 对于python2：pip install rglob </p> 
<pre><code>import rglob
file_list=rglob.rglob("/home/base/dir/", "*")
print file_list
</code></pre> 
<hr> 
<h4>#20楼</h4> 
<p> 为了获得更好的结果，可以将<code>os</code>模块的<code>listdir()</code>方法与生成器一起使用（生成器是保持其状态的强大迭代器，还记得吗？）。 以下代码在这两个版本上均可正常使用：Python 2和Python 3。 </p> 
<p> 这是一个代码： </p> 
<pre><code>import os

def files(path):  
    for file in os.listdir(path):
        if os.path.isfile(os.path.join(path, file)):
            yield file

for file in files("."):  
    print (file)
</code></pre> 
<p> <code>listdir()</code>方法返回给定目录的条目列表。 如果给定的条目是文件，则方法<code>os.path.isfile()</code>返回<code>True</code> 。 并且<code>yield</code>运算符退出功能但保持其当前状态，并且仅返回检测为文件的条目的名称。 以上所有内容使我们可以循环生成器功能。 </p> 
<hr> 
<h4>#21楼</h4> 
<p> 一位聪明的老师曾经告诉我： </p> 
<blockquote> 
 <p> 当有几种确定的方法可以做某事时，没有一种方法适合所有情况。 </p> 
</blockquote> 
<p> 因此，我将为问题的一个<strong>子集</strong>添加一个解决方案：很多时候，我们只想检查文件是否匹配开始字符串和结束字符串，而无需进入子目录。 因此，我们想要一个返回文件名列表的函数，例如： </p> 
<pre><code>filenames = dir_filter('foo/baz', radical='radical', extension='.txt')
</code></pre> 
<p> 如果您想先声明两个函数，可以这样做： </p> 
<pre><code>def file_filter(filename, radical='', extension=''):
    "Check if a filename matches a radical and extension"
    if not filename:
        return False
    filename = filename.strip()
    return(filename.startswith(radical) and filename.endswith(extension))

def dir_filter(dirname='', radical='', extension=''):
    "Filter filenames in directory according to radical and extension"
    if not dirname:
        dirname = '.'
    return [filename for filename in os.listdir(dirname)
                if file_filter(filename, radical, extension)]
</code></pre> 
<p> 可以使用正则表达式轻松推广此解决方案（并且，如果您不希望模式始终坚持文件名的开头或结尾，则可能需要添加<code>pattern</code>参数）。 </p> 
<hr> 
<h4>#22楼</h4> 
<p> 从指定的文件夹（包括子目录）获取所有文件。 </p> 
<pre><code>import glob
import os

print([entry for entry in glob.iglob("{}/**".format("DIRECTORY_PATH"), recursive=True) if os.path.isfile(entry) == True])
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27f2ab00e946dff6c9157e0535d86be6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【工具】BIOS详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d12b03e41d41d60b3e7c189bb65b5e9f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JSP内置对象详解及示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>