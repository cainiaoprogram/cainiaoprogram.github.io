<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Observability：从零基础到能够完成微服务可观测性的专家 - Service Map 实践 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Observability：从零基础到能够完成微服务可观测性的专家 - Service Map 实践" />
<meta property="og:description" content="现在的 IT 系统越来越复杂，而微服务也被广泛使用于越来越多的大型 IT 系统中。 微服务是一种软件开发技术- 面向服务的体系结构（SOA）架构样式的一种变体，将应用程序构造为一组松散耦合的服务。在微服务体系结构中，服务是细粒度的，协议是轻量级的。
对于一些大型的 IT 系统来说，微服务的个数可能达到 1000 多个或者更多。如果我们的系统变得很慢，我们想查出是哪个环节出了问题。如果没有一个很好的可观测性的工具。我们有时是一头的雾水。很幸运的是 Elastic Stack 提供了一套完整的 APM （应用性能监控）可观测性软件栈，为我们对微服务的调试提供了完美的解决方案。
在今天的文章中，我们将使用一个简单的例子来展示如何从0基础到一个掌控微服务可观察性的专家。你不需要具有先前的很多知识。对于 Elastic APM 不是很熟的开发者来说，你可以阅读我之前的文章 “Elastic：应用程序性能监控/管理（APM）实践”。
在今天的实践中，我将使用如下的代码来进行展示：
git clone https://github.com/liu-xiao-guo/from-zero-to-hero-with-observability 在做实验之前，请使用上面的命令下载代码。
Service Map 是应用程序体系结构中已检测服务的实时可视表示。 它显示了这些服务的连接方式，以及诸如平均交易持续时间，每分钟请求数和每分钟错误数之类的高级指标。 如果启用，服务图还将与机器学习集成-基于异常检测分数的实时健康指标。 所有这些功能都可以帮助你快速直观地评估服务的状态和运行状况。上面的例子的微服务服务图如下：
整个软件有如下的几个部分组成：
h2：是一个本地数据库backend-java ：是一个 Spring 的网路服务器。它接受来自 fronend-react 的数据请求localhost:3000： 是一个服务器，它用作数据展示backend-golang：它是一个由 Golang 写的服务，可以访问 redis 数据库 在下面，我们一步一步地来展示如何从 0 开始启动微服务的可观测性。我将以 7.10 版本为例来进行展示。
安装 Elasticsearch 及 Kibana 我们可以按照我们的文章 “Elastic：开发者上手指南” 来安装及运行我们的 Elasticsearch 及 Kibana。安装完后，并安装相应的指令分别进行运行。
APM server 我们接下来安装 APM 服务器。打开 Kibana：
我们可以根据自己的操作系统来分别进行安装。在我的实验中，我将以 macOS 为例来进行展示。通过这种安装的好处是它永远可以匹配你当前运行的 Elasticsearch 及 Kibana 的版本，同时你也可以找到适合自己 OS 的 APM Server 的安装方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9129d9180915604d726773488cd95f8f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-17T12:12:29+08:00" />
<meta property="article:modified_time" content="2022-05-17T12:12:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Observability：从零基础到能够完成微服务可观测性的专家 - Service Map 实践</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>现在的 IT 系统越来越复杂，而微服务也被广泛使用于越来越多的大型 IT 系统中。 微服务是一种软件开发技术- 面向服务的体系结构（SOA）架构样式的一种变体，将应用程序构造为一组松散耦合的服务。在微服务体系结构中，服务是细粒度的，协议是轻量级的。</p> 
<p style="text-align:center;"><img alt="" height="450" src="https://images2.imgbox.com/91/f8/7wZA776C_o.jpg" width="600"></p> 
<p>对于一些大型的 IT 系统来说，微服务的个数可能达到 1000 多个或者更多。如果我们的系统变得很慢，我们想查出是哪个环节出了问题。如果没有一个很好的可观测性的工具。我们有时是一头的雾水。很幸运的是 Elastic Stack 提供了一套完整的 APM （应用性能监控）可观测性软件栈，为我们对微服务的调试提供了完美的解决方案。</p> 
<p>在今天的文章中，我们将使用一个简单的例子来展示如何从0基础到一个掌控微服务可观察性的专家。你不需要具有先前的很多知识。对于 Elastic APM 不是很熟的开发者来说，你可以阅读我之前的文章  “<a href="https://elasticstack.blog.csdn.net/article/details/102844900" rel="nofollow" title="Elastic：应用程序性能监控/管理（APM）实践">Elastic：应用程序性能监控/管理（APM）实践</a>”。</p> 
<p>在今天的实践中，我将使用如下的代码来进行展示：</p> 
<pre><code>git clone https://github.com/liu-xiao-guo/from-zero-to-hero-with-observability</code></pre> 
<p>在做实验之前，请使用上面的命令下载代码。</p> 
<p>Service Map 是应用程序体系结构中已检测服务的实时可视表示。 它显示了这些服务的连接方式，以及诸如平均交易持续时间，每分钟请求数和每分钟错误数之类的高级指标。 如果启用，服务图还将与机器学习集成-基于异常检测分数的实时健康指标。 所有这些功能都可以帮助你快速直观地评估服务的状态和运行状况。上面的例子的微服务服务图如下：</p> 
<p style="text-align:center;"><img alt="" height="404" src="https://images2.imgbox.com/a8/88/MlTLUvrE_o.png" width="800"></p> 
<p>整个软件有如下的几个部分组成：</p> 
<ul><li>h2：是一个本地数据库</li><li>backend-java ：是一个 Spring 的网路服务器。它接受来自 fronend-react 的数据请求</li><li>localhost:3000： 是一个服务器，它用作数据展示</li><li>backend-golang：它是一个由 Golang 写的服务，可以访问 redis 数据库</li></ul> 
<p>在下面，我们一步一步地来展示如何从 0 开始启动微服务的可观测性。我将以 7.10 版本为例来进行展示。</p> 
<p></p> 
<h2>安装</h2> 
<h3>Elasticsearch 及 Kibana</h3> 
<p>我们可以按照我们的文章 “<a href="https://blog.csdn.net/UbuntuTouch/article/details/102728604" title="Elastic：开发者上手指南">Elastic：开发者上手指南</a>” 来安装及运行我们的 Elasticsearch 及 Kibana。安装完后，并安装相应的指令分别进行运行。</p> 
<h3>APM server </h3> 
<p>我们接下来安装 APM 服务器。打开 Kibana：</p> 
<p><img alt="" height="1188" src="https://images2.imgbox.com/c7/41/Lpn2Xt2k_o.png" width="1200"></p> 
<p><img alt="" height="1188" src="https://images2.imgbox.com/44/c7/1oBC2HeH_o.png" width="1200"></p> 
<p><img alt="" height="1188" src="https://images2.imgbox.com/53/6b/CW4oCiv7_o.png" width="1200"></p> 
<p>我们可以根据自己的操作系统来分别进行安装。在我的实验中，我将以 macOS 为例来进行展示。通过这种安装的好处是它永远可以匹配你当前运行的 Elasticsearch 及 Kibana 的版本，同时你也可以找到适合自己 OS 的 APM Server 的安装方法。</p> 
<p>在我们启动 APM 服务器之前，我们必须修改 APM server 安装根目录下的配置文件 apm-server.yml。我们必须在这个文件的最后部分添加如下的一句话：</p> 
<pre><code>apm-server.rum.enabled: true</code></pre> 
<p>这个原因是因为在我们的实验中有 frontend-react 这个服务。我们通过打开 RUM (Real User Monitoring) 可以监视从网页发出的请求。</p> 
<p>我们可以通过如下的方法来进行运行 APM server:</p> 
<p><img alt="" height="1188" src="https://images2.imgbox.com/0f/75/hBWvNps2_o.png" width="1200"></p> 
<p>如果一切正常，我们可以看到如上所示的信息。它表明我们的 APM  server 已经成功地被安装好了。</p> 
<p></p> 
<h3>Redis </h3> 
<p>在我们的实践中，我们也使用 redis 存储。如果大家还没安装好自己的 redis 的话，我们可以参考我之前的文章 “<a href="https://elasticstack.blog.csdn.net/article/details/104422417" rel="nofollow" title="使用 Elastic Stack 对 Redis 监控">使用 Elastic Stack 对 Redis 监控</a>” 来对 Redis 进行安装。</p> 
<p>你可以查看一下你下载的项目 <a href="https://github.com/liu-xiao-guo/from-zero-to-hero-with-observability" title="GitHub - liu-xiao-guo/from-zero-to-hero-with-observability: From Zero to Hero with Observability">GitHub - liu-xiao-guo/from-zero-to-hero-with-observability: From Zero to Hero with Observability</a>。里面有一个叫做 dump.rdb 的文件：</p> 
<pre><code>$ pwd
/Users/liuxg/demos/from-zero-to-hero-with-observability
liuxg:from-zero-to-hero-with-observability liuxg$ ls
LICENSE            backend-golang     docker-compose.yml images
README.md          backend-java       frontend-react     redis-data
liuxg:from-zero-to-hero-with-observability liuxg$ ls redis-data/
dump.rdb</code></pre> 
<p>这个是 redis 的数据文件。我们可以直接把这个文件拷贝到 macOS 的如下目录：</p> 
<pre><code>$ pwd
/usr/local/var/db/redis
liuxg:redis liuxg$ ls
dump.rdb         redis-server.log redis.log</code></pre> 
<p>这样当我们启动 redis 的时候，我们可以看到预先配置好的数据。我们通过如下的方法来运行 redis:</p> 
<pre><code>sudo redis-server /usr/local/etc/redis.conf</code></pre> 
<p>一旦 redis 运行成功后，我们可以使用如下的命令来进行检查：</p> 
<pre><code>$ redis-cli 
127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; keys *
 1) "ferrari"
 2) "toyota"
 3) "koenigsegg"
 4) "tesla"
 5) "bugatti"
 6) "mclaren"
 7) "exotic-cars"
 8) "nissan"
 9) "mercedes"
10) "lamborghini"
11) "base-price-default"
12) "lexus"
13) "ford"
127.0.0.1:6379&gt; </code></pre> 
<p>我们可以看到 redis 运行于默认的端口 6379 上。如果你能看到上面的输出，则表明你的配置是成功的。</p> 
<p>至此，我们的安装以及全部完成。接下来我们需要来完成各个服务的启动。</p> 
<p></p> 
<h2>启动服务</h2> 
<p>在这个章节里，我将来启动各个服务。</p> 
<h3>backend-golang</h3> 
<p>这个是一个 Golang 的服务。在这个项目中有一个叫做 run-locally.sh 的脚本文件。我们打开这个文件，并做如下的配置：</p> 
<pre><code>#!/bin/bash
# set -x

export ELASTIC_APM_SERVER_URL=http://localhost:8200
export ELASTIC_APM_SECRET_TOKEN=
export REDIS_URL=127.0.0.1:6379

go build -o backend-golang
./backend-golang &gt;&gt; backend-golang.json</code></pre> 
<p>在上面，我们配置了 APM  Server 的地址。由于它可以访问 redis，所以我也配置 redis 的访客地址及端口。</p> 
<p style="text-align:center;"><img alt="" height="451" src="https://images2.imgbox.com/f9/76/pcqBBFVQ_o.png" width="1100"></p> 
<p>这样我们的配置就基本完成了。当我们编译并运行时可能会出现不能访问 github 的一些库的情况。我们可以在 terminal 中先执行如下的命令，然后再执行 run-locally.sh:</p> 
<pre><code>export GO111MODULE=on
export GOPROXY=https://goproxy.io</code></pre> 
<p>然后再执行：</p> 
<pre><code>./run-locally.sh </code></pre> 
<p>这样我们就完成了 frontend-react 的启动工作了。</p> 
<p></p> 
<h3>backend-java</h3> 
<p>首先，我们打开地址：<a href="https://search.maven.org/search?q=a:elastic-apm-agent" rel="nofollow" title="Maven Central Repository Search">Maven Central Repository Search</a>，并找到最新的 elastic-apm-agent 的版本号码：</p> 
<p><img alt="" height="656" src="https://images2.imgbox.com/14/ee/m0L0IK7Y_o.png" width="1200"></p> 
<p>在上面显示有一个叫做 1.19.0 的发布版。我们可以点击右边的下载按钮进行直接下载，并拷贝到 backend-java 的根目录下。或者，我们直接有如下的 run-locally.sh 来帮我们进行下载。</p> 
<p>我们接下来配置 backend-java。打开这个项目的根目录，我们找 run-locally.sh 这个脚本文件：</p> 
<p><img alt="" height="640" src="https://images2.imgbox.com/45/1d/ZVN7JKXV_o.png" width="1200"></p> 
<p>在上面我们必须修改 AGENT_VERSION 这个变量的值。如果我们没有下载 elastic-apm-agent 的话，在下来的 curl 指令会帮我们下载。这个依赖于你的下载速度。</p> 
<p>我们做如下的配置：</p> 
<pre><code>export ELASTIC_APM_SERVER_URL=http://localhost:8200
export ELASTIC_APM_SECRET_TOKEN=
export ESTIMATOR_URL=http://localhost:8888</code></pre> 
<p>我们通过如下的命令来运行这个服务：</p> 
<pre><code>/run-locally.sh </code></pre> 
<p>当我们成功运行时，我们可以看到：</p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/11/96/w2VqQM0r_o.png" width="1200"></p> 
<p>这是一个 Spring 的 Web 服务。</p> 
<p></p> 
<h3>frontend-react</h3> 
<p>这个是我们的前端。我们打开这个项目，并找到 run-locally.sh 脚本文件。</p> 
<p><img alt="" height="727" src="https://images2.imgbox.com/ec/7b/6sI1sNRv_o.png" width="1200"></p> 
<p>我们对它作如下的配置：</p> 
<pre><code>export ELASTIC_APM_SERVER_URL=http://localhost:8200
export BACKEND_URL=http://localhost:8080</code></pre> 
<p>我们在运行 run-locally.sh 之前，需要使用使用如下的命令来安装 env-cmd:</p> 
<pre><code>npm install env-cmd</code></pre> 
<p>然后，我们使用如下的命令来启动：</p> 
<pre><code>./run-locally.sh</code></pre> 
<p>这样我们的 frontend-react 启动起来了。我们可以在浏览器中访问 <a href="http://http//localhost:3000" rel="nofollow" title="http:.//localhost:3000">http:.//localhost:3000</a>:</p> 
<p><img alt="" height="980" src="https://images2.imgbox.com/55/2d/EsxkPHIg_o.png" width="1200"></p> 
<p>从上面，我们可以看出来这是一个显示汽车信息及价格的一个列表。我们可以直接在网页上点击每个项进行修改，删除或创建一个新的汽车。</p> 
<p></p> 
<h2>通过 APM 来展示微服务的可观察性</h2> 
<h3>展示 Service Map</h3> 
<p>我们直接进入 Obverability overview 页面：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/9f/c4/DuiFzmIs_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a1/88/SE5gaD9F_o.png" width="1200"></p> 
<p>从上面的界面显示，我们可以看出来有3个 Services。我们点击 View in app:</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a2/a8/JARFwiLc_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c0/70/ie2tgRU2_o.png" width="1200"></p> 
<p>从上面我们可以看出来有三个服务：backend-java, frontend-react 以及 backend-golang。我们点击 Service Map:</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/67/c2/UXI7Rrf3_o.png" width="1200"></p> 
<p>我们可以点击每个节点，并查看详细信息：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/87/11/hGnF9aWS_o.png" width="1200"></p> 
<p>从上面的图，我们可以看出来 frontend-react 调用 backend-java，而 backend-java 调用 h2 数据库。到目前为止 backend-goland 是单独的一个服务。它和其它的服务没有任何的联系。我们接下来在 localhost:3000 来创建一个新的汽车：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/85/d9/jvRQzsmc_o.png" width="1200"></p> 
<p>点击上面的 Save 按钮：</p> 
<p><img alt="" height="724" src="https://images2.imgbox.com/4e/3d/wkFxU6wI_o.png" width="1200"></p> 
<p>我们可以看到新添加的叫做 Hyundai 的汽车。这个时候，我们重新刷新我们之前的 Service Map 界面：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e4/27/SSeZu4Qp_o.png" width="1200"></p> 
<p>这个时候，我们会发现 Service Map 有了新的变化。 backend-java 这个时候调用 backend-golang 服务了。</p> 
<p>我们接下来查看一个典型的 transaction:</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d0/56/AnRVUTIS_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e6/e1/1nmmEwZ7_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/9b/58/A9mO1HbC_o.png" width="1200"></p> 
<p>从上面我们可以看出从界面点击 New Car 所创建的一个 transaction 经历的所有 span。每个 span 都有相应的执行时间。我们很清楚整个调用的时间是花在哪里。如果我们的应用出现性能问题，我们很容从上面的图中看出来。上面的每个不同的颜色代表不同的微服务或数据库访问。我们可以点进每个 span 去查看具体的执行。比如点击上面的 INSERT INTO car:</p> 
<p><img alt="" height="802" src="https://images2.imgbox.com/d0/61/Vy6Sdmwz_o.png" width="1200"></p> 
<p>这个就是 APM 最好的地方。它很清楚地展示了我们的代码的执行情况。</p> 
<p></p> 
<h2>调试应用</h2> 
<p>我们接下来使用 UI 来创建一个新的汽车：</p> 
<p><img alt="" height="1146" src="https://images2.imgbox.com/4c/b2/pzpyxMwK_o.png" width="1200"></p> 
<p>我们按照如上所示的数据来添加一个叫做 Ferrari （法拉利）的汽车。点击 Save 按钮：</p> 
<p><img alt="" height="718" src="https://images2.imgbox.com/6c/d5/TQVOJDto_o.png" width="1200"></p> 
<p>我可以看到一个新增加的一个 Ferrari 汽车，但是我们会发现这次的操作和之前添加 Hyundai 所需要的时间要长很多。它需要花去5秒钟的时间。这到底是为什么呢？我们必须找出问题所在的原因。</p> 
<p>我们还是回到之前 Add car 的那个 transaction:</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/32/23/6y2HItM1_o.png" width="1200"></p> 
<p>我们选择执行时间较长的那个 transaction：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/8c/32/HPg7L4V4_o.png" width="1200"></p> 
<p>我们很快地发现在 calculateEstimate 的 span 里，它几乎占据了整个的执行时间。将近5秒的时间。我们直接点击上面的链接：</p> 
<p><img alt="" height="982" src="https://images2.imgbox.com/b3/90/PiFr9FkG_o.png" width="1200"></p> 
<p>首先我们不用想很多，它清楚地指出了在 backend-goland 服务中的 main.go 109 行代码有问题。点击 Metadata:</p> 
<p><img alt="" height="994" src="https://images2.imgbox.com/5f/f2/GKTbK0pt_o.png" width="1200"></p> 
<p>它显示 brand 是 Ferrari，model 是 2020年，生产日期是 2020 年。</p> 
<p>我们直接打开 main.go 文件：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/5b/33/t5pVv5ti_o.png" width="1200"></p> 
<p>在上面的代码中，我们定义了一个叫做 calculateEstimate 的 span。在这个代码中，我们定义了 brand, model 以及 year。这些对应于我们上面显示的 metadata。</p> 
<p>我们向下滚动追查 calculateEstimate 函数：</p> 
<pre><code>func calculateEstimate(ctx context.Context, brand string, model string, year int) Estimate {

	logger.Info("Value estimation for brand: "+brand,
		zap.String("event.dataset", eventDataset))

	estimate := Estimate{
		Brand: brand,
		Model: model,
		Year:  year,
	}

	brand = strings.ToLower(brand)

	// Retrieve the base price for the car
	redisConn := apmredigo.Wrap(redisPool.Get()).WithContext(ctx)
	defer redisConn.Close()
	basePrice, err := redis.Int(redisConn.Do("GET", brand))
	if err != nil {
		logger.Error(fmt.Sprintf("Error getting base price for '%s'", brand),
			zap.Error(err), zap.String("event.dataset", eventDataset))
	}
	if basePrice == 0 {
		basePrice, err = redis.Int(redisConn.Do("GET", basePriceDefault))
		if err != nil {
			logger.Error("Error getting base price default", zap.Error(err),
				zap.String("event.dataset", eventDataset))
		}
	}

	// Calculate mark up of 5% on top of the base price
	markUp := int(((float64(5) * float64(basePrice)) / float64(100)))

	// Exotic cars have an additional markup
	isExotic, err := redis.Bool(redisConn.Do("SISMEMBER", exoticCars, brand))
	if err != nil {
		logger.Error(fmt.Sprintf("Error checking if '%s' is exotic", brand),
			zap.Error(err), zap.String("event.dataset", eventDataset))
	}
	if isExotic {
		markUp += additionalMarkUp()
	}

	estimate.Estimate = basePrice + markUp
	return estimate

}</code></pre> 
<p>从上面的代码中，我们可以看出来有两个 Redis 操作：</p> 
<ul><li>GET</li><li> <p>SISMEMBER</p> </li></ul> 
<p>他们分别对应于我们之前显示的图：</p> 
<p><img alt="" height="262" src="https://images2.imgbox.com/e4/5e/816wiMDN_o.png" width="1200"></p> 
<p>那么我们的时间到底是花在哪里呢？我们先来查看如下的一个调用：</p> 
<pre><code>	// Exotic cars have an additional markup
	isExotic, err := redis.Bool(redisConn.Do("SISMEMBER", exoticCars, brand))
	if err != nil {
		logger.Error(fmt.Sprintf("Error checking if '%s' is exotic", brand),
			zap.Error(err), zap.String("event.dataset", eventDataset))
	}
	if isExotic {
		markUp += additionalMarkUp()
	}</code></pre> 
<p>在上面的 SISMEMBER 调用中它检查输入的汽车是否为 exotic （外来的）汽车。如果是需要调用  additionalMarkup()。这是一个模拟的针对外来汽车需要额外执行的函数。</p> 
<p>我们打开 redis 进行检查：</p> 
<pre><code>$ redis-cli 
127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; keys *
 1) "ferrari"
 2) "toyota"
 3) "koenigsegg"
 4) "tesla"
 5) "bugatti"
 6) "mclaren"
 7) "exotic-cars"
 8) "nissan"
 9) "mercedes"
10) "lamborghini"
11) "base-price-default"
12) "lexus"
13) "ford"
127.0.0.1:6379&gt; SMEMBERS exotic-cars
1) "ferrari"
2) "mercedes"
3) "lamborghini"
4) "koenigsegg"
5) "bugatti"
6) "mclaren"
127.0.0.1:6379&gt; </code></pre> 
<p>从上面的图中，我们可以看出来 ferrari 确实是一个 exotic 的车，那么它需要执行如下的函数：</p> 
<pre><code>func additionalMarkUp() int {
	logger.Debug("Waiting for the market data...",
		zap.String("event.dataset", eventDataset))
	time.Sleep(5 * time.Second)
	return rand.Intn(3) * 10000
}</code></pre> 
<p>在上面的函数中，我们使用了一个 Sleep 5秒的办法把当前的线程停止5秒。这也就是为什么我可以看到整个 calculateEstimate 需要大约5秒的时间来完成的原因。</p> 
<p>假如我们相对某段代码增加新的监视，我们可以仿照如下的办法来进行。我们重新编写 calculateEstimate()</p> 
<pre><code>func calculateEstimate(ctx context.Context, brand string, model string, year int) Estimate {

	logger.Info("Value estimation for brand: "+brand,
		zap.String("event.dataset", eventDataset))

	estimate := Estimate{
		Brand: brand,
		Model: model,
		Year:  year,
	}

	brand = strings.ToLower(brand)

	// Retrieve the base price for the car
	redisConn := apmredigo.Wrap(redisPool.Get()).WithContext(ctx)
	defer redisConn.Close()
	basePrice, err := redis.Int(redisConn.Do("GET", brand))
	if err != nil {
		logger.Error(fmt.Sprintf("Error getting base price for '%s'", brand),
			zap.Error(err), zap.String("event.dataset", eventDataset))
	}
	if basePrice == 0 {
		basePrice, err = redis.Int(redisConn.Do("GET", basePriceDefault))
		if err != nil {
			logger.Error("Error getting base price default", zap.Error(err),
				zap.String("event.dataset", eventDataset))
		}
	}

	// Calculate mark up of 5% on top of the base price
	markUp := int(((float64(5) * float64(basePrice)) / float64(100)))

	// Exotic cars have an additional markup
	isExotic, err := redis.Bool(redisConn.Do("SISMEMBER", exoticCars, brand))
	if err != nil {
		logger.Error(fmt.Sprintf("Error checking if '%s' is exotic", brand),
			zap.Error(err), zap.String("event.dataset", eventDataset))
	}
	if isExotic {
		myspan, ctx := opentracing.StartSpanFromContext(request.Context(), "additionalMarkUp")
		markUp += additionalMarkUp()
		myspan.Finish()
	}

	estimate.Estimate = basePrice + markUp
	return estimate
}</code></pre> 
<p>在上面，我为如下的代码进行了修改：</p> 
<pre><code>	if isExotic {
		myspan, ctx := opentracing.StartSpanFromContext(request.Context(), "additionalMarkUp")
		markUp += additionalMarkUp()
		myspan.Finish()
	}
</code></pre> 
<p>我们相对 addtionalMarkup 的调用进行监视。最终在我们的 Add car 中会有一个相应的 additionalMarkup span 出现。为了能够是这个代码起作用。我们重新启动各个服务。我们在 UI 添加一个新的汽车 lamborghini。这显然是一个 exotic 汽车：</p> 
<p><img alt="" height="1180" src="https://images2.imgbox.com/67/0e/ZwKx3TQH_o.png" width="1200"></p> 
<p>同样地，我们可以看到新添加的汽车:</p> 
<p><img alt="" height="784" src="https://images2.imgbox.com/c2/e6/IhmuJAqn_o.png" width="1200"></p> 
<p>由于 lamborghini (兰博基尼) 是一个 exotic 的汽车。毫无例外地我们可以发现它需要5秒的时间才能在页面上进行显示。</p> 
<p>我们重新来打开 Add car 这个 transaction。一定要选最新这个 transation：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c6/f0/q3WtW0pl_o.png" width="1200"></p> 
<p>如上图所示，我们可以看到一个叫做 addtionalMarkUp 的 span。</p> 
<p></p> 
<h2>运用 Filebeat 来提高可观测性</h2> 
<p>Elastic Stack 最大的优点就是可以把指标，日志以及 APM 集成到一个环境中提供全面的可观测性。在这节中，我们来安装 filebeat 来提高整个微服务的可观测性。首先我们按照之前的文章 “<a href="https://elasticstack.blog.csdn.net/article/details/104473684" rel="nofollow" title="Beats 入门教程 （二）">Beats 入门教程 （二）</a>” 来进行安装 Filebeat。</p> 
<p>我们使用如下的命令来启动对 System 模块的监控：</p> 
<pre><code>./filebeat modules enable system</code></pre> 
<p>我们接着修改 filebeat.yml 的配值文件：</p> 
<p><strong>filebeat.yml</strong></p> 
<pre><code>filebeat.inputs:

# Each - is an input. Most options can be set at the input level, so
# you can use different inputs for various configurations.
# Below are the input specific configurations.

- type: log

  # Change to true to enable this input configuration.
  enabled: true

  # Paths that should be crawled and fetched. Glob based paths.
  paths:
    - /var/log/*.log
    - /Users/liuxg/demos/from-zero-to-hero-with-observability/backend-golang/*.json
    - /Users/liuxg/demos/from-zero-to-hero-with-observability/backend-java/*.json

  json.keys_under_root: true
  json.overwrite_keys: true</code></pre> 
<p>我们修改 filebeat 的前面部分为上面的内容。上面的路径依赖于你自己的日志位置需要进行相应的修改。</p> 
<p>我们接下来运行 filebeat：</p> 
<pre><code>./filebeat setup
./filebeat -e</code></pre> 
<p><img alt="" height="1160" src="https://images2.imgbox.com/ea/76/2yEPafxu_o.png" width="1200"></p> 
<p>上面显示连接到 Elasticsearch 是成功的。</p> 
<p><img alt="" height="1182" src="https://images2.imgbox.com/ae/1b/WlP0uN9i_o.png" width="1200"></p> 
<p><img alt="" height="1182" src="https://images2.imgbox.com/a1/fc/xLbpXbdh_o.png" width="1200"></p> 
<p>上面的 Logs 中可以看出来有两中 logs。点击 View in App:</p> 
<p><img alt="" height="1182" src="https://images2.imgbox.com/93/38/ayfFCUlu_o.png" width="1200"></p> 
<p>在上面它显示了目前所有的 Log。我们回到前段的界面，重新输入一个新的汽车：</p> 
<p><img alt="" height="1182" src="https://images2.imgbox.com/3b/a7/pE1IH9rR_o.png" width="1200"></p> 
<p>点击 SAVE 按钮。我们回到 Logs 应用中：</p> 
<p><img alt="" height="1182" src="https://images2.imgbox.com/db/12/2qUqcnim_o.png" width="1200"></p> 
<p>当我们搜索的时候，我们会发现一些关于这个输入相关的 log。如上所示，我们可以找到 Test 相关的日志。</p> 
<p>我们现在重新回到 APM 应用的界面。我们找到 Add car 这个 transaction。我们确保点击最新的一个 transaction。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/0d/c7/tobVoZGt_o.png" width="1200"></p> 
<p>点击上面的 Trace logs：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7f/bd/ihVy0eID_o.png" width="1200"></p> 
<p>我们可以查看到当前 transaction 的所有日志。准确地说我们可以把 APM 和日志绑定在一起。在查看 APM 的同时，我们也可以查看日志。</p> 
<p></p> 
<h2>总结</h2> 
<p>在本文章中，我详述了如何使用 Elastic Stack 来对一个多微服务的 IT 系统进行性能监视，并提供良好的可观测性。Elastic Stack 在同一个软件栈中同时提供日志，指标以及 APM 的全方位客观则行。对于开发者来说，我们可以利用这个来对我们的系统进行监视。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/610ef07447b2c7b9ac5c17eff5cd6262/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[论文研读]天天看到的 ground truth，到底是什么意思？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40593c1ecb481bc2ae644d64f83ba6f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">“常量中有换行符”的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>