<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>智能算法——蚁群算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="智能算法——蚁群算法" />
<meta property="og:description" content="1、原理 蚁群算法是受到对真实蚂蚁群觅食行为研究的启发而提出。生物学研究表明：一群相互协作的蚂蚁能够找到食物和巢穴之间的最短路径,而单只蚂蚁则不能。生物学家经过大量细致观察研究发现,蚂蚁个体之间的行为是相互作用相互影响的。蚂蚁在运动过程中,能够在它所经过的路径上留下一种称之为信息素的物质,而此物质恰恰是蚂蚁个体之间信息传递交流的载体。蚂蚁在运动时能够感知这种物质,并且习惯于追踪此物质爬行,当然爬行过程中还会释放信息素。一条路上的信息素踪迹越浓,其它蚂蚁将以越高的概率跟随爬行此路径,从而该路径上的信息素踪迹会被加强,因此,由大量蚂蚁组成的蚁群的集体行为便表现出一种信息正反馈现象。某一路径上走过的蚂蚁越多,则后来者选择该路径的可能性就越大。蚂蚁个体之间就是通过这种间接的通信机制实现协同搜索最短路径的目标的。我们举例简单说明蚂蚁觅食行为：
如上图a,b,c的示意图：
a图是原始状态，蚂蚁起始点为A，要到达E，中途有障碍物，要绕过才能到达。BC和BH是绕过障碍物的2条路径(假设只有2条)。各个路径的距离d已经标定。
b图是t=0时刻蚂蚁状态，各个边上有相等的信息素浓度，假设为15；
c图是t=1时刻蚂蚁经过后的状态，各个边的信息素浓度，有变化；因为大量蚂蚁的选择概率会不一样，而选择概率是和路径长度相关的。所以越短路径的浓度会越来越大，经过此短路径达到目的地的蚂蚁也会比其他路径多。这样大量的蚂蚁实践之后就找到了最短路径。
所以这个过程本质可以概括为以下几点：
路径概率选择机制信息素踪迹越浓的路径,被选中的概率越大信息素更新机制路径越短,路径上的信息素踪迹增长得越快协同工作机制蚂蚁个体通过信息素进行信息交流。 从蚂蚁觅食的原理可见,单个个体的行为非常简单蚂蚁只知道跟踪信息素爬行并释放信息素,但组合后的群体智能又非常高蚂蚁群能在复杂的地理分布的清况下,轻松找到蚁穴与食物源之间的最短路径。这种特点恰恰与元启发算法的特点相一致,蚁群优化算法正是受到这种生态学现象的启发后加以模仿并改进而来,觅食的蚂蚁由人工蚁替代,蚂蚁释放的信息素变成了人工信息素,蚂蚁爬行和信息素的蒸发不再是连续不断的,而是在离散的时空中进行。
从深层意义上来讲,蚁群算法作为优化的方法之一,属于人工群集智能领域。人工群集智能,大都受自然群集智能如昆虫群和动物群等的启发而来。除了具有独特的强有力的合作搜索能力外,还可以利用一系列的计算代理对问题进行分布式处理,从而大大提高搜索效率。
2、基本流程
2.1基本数学模型 首先看看基本TSP问题的基本数学模型：
问题其实很简单，目标函数就是各个走过路径的总长度，注意的就是距离矩阵根据实际的问题不一样，长度是不一样的。
2.2说明 在说明群蚁算法流程之前，我们对算法原理和几个注意点进行描述：
TSP问题的人工蚁群算法中，假设m只蚂蚁在图的相邻节点间移动，从而协作异步地得到问题的解。每只蚂蚁的一步转移概率由图中的每条边上的两类参数决定：1. 信息素值也称信息素痕迹。2.可见度，即先验值。
2.信息素的更新方式有2种，一是挥发，也就是所有路径上的信息素以一定的比率进行减少，模拟自然蚁群的信息素随时间挥发的过程；二是增强，给评价值“好”(有蚂蚁走过)的边增加信息素。
3.蚂蚁向下一个目标的运动是通过一个随机原则来实现的，也就是运用当前所在节点存储的信息，计算出下一步可达节点的概率，并按此概率实现一步移动，逐此往复，越来越接近最优解。
4.蚂蚁在寻找过程中，或者找到一个解后，会评估该解或解的一部分的优化程度，并把评价信息保存在相关连接的信息素中。 2.3核心步骤 群蚁算法的2个核心步骤是 路径构建 和 信息素更新。
2.3.1路劲构建
每个蚂蚁都随机选择一个城市作为其出发城市，并维护一个路径记忆向量，用来存放该蚂蚁依次经过的城市。蚂蚁在构建路径的每一步中，按照一个随机比例规则选 择下一个要到达的城市。随机概率是按照下列公式来进行计算的：
上述公式就是计算当前点到每一个可能的下一个节点的概率。分子是信息素强度和能见度的幂乘积，而分母则是所有分子的和值。这个刚开始是很不容易理解的，我们在最后实例计算的时候，可以看得很清楚，再反过来理解公式。注意每次选择好节点后，就要从可用节点中移除选择的节点。
2.3.2信息素更新
信息素更新是群蚁算法的核心。也是整个算法的核心所在。算法在初始期间有一个固定的浓度值，在每一次迭代完成之后，所有出去的蚂蚁回来后，会对所走过的路线进行计算，然后更新相应的边的信息素浓度。很明显，这个数值肯定是和蚂蚁所走的长度有关系的，经过一次次的迭代，近距离的线路的浓度会很高，从而得到近似最优解。那我们看看信息素更新的过程。
初始化信息素浓度C(0)，如果太小，算法容易早熟，蚂蚁会很快集中到一条局部最优路径上来，因为可以想想，太小C值，使得和每次挥发和增强的值都差不多，那么 随机情况下，一些小概率的事件发生就会增加非最优路径的信息素浓度；如果C太大，信息素对搜索方向的指导性作用减低，影响算法性能。一般情况下，我们可以使用贪婪算法获取一个路径值Cnn，然后根据蚂蚁个数来计算C(0) = m/Cnn ,m为蚂蚁个数
每一轮过后，问题空间中的所有路径上的信息素都会发生蒸发,然后，所有的蚂蚁根据自己构建的路径长度在它们本轮经过的边上释放信息素，公式如下：
信息素更新的作用：
1.信息素挥发(evaporation)信息素痕迹的挥发过程是每个连接上的 信息素痕迹的浓度自动逐渐减弱的过程，这个挥发过程主要用于避 免算法过快地向局部最优区域集中，有助于搜索区域的扩展。
2.信息素增强(reinforcement)增强过程是蚁群优化算法中可选的部 分，称为离线更新方式（还有在线更新方式）。这种方式可以实现 由单个蚂蚁无法实现的集中行动。基本蚁群算法的离线更新方式是 在蚁群中的m只蚂蚁全部完成n城市的访问后，统一对残留信息进行 更新处理。
2.3.3迭代与停止
迭代停止的条件可以选择合适的迭代次数后停止，输出最优路径，也可以看是否满足指定最优条件，找到满足的解后停止。最重要的是，我刚开始理解这个算法的时候，以为每一只蚂蚁走一条边就是一次迭代，其实是错的。这里算法每一次迭代的意义是：每次迭代的m只蚂蚁都完成了自己的路径过程，回到原点后的整个过程。
3.计算实例
4.TSP问题的群蚁算法C#代码实现
4.1群蚁算法系统基类 我们封装了一个基础的BaseTspAntSystem类，包括了一些基本属性和计算过程，后续相关改进版本可以进行直接继承。BaseTspAntSystem类的主要属性如下：
基类有一个构造函数，对系统的初始化就是传入基本的参数，并对相关列表进行初始化，代码如下：
核心的是求解过程，完全按照迭代次数要求进行迭代进行，过程就是概率选择和信息素更新，我们辅助的用到了Ant蚂蚁类，目的就是让程序更加独立和容易理解。Ant类里面有蚂蚁路径寻找过程的所有信息。下一节将进行介绍。求解过程代码如下面，看看注释和对比算法进行：
4.2蚂蚁功能类 根据算法的描述，m只蚂蚁同时进行自己的工作和寻找路程，是一个并行的过程，因此也在单次过程中，蚂蚁都是独立的。蚂蚁的每一次迭代，过程都比较清楚，寻找路径过程，注意维护一些可用的节点列表，以及最后一条路径的处理。看看蚂蚁类的主要属性和构造函数：
Ant类的核心是寻找下一个城市节点的过程，以及循环直到所有路径都完成。如下面代码，是一个循环过程：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8578fe7f65eb2b32aede83fc0557d344/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-14T08:31:07+08:00" />
<meta property="article:modified_time" content="2022-03-14T08:31:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">智能算法——蚁群算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 style="text-align:justify;"><strong>1、原理</strong></h3> 
<p>蚁群算法是受到对真实蚂蚁群觅食行为研究的启发而提出。生物学研究表明：一群相互协作的蚂蚁能够找到食物和巢穴之间的最短路径,而单只蚂蚁则不能。生物学家经过大量细致观察研究发现,蚂蚁个体之间的行为是相互作用相互影响的。蚂蚁在运动过程中,能够在它所经过的路径上留下一种称之为信息素的物质,而此物质恰恰是蚂蚁个体之间信息传递交流的载体。蚂蚁在运动时能够感知这种物质,并且习惯于追踪此物质爬行,当然爬行过程中还会释放信息素。一条路上的信息素踪迹越浓,其它蚂蚁将以越高的概率跟随爬行此路径,从而该路径上的信息素踪迹会被加强,因此,由大量蚂蚁组成的蚁群的集体行为便表现出一种信息正反馈现象。某一路径上走过的蚂蚁越多,则后来者选择该路径的可能性就越大。蚂蚁个体之间就是通过这种间接的通信机制实现协同搜索最短路径的目标的。我们举例简单说明蚂蚁觅食行为：</p> 
<p><img alt="" height="236" src="https://images2.imgbox.com/7b/ee/bwB41MMX_o.png" width="692"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">如上图a,b,c的示意图：</p> 
<p style="margin-left:.0001pt;text-align:justify;"> a图是原始状态，蚂蚁起始点为A，要到达E，中途有障碍物，要绕过才能到达。BC和BH是绕过障碍物的2条路径(假设只有2条)。各个路径的距离d已经标定。</p> 
<p style="margin-left:.0001pt;text-align:justify;">  b图是t=0时刻蚂蚁状态，各个边上有相等的信息素浓度，假设为15；</p> 
<p style="margin-left:.0001pt;text-align:justify;">c图是t=1时刻蚂蚁经过后的状态，各个边的信息素浓度，有变化；因为大量蚂蚁的选择概率会不一样，而选择概率是和路径长度相关的。所以越短路径的浓度会越来越大，经过此短路径达到目的地的蚂蚁也会比其他路径多。这样大量的蚂蚁实践之后就找到了最短路径。</p> 
<p style="margin-left:.0001pt;text-align:justify;">所以这个过程本质可以概括为以下几点：</p> 
<ol><li style="text-align:justify;">路径概率选择机制信息素踪迹越浓的路径,被选中的概率越大</li><li style="text-align:justify;">信息素更新机制路径越短,路径上的信息素踪迹增长得越快</li><li style="text-align:justify;">协同工作机制蚂蚁个体通过信息素进行信息交流。</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">从蚂蚁觅食的原理可见,单个个体的行为非常简单蚂蚁只知道跟踪信息素爬行并释放信息素,但组合后的群体智能又非常高蚂蚁群能在复杂的地理分布的清况下,轻松找到蚁穴与食物源之间的最短路径。这种特点恰恰与元启发算法的特点相一致,蚁群优化算法正是受到这种生态学现象的启发后加以模仿并改进而来,觅食的蚂蚁由人工蚁替代,蚂蚁释放的信息素变成了人工信息素,蚂蚁爬行和信息素的蒸发不再是连续不断的,而是在离散的时空中进行。</p> 
<p><img alt="" height="362" src="https://images2.imgbox.com/96/09/AimEQBDy_o.png" width="692"></p> 
<p> <img alt="" height="333" src="https://images2.imgbox.com/82/7d/hVpM8JKd_o.png" width="686"></p> 
<p> <img alt="" height="326" src="https://images2.imgbox.com/12/dd/uolnhd29_o.png" width="685"></p> 
<p> 从深层意义上来讲,蚁群算法作为优化的方法之一,属于人工群集智能领域。人工群集智能,大都受自然群集智能如昆虫群和动物群等的启发而来。除了具有独特的强有力的合作搜索能力外,还可以利用一系列的计算代理对问题进行分布式处理,从而大大提高搜索效率。</p> 
<p style="text-align:justify;"><strong>2、基本流程</strong></p> 
<h4 style="text-align:justify;"><strong>2.1基本数学模型</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">首先看看基本TSP问题的基本数学模型：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="453" src="https://images2.imgbox.com/61/ab/PapRQj5e_o.png" width="733"></p> 
<p> 问题其实很简单，目标函数就是各个走过路径的总长度，注意的就是距离矩阵根据实际的问题不一样，长度是不一样的。</p> 
<h4 style="text-align:justify;"><strong>2.2说明</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">在说明群蚁算法流程之前，我们对算法原理和几个注意点进行描述：</p> 
<p style="margin-left:.0001pt;text-align:justify;">TSP问题的人工蚁群算法中，假设m只蚂蚁在图的相邻节点间移动，从而协作异步地得到问题的解。每只蚂蚁的一步转移概率由图中的每条边上的两类参数决定：1. 信息素值也称信息素痕迹。2.可见度，即先验值。<br> 2.信息素的更新方式有2种，一是挥发，也就是所有路径上的信息素以一定的比率进行减少，模拟自然蚁群的信息素随时间挥发的过程；二是增强，给评价值“好”(有蚂蚁走过)的边增加信息素。<br> 3.蚂蚁向下一个目标的运动是通过一个随机原则来实现的，也就是运用当前所在节点存储的信息，计算出下一步可达节点的概率，并按此概率实现一步移动，逐此往复，越来越接近最优解。<br> 4.蚂蚁在寻找过程中，或者找到一个解后，会评估该解或解的一部分的优化程度，并把评价信息保存在相关连接的信息素中。 </p> 
<h4 style="text-align:justify;"><strong>2.3核心步骤</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">群蚁算法的2个核心步骤是 路径构建 和 信息素更新。</p> 
<p><strong>2.3.1路劲构建</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">每个蚂蚁都随机选择一个城市作为其出发城市，并维护一个路径记忆向量，用来存放该蚂蚁依次经过的城市。蚂蚁在构建路径的每一步中，按照一个随机比例规则选 择下一个要到达的城市。随机概率是按照下列公式来进行计算的：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="373" src="https://images2.imgbox.com/b3/eb/hbnjIuQR_o.png" width="694"></p> 
<p> <img alt="" height="371" src="https://images2.imgbox.com/6f/66/fs7qn7KO_o.png" width="690"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">上述公式就是计算当前点到每一个可能的下一个节点的概率。分子是信息素强度和能见度的幂乘积，而分母则是所有分子的和值。这个刚开始是很不容易理解的，我们在最后实例计算的时候，可以看得很清楚，再反过来理解公式。注意每次选择好节点后，就要从可用节点中移除选择的节点。</p> 
<p><strong>2.3.2信息素更新</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">信息素更新是群蚁算法的核心。也是整个算法的核心所在。算法在初始期间有一个固定的浓度值，在每一次迭代完成之后，所有出去的蚂蚁回来后，会对所走过的路线进行计算，然后更新相应的边的信息素浓度。很明显，这个数值肯定是和蚂蚁所走的长度有关系的，经过一次次的迭代，近距离的线路的浓度会很高，从而得到近似最优解。那我们看看信息素更新的过程。</p> 
<p style="margin-left:.0001pt;text-align:justify;">初始化信息素浓度C(0)，如果太小，算法容易早熟，蚂蚁会很快集中到一条局部最优路径上来，因为可以想想，太小C值，使得和每次挥发和增强的值都差不多，那么 随机情况下，一些小概率的事件发生就会增加非最优路径的信息素浓度；如果C太大，信息素对搜索方向的指导性作用减低，影响算法性能。一般情况下，我们可以使用贪婪算法获取一个路径值Cnn，然后根据蚂蚁个数来计算C(0) = m/Cnn ,m为蚂蚁个数</p> 
<p style="margin-left:.0001pt;text-align:justify;">每一轮过后，问题空间中的所有路径上的信息素都会发生蒸发,然后，所有的蚂蚁根据自己构建的路径长度在它们本轮经过的边上释放信息素，公式如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="213" src="https://images2.imgbox.com/b3/e3/d0bumIKp_o.png" width="686"></p> 
<p> <img alt="" height="257" src="https://images2.imgbox.com/44/52/mJRSvDiW_o.png" width="683"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">信息素更新的作用：<br> 1.信息素挥发(evaporation)信息素痕迹的挥发过程是每个连接上的 信息素痕迹的浓度自动逐渐减弱的过程，这个挥发过程主要用于避 免算法过快地向局部最优区域集中，有助于搜索区域的扩展。<br> 2.信息素增强(reinforcement)增强过程是蚁群优化算法中可选的部 分，称为离线更新方式（还有在线更新方式）。这种方式可以实现 由单个蚂蚁无法实现的集中行动。基本蚁群算法的离线更新方式是 在蚁群中的m只蚂蚁全部完成n城市的访问后，统一对残留信息进行 更新处理。</p> 
<p><strong>2.3.3迭代与停止</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">迭代停止的条件可以选择合适的迭代次数后停止，输出最优路径，也可以看是否满足指定最优条件，找到满足的解后停止。最重要的是，我刚开始理解这个算法的时候，以为每一只蚂蚁走一条边就是一次迭代，其实是错的。这里算法每一次迭代的意义是：每次迭代的m只蚂蚁都完成了自己的路径过程，回到原点后的整个过程。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3.计算实例</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="226" src="https://images2.imgbox.com/7b/9a/EH3Il3ED_o.png" width="674"></p> 
<p> <img alt="" height="440" src="https://images2.imgbox.com/9e/46/sHKqudk9_o.png" width="680"></p> 
<p> <img alt="" height="409" src="https://images2.imgbox.com/b5/bd/Ar0Eik9A_o.png" width="692"></p> 
<p> <img alt="" height="370" src="https://images2.imgbox.com/62/c6/gM05AEVW_o.png" width="692"></p> 
<p> <img alt="" height="263" src="https://images2.imgbox.com/7b/1f/wu3oHaX2_o.png" width="691"></p> 
<p> <img alt="" height="417" src="https://images2.imgbox.com/df/7c/LygOUico_o.png" width="688"></p> 
<p> </p> 
<p style="text-align:justify;"><strong>4.TSP问题的群蚁算法C#代码实现</strong></p> 
<h4 style="text-align:justify;"><strong>4.1群蚁算法系统基类</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">我们封装了一个基础的BaseTspAntSystem类，包括了一些基本属性和计算过程，后续相关改进版本可以进行直接继承。BaseTspAntSystem类的主要属性如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="464" src="https://images2.imgbox.com/b2/c7/OaZTRMOU_o.png" width="691"></p> 
<p> 基类有一个构造函数，对系统的初始化就是传入基本的参数，并对相关列表进行初始化，代码如下：</p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/0f/9c/jGS0ruvM_o.png" width="691"></p> 
<p> 核心的是求解过程，完全按照迭代次数要求进行迭代进行，过程就是概率选择和信息素更新，我们辅助的用到了Ant蚂蚁类，目的就是让程序更加独立和容易理解。Ant类里面有蚂蚁路径寻找过程的所有信息。下一节将进行介绍。求解过程代码如下面，看看注释和对比算法进行：</p> 
<p><img alt="" height="1149" src="https://images2.imgbox.com/dc/43/V8andBzA_o.png" width="691"></p> 
<p> </p> 
<h4 style="text-align:justify;"><strong>4.2蚂蚁功能类</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">根据算法的描述，m只蚂蚁同时进行自己的工作和寻找路程，是一个并行的过程，因此也在单次过程中，蚂蚁都是独立的。蚂蚁的每一次迭代，过程都比较清楚，寻找路径过程，注意维护一些可用的节点列表，以及最后一条路径的处理。看看蚂蚁类的主要属性和构造函数：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="965" src="https://images2.imgbox.com/a3/c8/R9JIcBEK_o.png" width="662"></p> 
<p> Ant类的核心是寻找下一个城市节点的过程，以及循环直到所有路径都完成。如下面代码，是一个循环过程：</p> 
<p><img alt="" height="1099" src="https://images2.imgbox.com/ea/ff/3uwqCkPP_o.png" width="661"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07548780dc6a8dc658c8afae72cb81ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Win11又双叒叕崩溃？大量网友开始回滚Win10</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/585d510eec0c7cc3bbbf07bcf9aca1e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.nio.file.NoSuchFileException</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>