<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java8异步利器：CompletableFuture全网最全使用教程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java8异步利器：CompletableFuture全网最全使用教程" />
<meta property="og:description" content="点击上方“Java基基”，选择“设为星标”
做积极的人，而不是积极废人！
每天 14:00 更新文章，每天掉亿点点头发...
源码精品专栏
原创 | Java 2021 超神之路，很肝~
中文详细注释的开源项目
RPC 框架 Dubbo 源码解析
网络应用框架 Netty 源码解析
消息中间件 RocketMQ 源码解析
数据库中间件 Sharding-JDBC 和 MyCAT 源码解析
作业调度中间件 Elastic-Job 源码解析
分布式事务中间件 TCC-Transaction 源码解析
Eureka 和 Hystrix 源码解析
Java 并发源码
来源：blog.csdn.net/zsx_xiaoxin/
article/details/123898171
一、创建异步任务
1. supplyAsync
2. runAsync
3.获取任务结果的方法
二、异步回调处理
1. thenApply和thenApplyAsync
2. thenAccept和thenAcceptAsync
3.thenRun和thenRunAsync
4.whenComplete和whenCompleteAsync
5.handle和handleAsync
三、多任务组合处理
1. thenCombine、thenAcceptBoth 和runAfterBoth
2. allOf / anyOf
CompletableFuture是jdk8的新特性。CompletableFuture实现了CompletionStage接口和Future接口，前者是对后者的一个扩展，增加了异步会点、流式处理、多个Future组合处理的能力，使Java在处理多任务的协同工作时更加顺畅便利。
一、创建异步任务 1. supplyAsync supplyAsync是创建带有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是带有自定义线程池的重载方法
// 带返回值异步请求，默认线程池 public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) // 带返回值的异步请求，可以自定义线程池 public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor) 测试代码：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/66fa0364f72220fa921708f45484079e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-31T11:55:20+08:00" />
<meta property="article:modified_time" content="2023-03-31T11:55:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java8异步利器：CompletableFuture全网最全使用教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:center;">点击上方“Java基基”，选择“设为星标”</p> 
 <p style="text-align:center;">做积极的人，而不是积极废人！</p> 
 <p style="text-align:center;">每天 <strong>14:00</strong> 更新文章，每天掉亿点点头发...</p> 
 <p style="text-align:center;"></p> 
 <p>源码精品专栏</p>  
 <ul><li><p><a href="" rel="nofollow">原创 | Java 2021 超神之路，很肝~</a><br></p></li><li><p><a href="" rel="nofollow">中文详细注释的开源项目</a><br></p></li><li><p><a href="" rel="nofollow">RPC 框架 Dubbo 源码解析</a></p></li><li><p><a href="" rel="nofollow">网络应用框架 Netty 源码解析</a></p></li><li><p><a href="" rel="nofollow">消息中间件 RocketMQ 源码解析</a><br></p></li><li><p><a href="" rel="nofollow">数据库中间件 Sharding-JDBC 和 MyCAT 源码解析</a></p></li><li><p><a href="" rel="nofollow">作业调度中间件 Elastic-Job 源码解析</a></p></li><li><p><a href="" rel="nofollow">分布式事务中间件 TCC-Transaction 源码解析</a></p></li><li><p><a href="" rel="nofollow">Eureka 和 Hystrix 源码解析</a></p></li><li><p><a href="" rel="nofollow">Java 并发源码</a></p></li></ul> 
 <p style="text-align:right;"><a href="" rel="nofollow">来源：blog.csdn.net/zsx_xiaoxin/</a></p> 
 <p style="text-align:right;"><a href="" rel="nofollow">article/details/123898171</a></p> 
 <ul><li><p><a href="" rel="nofollow">一、创建异步任务</a></p> 
   <ul><li><p><a href="" rel="nofollow">1. supplyAsync</a></p></li><li><p><a href="" rel="nofollow">2. runAsync</a></p></li><li><p><a href="" rel="nofollow">3.获取任务结果的方法</a></p></li></ul></li><li><p><a href="" rel="nofollow">二、异步回调处理</a></p> 
   <ul><li><p><a href="" rel="nofollow">1. thenApply和thenApplyAsync</a></p></li><li><p><a href="" rel="nofollow">2. thenAccept和thenAcceptAsync</a></p></li><li><p><a href="" rel="nofollow">3.thenRun和thenRunAsync</a></p></li><li><p><a href="" rel="nofollow">4.whenComplete和whenCompleteAsync</a></p></li><li><p><a href="" rel="nofollow">5.handle和handleAsync</a></p></li></ul></li><li><p><a href="" rel="nofollow">三、多任务组合处理</a></p> 
   <ul><li><p><a href="" rel="nofollow">1. thenCombine、thenAcceptBoth 和runAfterBoth</a></p></li><li><p><a href="" rel="nofollow">2. allOf / anyOf</a></p></li></ul></li></ul> 
 <p><a href="" rel="nofollow"><img src="https://images2.imgbox.com/fa/1e/5mUxLY0f_o.jpg" alt="dc9589f16247bb32427ccbbacfc8890a.jpeg"></a></p> 
 <hr> 
 <p>CompletableFuture是jdk8的新特性。CompletableFuture实现了CompletionStage接口和Future接口，前者是对后者的一个扩展，增加了异步会点、流式处理、多个Future组合处理的能力，使Java在处理多任务的协同工作时更加顺畅便利。</p> 
 <h3><a href="" rel="nofollow">一、创建异步任务</a></h3> 
 <h4><a href="" rel="nofollow">1. supplyAsync</a></h4> 
 <p>supplyAsync是创建带有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是带有自定义线程池的重载方法</p> 
 <pre class="has"><code class="language-go">// 带返回值异步请求，默认线程池
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)

// 带返回值的异步请求，可以自定义线程池
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code></pre> 
 <p>测试代码：</p> 
 <pre class="has"><code class="language-go">public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println("do something....");
            return "result";
        });

        //等待任务执行完成
        System.out.println("结果-&gt;" + cf.get());
}


public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 自定义线程池
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println("do something....");
            return "result";
        }, executorService);

        //等待子任务执行完成
        System.out.println("结果-&gt;" + cf.get());
}</code></pre> 
 <p>测试结果：</p> 
 <img src="https://images2.imgbox.com/87/a5/lm6aTccY_o.png" alt="345d0775673826aa54503466ec54d61f.png"> 
 <h4><a href="" rel="nofollow">2. runAsync</a></h4> 
 <p>runAsync是创建没有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是带有自定义线程池的重载方法</p> 
 <pre class="has"><code class="language-go">// 不带返回值的异步请求，默认线程池
public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)

// 不带返回值的异步请求，可以自定义线程池
public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)</code></pre> 
 <p>测试代码：</p> 
 <pre class="has"><code class="language-go">public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(() -&gt; {
            System.out.println("do something....");
        });

        //等待任务执行完成
        System.out.println("结果-&gt;" + cf.get());
}


public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 自定义线程池
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(() -&gt; {
            System.out.println("do something....");
        }, executorService);

        //等待任务执行完成
        System.out.println("结果-&gt;" + cf.get());
}</code></pre> 
 <p>测试结果：</p> 
 <img src="https://images2.imgbox.com/f1/a2/VK943ZZr_o.png" alt="4e599b7fc7eac3cf8066869ce66b218b.png"> 
 <h4><a href="" rel="nofollow">3.获取任务结果的方法</a></h4> 
 <pre class="has"><code class="language-go">// 如果完成则返回结果，否则就抛出具体的异常
public T get() throws InterruptedException, ExecutionException 

// 最大时间等待返回结果，否则就抛出具体异常
public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException

// 完成时返回结果值，否则抛出unchecked异常。为了更好地符合通用函数形式的使用，如果完成此 CompletableFuture所涉及的计算引发异常，则此方法将引发unchecked异常并将底层异常作为其原因
public T join()

// 如果完成则返回结果值（或抛出任何遇到的异常），否则返回给定的 valueIfAbsent。
public T getNow(T valueIfAbsent)

// 如果任务没有完成，返回的值设置为给定值
public boolean complete(T value)

// 如果任务没有完成，就抛出给定异常
public boolean completeExceptionally(Throwable ex)</code></pre> 
 <blockquote> 
  <p>基于 Spring Boot + MyBatis Plus + Vue &amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能</p> 
  <ul><li><p>项目地址：https://github.com/YunaiV/ruoyi-vue-pro</p></li><li><p>视频教程：https://doc.iocoder.cn/video/</p></li></ul> 
 </blockquote> 
 <h3><a href="" rel="nofollow">二、异步回调处理</a></h3> 
 <h4><a href="" rel="nofollow">1. thenApply和thenApplyAsync</a></h4> 
 <p>thenApply 表示某个任务执行完成后执行的动作，即回调方法，会将该任务的执行结果即方法返回值作为入参传递到回调方法中，带有返回值。</p> 
 <p>测试代码：</p> 
 <pre class="has"><code class="language-go">public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });

        CompletableFuture&lt;Integer&gt; cf2 = cf1.thenApplyAsync((result) -&gt; {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            result += 2;
            return result;
        });
        //等待任务1执行完成
        System.out.println("cf1结果-&gt;" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果-&gt;" + cf2.get());
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });

        CompletableFuture&lt;Integer&gt; cf2 = cf1.thenApply((result) -&gt; {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            result += 2;
            return result;
        });
        //等待任务1执行完成
        System.out.println("cf1结果-&gt;" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果-&gt;" + cf2.get());
}</code></pre> 
 <p>测试结果：</p> 
 <p><img src="https://images2.imgbox.com/88/7d/VDPMrMvy_o.png" alt="93f672170aad7e2d5add8b28efac01a3.png"><img src="https://images2.imgbox.com/4f/69/WS7tcxja_o.png" alt="89b439e3ea0bf169a4deb63b48488ef4.png"></p> 
 <p>从上面代码和测试结果我们发现thenApply和thenApplyAsync区别在于，使用thenApply方法时子任务与父任务使用的是同一个线程，而thenApplyAsync在子任务中是另起一个线程执行任务，并且thenApplyAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。</p> 
 <h4><a href="" rel="nofollow">2. thenAccept和thenAcceptAsync</a></h4> 
 <p>thenAccep表示某个任务执行完成后执行的动作，即回调方法，会将该任务的执行结果即方法返回值作为入参传递到回调方法中，无返回值。</p> 
 <p>测试代码</p> 
 <pre class="has"><code class="language-go">public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });

        CompletableFuture&lt;Void&gt; cf2 = cf1.thenAccept((result) -&gt; {
            System.out.println(Thread.currentThread() + " cf2 do something....");
        });

        //等待任务1执行完成
        System.out.println("cf1结果-&gt;" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果-&gt;" + cf2.get());
}


public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });

        CompletableFuture&lt;Void&gt; cf2 = cf1.thenAcceptAsync((result) -&gt; {
            System.out.println(Thread.currentThread() + " cf2 do something....");
        });

        //等待任务1执行完成
        System.out.println("cf1结果-&gt;" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果-&gt;" + cf2.get());
}</code></pre> 
 <p>测试结果：</p> 
 <p><img src="https://images2.imgbox.com/b4/70/hGTNUmAl_o.png" alt="5322a90e1b37f73b30671dde7f0a0a0e.png"><img src="https://images2.imgbox.com/01/a5/EbGbQ84q_o.png" alt="2b4d3676f1211e64bc48f9af823336c9.png">从上面代码和测试结果我们发现thenAccep和thenAccepAsync区别在于，使用thenAccep方法时子任务与父任务使用的是同一个线程，而thenAccepAsync在子任务中可能是另起一个线程执行任务，并且thenAccepAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。</p> 
 <h4><a href="" rel="nofollow">3.thenRun和thenRunAsync</a></h4> 
 <p>thenRun表示某个任务执行完成后执行的动作，即回调方法，无入参，无返回值。</p> 
 <p>测试代码：</p> 
 <pre class="has"><code class="language-go">public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });

        CompletableFuture&lt;Void&gt; cf2 = cf1.thenRun(() -&gt; {
            System.out.println(Thread.currentThread() + " cf2 do something....");
        });

        //等待任务1执行完成
        System.out.println("cf1结果-&gt;" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果-&gt;" + cf2.get());
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });

        CompletableFuture&lt;Void&gt; cf2 = cf1.thenRunAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf2 do something....");
        });

        //等待任务1执行完成
        System.out.println("cf1结果-&gt;" + cf1.get());
        //等待任务2执行完成
        System.out.println("cf2结果-&gt;" + cf2.get());
}</code></pre> 
 <p>测试结果：</p> 
 <img src="https://images2.imgbox.com/92/91/0KdzjF2I_o.png" alt="dfb8407ae4c3d9b61a9f13f580f46a50.png"> 
 <img src="https://images2.imgbox.com/7a/52/NwHrHq5N_o.png" alt="99caa228f6ea37869265ced531de8edf.png"> 
 <p>从上面代码和测试结果我们发现thenRun和thenRunAsync区别在于，使用thenRun方法时子任务与父任务使用的是同一个线程，而thenRunAsync在子任务中可能是另起一个线程执行任务，并且thenRunAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。</p> 
 <h4><a href="" rel="nofollow">4.whenComplete和whenCompleteAsync</a></h4> 
 <p>whenComplete是当某个任务执行完成后执行的回调方法，会将执行结果或者执行期间抛出的异常传递给回调方法，如果是正常执行则异常为null，回调方法对应的CompletableFuture的result和该任务一致，如果该任务正常执行，则get方法返回执行结果，如果是执行异常，则get方法抛出异常。</p> 
 <p>测试代码：</p> 
 <pre class="has"><code class="language-go">public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            int a = 1/0;
            return 1;
        });

        CompletableFuture&lt;Integer&gt; cf2 = cf1.whenComplete((result, e) -&gt; {
            System.out.println("上个任务结果：" + result);
            System.out.println("上个任务抛出异常：" + e);
            System.out.println(Thread.currentThread() + " cf2 do something....");
        });

//        //等待任务1执行完成
//        System.out.println("cf1结果-&gt;" + cf1.get());
//        //等待任务2执行完成
        System.out.println("cf2结果-&gt;" + cf2.get());
    }</code></pre> 
 <p>测试结果：</p> 
 <img src="https://images2.imgbox.com/52/02/50PEScDc_o.png" alt="f6459c2e07bb37e3be1ad589ffe12ea1.png"> 
 <p>whenCompleteAsync和whenComplete区别也是whenCompleteAsync可能会另起一个线程执行任务，并且thenRunAsync可以自定义线程池，默认的使用ForkJoinPool.commonPool()线程池。</p> 
 <h4><a href="" rel="nofollow">5.handle和handleAsync</a></h4> 
 <p>跟whenComplete基本一致，区别在于handle的回调方法有返回值。</p> 
 <p>测试代码：</p> 
 <pre class="has"><code class="language-go">public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            // int a = 1/0;
            return 1;
        });

        CompletableFuture&lt;Integer&gt; cf2 = cf1.handle((result, e) -&gt; {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            System.out.println("上个任务结果：" + result);
            System.out.println("上个任务抛出异常：" + e);
            return result+2;
        });

        //等待任务2执行完成
        System.out.println("cf2结果-&gt;" + cf2.get());
}</code></pre> 
 <p>测试结果 ：</p> 
 <img src="https://images2.imgbox.com/f7/51/zpbaRubI_o.png" alt="2e5cb8424571e6cf0eb424358f58d5f3.png"> 
 <blockquote> 
  <p>基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能</p> 
  <ul><li><p>项目地址：https://github.com/YunaiV/yudao-cloud</p></li><li><p>视频教程：https://doc.iocoder.cn/video/</p></li></ul> 
 </blockquote> 
 <h3><a href="" rel="nofollow">三、多任务组合处理</a></h3> 
 <h4><a href="" rel="nofollow">1. thenCombine、thenAcceptBoth 和runAfterBoth</a></h4> 
 <p>这三个方法都是将两个CompletableFuture组合起来处理，只有两个任务都正常完成时，才进行下阶段任务。</p> 
 <p>区别：thenCombine会将两个任务的执行结果作为所提供函数的参数，且该方法有返回值；thenAcceptBoth同样将两个任务的执行结果作为方法入参，但是无返回值；runAfterBoth没有入参，也没有返回值。注意两个任务中只要有一个执行异常，则将该异常信息作为指定任务的执行结果。</p> 
 <p>测试代码：</p> 
 <pre class="has"><code class="language-go">public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });

        CompletableFuture&lt;Integer&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            return 2;
        });

        CompletableFuture&lt;Integer&gt; cf3 = cf1.thenCombine(cf2, (a, b) -&gt; {
            System.out.println(Thread.currentThread() + " cf3 do something....");
            return a + b;
        });

        System.out.println("cf3结果-&gt;" + cf3.get());
}

 public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });

        CompletableFuture&lt;Integer&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            return 2;
        });
        
        CompletableFuture&lt;Void&gt; cf3 = cf1.thenAcceptBoth(cf2, (a, b) -&gt; {
            System.out.println(Thread.currentThread() + " cf3 do something....");
            System.out.println(a + b);
        });

        System.out.println("cf3结果-&gt;" + cf3.get());
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf1 do something....");
            return 1;
        });

        CompletableFuture&lt;Integer&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread() + " cf2 do something....");
            return 2;
        });

        CompletableFuture&lt;Void&gt; cf3 = cf1.runAfterBoth(cf2, () -&gt; {
            System.out.println(Thread.currentThread() + " cf3 do something....");
        });

        System.out.println("cf3结果-&gt;" + cf3.get());
}</code></pre> 
 <p>测试结果：</p> 
 <img src="https://images2.imgbox.com/89/18/zJBujRhW_o.png" alt="d9f2ab9510c1e9c1c29e530668408010.png"> 
 <img src="https://images2.imgbox.com/f4/97/FofcrDf9_o.png" alt="4a98b2f2e718181bb64496ac14ede6c6.png"> 
 <p><img src="https://images2.imgbox.com/eb/77/EnJVsB0j_o.png" alt="6416f9dd0a80fe17c57687a7ff599d30.png"> 2.applyToEither、acceptEither和runAfterEither</p> 
 <p>这三个方法和上面一样也是将两个CompletableFuture组合起来处理，当有一个任务正常完成时，就会进行下阶段任务。</p> 
 <p>区别：applyToEither会将已经完成任务的执行结果作为所提供函数的参数，且该方法有返回值；acceptEither同样将已经完成任务的执行结果作为方法入参，但是无返回值；runAfterEither没有入参，也没有返回值。</p> 
 <p>测试代码：</p> 
 <pre class="has"><code class="language-go">public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "cf1 任务完成";
        });

        CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "cf2 任务完成";
        });

        CompletableFuture&lt;String&gt; cf3 = cf1.applyToEither(cf2, (result) -&gt; {
            System.out.println("接收到" + result);
            System.out.println(Thread.currentThread() + " cf3 do something....");
            return "cf3 任务完成";
        });

        System.out.println("cf3结果-&gt;" + cf3.get());
}


public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "cf1 任务完成";
        });

        CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "cf2 任务完成";
        });

        CompletableFuture&lt;Void&gt; cf3 = cf1.acceptEither(cf2, (result) -&gt; {
            System.out.println("接收到" + result);
            System.out.println(Thread.currentThread() + " cf3 do something....");
        });

        System.out.println("cf3结果-&gt;" + cf3.get());
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf1 任务完成");
            return "cf1 任务完成";
        });

        CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf2 任务完成");
            return "cf2 任务完成";
        });

        CompletableFuture&lt;Void&gt; cf3 = cf1.runAfterEither(cf2, () -&gt; {
            System.out.println(Thread.currentThread() + " cf3 do something....");
            System.out.println("cf3 任务完成");
        });

        System.out.println("cf3结果-&gt;" + cf3.get());
}</code></pre> 
 <p>测试结果：</p> 
 <img src="https://images2.imgbox.com/2c/9d/mPfAAvYK_o.png" alt="1cbc9656b05f0d0e8b68b6ca8d871e59.png"> 
 <img src="https://images2.imgbox.com/31/81/c9jtul3r_o.png" alt="981c9338b8c83ed91fad408dfdcaf80e.png"> 
 <p>从上面可以看出cf1任务完成需要2秒，cf2任务完成需要5秒，使用applyToEither组合两个任务时，只要有其中一个任务完成时，就会执行cf3任务，显然cf1任务先完成了并且将自己任务的结果传值给了cf3任务，cf3任务中打印了接收到cf1任务完成，接着完成自己的任务，并返回cf3任务完成；acceptEither和runAfterEither类似，acceptEither会将cf1任务的结果作为cf3任务的入参，但cf3任务完成时并无返回值；runAfterEither不会将cf1任务的结果作为cf3任务的入参，它是没有任务入参，执行完自己的任务后也并无返回值。</p> 
 <h4><a href="" rel="nofollow">2. allOf / anyOf</a></h4> 
 <p>allOf：CompletableFuture是多个任务都执行完成后才会执行，只有有一个任务执行异常，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回null。</p> 
 <p>anyOf ：CompletableFuture是多个任务只要有一个任务执行完成，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回执行完成任务的结果。</p> 
 <p>测试代码：</p> 
 <pre class="has"><code class="language-go">public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf1 任务完成");
            return "cf1 任务完成";
        });

        CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                int a = 1/0;
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf2 任务完成");
            return "cf2 任务完成";
        });

        CompletableFuture&lt;String&gt; cf3 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf3 任务完成");
            return "cf3 任务完成";
        });

        CompletableFuture&lt;Void&gt; cfAll = CompletableFuture.allOf(cf1, cf2, cf3);
        System.out.println("cfAll结果-&gt;" + cfAll.get());
}


public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf1 任务完成");
            return "cf1 任务完成";
        });

        CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf2 任务完成");
            return "cf2 任务完成";
        });

        CompletableFuture&lt;String&gt; cf3 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println(Thread.currentThread() + " cf2 do something....");
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("cf3 任务完成");
            return "cf3 任务完成";
        });

        CompletableFuture&lt;Object&gt; cfAll = CompletableFuture.anyOf(cf1, cf2, cf3);
        System.out.println("cfAll结果-&gt;" + cfAll.get());
}</code></pre> 
 <p>测试结果：</p> 
 <img src="https://images2.imgbox.com/c7/df/s3x9TDEz_o.png" alt="5898e86741eed077d4eed6e55a2cb67e.png"> 
 <img src="https://images2.imgbox.com/fe/8a/DPLKtVz7_o.png" alt="d16e5bcf603ccb06d26ea802eb11298f.png"> 
 <hr> 
 <hr> 
 <p>欢迎加入我的知识星球，一起探讨架构，交流源码。加入方式，<strong>长按下方二维码噢</strong>：<br></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/b1/90/nOD0Jz19_o.png" alt="761f4b1d7d13a0ea7629dcebb478056e.png"></p> 
 <p style="text-align:left;">已在知识星球更新源码解析如下：<br></p> 
 <p style="text-align:center;"><a href="" rel="nofollow"><img src="https://images2.imgbox.com/7a/ef/2sE1asLR_o.jpg" alt="5e7371a73bb2afb5dd005b16635d6d1d.jpeg"></a></p> 
 <p style="text-align:center;"><a href="" rel="nofollow"><img src="https://images2.imgbox.com/24/be/QeplMfCt_o.jpg" alt="49253b9d6f4137d30a4137aa2ea58024.jpeg"></a></p> 
 <p style="text-align:center;"><a href="" rel="nofollow"><img src="https://images2.imgbox.com/95/0c/D59mDp7s_o.jpg" alt="1956d5935fcf57b8bf80a3e38351b900.jpeg"></a></p> 
 <p style="text-align:center;"><a href="" rel="nofollow"><img src="https://images2.imgbox.com/ab/a3/rQBieyLx_o.jpg" alt="420c0680846028c06a5df40025194731.jpeg"></a></p> 
 <p>最近更新《芋道 SpringBoot 2.X 入门》系列，已经 101 余篇，覆盖了 MyBatis、Redis、MongoDB、ES、分库分表、读写分离、SpringMVC、Webflux、权限、WebSocket、Dubbo、RabbitMQ、RocketMQ、Kafka、性能测试等等内容。<br></p> 
 <p>提供近 3W 行代码的 SpringBoot 示例，以及超 6W 行代码的电商微服务项目。</p> 
 <p>获取方式：点“<strong>在看</strong>”，关注公众号并回复 <strong>666</strong> 领取，更多内容陆续奉上。</p> 
 <pre class="has"><code class="language-go">文章有帮助的话，在看，转发吧。
谢谢支持哟 (*^__^*）</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d32912109630b6f863571c1a6f7e75ca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[免费专栏] 车联网基础理论之车联网安全车端知识科普</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a82562a8467c2c5d44955484d1a75437/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">快手在线查询权重网站源码&#43;接口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>