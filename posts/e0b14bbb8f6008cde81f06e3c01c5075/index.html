<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>多服务器之间Session共享 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="多服务器之间Session共享" />
<meta property="og:description" content="原理：多个服务器间想共享session，就相当于共享取多台主机上的一个变量，所以共享的思路就是让大家都能读取变量，实现的方法可以通过将session保存到专门的一个服务器上，所有服务器都去请求数据，也memcache实现session共享 将这些服务器都配置成使用同一组Memcached服务器就可以， 一、提出问题： 为了满足足够大的应用，满足更多的客户，于是我们架设了N台Web服务器（N&gt;=2），在多台Web服务器的情况下，我们会涉及到一个问题：用户登陆一台服务器以后，如果在跨越到另一台服务器的时候能够继续使用客户的Session？ 二、解决方案： 1. 写客户端Cookie的方式 当用户登陆成功以后，把网站域名、用户名、密码、token、 session有效时间全部采用cookie的形式写入到客户端的cookie里面，如果用户从一台Web服务器跨越到另一台服务器的时候，我们的程序主动去检测客户端的cookie信息，进行判断，然后提供对应的服务，当然，如果cookie过期，或者无效，自然就不让用户继续服务了。当然，这种方法的弊端就不言而喻了，比如客户端禁用了cookie或者cookie被黑客窃取了呢？这些都可以解决，目前淘宝session框架就是基于client cookie做开发，不见得他们就出了很大的问题？也许是最可行的方式，可以配合memcached来实现。 2. 服务器之间Session数据同步的方式 假设Web服务器A是所有用户登陆的服务器，那么当用户验证登陆一下，session数据就会写到A服务器里，那么就可以自己写脚本或者守护进程来自动把session数据同步到其他Web服务器，那么当用户跳转到其他服务器的时候，那么session数据是一致的，自然就能够直接进行服务无须再次登陆了。缺点是，可能会速度慢，不稳定，如果是单向同步的话，登陆服务器出现问题，那么其他服务器也无法服务，当然也可以考虑双向同步的问题。这个方案都可以解决，目前zookeeper可以实现。 3. 利用NFS共享Session数据的方式 其实这个方案和下面的Mysql方案类似，只是存储方式不一 样。大致就是有一台公共的NFS服务器（Network File Server）做共享服务器，所有的Web服务器登陆的时候把session数据写到这台服务器上，那么所有的session数据其实都是保存在这台 NFS服务器上的，不论用户访问哪台Web服务器，都要来这台服务器获取session数据，那么就能够实现共享session数据了。缺点是依赖性太强，如果NFS服务器down掉了，那么大家都无法工作了，当然，可以考虑多台NFS服务器同步的形式。这个方案都可以解决，目前zookeeper可以实现，当然memcached也可以实现session共享。 4. 利用Mysql数据库共享Session数据的方式 这个方式与NFS的方式类似，也是采用一台Mysql服务器做共享服务器，把所有的session的数据保存到Mysql服务器上，所有Web服务器都来这台Mysql服务器来获取Session 数据。缺点也是依赖性太强，Mysql无法工作了影响所有的Web服务器，当然，可以考虑多太Mysql数据库来共享session，使用同步Mysql 数据的方式。这种方式跟方式3类似，同样可以采用memcached来做，nosql也可以实现，这些都不是问题。 5. 使用硬件设备 这个算是比较成熟的解决方案了，使用类似BIG-IP的负载设备来实现资源共享，那么就能够又稳定又合理的的共享Session了。目前很多门户网站采用这种方式。缺点很明显了，就是要收费了，硬件设备肯定需要购买成本的，不过对于专业或者大型应用来讲，是比较合理并且值得的，这种方式可以放到最后面考虑。 使用Memcached实现Session共享 由于Cookie是保存的用户客户端的，安全性存在问题，为保证用户数据的安全性，我们必须使用Session机制来保存用户登录后的一些信息。 如果我们使用LVS对Apache实现负载均衡，就无法保证用户每次都能被分配到同一台Apache Server上，以取到自己的Session，虽然LVS可以加-p参数来保证客户端每次都被分配到同一台Apache Server上，但这种方式存在一些弊端，比如必须设置一个保持时间，如果时间太长了，LVS就需要缓存大量信息，时间太短了，又不能保证用户每次被分配到同一台Server上，而且这种方式也不易实现Session的冗余备份。 因此，我们需要Session共享，也就是说每台Apache都可以访问到所有的Session，这样用户被分配到哪台Server就不重要了。 Session共享主要有多种实现方式：  Session复制。Apache可以实现把Session同步到其他Server上去，但这种技术太复杂，而且影响性能，占用内存，所以不推荐使用。  Session集中存储。存储介质可以是NFS文件系统、数据库、Memcached，从性能上考虑，当然是Memcached最好，推荐使用。 1.3 实现 1.3.1 安装Memcached Memcached是基于libevent实现的，所以要首先确保已经安装libevent。 安装libevent tar zxvf libevent-1.4.13-stable.tar.gz cd libevent-1.4.13-stable ./configure --prefix=/usr make &amp;&amp; make install 安装Memcached tar zxvf memcached-1.4.4.tar.gz cd memcached-1.4.4 ./configure --prefix=/usr/local/memcached --with-libevent=/usr make &amp;&amp; make install 启动Memcached /usr/local/memcached/bin/memcached -d -m 10 -u root -l 192." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e0b14bbb8f6008cde81f06e3c01c5075/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-31T22:03:00+08:00" />
<meta property="article:modified_time" content="2015-05-31T22:03:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">多服务器之间Session共享</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div>
   原理：多个服务器间想共享session，就相当于共享取多台主机上的一个变量，所以共享的思路就是让大家都能读取变量，实现的方法可以通过将session保存到专门的一个服务器上，所有服务器都去请求数据，也memcache实现session共享 
  <span style="color:#ff0000;">将这些服务器都配置成使用同一组Memcached服务器就可以</span>， 
 </div> 
 <div>
     
 </div> 
 <div> 
  <div>
    一、提出问题： 
  </div> 
  <div>
      
  </div> 
  <div>
    为了满足足够大的应用，满足更多的客户，于是我们架设了N台Web服务器（N&gt;=2），在多台Web服务器的情况下，我们会涉及到一个问题：用户登陆一台服务器以后，如果在跨越到另一台服务器的时候能够继续使用客户的Session？ 
  </div> 
  <div>
      
  </div> 
  <div>
    二、解决方案： 
  </div> 
  <div>
      
  </div> 
  <div>
    1. 写客户端Cookie的方式 
  </div> 
  <div>
           当用户登陆成功以后，把网站域名、用户名、密码、token、 session有效时间全部采用cookie的形式写入到客户端的cookie里面，如果用户从一台Web服务器跨越到另一台服务器的时候，我们的程序主动去检测客户端的cookie信息，进行判断，然后提供对应的服务，当然，如果cookie过期，或者无效，自然就不让用户继续服务了。当然，这种方法的弊端就不言而喻了，比如客户端禁用了cookie或者cookie被黑客窃取了呢？这些都可以解决，目前淘宝session框架就是基于client cookie做开发，不见得他们就出了很大的问题？也许是最可行的方式，可以配合memcached来实现。 
  </div> 
  <div>
      
  </div> 
  <div>
    2. 服务器之间Session数据同步的方式 
  </div> 
  <div>
           假设Web服务器A是所有用户登陆的服务器，那么当用户验证登陆一下，session数据就会写到A服务器里，那么就可以自己写脚本或者守护进程来自动把session数据同步到其他Web服务器，那么当用户跳转到其他服务器的时候，那么session数据是一致的，自然就能够直接进行服务无须再次登陆了。缺点是，可能会速度慢，不稳定，如果是单向同步的话，登陆服务器出现问题，那么其他服务器也无法服务，当然也可以考虑双向同步的问题。这个方案都可以解决，目前zookeeper可以实现。 
  </div> 
  <div>
      
  </div> 
  <div>
    3. 利用NFS共享Session数据的方式 
  </div> 
  <div>
           其实这个方案和下面的Mysql方案类似，只是存储方式不一 样。大致就是有一台公共的NFS服务器（Network File Server）做共享服务器，所有的Web服务器登陆的时候把session数据写到这台服务器上，那么所有的session数据其实都是保存在这台 NFS服务器上的，不论用户访问哪台Web服务器，都要来这台服务器获取session数据，那么就能够实现共享session数据了。缺点是依赖性太强，如果NFS服务器down掉了，那么大家都无法工作了，当然，可以考虑多台NFS服务器同步的形式。这个方案都可以解决，目前zookeeper可以实现，当然memcached也可以实现session共享。 
  </div> 
  <div>
      
  </div> 
  <div>
    4. 利用Mysql数据库共享Session数据的方式 
  </div> 
  <div>
           这个方式与NFS的方式类似，也是采用一台Mysql服务器做共享服务器，把所有的session的数据保存到Mysql服务器上，所有Web服务器都来这台Mysql服务器来获取Session 数据。缺点也是依赖性太强，Mysql无法工作了影响所有的Web服务器，当然，可以考虑多太Mysql数据库来共享session，使用同步Mysql 数据的方式。这种方式跟方式3类似，同样可以采用memcached来做，nosql也可以实现，这些都不是问题。 
  </div> 
  <div>
      
  </div> 
  <div>
    5. 使用硬件设备 
  </div> 
  <div>
           这个算是比较成熟的解决方案了，使用类似BIG-IP的负载设备来实现资源共享，那么就能够又稳定又合理的的共享Session了。目前很多门户网站采用这种方式。缺点很明显了，就是要收费了，硬件设备肯定需要购买成本的，不过对于专业或者大型应用来讲，是比较合理并且值得的，这种方式可以放到最后面考虑。 
  </div> 
  <div>
      
  </div> 
  <div>
      
  </div> 
  <div> 
   <h4>使用Memcached实现Session共享</h4> 由于Cookie是保存的用户客户端的，安全性存在问题，为保证用户数据的安全性，我们必须使用Session机制来保存用户登录后的一些信息。  
   <br>如果我们使用LVS对Apache实现负载均衡，就无法保证用户每次都能被分配到同一台Apache Server上，以取到自己的Session，虽然LVS可以加-p参数来保证客户端每次都被分配到同一台Apache Server上，但这种方式存在一些弊端，比如必须设置一个保持时间，如果时间太长了，LVS就需要缓存大量信息，时间太短了，又不能保证用户每次被分配到同一台Server上，而且这种方式也不易实现Session的冗余备份。  
   <br>因此，我们需要Session共享，也就是说每台Apache都可以访问到所有的Session，这样用户被分配到哪台Server就不重要了。  
   <br>Session共享主要有多种实现方式：  
   <br> Session复制。Apache可以实现把Session同步到其他Server上去，但这种技术太复杂，而且影响性能，占用内存，所以不推荐使用。  
   <br> Session集中存储。存储介质可以是NFS文件系统、数据库、Memcached，从性能上考虑，当然是Memcached最好，推荐使用。 
   <br>1.3 实现  
   <br>1.3.1 安装Memcached  
   <br>Memcached是基于libevent实现的，所以要首先确保已经安装libevent。  
   <br>安装libevent  
   <br>tar zxvf libevent-1.4.13-stable.tar.gz  
   <br>cd libevent-1.4.13-stable  
   <br>./configure --prefix=/usr  
   <br>make &amp;&amp; make install  
   <br>安装Memcached  
   <br>tar zxvf memcached-1.4.4.tar.gz  
   <br>cd memcached-1.4.4  
   <br>./configure --prefix=/usr/local/memcached --with-libevent=/usr  
   <br>make &amp;&amp; make install  
   <br>启动Memcached  
   <br> 
   <br>/usr/local/memcached/bin/memcached -d -m 10 -u root -l 192.168.0.9 -p 11211 -c 256 -P /tmp/memcached.pid  
   <br>1.3.2 安装PHP扩展pecl::memcache  
   <br>pecl install memcache  
   <br>或源码安装  
   <br>tar zxvf memcache-2.2.5.tgz  
   <br>cd memcache-2.2.5  
   <br>phpize  
   <br>./configure  
   <br>make &amp;&amp; make install  
   <br> 
   <br>将 php.ini 中 extension=memcache.so 打开，重启一下 apache，查看 phpinfo 中的 "Registered save handlers" 会有"files user memcache" 这3个可用。  
   <br> 
   <br>另外，基于libmemached的php扩展在pecl发布了，叫pecl::memcached，性能上可能会更好。  
   <br>1.3.3 配置Memcached保存Session  
   <br>修改配置文件，在 php.ini 中全局设置  
   <br>session.save_handler = memcache  
   <br>session.save_path = " 
   <a href="http://192.168.0.9/" rel="nofollow">tcp://192.168.0.9</a>:11211"  
   <br>或者某个目录下的 .htaccess ：  
   <br>php_value session.save_handler "memcache"  
   <br>php_value session.save_path " 
   <a href="http://192.168.0.9/" rel="nofollow">tcp://192.168.0.9</a>:11211"  
   <br>再或者在某个一个应用中：  
   <br>ini_set("session.save_handler", "memcache");  
   <br>ini_set("session.save_path", " 
   <a href="http://192.168.0.9/" rel="nofollow">tcp://192.168.0.9</a>:11211");  
   <br>使用多个 memcached server 时用逗号","隔开，并且和 Memcache::addServer() 文档中说明的一样，可以带额外的参数"persistent"、"weight"、"timeout"、"retry_interval" 等等，类似这样的：" 
   <a href="http://host1/" rel="nofollow">tcp://host1</a>:port1?persistent=1&amp;weight=2, 
   <a href="http://host2/" rel="nofollow">tcp://host2</a>:port2" 。  
   <br>1.3.4 测试  
   <br>&lt;?php  
   <br>session_start();  
   <br>if (!isset($_SESSION['TEST'])) {  
   <br>$_SESSION['TEST'] = time();  
   <br>}  
   <br>$_SESSION['TEST3'] = time();  
   <br>print $_SESSION['TEST'];  
   <br>print "&lt;br&gt;&lt;br&gt;";  
   <br>print $_SESSION['TEST3'];  
   <br>print "&lt;br&gt;&lt;br&gt;";  
   <br>print session_id();  
   <br>?&gt;  
   <br> 
   <br>可以直接用sessionid 去 memcached 里查询一下：  
   <br>telnet 192.168.0.9 11211  
   <br>get 19216821213c65cedec65b0883238c278eeb573e077  
   <br>得到  
   <br>TEST|i:1177556731;TEST3|i:1177556881;  
   <br>这样的结果，说明session 正常工作  
   <br> 
   <br>用Memcached来存储 session 在读写速度上会比文件快很多，而且在多个服务器需要共用session时会比较方便， 
   <span style="color:#ff0000;">将这些服务器都配置成使用同一组Memcached服务器就可以</span>，减少了额外的工作量。缺点是 session 数据都保存在 memory 中，持久化方面有所欠缺，但对 session 数据来说也不是很大的问题，如果要持久化数据，也可以使用新浪开发的MemcacheDB或日本人开发的Tokyo tyrant+Tokyo Cabinet。  
   <br>另外，如何解决Memcached的单点故障问题，有以下几个方案：  
   <br> 使用上面提到的Memcache::addServer增加多台Memcached，但这样只能达到一台出故障之后，另外一台可以使用，但每台Memcached的数据是独立的，不共享，不复制，出故障的数据丢失了。  
   <br> 使用Memcached的一个补丁应用repcached，可以实现multi master replication和asynchronous data repliacation，并且支持原来Memcached的所有命令。不过这个应用只支持Memcached1.2.x版本。  
   <br> 使用Tokyo tyrant+Tokyo Cabinet（简称TT+TC）。TT兼容Memcached协议，可以直接替换使用，TT支持replication，可以实现故障转移，TC则为TT提供持久化。  
   <br>TT+TC是日本最大的社交类网站 
   <a href="http://mixi.jp/" rel="nofollow">http://mixi.jp</a>开发的开源应用，并已成功应用在mixi.jp中，值得研究。 
  </div> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/xyxxs/p/4542791.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b3045abd8e8a5cb0b955a518dc605f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">iOS常量、变量、属性及其特性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e522cebc943e6ec80039f03ab98f69c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML5，不只是看上去很美（第二弹：打造最美3D机房）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>