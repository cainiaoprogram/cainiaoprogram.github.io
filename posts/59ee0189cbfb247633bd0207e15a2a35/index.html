<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python自然语言处理实战核心技术与算法——双向最大匹配法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python自然语言处理实战核心技术与算法——双向最大匹配法" />
<meta property="og:description" content="本人初学nlp，使用的是机械工业出版社的《python自然语言处理实战核心技术与算法》，学习到了双向最大匹配法，于是写下这篇文章记录一下整个代码的工作原理以及相应的理解。
目录 一、匹配切分二、算法代码及详谈1. 正向最大匹配法2. 逆向最大匹配法3.双向最大匹配法 三、总体代码与结果四、改进方式五、参考 一、匹配切分 在中文分词技术中的匹配切分输入规则分词方式，这是一种机械分词的方式，我们通过机器词典中的单词与语句中的每个词语进行匹配，如果匹配成功则切分，如果匹配失败则不与切分。
在匹配切分中，原则是“长词优先”，那么为什么是长词优先？这是因为在nlp中最需要考虑的几个问题是：速度与精度。以下是我的个人理解（主要是真的没查到相关的内容）：
大家仔细想一想，我们对一段话进行分词，是不是需要一直循环这段话与机器词典中的单词进行匹配操作，那么循环是不是一个很浪费性能的工作？如果我们一个字一个字的匹配，那么就等于这段话有多少个字，我们要循环多少次，更重要的是，我们是分词，不是分字，分字的话那么我们究竟是做新华字典还是做nlp对吧？所以我们通过长词优先，假设最长的词是4个字的成语，每一次循环就可能清理掉4个字，这样是不是有可能很大程度节约了性能？当然，最差的情况必定还是一个词都分不出来，这样的话理论上会比从小开始更消耗性能（因为算法中会依次减少匹配的字符数，具体的时候在代码中讨论），但是我们做中文分词，肯定不至于这句话中一个词语都没有在各个数据集中出现过对吧，所以长词优先可以增加相应的运行速度。
匹配切分中分为正向最大匹配法（Maximum Match Method，aka MM），逆向最大匹配法（Reverse Maximum Match Method，aka RMM），双向最大匹配法（Bi-directction Matching Method）
虽然本文讨论的是python实现双向最大匹配法，这种算法也运用了MM和RMM，所以下面就一起进行讨论。
二、算法代码及详谈 代码我引用的《python自然语言处理实战核心技术与算法》中的例子，词典为：
self.dic = [&#39;研究&#39;, &#39;研究生&#39;, &#39;生命&#39;, &#39;命&#39;, &#39;的&#39;, &#39;起源&#39;] 那么由此可见机器词典最长词条字符数（窗口值）为3：
self.window_size = 3 这里是直接设定的机器词典最长词条字符数，但是我个人觉得在实际工程中，应该有个方法来判断机器词典中的最长词条字符数。比如使用len(max(list, key = len))这样的方法取。
文本为：
text = &#39;研究生命的起源&#39; 1. 正向最大匹配法 这里先上代码，注释写得比较完善，具体的算法思想等都写在代码中了：
def MM_cut(self): &#34;&#34;&#34; 正向最大匹配法的方法 算法思想: 1. 从左向右取待切分汉语句的m个字符作为匹配字符, m为机器词典中最长词条的字符数 2. 查找机器词典并进行匹配，若匹配成功, 则将这个匹配字段作为一个词切分出来。 若匹配不成功, 则将这个匹配字段的最后一个字去掉, 剩下的字符串作为新的匹配字段, 进行再次匹配, 重复以上过程, 直到切分出所有词为止。 :return MM_result: 正向最大匹配法匹配结果 &#34;&#34;&#34; MM_result = [] MM_index = 0 MM_text_length = len(self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/59ee0189cbfb247633bd0207e15a2a35/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-07T10:38:01+08:00" />
<meta property="article:modified_time" content="2020-07-07T10:38:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python自然语言处理实战核心技术与算法——双向最大匹配法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>本人初学nlp，使用的是机械工业出版社的《python自然语言处理实战核心技术与算法》，学习到了双向最大匹配法，于是写下这篇文章记录一下整个代码的工作原理以及相应的理解。</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">一、匹配切分</a></li><li><a href="#_13" rel="nofollow">二、算法代码及详谈</a></li><li><ul><li><a href="#1__32" rel="nofollow">1. 正向最大匹配法</a></li><li><a href="#2__96" rel="nofollow">2. 逆向最大匹配法</a></li><li><a href="#3_151" rel="nofollow">3.双向最大匹配法</a></li></ul> 
  </li><li><a href="#_208" rel="nofollow">三、总体代码与结果</a></li><li><a href="#_367" rel="nofollow">四、改进方式</a></li><li><a href="#_385" rel="nofollow">五、参考</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>一、匹配切分</h2> 
<p>在中文分词技术中的匹配切分输入规则分词方式，这是一种机械分词的方式，我们通过机器词典中的单词与语句中的每个词语进行匹配，如果匹配成功则切分，如果匹配失败则不与切分。</p> 
<p>在匹配切分中，原则是“<strong>长词优先</strong>”，那么为什么是长词优先？这是因为在nlp中最需要考虑的几个问题是：<strong>速度</strong>与<strong>精度</strong>。以下是我的个人理解（主要是真的没查到相关的内容）：</p> 
<p>大家仔细想一想，我们对一段话进行分词，是不是需要一直循环这段话与机器词典中的单词进行匹配操作，那么循环是不是一个很浪费性能的工作？如果我们一个字一个字的匹配，那么就等于这段话有多少个字，我们要循环多少次，更重要的是，我们是分词，不是分字，分字的话那么我们究竟是做新华字典还是做nlp对吧？所以我们通过长词优先，假设最长的词是4个字的成语，每一次循环就可能清理掉4个字，这样是不是有可能很大程度节约了性能？当然，最差的情况必定还是一个词都分不出来，这样的话理论上会比从小开始更消耗性能（因为算法中会依次减少匹配的字符数，具体的时候在代码中讨论），但是我们做中文分词，肯定不至于这句话中一个词语都没有在各个数据集中出现过对吧，所以长词优先可以增加相应的运行速度。</p> 
<p>匹配切分中分为<strong>正向最大匹配法</strong>（Maximum Match Method，aka MM），<strong>逆向最大匹配法</strong>（Reverse Maximum Match Method，aka RMM），<strong>双向最大匹配法</strong>（Bi-directction Matching Method）</p> 
<p>虽然本文讨论的是python实现双向最大匹配法，这种算法也运用了MM和RMM，所以下面就一起进行讨论。</p> 
<h2><a id="_13"></a>二、算法代码及详谈</h2> 
<p>代码我引用的《python自然语言处理实战核心技术与算法》中的例子，词典为：</p> 
<pre><code class="prism language-python">self<span class="token punctuation">.</span>dic <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'研究'</span><span class="token punctuation">,</span> <span class="token string">'研究生'</span><span class="token punctuation">,</span> <span class="token string">'生命'</span><span class="token punctuation">,</span> <span class="token string">'命'</span><span class="token punctuation">,</span> <span class="token string">'的'</span><span class="token punctuation">,</span> <span class="token string">'起源'</span><span class="token punctuation">]</span>
</code></pre> 
<p>那么由此可见机器词典最长词条字符数（窗口值）为3：</p> 
<pre><code class="prism language-python">self<span class="token punctuation">.</span>window_size <span class="token operator">=</span> <span class="token number">3</span>
</code></pre> 
<p>这里是直接设定的机器词典最长词条字符数，但是我个人觉得在实际工程中，应该有个方法来判断机器词典中的最长词条字符数。比如使用len(max(list, key = len))这样的方法取。</p> 
<p>文本为：</p> 
<pre><code class="prism language-python">text <span class="token operator">=</span> <span class="token string">'研究生命的起源'</span>
</code></pre> 
<h3><a id="1__32"></a>1. 正向最大匹配法</h3> 
<p>这里先上代码，注释写得比较完善，具体的算法思想等都写在代码中了：</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">MM_cut</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        正向最大匹配法的方法

        算法思想:
        1. 从左向右取待切分汉语句的m个字符作为匹配字符, m为机器词典中最长词条的字符数
        2. 查找机器词典并进行匹配，若匹配成功, 则将这个匹配字段作为一个词切分出来。
           若匹配不成功, 则将这个匹配字段的最后一个字去掉, 剩下的字符串作为新的匹配字段,
           进行再次匹配, 重复以上过程, 直到切分出所有词为止。

        :return MM_result: 正向最大匹配法匹配结果
        """</span>

        MM_result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        MM_index <span class="token operator">=</span> <span class="token number">0</span>
        MM_text_length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
        MM_piece <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token keyword">while</span> MM_index <span class="token operator">&lt;</span> MM_text_length<span class="token punctuation">:</span>
            <span class="token comment"># MM的循环</span>
            <span class="token keyword">for</span> size <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>window_size <span class="token operator">+</span> MM_index<span class="token punctuation">,</span> MM_index<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 每一轮循环从新的字符串的"索引位置(起始位置) + 机器词典中最长的词条字符数"位置开始匹配字符</span>
                <span class="token comment"># 如果这一轮循环匹配失败，则将要匹配的字符数进行-1操作，进行新一轮的匹配</span>
                <span class="token comment"># 最后一轮匹配为一个字符匹配</span>
                MM_piece <span class="token operator">=</span> self<span class="token punctuation">.</span>text<span class="token punctuation">[</span>MM_index<span class="token punctuation">:</span> size<span class="token punctuation">]</span>
                <span class="token keyword">if</span> MM_piece <span class="token keyword">in</span> self<span class="token punctuation">.</span>dic<span class="token punctuation">:</span>
                    <span class="token comment"># 如果这串字符在机器词典中，那么移动索引至匹配了的字符串的最后一个字符的下标处(将匹配了的字符串移出这个线性表)</span>
                    MM_index <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>
                    <span class="token keyword">break</span>

            <span class="token comment"># 将索引移动到下一轮匹配的开始字符位置，即如果匹配成功，将之前成功匹配的字符移除线性表</span>
            <span class="token comment"># 如果匹配失败，则是将第一个字符移除线性表</span>
            MM_index <span class="token operator">+=</span> <span class="token number">1</span>
            MM_result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>MM_piece<span class="token punctuation">)</span>

        <span class="token keyword">return</span> MM_result
</code></pre> 
<p>我这里使用一张图进行算法第一轮循环的讲解，这样也方便初学者进行理解以及之后的循环推演。</p> 
<p>第一轮循环肯定是满足初始下标小于文本长度的，如果等于的话我怀疑这个丢个空字符串的人脑壳被门夹了。所以可以先直接看for循环。</p> 
<p>for循环是从range(self.window_size + MM_index, MM_index, -1)中获取一个size（大小），我们通过手动计算第一个size = 3（这里就满足了<strong>长词优先</strong>原则），再看第一片匹配的字符串的下标是[0]至[2]，于是绘出下面的图，是不是很像个线性表啊：<br> <img src="https://images2.imgbox.com/d3/92/tO7DoXav_o.png" alt="正向最大匹配法"><br> 这个size是[3, 2, 1]，如果不清楚这一步的就自己去查一下range()函数，这里不多赘述。<br> 接着在if语句中，把这3个字丢到机器词典dic中进行匹配，结果发现，芜湖，还真匹配上了，于是这个时候索引（MM_index）移动到“生”这个位置，即下图这样：<br> <img src="https://images2.imgbox.com/21/8d/kjoGD4uR_o.png" alt="匹配成功后的索引图"><br> 可能看到这里读者就会有些疑问了，为什么索引移动到的是2而不是3？这里先卖个关子，等我把如果匹配失败的情况说了再继续。</p> 
<p>现在我们假设匹配失败了，[‘研’, ‘研究’, ‘研究生’]都不在机器词典中，那么这时候for循环就第二轮，即size = 2，这时候匹配的就是’研究’两字，再接着size = 1，匹配‘研’字，但是发现都没匹配到，于是for循环结束，开始while之后的循环内容。</p> 
<p>如果匹配成功，这个时候索引会向前移动一个位置，即移动到‘命’这个地方，如果匹配失败，则移动到‘究’这个地方，这也就是为什么之前说的匹配成功后索引移动到的是size - 1的位置，就是为了增加代码复用性，方便这里移动索引。<br> <img src="https://images2.imgbox.com/51/1d/isrwYX7u_o.png" alt="匹配成功或失败后索引情况"><br> 而无论是匹配成功还是失败，相当于之前的内容已经被移除这个线性表了。</p> 
<p>最后会将匹配的内容添加至结果的列表中，这里也要分两种情况：<br> 1.如果匹配成功，则是成功的词语放至列表中。<br> 2.如果匹配失败，即词语不在机器词典中或者就不是词语，那么就是把第一个字放入结果中，就好比“我爱你”，这就不是个词语，而“我”也就可以直接放入结果中，作为一个分词结果。</p> 
<p>以上就是正向最大匹配法的内容，下面讨论逆向最大匹配法。</p> 
<h3><a id="2__96"></a>2. 逆向最大匹配法</h3> 
<p>同样，先上代码：</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">RMM_cut</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        逆向最大匹配法

        RMM的算法思想:
        1.先将文档进行倒排处理(reverse)，生成逆序文档，然后根据逆序词典，对逆序文档用正向最大匹配法处理
        2.从左向右取待切分汉语句的m个字符作为匹配字符, m为机器词典中最长词条的字符数
        3.查找机器词典并进行匹配，若匹配成功, 则将这个匹配字段作为一个词切分出来。
          若匹配不成功, 则将这个匹配字段的最后一个字去掉, 剩下的字符串作为新的匹配字段,
          进行再次匹配, 重复以上过程, 直到切分出所有词为止。

        该应用的算法思想:
        没有使用reverse处理，而是直接从后向前匹配，只是匹配的结果进行了reverse处理
        (因为匹配的结果第一个是"起源"，最后一个是"研究")

        :return RMM_result: 逆向最大匹配法匹配结果
        """</span>
        RMM_result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        RMM_index <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
        RMM_piece <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token keyword">while</span> RMM_index <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token comment"># RMM的循环</span>
            <span class="token keyword">for</span> size <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>RMM_index <span class="token operator">-</span> self<span class="token punctuation">.</span>window_size<span class="token punctuation">,</span> RMM_index<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 匹配最后的3个字符串，如果匹配就进行下一轮while循环，否则字符数-1，进行下一轮for循环</span>
                RMM_piece <span class="token operator">=</span> self<span class="token punctuation">.</span>text<span class="token punctuation">[</span>size<span class="token punctuation">:</span> RMM_index<span class="token punctuation">]</span>
                <span class="token keyword">if</span> RMM_piece <span class="token keyword">in</span> self<span class="token punctuation">.</span>dic<span class="token punctuation">:</span>
                    <span class="token comment"># 如果这串字符在机器词典中，那么移动索引至成功匹配的第一个字符的下标处(将匹配了的字符串移出这个线性表)</span>
                    RMM_index <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">1</span>
                    <span class="token keyword">break</span>

            <span class="token comment"># 将索引移动到下一轮匹配的开始字符位置，即如果匹配成功，将之前成功匹配的字符移除线性表</span>
            <span class="token comment"># 如果匹配失败，则是将最后一个字符移除线性表</span>
            RMM_index <span class="token operator">-=</span> <span class="token number">1</span>
            RMM_result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>RMM_piece<span class="token punctuation">)</span>

        RMM_result<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> RMM_result
</code></pre> 
<p>关于正向和逆向的区别为了防止许多同学没看过书，所以我这里还是copy一下：</p> 
<blockquote> 
 <p>由于汉语中偏正结构较多，若从后向前匹配，可以适当提高精确度。所以，逆向最大匹配法比正向最大匹配法的误差要小。</p> 
</blockquote> 
<p>书上写的具体的算法是先将词典和文本都逆序，再进行正向最大匹配法，而具体使用的情况是逆序来看，最后的匹配结果逆序。</p> 
<p>就我个人而言，我个人倾向于书上应用的方式，即直接从后向前匹配，最后结果再reverse，因为我是觉得如果使用第一种方式，中间你想测试下代码，然后print一下，我怀疑你会怀疑人生。</p> 
<p>具体的过程和正向的类似，这里不多赘述（主要是懒），我将图放出来，大家就可以自行举一反三了。<br> <img src="https://images2.imgbox.com/84/45/1rVwJB92_o.png" alt="逆向最大匹配法"><br> <img src="https://images2.imgbox.com/d0/c5/U7IK0vJj_o.png" alt="逆向最大匹配法成功后索引"><br> <img src="https://images2.imgbox.com/5b/79/GQrfIkdn_o.png" alt="匹配成功或失败后的索引情况"></p> 
<h3><a id="3_151"></a>3.双向最大匹配法</h3> 
<p>双向最大匹配法是建立在正向最大匹配法和逆向最大匹配法之上的，是对两者结果的比较，选出更优的那一个作为结果。<br> 书上对这个情况说明为：</p> 
<blockquote> 
 <p>据SunM.S.和Benjamin K.T. (1995)的研究表明，中文中90.0%左右的句子，正向最大匹配法和逆向最大匹配法完全重合且正确，只有大概9.0%的句子两种切分得到的结果不一样，但其中必有一个是正确的（歧义检测成功），只有不到1.0%的句子，使用正向最大匹配法和逆向最大匹配法的切分虽重合却是错的，或者正向最大匹配法和逆向最大匹配法切分不同但两个都不对（歧义检测失败）。</p> 
</blockquote> 
<p>所以看出我们要解决的就是那9.0%的问题，毕竟精度也是我们需要考虑的问题，免得到时候搜索一个吴彦祖的照片结果搜出我们的照片了对吧。</p> 
<p>整体代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">get_best_matching_result</span><span class="token punctuation">(</span>MM_result<span class="token punctuation">,</span> RMM_result<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    比较两个分词方法分词的结果

    比较方法:
        1. 如果正反向分词结果词数不同，则取分词数量较少的那个
        2. 如果分词结果词数相同：
            2.1 分词结果相同，说明没有歧义，可返回任意一个
            2.2 分词结果不同，返回其中单字较少的那个

    :param MM_result: 正向最大匹配法的分词结果
    :param RMM_result: 逆向最大匹配法的分词结果
    :return:
        1.词数不同返回词数较少的那个
        2.词典结果相同，返回任意一个(MM_result)
        3.词数相同但是词典结果不同，返回单字最少的那个
    """</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>MM_result<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>RMM_result<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 如果两个结果词数不同，返回词数较少的那个</span>
        <span class="token keyword">return</span> MM_result <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>MM_result<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>RMM_result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">else</span> RMM_result
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> MM_result <span class="token operator">==</span> RMM_result<span class="token punctuation">:</span>
            <span class="token comment"># 因为RMM的结果是取反了的，所以可以直接匹配</span>
            <span class="token comment"># 词典结果相同，返回任意一个</span>
            <span class="token keyword">return</span> MM_result
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 词数相同但是词典结果不同，返回单字最少的那个</span>
            MM_word_1 <span class="token operator">=</span> <span class="token number">0</span>
            RMM_word_1 <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">for</span> word <span class="token keyword">in</span> MM_result<span class="token punctuation">:</span>
                <span class="token comment"># 判断正向匹配结果中单字出现的词数</span>
                <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                    MM_word_1 <span class="token operator">+=</span> <span class="token number">1</span>

            <span class="token keyword">for</span> word <span class="token keyword">in</span> RMM_result<span class="token punctuation">:</span>
                <span class="token comment"># 判断逆向匹配结果中单字出现的词数</span>
                <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                    RMM_word_1 <span class="token operator">+=</span> <span class="token number">1</span>

            <span class="token keyword">return</span> MM_result <span class="token keyword">if</span> <span class="token punctuation">(</span>MM_word_1 <span class="token operator">&lt;</span> RMM_word_1<span class="token punctuation">)</span> <span class="token keyword">else</span> RMM_result
</code></pre> 
<p>这里没什么好说的，就是比较的过程，返回我使用的三目运算符，具体的可以在csdn查看相应的说明。</p> 
<p>在判断单字情况这里，我看到许多前辈大佬使用的是lambda表达式中使用过滤器filter，这里我没有使用，主要是lambda太简洁了，太python了，就有时候可能会造成可读性较差的情况，而且毕竟底层的逻辑都是相同的循环，在时间复杂度和空间复杂度上没有区别，只是看着就一行，舒服些。而我倾向于写for循环，因为我感觉这样方便注释以及后人来查看更改维护代码。</p> 
<p>而这里大家也就可以更清晰地看到什么叫“最大匹配”或者说“长词优先”。无论是第一步返回分词最少（即单个词更长）的结果，还是判断单字最少的情况，都是在最开始提到的“最大匹配”。</p> 
<h2><a id="_208"></a>三、总体代码与结果</h2> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">BiDirectctionMatchingMethod</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    双向最大匹配法

    算法思想:
        1. 如果正反向分词结果词数不同，则取分词数量较少的那个
        2. 如果分词结果词数相同：
            2.1 分词结果相同，说明没有歧义，可返回任意一个
            2.2 分词结果不同，返回其中单字较少的那个

    Attribute:
        window_size: 机器词典最长词条字符数
        dic: 机器词典
        text: 需要匹配的字符串(文本)
    """</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>window_size <span class="token operator">=</span> <span class="token number">3</span>
        self<span class="token punctuation">.</span>dic <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'研究'</span><span class="token punctuation">,</span> <span class="token string">'研究生'</span><span class="token punctuation">,</span> <span class="token string">'生命'</span><span class="token punctuation">,</span> <span class="token string">'命'</span><span class="token punctuation">,</span> <span class="token string">'的'</span><span class="token punctuation">,</span> <span class="token string">'起源'</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>text <span class="token operator">=</span> text

    <span class="token keyword">def</span> <span class="token function">MM_cut</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        正向最大匹配法的方法

        算法思想:
        1. 从左向右取待切分汉语句的m个字符作为匹配字符, m为机器词典中最长词条的字符数
        2. 查找机器词典并进行匹配，若匹配成功, 则将这个匹配字段作为一个词切分出来。
           若匹配不成功, 则将这个匹配字段的最后一个字去掉, 剩下的字符串作为新的匹配字段,
           进行再次匹配, 重复以上过程, 直到切分出所有词为止。

        :return MM_result: 正向最大匹配法匹配结果
        """</span>

        MM_result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        MM_index <span class="token operator">=</span> <span class="token number">0</span>
        MM_text_length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
        MM_piece <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token keyword">while</span> MM_index <span class="token operator">&lt;</span> MM_text_length<span class="token punctuation">:</span>
            <span class="token comment"># MM的循环</span>
            <span class="token keyword">for</span> size <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>window_size <span class="token operator">+</span> MM_index<span class="token punctuation">,</span> MM_index<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 每一轮循环从新的字符串的"索引位置(起始位置) + 机器词典中最长的词条字符数"位置开始匹配字符</span>
                <span class="token comment"># 如果这一轮循环匹配失败，则将要匹配的字符数进行-1操作，进行新一轮的匹配</span>
                <span class="token comment"># 最后一轮匹配为一个字符匹配</span>
                MM_piece <span class="token operator">=</span> self<span class="token punctuation">.</span>text<span class="token punctuation">[</span>MM_index<span class="token punctuation">:</span> size<span class="token punctuation">]</span>
                <span class="token keyword">if</span> MM_piece <span class="token keyword">in</span> self<span class="token punctuation">.</span>dic<span class="token punctuation">:</span>
                    <span class="token comment"># 如果这串字符在机器词典中，那么移动索引至匹配了的字符串的最后一个字符的下标处(将匹配了的字符串移出这个线性表)</span>
                    MM_index <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>
                    <span class="token keyword">break</span>

            <span class="token comment"># 将索引移动到下一轮匹配的开始字符位置，即如果匹配成功，将之前成功匹配的字符移除线性表</span>
            <span class="token comment"># 如果匹配失败，则是将第一个字符移除线性表</span>
            MM_index <span class="token operator">+=</span> <span class="token number">1</span>
            MM_result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>MM_piece<span class="token punctuation">)</span>

        <span class="token keyword">return</span> MM_result

    <span class="token keyword">def</span> <span class="token function">RMM_cut</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        逆向最大匹配法

        RMM的算法思想:
        1.
        先将文档进行倒排处理(reverse)，生成逆序文档，然后根据逆序词典，对逆序文档用正向最大匹配法处理
        2.
        从左向右取待切分汉语句的m个字符作为匹配字符, m为机器词典中最长词条的字符数
        3.
        查找机器词典并进行匹配，若匹配成功, 则将这个匹配字段作为一个词切分出来。
        若匹配不成功, 则将这个匹配字段的最后一个字去掉, 剩下的字符串作为新的匹配字段,
        进行再次匹配, 重复以上过程, 直到切分出所有词为止。

        该应用的算法思想:
        没有使用reverse处理，而是直接从后向前匹配，只是匹配的结果进行了reverse处理
        (因为匹配的结果第一个是"起源"，最后一个是"研究")

        :return RMM_result: 逆向最大匹配法匹配结果
        """</span>
        RMM_result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        RMM_index <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
        RMM_piece <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token keyword">while</span> RMM_index <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token comment"># RMM的循环</span>
            <span class="token keyword">for</span> size <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>RMM_index <span class="token operator">-</span> self<span class="token punctuation">.</span>window_size<span class="token punctuation">,</span> RMM_index<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 匹配最后的3个字符串，如果匹配就进行下一轮while循环，否则字符数-1，进行下一轮for循环</span>
                RMM_piece <span class="token operator">=</span> self<span class="token punctuation">.</span>text<span class="token punctuation">[</span>size<span class="token punctuation">:</span> RMM_index<span class="token punctuation">]</span>
                <span class="token keyword">if</span> RMM_piece <span class="token keyword">in</span> self<span class="token punctuation">.</span>dic<span class="token punctuation">:</span>
                    <span class="token comment"># 如果这串字符在机器词典中，那么移动索引至成功匹配的第一个字符的下标处(将匹配了的字符串移出这个线性表)</span>
                    RMM_index <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">1</span>
                    <span class="token keyword">break</span>

            <span class="token comment"># 将索引移动到下一轮匹配的开始字符位置，即如果匹配成功，将之前成功匹配的字符移除线性表</span>
            <span class="token comment"># 如果匹配失败，则是将最后一个字符移除线性表</span>
            RMM_index <span class="token operator">-=</span> <span class="token number">1</span>
            RMM_result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>RMM_piece<span class="token punctuation">)</span>

        RMM_result<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> RMM_result


<span class="token keyword">def</span> <span class="token function">get_best_matching_result</span><span class="token punctuation">(</span>MM_result<span class="token punctuation">,</span> RMM_result<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    比较两个分词方法分词的结果

    比较方法:
        1. 如果正反向分词结果词数不同，则取分词数量较少的那个
        2. 如果分词结果词数相同：
            2.1 分词结果相同，说明没有歧义，可返回任意一个
            2.2 分词结果不同，返回其中单字较少的那个

    :param MM_result: 正向最大匹配法的分词结果
    :param RMM_result: 逆向最大匹配法的分词结果
    :return:
        1.词数不同返回词数较少的那个
        2.词典结果相同，返回任意一个(MM_result)
        3.词数相同但是词典结果不同，返回单字最少的那个
    """</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>MM_result<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>RMM_result<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 如果两个结果词数不同，返回词数较少的那个</span>
        <span class="token keyword">return</span> MM_result <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>MM_result<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>RMM_result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">else</span> RMM_result
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> MM_result <span class="token operator">==</span> RMM_result<span class="token punctuation">:</span>
            <span class="token comment"># 因为RMM的结果是取反了的，所以可以直接匹配</span>
            <span class="token comment"># 词典结果相同，返回任意一个</span>
            <span class="token keyword">return</span> MM_result
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 词数相同但是词典结果不同，返回单字最少的那个</span>
            MM_word_1 <span class="token operator">=</span> <span class="token number">0</span>
            RMM_word_1 <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">for</span> word <span class="token keyword">in</span> MM_result<span class="token punctuation">:</span>
                <span class="token comment"># 判断正向匹配结果中单字出现的词数</span>
                <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                    MM_word_1 <span class="token operator">+=</span> <span class="token number">1</span>

            <span class="token keyword">for</span> word <span class="token keyword">in</span> RMM_result<span class="token punctuation">:</span>
                <span class="token comment"># 判断逆向匹配结果中单字出现的词数</span>
                <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                    RMM_word_1 <span class="token operator">+=</span> <span class="token number">1</span>

            <span class="token keyword">return</span> MM_result <span class="token keyword">if</span> <span class="token punctuation">(</span>MM_word_1 <span class="token operator">&lt;</span> RMM_word_1<span class="token punctuation">)</span> <span class="token keyword">else</span> RMM_result


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    text <span class="token operator">=</span> <span class="token string">'研究生命的起源'</span>
    tokenizer <span class="token operator">=</span> BiDirectctionMatchingMethod<span class="token punctuation">(</span>text<span class="token punctuation">)</span>
    MM_result <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>MM_cut<span class="token punctuation">(</span><span class="token punctuation">)</span>
    RMM_result <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>RMM_cut<span class="token punctuation">(</span><span class="token punctuation">)</span>
    best_result <span class="token operator">=</span> get_best_matching_result<span class="token punctuation">(</span>MM_result<span class="token punctuation">,</span> RMM_result<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MM_result:"</span><span class="token punctuation">,</span> MM_result<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"RMM_result:"</span><span class="token punctuation">,</span> RMM_result<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"best_result:"</span><span class="token punctuation">,</span> best_result<span class="token punctuation">)</span>
</code></pre> 
<p>运行结果如下：<br> <img src="https://images2.imgbox.com/f7/5d/U1iI4qKv_o.png" alt="运行结果"></p> 
<h2><a id="_367"></a>四、改进方式</h2> 
<p>毕竟我也只是一个初学者，也没有好的办法可以改进，但是我考古了一篇论文《基于最大匹配算法的中文分词模型改进》（相关链接我放在最后了），文中提到的观点是：</p> 
<blockquote> 
 <p>何为最大匹配？</p> 
</blockquote> 
<p>作者认为我们这种匹配方式并非是真正意义的最大匹配，而只是局部的最大匹配（比如只匹配最前面这几个字），作者的方式有点类似于KMP算法，就是拿模式串的最长词的长度来进行匹配，匹配成功切分匹配部分，匹配不成功，则下标后移一位进行匹配。</p> 
<p>但是我个人觉得，作者这种方式是以时间和空间为代价，来换“最大匹配”四个字，因为论文真的太老了，作者只是在摘要中轻浮的提了一句“改进后的算法在速度和效率方面比现有的正向和反向匹配分词算法都有所提高”，但是文中既没有写效率提升了多少，也没有写精度提升了多少，我只能手算时间复杂度（如果有错请见谅并指出）。（而且我感觉那流程图也是错的……）</p> 
<p>以最坏情况来看，即每一轮循环都没匹配到想要的结果，就每一轮都匹配结束，到最后一个字时才匹配完成。作者这种方式的时间复杂度如下：<br> <strong>O(n * (S(1+S)) / 2)</strong><br> n为字符串长度，S为机器词典中最长的单词词数。</p> 
<p>而书中这种方法的时间复杂度如下：<br> <strong>O(n * S)</strong></p> 
<p>而空间上就更不用说了，作者这种方式，假设把中间的截了，那么就成两个字符串了。</p> 
<p>但是这确实给了我们一个思考的方向，就是如何考虑其他的字符串处理方式，并进行相应的融合。</p> 
<h2><a id="_385"></a>五、参考</h2> 
<p>[1] 林关成.<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFD2008&amp;filename=KJXI200836343&amp;v=MTQ5OTdyN0lMaWZUWjdHNEh0blBxWXhCWjRSOGVYMUx1eFlTN0RoMVQzcVRyV00xRnJDVVI3cWZZT1pwRnk3a1Y=" rel="nofollow">基于最大匹配算法的中文分词模型改进</a>[J].科技信息(学术研究),2008(36):419-420.<br> [2] 涂铭,刘祥,刘树春.python自然语言处理实战核心技术与算法[M].机械工业出版社:北京,2018:38.</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/23a6bd81aedc2cb3e2d6dea8de4e3125/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">技术日志7.5</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7621a004f6d2e8019461a3717b9052b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flowable 流程跟踪图片</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>