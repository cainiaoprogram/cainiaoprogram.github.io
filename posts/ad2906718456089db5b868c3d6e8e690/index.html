<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【特征检测】FAST特征点检测算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【特征检测】FAST特征点检测算法" />
<meta property="og:description" content="简介 在局部特征点检测快速发展的时候，人们对于特征的认识也越来越深入，近几年来许多学者提出了许许多多的特征检测算法及其改进算法，在众多的特征提取算法中，不乏涌现出佼佼者。
从最早期的Moravec，到Harris，再到SIFT、SUSAN、GLOH、SURF算法，可以说特征提取算法层出不穷。各种改进算法PCA-SIFT、ICA-SIFT、P-ASURF、R-ASURF、Radon-SIFT等也是搞得如火如荼，不亦乐乎。上面的算法如SIFT、SURF提取到的特征也是非常优秀（有较强的不变性），但是时间消耗依然很大，而在一个系统中，特征提取仅仅是一部分，还要进行诸如配准、提纯、融合等后续算法。这使得实时性不好，降系了统性能。
Edward Rosten和Tom Drummond两位大神经过研究，于2006年在《Machine learning for high-speed corner detection》中提出了一种FAST特征点，并在2010年稍作修改后发表了《Features From Accelerated Segment Test》，简称FAST。注意：FAST只是一种特征点检测算法，并不涉及特征点的特征描述。
FAST详解 FAST特征的定义 FAST的提出者Rosten等将FAST角点定义为：若某像素与其周围邻域内足够多的像素点相差较大，则该像素可能是角点。
FAST算法的步骤 1、上图所示，一个以像素p为中心，半径为3的圆上，有16个像素点（p1、p2、...、p16）。
2、定义一个阈值。计算p1、p9、p5、p13与中心p的像素差，若它们的绝对值有至少3个超过阈值，则当做候选角点，再进行下一步考察；否则，不可能是角点；
3、若p是候选点，则计算p1到p16这16个点与中心p的像素差，若它们有至少连续9个超过阈值，则是角点；否则，不可能是角点。
4、对图像进行非极大值抑制：计算特征点出的FAST得分值（即score值，也即s值），判断以特征点p为中心的一个邻域（如3x3或5x5）内，计算若有多个特征点，则判断每个特征点的s值（16个点与中心差值的绝对值总和），若p是邻域所有特征点中响应值最大的，则保留；否则，抑制。若邻域内只有一个特征点（角点），则保留。得分计算公式如下（公式中用V表示得分，t表示阈值）：
上面是FAST-9，当然FAST-10、FAST-11、FAST-12也是一样的，只是步骤3中，超过阈值的个数不一样。FAST算法实现起来简单，尤其是以速度快著称。
以上便是FAST特征检测的过程，清晰明了，而对于角点的定义也是做到了返璞归真，大师就是大师，还原本质的能力很强，估计以前这种简单想法被很多人忽略了。
实验 opencv代码 #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/features2d/features2d.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;cv.h&gt; #include &lt;vector&gt; using namespace cv; using namespace std; int main() { Mat frame=imread(&#34;lena.jpg&#34;, 1); double t = getTickCount();//当前滴答数 std::vector&lt;KeyPoint&gt; keyPoints; FastFeatureDetector fast(50);	// 检测的阈值为50 fast.detect(frame, keyPoints); drawKeypoints(frame, keyPoints, frame, Scalar(0,0,255), DrawMatchesFlags::DRAW_OVER_OUTIMG); t = ((double)getTickCount() - t)/getTickFrequency(); cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ad2906718456089db5b868c3d6e8e690/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-07-15T20:23:53+08:00" />
<meta property="article:modified_time" content="2015-07-15T20:23:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【特征检测】FAST特征点检测算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#cc33cc;">简介</span></h2> 
<p><span style="font-size:14px;">        在局部特征点检测快速发展的时候，人们对于特征的认识也越来越深入，近几年来许多学者提出了许许多多的特征检测算法及其改进算法，在众多的特征提取算法中，不乏涌现出佼佼者。</span></p> 
<p><span style="font-size:14px;">        从最早期的Moravec，到Harris，再到SIFT、SUSAN、GLOH、SURF算法，可以说特征提取算法层出不穷。各种改进算法PCA-SIFT、ICA-SIFT、P-ASURF、R-ASURF、Radon-SIFT等也是搞得如火如荼，不亦乐乎。上面的算法如SIFT、SURF提取到的特征也是非常优秀（有较强的不变性），但是时间消耗依然很大，而在一个系统中，特征提取仅仅是一部分，还要进行诸如配准、提纯、融合等后续算法。这使得实时性不好，降系了统性能。</span></p> 
<p><span style="font-size:14px;">        Edward Rosten和Tom Drummond两位大神经过研究，于2006年在《Machine learning for high-speed corner detection》中提出了一种FAST特征点，并在2010年稍作修改后发表了《Features From Accelerated Segment Test》，简称<a href="http://www.edwardrosten.com/work/fast.html" rel="nofollow">FAST</a>。<span style="color:#6633ff;"><strong>注意：</strong>FAST只是一种特征点检测算法，并不涉及特征点的特征描述。</span></span></p> 
<h2><span style="color:#cc33cc;">FAST详解</span></h2> 
<h3><span style="color:#3333ff;">FAST特征的定义</span></h3> 
<p><span style="font-size:14px;">      FAST的提出者Rosten等将FAST角点定义为：若某像素与其周围邻域内足够多的像素点相差较大，则该像素可能是角点。</span></p> 
<h3><span style="color:#3333ff;">FAST算法的步骤</span></h3> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/96/9c/O4l39E8n_o.png" alt=""><br></p> 
<p><span style="font-size:14px;"><strong><span style="color:rgb(255,0,0);">1、</span></strong></span><span style="font-size:14px;">上图所示，一个以像素p为中心，半径为3的圆上，有16个像素点（p1、p2、...、p16）。</span></p> 
<p><span style="font-size:14px;"><strong><span style="color:rgb(255,0,0);">2、</span></strong>定义一个阈值。</span><span style="font-size:14px;">计算p1、p9、p5、p13与中心p的像素差，若它们的绝对值有至少3个超过阈值，则当做候选角点，再进行下一步考察；否则，不可能是角点；</span></p> 
<p><span style="font-size:14px;"><strong><span style="color:rgb(255,0,0);">3、</span></strong>若p是候选点，则计算p1到p16这16个点与中心p的像素差，若它们有至少<strong><span style="color:#3366ff;">连续</span></strong>9个超过阈值，则是角点；否则，不可能是角点。</span></p> 
<p><span style="font-size:14px;"><strong><span style="color:rgb(255,0,0);">4、</span></strong>对图像进行非极大值抑制：计算特征点出的FAST得分值（即score值，也即s值），判断以特征点p为中心的一个邻域（如3x3或5x5）内，计算若有多个特征点，则判断每个特征点的s值（16个点与中心差值的绝对值总和），若p是邻域所有特征点中响应值最大的，则保留；否则，抑制。若邻域内只有一个特征点（角点），则保留。得分计算公式如下（公式中用V表示得分，t表示阈值）：</span></p> 
<p style="text-align:center;"><span style="font-size:14px;"><img src="https://images2.imgbox.com/fd/a6/SklU011h_o.png" alt=""><br></span></p> 
<p><span style="font-size:14px;">       上面是FAST-9，当然FAST-10、FAST-11、FAST-12也是一样的，只是步骤3中，超过阈值的个数不一样。FAST算法实现起来简单，尤其是以速度快著称。</span></p> 
<p><span style="font-size:14px;">       以上便是FAST特征检测的过程，清晰明了，而对于角点的定义也是做到了返璞归真，大师就是大师，还原本质的能力很强，估计以前这种简单想法被很多人忽略了。</span></p> 
<h2><span style="color:#cc33cc;">实验</span></h2> 
<h3><span style="color:#3333ff;">opencv代码</span></h3> 
<pre><code class="language-cpp">#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/features2d/features2d.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;cv.h&gt;
#include &lt;vector&gt;

using namespace cv;
using namespace std;

int main()
{
	Mat frame=imread("lena.jpg", 1);
	double t = getTickCount();//当前滴答数
	std::vector&lt;KeyPoint&gt; keyPoints;
	FastFeatureDetector fast(50);	// 检测的阈值为50

	fast.detect(frame, keyPoints);
	drawKeypoints(frame, keyPoints, frame, Scalar(0,0,255), DrawMatchesFlags::DRAW_OVER_OUTIMG);
	
	t = ((double)getTickCount() - t)/getTickFrequency();
	cout&lt;&lt;"算法用时："&lt;&lt;t&lt;&lt;"秒"&lt;&lt;endl;

	imshow("FAST特征点", frame);
	cvWaitKey(0);

	return 0;
}</code></pre> 
<span style="font-size:18px;">输出结果：</span> 
<div style="text-align:center;"> 
 <img src="https://images2.imgbox.com/e0/38/bEZmbX0P_o.png" alt=""> 
</div> 
<h3><span style="color:#3333ff;">MATLAB代码</span></h3> 
<p><span style="font-size:14px;">再上一个自己编写的MATLAB代码，没有进行非极大值抑制，效果不及opencv，而且检测出的角点有一定的出入，应该是opencv内部做了一定的优化。</span></p> 
<pre><code class="language-cpp">clear all;
close all;
%%
pic=imread('lena.jpg');
img=pic;
[M N D]=size(pic);
if D==3
    pic=rgb2gray(pic);
end
%%
mask=[0 0 1 1 1 0 0;...
      0 1 0 0 0 1 0;...
      1 0 0 0 0 0 1;...
      1 0 0 0 0 0 1;...
      1 0 0 0 0 0 1;...
      0 1 0 0 0 1 0;...
      0 0 1 1 1 0 0];
mask=uint8(mask);
threshold=50;
figure;imshow(img);title('FAST角点检测');hold on;
tic;
for i=4:M-3
    for j=4:N-3%若I1、I9与中心I0的差均小于阈值，则不是候选点
        delta1=abs(pic(i-3,j)-pic(i,j))&gt;threshold;
        delta9=abs(pic(i+3,j)-pic(i,j))&gt;threshold;
        delta5=abs(pic(i,j+3)-pic(i,j))&gt;threshold;
        delta13=abs(pic(i,j-3)-pic(i,j))&gt;threshold;
        if sum([delta1 delta9 delta5 delta13])&gt;=3
            block=pic(i-3:i+3,j-3:j+3);
            block=block.*mask;%提取圆周16个点
            pos=find(block);
            block1=abs(block(pos)-pic(i,j))/threshold;
            block2=floor(block1);
            res=find(block2);
            if size(res,1)&gt;=12
                plot(j,i,'ro');
            end
        end
    end
end
toc;
%%</code></pre> 
<span style="font-size:14px;">输出结果：</span> 
<p></p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/5a/08/EKdMKZZ2_o.png" alt=""><br></p> 
<h2 style="text-align:left;"><span style="color:#cc33cc;">参考文献</span></h2> 
<p style="text-align:left;">1、<span style="font-size:14px;">Machine learning for high-speed corner detection[J],2006.</span></p> 
<p style="text-align:left;"><span style="font-size:14px;">2、<span style="font-size:14px;">Features From Accelerated Segment Test[J],2010.</span></span></p> 
<p style="text-align:left;"><span style="font-size:14px;"><span style="font-size:14px;">3、基于自适应阈值的FAST特征点提取算法[J],2013</span></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/220004fd56f4de756482f2e62ca67f64/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">javascript俄罗斯方块小游戏</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/94907c89eda1a4a26ec1b1af6535cd93/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是管态？什么事用户态？二者有何区别？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>