<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【投屏】Scrcpy源码分析三（Client篇-投屏阶段） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【投屏】Scrcpy源码分析三（Client篇-投屏阶段）" />
<meta property="og:description" content="Scrcpy源码分析系列
【投屏】Scrcpy源码分析一（编译篇）
【投屏】Scrcpy源码分析二（Client篇-连接阶段）
【投屏】Scrcpy源码分析三（Client篇-投屏阶段）
【投屏】Scrcpy源码分析四（最终章 - Server篇）
前一篇我们探究了Scrcpy Client端连接阶段的逻辑，这一篇我们继续探究Client端的投屏阶段。
Client篇-投屏阶段 1. 音视频和FFmpeg1.1 音视频基础1.1.1 编码/解码1.1.2 容器1.1.3 音视频播放流程 1.2 FFmpeg 2. 投屏阶段2.1 ``sc_screen_init`` - 对窗口进行初始化2.2 `sc_demuxer_start` - 分流和解码2.3 ``event_loop`` - 事件循环2.4 ``sc_keyboard_inject_init`` &amp; ``sc_mouse_inject_init`` - 键鼠事件2.5 ``sc_controller_start`` - 事件的收发2.6 时序图 3. 小结 1. 音视频和FFmpeg 因为投屏阶段用到了很多音视频编解码知识和FFmpeg相关的API，所以在继续分析代码之前，我们先简单快速地回顾一下这些内容。因FFmpeg功能很广，我们只介绍Scrcpy中用到的一部分。
1.1 音视频基础 1.1.1 编码/解码 编码（Encode）- 将一种音视频格式文件（通常是原始、未经压缩的）通过压缩技术转换成另一种格式文件。
解码（Decode）- 将压缩后的音视频格式文件还原成原始的音视频格式文件。
通常我们所说的编解码器（Codec），就是同时包含了编码和解码的能力。
编码的意义在于，未经压缩的原始类型，数据流是非常大的，不利于存储和网络传输，所以需要对其进行编码。常见的视频原始类型有YUV、RAW等，音频原始类型有PCM。常见的视频编码类型有H264、H265等，音频编码类型有AAC、MP3。
1.1.2 容器 容器通常指包含了多路流的封装格式。比如一个容器内可以包含音频流、视频流、字幕流等，而对应音频流和视频流的数据格式就是音视频的编码类型。
混流/复用（mux）- 将多个流混合到一个容器中。
分流/解复用（demux）- 从一个容器中分解成多个流。
常见的容器有MP4、FLV、MKV、AVI。
1.1.3 音视频播放流程 音视频播放的流程通常是：
编码 混流 分流 解码 采集 YUV H264 传输 H264 YUV 播放 如果只需要音频或视频则，则混流/分流的过程可以省略。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/139a681de3b148c643d412f367332a81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-18T15:57:16+08:00" />
<meta property="article:modified_time" content="2023-02-18T15:57:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【投屏】Scrcpy源码分析三（Client篇-投屏阶段）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>Scrcpy源码分析系列</strong><br> <a href="https://blog.csdn.net/ZivXu/article/details/128659839">【投屏】Scrcpy源码分析一（编译篇）</a><br> <a href="https://blog.csdn.net/ZivXu/article/details/128873600">【投屏】Scrcpy源码分析二（Client篇-连接阶段）</a><br> <a href="https://blog.csdn.net/ZivXu/article/details/128932688">【投屏】Scrcpy源码分析三（Client篇-投屏阶段）</a><br> <a href="https://blog.csdn.net/ZivXu/article/details/129095894">【投屏】Scrcpy源码分析四（最终章 - Server篇）</a></p> 
<p>前一篇我们探究了Scrcpy Client端连接阶段的逻辑，这一篇我们继续探究Client端的投屏阶段。</p> 
<p></p> 
<div class="toc"> 
 <h4>Client篇-投屏阶段</h4> 
 <ul><li><a href="#1_FFmpeg_10" rel="nofollow">1. 音视频和FFmpeg</a></li><li><ul><li><a href="#11__13" rel="nofollow">1.1 音视频基础</a></li><li><ul><li><a href="#111__14" rel="nofollow">1.1.1 编码/解码</a></li><li><a href="#112__22" rel="nofollow">1.1.2 容器</a></li><li><a href="#113__30" rel="nofollow">1.1.3 音视频播放流程</a></li></ul> 
   </li><li><a href="#12_FFmpeg_50" rel="nofollow">1.2 FFmpeg</a></li></ul> 
  </li><li><a href="#2__110" rel="nofollow">2. 投屏阶段</a></li><li><ul><li><a href="#21_sc_screen_init___181" rel="nofollow">2.1 ``sc_screen_init`` - 对窗口进行初始化</a></li><li><a href="#22_sc_demuxer_start___267" rel="nofollow">2.2 `sc_demuxer_start` - 分流和解码</a></li><li><a href="#23__event_loop___382" rel="nofollow">2.3 ``event_loop`` - 事件循环</a></li><li><a href="#24_sc_keyboard_inject_init__sc_mouse_inject_init___496" rel="nofollow">2.4 ``sc_keyboard_inject_init`` &amp; ``sc_mouse_inject_init`` - 键鼠事件</a></li><li><a href="#25_sc_controller_start___554" rel="nofollow">2.5 ``sc_controller_start`` - 事件的收发</a></li><li><a href="#26__603" rel="nofollow">2.6 时序图</a></li></ul> 
  </li><li><a href="#3__608" rel="nofollow">3. 小结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_FFmpeg_10"></a>1. 音视频和FFmpeg</h2> 
<p>因为投屏阶段用到了很多音视频编解码知识和FFmpeg相关的API，所以在继续分析代码之前，我们先简单快速地回顾一下这些内容。因FFmpeg功能很广，我们只介绍Scrcpy中用到的一部分。</p> 
<h3><a id="11__13"></a>1.1 音视频基础</h3> 
<h4><a id="111__14"></a>1.1.1 编码/解码</h4> 
<p><strong>编码</strong>（Encode）- 将一种音视频格式文件（通常是原始、未经压缩的）通过压缩技术转换成另一种格式文件。<br> <strong>解码</strong>（Decode）- 将压缩后的音视频格式文件还原成原始的音视频格式文件。</p> 
<p>通常我们所说的编解码器（Codec），就是同时包含了编码和解码的能力。</p> 
<p>编码的意义在于，未经压缩的原始类型，数据流是非常大的，不利于存储和网络传输，所以需要对其进行编码。常见的视频原始类型有<code>YUV</code>、<code>RAW</code>等，音频原始类型有<code>PCM</code>。常见的视频编码类型有<code>H264</code>、<code>H265</code>等，音频编码类型有<code>AAC</code>、<code>MP3</code>。</p> 
<h4><a id="112__22"></a>1.1.2 容器</h4> 
<p>容器通常指包含了多路流的封装格式。比如一个容器内可以包含音频流、视频流、字幕流等，而对应音频流和视频流的数据格式就是音视频的编码类型。</p> 
<p><strong>混流/复用</strong>（mux）- 将多个流混合到一个容器中。<br> <strong>分流/解复用</strong>（demux）- 从一个容器中分解成多个流。</p> 
<p>常见的容器有<strong>MP4</strong>、<strong>FLV</strong>、<strong>MKV</strong>、<strong>AVI</strong>。</p> 
<h4><a id="113__30"></a>1.1.3 音视频播放流程</h4> 
<p>音视频播放的流程通常是：</p> 
<div class="mermaid sequence-diagram"> 
 <svg id="mermaid-svg-9qOmJhMP5f3A1u9i" width="100%" xmlns="http://www.w3.org/2000/svg" height="57" style="max-width: 774.078125px;" viewbox="0 0 774.078125 57"> 
  <style>#mermaid-svg-9qOmJhMP5f3A1u9i {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-svg-9qOmJhMP5f3A1u9i .error-icon{fill:#552222;}#mermaid-svg-9qOmJhMP5f3A1u9i .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-9qOmJhMP5f3A1u9i .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-9qOmJhMP5f3A1u9i .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-9qOmJhMP5f3A1u9i .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-9qOmJhMP5f3A1u9i .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-9qOmJhMP5f3A1u9i .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-9qOmJhMP5f3A1u9i .marker{fill:#333333;stroke:#333333;}#mermaid-svg-9qOmJhMP5f3A1u9i .marker.cross{stroke:#333333;}#mermaid-svg-9qOmJhMP5f3A1u9i svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-9qOmJhMP5f3A1u9i .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-svg-9qOmJhMP5f3A1u9i .cluster-label text{fill:#333;}#mermaid-svg-9qOmJhMP5f3A1u9i .cluster-label span{color:#333;}#mermaid-svg-9qOmJhMP5f3A1u9i .label text,#mermaid-svg-9qOmJhMP5f3A1u9i span{fill:#333;color:#333;}#mermaid-svg-9qOmJhMP5f3A1u9i .node rect,#mermaid-svg-9qOmJhMP5f3A1u9i .node circle,#mermaid-svg-9qOmJhMP5f3A1u9i .node ellipse,#mermaid-svg-9qOmJhMP5f3A1u9i .node polygon,#mermaid-svg-9qOmJhMP5f3A1u9i .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-svg-9qOmJhMP5f3A1u9i .node .label{text-align:center;}#mermaid-svg-9qOmJhMP5f3A1u9i .node.clickable{cursor:pointer;}#mermaid-svg-9qOmJhMP5f3A1u9i .arrowheadPath{fill:#333333;}#mermaid-svg-9qOmJhMP5f3A1u9i .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-svg-9qOmJhMP5f3A1u9i .flowchart-link{stroke:#333333;fill:none;}#mermaid-svg-9qOmJhMP5f3A1u9i .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-svg-9qOmJhMP5f3A1u9i .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-svg-9qOmJhMP5f3A1u9i .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-svg-9qOmJhMP5f3A1u9i .cluster text{fill:#333;}#mermaid-svg-9qOmJhMP5f3A1u9i .cluster span{color:#333;}#mermaid-svg-9qOmJhMP5f3A1u9i div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-9qOmJhMP5f3A1u9i :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style> 
  <g transform="translate(0, 0)"> 
   <marker id="flowchart-pointEnd" class="marker flowchart" viewbox="0 0 10 10" refx="9" refy="5" markerunits="userSpaceOnUse" markerwidth="12" markerheight="12" orient="auto"> 
    <path d="M 0 0 L 10 5 L 0 10 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path> 
   </marker> 
   <marker id="flowchart-pointStart" class="marker flowchart" viewbox="0 0 10 10" refx="0" refy="5" markerunits="userSpaceOnUse" markerwidth="12" markerheight="12" orient="auto"> 
    <path d="M 0 5 L 10 10 L 10 0 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path> 
   </marker> 
   <marker id="flowchart-circleEnd" class="marker flowchart" viewbox="0 0 10 10" refx="11" refy="5" markerunits="userSpaceOnUse" markerwidth="11" markerheight="11" orient="auto"> 
    <circle cx="5" cy="5" r="5" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></circle> 
   </marker> 
   <marker id="flowchart-circleStart" class="marker flowchart" viewbox="0 0 10 10" refx="-1" refy="5" markerunits="userSpaceOnUse" markerwidth="11" markerheight="11" orient="auto"> 
    <circle cx="5" cy="5" r="5" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></circle> 
   </marker> 
   <marker id="flowchart-crossEnd" class="marker cross flowchart" viewbox="0 0 11 11" refx="12" refy="5.2" markerunits="userSpaceOnUse" markerwidth="11" markerheight="11" orient="auto"> 
    <path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1, 0;"></path> 
   </marker> 
   <marker id="flowchart-crossStart" class="marker cross flowchart" viewbox="0 0 11 11" refx="-1" refy="5.2" markerunits="userSpaceOnUse" markerwidth="11" markerheight="11" orient="auto"> 
    <path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1, 0;"></path> 
   </marker> 
   <g class="root"> 
    <g class="clusters"></g> 
    <g class="edgePaths"> 
     <path d="M55,28.5L59.166666666666664,28.5C63.333333333333336,28.5,71.66666666666667,28.5,80,28.5C88.33333333333333,28.5,96.66666666666667,28.5,100.83333333333333,28.5L105,28.5" id="L-id0-id1-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-id0 LE-id1" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
     <path d="M148.8984375,28.5L155.73177083333334,28.5C162.56510416666666,28.5,176.23177083333334,28.5,189.8984375,28.5C203.56510416666666,28.5,217.23177083333334,28.5,224.06510416666666,28.5L230.8984375,28.5" id="L-id1-id2-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-id1 LE-id2" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
     <path d="M281.5390625,28.5L288.3723958333333,28.5C295.2057291666667,28.5,308.8723958333333,28.5,322.5390625,28.5C336.2057291666667,28.5,349.8723958333333,28.5,356.7057291666667,28.5L363.5390625,28.5" id="L-id2-id3-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-id2 LE-id3" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
     <path d="M410.5390625,28.5L417.3723958333333,28.5C424.2057291666667,28.5,437.8723958333333,28.5,451.5390625,28.5C465.2057291666667,28.5,478.8723958333333,28.5,485.7057291666667,28.5L492.5390625,28.5" id="L-id3-id4-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-id3 LE-id4" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
     <path d="M543.1796875,28.5L550.0130208333334,28.5C556.8463541666666,28.5,570.5130208333334,28.5,584.1796875,28.5C597.8463541666666,28.5,611.5130208333334,28.5,618.3463541666666,28.5L625.1796875,28.5" id="L-id4-id5-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-id4 LE-id5" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
     <path d="M669.078125,28.5L673.2447916666666,28.5C677.4114583333334,28.5,685.7447916666666,28.5,694.078125,28.5C702.4114583333334,28.5,710.7447916666666,28.5,714.9114583333334,28.5L719.078125,28.5" id="L-id5-id6-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-id5 LE-id6" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
    </g> 
    <g class="edgeLabels"> 
     <g class="edgeLabel"> 
      <g class="label" transform="translate(0, 0)"> 
       <foreignobject width="0" height="0"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel"></span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="edgeLabel" transform="translate(189.8984375, 28.5)"> 
      <g class="label" transform="translate(-16, -13)"> 
       <foreignobject width="32" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel">编码</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="edgeLabel" transform="translate(322.5390625, 28.5)"> 
      <g class="label" transform="translate(-16, -13)"> 
       <foreignobject width="32" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel">混流</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="edgeLabel" transform="translate(451.5390625, 28.5)"> 
      <g class="label" transform="translate(-16, -13)"> 
       <foreignobject width="32" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel">分流</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="edgeLabel" transform="translate(584.1796875, 28.5)"> 
      <g class="label" transform="translate(-16, -13)"> 
       <foreignobject width="32" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel">解码</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="edgeLabel"> 
      <g class="label" transform="translate(0, 0)"> 
       <foreignobject width="0" height="0"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel"></span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
    </g> 
    <g class="nodes"> 
     <g class="node default default" id="flowchart-id0-21" transform="translate(31.5, 28.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-23.5" y="-20.5" width="47" height="41"></rect> 
      <g class="label" style="" transform="translate(-16, -13)"> 
       <foreignobject width="32" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">采集</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-id1-22" transform="translate(126.94921875, 28.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-21.94921875" y="-20.5" width="43.8984375" height="41"></rect> 
      <g class="label" style="" transform="translate(-14.44921875, -13)"> 
       <foreignobject width="28.8984375" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">YUV</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-id2-23" transform="translate(256.21875, 28.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-25.3203125" y="-20.5" width="50.640625" height="41"></rect> 
      <g class="label" style="" transform="translate(-17.8203125, -13)"> 
       <foreignobject width="35.640625" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">H264</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-id3-24" transform="translate(387.0390625, 28.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-23.5" y="-20.5" width="47" height="41"></rect> 
      <g class="label" style="" transform="translate(-16, -13)"> 
       <foreignobject width="32" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">传输</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-id4-25" transform="translate(517.859375, 28.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-25.3203125" y="-20.5" width="50.640625" height="41"></rect> 
      <g class="label" style="" transform="translate(-17.8203125, -13)"> 
       <foreignobject width="35.640625" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">H264</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-id5-26" transform="translate(647.12890625, 28.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-21.94921875" y="-20.5" width="43.8984375" height="41"></rect> 
      <g class="label" style="" transform="translate(-14.44921875, -13)"> 
       <foreignobject width="28.8984375" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">YUV</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-id6-27" transform="translate(742.578125, 28.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-23.5" y="-20.5" width="47" height="41"></rect> 
      <g class="label" style="" transform="translate(-16, -13)"> 
       <foreignobject width="32" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">播放</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
    </g> 
   </g> 
  </g> 
 </svg> 
</div> 
<p>如果只需要音频或视频则，则混流/分流的过程可以省略。</p> 
<p>上一篇有提到Scrcpy的原理的Android设备侧不断录屏、编码，将视频流传输给PC，PC进行解码和渲染，就是类似上述的过程。</p> 
<p>Android设备的编码用的是MediaCodec硬编码，这个暂且不用太关注，我们只需要只要Android是将YUV原始数据，编码生成H264，通过video_socket传给PC。PC侧收到视频流后，通过FFmpeg进行解码并通过SDL渲染出来。</p> 
<h3><a id="12_FFmpeg_50"></a>1.2 FFmpeg</h3> 
<p>FFmpeg是一套音视频开源软件，提供强大的音视频处理能力，应用广泛。其中最基础就是编解码的能力。</p> 
<p>Scrcpy主要用到FFmpeg的解码能力，并且此文我们的重点还是Scrcpy，所以只是简单描述一下FFmpeg的解码需要用到的API，方便后续分析。</p> 
<p>FFmpeg解码的关键流程如下（代码不完整，只需关注关键API）：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">ffmpeg_decode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 注册所有编解码器</span>
	<span class="token function">avcodec_register_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 创建解码器，传入对应的解码器ID，比如这里是H264解码器</span>
	AVCodec <span class="token operator">*</span>codec <span class="token operator">=</span> <span class="token function">avcodec_find_decoder</span><span class="token punctuation">(</span>AV_CODEC_ID_H264<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 分配AVCodecContext空间并初始化</span>
	AVCodecContext <span class="token operator">*</span>codecContext <span class="token operator">=</span> <span class="token function">avcodec_alloc_context3</span><span class="token punctuation">(</span>codec<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 通过AVCodec对AVCodecContext进行初始化</span>
	<span class="token function">avcodec_open2</span><span class="token punctuation">(</span>codecContext<span class="token punctuation">,</span> codec<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 初始化AVCodecParserContext</span>
	AVCodecParserContext <span class="token operator">*</span>parserContext <span class="token operator">=</span> <span class="token function">av_parse_init</span><span class="token punctuation">(</span>AV_CODEC_ID_H264<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 分配AVPacket空间</span>
	AVPacket <span class="token operator">*</span>avPacket <span class="token operator">=</span> <span class="token function">av_packet_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 分配AVFramen空间</span>
	AVFrame <span class="token operator">*</span>frame <span class="token operator">=</span> <span class="token function">av_frame_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">eof</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 解析一个packet</span>
		<span class="token function">av_parser_parse2</span><span class="token punctuation">(</span>parserContext<span class="token punctuation">,</span> codecContext<span class="token punctuation">,</span>  <span class="token operator">&amp;</span>pkt<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pkt<span class="token operator">-&gt;</span>size<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>data_size<span class="token punctuation">,</span> AV_NOPTS_VALUE<span class="token punctuation">,</span> AV_NOPTS_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 解码</span>
		<span class="token function">decode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 资源释放</span>
	<span class="token function">avcodec_free_context</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>codecContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">av_parse_close</span><span class="token punctuation">(</span>parseContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">av_frame_free</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">av_packet_free</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>avPacket<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">decode</span><span class="token punctuation">(</span>AVCodecContext <span class="token operator">*</span>codec_ctx<span class="token punctuation">,</span> AVPacket <span class="token operator">*</span>pkt<span class="token punctuation">,</span> AVFrame <span class="token operator">*</span>frame<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 将packet送入解码器</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">avcodec_send_packet</span><span class="token punctuation">(</span>codec_ctx<span class="token punctuation">,</span> pkt<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span><span class="token punctuation">(</span>ret <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 从解码器中拿到解码后的帧数据</span>
		ret <span class="token operator">=</span> <span class="token function">avcodec_receive_frame</span><span class="token punctuation">(</span>codec_ctx<span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// [TODO] 已经拿到帧数据frame-&gt;data</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>上面是使用FFmpeg对H264进行视频解码的模板代码，主要有几个阶段：</p> 
<ol><li>初始化相关，此阶段需要创建<code>AVCodec</code>、<code>AVCodecContext</code>、<code>AVCodecParserContext</code>变量，并进行相关初始化。</li><li>对<code>AVPacket</code>和<code>AVFrame</code>结构分配空间。<code>AVPacket</code>是指经过编码之后的一个数据包，<code>AVFrame</code>是解码后的一帧数据，视频中一帧代表一帧图片数据。</li><li>解码阶段，此阶段需要从输入源（文件或网络）解析一个packet，然后送入解码器解码，到到frame帧数据。</li><li>数据处理阶段，在拿到帧数据<code>AVFrame-&gt;data</code>后，可以根据业务需要对数据进行处理。</li></ol> 
<p>Scrcpy中使用FFmpeg进行解码流程也大致如上。</p> 
<h2><a id="2__110"></a>2. 投屏阶段</h2> 
<p>上回说到<code>scrcpy()</code>里的<code>await_for_server()</code>函数，这个函数内部在等待SDL事件，在收到连接成功的事件之后，则跳出等待，继续执行后续的逻辑。</p> 
<pre><code class="prism language-c"><span class="token comment">// scrcpy.c</span>
<span class="token keyword">enum</span> <span class="token class-name">scrcpy_exit_code</span>
<span class="token function">scrcpy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">scrcpy_options</span> <span class="token operator">*</span>options<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 连接阶段...</span>
	<span class="token function">await_for_server</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 【投屏阶段】</span>
	<span class="token comment">// 初始化文件上传相关数据结构</span>
	<span class="token function">sc_file_pusher_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>file_pusher<span class="token punctuation">,</span> serial<span class="token punctuation">,</span> options<span class="token operator">-&gt;</span>push_target<span class="token punctuation">)</span>
	<span class="token comment">// 初始化解码相关数据结构</span>
	<span class="token function">sc_decoder_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>decoder<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 初始化录制相关数据结构</span>
	<span class="token function">sc_recorder_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>recorder<span class="token punctuation">,</span>
                              options<span class="token operator">-&gt;</span>record_filename<span class="token punctuation">,</span>
                              options<span class="token operator">-&gt;</span>record_format<span class="token punctuation">,</span>
                              info<span class="token operator">-&gt;</span>frame_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 初始化分流相关数据结构</span>
	<span class="token function">sc_demuxer_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>demuxer<span class="token punctuation">,</span> s<span class="token operator">-&gt;</span>server<span class="token punctuation">.</span>video_socket<span class="token punctuation">,</span> <span class="token operator">&amp;</span>demuxer_cbs<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将解码器加到分流器的一路流中</span>
	<span class="token function">sc_demuxer_add_sink</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>demuxer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dec<span class="token operator">-&gt;</span>packet_sink<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将录制器加到分流器的一路流中</span>
	<span class="token function">sc_demuxer_add_sink</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>demuxer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rec<span class="token operator">-&gt;</span>packet_sink<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 初始化键盘拦截相关数据结构</span>
	<span class="token function">sc_keyboard_inject_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>keyboard_inject<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>controller<span class="token punctuation">,</span>
                                    options<span class="token operator">-&gt;</span>key_inject_mode<span class="token punctuation">,</span>
                                    options<span class="token operator">-&gt;</span>forward_key_repeat<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 初始化鼠标拦截相关数据结构</span>
	<span class="token function">sc_mouse_inject_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>mouse_inject<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>controller<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 初始化控制socket</span>
	<span class="token function">sc_controller_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>controller<span class="token punctuation">,</span> s<span class="token operator">-&gt;</span>server<span class="token punctuation">.</span>control_socket<span class="token punctuation">,</span>
                                acksync<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 开启两个控制相关的新线程，一个发，一个收</span>
	<span class="token function">sc_controller_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>controller<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 初始化屏幕渲染相关数据结构</span>
	<span class="token function">sc_screen_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>screen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>screen_params<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将屏幕加到解码器的一路流中</span>
	<span class="token function">sc_decoder_add_sink</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>decoder<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>screen<span class="token punctuation">.</span>frame_sink<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将v4l2加到解码器的一路流中</span>
	<span class="token function">sc_decoder_add_sink</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>decoder<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>v4l2_sink<span class="token punctuation">.</span>frame_sink<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 开启新线程执行分流和解码</span>
	<span class="token function">sc_demuxer_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>demuxer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// SDL事件循环等待事件</span>
	<span class="token function">event_loop</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 关闭窗口</span>
	<span class="token function">sc_screen_hide_window</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>screen<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 关闭和释放服务相关资源</span>
	<span class="token function">sc_server_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>投屏阶段我们需要关注几个部分：</p> 
<ol><li><code>sc_file_pusher_init</code> - 初始化文件上传相关的数据结构。文件上传是指将文件从PC拖入镜像窗口中自动同步至<code>/sdcard/Download</code>目录中。</li><li><code>sc_decoder_init</code> &amp; <code>sc_recorder_init</code> - 解码器和录制相关数据结构的初始化。主要设置<code>struct sc_packet_sink_ops</code>的回调函数，在<code>open</code>、<code>close</code>、<code>push</code>三个时机触发相应的动作。（注意：这里的回调是针对Packet的，如前面提到Packet指的是经过压缩编码后的一个数据包）。</li><li><code>sc_demuxer_init</code> - 对分流相关的数据结构进行初始化。</li><li><code>sc_demuxer_add_sink</code> - 将解码器和录制器加到分流中，Scrcpy的分流（Demuxer）和前面提到的容器分流不太一样。容器的分流是分离出多个流，而Scrcpy中的分流指的是把同一份数据送给不同的地方去处理。比如这里会送到解码器进行解码，如果在程序启动时指定了需要进行录制，那么也会送一份数据到录制器中进行数据保存。</li><li><code>sc_keyboard_inject_init</code> &amp; <code>sc_mouse_inject_init</code> - 初始化键盘和鼠标拦截的数据结构。</li><li><code>sc_controller_init</code> - 对control_socket链路进行初始化。</li><li><code>sc_controller_start</code> - 开启两个控制相关的新线程，一个发，一个收。</li><li><code>sc_screen_init</code> - 对窗口进行初始化，并用SDL创建窗口。设置<code>struct sc_frame_sink_ops</code>的回调函数， 在<code>open</code>、<code>close</code>、<code>push</code>三个时机触发相应的动作。（注意：和前面不同，这里的回调是针对frame的，即packet解码后帧数据）。</li><li><code>sc_decoder_add_sink</code> - 将窗口和V4L2加到解码器的一路流中，同分流器一样，解码器解码后的帧数据也会送到窗口上和V4L2设备中（V4L2设备需在启动程序是指定，如不指定，则此处就不会触发V4L2逻辑）。</li><li><code>sc_demuxer_start</code> - 开启新线程执行分流和解码。</li><li><code>event_loop</code> - 事件循环，监听SDL事件。</li><li><code>sc_server_destroy</code> - 关闭和释放服务相关资源。因为上一步是死循环，只有在触发退出事件才会退出循环，走到这里的释放逻辑。</li></ol> 
<p>其中需要重点关注的 <strong>5</strong>、<strong>7</strong> 、<strong>8</strong>、<strong>10</strong>、<strong>11</strong>，我们按照重要性顺序着重来看 - <strong>8</strong>、<strong>10</strong> 、<strong>11</strong>、<strong>5</strong>、<strong>7</strong>。</p> 
<h3><a id="21_sc_screen_init___181"></a>2.1 <code>sc_screen_init</code> - 对窗口进行初始化</h3> 
<p>我们列出<code>sc_screen_init</code>函数的关键代码：</p> 
<pre><code class="prism language-c"><span class="token comment">// screen.c</span>
bool
<span class="token function">sc_screen_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_screen</span> <span class="token operator">*</span>screen<span class="token punctuation">,</span>
               <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sc_screen_params</span> <span class="token operator">*</span>params<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 设置on_new_frame回调</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sc_video_buffer_callbacks</span> cbs <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">.</span>on_new_frame <span class="token operator">=</span> sc_video_buffer_on_new_frame<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// 对video buffer进行初始化</span>
	<span class="token function">sc_video_buffer_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>screen<span class="token operator">-&gt;</span>vb<span class="token punctuation">,</span> params<span class="token operator">-&gt;</span>buffering_time<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cbs<span class="token punctuation">,</span> screen<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 开启新线程执行帧数据处理</span>
	<span class="token function">sc_video_buffer_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>screen<span class="token operator">-&gt;</span>vb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 创建SDL窗口</span>
	<span class="token function">SDL_CreateWindow</span><span class="token punctuation">(</span>params<span class="token operator">-&gt;</span>window_title<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> window_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 创建渲染器</span>
	<span class="token function">SDL_CreateRenderer</span><span class="token punctuation">(</span>screen<span class="token operator">-&gt;</span>window<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> SDL_RENDERER_ACCELERATED<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 设置解码后frame数据回调</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sc_frame_sink_ops</span> ops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token punctuation">.</span>open <span class="token operator">=</span> sc_screen_frame_sink_open<span class="token punctuation">,</span>
	        <span class="token punctuation">.</span>close <span class="token operator">=</span> sc_screen_frame_sink_close<span class="token punctuation">,</span>
	        <span class="token punctuation">.</span>push <span class="token operator">=</span> sc_screen_frame_sink_push<span class="token punctuation">,</span>
	    <span class="token punctuation">}</span><span class="token punctuation">;</span>
	    
    screen<span class="token operator">-&gt;</span>frame_sink<span class="token punctuation">.</span>ops <span class="token operator">=</span> <span class="token operator">&amp;</span>ops<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们看到<code>sc_screen_init</code>的主要作用有四个：</p> 
<ol><li> <p>设置<code>on_new_frame</code>，并将回调传入screen（也就是桌面窗口）的video_buffer的初始化方法中，可以简单理解为将这个回调和客户端做一个绑定，后面会用到。</p> </li><li> <p>开启新线程执行帧处理，这里的功能最终是从一个帧队列里取帧数据，然后送给<code>on_new_frame</code>函数。</p> <pre><code class="prism language-c"><span class="token comment">// video_buffer.c</span>
bool
<span class="token function">sc_video_buffer_start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_video_buffer</span> <span class="token operator">*</span>vb<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 开启新线程执行run_buffering函数</span>
	<span class="token function">sc_thread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vb<span class="token operator">-&gt;</span>b<span class="token punctuation">.</span>thread<span class="token punctuation">,</span> run_buffering<span class="token punctuation">,</span> <span class="token string">"scrcpy-vbuf"</span><span class="token punctuation">,</span> vb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">run_buffering</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 从&amp;vb-&gt;b.queue队列中取帧</span>
		<span class="token function">sc_queue_take</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vb<span class="token operator">-&gt;</span>b<span class="token punctuation">.</span>queue<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vb_frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 调用此函数，将帧传入</span>
		<span class="token function">sc_video_buffer_offer</span><span class="token punctuation">(</span>vb<span class="token punctuation">,</span> vb_frame<span class="token operator">-&gt;</span>frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> bool
<span class="token function">sc_video_buffer_offer</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_video_buffer</span> <span class="token operator">*</span>vb<span class="token punctuation">,</span> <span class="token keyword">const</span> AVFrame <span class="token operator">*</span>frame<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 帧数据处理后，将数据通过on_new_frame回调传出</span>
    vb<span class="token operator">-&gt;</span>cbs<span class="token operator">-&gt;</span><span class="token function">on_new_frame</span><span class="token punctuation">(</span>vb<span class="token punctuation">,</span> previous_skipped<span class="token punctuation">,</span> vb<span class="token operator">-&gt;</span>cbs_userdata<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>通过SDL创建窗口和渲染器。</p> </li><li> <p>设置解码后frame数据的回调，正如前面提到，packet会送给解码器和录制器两路packet流，解码器里又可以分屏幕窗口和V4L2设备两路frame流。这里的回调就是这是解码器将数据解码后给到屏幕窗口的回调。</p> </li></ol> 
<pre><code class="prism language-c"><span class="token comment">// screen.c</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sc_frame_sink_ops</span> ops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token punctuation">.</span>open <span class="token operator">=</span> sc_screen_frame_sink_open<span class="token punctuation">,</span>
	        <span class="token punctuation">.</span>close <span class="token operator">=</span> sc_screen_frame_sink_close<span class="token punctuation">,</span>
	        <span class="token punctuation">.</span>push <span class="token operator">=</span> sc_screen_frame_sink_push<span class="token punctuation">,</span>
	    <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> bool
<span class="token function">sc_screen_frame_sink_push</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_frame_sink</span> <span class="token operator">*</span>sink<span class="token punctuation">,</span> <span class="token keyword">const</span> AVFrame <span class="token operator">*</span>frame<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">sc_video_buffer_push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>screen<span class="token operator">-&gt;</span>vb<span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// video_buffer.c</span>
bool
<span class="token function">sc_video_buffer_push</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_video_buffer</span> <span class="token operator">*</span>vb<span class="token punctuation">,</span> <span class="token keyword">const</span> AVFrame <span class="token operator">*</span>frame<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 往&amp;vb-&gt;b.queue队列中插帧数据</span>
    <span class="token function">sc_queue_push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vb<span class="token operator">-&gt;</span>b<span class="token punctuation">.</span>queue<span class="token punctuation">,</span> next<span class="token punctuation">,</span> vb_frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>分析完<code>sc_screen_init</code>函数后，我们知道这部分的流程基本如下图所示，那么现在遗留的问题就是外部怎么发起解码器的push回调，以及<code>on_new_frame</code>里到底做了什么。这里先埋个坑，我们后面填充。<br> <img src="https://images2.imgbox.com/81/18/ceIO4C6X_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22_sc_demuxer_start___267"></a>2.2 <code>sc_demuxer_start</code> - 分流和解码</h3> 
<p>我们列出<code>sc_demuxer_start</code>函数的关键代码：</p> 
<pre><code class="prism language-c"><span class="token comment">// demuxer.c</span>
bool
<span class="token function">sc_demuxer_start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_demuxer</span> <span class="token operator">*</span>demuxer<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">sc_thread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>demuxer<span class="token operator">-&gt;</span>thread<span class="token punctuation">,</span> run_demuxer<span class="token punctuation">,</span> <span class="token string">"scrcpy-demuxer"</span><span class="token punctuation">,</span> demuxer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">run_demuxer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// FFmpeg API: 初始化AVCodec和AVCodecContext</span>
	AVCodec <span class="token operator">*</span>codec <span class="token operator">=</span> <span class="token function">avcodec_find_decoder</span><span class="token punctuation">(</span>AV_CODEC_ID_H264<span class="token punctuation">)</span><span class="token punctuation">;</span>
	demuxer<span class="token operator">-&gt;</span>codec_ctx <span class="token operator">=</span> <span class="token function">avcodec_alloc_context3</span><span class="token punctuation">(</span>codec<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// open sinks，回调到struct sc_packet_sink_ops的.open回调</span>
	<span class="token function">sc_demuxer_open_sinks</span><span class="token punctuation">(</span>demuxer<span class="token punctuation">,</span> codec<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// FFmpeg API: 初始化AVCodecParserContext和AVPacket</span>
	demuxer<span class="token operator">-&gt;</span>parser <span class="token operator">=</span> <span class="token function">av_parser_init</span><span class="token punctuation">(</span>AV_CODEC_ID_H264<span class="token punctuation">)</span><span class="token punctuation">;</span>
	AVPacket <span class="token operator">*</span>packet <span class="token operator">=</span> <span class="token function">av_packet_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 不断地读packet，并将packet窗到sink中</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">sc_demuxer_recv_packet</span><span class="token punctuation">(</span>demuxer<span class="token punctuation">,</span> packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sc_demuxer_push_packet</span><span class="token punctuation">(</span>demuxer<span class="token punctuation">,</span> packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// FFmpeg API: 释放</span>
	<span class="token function">av_packet_free</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">av_parser_close</span><span class="token punctuation">(</span>demuxer<span class="token operator">-&gt;</span>parser<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">avcodec_free_context</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>demuxer<span class="token operator">-&gt;</span>codec_ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们看到，<code>sc_demuxer_start</code>主要就是在子线程中执行FFmpeg相关的数据结构初始化，然后在死循环中不断地读packet数据和push，具体是怎么做了，我们来看下<code>sc_demuxer_recv_packet</code>和 <code>sc_demuxer_push_packet</code>函数：</p> 
<pre><code class="prism language-c"><span class="token comment">// demuxer.c</span>
<span class="token comment">// sc_demuxer_recv_packet的作用就是接收packet</span>
<span class="token keyword">static</span> bool
<span class="token function">sc_demuxer_recv_packet</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_demuxer</span> <span class="token operator">*</span>demuxer<span class="token punctuation">,</span> AVPacket <span class="token operator">*</span>packet<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 通过video_socket从网络读packet header</span>
	<span class="token function">net_recv_all</span><span class="token punctuation">(</span>demuxer<span class="token operator">-&gt;</span>socket<span class="token punctuation">,</span> header<span class="token punctuation">,</span> SC_PACKET_HEADER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 通过video_socket从网络读packet数据</span>
	<span class="token function">net_recv_all</span><span class="token punctuation">(</span>demuxer<span class="token operator">-&gt;</span>socket<span class="token punctuation">,</span> packet<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// sc_demuxer_push_packet的作用就是调用struct sc_packet_sink_ops的.push回调</span>
<span class="token keyword">static</span> bool
<span class="token function">sc_demuxer_push_packet</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_demuxer</span> <span class="token operator">*</span>demuxer<span class="token punctuation">,</span> AVPacket <span class="token operator">*</span>packet<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">push_packet_to_sinks</span><span class="token punctuation">(</span>demuxer<span class="token punctuation">,</span> packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> bool
<span class="token function">push_packet_to_sinks</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_demuxer</span> <span class="token operator">*</span>demuxer<span class="token punctuation">,</span> <span class="token keyword">const</span> AVPacket <span class="token operator">*</span>packet<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> demuxer<span class="token operator">-&gt;</span>sink_count<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">struct</span> <span class="token class-name">sc_packet_sink</span> <span class="token operator">*</span>sink <span class="token operator">=</span> demuxer<span class="token operator">-&gt;</span>sinks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sink<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">push</span><span class="token punctuation">(</span>sink<span class="token punctuation">,</span> packet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意，这里是才从网络获取到packet，还没有解码成frame，所以调用是<code>struct sc_packet_sink_ops</code>的<code>.push</code>回调，并不是2.1节的解码后的push回调。这里packet的回调是在前文提到的<code>sc_decoder_init</code>函数中注册的：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span>
<span class="token function">sc_decoder_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_decoder</span> <span class="token operator">*</span>decoder<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    decoder<span class="token operator">-&gt;</span>sink_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sc_packet_sink_ops</span> ops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">.</span>open <span class="token operator">=</span> sc_decoder_packet_sink_open<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>close <span class="token operator">=</span> sc_decoder_packet_sink_close<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>push <span class="token operator">=</span> sc_decoder_packet_sink_push<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    decoder<span class="token operator">-&gt;</span>packet_sink<span class="token punctuation">.</span>ops <span class="token operator">=</span> <span class="token operator">&amp;</span>ops<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// packet的push回调方法</span>
<span class="token keyword">static</span> bool
<span class="token function">sc_decoder_packet_sink_push</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_packet_sink</span> <span class="token operator">*</span>sink<span class="token punctuation">,</span>
                            <span class="token keyword">const</span> AVPacket <span class="token operator">*</span>packet<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">sc_decoder</span> <span class="token operator">*</span>decoder <span class="token operator">=</span> <span class="token function">DOWNCAST</span><span class="token punctuation">(</span>sink<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">sc_decoder_push</span><span class="token punctuation">(</span>decoder<span class="token punctuation">,</span> packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> bool
<span class="token function">sc_decoder_push</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_decoder</span> <span class="token operator">*</span>decoder<span class="token punctuation">,</span> <span class="token keyword">const</span> AVPacket <span class="token operator">*</span>packet<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// FFmpeg API: 将packet送到packet送到解码器中</span>
	<span class="token function">avcodec_send_packet</span><span class="token punctuation">(</span>decoder<span class="token operator">-&gt;</span>codec_ctx<span class="token punctuation">,</span> packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// FFmpeg API: 从解码器中拿到解码后的帧数据</span>
	<span class="token function">avcodec_receive_frame</span><span class="token punctuation">(</span>decoder<span class="token operator">-&gt;</span>codec_ctx<span class="token punctuation">,</span> decoder<span class="token operator">-&gt;</span>frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将解码后的帧数据传给sinks</span>
	<span class="token function">push_frame_to_sinks</span><span class="token punctuation">(</span>decoder<span class="token punctuation">,</span> decoder<span class="token operator">-&gt;</span>frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>所以packet的push回调的主要功能就是通过解码器把packet解码成frame，这一点和前面说的FFmpeg解码流程是一致的。拿到frame之后，就该调用<code>push_frame_to_sinks</code>把frame发给了解码器的push回调了：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> bool
<span class="token function">push_frame_to_sinks</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_decoder</span> <span class="token operator">*</span>decoder<span class="token punctuation">,</span> <span class="token keyword">const</span> AVFrame <span class="token operator">*</span>frame<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> decoder<span class="token operator">-&gt;</span>sink_count<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">struct</span> <span class="token class-name">sc_frame_sink</span> <span class="token operator">*</span>sink <span class="token operator">=</span> decoder<span class="token operator">-&gt;</span>sinks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sink<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">push</span><span class="token punctuation">(</span>sink<span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对的，就是在这里触发了前面一节流程图的第一个问号，所以流程图可以填充一下：<br> <img src="https://images2.imgbox.com/a8/51/Ma9YIEjt_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23__event_loop___382"></a>2.3 <code>event_loop</code> - 事件循环</h3> 
<pre><code class="prism language-c"><span class="token comment">// scrcpy.c</span>
<span class="token keyword">static</span> <span class="token keyword">enum</span> <span class="token class-name">scrcpy_exit_code</span>
<span class="token function">event_loop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">scrcpy</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    SDL_Event event<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">SDL_WaitEvent</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">case</span> EVENT_STREAM_STOPPED<span class="token operator">:</span>
                <span class="token function">LOGW</span><span class="token punctuation">(</span><span class="token string">"Device disconnected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> SCRCPY_EXIT_DISCONNECTED<span class="token punctuation">;</span>
            <span class="token keyword">case</span> SDL_QUIT<span class="token operator">:</span>
                <span class="token function">LOGD</span><span class="token punctuation">(</span><span class="token string">"User requested to quit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> SCRCPY_EXIT_SUCCESS<span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
                <span class="token function">sc_screen_handle_event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>screen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> SCRCPY_EXIT_FAILURE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>event_loop</code>函数的结构比较清晰，就是一直在等待SDL事件，除了<code>EVENT_STREAM_STOPPED</code>和<code>SDL_QUIT</code>事件，其他的事件都是交给<code>sc_screen_handle_event</code>函数处理：</p> 
<pre><code class="prism language-c"><span class="token comment">// screen.c</span>
<span class="token keyword">void</span>
<span class="token function">sc_screen_handle_event</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_screen</span> <span class="token operator">*</span>screen<span class="token punctuation">,</span> SDL_Event <span class="token operator">*</span>event<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token operator">-&gt;</span>type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// new frame事件</span>
    	<span class="token keyword">case</span> EVENT_NEW_FRAME<span class="token operator">:</span>
    		<span class="token function">sc_screen_update_frame</span><span class="token punctuation">(</span>screen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    		<span class="token keyword">return</span><span class="token punctuation">;</span>
    	<span class="token comment">// SDL窗口事件，包括窗口最大化、恢复、窗口失去焦点等</span>
        <span class="token keyword">case</span> SDL_WINDOWEVENT<span class="token operator">:</span>
        	<span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">// 键盘事件</span>
        <span class="token keyword">case</span> SDL_KEYDOWN<span class="token operator">:</span>
        <span class="token keyword">case</span> SDL_KEYUP<span class="token operator">:</span>
        <span class="token comment">// 鼠标事件</span>
        <span class="token keyword">case</span> SDL_MOUSEWHEEL<span class="token operator">:</span>
        <span class="token keyword">case</span> SDL_MOUSEMOTION<span class="token operator">:</span>
        <span class="token keyword">case</span> SDL_MOUSEBUTTONDOWN<span class="token operator">:</span>
        <span class="token comment">// 触摸事件</span>
        <span class="token keyword">case</span> SDL_FINGERMOTION<span class="token operator">:</span>
        <span class="token keyword">case</span> SDL_FINGERDOWN<span class="token operator">:</span>
        <span class="token keyword">case</span> SDL_FINGERUP<span class="token operator">:</span>
        <span class="token keyword">case</span> SDL_MOUSEBUTTONUP<span class="token operator">:</span>
        	<span class="token comment">// 省略了部分代码</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">sc_input_manager_handle_event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>screen<span class="token operator">-&gt;</span>im<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在<code>sc_screen_handle_event</code>函数中，我们会处理<code>EVENT_NEW_FRAME</code>事件和其他鼠标和键盘事件。我们先着重关注<code>EVENT_NEW_FRAME</code>事件的。收到这个事件之后会执行<code>sc_screen_update_frame</code>函数，关键代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">// screen.c</span>
<span class="token keyword">static</span> bool
<span class="token function">sc_screen_update_frame</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_screen</span> <span class="token operator">*</span>screen<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 更新数据</span>
    <span class="token function">update_texture</span><span class="token punctuation">(</span>screen<span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 第一次执行则打开窗口</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>screen<span class="token operator">-&gt;</span>has_frame<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 		<span class="token function">sc_screen_show_initial_window</span><span class="token punctuation">(</span>screen<span class="token punctuation">)</span><span class="token punctuation">;</span>
 	<span class="token punctuation">}</span>
	<span class="token comment">// 数据渲染</span>
    <span class="token function">sc_screen_render</span><span class="token punctuation">(</span>screen<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">update_texture</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_screen</span> <span class="token operator">*</span>screen<span class="token punctuation">,</span> <span class="token keyword">const</span> AVFrame <span class="token operator">*</span>frame<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 将YUV数据写到SDL上下文中</span>
    <span class="token function">SDL_UpdateYUVTexture</span><span class="token punctuation">(</span>screen<span class="token operator">-&gt;</span>texture<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
            frame<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> frame<span class="token operator">-&gt;</span>linesize<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            frame<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> frame<span class="token operator">-&gt;</span>linesize<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            frame<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> frame<span class="token operator">-&gt;</span>linesize<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">sc_screen_show_initial_window</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_screen</span> <span class="token operator">*</span>screen<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 展示窗口</span>
	<span class="token function">SDL_ShowWindow</span><span class="token punctuation">(</span>screen<span class="token operator">-&gt;</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">sc_screen_render</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_screen</span> <span class="token operator">*</span>screen<span class="token punctuation">,</span> bool update_content_rect<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// SDL模板代码，将上下文中的数据渲染到窗口上</span>
	<span class="token function">SDL_RenderClear</span><span class="token punctuation">(</span>screen<span class="token operator">-&gt;</span>renderer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">SDL_RenderCopy</span><span class="token punctuation">(</span>screen<span class="token operator">-&gt;</span>renderer<span class="token punctuation">,</span> screen<span class="token operator">-&gt;</span>texture<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>screen<span class="token operator">-&gt;</span>rect<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">SDL_RenderPresent</span><span class="token punctuation">(</span>screen<span class="token operator">-&gt;</span>renderer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>所以我们知道这个函数的作用就是打开窗口并把frame数据（即解码后的YUV）渲染到窗口中。源头就是<code>EVENT_NEW_FRAME</code>这个事件。那么这个事件是哪里发来的呢。就是前面的<code>on_new_frame </code>回调，对应的是<code>sc_video_buffer_on_new_frame</code>函数：</p> 
<pre><code class="prism language-c"><span class="token comment">// screen.c</span>
<span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">sc_video_buffer_on_new_frame</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_video_buffer</span> <span class="token operator">*</span>vb<span class="token punctuation">,</span> bool previous_skipped<span class="token punctuation">,</span>
                             <span class="token keyword">void</span> <span class="token operator">*</span>userdata<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 这里将EVENT_NEW_FRAME通过SDL的事件机制发出</span>
	<span class="token keyword">static</span> SDL_Event new_frame_event <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	          <span class="token punctuation">.</span>type <span class="token operator">=</span> EVENT_NEW_FRAME<span class="token punctuation">,</span>
	      <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token function">SDL_PushEvent</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>new_frame_event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>看到这里，我们的流程图就可以填充完整了。<br> <img src="https://images2.imgbox.com/43/1c/QqASKOyH_o.png" alt="在这里插入图片描述"></p> 
<p>到目前为止，视频流这一块基本上已经分析完毕，这部分的数据走的是video_socket。上篇提到，还有一个control_socket，主要用于控制事件传输，比如鼠标键盘控制，也就是投屏中的反控功能，这也是投屏业务非常重要的一个环节，下面我们来看这部分。</p> 
<h3><a id="24_sc_keyboard_inject_init__sc_mouse_inject_init___496"></a>2.4 <code>sc_keyboard_inject_init</code> &amp; <code>sc_mouse_inject_init</code> - 键鼠事件</h3> 
<p>因为键盘和鼠标整体的逻辑差不多，所以这里我们追下键盘的流程，鼠标就不赘述。<code>sc_keyboard_inject_init</code>的主要功能就是注册键盘回调：</p> 
<pre><code class="prism language-c"><span class="token comment">// mouse_inject.c</span>
<span class="token keyword">void</span>
<span class="token function">sc_keyboard_inject_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_keyboard_inject</span> <span class="token operator">*</span>ki<span class="token punctuation">,</span>
                        <span class="token keyword">struct</span> <span class="token class-name">sc_controller</span> <span class="token operator">*</span>controller<span class="token punctuation">,</span>
                        <span class="token keyword">enum</span> <span class="token class-name">sc_key_inject_mode</span> key_inject_mode<span class="token punctuation">,</span>
                        bool forward_key_repeat<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	 <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sc_key_processor_ops</span> ops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">.</span>process_key <span class="token operator">=</span> sc_key_processor_process_key<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>process_text <span class="token operator">=</span> sc_key_processor_process_text<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

	ki<span class="token operator">-&gt;</span>key_processor<span class="token punctuation">.</span>ops <span class="token operator">=</span> <span class="token operator">&amp;</span>ops<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">sc_key_processor_process_key</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_key_processor</span> <span class="token operator">*</span>kp<span class="token punctuation">,</span>
                             <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sc_key_event</span> <span class="token operator">*</span>event<span class="token punctuation">,</span>
                             <span class="token class-name">uint64_t</span> ack_to_wait<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">sc_controller_push_msg</span><span class="token punctuation">(</span>ki<span class="token operator">-&gt;</span>controller<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

bool
<span class="token function">sc_controller_push_msg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_controller</span> <span class="token operator">*</span>controller<span class="token punctuation">,</span>
                       <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sc_control_msg</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 键盘事件入队列</span>
	<span class="token function">cbuf_push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>controller<span class="token operator">-&gt;</span>queue<span class="token punctuation">,</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到键盘事件最终会放到队列中。那么键盘事件是哪里来的呢？就是前一节的<code>event_loop</code>。SDL会自动检测窗口收到的键盘和鼠标事件，只需要在<code>event_loop</code>中监听对应事件即可，最终会触发事件回调：</p> 
<pre><code class="prism language-c"><span class="token comment">// input_manager.c</span>
<span class="token keyword">void</span>
<span class="token function">sc_input_manager_handle_event</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_input_manager</span> <span class="token operator">*</span>im<span class="token punctuation">,</span> SDL_Event <span class="token operator">*</span>event<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token operator">-&gt;</span>type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// ...</span>
		<span class="token keyword">case</span> SDL_KEYDOWN<span class="token operator">:</span>
        <span class="token keyword">case</span> SDL_KEYUP<span class="token operator">:</span>
            <span class="token function">sc_input_manager_process_key</span><span class="token punctuation">(</span>im<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token operator">-&gt;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">sc_input_manager_process_key</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_input_manager</span> <span class="token operator">*</span>im<span class="token punctuation">,</span>
                             <span class="token keyword">const</span> SDL_KeyboardEvent <span class="token operator">*</span>event<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 调用process_key回调</span>
	im<span class="token operator">-&gt;</span>kp<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">process_key</span><span class="token punctuation">(</span>im<span class="token operator">-&gt;</span>kp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>evt<span class="token punctuation">,</span> ack_to_wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>所以目前为止，键盘鼠标事件的流程是：<br> <img src="https://images2.imgbox.com/af/26/IooyW8DN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="25_sc_controller_start___554"></a>2.5 <code>sc_controller_start</code> - 事件的收发</h3> 
<p>这里说的事件手法主要是和手机侧的事件交互，我们来看下是怎么做的：</p> 
<pre><code class="prism language-c">bool
<span class="token function">sc_controller_start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_controller</span> <span class="token operator">*</span>controller<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">sc_thread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>controller<span class="token operator">-&gt;</span>thread<span class="token punctuation">,</span> run_controller<span class="token punctuation">,</span>
                               <span class="token string">"scrcpy-ctl"</span><span class="token punctuation">,</span> controller<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">receiver_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>controller<span class="token operator">-&gt;</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool
<span class="token function">receiver_start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">receiver</span> <span class="token operator">*</span>receiver<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">sc_thread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>receiver<span class="token operator">-&gt;</span>thread<span class="token punctuation">,</span> run_receiver<span class="token punctuation">,</span>
                               <span class="token string">"scrcpy-receiver"</span><span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>sc_controller_start</code>函数会开两个线程，一个负责收，一个负责发：</p> 
<ul><li> <p>收线程 - 主要从手机侧收粘贴板事件，手机侧触发的复制操作，会将数据传至PC侧，PC会放到粘贴板中。这里不细说，感兴趣的同学可以自行追下源码。</p> </li><li> <p>发线程 - 将PC侧的事件发给手机。这是我们关注的重点，我们看下<code>run_controller</code>函数的核心逻辑：</p> </li></ul> 
<pre><code class="prism language-c"><span class="token comment">// controller.c</span>
<span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">run_controller</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 从队列里取事件</span>
		<span class="token function">cbuf_take</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>controller<span class="token operator">-&gt;</span>queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 处理事件</span>
		<span class="token function">process_msg</span><span class="token punctuation">(</span>controller<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> bool
<span class="token function">process_msg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sc_controller</span> <span class="token operator">*</span>controller<span class="token punctuation">,</span>
            <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sc_control_msg</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 通过control_socket将事件发出去</span>
	<span class="token function">net_send_all</span><span class="token punctuation">(</span>controller<span class="token operator">-&gt;</span>control_socket<span class="token punctuation">,</span> serialized_msg<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>发线程的主要逻辑就是一个死循环，不断地从队列中取事件，然后通过control_socket发出去。</p> 
<p>所以键鼠事件的流程可以完善一下了：<br> <img src="https://images2.imgbox.com/52/f9/yvFQrIPd_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="26__603"></a>2.6 时序图</h3> 
<p>老规矩，抛出一张投屏阶段的时序图。不同的颜色代表不同的线程。</p> 
<p><img src="https://images2.imgbox.com/bc/5e/7BHgaBCK_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3__608"></a>3. 小结</h2> 
<p>这一篇我们探究了Scrcpy Client端投屏阶段的逻辑。涉及的点有FFmpeg解码、SDL的窗口绘制和键盘鼠标反控。</p> 
<p>至此Client端的逻辑已经介绍完了，分为连接阶段和投屏阶段。下一篇我们就要探究Server端，也就是手机侧的功能逻辑了，下篇见。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0df06d2d400993678d2567ffc78204e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">5年软件测试工程师分享的自动化测试经验，一定要看</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e3ea378844de7ee2df294d5db4e9ebe8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NSIS入门教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>