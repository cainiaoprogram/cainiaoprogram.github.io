<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Redis】的后台启动方法、相关数据类型、配置文件及Redis的测试 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Redis】的后台启动方法、相关数据类型、配置文件及Redis的测试" />
<meta property="og:description" content="本文是在阿里云服务器上进行的学习redis，因此gcc等安装操作不需要进行，可以直接进行安装redis，在安装完成之后，我们进行以下的学习。本次学习的redis安装路径为/usr/local/bin,安装的步骤可以参照尚硅谷教程进行安装。 目录
1.Redis的后台启动（推荐）
2.Redis相关知识介绍
2.1 Redis 键(key)
2.2 Redis 字符串(String)
2.3. Redis 列表(List)
2.4. Redis 集合(Set)
2.5. Redis 哈希(Hash)
2.6. Redis 有序集合 Zset(sorted set)
3.配置文件
3.1 单位
3.2 INCLUDES 包含 3.3 网络相关配置
bind protected-mode
3.4 GENERAL 通用设置
3.5 SECURITY 安全
4.Redis 的发布和订阅
5.Redis 新数据类型
5.1 Bitmaps(位操作)
合理地使用操作位能够有效地提高内存使用率和开发效率。
5.2 HyperLogLog(统计)
5.3 Geospatial(经纬度)
6.Redis_Jedis_测试
创建maven工程后引入Jedis 所需要的 jar 包
6.1 操作key
6.2 完成一个手机验证码功能
04-概述和安装_哔哩哔哩_bilibilihttps://www.bilibili.com/video/BV1Rv41177Af?p=4&amp;vd_source=7b32287884d43c4ae590e89cdf55a096
1.Redis的后台启动（推荐） [root@iZuf6085c1lnhffxqh52xzZ bin]# redis-server /etc/redis.conf [root@iZuf6085c1lnhffxqh52xzZ bin]# ps -ef | grep redis root 66433 1 0 19:42 ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1a33a81eb6ee7fc6e75f227f5a7803f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-05T19:52:17+08:00" />
<meta property="article:modified_time" content="2023-03-05T19:52:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Redis】的后台启动方法、相关数据类型、配置文件及Redis的测试</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li>本文是在阿里云服务器上进行的学习redis，因此gcc等安装操作不需要进行，可以直接进行安装redis，在安装完成之后，我们进行以下的学习。</li><li>本次学习的redis安装路径为/usr/local/bin,安装的步骤可以参照尚硅谷教程进行安装。</li></ul> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.Redis%E7%9A%84%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89-toc" style="margin-left:0px;"><a href="#1.Redis%E7%9A%84%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89" rel="nofollow">1.Redis的后台启动（推荐）</a></p> 
<p id="2.Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#2.Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D" rel="nofollow">2.Redis相关知识介绍</a></p> 
<p id="2.1%20Redis%20%E9%94%AE(key)-toc" style="margin-left:40px;"><a href="#2.1%20Redis%20%E9%94%AE%28key%29" rel="nofollow">2.1 Redis 键(key)</a></p> 
<p id="2.2%20Redis%20%E5%AD%97%E7%AC%A6%E4%B8%B2(String)-toc" style="margin-left:40px;"><a href="#2.2%20Redis%20%E5%AD%97%E7%AC%A6%E4%B8%B2%28String%29" rel="nofollow">2.2 Redis 字符串(String)</a></p> 
<p id="2.3.%20Redis%20%E5%88%97%E8%A1%A8(List)-toc" style="margin-left:40px;"><a href="#2.3.%20Redis%20%E5%88%97%E8%A1%A8%28List%29" rel="nofollow">2.3. Redis 列表(List)</a></p> 
<p id="2.4.%20Redis%20%E9%9B%86%E5%90%88(Set)-toc" style="margin-left:40px;"><a href="#2.4.%20Redis%20%E9%9B%86%E5%90%88%28Set%29" rel="nofollow">2.4. Redis 集合(Set)</a></p> 
<p id="2.5.%20Redis%20%E5%93%88%E5%B8%8C(Hash)-toc" style="margin-left:40px;"><a href="#2.5.%20Redis%20%E5%93%88%E5%B8%8C%28Hash%29" rel="nofollow">2.5. Redis 哈希(Hash)</a></p> 
<p id="2.6.%20Redis%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%20Zset(sorted%20set)-toc" style="margin-left:40px;"><a href="#2.6.%20Redis%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%20Zset%28sorted%20set%29" rel="nofollow">2.6. Redis 有序集合 Zset(sorted set)</a></p> 
<p id="3.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:0px;"><a href="#3.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">3.配置文件</a></p> 
<p id="3.1%20%E5%8D%95%E4%BD%8D-toc" style="margin-left:40px;"><a href="#3.1%20%E5%8D%95%E4%BD%8D" rel="nofollow">3.1 单位</a></p> 
<p id="3.2%20INCLUDES%20%E5%8C%85%E5%90%AB%C2%A0-toc" style="margin-left:40px;"><a href="#3.2%20INCLUDES%20%E5%8C%85%E5%90%AB%C2%A0" rel="nofollow">3.2 INCLUDES 包含 </a></p> 
<p id="3.3%20%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#3.3%20%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE" rel="nofollow">3.3 网络相关配置</a></p> 
<p id="bind%C2%A0-toc" style="margin-left:80px;"><a href="#bind%C2%A0" rel="nofollow">bind </a></p> 
<p id="protected-mode-toc" style="margin-left:80px;"><a href="#protected-mode" rel="nofollow">protected-mode</a></p> 
<p id="3.4%C2%A0GENERAL%20%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#3.4%C2%A0GENERAL%20%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE" rel="nofollow">3.4 GENERAL 通用设置</a></p> 
<p id="3.5%20SECURITY%20%E5%AE%89%E5%85%A8-toc" style="margin-left:40px;"><a href="#3.5%20SECURITY%20%E5%AE%89%E5%85%A8" rel="nofollow">3.5 SECURITY 安全</a></p> 
<p id="4.Redis%20%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85-toc" style="margin-left:0px;"><a href="#4.Redis%20%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85" rel="nofollow">4.Redis 的发布和订阅</a></p> 
<p id="5.Redis%20%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#5.Redis%20%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">5.Redis 新数据类型</a></p> 
<p id="5.1%20Bitmaps(%E4%BD%8D%E6%93%8D%E4%BD%9C)-toc" style="margin-left:80px;"><a href="#5.1%20Bitmaps%28%E4%BD%8D%E6%93%8D%E4%BD%9C%29" rel="nofollow">5.1 Bitmaps(位操作)</a></p> 
<p id="%E5%90%88%E7%90%86%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E4%BD%8D%E8%83%BD%E5%A4%9F%E6%9C%89%E6%95%88%E5%9C%B0%E6%8F%90%E9%AB%98%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87%E5%92%8C%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E3%80%82-toc" style="margin-left:80px;"><a href="#%E5%90%88%E7%90%86%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E4%BD%8D%E8%83%BD%E5%A4%9F%E6%9C%89%E6%95%88%E5%9C%B0%E6%8F%90%E9%AB%98%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87%E5%92%8C%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E3%80%82" rel="nofollow">合理地使用操作位能够有效地提高内存使用率和开发效率。</a></p> 
<p id="5.2%C2%A0HyperLogLog(%E7%BB%9F%E8%AE%A1)-toc" style="margin-left:80px;"><a href="#5.2%C2%A0HyperLogLog%28%E7%BB%9F%E8%AE%A1%29" rel="nofollow">5.2 HyperLogLog(统计)</a></p> 
<p id="5.3%C2%A0Geospatial(%E7%BB%8F%E7%BA%AC%E5%BA%A6)-toc" style="margin-left:80px;"><a href="#5.3%C2%A0Geospatial%28%E7%BB%8F%E7%BA%AC%E5%BA%A6%29" rel="nofollow">5.3 Geospatial(经纬度)</a></p> 
<p id="%C2%A06.Redis_Jedis_%E6%B5%8B%E8%AF%95-toc" style="margin-left:0px;"><a href="#%C2%A06.Redis_Jedis_%E6%B5%8B%E8%AF%95" rel="nofollow"> 6.Redis_Jedis_测试</a></p> 
<p id="%E5%88%9B%E5%BB%BAmaven%E5%B7%A5%E7%A8%8B%E5%90%8E%E5%BC%95%E5%85%A5Jedis%20%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%20jar%20%E5%8C%85-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BAmaven%E5%B7%A5%E7%A8%8B%E5%90%8E%E5%BC%95%E5%85%A5Jedis%20%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%20jar%20%E5%8C%85" rel="nofollow">创建maven工程后引入Jedis 所需要的 jar 包</a></p> 
<p id="6.1%20%E6%93%8D%E4%BD%9Ckey-toc" style="margin-left:80px;"><a href="#6.1%20%E6%93%8D%E4%BD%9Ckey" rel="nofollow">6.1 操作key</a></p> 
<p id="6.2%C2%A0%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#6.2%C2%A0%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD" rel="nofollow">6.2 完成一个手机验证码功能</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><a class="has-card" href="https://www.bilibili.com/video/BV1Rv41177Af?p=4&amp;vd_source=7b32287884d43c4ae590e89cdf55a096" rel="nofollow" title="04-概述和安装_哔哩哔哩_bilibili"><span class="link-card-box"><span class="link-title">04-概述和安装_哔哩哔哩_bilibili</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/4c/c7/B84XWlzs_o.png">https://www.bilibili.com/video/BV1Rv41177Af?p=4&amp;vd_source=7b32287884d43c4ae590e89cdf55a096</span></span></a></p> 
<h2 id="1.Redis%E7%9A%84%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89">1.Redis的后台启动（推荐）</h2> 
<pre><code class="language-Go">[root@iZuf6085c1lnhffxqh52xzZ bin]# redis-server /etc/redis.conf
[root@iZuf6085c1lnhffxqh52xzZ bin]# ps -ef | grep redis
root       66433       1  0 19:42 ?        00:00:00 redis-server 127.0.0.1:6379
root       66439   66386  0 19:43 pts/0    00:00:00 grep --color=auto redis
[root@iZuf6085c1lnhffxqh52xzZ bin]# redis-cli
127.0.0.1:6379&gt; </code></pre> 
<ul><li>首先在usr/local/bin目录下运行<strong><span style="background-color:#a2e043;"> redis-server /etc/redis.conf，这个命令是我们的启动命令。</span></strong></li><li><span style="background-color:#a2e043;">ps -ef | grep redis可以查看Redis是否启动</span>了，从上面的运行结果可以知道Redis的端口号为<strong>6379。</strong></li><li><strong><span style="background-color:#a2e043;"> redis-cli</span></strong>：使用客户端连接Redis，测试验证--在其中输入ping会有pong回复。</li><li>Redis关闭：<strong>进入终端使用shutdown关闭</strong>或者在<strong>bin目录下使用redis-cli shutdown.</strong></li></ul> 
<h2 id="2.Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D">2.Redis相关知识介绍</h2> 
<p><strong>Redis有五大常用数据类型，分别为:</strong></p> 
<ul><li>Redis 键(key)</li><li>Redis 字符串(String)</li><li>Redis 列表(List)</li><li>Redis 集合(Set)</li><li>Redis 哈希(Hash)</li><li>Redis 有序集合 Zset(sorted set)</li></ul> 
<h3 id="2.1%20Redis%20%E9%94%AE(key)">2.1 Redis 键(key)</h3> 
<pre><code class="language-html">[root@iZuf6085c1lnhffxqh52xzZ ~]# redis-cli
127.0.0.1:6379&gt; keys *
(empty array)
127.0.0.1:6379&gt; set k1 caojiajun
OK
127.0.0.1:6379&gt; set k2 jiangwei
OK
127.0.0.1:6379&gt; set k3 icezrj
OK
127.0.0.1:6379&gt; exist k1
(error) ERR unknown command `exist`, with args beginning with: `k1`, 
127.0.0.1:6379&gt; exists k1
(integer) 1
127.0.0.1:6379&gt; exists k4
(integer) 0
127.0.0.1:6379&gt; type k3
string
127.0.0.1:6379&gt; del k3
(integer) 1
127.0.0.1:6379&gt; keys *
1) "k1"
2) "k2"
127.0.0.1:6379&gt; unlink k2
(integer) 1
127.0.0.1:6379&gt; keys *
1) "k1"
127.0.0.1:6379&gt; expire k1 20
(integer) 1
127.0.0.1:6379&gt; keys *
1) "k1"
127.0.0.1:6379&gt; ttl k1
(integer) -2
127.0.0.1:6379&gt; set k2 zeyein
OK
127.0.0.1:6379&gt; set k3 huge
OK
127.0.0.1:6379&gt; keys *
1) "k3"
2) "k2"
127.0.0.1:6379&gt; set k1 icezrj
OK
127.0.0.1:6379&gt; keys *
1) "k1"
2) "k3"
3) "k2"
127.0.0.1:6379&gt; </code></pre> 
<p><img alt="" height="769" src="https://images2.imgbox.com/4d/be/hPOPy9Wy_o.png" width="1200"></p> 
<p><strong><span style="background-color:#ffd900;"> 特别注意：-2表示已经过期，-1表示永不过期（del删除和unlink删除的区别）</span></strong></p> 
<pre><code class="language-html">127.0.0.1:6379&gt; select 1
OK
127.0.0.1:6379[1]&gt; select 4
OK
127.0.0.1:6379[4]&gt; select 0
OK
127.0.0.1:6379&gt; dbsize
(integer) 3
127.0.0.1:6379&gt; flushdb
OK
127.0.0.1:6379&gt; dbsize
(integer) 0
127.0.0.1:6379&gt; flushall
OK
127.0.0.1:6379&gt; 
[root@iZuf6085c1lnhffxqh52xzZ ~]# 
</code></pre> 
<p><img alt="" height="725" src="https://images2.imgbox.com/63/c1/7N01hUtF_o.png" width="1200"></p> 
<p><strong><span style="background-color:#a2e043;"> flushdb和flushall在现实中用的比较少，dbsize表示查看当前库中（key）键的数量。</span></strong></p> 
<ul><li><strong>keys * </strong>查看当前库所有key (匹配: keys *1)</li><li><strong>exists key </strong>判断某个key是否存在</li><li><strong>type key </strong>查看你的key是什么类型</li><li><strong>del key </strong>删除指定的key数据</li><li><strong>unlink key </strong>根据value选择非阻塞删除 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li><li><strong>expire key 10</strong>  10 秒钟:为给定的key设置过期时间</li><li><strong>ttl key </strong>查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</li><li><strong>select </strong>命令切换数据库</li><li><strong>dbsize </strong>查看当前数据库的key的数量</li><li><strong>flushdb </strong>清空当前库</li><li><strong>flushall </strong>通杀全部库<br>  </li></ul> 
<h3 id="2.2%20Redis%20%E5%AD%97%E7%AC%A6%E4%B8%B2(String)">2.2 Redis 字符串(String)</h3> 
<pre><code class="language-html">127.0.0.1:6379&gt; keys *
(empty array)
127.0.0.1:6379&gt; set k1 v120
OK
127.0.0.1:6379&gt; set k2 v122
OK
127.0.0.1:6379&gt; keys *
1) "k1"
2) "k2"
127.0.0.1:6379&gt; get k1
"v120"
127.0.0.1:6379&gt; get k2
"v122"
127.0.0.1:6379&gt; set k2 v1314
OK
127.0.0.1:6379&gt; get k2
"v1314"
127.0.0.1:6379&gt; append k2 502
(integer) 8
127.0.0.1:6379&gt; get k2
"v1314502"
127.0.0.1:6379&gt; strlen k2
(integer) 8
127.0.0.1:6379&gt; strlen k1
(integer) 4
127.0.0.1:6379&gt; setnx k1 123
(integer) 0
127.0.0.1:6379&gt; decr k2
(error) ERR value is not an integer or out of range
127.0.0.1:6379&gt; set k3 123
OK
127.0.0.1:6379&gt; incr k3
(integer) 124
127.0.0.1:6379&gt; decr k33
(integer) -1
127.0.0.1:6379&gt; decr k3
(integer) 123
127.0.0.1:6379&gt; decr k2
(error) ERR value is not an integer or out of range
127.0.0.1:6379&gt; get k3
"123"
127.0.0.1:6379&gt; incrby k3 10
(integer) 133
127.0.0.1:6379&gt; decrby k3 30
(integer) 103
127.0.0.1:6379&gt; keys *
1) "k1"
2) "k33"
3) "k3"
4) "k2"
127.0.0.1:6379&gt; mset k1 1 k2 2 k3 5
OK
127.0.0.1:6379&gt; mget k1 k2 k3
1) "1"
2) "2"
3) "5"
127.0.0.1:6379&gt; msetnx k1 3 k4 6
(integer) 0
127.0.0.1:6379&gt; msetnx k4 6 k5 66
(integer) 1
127.0.0.1:6379&gt; 
</code></pre> 
<p><strong><span style="background-color:#a2e043;">incr是原子操作：所谓原子操作是指不会被线程调度机制打断的操作</span></strong></p> 
<ul><li>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是"原子操作"，因为中 断只能发生于指令之间。</li><li>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。 Redis 单命令的原子性主要得益于 Redis 的单线程。</li><li><span style="background-color:#ffd900;"><strong>mset  &lt;key1&gt;&lt;value&gt;&lt;key2&gt;&lt;value&gt;&lt;key3&gt;&lt;value&gt;.....</strong>同时设置一个或多个 key-value </span></li><li><span style="background-color:#ffd900;"><strong>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;  </strong>同时获取一个或多个 value</span></li><li><span style="background-color:#ffd900;"><strong>msetnx &lt;key1&gt;&lt;value&gt;&lt;key2&gt;&lt;value&gt;&lt;key3&gt;&lt;value&gt;.....</strong>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</span>。</li><li><strong>get &lt;key&gt;</strong> 查询对应键值</li><li><strong>append &lt;key&gt; &lt;value&gt;</strong>将给定的&lt;value&gt;追加到原值的末尾</li><li><strong>strlen &lt;key&gt; </strong>获得值的长度</li><li><strong>setnx &lt;key&gt; &lt;value&gt;</strong>只有在key不存在时设置 key的值</li><li><strong>incr &lt;key&gt;</strong>将key中储存的数字值增1,<span style="background-color:#ffd900;">只能对数字值操作，如果为空，新增值为1</span></li><li><strong>decr &lt;key&gt;</strong>将key中储存的数字值减1,<span style="background-color:#ffd900;">只能对数字值操作，如果为空,新增值为-1</span></li><li><strong>incrby / decrby &lt;key&gt; &lt;步长&gt;</strong>将key中储存的数字值增减。自定义步长。<br>  </li></ul> 
<h3 id="2.3.%20Redis%20%E5%88%97%E8%A1%A8(List)">2.3. Redis 列表(List)</h3> 
<ul><li><strong>lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt; &lt;value3&gt; ...  </strong>从左边/右边插入-个或多个值。</li><li><strong>lpop/rpop &lt;key&gt; </strong>从左边/右边吐出一一个值。 值在键在，值光键亡。</li><li><strong>rpoplpush &lt;key1&gt; &lt;key2&gt; </strong>从&lt;key1&gt;列表右边吐出一个值， 插到&lt;key2&gt;列表左边。</li><li><strong>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; </strong>按照索引下标获得元素(从左到右)</li><li><strong>lrange mylist0-1 0 </strong>左边第一个，-1 右边第一个，(0-1 表示获取所有)</li><li><strong>lindex &lt;key&gt; &lt;index&gt; </strong>按照索引下标获得元素(从左到右)</li><li><strong>llen &lt;key&gt;</strong> 获得列表长度</li><li><strong>linsert &lt;key&gt; before &lt;value&gt; &lt;newvalue&gt; </strong>在&lt;value&gt;的后面插入&lt;newvalue &gt;插入值</li><li><strong>Irem &lt;key&gt; &lt;n&gt; &lt;value&gt; </strong>从左边删除n个value(从左到右)</li><li><strong>Iset &lt;key&gt; &lt;index&gt; &lt;value&gt; </strong>将列表key下标为index的值替换成value<br>  </li></ul> 
<h3 id="2.4.%20Redis%20%E9%9B%86%E5%90%88(Set)">2.4. Redis 集合(Set)</h3> 
<p>Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以<strong><span style="background-color:#ff9900;">自动排重</span></strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选 择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所 不能提供的。</p> 
<ul><li><strong>sadd. &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ....          </strong>将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略</li><li><strong>smembers &lt;key&gt;  </strong>取出该集合的所有值。</li><li><strong>sismember &lt;key&gt; &lt;value&gt;   </strong>  判断集合&lt;key&gt;是否为含有该&lt;value&gt;值,有1,没有0</li><li><strong>scard &lt;key&gt;    </strong>返回该集合的元素个数。</li><li><strong>srem &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ...    </strong>删除集合中的某个元素。</li><li><strong>spop &lt;key&gt;    </strong>随机从该集合中吐出一个值。</li><li><strong>srandmember &lt;key&gt; &lt;n&gt;    </strong>随机从该集合中取出n个值。不会从集合中删除。</li><li><strong>smove &lt;source&gt; &lt;destination&gt;value    </strong>把集合中一个值从-一个集合移动到另一个集合</li><li><strong>sinter &lt;key1&gt; &lt;key2&gt;    </strong>返回两个集合的交集元素。</li><li><strong>sunion &lt;key1&gt; &lt;key2&gt; </strong>   返回两个集合的并集元素。</li><li><strong>sdiff &lt;key1&gt; &lt;key2&gt; </strong>   返回两个集合的差集元素(key1中的,不包含key2中的)<br>  </li></ul> 
<h3 id="2.5.%20Redis%20%E5%93%88%E5%B8%8C(Hash)">2.5. Redis 哈希(Hash)</h3> 
<p>Redis hash 是一个键值对集合。 Redis hash 是一个 string 类型的 <strong><span style="background-color:#ff9900;">field </span></strong>和 <strong><span style="background-color:#ff9900;">value </span></strong>的映射表，hash 特别适合用于存储对象。 类似 Java 里面的 Map 用户 ID 为查找的 key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用 普通的 key/value 结构来存储</p> 
<ul><li><strong>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;  </strong>     给&lt;key&gt;集合中的&lt;field&gt; 键赋值&lt;value&gt;</li><li><strong>hget &lt;keyl&gt;&lt;field&gt;</strong>      从&lt;key1&gt;集合&lt;field&gt;取出value</li><li><strong>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...  </strong>    批量设置hash的值</li><li><strong>hexists&lt;key1&gt;&lt;field&gt;</strong>      查看哈希表key中，给定域field 是否存在。</li><li><strong>hkeys &lt;key&gt; </strong>      列出该hash集合的所有field</li><li><strong>hvals &lt;key&gt;  </strong>    列出该hash集合的所有value</li><li><strong>hincrby &lt;key&gt;&lt;field&gt;&lt; increment&gt;  </strong>    为哈希表key中的域field 的值加.上增量1 -1</li><li><strong>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</strong>      将哈希表key中的域field 的值设置为value ，当且仅当域field不存在.</li></ul> 
<h3 id="2.6.%20Redis%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%20Zset(sorted%20set)">2.6. Redis 有序集合 Zset(sorted set)</h3> 
<p>Redis 有序集合 zset 与普通集合 set 非常相似，是一个没有重复元素的字符串集合。</p> 
<p><strong><span style="background-color:#a2e043;">不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用 来按照从最低分到最高分的方式排序集合中的成员</span></strong>。集合的成员是唯一的，但是评分 可以是重复了 。</p> 
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获 取一个范围的元素。 访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成 员的智能列表。</p> 
<ul><li><strong>zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;...      </strong>   将一个或多个member元素及其score值加入到有序集key当中。</li><li><strong><span style="color:#fe2c24;">zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [WITHSCORES] </span>  </strong>       返回有序集key中，下标在&lt;start&gt;&lt;stop&gt; 之间的元素 带WITHSCORES,可以让分数-起和值返回到结果集。</li><li><strong>zrangebyscore key minmax [withscores] [limit offset count]  </strong>         返回有序集key中，所有score 值介于min和max之间(包括等于min或max )的成员。</li><li>有序集成员按score值递增(从小到大)次序排列。</li><li><strong>zrevrangebyscore key maxmin [withscores] [limit offset count]   </strong>   同上，改为从大到小排列。</li><li><strong>zincrby &lt;key&gt; &lt;increment&gt; &lt;value&gt;    </strong>为元素的score加上增量</li><li><strong>zrem &lt;key&gt; &lt;value&gt;       </strong>删除该集合下，指定值的元素</li><li><strong>zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;       </strong>统计该集合,分数区间内的元素个数</li><li><strong>zrank &lt;key&gt; &lt;value&gt;        </strong>返回该值在集合中的排名，从0开始。<br>  </li></ul> 
<h2 id="3.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">3.配置文件</h2> 
<p>在安装Redis之后是将配置文件放在了目录/etc/redis.conf下面，使用vi命令将其打开，现在对其进行分析。</p> 
<h3 id="3.1%20%E5%8D%95%E4%BD%8D">3.1 单位</h3> 
<p>配置大小单位,开头定义了一些基本的度量单位，<strong><span style="background-color:#a2e043;">只支持 bytes，不支持 bit 大小写不敏感。</span></strong></p> 
<pre><code>[root@iZuf6085c1lnhffxqh52xzZ ~]# vi /etc/redis.conf

# Redis configuration file example.
#
# Note that in order to read the configuration file, Redis must be
# started with the file path as first argument:
#
# ./redis-server /path/to/redis.conf

# Note on units: when memory size is needed, it is possible to specify
# it in the usual form of 1k 5GB 4M and so forth:
#
# 1k =&gt; 1000 bytes
# 1kb =&gt; 1024 bytes
# 1m =&gt; 1000000 bytes
# 1mb =&gt; 1024*1024 bytes
# 1g =&gt; 1000000000 bytes
# 1gb =&gt; 1024*1024*1024 bytes
#
# units are case insensitive so 1GB 1Gb 1gB are all the same.
</code></pre> 
<p><img alt="" height="605" src="https://images2.imgbox.com/2a/45/o5JlqDk6_o.png" width="1200"></p> 
<h3 id="3.2%20INCLUDES%20%E5%8C%85%E5%90%AB%C2%A0">3.2 INCLUDES 包含 </h3> 
<p><strong><span style="background-color:#a2e043;">类似 jsp 中的 include</span></strong>，多实例的情况可以把公用的配置文件提取出来</p> 
<pre><code># Include one or more other config files here.  This is useful if you
# have a standard template that goes to all Redis servers but also need
# to customize a few per-server settings.  Include files can include
# other files, so use this wisely.
#
# Note that option "include" won't be rewritten by command "CONFIG REWRITE"
# from admin or Redis Sentinel. Since Redis always uses the last processed
# line as value of a configuration directive, you'd better put includes
# at the beginning of this file to avoid overwriting config change at runtime.
#
# If instead you are interested in using includes to override configuration
# options, it is better to use include as the last line.
#
# include /path/to/local.conf
# include /path/to/other.conf
</code></pre> 
<h3 id="3.3%20%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE">3.3 网络相关配置</h3> 
<ul><li> <h4 id="bind%C2%A0"><strong>bind </strong></h4> </li></ul> 
<p><img alt="" height="590" src="https://images2.imgbox.com/13/27/5ucDFrhk_o.png" width="1200">默认情况 bind=127.0.0.1 只能接受本机的访问请求不写的情况下<strong><span style="background-color:#a2e043;">（注释后），无限制接受任何 ip 地址的访问。</span></strong></p> 
<ul><li> <h4 id="protected-mode"><strong>protected-mode</strong></h4> </li></ul> 
<p><strong><span style="background-color:#a2e043;">将本机访问保护模式设置为no才能进行远程连接。</span></strong></p> 
<p><img alt="" height="591" src="https://images2.imgbox.com/3e/da/42Yv6FCR_o.png" width="1200"></p> 
<ul><li><strong> Port</strong></li></ul> 
<p><strong><span style="background-color:#a2e043;">端口号，默认 6379</span></strong></p> 
<ul><li><strong> tcp-backlog</strong></li></ul> 
<p>设置 tcp 的 backlog，backlog 其实是一个连接队列，backlog 队列总和=未完成三次握手 队列 + 已经完成三次握手队列。</p> 
<p>在高并发环境下你需要一个高 backlog 值来避免慢客户端连接问题。</p> 
<p>注意 Linux 内核会将这个值减小到/proc/sys/net/core/somaxconn 的值（128），所以需要 确认增大/proc/sys/net/core/somaxconn 和/proc/sys/net/ipv4/tcp_max_syn_backlog（128） 两个值来达到想要的效果</p> 
<ul><li><strong>timeout</strong></li></ul> 
<p>一个空闲的客户端维持多少秒会关闭，<strong><span style="background-color:#a2e043;">0 表示关闭该功能。即永不关闭</span></strong>。</p> 
<p><img alt="" height="714" src="https://images2.imgbox.com/da/17/KVOUrbQ0_o.png" width="1200"></p> 
<ul><li><strong>tcp-keepalive</strong></li></ul> 
<p>对访问客户端的一种心跳检测，每个 n 秒检测一次。 单位为秒，如果设置为 0，则不会进行 Keepalive 检测，<strong>建议设置成 60</strong></p> 
<p><img alt="" height="318" src="https://images2.imgbox.com/73/dd/NKXnQL5N_o.png" width="1200"></p> 
<h3 id="3.4%C2%A0GENERAL%20%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE">3.4 <strong>GENERAL 通用设置</strong></h3> 
<ul><li><strong>daemonize</strong></li></ul> 
<p><span style="background-color:#a2e043;">是否为后台进程，设置为 yes 守护进程，后台启动</span></p> 
<ul><li><strong>pidfile</strong></li></ul> 
<p>存放 pid 文件的位置，每个实例会产生一个不同的 pid 文件</p> 
<ul><li><strong>loglevel</strong></li></ul> 
<p>指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默 认为 <strong><span style="color:#fe2c24;">notice</span></strong></p> 
<ul><li><strong>logfile</strong></li></ul> 
<p>日志文件名称(默认为空)</p> 
<ul><li><strong>databases 16</strong></li></ul> 
<p><strong><span style="color:#0d0016;"><span style="background-color:#a2e043;">设定库的数量 默认 16，默认数据库为 0，可以使用 SELECT 命令在连接上指定 数据库 id</span></span></strong></p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/96/23/wlzTuQU6_o.png" width="1200"></p> 
<p> <strong><img alt="" height="202" src="https://images2.imgbox.com/3d/ed/7Fq6pent_o.png" width="1200"></strong></p> 
<h3 id="3.5%20SECURITY%20%E5%AE%89%E5%85%A8">3.5 SECURITY 安全</h3> 
<ul><li><strong>设置密码</strong></li></ul> 
<p>在命令中设置密码，只是临时的。重启 redis 服务器，密码就还原了。 <strong><span style="background-color:#a2e043;">永久设置，需要再配置文件中进行设置。</span></strong></p> 
<p><strong><span style="color:#fef2f0;"><span style="background-color:#fe2c24;">在文件下使用"/"可以进行搜索</span></span></strong></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/a6/56/yb5HmCIC_o.png" width="1200"></p> 
<p><img alt="" height="431" src="https://images2.imgbox.com/63/74/p82DvHsw_o.png" width="687"><strong> </strong></p> 
<p><span style="background-color:#ffd900;">本文就不进行设置了。</span></p> 
<ul><li><strong>LIMITS 限制</strong></li></ul> 
<p>➢<span style="background-color:#4da8ee;">设置 redis 同时可以与多少个客户端进行连接。 </span></p> 
<p>➢<span style="background-color:#4da8ee;"> 默认情况下为 10000 个客户端。</span></p> 
<p>➢<span style="background-color:#4da8ee;">如果达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出 “max number of clients reached”以作回应。</span></p> 
<ul><li><strong>maxmemory</strong></li></ul> 
<p>➢ <span style="background-color:#4da8ee;">建议必须设置，否则，将内存占满，造成服务器宕机</span></p> 
<p>➢ <span style="background-color:#4da8ee;">设置 redis 可以使用的内存量。一旦到达内存使用上限，redis 将会试图移除内部数 据，移除规则可以通过 maxmemory-policy 来指定。</span></p> 
<h2 id="4.Redis%20%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85">4.Redis 的发布和订阅</h2> 
<p>Redis 发布订阅 (pub/sub) 是<strong><span style="background-color:#a2e043;">一种消息通信模式</span></strong>：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。</p> 
<p><strong>发布订阅命令行实现:</strong></p> 
<ul><li><span style="color:#0d0016;"><strong><span style="background-color:#9c8ec1;">打开一个客户端订阅 channel1</span></strong></span></li></ul> 
<pre><code>SUBSCRIBE channel1</code></pre> 
<ul><li><span style="color:#0d0016;"><strong><span style="background-color:#9c8ec1;">打开另一个客户端，给 channel1 发布消息 hello</span></strong></span></li></ul> 
<pre><code>publish channel1 hello
#返回的 1 是订阅者数量
</code></pre> 
<ul><li><span style="color:#0d0016;"><strong><span style="background-color:#9c8ec1;">打开第一个客户端可以看到发送的消息</span></strong></span></li></ul> 
<p><span style="color:#fe2c24;">注：发布的消息没有持久化，如果在订阅的客户端收不到 hello，只能收到订阅后发布 的消息</span></p> 
<h2 id="5.Redis%20%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">5.Redis 新数据类型</h2> 
<h4 id="5.1%20Bitmaps(%E4%BD%8D%E6%93%8D%E4%BD%9C)">5.1 Bitmaps(位操作)</h4> 
<h4 id="%E5%90%88%E7%90%86%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E4%BD%8D%E8%83%BD%E5%A4%9F%E6%9C%89%E6%95%88%E5%9C%B0%E6%8F%90%E9%AB%98%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87%E5%92%8C%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E3%80%82">合理地使用操作位能够有效地提高内存使用率和开发效率。</h4> 
<p><span style="background-color:#a2e043;">Redis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：</span></p> 
<ul><li><strong> Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value）， 但是它可以对字符串的位进行操作。 </strong></li><li><strong> Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字 符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。</strong></li></ul> 
<p><strong>命令：setbit</strong></p> 
<p><strong><span style="background-color:#ffd900;">setbit&lt;key&gt; &lt;offset&gt; &lt;value&gt;           设置Bitmaps中某个偏移量的值(0 或1)。</span></strong><br>  </p> 
<p>统计每个用户是否访问过某个网站。===&gt;</p> 
<ul><li>每个独立用户是否访问过网站存放在 Bitmaps 中， 将访问的用户记做 1， 没有 访问的用户记做 0， 用偏移量作为用户的 id。</li><li>设置键的第 offset 个位的值（从 0 算起） ， 假设现在有 20 个用户，userid=1， 6， 11， 15， 19 的用户对网站进行了访问， 那么当前 Bitmaps 初始化结果如图</li><li>在第一次初始化 Bitmaps 时， 假如偏移量非常大， 那么整个初始化过程执行会 比较慢， 可能会造成 Redis 的阻塞</li></ul> 
<p><strong>命令：getbit</strong></p> 
<p><strong><span style="background-color:#ffd900;">getbit &lt;key&gt; &lt;offset&gt;                         获取Bitmaps中某个偏移量的值</span></strong></p> 
<p></p> 
<p><br> 获取 id=8 的用户是否在 2020-11-06 这天访问过， 返回 0 说明没有访问过：</p> 
<p><strong>命令：bitop</strong></p> 
<p>计算出两天都访问过网站的用户数量===&gt;</p> 
<p><strong><span style="background-color:#ffd900;">bitop and unique:users:and:20201104_03 unique:users:20201103unique:users:20201104</span></strong></p> 
<p></p> 
<p><strong>命令：Bitmaps 与 set 对比</strong></p> 
<ul><li>很明显， 这种情况下使用 Bitmaps 能节省很多的内存空间， 尤其是随着时间推 移节省的内存还是非常可观的。</li><li>但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10 万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用 Bitmaps 就不太合适了， 因为基本上大部分位都是 0。</li></ul> 
<p></p> 
<h4 id="5.2%C2%A0HyperLogLog(%E7%BB%9F%E8%AE%A1)">5.2 HyperLogLog(统计)</h4> 
<p><strong>命令: pfadd(<span style="color:#fe2c24;">去重</span>)</strong></p> 
<p><strong><span style="background-color:#ffd900;">pfadd &lt;key&gt; &lt; element&gt; [element ..]添加指定元素到 HyperLogLog中</span></strong></p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/94/bc/BAsKnKjJ_o.png" width="1200"><br> 将所有元素添加到指定 HyperLogLog 数据结构中。如果执行命令后 HLL 估计的 近似基数发生变化，则返回 1，否则返回 0。</p> 
<pre><code>[root@iZuf6085c1lnhffxqh52xzZ ~]# redis-cli
127.0.0.1:6379&gt; pfadd zrj "jiangwei"
(integer) 1
127.0.0.1:6379&gt; pfadd zrj "java"
(integer) 1
127.0.0.1:6379&gt; pfadd zrj "c++"
(integer) 1
127.0.0.1:6379&gt; pfadd zrj "c++"
(integer) 0
127.0.0.1:6379&gt; pfcount zrj 
(integer) 3
127.0.0.1:6379&gt; </code></pre> 
<p><strong>命令：<span style="color:#0d0016;">pfmerge(</span><span style="color:#fe2c24;">合并</span><span style="color:#0d0016;">)</span></strong></p> 
<p><strong><span style="color:#0d0016;"><span style="background-color:#ffd900;">pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey]               将-个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</span></span></strong><br><img alt="" height="697" src="https://images2.imgbox.com/82/51/0i8rMecW_o.png" width="1200"></p> 
<p></p> 
<h4 id="5.3%C2%A0Geospatial(%E7%BB%8F%E7%BA%AC%E5%BA%A6)">5.3 Geospatial(经纬度)</h4> 
<p>GEO，Geographic，地理信息的缩写。</p> 
<p>该类型，就是<span style="color:#fe2c24;"><strong>元素的 2 维坐标</strong></span>，在地图上就是经纬度。redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。</p> 
<p><strong>命令：geoadd（添加一个或者多个经纬度坐标）</strong></p> 
<pre><code>127.0.0.1:6379&gt; geoadd china:city 121.37 31.23 shanghai
(integer) 1
127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing
(integer) 3
127.0.0.1:6379&gt; 
</code></pre> 
<ul><li><strong>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</strong></li><li><strong>有效的经度从 -180 度 到 180 度 。 有 效 的纬 度 从 -85.05112878 度 到 85.05112878 度。 当坐标位置超出指定范围时，该命令将会返回一个错误。</strong></li><li><strong>已经添加的数据，是无法再次往里面添加的。</strong></li></ul> 
<p><strong>命令：geopos（获取指定位置经纬度）</strong></p> 
<p><strong><span style="background-color:#ffd900;">geopos &lt;key&gt; &lt;member&gt; [member..]  获得指定地区的坐标值</span></strong></p> 
<p><strong>命令：geodist</strong><strong>（获取指定两个位置的直线距离）</strong></p> 
<p><strong><span style="background-color:#ffd900;">geodist&lt;key&gt; &lt;member1&gt; &lt;member2&gt;[m|km|ft|mi ]     获取两个位置之间的直线距离</span></strong><br>  </p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/25/24/OZNFpiRr_o.png" width="1200"></p> 
<p><strong> 命令：georadius（范围）</strong></p> 
<p><strong><span style="background-color:#ffd900;">georadius&lt;key&gt; &lt; longitude&gt; &lt;latitude&gt;radius  m|km|ft|mi   以给定的经纬度为中心,找出某一半径内的元素</span></strong><br><img alt="" height="212" src="https://images2.imgbox.com/99/0e/8g4tg9qG_o.png" width="1200"></p> 
<h2 id="%C2%A06.Redis_Jedis_%E6%B5%8B%E8%AF%95"> 6.Redis_Jedis_测试</h2> 
<h4 id="%E5%88%9B%E5%BB%BAmaven%E5%B7%A5%E7%A8%8B%E5%90%8E%E5%BC%95%E5%85%A5Jedis%20%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%20jar%20%E5%8C%85"><span style="background-color:#38d8f0;">创建maven工程后引入Jedis 所需要的 jar 包</span></h4> 
<p><img alt="" height="899" src="https://images2.imgbox.com/f3/a1/xNUqZhTe_o.png" width="1200"></p> 
<p> 由于引入3.2.0版本我们的idea会报错，于是我们引入2.9.0版本的jedis。</p> 
<pre><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
            &lt;version&gt;2.9.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<p><span style="color:#fe2c24;"><strong>在进行操作之前我们需要确保/etc/redis.conf中的bind 127.0.0.1 -::1是注释完成还有protected-mode yes改成protected-mode no。 之后保存这个文件后再重启一下redis，这里可以在本文开头查看如何重启操作，还有将服务器的防火墙规则添加6379端口。（如果是虚拟机则只需要将自己的防火墙关闭 systemctl stop firewalld）</strong></span></p> 
<p><img alt="" height="761" src="https://images2.imgbox.com/ed/c6/RbYMEfe8_o.png" width="1200"></p> 
<p><img alt="" height="790" src="https://images2.imgbox.com/5b/33/Bn2RYA7q_o.png" width="1200"></p> 
<pre><code class="language-java">package com.atzrj.jedis;

import redis.clients.jedis.Jedis;

/**
 * @Program:jedis_redis
 * @description：jedis
 * @author: 
 * @create: 2022-11-17 11
 **/

public class jedisDemo1 {

    public static void main(String[] args) {
        //创建jedis对象
        Jedis jedis = new Jedis("此处填写自己的虚拟机ip",6379);
        //测试
        String value = jedis.ping();
        System.out.printf(value);
    }


}
</code></pre> 
<p></p> 
<p><img alt="" height="792" src="https://images2.imgbox.com/a3/21/rmWgbPvL_o.png" width="1200"> 运行后查看我们ping得到的值PONG。</p> 
<h4 id="6.1%20%E6%93%8D%E4%BD%9Ckey"><strong>6.1 操作key</strong></h4> 
<p><img alt="" height="830" src="https://images2.imgbox.com/1f/df/RaOMei8d_o.png" width="1200"></p> 
<p> <img alt="" height="215" src="https://images2.imgbox.com/70/a4/DhV9n62s_o.png" width="1200"></p> 
<p> 向redis中添加键值k1,k2,k3,并且获取k3的对应值（value）：<img alt="" height="842" src="https://images2.imgbox.com/fb/30/mp7Ug1Vt_o.png" width="1200"></p> 
<pre><code class="language-java">System.out.println(jedis.exists("k1"));//查看键值k1是否存在
System.out.println(jedis.ttl("k1")); //查看k1还有多少秒过期,-1 表示永不过期，-2 表示已过期
System.out.println(jedis.get("k1"));</code></pre> 
<p><img alt="" height="776" src="https://images2.imgbox.com/81/e4/vUOxl2Uk_o.png" width="1200"></p> 
<p> 这里的各种操作和方法可以自行完成，这里不一一演示。</p> 
<h4 id="6.2%C2%A0%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD"><strong>6.2 </strong>完成一个手机验证码功能</h4> 
<p>要求：</p> 
<ul><li>1、输入手机号，点击发送后随机生成6位数字码，2分钟有效</li><li>2、输入验证码，点击验证，返回成功或失败</li><li>3、每个手机号每天只能输入3次</li></ul> 
<pre><code class="language-java">package com.atzrj.jedis;

import java.util.Random;

/**
 * @Program:jedis_redis
 * @description：jedis
 * @author: j
 * @create: 2022-11-17 18
 **/

public class PhoneCode {

    public static void main(String[] args) {
        String code = getCode();
        System.out.println(code);
    }


    //生成六位数字验证码
    public static String getCode() {
        Random random = new Random();
        String code = "";
        for (int i = 0; i &lt; 6; i++) {
            int rand = random.nextInt(10);//生成10以内的值
            code += rand;
        }
        return code;

    }


}
</code></pre> 
<p>在完成编写一个生成6位数的类之后，还要完成两点钟内有效和每天只能输入三次，两分钟内有效可以想到使用redis中的<strong>expire key times</strong> 设置键值的过期时间。</p> 
<p></p> 
<p><img alt="" height="974" src="https://images2.imgbox.com/d7/e0/pG2MtvH2_o.png" width="1200"></p> 
<p> <img alt="" height="330" src="https://images2.imgbox.com/b8/98/lrvMQhTQ_o.png" width="1200"></p> 
<p> 如果报上面的错误输入下面这行代码在redis中再次运行即可。</p> 
<pre><code>config set stop-writes-on-bgsave-error no</code></pre> 
<p><img alt="" height="735" src="https://images2.imgbox.com/31/bd/N7EYwpe6_o.png" width="1200"> <img alt="" height="609" src="https://images2.imgbox.com/4c/b1/2xVGWI2H_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-java">package com.atzrj.jedis;

import redis.clients.jedis.Jedis;

import java.util.Random;

/**
 * @Program:jedis_redis
 * @description：jedis
 * @author: j
 * @create: 2022-11-17 18
 **/

public class PhoneCode {

    public static void main(String[] args) {
        //模拟验证码发送
        verifyCode("17779141914");
    }


    //1.生成六位数字验证码
    public static String getCode() {
        Random random = new Random();
        String code = "";
        for (int i = 0; i &lt; 6; i++) {
            int rand = random.nextInt(10);//生成10以内的值
            code += rand;
        }
        return code;
    }

    //2.每个手机每天只能发送三次，验证码放到redis中，设置过期时间
    public static void verifyCode(String phone){
        //连接redis
        Jedis jedis = new Jedis("IP地址", 6379);
        //拼接key
        //手机发送次数key
        String countkey = "VerifyCode"+phone+":count";
        //验证码key
        String codekey  = "VerifyCode"+phone+":code";
        //每个手机每天只能发送三次
        String count = jedis.get(countkey);
            //没有发送次数，第一次发送
            //设置发送次数为1
            if (count==null){
                jedis.setex(countkey,24*60*60,"1");
            }else if (Integer.parseInt(count)&lt;=2){
                //发送次数+1
                jedis.incr(countkey);
            }else if (Integer.parseInt(count)&gt;2){
                //发送三次，不能在发送了
                System.out.println("今天发送次数已达上限!");
                jedis.close();
                return;//不返回验证码仍会更新，虽然次数已经达到上限
            }
        //发送的验证码要放到redis中去
        String vcode = getCode();
        jedis.setex(codekey,120,vcode);
        jedis.close();
        }

    //3.验证码校验
    public static void getRedisCode(String phone,String code){
        //从redis中获取验证码
        Jedis jedis = new Jedis("IP地址", 6379);
        //验证码key
        String codekey  = "VerifyCode"+phone+":code";
        String redisCode = jedis.get(codekey);
        //判断
        if (redisCode.equals(code)){
            System.out.println("成功~");
        }else {
            System.out.println("失败！");
        }
        jedis.close();
    }

}




</code></pre> 
<p>声明：本文仅为博主在学习redis时的学习笔记。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2ce2f12b99c5f5f6c808e58093a9eba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Umi使用百度地图服务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/faf44a03b5466bca957700baca692902/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【CSS】CSS 复合选择器 ② ( 子元素选择器 | 交集选择器 )</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>