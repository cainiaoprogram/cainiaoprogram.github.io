<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【密码学】密码学中的常见概念简介 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【密码学】密码学中的常见概念简介" />
<meta property="og:description" content="一、对称密码（共享钥匙密码）---用相同的密钥进行加密和解密 1.何为编码？ 将现实世界的东西映射为比特序列的操作称为编码（encoding）。例如midnight这个词，我们就可以对其中每个字逐一进行编码，这种编码规则叫做ASCII。
2.XOR 0 XOR 0 = 0
0 XOR 1 = 1
1 XOR 0 = 1
1 XOR 1 = 0
也就是说相同则为0，不同则为1。
将结果与其中一项重新新异或（XOR），可以还原另外一项。
用于与明文异或的随机比特序列就是密钥，与明文异或得到的结果就是密文，将密钥重新与密文异或可以得到明文。
3.一次性密码本 号称永远不会被破译的加密方式，事实上的确是这样。然而没卵用，就是将保护明文变成了保护与明文相同长度的密钥，没有根本性解决问题。
4.DES（Data Encryption Standard） DES已经能够被暴力破解。所以不推荐使用哦。
DES是以64比特的明文为一个单位进行加密的，这个64比特的单位称为分组。
它的密钥长度是56比特，尽管从规格上说，DES密钥长度是64比特，但由于每隔7比特就会设置一个用于错误检查的比特，实质上是56比特。
DES的结构（Feistel网络）
Feistel网络中，加密的各个步骤称为轮（round），整个加密过程就是若干次轮的循环。
DES是一种16轮循环的Feistel网络。
DES一轮的具体计算步骤如下：
将输入的数据等分为左右两部分。将输入的右侧直接发送到输出的右侧。将输入的右侧发送到轮函数。轮函数根据右侧数据和子密钥，计算出一串看上去随机的比特序列。将上一步得到的比特序列与左侧数据进行XOR运算，并将结果作为加密后的左侧。 通过上面的步骤来看，“右侧”根本就没有加密，因此需要每两轮处理只见将左侧和右侧数据对调。
用相同的子密钥重新运行一轮即可还原。
加密和解密使用完全相同的结构来实现。
5.三重DES 三重DES是为了增加DES的强度，将DES重复三次所得到的一种密码算法，也称为TDEA，通常缩写为3DES。
三重DES并不是进行三次DES加密（加密-加密-加密），而是（加密-解密-加密）。这是IBM公司设计出来的，目的是为了让三重DES能够兼容普通的DES（三次密钥相同即为普通的DES，但是浪费运算。）
三重DES的解密与加密完全相反，为（解密-加密-解密）。
6.AES 1997年，NIST开始公开募集AES。
AES的选拔，不仅考虑一种算法是否存在弱点，算法的强度，实现的容易性等也在考虑范围内。不仅加密本身的速度要快，密钥准备的速度也很重要。此外，还需要能够在各种平台上有效工作。
2000年，Rijindeal力压群雄，被NIST选定为AES标准。
在AES规格中，分组长度固定为128比特，密钥长度有128、192和256比特三种。
与DES一样，Rijindeal算法也是由多个轮构成，其中每一轮分为SubBytes、ShiftRows、MixColumns和AddRoundKey共四个步骤。
AES没有使用Feistel网络作为基本结构，而是使用了SPN结构。
AES一轮的步骤如下：
SubBytes 逐字节（1字节为8比特）替换，（在字节中对比特进行替换）4*4=16字节。ShiftRows处理，这一步是将以4字节为单位的row按照一定的规则向左平移，且每一行平移的字节数是不同的。MixColumns处理，这一步是对一个4字节的值进行比特运算，将其变为另外一个4字节的值。最后需要将MixColumns的输出与轮密码进行XOR，即AddRoundKey处理。 AES需要重复进行10~14轮计算。
AES的解密就是将上述步骤反过来。
二、分组密码的模式 ---分组密码是如何迭代的 DES和AES都属于分组密码，他们只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码迭代的方法就成为分组密码的“模式”。
分组密码有多种模式，如果模式选择不恰当，就无法充分保证机密性。
1.分组密码和流密码 分组密码是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组。此外，一个分组的比特数就称为分组长度。
如DES和三重DES的分组长度都是64比特，AES将128比特明文转化为128比特密文。
DES将64比特明文转换为64比特密文，AES将128比特明文转化为128比特密文。
流密码是对数据进行连续处理的一类密码算法。流密码一般以1比特、8比特或32比特等为单位进行加密和解密。
分组密码处理完一个分组就结束了，因此不需要通过内部状态记录它加密的进度；相对的，流密码是对一串数据流进行连续处理，因此需要保持内部状态。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c72fca7b0ea9bcf601fab3834e1497ae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-15T12:58:50+08:00" />
<meta property="article:modified_time" content="2023-09-15T12:58:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【密码学】密码学中的常见概念简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、对称密码（共享钥匙密码）---用相同的密钥进行加密和解密</h2> 
<h3> 1.何为编码？</h3> 
<p>将现实世界的东西映射为比特序列的操作称为编码（encoding）。例如midnight这个词，我们就可以对其中每个字逐一进行编码，这种编码规则叫做ASCII。</p> 
<h3>2.XOR</h3> 
<p>0 XOR 0 = 0</p> 
<p>0 XOR 1 = 1</p> 
<p>1 XOR 0 = 1</p> 
<p>1 XOR 1 = 0</p> 
<p>也就是说相同则为0，不同则为1。</p> 
<p>将结果与其中一项重新新异或（XOR），可以还原另外一项。</p> 
<p>用于与明文异或的随机比特序列就是密钥，与明文异或得到的结果就是密文，将密钥重新与密文异或可以得到明文。</p> 
<h3>3.一次性密码本</h3> 
<p>号称永远不会被破译的加密方式，事实上的确是这样。然而没卵用，就是将保护明文变成了保护与明文相同长度的密钥，没有根本性解决问题。</p> 
<h3>4.DES（Data Encryption  Standard）</h3> 
<p>DES已经能够被暴力破解。所以不推荐使用哦。</p> 
<p>DES是以64比特的明文为一个单位进行加密的，这个64比特的单位称为分组。</p> 
<p>它的密钥长度是56比特，尽管从规格上说，DES密钥长度是64比特，但由于每隔7比特就会设置一个用于错误检查的比特，实质上是56比特。</p> 
<p>DES的结构（Feistel网络）</p> 
<p>Feistel网络中，加密的各个步骤称为轮（round），整个加密过程就是若干次轮的循环。</p> 
<p>DES是一种16轮循环的Feistel网络。</p> 
<p>DES一轮的具体计算步骤如下：</p> 
<ol><li>将输入的数据等分为左右两部分。</li><li>将输入的右侧直接发送到输出的右侧。</li><li>将输入的右侧发送到轮函数。</li><li>轮函数根据右侧数据和子密钥，计算出一串看上去随机的比特序列。</li><li>将上一步得到的比特序列与左侧数据进行XOR运算，并将结果作为加密后的左侧。</li></ol> 
<p>通过上面的步骤来看，“右侧”根本就没有加密，因此需要每两轮处理只见将左侧和右侧数据对调。</p> 
<p>用相同的子密钥重新运行一轮即可还原。</p> 
<p>加密和解密使用完全相同的结构来实现。</p> 
<h3>5.三重DES</h3> 
<p>三重DES是为了增加DES的强度，将DES重复三次所得到的一种密码算法，也称为TDEA，通常缩写为3DES。</p> 
<p>三重DES并不是进行三次DES加密（加密-加密-加密），而是（加密-解密-加密）。这是IBM公司设计出来的，目的是为了让三重DES能够兼容普通的DES（三次密钥相同即为普通的DES，但是浪费运算。）</p> 
<p>三重DES的解密与加密完全相反，为（解密-加密-解密）。</p> 
<h3>6.AES</h3> 
<p>1997年，NIST开始公开募集AES。</p> 
<p>AES的选拔，不仅考虑一种算法是否存在弱点，算法的强度，实现的容易性等也在考虑范围内。不仅加密本身的速度要快，密钥准备的速度也很重要。此外，还需要能够在各种平台上有效工作。</p> 
<p>2000年，Rijindeal力压群雄，被NIST选定为AES标准。</p> 
<p>在AES规格中，分组长度固定为128比特，密钥长度有128、192和256比特三种。</p> 
<p>与DES一样，Rijindeal算法也是由多个轮构成，其中每一轮分为SubBytes、ShiftRows、MixColumns和AddRoundKey共四个步骤。</p> 
<p>AES没有使用Feistel网络作为基本结构，而是使用了SPN结构。</p> 
<p>AES一轮的步骤如下：</p> 
<ol><li>SubBytes 逐字节（1字节为8比特）替换，（在字节中对比特进行替换）4*4=16字节。</li><li>ShiftRows处理，这一步是将以4字节为单位的row按照一定的规则向左平移，且每一行平移的字节数是不同的。</li><li>MixColumns处理，这一步是对一个4字节的值进行比特运算，将其变为另外一个4字节的值。</li><li>最后需要将MixColumns的输出与轮密码进行XOR，即AddRoundKey处理。</li></ol> 
<p>AES需要重复进行10~14轮计算。</p> 
<p>AES的解密就是将上述步骤反过来。</p> 
<hr> 
<h2>二、分组密码的模式 ---分组密码是如何迭代的</h2> 
<p>DES和AES都属于分组密码，他们只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码迭代的方法就成为分组密码的“模式”。</p> 
<p>分组密码有多种模式，如果模式选择不恰当，就无法充分保证机密性。</p> 
<h3>1.分组密码和流密码</h3> 
<p> 分组密码是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组。此外，一个分组的比特数就称为分组长度。</p> 
<p>如DES和三重DES的分组长度都是64比特，AES将128比特明文转化为128比特密文。</p> 
<p>DES将64比特明文转换为64比特密文，AES将128比特明文转化为128比特密文。</p> 
<p>流密码是对数据进行连续处理的一类密码算法。流密码一般以1比特、8比特或32比特等为单位进行加密和解密。</p> 
<p>分组密码处理完一个分组就结束了，因此不需要通过内部状态记录它加密的进度；相对的，流密码是对一串数据流进行连续处理，因此需要保持内部状态。</p> 
<p>上面的介绍中，只有一次性密码本属于流密码，DES和AES都属于分组密码。</p> 
<h3>2.什么是模式？</h3> 
<p>明文长度超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密，而迭代的方法就称为分组密码的模式。</p> 
<p>如果明文很长的话，将明文分割成若干个分组再进行逐个加密，这种方式就是ECB模式，<strong><span style="color:#fe2c24;">ECB模式是很蠢的，千万不要用ECB模式！</span></strong></p> 
<h3>3.明文分组和密文分组</h3> 
<p>明文分组是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。</p> 
<p>密文分组是指使用分组密码算法将明文分组加密之后所生成的密文。</p> 
<h3>4.模式</h3> 
<h4>1.ECB模式</h4> 
<p>ECB模式，将明文分组加密后的结果直接称为密文分组。可以将其看做一个巨大的“明文分组-密文分组”的对应表，因此ECB被称为电子密码本模式。</p> 
<h4>2.CBC模式</h4> 
<p>CBC模式叫做密文分组链接模式，之所以叫这个名字，是因为密文分组像链条一样互相连接在一起的。</p> 
<p>在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。</p> 
<p>当加密第一个明文时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组长的的比特序列来代替“前一个密文分组”。这个比特序列称为初始化向量（initalization Vector），通常缩写为IV。</p> 
<p>一般来说，每次加密时都会随机生成一个不同的比特序列来作为初始化向量。</p> 
<p>CBC模式如果有一个分组损坏了，最多之后有两个分组受到影响。如果有一些比特缺失了，缺失比特之后的密文分组都无法破解了。</p> 
<h4>3.CFB模式</h4> 
<p>CFB模式全称是密文反馈模式。</p> 
<p>在CFB模式中，前一个密文分组会被送回到密码算法的输入端。所谓反馈，这里指的就是返回输入端的意思。</p> 
<p>与CBC模式不同的是，CBC先异或再加密，CFB先加密再异或。</p> 
<h4>4.OFB模式</h4> 
<p>OFB模式全称是输出反馈模式。</p> 
<p>在OFB模式中，密码算法的输出会反馈到密码算法的输入中。</p> 
<p>就是将初始化向量一直加密，每加密一次就将加密结果与一组明文进行异或一次得到一组密文。</p> 
<h4>5.CTR模式</h4> 
<p>CTR模式全称是计数器模式。</p> 
<p>CTR模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。</p> 
<p>也就是将计数器CTR加密后与明文进行异或得到密文分组，然后下次将计数器CTR+1再加密后与下一组明文进行异或得到下一组密文分组。</p> 
<h4>6.模式对照表</h4> 
<table align="center" border="3" cellpadding="1" cellspacing="1"><thead><tr><th>模式</th><th>全称</th><th>优点</th><th>缺点</th><th>备注</th></tr></thead><tbody><tr><td>ECB模式</td><td>电子密码本模式</td><td> <p>1.简单</p> <p>2.快速</p> <p>3.支持并行运算</p> </td><td> <p>1.明文中的重复排列会反映在密文中。</p> <p>2.通过删除、替换密文分组可以对明文进行操作。</p> <p>3.对包含某些比特的错误的密文进行解密时，对应的分组会出错。</p> <p>4.不能抵御重放攻击。</p> </td><td>不应使用</td></tr><tr><td>CBC模式</td><td>密文分组链式模式</td><td> <p>1.明文的重复排列不会反映在密文中</p> <p>2.支持并行运算（仅解密）</p> <p>3.能够解密任意密文分组</p> </td><td> <p>1.对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错。</p> <p>2.加密不支持并行计算</p> </td><td> <p>CRYPTREC推荐</p> <p>实用密码学推荐</p> </td></tr><tr><td>CFB模式</td><td>密文反馈模式</td><td> <p>1.不需要填充</p> <p>2.支持并行计算（仅解密）</p> <p>3.能够解密任意密文分组</p> </td><td> <p>1.加密不支持并行计算</p> <p>2.对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个相应比特会出错。</p> <p>3.不能抵御重放攻击。</p> </td><td>CRYPTREC推荐</td></tr><tr><td>OFB模式</td><td>输出反馈模式</td><td> <p>1.不需要填充</p> <p>2.可事先进行加密、解密的准备</p> <p>3.加密、解密使用相同结构</p> <p>4.对包含某些错误比特的密文进行解密时，只有明文中对应的比特会出错。</p> </td><td> <p>1.不支持并行计算</p> <p>2.主动攻击反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转</p> </td><td>CRYPTREC推荐</td></tr><tr><td>CTR模式</td><td>计数器模式</td><td> <p>1.不需要填充</p> <p>2.可事先进行加密、解密的准备</p> <p>3.加密、解密使用相同结构</p> <p>4.对包含某些错误比特的密文进行解密时，只有明文中相应的比特会出错。</p> <p>5.支持并行计算（加密、解密）</p> </td><td>1.主动攻击者反转密文中的某些比特时，明文分组中相对应的比特也会被反转。</td><td> <p>CRYPTREC推荐</p> <p>实用密码学推荐</p> </td></tr></tbody></table> 
<p></p> 
<hr> 
<h2>三、公钥密码 ---用公钥加密，用私钥解密</h2> 
<h3>1.什么是公钥密码？</h3> 
<p>公钥密码中，密钥分为加密秘钥和解密秘钥两种。</p> 
<p>1.发送者只需要加密密钥。</p> 
<p>2.接收者只需要解密密钥。</p> 
<p>3.解密密钥不可以被窃听者获取。</p> 
<p>4.加密密钥被窃听者获取也没关系。</p> 
<p>公钥密码也有不同的称谓，如非对称密码。</p> 
<p>它的处理速度只有对称密码的几百分之一。</p> 
<p>RSA利用大数质因数分解的难度。</p> 
<p>EIGamal利用mod N下求离散对数的困难度。</p> 
<p>Rabin利用mod N下求平方根的困难度。</p> 
<p>椭圆曲线密码 利用了乘法运算的逆运算非常困难的这一特性。它的特点是所需的秘钥长度比RSA短。</p> 
<hr> 
<h2>四、混合密码系统 ---用对称密码提高速度，用公钥密码保护会话密钥。</h2> 
<hr> 
<h2>五、单向散列函数</h2> 
<h3>1.什么是单向散列函数？</h3> 
<p>单向散列函数（One-way hash function）是指一种将任意长度的消息映射到固定长度的散列值（hash值）的函数，这种函数是单向的，即无法通过散列值反推出原始消息。常用的单向散列函数有MD5、SHA-1、SHA-256等。</p> 
<p>弱抗碰撞性指的是对一组输入数据，难以找到另一组不同的输入数据映射到相同的散列值。如果有人在不知道原始输入的情况下能够找到两个不同的输入，它们散列后的结果相同，那么这个单向散列函数就被认为是弱抗碰撞性的。</p> 
<p>强抗碰撞性指对于所有的输入数据，都无法找到两个不同的输入映射到相同的散列值。也就是说，在计算这个单向散列函数时，输入数据的所有位的变化都应该能够导致散列值的完全不同。如果有人能找到两个不同的输入，它们散列后的结果相同，那么这个单向散列函数就被认为是强抗碰撞性的。</p> 
<p>强抗碰撞性比弱抗碰撞性更加重要，因为强抗碰撞性是保证一个单向散列函数在实际应用中安全性的基础。如果一个单向散列函数不具备强抗碰撞性，那么攻击者可能会通过针对性的攻击构造相同的哈希值，从而导致信息泄露或其他安全问题。</p> 
<p>单向散列函数有一个输入和一个输出，其中输入称为消息，输出称为散列值。</p> 
<p>单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。</p> 
<h3>2.单向散列函数的性质</h3> 
<p>1.根据任意长度的消息计算出固定长度的散列值。</p> 
<p>2.能够快速计算出散列值</p> 
<p>3.消息不同散列值也不同</p> 
<p>        难以发现碰撞的性质称为抗碰撞性。单向散列函数必须确保要找到和该条消息具有相同散列值的另外一条消息是非常困难的。这一性质称为弱抗碰撞性。和弱抗碰撞性相对的，还有强抗碰撞性，是指要找到散列值相同的两条不同的消息是非常困难的这一性质。密码技术中所使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。</p> 
<p>4.具备单向性</p> 
<p>        单向散列函数必须具备单向性。单向性指的是无法通过散列值反算出消息的性质。</p> 
<h3>3.关于术语</h3> 
<p>单向散列函数也称为消息摘要函数、哈希函数或者杂凑函数。</p> 
<p>输入单向散列函数的消息也称为原像。</p> 
<p>单向散列函数输出的散列值也称为消息摘要或者指纹。</p> 
<p>完整性也称为一致性。</p> 
<h3>4.单向散列函数的实际应用</h3> 
<ul><li>检测软件是否被篡改。</li><li>基于口令的加密</li><li>消息认证码</li><li>数字签名</li><li>伪随机数生成器（密码技术中所使用的随机数要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。）</li><li>一次性口令</li></ul> 
<h3>5.单向散列函数的具体例子</h3> 
<h4>1.MD4和MD5</h4> 
<p>MD是Message Digest（消息摘要）的缩写。</p> 
<p>MD4和MD5的强抗碰撞性已经被攻破，因此已经不安全了。</p> 
<h4>2.SHA-1、SHA-256、SHA-384、SHA-512</h4> 
<p>SHA-1、SHA-256、SHA-384、SHA-512都是由NIST（National Institute of Standards and Technology 美国国家标准技术研究所）设计的。</p> 
<p>SHA-1的强抗碰撞性已经被山东大学王小云于2005年攻破。</p> 
<p>SHA-2还尚未被攻破。</p> 
<h4>3.RIPEMED-160</h4> 
<p>RIPEMED的强抗碰撞性已经于2004年被攻破，但RIPEMED-160还未被攻破，顺便一提，比特币中使用的就是RIPEMED-160。</p> 
<h4>4.SHA-3</h4> 
<p>即Keccak算法，是NIST采取公开竞争的方式向世界征集的。</p> 
<p>Keccak的结构为海绵结构。</p> 
<p>Keccak的海绵结构中，输入的数据在进行填充之后，要经过吸收阶段和挤出阶段，最终生成输出的散列值。</p> 
<p>吸收阶段的流程如下：</p> 
<ol><li>将经过填充的输入消息按照每r个比特为一组分割成若干个输入分组。</li><li>首先，将“内部状态的r个比特”与“输入分组1”进行XOR，将其结果作为“函数f的输入值”。</li><li>然后，将“函数f的输出值r个比特”与“输入分组2”进行XOR，将其结果再次作为“函数f的输入值”。</li><li>反复执行上述步骤，直到到达最后一个输入分组。</li><li>待所有输入分组处理完成后，结束吸收阶段，进入挤出阶段。</li></ol> 
<p>函数f的作用是将输入的数据进行复杂的搅拌操作并输出结果（输入和输出的长度均为b=r+c个比特），每次被吸收的输入分组长度为r个比特，因此r被称为比特率。c个比特是不受输入分组内容直接影响的（但会通过函数f受到间接影响）。这里c被称为容量。</p> 
<p>挤出阶段的流程如下：</p> 
<ol><li>首先，将“函数f的输出值中的r个比特”保存为“输出分组1”，并将整个输出值（r+c个比特）再次输入到函数f中。</li><li>然后，将“函数f的输出值中的r个比特”保存为“输出分组2”，并将整个输出值（r+c个比特）再次输入到函数f中。</li><li>反复执行上述步骤，直到获得所需长度的输出数据。</li></ol> 
<p>无论是吸收阶段还是挤出阶段，函数f的逻辑本身完全是相同的，每执行一次函数f，海绵结构的内部状态都会被搅拌一次。</p> 
<p>c的意义在于放置将输入消息中的一些特征泄露出去。</p> 
<p>双工结构，输入和输出是以相同的速率进行的。通过双工结构，Keccak不仅可以用于计算散列值，还可以覆盖密码学家的工具箱中的其他多种用途，如伪随机数生成器、流密码、认证加密、消息认证码等。</p> 
<hr> 
<h2>六、消息认证码 ---消息被正确发送了吗</h2> 
<p>可用单向散列函数、AES之类的分组密码、流密码和公钥密码都可以实现消息认证码。</p> 
<hr> 
<h2>七、数字签名 ---消息到底是谁写的？</h2> 
<h3>数字签名和公钥密码的密钥使用方式对比：</h3> 
<table border="3" cellpadding="1" cellspacing="1"><tbody><tr><td></td><td>私钥</td><td>公钥</td></tr><tr><td>公钥密码</td><td>接收者解密时使用</td><td>发送者加密时使用</td></tr><tr><td>数字签名</td><td>签名者生成签名时使用</td><td>验证者验证签名时使用</td></tr><tr><td>谁持有密钥？</td><td>个人持有</td><td>只要需要，任何人都可以持有</td></tr></tbody></table> 
<hr> 
<h2>八、证书</h2> 
<h3>1.什么是证书？</h3> 
<p>公钥证书其实和驾照很相似，里面有姓名，组织，邮箱地址等个人信息，以及属于此人的公钥，并由认证机构（CA）施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为证书。</p> 
<h3>2.证书的应用场景</h3> 
<p>认证机构必须是可信的第三方</p> 
<ol><li>Bob生成密钥对。</li><li>Bob在认证机构注册自己的公钥。</li><li>认证机构用自己的私钥对Bob的公钥施加数字签名并生成证书。</li><li>Alice得到带有认证机构数字签名的Bob的公钥（证书）。</li><li>Alice使用认证机构的公钥验证数字签名，确认Bob的公钥的合法性。</li><li>Alice用Bob的公钥加密消息并发送给Bob。</li></ol> 
<h3>3.公钥基础设施</h3> 
<h4>1.什么是公钥基础设施？</h4> 
<p>公钥基础设施是为了能够更有效地运用公钥而指定的一系列规范和规格的总称PKI。</p> 
<h4>2.PKI的组成要素</h4> 
<p>1.用户 ----使用PKI的人</p> 
<p>        用户就是像Alice、Bob这样使用PKI的人，用户包括两种：一种是希望使用PKI注册自己公钥的人，另一种是希望使用已注册的公钥的人。</p> 
<p>【注册公钥的用户所进行的操作】</p> 
<ol><li>生成密钥对（也可以由认证机构生成）</li><li>在认证机构注册公钥</li><li>向认证机构申请证书</li><li>根据需要申请作废已注册的公钥。</li><li>解密接收到的密文</li><li>对消息进行数字签名</li></ol> 
<p>【使用已注册公钥的用户所进行的操作】</p> 
<ol><li>将消息加密后发送给接收者</li><li>验证数字签名</li></ol> 
<p>2.认证机构 ----颁发证书的人</p> 
<p>【认证机构所做的操作】</p> 
<ol><li>生成密钥对（也可以由用户生成）</li><li>在注册公钥时对本人身份进行验证</li><li>生成并颁发证书</li><li>作废证书</li></ol> 
<p>3.仓库 ----保存证书的数据库</p> 
<p>仓库是一个保存证书的数据库，PKI用户在需要的时候可以从中获取证书，它的作用有点像打电话时用的电话本。仓库也叫作证书目录。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71fdfb935e49c5f7c4de0f6712f37fc3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jsoup | Document | HTML解析器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7672cd3a1e7157ff756997c98d299c17/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaScript之innerHTML和outerHTML，innerText和outerText</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>