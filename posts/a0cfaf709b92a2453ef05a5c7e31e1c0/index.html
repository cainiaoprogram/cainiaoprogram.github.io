<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于Java文件路径问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于Java文件路径问题" />
<meta property="og:description" content="1.如何获得当前文件路径
常用：
字符串类型：System.getProperty(&#34;user.dir&#34;);
综合：
package com.zcjl.test.base;
import java.io.File;
public class Test {
public static void main(String[] args) throws Exception {
System.out.println(
Thread.currentThread().getContextClassLoader().getResource(&#34;&#34;));
System.out.println(Test.class.getClassLoader().getResource(&#34;&#34;));
System.out.println(ClassLoader.getSystemResource(&#34;&#34;));
System.out.println(Test.class.getResource(&#34;&#34;));
System.out.println(Test.class.getResource(&#34;/&#34;));
System.out.println(new File(&#34;&#34;).getAbsolutePath());
System.out.println(System.getProperty(&#34;user.dir&#34;));
}
}
2.Web服务中
(1).Weblogic
WebApplication的系统文件根目录是你的weblogic安装所在根目录。
例如：如果你的weblogic安装在c:\bea\weblogic700.....
那么，你的文件根路径就是c:\.
所以，有两种方式能够让你访问你的服务器端的文件：
a.使用绝对路径：
比如将你的参数文件放在c:\yourconfig\yourconf.properties，
直接使用 new FileInputStream(&#34;yourconfig/yourconf.properties&#34;);
b.使用相对路径：
相对路径的根目录就是你的webapplication的根路径，即WEB-INF的上一级目录，将你的参数文件放在yourwebapp\yourconfig\yourconf.properties，
这样使用：
new FileInputStream(&#34;./yourconfig/yourconf.properties&#34;);
这两种方式均可，自己选择。
(2).Tomcat
在类中输出System.getProperty(&#34;user.dir&#34;);显示的是%Tomcat_Home%/bin
(3).Resin
不是你的JSP放的相对路径,是JSP引擎执行这个JSP编译成SERVLET
的路径为根.比如用新建文件法测试File f = new File(&#34;a.htm&#34;);
这个a.htm在resin的安装目录下 (4).如何读相对路径哪？
在Java文件中getResource或getResourceAsStream均可
例：getClass().getResourceAsStream(filePath);//filePath可以是&#34;/filename&#34;,这里的/代表web发布根路径下WEB-INF/classes
(5).获得文件真实路径
string file_real_path=request.getRealPath(&#34;mypath/filename&#34;); 通常使用request.getRealPath(&#34;/&#34;); 3.文件操作的类
import java.io.*;
import java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a0cfaf709b92a2453ef05a5c7e31e1c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2007-03-29T18:59:25+08:00" />
<meta property="article:modified_time" content="2007-03-29T18:59:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于Java文件路径问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="postText"> 
 <p><font size="3">1.如何获得当前文件路径</font></p> 
 <p><font size="3">常用：</font></p> 
 <p><font size="3">字符串类型：System.getProperty("user.dir");</font></p> 
 <p><font size="3">综合：</font></p> 
 <p><font size="3">package com.zcjl.test.base;<br> import java.io.File;<br> public class Test {<!-- --><br>     public static void main(String[] args) throws Exception {<!-- --><br>         System.out.println(<br></font><font size="3"><font color="#ff0000">            Thread.currentThread().getContextClassLoader().getResource(""));<br>         System.out.println(Test.class.getClassLoader().getResource(""));<br>         System.out.println(ClassLoader.getSystemResource(""));<br>         System.out.println(Test.class.getResource(""));<br>         System.out.println(Test.class.getResource("/"));<br>         System.out.println(new File("").getAbsolutePath());<br>         System.out.println(System.getProperty("user.dir"));</font><br>     }<br> }</font></p> 
 <p><font size="3">2.Web服务中</font></p> 
 <p><font size="3">(1).Weblogic</font></p> 
 <p><font size="3">WebApplication的系统文件根目录是你的weblogic安装所在根目录。<br> 例如：如果你的weblogic安装在c:\bea\weblogic700.....<br> 那么，你的文件根路径就是c:\.<br> 所以，有两种方式能够让你访问你的服务器端的文件：<br> a.使用绝对路径：<br> 比如将你的参数文件放在c:\yourconfig\yourconf.properties，<br> 直接使用 new FileInputStream("yourconfig/yourconf.properties");<br> b.使用相对路径：<br> 相对路径的根目录就是你的webapplication的根路径，即WEB-INF的上一级目录，将你的参数文件放在yourwebapp\yourconfig\yourconf.properties，<br> 这样使用：<br> new FileInputStream("./yourconfig/yourconf.properties");<br> 这两种方式均可，自己选择。</font></p> 
 <p><font size="3">(2).Tomcat</font></p> 
 <p><font size="3">在类中输出System.getProperty("user.dir");显示的是%Tomcat_Home%/bin</font></p> 
 <p><font size="3">(3).Resin</font></p> 
 <p><font size="3">不是你的JSP放的相对路径,是JSP引擎执行这个JSP编译成SERVLET<br> 的路径为根.比如用新建文件法测试File f = new File("a.htm");<br> 这个a.htm在resin的安装目录下 </font></p> 
 <p><font size="3" color="#ff0000">(4).如何读相对路径哪？</font></p> 
 <p><font size="3" color="#ff0000">在Java文件中getResource或getResourceAsStream均可</font></p> 
 <p><font size="3" color="#ff0000">例：getClass().getResourceAsStream(filePath);//filePath可以是"/filename",这里的/代表web发布根路径下WEB-INF/classes</font></p> 
 <p><font size="3">(5).获得文件真实路径</font></p> 
 <p><font size="3">string  file_real_path=request.getRealPath("mypath/filename");  </font></p> 
 <p><font size="3">通常使用request.getRealPath("/");  </font></p> 
 <p><font size="3">3.文件操作的类</font></p> 
 <p><font size="3">import java.io.*;<br> import java.net.*;<br> import java.util.*;<br> //import javax.swing.filechooser.*;<br> //import org.jr.swing.filter.*;</font></p> 
 <p><font size="3">/**<br> * 此类中封装一些常用的文件操作。<br> * 所有方法都是静态方法，不需要生成此类的实例，<br> * 为避免生成此类的实例，构造方法被申明为private类型的。<br> * @since  0.1<br> */</font></p> 
 <p><font size="3">public class FileUtil {<!-- --><br>   /**<br>    * 私有构造方法，防止类的实例化，因为工具类不需要实例化。<br>    */<br>   private FileUtil() {<!-- --></font></p> 
 <p><font size="3">  }</font></p> 
 <p><font size="3">  /**<br>    * 修改文件的最后访问时间。<br>    * 如果文件不存在则创建该文件。<br>    * &lt;b&gt;目前这个方法的行为方式还不稳定，主要是方法有些信息输出，这些信息输出是否保留还在考</font></p> 
 <p><font size="3">虑中。&lt;/b&gt;<br>    * @param file 需要修改最后访问时间的文件。<br>    * @since  0.1<br>    */<br>   public static void touch(File file) {<!-- --><br>     long currentTime = System.currentTimeMillis();<br>     if (!file.exists()) {<!-- --><br>       System.err.println("file not found:" + file.getName());<br>       System.err.println("Create a new file:" + file.getName());<br>       try {<!-- --><br>         if (file.createNewFile()) {<!-- --><br>         //  System.out.println("Succeeded!");<br>         }<br>         else {<!-- --><br>         //  System.err.println("Create file failed!");<br>         }<br>       }<br>       catch (IOException e) {<!-- --><br>       //  System.err.println("Create file failed!");<br>         e.printStackTrace();<br>       }<br>     }<br>     boolean result = file.setLastModified(currentTime);<br>     if (!result) {<!-- --><br>     //  System.err.println("touch failed: " + file.getName());<br>     }<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 修改文件的最后访问时间。<br>    * 如果文件不存在则创建该文件。<br>    * &lt;b&gt;目前这个方法的行为方式还不稳定，主要是方法有些信息输出，这些信息输出是否保留还在考</font></p> 
 <p><font size="3">虑中。&lt;/b&gt;<br>    * @param fileName 需要修改最后访问时间的文件的文件名。<br>    * @since  0.1<br>    */<br>   public static void touch(String fileName) {<!-- --><br>     File file = new File(fileName);<br>     touch(file);<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 修改文件的最后访问时间。<br>    * 如果文件不存在则创建该文件。<br>    * &lt;b&gt;目前这个方法的行为方式还不稳定，主要是方法有些信息输出，这些信息输出是否保留还在考</font></p> 
 <p><font size="3">虑中。&lt;/b&gt;<br>    * @param files 需要修改最后访问时间的文件数组。<br>    * @since  0.1<br>    */<br>   public static void touch(File[] files) {<!-- --><br>     for (int i = 0; i &lt; files.length; i++) {<!-- --><br>       touch(files);<br>     }<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 修改文件的最后访问时间。<br>    * 如果文件不存在则创建该文件。<br>    * &lt;b&gt;目前这个方法的行为方式还不稳定，主要是方法有些信息输出，这些信息输出是否保留还在考</font></p> 
 <p><font size="3">虑中。&lt;/b&gt;<br>    * @param fileNames 需要修改最后访问时间的文件名数组。<br>    * @since  0.1<br>    */<br>   public static void touch(String[] fileNames) {<!-- --><br>     File[] files = new File[fileNames.length];<br>     for (int i = 0; i &lt; fileNames.length; i++) {<!-- --><br>       files = new File(fileNames);<br>     }<br>     touch(files);<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 判断指定的文件是否存在。<br>    * @param fileName 要判断的文件的文件名<br>    * @return 存在时返回true，否则返回false。<br>    * @since  0.1<br>    */<br>   public static boolean isFileExist(String fileName) {<!-- --><br>     return new File(fileName).isFile();<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 创建指定的目录。<br>    * 如果指定的目录的父目录不存在则创建其目录书上所有需要的父目录。<br>    * &lt;b&gt;注意：可能会在返回false的时候创建部分父目录。&lt;/b&gt;<br>    * @param file 要创建的目录<br>    * @return 完全创建成功时返回true，否则返回false。<br>    * @since  0.1<br>    */<br>   public static boolean makeDirectory(File file) {<!-- --><br>     File parent = file.getParentFile();<br>     if (parent != null) {<!-- --><br>       return parent.mkdirs();<br>     }<br>     return false;<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 创建指定的目录。<br>    * 如果指定的目录的父目录不存在则创建其目录书上所有需要的父目录。<br>    * &lt;b&gt;注意：可能会在返回false的时候创建部分父目录。&lt;/b&gt;<br>    * @param fileName 要创建的目录的目录名<br>    * @return 完全创建成功时返回true，否则返回false。<br>    * @since  0.1<br>    */<br>   public static boolean makeDirectory(String fileName) {<!-- --><br>     File file = new File(fileName);<br>     return makeDirectory(file);<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 清空指定目录中的文件。<br>    * 这个方法将尽可能删除所有的文件，但是只要有一个文件没有被删除都会返回false。<br>    * 另外这个方法不会迭代删除，即不会删除子目录及其内容。<br>    * @param directory 要清空的目录<br>    * @return 目录下的所有文件都被成功删除时返回true，否则返回false.<br>    * @since  0.1<br>    */<br>   public static boolean emptyDirectory(File directory) {<!-- --><br>     boolean result = false;<br>     File[] entries = directory.listFiles();<br>     for (int i = 0; i &lt; entries.length; i++) {<!-- --><br>       if (!entries.delete()) {<!-- --><br>         result = false;<br>       }<br>     }<br>     return true;<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 清空指定目录中的文件。<br>    * 这个方法将尽可能删除所有的文件，但是只要有一个文件没有被删除都会返回false。<br>    * 另外这个方法不会迭代删除，即不会删除子目录及其内容。<br>    * @param directoryName 要清空的目录的目录名<br>    * @return 目录下的所有文件都被成功删除时返回true，否则返回false。<br>    * @since  0.1<br>    */<br>   public static boolean emptyDirectory(String directoryName) {<!-- --><br>     File dir = new File(directoryName);<br>     return emptyDirectory(dir);<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 删除指定目录及其中的所有内容。<br>    * @param dirName 要删除的目录的目录名<br>    * @return 删除成功时返回true，否则返回false。<br>    * @since  0.1<br>    */<br>   public static boolean deleteDirectory(String dirName) {<!-- --><br>     return deleteDirectory(new File(dirName));<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 删除指定目录及其中的所有内容。<br>    * @param dir 要删除的目录<br>    * @return 删除成功时返回true，否则返回false。<br>    * @since  0.1<br>    */<br>   public static boolean deleteDirectory(File dir) {<!-- --><br>     if ( (dir == null) || !dir.isDirectory()) {<!-- --><br>       throw new IllegalArgumentException("Argument " + dir +<br>                                          " is not a directory. ");<br>     }</font></p> 
 <p><font size="3">    File[] entries = dir.listFiles();<br>     int sz = entries.length;</font></p> 
 <p><font size="3">    for (int i = 0; i &lt; sz; i++) {<!-- --><br>       if (entries.isDirectory()) {<!-- --><br>         if (!deleteDirectory(entries)) {<!-- --><br>           return false;<br>         }<br>       }<br>       else {<!-- --><br>         if (!entries.delete()) {<!-- --><br>           return false;<br>         }<br>       }<br>     }</font></p> 
 <p><font size="3">    if (!dir.delete()) {<!-- --><br>       return false;<br>     }<br>     return true;<br>   }</font></p> 
 <p><br><font size="3">  /**<br>    * 返回文件的URL地址。<br>    * @param file 文件<br>    * @return 文件对应的的URL地址<br>    * @throws MalformedURLException<br>    * @since  0.4<br>    * @deprecated 在实现的时候没有注意到File类本身带一个toURL方法将文件路径转换为URL。<br>    *             请使用File.toURL方法。<br>    */<br>   public static URL getURL(File file) throws MalformedURLException {<!-- --><br>     String fileURL = "file:/" + file.getAbsolutePath();<br>     URL url = new URL(fileURL);<br>     return url;<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 从文件路径得到文件名。<br>    * @param filePath 文件的路径，可以是相对路径也可以是绝对路径<br>    * @return 对应的文件名<br>    * @since  0.4<br>    */<br>   public static String getFileName(String filePath) {<!-- --><br>     File file = new File(filePath);<br>     return file.getName();<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 从文件名得到文件绝对路径。<br>    * @param fileName 文件名<br>    * @return 对应的文件路径<br>    * @since  0.4<br>    */<br>   public static String getFilePath(String fileName) {<!-- --><br>     File file = new File(fileName);<br>     return file.getAbsolutePath();<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 将DOS/Windows格式的路径转换为UNIX/Linux格式的路径。<br>    * 其实就是将路径中的"\"全部换为"/"，因为在某些情况下我们转换为这种方式比较方便，<br>    * 某中程度上说"/"比"\"更适合作为路径分隔符，而且DOS/Windows也将它当作路径分隔符。<br>    * @param filePath 转换前的路径<br>    * @return 转换后的路径<br>    * @since  0.4<br>    */<br>   public static String toUNIXpath(String filePath) {<!-- --><br>     return filePath.replace('\\', '/');<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 从文件名得到UNIX风格的文件绝对路径。<br>    * @param fileName 文件名<br>    * @return 对应的UNIX风格的文件路径<br>    * @since  0.4<br>    * @see #toUNIXpath(String filePath) toUNIXpath<br>    */<br>   public static String getUNIXfilePath(String fileName) {<!-- --><br>     File file = new File(fileName);<br>     return toUNIXpath(file.getAbsolutePath());<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 得到文件的类型。<br>    * 实际上就是得到文件名中最后一个“.”后面的部分。<br>    * @param fileName 文件名<br>    * @return 文件名中的类型部分<br>    * @since  0.5<br>    */<br>   public static String getTypePart(String fileName) {<!-- --><br>     int point = fileName.lastIndexOf('.');<br>     int length = fileName.length();<br>     if (point == -1 || point == length - 1) {<!-- --><br>       return "";<br>     }<br>     else {<!-- --><br>       return fileName.substring(point + 1, length);<br>     }<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 得到文件的类型。<br>    * 实际上就是得到文件名中最后一个“.”后面的部分。<br>    * @param file 文件<br>    * @return 文件名中的类型部分<br>    * @since  0.5<br>    */<br>   public static String getFileType(File file) {<!-- --><br>     return getTypePart(file.getName());<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 得到文件的名字部分。<br>    * 实际上就是路径中的最后一个路径分隔符后的部分。<br>    * @param fileName 文件名<br>    * @return 文件名中的名字部分<br>    * @since  0.5<br>    */<br>   public static String getNamePart(String fileName) {<!-- --><br>     int point = getPathLsatIndex(fileName);<br>     int length = fileName.length();<br>     if (point == -1) {<!-- --><br>       return fileName;<br>     }<br>     else if (point == length - 1) {<!-- --><br>       int secondPoint = getPathLsatIndex(fileName, point - 1);<br>       if (secondPoint == -1) {<!-- --><br>         if (length == 1) {<!-- --><br>           return fileName;<br>         }<br>         else {<!-- --><br>           return fileName.substring(0, point);<br>         }<br>       }<br>       else {<!-- --><br>         return fileName.substring(secondPoint + 1, point);<br>       }<br>     }<br>     else {<!-- --><br>       return fileName.substring(point + 1);<br>     }<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 得到文件名中的父路径部分。<br>    * 对两种路径分隔符都有效。<br>    * 不存在时返回""。<br>    * 如果文件名是以路径分隔符结尾的则不考虑该分隔符，例如"/path/"返回""。<br>    * @param fileName 文件名<br>    * @return 父路径，不存在或者已经是父目录时返回""<br>    * @since  0.5<br>    */<br>   public static String getPathPart(String fileName) {<!-- --><br>     int point = getPathLsatIndex(fileName);<br>     int length = fileName.length();<br>     if (point == -1) {<!-- --><br>       return "";<br>     }<br>     else if (point == length - 1) {<!-- --><br>       int secondPoint = getPathLsatIndex(fileName, point - 1);<br>       if (secondPoint == -1) {<!-- --><br>         return "";<br>       }<br>       else {<!-- --><br>         return fileName.substring(0, secondPoint);<br>       }<br>     }<br>     else {<!-- --><br>       return fileName.substring(0, point);<br>     }<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 得到路径分隔符在文件路径中首次出现的位置。<br>    * 对于DOS或者UNIX风格的分隔符都可以。<br>    * @param fileName 文件路径<br>    * @return 路径分隔符在路径中首次出现的位置，没有出现时返回-1。<br>    * @since  0.5<br>    */<br>   public static int getPathIndex(String fileName) {<!-- --><br>     int point = fileName.indexOf('/');<br>     if (point == -1) {<!-- --><br>       point = fileName.indexOf('\\');<br>     }<br>     return point;<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 得到路径分隔符在文件路径中指定位置后首次出现的位置。<br>    * 对于DOS或者UNIX风格的分隔符都可以。<br>    * @param fileName 文件路径<br>    * @param fromIndex 开始查找的位置<br>    * @return 路径分隔符在路径中指定位置后首次出现的位置，没有出现时返回-1。<br>    * @since  0.5<br>    */<br>   public static int getPathIndex(String fileName, int fromIndex) {<!-- --><br>     int point = fileName.indexOf('/', fromIndex);<br>     if (point == -1) {<!-- --><br>       point = fileName.indexOf('\\', fromIndex);<br>     }<br>     return point;<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 得到路径分隔符在文件路径中最后出现的位置。<br>    * 对于DOS或者UNIX风格的分隔符都可以。<br>    * @param fileName 文件路径<br>    * @return 路径分隔符在路径中最后出现的位置，没有出现时返回-1。<br>    * @since  0.5<br>    */<br>   public static int getPathLsatIndex(String fileName) {<!-- --><br>     int point = fileName.lastIndexOf('/');<br>     if (point == -1) {<!-- --><br>       point = fileName.lastIndexOf('\\');<br>     }<br>     return point;<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 得到路径分隔符在文件路径中指定位置前最后出现的位置。<br>    * 对于DOS或者UNIX风格的分隔符都可以。<br>    * @param fileName 文件路径<br>    * @param fromIndex 开始查找的位置<br>    * @return 路径分隔符在路径中指定位置前最后出现的位置，没有出现时返回-1。<br>    * @since  0.5<br>    */<br>   public static int getPathLsatIndex(String fileName, int fromIndex) {<!-- --><br>     int point = fileName.lastIndexOf('/', fromIndex);<br>     if (point == -1) {<!-- --><br>       point = fileName.lastIndexOf('\\', fromIndex);<br>     }<br>     return point;<br>   }</font></p> 
 <p><font size="3">  /**<br>    * 将文件名中的类型部分去掉。<br>    * @param filename 文件名<br>    * @return 去掉类型部分的结果<br>    * @since  0.5<br>    */<br>   public static String trimType(String filename) {<!-- --><br>     int index = filename.lastIndexOf(".");<br>     if (index != -1) {<!-- --><br>       return filename.substring(0, index);<br>     }<br>     else {<!-- --><br>       return filename;<br>     }<br>   }<br>   /**<br>    * 得到相对路径。<br>    * 文件名不是目录名的子节点时返回文件名。<br>    * @param pathName 目录名<br>    * @param fileName 文件名<br>    * @return 得到文件名相对于目录名的相对路径，目录下不存在该文件时返回文件名<br>    * @since  0.5<br>    */<br>   public static String getSubpath(String pathName,String fileName) {<!-- --><br>     int index = fileName.indexOf(pathName);<br>     if (index != -1) {<!-- --><br>       return fileName.substring(index + pathName.length() + 1);<br>     }<br>     else {<!-- --><br>       return fileName;<br>     }<br>   }</font></p> 
 <p><font size="3">}<br>  4.遗留问题</font></p> 
 <p><font size="3">目前new FileInputStream()只会使用绝对路径，相对没用过，因为要相对于web服务器地址，比较麻烦</font></p> 
 <p><font size="3">还不如写个配置文件来的快哪</font></p> 
 <p><font size="3">5.按Java文件类型分类读取配置文件</font></p> 
 <div class="storycontent"> 
  <p><font size="3">配 置文件是应用系统中不可缺少的，可以增加程序的灵活性。java.util.Properties是从jdk1.2就有的类，一直到现在都支持load ()方法，jdk1.4以后save(output,string) -&gt;store(output,string)。如果只是单纯的读，根本不存在烦恼的问题。web层可以通过 Thread.currentThread().getContextClassLoader().<br> getResourceAsStream("xx.properties") 获取；Application可以通过new FileInputStream("xx.properties");直接在classes一级获取。关键是有时我们需要通过web修改配置文件，我们不 能将路径写死了。经过测试觉得有以下心得：</font></p> 
  <p><font size="3">1.servlet中读写。如果运用Struts 或者Servlet可以直接在初始化参数中配置，调用时根据servlet的getRealPath("/")获取真实路径，再根据String file = this.servlet.getInitParameter("abc");获取相对的WEB-INF的相对路径。<br> 例：<br> InputStream input = Thread.currentThread().getContextClassLoader().<br> getResourceAsStream("abc.properties");<br> Properties prop = new Properties();<br> prop.load(input);<br> input.close();<br> OutputStream out = new FileOutputStream(path);<br> prop.setProperty("abc", “test");<br> prop.store(out, “–test–");<br> out.close();</font></p> 
  <p><font size="3">2.直接在jsp中操作，通过jsp内置对象获取可操作的绝对地址。<br> 例：<br> // jsp页面<br> String path = pageContext.getServletContext().getRealPath("/");<br> String realPath = path+"/WEB-INF/classes/abc.properties";</font></p> 
  <p><font size="3">//java 程序<br> InputStream in = getClass().getClassLoader().getResourceAsStream("abc.properties"); // abc.properties放在webroot/WEB-INF/classes/目录下<br> prop.load(in);<br> in.close();</font></p> 
  <p><font size="3">OutputStream out = new FileOutputStream(path); // path为通过页面传入的路径<br> prop.setProperty("abc", “abcccccc");<br> prop.store(out, “–test–");<br> out.close();</font></p> 
  <p><font size="3">3.只通过Java程序操作资源文件<br> InputStream in = new FileInputStream("abc.properties"); // 放在classes同级</font></p> 
  <p><font size="3">OutputStream out = new FileOutputStream("abc.properties");</font> </p> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32e7bd52742284e16b789d66996499d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MediaPlayer ActiveX访问自定义的URL协议时问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f9ed715eeca69a56ca566fa65c22b977/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机类期刊投稿心得  [ 添加中...现35种 ]</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>