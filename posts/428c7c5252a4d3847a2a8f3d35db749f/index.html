<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Codeforces Round #522 div2 C、E题解（DP） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Codeforces Round #522 div2 C、E题解（DP）" />
<meta property="og:description" content="题目链接：
C. Playing Piano
题意：
给一个序列，让你构造一个相等长度的序列，构造的序列中每个元素的取值范围都为[1,5]。
构造要求：
1. 若原序列a[i]==a[i&#43;1]，那么构造的序列b[i]!=b[i&#43;1]；
2. 若原序列a[i]&gt;a[i&#43;1]，那么构造的序列b[i]&gt;b[i&#43;1]；
3. 若原序列a[i]&lt;a[i&#43;1]，那么构造的序列b[i]&lt;b[i&#43;1]；
若答案存在，输出任意一个，否则输出-1。
思路：
暴力dp。开一个dp[N][5]，若第 i 位是 k （1&lt;=k&lt;=5），且到第 i 位为止满足要求，那么dp[i][k]=1，否则dp[i][k]=0。由于要保存路径，所以把dp数组弄成一个结构体，用pre变量记录当前位上一位的答案的值。
code：
#include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; typedef long long ll; const ll INF = 0x3f3f3f3f3f3f3f3f; const int MAX = 1e5&#43;100; typedef struct{ int val; int pre; }Point; int n; int a[MAX]; Point dp[MAX][10]; int ans[MAX]; int main() { scanf(&#34;%d&#34;,&amp;n); for(int i=0;i&lt;n;i&#43;&#43;){ scanf(&#34;%d&#34;,&amp;a[i]); } if(n==1){ printf(&#34;1\n&#34;); return 0; } for(int i=1;i&lt;=5;i&#43;&#43;){ dp[0][i]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/428c7c5252a4d3847a2a8f3d35db749f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-22T16:14:58+08:00" />
<meta property="article:modified_time" content="2018-11-22T16:14:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Codeforces Round #522 div2 C、E题解（DP）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>题目链接：</strong></p> 
<p><a href="http://codeforces.com/contest/1079/problem/C" rel="nofollow">C. Playing Piano</a></p> 
<p><strong>题意：</strong></p> 
<p>给一个序列，让你构造一个相等长度的序列，构造的序列中每个元素的取值范围都为[1,5]。</p> 
<p>构造要求：</p> 
<p>1. 若原序列a[i]==a[i+1]，那么构造的序列b[i]!=b[i+1]；</p> 
<p>2. 若原序列a[i]&gt;a[i+1]，那么构造的序列b[i]&gt;b[i+1]；</p> 
<p>3. 若原序列a[i]&lt;a[i+1]，那么构造的序列b[i]&lt;b[i+1]；</p> 
<p>若答案存在，输出任意一个，否则输出-1。</p> 
<p><strong>思路：</strong></p> 
<p>暴力dp。开一个dp[N][5]，若第 i 位是 k （1&lt;=k&lt;=5），且到第 i 位为止满足要求，那么dp[i][k]=1，否则dp[i][k]=0。由于要保存路径，所以把dp数组弄成一个结构体，用pre变量记录当前位上一位的答案的值。</p> 
<p><strong>code：</strong></p> 
<pre class="has"><code class="hljs language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long  ll;

const ll INF = 0x3f3f3f3f3f3f3f3f;
const int MAX = 1e5+100;

typedef struct{
    int val;
    int pre;
}Point;

int n;
int a[MAX];
Point dp[MAX][10];
int ans[MAX];

int main()
{
    scanf("%d",&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf("%d",&amp;a[i]);
    }
    if(n==1){
        printf("1\n");
        return 0;
    }
    for(int i=1;i&lt;=5;i++){
        dp[0][i].val=1;
    }
    for(int  i=1;i&lt;n;i++){
        for(int j=1;j&lt;=5;j++){
            if(dp[i-1][j].val){
                if(a[i]&gt;a[i-1]){
                    for(int k=j+1;k&lt;=5;k++){
                        dp[i][k].val=1;
                        dp[i][k].pre=j;
                    }
                }
                else if(a[i]==a[i-1]){
                    for(int k=1;k&lt;=5;k++){
                        if(k==j)    continue;
                        dp[i][k].val=1;
                        dp[i][k].pre=j;
                    }
                }
                else if(a[i]&lt;a[i-1]){
                    for(int k=1;k&lt;j;k++){
                        dp[i][k].val=1;
                        dp[i][k].pre=j;
                    }
                }
            }
        }
    }
    int cnt=0;
    int pos=-1;
    //判断是否有满足条件的解
    for(int i=1;i&lt;=5;i++){
        if(dp[n-1][i].val){
            ans[cnt++]=i;
            pos=dp[n-1][i].pre;
            ans[cnt++]=pos;
            break;
        }
    }
    if(pos==-1){
        printf("-1\n");
        return 0;
    }
    for(int i=n-2;i&gt;=1;i--){
        ans[cnt++]=dp[i][pos].pre;
        pos=dp[i][pos].pre;
    }
    for(int i=cnt-1;i&gt;=0;i--){
        if(i==cnt-1)  printf("%d",ans[i]);
        else  printf(" %d",ans[i]);
    }
    printf("\n");
    return 0;
}</code></pre> 
<p><strong>题目链接：</strong></p> 
<p><a href="http://codeforces.com/contest/1079/problem/E" rel="nofollow">E. The Unbearable Lightness of Weights</a></p> 
<p><strong>题意：</strong></p> 
<p>有 n 个砝码，给定它们的重量，但对应关系不知道（即不知道第几个砝码重多少，只知道它的重量肯定是给的数字中的一个）。但你的朋友是知道对应关系的，你可以问他一个问题（只能问一次），你只能问 k 个砝码重量为 m（k、m的值你自己随便定），他会给你 k 个砝码，这些砝码的重量恰好为 m，如果有多种情况，他会随便给你一种（给你的 k 个砝码的重量对应关系也是不知道的）。问你最多能确定多少个砝码的重量。</p> 
<p><strong>思路：</strong></p> 
<p>题目虽然很短，但题意理解了半天......</p> 
<p>由于问完之后朋友返回给你的那些砝码重量的对应关系也是不知道的，所以<span style="color:#f33b45;">只有在那 k 个砝码的重量相等时才能确定他们各自的重量</span>。但因为 k 个砝码重量为 m 的情况可能不止一种，比如3个砝码：4、4、4，总重为12，1、3、9，总重也为12。所以当情况不止一种时，就算 k 个砝码重量一样也还是不能确定的（因为你不知道朋友给你的是不是恰好是重量一样的那种）。</p> 
<p>所以题目转变为要判断一个序列中，任意k个数的和等于m的情况数。用dp可解：</p> 
<p>dp[num][sum][2]：num表示有num个数相加，sum表示num个数的和，0表示当前状态，1表示可转移到的状态。</p> 
<p>为什么要用2个状态去计算呢？因为只用一个状态的话，当前的a[i]可能会多加很多次。</p> 
<p>那么转移方程为：</p> 
<p>当dp[num][sum][0]存在时，dp[num+1][sum+a[i]][1]+=dp[num][sum][0]；</p> 
<p>到这问题基本就已经解决了，但还要注意题目的一些<span style="color:#f33b45;">细节</span>：</p> 
<p>比如有4、4、4，但只能取2个数（假设有1、3、9），这3个 4 本身能组成 3 个 8，我们要去找的是除了这3个 4 之外还存不存在2个数和为 8 的情况。此外，如果总共只有2种重量的砝码，且能把其中的一种全部确定，那剩下的那种也能全部确定，比如1、1、2、2、2、2，问k = 4 , m = 8，就能把重量为2的砝码全部确定，那么剩下两个重量肯定都只能为 1 。</p> 
<p><strong>code：</strong></p> 
<pre class="has"><code class="hljs language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long  ll;

const ll INF = 0x3f3f3f3f3f3f3f3f;
const int MAX = 1e5+100;

int n;
int a[110];
ll dp[110][10010][3];
ll comb[120][120]; //组合数

void init(){
    for(int i = 0; i &lt; 120; i ++){
        comb[i][0] = comb[i][i] = 1;
        for(int j = 1; j &lt; i; j ++){
            comb[i][j] = comb[i-1][j] + comb[i-1][j-1];
        }
    }
}

int main()
{
    init();
    scanf("%d",&amp;n);
    int Max=0;
    for(int i=0;i&lt;n;i++){
        scanf("%d",&amp;a[i]);
        Max+=a[i];
    }
    dp[0][0][0]=1;
    dp[1][a[0]][0]=1;
    dp[0][0][1]=1;
    dp[1][a[0]][1]=1;
    for(int i=1;i&lt;n;i++){
        for(int j=0;j&lt;=i;j++){
            for(int k=0;k&lt;=Max;k++){
                if(dp[j][k][0]){
                    dp[j+1][k+a[i]][1]+=dp[j][k][0];
                }
            }
        }
        //将当前状态进行转移
        for(int j=0;j&lt;=i+1;j++){
            for(int k=0;k&lt;=Max;k++){
                dp[j][k][0]=dp[j][k][1];
            }
        }
    }
    sort(a,a+n);
    a[n]=-1;
    int cnt=1; //表示重量相同的砝码的个数
    int ans=0;
    int num=0;
    int fg=0;
    for(int i=1;i&lt;=n;i++){
        if(a[i]!=a[i-1]){
            num++;
            for(int j=cnt;j&gt;0;j--){
                if(ans&gt;=j)  break;
                //comb[cnt][j]为C(cnt,j)，表示这相同的几个数能组成和为j*a[i-1]的情况数
                if(dp[j][j*a[i-1]][0]==comb[cnt][j]){
                    ans=j;
                    if(j==cnt) fg=1;
                    else fg=0;
                    break;
                }
            }
            cnt=1;
        }
        else{
            cnt++;
        }
    }
    //若只有2种重量的砝码且一种能全部确定
    if(num==2&amp;&amp;fg==1){
        ans=n;
    }
    printf("%d\n",ans);
    return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c70a8280a04f198558fb5bd8039a4c5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">随机梯度下降法（SGD）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f52216f12b42a72d2129325f951f20d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于深度学习的知识图谱综述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>