<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ArkTS开发实践 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ArkTS开发实践" />
<meta property="og:description" content="声明式UI基本概念 应用界面是由一个个页面组成，ArkTS是由ArkUI框架提供，用于以声明式开发范式开发界面的语言。
声明式UI构建页面的过程，其实是组合组件的过程，声明式UI的思想，主要体现在两个方面：
描述UI的呈现结果，而不关心过程状态驱动视图更新 类似苹果的SwiftUI中通过组合视图View，安卓Jetpack Compose中通过组合@Composable函数，ArkUI作为HarmonyOS应用开发的UI开发框架，其使用ArkTS语言构建自定义组件，通过组合自定义组件完成页面的构建。
自定义组件的组成 ArkTS通过struct声明组件名，并通过@Component和@Entry装饰器，来构成一个自定义组件。
使用@Entry和@Component装饰的自定义组件作为页面的入口，会在页面加载时首先进行渲染。
@Entry @Component struct ToDoList {...} 例如ToDoList组件对应如下整个代办页面。
图1 ToDoList待办列表
使用@Component装饰的自定义组件，如ToDoItem这个自定义组件则对应如下内容，作为页面的组成部分。
@Component struct ToDoItem {...} 图2 ToDoItem
在自定义组件内需要使用build方法来进行UI描述。
@Entry @Component struct ToDoList ... build() { ... } } build方法内可以容纳内置组件和其他自定义组件，如Column和Text都是内置组件，由ArkUI框架提供，ToDoItem为自定义组件，需要开发者使用ArkTS自行声明。
@Entry @Component struct ToDoList { ... build() { Column(...) { Text(...) ... ForEach(...{ TodoItem(...) },...) } ... } } 配置属性与布局 自定义组件的组成使用基础组件和容器组件等内置组件进行组合。但有时内置组件的样式并不能满足我们的需求，ArkTS提供了属性方法用于描述界面的样式。属性方法支持以下使用方式：
常量传递例如使用fontSize(50)来配置字体大小。 Text(&#39;Hello World&#39;) .fontSize(50) 变量传递在组件内定义了相应的变量后，例如组件内部成员变量size，就可以使用this.size方式使用该变量。 Text(&#39;Hello World&#39;) .fontSize(this.size) 链式调用在配置多个属性时，ArkTS提供了链式调用的方式，通过&#39;.&#39;方式连续配置。 Text(&#39;Hello World&#39;) .fontSize(this.size) ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0fe05c36025a3f0648d24c78f44f6b3d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-12T22:16:03+08:00" />
<meta property="article:modified_time" content="2023-11-12T22:16:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ArkTS开发实践</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="section5127641257">声明式UI基本概念</h3> 
<p></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p929216231246">应用界面是由一个个页面组成，ArkTS是由ArkUI框架提供，用于以声明式开发范式开发界面的语言。</p> 
<p id="ZH-CN_TOPIC_0000001524178997__p1336171611357">声明式UI构建页面的过程，其实是组合组件的过程，声明式UI的思想，主要体现在两个方面：</p> 
<ul id="ZH-CN_TOPIC_0000001524178997__ul5342163043418"><li id="ZH-CN_TOPIC_0000001524178997__li113421430123415">描述UI的呈现结果，而不关心过程</li><li id="ZH-CN_TOPIC_0000001524178997__li677013365347">状态驱动视图更新</li></ul> 
<p id="ZH-CN_TOPIC_0000001524178997__p19769124011817">类似苹果的SwiftUI中通过组合视图View，安卓Jetpack Compose中通过组合@Composable函数，ArkUI作为HarmonyOS应用开发的UI开发框架，其使用ArkTS语言构建自定义组件，通过组合自定义组件完成页面的构建。</p> 
<h3 id="section1456320591862">自定义组件的组成</h3> 
<p></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p19515494">ArkTS通过struct声明组件名，并通过@Component和@Entry装饰器，来构成一个自定义组件。</p> 
<p id="ZH-CN_TOPIC_0000001524178997__p1465681913301">使用@Entry和@Component装饰的自定义组件作为页面的入口，会在页面加载时首先进行渲染。</p> 
<pre><code class="hljs">@Entry
@Component
struct ToDoList {...}</code></pre> 
<p id="ZH-CN_TOPIC_0000001524178997__p135846143014">例如ToDoList组件对应如下整个代办页面。</p> 
<p><strong>图1 </strong>ToDoList待办列表</p> 
<p class="img-center"><img alt="" height="942" src="https://images2.imgbox.com/bf/6e/gkt2zkC0_o.png" width="462"></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p1546919853111">使用@Component装饰的自定义组件，如ToDoItem这个自定义组件则对应如下内容，作为页面的组成部分。</p> 
<pre><code class="hljs">@Component
struct ToDoItem {...}</code></pre> 
<p><strong>图2 </strong>ToDoItem</p> 
<p class="img-center"><img alt="" height="192" src="https://images2.imgbox.com/0a/f3/wcBN9NgP_o.png" width="1143"></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p478863203417">在自定义组件内需要使用build方法来进行UI描述。</p> 
<pre><code class="hljs">@Entry
@Component
struct ToDoList
...
build() {
...
}
}</code></pre> 
<p id="ZH-CN_TOPIC_0000001524178997__p93831823153712">build方法内可以容纳内置组件和其他自定义组件，如Column和Text都是内置组件，由ArkUI框架提供，ToDoItem为自定义组件，需要开发者使用ArkTS自行声明。</p> 
<pre><code class="hljs">@Entry
@Component
struct ToDoList {
...
build() {
Column(...) {
Text(...)
...
ForEach(...{
TodoItem(...)
},...)
}
...
}
}</code></pre> 
<h3 id="section5973143214204">配置属性与布局</h3> 
<p></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p98921855142115">自定义组件的组成使用基础组件和容器组件等内置组件进行组合。但有时内置组件的样式并不能满足我们的需求，ArkTS提供了属性方法用于描述界面的样式。属性方法支持以下使用方式：</p> 
<ul id="ZH-CN_TOPIC_0000001524178997__ul376920468240"><li id="ZH-CN_TOPIC_0000001524178997__li19769134652412">常量传递<a name="li19769134652412"></a>例如使用fontSize(50)来配置字体大小。 <pre><code class="hljs">Text('Hello World')
.fontSize(50)</code></pre> </li><li id="ZH-CN_TOPIC_0000001524178997__li143001026102518">变量传递<a name="li143001026102518"></a>在组件内定义了相应的变量后，例如组件内部成员变量size，就可以使用this.size方式使用该变量。 <pre><code class="hljs">Text('Hello World')
.fontSize(this.size)</code></pre> </li><li id="ZH-CN_TOPIC_0000001524178997__li551512237273">链式调用<a name="li551512237273"></a>在配置多个属性时，ArkTS提供了链式调用的方式，通过'.'方式连续配置。 <pre><code class="hljs">Text('Hello World')
.fontSize(this.size)
.width(100)
.height(100)</code></pre> </li><li id="ZH-CN_TOPIC_0000001524178997__li1351562322720">表达式传递<a name="li1351562322720"></a>属性中还可以传入普通表达式以及三目运算表达式。 <pre><code class="hljs">Text('Hello World')
.fontSize(this.size)
.width(this.count + 100)
.height(this.count % 2 === 0 ? 100 : 200)</code></pre> </li><li id="ZH-CN_TOPIC_0000001524178997__li2515172362711">内置枚举类型<a name="li2515172362711"></a>除此之外，ArkTS中还提供了内置枚举类型，如Color，FontWeight等，例如设置fontColor改变字体颜色为红色，并私有fontWeight为加粗。 <pre><code class="hljs">Text('Hello World')
.fontSize(this.size)
.width(this.count + 100)
.height(this.count % 2 === 0 ? 100 : 200)
.fontColor(Color.Red)
.fontWeight(FontWeight.Bold)</code></pre> </li></ul> 
<p id="ZH-CN_TOPIC_0000001524178997__p5549122318461">对于有多种组件需要进行组合时，容器组件则是描述了这些组件应该如何排列的结果。</p> 
<p id="ZH-CN_TOPIC_0000001524178997__p11790163104419">ArkUI中的布局容器有很多种，在不同的适用场合选择不同的布局容器实现，ArkTS使用容器组件采用花括号语法，内部放置UI描述。</p> 
<p id="ZH-CN_TOPIC_0000001524178997__p194845109262"></p> 
<p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/f7/65/BhbnoCKT_o.png" width="366"></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p1600531113620">这里我们将介绍最基础的两个布局——列布局和行布局。</p> 
<p id="ZH-CN_TOPIC_0000001524178997__p1724821019439">对于如下每一项的布局，两个元素为横向排列，选择Row布局</p> 
<p><strong>图3 </strong>Row布局</p> 
<p class="img-center"><img alt="" height="123" src="https://images2.imgbox.com/41/9b/ctcE8EqU_o.png" width="1200"></p> 
<pre><code class="hljs">Row() {
Image($r('app.media.ic_default'))
...
Text(this.content)
...
}
...</code></pre> 
<p id="ZH-CN_TOPIC_0000001524178997__p15918173174412">类似下图所示的布局，整体都是从上往下纵向排列，适用的布局方式是Column列布局。</p> 
<p><strong>图4 </strong>Column布局</p> 
<p class="img-center"><img alt="" height="767" src="https://images2.imgbox.com/aa/f2/3xtBQGK4_o.png" width="1200"></p> 
<pre><code class="hljs">Column() {
Text($r('app.string.page_title'))
...

ForEach(this.totalTasks,(item) =&gt; {
TodoItem({content:item})
},...)
}</code></pre> 
<h3 id="section197253143815">改变组件状态</h3> 
<p></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p8060118">实际开发中由于交互，页面的内容可能需要产生变化，以每一个ToDoItem为例，其在完成时的状态与未完成时的展示效果是不一样的。</p> 
<p><strong>图5 </strong>不同状态的视图</p> 
<p class="img-center"><img alt="" height="282" src="https://images2.imgbox.com/bf/7d/P68dDyuk_o.png" width="1200"></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p970619337447">声明式UI的特点就是UI是随数据更改而自动刷新的，我们这里定义了一个类型为boolean的变量isComplete，其被@State装饰后，框架内建立了数据和视图之间的绑定，其值的改变影响UI的显示。</p> 
<pre><code class="hljs">@State isComplete : boolean = false;</code></pre> 
<p><strong>图6 </strong>@State装饰器的作用</p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/65/7e/cGHKq7VT_o.png" width="1200"></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p1310615915516">用圆圈和对勾这样两个图片，分别来表示该项是否完成，这部分涉及到内容的切换，需要使用条件渲染if / else语法来进行组件的显示与消失，当判断条件为真时，组件为已完成的状态，反之则为未完成。</p> 
<pre><code class="hljs">if (this.isComplete) {
Image($r('app.media.ic_ok'))
.objectFit(ImageFit.Contain)
.width($r('app.float.checkbox_width'))
.height($r('app.float.checkbox_width'))
.margin($r('app.float.checkbox_margin'))
} else {
Image($r('app.media.ic_default'))
.objectFit(ImageFit.Contain)
.width($r('app.float.checkbox_width'))
.height($r('app.float.checkbox_width'))
.margin($r('app.float.checkbox_margin'))
}</code></pre> 
<p id="ZH-CN_TOPIC_0000001524178997__p8573175212477">由于两个Image的实现具有大量重复代码，ArkTS提供了@Builder装饰器，来修饰一个函数，快速生成布局内容，从而可以避免重复的UI描述内容。这里使用@Bulider声明了一个labelIcon的函数，参数为url，对应要传给Image的图片路径。</p> 
<pre><code class="hljs">@Builder labelIcon(url) {
Image(url)
.objectFit(ImageFit.Contain)
.width($r('app.float.checkbox_width'))
.height($r('app.float.checkbox_width'))
.margin($r('app.float.checkbox_margin'))
}</code></pre> 
<p id="ZH-CN_TOPIC_0000001524178997__p167301735135516">使用时只需要使用this关键字访问@Builder装饰的函数名，即可快速创建布局。</p> 
<pre><code class="hljs">if (this.isComplete) {
this.labelIcon($r('app.media.ic_ok'))
} else {
this.labelIcon($r('app.media.ic_default'))
}</code></pre> 
<p id="ZH-CN_TOPIC_0000001524178997__p1364212280169">为了让待办项带给用户的体验更符合已完成的效果，给内容的字体也增加了相应的样式变化，这里使用了三目运算符来根据状态变化修改其透明度和文字样式，如opacity是控制透明度，decoration是文字是否有划线。通过isComplete的值来控制其变化。</p> 
<pre><code class="hljs">Text(this.content)
...
.opacity(this.isComplete ? CommonConstants.OPACITY_COMPLETED : CommonConstants.OPACITY_DEFAULT)
.decoration({ type: this.isComplete ? TextDecorationType.LineThrough : TextDecorationType.None })</code></pre> 
<p>最后，为了实现与用户交互的效果，在组件上添加了onClick点击事件，当用户点击该待办项时，数据isComplete的更改就能够触发UI的更新。</p> 
<pre><code class="hljs">@Component
struct ToDoItem {
@State isComplete : boolean = false;
@Builder labelIcon(icon) {...}
...
build() {
Row() {
if (this.isComplete) {
this.labelIcon($r('app.media.ic_ok'))
} else {
this.labelIcon($r('app.media.ic_default'))
}
...
}
...
.onClick(() =&gt; {
this.isComplete= !this.isComplete;
})
}
}</code></pre> 
<h3 id="section8466841182">循环渲染列表数据</h3> 
<p></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p14203731798">刚刚只是完成了一个ToDoItem组件的开发，当我们有多条待办数据需要显示在页面时，就需要使用到ForEach循环渲染语法。</p> 
<p>例如这里我们有五条待办数据需要展示在页面上。</p> 
<pre><code class="hljs">total_Tasks:Array&lt;string&gt; = [
'早起晨练',
'准备早餐',
'阅读名著',
'学习ArkTS',
'看剧放松'
]</code></pre> 
<p id="ZH-CN_TOPIC_0000001524178997__p1770111591989">ForEach基本使用中，只需要了解要渲染的数据以及要生成的UI内容两个部分，例如这里要渲染的数组为以上的五条待办事项，要渲染的内容是ToDoItem这个自定义组件，也可以是其他内置组件。</p> 
<p><strong>图7 </strong>ForEach基本使用</p> 
<p class="img-center"><img alt="" height="576" src="https://images2.imgbox.com/43/8f/TFHldFri_o.png" width="1200"></p> 
<p id="ZH-CN_TOPIC_0000001524178997__p677365813513">ToDoItem这个自定义组件中，每一个ToDoItem要显示的文本参数content需要外部传入，参数传递使用花括号的形式，用content接受数组内的内容项item。</p> 
<p id="ZH-CN_TOPIC_0000001524178997__p1395855812513">最终完成的代码及其效果如下。</p> 
<pre><code class="hljs">@Entry
@Component
struct ToDoList {
...
build() {
Row() {
Column() {
Text(...)
...
ForEach(this.totalTasks,(item) =&gt; {
TodoItem({content:item})
},...)
}
.width('100%')
}
.height('100%')
}
}</code></pre> 
<p><strong>图8 </strong>ToDoList页面</p> 
<p class="img-center"><img alt="" height="942" src="https://images2.imgbox.com/1e/6f/t64v9s3E_o.png" width="462"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96da040f6fb946506a546b7fb1e84ab5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Mac开发环境搭建】安装HomeBrew、HomeBrew安装Docker、Docker安装Mysql5.7和8</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c261b19c41ff3007cca914427fb2b44/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">视觉大模型DINOv2:自我监督学习的新领域</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>