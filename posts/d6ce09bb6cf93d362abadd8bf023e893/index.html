<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>让qt应用程序支持触摸 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="让qt应用程序支持触摸" />
<meta property="og:description" content="原文地址::https://blog.csdn.net/orz415678659/article/details/9136575
一.设备驱动
我的触摸屏是usb接口的
可以参考下这2篇文件
http://blog.csdn.net/paomadi/article/details/8754783 usb触摸屏
http://blog.csdn.net/paomadi/article/details/8309861 输入子系统
不是usb接口的或者自己想写多一个也可以(需要我的源码的请留邮箱说下,我贴一部分)
usb子系统部分关键在于urb的数据传递
input子系统部分关键在于事件的设置及上报
#define M //多点触摸点数
在初始化init或者probe方法中
input_dev=input_allocate_device()；//分配初始化输入设备
//(最好构建一个对象结构体,包含input设备和usb设备,或其他设备,将各个子系统的设备捆绑到一个对象中去)
set_bit(EV_KEY, input_dev-&gt;evbit); //设置事件类型标志位
set_bit(EV_ABS, input_dev-&gt;evbit);
set_bit(BTN_TOUCH, input_dev-&gt;keybit); //设置按键类型标志
#if M
//多点的这么设置参数(我的屏只支持单点,so没亲测)
input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,1920, 0, 0);
input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,1080, 0, 0);
input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
#else
//单点的参数设置
input_set_abs_params(input_dev, ABS_X, 0, 0x7FFF, 0, 0); //设置参数
input_set_abs_params(input_dev, ABS_Y, 0, 0x7FFF, 0, 0);
input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);
#endif
在接收到数据之后上报事件给input子系统
#if M" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d6ce09bb6cf93d362abadd8bf023e893/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-08T17:14:51+08:00" />
<meta property="article:modified_time" content="2020-05-08T17:14:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">让qt应用程序支持触摸</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>原文地址::<a href="https://blog.csdn.net/orz415678659/article/details/9136575">https://blog.csdn.net/orz415678659/article/details/9136575</a></p> 
<p> </p> 
<p>一.设备驱动</p> 
<p>我的触摸屏是usb接口的<br> 可以参考下这2篇文件<br> http://blog.csdn.net/paomadi/article/details/8754783 usb触摸屏<br> http://blog.csdn.net/paomadi/article/details/8309861 输入子系统</p> 
<p>不是usb接口的或者自己想写多一个也可以(需要我的源码的请留邮箱说下,我贴一部分)<br> usb子系统部分关键在于urb的数据传递</p> 
<p>input子系统部分关键在于事件的设置及上报</p> 
<p>#define M //多点触摸点数<br> 在初始化init或者probe方法中<br> input_dev=input_allocate_device()；//分配初始化输入设备<br> //(最好构建一个对象结构体,包含input设备和usb设备,或其他设备,将各个子系统的设备捆绑到一个对象中去)<br>  <br> set_bit(EV_KEY, input_dev-&gt;evbit);    //设置事件类型标志位<br> set_bit(EV_ABS, input_dev-&gt;evbit);<br>  <br> set_bit(BTN_TOUCH, input_dev-&gt;keybit);    //设置按键类型标志<br>  <br> #if M<br> //多点的这么设置参数(我的屏只支持单点,so没亲测)<br> input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,1920, 0, 0);<br> input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,1080, 0, 0);<br> input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);<br> #else<br> //单点的参数设置<br> input_set_abs_params(input_dev, ABS_X, 0, 0x7FFF, 0, 0);    //设置参数<br> input_set_abs_params(input_dev, ABS_Y, 0, 0x7FFF, 0, 0);<br> input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);<br> #endif<br>     <br> 在接收到数据之后上报事件给input子系统<br> #if M<br>     //input_report_abs(touch-&gt;input, ABS_MT_TOUCH_MAJOR, 0);<br>     for(i=0;i&lt;M;i++){<!-- --><br>         input_report_abs(touchkit-&gt;input, ABS_MT_TRACKING_ID,0);<br>         input_report_key(touchkit-&gt;input, BTN_TOUCH, touchkit-&gt;press);<br>         input_report_abs(touchkit-&gt;input, ABS_MT_POSITION_X, touchkit-&gt;x);<br>         input_report_abs(touchkit-&gt;input, ABS_MT_POSITION_Y, touchkit-&gt;y);<br>         input_report_abs(touchkit-&gt;input, ABS_PRESSURE, touchkit-&gt;press);<br>         input_mt_sync(touchkit-&gt;input);    <br>     }<br> #else<br>     input_report_abs(input_dev, ABS_X, touchkit-&gt;x);<br>     input_report_abs(input_dev, ABS_Y, touchkit-&gt;y);<br>     input_report_key(input_dev, BTN_TOUCH,touchkit-&gt;press);<br>     input_report_abs(input_dev, ABS_PRESSURE, touchkit-&gt;press);<br> #endif<br>     input_sync(input_dev);<br> usb能匹配直接用hid子系统那是极好的</p> 
<p>可以这样调试hid的设备<br> mkidr /tmp/debugfs<br> mount -t debugfs debugfs /tmp/debugfs<br> cd /tmp/debugfs<br> cd hid<br> cd 进对应的hid设备文件夹<br> cat event<br> 其他的一些调试查看方法</p> 
<p>ls -l /dev/input查看输入input设备<br> 其中可以看到 lrwxrwxrwx    1 root     root            6 Jan  1  2000 touchscreen0 -&gt; event1<br> /dev/input/touchscreen0是链接文件,链接到对应的触摸屏event1设备</p> 
<p>查看event1是否触摸设备<br> cd /sys/class/input<br> cd event1<br> cd device<br> cat name<br> 或者<br> cat /proc/bus/input/devices<br> 比较Handlers和Name</p> 
<p> </p> 
<p>cat /dev/input/touchscreen|hexdump 点击触摸屏查看接收到的数据</p> 
<p><br> 二.tslib</p> 
<p>升级工具<br> sudo apt-get install autoconf<br> sudo apt-get install automake<br> sudo apt-get install libtool</p> 
<p>解压tslib<br> tar xzf tslib-1.4.tar.gz<br> cd tslib<br> 生产configure文件<br> ./autogen.sh<br> 创建安装目录<br> mkdir tmp<br> 配置生成makefile文件<br> echo "ac_cv_func_malloc_0_nonnull=yes" &gt;arm-none-linux-gnueabi.cache<br> ./configure --host=arm-none-linux-gnueabi --cache-file=arm-none-linux-gnueabi.cache --prefix=$(pwd)/tmp<br> 编译tslib<br> make<br> 安装tslib<br> make install</p> 
<p>安装完成后生成4个目录<br> /bin 目录包含ts_calibrate ts_test ts_harvest ts_print ts_print_raw测试执行文件<br> /etc 目录包含ts.conf配置文件<br> /include 目录包含 tslib.h头文件<br> /lib 目录包含 pkgconfig目录和ts目录和*.so(libts.so等)动态链接库</p> 
<p>检验文件是否用交叉工具链编译的<br> file ts_calibrate查看打印的信息</p> 
<p>文件系统配置<br> 将/bin目录的和/etc目录下的文件复制到目标板文件系统的同样目录下<br> /include和/lib目录复制到目标板文件系统的/usr目录下</p> 
<p>配置ts.conf<br> module_raw input<br> module pthres pmin=1<br> module variance delta=30<br> module dejitter delta=100<br> module linear</p> 
<p>配置环境变量<br> 打开目标板文件系统/etc/profile文件<br> export LD_LIBRARY_PATH=/usr/lib/    --库文件目录<br> export TSLIB_ROOT=/usr/       --tslib库文件/头文件根目录<br> export TSLIB_TSDEVICE=/dev/input/touchscreen0 --触摸屏设备文件路径<br> export TSLIB_CALIBFILE=/etc/pointercal   --校正文件路径 运行ts_calibrates会自动生成<br> export TSLIB_CONFFILE=/etc/ts.conf    --配置文件路径<br> export TSLIB_CONSOLEDEVICE=none     --<br> export TSLIB_FBDEVICE=/dev/fb0     --fb显示设备文件路径<br> export TSLIB_TSEVENTTYPE=INPUT     --触摸事件类型 input子系统<br> export TSLIB_PLUGINDIR=/usr/lib/ts    --</p> 
<p>tslib测试<br> 运行ts_calibrate<br> 打印:<br> xres = 1920, yres = 1080<br> 显示屏出现校正画面<br> 点击方块(左上角)<br> 打印:<br> Took 1 samples...<br> Top left : X =  752 Y = 1248<br> 再次点击方块(右上角)<br> 打印:<br> Took 2 samples...<br> Top right : X = 31938 Y = 1468<br> 再次点击方块(右下角)<br> 打印:<br> Took 2 samples...<br> Bot right : X = 31986 Y = 30926<br> 再次点击方块(左下角)<br> 打印:<br> Took 1 samples...<br> Bot left : X =  728 Y = 31278<br> 再次点击方块(正中间)<br> 打印:<br> Took 1 samples...<br> Center : X = 16387 Y = 16403<br> 3.813721 0.058434 0.000070<br> 3.860352 0.000071 0.032752<br> Calibration constants: 249936 3829 4 252992 4 2146 65536</p> 
<p>校验完在/etc目录下生成/etc/pointercal</p> 
<p>ts_calibrate可能会遇到一些问题<br> 提示不是支持的触摸屏:查看TSLIB_TSDEVICE环境变量是否设置对<br> 没点击方块就自动校正了:1.驱动BTN_TOUCH或者ABS_PRESSURE的值固化成1了(有上报按下事件没上报松开事件)<br>       2.库文件放错位置</p> 
<p>运行ts_test<br> 点击Drag按钮 可以拖动小方块<br> 点击Draw按钮 可以在屏幕上画线<br> 点击的时候会打印:xxx:[x坐标] [y坐标] [按下1/松开0]<br> 1345221722.121520:   1920   1074      1<br> 1345221722.121520:   1920   1074      1<br> 1345221722.354517:   1920   1078      0<br> 1345221724.035519:   1851    838      1<br> 1345221724.045521:   1849    835      1<br> 1345221724.065520:   1845    829      1<br> 1345221724.081520:   1840    823      1<br> 1345221724.091521:   1834    816      1<br> 1345221724.104521:   1828    810      1<br> 1345221724.121520:   1821    803      1<br> 1345221724.137518:   1814    797      1<br> 1345221724.153520:   1807    790      1</p> 
<p> </p> 
<p>三.qt everywhere 4.8.1编译</p> 
<p>重新配置tslib<br> /configure --host=arm-none-linux-gnueabi --cache-file=arm-none-linux-gnueabi.cache --prefix=/usr/local/tslib<br> 修改安装目录<br> make<br> make install</p> 
<p>修改qt-everywhere-opensource-src-4.8.1/mkspecs/qws/【xxx】/qmake.conf文件<br> QMAKE_CC = arm-none-linux-gnueabi-gcc -lts<br> QMAKE_CXX = arm-none-linux-gnueabi-g++ -lts<br> QMAKE_LINK = arm-none-linux-gnueabi-g++ -lts<br> QMAKE_LINK_SHLIB = arm-none-linux-gnueabi-g++ -lts</p> 
<p>QMAKE_INCDIR =/usr/local/tslib/include<br> QMAKE_LIBDIR =/usr/local/tslib/lib</p> 
<p>配置qt<br> .configure 后面加上 -no-mouse-linuxtp -qt-mouse-tslib<br> 在test的过程中打印<br> Mouse driver(qt) ......pc tslib<br> 表示库安装成功并成功检测到</p> 
<p>编译qt<br> make<br> make install</p> 
<p>example里面选择应用程序(推荐qt-everywhere-opensource-src-4.8.1/examples/widgets/calculator)<br> 拷贝到目标板文件系统里<br> ldd calculator 查看calculator需要调用的库<br> 打印:</p> 
<p>        libts-0.0.so.0 =&gt; /usr/lib/libts-0.0.so.0 (0x2ac3f000)<br>         libQtGui.so.4 =&gt; /usr/lib/libQtGui.so.4 (0x2ac49000)<br>         libQtNetwork.so.4 =&gt; /usr/lib/libQtNetwork.so.4 (0x2b6ae000)<br>         libQtCore.so.4 =&gt; /usr/lib/libQtCore.so.4 (0x2b7d6000)<br>         libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x2ab6a000)<br>         libstdc++.so.6 =&gt; /usr/lib/libstdc++.so.6 (0x2bb35000)<br>         libm.so.6 =&gt; /lib/libm.so.6 (0x2ab8a000)<br>         libgcc_s.so.1 =&gt; /lib/libgcc_s.so.1 (0x2ab40000)<br>         libc.so.6 =&gt; /lib/libc.so.6 (0x2bc07000)<br>         libdl.so.2 =&gt; /lib/libdl.so.2 (0x2bd31000)<br>         librt.so.1 =&gt; /lib/librt.so.1 (0x2ab10000)<br>         /lib/ld-linux.so.3 (0x2aaea000)<br> 看到libts-0.0.so.0说明tslib在qt中移植成功<br> ldd是个脚本,交叉工具链里面找</p> 
<p>拷贝库文件到/usr/lib<br> 在qt-everywhere-opensource-src-4.8.1/lib里面有la、prl、so和so.xxx文件<br> 拷贝so和so.xxx文件就行</p> 
<p>配置环境变量<br> 打开目标板文件系统/etc/profile文件,添加以下<br> export LD_LIBRARY_PATH=/usr/lib/ ----库文件目录<br> export QWS_SIZE=1920x1080   ----分辨率<br> export QWS_MOUSE_PROTO="tslib:/dev/input/touchscreen0 mouseman:/dev/input/mouse0" ----"鼠标"类型</p> 
<p>QWS_MOUSE_PROTO指定qt的鼠标,由【”】【第1个设备名字】【:】【设备文件路径】【空格】【第2个设备名字】【:】【设备文件路径】...【“】构成设备名字不区分大小写<br> 设备名字可以是:(tslib、qnx、integrity、linuxtp、auto、intellimouse、microsoft、mousesystems、mouseman、linuxinput、usb、linuxis...)<br> 该环境变量在qt源码qt-everywhere-opensource-src-4.8.1/src/gui/embedded/Qwindowsystem_qws.cpp的QWSServer::openMouse()函数中读取<br> QString mice=QString::fromLatin1(qgetenv("QWS_MOUSE_PROTO"))语句读入到mice,调试分析可以从这里入手<br> 打印读取的环境变量:qDebug()&lt;&lt;mice,读取环境变量到mice后会判断mice中有多少个空格" ",也就是判断有多少个“鼠标”设备,个数作为后面for语句的循环因子,<br> for语句则调用QWSMouseHandler *handler=d-&gt;newMouseHandler(mouse.at(i))创建"鼠标"句柄,--&gt;QMouseDriverFactory::create--&gt;具体“鼠标”设备句柄的创建函数</p> 
<p>QWSMouseHandler *QMouseDriverFactory::create(const QString&amp; key, const QString &amp;device)<br> {<!-- --><br>     QString driver = key.toLower();<br> #if defined(Q_OS_QNX) &amp;&amp; !defined(QT_NO_QWS_MOUSE_QNX)<br>     if (driver == QLatin1String("qnx") || driver.isEmpty())<br>         return new QQnxMouseHandler(key, device);<br> #endif<br> #if defined(Q_OS_INTEGRITY) &amp;&amp; !defined(QT_NO_MOUSE_INTEGRITY)<br>     if (driver == QLatin1String("integrity") || driver.isEmpty())<br>         return new QIntMouseHandler(key, device);<br> #endif<br> #ifndef QT_NO_QWS_MOUSE_LINUXTP<br>     if (driver == QLatin1String("linuxtp") || driver.isEmpty())<br>         return new QWSLinuxTPMouseHandler(key, device);<br> #endif<br> #ifndef QT_NO_QWS_MOUSE_PC<br>     if (driver == QLatin1String("auto")<br>         || driver == QLatin1String("intellimouse")<br>         || driver == QLatin1String("microsoft")<br>         || driver == QLatin1String("mousesystems")<br>         || driver == QLatin1String("mouseman")<br>         || driver.isEmpty()) {<!-- --><br>         return new QWSPcMouseHandler(key, device);                    //mice...<br>     }<br> #endif<br> #ifndef QT_NO_QWS_MOUSE_TSLIB<br>     if (driver == QLatin1String("tslib") || driver.isEmpty())        //tslib<br>         return new QWSTslibMouseHandler(key, device);<br> #endif<br> # ifndef QT_NO_QWS_MOUSE_LINUXINPUT<br>     if (driver == QLatin1String("linuxinput") || \<br>         driver == QLatin1String("usb") || \<br>         driver == QLatin1String("linuxis"))<br>         return new QWSLinuxInputMouseHandler(device);<br> # endif<br> #ifndef QT_NO_QWS_MOUSE_QVFB<br>     if (driver == QLatin1String("qvfbmouse") || driver == QLatin1String("qvfb"))<br>         return new QVFbMouseHandler(key, device);<br> #endif<br>  <br> #if !defined(Q_OS_WIN32) || defined(QT_MAKEDLL)<br> #ifndef QT_NO_LIBRARY<br>     if (QWSMouseHandlerFactoryInterface *factory = qobject_cast&lt;QWSMouseHandlerFactoryInterface*&gt;(loader()-&gt;instance(driver)))<br>         return factory-&gt;create(driver, device);<br> #endif<br> #endif<br>     return 0;<br> }<br> 如果鼠标类型没指定(mouseman之类的),则默认会调用/dev/input/mice这样会使你的触摸有点漂移的感觉,</p> 
<p>这个情况很多人都碰到过,如果不需要鼠标 指定mouseman:/dev/NULL这样的话就没问题了。<br> 凡是指定了鼠标设备的话都会引起触摸屏有点漂移的感觉.当你再触摸触摸屏时候,qt会读取你的触摸设备的数据和鼠标设备的数据</p> 
<p>结果就是相对位移+绝对位移的处理结果,有点漂移,但还是勉强可以触摸.</p> 
<p>还有一种情况会引起漂移现象,那就是你的环境变量没读取对,<br> 也就是QWS_MOUSE_PROTO为空,所以最好添加qDebug()&lt;&lt;mice去调试一下,悲剧的是我就是碰到这种情况,即使用env查看是正确的也不一定说明你读取的环境变量是对的,你的应用程序<br> 可能是在其他级别的用户或者在其他的bash环境下执行的,你的环境变量不一定对他起效.修改代码调试编译qt时候只需重新make一次,然后把前面说的库文件拷贝过去目标板就行了,<br> 不费时间的</p> 
<p>这里的QWS_MOUSE_PROTO的设置最好要写个shell脚本测试下是否插了鼠标,是否插了触摸屏根据判断的结果来不同的设置QWS_MOUSE_PROTO环境变量最好</p> 
<p>查看你应用程序调用了那个input设备,使用lsof命令工具<br> lsof /dev/input/touchscreen0<br> 打印:<br> COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME<br> xxxx 1771 root   41r   CHR  13,65      0t0 2326 /dev/input/event1<br> 就是说xxxx打开了/dev/input/touchscreen0这个设备,这个设备是链接文件链接到/dev/input/event1</p> 
<p><br> 如果设备文件打开正确，但是触摸时候鼠标指针不动,运行一下ts_calibrate生成pointercal文件后再试试<br> 这里可以添加下面shell脚本,在你打开qt应用程序前先判断是否校正过了,矫正过则执行qt程序,没校正过则校正一下</p> 
<p>if [ ! -f "/etc/pointercal" ]; then <br>     ts_calibrate<br> fi</p> 
<p> 实现触摸屏+鼠标同时热拔插的方法：</p> 
<p>1.export QWS_MOUSE_PROTO="tslib:/dev/input/touchscreen0 mouseman:/dev/input/mice"</p> 
<p>触摸屏的设备节点可以是你自己的设备节点,鼠标的设备节点必须是mice</p> 
<p>2设备节点随着热拔插不能发生变化</p> 
<p>usb触摸屏,如果给hid子系统识别到,那可能受它框架束缚,热拔插节点会变化,我的方法是自己写usb触摸屏驱动,当然要先和hid子系统脱钩</p> 
<p>在/driver/hid/hid-core.c文件中hid_bus_match函数中,添加了</p> 
<p>static int hid_bus_match(struct device *dev, struct device_driver *drv)<br> {<!-- --><br>     struct hid_driver *hdrv = container_of(drv, struct hid_driver, driver);<br>     struct hid_device *hdev = container_of(dev, struct hid_device, dev);<br>  <br>     if(hdev-&gt;vendor==0x1111){<!-- --><br>         //printk("touch__________________________%s\n",__func__);    //touch<br>         return 0;    <br>     }<br> 1111假设是我的触摸屏的厂商id,这样就匹配失败了<br> 其次,自己写的usb触摸屏驱动随着热拔插设备节点也不能变化,那么...</p> 
<p>我们知道input设备是虚拟的设备(没有硬件设备的),那么随着usb的插拔这个虚拟设备并不需要unregister，也就是说你usb_driver的disconnect方法中别input_unregister_device,释放在module_exit中释放</p> 
<p>在usb_driver的probe方法中也别input_allocate_device和input_register_device这两个方法放在module_init的函数中</p> 
<p>这样以input设备节点就不会变了,热拔插也没问题了</p> 
<p>3.鼠标对触摸屏的影响</p> 
<p>qt底层用QSocketNotifier监听着:/dev/input/touchscreen0和/dev/input/mice两个设备节点,一有数据可读就调用其connect指定的SLOT函数(qt的信号与槽)</p> 
<p>tslib的：</p> 
<p>    int fd = ts_fd(dev);//获取设备的fd(/dev/input/touchscreen0)<br>     mouseNotifier = new QSocketNotifier(fd, QSocketNotifier::Read, this);    //创建了QsocketNotifier监听fd<br>     connect(mouseNotifier, SIGNAL(activated(int)),this, SLOT(readMouseData()));//调用readMouseData方法<br> 读数据的函数void QWSTslibMouseHandlerPrivate::readMouseData()</p> 
<p>鼠标的：</p> 
<p>    QSocketNotifier *mouseNotifier = new QSocketNotifier(fd, QSocketNotifier::Read, this);<br>     connect(mouseNotifier, SIGNAL(activated(int)),this, SLOT(readMouseData(int)));<br> 读数据的函数void QWSPcMouseHandlerPrivate::readMouseData(int fd)</p> 
<p>添加点调试信息进去,发现每次点击触摸屏不仅会引起/dev/input/touchscreen0可读,而且会引起/dev/input/mice设备可读.移动鼠标的话就只有/dev/input/mice可读而已,</p> 
<p>so问题必须是出现在/dev/input/mice设备相关的源码中,就是moousedev.c啦.</p> 
<p>我干的活就是注释掉和绝对坐标相关的代码,如下:</p> 
<p>static void mousedev_abs_event(struct input_dev *dev, struct mousedev *mousedev,<br>                 unsigned int code, int value)<br> {<!-- --><br>     int min, max, size;<br> #if 0 //MHB<br>     switch (code) {<!-- --><br>     case ABS_X:<br>         min = input_abs_get_min(dev, ABS_X);<br>         max = input_abs_get_max(dev, ABS_X);<br>     <br>         size = max - min;<br>         if (size == 0)<br>             size = xres ? : 1;<br>  <br>         clamp(value, min, max);<br>         //printk("size=%d,xres=%d\n",size,xres);<br>         mousedev-&gt;packet.x = ((value - min) * xres) / size;<br>         mousedev-&gt;packet.abs_event = 1;<br>         break;<br>  <br>     case ABS_Y:<br>         min = input_abs_get_min(dev, ABS_Y);<br>         max = input_abs_get_max(dev, ABS_Y);<br>  <br>         size = max - min;<br>         if (size == 0)<br>             size = yres ? : 1;<br>  <br>         clamp(value, min, max);<br>         //printk("size=%d,yres=%d\n",size,yres);<br>         mousedev-&gt;packet.y = yres - ((value - min) * yres) / size;<br>         mousedev-&gt;packet.abs_event = 1;<br>         break;<br>     }<br> #endif<br> }<br> 这样注释掉上报的ABS_X和ABS_Y事件对于/dev/input/mice来说等于给截断了,所以触摸的时候不会引起/dev/input/mice设备的可读,同时也不会影响相对位移事件对/dev/input/mice的通讯</p> 
<p>由于mice这个节点是固定的,所以也支持热拔插</p> 
<p>ok现在应该鼠标触摸屏都支持热拔插了,而且鼠标和触摸两个操作不会互相影响了。</p> 
<p> </p> 
<p>补充最近的收获</p> 
<p>由于硬件上的usb开关小板有点设计问题,切换usb的时候只是切换数据口,5v和gnd都没有切换,使得热拔插问题又不行了。</p> 
<p>改成走hid路线,屏蔽usbtouchscreen.c的驱动--&gt;匹配hid</p> 
<p>(hid的代码参考MODULE_AUTHOR("Stephane Chatty &lt;chatty@enac.fr&gt;")的代码高版本内核中drivers/hid/hid-multitouch.c)</p> 
<p>碰到问题1:</p> 
<p>hid驱动识别出是多点的,走多点的驱动,而tslib是只支持单点的,所有出现"selected device is not a touchscreen I understand"</p> 
<p>    if (<br>             !(<br>                 (ioctl(ts-&gt;fd, EVIOCGVERSION, &amp;version) &gt;= 0) &amp;&amp; <br>                 (version == 0x010001) &amp;&amp;<br>                 (ioctl(ts-&gt;fd, EVIOCGBIT(0, sizeof(bit) * 8), &amp;bit) &gt;= 0) &amp;&amp;<br>                 (bit &amp; (1 &lt;&lt; EV_ABS)) &amp;&amp;<br>                 (ioctl(ts-&gt;fd, EVIOCGBIT(EV_ABS, sizeof(absbit) * 8), &amp;absbit) &gt;= 0) &amp;&amp;<br>                 (absbit &amp; (1 &lt;&lt; ABS_X)) &amp;&amp;<br>                 (absbit &amp; (1 &lt;&lt; ABS_Y)) &amp;&amp; <br>                 (absbit &amp; (1 &lt;&lt; ABS_PRESSURE))<br>             )<br>         ) <br>     {<!-- --><br>         fprintf(stderr, "selected device is not a touchscreen I understand\n");<br>         return -1;<br>     }    <br> 解决方法:</p> 
<p>1.修改上报事件:多点改为单点</p> 
<p>驱动中上报事件修改成ABS_X,ABS_Y..</p> 
<p>    for (i=0; i&lt;td-&gt;num_expected; i++)<br>     {<!-- --><br>         input_report_abs(input, ABS_MT_TOUCH_MAJOR, td-&gt;slots[i].valid);<br>         if (td-&gt;slots[i].valid)<br>         {<!-- --><br>             input_report_abs(input, ABS_MT_TRACKING_ID, td-&gt;slots[i].id);<br>             input_report_abs(input, ABS_MT_POSITION_X, td-&gt;slots[i].x);<br>             input_report_abs(input, ABS_MT_POSITION_Y, td-&gt;slots[i].y);<br>         }<br>         input_mt_sync(input);<br>     }<br> 改成</p> 
<p>    input_report_abs(input, ABS_X,td-&gt;slots[i].x);<br>     input_report_abs(input, ABS_Y, td-&gt;slots[i].y);<br>     input_report_abs(input, ABS_PRESSURE, td-&gt;slots[i].valid);    //按下?<br> 2.修改input设备属性设置</p> 
<p>在hidinput_connect函数中</p> 
<p>                if(hid-&gt;vendor==0xxxx){<!-- --><br>                     set_bit(EV_KEY, input_dev-&gt;evbit);<br>                     set_bit(EV_ABS, input_dev-&gt;evbit);<br>                     set_bit(BTN_TOUCH, input_dev-&gt;keybit);<br>                     input_set_abs_params(input_dev, ABS_X, 0, 0x7FFF, 0, 0);<br>                     input_set_abs_params(input_dev, ABS_Y, 0, 0x7FFF, 0, 0);<br>                     input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);<br>                 }<br>                 else{<!-- --><br>                     input_dev-&gt;setkeycode_new = hidinput_setkeycode;<br>                     input_dev-&gt;getkeycode_new = hidinput_getkeycode;<br>                 }<br> ok，这样hid就识别成单点的了,ts_lib就认设备了<br> 注意:hidinput_connect是对所有hid设备都作用的,所以添加if(hid-&gt;vendor==0xxxx) xxxx为厂商ID这个是必须的,不然鼠标键盘等设备会变成触摸屏设备了。</p> 
<p>问题2:热拔插</p> 
<p>在hidinput_connect函数中可以看到input设备是动态分配的</p> 
<p>hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);<br>                 input_dev = input_allocate_device();<br> 虽然udev会识别触摸屏，并产生/dev/input/touchscreen0链接节点(/etc/udev/rules.d/local.rules文件中)</p> 
<p># Create a symlink to any touchscreen input device<br> SUBSYSTEM=="input", KERNEL=="event[0-9]*", SYSFS{modalias}=="input:*-e0*,3,*a0,1,*18,*", SYMLINK+="input/touchscreen0"<br> SUBSYSTEM=="input", KERNEL=="event[0-9]*", SYSFS{modalias}=="ads7846", SYMLINK+="input/touchscreen0"<br> 但是对于tslib来说还是不能热拔插的(必须重启 ts_test或对应的qt程序)<br> 所以需要按以前方法脱离usb设备和input设备,不好改</p> 
<p>索性添加一个虚拟的input设备<br> 在Stephane Chatty的程序中修改</p> 
<p>先添加全局结构体</p> 
<p>#define TOUCH 1<br>  <br> #if TOUCH<br> static struct input_dev *Vtouch;<br> #endif<br> module_init方法中添加</p> 
<p>#if TOUCH<br>     Vtouch=input_allocate_device();    //输入设备内存分配-&gt;设置参数-&gt;注册    <br>     set_bit(EV_KEY, Vtouch-&gt;evbit);    <br>     set_bit(EV_ABS, Vtouch-&gt;evbit);    <br>     set_bit(BTN_TOUCH, Vtouch-&gt;keybit);    <br>     input_set_abs_params(Vtouch, ABS_X, 0, 0x7FFF, 0, 0);    <br>     input_set_abs_params(Vtouch, ABS_Y, 0, 0x7FFF, 0, 0);    <br>     input_set_abs_params(Vtouch, ABS_PRESSURE, 0, 1, 0, 0);    <br>  <br>     Vtouch-&gt;name = "Vtouch";    <br>     Vtouch-&gt;phys = "paomadi";    <br>     Vtouch-&gt;id.bustype = BUS_USB;    <br>     Vtouch-&gt;id.vendor = 0xxxx;    <br>     Vtouch-&gt;id.product = 0x0000;    <br>     Vtouch-&gt;id.version = 0x0000;    <br>     <br>     if(input_register_device(Vtouch))        <br>         printk("input_register_device error!\n");<br> #endif<br> 注意这个Vtouch-&gt;name域,后面有大作用哦</p> 
<p>在module_exit方法中添加</p> 
<p>#if TOUCH    <br>     input_unregister_device(Vtouch);<br> #endif<br> 在上报事件中来个很贱的招</p> 
<p>    input_report_abs(input, ABS_X,td-&gt;slots[i].x);<br>     input_report_abs(input, ABS_Y, td-&gt;slots[i].y);<br>     input_report_abs(input, ABS_PRESSURE, td-&gt;slots[i].valid);<br>  <br>     #if TOUCH    <br>         input_report_abs(Vtouch, ABS_X,td-&gt;slots[i].x);<br>         input_report_abs(Vtouch, ABS_Y, td-&gt;slots[i].y);<br>         input_report_abs(Vtouch, ABS_PRESSURE, td-&gt;slots[i].valid);<br>         input_sync(Vtouch);<br>     #endif<br> 好,这样虚拟的input设备节点就固定了,不会随着usb拔插而改变</p> 
<p>但是它可能是event0也可以是event1...关键看它啥时候给input_register_device了，这就有潜在的危险"万一不是event0呢！"</p> 
<p>souceinsight搜索"event%d"<br> 在/drivers/input/Evdev.c文件的evdev_connect函数中修改</p> 
<p>if(dev-&gt;name=="Vtouch"){    // touch<br>     dev_set_name(&amp;evdev-&gt;dev, "Vtouch");<br> }<br> else{<!-- --><br>     dev_set_name(&amp;evdev-&gt;dev, "event%d", minor);<br> }<br> 编译内核更新到开发板,你会发现/dev/input下没有Vtouch</p> 
<p>so ..修改udev规则/etc/udev/rules.d/udev.rules文件</p> 
<p>#input devices分支下添加</p> 
<p>KERNEL=="Vtouch” NAME="input/%k"</p> 
<p>重启板子/dev/input/Vtouch文件就存在了</p> 
<p>修改ts_lib的配置环境变量</p> 
<p>export QWS_MOUSE_PROTO="tslib:/dev/input/Vtouch mouseman:/dev/input/mice"</p> 
<p>export TSLIB_TSDEVICE="/dev/input/Vtouch"</p> 
<p>ok全部搞定<br> ————————————————<br> 版权声明：本文为CSDN博主「paomadi」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/orz415678659/article/details/9136575</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd326446a404dd506cb86b8b09d927e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络课程笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92b2e3eaf6f7d0d00871ec81655700ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【FCC前端教程】28关学会HTML与HTML5基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>