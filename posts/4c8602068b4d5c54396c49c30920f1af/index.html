<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>为什么会出现梯度爆炸和梯度消失现象？怎么缓解这种现象的发生？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="为什么会出现梯度爆炸和梯度消失现象？怎么缓解这种现象的发生？" />
<meta property="og:description" content="前言：梯度消失现象在深度神经网络训练过程中表现得尤为突出，随着网络层数的加深，损失在反向传播时梯度在不断减小，导致浅层网络的学习进行不下去，参数得不到有效更新。为什么会出现这种现象呢？下面小编将从神经网络反向传播（BP）原理上揭露出现梯度消失和梯度爆炸现象本质以及如何缓解。
目录
1、梯度消失和梯度爆炸的原因
2、解决办法
1、梯度消失和梯度爆炸的原因 以下图为例，通过推导反向传播过程来讲解网络训练过程中梯度消失和梯度爆炸现象产生的原因。
假设训练时需要使用梯度下降法对、、进行参数更新，那么就需要损失反向传播分布对这三个参数求取梯度。
①针对，
②针对，
③针对，根据链式求导法则可知，有3条路径可以到达，如图中的红黄蓝3条线，对的偏导等于这3条路径之和，为了方便，就以红色这条线为例，其中非线性变换部分，是非线性函数。
由上面3式求导过程可以推广，当网络深度大大增加，损失对浅层网络权重参数的偏导可以表示为：
其中表示大致的网络层数，表示非线性变换的次数。
根据上面求参数梯度的公式不难发现，如果要细分的话，梯度消失和梯度爆炸有以下几种原因：①网络深度过大；②激活函数选择不当；③参数初始化不当，导致参数​​​过大或过小；④损失函数选择不当；⑤神经元激活值的分布不当，神经元值过大或过小。在网络的实际学习过程中，①②③项是导致梯度消失和梯度爆炸现象发生的主要因素，但梯度消失和梯度爆炸问题的根源都是因为网络太深，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应。总之，不管发生梯度爆炸还是梯度消失现象，都会导致网络很难学习下去，所以在深度学习任务中要尽量避免这些现象的发生。
2、解决办法 （1）预训练&#43;微调(pre-training&#43;fine-tunning)：其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。
（2）梯度剪切（对梯度设定阈值）：这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内，这可以防止梯度爆炸。
（3）权重正则化：另外一种解决梯度爆炸的手段是采用权重正则化，正则化主要是通过对网络权重做正则来限制过拟合。如果发生梯度爆炸，那么权值就会变的非常大，反过来，通过正则化项来限制权重的大小，也可以在一定程度上防止梯度爆炸的发生。
（4）选择relu等梯度大部分落在常数上（梯度越接近1越好）的激活函数：relu函数的导数在正数部分是恒等于1的，因此在深层网络中使用relu激活函数就不会导致梯度消失和爆炸的问题。
（5）BN：其可以有效解决梯度的理由参考文章https://blog.csdn.net/Mike_honor/article/details/125915321?spm=1001.2014.3001.5501。
（6）残差网络结构
相比较于以前网络的直来直去结构，残差网络中有很多这样的跨层连接结构，这样的结构在反向传播中具有很大的好处，因为跨层连接结构（短路机制）可以无损地传播梯度，不会导致梯度消失。
（7）LSTM的“门(gate)”结构
LSTM全称是长短期记忆网络（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)，如下图，LSTM通过它内部的“门”可以接下来更新的时候“记住”前几次训练的”残留记忆“。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4c8602068b4d5c54396c49c30920f1af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-23T16:12:37+08:00" />
<meta property="article:modified_time" content="2022-07-23T16:12:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">为什么会出现梯度爆炸和梯度消失现象？怎么缓解这种现象的发生？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前言：梯度消失现象在深度神经网络训练过程中表现得尤为突出，随着网络层数的加深，损失在反向传播时梯度在不断减小，导致浅层网络的学习进行不下去，参数得不到有效更新。为什么会出现这种现象呢？下面小编将从神经网络反向传播（BP）原理上揭露出现梯度消失和梯度爆炸现象本质以及如何缓解。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E5%8E%9F%E5%9B%A0-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E5%8E%9F%E5%9B%A0" rel="nofollow">1、梯度消失和梯度爆炸的原因</a></p> 
<p id="2%E3%80%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" rel="nofollow">2、解决办法</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E5%8E%9F%E5%9B%A0">1、梯度消失和梯度爆炸的原因</h2> 
<p>        以下图为例，通过推导反向传播过程来讲解网络训练过程中梯度消失和梯度爆炸现象产生的原因。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/91/d5/VjYsscqb_o.png"></p> 
<p>        假设训练时需要使用梯度下降法对<img alt="\omega _{1}" class="mathcode" src="https://images2.imgbox.com/44/8b/Q2GkaRNj_o.png">、<img alt="\omega _{2}" class="mathcode" src="https://images2.imgbox.com/4f/91/TSfP7TUk_o.png">、<img alt="\omega _{3}" class="mathcode" src="https://images2.imgbox.com/bb/25/UPi1fDxu_o.png">进行参数更新，那么就需要损失反向传播分布对这三个参数求取梯度。</p> 
<p>①针对<img alt="\omega _{3}" class="mathcode" src="https://images2.imgbox.com/ed/6c/nA3JFDXe_o.png">，</p> 
<p style="text-align:center;"><img alt="\frac{\partial loss}{\partial \omega_{3} }=\frac{\partial loss}{\partial y}\frac{\partial y}{\partial \omega _{3}}=\frac{\partial loss}{\partial y}h_{3}" class="mathcode" src="https://images2.imgbox.com/cc/f3/ZenFshXx_o.png"></p> 
<p>②针对<img alt="\omega _{2}" class="mathcode" src="https://images2.imgbox.com/18/37/pXnRZueU_o.png">，</p> 
<p style="text-align:center;"><img alt="\frac{\partial loss}{\partial \omega _{2}}=\frac{\partial loss}{\partial y}\frac{\partial y}{\partial h _{3}}\frac{\partial h_{3}}{\partial \omega _{2}} =\frac{\partial loss}{\partial y}\omega _{3}h_{2}" class="mathcode" src="https://images2.imgbox.com/4b/5f/R70D7dH8_o.png"></p> 
<p>③针对<img alt="\omega _{1}" class="mathcode" src="https://images2.imgbox.com/a5/b6/KSuESSJv_o.png">，根据链式求导法则可知，有3条路径可以到达<img alt="\omega _{1}" class="mathcode" src="https://images2.imgbox.com/32/5c/YjCqfmqq_o.png">，如图中的红黄蓝3条线，对<img alt="\omega _{1}" class="mathcode" src="https://images2.imgbox.com/d6/90/9GsQrj0e_o.png">的偏导等于这3条路径之和，为了方便，就以红色这条线为例，其中非线性变换部分<img alt="h_{2}=\sigma (h_{1})" class="mathcode" src="https://images2.imgbox.com/d5/56/6fdHKswH_o.png">，<img alt="\sigma" class="mathcode" src="https://images2.imgbox.com/d6/c3/XzQuAZ8d_o.png">是非线性函数。</p> 
<p style="text-align:center;"><img alt="\frac{\partial loss}{\partial \omega _{1}}=\frac{\partial loss}{\partial y}\frac{\partial y}{\partial h _{3}}\frac{\partial h_{3}}{\partial h _{2}}\frac{\partial h_{2}}{\partial h_{1}}\frac{\partial h_{1}}{\partial \omega _{1}} =\frac{\partial loss}{\partial y}\omega _{3}\omega _{2}{\sigma }'x_{2}" class="mathcode" src="https://images2.imgbox.com/3f/5a/JUsOfZA5_o.png"></p> 
<p>        由上面3式求导过程可以推广，当网络深度大大增加，损失对浅层网络权重参数的偏导可以表示为：</p> 
<p style="text-align:center;"><img alt="\frac{\partial loss}{\partial \omega _{1}}=\frac{\partial loss}{\partial y}\omega _{n}\omega _{n-1}...\omega _{2}{\sigma }'^{m}x" class="mathcode" src="https://images2.imgbox.com/8a/8b/fvCqH10K_o.png"></p> 
<p>其中<img alt="n" class="mathcode" src="https://images2.imgbox.com/af/a0/LYhO5SD0_o.png">表示大致的网络层数，<img alt="m" class="mathcode" src="https://images2.imgbox.com/a3/63/DaMPKvqp_o.png">表示非线性变换的次数。</p> 
<p>        根据上面求参数梯度的公式不难发现，如果要细分的话，梯度消失和梯度爆炸有以下几种原因：①网络深度过大；②激活函数选择不当；③参数初始化不当，导致参数<img alt="\omega" class="mathcode" src="https://images2.imgbox.com/62/6e/h8irxQ2b_o.png">​​​过大或过小；④损失函数选择不当；⑤神经元激活值的分布不当，神经元值过大或过小。在网络的实际学习过程中，①②③项是导致梯度消失和梯度爆炸现象发生的主要因素，但梯度消失和梯度爆炸问题的根源都是因为网络太深，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应。总之，不管发生梯度爆炸还是梯度消失现象，都会导致网络很难学习下去，所以在深度学习任务中要尽量避免这些现象的发生。</p> 
<h2 id="2%E3%80%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">2、解决办法</h2> 
<p>        （1）预训练+微调(pre-training+fine-tunning)：其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。</p> 
<p>        （2）梯度剪切（对梯度设定阈值）：这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内，这可以防止梯度爆炸。</p> 
<p>        （3）权重正则化：另外一种解决梯度爆炸的手段是采用权重正则化，正则化主要是通过对网络权重做正则来限制过拟合。如果发生梯度爆炸，那么权值就会变的非常大，反过来，通过正则化项来限制权重的大小，也可以在一定程度上防止梯度爆炸的发生。</p> 
<p>         （4）选择relu等梯度大部分落在常数上（梯度越接近1越好）的激活函数：relu函数的导数在正数部分是恒等于1的，因此在深层网络中使用relu激活函数就不会导致梯度消失和爆炸的问题。</p> 
<p>        （5）BN：其可以有效解决梯度的理由参考文章<a class="link-info" href="https://blog.csdn.net/Mike_honor/article/details/125915321?spm=1001.2014.3001.5501" title="https://blog.csdn.net/Mike_honor/article/details/125915321?spm=1001.2014.3001.5501">https://blog.csdn.net/Mike_honor/article/details/125915321?spm=1001.2014.3001.5501</a>。</p> 
<p>        （6）残差网络结构</p> 
<p style="text-align:center;">        <img alt="" src="https://images2.imgbox.com/c2/48/0yXvc16s_o.jpg"></p> 
<p>        相比较于以前网络的直来直去结构，残差网络中有很多这样的跨层连接结构，这样的结构在反向传播中具有很大的好处，因为跨层连接结构（短路机制）可以无损地传播梯度，不会导致梯度消失。</p> 
<p>        （7）LSTM的“门(gate)”结构</p> 
<p>        LSTM全称是长短期记忆网络（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)，如下图，LSTM通过它内部的“门”可以接下来更新的时候“记住”前几次训练的”残留记忆“。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3c/f2/7EHE6IFZ_o.jpg"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd35483c6c11d513fcce8fcbd9f52fcb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言经典50道例题---精华篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8653dba527b469fa0de4840477bb9bd5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">aardio从高级选项卡中分离出独立窗口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>