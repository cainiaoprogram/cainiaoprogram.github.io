<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python模块导入及属性：import - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python模块导入及属性：import" />
<meta property="og:description" content="http://blog.csdn.net/pipisorry/article/details/43313197
模块和包 1. python程序由包（package）、模块（module）和函数组成。
2. 包是由一系列模块组成的集合。当不同作的模块进行按文件夹分类后再组成一个整体的库，可以称为包。为了让Python将目录当做内容包，目录中必须包含__init__.py文件，用于标识当前文件夹是一个包。最简单的情况下，只需要一个空的__init__.py文件即可。包就是一个完成特定任务的工具箱，包的作用是实现程序的重用。包导入会让模块扮演的角色更为明显，也使代码更具有可读性。
3. 模块是处理某一类问题的函数和类的集合，由代码、函数和类组成。函数是一段可以重复多次调用的代码。模块把一组相关的函数或代码组织到一个文件中，一个文件即是一个模块。每个模块文件是一个独立完备的命名空间，一个模块文件不能看到其他文件定义的变量名，除非它明确地导入了那个文件，模块文件起到了最小化命名冲突的作用。
皮皮blog
python中引入包 两种导入语句 导入模块使用import和from语句（都是隐性的赋值语句），以及reload函数。可以导入模块名，还可以指定目录路径（Python代码的目录就称为包），包导入就是把计算机上的目录变成另一个Python命名空间，包的属性就是该目录包含的子目录和模块文件。当多个同名程序文件安装在某机器上时，包导入可以偶尔用来解决导入的不确定性。导入包也使用import和from语句。
import语句 python3引入同一目录下的py文件 注意：python2和python3的包内import语法有区别。
例如在admin.py文件中要引入dealcode.py文件：
1、在目录下有__init__.py文件
2、在admin.py文件中加一行：from . import dealcode
（如果要引入同一目录下的dealcode.py文件中的一个类Hello，在admin.py文件中加一行：from .dealcode import Hello）
可以直接在__init__.py中import，在该目录下的文件都可以使用__init__.py文件中import的东西
如果还是不行的话，注意一下当前目录是否已经被加入PYTHONPATH环境变量中了，
如果是命令行，系统会默认当前目录已经在环境变量中
python2引入同一目录下的py文件 import file_name可以导入当前目录上file_name.py这个模块，但是里面的内容，必须通过file_name.func/file_name.var 来访问。
如果你一直在某个环境，比如解释器下面，你已经导入过某个模块 ，现在你对模块进行了修改，这里你需要用reload modulename来重新载入。Python里，多次import的效果是只有第一次import有用，如果想要重新载入模块应该用reload。
局部import时还可以使用这种语法 __import__(&#39;shutil&#39;).rmtree(DATA_DIR)
subpackage导入时要这样：
__import__(&#39;geopy.distance&#39;).distance.vincenty(i, j).miles
相当于import geopy.distance; distance.vincenty(i, j).miles?
from import语句 另外一种导入方式为import func/var from file_name。这样func/var直接可用，但是file_name是没有定义的。
从file_name中导入所有：import * from file_name。这样会导入所有除了以下划线开头的命名。实际代码中这样做往往是不被鼓励的。
导入模块的两种方式的不同之处 1. 与import类似, 被导入的module仍然会执行且仅执行一次
2. from *** import 的实质
当以 &#34;from *** import &#34; 方式导入module时, python会在当前module 的命名空间中新建相应的命名." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cd54a90ba3e9b6629a37e295defe6359/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-08T16:40:01+08:00" />
<meta property="article:modified_time" content="2023-08-08T16:40:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python模块导入及属性：import</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>http://<a href="http://blog.csdn.net/pipisorry/article/details/43313197" title="blog.csdn.net/pipisorry/article/details/43313197">blog.csdn.net/pipisorry/article/details/43313197</a></p> 
<h2>模块和包</h2> 
<p>1. python程序由包（package）、模块（module）和函数组成。</p> 
<p>2. 包是由一系列模块组成的集合。当不同作的模块进行按文件夹分类后再组成一个整体的库，可以称为包。为了让Python将目录当做内容包，目录中必须包含__init__.py文件，用于标识当前文件夹是一个包。最简单的情况下，只需要一个空的__init__.py文件即可。包就是一个完成特定任务的工具箱，包的作用是实现程序的重用。包导入会让模块扮演的角色更为明显，也使代码更具有可读性。</p> 
<p>3. 模块是处理某一类问题的函数和类的集合，由代码、函数和类组成。函数是一段可以重复多次调用的代码。模块把一组相关的函数或代码组织到一个文件中，一个文件即是一个模块。每个模块文件是一个独立完备的命名空间，一个模块文件不能看到其他文件定义的变量名，除非它明确地导入了那个文件，模块文件起到了最小化命名冲突的作用。</p> 
<p><a href="http://blog.csdn.net/pipisorry" title="皮皮blog">皮皮blog</a></p> 
<p></p> 
<p></p> 
<h2>python中引入包</h2> 
<h3>两种导入语句</h3> 
<p>导入模块使用import和from语句（都是隐性的赋值语句），以及reload函数。可以导入模块名，还可以指定目录路径（Python代码的目录就称为包），包导入就是把计算机上的目录变成另一个Python命名空间，包的属性就是该目录包含的子目录和模块文件。当多个同名程序文件安装在某机器上时，包导入可以偶尔用来解决导入的不确定性。导入包也使用import和from语句。</p> 
<h3>import语句</h3> 
<p></p> 
<h4>python3引入同一目录下的py文件</h4> 
<p>注意：python2和python3的包内import语法有区别。</p> 
<p>例如在admin.py文件中要引入dealcode.py文件：</p> 
<p>1、在目录下有__init__.py文件</p> 
<p>2、在admin.py文件中加一行：from . import dealcode</p> 
<p>（如果要引入同一目录下的dealcode.py文件中的一个类Hello，在admin.py文件中加一行：from .dealcode import Hello）</p> 
<p>可以直接在__init__.py中import，在该目录下的文件都可以使用__init__.py文件中import的东西</p> 
<p>如果还是不行的话，注意一下当前目录是否已经被加入PYTHONPATH环境变量中了，</p> 
<p>如果是命令行，系统会默认当前目录已经在环境变量中</p> 
<h4>python2引入同一目录下的py文件</h4> 
<p>import file_name可以导入当前目录上file_name.py这个模块，但是里面的内容，必须通过file_name.func/file_name.var 来访问。</p> 
<p>如果你一直在某个环境，比如解释器下面，你已经导入过某个模块 ，现在你对模块进行了修改，这里你需要用reload modulename来重新载入。Python里，多次import的效果是只有第一次import有用，如果想要重新载入模块应该用reload。</p> 
<h4>局部import时还可以使用这种语法</h4> 
<p>__import__('shutil').rmtree(<em>DATA_DIR</em>)</p> 
<p>subpackage导入时要这样：</p> 
<p>__import__('geopy.distance').distance.vincenty(<em>i</em>, <em>j</em>).miles</p> 
<p>相当于import geopy.distance; distance.vincenty(i, j).miles?</p> 
<h3>from import语句</h3> 
<p>另外一种导入方式为import func/var from file_name。这样func/var直接可用，但是file_name是没有定义的。</p> 
<p>从file_name中导入所有：import * from file_n<code>ame</code>。这样会导入所有除了以下划线开头的命名。实际代码中这样做往往是不被鼓励的。</p> 
<h3>导入模块的两种方式的不同之处</h3> 
<p>1. 与import类似, 被导入的module仍然会执行且仅执行一次</p> 
<p>2. from *** import 的实质</p> 
<p>当以 "from *** import " 方式导入module时, python会在当前module 的命名空间中新建相应的命名.</p> 
<p>即, "from t2 import var1" 相当于:</p> 
<p>import t2</p> 
<p>var1= t2.var1</p> 
<p>在此过程中有一个隐含的赋值的过程</p> 
<p>由于python赋值操作特性(<a href="http://blog.csdn.net/lianliange85/article/details/17223537" title="参考python变量名本质">参考python变量名本质</a>)，在当前代码中对"var1"的修改并不能影响到t2.py中"var1"的值。同时，在t2.py中对var1的修改也不能反映到当前的代码。如果实在要改，可以这样：import t2; t2.var1 = something</p> 
<h4>包的两种导入模块或模块内函数的/变量的方式可能出现的错误</h4> 
<pre class="has"><code class="language-html">from package import item  # 这种方式，item可以是包中的一个子模块或子包，也可以是包中定义的其他命名，像函数、类、变量。
import item.subitem.subsubitem # 这些子项必须是包，最后的子项是包或模块。但不能为函数、类或变量。否则出错：No module named ***</code></pre> 
<p><strong>Note</strong>: </p> 
<p>1. 陷阱：使用from导入变量，而那些变量碰巧和作用域中现有的变量同名，本地变量就会被悄悄地覆盖掉；使用import则没这个问题。</p> 
<p>2.当b.py文件以from filename import fun方式从a.py文件引入函数fun时，如果有可执行语句在函数fun外，则引入后，执行b.py也会同时执行a.py在函数外的可执行语句，故一般不要把可执行脚本直接写到函数外，实在不想写入函数中也可以使用if __name__ == '__main__':...的方式。</p> 
<p><a href="http://blog.csdn.net/pipisorry" title="皮皮blog">皮皮blog</a></p> 
<p></p> 
<p></p> 
<h2>模块的搜索路径</h2> 
<p>首先会搜索解析器的当前目录。然后会到sys.path变量中给出的目录列表中查找。</p> 
<pre class="has"><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages']</code></pre> 
<ol><li>输入脚 本的目录（当前目录）</li><li>环境变量<code>PYTHONPATH</code>表示的目录列表中搜索</li><li>Ptyon的默认安装路径中搜索。</li></ol> 
<p><strong>Note</strong>:<code><strong>sys.path</strong></code>包含输入模块的目录名列表。我们可以观察到<code>sys.path</code>的第一个字符串是空的——这个空的字符串表示当前目录也是<code>sys.path</code>的一部分，这与<code>PYTHONPATH</code>环境变量是相同的。这意味着你可以直接输入位于当前目录的模块。否则，你得把你的模块放在<code>sys.path</code>所列的目录之一。[<a href="http://blog.csdn.net/pipisorry/article/details/42167683" title="python系统模块sys、os和路径、系统命令">python系统模块sys、os和路径、系统命令</a>]</p> 
<p><a href="http://blog.csdn.net/pipisorry" title="皮皮blog">皮皮blog</a></p> 
<p></p> 
<p></p> 
<h2 id="-">从 * 导入包和__init__.py 中的__all__ 列表</h2> 
<p>当用户写下 <code>from sound.Effects import *</code> 时会发生什么事？理想中，总是希望在文件系统中找出包中所有的子模块，然后导入它们。这可能会花掉很有长时间，并且出现期待之外的边界效应，导出了希望只能显式导入的包。</p> 
<p>对于包的作者来说唯一的解决方案就是给提供一个明确的包索引。</p> 
<h4>import 语句按如下条件进行转换：</h4> 
<p>执行 <code>from package import *</code>时，如果包中的<strong><code>__init__.py</code> 代码定义了一个名为<code>__all__</code> 的列表，就会按照列表中给出的模块名进行导入。</strong>新版本的包发布时作者可以任意更新这个列表。如果包作者不想 import * 的时候导入他们的包中所有模块，那么也可能会决定不支持它（ import * ）。例如，<code>sounds/effects/__init__.py</code> 这个文件可能包括如下代码:</p> 
<pre class="has"><code>__all__ = ["echo", "surround", "reverse"]</code></pre> 
<p>这意味着 <code>from Sound.Effects import *</code> 语句会从 sound 包中导入以上三个已命名的子模块。</p> 
<p>如果没有定义 <code>__all__</code> ， <code>from Sound.Effects import *</code> 语句 不会 从 sound.effects 包中导入所有的子模块。无论包中定义多少命名，只能确定的是导入了 sound.effects 包（可能会运行<code>__init__.py</code> 中的初始化代码）以及包中定义的所有命名会随之导入。这样就从<code>__init__.py</code> 中导入了每一个命名（以及明确导入的子模块）。同样也包括了前述的 import 语句从包中明确导入的子模块。</p> 
<p>考虑以下代码:</p> 
<pre class="has"><code>import sound.effects.echo
import sound.effects.surround
from sound.effects import *</code></pre> 
<p>在这个例子中，echo 和 surround 模块导入了当前的命名空间，这是因为执行 from...import 语句时它们已经定义在 sound.effects 包中了（定义了<code>__all__</code>时也会同样工作）。</p> 
<p>尽管某些模块设计为使用 import * 时它只导出符全某种模式的命名，仍然不建议在生产代码中使用这种写法。</p> 
<p>记住，from Package import specific_submodule 没有错误！事实上，除非导入的模块需要使用其它包中的同名子模块，否则这是推荐的写法。</p> 
<p><a href="http://blog.csdn.net/pipisorry" title="皮皮blog">皮皮blog</a></p> 
<p></p> 
<p></p> 
<h2>包的绝对导入和相对导入</h2> 
<h3>python 2.7及之前版本</h3> 
<p>中默认是先“相对”后“绝对”的顺序搜索模块，也就是说先在模块所在同一个包内搜索然后在sys.path中搜索。为此，所有的导入现在都被认为是绝对的, 也就是说这些名字必须通过 Python 路径(sys.path 或是 PYTHONPATH )来访问。python 2.x在包内模块的导入，顺序是：<br> 1、当前目录<br> 2、上一个目录<br> 3、找不到再往上<br> 4、系统环境变量<br> 5、标准库<br> 6、前三个在搜索路径下的 .pth文件</p> 
<h3>Python 2.7之后版本</h3> 
<h4 style="background-color:transparent;">包的绝对导入</h4> 
<p>很多情况下导入子包会导致和真正的标准库模块发生(事实上是它们的名字)冲突。 包模块会把名字相同的标准库模块隐藏掉, 因为它首先在包内执行相对导入, 隐藏掉标准库模块。</p> 
<p>从 Python 2.7 开始默认绝对导入。 python3.x 中的包内的模块导入原则编程了：如果要相对导入，那么一定是显式声明，并且，这个声明不是告诉python一个模块查找偏好，而是一种约束（也就是说，一旦声明，必须是相对导入）</p> 
<p><code>from __future__ import absolute_import</code>: 在 3.0 以前的旧版本中启用相对导入等特性所必须的 future 语句。</p> 
<p><strong>Python3绝对导入：</strong>按照sys.path顺序搜索，先主目录（sys.path中第一项''），然后PYTHONPATH环境变量、标准库路径、pth指定路径等。</p> 
<h4>包的相对导入</h4> 
<p>import 语句总是绝对导入的, 所以<strong>相对导入只应用于 from-import 语句</strong>。</p> 
<p>Python3相对导入：在模块所在同一个包内搜索，注意该包目录与主目录的区别。Python3中，每一个点号代替上一层目录。这样做的目的，主要是防止覆盖命名空间。</p> 
<p><strong>Note</strong>:从当前目录相对导入可以省略.号，不过不省略更好，以免之后修改系统不会自动调整（使用pycharm时，移动文件时，有.号它会自动修改导入路径）。</p> 
<p><strong>Example</strong></p> 
<p>Phone/</p> 
<p>        __init__.py<br>        common_util.py           #其中包含setup<br>         Fax/<br>               __init__.py<br>               G3.py                       #其中包含dial<br>          Mobile/<br>                __init__.py<br>                Analog.py               #其中包含dial<br>                Digital.py</p> 
<p>在 Mobile.Analog.Digital , 也就是 <strong>Digital.py 模块中,</strong> 不能简单地使用<strong>错误语法</strong>(只能工作在旧版本的 Python 下, 在新的版本中它会导致一个警告, 或者干脆不能工作)<br> import Analog<br> from Analog import dial</p> 
<p><strong>正确绝对导入方法：</strong></p> 
<p>from Phone.Mobile.Analog import dial</p> 
<p><strong>正确相对导入方法:</strong><br> from .Analog import dial            # . 代表当前.py文件所在目录Mobile/<br> from ..common_util import setup<br> from ..Fax import G3.dial.</p> 
<p>[Python核心编程2ed]</p> 
<p>[<a href="http://blog.csdn.net/liberize/article/details/8882659" title="Python 相对导入">Python 相对导入</a>]</p> 
<h3>相对导入要注意的问题和常见错误</h3> 
<p>lz总结的一个模块导入法则：Use relative import only in modules and run the scripts outside the package. 也就是说使用相对导入的文件不应该是要运行执行的文件，而应该只是外层调用的模块。但是如果你非要在packges里面做测试的话，那就不要使用相对导入。Note that relative imports are based on the name of the current module. Since the name of the main module is always "__main__", modules intended for use as the main module of a Python application must always use absolute imports.[<a href="https://docs.python.org/3/tutorial/modules.html#intra-package-references" rel="nofollow" title="documentation">documentation</a>]</p> 
<h4>终极解决方案</h4> 
<pre class="has"><code class="language-html">import sys
import os
#将mymodule模块（目录）所在的目录（如这个py文件的../..）加入到pythonpath中就可以使用from mymodule import *了
</code></pre> 
<pre class="has"><code class="language-html">sys.path.append(os.path.join(os.path.split(os.path.realpath(__file__))[0],"../..")) </code></pre> 
<p>try:<br>  from .mymodule import myclass<br> except Exception: #ImportError<br>  from mymodule import myclass</p> 
<p>示例</p> 
<p>Note: 最顶层的SocialNetworks是一个单纯的目录，而下层的SocialNetworks开始就是一个python package.</p> 
<p>运行MainTest.py，EBM中导入的就是try中的import</p> 
<p><img alt="" class="has" height="238" src="https://images2.imgbox.com/09/88/YXSlWbuY_o.png" width="532">   <img alt="" class="has" height="235" src="https://images2.imgbox.com/b8/b2/yOUjaKiQ_o.png" width="534"></p> 
<p>直接运行EBM.py，是从except中import的</p> 
<p><img alt="" class="has" height="241" src="https://images2.imgbox.com/bf/b2/nCKFtgox_o.png" width="540"></p> 
<p>也就是使用</p> 
<pre class="lang-py prettyprint prettyprinted"><code>try:
    from .mymodule import myclass
except Exception: #ImportError
    from mymodule import myclass</code></pre> 
<p>来区分包内和包外的运行测试。</p> 
<p>[<a class="question-hyperlink" href="http://stackoverflow.com/questions/33837717/systemerror-parent-module-not-loaded-cannot-perform-relative-import" rel="nofollow" title="SystemError: Parent module '' not loaded, cannot perform relative import">SystemError: Parent module '' not loaded, cannot perform relative import</a>]</p> 
<p>后来lz发现pycharm中不用加入路径就可以导入except中的语句，from SocialNetworks.SocialNetworks引入成功的原因是lz在pycharm中添加了add content roots to pythonpath了，这样sys.path中多了一个整个项目project的路径/media/pika/files/mine/python_workspace，里面的目录就被当成包使用，所以可以引入成功！在代码中加入路径后，在pycharm之外也可以正常运行from SocialNetworks.SocialNetworks了，所以lz建议关闭pycharm的add roots to pythonpath这种功能。</p> 
<p>[<a class="question-hyperlink" href="http://stackoverflow.com/questions/21199382/why-does-pycharm-always-add-contents-root-to-my-pythonpath-and-what-pythonpat" rel="nofollow" title="Why does PyCharm always add “contents root” to my PYTHONPATH, and what PYTHONPATH?">Why does PyCharm always add “contents root” to my PYTHONPATH, and what PYTHONPATH?</a>]</p> 
<p>下面这几个错误好像都可以使用上述的方法解决，下面是以前总结的解决方案，不怎么好。</p> 
<h4>python拓展包的调用</h4> 
<p>&gt;&gt;&gt; import sys<br> &gt;&gt;&gt; sys.path<br> ['', '/home/pipi/ENV/ubuntu_env/lib/python35.zip', '/home/pipi/ENV/ubuntu_env/lib/python3.5', '/home/pipi/ENV/ubuntu_env/lib/python3.5/plat-x86_64-linux-gnu', '/home/pipi/ENV/ubuntu_env/lib/python3.5/lib-dynload', '/usr/lib/python3.5', '/usr/lib/python3.5/plat-x86_64-linux-gnu', '/home/pipi/ENV/ubuntu_env/lib/python3.5/site-packages']<br> 可以看到/home/pipi/ENV/ubuntu_env/lib/python3.5/site-packages在sys.path中，所以可以在python中调用这些不同的拓展包（如使用pip安装的包）。</p> 
<p>1.报错：ValueError: Attempted relative import beyond toplevel packages</p> 
<p><strong>案例1：</strong></p> 
<p>目录树<br> case1/<br> ├── cat<br> │   ├── __init__.py<br> │   ├── cat.py<br> ├── dog<br> │   ├── __init__.py<br> │   └── dog.py<br> ├── __init__.py<br> └── main.py<br>  <br> 代码<br> # case1/cat/cat.py<br> from .. import dog<br><br> # case1/main.py<br> import cat.cat<br><br> 执行<br> python case1/main.py<br><br> 错误原因:<br> 这里的 case1 是一个包，但当你直接执行 main.py 的时候，就没有把完整的 case1 当作一个包来处理了( the package should be entirely self contained. It won't treat case1/ as a package when you're running main.py inside it.)，而cat和dog还是包，并且已经是包树的顶层了。可想而知，下层的 cat.py (import cat.cat)自然找不到上层包了，想要相对导入成功，必须让下层的被导入对象是上层包或上层包内的对象。</p> 
<p>所以使用相对导入的目录的平级目录内的所有py文件不允许单独执行（当然局部测试时是可以的，而不是将包中的py文件当作主应用程序执行），要保证这个模块不是入口文件(py文件中有if __name__ == '__main__'，其实也不一定有这个，只要你执行就算是)，只是作为被导入的模块才可以以这样使用。</p> 
<p>python 中只能在package中使用相对导入，不能在用户的应用程序中使用相对导入，因为不论是相对导入还是绝对导入，都是相当于当前模块来说的，对于用户的主应用程序，也就是入口文件，模块名总是为“ __main__  ”, 所以用户的应用程序（如NLP目录下有一个main.py[包含__main__]，要执行的）必须使用绝对导入，而package（如__main__调用的包NLP\TargetOpinion）中的导入可以使用相对导入。</p> 
<p>When launching a python source file, it is forbidden to import another file, that is in the current package, using relative import.</p> 
<p><strong>解决：</strong></p> 
<p>1 假设整个项目目录NLP\TargetOpinion\***；将主程序移出到package（即TargetOpinion\***）外，TargetOpinion中的子packages可以互相相对导入，但是package即TargetOpinion目录下不能有main模块，要移到外面，如NLP目录下，与TargetOpinion平齐。</p> 
<p>当然上面案例就是将main.py放到case1平齐的目录中，如case1_1。</p> 
<p>2 如果main.py想放到与TargetOpinion平齐的目录中，如NLP\test，这时也不能使用..TargetOpinion来调用，但是可以先将NLP目录加入path：sys.path.append(os.path.join(os.path.split(os.path.realpath(__file__))[0], ".."))，再使用TargetOpinion来调用。</p> 
<p>报错2：SystemError: Parent module '' not loaded, cannot perform relative import？</p> 
<p>这种情况一般是因为case1不是包（目录下没有__init__），而 cat.cat.py要调用dog.dog.py（from ..dog import dog），这样上层..不是包不能导入出错。</p> 
<p>不过在pycharm中设置source root（或者加入../..到sys.path中）好像也可以解决。</p> 
<p>[<a href="http://blog.csdn.net/pipisorry/article/details/39909057" title="pycharm快捷键、常用设置、配置管理 ">pycharm快捷键、常用设置、配置管理 </a> ]</p> 
<p><strong>案例2：</strong></p> 
<p>目录树<br> case3/<br> ├── alpaca.py<br> ├── main.py<br> └── pets<br>     ├── __init__.py<br>     ├── cat<br>     │   ├── __init__.py<br>     │   └── cat.py<br>     └── dog<br>         ├── __init__.py<br>         └── dog.py<br><br> 代码<br> # case3/pets/cat/cat.py<br> from ..dog import dog<br> from .. import dog<br> # case3/main.py<br> from pets.cat import cat<br><br> 执行<br> python case3/main.py<br><br> 请注意，这里的 cat.py 中是不能导入 alpaca 的，因为 pets 已经是这个包树的顶层了（case3中包含main.py其中包含main函数，这样case3就不会被当作包？）。</p> 
<p>2.ImportError: No module named '***'</p> 
<p>sys.path没有加入导入的模块所在目录</p> 
<p>3.忌两个py文件循环导入</p> 
<p>4. 使用相对导入非本级目录的py也禁止单独运行</p> 
<p>否则报错： ValueError: Attempted relative import in non-package</p> 
<p>[<a href="http://blog.csdn.net/l7946381/article/details/9401585" title="python的relation import">python的relation import</a>]</p> 
<p>[<a href="http://www.itnose.net/detail/6232982.html" rel="nofollow" title="python package module import 完全总结">python package module import 完全总结</a>]</p> 
<p>[<a href="http://www.dai3.com/python-import.html" rel="nofollow" title="python 下 import 模块使用相对路径">python 下 import 模块使用相对路径</a>]</p> 
<h3>在软件包内部只进行相对导入</h3> 
<p>在子模块中你时常见到的一个简单错误，就是使用软件包的名字来导入软件包。</p> 
<p><code># within a sub-module</code></p> 
<p><code>from</code> <code>a_package </code><code>import</code> <code>APackageError</code></p> 
<p>这样做会导致两个不好的结果：</p> 
<ol><li>子模块只有当软件包被安装在 PYTHONPATH 内才能正确运行。</li><li>子模块只有当这个软件包的名字是 a_package 时才能正确运行。</li></ol> 
<p>尽管第一条看上去并不是什么大问题，但是考虑一下，如果你在 PYTHONPATH 下的两个目录中，有两个同名的软件包。你的子模块可能最终导入了另一个软件包，你将无意间使得某个或某些对此毫无戒备的程序员（或是你自己）debug 到深夜。</p> 
<p>所以说，在软件包中最好只进行相对导入，而运行的执行文件（__main__）都放在软件包外面。</p> 
<h3>AttributeError: 'module' object has no attribute '***'</h3> 
<p>如import scipy或者import dateutil后</p> 
<p>使用scipy.misc或者dateutil.parser出错</p> 
<p>原因：because the parser.py is a module in the dateutil package. It's a separate file in the folder structure.所以要手动添加。其实主要是ubuntu_env/lib/python3.5/site-packages/dateutil$ vi __init__.py中没有from . import subpackages，自己修改一下就好了，不过它本身没这么加肯定有它的原因，lz暂时还没搞清楚。</p> 
<p>解决：所以最好还是使用import dateutil.parser或者from dateutil import parser来导入模块。</p> 
<p>[<a href="http://blog.csdn.net/pipisorry/article/details/39123171" title="Scipy教程 - python数值计算库 ">Scipy教程 - python数值计算库 </a>]</p> 
<p><a href="http://blog.csdn.net/pipisorry" title="皮皮blog">皮皮blog</a></p> 
<p></p> 
<p></p> 
<h4>让模块保持较小的规模</h4> 
<p>你的模块应当比较小。记住，那个使用你软件包的程序员会在软件包作用域进行导入，同时你会使用你的 <code>__init__.py </code>文件来作为一个组织工具，来暴露一个完整的接口。</p> 
<p><strong>好的做法</strong>是一个模块只定义一个类，伴随一些帮助方法和工厂方法来协助建立这个模块。</p> 
<p><code>class</code> <code>APackageClass(</code><code>object</code><code>):</code></p> 
<p><code>    </code><code>'''One class'''</code></p> 
<p><code>def</code> <code>apackage_builder(how_many):</code></p> 
<p><code>    </code><code>for</code><code>i</code><code>in</code><code>range</code><code>(how_many):</code></p> 
<p><code>        </code><code>yield</code><code>APackageClass()</code></p> 
<p>如果你的模块暴露了一些方法，把一些相互依赖的方法分为一组放进一个模块，并且把不相互依赖的方法移动到单独的模块中，一个例子是 <a href="https://github.com/axialmarket/fsq/blob/master/fsq/enqueue.py" title="fsq/enqueue.py">fsq/enqueue.py</a>，它暴露了一系列的方法来为同一个功能提供不同的接口（就像 simplejson 中的l oad/loads）。尽管这个例子足够直观，让你的模块保持较小规模需要一些判断，但是<strong>一个好的原则</strong>是：当你有疑问的时候，就去创建一个新的子模块吧。</p> 
<h4>字节编译文件.pyc</h4> 
<p>输入一个模块相对来说是一个比较费时的事情，所以Python做了一些技巧，以便使输入模块更加快一些。</p> 
<p>一种方法是创建 字节编译的文件 ，这些文件以.pyc作为扩展名。字节编译的文件与Python变换程序的中间状态有关。{一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码运行 程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。}</p> 
<p>当你在下次从别的程序输入这个模块的时候，<code>.pyc</code>文件是十分有用的——它会快得多，因为一部分输入模块所需的处理已经完成了。另外，这些字节编译的文件也是与平台无关的。</p> 
<p><a href="http://blog.csdn.net/pipisorry" title="皮皮blog">皮皮blog</a></p> 
<h4>模块内的所有定义</h4> 
<p><strong><code>dir()</code>函数</strong></p> 
<p>当你为dir()提供一个模块名的时候，它返回模块定义的名称列表（函数、类和变量）。如果不提供参数，它返回当前模块中定义的名称列表(当前解释器中定义的命名)。</p> 
<pre class="has"><code>&gt;&gt;&gt; import fibo
&gt;&gt;&gt; dir(fibo)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'fib', 'fib2']
&gt;&gt;&gt; dir()
['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'fibo']</code></pre> 
<p><code>dir()</code>并不会列出内置函数和变量名。如果你想列出这些内容，它们在标准模块<code>__builtin__</code>中定义。</p> 
<p>curModuleDir=dir()  # get dir of current file(module)同时这句话放在模块（.py）文件函数或类外面</p> 
<p><strong>修改dir函数表现</strong></p> 
<p><code>class</code> <code>Shape(</code><code>object</code><code>):</code></p> 
<p><code>        </code><code>def</code><code>__dir__(</code><code>self</code><code>):</code></p> 
<p><code>            </code><code>return</code><code>[</code><code>'area'</code><code>,</code><code>'perimeter'</code><code>,</code><code>'location'</code><code>]</code></p> 
<p>则返回指定的三个函数字符串</p> 
<p><strong>模块的__name__属性</strong></p> 
<p>当一个模块被第一次输入import的时候，这个模块的主块将被运行。假如我们只想在程序本身被使用的时候运行主块，而在它被别的模块输入的时候不运行主块，这可以通过模块的__name__属性完成。</p> 
<p><a href="http://images.cnblogs.com/cnblogs_com/wei-li/201203/201203250139151134.png" rel="nofollow" title="​编辑">​编辑</a></p> 
<p>每个Python模块都有它的<code>__name__</code>，如果它是<code>'__main__'</code>，这说明这个模块被用户单独运行，我们可以进行相应的恰当操作。</p> 
<p>[<a class="singleposttitle" href="http://www.cppblog.com/volant/archive/2009/10/16/98773.html" rel="nofollow" id="viewpost1_TitleUrl" title="Python内置函数--dir">Python内置函数--dir</a>]</p> 
<p></p> 
<h4>Import成功但是pycharm中无法点击进入</h4> 
<p>使用torch.utils.data.DataLoader时，pycharm中无法直接点击进入代码。</p> 
<p>torch.utils Cannot find reference 'utils' in '__init__.pyi</p> 
<p>可以通过更新torch到1.6.0解决，但是会出另一个问题：Cannot find reference 'data' in '__init__.pyi</p> 
<p>解决方法：同时</p> 
<p>import torch<br> import torch.utils.data   #这样就可以了</p> 
<p>from:<a href="http://blog.csdn.net/pipisorry/article/details/43313197" title="python模块导入及属性：import_python 为模块增添属性_-柚子皮-的博客-CSDN博客">python模块导入及属性：import_python 为模块增添属性_-柚子皮-的博客-CSDN博客</a></p> 
<p>ref:<a href="http://www.cnblogs.com/wei-li/archive/2012/03/25/2416291.html" rel="nofollow" title="简明python教程-模块和包">简明python教程-模块和包</a></p> 
<p><a href="http://www.cnblogs.com/ronny/p/4519516.html" rel="nofollow" id="cb_post_title_url" title="深入Python模块的使用">深入Python模块的使用</a></p> 
<p><a href="http://python.jobbole.com/81579/#comment-93075" rel="nofollow" title="构建健壮 Python 包的 5 个简单规则">构建健壮 Python 包的 5 个简单规则</a></p> 
<p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NzU0MzU0Nw==&amp;mid=210543177&amp;idx=1&amp;sn=ae385e72acbf842fcd1576e02c98d2d4#rd" rel="nofollow" title="深扒Python是如何找到模块的?">深扒Python是如何找到模块的?</a></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e801198b2e88ae3d06c2256c2372e831/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js：Markdown编辑器Vue3版本md-editor-v3</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70920b74ff0fc47a172f21f17e034c0e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【简单数论】求乘法逆元</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>