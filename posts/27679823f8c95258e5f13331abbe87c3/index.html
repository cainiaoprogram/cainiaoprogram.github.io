<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue填坑之路——Day1（基础） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue填坑之路——Day1（基础）" />
<meta property="og:description" content="MVVM模式 MVVM、MVC、MVP都是架构模式，这里是这三者的图示。vue中MVVM架构如下： Vue基本语法 Vue实例和Vue组件 Vue实例由Vue函数创建。
var vm = new Vue({ // }) Vue组件也是Vue实例，组件可以扩展html元素，封装可重用代码。
// 注册 Vue.component(&#39;my-component&#39;, { template: &#39;&lt;div&gt;A custom component!&lt;/div&gt;&#39; }) // 创建根实例 new Vue({ el: &#39;#example&#39; }) 渲染为
&lt;div id=&#34;example&#34;&gt; &lt;div&gt;A custom component!&lt;/div&gt; &lt;/div&gt; 父子组件通信 参考笔记
父组件给子组件传递字符串 // html &lt;div id=&#34;m-dialog&#34;&gt; &lt;!-- &lt;child value=&#34;str&#34;&gt;&lt;/child&gt; 该种方法“只能传递字符串”， 将child的data中的value = &#34;str&#34;;不需要父组件data中有数据 --&gt; &lt;child value=&#34;str&#34;&gt;&lt;/child&gt; &lt;/div&gt; // js // 注册子组件 Vue.component(&#34;child&#34;, { // 获取value的依赖 props:[&#34;value&#34;], template: &#39;&lt;span&gt;{{ value }}&lt;/span&gt;&#39; }); // 父实例 new Vue({ // 这里的el可视为父组件 el:&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/27679823f8c95258e5f13331abbe87c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-02-09T00:07:52+08:00" />
<meta property="article:modified_time" content="2018-02-09T00:07:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue填坑之路——Day1（基础）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4 id="mvvm模式">MVVM模式</h4> 
<p>MVVM、MVC、MVP都是架构模式，<a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" rel="nofollow">这里</a>是这三者的图示。vue中MVVM架构如下： <br> <img src="https://images2.imgbox.com/6e/39/IgGxYytA_o.png" alt="这里写图片描述" title=""></p> 
<hr> 
<h4 id="vue基本语法">Vue基本语法</h4> 
<h5 id="vue实例和vue组件">Vue实例和Vue组件</h5> 
<p>Vue实例由<code>Vue</code>函数创建。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
<span class="hljs-comment">//</span>
})</code></pre> 
<p>Vue组件也是Vue实例，组件可以扩展html元素，封装可重用代码。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// 注册</span>
Vue.component(<span class="hljs-string">'my-component'</span>, {
  template: <span class="hljs-string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span>
})

<span class="hljs-comment">// 创建根实例</span>
<span class="hljs-keyword">new</span> Vue({
  el: <span class="hljs-string">'#example'</span>
})</code></pre> 
<p>渲染为</p> 
<pre class="prettyprint"><code class=" hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-property">id</span>=<span class="hljs-string">"example"</span>&gt;
  &lt;<span class="hljs-keyword">div</span>&gt;A custom component!&lt;/<span class="hljs-keyword">div</span>&gt;
&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre> 
<h5 id="父子组件通信">父子组件通信</h5> 
<p>参考<a href="https://github.com/Kelichao/vue.js.2.0/issues/22">笔记</a></p> 
<h6 id="父组件给子组件传递字符串">父组件给子组件传递字符串</h6> 
<pre class="prettyprint"><code class=" hljs xml">// html
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"m-dialog"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 
&lt;child value="str"&gt;&lt;/child&gt;
该种方法“只能传递字符串”，
将child的data中的value = "str";不需要父组件data中有数据
 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">child</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"str"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">child</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></code></pre> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// js</span>
<span class="hljs-comment">// 注册子组件</span>
Vue.component(<span class="hljs-string">"child"</span>, {
    <span class="hljs-comment">// 获取value的依赖</span>
    props:[<span class="hljs-string">"value"</span>],
    template: <span class="hljs-string">'&lt;span&gt;{<!-- -->{ value }}&lt;/span&gt;'</span>
});

<span class="hljs-comment">// 父实例</span>
<span class="hljs-keyword">new</span> Vue({
    <span class="hljs-comment">// 这里的el可视为父组件</span>
    el:<span class="hljs-string">"#m-dialog"</span>
});</code></pre> 
<p>渲染结果 <br> <img src="https://images2.imgbox.com/06/12/vALnUCfa_o.png" alt="这里写图片描述" title=""></p> 
<h6 id="父组件给子组件传递数据动态prop">父组件给子组件传递数据（动态prop）</h6> 
<p>使用<code>v-bind</code> 绑定子组件的data，如果父组件的<code>flag</code>发生改变，会传递给子组件。</p> 
<pre class="prettyprint"><code class=" hljs xml">// html
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"m-dialog"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">child</span> <span class="hljs-attribute">v-bind:state</span> = '<span class="hljs-attribute">flag</span>'&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">child</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></code></pre> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// js</span>
Vue.component(<span class="hljs-string">"child"</span>, {
    props:[<span class="hljs-string">"state"</span>],
    template: <span class="hljs-string">'&lt;span&gt;{<!-- -->{ state }}&lt;/span&gt;'</span>
});
<span class="hljs-keyword">new</span> Vue({
    el:<span class="hljs-string">"#m-dialog"</span>,
    data: {
        flag: <span class="hljs-keyword">true</span>
    }
});</code></pre> 
<p>渲染结果</p> 
<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-literal">true</span></code></pre> 
<h6 id="子组件数据emit给父组件">子组件数据emit给父组件</h6> 
<pre class="prettyprint"><code class=" hljs xml">// html
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"m-dialog"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- v-on:cancle="other"表示如果触发组件中的cancle事件则连带触发父组件中的other时间--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">child</span> <span class="hljs-attribute">v-on:cancle</span>=<span class="hljs-value">"other"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">child</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></code></pre> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-comment">// js</span>
Vue.component(<span class="hljs-string">"child"</span>, {
    template: <span class="hljs-string">'&lt;button v-on:click="cancle"&gt;我是按钮，点我触发父组件事件&lt;/button&gt;'</span>,
    methods: {
        cancle: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {<!-- --></span>
            <span class="hljs-comment">// 与父组件通信一定要加上这句话</span>
            <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'cancle'</span>);
        }
    }
});
<span class="hljs-keyword">var</span> vue1 = <span class="hljs-keyword">new</span> Vue({
    <span class="hljs-comment">// 这里的el可视为父组件</span>
    <span class="hljs-comment">// 所以下面这个片段是放在#m-dialog里面的</span>
    el:<span class="hljs-string">"#m-dialog"</span>,
    data: {
        flag: <span class="hljs-literal">true</span>
    },
    methods: {
        other: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {<!-- --></span>
            alert();
        }
    }
});</code></pre> 
<h6 id="ref属性">ref属性</h6> 
<p>使用 <code>ref</code> 为子组件 / 元素指定一个引用 ID：<code>ref = 'ID'</code>。通过<code>vm.$refs.ID</code> 获取该组件/元素。</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">child</span> <span class="hljs-attribute">ref</span> = '<span class="hljs-attribute">mycom</span>'&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">child</span>&gt;</span> // 子组件
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></code></pre> 
<p>则在父组件中，通过<code>vm.$refs.mycom</code> 获取整个子组件对象。（vm是父组件）</p> 
<hr> 
<h5 id="指令">指令</h5> 
<h6 id="mustache语法v-text和v-html">Mustache语法、v-text和v-html</h6> 
<ul><li><code>{<!-- -->{content}}</code> 更新文本（部分文本）的textContent</li><li><code>&lt;div v-text = 'content'&gt;&lt;/div&gt;</code> 插入的content会被解析为字符串</li><li><code>&lt;div v-html = 'content'&gt;&lt;/div&gt;</code> 更新div的innerHtml，<strong>内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong>。</li></ul> 
<h6 id="v-cloak">v-cloak</h6> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml">// html
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">v-cloak</span>&gt;</span> </span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">content</span> }}</span><span class="xml"> <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>

// css
[v-cloak] {
  display: none;
}</span></code></pre> 
<p>则div中content会在vue实例准备完毕之后才显示。次方法可以避免网速较慢时候，<code>{<!-- -->{ content }}</code> 引起的闪烁。</p> 
<h6 id="v-bind">v-bind</h6> 
<ul><li>绑定class </li></ul> 
<pre class="prettyprint"><code class=" hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-type">class</span> = <span class="hljs-string">"static"</span> v-bind: <span class="hljs-type">class</span> = <span class="hljs-string">"{ active: isActive, 'text-danger': hasError }"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre> 
<p>若data如下</p> 
<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span><span class="hljs-container">()</span> <span class="hljs-container">{
  <span class="hljs-title">return</span> {
    <span class="hljs-title">isActive</span>: <span class="hljs-title">true</span>,
    <span class="hljs-title">hasError</span>: <span class="hljs-title">false</span>
    }</span></span>
  }</code></pre> 
<p>结果渲染为<code>&lt;div class = "static active"&gt;&lt;/div&gt;</code> <br> 绑定的数据对象不必内联定义在模板中</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">// 渲染结果同上</span>
<span class="hljs-subst">&lt;</span>div v<span class="hljs-attribute">-bind</span>:class<span class="hljs-subst">=</span><span class="hljs-string">"classObject"</span><span class="hljs-subst">&gt;&lt;</span>/div<span class="hljs-subst">&gt;</span>
<span class="hljs-built_in">data</span>: {
  classObject: {
    active: <span class="hljs-literal">true</span>,
    <span class="hljs-string">'text-danger'</span>: <span class="hljs-literal">false</span>
  }
}</code></pre> 
<p>也可以返回绑定对象的计算属性</p> 
<pre class="prettyprint"><code class=" hljs actionscript">&lt;div v-bind:<span class="hljs-class"><span class="hljs-keyword">class</span>="<span class="hljs-title">classObject</span>"&gt;&lt;/<span class="hljs-title">div</span>&gt;
<span class="hljs-title">data</span>: {<!-- --></span>
  isActive: <span class="hljs-literal">true</span>,
  error: <span class="hljs-literal">null</span>
},
computed: {
  classObject: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {<!-- --></span>
    <span class="hljs-keyword">return</span> {
      active: <span class="hljs-keyword">this</span>.isActive &amp;&amp; !<span class="hljs-keyword">this</span>.error,
      <span class="hljs-string">'text-danger'</span>: <span class="hljs-keyword">this</span>.error &amp;&amp; <span class="hljs-keyword">this</span>.error.type === <span class="hljs-string">'fatal'</span>
    }
  }
}</code></pre> 
<ul><li>绑定style</li><li>绑定元素的属性 <br> 例如，绑定一个input标签的name属性</li></ul> 
<pre class="prettyprint"><code class=" hljs haskell">&lt;input <span class="hljs-typedef"><span class="hljs-keyword">type</span> = 'text' v-bind = "<span class="hljs-container">{ <span class="hljs-title">value</span>: '<span class="hljs-title">hello</span> ' + <span class="hljs-title">name</span> }</span>" /&gt;</span>

// <span class="hljs-typedef"><span class="hljs-keyword">data</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">data</span><span class="hljs-container">()</span> <span class="hljs-container">{
  <span class="hljs-title">name</span>: '<span class="hljs-title">hello</span> <span class="hljs-title">world</span>!'
}</span></span></code></pre> 
<p>渲染结果 <br> <img src="https://images2.imgbox.com/90/d8/HOTnuZ11_o.png" alt="这里写图片描述" title=""></p> 
<h6 id="v-model">v-model</h6> 
<p>上面input的value值如果发生改变，是不会“同步”到data中的name值，要实现“双向绑定”，需要使用<code>v-model</code> 指令。一般用在表单输入绑定，input、textarea等。</p> 
<h6 id="v-for">v-for</h6> 
<p>vue2.0之后，要访问遍历的数组中对象的下标，要把index写在括号中第二位。</p> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">v-for</span> = "(<span class="hljs-attribute">item</span>, <span class="hljs-attribute">index</span>) <span class="hljs-attribute">in</span> <span class="hljs-attribute">items</span>"&gt;</span></span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">index</span> }}</span><span class="xml"> - </span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">item</span> }}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>

// data
items: ['item1', 'item2', 'item3']</span></code></pre> 
<p>结果 <br> <img src="https://images2.imgbox.com/4c/e4/QruqZEwb_o.png" alt="这里写图片描述" title=""> <br> 遍历一个对象的属性及属性值</p> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">v-for</span> = "(<span class="hljs-attribute">item</span>, <span class="hljs-attribute">key</span>) <span class="hljs-attribute">in</span> <span class="hljs-attribute">user</span>"&gt;</span>
        </span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">key</span> }}</span><span class="xml">-</span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">item</span> }}</span><span class="xml">
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>

// data
user: {
    name: 'userName',
    age: 20
}</span></code></pre> 
<p>结果 <br> <img src="https://images2.imgbox.com/29/ed/07TA0d1f_o.png" alt="这里写图片描述" title=""></p> 
<p>列表渲染中的key属性 <br> key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p> 
<p>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。 <br> 假如<code>v-for</code> 出来的元素中有相同的，console会华丽丽打出warning</p> 
<pre class="prettyprint"><code class=" hljs markdown">[<span class="hljs-link_reference">Vue warn</span>]:<span class="hljs-link_url"> Duplicate keys detected: '重复渲染项'. This may cause an update error.</span></code></pre> 
<p>它也可以用于<strong>强制替换元素/组件</strong>而不是重复使用它。当你遇到如下场景时它可能会很有用：</p> 
<ul><li>完整地触发组件的生命周期钩子</li><li>触发过渡</li></ul> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">transition</span> <span class="hljs-attribute">name</span> = '<span class="hljs-attribute">fade</span>'&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span></span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">text</span> }}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">transition</span>&gt;</span></span></code></pre> 
<p>如果<code>span</code> 没有绑定<code>key</code> 属性，则在text发生改变的时候，<code>transition</code> 组件会被重复使用，此时text文本被简单替换，不会触发元素过渡效果。 <br> <img src="https://images2.imgbox.com/26/5c/LEovdQ5g_o.gif" alt="这里写图片描述" title=""> <br> 为span元素绑定key属性<code>&lt;span :key = 'text'&gt;{<!-- -->{ text }}&lt;/span&gt;</code> ，则text发生变化的时候，<code>transition</code> 组件会被替换/重新渲染。 <br> <img src="https://images2.imgbox.com/9e/59/lxEqMGlp_o.gif" alt="这里写图片描述" title=""></p> 
<h6 id="v-if-vs-v-show">v-if vs v-show</h6> 
<p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p> 
<p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p> 
<p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS <code>display: none;</code>进行切换。</p> 
<p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p> 
<h6 id="v-on">v-on</h6> 
<p>用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。简写<code>@</code> <br> 在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符，以下几种写法等效。</p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 只有在 `keyCode` 是 13 时（enter键）调用 `vm.submit()` --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">v-on:keyup.13</span>=<span class="hljs-value">"submit"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 同上 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">v-on:keyup.enter</span>=<span class="hljs-value">"submit"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 缩写语法 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">input</span> @<span class="hljs-attribute">keyup.enter</span>=<span class="hljs-value">"submit"</span>&gt;</span></code></pre> 
<p>可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">// 可以使用 v-on:keyup<span class="hljs-preprocessor">.f</span>1
Vue<span class="hljs-preprocessor">.config</span><span class="hljs-preprocessor">.keyCodes</span><span class="hljs-preprocessor">.f</span>1 = <span class="hljs-number">112</span></code></pre> 
<hr> 
<h5 id="watch与计算属性computed">watch与计算属性computed</h5> 
<h6 id="computed">computed</h6> 
<p>模板内的表达式<code>{<!-- -->{ expression }}</code> 的逻辑若太复杂，不好看也不易维护。</p> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"example"</span>&gt;</span>
  </span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">message.split</span>('')<span class="hljs-variable">.reverse</span>()<span class="hljs-variable">.join</span>('') }}</span><span class="xml">
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></span></code></pre> 
<p>此时使用计算属性。</p> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"example"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Original message: "</span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">message</span> }}</span><span class="xml">"<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Computed reversed message: "</span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">reversedMessage</span> }}</span><span class="xml">"<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></span></code></pre> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
  el: <span class="hljs-string">'#example'</span>,
  data: {
    message: <span class="hljs-string">'Hello'</span>
  },
  computed: {
    <span class="hljs-comment">// 计算属性的 getter</span>
    reversedMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {<!-- --></span>
      <span class="hljs-comment">// `this` 指向 vm 实例</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message.split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>)
    }
  }
})</code></pre> 
<p>结果： <br> Original message: “Hello”</p> 
<p>Computed reversed message: “olleH”</p> 
<p>也可以在<code>methods</code> 中定义一个<code>reversedMessage</code> 方法。效果一样。但是两者也有区别：</p> 
<p><strong>[Note]</strong> <code>computed</code> 只有在相关依赖发生变化的时候，才会重新求值。例如<code>reversedMessage</code> 属性依赖<code>message</code> 属性，如果<code>message</code> 不改变，<code>reversedMessage</code> 不会更新，此时多次访问<code>reversedMessage</code> 会<strong>立即</strong>返回缓存的值。 <br> 看这个例子：</p> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml">// html

<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>date: '</span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">date</span> }}</span><span class="xml">'<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>date + 1: '</span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">dateAdd</span> }}</span><span class="xml">'<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-comment">&lt;!-- past 的值在vue实例生成后，不再改变 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>computed: past: '</span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">past</span> }}</span><span class="xml">'<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>function called: now: '</span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">now</span>() }}</span><span class="xml">'<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span></span></code></pre> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-comment">// javascript</span>

<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
    el:<span class="hljs-string">"#app"</span>,
    data: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{<!-- --></span>
        <span class="hljs-keyword">return</span> {
            message: <span class="hljs-string">'Hello'</span>,
            date: <span class="hljs-number">1518673470535</span>
        }
    },
    computed: {
        <span class="hljs-comment">// 计算属性dateAdd的依赖是date</span>
        dateAdd: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {<!-- --></span>
            console.log(<span class="hljs-string">'computed: date + 1'</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.date + <span class="hljs-number">1</span>
        },

        <span class="hljs-comment">// 计算属性past没有依赖date</span>
        past: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {<!-- --></span>
            console.log(<span class="hljs-string">'computed: past'</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now()
        }
     },
    methods: {
        now: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {<!-- --></span>
            console.log(<span class="hljs-string">'function called: now'</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now()
        }
    }
    });</code></pre> 
<p><code>vm</code> 实例第一次生成后，计算属性<code>dateAdd</code> 和<code>past</code> 第一次更新。<code>now()</code> 函数调用，所以在控制台可以看到三个消息： <br> <img src="https://images2.imgbox.com/44/7e/VskjBzJI_o.png" alt="这里写图片描述" title=""> <br> 改变date的值</p> 
<ul><li><code>dateAdd</code> 更新。</li><li>因为<code>past</code> 的值不依赖<code>date</code> ，所以它不更新。</li><li>触发重新渲染，函数 <code>now()</code> 会执行，页面中<code>{<!-- -->{ now() }}</code> 也会更新。 <br> <img src="https://images2.imgbox.com/07/bb/m3czIlLS_o.png" alt="这里写图片描述" title=""></li></ul> 
<h6 id="watch">watch</h6> 
<p>监听数据变化，特别是在有些数据会随着其他数据变化时变化，当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p> 
<pre class="prettyprint"><code class=" hljs scala"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
    el:<span class="hljs-string">"#app"</span>,
    data: function(){
        <span class="hljs-keyword">return</span> {
            firstName: <span class="hljs-string">'html'</span>,
            lastName: <span class="hljs-string">'css'</span>,
            fullName: <span class="hljs-string">'html-css'</span>
        }
    },
    watch: {
        <span class="hljs-comment">// firstName 发生改变的时候，这个函数会立刻被调用</span>
        <span class="hljs-javadoc">/**
        params：
        newval：firstName新值
        oldval：firstName旧值
        **/</span>
        firstName: function(newval, oldval) {
        <span class="hljs-comment">// 更新fullName</span>
        <span class="hljs-keyword">this</span>.fullName = <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">'-'</span> + <span class="hljs-keyword">this</span>.lastName
        }
    }
    });</code></pre> 
<p><code>watch</code> 属性中<code>firstName</code> 函数，作用就是监听<code>firstName</code> 的值，参数<code>newval</code>、<code>oldval</code> 都是可选的。</p> 
<p>监控路由对象：</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-string">'$route'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(newRoute, oldRoute)</span>{<!-- --></span>
    <span class="hljs-comment">// 获取新的路由对象和旧的路由对象</span>
    <span class="hljs-comment">// 对一些特定页面或者特殊操作（如返回），执行某些操作</span>
}</code></pre> 
<hr> 
<h5 id="过滤">过滤</h5> 
<ul><li>列表渲染<code>v-for</code> 渲染结果的过滤：在computed属性中使用js内置filter</li></ul> 
<pre class="prettyprint"><code class=" hljs livecodeserver">// html<span class="hljs-comment">
// ...</span>
&lt;tr v-<span class="hljs-keyword">for</span> = <span class="hljs-string">'item in filterItems'</span>&gt;
    &lt;td&gt;{<!-- -->{ <span class="hljs-keyword">item</span>.id }}&lt;/td&gt;
    &lt;td&gt;{<!-- -->{ <span class="hljs-keyword">item</span>.<span class="hljs-keyword">text</span> }}&lt;/td&gt;
    &lt;td&gt;{<!-- -->{ <span class="hljs-keyword">item</span>.ctime }}&lt;/td&gt;
    &lt;td&gt;
        &lt;button @click = <span class="hljs-string">'remove(item.id)'</span>&gt;<span class="hljs-built_in">delete</span>&lt;/button&gt;
    &lt;/td&gt;
&lt;/tr&gt;
<span class="hljs-comment">
// js</span>
computed: {
    filterItems: <span class="hljs-function"><span class="hljs-keyword">function</span>() {<!-- --></span>
        var self = this
        <span class="hljs-constant">return</span> self.<span class="hljs-keyword">items</span>.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-title">item</span>){<!-- --></span>
            <span class="hljs-constant">return</span> <span class="hljs-keyword">item</span>.<span class="hljs-keyword">text</span>.indexOf(self.<span class="hljs-built_in">value</span>) !== -<span class="hljs-number">1</span>
        })
    }
}
<span class="hljs-comment">
// data</span>
<span class="hljs-built_in">value</span>: <span class="hljs-string">''</span></code></pre> 
<p>效果 <br> <img src="https://images2.imgbox.com/7d/fa/BOf3EAOQ_o.gif" alt="这里写图片描述" title=""></p> 
<ul><li>本地过滤器 <br> 在vue组件<code>filter</code> 属性中定义私有过滤器。</li></ul> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- 在双花括号中 --&gt;</span>
</span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">message</span> | <span class="hljs-variable">capitalize</span> }}</span><span class="xml">

<span class="hljs-comment">&lt;!-- 在 `v-bind` 中 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">v-bind:id</span>=<span class="hljs-value">"rawId | formatId"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></span></code></pre> 
<pre class="prettyprint"><code class=" hljs r">filters: {
  capitalize: <span class="hljs-keyword">function</span>(value){
    // <span class="hljs-keyword">...</span>
  }
}</code></pre> 
<p>value是默认参数，取自过滤器capitalize左边<strong>管道符(|)的左边的参数</strong>，这里是message。有这几机制，则可以很好理解多级过滤。</p> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml"></span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">message</span> | <span class="hljs-variable">filterA</span> | <span class="hljs-variable">filterB</span> }}</span><span class="xml"></span></code></pre> 
<p>过滤器是js的函数，有一个取自管道符(|)左边的默认参数，也可以向过滤器传递参数。</p> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml"></span><span class="hljs-expression">{<!-- -->{ <span class="hljs-variable">message</span> | <span class="hljs-variable">filterA</span>('<span class="hljs-variable">arg</span>1', <span class="hljs-variable">arg</span>2) }}</span><span class="xml"></span></code></pre> 
<p>以上filterA接受三个参数，第一个参数是默认参数<code>message</code>，第二个参数是字符串常量<code>'arg1</code> ，第三个参数是表达式<code>arg</code> 。</p> 
<p>在创建Vue实例之前，定义全局过滤器。</p> 
<pre class="prettyprint"><code class=" hljs r">Vue.filter(<span class="hljs-string">'capitalize'</span>, <span class="hljs-keyword">function</span> (value) {
  <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
  value = value.toString()
  <span class="hljs-keyword">return</span> value.charAt(<span class="hljs-number">0</span>).toUpperCase() + value.slice(<span class="hljs-number">1</span>)
})

new Vue({
  // <span class="hljs-keyword">...</span>
})</code></pre> 
<h5 id="自定义指令">自定义指令</h5> 
<p>全局注册</p> 
<pre class="prettyprint"><code class=" hljs javascript">Vue.directive(<span class="hljs-string">'不带 v- 的指令名称'</span>, {
  钩子函数: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(para)</span>{<!-- --></span>}
}</code></pre> 
<p>局部注册</p> 
<pre class="prettyprint"><code class=" hljs javascript">directives: {
  <span class="hljs-string">'不带v-的指令名称'</span>: {
    钩子函数: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(para)</span>{<!-- --></span>}
    }
}</code></pre> 
<p>钩子函数</p> 
<blockquote> 
 <p><strong>bind</strong>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 <br> <strong>inserted</strong>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 <br> <strong>update</strong>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。 <br> <strong>componentUpdated</strong>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 <br> <strong>unbind</strong>：只调用一次，指令与元素解绑时调用。</p> 
</blockquote> 
<p>钩子函数的参数<code>el</code>、<code>binding</code>、<code>vnode</code>、<code>oldVnode</code>。见<a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" rel="nofollow">官网-钩子函数的参数</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df675eb39b17d785a623a6cb8ee43e92/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kotlin的伴生对象的理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/77f0b73fa50623ffdd44f888eae37c7a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Broken pipe错误解释</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>