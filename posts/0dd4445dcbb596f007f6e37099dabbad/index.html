<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ZT 匿名内存映射 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ZT 匿名内存映射" />
<meta property="og:description" content="mmap函数使用 分类： Linux/Unix C/C&#43;&#43; 2008-01-22 17:03 6089人阅读 评论(1) 收藏 举报 unix 编程 null 网络 UNIX网络编程第二卷进程间通信对mmap函数进行了说明。该函数主要用途有三个：
1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读写，以获得较高的性能；
2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；
3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。
函数：void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offsize); 参数start：指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。
参数length：代表将文件中多大的部分映射到内存。
参数prot：映射区域的保护方式。可以为以下几种方式的组合：
PROT_EXEC 映射区域可被执行
PROT_READ 映射区域可被读取
PROT_WRITE 映射区域可被写入
PROT_NONE 映射区域不能存取
参数flags：影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。
MAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。
MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。
MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。
MAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。
MAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。
MAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。
参数fd：要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。
参数offset：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。
返回值：
若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。
错误代码：
EBADF 参数fd 不是有效的文件描述词
EACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用MAP_SHARED则要有PROT_WRITE以及该文件要能写入。
EINVAL 参数start、length 或offset有一个不合法。
EAGAIN 文件被锁住，或是有太多内存被锁住。
ENOMEM 内存不足。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0dd4445dcbb596f007f6e37099dabbad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-10T22:33:53+08:00" />
<meta property="article:modified_time" content="2019-07-10T22:33:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ZT 匿名内存映射</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <h4><span class="link_title"><a href="http://blog.csdn.net/scorpio16/article/details/2059623"> mmap函数使用 </a></span></h4> 
 <div class="article_manage"> 
  <span class="link_categories"> 分类： <a href="http://blog.csdn.net/scorpio16/article/category/260771">Linux/Unix</a> <a href="http://blog.csdn.net/scorpio16/article/category/260770">C/C++</a> </span> 
  <span class="link_postdate">2008-01-22 17:03</span> 
  <span class="link_view" title="阅读次数">6089人阅读</span> 
  <span class="link_comments" title="评论次数"><a href="http://blog.csdn.net/scorpio16/article/details/2059623#comments">评论</a>(1)</span> 
  <span class="link_collect"><a title="收藏">收藏</a></span> 
  <span class="link_report"><a title="举报" href="http://blog.csdn.net/scorpio16/article/details/2059623#report">举报</a></span> 
 </div> 
 <div class="tag2box"> 
  <a href="http://www.csdn.net/tag/unix">unix</a> 
  <a href="http://www.csdn.net/tag/%E7%BC%96%E7%A8%8B">编程</a> 
  <a href="http://www.csdn.net/tag/null">null</a> 
  <a href="http://www.csdn.net/tag/%E7%BD%91%E7%BB%9C">网络</a> 
 </div> 
 <p>UNIX网络编程第二卷进程间通信对mmap函数进行了说明。该函数主要用途有三个：<br>1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读写，以获得较高的性能；<br>2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；<br>3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。<br><span style="font-weight:bold;"><br>函数</span>：void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offsize); </p> 
 <p><span style="font-weight:bold;">参数start</span>：指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。</p> 
 <p><span style="font-weight:bold;">参数length</span>：代表将文件中多大的部分映射到内存。</p> 
 <p><span style="font-weight:bold;">参数prot</span>：映射区域的保护方式。可以为以下几种方式的组合：<br>PROT_EXEC 映射区域可被执行<br>PROT_READ 映射区域可被读取<br>PROT_WRITE 映射区域可被写入<br>PROT_NONE 映射区域不能存取</p> 
 <p><span style="font-weight:bold;">参数flags：</span>影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。<br>MAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。<br>MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。<br>MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。<br>MAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。<br>MAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。<br>MAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。</p> 
 <p><span style="font-weight:bold;">参数fd</span>：要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</p> 
 <p style="font-weight:bold;">参数offset<span style="font-weight:normal;">：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</span></p> 
 <p><span style="font-weight:bold;">返回值：</span></p> 
 <p>若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。</p> 
 <p><span style="font-weight:bold;">错误代码：</span></p> 
 <p>EBADF 参数fd 不是有效的文件描述词<br>EACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用MAP_SHARED则要有PROT_WRITE以及该文件要能写入。<br>EINVAL 参数start、length 或offset有一个不合法。<br>EAGAIN 文件被锁住，或是有太多内存被锁住。<br>ENOMEM 内存不足。</p> 
 <p> <span style="font-weight:bold;">系统调用mmap()用于共享内存的两种方式：</span></p> 
 <p><span style="font-weight:bold;">（1）</span>使用普通文件提供的内存映射：</p> 
 <p>适用于任何进程之间。此时，需要打开或创建一个文件，然后再调用mmap()</p> 
 <p>典型调用代码如下：</p> 
 <p>fd=open(name, flag, mode); if(fd&lt;0) ...</p> 
 <p>ptr=mmap(NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED , fd , 0); </p> 
 <p>通过mmap()实现共享内存的通信方式有许多特点和要注意的地方，可以参看UNIX网络编程第二卷。</p> 
 <p><span style="font-weight:bold;">（2）</span>使用特殊文件提供匿名内存映射：</p> 
 <p> 适用于具有亲缘关系的进程之间。由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用 fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区 域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。 对于具有亲缘关系的进程实现共享内存最好的方式应该是采用匿名内存映射的方式。此时，不必指定具体的文件，只要设置相应的标志即可。</p> 
 <p> </p> 
 <p> </p> 
 <div id="sina_keyword_ad_area2" class="articalContent"> 
  <h4 align="center"><span style="font-family:'微软雅黑';font-size:x-large;">Unix/Linux的内存映射</span>  </h4> 
  <div> 
   <p><span style="font-family:'宋体';"><strong><span style="color:#0000ff;">共享内存</span></strong>可以说 是最有用的进程间通信方式,也是最快的IPC形式;两个不同的进程A和B共享内存的意思就是:同一块物理内存即被映射到进程A的地址空间中又内映射到进程 B的地址空间中.进程A可以实时地看到进程B对共享内存中数据的更新,反之,进程B也可以实时地看到进程A对共享内存的更新;由于多个进程同时访问同一块 共享内存区域,那就需要某种同步机制来保证多个不同进程对共享内存的访问,互斥锁、信号量/信号灯、信号量集都可以;</span></p> 
   <p><span style="font-family:'宋体';">采用共享内存来实现进程间通信的一个很明显的好处就是:进程可以直接读写内存,基本上不需要任何额外的数据拷贝. 而对于像管道、消息队列之类的IPC方式,则需要在内核空间和用户空间之间进行四次数据拷贝,而共享内存则只需要两次拷贝:一次是从输入文件拷贝到共享内 存区,另外一次是从共享内存区拷贝到输出文件中.实际上,进程之间在共享内存时,并不总是读写少量数据后就解除映射,有新的通信时,再重新建立共享内存区 域,而是保持共享区域,直到通信完毕为止;这样,数据内容一直保存在共享内存中,并没有写回文件.共享内存中的数据内容往往是在解除映射时才写回文件的. 因此,采用共享内存的通信方式是非常有效的;</span></p> 
   <p><span style="font-family:'宋体';">Linux的2.2.x以后的内核版本支持多种共享内存方式,比如:内存映射mmap、POSIX共享内存、System V共享内存;</span></p> 
   <p><span style="font-family:'宋体';"><strong><span style="color:#0000ff;">一、内核怎样保证各个进程寻址到同一块共享内存区域的内存页面</span></strong>:<br> 1、page cache及swap cache中页面的区分:一个被访问文件的物理页面都驻留在page cache或swap cache中,一个页面的所有信息由struct page来描述,struct page结构中有一个字段为指针mapping,它指向一个struct address_space类型的结构.page cache或swap cache中的所有页面就是根据struct address_space结构以及一个偏移量来区分的;<br> 2、文件与struct address_space结构的对应:一个具体的文件被打开之后,内核会在内存中为之建立一个struct inode结构类型的节点,其中的i_mapping字段指向一个struct address_space类型的结构,这样,一个文件就对应一个struct address_space结构,一个struct address_space和一个偏移量就可以确定一个page cache或swap cache中的一个页面.因此,当要寻址某个数据的时候,很容易根据给定的文件及数据在文件内的偏移量范围之内找到对应的页面;<br> 3、进程调用mmap()时,只是在进程的地址空间中新增加了一块相应大小的缓冲区,并设置另外相应的访问标识,但是并没有建立进程地址空间到物理页面的映射.所以,第一次访问该空间时,会引发一个缺页异常;<br> 4、对于共享内存的情况,缺页异常处理程序首先在swap cache中寻找目标页(符合struct address_space以及偏移量的物理页),如果找到,则直接返回该页的地址;如果没找到,则判断该页是否在交换分区(swap area)中存在,如果存在,则执行一个换入操作;如果上述两种情况都不满足,则缺页处理程序将分配新的物理页,并把它插入到page cache中.进程最终将更新进程页表;<br><strong><span style="color:#ff0000;">注意</span></strong>:对于映射普通文件(非共享映射)的情况,缺页处理程序首先会在page cache中根据struct address_space和偏移量寻找相应页面.如果没找到,则说明文件数据还没有读入内存,处理程序会从磁盘读入相应的文件页面,并返回相应的页面地址,同时,进程页表也会被更新;<br> 换句话说,对于共享内存来说,缺页处理程序是在swap cache和swap area中寻找相应的页面,而对于非共享映射(映射普通文件)来说,则是在page cache来寻找对应的页面;<br> 5、所有进程在映射同一块共享内存区域时,情况都一样,在建立线性地址与物理地址之间的映射之后,不论进程各自返回的地址如何,实际上访问的必然都是同一块共享内存区域对应的物理页面.<br> 注意:一块共享区域可以看作是特殊文件系统shm中的一个特殊文件,shm的安装点在交换分区上;<br><strong><span style="color:#0000ff;">二、内存映射</span></strong>:<br> 实际上,内存映射机制并不是完全为了共享内存的目的而设计的,它本身提供了不同于一般普通文件的访问方式,进程可以像访问内存一样对普通文件进程操作.而POSIX或System V共享内存IPC则纯粹是用于共享内存的目的.当然内存映射实现共享内存,也是内存映射的应用之一;<br><strong><span style="color:#ff0000;">内存映射机制的用途</span></strong>:A、以访问内存的方式读写文件; B、实现共享内存;<br><strong><span style="color:#0000ff;">三、mmap()系统调用</span></strong>:<br>    mmap()系统调用使得进程之间通过映射同一个普通文件而实现共享内存的目的.普通文件被映射到进程的地址空间之后,进程就可以像访问普通内存一样对文件进行访问,不必再调用read()、write()等系统调用操作.<br>    mmap()系统调用介绍:<br>    void* mmap(void* addr, size_t len, int prot, int flags, int fd, off_t offset);<br>    该函数在进程的地址空间与文件对象或共享内存对象之间建立一种映射关系;<br>    addr  :该参数指定文件应该被映射到进程地址空间的起始地址,一般被指定为一个空指针,此时,程序把选择起始地址的任务留给内核来完成了.这个地址是进程地址空间中需要映射到文件中的内存区域的首地址;也就是说,在进程地址空间中用于文件映射的内存区域的首地址;<br>    len   :文件被映射到调用进程的地址空间中的字节数,它从被映射文件开头offset个字节处开始算起,取len个字节,把文件中的这len个字节的文件空间映射到进程的地址空间中;<br>    port  :指定文件被映射到内存中之后的访问权限.可取的值有:PORT_READ(可读)、PORT_WRITE(可写)、PORT_EXEC(可执行)、PORT_NONE(不可访问);<br>    flags :映射标记;取值如下:MAP_SHARED、MAP_PRIVATE、MAP_FIXED,其中,MAP_SHARED和MAP_PRIVATE必选其一,而MAP_FIXED则不推荐使用;<br>    fd    :即将被映射到进程地址空间中的文件的描述符.一般由系统调用open()返回;同时,fd可以指定为-1,此时,必须指定flags参数中的 MAP_ANON,表明进程的是匿名映射(不涉及具体的文件名,避免了文件的创建及打开,很显然,只能用于具有亲属关系的进程之间的通信).<br>    offset:从文件开头计算offset个字节处开始映射;也就是,文件中需要被映射的文件内容的起始地址,这个起始地址的计算是以文件开头为参照的;这个参数一般取值为0,表示从文件开头处开始映射;<br>    返回值:文件最终映射到进程地址空间中的起始地址;进程可直接以该地址为有效的起始地址进行操作;也就是文件中开始映射的起始字节点到进程中对应映射内存区的起始地址点处的一个映射;换句话就是说,在进程地址空间中用于文件映射的内存区域的首地址;<br><strong><span style="color:#0000ff;">四、系统调用mmap()用于共享内存的两种方式</span></strong>:<br>    A、使用普通文件提供的内存映射/共享内存:适用于任何进程之间;此时,需要使用系统调用open()事先打开或创建一个文件,然后再调用mmap():<br>       fd = open(filename, flag, mode);<br>       ......<br>       ptr = mmap(NULL, len, PORT_READ|PORT_WRITE, MAP_SHARED, fd, 0);<br>       使用特殊文件提供<a name="baidusnap0"></a><strong style="color:#000000;">匿名内存映射</strong>: 适用于具有亲属关系的进程之间;由于父子进程之间的这种特殊的父子关系,在父进程中先调用mmap(),然后调用fork(),那么,在调用fork() 之后,子进程继承了父进程的所有资源,当然也包括匿名映射后的地址空间和mmap()返回的地址,这样,父子进程就可以通过映射区域进行通信了;<br>       <strong><span style="color:#ff0000;">注意</span></strong>:这里不是一般的继承关系.一般来说,子进程单独维护从父进程继承下来的一些变量,而mmap()返回的地址却是由父子进程共同维护的;对于具有亲属关系的进程之间实现共享内存的最好方式应该是采用匿名映射的方式.此时,不必指定具体的条件,只要设置相应的标志即可.<br><strong><span style="color:#0000ff;">五、解除内存映射关系</span></strong>:<br>    当进程间通信结束时,需要解除文件页面空间到进程地址空间之间的映射关系;也就说,进程通信结束时,需要把挂载到进程地址空间上的文件卸载下来;这个任务由系统调用munmap();<br>    int munmap(void* addr, size_t len);<br>    该系统调用用于在进程地址空间中结束映射关系;<br>    addr:是调用mmap()返回的进程地址空间中用于文件映射的内存区域的首地址;<br>    len :进程地址空间中映射区域的大小,单位:字节;<br>    当映射关系解除之后,对原来映射地址的访问将导致段错误发生;<br>    返回值: -1:失败; 0:成功;<br><strong><span style="color:#0000ff;">六、内存映射的同步</span></strong>:<br>    一般来说,进程在映射空间中对共享内容的修改并不会直接写回到磁盘文件中,往往在调用munmap()之后才会同步输出到磁盘文件中.那么,在程序运行过 程中,在调用munmap()之前,可以通过调用msync()来实现磁盘上文件内容与共享内存区中的内容与一致;或者是把对共享内存区的修改同步输出到 磁盘文件中;<br><strong><span style="color:#ff0000;">注意</span></strong>:<br> 1、最终被映射文件内容的长度不会超过文件本身的初始大小,即:内存映射操作不能改变文件的大小;<br> 2、可以用于进程间通信的得有效地址空间大小大体上受限于被映射文件的大小,但是并不完全受限于文件大小.<br>    在Linux中,内存的保护机制是以内存页为单位的,即使被映射的文件只有一个字节的大小,内核也会为这个文件的映射分配一个页面大小的内存空间.当被映 射文件的大小小于一个页面大小时,进程可以对mmap()返回地址开始的一个页面大小进行访问,而不会出错;但是,如果对一个页面之外的地址空间进行访 问,则导致错误发生.因此,可用于进程间通信的有效地址空间的大小不会超过被映射文件大小与一个页面大小的和;<br> 3、文件一旦被映射之后,调用mmap()的进程对返回地址空间的访问就是对某一内存区域进行访问,暂时脱离了磁盘上文件的影响.所有对mmap()返回 地址空间的操作只在内存范围内有意义,只有在调用了munmap()或msync()之后,才会把映射内存中的相应内容写回到磁盘文件中,所写内容的大小 仍然不会超过被映射文件的大小;<br><strong><span style="color:#0000ff;">七、对mmap()返回的地址空间的访问</span></strong>:<br> Linux采用的是页式管理机制.对于用mmap()映射普通文件来说,进程会在自己的地址空间中新增加一块空间,空间的大小由mmap()的len参数 指定,注意:进程并不一定能够对新增加的全部空间都进行有效的访问.进程能够访问的有效地址空间的大小取决于文件中被映射部分的大小.简单地说,能够容纳 文件中被映射部分大小的最少页面个数决定了进程从mmap()返回的地址开始,能够访问的有效地址空间大小.超过这个空间大小,内核会根据超过的严重程度 返回发送不同的信号给进程.<br><strong><span style="color:#ff0000;">注意</span></strong>:决定进程能够访问的有效地址空间大小的因素是文件中被映射的部分,而不是整个文件;另外,如果指定了文件的偏移部分,一定要注意为页面大小的整数倍;</span></p> 
   <p><span style="font-family:'宋体';"><strong><span style="color:#0000ff;">总之</span></strong>:采用内存映射机制mmap()来实现进程间通信是很方便的,在应用层上,调用接口非常简单,内部实现机制涉及到了Linux的存储管理以及文件系统等方面的内用;</span></p> 
  </div> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/jeanschen/p/3532743.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c5639fade2c509fafe6950ee434c5c11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java.lang.NoSuchFieldError异常</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e1af83944fb691f14a480b576f694622/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">博客迁移至 https://eaphy.github.io/</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>