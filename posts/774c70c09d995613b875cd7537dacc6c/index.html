<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>王道计算机考研 操作系统学习笔记 &#43; 完整思维导图篇章三: 内存管理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="王道计算机考研 操作系统学习笔记 &#43; 完整思维导图篇章三: 内存管理" />
<meta property="og:description" content="目录
内存管理概念
内存的基础知识
什么是内存？有何作用？
补充知识:几个常用的数量单位
指令的工作原理 三种装入方式
绝对装入 可重定位装入 动态重定位 从写程序到程序运行 链接的三种方式 总结
内存管理的概念
内存保护 内存空间的扩充 覆盖技术
交换技术
内存空间的分配与回收 连续分配管理方式
单一连续分配
固定分区分配 动态分区分配
总结
动态分区分配算法
首次适应算法 最佳适应算法 最坏适应算法
邻近适应算法 总结 非连续分配管理方式
基本分页存储管理的基本概念 基本地址变换机构 具有快表的地址变换机构
两级页表 基本分段存储管理
分段、分页管理的对比
段页式管理方式 虚拟内存管理
传统存储管理方式的特征、缺点
虚拟内存的定义和特征 如何实现虚拟内存技术
请求分页管理方式 请求页表 缺页中断
地址转换流程 页面置换算法
最佳置换算法 (OPT)
先进先出置换算法 (FIFO) 最近最久未使用置换算法(LRU)
时钟置换算法 (CLOCK)
改进型CLOCK算法 页面分配策略
驻留集
页面分配、置换策略 页面调动时机策略
页面调动位置策略 抖动（颠簸）现象 内存映射文件 传统文件访问方式
内存管理概念 内存的基础知识 什么是内存？有何作用？ 程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾
补充知识:几个常用的数量单位 指令的工作原理 三种装入方式 绝对装入 可重定位装入 动态重定位 从写程序到程序运行 链接的三种方式 静态链接：程序运行之前，将库函数连接成一个完整的可执行程序装入时动态链接：将用户源程序编译后得到目标模块，装入内存时，采用边装入边链接的方式运行时动态链接：对于某些目标模块的链接，程序需要时才会对其链接 ，便于修改和更新，便于实现对目标模块的共享 总结 内存管理的概念 内存保护 内存空间的扩充 覆盖技术 交换技术 注意: PCB 会常驻内存，不会被换出外存 应该在外存(磁盘)的什么位置保存被换出的进程?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/774c70c09d995613b875cd7537dacc6c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-20T17:30:01+08:00" />
<meta property="article:modified_time" content="2023-10-20T17:30:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">王道计算机考研 操作系统学习笔记 &#43; 完整思维导图篇章三: 内存管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="-toc" style="margin-left:0px;"></p> 
 <p id="内存管理概念-toc" style="margin-left:0px;"><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5" rel="nofollow">内存管理概念</a></p> 
 <p id="内存的基础知识-toc" style="margin-left:40px;"><a href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" rel="nofollow">内存的基础知识</a></p> 
 <p id="什么是内存？有何作用？-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%EF%BC%9F%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8%EF%BC%9F" rel="nofollow">什么是内存？有何作用？</a></p> 
 <p id="%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%3A%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E9%87%8F%E5%8D%95%E4%BD%8D-toc" style="margin-left:80px;"><a href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%3A%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E9%87%8F%E5%8D%95%E4%BD%8D" rel="nofollow">补充知识:几个常用的数量单位</a></p> 
 <p id="%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%C2%A0" rel="nofollow">指令的工作原理 </a></p> 
 <p id="%E4%B8%89%E7%A7%8D%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E7%A7%8D%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F" rel="nofollow">三种装入方式</a></p> 
 <p id="%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5%C2%A0-toc" style="margin-left:120px;"><a href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5%C2%A0" rel="nofollow">绝对装入 </a></p> 
 <p id="%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5%C2%A0-toc" style="margin-left:120px;"><a href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5%C2%A0" rel="nofollow">可重定位装入 </a></p> 
 <p id="%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%C2%A0-toc" style="margin-left:120px;"><a href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%C2%A0" rel="nofollow">动态重定位 </a></p> 
 <p id="%E4%BB%8E%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%8E%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%C2%A0" rel="nofollow">从写程序到程序运行 </a></p> 
 <p id="%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%C2%A0-toc" style="margin-left:80px;"><a href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%C2%A0" rel="nofollow">链接的三种方式 </a></p> 
 <p id="%E6%80%BB%E7%BB%93%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">总结</a></p> 
 <p id="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">内存管理的概念</a></p> 
 <p id="%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%C2%A0" rel="nofollow">内存保护 </a></p> 
 <p id="%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85%C2%A0" rel="nofollow">内存空间的扩充 </a></p> 
 <p id="%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF-toc" style="margin-left:120px;"><a href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF" rel="nofollow">覆盖技术</a></p> 
 <p id="%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF-toc" style="margin-left:120px;"><a href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF" rel="nofollow">交换技术</a></p> 
 <p id="%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%C2%A0" rel="nofollow">内存空间的分配与回收 </a></p> 
 <p id="%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:120px;"><a href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F" rel="nofollow">连续分配管理方式</a></p> 
 <p id="%C2%A0%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D-toc" style="margin-left:160px;"><a href="#%C2%A0%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D" rel="nofollow"> 单一连续分配</a></p> 
 <p id="%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%C2%A0-toc" style="margin-left:160px;"><a href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%C2%A0" rel="nofollow">固定分区分配 </a></p> 
 <p id="%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D-toc" style="margin-left:160px;"><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D" rel="nofollow">动态分区分配</a></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:160px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
 <p id="%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95-toc" style="margin-left:120px;"><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95" rel="nofollow">动态分区分配算法</a></p> 
 <p id="%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%C2%A0-toc" style="margin-left:160px;"><a href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%C2%A0" rel="nofollow">首次适应算法 </a></p> 
 <p id="%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%C2%A0-toc" style="margin-left:160px;"><a href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%C2%A0" rel="nofollow">最佳适应算法 </a></p> 
 <p id="%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-toc" style="margin-left:160px;"><a href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95" rel="nofollow">最坏适应算法</a></p> 
 <p id="%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%C2%A0-toc" style="margin-left:160px;"><a href="#%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%C2%A0" rel="nofollow">邻近适应算法 </a></p> 
 <p id="%E6%80%BB%E7%BB%93%C2%A0-toc" style="margin-left:160px;"><a href="#%E6%80%BB%E7%BB%93%C2%A0" rel="nofollow">总结 </a></p> 
 <p id="%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:120px;"><a href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F" rel="nofollow">非连续分配管理方式</a></p> 
 <p id="%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0-toc" style="margin-left:160px;"><a href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0" rel="nofollow">基本分页存储管理的基本概念 </a></p> 
 <p id="%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%C2%A0-toc" style="margin-left:160px;"><a href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%C2%A0" rel="nofollow">基本地址变换机构 </a></p> 
 <p id="具有快表的地址变换机构-toc" style="margin-left:160px;"><a href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84" rel="nofollow">具有快表的地址变换机构</a></p> 
 <p id="%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%C2%A0-toc" style="margin-left:160px;"><a href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%C2%A0" rel="nofollow">两级页表 </a></p> 
 <p id="%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-toc" style="margin-left:120px;"><a href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86" rel="nofollow">基本分段存储管理</a></p> 
 <p id="%E5%88%86%E6%AE%B5%E3%80%81%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:120px;"><a href="#%E5%88%86%E6%AE%B5%E3%80%81%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">分段、分页管理的对比</a></p> 
 <p id="%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%C2%A0-toc" style="margin-left:120px;"><a href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%C2%A0" rel="nofollow">段页式管理方式 </a></p> 
 <p id="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" rel="nofollow">虚拟内存管理</a></p> 
 <p id="%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E5%BE%81%E3%80%81%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E5%BE%81%E3%80%81%E7%BC%BA%E7%82%B9" rel="nofollow">传统存储管理方式的特征、缺点</a></p> 
 <p id="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81%C2%A0-toc" style="margin-left:80px;"><a href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81%C2%A0" rel="nofollow">虚拟内存的定义和特征 </a></p> 
 <p id="%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF-toc" style="margin-left:80px;"><a href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF" rel="nofollow">如何实现虚拟内存技术</a></p> 
 <p id="%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%C2%A0" rel="nofollow">请求分页管理方式 </a></p> 
 <p id="%E8%AF%B7%E6%B1%82%E9%A1%B5%E8%A1%A8%C2%A0-toc" style="margin-left:80px;"><a href="#%E8%AF%B7%E6%B1%82%E9%A1%B5%E8%A1%A8%C2%A0" rel="nofollow">请求页表 </a></p> 
 <p id="%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD-toc" style="margin-left:80px;"><a href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD" rel="nofollow">缺页中断</a></p> 
 <p id="%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B%C2%A0" rel="nofollow">地址转换流程 </a></p> 
 <p id="%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95" rel="nofollow">页面置换算法</a></p> 
 <p id="%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20(OPT)-toc" style="margin-left:120px;"><a href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20%28OPT%29" rel="nofollow">最佳置换算法 (OPT)</a></p> 
 <p id="%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20(FIFO)%C2%A0-toc" style="margin-left:120px;"><a href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20%28FIFO%29%C2%A0" rel="nofollow">先进先出置换算法 (FIFO) </a></p> 
 <p id="%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95(LRU)-toc" style="margin-left:120px;"><a href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%28LRU%29" rel="nofollow">最近最久未使用置换算法(LRU)</a></p> 
 <p id="%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20(CLOCK)-toc" style="margin-left:120px;"><a href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20%28CLOCK%29" rel="nofollow">时钟置换算法 (CLOCK)</a></p> 
 <p id="%E6%94%B9%E8%BF%9B%E5%9E%8BCLOCK%E7%AE%97%E6%B3%95%C2%A0-toc" style="margin-left:120px;"><a href="#%E6%94%B9%E8%BF%9B%E5%9E%8BCLOCK%E7%AE%97%E6%B3%95%C2%A0" rel="nofollow">改进型CLOCK算法 </a></p> 
 <p id="%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5" rel="nofollow">页面分配策略</a></p> 
 <p id="%E9%A9%BB%E7%95%99%E9%9B%86-toc" style="margin-left:120px;"><a href="#%E9%A9%BB%E7%95%99%E9%9B%86" rel="nofollow">驻留集</a></p> 
 <p id="%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E3%80%81%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5%C2%A0-toc" style="margin-left:120px;"><a href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E3%80%81%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5%C2%A0" rel="nofollow">页面分配、置换策略 </a></p> 
 <p id="%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%8A%A8%E6%97%B6%E6%9C%BA%E7%AD%96%E7%95%A5-toc" style="margin-left:120px;"><a href="#%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%8A%A8%E6%97%B6%E6%9C%BA%E7%AD%96%E7%95%A5" rel="nofollow">页面调动时机策略</a></p> 
 <p id="%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%8A%A8%E4%BD%8D%E7%BD%AE%E7%AD%96%E7%95%A5%C2%A0-toc" style="margin-left:120px;"><a href="#%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%8A%A8%E4%BD%8D%E7%BD%AE%E7%AD%96%E7%95%A5%C2%A0" rel="nofollow">页面调动位置策略 </a></p> 
 <p id="%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89%E7%8E%B0%E8%B1%A1%C2%A0-toc" style="margin-left:120px;"><a href="#%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89%E7%8E%B0%E8%B1%A1%C2%A0" rel="nofollow">抖动（颠簸）现象 </a></p> 
 <p id="%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%C2%A0" rel="nofollow">内存映射文件 </a></p> 
 <p id="%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F-toc" style="margin-left:120px;"><a href="#%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F" rel="nofollow">传统文件访问方式</a></p> 
 <hr id="hr-toc"> 
 <p></p> 
</blockquote> 
<h2><img alt="" height="1200" src="https://images2.imgbox.com/ea/e3/tDXasN54_o.png" width="1200"></h2> 
<p><img alt="" height="1119" src="https://images2.imgbox.com/ad/9a/nTurqK9I_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/14/78/5moyfS0G_o.png" width="1200"></p> 
<p><img alt="" height="1059" src="https://images2.imgbox.com/b6/eb/ruGoZYu3_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b2/d0/mm8JWkTe_o.png" width="1200"></p> 
<h2 id="内存管理概念">内存管理概念</h2> 
<h3 id="内存的基础知识">内存的基础知识</h3> 
<h4 id="什么是内存？有何作用？">什么是内存？有何作用？</h4> 
<p style="text-align:center;">程序执行前<strong>需要先放到内存中才能被CPU处理</strong>——缓和CPU与硬盘之间的<strong>速度矛盾</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/05/0a/Ps1bC1lQ_o.png" width="1200"></p> 
<h4 id="%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%3A%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E9%87%8F%E5%8D%95%E4%BD%8D">补充知识:几个常用的数量单位</h4> 
<p><img alt="" height="1001" src="https://images2.imgbox.com/55/8b/hKTGvBH0_o.png" width="1200"></p> 
<h4 id="%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%C2%A0">指令的工作原理 </h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/51/3b/emxtxM2M_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c2/89/U71ixOuQ_o.png" width="1200"></p> 
<h4 id="%E4%B8%89%E7%A7%8D%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F">三种装入方式</h4> 
<h5 id="%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5%C2%A0">绝对装入 </h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/83/50/1AAvX6Vv_o.png" width="1200"></p> 
<h5 id="%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5%C2%A0">可重定位装入 </h5> 
<h5 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="1200" src="https://images2.imgbox.com/00/48/wIT7HWv6_o.png" width="1200"></h5> 
<h5 id="%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%C2%A0">动态重定位 </h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/89/6f/p4cv0GzZ_o.png" width="1200"></p> 
<h4 id="%E4%BB%8E%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%C2%A0">从写程序到程序运行 </h4> 
<p><img alt="" height="1183" src="https://images2.imgbox.com/82/d1/AVjmDUIz_o.png" width="1200"></p> 
<h4 id="%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%C2%A0">链接的三种方式 </h4> 
<blockquote> 
 <ul><li><span style="color:#0d0016;"><strong>静态链接：</strong></span>程序运行之前，将库函数连接成一个完整的可执行程序</li><li><span style="color:#0d0016;"><strong>装入时动态链接：</strong></span>将用户源程序编译后得到目标模块，装入内存时，采用边装入边链接的方式</li><li><span style="color:#0d0016;"><strong>运行时动态链接：</strong></span>对于某些目标模块的链接，<strong>程序需要时才会对其链接</strong> ，便于修改和更新，便于实现对目标模块的共享</li></ul> 
</blockquote> 
<hr> 
<h4 id="%E6%80%BB%E7%BB%93%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91">总结 <img alt="" height="1197" src="https://images2.imgbox.com/76/e6/DH05oTSz_o.png" width="1200"></h4> 
<hr> 
<h3 id="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5" style="background-color:transparent;">内存管理的概念</h3> 
<p><img alt="" height="1077" src="https://images2.imgbox.com/43/a7/ViPVgnNi_o.png" width="1200"></p> 
<h4 id="%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%C2%A0">内存保护 </h4> 
<p><img alt="" height="1153" src="https://images2.imgbox.com/95/e5/aXEW3uM2_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e2/22/I03qRg4H_o.png" width="1200"></p> 
<hr> 
<h4 id="%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85%C2%A0">内存空间的扩充 </h4> 
<h5 id="%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF" style="background-color:transparent;">覆盖技术</h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/96/2a/Z9B6mqUd_o.png" width="1200"></p> 
<p><img alt="" height="1115" src="https://images2.imgbox.com/5e/54/dUt4AJqC_o.png" width="1200"></p> 
<hr> 
<h5 id="%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF" style="background-color:transparent;">交换技术</h5> 
<p><img alt="" height="833" src="https://images2.imgbox.com/19/30/LedgpBfx_o.png" width="1200"></p> 
<p><img alt="" height="1109" src="https://images2.imgbox.com/fa/cf/r6rii9pi_o.png" width="1200"></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>注意: PCB 会常驻内存，不会被换出外存 </strong></span></p> 
<ul><li><strong>应该在外存(磁盘)的什么位置保存被换出的进程?</strong> 
  <ul><li>具有对换功能的操作系统中，通常把磁盘空间分为<span style="color:#fe2c24;"><strong>文件区</strong></span>和<span style="color:#fe2c24;"><strong>对换区</strong></span>两部分。文件区主要用于存放文件，<span style="color:#fe2c24;"><strong>主要追求存储空间的利用率</strong></span>，因此对文件区空间的管理<strong><span style="color:#fe2c24;">采用离散分配方式: </span></strong>对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区<span style="color:#fe2c24;"><strong>采用连续分配方式</strong></span>(学过文件管理章节后即可理解)。总之，<strong><span style="color:#fe2c24;">对换区的I/O速度比文件区的更快。</span></strong></li></ul></li><li><strong>什么时候应该交换?</strong> 
  <ul><li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</li></ul></li><li><strong>应该换出哪些进程?</strong> 
  <ul><li>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间</li></ul></li></ul> 
<p><img alt="" height="1147" src="https://images2.imgbox.com/11/16/gmKeB5Lc_o.png" width="1200"></p> 
<hr> 
<h4 id="%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%C2%A0" style="background-color:transparent;">内存空间的分配与回收 </h4> 
<h5 id="%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">连续分配管理方式</h5> 
<p style="text-align:center;">        <span style="color:#0d0016;"><strong>连续分配:指为用户进程分配的必须是一个</strong></span><strong><span style="color:#fe2c24;">连续的内存空间</span></strong></p> 
<h6 id="%C2%A0%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"> 单一连续分配</h6> 
<p><img alt="" height="1101" src="https://images2.imgbox.com/36/98/w8lRqymP_o.png" width="1200"></p> 
<h6 id="%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%C2%A0">固定分区分配 </h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/4e/84/WKUUoZMy_o.png" width="1200"></p> 
<p><img alt="" height="1165" src="https://images2.imgbox.com/44/c3/X73yG5pL_o.png" width="1200"></p> 
<h6 id="%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D">动态分区分配</h6> 
<p><img alt="" height="219" src="https://images2.imgbox.com/db/97/ySTzMGqj_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/8d/3d/e4WhJdxu_o.png" width="1200"></p> 
<p><img alt="" height="975" src="https://images2.imgbox.com/d1/3c/smSVMrFL_o.png" width="1200"></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>动态分区分配没有内部碎片，但是有外部碎片。</strong></span></p> 
<ul><li><span style="color:#0d0016;"><strong>内部碎片</strong></span>，分配给某进程的内存区域中，如果有些部分没有用上。</li><li><span style="color:#0d0016;"><strong>外部碎片</strong></span>，是指内存中的某些空闲分区由于太小而难以利用。</li></ul> 
<p>如果内存中空闲空间的总和本来可以满足某进程的要求但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求可以通过<span style="color:#fe2c24;"><strong>紧凑(拼凑，Compaction) 技术</strong></span>来解决外部碎片。 </p> 
<hr> 
<h6 id="%E6%80%BB%E7%BB%93">总结</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e1/42/mcdxPCVu_o.png" width="1200"></p> 
<hr> 
<h5 id="%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95">动态分区分配算法</h5> 
<p style="text-align:center;"><strong>在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?</strong></p> 
<h6 id="%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%C2%A0" style="background-color:transparent;">首次适应算法 </h6> 
<p><span style="color:#0d0016;"><strong>算法思想:  </strong></span>每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p> 
<p><span style="color:#0d0016;"><strong>如何实现:  </strong></span>空闲分区以<span style="color:#fe2c24;"><strong>地址递增的次序排列</strong></span>。每次分配内存时顺序查找<strong>空闲分区链</strong>(或<strong>空闲分区表</strong>)，找到大小能满足要求的第一个空闲分区。</p> 
<p><img alt="" height="975" src="https://images2.imgbox.com/11/b3/dwD7AS46_o.png" width="1200"></p> 
<h6 id="%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%C2%A0">最佳适应算法 </h6> 
<p><span style="color:#0d0016;"><strong>算法思想:  </strong></span>由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区即，优先使用更小的空闲区。<br><span style="color:#0d0016;"><strong>如何实现:  </strong></span>空闲分区<span style="color:#fe2c24;"><strong>按容量递增次序</strong></span>链接。每次分配内存时顺序查找<strong>空闲分区链</strong>(或<strong>空闲分区表</strong>)，找到大小能满足要求的第一个空闲分区。</p> 
<p><img alt="" height="903" src="https://images2.imgbox.com/30/a5/etArxu70_o.png" width="1200"></p> 
<h6 id="%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95">最坏适应算法</h6> 
<p>又称 <strong>最大适应算法 (Largest Fit)</strong></p> 
<p><span style="color:#0d0016;"><strong>算法思想: </strong></span> 为了解决最佳适应算法的问题-一即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p> 
<p><span style="color:#0d0016;"><strong>如何实现: </strong></span>空闲分区<strong><span style="color:#fe2c24;">按容量递减次序</span></strong>链接。每次分配内存时顺序查找<strong>空闲分区链</strong>(或<strong>空闲分区表</strong>)，找到大小能满足要求的第一个空闲分区。</p> 
<p><img alt="" height="913" src="https://images2.imgbox.com/81/77/XJZRkvhp_o.png" width="1200"></p> 
<h6 id="%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%C2%A0">邻近适应算法 </h6> 
<p><span style="color:#0d0016;"><strong>算法思想:  </strong></span>首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果<span style="color:#fe2c24;"><strong>每次都从上次查找结束的位置开始检索</strong></span>，就能解决上述问题。</p> 
<p><span style="color:#0d0016;"><strong>如何实现:  </strong></span>空闲分区<span style="color:#fe2c24;"><strong>以地址递增的顺序</strong></span>排列 (可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p> 
<p><img alt="" height="941" src="https://images2.imgbox.com/d9/3c/dk3LyxkI_o.png" width="1200"></p> 
<h6 id="%E6%80%BB%E7%BB%93%C2%A0">总结 </h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/38/41/yZXTTF0Q_o.png" width="1200"></p> 
<hr> 
<h5 id="%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">非连续分配管理方式</h5> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>为用户进程分配的可以是一些分散的内存空间</strong></span></p> 
<h6 id="%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0">基本分页存储管理的基本概念 </h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/6d/64/wxNXtlJf_o.png" width="1200"></p> 
<blockquote> 
 <p id="页表">页表</p> 
 <p>        记录了<strong>页面</strong>和<strong>实际存放的内存块</strong>之间的<strong>映射关系</strong></p> 
 <p>        为了便于在内存中找到进程的每个页面对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般放在内存中</p> 
 <p>页表项：</p> 
 <p>        页号+物理内存中的块号（不要与地址结构搞混）页表项的物理内存块号+地址结构中的页内偏移=物理地址</p> 
</blockquote> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/14/7e/bofucGTx_o.png" width="1200"><img alt="" height="1200" src="https://images2.imgbox.com/d5/ce/aBIrmM9W_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/04/fe/QduZbRH4_o.png" width="1200"><img alt="" height="1103" src="https://images2.imgbox.com/a8/b3/QAQqhpwF_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/66/2f/zzYIhZ3g_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="134" src="https://images2.imgbox.com/23/d4/RsNAUE2I_o.png" width="371"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/43/4d/B6Aoy65A_o.png" width="1200"></p> 
<p><strong>总结</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/39/bb/LiB3r9w1_o.png" width="1200"></p> 
<h6></h6> 
<hr> 
<h6 id="%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%C2%A0">基本地址变换机构 </h6> 
<p style="text-align:center;"><strong>用于实现逻辑地址到物理地址转换的一组硬件机构</strong></p> 
<p><img alt="" height="487" src="https://images2.imgbox.com/6d/d6/6TLmVN3B_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/ac/7d/VWvkH61Y_o.png" width="1200"></p> 
<p><img alt="" height="803" src="https://images2.imgbox.com/86/7d/RuzUu5to_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d2/a6/Y12dFlRV_o.png" width="1200"></p> 
<p><strong>总结</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/1f/a1/h6SAHXry_o.png" width="1200"></p> 
<hr> 
<h6 id="具有快表的地址变换机构">具有快表的地址变换机构</h6> 
<p><img alt="" height="223" src="https://images2.imgbox.com/e3/b3/zKnyBbA0_o.png" width="1200"></p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/fd/48/yLT2FAxO_o.png" width="287"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/1d/58/HUqN2FMb_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/48/32/LHieOtDa_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/07/e3/JQIlFPZM_o.png" width="1200"></p> 
<p><strong>局部性原理</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/fd/f2/dYDss1Pb_o.png" width="1200"></p> 
<p><img alt="" height="1047" src="https://images2.imgbox.com/42/d4/h0gVAADr_o.png" width="1200"></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>TLB和普通Cache 的区别--TLB 中只有表项的副本，而普通Cache 中可能会有其他各种数据的副本 </strong></span></p> 
<hr> 
<h6 id="%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%C2%A0" style="background-color:transparent;">两级页表 </h6> 
<blockquote> 
 <ul><li>根据页号查询页表的方法: K 号页对应的页表项存放位置 = 页表始址 + K*4要在所有的页表项都连续存放的基础上才能用这种方法找到页表项</li><li>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存。</li></ul> 
</blockquote> 
<p>由上述分析可得到单级页表的问题如下： </p> 
<ul><li><span style="color:#0d0016;"><strong>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框.</strong></span></li><li><span style="color:#0d0016;"><strong>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</strong></span></li></ul> 
<p><img alt="" height="793" src="https://images2.imgbox.com/19/bb/9Yskp7bS_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e0/22/yftO62Uz_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/90/ac/ejPPbeOl_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d8/0d/cr1dOPAg_o.png" width="1200"><img alt="" height="321" src="https://images2.imgbox.com/3b/f5/yBV3Ts0u_o.png" width="1200"></p> 
<p><img alt="" height="292" src="https://images2.imgbox.com/00/88/TwsVqX5k_o.png" width="420"><img alt="" height="130" src="https://images2.imgbox.com/01/5c/lX1b9Xik_o.png" width="544"><img alt="" height="42" src="https://images2.imgbox.com/57/1f/peWroxph_o.png" width="743"></p> 
<p><img alt="" height="1193" src="https://images2.imgbox.com/b6/a9/1wnltIXP_o.png" width="1200"></p> 
<hr> 
<h5 id="%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86">基本分段存储管理</h5> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>与“分页”最大的区别就是--离散分配时所分配地址空间的基本单位不同</strong></span></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/da/ef/bhN5KcGd_o.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/23/b8/f8YygCIw_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e6/58/n8E2jAeN_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/eb/81/2nrNwfo4_o.png" width="1200"></p> 
<hr> 
<h5 id="%E5%88%86%E6%AE%B5%E3%80%81%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94" style="background-color:transparent;">分段、分页管理的对比</h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/72/1a/a434jMsl_o.png" width="1200"></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>分段比分页更容易实现信息的共享和保护 </strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>不能被修改的代码称为纯代码或可重入代码 (不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的(比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致)</strong></span></p> 
<p style="text-align:center;"><img alt="" height="1029" src="https://images2.imgbox.com/8c/70/lAsGhggr_o.png" width="1200"></p> 
<p style="text-align:center;"><img alt="" height="1200" src="https://images2.imgbox.com/68/52/TnJhYJSa_o.png" width="1200"></p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/eb/17/OGOADpsw_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/4d/a7/jYIIQosg_o.png" width="1200"></p> 
<hr> 
<h5 id="%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%C2%A0">段页式管理方式 </h5> 
<p class="img-center"><img alt="" height="441" src="https://images2.imgbox.com/3b/f8/Dyx78aea_o.png" width="718"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/97/03/RQ88ZY0H_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b5/f5/xXeJm14N_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d1/ee/L60rbQyy_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/3f/59/OIZ1Vc3p_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f9/27/y5GLEeWf_o.png" width="1200"></p> 
<hr> 
<h2 id="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">虚拟内存管理</h2> 
<h3 id="%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E5%BE%81%E3%80%81%E7%BC%BA%E7%82%B9">传统存储管理方式的特征、缺点</h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/26/91/8CEl53g1_o.png" width="1200"></p> 
<h4 id="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81%C2%A0" style="background-color:transparent;">虚拟内存的定义和特征 </h4> 
<p><img alt="" height="697" src="https://images2.imgbox.com/fe/64/zaDJnAcN_o.png" width="1200"></p> 
<ul><li><strong>多次性</strong>：作业在运行时，分多次调入内存运行</li><li><strong>对换性</strong>：作业不必一直驻留内存，允许作业在运行过程中进行换进换出</li><li><strong>虚拟性</strong>：从逻辑上扩充内存容量，使用户看到的内存容量远大于实际的内存容量</li></ul> 
<hr> 
<h4 id="%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF">如何实现虚拟内存技术</h4> 
<p>        虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此,虚拟内存的实现需要建立在<span style="color:#fe2c24;"><strong>离散分配</strong></span>的内存管理方式基础上。</p> 
<p><span style="color:#0d0016;"><strong>主要思想：</strong></span>在程序执行过程中，当<span style="color:#fe2c24;"><strong>所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong></span>，然后继续执行程序。若<span style="color:#fe2c24;"><strong>内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</strong></span>。</p> 
<blockquote> 
 <ul><li>操作系统要提供请求调页 (或请求调段) 功能</li><li>操作系统要提供页面置换 或段置换) 的功能</li></ul> 
</blockquote> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/46/d5/NfKmi0pc_o.png" width="1200"></p> 
<hr> 
<h3 id="%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%C2%A0">请求分页管理方式 </h3> 
<p><img alt="" height="489" src="https://images2.imgbox.com/92/04/ahGgEMAg_o.png" width="1200"></p> 
<h4 id="%E8%AF%B7%E6%B1%82%E9%A1%B5%E8%A1%A8%C2%A0">请求页表 </h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/8e/d6/eWTZRAOi_o.png" width="1200"></p> 
<h4 id="%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD">缺页中断</h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c8/ce/YqDZrjJS_o.png" width="1200"></p> 
<p><img alt="" height="1095" src="https://images2.imgbox.com/27/0f/fomIy8x7_o.png" width="1200"></p> 
<h4 id="%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B%C2%A0">地址转换流程 </h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/9b/ba/aKV3REHg_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f6/3b/ezZMX8UK_o.png" width="1200"></p> 
<hr> 
<h4 id="%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">页面置换算法</h4> 
<h5 id="%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20(OPT)">最佳置换算法 (OPT)</h5> 
<p>        最佳置换算法 (OPT，Optimal):  每次选择淘汰的页面将是<span style="color:#fe2c24;">以后永不使用，或者在最长时间内不再被访问</span>的页面，这样可以保证最低的缺页率。</p> 
<p><img alt="" height="1071" src="https://images2.imgbox.com/7a/a3/cJurA5rK_o.png" width="1200"></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。 </strong></span></p> 
<hr> 
<h5 id="%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20(FIFO)%C2%A0">先进先出置换算法 (FIFO) </h5> 
<p>        先进先出置换算法(FIFO): 每次选择淘汰的页面是<span style="color:#fe2c24;">最早进入内存的页面</span></p> 
<p><span style="color:#fe2c24;">        </span>实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可</p> 
<p>        队列的最大长度取决于系统为进程分配了多少个内存块。</p> 
<p><img alt="" height="967" src="https://images2.imgbox.com/a2/dd/1xVT5Dya_o.png" width="1200"></p> 
<p><img alt="" height="1037" src="https://images2.imgbox.com/dc/43/RmhhcnL5_o.png" width="1200"></p> 
<hr> 
<h5 id="%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95(LRU)">最近最久未使用置换算法(LRU)</h5> 
<p>最近最久未使用置换算法 (LRU，least recently used): 每次淘汰的页面是<span style="color:#fe2c24;">最近最久未使用的页面</span></p> 
<p>实现方法: 赋予每个页面对应的页表项中，用<span style="color:#fe2c24;">访问字段记录该页面自上次被访问以来所经历的时间t</span>.当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p> 
<p><img alt="" height="1087" src="https://images2.imgbox.com/82/39/ZS2rUWJM_o.png" width="1200"></p> 
<hr> 
<h5 id="%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%20(CLOCK)">时钟置换算法 (CLOCK)</h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/96/b9/rWIseoA7_o.png" width="1200"></p> 
<hr> 
<h5 id="%E6%94%B9%E8%BF%9B%E5%9E%8BCLOCK%E7%AE%97%E6%B3%95%C2%A0">改进型CLOCK算法 </h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7e/11/F4tplLB4_o.png" width="1200"></p> 
<p><img alt="" height="1157" src="https://images2.imgbox.com/ed/a9/e643rLvM_o.png" width="1200"></p> 
<hr> 
<h4 id="%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">页面分配策略</h4> 
<h5 id="%E9%A9%BB%E7%95%99%E9%9B%86">驻留集</h5> 
<p>        驻留集:  指请求分页存储管理中给进程分配的物理块的集合。<br> 在采用了虚拟存储技术的系统中，<span style="color:#fe2c24;">驻留集大小一般小于进程的总大小。</span></p> 
<blockquote> 
 <p>考虑一个极端情况，若某进程共有100个页面，则该进程的驻留大小为100时进程可以全部放入内存，运行期间不可能再发生决页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页</p> 
</blockquote> 
<hr> 
<h5 id="%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E3%80%81%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5%C2%A0">页面分配、置换策略 </h5> 
<ul><li><span style="color:#0d0016;"><strong>固定分配：</strong></span>操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变</li><li><span style="color:#0d0016;"><strong>可变分配：</strong></span>先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变 </li><li><strong>局部置换：</strong>发生缺页时只能选进程自己的物理块进行置换。</li><li><strong>全局置换：</strong>可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</li></ul> 
<p class="img-center"><img alt="" height="142" src="https://images2.imgbox.com/e2/84/B3dnsX4k_o.png" width="550"></p> 
<p><img alt="" height="1169" src="https://images2.imgbox.com/c1/5e/ok9tYhif_o.png" width="1200"></p> 
<hr> 
<h5 id="%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%8A%A8%E6%97%B6%E6%9C%BA%E7%AD%96%E7%95%A5">页面调动时机策略</h5> 
<ul><li><span style="color:#0d0016;"><strong>预调页策略：</strong></span>根据局部性原理，一次调入若工个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于<span style="color:#fe2c24;">进程的首次调入</span>由程序员指出应该先调入哪些部分。<span style="color:#fe2c24;">（运行前调入）</span></li><li><span style="color:#0d0016;"><strong>请求调页策略：</strong></span>进程<span style="color:#fe2c24;">在运行期间发现缺页时才将所缺页面调入内存</span>。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/0操作，因此I/0开销较大。<span style="color:#fe2c24;">（运行时调入）</span></li></ul> 
<hr> 
<h5 id="%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%8A%A8%E4%BD%8D%E7%BD%AE%E7%AD%96%E7%95%A5%C2%A0">页面调动位置策略 </h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/9e/09/rA4dq8cn_o.png" width="1200"></p> 
<hr> 
<h5 id="%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89%E7%8E%B0%E8%B1%A1%C2%A0">抖动（颠簸）现象 </h5> 
<p><img alt="" height="655" src="https://images2.imgbox.com/33/be/qpBIvnqJ_o.png" width="1200"></p> 
<p><img alt="" height="1153" src="https://images2.imgbox.com/db/f0/WW1KvHDA_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/09/b5/vx4kelm8_o.png" width="1200"></p> 
<hr> 
<h4 id="%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%C2%A0">内存映射文件 </h4> 
<p>内存映射文件一一<strong>操作系统向上层程序员提供的功能(系统调用)</strong></p> 
<ul><li>方便程序员访问文件数据</li><li>方便多个进程共享同一个文件</li></ul> 
<h5 id="%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F">传统文件访问方式</h5> 
<p class="img-center"><img alt="" height="398" src="https://images2.imgbox.com/35/b2/1FAS6Wal_o.png" width="779"></p> 
<p class="img-center"><img alt="" height="462" src="https://images2.imgbox.com/ca/97/bH0yH7pP_o.png" width="528"></p> 
<p><img alt="" height="1069" src="https://images2.imgbox.com/5d/05/usZ7wBAT_o.png" width="1200"> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f4203abe661b6242387ca7cf05e49c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">静电放电保护和片式压敏电阻器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3ff11a8e8c687113341d63f5941ac4b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决提交到App Store时的ITMS-90478和ITMS-90062错误</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>