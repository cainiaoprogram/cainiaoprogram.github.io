<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/509d77fefe6bfdaa5654d17b9cdc0c2f/" rel="bookmark">
			【Linux】Samba服务器超详细安装、配置（附带各种问题解决方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在嵌入式系统开发应用平台中，tftp、nfs和samba服务器是最常用的文件传输工具，tftp和nfs是在嵌入式Linux开发环境中经常使用的传输工具，samba则是Linux和Windows之间的文件传输工具。
samba是模仿Windows网上邻居的SMB的通讯协议，将Linux操作系统“假装成”Windows操作系统，通过网上邻居的方式来进行文件传输的。
虚拟机版本：VMware10
Linux操作系统版本：Red Hat Enterprise Linux 5
Samba服务器介绍 Samba是在Linux系统上实现SMB（Session MessageBlock）协议的一个免费软件，以实现文件共享和打印机服务共享。 Samba服务器组件 samba有两个主要的进程smbd和nmbd。smbd进程提供了文件和打印服务，而nmbd则提供了NetBIOS名称服务和浏览支持，帮助SMB客户定位服务器，处理所有基于UDP的协议。 Samba服务器相关的配置文件 /etc/samba/smb.conf 这是samba的主要配置文件，基本上仅有这个文件，而且这个配置文件本身的说明非常详细。主要的设置包括服务器全局设置，如工作组、NetBIOS名称和密码等级，以及共享目录的相关设置，如实际目录、共享资源名称和权限等两大部分。/etc/samba/lmhosts 早期的 NetBIOS name 需额外设定，因此需要这个 lmhosts 的 NetBIOS name 对应的 IP 檔。 事实上它有点像是 /etc/hosts 的功能！只不过这个 lmhosts 对应的主机名是 NetBIOS name 喔！不要跟 /etc/hosts 搞混了！目前 Samba 预设会去使用你的本机名称 (hostname) 作为你的 NetBIOS name，因此这个档案不设定也无所谓。/etc/sysconfig/samba 提供启动 smbd, nmbd 时，你还想要加入的相关服务参数。/etc/samba/smbusers 由于 Windows 与 Linux 在管理员与访客的账号名称不一致，例如： administrator (windows) 及 root(linux)， 为了对应这两者之间的账号关系，可使用这个档案来设定/var/lib/samba/private/{passdb.tdb,secrets.tdb} 管理 Samba 的用户账号/密码时，会用到的数据库档案；/usr/share/doc/samba-&lt;版本&gt; 这个目录包含了 SAMBA 的所有相关的技术手册喔！也就是说，当你安装好了 SAMBA 之后，你的系统里面就已经含有相当丰富而完整的 SAMBA 使用手册了！值得高兴吧！ ^_^，所以，赶紧自行参考喔！ 至于常用的脚本文件案方面，若分为服务器与客户端功能，则主要有底下这几个数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/509d77fefe6bfdaa5654d17b9cdc0c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/729bf38a52820e54c0ec11a8966ec25b/" rel="bookmark">
			git上clone别人的项目、提交代码以及更新最新代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.clone项目 例如这是我们正要寻找的开源项目。
首先要做的是fork代码到自己的库，点击右上角的fork按钮，之后这个项目就会在出现在自己的库中。如下图所示： 这时候这个项目就出现在自己的库中。
打开git bash。 执行如下命令：
git clone git@github.com:JasonLeeLJQ/RIA_Test.git 后面的SSH是这样的得到的：如图，直接复制蓝色方框里面的ssh即可。 这样就完成了项目代码的clone。 在本地文件夹下，你会看到项目的文件夹。
2、将修改后的项目提交给作者 接下来，就可以对代码进行修改了。 修改文件之后，需要将项目提交给作者。
第一步，将项目提交到自己的仓库 执行如下命令：
//添加全部 git add . //提交全部 git commit -m '更新日志' //提交到服务器 git push origin master 这样，就将修改后的代码上传到自己的仓库中了。还需要提交给作者。
第二步，将项目提交给作者 我们点击项目上的Pull request去请求 在这里写上我们的更新日志和更改了什么东西，然后点击Create pull request 到这里，就没有我们什么事了，我们只要等待作者收到邮件同意我们的更新就好了 那作者哪里做了什么呢？ 当他收到这个请求就会看到 只要点击同意，我们的提交就合并到他的代码里去了，就可以看到提交信息了 这个时候你的代码就静静的躺在作者的Github里了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5856f1db1a7c44eeafac618d1c187782/" rel="bookmark">
			springboot 热部署，修改代码不重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、导入包，插件
&lt;!-- 热部署模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 这个需要为 true 热部署才有效 --&gt; &lt;/dependency&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; 二、修改idea配置
1、“File” -&gt; “Settings” -&gt; “Build,Execution,Deplyment” -&gt; “Compiler”，选中打勾 “Build project automatically” 。
2、组合键：“Shift+Ctrl+Alt+/” ，选择 “Registry” ，选中打勾 “compiler.automake.allow.when.app.running” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77a24d93488e325d82be3e263bea1891/" rel="bookmark">
			Java解析XML(4种方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xml文件
&lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;class&gt; &lt;student&gt; &lt;firstname&gt;cxx1&lt;/firstname&gt; &lt;lastname&gt;Bob1&lt;/lastname&gt; &lt;nickname&gt;stars1&lt;/nickname&gt; &lt;marks&gt;85&lt;/marks&gt; &lt;/student&gt; &lt;student rollno="493"&gt; &lt;firstname&gt;cxx2&lt;/firstname&gt; &lt;lastname&gt;Bob2&lt;/lastname&gt; &lt;nickname&gt;stars2&lt;/nickname&gt; &lt;marks&gt;85&lt;/marks&gt; &lt;/student&gt; &lt;student rollno="593"&gt; &lt;firstname&gt;cxx3&lt;/firstname&gt; &lt;lastname&gt;Bob3&lt;/lastname&gt; &lt;nickname&gt;stars3&lt;/nickname&gt; &lt;marks&gt;85&lt;/marks&gt; &lt;/student&gt; &lt;/class&gt; 1.DOM方式 package com.cxx.xml; import org.w3c.dom.*; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; /** * @Author: cxx * Dom操作xml * @Date: 2018/5/29 20:19 */ public class DomDemo { //用Element方式 public static void element(NodeList list){ for (int i = 0; i &lt;list.getLength() ; i++) { Element element = (Element) list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77a24d93488e325d82be3e263bea1891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f054ac8e58276f0c10f8354a46b2790f/" rel="bookmark">
			alibaba  trace_201708 数据集简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址 1.简介 数据中心增长的大规模的在线服务以及批处理作业的联合分配被用来提升数据中心的效率。这种联合分配为现有的集群管理系统带来了很大的挑战，特别是一起工作的用来提升集群利用率和效率的服务和作业的调度。 跟随我们认为的学术团体和工业界比较感兴趣的研究热点，我们提取出以下挑战：
负载特性：我们如何能够以一种有代表性的方式为调度器研究模拟各种生产工作负载的方式来描述阿里巴巴工作负载？新的算法来分配工作负载到机器和CPU内核。我们如何分配和重新调整工作负载到不同的机器和CPU，以获得更好的资源利用率和可接受的资源竞争。在线服务和批作业调度器协作：如何调整在线服务和批处理作业之间的资源分配，以提高批处理作业的吞吐量，同时维持在线服务的可接受服务质量和快速故障恢复。 为了帮助研究人员解决上述问题，我们提供了生产集群24小时内的跟踪数据。这些数据包括运行在整个集群上的机器和负载，以及所有可以同时运行在线服务和批处理作业的机器。
2.通用技术和领域 出于机密原因，我们在跟踪中模糊了特定信息 1）时间和时间戳 跟踪中的每条记录包含一个时间戳，以秒为单位与跟踪开始时间相关。且，时间0表示世间发生在跟踪之前，在某些文件中，有一小部分条目（例如batch_instance.csv文件中小于0.1%的数目）是负时间戳，这些也表示发生在跟踪之前。 对利用率的衡量，包括实例和机器利用率，时间间隔是60s，平均时间超过300s。为了保密，我们仅披露联系12个小时的使用数据。 2）唯一识别 每台机器、在线和服务负载给定一个在整个耿总期间唯一的数字id。没有给出服务和任务名称。 3）资源利用 大多数资源利用衡量以及请求已经被归一化，包含：
memory sizedisk space cpu核数未被归一化 3.数据表 下面我们描述一下提供的表。牢记：不是所有的跟踪数据都包含这里提到的全部类型，列可能是以不同的排序，或者有不同的名字。这些定义的特殊性以及细节可以在schema.csv中找到。 1）machines 机器通过两张表描述：machine events table 以及 the machine resource utilization table a.Machine events(server_event.csv) - timestamp - machineID - event type - event detail - capacity:CPU - capacity:memory 这些追踪包含机器事件的三个类型： - add 一台机器对于集群来说变得可用。追踪数据中所有的机器都有一个add事件，在追踪之前机器时added，则时间戳为0 - softerror 机器由于软件失败例如低磁盘空间以及代理失败导致的短暂性不可用 - harderror 由于硬件故障，例如磁盘故障，机器变得不可用。在软件和硬件错误的情况下，新的在线服务和批处理作业不应该放置在机器中，但是现有的服务和作业仍然可以正常工作。可以从事件细节字段推断错误原因。
机器容量反映了每台机器每一维归一化的物理容量，每一维（CPU核数，RAM大小）是相互独立归一化的。
b.Machine utilization（server_usage.csv） - timestamp - machineID - util:CPU - util:memory - util:disk - load1: linux cpu load average of 1 minute - load5: linux cpu load average of 5 minute - load15: linux cpu load average of 15 minute 机器利用率是百分数，反映了所有工作负载的总资源使用率，包括操作系统的全部资源使用量。 batch workload 批处理作业用一下表描述： - instance table - task table 用户以job的形式提交批处理负载（不包含在追踪数据中）一个job包含多个task，不同的task执行不同的计算逻辑。根据数据依赖任务形成一个DAG。instance是批处理作业中最小的调度单元，任务中的所有实例用相同的资源请求执行完全相同的二进制，但使用不同的输入数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f054ac8e58276f0c10f8354a46b2790f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de9812c9c83068c71be5db6d834f575/" rel="bookmark">
			Shiro 中的 Realm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前写项目用了 Shiro 框架，来进行安全验证以及权限管理。当时项目赶得急，没怎么深入了解，只能说能跑能改，不过在使用的过程中发现 Shiro 确实很优秀。现在回过头来学习原理，读读源码，深入的学习下。·
本篇博文主要写的是关于使用 Shiro 起步时最重要的一块，找了一些资料，力求写得简单明了。
简介 Realm：域，Realm 充当了 Shiro 与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro 会从应用配置的 Realm 中查找用户及其权限信息。从这个意义上讲，Realm 实质上是一个安全相关的 DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给 Shiro 。当配置 Shiro时，你必须至少指定一个 Realm ，用于认证和（或）授权。配置多个 Realm 是可以的，但是至少需要一个。 Shiro 内置了可以连接大量安全数据源（又名目录）的 Realm，如 LDAP、关系数据库（JDBC）、类似 INI 的文本配置资源以及属性文件等。如果缺省的 Realm 不能满足需求，你还可以插入代表自定义数据源的自己的 Realm 实现。
功能 Realm能做的工作主要有以下几个方面：
身份验证（getAuthenticationInfo 方法）验证账户和密码，并返回相关信息
权限获取（getAuthorizationInfo 方法） 获取指定身份的权限，并返回相关信息
令牌支持（supports方法）判断该令牌（Token）是否被支持
令牌有很多种类型，例如：HostAuthenticationToken（主机验证令牌），UsernamePasswordToken（账户密码验证令牌）
这里主来说明一下关于前两点验证方面的逻辑，因为令牌一般用的都是 UsernamePasswordToken，哪怕用 HostAuthenticationToken，也没必要细讲，这个函数很少用到。
身份验证 我们看到第一个方法就是我们上面说的“验证账户和密码，并返回相关信息”的方法。从方法的名字上看，只有取得验证信息的意思，其实这里面还包括了进行验证的逻辑。 看Javadoc，这个方法的作用是：根据传进来的 Token，返回用户的验证信息。下面说明一下 Token 和 用户验证信息 。
Token：就是要拿来进行验证的信息，例如：如果是 UsernamePasswordToken 的话，这个 Token 的内容就是“用户提交的用户名和密码”。
来看下 UsernamePasswordToken 的属性。
public class UsernamePasswordToken implements HostAuthenticationToken, RememberMeAuthenticationToken { private String username; private char[] password; private boolean rememberMe; private String host; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4de9812c9c83068c71be5db6d834f575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f443de916b896a36de21ea89ad5019c/" rel="bookmark">
			理解path.join() 和 path.resolve()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		path.resolve('/foo/bar', './baz'); // 返回: '/foo/bar/baz' path.resolve('/foo/bar', '/tmp/file/'); // 返回: '/tmp/file' path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif'); // 如果当前工作目录为 /home/myself/node， // 则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif' 如果任何参数不是一个字符串，则抛出 TypeError 。 1. 对于以/开始的路径片段，path.join只是简单的将该路径片段进行拼接，而path.resolve将以/开始的路径片段作为根目录，在此之前的路径将会被丢弃，就像是在terminal中使用cd命令一样。
2、path.resolve总是返回一个以相对于当前的工作目录（working directory）的绝对路径。
更多例子
path.join('/foo', 'bar', 'baz/asdf', 'quux', '.'); // 返回 /foo/bar/baz/asdf/quux, "."和"/"没什么影响 path.join('/foo', './bar', 'baz/asdf', '.', 'quux'); // 返回 /foo/bar/baz/asdf/quux path.join('/foo', './bar', './baz/asdf', 'quux', '..'); // 返回 /foo/bar/baz/asdf path.join('/foo', 'bar', 'baz/asdf', '.', '.'); // 返回 /foo/bar/baz/asdf path.join('/foo', 'bar', 'baz/asdf', 'quux'); // 返回 /foo/bar/baz/asdf/quux path.join('/foo', 'bar', 'baz/asdf', '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f443de916b896a36de21ea89ad5019c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59cb431f6ee0df1f320b73975e671e68/" rel="bookmark">
			pandas设置第一列为索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		df = pd.read_csv（）
unnamed:0 A
0 0 ..
1 1 ..
2 2 ..
。。。
df = pd.read_csv（'...', index_col = 'unnamed:0 '）
df.to_csv('.....',index_label=False) index_label=False 这样索引不会被当成列
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ccf621f60cb1772d3d692db4185dd38/" rel="bookmark">
			Google play store 常见错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q1:一直显示显示“等待下载”
A1:由于之前在别的节点上下载过同一个程序但是没有完全下载，后来又切换别的节点导致的（不同物理地址的节点）
解决方法:
1.切换回之前下载所用的节点（希望渺茫）
2.清除应用管理中“下载”、“下载管理器”的全部数据（此时应保证Google play为关闭状态），如果是华为手机此时还没有解决的话需要连同自带“手机管家”的数据一并删除
Q2:不能进入主页，直接提示错误代码
A2:删除手机中的Google账号，重启手机，重新登陆账号
Q3:主页直接显示未连接到互联网
A3:你的智商不足以使用Google play，去看看别的应用市场吧
Q4:通过GAPPS工具安装的Google 全家桶，导致服务框架等重要软件不能升级
A4:TWRP重新刷最新版的GAPPS（不会？那你第一遍是怎么刷的？）
Q4: 不是以上四种问题
A4:删除账号、卸载Google play、重启手机、下载新版google play、重新安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe65bf20fdb4aff80805c3e749599026/" rel="bookmark">
			在虚拟世界里，欣赏的不过是别人的想象——《头号玩家》观后感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（好久没更新博客了，把一个月前看一部电影的感想发上来，电影是虚拟现实和科幻题材的，所以也算和程序员有点联系吧：-）
一开始的观影体验并不好。特意选的最后一排座位，没想到头顶一个换气口呼呼作响，座位上也是污渍。下午场，小小的观影厅没有坐满，就换到前排靠边的座位。大概是因为电影的科幻和游戏名声在外，观众里很多是孩子，还有没有监护人带着的孩子。电影开头部分的酷炫的虚拟现实场面让我边上的两个小孩兴奋不已，不停发表感想，后来才知道后排坐着的是他们的母亲，但也从来没有制止过。我就想着该把自己的观影体验预期调整为在热闹的戏园子里看戏。
科幻和游戏的情节持续了很长时间，我早已过了因为变形金刚之类的画面激动的年龄，看得有些昏昏欲睡。男女主人公的avatar形象实在算不上吸引人，特别是脸部的编织布素材和女主角的发型。我心里嘀咕着老套的虚拟现实体验、真实世界感受的bug还有沉溺在这种游戏中对人类身体和精神的可以想象得到的种种毒害。
女主角对IOI公司的控诉和反叛者角色的确立给我提了一点神，在浮华的画面之外终于出现了妄图支配世界的邪恶力量和与它一样经典的反叛者，这一次邪恶力量不是来自外太空，不是靠政府力量的独裁者，不是变异的人工智能，而是妄图掌控虚拟世界来谋利的资本家。
虚拟和真实两个交织的世界里正邪之间的冲突在加剧，现实中弱小的五人组只能在游戏里争分夺秒，领先对手。五个人的现实设定和虚拟角色还是好莱坞大片吸引全球市场的套路，白人主角，黑人第一配角，东亚的日本和中国分得了第二三配角，只不过中国人除了西方人不习惯的姓氏发音之外，连角色也是日本的忍者。电影还在不断向经典致敬，动画片希瑞中的霍达克、异形中的小怪物头、库布里克的闪灵、绿野仙踪中的大块头机器人、龟仙人的波动拳、还有大东禅思之后变身而成的高达，真让人有八仙过海大显神通、动画角色大聚会的感觉，人物引用的层出不穷的游戏估计也有很多是历史上出现过的。
导演对现实世界和传统人文价值的推重虽然在分量上让位于紧张的剧情与科幻和游戏双重染色的画面，但却是影片的灵魂和感人的源泉。男主人公说，这里的时间很慢，确实，在目不暇接的游戏里高涨的是荷尔蒙，细腻的感情、哲理的沉思都没有生存的空间。
游戏的世界如此精彩，似乎有无限的可能性，但是在虚拟世界里，欣赏的不过是别人的想象。设计者就是这个异度空间的上帝，所幸的是，这位上帝和真实世界里的上帝一样，是仁慈的。他给人类以考验，也给他们以机会。他因为在现实中不自在而创造了一个世界，但又希望这个世界中的子民能回头发现真实的美好，只有在那里，才能好好地吃上一顿，才能关心与被关心，才有爱。
影片开始后的一段时间内，陆续有几批观众入场，其中有一位母亲带着一个三四岁的小女孩，张望了一阵后让小女孩留在另两个小朋友边上，自己出去了，大概是让她当动画片看。片子演到毁灭之子被引爆后，大概是被冲击波的场面和隆隆的声音吓到了，小女孩哇哇地哭了起来。或许是因为自己有一个比她还小的女儿，怜爱之心油然而生，我起身走到小女孩身边，牵起她的手，告诉她带她去找妈妈，小女孩顺从地跟我走。我领她离开观影厅，她就往前走去，她的妈妈看见了，赶了过来，对我道谢。
回到座位上，很快男主人公破解了三道中规中距的隐语谜题的最后一道，游戏的设计者在给出类似西天取经最后一难的考验之后，动人地展现了自己孤独的童年和创造游戏的原因，他将彩蛋交给男主人公时，我的眼睛有些湿润了。
电影最能吸引的当然是那些热爱游戏和虚拟世界的青年，实际上男主人公的性格设定和遭遇就是为了取悦这个人群的，除了正义的宏大主题，片尾周二周四关闭游戏世界的措施不啻为对玩家的一则提醒和忠告。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68bcc64a3554d87191aaba2ca0e64810/" rel="bookmark">
			聊聊自动化测试框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是在自动化测试实践，还是日常交流中，经常听到一个词：框架。之前学习自动化测试的过程中，一直对“框架”这个词知其然不知其所以然。
最近看了很多自动化相关的资料，加上自己的一些实践，算是对“框架”有了一些理解，这篇博客，就聊聊自动化框架的一些事吧。
一、什么是框架
框架（framework）是一个框子——指其约束性，也是一个架子——指其支撑性。是一个基本概念上的结构，用于去解决或者处理复杂的问题。
在软件工程中，框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；
另一种定义认为，框架是可被应用开发者定制的应用骨架，前者是从应用方面而后者是从目的方面给出的定义。
—— 百度百科
上面的概念比较抽象，换另一个角度解释：
1. 框架本身一般不完整到可以解决特定问题；
2. 框架天生就是为扩展而设计的；
3. 框架里面可以为后续扩展的组件提供很多辅助性、支撑性的方便易用的工具，也就是说框架是配套了一些帮助解决某类问题的库（libraries）或工具（tools）。
约束性：针对解决特定问题的软件框架会首先定义问题的边界，进而将相关的软件组件约束在这个边界内，保持框架在解决问题方面上的内聚性。
支撑性：框架本身不解决什么问题，但给了解决问题的相关组件一个组合底子，这个底子的科学性和易用性直接影响在此之上进一步开发的科学性和方便性。
—— 知乎
上面的2个对框架的解释和定义，看起来也并没有很简单直白的说清楚什么是框架，下面是我的一些理解：
定义：为解决某些特定问题而约束边界，支撑整个问题解决方案，配套了一些解决问题的组件而构成的工具。
特定问题：什么问题？——自动化测试
约束边界：为什么约束？——明确测试范围和目的
解决方案：用什么方案解决问题？——编程语言+工具+其他
构成工具的组件：哪些组件？—— 用例、脚本、数据、日志、报告、通知
工具：特点是什么？—— 灵活性、可扩展性、高内聚低耦合
二、自动化测试
1、为什么要进行自动化测试？
① 黑盒测试回归效率低
② 手动测试的偶然性和不确定性
③ 回归的覆盖率不足
④ 交付的产品质量无法保证，全靠评估
⑤ 系统越复杂，问题越多
⑥ 上线时间长、构件失败率高导致的蝴蝶效应（迭代快，加班多）
2、自动化测试能解决什么问题？
① 提高出现问题后的响应速率
② 降低回归成本
③ 提高回归覆盖率
④ 提高回归效率
⑤ 提高回归的稳定性
3、自动化测试的不足有哪些？
① 无法减少成本投入，而是为了加快测试结果反馈，提升测试质量
② 自动化适用于回归和冒烟，而不是发现BUG
③ 录制回放功能是鸡肋，可视化并不是一个很好的做法
④ 不是所有所有系统所有功能都适合做自动化测试
三、自动化测试框架
构成框架的组件，最起码应该具备以下的功能：
Log：日志记录和管理功能，针对不同的情况，设置不同的日志级别，方便定位问题；
Report：测试报告生成和管理以及即时通知，测试结果快速响应；
Source：配置文件、静态资源的管理，遵循高内聚低耦合原则；
Common：公共函数、方法以及通用操作的管理，遵循高内聚低耦合原则；
TestCase：测试用例管理功能，一个功能点对应一个或者多个case，尽可能的提高覆盖率；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68bcc64a3554d87191aaba2ca0e64810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15dd5e97f54fe02d3c6e51ce42f5f3cd/" rel="bookmark">
			spring常见错误:Error creating bean with name ‘xxx‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error creating bean with name 'userController': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.taotao.sso.service.UserService com.taotao.sso.controller.UserController.userService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.taotao.sso.service.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:334) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1214) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:772) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15dd5e97f54fe02d3c6e51ce42f5f3cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6d6adccaee72765013f677a1f01b66/" rel="bookmark">
			XML的Pull解析详细实例（Android Studio下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，介绍一下本文背景。是在看第一行代码中的pull解析方式要下新软件，就懒得下，去网上找资料，但是发现很多博客都没有写完一个例子，没想到花了更多的时间。最后找到一篇完整的博客，自己加上一些批注，在这里记录一下
Pull步骤简单介绍
需要建立一个解析器对象XmlPullParser。再使用XmlPullParser.setInput()方法设置解析器的输入。之后再通过判断事件类型，循环调用next()方法获得解析的数据 工程文件截图
student.xml用于放要读的数据
Student是数组的泛型
ParserByPull是一个方法类，在里面实现读取
代码如下
student.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;students&gt; &lt;student id="20110806100"&gt; &lt;name&gt;小明&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/student&gt; &lt;student id="20110806101"&gt; &lt;name&gt;小李&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/student&gt; &lt;student id="20110806102"&gt; &lt;name&gt;小丽&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;女&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt;Student.class public class Student { private String id; private String name; private int age; private String sex;}(get()和set()方法也要，此处省略) ParserByPull.class
public class ParserByPULL { //采用XmlPullParser来解析文件 public static List&lt;Student&gt; getStudents(InputStream inputStream)throws Throwable{ List&lt;Student&gt; students=null; Student mStudent=null; //创建XmlPullParser XmlPullParser parser= Xml.newPullParser(); //解析文件输入流 parser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb6d6adccaee72765013f677a1f01b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2fc814347ec8cc365daa57d1b6a6f48/" rel="bookmark">
			卡在checking installable status
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm install卡在checking installable status 笔者在使用NPM过程中经常会用到npm install命令，发现有时候会卡在checking installable status不动，在网上搜寻了各种解决方法之后在这里做一个记录。
原因 修改过仓库源（淘宝源之类的）远程仓库连接旧的npm缓存与项目冲突 解决方案 打开资源管理器，地址栏输入 C:\Users\用户名\AppData\Roaming
这里需要根据自己用户名修改路径
回车进入npm目录 找到npm和npm-cache两个文件夹删除 重新打开终端尝试npm下载。问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64da1a8e0c19e050b5b7fa8cc8ea8bc/" rel="bookmark">
			python中执行shell命令的几个方法小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有个需求就是页面上执行shell命令，第一想到的就是os.system， 代码如下:
os.system('cat /proc/cpuinfo') 但是发现页面上打印的命令执行结果 0或者1，当然不满足需求了。
尝试第二种方案 os.popen() 代码如下:
output = os.popen('cat /proc/cpuinfo') print output.read() 通过 os.popen() 返回的是 file read 的对象，对其进行读取 read() 的操作可以看到执行的输出。但是无法读取程序执行的返回值）
适用于Python2 尝试第三种方案 commands.getstatusoutput() 一个方法就可以获得到返回值和输出，非常好用。 代码如下:
(status, output) = commands.getstatusoutput('cat /proc/cpuinfo') print status, output Python Document 中给的一个例子
&gt;&gt;&gt; import commands &gt;&gt;&gt; commands.getstatusoutput('ls /bin/ls') (0, '/bin/ls') &gt;&gt;&gt; commands.getstatusoutput('cat /bin/junk') (256, 'cat: /bin/junk: No such file or directory') &gt;&gt;&gt; commands.getstatusoutput('/bin/junk') (256, 'sh: /bin/junk: not found') &gt;&gt;&gt; commands.getoutput('ls /bin/ls') '/bin/ls' &gt;&gt;&gt; commands.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a64da1a8e0c19e050b5b7fa8cc8ea8bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9f18b8197b1a87bd5d224a54ac9625/" rel="bookmark">
			Oracle入门（五A）之conn命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、connect命令
将给定的用户名连接到Oracle数据库。当你运行一个连接命令、站点配置文件、Galgn.SQL和用户配置文件，按顺序处理Login .SQL。连接不重发如果初始连接不成功，请使用用户名或密码。
语法： conn[ect] [{登录串|/|代理串} [AS {SYSOPER|SYSDBA|SYSASM}] [edition=value]]
a.登录串：用户名[/密码][@连接字符串]
b.代理串：代理用户[用户名][/密码][@连接字符串] 注意：代理中用户名的括号是必需的语法。
c.连接字符串： ip地址[:端口号（默认端口1521）]/数据库名
d.conn是connect的缩写
如，代理用户
conn myOrcale[sys]/abc@192.168.23.1:1521/orcl as sysdba 如，普通用户
SQL&gt;conn user/abc 如，超级管理员
SQL&gt;conn sys/abcd as sysdba 或者
SQL&gt; connect / as sysdba 如，超级管理员远程登录
SQL&gt;conn sys/abcd@192.168.1.2:1521/orcl as sysdba 二、英文版
SQL&gt; help conn CONNECT ------- Connects a given username to the Oracle Database. When you run a CONNECT command, the site profile, glogin.sql, and the user profile, login.sql, are processed in that order.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d9f18b8197b1a87bd5d224a54ac9625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee36dbdd07ddf2509255b45fa2bff96/" rel="bookmark">
			超详细Gitlab Runner环境配置中文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置GitlabRunner环境 GitLab Runner 是一个开源项目， 它用来运行你定制的任务（jobs）并把结果返回给 GitLab。 GitLab Runner 配合GitLab CI（GitLab 内置的持续集成服务） 协调完成任务。 本文将记录将一台闲置的iMac mini配置一个Specific Runner环境。 其他平台可以同时参考这个教程
本教程写的过于详细所以篇较长，需要一些耐心才可以完成配置
1.下载二进制文件到电脑上 下载这个需要梯子 sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64 2.添加执行权限 sudo chmod +x /usr/local/bin/gitlab-runner 3.注册Runner 以下步骤需要切换到需要运行该Runner的账户后运行
1.终端输入
sudo gitlab-runner register 回车显示 2.填入gitlab的URL 3.填入token（不清楚如何获取token的可以参考我的另一篇博客《获取Gitlab项目的Token》）
4.添加runner描述
这个描述可以以后gitlab网页里修改
5.添加描述标签，若添加多个需用逗号隔开
同样可以以后修改
6.询问是否在未加标签的Build上运行 我这里选择的“true”，默认为“false”。 7.询问是否锁定最近项目 默认为“是”，直接回车 8.提醒注册完成，选择runner要运行的平台和方式
请根据你需求选择
例如
ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:docker 回车
如果选择了docker，还会提醒输入默认的Docker Image，请确认电脑已经安装了docker
注册部分完成。
4.运行Runner 接下来就是将runner注册为服务并且开启 在终端输入
cd ~ gitlab-runner install gitlab-runner start 重启电脑即可正常运行 至此。整个配置过程完成!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ee36dbdd07ddf2509255b45fa2bff96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd9e8c6d0ec28451b9c98d3032497b4/" rel="bookmark">
			记录一下 接入大华ipc摄像机rtsp流的经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当时接入rtsp服务器时，我测过一些别的厂家的ipc，没有理会rtcp消息。
当对于大华的ipc 不理会rtcp不行啊，你必须建立rtcp的通讯 随便给它发点什么东西都可以，然后流就接通上来了。
不知道我这是不是个例，仅作为我这次经历的记录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d3caabe45f52316a0407262d47ad1f8/" rel="bookmark">
			oracle版本、JDBC版本与JDK版本的对应（oracle官网2018.05）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 来源：oracle JDBC常见问题解答 最近在写Java聊天室的时候，遇到了oracle jdbc jar包的版本选择问题，在官网上找到了版本对应，在这里贴下来，方便大家看。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/064d5b069a5ec2c6dcff0ce2d2151ec4/" rel="bookmark">
			为什么接入大华的IPC的RTSP服务器 就是不行呢，这是啥坑？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rtsp通信消息都走完了，下一步rtp流就没有了，什么坑吗？但是接入海康 三星等ipc都没问题，咨询客服就是vlc可以就是我自己的问题，我也知道是我自己问题，这不是不知道是什么问题才咨询你的吗？你这回答扯淡的吧，
OPTIONS rtsp://192.168.1.51:554/cam/realmonitor?channel=1&amp;subtype=0 RTSP/1.0
CSeq: 1
User-Agent: avcit_rtspclient/1.0
RTSP/1.0 401 Unauthorized
CSeq: 1
WWW-Authenticate: Digest realm="Login to 4C056DEPAA0A088", nonce="5971f9c8f93f05f05a8f9fbc6599ddcd"
OPTIONS rtsp://192.168.1.51:554/cam/realmonitor?channel=1&amp;subtype=0 RTSP/1.0
CSeq: 2
Authorization: Digest username="admin", realm="Login to 4C056DEPAA0A088", nonce="5971f9c8f93f05f05a8f9fbc6599ddcd", uri="rtsp://192.168.1.51:554/cam/realmonitor?channel=1&amp;subtype=0", response="ed2eaecc3e3bc699452429cd00fd221f"
User-Agent: avcit_rtspclient/1.0
DESCRIBE rtsp://192.168.1.51:554/cam/realmonitor?channel=1&amp;subtype=0 RTSP/1.0
CSeq: 3
Accept: application/sdp
Authorization: Digest username="admin", realm="Login to 4C056DEPAA0A088", nonce="5971f9c8f93f05f05a8f9fbc6599ddcd", uri="rtsp://192.168.1.51:554/cam/realmonitor?channel=1&amp;subtype=0", response="688eae2e0d63fd765a68bc199d69d6e8"
User-Agent: avcit_rtspclient/1.0
RTSP/1.0 200 OK
CSeq: 2
Server: Rtsp Server/3.0
Public: OPTIONS, DESCRIBE, ANNOUNCE, SETUP, PLAY, RECORD, PAUSE, TEARDOWN, SET_PARAMETER, GET_PARAMETER
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/064d5b069a5ec2c6dcff0ce2d2151ec4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d96409ce1f0609f19454de0ac0703b/" rel="bookmark">
			Java远程连接Linux服务器并执行命令及上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近再开发中遇到需要将文件上传到Linux服务器上，至此整理代码笔记。
此种连接方法中有考虑到并发问题，在进行创建FTP连接的时候将每一个连接对象存放至
ThreadLocal&lt;Ftp&gt; 中以确保每个线程之间对FTP的打开与关闭互不影响。 package com.test.utils; import java.io.BufferedInputStream; import java.io.File; import java.io.FileFilter; import java.io.FileInputStream; import java.io.InputStream; import java.util.ArrayList; import java.util.Date; import java.util.List; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import com.jcraft.jsch.ChannelSftp; import com.jcraft.jsch.JSch; import com.jcraft.jsch.Session; public class Ftp { //打印log日志 private static final Log logger = LogFactory.getLog(Ftp.class); private static Date last_push_date = null; private Session sshSession; private ChannelSftp channel; private static ThreadLocal&lt;Ftp&gt; sftpLocal = new ThreadLocal&lt;Ftp&gt;(); private Ftp(String host, int port, String username, String password) throws Exception { JSch jsch = new JSch(); jsch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3d96409ce1f0609f19454de0ac0703b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99518545f5277dab36fbb8c9960aa738/" rel="bookmark">
			easyui中获取getEditor为空情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么80%的码农都做不了架构师？&gt;&gt;&gt; 在使用getEditor方法获取到的ed对象为空：
var ed = $('#tt').treegrid("getEditor", { id: row.id, field: field }); 主要原因就是，在使用getEditor方法之前需要调用beginEdit方法,具体如下：
$('#tt').treegrid('beginEdit', row.id); var ed = $('#tt').treegrid("getEditor", { id: row.id, field: field }); 这样才能正常使用getEditor方法，注意编辑完成后，记得使用endEdit方法或cancelEdit方法结束编辑，即:
$('#tt').treegrid('endEdit', row.id); or
$('#tt').treegrid('cancelEdit', row.id); 参考: easyui官方文档
转载于:https://my.oschina.net/fxtxz2/blog/1817882
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3806976fec324f9c09153ac46cfe7bad/" rel="bookmark">
			添加字符串到集合中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f8d24d4df34f5e9623f3640226db1b/" rel="bookmark">
			MATLAB 相机标定（双目）使用工具箱TOOLBOX_calib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇写到单目的标定：MATLAB 相机标定（单目）使用工具箱TOOLBOX_calib - CSDN博客 https://blog.csdn.net/panpan_jiang1/article/details/80414737，
这一篇在上次的基础上，写双目（先单目标定完，再标定双目）标定。
介绍如何使用工具箱进行立体视觉系统标定，包括内外参数，以及用获得的数据进行立体校正和三维测量。
1、上一步中保存双目的图片，包括15对左右摄像头获取的图像，还有两个独立标定的结果。
2、在窗口处输入“stereo_gui"，出现如图窗口
3、点击第一个按钮 Load left and right calibration files .窗口提示输入左右标定文件名，分别输入对应文件名 Calib_Results_left.mat Calib_Results_right.mat 4、运行全局双目优化算法通过点击按钮Run stereo calibration 有以下所示结果
可以发现内外参数都被重新计算，所有未确定的参数也确定保证误差最小的基础上。你会发现不确定的内参数都变小了，这是因为最优化算法的作用。默认情况下，优化算法会重新计算左右相机的内部参数，但是如果你不想让其优化，则在窗口运行recompute_instrinsic_left和或者recompute_instrinsic_right
5、双目相机的空间位置和标定平面可以可视化，通过点击按键 Show Extrinsics of the rig.
6、点击 Savestereo calib results ,存储标定数据结果
7、校正图像
点击 Rectify the calibrationimages ，所有15对图片校正后图像存储在文件下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce2aae35e496b35b6c64f1e424bf586d/" rel="bookmark">
			python opencv加水印 去水印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收到的需求是在一个图上匹配到水印 然后将原来的水印换成一个新水印
先要安装一个库 库文件代码如下：
# coding=utf-8 import cv2 import numpy as np # 膨胀算法 Kernel _DILATE_KERNEL = np.array([[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], dtype=np.uint8) class WatermarkRemover(object): """" 去除图片中的水印(Remove Watermark) """ def __init__(self, verbose=True): self.verbose = verbose self.watermark_template_gray_img = None self.watermark_template_mask_img = None self.watermark_template_h = 0 self.watermark_template_w = 0 self.watermark_start_x = 0 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce2aae35e496b35b6c64f1e424bf586d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7180bf75619ca128d0b5b42865b348f8/" rel="bookmark">
			MATLAB 相机标定（单目）使用工具箱TOOLBOX_calib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境MATLAB R2014a+windows7 64位
1.单目摄像机标定
（1）首先把解压的TOOLBOX_calib文件夹的路径设置到MATLAB里,在主页-&gt;环境-&gt;设置路径-&gt;选择工具箱路径，如图：
然后保存，关闭
（2）此时，将你采集到的图片放到工具箱以外的文件夹中，在MATLAB中打开，如图：
注意上面的路径，必须选择图像所在的文件夹，不然下一步会出现错误“No image in this directory in either ras, bmp, tif, pgm, ppm or jpg format. Change directory and try again.”跟这有关。
（3）回到MATLAB界面，输入命令，calib_gui 选择standard，出现如下窗口，如图所示：
（4）点击Image name，出现
此时提示你输入Basename，Basename就是你的所有图片的名字中相同的部分，例如我的图片Basename就是image2_
然后按照要求输入图片格式，例如我的图片是JPG格式就输入“j”
回车，图片就读入到了MATLAB里，出现所有图片的缩略图，如图
（5）点击Extract grid corners，提取每幅图的角点，点击完成后出现如下界面 直接回车（没有参数）选择所有的图像，否则就需要输入图像索引如[2 5 8 10 12]来提取这些图像中的角点。然后通过直接输入“Enter”来选择默认的角点寻找窗口尺寸：wintx=winty=5。这就产生了一个11X11个像素有效的窗口尺寸，角点提取引擎有一个对网格中的方格个数进行计数的自动机制。这个工具尤其对于图像数量大的时候非常便利，因为用户不需要手工地输入X和Y方向方格的数量。所以也可以直接回车（没有参数），然后第一张标定图像就会显示出来，如图
（6）点击长方形棋盘格的四个边角点。选择的位置在下图中显示出来（注意：尽量精确地点击这四个角点，控制在实际角点的5个像素范围内，否则一些角点可能会被检测器丢失掉）。
点击的顺序规则：第一个点被用来作为棋盘格坐标系的原点。其他三个点可以以任何顺序点击。第一个点击的的点非常重要，尤其是对于多相机的情况（例如当计算几个相机在空间之间的相互关系的时候）。当处理多相机系统时对于不同的相机标定图像需要总是选择同一个棋盘格坐标系。
（7）经过上面的步骤之后，标定棋盘的边界就显示出来了：输入网格中每个方格在X和Y方向上的尺寸dX和dY（在这里，dX=dY=30mm=defaultvalues）（要根据自己的棋盘做调整），例如我的棋盘设置为28mm的正方形。程序会自动对各个方向的方格数进行计数，然后在显示出没有畸变的预估角点。如图
角点以大约0.1个像素的精度被提取出来。对第2、3、4...图像采用上述同样的步骤。
（8）在角点提取完之后，就可以单击标定工具箱面板上的“Calibration”来运行主要的相机标定程序。标定主要通过两个步骤来完成：初次初始化以及非线性优化。
初始化步骤中对标定参数进行闭环计算，这个过程不包括任何镜头畸变（程序名：init_calib_param.m）
非线性优化过程中将对所有的标定参数最小化总体映射误差（从最小二乘的角度出发）（9个内参以及6X20=129个外参）。优化是对特定雅可比矩阵进行计算然后往梯度下降的方向进行的。下图为非线性优化的结果：
从上图中我们可以注意到：为了达到最小值，只用了15次梯度迭代。这就意味着只有15次对映射函数、雅可比计算
以及求逆的评估。快速收敛的一个原因就是初始化程序所要计算的参数的有一个好的初始预估值。
现在，忽略推荐的可以减少畸变的模型的系统。对一个模型的复杂性进行判断的映射误差仍然很大。这主要是因为
对于一些图像一些网格角点并没有被精确地提取。
（9）单击面板上的“Reproject on images”来将网格角点映射到原始图像中。这些映射是基于当前的内参和外参计算
出来的。输入一个空字符（直接按"Enter"）作为“Number(s) of image(s) to show([]=all images)”来
表示你想查看所有图像，下面的图像显示了最初的四张检测到的角点的图像（叉）以及映射的网格角点（圆）。
映射误差也以有颜色的叉叉显示在图中：
（10）在面板中单击“ShowExtrinsic”。外参（棋盘格相对于相机的相对位置）就以3D的形式显示出来了：
、
（11）工具“Analyseerror”允许你去检查哪个点对应大的误差。单击“Analyse error”并且选择图像由上角的那个点。
退出误差分析工具，在图像上的任何位置右击。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7180bf75619ca128d0b5b42865b348f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/938237d46beb2f2ee9e442845df07902/" rel="bookmark">
			bochs 详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BOCHS 简介及配置 Bochs 简介 Bochs（读音同 Box）是用C++开发的以 LGPL 许可证发放的开放源代码的x86，x86-64模拟器，模拟整个PC。它被设计成可以运行于多种主流平台下，包括x86, PPC, Alpha, Sun和MIPS。
和 Bochs 类似的虚拟机软件还有：VMware，Virtual PC，VirtualBox，但这些都使用了虚拟化技术，部分指令直接交给硬件执行。而Bochs完全是靠软件模拟来实现的（所以Bochs虚拟机的速度慢很多，而且应该称Bochs为模拟器，而非虚拟机）。从启动到重启，包括PC的外设键盘，鼠标，VGA卡，磁盘，网卡等，全部都是由软件来模拟的。也正是由于Bochs完全是靠软件来模拟整个PC环境，因此它非常的适合开发操作系统，这对广大操作系统爱好者来说是一个福音。因为有它，使得调试操作系统非常非常的容易，它自带一个调试器bochsdbg，它可以从PC机刚启动的那一刹那起就开始模拟，注意，这不是从读取磁盘中的引导扇区那开始模拟。
在Bochs中安装操作系统，不会分区宿主机硬盘，而仅仅是在宿主机中建立一个大文件——磁盘镜像文件。
使用Bochs自带的bximage工具可以创建软盘，硬盘的镜像文件。
在Bochs中运行操作系统的最低要求：
Bochs 软件BIOS 镜像VGA BIOS 镜像 至少一个可引导的磁盘镜像（软盘，硬盘，光盘）或物理磁盘（软盘，光盘） 配置Bochs —— 告诉Bochs你想模拟一台拥有何种硬件配置的PC。 这里只介绍如何使用配置文件配置 Bochs。
Bochs为我们提供了一个配置文件的模版，这个模版为bochsrc-sample.txt，可以在Bochs的安装目录中找到。在配置文件中”#”为注释符号，表明#后面的全部是注释的内容（类似于C / C++ 中的行注释“//”）。
——其实只要懂点硬件，看看这个模板文件就懂如何配置了，要学习，官网的资料最好。
Romimage # ROMIMAGE: # The ROM BIOS controls what the PC does when it first powers on. # Normally, you can use a precompiled BIOS in the source or binary # distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded # starting at address 0xf0000, and it is exactly 64k long.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/938237d46beb2f2ee9e442845df07902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7cac0b23450a0f9ecea9efe72b3f542/" rel="bookmark">
			数字图像的退化模型及原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像复原的一般那过程：分析退化原因——建立退化模型——反映推演——恢复图像。
退化模型：
恢复模型：
现实中，造成图像退化的种类很多，常见的图像退化模型即点扩散函数（PSF）有如下情形：
1、线性移动退化
线性运动退化是由于目标与成像系统间的相对匀速直线运动造成的退化。水平方向的均匀移动退化可以用一下的退化函数来描述：
其中，d是退化函数的长度。实际情况中，如果线性运动的方向不是水平方向运动，可以类似求解。
2、高斯退化
高斯退化函数是许多光学测量系统和成像系统最常见的退化函数模型。对于这些系统，点扩散函数的影响因素比较多。众多因素的综合使点扩散函数趋向于高斯型退化函数分布。高斯退化函数的数学表达式：
其中，K为归一化常数，a为一个正常数，C为h(m,n)的圆形支持域。由高斯函数可知，高斯退化函数二维表达式可以分解为两个一维高斯退化函数的乘积。
3、散焦退化
在摄影中，镜头散焦时，光学系统造成图像退化相应的点扩散函数是一个均匀分布的圆形光斑。此时，散焦退化的函数表达式为
其中，R是散焦半径。在信噪比比较高的情况下，在频域上可以观察到圆形的轨迹。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/313dc4074d4ebbbb700c303febccfee4/" rel="bookmark">
			后台导入excel数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; 还是使用poi-ooxml，可以解析xls和xlsx两种文件。
前台使用&lt;input type="file"/&gt;，form表单提交，
或者使用formData用ajax提交（注意$.ajax加上 processData: false,contentType: false两个属性），
注意form 的属性enctype="multipart/form-data"
然后后台用MultipartFile 的类来接受，基本上上传文件的都是用这个类，至于原因我也不是很清楚
拿到文件后接着生成workbook
public static Workbook readExcel(MultipartFile file) throws IOException { Workbook wb = null; String filePath = file.getOriginalFilename(); if(filePath.lastIndexOf(".") &lt; 0) return wb = null; String extString = filePath.substring(filePath.lastIndexOf(".")); InputStream is = file.getInputStream(); if(".xls".equals(extString)){ return wb = new HSSFWorkbook(is); }else if(".xlsx".equals(extString)){ return wb = new XSSFWorkbook(is); }else{ return wb = null; } } 通过判断后缀名生成不同的Workbook
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/313dc4074d4ebbbb700c303febccfee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3648b8094e9ee4fae3f3a1cc1946c3a0/" rel="bookmark">
			OpenCV Camera Calibration 示例使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍OpenCV自带标定例子的使用方法。
OpenCV包含标定文件：calibration.cpp：是通过用户输入可选参数进行相机标定的程序；
（1）新建项目 test_Calibration
File-&gt;New -&gt; Project,点击ok，next，选择Empty project，点击finish。
（2）添加源文件 将OpenCV安装目录下的OpenCV\opencv\sources\samples\cpp文件夹中的calibration.cpp文件复制到港创建的工程目录下....\Test_Calibration\test_Calibration\test_Calibration文件夹下。作者为了区分两者，所以将其重命名为TestCalibration.cpp
在VS中右击工程名，右键点击工程中的Source Files-&gt;Add -&gt;Existing Item ,选择刚复制的TestCalibration.cpp文件。
（3）运行
点击Debug-&gt;Start Without Debugging，运行。生成test_Calibration.exe，在。。。Test_Calibration\test_Calibration\x64\Debug文件夹下。
（4）标定
打开所有程序中的“运行”，或直接按键Win+R，打开“运行”，输入“cmd”回车，打开命令行窗口
输入文件地址，如作者的地址输入 “E：”回车-&gt;cd paper_and_code\code20180507\C++\Test_Calibration\test_Calibration\x64\Debug 进入文件夹。
输入命令：“test_Calibration.exe -w=8 -h=6”回车
程序开始运行。
并生成out_camera_data.yml文件
利用事先拍好的图片标定的方法在下一篇会讲到
OpenCV Camera Calibration 示例使用（二） - CSDN博客
https://blog.csdn.net/panpan_jiang1/article/details/80429937
TestCalibration.cpp的代码如下
#include "opencv2/core.hpp"
#include &lt;opencv2/core/utility.hpp&gt;
#include "opencv2/imgproc.hpp"
#include "opencv2/calib3d.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/videoio.hpp"
#include "opencv2/highgui.hpp"
#include &lt;cctype&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
using namespace cv;
using namespace std;
const char * usage =
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3648b8094e9ee4fae3f3a1cc1946c3a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2aeafa6428c9028f6fac7c26544d3f1/" rel="bookmark">
			微信支付回调不了怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信支付回调不了一般有以下两个原因：
1、没有配置“支付授权目录”或“支付授权目录”配置不对。
（1）配置的地方：微信支付商户—产品中心—开发配置—支付授权目录。
（2）配置的格式要注意。
2、回调的路径出错。
我们可以直接访问对应的网址，看有没有代码或语法上的错误，有时一不小心出了点错误，也回调不了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1423a40f810abb9da5c2f12e7d517273/" rel="bookmark">
			华为路由器默认用户名密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AR路由器的缺省账号密码如下：
V200R003C00版本：
AR150&amp;200系列路由器的Telnet缺省用户名为admin，缺省密码为admin，缺省级别为15级。Web网管缺省用户名为admin，缺省密码为admin，缺省级别为15级。其他系列路由器支持情况和AR150&amp;200相同。
AR所有系列的BootROM菜单缺省密码为huawei。V200R003C01版本：
AR150&amp;200系列路由器的Telnet缺省用户名为admin，缺省密码为admin，缺省级别为15级。Web网管缺省用户名为admin，缺省密码为admin，缺省级别为15级。其他系列路由器支持情况和AR150&amp;200相同。
AR所有系列的BootROM菜单缺省密码为huawei。V200R005C00版本：br/&gt;AR150&amp;160&amp;200系列路由器的Telnet缺省用户名为admin，缺省密码为Admin@huawei或admin，缺省级别为15级。Web网管缺省用户名为admin，缺省密码为Admin@huawei或admin，缺省级别为15级。其他系列路由器支持情况和AR150&amp;160&amp;200相同。
AR所有系列的BootROM菜单缺省密码为Admin@huawei。V200R005C10版本：br/&gt;AR150&amp;160&amp;200系列路由器的Telnet缺省用户名为admin，缺省密码为Admin@huawei或admin，缺省级别为15级。Web网管缺省用户名为admin，缺省密码为Admin@huawei或admin，缺省级别为15级。其他系列路由器支持情况和AR150&amp;160&amp;200相同。
AR所有系列的BootROM菜单缺省密码为Admin@huawei。V200R005C20版本：br/&gt;AR150&amp;160&amp;200系列路由器的Telnet缺省用户名为admin，缺省密码为Admin@huawei或admin，缺省级别为15级。Web网管缺省用户名为admin，缺省密码为Admin@huawei或admin，缺省级别为15级。其他系列路由器支持情况和AR150&amp;160&amp;200相同。
AR所有系列的BootROM菜单缺省密码为Admin@huawei。V200R005C30版本及之后版本：br/&gt;AR所有系列的Web网管缺省用户名为admin，缺省密码为Admin@huawei，缺省级别为15级。
AR所有系列的Console口登录缺省用户名为admin，缺省密码为Admin@huawei，缺省级别为15级。
AR所有系列的BootROM菜单缺省密码为Admin@huawei。 转载于:https://blog.51cto.com/13626036/2118824
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b230da8a28e4734146bf526e80c0485/" rel="bookmark">
			VC代码添加防火墙规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、VC代码添加防火墙规则（调用netsh命令）
VOID GetOSVersion(CString&amp; strOSVersion, DWORD &amp; dwMajorVersion, DWORD &amp; dwMinorVersion) { OSVERSIONINFOEX osver = { 0 }; osver.dwOSVersionInfoSize = sizeof(osver); ::GetVersionEx((OSVERSIONINFO*)&amp;osver); dwMajorVersion = osver.dwMajorVersion; dwMinorVersion = osver.dwMinorVersion; if (osver.dwMajorVersion == 5 &amp;&amp; (osver.dwMinorVersion == 1 || osver.dwMinorVersion == 2)) { strOSVersion = "OS:Windows XP"; } else if (osver.dwMajorVersion == 6 &amp;&amp; osver.dwMinorVersion == 0) { strOSVersion = "OS:Windows Vista"; } else if (osver.dwMajorVersion == 6 &amp;&amp; osver.dwMinorVersion == 1) { strOSVersion = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b230da8a28e4734146bf526e80c0485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603fe6618ce4807b75ae926ff996f630/" rel="bookmark">
			常用注解使用总结系列: @Order 注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Order 注解 @Order注解主要用来控制配置类的加载顺序 示例代码:
package com.runlion.tms.admin.constant; public class AService { } package com.runlion.tms.admin.constant; public class BService { } package com.runlion.tms.admin.constant; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.annotation.Order; @Configuration @Order(2) public class AConfig { @Bean public AService AService() { System.out.println("AService 加载了"); return new AService(); } } package com.runlion.tms.admin.constant; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.annotation.Order; @Configuration @Order(1) public class BConfig { @Bean public BService bService() { System.out.println("BService 加载了"); return new BService(); } } 测试类:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603fe6618ce4807b75ae926ff996f630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9133799ed852911c11bf249885b24222/" rel="bookmark">
			http状态码401
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器访问网站如果出现401 这个错误是未经授权.
其他常见的http状态码 1XX系列： 指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。
2XX系列： 代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。
200状态码： 表示请求已成功，请求所希望的响应头或数据体将随此响应返回
201状态码： 表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’
202状态码：服务器已接受请求，但尚未处理 3XX系列： 代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。这系列中最常见的有301、302状态码。
301状态码： 被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302状态码： 请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求
304状态码: 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。
4XX系列： 表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。
401状态码： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
403状态码： 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。
404状态码： 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。
5xx系列： 代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。
500状态码： 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。
503状态码： 由于临时的服务器维护或者过载，服务器当前无法处理请求。通常，这个是暂时状态，一段时间会恢复
了解基本http状态码。HTTP状态码是服务器和客户端之间交流信息的语言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ea6adaa3ae694d22d4bf590c9c7b5f/" rel="bookmark">
			filewriter追加写入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1938c17a47e3b642a538d9f4706df387/" rel="bookmark">
			intouch用户权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 intouch用户权限 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792191be39df13bde32c8e6efacb9169/" rel="bookmark">
			intouch报警组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 intouch报警组 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84fa1d514fec52a1119d3ae31776c682/" rel="bookmark">
			[Hibernate] Hibernate配制项之hibernate.show_sql, hibernate.show_sql和hibernate.use_sql_comments
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hibernate配制项之hibernate.show_sql, hibernate.show_sql和hibernate.use_sql_comments 前言 在本地开发时，我们经常有查看执行的SQL语句的需求。 本次介绍输出和统计SQL语句相关的三个配制项。
本文测试使用的实体如下：
@Entity public class Event { @Id @GeneratedValue @Column(name = "EVENT_ID") private Long id; private String title; @Column(name = "EVENT_DATE") private Date date; private int version; } show_sql(输出sql) 在hiberante.cfg.xml中把show_sql配制为true如下
&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--省略了其它配制项 --&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 在保存Event时，
Session session = sessionFactory.openSession(); session.getTransaction().begin(); Event event = new Event(); event.setDate(new Date()); event.setTitle("event title"); session.save(event); session.getTransaction().commit(); 在控制台会输出如下sql
Hibernate: insert into Event (EVENT_DATE, title, version, EVENT_ID) values (?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84fa1d514fec52a1119d3ae31776c682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83dcd21d76a809b5c23047c8df4fe8a2/" rel="bookmark">
			集合框架的理解与总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于集合框架的理解与总结
![集合框架的各种关系](https://img-blog.csdn.net/20180517215052822?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5nenVp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) （图片来自网络）
集合框架实际上用得较多的有：List,Set,Map和Iterator。
List:有序集合，允许重复的元素，常用的实现类有ArrayList,LinkedList。 ListIterator是专门用来遍历List的，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。
Set:无序集合，不允许重复的元素，常用的实现类有HashSet,TreeSet(注意：TreeSet是有序的) Set通过Iterator迭代器进行迭代
Map:是由键映射值构成的集合，一个映射不能包含重复的键；每个键最多只能映射到一个值， key是不能重复的，但是可以是null。常用的实现类：HashMap,TreeMap,Hashtable。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dabca52f96ea3bebbccb09ceb0f9c5e/" rel="bookmark">
			php 微信公众号开发之 三 自定义菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php header("Content-type: text/html; charset=utf-8"); //ID 密钥 $appid = " appid "; $appsecret = " appsecret "; $url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$appid&amp;secret=$appsecret"; $output = https_request($url); $jsoninfo = json_decode($output, true); //返回 一个数组 //[html] view plain copy//7200 var_dump($jsoninfo); //[html] view plain copy$access_token = $jsoninfo["access_token"]; //d定义菜单的格式 $jsonmenu='{ "button":[ { "type":"view", "name":"目录1", "url":"http://wx.test.com/i.php" }, { "type":"view", "name":"目录2", "url":"http://wx.test.com/i.php" }, { "type":"view", "name":"目录3", "url":"http://wx.test.com/i.php" }] }'; $url = "https://api.weixin.qq.com/cgi-bin/menu/create?access_token=".$access_token; $result = https_request($url, $jsonmenu); //[html] view plain copyvar_dump($result); function https_request($url,$data = null){ $curl = curl_init(); //$data=iconv('GB2312','UTF-8',$data);$encode = mb_detect_encoding($data, array('ASCII','UTF-8','GB2312','GBK','BIG5')); if ($encode!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dabca52f96ea3bebbccb09ceb0f9c5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bfe1ff6205851305bc8ca0e2ad88b08/" rel="bookmark">
			文本处理工具-----------AWK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本处理工具--------AWK AWK介绍 awk：Aho, Weinberger, Kernighan，报告生成器，格式化文本输出 有多种版本：New awk（nawk），GNU awk（ gawk） gawk：模式扫描和处理语言，打印报表 基本用法： awk [options] ‘program’ var=value file… awk [options] -f programfile var=value file… awk [options] 'BEGIN{ action;… } pattern{ action;… } END{ action;… }' file ... awk 程序通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块，共3部分组成 program通常是被单引号或双引号中 【建议用单引号】 选项： -F 指明输入时用到的字段分隔符 -v var=value: 自定义变量 AWK语言： 【行的换行符合自行指定；自带循环】 基本格式：awk [options] 'program' file… program:pattern{action statements;..} pattern和action： • pattern部分决定动作语句何时触发及触发事件 BEGIN,END • action statements对数据进行处理，放在{}内指明 print, printf 分割符、域和记录 • awk执行时， 由分隔符分隔的字段（域）标记$1,$2..$n称为域标识。 $0为所有域，注意：和shell中变量$符含义不同 【默认空白符为分隔符】 • 文件的每一行称为记录 • 省略action，则默认执行 print $0 的操作 注意：行：称为记录record 列：称为字段或域field或属性 AWK工作原理： 第一步：执行BEGIN{action;… }语句块中的语句第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ action;… }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。第三步：当读至输入流末尾时，执行END{action;…}语句块BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块pattern语句块中的通用命令是最重要的部分，也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块 AWK （支持标准输入，和标准输出，管道;支持数据运算） print格式： print item1, item2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bfe1ff6205851305bc8ca0e2ad88b08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0459c61fd7dcd4bf96b80a463efc82c/" rel="bookmark">
			【java】【jvm】使用命令行jmap手工触发fullGC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用了jmap工具实现，手工触发fullGC，运维常备
jmap -histo:live &lt;pid&gt;
或者
jmap -dump:live,file=dump_001.bin PID 然后删掉dump_001.bin文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f5ec164e224cddca5d7b43ffa8699b/" rel="bookmark">
			go get 与git clone的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一直对go get 和git clone 区别不开，
go get 的参数说明：
-d 只下载不安装 -f 只有在你包含了-u参数的时候才有效， 不让-u去验证import中的每一个都已经获取了， 这对于本地fork的包特别有用 -fix 在获取源码之后先运行fix，然后再去做其他的事情 -t 同时也下载需要为运行测试所需要的包 -u 强制使用网络去更新包和它的依赖包 -v 显示执行的命令 所以，go get 不仅仅是下载咯？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e72a9b9073050b67c114b0582aaf8f94/" rel="bookmark">
			程序员年龄大了真的会被时代淘汰？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直以来，都有许多人说“程序员是个吃青春饭的职业”，甚至还有说“35 岁混不到管理就等于失业”的言论。这个言论个人觉得有失偏颇，你看看这个人，头发都花白了还在岗位上呢，当时项目遇到瓶颈，快完蛋了，这个老哥从总部带了一个团队过来，没日没夜的改bug，一周后整个团队走人，项目主要的问题都解决了，后面一切顺利，完事大吉。他叫David Cutler，40多岁进入微软，今年70岁，是唯一个直接向鲍尔默汇报工作的程序员。
其实好的程序员是需要长时间的不断学习和积累而造就的，像老医生。老会计一样，也应该是越老越吃香。因为编程是脑力劳动非体力，也不靠脸蛋靠身材，跟年轻没必然联系。编程也需要经验积累，也需要长期磨练，凭什么就必须是年轻才可以？
俗话说老姜辣味大，老人经验多，老程序员的长达几十年经验是年轻程序员短时间内所不能企及的，满足现状，忽视知识更新，与时代脱节这类的人才会被社会放弃，由此可以看出跟上社会脚步，定期进行知识的更新与交流是很有必要的，那么如何更新自我知识体系，获取最新的行业资讯，快人一步呢？参加学术会议可以说是一个绝佳途径！
在今年的8、9月份，就即将有2场有关计算机技术类的国际学术会议，分别是第三届机械、控制与计算机工程国际学术会议(ICMCCE 2018)与第三届计算机技术与机械电气工程国际学术论坛(ISCME 2018)，届时，众多计算机研究领域的专家学者及企业发展人都会在会议上分享研究成果、讨论存在的问题与挑战、探索前沿科技，这注定是一场属于计算机人的学术交流风暴！欢迎海内外学者前来投稿和参会。
更多精彩高水平会议，尽在AEIC！
AEIC官网：https://www.keoaeic.org/
AEIC官方公众号
↓↓↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c2f3011910c815fe1db37e4e300d70/" rel="bookmark">
			【STM32】SPI的基本原理、库函数（SPI一般步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32F1xx官方资料：
《STM32中文参考手册V10》-第23章 串行外设接口SPI
SPI的基本介绍 SPI的简介 SPI，是英语Serial Peripheral interface的缩写，顾名思义就是串行外围设备接口，是Motorola首先在其MC68HCXX系列处理器上定义的。
SPI接口主要应用在EEPROM、FLASH、实时时钟、AD转换器，还有数字信号处理器和数字信号解码器之间。SPI是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，现在越来越多的芯片集成了这种通信协议，比如AT91RM9200。
SPI分为主、从两种模式，一个SPI通讯系统需要包含一个（且只能是一个）主设备，一个或多个从设备。SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的片选信号进行管理。
优点：支持全双工通信、通信简单、数据传输速率快；缺点：没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据的可靠性上有一定的缺陷。 STM32中SPI接口的特点
3线全双工同步传输；8或16位传输帧格式选择；主或从操作，支持多主模式；主模式和从模式下均可以由软件或硬件进行NSS管理：主/从操作模式的动态改变；可编程的时钟极性和相位；可编程的数据顺序，MSB在前或LSB在前；可触发中断的专用发送和接收标志；SPI总线忙状态标志；支持可靠通信的硬件CRC；可触发中断的主模式故障、过载以及CRC错误标志；支持DMA功能的1字节发送和接收缓冲器：产生发送和接受请求。 SPI协议 SPI引脚说明 SPI的通信原理很简单，它以主从方式工作，这种模式通常有一个主设备和一个或多个从设备，需要至少4根线，事实上3根也可以（单向传输时）。这四根线分别是MISO、MOSI、SCLK、CS，具体的描述见下表：
SPI各根线的描述 名称描述MISO主设备数据输出，从设备数据输入MOSI主设备数据输出，从设备数据输入SCLK时钟信号，主设备产生CS片选信号，主设备控制 CS：控制芯片是否被选中的，也就是说只有片选信号为预先规定的使能信号时（一般默认为低电位），对此芯片的操作才有效，这就允许在同一总线上连接多个SPI设备成为可能。
也就是说：当有多个从设备的时候，因为每个从设备上都有一个片选引脚接入到主设备机中，当我们的主设备和某个从设备通信时将需要将从设备对应的片选引脚电平拉低。
MISO/MOSI/SCLK：通讯是通过数据交换完成的，这里先要知道SPI是串行通讯协议，也就是说数据是一位一位的传输的。这就是SCLK时钟线存在的原因，由SCLK提供时钟脉冲，MISO，MOSI则基于此脉冲完成数据传输。数据输出通过MOSI线，数据在时钟上升沿或下降沿时采样，同时也会有返回数据用于接受。完成一位数据传输，输入也使用同样原理。这样，在至少8次时钟信号的改变（上沿和下沿为一次），就可以完成8位数据的传输。
要注意的是：
SCLK信号线只由主设备控制，从设备不能控制信号线。同样，在一个基于SPI的设备中，至少有一个主控设备；在点对点的通信中，SPI接口不需要进行寻址操作，且为全双工通信，显得简单高效。在多个从设备的系统中，每个从设备需要独立的使能信号，硬件上比I2C系统要稍微复杂一些。 SPI通讯模式 SPI通信有4种不同的模式，不同的从设备可能在出厂是就是配置为某种模式，这是不能改变的；但我们的通信双方必须是工作在同一模式下，所以我们可以对我们的主设备的SPI模式进行配置，通过CPOL（时钟极性）和CPHA（时钟相位）来控制我们主设备的通信模式，具体如下：
SPI通讯模式 模式CPOL（时钟极性）CPHA（时钟相位）MODE000MODE101MODE210MODE311 时钟极性CPOL是用来配置SCLK的电平出于哪种状态时是空闲态或者有效态，时钟相位CPHA是用来配置数据采样是在第几个边沿：
CPOL=0，表示当SCLK=0时处于空闲态，所以有效状态就是SCLK处于高电平时；CPOL=1，表示当SCLK=1时处于空闲态，所以有效状态就是SCLK处于低电平时；CPHA=0，表示数据采样是在第1个边沿，数据发送在第2个边沿；CPHA=1，表示数据采样是在第2个边沿，数据发送在第1个边沿。 具体四种模式的时序图如下：
对于SPI的四种通讯模式，总结起来，就是：
CPOL=0，CPHA=0：此时空闲态时，SCLK处于低电平，数据采样是在第1个边沿，也就是SCLK由低电平到高电平的跳变，所以数据采样是在上升沿；CPOL=0，CPHA=1：此时空闲态时，SCLK处于低电平，数据发送是在第1个边沿，也就是SCLK由低电平到高电平的跳变，所以数据采样是在下降沿；CPOL=1，CPHA=0：此时空闲态时，SCLK处于高电平，数据采集是在第1个边沿，也就是SCLK由高电平到低电平的跳变，所以数据采集是在下降沿；CPOL=1，CPHA=1：此时空闲态时，SCLK处于高电平，数据发送是在第1个边沿，也就是SCLK由高电平到低电平的跳变，所以数据采集是在上升沿。 SPI内部工作机制 下面对照一个SPI单主机与单从机连接图，理解其内部工作机制：
硬件上为4根线；主机和从机都有一个串行移位寄存器，主机通过向它的SPI串行寄存器写入一个字节来发起一次传输；串行移位寄存器通过MOSI信号线将字节传送给从机，同时从机也将自己的串行移位寄存器中的内容通过MISO信号线返回给主机。这样，两个移位寄存器中的内容就被交换；外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。 也就是说：SPI是一个环形总线结构，由CS、SCLK、MISO、MOSI构成，其时序其实很简单，主要是在SCLK的控制下，数据按照从高位到低位的方式依次移出主机寄存器和从机寄存器，并且依次移入从机寄存器和主机寄存器。当寄存器中的内容全部移出时，相当于完成了两个寄存器内容的交换。
假设主机的8位寄存器装的是待发送的数据10101010，上升沿发送、下降沿接收、高位先发送。那么第一个上升沿来的时候，主机将会通过MOSI信号线传输给从机最高位1，自身寄存器变成0101010x。同时，MISO信号线会从从机处返回一个数据给主机，那么这时寄存器为0101010MISO，这样在 8个时钟脉冲以后，两个寄存器的内容互相交换一次。这样就完成里一个SPI时序。 这个时候就会有一个疑问，或者说产生一个必然了：
为什么主机发送一个数据给从机，从机就同时通过MISO返回的一个数据给主机呢？
解释：主机和从机的发送数据是同时完成的，两者的接收数据也是同时完成的。也就是说，当上升沿主机发送数据的时候，从机也发送了数据。
所以为了保证主从机正确通信，应使得它们的SPI具有相同的时钟极性和时钟相位。
STM32的SPI接口 SPI可分为主、从两种模式，并且支持全双工模式，所以这也就导致STM32的SPI接口比较复杂。比如：配置SPI为主模式、配置SPI为从模式、配置SPI为单工通信、配置SPI为双工通信等等。这里的内容就非常庞大，涉及到的寄存器的位也比较多，所以就不介绍太多，想要了解更多可以去查看STM32F1xx官方资料的第23章节。
SPI接口的框图 SPI引脚 STM32的SPI接口通过4个引脚与外部器件相连，与标准的SPI协议是一致的：
MISO：主设备输入/从设备输出引脚。该引脚在从模式下发送数据，在主模式下接收数据；MOSI：主设备输出/从设备输入引脚。该引脚在主模式下发送数据，在从模式下接收数据；SCK：串口时钟，作为主设备的输入，从设备的输入；NSS：从设备选择。这是一个可选的引脚，用来选择主/从设备。它的功能是用来作为“片选引脚”，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。 从选择（NSS）脚管理
有2种NSS模式：
软件NSS模式：可以通过设置SPI_CR1寄存器的SSM位来使能这种模式。在这种模式下NSS引脚可以用作它用，而内部NSS信号电平可以通过写SPI_CR1的SSI位来驱动；硬件NSS模式，分两种情况： NSS输出被使能：当STM32F10xxx工作为主SPI，并且NSS输出已经通过SPI_CR2寄存器的SSOE位使能，这时NSS引脚被拉低，所有NSS引脚与这个主SPI的NSS引脚相连并配置为硬件NSS的SPI设备，将自动变成从SPI设备。 当一个SPI设备需要发送广播数据，它必须拉低NSS信号，以通知所有其它的设备它是主设备；如果它不能拉低NSS，这意味着总线上有另外一个主设备在通信，这时将产生一个硬件失败错误；NSS输出被关闭：允许操作于多主环境。 数据帧格式 根据SPI_CR1寄存器中的LSBFIRST位，输出数据位时可以左对齐（MSB对齐标准）也可以右对齐（LSB对齐标准）。根据SPI_CR1寄存器的DFF位，每个数据帧可以是8位或是16位。所选择的数据帧格式对发送和/或接收都有效。 状态标志 应用程序通过3个状态标志可以完全监控SPI总线的状态：
发送缓冲器空闲标志（TXE） 此标志为1时表明发送缓冲器为空，可以写下一个待发送的数据进入缓冲器中。当写入SPI_DR时，TXE标志被清除。
接收缓冲器非空（RXNE） 此标志为1时表明在接收缓冲器中包含有效的接收数据。读SPI数据寄存器可以清除此标志。
忙（Busy）标志 BSY标志由硬件设置与清除（写入此位无效果），此标志表明SPI通信层的状态。
当它被设置为1时，表明SPI正忙于通信，但有一个例外：在主模式的双向接收模式下（MSTR=1、BDM=1并且BDOE=0），在接收期间BSY标志保持为低。
在软件要关闭SPI模块并进入停机模式(或关闭设备时钟)之前，可以使用BSY标志检测传输是否结束，这样可以避免破坏最后一次传输，因此需要严格按照下述过程执行。
SPI中断 STM32的SPI引脚 SPI引脚位置 外设的GPIO配置 SPI相关配置库函数 1个初始化函数 void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct); 作用：初始化SPI的相关参数，比如方向（全双工）、主从模式、数据大小、CPOL、CPHA、片选软件模式、预分频系数等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c2f3011910c815fe1db37e4e300d70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aeda0019ccffe19267d837103d62f87/" rel="bookmark">
			ajax所包含的技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用CSS和XHTML来表示。 2. 使用DOM模型来交互和动态显示。 3.使用XMLHttpRequest来和服务器进行异步通信。 4.使用javascript来绑定和调用。
在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3deae4ef12164495f93d533be7ee2e06/" rel="bookmark">
			Ajax工作原理的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f30281ff08c92fb3bcc52160bac48fd2/" rel="bookmark">
			Linux下安装和卸载git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yum源上自动安装:
sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker
git --version
git已经安装完毕
在Linux上安装Git Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。而国外的GitHub和国内的Coding都是项目的托管平台。但是在使用Git工具的时候，第一步要学会如何安装git，本教程就手把手教大家如何手动编译安装git。
1、介绍
使用Coding管理项目，上面要求使用的git版本为1.8.0以上，而很多yum源上自动安装的git版本为1.7，所以需要掌握手动编译安装git方法。
2、安装git依赖包
yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker
3、删除已有的git
yum remove git
4、下载git源码
切换到你的包文件存放目录下
cd /usr/src
下载git安装包
wget https://www.kernel.org/pub/software/scm/git/git-2.8.3.tar.gz
解压git安装包
tar -zxvf git-2.8.3.tar.gz
cd git-2.8.3
配置git安装路径
./configure prefix=/usr/local/git/
编译并且安装
make &amp;&amp; make install
查看git版本号
git --version
git已经安装完毕
5、将git指令添加到bash中
vi /etc/profile
在最后一行加入
export PATH=$PATH:/usr/local/git/bin
让该配置文件立即生效
source /etc/profile
git如何卸载 &lt;1.&gt;找到git的位置
终端命令:which -a git
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f30281ff08c92fb3bcc52160bac48fd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cce670e93e3555fb87cfa9a291d549c/" rel="bookmark">
			linux下安装jdk(rpm版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载:https://blog.csdn.net/sonnet123/article/details/9169741/
1、下载JDK
路径：http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html
下载jdk：
[plain] view plain copy #cd /tmp #wget "http://download.oracle.com/otn-pub/java/jdk/7u25-b15/jdk-7u25-linux-x64.rpm?AuthParam=1372142112_983985b072250462338f52e48b37d8b9" 2、安装 ①复制到/usr/java/路径下
[plain] view plain copy #mkdir /usr/java/ #cp jdk-7u25-linux-x64.rpm /usr/java/ ②添加可执行权限，并安装
[plain] view plain copy # cd /usr/java/ # chmod +x jdk-7u25-linux-x64.rpm #rpm -ivh jdk-7u25-linux-x64.rpm ③执行结果： [plain] view plain copy [root@localhost java]# rpm -ivh jdk-7u25-linux-x64.rpm Preparing... ########################################### [100%] 1:jdk ########################################### [100%] Unpacking JAR files... rt.jar... jsse.jar... charsets.jar... tools.jar... localedata.jar... 3、配置环境变量 ①进入编辑profile文件
[plain] view plain copy #vim /etc/profile ②在profile文件最后追加入如下内容： export JAVA_HOME=/usr/java/jdk1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cce670e93e3555fb87cfa9a291d549c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/436/">«</a>
	<span class="pagination__item pagination__item--current">437/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/438/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>