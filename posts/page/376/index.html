<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bfc4c46e3d4b1e61e75b2d6783529b0/" rel="bookmark">
			plantUml活动图(新语法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动图(新语法) 当前活动图(activity diagram)的语法有诸多限制和缺点，比如代码难以维护。
所以从V7947开始提出一种全新的、更好的语法格式和软件实现供用户使用(beta版)。
就像序列图一样，新的软件实现的另一个优点是它不再依赖于Graphviz。
新的语法将会替换旧的语法。然而考虑到兼容性，旧的语法仍被能够使用以确保向前兼容。
但是我们鼓励用户使用新的语法格式。
简单活动图 活动标签(activity label)以冒号开始，以分号结束。
文本格式支持creole wiki语法。
活动默认安装它们定义的顺序就行连接。
@startuml :Hello world; :This is on defined on several **lines**; @enduml 开始/结束 你可以使用关键字start和stop表示图示的开始和结束。
@startuml start :Hello world; :This is on defined on several **lines**; stop @enduml 也可以使用 end 关键字。
@startuml start :Hello world; :This is on defined on several **lines**; end @enduml 转存失败重新上传取消
条件语句 在图示中可以使用关键字if，then和else设置分支测试。标注文字则放在括号中。
@startuml start if (Graphviz installed?) then (yes) :process all\ndiagrams; else (no) :process only __sequence__ and __activity__ diagrams; endif stop @enduml 转存失败重新上传取消
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bfc4c46e3d4b1e61e75b2d6783529b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c6f4cef1e3b3f047c3167853781d6c/" rel="bookmark">
			解决vue-i18n在非.vue文件中，在其他js文件，譬如axios拦截器等js文件中如何使用的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：多语言网站，网络提示错误信息也需要支持多语言切换，一般i18n在.vue文件中的模板里按照api调用就可以了。
那么在.js文件中如何使用呢？
譬如：我封装的axios请求文件
只需要看步骤1、2、3、4
// request.js import axios from 'axios' import { Message } from 'element-ui' // 1.还是需要引入vue-i18n插件 import VueI18n from 'vue-i18n' // 2.定义中英文语言包 const messages = { en: { message: { connectionServerFailed: 'Connection to server failed' } }, zh: { message: { connectionServerFailed: '连接服务器失败' } } } export function getLanguage() { const chooseLanguage = Cookies.get('language') if (chooseLanguage) return chooseLanguage const language = (navigator.language || navigator.browserLanguage).toLowerCase() const locales = Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45c6f4cef1e3b3f047c3167853781d6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5239c403dc22c1f5d3f211c2992fca71/" rel="bookmark">
			将Excel转换成为数据库的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景:项目需要，将Excel内容，转换为数据库格式
步骤一：下载excel格式文件
步骤二: 将excel另存位txt（UTF-8/UTF-16），我们的目的是导出csv，但是直接导出的话，格式没办法指定，所以过渡一下
步骤三：将txt中的 （ ）空格替换为,另存为csv
步骤四：将csv直接转换为sql指令文件，（https://www.convertcsv.com/csv-to-sql.htm）
步骤五：将sql语句直接生成数据库db文件（使用sqlite工具，都具备转换功能）
但是我想做的是在服务端生成db文件，所以步骤五的操作略有不同
服务端操作步骤：
步骤五：登陆mysql
1.登陆 mysql
2.指定数据库：
mysql&gt; use db_name;
3.指定名字utf-8格式：
mysql&gt; set names utf8;
4.根据sql写入数据库内容：
mysql&gt; source /xxx/xxx.sql
注意，这里如果是中文，可能会报错：
ERROR 1366 (HY000): Incorrect string value: '\xE6\x9C\x888\xE6\x97...' for column 'xx' at row 1
步骤六：调整数据库格式：
alter table table_name default character set utf8;(改完之后，查看一下改没改成功：show create table mytable;)
alter table table_name change colume_name colume_name varchar(50) character set utf8;(改完之后，查看一下改没改成功：show create table mytable;)
修改成功之后，继续使用写入数据库命令就完成了数据库的写入了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dea0522eeb22fac0f1b25e8bc0151d4/" rel="bookmark">
			常用网络命令（二）-- IPConfig 操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 常用网络命令（一）-- ping操作
常用网络命令（二）-- IPConfig操作
常用网络命令（三）-- netstat 命令 和 tracert 命令
常用网络命令（四）-- route 命令 和 arp 命令
常用网络命令（五）-- nslookup, netsh, net
常用网络命令（六）-- ftp （命令行里也能传文件）
重点说明： Win下dos命令行内，使用ctrl + c 可以终止当前进程的运行
参考来源：深圳大学 尹剑飞老师 计算机网络课程实验
IPConfig IPConfig 实用程序（ 和 WinIPCfg ）可用于显示当前的TCP/IP配置的设置值。这些值用来检验人工配置的TCP/IP设置是否正确。如果本地计算机和所在的局域网使用了动态主机。
配置协议，通过IPConfig可以了解计算机是否成功租用到一个IP地址，如果租用到则可以了解它目前分配到的是什么地址。
了解计算机当前IP地址、子网掩码和缺省网关实际上是进行测试和故障分析的必要项目。
常用命令为
ipconfig 查看配置 ipconfig /all 查看全部详情配置 ipconfig /release 释放归还IP地址 ipconfig /renew 重新租用地址 其中，下面的两条release renew命令只能在动态分配（向DHCP服务器租用IP地址）的计算机上起作用。如果计算机的IP不是由DHCP动态分配的，那么就无法执行这两条。Win10的网络设置中可以看到IP设置，IPV4协议中也可以调是否自动分配ip和自动分配dns地址。
ipconfig /release 执行ipconfig /release 之后，计算机就会丢失掉自己的IP地址，默认是ipv4地址，可以看到执行前后的配置变化，执行完之后显示的配置信息没有了IPV4地址，查看全部配置信息则会看到连接已断开。
执行前后的配置对比见下图。
这时候如果打开浏览器访问，域名则会报dns错误，ip地址报unreachable地址不可达
恢复正常的方法是需要重新获取分配的ip地址，可以使用ipconfig /renew 重新租用地址。或者简单粗暴的断开网络连接，再重新连接即可。
ipconfig /renew 输入ipconfig /renew，本地计算机便设法与DHCP 服务器取得联系，并租用一个IP地址。多数情况下网卡将被重新赋予和以前所赋予的相同的IP地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dea0522eeb22fac0f1b25e8bc0151d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6484459735f15fe83426b04b02154a46/" rel="bookmark">
			Java中如何创建字符串数组？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String [] strArray = new String [20];
注意后面的[20]是字符串数组的个数，不是字符串的长度。
不过推荐用ArrayList strArray = new ArrayList (); 比较灵活
转自：https://zhidao.baidu.com/question/407107329.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c05fedf10ae8fba082e6a45df5f268/" rel="bookmark">
			用树莓派打造摄像头服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 1.下载motion软件2.查看摄像头是否插入树莓派且是否正常3.编辑文件4.查看摄像头内容 1.下载motion软件 sudo apt-get install motion
2.查看摄像头是否插入树莓派且是否正常 lsusb
可查看是否有摄像头的内容，要是不知道怎么判断的话可以先把摄像头断开，重新运行改命令，看看是否有内容消失
3.编辑文件 sudo nano /etc/motion/motion/.conf
进入后将“daemon off”改为“daemon on”,如图所示：
另外还有一个地方在文件较下方，我可以通过“Ctrl+W"进搜索，输入”localhost“,回车搜索
然后将"stream_localhost =on"改为"stream_localhost =off"。
然后按下“Crtl+O"保存，再按下”Crtl+X"退出。
此外还有一个文件需要编辑
sudo nano /etc/default/motion
将“start_motion_daemon=no”改为“start_motion_daemon=yes”即可
为了运行web服务，需要键入下列命令
sudo service motion start
sudo motion
4.查看摄像头内容 首先你得知道自己的树莓派IP地址，输入以下命令
honstname -I
这是我的树莓派的地址
然后你就可以打开手机或者电脑浏览器观看摄像头的实时情况了
在浏览器输入地址：http://192.168.xxx.xxx(自己树莓派的的IP地址):8081(端口都一样)，有些浏览器可能打不开，换个试试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e63feeb31e540b085726affab85962b7/" rel="bookmark">
			传统的目标检测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基于滑动窗口的目标检测算法
滑动窗口&gt;&gt;特征提取&gt;&gt;分类器
图 滑动窗口目标检测流程
对输入的图像设置不同大小的滑窗，确定步长遍历整个图像，每次滑动完成后对当前选择框进行特征提取（SIFT、HOG等），并使用事先训练好的分类器（SVM、Adaboost等）判断该区域中存在目标的概率。得到所有可能存在目标的滑窗，因为这些窗口会存在重复较高的部分，最后采用非极大值抑制(Non-Maximum Suppression, NMS)的方法进行筛选，经过NMS筛选后得到检测目标。
缺点
滑窗法简单易于理解，但是不同大小比例的窗口遍历图像导致选择框冗余；同时设计窗口时还需要考虑物体长宽比，增加了设计复杂度；手工设计的特征鲁棒性较差；效率低下，对于实时性要求较高的任务，不推荐使用滑窗法。
2.基于选择性搜索（Selective Search）的目标检测算法
利用图像中的边缘、纹理、颜色等信息，保证在选取较少(几百至几千）窗口的情况下保持较高的召回率（Recall）。
选择性搜索&gt;&gt;特征提取&gt;&gt;分类器
图 基于相似度的分割区域合并
首先使用图像分割方法初始化分割区域，然后计算相邻两个区域的相似度，每次合并最相似（通过颜色、纹理、大小和形状交叠判断）的两个区域，每次迭代过程中使用搜索框定位合并区域，直到最终剩下一块完整的区域，最后进行特征提取与分类。
总结
滑动窗口最大的缺点就在于选择框冗余，而选择性搜索可以有效地去除冗余候选框，使得计算量大大的减小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f81cca3056b8d249f6182b722824ed6/" rel="bookmark">
			cuda运行错误：the launch timed out and was terminated in
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 运行cuda程序时，提示the launch timed out and was terminated in
原因： 核函数运行时间太长，导致看门狗定时器超时。
解决办法 一个简单的方法就是把每个核函数写的足够短。
其他方法可以看这里，它提供了windows和linux的解决方案：
windows解决方案linux解决方案 这里记录一下我用linux解决方案中第四种方法（Option 4: Turn Off Interactive Mode in the NVIDIA Driver）遇到的问题：
修改xorg.conf文件 $sudo gedit /etc/X11/xorg.conf 在Section "Device"里添加一行Option "Interactive" "off"，如下图
重启即可。重启后，再运行代码就不会超时了。 不过虽然可以长时间运行核函数，但是我遇到了其他问题，就是屏幕的分辨率变小了，只支持960x540；所以成功代码运行完后我还想取消这种设置，下面是取消设置的办法：
打开/etc/X11/xorg.conf，删掉刚才添加的Option "Interactive" "off"，重启，这时候还没有好。按Ctrl+Alt+F1进入tty1模式，输入 $sudo service lightdm stop $sudo service lightdm start 按Ctrl+Alt+F7切换回GUI模式，分辨率的问题就好了。 相关/参考链接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996e9448fef67f0e8b3a28b22d398e26/" rel="bookmark">
			dpkg: error processing package *** (--configure)错误解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Ubuntu 执行 sudo apt-get upgrade 或sudo apt-get install 时，出现了如下的报错：
dpkg: error processing package ***
subprocess installed post-installation script returned error exit status 127
这主要是由于不完全安装导致的。解决方式是删除或编辑安装信息文件。
粗暴方法一：删除所有信息之后update sudo mv /var/lib/dpkg/info/ /var/lib/dpkg/info_old/ sudo mkdir /var/lib/dpkg/info/ sudo apt-get update 执行完以上代码后再用sudo apt-get install 安装
精细方法二：查看出错信息，定向删除或编辑 出错信息subprocess installed post-installation script returned error exit status 127中
可以看到这里的提示post-installation的问题，那么需要编辑该文件，具体在
/var/lib/dpkg/info/[package_name].postinst
同理，还有可能出问题的是"pre-removal" or "post-removal" 对应后缀 .prerm or .postrm
此时删除问题文件或编辑注释掉所有或问题内容即可。例如
sudo rm /var/lib/dpkg/info/[package_name].postinst # 或更狠一点，全删 # sudo rm /var/lib/dpkg/info/[package_name].* sudo dpkg --configure -a sudo apt-get update 执行完以上代码后再用sudo apt-get install 安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/996e9448fef67f0e8b3a28b22d398e26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f18482df0449720e0c58b7353223f5/" rel="bookmark">
			一个例子带你入门Python装饰器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		============
欢迎关注我的公众号：早起python
============
前言
在还未正式发布的python3.9中，有一个新功能值得关注，那就是任意表达式可以作为装饰器，如果你还不知道装饰器是什么，没关系，跟着本文一个例子搞明白，不过需要你对Python中的类(Class)有一定的了解，因为我们一般在类中使用。
一个例子
关于装饰器是什么，随便一搜都能找到一堆解释。我们让那些看着头疼的名词、定义去一边吃灰，看下面这个例子
class Blog(): def __init__(self,name,title): self.author = name self.article = title self.information = self.author + ' ' + self.article def url(self): return f"The author url is {self.author}.{self.article}.com " 这段代码不难理解吧，定义了一个Blog类，这个类包含author、article、information属性，并拥有一个url方法。
现在我们来创建一个实例
&gt;&gt;&gt; user = Blog('liuzaoqi','Python') 这行代码不难看懂吧，创建了一个user，姓名是liuzaoqi，标题是Python。OK现在来打印一下相关属性
&gt;&gt;&gt; print(user.author) #liuzaoqi &gt;&gt;&gt; print(user.article) #Python &gt;&gt;&gt; print(user.information) #liuzaoqi Python &gt;&gt;&gt; print(user.url()) #The author url is liuzaoqi.Python.com 没问题吧，到目前为止还与装饰器没啥太大关系，现在问题来了，如果我想修改这个user的article，这样写可以吧👇
&gt;&gt;&gt; user.article = 'study' &gt;&gt;&gt; print(user.article) &gt;&gt;&gt; print(user.information) &gt;&gt;&gt; print(user.url()) 来猜一下结果，我们将article修改了：将'Python'改为'study'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f18482df0449720e0c58b7353223f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e929eb7043d2f4a3c77f99e77e59b6/" rel="bookmark">
			动态规划——详解经典的完全背包与多重背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天是算法数据结构专题的第13篇文章，也是动态规划专题的第二篇。
上一讲当中我们一起学习了动态规划算法中的零一背包问题，我们知道了所谓的零一背包是指每一种物品只有一个，所以它的状态只有0和1两种，即拿或者不拿。而今天我们要来讨论物品不止有一个的情况，物品不止有一个也分两种，一种是不作任何限制，要多少有多少，这种称为完全背包问题，另一种是依然有个数限制，这种称为多重背包问题。
我们一个一个来看，我们先从其中比较简单的完全背包开始。由于我们这是一个连续的专题，没有看过上篇文章或者是新关注的同学可以移步我们专题的第一篇：
动态规划入门——详解经典的零一背包问题
完全背包 在之前的文章当中，我们阐述了动态规划当中状态和决策以及状态转移的相关概念。在背包问题当中，背包的容量是状态，而选择哪个物品进行获取则是决策，当我们制定了一个决策之后，背包会从一个状态转移到另一个状态。而动态规划算法就是枚举所有状态和决策，获得所有的状态转移，并且记录这个过程中每个状态能够获得的最优解。
在之前的文章当中，我们先遍历了所有的决策，然后再枚举了所有的状态，计算在决策下进行转移之后得到的结果。在之前的零一背包问题当中，由于我们每个物品只能获取一个，如果在前面的状态执行了决策，那么后面的状态则不能进行相同的决策。这也就是动态规划的后效性，而在完全背包问题当中，我们去掉了这个限制，也就意味着决策之间不再有后效性，一个决策可以重复应用在各个状态当中。
所以如果你能理解上面这段话，那么整个算法其实非常简单，几乎就是零一背包的代码。只不过我们把其中倒叙遍历的背包状态再”修正“回来。
之前我们为了避免物品的重复获取，所以采用了倒叙遍历的方法，如今我们不再对数量进行限制，意味着我们可以自由地采取决策进行转移。要做到这点，就是单纯的两重循环，第一种枚举决策， 第二重枚举状态，记录所有转移可能带来的最优解即可。我们来看代码：
dp = [0 for _ in range(11)] items = [[6, 10], [5, 8], [5, 9]] # 遍历物品 for v, w in items: # 遍历背包空间（状态） # 更新vp+v的状态，即当前容量放入物品之后的状态 for vp in range(0, 10-v+1): dp[vp+v] = max(dp[vp+v], dp[vp] + w) print(max(dp])) 如果你还没能完全理解其中的逻辑，我们可以对照一下代码再来理解一下。在第一种循环当中，我们遍历了所有的物品，每一个物品对应了一种决策。每一个决策可以应用在各个状态上，比如第一个物品是6， 15，代表它的体积是6，价值是15。那么我们遍历所有能够应用这个决策的状态，也就是在不超过背包容量的情况下能够放下的状态。显然对于一个体积是6的物品来说，只有0到4的状态可以放下。比如说我们选择状态2，状态2放下了这个物品之后，自然会转移到状态8，因为体积增加了6。有可能这个决策会使得状态8获得更好的结果，也有可能不会，如果会的话我们就更新一下状态8记录的值。这个从一个状态采取决策到另一个状态的过程就是状态转移。
完全背包就是零一背包的无限制版，从原理上来说，两者的思路和做法基本上是一样的。如果你能理解零一背包，那么完全背包对你来说也一定不在话下。
细小的优化 在完全背包当中，由于所有的物品都可以无限获取。所以我们可以引入一些零一背包不能进行的优化，比如对于同样体积的物品而言，我们可以只保留价值最高的物品，将其他的物品过滤掉。这个思路很朴素，我想大家应该都能理解。
比如两个物品体积都是3，一个价值是4，另一个价值是3，我们完全可以忽略价值是3的那一种。因为两者带来的状态转移是一样的，但是明显前者收益更好。而这个优化在零一背包当中不可行是因为每个物品只有一个，很有可能会出现两者都要的情况，所以不能简单地替换。而在完全背包当中则没有这个问题。
多重背包 和零一背包以及完全背包相比，多重背包要难上一些，它的解法也非常多样。我们今天先来看一些相对比较简单的方法。
同样，我们从最简单的方法开始讲起。最简单的方法当然就是将多重背包蜕化成零一背包来解决，比如一个物品最多可以拿N个，我们就把它拆成N种物品，这N种每种物品最多拿一个，相当于我们一种物品可以最多拿N个。这个思路应该很简单，大家都能想明白，但是有个很大的问题，就是复杂度。当然我们可以根据背包的体积做一些优化，比如当物品的数量很多并且超过了背包容量的时候，我们可以把超过容量的数量去掉，但是整体的复杂度还是很高。尤其是当我们背包容量很大的时候。
那么，我们怎么来解决这个问题呢？
这里要介绍一个比较通用的算法，这个算法可以用来优化很多问题，也是很多算法的思想。它就是二进制表示法。这个方法我们在之前的文章当中曾经讲到过，思想非常简单，但是非常实用。
二进制表示法 所谓二进制表示法就是将一个int类型的数表示成二进制，整个算法的思想就是这一句话，所以我想大家应该都能理解。但是我们为什么要将一个int转成二进制，以及转成二进制之后怎么样来优化算法，这个才是我们想知道的，也才是算法的核心重点，不要着急，我们一点点来说明。
我们都知道在计算机系统当中都是以二进制存储的所有数据，最典型的就是整数。一个32位的int，可以表示最大21亿的整数。这个都是我们已知的，但是换一个角度来看，一个21亿的数最后用32个二进制位就表示了，其实非常惊人。为什么说二进制是一个非常伟大的思想？不在于它难，而在于它高效地压缩了数据。
我们进一步来看，32个二进制位为什么能表示这么大的数据呢？因为这32位int表示的数据是不一样的，第0位表示1，第1位表示2，第2位表示4……到了第31位的时候，表示的数已经非常庞大。我们用这32个数不同的组合来表示不同的数，换句话说范围内的所有数最终都变成了这32个数中若干个的累加。我们写成公式就是： x = ∑ i = 0 31 a i ⋅ 2 i x = \sum_{i=0}^{31} a_i\cdot 2^i x=∑i=031​ai​⋅2i，这里的 a i a_i ai​表示的是第i位的系数，它只有0和1两个取值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e929eb7043d2f4a3c77f99e77e59b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c5c214b1fa8df106839ca5c39b75cb/" rel="bookmark">
			英语入门2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实意动词特征 come read go watch play fly
1.He comes from Shenyang.
2.She is reading story books.
现在进行式
3.They went to America yesterday
一般过去式
4.We have watched the game for three times.
现在完成式
5.My mother will fly back to China next month.
一般未来式
实义动词的否定 使用助动词进行否定
在助动词do does did 后面加not
1.I don’t go to school by bus.
2.She doesn’t watch TV every day
使用助动词进行提问：
使用疑问词进行提问和回答 When ， Where ，Who ，What ，How
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12c5c214b1fa8df106839ca5c39b75cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15b227333c1d0665b33fbf53d96b6b95/" rel="bookmark">
			每日打卡 2020-03-26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 践行每日打卡，早睡早起早做，轻快前行：
学习：精读一篇文章，看一功能，写一总结工作：撰写工作计划，更新资源汇总，写项目总结设计生活：整理家，迎接下一段生活 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e6879b3e9389e813f7d0501d1ab486/" rel="bookmark">
			使用text-align: center；的居中问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：把&lt;img&gt;和&lt;span&gt;放在div标签里用text-align:center;进行div块内元素居中但是文本居中了，图片没有居中
1. 分析 我们先来说一下 w3cschool对text-align定义：text-align 属性规定元素中的文本的水平对齐方式。通过指定行框与哪个点对齐，从而设置块级元素内文本的水平对齐方式。
用法：
在块级元素内使用，能实现它里面包含的文本内容居中
在块级元素内使用，能实现他里面的行内块元素或者行内元素居中
在块级元素内使用，当子元素也为块级元素时不能让子元素居中
但是块级子元素会继承父元素的text-align:center;，使得其内的文本内容居中 下面是我写的代码
从代码中可以发现两个问题
首先，图片不能居中是因为我给图片设置了display:block;，把它转为块级元素了，加上我给图片设置的宽高正好等于容器大小，所以也看不出来他其实在容器内居中了
补充：&lt;img&gt;标签作为可置换元素，虽然是行内元素，但是也可以设置宽高属性 其次，我也通过display:block;把&lt;span&gt;转为了块级元素，然后也没有给他设置宽度，所以他就继承了父元素的宽度，同时也继承了父元素的text-align，使得里面的内容居中了
当我把img和span里的display:block;去掉时，会发现span有的内容跑到了图片的旁边，其实这个时候他也是居中的，只不过我给div设置的宽度不够，导致他换行显示了。当把div宽度改为500px的时候。可以看到图片跟内容都是在同一行居中显示的。在同一行是因为他们是行内元素。
&lt;style&gt; a{text-decoration: none;} div{ height: 300px; width: 300px; background: pink; border: 1px solid #555555; text-align: center; } div a img{ width: 245px; height: 245px; margin-top: 10px; display: block; } div a span{ display: block; color: #5555; font-size: 12px; } &lt;/style&gt; &lt;body&gt; &lt;div&gt; &lt;a href="#"&gt; &lt;img src="img/cake1.jpg" alt=""&gt; &lt;span&gt;幸福先生【F先生】&lt;/span&gt; &lt;span&gt;228.00&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/body&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5e6879b3e9389e813f7d0501d1ab486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db1a33340af7db3cca15ce0cdc7186b8/" rel="bookmark">
			LaTex ieee模版中表格caption大写出不来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IEEE模版里面给的表格示例中，表格的caption都是大写，但是自己用的时候都是小写，而且caption和table还是连在一起写的，并没有换行，检查之后发现多加了一个caption的package，删掉就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b1117f1e75daa1c2e258d4087bdf03d/" rel="bookmark">
			27-图像的矩（EmguCV学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 图像普通矩图像的Hu矩形状匹配（matchShape()函数）Code效果参考 图像普通矩 1、矩函数在图像分析中有着广泛的应用;一个从数字图像中提取出来的矩集，通常描述了该图像形状的全局特征，并提供了大量的关于该图像不同类型的几何特征信息，比如大小、位置、方向、形状等。一阶矩与形状有关，二阶矩显示曲线围绕直线平均值的扩展程度，三阶矩是关于平均值的对称性的测量。
2、由图像二阶矩与三阶矩可以导出7个不变矩，不变矩是图像的统计特征，满足平移，伸缩，旋转不变性， 在图像识别领域具有广泛的应用；
3、轮廓矩代表一条轮廓、一幅图像、一组点集的某些高级特征，矩的数值定义：
M p , q {M}_{p,q} Mp,q​代表对象中所有像素和；
4、矩的分类：
①空间矩（普通矩）： 具体分为0阶矩：m00、1阶矩：m10, m01、2阶矩: m20,m02,m11、3阶矩：m30，m21，m12，m03；各阶矩物理意义如下：
②中心距（central moments）：具有位移不变性，利用这些矩，可将出现在图像中任意位置的物体与参考图像中可能出现在另外位置的参考物体进行比较；
图像中心计算公式：
③归一化中心矩：具有缩放不变性，支持图像的缩放进行比较
5、图像矩通过Moments()函数计算：
图像的Hu矩 1、Hu矩是归一化中心矩的线型组合，具有平移、缩放、旋转、镜面映射不变性，一共有7个double元素组成一个向量；
2、Hu不变矩通过Humoments()函数计算：
3、Hu矩对物体形状具有较好的描述
形状匹配（matchShape()函数） 1、matchShape()函数比较轮廓相似度，根据Hu矩的原理进行计算：计算结果通过函数返回值返回，返回值越小，相似度越高，返回值为0 ， 表示两轮廓完全相似。
Code 利用Hu矩进行形状匹配比模板匹配好用一点：
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using Emgu.CV; using Emgu.Util; using Emgu.CV.Structure; using Emgu.CV.CvEnum; using Emgu.CV.Util; using System.Drawing; namespace lesson27 { class Program { static void Main(string[] args) { ///计算轮廓面积、周长、质心 Mat src = CvInvoke.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b1117f1e75daa1c2e258d4087bdf03d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c578942769b0ecc4c85256498fad4971/" rel="bookmark">
			js转换金额，元，万元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js转换金额，元，万元。。 export function strNumSize(tempNum) { var stringNum = tempNum.toString(); var index = stringNum.indexOf("."); var newNum = stringNum; if (index != -1) { newNum = stringNum.substring(0, index); } return newNum.length; } export function unitConvert(num) { var moneyUnits = ["元", "万元", "亿元", "万亿"]; var dividend = 10000; var curentNum = num; //转换数字 var curentUnit = moneyUnits[0]; //转换单位 for (var i = 0; i &lt; 4; i++) { curentUnit = moneyUnits[i]; if (strNumSize(curentNum) &lt; 5) { break; } curentNum = curentNum / dividend; } var m = { num: 0, unit: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c578942769b0ecc4c85256498fad4971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1b931ab6fc8167e2d611c024e13bd6/" rel="bookmark">
			评分卡模型的思想和数理推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、数据准备
二、特征工程
2.1 WOE和IV公式
2.2 WOE实例：
2.3 WOE的意义及单调性
2.4 特征选择
三、数据建模
四、模型评估
五、生成评分卡
本文主要介绍评分卡模型的概念及背后的思想体系，模型如何创建，以及在创建模型过程中遇到的问题和思考。
前言 为什么要做评分卡模型？
《巴赛尔协议》中明确对银行的系统性风险进行定义和划分，主要分为：信用风险、市场风险、操作风险、流动性风险、国家风险、声誉风险、法律风险、合规风险、战略风险。其中信用风险指授信方拒绝或无力按时、全额支付所欠债务时，给信用方带来的损失。
银行、消费金融等各种贷款机构，为了控制信用风险，期望通过客户历史的行为信息判断客户违约的可能性，由此决定是否授信以及授信的额度，从而减少在金融交易中存在的风险。评分卡模型在这种大背景下应运而生。
评分卡分为ABC卡三类：
A卡（Application score card）申请评分卡
B卡（Behavior score card）行为评分卡
C卡（Collection score card）催收评分卡
评分机制的区别在于：
1.使用的时间不同。分别侧重贷前、贷中、贷后；
2.数据要求不同。A卡一般可做贷款0-1年的信用分析，B卡则是在申请人有了一定行为后，有了较大数据进行的分析，一般为3-5年，C卡则对数据要求更大，需加入催收后客户反应等属性数据。
3.每种评分卡的模型会不一样。在A卡中常用的有逻辑回归，AHP等，而在后面两种卡中，常使用多因素逻辑回归，精度等方面更好。
除此之外，评分卡模型还适用于其他关于信用风险行为识别，如芝麻信用分、它可以提高花呗的额度，可以消费贷，可以不缴押金直接租车等。
信用评分模型是将模型变量WOE编码方式离散化之后运用logistic回归模型进行的一种二分类变量的广义线性模型。利用信用评分模型得到的客户信用评分，可作为是否准予授信或为授信额度和利率提供参考。接下来介绍如何创建评分卡及遇到的问题。
一、数据准备 因为不同评级模型所需要的数据也是不同的，所以在开发信用评级模型之前，要先明确我们需要解决的问题。
1.1 排除一些特定的建模客户
用于建模的客户或者申请者必须是日常审批过程中接触到的，需要排除异常情况。如 欺诈，特殊客户。
1.2 明确客户属性
根据不同的数据来源，可以分为以下几类：
人口统计特征：客户的基本特征，如性别，年龄、居住情况、年收入等征信机构数据和外部评分:如人行征信报告、芝麻分等。其他数据来源。 1.3 目标变量的确立
预测模型的一个基本原理是用历史数据来预测未来，申请者评分模型需要解决的问题是未来一段时间（如12个月）客户出现违约（如至少一次90天或90天以上逾期）的概率。先将客户标签定义为二分类，不良/逾期：观察窗口内，观察窗口内，60/90/120天算逾期日期；良好:从未或截止逾期；从未或在观察期内截止逾期
其中关于不良/逾期需要界定以下两项内容：确定违约日期时长、观察窗口期设置。
定违约日期时长，违约时长的确定可以使用逾期转移矩阵来确定，也可以按客户规则确定：
通过上图可以看出来，M3客户变坏的概率为93%.也就是说当客户逾期超过60天后，被催回的几率为7%。因此，可以定义逾期超过60天的客户为坏客户。
二、特征工程 数据准备和数据预处理阶段消耗大量的时间，主要的工作包括数据获取、探索性数据分析、缺失值处理、数据校准、数据抽样、数据转换、离散变量降维、连续变量优先分段等工作。
在评分卡模型中特别要做的是变量分箱和自变量WOE编码。
变量分箱主要指的是连续型变量化为离散型变量，为WOE编码做准备。这样做会有信息损失，但相比信息损失，过拟合带来的影响更大。
2.1 WOE和IV公式 Q1：什么是IV和WOE编码？
WOE全称是Weight of Evidence，即证据权重，也叫作自变量的一种编码。
IV全称是Information value，可通过woe加权求和得到，衡量自变量对因变量的预测能力。
要对一个变量进行WOE编码，需要首先把这个变量进行分组处理（也叫离散化、分箱等等，说的都是一个意思）。分组后，对于第i组，WOE的计算公式如下：
其中，pyi是这个组中响应客户（风险模型中，对应的是违约客户，总之，指的是模型中预测变量取值为“是”或者说1的个体）占所有样本中所有响应客户的比例，pni是这个组中未响应客户占样本中所有未响应客户的比例，#yi是这个组中响应客户的数量，#ni是这个组中未响应客户的数量，#yT是样本中所有响应客户的数量，#nT是样本中所有未响应客户的数量。
从这个公式中我们可以体会到，WOE表示的实际上是“当前分组中响应客户占所有响应客户的比例”和“当前分组中没有响应的客户占所有没有响应的客户的比例”的差异。
对这个公式做一个简单变换，可以得到：
变换以后我们可以看出，WOE也可以这么理解，他表示的是当前这个组中响应的客户和未响应客户的比值，和所有样本中这个比值的差异。这个差异是用这两个比值的比值，再取对数来表示的。WOE越大，这种差异越大，这个分组里的样本响应的可能性就越大，WOE越小，差异越小，这个分组里的样本响应的可能性就越小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1b931ab6fc8167e2d611c024e13bd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85325649d7ffe274a13ccef3f175c425/" rel="bookmark">
			【深度学习】介绍六大类损失函数（九）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 损失函数Pixel-wise LossMSE 均方误差MAE 平均绝对误差CE 交叉熵损失 Perceputal LossContent-Style LossTexture LossTopological Perceputal LossGAN LossMin-Max 损失函数不饱和的GAN损失最小均方GAN损失Wasserstein GAN损失循环一致性损失 总结 写在最前面的话：本文主要整理深度学习中的损失函数，从原理到作用，详细了解损失函数。
损失函数 损失函数（loss function） 是用来评估模型的预测值f(x)与真实值y的不一致程度，它是一个非负值，常用符号 L ( f ( x ) , y ) L(f(x), y) L(f(x),y)表示。损失函数在模型的性能中起关键作用，选择正确的损失函数能帮助模型在数据集中获得最优最快的收敛，起到指导模型学习的作用。它的值越小，说明模型的鲁棒性越好。损失函数是经验风险函数的核心部分，也是结构风险函数的重要组成部分。模型的结构风险函数包括了经验风险项和正则项，通常可以表示为：
θ ∗ = arg min ⁡ θ 1 N ∑ i = 1 N L ( f ( x i ; θ ) , y i ) + λ Φ ( θ ) \theta^*=\argmin_\theta \frac1N\sum_{i=1}^NL(f(x_i;\theta), y_i)+\lambda\Phi(\theta) θ∗=θargmin​N1​i=1∑N​L(f(xi​;θ),yi​)+λΦ(θ)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85325649d7ffe274a13ccef3f175c425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5e6ba92bc9b69e45799f551d98e6d0/" rel="bookmark">
			【JetPack】为现有 Android 项目配置视图绑定 ( ViewBinding ) 模块 ( 视图绑定不影响传统布局操作 | 视图绑定类关联 Activity | 视图绑定类本质 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 I . 为现有项目配置 视图绑定 ( ViewBinding ) 应用II . 视图绑定 ( ViewBinding ) 定制III . 视图绑定 ( ViewBinding ) 对于正常操作的影响测试IV . 视图绑定 ( ViewBinding ) 关联 Activity 界面V . 视图绑定 ( ViewBinding ) 本质分析VI . GitHub 代码地址 I . 为现有项目配置 视图绑定 ( ViewBinding ) 应用 1 . 视图绑定模块默认为全部布局生成绑定类 ; 视图绑定 ( ViewBinding ) 模块一旦启用 , 应用的全部布局都会默认自动生成一个视图绑定类 , 如果生成了视图绑定模块 , 是否对于已经使用的 findViewById 或者 @BindView @BindViews 代码是否有影响 ;
2 . Android 项目中布局文件数量比较大 ; 现在的 Android 项目如果比较大 , 布局文件可能存在上百个 , Activity , Fragment , 自定义布局的 Dialog , 自定义 View 组件 , RecyclerView 列表条目 item 布局 , 这些都要使用到布局文件 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5e6ba92bc9b69e45799f551d98e6d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8da056855abc30ffab5b45993d369d/" rel="bookmark">
			GIS：谈谈叠加分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：叠加分析，也叫叠置分析(Overlay)，是GIS空间分析的核心，有着很重要的地位，本文主要引入GIS叠加分析的概念，分享了一些个人的思考，介绍了叠加分析的分类，以及叠加分析的基本方法，侧重理论知识的介绍。欢迎交流。
文章地址：
https://mp.weixin.qq.com/s/1exOeGmxaqt2l6mpvM_2Xg
推荐下公众号，后续主要更新开源GIS相关知识技能，包括PostgreSQL、PostGIS、Geoserver等，欢迎有兴趣同学关注学习交流
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c899f3619910d9ac07e0affe2ef62a00/" rel="bookmark">
			小程序中placeholder-class和placeholder-style的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义placeholder颜色和样式 如图，这是微信小程序input组件的官方文档描述，下图红框里的placeholder-style和placeholder-class就是微信小程序里用来给placeholder设置样式的属性。
如图可知，小程序为我们提供了两种修改input中placeholder的方法。
两者的区别
在项目使用过程中起初我以为两种属性只是区别于形式功能是一样的，但后来发现并不相同。
**区别一：**placeholder-style可以设置字体颜色，但是placeholder-class不可以。
**区别二：**如果你的小程序要适配平板，把font-size写在placeholder-style中，你会发现placeholder的字体并没有随屏幕的比例变大。把font-size写在placeholder-class上则是正常比例。
总结
placeholder-style适合设置颜色，placeholder-class适合设置字体。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316983bc02870c1c5521695078ef7fee/" rel="bookmark">
			PostGIS 缓冲区分析（查询距离范围内要素）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：
遇到个需求：需要查询事发点周围100米内的人和车，这个通过PostGIS的ST_DWithin函数很容易实现。
但是在实现过程中，遇到了三个不同的问题，在此总结一下。
解决方案：
方案一：
这种方式适用于PostGIS库，在库里直接写SQL实现，入参直接可以用PostGIS的geometry格式。
--调用方式（参数：表名，坐标系id，表主键ID，缓冲区半径，中心点）
select * from enc_buffer_bygeom('fm',3857,'gid',100,'0101000020110F0000F2D24D3662CA6841480C02EB46545241');
函数如下：
-- FUNCTION: public.func_buffer_bygeom(character varying, integer, character varying, double precision, character varying)
-- DROP FUNCTION public.func_buffer_bygeom(character varying, integer, character varying, double precision, character varying);
CREATE OR REPLACE FUNCTION public.func_buffer_bygeom(
tb character varying,
qsrid integer,
qid character varying,
qbuffer double precision,
qgeom character varying)
RETURNS TABLE(v_gid integer, v_res geometry, v_dis double precision) LANGUAGE 'plpgsql'
COST 100
VOLATILE STRICT ROWS 1000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316983bc02870c1c5521695078ef7fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d265a50b33498f75e74b0c983a8874b1/" rel="bookmark">
			如何根据笔记本CPU选取合适内存条总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、内存条频率和大小的获取 在升级笔记本的内存条时，我们首先需要了解自身原装笔记本的内存条大小和频率。一般来讲选取同品牌同大小同频率的内存条最为合适。如果大小不同，会兼容性能低的，如4G+8G运行，效果是等同于4G+4G；频率是2400+2600则等效于两个2400。最好不要选取不同频率的内存，容易发生读取错误。
获取内存条信息
1、通过管家或鲁大师查询 2、通过cpu-z查询 其中cpu-z内存选项显示的是电脑运行时的频率，spd中显示的是内存条允许的最大频率。这里我的电脑显示2400是因为我的cpu的原因，具体见后面。2666才是我内存条的实际允许频率。
3、通过内存条实际物理参数获取 这里我的内存条实际就时8G+2666
2、笔记本cpu支持的频率信息获取 我的笔记本是拯救者R720，cpu是Intel Core i5-7300HQ。见下图cpu的参数可知该cpu支持的内存频率最大是DDR4-2400。与电脑软件检测的实际过程中的频率相符。所以2666的内存条受cpu的限制只能发挥2400的性能
3、综合考虑选择内存条 遵循同大小同频率的原则，选取8G+2666的大牌厂商的笔记本内存条即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9426921c8077765707ef3e6327b7d495/" rel="bookmark">
			Linux系统配置网卡ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里我采用修改网络配置文件的方式配置网卡的ip地址，网络服务重启ip地址也不会丢失
1.进入到网络配置文件目录/etc/sysconfig/network-scripts，这里可以看到以ifcfg-开头的文件
2.打开配置文件为网卡enp0s3配置一些ip相关信息，保存文件退出
相关配置说明如下：
TYPE=Ethernet ##网卡类型为以太网 NAME=enp0s3 ##指定网络链接的名字为eth0，个人习惯，开心就好 DEVICE=enp0s3 ##指定文件管理的网卡名称 BOOTPROTO=static ##ip是否动态获取：dhcp动态获取，none和static表示静态网络 ONBOOT=yes ##是否开机启动 IPADDR=192.168.1.110	##设定ip为192.168.1.110 NETMASK=255.255.255.0	##子网掩码 GATEWAY=192.168.1.1	##网关地址 DNS1=114.114.114.114	##DNS地址，如需域名解析需要设置 DNS2=8.8.8.8 3.重启网络服务，或者重启单个网卡
#重启网络服务，下面的两个语句都可以
[root@localhost ~]#service network restart
[root@localhost ~]#systemctl restart network
#重启单个网卡
[root@localhost ~]#ifdown enp0s3
[root@localhost ~]#ifup enp0s3
4.最后查看网卡ip地址
[root@localhost ~]# ip addr show enp0s3
到此网卡的ip配置完成了，有时我们想要临时配ip地址，可以使用ifconfig命令进行设置
ifconfig enp0s3 192.168.1.110 netmask 255.255.255.0 ------------------------------------------------------------------------------------------------------------------------------------------------------------
其他相关
查看DNS配置
[root@localhost /]# cat /etc/resolv.conf
centos关闭防火墙的方法：
#查看防火墙状态：
systemctl status firewalld.service
#关闭防火墙：
systemctl stop firewalld
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9426921c8077765707ef3e6327b7d495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ad3158500f6de269b502e11cb40a4c/" rel="bookmark">
			QPSK调制解调原理（IQ调制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QPSK调制解调原理（IQ调制） QPSK调制过程 QPSK调制星座图 参考链接：https://www.zhihu.com/question/23107539/answer/72521819?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=736516591579037696
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ff7ba19481c9d5bec001418aebd3a3/" rel="bookmark">
			用“易于改编”原则，提升编程水平，写出更好的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论新手还是资深开发者都会经常问一个问题，“怎么写好的代码？”，要知道怎么写好代码，首先我们要知道怎么样才是好的代码。要有明确的目标，才能知道如何达成目标。在《程序员修炼之道》中提到的“ETC Principle” -- 易于改编原则。这个原则看似简单，但是我们越是深入思考越是觉得“简约而不简单”。
这篇文章里会详细解刨在实际产品研发中“易于改编”的原因和怎么做到“易于改编”， 从而让我们编写出更好的代码。
文章目录 「一」程序为何需要“易于改编”？需求会变“可快速更变”是一个软件的核心 「二」如何做到“易于改编”？模块设计 ---「Modular Design」设计思路前端模块设计页 (排) 面 (版) 的模块设计前端逻辑模块设计 解耦 - 「Decoupling」服务化 --- 「Service」理解服务编写思路 总结推荐阅读 「一」程序为何需要“易于改编”？ 为何代码必须要易于改编？因为一个系统是会随着一个产品的发展，每日有用户增长就会有一直做不完的需求。只要公司一直在运营着这个产品，需求就会随着公司的发展而改变。只要我们开发者一直与时并进专研新技术，我们就需要一直升级优化。
只有了解清楚一个系统在一个生命周期中，具体什么会推动我们程序改变，从中我们才会更深刻明白为什么我们的代码需要”易于改编“。
需求会变 无论我们是研发任何系统，产品需求都是会一直变的。这个是永恒不变的命运。为什么呢？
产品方向 — 随着产品的营销，运营，发展会推动产品需求一直新增，修改，优化。使用量 — 随着产品的用户量级，数据量级，并发量级也会推动程序的架构和策略上的变动。技术升级优化 — 甚至是我们使用的语言，框架，依赖包等升级也会引起我们的代码需要适应。技术债 — 可能是因为时间的限制，之前的代码重于实现而质量不佳。 所以我们的代码会随着岁月的流逝一直在迭代升级优化。
“可快速更变”是一个软件的核心 近几年很多技术团队启用了敏捷迭代开发模式。什么是敏捷迭代呢？
敏捷迭代就是把开发周期缩短到1-4周。小步快跑的迅速迭代交付功能上线。敏捷迭代的流程分别如下：
确定需求 - 与老板和市场确认需求和流程需求评审 - 与开发同频需求里面的功能点和业务流程技术反讲 - 开发与产品同频需求，保证双方理解无误区，开发也需要评估开发难度和开发时间研发周期 - 开发人员开始投入研发直接到功能和需求开发完毕，转交给测试，在测试环境提测测试周期 - 测试和开发人员开始排除缺陷，修复所有在开发过程产生的bug验收/预发布周期 - 当测试在测试环境把所有bug排除掉后，当前迭代版本就会发布到预发布环境让市场和产品验收功能发布正式 - 当验收通过后，当前迭代版本就可以部署上线到正式环境正式回归测试 - 发布上线后，就会有正式回归测试，最后一道防线，保证系统加入的所有新功能都无问题迭代总结 - 每一期迭代结束后都总结这次迭代遇到的问题，持续优化，提高效率 你想想如果一个APP或者系统，几个月甚至一年才更新一次功能和升级。我们用起来其实很枯燥的，甚至我们会发现很多问题，还有很多功能可以便捷或者提升我们的使用体验。但是这么久才更新一次，我们还会对这个产品抱有希望吗？（除了微信这种已经很成熟的应用，但是就算是微信也是有持续更新的）。
所以一个好的产品，是需要快速迭代，小步快跑的迅速迭代交付功能上线的。也是因为这样，功能就需要持续更新、升级和优化。自然我们研发的代码就需要一直随着产品的变化而改编。而且还是每1-4周就会升级优化一次。
🏆小总结一下：
一个系统会随着产品的发展和迭代，一直走在改变和更新的道路上。因为系统一直在变，代码就需要响应系统的变化，持续的快速迭代升级优化。既然代码需要快速的更变和升级，那程序的“易于改编”性就必须要高。 「二」如何做到“易于改编”？ 我们深刻懂得为什么系统会一直在改变，那我们就要知道怎么写代码才能让一个程序“易于改编”，然而在敏捷迭代中才能快速的响应需求的变化。如果想让我们编写的程序更容易的响应需求改变、业务改变和逻辑改变等，我们就要充分的给我们的程序解刨逻辑。
说到逻辑与业务的分解，首先要根据需求和功能深入思考分析，然后对其进行一个架构的设计。最常用的方式就是把系统模块化，组件化等的系统架构设计。
模块设计 —「Modular Design」 模块设计，就是以功能块为单位进行程序设计，实现其求解算法的方法称为模块化。模块化的目的是为了降低程序复杂度，使程序设计、调试和维护等操作简单化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61ff7ba19481c9d5bec001418aebd3a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad33573a5a8d8783dde8a2d95c63ab7/" rel="bookmark">
			Java Swing 进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Swing 进度条1. 应用：使用进度条 Swing 进度条 利用 JProgressBar 类可以创建进度条。进度条本质是就是一个矩形组件，通过填充它的一部分或者全部来指示一个任务的具体执行情况；默认情况下，要确保既定任务的执行进度和进度条的填充区域成正比关系，如果并不确定任务的执行进度，则可以通过调用方法 setIndeterminate( boolean b) 来设置进度条的样式。设置为 true，表示不确定任务的执行进度，填充区域会来回滚动；设置为 false 则表示确定任务的执行进度；一般来说，在进度条中不显示提示信息，可以调用 setStringPainted(boolean b) 来设置是否显示提示信息，true 表示显示信息，false 表示不显示信息。如果是将确定进度的进度条设置为显示信息，默认为当前任务完成的百分比，也可以通过方法 setString(String s) 设置指定的提示信息；如果将不确定进度的进度条设置为显示提示信息，则必须设置指定的提示信息，否则将出现填充面积和进度提示信息不匹配的不正确效果；如果采用确定进度的进度条，进度条并不能自动获取任务的执行速度，不需通过方法 setValue(int n) 反复修改当前的执行速度，例如将入口参数设置为 88，则将显示为 88%；如果采用不确定进度的进度条，则需要在任务执行完成后将其设置为采用确定进度的进度条，并将任务的执行进度设置为 100%，或者是设置指定的提示已完成的信息； 1. 应用：使用进度条 import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class Test extends JFrame { public static void main(String args[]) { Test frame = new Test(); frame.setVisible(true); } public Test() { super(); getContentPane().setLayout(new GridBagLayout()); setTitle("Regino"); setBounds(100, 100, 500, 375); setBounds(100, 100, 266, 132); setDefaultCloseOperation(JFrame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad33573a5a8d8783dde8a2d95c63ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433fcf553131497e65a809212e0956be/" rel="bookmark">
			QT压缩和解压ZIP学习笔记二：编译quazip 32位和64位dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 QuaZIP是使用Qt/C++对ZLIB进行简单封装的用于压缩及解压缩ZIP的开源库。适用于多种平台，利用它可以很方便的将单个或多个文件打包为zip文件，且打包后的zip文件可以通过其它工具打开。
QuaZIP下载： https://github.com/stachenov/quazip
ZLIB编译方法： https://blog.csdn.net/yxy244/article/details/105024989
编译小知识： QT编译要注意编译器MinGW和MSVC链接上有点不同：
在MSVC下编程，当要使用DLL动态库文件时，必须要有导入库.lib文件才能编译链接通过。
在MinGW下编程，既可以与导入库.lib链接，也可以直接与.dll动态库链接。在大多数情况下，.MinGW的导入库.dll.a文件不起作用，这称为Direct linking to a dll技术。
二、编译QuaZIP 1.quazip目录下新建一个lib文件夹，把编译好的zlib动态库和导入库复制过来，这里有几点注意：
（1）如果开发的是32位应用程序，那就复制32位zlib1.dll和lib；开发64位程序就复制64位的dll，编译32位和64位的zlib方法上面的链接有。
（2）如果用MinGW编译器，那么前面的编译知识就知道了，链接dll或lib都可以；但是用MSVC编译器，只能用zdll.lib导入库，而不能直接用dll。这里两个都复制过来，其实只复制lib也可以。
2.quazip目录下新建一个include文件夹，复制zlib的头文件过来
3.打开quazip工程，在.pro文件文件里找到win32，在最后添加头文件和库文件路径：
LIBS += -L$$PWD/lib/ -lzdll INCLUDEPATH += $$PWD/include 注意网上有的教程是链接到zlib1.dll，如果这么写，一定要用MinGW编译才能通过的哦。
LIBS += -L$$PWD/lib -lzlib1 INCLUDEPATH += $$PWD/include 4. Debug和Release都编译一下，就会得到quazip的动态库和它的导入库了
二、测试例程 1.新建一个QT工程，在工程目录下新建文件夹lib，复制quazip的导入库进来
2.工程目录下新建一个include文件夹，将quazip和zlib的头文件都复制过来
3. pro文件里添加头文件和库文件路径：
CONFIG(release, debug|release): LIBS += -L$$PWD/lib -lquazip CONFIG(debug, debug|release): LIBS += -L$$PWD/lib -lquazipd INCLUDEPATH += $$PWD/include 4.测试代码
#include "JlCompress.h"
static bool compressDir(QString fileCompressed, QString dir=QString(), bool recursive = true)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/433fcf553131497e65a809212e0956be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7626039a5e574f88f7c390724cfd7437/" rel="bookmark">
			你真的会在Linux系统安装应用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 近来使用linux系统已久，但是有时候要安装软件时都是打开浏览器，输入：怎么样在linux上安装XXXX，对此颇感无奈，没办法，linux不像windows，直接下载然后鼠标点点点一步到底。因此，本篇文章将讲述如何一步一步在linux上安装软件，这里不是某个软件怎么安装的命令，而是通用的安装方法，从根本上解决问题才是我们应该做的。
命令 &amp;&amp; 工具 linux系统yum，wget，tar，cd ，vi，make 步骤 本次以安装python3.7为例，由于我安装的是有图形界面的，但不碍事，我们全是在命令行界面操作
首先我的系统是运行在虚拟机上的全新Red Hat，啥都没有，所以我们查看是否有wget，出现下面界面说明有，没有首先就下载wget，该命令具体操作自行百度。然后我们用wget去python官网直接获取下载链接然后获得下载。 wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz 下载位置自己指定，下载好后我们就可以在指定路径下上看到该文件了。第二步我们进去安装包里看看有什么，一般我们就想，进入不就是 cd 嘛，可事实不是哟，该文件为压缩包，而不是文件夹，从文件后缀名我们就可以看到要用的命令是啥了，tar xf Python-3.7.0.tar.xz ，该命令是解压并撕毁该文件，然后我们就可以看到当前目录下有该文件包了。 解开之后我们进到该文件的目录，这回就是cd了，我们看一下该文件夹下有什么，其实就是该文件的源码。 我们可以看到该文件下有个README.rst，这不就很清晰了嘛，三年级英语水平的我都能知道这叫啥，readme不就是读我嘛，读我，读我，快读我，多诱惑啊，好了，我们就来看一下里面有啥。命令就是 vi README.rst 偶买噶，一堆令人头大的英文。不过没关系，我们不就是要编译安装嘛，我们按回车往下走走看。 哎，来了来了，三年级水平的我看到了Build这个东西，这不就是编译安装的意思吗，好了我们看下命令。 On Unix, Linux, BSD, macOS, and Cygwin:: ./configure make make test sudo make install 我们退出来试试第一个命令，他还有个参数./configure --prefix=/opt/python36 # 指定安装目录为/opt/python36，这里我就使用默认的了，直接./configure。 上图可以看到creating Makefile，那么我们来执行第二个命令试试。make。这里仿佛过了一个世纪，足足17分钟。 好了，我们进行第三个命令试试。make test。380个test通过，有几个错误，我们不管它，直接第三个命令。第三命令。 sudo make install。哦吼，出错了。没关系，我们看看啥问题。zlib not available，应该是没这个东西，我们百度一下。 安装zilb，然后重新执行，sudo make install，完成。 Collecting setuptools Collecting pip Installing collected packages: setuptools, pip Successfully installed 后记 好了，到此我们就完成了一个应用的安装啦，其实总结下来大部分应用安装也没多少步骤，下载包，解压撕毁，进入包查看README，查看安装命令，执行命令，最后看能否成功，有错就去查错，毕竟学习路上总是充满坎坷不是吗？ 其实嫌麻烦的话直接百度查看大神们怎么安装的也不是一个错误，竟毕重复造轮子不是我们提倡的，不过，最基本的我们还是要懂一点，哪怕就一点点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d50afc3489b81a636faba07d4f3fb3/" rel="bookmark">
			设计模式之一——Adapter模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在看23种设计模式之前，我们首先了解一下设计原则。
面向对象的设计原则有以下8个：
1.依赖倒置原则
高层模块（稳定）不应依赖于低层模块（变化），二者都应该依赖于抽象（稳定）；抽象（稳定）不应依赖于实现细节（变化）。
2.开放封闭原则
对扩展开放，对过呢更改封闭。类模块应该是可扩展的，但是不可修改。
3.单一职责原则
一个类应该仅有一个引起它变化的原因。
4.替换原则
子类必须能够替换它们的基类（is-a）。
5.接口隔离原则
6.优先使用对象组合，而不是类继承
7.封装变化点
8.针对接口编程，而不是针对实现编程
减少各部分的依赖关系，实现“高内聚、低耦合”。
综上我们可以总结为：
由静态——到动态
由早绑定——到晚绑定
由继承——到组合
由编译时依赖——到运行时依赖
由紧耦合——到松耦合
接下来我们来看Adapt模式：
Adapter模式其实就是将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能在在一起工作的那些类可以一起工作。
在代码的实现中，我们常常希望旧的接口不要改动，又能适应新的目标接口。其中适配器有两种：类适配器和对象适配器。类适配器采用多继承的方法，一般不推荐，它不具有灵活性；对象适配器采用对象组合的方法，比较常用。
下面我们采用对象适配器的方法进行一个举例：
一、首先第一步建一个 ITarget的类，是我们的新接口，itarget.h如下：
#ifndef ITARGET_H #define ITARGET_H //目标接口(新接口) class ITarget { public: ITarget(); virtual void request(); }; #endif // ITARGET_H itarget.cpp如下：
#include "itarget.h" #include &lt;QDebug&gt; ITarget::ITarget() { } void ITarget::request() { qDebug()&lt;&lt;"目标接口"; } 二、然后建一个 IAdaptee的类，是我们要适配的旧接口，iadaptee.h如下：
#ifndef IADAPTEE_H #define IADAPTEE_H class IAdaptee { public: IAdaptee(); virtual void specificRequest();//旧接口 }; class IAdapteeA:public IAdaptee //因为旧接口不一定只有一个类，可能还有一些继承于旧接口的多种类 { public: virtual void specificRequest(); }; class IAdapteeB:public IAdaptee { public: virtual void specificRequest(); }; #endif // IADAPTEE_H iadaptee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d50afc3489b81a636faba07d4f3fb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a09d5995cf3a185c5fb3b3c668915425/" rel="bookmark">
			Android SELinux avc dennied权限问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述
SELinux是Google从android 5.0开始，强制引入的一套非常严格的权限管理机制，主要用于增强系统的安全性。
然而，在开发中，我们经常会遇到由于SELinux造成的各种权限不足，即使拥有“万能的root权限”，也不能获取全部的权限。本文旨在结合具体案例，讲解如何根据log来快速解决90%的SELinux权限问题。
2. 调试确认SELinux问题 为了澄清是否因为SELinux导致的问题，可先执行：
setenforce 0 （临时禁用掉SELinux）
getenforce （得到结果为Permissive）
如果问题消失了，基本可以确认是SELinux造成的权限问题，需要通过正规的方式来解决权限问题。
遇到权限问题，在logcat或者kernel的log中一定会打印avc denied提示缺少什么权限，可以通过命令过滤出所有的avc denied，再根据这些log各个击破：
cat /proc/kmsg | grep avc 或
dmesg | grep avc
例如：
audit(0.0:67): avc: denied { write } for path="/dev/block/vold/93:96" dev="tmpfs" ino=1263 scontext=u:r:kernel:s0 tcontext=u:object_r:block_device:s0 tclass=blk_file permissive=0
可以看到有avc denied，且最后有permissive=0，表示不允许。
3. 具体案例分析 解决原则是：缺什么权限补什么，一步一步补到没有avc denied为止。
解决权限问题需要修改的权限文件如下位置，以.te结尾
A：Android/devicesoftwinner/astar-common/sepolicy/*.te
B：Android/external/sepolicy/*.te
其中，A是对B的overlay（覆盖），能在A修改的尽量在A修改，尽量避免修改B，修改B可能会导致CTS fail问题，修改A不会影响CTS测试。
（如果不需要深入了解，请直接跳到万能公式这一章阅读更简洁）
下面给出四个案例：
案例1
audit(0.0:67): avc: denied { write } for path="/dev/block/vold/93:96" dev="tmpfs" ino=/1263 scontext=u:r:kernel:s0 tcontext=u:object_r:block_device:s0 tclass=blk_file permissive=0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a09d5995cf3a185c5fb3b3c668915425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc9352be649bd1ff5ea1db9778adc1a/" rel="bookmark">
			Python之format用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python之format用法详解 一、填充 1.无参（1） print('{} {}'.format('hello','world')) hello world
2.无参（2） print('{0} {1}'.format('hello','world')) hello world
3.无参（3） print('{1} {0} {1}'.format('hello','world')) world hello world
4.key value print('ID:{id},Name:{name}'.format(id='001',name='hello')) ID:001,Name:hello
5.列表 list=['001','hello'] print('ID:{List[0]},Name:{List[1]}'.format(List = list)) print('ID:{0[0]},Name:{0[1]}'.format(list)) ID:001,Name:hello
ID:001,Name:hello
6.字典 dict={'id':'001,'name':'hello'} print('ID:{Dict[0]},Name:{Dict[1]}'.format(Dict = dict)) print('ID:{id},Name:{name}'.format(**dict)) ID:001,Name:hello
ID:001,Name:hello
7.类 class value(): id = '001' name = 'hello' print('ID:{Value.id},Name{Value.name}'.format(Value = value)) ID:001,Name:hello
8.魔法参数 *args表示任何多个无名参数，它是一个tuple or list；**kwargs表示关键字参数，它是一个 dict。
args = [',','.'] kwargs = {'id': '001','name':'hello'} print('ID:{id}{}Name:{name}{}'.format(*args, **kwargs)) ID:001,Name:hello.
二、数字格式化 数字格式输出描述3.1415926{:.2f}3.14保留小数点后两位3.1415926{:+.2f}+3.14带符号保留小数点后两位-1{:+.2f}-1.00带符号保留小数点后两位2.71828{:.0f}3不带小数5{:0&gt;2d}05数字补零 (填充左边, 宽度为2)5{:x&lt;4d}5xxx )数字补x (填充右边, 宽度为410{:x&lt;4d}10xx )数字补x (填充右边, 宽度为41000000{:,}1,000,000以逗号分隔的数字格式0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bc9352be649bd1ff5ea1db9778adc1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/122f1becabc97a021df26936321c3c26/" rel="bookmark">
			整合支付宝和微信支付的(h5)支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 整合支付宝和微信支付的springboot demo(h5)支付，支付宝已经测通，微信因为账号原因暂时没法测
https://gitee.com/jiandandian111/pay?_from=gitee_search 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdcb4667963e9e50f1cd02f46c61985c/" rel="bookmark">
			eclipse新建项目后add libraries的按钮全都是灰色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现全是灰的，点击不了。。。。
这个问题其实非常搞笑
只是因为没有点击相应的地方，比如Modulepath或者Classpath，把鼠标点击上去就可以正常加了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72ed69479abb88993c21ac92c46a00e/" rel="bookmark">
			“程序猿”的等级划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“程序猿”的等级划分 “程序猿”大致可分为
菜鸟程序员、码农、程序员、成功的程序员、著名程序员 和 顶级程序员……
1菜鸟程序员 之所以称这类程序猿为菜鸟程序员，是因为他们的技术比较渣（当然我现在菜鸟都算不上）。在工作中，他们往往会给自己的团队带来许多压力，他们编程简直是把大量的bug放入到程序中，而团队要帮他大量地去找bug，改掉bug；即使这样，他们在编写比较简单的程序中也为团队节省了不少时间。
2 码农 码农是一个比较平凡的群体，更多的时候是拷贝代码。
他们是无名程序员，典型的程序员大众。虽然他们终日兢兢业业，在编写代码上花费了许多时间和精力，但在工作中他们只知道怎样完成任务，却不去思考原理，所以，他们在技术上进步非常慢。显然，他们的工资也没有程序员高。
3 程序员 程序员又可分为 普通程序员 和 有工作能力的程序员
普通程序员：处于这个等级的程序猿已经是个非常不错的的程序员（目前我的目标就是希望通过自己的努力以后能够成为这样的程序猿），这类人有自知之明，认识到自己不是个优秀程序员， 也许永远也不是，但他们仍然坚持努力着。
我认为，一个人一定要认清现实，根据自身状况，利用好自己的长处，向着自己的目标不断努力着，或许，有一天你会有所突破。
星光不问赶路人，时光不负有心人
有工作能力的程序员：这类程序员他们的技术水平比较高，有许多项目开发经验。能够在职业上创造出成功的产品。
最后还有这么一些爱好者
业余程序员
他们大都是因为对某些程序或者网站感兴趣，他们会在业余时间开发有趣的“只是为了好玩”的程序或网站。由于他们的程序和想法展现出一种热情和希望。所以，这个级别的人能很快成为一名有工作能力的程序员。
4 成功的程序员 有一定的知名度，通过自己的代码创建了公司。这是大多数程序员都向往渴望的级别。达到这种级别通常更多的是依靠商业技巧，而不是单单靠编程。
5 著名程序员 这类程序员有着过人的技术并且具备极强的商业头脑，他们的出现改变了一个国家人民的学习，工作和生活方式，甚至世界IT界的发展趋势。
比如国内的各大创业大佬，金山创始人求伯君、360创始人周鸿袆、百度创始人李彦宏……
比如扎克伯格创造了Facebook、比尔盖茨创造了微软、雷军创造了小米公司……
6 顶级程序员 他们用自己独特的思维和技能，创造了世界奇迹——计算机时代
计算机从这里开始……
图灵、冯诺依曼和香农
香农（克劳德·艾尔伍德·香农，Claude Elwood Shannon ，1916年4月30日—2001年2月24日）是美国数学家、信息论的创始人。主要论文有：1938年的硕士论文《继电器与开关电路的符号分析》，1948年的《通讯的数学原理》和1949年的《噪声下的通信》。
图灵（艾伦·麦席森·图灵 Alan Mathison Turing 1912年6月23日—1954年6月7日）英国数学家、逻辑学家，被称为计算机科学之父，人工智能之父。
主要成就：图灵在科学、特别在数理逻辑和计算机科学方面，他的一些科学成果，构成了现代计算机技术的基础。
冯诺依曼（John von Neumann，1903年12月28日-1957年2月8日）美籍匈牙利数学家、计算机科学家、物理学家，在现代计算机、博弈论、核武器（冯·诺依曼第二次世界大战期间曾参与曼哈顿计划，为第一颗原子弹的研制作出了贡献。）和生化武器等领域内的科学全才之一，被后人称为“现代计算机之父”、“博弈论之父”。
除了这三位创始性代表人物，还有 ：
丹尼斯·里奇（Dennis Ritchie）——“C语言之父”，“UNIX之父”，开创了计算机网络技术的先河，1978年与布莱恩科尔尼干（BrianW Kernighan）一起出版了名著《C程序设计语言》，被翻译为多种语言，是C语言方面最权威的教材之一。
Bjarne Stroustrup（本贾尼·斯特劳斯特卢普）——C++
高斯林（James Gosling）——JAVA
Guido van Rossum（吉多·范罗苏姆）——Python
Rasmus Lerdorf（拉斯马斯·勒德尔夫）——PHP
Niklaus Wirth（尼克劳斯·威茨）——程序=算法+数据结构
…………………………
他们不仅仅创造了语言，而且改变了人们的生活方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f72ed69479abb88993c21ac92c46a00e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4946e3070f3525456bb8601a3514544a/" rel="bookmark">
			第六章 异常机制（尚学堂java300集笔记，含自写编程题答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第六章 异常机制 DAY16 Java是采用面向对象的方式来处理异常的。处理过程：
抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。 异常分类
Error表明系统JVM已经处于不可恢复的崩溃状态中，我们不需要管它。例如，Java虚拟机运行错误(Virtual MachineError)，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。Exception是程序本身能够处理的异常，如：空指针异常(NullPointerException)、数组下标越界异常(ArrayIndexOutOfBoundsException)、类型转换异常(ClassCastException)、算术异常(ArithmeticException)等。 CheckedException已检查异常(编译器异常)，处理方式有两种：使用“try/catch”捕获异常、使用“throws”声明异常
捕获异常是通过3个关键词来实现的：try-catch-finally
子类异常在父类异常前面
即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出
finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行
方法重写中声明异常原则：子类声明的异常范围不能超过父类声明的范围
自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类
作业 一、1.DC（try语句中没有异常，输出“try”,即使try和catch块中存在return语句，finally语句也会执行） 2.C 3.DAC（1处 应为throws，3处应为throw） 4.BC 5.B
三、
package cn.sxt.oo; import java.util.Scanner; public class Test1 { public static void main(String[] args) { System.out.println("输入分数："); Scanner scanner = new Scanner(System.in); int scr = scanner.nextInt(); Scour scour = new Scour(); scour.setScour(scr); scour.getScour(); } } class Scour { private int scour; public int getScour() { if(scour&gt;=0&amp;&amp;scour&lt;=100) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4946e3070f3525456bb8601a3514544a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d820d13570a4b13a35658ffe3ef2f068/" rel="bookmark">
			微信、支付宝、银联支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.微信支付 1.1 了解微信支付相关基础知识
参考地址：
https://pay.weixin.qq.com/wiki/doc/apiv3/wxpay/pages/ico-guide/chapter1_1.shtml
1.1.1 理解三种账号：
公众平台：服务号、订阅号，统称公众号，和小程序。
商户平台：微信支付。
开放平台：APP、网站、公众号（服务号、订阅号）。
1.1.2 设置相关参数
API密钥（KEY）：用于接口API的签名计算。
APIv3密钥：在微信支付接口V3版本，为了保证安全性，微信支付在回调通知和平台证书下载接口中，对关键信息进行了AES-256-GCM加密。API v3密钥是解密时使用的对称密钥。
支付目录：JSAPI支付（公众号支付）、H5支付都要求发起支付请求的页面域名必须在商户平台配置后才可正常调用微信支付
授权域名：获取用户身份标识openid时，要求请求来源域名必须在公众平台配置过，才被允许获取用户身份标识openid
1.1.3 下载证书
api证书：微信退款的时候会用到
1.1.4 两种模式
普通商户：信息、资金流：微信支付—&gt;直连商户
普通服务商：服务商下可签约特约商户、资金流直接到商户，服务商可以参与分成
1.2 了解微信支付产品
了解完这些可以再了解一下微信的几种方式来确定你需要使用的api文档，微信官方了解地址：
https://pay.weixin.qq.com/static/product/product_index.shtml
1.3 了解微信支付api文档
目前有两版api文档，自助支付的话使用V2版即可，V3版给定制商户使用的。
SDK下载地址：
https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=11_1
开发步骤：
1）获取商户信息：appid、mch_id，如果是服务商，需要签约特殊商户来获取子商户sub_appid和sub_mch_id
2）生成签名，参考https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=4_3，微信SDK会帮你实现
3）包装请求参数：转xml格式，SDK也会帮你实现
4）分析请求结果，然后进行业务处理
5）如果是退款和撤销支付的话，需要携带证书
付款码支付代码参考：
微信配置pojo类参考：实现微信提供的抽象配置类
/** * 商户微信配置信息 */ public class WxPayAppConfig implements WXPayConfig { /** * appID */ private String appID; /** * 商户号 */ private String mchID; /** * API 密钥 */ private String key; /** * API证书绝对路径 (本项目放在了 resources/cert/wxpay/apiclient_cert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d820d13570a4b13a35658ffe3ef2f068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33698dfe9e4953a3caa12047b4a961e/" rel="bookmark">
			【论文阅读】LIME：Low-light Image Enhancement via Illumination Map Estimation(笔记最全篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 AbstractIntroductionContributionMethodSpeed-up Method(1)：ALM子问题 T子问题 G子问题 Z和 μ \mu μ Speed-up Method(2)：权重变量 实验conclusion 今天要整理的一篇论文是使用传统的方法解决低照度的问题，Guo等人于2016年发表在IEEE上，论文《LIME：Low-light Image Enhancement via Illumination Map Estimation》，DOI：10.1109/TIP.2016.2639450
Abstract 在低照度环境下拍摄的图像通常能见度都很低，这些图像除了在视觉效果上降低了美感以外，还让计算机视觉的显示效果降质了。为了解决这个问题，本文提出了一种简单有效的低照度图像增强算法（Low-light Image Enhancement，LIME）。具体来说，输入一张低照度图像，选取每个像素通道中的最大值初始化该图像光照图，然后通过强加入一种结构先验来细化这个初始光照图，最后根据Retinex理论合成增强图。实验表明，该算法较之前的方法在质量和性能上都取得不错的效果。
Introduction 能见度高的图像能反映出场景中清晰的细节，这对于一些采用视觉技术的工作有很大的影响，如物体检测和追踪等。但是，在低照度的环境下捕获的图像通常是低能见度，虽然目前有很多算法能提升图像亮度，但是过度提亮会有损图像的效果。直接放大低照度图像可能是调节暗区可见性最直观和最简单的方法，但此操作也会带来另一个问题，比如相对较亮的区域可能已经饱和，因此丢失了相应的细节。
直方图均衡化（HE） 策略是一种将原图像通过某种变换，得到一幅灰度直方图为均匀分布的新图像的方法，可以避免上面的问题。它的基本思想是对在图像中像素个数多的灰度级进行展宽，而对像素个数少的灰度级进行缩减（将像素灰度级范围规定在0-1），从而达到清晰图像的目的。直方图均衡化的核心是变换函数，而常用的变换函数有线性变换、分段线性变换、伽马校正，对数变换、幂变换等。在文中主要指出伽马校正的缺点：仅对每个像素进行操作，忽略了像素之间的相邻关系。
Retinex理论的理论依据依赖一个核心假设：（彩色）图像可以被分解成入射分量（光照）和反射分量两个主要成分，表达式如下：
I = T ⋅ R (1) \begin{aligned}I=T\cdot R \tag1\end{aligned} I=T⋅R​(1)
其中 I I I是原始低照度图，T是入射分量即光照，R是反射分量。最早基于Retinex理论的研究有SSR、MSR：它们都是把反射分量作为最后的增强结果，因此，只需要求解出入射分量即可。但是这样的处理方式，得到的结果通常是不自然的，且容易过度增强。往后的研究就偏向于优化入射分量，使其更自然，有通过融合多张图像来调整光照图，也有通过划分子块优化光照图等。最后来，研究的方向就偏向于加入权重模型，同时优化光照图和反射分量。
到这里，值得一提的方法是：Dong发现了反转低照度图像跟有雾图像的特征相似，因此提出了反转图像（作为伪雾图）应用去雾算法，同样能得到增强亮度的效果，这就将低照度增强领域扩展至图像去雾领域中去了，去雾算法可用在低照度增强中去。（对这个算法感兴趣的同学，可以去下载文章看看，这里提供论文DOI：10.1145/1836845.1836920）
（图）伪雾图与有雾图像
Contribution 本文提出的算法也是基于Retinex理论的，算法主要倾向于估计低照度图像的光照图来实现增强。这里值得注意的是，本文的算法跟以往的基于Retinex增强方法（直接将图像分解成L和R）不同，我们的算法是仅仅估计一种一个变量（光照），这大大地缩小解空间和减少计算量。本文的主要贡献是：
提出了两种加速优化光照图的算法：增广拉格朗日乘数法（ALM）和权重策略。进行了大量的对比实验。 个人观点： 该文章最大的贡献其实是提出的第一种加速优化方法，他主要将优化光照的问题嵌入到最优化问题中，考虑图像的保真和结构性，自定义了一个优化的目标函数和相应的约束条件，然后采用传统的拉格朗日乘数法来解决这个优化问题。
Method 根据Retinex理论可知，我们理想的图像是R（入射分量）可以通过估计出光照图T和原始的低照度 I I I得到：
R = I T \begin{aligned}R=\frac IT \end{aligned} R=TI​​
为了简化计算，通常认为三通道（彩色）图像都是共享同一个光照图。首先初始化光照图 T T T：
T c ( x ) = max ⁡ c ∈ { R , G , B } I c ( x ) (2) \begin{aligned}T^c(x)=\max_{c\in\{R,G,B\}}I^c(x) \tag2\end{aligned} Tc(x)=c∈{R,G,B}max​Ic(x)​(2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33698dfe9e4953a3caa12047b4a961e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14cc93a0f685aa2a99e007e175ec3df3/" rel="bookmark">
			Visual Studio Code 搭建 Java开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 Visual Studio Code 添加扩展 Java Dependency ViewerJava Extension Pack Language Support for Java™ by Red HatLombok Annotations Support for VS CodeSpring Boot Extension Pack 0x02 配置Java地址 Ctrl + Shift + P =&gt; 输入 Setting 找到 打开设置（Json）
然后把下方配置拷贝进去，修改下粗体字段的路径
“workbench.iconTheme”: “vscode-icons”,
“workbench.startupEditor”: “newUntitledFile”,
“java.errors.incompleteClasspath.severity”: “ignore”,
"java.home":“C:\Program Files\Java\jdk1.8.0_65”,
"java.configuration.maven.userSettings": “C:\Program Files\apache-maven-3.6.2\conf\settings.xml”,
"maven.executable.path": “C:\Program Files\apache-maven-3.6.2\bin\mvn.cmd”,
“maven.terminal.useJavaHome”: true,
“maven.terminal.customEnv”: [
{
“environmentVariable”: “JAVA_HOME”,
"value": "C:\Program Files\Java\jdk1.8.0_65"
}
],
备份下我的 { "[javascript]": { "editor.defaultFormatter": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14cc93a0f685aa2a99e007e175ec3df3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1a0d78cb4e2885103298604182f8b39/" rel="bookmark">
			从一无所有，到整个世界-梁宁·产品思维30讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下文章转载自网络，连接在最下方，因作者特别赞同文章内容和观点，并且同感，所以转出来了，谢谢。
8 年前，我的主业是产品经理，产品思维改变了我认识世界的方式，让我明白司空见惯的设计，也有其底层逻辑。
几年后我接触培训、运营自媒体……基于产品能力，我从 IT 男变成了创业者。
年前，在得到App听完《梁宁 · 产品思维 30 讲》，我整个人被点燃了。
梁宁，著名产品人，江湖人称中关村第一才女。
湖畔大学产品模块学术主任。百度顾问，曾任联想、腾讯高管，工作经历横跨BAT，与京东、美团、小米等企业有长期深度交流。
在学习 5、6 遍之后，我用 PPT 做了一份笔记，希望把改变我一生的思维模式，分享给你。
依惯例，回复梁宁可以拿到这份源文件。
产品思维：每个人的底层能力/ 序
科技进步、产品迭代、公司演化、组织变迁……不变的是用户的情绪和人性。
那些信奉“用户驱动”的人，从普通人变成了行业大佬，建立了自己的世界。
乔布斯、马化腾、马云、雷军、张小龙、周鸿祎、傅盛……这些改变世界样貌的产品经理，究竟具备一种怎样的能力？
产品思维，需要我们根据观察和判断，建立系统能力，向用户交付确定性。
运用交互的能力，在连接和迭代中，深化与用户的关系。
这也构成了《梁宁 · 产品思维30讲》的 5 个课程模块——
1、同理心：看懂情绪，找到天分
2、机会判断：从一个“点”，看到一个“体”
3、系统能力：组建系统，制造确定和依赖
4、用户体验：让产品拥有效率、进行演化
5、创新模式：找到创新模式，发现新大陆
同理心：人欲即天理/ 第一部分
做好产品，最重要的是理解用户和自己。
1、专业化的观察和判断
只抓表面数据，无法成为优秀的产品经理。
但我们对于大多数事物的认识，都停留在非常浅的层面。
好的产品经理，要看到人在不同的资源推动下，会去到不同的地方，还要看到触发情绪和推进行动的开关。
要能看到持续变化的内在动力，能拥抱变化，变得成熟。
一个人为了强化自己的存在感，会不断扩张自己的能力圈；
一旦存在感满足，能力圈也就不会继续扩充了。
就像很多女人结了婚就不化妆，男人满足了就不奋斗了……
◇◆◇
2、读懂用户的底层情绪
用户往往无法准确说出体验，只能展现情绪。
把人比作“手机”，后天学的知识就像一个个“App”，而情绪是底层“操作系统”。
理性的调用需要时间和思考，驱动一个人的，可能只是一瞬间的情绪。
通过产品服务人，本质就是用户是否通过你的服务得到了满足。
在一段双方彼此了解的良性关系中，可以读懂对方的“满足”和“不爽”，并给予对方“满足”。
“愉悦”就是被满足，“爽”就是绷了很久的需求突然被满足。
读懂情绪，看到天分和命运。
为什么你照着 PPT 练三次就很痛苦，而乔布斯为了一场发布会对着 PPT 练 100 次依然乐此不疲？
你不厌其烦愿意一直去做的事，就是你的天分所在，是上帝给你的操作系统初始密码。
◇◆◇
做让人愉悦到爽，或是抵御恐惧的产品。
每个人的痛点都是他的恐惧，人们会为了解决恐惧，毫不犹豫地花钱。
医疗和教育是最大的市场，为什么？对生存的恐惧；
为什么医美产品比普通化妆品贵那么多？对青春流逝的恐惧；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1a0d78cb4e2885103298604182f8b39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612a2ac6a2bb0cb2d2cde8ef354cd37b/" rel="bookmark">
			Python：plt.imshow() 没反应 不显示图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 调用plt.imshow()函数之后，程序没有报错，但是并没有弹出窗口，以显示图片
import matplotlib.pyplot as plt plt.imshow(image) # 这里image表示是一张图片 问题分析： 大家可以把plt.imshow()这个函数的作用理解为：把一张图片做一些数据处理，但仅仅是做处理而已。
如果要想把这个处理后的结果显示出来，需要调用另一个函数：plt.show()
解决方案： import matplotlib.pyplot as plt plt.imshow(image) # 对图片image进行数据处理 plt.show() # 将图片显示出来 结果如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b409badaebc2d6120201e7ec4c46bd95/" rel="bookmark">
			filecoin lotus deal（交易）状态及 sectors（扇区）状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交易状态 正常流程：DealUnknown-&gt;DealAccepted-&gt;DealStaged-&gt;DealSealing-&gt;DealComplete 异常流程：DealUnknown-&gt;DealRejected｜DealNoUpdate｜DealError 扇区状态 * Empty | | | v *&lt;- Packing &lt;- incoming | | | v *&lt;- Unsealed &lt;--&gt; SealFailed | | | v * PreCommitting &lt;--&gt; PreCommitFailed | | ^ | v | *&lt;- WaitSeed ----------/ | ||| | vvv v--&gt; SealCommitFailed *&lt;- Committing | | ^--&gt; CommitFailed | v ^ *&lt;- CommitWait ---/ | | | v *&lt;- Proving | v FailedUnrecoverable UndefinedSectorState &lt;- ¯\_(ツ)_/¯ | ^ *---------------------/ 存储矿工日志 2020-03-20T00:19:25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b409badaebc2d6120201e7ec4c46bd95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c77afacd21fef8ab507092cd9a7114/" rel="bookmark">
			python导入同级、下级、上级目录的文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 导入同级模块 直接导入from add import *
没有定义函数，直接import 也可以
addFun.py
import numpy def add(a, b): print("load fun success") return a + b main.py
from addFun import * result = add(1, 1) print(result) 2. 导入下一级别的模块 导入utils文件夹下的app.py
需要在下级目录中新建__init__.py（空文件）
在main.py修改
from utils.addFun import * result = add(1, 1) print(result) 3.导入上级别目录 修改main.py
import sys sys.path.append('../') from addFun import * result = add(1, 1) print(result) 要导入上级目录，可以使用sys.path
作用：当使用import导入模块时，解释器会搜索当前模块所在目录以及sys.path指定的路径去找需要导入的模块。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ce4c2b967493b1bf3dfaec8a900090/" rel="bookmark">
			Laravel 零基础搭建简易后台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备 1、安装 composer php依赖管理工具
安装教程：https://pkg.phpcomposer.com/
2、安装 laravel （注意安装php扩展）
安装教程一：https://xueyuanjun.com/post/7620（常规下载）
安装教程二：安装包下载https://xueyuanjun.com/post/2
图一 3、安装phpstudy(新入门laravel推荐使用)
二、配置及运行 1、把下载下来的项目安装包解压，并命项目名
2、配置，修改 hosts 文件，并且配置站点
3、运行
三、安装 Laravel-admin 安装教程：https://laravel-admin.org/docs/zh/installation
注意：安装前修改 /config/database.php 文件 与 /.env 文件，如图:
如果没有同时修改下面文件，执行 php artisan admin:install 会发生：PDOException] SQLSTATE[HY000] [1045] Access denied for user 'homestead'@'localhost ````````````` 错误。
如果发生42000错误，请修改完之后，删除生成的 两个表后再执行： user 、migrations
发生错误记住清缓存：
php artisan cache:clear php artisan config:clear php artisan config:cache ：不上线不用执行该命令，由于该命令会有一个配置的缓存，执行后，您的 config 文件夹内的配置 就会失效，原因是系统在 bootstrap 中生成了 一个 config,php 文件 失效，执行上面两条命令即可 四、运行发现并没有出现页面，而是 出现 404 ： 进查找参考资料（闪灵龍：laravel 路由404问题）发现是配置问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ce4c2b967493b1bf3dfaec8a900090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c76541b0a09b6f2c46830ace107d74/" rel="bookmark">
			微信小程序如何播放音频，这里以本地mp3文件举例。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下。这里用到的是InnerAudioContext
srcurl是播放的MP3的路径。例如：/image/a.mp3
playmp3: function(event) {
var srcurl="/image/a.mp3"
const innerAudioContext = wx.createInnerAudioContext()
innerAudioContext.autoplay = true
innerAudioContext.src = srcurl
innerAudioContext.onPlay(() =&gt; {
console.log('开始播放')
})
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac6fc4e4c7e57ea4ff8861fe3c585858/" rel="bookmark">
			如何将数组插入到数据库中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在做一个系统的时候，我碰到了一个问题，在向数据库中插入数组时，如何正确添加两个数字之间的逗号呢？
string idstr = ExamOnline_BYSJ.Request.GetFormString(“id”);
string sid = ExamOnline_BYSJ.Request.GetFormString("_sid");
var idarray = idstr.Split(’,’);//0,1,2,3,0
StringBuilder sb = new StringBuilder(" insert into SubjectQuestions (SubjectID,QuestionsID) values “);
int i = 0;
foreach (string s in idarray)
{
if (s != “0”)
{
if ((i + 2) == idarray.Length)
{
sb.AppendFormat(”({0},{1})", sid, s);
}
else
{
sb.AppendFormat("({0},{1}),", sid, s);
}
}
i++;
}
大家请看，我现在要将从前端获取到的两个数据传递到服务器，然后再由服务器将这两个数据插进数据库中，只需用这个循环遍历一遍即可。
ps：我所获取的数组中默认首位各有一个0，例如我获取的数据是3，2则传递到服务器的数据是0,3,2,0再转变成数组然后遍历一遍即可插入数据库中了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5030b96e7802d19e5079c4232fe6e77/" rel="bookmark">
			error Failed to build iOS project. We ran &#34;xcodebuild&#34; command but it exited with error code 65.- RN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一波一波又一波啊，最近一路掉进去爬出来反反复复，嗯。。。又掉进来了，速战速决记录下继续前行。。
macOS 环境下运行 iOS 模拟器进行调试时抛出的如下异常
异常信息 error Failed to build iOS project. We ran "xcodebuild" command but it exited with error code 65. To debug build logs further, consider building your app with Xcode.app, by opening skill_assessment.xcworkspace. Run CLI with --verbose flag for more details. 解决办法 首先，清除当前项目中所加载关联的依赖包并清除 yarn 的缓存
rm -rf node_modules &amp;&amp; yarn cache clean 其次，重新安装依赖包
yarn install 再其次，清除 ReactNative 的缓存
rm -rf ~/.rncache 最后，重新尝试启动程序模拟器即可
react-native run-ios 以上便是此次分享的全部内容，希望能对大家有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845ea76438bd3b6113610cf664cd30d3/" rel="bookmark">
			为什么神经网络会出现梯度消失和梯度爆炸？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝字“视学算法”关注我哟
加个“星标★”，每日好文必达
文末包邮送5本技术书给老读者
阿广 · 家里蹲大学幼儿组编程赛参与奖
我们知道深度神经网络中一个非常关键的问题是如何解决梯度消失和梯度爆炸。当我们看完深度神经网络之后，很多朋友不乏对梯度消失和梯度爆炸一头雾水、一知半解。所以阿广今天给大家彻底的讲一下神经网络中梯度消失和梯度爆炸。
举个例子：下面是一个输入层，三个隐藏层，一个输出层的简单神经网络。
如上图所示的神经网络，误差对b1的求导如下：
其中
我们假设激活函数使用的是sigmoid函数，如下图：
而sigmoid函数的导数最大值为0.25，如下图所示：
通常abs(w)&lt;1，所以可以得到下面的式子：
从上式中不难看出，随着网络层数加大，从前面的层传递到后面的层梯度会越来越小，进而引起了梯度消失的问题。
那么到底什么是梯度爆炸呢？
我们可以看到上式中，sigmoid的导数最大值为0.25，而只有我们的权重持续符合abs(w)&gt;4的时候，才会出现梯度爆炸的问题。
梯度消失和爆炸哪个更容易出现呢？
我们在日常实验或者科研项目中权重的设置基本上都是abs(w)&lt;4，所以梯度消失更普遍。
既然发现了梯度消失和梯度爆炸的问题，那么应该如何解决呢？
1、更换激活函数，使用ReLU或者Maxout等激活函数替代sigmoid；
2、例如ResNet中的残差网络（使用参数隔层传递），也可以有效的防止梯度消失的问题；
3、使用Dropout策略；
4、使用BatchNormlization对各层输入统一；
5、调整学习率；
6、调整权重衰减率；
7、调整网络结构（例如残差网络等）；
8、等待各位开发。
加个“星标★”，欢迎留言！
阿广 · 一个会讲段子的科学探索者
如果有收获，欢迎转发给身边的朋友，也是对阿广最大的支持，后续会更新计算机视觉和深度学习、机器学习数学基础等系列文章，希望得到大家的支持和鼓励！
如果不出什么意外情况，每周包邮送五本书给留言阅读最多和分享最多的老粉丝。本周中奖名单如下（详细中奖名单请看次条文章，中奖者请联系微信：872561826，并使用一条信息发给我所有信息：邮寄信息+想要哪本书）：
PS：特别感谢北京大学出版社的赞助，下面部分图书参与了京东五折活动，欢迎购买。
麻烦给我一个在看！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eae8da15fa9986cdf6205a557a4515c/" rel="bookmark">
			vue项目PC端扫码授权绑定公众号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景需求： PC端点击授权按钮弹框提示立即绑定公众号生成二维码提供微信扫码授权PC端提示授权结果提示、微信公众号提示授权成功提示 解决方案： 利用qrcodejs2插件生成二维码（有容错率区别）需要实时调取接口返回授权绑定公众号是否成功setInterval定时器异步请求的回调反馈问题无法获取（利用Promise函数） 插件引入使用方法可点击查看以往博客 点击这里
1、view层 &lt;el-dialog title="绑定公众号" :visible.sync="authDialog" width="60%"&gt; &lt;div class="tc"&gt; &lt;p class="mb10"&gt;这为保证所有功能的正常使用，授权时请把所有权限统一授权给惠联生花&lt;/p&gt; &lt;el-button class="mt15" type="primary" @click="confirmBind()"&gt;立即绑定&lt;/el-button&gt; &lt;/div&gt; &lt;el-dialog width="30%" title="扫码绑定" :visible.sync="QRVisible" :close-on-click-modal="false" @close="qrClose" append-to-body&gt; &lt;div ref="qrBox" class="qrBox tc"&gt;&lt;/div&gt; &lt;/el-dialog&gt; &lt;/el-dialog&gt; 2、methods层 关键点：
qrcodejs2生成二维码时的容错率属性，PC端会导致扫码失败或扫不出 （correctLevel: QRCode.CorrectLevel.L //容错率，L/M/H）只通过setInterval异步函数请求接口返回无法正常所需要的回调函数结果利用Promise函数中的resolve、reject返回请求结果处理回调函数逻辑处理结果后清除setInterval定时器、以及交互时清除 // 二维码关闭回调 qrClose(){ this.$refs.qrBox.innerHTML = '' clearInterval(this.requestTimer); }, // 绑定公众号 confirmBind(){ // 二维码URL getCodeUrl(this.seller_id).then( res =&gt; { this.qrUrl = res.data.url; this.QRVisible = true; this.$nextTick(()=&gt;{ this.crateQrcode() }) // 请求绑定返回（1分钟内） let time = 60; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eae8da15fa9986cdf6205a557a4515c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/375/">«</a>
	<span class="pagination__item pagination__item--current">376/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/377/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>