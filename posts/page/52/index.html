<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/831ebba201c50bb2710fba01d87beb8c/" rel="bookmark">
			web逆向经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JS逆向调试流程 如果网页有跳转，必须勾选 preservelog 防止丢包看一下有没有框架 右键查看框架源代码(弹出式登陆界面)登陆尽量使用错误密码 防止跳转查看关键登陆包 分析哪些参数是加密的使用别的浏览器分析哪些参数是固定的值初步猜测加密方法搜索，直接搜索参数，例如pwd ，Encrypt，decrypt密码框地方右键 检查 查看 id name type找到加密的地方(重点)(一般debug)找出所有的加密代码 从最后一步开始写起，缺啥找啥如果找的是函数的话 search 要带上 function xxx如果看到加密的地方有个类，并且之后是用 prototype 把方法加在原生对象上的话，要把 所有加在原生对象上的方法都找出来函数找多了没关系，只要不报错不会影响结果，但是不能找少了 二、加密破解 始于前端js对密码加密实现的需要，目前使用最多是AES、RSA、MD5，当然这三个的嵌套和混合使用情况也比较多发现有加密时，搜索encrypt，JSON.parse，​​JSON.stringify，​​CryptoJS 等相关关于算法总结: 对称加密（加密解密密钥相同）：DES、DES3、AES非对称加密（分公钥私钥）：RSA信息摘要算法/签名算法：MD5、HMAC、SHA前端实际使用中MD5、AES、RSA使用频率是最高的几种加密方式配合次序：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，用签名算法生成非对称加密的摘要DES、DES3、AES、RSA、MD5、SHA、HMAC传入的消息或者密钥都是bytes数据类型，不是bytes数据类型的需要先转换；密钥一般是8的倍数 参考项目
三、有eval语句体的，直接把eval改为console.log，在控制台输出查看 四、补环境 什么是 “补浏览器环境” 浏览器环境： 是指JS代码在浏览器中的运行时环境，它包括V8自动构建的对象（即ECMAScript的内容,如Date、Array），浏览器（内置）传递给V8的操作DOM和BOM的对象（如document、navigator）；Node环境：是基于V8引擎的Js运行时环境，它包括V8与其自己的内置API，如fs，http，path； Node环境 与 浏览器环境 的异同点可以简单概括如图：
补浏览器环境” 其实是补浏览器有 而Node没有的环境，即补BOM和DOM的对象
关于bom对象和dom对象：
为什么要 “补浏览器环境”？ 对于逆向老手而言，“补环境” 这个词不会陌生，当我们每次把辛辛苦苦扣出来的 “js加密算法代码”，并且放在浏览器环境中能正确执行后，就需要将它放到Node环境 中去执行，而由于Node环境与浏览器环境之间存在差异，会导致部分JS代码在浏览器中运行的结果 与在node中运行得到的结果不一样或者报异常，从而影响我们最终逆向成果；eg：
function decrypt() { document = false; var flag = document?true:false; if (flag) { return "正确加密" } else { return "错误加密"; } } 在浏览器环境运行时 flag为true，然后得到正常结果； 在Node环境运行时 flag为false，然后得到错误结果； 所以我们需要 “补浏览器环境”，使得扣出来的 “js加密算法代码” 在Node环境中运行得到的加密值，与其在 浏览器环境中运行得到的加密值一致。 即对于这段 “js加密算法代码” 而言，我们补出来的环境与浏览器环境一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/831ebba201c50bb2710fba01d87beb8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9eebf268fa54722e17164be8bb938d4/" rel="bookmark">
			EDA设计基础练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EDA设计基础练习题 ： 1、设计一个三输入或非门电路。 2、三输入三输出电路设计：
输入A为1时，对应输出为1，A为0时，输出为0；
输入B为1时，对应输出为0，B为0时，输出为1；
输入A、B、C有一个为1时，C对应输出为1。
3、十进制数编码电路：把0~9十个数编码成8421BCD码。 实验要求如下： 1、程序设计：编写完整实验程序；注明端口名称及意义； 2、仿真验证：编辑程序、编译、仿真。 编码对象
输入端口
输出端口
I0、I1、I2、I3、I4、I5、I6、I7、I8、I9
Q8、Q4、Q2、Q1
0
I0=1，其他为0
0000
1
I1=1，其他为0
0001
2
I2=1，其他为0
0010
3
I3=1，其他为0
0011
4
I4=1，其他为0
0100
5
I5=1，其他为0
0101
6
I6=1，其他为0
0110
7
I7=1，其他为0
0111
8
I8=1，其他为0
1000
9
I9=1，其他为0
1001
其他情况
1111
代码 1、设计一个三输入或非门电路。 library IEEE; USE IEEE.STD_logic_1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; USE IEEE.STD_logic_unsigned.ALL; -- 实体声明 ENTITY ShiYan6 IS PORT( A,B,C	: IN	std_logic; output	:out	std_logic );	END ShiYan6; --结构体说明 ARCHITECTURE behave OF ShiYan6 IS BEGIN PROCESS (A, B, C) BEGIN --三输入或非门 描述 output &lt;= NOT (A OR B OR C); END PROCESS; END behave; 2、三输入三输出电路设计： 输入A为1时，对应输出为1，A为0时，输出为0；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9eebf268fa54722e17164be8bb938d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff8060f6150b89cbd1ed37f6ce96785/" rel="bookmark">
			【IDEA】-CPU占用率过高的五种解决办法（VIP典藏版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、IDEA的CPU占用率过高
二、解决办法
1、选择合适的idea版本（⭐⭐⭐）
2、修改IDEA配置文件，内存优化（⭐⭐）
3、关掉代码检查（⭐⭐⭐）
4、去掉多余的插件（⭐⭐⭐）
5、选择合适的JDK版本（⭐）
一、IDEA的CPU占用率过高 二、解决办法 1、选择合适的idea版本（⭐⭐⭐） 用过四个版本的（2018.3、2019.3、2020.1、2021.3、2023.1），2018性能明显差好多，2020版本尚可，个人认为性能和易用性最高的是2019.3的版本，2021.3次之
2、修改IDEA配置文件，内存优化（⭐⭐） idea安装路径bin目录
idea64.exe.vmoptions IDEA优化内存配置
-Xms2048m -Xmx4096m -XX:ReservedCodeCacheSize=800m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 3、关掉代码检查（⭐⭐⭐） setting -&gt; Editor -&gt; Inspections，把右面方框框里的对勾根据需要√掉，保留以下两个即可。
4、去掉多余的插件（⭐⭐⭐） 比如特效类的，代码检查类的，对于大型项目提升效果显著
5、选择合适的JDK版本（⭐） 每个大版本都有后续小版本，一般来说版本号越大越好，本人常用的是201版本
有用请点赞,养成良好习惯！
疑问交流鼓励请留言！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cdb1361a977fb7fcf4c01fecaad47d9/" rel="bookmark">
			8086汇编程序：8254定时器/计数器实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的 1.学会8254芯片和微机接口原理和方法
2.掌握8254定时器计数器的工作方式和编程原理
实验内容 1、在Proteus中设计一个简单计件系统，用一个脉冲信号代表一个事件，当计数到100时，通过扬声器发音,通知操作员。
2、计数器0用来统计事件数量，工作于方式0，计数初值是100，时钟信号CLKO接2Hz。
3、计数器 1用来驱动扬声器发生，产生500Hz的发音频率，工作于方式3。时钟信号 CLK1接1MHz，计数初值是:1000000/500=2000。
4、计数器0在开始执行程序时就开始工作，即门控信号GATEO一直有效。计数器1是计数器0结束计数后开始工作，因此刚好用CLKO产生的高电平接到计数器1的门控信号GATE1上。
8253控制字： D7
D6
D5
D4
D3
D2
D1
D0
SC1
SC0
RL1
RL0
M2
M1
M0
BCD
选择通道
读写操作
工作方式选择
十进制
实验步骤 1、硬件线路连接
在Proteus软件中绘制硬件电路图。8254A片上地址：计数器0地址为78H、计数器1地址为7AH、计数器2地址为7CH、控制端口地址为7EH。
2、软件程序编写
用emu8086软件编写汇编语言程序，保存成*.asm源程序，编译生成.exe可执行文件。
3、在Proteus中双击8086CPU，加载.exe可执行文件。
4、单步执行程序，查看每一条指令的运行结果。
程序代码 ASSUME CS:CODE PORT_Timer0 EQU 78H PORT_Timer1 EQU 7AH PORT_Timer2 EQU 7CH PORT_control EQU 7EH CODE SEGMENT START: ;Timer0 MOV AL, 00010000B	;10H OUT PORT_control, AL;定时器0控制字 MOV AL, 10 ;定时器0初值 OUT PORT_Timer0, AL ;Timer1 MOV AL, 01110110B	;76H OUT PORT_control, AL	;定时器1控制字 MOV AX, 2000;定时器1初值 OUT PORT_Timer1, AL	;写低8位 MOV AL, AH	;高字节赋值给低四位 OUT PORT_Timer1, AL	;写高8位 ;MOV CX, 70 T:	JMP T;循环 MOV AH, 4CH INT 21H CODE ENDS END START 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cdb1361a977fb7fcf4c01fecaad47d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a5c5a2400dd508f320240eaa81426a/" rel="bookmark">
			Centos下用nodejs实现一个简单的web服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebRTC是音视频直播中最常用的一个框架，在使用的过程中，我们就需要实现一个服务器端。本文以nodejs实现一个服务器为例，讲述一下在centos下如何用nodejs实现一个简单的web服务器。
一、安装nodejs 在linux环境下安装nodejs有多重方式，主要分为安装包安装或者源码安装，这里为了方便，我们就直接用安装包的方式来安装。
1、用yum 命令安装 用以下命令来安装nodejs和依赖的npm服务
yum install -y nodejs yum install -y npm 有时候因为没有配置对应的yum源的原因，就会出现找不到nodejs的情况，这个时候找yum源比较麻烦，我们就直接下载安装包来安装
2、用下载安装包的方式来安装nodejs 首先，我们到nodejs的下载网站上下载的包(这里选择了16版本，最新版本需要升级glib，比较麻烦)，复制其下载链接
然后到linux命令行，用wget命令下载
wget https://nodejs.org/dist/v16.14.0/node-v16.14.0-linux-x64.tar.xz 如果没有wget命令，用
yum install -y wget 来安装即可。
等待安装完成以后，先后执行以下命令解压下载的安装包
node-v16.14.0-linux-x64 是我下载的包名，对应到自己下载的包即可
tar -xvf node-v16.14.0-linux-x64.tar.xz 将解压后的文件移动到/usr/local/下面(这样做的目的是为了防止后面误删)
mv node-v16.14.0-linux-x64 /usr/local/node-v16.14.0-linux-x64 部署bin文件(这样就可以在随时随地使用node命令)
ln -s /usr/local/node-v16.14.0-linux-x64/bin/node /usr/bin/node ln -s /usr/local/node-v16.14.0-linux-x64/bin/npm /usr/bin/npm 使用以下命令进行测试
node -v npm -v 结果如下：
二、开发最简单的一个web服务器 1、编写一个简单的js服务文件MyFirstServer.js,内容如下 var http = require('http'); http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain。并用charset=UTF-8解决输出中文乱码 response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8a5c5a2400dd508f320240eaa81426a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1614f5e00e0bfde5e1cb0ec200a1145/" rel="bookmark">
			【Kafka-Eagle】EFAK告警配置与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka-Eagle是一个开源的Kafka集群监控与告警系统，可以帮助用户实现对Kafka集群的实时监控、性能指标收集以及异常告警等功能。下面是关于Kafka-Eagle的告警配置和实践的一般步骤：
安装和配置Kafka-Eagle：
下载最新版本的Kafka-Eagle安装包，并解压到一个合适的目录中。进入Kafka-Eagle的解压目录，编辑conf/system-config.properties文件，配置Kafka集群的相关信息。 修改kafka.eagle.zk.cluster.alias属性来设置ZooKeeper集群的别名。修改kafka.eagle.zk.list属性来设置ZooKeeper的地址，支持多个地址用逗号分隔。修改kafka.eagle.bootstrap.servers属性来设置Kafka集群的Bootstrap Servers，支持多个地址用逗号分隔。 配置告警规则：
在Kafka-Eagle的解压目录下，找到conf/alarm.properties文件，该文件用于配置告警规则。告警规则由JSON数组表示，可以添加多个告警规则。每个告警规则由以下字段组成： cluster：指定Kafka集群的别名，与system-config.properties文件中的kafka.eagle.zk.cluster.alias对应。topic：定义要监控的Topic名称，可以使用通配符（*）匹配多个Topic。alarmLevel：设置告警级别，可选值为CRITICAL、WARNING、INFO。expression：定义告警的触发条件，可以使用Kafka-Eagle提供的表达式语法，例如brokerMetrics.get(1).get('HeapMemoryUsed') &gt; 1000000000表示当Broker的堆内存使用量超过1GB时触发告警。notificationGroups：指定通知组，用于发送告警通知。 配置告警通知方式：
在conf/alarm.properties文件中，配置告警通知方式。Kafka-Eagle支持多种告警通知方式，包括邮件、短信、Webhook等。配置相应的通知方式参数，如SMTP服务器信息（如果使用邮件通知）或其他通知方式的相关参数。 启动Kafka-Eagle：
执行Kafka-Eagle的启动脚本，例如执行./bin/ke.sh start（Linux/Mac）或bin\ke.bat start（Windows）来启动Kafka-Eagle服务。等待一段时间，确保Kafka-Eagle成功连接到Kafka集群并开始收集监控数据。 监控与告警查看：
打开Web浏览器，访问Kafka-Eagle的Web界面，默认地址为http://&lt;Kafka-Eagle服务器IP&gt;:8048/ke。在登录页面输入用户名和密码，默认用户名为admin，密码为admin（可以在conf/system-config.properties文件中修改）。登录后，可以查看Kafka集群的实时监控数据、告警信息和历史记录。在"Topics"选项卡下，可以查看Topic的分区情况、消息堆积数量等指标。在"Brokers"选项卡下，可以查看Broker的性能指标、副本状态等信息。当触发告警规则时，Kafka-Eagle会发送相应的告警通知。 请注意，以上步骤仅为基本配置和使用Kafka-Eagle进行告警的指导。Kafka-Eagle还提供了更多功能，如消费者组监控、消息查询等。你可以参考官方文档获取更详细的配置和使用说明，并根据实际需求进行适当调整和优化。
当配置Kafka-Eagle的告警规则时，你可以根据实际需求定义更详细的规则。以下是一些常见的告警规则配置选项：
1. `cluster`：指定要监控的Kafka集群的别名。
2. `topic`：定义要监控的Topic名称。你可以使用通配符（*）来匹配多个Topic，例如`topic: "my_topic_*"`。
3. `alarmLevel`：设置告警级别，可选值包括：
- `CRITICAL`：关键级别的告警，表示存在严重问题。
- `WARNING`：警告级别的告警，表示存在潜在问题。
- `INFO`：信息级别的告警，表示一般的监控信息。
4. `expression`：定义告警触发条件的表达式。你可以使用Kafka-Eagle提供的表达式语法来构建条件。以下是一些常用的表达式语法：
- 监控Broker的Heap Memory使用量是否超过阈值：`brokerMetrics.get(&lt;brokerId&gt;).get('HeapMemoryUsed') &gt; &lt;threshold&gt;`。
- 监控Topic的消息堆积数量是否超过阈值：`topicMetrics.get('&lt;topicName&gt;').get('MessagesIn') &gt; &lt;threshold&gt;`。
- 监控Topic的副本数量是否低于期望值：`topicMetadata.get('&lt;topicName&gt;').get('ReplicaCount') &lt; &lt;expectedReplicaCount&gt;`。
5. `notificationGroups`：指定用于发送告警通知的通知组。你可以在Kafka-Eagle的Web界面中配置通知组，包括邮件、短信、Webhook等方式。
下面是一个示例告警规则的配置：
```json
[
{
"cluster": "my_cluster",
"topic": "my_topic",
"alarmLevel": "CRITICAL",
"expression": "topicMetrics.get('my_topic').get('MessagesIn') &gt; 1000",
"notificationGroups": ["group1", "group2"]
},
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1614f5e00e0bfde5e1cb0ec200a1145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05280814570280724761bb6fa38e830a/" rel="bookmark">
			C# 文件同步写入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 需要对某一文件进行同步写入
问题描述 一般的方法：
File.AppendAllText(filePath, $"{curTimeStr}: {recordText}" + Environment.NewLine); 原因分析： 该方法会引起报错：
Information: WriteToFile() catch exception =&gt; System.IO.IOException: The process cannot access the file 'C:\Users\e2e\AppData\Local\Temp\ProxyServerTest_20231222-093555' because it is being used by another process. at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath) 异常信息：WriteToFile() 捕获到异常 =&gt; System.IO.IOException: 无法访问文件 ‘C:\Users\e2e\AppData\Local\Temp\ProxyServerTest_20231222-093555’，因为它正被另一个进程使用。
在 System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
这个异常是因为WriteToFile()函数尝试访问的文件’C:\Users\e2e\AppData\Local\Temp\ProxyServerTest_20231222-093555’正在被另一个程序或进程使用。
这种情况通常发生在某个程序或进程打开了文件进行读取或写入时，另一个程序或进程尝试同时访问同一文件。要解决这个问题，你可以尝试以下步骤：
1.关闭可能正在使用该文件的所有程序或进程。 2.检查是否是由防病毒软件或安全软件锁定的文件。如果是，暂时禁用该软件并尝试再次访问文件。 3.使用File.Open()方法配合适当的文件访问模式（读、写、读写）和文件共享模式（无、读、写、读写），以确保正确地访问文件。 4.将WriteToFile()函数包裹在try-catch块中，并处理IOException异常，可以通过在短暂延迟后重试操作或向用户显示错误消息来处理。 解决方案： 在C#中，同时对一个文件进行写入可能会导致数据冲突或损坏，因为多个线程或进程同时修改同一文件可能会产生不可预知的结果。为了安全地在同一文件上进行并发写入，你需要使用适当的同步机制。
private static object fileLock = new object(); public static void SafeWriteToFile(string filePath, string content) { lock (fileLock) { using (FileStream fs = new FileStream(filePath, FileMode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05280814570280724761bb6fa38e830a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83243a519b57bd7db2e770792c2f0123/" rel="bookmark">
			内网穿透之FRP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		借助frp实现内网穿透。
技术实现过程： 借助一台云服务器，在服务器上部署frp服务器程序，在内网服务器上部署frp客户端程序。首先是它两建立连接，连接的方式可以是tcp http等，在配置文件中配置。以http为例，当有请求到frp服务器程序的某个端口时，它会自动转发到配置好的内网服务器上。在云服务器上部署一个nginx,实现代理。当请求到nginx时，nginx转发到本地的frp服务器程序，最后再到内网客户端。这样就实现了内网穿透。 技术原理 其实nginx本身是一个软件，frp本身也是一个开源的软件。他们自己实现了这个功能。
frp 官网：https://gofrp.org/
注意的点 就是在写配置文件的时候，当使用http的时候，会让填写域名，写公网IP应该也行。
收集的博客 https://blog.csdn.net/u010025272/article/details/132360128
https://zhuanlan.zhihu.com/p/626471788
https://blog.csdn.net/XiaoChen10086/article/details/117110010
https://blog.csdn.net/weixin_44797182/article/details/128167613
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd72ca9cadd1bb0833f48bd122c98964/" rel="bookmark">
			每日一题|计算机考研C语言专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若有定义:int x=1234,y=123,z=12;则语句printf(“%4d+%3d+%2d”,x,y,z);运行后的输出结果为()。
A.123412312 B. 12341234123412341231231231212 C.1234+1234+1234 D.1234+123+12
若有定义:int x=1234,y=123,z=12;则语句printf(“%4d+%3d+%2d”__N诺计算机考研计算机保研,计算机考研国家线,计算机考研需要考哪些科目,计算机考研院校推荐,计算机考研学校排名,计算机考研科目,计算机考研,计算机考研大纲,计算机专业考研,计算机考研专业课,计算机408考研科目,计算机考研机试,软件工程考研,考研真题https://noobdream.com/Practice/article/1467/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7301a3fef9eb35ad566ac85e136e1aff/" rel="bookmark">
			mysql空间查询之搜索在不规则图形范围内点的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这次的需求是在地图上画一个不规则图形,查询这个范围内的数据,类似下图:
前端会把每个折现点的经纬度传过来,比如:0 0, 0 10, 10 10, 10 0, 0 0,注意要首尾相连,这样才是一个完整的图形。
数据准备:有一个包含点的数据表，并且该表具有一个名为point的列来存储每个点的坐标,数据格式跟下面一样.point(经度 纬度),要注意范围要在-90,90,具体操作可以看我之前的文章.
POINT(91.0950400002959 29.6587200003277)
一.实现 首先将前端传过来的不规则图形数据进行包装,前段传来的数据如下:
0 0, 0 10, 10 10, 10 0, 0 0
我们需要修改成:
‘POLYGON((0 0, 0 10, 10 10, 10 0, 0 0))’
现在可以直接写sql了
SELECT * FROM points_table WHERE ST_Within(point, ST_GeomFromText('POLYGON((0 0, 0 10, 10 10, 10 0, 0 0))')); 注意:
有时候我们在数据库软件运行是没问题的,但是在代码里会报错,这是因为ST_GeomFromText()函数,需要对里面的数据加’ ‘,所以我这边是直接将数据拼上’ ',然后使用${}来进行拼接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20955b2b421438cd2a6effd52ee905d/" rel="bookmark">
			win10 安装tvm（aarch64进行推理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 准备一、编译llvm二、编译tvm三、测试tvm 准备 tvm下载：git clone -b v0.14.0 --depth=1 --recursive http://github.com/apache/tvm tvmllvm下载：https://codeload.github.com/llvm/llvm-project/zip/refs/tags/llvmorg-11.0.1E:\TVM_LLVM ├─llvm-project-llvmorg-11.0.1.zip └─tvm 在E:根目录下创建如上tvm_llvm文件夹，并将下载的两个包放置到文件夹内。 一、编译llvm 解压llvm-project-llvmorg-11.0.1.zip 创建build并编译
cd E:\tvm_llvm\llvm-project-llvmorg-11.0.1\llvm\ &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; cmake ..
执行编译
cd ../ &amp;&amp; cmake --build build --config Release
二、编译tvm 准备cmake
cd E:\tvm_llvm\tvm &amp;&amp; mkdir build &amp;&amp; copy cmake\config.cmake .\build\修改config.cmake， 若有cuda配置，可设置使用cuda
set(USE_CUDA ON)
set(USE_LLVM E:/tvm_llvm/llvm-project-llvmorg-11.0.1/llvm/build/Release/bin/llvm-config.exe)切换路径执行cmake
cd build &amp;&amp; cmake -A x64 -Thost=x64 ..
执行编译
cd .. &amp;&amp; cmake --build build --config Release -- /m
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e20955b2b421438cd2a6effd52ee905d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6f3351bc779e83cb1e8b8a23ee6c1b/" rel="bookmark">
			Qt/C&#43;&#43;视频监控Onvif工具/组播搜索/显示监控画面/图片参数调节/OSD管理/祖传原创
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 能够写出简单易用而又不失功能强大的组件，一直是我的追求，简单主要体现在易用性，不能搞一些繁琐的流程和一些极难使用的API接口，或者一些看不懂的很难以理解的函数名称，一定是要越简单越好。功能强大主要体现在功能的完整性，常规的接口肯定是必备的，然后在默认值方面，尽量将值设置成最常用的合规的值，然后提供了接口可以修改这些值，以便兼容各种各样的需求场景。比如一些开关的值，如果90%的人希望默认是关闭的，而你搞个默认值开启，这就很纳闷了，大部分的用户每次都需要去主动修改后才能适用自己的场景。在做软件开发这些年，一直遵循这些原则和逻辑搞到今天，包括精心打磨很多年的各种组件，比如视频播放组件，Onvif组件等。
代码使用示例：
第一步：拷贝onvif组件源码到你的项目，放到同级目录。第二步：在项目pro文件中引入组件 include ($$PWD/…/core_onvif/core_onvif.pri)。第三步：代码文件引入头文件 #include “onvifsearch.h” #include “onvifdevice.h”，其中onvifsearch用于搜索设备，onvifdevice用于获取设备的详细信息比如rtsp视频流地址。第四步：组播或者单播搜索设备，获取到对应的onvif地址。每个设备都有一个唯一的onvif地址。 //实例化搜索对象并关联信号槽 OnvifSearch *search = new OnvifSearch(this); connect(search, SIGNAL(receiveDevice(OnvifDeviceInfo)), this, SLOT(receiveDevice(OnvifDeviceInfo))); //参数1是网卡地址/参数2指定地址则表示单播 search-&gt;search("192.168.0.110", ""); void frmSimple::receiveDevice(const OnvifDeviceInfo &amp;deviceInfo) { QString msg = QString("收到设备: %1").arg(deviceInfo.onvifAddr); ui-&gt;textEdit-&gt;append(msg); QListWidgetItem *item = new QListWidgetItem; item-&gt;setText(deviceInfo.deviceIp); item-&gt;setData(Qt::UserRole, deviceInfo.onvifAddr); ui-&gt;listWidget-&gt;addItem(item); } 第五步：对指定的onvif地址发送http请求，获取详细信息。 //实例化onvif对象实例 OnvifDevice *device = new OnvifDevice(this); //设置用户信息用于请求的时候认证用 device-&gt;setUserInfo("admin", "123456"); //设置请求地址 device-&gt;setOnvifAddr("http://192.168.0.64/onvif/device_service"); //先获取服务文件 device-&gt;getServices(); //可能为空需要按照另一种方式获取 if (device-&gt;getMediaUrl().isEmpty()) { device-&gt;getCapabilities(); } //获取配置文件 QList&lt;OnvifProfileInfo&gt; profiles = device-&gt;getProfiles(); foreach (OnvifProfileInfo profile, profiles) { ui-&gt;cboxProfiles-&gt;addItem(profile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c6f3351bc779e83cb1e8b8a23ee6c1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e827dd27b0135118d9e5282ec886a66/" rel="bookmark">
			Slurm随手记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：项目要用，随便记录一下
文章目录 简介快速开始框架命令建议MPI 参考资料：
https://slurm.schedmd.com/quickstart.html
https://blog.csdn.net/weixin_42279314/article/details/109677459
https://hpc.pku.edu.cn/_book/guide/slurm/sbatch.html
简介 Slurm是一个开源、容错、高度可扩展的集群管理和作业调度系统，适用于大型和小型Linux集群。Slurm的操作不需要对内核进行修改，并且相对独立。作为集群工作负载管理器，Slurm具有三个关键功能。首先，它将对资源（计算节点）的独占和/或非独占访问分配给用户一段时间，以便他们可以执行工作。其次，它提供了一个框架，用于在分配的节点集上启动、执行和监视工作（通常是并行作业）。最后，它通过管理挂起的工作队列来仲裁资源争用。
快速开始 框架 Slurm系统由两个关键部分组成，如图1所示。每个计算节点上都有一个slurmd守护进程，而管理节点上则有中央slurmctld守护进程（还可以选择启用故障转移）。slurmd负责提供容错通信。用户可以使用一系列命令来与系统交互，包括：sacct、sacctmgr、salloc、sattach、sbatch、sbcast、scancel、scontrol、scrontab、sdiag、sh5util、sinfo、sprio、squeue、sreport、srun、sshare、sstat、strigger、sview。所有这些命令都可以在集群的任何位置执行。
Slurm系统中有多个组成部分，如图2所示。这些包括节点（计算资源的基本单元）、分区（将节点分组成逻辑集合，可以有重叠）、作业（在指定时间内分配给用户的任务或资源）、以及作业步骤（作业中的一组可能并行执行的任务）。分区可以看作是作业的队列，每个分区都有一些限制，比如作业大小、运行时间、允许使用的用户等。系统会按照优先级将作业分配给分区内的节点，直到该分区的资源（如节点、处理器、内存等）被用尽。一旦作业被分配到一组节点，用户就可以启动并行工作，可以是利用所有节点的单个作业步骤，也可以是几个独立的作业步骤，每个步骤使用分配的一部分资源。
命令 所有Slurm守护进程、命令和API函数都有手册页。命令选项–help还提供了选项的简要摘要。请注意，命令选项都区分大小写。
sacct 用于报告有关活动或已完成作业的作业或作业步骤的会计信息。
salloc 用于实时分配作业的资源。通常用于分配资源并生成一个 shell。然后使用该 shell 执行 srun 命令启动并行任务。
sattach 用于将标准输入、输出和错误以及信号功能附加到当前运行的作业或作业步骤。可以多次附加到和分离从作业。
sbatch 用于提交作业脚本以供以后执行。脚本通常包含一个或多个 srun 命令以启动并行任务。 假设你有一个名为 my_job_script.sh的脚本，其中包含作业的详细信息和要执行的命令。通过以下命令将作业提交到队列：sbatch my_job_script.sh
sbcast 用于将文件从本地磁盘传输到分配给作业的节点的本地磁盘。这可用于有效地使用无磁盘的计算节点或相对于共享文件系统提供更好的性能。
scancel 用于取消挂起或运行中的作业或作业步骤。还可以用于向与运行中的作业或作业步骤关联的所有进程发送任意信号。
scontrol 是用于查看和/或修改 Slurm 状态的管理工具。请注意，许多 scontrol 命令只能以 root 用户身份执行。
sinfo 报告由 Slurm 管理的分区和节点的状态。它具有各种过滤、排序和格式化选项。
sprio 用于显示影响作业优先级的组件的详细视图。
squeue 报告作业或作业步骤的状态。它具有各种过滤、排序和格式化选项。默认情况下，它按优先级顺序报告运行中的作业，然后按优先级顺序报告挂起的作业。
srun 用于实时提交作业以执行或启动实时作业步骤。srun 具有各种选项，可指定资源要求，包括：最小和最大节点数、处理器数、要使用或不使用的特定节点以及作业的节点分配中的特定节点特性（内存、磁盘空间、某些所需功能等）。作业可以包含在作业的节点分配内顺序或并行执行的多个作业步骤。
如果你想直接在命令行中启动一个 MPI 进程，可以使用 srun，例如srun -n 4 ./my_mpi_program
sshare 显示有关集群上公平份额使用情况的详细信息。请注意，这仅在使用优先级/多因素插件时才可行。
sstat 用于获取有关运行中作业或作业步骤使用的资源的信息。
strigger 用于设置、获取或查看事件触发器。事件触发器包括节点宕机或作业接近其时间限制等情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e827dd27b0135118d9e5282ec886a66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5717b0013e8de397ccfdfc28ff4e8ff5/" rel="bookmark">
			windows下使用gtest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是在window下使用clion来写c++的，最近学习了gtest，中间遇到了一些问题，记录一下。
整体目录 先看一下目录结构
两个测试case，前面就有运行的标志，直接点击就能运行
具体的代码 CMakeLists.txt cmake_minimum_required(VERSION 3.14) project(my_project) # GoogleTest requires at least C++11 set(CMAKE_CXX_STANDARD 11) include(FetchContent) FetchContent_Declare( googletest URL https://github.com/google/googletest/archive/609281088cfefc76f9d0ce82e1ff6c30cc3591e5.zip ) # For Windows: Prevent overriding the parent project's compiler/linker settings set(gtest_force_shared_crt ON CACHE BOOL "" FORCE) FetchContent_MakeAvailable(googletest) enable_testing() add_executable( gtest_demo gtest_demo_1.cc sample1.cc ) target_link_libraries( gtest_demo gtest_main ) include(GoogleTest) gtest_discover_tests(gtest_demo) sample1.h #ifndef GOOGLETEST_SAMPLES_SAMPLE1_H_ #define GOOGLETEST_SAMPLES_SAMPLE1_H_ // Returns n! (the factorial of n). For negative n, n! is defined to be 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5717b0013e8de397ccfdfc28ff4e8ff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ad913ed87a792bcc5ef262e543c279/" rel="bookmark">
			可持续架构：过去、现在和未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键字: [Amazon Web Services re:Invent 2023, Sustainable Architecture, Resource Efficiency, Amazon Web Services Services, Renewable Energy, Optimization]
本文字数: 1400, 阅读完需: 7 分钟
视频 如视频不能正常播放，请前往bilibili观看本视频。&gt;&gt; https://www.bilibili.com/video/BV1Pi4y1Y7pb
导读 自 2021 年亚马逊云科技良好架构框架的可持续性支柱推出以来，对环境可持续性的关注已经发展到云工作负载的关键非功能需求。本论坛重新讨论了这一支柱及其最佳实践。深入研究客户用于建立其架构的资源和能效可见性的机制和工具，以及他们如何确定优化并确定其优先级。通过客户示例和演示，了解如何为应用程序团队构建可持续性展示机制并推动变革。
演讲精华 以下是小编为您整理的本次演讲的精华，共1100字，阅读时间大约是6分钟。如果您想进一步了解演讲内容或者观看演讲全文，请观看演讲完整视频或者下面的演讲原文。
斯特凡·瓦尔，作为亚马逊云科技的解决方案架构师，在亚马逊云科技2022峰会的演讲中分享了他对于优化和提高资源效率的观点。他认为这是实现可持续发展的重要途径。首先，他带领观众回顾了过去的历史，强调了在预算限制下，应用程序团队在架构中追求效率的动力。由于基础设施边界的限制，他们必须调整应用程序以适应这个固定范围。这一变化始于2006年，当时亚马逊云科技推出了Amazon Elastic Compute Cloud (EC2)。如今，客户可以根据需要在高峰期扩展资源并在非高峰期收缩，从而充分利用亚马逊云科技EC2基础设施的规模经济。
然而，随着EC2使得高效扩展变得更加容易，一种反弹效应出现了：使用更多有效基础设施变得越来越受欢迎。开发者现在有两个选择来加速应用程序：调整代码或为应用程序分配更多水平的EC2实例。只要业务需求增长，使用更多资源是可以接受的。甚至在2012年，亚马逊云科技的沃纳·维格尔斯就倡导了成本意识架构，通过跟踪成本效率和利用云的弹性来实现规模经济。
与此同时，对气候变化影响的认识逐渐增强，这使得利益相关者更加关注可持续发展。客户将可持续发展目标纳入其决策标准，而员工和投资者在选择工作和投资的地方时也优先考虑可持续性。许多公司公开承诺可持续发展，例如亚马逊在2019年与全球乐观主义和其他组织共同发起的“气候承诺”，目前已有400多个签署方承诺到2040年实现净零碳排放，比巴黎协定2050年的目标提前了10年。
当公司设定净零目标时，这通常涉及到其IT部门。人们对量化三种范围的温室气体排放的协议有了更深入的理解——范围1是直接排放，范围2是从购买能源中产生的间接排放，而范围3是所有其他间接排放，如供应链。亚马逊云科技的应用涵盖了范围2和3。碳核算为团队提供了通过其产品和服务产生影响的排放可视性。随着这种关注的增加，IT现在面临着优化可持续性的压力，作为非功能性需求。
在当今时代，斯特凡讨论了成功地为可持续发展优化的客户所看到的流程、工具和文化。自10年前于2012年推出的Well Architected框架提供了一种一致的方法来实施跨支柱的最佳实践，包括2020年新增的可持续发展支柱。它确立了重要概念，如共享责任模型，其中亚马逊云科技构建高效的基础设施，而客户做出高效的架构决策，以使双方都能为可持续发展做出贡献。
亚马逊云科技于2021年推出的客户碳足迹工具提供了用于分析并识别优化机会的亚马逊云科技总使用量的排放数据。然而，需要更及时的指标以实现持续优化。亚马逊云科技的成本和使用报告提供了细粒度的服务使用数据。通过了解流程和业务需求,客户可以计算业务指标与资源指标之间的比率作为可持续性KPI。
涵盖的一些最佳实践包括匹配供应和需求、减少过度供应、近似结果而不是到处追求精确准确性，并在可能的情况下放宽可用性要求。2019年推出的CodeGuru等工具、2020年推出的AmazonS3 Storage Lens、2018年推出的Compute Optimizer以及2022年公开的Sustainability Scanner都有助于检查优化机会并根据可持续性最佳实践验证架构。
史蒂芬提供了一些客户案例，例如TUI和VMware已经在应用这些技术。作为全球最大的旅游公司之一的TUI，使用代理指标和KPI来了解跨应用程序团队的资源使用情况，并推动改进。他们的Flight Margin Brain工具每天计算7000万笔航班费用，通过优化基于这些指标，他们将缓存层计算资源减少了40%，而不会对客户体验产生影响。
VMware是一家提供多云和虚拟化服务的提供商，他们建立了显示加权资源使用分数的仪表板，从而激励某些资源的利用。他们还将其可持续性集成到现有的FinOps工具中，这是他们在私人测试阶段的Tanzu Cloud Health工具，用于识别优化机会并提供建议。
展望未来，亚马逊云科技将继续投资可再生能源，目标是到2025年所有运营活动都使用100%可再生能源。2022年，亚马逊云科技在整个业务中实现了90%的可再生能源。在严重依赖化石燃料的地区，亚马逊云科技正在添加新的可再生能源项目，例如今年在亚太地区增加了13个。亚马逊云科技还计划到2030年实现水正面影响，通过回收和社区补给项目返还比使用的更多的水。自2021年以来，亚马逊云科技已将水利用率从0.25升/千瓦小时提高到0.19升/千瓦小时。
当亚马逊云科技关注基础设施效率时，史蒂芬解释说，他们可以与客户的工作负载灵活性信号一起进一步优化。例如，2022年推出的EC2 M7 Flex实例等服务可以发送闲置容量信号以有效地利用它。通过共享工作负载约束和任何灵活性，客户使亚马逊云科技能够通过服务优化提高效率。彼得·德斯兰蒂斯在2022年re:Invent的主题演讲强调了现在可用的所有数据库、缓存和仓库选项，以减少处理使用高峰和低谷的客户开销。
同时，客户最了解自己的工作负载。亚马逊云科技旨在提供透明度、工具和选择，以赋予优化决策的能力。例如，CodeGuru持续扫描代码以寻找优化机会。2022年新宣布的Gen AI等AI服务应该通过首先使用较少资源消耗的选项(如提示工程而非完整模型训练)来减少环境影响。
斯蒂芬为客户提供的建议包括跟踪资源使用和排放量，与开发团队建立反馈循环，审查Well Architected Framework的可持续性最佳实践，利用亚马逊云科技的优化工具，并关注最大的改进领域。他提倡运用技术来构建可持续解决方案，以解决常见的能源和建筑管理问题。亚马逊云科技解决方案库提供了现成的可持续解决方案，结合了服务、软件和指导，以加速开发进程。
总的来说，斯蒂芬·夸尔提供了关于可持续发展日益增长的重要性的实际见解，以及亚马逊云科技及其客户所采用的驱动更高效和可持续架构的过程和工具。他还为组织在优化过程中可以采取的下一步操作提供了建议。通过提高排放量的可见性，利用亚马逊云科技专为效率设计的服务，并在需求管理、过度分配和精确需求方面采用最佳实践，客户可以显著提高其云计算足迹的可持续性。
下面是一些演讲现场的精彩瞬间：
亚马逊云科技的领导者们强调了诸如CodeGuru、S3 Storage Lens和Compute Optimizer等指导性工具如何提供优化建议，从而提高工作负载的效率和可持续性。
这些可持续发展扫描器能够扫描基础设施即代码模板并给出实际可行的建议，帮助企业识别优化云计算基础设施以实现可持续发展的机会。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28ad913ed87a792bcc5ef262e543c279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff8d27c7162ed5457f0ea70b5d8ef77/" rel="bookmark">
			Sustainable architecture: Past, present, and future
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Good afternoon, everyone. I'm Stefan Kwal. I'm a Solutions Architect at AWS, and my job is to help customers build sustainable architectures on AWS. This is SU S3 02, Sustainable Architecture, Past Present and Future.
Originally we planned this title to be "A Sustainability Carol." But we've been asked to stop this. So instead, we are having this title.
Good news for you - nobody in this session will sing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ff8d27c7162ed5457f0ea70b5d8ef77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf4f11306f35ad94ea2adc377728aaa/" rel="bookmark">
			shell 变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 自定义变量2.环境变量：3. 多个脚本之间共享变量4. 位置变量5. 预定义变量6. 强引用和弱引用、反引号和括号7. 变量的运算7. 小数运算8. 变量内容 删除9. 索引及切片10.内容替换11.变量替代12. 条件测试13. 是字符串比较14.总结 1. 自定义变量 定义变量： 变量名=变量值 eg：ip=192.168.1.14 引用变量：$变量名 或 ${变量名} eg：$ip ${ip} 查看变量：echo $变量名 eg: echo ${ip} 取消变量： unset 变量名 eg: unset ip 作用范围： 仅在当前shell中有效 2.环境变量： 定义环境变量：法一： export ip=192.168.1.14 法二：ip=192.168.1.14 export ip 查看当前环境变量： env | grep ip # 读取变量 ip read ip # 提示读取 read -p "please input ip " ip # 倒计时 read -t 5 -p "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf4f11306f35ad94ea2adc377728aaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca37290e38d505f71a74cb4fa6a76df6/" rel="bookmark">
			下午好~ 我的论文【yolov5】（第四期）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介模型Mosaic数据增强自适应锚框计算自适应图片缩放Focus结构CSP结构 NeckCIOU_Lossnms非极大值抑制代码最后 简介 YOLO V4没过多久YOLO V5就出来了。YOLO V5的模型架构是与V4非常相近的。
模型 Yolov5官方代码中，给出的目标检测网络中一共有4个版本，分别是Yolov5s、Yolov5m、Yolov5l、Yolov5x四个模型。
Yolov5s整体的网络结构图：
图片来自：https://zhuanlan.zhihu.com/p/172121380
（1）输入端：Mosaic数据增强、自适应锚框计算、自适应图片缩放
（2）Backbone：Focus结构，CSP结构
（3）Neck：FPN+PAN结构
（4）Prediction：GIOU_Loss
Mosaic数据增强 Mosaic数据增强的步骤包括：
选择四张不同的图像：从训练数据集中随机选择四张图像。
随机选取一个位置：随机选择一个位置在这四张图像中，这个位置将成为新的合成图像的中心点。
将这四张图像拼接：将选中位置的像素从四张图像中裁剪出来，然后将它们拼接在一起，形成新的合成图像。
调整目标框坐标：如果图像中包含目标框（用于目标检测的边界框），则需要相应地调整这些目标框的坐标，以反映合成图像中目标的新位置。
自适应锚框计算 在Yolo算法中，针对不同的数据集，都会有初始设定长宽的锚框。
在Yolov3、Yolov4中，训练不同的数据集时，计算初始锚框的值是通过单独的程序运行的。
但Yolov5中将此功能嵌入到代码中，每次训练时，自适应的计算不同训练集中的最佳锚框值。
传统的目标检测方法中，锚框通常是在图像中均匀分布的一组预定义框，但这种方法可能无法很好地适应不同尺度、长宽比或者特定场景下目标的变化。为了更好地适应不同的场景，自适应锚框计算采用一种动态的策略，根据数据集中的实际目标分布情况，调整生成锚框的尺度和长宽比。
自适应锚框计算可以采用以下策略：
数据统计分析： 对训练数据集进行分析，了解不同目标的尺度和长宽比分布情况。
动态调整锚框： 根据数据统计的结果，动态地调整生成锚框的尺度和长宽比，使其更符合实际场景中的目标形状和大小变化。
学习适应性参数： 有些方法还可以通过学习适应性参数的方式，让模型自动调整生成锚框的尺度和长宽比。
在yolov5x.yaml中查看锚定框的数据，如下：
# yolov5中预先设定了锚定框，这些锚框是针对coco数据集的，其他目标检测也适用。 # 这些框针对的图片大小是640x640，是默认的anchor大小。 # 需要注意的是在目标检测任务中，一般使用大特征图上去检测小目标，因为大特征图含有更多小目标信息， # 因此大特征图上的anchor数值通常设置为小数值，小特征图检测大目标，因此小特征图上anchor数值设置较大。 anchors: - [10,13, 16,30, 33,23] # P3/8 最大特征图上的锚框 - [30,61, 62,45, 59,119] # P4/16 中等特征图上的锚框 - [116,90, 156,198, 373,326] # P5/32 最小特征图上的锚框 在yolov5 中训练开始前，计算数据集标注信息针对默认锚定框的最佳召回率，当最佳召回率大于等于0.98时，则不需要更新锚定框；如果最佳召回率小于0.98，则需要重新计算数据集的锚定框，如果计算处理更好则更新原理的anchors。
def check_anchors(dataset, detect, thr=4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca37290e38d505f71a74cb4fa6a76df6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa7ea4cc8bf2f8d72e0326c024d6e80/" rel="bookmark">
			ubuntu22 安装 cuda12.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文是先安装显卡驱动后进行的操作
查看显卡驱动支持CUDA的最新版本12.0
nvidia-smi
检查gcc版本 gcc -v
查看系统支持的gcc版本 https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html
选择对应的安装cuda命令 https://developer.nvidia.com/cuda-toolkit-archive
下载安装文件 wget https://developer.download.nvidia.com/compute/cuda/12.0.0/local_installers/cuda_12.0.0_525.60.13_linux.run
sudo sh cuda_12.0.0_525.60.13_linux.run
空格键取消 [ ] Driver前面的X，不安装显卡驱动，然后选择install进行安装
查看目录
cd /usr/local/cuda-12.0/bin/
配置环境变量 # 1.nano ~/.bashrc 进入.bashrc文件后， 移动光标:上下左右方向键 ↑ ↓ ← → 移动到文本最下面末尾添加两行： export PATH=/usr/local/cuda-12.0/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda-12.0/lib64:$LD_LIBRARY_PATH # 2.按ctrl+x 按 Y 保存退出 # 3. 应用生效 source ~/.bashrc 查看cuda版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcadde722249ff2339e7c4e035d952dc/" rel="bookmark">
			PID 调节比例积分微分作用的特点和规律总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在自动控制系统中，P、I、D调节是比例调节，积分调节和微分调节作用。调节控制质量的好坏取决于控制规律的合理选取和参数的整定。在控制系统中总是希望被控参数稳定在工艺要求的范围内。但在实际中被控参数总是与设定值有一定的差别。调节规律的选取原则为：调节规律有效，能迅速克服干扰。
比例、积分、微分之间的联系与相匹配使用效果
比例调节简单，控制及时，参数整定方便，控制结果有余差。因此，比例控制规律适应于对象容量大负荷变化不大纯滞后小，允许有余差存在的系统，一般可用于液位、次要压力的控制。
比例积分控制作用为比例及时加上积分可以消除偏差。积分会使控制速度变慢，系统稳定性变差。比例积分适应于对象滞后大，负荷变化较大，但变化速度缓慢并要求控制结果没有余差。广泛使用于流量，压力，液位和那些没有大的时间滞后的具体对象。
比例微分控制作用：响应快、偏差小，能增加系统稳定性，有超前控制作用，可以克服对象的惯性，控制结果有余差。适应于对象滞后大，负荷变化不大，被控对象变化不频繁，结果允许有余差的系统。
在自动调节系统中，E=SP-PV。其中，E为偏差，SP为给定值，PV为测量值。当SP大于PV时为正偏差，反之为负偏差。
比例调节作用的动作与偏差的大小成正比；当比例度为100时，比例作用的输出与偏差按各自量程范围的1：1动作。当比例度为10时，按lO：l动作。即比例度越小。比例作用越强。比例作用太强会引起振荡。太弱会造成比例欠调，造成系统收敛过程的波动周期太多，衰减比太小。其作用是稳定被调参数。
积分调节作用的动作与偏差对时间的积分成正比。即偏差存在积分作用就会有输出。它起着消除余差的作用。积分作用太强也会引起振荡，太弱会使系统存在余差。
微分调节作用的动作与偏差的变化速度成正比。其效果是阻止被调参数的一切变化，有超前调节的作用。对滞后大的对象有很好的效果。但不能克服纯滞后。适用于温度调节。使用微分调节可使系统收敛周期的时间缩短。微分时间太长也会引起振荡。
参数设定的方法一般是，先比例次积分后微分的顺序进行。看曲线调参数，从调节品质的曲线逐步找到最佳参数．
在随动系统中，采用数字PI控制可以达到控制精度高、无超调、响应快、曲线拟合精度高等优点，并简化了控制电路。传统的位置式PI算法一般是可以达到基本控制要求，但必须有一个前提：控制周期要足够小。如果控制周期过长，曲线拟合差，要达到15％的曲线拟合误差有点困难，甚至可能会造成系统失控，并造成对机械设备的损伤。因此，针对本文所提到的控制系统，不能简单的采用位置式PI算法，而应该对其进行改进，以适应该控制系统的要求。
比例系数K是和每次采样的偏差值有直接关系，因此提高Kp能使系统响应较快；同时积分系数Ⅸ尾和前面所有的采样偏差值有关，由于采样周期长，每次采样的误差影响较大，因此降低积分系数对提高控制精度有好处。但提高比例系数和降低积分系数会使计算机每次输出值的变化较大。
二
PID控制(实际中还有仅用到PI和PD的控制)，就是根据系统的误差或者加上系统误差的变化率，利用比例、积分、微分计算出控制量进行控制。任何闭环控制系统的调节目标是使系统的响应达到快(快速)、准(准确)、稳(稳定)的最佳状态，PID调整的主要工作就是如何实现这一目标。
增大比例P项将加快系统的响应，其作用是放大误差的幅值，它能快速影响系统的控制输出值，但仅靠比例系数的作用，系统不能很好地稳定在一个理想的数值，其结果是虽较能有效地克服扰动的影响，但有稳态误差出现。过大的比例系数还会使系统出现较大的超调并产生振荡，使稳定性变差。
积分I项的作用是消除稳态误差，它能对稳定后有累积误差的系统进行误差修整，减小稳态误差。在积分控制中，控制器的输出与输入误差信号的积分成正比关系。对一个自动控制系统，如果在进入稳态后存在稳态误差，则称这个控制系统为有差系统。为了消除稳态误差，在控制器中必须引入积分项。积分项对误差的作用取决于时间的积分，随着时间的增加，积分项会增大。这样，即便误差很小，积分项也会随着时间的增加而加大，它推动控制器的输出向稳态误差减小的方向变化，直到稳态误差等于零。
微分具有超前作用，对于具有滞后的控制系统，引入微分控制，在微分项设置得当的情况下，对于提高系统的动态性能指标有着显著效果，它可以使系统超调量减小，稳定性增加，动态误差减小。在微分控制中，控制器的输出与输入误差信号的微分(即误差的变化率)成正比关系。自动控制系统在克服误差的调节过程中可能会出现振荡甚至失稳，其原因是由于存在有较大惯性环节或滞后的被控对象，具有抑制误差的作用，其变化总是落后于误差的变化。解决的办法是使抑制误差作用的变化“超前”，即在误差接近零时，抑制误差的作用就应该是零。微分项能预测误差变化的趋势，从而做到提前使抑制误差的控制作用等于零，甚至为负值，从而避免了被控量的严重超调，改善了系统在调节过程中的动态特性。
三
PID控制器参数调节的方法很多，概括起来有两大类：
一是理论计算法，它主要是依据系统的数学模型，经过理论计算来确定控制器参数，这种方法可能会由于系统模型的不精确性使得所得到的PID参数不能直接应用，还必须通过工程实际进行调整和修改；
二是工程方法，它主要依赖工程经验，直接在控制系统的试验中进行，该方法简单、易于掌握，在工程实际中被广泛采用。工程实际中，PID控制器参数的调节方法主要有临界比例法、反应曲线法和衰减法。3种方法各有其特点，其共同点都是通过试验，然后按照工程经验公式对控制器参数进行调节。但无论采用哪一种方法所得到的控制器参数，都需要在实际运行中进行最后调整与完善。
现在一般采用的是临界比例法，利用该方法进行PID控制器参数的调节步骤如下：
①首先预选择一个足够短的采样周期让系统工作；
②仅加入比例控制环节，直到系统对输入的阶跃响应表现出临界振荡，记下这时的比例放大系数和临界振荡周期；
③在一定的控制度下通过公式计算得到PID控制器的参数。PID控制器参数的调试实例当调速系统的各项基本参数设定后，接下来是调整PID参数以取得最理想的控制效果。
下面以控制目标为恒定转速的柴油机电站的PID调节器为例，具体说明工程法的调节步骤。
(1)比例参数：在保持转速稳定时应使用最大比例增益。增加比例增益直到转速开始波动，然后减小比例增益直到波动停止。如果一直没有转速波动，则抖动执行器连杆，然后减小比例增益直到波动停止。但比例增益太大会导致系统转速出现振荡，这时应减小比例增益。
(2)积分参数：在保持转速稳定时应使用最大积分增益。增加积分增益直到转速开始波动，然后减小积分增益直到波动停止。如果一直没有转速波动，则抖动执行器连杆，然后减小积分增益直到波动停止。但积分增益太大会导致系统转速出现振荡，这时应减小积分增益。
(3)微分参数：增加微分增益直到出现反应对负载瞬变有最小的超调量。但微分增益太大也会导致系统转速出现振荡，这时应减小微分增益。
(4)PID调整顺序：调试时，可以先调比例参数，然后调积分参数，最后调微分参数，之后再调比例参数和积分参数。如果需要，重复进行(1)～(3)步骤，直至达到理想的效果。
PID控制是工程实际中应用最为广泛的调节器控制规律，它具有结构简单、稳定性好、工作可靠、调整方便等优点。但在实际在线调试中，需要遵循一定的规律，掌握一定的调试技巧才能又快又好地将控制系统调整到最佳的效果。
温度控制系统具有非线性、时变性和滞后性的特性，并且锅炉水温控制系统中的循环水也是强干扰，增加了系统控制的复杂性，常规PID控制效果不太理想，而模糊PID参数自整定控制算法对于解决温度系统中的非线性、时变性和大延时起到明显的改善效果，对干扰也具有较好的抑制词节能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a5b8e222e7a4acdb5e46aba1049f802/" rel="bookmark">
			Yocto开发讲解系列 - 总目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Yocto开发讲解系列总纲 Yocto开发专栏前言Yocto开发专栏总目录快速上手Yocto理论篇Metadata LayerBitBake工具Toolchain或交叉编译器Linux内核和驱动模块文件系统相关devtool开发工具Toaster使用ARM相关的BSPbb文件编写知识conf配置实际平台举例技巧篇汇总实战篇汇总Yocto编译问题汇总 Yocto开发专栏前言 欢迎读者盆友光临fulinux的《Yocto开发讲解系列》专栏！
本小编有10年软件开发经历和丰富的Yocto开发经验，我最早接触Yocto是在做Freescale的imx6平台的时候，那个时候也是瞎折腾，压根就搞不清楚Yocto里的软件代码怎么改，怎么添加自己的软件项目，没有深入去研究。也仅仅是“挪用”yocto编译出来的一些库和程序、文件系统或者Toolchain SDK来满足自己的项目需求，甚至那个时候觉得还是自己的项目构建系统比较简单好用。虽然有心想研究Yocto，但是太大、太难、太复杂了，想入门都找不到门在哪，也仅仅是浅尝辄止~。但是，四年前由于实际开发要求，我又一次开始接触Yocto，感受到了他的强大和价值，决心好好系统的研究它。这期间付出了大量的时间和精力，真是让人头秃过程呐！不过现在来看Yocto真的的是太棒了，也不是那么难，对于我们做软件开发的盆友们而言简直就是福音，省去了我们交叉编译每个软件项目的时间，又容易将我们的成果固化下来，使我们的项目更加的规范和标准化（国外有很多Yocto开发人员哦）。对于开发者而言，仅仅两条终端命令即可编译出我们需要的所有镜像文件。从此，不必再纠结交叉编译的问题，公司也不必担心某个程序员离职导致项目开发无法继承的问题，即使一个N年之后没有接触的项目，仍然可以快速上手、编译和刷机运行。
我写本系列的文章也是在实际需求的驱动下，在边开发的过程中边记录和讲解，尽可能使自己处于一张白纸的基础出发和大家一起从Yocto入门到深入研究，每一篇博文尽可能带着问题出发，落实到具体的实例，结合理论和注释讲解，并将自己折腾的过程记录下来。
我想很多朋友都在思考本专栏是否能解决我的问题，是否适配我的硬件平台，我的回答是肯定的。而且为了不局限于某个特定的硬件平台和环境，本专栏从Yocto自带的官方x86-64 qemu虚拟机平台上开发和示例演示，qemu虚拟机的好处是不需要借助除了电脑之外的其他硬件环境，只要一台电脑就可以开始我们的Yocto学习和开发。
本专栏我会涉及到的一些技术和知识点，包括C/C++语言、shell、python、Qt5/QML和网络等知识，技能包括vim、git、makefile、cmake、autotools、Android、gcc/gdb和toolchain SDK等方面的技能。当然，我会在文中也会尽可能照顾到小白盆友，尽可能讲解我这么做的理由和对代码的注释。当然对于小白盆友能掌握掌握一门C语言和Linux基础操作也可以开始我们的yocto之旅。
技术和知识点都是在漫长的过程中积累起来的，重要的我觉得是一些精神品质方面的东西：较真、能折腾和不屈不挠的品质，归纳演绎、对比和逆向的思维方式。我在写本文的过程中遇到很多的坎和高山，我私下都是花了很久的时间折腾，有时候近乎绝望都要放弃了，但是还是坚持了下来了，就是希望给读者盆友呈现的是一个完整优美的演绎过程，而不是将就得过且过。有很多时候我们不怕问题本身，就是怕不知道问题是什么，无法描述，导致无法求助于网络或者他人。我希望大家在使用Yocto的过程中遇到问题时，需要善于找示例，有时候千言万语都不及一个好例子，并从中发现要点。解决问题的方向可以是多方面的，这个反向攻不破可以尝试从其他方向入手，进而对比找出问题出在哪里。读者盆友在阅读本专栏的博文的过程中遇到任何的问题和疑惑，都可以在讨论区提出来，我都会尽可能的回复和帮助解决，而不是当个高冷的博主。
我后续还会对本专栏进行系统的归类、校对和查错，尽可能丰富博文，让每一篇文档都做到理论和实践相结合，做到有的放矢、深入浅出。从问题和实际需求出发，分析问题，解决问题、并做相应的归纳和总结。
Yocto开发专栏总目录 本篇博文主要是为了方便新老读者朋友了解和查阅本专栏，将该系列进行科学分类和提取关键词，尽可能为每篇博文写个概述和要解决什么问题。
快速上手 下面几篇是用来带着大家快速上手的，熟悉下yocto。教大家如何搭建环境、安装必备的软件包，下载Yocto源码，download目录修改、开始编译，并演示运行qemu虚拟机，以及不带显示器如何登陆qemu虚拟机：
Yocto系列讲解[入门篇] 1 - 开始qemux86-64虚拟机的构建
Yocto系列讲解[入门篇] 2 - qemux86-64虚拟机运行演示
关键词：yocto qemu bitbake 入门 Yocto理论篇 让大家对Yocto有个简单的认识，介绍一些概念、目录、工具和变量等：
yocto系列讲解[理论篇]68 -Yocto版本信息查询稳定版本和EOL版本
yocto系列讲解[理论篇]6 - 什么是yocto理论篇
yocto系列讲解[理论篇]21 -yocto项目的概念(1)
yocto系列讲解[理论篇]22 -yocto项目的概念(2)
yocto系列讲解[理论篇]69 - Yocto-3.4新版本honister语法修改方法
Yocto系列讲解[理论篇]76 - 某些小技巧简单札记
关键词：bitbake recipe class 用户配置 Distro BSP Software Layer 版本 honister Metadata Layer 介绍meta layer的一些知识和示例：
yocto系列讲解[理论篇]56 - poky下目录结构
yocto系列讲解[理论篇]57 - 如何快速搜索和查找
yocto系列讲解[理论篇]3 - 添加已有硬件层实例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a5b8e222e7a4acdb5e46aba1049f802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4919f769e329c1c6c13a84bb693b9f1/" rel="bookmark">
			Transformer研究综述（BERT，GPT-3，ViT，DETR...）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近整理了一些关于Transformer模型的研究综述，从17年Google最先提出到后来Transformer横扫各大NLP任务，到后来的视觉Transformer，参考文献附在最后，大家一起交流学习。
Google在2017年首次提出Transformer模型[1]，如图1所示，该模型使用编码器和解码器的堆叠自注意层和点向全连接层并使用Attention替换了原来Seq2Seq模型中的循环结构，避免了重复和卷积。Transformer模型的出现使得NLP领域各项任务性能得到极大提升。
图1.Transformer结构模型
Devlin等人[2]引入了一个新的语言表示模型BERT，它代表来自变压器的双向编码器表示。BERT的设计是通过在所有层的左右上下文中联合条件作用，从未标记的文本中预先训练深度双向表示。只需添加一个输出层，就可以对预先训练好的BERT模型进行微调，从而为广泛的任务创建最先进的模型。BERT模型在11个自然语言处理任务上取得了最新的研究成果
Brown等人[3]在45TB压缩明文数据上预训练了基于GPT-3模型的具有1750亿个参数的巨大Transformer，并且在不同类型的下游自然语言任务上实现了强性能而无需微调。这些基于变压器的模型表现出很强的表现能力，并在自然语言处理领域取得了突破。
Parmar等人[4]把基于Attention的Transformer模型推广到具有易于处理的似然性的图像生成序列建模公式，他将每个值为[0,255]的像素编码成一个d维向量作为编码器的输入。该模型特殊之处在于decoder，每个输出像素是经过计算输入像素以及已经生成像素之间的Attention得到的。这是最先使用完整的 transformer 做图像生成的工作。
Dosovitskiy等人[5]证明了对CNN的依赖是不必要的，直接应用于图像修补序列的纯的Transformer可以很好地执行图像分类任务。在大量数据上进行预先训练，并转移到多个中型或小型图像识别基准(ImageNet, CIFAR-100, VTAB等)，视觉转换器(ViT)与最先进的卷积网络相比取得了优异的结果，而训练所需的计算资源则大大减少。
Carion等人[6]提出一种用于目标检测的Detection TRansformer (DETR）模型，该模型将目标检测任务视为一种图像到集合的问题。给定一张图像，模型必须预测所有目标的无序集合（或列表），每个目标基于类别表示，并且周围各有一个紧密的边界框。这种表示方法特别适合Transformer。因此作者使用卷积神经网络从图像中提取局部信息，同时利用Transformer编码器-解码器架构对图像进行整体推理并生成预测。在定位图像中的目标以及提取特征时，传统计算机视觉模型通常使用基于自定义层的复杂且部分手动操作的pipeline。DETR则使用更为简单的神经网络，它可以提供一个真正的端到端深度学习解决方案。
[1] Vaswani A, Shazeer N, Parmar N, et al. Attention Is All You Need[J]. arXiv, 2017.
[2] Devlin J, Chang M W, Lee K, et al. BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding [J]. 2018.
[3] Bhandare A , Sripathi V , Karkada D , et al. Efficient 8-Bit Quantization of Transformer Neural Machine Language Translation Model[J].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4919f769e329c1c6c13a84bb693b9f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c54571761227edf7faa1624b7651b5e/" rel="bookmark">
			轻量级网络模型MobileNet发展脉络（V1-V2-V3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积神经网络发展 卷积神经网络被广泛应用在图像分类、目标检测等视觉任务中，并取得了巨大的成功。然而，卷积神经网络通常需要较大的运算量和内存占用，在移动端以及嵌入式设备等资源受限的环境中受到限制，因此需要进行网络压缩。从2012年AlexNet网络提出获得image net分类任务第一名后，深度学习模型迅速发展，网络层数不断加深，2015年提出的ResNet的准确率首次超越人类，但同时网络层数也达到了152层。
MobileNet系列是谷歌推出的轻量级网络模型，旨在不过多牺牲模型性能的同时大幅度减小模型的尺寸和加快模型的运算速度。
MobileNet V1 MobileNet V1基于一种流线型结构使用深度可分离卷积来构造轻型权重深度神经网络。主要用于移动端以及嵌入式设备。模型包含两个权衡延迟和准确率的全局超参数-宽度乘法器(width multiplier)和分辨率乘法器(resolution multiplier),允许模型构造器能够根据特定问题选择合适大小的模型。
深度可分离卷积 深度可分离卷积是一种将标准卷积分解成深度卷积以及一个1x1的卷积即逐点卷积。能够有效减少计算量以及模型的大小。如图所示，一个标准的卷积(a)被分解成深度卷积(b)以及1x1的逐点卷积(c)。 一个 3x3 Conv 被拆分成了 3x3 Depthwise Conv和 1x1 Conv
常规卷积操作 假设输入特征图的尺寸（H, W, D）是
DF⋅DF⋅M ，可以得到：
- 输入特征图尺寸：DF⋅DF⋅M
- 卷积核尺寸： DK * DK * M * N
- 输出特征图尺寸：DF⋅DF⋅ N
- 运算量为： DK⋅DK⋅M⋅N⋅DF⋅DF
有 N 个卷积核，每个大小为 DK⋅DK⋅M ，每个卷积核作用于 M 个通道。也就是1个 Filter 连接 3 个 input channels。
深度卷积 深度卷积每个卷积核只处理1个输入特征通道，而不是M个输入特征通道，这样大大减少了运算量。输入特征图的尺寸（H, W, D）是 DF⋅DF⋅M ，可以得到如下公式：
- 输入特征图尺寸：DF⋅DF⋅M
- 卷积核尺寸： DK⋅DK⋅1⋅M
- 输出特征图尺寸：DF⋅DF⋅M
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c54571761227edf7faa1624b7651b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0e38525a7b7a6133b56ca4c261ccb7/" rel="bookmark">
			移动端深度学习部署：TFlite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.TFlite介绍 （1）TFlite概念 tflite是谷歌自己的一个轻量级推理库。主要用于移动端。 tflite使用的思路主要是从预训练的模型转换为tflite模型文件，拿到移动端部署。 tflite的源模型可以来自tensorflow的saved model或者frozen model,也可以来自keras。 （2）TFlite优点 用Flatbuffer序列化模型文件，这种格式磁盘占用少，加载快
可以对模型进行量化，把float参数量化为uint8类型，模型文件更小、计算更快。
可以对模型进行剪枝、结构合并和蒸馏。
对NNAPI的支持。可调用安卓底层的接口，把异构的计算能力利用起来。
（3）TFlite量化 a.量化的好处 较小的存储大小：小模型在用户设备上占用的存储空间更少。例如，一个使用小模型的 Android 应用在用户的移动设备上会占用更少的存储空间。 较小的下载大小：小模型下载到用户设备所需的时间和带宽较少。 更少的内存用量：小模型在运行时使用的内存更少，从而释放内存供应用的其他部分使用，并可以转化为更好的性能和稳定性。 b.量化的过程
tflite的量化并不是全程使用uint8计算。而是存储每层的最大和最小值，然后把这个区间线性分成 256 个离散值，于是此范围内的每个浮点数可以用八位 (二进制) 整数来表示，近似为离得最近的那个离散值。比如，最小值是 -3 而最大值是 6 的情形，0 字节表示 -3，255 表示 6，而 128 是 1.5。每个操作都先用整形计算，输出时重新转换为浮点型。下图是量化Relu的示意图。
Tensorflow官方量化文档
c.量化的实现
训练后动态量化
import tensorflow as tf
converter = tf.lite.TFLiteConverter.from_saved_model(saved_model_dir)
#converter.optimizations = [tf.lite.Optimize.DEFAULT]
converter.optimizations = [tf.lite.Optimize.OPTIMIZE_FOR_SIZE]
tflite_model1 = converter.convert()
open("xxx.tflite", "wb").write(tflite_model1)
训练后float16量化
import tensorflow as tf
converter = tf.lite.TFLiteConverter.from_saved_model(saved_model_dir)
converter.optimizations = [tf.lite.Optimize.DEFAULT]
converter.target_spec.supported_types = [tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb0e38525a7b7a6133b56ca4c261ccb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03efde37cc77decac7dab70e65a76fd/" rel="bookmark">
			PyTorch模型部署流程(ONNX Runtime)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型部署指让训练好的深度学习模型在特定环境中运行的过程。模型部署会面临的难题：
运行模型所需的环境难以配置。深度学习模型通常是由一些框架编写，比如 PyTorch、TensorFlow。由于框架规模、依赖环境限制，框架不适合在手机、开发板等生产环境中安装。 深度学习模型的结构通常比较大，需要大量算力才能满足实时运行需求，运行效率需要优化。 因为这些难题的存在，模型部署不能靠简单的环境配置与安装完成。目前模型部署有一条流行的流水线：
为了让模型最终能够部署到某一环境上，可以使用任意一种深度学习框架来定义网络结构，并通过训练确定网络中的参数。之后，模型的结构和参数会被转换成一种只描述网络结构的中间表示，一些针对网络结构的优化会在中间表示上进行。最后，用面向硬件的高性能编程框架（如 CUDA，OpenCL）编写，能高效执行深度学习网络中算子的推理引擎会把中间表示转换成特定的文件格式，并在对应硬件平台上高效运行模型。
创建PyTorch模型
a.配置环境
# 创建预安装 Python 3.7 的名叫 deploy 虚拟环境
conda create -n deploy python=3.7 -y
# 进入虚拟环境
conda activate deploy
# 安装 Gpu 版本的 PyTorch
# 从官网中选择合适的配置并复制下载路径---https://pytorch.org/get-started/locally/
cconda install pytorch torchvision cudatoolkit=11.3 -c pytorch
# 安装 ONNX Runtime, ONNX, OpenCV
pip install onnxruntime onnx opencv-python
b.创建PyTorch模型
import os
import cv2
import numpy as np
import requests
import torch
import torch.onnx
from torch import nn
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c03efde37cc77decac7dab70e65a76fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39de2a93924775b922f9d43d582c4c1f/" rel="bookmark">
			Qualcomm® AI Engine Direct 使用手册（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qualcomm® AI Engine Direct 使用手册（3） 3.3 环境设置 4. 后端4.1 后端特定页面4.1.1 数字信号处理器4.1.2 HTP 3.3 环境设置 Linux
满足 Linux 平台依赖性后，可以使用提供的 envsetup 设置用户环境.sh 脚本。
在 Linux 主机上打开命令 shell 并运行：
$ source ${QNN_SDK_ROOT}/bin/envsetup.sh 这将设置/更新以下环境变量：
QNN_SDK_ROOT
Python路径
小路
LD_LIBRARY_PATH
${QNN_SDK_ROOT} 代表 Qualcomm® 的完整路径AI Engine Direct SDK 根目录。
QNN API 标头位于 ${QNN_SDK_ROOT}/include/QNN 中。
工具位于${QNN_SDK_ROOT}/bin/x86_64-linux-clang中。
目标特定后端和其他库位于${QNN_SDK_ROOT}/lib/*/中。
TensorFlow 设置
请使用 https://pypi.org/project/tensorflow/2.10.1/ 将 TensorFlow 安装为独立的 Python 模块 如果安装 tf-1.15.0 请参阅上面的 python3.6 安装部分。确保TensorFlow
在你的 PYTHONPATH 中使用这个测试代码：
$ python3 -c "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39de2a93924775b922f9d43d582c4c1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3f028eb4b152a04b419ecd8732e248/" rel="bookmark">
			论文阅读之《Underwater scene prior inspired deep underwater image and video Enhancement (UWCNN)》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pattern Recognition(2020)
作者：Chongyi Li（这是水下图像增强界公认的大佬~我的偶像啊）
2020/01至今，新加坡南洋理工大学计算机科学与工程学院MMLAB研究员。
2018/10-2020/01，香港城市大学计算机科学系博后研究员，与教授Sam Kwong (IEEE fellow)一起工作。
2016/12-2017/12，澳大利亚国立大学工程研究学院联合攻读博士，师从Fatih Porikli教授(IEEE Fellow) 。
2014/09-2018/07，天津大学电气与信息工程学院攻读博士学位，师从郭继昌教授。
研究兴趣包括人工智能，机器学习，计算机视觉和图像处理，特别是在图像和视频恢复和增强领域。
Abstract 在水下场景中，波长相关的光吸收和散射会降低图像和视频的可见度。退化的水下图像和视频影响水下场景中模式识别、视觉理解和关键特征提取的准确性。文章提出了一种基于水下场景先验的水下图像增强卷积神经网络模型（UWCNN）。该模型不需要估计水下成像模型的参数，而是直接重构清晰的潜在水下图像，这得益于水下场景先验，可用于合成水下图像训练数据。此外，基于轻量级的网络结构和有效的训练数据，UWCNN模型可以很容易地扩展到水下视频进行逐帧增强。具体来说，将水下成像物理模型与水下场景的光学特性相结合，先合成不同类型的水下图像数据集，然后，针对每种水下场景类型，设计一个轻量级的CNN模型，并通过相应的训练数据进行训练。最后，将该模型直接扩展到水下视频增强。在真实和合成的水下图像和视频上的实验表明，该方法能够很好地适用于不同的水下场景。
Introduction 研究动机：
光在水下传播过程受到衰减导致颜色通道衰减。传统的图像增强方法在处理水下图像和视频时表现出局限性。此外，由于缺乏足够和有效的训练数据，基于深度学习的水下图像和视频增强方法的性能不能与基于深度学习的解决方案(例如图像分类、分析、分割、超分辨率、识别等)相匹配。为了获得更高的水下视觉质量，提高高水平视觉任务的性能，有必要开发水下图像合成和增强方法。
主要工作：
文中提出了一种新的水下图像合成算法，算法使用水下场景先验，为水下图像和视频增强提供基于数据驱动的解决方案。提出的方法被证明对不同的水类型具有优越的鲁棒性、准确性和灵活性。
贡献：
(1)提出一种新的基于水下场景先验的水下图像合成算法，该算法能够模拟多种退化的水下图像。
(2)提出了一种新的CNN模型，通过联合优化多项损失，在保留原始结构和纹理的同时，重建清晰的水下图像。
(3)提出方法可以很好地推广到具有不同颜色和可见性特征的合成和真实世界的水下图像和视频。
Related work Proposed method 首先将图像转换到HSI颜色空间。然后，其在HSI颜色空间中的饱和度和强度分量的范围被归一化为[0,1]。
在将调整后的图像转到RGB空间。UWCNN可以有效的消除真实水下图像中存在的绿色失真并改善对比度，经过后处理的UWCNN进一步提高了饱和度和亮度，揭示了更多的细节信息。
水下图像合成算法
缺乏地面真实的水下图像数据集限制了基于深度学习的水下图像增强和质量评估的发展。为了填补这一空白，提出了一种基于水下成像物理模型和水下场景光学特性的水下图像合成算法。这是第一个基于物理模型的水下图像合成算法，可以模拟不同的水类型和退化程度，这是对水下图像和视频增强发展的重要贡献。
（1）通过不同的衰减系数来描述海洋和沿海不同类型的水体。
（2）通过修改水下图像恢复模型中的光波和场景点X到相机的距离d(x)来模拟不同深度的水下图像成像过程。
Experiment Conclusion 文章提出了一个基于水下场景先验的水下图像和视频增强网络UWCNN。在合成和真实水下图像验证实验表明了该方法的鲁棒性和有效性。网络只包含十个卷积层和每个卷积层的16个特征映射，可以快速训练。在我们的网络中使用的残差学习、密集连接和SSIM损失经证明都提升了网络性能。
我的想法 存在的问题
1.通过水下成像模型设置不同的衰减系数模拟水下图像训练模型有待于验证准确性。
2.模型对于衰减严重的图像存在过度补偿的问题。
3.合成的数据很难模拟到各种衰减程度的水下图像，导致模型整体的泛化性不强。
4.论文采用MSE，PSNR，SSIM等传统有参考图像评价指标，不具有广泛性，而针对水下图像的无参考质量评价指标也是研究的一个热点，作者完全规避掉了。
后期可以尝试的改进
1.根据水下合成数据集的思想，尝试各种监督学习图像增强框架。
2.利用残差学习实现无监督学习，解决无参考图像水下图像增强问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/379ba4750883f0e85307045e84e92286/" rel="bookmark">
			NLP论文阅读记录 - | 使用GPT对大型文档集合进行抽象总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言0、论文摘要一、Introduction二.相关工作2.1Summarization2.2 神经网络抽象概括2.2.1训练和测试数据集。2.2.2 评估。 2.3 最先进的抽象摘要器 三.本文方法3.1 查询支持3.2 文档聚类3.3主题句提取3.4 语义分块3.5 GPT 零样本总结 四 实验效果4.1数据集4.2 对比模型4.3实施细节4.4评估指标4.5 实验结果 五 总结 前言 ABSTRACTIVE SUMMARIZATION OF LARGE DOCUMENT COLLECTIONS USING GPT（2306） no code
paper
0、论文摘要 本文提出了一种抽象摘要方法，旨在扩展到文档集合而不是单个文档。我们的方法结合了语义聚类、主题集群内的文档大小缩减、集群文档的语义分块、基于 GPT 的摘要和串联以及每个主题的组合情感和文本可视化，以支持探索性数据分析。
使用 ROGUE 汇总分数将我们的结果与现有最先进系统 BART、BRIO、PEGASUS 和 MoCa 进行统计比较，结果显示，BART 和 PEGASUS 在 CNN/Daily Mail 测试数据集上以及 BART 在 Gigaword 上的性能在统计上相当测试数据集。
这一发现很有希望，因为我们认为文档集合摘要比单个文档摘要更具挑战性。最后，我们讨论了如何在 GPT 大语言模型中解决规模问题，然后提出未来工作的潜在领域。
一、Introduction 对变压器注意力机制和大语言模型（LLM）的研究已经产生了令人印象深刻的成果，特别是在自然语言处理（NLP）和文本分析方面。法学硕士，如 BERT Kenton 等人。 [2019]，BART Lewis 等人。 [2020]，GPT Radford 等人。 [2018]、Bard Manyaka [2023] 和 LLaMA Meta AI [2023] 已经产生了重要的研究和公众影响。尽管它们具有最先进的性能，但广泛、通用用途的目标使得某些任务仅得到部分解决。本文重点研究多文档集合的抽象概括。像 GPT 这样的系统可以执行抽象摘要，但目前仅限于 512 到 4,096 个术语的最大输入。文档集合可以轻松地由数百个包含数千个术语的文档组成。需要一种智能方法来管理规模，以利用法学硕士的抽象总结能力。我们还建议应用情感分析和可视化来增强摘要，并以交互式且易于理解的视觉格式呈现附加属性。我们的方法执行以下步骤，将 GPT 的抽象摘要方法扩展到大型文档集合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/379ba4750883f0e85307045e84e92286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d324609b2714d9a5345ac006c84c040a/" rel="bookmark">
			Qualcomm® AI Engine Direct 使用手册（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qualcomm® AI Engine Direct 使用手册（1） 1. 介绍1.1 目的1.2 惯例1.3 平台差异1.4 发行说明 2 概述2.1 特征2.2 软件架构2.3 集成工作流程2.4 Linux 上的开发人员2.5 Windows 上的集成工作流程2.6 Windows 上的开发人员 1. 介绍 1.1 目的 本文档提供 Qualcomm® AI Engine Direct 软件开发套件 (SDK) 的参考指南。
笔记
Qualcomm® AI Engine Direct 在源代码和文档中也称为 Qualcomm 神经网络 (QNN)。
1.2 惯例 函数声明、函数名称、类型声明、文件名、目录名称和库 名称以不同的字体显示。例如：#include
命令和代码示例出现在特殊格式的代码部分中。例如：
output = (input - offset) * scale. 数学表达式出现在特殊格式的数学部分中。例如：
y = x + 1 环境变量前面带有 $，例如 $QNN_SDK_ROOT。
1.3 平台差异 Qualcomm® AI Engine Direct 支持 Windows 和 Linux 平台。之间有几个区别 Linux 和 Windows 系统：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d324609b2714d9a5345ac006c84c040a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1edd39bb663759a94364f6307741737/" rel="bookmark">
			ROS2 学习09--ros 中的通信接口的定义以及如何创建自定义msg、srv和action文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ROS系统中，无论话题还是服务，或者我们后续将要学习的动作，都会用到一个重要的概念——通信接口。
通信并不是一个人自言自语，而是两个甚至更多个人，你来我往的交流，交流的内容是什么呢？为了让大家都好理解，我们可以给传递的数据定义一个标准的结构，这就是通信接口。
接口的定义
接口的概念在各个领域随处可见，无论是硬件结构还是软件开发，都有广泛的应用。
比如生活中最为常见的插头和插座，两者必须匹配才能使用，电脑和手机上的USB接口也是，什么Micro-USB、TypeC等等，都是关于接口的具体定义。
软件开发中，接口的使用就更多了，比如我们在编写程序时，使用的函数和函数的输入输出也称之为接口，每一次调用函数的时候，就像是把主程序和调用函数通过这个接口连接到一起，系统才能正常工作。
更为形象的是图形化编程中使用的程序模块，每一个模块都有固定的结构和形状，只有两个模块相互匹配，才能在一起工作，这就很好的讲代码形象化了。
所以什么是接口，它是一种相互关系，只有彼此匹配，才能建立连接。
回到ROS的通信系统，它的主要目的就是传输数据，那就得让大家高效的建立连接，并且准确包装和解析传输的数据内容，话题、服务等机制也就诞生了，他们传输的数据，都要符合通信接口的标准定义。
比如摄像头驱动发布的图像话题，由每个像素点的R、G、B三原色值组成，控制机器人运动的速度指令，由线速度和角速度组成，进行机器人配置的服务，有配置的参数和反馈的结果组成等等，类似这些常用的定义，在ROS系统中都有提供，我们也可以自己开发。
这些接口看上去像是给我们加了一些约束，但却是ROS系统的精髓所在。举个例子，我们使用相机驱动节点的时候，完全不用关注它是如何驱动相机的，只要一句话运行，我们就可以知道发布出来的图像数据是什么样的了，直接开始我们的应用开发；类似的，键盘控制我们也可以安装一个ROS包，如何实现的呢？不用关心，反正它发布出来的肯定是线速度和角速度。
ROS通信接口 接口可以让程序之间的依赖降低，便于我们使用别人的代码，也方便别人使用我们的代码，这就是ROS的核心目标，减少重复造轮子。
ROS有三种常用的通信机制，分别是话题、服务、动作，通过每一种通信种定义的接口，各种节点才能有机的联系到一起。
语言无关 为了保证每一个节点可以使用不同语言编程，ROS将这些接口的设计做成了和语言无关的，比如这里看到的int32表示32位的整型数，int64表示64位的整型数，bool表示布尔值，还可以定义数组、结构体，这些定义在编译过程中，会自动生成对应到C++、Python等语言里的数据结构。
话题通信接口的定义使用的是.msg文件，由于是单向传输，只需要描述传输的每一帧数据是什么就行，比如在这个定义里，会传输两个32位的整型数，x、y，我们可以用来传输二维坐标的数值。
服务通信接口的定义使用的是.srv文件，包含请求和应答两部分定义，通过中间的“—”区分，比如之前我们学习的加法求和功能，请求数据是两个64位整型数a和b，应答是求和的结果sum。
动作是另外一种通信机制，用来描述机器人的一个运动过程，使用.action文件定义，比如我们让小海龟转90度，一边转一边周期反馈当前的状态，此时接口的定义分成了三个部分，分别是动作的目标，比如是开始运动，运动的结果，最终旋转的90度是否完成，还有一个周期反馈，比如每隔1s反馈一下当前转到第10度、20度还是30度了，让我们知道运动的进度。
标准接口 大家可能好奇ROS系统到底给我们定义了哪些接口呢？我们可以在ROS安装路径中的share文件夹中找到，涵盖众多标准定义，大家可以打开几个看看。
一、ROS2创建自定义msg、srv和action文件的思路 ROS2通过自带rosidl_default_generators包来为自定义的msg、srv和action文件生成各个语言的头文件！
ROS2通过在CMakeLists.txt中调用新增的宏rosidl_generate_interfaces来为msg、srv和action文件生成各个语言的头文件！而这个宏的实现定义在rosidl_default_generators包。
二、基本数据类型 利用ROS2的原始基本数据类型和已有的数据类型，可以自定义需要的数据类型。
2.1 ROS2的基本原始数据类型
ROS2目前支持的内置类型：
每种内置类型都可以用来定义数组：
所有比其ROS定义更宽松的类型均由软件强制执行ROS的范围和长度约束。
使用数组和有界类型的消息定义示例：
int32[] unbounded_integer_array int32[5] five_integers_array int32[&lt;=5] up_to_five_integers_array string string_of_unbounded_size string&lt;=10 up_to_ten_characters_string string[&lt;=5] up_to_five_unbounded_strings string&lt;=10[] unbounded_array_of_string_up_to_ten_characters each string&lt;=10[&lt;=5] up_to_five_strings_up_to_ten_characters_each 三、创建自定义的msg、srv和action 3.1 创建功能包 在本文中，将在自己的包中创建自定义的.msg、.srv和.action文件，然后在另外的包中使用它们，这两个包应该在同一个工作空间dev_ws/src目录中,然后运行以下命令创建一个新包。
ros2 pkg create --build-type ament_cmake learning_inteface tutorial_interfaces是新包的名称。注意，它是一个CMake包，目前还没有办法在纯Python包中生成.msg、.srv和.action文件。但是，可以在CMake包中创建自定义接口，然后在Python节点中使用它。
将.msg、.srv和.action文件保存在自己的包中是一种很好的做法。在dev_ws/src/learning_inteface 目录下创建：
mkdir msg srv action 3.2 创建自定义接口文件 3.2.1 自定义msg文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1edd39bb663759a94364f6307741737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ae4b513a1708c61bfabf6145fee72a/" rel="bookmark">
			Ubuntu 常用命令之 ll 命令用法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📑Linux/Ubuntu 常用命令归类整理
ll是ls -l的别名，用于在Ubuntu系统中列出目录的详细信息。ls命令用于列出目录内容，-l选项则以长格式显示，包括文件类型、权限、链接数、所有者、组、大小、最后修改时间以及文件或目录名。
这是ll命令的基本格式 ll [选项]... [文件]... 这是ll命令的一些常用选项：
-a：显示所有文件，包括隐藏文件-h：以易读的方式显示文件大小-r：反向排序-t：按修改时间排序 下面是一些使用ll命令的例子： 👇列出当前目录的详细信息： ll 👇列出指定目录的详细信息： ll /path/to/directory 👇列出所有文件（包括隐藏文件）的详细信息： ll -a 👇以易读的方式显示文件大小： ll -h 👇按修改时间排序： ll -t 👇反向排序： ll -tr 👇组合使用多个选项： ll -lathr 这个命令将以长格式列出所有文件，以易读的方式显示文件大小，按修改时间排序，并反向排序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7498c7826663dd54c0c6aa47e7d313f/" rel="bookmark">
			4.docker镜像及相关命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 查看所有镜像 docker images
1.1 基本用法
1.2 docker images -q 只显示所有镜像ID
1.3 docker images -f [筛选条件] -q 只显示符合条件的所有镜像ID
1.4 docker images --no-trunc 显示完整的IMAGE ID
1.5 docker images --format [模板] 使用模板
2 从源拉取镜像 docker pull
3 从源查找镜像 docker search
4 移除本地镜像 docker rmi
4.1 基本使用
4.2 强制删除 -f
5 将镜像保存为tar文件 docker save
6 将docker save生成的tar文件加载为镜像 docker load
7 查看镜像的元数据 docker inspect
8 查询镜像的多架构信息 docker manifest inspect
9 查看镜像历史记录(分层) docker history
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7498c7826663dd54c0c6aa47e7d313f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1882778f2d37cf2d7a58afe7616569e/" rel="bookmark">
			c# WPF 应用程序在屏幕上居中显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 xaml &lt;Window ... WindowStartupLocation="CenterScreen"&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c583ed082467847eeac91e7a46e3a537/" rel="bookmark">
			vue实现excel上传并显示数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue中实现excel上传并显示数据
效果如下：
vue--excel上传
具体代码如下：
&lt;template&gt; &lt;div class="app-container"&gt; &lt;input ref="excel-upload-input" class="excel-upload-input" style="width: 300px;margin-left: 10px" type="file" accept=".xlsx, .xls" @change="handleClick" /&gt; &lt;div class="drop" @drop="handleDrop" @dragover="handleDragover" @dragenter="handleDragover"&gt; 批量导入：拖拽excel文件或者 &lt;el-button :loading="loading" style="margin-left:16px;" size="mini" type="primary" @click="handleUpload"&gt; 浏览 &lt;/el-button&gt; &lt;/div&gt; &lt;el-table :data="excelData.results" border highlight-current-row style="width: 100%;margin-top:20px;"&gt; &lt;el-table-column v-for="item of excelData.header" :key="item" :prop="item" :label="item"/&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import XLSX from 'xlsx' export default { name: 'UploadExcel', data() { return { loading: false, excelData: { header: null, results: null } } }, methods: { handleUpload() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c583ed082467847eeac91e7a46e3a537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9632adaa8c8969414e4c0c27c374f8/" rel="bookmark">
			AM@常用等价无穷小及其证明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 abstract常用等价无穷一览👺派生和拓展幂指函数中常用等价无穷小小结 其他精度更高的等价无穷小记忆技巧 常用的等价无穷小和推导👺例 abstract 介绍常用等价无穷小及其推导
等价无穷小和泰勒公式
等价无穷小可以由泰勒公式推导(通用),通过泰勒公式的变形,可以获得各式各样的等价无穷小
如果不使用泰勒公式,直接从极限的角度和函数的基本性质来证明,从中也可以学习到一些技巧,开阔思路
常用等价无穷一览👺 x → 0 x\to{0} x→0时的等价无穷小
x ∼ sin ⁡ x ∼ tan ⁡ x ∼ arcsin ⁡ x ∼ arctan ⁡ x ∼ ln ⁡ ( 1 + x ) ∼ e x − 1 x\sim\sin{x}\sim{\tan{x}}\sim\arcsin{x}\sim{\arctan{x}}\sim{\ln(1+x)}\sim{e^{x}-1} x∼sinx∼tanx∼arcsinx∼arctanx∼ln(1+x)∼ex−1 ( 1 + x ) α − 1 ∼ α x (1+x)^{\alpha}-1\sim{\alpha{x}} (1+x)α−1∼αx; ( 1 − x ) α − 1 ∼ α ( − x ) = − α x (1-x)^{\alpha}-1\sim{\alpha(-x)=-\alpha{x}} (1−x)α−1∼α(−x)=−αx; 1 + x n − 1 ∼ 1 n x \sqrt[n]{1+x}-1\sim{\frac{1}{n}x} n1+x ​−1∼n1​x, 1 + x − 1 − x ∼ x \sqrt{1+x}-\sqrt{1-x}\sim{x} 1+x ​−1−x ​∼x 1 − cos ⁡ x ∼ 1 2 x 2 1-\cos{x}\sim{\frac{1}{2}x^2} 1−cosx∼21​x2 a x − 1 ∼ x ln ⁡ a a^{x}-1\sim{x\ln{a}} ax−1∼xlna log ⁡ a ( 1 + x ) ∼ 1 ln ⁡ a x \log_a(1+x)\sim \frac{1}{\ln{a}}x loga​(1+x)∼lna1​x 以下3组函数各组内函数互为反函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be9632adaa8c8969414e4c0c27c374f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e30353c8687eec0f4fadd09bc0fd1ae/" rel="bookmark">
			C语言-数组（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 在C语言中，数组是一种相同数据类型元素的集合，存储在连续的内存位置上。数组允许将相关的数据组合在一起，以便更方便地进行操作和管理。
2、举例 要声明一个数组，需要指定数组的数据类型和数组的名称，然后使用方括号[]指定数组的大小。例如，下面是声明一个包含5个整数的数组的方式：
int numbers[5]; 在上面的例子中，我们声明了一个名为"numbers"的整数数组，它可以存储5个整数。
数组中的元素可以通过索引访问，索引从0开始，并按顺序递增。例如，要访问数组中的第一个元素，可以使用以下语法： numbers[0] 还可以在声明数组时初始化数组的元素。例如，下面是声明一个整数数组并初始化其元素的方式
int numbers[] = {10, 20, 30, 40, 50}; 在上面的例子中，声明了一个整数数组，将初始值为10、20、30、40和50的元素依次赋给数组。
数组还可以用于多维数据的表示，例如二维数组。二维数组是一种表格形式的数据结构，可以通过行和列来访问元素。例如，下面是声明一个3行4列的二维整数数组的方式：
int matrix[3][4]; 在上述例子中，我们声明了一个名为"matrix"的二维整数数组，它具有3行和4列。
通过使用合适的索引，您可以访问和操作数组中的元素，以及进行各种算法和逻辑操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a64b6829e7076428cd213f9010c3a78/" rel="bookmark">
			EGD价格操纵攻击事件foundry复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其它相关内容可见个人主页 EGD价格操纵攻击事件的介绍见：EGD价格操纵攻击原理分析–phalcon+etherscan)
foundry的介绍可见：编写测试 - Foundry 中文文档 (learnblockchain.cn)
参考链接：EGD Finance 价格操纵攻击事件分析 - YINHUI’s BLOG (yinhui1984.github.io)
1. 前情提要以及思路介绍 EGD-Finance项目的主要实现目的：质押USDT一段事件，可提取奖励EGD Token,前文已经说明，由于闪电贷从Pancake LPs池子中借出了大量的USDT，而奖励的EGD Token数量一定程度上依赖于池子中两种代币的数量，从而导致了价格操纵攻击。
由于对foundry不太熟悉，加上没有写过大的solidity项目；
攻击的复现我们分为三部分进行实现：
借用闪电贷，实现价格的操纵实现EGD项目的逻辑，质押后兑换奖励闪电贷实现价格操纵，利用EGD兑换的逻辑漏洞，实现套利 2. 闪电贷实现价格操纵 对于想调用的外部合约函数，不仅仅需要它的地址，同时把对应需要调用的函数写成接口interface()的形式，interface()中不写具体的函数代码，函数访问修饰都是external.solidity中没有浮点型的数，一般乘以的百分比，可以学习一下一般怎么写的 pragma solidity ^0.8.10; import "forge-std/Test.sol"; interface IERC20 { function balanceOf(address owner) external view returns (uint256); function approve(address spender, uint256 value) external returns (bool); function transfer(address to, uint256 value) external returns (bool); } interface IEGD_Finance { function getEGDPrice() external view returns (uint); } interface IPancakePair { function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external; } //Pancake借出USDT的池子 address constant EGD_USDT_LPPool = 0xa361433E409Adac1f87CDF133127585F8a93c67d; // EGD 代理合约的地址 address constant EGD_Finance = 0x34Bd6Dba456Bc31c2b3393e499fa10bED32a9370; // USDT代币的地址 address constant usdt = 0x55d398326f99059fF775485246999027B3197955; contract pricemanipulation is Test{ function setUp() public{ //fork stake()函数调用前的状态 vm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a64b6829e7076428cd213f9010c3a78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f798caf58704c83cdee8412873387d/" rel="bookmark">
			git stash 用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.作用 这个命令可以将当前的工作区域的代码暂存起来，在需要的时候再恢复使用。
2. 使用场景 在使用git的时候，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，这时，我们不得不暂停手头上的工作，切换到另外的分支去修复错误，我们往往会把完成一半的代码commit提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来，这样的话往往log上会有大量不必要的记录。
如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用 git stash 就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用git stash pop将以前一半的工作代码恢复回来就可以了。
3. 细节与注意 默认情况下，git stash会缓存下列文件：
添加到暂存区的修改（staged changes）Git跟踪的但并未添加到暂存区的修改（unstaged changes） 但不会缓存以下文件：
在工作目录中新的文件（untracked files）被忽略的文件（ignored files） git stash命令提供了参数用于缓存上面两种类型的文件。
使用-u或者--include-untracked可以stash untracked文件。
使用-a或者--all命令可以stash当前目录下的所有修改。
4. 基本用法 保存：git stash &gt; 将当前工作区和暂存区的更改保存到一个栈结构
&gt; git stash
&gt; 将当前工作区和暂存区的更改保存到一个栈结构，并附带一个信息
&gt; git stash save "message"
&gt; 将当前工作区和暂存区的更改保存到一个栈结构，包括新增的文件 &gt; git stash -u
&gt; git stash --include-untracked
&gt; 将当前工作区和暂存区的更改保存到一个栈结构，包括新增的文件以及忽略的文件
&gt; git stash -a
&gt; git stash --all 查看栈中保存的更改：git stash list &gt; 查看栈中所有保存的更改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f798caf58704c83cdee8412873387d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ebc52386c3d0e6f18726fa09a024b84/" rel="bookmark">
			Sentinel 流量治理组件教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 官网首页：home | Sentinel (sentinelguard.io)
随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。
基本概念 资源 资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。
只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。
规则 围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。
功能和设计理念 流量控制 流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：
流量控制有以下几个角度:
资源的调用关系，例如资源的调用链路，资源和资源之间的关系；运行指标，例如 QPS、线程池、系统负载等；控制的效果，例如直接限流、冷启动、排队等。 Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。
熔断降级 除了流量控制以外，降低调用链路中的不稳定资源也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积。这个问题和 Hystrix 里面描述的问题是一样的。
Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。
系统负载保护 Sentinel 同时提供系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。
针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。
快速开始 Sentinel 是分为两个部分
控制台（Dashboard）：控制台主要负责管理推送规则、监控、集群限流分配管理、机器发现等。核心库（Java 客户端）：不依赖任何框架/库，能够运行于 Java 7 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。 控制台 在这里我们看下控制台的使用
首先获取控制台 jar 包：Release v1.8.6 · alibaba/Sentinel (github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ebc52386c3d0e6f18726fa09a024b84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bb82404118d2d9cdfdd860ff57e0874/" rel="bookmark">
			前端实现文件下载(a标签文件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文件下载两种方案 链接地址下载后台接口返回文件信息跨域问题，setAttribute设置文件名不生效 链接地址下载 const link = document.createElement('a'); const url = `url下载链接地址` link.href = url; link.setAttribute('download', '文件名'); //window下载窗口名称自定义 document.body.appendChild(link); link.click(); document.body.removeChild(link); 后台接口返回文件信息 await api.downloadFile(item).then(res =&gt; { //接口请求 const link = document.createElement('a'); //window.URL.createObjectURL() 方法用于创建一个表示指定对象的 URL，需要传入一个 Blob 对象或者 File 对象作为参数 link.href = window.URL.createObjectURL(new Blob([res]));//将内容转为blob格式 link.setAttribute('download', '文件名'); document.body.appendChild(link); link.click(); document.body.removeChild(link); }) 跨域问题，setAttribute设置文件名不生效 如果在setAttribute时发现a标签中download属性发生改变但是window文件窗口的名称未改变，那么可能是因为服务端返回的响应头中设置了文件名。这时候，浏览器会优先使用服务端返回的文件名作为下载文件的名称，而忽略前端设置的下载属性
//解决方案 //在服务端返回的响应头中设置一个特殊的 Content-Disposition 字段，强制浏览器使用前端设置的下载属性 Content-Disposition: attachment; filename='文件名' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8972c309f100a2d949dce33cf149442e/" rel="bookmark">
			Lede/Openwrt 系统编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述
安装系统依赖
Clone 源码
调整配置
修改feeds文件，添加需要的插件
修改默认IP(可选，根据自己需要)
修改默认主题
1.删除lede的luci源中的argon旧版本主题(需先feeds update):
2.拉取最新的18.06分支的argon主题源码到 package/downloads/luci-theme-argon :
3.修改lede的默认主题,位置 feeds/luci/collections/luci/Makefile :
生成系统配置
编译系统
二次编译
附录
概述 如果你想拥有一个属于自己的路由器操作系统，Openwrt是一个不错的选择，本文描述了如何编译一个Lede系统，并附 树莓派4B的 config文件
安装系统依赖 sudo apt update -y sudo apt full-upgrade -y sudo apt install -y ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \\ bzip2 ccache cmake cpio curl device-tree-compiler fastjar flex gawk gettext gcc-multilib g++-multilib \\ git gperf haveged help2man intltool libc6-dev-i386 libelf-dev libfuse-dev libglib2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8972c309f100a2d949dce33cf149442e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e7bbc69b247923deb1ef89efce2cc2/" rel="bookmark">
			如何使用localStorage、sessionStorage、cookie进行本地储存数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		localStorage、sessionStorage 和 cookie 都是浏览器提供的用于在客户端存储数据的方式：
相同点：
都可以在客户端存储数据，使得数据能够在用户关闭浏览器后仍然存在。都可以存储字符串类型的数据，也可以使用其他数据类型，但最终都被转换为字符串。 不同点：
存储数据的大小：localStorage 和 sessionStorage 不限制存储的数据量，而 cookie 的大小限制为4KB。存储数据的生命周期： localStorage：没有过期时间，数据在页面卸载后依然存在。sessionStorage：与页面会话关联，当页面会话结束（用户关闭浏览器或标签页）时，数据被清除。cookie：可以设置过期时间，如果不设置过期时间，那么默认的生命周期与浏览器会话相关，即当浏览器关闭时，数据将被清除。 数据的可用性： localStorage 和 sessionStorage 仅在当前源（即当前域名和协议）的文档中可用。这意味着如果你在同源的不同标签页或窗口中打开新窗口，它们可以访问并共享 localStorage 或 sessionStorage。cookie 可以被发送到不同的源（即不同的域名和协议），但默认情况下，它们只能被设置它们的域访问。然而，可以通过设置 "domain" 和 "path" 属性来更改此行为。 数据的访问：localStorage 和 sessionStorage 不支持 "SameSite" 或 "SameBrowser" 选项，这意味着它们不能像 cookie 一样被限制在特定的源或跨源使用。数据的操作：localStorage 和 sessionStorage 支持立即可读写的数据存储，而 cookie 需要使用特定的函数来读取和设置。数据的兼容性：不是所有的浏览器都支持 localStorage 和 sessionStorage，但几乎所有的现代浏览器都支持 cookie。 一，cookie 的使用 1，首先加载模块 npm i js-cookie -S 2，在使用cookie的页面上进行引入 import Cookies from 'js-cookie' 3，使用方法 创建一个在整个网站上有效的Cookie Cookies.set('name', 'value'); 创建一个从现在起7天后过期的cookie，在整个站点上有效： Cookies.set('name', 'value', { expires: 7 }); 创建一个过期的cookie，对当前页面的路径有效： Cookies.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91e7bbc69b247923deb1ef89efce2cc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7453a13e33dcc5dcc8aa1d81b41aab9f/" rel="bookmark">
			按钮背景图片闪动5秒然后停住
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按钮背景图片闪动5秒，然后停住：
@keyframes flashing { 0%, 100% { filter: grayscale(0%); } 50% { filter: grayscale(50%); } } .alarmBg { color: #E93557; background: url('../../../assets/images/newui/alarmBg.png') no-repeat; border: none; // animation: flashing 5s infinite; animation: flashing 0.4s linear 13; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc1fc2ab8e563b6706c7e53bea4adb79/" rel="bookmark">
			论文解读：Exploring Complementary Strengths of Invariant and Equivariant Representations
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小样本学习论文解读：Exploring Complementary Strengths of Invariant and Equivariant Representations for Few-Shot Learning
摘要 teach：这篇文章尽管标题带小样本学习，但是并没有设计一套小样本学习的算法，而是用一种数据增强或者数据增广的方式生成更多的样本。通过样本之间的训练或者学习来去提升这个模型的泛化能力。用积累的数据去学习一个更好的泛化能力的模型，让这个模型能够泛化到新颖的类别当中。
1.介绍 创新点1：不变性(3.2.1)与等价性(3.2.2)的设计 方法概述:形状代表不同的变换 ，颜色代表不同的类 。虽然不变特征提供了更好的辨 别 ，但等变特征帮助我 们了解数据流形的内部结 构 。 这些互补的表征帮助我们更好地泛化到只有少数训练样本的新任务。通过共同利用 等变和不变特征的优势，我们的方法在基线(下 一行)上实现了显著的改进。
效果展示(如果论文效果比较好可以把效果对比图直接放在摘要)：
创新点2：多头知识蒸馏(参考3.2.3) 2.Related Works(略) 3.Our Approach 总体框架图 每个Ti都是一种变换，论文给出的为16种(包括旋转变换，按一定比例的图像变换的融合)，每一种变换都给上一个标签，这个标签是人为设定的，比如说16种变换，对应的标签为0-15；因此除了图片本身含有的标签外，还有人为给予的标签。这16种变换为网络输入的数据。
LCE为标准分类器的监督，这是利用每一个样本对真实标签的监督，即不管一张图片经过如何的选择变换，都用它本身真实的标签(比如说这张图为一只猫，不管如何旋转或者裁剪，这种图片的真实标签还是一只猫)
LEQ(Enforcing Equivariance)就是"等价性"，这里用到了对于每一种变换，人为所给定的标签
LINV(Enforcing Invariance)为"不变性"，这里构建一个Memory Bank，即一个非常大的负样本，来进行对比学习。在这里一张图片i有M个变换，这是属于正样本，其他图像相对这张图片i来说就是负样本，可以用来构建Memory Bank，这个Memory Bank量可以很大。
其中对比学习的方式就是：不同变换的同一张图片"拉近"，不同图片就"拉远"。
总的来说就是引入了两种损失函数：一种就是等价性的损失，一种就是不变形的损失。等价性的损失就是把图像进行不同的几何变换来进行监督；不变性损失就是构建了大的Memory Ban，即大的负样本，通过与正样本的对比学习，使得模型的泛化能力或者类的边界更有效。
3.1. Problem Formulation 标准的图像分类模型 LCE为标准分类器的监督，这是利用每一个样本对真实标签的监督，即不管一张图片经过如何的选择变换，都用它本身真实的标签(比如说这张图为一只猫，不管如何旋转或者裁剪，这种图片的真实标签还是一只猫)
LCE与LEQ两个损失函数的比较 LCE与LEQ这两个损失函数其实都是一样的，都是标准监督的损失函数，只不过预测结果与标签不同
LCE的预测结果是由网络得到，而LEQ的预测结果是由网络得到；
LCE的标签是图片原本的标签(比如说这张图片不管经过怎么样的变换，还是一只猫)，而LEQ的标签是人为设定的(见3.2中Equivariance人为设定的标签)
损失函数解读：
结果为：对每个类别分别预测的概率
为：这种图片的实际类别(即标签)所预测的概率
交叉熵损失函数中包含了一个最基础的部分：
参考资料：
在线：
【pytorch】交叉熵损失函数 nn.CrossEntropyLoss()-CSDN博客
离线：📎【pytorch】交叉熵损失函数 nn.CrossEntropyLoss()-CSDN博客 (2023_12_14 15_34_02).html
3.2. Injecting Inductive Biases through SSL 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc1fc2ab8e563b6706c7e53bea4adb79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd48f91fce38637909d1d608697a1b21/" rel="bookmark">
			分享一个项目——Sambert UI 声音克隆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、运行ipynb二、数据标注三、训练四、生成总结 前言 原教程视频
项目链接
运行一个ipynb，就可操作
总共四步
1）运行ipynb
2）数据标注
3）训练
4）生成
一、运行ipynb 等运行完毕后，获得该链接打开
二、数据标注 准备一段自己念书的音频【MP3格式】（最好不要是唱歌的，亲测生成效果会比较扭曲）
1）上传音频
2） 角色命名
3） 开始标注
三、训练 1）点击角色选择
2）设置训练步数 60 ~ 100即可
3）开始训练
四、生成 1）选择推理模型
2） 输入文本
3）开始语音合成
总结 一个能够简单克隆声音的小demo, 里面可能有个基座模型，应该是用台湾省同胞的声音练的，总体效果会有点台湾腔。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a67d701c0471fca161746f740d4cc9e2/" rel="bookmark">
			为什么说Transformer可以代替seq2seq？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是Transformer 《Attention Is All You Need》是一篇Google提出的将Attention思想发挥到极致的论文。这篇论文中提出一个全新的模型，叫 Transformer，抛弃了以往深度学习任务里面使用到的 CNN 和 RNN。目前大热的Bert就是基于Transformer构建的，这个模型广泛应用于NLP领域，例如机器翻译，问答系统，文本摘要和语音识别等等方向。
2. Transformer结构 2.1 总体结构 Transformer的结构和Attention模型一样，Transformer模型中也采用了 encoer-decoder 架构。但其结构相比于Attention更加复杂，论文中encoder层由6个encoder堆叠在一起，decoder层也一样。
不了解Attention模型的，可以回顾之前的文章：Attention
每一个encoder和decoder的内部结构如下图：
encoder，包含两层，一个self-attention层和一个前馈神经网络，self-attention能帮助当前节点不仅仅只关注当前的词，从而能获取到上下文的语义。decoder也包含encoder提到的两层网络，但是在这两层中间还有一层attention层，帮助当前节点获取到当前需要关注的重点内容。 2.2 Encoder层结构 首先，模型需要对输入的数据进行一个embedding操作，也可以理解为类似w2c的操作，enmbedding结束之后，输入到encoder层，self-attention处理完数据后把数据送给前馈神经网络，前馈神经网络的计算可以并行，得到的输出会输入到下一个encoder。
2.2.1 Positional Encoding transformer模型中缺少一种解释输入序列中单词顺序的方法，它跟序列模型还不不一样。为了处理这个问题，transformer给encoder层和decoder层的输入添加了一个额外的向量Positional Encoding，维度和embedding的维度一样，这个向量采用了一种很独特的方法来让模型学习到这个值，这个向量能决定当前词的位置，或者说在一个句子中不同的词之间的距离。这个位置向量的具体计算方法有很多种，论文中的计算方法如下：
其中pos是指当前词在句子中的位置，i是指向量中每个值的index，可以看出，在偶数位置，使用正弦编码，在奇数位置，使用余弦编码。
最后把这个Positional Encoding与embedding的值相加，作为输入送到下一层。
2.2.2 Self-Attention 接下来我们详细看一下self-attention，其思想和attention类似，但是self-attention是Transformer用来将其他相关单词的“理解”转换成我们正在处理的单词的一种思路，我们看个例子：
The animal didn't cross the street because it was too tired
这里的 it 到底代表的是 animal 还是 street 呢，对于我们来说能很简单的判断出来，但是对于机器来说，是很难判断的，self-attention就能够让机器把 it 和 animal 联系起来，接下来我们看下详细的处理过程。
首先，self-attention会计算出三个新的向量，在论文中，向量的维度是512维，我们把这三个向量分别称为Query、Key、Value，这三个向量是用embedding向量与一个矩阵相乘得到的结果，这个矩阵是随机初始化的，维度为（64，512）注意第二个维度需要和embedding的维度一样，其值在BP的过程中会一直进行更新，得到的这三个向量的维度是64。
计算self-attention的分数值，该分数值决定了当我们在某个位置encode一个词时，对输入句子的其他部分的关注程度。这个分数值的计算方法是Query与Key做点成，以下图为例，首先我们需要针对Thinking这个词，计算出其他词对于该词的一个分数值，首先是针对于自己本身即q1·k1，然后是针对于第二个词即q1·k2。
接下来，把点成的结果除以一个常数，这里我们除以8，这个值一般是采用上文提到的矩阵的第一个维度的开方即64的开方8，当然也可以选择其他的值，然后把得到的结果做一个softmax的计算。得到的结果即是每个词对于当前位置的词的相关性大小，当然，当前位置的词相关性肯定会会很大。
下一步就是把Value和softmax得到的值进行相乘，并相加，得到的结果即是self-attetion在当前节点的值。
在实际的应用场景，为了提高计算速度，我们采用的是矩阵的方式，直接计算出Query, Key, Value的矩阵，然后把embedding的值与三个矩阵直接相乘，把得到的新矩阵 Q 与 K 相乘，乘以一个常数，做softmax操作，最后乘上 V 矩阵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a67d701c0471fca161746f740d4cc9e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb0c678e0b5653033dcc1f9ba7577df/" rel="bookmark">
			Python处理excel和绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理excle import pandas as pd def excel_read(path,sheet): df = pd.read_excel(path, sheet_name=sheet) #读取第三列的数据 column_data = df.iloc[:, 3] column_data_list = column_data.tolist() return column_data_list if __name__ == '__main__': list1 = excel_read(r"D:\Book1.xlsx","Sheet2") print(list1) list2 = excel_read(r"C:\Users\fuwh2\Downloads\机器借用情况 1.xlsx","Sheet1") print(list2) for item in list1: if item in list2: continue else: print(item) 绘图 import matplotlib.pyplot as plt import seaborn as sns def draw(): # 输入数据 x = ['3.7', '3.8', '3.9', '3.10', '3.11', '3.12'] y1 = [24, 24, 30, 58, 19, 9] # y2 = [5, 8, 11, 14, 16, 19, 23] # 设置颜色代码 color1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccb0c678e0b5653033dcc1f9ba7577df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f832d51afc1d419a0b5c7d95ccfdaf66/" rel="bookmark">
			如何在海思 Hi3519AV100上移植YOLOV3 （1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HI3519AV100包含了深度学习的NNIE内核，算力为2TOPS，是目前同等算力下性价比最好的平台之一。公司产品已经可以实时运行YOLO V3，写这个系列的原因在于帮助我们开放平台下的开发者用户及公司新入职员工的使用培训，可以更快速的使用开发板进行模型的部署。
打个小广告：
海思hi3519av100开发板链接：
https://item.taobao.com/item.htm?spm=a230r.1.14.117.4afe75a61WreAX&amp;id=586610485052&amp;ns=1&amp;abbucket=1#detail
除了SDK与底板图纸之外我们提供了EMMC文件配置和摄像头采集到RFCN深度神经网络的物体识别和HDMI显示的完整代码，帮助开发者快速部署模型。
此篇为开篇，主要介绍都需要哪些关联的软件需要安装，环境怎么去搭建。
首先说明的是海思的文档中其实写的特别特别详细，大家可以去看详细的文档，我们重新写这个的目的是减少时间，只把关键的几个点写出来，如果怕安装出问题，可以阅读海思的详细文档。
海思相关的文档在 ..\Hi3519A V100R001C02SPC010\ReleaseDoc\zh\01.software\board\SVP 中的 “HiSVP 开发指南.pdf”。
Hi3519A目前支持的深度学习框架只有caffe，那两个文件是必不可少的：训练完成后 *.caffemodel，*.prototxt是必须要有的。
海思提供了一个mapper工具和一个simulation工具可以对模型进行量化和仿真。这两个工具都在海思提供的 RuyiStudio中，所以后面使用的软件就是RuyiStudio，以下简称RS。
RS是不需要安装的，直接解压就可以用，但是需要提前装好很多配置环境。
提前需要装的部分如下：
1. CUDA
2. CuDnn
3. OpenCV
4. wget
5. MinGW-w64
6. Msys
7. Python3.5
8. Caffe
9. VisualStudio2015
此部分软件为了方便使用我们会整理后上传到百度网盘。到时连接会贴到此博文中。
另外一点是如果不想出错就完全按照海思要求安装版本。
环境配置的过程后面有时间的时候会补充进来，着急用的朋友就看海思的文档吧。
---- YOLO V3移植-----
模型移植之前我们首先要做几件事情，
1）首先得有自己的模型或者用官方提供的模型也可以；
2）模型导入到RS中，做模型的mapper，生成 *.wk文件；
3）做mapper后的模型文件的仿真验证；
4）部署到板卡中运行。
一般在SVP中已经有YOLO V3的demo，至少我们提供的板卡上是有这个文件的。
直接在RS中打开工程文件，SDK中的路径为
..\Hi3519A V100R001C02SPC010\SVP_PC\HiSVP_PC_V1.2.0.5\software\sample_runtime
工程名称为.cproject .project
快速上手：
1）工程文件中首先找到*.cfg文件，在 sample_runtime\data\detection\yolov3 中，
此文件用来配置caffemodel转 *.wk 文件前的基本配置。
查看方式：右键—open with—mapper configuration editor
三个部分组成：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f832d51afc1d419a0b5c7d95ccfdaf66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c08b8edc56b23126a17fbb7f6959b7/" rel="bookmark">
			海思SD3403,SS928/926,hi3519dv500,hi3516dv500移植yolov7,yolov8（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过调试后中终于在hi3519dv500和hi3516dv500两个平台中都实现的算法验证。同时可以做自己定制的算法模型的移植了，下面是两个移植案例效果。
识别运行时间上做了对比和统计，具体的可以看下面的表格。
总体来说速度还是比较快的，Yolo系列算法实时运行是几乎没有任何问题。
训练到量化过程已经全部验证完，期待在项目中使用。
下一篇会介绍如何修改yolov7的源码进行训练。
涉及到技术细节的部分因为商业用途，有部分省略。如需相关技术服务项目合作可私信联系。
-------------------------------分割线----------------------------- 目标识别跟踪模块，支持热红外、可见光主流多光谱视频输入与目标识别跟踪等功能，支持人、车、船、飞机、无人机等目标的实时识别与多模式跟踪，跟踪过程中支持镜头自动变倍、伺服随动。支持整机产品的定制。
​​​
​​​​
​​
算法应用视频—— 无人机识别跟踪
=======================未经作者许可严禁转载===================================
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b5e2f1db0ca7c0712a142c83fb1cba1/" rel="bookmark">
			【大数据实训】python石油大数据可视化(八)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2014到2020年石油加工产品产量数据处理分析
一、任务描述
石油是工业的命脉。
一直到2020年，我国原油产量基本处于平稳的状态，大部分原油来自国外进口；中国原油加工产量在华东、东北地区占比较大，华南地区相对较少。原油的加工企业对原油的加工有很大的影响，中国石油营业收入及净利润也十分可观。
本课题的目标是用python编程，抓取有关网站的数据，并将获取数据保存到csv文件和excel文件中，然后使用python对数据进行清洗及处理，利用python可视化，结合数据处理与分析，获得数据的统计分析结果。
图1 2014-2020年中国原油加工产量信息
**二、**数据获取与清洗
1、数据描述
数据来源：2020年中国原油加工产业现状分析、2019年中国原油加工量产量及格局分析（当前网络上暂无2020年数据，故爬取了2019年数据）
数据获取：2014-2020年中国原油产量统计、中国各地区原油加工比例。
2、使用工具
python是一种功能丰富的语言，它拥有一个强大的基本类库和数量众多的第三方扩展。本次报告，使用到的库有：
1）requests库
2）BeautifulSoup4库
3）csv库
4）pandas库
3、数据获取步骤
第一步：从网页上获取HTML内容。
第二步：分析网页内容并提取有用数据
第三步：将获得的数据写入Excel文件。
4、程序代码
获取数据代码如下 文件夹名称：报告
文件名称: 石油加工产品产量分析
图2 爬虫程序及运行结果
将获得各省原油加工产量以及各种油产量放入csv文件中，使用的函数代码如下： 图3 存储函数
5 数据清洗后保存到Excel和csv文件，使用的函数、Excel文件截图，存储位置如图4、5、6、7所示：
图4 数据清洗并存储函数
图5 各种油的产量的excel文件截图
图6 各省油产量的excel文件截图
图7 存储位置截图
（默认存储到与py文件同目录的位置）
三**、**数据处理和分析
1、数据可视化工具
python是一种功能丰富的语言，它拥有一个强大的基本类库和数量众多的第三方扩展。报告中使用Matplotlib库以及pyecharts库的Map库实现了数据可视化。
2、先用python 对2014-2020年各种油产量以及2019年各省油产量数据进行可视化处理，所用的函数代码以及柱状图如图8、9所示。
图8 使用函数代码截图
图9 各种油加工产量以及各省份加工原油产量
3、统计各种加工油产量以及各省市油产量数据，可视化后，画出折线图、饼状图如图10所示使用的代码如图11所示：
注明：代码本将七种油逐年产量数据均画出饼状图、折线图，因图数量过多，不全予以展示。
图10 各种油加工产量以及各省份加工原油产量
图11 使用的函数代码
4、特别地，我们安装pyecharts库将2019年各省油的产量在整个中国地图中呈现出来，观看时只需要将鼠标移到对应的省份，这样观看更加直观和方便。（其中山西、重庆、贵州、西藏、台湾暂无数据）代码及成果如下，结果如图
四**、**关键问题及对策
1、*爬取时的问题*
问题描述：找到要爬取的网站，找到网站上目标表格。于是参考了第二次大作业所用的爬取数据的代码，但是出现了爬取数据不完整的问题：
图13 用爬虫抓取数据
解决方法：
通过查询网上资料，我发现了问题主要出在fillUnivlist函数中，把tds增加到可以容纳整个列表后问题就可以解决，并且将string改为text以加强函数的稳定性，如图14 ：
图14
2**、** 实际编写代码时遇到代码过长问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b5e2f1db0ca7c0712a142c83fb1cba1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/51/">«</a>
	<span class="pagination__item pagination__item--current">52/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/53/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>