<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6cc6b3d89d8c2ae96055d65f5336017/" rel="bookmark">
			yocto构建镜像分析(基于STM32MP1157)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yocto构建自定义镜像 本文将基于STM32MP157开发板分析yocto构建镜像的流程，并刨析开发板自带的自定义镜像菜谱是如何设计的，最后尝试编写自己的自定义镜像。
yocto创建镜像流程 OpenEmbedded核心和其他Yocto项目层包括一些样例镜像。这些镜像提供用于典型Linux操作系统栈的根文件系统配置。所有核心镜像菜谱都继承自core-image类,core-image类自己从image类继承。所有镜像设置IMAGE_INSTALL变量来指定什么包被安装进根文件系统。IMAGE_INSTALL可以指定单个包，也可以指定包组（package group）。core-image类提供的默认值安装packagegroup-core-boot和packagegroup-base-extended这两个包组。默认创建启动到控制台的工作的根文件系统。
如果要增加包到根文件系统，可以在conf/local.conf中添=追加IMAGE_INSTALL_append变量，eg:
IMAGE_INSTALL_append+=" demo" 注意双引号中间前面要加空格。
IMAGE_INSTALL_append_pn-&lt;image&gt; : 可以向特定镜像追加包/包组
CORE_IMAGE_EXTRA_INSTALL: core-image类定义的变量，可以使用该变量增加包到所有继承自core-image的镜像。
定制镜像菜谱必须继承image或者core-image类。
inherit core-image 下面介绍一些和创建镜像相关的变量
PACKAGE_CLASSES :在构建环境的conf/local.conf中控制使用什么包管理系统用于构建镜像
IMAGE_FSTYPES：设置一个或者多个由类提供的文件系统类型, tar ext4…
IMAGE_LINGUAS ：添加语言支持到根文件系统或者镜像中
IMAGE_ROOTFS_SIZE:以KB定义被创建的根文件系统镜像大小。
IMAGE_ROOTFS_ALIGNMENT:以KB定义根文件系统镜像的对齐。
IMAGE_ROOTFS_EXTRA_SPACE:以KB定义增加额外可用空间到根文件系统镜像。
IMAGE_OVERHEAD_FACTOR:这个变量指定用于根文件系统镜像的乘数。
EXTRA_USERS_PARMS:用于增加和修改组、用户和密码等命令。
IMAGE_PREPROCESS_COMMAND:在实际根文件系统镜像被创建前进一步地定制根文件系统
ROOTFS_POSTPROCESS_COMMAND：在其已经被构建系统创建后进一步地定制根文件系统
分析STM32MP1开发板bootfs vendorfs userfs生成过程 STM32MP1 yocto里面创建了除rootfs外的三个镜像，bootfs vendorfs 和userfs。
三个bb文件均引用了st-image-partitions.inc，下面先从它开始分析：
st-image-partitions.inc
inherit core-image # Disable flashlayout generation for the partition image as this is supposed # to be done only for complete image ENABLE_FLASHLAYOUT_CONFIG = "0" # Disable image license summary generation for the partition image as this is # supposed to be done only for complete image ENABLE_IMAGE_LICENSE_SUMMARY = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6cc6b3d89d8c2ae96055d65f5336017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/385713236ba613b7827beb3529af6368/" rel="bookmark">
			Linux系统内核概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 内核是一种开源的类 Unix 操作系统宏内核。
Linux 内核是 Linux 操作系统的主要组件，也是计算机硬件与其进程之间的核心接口。它负责两者之间的通信，还要尽可能高效地管理资源。之所以称为内核，是因为它在操作系统中就像果实硬壳中的种子一样，并且控制着硬件的所有主要功能。内核的用途主要有以下 4 项工作：
内存管理：追踪记录有多少内存存储了什么以及存储在哪里进程管理：确定哪些进程可以使用中央处理器、何时使用以及持续多长时间设备驱动程序：充当硬件与进程之间的调解程序/解释程序系统调用和安全防护：从流程接受服务请求 在正确实施的情况下，内核对于用户是不可见的，它在自己的小世界(称为内核空间)中工作，并从中分配内存和跟踪所有内容的存储位置。用户所看到的内容则被称为用户空间。这些应用通过系统调用接口(SCI)与内核进行交互。
Linux系统内核概述
1. 内核简介 单内核体系设计、但充分借鉴了微内核设计体系的优点，为内核引入模块化机制。
Linux 内核的重要组成部分，主要有以下几部分：
kernel内核核心，一般为 bzImage通常在 /boot 目录下，名称为 vmlinuz-VERSION-RELEASEkernel object内核对象，一般放置于 /lib/modules/VERSION-RELEASE/[ ] ==&gt; N ==&gt; 不编译进内核[M] ==&gt; M ==&gt; 编译为模块文件[*] ==&gt; Y ==&gt; 编译进内核辅助文件(ramdisk)initrdinitramfs 2. 内核模块 2.1 uname 命令 使用格式
uname [OPTION]... 参数解释
-n 显示节点名称-r 显示VERSION-RELEASE-s 内核名称-v 内核版本-n 节点名-m 硬件名称-i 硬件平台-p 处理器类型-o 操作系统 # uname -m i686 # uname -r 2.6.32-573.22.1.el6.i686 # uname -a Linux MyServer 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/385713236ba613b7827beb3529af6368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af09f2be1f710f0b3a3ce8e749994076/" rel="bookmark">
			Ansible环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 环境搭建： 首先准备三台虚拟机一台为受管主机
三台ip为 master 192.168.190.132 node1 192.168.190.133 node2 192.168.190.133 编辑三个虚拟机的hosts文件
vim /etc/hosts #添加如下内容 192.168.190.132 master 192.168.190.133 node1 192.168.190.133 node2 在添加结束之后可以通过ping命令去测试
在所有的主机上添加用户
useradd xiaoming # 设置密码 echo 123 | passwd --stdin xiaoming #### 在master主机上添加admin账号 useradd admin echo 123 | passwd --stdin admin 通过ssh服务设置免密登录
通过ssh-keygen生成公私钥
将生成的公钥文件传给master的小明用户
验证是否登录成功
[admin@master .ssh]$ ssh xiaoming@master [xiaoming@master ~]$ # 两次操作的命令 ssh-keygen ssh-copy-id xiaoming@master 之后配置免密登录node1和node2上的xiaoming用户
[xiaoming@master ~]$ exit logout Connection to master closed. [admin@master .ssh]$ ssh-copy-id xiaoming@node1 /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af09f2be1f710f0b3a3ce8e749994076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057cb4a9ac5b5e683173275fbb9450a7/" rel="bookmark">
			【hdfs/hadoop】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 hadoop/hdfs
#在master中 cd /usr/hadoop/hadoop-2.7.3 ./sbin/start-dfs.sh #下面两个效果一样 hdfs dfs -ls /test hadoop fs -ls /test hdfs dfs -cat /test/xxx.txt hdfs dfs .... #命令大全 https://blog.csdn.net/weixin_42073408/article/details/118308009 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cdf41c05e9e91dc5d03c6ab269d4a42/" rel="bookmark">
			git导出两个不同版本之间差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开git bash窗口,需要注意的是，以下导出命令必须在本地项目的根目录执行(git init目录)
2.git log 查看提交版本id（commit）
3.使用命令git diff 45b46bb7867c97b53fed34c63b121950344f7e9d 4e3585cd3b4437d97518f9ba780c5326ac6bcd03 --name-only | xargs tar -zcvf diff.tgz -C 指定目录
4.也可以使用 git archive --format=zip HEAD $(git diff --name-only 45b46bb7867c97b53fed34c63b121950344f7e9d 4e3585cd3b4437d97518f9ba780c5326ac6bcd03) &gt; diff.zip
转自：git导出两个不同版本之间差异 - 八戒vs - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8bc448466b61c6cfa53916eaeffa796/" rel="bookmark">
			uniapp自定义导航 vue3实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我用到的自定义导航是单页面使用，所以多页面使用建议自行查阅。首先代码，里面一定要引入uview哟，配套使用Uview的样式组件，引入方式自行查阅官方文档。
Form 表单 | uView Vue3.0 横空出世，继承uView1.0意志，再战江湖，风云再起！ (fsq.pub)
实现效果如下：（ps:由于本人CSS样式没学好，借助了uview布局实现）
步骤如下：
1、更改page.json该页面的style，主要是navigationStyle设为custom
{ "path": "pages/xxx/xxx/index", "style": { "navigationBarTitleText": "设备", "enablePullDownRefresh": false, "navigationStyle":"custom" } 2、回到当前页面布置布局
&lt;template&gt; &lt;view&gt; &lt;!-- 自定义导航栏 --&gt; &lt;view class="navBarBox"&gt; &lt;!-- 状态栏占位 --&gt; &lt;view class="statusBar" :style="{ paddingTop: statusBarHeight + 'px' }"&gt;&lt;/view&gt; &lt;!-- 真正的导航栏内容 --&gt; &lt;view class="navBar"&gt; &lt;u-row gutter="16"&gt; &lt;u-col :span="4"&gt; &lt;u-image @click="handleBack" src="@/static/images/table/back.svg" width="50rpx" height="50rpx"&gt; &lt;/u-image&gt; &lt;/u-col&gt; &lt;u-col :span="5"&gt;设备&lt;/u-col&gt; &lt;u-col :span="2"&gt; &lt;!-- 新增设备 --&gt; &lt;u-image src="@/static/images/table/add.svg" width="60rpx" height="60rpx"&gt;&lt;/u-image&gt; &lt;/u-col&gt; &lt;u-col :span="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8bc448466b61c6cfa53916eaeffa796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82d793b1a9d86f511019b4ce050e4b8/" rel="bookmark">
			lombok详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 lombok_exploreval、var@NoNull@Cleanup@ToString@Getter、@Setter@EqualsAndHashCode@NoArgsConstructor、@AllArgsConstructor@RequiredArgsConstructor@Data@Value@Builder@SneakyThrows@Synchronized@With lombok_explore 探索lombok在项目中的应用
val、var val和var都表示定义一个变量，并且回进行类型推导
val: 定义的是final变量var: 定义的是非final变量 public class ValAndVarExample { public void valExample(){ //相当于final String example = "Hello world"; val example = "hello world"; // example = "hello china"; //Cannot assign a value to final variable System.out.println(example); } public void varExample(){ var example = "hello world"; example = "hello china"; System.out.println(example); } public static void main(String[] args) { ValAndVarExample valAndVarExample = new ValAndVarExample(); valAndVarExample.valExample(); valAndVarExample.varExample(); } } @NoNull 用来指定某个方法入参不能为null。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f82d793b1a9d86f511019b4ce050e4b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab05207c48679af6f98ac4b852e0e306/" rel="bookmark">
			如何将U盘设置为启动盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先我们将封装好系统的启动u盘插入USB口中，启动电脑.。
2.当显示屏闪过第一个开机画面的时候，我们迅速连续按下键盘上的快捷启动热键，联想为F12，其他品牌按下表自行查询快捷启动热键或联系电脑品牌客服询问。
3.此时显示屏会弹出一个选择的蓝色窗口，通过↑↓选择“Enter Setup”进入BIOS设置（也可以在电脑出现开机画面的时候连续按下“Esc”键进入BIOS设置，部分电脑可能会是Delete、F2或F6）。
3.进入BIOS设置中，将Boot第一启动顺序设定为USB Hard Disk（或USB-HDD、USB-FDD、USB-ZPI，USB-CD-ROM 与你制作的U盘工作模式对应）,BIOS能识别接受的有：驱动程序（ZIP）/ 软盘（FDD） / 光盘（CD-ROM）/ 还有硬盘（HDD），设定的方法是回车然后选择USB Hard Disk选项。
4.设定完毕后按“ESC”键，退回BIOS主界面，选择Save and Exit（也可以按下F10保存退出）。
5.然后重启电脑，U盘插上就会自动从U盘启动了。
注:部分电脑设置可能不太一样，但都是可以依葫芦画瓢解决的。
本文转载自天乐博客：https://blog.361s.cn/73.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dff1d6c36c4d9f4e60057b13c649b35/" rel="bookmark">
			EMP电磁脉冲射频发射器制作教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EMP简介：
电磁脉冲(electromagnetic pulse，EMP) ，电磁脉冲是一种物理现象，主要能干扰破坏电子设备。电磁脉冲是一种极强的电磁场。这个电磁场会对用电设备或电子设备发生耦合，并产生具破坏性的电流和浪涌。EMP实际上是一种电磁波发生器。它能发射一定频率的电磁波。军用级EMP利用炸药爆炸或化学燃料燃烧产生的能量，通过微波器件转换成高功率微波辐射，能发射峰值功率在吉瓦以上、频率为1吉赫～300吉赫的脉冲微波束，在裸露的导电体（例如裸露的电线、印刷电路板的印制线）上急剧产生数千伏的瞬变电压，对大量电子设备造成无法挽回的损坏。
原理：
EMP产生带负电的电子、产生极强的电磁场（俗称电磁脉冲)，这个电磁场可能会与用电设备或电子设备发生耦合，并产生破坏性的电流和浪涌。
信号对敏感电路干扰的能力需要有几个属性。大多数微处理器由工作电压非常低的场效应晶体管(FET)组成。一旦工作电压过大，灾难性故障就即将来临。在实际中是不能宽恕这种过压错误的，因为控制部件之间为超细金属氧化物。在这些控制部件之间产生的任何过压，必然产生永久性破坏，在某些严重的场合下，还会导致程序消失。由外部电源产生这些破坏性电压需要电压的波动，这种波动能够在电路板的走线上、元器件和其他关键点上产生持续的能量波动。因此，对电路来说，外部信号的能量必须足够高，因为在这个波长上，几何尺寸是能量非常重要的一部分。微波具有快速的上升时间(等效为傅里叶频率高)，且持续时间短，因此会获得最好的效果。所需要的能量是巨大的，这个能量势必会产生更大的破坏。一种良好的度量方法是能量除以波长的商。
大功率的微波脉冲能够通过下面介绍的几种方法产生。爆炸物的磁力线压缩驱动虚阴极振荡器，其一般的相关物能够仅从几百焦耳产生千兆瓦的峰值功率。最初始的电流变成脉冲送入电感器，而电流的峰值被成形的爆炸物电荷压缩，因而捕获磁力线并产生很高能量的电流源。利用极高速度的爆炸物如三甲基三硝胺(cyclotrimethyltrinitramine)，它的派生词是PETN或相当能量的爆炸物，线圈沿着其轴向和径向压缩。这些捕获的磁力线产生能量增长，通过微波激励(HEPM)变成最终的大功率峰值的脉冲。像原子能初始爆炸一样，磁力线压缩需要爆炸充电器的精确定时。对于磁力线压缩，克里管(Krytron)开关或类似开关可以用来代替大多数的增强抗辐射的Sprytrons, Sprytrons用在原子
能初始反应，在原子能初始反应中，由固有的裂变物质产生电离辐射。虚阴极振荡器也可以很方便地由小型Marx脉冲发生器产生200^}4ookV的激励。快速的上升电流以及大的峰值功率能够产生强大的微波脉冲。其他方法包括爆炸丝(exploding wire)。这种方法允许能量流向LCR电路，因为爆炸丝在附近蒸发，反馈线的爆炸快速地中断峰值注人电流。一个上升速度很快、能量非常大的脉冲就产生了，这种方法能够产生电磁脉冲(EMP) 微波脉冲对于破坏敏感电子电路是一个非常优秀的候选者，简单地说EMP可以干扰手机，监视器等各种电子设备。
分类：
1.马克思发生器:利用电容并联充电、再串联放电产生高压的装置
2.射频发生器:（本次教程介绍的就是这种）
3.感应式脉冲电磁炮:是一种电流很高的线圈式电磁炮
材料：
蓄电池，高压整流器，电容，电阻（拆一个电蚊拍可以完美获取这些电子元件）
电感线圈（漆包铜线 1mm 1m）
计算机（演示使用）
制作教程：
1.将准备好的电蚊拍拆解，取出电路元件。
2.把电感线圈绕成矿泉水瓶差不多粗细的线圈，将两端绝缘层漆刮掉（在线圈上再绕一圈盘一个蚊香状线圈发射感应范围更广）。
3.将高压整流器与电感线圈一端连接，另一端头对头留一点点空隙。
4.然后这个简易的EMP电磁脉冲射频发射器就做好了。
效果演示视频：
简易EMP电磁脉冲发生装置
防护措施：
电子脉冲防护方法与雷电防护方法基本相同。用9.5毫米厚钢板或4毫米厚铜板做成的屏蔽罩，可以提供很高的总体屏蔽效能。但是，这种屏蔽会由于存在检修门和供电缆、连接器、开关等使用的小孔而减弱，这样就必须用衬垫密封孔隙。如果必须开孔通气，则应使用各种屏蔽栅（如蜂窝状隔板、多孔金属板和金属丝网屏栅）把大孔分成许多小孔，孔与孔之间相交的地方必须熔合，以便确保最佳的屏蔽效果。电缆必须使用整体防护材料，最好的电缆防护材料是管道之类的导电固体材料。在协助降低易损性方面，合适的接地线路也很重要。若数据传输率低，可采用滤波方法抑制瞬时效应。若只靠滤波不足以把电子脉冲降到安全水平，则需使用防护性抑制器，例如齐纳二极管。
当前，国外指挥通信系统防电子脉冲的具体方法主要有：选取最佳元器件；使用不易受电子脉冲影响的元件，如电子管等；在连接器上安装滤波器；使用外部防护元器件保护预先包装的电路（如集成电路）；使用引线防护装置；使用分离滤波器，将耦合频率限制在很窄的频带内；采用自动增益控制与增益限制技术；使用特种滤波器；使用电路隔离技术隔离电瞬变现象；屏蔽和接地；重新设计分系统；探测由于电子脉冲干扰而出现的数据错误，并拒绝这些数据。
注意！
电磁脉冲（EMP）对着小区，可以让小区的车都响起来！
对着游戏机，可以自动退币（也就是俗称的上分器）！
对着节能灯，可以使灯亮起！
对着智能门锁，可以打开门锁！
对重要家电发射，会损坏家电！
用来破坏无线设备是轻而易举的事！
不要对电视信号塔，基站等等测试，不要乱试哦，当心获得精美手镯。
本文转载自天乐博客：https://blog.361s.cn/75.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bcbc3986759b512746ac53153f65c80/" rel="bookmark">
			web浏览器获取摄像头并拍照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器兼容性尚可
desktopmobile Chrome
Edge
Firefox
Opera
Safari
Chrome Android
Firefox for Android
Opera Android
Safari on iOS
Samsung Internet
WebView Android
getUserMedia
53
footnote
Toggle history 12
Toggle history 36
footnote
Toggle history 40
footnote
Toggle history 11
Toggle history 53
footnote
Toggle history 36
footnote
Toggle history 41
footnote
Toggle history 11
Toggle history 6.0
Toggle history 53
Toggle history Secure context required
53
Toggle history 79
Toggle history 68
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bcbc3986759b512746ac53153f65c80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d03d7a0a9335861f270eb48120810faa/" rel="bookmark">
			服务器密码以及用户名怎么修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器密码以及用户名怎么修改 我是艾西，今天给大家说下服务器密码如何修改
windows2003系统：
1、右键我的电脑，点击“管理”：
2、在“本地用户和组”中打开“用户”，在右侧找到 Administrator 账户进行修改。
2008系统
右键我的电脑–管理 进入后在配置-本地用户和组-用户,在右侧找到administrator帐户进行修改。
3、在 Administrator 账户上点击右键，选择“修改密码”设置您的新密码。
4、修改后请牢记您的系统管理员密码，若忘记需找回密码，可以在管理中心服务器管理里面点击“改密码”功能修改，若服务器里面安装了安全防护软件可能会导致修改失败，许提交工单人工重置。
修改完密码后，先不要断开远程连接，新开一个远程连接，用新密码登陆测试是否修改成功，修改成功后再关闭。
2012/2016/2019系统
1.点击左下角服务器管理
2.点击管理器–工具–计算机管理
3.本地用户和组–用户–找到adminstrator-右键设置密码
今天拿Windows server 2012系统实操带图文教学：修好账号密码
我的电脑-----右键管理-----服务器管理器------右上角点击工具------点击计算机管理-----本地用户和组------用户-----administrator-------右键设置密码
输入自己觉得好记又安全的密码就可以了
那么我们想把用户名administrator改成自己喜欢的字母怎么设置呢？
按Win+R组合键打开 “运行” 窗口键入 “gpedit.msc” 按回车，打开“本地组策略编辑器”
在窗口中依次打开“计算机配置”—“Windows设置”—“安全设置”—“本地策略”—“安全选项”
在右侧窗口中双击打开“账户︰重命名系统管理员账户”选项。
弹出属性对话框，在“本地安全设置”选项卡中，直接将默认的administrator账户名修改为自己设置的名称
我这里是设置的aixiaixi
然后点击下方的“确定”按钮重启电脑即可生效
我们远程登陆用户名输入aixiaixi
这样就直接进入到服务器了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6c6d30a7fb8e2d5cc1e9b6b830144a0/" rel="bookmark">
			使用flv.js &#43; websokect播放rtsp格式视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题背景 在最近的项目中，涉及到海康接入的视频播放的问题，海康这边获取到的视频流是rtsp格式，web端目前没有直接可以播放的组件，于是最开始是后端处理了视频流，返回hls格式的m3u8地址，这样用videojs插件就可以播放了，但是问题就是处理了的m3u8地址播放效果非常差，第一次加载时间较长，且播放过程中很卡，尤其是项目的界面做的是视频监控墙，不止一个视频，导致没办法看了。想着最好的方式还是直接播放rtsp地址，不经过转码。于是问题回到了如何播放rtsp.
2.方案的筛选
播放rtsp格式的视频流，网上有很多方式，除了上述的转m3u8，还有转rtmp的，或者使用WebRTC、streamedian、h5stream等，其中webRTC我不太了解，看了一下文档，也比较复杂，就放弃了。然后是streamedian、h5stream这两个，前者是需要收费，另一个我看了文档，没有可以动态设置rtsp地址的地方，只有在配置文件里写好，这样不符合项目的要求，也放弃了，就在纠结到底该怎么办的时候，同事大佬提出了一个建议，看看人家bilibili也有直播，人家是怎么做的呢，于是顺手搜了一下B站直播原理，看到了一篇博文是说bilibili开发的flv.js，讲述了里面的用法，我看了看，确实算是一个比较可行的方法了，于是开干起来。
3.实际运用
首先了解这个方案的大致流程：1.需要一个node服务器处理rtsp流，转为flv流，2.前端安装flv.js显示flv视频流。其中第一步搭建的服务器实际上是搭建了一个websokect服务器，前端通过flv里提供的方法，通过websokect连接到node服务器，这样flv流就源源不断的送到了前端，虽然这里也对rtsp进行了处理，但是效果却出奇的好，比m3u8格式的效果好太多，基本上3、4s就加载出来了，如果同时加载的视频很多，那么差不多也在5-8s内加载出来了，最多的一次12个视频，最后一个加载出来用了12s左右。总得来说比之前m3u8单个都要加载10s左右，视频多了甚至加载不出来好太多了。
好了，介绍的话太多了，还是回到如何搭建吧。node搭建的服务器需要配合ffmpeg。所以首先安装ffmpeg，这个我在Windows上测试的，直接下载了一个压缩包，解压就好，然后是搭建node服务器，将以下package.json直接复制到文件里，然后npm install就可以得到一个服务器环境（前提是已经安装了node哦）。
1 { 2 "name": "ffmpeg-server", 3 "version": "1.0.0", 4 "description": "", 5 "main": "index.js", 6 "scripts": { 7 "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" 8 }, 9 "author": "", 10 "license": "ISC", 11 "devDependencies": { 12 "express": "^4.17.1", 13 "express-ws": "^4.0.0", 14 "ffmpeg": "0.0.4", 15 "fluent-ffmpeg": "^2.1.2", 16 "http": "0.0.0", 17 "websocket-stream": "^5.5.0" 18 } 19 } 接下来是index.js
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6c6d30a7fb8e2d5cc1e9b6b830144a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d86358d9cef9fb6d40063726428bfdab/" rel="bookmark">
			阿里Java研发面经（已拿offer）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、自我总结： 1）首先最重要的一点。对自己的要求高点。不要以简单的实习生来要求自己。你要想 你会的别人都会 你的核心竞争力是什么呢。所以楼主建议以Java高级工程师来要求自己。不会的就学嘛。人面对未知的事物 本能反应是恐惧与退缩。可当你尝试去理解它 运用它 你会发现其实也没那么难的。2）带着好奇心去思考问题。不要停留在问题表面。要多想想为什么用这个技术。不要和我说你会什么语言和框架。语言和框架本身只是工具而已，重要的是框架背后的设计模式与原理，抛开设计模式降低模块耦合外，个人觉得核心就是数学。因为不同的数学思维可能造成代码的质量不在一个层次。（说白了就是时间空间复杂度的问题）。 Java主要分为三个部分：
1）Java基础（Java面向对象思想）各种Jar包熟练调用以及运用。2）Java框架的使用 SSM,SpringBoot。。等等一系列。3）JDK常见源码（比如HashTable HashMap） 优缺点。JVM Java虚拟机 Java高并发线程安全策略 Spring各种框架源码的实现。 二、源码分析思路： 1）由于源码包含太多抽象类 很多都是一层又一层的封装（先看个大体流程 再去关注具体的抽象方法的具体实现）。当学习一个框架时，建议是了解它的基本功能，然后自己去跑个Demo 然后再去分析它的底层。2）比如Spring，主要功能是Ioc 丶AOP。首先你要知道Ioc丶Aop的功能是什么。再其次Ioc怎么去加载 管理 销毁 Bean。这个Bean是怎么加载的 存放再哪里 怎么回收等等一些列问题。为什么用Aop，实现原理是什么，Java动态代理与cglib的优缺点是什么。 三、分布式思维： 有问题就去解决问题。没有问题就是最大的问题。（为了防止单点宕机一般采用分布式。为了缓解数据库压力 我们会引用缓存技术）
通常系统都是采用单点模式。所以当出现宕机的时候你怎么去解决它。最常见是采用分布式方法。多起几个应用。一个挂了 自动切换到另一个。但是分布式也有很多问题值得我们思考。
分布式一般遵循CAP（一致性，可用性，分区容错性）原则，Base原则。
1）Session共享问题2）分布式事务管理怎么解决3）分布式锁怎么解决。4）缓存雪崩 问题怎么解决。 四、系统的设计主要围绕两个点：1）安全 2）性能 围绕这两个点逐渐延申： 常见安全：
1）XSS攻击2）CSRF(表单重复提交)3）SQL注入4）反盗链怎么解决 性能：
1）Nginx负载均衡2）消息中间件3）缓存Redis4)分布式架构 总结 就写到这了，写的有点多了，也算是给这段时间的面试做一个总结，查漏补缺，祝自己好运吧，也希望正在求职或者打算跳槽的 程序员看到这个文章能有一点点帮助或收获，我就心满意足了。多思考，多问为什么。希望小伙伴们早点收到满意的offer! 越努力越幸运！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd42bfdf5dca2123997a993d3f2baa8/" rel="bookmark">
			深度干货 | 32道JVM基础面试题 （1.2W字详细解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 内存区域划分1、运行时数据区是什么？2、程序计数器是什么？3、Java 虚拟机栈的作用？4、本地方法栈的作用？5、堆的作用是什么？6、方法区的作用是什么？7、运行时常量池的作用是什么?8、直接内存是什么？ 内存溢出1、内存溢出和内存泄漏的区别？2、堆溢出的原因？3、栈溢出的原因？4、运行时常量池溢出的原因？5、方法区溢出的原因？ 创建对象1、创建对象的过程是什么？2、对象分配内存的方式有哪些？3、对象分配内存是否线程安全？4、对象的内存布局了解吗？5、对象的访问方式有哪些？ 垃圾回收1、如何判断对象是否是垃圾？2、Java 的引用有哪些类型？3、有哪些 GC 算法？4、你知道哪些垃圾收集器？5、ZGC 了解吗？6、你知道哪些内存分配与回收策略？7、你知道哪些故障处理工具？ 类加载机制1、Java 程序是怎样运行的？2、类加载是什么？3、类初始化的情况有哪些？4、类加载的过程是什么？5、有哪些类加载器？6、双亲委派模型是什么？7、如何判断两个类是否相等？ 内存区域划分 1、运行时数据区是什么？ 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干不同的数据区，这些区域有各自的用途、创建和销毁时间。
线程私有：程序计数器、Java 虚拟机栈、本地方法栈。
线程共享：Java 堆、方法区。
2、程序计数器是什么？ 程序计数器是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。字节码解释器工作时通过改变计数器的值选取下一条执行指令。分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。是唯一在虚拟机规范中没有规定内存溢出情况的区域。
如果线程正在执行 Java 方法，计数器记录正在执行的虚拟机字节码指令地址。如果是本地方法，计数器值为 Undefined。
3、Java 虚拟机栈的作用？ Java 虚拟机栈来描述 Java 方法的内存模型。每当有新线程创建时就会分配一个栈空间，线程结束后栈空间被回收，栈与线程拥有相同的生命周期。栈中元素用于支持虚拟机进行方法调用，每个方法在执行时都会创建一个栈帧存储方法的局部变量表、操作栈、动态链接和方法出口等信息。每个方法从调用到执行完成，就是栈帧从入栈到出栈的过程。
有两类异常：① 线程请求的栈深度大于虚拟机允许的深度抛出 StackOverflowError。② 如果 JVM 栈容量可以动态扩展，栈扩展无法申请足够内存抛出 OutOfMemoryError（HotSpot 不可动态扩展，不存在此问题）。
4、本地方法栈的作用？ 本地方法栈与虚拟机栈作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈为虚本地方法服务。调用本地方法时虚拟机栈保持不变，动态链接并直接调用指定本地方法。
虚拟机规范对本地方法栈中方法的语言与数据结构无强制规定，虚拟机可自由实现，例如 HotSpot 将虚拟机栈和本地方法栈合二为一。
本地方法栈在栈深度异常和栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError。
5、堆的作用是什么？ 堆是虚拟机所管理的内存中最大的一块，被所有线程共享的，在虚拟机启动时创建。堆用来存放对象实例，Java 里几乎所有对象实例都在堆分配内存。堆可以处于物理上不连续的内存空间，逻辑上应该连续，但对于例如数组这样的大对象，多数虚拟机实现出于简单、存储高效的考虑会要求连续的内存空间。
堆既可以被实现成固定大小，也可以是可扩展的，可通过 -Xms 和 -Xmx 设置堆的最小和最大容量，当前主流 JVM 都按照可扩展实现。如果堆没有内存完成实例分配也无法扩展，抛出 OutOfMemoryError。
6、方法区的作用是什么？ 方法区用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
JDK8 之前使用永久代实现方法区，容易内存溢出，因为永久代有 -XX:MaxPermSize 上限，即使不设置也有默认大小。JDK7 把放在永久代的字符串常量池、静态变量等移出，JDK8 中永久代完全废弃，改用在本地内存中实现的元空间代替，把 JDK 7 中永久代剩余内容（主要是类型信息）全部移到元空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd42bfdf5dca2123997a993d3f2baa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558e55007452c902fc6d0e48ac1323a7/" rel="bookmark">
			mysql并发更新丢失解决方案实战 go语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql并发更新丢失解决方案实战 1 更新丢失 对于可重复读、读已提交隔离级别都会有更新丢失的问题。事务A、事务B开始读取到order_id=1的累计金额为0，事务A加一后执行更新并提交，此时数据库中累计金额为1。事务B也加一并执行更新且提交，覆盖了事务A的结果。两个事务完成后，数据库中累计金额为1。而我们的预期是2。
2 解决方案 2.1悲观锁 对数据加锁，同一时间内只能有一个事务进行更新。
2.2更改update语句 因为update语句是原子性的，对于update a = a + 1类型，即使在高并发下，依然是一条一条执行，执行多少次update就增加几次1。
原来：
accumulativeTotal=1
accumulativeTotal= accumulativeTotal +1
update accumulative_total = accumulativeTotal
改为：
accumulativeTotal=1
update accumulative_total = accumulative_total + 1
2.3乐观锁 乐观锁没有加锁，而是由应用程序判断是否可以更新。一般会通过引入版本号的方式来实现，在更新之前读取到版本号，update语句指定where条件版本号等于之前读到的，并让版本加一，也是依赖update语句的原子性。版本号等于之前读到的说明数据没有被更改，可以更新，否则放弃更新，重新读取更新。由于可能在事务中多次读取版本号，且版本号要最新的，因此隔离级别应为读已提交。
乐观锁适合于并发较低的情况，当并发高时，应用会不断地读取版本、放弃更新，不停空转，消耗cpu、数据库资源。
2.4分布式锁 分布式锁，比如redis实现的分布式锁，多了跟redis交互的时间，效率并不高。
3 实战 3.1说明 3.1.1 源码 https://gitee.com/tong-exists/concurrent-update-mysql
3.1.2 机器配置 数据库机器
虚拟机2GB内存，1核cpu
redis机器配置
虚拟机2GB内存，1核cpu
宿主机配置
16GB内存，8核cpu 2.4Ghz。go程序、jmeter都在宿主机运行。
3.1.3 表的初始状态 也是测试前的状态
3.1.4 测试 测试软件为jmeter
3.1.4.1 高并发测试配置 样本为5000个，100的并发
3.1.4.2 低并发测试配置 样本为5000个，10的并发
3.2更新丢失 3.2.1 代码 package main import ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/558e55007452c902fc6d0e48ac1323a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e281bcdc37012ac8c6ea78f952cfe1e/" rel="bookmark">
			COMMON LAYER INTERFACE (CLI)切片格式读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		COMMON LAYER INTERFACE (CLI)切片格式读取 CLI简介：
通用接口层文件格式，是许多切片软件生成的切片数据格式，但是CLI也含有许多接口，可以自定义添加所需的数据，比如3DXpert软件路径规划后生成的数据就是使用CLI格式保存。
CLI格式说明：
去年因做3D打印路径规划项目，就研究了一下CLI格式，该格式官方介绍如下：https://www.hmilch.net/downloads/cli_format.html
个人还是建议去官网格式介绍自己好好看懂它，但事实就是很多同学看不懂，问了我一遍又一遍，我决定用最简单的方式在这里介绍清楚，方便大家理解。
CLI文档内存数据有两种，ASCII码数据格式以及二进制数据格式。
（1）ASCII码数据格式。这种比较少见，而且我觉得不需要介绍了，连ASCII都看不懂的话，基本无缘编程了。/哭笑
（2）二进制数据格式。
上图的表格基本就是官网的介绍。将会用到的一些字节型：
无符号整型：2字节。
REAL型：4字节
其余的可以自己百度一下。
对于CLI切片文件（只含轮廓数据，无填充数据的情况下），只有128、129两种数据。从上表得知128、129都是无符号整型，因此解析的时候按照2字节读取便可。具体内容如下图：
上图表示一层里面有一个轮廓，该轮廓由5个顶点相连而成。当然了，一层数据里面可能有多个轮廓，如下图：
注：CLI中的层厚度以及坐标数值都是mm放大了100倍，比如上图第二层的厚度为3，那么第二层的实际厚度就是0.03mm。
去年在学习的过程中，网上也看了很多资料，结合自己实际项目经验和理解，以上的总结应该是全网最清晰的了。希望大家都能顺利解析CLI文件，开始3D打印路径规划算法的第一步。若还是实在无法理解，我已经写好了C++、C#的两种解析代码，可以联系我获取。
多动手、多尝试。
2022年11月26日更新：
非常抱歉，很久没弄CLI相关工作了，很多人也私信了我快一年了，一直忘记或者没空整理，答应了几位私信我的同学说本月一定上传CLI解析代码，于是乎在本月的最后一个周末，专门设定了一个闹钟提醒自己，各位十分抱歉了，我上传了C#和C++解析CLI的代码，有不明白可以继续问我，谢谢。
下载链接：
https://download.csdn.net/download/qqqcheng_/87164341
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ab53dd9679f0fc4ef69e8f6a3bc1ca/" rel="bookmark">
			【C语言】编写程序，由键盘输入一元二次方程ax^2&#43;bx&#43;c=0的a、b、c的值，求方程的解。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要注意的是：1、定义变量为double类型，2、考虑该题的全部解3、注意运算括号的使用
#include &lt;stdio.h&gt; #include&lt;math.h&gt; int main() { double a,b,c; double d,e; double G; printf("请分别输入abc的值："); scanf("%lf%lf%lf",&amp;a,&amp;b,&amp;c); G=b*b-4*a*c; if(a==0){ printf("该方程为一元一次方程！\n"); printf("求解值为：%.2lf",-c/b); }else{ if(G&lt;0){ printf("该方程没有实根！"); }else{ if(G==0){ printf("该方程有两个一样的实根！\n"); d=-b/(2*a); e=d; printf("x1的值为：%.2lf,x2的值为：%.2lf",d,e); } if(G&gt;0){ printf("该方程有两个不同实根！\n"); d=-b/(2*a); e=sqrt(G)/(2*a); printf("x1的值为：%.2lf,x2的值为：%.2lf",d,e); } } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eebf4052e108f285cb13592f25a493b/" rel="bookmark">
			在 VS Code 中阅读 G-code 及 3D 打印机 gcode 常用指令介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 在 VS Code 中阅读 G-code 直接以文本格式在 VS Code 中打开 .gcode 文件，会发现没有语法高亮。
安装插件实现语法高亮和悬浮显示命令解释。
1.1 安装插件「G-Code」 1.2 配置 settings.json 文件 1.2.1 打开 VS Code 设置(快捷键： Ctrl + 逗号) 1.2.2 打开 settings.json 文件 1.2.3 在文件底部追加如下内容后保存文件并关闭(注意补全 逗号) "gcode.definitions": { "G0": "快速移动，用于快速移动到指定位置，在使用该命令之前，要考虑其移动的直线路径上是否有障碍物", "G1": "运动。F: 喷嘴最大移动速度，单位为 mm/min；E：控制挤出机给丝量，即输入丝材的长度，单位 mm，也可控制回抽。与M82(绝对挤出)/M83(相对)命令配合", "G2": "顺时针圆弧", "G3": "逆时针圆弧", "G4": "等待。无参数等价于M400，停止移动。参数如P500 = 0.5s；S3 = 3s", "G17": "平面设定,为XY平面, 控制G2/G3(圆弧)、G73,G81-G89(封闭循环)。默认值", "G18": "平面设定,为XZ平面, 控制G2/G3(圆弧)、G73,G81-G89(封闭循环)", "G19": "平面设定,为YZ平面, 控制G2/G3(圆弧)、G73,G81-G89(封闭循环)", "G20": "设置单位为英制英寸", "G21": "设置单位为公制毫米", "G28": "复位，无参数表示所有轴复位；加上参数，表示仅控制指定的轴复位。该命令会禁用打印平台水平补偿，使用'M420 S'命令打开水平。W:：所有轴复位，但不影响平台水平补偿", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eebf4052e108f285cb13592f25a493b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa17a68d05f2016b369f747e231cdae/" rel="bookmark">
			Matlab简易版美图秀秀（GUI界面实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该项目为数字图像处理课程的期末大项目，主要内容是用matlab软件实现一些美图秀秀相关功能，比如对图像进行水平垂直翻转，旋转，裁剪，抠图等基础功能；对图像添加浮雕，艺术噪声，灰度胶片，动感模糊，素描，油画，羽化等滤镜的功能；以及祛痘祛痣，白牙，大眼，磨皮，美白，增强等美化功能。在实现以上功能的基础上，还使用了GUI图像用户界面，增强了用户交互式体验感。
GUI界面的一些使用方法可看之前我发的两篇博客：
Matlab GUI界面使用方法（一）：打开GUI&amp;GUI常用控件（最基础）
Matlab GUI界面使用方法（二）：GUI控件功能实现
这是该简易版美图秀秀的GUI界面：
以下是一些功能的原理步骤以及代码和部分注释：
1.导入图像和从摄像头获取图像 原理步骤：
从摄像头获取：通过imaqhwinfo函数获取摄像头信息，再在videoinput函数中创建一个视频对象，用preview函数创建预览窗口，即可完成使用matlab调用摄像头获取图像了。
从文件夹中选择图片：用uigetfile函数打开文件对话框，选择指定格式的图片，这时会返回图像的名称和路径信息，如果选择成功就将编辑文本的string设置为文件的名称和路径，并将名称和路径存储在handles中，最后在确认按钮中从handles获取到名称路径信息，并用imshow函数读取即可。
从摄像头获取： % --- Executes on button press in pushbuttoncam. function pushbuttoncam_Callback(hObject, eventdata, handles) % hObject handle to pushbuttoncam (see GCBO) % eventdata reserved - to be defined in a future version of MATLAB % handles structure with handles and user data (see GUIDATA) vid=videoinput('winvideo',1);%创建视频输入对象 h=preview(vid);%显示视频输入对象 while ishandle(h) img=getsnapshot(vid); imshow(img); end从文件夹选取： % 主界面选择图片按钮 % --- Executes on button press in pushbutton1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fa17a68d05f2016b369f747e231cdae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09ac7cd470ac98bb1a73456326c59611/" rel="bookmark">
			论文笔记---SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里，我们设计了一个与SSH模型完全相似的一维周期声学系统。声学系统的单元由两个谐振腔和连接它们的两个连接管组成。我们表明，当我们调整控制细胞间和细胞内跳的连接管的半径时，我们的声学模拟发生拓扑相变。拓扑相变的特征是几何Zak相位的突变。
在三维系统中，两个带在Weyl点处线性相交，一个Weyl点是Berry通量的源或流，即以其Berry曲率的表面积分为特征的拓扑电荷。在二维(2D)系统中，Berry曲率的表面积分用Chern数表示。此外，对于一维系统，Berry连接的积分被定义为Zak相位。
在一维系统中，具有拓扑非平凡相的最具代表性的模型之一是Su-SchriefferHeeger (SSH)模型。该模型描述了电子在单细胞节理处的交错跳，该模型将电子的跳分为胞内跳和胞间跳两种。通过控制振幅，一维链的能带间隙可以闭合和重新打开，这意味着拓扑相变。
在一维系统中，如果胞间跳强大于胞内跳强，则该系统具有拓扑非平凡相。如果胞内跳强度大于胞间跳强度，则系统具有拓扑平凡相。
间&gt;内 非平凡
间&lt;内 平凡
当两个拓扑相不同的晶格连接时，会出现拓扑界面态。拓扑边缘态可以由单个拓扑非平凡声子晶体实现。
声子晶体由圆柱形波导和周期性交替结构的谐振腔组成
每个单元由两个相同的垂直方向的圆柱形腔作为谐振腔和两个水平方向的不同半径的圆柱形管作为连接点组成
图1所示。(a)实验装置。实验系统由一个扬声器和四个麦克风组成。该样品是由两种声子晶体组成的声波导。这些声子晶体是相互连接的，连接处用洋红色的箭头标出。声子晶体在结的每一边都有一个单位单元a或单位单元b，每一边的单位单元分别用红色和绿色虚线框标出。声波由扬声器产生，并沿波矢量k(由蓝色箭头表示)的方向在声学系统中传播。(b)和(c)分别标注a单元和b单元的截面及其几何参数。
每种声子晶体都类似于SSH模型，垂直(水平)圆柱腔对应于位点(键)。
a单元的草图如图1(b)所示，尺寸为a=200mm, t=5mm, r=40mm, h=80mm, w1=13mm, w2=20mm。 b单元示意图如图1(c)所示，其几何参数与a单元相同，除了w1=20 mm, w2=13 mm。
如图所示，单元胞中心半径为w2的导波结管控制胞间跳变，单元胞内跳变由单元胞边界附近半径为w1的导波结管控制。系统中充满空气，且样品的壁厚t足够大(&gt;2 mm)，可以视为刚性边界。在模拟过程中，在每个单元单元的周期面上使用BlochFloquet边界条件，在其他边界上应用健全的硬边界条件。
单元A B的能带图如图2(a),(c)所示：
C单元的能带结构在图2(b)，参数w1=w2=16.5（内外一样大）
边界带状态的本证模 a--d c--e 从图2(d)和图2(e)可以看出，本征模的声场压力沿波传播方向(x方向)变化，在z方向几乎一致。
所有的特征模对于反演中心都是对称或反对称的。每个波段的Zak相位可以由这些特征模的对称性来确定。
例如，在图2(a)，第二带下沿和上沿的特征模对称性相同，因此，Zak相位为0。同样，在图2(c)中，第二带下沿和上沿的特征模对称性不同，因此，Zak相位为p。
每个波段的Zak相位可以定义为
其中k是布洛赫准动量，为周期布洛赫函数，为布洛赫波，a为周期。
更具体地说，我们的声学系统的第n个隔离带的Zak相位可以表示为
其中，hnZak代表第n波段的Zak相位，ρ是空气密度，v为空气中的声速，un,k(x, y, z)为带波向量k的第n波段状态归一化Bloch本征函数的胞内周期性部分。
如果所选单元格具有镜像对称性，则Zak相位的值要么等于0，要么等于p。
本文研究的声子晶体的拓扑特性可以通过各个单元的几何参数来调制。
改变两个水平连接管的半径差来实现拓扑相变
黑线和红线分别表示对称和反对称带边模式。很明显，随着dw的增大，频带闭合再打开，临界点dw=0（w1=w2）是频带反转点。
每个带隙的拓扑相位可以由带隙以下所有体带的Zak相位的总和来确定。
第1带隙的拓扑相用蓝色(Zak相0)和红色(Zak相p)标记。上下带边缘的对称分布是由于我们的系统在布里渊区边界附近的手性对称。
通过在一定的带隙内连接两个拓扑相位不同的声子晶体，可以实现拓扑界面。
在图1(a)中，选择左侧声子晶体的半径差为dw= -7 mm，选择右侧声子晶体的半径差为dw=7 mm(整个结构称为S1)。S1的特征模如图4(d)所示
为了便于比较，dw的另一组值分别在左右两侧为dw=-7 mm和dw=- 3mm(整个结构称为S2)。S2的本征模如图4(a)所示，可以观察到在带隙中间(红线表示)存在具有本征频率的本征模。
这一对比证明了拓扑相变发生时出现拓扑界面态，这意味着在结两侧的两个声子晶体的拓扑相是不同的。
S1对应透射光谱的结果如图4(e)和图4(f)所示。
此外，对S2的透射光谱进行了模拟和测量，结果分别如图4(b)和图4(c)所示。
对比S1和S2的透射光谱，无论是模拟的还是实测的S1透射光谱都可以观察到一个明显的透射峰。
界面态声压模拟场分布如图5(a)所示。
(a)：模拟S1中界面态声压场的空间分布。红色虚线表示结构的中心线。色标表示声压归一化幅值。(b)：S1界面态实测声压场用红色圈表示，沿红色虚线的模拟声压场分布用黑色实线表示。振幅由P0的最大值归一化。
从图5(b)可以观察到，界面态的声压分布在离界面结(x= 0)远的地方呈指数衰减。
拓扑非平凡声子晶体末端的拓扑边缘态，如图6(c)所示，PC1的第一个带隙没有出现边缘状态，因为该结构具有拓扑平凡几何Zak相位(0)。相反，拓扑边缘态(红线)出现在图6(d)中0.516 kHz处PC2的第一个带隙中，因为该结构具有拓扑非平凡几何Zak相位(p)。
图6所示。(a)声子晶体由29个a单元组成，称为PC1。(b)声子晶体由29个单元b组成，称为PC2。注意，标记为蓝色的谐振器是为可能的边缘状态提供类似声学环境的附加谐振器。(c) PC1的模拟本征频谱如(a)所示。(d) PC2的模拟本征频谱如(b)所示。通过比较，在0.516 kHz处(d)出现了两个用红线标记的简并边缘状态。(e) (d)中红线对应的声压场分布。两者的声压场都局限在边缘附近。色标表示声压归一化幅值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09ac7cd470ac98bb1a73456326c59611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/116ae836c3ca60caadb5041df332cee1/" rel="bookmark">
			1.1docker介绍安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1docker介绍安装 docker介绍什么是虚拟化虚拟化技术种类虚拟化种类1.全虚拟化架构2.os层虚拟化架构3.硬件虚拟化 容器技术dockerdocker和vmware的区别docker的特点docker组件Doker客户端和服务器Docker镜像Registry(注册中心)Docker容器 Docker安装 docker介绍 什么是虚拟化 在已有硬件资源上，将资源分成多个不同的实体成分，如一台windows电脑 可以虚拟出Ubuntu系统和mac系统
虚拟化技术种类 软件虚拟化，硬件虚拟化，内存虚拟化，网络虚拟化(vip)，桌面虚拟化，服务虚拟化，虚拟机虚拟化等等
虚拟化种类 1.全虚拟化架构 2.os层虚拟化架构 3.硬件虚拟化 容器技术 容器是直接运行在操作系统内核之上的用户空间
容器只能运行与底层宿主机相同或者相似的操作系统
容器有独立的网络和存储栈
容器有自己的资源管理能力
同一台电脑的容器可以友好共存
容器和宿主机器隔离非常彻底
docker docker直接在宿主的操作系统调用硬件资源
不会虚拟操作系统和硬件
应用和镜像都docker容器中
docker和vmware的区别 docker体积小，速度快，扩展性强
docker的特点 1.上手快
用户几分钟就可以把自己的程序虚拟化
2.职责的逻辑分类
开发人员只需要关心容器中运行的应用程序，运维人员只需要关心如何管理容器
3.快速高效的开发生命周期
Docker就像一个盒子，里面可以装很多物件，如果需要这些物件可以直接将该大盒子拿走，而不需要从该盒子中一件件取。
4鼓励使用面向服务的架构
Docker还鼓励面向服务的体系结构和微服务架构
服务提供者:发布自己的服务，并对服务请求进行响应
服务注册中心:注册已经发布的web service,对其进行分类，并提供搜索服务
服务请求者:利用服务中心查找所需要的服务，然后使用该服务
docker组件 Doker客户端和服务器 客户端-服务器(c/s架构程序，可以在同一台主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程)
Docker镜像 用户基于镜像来运行自己的容器，镜像也是Docker生命周期中的构建部分，vm虚拟机ubuntu镜像，类比docker docker镜像
Registry(注册中心) docker用registry来保存用户构建的镜像，如ubuntu，mysql等需要下载
Docker容器 docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可，容器基于镜像启动起来
Docker安装 ubuntu为例
更新源
sudo apt-get update 安装包允许apt通过HTTPS使用仓库
sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 添加Docker官方GPG key
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/116ae836c3ca60caadb5041df332cee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e7a18f7ff0c660fe0d680985c77463/" rel="bookmark">
			ts 动态加载import()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import()函数 简介 import命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）。所以，下面的代码会报错。
// 报错if (x === 2) {import MyModual from './myModual';} 上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。
这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。
const path = './' + fileName;const myModual = require(path); 上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。import语句做不到这一点。
因此，有一个提案，建议引入import()函数，完成动态加载。
import(specifier) 上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。
ES6 import()返回一个 Promise 对象。下面是一个例子。
const main = document.querySelector('main');import(`./section-modules/${someVariable}.js`).then(module =&gt; {module.loadPageInto(main);}).catch(err =&gt; {main.textContent = err.message;}); import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，也会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。
import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。
适用场合 下面是import()的一些适用场合。
（1）按需加载。
import()可以在需要的时候，再加载某个模块。
button.addEventListener('click', event =&gt; {import('./dialogBox.js').then(dialogBox =&gt; {dialogBox.open();}).catch(error =&gt; {/* Error handling */})}); 上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。
（2）条件加载
import()可以放在if代码块，根据不同的情况，加载不同的模块。
if (condition) {import('moduleA').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e7a18f7ff0c660fe0d680985c77463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c27d6807bc290a1caa4788013e96dc1/" rel="bookmark">
			大三保研夏令营须知及前期准备工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
对于大三保研学生而言，学期将近结束；接踵而来的是接下来的保研准备。保研阶段通常可以分为：夏令营、预推免、九推(捡漏)。很多同学往往都是在前两个阶段就能获得满意的offer。
对于计算机专业来说，经历过2022年的“推免季”，这次经历告诉我们“计算机专业真的很卷”；(例如北航的某位老哥，投遍了所有的985；例如北大的学子竟然参加川大的夏令营；种种夸张现象层出不穷)。特别是对于双非的同学们，很多985高校都将其拒之门外。
那么面对疫情之下的保研，我们是选择妥协？亦或是直面困难？
为了能够在保研的前期准备工作当中抢占先机，需要保研er们在寒假阶段做如下的准备工作：
对于保研er，夏令营面试高校往往看中的无非就是三类：(1)成绩排名；(2)科研经历；(3)竞赛经历
其中就我个人投递近百所高校的经历而言，高校在筛选学生的时候往往首先看的是本科的学校背景。这在很大程度上决定你是否能够入营。其次是成绩排名，往往很多双非学校只能入营rank1或rank2。而你的科研和竞赛经历只不过是辅助，在决定你能否入营没有绝对的优势。
而对于双非的同学们，在学校背景不占优势的情况下，那么只能从夏令营院校的投递方法上进行改善。其次需要在科研经历和竞赛经历中体现出你比其他人优越的地方。（你需要明确告诉老师，你的优势是什么）
接下来对于不同条件的同学，在夏令营的前期准备工作上也是不同的。
1. 未确定本校保研资格的同学
对于这类同学，我的建议是提高绩点+参加竞赛。毕竟大三下学期还有专业课和必修课，可以通过这些课程来提高自身的绩点。同时如果能够在竞赛中获得国奖，那么就能够通过竞赛加分来超越对手。
2. 已确定本校保研资格，但没有科研经历的同学
虽然科研经历并非是能否入营的决定因素，但是它确实你能否获得offer的关键因素。很多老师最终选择你，往往看中的就是你的科研经历。
如果在现阶段你还没有任何科研经历，或者科研经历很少，那么你就需要找相关的任课老师或者实验室老师进行科研项目的训练。（很多时候我们也可以把比赛当中的经历也看做一项科研，但是前提是这次经历你的参与度足够高，或者这个项目就是你一个人做的。）
3. 确定能够获得保研资格，且有科研经历的同学
对于这类同学来说，你的优势比较的明显；如果你发现自身的竞赛经历比较少，那么可以多参加一些竞赛来丰富你的经历；同时还要准备相关的算法练习，针对于算法的训练可以在Acwing(主推)、leetcode等练习平台上进行训练。因为很多计算机高校夏令营都是需要进行机试的(例如中国人大、华东师范、浙大、华科等)
上述的准备都是针对每个人的不同情况提供的建议，接下来的事项是每位保研er在寒假需要进行的准备工作。 以上材料需要在寒假阶段准备完善，其中导师推荐信建议2-3份，（副教授及以上职称）。
个人简历和陈述准备的时候最好能够将英文版的也准备出来，因为有些高校投递的时候需要中英文都上传。
针对于个人简历、个人陈述、专家推荐信、自荐信等内容如何撰写，可以关注“for保研”；后续在其中可以进行撰写的辅导。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad84a5fc030c961561ed056b797dfc6/" rel="bookmark">
			嵌入式单片机智能药盒设计（含代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
设计的内容
（1）显示
（2）定时时间与用药量的设定
（3）实时时间调节
（4）报警功能
时钟模块
蓝牙模块
系统软件设计
系统主程序
按键函数
中断服务函数
作品展示 测试药定时提醒功能
完整代码
前言 近年来，疫情反复，这让一些家庭使得自己的家里的老人造成了没有人照看的状态，那这就会出现一个问题，那就是我国现在的医疗物资非常的紧张，因为收到了疫情的影响，相关的专业的人员都已经开始向智慧云药能方面开始发展了，同时现在也是大数据的社会在这样的时代的背景下，那些对自身健康问题越来越重视的人，就能够从网络上获取到很多有关于医疗的信息，所以为了迎合拿下记忆力下降而遇到事情就容易忘记的健忘人员，对于他们的需求，就由此提出了一种可以给基于嵌入式单片机的智能药盒的设计方案。
设计的内容 首先介绍一下本设计的使用的LCD160液晶显示屏幕的显示的原理，以及实时时钟模块运行的原理和声控光控报警系统模块的原理。
系统的硬件部分由以下几个模块组成：STC90C51单片机、4×2键盘模块、LCD1602液晶显示屏幕模块、声光报警模块、HC-05蓝牙模块。其中LCD1602液晶显示屏幕模块可以实现实时日期、时间显示功能，键盘模块可以实现对时间、药物用量的设置，声光报警模块可以实现定时时间的提醒，HC-05模块建立单片机与手机之间的链接。
其中系统实现的基本功能具体如下：
（1）显示 采用LCD1602液晶屏幕显示实时日期时间、用药种类及用量等。
（2）定时时间与用药量的设定 系统将在LCD屏幕上显示并实现三种药物用量以及时间的定时设置，分别通过键盘模块中的七个按键完成。
其中七个按键的功能具体为：一个设置键，记为k1，负责进入设置状态；一个功能键记为k2，负责进入三种药品的用药量设置状态；两个调节键，分别记为k7、k8。其中k7的作用为药量增加1，k8的作用为药量减少1。三次定时对应的三个定时按键k4、k5、k6，按下即可停止蜂鸣器鸣警报。
（3）实时时间调节 实时时间通过三个按键进行调节，一个为设置键，记为k1,负责进入时间设置状态；另外两个个为调节键，记为k2、k3。其中k2的作用为增加时间，k3为减少时间。
（4）报警功能 系统内部程序存储器中，自动将系统时钟模块运行的实时时间与定时时间进行对比判断，在两者一致的情况下，蜂鸣器警报响起，且根据需要的服用药物种类，同时对应的LED发光二极管将持续闪烁。
本设计以STC90C516RD+单片机作为核心主控芯片，在本文中主要介绍系统复位电路以及内部振荡电路的原理。其中LCD1602屏幕显示模块则负责时间、日期、药物种类、用药量等设置[4]，将简单介绍其原理组成、指令时序。由LED发光二极管与蜂鸣器电路组成的声光报警系统中，以蜂鸣器警报为主，LED则起到辅助报警功能。系统的基本原理为：各模块驱动程序运行后，系统主程序调用单片机和按键扫描子程序，将扫描结果发送给系统数据更新程序，反馈给LCD1602液晶屏幕显示模块，从而实现按键的输入信息显示功能。在声光报警电路中，程序将调用单片机细分读取数据并输入报警时间。
原理图 时间设置用三个按键完成，一个功能按键k1，两个调节按键k2、k3，在屏幕时间显示界面，按下功能按键后即可进入时间设置状态，两个调节按键k2、k3分别为时间增加1、减少1，最后按下功能按键直至退出设置状态，时钟开始工作。
药品用量设置用四个按键完成，两个功能按键，两个调节按键。其中一个功能键作用为屏幕由时间显示转换到药量显示，另一个即进入、退出设置状态。两个调节按键分别为药量增加1、减少1。
声光报警系统中，停止蜂鸣器警报与LED发光二极管的闪烁需要使用到三个按键，分别对应三种药物，按下即可停止；如果没有按下相应按键，则将在一分钟后，程序判定实时时钟超过固定时钟，即实时时间超过定时时间，判断结果为时间不相等，系统自动退出报警程序。
系统结构 药盒系统的最小系统图 LCD连接方式 LCD显示屏指令表 LCD屏操作时序 除了复位电路模块，在此次的单片机的应用系统中，按键键盘模块部分也是不可或缺的。键盘是计算机全部操作中使用的输入设备之一，通过用手指按压键盘按钮——通常按钮上附有对应文字标签，向计算机发送文字信号等。
键盘的开关主要有膜合开关、机械开关、电容无接点方式，其中，膜合开关和机械开关是完全数字的开关，只有触点关闭或触点打开两种状态。
本系统键盘电路共由8个按键按钮组成，并根据4×2的格式进行布局焊接。
按下键帽时，内置的电路成为闭路，电流流动，作为电信号被编码器读取并作为数字信号输入到单片机系统中。
本次系统所采用的是电磁式蜂鸣器，是利用电磁线圈对蜂鸣片的作用而发声，相对于压电式蜂鸣器，其运作时所需要的电压较低。
发光二极管是二极管的一种，与荧光灯、白炽灯泡等许多其他光源不同，LED会产生偏向特定波长的光。因此，有时由于不包含亮度所需要的波长的光，所以不能得到充分的效果。但LED结构简单，可以大量生产，从而价格相对白炽灯、荧光灯较为低廉，在当今市场上被广泛应用[5]。虽然LED对高温缺乏耐受性，其半导体的材质有可能因电路产生问题而发生故障，但其由于不使用灯丝，重量轻且耐冲击性强，由此可知寿命比白炽灯长。并且与需要稳定器的荧光灯相比，LED的电路比较简单。
发光二极管与其他一般二极管一样具有极性，在阳极上加正电压用于阴极，即电源正极与发光二极管的正极相连，阴极同理，此时将该电路中的电压称为“正向下降电压”。与一般将硅用作主原料的二极管相比，发光二极管的正向下降电压高。
发光二极管连接图 时钟模块 单片机中，具有处理时间和一定周期等形式的时间相关功能的是定时/计时器。本次设计采用的是DS1302时钟芯片作为系统的定时/计时器，通过传送多个字节的时钟信号或RAM数据，对年月日期及时分秒进行计时。
时钟信号是指在电子基板和半导体芯片等内部，为了使多个电子电路发送接收信号的定时一致，有规则地被刻上的电信号。通过这样的信号使各电路的动作同步的方式称为时钟同步设计。信号的形式有几种，但最简单的时钟信号每隔一定的时间切换高电压和低电压，将电压从上升到下一个上升的时间（或从下降到下一个下降的时间）称为“时钟周期”，每单位时间的周期数 “时钟频率”。时钟频率越高，越能高速处理和收发数据。
时钟信号是由内置水晶和陶瓷振子的时钟振荡电路发出的，通过专用的信号线提供给各电路。虽然基板上的芯片或电路根据单个时钟进行操作，但是也可以仅在诸如CPU之类的特定芯片内以来自外部的信号的数倍的时钟信号高速工作。
时钟芯片原理图 蓝牙模块 无线通信主要是利用电波进行的电子通信，而使用电缆等作为传输线的通信称为有线通信。蓝牙是无线通信技术之一。使用超短波2.4GHz带宽，无线连接近距离的数字设备[7]。
蓝牙是一种只有小基础和电池的小型轻量装置，与Wi-Fi等无线LAN相比，价格与功耗较低，并且对于开发者来说具有较为容易理解的数据模型，在此基础上可以自由扩展功能，应用于各种服务。
系统软件设计 系统主要模块软件设计结构 系统主程序 当本系统主程序运行在不同阶段时，在系统逐步完成各个功能模块的初始化之后，将进入程序的循环状态，即此时系统正在运行扫描程序。之后根据所需，按下键盘模块上的按钮，向系统输入信息，于是系统内置的程序存储库中将信息命令判断并执行，这些操作完成之后LCD1602液晶显示屏将实时显示输入信息，同理可实现定时提醒、设定三种药物的剂量。
主程序流程 按键函数 系统中的八个按键分别具有不同的职能，以下主要介绍设置键k1、功能键兼调节键k2、k3、调节键k7、k8：
（1）设置键，当屏幕显示实时时间时，按下即进入设置状态，同理可退出设置状态。
（2）在屏幕时间设置状态下，k2作为调节键，起到时间增加1的作用；相反，未进入时间设置状态时，k2作为功能键，按下即进入药量显示状态，此时可对三种药物的用量进行设置。同理，k3作为调节键时起到时间减少1的作用，作为功能键时可切换时间的显示。
（3）调节键k7为药量增加1，则k8为药量减少1。
中断服务函数 在正常程序运行中，中断处理作为CPU的硬件功能实现，强制中断正常程序的执行。例如，从LED发光二极管闪烁这样简单的处理到在多任务操作系统中，有时必须停止程序的长时间运行。而在本系统时钟模块中，这种情况出现时将利用定时器中的中断子函数进行处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad84a5fc030c961561ed056b797dfc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b27657c2b6a167c59679f6c49b903f/" rel="bookmark">
			mAP@0.5 与 mAP@0.5:0.95 是什么意思，YOLOv5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mAP@0.5 全称是 mean Average Precision（IoU=0.5），即将IoU设为0.5时，计算每一个类别下所有图片的平均AP，即mAP
如上图所示，AP50，AP60，AP70……等等指的是取 detector 的 IoU 阈值大于0.5，大于0.6，大于0.7……等等。数值越高，即阈值越大，精度越低。
mAP@.5:.95（mAP@[.5:.95]）：表示在不同IoU阈值（0.5～0.95，步长0.05）（0.5、0.55、0.6、0.65、0.7、0.75、0.8、0.85、0.9、0.95）上的平均mAP。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d5991dca6041512d79fa8ccc5d94dd0/" rel="bookmark">
			tkinter打包成exe程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求分析：
python脚本如果在没有安装python的机器上不能运行，所以将脚本打包成exe文件，降低脚本对环境的依赖性，同时运行更加迅速
准备:
pyinstaller 官网:http://www.pyinstaller.org/ 首先还是去看支持的python版本(这里我使用的是py3.5)
安装方法:
pip3 install pywin32
pip3 install pyinstaller
确保安装成功
可执行pyinstaller -v 查看版本
编写一个tkinter程序,代码如下:
#!/usr/bin/env python # coding: utf-8 import tkinter as tk root = tk.Tk() root.title('tkinter') # 使用PhotoImage类处理图片,只能是gif格式 # 需要传入一个图片路径 bm1 = tk.PhotoImage(file='444.gif') # 图像居下,文字居上 tk.Label(root, fg='red', bg='yellow', text='妹子图', compound='bottom', image=bm1).pack() root.mainloop() 效果:
将上面的python程序打包成exe可执行程序.
注意:
上面的代码中有gif图片设置为背景
下载一个.ico文件(也可不要,看需求)
进入python程序目录
执行打包命令:
-i 指定exe可执行程序图标,如果没有ico文件，可以不指定，直接 pyinstaller -F xxxxx.py
pyinstaller -i favicon.ico -F tkinter_exe.py
打包成功后会在当前目录生成一个dist目录
注意(重点):把需要的 ico 图标 和 gif 图片文件拖到dist目录里面，不然执行exe的时候会报错,找不到文件!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d5991dca6041512d79fa8ccc5d94dd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1795e55ce91d26cf814f106e832b75be/" rel="bookmark">
			Gitlab-标准流程配置[总结多篇文章并实践多次，小白零基础亦可上手]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谈谈这几天的感受吧：公司因为以前的gitlab服务器出了一点问题，让半路出家的我来看一下，最后说模拟搭建一个gitlab服务器，先看一下里面是跑些什么东东，需要配置的内容是什么等，接着就着手干，但是百度了多篇文章，B站也看了不少的视频，几乎内容都差不多，但是几乎都有一个问题：光是说了做什么，可能本身作者就是熟悉gitlab的大牛，自然就忽略了中间的很多细节，可能有时候轻描淡写地说执行啥命令一下，但是对于小白而言，一下子都可能懵逼，连下手的地方都找不到，因此，结合自己的历程，连文带图，把全过程写下来，同时将自己经历的坑也填上，希望能为后面学习的人提供点帮助。
基本要求：
首先：安装gitlab的服务器，不论本地的PC机、虚拟机、云服务器都可以安装，但是必须要注意的一点：必须CPU2个，内存2G以上，这个算是最低标准了吧，因为我曾经从天翼云领取了1CPU，1G内存的免费服务器，可惜在安装的时候，系统都在安装的时候就挂掉，CPU占用接近100%，内存溢出等错误不断，耗时让人抓狂！最终还报错安装不成功！
其次：我使用的操作系统是Linux，CentOS7【使用XSHELL7链接服务器进行操作】
图一：安装好gitlab后，使用xshell登陆Linux服务器示例
第一步、准备工作：安装依赖包并启动服务 主要的包有： policycoreutils 、openssh-server、 openssh-clients、 postfix、policycoreutils-python。【暂时不要纠结它们做啥用，反正安装就行，有兴趣后期慢慢研究。】
1、命令行内录入安装命令，回车自动执行：
sudo yum -y install policycoreutils openssh-server openssh-clients postfix policycoreutils-python
2、启动服务：逐个将命令录入命令行执行即可【sudo是获取管理员权限，如果本身即是管理员root登陆的，不需要都可以顺利执行，否则就加上以提升权限】。
sudo systemctl enable sshd
sudo systemctl start sshd
systemctl enable postfix
systemctl start postfix
3、关闭防火墙，或者在防火墙将HTTP、HTTPs添加白名单【最好是关闭防火墙】
关闭命令：systemctl stop firewalld
添加白名单的命令【添加完成后重启防火墙】：
添加http： sudo firewall-cmd --permanent --add-service=http
添加https：sudo firewall-cmd --permanent --add-service=https
重启防火墙：sudo systemctl reload firewalld
【注：以上3步因比较简单，粘贴复制命令即可，故不上图了。】
这些都是系统首先必须安装gitlab的依赖包，熟悉的人可以在命令行内使用先查询是否已经安装，例如，查询mysql是否已安装。在命令行中使用命令：rpm -qa|grep -i mysql。如果已经安装可以略去，不熟悉的话，直接全部安装，如果已经安装自然会跳过的。
图二、查询软件或服务是否已安装
第二步、安装gitlab 1、下载安装包：
1.1、直接在线连接命令方式：【最好在系统etc目录下创建gitlab文件夹放置，创建文件夹方式：cd /etc，转入etc目录，使用命令 mkdir gitlab 创建文件夹，在cd gitlab进入】
下载命令：命令中的“-c"，为断点继续的意思，因为网络的原因，可能一次会下载不全不能安装，发现断掉后，再次执行就必须由-c即接着上次下载的继续，否则就是从头开始，会耽误很多时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1795e55ce91d26cf814f106e832b75be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4023d3b46d6e77b15cfaabf9190924/" rel="bookmark">
			【js执行机制】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.浏览器常驻的线程
（1）js引擎线程（解释执行js代码、用户输入、网络请求）
（2）GUI线程（绘制用户界面、与js主线程是互斥的）
（3）http网络请求线程（处理用户的get和post请求，等返回结果后将回调函数推入任务队列）
（4）定时触发线程（setTIMEOUT,setinterval等大事件结束后，把执行函数推入任务队列中，）
（5）浏览器事件处理线程（将click,mouse等交互事件发生后将这些事件放入事件队列）
2.js引擎线程和GUI线程-----互斥
（6）Js可以操作dom元素，近而会影响到GUI的渲染结果，因此js引擎线程与GUI渲染线程是互斥的，也就是说当js引擎线程处于运行状态时，GUI线程将处于冻结状态。
3.js执行机制 ---- 单线程
（7）单线程，同一时间只能做一件事情。
4.js执行机制----多线程不好吗？
（8）Js设计出来就是为了与用户交互，处理dom，假如js是多线程，同一时间一个线程想修改dom，另一个线程想要伸出dom，问题就变得复杂很多，浏览器不知道听谁的，如果引入“锁”的机制，这不就又回到被其他语言尴尬的困境了吗？
Js执行机制
（9）Javascript是基于单线程运行的，同时又是可以异步执行的，一般来说这种既是单线程又是异步的语言都是基于时间驱动的。恰好浏览器就给JavaScript提供了这么一个环境（event loop 事件循环）
（10）执行栈相当于js线程里面的主线程。
重新理解定时器
（11）SetTimeout的等待时间结束后并不是直接执行而是先推入浏览器的一个任务队列，在同步队列结束后再一次调用任务队列中的任务。
（12）SetTimeout(function(){},0),js主线程执行栈为空时，0毫秒实际上也达不到的，根据html标准，最低4毫秒。
（13）Setinterval是每隔一段时间把任务放到event loop 里面。
（14）所以，定时器不准。定时器不准，定时器不准。
var starttime = +new Date(); function foo(a) { for (var i = 0; i &lt; a; i++) { console.log(i) } } console.log(starttime) setTimeout(function() { console.log(+new Date() - starttime) }, 400) foo(100000); console.log("helloworld") 发现延迟了一千多毫秒才执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ddb016f061d4863b3314f4a1f26cd9/" rel="bookmark">
			NPOI对已有Excel文件添加数据的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 最近有朋友反馈使用NPOI向已有的xlsx文件中添加数据后，要么无法保存新增数据，要么直接报出下图所示的错误，下面就来说一下如何利用NPOI向一个已有的xlsx文件添加数据的方法。
2、实现方法 新建一个xlsx文件，其数据如下图所示：
如果要向该文件添加一行新的数据，只要分三步走即可：
1、创建文件流读取xlsx
2、添加新的数据
3、创建文件流写入xlsx
using System; using System.IO; namespace NPOIApp { class Program { static void Main(string[] args) { // 第一步：读取文件流 NPOI.SS.UserModel.IWorkbook workbook; using (FileStream stream = new FileStream(@"C:\Users\dongshenfeng\Desktop\test.xlsx", FileMode.Open, FileAccess.Read)) { workbook = new NPOI.XSSF.UserModel.XSSFWorkbook(stream); } // 第二步：创建新数据行 NPOI.SS.UserModel.ISheet sheet = workbook.GetSheetAt(0); NPOI.SS.UserModel.IRow row = sheet.CreateRow(sheet.LastRowNum + 1); NPOI.SS.UserModel.ICell cell; // 创建单元格样式 NPOI.SS.UserModel.ICellStyle cellStyle = workbook.CreateCellStyle(); cellStyle.BorderTop = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderRight = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderBottom = NPOI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28ddb016f061d4863b3314f4a1f26cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1529d57db911ce7119eef59ebf7672e/" rel="bookmark">
			lombok注解@Cleanup解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本介绍： 添加maven 依赖后，还需要添加Lombok 插件，插件这里就不介绍了，主要讲下注解@Cleanup
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 使用场景 当在处理文件对象，或者数据库资源时，我们总是会忘记close，可能引发内存溢出。
如果手动去调用close方法，代码又会非常长，@Cleanup可以很好的解决这个问题。
简单示例
package com.test; import lombok.Cleanup; /** * 测试@Cleanup */ public class Test { /** * 状态 * true : 打开 * false : 关闭 */ private boolean status; public Test() { this.status = true; System.out.println("初始化，状态: "+this.status); } public void operation() { System.out.println("业务操作..."); } public void close() { this.status = false; System.out.println("关闭，状态: "+this.status); } //main方法测试 public static void main(String[] args) { @Cleanup Test test = new Test(); test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1529d57db911ce7119eef59ebf7672e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593dada07b7489cbf10b7db4dfdc3ac5/" rel="bookmark">
			list排序，普通排序，java8lambda 表达式和stream排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		list集合的几种排序方式： 1、Collections.sort(list&lt;基本类型&gt;)
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(3); list.add(5); list.add(1); Collections工具类，升序排:
Collections.sort(list); System.out.println(list); Collections工具类，降序排:
Collections.reverse(list); System.out.println(list); 1.1Collections.sort(list&lt;基本类型&gt;) 使用java8
list.sort(Integer::compareTo); System.out.println(list); 2、Collections.sort(list&lt;字符串&gt;)
public void printListStringSort(){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("15"); list.add("123"); list.add("10"); list.add("9"); list.add("3"); System.out.println( "---------------升序排列----------------" ); // 升序排列 Collections.sort(list, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { int num1 = Integer.parseInt(o1); int num2 = Integer.parseInt(o2); if (num1 &gt; num2) { return 1; } else if (num1 &lt; num2) { return -1; } else { return 0; } } }); for (String str : list) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/593dada07b7489cbf10b7db4dfdc3ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14bad5b3c9e130b6e9b63a0582c1f83f/" rel="bookmark">
			【开发踩坑】EXT-X-DISCONTINUITY 合并多个 m3u8 文件到一个 m3u8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景问题原因解决方案参考资料 背景 因业务需求，需要将多个 m3u8 文件合并成一个。解析 m3u8 文件以后，发现一个文件分为 3 部分，第一部分是 #EXTM3U 这些文件头，第二部分是 ts 后缀的视频分片文件，第三部分就是 #EXT-X-ENDLIST 结尾。所以我的思路就是将多个 m3u8 文件的 ts 都提取出来合并到一起，然后加上头和结尾。
问题 合并出来的文件能正常播放，但是每次第一个视频文件播放完以后就不自动播放第二个视频了。
原因 原因是拼接的 2 个 ts 文件的时间不连续了，所以不会自动续播。
解决方案 在两个拼接的视频文件之间加上 #EXT-X-DISCONTINUITY。如下所示：
#EXTINF:6 https:xxxx.ts #EXT-X-DISCONTINUITY // 两断不连续的视频中间加上 #EXT-X-DISCONTINUITY tag #EXTINF:6 https:xxxx.ts 参考资料 https://stackoverflow.com/questions/64842167/can-i-merge-multiple-m3u8-files-into-one-m3u8-file
https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-23#section-4.3.2.3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65fa4c7db59bf94bfb2506da659d8f3b/" rel="bookmark">
			取消win10系统自动更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人电脑是拯救者win10系统，一直提醒自动更新，特别烦，然后就找了个教程取消掉自动更新，教程链接为：彻底关闭win10自动更新_名字长点容易记住的博客-CSDN博客下面是本人在取消自动更新时遇到的麻烦。
1、找不到Update Orchestrator Service
可能因为版本的问题，链接中的有这个，这个在我这里变成了“更新Orchestrator服务”
这样就可以了。
2、没有gpedit.msc，没有本地组策略编辑器
参考win10本地组策略编辑器找不到怎么办（超详细，超易懂）_满城皆是木棉花的博客-CSDN博客_本地组策略编辑器找不到
@echo off
pushd "%~dp0"
dir /b %systemroot%\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;gp.txt
dir /b %systemroot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;gp.txt
for /f %%i in ('findstr /i . gp.txt 2^&gt;nul') do dism /online /norestart /add-package:"%systemroot%\servicing\Packages\%%i"
pause
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1666d4ef083a4f8211c77877018508e8/" rel="bookmark">
			IDEA Translation插件安装及设置鼠标悬浮提示的自动翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、安装插件 Translation 2.设置鼠标悬浮提示 3.在代码界面鼠标悬停在方法上 就会自动翻译提示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc49db7c360e621f54cfd0f88df05c58/" rel="bookmark">
			Visual Studio Code 单独设置项目文件默认编码 或其他个性配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCODE通过设置页面，或Ctrl-Shift-P快捷方式打开配置和设置页面相同，均只能修改全局默认文件编码。
其实VSCODE是可以单独进行项目设置的，通过项目的json配置文件即可，配置方式可参考默认配置文件。
通过Ctrl-Shift-P，输入settings，查找到“首选项：打开默认设置”，defaultSettings.json
再次使用Ctrl-Shift-P，输入settings，向下拉查找到“首选项：打开工作区设置”
将defaultSettings.json中的“files.encoding”项（上面注释内容说面了支撑的编码格式）
加入到工作区设置json文件的“settings”中
重起vscode或重新打开工作区即可生效。
这种方法同样适用于其他的设置项。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f177b6c2c39962208822a8faeb6ca05b/" rel="bookmark">
			Vue兄弟组件之间的通信：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：
通过中间人父组件进行通信；
子组件先传给父组件，然后父组件再传给另一个子组件； &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="../lib/vue.js"&gt;&lt;/script&gt; &lt;style&gt; div img{ width: 100px; } .active{ width: 300px; min-height: 200px; background-color: yellow; position: fixed; right: 50px; top: 100px; border: 1px solid blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt; &lt;button @click="handleAjax"&gt;ajax&lt;/button&gt; &lt;film-item v-for="item in datalist" :key="item.filmId" :mydata="item" @event="handleEvent"&gt;&lt;/film-item&gt; &lt;film-detail :film-data="filmData"&gt;&lt;/film-detail&gt; &lt;/div&gt; &lt;script&gt; Vue.component("filmItem",{ props:['mydata'], template:` &lt;div&gt; &lt;img :src="mydata.poster"&gt; {{mydata.name}} &lt;button @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f177b6c2c39962208822a8faeb6ca05b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d258fc1f2963dbd0991df56a0c0f3b75/" rel="bookmark">
			DW运用HTML&#43;CSS建网站（2）成品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-type" content="text/html; charset=UTF-8" /&gt; &lt;title&gt;CompanyName - PageName&lt;/title&gt; &lt;meta http-equiv="Content-Language" content="en-us" /&gt; &lt;meta name="description" content="Description" /&gt; &lt;meta name="keywords" content="Keywords" /&gt; &lt;meta name="author" content="Enlighten Designs" /&gt; &lt;link rel="stylesheet" type="text/css" href="css/master.css"/&gt; &lt;link rel="stylesheet" href="master1.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="page-container"&gt; &lt;div id="page-container"&gt; &lt;div id="main-nav"&gt; &lt;ul&gt; &lt;li id="about"&gt;&lt;a href="#" &gt;About&lt;/a&gt;&lt;/li&gt; &lt;li id="services"&gt;&lt;a href="#" &gt;Services&lt;/a&gt;&lt;/li&gt; &lt;li id="portfolio"&gt;&lt;a href="#" &gt;Portfolio&lt;/a&gt;&lt;/li&gt; &lt;li id="contact"&gt;&lt;a href="#" &gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d258fc1f2963dbd0991df56a0c0f3b75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1797014c736f5b932ca68338a26d061e/" rel="bookmark">
			UNet网络解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNet解读 UNet论文UNet的简介代码解读DoubleConv模块Down模块Up模块OutConv模块 整个UNet参考资料 UNet论文 UNet论文地址
UNet的简介 UNet是一个对称的网络结构，左侧为下采样，右侧为上采样；下采样为encoder，上采样为decoder;四条灰色的平行线，就是在上采样的过程中，融合下采样过程的特征图的通道，Concat 原理就是：一本大小为10cm10cm的书，厚度为3cm的书本（10103）的A书，和一本大小为10cm10cm，厚度为4cm的B书（10103）将A书和B书，边缘对齐的摞在一起，这样就可以得到一个大小10107的一摞书了所以对feature map,一个大小为256*256*64的feature map(w为256，h为256，c为64)，和一个大小为256*256*32的feature map进行Concat融合，你就会得到一个大小为256*256*96的feature map在实际使用中，Concat融合的两个feature map的大小不一定相同，例如25625664的feature map和24024032的feature map进行Concat 两种方法 1.将大的256*256*64的feature map进行裁剪，裁剪为240*240*64的feature map，比如上下左右，各舍弃8 pixel，裁剪后再进行Concat，得到24024096的feature map。2.将小的240*240*32的feature map进行padding操作，padding为256*256*32的feature map，比如上下左右，各补8 pixel，padding后再进行Concat，得到25625696的feature map。 UNet采用的Concat方案就是第二种，将小的feature map进行padding，padding的方式是补0，一种常规的常量填充。（详细看代码Up） 代码解读 组成U-Net的模型块主要有如下几个部分：
1）每个子块内部的两次卷积（Double Convolution）
2）左侧模型块之间的下采样连接，即最大池化（Max pooling）
3）右侧模型块之间的上采样连接（Up sampling）
4）输出层的处理（OutConv）
DoubleConv模块 两次卷积操作： class DoubleConv(nn.Module): # mid_channel是第一次conv的out和第二次conv的输入 def __init__(self, in_channels, out_channels, mid_channels=None): super().__init__() if not mid_channels: mid_channels = out_channels self.double_conv = nn.Sequential( # 大小 (高宽 + 2*padding - kernel_size)/stride + 1 # (572 + 2*0 - 3 )/1 +1 = 570 # 通道1-&gt;64 nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1797014c736f5b932ca68338a26d061e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eccd5ff1e06792a8f1216c99c6c4002/" rel="bookmark">
			Python基本数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、变量和常量 1、变量。是一种可变化的量，一个用于存储数据的空间。如定义变量a并赋值为2
&gt;&gt;&gt; a=2 &gt;&gt;&gt; print(a) 输出结果：2 2、常量。是固定不变的量，指定数据值。如指定常量100
&gt;&gt;&gt; print(100) 输出结果：100 二、数据类型 1、数字型 Number：int 有符号整型，long 长整型， float 浮点型，complex 复数型
2、布尔型 Bool：两个逻辑值 True和False
3、字符串型 String
4、列表型 List，数据元素可变
数据形式：[数据1，数据2，数据3.……]利用索引访问列表元素，下标从0开始列表切片：[ 开始位置 ：结束位置] 5、元组型 Tuple，一种数据元素不可变的列表
数据形式为(数据1，数据2，数据3，……)，是一种特殊形式的列表，适用于列表的所有操作 6、字典型 Dictionary，一种由键值对构成的数据{键：值}。每个键值对是一组数据，各组数据之间以逗号分隔。数据元素可变
-访问数据值：通过键值访问对应数据值，如
&gt;&gt;&gt; dict = {'tan':'xianchao','song':'shiyu','ma':'wan'} &gt;&gt;&gt; dict['tan'] 输出结果为：'xianchao'，成功访问字典中的值 添加键值对：指定字典名和对应键值，如 &gt;&gt;&gt; dict['wang']='jinjun' &gt;&gt;&gt; print(dict) 输出结果为 {'tan': 'xianchao', 'song': 'shiyu', 'ma': 'wan', 'wang': 'jinjun'} 新的键值对添加成功
-通过.keys()方法遍历字典中的所有键
In [5]: for data in dict.keys(): ...: print(data); ...:（以下内容是输出结果） tan song ma wang -通过.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eccd5ff1e06792a8f1216c99c6c4002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5249a772f0627cd02aaaf2fbd2d2ae0c/" rel="bookmark">
			同态加密库Seal库的安装（win11&#43;VS2022）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说一下，seal库是微软开发的同态加密库，目前支持三种算法bfv，bgv和ckks。提供的语言版本是C艹和C#。
工具准备 这是github上提供的要求。
要准备的东西有
vs2022（社区版就行了，网上一堆教程），cmake（最新版貌似是3.25，网上也有一堆教程），git（这个主要是因为后续在下载seal库的时候会调用，所以得装上），去GitHub上把seal库打包下下来解压出来，假定解压出来的文件夹为SEAL。 安装步骤 以管理员权限打开vs的命令行窗口 cd进入SEAL文件夹，三个命令按顺序敲 cmake -S . -B build -G "Visual Studio 17 2022" -A x64 cmake --build build --config Release cmake --install build 第一个命令下载库的时候可能会报错链接问题，最好是科学上网，不然就只能多多尝试几次
全部执行完后可以看到SEAL下会多个build文件夹
里面的内容长这样
这就算安装完成
运行环境调整 打开vs2022，新建一个空项目，然后随便建立一个cpp文件，不然你会看不到属性里的c/c++选项。然后右键项目属性 配置附加目录 c++ 语言标准 链接器里面的附加库目录 最后是输入里的附加依赖项 测试 注意测试的是需要调整这两个的
同时也要调整运行库
不然会报错类似
error LNK2038: 检测到“RuntimeLibrary”的不匹配项: 值“MT_StaticRelease”不匹配值“MD_DynamicRelease”
可以根据报错的具体信息来调整
最后是测试代码
#include "seal/seal.h" using namespace seal; 不保存就算安装成功。
如果要跑官方给的例子的话
把SEAL\native\examples里面的例子扔到项目就行
跑出来的结果大概长这样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b9e6557f251f1ceec31c43d1e7f31d0/" rel="bookmark">
			frp穿透你的远程桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缘起 作为一个程序员，经常会遇到需要使用远程桌面的述求（居家办公、加班，你懂的）。所以，在网上找一圈远程桌面解决方案之后，最终还是使用frp来穿透远程桌面。（推荐使用）
前提 需要一台有公网ip的服务器，腾讯云服务器或者阿里云服务器都可以需要会docker的基本使用知晓内网穿透frp的使用针对windows系统的远程桌面配置 公网搭建frps服务端 本文服务端基于 docker安装 frps，镜像使用snowdreamtech/frps。
详细配置请参考frp文档。
配置文件frps.ini
# [common] is integral section [common] # A literal address or host name for IPv6 must be enclosed # in square brackets, as in "[::1]:80", "[ipv6-host]:http" or "[ipv6-host%zone]:80" bind_addr = 0.0.0.0 bind_port = 7000 # udp port to help make udp hole to penetrate nat #bind_udp_port = 7001 # udp port used for kcp protocol, it can be same with 'bind_port' # if not set, kcp is disabled in frps #kcp_bind_port = 7000 # specify which address proxy will listen for, default value is same with bind_addr # proxy_bind_addr = 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b9e6557f251f1ceec31c43d1e7f31d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468ebf1dfdfa68a60d59e1e64048d7f0/" rel="bookmark">
			goland2022.2取消自动删除暂未使用的包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		settings中搜索optimize
取消勾选下面两张图所示的位置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16123ab594c38721d9d2c91f5572c682/" rel="bookmark">
			C#读取和写入文件（干货分享）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、读取文件 读取的文件内容不多： 可以使用 File.ReadAllText(FilePath) 可以指定编码方式 File.ReadAllText(FilePath, Encoding)的方法。可以使用File.ReadAllLines(FilePath)可以指定编码方式File.ReadAllLines(FilePath, Encoding)的方法 这些方法都是一次将文本内容全部读完，
前两种方法返回一个包含全部文本内容的字符串；
后两种返回一个字符串数组，每一行都是一个数组元素。
如何使用：
string str = File.ReadAllText(@"c:\temp\ascii.txt");//第一种 string str2 = File.ReadAllText(@"c:\temp\ascii.txt", Encoding.ASCII);//第二种 string[] strs = File.ReadAllLines(@"c:\temp\ascii.txt"); //第三种 string[] strs2 = File.ReadAllLines(@"c:\temp\ascii.txt", Encoding.ASCII);//第四种 读取的文件内容较多：
我们就不要将文本内容一次读完，而应该采用流（Stream）的方式来读取内容。.Net为我们封装了StreamReader类。初始化StreamReader类有很多种方式。
可以使用StreamReader（FilePath）可以指定编码方式 StreamReader(FilePath, Encoding)可以使用StreamReader（FileStream）可以指定编码方式StreamReader(FileStream, Encoding) 可以使用File.OpenText（FilePath）可以使用FileInfo.OpenText() 如何使用：
StreamReader sr1 = new StreamReader(@"c:\temp\utf-8.txt"); //第一种 StreamReader sr2 = new StreamReader(@"c:\temp\utf-8.txt", Encoding.UTF8);//第二种 FileStream fs = new FileStream(@"C:\temp\utf-8.txt", FileMode.Open, FileAccess.Read, FileShare.None); //初始化FileStream StreamReader sr3 = new StreamReader(fs); //第三种 StreamReader sr4 = new StreamReader(fs, Encoding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16123ab594c38721d9d2c91f5572c682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d6bd176846a53e4cb255ad590b65d6c/" rel="bookmark">
			攻防世界 crypto---simpleRSA wp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言题目解题过程求解E1求解E2求P以及flag 前言 亚雷，你还知道更新博客啊？
题目 #!/usr/bin/env python3.9 # -*- coding: utf-8 -*- import gmpy2 from Crypto.Util.number import getPrime, isPrime, bytes_to_long from secret import FLAG, E1, E2, P, Q1, Q2 def next_prime(num: int) -&gt; int: num = num + 2 if num % 2 else num + 1 while not isPrime(num): num += 2 return num p = getPrime(1024) q = next_prime(getPrime(16) * p + 38219) n = p * q c = pow(E1, 65537, n) print(f'n = {n}') print(f'c = {c}') # n = 1605247600724752598798254639224215706171506359654961357324428027985787942008103766562745464838961569081446916113769517713344420113584254259000172572811154232107339480903672251992191997458469905064423618888336088652352540882576826988355783159237971043770132628344798937353150930071309347972804118952814447576207066147031238749098842662046825743988208813903138796789940911515825517078554074496474819128789835309636804325132602557092847746454786387067599510769382078521691609970320528531270474091713477040343897269903489441410062592732302402854035415438078656688806905350495825334584533345448091335565792091890185673190424063 # c = 751639057610677013264061431434189083017589908118307247217007533938435229431015858783222167911772848893015518607229280589985711010766459396989232072512314594917029375221335361209036112742388866873824163350886610514973038316512032459352053158417705406031466332440378871927174731975794579894912999936641163063898365134788537389162378185448090279397717831977803284480743612393591614284972981435749362255654561121758163485884075260156288337176713756471879489767416836868661153693157792733142765671887792303181376620864506386820826866340907593080654521498766421056474652652337037121881207188033108746890998208582406826010121861 assert E2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d6bd176846a53e4cb255ad590b65d6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a470d78945fcb1b9db5bf6e0014a3af7/" rel="bookmark">
			脑电数据相关分析参数 定义 后续实现陆续增加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1
第一章 常规脑电相关素材积累 3
1实时分析 3
1.1癫痫发作报警 3
1.2脑电双频指数（BIS）值 3
1.3大脑状态指数（CSI） 3
2非实时分析 3
2.1脑电图频域分析fft变换，插值运算 3
2.2功率谱图显示（多导，单导单独放大显示） 3
2.3脑电地形图（绝对，相对两种显示方式） 3
2.4压缩谱阵图 3
2.5单频地形图 3
2.6三维旋转脑电地形图 3
2.7侧视地形图 3
2.8数值地形图、梯形图 3
2.9频谱直方图 3
2.10睡眠分析模块 4
3 其他脑电分析 4
3.1尖棘波自动检测 4
3.2新生儿惊厥识别分析 4
3.3事件相关ERP诱发 4
3.4 P300、CNV、P50等事件相关电位检查功能 4
第二章 量化脑电相关素材积累 4
1 彩色密度谱阵列cDSA 4
2.1绘制方法 4
参考 脑电彩色密度谱阵列监护仪的研制_张庆陵
2 振幅整合脑电图aEEG 5
2.2绘制方法 5
参考 正常新生儿及婴儿睡眠振幅整合脑电图分析_张丹丹
参考 百度文库
参考：结合传统特征和深度特征的新生儿脑功能状态自动辨识研究_刘立喆.caj
参考 aEEG对新生儿脑功能监测意义 - 百度文库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a470d78945fcb1b9db5bf6e0014a3af7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dda120d923874f65daf6728f5225845/" rel="bookmark">
			dataframe数据分析常用操作汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dataframe的常用操作汇总
目录
1.建 1
2.读 2
3.存 2
4.阅 2
5.取 2
6.改 4
7.增 4
8.删 5
9.并 5
10.序 7
1.建 创建只有一列的数据框
df = pd.DataFrame([1, 2, 3, 4, 5], columns=[‘宽度’], index=[‘a’, ‘b’, ‘c’, ‘d’, ‘e’])
创建3行2列的数据框
df = pd.DataFrame([[1, 2], [3, 4], [5, 6]], columns=[‘分数’, ‘长度’], index=[‘a’, ‘b’, ‘c’])
对行命名
df.index.name = ‘公司’
创建3行2列的数据框
df = pd.DataFrame({‘key1’: [1, 2, 3], ‘key2’: [4, 5, 6]})
创建2行3列的数据框
df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dda120d923874f65daf6728f5225845/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e65591fbd83e5ee32328ad132fb25424/" rel="bookmark">
			ubuntu下载cuda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ubuntu下载cuda-11.7 18.04 wget https://developer.download.nvidia.com/compute/cuda/11.7.1/local_installers/cuda_11.7.1_515.65.01_linux.run sudo sh cuda_11.7.1_515.65.01_linux.run 20.04 wget https://developer.download.nvidia.com/compute/cuda/11.7.1/local_installers/cuda_11.7.1_515.65.01_linux.run sudo sh cuda_11.7.1_515.65.01_linux.run 22.04 wget https://developer.download.nvidia.com/compute/cuda/11.7.1/local_installers/cuda_11.7.1_515.65.01_linux.run sudo sh cuda_11.7.1_515.65.01_linux.run ubuntu下载cuda-11.6 18.04 wget https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda_11.6.2_510.47.03_linux.run sudo sh cuda_11.6.2_510.47.03_linux.run 20.04 wget https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda_11.6.2_510.47.03_linux.run sudo sh cuda_11.6.2_510.47.03_linux.run 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/086b5060f17a01330385dddb62186825/" rel="bookmark">
			java8新特性使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Stream api2 Collect to Map Map&lt;String, String&gt; result = effectList.stream().collect( Collectors.toMap(BusiDisposalProveEffectInfo::getDeclareId, BusiDisposalProveEffectInfo::getRegAttachmentId)); Collect to List or Set List&lt;String&gt; idList = resultList.stream().map(BusiDisposalProveListVO::getId).collect(Collectors.toList()); Filter Set&lt;String&gt; idSet = resultList.stream() .filter(e -&gt; StringUtils.equals(e.getStatus(), DeclareStatusEnum.SUCCESS.getCode())) .map(BusiDisposalProveListVO::getId) .collect(Collectors.toSet()); Consumer // 相加并将结果回调回去 public void f1(int a,int b,Consumer&lt;Integer&gt; callback){ callback.accept(a+b); } // 调用并打印 f1(1,2,result -&gt; { System.out.println(result); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06c57fd6324566dc6eab7ba5134da807/" rel="bookmark">
			drools规则引擎可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：drools规则引擎可视化
Drools是一款基于Java的优秀的规则引擎，将复杂多变的业务规则从硬编码中解放出来，以规则脚本的形式存放在文件中，使得修改规则不需要改动代码重启服务就能生效。
Drools有一定的学习成本，官方英文文档非常详细，但中文文档少，本文将通过一篇文章来介绍Drools的使用和动态部署，这也是我学习过后的总结，希望对你入门Drools有帮助。
官网地址：https://www.drools.org/
github: https://github.com/kiegroup/drools
一、简单使用 给不同商品设置不同折扣。
1.1 pom.xml &lt;dependency&gt; &lt;groupId&gt;org.droolsgroupId&gt; &lt;artifactId&gt;drools-compilerartifactId&gt; &lt;version&gt;7.23.0.Finalversion&gt;dependency&gt; 1.2 kmodule.xml kmodule.xml 文件用于配置规则脚本，可以有多个kbase
文件放在项目resources/META-INF目录下可以自动加载
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt; &lt;kbase name="rules" packages="rules"&gt; &lt;ksession name="ksession-rule"/&gt; 1.3 Product Bean实体 //lombok注解@Datapublic class Product { public static final String DIAMOND = "DIAMOND"; public static final String GOLD = "GOLD"; private String type; private int discount; } 1.4 Rules.drl resources/rules/Rules.drl 规则脚本
package rulesimport drools.Product // 当商品类型是DIAMOND时,打折为15% rule Offer4Diamond when productObject:Product(type == Product.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06c57fd6324566dc6eab7ba5134da807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9979e981bae4e2289a8fe884d89bcc94/" rel="bookmark">
			如何在Arcmap 中提取多段影像的某个波段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Arcmap中打开包含多个波段的影像
2.在菜单栏依次点击窗口——影像分析——选中要提取的影像——添加函数
弹出函数模板编辑器后，右击影像依次选择插入函数——波段提取函数
在弹出的栅格函数属性窗口中，依次点击提取波段——波段（要提取的波段）——组合（被提取的波段）——确定
提取完毕
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/187/">«</a>
	<span class="pagination__item pagination__item--current">188/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/189/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>