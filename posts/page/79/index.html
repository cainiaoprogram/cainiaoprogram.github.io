<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b51f9bc29441e22c274fdc4e853350/" rel="bookmark">
			洗衣机平台设计思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概述 随着人们的生活水平的日益提高，洗衣机的使用也越来越普及，目前全国的洗衣机的年产量已超过1000万台。洗衣机的分类较多，根据不同的角度大致可分如下几类：
洗衣机从不同洗衣的原理来说可分为波轮洗衣机、滚筒洗衣机、以及搅拌式洗衣机。
洗衣机从结构上又可分为：单缸和双缸洗衣机；
洗衣机从水流方式上又可分为：瀑布水流、手搓水流、悬浮水流等；
洗衣机从电机的驱动方式上又可分为：间接驱动和直接驱动（DD型洗衣机）；
从洗衣机的电机的驱动电源的不同可分为：普通洗衣机和变频洗衣机，其中变频洗衣机又可分为：直流变频洗衣机和交流变频洗衣机；
从洗衣机的显示方式来分有：LED灯显示、数码管显示、LCD显示、以及VFD显示。
目前在国内波轮洗衣机占洗衣机用量的大部分，滚筒洗衣机和搅拌式洗衣机在国内很少，主要在欧美的家庭大量使用。但近几年滚筒洗衣机洗衣机在国内的市场呈快速增长。
主要功能 波轮洗衣机主要功能完成洗衣过程中的进水、排水、洗涤、漂洗、脱水、自动跳电、故障自检等功能。目前市场推出的健康型洗衣机还要完成消毒、杀菌功能。
滚筒洗衣机的主要功能除上面提到的波轮洗衣机的主要功能外，还有给水加热和温控，以及烘干衣物等功能。
产品硬件 1. 结构图及功能划分
2．硬件功能模块
全自动洗衣机的电路包含220V交流负载驱动电路，IC和蜂鸣器工作用的低压直流电路及高低压共路的电路。电脑程控器一般由下列九部分电路组成：
单片机程控器控制中心 单片机IC是程控器的控制中心，IC的ROM中固化了预定程序，一般均采用8位微处理器（CPU）的IC，它由算术逻辑单元ALU、可掩膜程序存储器ROM、数据存储器RAM、输入输出接口以及控制计时、定时逻辑单元等组成。IC工作时，对各功能键进行扫描处理，根据功能键设置情况输出响应的控制信号。
(2) 直流电源电路
电气控制系统一般需两种直流电源：+5V和+12V，其中+5V作为IC、LED显示电路、三极管放大器驱动双向可控硅的直流电源；+12V直流电压供给蜂鸣电路及继电器。
在控制器中，输入的电源为交流220V±15%，50HZ。为提高整个控制器的抗干扰能力，一般在电源L与N之间加上一104M 275V的X2安规电容，该可有效吸收大部分外来干扰，另外为提高整个控制器的抗雷击能力，在交流输入侧加上一个压敏电阻，以吸收大部分因雷击带来的外来能量，保护整个控制器不被损坏。考虑到成本，在洗衣机控制器中的压敏电阻一般采用10D621K。
控制器中的电源主要向继电器、可控硅、LED灯、以及蜂鸣器等供电，负载电流较大，为有效抑制滤波后的电源的纹波，我们在稳压片7805的输入和输出端各加一个电解电容，一般在7805输入端加电容较大为1000uf/25V(如果整个控制器所驱动的负载较多时，为保证通过电压跌落实验需将该电容选得大一些2200uf/25V)，7805的输出端一般加一个100uF/16V的电解电容。另外为提高整个电源部分的抗干扰能力，一般在7805的输入和输出端还须各加一个高频电容（以吸收外来的各种高频干扰信号。在洗衣机控制器的设计过程，对高频电容的选取，一般不选用瓷片电容和独石电容，而选用纸介电容，如涤纶电容和金属聚脂膜电容。
洗衣机控制器整个电源部分的电路如附图1所示。
（3）过零检测电路
由分压电阻及脉冲信号电路组成，将交流电过零点所产生的同步信号输入给IC，以作为双向可控硅过零触发的同步触发信号。（见附图2）
按键电路 功能键电路是将选择开关按一定的顺序排列而组成的电路。按下不同的功能键时，不同的键扫脉冲有该键所在的行输入到IC接口中，由IC判断处理，以设定不同的功能并转入相对应的工序，由IC的输出端输出控制信号。从键按下到接触稳定要经过数毫秒的抖动，键松开时也有同样的问题。为了解决按键抖动的问题，在硬件上采用了RC滤波器来克服抖动；在软件上采用了动态扫描按键延时的方式来避免因键抖动而造成的重复键问题。（见附图）
显示电路 显示电路一般由发光二极管（或LED、LCD组成），由IC输出端巡回输出显示信号，使显示电路发光二极管（或LED、LCD）交替发光显示，以显示洗衣机的运转状态。
发光二极管的电路一般采用的是三极管的驱动放大来使得发光二极管的亮灭。
对于LED必须采用直流电压驱动，LED是电阻性负载，动态响应快。工作电压为1.5-5V。（见附图4）
对于LCD必须采用交流（方波）驱动电压，以防止液晶材料分解失效，LCD是容性负载，动态响应慢。工作电压为2-6V。（见附图5）
复位电路 复位电路一端接于直流电源的三端稳压器输出，一端接于IC，当电源出现低电压或电源有间断时，稳压输出端的直流电压不正常，复位电路便将IC内部存储器清零，使IC始终处于初始状态，以防止工作状态混乱。
目前采用的复位电路是RC充放电电路，其中二极管D是用于电源电压跌落时对电容上的电荷快速放电。其中电阻R最好小于40000欧姆，这样才能确保R两端的电压将不超过0.2V, 以免在复位引脚上压降过大而影响引脚上的高电平。（见附图6）
LC振荡电路(时钟电路) LC元件和IC内部电路组成的振荡电路为LC提供了几兆赫的时钟信号，程控器的一切程序功能都是在时序脉冲控制下，严格地按指令周期完成。
报警电路 三极管、电阻和陶瓷蜂鸣片等构成报警电路，当有信号给蜂鸣片使之发声，表示按键按动有效，程序执行终了以及异常运转状态等。（见附图7）
负载驱动电路 以双向可控硅为电源开关的电路。按钮选择开关发出操作指令给IC，IC根据指令按预定的程序向各个双向可控硅控制极输出控制信号，使各双向可控硅按程序导通，电机等按程序运转，洗衣机按程序工作。与各个触发电路上相连的是ULN2003反向驱动放大芯片，是总控门，只有它发出信号，各个可控硅才可能导通或截止。与双向可控硅驱动电路并联的压敏电阻，是用以吸收瞬间高压，保护双向可控硅的安全。在保护回路是一个并接在双向可控硅阳极之间的RC网络。可控硅的负载都是小电感负载，他们容易受到机器内外的干扰而误动作，这样保护回路中的小电阻R不仅不会影响对负载的控制，而且还可以起到限制电容通过双向可控硅的放电电流，同时负载电感和电容构成了高频滤波器，从而保证了可控硅的正常工作。（见附图8）
目前我们公司设计洗衣机控制器中所采用的可控硅主要有：T8300-800W，T435-800W、Z0110NA、BT134-800等几款。洗衣机控制器中所采用可控硅一般都要求耐压为800V，而且门电流加大（大约在25mA~35mA之间），选用较大门电流的可控硅主要为提高控制器的抗干扰能力，防止在有干扰条件下可控硅误通。
在洗衣机控制器的设计过程中，为提高抗干扰能力，一般在可控硅的门极要加上一个104的电容，在做PCB板时应尽量将该电容靠近可控硅的门极，否则将减少其效果。
可控硅的驱动在没有采用78012时，其驱动电源尽量采用+5V电源来驱动，该方式可避免因网络电压的波动影响可控硅的驱动。另外，在计算可控硅的门极电流时，将其电流值靠近该可控硅的最大门极电流，这样可避免在低温条件下可控硅的导通情况。
电脑控制器的软件流程 总体框图及功能划分 软件框图 1） 主要完成各个子程序的调用任务。
2)主要完成洗衣机电机的运行过程、时间定时、水位检测、微动检测、按键扫描、LCD显示驱动等。
3）主要完成有键按下，按了哪一个键以及键值处理等。
4)故障报警是洗衣机的自我保护功能，可防止进水阀、电磁铁长时间通电而被烧坏。发出故障报警后需人工排除异常。
5）不平衡修正是指在桶内脱水衣物偏于一边而使安全开关频繁通断而出现撞桶。在进行不平衡修正过程中，即先进水后在漂洗3分钟进行不平
衡处理，目的是使脱水衣物重新分布均匀，然后再脱水。
6）控制器的所有运行显示、暂停显示、自检显示、故障显示都在显示处理子程序里体现 。
7）主要检测正常运行至脱水时，如果安全开关没接通则运转停止，并发出报警。这是因桶盖没关造成的。
8）主要完成是否有键按下，并完成按键的去抖动工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7af2bce40b744d7277cb20afa0701e/" rel="bookmark">
			Android应用：实现网络加载商品数据【OKHttp、Glide、Gson】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现网络加载商品数据的功能：
1、在AndroidManifest.xml中声明网络权限；
2、在app/build.gradle中添加okhttp, glide, gson等必需的第3方库；
3、在MainActivity中通过OkHttpClient连接给定的Web服务，获取商品数据；对应的json数据为本地的json文件，名字为goods_list_data.json;数据内容为：[
{“id”:1,“count”:“5.4万”,“goodsName”:“富士拍立得相机”,“goodsPic”:“/img/polaroid.png”},
{“id”:2,“count”:“5.3万”,“goodsName”:“格兰仕微波炉”,“goodsPic”:“/img/microwave_oven.png”},
{“id”:3,“count”:“1.4万”,“goodsName”:“新国标电动车”,“goodsPic”:“/img/electric_vehicle.png”},
{“id”:4,“count”:“1.6万”,“goodsName”:“官方订制投影仪”,“goodsPic”:“/img/projector.png”},
{“id”:5,“count”:“0.4万”,“goodsName”:“美的35L烤箱”,“goodsPic”:“/img/oven.png”},
{“id”:6,“count”:“3.3万”,“goodsName”:“儿童学习桌”,“goodsPic”:“/img/learning_table.png”}
]
对应的图片也存储在本地的img文件中
4、使用gson库解析JSON格式的商品数据，转成java bean商品数据对象（Goods类）的列表；
5、创建MsgHandler类，用于异步更新商品列表；
6、在GoodsAdapter中通过glide控件加载并显示网络图片。
1.部署网络图片资源 首先，我们需要将对应的文件部署在一个简易的服务器（Tomcat）中，服务器中存放数据的目录结构如下图所示
E:. ├─goods │ └─img │ └─goods_list_data.json └─WEB-INF 其中，ROOT目录在"apache-tomcat-9.0.65-windows-x64\webapps\ROOT"下，表示Tomcat服务器的根目录。
goods文件夹存放的是商品列表所用到的数据其中goods\img文件夹存放的是商品的图片资源goods_list_data.json文件存放的是商品列表的数据，具体如下所示 [ {"id":1,"count":"5.4万","goodsName":"富士拍立得相机","goodsPic":"/img/polaroid.png"}, {"id":2,"count":"5.3万","goodsName":"格兰仕微波炉","goodsPic":"/img/microwave_oven.png"}, {"id":3,"count":"1.4万","goodsName":"新国标电动车","goodsPic":"/img/electric_vehicle.png"}, {"id":4,"count":"1.6万","goodsName":"官方订制投影仪","goodsPic":"/img/projector.png"}, {"id":5,"count":"0.4万","goodsName":"美的35L烤箱","goodsPic":"/img/oven.png"}, {"id":6,"count":"3.3万","goodsName":"儿童学习桌","goodsPic":"/img/learning_table.png"} ] 启动tomcat后，可访问http://localhost:8080/goods/goods_list_data.json展示信息
2.创建项目 打开Android Studio，并创建一个新的Android项目。命名项目并选择适当的目标API级别和设备类型。创建一个新的空白活动（Empty Activity）。 3.在AndroidManifest.xml中声明网络权限 在 AndroidManifest.xml 文件中添加以下权限声明，以便应用可以访问网络：
&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 由于网络安全策略导致的问题，即不允许在明文（非加密）的情况下与 localhost 进行通信。这通常涉及到网络安全配置，特别是在 Android 9.0（API级别28）及更高版本中引入了更严格的网络安全策略；因此我们还需要进行配置网络安全配置文件
解决此问题的方法之一是使用 HTTPS 协议而不是 HTTP，因为 HTTPS 是加密的。
如果在本地测试应用，可以使用 Android 的网络安全配置文件来允许明文通信。
在 res/xml 文件夹中创建一个名为 network_security_config.xml 的网络安全配置文件。如果该文件夹不存在，请手动创建。 &lt;?xml version="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7af2bce40b744d7277cb20afa0701e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f224dacc24ec893fd313a513fde716/" rel="bookmark">
			【PyQt学习篇 · ②】：QObject - 神奇的对象管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 QObject介绍Object的继承结构测试QObject对象名称和属性QObject对象名称和属性的操作应用场景 QObject父子对象QObject父子对象的操作 QObject的信号与槽QObject的信号与槽的操作 QObject介绍 在PyQt中，QObject是Qt框架的核心对象之一。QObject是一个基类，它提供了对象之间的信号和槽机制、父子对象关系管理、对象属性以及事件处理等功能。
以下是QObject类的一些常用特性和功能：
信号和槽机制：QObject支持信号和槽机制，用于实现对象之间的通信。通过定义信号和槽，可以在事件发生时触发、连接和处理功能。信号可以在特定条件下被发射，而槽则是处理信号的函数。
父子对象关系：QObject支持父子对象关系的管理。可以使用setParent()方法将一个QObject对象设置为另一个QObject对象的父对象。当父对象被销毁时，它会负责销毁其所有的子对象。
对象属性：QObject支持动态属性机制，可以通过setProperty()方法设置对象的属性值，并可以通过property()方法获取属性值。属性可以用于存储对象的状态或其他自定义信息。
事件处理：QObject提供了处理事件的基本机制。可以通过重写event()或eventFilter()方法来处理对象接收到的事件。事件可以是鼠标事件、键盘事件或其他自定义事件。
对象生命周期管理：QObject对象在创建后可以自动管理其生命周期。在Python中，当一个QObject对象没有引用时，它会被Python的垃圾回收器销毁。同时，QObject的父子关系机制也可以在父对象销毁时自动销毁子对象。
QObject是PyQt中其他重要对象（如QWidget、QThread等）的基类，它为它们提供了共享的核心功能和特性。
下面，将从以下基本程序展开演示QObject的具体使用方法：
class Window(QWidget): def __init__(self): super().__init__() self.setWindowTitle("QLabel的学习") self.resize(500, 500) self.setup_ui() # 调用以下文章自定义的函数 def setup_ui(self): pass if __name__ == '__main__': app = QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec_()) 注意：
在以上代码中，self代表当前实例化的Window对象。在Python中，通过使用self关键字，可以在类的方法中引用对象自身。
在构造函数中的super().__init__()调用中，self被用于传递当前对象自身给父类的构造函数，确保父类的初始化操作能够正确地处理当前对象。
Object的继承结构测试 如以下代码所示，在Window()类中自定义一个QObject_Inheritance_Structure_Testing(self)方法，在该方法中，通过调用QObject.mro()方法，可以获取到QObject类的方法解析顺序。方法解析顺序决定了当一个方法被调用时，解释器在哪个类中找到该方法的定义。通过打印每个继承类，可以查看继承结构中各个类的排列顺序。
# QObject继承结构测试 def QObject_Inheritance_Structure_Testing(self): mros = QObject.mro() for mro in mros: print(mro) 运行结果：
这些打印结果表示了QObject类的继承关系。QObject类继承自sip.wrapper类，sip.wrapper类又继承自sip.simplewrapper类，最后都继承自object类。继承结构定义了这些类之间的层次关系，使得QObject类可以具有基类和扩展类提供的功能和属性。
QObject对象名称和属性 在进行QObject对象的名称和属性操作时，可以使用以下 API：
setObjectName(name): 设置对象的名称，可以用于在后续代码中查找和识别具体的对象。一般这个名称是唯一的，当做对象的ID来使用。objectName(): 获取对象的名称。setProperty(name, value): 设置对象的属性，可以用于存储和传递自定义的数据。property(name): 获取对象的属性值。dynamicPropertyNames(): 获取对象所有动态属性的名称列表。 QObject对象名称和属性的操作 以下将对演示如何使用这些API：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2f224dacc24ec893fd313a513fde716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6921017182f54b27c572ffddc8499a8/" rel="bookmark">
			【管理运筹学】第 10 章 | 排队论（5，多服务台排队系统、一般服务时间模型、P-K 公式、排队系统的经济分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言一、多服务台排队系统二、一般服务时间 M / G / 1 M/G/1 M/G/1 模型Pollaczek-Khinchine（P-K）公式 三、排队系统的经济分析写在最后 引言 对于多服务台负指数分布排队系统，大纲要求没那么深，只提到了状态转移图以及状态概率的方程，因此我这部分也就作简单介绍，重点在后面的一般服务时间模型上。
一、多服务台排队系统 M / M / c M/M/c M/M/c 模型各种的特征的规定与标准的 M / M / 1 M/M/1 M/M/1 模型的规定相同。另外规定各服务台工作是相互独立且平均服务率 μ 1 = μ 2 = ⋯ = μ c = μ \mu_1=\mu_2=\cdots=\mu_c=\mu μ1​=μ2​=⋯=μc​=μ ，于是整个服务机构的平均服务率为 c μ ( n ≥ c ) , n μ ( n &lt; c ) c\mu(n\geq c),n\mu(n&lt;c) cμ(n≥c),nμ(n&lt;c) ；令 ρ = λ / ( c μ ) \rho=\lambda/(c\mu) ρ=λ/(cμ) ，只有当其小于 1 时才不会形成无限的队列，称它为这个服务系统的服务强度或服务机构的平均利用率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6921017182f54b27c572ffddc8499a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfed719538110a95faf70b315ee0714c/" rel="bookmark">
			Python基于微博的舆情分析、热搜可视化系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌程序员徐师兄、7年大厂程序员经历。全网粉丝30W+、csdn博客专家、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
1. 简介 基于Python Django的微博热搜、微博舆论可视化系统。通过微博舆情分析系统获取到最新微博舆情分析系统详细情况，了解最新动态信息等。
《基于Python Django的微博热搜、微博舆论可视化系统》该项目含有源码、论文等资料、配套开发软件、软件安装教程等。系统功能完整，适合作为毕业设计、课程设计、数据库大作业学习使用。
基于Python的微博热搜、微博舆论可视化系统，附源码，教程
微博舆情分析系统，项目后端分爬虫模块、数据分析模块、数据存储模块、业务逻辑模块组成。
热度分析
图标分析
关键分析
评论数据分析
个人信息管理
登陆注册
所有数据可视化管理
2. 技术简介 本系统使用Django进行整个项目框架的构建，爬虫部分模块使用requests官方依赖库进行数据获取，利用 selenium 爬取数据，用 beautifulsoup4 分析，然后使用pandas对数据进行筛选，处理和分析。储存到 sqlite 数据库当中。
管理员可以登陆系统，查看到所有的数据。
3. 技术栈 技术栈说明备注Django作为后端接口Sqlite数据库snownlp情感分析，作为情感得分日常笔记-snownlp情感分析计算情感得分beautifulsoup4爬虫，网页接口分析urllib3、requests网络请求certifi网络证书Python certifi：如何在Python中使用SSL证书jieba关键词提取https://blog.csdn.net/FontThrone/article/details/72782499 Django Django是Python社区两大受欢迎的Web框架之一。 凭借功能强大的脚手架和诸多开箱即用的组件，用Django搭建Web应用快速而又省力。
Django特点及优势：
1、重量级框架，对比Flask框架，Django原生提供了众多的功能组件，让开发更简便快速。
2、MVT模式，有一种程序设计模式叫MVC,其核心思想是分工、解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容。
3、MVC模式说明，M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。V全拼为View，用于封装结果，生成页面展示的html内容。C全拼为Controller，用于接收请求，处理业务逻辑，与Model和View交互，返回结果。
依赖列表 4 项目结构 /static 前端静态资源
/templates 前端 html
/keshihua 包括后端接口和爬虫
5 效果图 前台 后台 推荐阅读 200 道Java 精品项目
基于Python的微博大数据舆情分析可视化系统
Python 基于微博舆情分析系统的设计与实现，GUI可视化界面（课程设计，附源码，教程）
基于Python的微博舆论分析，微博情感分析可视化系统（V2.0)
原文地址:https://it1314.top/article/1048
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/391f8dce69c05d0b47f57b4d0e316308/" rel="bookmark">
			Monocle 3 | 太牛了！单细胞必学R包！~（二）（寻找marker及注释细胞）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1写在前面 昨天又是不睡觉的一天，晚上还被家属讲了一通，理由是我去急诊了，没有在办公室待着，他老公疼没人去看。🫠
我的解释是只有我一个值班医生，不可能那么及时，而且也不是什么急症啊。😂
好的，说完家属就暴雷了，“这么大的医院就安排一个大夫值班吗！？”😡
我也是懒得跟她battle，这个世界不是谁生病就谁有理吧！~😂
今天继续接上一次monocle3的教程吧。🧐
2用到的包 library(tidyverse)
library(monocle3)
library(garnett)
3示例数据 还是上一次运行完的结果哦，不知道大家有没有保存。😂
cds
4寻找marker genes 完成细胞聚类后，我们就可以使用top_markers()来选中marker genes。😘
marker_test_res &lt;- top_markers(cds, group_cells_by="partition", reference_cells=1000, cores=8)
接着我们就可以根据cluster,partition或者colData(cds)来确定top n的基因表达量。🤩
top_specific_markers &lt;- marker_test_res %&gt;%
filter(fraction_expressing &gt;= 0.10) %&gt;%
group_by(cell_group) %&gt;%
top_n(1, pseudo_R2)
top_specific_marker_ids &lt;- unique(top_specific_markers %&gt;% pull(gene_id))
可视化！~🤪
plot_genes_by_group(cds,
top_specific_marker_ids,
group_cells_by="partition",
ordering_type="maximal_on_diag",
max.size=3)
我们再试试看看top 3的基因。😘
top_specific_markers &lt;- marker_test_res %&gt;%
filter(fraction_expressing &gt;= 0.10) %&gt;%
group_by(cell_group) %&gt;%
top_n(3, pseudo_R2)
top_specific_marker_ids &lt;- unique(top_specific_markers %&gt;% pull(gene_id))
plot_genes_by_group(cds,
top_specific_marker_ids,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/391f8dce69c05d0b47f57b4d0e316308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e332f591b401e225273dac481a5647d/" rel="bookmark">
			探索控制领域：从电视遥控器到自动驾驶【基础概念理解、应用实例】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当谈到控制学和控制系统时，你可能会联想到电视遥控器、自动驾驶汽车、飞机自动驾驶系统以及许多其他自动化系统。但控制学是一个更广泛的学科，它涵盖了各种领域，从工程到生物学，从经济学到环境科学。让我们深入了解控制学的基本概念以及它在各个领域的应用。
什么是控制学，它涉及哪些方面？ 控制学的定义：
控制学是一门研究如何设计、分析和优化系统以实现所期望性能的学科。这些系统可以是物理系统（例如机械系统、电气系统、化学过程等），也可以是抽象系统（例如经济系统、生态系统、计算机系统等）。控制学的目标是开发控制策略和方法，使系统保持在所期望的状态，或者将其从当前状态引导到期望的状态。
控制学主要涉及以下几个方面：
目标设置： 控制学首先要确定你想要系统做什么，就像你通过遥控器选择想要的电视频道一样。这是控制的起点，你需要明确系统的目标和性能指标。
传感器： 这是控制中的眼睛和耳朵，它们帮助我们了解系统的当前状态，例如温度传感器告诉我们房间有多热。传感器用于监测系统的反馈信息，这是控制中非常重要的一环。
处理器： 这是控制中的大脑，它根据传感器提供的信息决定采取什么行动，就像你的大脑决定是否要打开空调以降低温度。处理器包括控制算法和决策规则。
执行器： 这是控制中的手，它们根据处理器的指令执行动作，例如控制器告诉电视打开或关闭。执行器可以是电动机、阀门、马达等物理设备。
反馈： 控制学还包括不断检查系统的表现，并根据需要进行微调，就像你可能需要不断调整电视音量以确保音量合适一样。反馈是指系统的实际输出信息，它用于与期望输出进行比较，以便调整控制策略。
控制学的核心思想是通过监测系统的状态、比较实际状态与期望状态，然后采取控制措施来使它们尽量保持一致。控制系统通常基于反馈信息或预测模型来做出决策，以实现各种目标，如稳定性、性能和安全性。
在接下来的部分，我们将更深入地探讨控制系统的基本原理和应用。
控制系统的基本原理 控制系统的基本原理涉及到几个关键概念，包括反馈控制和前馈控制：
反馈控制：
反馈控制类似于你在开车时用方向盘调整车的方向。在控制系统中，我们使用 传感器 来测量系统的当前状态，然后将这些信息反馈给控制器。控制器 比较当前状态与我们想要的状态，然后采取措施来使它们保持一致。如果系统偏离了目标，反馈控制会不断调整操作，就像你不断转动方向盘以保持车在正确的道路上。
前馈控制：
前馈控制是一种预测性的控制方式，就像你知道在前面有一条坑洞，所以提前减速一样。前馈控制通过预测系统的行为并提前采取措施来避免偏离目标。它不仅依赖于反馈信息，还考虑系统的特性和环境因素，以尽量减小误差。
反馈控制是根据实际观测进行调整前馈控制是根据预测进行调整。 这些原理在各种领域的自动化和工程应用中发挥着关键作用，以确保系统的稳定性、性能和安全性。
开环控制和闭环控制的区别 在控制学中，有两种主要类型的控制方法，即开环控制和闭环控制：
1. 开环控制：
定义： 开环控制是一种控制系统，其中控制器根据预定的输入来操作系统，而无需监测系统的实际输出或反馈信息。
工作原理： 在开环控制中，系统的操作不依赖于实时反馈。控制器会发送指令，系统按照这些指令执行。然而，开环控制不会调整操作以应对外部扰动或系统内部变化，因此可能无法保证稳定性和准确性。
示例： 一个简单的示例是洗衣机的程序。你选择洗衣机的洗涤模式和时间，然后启动。机器会按照你选择的方式运行，而不考虑洗涤过程中的衣物状态。
2. 闭环控制：
定义： 闭环控制是一种控制系统，其中控制器根据系统的实际输出或反馈信息来调整操作，以确保系统达到预期的状态。
工作原理： 在闭环控制中，控制器会不断监测系统的性能，然后根据实际输出与期望输出之间的差异来进行调整。这种反馈机制使得闭环控制能够适应外部变化和扰动，从而更稳定和精确。
示例： 汽车的 巡航控制系统 是一个闭环控制的例子。系统使用传感器来监测车辆与前方车辆的距离，然后自动调整加速度和刹车力以保持安全的跟车距离。这种控制系统会根据实际道路和交通情况的变化进行调整，以满足驾驶员设定的速度和距离要求。
主要区别在于开环控制不依赖于反馈信息，而闭环控制根据反馈信息进行实时调整。
闭环控制通常更适用于需要高精度和稳定性的系统，因为它可以主动纠正误差。而开环控制更适用于一些简单的系统，不需要实时调整或不容易受到外部变化的影响。
什么是PID控制，它在工程和自动化中的应用是什么？ PID控制是一种常见的控制方法，它用于调节系统以使其维持所期望的状态。PID代表比例-积分-微分，分别代表了控制器的三个主要部分。让我们深入了解PID控制的原理和应用。
PID控制的三个部分：
比例（P）部分： 如果房间温度偏离了目标温度，比例部分将根据偏离的程度产生一个控制输出。如果温度偏低，它会增加加热器的功率，以加热房间。如果温度偏高，它会减小加热器功率，以降低温度。这就是比例控制的作用。
积分（I）部分： 积分部分考虑了时间内温度的累积偏差。如果房间温度长时间低于目标温度，积分部分将逐渐增加加热器的功率，以弥补长时间的低温。这有助于避免温度长时间波动在目标值附近。
微分（D）部分： 微分部分关注温度的变化速度。如果温度开始迅速升高，微分部分将减小加热器的功率，以避免温度超过目标值。这有助于防止过冲。
P（比例）部分负责根据当前偏离情况调整加热器的功率。I（积分）部分负责处理长时间的偏差。D（微分）部分负责处理温度变化的速度。 它们一起工作，以确保温度尽量稳定地维持在目标值附近，而不出现大的波动或过冲。
应用示例：温度控制
PID控制在工程和自动化领域有广泛的应用。一个常见的应用示例是温度控制，如在加热系统中。PID控制可以确保加热器根据实际温度与目标温度之间的差异来自动调整加热功率，以使温度稳定在期望的范围内。这在烤箱、恒温房间、冷却系统等多种情况下都有用武之地。
除了温度控制，PID控制还广泛应用于自动驾驶汽车、机器人、化工过程、电机控制、水处理系统、飞机飞行控制等各种领域。它是一种灵活、通用的控制方法，可以根据不同应用的需求进行调整和优化。
控制系统如何处理不确定性和噪声？ 在自动化和工程领域，控制系统必须能够处理不确定性和噪声，以确保系统的性能和稳定性。以下是一些常见的方法和策略，用于处理不确定性和噪声：
1. 鲁棒性控制：
原理： 鲁棒性控制是一种设计控制器的方法，可以处理系统参数不确定性或外部扰动。它考虑到系统模型不是完美的，因此控制器被设计成具有某种程度的容忍度，以应对系统变化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e332f591b401e225273dac481a5647d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8294819afa24fd1d0e810dbdbd056e8/" rel="bookmark">
			【车载开发系列】HexView文件合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【车载开发系列】HexView文件合并 【车载开发系列】HexView文件合并 【车载开发系列】HexView文件合并一. 合并文件目的二. 地址范围说明1）Bootloader地址范围2）应用程序地址范围3）其它数据的地址范围 三. 批处理合并1）/S 命令2）/MT:file1[;offset][:range1][+file2][;offset][:range1]命令3）/XS[:reclinelen[:rectype]]命令3）/FA 命令4）/Af:xx: 命令 一. 合并文件目的 我们经常需要将Bootloader程序和Application应用程序合并到同一个S19文件中，这样可以简化整个软件/固件的刷写/升级过程。
Bootloader是一个特殊的程序，其主要功能是用来引导应用程序的运行。在实际的应用中，我们经常需要对应用程序进行刷写/升级，而刷写/升级过程需要将新的应用程序下载到设备中。如果应用程序和Bootloader分别存储在不同的文件中，那么在刷写/升级过程中就需要分别下载这两个文件，并且还需要确保这两个文件的版本是兼容的，否则可能会导致设备无法正常工作。
因此，将Bootloader和应用程序合并到同一个文件中可以简化软件/固件刷写/升级的过程，减少用户的操作复杂度。在刷写/升级过程中，我们只需要下载一个文件，就可以完成整个软件/固件的刷写/升级。另外，在合并的过程中，我们可以使用一些特殊的技术，比如加密、校验和等，来保证软件/固件的安全性。
二. 地址范围说明 当将Bootloader和应用程序合并到同一个文件时，需要确定它们在文件中的地址范围。一般来说，Bootloader和应用程序需要存储在不同的地址范围内，以便在固件启动时正确加载它们。
1）Bootloader地址范围 Bootloader一般存储在起始地址处，通常是0x00000000开始的连续地址范围。举个例子，Bootloader地址范围可以是：0x00000000 - 0x00007FFF。这样BOOT程序的大小可以是32KB。
2）应用程序地址范围 应用程序一般存储在Bootloader之后的地址范围内，通常是0x00008000开始的连续地址范围。它占用的地址范围可以是0x00008000 - 0x0003FFFF，这样应用程序的大小为192KB。
3）其它数据的地址范围 一般其他数据地址范围在0x00040000 - 0x0007FFFF之间。在Flash中，我们通常会保留一部分地址范围用于存储其它数据，比如配置信息、用户数据等等。在本示例中，我们保留了32KB的地址范围，用于存储其它数据。
正确的确定Bootloader和应用程序的地址范围是软件/固件设计中非常重要的一部分，它不仅关系到固件的安全性和可靠性，还关系到固件的性能和扩展性。
三. 批处理合并 对两个S19文件特定地址范围进行合并
如何你想对两个S19文件特定地址范围进行合并，可将批处理最后一段改写如下。
基于批处理Bat调用HexView工具提供的Command line，通过该脚本来实现两个S19文件的合并。将该脚本集成开发环境IDE（CodeWarrior，S32K DS，Davinci，EB Tresos，ETAS…）中，即可自动实现S19文件的合并。
%HexViewPath% /S /MT:%Input_S19_File1%;0x0:0x9000-0x90E8+%Input_S19_File2%;0x0:0x9100-0x91E7 /XS:32 -o %Output_S19_File%
1）/S 命令 该选项用于抑制对GUI的任何输出，在无声模式下运行HexView。在执行了命令行选项中给出的所有命令后，HexView将被关闭。
2）/MT:file1[;offset][:range1][+file2][;offset][:range1]命令 一个或多个文件以透明模式合并到memory中（现有数据不被覆盖）。可选的offset将应用于被合并的文件的所有地址。
3）/XS[:reclinelen[:rectype]]命令 以Motorola S-Record格式导出。Reclinelen表示Data段的长度。
3）/FA 命令 创建一个单一的区域文件（填写所有）。这个选项可以用来创建一个单块文件。在这种情况下，HexView将使用第一个区块的起始地址和最后一个区块的结束地址。
4）/Af:xx: 命令 指定填充字符，但xx可以指定为十进制（无后缀）、十六进制值（0x-后缀）或二进制（b-后缀）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1db2ce76ed283bc92b0440ef465d84d/" rel="bookmark">
			SQL注入原理及思路（mysql）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库知识 mysql数据库 show database; #列出所有数据库 show tables; #列出所有表名 show columns from 表名; #列出表的列 select * from 表名 #查询数据库中某表的信息 select * from 表名 where 列=xx #查询某表中符合列=xx的信息 select * from 表名 order by 数字 #用于将结果集按照某列进行排序（asc 升序desc 降序），在sql注入中通常用来判断前面查询结果集的列数，用于联合union查询 select * from 表名1 union select * from 表名2 #union操作符用于合并两个或多个select语句的结果。但是必须保证前后的select语句必须保证拥有相同数量的列， insert into 表名(`列1`,`列2`,`列3`) values ('值1','值2','值3');#给表中添加数据 delete from 表名 where 列=xx;#删除表中数据 update 表名 set 列=xx where 条件;#修改数据 对于mysql5.0以上版本，有数据库information_schema存放数据库所有信息 schemata表（存放所有的数据库）：schema_name列（所有的数据库名） tables表（存放所有的表信息）：table_schema列（数据库名） table_name列（表名） columns表（存放所有的列信息）：table_schema列（数据库名） table_name列（表名）column_name列（列名） select * from 表名 limit 3/limit 0,1; #只有一个参数值时将表中前三条数据列出来；两个参数是从0行开始取1条数据 SQL注入原理 SQL注入有两个前提条件：源码中有执行的sql语句、参数可控且未对参数进行过滤；满足以上两个条件我们就可以任意构造sql语句且执行，从而获取我们想要的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1db2ce76ed283bc92b0440ef465d84d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3541ac5b422fd237b57d61065eb0355/" rel="bookmark">
			鸿蒙ArkUI-X跨端应用开发，一套代码构建多平台应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、项目介绍二、技术架构三、Gitee仓库地址四、ArkUI-X开发者文档五、快速开始——环境准备1、下载DevEco Studio，版本V4.0 Beta2以上2、打开DevEco，下载相关环境配置3、配置开发环境3.1、OpenHarmony SDK3.2、安装ArkUI-X SDK3.2、Android SDK 五、快速开始——创建Hello World项目六、编译构建生成跨平台应用六、报错了 一、项目介绍 ArkUI是一套构建分布式应用的声明式UI开发框架。它具备简洁自然的UI信息语法、丰富的UI组件、多维的状态管理，以及实时界面预览等相关能力，帮助您提升应用开发效率，并能在多种设备上实现生动而流畅的用户体验。
详情可参考ArkUI框架介绍
ArkUI-X进一步将ArkUI扩展到了多个OS平台：目前支持OpenHarmony、HarmonyOS、Android、 iOS，后续会逐步增加更多平台支持。
开发者基于一套主代码，就可以构建支持多平台的精美、高性能应用。
二、技术架构 ArkUI跨平台框架整体架构如下图所示，详细设计请参考ArkUI跨平台设计总体说明。
三、Gitee仓库地址 https://gitee.com/arkui-x
四、ArkUI-X开发者文档 https://gitee.com/arkui-x/docs/blob/master/zh-cn/README.md
五、快速开始——环境准备 让我们来试试开发个Hello World应用。
1、下载DevEco Studio，版本V4.0 Beta2以上 打开ArkUi开发工具配套关系。
点击下载Windows(64-bit)
2、打开DevEco，下载相关环境配置 提示是要选择本地的NodeJS，还是下载NodeJS；提示是要选择本地的ohpm，还是下载ohpm；点下一步。提示是要选择本地的HarmonyOS SDK，还是下载HarmonyOS SDK；点下一步。点同意协议；点下一步，开始下载…完成，点Finish. 3、配置开发环境 3.1、OpenHarmony SDK 3.1.1、DevEco在File &gt; Settings &gt; SDK 下，（macOS为DevEco Studio &gt; Preferences &gt; SDK）选择OpenHarmony SDK
我们可以看到OpenHarmony SDK的Location是空的。
点击Location右侧的Edit，为SDK选择存储路径，一直点击Next和accept，开始下载安装后，点击Finish.
3.1.2、下载API Version10 五个软件工具
3.2、安装ArkUI-X SDK 3.2.1、DevEco在File &gt; Settings &gt; ArkUI-X下，点击Location右侧的Edit，为SDK选择存储路径。
3.2.2、在弹出的SDK Setup页面选择存储路径，一直点击Next，直到完成SDK的安装后，点击Finish。 3.2、Android SDK 假设你要生成安卓应用，你还得下载Android SDK。
这里我就不下载配置了。
五、快速开始——创建Hello World项目 1、在DevEco Studio中导入ArkUI-X Sample，快速创建跨平台工程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3541ac5b422fd237b57d61065eb0355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74deab04debf539b8c3169506ea196ef/" rel="bookmark">
			人间道－您到底做错了什么：正心径之您要逐渐去除外邪行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 过去的您或许在您自个身上付出，投入了巨大，重大的人力，物力，财力等各方面的重重的成本，但是呢，收获却微小的稀罕，微少的可怜啊。甚至于一个错误，就把您完全陷入到万丈深渊里面去了，以至于无法自拔的地方，无法抽身，极其难于扭转的巨大劣势存在，巨大劣势所在。 然后呢？ 知道劣势了能咋样？ 有时候想到毕竟都要奔四十岁的人了，想不到竟然还一事无成？ 一身负债？ 难道您就甘心了吗 显然，这才是人生的真相所在啊。只是没人告诉过你，面对您自己的命运，尤其面对您个人命运的无可奈何所在，甚至于无力感所在，如何解决？ 又该如何动而走出困难境地呢？ 这些其实都是没有教授过的学问？ 总是随大流的一些人去说，类似鸡汤文的起伏，人生起落很正常，但是您真正起来过吗？ 没有，不是吗 ，反而一直在平庸的道路上面行走，却未察觉到错误的道路上面走到时间长了，再扭转是一件极其艰難困难的事情，以至于很多人无法扭转过来的事情都是存在的。
奔向新将来，谈何容易？ 从负债的深渊中走出来，又谈何容易啊！？
非意志刚强，刚烈的好男儿不能为之的事情啊。 只是您个人探索这个正事情的过程中，付出的时间成本，综合成本忒高了啊，完全超出了承受挫折的范围能力了。。。 强受之而已，而后呢？ 做一个普通人都感觉困难的了，更何谈其他？ 谈其他也都是妄想，痴人说梦，妄言语而已。 您的客观形势就是如此残酷的所在。 所谓修行莫过于此的了，也是。first要修正您自己的起心动念，起心动念之间的歪念先修正过来啊！然后才是然后的事情。要不然，歪念头产生于心了，就不要动那个念头，去聊天，比如去QQ群了，其他熟悉的朋友了？ 或者出去跑外卖，转移视线方法方式去处理。 另外就是深植于心的一些念头的逐渐纠正过来，莫过于如此的耕种您自己的心田的了，所谓心地善良无非也是不行违法的事情，不做不合理，不合法，不合规矩的事情。虽然深陷一时的困窘境地，但是谁又没陷入过个人人生必然，必要的困难境地？ 需要真正的去践行虽然被困，但是困而不失掉其所守，守的啥？当然是正心正念所在啊。区别于歪门邪道的念头，以及其他非分之想！ 因为当今社会经济形势虽然逐步好转起来，但是世风日下？ 还是日上？ 总之很多不正之风也是流窜的厉害，需要进行约束的地方。
您个人说白了，也就是这个世界当中，极其默默无闻的一份子。能够过好您个人的小日子，就已经非常不错了。就不要再生其他妄想的了。 只是很多人都没有把您自己的日子过好了，反而过成了一地鸡毛，鸡飞蛋打，甚至于鸡飞狗跳，以至于更加严重违法事情，甚至于涉及刑事责任违法事情的发生。这个当然跟您打小成长起来的环境有关系，有很大的关系存在。
所以研究风水的价值何在？ 梅花易数，八字命理预测的价值何在？ 不就是为了能过上好日子吗？ 说白了，老百姓图啥？ 不就是图一个家庭和睦，身体健康，然后有一个相对稳定的工作事业，不就是夫复何求的事情场景了吗！ 更有何欲望想要的呢？ 很多人在小年轻的时候，没有把握住年轻的宝贵光阴，让大好的光阴不能说通通浪费掉也差不多。没有专注 专心去做好一个事情，反而就是今天做做这个，明天做做那个，就真的是把大好的光阴岁月都给浪费掉了啊，多可惜，可悲可叹的事情呢，甚至于遗憾的发生，后悔的发生莫过于此了。 有些人虽然中途幡然醒悟，但是发现年龄却已经上来了，就不能说破罐子破摔也差不多了，就是年轻时候的精力，冲劲头，那一口气已经泄掉的了，再想重回二十多岁的年轻时候，已经不可能，不复发生的事情的了。 比如再让您这个年龄去看哈利波特，感觉完全不同了，犹如那个让八十岁的老大爷买宝马车一样，已经没有得到的价值了，激情销退了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf9dfb6c2c4c25af7451e000d0358b1/" rel="bookmark">
			linux 配置多个tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复制几个tomcat、分别为
tomcat-uat-AAA tomcat-uat-BBB tomcat-uat-CCC cp -r tomcat_8.0.47/. tomcat-uat-AAA/ 第一步：修改tomcat的环境变量 vi /etc/profile ##########AAA tomcat########### CATALINA1_BASE=/home/webapp/tomcat-uat-AAA CATALINA1_HOME=/home/webapp/tomcat-uat-AAA TOMCAT1_HOME=/home/webapp/tomcat-uat-AAA export CATALINA1_BASE CATALINA1_HOME TOMCAT1_HOME ##########AAA tomcat########### ##########BBB tomcat########## CATALINA2_BASE=/home/webapp/tomcat-uat-BBB CATALINA2_HOME=/home/webapp/tomcat-uat-BBB TOMCAT2_HOME=/home/webapp/tomcat-uat-BBB export CATALINA2_BASE CATALINA2_HOME TOMCAT2_HOME ##########BBB tomcat########## ##########CCC tomcat########## CATALINA3_BASE=/home/webapp/tomcat-uat-CCC CATALINA3_HOME=/home/webapp/tomcat-uat-CCC TOMCAT3_HOME=/home/webapp/tomcat-uat-CCC export CATALINA3_BASE CATALINA3_HOME TOMCAT3_HOME ##########CCC tomcat########## 然后使修改的环境变量生效
source /etc/profile 第二步：修改启动文件tomcat 在 bin 下 catalina.sh vi /home/webapp/tomcat-uat-AAA/bin/catalina.sh 在：模式下输入全局替换命令，执行下面2次命令 %s/CATALINA_BASE/CATALINA1_BASE/g %s/CATALINA_HOME/CATALINA1_HOME/g vi /home/webapp/tomcat-uat-BBB/bin/catalina.sh 在：模式下输入全局替换命令，执行下面2次命令 %s/CATALINA_BASE/CATALINA2_BASE/g %s/CATALINA_HOME/CATALINA2_HOME/g vi /home/webapp/tomcat-uat-CCC/bin/catalina.sh 在：模式下输入全局替换命令，执行下面2次命令 %s/CATALINA_BASE/CATALINA3_BASE/g %s/CATALINA_HOME/CATALINA3_HOME/g 第三步：修改tomcat 在 conf 下的 server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf9dfb6c2c4c25af7451e000d0358b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4590c80e51d89c590b169465dfbc8cb/" rel="bookmark">
			BI技巧丨利用Rank函数排名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际业务场景中，除了各类条件计算、同环比计算以外，排名也是比较常见的问题，我们经常需要使用Rankx函数来进行某些TopN计算等。
微软新推出的开窗函数Rank，可以说是对排名问题的一次优化，也解决了一些之前Rankx函数的坑点。
Rank函数基本语法
RANK ( [&lt;ties&gt;][, &lt;relation&gt;][, &lt;orderBy&gt;][, &lt;blanks&gt;][, &lt;partitionBy&gt;][, &lt;matchBy&gt;] ) 参数介绍：
ties：可选项，DENSE或SKIP，相同值的排名处理。
relation：可选项，排名依据的表或表表达式。
orderBy：可选项，排序依据，如果省略，第2参数需绑定。
blanks：可选项，处理空值排名位置使用。
partitionBy：可选项，分区定义，参照SQL的开窗分区即可。
matchby：可选项，定义匹配数据和标识当前行的列的语句。
PS：
看起来参数很多，实际上我们日常中用到第2参数和第3参数的频率较高，其他参数一般是为了处理某些特殊场景时使用。
先来看看本期的案例数据：
案例数据共计3张表，产品表、分店表以及事实表，将其导入到PowerBI中，模型关系如下：
添加基础度量值：
销售金额：
001.SalesAmount = SUMX ( 'Fact_Sales', 'Fact_Sales'[Quantity] * RELATED ( Dim_Product[Price] ) ) 销售成本：
002.SalesCost = SUMX ( 'Fact_Sales', 'Fact_Sales'[Quantity] * RELATED ( Dim_Product[Cost] ) ) 销售利润：
003.SalesProfit = [001.SalesAmount] - [002.SalesCost] 销售单价：
001.Price = SUM ( 'Dim_Product'[Price] ) 销售单位成本：
002.Cost = SUM ( 'Dim_Product'[Cost] ) 到这里，我们的准备工作完成，接下来我们来看看在不同的场景中，Rank函数的表现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4590c80e51d89c590b169465dfbc8cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9246bb30693433e7d544e40fc348f81/" rel="bookmark">
			Windows-Oracle11g 安装详解-含Navicate远程连接配置 -本地监听设置及更换navicate环境指向的oci.dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 下载地址：2 安装2.1 解压缩运行setup2.2 修改配置文件2.3 一直选择默认，直到设置口令2.4 Oracle服务启动 3 登录Oracle4 解锁普通用户scott5 简化连接（可做可不做）5.1 修改配置文件5.2 添加内容 6 配置本地监听6.1 修改配置文件6.2 修改网络设置 7 连接成功8 如果还出现报错ORA-28547，需要排查是不是oci.dll的版本问题。8.1 去官网下载安装包8.2 下载差不多的版本号8.3 将oci.dll所在的目录写到navicate的环境配置中 1 下载地址： https://www.oracle.com/partners/campaign/112010-win64soft-094461.html
2 安装 2.1 解压缩运行setup 2.2 修改配置文件 下一步可能会出现[INS-13001]的提示，这是因为版本注册的问题。
Oracle 在发布 11g时，Winodws10还没有发布。所以Oracle的安装程序中，并没有将Windows10作为被认证的操作系统。
解决方案：
第一种方法：直接忽略安装即可。
第二种方法：修改配置信息。
在&lt;CERTIFIED_SYSTEMS&gt;里添加如下代码： &lt;OPERATING_SYSTEM RELEASE="6.2"&gt; &lt;VERSION VALUE="3"/&gt; &lt;ARCHITECTURE VALUE="64-bit"/&gt; &lt;NAME VALUE="Windows 10"/&gt; &lt;ENV_VAR_LIST&gt; &lt;ENV_VAR NAME="PATH" MAX_LENGTH="1023" /&gt; &lt;/ENV_VAR_LIST&gt; &lt;/OPERATING_SYSTEM&gt; 保存文件即可，重新安装。
2.3 一直选择默认，直到设置口令 我的D盘装不下了，先装C盘…，设置口令需要至少一个大写一个小写一个数字。
2.4 Oracle服务启动 OracleServiceORCL和OracleOraDb11g_home1TNSListener是必须启动的。其他改为手动即可（减少内存占用）。
注：OracleServiceORCL数据库（实例）服务，核心服务。
进入控制台，输入命令调整一下。
services.msc
Oracle系统用户介绍
1 sys用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9246bb30693433e7d544e40fc348f81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd6efc533c6cdd9890950ab5db1312d/" rel="bookmark">
			Steger算法实现结构光光条中心提取(python版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Steger算法原理 对结构光进行光条中心提取时，Steger算法是以Hessian矩阵为基础的。它的基础步骤如下所示：
从Hessian矩阵中求出线激光条纹的法线方向在光条纹法线方向上将其灰度分布按照泰勒多项式展开，求取的极大值即为光条在该法线方向上的亚像素坐标。对于二维离散图像来说，Hessian矩阵可以表示为： 这里面的u，v表示的就是像素的行坐标和列坐标，代表像素的灰度也可以称之为灰度分布函数。而，和都可以通过与二维高斯函数卷积运算得到。
在这里，二维高斯函数，其主要作用是为了让光条灰度分布特性更加明显，在G(u,v)表达式中，是标准差，一般取，W代表光条宽度。在像素(u,v)处的Hessian矩阵有两个特征向量，其中一个绝对值较大，为该像素处的法线方向向量，而另外一个则是切向方向向量。因此可以通过求取Hessian矩阵的特征向量来计算出法线方向。某一像素点，在二阶泰勒展开式Hessian矩阵为：
由该点的Hessian矩阵所求出的特征值和特征向量分别与该点的法线方向和该方向的二阶方向导数相对应。其中法线方向的单位向量为：，并且在光条纹法线方向上的像素点，并且在光条纹法线方向上的像素点可以由像素(u0,v0)的灰度I(u0,v0)和二阶泰勒展开多项式表示为：
再将t(即泰勒展开式)代入其中即可求出光条纹中心的亚像素坐标。
Steger算法Python实现 这一部分，我在网上找到了许多C++版本的Steger算法实现，本人参考了现有的C++版本Steger算法实现，在此基础上进行了改进，用Python重新去实现该算法。
计算图像的一阶导数和二阶导数 这里我采用了三种方法，分别是自定义卷积、Scharr 滤波器、Sobel 滤波器来计算图像的导数和二阶导数。
import cv2 import numpy as np def _derivation_with_Filter(Gaussimg): dx = cv2.filter2D(Gaussimg,-1, kernel=np.array([[1], [0], [-1]])) dy = cv2.filter2D(Gaussimg,-1, kernel=np.array([[1, 0, -1]])) dxx = cv2.filter2D(Gaussimg,-1, kernel=np.array([[1], [-2], [1]])) dyy = cv2.filter2D(Gaussimg,-1, kernel=np.array([[1, -2, 1]])) dxy = cv2.filter2D(Gaussimg,-1, kernel=np.array([[1, -1], [-1, 1]])) return dx, dy, dxx, dyy, dxy def _derivation_with_Scharr(Gaussimg): dx = cv2.Scharr(Gaussimg, cv2.CV_32F, 1, 0) dy = cv2.Scharr(Gaussimg, cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd6efc533c6cdd9890950ab5db1312d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0db2219d03ff6cd7e7e60c493288d5a/" rel="bookmark">
			基于spark的音乐数据分析系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路
文章目录 前言一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 前言 本文主要对音乐数据，进行分析，系统技术主要使用，1.对原始数据集进行预处理；3.使用python语言编写Spark程序对HDFS中的数据进行处理分析，并把分析结果写入到MySQL数据库；4.利用Spark MLlib进行数据和关系预测；5.利用IntelliJ IDEA搭建动态Web应用；6.利用plotly进行前端可视化分析。
关键词：音乐数据分析；可视化分析；python语言
一、项目介绍 本文对网易云音乐平台的数据进行分析，分析年度音乐专辑销量TOP10 ；年度月排行榜榜首播放量；最受欢迎的音乐类型；音乐评论数TOP榜；用户性别比例。使用Hadoop提供HDFS的分布式存储[10]，利用Spark对HDFS中的数据进行处理，并对结果进行可视化分析。
音乐数据分析系统的设计开发工作：
网易云音乐数据爬虫。在本课题中，需要爬取的数据主要包括音乐数据、用户数据、评论数据等等，每一种类型的数据对应一个爬取接口。使用Python进行数据清洗。这三种类型的数据分别应用于不同的功能中。将前面爬取到的数据作为数据源，上传到HDFS文件系统上。使用Scala语言编写Spark程序对数据进行分析处理。可以从多个角度对网易云音乐的现有数据进行有效的信息挖掘，并加以分析。恰当的数据可视化展示。当分析出数据结论之后，采用合适的方式去展示最终的结果数据。比如可以使用柱状图、折线图、词云图、饼状图等阐释数据的特点。 二、开发环境 开发语言：Python
python框架：django
软件版本：python3.7/python3.8
数据库：mysql 5.7或更高版本
数据库工具：Navicat11
开发软件：PyCharm/vs code
前端框架:vue.js
————————————————
三、功能介绍 整个音乐流量可视化系统，主要包含前台和后台，前台是可视化数据，呈现大屏幕效果，主要包含了音乐数据的分析，以及音乐播放量分析，音乐专辑分析，用户登录信息，后台包含登录注册功能，以及个人中心修改资料，音乐数据添加，对用户的删除和查看，音乐数据的预测分析，以及系统权限的设置，具体如下图所示。
图4-1音乐数据分析系统的分析
四、核心代码 部分代码：
def users_login(request): if request.method in ["POST", "GET"]: msg = {'code': normal_code, "msg": mes.normal_code} req_dict = request.session.get("req_dict") if req_dict.get('role')!=None: del req_dict['role'] datas = users.getbyparams(users, users, req_dict) if not datas: msg['code'] = password_error_code msg['msg'] = mes.password_error_code return JsonResponse(msg) req_dict['id'] = datas[0].get('id') return Auth.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0db2219d03ff6cd7e7e60c493288d5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6191c9376b7713fc159e33e20ae4237/" rel="bookmark">
			【C&#43;&#43;】多态 ② ( 面向对象中 “ 多态 “ 的真正需求 | 面向对象 “ 多态 “ 实现 - virtual 修饰函数 | 代码示例 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、多态实现1、面向对象中 " 多态 " 的真正需求2、面向对象 " 多态 " 实现 - virtual 修饰函数 二、代码示例 - 多态实现1、代码示例2、执行结果 一、多态实现 1、面向对象中 " 多态 " 的真正需求 在上一篇博客 【C++】多态 ① ( 类型兼容性原则与函数重写 | “ 多态 “ 引入 | 函数重写 )
中 , 进行了测试 , 在测试代码中 , 实际的对象类型是 Parent 父类类型的 ,
不管是 将 Parent* 指针 指向 父类 还是 子类 ,不管是 将 Parent&amp; 引用 指向父类 还是 子类 , 调用的都是 父类的 函数 , 这并不是我们想要的 ;
上述测试中 , 根据实际的 对象类型 确定 重写函数 中要调用 父类 还是 子类 中的函数 , 并不是我们期望的 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6191c9376b7713fc159e33e20ae4237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce72be8e588b33990c3ac3fc587c8bc4/" rel="bookmark">
			springboot打成war包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring boot 打成war包 摘要环境修改maven配置环境配置文件的调整启动类引导打包部署 摘要 本文主要以企业级应用服务器（weblogic、普元app server）部署应用的项目背景下，讲述了如何在Spring Boot 2.5.x环境下将项目打包成WAR包，并在Tomcat 9上运行。首先，需要在Maven配置中添加Maven War插件，并排除掉spring-boot-starter-web依赖中的集成tomcat包，然后添加tomcat依赖和servlet API。其次，需要在pom.xml文件中加入war标签以标识项目将被打包成WAR包。此外，如果在使用配置文件并且需要指定profiles.active，那么需要在application配置文件中指定spring.profiles.active=prod。最后，需要增加一个启动类，该类需要放在application.class类同目录下，并引导SpringApplicationBuilder进行配置。
环境 Idea 2023
Windows 10
tomcat 9
maven
springboot 2.5.x
修改maven配置 maven配置
改配置
&lt;build&gt;&lt;plugins&gt;段里加war包插件 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; 如果war放在tomcat下启动出现Class not found的问题，可能是因为一些dependency（比如springfox）的scope为provided，
provided
这个时候把注释掉就行。
要把spring-boot-starter-web依赖里的集成tomcat包排除掉，并单独添加tomcat依赖。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;9.0.45&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 在标签内加入&lt;packaging&gt;war&lt;/packaging&gt;标签，放在、一块就行。
环境配置文件的调整 如果配置使用的是配置文件，并需要指定profiles.active那么需要自行在application（default配置文件里指定spring.profiles.active=prod。
启动类引导 增加启动类，使用war包后APP类的启动需要引导，此类要放到application.class类同目录下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce72be8e588b33990c3ac3fc587c8bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a9433a0a4ad6db2284d4b282fcfcd1b/" rel="bookmark">
			VLC播放器创建rtsp直播流、拉流操作，实现url在网页播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#1.VLC 创建推流
#2.VLC拉流播放
#3. 利用电脑摄像头作为数据源推流
#1.VLC 创建推流
先打开一个VLC窗口
将目标设置为“RTSP”，然后点击“添加”。
手动输入/v路径，可自行定义
如果没有特殊需求，可以直接点击“下一个”使用默认值。
其中 rtsp://:8554/v 中本机IP地址被省略了，需要自己增加，如rtsp://192.20.1.12:8554/v ,就可以拿来拉流播放了
最后一步，点击“流”就可以了。
可查看推流的进度
#2.VLC拉流播放
重新打开一个VLC窗口用来拉流，一个推一个拉，可自行设置窗口下面的重复推流和拉流就可以循环播放。
其中 rtsp 代表了协议，192.168.1.209 表示本机 ip 地址，8554 是前面填写的 RTSP 端口。
稍等就可以看到视频了。
#3. 利用电脑摄像头作为数据源推流，流程步骤和以上一致，就下图一个区别
文章部分图片引用该作者的
https://blog.csdn.net/qq_16992475/article/details/130674055
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89841c8822c5db06902c0d4f7e57b18b/" rel="bookmark">
			python访问pg数据库，并将查询结果保存到文件（txt，word，Excel）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
前言一、安装pg数据库驱动程序二、使用步骤1.引入库2.连接pg数据库，执行操作语句3.将查询结果保存到文件中curPath获取当前文件的绝对路径rootPath为获取当前文件所在目录的父级目录路径 保存为txt文件保存为Excel 文件保存为Word 文件 总结 前言 例如：学习locust时，需要读取数据库的用户信息，涉及多个环境，手动一个环境一个环境数据库查询后复制到文件里太麻烦。
一、安装pg数据库驱动程序 首先，你需要确定你要连接的数据库类型，并安装相应的数据库驱动程序。常见的数据库驱动程序包括psycopg2（PostgreSQL），mysql-connector-python（MySQL），pyodbc（Microsoft SQL Server），cx_Oracle（Oracle）等。你可以使用Python的包管理器（如pip）来安装这些驱动程序。
pip install psycopg2 二、使用步骤 1.引入库 代码如下（示例）：
import psycopg2 # 导入psycopg2驱动程序 2.连接pg数据库，执行操作语句 使用数据库驱动程序提供的函数来建立与数据库的连接。你需要提供数据库的连接参数，例如主机名、端口号、用户名、密码等。
具体的连接参数取决于你要连接的数据库类型
这里我读取的是单独建的一个字典文件config中的配置
连接pg数据库,执行查询代码如下：
def pg_sql(sql): result = [] conn = None cur = None try: # 连接到数据库 conn = psycopg2.connect( host=config.DB["host"], port=config.DB["port"], database=config.DB["database"], user=config.DB["user"], password=config.DB["password"] ) 执行SQL查询：一旦连接成功，你可以使用conn对象来执行SQL查询并获取结果。
cur = conn.cursor() # 创建游标 cur.execute(sql) # 执行语句 rows = cur.fetchall() # 处理查询结果 for row in rows: result.append(row[0]) # 这里的[0]表示只保存了查询出来的第一列数据 except psycopg2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89841c8822c5db06902c0d4f7e57b18b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50069566bf934fb6e733ed2d6aa0b01d/" rel="bookmark">
			`AUTH` failed: ERR AUTH ＜password＞ called without any password configured fo 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章主要讲解安装和更新redis报错：AUTH failed: ERR AUTH called without any password configured fo 的解决办法。
日期：2023年10月27日
作者：任聪聪
问题现象： 提示报错为： `AUTH` failed: ERR AUTH &lt;password&gt; called without any password configured fo 2.服务器页面打开报错：500 错误
3.密码检查了发现没有错误。
解决办法： 说明：这个问题不是什么大问题，或许在你的日志报错中有报错权限错误，但实际上这里是没有重新加载配置，没有让redis生效导致的报错。
重启redis或者重载配置即可解决这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f34ab2012d422274897ca446b7706352/" rel="bookmark">
			【Note详细图解】中缀表达式如何转为后缀表达式？数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中缀表达式 中缀表达式（中缀记法）是一个通用的算术或逻辑公式表示方法，操作符是以中缀形式处于操作数的中间（例：3 + 4），中缀表达式是人们常用的算术表示方法。
前缀或后缀记法不同的是，中缀记法中括号是必需的。计算过程中必须用括号将操作符和对应的操作数括起来，用于指示运算的次序。
后缀表达式 逆波兰表示法（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。
中缀表达式转后缀表达式 中缀转后缀思路 初始化两个栈：运算符栈S1；操作数栈S2从左向右扫描中缀表达式遇到操作数时，将其压入到操作数栈S2遇到运算符时，比较其与运算符栈S1栈顶运算符的优先级如果运算符栈S1为空，或栈顶运算符为左括号“ ( ”，或者优先级比栈顶运算符的优先级较高，则直接将此运算符压入栈中否则，将运算符栈S1中栈顶的运算符弹入并压到操作数栈S2中，再次进行与运算符栈S1栈顶运算符的优先级比较遇到括号时，如果遇到了左括号“ ( ”，则直接压入运算符栈S1；如果遇到右括号“ ) ”，则依次弹出运算符栈S1栈顶的运算符，并压入操作数栈S2，直到遇到左括号" ( "为止，此时将这一对括号丢弃重复步骤2至8，直到表达式的最右边将运算符栈S1剩余的运算符依次弹出并压入操作数栈S2拼接操作数栈S2中的元素并输出，结果即为中缀表达式所对应的后缀表达式 中缀转后缀图示 下图是以9-2*3+(5-2)*2为例子的完整过程。
中缀转后缀流程图 中缀转后缀代码分析 主函数 先初始化一下需要转化为后缀记法的字符串，然后给一个用来存储后缀表达式的数组，假设中缀转后缀的函数为MidtoLast，给这个函数传入中缀表达式的字符数组midstr，以及存储后缀表达式的字符数组laststr：
int main() { char midstr[] = "9-2*3+(5-2)*2";//中缀表达式 printf("中缀表达式为：%s\n", midstr); char laststr[100];//后缀表达式 MidtoLast(laststr, midstr); printf("后缀表达式为：%s\n", laststr); return 0; } 遇到操作数 遍历整个中缀字符串数组，遇到数字字符就直接进行存储，这里我们利用isdigit函数来判断是否数字字符，在下面相关总结的部分，会为大家详细讲解函数的使用方式，这里只先需要知道它的头文件是#include &lt;ctype.h&gt;；
for (int i = 0; midstr[i] != '\0';)//i有的情况是不++的 { if (isdigit(midstr[i]))//数字字符直接放到后缀表达式里 { laststr[j++] = midstr[i++]; } } 遇到运算符 在遇到运算符的时候：遇到第一个操作符就直接压入栈中，根据优先级来判断是谁先出栈谁后出栈，“*”“/”的优先级高于“+”“-”的优先级：
遇到括号 并且在遇到操作符（不是“)”）想要进栈，并且栈顶是“(”，就直接压入栈中：
for (int i = 0; midstr[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f34ab2012d422274897ca446b7706352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab738844b0c52ba433538ed4ada497e0/" rel="bookmark">
			vue2循环的列表商品选择后的商品禁用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css" /&gt; &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.13/vue.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/@unocss/runtime"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app" class="h-90vh grid place-items-center"&gt; &lt;div&gt; &lt;div v-for="(item,i) in list" class="mt-20px flex items-center"&gt; &lt;el-button type="primary"&gt;{{item.name}}&lt;/el-button&gt; &lt;div v-for="(sel,v) in item.tags" class="flex items-center"&gt; &lt;div class="w-180px flex items-center border-1px border-solid ml-20px rounded-5px border-#6f6f6f" &gt; &lt;el-select v-model="sel.value" placeholder="请选择" class="w-110px" &gt; &lt;el-option v-for="item in getOption(item.tags)" :key="item.value" :label="item.label" :value="item.value" :disabled="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab738844b0c52ba433538ed4ada497e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e8d97a6eb2718712c3c12b718260ec/" rel="bookmark">
			el-table中show-overflow-tooltip属性未生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 使用 el-table 组件中的 show-overflow-tooltip 属性，目的是想让“描述”这一栏信息只展示一行，如果信息过长则在行尾增加省略号并且鼠标移至该单元格上时能够显示 tooltip，但是却没有起到作用，页面效果如下：
出现上面图片效果所对应的代码如下： &lt;el-table :header-cell-style="{ 'text-align': 'center' }" :cell-style="{ 'text-align': 'center' }" :data="tableData" :show-header="true" width="800px" &gt; &lt;el-table-column type="index" label="序号" &gt;&lt;/el-table-column&gt; &lt;el-table-column label="姓名" prop="name" &gt;&lt;/el-table-column&gt; &lt;el-table-column label="描述" prop="describe" show-overflow-tooltip &gt;&lt;/el-table-column&gt; &lt;/el-table&gt; 解决方案： 给出以下三种方案都可以试一试，本人是最后一种方案才解决问题的。
方案一 如果该 vue 文件底部的样式标签 &lt;style scoped&gt;&lt;/style&gt; 中属性值用了 scoped，那么将其删除；
方案二 给加了 show-overflow-tooltip 的那一列设置定长宽度（增加 width 属性）：
&lt;el-table-column label="描述" prop="describe" width="150px" show-overflow-tooltip &gt;&lt;/el-table-column&gt; 方案三 css 样式设置不对，在全局 css 文件中（我的项目中该文件名为 index.css，有的项目可能是 common.styl，根据自己实际的项目去找到该文件，找不到的话可以使用快捷键 Ctrl+shift+f 全局搜 .el-table 或 .cell 去定位文件）找到 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53e8d97a6eb2718712c3c12b718260ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6291de2798f902351e4f86f89ffc872/" rel="bookmark">
			SpringBoot 集成 kaptcha 验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 这里就一句话说明了哈，并能找到这里，都是知道这个是要干嘛的了。kaptcha 是谷歌开源的简单实用的验证码生成工具。
项目源码 项目工程源码路径，点击这里， 可以结合源码来看。
项目搭建 项目工程截图 第一步：引入依赖包 关于依赖啊，这里我要说明下，在我看有些博客上面说引入包的时候，说的另外的一个包地址，我就觉很奇怪，还特地去查了下。
在这里我们发现 com.github.penggle » kaptcha 有 75 个使用。但是点击进去之后发现这个居然有一个 Vulnerabilities(漏洞)
最后呢，我在ruoyi 框架的源码下面看到这个引用，并且这个没有显示 Vulnerabilities(漏洞)，那就哦那个这个把。
&lt;!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; 第二步：增加配置文件 这里增加配置文件是为了方便于切换验证码格式
## 这个可以选择 math 或者 char captcha.type=char 第三步：增加配置类 Kaptcha 是支持两种方式的验证码一种是计算类的 配置文件设置为 math，一种就是常规的方式 配置文件设置为 char
@Configuration public class KaptchaConfig { @Bean(name = "captchaProducer") public DefaultKaptcha getKaptchaBean() { DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); Properties properties = new Properties(); // 是否有边框 默认为true 我们可以自己设置yes，no properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6291de2798f902351e4f86f89ffc872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8dbad38eabea703746208c9d53a5cbd/" rel="bookmark">
			基于虚幻引擎的AI训练合成数据生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐：用 NSDT编辑器 快速搭建可编程3D场景
近年来，合成数据生成（Synthetic Data Generation）已成为手动收集和注释数据集的替代方法。
数据合成器的优点主要有两个。 首先，它使获取数据的成本几乎为零，同时消除了几乎所有的数据处理工作。 其次，即使在没有数据的情况下，它也有可能实现新机器学习想法的快速原型设计。
简而言之，一个结构良好的合成数据生成器可以为任何机器学习案例生成现成格式的数据。 然而，合成数据生成器面临的挑战是，它们通常是特定领域的，应用范围狭窄，并且远不如网络架构和学习方法成熟。
在计算机视觉领域，合成数据生成特别有趣，因为多年来相关资源和工具的数量不断增长和显着改进。 不过，这种发展并不是在机器学习领域，而是在虚幻引擎、Blender 和 Unity 等游戏引擎领域。 通常由专业设计师制作，逼真的场景提供了精彩的细节，如下面的视频所示。
视频 1：在虚幻引擎中徒步游览
Modulai 已在多个项目中部署了经过合成数据训练的模型，现在寻求了解 3D 渲染数据在解决计算机视觉任务方面的潜力。 具体来说，在这个项目中，任务是使用虚幻引擎生成由文本组成的合成数据图像。 这些数据将用于训练网络，旨在检测从真实环境捕获的图像中的文本。
如果你希望利用虚幻引擎的逼真渲染能力制作合成数据，最简单的方法是使用基于UE5开发的 UnrealSynth，只需要将3D模型导入UnrealSynth虚幻合成数据生成器，就可以自动生成数据集，非常方便：
https://tools.nsdt.cloud/UnrealSynth
1、使用静态背景合成场景文本数据 场景文本检测应用程序已经采用了合成数据的使用。 几乎所有最先进的网络都是根据合成数据进行预训练，然后根据真实数据进行微调。 用于预训练的最常见的合成数据集是 SynthText 数据集 [1]。 该数据集是由 8,000 张背景图像生成的。 通过在背景图像的不同位置粘贴各种颜色、字体和大小的文本，生成了80万张图像的数据集。 以下是 SynthText 数据集中的两个示例。
图 1：使用背景图像获得的场景文本数据
SynthText 提供了生成场景文本数据的基本方法和一组原则。 最重要的一点是文本的嵌入方式应该尽可能自然。 因此，渲染引擎旨在生成逼真的场景文本图像，其中使用语义分割和深度估计将文本混合到背景图像的合适区域中。 在图 2 中，合适的区域和不合适的区域都被可视化。
图 2：合适（左）和不合适（右）文本区域的示例。
将文本粘贴到背景图像上的过程会导致场景与人类在现实世界环境中自然观察到的场景不同。 从现实世界获得的文本可能具有视点、照明条件和遮挡的变化。 通过将文本插入 2D 背景图像很难产生这些变化。
2、使用 3D 引擎合成场景文本数据 随着游戏引擎缩小现实世界和合成世界之间的差距，探索基于游戏引擎的合成数据生成的可能性是很自然的。 游戏引擎的优点首先是可以通过将场景和文本作为一个整体渲染来实现现实世界的变化。 此外，3D 引擎提供真实场景信息，从而产生更真实的文本区域，并具有许多优点。
该项目使用游戏引擎Unreal Engine 4。当使用游戏引擎渲染场景文本图像时，[2]的工作提供了四个模块。 这些模块为游戏引擎获取带有文本的图像提供了基线，按以下顺序执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8dbad38eabea703746208c9d53a5cbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65373f65eab0349ccb8a908a208857a8/" rel="bookmark">
			Jetson Nano下安装opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录下Jetson Nano下安装opencv的过程。
步骤一：安装依赖项
在移植 OpenCV 前，需要先安装一些依赖项。打开终端窗口，输入以下命令来安装这些依赖项：
sudo apt-get update
sudo apt-get install build-essential cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev
sudo apt-get install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev
sudo apt-get install python2.7-dev python3-dev python-numpy python3-numpy
步骤二：下载 OpenCV 源代码
https://github.com/opencv/opencv.git 下载最新的opencv发布版本
https://github.com/opencv/opencv_contrib 下载对应的opencv_contrib 。（里面放着不稳定的新module。这个新仓库中有很多让人兴奋的功能：包括脸部识别和文本探测，以及文本识别、新的边缘检测器、充满艺术感的图像修复、深度地图处理、新的光流和追踪算法等）
步骤三：编译和安装 OpenCV
在下载 OpenCV 源代码后，需要编译和安装 OpenCV 库。在终端窗口中输入以下命令：
cd ~
mkdir build
cd build
cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_CUDA=ON -D CUDA_ARCH_BIN=“5.3” -D CUDA_ARCH_PTX=“” -D WITH_CUBLAS=ON -D ENABLE_FAST_MATH=ON -D CUDA_FAST_MATH=ON -D ENABLE_NEON=ON -D WITH_GSTREAMER=ON -D WITH_LIBV4L=ON -D BUILD_TESTS=OFF -D BUILD_PERF_TESTS=OFF -D BUILD_EXAMPLES=OFF -D BUILD_opencv_python3=ON -D BUILD_opencv_python2=ON -D PYTHON3_EXECUTABLE=/usr/bin/python3 -D PYTHON2_EXECUTABLE=/usr/bin/python2 -D PYTHON_DEFAULT_EXECUTABLE=/usr/bin/python3 -DOPENCV_EXTRA_MODULES_PATH=/home/name/TG10_lib/opencv_contrib-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65373f65eab0349ccb8a908a208857a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46d9228c00b42b28dee0687c113f748/" rel="bookmark">
			GPT的前世今生：从gpt1到chatgpt的能力提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从2017年google brain提出transformer模型，到2018年基于transformer模型open ai推出了gpt1模型以及google推出了bert模型，到2019-2021年open ai陆续推出gpt2和gpt3，再到2022-2023年推出chat-gpt和gpt4，大语言模型已经发展成了一个具有3个大分支的参天大树[LLM：大语言模型]。在这里主要写写关于gpt的那些事。
GPT发展路径 GPT-1到GPT-3到ChatGPT
各GPT的技术路线：
各GPT的模型大小：
模型发布时间参数量预训练数据量GPT2018 年 6 月1.17 亿约 5GBGPT-22019 年 2 月15 亿40GBGPT-32020 年 5 月1,750 亿45TB GPT-3.5 的进化树：
Note: 图中的几个概念：
1 Instruction tuning 有两个版本，一个是 supervised tuning，另一个是 reinforcement learning from human feedback (RLHF).
2 supervised instruction tuning 使用自然语言作为任务描述，而supervised fine tuning 使用固定格式或标签作为任务描述。supervised instruction tuning 的数据集包含指令、输入和输出三个部分，而supervised fine tuning 的数据集只包含输入和输出两个部分。 GPT-1、GPT-2和GPT-3模型 参考[GPT-1、GPT-2和GPT-3模型详解]
codex：code-davinci-002 [论文：Evaluating Large Language Models Trained on Code]
InstructGPT 参考[InstructionGPT]
[论文：Training language models to follow instructions with human feedback]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46d9228c00b42b28dee0687c113f748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec5ad4c8139830cb0412c4a277b2572/" rel="bookmark">
			InstructionGPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前是写在[Instruction-tuning（指令微调）]里的，抽出来单独讲一下。
基本原理 在做下游的任务时，我们发现GPT-3有很强大的能力，但是只要人类说的话不属于GPT-3的范式，他几乎无法理解。例如，我们说把句子A变成句子B，这种到底是机器翻译呢，还是同语言的转述，都需要让GPT-3学习到才是可以的。
InstructGPT/ChatGPT都是采用了GPT-3的网络结构，通过指示学习构建训练样本来训练一个反应预测内容效果的奖励模型（RM），最后通过这个奖励模型的打分来指导强化学习模型的训练。
InstructGPT采用基于人类反馈的强化学习（RLHF）来不断微调预训练语言模型，旨在让模型能够更好地理解人类的命令和指令含义，如生成小作文、回答知识问题和进行头脑风暴等。该方法不仅让模型学会判断哪些答案是优质的，而且可以确保生成的答案富含信息、内容丰富、对用户有帮助、无害和不包含歧视信息等多种标准。
新训练范式：RLHF 大型语言模型 (Large Language Model，LLM) 生成领域的新训练范式：RLHF (Reinforcement Learning from Human Feedback) ，即以强化学习方式依据人类反馈优化语言模型。RLHF最早可以追溯到Google在2017年发表的《Deep Reinforcement Learning from Human Preferences》，它通过人工标注作为反馈，提升了强化学习在模拟机器人以及雅达利游戏上的表现效果。
RLHF是旨在人类对语言模型的指令与人类意图对齐并生成无负面影响结果的技术。该算法在强化学习框架下实现，分为奖励模型训练和生成策略优化两个阶段。[Training an agent manually via evaluative reinforcement]
训练流程 Step1：根据采集的SFT数据集对GPT-3进行有监督的微调（Supervised FineTune，SFT）：
首先，从测试用户提交的 prompt 中随机抽取一批，然后请专业的标注人员为这些 prompt 给出高质量答案。接下来，我们使用这些&lt;prompt,answer&gt;数据来Fine-tune GPT-3模型，以使其初步具备理解人类prompt中所包含意图，并根据这个意图给出相对高质量回答的能力。虽然这个过程是有效的，但显然这还不足以解决所有问题：此时的SFT模型在遵循指令/对话方面已经优于 GPT-3，但不一定符合人类偏好。
这一步骤中包含了1.2万条训练demonstration数据，其包括prompt和labeled answer。SFT数据一部分来自使用OpenAI的PlayGround的用户，另一部分来自OpenAI雇佣的40名标注工（labeler），并且他们对labeler进行了培训。在这个数据集中，标注工的工作是根据内容自己编写指示，并且要求编写的指示满足下面三点：简单任务：labeler给出任意一个简单的任务，同时要确保任务的多样性；Few-shot任务：labeler给出一个指示，以及该指示的多个查询-响应对；用户相关的：从接口中获取用例，然后让labeler根据这些用例编写指示。
这里使用余弦学习率衰减和残差 dropout 为0.2进行了16个epoch的训练，根据验证集上的RM分数进行最终的SFT模型选择。论文发现SFT模型在第1个epoch后会出现过拟合情况，然而后来实验发现训练更多的epoch会提高RM分数和人类偏好评分，尽管会出现过拟合，所以看来过拟合即使出现也不影响最终的学习结果。
Step2：收集人工标注的对比数据，训练奖励模型（Reword Model，RM）：
具体地，Fine-tuning完之后，再给一个prompt让SFT模型生成出若干结果，通过人工为其排序，可以得到标注的排序pair；基于标注的排序结果（来自于Human Feedback），训练一个Reward Model。
Step3：使用RM作为强化学习的优化目标，利用PPO算法微调SFT模型：
使用第二步训练得到的reward model和PPO算法，对第一步的模型进行 fine-tune。具体地：用生成出来的结果训练SFT，并通过强化学习的PPO方法，最大化SFT生成出排序靠前的answer。
base模型是绿色的，RL Policy是灰色的：
奖励模型（RM） 因为训练RM的数据是一个labeler根据生成结果排序的形式，所以它可以看做一个回归模型。RM结构是将SFT训练后的模型的最后的嵌入层去掉后的模型。
RM模型接受输入&lt;prompt,answer&gt;，给出评价回答质量高低的奖励值——回报分数Score。
具体的讲，对弈每个prompt，InstructGPT/ChatGPT会随机生成K个输出（ 4≤K≤9 ）（可通过beam search等方法），然后它们向每个labeler成对的展示输出结果，也就是每个prompt共展示个结果，然后用户从中选择效果更好的输出。
在训练时，对多个排序结果，两两组合，形成多个训练数据对。接下来，研究者使用这个排序结果数据进行pair-wise learning to rank训练模式，训练回报模型。对于一对训练数据，调节参数使得高质量回答的打分比低质量的打分要高。
奖励模型的损失函数：最大化labeler更喜欢的响应和不喜欢的响应之间的差值。
另外InstructGPT/ChatGPT将每个prompt的个响应对作为一个batch，这种按prompt为batch的训练方式要比传统的按样本为batch的方式更不容易过拟合，因为这种方式每个prompt会且仅会输入到模型中一次。（作者也尝试了shuffle，这样很容易过拟合）
PPO-ptx模型 通过第2步得到的奖励模型来指导SFT模型的继续训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec5ad4c8139830cb0412c4a277b2572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0682671f928cc5e57e2fc40351e3f9/" rel="bookmark">
			解决SpringBoot3整合Druid的兼容性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景描述 springboot升级到3.*之后，Druid出现了兼容性问题。
解决方案 官方已经更新了maven包。将依赖有原先的依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; 改为下面的依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.20&lt;/version&gt; &lt;/dependency&gt; 目前版本是1.2.20版本，解决了启动报错问题
1. 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.20&lt;/version&gt; &lt;/dependency&gt; 2. 新增配置 1.2.20版本，不需要在resources下创建META-INF/spring文件夹，因为这个版本的包已经创建了。
友情链接-官方地址 GitHub - alibaba/druid: 阿里云计算平台DataWorks(https://help.aliyun.com/document_detail/137663.html) 团队出品，为监控而生的数据库连接池
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeff23941a4f81580febe65564f26db4/" rel="bookmark">
			Windows下如何编译FFmpeg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffmpeg一般在linux环境中使用，但是我们目前很多的开发工具是windows，为了方便在windows下调试和使用ffmpeg，我们需要再windows下面编译和使用ffpeg，本文只讲述windows下如何编译ffmpeg的内容。
windows下编译ffmpeg有很多的方法，本文主要用MSYS2的方式来编译。其本质就是模拟一个linux的命令环境，用来编译ffmpeg
一、需要的软件下载 在windows下编译ffmpeg，需要下载几个软件，我们将其下载在一个不带有中文名称的文件夹中。
1、下载MSYS2 官网下载地址：https://www.msys2.org/
2、下载FFmpeg源码 从ffmpeg官网上下载的源码好像不是最新的，后面编译的时候会报错，所以我们直接从github上下载5.1.2版本
3、下载x264源码 官网下载地址：https://www.videolan.org/developers/x264.html
4、下载SDL源码（可选，在编译FFplay.exe时需要） 官网下载地址：https://www.libsdl.org/
这里下载了2.26.3版本
将下载的软件解压放在一个没有中文名称和空格的文件夹中，以下是我的地址路径
二、安装MSYS2及编译工具链 1、点击msys2-x86_64-20230718.exe并完成安装，完成后的工具如下： 2、修改C:\msys64\msys2_shell.cmd文件，将 rem set MSYS2_PATH_TYPE=inherit 修改成 set MSYS2_PATH_TYPE=inherit 3、启动MSYS2 MINGW64，依次输入以下命令行开始安装mingw64编译链和基本依赖 更新环境 pacman -Sy 如果出现 clang32: signature from “Christoph Reiter (MSYS2 development key) reiter.christoph@gmail.com” is invalid
解决方法是输入以下命令，
rm -r /etc/pacman.d/gnupg/ pacman-key --init pacman-key --populate msys2 curl -O http://repo.msys2.org/msys/x86_64/msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz curl -O http://repo.msys2.org/msys/x86_64/msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz.sig pacman -U --config &lt;(echo) msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz pacman -Syu 最终结果：
安装基本依赖库 pacman -S mingw-w64-x86_64-toolchain # mingw64编译工具链，win下的gcc，用于编译64位的库 pacman -S mingw-w64-i686-toolchain # 用于编译32位的库 pacman -S base-devel # 一些基本的编译工具 pacman -S yasm nasm gcc # 汇编器 pacman -S mingw64/mingw-w64-x86_64-SDL2　#SDL2 是ffmpeg依赖的，因为没有它ffpaly不能用 安装完毕后，可以输入gcc -v查看 gcc 版本：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeff23941a4f81580febe65564f26db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03aa5491ea02670edb6309e1cd2977eb/" rel="bookmark">
			工业自动化产品抗干扰笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工业自动化产品抗干扰笔记 名词解释： 耦合矢量控制寄生振荡热噪点闪变噪点尖峰噪点反电势集肤效应交流电阻感抗容抗寄生电容共模与差模电场和磁场漏电流浪涌电压电流传输与电压传输各种地线解析 一、干扰来源： 任何一个电磁干扰现象都具有电磁干扰源，即产生电磁能量的部件或物体。
外部干扰： 雷电、大气电离作用等变频器电动机（动力机械，高频炉，电焊机）其他：荧光灯、开关、断路器、继电器、指示灯等具有瞬变过程的设备也会产生较大干扰 内部干扰 系统的结构布局、制造工艺所引入的。
例如：
多点接地造成的电位差引起干扰；各种寄生振荡引入的干扰以及热噪点、闪变噪声、尖峰噪声等进入的干扰；元器件产生的噪音 举例：
电路板上的开关电源也是干扰源；设计不当的引线也是干扰源
笔记：
继电器触点，会出现反电势，有很强的电流；反电势是出现干扰的原因之一。
二、干扰的传播途径 传播途径可以分为2大类：传导耦合、辐射耦合
电路耦合
也称为：电流耦合
一般为2个相互耦合的电路；
笔记：实体传播；有导线连接电容耦合
连接导线间由于电位差，产生的电场作用
笔记：空间传播；有电位差就会有电场，有电场就会有能量，有容易出现能量的转移，就会出现干扰。电感耦合
两个电路间的磁场相互作用形成的耦合
笔记：空间传播；磁耦合，影响另一个电路近场耦合
干扰源与敏感物体距离较近的辐射耦合
笔记：辐射远场耦合
笔记：辐射 笔记：关键点地线阻抗，由感抗产生，产生很大的压降。在设备的公共地线上存在着各种信号电路的电流，并由地线阻抗变换成干扰电压。这个干扰电压会对两个设备造成很大的影响，我理解：影响来源于分压。由于有了电阻Zc，红蓝两个设备的电压=总电压-Uzc。
笔记：电容三要素介质、面积、距离；相对面积成正比，与距离成反比。
笔记：电感耦合就是磁；导线上电流变化（比如：交流，脉冲），会引起周围磁场发生变化。
笔记：近场耦合与远场耦合都是辐射；
电力线电流很强；
零项电流；产生-&gt;干扰来源-&gt;零项电抗器；
上图公式：r&lt;=λ/2π，其中λ（拉姆达）辐射电磁波的频率；
例如：工频电压是50hz，波长（光速=3*10的8次方）？
蓝牙频率2.4G，波长0.125米？（如果计算的）
笔记:
辐射能量
三、干扰的作用方式 电流、电压的变化通过导线传输时，有“共模”和“差模”两种形态
笔记：大部分干扰为共模干扰。
笔记:电感耦合？
笔记：电磁噪音是什么？电场，有电荷产生电场，有电流会产生电场； 磁场，只有电流会产生磁场；
电场或磁场达到噪音的程度，关键因素是电突然断了，或者电压突然断了。即，电流或电压变化率很大。
实例：
磁环的使用？
解答：信号线绕磁环，最多绕1-2扎。过多，会影响效果；
如何区分电磁干扰、电场干扰?
解答：
近场探头
示波器（10M以上，怀疑辐射干扰）
如何切断接地的干扰？
解答：
显示器（液晶）花屏？
解答：周边找原因。不规则走线（近场耦合），解决方法：垂直走线。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39629232ce0b0ab5b1e0fc0b2f36d8c/" rel="bookmark">
			Flink CDC 2.0 主要是借鉴 DBLog 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DBLog 算法原理 DBLog 这个算法的原理分成两个部分，第一部分是分 chunk，第二部分是读 chunk。分 chunk 就是把一张表分为多个 chunk（桶/片）。我可以把这些 chunk 分发给不同的并发的 task 去做。例如：有 reader1 和 reader2，不同的 reader 负责读不同的 chunk。其实只要保证每个 reader 读的那个 chunk 是完整的，也能跟最新的 Binlog 能够匹配在一起就可以了。在读 chunk 的过程中，会同时读属于这个 chunk的历史数据，也会读这个 chunk 期间发生的 Binlog 事件，然后来做一个 normalize。
首先是 chunk 的划分。一张表，它的 ID 字段是主键 PK。通过 query 能够知道最大的 PK 也能知道最小的 PK。然后根据最大最小的 PK 设定一个步长，那么就能把这个表分成一些 chunk。每个 chunk 是一个左闭右开的区间，这样可以实现 chunk 的无缝衔接。第一个 chunk 和最后一个 chunk 最后一个字段，是一个正无穷和负无穷的表示， 即所有小于 k1 的 key 由第一个 chunk 去读，所有大于 K104 的 key 由最后一个chunk去读。
chunk 的读取，首先有一个 open 打点的过程，还有一个 close 打点的过程。例如，读属于这个 chunk1 的所有数据时，橘色的 K1 到 K7 是这些全量数据。橘黄色里面有下划线的数据，是在读期间这些 Binlog 在做改变。比如 K2 就是一条 update，从 100 变成 108，K3 是一条 delete。K2 后面又变成 119。还有 K5 也是一个update。在 K2、K3、K5 做标记，说明它们已经不是最新的数据了，需要从 Binlog 里面读出来，做一个 merge 获取最新的数据， 最后读出来的就是在 close 位点时刻的最新数据。最后的效果就是，将 update 最新的数据最终输出，将 delete 的数据如 K3 不输出。所以在 chunk1 读完的时候，输出的数据是 K0、K2、K4、K5、K6、K7 这些数据，这些数据也是在 close 位点时数据库中该 chunk 的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f39629232ce0b0ab5b1e0fc0b2f36d8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d20936174a7198569a69880be37d274e/" rel="bookmark">
			实现PC端微信扫码native支付功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实现PC端微信扫码
简介
实现步骤
示例代码
Native支付
简介
应用场景
【客户端】生成支付二维码
常见问题 Vue中qrcode的使用方法
1.下载
2.引入（在所需要的页面中引入）
3.生成二维码
实现PC端微信扫码 在本文中，我们将讨论如何在PC端实现微信扫码native支付功能，并提供代码案例和qrcode的使用方法
简介 微信扫码native支付是一种方便快捷的支付方式，用户只需使用微信扫描二维码即可完成支付操作。对于开发者来说，实现微信扫码native支付可以为PC端应用添加更多支付选择，提高用户体验。
实现步骤 以下是实现微信扫码native支付的步骤：
1. 获取商户号
首先，您需要拥有一个微信支付商户号。如果没有，请注册一个商户账号并申请商户号。
2. 生成支付二维码
在PC端应用中，您可以使用qrcode库生成支付二维码。这个库可以帮助您生成包含支付信息的二维码。
3. 监听支付结果
用户扫描二维码完成支付后，您需要监听支付结果。为了实现跳转到支付结果页面等功能，您可以使用回调函数或事件监听器。
4.处理支付回调
您可以在接收到支付回调后执行相应的后续处理，例如更新订单状态或通知用户支付结果。
示例代码 下面是整理后的示例代码：
const openDialog = async () =&gt; { let result = await reqQrcode(route.query.orderId as string); await generatePaymentQRCode(result.data.codeUrl); dialogVisible.value = true; let timer = setInterval(async () =&gt; { let result = await reqQueryPayState(route.query.orderId as string); if (result.data) { dialogVisible.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d20936174a7198569a69880be37d274e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44520bfba99cb009472e602bbee5e91b/" rel="bookmark">
			网络安全的基本概念——自学网安（黑客）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们谈论网络安全时，我们正在讨论的是保护我们的在线空间，这是我们所有人的共享责任。网络安全涉及保护我们的信息，防止被未经授权的人访问、披露、破坏或修改。
一、网络安全的基本概念 网络安全是一种保护：它涉及保护我们的设备和信息，从各种威胁，如病毒和蠕虫，到更复杂的形式的网络犯罪。它涉及保护我们的数据，确保其安全性、机密性和完整性，同时还要确保我们的设备和网络的正常运行。
网络安全可以分为几个关键领域：
网络安全：保护网络和其资源免受攻击、损坏或未经授权的访问。信息安全：保护信息和信息系统免受未经授权的访问、使用、披露、破坏、修改或破坏。运行安全：确保系统的连续运行和设备的正常运行，防止硬件或软件故障、人为错误或自然灾害导致的中断。应用安全：保护应用程序免受各种威胁，包括病毒、黑客攻击和数据窃取。 网络安全的目标是确保数据和系统的机密性、完整性和可用性。机密性是防止未经授权的数据访问，完整性是保护数据免受未经授权的修改，而可用性是确保网络服务对授权用户始终可用。
二、网络安全的重要性 那么，网络安全为什么重要呢？让我们来看几个例子。
例1：假设你是一家公司的老板，你的公司的所有业务都在网络上运行，包括与客户的沟通、订单处理、产品销售等。如果你的网络被攻击，那么你的业务就会受到影响，你可能会失去客户，你的公司可能会遭受重大损失。这就是网络安全的重要性。
例2：假设你是一个普通的互联网用户，你在网上购物、网上银行、社交媒体等。你的所有这些活动都需要网络，如果你的网络不安全，你的个人信息可能会被窃取，你的银行账户可能会被盗，你的社交媒体账户可能会被滥用。这也是网络安全的重要性。
网络安全的重要性无法被高估。随着我们生活和工作的方方面面越来越依赖网络，任何形式的网络攻击都可能导致灾难性的结果。以下是网络安全的一些主要原因：
1. 个人隐私保护 我们在网络上共享的信息越来越多，包括个人信息（如地址、电话号码和社保号码）和财务信息（如银行账户和信用卡信息）。如果网络安全措施不足，这些信息可能会落入错误的手中，导致身份盗窃或其他形式的犯罪。
2. 企业安全 对于企业来说，网络安全更是至关重要。企业拥有大量的敏感数据，包括员工信息、客户信息、公司财务信息和其他商业数据。网络攻击可能导致这些信息被盗，导致财务损失、品牌形象损害、甚至可能导致公司倒闭。
例如，2017年信用报告公司Equifax遭受的网络攻击，导致大约1.47亿美国消费者的个人信息被盗，包括姓名、社保号码、出生日期、地址，以及一些驾驶执照号码。
3. 国家安全 网络安全也是国家安全的重要组成部分。国家的关键基础设施，如电力网、交通系统和通信网络，都依赖于网络。网络攻击可能导致这些系统瘫痪，对国家安全构成威胁。
例如，2015年乌克兰的电力网遭受网络攻击，导致约23万人断电。据报道，这是历史上首次通过网络攻击导致电力中断的事件。
三、结论 网络安全是我们每个人都需要关注的问题。无论我们是在网上购物、使用社交媒体、在线工作，还是依赖网络进行基本的日常活动，我们都需要保护我们的信息和设备免受网络攻击。
网络安全需要我们所有人的参与，我们每个人都有责任保护我们的网络空间。这包括使用强密码、定期更新软件、谨慎分享个人信息、使用安全的网络连接，以及教育自己和他人关于网络威胁的知识。
网络安全不仅是一个技术问题，更是一个人的问题。只有当我们所有人都认识到网络安全的重要性，并采取适当的措施来保护我们的网络空间，我们才能真正实现网络安全
四、网络安全的知识多而杂，怎么科学合理安排？ 1、基础阶段 中华人民共和国网络安全法 （包含18个知识点） Linux操作系统 （包含16个知识点） 计算机网络 （包含12个知识点） SHELL （包含14个知识点） HTML/CSS （包含44个知识点） JavaScript （包含41个知识点） PHP入门 （包含12个知识点） MySQL数据库 （包含30个知识点） Python （包含18个知识点） 入门的第一步是系统化的学习计算机基础知识，也就是学习以下这几个基础知识模块:操作系统、协议/网络、数据库、开发语言、常用漏洞原理。
前面的基础知识学完之后，就要进行实操了。
因为互联网与信息化的普及网站系统对外的业务比较多,而且程序员的水平参差不齐和运维人员的配置事物，所以需要掌握的内容比较多。
2、渗透阶段 SQL注入的渗透与防御（包含36个知识点） XSS相关渗透与防御（包含12个知识点） 上传验证渗透与防御（包含16个知识点） 文件包含渗透与防御（包含12个知识点） CSRF渗透与防御（包含7个知识点） SSRF渗透与防御（包含6个知识点） XXE渗透与防御（包含5个知识点） 远程代码执行渗透与防御（包含7个知识点） 掌握常见漏洞的原理、使用、防御等知识。Web渗透阶段还是需要掌握一些必要的工具。
主要要掌握的工具和平台：burp、AWVS、Appscan、Nessus、sqlmap、nmap、shodan、fofa、代理工具ssrs、hydra、medusa、airspoof等，以上工具的练习完全可以利用上面的开源靶场去练习，足够了；
3、安全管理（提升） 渗透报告编写（包含21个知识点） 等级保护2.0（包含50个知识点） 应急响应（包含5个知识点） 代码审计（包含8个知识点） 风险评估（包含11个知识点） 安全巡检（包含12个知识点） 数据安全（包含25个知识点） 主要包括渗透报告编写、网络安全等级保护的定级、应急响应、代码审计、风险评估、安全巡检、数据安全、法律法规汇编等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44520bfba99cb009472e602bbee5e91b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c35dcf558aa68b13752547d4b53676e/" rel="bookmark">
			以moectf为例，解决rsa里e和phi不互素问题，ctf中rsa的ZeroDivisionError: invert() no inverse exists报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个非科班出身的选手，初学rsa总会遇到很多数学问题是当前没有见到过的，没深入密码学的ctfer，可能针对于题目给出的参数直接照搬网上脚本，有时候，我们就会遇到很多非标准的rsa题目(被出题人动过手脚)是不能直接用网上的脚本解决的，本文主要为解决笔者初学ctf中的rsa常常遇到的invert() no inverse exists报错。
[moectf 2023]bad_e
题目附件如下：
from Crypto.Util.number import * p = getPrime(512) q = getPrime(512) e = 65537 print(p) # 6853495238262155391975011057929314523706159020478084061020122347902601182448091015650787022962180599741651597328364289413042032923330906135304995252477571 print(q) # 11727544912613560398705401423145382428897876620077115390278679983274961030035884083100580422155496261311510530671232666801444557695190734596546855494472819 with open("flag.txt","r") as fs: flag = fs.read().strip() m = bytes_to_long(flag.encode()) c = pow(m,e,p*q) print(c) # 63388263723813143290256836284084914544524440253054612802424934400854921660916379284754467427040180660945667733359330988361620691457570947823206385692232584893511398038141442606303536260023122774682805630913037113541880875125504376791939861734613177272270414287306054553288162010873808058776206524782351475805 这道题目给出了rsa中的关键参数p,q,c,e,按照一般的脚本尝试，计算欧拉函数phi就会出现invert() no inverse exists报错(如下脚本的注释部分)，原因就出在e,phi不互素，没法进行求逆元的操作。在本题中用gcd函数求出e和（p-1）有因数,而e和(q-1)无因数，因此，借助式子：
e*d = 1 mod (q-1)
m = c ^ d mod q
在模（q-1）下，求解rsa明文，解决
from Crypto.Util.number import * from gmpy2 import * p=6853495238262155391975011057929314523706159020478084061020122347902601182448091015650787022962180599741651597328364289413042032923330906135304995252477571 q=11727544912613560398705401423145382428897876620077115390278679983274961030035884083100580422155496261311510530671232666801444557695190734596546855494472819 c=63388263723813143290256836284084914544524440253054612802424934400854921660916379284754467427040180660945667733359330988361620691457570947823206385692232584893511398038141442606303536260023122774682805630913037113541880875125504376791939861734613177272270414287306054553288162010873808058776206524782351475805 e = 65537 phi = (p-1)*(q-1) # d = invert(e, phi) # m = pow(c, d, n) # print(long_to_bytes(m)) print(gcd(e,phi)) print(gcd(e,p-1)) print(gcd(e,q-1)) d = invert(e,(q-1)) m = pow(c,d,q) print(long_to_bytes(m)) # 65537 # 65537 # 1 # b'moectf{N0w_Y0U_hAve_kN0w_h0w_rsA_w0rks!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c35dcf558aa68b13752547d4b53676e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48712b3313d735a00137f40b69a1bade/" rel="bookmark">
			python中strip()和split()的使用方法（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.strip()：用于移除字符串头、尾指定的字符(默认空格)，不能删除中间部分的字符。
#未使用strip() path=r"C:\Users\67539\Desktop\22\11.txt" f=open(path,"r") for line in f: # 按行读取 print(line) f.close() #结果 cat 22 airplane 23 dog 58 mug 86 ########################### #使用strip() cat={} f=open(path,"r") for line in f: print(line.strip()) f.close() #结果 cat 22 airplane 23 dog 58 mug 86 2.split():指定分隔符对字符串进行切片，返回分割后的字符串列表(默认为所有的空字符,包括空格,换行\n等)。
#使用split() f=open(path,"r") for line in f: print(line.split()) f.close() #结果 ['cat', '22'] ['airplane', '23'] ['dog', '58'] ['mug', '86'] #strip()和split()一起使用。 f=open(path,"r") for line in f: print(line.strip().split()) f.close() #结果 ['cat', '22'] ['airplane', '23'] ['dog', '58'] ['mug', '86'] #利用strip()和split()生成字典。 f=open(path,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48712b3313d735a00137f40b69a1bade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b655186c8682389aba2688d308d85a/" rel="bookmark">
			LVS、nginx、HAproxy区别和工作中选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LVS 的优点： 1 、抗负载能力强、工作在第 4 层仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性 能最强的；无流量，同时保证了均衡器 IO 的性能不会受到大流量的影响； 2 、工作稳定，自身有完整的双机热备方案，如 LVS+Keepalived 和 LVS+Heartbeat ； 3 、应用范围比较广，可以对所有应用做负载均衡； 4 、配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减 少了人为出错的几率； LVS 的缺点： 1 、软件本身不支持正则处理，不能做动静分离，这就凸显了 Nginx/HAProxy+Keepalived 的优势。 2 、如果网站应用比较庞大， LVS/DR+Keepalived 就比较复杂了，特别是后面有 Windows Server 应用的机 器，实施及配置还有维护过程就比较麻烦，相对而言， Nginx/HAProxy+Keepalived 就简单多了。 Nginx 的优点： Git+Jenkins 1 、简述集中式版本管理和分布式版本管理的优缺点。 1 、工作在 OSI 第 7 层，可以针对 http 应用做一些分流的策略。比如针对域名、目录结构。它的正则比 HAProxy 更为强大和灵活； 2 、 Nginx 对网络的依赖非常小，理论上能 ping 通就就能进行负载功能，这个也是它的优势所在； 3 、 Nginx 安装和配置比较简单，测试起来比较方便； 4 、可以承担高的负载压力且稳定，一般能支撑超过几万次的并发量； 5 、 Nginx 可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会 把返回错误的请求重新提交到另一个节点； 6 、 Nginx 不仅仅是一款优秀的负载均衡器 / 反向代理软件，它同时也是功能强大的 Web 应用服务器。 LNMP 现在 也是非常流行的 web 环境，大有和 LAMP 环境分庭抗礼之势， Nginx 在处理静态页面、特别是抗高并发方面相对 apache 有优势； 7 、 Nginx 现在作为 Web 反向加速缓存越来越成熟了，速度比传统的 Squid 服务器更快，有需求的朋友可以考虑 用其作为反向代理加速器； Nginx 的缺点： 1 、 Nginx 不支持 url 来检测。 2 、 Nginx 仅能支持 http 和 Email ，这个它的弱势。 3 、 Nginx 的 Session 的保持， Cookie 的引导能力相对欠缺。 HAProxy 的优点： 1 、 HAProxy 是支持虚拟主机的，可以工作在 4 、 7 层 ( 支持多网段 ) ； 2 、能够补充 Nginx 的一些缺点比如 Session 的保持， Cookie 的引导等工作； 3 、支持 url 检测后端的服务器； 4 、它跟 LVS 一样，本身仅仅就只是一款负载均衡软件；单纯从效率上来讲 HAProxy 更会比 Nginx 有更出色的负 载均衡速度，在并发处理上也是优于 Nginx 的； 5 、 HAProxy 可以对 Mysql 读进行负载均衡，对后端的 MySQL 节点进行检测和负载均衡，不过在后端的 MySQL slaves 数量超过 10 台时性能不如 LVS ； 6 、 HAProxy 的算法较多，达到 8 种； LVS ： 是基于四层的转发 HAproxy ： 是基于四层和七层的转发，是专业的代理服务器 Nginx ： 是 WEB 服务器，缓存服务器，又是反向代理服务器，可以做七层的转发 区别： LVS 由于是基于四层的转发所以只能做端口的转发 而基于 URL 的、基于目录的这种转发 LVS 就做不了 工作选择： HAproxy 和 Nginx 由于可以做七层的转发，所以 URL 和目录的转发都可以做 在很大并发量的时候我们就要选择 LVS ，像中小型公司的话并发量没那么大 选择 HAproxy 或者 Nginx 足已，由于 HAproxy 由是专业的代理服务器 配置简单，所以中小型企业推荐使用 HAproxy 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af8bb25545b81fce9b79d8555adcacc/" rel="bookmark">
			竞赛选题 深度学习卷积神经网络垃圾分类系统 - 深度学习 神经网络 图像识别 垃圾分类 算法 小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 简介1 背景意义2 数据集3 数据探索4 数据增广(数据集补充)5 垃圾图像分类5.1 迁移学习5.1.1 什么是迁移学习？5.1.2 为什么要迁移学习？ 5.2 模型选择5.3 训练环境5.3.1 硬件配置5.3.2 软件配置 5.4 训练过程5.5 模型分类效果(PC端) 6 构建垃圾分类小程序6.1 小程序功能6.2 分类测试6.3 垃圾分类小提示6.4 答题模块 7 关键代码8 最后 0 简介 🔥 优质竞赛项目系列，今天要分享的是
深度学习卷积神经网络垃圾分类系统
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 背景意义 近年来，随着我国经济的快速发展，国家各项建设都蒸蒸日上，成绩显著。但与此同时，也让资源与环境受到了严重破坏。这种现象与垃圾分类投放时的不合理直接相关，而人们对于环境污染问题反映强烈却束手无策，这两者间的矛盾日益尖锐。人们日常生活中的垃圾主要包括有害垃圾、厨余垃圾、可回收垃圾以及其他垃圾这四类，对不同类别的垃圾应采取不同分类方法，如果投放不当，可能会导致各种环境污染问题。合理地进行垃圾分类是有效进行垃圾处理、减少环境污染与资源再利用中的关键举措，也是目前最合适最有效的科学管理方式，利用现有的生产水平将日常垃圾按类别处理、利用有效物质和能量、填埋无用垃圾等。这样既能够提高垃圾资源处理效率，又能缓解环境污染问题。
而对垃圾的分类首先是在图像识别的基础上的，因此本文想通过使用近几年来发展迅速的深度学习方法设计一个垃圾分类系统，从而实现对日常生活中常见垃圾进行智能识别分类，提高人们垃圾分类投放意识，同时避免人们错误投放而产生的环境污染。
2 数据集 数据集采用了中国发布的垃圾分类标准，该标准将人们日常生活中常见的垃圾分为了四大类。其中，将废弃的玻璃、织物、家具以及电器电子产品等适合回收同时可循环利用的废弃物归为可回收垃圾。将剩菜剩饭、果皮果壳、花卉绿植以及其他餐厨垃圾等容易腐烂的废弃物归为厨余垃圾。将废电池、废药品、废灯管等对人们身体健康和自然环境有害而且应当门处理的废弃物归为有害垃圾。除以上三类垃圾之外的废弃物都归为其他垃圾。
该数据集是图片数据，分为训练集85%（Train）和测试集15%（Test）。其中O代表Organic（有机垃圾），R代表Recycle（可回收）
3 数据探索 我们先简单的大致看看数据的情况
所得的垃圾图片数据集中有40个二级类别，图片数量合计
14802张。由图3-1可以看出，各个垃圾类别的图像数据量不均衡，其中图片数据量较少的类别有：类别0(一次性快餐盒)、类别3(牙签)、类别20(快递纸袋)；数据量较多的类别是：类别11(菜叶根)、类别21(插头电线)、类别25(毛绒玩具)。
4 数据增广(数据集补充) 数据增广就是对基础数据集进行扩充，避免因为数据集太少导致在模型训练过程可能出现的过拟合现象，以此来提高模型泛化能力，达到更好的效果。根据扩充数据集的来源可分为两类：内部数据增广是对基础数据集进行水平翻转、垂直翻转、高斯噪声以及高斯模糊等变换操作，来产生新的特征；而外部数据增广是引入新的高质量外部数据来扩充数据集，包括数据爬取与数据筛选两个步骤。
数据爬取是通过网络爬虫技术来实现的，爬虫的流程是，首先向远程服务器端发送请求，获取目标网页的HTML文件；然后跟踪这个链接文件，获取文件数据。各种搜索引擎就是通过爬虫技术来实现网页数据更新，爬取的效率直接决定了搜索的效果。
根据流程图可以看到，爬虫的流程与用户浏览网页的过程相似，首先输入目标URL地址，向服务器发送请求，接着服务器端会返回包含大量链接的HTML文件，然后提取这些链接将其组成URL列表，通过串行或并行方式从服务器端中下载数据。
由于基础数据集中类别数量不均衡，所以本设计使用网络爬虫方式从百度图库对数量较少的类别进行数据扩充，首先输入想要爬取的图片名称关键字，然后输入想要爬取图片的数量以及存放的文件夹之后，进行图片爬取。
5 垃圾图像分类 5.1 迁移学习 5.1.1 什么是迁移学习？ 迁移学习是指在一个数据集上，重新利用之前已经训练过的卷积神经网络，并将其迁移到另外的数据集上。
5.1.2 为什么要迁移学习？ 卷积神经网络前面的层提取的是图像的纹理、色彩等特征，而越靠近网络后端，提取的特征就会越高级、抽象。所以常用的微调方法是，保持网络中其他参数不变，只修改预训练网络的最后几层，最后几层的参数在新数据集上重新训练得到。其他层的参数保持不变，作为特征提取器，之后再使用较小的学习率训练整个网络。因为从零开始训练整个卷积网络是非常困难的，而且要花费大量的时间以及计算资源，所以采取迁移学习的方式是一种有效策略。
通常在非常大的数据集上对ConvNet进行预训练，然后将ConvNet用作初始化或者是固定特征提取器，以下是两个主要的迁移学习方法：
1.微调卷积网络。使用预训练的网络来初始化网络而不使用随机初始化，比较常用的方法是使用在ImageNet数据集上训练好的模型参数进行初始化，然后训练自己的数据集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af8bb25545b81fce9b79d8555adcacc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc7a1865ce2d8256758a91a5872aa12/" rel="bookmark">
			WiFi开发相关的基础工具：iwconfig、iwlist、wpa_supplicant、hostapd（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. iwconfig 1.1 iwconfig语法 iwconfig是Linux下的一个命令，它用于配置无线网络接口，可以显示和更改无线网卡的大部分参数。使用iwconfig的一般语法如下：
iwconfig [interface] [essid {NN|on|off}] [nwid {NN|on|off}] [mode {managed|ad-hoc|...} [freq N.NNNN[k|M|G]] [channel N] [ap {N|off|auto}] [sens N] [nick N] [rate {N|auto|fixed}] [rts {N|auto|fixed|off}] [frag {N|auto|fixed|off}] [enc {NNNN-NNNN|off}] [power {period N|timeout N}] [retry {limit N|lifetime N}] [txpower N {mW|dBm}] [commit] 其中，[interface]是要配置的网络接口名称，例如wlan0；[essid {NN|on|off}]是设置无线网卡的ESSID（扩展服务集标识）；[nwid {NN|on|off}]是设置无线网卡的工作模式；[mode {managed|ad-hoc|...} 是设置无线网卡的工作模式，包括managed（管理模式）和ad-hoc（对等模式）；[freq N.NNNN[k|M|G]]是设置无线网卡的频率；[channel N]是设置无线网卡的信道；[ap {N|off|auto}]是设置无线网卡是否连接到Access Point（接入点）；[sens N]是设置无线网卡的灵敏度；[nick N]是设置无线网卡的别名；[rate {N|auto|fixed}]是设置无线网卡的数据传输速率；[rts {N|auto|fixed|off}]是设置无线网卡的RTS阈值；[frag {N|auto|fixed|off}]是设置无线网卡的分片阈值；[enc {NNNN-NNNN|off}]是设置无线网卡的加密类型；[power {period N|timeout N}]是设置无线网卡的电源管理参数；[retry {limit N|lifetime N}]是设置无线网卡的重试次数；[txpower N {mW|dBm}]是设置无线网卡的发射功率；[commit]是提交配置更改。 1.2 实际测试 显示无线网卡配置信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc7a1865ce2d8256758a91a5872aa12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc98d9456f400810e5cd7f18fd11501/" rel="bookmark">
			企业/公司文件加密软件｜办公文件、文档、图纸加密｜源代码透明加密保护防止外泄。dlp数据泄露防护系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天锐绿盾是一家专业的数据安全保护解决方案提供商，其产品包括文件加密、图纸加密、源代码加密、音视频加密等智能透明加密保护。
PC访问地址：
https://isite.baidu.com/site/wjz012xr/2eae091d-1b97-4276-90bc-6757c5dfedee
以下是天锐绿盾的优势和特点： 全面保护：天锐绿盾可以针对不同类型的文件和数据，提供全面的加密保护。无论是设计图纸、源代码、音视频文件还是其他核心数据，都可以通过天锐绿盾进行加密，防止数据泄露和非法访问。
智能透明加密：天锐绿盾采用智能透明加密技术，可以在不影响正常工作的情况下，对数据进行加密。用户在操作加密文件时，不需要解密就可以进行正常的编辑、修改、保存等操作。
权限控制：天锐绿盾还提供了精细的权限控制功能，可以根据不同用户的角色和权限，设置不同的访问和操作权限。这样可以更好地控制数据的使用和传播范围，确保核心数据的安全性。
加密外发：对于需要外发的文件和数据，天锐绿盾提供了加密外发功能，可以对外发的文件进行加密处理，确保外发数据的安全性。
多层加密：天锐绿盾采用了多层加密技术，可以防止非法访问和恶意攻击。同时，天锐绿盾还支持多种加密算法和强度设置，可以根据企业的实际需求进行灵活配置。
兼容性强：天锐绿盾可以兼容各种操作系统和文件格式，无论是Windows、Linux还是MacOS等操作系统，或者是常用的文件格式如Word、Excel、AutoCAD等，都可以通过天锐绿盾进行加密保护。
试用下载：www.drhchina.com
天锐绿盾作为一家专业的数据安全保护解决方案提供商，其产品可以提供全面、智能、透明的加密保护，有效防止核心数据外泄。
透明加密#防止核心文件数据外泄#
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e7f06de2305e4d42a9289b607878279/" rel="bookmark">
			智慧巡查平台（Ionic/Vite/Vue3 移动端） 问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.环境搭建
1.1 安装 node 16+ 版本
1.2 安装 ionic7
1.3 创建 vue 项目
2.index.html
3.main.ts
3.1 如何默认使用 ios 样式？
3.2 如何使用 ElmentPlus 国际化？
4.router/xxx
5.打包二三事
5.1 添加打包相关文件
5.1.1 .env.development / .env.production
5.1.2 修改 vite.config.ts，增加 base
5.2 打包 h5
5.2.1 如何使用 Live Server，测试打包效果？
5.3 打包移动端
5.3.1 添加 android 平台
5.3.1.1 打包时，依赖解析失败，会导致添加 android 平台失败
5.3.2 构建、同步原生app资源，打开 Android Studio
5.3.2.1 gradle 是个啥
5.3.2.2 如何解决 gradle 下载不下来的问题？
5.3.2.3 执行 ionic cap sync 后 在 Android Studio 中报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e7f06de2305e4d42a9289b607878279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/507e56fe4342fddd973f4a9031e85989/" rel="bookmark">
			Mybatis-Plus 分页插件失效？getPage( )和getTotal( )的结果为0，但getRecords( )可以得到正确结果。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的springboot用的3.4.3版本，在用mybatis-plus进行分页的时候出现了这个问题，getPage（）和getTotal（）都为0，所有的结果都直接显示出来了，说明分页的插件失效了，也就是mybatis-plus拦截器没有起作用。
我也在网上找了找，都是说没有添加配置类，但我是添加了配置类的，还是没有用
经过了几个小时我也是终于找到了问题，原来是因为分页插件版本太低了，于是我用了最新版本
将拦截器类里的代码换成下面这样
@Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } 结果就出来了，因为我前面Page里面设置了，当前页为1，每页显示数据为2
**这其中还有重要的一点别忘了，就是springboot的启动类一定要将配置类扫描到，就是用ComponentScan注解扫描，否则插件也不会生效！
好啦，这样就成功了！感谢您的观看！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2a4ab6b9f3e99244efe10a152f7b89/" rel="bookmark">
			2024通信保研-电磁场电磁波复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标量场的梯度的旋度恒等于0，旋度的散度等于0。
旋度：
rot ⁡ F = ( e x ∂ ∂ x + e y ∂ ∂ y + e z ∂ ∂ z ) × ( e x F x + e y F y + e z F z ) = e x ( ∂ F z ∂ y − ∂ F y ∂ z ) + e y ( ∂ F x ∂ z − ∂ F z ∂ x ) + e x ( ∂ F y ∂ x − ∂ F x ∂ y ) = ∇ × F \begin{aligned} \operatorname{rot} \boldsymbol{F} &amp; =\left(\boldsymbol{e}_{x} \frac{\partial}{\partial x}+\boldsymbol{e}_{y} \frac{\partial}{\partial y}+\boldsymbol{e}_{z} \frac{\partial}{\partial z}\right) \times\left(\boldsymbol{e}_{x} F_{x}+\boldsymbol{e}_{y} F_{y}+\boldsymbol{e}_{z} F_{z}\right) \\ &amp;=\boldsymbol{e}_{x}\left(\frac{\partial F_{z}}{\partial y}-\frac{\partial F_{y}}{\partial z}\right)+\boldsymbol{e}_{y}\left(\frac{\partial F_{x}}{\partial z}-\frac{\partial F_{z}}{\partial x}\right)+\boldsymbol{e}_{x}\left(\frac{\partial F_{y}}{\partial x}-\frac{\partial F_{x}}{\partial y}\right)\\ &amp; =\boldsymbol{\nabla} \times \boldsymbol{F} \end{aligned} rotF​=(ex​∂x∂​+ey​∂y∂​+ez​∂z∂​)×(ex​Fx​+ey​Fy​+ez​Fz​)=ex​(∂y∂Fz​​−∂z∂Fy​​)+ey​(∂z∂Fx​​−∂x∂Fz​​)+ex​(∂x∂Fy​​−∂y∂Fx​​)=∇×F​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff2a4ab6b9f3e99244efe10a152f7b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c51e11fe26cfb87a2e503fa845b7ab/" rel="bookmark">
			微信智能对话初体验：5分钟搭建免费专属的智能对话机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 投入AI创业几个月了，AI小程序快要上线了，已经在备案审批中，想一起AI搞事情的可以联系我看是否有合作机会。昨天刷X时，看到有人说微信新上线了这个平台：https://chatbot.weixin.qq.com/，赶紧试试，把试用的情况给各位汇报汇报。
是什么 完全0基础，没有开发能力的个人/企业运营者，也能免费给你的公众号、小程序一键配置智能客服和营销机器人，5分钟即可实现用户后台的智能对话与互动，降低服务成本，提升营销效率。有开发能力的企业、组织，可使用API接口，定制个性化的任务型服务技能，利用智能对话机器人提升企业运营效率，运营成本及用户活跃，可在【预置技能】内体验
特点 1、免费
2、智能对话机器人
3、即使完全0基础无开发能力的用户，5分钟也可以简单设置使用
4、先进技术能力：平台对话系统由微信对话提供技术支持，应用业内最领先的语义理解模型。（这句是文档上的）
试用过程 微信扫码后登陆“微信对话开放平台”，进入后可以做一下配置，如“欢迎语”、"简单问答"等，如图
欢迎语的配置： 简单问答的配置： 操作很简单，真的是0基础，在没看文档的情况下，几分钟就配置出来了一个智能对话机器人。
效果： 可以快速接入微信公众号、小程序等。
其他功能没有深入，有兴趣的自己去试试。
对AI的创业有兴趣的欢迎找我交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e9abd57bd2f576ec784b1d66e205ce/" rel="bookmark">
			MySQL容器数据库的备份测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、测试目的和流程
本次测试主要目的为测试容器数据库的备份方法和可行性，分为物理备份和逻辑备份测试。测试主机操作系统为Centos7.9，数据库版本为MySQL8.0.30，容器版本为docker24.0.6，备份工具为percona-xtrabackup-80-8.0.30和mysqldump。
测试流程为安装docker，在docker中部署MySQL数据库，然后在主机安装percona-xtrabackup和mysqldump工具，通过备份工具进行数据库备份，验证备份方法是否能够成功。
二、容器及数据库部署
2.1 安装容器
下载yum仓库文件
wget http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
安装docker
yum -y install docker-ce doker-ce-cli containerd.io
启动docker服务，
systemctl start docker &amp;&amp; systemcetl status docker
docker安装成功。
2.2 安装数据库
拉取MySQL镜像
docker pull mysql:8.0.30
启动MySQL容器
docker run -p 3306:3306 --name mysql --restart=always --privileged=true -v /var/lib/mysql:/var/lib/mysql -v /etc/my.cnf:/etc/my.cnf -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.30
登录数据库创建表并插入数据
docker exec -it mysql /bin/bash
mysql -uroot -p123456
create database test;
use test;
create table t1 (id int);
insert into t1 values (1);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7e9abd57bd2f576ec784b1d66e205ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00839d163dfc305858724e15dcb4e012/" rel="bookmark">
			git将本地更改在不影响远程分支情况下提交到远程新建分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 应用场景 当在本地修改后想不影响当前分支的情况下将代码放到远程分支上
流程解析 1.在本地创建一个分支(test git checkout -b test 2.查看当前状态 git status 3.添加到暂存区 git add . 4.查看状态 git status 5.提交 git commit -m "feat: 新修改 " 6.建立远程连接提交修改 git push -u origin test **撤销本地上一次提交 -- 方便测试完成后提交到指定分支 git reset HEAD^ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026e5c19d3b4fb3dd3ab98acc433dd2b/" rel="bookmark">
			JS 计算时间差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		export function timeAgo(dateTimeStamp) { let result = ""; let minute = 1000 * 60; //把分，时，天，周，半个月，一个月用毫秒表示 let hour = minute * 60; let day = hour * 24; let week = day * 7; let month = day * 30; let year = day * 365; let now = new Date().getTime(); //获取当前时间毫秒 let defaultTime =dateTimeStamp dateTimeStamp = dateTimeStamp.substring(0, 18); //必须把日期'-'转为'/' dateTimeStamp = dateTimeStamp.replace(/-/g, '/'); let timestamp = new Date(dateTimeStamp).getTime(); let diffValue = now - timestamp;//时间差 if (diffValue &lt; 0) { return result; } let minC = diffValue / minute; //计算时间差的分，时，天，周，月 let hourC = diffValue / hour; let dayC = diffValue / day; let weekC = diffValue / week; let monthC = diffValue / month; let yearC = diffValue / year; minC = parseInt(minC) hourC = parseInt(hourC) dayC = parseInt(dayC) weekC = parseInt(weekC) monthC = parseInt(monthC) yearC = parseInt(yearC) if (monthC &gt; 12) { // result = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/026e5c19d3b4fb3dd3ab98acc433dd2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7b4d21240dee110be5c32a7f67bca0/" rel="bookmark">
			C&#43;&#43;智能指针使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++智能指针总结 概述标准库中的智能指针创建shared_ptr创建weak_ptr使用智能指针shared_ptr成员函数示例演示 weak_ptr成员函数示例演示 Qt中的智能指针创建QSharedPointer创建QWeakPointer使用智能指针 返回自身引用shared_ptrQSharedPointer 智能指针常见错误二次析构管理数组 概述 在开发C++代码的时候内存管理是一个很麻烦的事情，开发人员一般都是遵守谁申请谁释放的原则，但是实际开发过程中难免有疏忽。当存在多个模块互相传递数据时更是困难，因为不知道数据什么时候会用完，因此也很难释放从而导致内存泄漏。
智能指针是一种C++对象，它模拟传统的原始指针的行为，但可以自动管理所指向的内存。智能指针的原理就是维护一个引用计数，指向相同内存的智能指针之间赋值或者拷贝都会让内部的引用计数增加，出了某些作用域时引用计数减少，当引用计数等于0时指针自动删除内存对象。
标准库中的智能指针 创建shared_ptr int main(int argc, char *argv[]) { // ...... // 常用声明方式 std::shared_ptr&lt;Student&gt; student_ptr_1 = std::shared_ptr&lt;Student&gt;(new Student()); // 推荐使用方式 std::shared_ptr&lt;Student&gt; student_ptr_2 = std::make_shared&lt;Student&gt;(); } 创建weak_ptr weak_ptr和shared_ptr这两指针类型最好配套使用，weak_ptr更像是一个shared_ptr观察器，检测智能指针是否有效的一个观察器。weak_ptr通过shared_ptr的赋值创建，而且不会引起计数器的改变。
int main(int argc, char *argv[]) { // ...... // 赋值给弱引用 std::weak_ptr&lt;Student&gt; student_ptr_3 = student_ptr_2; } 使用智能指针 shared_ptr 成员函数 use_count() 统计指向同一内存对象的智能指针的个数。
swap() 交换两个智能指针所指向的内存地址。
reset() 当前智能指针放弃内存的所有权，引起计数器减少,同时，清空智能指针，是智能指针变为empty状态。
unique() 判断当前智能指针变量是否是唯一所有权（use_count() = 1）。
get() 获取当前智能指针包含的实际类型对象地址。
示例演示 引用计数的增加和减少 int main(int argc, char *argv[]) { // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e7b4d21240dee110be5c32a7f67bca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79d482ea83ef8e79385b32d9137d98c4/" rel="bookmark">
			信息科技如何做好风险管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言介绍亮点结构读者对象 前言 信息科技对金融业务发展所起的作用是举足轻重的。 近年来，金融机构在战略规划中相继引入科技引领的概念。作为金融机构信息科技从业人员，我们笃信信息科技是一个非常有用的工具，一个兼具产品思维和管理思维、拥有高质增效能力的工具。
这个工具如果在金融机构的业务发展中被很好地利用，可以帮助业务部门在开拓市场的过程中乘风破浪、激流勇进，创造丰硕成果；如果用不好信息科技这个工具，则可能引发信息科技风险，不仅损害金融机构业务的发展，还可能破坏金融业的安全和国家金融体系的稳定，信息科技风险甚至成为唯一可能使银行业务在瞬间全部瘫痪的重要风险。
那么如何在充分利用好信息科技赋能金融机构业务发展的同时，做好金融机构信息科技风险管理呢？这本《信息科技风险管理：合规管理、技术防控与数字化》一定可以帮到你。
介绍 这是一本能系统指导银行等金融机构切实做好信息科技风险管理从而提升业务价值的著作。它是5位资深的银行业科技工作者近20年的工作总结，汇聚了他们在大型商业银行、股份制银行、城商行的宝贵经验。
本书的理念是：“从容驾驭科技风险，让合规创造价值”，从合规管理和技术防控2个维度全面地分析和讲解了信息科技风险管理的监管规则、合规要求、技术方案和实施方法等，可以作为信息科技风险管理的标准参考书。
合规管理层面 ：基于对信息科技风险管理的监管要求的深入分析和作者团队丰富的从业经验，总结了信息科技治理、信息科技风险管理、信息科技审计、信息安全管理、信息科技开发及测试、信息科技运行及维护、业务连续性管理、信息科技外包管理8大领域的方法论和落地要求。
技术防控层面：从业务架构、技术架构、功能实现、预期效果等维度详细讲解了以上8大领域的自动化、智能化实施方案；除此之外，还讲解了业务风险防范过程中信息技术的应用，以及金融机构信息技术自主可控的现状和挑战。
写作本书的目的，并非要大家谈虎色变，惧怕信息科技风险而因噎废食，而是让读者在充分认识和理解信息科技风险管理的基础上，更好地利用信息科技的手段促进本机构的业务发展。风险管理做得足够好，往往能够创造更多、更好的机会。希望本书能够帮助广大读者在日后的工作中更好地管理信息科技风险，在本职工作中努力创新，利用信息科技工具推动本机构业务的发展，创造更辉煌的未来。
亮点 相较于其他关于信息科技风险的图书，本书的主要特点如下。
本书对金融机构信息科技风险管理进行了较全面的论述。对于金融机构信息科技风险管理的八大领域，本书均有细致而完整的梳理和分析，并提出了独到的见解。
本书注重理论与实践相结合，内容分为合规管理和技术防控两部分。第一部分针对信息科技风险管理的监管要求加以分析和说明，并总结出行之有效的方法论。第二部分本着技防胜于人防的观点，结合业界在各个领域的最新发展动态，提出了信息科技风险管理的信息化、自动化和智能化实施方案，概括了各场景下信息科技风险管理的最佳实践。
本书紧扣热点，针对金融科技技术应用蓬勃发展以及近年来提出的信息技术自主可控等话题进行了探讨，并根据作者的从业经历，给出了一系列可快速落地的方案。
结构 第一部分为合规管理（第1～9章），主要分析了新时代金融机构信息科技风险的态势，并逐一阐述金融机构信息科技风险管理八大领域。
第二部分为技术防控（第10～21章），从技术防控角度阐述了各个细分领域风险管理信息化、自动化和智能化的最佳实践，并对金融机构信息科技风险管理的未来进行了展望。
读者对象 金融机构高层管理人员。
金融机构首席信息官。
金融机构业务部门、信息科技部门工作人员。
金融机构的IT服务商等。
感兴趣的朋友欢迎前往京东购买正版纸书 https://item.jd.com/13711569.html
金融机构风险管理的关键在于得到金融机构上上下下、里里外外相关人员的重视，在金融机构信息科技的各个领域做好全面的风险管控，避免百密一疏。写作本书的目的，并非要大家谈虎色变，惧怕信息科技风险而因噎废食，而是让读者在充分认识和理解信息科技风险管理的基础上，更好地利用信息科技的手段促进本机构的业务发展。风险管理做得足够好，往往能够创造更多、更好的机会。希望本书能够帮助广大读者在日后的工作中更好地管理信息科技风险，在本职工作中努力创新，利用信息科技工具推动本机构业务的发展，创造更辉煌的未来。
以上是这本书的见解，我也说说我个人的见解哈：
在信息科技领域，风险管理是非常重要的，可以帮助组织有效地应对和降低各种风险带来的潜在损失。以下是一些关键步骤和方法，可以帮助信息科技部门做好风险管理：
风险识别和评估：首先需要明确可能存在的风险，并对其进行评估。这包括对组织的技术系统、数据安全、网络安全和合规性等方面的潜在风险进行识别，并评估其影响程度和可能性。
制定风险管理策略：根据评估结果，制定适合组织的风险管理策略和政策，明确目标和原则，以指导风险管理的实施。这可以包括确定风险接受水平、风险优先级和风险处理方式等。
风险控制和减轻：采取适当的控制措施来减少风险的发生和影响。这可能包括技术措施（如加密、访问控制、备份和恢复系统）、合规性控制措施（如遵循相关的法规和标准）和员工培训等。
风险监测和报告：建立风险监测和报告机制，及时发现和跟踪潜在风险，并向管理层和相关利益相关者提供准确和及时的风险报告。这样可以帮助决策者了解当前的风险状况，并采取必要的行动。
应急计划和恢复能力：制定和实施紧急事件管理计划，以应对突发事件和风险造成的影响。这包括制定灾难恢复计划、备份关键数据、建立冗余系统和进行演练等，以降低业务中断的风险，并提高组织的恢复能力。
持续改进：风险管理是一个持续的过程，需要不断地监测、评估和改进。通过定期的风险审查和评估，及时调整和改善风险管理策略和措施，以适应不断变化的威胁和环境。
值得注意的是，风险管理不仅仅是技术层面上的事情，还需要与组织的其他部门和利益相关者密切合作。建立跨部门的合作机制，并确保风险管理与组织的战略目标和价值观相一致。
总结起来，信息科技部门在风险管理方面应该注重风险识别和评估、制定策略、风险控制、监测和报告、应急计划和恢复能力以及持续改进。通过综合的风险管理措施，可以确保组织在信息科技方面的运营和发展更加安全和可持续。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/78/">«</a>
	<span class="pagination__item pagination__item--current">79/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/80/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>