<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ff2b6fb0abbbe67ae80e2db3d5616c/" rel="bookmark">
			apk安装包信息识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.hysj.utils;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import net.dongliu.apk.parser.ApkFile;
import net.dongliu.apk.parser.bean.ApkMeta;
import net.dongliu.apk.parser.bean.Permission;
import net.dongliu.apk.parser.bean.UseFeature;
public class ApkUtil {
/**
* 获取APK信息
* @param apkUrl apk路径
* @return 信息集合（map）
*/
public static Map&lt;String,Object&gt; readApk(String apkUrl){
//创建集合，存放APK信息
Map&lt;String,Object&gt; resMap=new HashMap&lt;String,Object&gt;();
//获取APK文件
try (ApkFile apkFile = new ApkFile(new File(apkUrl))) {
ApkMeta apkMeta = apkFile.getApkMeta(); //获取APK文件中的元数据
/*************************集合添加信息内容*************************/
resMap.put("apkName", apkMeta.getName()); //apk名称
resMap.put("apkPackageName", apkMeta.getPackageName()); //apk包名
resMap.put("versionCode", apkMeta.getVersionCode()); //版本号
resMap.put("versionName", apkMeta.getVersionName()); //版本名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ff2b6fb0abbbe67ae80e2db3d5616c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeea77b62e49c5052faa1b6310f4d5e7/" rel="bookmark">
			怎样生成CSR证书请求文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装数字证书时，需要准备CSR证书请求文件，使用SSL工具CSR生成器：https://csr.wiki 即可在线自助生成 CSR和密钥文件，另外一种方法使用openSSL/Keytools在服务器中生成证书请求文件，如果需要生成中文证书请 求文件需要使用在线工具、openSSL支持UTF-8、Keytools，本文介绍openSSL来生成CSR。
第一步，生成私钥 以root登录到服务器，并进入根root用户目录
root@yourhost:~# cd ~
在已安装openSSL的服务器中输入以下命令，用来生成私钥
sudo openssl genrsa -out server.key 2048
也可以设置口令如下，如果使用在线CSR请求工具，带有下述口令的不会被识别错误（如使用上述命令，直接跳过 到第二步）
sudo openssl genrsa -des3 -out server.key 2048
通常现在全球大多SSL证书商都是基于2048方式加密，所以私钥也是2048位，回车之后出现下述指令
Enter pass phrase for server.key:12345
输入“12345”方便好记，下一步会要求重新输入
Verifying - Enter pass phrase for server.key:12345
输入完毕，这时会在当前目录下看到server.key文件(/root/server.key)
第二步，生成CSR证书请求文件 输入下述指令，依赖于上面生成的
server.key sudo openssl req -new -key server.key -out server.csr
然后看到下一步会逐步要求输入前面的phrase，也就是
12345 Enter pass phrase for test.key:12345
再就会要求输入相关信息，请务必认真输入，并不能有其它字符 Common Name不是Company Name，本项千万不可输入错误，会影响到证书安装！
这是表示证书验证的域 名，比如ssldun.com和www.ssldun.com，如果用户想节省成本，同时使用不带www和带www，那就在 Common Name中直接输入ssldun.com顶级域名，
Country Name (2 letter code) [AU]:CN #国家代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeea77b62e49c5052faa1b6310f4d5e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe762a5e62ed82e8e77bd6a7d301bae/" rel="bookmark">
			Flutter 混合开发组件化与工程化架构 | 开发者说·DTalk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文原作者: zhengxiaoyong，原文发布于 Android 晓说 (Bytes_)。
一、简述 对于构建Flutter类型应用，因其开发语言Dart、虚拟机、构建工具与平时我们开发Native应用不同且平台虚拟机也不支持，所以需要Flutter SDK来支持，如构建Android应用需要Android SDK一样，下载Flutter SDK通常有两种方式：
在官网下载构建好的zip包，里面包含完整的Flutter基础Api，Dart VM，Dart SDK等
手动构建，Clone Flutter源码后，运行flutter --packages get或其它具有检测类型的命令如build、doctor，这时会自动构建和下载Dart SDK以及Flutter引擎产物
在团队多人协作开发下，这种依赖每个开发本地下载Flutter SDK的方式，不能保证Flutter SDK的版本一致性与自动化管理，在开发时如果Flutter SDK版本不一致，往往会出现Dart层Api兼容性或Flutter虚拟机不一致等问题，因为每个版本的Flutter都有各自对应的Flutter虚拟机，构建产物中会包含对应构建版本的虚拟机。Flutter工程的构建需要Flutter标准的工程结构目录和依赖于本地的Flutter环境，每个对应Flutter工程都有对应的Flutter SDK路径，Android在local.properties中，IOS在Generated.xcconfig中，这个路径会在Native工程本地依赖Flutter工程构建时读取，并从中获取引擎、资源和编译构建Flutter工程，而调用flutter命令时构建Flutter工程则会获取当前flutter命令所在的Flutter SDK路径，并从中获取引擎、资源和编译构建Flutter工程，所以flutter命令构建环境与Flutter工程中平台子工程的环境变量一定得保持一致，且这个环境变量是随flutter执行动态改变的，团队多人协作下这个得保证，在打包Flutter工程的正式版每个版本也应该有一个对应的Flutter构建版本，不管是本地打包还是在打包平台打包。
我们知道Flutter应用的工程结构都与Native应用工程结构不一样，不一致地方主要是Native工程是作为Flutter工程子工程，外层通过Pub进行依赖管理，这样通过依赖下来的Flutter Plugin/Package代码即可与多平台共享，在打包时Native子工程只打包工程代码与Pub所依赖库的平台代码，Flutter工程则通过flutter_tools打包lib目录下以及Pub所依赖库的Dart代码。回到正题，因工程结构的差异，如果基于现有的Native工程想使用Flutter来开发其中一个功能模块，一般来说混合开发至少得保证如下特点：
对Native工程无侵入
对Native工程零耦合
不影响Native工程的开发流程与打包流程
易本地调试
显然改变工程结构的方案可以直接忽略，官方也提供了一种Flutter本地依赖到现有Native的方案，不过这种方案不加改变优化而直接依赖的话，则会直接影响了其它无Flutter环境的开发同学的开发，影响开发流程，且打包平台也不支持这种依赖方式的打包。
再讲讲Flutter SDK，平时进行Flutter开发过程中，难免避免不了因Flutter SDK的Bug亦或是需要改Flutter SDK中平台链接的脚本代码导致直接改动或者定制Flutter SDK，这种方式虽然可以解决问题或定制化，不过极其不推荐，这种方式对后续Flutter SDK的平滑升级极不友好，且带来更多的后期维护成本。
接下来，本文主要是介绍如何对上述问题解决与实现：
Flutter SDK版本一致性与自动化管理
无侵入Flutter SDK源码进行BugFix或定制化
Flutter混合开发组件化架构
Flutter混合开发工程化架构
二、Flutter四种工程类型 Flutter工程中，通常有以下几种工程类型，下面分别简单概述下：
1. Flutter Application
标准的Flutter App工程，包含标准的Dart层与Native平台层
2. Flutter Module
Flutter组件工程，仅包含Dart层实现，Native平台层子工程为通过Flutter自动生成的隐藏工程
3. Flutter Plugin
Flutter平台插件工程，包含Dart层与Native平台层的实现
4. Flutter Package
Flutter纯Dart插件工程，仅包含Dart层的实现，往往定义一些公共Widget
三、Flutter工程Pub依赖管理
Flutter工程之间的依赖管理是通过Pub来管理的，依赖的产物是直接源码依赖，这种依赖方式和IOS中的Pod有点像，都可以进行依赖库版本号的区间限定与Git远程依赖等，其中具体声明依赖是在pubspec.yaml文件中，其中的依赖编写是基于YAML语法，YAML是一个专门用来编写文件配置的语言，下面是一个通过Git地址远程依赖示例：
dependencies:
uuid:
git:
url: git://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe762a5e62ed82e8e77bd6a7d301bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d2641a4e6bd738e2d8eee61a11e65c/" rel="bookmark">
			冒险岛脚本函数积累
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 传送 参数 地图Id
cm.warp(100000000, 0);
// 装备发送 参数 装备id 装备数量
cm.gainItem(1532150, 1);
// 关闭窗口
cm.dispose();
// 提示窗口
cm.sendOk("我即将送你一个装备，确定吗?");
// 下一步提示（继续执行当前方法）
cm.sendNext("请按下一步");
// 选择性操作 #L0# 中的0表示选择状态selection 后面 #L0# 也是同理 // 后面就可以跟着逻辑走 if (selection == 0) { 业务逻辑 } else if(selection == 1){ 业务逻辑 }
cm.sendSimple("你看到我如何操作 status 了吗？\r\n #L0# 是 #l \r\n #L1# 否 #l");
转载于:https://my.oschina.net/u/3516665/blog/3062743
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e2892cf31e72f550dba02aa4b22ba7/" rel="bookmark">
			汇编语言MOV指令详解以及错误写法修正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汇编语言中，MOV是最基本的一种操作。
格式：MOV dest，src
操作：将src的内容移至dest，移动后src的内容仍在，dest的内容被src覆盖。
其规则如下：
1.CS、IP的值不可以作为目标操作数；
2.dest、src不可以同时作为存储器操作数出现；
3.段寄存器不能相互转送；
4.不能把立即数送人段寄存器。
常见错误写法：
1.
DATA DB 10H
MOV [SI],DATA
解释：[SI]指向的是内存内的数，违反规则2，所以此语句错误。
改正：MOV AX,DATA;MOV [SI],AX
2.
MOV CS,AX
MOV DS,1000H
解释：见规则1、4。正确写法：MOV AX,CS(虽然这个没有什么实际意义，但是仅说明这种写法是可行的，即把段寄存器的内容传到寄存器里)；MOV BX,1000H;MOV DS,BX
3.
MOV AX,DL
解释：前后数据类型不匹配，所以不能传送。可以改成MOV AL,DL
4.
MOV DATA,AH
解释：DATA的类型没有说明，如果是DB类型，那么这条语句没错，否则前后类型不一致，错误。改正：DATA必须是DB类型。
5.
DATA DW 1234H
MOV DATA,WORD PTR AH
解释：PTR无法对寄存器进行操作。改正：MOV BYTE PTR DATA,AH。举例说AH的值是00H，操作完成后，内存中的数应该是00H 12H。
6.
MOV [SI],10H
解释：MOV不可以把立即数送入内存中。改正：MOV AH,10H MOV BYTE PTR[SI],AH。
总结一下：MOV命令的书写必须遵守开始列出的四条规则，除此之外注意操作类型需要一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75016b52c5c900b560a322a1947632e/" rel="bookmark">
			Android 事件传递机制详解（事件的分发、拦截、处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、事件在Android中的传递顺序 事件在Android的传递顺序：
Activity--&gt; Window--&gt;DecorView --&gt; 布局View 或者说以上顺序是事件在应用层的传递顺序。如果要说整个事件的传递机制，是Android底层收到触摸屏的事件后，使用socket跨进程通信，用InputDispatcher将事件发送给APP进程，由主线程的Looper去取出消息进行处理。
本文主要分析Android应用层的一个传递过程。
2、事件的传递规则 一个点击事件，或者说触摸事件，被封装为了一个MotionEvent。事件的分发主要由三个重要的方法来完成：
1、分发：dispatchTouchEvent;2、拦截：onInterceptTouchEvent；3、处理：onTouchEvent； 如果是ViewGroup容器类view，则以上三个方法都会用到。但是如果是View类型的，不能包含子view，那就没有第二个拦截方法，因为没有子view的话，拦截方法的就是多余的，只有ViewGroup才会有拦截。
2.1 public boolean dispatchTouchEvent(MotionEvent ev) 此方法用来处理事件的分发，当事件传递给当前view时，首先就是通过调用此方法来进行传递的，如果当前view锁包含的子view的dispatchTouchEvent方法或者当前view的onTouchEvent处理了事件， 通常返回true， 表示事件已消费。如果没有处理则返回false。
2.2 public boolean onInterceptTouchEvent(MotionEvent ev) 此方法用来判断某个事件是否需要拦截，如果某个view拦截了此事件，那么同时个事件序列中，此方法不会被再次调用，因为会把当前view赋值给mFirstTouchTarget对象（原本为null），后续父必问判断mFirstTouchTarget != null时，就会去调用它的onTouchEvent方法，交给mFirstTouchTarget处理事件。
2.3 public boolean onTouchEvent(MotionEvent ev) 用来处理事件，如果事件被消耗了，通常就返回true， 如果不做处理，则发挥false，并且在同一个时间序列中，当前view不会再接受到事件。
以上三个方法的关系可以用以下伪代码来表示：
public boolean dispatchTouchEvent(MotionEvent ev) { boolean consume = false; if(onInterceptTouchEvent(ev)) { consume = onTouchEvent(ev); } else { consume = child.dispatchTouchEvent(ev); } return consume; } 根据以上伪代码和图片展示的流程图，我们梳理一下从根ViewGroup（也就是DecorView）往下传递事件的过程：首先，事件产生后，通过调用根ViewGroup的dispatchTouchEvent方法，然后，如果这个ViewGroup要拦截事件， 则它的onInterceptTouchEvent返回true，然后事件交给它的onTouchEvent处理，不再进行传递。如果不拦截，则继续调用子view的dispatchTouchEvent方法，继续往下传递，往下递归，直到最终被处理。如果没有任何一个view处理事件， 则最终又会回调给Activity的onTouchEvent方法，如果Activity也不处理，则此事件结束，且没做任何处理。
3、事件传递的源码分析 3.1 Activity对事件的传递 前面已经讲到,APP层的事件传递是从Activity看是的，首先就是调用Activity的dispatchTouchEvent， 源码如下：
public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e75016b52c5c900b560a322a1947632e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee06c55267399df1a597ae5036dc5517/" rel="bookmark">
			SwiftUI or Flutter ?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 相信每一个见到 SwiftUI 的开发者，都会立刻将这门船新的 UI 框架和 Flutter 联系到一起。是的，它们身上有太多太多相似的地方，相似的声明语法、实时热更新、跨平台（SwiftUI 仅仅跨 Apple 平台）等等，让羡慕了前端技术爆发的移动开发圈子也热闹了一回。那么 SwiftUI 和 Flutter 到底有什么相似和不同？它们又各有什么优缺点？以及最后，单就技术方向而言，谁才是未来跨平台方案的赢家呢？
语言 现代计算机语言越发趋于相似是一个不争的事实，因为每个语言的基本目标都相当的一致：简洁、灵活、安全、高性能。同时，各种语言的优异特性也都在被相互借鉴，更近一步减少了各个语言之间的鸿沟。
Swift 和 Dart 分别作为这两个 UI 框架的唯一官方语言，在语法层面的差别其实非常小，网上也有大量的文章来对比这两种语言的优劣性。我的使用体验和大部分人相似，就目前而言，Swift 和 Dart 各有优劣。
Swift 比 Dart 更加简洁。Swift 本身在语法层面已经比 Dart 要简洁很多，比如无需在句末添加;分号等。这一点在直接编写 SwiftUI 和 Flutter 上会显得尤为明显。不过这个问题并不全是语言层面带来的问题，也跟这两个 UI 框架的设计有关。
ForEach(userData.landmarks) { landmark in NavigationButton( destination: LandmarkDetail(landmark: landmark)) { LandmarkRow(landmark: landmark) } } 复制代码SliverList( delegate: SliverChildBuilderDelegate( (context, index) { final landmark = landmarks[index]; return LandmarkCell( landmark: landmark, onTap: () { Navigator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee06c55267399df1a597ae5036dc5517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be359e404c56c9b1268b7e51f100b0a6/" rel="bookmark">
			LIBCD.lib(crt0.obj) : error LNK2001: unresolved external symbol _main报错的原因之一。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		照着网上的一直改，
[Project] --&gt; [Settings] --&gt; 选择"Link"属性页,
在Project Options中将/subsystem:console改成/subsystem:windows.
然鹅还是一直报错，就在绝望之际！！！我把代码贴到了交流群里求助。果然！！大家的眼睛总是雪亮的！！！
原来是我把 int main写成了int mian！！
wocao!!
结果一编译直接就通过了：
***.exe - 0 error(s), 0 warning(s)
真是哭笑不得！！哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈
后来百度了一下 还有很多一样犯这个错误的人哈哈哈
看到有个大哥支了个招 #define mian main程序猿必备宏
ahhhhhh
再也不敢了粗心大意了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0a9b32fb94ae4e6a9bd032533acaa12/" rel="bookmark">
			Activiti6自学之路（五）—— 部署流程资源的四种方式及数据库表更新情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建了流程图资源后，
一般我们需要对创建的资源如（leave.bpmn、leave.png）进行部署，部署方式我这里列出四种方式，前三种为单个流程资源的部署，第四种方式可以同时部署多个流程资源。
一、部署流程资源四种方式 部署流程资源有很多种方法，包括classpath、InputStream、字符串、zip格式压缩包
1.classpath方式 读取processes路径下制定名称的流程图，注意一次只能加载一个资源文件
2.InputStream方式 使用InputStream方式部署流程资源需要传入一个输入流及资源的名称，输入流的来源不限，可以从classpath读取，也可以从一个绝对路径文件读取，也可以是从网络上读取。
3.字符串方式 利用字符串方式可以直接传入纯文本作为资源的来源，和前两种方式类似，字符串方式的实现原理是把一组字符串的内容转化为字节流后再部署。 4.zip/bar格式压缩包方式 以上3种部署方式一次只能部署一个资源，除非执行多次deployment.addXxx()方法，如何一次部署多个资源呢？很简单，是我们可以使用zip/bar格式压缩包方式。将资源文件手动或使用Ant脚本，打包文件扩展名可以是Activiti官方推荐的bar或普通的zip。
二、部署流程资源四种方式分别对应的源码实现 下面提供四种方式的源码
package com.springboot.activiti.eimm.leave.controller; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; import java.util.zip.ZipInputStream; import org.activiti.engine.HistoryService; import org.activiti.engine.IdentityService; import org.activiti.engine.ProcessEngine; import org.activiti.engine.RepositoryService; import org.activiti.engine.RuntimeService; import org.activiti.engine.TaskService; import org.activiti.engine.repository.Deployment; import org.junit.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import com.springboot.activiti.eimm.leave.dao.LeaveMapper; import com.springboot.activiti.eimm.leave.service.LeaveService; import lombok.extern.slf4j.Slf4j; @Controller @Slf4j @RequestMapping("/leave") public class LeaveController { @Autowired LeaveMapper leaveMapper; @Autowired private RuntimeService runtimeService; @Autowired private TaskService taskService; @Autowired private IdentityService identityService; @Autowired private RepositoryService repositoryService; @Autowired private ProcessEngine processEngine; @Autowired private HistoryService historyService; @Autowired private LeaveService leaveService; //部署流程资源【第一种方式：classpath】 @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0a9b32fb94ae4e6a9bd032533acaa12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d486f9bdc4cf1c4fdf2e394b04b636/" rel="bookmark">
			python中docx模板合并多个word文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载链接：https://stackoverflow.com/questions/24872527/combine-word-document-using-python-docx from docx import Document # 合并文档的列表 files = ['1.docx', '2.docx'] #合并操作 def combine_word_documents(files): merged_document = Document() for index, file in enumerate(files): sub_doc = Document(file) # Don't add a page break if you've reached the last file. if index &lt; len(files)-1: sub_doc.add_page_break() for element in sub_doc.element.body: merged_document.element.body.append(element) merged_document.save('merged.docx') combine_word_documents(files) 增加 import os from docx import Document from docxcompose.composer import Composer from docx import Document as Document_compose result=[] def search(path=".", name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2d486f9bdc4cf1c4fdf2e394b04b636/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36bd310e9c2535665b18f063b3a5952e/" rel="bookmark">
			关于vue-router中路由权限用到的router.mtcher说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 替换现有router的routes router.matcher = new VueRouter({ routes: newRoutes }).matcher outer.matcher是比较核心的一个属性。对外提供两个方法match(负责route匹配), addRoutes（动态添加路由）。
具体原因：在做路径切换transitionTo方法中，首先就会使用const route = this.router.match(location, this.current)来匹配route, 其实内部会使用matcher来做匹配。修改了matcher即新的routes生效。
对router.matcher属性做修改，即新的routes就会替换老的routes, 其实就是replaceRoutes()的含义（但是官方没有提供这个API）。
参考说明
https://segmentfault.com/a/1190000019386190?utm_source=tag-newest
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec765678d169234a3748d8f2600b4857/" rel="bookmark">
			程序员的线性代数环境配置（Ruby&#43;Gnuplot&#43;Maxima&#43;xlispstat）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac环境下配置： 1.ruby语言配置（程序设计语言）
下载链接：mac +https://macromates.com
2.Gnuplot(绘图工具)
下载：https://www.macports.org/install.php
https://www.macports.org/install.php
https://blog.csdn.net/u014293324/article/details/78358684
1.首先安装xcode，可以去App Store下载
2.安装Macports，去http://www.macports.org下载pkg文件
3.打开终端，进入/opt/local/bin，输入sudo port install gnuplot
4.在终端输入gnuplot后输入plot sin(x)测试是否安装成功
3)maxima 安装（公式推导和计算工具）
下载链接： http://maxima.sourceforge.net/download.html
https://sourceforge.net/projects/maxima/
4）xlispstat的安装（统计计算处理环境）
http://www.stat.ucla.edu/~rgould/154b1www/xlisp.html（目前mac好像安装部了）
Window环境配置
gunplot
https://blog.csdn.net/liyuanbhu/article/details/8502383
maxima
Axmath
ruby(eclipse)
链接：https://pan.baidu.com/s/14ZPNkWqIdU4Q9FTyhBid8g
提取码：4z2k
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62ec37f0d128bf67f9c1de423a2231d7/" rel="bookmark">
			[算法] 深搜整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深搜 之前在leetcode上刷题一直都对这个知识点比较模糊，最近，集中写了几道深搜的题目，将自己的思路和题目做了整理写下此篇博客。博客很多题目是网上提供的一些深搜题目，另外一些是leetcode上关于深搜的题目。
六角填数 如下图所示六角形中，填入1~12的数字。使得每条直线上的数字之和都相同。 图中，已经替你填好了3个数字，请你计算星号位置所代表的数字是多少？
针对下面代码，将整个六角形的每个元素加上标号，标号的规则是从上往下，如下图：
最终12个点的结果：1 8 9 2 7 10 12 6 5 4 11 3
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Solution { private: int n; int ff; vector&lt;int&gt; Star; // 记录每个点的值 vector&lt;bool&gt; visit; // 记录当前值是否被用过 public: Solution(int n_, int find_index) { // n为点的个数，ff为我们最终需要找的点的序号（序号从1开始，到12截至，包括12） n = n_; ff = find_index; for (int i = 0; i &lt;= n; i++) { Star.push_back(0); visit.push_back(false); } Star[1] = 1; Star[2] = 8; Star[12] = 3; visit[1] = true; visit[8] = true; visit[3] = true; }; void dfs(int i); void check(); void printInfo(); }; void Solution::printInfo() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62ec37f0d128bf67f9c1de423a2231d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f1faab631bd4257c49bd67f89c0954e/" rel="bookmark">
			TVM Compiler中文教程：TVM如何优化CPU GEMM(矩阵乘法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 TVM如何优化CPU GEMM(矩阵乘法)准备和基线Opt1：分块Opt2：向量化Opt3：循环排布permuteOpt4：数组打包Opt5：为块写cacheOpt6：并行总结 TVM如何优化CPU GEMM(矩阵乘法) TVM提供抽象接口，允许用户分别描述算法和算法的实施组织（所谓的调度Schedule）。通常，写高性能调度的算法时，会破坏算法的可读性和模块性。此外，尝试各种看似有用的调度是非常耗费人力的。在TVM帮助下，我们能高效地尝试这些调度，来提高计算性能。
在本教程中，我们将演示如何使用TVM优化方阵乘法，并通过简单地添加18行额外代码，实现比基线版本快200倍的优化版本。
在CPU上执行密集计算有两个优化重点：
提高内存访问的cache命中率。复杂的数值计算和hot-spot存储器访问都可以从高cache命中率中加速。这要求我们将原始内存访问模式转换为符合cache策略的模式。SIMD（单指令多数据），也成为向量化处理单元。每次都会处理一小批数据，而不是单个网格。这要求我们以统一模式在循环体中转变数据访问模式，以便LLVM后端可以将其降低到SIMD。 实际上，本教程中使用的所有方法都是此repo中提到的技巧的子集。其中一些已经被TVM抽象并自动应用，但由于TVM限制，其中一些不能简单地应用。
下面提到的所有实验结果都是在配备Intel i7-4770HQ CPU的2015款15英寸MacBook上执行的。对于所有x86 CPU，高速缓存行大小应为64字节。
注：代码里面的测试时间是个人在E5-2620 v4测得 准备和基线 在本教程中，我们将演示如何使用TVM来优化矩阵乘法。在实际演示之前，我们首先定义这些变量。然后我们编写一个基线实现，这是在TVM中编写矩阵乘法的最简单方法。
import tvm import numpy import timeit #矩阵大小(M,K)x(K,N),可以自由尝试不同的形状，有时TVM优化优于MKL的numpy。 M = 1024 K = 1024 N = 1024 #TVM中默认张量类型 dtype = "float32" #使用Intel AVX2（高级矢量扩展）ISA进行SIMD #获得最佳新能要修改下一行为'llvm -mcpu=core-avx2'，或者指定你使用的其他CPU类型 #实测指定CPU以后，Opt6版本可以达到略高于MKL numpy的性能。 target = 'llvm' ctx = tvm.context(target, 0) # Random generated tensor for testing a = tvm.nd.array(numpy.random.rand(M, K).astype(dtype), ctx) b = tvm.nd.array(numpy.random.rand(K, N).astype(dtype), ctx) #numpy测试Numpy running time: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f1faab631bd4257c49bd67f89c0954e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176c20cbb27ebb68fc84e0ffeb034e19/" rel="bookmark">
			win10护眼色设置（注册表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键词为：win10豆沙绿 修改方法为注册表，以下另存为.reg运行即可：
Windows Registry Editor Version 5.00
[HKEY_CURRENT_USER\Control Panel\Colors]
"Window"="202 234 206"
reg文件直接下载链接：https://download.csdn.net/download/yingang2009/11240278
想要还原的朋友，以下另存为.reg运行即可，运行后注销一下：
Windows Registry Editor Version 5.00
[HKEY_CURRENT_USER\Control Panel\Colors]
"Window"="255 255 255"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f809a90c271fee371f7bf1d1d27b862b/" rel="bookmark">
			【图像识别】基于pytorch 的入门demo——CIFAR10数据集识别及其可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
环境配置
1.数据集
2.模型训练
3.训练结果
4.Batch_size的作用
5.参考资料
pytorch使用是动态图计算思想，符合一般的计算逻辑，集成了caffe，容易上手灵活方便，方便使用GPU 加速、自动求导数，更适用于学术界。tensorflow采用的是静态图计算思想，静态图需要提前定义计算图，然后使用创建的计算图运算，运算过程中不利于查看中间变量，但是框架的生态成熟，部署便利，更适合工业界。pytorch自然语言处理包：AllenNLP，计算机视觉包：Torchvision。
环境配置 win10 + GTX 1660Ti +Anaconda3 +Spyder+Pytorch1.0
Pytorch的配置非常简单，非常友好。 直接登录官网，https://pytorch.org/ 选择配置环境，执行Command即可。
spyder配置opencv环境，在Anaconda prompt中输入：
conda install –c https://conda.binstar.org/menpo opencv 1.数据集 CIFAR-10和CIFAR-100是带有标签的数据集（详情：http://groups.csail.mit.edu/vision/TinyImages/）
CIFAR-10数据集共有60000张彩色图像，每张大小：32*32*3，分为10个类，具体见图，每类6000张图。
训练集：50000张，构成了500个训练批batch，每一批batch_size为100张。
测试集：10000张，构成一个batch。每一类随机取1000张，共10类*1000=10000张。
10个类别
另外，pytorch的内置数据集很多：torchvision.datasets
class torchvision.datasets.MNIST(root, train=True, transform=None, target_transform=None, download=False) class torchvision.datasets.FashionMNIST(root, train=True, transform=None, target_transform=None, download=False) class torchvision.datasets.EMNIST(root, split, **kwargs) class torchvision.datasets.CocoCaptions(root, annFile, transform=None, target_transform=None) class torchvision.datasets.CocoDetection(root, annFile, transform=None, target_transform=None) class torchvision.datasets.LSUN(root, classes='train', transform=None, target_transform=None) class torchvision.datasets.ImageFolder(root, transform=None, target_transform=None, loader=) class torchvision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f809a90c271fee371f7bf1d1d27b862b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbee4161f7ab26b73ffa69102279ffc7/" rel="bookmark">
			Opencv笔记 v1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[toc]
2019年3月8日21点48分 杨军伟学习笔记
一、下载Opencv 1、官网下载（测试部分无法运行） 巨慢
2、https://opencv.org/releases.html
3、（3.2以下版本）https://blog.csdn.net/love666666shen/article/details/76449155
4、cmake下载：https://cmake.org/download/
二、安装Opencv 一、添加环境变量：目录\opencv\build\x86\vc11\bin 或者
目录\opencv\build\x64\vc11\bin
二、在【通用属性】 -&gt;【VC++目录】 -&gt;【包含目录】中 添加：
目录\opencv\build\include 目录\opencv\build\include\opencv 目录\opencv\build\include\opencv2 三、工程库（lib）目录的配置 【VC++目录】 -&gt;【库目录】中 添加：
目录\opencv\build\x86(64)\vc11\lib 四、添加依赖库
在【链接器】-&gt;【常规】-&gt;【附加库目录】选择lib目录 如：目录\opencv\build\x64\vc14\lib
在【链接器】-&gt;【输入】-&gt;【附加依赖项】中添加库文件名称(带’d’的时DEbug中用的)
opencv_world320.lib opencv_world320d.lib
1、OpenCV 3.2.0附加依赖项库 网上找的不能用 解决方法：到安装目录\opencv\build\x64\vc14\lib 找到对应的lib文件添加，我只找到目录下的2个 添加暂时可运行（后续验证就是这两个就行） 2、由于找不到 opencv_world320.dll，无法继续执行代 解决方法：到安装目录\opencv\build\x64\vc14\bin 复制里面的dll文件到 C:\Windows\System32 （x64） C:\Windows\SysWOW64 （x86）32位系统 五、其他情况不安全代码
将宏添加到 【c/c++】-&gt;【预处理器】-&gt;【预处理器定义中】 测试代码：//图片放在项目的二级目录下
#include &lt;opencv2/opencv.hpp&gt;
using namespace cv;
int main(void)
{
Mat img=imread("1.jpg"); imshow("test",img); waitKey(5000); }
图片打开成功
三、一般类与函数 1、Mat类
2、imread 读取图片，指定读取的颜色方式。 3、imshow 在指定名称的窗口显示指定图片 4、namedWindow 创建窗口 5、imwrite 向文件中写入一张图片 6、VideoCapture 类：对视频进行读取显示，以及调用摄像头。 7、定义ROI的两种方法 1、Mat类 用于保存图像以及其他矩阵数据的数据结构，默认情况下其尺寸为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbee4161f7ab26b73ffa69102279ffc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de5e638b75cb15a4a778497a8355171/" rel="bookmark">
			论文笔记：CornerNet—Detecting Objects as Paired Keypoints
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CornerNet: Detecting Objects as Paired Keypoints 1、摘要2、细节2.1、概览2.2、检测角点2.3、角点分组2.4、角点池化2.5、Hourglass Network 3、实验4、总结5、思考 1、摘要 作者提出了一种 s i n g l e − s t a g e single-stage single−stage 检测器，将目标边界框看作一对关键点（左上和右下）的检测。不需要设计一组 a n c h o r anchor anchor，作者提出新的池化方法 c o r n e r p o o l i n g corner~pooling corner pooling 来帮助网络更好地定位角点。
使用 a n c h o r anchor anchor 存在两个主要缺陷：
采用大量的 a n c h o r anchor anchor 导致严重的正负样本不平衡问题 a n c h o r anchor anchor 的使用引入了大量超参数 三处创新点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2de5e638b75cb15a4a778497a8355171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd494206a8ca8ddc7b17d94037cb98e7/" rel="bookmark">
			视频&#43;公式编辑器（Axmath)&#43;xMind/imindMap&#43;word一个完美的配套学习环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		菜鸟看视频，新手转博客；精专啃书本，大神攻算法。
我们学习机器学习的过程中懂的数学是第一要务，数学是提升我们的逻辑思维能力的，所以我们要有一个好的学习方式，本文章算不是技术，只是针对枯燥的理论知识有一个好的指引学习的方法:
第一步:看视频:学机器学习的当然是先把数学和机器学习的应用结合起来，因此在B站上找到你想要学习视频
第二步：完美的记笔记，就是我们一定想要有一个完美的公式编辑器，在这里给大家分享一个可以单独编辑也可以作为WORD插件的公式编辑器：AXmath
下载地址：https://pan.baidu.com/s/1z91wKiNGXbpaaq8BMgE1Ow
提取码：mldy
单独使用：
第三步：思维导图的选择
1）xmind(好用，可破解)
2）imindMap(很酷但是要钱)
通过以上三点的结合，再加上博客的整理，这样我们的思维逻辑知识体系才能够建立起来。学而不忘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af604cf636b260521f86aea507ff9d4e/" rel="bookmark">
			js各种宽高度学习笔记图文总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在javascript中操作dom节点让其运动的时候，常常会涉及到各种宽高以及位置坐标等概念，如果不能很好地理解这些属性所代表的意义，就不能理解js的运动原理，同时，由于这些属性概念较多，加上浏览器之间
实现方式不同，常常会造成概念混淆，经过研究之后，这里来进行一个总结。
一、和window（浏览器）相关的宽高宽高属性
1、outerWidth与outerHeight:是整个浏览器窗口的大小，包括窗口的标题 工具栏和 状态栏等。
2、innerWidth与innerHeight：浏览器中可网页可显区域的宽高（frame，frameset也有该属性），需要注意的是在打开控制台之后,innerWidth和innerHeight会发生相应的变化
以上在浏览器宽度为1280，高度为936的情况下
二. 和screen（电脑显示器）相关的宽高
screen.width 与 screen.height:电脑显示器屏幕的宽高
screen.availWidth 与 screen.availHeight: 电脑显示器屏幕的可用宽高（减去状态栏）
window.screenLeft,window.screenX: 浏览器外部距离屏幕左边的距离
window.screenTop, window.screenY: 浏览器外部距离屏幕左边的距离
显示器的状态栏高度一般为40px;
&lt;script&gt; function demo(){ var outerWidth = window.screen.width; var outerHeight = window.screen.height; var innnerWidth = window.screen.availWidth; var innerHeight = window.screen.availHeight; var screenX = window.screenX; var screenY = window.screenY; console.log("screen.width:"+screen.width); console.log("screen.height:"+screen.height); console.log("screen.availWidth:"+screen.availWidth); console.log("screen.availHeight:"+screen.availHeight); console.log("screenX:"+screenX); console.log("screenY:"+screenY); } demo(); &lt;/script&gt; 他们之间的关系是: screen.width(height) = screen.availWidth(availHeight) + 状态栏宽度(高度[40])
三. 和client相关的宽高（padding+content）
1、document.body.clientWidth 与document.body.clientHeight:元素可视部分的宽高，即padding+content,可总结为以下三种情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af604cf636b260521f86aea507ff9d4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/013edcf9cb7cae2fb4f9a2e79846cc61/" rel="bookmark">
			Linux ： Failed to connect to 127.0.0.1 port 8888: 拒绝连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Failed to connect to 127.0.0.1 port 8888: 拒绝连接 分析：
lsof -i:8888 发现端口未被占用 查看代理：env|grep -i proxy https_proxy=127.0.0.1:8888 http_proxy=127.0.0.1:8888 socks_proxy= ftp_proxy= 原因是127.0.0.1 port 8888被当作代理占用了，需要关闭。
解决：在终端输入以下命令
export http_proxy='' export https_proxy='' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f1eadbeba8aa23d3ad9944accc9d5d/" rel="bookmark">
			debian无法手动重启网卡的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统为debian9.9，Linux debian 4.9.0-9-amd64 #1 SMP Debian 4.9.168-1+deb9u2 (2019-05-13) x86_64 GNU/Linux
最近在使用过程中，发现无法通过命令手动重启网卡，在网络上搜索了很多帖子，都没有解决问题。只能慢慢排查。
首先修改配置文件以后，手动重启网卡，提示如下：
root@debian:~# service networking restart Job for networking.service failed because the control process exited with error code. See "systemctl status networking.service" and "journalctl -xe" for details. 根据提示，输入systemctl status networking.service继续排查问题，
root@debian:~# systemctl status networking.service ● networking.service - Raise network interfaces Loaded: loaded (/lib/systemd/system/networking.service; enabled; vendor preset: enabled) Active: failed (Result: exit-code) since Thu 2019-06-13 15:27:41 CST; 2min 22s ago Docs: man:interfaces(5) Process: 765 ExecStart=/sbin/ifup -a --read-environment (code=exited, status=1/FAILURE) Process: 760 ExecStartPre=/bin/sh -c [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f1eadbeba8aa23d3ad9944accc9d5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81ab1febd5adf10055dc41d0f1d9c57b/" rel="bookmark">
			免费获取省市县的shp，geojson文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理下资料：
需要做准备工作：
1、 一个全能地图下载（https://blog.csdn.net/qq_41619796/article/details/90241491），可以获取边界坐标
2、获取文件的网站 http://geojson.io
3、GoogleEarthProPortable.exe文件，或者arcgis,又或者udig，用来查看最终生成文件
步骤：以县级为案例
第一：打开全能地图下载器
1、找县，2、打开左上角文件 ==》导出边界坐标，得到一个txt文件，里面有坐标数据
第二：把txt边界数据改变为geojson文件：
{ "type": "FeatureCollection", "features": [ { "type": "Feature", "properties": {}, "geometry": { "type": "Polygon", "coordinates": [ [//从这里开始，把你txt中得到的坐标数据，把下面的替换了 [112.399030,22.775490], [112.391630,22.782920], [112.390420,22.796070], [112.383750,22.801780], [112.367500,22.794760], [112.361760,22.797720], [112.319250,22.794060], [112.319700,22.798450], [112.327170,22.801680], [112.329700,22.807390], [112.342210,22.814480], [112.328030,22.829690], [112.320570,22.829690], [112.318580,22.839200], [112.296840,22.830590], [112.289390,22.830650], [112.285480,22.834570], [112.280710,22.829580], [112.267720,22.830130], [112.265520,22.840970], [112.255470,22.847570], [112.226430,22.836550], [112.222110,22.838530], [112.219530,22.825250], [112.194260,22.808240], [112.188510,22.806860], [112.180730,22.810200], [112.164170,22.789040], [112.142390,22.792620], [112.131860,22.790450], [112.124570,22.778760], [112.107790,22.772610], [112.098200,22.751400], [112.090550,22.749180], [112.083300,22.738890], [112.076090,22.736940], [112.075620,22.721080], [112.060560,22.705960], [112.050210,22.688190], [112.049950,22.674780], [112.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81ab1febd5adf10055dc41d0f1d9c57b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a103737e8721b1872023634d33141a1/" rel="bookmark">
			分布式ID生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.背景 公司产品线最初为了快速上线、快速迭代，所使用的ID采用把JDK原生的32位(去掉四个-)或者36位的原始UUID(Universally Unique Identifier)缩短为19位，且不丢失精度的方式。
例如：E3MGMM6SQwsaZqHfcIs
但是UUID太长而且人类不可读（由大写、小写、数字随机组成），且对数据库性能有一定的影响（短且数字递增的最优），所以希望开发出一种全局唯一性、高性能、纯数字、较短、趋势递增的分布式ID生成器。
1.需求/设计 ID不重复、全局唯一长度简短：长度尽量保持短（最好在10位以内），方便用户转述、记录、投诉能通过ID区分业务类型，例如A开头的表示国内机票推荐使用纯数字性能要高适应分布式环境趋势递增 业界常用的ID如下所示：（作为参考）
暂定参考设计为：
2.UUID 2.1概念 UUID 含义是通用唯一识别码 (Universally Unique Identifier)，这是一个软件建构的标准。
也是被开源软件基金会 (Open Software Foundation, OSF) 的组织应用在分布式计算环境领域的一部分。
UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。
UUID保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。
按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字
2.2优缺点 优点：
UUID的好处是生成和使用简单、性能好、本地生成、没有高可用风险、而且在全球范围内任意分布式系统中都不会重复，不用考虑数据库主键的冲突等。缺点：
缺陷在于生成的结果串会比较长；由大写、小写、数字随机组成，人类完全不可读，不可记；在进行ID转述过程中特别容易出错；查询效率低，数据库的主键若使用数字的性能要高于字符串。 2.3一个生成19位UUID的算法 JDK自带的UUID类中toString方法其实是把128位字节转换为16进制数值，若使用62进制，既0-9a-zA-Z，这样就能缩短UUID到19位。为此，专门编写了一个UUID字符串生成法。
详见：超短的19位UUID，性能几乎翻倍提升
3.数据库自增ID 使用数据库的id自增策略，如 MySQL 的 auto_increment。并且可以使用两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。
能够保证严格有序，但是有严重的性能瓶颈。项目组最早就是使用这种方式，性能低下、吃了不少苦头。
为了解决性能低的问题，可以采用批量生成ID的方式缓解。
主要思想为：一次按需批量生成多个ID，每次生成都需要访问数据库，将数据库修改为最大的ID值，并在内存中记录当前值及最大值。
4.类snowflake方案 1bit:一般是符号位，不做处理41bit:用来记录时间戳，这里可以记录69年，如果设置好起始时间比如今年是2018年，那么可以用到2089年，到时候怎么办？要是这个系统能用69年，我相信这个系统早都重构了好多次了。10bit:10bit用来记录机器ID，总共可以记录1024台机器，一般用前5位代表数据中心，后面5位是某个数据中心的机器ID12bit:循环位，用来对同一个毫秒之内产生不同的ID，12位可以最多记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下毫秒。 优点：
毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
生成ID的性能也是非常高的。
可以根据自身业务特性分配bit位，非常灵活。
缺点：
强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。
上面只是方案和思路，需要落地实现
详见：ID 生成器 雪花算法
5.Leaf——美团点评分布式ID生成系统 Leaf是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。
详见：Leaf——美团点评分布式ID生成系统
6.百度UidGenerator(项目中最终使用该方案) UidGenerator是Java实现的, 基于Snowflake算法的唯一ID生成器。
UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题. 最终单机QPS可达600万
依赖版本：Java8及以上版本, MySQL(内置WorkerID分配器, 启动阶段通过DB进行分配; 如自定义实现, 则DB非必选依赖）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a103737e8721b1872023634d33141a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce43229f3f40baa8b1e71873d65ec6e/" rel="bookmark">
			连接共享打印机出现0x000000bcb问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以win7为例，在局域网中，安装共享打印机时，会出现安装失败，打开详细信息显示为0x000000bcb，重新安装也不行，具体操作如下：
连接共享打印机出现0x000000bcb问题的解决方法
1
打开控制面板，点击卸载程序，如下：
2
点击”查看已安装的更新“如下：
3
点击右上角“搜索已安装更新”，输入：”KB4022722“，点击搜索，会在下面的找到”KB4022722“的更新，点击卸载就可以了。
4
接下来会提示稍后重启或立即重启电脑，点击立即重启电脑。
5
若上述方法不行可尝试下载安装Windows6.1-KB3170455-X64补丁
END
再次点开已共享的打印机，然后安装驱动，发现安装成功了，可以开始打印了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555ca79486aa5d971000fa55d533f041/" rel="bookmark">
			java后台接收微信小程序发送的post请求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java后台接收微信小程序发送的post请求参数 // 微信端:data数据要加上JSON转换JSON.stringify() wx.request({ url: 'http://127.0.0.1:8080/login', //仅为示例，并非真实的接口地址 method: "POST", data: JSON.stringify({ code: code // 需要传到后台的值 }), header: { 'content-type': 'application/x-www-form-urlencoded"' // 默认值 }, success(res) { console.log(res.data) } }) // java端:通过参数HttpServletRequest request解析出json格式的参数 // json包用的阿里的 com.alibaba.fastjson.JSONObject; JSONObject result = null; StringBuilder sb = new StringBuilder(); try (BufferedReader reader = request.getReader();) { char[] buff = new char[1024]; int len; while ((len = reader.read(buff)) != -1) { sb.append(buff, 0, len); } result = JSONObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/555ca79486aa5d971000fa55d533f041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf6495ef544fec0f44d24748239c3de/" rel="bookmark">
			解决checkbox复选框未选中时不传值的问题 / 判读复选框是否选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 想实现的需求是：复选框默认选中，选中时传值1，未选中时传值0；
根据W3C的规则未选中的checkbox和禁用的控件不是有效控件，不会传值。
方法1：
&lt;input type="hidden" name="aa" value="0" /&gt; &lt;input type="checkbox" name="aa" id="aa" value="1" checked/&gt; 网上最多的方法是这种，但是对我却没用，未选中时传值是为0 ，但是选中时hidden的值并没有被checkbox覆盖掉，传值为["0","1"]这样的数组。
方法2：判读复选框是否勾选
于是我试用判断复选框是否选中；若选中时给它设置值为1，否则为0 ；
&lt;input type="checkbox" name="aa" id="aa" checked/&gt; if($("#aa").is(':checked')){ $("#aa").val(1); }else{ $("#aa").val(0); } 方法3：同样是判读复选框是否勾选
if($("#aa")[0].checked){ $("#aa").val(1); }else{ $("#aa").val(0); } 方法4：
checkbox只做显示，另一个隐藏域来保存提交的数据。checkbox改变时修改隐藏域的值。
&lt;label&gt;是否选中&lt;/label&gt; &lt;input type="checkbox" onchange="this.nextElementSibling.value = (this.nextElementSibling.value==0)?1:0 " checked/&gt; &lt;input type="hidden" name="aa" value="1"/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6c2a4b16842e2d143f8800082b95ac/" rel="bookmark">
			举例说明strcmp的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		strcmp为比较字符串函数（只能比较字符串的大小）
strcmp函数的原型为：int strcmp( const char *string1, const char *string2 );
返回值为：
Value Relationship of string1 to string2
&lt; 0 string1 less than string2 （string1 &lt; string2）
0 string1 identical to string2 （string1 = string2）
&gt; 0 string1 greater than string2 （string1 &gt; string2）
eg:
#define	_CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; int main() { //字符串比较 char arr1[] = "AbCd"; char arr2[] = "abcd"; char arr3[] = "AbCd"; char arr4[] = "ABCD"; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e6c2a4b16842e2d143f8800082b95ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad46122568cbebd68a257e463e7d0660/" rel="bookmark">
			Hadoop Windows插件配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、将hadoop-2.7.3.tar.gz解压（Windows），解压路径不要出现中文、空格
2.将windows软件/插件.rar/bin/ 中的所有文件（7个） 拷贝到 hadoop-2.7.3 解压的bin目录中
Hadoop Windows插件配置：
1、将hadoop-2.7.3.tar.gz解压（Windows），解压路径不要出现中文、空格
2、将01课前资料/windows软件/插件.rar/bin/ 中的所有文件（7个） 拷贝到 hadoop-2.7.3 解压的bin目录中
3、将hadoop-2.7.3/bin/hadoop.dll文件复制到C:/Windows/System32/ 目录下
4、双击hadoop-2.7.3/bin/winutils.exe文件
5、配置环境变量
%HADOOP_HOME%\bin
%HADOOP_HOME%\sbin
Hadoop Eclipse插件配置：
1、解压Eclipse
2、将01课前资料/windows软件/插件.rar/hadoop-eclipse-plugin-2.6.5.jar 文件拷贝到 Eclipse的plugins目录下
3、启动Eclipse
4、Eclipse：window–&gt;Preferences–&gt;Hadoop Map/Reduce 在右侧的界面中指定Hadoop-2.7.3解压根目录
5、Eclipse：window–&gt;Preferences–&gt;General–&gt;WorkSpace 在右侧的界面中设置字符集text file encoding为UTF-8
6、在Eclipse：window–&gt;Show view–&gt;Other 输入map，双击显示的Map/Reduce Locations
7、Map/Reduce Locations：空白处右键–&gt;new Hadoop Locations
Location name: 名称任意指定
Map/Reduce(V2)Master:
Host:虚拟机IP地址（192.168.56.100）
DFS Master：
Port：9000
保存退出。
此时在项目管理栏中，可以看到DFS Locations，点击打开，就可以看到在HDFS文件系统中的内容。 使用XShell和XFTP连接Linux操作系统的时候，等待时间较长：
vi /etc/ssh/sshd_config
进入之后，先按 /DNS （搜索包含DNS的字符串）
找到如下所示的字符串：
#UserDNS yes
修改为 UserDNS no
保存退出。
重启ssh服务
service sshd.service restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55a891c2ef7335baf34b16ec871bade0/" rel="bookmark">
			ERROR StatusLogger No log4j2 configuration file found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 idea报日志错误
ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.
pom.xml中加上配置
&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; 是因为缺少了配置文件，resources文件夹下加上log4j2.xml文件。
&lt;configuration monitorInterval="60"&gt; &lt;Appenders&gt; &lt;Console name="Console" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="%-4r [%t] %-5p %c{1.} - %msg%n"/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Logger name="org.apache.zookeeper" level="ERROR"/&gt; &lt;Root level="error"&gt; &lt;AppenderRef ref="Console"/&gt; &lt;/Root&gt; &lt;/Loggers&gt; &lt;Loggers&gt; &lt;Logger name="mh.sample2.Log4jTest2" level="INFO"&gt; &lt;AppenderRef ref="File" /&gt; &lt;/Logger&gt; &lt;Root level="INFO"&gt; &lt;AppenderRef ref="Console" /&gt; &lt;/Root&gt; &lt;/Loggers&gt; &lt;/configuration&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56023bc7655cd5a0a52df53e44c2408/" rel="bookmark">
			论文笔记：Towards accurate multi-person pose estimation in the wild（G-RMI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Towards accurate multi-person pose estimation in the wild 1、摘要2、方法2.1、人体检测2.2、姿态估计 3、实验4、总结 1、摘要 作者提出了新的自顶向下的多人姿态估计方法。首先使用 F a s t e r R C N N Faster~RCNN Faster RCNN 预测可能包含人体目标的边界框的位置和大小。然后估计每个提议边界框可能包含的关键点。使用全卷积 R e s N e t ResNet ResNet 预测每个关键点的密度热图和偏移量。为了合并输出，作者引入了一种新的聚合过程来获得高度定位的关键点预测。作者还使用了一种新形式的基于关键点的非最大值抑制，而不是更粗糙的框级非最大抑制，以及一种新形式的基于关键点的置信度得分估计，而不是框级得分。
2、方法 如图 1 1 1 所示为算法处理过程。
图 1 1 1 首先使用 F a s t e r R C N N Faster~RCNN Faster RCNN 检测人体目标，然后裁剪相应目标图像块，使用姿态估计器定位关键点，并且对相应提议重新打分。 2.1、人体检测 使用空洞卷积替代的 R e s N e t − 101 ResNet-101 ResNet−101 作为 F a s t e r R C N N Faster~RCNN Faster RCNN 检测器网络主骨，输出步长等于 8 8 8 像素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e56023bc7655cd5a0a52df53e44c2408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9595845fc7068aaf9a3a642c7eb692/" rel="bookmark">
			【C&#43;&#43;】C&#43;&#43;的true和false
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其他文章：
【C++演示】编程语言的true、false和1、0之间的相互转化
【JAVA】Java的boolean 和 int互相转换 ——Java的true、false和1、0之间的相互转化
int main() { if (true==1) cout&lt;&lt;"true"; else cout &lt;&lt; "false"; } result：true
int main() { if (1==true) cout&lt;&lt;"true"; else cout &lt;&lt; "false"; } result：true
int main() { if (true==112) cout&lt;&lt;"true"; else cout &lt;&lt; "false"; } result：false
int main() { if (112==true) cout&lt;&lt;"true"; else cout &lt;&lt; "false"; } result：false
int main() { if (1) cout&lt;&lt;"true"; else cout &lt;&lt; "false"; } result：true
int main() { if (112) cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f9595845fc7068aaf9a3a642c7eb692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6bf3f754171502c8409cd7e01d22f1c/" rel="bookmark">
			sh文件定时删除hbase表中的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先在系统中建一个txt文件；
vi test.txt
然后在test文件中添加要执行的hbase shell语句
truncate test
exit
（hbase 命令执行后不会自动退出，所以执行exit 这个命令强制退出）
2.新建一个.sh文件
vi test.sh
然后在.sh文件中写入
hbase shell /root/test/test.txt（后面的地址要详细的文件地址）
然后执行sh文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e542833f8fa42e33be13de8c8a6b2e0/" rel="bookmark">
			ubuntu——ls-l命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以ubuntu14.04为例
ls -l命令 将某目录以详细列表的形式进行展示
以root的家目录为例
还有个比较常用的命令ll
可以看出ll和ls -l展示的内容差不多，只是ll将隐藏文件展示了出来。
第1字段: 文件属性字段 文件属性字段总共由10个字母组成
第1位字符代表文件的类型。
字母“-”表示该文件是一个普通文件；
字母“d”表示该文件是一个目录，字母”d”，是dirtectory目录的缩写；
其余字母“l”、“b”、“c”、“p”、“s”不是很常用。
第2~4位：表示文档所有者的权限，第2位表示读权限的情况，取值有r和-；第3位表示写权限的情况，w表示可写，-表示不可写，第4位表示执行权限的情况，取值有x和-。
第5~7位：表示与所有者同在一个组的用户的权限情况，第5位表示读权限的情况，取值有r和-；第6位表示写权限的情况，w表示可写，-表示不可写，第7位表示执行权限的情况，取值有x和-。
第8~10位：表示除了上面前2部分的用户以外的其他用户的权限情况，第8位表示读权限的情况，取值有r和-；第9位表示写权限的情况，w表示可写，-表示不可写，第10位表示执行权限的情况，取值有x和-。
第2字段：文件硬链接数 第3字段：文件（目录）拥有者 该字段表示此文件是属于哪个用户。linux类系统都是多用户系统，每个文件都有它的拥有者。只有文件的拥有者才具有改动文件属性的权利。root用户具有改动任何文件属性的权利。对于一个目录来说，只有拥有该目录的用户，或者具有写权限的用户才有在目录下创建文件的权利。
第4字段：文件（目录）拥有者所在的组 一个用户可以加入很多个组，但是其中有一个是主组，就是显示在第4字段的名称。
第5字段: 文件所占用的空间(以字节为单位) 第6字段：文件（目录）最近访问（修改）时间 第7字段：文件(目录)名 小结：
在日常开发与运维的过程中，我一般都是用ll命令查看一下某文件的修改时间。比如系统快要上线了，把项目war放到服务器上去，通过scp命令上传到服务器后，到所在目录执行ll命令，看一下该war文件的更新时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05818ff19b27283ced442b92fee4d673/" rel="bookmark">
			SAS描述性统计分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用proc means描述数据 可以用proc means查看一些简单的统计量，Means过程开始于关键词proc means，后面接需要打印的统计量，基本形式：
PROC MEANS options;
如果不加选项，则默认打印出非缺失值个数、均值、标准差、以及最大最小值，下面是用选项可以查看的统计量：
BY variable-list; 分变量单独分析，但数据必须先按照variable-list的变量顺序排序（proc sort）。CLASS variable-list; 也是分变量单独分析，看起来会更集中一些，且不需要排序。VAR variable-list; 指定分析中使用哪种数值变量，默认则使用所有的数值变量 下面的代码读取数据，计算新变量销售月份month，并使用proc sort按照月份排序，并使用proc means的by语句来按照月份描述数据： 输出结果为：
将描述性统计写入SAS数据集中
有两种方法可以在SAS数据集中储存描述性统计量，Output Delivery System(ODS)，或者output语句。后者的基本形式为：OUTPUT OUT=data-set output-statistic-list;
要描述数据，每个顾客只有一个观测值，包括SUM和MEAN，并且将结果储存到数据集中以便日后分析。下面的程序读取程序，按照CustomerID排序，使用means过程，结果存在totals数据集中。以原始名Petunia,SnapDragon,Marigold给出sum，以新变量名MeanPetunia,MeanSnapDragon,and MeanMarigold给出mean。
结果如下：
二、用proc freq为数据计数 使用proc freq最明显的目的是现实分类数据的分布情况，基本形式为：
PROC FREQ;
TABLES variable-combinations;
建立两个变量的交叉表需要一个*号，下面的语句显示变量Sex by YearsEducation的频数情况：TABLES Sex*YearsEducation;
这个语句之后可以用/option的形式添加选项，主要下面几个：
LIST：用list形式打印交叉表（而不是网格）
MISSING：频率统计量中包含缺失值
NOCOL：强制在交叉表中不打印列百分比
NOROW：强制在交叉表中不打印行百分比
OUT=data-set：输出数据集
比如说，使用第二个选项：TABLES Sex*YearsEducation/MISSING;
例子 有一家咖啡店的销售数据，记录了销售的咖啡种类（cappuccino,espresso,kona,or iced coffee），以及每次购买的顾客是打包还是原地就饮：
下面的代码就产生了一个one-way和two-way的频率表：
代码告诉SAS打印两个表，一个是one-way的频率表，一个是交叉表。交叉表的每个小方格内，SAS打印了频数、百分比、行百分比和列百分比。左边和右边是累积百分比。注意计算频数时没有考虑缺失值。
三、用proc tabulate产生一个表格报告 比起print means和print freq，Proc tabulate过程产生的报告更耐看。Proc tabulate的基本形式为：
PROC TABULATE;
CLASS classification-variable-list;
TABLE page-dimension,row-dimension,column-dimension;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05818ff19b27283ced442b92fee4d673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f7fdc2b18c2a9db67c83053bc46f94/" rel="bookmark">
			HTTPS证书安装无效的原因都有哪些 ？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS是什么？ HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。
HTTPS相当于在HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。
HTTPS作为一种全新的安全协议，对网站本身以及访问网站的网友都有着更好的安全性，防止隐私泄露。
对于站长来说，HTTPS可以避免第三方窃听或阻断流量，保护用户的隐私和安全，提升口碑。此外，谷歌开始针对启用HTTPS网站给予更高的搜索引擎权重，可以提升网站流量。另外HTTPS能够更好的保护网站数据独享，在如今这个大数据时代，数据就是财富。
对于网友来说，访问启用HTTPS安全通道的网站，隐私和安全更有保障。
对于https证书安装无效的主要原因可能由以下几点造成的。 1、自签名https证书若得祸
网站出现”https证书不受信任”可能是网站使用了自签名证书。自签名证书是一种自己生成的https证书，没有通过合法第三方CA机构审核签发，任何人都可以生成(包括钓鱼网站)，很容易被仿冒和伪造，容易受到中间人攻击，存在较大的安全风险，同时浏览器也不信任自签名证书，所以部署了自签名证书的网站会出现”https证书不受信任”。
2、https证书兼容性不够好
并非所有的CA机构签发的https证书都是全球通用支持所有浏览器的。如果该CA机构没有通过国际WebTrust认证，那么他签发的https证书很多浏览器都不信任，比如IE浏览器等。网站在申请购买https证书时一定要选择通过国际WebTrust认证的CA机构。
3、https证书没有正确部署
如果网站的https证书没有正确的部署，在访问的时候也会有一些风险提示，比如https页面中存在http资源的调用，部分版本的浏览器就会提示该页面存在不安全因素。这时只需要将这些http调用资源改为https调用即可解决。
4、浏览器指定不信任的https证书
有的证书颁发机构由于某些原因，已经被浏览器列入”黑名单” ，公开宣布将不再信任其签发的https证书。所以当你访问到部署了这些证书的网站时，部分浏览器比如谷歌、火狐会提示”https证书不受信任”
以上由SSL盾现编整理发布，希望本文可以给您帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf103fe3103263d4407f0d30cc8c4b17/" rel="bookmark">
			算法研究的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法研究的步骤
1. 决定一个完整和具体问题陈述，包括确定问题和API固有的基本抽象操作；
Decide on a complete and specific problem statement, including identifying fundamental abstract operations that are intrinsic to the problem and an API.
2. 仔细为一个简单的算法开发一个简明的实现，使用静心设计的开发客户端和真实的输入数据。
Carefully devlelop a succinct implementation for a straightforward algorithm, using a well-though-out development client and realistic input data.
3. 要知道当一个实现不能用于解决按照设想规模的问题，这个实现必须被优化或者被抛弃；
Know when an implementation could not possibly be used to solve problems on the scale contemplated and must be improved or abandoned.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf103fe3103263d4407f0d30cc8c4b17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/354569f15a0c8ba3d92a75e86a8e18e5/" rel="bookmark">
			阿里云Linux系统搭建Docker容器部署MySQL【亲测】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装部署Docker容器 第一步：查看系统要求删除旧版本要求 CentOS 系统的内核版本高于 3.10 #查看内核版本 uname -a #删除旧版本 yum remove docker docker-common docker-selinux docker-engine 第二步：安装所需依赖、设置Docker yum源
sudo yum install -y yum-utils device-mapper-persistent-data lvm2 安装驱动依赖 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo #设置docker镜像源 第三步：查看所有仓库中所有docker版本并安装
yum list docker-ce --showduplicates | sort -r # 可以查看所有仓库中所有docker版本,并选择特定的版本安装。 sudo yum install docker-ce # 安装 由于repo中默认只开启stable仓库，故这里安装的是最新稳xxxxx.centos如果要安装特定版本： sudo yum install docker-ce-18.06.1.ce 第四步：快捷键设置
[root@MrYu Download]# systemctl enable docker 设置为开机启动 [root@MrYu Download]# systemctl start docker 启动 [root@MrYu Download]# systemctl status docker 查看启动状态 ● docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/354569f15a0c8ba3d92a75e86a8e18e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25a3604f755884d5030478d07a55eea4/" rel="bookmark">
			WHUCTF easyphp代码审计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON 数据结构介绍：
按照最简单的形式，可以用下面这样的 JSON 表示 “名称 / 值对” ：{ "firstName": "Brett" } 等效的纯文本为firstName=Brett
但是，当将多个"名称 / 值对"串在一起时，JSON 就会体现出它的价值了。首先，可以创建包含多个"名称 / 值对"的 记录，比如：
{ "firstName": "Brett", "lastName":"McLaughlin", "email": "aaaa" }。从语法方面来看，这与"名称 / 值对"相比并没有很大的优势，但是在这种情况下 JSON 更容易使用，而且可读性更好。例如，它明确地表示以上三个值都是同一记录的一部分；花括号使这些值有了某种联系。
WHUCTF easyphp
首先这道题要先传入一个COOKIE,且COOKIE值为admin.后再admin中匹配{"hash": [\w\"]+}$
发现不存在COOKIE值，于是添加Cookie: admin={“hash”: 0}
发现了给了个提示，且提示的数字是**00111000100001100101001001000101**这个数字也就是ord(MD5($flag)[$i]
发现要判断这个是否相等($session_data['hash'] != strtoupper(MD5($flag)))，相等则继续进行。hash和MD5可以使用弱类型绕过。而后半部分的strtoupper(MD5($flag))这个值是固定的所以可以使用bp对hash值爆破。
当hash值为82时成功绕过。
后半部是一个反序列化的问题。构造ROP(返回导向编程)。即可执行cat ./flag.php成功获取flag
构造如下：
&lt;?php class WHUCTF { protected $stu; function __construct() { $this-&gt;stu = new Evil(); } function __destruct() { $this-&gt;stu-&gt;action(); } } class Evil { function action() { system('cat .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25a3604f755884d5030478d07a55eea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e93357a5d8002664f5c2215adda07f0/" rel="bookmark">
			Java Swing 如何关闭当前窗口？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写swing项目的时候，发现窗体关闭是一个比较烦，因为每次一关闭某一个窗口，就会导致所有的窗口全部关闭，这种很明显不是很符合我们的真正的需要，所以经过一系列的摸索发现，成功解决了一问题。下面主要写下如何解决该问题的方法：
主界面主要是有两个JButton，一个是通过按钮事件调起另一个JFame，另一个是关闭当前窗体。
// 设置按下右上角X号后关闭 jFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); 首先，关闭当前窗体不能使用setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)方法，可以使用setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
其次，通过JButton事件不能使用exit（），这样会使得整个程序的窗体全部关闭，推荐使用dispose（）；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d90da7752b61d8fb95d792ebb2af5053/" rel="bookmark">
			解决百度地图SDK报错问题  鉴权错误信息 errorcode: 230
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用百度地图SDK的应用需要申请应用（AK） 官网网址为：http://lbsyun.baidu.com/apiconsole/key/create
如图下：
需要获取开发版本SHA1和发布版本SHA1，参考文章：
https://blog.csdn.net/Sunxiaolin2016/article/details/91042117
将AK加入到AndroidManifest.xml中：
&lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="xqTGl9SjZUQdfd1231acCfgzLHxuRuPmQr" /&gt; 2.依旧会报AK错误 报错信息如下：
2019-06-04 12:38:23.198 3677-3677/baidumapsdk.demo E/baidumapsdk: Authentication Error ============================================= ----------------- 鉴权错误信息 ------------ sha1;package:D2:1F:93:FE:B4:0F:BE:7A:68:11:2C:50:74:44:DC:79:18:56:28:C5;baidumapsdk.demo key:xqTGl9SjZUQKP1acCfgzLHxuRu2KPmQr1 errorcode: 200 uid: -1 appid -1 msg: APP不存在 请仔细核查 SHA1、package与key申请信息是否对应，key是否删除，平台是否匹配 errorcode为230时，请参考论坛链接： http://bbs.lbsyun.baidu.com/forum.php?mod=viewthread&amp;tid=106461 ============================================= 此时已经确认填入了正确的AK。
原因是Android Studio在Run的时候编译的apk没有带发布版的签名。所以填入了正确的AK后，还是报错。
所以需要在Run app时运行带正式签名的apk，即我们发布版本时创建的签名。
方法如下：
在项目设置中，项目右键，Open Module Settings --&gt;Signing Configs.
填入我们创建的发布版签名文件。
这是build.gradle中会生成：
signingConfigs { debug { storeFile file('C:\\Users\\ad\\BaiduDemo.jks') storePassword '123456' keyAlias = 'key0' keyPassword '123456' } } 修改完成后，需要Clean Project.一定要Clean一下。在运行，成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b55bdf7ca46d3d185caf98dbbe7ce6/" rel="bookmark">
			path.join()和path.resolve()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		path.join() path.join():方法使用平台特定的分隔符[Unix系统是/，Windows系统是\ ]把全部给定的 path 片段连接到一起，并规范化生成的路径。若任意一个路径片段类型错误，会报错。
例如：
__dirname // __dirname返回当前文件所在的绝对路径 const path = require('path'); const path1 = path.join(__dirname, '/foo'); const path2 = path.join(__dirname, './foo/bar'); const path3 = path.join('/foo', 'bar', '/baz/apple', 'aaa', '..'); const path4 = path.join('foo', 'bar', 'baz'); console.log(path1); console.log(path2); console.log(path3); console.log(path4); // 输出结果 /Users/xiao/work/test/foo /Users/xiao/work/test/foo/bar /foo/bar/baz/apple foo/bar/baz 不合法的字符串将抛出异常
const path5 = path.join('foo', {}, 'bar'); // TypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string. Received type object 如果连接后的路径字符串是一个长度为零的字符串，则返回 ‘.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81b55bdf7ca46d3d185caf98dbbe7ce6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c2e1884ca120d39cbbad25fd94727a/" rel="bookmark">
			python中的阻塞线程和非阻塞线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python中的阻塞线程和非阻塞线程
join( ) 阻塞主线程 join() 作用为阻塞主线程,即在子线程未返回的时候,主线程等待其返回然后再继续执行join不能与start在循环里连用 以下为错误代码,代码创建了5个线程,然后用一个循环激活线程,激活之后令其阻塞主线程
threads = [Thread() for i in range(5)] for thread in threads: thread.start() thread.join() 执行过程:
1. 第一次循环中,主线程通过start函数激活线程1,线程1进行计算
2. 由于start函数不阻塞主线程,在线程1进行运算的同时,主线程向下执行join函数
3. 执行join之后,主线程被线程1阻塞,在线程1返回结果之前,主线程无法执行下一轮循环
4. 线程1计算完成之后,解除对主线程的阻塞
5. 主线程进入下一轮循环,激活线程2并被其阻塞
如此往复,可以看出,本来应该并发的五个线程,在这里变成了顺序队列,效率和单线程无异
join的正确用法：使用两个循环分别处理start和join函数，即可实现并发
threads = [Thread() for i in range(5)] for thread in threads: thread.start() for thread in threads: thread.join() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4b06d6888825c3b17501abd96259d5/" rel="bookmark">
			matlab输出原始图像和修改图像像素的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cover = imread('s3898.pgm'); %原始图像路径 stego = imread('ad3898.pgm');%修改图像像素后的图像路径 figure; subplot(1, 2, 1); imshow(cover); title('cover'); subplot(1, 2, 2); imshow((double(stego) - double(cover) + 1)/2); title('embedding changes: +1 = white, -1 = black'); %fprintf('\n\nImage embedded , change rate: %.4f, distortion per pixel: %.6f\n',sum(cover(:)~=stego(:))/numel(cover)); fprintf('change bits %d \n', sum(cover(:)~=stego(:))) 输出对比
change bits 1991 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c79ea8a573622f84a8c3d3551dbf99cd/" rel="bookmark">
			golang语言sql Rows转化保存成map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们用sql查出数据时，第一个问题当然是如何将rows转成map集合了 ，不多说直接上代码
func DoQuery(db *sql.DB, sqlInfo string, args ...interface{}) ([]map[string]interface{}, error) { rows, err := db.Query(sqlInfo, args...) if err != nil { return nil, err } columns, _ := rows.Columns() columnLength := len(columns) cache := make([]interface{}, columnLength) //临时存储每行数据 for index, _ := range cache { //为每一列初始化一个指针 var a interface{} cache[index] = &amp;a } var list []map[string]interface{} //返回的切片 for rows.Next() { _ = rows.Scan(cache...) item := make(map[string]interface{}) for i, data := range cache { item[columns[i]] = *data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c79ea8a573622f84a8c3d3551dbf99cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a43af097bca11b42e8a0f867975c3eb/" rel="bookmark">
			架构师职位常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、架构师的日常职责是什么 ？ 总体而言，架构师负责软件领域的顶层设计。 架构师需要根据公司的发展，规划企业未来若干年的架构，制定可落地的架构方案，解决技术难题，做技术选型与攻关，落地具体的架构。优秀的架构师既能做架构方案，也能写具体的架构代码。
二、开发工程师和架构师有何区别？ 工作重点不同：架构师重点在于前期的架构规划，需要制定可落地的架构方案，结合公司的业务场景、团队的技术水平等因素做技术选型，解决技术难题等等；而开发工程师重点在于具体的落地，特别的， 开发工程师的工作重点落地具体的功能。
能力要求不同：架构师要求比较高，要有架构的广度、深度，需要掌握一系列的架构技术栈，要求有架构实战经验，要有很强的系统分析、系统架构、系统设计的能力。 开发工程师主要是要求熟悉基本的技术栈，熟悉相关业务，快速落地产品的相关功能。
三、 如何走上架构之路？ 首先要有架构师的思维，对分布式、高并发、高性能、高可用、可扩展、松耦合、高内聚、可复用、系统边界、安全等方面有深刻的理解 。技术面要广，熟悉架构技术栈，比如:熟悉微服务，缓存，分布式消息中间件，分布式任务中间件，数据层中间件，分布式监控中间件，网关中间件，分布式配置中心等等，并不是所有的技术栈要非常精通，但重要的技术，一定要掌握得非常深 。注重架构技术实践，这是开发童鞋非常缺失的。建议多和架构师多交流，多落地相关技术的实践，集中火力多实战成长会很快的。理论看100遍，不如实践一遍。 掌握好uml,提升个人系统分析、系统架构、系统设计、画业务架构图、技术架构图、写架构方案等方面的能力 。从架构思维，架构技术栈，架构职责等角度写好一份架构师的简历，重点突出个人掌握的架构技术栈，重点突出项目的架构亮点，难点 。在企业内部转架构，或者去别的企业转型架构。架构面试方面多实践，如果没经验，可以让架构师老司机们多模拟面试几轮。 四、业务架构师与基础架构师区别 对于java程序猿而言，架构师分为业务架构师，基础架构师两大类，从高级开发转成业务架构师，难度小，出成绩快。业务架构和基础架构有70%是一样的，那就是都要求有架构能力，剩下的30%是业务架构要求熟练掌握业务，制定架构方案，架构落地，基础架构则是100%要求纯技术。短期而言，看似基础架构更风光，其实不然。业务架构发展前景更好一些，因为35岁以后，拼的是综合能力，不再是纯架构能力。业务架构要求有更好的沟通能力，架构规划，架构落地能力，一定的行业业务背景，甚至管理能力，所以从业务架构更容易做到技术总监或cto。如果一直做基础架构，那么可能是首席架构师。一般的架构老司机是业务架构，基础架构通吃的，好就业，到什么山唱什么歌。
五、 UML对系统架构重不重要？ UML是架构基本功，但又容易被开发童鞋忽视。架构师要有很强的系统分析，系统架构，系统设计，架构表达能力，通过掌握UML，提高这些能力。业务架构师 通过 UML可以抽象出业务平台的核心用例，可以把复杂的业务流程以分析模型表达清楚，高阶设计阶段，利用包图，组件图，部署图把设计，部署表达清楚。基础架构师设计中间件，可以画uml协作图，或活动图表达技术功能的流程，设计阶段，可以画包图，表达各个包的功能，然后多人可以一起撸技术中间件的具体代码，做具体架构落地。
六、Springcloud和Dubbo用哪个？ Dubbo相对而言，成熟稳定，文档齐全门槛低一些，但是很多服务治理方面的功能是缺失的。Springcloud大而全，但很多功能不强大，不成熟。长期而言，个人更看好Spring cloud,虽然目前还有一些坑，而且门槛也比Dubbo高，但整体发展趋势比Dubbo强，Spring cloud生态体系比Dubbo更好，功能更全面。掌握Dubbo和Spring cloud是不冲突的，二者有很多相同的地方，又有很多地方不同。
七、分布式定时任务和一般的任务都什么区别？ 分布式定时任务一般是多台服务器可以同时跑定时任务，效率要比一般的任务高，可用性要比一般的任务高(可以做失效转移，架构上没有单点问题，任务节点可以监控)，性能要比一般任务的强（架构是强伸缩性，多台机器一起运行，执行时间要短），支持的并发能力远远超过一般的任务（多台机器执行，可以把海量数据分配给不同的机器执行，并发能力非常好）。
八、高并发和高性能的区别和联系是什么？ 简单而言，高并发是访问数量，高性能是访问响应时间，两个不同的角度。 并发量化的常见参数指标，qps,tps等等，性能量化指标一般是处理时间，比如:接口响应时间是10ms和5分钟，性能是完全不一样的。qps为100和qps为50万的并发架构完全不一样。如果架构不合理，并发量越大，性能越差。如果架构合理，并发量的大小对性能基本没影响，加机器即可，软件架构不需要任何改变。
九、为啥项目经理在国内其实是很危险的职业？ 项目管理其实没啥含金量，项目经理工作替代性其实很强，可以被产品经理，技术经理，核心开发等干系人替代。特别是到中年以后，项目经理很难找到合适的工作。
十、reactor线程指的是reactor模型中的哪个部分？ 这个问题本身是有问题的。 reactor线程模型分为单线程，多线程，主从多线程。 实际编程过程中，第二种用的是最多的，
十一、消息中间件目前使用频率最大是RabbitMQ吗？ 技术选型是从技术的使用场景，优缺点等方面综合评估的。很多企业用RocketMQ和kafka,大数据基本100%选kafka.
十二、 服务限流有哪些算法？ 服务限流常见算法有并发计数器算法，漏桶算法，令牌桶算法。前两种算法不支持突发流量的限流，令牌桶算法支持突发流量的限流。 一般用谷歌guava落地令牌桶算法，用sentinel作为服务限流的中间件。
十三、 数据同步有哪些方式 ？ 这个问题其实涉及到很多场景的。 如果是数据库方面的，可以用SqlLoader、GoldenGate等相关工具同步数据； 大数据方面的，可以用ETL、Hadoop等相关技术同步数据；如果是定时调度发起的，可以考虑用SpringBatch，Quartz，Elastic-Job等分布式任务中间件发起同步数据；如果是异步的场景，可以用mq来实现监听并且同步增量数据。 大批量的数据情况下，尽可能地考虑用mq、线程池、多线程、数据批量操作等相关技术手段提升性能。
十四、上亿数据如何大规模更新 ？ 可以用分布式任务调度中间件的大任务分片来做，把上亿的数据分给多台机器来做。 如果实时性要求不高，完全可以设置一定的时间间隔，减少DB压力；如果实时要求高，数据层需要分库。如果每天增量数据较多，可以考虑周期性地做数据归档。
十五、dubbo是否有什么缺陷 dubbo缺陷很多呀，特别是服务治理方面，服务限流算法有缺陷，突发流量有问题的，服务熔断才刚刚有，但也有缺陷，监控方面只支持点到点的监控，不能做到分布式链路监控，没有服务网关，服务分组能力太弱。dubbo性能还有提升的空间，编解码不支持messagpack，通信方式有待改进。监控中心功能太简单，监控中心和管理后台没有整合。dubbo才刚刚和springcloud打通，支持还不是很友好。
十六、在分布式环境下，如何防止RocketMQ消息重复消费？ 消费方可以基于分布式锁来解决rocketmq的消息幂等性的问题。用分布式锁可以从纯技术角度messageid,或者业务角度业务主键唯一性都可以实现rocketmq消息消费的幂等性。另外，rocketmq生产方发送消息，本身就保证了消息的幂等性，主要是消费方消费消息要保证幂等性。
十七、MongoDB和Redis有什么区别？ 定位不一样，前者是基于分布式文件存储的数据库，后者是缓存，很多公司是禁止把redis当数据库来使用的，一般而言，有经验的架构团队会规定把缓存失效时间至多设置为7天。超过7天，再重新生成热点数据。
十八、rocketmq是否会丢消息 rocketmq一般是不会丢消息，所谓的rocketmq丢消息，有两种常见的原因，1、开发童鞋写的消费者代码逻辑有bug,比如，消费消息的代码逻辑有异常，却把异常吃掉了，且返回成功的状态，人为的导致丢消息。2、运维层面有问题，把消息写到分布式存储有问题，导致丢消息。 这两种情况导致所谓的丢消息，以第一种居多，有不少开发童鞋会犯第一种错误。
十九、Spring cloud 和dubbo用哪个？ dubbo相对而言，成熟稳定，文档齐全门槛低一些，但是很多服务治理方面的功能是缺失的。spring cloud大而全，但很多功能不强大，不成熟。长期而言，个人更看好spring cloud,虽然目前还有一些坑，而且门槛也比dubbo高，但整体发展趋势比dubbo强，spring cloud生态体系比dubbo更好，功能更全面。掌握dubbo和spring cloud是不冲突的，二者有很多相同的地方，又有很多地方不同。并且阿里技术团队开发了spring-cloud-alibaba，为dubbo向spring-cloud靠拢，整合做了技术准备。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a43af097bca11b42e8a0f867975c3eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43914ef992ee4b22b3ab0f9c61ae5dad/" rel="bookmark">
			论文笔记：OpenPose（Realtime Multi-Person 2D Pose Estimation using Part Affinity Fields）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Realtime Multi-Person 2D Pose Estimation using Part Affinity Fields 1、主要成果2、算法细节2.1、算法原理2.2、实现细节2.2.1、网络结构2.2.2、损失函数2.2.3、GT 置信图生成2.2.4、PAFs 生成2.2.5、PAFs 多人分析2.2.6、结果 3、总结4、感想 1、主要成果 提出将人体部位与个体联系起来的非参数化方法— P A F s PAFs PAFs，实现自底向上的实时多人姿态估计，在性能和效率上均实现当时最优的结果。
2、算法细节 2.1、算法原理 首先预测一组图像中人体部位位置的 2 D 2D 2D 置信图 S S S，以及一组表示部位相似性的 2 D 2D 2D 矢量场 L L L，它们表示部位之间的关联程度。集合 S = ( S 1 , S 2 , … , S J ) S=\left(\mathbf{S}_{1}, \mathbf{S}_{2}, \ldots, \mathbf{S}_{J}\right) S=(S1​,S2​,…,SJ​) ， S j ∈ R w × h \mathbf{S}_{j} \in \mathbb{R}^{w \times h} Sj​∈Rw×h， j ∈ { 1 … J } j \in\{1 \ldots J\} j∈{1…J}。集合 L = ( L 1 , L 2 , … , L C ) \mathbf{L}=\left(\mathbf{L}_{1}, \mathbf{L}_{2}, \ldots, \mathbf{L}_{C}\right) L=(L1​,L2​,…,LC​) 有 C C C 个矢量场，每个肢体一个。其中， L c ∈ R w × h × 2 \mathbf{L}_{c} \in \mathbb{R}^{w \times h \times 2} Lc​∈Rw×h×2， c ∈ { 1 … C } c \in\{1 \ldots C\} c∈{1…C}， L c \mathbf{L}_c Lc​ 中的每个图像位置编码一个 2 D 2D 2D 向量。最后，通过贪婪推理解析置信度图和亲和场，以输出图像中所有人的 2 D 2D 2D 关键点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43914ef992ee4b22b3ab0f9c61ae5dad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c05834ea9277b64774b197367ffa50/" rel="bookmark">
			使用 keepalived 设置虚拟 IP 环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 keepalived 设置虚拟 IP 环境 准备 装备两个机器，IP地址信息如下：
host1： 192.168.56.103 host2： 192.168.56.104 为了测试需要，分别在两个机器上安装 apache 并启动httpd服务，使下面两个url均可访问
- http://192.168.56.103
- http://192.168.56.104
安装 keepalived 在两台机器上分别安装 keepalived
$ sudo yum install -y keepalived 配置 keepalived host1 上 keepalived 配置 $ cat /etc/keepalived/keepalived.conf vrrp_instance VI_1 { state MASTER interface eth2 virtual_router_id 51 priority 101 advert_int 1 authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 192.168.56.105 } } host2 上 keepalived 配置 $ cat /etc/keepalived/keepalived.conf vrrp_instance VI_1 { state MASTER interface eth2 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3c05834ea9277b64774b197367ffa50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c065d460216107907a1783dcce31f3a6/" rel="bookmark">
			（十）linux下使用串口控制语音模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平台：NanoPi fire3
系统：Ubuntu core+Qt5.10（linux kernel 4.4）
语音模块：SYN6288A
模块链接：https://item.taobao.com/item.htm?spm=a1z09.2.0.0.6fa82e8dV9HJVN&amp;id=575307622242&amp;_u=51pfiddhc204
使用引脚信息
串口3对应设备结点/dev/ttySAC3
模块官方给了51单片机的程序，现在修改并移植到linux中运行
修改了其中两个头文件，如下
SYN6288.h
/***************************乐声电子科技有限公司**************************** ** 工程名称：YS-SYN6288语音合成配套程序 **	CPU: STC89LE52 **	晶振：22.1184MHZ **	波特率：9600 bit/S **	配套产品信息：YS-SYN6288语音合成模块 ** http://yuesheng001.taobao.com ** 作者：zdings ** 联系：751956552@qq.com ** 修改日期：2012.8.25 ** 说明：。。 /***************************乐声电子科技有限公司******************************/ #ifndef SYN6288_H #define SYN6288_H #include &lt;stdlib.h&gt; #include "config.h" /**************芯片设置命令*********************/ uint8_t SYN_StopCom[]={0xFD,0X00,0X02,0X02,0XFD};//停止合成 uint8_t SYN_SuspendCom[]={0XFD,0X00,0X02,0X03,0XFC};//暂停合成 uint8_t SYN_RecoverCom[]={0XFD,0X00,0X02,0X04,0XFB};//恢复合成 uint8_t SYN_ChackCom[]={0XFD,0X00,0X02,0X21,0XDE};//状态查询 uint8_t SYN_PowerDownCom[]={0XFD,0X00,0X02,0X88,0X77};//进入POWER DOWN 状态命令 /***********************************************/ /*********************************************************** * 名 称： YS-SYN6288 文本合成函数 * 功 能： 发送合成文本到SYN6288芯片进行合成播放 * 入口参数：Music(背景音乐选择):0无背景音乐。1-15：相关背景音乐 *HZdata:文本指针变量 * 出口参数： * 说 明： 本函数只用于文本合成，具备背景音乐选择。默认波特率9600bps。	* 调用方法：例： SYN_FrameInfo（0，“乐声电子科技”）； **********************************************************/ int SYN_FrameInfo(uint8_t Music,uint8_t *HZdata, unsigned char *buf) { /****************需要发送的文本**********************************/ unsigned char *Frame_Info = buf; unsigned char HZ_Length; unsigned char ecc = 0; //定义校验字节 unsigned int i=0; HZ_Length =strlen(HZdata); //需要发送文本的长度 /*****************帧固定配置信息**************************************/ Frame_Info[0] = 0xFD ; //构造帧头FD Frame_Info[1] = 0x00 ; //构造数据区长度的高字节 Frame_Info[2] = HZ_Length + 3; //构造数据区长度的低字节 Frame_Info[3] = 0x01 ; //构造命令字：合成播放命令	Frame_Info[4] = 0x01 | Music&lt;&lt;4 ; //构造命令参数：背景音乐设定 /*******************校验码计算***************************************/	for(i = 0; i&lt;5; i++) //依次发送构造好的5个帧头字节 { ecc=ecc^(Frame_Info[i]);	//对发送的字节进行异或校验	} for(i= 0; i&lt;HZ_Length; i++) //依次发送待合成的文本数据 { ecc=ecc^(HZdata[i]); //对发送的字节进行异或校验	}	/*******************发送帧信息***************************************/	memcpy(&amp;Frame_Info[5], HZdata, HZ_Length); Frame_Info[5+HZ_Length]=ecc; return 5+HZ_Length+1; //PrintCom(Frame_Info,5+HZ_Length+1); } #endif config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c065d460216107907a1783dcce31f3a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9871bac9ca00c4108082f1b89f038e84/" rel="bookmark">
			Android Edittext焦点处理；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、进入界面EditText自动获取焦点并弹出软键盘； &lt;activity android:name=".activity.SettingPwdActivity" android:label="修改密码" android:screenOrientation="portrait" android:windowSoftInputMode="stateVisible|adjustPan" /&gt; EditText不做任何处理，进入界面会自动或焦；
清单文件中给该Activity设置 android:windowSoftInputMode="stateVisible" ，就会自动弹出软键盘了；
2、进入界面EditText不获取焦点也不弹出软键盘； android:focusable="true" android:focusableInTouchMode="true" 给该EditText的父布局加上以上两个属性就不会自动获取焦点了；让父布局抢走焦点；
清单文件中给该Activity设置 android:windowSoftInputMode="stateHidden"
3、EditText获取焦点和失去焦点的监听： etSearch.setOnFocusChangeListener(new View.OnFocusChangeListener() { @Override public void onFocusChange(View v, boolean hasFocus) { if (hasFocus) { // 获取焦点时 tvCancle.setVisibility(View.VISIBLE); } else { // 失去焦点时 tvCancle.setVisibility(View.GONE); } } }); 4、主动让EditText失去焦点、获取焦点； etSearch.clearFocus(); //让输入框失去焦点 etSearch.requestFocus(); //让输入框获取焦点 附：隐藏软键盘：
public void hideSystemSoftKeyboard(Activity activity){ ((InputMethodManager)activity.getSystemService(Context.INPUT_METHOD_SERVICE)).hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/404/">«</a>
	<span class="pagination__item pagination__item--current">405/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/406/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>