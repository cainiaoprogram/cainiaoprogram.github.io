<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8add9d2d49b325e081217a5e2c9b12ae/" rel="bookmark">
			在 SpringBoot 项目中，如何解决依赖冲突问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Boot项目中，依赖冲突是一个常见的问题，特别是当项目引入多个第三方库或框架时。依赖冲突可能导致编译错误、运行时异常或不可预测的行为。为了解决这些问题，你可以采取一些方法来管理依赖并确保项目中的所有库都能协同工作。
1. 使用Dependency Management插件 Spring Boot提供了spring-boot-dependencies模块，其中包含了一组经过仔细测试和协同工作的依赖关系版本。通过使用spring-boot-dependencies，你可以确保项目中的所有Spring相关依赖都具有兼容的版本。在pom.xml中添加以下依赖：
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;!-- 替换为当前的Spring Boot版本 --&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 这样，你就不需要为每个Spring相关的依赖指定版本号，而是可以直接使用spring-boot-dependencies中定义的版本。
2. 排除依赖 在一些情况下，你可能需要排除特定的依赖以解决冲突。在pom.xml中，你可以使用&lt;exclusions&gt;标签排除特定的传递依赖。例如：
&lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;example-library&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.unwanted&lt;/groupId&gt; &lt;artifactId&gt;unwanted-library&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 这将排除example-library依赖中的unwanted-library。
3. 使用mvn dependency:tree命令 Maven提供了一个非常有用的命令mvn dependency:tree，可以帮助你可视化项目的依赖关系。通过运行此命令，你可以查看项目中所有依赖项及其版本，从而更容易识别潜在的冲突。
mvn dependency:tree 4. 使用mvn dependency:analyze命令 mvn dependency:analyze是另一个有用的Maven命令，它可以帮助你识别不同依赖项版本之间的冲突。运行以下命令：
mvn dependency:analyze 5. 使用dependencyManagement中的&lt;dependency&gt;标签 除了Spring Boot的spring-boot-dependencies，你也可以使用自定义的dependencyManagement中的&lt;dependency&gt;标签来管理项目的所有依赖版本。这样可以确保所有依赖项都使用相同的版本。
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 其他依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;example-library&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 其他依赖 --&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8add9d2d49b325e081217a5e2c9b12ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c27326ce5b085648c45f6c0ae8fdc65/" rel="bookmark">
			如何查找native服务的接口实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以Netd为例：
首先adb看一下服务的接口：
接口文件是INetd，去源码找一下INetd.aidl
已经确定了接口API，对于native服务端的实现，一般的继承顺序为：
根据继承关系，对于BnXxx/XxxService 对象，含有三张虚表
虚表1 虚表1（来自IXxx）
01destructor02destructor03android::BnInterface::onAsBinder(void)04getInterfaceDescriptor()05 ~ (04+n)n个接口 ... ...05+ngetInterfaceVersion(void)06+nqueryLocalInterface(const String16&amp; _descriptor)07+nonTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags) 虚表2 虚表2（来自BBinder）
01queryLocalInterface(const String16&amp; _descriptor)02getInterfaceDescriptor()03android::BBinder::isBinderAlive(void)04android::BBinder::pingBinder(void)05android::BBinder::dump(int,android::Vector&lt;android::String16&gt; const&amp;)06android::BBinder::transact(uint,android::Parcel const&amp;,android::Parcel*,uint)07android::BBinder::linkToDeath(android::sp&lt;android::IBinder::DeathRecipient&gt; const&amp;,void *,uint)08android::BBinder::unlinkToDeath(android::wp&lt;android::IBinder::DeathRecipient&gt; const&amp;,void ,uint,android::wp&lt;android::IBinder::DeathRecipient&gt;)09android::IBinder::checkSubclass(void const*)10android::BBinder::attachObject(void const*,void ,void ,void ()(void const,void *,void *))11android::BBinder::findObject(void const*)12android::BBinder::detachObject(void const*)13android::BBinder::localBinder(void)14android::IBinder::remoteBinder(void) 虚表3 虚表3（来自RefBase）
01destructor02destructor03android::RefBase::onFirstRef(void)04android::RefBase::onLastStrongRef(void const*)05android::RefBase::onIncStrongAttempted(uint,void const*)06android::RefBase::onLastWeakRef(void const*) 下面在IDA中查找其具体API地址。先从手机中CP出system目录，在/system/bin 下面找到netd可执行程序，IDA打开。搜索BnNetd虚表中的函数，直接搜“BnNetd::onTransact”
查找引用定位虚表，一般虚表位于.data.rel.ro节中
定位到.data.rel.ro中的这一项，当虚表顺序满足Bn对象的虚表顺序时，这就是Bn对象的虚表（第二张虚表几乎全为导入函数，辨识度很高）
虚表一：
虚表二：
虚表三：
虚表一中getInterfaceVersion函数上面就是接口函数列表，IDA没有识别为函数，且还需要对该列表进行重命名，写一个IDA脚本来完成：
import idc import ida_funcs import ida_bytes import ida_idaapi ApiLists = ''' android::net::INetdDefault::isAlive(bool *)	.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c27326ce5b085648c45f6c0ae8fdc65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b9b6b3d4dc11afeda220edb9a93ed6/" rel="bookmark">
			JVS低代码与Nacos联手：打造用户满意的个性化首页配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常系统软件都会有首页展示，是用户首次打开系统软件时看到的页面，是用户对软件的第一印象。同时不同的软件类型和目标用户群体对首页的风格和内容会有所差异，JVS低代码平台就可以通过自定义页面引用外部站点来设置成首页，还可以直接在nacos中设置配置文件来切换首页，从而可以提高用户对软件的使用体验，增加用户黏性和满意度。
轻应用首页设置 一、通过自定义页面设置首页 ①：页面名称，输入自定义页面的名称（即在应用目录下的菜单名称）。
②：目标地址，填写完整的url地址。（注意例如百度类的地址，百度是有限制则不支持）
③：描述，页面的描述。
④：图标，可以选择系统预置的图标。
在对应目录下添加完自定义页面，光标放在“...”上点击【设置为首页】选择用户信息中的等级（设置首页需要在用户等级里面，有这样的参数）。最后退出重新登录系统即可查看效果。
二、通过nacos配置文件设置首页 通过修改naocs配置可以设置是否设置【示例首页应用】为默认首页展示：如下图。
设置配置项为true时效果如图：
设置配置项为false时效果如图：
在线demo：https://frame.bctools.cn
开源基础框架：https://gitee.com/software-minister/jvs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d81a57a28b8053b2d45d7101bd342d/" rel="bookmark">
			C&#43;&#43;学习笔记（二十八）：c&#43;&#43; 箭头-＞运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++中-&gt;运算符主要包含两种使用方式，一种是最为常用的用来调用类指针对象的属性和方法，另一种是c++运算符重载。代码示例如下： #include &lt;iostream&gt; class Entity { public: void Print() const { std::cout &lt;&lt; "Hello!" &lt;&lt; std::endl; } }; class ScopeEntity { private: Entity* m_Obi; public: ScopeEntity(Entity* entity) :m_Obi(entity) {} ~ScopeEntity() { delete m_Obi; } Entity* operator-&gt; () { return m_Obi; } const Entity* operator-&gt; () const { return m_Obi; } }; int main() { //-&gt;操作符的使用方式1 const Entity* e1 = new Entity; e1-&gt;Print(); //-&gt;操作符的使用方式2，操作符重载 const ScopeEntity entity(new Entity); entity-&gt;Print(); std::cin.get(); return 0; } 箭头操作符在实际项目中一个简单的使用技巧：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d81a57a28b8053b2d45d7101bd342d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4ac4756240463fb47d5b61f3477fdd/" rel="bookmark">
			干货|为什么选择独立站？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		独立站就像是一个独立的王国，有自己独立的服务器、网站程序和域名。它与依赖平台的模式不同，搭建独立网站可以提供更好的用户体验，建立自己的私域流量，让商家与客户建立更紧密的联系。独立站与第三方平台没有关联，营销渠道更加多样化，可以让商家通过各种方式推广自己的网站，吸引流量和增加品牌知名度。这些流量和品牌知名度都是属于商家的，可以让商家回归经营的本质，创造长期的商业价值。
独立站的优势
01
去中心化，打破规则束缚
电商平台上的价格战和跟卖事件经常发生，导致平台上的卖家竞争激烈，流量被垄断。为了摆脱电商平台的限制和避免第三方平台的收费，去中心化的独立站模式开始受到欢迎。搭建独立站可以让商家自主管控销售环节，没有产品下架的风险和政策限制，也不需要与其他同行争夺流量。跨境电商独立站是商家脱离跨境电商平台，自主建立网站销售自己产品的解决方案。
02
塑造品牌，增强品牌体验
独立站可以让商家根据自己的需求自主设计和优化，比如选择自己的域名、设计网站主页、提升产品详情页的质感和内容更新。当客户进入独立网站后，商家可以通过各种方式进行品牌培育，例如使用文案、视频和品牌介绍等，这有助于提升品牌形象和知名度。通过独立站，商家可以突出自己产品的特点和优势，与竞争对手的产品形成差异化，让消费者更容易记住自己的产品。这有助于打造品牌认知度，提高消费者对商家的信任度。
03
提高回购率
如果商家的店铺想要拥有长期的生命周期，那么客户回购率是非常重要的。首先，产品质量是回购率的基础，只有高质量的产品才能赢得客户的信任和重复购买。此外，商家可以通过独立站中的营销工具来提高回购率。例如，他们可以发展老客户成为店铺的分销员，并鼓励他们介绍亲朋好友给商家。这样可以让独立站获得更多的社交和媒体流量，从而为网站注入更多新的流量，提高销售量和复购转化率。通过这种方式，商家可以更好地推广自己的品牌，并在独立站中产生持续的复购。
04
沉淀数据，促进转化
在大数据时代，数据是非常重要的资源。独立站可以帮助商家获取到客户的所有数据，通过分析这些数据，商家可以更准确地了解客户的消费需求和行为趋势，从而制定更有针对性的营销活动，增强客户黏性。此外，总结用户行为趋势可以帮助商家避免陷入相同的错误策略，更好地制定下一步商业策略，快速迭代并提升用户体验。通过独立站进行的二次营销也可以进一步提高转化率。因此，掌握数据就等于掌握了商业主动权。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6d2d37178022263cd12829029ba503/" rel="bookmark">
			linux添加或扩展swap分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用dd命令创建一个swap交换文件
dd if=/dev/zero of=/home/swap bs=1024 count=4000000 这样就建立一个/home/swap的分区文件，大小为4G。
2.制作为swap格式文件：
mkswap /home/swap 3.再用swapon命令把这个文件分区挂载swap分区
swapon /home/swap 我们用free -m命令看一下，发现已经有交换分区了。
但是重启系统后，swap分区又变成0了。
4.为防止重启后swap分区变成0，要修改/etc/fstab文件
vi /etc/fstab 在文件末尾（最后一行）加上
/home/swap swap swap defaults 0 0 这样就算重启系统，swap分区还是有值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfbd94aa9a711f46afb910d4a38f4026/" rel="bookmark">
			中央处理单元（CPU）学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言
中央处理单元（CPU）是计算机的核心部件，负责执行程序指令和控制整个计算机系统的运行。本篇学习笔记将介绍CPU的功能和组成，帮助读者深入了解CPU的工作原理和重要性。
二、CPU的功能
程序控制：CPU通过执行指令来控制程序的执行顺序，确保程序按照设计的逻辑进行运行。操作控制：CPU产生每条指令的操作信号，并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。时间控制：CPU对各种操作进行时间上的控制，确保指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都得到严格控制。数据处理：CPU通过对数据进行算术运算和逻辑运算等方式进行加工处理，将处理结果提供给其他部件使用。中断响应：CPU需要对系统内部和外部的中断（异常）做出响应，并进行相应的处理，保证系统的稳定性和可靠性。 三、CPU的组成
运算器：由算术逻辑单元（ALU）、累加寄存器（AC）、数据缓冲寄存器（DR）和状态条件寄存器（PSW）等组成。ALU实现对数据的算术和逻辑运算，AC用于存放运算结果或源操作数，DR暂时存放内存的指令或数据，PSW保存指令运行结果的条件码内容，如溢出标志等。控制器：由指令寄存器（IR）、程序计数器（PC）、地址寄存器（AR）和指令译码器（ID）等组成。IR暂存CPU执行指令，PC存放指令执行地址，AR保存当前CPU所访问的内存地址，ID分析指令操作码。控制器负责控制整个CPU的工作，是CPU最重要的组成部分。寄存器组：包括通用寄存器、段寄存器和标志寄存器等。通用寄存器用于临时存储数据和地址，段寄存器保存程序的分段信息，标志寄存器保存各种状态标志位。内部总线：连接运算器、控制器和其他部件的内部数据传输通道。内部总线负责在各个部件之间传输数据和控制信号。 四、CPU的工作原理
指令周期：CPU根据指令周期的不同阶段来区分二进制的指令和数据。指令周期包括取指阶段、译码阶段、执行阶段和写回阶段。在取指阶段，CPU从内存中取出指令并将其存入指令寄存器；在译码阶段，指令译码器分析指令的操作码；在执行阶段，根据指令的要求进行相应的操作；在写回阶段，将执行结果写回内存或其他寄存器。流水线技术：为了提高CPU的处理速度，采用了流水线技术。流水线技术将指令的执行过程划分为多个阶段，并同时进行多个阶段的处理，以提高并行度和效率。缓存机制：为了加快数据的访问速度，CPU引入了缓存机制。缓存分为三级缓存，分别是一级缓存（L1）、二级缓存（L2）和三级缓存（L3）。一级缓存位于CPU内部，二级缓存位于CPU与内存之间，三级缓存位于主板上。缓存机制可以减少对内存的访问次数，提高数据的读取速度。多核处理器：为了进一步提高计算能力，现代计算机通常采用多核处理器。多核处理器将多个独立的处理器核心集成到一个芯片上，每个核心都可以独立执行指令。多核处理器可以同时处理多个任务，提高系统的并发性能。 五、总结
中央处理单元（CPU）是计算机的核心部件，负责执行程序指令和控制整个计算机系统的运行。它由运算器、控制器、寄存器组和内部总线等部件组成。CPU的功能包括程序控制、操作控制、时间控制、数据处理和中断响应等。了解CPU的工作原理和组成对于理解计算机系统的运行机制非常重要。通过不断学习和实践，我们可以更好地掌握CPU的知识，为计算机科学的发展做出贡献。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26aa8b84753dc7778d9e00d4f227a789/" rel="bookmark">
			oracle的SYSAUX表空间满了怎么处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		清理SYSAUX表空间：
创建临时表，保存近8天的数据 create table test.ash_bak_20220119 as select * from sys.WRH$_ACTIVE_SESSION_HISTORY where SAMPLE_TIME&gt;=sysdate-9; SQL&gt; select count(*) from test.ash_bak_20220119; COUNT(*) ---------- 12648 1 row selected. 禁用AWR exec dbms_workload_repository.modify_snapshot_settings(interval =&gt; 0); truncate WRH$_ACTIVE_SESSION_HISTORY TRUNCATE TABLE sys.WRH$_ACTIVE_SESSION_HISTORY; truncate 完成后，重建 WRH$_ACTIVE_SESSION_HISTORY表的索引，并从备份表恢复数据 insert into sys.WRH$_ACTIVE_SESSION_HISTORY select * from test.ash_bak_20220119; commit; 查看索引状态(USABLE是未失效，UNUSABLE是失效) set line 300 pages 200 col owner for a20 col index_name for a30 select index_owner, index_name, partition_name, status, tablespace_name, last_analyzed from dba_ind_partitions where index_name in (select index_name from dba_indexes where table_name in ('WRH$_ACTIVE_SESSION_HISTORY') and table_owner = 'SYS'); INDEX_OWNER	INDEX_NAME	PARTITION_NAME	STATUS TABLESPACE_NAME	LAST_ANAL ------------------------------ ------------------------------ ------------------------------ -------- ------------------------------ --------- SYS	WRH$_ACTIVE_SESSION_HISTORY_PK WRH$_ACTIVE_3552434506_0	USABLE SYSAUX	04-DEC-21 SYS	WRH$_ACTIVE_SESSION_HISTORY_PK WRH$_ACTIVE_SES_MXDB_MXSN USABLE SYSAUX	07-FEB-20 如果索引失效重建索引（测试的时候是没有失效的，索引为本地索引） ALTER INDEX SYS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26aa8b84753dc7778d9e00d4f227a789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6662e3069a5474ea922e7ededf507060/" rel="bookmark">
			用h5写一个旋转的动态页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建一个旋转的动态页面需要使用HTML5的canvas元素和JavaScript。以下是一个简单的示例，展示了如何创建一个在页面上旋转的动态效果。
首先，创建一个HTML文件并添加以下内容：
html复制代码
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;旋转的动态页面&lt;/title&gt; &lt;style&gt; body { margin: 0; padding: 0; background-color: #f0f0f0; } canvas { position: absolute; left: 50%; top: 50%; transform-origin: 0 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="myCanvas" width="400" height="400"&gt;&lt;/canvas&gt; &lt;script src="script.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 接下来，创建一个JavaScript文件（例如script.js）并添加以下内容：
javascript复制代码
const canvas = document.getElementById('myCanvas'); const ctx = canvas.getContext('2d'); const angle = 0; const centerX = canvas.width / 2; const centerY = canvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6662e3069a5474ea922e7ededf507060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af12e937e10bdc95c86e760d5e8f024/" rel="bookmark">
			AI ppt生成器 Tome
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍
一款 AI 驱动的 PPT/幻灯片内容辅助生成工具。只需要输入一个标题或者一段特定的描述，AI 便会自动生成一套包括标题、大纲、内容、配图的完整 PPT。
Tome平台只需要用户输入一句话，就可以自动生成完整的PPT，包括文字和图片。功能非常强大，可以极大地提高制作PPT的效率。
Tome平台还提供了丰富的模板库、自定义设计、大量的素材库和多语言支持等功能，使得用户可以根据自己的需求和风格制作出高质量的PPT。
Tome | Polished &amp; Professional AI Presentations
功能 将文字描述，通过AI生成文字内容和AI插图，自动将其组装成一个完整 的PPT 。
&gt; 提示栏（Prompt Bar）：**可以让你输入任何想法或问题，然后由AI来为你生成完整的故事或者特定的页面。例如，你可以输入“介绍一款新能源汽车”，然后AI就会为你生成一份包含文本和图片的页面。
&gt; DALL-E 2瓦片（DALL-E 2 Tile）：**可以利用AI来创造出任何类型和风格的图片。只需输入一些文字或图标，然后AI就会生成一张图片，并且可以进行细节上的调整。例如，你可以输入“一个骑着独角兽的男人”，然后AI就会为你生成一张符合这个描述的图片，并且可以让你改变男人或独角兽的颜色、大小、位置等。
&gt; 内容类型（Content Types）：**可以让你添加各种类型的内容到你的故事中。可以选择文本、图片、视频、音频、3D渲染、网页嵌入等多种内容类型。
&gt; 网页嵌入（Web Embeds）：**可以让你在你的故事中嵌入任何来自网页的内容\
&gt; 视频录制（Video Recording）：**可以为你的故事添加视频解说。
注册
填入信息后，需要进入邮箱激活。
使用
点击右上角创建按钮进入创作页面输入我们想制作的ppt的主题思想，TomeAi能根据文字理解自动进行创作，生成图文PPT。 我们可以根据自己的爱好定制主题颜色等 它能够完整的制作出针对某个话题的完整演示，并提供一些完全不需要考虑版权问题的原创图片 调整PPT 点击右侧的工具栏按钮，输入或者修改与TomeAi的对话，TomeAi可以根据你的对话生成对应的图片。点击图片可以进行更换。
样式 右侧工具栏可以对整个ppt或者某一页ppt进行风格样式调整
优点：
AI驱动生成PPT内容，中英文描述均支持。支持通过描述生成对应AI图片。允许嵌入文本、图片、视频、书签、网页片段。支持中英文输入。 缺点：
不支持文档导出下载。模版和主题还比较单一。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ee02211747384701d6225a1aedd183/" rel="bookmark">
			html 原生网页使用ElementPlus 日期控件el-date-picker换成中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目： 原生的html,加jQuery使用不习惯，新html页面导入vue3,element plus做界面，现在需要把日历上英文切成中文。
最终效果： 导入能让element plus日历变成中文脚本： elementplus, vue3对应的js都可以通过创建一个vue3项目找到对应的脚本导入）
环境：
&gt;1.node.js
&gt; 2.npm
&gt;3.vue cli ：npm install -g @vue/cli
&gt; 4.vue： npm install vue
## 创建工程vue3 + vite
npm init vite-app &lt;project-name&gt;
## 进入工程目录
cd &lt;project-name&gt;
## 安装依赖
npm install
## 运行
npm run dev ///
安装element-plus
# 选择一个你喜欢的包管理器 # NPM $ npm install element-plus --save # Yarn $ yarn add element-plus # pnpm $ pnpm install element-plus 下载zh-cn.min.mjs： 然后在node_modules对应目录的文件，把它拷贝到html项目即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49ee02211747384701d6225a1aedd183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e572c2289ade3280d17b45da30d38b5/" rel="bookmark">
			C#高级 10 Linq操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Linq操作介绍 Linq操作是C#集成的类似于数据库语言的操作，是通过将数据库的表名映射为类，把数据库的列名映射为属性。 Linq查询主要分为3类： Linq to object(数组、list集合) --内存里面的数据 Linq to sql(查询数据库用的) --在数据库数据 Linq to XML 查询XML文件 这里主要以第一种为例，下面将会直接以代码+注释的方法来展示第一类方式如何使用linQ进行查询。 为方便读者直接复制代码进行运行，就不配置数据库，使用对象的方式来存储数据。下面直接上代码： Kongfu.cs内代码如下：
public class Kongfu { public int Id { get; set; } public string Name { get; set; } public int Power { get; set; } public override string ToString() { return string.Format("id:{0}, name:{1}, power:{2}", Id, Name, Power); } } MartialArtsMaster.cs内代码如下所示：
public class MartialArtsMaster { public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } public string Menpai { get; set; } public string Kongfu { get; set; } public int Level { get; set; } public override string ToString() { return string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e572c2289ade3280d17b45da30d38b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f6b974e43f483b2f60cdeaa831d0ba/" rel="bookmark">
			多国管理中心多语言区块链源码一元夺宝程序仿趣步奕跑/原生计步器/原生人脸识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前后台分开的，后台是TP3.2的框架了，应该是比较老的程序了。
目前把整体UI 改版黄色系风格，集成了一元夺宝程序，用户数据同步趣步，效果看起来很棒，另外加入股票走势图（K线图），目前已经继承人脸识别，对接的百度API，可以在线人脸识别，接入原生计步器，计步效果很好多国管理中心多语言区块链源码一元夺宝程序仿趣步奕跑/原生计步器/原生人脸识别 - 百创网-源码交易平台_网站源码_商城源码_小程序源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df2333699d6081b49e15499ce77c8fdd/" rel="bookmark">
			android系列-init 初始化日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.FirstStageMain //android10\system\core\init\first_stage_init.cpp int FirstStageMain(int argc, char** argv) { // Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually // talk to the outside world... InitKernelLogging(argv);//初始化日志 } 2.InitKernelLogging //android10\system\core\init\util.cpp void InitKernelLogging(char** argv) { SetFatalRebootTarget(); android::base::InitLogging(argv, &amp;android::base::KernelLogger, InitAborter); } 3.KernelLogger //android10\system\core\base\logging.cpp void KernelLogger(android::base::LogId, android::base::LogSeverity severity, const char* tag, const char*, unsigned int, const char* msg) { static int klog_fd = OpenKmsg(); } 4.OpenKmsg //android10\system\core\base\logging.cpp #if defined(__linux__) static int OpenKmsg() { #if defined(__ANDROID__) // pick up 'file w /dev/kmsg' environment from daemon's init rc file //在 Android 中用于获取名为 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df2333699d6081b49e15499ce77c8fdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24810684e4a6c4486d41a2e7e251dcec/" rel="bookmark">
			芯课堂 | 如何配置SWM系列系统时钟？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何配置SWM系列 系统时钟？ 华芯微特科技有限公司SWM系列芯片可通过软件配置改变时钟的速度，可以让我们的设计更加灵活,频率可选空间也更加广泛，用户可以根据自己的实际需求配置需要的系统时钟。为了让用户能够更简单的使用这一功能，下面小编将以SWM190为例，给大家展示如何配置SWM系列产品的系统时钟。
S W M 1 9 0 最大时钟频率可达 60MHz 有5个时钟源可供使用： 01.内部高频振荡器（RCHF）：内部高频振荡器为片内时钟源，无需连接任何外部器件。频率为24MHz或48MHz，通过HRCCR寄存器进行切换，精度为百分之一，可提供较精确的固定频率时钟.
02.内部低频振荡器（RCLF）：内部低频振荡器为片内时钟源，无需连接任何外部器件。频率为32KHz。
03.外部振荡器（XTAH）：外部振荡器可接4~32MHz频率.
04.外部低频振荡器（XTAL）：外部低频振荡器，支持32.768KHz时钟接入
05.PLL：支持RCHF或XTAH作为输入源
我们来看一下时钟系统框图 如图所示： SWM190时钟框图
S W M 1 9 0 时钟配置方法 在SWM190固件库中对时钟频率的选择进行了简化，原先的很多操作都在后台进行。系统给出的函数为SystemInit(void)，可直接调用配置系统时钟，但在调用前还需要进行一些宏定义的设置，具体的设置在system_SWM190.c文件中。
如下：
/* 系统时钟设定 */ #define SYS_CLK_24MHz 0 //0 内部高频24MHz RC振荡器
#define SYS_CLK_3MHz 1 //1 内部高频 3MHz RC振荡器
#define SYS_CLK_48MHz 2 //2 内部高频48MHz RC振荡器
#define SYS_CLK_6MHz 3 //3 内部高频 6MHz RC振荡器
#define SYS_CLK_XTAL 4 //4 外部晶体振荡器（2-30MHz）
#define SYS_CLK_XTAL_DIV8 5 //5 外部晶体振荡器（2-30MHz） 8分频
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24810684e4a6c4486d41a2e7e251dcec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c37a364807e2712df4d83ea9ccc338f/" rel="bookmark">
			Vue2-组件的基本应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人练习，仅供参考。
1.先在components中创建公用的内容（public.vue）。components文件夹下放组件供其他页面调用。
2.在用到组件的页面导入该公用组件（import navTitle from "@/components/public.vue";）。
import 自定义命名 from "@/components/自定义组件"
3.注册组件，在components中注册组件（components: {"nav-title": navTitle,},）。
4.使用组件，&lt;template&gt;&lt;div&gt;在其中插入需要该组件（&lt;nav-title title="热门社区"&gt;&lt;/nav-title&gt;）的位置&lt;/div&gt;&lt;/template&gt;。
5.动态数据采用prop传值（props:["title"，"age",...]），变量接收（&lt;h5&gt;{{ title }}&lt;/h5&gt;），在需要该组件的页面设置传的值（&lt;nav-title title="热门社区"&gt;&lt;/nav-title&gt;）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d51c5cee7668d7c5989c58e30899a25/" rel="bookmark">
			Simpy简介：python仿真模拟库-01/5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 在计算机编程领域，仿真在理解复杂系统、进行实验和做出明智决策方面发挥着关键作用。SimPy 是“Simulation Python”的缩写，是一个功能强大且多功能的仿真框架，允许开发人员和研究人员使用 Python 创建和分析离散事件仿真。无论您是新手还是经验丰富的程序员，SimPy 都提供了一种直观有效的方法来建模和模拟各种场景，使其成为从运筹学到物流、从流行病学到制造等广泛领域不可或缺的工具。本文 是一个关于如何精通 simpy 的内容广泛的系列。 二、什么是 SimPy？ SimPy 是一个开源 Python 库，专为建模和模拟离散事件系统而设计。它提供了用于创建模拟的构建块，使您能够准确地对系统中的时间和事件流进行建模。与变量随时间连续变化的连续模拟不同，离散事件模拟关注在特定时间点发生的事件。这些事件会触发系统中的状态变化，使 SimPy 特别适合涉及离散且通常不可预测的事件的建模过程。
SimPy 的一些主要功能包括：
进程：在 SimPy 中，模拟中的实体表示为进程。这些进程可以是任何事物，例如队列中的人、交通网络中的车辆或计算机系统中的任务。您可以使用 Python 生成器函数定义流程，从而轻松建模复杂的异步行为。事件：事件是 SimPy 建模方法的核心。事件可以安排在特定时间或满足特定条件后发生。您可以创建事件链并通过调度事件来触发系统中的更改来管理模拟中的时间流。资源：在许多模拟中，资源是有限的，需要在不同实体之间共享。SimPy 提供了一个资源类，允许您对资源分配和争用进行建模。这对于数据中心服务器分配或工厂机器分配等建模场景非常有价值。统计和数据收集： SimPy 提供了一系列用于在模拟过程中收集数据的工具。这包括监视事件、跟踪实体在各种状态下花费的时间以及记录其他相关信息。这些统计数据对于分析和理解系统行为至关重要。集成： SimPy 与其他 Python 库和工具高度兼容。您可以将其与 NumPy 和 Pandas 等数据分析库结合使用来分析模拟结果并做出数据驱动的决策。 三、SymPy — 安装 SymPy 有一个重要的必备库，名为mpmath。它是一个用于任意精度的实际复杂浮点运算的 Python 库。但是，当安装 SymPy 时，Python 的包安装程序 PIP 会自动安装它，如下所示 -
pip install sympy import sympy sympy.__version__ Output: '1.12' 四、SymPy — 符号计算 符号计算涉及创建旨在操纵数学表达式和各种数学实体的算法。它融合了数学和计算机科学领域，通过使用数学符号来解析数学表达式。计算机代数系统 (CAS)，如 SymPy，通过利用传统手动技术中使用的符号来精确评估代数表达式。为了说明这一点，请考虑通过 Python 的数学模块计算数字的平方根，如下所示 -
import math print (math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d51c5cee7668d7c5989c58e30899a25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ba9f0442cb8c7a85400afa05128169/" rel="bookmark">
			基于FPGA的RLC测试仪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 系统设计
以FPGA为控制器，实现RLC(电阻、电容、电感)的检测，其测量电路如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7baa057465d629de35e5d783ecd683/" rel="bookmark">
			探索 GitHub：高效使用技巧与实例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索 GitHub：高效使用技巧与实例分享 前言:
欢迎来到本篇博客，今天我们将深入研究 GitHub 的一些高效使用技巧，以便更好地利用这一强大的代码托管平台。
1. GitHub 简介：
GitHub 是全球最大的代码托管平台之一，它不仅提供了代码仓库的管理功能，还包括了问题追踪、版本控制、协作开发等丰富的功能。
2. GitHub 使用技巧与案例：
代码搜索： GitHub的搜索功能支持高级过滤条件，如 language:java、stars:&gt;1000，让我们通过 Java语言、星标超过1000的项目找到优秀的项目。 in
in:name 指定搜索范围是仓库的名称，可以有多个关键字
in:descripttion 指定搜索范围是摘要中
in:readme 指定搜索范围是readme文档中
in:name vue picture//会搜索有vue和picture两个值的仓库名称
stars、forks
stars:&gt; 筛选stars数量大于某个值的仓库
stars:start…end 筛选stars数量在start和end区间的仓库
fork:&gt;
fork:start…end
in:name vue picture stars:&gt;50//搜索stars大于50的开源项目
in:name vue picture stars:800…900//搜索stars在800到900之间的开源项目
language
搜索指定项目的编写语言
in:name vue picture stars:800…900 language:vue//使用vue编写
created、pushed
项目的创建日期和更新日期 in:name vue picture stars:800…900 language:vue pushed:&gt;2021-01-01//2021-01-01后更新的开源项目
README 优化： 编写清晰、详细的 README 文件，提供项目的介绍、使用方法和贡献指南。例如，可以参考 Spring Framework 项目的 README。
分支管理： 合理使用分支，例如主分支用于稳定版本，开发分支用于新功能的开发。具体可参考 Gitflow Workflow。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7baa057465d629de35e5d783ecd683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aca1f1e03448dc34c186ec1758abb20/" rel="bookmark">
			SpringMVC拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、拦截器的配置2、拦截器的三个抽象方法3、多个拦截器的执行顺序4. 书籍推荐《实战AI大模型 李开复 周鸿祎 颜水成 推荐 ChatGPT GPT-4 AIGC》简介目录 SpringMVC拦截器是Spring框架提供的一种机制，用于拦截HTTP请求和响应。它可以让开发者在请求处理前或后执行一些额外的操作，比如日志记录、权限验证、跨域处理等。
拦截器的主要用途包括：
权限控制：拦截器可以在请求到达Controller之前进行权限验证，以确保用户有权访问相应的资源。
日志记录：拦截器可以记录请求的相关信息，如请求路径、参数等，方便后续的跟踪和排查问题。
跨域处理：可以使用拦截器来处理跨域请求，添加必要的响应头信息。
全局异常处理：拦截器可以捕获异常并根据需要进行处理，比如返回统一的错误信息。
通过拦截器，我们可以在请求处理的不同阶段加入自己的逻辑，实现更灵活的业务需求和统一的处理逻辑。
1、拦截器的配置 SpringMVC中的拦截器用于拦截控制器方法的执行
SpringMVC中的拦截器需要实现HandlerInterceptor
SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：
&lt;bean class="com.atguigu.interceptor.FirstInterceptor"&gt;&lt;/bean&gt; &lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt; &lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;mvc:exclude-mapping path="/testRequestEntity"/&gt; &lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt; &lt;/mvc:interceptor&gt; &lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求 --&gt; 2、拦截器的三个抽象方法 SpringMVC中的拦截器有三个抽象方法：
preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法
postHandle：控制器方法执行之后执行postHandle()
afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()
3、多个拦截器的执行顺序 a&gt;若每个拦截器的preHandle()都返回true
此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：
preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行
b&gt;若某个拦截器的preHandle()返回了false
preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行
4. 书籍推荐《实战AI大模型 李开复 周鸿祎 颜水成 推荐 ChatGPT GPT-4 AIGC》 实战AI大模型 李开复 周鸿祎 颜水成 推荐 ChatGPT GPT-4 AIGC
《实战AI大模型》详细介绍了从基本概念到实践技巧的诸多内容，全方位解读AI大模型，循序渐进、由浅入深。书中配有二维码视频，使读者身临其境，迅速、深入地掌握各种经验和技巧。本书还附带了丰富的额外资源：开源工具和库、数据集和模型案例研究和实际应用、在线交流社区等。读者可以综合利用这些资源，获得更丰富的学习体验，加速自己的学习和成长。
人工智能领域资深专家尤洋老师倾力打造，获得了李开复、周鸿祎、颜水成三位大咖鼎力推荐，一经上市就登上了京东“计算机与互联网”图书排行榜Top1的宝座。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aca1f1e03448dc34c186ec1758abb20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43846da41835d24efac73afa7718fddc/" rel="bookmark">
			外贸独立站建站详细操作流程一览，跨境电商卖家营销必看！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		独立站是一个独立的网站，包括有独立的服务器，独立的网站程序以及网站域名。关于独立站的优势已经说了很多，本文就不再细谈，想了解的小伙伴可以自行查找之前发布的文章观看。
今天就来说说搭建独立站的详细步骤都有哪些？
1.给自己的品牌取个好名称：一个好的品牌名称可以说就是一个好的开始。
2.创作一个有特色的品牌logo：建站初期或许因为资金问题不会花费太多精力在设计品牌logo上，但当独立站稳定之后，专门设计一个具有标志性的，有特色的logo还是很有必要的，既能给消费者留下深刻印象，也能提高品牌的知名度。
3.拥有一个域名：注册的域名可以是每年续费，也可以一次性买断5年/10年。选择域名时可以考虑这些因素：
(1)域名的年龄；
(2)域名越简短越好，比较容易被记住；
(3)建议使用.com等国际性顶级域名；
(4)发音要简单容易记；
(5)可以定期上注册域名的网站，检查是否有更好的域名注册机会。
4.选择合适的独立站建站平台：
建站方式有三种，SaaS建站、开源建站、自主开发网站。第一种没有什么技术要求是独立站卖家最常用的方式，后两种对技术水平有一定要求，商家根据自身情况选择即可。
常见的建站平台盘点：
【SaaS建站】Shopyy、Shopplus（超店）、万全云、2Cshop、ShopiBar、跨等。
【开源系统】Opencart、Zencart、WordPress、Magento、PHP等。
5.开户：输入邮箱、密码和store name就能拥有一个账号，store name选好后会自动生成一个展示域名，最后按提示如实填写注册公司地址。
6.店铺主题：可以根据独立站的产品本身特点来进行主题设计。
7.产品分类：若独立站的产品较多，需要做好网页中的产品分类，方便消费者根据分类列表查找符合需求的商品。
8.店铺装修：一个精美的网页装修更能吸引买家的注意。在独立站停留的时间变长，也会对独立站转化和用户粘性产生影响。
9.插件与应用：各种应用的插件可以满足店铺的个性化设计和对其他附加功能的需求。
10.独立站支付方式：常用的线上付款方式有Paypal和第三方信用卡支付，需确认建站工具是否集成了对应的支付通道。
上文中提到的两种建站方式的所有常见建站平台，Onlypay就全部都支持。并且基本覆盖了市面上主流的国际信用卡种类，做到快速提现，即刻到账，有效缓解商家的资金周转压力。只需注册一个账户可以管理多个平台、多个店铺，省去了很多步骤，非常便捷。
11.独立站引流：
(1)通过搜索推广流量；(2)通过社交推广流量；(3)通过跨境电商平台推广流量；(4)其他推广方式。例如发邮件，网红带货，论坛推广等。
12.订单发货（独立站一般以国内发货为主）
分两种模式：
(1)零售高客单产品，商家可以选择包邮，因为其实运费已经加到了商品价格里，发邮政小包这种快递会比较实惠。
(2)给消费者提供两种运费方式。一种是速度快（几天内到货）但是运费较高，比如DHL、UPDP。另一种是支付小部分运费或者到达金额免运费，但时效就相对慢一些。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6540cc4a80f5a37435f6734220cfb98/" rel="bookmark">
			目标检测：如何将VOC标注的xml数据转为YOLO标注的txt格式，且生成classes的txt文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 目标检测数据的标注分为两种格式：
xml 解释性标签，左上角+右下角的坐标txt 记事本文件，类别+x，y中心坐标+w，h的相对值 如下：
xml 文件格式：
txt 文件格式：
本文要实现的目标是将目标检测xml标注格式转为txt相对坐标的标注方式
值得一提的是，xml标注包含了类别名称，往往在&lt;name&gt;下。所以，xml标注的数据有时候没有包含类别的json文件，因为根据xml可以直接绘制边界框。如果想要生成xml对应的类别json字典文件，可以参考：目标检测篇：如何根据xml标注文件生成类别classes的json文件
而对于yolo 标注的txt文件来说，类别仅仅用索引0 1 2表示，这也就是说我们是不知道0 1 2代表什么含义，所以yolo 的数据集往往包含类别的txt文件，方便可视化需要。没有的话，可以参考这个自己生成：关于目标检测任务中，YOLO(txt格式)标注文件的可视化 看文章的Tips
所以本文，将根据VOC标注的xml文件生成YOLO格式的txt文件，且生成yolo需要的类别txt文件
2. 代码实现 简单介绍代码逻辑
2.1 目录 目录结构：
这里是根据voc的训练集和验证集转换，且需要xml对应的json字典文件
class_indices.json 如下：
没有的话，看这个自己生成：目标检测篇：如何根据xml标注文件生成类别classes的json文件
2.2 图像的生成 关于图片，可以直接拷贝过去就行
这里生成好的目录根据本人习惯命名
代码运行到这，可以看到图像已经拷贝过去
2.3 目标类别的txt文件生成 yolo格式的classes文件，这里默认根据voc的json字典文件生成，代码如下
代码很简单，就是读取xml的json文件，获取字典的value值，然后保存在txt文件中
2.4 标签xml to yolo标签txt 这里通过labels_xml2yolo 自定义函数操作，传入训练集和验证集的xml目录即可，因为yolo的txt文件需要类别索引，这里将字典文件也传进去
这里需要保存原始图像的w、h，因为yolo标注是相对值，后面运算需要。因为voc标注的xml文件中包含了图像的size，直接读取即可
下面是将bbox坐标转为yolo相对坐标的代码，最终的数据就是info的存放的内容
将info 保存即可
生成好的数据：
2.5 可视化 为了验证是否转化成功，利用 这篇代码 可视化一下
3. 完整代码 如下：
import os from tqdm import tqdm from lxml import etree import shutil import json # 读取 xml 文件信息，并返回字典形式 def parse_xml_to_dict(xml): if len(xml) == 0: # 遍历到底层，直接返回 tag对应的信息 return {xml.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6540cc4a80f5a37435f6734220cfb98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422fea07990c8c824482c5e35189f57c/" rel="bookmark">
			微信小程序rsa加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没有使用npm下载依赖的方式，直接引入了rsa.js文件，rsa.js文件在后面，目录结构如下：
在index.js文件引用
import { proxyInstance, backendUrl } from '../../util/request.js'; import JSEncrypt from './rsa.js' const key = `-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCqeLMdabVQyl3tSAy4LBXihvcK Bq+YSHfWRugDvdaxkaNWo5EQYfmRYnwe8uHDHs4/jZuUIhPfWOsp1X6rbVqolwuB pgtDA6MVGJx6n3/v9d6b2ZkyoyRt9thL3eu1HPhbqnC187Rxyj86847MzuWrtwUc t7795HFw67CgfbVszQIDAQAB -----END PUBLIC KEY-----` const jsencrypt = new JSEncrypt(); const app = getApp(); Page({ ...... }) 在登录方法中使用JSEncrypt就好了
this.data.form.password = jsencrypt.encrypt(this.data.form.password) setData是双向绑定，页面显示，这边只处理传给后端的数据，所以直接赋值就好了
rsa.js文件：
/*! For license information please see jsencrypt.min.js.LICENSE.txt */ !function(t,e){"object"==typeof exports&amp;&amp;"object"==typeof module?module.exports=e():"function"==typeof define&amp;&amp;define.amd?define([],e):"object"==typeof exports?exports.JSEncrypt=e():t.JSEncrypt=e()}(window,(()=&gt;(()=&gt;{var t={155:t=&gt;{var e,i,r=t.exports={};function n(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/422fea07990c8c824482c5e35189f57c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef1c4d41dc65dbf99e068c838fb7f03/" rel="bookmark">
			Redis之集群方案比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哨兵模式 在redis3.0以前的版本要实现集群一般是借助哨兵sentinel工具来监控master节点的状态，如果master节点异常，则会做主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率
高可用集群模式 redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要sentinel哨兵∙也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35aece3d702dd05fe6938dc2f269507c/" rel="bookmark">
			安全防御之漏洞扫描技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每年都有数以千计的网络安全漏洞被发现和公布，加上攻击者手段的不断变化，网络安全状况也在随着安全漏洞的增加变得日益严峻。寻根溯源，绝大多数用户缺乏一套完整、有效的漏洞管理工作流程，未能落实定期评估与漏洞修补工作。只有比攻击者更早掌握自己网络安全漏洞并且做好预防工作，才能够有效地避免由于攻击所造成的损失。
什么是漏洞及漏洞的管理参见博客《安全运营之漏洞管理》，本文介绍安全防御中的漏洞扫描技术来发现漏洞。
安全防御中的漏洞扫描技术是网络安全防护体系中一项核心的预防性措施，用于自动检测网络、系统和服务中的潜在弱点和已知安全漏洞。这项技术帮助企业、组织和个人识别出可能被攻击者利用的风险点，并采取相应的补救措施以强化其整体安全态势。
漏洞扫描通过针对常见黑客攻击手法的检查策略，定期对网络系统进行扫描分析，及时发现问题、给出相关安全措施和建议并进行相应的修补和配置，这项技术的具体实现就是安全扫描程序，在很短的时间内查出现存的安全脆弱点。
安全漏洞扫描技术可以分为被动和主动两种方式。被动扫描是指在不影响系统正常运行的情况下，通过分析系统的网络流量、系统日志和配置信息等，来发现潜在的安全漏洞。主动扫描则是通过模拟攻击的方式，对系统进行深入的探测和漏洞发现。
被动扫描和主动扫描它们各有优缺点。
被动扫描是指在不影响系统正常运行的情况下，通过分析系统的网络流量、系统日志和配置信息等，来发现潜在的安全漏洞。被动扫描的优点在于不会对目标系统造成干扰或损害，可以避免触发恶意软件或警报器。同时，被动扫描可以实时监测系统的安全状况，及时发现新的漏洞和攻击。然而，被动扫描的缺点在于无法发现未知的漏洞和攻击，因为它是基于已知的安全漏洞库和规则进行扫描的。主动扫描则是通过模拟攻击的方式，对系统进行深入的探测和漏洞发现。主动扫描可以发现未知的漏洞和攻击，因为它是通过模拟攻击来发现系统中的弱点。主动扫描的优点在于可以更加深入地探测系统中的安全漏洞，包括缓冲区溢出、SQL注入等。同时，主动扫描还可以评估系统的防御策略和应急响应措施的有效性。然而，主动扫描的缺点在于可能会对目标系统造成干扰或损害，需要谨慎操作，避免对系统造成不必要的风险。 被动扫描和主动扫描各有优缺点，需要根据实际情况选择使用。在某些情况下，可能需要结合使用被动扫描和主动扫描，以提高系统的安全性。
安全漏洞扫描技术可以自动化进行，也可以手动执行。自动化扫描工具可以根据预定义的漏洞库和扫描规则，自动对目标系统进行扫描和漏洞发现。手动扫描则需要专业的安全人员对系统进行逐一检查和分析。
常见漏洞扫描工具的特点：
智能识别：能够对扫描结果数据进行在线分析，能够根据端口、漏洞、BANNER信息、IP地址等关键字对主机信息进行查询并能将查询结果保存。高效快捷：支持高级数据分析，能够进行历史数据查询、汇总查看、对比分析等，方便进行多个扫描任务或多个IP风险对比，能够在多个历史任务中，很快的检索到需要关注的资产IP点。脚本依赖：扫描模块会自动根据其逻辑依赖关系执行而不是无目的盲目执行，从而提高了扫描准确性。信息输出：漏洞分析报告应提供在线浏览报告和离线打印报告;离线报表提供针对不同角色的默认模板，允许用户定制报告的内容、报告的格式等。断点恢复：在扫描程序运行到一半的时候如果系统意外掉电等，可以通过查看扫描状态进行重新扫描或者继续扫描，如果选择继续扫描的话，前面扫描到的结果会保留下来和后面的结果一起合并生成结果文件。 安全漏洞扫描技术可以针对不同的层次进行扫描，例如网络层、操作系统层和应用层等。网络层扫描主要是检查网络设备和通信线路的安全性，操作系统层扫描主要检查操作系统的配置和漏洞，应用层扫描则针对具体的软件应用程序进行安全检查。基于网络的安全扫描主要扫描设定网络内的服务器、路由器、网桥、变换机、访问服务器、防火墙等设备的安全漏洞，并可设定模拟攻击，以测试系统的防御能力。通常该类扫描器限制使用范围（IP地址或路由器跳数）。
安全漏洞扫描技术是一类重要的网络安全技术。它和防火墙、入侵检测系统互相配合，能够有效提高网络的安全性。通过对网络的扫描，网络管理员能了解网络的安全设置和运行的应用服务，及时发现安全漏洞，客观评估网络风险等级。网络管理员能根据扫描的结果更正网络安全漏洞和系统中的错误设置，在黑客攻击前进行防范。如果防火墙和网络监视系统是被动的防御手段，那么安全扫描就是一种主动的防范措施，能有效避免黑客攻击行为，做到防患于未然。
博客：http://xiejava.ishareread.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7e9435f607d0ab1b465259b3bb42dc/" rel="bookmark">
			【大数据-Datax】ERROR Engine -经DataX智能分析,该任务最可能的错误原因是:com.alibaba.datax.common.exception.DataXException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题： 在执行 python datax.py ../job/job.json 时可能会出现以下报错:
DataX (DATAX-OPENSOURCE-3.0), From Alibaba !
Copyright (C) 2010-2017, Alibaba Group. All Rights Reserved.
2024-01-07 19:27:36.816 [main] WARN ConfigParser - 插件[streamreader,streamwriter]加载失败，1s后重试... Exception:Code:[Common-00], Describe:[您提供的配置文件存在错误信息，请检查您的作业配置 .] - 配置信息错误，您提供的配置文件[D:\dev\datax\plugin\reader\._cassandrareader\plugin.json]不存在. 请检查您的配置文件.
2024-01-07 19:27:37.824 [main] ERROR Engine -
经DataX智能分析,该任务最可能的错误原因是:
com.alibaba.datax.common.exception.DataXException: Code:[Common-00], Describe:[您提供的配置文件存在错误信息，请检查您的 作业配置 .] - 配置信息错误，您提供的配置文件[D:\dev\datax\plugin\reader\._cassandrareader\plugin.json]不存在. 请检查您的配置文件.
at com.alibaba.datax.common.exception.DataXException.asDataXException(DataXException.java:26)
at com.alibaba.datax.common.util.Configuration.from(Configuration.java:95)
at com.alibaba.datax.core.util.ConfigParser.parseOnePluginConfig(ConfigParser.java:153)
at com.alibaba.datax.core.util.ConfigParser.parsePluginConfig(ConfigParser.java:125)
at com.alibaba.datax.core.util.ConfigParser.parse(ConfigParser.java:63)
at com.alibaba.datax.core.Engine.entry(Engine.java:137)
at com.alibaba.datax.core.Engine.main(Engine.java:204)
解决办法 删除plugin 目录下的reader文件和writer文件夹下的 ._xxx 文件
此时进入bin目录执行自检脚本，可正常启动 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a9771161bac020ab1b6994bf4f29de/" rel="bookmark">
			C# 各数据类型 范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/m110/p/7754930.html
类型　范围　大小
sbyte -128 到 127　有符号 8 位整数
byte 0到255　无符号 8 位整数
char　U+0000 到 U+ffff 16 位 Unicode 字符
short　-32,768 到 32,767　有符号 16 位整数
ushort　0 到 65,535　无符号 16 位整数
int　-2,147,483,648 到 2,147,483,647　有符号 32 位整数
uint　0 到 4,294,967,295　无符号 32 位整数
long　-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807　有符号 64 位整数
ulong　0 到 18,446,744,073,709,551,615　无符号 64 位整数
--------------------------------------------------------------------------------------------------------------------------
类型　大致范围　精度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8a9771161bac020ab1b6994bf4f29de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96957e9ebb52fb5b4142bf3583aded07/" rel="bookmark">
			int 类型取值范围最大能到多少 16进制与2进制之间的转化 16进制占字节问题 16 进制与2进制的关联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/judongbin123/article/details/81093275
所以，int占32位的时候，最大可以赋值为：2147483647。也就是0x7fffffff。
32/8 =4字节
0x7fffffff = 一共8个数， 一个 f 是 4个 二进制位 ， 两个 f 才占用一个字节。
所以，int占32位的时候，最大可以赋值为：2147483647。也就是0x7fffffff。
32/8 =4字节
0x7fffffff = 一共8个数， 一个 f 是 4个 二进制位 ， 两个 f 才占用一个字节。
————————————————
版权声明：本文为CSDN博主「jubd」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/judongbin123/article/details/81093275
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4c943eddf2e6d1aee6c810292c87fe/" rel="bookmark">
			多数据集垃圾邮件过滤的朴素贝叶斯算法分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多数据集垃圾邮件过滤的朴素贝叶斯算法分析
Nurul Fitriah Rusland, Norfaradilla Wahid, Shahreen Kasim,
网络技术系,2017,马来西亚
摘要
电子邮件中的垃圾邮件继续成为互联网上的一个问题。垃圾邮件的电子邮件可能包含相同的信息，商业广告或其他不相关的帖子就像色情内容。在以往的研究中，不同的滤波技术来检测这些电子邮件，如用随机森林，朴素贝叶斯，支持向量机（SVM）和神经网络。在本研究中，我们测试垃圾邮件过滤的两个数据集上的朴素贝叶斯算法和测试其性能，即垃圾邮件数据Spambase数据[ 8 ]。数据集的性能在评价的基础上，他们的准确率，召回率，精度和F值。我们的研究使用WEKA工具用于垃圾邮件过滤对数据集的朴素贝叶斯算法的评价。结果表明，邮件的类型和数据集的实例的数量有影响对朴素贝叶斯算法的性能。
目录
多数据集垃圾邮件过滤的朴素贝叶斯算法分析 1
摘要 1
1.引言 1
2. 相关的工作 2
3. 方法论 3
3.1.朴素贝叶斯分类器 3
3.3.特征选择 6
4. 实验装置 6
4.1,评价指标 6
（7）真阳性率（TP）：垃圾邮件被正确地判断为垃圾邮件。 7
4.2.数据集 7
5. 结果与讨论 8
6.结论 12
机器学习算法已运用在反垃圾邮件的垃圾邮件过滤行动中，包括被认为在文本分类[ 3 ]优秀算法，提高算法、支持向量机（SVM）算法[ 5 ]和[ 7 ]朴素贝叶斯算法。
康斯坦丁特列季亚科夫等人[ 6 ]评估几个最流行的机器学习方法，即贝叶斯分类，k-近邻，人工神经网络，支持向量机将其应用于垃圾邮件过滤问题。在这项工作中，作者提出了命名的技术，其性能对PU1垃圾邮件语料库数据比较是最微不足道的样本实现了。利用提取特征将所有信息转换为数字向量（特征向量），然后对这些向量进行分类。这是因为大多数机器学习算法只能对向量等数字对象进行分类。
然后提出了算法的简单的C++实现，并测试了它们在PU1垃圾邮件语料库。PU1语料包括1099个信息，其中481是垃圾邮件。通过有效措施这是精密测试设置使用，合法邮件和垃圾邮件的影响后果。结果的K-最近邻分类器的性能似乎是穷人和误报的数量是相当大的。笔者认为，只有朴素贝叶斯分类器已经通过测试。
3. 方法论
本节描述了用于研究的方法。用于过滤方法的方法是由三个阶段划分的机器学习技术。该方法基于朴素贝叶斯算法用于垃圾邮件过滤的过程。
3.1.朴素贝叶斯分类器
朴素贝叶斯算法是一种简单的概率分类器，通过在一个给定的数据集[ 4 ]值的频率和组合计数的一组概率。在本研究中，朴素贝叶斯分类器使用的袋字特征识别垃圾邮件的电子邮件和文本是代表作为其字袋。包装袋上的字是用在文本分类的方法，其中每个词的出现频率是用于训练分类器的特征。该袋的文字功能包括在选定的数据集。
朴素贝叶斯技术利用贝叶斯定理确定垃圾邮件的概率。有些词在垃圾邮件或非垃圾邮件中有特定的发生概率。例如，假设我们确切地知道，在非垃圾邮件中，“自由”这个词永远不会出现。然后，当我们看到一个包含这个词的消息时，我们可以肯定地说那是垃圾邮件。
贝叶斯垃圾邮件过滤器学到了垃圾邮件的可能性，对诸如自由和伟哥很高，但非常低的垃圾邮件的概率为非垃圾邮件见字，如姓名的朋友和家庭成员。因此，为了计算电子邮件是垃圾邮件还是非垃圾邮件的概率，贝叶斯技术使用贝叶斯定理，如下面的公式所示。
介绍性陈述：
（1）P（spamword）是一个电子邮件有特定的词的电子邮件是垃圾邮件的概率。
（2）p（spam）是指任何给定的消息是垃圾邮件的概率。
（3）P（wordspam）是在垃圾短信出现的特定词概率。
（4）P（non-spam）是指任何特定的词不是垃圾邮件的概率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa4c943eddf2e6d1aee6c810292c87fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd8f934eb7dcc5c69bda5f1e4bf0b987/" rel="bookmark">
			Open CV 图像处理基础：（四）使用 Open CV 在 Java 中进行基本的图片模糊处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Open CV 在 Java 中进行基本的图片模糊处理 方法介绍 在Java中使用OpenCV进行图片模糊处理，主要可以通过以下几种方式：
均值模糊（Averaging Blur）: 通过计算核窗口内所有像素的平均值来模糊图像。这种方法可以移除图像噪声，但也会使图像细节变得模糊。
Imgproc.blur(src, dst, new Size(10, 10), new Point(-1, -1), Core.BORDER_DEFAULT); 这里src是原始图像，dst是模糊后的图像，new Size(10, 10)定义了核窗口的大小。
高斯模糊（Gaussian Blur）: 这种模糊使用正态分布的权重核，相较于均值模糊，它保留了更多的图像细节。
Imgproc.GaussianBlur(src, dst, new Size(15, 15), 0); 其中new Size(15, 15)指定了高斯核的大小，0指定了沿X和Y方向的标准偏差。
中值模糊（Median Blur）: 使用核窗口内像素的中值来替换。对于去除椒盐噪声很有效，同时能够保留边缘。
Imgproc.medianBlur(src, dst, 5); 其中5指定了核的大小，它必须是一个正的奇数。
双边滤波（Bilateral Filter）: 它可以在保持边缘清晰的情况下减少不必要的噪声。这种过滤器通常用于图像去噪。
Imgproc.bilateralFilter(src, dst, 9, 75, 75); 其中9是邻域直径，两个75分别是颜色空间和坐标空间的标准偏差。
示例 import org.opencv.core.Core; import org.opencv.core.Mat; import org.opencv.core.Point; import org.opencv.core.Size; import org.opencv.imgcodecs.Imgcodecs; import org.opencv.imgproc.Imgproc; public class ImageBlur { static { // 加载 OpenCV 的本地库，这一步是必须的 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd8f934eb7dcc5c69bda5f1e4bf0b987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f9e9a2c38690e16709b10d74d6a262/" rel="bookmark">
			2个nodejs进程利用redis 实现订阅发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新建文件 redis_db.js 'use strict'; const redis = require('redis'); const options = { host: "127.0.0.1", port: 6379, password: "123456", // CONFIG SET requirepass "123456" } var array = [] for(var i=0; i&lt;3; i++){ const client = redis.createClient(options) array.push(client) } function getDB(index){ if(typeof index === "number"){ return array[index] } return array } for(var key in array){ const client = array[key] client.on('error', err =&gt; console.log('------ client Redis connection failed ------' + err)) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f9e9a2c38690e16709b10d74d6a262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60227077f0519195603cc64d66c89d0d/" rel="bookmark">
			docker拉取镜像提示 remote trust data does not exist for xxxxxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、How can I be sure that I am pulling a trusted image from docker 2、docker: you are not authorized to perform this operation: server returned 401. 以上两个问题可以试试以下解决办法
DOCKER_CONTENT_TRUST=false
本人是使用jenkins部署自己的项目到docker容器出现的这个错误，
解决办法
注意在制作镜像之前设置不需要上传秘钥，如果你们在执行遇到这个问题，可以试着在拉取、推送该镜像之前进行操作 #不需要上传秘钥 DOCKER_CONTENT_TRUST=false #制作dockerfile镜像 docker build -f Dockerfile -t ruoyi-admin . #run docker run --name ruoyi-admin -d -p 80:80 --network=host ruoyi-admin 3、Error: remote trust data does not exist for docker.io/nacos/nacos-server: notary.docker.io does not have trust data for docker.io/nacos/nacos-server 4、Error: remote trust data does not exist for docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60227077f0519195603cc64d66c89d0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a0f646d806b9a47ff3e40c8469aeb0/" rel="bookmark">
			git 查看tag和创建tag以及上传tag命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 git 查看tag和创建tag以及上传tag命令git tagtag操作常用命令 git 查看tag和创建tag以及上传tag命令 git tag 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。
Git 的 tag 功能是一个非常有用的工具，它可以帮助开发者在代码仓库中标记重要的里程碑和版本号。
Tag 可以看作是一个快照，用于永久性地标记提交记录。它们通常用于发布新版本或里程碑，并且可以帮助开发者追踪项目的历史记录。Tag 在 Git 中是轻量级对象，不会像分支那样占用额外的存储空间，因此创建 Tag 对存储的影响很小。
tag操作常用命令 查看tag git tag // 列出tag git tag -l // 列出tag git show 标签名 // 查看标签对应的提交 git ls-remote --tags origin // 查询远程tags 添加标签 git tag -a 标签名称 -m 附注信息 git tag 标签名 提交版本commit号 // 基于某次提交创建tag 比如
git tag -a v0.1.0 创建带有说明的标签，用-a指定标签名，-m指定说明文字。
提交tag到远端服务器 git push origin 标签名称	通过tag创建新分支 (检出标签) git checkout -b 分支名称 标签名称 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814fc894c6447272dbb61cc07aa66d4e/" rel="bookmark">
			用css给宽高不固定的矩形画对角线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.kong{ width: 200rpx; height: 76rpx; background: linear-gradient( to bottom right, #E5E5E5 0%, rgba(0, 0, 0, 0.1) calc(50% - 1px), #175CFF 50%, rgba(0, 0, 0, 0.1) calc(50% + 1px), rgba(0, 0, 0, 0.1) 100% ); } 参考：
https://blog.csdn.net/weixin_38779534/article/details/104778147
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b150fb7b6069654c87c737742b4e085/" rel="bookmark">
			Python 私有变量(__)的访问和赋值以及变量前加(_)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一、Python 私有变量的访问和赋值二、变量前加(_)三、其他 一、Python 私有变量的访问和赋值 python中的私有变量是以双下划线开头的变量，例如__name。虽然不能直接从外部访问私有变量，但是可以通过一些方式来访问。
一种方式是通过使用变量名改写规则来访问私有变量。Python解释器会将双下划线开头的变量名改写为_类名__变量名的形式。例如，对于类Person中的私有变量__name，可以通过_Person__name来访问。
另一种方式是通过提供公有的getter和setter方法来访问和修改私有变量。通过这种方式，可以在方法内部对私有变量进行操作，同时对外部隐藏实际的变量名。
然而，尽管可以通过上述方式访问私有变量，但是强烈建议不要这样做。因为不同版本的Python解释器可能会将私有变量名改写成不同的形式，这样会导致代码的可移植性和可维护性变差。
案例
class S: __name = 'kobe' _age = 18 def __init__(self): self.__name1 = 'zhil' self.__age1 = 20 self.__sex='女' def get_name(self): return self.__name1 def get_age(self): return self.__name1 def set_age(self, sex): self.__sex = sex s = S() # print(s.__name) #AttributeError: 'S' object has no attribute '__name' # print(s.__name1) #AttributeError: 'S' object has no attribute '__name' print(s._age) # 18 # print(s.__name1) print(s.get_name()) # zhil 我们知道，私有变量是不能直接通过：s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b150fb7b6069654c87c737742b4e085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e607b7a0c35f030b34d7cd22247c92c/" rel="bookmark">
			gradio高级技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gradio高级技巧） 1 Gradio基础功能回顾2. Gradio的高级组件1. 使用 `InterfaceOptions` 自定义界面外观和行为2. 使用 `CustomCSS` 自定义界面样式3. 使用 `MultiModel` 集成多个模型 结尾 1 Gradio基础功能回顾 Gradio的基础功能，如何创建简单的界面、添加输入输出、以及使用不同的预训练模型等。
2. Gradio的高级组件 当探讨 Gradio 的高级功能时，举例可以让读者更清楚地理解其灵活性和功能强大之处。以下是一些例子：
1. 使用 InterfaceOptions 自定义界面外观和行为 import gradio as gr # 创建一个简单的文本分类界面 def text_classifier(text): # 这里是你的文本分类器代码 return "分类结果：" + text iface = gr.Interface(fn=text_classifier, inputs=gr.inputs.Textbox(), outputs="text") # 自定义界面外观和行为 iface.interface_options['input_width'] = 500 # 设置输入框宽度 iface.interface_options['output_font_size'] = 20 # 设置输出文本字体大小 iface.launch() 2. 使用 CustomCSS 自定义界面样式 import gradio as gr # 创建一个图像分类界面 def image_classifier(image): # 这里是你的图像分类器代码 return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e607b7a0c35f030b34d7cd22247c92c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9838abacf92233972038ed6e54da696c/" rel="bookmark">
			1为什么要用Spring框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mg9b
dao-impl-UserDaoImpForMySQL package com.sunsplanter.dao.impl; import com.sunsplanter.dao.UserDao; public class UserDaoImpForMySQL implements UserDao { @Override public void deleteById() { System.out.println("deleting User..."); } } dao-UserDao package com.sunsplanter.dao; //yuyuemima wg9b public interface UserDao { void deleteById(); } service-Impl-UserServiceImp package com.sunsplanter.service.impl; import com.sunsplanter.dao.UserDao; import com.sunsplanter.dao.impl.UserDaoImpForMySQL; import com.sunsplanter.service.Userservice; public class UserServiceImp implements Userservice { //控制层调用（操作）持久层，因此必须创造一个dao对象（控制具体的对象） //UserDao是抽象接口（框架），UserDaoImpForMySQL是实现类（实物）， //new出一个实物，填进框架 private UserDao userDao = new UserDaoImpForMySQL(); @Override public void deleteUser() { //然后操作具体的userDao对象调用UserDao的方法 userDao.deleteById(); } } service-UserService package com.sunsplanter.service; public interface Userservice { void deleteUser(); } web-UserAction package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9838abacf92233972038ed6e54da696c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb36ba3e3d11210bb1370162a1ea4c02/" rel="bookmark">
			Protobuf 序列化源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇 深入 ProtoBuf - 编码 中，我们详细解析了 ProtoBuf 的编码原理。
有了这个知识储备，我们就可以深入 ProtoBuf 序列化、反序列化的源码，从代码的层面理解 ProtoBuf 具体是如何实现对数据的编码（序列化）和解码（反序列化）的。
我们重新复习一下， ProtoBuf 的序列化使用过程：
定义 .proto 文件protoc 编译器编译 .proto 文件生成一系列接口代码调用生成的接口实现对 .proto 定义的字段的读取以及 message 对象的序列化、反序列化方法 具体调用代码如下：
Example1 example1; example1.set_int32val(val); example1.set_stringval("hello,world"); example1.SerializeToString(&amp;output); 调用 SerializeToString 函数将 example1 对象序列化（编码）成字符串。我们的目的就是了解 SerializeToString 函数里到底发生了什么，是怎么一步一步得到最终的序列化结果的。
注意：并非编码成字符串数据，string 只是作为编码结果的容器
我们在 .proto 文件中定义的 message 在最终生成的对应语言的代码中，例如在 C++ (xxxx.pb.h、xxxx.pb.cpp) 中每一个在 .proto 文件中定义的 message 字段都会在代码中构造成一个类，且这些 message 消息类继承于 ::google::protobuf::Message，而 ::google::protobuf::Message 继承于一个更为轻量的 MessageLite 类。其相关的类图如下所示：
protobuf-class-analysis.png
而我们经常调用的序列化函数 SerializeToString 并定义在基类 MessageLite 中。
编码 当某个 Message 调用 SerializeToString 时，经过一层层调用最终会调用底层的关键编码函数 WriteVarint32ToArray 或 WriteVarint64ToArray，整个过程如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb36ba3e3d11210bb1370162a1ea4c02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54fa1bda9935fc279dd8e8605f0c3d63/" rel="bookmark">
			Protobuf 反射技术简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于反射大家应该不会陌生，如果你接触过一些框架（如 ORM、IOC、OSGi 等） 的内部实现，应该更能体会反射技术的应用可谓无处不在。
反射概念最早出现于人工智能领域，20 世纪 70 年代末被引入到程序语言设计中。1982 年 MIT 的 Smith, Brian Cantwell 在他的博士论文中最早提出了程序反射的概念：
既然我们可以构造“有关某个外部世界表示”的计算过程, 并通过它来对那个外部世界进行推理; 那么我们也可以构造能够对自身表示和计算进行推理的计算过程 ,它包含负责管理有关自身的操作和结构表示的内部过程。
—— 1982年 Smith, Brian Cantwell 博士论文首次提出
从某种角度来看，所谓编程实际上就是在构造 “关于外部世界” 的计算过程。如果用 F 表示这个构造过程，用 X 表示外部世界，那么编写一个计算系统可表示为 F(X)。
那么非常有趣的点就在于：我们完全可以构造对上述过程本身进行描述和推理的计算过程。即将 F(X) 视为新的 “世界” 和 研究对象，构造 F(F(X))。
我们平时编写的计算系统是面向特定领域的（通常是面向现实建模）, 系统中包含 用来描述领域中的实体 和 实体间关系 的数据结构以及处理这些数据结构的规则。那么反射系统面向领域便是这个系统本身。
从上层概念往下走，很容易就能理解反射将为我们提供这样的能力：
计算机程序在运行时可以访问、检测和修改它本身状态或行为
—— 反射 (计算机科学) Wikipedia
很多编程语言可对程序本身进行构建（如何构建见下文），从而为程序员提供反射能力，即可在运行时访问和修改自身状态和行为：
// 运行时动态创建对象 Class&lt;?&gt; class1 = Class.forName("cn::lcy::dog"); Dog dogObj = (Dog) class1.newInstance(); // 运行时动态访问状态 Field dogNameField = class1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54fa1bda9935fc279dd8e8605f0c3d63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138912570f80a82abcb1ff31f0c546ab/" rel="bookmark">
			NodeJS报错Cannot access ‘xxx‘ before initialization排查解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 我在写Nodejs时，正在测试一个方法，报错
ReferenceError: Cannot access ‘isSaved’ before initialization
at test ?[90m(E:\idea项目\sifanERP\dev\src\non_core?[39mtest.js:52:21?[90m)?[39m
at Object. ?[90m(E:\idea项目\sifanERP\dev\src\non_core?[39mtest.js:57:1?[90m)?[39m
?[90m at Module._compile (node:internal/modules/cjs/loader:1126:14)?[39m
?[90m at Object.Module._extensions…js (node:internal/modules/cjs/loader:1180:10)?[39m
?[90m at Module.load (node:internal/modules/cjs/loader:1004:32)?[39m
?[90m at Function.Module._load (node:internal/modules/cjs/loader:839:12)?[39m
?[90m at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)?[39m
?[90m at node:internal/main/run_main_module:17:47?[39m
很懵逼啊。
排查过程 代码如下：
async function isSaved(asin) { return asin } async function test() { const isSaved = await isSaved("B08FT159") console.log(isSaved) } test() 很简单的东西，就是测试一下isSaved方法会返回什么，竟然直接报错。
然后我写了一个名字不同，但是作用一样的方法
async function isSaved2(asin) { return asin } async function isSaved(asin) { return asin } async function test() { const isSaved = await isSaved2("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/138912570f80a82abcb1ff31f0c546ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc1a11111b46b1121981b4eb129f748/" rel="bookmark">
			MySQL MHA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1．什么是 MHA
2．MHA 的组成
3．MHA 的特点
----------------------搭建 MySQL MHA--------------------------------
---------------------- 故障模拟 --------------------------------
1．什么是 MHA MHA（MasterHigh Availability）是一套优秀的MySQL高可用环境下故障切换和主从复制的软件。
MHA 的出现就是解决MySQL 单点的问题。
MySQL故障切换过程中，MHA能做到0-30秒内自动完成故障切换操作。
MHA能在故障切换的过程中最大程度上保证数据的一致性，以达到真正意义上的高可用。
2．MHA 的组成 ●MHA Node（数据节点）
MHA Node 运行在每台 MySQL 服务器上。
●MHA Manager（管理节点）
MHA Manager 可以单独部署在一台独立的机器上，管理多个 master-slave 集群；也可以部署在一台 slave 节点上。
MHA Manager 会定时探测集群中的 master 节点。当 master 出现故障时，它可以自动将最新数据的 slave 提升为新的 master， 然后将所有其他的 slave 重新指向新的 master。整个故障转移过程对应用程序完全透明。
3．MHA 的特点 ●自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据不丢失
●使用半同步复制，可以大大降低数据丢失的风险，如果只有一个slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其他所有的slave服务器上，因此可以保证所有节点的数据一致性
●目前MHA支持一主多从架构，最少三台服务，即一主两从
----------------------搭建 MySQL MHA-------------------------------- 实验思路：
1．MHA架构
1）数据库安装
2）一主两从
3）MHA搭建
2．故障模拟
1）主库失效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dc1a11111b46b1121981b4eb129f748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/453ce5e7f02af4e3840c5e4455c932a8/" rel="bookmark">
			【自少目多集】北京23年高考学校排名笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记录一下北京23年高考学校平均分排名和讲解。虽然高考和分数不是教育唯一的指标，但是不可否认是最重要的指标甚至没有之一。孩子和作为家长的我们生活在这个时代，就要遵从时代的规律。
仔细看看学校的排名也非常讲究。平均分的顺序是不是和我们印象中的顺序有所差别。——是的，平均分四中一直优于人大附中，而我们印象中的是尖子生的清北入学顺序，人大附是优于四中的。
排名前面的学校中，按行政区划，明显是三个梯队。
海淀和东西城是第一梯队。其中海淀的学校几乎是东西城之和，占据半壁江山。朝阳是第二梯队。东西城的零头就是朝阳优质校的数量。其他的行政区是第三梯队。优质校在其他所有区数量之和几乎也就是朝阳的数量。 海淀的优质校和坑校两极分化的比较多，需要父母鸡娃。西城平均水平最高，既可以鸡娃，整体坑校也比较少。再次是东城，整体水平高，气氛温和，小学四年级以前可以躺平。
排名高中排名变化行政区1北京四中西城2人大附中海淀3清华附中2海淀4北师大附实验西城5北京八中-2西城6十一学校海淀7一零一中学海淀8北京二中4东城9北师大二附中-1西城10北大附中4海淀11北京中学-2朝阳12首师附中-2海淀13十一实验中学new海淀14清华实验-1海淀15北师大附中-4西城16北京五十七中-3海淀17育英学校-海淀18建华实验学校-3海淀19朝阳外国语学校11朝阳20北京十二中-4丰台21人大附朝阳4朝阳22交大附中4海淀23八十中15朝阳24八一学校-2海淀25清华附朝阳学校-4朝阳26理工附中11海淀27陈经纶中学8朝阳28五中5东城29一六一中学-11西城30一七一中学-1东城31亦庄实验中学-4经开32汇文中学-1东城33教进实验学校10海淀34广渠门中学13东城35北京十三中-1西城36人大附中分校new海淀37景山学校new东城38陈经纶保利new朝阳39北京三十五中2西城40北大附中石景山new石景山41一六六中学new东城42人大附中经开new经开43昌平二中3昌平44首师附中通州new通州45京源学校-17石景山46牛栏山一中-26顺义47东直门中学new东城48北航实验学校new海淀49景山远洋-25石景山50铁二中-5西城51中关村中学7海淀52丰台二中new丰台53北京十五中-14西城54北京二十中new海淀55潞河中学-13通州56五十七中上庄new海淀57北京十四中new西城58人大附中通州-10通州59北京十八中new丰台60一五六中学new西城 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ad187bcbdb80dbfdc451e81baf0ffa/" rel="bookmark">
			3D点云平面拟合算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设你有一组 3D 中的 n 个点，并且想要为它们拟合一个平面。 在本文中，我将推导出一个简单的、数值稳定的方法，并提供它的源代码。 听起来很好玩？ 我们开始吧！
NSDT工具推荐： Three.js AI纹理开发包 - YOLO合成数据生成器 - GLTF/GLB在线编辑 - 3D模型格式在线转换 - 可编程3D场景编辑器 - REVIT导出3D模型插件 - 3D模型语义搜索引擎
首先，如果在网上寻找答案，你将得到的答案包括对协方差矩阵进行奇异值分解以找到最小特征值的特征向量。 然而事实证明，这让事情变得比他们需要的更加复杂。 让我们从基础开始：
平面通常由法向量 n = [a, b, c]ᵀ 和距离 d 描述，因此对于平面 n · p + d = 0 上的点 p = [x, y, z]ᵀ。我们可以 将其写为：
但请注意，这是超定的 - 解空间（平面）是三维的，但上面的描述使用了四个值。 因此，让我们首先通过限制解决方案空间来删除一个组件。 我们通过任意指定 c = 1 来实现这一点，即平面法线的 z 分量始终为 1（请注意，法线的长度不需要为 1）。 如果你认为这是一个潜在有问题的假设，那么你是对的——我们稍后会再讨论这个问题。 现在，让我们定义：
并求解a、b、d。 矩阵形式：
接下来，我们将这个矩阵转置，然后从左侧相乘以执行线性最小二乘：
转置后相乘：
其中 N 是点数。 现在这是聪明的部分：让我们定义上面的 x,y,z 相对于点云的质心（平均值）。 现在 Σx = Σy = Σz = 0 所以我们可以简化为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ad187bcbdb80dbfdc451e81baf0ffa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc676d39f78e43b586935f66aeb96184/" rel="bookmark">
			Pandas助力表格操作提升生产力,以销售表格为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas助力表格操作提升生产力 1. 数据加载和预览2. 数据清洗和处理3. 数据分析和统计实战案例：销售数据分析步骤 1：数据加载和预览步骤 2：数据清洗和处理步骤 3：数据分析和可视化 结尾 1. 数据加载和预览 首先，让我们谈谈如何用Pandas加载数据。使用pd.read_csv()可以轻松读取CSV文件，而head()方法则可以快速预览数据的前几行，帮助你了解数据的结构和内容。
import pandas as pd # 加载数据 data = pd.read_csv('your_data.csv') # 预览前几行数据 print(data.head()) 2. 数据清洗和处理 Pandas使得数据清洗变得非常简单。你可以使用dropna()方法删除缺失值，fillna()填充缺失值，drop_duplicates()去除重复行等等。此外，apply()方法和自定义函数的结合可以高效地对数据进行处理。
# 删除缺失值 clean_data = data.dropna() # 填充缺失值 data['column'].fillna(data['column'].mean(), inplace=True) # 去除重复行 data.drop_duplicates(inplace=True) # 使用apply()方法进行数据处理 def double_data(x): return x * 2 data['doubled_column'] = data['column'].apply(double_data) 3. 数据分析和统计 Pandas也提供了丰富的功能来进行数据分析和统计。你可以使用groupby()方法进行分组汇总，使用describe()方法查看数据的统计信息，还可以进行数据透视表操作等等。
# 分组汇总数据 grouped_data = data.groupby('category_column').mean() # 查看数据的统计信息 data_stats = data.describe() # 创建数据透视表 pivot_table = pd.pivot_table(data, values='value', index='index_column', columns='column_to_pivot') 实战案例：销售数据分析 假设我们有一个名为sales_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc676d39f78e43b586935f66aeb96184/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8e2f28cde26eccb56b71d34e4103e3/" rel="bookmark">
			50、Flink的单元测试介绍及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink 系列文章 一、Flink 专栏
Flink 专栏系统介绍某一知识点，并辅以具体的示例进行说明。
1、Flink 部署系列
本部分介绍Flink的部署、配置相关基础内容。
2、Flink基础系列
本部分介绍Flink 的基础部分，比如术语、架构、编程模型、编程指南、基本的datastream api用法、四大基石等内容。
3、Flik Table API和SQL基础系列
本部分介绍Flink Table Api和SQL的基本用法，比如Table API和SQL创建库、表用法、查询、窗口函数、catalog等等内容。
4、Flik Table API和SQL提高与应用系列
本部分是table api 和sql的应用部分，和实际的生产应用联系更为密切，以及有一定开发难度的内容。
5、Flink 监控系列
本部分和实际的运维、监控工作相关。
二、Flink 示例专栏
Flink 示例专栏是 Flink 专栏的辅助说明，一般不会介绍知识点的信息，更多的是提供一个一个可以具体使用的示例。本专栏不再分目录，通过链接即可看出介绍的内容。
两专栏的所有文章入口点击：Flink 系列文章汇总索引
文章目录 Flink 系列文章一、Flink测试概述二、测试用户自定义函数1、单元测试无状态、无时间限制的 UDF1）、示例-mapFunction2）、示例-flatMapFunction 2、对有状态或及时 UDF 和自定义算子进行单元测试1）、DataStream API 测试依赖2）、Table API 测试依赖3）、flatmap function 单元测试4）、Process Function 单元测试 三、测试 Flink 作业1、JUnit 规则 MiniClusterWithClientResource 本文详细的介绍了Flink的单元测试，分为有状态、无状态以及作业的测试，特别是针对无状态的单元测试给出了常见的使用示例。
如果需要了解更多内容，可以在本人Flink 专栏中了解更新系统的内容。
本文除了maven依赖外，没有其他依赖。
一、Flink测试概述 Apache Flink 同样提供了在测试金字塔的多个级别上测试应用程序代码的工具。
本文示例的maven依赖
&lt;properties&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8e2f28cde26eccb56b71d34e4103e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ab5c643ddae9bc6f5f45b9123784ed/" rel="bookmark">
			基于51单片机的智能水表电路设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：基于51单片机的智能水表设计与实现
摘要：
本文主要探讨了基于STC89C52单片机为核心，结合霍尔传感器、流量传感器以及IC卡技术设计一种新型智能水表的电路系统。通过采用先进的电子传感技术和数据处理算法，实现了对水资源消耗的精确计量和智能化管理。该智能水表具有自动读数、远程传输、预付费功能，并且能有效解决传统机械水表存在的误差大、维护不便等问题。
一、引言
随着物联网和智慧城市的发展，智能水表作为供水系统的终端设备，其智能化、信息化的需求日益增强。本研究以51系列单片机为控制核心，开发了一种能够实时监测水量、记录用户用水信息、具备防窃水功能的智能水表。
二、系统总体设计
1. 硬件设计部分详细介绍了利用霍尔传感器检测水流信号，将流经水表的水量转换为电信号；同时使用高精度流量传感器获取更为准确的流量数据。此外，还阐述了基于非接触式IC卡进行预付费操作的设计思路，以及电磁阀控制模块在余额不足时切断供水的功能实现。
2. 软件设计部分讨论了单片机程序中如何实现数据采集、脉冲计数、IC卡信息读写、剩余水量计算及显示等关键算法，以及通过无线通信模块实现远程数据传输的方法。
三、关键技术
（1）霍尔传感器与流量传感器的数据融合算法；
（2）基于单片机的IC卡预付费管理系统；
（3）低功耗设计与电源管理策略；
（4）无线通讯模块的选择与接口设计。
四、实验验证与性能评估
通过实验室模拟测试和实际环境应用，验证了智能水表的准确性、稳定性、安全性以及低功耗特性，并对其抗干扰能力进行了全面评估。
五、结论与展望
本文设计的基于51单片机的智能水表在提高计量精度、简化管理流程、提升用户体验等方面表现出良好的性能，但仍有进一步优化的空间，如增加故障诊断、自适应校准等功能。未来将继续深入研究并拓展智能水表在智慧水务中的应用。
关键词：51单片机；智能水表；霍尔传感器；流量传感器；IC卡；远程抄表；预付费
请注意，以上内容仅为示例性的论文框架，具体实施细节需根据实际项目的技术路线和研究成果来填充和完善。
部分代码如下
基于51单片机设计智能水表的电路涉及到多个模块，包括流量传感器信号处理、IC卡读写、液晶显示、蜂鸣器报警以及可能的无线通信等。由于代码编写非常依赖于具体的硬件接口配置和传感器类型，以下将提供一个简化的代码框架示例，用于说明主要功能部分的设计思路，但请注意这并非完整可运行的代码，需要根据实际项目硬件环境进行详细编程。
#include &lt;reg52.h&gt; // 导入51单片机头文件 // 假设定义了相关硬件端口和宏定义 #define FLOW_SENSOR_PIN P3_0 // 流量传感器中断引脚 #define IC_CARD_PORT P2 // IC卡连接的I/O口 #define LCD_PORT P0 // 连接LCD的数据口 #define BUZZER_PIN P1_0 // 蜂鸣器控制引脚 unsigned int waterCount = 0; // 计量用水总量变量 unsigned char cardData[16]; // 存储IC卡数据缓冲区 unsigned int remainingWater; // 剩余水量 void FlowSensor_Init(void); // 初始化流量传感器 void IC_Card_ReadWrite(void); // IC卡读写函数 void DisplayOnLCD(unsigned int count, unsigned int rem_water); // 在LCD上显示水量信息 void BuzzerAlarm(void); // 蜂鸣器报警函数 void main(void) { FlowSensor_Init(); // 初始化流量传感器 IC_Card_ReadWrite(); // 读取或写入IC卡数据 remainingWater = GetCardBalance(cardData); // 获取卡内剩余水量 while (1) { if (IsFlowInterrupt()) { // 检查到流量脉冲中断 waterCount++; // 更新累计水量 if (CheckThreshold(waterCount)) { // 检查是否达到预设阈值 BuzzerAlarm(); // 触发蜂鸣器报警 } DisplayOnLCD(waterCount, remainingWater); // 更新LCD显示内容 } } } // 其他未在此处详述的相关函数实现.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8ab5c643ddae9bc6f5f45b9123784ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49307ac28606dbb0e6732568658c7305/" rel="bookmark">
			基于51单片机的恒温淋浴器控制电路设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：
本文提出了一种基于51系列单片机的智能恒温淋浴器控制系统的设计方案。系统采用温度传感器实时监测水温，并通过PID算法精确控制电热元件的工作状态，从而实现对出水温度的精准调控。同时，系统还具备人机交互界面，便于用户设定和查看淋浴器的工作状态。
关键词：51单片机；恒温淋浴器；温度控制；PID算法；人机交互
一、引言
（阐述背景，包括现有淋浴器存在的问题以及智能恒温技术的发展趋势和应用前景）
二、系统总体设计方案
1. 系统组成及工作原理：描述系统主要由51单片机、温度传感器、继电器驱动模块、电热元件以及显示与按键模块等构成。
2. 温度检测模块设计：详细介绍所使用的温度传感器类型及其与单片机的接口连接方式。
3. 温度控制策略：介绍如何利用PID算法实现恒温控制，包括PID参数整定方法和算法的具体实现。
4. 人机交互模块设计：说明如何使用LCD显示屏或LED数码管显示当前水温和设定温度，并通过按键进行温度设定。
三、硬件设计与实现
1. 单片机最小系统设计
2. 温度传感器接口电路设计
3. 继电器驱动电路设计以控制电热元件通断
4. 显示与按键模块电路设计
四、软件设计与实现
1. 系统主程序流程图
2. PID算法的C语言编程实现
3. 温度采样、处理与控制程序设计
4. 人机交互界面的程序设计
五、实验测试与结果分析
（展示实际搭建的系统实物照片，给出实验数据，分析系统的稳定性和准确性）
六、结论
（总结设计成果，指出可能的改进点和未来的研究方向）
参考文献
以上是基于51单片机设计恒温淋浴器控制电路的一般性论文大纲，具体的内容需要根据实际项目实施情况进行填充和完善。在撰写过程中，应充分考虑系统设计的可行性、实用性、经济性和安全性等方面。
部分代码如下
#include &lt;reg52.h&gt; // 导入51单片机头文件 // 假设已定义相关硬件端口和宏定义 #define TEMP_SENSOR_PIN P1_0 // 温度传感器连接的ADC输入引脚 #define RELAY_PIN P2_0 // 继电器驱动输出引脚 #define SETPOINT_TEMP 40 // 用户设定的目标温度 // PID参数（示例） #define KP 5.0 #define KI 0.2 #define KD 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49307ac28606dbb0e6732568658c7305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfb4c897e6948bd551d2405e0cc93f4/" rel="bookmark">
			2024华为OD机试题库【A卷&#43;B卷&#43;C卷&#43;D卷】（JAVA、Python、C&#43;&#43;、JS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常见问题 1、11月之后，华为od考卷统一替换为【C+D卷】。新的题目由一部分以前考过的旧题库的题目+一部分全新题目（也就是今年才出的题目）题目组成。
2、如果时间紧迫，没有太多时间复习，建议直接从【C+D卷】开始刷。因为以前的旧题库不会再考到了，不会遇到原题。但是【C+D卷】大部分是原题。
3、如果机试挂了，6个月之后可以再考。
4、订阅专栏后，后面更新的答案都可以查看。以后更新的题目也会放到这个专栏里。
5、如果对题解有问题，私信我解答。
样例展示 题目：优雅子数组
链接：https://blog.csdn.net/AlgorithmHero/article/details/130743114
考点类型：双指针
样题展示 题目：最大利润
链接：https://blog.csdn.net/AlgorithmHero/article/details/130742751
考点类型：双指针
新题库A+B+C+D卷【目录】 题目考点分值不相交子序列逻辑推理200计算主站点并查集100最长公共后缀双指针100无向染色图逻辑推理200单词加密正则匹配100 跳房子双指针100区间交叠贪心算法100 矩阵元素的边界值矩阵的遍历200人数最多的站点逻辑推理100最高价值的矿深度优先搜索200几何平均值最大子数组二分查找200ipv4地址转换字符串处理100田忌赛马双指针100节省内存的备份方法二分查找100查找人名字符串处理100玩牌获取的最高分动态规划200最长元音串字符串遍历200最短步数数学推理100数组中点字符串遍历200最旺的店铺优先队列200软盘拷贝文件动态规划200矩阵的最大值和最小值数组的遍历200字符串匹配字符串处理100关联子串字符串处理100金字塔形收入哈希表200最接近中位数排序100新荒岛求生遍历100查字典字符串处理100生日蛋糕二分法200比赛冠军自定义排序200喊7游戏贪心算法200火星改造广度优先搜索200植树距离逻辑推理200字符匹配逻辑推理200符合要求的团队逻辑推理200师徒关系动态规划200增强字符串滑动窗口200施肥问题逻辑推理100组装数组深度优先搜索200计算误码率字符串遍历200监视器的数量深度优先搜索200开租建站拓补排序100区域发电量统计前缀和200新词挖掘滑动窗口100区块链转储系统滑动窗口100新词挖掘滑动窗口100最大控制资源成本优先队列200租车骑绿岛逻辑推理100上班之路深度优先搜索200无向图染色暴力搜索200等和子数组的最小和动态规划100单向链表的中间节点逻辑推理100不含101的数逻辑推理100简单的压缩算法栈200最小调整顺序次数双端队列100最多颜色的车辆滑动窗口100真正的密码集合100羊狼农夫过河深度优先搜索200过滤组合字符串深度优先搜索200模拟商场优惠打折逻辑推理100探索地块建立前缀和200日志首次上报最多积分动态规划100处理器问题深度优先搜索100打印机队列排序100积木最远距离动态规划100最大平分数组动态规划200修建高铁最低成本并查集200垃圾短信识别逻辑推理200机房布局模拟100矩阵里的非1元素逻辑推理100机房布局栈100缓存需要最少金币数贪心算法100快递投放哈希表100二元组个数哈希表100连接器贪心算法200最长密码哈希集合100最大利润贪心算法100端口合并贪心算法100最左侧冗余覆盖子串滑动窗口100星际篮球争霸赛动态规划100最多获得的短信条数动态规划100最短木板长度贪心算法100挑选字符串贪心算法100数组合并贪心算法100对称美学递归100单词倒序快速排序100预定酒店自定义排序100查找单入口空闲区域回溯法100货币单位换算贪心算法100最多等和不相交连续子序列动态规划100去除多余空格逻辑推理200最差产品奖滑动窗口200计算快递业务主站点深度优先搜索200分奖金单调栈200整理扑克牌逻辑分析100猜字谜自定义排序100数字加减游戏逻辑分析200最多获得的短信条数动态规划200优雅子数组双指针200找出重复代码动态规划100密室逃生游戏逻辑分析100匿名信自定义排序100分界线逻辑分析100任务调度大顶堆100寻找路径二叉树遍历100新学校选址数学问题100机器人深度优先搜索100最大报酬动态规划100通信误码逻辑分析2023.Q1开心消消乐广度优先搜索2023.Q1投篮大赛逻辑分析2023.Q1开放日活动二分法2023.Q1相同数字的积木游戏逻辑分析2023.Q1二进制差异数逻辑分析2023.Q1获取最大软件版本号字符串分割2023.Q1自动曝光逻辑分析100基站维护最短距离动态规划100硬件产品销售方案深度优先搜索100计算网络信号广度优先搜索200核酸最快检测效率动态规划200异常的打卡记录字符串操作100最大数字单调栈200字符串解密逻辑分析100 什么是华为OD机试 华为OD机试是华为的笔试（因为是在电脑上做题，所以称为机试）。主要用于评估求职者是否适合所申请的职位。
华为OD机试通常涵盖了多个测试领域，如算法构造、编程技巧以及错误修复等，其目标是全面评估求职者的基础知识、实践技能和编程逻辑等能力。这是华为招聘过程中至关重要的一步。
华为OD的笔试+面试流程 华为OD面试流程主要包括以下环节：
在线笔试：测试候选人的基础知识、算法构造和编程技巧等。试题类型多样，包括但不限于算法问题、编程问题和数据结构问题。
性格评估：性格评估主要是用来了解求职者的个性特点，以更准确地评估他们的适应性、交际能力以及团队协作能力等。
技术面试：此轮面试通常由项目组的技术负责人进行，主要测试求职者对技术的理解和实践能力。面试内容可能包括代码问题和项目问题解答。
小组面试：华为的特色环节，一般会安排多名求职者进行群体面试，以更全面地评估他们的团队协作、沟通技巧以及领导才能等。
最终面试：这是面试的最后一轮，通常由公司的高级领导或人力资源部门的负责人进行。其主要目标是评估求职者的全面素质和潜在的领导能力。
在线笔试和性格评估是常规流程，所有岗位的必经历程。而其他环节不一定所有岗位都有。最后的面试结果会基于个人表现和竞争状况进行决定，而不会设定一个固定的通过人数。
机试通过率高吗 根据华为公开的信息，华为OD机试的通关比例大约在75%左右。华为OD员工包含五个等级，分别是D1至D5，对应着13至17的级别，每个等级的题目数和难度都各不相同。据历年的招聘情况统计，大约只有四分之一的候选者能成功通过初次的在线测试。而第二轮的性格测试相比较机试就简单多了，只要你尽量表现得像个正常人，基本都能过。不过，最后的通过比例取决于候选者的实际表现及竞争状态，不会设定固定的通过人数。
总体来看，虽然华为OD在线测试的通过率并未达到100%，但仍然保持在一个较高的水平。对于候选者来说，全面提升自身的各项能力是更好地通过在线测试的关键。
薪资待遇 级别年薪年终股权所需工作经验1318万2.5万0.3万1年1424万5.4万2.0万2年1532万12万6.8万3年1640万14万8.8万4.5年1752万19万10万5.5年1860万40万20万8年 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c782dc1a178944f87e631e2e60552274/" rel="bookmark">
			python基础-面向对象（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入： 当我们在进行游戏制作时，往往需要多个角色，但是其都有许多相似的属性，例如：名字，年龄，性别...这些共有的属性通过基本的代码实现会有较高的重复率，并且使用起来也多有不便，此时，我们就需要引入面向对象来使问题得到简化。
面向对象的使用： 面向对象编程适用于：
复杂的·，拥有开放式结局的程序（游戏，购物）
在我们进行创建人物时，我们可以构建一个类，然后进行实例化，一次来进行面向对象的使用
class person(): def __init__(self,name,age,gender,user): #定义一个person类，定义多个属性 self.name = name self.age = age self.gender = gender self.user = user class student(person): #继承person的属性 def resigter(self,password): #设设注册方法，进行拥护注册 self.password = password line = "{}|{}".format(self.user,self.password) with open("login.txt",mode="a",encoding="utf-8") as file: file.write("{}\n".format(line)) class teacher(person): #继承 def find_user(self,user): #定义find——user方法，判断学生是否已经注册用户 self.user_root = user flag = 0 with open("login.txt",mode="r",encoding="utf-8") as file_root: for line in file_root: user_root_file = line.strip().split("|")[0] if self.user_root == user_root_file: flag = 1 if flag: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c782dc1a178944f87e631e2e60552274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688425128a4f955aee0fb29b1b788727/" rel="bookmark">
			案例105:基于微信小程序的文章管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
微信端功能模块的实现
注册登录界面
首页界面
文章界面
我要发帖界面
添加文章界面
我的收藏管理界面
管理员功能模块的实现
管理员登录界面
用户管理界面
作者管理界面
文章管理界面
文章分类管理界面
论坛管理界面
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着计算机技术的成熟，互联网的建立，如今，PC平台上有许多关于文章管理方面的应用程序，但由于使用时间和地点上的限制，用户在使用上存在着种种不方便，而开发一款基于微信小程序的文章管理系统，能够有效地解决这个问题。
本基于微信小程序的文章管理系统是针对文章管理而开发，采用微信开发者工具进行微信端开发，使用MYSQL数据库进行系统数据的储存，系统满足用户通过微信客户端进行文章管理的需求。本小程序是以微信为入口的，可以说是在自带接近10亿的流量人口。整个系统不仅操作简单、便捷，而且节约用户的时间及资源成本等，仅需通过一部手机和微信号即可满足用户们的需求。
论文首先阐述了基于微信小程序的文章管理系统的开发背景，并对开发基于微信小程序的文章管理系统所采用的相关技术进行了详细的介绍，然后对此应用软件进行了需求分析、设计，最后对系统进行测试、维护，保证系统的正常运行。
系统展示 微信端功能模块的实现 注册登录界面 没有账号的用户可进行注册操作，注册时可选择注册类型进入对应角色的注册界面，注册后可进行登录系统
首页界面 所有用户登录后均可进入首页查看首页信息 文章界面 用户登录后可查看文章信息，并可根据条件快速查询所需文章，可选择文章进行查看详情操作 我要发帖界面 作者和用户登录后均可进行发帖操作 添加文章界面 作者登录后可进行添加文章操作 我的收藏管理界面 用户和作者均可管理个人收藏信息 管理员功能模块的实现 管理员登录界面 管理员要想进入系统后台对系统进行管理操作，必须登录系统后台 用户管理界面 管理员登录后可添加、修改和删除用户信息
作者管理界面 管理员在作者管理界面可查看所有作者信息，对已有作者信息可进行编辑和删除操作，同时也可添加作者信息
文章管理界面 管理员可管理文章信息，对已有文章信息可进行编辑和删除
文章分类管理界面 管理员可增删改查文章分类信息
论坛管理界面 管理员可管理论坛信息
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/688425128a4f955aee0fb29b1b788727/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/21/">«</a>
	<span class="pagination__item pagination__item--current">22/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/23/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>