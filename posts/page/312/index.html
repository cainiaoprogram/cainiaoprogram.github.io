<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0733f4e6458b3a00c3f8be56191ca14c/" rel="bookmark">
			android9.0官方下载,安卓9.0系统刷机包 官方正式版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓9.0系统安装包是安卓最新推出的新一代操作系统。这一次代号“Pi”，预计是馅饼pie的缩写，使用Pie的代号一点都不让我们惊讶，因为历代Android系统的代号，谷歌都是偏爱用美食或甜点来命名，其实还是蛮有趣的。
为了解决碎片化严重的这个问题，谷歌之前在安卓系统开启了Project Treble模式，不过各大手机厂商支持力度并不好，而从Android 9.0开始，谷歌要深度集成这个模式。
Project Treble最大的好处除了能帮OEM厂商更快的为自家手机提供最新的系统更新，同时还可以让开发者更加便利的定制和修改自己的系统，而无须等待厂商适配，如果你的手机支持这个模式，那么完全不用在担心没有新系统可以更新了。所以从这个角度上来看，Android 9.0上Project Treble模式如何被进一步完善，才是最大看点。
【功能特点】
通知消息调整
应用通知消息角标
画中画模式
智能文字选择工具栏(集成谷歌Assistant)
后台应用进程限制
自适配性应用图标
媒体录制API优化
大量针对企业用户的新功能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae1086a975c32b52feb9050f51a547a/" rel="bookmark">
			android compress函数,Linux Kernel(Android) 加密算法小结（cipher、compress、digest）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux Kernel(Android) 加密算法总结(cipher、compress、digest)
1. Linux内核支持哪些加密算法 ？
内核支持的加密算法很多，包括：
对称加密算法，如AES；
摘要算法，如sha1,md5；
压缩算法，如deflate。
不过内核好像不支持非对称加密算法。
2. 加密算法源文件位置
这些算法作为加密函数框架的最底层，提供加密和解密的实际操作。这些函数可以在内核crypto文件夹下，相应的文件中找到。
3. 配置编译选项将加密算法作为模块编入内核
Cryptographic options
加密选项
Cryptographic API
提供核心的加密API支持.这里的加密算法被广泛的应用于驱动程序通信协议等机制中.子选项可以全不选,内核中若有其他部分依赖它,会自动选上
Cryptographic algorithm manager
创建加密模版实例,必须要选
HMAC support
为IPSec所必须,可为PPPoE提供压缩支持
Null algorithms
NULL加密算法(什么也不做),用于IPsec协议的封装安全载荷模块(ESP)
MD4 digest algorithm
老旧的摘要算法,已经过时
MD5 digest algorithm
主流摘要算法,128位(已被中国山东大学王小云攻破,可以快速找到碰撞)
SHA1 digest algorithm
主流摘要算法,160位(已被中国山东大学王小云攻破,可以快速找到碰撞),速度与MD5相当
SHA256 digest algorithm
更好的摘要算法,256位,速度较SHA1稍慢
SHA384 and SHA512 digest algorithms
更好的摘要算法,384/512位,速度大约只有SHA1的40-50%
Whirlpool digest algorithms
最安全的摘要算法,512位,已被列入ISO标准,目前最新版本为3.0(2003年发布)
Tiger digest algorithms
号称最快的摘要算法,192位,专门为64位CPU进行了优化
ECB support
电子密码本,最简单的加密方法
CBC support
密码块链,IPSec需要使用它
DES and Triple DES EDE cipher algorithms
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ae1086a975c32b52feb9050f51a547a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b7e28b85a378d09ad44ee8020ae4fd9/" rel="bookmark">
			【论文】未：考虑出行距离和时延的基于小区的动态拥塞定价方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解读A cell-based dynamic congestion pricing scheme considering travel distance and time delay 摘要 该研究引入了动态网络中考虑实际出行距离和时间延迟的动态拥挤定价问题(DCP)(dynamic congestion pricing)(即联合距离和时间延迟收费)，与现有的收费方案相比，该问题更加公平有效。系统动力学可以体现在两个方面:🐸(1)出行者的路径选择决策遵循动态用户均衡原则；🐸(2)联合距离和延时费用呈现时变模式。在整个建模过程中采用了多时段需求方案，并建立了一个双层规划模型，以获得最优的收费值。数值结果表明，与静态联合公交换乘方案、动态联合距离和时间收费方案以及动态纯距离收费方案相比，动态联合公交换乘方案的最小系统总出行时间分别减少了6.28%、4.30%和7.45%。
1. Introduction 拥挤收费(congestion pricing )作为交通管理的需求侧策略之一，被经济学家广泛认为是缓解城市交通拥挤问题、提高系统性能的有效经济手段，也越来越受到学术界和实务界的关注。拥挤定价的研究主要集中在第一最优定价(first-best pricing和第二最优定价(secongd-best pricing)。在交通网络建模和分析中，大多数研究认为网络中的每一个链接(link)都是第一最优定价方案(如杨、黄1998；Sumalee和徐(2011)，而网络中只有一部分链接被评为次优定价方案(如刘和麦当劳1999；Verhoef 2000，2002；张等2011；刘、孟、王2014；狄、刘、班2016；韩、王、朱(2017)；感兴趣的读者可以从杨和黄(2005)那里得到全面的评论。
拥挤收费的一个关键问题是确定收费标准。大多数实施的拥挤收费政策在基于警戒线的收费方案中采用统一(固定)收费方法，包括按次收费(pay-per-entry charge)和每日许可证收费(daily licensing charge)，而不考虑警戒线收费区内的实际行驶距离。因此，这种收费方法可能会因长途旅行少收费和短途旅行多收费而造成不公平的收费问题，并会造成破坏性的问题，因为它可能会增加警戒线以外的边界路线的拥挤程度(May等人，2008年)。此外，这种收费方式并不能完全缓解交通拥堵，因为一部分司机可能会有计划地利用警戒线以内的更多路段，以最大限度地提高已付费用的效用(孟，刘，王，2012)。这实际上可能会增加警戒线区域内的拥挤现象。因此，为了充分发挥拥挤收费在缓解城市交通拥堵中的作用，提高拥挤收费的公平性和有效性，需要考虑警戒线收费区内的出行距离(或使用量)，建立基于距离的拥挤收费方案。孟，刘，王(2012)和刘等人(2017)提出了最优基于距离的拥挤收费问题，并采用分段线性函数来制定非线性基于距离的收费。值得注意的是，基于距离的定价方案将是新加坡下一代电子道路定价(ERP)系统(新加坡陆路运输管理局，2013年)。
然而，正如刘、王和孟(2014)所言，基于距离的定价模型仍然有其局限性:出行者会有意选择较短的路线来减少定价警戒线内的通行费，而不管该路线是否高度拥堵。为了解决这个问题，他们提出了一个联合距离和时间收费(JDTT)方案(joint distance and time toll scheme)。然而，就自由流行驶时间而言，距离通行费和时间通行费之间存在重叠。例如，一个旅行者沿着一条特定的路线穿过收费警戒线，花了15分钟，在警戒线内行驶了6公里。然而，当网络处于自由流动状态时，同样的路线只需要12分钟。在基于距离的收费部分，它已经包含了自由流交通状态(free-flow traffic state)下的收费，因为所经历的路线的总长度是固定的，并且与恒定的自由流行驶时间有关。这种重叠意味着JDTT中存在过度收费，并导致次优化(sub-optimality)。因此，这部分应该被切掉。为此，应以基于时间延迟的收费方案取代基于时间的收费。在本文中，我们将该方法扩展到了联合距离和延时收费，它比联合距离和延时收费更有效。
对于拥挤收费问题，大多数研究集中在静态交通网络的确定性过程。然而，基于静态交通分配的拥挤定价存在显著的局限性(Chiu等人，2011；Chung等人，2012年；董和马赫马萨尼2013)。静态模型只关注出行者的静态路径选择决策，静态用户均衡忽略了交通流的时间依赖性。此外，在静态定价模型中没有考虑当前通行费对未来拥堵水平的影响(Wie和Tobin 1998)。此外，由于运输系统的内在动力，人们的旅行行为将随着外部环境的变化而变化。因此，引入动态交通分配理论(DTA)(dynamic traffic assignment)对联合动态交通分配方案的应用十分重要。本研究利用DTA分析理论阐述了JDTDT问题。
动态拥挤定价问题通常被公式化为一个双层规划模型，上层用于优化整个系统的性能，下层用于建模每个个体的动态路径选择。下层问题可以被公式化为一个动态用户均衡(DUE)问题，其目的是确定路线流模式，使得每个OD对的出行者在任何时间的总广义成本相等且最小(冉和博伊斯1996；司徒和罗2004)。在DUE问题中，两个至关重要的问题是流动动力学(flow dynamics)和流动传播约束(flow propagation contraints)。换句话说，如何从路径流中获得实际的路径旅行时间是一个至关重要的问题。在这一领域开展了大量研究(如班等人，2008年；韩、皮考利、弗里斯兹2015；韩、皮考利、赛托2016；黄和拉姆2002；L o n ge ta l .2013L o n g et al.2016詹和Ukkusuri2017)。在本文中，动态交通流分量由基于路径的CTM表示(Doan和Ukkusuri 2012，2015；英国、英国、美国、爱尔兰、日本、荷兰、挪威、荷兰(2012年)。与最初的CTM (Daganzo，1994，1995)相比，基于路径的CTM的主要优点如下:👍(a)小区和小区连接器可以在不同的路径中被跟踪，👍(b)合并和分叉链路处的流量可以在没有外生转向比的情况下被唯一地确定，以及(c )👍不再需要每个小区占用的等待时间。为了避免计算反函数(inverse function)(Lo和Szeto 2002)，提出了一种新的平均方案，用基于路径的CTM的输出来估计每条路径上同时离开的交通的途中行驶时间。在我们提出的平均法引入了两个新的到达时间指标，使途中旅行时间的计算更加简洁。此外，与在整个建模期间采用统一需求作为输入的其他基于小区的动态交通分配模型相比(例如，Lo和Szeto 2002为了更好地描述动态拥挤定价问题，采用了多时段需求方案作为输入。
DUE问题被建模为变分不等式(VI)问题，这是动态拥挤定价问题的下层，而上层是最小化总系统时间。众所周知，双层规划问题是NP难且求解繁琐的(Jeroslow 1985高、吴、孙2005；Rahmani，Jenelius，Koutsopoulos 2015Rahmani和MirHassani 2015Kheirkhah、Navidi和Bidgoli2016)。为此，提出了一种混合自适应梯度投影(SAGP)(hybrid self-adpative gradient prjection)和人工蜂群(ABC)算法(artificial bee colony)求解双层模型，下层采用SAGP算法求解VI问题，上层采用ABC算法求解动态JDTDT问题。请注意，系统动态性可以体现在两个方面:(a)☀️旅行者的路径选择决策遵循DUE原则；(b)☀️JDTDT从静态模式扩展到时变模式，这可以通过改变每个离散时间间隔的通行费值来处理(例如，在新加坡的ERP系统中为30分钟)。在每个时间间隔结束时，出行需求发生变化，因此征收新的JDTDT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b7e28b85a378d09ad44ee8020ae4fd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dfe105ba77651d072fb50cdbc790f82/" rel="bookmark">
			【JAVA】java.util.ArrayList cannot be cast to class java.lang.String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述
21-05-25 14:39:34.110 ERROR [taskScheduler-12] o.s.s.s.TaskUtils$LoggingErrorHandler :95 - Unexpected error occurred in scheduled task java.lang.ClassCastException: class java.util.ArrayList cannot be cast to class java.lang.String (java.util.ArrayList and java.lang.String are in module java.base of loader 'bootstrap') at org.springframework.data.redis.serializer.StringRedisSerializer.serialize(StringRedisSerializer.java:36) at org.springframework.data.redis.core.AbstractOperations.rawValue(AbstractOperations.java:127) at org.springframework.data.redis.core.AbstractOperations.rawValues(AbstractOperations.java:135) at org.springframework.data.redis.core.DefaultZSetOperations.remove(DefaultZSetOperations.java:335) at com.easylive.mgs.stat.service.redis.AudienceRankCache.checkRejectedAudience(AudienceRankCache.java:92) at com.easylive.mgs.stat.job.RankCacheJob.checkRejectedAudience(RankCacheJob.java:72) at jdk.internal.reflect.GeneratedMethodAccessor184.invoke(Unknown Source) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:567) at org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:84) at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) at java.base/java.util.concurrent.FutureTask.runAndReset(FutureTask.java:305) at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:305) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.lang.Thread.run(Thread.java:835) 使用这个方法是传递了一个List导致报错 /** * Remove {@code values} from sorted set.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dfe105ba77651d072fb50cdbc790f82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d317aef9fbca0f4ee4cc40df42bcb4/" rel="bookmark">
			信号完整性仿真SI之Cadence Sigrity SPEED2000_眼图仿真（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享一个仿真的操作流程，是关于Cadence Sigrity SPEED2000的时域波形仿真和眼图仿真。我们会经常看见硬件工程师调试示波器上的一些信号的波形变化，其实这些也可以通过仿真电路的搭建来做出投板前的仿真，来优化走线，以减少版本的迭代次数。如果要和实际的信号保持一致，就要求仿真设置的参数和实际的参数保持一致，这也是仿真的重点和难点。下面先让我们了解一下Cadence Sigrity SPEED2000时域仿真的操作流程：
1.仿真模式选择与文件导入 选择Cadence Sigrity下的SPEED2000组件，然后先择licence，打开组件选择Generator SI Simulation，最后就可以打开我们之前转化好的.SPD文件。操作如下图：
2.设置层叠信息和过孔焊盘参数 层叠信息：每层的介质厚度、材料、介电常数、介质损耗角等，如下图：
过孔焊盘参数：过孔焊盘的镀铜厚度、材料等，如下图：
3.选择仿真的信号网络 选择仿真的信号网络，在添加相应的电源和地，如下图：
4.设置DC的电压值 查看我们刚才选择的电源和地，设置信号的电源的电压值，根据不同的信号有不同的电压值3.3V、1.8V、1.2V等，如下图：
5.设置器件Model 我们仿真的网络是一个控制器和一个存储芯片之间的通信信号，在信号始端端接电阻。所以我们需要添加源端控制器、负载端存储芯片、端接电阻的模型、DC电源器件模型，模型有IBIS、终端端接、SPICE三种，选择我们有的资源就可以。下面的仿真中源端控制器、负载端存储芯片是IBIS模型，端接电阻使用的是Value电阻值设置，DC电源器件使用的是SPICE模型，设置如下图：
源端控制器IBIS模型添加
负载端存储芯片IBIS模型添加
端接电阻Value电阻值设置
DC电源器件SPICE模型添加
所有的器件Model添加完成之后，会在相应的器件前面打勾。
6.设置仿真参数 在这设置仿真的level，一般选择level1，然后选择仿真时间和比特率的大小。其中我们的负载端要选择输入高阻态模式(Input/High-Z)，源端要选择输出(Output)，然后在Transmitter IO Model选择相应的IO端口模型。这个IO端口模型需要根据IBIS模型中的定义来选择，否则端口的model和其pin功能不对应，仿真结果会有偏差。设置如下图：
7.添加探针端口 选择你想要查看的波形的网络端口，可以在其相应的前面打勾，设置如下图：
8.保存文件，开始仿真 设置如下图：
9.查看仿真结果 仿真结束后，可以查看刚才设置探针位置的信号时域波形和眼图，查看如下：
以上是关于Cadence Sigrity SPEED2000的时域仿真的操作流程，在操作流程中可能设置的东西相对来说比较多和复杂，比如我们器件的IBIS的获取，得到了IBIS模型之后还要会识别相应的IO模型。还有如果想要得到眼图仿真的话，需要设置信号的比特率、上升沿等信息。可能本人整理的相对简单，因为我也在不断的学习，以后会持续的总结和大家分享。
以上流程如有遗漏或不对的地方，希望各位大神留言指正，顺便点个赞👍关注，感谢！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d637b2a044b8d89185d18f8d2997d88c/" rel="bookmark">
			由于非法正常关机   导致momgo 连接失败，突然连接不上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		net start mongodb重启服务即可。
net start mongodb 发生系统错误5 。以管理员身份启动cmd即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca397b809e9f26267c3e09a896795153/" rel="bookmark">
			NAT与FULL NAT的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NAT与FULL NAT的区别 LVS 当前应用主要采用 DR 和 NAT 模式，但这 2 种模式要求 RealServer 和 LVS在同一个 vlan中，导致部署成本过高；
TUNNEL 模式虽然可以跨 vlan，但RealServer上需要部署 ipip 模块等， 网络拓扑上需要连通外网，较复杂，不易运维。
为了解决上述问题，我们在 LVS 上添加了一种新的转发模式：FULLNAT
该模式和 NAT 模式的区别是： Packet IN 时，除了做 DNAT，还做 SNAT（用户 ip-&gt;内网 ip），从而实现LVS-RealServer 间可以跨 vlan 通讯， RealServer 只需要连接到内网
FULLNAT 将作为一种新工作模式（同 DR/NAT/TUNNEL），实现如下功能：
1. Packet IN 时，目标 ip 更换为 realserver ip，源 ip 更换为 内网 local ip；
2. Packet OUT 时，目标 ip 更换为 client ip，源 ip 更换为 vip；
注： Local ip 为一组内网 ip 地址；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca397b809e9f26267c3e09a896795153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c0272e103a6bb83821087b402bd63f/" rel="bookmark">
			JavaScript 中 call()、apply()、bind() 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看明白下面：
obj.objAge; // 17 obj.myFun() // 小张年龄 undefined shows() // 盲僧 比较一下这两者 this 的差别，第一个打印里面的 this 指向 obj，第二个全局声明的 shows() 函数 this 是 window ；
1，call()、apply()、bind() 都是用来重定义 this 这个对象的！
obj.myFun.call(db)；　// 德玛年龄 99 obj.myFun.apply(db);　// 德玛年龄 99 obj.myFun.bind(db)();　// 德玛年龄 99 以上出了 bind 方法后面多了个 () 外 ，结果返回都一致！
由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行。
obj.myFun.call(db,'成都','上海')；　// 德玛 年龄 99 来自 成都去往上海 obj.myFun.apply(db,['成都','上海']); // 德玛 年龄 99 来自 成都去往上海 obj.myFun.bind(db,'成都','上海')(); // 德玛 年龄 99 来自 成都去往上海 obj.myFun.bind(db,['成都','上海'])();　// 德玛 年龄 99 来自 成都, 上海去往 undefined 微妙的差距！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61c0272e103a6bb83821087b402bd63f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3edfc479ca55f5192596d3be0c90fe92/" rel="bookmark">
			Java中如何实现一个函数返回多个值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于java中没有指针，不能像C++一样通过指针的方式实现一个函数返回多个值，因此在java中必须采用变通的方式解决，常用的方式有以下几种：
1、封装一个实体类，将要返回的值封装进去；
2、通过map或者数组的方式来返回多个值；
第一种方案不够优雅，而且每次要返回多个值时就去封装一个实体类，这样会导致实体类多到泛滥；
第二种方案必须采用实现方法和调用方法约定的Key或者下标，如果只是系统内部使用问题不大，但是如果与外部系统对接时，调用方不知道具体的Key值或者下标，只能通过文档或者查看代码，通用性不强；
使用EnumMap作为返回值类型，自己定义一个enum，将可能返回的属性名定义为enum取值即可。
使用示例：
1、定义enum值：
1 enum ExpertOpKey {
2 eokAdd,
3 eokDel
4 }
2、实现能返回多个值的方法：
1 private static EnumMap&lt;ExpertOpKey, Object&gt; testFunc() {
2 EnumMap&lt;ExpertOpKey, Object&gt; map = new EnumMap&lt;ExpertOpKey, Object&gt;(ExpertOpKey.class);
3 map.put(ExpertOpKey.eokAdd, “hello, world”);
4 map.put(ExpertOpKey.eokDel, 193);
5
6 return map;
7 }
3、调用方法获取多个返回值：
1 public static void main(String[] args) {
2 EnumMap&lt;ExpertOpKey, Object&gt; map = testFunc();
3 System.out.println(map.get(ExpertOpKey.eokAdd));
4 System.out.println(map.get(ExpertOpKey.eokDel));
5 }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b35b6f61263fe39b46fe6e758801bd/" rel="bookmark">
			Vue使用viewer标签实现列表图片点击放大功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
实现步骤：
1、安装依赖
npm install v-viewer --save
2、页面引入
import Vue from 'vue'; import Viewer from 'v-viewer'; import 'viewerjs/dist/viewer.css'; Vue.use(Viewer) Viewer.setDefaults({ Options: { 'inline': true, 'button': true, 'navbar': true, 'title': true, 'toolbar': true, 'tooltip': true, 'movable': true, 'zoomable': true, 'rotatable': true, 'scalable': true, 'transition': true, 'fullscreen': true, 'keyboard': true, 'url': 'data-source' } }) 3、图片列表
将上传的内容以对象的形式保存在一个数组中，
进而以JSON格式保存在数据库phoneUrl字段里
phoneUrl=“[{name: ‘dog.jpg’,url: ‘http://www.baidu.com/dog.jpg’},{name: ‘cat.jpg’,url: ‘http://www.baidu.com/cat.jpg’},{name: ‘pig.jpg’,url: ‘http://www.baidu.com/pig.jpg’}]”
&lt;el-form-item label="图片" prop="phoneUrl"&gt; &lt;viewer :images="phoneList"&gt; &lt;img v-for="(item, index) in phoneList"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70b35b6f61263fe39b46fe6e758801bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cd4df5daeffd6db66731cc615e868ef/" rel="bookmark">
			【java高级】java.io.InputStream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.概述二.FileInputStream三.缓冲区管理 一.概述 java.io.InputStream是java标准库提供的最基本的输入流，它是一个抽象类，是所有输入流的超类。其中有一个read()方法，会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。
二.FileInputStream InputStream的一个子类。
我们通过查看FileInputStream的官方文档，我们主要看第三个构造函数。
主要看一下read()函数。
package com.sdnu.project1; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; /** * @author Beyong * @Description FileInputStream * @date 2021/05/23 17:52 */ public class Demo1 { public static void main(String[] args) { FileInputStream fileDate = null; try{ fileDate = new FileInputStream("d:\\test.txt"); System.out.println(fileDate.read()); System.out.println(fileDate.read()); System.out.println(fileDate.read()); System.out.println(fileDate.read()); System.out.println(fileDate.read()); System.out.println(fileDate.read()); System.out.println(fileDate.read()); System.out.println(fileDate.read()); System.out.println(fileDate.read()); System.out.println(fileDate.read()); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if( fileDate !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cd4df5daeffd6db66731cc615e868ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/822e32f404d266f24fa904fda3fce767/" rel="bookmark">
			画了一个田径场，可以踢世界杯吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		画了一个田径场，可以踢世界杯吗？ html代码
&lt;div class="box1"&gt; &lt;div class="box2"&gt; &lt;div class="box3"&gt; &lt;div class="box4"&gt; &lt;div class="box5"&gt; &lt;div class="box6"&gt; &lt;div class="box7"&gt; &lt;div class="box8"&gt; &lt;div class="boxRect"&gt; &lt;div class="boxCirc"&gt;&lt;/div&gt; &lt;div class="boxRectLeft1"&gt;&lt;/div&gt; &lt;div class="boxRectRight1"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; css样式
.box1 { background-color: #DA251E; /* 这里使用css的一个表达式，方便加减乘除计算 */ width: calc(1719.2px/2 + 360px*2 - 12.2px*0*2); height: calc(360px*2 - 12.2px*0*2); margin: 100px auto; border: 0.5px white solid; /* 圆角 */ border-radius: calc(360px - 12.2px*0) / 50%; /* 盒子 */ box-sizing: border-box; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/822e32f404d266f24fa904fda3fce767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2667f0350e954ab3ccd983ab240e1009/" rel="bookmark">
			c语言 题目 猜算式,蓝桥杯竞赛题目（猜算式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看下面的算式：
□□ x □□ = □□ x □□□
它表示：两个两位数相乘等于一个两位数乘以一个三位数。
如果没有限定条件，这样的例子很多。
但目前的限定是：这9个方块，表示1~9的9个数字，不包含0。
该算式中1至9的每个数字出现且只出现一次！
比如：
46 x 79 = 23 x 158
54 x 69 = 27 x 138
54 x 93 = 27 x 186
.....
请编程，输出所有可能的情况！
注意：
左边的两个乘数交换算同一方案，不要重复输出！
不同方案的输出顺序不重要
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
public class Main {
static boolean visited[] = new boolean[10];
static List k = new ArrayList();
static int[] vs = new int[10];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2667f0350e954ab3ccd983ab240e1009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9302c93392ab197f40b3554aad4b24d/" rel="bookmark">
			Java中常用的原子类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是原子类二、原子类的底层实现三、常用的原子类3.1、AtomicInteger与AtomicLong3.2、LongAdder 四、原子类的性能测试4.1、测试程序4.2、测试结果4.3、结果分析4.4、底层实现分析 一、什么是原子类 Java中提供了一些原子类，原子类包装了一个变量，并且提供了一系列对变量进行原子性操作的方法。我们在多线程环境下对这些原子类进行操作时，不需要加锁，大大简化了并发编程的开发。
二、原子类的底层实现 目前Java中提供的原子类大部分底层使用了CAS锁（CompareAndSet自旋锁），如AtomicInteger、AtomicLong等；也有使用了分段锁+CAS锁的原子类，如LongAdder等。
三、常用的原子类 3.1、AtomicInteger与AtomicLong AtomicInteger与AtomicLong的底层实现与用法基本相同，不同点在于AtomicInteger包装了一个Integer型变量，而AtomicLong包装了一个Long型变量。
AtomicInteger与AtomicLong的底层实现都使用了CAS锁。
import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong; /** * @author IT00ZYQ * @date 2021/5/24 15:33 **/ public class T13_AtomicInteger { private static AtomicInteger atomicInteger = new AtomicInteger(); private static AtomicLong atomicLong = new AtomicLong(); private static Integer integer = 0; private static Long lon = 0L; public static void main(String[] args) { // 创建10个线程，分别对atomicInteger、atomicLong、integer、lon进行1000次增加1的操作 // 如果操作是原子性的，那么正确结果 = 10 * 1000 = 10000 Thread[] threads = new Thread[10]; for (int i = 0; i &lt; 10; i++) { threads[i] = new Thread(() -&gt; { for (int j = 1; j &lt;= 1000; j++) { atomicInteger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9302c93392ab197f40b3554aad4b24d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718cd0da2219e060a1c8b35873670e50/" rel="bookmark">
			IMEI、IMSI、ICCID、SN是什么？意义和区别？通信模组或手机的唯一识别码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做几个4G移动端的产品，初入行门有很多生涩的名词。想获取一个全球唯一ID作为设备后台管理编号，就扯出了 IMEI、IMSI、ICCID、SN 这几个东西。
IMEI IMEI：国际移动设备识别码 （International Mobile Equipment Identity）。
由15位数字组成，全球唯一ID，用来区别每一部移动通信设备。与手机是绑定关系。
第一部分 TAC，Type Allocation Code，类型分配码。86为中国。
其余的部分没啥有用信息。 典型IMEI码：868540050954128
IMSI IMSI：国际移动用户识别号。（International Mobile Subscriber Identification Number）
由15位数字组成，全球唯一ID，用来区别每一位移动用户。与SIM卡是绑定关系。
第一部分：MCC，移动国家代码 （Mobile Country Code）。3位，中国为460。
第二部分：MNC，移动网络代码（Mobile Network Code）。2位，中国移动使用00、02、04、07，中国联通GSM系统使用01、06、09，中国电信CDMA系统使用03、05，电信4G使用11，中国铁通使用20。（百度上是这么说的，可我的移动物联卡是08…啊这 (⊙ˍ⊙) … ）
第三部分：MSIN，移动订阅用户识别代码（Mobile subscription identification number）。10位。 典型IMSI码：460080585306741
ICCID ICCID：集成电路卡识别码（Integrate circuit card identity）。
由20位数字组成，是IC卡的唯一识别号码。与SIM卡是绑定关系。
前六位为运营商代码：
中国移动的为：898600；898602；898604；898607 。
中国联通的为：898601；898606；898609。
中国电信的为：898603。
其余的部分没啥有用信息。 典型ICCID码: 89860485192072216741
SN SN：Series Number。一般是产品的生产编号。
这个编码就比较随意了，不知道啥规则，英文、数字都有，估计每个厂商的编码规则都不一样。 典型SN码：P1Q21DJ6A0026310P
Q&amp;A Q： IMEI 与 IMSI 的区别 ？
A：IMEI是移动设备识别码，IMSI是移动用户识别码。
都是全球唯一ID。但IMEI绑定于手机设备，而IMSI绑定于SIM卡。
Q：IMEI 注意事项：
A：IMEI和IMSI存在一一对应关系，所以双卡手机有两个IMEI号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/718cd0da2219e060a1c8b35873670e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5f705a160fe2275367af606263c6e95/" rel="bookmark">
			w ndows10摄像头设置,windows10系统电脑摄像头怎么打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常生活中经常有用户会需要使用摄像头，其实现很多的电脑都自带有摄像头功能，可要是当我们需要使用摄像头进行拍摄再者录制视频时，却有很多用户不知windows10系统电脑摄像头怎么打开，别急，今天小编整理了打开电脑摄像头的方法，现分享给大家。
windows10系统电脑摄像头怎么打开?可能大多数的人都不清楚如何操作吧，嘻嘻~你们要是不知道的话，那么下面就让小编我来把打开电脑摄像头的方法分享给大家吧。
windows10系统电脑摄像头怎么打开
一：开启摄像头功能：
1，首先我们要确认自己的电脑是否有摄像头功能，一般在电脑屏幕的上方有个圆形摄像孔的话，说明我们电脑是有这个功能的。
2，在桌面上找到【我的电脑】，单击右键，找到【管理】，点击进入。
打开电脑摄像头图-1
3，在页面左侧找到【设备管理器】，点击打开，然后在右边一栏找到【照相机】。
电脑图-2
4，双击进入，如果框里显示内容为这个设备运转正常，说明你的摄像头功能打开了，如果显示的是禁用，我们就需要解除禁用。
点击 【驱动程序】，再点击【禁用设备】，确认，这个时候会弹出对话框提醒你是否解除禁用，点击确认。
摄像头图-3
电脑图-4
5，然后我们还要点击【更新驱动程序】在弹出的对话框中选择更新，完成后才能成功开启摄像头功能。
电脑摄像头图-5
摄像头图-6
电脑图-7
二：找到应用
1，我们在完成了上述操作后，回到电脑桌面，还是找不到摄像头，那它在哪里呢?
首先点击【开始】菜单，然后点击【所有应用】的图标。
摄像头图-8
2，鼠标下拉就可以找到【相机】了。为了方便我们下次查找，我们可以将它固定到任务栏中。右键【相机】，点击更多，找到【固定到任务栏】选项，点击，然后我们就会发现它在任务栏中出现了。
打开电脑摄像头图-9
摄像头图-10
以上就是打开电脑摄像头的方法了，是不是很简单呢?
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae300f4f1fa36d118910a8b67a0eca3/" rel="bookmark">
			MybatisPlus中使用多表数据，合并数据后再分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 List&lt;Project&gt; projectList = sysProjectMapper.selectList(queryWrapperProject); List&lt;ProjectReported&gt; projectReportedList = sysProjectReportedMapper.selectList(queryWrapper); List&lt;ProjectReported&gt; finalProject = new ArrayList&lt;ProjectReported&gt;(); //强转公司项目成为报备项目 for (Project project : projectList ) { finalProject.add(project); } for (ProjectReported projectReported1 : projectReportedList ) { finalProject.add(projectReported1); } IPage&lt;ProjectReported&gt; iPage = page(new Page&lt;&gt;()); iPage.setRecords(finalProject); iPage.setTotal(finalProject.size()); int startIndex=limit*(page-1); int endIndex= Math.min(limit * page, finalProject.size()); return new LayTableResult&lt;&gt;(iPage.getTotal(), iPage.getRecords().subList(startIndex,endIndex)); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/488f9f537f9099a89aad7653b52b11a4/" rel="bookmark">
			DW网页设计大作业成品品分享，Div&#43;Css，主题如风景、校园、美食、动漫、lol、咖啡...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态网站的编写主要是用HTML DIV+CSS JS等来完成页面的排版设计,一般的网页作业需要融入以下知识点：div布局、浮动、定位、高级css、表格、表单及验证、js轮播图、音频 视频 Flash的应用、ul li、下拉导航栏、鼠标划过效果等知识点，学生网页作业源码可以去大设计师论坛下载，制作水平和原创度都适合学习或交作业用，记得点赞；
网页的风格主题也很全面：如书籍、风景、校园、美食、动漫、游戏、咖啡、音乐、汽车、电影以及个人主页等等主题需要的可以去兔费下（记得点赞）... 附个源码下载地址↓↓↓（源码已更新至本月）：
http://www.psdhtml.cn/index.php?c=thread&amp;fid=18
上面只是一部分网页作品的截图实际上分享出来有上百套了，有5-6个页面的，也有10个页面左右的，自己敲的话每套做下来都差不多要0.5-1天的时间，共享在自己的论坛里（如果全部打包共享到网盘这么多的工作量就可能被他人直接拿去转卖了），请各位戳下方链接阅读下载须知自助免费下载 ↓↓↓
http://www.psdhtml.cn/index.php?c=thread&amp;fid=18
源码有价，感谢理解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cae69dee17edd59bd894dd83dbeb80b/" rel="bookmark">
			ZYNQ-XADC使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习内容 本文首先介绍了ZYNQ的XADC的相关内容，并学习使用ZYNQ芯片中的XADC测量芯片内部的温度电压等参数，然后进行串口打印输出。
开发环境 vivado 18.3&amp;SDK，PYNQ-Z2开发板。
XADC介绍 简介 Xilinx模拟信号转换模块，称为XADC，是一个硬核。它具有JTAG和DRP接口用于访问7系列FPGA中的XADC状态和控制寄存器。Zynq-7000 SoC器件添加了第三个接口，即PS-XADC接口，用于PS软件进行控制XADC。 ZYNQ器件将XADC与可编程逻辑融合，解决了对模拟数据采集和监视要求。
XADC具有两个12位的ADC，具有独立的跟踪和保持放大器，模拟多路复用器（最多17个外部模拟输入通道）以及片上散热和片上电压传感器。可以将两个ADC配置为同时采样两个外部输入模拟通道。采样保持放大器支持一系列模拟输入信号类型，包括单端输入，双端输入和差分输入。模拟输入可以支持信号带宽在1M SPS的采样率下为500 KHz。可以使用外部模拟多路复用器来增加支持的外部通道数量，无需额外的封装引脚。XADC可选地使用片上参考电路，从而无需外部有源元件，用于温度和电源轨的基本片上监控。实现12位的ADC的全部性能，建议使用外部1.25V作为参考电压。最新的测量结果（连同最大和最小读数）存储在专用寄存器。用户可以根据自己的需要进行自定义的警报阈值（例如80°C），可以自动指示温度过高事件和不可接受的电源变化，并启动软件控制的系统掉电。
控制方式 PS端可以通过以下两种方式之一与XADC通信：
PS-XADC接口：PS互连上的32位APB从接口，该接口使用FIFO，并进行了串行化。通过PS to PL AXI的主接口，此时要使用AXI XADC Logic IP核来控制XADC。 需要注意的是，对PS端控制ADC对性能要求较高的程序，要使用相关连接的逻辑IP连接到M_AXI_GP接口（并行数据路径）。使用PS_XADC接口时，FIFO用于命令和读取数据，以允许软件快速排队命令，而不必等待序列化，但是对于PS to PL AXI主接口访问，数据像PL-JTAG一样被序列化到XADC 中（串行数据路径），相对来说速度慢得多。
系统框图 PL-JTAG接口和内部PS-XADC接口不能同时使用。 这些接口之间的选择由devcfg.XADCIF_CFG [ENABLE]位控制。 XADC可以进行接口选择，即对（PL-JTAG或PS-XADC）和DRP接口之间进行仲裁选择。下图为XADC的系统框图。
由上图可知，XADC是通过硬逻辑实现的，并且位于PL电源域中。 PS-XADC接口是PS的一部分，所以无需编程PL就可以由PS APU访问。 但是必须打开PL的电源以配置PS-XADC接口，使用PL-JTAG或DRP接口以及操作XADC。同时由图上可以清楚看出对于PL-JTAG或PS-XADC这两个接口经过了一个二选一选择器，所以这两个不能同时进行驱动。
接口说明 XADC在DRP接口与PS-XADC或PL-JTAG接口之间进行仲裁。
PS-XADC Interface： PS-XADC接口是PS中运行的软件使用devcfg寄存器配置接口。 软件将命令写入接口，然后将其推入命令FIFO。 这些由DRP命令，地址和数据组成的32位写入被串行化，并以回送路径发送到XADC，该回送路径填充了软件读取的返回读取数据FIFO。
DRP Interface： DRP接口是一个并行的16位双向接口，可以使用AXI4-Lite接口通过AXI XADC IP核连接到主机上，以使处理器能够控制XADC。IP内核通过每个AXI4-Lite读/写事务接收16位数据。
PL JTAG Interface： XADC使用完整的JTAG接口扩展到DRP接口。 这允许通过现有的片上JTAG基础结构对XADC DRP进行读/写访问。 通过JTAG访问DRP接口不需要实例化。 边界扫描指令（6位指令= 110111）称为XADC_DRP，已添加到7系列FPGA中，允许通过JTAG TAP访问DRP。 所有XADC JTAG指令均为32位宽。
PS-XADC接口编程指南 本文主要使用的是PS-XADC接口对XADC进行编程控制，下面给出相关操作的编程指导步骤。
通过PS-XADC接口初始化XADC 对通道和XADC进行复位操作，并刷新FIFO，操作顺序如下：
复位串行通讯通道。 先后把1和0到devcfg.XADCIF_MCTL[RESET]寄存器位中；复位XADC。 把16位任意值写入DRP地址0x03（复位寄存器）。接着写08030000h到devcfg.XADCIF_CMDFIFO寄存器中；刷新FIFO。 这里刷新FIFO没有复位信号，而是将15个NOOP写入到FIFO；然后等待命令FIFO清空。 最后一个命令应该是NOOP（虚拟写入），最后读取读取数据FIFO，直到为空。 命令准备 准备要写入XADC寄存器的数据配置顺序：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cae69dee17edd59bd894dd83dbeb80b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8fed8e133fd71c0d049c8096328aa2e/" rel="bookmark">
			Prometheus源码学习(9) scrape-target
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要作用 scrape.Target 是一次抓取的具体对象，包含了抓取和抓取后存储所需要的全部信息。从 targetGroup.Group 到 scrape.Target 的转换过程如下：
targetsFromGroup函数遍历每个targetGroup.Group中的Target，合并targetGroup.Group的公共标签集（记为A）和这个Target本身的标签集（记为B）为标签集C。populateLabels函数从C和*config.ScrapeConfig中创建Target。 以下是具体代码
target 定义 target 是 scrapePool 抓取的最终目标，描述一个 HTTP 或 HTTPS 端点。target 结构体内嵌了 MetricMetadataStore 接口类型的字段 metadata。
// TargetHealth describes the health state of a target. type TargetHealth string // The possible health states of a target based on the last performed scrape. // 目标的三种健康状态值，基于最后一次抓取来设置。 const ( HealthUnknown TargetHealth = "unknown" HealthGood TargetHealth = "up" HealthBad TargetHealth = "down" ) // Target refers to a singular HTTP or HTTPS endpoint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8fed8e133fd71c0d049c8096328aa2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b5b63b8628b0b06ac17fa29221f60c1/" rel="bookmark">
			ch454c语言程序实例,CSDN18luck手机客户端下载 -IT新利18官网登录 大本营
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux-0.11 [内核源代码带中文注释]
!!SYS_SIZE is the number of clicks (16 bytes) to be loaded.!0x3000 is 0x30000 bytes = 196kB,more than enough for current!versions of linux!SYS_SIZE 是要加载的节数(16 字节为1 节)。0x3000 共为 1 2 3 4 5 6 0x7c00 0x0000 0x90000 0x10000 0xA0000 system 模块 代码执行位置线路 0x90200!0x30000 字节=192 kB(上面Linus 估算错了),对于当前的版本空间已足够了。!SYSSIZE = 0x3000!指编译连接后system 模块的大小。参见列表1.2 中第92 的说明。!这里给出了一个最大默认值。!!bootsect.s (C) 1991 Linus Torvalds!!bootsect.s is loaded at 0x7c00 by the bios-startup routines,and moves!iself out of the way to address 0x90000,and jumps there.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b5b63b8628b0b06ac17fa29221f60c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478d51bda4f4ab3a9fd3d0fb0e1d6f96/" rel="bookmark">
			Activiti监听器使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 上一篇在讲分配处理人时其实就已经有用到监听器了，Activiti最灵活的点便是其提供了多种多样的监听器及对应的监听事件，能实现绝大部分业务需求，因此学会使用监听器也是掌握Activiti非常重要的一个步骤。
二、监听器使用场景 在使用Activiti时，其通常作为底层引擎使用，而引擎通常与业务是分开的，因此需要引擎去推动业务，即流程执行到某个阶段时，我们才去执行相对应的业务逻辑，这便依赖Activiti的监听器。常见的场景有：
1、环节人员动态分配
2、某个环节开始或结束时需要记录环节信息，或者插入一些记录数据
3、任务开始或结束时需要做一些自定义的业务
...
总之监听器就是用来满足各种各样复杂的业务需求
三、监听器类别 按照监听的类型来划分，大致有三种：
执行监听器任务监听器事件监听器 下面一一介绍
1、执行监听器（ExecutionListener） 该监听器可以配置在节点和线，主要有三种事件类型：
start：开始时触发end：结束时触发take：主要用于监控流程线，当流程流转该线时触发 既然要使用监听器，那肯定得先自己自定义一个，需要实现org.activiti.engine.delegate.ExecutionListener，如下：
package activiti.activiti.listener; import org.activiti.engine.delegate.DelegateExecution; import org.activiti.engine.delegate.ExecutionListener; /** * Created by xujia on 2020/2/6 */ public class ExecutionListenerImpl implements ExecutionListener { @Override public void notify(DelegateExecution delegateExecution) { String event = delegateExecution.getEventName(); switch (event) { case "start" : System.out.println("start event"); break; case "end" : System.out.println("end event"); break; case "take" : System.out.println("take event"); break; } } } 然后便是在流程图处进行配置，首先看下我绘制的简单流程图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/478d51bda4f4ab3a9fd3d0fb0e1d6f96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76642f02b622038f4028d51c3e4269a3/" rel="bookmark">
			golang自定义中间件的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 func main() { engine := gin.Default() engine.Use(RequestInfos()) engine.GET("/query", func(context *gin.Context) { fmt.Println(" 中间件的使用方法 ") context.JSON(404, map[string]interface{}{ "code": 1, "msg": context.FullPath(), }) }) engine.Run(":9000") } func RequestInfos() gin.HandlerFunc { return func(context *gin.Context) { path := context.FullPath() method := context.Request.Method fmt.Println("请求Path：", path) fmt.Println("请求Method：", method) context.Next() fmt.Println(context.Writer.Status()) } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4826dd48a0076eaa64bfd53e36087073/" rel="bookmark">
			【Web前端HTML5&amp;CSS3】06-盒模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记来源：尚硅谷Web前端HTML5&amp;CSS3初学者零基础入门全套完整版
文章目录 盒模型1. 文档流（normalflow）2. 块元素3. 行内元素4. 盒子模型盒模型、盒子模型、框模型（box model）内容区（content）边框（border）内边距(padding）外边距（margin） 5. 水平方向布局6. 垂直方向布局元素溢出边距折叠兄弟元素父子元素 脱离文档流 7. 行内元素的盒模型8. 浏览器的默认样式reset样式normalize样式 盒模型 1. 文档流（normalflow） 网页是一个多层的结构，一层摁着一层
通过CSS可以分别为每一层来设置样式，作为用户来讲只能看到最顶上一层
这些层中，最底下的一层称为文档流
文档流是网页的基础我们所创建的元素默认都是在文档流中进行排列
对于我们来元素主要有两个状态
在文档流中不在文档流中（脱离文档流） 那么元素在文档流中有什么特点，我们接着往下看
2. 块元素 块元素会在页面中独占一行默认宽度是父元素的全部（会把父元素撑满）默认高度是被内容撑开（子元素） 3. 行内元素 行内元素不会独占页面的一行，只占自身的大小行内元素在页面中左向右水平排列（书写习惯一致）如果一行之中不能容纳下所有的行内元素，则元素会换到第二行继续自左向右排列行内元素的默认宽度和高度都是被内容撑开 4. 盒子模型 网页设计中常听的属性名：内容(content)、内边距(padding)、边框(border)、外边距(margin)， CSS盒子模型都具备这些属性。
这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模型。
CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。1
盒模型、盒子模型、框模型（box model） CSS将页面中的所有元素都设置为了一个矩形的盒子
将元素设置为矩形的盒子后，对页面的布局就变成将不同的盒子摆放到不同的位置
每一个盒子都由一下几个部分组成：
内容区（content）内边距（padding）边框（border）外边距（margin） 内容区（content） 内容区是盒子模型的中心，它呈现了盒子的主要信息内容，这些内容可以是文本、图片等多种类型
元素中的所有的子元素和文本内容都在内容区中
width和height 设置排列内容区的大小width 设置内容区的宽度height 设置内容区的高度 示例
.box1{ width: 200px; height: 200px; background-color: #bfa; } 效果
边框（border） 边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部
注意：边框的大小会影响到整个盒子的大小
border-width 边框的宽度：默认3px border-top-width 上边框的宽度border-right-width 右边框的宽度border-bottom-width 下边框的宽度border-left-width 左边框的宽度 border-color 边框的颜色：默认使用color的颜色值border-top-color 上边框的颜色border-right-color 右边框的颜色border-bottom-color 下边框的颜色border-left-color 左边框的颜色border-style 边框的样式：没有默认值，必须指定 border-top-style 上边框的样式border-right-style 右边框的样式border-bottom-style 下边框的样式border-left-style 左边框的样式 示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4826dd48a0076eaa64bfd53e36087073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79070bb77c6c335e917b19d7ad1ee6e3/" rel="bookmark">
			（Java实习生）每日10道面试题打卡——Java基础知识篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		临近秋招，备战暑期实习，祝大家每天进步亿点点！本篇总结的是Java基础知识相关的面试题，后续会每日更新~ 1、请你说一下什么是面向对象？ Java是面向对象的编程语言，不同于C语言是面向过程的。对于面向对象和面向过程的区别，举一个简单的例子说明一下（我们以洗衣机洗衣服为例）：
面向过程：面向过程的编程方式，程序会将要完成的某一个任务拆解成一系列的小步骤 (函数)，如： ① 打开洗衣机：method01()② 放入要洗的衣服：method02()③ 放入洗衣服：method03()④ 清洗：method04()⑤ 烘干：method05() 面向对象：面向对象的编程方式，程序会将要完成的洗衣机洗衣服的任务拆分成如下两个对象： 人(Person)：Person在洗衣机洗衣服这个程序任务中有三个作用，分别是打开洗衣机、放入要洗的衣服、放入洗衣粉。洗衣机(Machine)：Machine在洗衣机洗衣服这个程序任务中有两个作用，分别是清洗、烘干。 从上面这个例子能看出，面向过程的编程方式比较直接且高效，而面向对象的编程方式更易复用、扩展和维护！
2、请你简述一下面向对象的三个基本特征？ 继承：承是Java中面向对象最显著的一个特征，继承是从已有的类中派生出新的类，新的类可以吸收已有的属性、行为，并扩展新的能力。Java中不支持多继承，但是接口可以支持多实现。
封装：将同一类事物的特征和功能包装在一起，只对外暴露需要调用的接口。封装也称为信息的隐藏，在Java中接口是体现封装最常用的方法，在接口中我们没有任何功能的实现(具体实现都交给实现类)，只是定义了一系列抽象的方法声明用于外部调用。
多态：封装和继承都是为多态来服务的，多态是指同一个行为具有多个不同的表现形式。在Java中方法的重载和重写是实现多态的2种方式。
重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。方法重载体现了编译时的多态性。重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，重载对返回类型没有特殊的要求。方法重写体现了运行时的多态性。 多态的三要素：继承 、重写、父类指向子类引用！
3、为什么说 Java 是一种半解释半编译的程序设计语言呢？ 什么是编译形语言，什么又是解释形语言？
编译型语言：把做好的源程序全部编译成二进制代码的可运行程序。然后，就可以直接运行这个程序。执行速度快，效率高，依靠编译器，跨平台性稍差。解释型语言：把已经做好的源程序，翻译一句，执行一句，直到结束。执行速度慢，效率低，依靠编译器，但是跨平台性稍好。 那么为什么说Java 是编译型语言呢？
第一个观点认为 Java 是编译型语言，因为Java程序想要运行，那么第一步就是要使用Javac进行编译(将Java源文件编译成.class二进制文件)。没有经过编译的.java文件，是没办法运行的！
那么为什么又说Java 是解释型语言呢？
那么第二个观点则是认为Java是解释型语言，Java经过编译，Javac 将.java源文件编译成.class二进制文件之后，仍然需要借助 JVM 的解释执行。
综合上面两个观点来看，Java似乎既有编译型语言的特点，又有解释型语言的特点，也没有看到哪本权威的书籍上认定Java就是哪一种类型的语言。
4、请你说一下Java中的8大基本类型是那些？ 如图所示：
8种基本数据类型和取值范围：
基本类型大小(位/bit)字节数(byte)最小值最大值默认值包装器类型boolean--falsetruefalseBooleanchar16 bits2 bytesUnicode 0Unicode 2^16-1空Characterbyte8 bits1 byte-2^72^7-10Byteshort16 bits2 bytes-2~152^15-10Shortint32 bits4 bytes-2^312^31-10Integerlong64 bits8 bytes-2^632^63-10Longfloat32 bits4 bytes0.0Floaddouble64 bits8 bytes0.0Double 注意：对于boolean值，在Java规范中并没有给出其储存大小，在《Java虚拟机规范》中给出了4个字节，和boolean数组1个字节的定义，具体还要看虚拟机实现是否按照规范来，所以1个字节、4个字节都是有可能的。除了void之外，其他8种基本数据类型被称为八大基本数据类型。
图中从左向右的转换都是隐式转换，无需再代码中进行强制转换。从右向左均要进行强制类型转换，才能通过编译。强制转换会丢失精度。
5、请你讲讲抽象类和接口有什么区别? (一) 继承方面：
抽象类只能单继承；而接口可以多实现； (二) 成员属性方面：
抽象类中可以有普通属性，也可以有常量；接口中的成员变量全部默认是常量，使用public static final修饰，这个可以省略不写; (三) 代码块方面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79070bb77c6c335e917b19d7ad1ee6e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b8ce75b654d80a901e607576f08ef91/" rel="bookmark">
			ViLT：最简单的多模态Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之所以用这一篇作为多模态的开篇是因为这篇清楚的归纳了各种多模态算法，可以当成一个小综述来看，然后还提出了一种非常简单的多模态Transformer方法ViLT。
先阐述一下4种不同类型的Vision-and-Language Pretraining(VLP)，然后归纳2种模态相互作用方式和3种visual embedding方式，最后讲一下ViLT的设计思路。
01
Taxonomy of VLP 上图是4种不同类型的VLP模型示意图。其中每个矩形的高表示相对计算量大小，VE、TE和MI分别是visual embedding、text embedding和modality interaction的简写。
作者提出这4种类型的主要依据有两点：
1.在参数或者计算上，两种模态是否保持平衡。
2.在网络深层中，两种模态是否相互作用。
VSE、VSE++和SCAN属于(a)类型。对图像和文本独立使用encoder，图像的更重，文本的更轻，使用简单的点积或者浅层attention层来表示两种模态特征的相似性。
CLIP属于(b)类型。每个模态单独使用重的transformer encoder，使用池化后的图像特征点积计算特征相似性。
ViLBERT、UNTER和Pixel-BERT属于(c)类型。这些方法使用深层transformer进行交互作用，但是由于VE仍然使用重的卷积网络进行特征抽取，导致计算量依然很大。
作者提出的ViLT属于(d)类型。ViLT是首个将VE设计的如TE一样轻量的方法，该方法的主要计算量都集中在模态交互上。
Modality Interaction Schema 模态交互部分可以分成两种方式：一种是single-stream(如BERT和UNITER)，另一种是dual-stream(如ViLBERT和LXMERT)。其中single-stream是对图像和文本concate然后进行交互操作，而dual-stream是不对图像和文本concate然后进行交互操作。ViLT延用single-stream的交互方式，因为dual-stream会引入额外的计算量。
Visual Embedding Schema 现有的VLP模型的text embedding基本上都使用类BERT结构，但是visual embedding存在着差异。在大多数情况下，visual embedding是现有VLP模型的瓶颈。visual embedding的方法总共有三大类，其中region feature方法通常采用Faster R-CNN二阶段检测器提取region的特征，grid feature方法直接使用CNN提取grid的特征，patch projection方法将输入图片切片投影提取特征。ViLT是首个使用patch projection来做visual embedding的方法。
02
ViLT Model Overview
作者提出的ViLT可以认为是目前最简单的多模态Transformer方法。ViLT使用预训练的ViT来初始化交互的transformer，这样就可以直接利用交互层来处理视觉特征，不需要额外增加一个视觉encoder。
文本特征输入部分，将文本看成一个词序列，通过word embedding matrix转化成word embedding，然后和position embedding进行相加，最后和modal-type embedding进行concate。
图像特征输入部分，将图像切块看成一个图像块序列，通过linear projection转化成visual embedding，然后和postion embedding进行相加，最后和modal-type embedding进行concate。
其中word embedding和visual embedding通过可学习的modal-type embedding标志位来区分，其中0标志位表示word embedding部分，1标志位表示visual embedding部分。
wrod embedding和visual embedding分别都嵌入了一个额外的可学习[class] embedding，方便和下游任务对接。
Pretraining Objectives
ViLT预训练的优化目标有两个：一个是image text matching(ITM)，另一个是masked language modeling(MLM)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b8ce75b654d80a901e607576f08ef91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4986ad47d68a57087450a482ab203e/" rel="bookmark">
			JS中多线程的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS中如何使用多线程 介绍 Worker可以为JavaScript创建多线程，且Worker 是运行在后台的
JavaScript，独立于其他脚本，不会影响页面的性能。主线程在运行的时候，worker也在后台运行，两者互不干扰，当worker线程完成任务后就可以将结果返回给主线。
当创建一个新的worker时，该代码会运行在一个全新的javascript的环境中,是完全和原JS隔离，这时我们把原JS(创建新worker的)脚本叫做主线程，而被创建的新的worker叫做子线程
浏览器的支持程度 除了 Internet Explorer外，其他主流浏览器均支持 Web Worker。
Worker的使用 1. 创建Worker对象 var worker=new Worker("xxx.js"); //xxx.js是子线程所执行的js文件 2. 传入参数 worker.postMessage(参数); 3. 获取返回的参数 worker.addEventListener('message', function (e) { console.log('message ', e.data); }); 4. 异常处理 worker.onerror = function (err) { } 5. 终止线程(过多的开启worker线程非常浪费资源所以在使用过后可以终止它) worker.terminate(); 6. 执行的子线程中接收参数 self.onmessage = function(event) { console.log("onmessage:",event.data); }; 7. 执行的子线程向主线程传值 postMessage(子线程中的值); 8. 子线程中终止 self.close(); 示例 场景 js通过http请求客户端本地的服务(实现读卡功能) 1. 主线程js var jzk_worker=new Worker("Web_1920/js/child_thread/jzk.js"); jzk_worker.postMessage("in"); //接收消息 jzk_worker.addEventListener('message', function (e) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c4986ad47d68a57087450a482ab203e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c4537fe2e29419779c02f3272fe0d2/" rel="bookmark">
			Java对象监视器Monitor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、ObjectMonitor结构体二、Monitor原理 一、ObjectMonitor结构体 Monitor是基于C++代码中的ObjectMonitor结构体实现的。
ObjectMonitor() { _header = NULL; _count = 0; // 由于synchronized是可重入锁，count用于记录当前对象锁拥有者线程获取锁的次数 _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; _WaitSet = NULL; // 调用了wait方法，处于WAIT/TIME_WAIT的线程，会被加入到WaitSet _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; // 处于等待锁block状态的线程，会被加入到EntryList _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; } 二、Monitor原理 在Java虚拟机（HotSpot）中，对象监视器主要是基于ObjectMonitor结构体中的EntrySet、WaitSet两个队列以及计数器count实现的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c4537fe2e29419779c02f3272fe0d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b11b05b43ebbd7ebb00a54edab40660/" rel="bookmark">
			【源码阅读】AndPermission源码阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://www.jianshu.com/p/24a33acb7eb6 前言 权限是绝大多数App必不可少的部分，不管你仍在用原生的方式，还是其他的开源库，AndPermission绝对是值得学习的一个开源库，今天，我们就来学习下它的设计思想。
AndPermission 思路 权限库的思路大体上都如下图所示，也玩不出太复杂的花样。
image.png
使用 1.添加引用 implementation 'com.yanzhenjie.permission:support:2.0.1'
2.请求权限 AndPermission.with(this)
.runtime()
.permission(permissions)
.rationale(new RuntimeRationale())
.onGranted(new Action&lt;List&lt;String&gt;&gt;() {
@Override
public void onAction(List&lt;String&gt; permissions) {
toast(R.string.successfully);
}
})
.onDenied(new Action&lt;List&lt;String&gt;&gt;() {
@Override
public void onAction(@NonNull List&lt;String&gt; permissions) {
toast(R.string.failure);
if (AndPermission.hasAlwaysDeniedPermission(MainActivity.this, permissions)) {
showSettingDialog(MainActivity.this, permissions);
}
}
})
.start();
3.安装应用 private void installPackage() {
AndPermission.with(this)
.install()
.file(new File(Environment.getExternalStorageDirectory(), "android.apk"))
.rationale(new InstallRationale())
.onGranted(new Action&lt;File&gt;() {
@Override
public void onAction(File data) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b11b05b43ebbd7ebb00a54edab40660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea16938dd7518d9d861e7ceabea4096/" rel="bookmark">
			TCP服务器搭建—阿里云&amp;&amp;Jetson Nano
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言
TCP（传输控制协议，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议我们在测试通信模块时，常常借用到TCP服务器，下面让我们走进TCP的大门。
硬件准备 Jetson Nano SIM7080G Cat-M/NB-IoT HAT一套电脑一台 软件准备 阿里云轻量级服务器 搭建阿里云TCP服务器 基于阿里云搭建TCP服务器可以获取到公网IP，就免去了内网穿透的步骤，使用起来也非常灵活方便。
购买服务器，个人推荐 阿里云轻量级服务器
配置服务器镜像，这里用到的镜像是Alyun Linux 2.19.03 打开服务器防火墙
3.通过SSH远程接入阿里云服务器
安装nc yum install nc 服务端监听一个TCP端口 nc -lk 5555 本地客户端连接服务端 nc 127.0.0.1 5555 在阿里云测试客户端与服务端互发信息
通过PC的网络助手接入测试
通过 SIM7080G Cat-M/NB-IoT HAT测试
在Jstson nano搭建TCP服务器 有朋友可能没有阿里云服务器，那用树莓派或者Jetson等linux系统主控可以么？我们来牛刀小试：
Jetson nano不用下载nc工具，可以直接监听端口 nc -lk 9999 Jetson nano客户端连接服务端 nc 127.0.0.1 9999 通过（同一个局域网）PC的网络助手接入测试
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传
通过 SIM7080G Cat-M/NB-IoT HAT测试
由于两者不在一个局域网，需要内网穿透：
内网穿透过程可参考小编笔记，端口号改为监听的端口号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a3e3fff19824217d5c2fac52f5ab8bc/" rel="bookmark">
			单片机c语言双边拉幕灯,51单片机实例-拉幕式数码显示.pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AT89S51AT89S51AT89S51AT89S51单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程 114114114114 21212121 拉幕式数码显示技术拉幕式数码显示技术 1 1 1 1 实验任务实验任务 用 AT89S51 单片机的 P0 0 AD0 P0 7 AD7 端口接数码管的a h 端 8 位数码管的 S1 S8 通过 74LS138 译码器的 Y0 Y7 来控制选通每个数码管的位选端 AT89S51 单 片机的 P1 0 P1 2 控制 74LS138 的 A B C 端子 在 8 位数码管上从右向左循环显 示 12345678 能够比较平滑地看到拉幕的效果 2 2 2 2 电路原理图电路原理图电路原理图电路原理图 图 4 21 1 3 3 3 3 系统板上硬件连线系统板上硬件连线系统板上硬件连线系统板上硬件连线 1 把 单片机系统 区域中的 P0 0 AD0 P0 7 AD7 用 8 芯排线连接到 动态数码显 AT89S51AT89S51AT89S51AT89S51单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程 115115115115 示 区域中的a h 端口上 2 把 三八译码模块 区域中的 Y0 Y7 用 8 芯排线连接到 动态数码显示 区域中 的 S1 S8 端口上 3 把 单片机系统 区域中的 P1 0 P1 2 端口用 3 根导线连接到 三八译码模块 区域中的 A B C 端口上 4 程序设计方法程序设计方法程序设计方法程序设计方法 1 动态数码显示技术 如何进行动态扫描 由于一次只能让一个数码管显示 因此 要显示 8 位的数据 必须经过让数码管一个一个轮流显示才可以 同 时每个数码管显示的时间大约在 1ms 到 4ms 之间 所以为了保证正确显示 我必须每隔 1ms 就得刷新一个数码管 而这刷新时间我们采用单片机的定时 计数器 T0 来控制 每定时 1ms 对数码管刷新一次 T0 采用方式 2 2 在进行数码显示的时候 要对显示单元开辟 8 个显示缓冲区 每个显示缓冲 区装有显示的不同数据即可 5 程序框图程序框图程序框图程序框图 主程序框图 开始 显示缓冲区初始化 必要参数初始化 T0 初始化 TH0 TL0 装入初值 T0 工作并开中断 等待中断 AT89S51AT89S51AT89S51AT89S51单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程 116116116116 中断服务程序框图 图 4 21 2 T0 中断入口 通过查表方式 获得显示代码送入 P0 位选数据送 P1 位选数据 8 吗 位选数据加 1 位选数据 0 CNT加1 0 4 秒定时到了吗 CNT 9 吗 CNT 0 根据 CNT 来决定显示几位数据 中断返回 AT89S51AT89S51AT89S51AT89S51单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程 117117117117 6 汇编源程序汇编源程序汇编源程序汇编源程序 DISPBUFEQU 30H DISPCNTEQU 38H DISPBITEQU 39H T1CNTAEQU 3AH T1CNTBEQU 3BH CNTEQU 3CH ORG 00H LJMP START ORG 0BH LJMP INT T0 START MOV DISPCNT 8 MOVA 10 MOV R1 DISPBUF LP MOV R1 A INC R1 DJNZ DISPCNT LP MOV DISPBIT 00H MOVT1CNTA 00H MOVT1CNTB 00H MOV CNT 00H MOVTMOD 01H MOVTH0 65536 1000 256 MOVTL0 65536 1000 MOD 256 SETB TR0 SETB ET0 SETB EA SJMP INT T0 MOVTH0 65536 1000 256 MOVTL0 65536 1000 MOD 256 MOVA DISPBIT ADDA DISPBUF MOV R0 A MOVA R0 MOV DPTR TABLE MOVCA A DPTR MOV P0 A MOVA P1 ANLA 0F8H ADDA DISPBIT MOV P1 A INC DISPBIT AT89S51AT89S51AT89S51AT89S51单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程 118118118118 MOVA DISPBIT CJNEA 08H NEXT MOV DISPBIT 00H NEXT INC T1CNTA MOVA T1CNTA CJNEA 50 LL1 MOVT1CNTA 00H INC T1CNTB MOVA T1CNTB CJNEA 8 LL1 MOVT1CNTB 00H INC CNT MOVA CNT CJNEA 9 LLX MOV CNT 00H MOVA CNT LLX CJNEA 01H NEX1 MOV 30H 8 LL1 LJMP DONE NEX1 CJNEA 02H NEX2 MOV 31H 8 MOV 30H 8 LJMP DONE NEX2 CJNEA 03H NEX3 MOV 32H 8 MOV 31H 8 MOV 30H 8 LJMP DONE NEX3 CJNEA 04H NEX4 MOV 33H 8 MOV 32H 8 MOV 31H 8 MOV 30H 8 LJMP DONE NEX4 CJNEA 05H NEX5 MOV 34H 8 MOV 33H 8 MOV 32H 8 MOV 31H 8 MOV 30H 8 LJMP DONE NEX5 CJNEA 06H NEX6 MOV 35H 8 MOV 34H 8 MOV 33H 8 MOV 32H 8 MOV 31H 8 MOV 30H 8 LJMP DONE AT89S51AT89S51AT89S51AT89S51单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程 119119119119 NEX6 CJNEA 07H NEX7 MOV 36H 8 MOV 35H 8 MOV 34H 8 MOV 33H 8 MOV 32H 8 MOV 31H 8 MOV 30H 8 LJMP DONE NEX7 CJNEA 08H NEX8 MOV 37H 8 MOV 36H 8 MOV 35H 8 MOV 34H 8 MOV 33H 8 MOV 32H 8 MOV 31H 8 MOV 30H 8 LJMP DONE NEX8 CJNEA 00H DONE MOV 37H 10 MOV 36H 10 MOV 35H 10 MOV 34H 10 MOV 33H 10 MOV 32H 10 MOV 31H 10 MOV 30H 10 LL LJMP DONE DONE RETI TABLE DB 3FH 06H 5BH 4FH 66H 6DH 7DH 07H 7FH 6FH 00H END 7 C C C C 语言源程序语言源程序语言源程序语言源程序 include unsigned char code dispcode 0 x3f 0 x06 0 x5b 0 x4f 0 x66 0 x6d 0 x7d 0 x07 0 x7f 0 x6f 0 x77 0 x7c 0 x39 0 x5e 0 x79 0 x71 0 x00 unsigned char dispbitcode 0 xf8 0 xf9 0 xfa 0 xfb 0 xfc 0 xfd 0 xfe 0 xff unsigned char dispbuf 8 16 16 16 16 16 16 16 16 unsigned char dispbitcnt unsigned int t02scnt unsigned char t5mscnt unsigned char u unsigned chari AT89S51AT89S51AT89S51AT89S51单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程 120120120120 void main void TMOD 0 x02 TH0 0 x06 TL0 0 x06 TR0 1 ET0 1 EA 1 while 1 void t0 void interrupt 1 using 0 t5mscnt if t5mscnt 4 t5mscnt 0 P0 dispcode dispbuf dispbitcnt P1 dispbitcode dispbitcnt dispbitcnt if dispbitcnt 8 dispbitcnt 0 t02scnt if t02scnt 1600 t02scnt 0 u if u 9 u 0 for i 0 i 8 i dispbuf i 16 for i 0 i u i dispbuf i 8 AT89S51AT89S51AT89S51AT89S51单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程单片机实验及实践教程 121121121121
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a3e3fff19824217d5c2fac52f5ab8bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e0e4dc45207cf854a96c4cf97d6f03/" rel="bookmark">
			1 3 5 n的和c语言编程,输入正整数n，计算1-1/3&#43;1/5-1/7&#43;....的前n项之和。用C语言程序解答...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		www.shufadashi.com防采集。
输入正整数n，计算1-1/3+1/5-1/7+....的前n项之和。用C语言程序解答。
#includeint main(){ int i,j; double add = 0; printf("Please input a number!"); scanf("%d",&amp;i); for(j = 0;j &lt; i;j++) { if(j%2) add -= 1 / (double)(1 + j * 3); else add += 1 / (double)(1 + j * 3); } printf("The result is %f",add)
#includeintmain(void){intn;floats=0.0;printf("请输入需2113要计算5261数列前多少4102项：1653");while(!scanf("%d",&amp;n)){printf("输入错误！请重回新输入：");fflush(stdin);}for(inti=0;i评论答00加载更多
#include int main (void) { int i,n,m=1; double sum=0.0; printf("Enter a number:"); scanf("%d",&amp;n); for(i=1;i
c:#includeint main() {int flag=1,i,n,temp;double fz=1.0,fm=1.0,sum;printf("请输入bai一du个正整数：zhi");scanf("%d",&amp;n);//*********************************************************************for(int i=1;i&lt;=n;i++){sum+=(flag*fz/fm);flag=-flag;fm=fz+fm;fz=fm-fz;}//*********************************************************************printf("1-1/2+2/3-3/5+...的前dao%d项之专和等于属%0.2f\n", n,sum);}，c:#includeint main() {int flag=1,i,n,temp;double fz=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e0e4dc45207cf854a96c4cf97d6f03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41ee6208e4ceb3a897630ba2e15f975/" rel="bookmark">
			基于Vue&#43;SpringCloudAlibaba微服务电商项目实战-构建会员服务-005：令牌登陆&amp;扫码关注&amp;细分接口安全领域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		005：令牌登陆&amp;扫码关注&amp;细分接口安全领域 1 会员、令牌登陆服务接口的演示2 为什么我们接口需要定义dto与do转换3 定义会员注册接口的dto参数4 定义dto与do的转换工具类封装5 会员服务注册接口测试运行6 令牌登录接口的基本实现7 基于令牌获取用户信息接口8 使用多线程异步的形式处理日志操作9 @Async整合可能存在的问题10 源码角度分析@Async为什么会失效11 @Async需要注意那些事项 1 会员、令牌登陆服务接口的演示 今日课程任务
如何细分rpc接口需要细分参数安全领域为什么要dto、do之间实现互转构建会员服务用户注册的接口构建会员服务令牌登录接口基于多线程的形式异步写入登录日志@Async注解的失效之谜分析基于令牌查询用户的信息实现用户脱敏 2 为什么我们接口需要定义dto与do转换 构建会员服务接口
数据库表设计
CREATE TABLE `meite_user` ( `USER_ID` int(12) NOT NULL AUTO_INCREMENT COMMENT 'user_id', `MOBILE` varchar(11) NOT NULL COMMENT '手机号', `EMAIL` varchar(50) DEFAULT NULL COMMENT '邮箱号', `PASSWORD` varchar(64) NOT NULL COMMENT '密码', `USER_NAME` varchar(50) DEFAULT NULL COMMENT '用户名', `SEX` tinyint(1) DEFAULT '0' COMMENT '性别 1男 2女', `AGE` tinyint(3) DEFAULT '0' COMMENT '年龄', `CREATE_TIME` timestamp NULL DEFAULT NULL COMMENT '注册时间', `UPDATE_TIME` timestamp NULL DEFAULT NULL COMMENT '修改时间', `IS_AVAILABLE` tinyint(1) DEFAULT '1' COMMENT '是否可用 1正常 2冻结', `PIC_IMG` varchar(255) DEFAULT NULL COMMENT '用户头像', `QQ_OPENID` varchar(50) DEFAULT NULL COMMENT 'QQ联合登陆id', `WX_OPENID` varchar(50) DEFAULT NULL COMMENT '微信公众号关注id', PRIMARY KEY (`USER_ID`), UNIQUE KEY `MOBILE_UNIQUE` (`MOBILE`), UNIQUE KEY `EMAIL_UNIQUE` (`EMAIL`) ) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8 COMMENT='用户会员表'; CREATE TABLE `user_login_log` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) DEFAULT NULL, `login_ip` varchar(255) DEFAULT NULL, `login_time` datetime DEFAULT NULL, `login_token` varchar(255) DEFAULT NULL, `channel` varchar(255) DEFAULT NULL, `equipment` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41ee6208e4ceb3a897630ba2e15f975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451c04979b1fc23aa8b88c313d947cb0/" rel="bookmark">
			用 JavaScript 实现手势库 — 事件派发与 Flick 事件【前端组件化】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端《组件化系列》目录 「一」用 JSX 建立组件 Parser（解析器）「二」使用 JSX 建立 Markup 组件风格「三」用 JSX 实现 Carousel 轮播组件「四」用 JavaScript 实现时间轴与动画「五」用 JavaScript 实现三次贝塞尔动画库 - 前端组件化「六」用 JavaScript 实现手势库 - 实现监听逻辑「七」用 JavaScript 实现手势库 — 手势逻辑「八」用 JavaScript 实现手势库 — 支持多键触发「九」用 JavaScript 实现手势库 — 事件派发与 Flick 事件 《 本期 》… 待续 … 我们上一期已经实现了所有的 gesture（手势），接下来我们需要实现的就是事件派发的功能。
事件派发 在 DOM 里面事件的派发是使用 new Event ， 然后在上面加一些属性，最后把这个事件给派发出去的。
所以我们这里也是一样，建立一个 dsipatch 的函数，并且加入 type、property 这些参数。这里的 property 含有 context 对象和 point 坐标两个属性。
在我们的 dispatch 函数中，首先我们需要做的就是创建一个 event 对象。在新的浏览器 API 中，我们可以直接使用 new Event 来创建。当然我们也可以使用自定义事件来创建 new CustomEvent。那么我们这里，就用普通的 new Event 就好了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/451c04979b1fc23aa8b88c313d947cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d514a504784f07868476a47d253391/" rel="bookmark">
			c语言 bmp转png,用c语言把bmp格式的彩色图片转换成黑白的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该楼层疑似违规已被系统折叠 隐藏此楼查看此楼
#include
#include
#include
typedef unsigned char BYTE;
#define RGB 3.0
#define MAX 255.0
struct BitMap
{
short Type;
long Size;
short Reserve1;
short Reserve2;
long Offset;
long FileSize;
long Width;
long Height;
short ClrPlanes;
short BitsPerPix;
long Compression;
long ImSize;
long XPixPerMeter;
long YPixPerMeter;
long ClrTBClr;
long ImpClr;
} Header;
typedef struct
{
BYTE Blue;
BYTE Green;
BYTE Red;
} __attribute__((__packed__))
RGBTRIPLE;
int main(int argc, char **argv) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d514a504784f07868476a47d253391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b639e5cf7640afeabc637c6562a2e0/" rel="bookmark">
			c语言判断一个数既是5的背书,试编程判断输入的正整数是否既是5又是7的正倍数。若是，则输出yes；否则输出no。知道...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.Scanner;
public class Test6{
public static void main(String[] args){
System.out.println("请输入一个正整数：");
Scanner s = new Scanner(System.in);
int a = s.nextInt();
if(a % 5 == 0 &amp;&amp; a % 7 == 0){
System.out.println("YES");
}else{
System.out.println("NO");
}
}
}
C语言编程:
#include"stdio.h"
void main()
{
int a;
printf("请输入a的值:");
scanf("%d",&amp;a);
if(a%5==0&amp;&amp;a%7==0)
printf("yes\n");
else
printf("no\n");
}
编程高级语言
高级语言是一类接近于人类的自然语言和数学语言的程序设计语言的统称。按照其程序设计的出发点和方式不同，高级语言分为了面向过程的语言和面向对象的语言，如Fortran语言、C语言、汉语程序设计语言等都是面向过程的语言;而以C++、Smalltalk等为代表的面向对象的语言与面向过程语言有着许多不同，这些语言支持"程序是相互联系的离散对象集合"，这样一种新的程序设计思维方式，具有封装性、继承性和多态性等特征。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d38c58e0b16cfa9d924346bc99fda3/" rel="bookmark">
			while scanning for the next token found character ‘@‘ that cannot start any token.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前置 1、maven版本: 3.6.3 版本相差不远没有关系
2、重现问题 启动报错:
3、解决方式 &lt;!-- 资源目录 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 开启对directory主资源目录下的文件过滤. (用指定的参数替换directory下的文件中的参数 eg:profiles.active) --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 4、其余方案 1、添加单引号|双引号 不推荐
2、mvn clean install
3、重启电脑 不推荐
4、重启项目 不推荐
5、项目目录下反键 maven reload project
6、maven插件的刷新按钮, reload all maven project
7、项目目录下 mvn spring-boot:run
8、更新idea版本的 不推荐
9、更新maven版本 不推荐
10、。。。。。就不再罗列了
零零散散的方案, 大家可能会觉得怎么会这样, 无数问号, 但是以上方案确实是解决了一部分人的问题. 大家也可以看看官方的issues:
https://github.com/spring-projects/spring-boot/issues/8438
https://github.com/spring-cloud/spring-cloud-config/issues/540
5、个人见解 推荐采用本文章所给的方案, 指定资源文件, 开启文件过滤, 设置filtering=true
大家如果对filtering有疑问, 觉得还是不够清楚, 可以看下官方的介绍, 文档地址如下:
http://maven.apache.org/pom.html#The_Super_POM
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/375524a6e19b6796eb1b4cc9a2a9a33c/" rel="bookmark">
			c语言 bmp转png 代码,用c语言把bmp格式的彩色图片转换成黑白的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该楼层疑似违规已被系统折叠 隐藏此楼查看此楼
#include
#include
#include
typedef unsigned char BYTE;
#define RGB 3.0
#define MAX 255.0
struct BitMap
{
short Type;
long Size;
short Reserve1;
short Reserve2;
long Offset;
long FileSize;
long Width;
long Height;
short ClrPlanes;
short BitsPerPix;
long Compression;
long ImSize;
long XPixPerMeter;
long YPixPerMeter;
long ClrTBClr;
long ImpClr;
} Header;
typedef struct
{
BYTE Blue;
BYTE Green;
BYTE Red;
} __attribute__((__packed__))
RGBTRIPLE;
int main(int argc, char **argv) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/375524a6e19b6796eb1b4cc9a2a9a33c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e68484af944611e79c5cb61e8ca75e/" rel="bookmark">
			如何使用Albumentations 对目标检测任务做增强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、导入所需的库
2、定义可视化函数显示图像上的边界框和类标签
3、获取图像和标注
4、使用RandomSizedBBoxSafeCrop保留原始图像中的所有边界框
5、定义增强管道
6、输入用于增强的图像和边框
7、其他不同随机种子的示例
诸如RandomCrop和CenterCrop之类的某些增强功能可能会变换图像，使其不包含所有原始边界框。 本示例说明如何使用名为RandomSizedBBoxSafeCrop的变换来裁剪图像的一部分，但保留原始图像的所有边界框。
1、导入所需的库 import random import cv2 from matplotlib import pyplot as plt import albumentations as A 2、定义可视化函数显示图像上的边界框和类标签 可视化函数参考https://github.com/facebookresearch/Detectron/blob/master/detectron/utils/vis.py
BOX_COLOR = (255, 0, 0) # Red TEXT_COLOR = (255, 255, 255) # White def visualize_bbox(img, bbox, class_name, color=BOX_COLOR, thickness=2): """Visualizes a single bounding box on the image""" x_min, y_min, w, h = bbox x_min, x_max, y_min, y_max = int(x_min), int(x_min + w), int(y_min), int(y_min + h) cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9e68484af944611e79c5cb61e8ca75e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403f8c655fc62d366e20d9aeff7e678e/" rel="bookmark">
			熟悉Grasp，并撰写心得回答设计模式是怎样解决设计问题的，在实际编程中是如何使用的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熟悉Grasp，并撰写心得回答设计模式是怎样解决设计问题的，在实际编程中是如何使用的？
Part1
Grasp介绍
GRASP，全称为General Responsibility Assignment Software Pattern，即通用职责分配软件模式，它由《UML和模式应用》(Applying UML and Patterns)一书作者Craig Larman提出。与其将它们称之为设计模式，不如称之为设计原则，因为它是站在面向对象设计的角度，告诉我们怎样设计问题空间中的类与分配它们的行为职责，以及明确类之间的相互关系等，而不像GoF模式一样是针对特定问题而提出的解决方案。因此GRASP站在一个更高的角度来看待面向对象软件的设计，它是GoF设计模式的基础。GRASP是对象职责分配的基本原则，其核心思想是职责分配(Responsibility Assignment)，用职责设计对象(Designing Objects with Responsibilities)。它包含如下9个基本特征或原则：
1、信息专家：将职责分配给拥有履行一个职责所必需信息的类，即信息专家。
信息专家模式是面向对象设计的最基本原则。通俗点来讲，就是一个类只干该干的事情，不该干的事情不干。在系统设计时，需要将职责分配给具有实现这个职责所需要信息的类。信息专家模式对应于面向对象设计原则中的单一职责原则。
例如：常见的网上商店里的购物车(ShopCar),需要让每种商品(SKU)只在购物车内出现一次，购买相同商品，只需要更新商品的数量即可。如下图：
针对这个问题需要权衡的是，比较商品是否相同的方法需要放到那里类里来实现呢？分析业务得知需要根据商品的编号(SKUID)来唯一区分商品，而商品编号是唯一存在于商品类里的，所以根据信息专家模式，应该把比较商品是否相同的方法放在商品类里。
2、创造者
如果符合下面的一个或者多个条件，则可将创建类A实例的职责分配给类B：
B包含A；B聚合A；B拥有初始化A的数据并在创建类A的实例时将数据传递给类A；B记录A的实例；B频繁使用A。 此时，我们称类B是类A对象的创建者。如果符合多个条件，类B聚合或者包含类A的条件优先。
3、低耦合
耦合是评价一个系统中各个元素之间连接或依赖强弱关系的尺度，具有低耦合的元素不过多依赖其他元素。此处的元素可以是类，也可以是模块、子系统或者系统。具有高耦合的类过多地依赖其他类，这种设计将会导致：一个类的修改导致其他类产生较大影响；系统难以维护和理解；系统重用性差，在重用一个高耦合的类时不得不重用它所依赖的其他类。因此需要对高耦合的系统进行重构。
类A和类B之间的耦合关系体现如下：A具有一个B类型的属性；A调用B的方法；A的方法包含对B的引用，如方法参数类型为B或返回类型为B；A是B的直接或者间接子类；B是一个接口，A实现了该接口。低耦合模式鼓励在进行职责分配时不增加耦合性，从而避免高耦合可能产生的不良后果。在进行类设计时，需要保持类的独立性，减少类变更所带来的影响，它通常与信息专家模式和高内聚模式一起出现。
4、高内聚
内聚是评价一个元素的职责被关联和关注强弱的尺度。如果一个元素具有很多紧密相关的职责，而且只完成有限的功能，则这个元素就具有高内聚性。此处的元素可以是类，也可以是模块、子系统或者系统。
在一个低内聚的类中会执行很多互不相关的操作，这将导致系统难于理解、难于重用、难于维护、过于脆弱，容易受到变化带来的影响。因此我们需要控制类的粒度，在分配类的职责时使其内聚保持为最高，提高类的重用性，控制类设计的复杂程度。为了达到低内聚，我们需要对类进行分解，使得分解出来的类具有独立的职责，满足单一职责原则。在一个类中只保留一组相关的属性和方法，将一些需要在多个类中重用的属性和方法或完成其他功能所需的属性和方法封装在其他类中。类只处理与之相关的功能，它将与其他类协作完成复杂的任务。
5、控制器
一个控制器是负责接收或者处理系统事件的非图形用户界面对象。一个控制器定义一组系统操作方法。在控制器模式中，要求系统事件的接收与处理通常由一个高级类来代替；一个子系统需要定义多个控制器，分别对应不同的事务处理。通常，一个控制器应当把要完成的功能委托给其他对象，它只负责协调和控制，本身不完成太多的功能。它可以将用户界面所提交的请求转发给其他类来处理，控制器可以重用，且不能包含太多业务逻辑，一个系统通常也不能设计一个统一的控制器。控制器模式与MVC模式相对应，而MVC是一种比设计模式更加高级的架构模式。 6、多态
由条件变化引发同一类型的不同行为是程序的一个基本主题。如果用if-else或switch-case等条件语句来设计程序，当系统发生变化时必须修改程序的业务逻辑，这将导致很难方便地扩展有新变化的程序。另外对于服务器/客户端结构中的可视化组件，有时候需要在不影响客户端的前提下，将服务器的一个组件替换成另一个组件。此时可以使用多态来实现，将不同的行为指定给不同的子类，多态是设计系统如何处理相似变化的基本方法，基于多态分配职责的设计可以方便地处理新的变化。在使用多态模式进行设计时，如果需要对父类的行为进行修改，可以通过其子类来实现，不同子类可以提供不同的实现方式，将具体的职责分配给指定的子类。新的子类增加到系统中也不会对其他类有任何影响，多态是面向对象的三大基本特性之一（另外两个分别是封装和继承），通过引入多态，子类对象可以覆盖父类对象的行为，更好地适应变化，使变化点能够“经得起未来验证”。多态模式在多个GoF设计模式中都有所体现，如适配器模式、命令模式、组合模式、观察者模式、策略模式等等。
7、纯虚构
纯虚构模式用于解决高内聚和低耦合之间的矛盾，它要求将一部分类的职责转移到纯虚构类中，在理想情况下，分配给这种虚构类的职责是为了达到高内聚和低耦合的目的。在实际操作过程中，纯虚构有很多种实现方式，例如将数据库操作的方法从数据库实体类中剥离出来，形成专门的数据访问类，通过对类的分解来实现类的重用，新增加的数据访问类对应于数据持久化存储，它不是问题域中的概念，而是软件开发者为了处理方便而产生的虚构概念。纯虚构可以消除由于信息专家模式带来的低内聚和高耦合的坏设计，得到一个具有更好重用性的设计。在系统中引入抽象类或接口来提高系统的扩展性也可以认为是纯虚构模式的一种应用。纯虚构模式通常基于相关功能的划分，是一种以功能为中心的对象或行为对象。在很多设计模式中都体现了纯虚构模式，例如适配器模式、策略模式等等。
8、中介
“中介”顾名思义，就是这个事不能直接来办，需要绕个弯才行。绕个弯的好处就是，本来直接会连接在一起的对象彼此隔离开了，一个的变动不会影响另一个。就像前面的低耦合模式里说的一样，“两个不同模块的内部类之间不能直接连接”，但是我们可以通过中间类来间接连接两个不同的模块，这样对于这两个模块来说，他们之间仍然是没有耦合/依赖关系的。
9、受保护变化
受保护变化模式简称PV，它是大多数编程和设计的基础，是模式的基本动机之一，它使系统能够适应和隔离变化。它与面向对象设计原则中的开闭原则相对应，即在不修改原有元素（类、模块、子系统或系统）的前提下扩展元素的功能。开闭原则又可称为“可变性封装原则(Principle of Encapsulation of Variation, EVP)”，要求找到系统的可变因素并将其封装起来。如将抽象层的不同实现封装到不同的具体类中，而且EVP要求尽量不要将一种可变性和另一种可变性混合在一起，这将导致系统中类的个数急剧增长，增加系统的复杂度。在具体实现时，为了符合受保护变化模式，我们通常需要对系统进行抽象化设计，定义系统的抽象层，再通过具体类来进行扩展。如果需要扩展系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，在不修改已有代码的基础上扩展系统的功能。大多数设计原则和GoF模式都是受保护变化模式的体现。
Part2
关于设计模式解决设计问题和实际中使用设计模式的心得：
本学期软件构造课程即将结束，12周的课程主要从模块化软件构造、软件构造的质量目标、面向可复用性的软件构造、面向可维护性软件构造、面向对象的软件构造和面向健壮性的软件构造几大方面进行了深度的学习，同时，我们也从适配器模式、装饰模式、外观模式、策略模式、模板模式、迭代器模式入手，对相关的设计模式进行了理解并完成了实验，总之，从课堂和实验中能感觉到个人的软件设计思维和对高效的软件工程设计模型方法的理解达到了一定的层次，软件构造课程对于当下正在学习spring、springboot框架，利用这些高效的框架练习商业软件项目的同学来说正好起到了很好的知识穿透学习作用，我们能从微观框架的设计和宏观代码编写、测试上更好地把握一个软件作品的设计，也更加深了对面向对象编程的理解，以下即是本人通过本次学习后关于利用设计模式解决问题的心得。
首先，设计模式对面向对象设计过程中的相关问题是有多种解决方法的，我认为解决问题首先即是要根据问题本身寻找合适的对象，面向对象程序由对象组成，对象包括数据和对数据进行操作的过程。对象在收到客户的请求(或消息)后，执行相应的操作。客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。由于这些限制，对象的内部状态是被封装的，它不能被直接访问，它的表示对于对象外部是不可见的。面向对象设计最困难的部分是将系统分解成对象集合。因为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用等等，它们都影响着系统的分解，并且这些因素通常还是互相冲突的。面向对象设计方法学支持许多设计方法。你可以写出一个问题描述，挑出名词和动词，进而创建相应的类和操作；或者，你可以关注于系统的协作和职责关系；或者，你可以对现实世界建模，再将分析时发现的对象转化至设计中。设计的许多对象来源于现实世界的分析模型。但是，设计结果所得到的类通常在现实世界中并不存在，有些是像数组之类的低层类，而另一些则层次较高。
其次，我们要确定对象的粒度，它的意思即是对象在大小和数目上变化极大，它们能表示下自硬件或上自整个应用的任何事物，因而我们常常无法有效的描述这个待确定的对象，而在设计模式中，外观模式就很好地描述了怎样用对象表示完整的子系统，享元模式描述了如何支持大量的最小粒度的对象，抽象工厂模式和建造者模式产生哪些专门负责生成其他对象的对象，访问者模式和命令模式生成的对象那个负责实现对其他对象或对象组的请求。
第三点我们要指定对象接口，在面向对象系统中，接口是基本的组成部分。对象只有通过它们的接口才能与外部交流，如果不通过对象的接口就无法知道对象的任何事情，也无法请求对象做任何事情。对象接口与其功能实现是分离的，不同对象可以对请求做不同的实现，也就是说，两个有相同接口的对象可以有完全不同的实现。当给对象发送请求时，所引起的具体操作既与请求本身有关又与接受对象有关。支持相同请求的不同对象可能对请求激发的操作有不同的实现。发送给对象的请求和它的相应操作在运行时刻的连接就称之为动态绑定。动态绑定是指发送的请求直到运行时刻才受你的具体的实现的约束。因而，在知道任何有正确接口的对象都将接受此请求时，你可以写一个一般的程序，它期待着那些具有该特定接口的对象。进一步讲，动态绑定允许你在运行时刻彼此替换有相同接口的对象。这种可替换性就称为多态，它是面向对象系统中的核心概念之一。多态允许客户对象仅要求其他对象支持特定接口，除此之外对其假设几近于无。多态简化了客户的定义，使得对象间彼此独立，并可以在运行时刻动态改变它们相互的关系。设计模式通过确定接口的主要组成成分及经接口发送的数据类型，来帮助你定义接口。设计模式也许还会告诉你接口中不应包括哪些东西。设计模式也指定了接口之间的关系。特别地，它们经常要求一些类具有相似的接口；或它们对一些类的接口做了限制。
第四点就要关注对象描述的实现，我们一般很少提及到实际上怎么去定义一个对象。对象的实现是由它的类决定的，类指定了对象的内部数据和表示，也定义了对象所能完成的操作。对象通过实例化类来创建，此对象被称为该类的实例。当实例化类时，要给对象的内部数据(由实例变量组成)分配存储空间，并将操作与这些数据联系起来。对象的许多类似实例是由实例化同一个类来创建的。新的类可以由已存在的类通过类继承来定义。当子类继承父类时，子类包含了父类定义的所有数据和操作。子类的实例对象包含所有子类和父类定义的数据，且它们能完成子类和父类定义的所有操作。这里就借用了抽象类，抽象类的主要目的是为它的子类定义公共接口。一个抽象类将把它的部分或全部操作的实现延迟到子类中，因此，一个抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为抽象操作。非抽象类称为具体类。子类能够改进和重新定义它们父类的操作。更具体地说，类能够重定义父类定义的操作，重定义使得子类能接管父类对请求的处理操作。类继承允许你只需简单的扩展其他类就可以定义新类，从而可以很容易地定义具有相近功能的对象族。这方面我们要重点关注类继承与接口继承的比较和我们所作的是对接口编程而不是对实现编程这两个问题。
第五点就要合理地应用复用机制，首先面向对象系统中功能复用的两种最常用技术是类继承和对象组合，类继承允许你根据其他类的实现来定义一个类的实现。这种通过生成子类的复用通常被称为白箱复用。术语“白箱”是相对可视性而言：在继承方式中，父类的内部细节对子类可见。对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。继承和组合各有优缺点。类继承是在编译时刻静态定义的，且可直接使用，因为程序设计语言直接支持类继承。类继承可以较方便地改变被复用的实现。当一个子类重定义一些而不是全部操作时，它也能影响它所继承的操作，只要在这些操作中调用了被重定义的操作。但是类继承也有一些不足之处。首先，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了部分子类的具体表示。因为继承对子类揭示了其父类的实现细节，所以继承常被认为“破坏了封装性。子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。对象组合是通过获得对其他对象的引用而在运行时刻动态定义的。组合要求对象遵守彼此的接口约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。这还会产生良好的结果：因为对象只能通过接口访问，所以我们并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来替代另一个对象；更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系，因此我们一般优先使用对象组合而不是类继承。其次我们要关注的是委托的使用，它使组合具有与继承同样的复用能力。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者。它的主要优点在于它便于运行时刻组合对象操作以及改变这些操作的组合方式。
第六点就是在设计过程中关联运行时刻和编译时刻的结构设计，个面向对象程序运行时刻的结构通常与它的代码结构相差较大，代码结构在编译时刻就被确定下来了，它由继承关系固定的类组成，而程序的运行时刻结构是由快速变化的通信对象网络组成，可见程序运行时刻和编译时刻的结构是存在很大差别的，很明显代码不可能揭示关于系统如何工作的全部。系统的运行时刻结构更多地受到设计者的影响，而不是编程语言。对象和它们的类型之间的关系必须更加仔细地设计，因为它们决定了运行时刻程序结构的好坏。
总之，虽然在讨论设计模式的问题解决时我们可以从这六个方面深入分析，然而实际对于设计模式的使用过程中，我们要想学会灵活、科学地使用设计模式就更要深入地实验这些模式，体会不同模式之间应用场景地不同，设计模式地选择过程中，我们要理解好变化的设计思维，要积极地摆脱对特殊操作、软硬件平台、对象表示或实现和算法的依赖因素，积极理解低耦合、高内聚的思想，要结合设计目标对设计未来的变化都要充分地考虑，设计模式可以确保系统能以特定方式变化，从而帮助你避免重新设计系统。每一个设计模式允许系统结构的某个方面的变化独立于其他方面，这样产生的系统对于某一种特殊变化将更健壮。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6047551d63b48f2baa2b488681fbd8d/" rel="bookmark">
			第九篇 Elementui 树形表格多选问题-多级树形表格懒加载复选框勾选问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 个人在做项目中，使用到了 Elementui 组件库中的树形表格，其中的需求就是要能够做到多选的功能。使用官网的例子，只有一层的多选，不能做到多层的勾选。无法满足开发的需要，
本文做的就是分享： 1.一次性展示的数据进行多选 2.懒加载的获取的数据的多选 的实现
请先看效果:
1.一次性展示的数据进行多选：
2.懒加载后获取的数据的多选
处理前：
处理后：
1.一次性展示的数据进行多选
这种情况是一次性从后端接口取回了显示的数据，主要使用到的方法如下：---&gt;可到ElementUi官网查看功能：ElementUi官方文档
@select="select" @select-all="selectAll" @selection-change="selectionChange" 完整的代码：
&lt;template&gt; &lt;div&gt; &lt;el-table :data="tableData" style="width: 100%;margin-bottom: 20px;" row-key="id" border default-expand-all :select-on-indeterminate="true" @select="select" @select-all="selectAll" @selection-change="selectionChange" ref="multipleTable" :tree-props="{ children: 'children', hasChildren: 'hasChildren' }" &gt; &lt;el-table-column type="selection" width="55"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="date" label="日期" sortable width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" sortable width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { tableData: [ { id: 1, date: '2016-05-02', name: '王小虎1', address: '上海市普陀区金沙江路 1518 弄' }, { id: 2, date: '2016-05-04', name: '王小虎2', address: '上海市普陀区金沙江路 1517 弄' }, { id: 3, date: '2016-05-01', name: '王小虎3', address: '上海市普陀区金沙江路 1519 弄', children: [ { id: 31, date: '2016-05-01', name: '王小虎31', address: '上海市普陀区金沙江路 1519 弄', children: [ { id: 311, date: '2016', name: '测试', address: '上海市普陀区金沙江路 1519 弄' }, { id: 312, date: '2016-01', name: '测试2', address: '上海市普陀区金沙江路 1519 弄' } ] }, { id: 32, date: '2016-05-01', name: '王小虎4', address: '上海市普陀区金沙江路 1519 弄' } ] }, { id: 4, date: '2016-05-03', name: '王小虎5', address: '上海市普陀区金沙江路 1516 弄' // hasChildren: true } ] } }, created() {}, methods: { setChildren(children, type) { // 编辑多个子层级 children.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6047551d63b48f2baa2b488681fbd8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9108185e0a368afb7c2aca3904ba26fd/" rel="bookmark">
			SAS代码汇总（1）基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑库 libname语句——逻辑库
libname &lt;name&gt; '&lt;path&gt;'; 多个位置
libname &lt;name&gt; ('&lt;path&gt;' '&lt;path&gt;'); 路径 固定路径，方便重复调用
filename &lt;myfile&gt; 'path'; 用法
filename myfile 'C:\SataSoftData\'; data bank; infile myfile(bank1.txt); input ...; run; 排序 sort过程——排序
proc sort data=dataname out=asd; where family='asd'; by var1 descending var2; run; 输出数据 print过程——数据集数据部分
proc print data=&lt;dataname&gt; label noobs ;显示标签，不显示观测序号 title 'title'; footnote 'footnote';注意这是全局设置 by var1;必须先sort过程之后再使用by语句 sum var2;对变量进行求和 id var1;用var1替代obs，当作第一列 var var1 var2 var3; where var1=3;条件筛选 format var1 date9.; run; 输出内容 contents过程——数据集描述部分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9108185e0a368afb7c2aca3904ba26fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca3fb3ff26297a85704e3a0fac79e82/" rel="bookmark">
			怎么去实现一个第三方登录功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里不会描述太详细的开发流程和步骤，仅做心得分享和体会。
首先要了解下第三方登录的一个大致流程，这里举个例子，假设我们开发的网站要通过码云登录，网站表面体验的交互流程应该是点击码云登录-&gt;跳转到码云的授权登录页-&gt;授权成功后跳转回网站首页，这样就实现了第三方登录。如果从开发设计角度来讲，实际流程应该涉及到4个角色，一个是用户，一个是客户端也就是我们的网站，一个是码云认证服务器，一个是码云授权服务器，中间涉及到oauth2协议，用户选择码云登录，我们的网站返回码云的授权登录页，用户输入用户名和密码，认证服务器认证成功，返回给客户端一个code码，之后客户端通过这个code获取访问令牌access_token，接着带着访问令牌去访问授权服务器，就可以获取到第三方用户的一些基本信息了。如果从代码的角度来说，就更简单了，前端点击选择码云登录，后端返回码云的授权页面，然后用户授权成功后，码云回调网站的接口地址，只要能进回调方法，想实现什么逻辑，就完全由开发来决定了。简单的了解流程后，可以直接找开源框架了，看看有没啥活跃度高的第三方登录开源框架，我这里引入了JustAuth，码云地址如下：https://gitee.com/yadong.zhang/JustAuth。文档地址如下：https://justauth.wiki/。先看文档，熟悉下这个框架的基本功能，然后看看一些集成第三方的代码案例，第三方登录功能代码该怎么写其实就大概会有个思想了。这时候先不要急着写，再去找找有没有已经集成了JustAuth的开源项目或者demo，如果有，可以做借鉴，没有的话，再自己写，推荐参考demo：JustAuth-demo感觉到了这步骤，复制黏贴就搞定了，真正需要开发者做的只有申请第三方平台的开发者资质拿到一些必要属性和新建社交用户表以及完善回调方法里的逻辑了，回调的话，我这里的逻辑一般都是重定向到某个页面，比如首页。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b65eb468e0b75d5be553e9e3dade035e/" rel="bookmark">
			存储过程PL/SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发存储过程 *********************************************
程序功能：
业务逻辑：
开发日期：
开发人员：
源表：
目标表：
*********************************************
语句 CREATE OR REPLACE 过程名称（可以有参数list） IS
动态变量，游标
BEGIN
内容
（如果有update insert delete 后面一定要commit）
异常
END;
执行 1.在PLSQL里 命令窗口执行存储过程 execute 存储过程名称；
2.BEGIN
存储过程名称（参数）；
END;
存储过程相当于JAVA中的方法 参数，返回值，异常处理，循环，打印 CREATE OR REPLACE testproce(e_num IN NUMBER，e_name OUT VARCHAR) ------e_num 参数 IN 类型 ，e_name 参数 OUT 类型 IS v_name emp.ename%TYPE -------------------v_name的类型与emp表中ename的类型一致 BEGIN SELECT ename INTO v_name FROM emp WHERE empno=e_num; e_name:=v_name;---赋值 EXCEPTION WHEN no_data_found THEN dbms_output.put_line("打印输出异常信息"); END; 调用 DECLARE aa VARCHAR2(30); BEGIN testproce(123,aa); dbms_output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b65eb468e0b75d5be553e9e3dade035e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c59a8bbe54c1f8a065405f66d8b741/" rel="bookmark">
			存储过程-游标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CURSOR ( /ˈkɜːrsər/) （柯sir） 就是结果集，是一个查询后的结果集 select * from emp
DECLARE(声明) v_empno NUMBER; v_ename VARCHAR2(40); CURSOR c_emp IS SELECT empno,emname FROM EMP;(查询结果集) BEGIN（开始） OPEN c_emp;（打开游标） LOOP（循环开始） FETCH c_emp INTO v_empno,v_ename;（提取游标变量到c_emp,指针操作） EXIT WHEN c_emp%NOTFOUND;(判断结束条件) dbms_output.put_line(v_empno||v_ename)（打印） END LOOP;（结束循环） CLOSE c_emp;（关闭游标） END（关闭） 循环插入数据 while 和 for
第一种 DECLARE v_cout number:=51; BEGIN while v_cout&lt;=60 loop insert into emp(no,name) values(v_cout,'123'); v_cout:=v_cout+1; end loop; commit; END 第二种 DECLARE v_cout number; BEGIN for v_cout in 61..65 loop insert into emp(no,name) values(v_cout,'123'); v_cout:=v_cout+1; end loop; commit; END 删除部门名称相同，且保留最大的部门编号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e730ec7e09eea8c8c2c05e629c0301/" rel="bookmark">
			MAC压缩的文件在win下减压出来是空文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac压缩的文件为.zip格式
直接减压，内容为空
解决方法：
直接将文件夹后缀改为.rar。减压即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c5619fea11028270b6df3a23978158f/" rel="bookmark">
			软件构造课程MIT课程学习并文档翻译理解-------序号6(已对应MIT第6节)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		西安工业大学计算机学院18060721班软件构造课程MIT课程学习并文档翻译理解-------序号6(已对应MIT第6节)
翻译内容
软件构造的规格
1.注释与断言 2.异常分析
Java辅导练习---通过完成Java导师的这些任务，继续在Java上取得进步，软件为6.031，
软件构造过程中保持规范化的意义：
1.提防安全漏洞：纠正当下在工程设计过程中犯过的每一个错误，要时刻保持着对未来系统中暴漏出安全隐患风险的考虑和前瞻性解决。
2.是构造过程容易理解：在设计过程中要清晰地考虑每一个细节问题，要为今后系统的正常运转和进一步发展做好充足的准备。
3.准备好去作出改变：设计用于适应变化而无需重写。
规范化设计目标：
1.要充分地理解方法规范中的前置条件和后前置条件，从而保证能够编写正确的规范。
2.能够根据规范编写测试来进一步印证系统。
3.了解Java中检查异常和未检查异常之间的区别。
4.了解如何对特殊结果使用异常。
介绍：
规格是团队合作的关键。如果没有规范，就不可能委派实现方法的责任。规范充当契约:实现者负责满足契约，而使用该方法的客户端可以依赖契约。事实上，我们将看到，像真正的合法合同一样，规范对双方都有要求:当规范有先决条件时，客户也有责任。
在本文中，我们将研究方法规范所扮演的角色。我们将讨论什么是前置条件和后置条件，以及它们对方法的实现者和客户机意味着什么。我们还将讨论如何使用异常，这是Java、Python和许多其他现代语言中的一个重要语言特性，它允许我们使方法的接口更安全，避免出现错误，更容易理解。
第一部分：规格化
在我们深入讨论规范的结构和意义前先来聊聊“什么是规格化？” 程序中许多最糟糕的错误是由于对两段代码之间接口的行为的误解而产生的。虽然每个程序员心里都有规范，但并不是所有的程序员都把它们写下来。因此，团队中不同的程序员有不同的规范。当程序失败时，很难确定错误在哪里。代码中的精确规范可以让您推卸责任(归咎于代码片段，而不是人)，并且可以让您免去苦苦思索应该如何修复的麻烦。规范对于方法的客户端是有益的，因为它们省去了阅读代码的任务。如果您不相信阅读规范比阅读代码更容易，请查看一些标准Java规范，并将它们与实现它们的源代码进行比较。
API文档中的规范:----这里放值了java的API文档供跳转学习
public BigInteger add(BigInteger val)
这里的返回值类型为BigInteger，返回值为 (this + val)，这里的参数：val代表将要添加到BigInteger的值。
方法体来自Java 8源代码
这里的BigInteger.add的规范对于客户端来说很容易理解，如果我们对一些特殊情况有疑问，BigInteger类提供了额外的可读文档，如果我们拥有哦的只是代码部分，那要理解这些内容就必须阅读这个构造函数，对输入的这种限制可能允许实现者跳过不再需要的昂贵检查，并使用更有效的实现。契约充当客户机和实现者之间的防火墙。它保护了客户端不受单元工作细节的影响——如果你有它的规范，你不需要阅读程序的源代码。而且它让实施者不知道设备使用的细节;他不需要询问每一个客户她打算如何使用这个单元。该防火墙导致解耦，允许单元代码和客户端代码独立更改，只要更改遵守规范——每个更改都遵守其义务。
行为代价：
考虑这两种方法它们是相同还是不同的？
static int findFirst(int[] arr, int val) { for (int i = 0; i &lt; arr.length; i++) { if (arr[i] == val) return i; } return arr.length; } static int findLast(int[] arr, int val) { for (int i = arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c5619fea11028270b6df3a23978158f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599c8e52a5a00898c844aeb57eacaf3d/" rel="bookmark">
			工作记录 如何发送邮件，并实现证书校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;/dependency&gt; 2、设置邮件内容 // 根据参数生成邮件 MultiPartEmail email = new MultiPartEmail(); email.setHostName(remoteNotifyServer.getServer()); email.setSmtpPort(Integer.parseInt(remoteNotifyServer.getPort())); setEmailAuth(remoteNotifyServer, email); email.setFrom(remoteNotifyServer.getEmailFrom()); email.setCharset(EMAIL_CHARSET); email.setSubject(title); email.setMsg(content); email.setSocketTimeout(LegoNumberConstant.THIRTY * LegoNumberConstant.THOUSAND); List&lt;InternetAddress&gt; internetAddresses = Collections.singletonList(new InternetAddress(receiver)); email.setTo(internetAddresses); email.setSocketTimeout(IsmNumberConstant.THOUSAND * IsmNumberConstant.FIVE); email.setSocketConnectionTimeout(IsmNumberConstant.THOUSAND * IsmNumberConstant.FIVE); // 设置代理服务器的系统变量 Properties props = setProperty(remoteNotifyServer, email); initMailcapCommandMap(); Properties properties = email.getMailSession().getProperties(); properties.putAll(props); email.send(); private Properties setProperty(RemoteNotifyServer remoteNotifyServer, MultiPartEmail email) { Properties properties = new Properties(); // 使用代理发送 if (remoteNotifyServer.isProxyEnable()) { properties.setProperty(PROXY_SET, TRUE); properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/599c8e52a5a00898c844aeb57eacaf3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be4c3a07d3eb7e1c4ba120ab82aeb06/" rel="bookmark">
			Java 集合深入理解 （八） ：Collection接口和list接口对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
List接口是继承自Collection接口，在collection接口上做一些扩展，相对于一些基本操作增加了一些包括视图，位置查询等操作
方法操作对比 Collection方法
list方法
Collection （集合）的操作：
1.查询操作
size isEmpty contains iterator toArray
2. 修改操作
add remove
3.批量修改操作
containsAll addAll removeAll retainAll clear
4.比较和散列
equals hashCode
5.default 默认方法
spliterator stream
List （列表）的操作：
1.查询操作
size isEmpty contains iterator toArray
2. 修改操作
add remove
3. 批量修改操作
containsAll addAll removeAll retainAll clear sort
4.比较和散列
equals hashCode
5.位置访问操作
get set add(int index, E element) remove(int index)
6.搜索 操作
indexOf lastIndexOf
7.List 迭代器
listIterator listIterator
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9be4c3a07d3eb7e1c4ba120ab82aeb06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1acdc2699553976c1cfa1d1cee168b/" rel="bookmark">
			关于高版本MigrateCommand不能使用的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于高版本MigrateCommand不能使用的问题 先说说我自己的想法：一开始遇到这个问题，我以为是python软件版本太高，后来，我把最新版软件卸了，重新安装了python3.7,结果试了一下还是出现原来的问题。这让我绝望了。报错如下：
File "app.py", line 1, in &lt;module&gt; from flask_migrate import Migrate,MigrateCommand ImportError: cannot import name 'MigrateCommand' 结果，不知道脑子怎么一下子想到了包的问题上，结果把有的包的版本改了一下就可以了。比如:
pip install flask-migrate==2.5.3 我把包改过来之后，又出现了另一个问题:
from flask_script import Manager File "D:\pythonProject\ENV\flaskproject\lib\sitepackages\flask_script\__init__.py", line 15, in &lt;module&gt; from flask._compat import text_type ModuleNotFoundError: No module named 'flask._compat' 这让我琢磨到半夜，结果还是睡了，到第二天搜到了类似的问题，原来是python中的flask版本过高，重新改一下就可以了。
pip install flask==1.1.2 我认为最简单的办法就是给pip版本降级:
python -m pip install pip=='自己想要的pip'版本 总结：pip新版本真的有太多的坑，所以，不是所有的软件最新版本都是最好的。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/311/">«</a>
	<span class="pagination__item pagination__item--current">312/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/313/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>