<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a15d7ef568208b75445e7e28a8469a8/" rel="bookmark">
			【原生js】js动态添加dom，如何绑定事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要明白浏览器在加载页面的时候是按顺序来加载的，这样以来就很清楚了，js动态添加dom以后，这些dom并没有绑定事件，这个时候最简单的一个办法就是：将绑定事件的方法封装到一个函数A中，在动态添加完dom以后立即执行一次函数A即可。
需要注意的是，在你可能同时需要添加许多的dom，不要添加一个就执行一次函数A，这样会增加浏览器的负载，你需要在所有dom添加完以后在执行函数A，例如你用一个for循环遍历dom组合并拼接成一个字符串，然后添加到某个父级dom里面，这个时候你需要在循环外添加一次就可以了。
代码如下：
1 &lt;!DOCTYPE html&gt; 2 &lt;html lang="en"&gt; 3 &lt;head&gt; 4 &lt;meta charset="UTF-8"&gt; 5 &lt;title&gt;添加div并绑定点击事件&lt;/title&gt; 6 &lt;style&gt; 7 div.btn{ 8 width: 200px; 9 height: 50px; 10 line-height: 50px; 11 text-align: center; 12 border: solid 1px #000; 13 cursor: pointer; 14 } 15 div.innerDiv{ 16 width: 50px; 17 height: 50px; 18 background-color: black; 19 margin: 10px; 20 cursor: pointer; 21 } 22 &lt;/style&gt; 23 &lt;/head&gt; 24 &lt;body&gt; 25 &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a15d7ef568208b75445e7e28a8469a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141ad29a3e440faf55e99e707df2d7dc/" rel="bookmark">
			play框架使用起来（16）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、缓存 缓存是用来避免频繁到服务器端获取数据而建立的一个存取更快的临时存储器。缓存的容量相对较小，但执行速度非常快，其主要作用为：
存储系统经常访问的数据。存储耗时较长的计算结果。 合理地缓存数据，可以提高系统的性能。Play内置了缓存库，并为分布式环境提供了Memcached缓存数据的支持。
补充： Memcached是一套开源的分布式内存对象缓存系统，它通过在内存中缓存数据和对象来减少读取数据库的次数，从而大幅度降低数据库负载。
如果项目中没有配置Memcached，Play将使用JVM堆中的独立缓存进行数据存储。但是将数据缓存在不同服务器的JVM堆中破坏了Play的share nothing原则：我们不能将应用程序运行在多个服务器上的同时，还期望数据保持一致，这样做只会导致每个程序实例都拥有各自不同的数据副本。
当我们在使用缓存时，必须明确其自身特性：缓存存在于内存中（不进行持久化），只是用于存放暂时性的数据，时间一到就会过期。因此缓存并不是一个安全的存储器，不能保证数据可以永久存在。如果发现数据在缓存中已过期，需要重新获取数据，并再次放入缓存：
public static void allProducts() { List&lt;Product&gt; products = Cache.get("products", List.class); if(products == null) { products = Product.findAll(); Cache.set("products", products, "30mn"); } render(products);} 1.1 缓存 API# play.cache.Cache类提供了一系列访问缓存的API，包含了完整的设置、替换和获取数据的方法：
public static void showProduct(String id) { Product product = Cache.get(id, Product.class); if(product == null) { product = Product.findById(id); Cache.set("product_"+id, product, "30mn"); } render(product);} public static void addProduct(String name, int price) { Product product = new Product(name, price); product.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/141ad29a3e440faf55e99e707df2d7dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f20e5ca646fcc9919be6813455108771/" rel="bookmark">
			构造方法，初始化块和静态初始化块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始学习java，对于构造方法，初始化块和静态初始化块感觉比较迷茫，所以做出一些简单的总结
初始化块：构造器的补充，初始化块不能接受任何参数，定义一些所有对象共有属性方法时可以使用初始化块进行初始化。
“里面的代码在创建Java对象时执行，而且在构造器之前执行！”，每个对象生成时都会被执行一次
例如：
{ System.out.println("通过初始化块初始化sex"); sex = "男"; } 静态初始化块: 使用static定义，当类装载到系统时执行一次，若在静态出是坏块中想初始化变量，只能初始化静态变量 例如：
static { System.out.println("通过静态初始化块初始化age"); age = 20;//age是静态变量，请看后面的全部代码 } 构造函数：不做更多讲解 public HelloWorld () { System.out.println("通过构造方法初始化name"); name = "tom"; } 那你知道这三种方式的运放顺序吗？？ 代码：
public class HelloWorld { String name; // 声明变量name String sex; // 声明变量sex static int age;// 声明静态变量age // 构造方法 public HelloWorld () { System.out.println("通过构造方法初始化name"); name = "tom"; } // 初始化块 { System.out.println("通过初始化块初始化sex"); sex = "男"; } // 静态初始化块 static { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f20e5ca646fcc9919be6813455108771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2742bb5d5d175ac492aa38249445216/" rel="bookmark">
			Ext.create()方法浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		译自：http://docs.sencha.com/extjs/4.2.0/#!/api/Ext-method-create
create( [name], [args] ) : Object Instantiate a class by either full name, alias or alternate name.
If Ext.Loader is enabled and the class has not been defined yet, it will attempt to load the class via synchronous loading.
For example, all these three lines return the same result:
// alias var window = Ext.create('widget.window', { width: 600, height: 800, ... }); // alternate name var window = Ext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2742bb5d5d175ac492aa38249445216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/346dda0b67c02fc550dba6ce668c5a50/" rel="bookmark">
			干货：五分钟带你看懂NestedScrolling嵌套滑动机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android NestedScrolling嵌套滑动机制 Android在发布5.0之后加入了嵌套滑动机制NestedScrolling,为嵌套滑动提供了更方便的处理方案。在此对嵌套滑动机制进行详细的分析。
嵌套滑动的常见用法比如在滑动列表的时候隐藏相关的TopBar和BottomBar，增加列表的信息展示范围，让用户聚焦于App想展示的内容上等。官方出的Design包里也有很多支持该机制的炫酷控件，比如CoordinatorLayout，AppBarLayout等，在用户体验上有很大的进步。
说道嵌套滑动，离不开以下几个内容：
NestedScrollingChildNestedScrollingParentNestedScrollingChildHelperNestedScrollingParentHelper 在具体说明之前，先来看看我们的Sample，这是一个仿携程机票首页的Demo
这里用到了一个实现了NestedScrollingParent的CollaspingLayout作为父View和一个实现了NestedScrollingChild的NestedScrollView作为子View进行嵌套滑动，布局可以简单的描述成：
具体的布局结构大致如下： &lt;com.lycc.flight.fastproject.widget.search.CollaspingLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:orientation="vertical" android:id="@+id/pl_container" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="160dp"&gt; &lt;com.yyydjk.library.BannerLayout android:id="@+id/banner" android:layout_width="match_parent" android:layout_height="160dp" app:autoPlayDuration="5000" app:indicatorMargin="50dp" app:indicatorPosition="centerBottom" app:indicatorShape="oval" app:indicatorSpace="3dp" app:scrollDuration="1100" app:defaultImage="@mipmap/ic_launcher" app:selectedIndicatorColor="?attr/colorPrimary" app:selectedIndicatorHeight="6dp" app:selectedIndicatorWidth="6dp" app:unSelectedIndicatorColor="#99ffffff" app:unSelectedIndicatorHeight="6dp" app:unSelectedIndicatorWidth="6dp" app:layout_collapseMode="parallax" app:layout_collapseParallaxMultiplier="0.7"/&gt; &lt;View android:id="@+id/view" android:layout_width="match_parent" android:layout_height="40dp" android:background="@drawable/gradient" /&gt; &lt;FrameLayout android:id="@+id/search_tab_container" android:layout_width="match_parent" android:layout_height="43dp" android:layout_marginBottom="-4dp" android:layout_alignParentBottom="true"&gt; &lt;View android:layout_width="match_parent" android:layout_height="40dp" android:background="#5a000000" android:layout_marginLeft="5dp" android:layout_marginTop="3dp" android:layout_marginBottom="-4dp" android:layout_marginRight="5dp"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="bottom" android:layout_marginBottom="-4dp" android:layout_marginLeft="5dp" android:layout_marginRight="5dp" android:orientation="horizontal"&gt; &lt;View android:id="@+id/slide_bg" android:layout_width="120dp" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/346dda0b67c02fc550dba6ce668c5a50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab77cd533601a69b6f15f480b349a0f6/" rel="bookmark">
			TCP/IP、Http、Socket的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TCP/IP、Http、Socket的区别 大学学习网络基础的时候老师讲过，网络由下往上分为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。通过初步的了解，我知道IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层，三者从本质上来说没有可比性，socket则是对TCP/IP协议的封装和应用（程序员层面上）。也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍： “我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。” 而我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。网络有一段关于socket和TCP/IP协议关系的说法比较容易理解： “TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。” 关于TCP/IP协议的相关只是，用博大精深来讲我想也不为过，单单查一下网上关于此类只是的资料和书籍文献的数量就知道，这个我打算会买一些经典的书籍（比如《TCP/IP详解：卷一、卷二、卷三》）进行学习，今天就先总结一些基于基于TCP/IP协议的应用和编程接口的知识，也就是刚才说了很多的HTTP和Socket。 CSDN上有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。 下面是一些经常在笔试或者面试中碰到的重要的概念，特在此做摘抄和总结。 一。什么是TCP连接的三次握手 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开） 二。利用Socket建立网络连接的步骤 建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。 1。服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 2。客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 3。连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 三。HTTP链接的特点 HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。 HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。 四。TCP和UDP的区别（考得最多。。快被考烂了我觉得- -\\） 1。TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上（实际上也很大程度上保证了）保证了连接的可靠性；而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。 2。也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。 知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的，因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现了TCP所无法达到的传输效率。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c60c8778803e5bb2fff8f370cd1d6f34/" rel="bookmark">
			React Native安卓源码学习（一 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://blog.csdn.net/BingHongChaZuoAn/article/details/53011923
Android加载jsbundle详解。
前段时间做了个 React Native的项目，也没时间好好研究下React Native 安卓端的代码。现在闲下来了，看了看Android端的源码，感受颇深。做下总结，也方便自己以后回顾学习。
首先看主Activity
public class MainActivity extends ReactActivity { /** * Returns the name of the main component registered from JavaScript. * This is used to schedule rendering of the component. */ @Override protected String getMainComponentName() { return "xxx"; } } 这里只有一个方法 getMainComponentName，获取的是jsbundle加载的首组件名字。也可以叫做启动页吧，这里必须和jsbundle里面设置的一致。
既然 MainActivity 继承ReactActivity ，那么接下来我们来看 ReactActivity 吧。
private final ReactActivityDelegate mDelegate; protected ReactActivity() { mDelegate = createReactActivityDelegate(); } @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c60c8778803e5bb2fff8f370cd1d6f34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e4f23c6c9708995df2d913db9c231a4/" rel="bookmark">
			MySQL数据类型介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL的数据类型 主要包括以下五大类：
整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT
浮点数类型：FLOAT、DOUBLE、DECIMAL
字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB
日期类型：Date、DateTime、TimeStamp、Time、Year
其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等
1、整型
MySQL数据类型含义（有符号）tinyint(m)1个字节 范围(-128~127)smallint(m)2个字节 范围(-32768~32767)mediumint(m)3个字节 范围(-8388608~8388607)int(m)4个字节 范围(-2147483648~2147483647)bigint(m)8个字节 范围(+-9.22*10的18次方) 取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。
int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。
2、浮点型(float和double)
MySQL数据类型含义float(m,d)单精度浮点型 8位精度(4字节) m总个数，d小数位double(m,d)双精度浮点型 16位精度(8字节) m总个数，d小数位 设一个字段定义为float(5,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。
3、定点数
浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位。
4、字符串(char,varchar,_text)
MySQL数据类型含义char(n)固定长度，最多255个字符varchar(n)可变长度，最多65535个字符tinytext可变长度，最多255个字符text可变长度，最多65535个字符mediumtext可变长度，最多2的24次方-1个字符longtext可变长度，最多2的32次方-1个字符 char和varchar：
1.char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 2.char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，
所以varchar(4),存入3个字符将占用4个字节。 3.char类型的字符串检索速度要比varchar类型的快。
varchar和text： 1.varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字
节。 2.text类型不能有默认值。 3.varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。
5.二进制数据(_Blob)
1._BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。
2._BLOB存储的数据只能整体读出。 3._TEXT可以指定字符集，_BLO不用指定字符集。
6.日期时间类型
MySQL数据类型含义date日期 '2008-12-2'time时间 '12:25:36'datetime日期时间 '2008-12-2 22:06:44'timestamp自动存储记录修改时间 若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。
数据类型的属性
MySQL关键字含义NULL数据列可包含NULL值NOT NULL数据列不允许包含NULL值DEFAULT默认值PRIMARY KEY主键AUTO_INCREMENT自动递增，适用于整数类型UNSIGNED无符号CHARACTER SET name指定一个字符集 二、MYSQL数据类型的长度和范围 各数据类型及字节长度一览表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e4f23c6c9708995df2d913db9c231a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea6281e61460d6460326846ad60f73ba/" rel="bookmark">
			onTouchEvent(二) 使用Scroller实现黏性滑动的ScrollView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为楼主原创，转载请表明出处：http://blog.csdn.net/suma_sun/article/details/52900476 上一篇博文介绍了onTouchEvent()手势控制相关的一些坐标概念，这篇文章结合上一篇内容加上Scroller实现一个简单的带黏性滑动的ScrollView。
思路 滑动的时候判断最终偏移量是不是超出了子view(ViewGroup内容)的范围，如果超出了就限制不让其超出，这样就可以做出一个滑动的ScrollView并且不会滑出界当松手(action_up)的时候判断当前偏移量在该子view的什么位置，如果小于三分之一就滑动回该view的头部，如果超出三分之二就滑动到下个view 首先看看我们需要做些什么，自定义View要复写的方法有好几个，我们要复写的有： 1. onMeasure() 2. onLayout() 3. onTouchEvent() 4. computeScroll()
因为是ViewGroup需要计算、定位子View所以需要复写1和2两个函数。 3不用说了，要实现滑动功能必须要实现的函数。 4这是配合Scroller使用的一个函数。
首先介绍下Scroller这个类，这个类是一个工具，并不是实际UI操作。这个工具提供的功能是提供差值计算，就像属性动画一样，要做一个平滑过渡的动画需要用到差值器来辅助提供偏移差值。
下面是一个不使用Scroller的Demo。 差别很明显。
onMeasure @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //遍历子View，测量子View int count = getChildCount(); for (int i = 0; i &lt; count; i++) { View view = getChildAt(i); measureChild(view, widthMeasureSpec, heightMeasureSpec); } super.onMeasure(widthMeasureSpec, heightMeasureSpec); } onMeasure()没什么好说的，遍历子view，测量子view。
onLayout @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { // 这里的四个坐标都是以ViewGroup来参照的，而不是屏幕的原点 // top默认0 // left默认0 // right默认屏幕宽度,ViewGroup的布局mactch_parent // bottom默认屏幕高度,ViewGroup的布局mactch_parent int count = getChildCount(); for (int i = 0; i &lt; count; i++) { View view = getChildAt(i); //这个demo模仿垂直的ScrollView所以就没有累计宽度 int right = view.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea6281e61460d6460326846ad60f73ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199a0c16a8d210f20a53f6d6494efd59/" rel="bookmark">
			【Launcher】获取最新Launcher源码，并且导入到Android Studio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装好git,官方网站git下载过慢的可以通过该链接下载：http://download.csdn.net/detail/q849340003/9670061
2.翻墙的可以直接通过 git clone https://android.googlesource.com/platform/packages/apps/Launcher3 下载源码（git命令不熟悉的自行百度，如果翻墙了下载中还出现 443 Time Out，请通过Git 命令设置Git代理： git config --global http.proxy "localhost:1080"） 没有翻墙的可以通过 git clone https://github.com/blanks1314/newest_launcher.git 下载 3.源码下载完毕后，通过git命令检出相应的版本，我检出的是nougat-release该分支下的版本，从名称可以看出该版本是7.0所使用的
4.最坑的步骤，先直接打开该项目等待project build,如果完成后没有出现错误，直接运行，如果出现错误找到项目文件夹下的gradle文件夹，打开其中gradle-wrapper.properties文件，修改为
gradle版本为图中所示版本，在重新同步gradle，需要等待一段时间，完成后应该就没有错误了
5.编译运行，至此准备工作结束，下面就可以开始研究launcher的源码了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844a0a88dfa81a018033bd965baad8a2/" rel="bookmark">
			如何进入、退出docker的container
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处：http://blog.csdn.net/dongdong9223/article/details/52998375
本文出自【我是干勾鱼的博客】
1 启动docker服务 首先需要知道启动docker服务是：
service docker start 或者：
systemctl start docker 2 关闭docker服务 关闭docker服务是：
service docker stop 或者：
systemctl stop docker 3 启动docker某个image（镜像）的container（容器） Docker的镜像称为image，容器称为container。
对于Docker来说，image是静态的，类似于操作系统快照，而container则是动态的，是image的运行实例。
比如，有一个image名称为ubuntu，那么比如现在我们启动这个image的container并且进入到这个container的bash命令行中：
docker run -t -i ubuntu /bin/bash 官网是这么说的：
docker run: runs a container.ubuntu: is the image you would like to run.-t: flag assigns a pseudo-tty or terminal inside the new container.-i: flag allows you to make an interactive connection by grabbing the standard in (STDIN) of the container.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/844a0a88dfa81a018033bd965baad8a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c195adeef57769eed211eec6b9924de/" rel="bookmark">
			IMEI,IMSI和ICCID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IMEI,IMSI和ICCID IMEI(International Mobile Equipment Identity)是国际移动设备身份码的缩写,国际移动装备辨识码,是由15位数字组成的"电子串号",它与每台手机一一对应,而且该码是全世界唯一的.每一部手机在组装完成后都将被赋予一个全球唯一的一组号码,这个号码从生产到交付使用都将被制造生产的厂商所记录.手机用户可以在手机中查到自己手机的IMEI码.
IMEI可用移动终端设备通过键入“*#06#”查得(不同厂商的手机所需输入的内容不同,同一厂商不同手机所需输入的内容也可能不同).其总长为15位,每位数字仅使用0～9的数字.IMEI码由GSM(全球移动通信协会)统一分配,授权BABT(英国通信认证管理委员会)审受.
IMEI组成为:
1、前6位数(TAC,Type ApprovalCode)是"型号核准号码",一般代表机型.2、接着的2位数(FAC,Final Assembly Code)是"最后装配号"，一般代表产地.3、之后的6位数(SNR)是"串号",一般代表生产顺序号.4、最后1位数(SP)通常是"0",为检验码,备用. 国际移动用户识别码(IMSI:International Mobile Subscriber Identification Number)是区别移动用户的标志,储存在SIM卡中,可用于区别移动用户的有效信息.其总长度不超过15位,同样使用0～9的数字.
IMSI 与你的手机卡是绑定关系,用于区别移动用户的有效信息.
IMEI 与你的手机是绑定关系,用于区别移动终端设备.
ICCID:Integrate circuit card identity 集成电路卡识别码(固化在手机SIM卡中),简单来说就是SIM卡序列号,它拥有独一无二的特性,类似于手机的序列号,仅仅指向一张手机卡.共有20位数字组成,不同运营商编码格式不一样.并且前六位数字为运营商代码:比如中国移动的为:898600;中国联通的为:898601,中国电信的为:898603.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0f2fd1485b4c08b4f265621ee5036e/" rel="bookmark">
			Android研发安全3-Service安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Android系统开发中，Service是一个重要的组成部分。如果现在某些程序中的某部分操作是很耗时的，那么可以将这些程序定义在Service中，这样就可以在后台运行，也可以在不显示界面的形式下运行，即，Service实际上就是相当于一个没有图形界面的Activity程序，而且当用户执行某些操作需要进行跨进程访问的时候也可以使用Service来完成。
Service的分类 本地服务（Local） 该服务依附在主进程上，不是独立的进程。本地服务在一定程度上节约了资源，由于是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。主进程被Kill后，服务便会终止。 远程服务（Remote） 该服务是独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。但由于独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。一些提供系统服务的Service通常是常驻的。
Service组件已知产生的安全问题 权限提升 Service劫持 拒绝服务 消息伪造 安全问题案例 以拒绝服务问题为例，常见的拒绝服务分为两种：
1.java.lang.NullPointerException 空指针异常导致的拒绝服务 ClassCastException 2.类型转换异常导致的拒绝服务
POC内传入畸形数据即可引发crash，捕获异常即可修复。
研发人员该如何预防 不同Service的安全描述 私有Service：不能被其他应用调用,相对安全 公共Service：可以被任意应用调用 可信Service：只能被可以信任的应用调用内部Service：只能被内部应用调用 intent-filter与exported属性配置方法 私有service不定义intent-filter并且设置exported为false公开的service设置exported为true，intent-filter可以定义或者不定义内部或可信service设置exported为true，intent-filter不定义 安全研发建议 应用内部使用的Service应设置为私有 针对Service接收到的数据应该验证并谨慎处理内部Service需要使用签名级别的protectionLevel来判断是否未内部应用调用不建议在onCreate方法调用的时候决定是否提供服务，建议在onStartCommand、onBind、onHandleIntent等方法被调用的时候做判断使用显示意图只针对有明确服务需求的情况 尽量不发送敏感信息 可信任的Service需要对第三方可信公司的app签名做效验 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe05c25a9f061f4e724e2e4b9fa4c70f/" rel="bookmark">
			分支限界法的0-1背包问题Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;pre name="code" class="python"&gt;重量为[3,5,2,1] 值为[9,10,7,4] 背包的总重为7，主要运用的queue的特性 #coding : utf-8 import numpy as np import Queue import math w = [3,5,2,1]#weight v = [9,10,7,4]#value def test(capacity): vec_len = 2**(len(v)+1) - 1#tree `s size vec_v = np.zeros(vec_len) vec_w = np.zeros(vec_len) vec_w[0]=capacity que = Queue.Queue(); que.put(0) best = 0 while(not que.empty()): current = que.get() level = int(math.log(current+1,2)) if(vec_v[current] &gt; vec_v[best]): best = current left = 2*current+1#left child index right = 2*current+2#right child index if(left &lt; vec_len and vec_w[current]-w[level] &gt; 0 and vec_v[current]+v[level] &gt; vec_v[best] ): vec_v[left] = int(vec_v[current]+v[level]) vec_w[left] = vec_w[current]-w[level] que.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe05c25a9f061f4e724e2e4b9fa4c70f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c838b375c6e3c3e1d33701f2265c7fe/" rel="bookmark">
			机器学习：scikit-learn 做笑脸识别 (SVM, KNN, Logisitc regression)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scikit-learn 是 Python 非常强大的一个做机器学习的包，今天介绍scikit-learn 里几个常用的分类器 SVM, KNN 和 logistic regression，用来做笑脸识别。
这里用到的是GENKI4K 这个数据库，每张图像先做一个人脸检测与剪切，然后提取HOG特征。这个数据库有 4000 张图，分成4组，做一个 cross validation，取平均值作为最终的识别率:
import string, os, sys import numpy as np import matplotlib.pyplot as plt import scipy.io import random from sklearn import neighbors, linear_model, svm dir = '/GENKI4K/Feature_Data' print '----------- no sub dir' # prepare the data files = os.listdir(dir) for f in files: print dir + os.sep + f file_path=dir+os.sep+files[14] #print file_path dic_mat = scipy.io.loadmat(file_path) data_mat=dic_mat['Hog_Feat'] print 'feature: ', data_mat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c838b375c6e3c3e1d33701f2265c7fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec4089260df0c034dba72d44bd1f1130/" rel="bookmark">
			ｉｄｅａ报错：[2016-08-31 09:20:10,763] Artifact xxx:war exploded: Error during artifact deployment.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from: http://blog.csdn.net/petershusheng/article/details/52382216
[2016-08-31 09:20:10,763] Artifact newClassProject1:war exploded: Error during artifact deployment. See server log for details.
[2016-08-31 09:20:10,764] Artifact newClassProject1:war exploded: com.intellij.javaee.oss.admin.jmx.JmxAdminException: com.intellij.execution.ExecutionException: D:\xxx\xxx\xxx\xxx\out\artifacts\xxx_war_exploded not found for the web module. 原因：没有下图的底下的红色框的内容.(不能部署源码,需要部署war包什么的) 正确操作顺序,: 然后: 然后确认下图的信息都齐全即可: 然后即可部署成功.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d6d6003e726cfe197d6d4860282985/" rel="bookmark">
			ubuntu   VirtualBox   增加根目录空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 去除闲置空间
sudo apt-get clean
2、安装gparted分区工具
sudo apt-get gparted
3、运行gparted
a)查看分区情况
b)删除/dev/sda5 /dev/sda2
c)重新分配/dev/sda1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5766cad9bb6687dc74e6605cacc44a03/" rel="bookmark">
			在Oracle11g 中新建用户，授予只读用户权限详细步骤 (批量执行授权多表查询)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建新用户 create user macs identified by 123456 default tablespace tablespacename;
2、授权connect 和 synonym grant connect to macs;
grant create synonym to macs;
3、授权查询表的权限
grant select on tablespacename.M_TMP to t1;
4、创建同义词
create or replace SYNONYM MACS.M_TMP FOR tablespacename.M_TMP;
5、完成。测试查询
备注：
1、批量执行授权多表查询权限的查询语句
select 'grant select on '||owner||'.'||object_name||' to t1;'
from dba_objects
where owner in ('tablespacename')
and object_type='TABLE';
2、批量执行创建同义词查询语句
SELECT 'create or replace SYNONYM MACS.' || object_name|| ' FOR ' || owner || '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5766cad9bb6687dc74e6605cacc44a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab702f5412ec4cee96b0d529dfd6314/" rel="bookmark">
			Faster_rcnn训练自己的数据集(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在看了一些深度学习的目标检测的论文后，想着去用开源的代码去跑一下，看看实际的效果。于是小菜就想着直接把faster_rcnn用起来，包括前期的faster_rcnn安装和配置并运行其中的一个demo.py。后面是用自己的数据集训练faster_rcnn的模型。 1. 准备工作：
1) 搭建caffe框架
这个可以参考Linux先搭建caffe的笔记。
2) 安装第三方依赖包：Cython、 Python-OpenCV、easydict
pip install cython pip install easydict apt-get install python-opencv 123 123 3) 下载py-faster-rcnn # Make sure to clone with --recursive git clone --recursive https://github.com/rbgirshick/py-faster-rcnn.git 12 12 4) 编译faster_rcnn 进入py-faster-rcnn/lib，执行make
cd py-faster-rcnn/lib make 12 12 5) 配置faster_rcnn 进入py-faster-rcnn\caffe-fast-rcnn，执行
cp Makefile.config.example Makefile.config 1 1 然后，配置Makefile.config文件，配置好Makefile.config文件后，执行：
make –j4 &amp;&amp; make pycaffe 1 1 注：我在这一步出错了，老是不能编译成功。问题应该是出在Makefile.config文件内容中的，应该是出在路径添加中出错。
解决： 在原来搭建的caffe文件中将Makefile.config文件内容直接复制过来。 接下来下载已经训练好的faster模型，进入py-faster_rcnn/data/scripts目录，执行./fech-faster_rcnn_models,sh
6) 测试faster_rcnn 运行网络和加载下载的模型进行最后的测试demo 执行：
./tools/demo.py 1 1 出现问题： ImportError：No module named yaml 解决:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab702f5412ec4cee96b0d529dfd6314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5882ba22383fcc00d3e777423b279c3c/" rel="bookmark">
			OC类型常量的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		objective 类型常量的使用 static 修饰的全局变量 只在该源文件中可见，全局变量的生命周期和程序一样，在@implement之外声明extern 修饰的全局变量 可在所有源文件中使用
参考博客： http://9077272.blog.51cto.com/9067272/1683688
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c693c5139a687803620d031a476833/" rel="bookmark">
			angular2的http请求返回结果的subcribe注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		this.monitorSer.getVehicleLonAndLat(vehicleIds) .subscribe( data =&gt; { //将data下的data字符串转化为vehdata数组 this.vehData=JSON.parse(data.data); //功能实现 this.loadOverLay(); }, error =&gt; this.errorMessage = &lt;any&gt;error
);//错误处理
subscribe（）异步处理，如果需要用返回的数据，最好把方法写在里面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78312613e1dde87bce90b13392dbae64/" rel="bookmark">
			Deep Compression阅读理解及Caffe源码修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新： 没想到这篇文章写出后有这么多人关注和索要源码，有点受宠若惊。说来惭愧，这个工作当时做的很粗糙，源码修改的比较乱，所以一直不太好拿出手。最近终于有时间整理了一下代码并开源出来了。关于代码还有以下几个问题： ~1.在.cu中目前仍然是调用cpu_data接口，所以可能会增加与gpu数据交换的额外耗时，这个不影响使用，后面慢慢优化。~(已解决) 2.目前每层权值修剪的比例仍然是预设的，这个比例需要迭代试验以实现在尽可能压缩权值的同时保证精度。所以如何自动化选取阈值就成为了后面一个继续深入的课题。 3.直接用caffe跑出来的模型依然是原始大小，因为模型依然是.caffemodel类型，虽然大部分权值为0且共享，但每个权值依然以32float型存储，故后续只需将非零权值及其下标以及聚类中心存储下来即可，这部分可参考作者论文，写的很详细。 4.权值压缩仅仅压缩了模型大小，但在前向inference时不会带来速度提升。因此，想要在移动端做好cnn部署，就需要结合小的模型架构、模型量化以及NEON指令加速等方法来实现。 代码开源在github https://github.com/may0324/DeepCompression-caffe 最近又转战CNN模型压缩了。。。（我真是一年换N个坑的节奏），阅读了HanSong的15年16年几篇比较有名的论文，启发很大，这篇主要讲一下Deep Compression那篇论文，因为需要修改caffe源码，但网上没有人po过，这里做个第一个吃螃蟹的人，记录一下对这篇论文的理解和源码修改过程，方便日后追本溯源，同时如果有什么纰漏也欢迎指正，互相交流学习。 这里就从Why-How-What三方面来讲讲这篇文章。
Why 首先讲讲为什么CNN模型压缩刻不容缓，我们可以看看这些有名的caffe模型大小: 1. LeNet-5 1.7MB 2. AlexNet 240MB 3. VGG-16 552MB LeNet-5是一个简单的手写数字识别网络，AlexNet和VGG-16则用于图像分类，刷新了ImageNet竞赛的成绩，但是就其模型尺寸来说，根本无法移植到手机端App或嵌入式芯片当中，就算是想通过网络传输，较高的带宽占用率也让很多用户望尘莫及。另一方面，大尺寸的模型也对设备功耗和运行速度带来了巨大的挑战。随着深度学习的不断普及和caffe,tensorflow,torch等框架的成熟，促使越来越多的学者不用过多地去花费时间在代码开发上，而是可以毫无顾及地不断设计加深网络，不断扩充数据，不断刷新模型精度和尺寸，但这样的模型距离实用却仍是望其项背。 在这样的情形下，模型压缩则成为了亟待解决的问题，其实早期也有学者提出了一些压缩方法，比如weight prune(权值修剪)，权值矩阵SVD分解等，但压缩率也只是冰山一角，远不能令人满意。今年standford的HanSong的ICLR的一篇论文Deep Compression: Compressing deep neural networks with pruning, trained quantization and Huffman coding一经提出，就引起了巨大轰动，在这篇论文工作中，他们采用了3步，在不损失（甚至有提升）原始模型精度的基础上，将VGG和Alexnet等模型压缩到了原来的35~49倍，使得原本上百兆的模型压缩到不到10M，令深度学习模型在移动端等的实用成为可能。
How Deep Compression 的实现主要有三步，如下图所示： 包括Pruning（权值修剪），Quantization（权值共享和量化），Huffman Coding（Huffman编码）。
1.Prunning 如果你调试过caffe模型，观察里面的权值，会发现大部分权值都集中在-1~1之间，即非常小，另一方面，神经网络的提出就是模仿人脑中的神经元突触之间的信息传导，因此这数量庞大的权值中，存在着不可忽视的冗余性，这就为权值修剪提供了根据。pruning可以分为三步： step1. 正常训练模型得到网络权值； step2. 将所有低于一定阈值的权值设为0； step3. 重新训练网络中剩下的非零权值。 经过权值修剪后的稀疏网络，就可以用一种紧凑的存储方式CSC或CSR（compressed sparse column or compressed sparse row）来表示。这里举个栗子来解释下什么是CSR 假设有一个原始稀疏矩阵A CSR可以将原始矩阵表达为三部分，即AA,JA,IC 其中，AA是矩阵A中所有非零元素，长度为a，即非零元素个数； JA是矩阵A中每行第一个非零元素在AA中的位置，最后一个元素是非零元素数加1，长度为n+1, n是矩阵A的行数； IC是AA中每个元素对应的列号，长度为a。 所以将一个稀疏矩阵转为CSR表示，需要的空间为2*a+n+1个，同理CSC也是类似。 可以看出，为了达到压缩原始模型的目的，不仅需要在保持模型精度的同时，prune掉尽可能多的权值，也需要减少存储元素位置index所带来的额外存储开销，故论文中采用了存储index difference而非绝对index来进一步压缩模型，如下图所示： 其中，第一个非零元素的存储的是他的绝对位置，后面的元素依次存储的是与前一个非零元素的索引差值。在论文中，采用固定bit来存储这一差值，以图中表述为例，如果采用3bit，则最大能表述的差值为8，当一个非零元素距其前一个非零元素位置超过8，则将该元素值置零。（这一点其实也很好理解，如果两个非零元素位置差很多，也即中间有很多零元素，那么将这一元素置零，对最终的结果影响也不会很大） 做完权值修剪这一步后，AlexNet和VGG-16模型分别压缩了9倍和13倍，表明模型中存在着较大的冗余。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78312613e1dde87bce90b13392dbae64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00c2e3bf349e7311cfb6d229db0178e/" rel="bookmark">
			java 生成word文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自:http://18810098265.iteye.com/blog/2056122
最近需要做一个导出word的功能, 在网上搜了下, 有用POI,JXL,iText等jar生成一个word文件然后将数据写到该文件中,API非常繁琐而且拼出来的样式也不美观,于是选择了另一种方式----feemarker基于word模板的导出方式, 这种方式非常简单而且导出的样式美观, 其原理就是先做一个word模板, 该模板中变量数据用${xxx}这种方式填写, 然后再导出时只需读取模板然后用相应的数据替换其中的${xxx}即可. 一,简单模板导出(不含图片, 不含表格循环) 1, 新建一个word文档, 输入如下类容: 2, 将该word文件另存为xml格式(注意是另存为,不是直接改扩展名) 3, 将xml文件的扩展名直接改为ftl 4, 用java代码完成导出(需要导入freemarker.jar) Java代码 @Test public void exportSimpleWord() throws Exception{ // 要填充的数据, 注意map的key要和word中${xxx}的xxx一致 Map&lt;String,String&gt; dataMap = new HashMap&lt;String,String&gt;(); dataMap.put("username", "张三"); dataMap.put("sex", "男"); //Configuration用于读取ftl文件 Configuration configuration = new Configuration(); configuration.setDefaultEncoding("utf-8"); /*以下是两种指定ftl文件所在目录路径的方式, 注意这两种方式都是 * 指定ftl文件所在目录的路径,而不是ftl文件的路径 */ //指定路径的第一种方式(根据某个类的相对路径指定) //configuration.setClassForTemplateLoading(this.getClass(),""); //指定路径的第二种方式,我的路径是C:/a.ftl configuration.setDirectoryForTemplateLoading(new File("C:/")); // 输出文档路径及名称 File outFile = new File("D:/test.doc"); //以utf-8的编码读取ftl文件 Template t = configuration.getTemplate("a.ftl","utf-8"); Writer out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outFile), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c00c2e3bf349e7311cfb6d229db0178e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1493cbf7d0dbf7dd489b926ad6eed30/" rel="bookmark">
			恶意代码--dll动态链接库注入目标进程隐藏自身（亲测win7x86和x64有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 dll 注入 所谓DLL注入就是将一个DLL放进某个进程的地址空间里，让它成为那个进程的一部分。 很多恶意代码，游戏外挂，盗号木马，顽固类病毒等程序均采用此寄生，隐藏在目标计算机之内。 0x02 关键API VirtualAllocEx function VirtualAllocEx函数在远程进程的地址空间中分配一块内存 C++ LPVOID WINAPI VirtualAllocEx( _In_ HANDLE hProcess, _In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect ); WriteProcessMemory function WriteProcessMemory函数把DLL的路径名复制到第1步分配的内存中
C++ BOOL WINAPI WriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_ LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_ SIZE_T *lpNumberOfBytesWritten ); GetProcAddress function
GetProcAddress函数来得到LoadLibraryW或LoadLibraryA函数（在Kernel32.dll中）的实际地址 C++ FARPROC WINAPI GetProcAddress( _In_ HMODULE hModule, _In_ LPCSTR lpProcName ); CreateRemoteThread function CreateRemoteThread函数在远程进程中创建一个线程，让新线程调用正确的LoadLibrary函数并在参数中传入第1步分配的内存地址。这时，DLL已经被注入到远程进程的地址空间中，DLL的DllMain函数会收到DLL_PROCESS_ATTACH通知并且可以执行我们想要执行的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1493cbf7d0dbf7dd489b926ad6eed30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7efaa43bbe90318853ad25f06c57cc0/" rel="bookmark">
			php Carbon 中文文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我只是个搬运工 0.0 [TOC]
Introduction Carbon 是php的日期处理类库（A simple PHP API extension for DateTime.）。
The Carbon class is inherited from the PHP DateTime class. Carbon has all of the functions inherited from the base DateTime class. This approach allows you to access the base functionality if you see anything missing in Carbon but is there in DateTime.
Carbon 继承了PHP的 Datetime 类，所以 Carbon 中没有涉及到的，但在 Datetime 中已经实现的方法都是可以使用的。
有点类似于 JavaScript 中的 Moment.js，Laravel 中的 Carbon 就是这货。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7efaa43bbe90318853ad25f06c57cc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6734d7cb8b5ee833c36ed7fc2cc327f/" rel="bookmark">
			MinGW 编译zlib、libpng
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 编译zlib
下载 http://www.zlib.net/ 下载版本zlib-1.2.8， 解压缩文件zlib-1.2.8。进入mingw命令行，切换目录到zlib-1.2.8解压缩目录。
命令行输入 mingw32-make -f makefile.gcc
编译生成 libz.a, libz.dll.a, zlib1.dll等文件
2. 编译libpng
下载源码，解压缩。切换到源码路径。
打开scripts/makefile.gcc设置zlib路径：
ZLIBINC = ../zlib-1.2.8
ZLIBLIB = ../zlib-1.2.8
拷贝scripts/pnglibconf.h.prebuilt到源码目录，改名为pnglibconf.h
命令行输入：
copy scripts\makefile.gcc makefile.gcc
mingw32-make -f makefile.gcc
生成libpng.a文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c514d80fa9519cb3ef68972c55792d1f/" rel="bookmark">
			基于vue的picker组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 基于vue.js选择器组件
github: https://github.com/xiecg/vue-...
DEMO vue-picker
安装 npm install vue-3d-picker --save import picker from 'vue-3d-picker'; Vue.component(picker.name, picker); 基础用法 &lt;picker v-model="visible" :data-items="items" @change="onValuesChange"&gt; &lt;div class="top-content" slot="top-content"&gt;Top of the content.&lt;/div&gt; &lt;div class="bottom-content" slot="bottom-content"&gt;Bottom of the content.&lt;/div&gt; &lt;/picker&gt; export default { methods: { onValuesChange(result1, result2, ...) { console.log(result1, result2); } }, data() { return { visible: true, items: [ { values: ['2000', '2001', '2002', '2003', '2004', '2005', '2006', '2007'], }, { values: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'], } ] } } } 选项 Picker Options:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c514d80fa9519cb3ef68972c55792d1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e5c1235d18bf7cfa97ca8fc597bf009/" rel="bookmark">
			QT 5.7   QWebChannel如何调用JavaScript以及JavaScript如何调用QT中函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章用来回忆内容，不喜勿喷。
QWebChanne与js交互
下面是用来与JS交互类
webconnect.h
#ifndef WEBCONNECT_H #define WEBCONNECT_H #include &lt;QDebug&gt; #include &lt;QObject&gt; class webconnect : public QObject { Q_OBJECT public: public slots: void receiveText(const QString &amp;r_text); signals: void sendText(const QString &amp;text); }; #endif // WEBCONNECT_H 头文件里面我认为最重要也是最容易忽视的就是 : public QObject 和 Q_OBJECT 类里如果少了这两样就会调用失败，这折腾了我几天的时间.....webconnect.cpp#include "webconnect.h"void webconnect::receiveText(const QString &amp;r_text){ qDebug()&lt;&lt;(QObject::tr("Received message: %1").arg(r_text));}下面是怎样从QT传类对象到JSQWebEnginePage *page = new QWebEnginePage(this); ui-&gt;webEngineView-&gt;setPage(page); QWebChannel *channel = new QWebChannel(this); channel-&gt;registerObject(QStringLiteral("content"), &amp;lianjie); //lianjie就是交互类 page-&gt;setWebChannel(channel); ui-&gt;webEngineView-&gt;setUrl(QUrl("xxxxxx"));
signals就是发出信号的意思在JS文件里面我是这样写的window.onload = function() { new QWebChannel(qt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e5c1235d18bf7cfa97ca8fc597bf009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0a9bc4fb43b1b6f5ca21798200e768/" rel="bookmark">
			QT 5.7 QWebEngineView加载网页卡的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用QT 5.7 QWebEngineView 加载高德地图后发现地图一卡一卡的，严重影响体验。发现原来使用的是Debug ，无意中换成了release编译结果十分流畅，遇到同样问题的朋友可以试试。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28826509e534b8e45801a620a4f42b1/" rel="bookmark">
			各向异性扩散滤波_原理与算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.原理简述 各向异性扩散滤波主要是用来平滑图像的，克服了高斯模糊的缺陷，各向异性扩散在平滑图像时是保留图像边缘的，和双边滤波很像。 通常我们有将图像看作矩阵的，看作图的，看作随机过程的，记得过去还有看作力场的。这次新鲜，将图像看作热量场了。每个像素看作热流，根据当前像素和周围像素的关系，来确定是否要向周围扩散。比如某个邻域像素和当前像素差别较大，则代表这个邻域像素很可能是个边界，那么当前像素就不向这个方向扩散了，这个边界也就得到保留了。 具体的推导公式都是热学上的，自己也不太熟悉，感兴趣的可以去看原论文，引用量超7000吶。我这里只介绍一下最终结论用到的公式。
主要迭代方程如下：
I就是图像了，因为是个迭代公式，所以有迭代次数t。
四个散度公式是在四个方向上对当前像素求偏导，news就是东南西北嘛，公式如下：
而cN/cS/cE/cW则代表四个方向上的导热系数，边界的导热系数都是小的。公式如下：
最后整个公式需要先前设置的参数主要有三个，迭代次数t，根据情况设置；导热系数相关的k，取值越大越平滑，越不易保留边缘；lambda同样也是取值越大越平滑。
2.MATLAB仿真代码 clear all; close all; clc; k=15; %导热系数,控制平滑 lambda=0.15; %控制平滑 N=20; %迭代次数 img=double(imread('lena.jpg')); imshow(img,[]); [m n]=size(img); imgn=zeros(m,n); for i=1:N for p=2:m-1 for q=2:n-1 %当前像素的散度，对四个方向分别求偏导，局部不同方向上的变化量， %如果变化较多，就证明是边界，想方法保留边界 NI=img(p-1,q)-img(p,q); SI=img(p+1,q)-img(p,q); EI=img(p,q-1)-img(p,q); WI=img(p,q+1)-img(p,q); %四个方向上的导热系数，该方向变化越大，求得的值越小，从而达到保留边界的目的 cN=exp(-NI^2/(k*k)); cS=exp(-SI^2/(k*k)); cE=exp(-EI^2/(k*k)); cW=exp(-WI^2/(k*k)); imgn(p,q)=img(p,q)+lambda*(cN*NI+cS*SI+cE*EI+cW*WI); %扩散后的新值 end end img=imgn; %整个图像扩散完毕，用已扩散图像的重新扩散。 end figure; imshow(imgn,[]); 3.运行结果及分析 (处理图像) (原图)
各向异性滤波方法确实在保持边缘和图像平滑方面进行了很好的尝试，其结果和双边滤波有很大的相似性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd4edf8edde1b8ddea07b2837afc976/" rel="bookmark">
			Java三大器之监听器（Listener）的工作原理和代码演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在来说说Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener 接口的服务器端程序，它也是随web应用的启动 而启动，只初始化一次，随web应用的停止而销毁。主要作用是：做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些 固定的对象等等。首先来看一下ServletContextListener接口的源代码：
public abstract interface ServletContextListener extends EventListener{ public abstract void contextInitialized(ServletContextEvent paramServletContextEvent); public abstract void contextDestroyed(ServletContextEvent paramServletContextEvent); } 下面利用监听器对数据库连接池DataSource的初始化演示它的使用：ListenerTest.java import javax.servlet.ServletContext; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import org.apache.commons.dbcp.BasicDataSource; /** * 现在来说说Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener 接口的 * 服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是：做一些初始化 * 的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。 * * 示例代码：使用监听器对数据库连接池DataSource进行初始化 */ public class ListenerTest implements ServletContextListener{ // 应用监听器的销毁方法 public void contextDestroyed(ServletContextEvent servletContextEvent) { ServletContext servletContext = servletContextEvent.getServletContext(); // 在整个web应用销毁之前调用，将所有应用空间所设置的内容清空 servletContext.removeAttribute("dataSource"); System.out.println("销毁工作完成..."); } // 应用监听器的初始化方法 public void contextInitialized(ServletContextEvent servletContextEvent) { // 通过这个事件可以获取整个应用的空间 // 在整个web应用下面启动的时候做一些初始化的内容添加工作 ServletContext servletContext = servletContextEvent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd4edf8edde1b8ddea07b2837afc976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5c586fa9c14cccfe77c68033a8da5eb/" rel="bookmark">
			安全漏洞--linux 最新内核通用提权漏洞利用示例 (脏牛Dirty COW)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 漏洞简介 Linux内核在处理内存写时拷贝（Copy-on-Write）时存在条件竞争漏洞，导致可以破坏私有只读内存映射。一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞。
CVE-2016-5195: https://access.redhat.com/security/cve/CVE-2016-5195
0x02 漏洞危害 低权限用户可以利用该漏洞修改只读内存，进而执行任意代码获取 root权限。
0x03 影响范围 该漏洞影响所有 Linux Kernel &gt;= 2.6.22的版本。 2.6.22是 2007年发布的版本，也就是说这个漏洞几乎影响 2007以后的所有版本。
0x04 漏洞测试 读取 /proc/version 来获取 LinuxKernel 版本：
0x05 测试代码 /* * main.c * * Created on: Oct 21, 2016 * Author: 5t4rk */ #include&lt;stdio.h&gt; #include&lt;sys/mman.h&gt; #include&lt;fcntl.h&gt; #include&lt;pthread.h&gt; #include&lt;string.h&gt; void *map; int f; struct stat st; char* name; void * madviseThread(void *arg) { char *str; str = (char *) arg; int i, c = 0; for (i = 0; i &lt; 100000000; i++) { c += madvise(map, 100, MADV_DONTNEED); } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5c586fa9c14cccfe77c68033a8da5eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb567997c37f3a37c104bd4cee20b016/" rel="bookmark">
			匹配中文字符的正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		From: http://blog.sina.com.cn/s/blog_4540c3630100aq01.html
评注：匹配中文还真是个头疼的事，有了这个表达式就好办了
匹配双字节字符(包括汉字在内)：[^x00-xff]
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
匹配空白行的正则表达式：ns*r
评注：可以用来删除空白行
匹配HTML标记的正则表达式：&lt;(S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt;
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记
依旧无能为力
匹配首尾空白字符的正则表达式：^s*|s*$
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常
有用的表达式
匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*
评注：表单验证时很实用
匹配网址URL的正则表达式：[a-zA-z]+://[^s]*
评注：网上流传的版本功能很有限，上面这个基本可以满足需求
匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][azA-
Z0-9_]{4,15}$
评注：表单验证时很实用
匹配国内电话号码：d{3}-d{8}|d{4}-d{7}
评注：匹配形式如 0511-4405222[img]chrome://skype_ff_toolbar_win/content/
cb_transparent_r.gif[/img] 或 021-87888822
匹配腾讯QQ号：[1-9][0-9]{4,}
评注：腾讯QQ号从10000开始
匹配中国邮政编码：[1-9]d{5}(?!d)
评注：中国邮政编码为6位数字
匹配身份证：d{15}|d{18}
评注：中国的身份证为15位或18位
匹配ip地址：d+.d+.d+.d+
评注：提取ip地址时有用
匹配特定数字：
^[1-9]d*$　//匹配正整数
^-[1-9]d*$ //匹配负整数
^-?[1-9]d*$　//匹配整数
^[1-9]d*|0$　//匹配非负整数（正整数 + 0）
^-[1-9]d*|0$　//匹配非正整数（负整数 + 0）
^[1-9]d*.d*|0.d*[1-9]d*$　//匹配正浮点数
^-([1-9]d*.d*|0.d*[1-9]d*)$　//匹配负浮点数
^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　//匹配浮点数
^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　//匹配非负浮点数（正浮点数 + 0）
^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　//匹配非正浮点数（负浮点数 + 0）
评注：处理大量数据时有用，具体应用时注意修正
匹配特定字符串：
^[A-Za-z]+$　//匹配由26个英文字母组成的字符串
^[A-Z]+$　//匹配由26个英文字母的大写组成的字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb567997c37f3a37c104bd4cee20b016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9077ac8b1ff2485cd52b96416a9611f3/" rel="bookmark">
			error LNK2001:无法解析的外部符号_imp_timeGetTime@0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天调用librtmp时出现如下错误。
后来查MSDN，得到如下信息。
解决方法：将库winmm.lib添加到工程中
参考链接：https://msdn.microsoft.com/en-us/library/dd757629
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d1e617babba75a4ef85f86095f202c7/" rel="bookmark">
			Oracle11g Http请求报错 ORA-24247: 网络访问被访问控制列表 (ACL) 拒绝 ORA-29273:HTTP 请求失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目要求每个星期执行一次C#后台代码，写了一个http请求的存储过程以便每个星期固定时间访问一次后台代码, 用call SP_XXX();执行存储过程，报出如下异常
ORA-29273: HTTP 请求失败 ORA-06512: 在 "SYS.UTL_HTTP", line 1130 ORA-24247: 网络访问被访问控制列表 (ACL) 拒绝 ORA-06512: 在 "YGMM.P_SENDSMS_TEST", line 15 ORA-06512: 在 line 3
原因：Oracle 11g引入了细粒度访问网络服务.通过在XML DB 数据库中使用访问控制列表(ACL)来实现，允许控制哪个用户能够访问哪个网络资源。
解决办法：
1、给当前Oracle登入用户配置ACL 权限
begin dbms_network_acl_admin.create_acl ( -- 创建访问控制文件（ACL） acl =&gt; 'utl_http.xml' , -- 文件名称 description =&gt; 'HTTP Access' , -- 描述 principal =&gt; 'ITS' , -- 授权或者取消授权账号，大小写敏感（用大写可以，小写报错） is_grant =&gt; TRUE , -- 授权还是取消授权 privilege =&gt; 'connect' , -- 授权或者取消授权的权限列表 start_date =&gt; null , -- 起始日期 最好写上起始日期，没写权限一会就失效 end_date =&gt; null -- 结束日期 最好写上起始日期，没写权限一会就失效 ); dbms_network_acl_admin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d1e617babba75a4ef85f86095f202c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3087c270eca0737e0a2113a7b229c993/" rel="bookmark">
			ES7标准  fetch请求封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://blog.csdn.net/BingHongChaZuoAn/article/details/52851980 作为一个程序猿，一定要养成一个爱学习的好习惯，因为程序员是一个终身学习的职业，要时刻把Live and learn作为一种信仰。I can’t change the world，only change myself。
闲话少说，言归正传，今天跟大家分享下我自己封装的延用ES7标准的 fetch请求，不好之处忘大家见谅。
首先是 Header model类型，配置文件 header.js。
let Header = { 'Accept': 'application/json', //json形式 'Content-Type': 'application/json' } module.exports = Header; netTools.js
export default { /*检查对象是否为空*/ isEmpty(obj){ for (var r in obj){return false;} return true; }, /*把String转化成对象*/ toObj(obj){ if(typeof obj === 'object'){ return obj; }else{ return eval('('+obj+')'); } }, /*判断对象是否为空*/ isNull(obj){ return (!obj &amp;&amp; typeof(obj)!="undefined" &amp;&amp; obj!=0)?true:false; }, } NetUtil.js
'use strict'; import React, { Component} from 'react'; var Header = require('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3087c270eca0737e0a2113a7b229c993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe86fee6ec4d69c798163d861f171289/" rel="bookmark">
			golang实践-目录结构与工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个话题确实是老调重弹，但确异常重要。 老实说，用go做正式项目之前，写过scala，但那个SBT太折磨人，偶然就上了go。两者语法的差别就不说了，但入坑之后才发现水深：没有模块部署及官方的版本管理工具，会带来很多麻烦。 反复折腾了近一年，基本上形成了一点固有的模式，做一般项目还算能够简单支持。没什么特别的技术点，更多只是一点心得。
一、目录结构 我们的代码以rpc为主，http为辅（调用rpc，也辅助测试），基本上一个项目就按照下面这个目录结构定制。
//project directory --src //源代码目录，需纳入vcs --package1 --package1 --main.go //package1编译生成的执行文件源代码 --othersubpackage --package2 --package2 --main.go //这么摆放，是因为执行文件默认是[目录名] --othersubpackage --utils//公共的代码 --vendor //第三方包目录，glide生成，可不纳入vcs glide.yaml //glide生成的文件，需纳入vcs glide.lock //glide生成的文件，需纳入vcs --cfg //配置文件存放目录，需纳入vcs package1.yaml --pkg --bin compile.sh //编译脚本 .bash_profile //工程环境 以上结构，适合于内部项目开发，按照项目进行统一采用glide进行管理。就版本管理工具有很多选择，考虑glide主要是：
简单，第一次用的时候半分钟搞定。只需要在src目录下，先后执行glide init、glide install；定期用一下glide up，自动升级第三方包。golang.org不再被墙之后，基本能一次性更新。 但要特别注意，glide在使用的时候，对tag标签的规则有一定的要求，需要遵循 Semantic Versions 的规则。之前，个别知名的库不是很规范，经常在up的时候反而是老版本，但现在这种问题很少。 安装glide也很简单，因为用的macos，所以brew install glide 就很容易搞定。 当然，github上面很多也用godep，如果有精力，可以投入时间去熟悉、使用。 编译脚本 compile.sh是一个代码编译脚本，偶尔进行一下维护就好。
#清理 go clean all #需要维护的包，只需要列出含有执行文件的包名 MYSERVICE=("package1" "package2") #生成本地运行文件 for SERVER in ${MYSERVICE[*]} do echo "正在编译服务$SERVER mac版" go install $SERVER/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe86fee6ec4d69c798163d861f171289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7574dbc537aa0baa8aa2f7202c1c2d68/" rel="bookmark">
			安全漏洞--C/C&#43;&#43;代码安全漏洞审计技术学习分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 简介 代码审计，大家估计见到最多的一般是web程序的代码审计。然而c/c++这种语言的代码审计估计就很少了。
今天我们要来学习一下，工欲善其事必先利其器，今天介绍一款审计的利器Flawfinder（当然同类的还有很多工具，比如
RATS,RIPS,VCG,Fortify SCA,GOLD,YASCA等等）。该工具我搭建运行在ubuntu16.0.4LTS系统之上。
Flawfinder是一个C/C++代码的开源安全审查工具，采用内建语法缺陷数据库，能够标记类似缓冲溢出、格式字符串、竞争条件、随
机数获取方面的问题。Flawfinder是一个非常简单的工具，采用的算法也不复杂，可以看做是一个基于词典的源代码静态分析器。
Flawfinder的开发者David Wheeler表示：很多软件开发者都在不断重复犯相同的错误，开发人员应当在软件部署前就
用Flawfinder审查代码。 官方地址http://www.dwheeler.com/flawfinder/
0x02 flawfinder root@ubuntu:~/Desktop# flawfinder --h *** getopt error: option --h not a unique prefix flawfinder [--help | -h] [--version] [--listrules] [--allowlink] [--followdotdir] [--nolink] [--patch filename | -P filename] [--inputs | -I] [--minlevel X | -m X] [--falsepositive | -F] [--neverignore | -n] [--context | -c] [--columns | -C] [--dataonly | -D] [--html | -H] [--immediate | -i] [--singleline | -S] [--omittime] [--quiet | -Q] [--loadhitlist F] [--savehitlist F] [--diffhitlist F] [--] [source code file or source root directory]+ The options cover various aspects of flawfinder as follows.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7574dbc537aa0baa8aa2f7202c1c2d68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab6bc38e8ed73a5cf5bff8dcaf34d31/" rel="bookmark">
			VC 操作Excel sheet复制、重命名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CApplication ExcelApp; CWorkbooks books; CWorkbook book; CWorksheets sheets; CWorksheet sheet; CRange range; LPDISPATCH lpDisp = NULL; LPDISPATCH lpDisp1 = NULL; //创建Excel 服务器(启动Excel) if(!ExcelApp.CreateDispatch(_T("Excel.Application"),NULL)) { AfxMessageBox(_T("启动Excel服务器失败!")); return ; } ExcelApp.put_Visible(TRUE); ExcelApp.put_UserControl(FALSE); /*得到工作簿容器*/ books.AttachDispatch(ExcelApp.get_Workbooks()); CString strBookPath = _T("E:\\测试.xls"); try { /*打开一个工作簿*/ lpDisp = books.Open(strBookPath, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing); book.AttachDispatch(lpDisp); } catch(...){} /*得到工作簿中的Sheet的容器*/ sheets.AttachDispatch(book.get_Sheets()); CString strSheetName; strSheetName = _T("XXXX表"); lpDisp = sheets.get_Item(_variant_t((long)7)); sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab6bc38e8ed73a5cf5bff8dcaf34d31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6307359dadc427a77bba6217e416a1bf/" rel="bookmark">
			thymeleaf 回显富文本编辑器的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 把 th:text 换成 th:utext 即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d05dcb799beae0600b1262b372b50b/" rel="bookmark">
			linux大文件分割命令split（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 简介 linux Ubuntu 16.04LTS输入split --help输出如下:
Usage: split [OPTION]... [FILE [PREFIX]] Output pieces of FILE to PREFIXaa, PREFIXab, ...; default size is 1000 lines, and default PREFIX is 'x'. With no FILE, or when FILE is -, read standard input. Mandatory arguments to long options are mandatory for short options too. -a, --suffix-length=N generate suffixes of length N (default 2) --additional-suffix=SUFFIX append an additional SUFFIX to file names -b, --bytes=SIZE put SIZE bytes per output file -C, --line-bytes=SIZE put at most SIZE bytes of records per output file -d use numeric suffixes starting at 0, not alphabetic --numeric-suffixes[=FROM] same as -d, but allow setting the start value -e, --elide-empty-files do not generate empty output files with '-n' --filter=COMMAND write to shell COMMAND; file name is $FILE -l, --lines=NUMBER put NUMBER lines/records per output file -n, --number=CHUNKS generate CHUNKS output files; see explanation below -t, --separator=SEP use SEP instead of newline as the record separator; '\0' (zero) specifies the NUL character -u, --unbuffered immediately copy input to output with '-n r/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d05dcb799beae0600b1262b372b50b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03eef1cdce584ed18abb93c7753a09c4/" rel="bookmark">
			Java三大器之过滤器（Filter）的工作原理和代码演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Filter简介 Filter也称之为过滤器，它是Servlet技术中最激动人心的技术之一，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态html文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等 一些高级功能。 Servlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过Filter 技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截，Filter接口源代码： public abstract interface Filter{ public abstract void init(FilterConfig paramFilterConfig) throws ServletException; public abstract void doFilter(ServletRequest paramServletRequest, ServletResponse paramServletResponse, FilterChain paramFilterChain) throws IOException, ServletException; public abstract void destroy(); } 二、Filter是如何实现拦截的？(Filter的工作原理) Filter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前， 都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的： 调用目标资源之前，让一段代码执行。 是否调用目标资源（即是否让用户访问web资源）。 调用目标资源之后，让一段代码执行。 web服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对象，它也提供了一个 doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问， 否则web资源不会被访问。 三、Filter开发流程 3.1、Filter开发步骤 Filter开发分为2步： * 编写java类实现Filter接口，并实现其doFilter方法。 * 在web.xml 文件中使用&lt;filter&gt;和&lt;filter-mapping&gt;元素对编写的filter类进行注册，并设置它所能拦截的资源。 过滤器范例：
import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; /** * @author yangcq * @description 过滤器Filter的工作原理 */ public class FilterTest implements Filter{ public void destroy() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03eef1cdce584ed18abb93c7753a09c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f816762ab0310321030ba3869adca178/" rel="bookmark">
			微信小程序 开发运营接入指南 设计规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信官方刚发布了微信小程序的一些规则,当然也是动态变化的,毕竟还在内测阶段.为了节约小伙伴的时间我会用红色标出我认为重点的位置. 一、原则及相关说明 ​ 微信最核心的价值，就是连接——提供一对一、一对多和多对多的连接方式，从而实现人与人、人与智能终端、人与社交化娱乐、人与硬件设备的连接，同时连接服务、资讯、商业。
​ 微信团队一直致力于将微信打造成一个强大的、全方位的服务工具。在此基础上，我们推出了微信小程序这个产品，提供给微信小程序的开发者在微信内搭建和实现特定服务、功能的平台。通过全面开放的能力，我们将更多连接的可能给予企业和服务提供者，并为微信小程序提供基础的接入能力、运营环境和规则体系，进而帮助更多的企业和服务提供者建立自己的品牌，将商业机会带给整个微信产业链。
​ 在开始微信小程序的开发前，我们希望微信小程序开发者（以下也称为“你”）已经仔细阅读了《微信小程序接入指南》、《微信小程序设计规范》、《微信小程序开发指南》等；同时，我们也为你准备了微信小程序平台常见拒绝情形。希望这些指南和规范，能够一定程度上帮助你解决开发、运营微信小程序过程中所遇到的疑问。
​ 我们希望你提交的微信小程序，能够符合微信团队一直以来的价值观，那就是：一切以用户价值为依归、让创造发挥价值、好的产品是用完即走，以及让商业化存在于无形之中。在切实符合用户的合理需求和利益的前提下，通过微信小程序所提供的功能和服务，为海量微信用户提供具有持续价值和高品质的服务。我们期待你来提交你的微信小程序。
二、具体运营规范 ​ 使用微信小程序平台的服务，你必须阅读并遵守 《微信小程序平台服务条款》，以及腾讯为此制定的专项规则等。本运营规范是在上述协议及规则基础上进行解释和说明，相关内容旨在帮助你更加清晰地理解和遵守相关协议和规则，以便能够更加顺利地在微信小程序平台进行运营，而不是修改或变更上述协议及规则中的任何条款。如果我们认为你的微信小程序违反了我们的条款、相关平台规则或法律法规，或对微信公众平台、微信开放平台造成了影响，则微信有权对你的微信小程序采取强制措施，包括但不限于限制你的微信小程序访问平台功能、下架小程序、要求删除数据、终止协议等。
1.注册提交规范 ​1.1提供给用户可以联络到开发者的链接或电子邮箱等有效联系方式。
​1.2提供给平台联络到开发者的管理员微信号，并保证该微信号真实有效。
1.3你所提交的微信小程序，不得关联至你不具有完整合法权益或不具备完整授权的网站、应用程序、产品或服务等。
​1.4为保障平台和其他用户的安全、稳定，我们会在你提交微信小程序、运营微信小程序等全过程中，要求你提供相应的材料、进行相应的修改等补充和调整，你应当按照我们的要求协助我们进行审核，否则，将影响审核的结果。
​1.5不允许批量注册、重复提交大量相似的微信小程序。
​1.6不允许重复提交多个相同或同质化严重的微信小程序。
2.基本信息规范 ​2.1微信小程序名称、icon、简介、描述等信息均不得含有政治敏感、色情、暴力血腥、恐怖内容及国家法律法规禁止的其他违法内容；未经授权不得使用第三方享有合法权益的商标、品牌标识等内容或与之相似的内容、信息、特殊角标，侵犯他人合法知识产权，也不得含有其他侵犯他人合法权益（包括但不限于肖像权、名誉权、隐私权、姓名权等）的内容。
​2.2微信小程序icon必须清晰，不能含有其它水印信息。
​2.3小程序的简介和描述需明确介绍微信小程序的功能，准确反映微信小程序的核心体验，并保持最新。
​2.4微信小程序的名称、icon、简介等基本信息，相互之间必须有所关联。
​2.5微信小程序的名称和简介、描述中，不得混有商业化用语、热门微信小程序名称、“国家级”、“最高级”等新广告法明令禁止或其他无关的词语。
​2.6微信小程序的名称不得以电话、邮件、日历等广义归纳类、普遍且不具有识别性的词汇来命名，从而干扰搜索结果。
3.功能设置规范 ​3.1微信小程序所实际提供的服务和内容，需与小程序的简介一致，且不存在隐藏类目。
​3.2微信小程序的核心功能，必须在小程序首页得到体现。
​3.3微信小程序向用户提供基本的功能指引，应包括描述或截图等形式。
​3.4微信小程序的服务范围需与实际填写的类目和标签一致，也需和自身所提供的服务一致，且不应超出小程序平台的类目库范围。如游戏、直播、虚拟物品购买功能等均尚未开放。
​3.5微信小程序的功能不能过于简单，提供的功能不应与其他微信小程序同质化严重。
​3.6未经腾讯公司授权的情况下，微信小程序的添加，必须是免费的，不得设置付费添加。
​3.7未经腾讯公司授权的情况下，不得提供与微信客户端功能相同或者相似的功能。
​3.8微信小程序功能的使用，不应依赖于其他微信小程序，即不得以添加关注或使用其他微信小程序为条件；未经允许或未经腾讯公司授权的情况下，也不得展示或者推荐其他微信小程序。
​3.9微信小程序应设置侵权投诉机制，处理用户间的权益纠纷。
4.主体规范 ​4.1微信小程序的开发、运营者应当符合法律、法规等规范性文件的规定，任何有合理理由认为存在违反法律、法规或监管要求的情况的，将会被拒绝。
​4.2你应当按照我们的要求提供相应的审批、备案等资质文件材料，否则，我们有理由相信你提交的微信小程序存在违反法律、法规或监管要求的情况。
​4.3 任何有合理理由认为从事或为从事违法行为、非法活动提供便利、协助的，将会被拒绝。
​4.4未取得法定许可证件或牌照，发布、传播或从事相关经营活动的，我们有权拒绝。
5.行为规范 ​5.1微信小程序的页面内容中，不得存在诱导类行为，包括但不限于诱导分享、诱导添加、诱导关注、诱导下载等；如不得要求用户分享、添加、关注或下载后才可操作；不得含有明示或暗示用户分享的文案、图片、按钮、浮层、弹窗等；不得通过利益诱惑诱导用户分享、传播；不得用夸张言语来胁迫、引诱用户分享；不得强制或诱导用户添加小程序。
​5.2不得存在恶意刷量、刷单等行为。
​5.3未经腾讯书面许可，不得使用或推荐、介绍使用插件、外挂或其他违规第三方工具、服务接入本服务和相关系统。
​5.4不得滥用模板消息，包括但不限于利用模板消息骚扰用户和广告营销。
5.5不得存在导致腾讯软件在终端设备系统、应用程序商店、市场等必要的使用环境或下载渠道中发生下架、下线、终止提供服务、不兼容等不利影响的内容。
5.6完成注册后，如帐号长期未登录，微信小程序可能被终止使用，终止使用后注册所使用的邮箱、身份证、微信号等信息可能将被取消注册状态。
5.7不得通过微信小程序实施多级分销欺诈行为，发布分销信息诱导用户进行添加、分享或直接参与。一经发现存在此类行为，微信有权对其进行限制功能直至下架处理，并有权拒绝再向该主体提供服务。
6.信息内容规范 ​6.1微信小程序不得发布、传送、传播、储存国家法律法规禁止的以下信息内容：
​ 6.1.1反对宪法所确定基本原则，危害国家安全、泄露国家秘密、颠覆国家政权、破坏国家统一 、损害国家荣誉和利益。
​ 6.1.2反政府、反社会，或存在煽动性的涉政言论、散布谣言，扰乱社会秩序，破坏社会稳定。
​ 6.1.3煽动民族仇恨、民族歧视、破坏民族团结、破坏国家宗教政策、宣扬邪教和封建迷信。
​ 6.1.4展示人或动物被杀戮、致残、枪击、针刺或其他伤害的真实图片，描述暴力或虐待儿童的，或包含宣扬暴力血腥内容。
​ 6.1.5传播淫秽、色情或低俗信息，包括但不限于暴露图片、挑逗内容等，或包含非法色情交易的信息。
​ 6.1.6包含赌博、竞猜和抽奖信息的。
​ 6.1.7含有虚假、欺诈或冒充类内容，包括但不限于虚假红包、虚假活动、虚假宣传，仿冒腾讯官方或他人业务，可能造成微信用户混淆。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f816762ab0310321030ba3869adca178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3eaddc0ba6c1020b7a6e0d7356b0ba5/" rel="bookmark">
			由Asset中的double free引发的Android系统及APP崩溃问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这个问题在来小米之前就遇到并解决过，当时的解决方案与朴老师的初步解决方案一样，本文在之前的初步分析结果之上进一步进行了深入分析，最终得出了当前看起来相对合理并符合原来架构设计的最终方案。
文中引用了朴老师抓的backtrace，同时在进一步分析的过程中朴老师也提出的大量有建设性的问题，感谢朴老师！
一、问题现象 1、systemui高频崩溃
2、system server崩溃导致重启
二、解决方案 通过初步分析、深入分析（具体分析过程和关键代码及log在下面）我们知道了问题的原因：
1、_CompressedAsset::getBuffer不是线程安全的
2、多个AssetManager一起share同一个_CompressedAsset对象，而不同的AssetManager在对_CompressedAsset进行get和set时存在多线程并发竞争同一资源的场景
3、多线程对_CompressedAsset进行get和set时没有用同一个lock同步
4、两个线程同时走进_CompressedAsset::getBuffer并发生double free
针对问题的根本原因，给出以下解决方案：
对临界资源的get和set用同一个lock同步，有序访问。
patch已同步提交给AOSP review并merged，patch详情请猛击：https://android-review.googlesource.com/#/c/271434/
三、初步分析 1、查看崩溃时的backtrace，发现是对象析构时free memory时出问题了，为什么？
backtrace: #00 pc 0003d546 /system/lib/libc.so (arena_run_dalloc+97) #01 pc 0003e5e9 /system/lib/libc.so (je_arena_dalloc_large+24) #02 pc 000463d9 /system/lib/libc.so (ifree+700) #03 pc 0000fa13 /system/lib/libc.so (free+10) #04 pc 00018f15 /system/lib/libandroidfw.so (android::StreamingZipInflater::~StreamingZipInflater()+44) #05 pc 0000dc3f /system/lib/libandroidfw.so (android::_CompressedAsset::getBuffer(bool)+62) #06 pc 000177c3 /system/lib/libandroidfw.so (android::ResTable::add(android::Asset*, android::Asset*, int, bool)+22) #07 pc 00010a33 /system/lib/libandroidfw.so (android::AssetManager::appendPathToResTable(android::AssetManager::asset_path const&amp;, unsigned int*) const+270) #08 pc 00010e5f /system/lib/libandroidfw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3eaddc0ba6c1020b7a6e0d7356b0ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77b30fc2aa461b4fc2bd3359d5e7213/" rel="bookmark">
			bootstrap设置table的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用bootstrap时，不需要table的边框样式，并且不想还想继续使用bootstrap table的分页功能，需要清除table的边框样式，设置自己需要的；
1.bootstrap中清除table样式前的表格
2.清除table样式后的表格样式
清除table自带的样式之后就可以设置自己想要的样式，不影响bootstrap的其他功能
清除bootstrap table样式的代码：
.fixed-table-container tbody td , .fixed-table-container, .bootstrap-table .table, .table&gt;tbody&gt;tr&gt;th, .table&gt;tfoot&gt;tr&gt;th, .table&gt;thead&gt;tr&gt;th{
border:0px;
}
.table&gt;tbody&gt;tr&gt;td, .table&gt;tfoot&gt;tr&gt;td,.table&gt;thead&gt;tr&gt;td,{
border-bottom:1px;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e470329f20c5c537dd4763576d335868/" rel="bookmark">
			linux修改ip,mac命令和qt中编程修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux修改Mac地址 有三种方法： 方法一： 1.关闭网卡设备 ifconfig eth0 down 2.修改MAC地址 ifconfig eth0 hw ether MAC地址 3.重启网卡 ifconfig eth0 up 方法二： 以上方法一修改后linux重启后MAC又恢复为原来的，为了下次启动时修改后的MAC仍有效，我们可以修改文件file:/etc/rc.d/rc.sysinit(RedFlag Linux为这个文件，其他版本的linux应该不同)的内容，在该文件末尾加以下内容： ifconfig eth0 down ifconfig eth0 hw ether MAC地址 ifconfig eth0 up 方法三： 很简单的，只是在./etc/sysconfig/network-scripts/ifcfg-eth0中加入下面一句话： MACADDR=00:AA:BB:CC:DD:EE linux修改IP地址 （1）Ifconfig命令 第一种使用ifconfig命令配置网卡的ip地址。此命令通常用来零时的测试用，计算机启动后
ip地址的配置将自动失效。具体用法如下。ifconfig eth0 ipadd netmask x.x.x.x。
子网掩码:ifconfig eth0 netmask x.x.x.x
其中ethx中的x代表第几快以太网卡，默认第一块为0.ipadd代表ip地址。x.x.x..x为子网掩码。例如给网卡eth0配置的ip地址为192.168.1.1 子网掩码为 255.255.255.0 。
（2）vi /etc/sysconfig/network-scripts/ifcfg-eth0
配置完以后重启动服务.，p地址就配置好了。其实前面3个的配置方法最终还是改变了/etc/sysconfig/network-scripts/ifcfg-eth0下的配置文件罢了。
linux修改网关地址 # route add default gw xxx.xxx.xxx.xxx(网关的IP) 如果用户想更改网关，编辑/etc/sysconfig/network-scripts/ifcfg-eth0文件，将对应的网关设置修改之后，执行下面的命令即可： #/etc/init.d/network restart Qt中如何获取主机名、IP、端口、MAC等信息？ 主要使用到的类有： QHostInfoQHostAddressQNetworkInterfaceQNetworkAddressEntry 1.获取登录用户 QString name = qgetenv("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e470329f20c5c537dd4763576d335868/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb151c589ed0384ab8c87a7211ff5c08/" rel="bookmark">
			Ubuntu sudo报错command not found的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu系统操作中，在使用sudo的时候出现sudo：source：command not found错误提示，遇到这种问题要如何处理呢？下面小编就给大家介绍下Ubuntu系统中报错sudo：source：command not found的解决方法。
Ubuntu Server上执行以下命令，可以看到默认打开的文件数限制为1024个。
$ ulimit -n
1024
编辑/etc/profile配置文件，在最后添加一行：
ulimit -SHn 65535
要让配置生效：
$ sudo source /etc/profile
sudo： source： command not found
我们直接执行ulimit -SHn 65535命令又会怎么样呢？
$ ulimit -SHn 65535
-bash： ulimit： open files： cannot modify limit： Operation not permitted
$ sudo ulimit -SHn 65535
sudo： ulimit： command not found
普通用户获得root权限后反而提示找不到命令了，该如何解决这个问题呢？
$ sudo -s
# source /etc/profile
再次执行ulimit，可以看到打开文件的限制数已改为65535了。
# ulimit -n
65535
上面就是Ubuntu解决sudo：source：command not found错误的方法介绍了，如果你碰到这个问题，可是尝试使用本文介绍的方法进行处理，希望对你有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf029c4a584d49fcfb27449104c03c2c/" rel="bookmark">
			java 获取CPU 和 硬盘序列号的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.ctne.test; /** * @author guanchen * @creation 2016年10月13日 上午9:35:43 */ import java.io.BufferedReader; import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.io.InputStreamReader; import java.text.DecimalFormat; import java.util.Scanner; import org.hyperic.sigar.CpuInfo; import org.hyperic.sigar.CpuPerc; import org.hyperic.sigar.Sigar; import org.hyperic.sigar.SigarException; public class Cpu { private static Sigar sigar = new Sigar(); public static CpuInfo getCpuInfo() { try { CpuInfo[] cpuArr = sigar.getCpuInfoList(); return cpuArr[0]; } catch (SigarException e) { e.printStackTrace(); } return null; } public static String getCpuPerc() { try { CpuPerc[] cpuPercList = sigar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf029c4a584d49fcfb27449104c03c2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a6ccef134739c8b4cde78281ebd5532/" rel="bookmark">
			string datdString=&#39;Wed Oct 12 2016 00:00:00 GMT&#43;0800 (中国标准时间)&#39;将字符串转化为date类型，格式2016-10-12
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public static void main(String[] args) throws Exception { &lt;span style="white-space:pre"&gt;	&lt;/span&gt;String datdString="Wed Oct 12 2016 00:00:00 GMT+0800 (中国标准时间)"; datdString = datdString.replace("GMT", "").replaceAll("\\(.*\\)", ""); //将字符串转化为date类型，格式2016-10-12 SimpleDateFormat format = new SimpleDateFormat("EEE MMM dd yyyy hh:mm:ss z",Locale.ENGLISH); Date dateTrans = format.parse(datdString); System.out.println(new SimpleDateFormat("yyyy-MM-dd").format(dateTrans)); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2872b4231b242e10f7c8e6ed90ef53e9/" rel="bookmark">
			ELK(ElasticSearch, Logstash, Kibana)搭建实时日志分析平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://baidu.blog.51cto.com/71938/1676798
http://www.tuicool.com/articles/YR7RRr
日志主要包括系统日志、应用程序日志和安全日志。系统运维和开发人员可以通过日志了解服务器软硬件信息、检查配置过程中的错误及错误发生的原因。经常分析日志可以了解服务器的负荷，性能安全性，从而及时采取措施纠正错误。
通常，日志被分散的储存不同的设备上。如果你管理数十上百台服务器，你还在使用依次登录每台机器的传统方法查阅日志。这样是不是感觉很繁琐和效率低下。当务之急我们使用集中化的日志管理，例如：开源的syslog，将所有服务器上的日志收集汇总。
集中化管理日志后，日志的统计和检索又成为一件比较麻烦的事情，一般我们使用grep、awk和wc等Linux命令能实现检索和统计，但是对于要求更高的查询、排序和统计等要求和庞大的机器数量依然使用这样的方法难免有点力不从心。
开源实时日志分析ELK平台能够完美的解决我们上述的问题，ELK由ElasticSearch、Logstash和Kiabana三个开源工具组成。官方网站： https://www.elastic.co/products
Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。 转载于:https://www.cnblogs.com/chengjun/p/5951501.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/459/">«</a>
	<span class="pagination__item pagination__item--current">460/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/461/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>