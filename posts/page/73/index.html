<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da24c1af942d49104144e943432bb698/" rel="bookmark">
			python opencv 读取文件夹下所有MP4文件并解析成jpg图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可以使用Python的OpenCV库来读取文件夹中的所有MP4文件，并将其解析为JPG图像。以下是一个示例代码，演示了如何实现这个功能，并设置解析间隔为3帧：
import os import cv2 def extract_frames(input_folder, output_folder, interval): # 遍历输入文件夹中的所有文件 for filename in os.listdir(input_folder): if filename.endswith(".mp4"): file_path = os.path.join(input_folder, filename) output_subfolder = os.path.join(output_folder, os.path.splitext(filename)[0]) os.makedirs(output_subfolder, exist_ok=True) # 打开视频文件 cap = cv2.VideoCapture(file_path) frame_count = 0 while cap.isOpened(): ret, frame = cap.read() if not ret: break # 按照设定的间隔保存帧 if frame_count % interval == 0: output_filename = os.path.join(output_subfolder, f"frame_{frame_count}.jpg") cv2.imwrite(output_filename, frame) frame_count += 1 cap.release() # 设置输入文件夹路径、输出文件夹路径和解析间隔 input_folder = "path/to/input/folder" output_folder = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da24c1af942d49104144e943432bb698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b211aa1d050e12a61ce2ddd77e1d4ca/" rel="bookmark">
			C#与西门子PLC通讯——新手快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：参照本文，你可以完成从软件安装到第一个C#通讯实例的快速搭建，少踩一些坑。
关键词：C#，.Net Core，S7 Net Plus，TIA Portal V17，PLCSIM Advanced V4，S7-1500。
C#与西门子PLC通讯 系列文章目录 后续博客参考
如果您觉得新手入门还不过瘾，请继续阅读下面的文章。
C#与西门子PLC通讯——熟手快速入门
番外篇
C#与西门子PLC通讯——手搓S7通讯协议
文章目录 C#与西门子PLC通讯 系列文章目录前言一、环境准备1.1 PLC编程环境准备1.2 PLC仿真环境准备1.3 .Net Core编程环境准备1.4 仿真器网络环境配置 二、PLC创建2.1 运行博图软件2.2 创建一个新项目2.3 组态设备 添加S7-15002.4 属性设置2.4.1 设置项目支持仿真2.4.2 PLC网络设置 2.5 数据块添加2.5.1 添加新块2.5.2 添加数据块内容2.5.3 取消优化的块访问（可选） 三、仿真器创建3.1 运行博图仿真软件3.2 博图仿真软件参数设置 四、PLC程序下载到仿真器4.1 PLC程序装载4.2 监控仿真PLC数据 五、.Net Core读写仿真器5.1 新建项目5.2 安装S7netplus程序包5.3 连接仿真PLC5.4 读写仿真PLC5.5 使用Task多线程自动读写PLC数据 总结 前言 一日，吾遇一电气之士，闻其欲谋转开发之途，叹其敏而好学，故以吾之薄知相赠，遂有此记焉。
本文基于C# .Net Core和西门子博图TIA Portal V17搭建。由于手边没有西门子PLC实物，所以采用S7-PLCSIM Advanced V4.0作为模拟PLC，以实现0成本完成通讯测试实例。
整体架构示意图如下：
注：网络架构中的IP地址可以根据自己的实际情况进行调整。
一、环境准备 博图V17安装包资源：https://www.jb51.net/softs/777828.html
Visual Studio Community 开发工具：https://visualstudio.microsoft.com/zh-hans/vs/community/
注意：完成本章任务大约耗时半天，请合理安排时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b211aa1d050e12a61ce2ddd77e1d4ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54a4179627226083453a8bc1c944305/" rel="bookmark">
			python——列表推导式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表推导式书写形式： [表达式 for 变量 in 列表] 或者 [表达式 for 变量 in 列表 if 条件] 列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。
它的结构是在一个中括号里包含一个表达式，然后是一个for语句，然后是 0 个或多个 for 或者 if 语句。那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以 if 和 for 语句为上下文的表达式运行完成之后产生。
列表推导式的执行顺序：各语句之间是嵌套关系，左边第二个语句是最外层，依次往右进一层，左边第一条语句是最后一层。
[x*y for x in range(1,5) if x &gt; 2 for y in range(1,4) if y &lt; 3] 他的执行顺序是:
for x in range(1,5) if x &gt; 2 for y in range(1,4) if y &lt; 3 x*y 举例说明：
#!/usr/bin/python # -*- coding: utf-8 -*- li = [1,2,3,4,5,6,7,8,9] print ([x**2 for x in li]) [1, 4, 9, 16, 25, 36, 49, 64, 81] print ([x**2 for x in li if x&gt;5]) [36, 49, 64, 81] print (dict([(x,x*10) for x in li])) {1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60, 7: 70, 8: 80, 9: 90} print ([ (x, y) for x in range(10) if x % 2 if x &gt; 3 for y in range(10) if y &gt; 7 if y !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54a4179627226083453a8bc1c944305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d64063c39a7783d5867b2584b8fcc5b/" rel="bookmark">
			如何在 Windows 11 上恢复丢失的文件？（4种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Windows 11 设备上丢失重要文件感觉就像一场噩梦。这是您希望时光倒流并撤消意外删除或避免那些意外的系统故障的时刻之一。这种情况带来的挫败感和焦虑感简直难以承受。但是，嘿，不要绝望！我们随时为您提供帮助。
在这本真诚的指南中，我们将握住您的手，引导您了解各种方法和工具，这些方法和工具可以在 Windows 11 上恢复丢失的文件时为您提供帮助。将我们视为您理解的朋友，在整个磨难期间为您提供坚定不移的支持和同情。在我们的指导下，您将能够最好地检索有价值的数据，让您高枕无忧。
因此，深吸一口气，相信我们会引导您走向正确的方向。我们将帮助您应对这一充满挑战的情况，并让您的重要文件回到正轨。我们将共同确保您重新访问您珍贵的数据，并将这种痛苦的经历变成纯粹的记忆。
是什么导致 Windows 11 上的文件被删除？ 文件在 Windows 11 上被删除的原因有多种，包括意外删除、系统错误或崩溃、格式化驱动器或分区、恶意软件或病毒攻击、硬件或存储故障以及人为错误。请务必注意，已删除的文件不会立即从存储设备中删除，并且有可能在永久丢失之前恢复。
如何恢复从 Windows 11 删除的文件？ 方法1：从回收站恢复已删除的文件。 打开回收站：双击桌面上的回收站图标。找到已删除的文件：在回收站中查找要恢复的文件。您可以使用搜索栏或滚动浏览已删除文件的列表。选择要恢复的文件：选择您要恢复的文件。您可以通过按住 Ctrl 键并单击每个文件来选择多个文件。恢复文件：右键单击所选文件，然后从上下文菜单中选择“恢复”选项。或者，您可以单击回收站工具栏中的“恢复所选项目”按钮。恢复的文件：恢复的文件将返回到删除前的原始位置。您现在可以像平常一样访问和使用它们。 方法2：使用专业的数据恢复工具。 如果上述基本步骤无法恢复丢失的文件，您可以使用专业的数据恢复软件来恢复损坏的文件。奇客数据恢复是一款一体化数据恢复软件，可让您在几秒钟内恢复丢失的信息。您可以使用此程序恢复已从格式化、加密或损坏的设备中擦除的文件。甚至软件也可以帮助您从完全损坏和无法启动的设备中恢复文件。
奇客数据恢复: 支持1000+数据格式恢复免费下载软件扫描数据，支持文件、照片、视频、邮件、音频等1000+种文件的格式恢复更有电脑/笔记本、回收站、U盘、硬盘等各类存储设备数据丢失恢复https://www.geekersoft.cn/geekersoft-data-recovery.html
在您的 PC 上安装奇客数据恢复 应用程序。启动应用程序并选择您要恢复的数据。接下来，单击按钮。然后，选择要从中恢复文件的磁盘位置并按“扫描”按钮。然后程序将开始扫描以找到已删除的文件。扫描过程完成后，选择要恢复的文件，然后单击“恢复”选项以保存恢复的数据。 方法3：使用CMD恢复丢失的文件。 打开命令提示符：按 Windows 键，键入“命令提示符”，然后单击“命令提示符”应用程序将其打开。导航到所需的驱动器：使用命令“cd [驱动器号]：”导航到丢失文件所在的驱动器。例如，如果文件位于 D 驱动器上，则输入“cd D:”并按 Enter 键。运行文件恢复命令：输入命令“attrib -h -r -s /s /d 。”并按 Enter 键。此命令将扫描选定的驱动器，包括所有子文件夹，以恢复隐藏的、只读的和系统文件。等待命令执行：该命令需要一些时间才能完成，具体取决于驱动器的大小和复杂性。请耐心等待该过程完成。检查恢复的文件：命令完成运行后，导航到驱动器并检查丢失的文件是否已恢复。查找以前隐藏的任何新可见的文件或文件夹。 方法4：使用文件历史记录和备份恢复已删除的文件。 打开文件历史记录：转到“开始”菜单，搜索“文件历史记录设置”并将其打开。连接备份驱动器：确保备份驱动器已连接。访问文件历史记录：单击“从当前备份恢复文件”以打开文件历史记录。浏览和恢复：导航到包含已删除文件的文件夹。选择文件/文件夹并单击“恢复”将其恢复到原始位置。 方法5：通过备份和恢复恢复已删除的文件。 打开备份和还原：在开始菜单中搜索“备份和还原”并将其打开。选择“恢复我的文件”：在“备份和恢复”窗口中单击“恢复我的文件”。选择备份位置：选择保存文件的备份位置。选择要恢复的文件：浏览备份版本并选择要恢复的文件。指定还原位置：决定是将文件还原到原始位置还是其他位置。开始恢复：单击“恢复”以启动文件恢复过程。 避免 Windows 11 设备上数据丢失的重要提示 定期备份您的数据。保持您的系统和软件更新。使用可靠的防病毒软件。下载文件或打开电子邮件附件时请务必小心。使用强密码并启用多重身份验证。随时了解数据安全最佳实践。 结论 意外删除重要文件可能会令人沮丧，但有一些有效的方法可以恢复 Windows 11 设备上丢失的数据。本文简要概述了各种恢复方法。如果手动方法不成功，您可以依靠值得信赖的第三方软件（例如 奇客数据恢复）来检索您的文件。借助正确的工具和技术，您可以成功恢复宝贵的数据并重获安心。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca62ad6499b70572cbe2f8c8e8d160f/" rel="bookmark">
			conda搭建复现需要的pytorch环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：复现DialogXL，搭建需要的pytorch环境
环境：Python 3.6
PyTorch 1.4.0
Transformers 4.3.3
scikit-learn 0.23.1
CUDA 10.0
云服务器：AutoDL(自带miniconda，此教程省略conda安装和环境配置)
1. 初始化conda 使每次ssh服务器后直接进入base环境而不用source activate
输入conda init初始化conda
关闭服务器，重启服务器后见下图界面
2. 创建虚拟环境 我们需要的python版本是3.6，因此创建虚拟环境同时指定python版本，命令为：
conda create-n "自定义环境名" python="指定版本"
3.安装torch 因为我们安装的过往版本，因此查看以前版本的安装命令在https://pytorch.org/get-started/previous-versions/
使用conda安装时可能此处会遇到两个问题！！
-c pytorch 导致下载速度极慢可能报错找不到对应版本 解决方案如下：
3. 使用pip安装（注意一定要升级pip到最新版本！！）
pip install --upgrade pip
pip install torch==1.4.0 torchvision==0.5.0
5. conda添加国内镜像源（conda同样也要升级到最新版本！）
conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels http://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels http://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ca62ad6499b70572cbe2f8c8e8d160f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3df864048bd7f592695bc349a9d327e/" rel="bookmark">
			Golang中常用字符串函数【一】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 语言是一种相对较新的编程语言，它在字符串操作上提供了丰富的功能。本文将介绍 Go 语言中常用的字符串操作函数。
1.len函数 len 函数是 Go 语言内置的一个函数，用于返回字符串的长度。它的用法非常简单，只需要将字符串作为参数传入即可。
例子：
package main import "fmt" func main() { str := "Hello, World!" fmt.Println(len(str)) // 输出：13 } 2.strings.Contains函数 strings.Contains 函数用于检查一个字符串是否包含另一个字符串。它的返回值为一个布尔类型，表示是否包含。Golang 常⻅⾯试题⽬解析(一)
例子：
package main import ( "fmt" "strings" ) func main() { str := "Hello, World!" fmt.Println(strings.Contains(str, "World")) // 输出：true } 3.strings.HasPrefix和strings.HasSuffix函数 strings.HasPrefix 函数用于检查一个字符串是否以另一个字符串开头，而 strings.HasSuffix 函数则用于检查字符串是否以另一个字符串结尾。
例子：
package main import ( "fmt" "strings" ) func main() { str := "Hello, World!" fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3df864048bd7f592695bc349a9d327e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5486e9b538094bf2a0038e908455e47b/" rel="bookmark">
			OpenCV入门9:图像增强和图像滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像增强是一种通过对图像进行处理以改善其质量、对比度、清晰度等方面的技术。在OpenCV中，有多种图像增强的方法和函数可用。下面简要介绍一些常见的图像增强方法及其在OpenCV中的实现方式。
直方图均衡化（Histogram Equalization）：
直方图均衡化是一种通过调整图像的像素值分布来增强图像对比度的方法。它利用图像的像素直方图，将像素值重新映射到一个更均匀的分布上。在OpenCV中，可以使用cv::equalizeHist()函数来实现直方图均衡化。以下示例展示了如何使用直方图均衡化对图像进行增强：
cv::Mat image = cv::imread("image.jpg", cv::IMREAD_GRAYSCALE); // 读取灰度图像 cv::Mat equalizedImage; cv::equalizeHist(image, equalizedImage); // 直方图均衡化 锐化滤波器：
锐化滤波器是一种用于增强图像边缘和细节的滤波方法。它通过增强图像的高频部分来加强图像的边缘信息。在OpenCV中，可以使用拉普拉斯滤波器来实现图像的锐化。以下示例展示了如何使用拉普拉斯滤波器对图像进行锐化处理：
cv::Mat image = cv::imread("image.jpg", cv::IMREAD_GRAYSCALE); // 读取灰度图像 cv::Mat sharpenedImage; cv::Laplacian(image, sharpenedImage, CV_8U); // 拉普拉斯滤波器 图像增强滤波器：
滤波器是一种常用的图像增强方法，通过对图像进行滤波处理来改善图像的质量和特征。常见的滤波器包括均值滤波器、高斯滤波器、中值滤波器等。在OpenCV中，可以使用cv::blur()、cv::GaussianBlur()、cv::medianBlur()等函数来实现不同类型的滤波器。
均值滤波 均值滤波是一种简单的线性平滑滤波器，通过计算像素邻域平均值来实现去除噪声的目的。常用函数为blur()，例如：
Mat image = imread("test.jpg"); Mat blurredImage; // size表示滤波核的大小 blur(image, blurredImage, Size(7, 7)); imshow("image", blurredImage); waitKey(); 图像被平滑了，并且锐化变得更加模糊。
中值滤波 中值滤波是一种非线性平滑滤波器，通过计算像素邻域的中值来实现去除噪声的目的。函数为 medianBlur()，例如：
Mat image = imread("test.jpg"); Mat denoisedImage; // ksize表示滤波核的大小，必须为奇数 medianBlur(image, denoisedImage, 5); imshow("image", denoisedImage); waitKey(); 这段代码演示了如何使用中值滤波来去除图像中的噪声。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5486e9b538094bf2a0038e908455e47b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea83672038b3ae0c6f3054661c99245/" rel="bookmark">
			本周Github有趣开源项目：Rspress等6个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Github有趣的项目、工具和库：
1、sshx
一个基于 Web 的安全协作终端。通过网络进行快速、协作的实时终端共享
特征：
运行一个命令即可与任何人共享您的终端。
在无限画布上调整大小、移动窗口以及自由缩放和平移。
查看其他人的光标实时移动。
连接到全球分布式网格中最近的服务器。
使用 Argon2 和 AES 进行端到端加密。
自动重新连接和实时延迟估计。
预测回声可实现更快的本地编辑（类似于 Mosh）。
2、tailspin
日志文件荧光笔。用颜色突出突出显示日志中的数字、日期、IP 地址、UUID、URL 等，所有突出显示组均可定制
tailspin其工作原理是逐行读取日志文件，对每一行运行一系列正则表达式。正则表达式可以识别日期、数字、严重性关键字等模式。
tailspin不对它想要突出显示的项目的格式或位置做出任何假设。因此，它不需要配置或设置，并且无论日志文件采用何种格式，都可以按预期工作。
3、Rspress
一个基于 Rspack 的快速静态站点生成器。
特征
快速启动：基于Rust的构建工具和markdown/mdx编译器，构建速度极快，为您带来极致的开发体验。
MDX 支持：MDX 是一种强大的内容编写方式，允许您在 Markdown 中使用 React 组件。
内置全文搜索：在构建过程中自动为您生成全文搜索索引，提供开箱即用的全文搜索功能。
静态站点生成：在生产中，它会自动构建成静态 HTML 文件，可以轻松部署在任何地方。
提供插件系统：提供插件系统，您可以根据需要自定义构建流程和主题。
组件文档：支持多种方式预览组件演示。
4、Awesome-emulators
很棒的百种模拟器开源列表！有
[视频游戏控制台模拟器](https://github.com/DerekTurtleRoe/awesome-emulatorsvideo-game-console-emulators)、[任天堂](https://github.com/DerekTurtleRoe/awesome-emulatorsnintendo-entertainment-systemfamicom)、[世嘉](https://github.com/DerekTurtleRoe/awesome-emulatorssega-master-system)、[微软Xbox](https://github.com/DerekTurtleRoe/awesome-emulatorsmicrosoft-xbox)[索尼](https://github.com/DerekTurtleRoe/awesome-emulatorssony-playstation-portable)[手持游戏机模拟器](https://github.com/DerekTurtleRoe/awesome-emulatorshandheld-game-console-emulators)[电话/PDA/其他移动设备等](https://github.com/DerekTurtleRoe/awesome-emulatorsphonespdasother-mobile-devices-etc)Java J2ME：[Java](https://github.com/DerekTurtleRoe/awesome-emulatorsjava)[x86 模拟器](https://github.com/DerekTurtleRoe/awesome-emulatorsx86-emulators)[德州仪器](https://github.com/DerekTurtleRoe/awesome-emulatorstexas-instruments) 5、EKS Cluster Games
识别常见的 AWS EKS 安全问题和漏洞并了解如何在实践中利用它们。每个挑战都在不同的Kubernetes命名空间中运行，具有不同的权限。所有K8资源都至关重要;挑战基于真实的EKS错误配置和安全问题。
6、inshellisense
inshellisense 为 shell 提供 IDE 风格的自动完成功能。
inshellisense为 shell 提供 IDE 风格的自动完成功能。它是一个用于自动完成的终端本机运行时，支持 600 多个命令行工具。inshellisense支持 Windows、Linux 和 MacOS。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ea83672038b3ae0c6f3054661c99245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3531b0beda49e407aa9fab4a1be0a94f/" rel="bookmark">
			【C语言】LeetCode(力扣)上经典题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说起力扣(LeetCode)相信大部分都不陌生,它是领扣网络旗下专注于程序员技术成长和企业技术人才服务的品牌。源自美国硅谷，力扣为全球程序员提供了专业的IT技术职业化提升平台，有效帮助程序员实现快速进步和长期成长。力扣致力于解决程序员技术评估、培训、职业匹配的痛点，逐步引领互联网技术求职和招聘迈向专业化 力扣经典题目：给定一个非空整型数组,除了某个元素是出现一次以外,其余每个元素均出现两次,找出那个只出现一次的元素; 分析: 刚看到这道题的时候,第一反应是使用for循环进行迭代比对;我们先尝试一下这种方式 #include &lt;stdio.h&gt; int main() { int arr[] = { 1,2,3,4,5,1,2,3,4 }; int sz = sizeof(arr) / sizeof(int); //计算出数组的个数 int con = 0; for (int i = 0; i &lt; sz; i++) { con = 0; for (int j = 0; j &lt; sz; j++) { if (arr[i] == arr[j]) { con++; } } if (con == 1) { printf("%d", arr[i]); break; } } return 0; } 显然这种方法是可行的,但有没有办法在升级一点或者在优化一点呢?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3531b0beda49e407aa9fab4a1be0a94f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0676c3c741a37aa5a3d514a5609a4bb/" rel="bookmark">
			Vue报错解决Error in v-on handler: “Error: 无效的节点选择器：#div1“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因为我们在创建元素之前用了#div1"所有它会报错，解决方案简单粗暴咱们直接用
setTimeout(createEdit, 1)解决问题了 原理：vue的虚拟dom创建完成以后再调用真是dom就没啥问题
function createEdit() { const editor = new E('#div1') editor.config.height = 200 editor.create() } export default { name: 'articleList', mounted() { }, methods: { handleClick(row) { console.log(row) }, createEditor() { this.dialogVisible = true createEdit() 在这咱们直接调用 setTimeout(createEdit, 1)就会解决问题了 }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7117f6a34d421710ec173a6e04a7a794/" rel="bookmark">
			MIPSsim模拟器 使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一） 启动模拟器 双击MIPSsim.exe，即可启动该模拟器。模拟器启动时，自动将自己初始化为默认状态。所设置的默认值为：
u所有通用寄存器和浮点寄存器为全0；
u内存清零；
u流水寄存器为全0；
u清空时钟图、断点、统计数据；
u内存大小为4096字节；
u载入起始地址为0；
u浮点加法、乘法、除法部件的个数均为1；
u浮点加法、乘法、除法运算延迟分别为6、7、10个时钟周期；
u采用流水方式；
u不采用定向机制；
u不采用延迟槽；
u采用符号地址；
u采用绝对周期计数。
当模拟器工作在非流水方式下（配置菜单中的“流水方式”前没有“√”号）时，下面叙述中有关流水段的内容都没有意义，应该忽略之。
（二）MIPSsim的窗口 在流水方式下，模拟器主界面中共有7个子窗口，它们是：代码窗口、寄存器窗口、流水线窗口、时钟周期图窗口、内存窗口、统计窗口和断点窗口。每一个窗口都可以被收起（变成小图标）、展开、拖动位置和放大/缩小。当要看窗口的全部内容时，可以将其放大到最大。
在非流水方式下，只有代码窗口、寄存器窗口、内存窗口和断点窗口。
代码窗口 代码窗口给出内存中代码的列表，每条指令占一行，按地址顺序排列。每行有5列（当全部显示时）：地址、断点标记、指令的机器码、流水段标记和符号指令。如图所示。
代码窗口 图中不同抹色的行代表相应的指令所处的执行段。黄色代表IF段，绿色代表ID段，红色代表EX段，青色代表MEM段，棕色代表WB段。
该窗口中各列的含义如下：
u地址：以16进制的形式给出。内存是按字节寻址的，每条指令占4个字节。当采用符号地址时，会在相应的位置给出汇编程序中出现的标号。
u断点标记：如果在该指令处设有断点，则显示相应的标记。断点标记的形式为B.X（X为段名），表示该断点是设置在该指令的“X”段。例如，若某行的断点标记为“B.EX”，则表示在该指令的EX段设置了断点。当模拟器工作在非流水方式下时，断点的标记为B。
u机器码：该行所对应的指令的十六进制机器码。若该行无指令，则仅仅显示4字节数据；
u流水段标记：表示当该指令正在执行时，它在当前周期该指令所处的流水段。当模拟器工作在非流水方式下时，它没有意义。
u符号指令：机器代码所对应的符号指令。
在该窗口中选中某行（用鼠标左键单击），然后再点击鼠标右键，就会弹出菜单：设置断点，清除断点，它们分别用于在所选指令处设置断点和清除断点。
l设置断点
选择（点击）要设断点的指令à点击右键à“设置断点”，弹出“设置断点”小对话框，在“段”的下拉框中选择断点所在的流水段（在非流水方式下，不存在该下拉框），单击“确定”即可。
l清除断点
选择（点击）指令à点击右键à“清除断点”，则设置在该指令处的断点被删除。
寄存器窗口 寄存器窗口显示MIPSsim模拟器中的寄存器的内容。共有4组寄存器：通用寄存器、浮点寄存器、特殊寄存器和流水寄存器，分为4栏来显示。每一栏下分别有各自的数据格式选项，如图所示
寄存器窗口 (1)通用寄存器 MIPS64有32个64位通用寄存器：R0，R1，…，R31。它们被简称为GPRs（General-PurposeRegisters），有时也被称为整数寄存器。R0的值永远是0。通过数据格式选项，可以选择显示的格式是十进制还是十六进制。
(2)浮点寄存器 共有32个64位浮点数寄存器：F0，F1，…，F31。它们被简称为FPRs（Floating-PointRegisters）。它们既可以用来存放32个单精度浮点数（32位），也可以用来存放32个双精度浮点数（64位）。存储单精度浮点数（32位）时，只用到FPR的一半，其另一半没用。
(3)特殊寄存器 特殊寄存器有4个：
uPC：程序计数器（32位）；
uLO：乘法寄存器的低位；
uHI：乘法寄存器的高位；
uFCSR：浮点状态寄存器。
(4)流水寄存器 uIF/ID.IR：流水段IF与ID之间的指令寄存器；
uIF/ID.NPC：流水段IF与ID之间的下一指令程序计数器；
uID/EX.A：流水段ID与EX之间的第一操作数寄存器；
uID/EX.B：流水段ID与EX之间的第二操作数寄存器；
uID/EX.Imm：流水段ID与EX之间的立即数寄存器；
uID/EX.IR：存放从IF/ID.IR传过来的指令；
uEX/MEM.ALUo：流水段EX与MEM之间的ALU计算结果寄存器；
uEX/MEM.IR：存放从ID/EX.IR传过来的指令；
uMEM/WB.LMD：流水段MEM与WB之间的数据寄存器，用于存放从存储器
读出的数据；
uMEM/WB.ALUo：存放从EX/MEM.ALUo传过来的计算结果；
uMEM/WB.IR：存放从EX/MEM.IR传过来的指令。
除了流水寄存器外，其他寄存器都可以修改。只要双击某寄存器所在的行，系统就会弹出一个小对话框。该对话框显示了该寄存器原来的值。在新值框中填入新的值，然后点击“保存”，系统就会将新值写入该寄存器。
流水线窗口 流水线窗口显示流水线在当前配置下的组成以及该流水线的各段在当前周期正在处理的指令。如图所示。非流水方式下，没有该窗口。
流水线窗口 在该窗口中，每一个矩形方块代表一个流水段，它们用不同的颜色填充。在该窗口的左侧是IF到WB段，其右边为浮点部件。浮点部件分有浮点加法部件（fadd）、浮点乘法部件fmul）和浮点除法部件（fdiv）三种。在菜单“配置”à“常规配置”中修改浮点部件个数，可看到该窗口中对应类型的浮点部件个数会发生相应的变化。
在运行过程中，各段的矩形方块中会显示该段正在处理的指令及其地址（16进制）。当双击某矩形方块时，会弹出窗口显示该段出口处的流水寄存器的内容（16进制）。
时钟周期图窗口 该窗口用于显示程序执行的时间关系，画出各条指令执行时所用的时钟周期。非流水方式下，没有该窗口。以窗口左上为原点，横轴正方向指向右方，表示模拟器先后经过的各个周期（列），纵轴正方向指向下方，表示模拟器中先后执行的各条指令（行）。如图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7117f6a34d421710ec173a6e04a7a794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d142ed26ea014cb7a6c00e06691d8c01/" rel="bookmark">
			js将图片文件转为base64格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** *图片文件转换成BASE64字符串，异步任务 *@param {File} file图片文件对象 *@return {String} BASE64字符串 */ const getBase64 = (file: File) =&gt; new Promise((resolve: (url: string) =&gt; void, reject) =&gt; { const reader = new FileReader(); reader.onload = () =&gt; { resolve(reader.result as string); }; reader.onerror = (error) =&gt; reject(error); reader.readAsDataURL(file); }); FileReader
FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用File或 Blob 对象指定要读取的文件或数据。
其中 File 对象可以是来自用户在一个&lt;input&gt;元素上选择文件后返回的FileList对象，也可以来自拖放操作生成的 DataTransfer对象，还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。
重要提示：FileReader 仅用于以安全的方式从用户（远程）系统读取文件内容 它不能用于从文件系统中按路径名简单地读取文件。要在 JavaScript 中按路径名读取文件，应使用标准 Ajax 解决方案进行服务器端文件读取，如果读取跨域，则使用 CORS 权限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bda95a0433c68bee19ff895c8455f9d/" rel="bookmark">
			通过pyserial操作串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装好pySerial库之后就可以通过python打开串口了 &gt;&gt;&gt; import serial &gt;&gt;&gt; ser=serial.Serial("com23",baudrate = 115200, bytesize = 8,parity = 'N',stopbits = 1,timeout=0.5) 设备名对于不同的设备和操作系统是不一样的。 比如,在Windows系统上,你可以使用0,1等表示的一个设备来打开通信端”COM0”和”COM1”。 一旦端口打开,那就可以使用read() , readline() 和 write() 函数读写数据了。
操作串口示例：
&gt;&gt;&gt; ser.write(b"at\r\n") #向端口写AT命令 4 &gt;&gt;&gt; ser.read(60) b'\r\nOK\r\n' &gt;&gt;&gt; ser.write(b"ati\r\n") 5 &gt;&gt;&gt; ser.read(60) b'\r\nQuectel\r\nEC600M\r\nRevision: EC600MCNLAR01A04M08_XBND_OCPU_Q' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c010591abc8bb2f9b73bcc94a5617618/" rel="bookmark">
			Opencv图像处理总结（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天在进行印章提取、识别的代码开发，其中用到了几个opencv库的几个函数，脑袋中想到了要用到什么处理，但是却忘记了各个函数库比如二值化、膨胀/腐蚀等函数的参数，因此每个函数都查找了好久才想起来每个函数参数中的意思，因此在这篇blog中想总结一下opencv用过的函数，方便我自己以后查找、使用。
目录
1、读取图像
2、图像形状
3、图像缩放
4、图像保存
5、图像格式转换
6、图像二值化
7、图像形态学操作
8、图像边缘检测
9、图像融合
10、图像通道分割及合并
11、图像轮廓检测及绘制
12、图像滤波
13、几何图像绘制
1、读取图像 image = cv2.imread(filename, flags) filename: 需要读取图像的绝对路径。
flags（一般省略，需要时填上）: 需要的格式
（1）cv2.IMREAD_UNCHANGED ：原图
（2）cv2.IMREAD_COLOR ：彩色图像
（3）cv2.IMREAD_GRAYSCALE ：灰度图像
示例：
import cv2 image_path = "C:/Users/Roger/Desktop/lena.jpg" image = cv2.imread(image_path) cv2.imshow("image", image) # 显示图像，第一参数为窗口的名字，第二参数为要显示的图像 cv2.waitKey(0) # 参数为等待多少毫秒秒后关闭，当参数为0时无限刷新窗口，按下任意按键则关闭窗口 cv2.destroyAllWindows() # 关闭所有窗口 2、图像形状 import cv2 image_path = "C:/Users/Roger/Desktop/lena.jpg" image = cv2.imread(image_path) height, width, channel = image.shape # 高、宽、通道数 print(height, width, channel) cv2.imshow("image", image) # 显示图像，第一参数为窗口的名字，第二参数为要显示的图像 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c010591abc8bb2f9b73bcc94a5617618/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45bcc2607999d79d09973fd5913bd402/" rel="bookmark">
			车联网场景中的MQTT协议应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念解释 MQTT解释 MQTT（Message Queuing Telemetry Transport）是一种轻量级、基于TCP/IP协议栈构建的异步通信，和发布-订阅模式的消息传输协议。适用于资源受限的设备和低带宽、高延迟或不稳定的网络环境。它在物联网应用中广受欢迎，能够实现传感器、执行器和其它设备之间的高效通信。MQTT已逐渐成为物联网（IoT）领域最热门的协议，也是国内外各大物联网平台最主流的传输协议，阿里云物联网平台很多设备都是通过MQTT接入。
车联网定义 车联网是指车辆与周围环境中的一切物体（包括其他车辆、道路基础设施、行人、交通管理系统等）之间的互联互通系统。Vehicle-to-Everything (V2X)是车联网中的一个重要概念，旨在通过交互式通信和数据共享，提高交通安全性、流量效率和驾驶体验。简单来说，V2X技术主要基于车载通信设备和传感器，通过通信技术将车辆与周围环境中的其他实体连接起来。车辆通过传感器（如雷达、摄像头、激光雷达等）采集实时数据，如车速、位置、方向、加速度等，并通过通信设备将这些数据传输到周围的实体。而运行于其中的通信协议就成为车联网系统建设的关键和核心。
车联网作为一个高速发展中的物联网平台，现在很多车辆已经具备基础的车联网功能，能够实现T-Box远程升级（OTA）与部分信号的传输。随着5G时代的到来与通信技术不断进步，车联网将会以非常快的速度进入每一台车。
阿里云物联网平台对车联网的支持 全球亿级连接高并发架构：依靠全球2800+加速节点和亿级连接架构，车辆可根据实时位置就近接入，助力客户轻松应对全球各地百万级车辆并发稳定在线的问题。多种车辆接入协议灵活选择：尊享型实例的云网关提供了如GB/T 32960、JT/T 808等车联网领域国标/行标的接入能力，并支持MQTT 3.1.1/5.0协议的绝大部分特性。车辆双向认证保障数据安全：尊享型实例的云网关支持车辆和平台间使用X.509证书双向认证，打通了阿里云数字证书产品的PCA服务，可直接选择证书进行配置，同时支持第三方证书导入认证。 阿里云物联网平台下车联网的系统架构 阿里云车联网系统架构通过设备端、云平台、通信模块、数据存储、数据分析与处理、业务应用和安全认证与权限控制等组成部分，实现了从设备到云端的全链路的车联网服务。该架构可以支持大规模的车辆连接和数据处理，提供高效、安全和智能的车联网解决方案。
设备端：车载设备、传感器和智能终端等，用于采集车辆和环境数据，并通过通信模块将数据发送到云平台。云平台：阿里云提供的云计算平台，承载车联网系统的核心功能。云平台提供设备管理、数据存储、数据分析、业务逻辑处理、安全认证等服务。通信模块：位于设备端和云平台之间，负责设备与云平台之间的数据传输和通信。通信模块可以使用不同的通信协议，如MQTT、HTTPS等。数据存储：云平台提供的高可靠、可扩展的数据存储服务，用于存储车辆和环境数据。阿里云提供的存储服务包括云数据库（RDS）、对象存储（OSS）等。数据分析与处理：云平台通过大数据分析和人工智能技术，对车辆和环境数据进行实时和离线分析，提取有价值的信息和洞察，并支持业务逻辑的处理。业务应用：基于云平台和数据分析结果，开发应用程序和服务，如车辆远程监控、诊断、驾驶行为分析、智能导航、车辆共享等。安全认证与权限控制：云平台提供身份认证和权限控制服务，确保只有授权的用户或设备可以访问车联网系统，并对数据进行安全的传输和存储。 车联网系统一般包含几个重要部分。其中，主机主要用于影音娱乐，以及车辆信息显示；汽车T-Box主要用于和后台系统/手机APP互联通信，实现后台系统/手机APP的车辆信息显示与控制。
车联网中对MQTT的使用 MQTT在车联网应用中的业务场景 车辆实时监控：通过使用MQTT协议，车辆可以实时将其位置、速度、状态等信息发布到一个或多个监控中心。监控中心可以订阅这些信息并进行实时监控和分析，以提供实时的车辆位置跟踪和监控。车辆远程控制：通过使用MQTT协议，车辆可以接收来自远程控制中心的指令，并执行相应的操作，如开关车门、启动引擎、调整车辆参数等。这样可以实现远程监控和控制车辆的功能。车辆数据采集与共享：通过使用MQTT协议，车辆可以将其传感器和系统收集到的数据发布到一个或多个数据中心。数据中心可以订阅这些数据，并进行分析和共享，以支持车辆管理、故障诊断、预测维护等功能。车辆交互和通信：通过使用MQTT协议，车辆可以与其他车辆、交通设施和智能交通系统进行实时交互和通信。例如，车辆可以发布其位置和行驶意图，以提供给其他车辆和交通设施，从而实现车辆之间的协同行驶和交通流优化。 车联网体系中的车辆、手机APP端、路侧等设备端连接到车载设备T-Box， 通过MQTT接入，实现对千万量级的以上终端的并发接入能力。
MQTT在车联网应用中的优势 低能耗：车联网设备通常需要长时间运行，并且能耗要求较低。根据MQTT消息格式，消息头部最小只需要占用2个字节，达到带宽消耗最小化。开放性：目前市场上已经有了大量成熟的软件库与硬件模组，可以极大减少开发的成本，降低接入难度。可靠性：根据QoS传输质量等级，确保对有效性要求高的数据不会丢失，且有效性要求低的数据不占资源。异步通信：MQTT支持异步通信，可以在车联网应用中实现实时的消息传递。这对于需要及时响应的车联网应用来说非常重要。灵活性：根据主题名称/过滤规则，可以自由设计主题Topic，应用于大量的车联网业务场景。实时性：MQTT的会话保持和在线状态感知功能，可以提高车辆在离线状态下的消息完整性。安全性：MQTT可以通过加密和身份验证等机制来确保消息的安全传输。这对于车联网应用来说非常重要，保护车辆和用户的数据安全。 相比于其他HTTPS/TCP等私有协议，MQTT具有开放性，多平台使用等优点，适用于多种业务场景，且不受资源限制，能随意扩展以处理海量数据。因此MQTT协议顺理成章地成为最适合车联网领域的主流协议。
MQTT消息主题Topic设计 MQTT主题Topic定义 MQTT协议根据主题来转发消息。MQTT的主题是不要预先创建的，发布者发送消息到某个主题、或者订阅者订阅某个主题的时候，Broker就会自动创建这个主题。
主题Topic通配符：
正斜杠（“/”U+002F）用于分隔主题树中的每个级别，并为主题名称提供层次结构，类似于URL路径。数字符号 ('#' U+0023) 是一个通配符，可匹配主题中任意数量的级别。多级通配符代表父级和任意数量的子级。加号 ('+' U+002B) 是仅匹配一个主题级别的通配符。 主题Topic规则：
所有主题名称和主题过滤器的长度必须至少为一个字符主题名称和主题过滤器区分大小写主题名称和主题过滤器可以包含空格字符前导或尾随“/”创建不同的主题名称或主题过滤器仅包含“/”字符的主题名称或主题过滤器有效主题名称和主题过滤器不得包含空字符 (Unicode U+0000) [Unicode]主题名称和主题过滤器是UTF-8编码的字符串；它们不得编码超过 65,535 字节。除了 UTF-8 编码字符串的总长度所施加的限制之外，主题名称或主题过滤器中的级别数没有限制。 车联网场景中对MQTT主题设计的应用 主动上报车辆数据：设备端T-Box通过控制器传感器等收集车辆运行数据及车况数据，例如车况运行数据、电池状态数据、车舱环境数据等，以指定频率将数据发送到平台端。此类数据可以按照上报数据的车型、车架号、业务数据类型等多个层级进行设计。 示例：/sys/product/{产品KEY}/device/{设备ID}/uplink/battery
请求上报车辆数据：当云平台需要获取车辆的最新状态数据时，例如位置信息等，可以主动下发命令到车辆端，要求上报数据。此类场景一般可以按照车架号、业务类型等层级进行主题设计。 示例：/req/product/{产品KEY}/device/{设备ID}/report/location
指令下发到车辆：用户可以在手机App中操作各种远程控制功能，例如远程启动、远程开车门、远程闪灯鸣笛等。该功能是车辆是车联网业务中最常见、最典型的业务场景。该业务场景下，由手机App发送控制命令至云平台，平台应用通过MQTT将命令下发至车辆，车辆端执行命令成功后，可选择异步发送执行结果到平台。 示例：/ord/product/{产品KEY}/device/{设备ID}/lockAllDoors
请求下发平台数据：车辆配置数据，如数据采集规则、安全访问规则，会根据实际路况或位置的不同做到动态变化的，在软件定义汽车-SDV的背景下更是如此。所以车辆侧可主动请求平台匹配最新的配置信息，以保证车辆侧和平台侧的配置信息一致。 示例：/req/tsp/notify/product/{产品KEY}/device/{设备ID}/roadSecurity
MQTT数据传输质量 MQTT QoS定义 MQTT提供了三种服务质量（QoS），在不同网络环境下保证消息的可靠性。
QoS 0：消息最多传送一次。MQTT Broker发送出一条消息后，无需关心客户端是否接收到。如果当前客户端丢失该消息，也不做任何处理。QoS 1：消息至少传送一次。包含简单的重发机制，若发送方认为消息未被成功发送或接受，会执行重发操作。但这种模式只能保证消息成功到达，但无法保证消息重复到达。QoS 2：消息只传送一次。该模式设计了复杂的重发和重复消息发现机制，保证消息能成功到达对方，并且严格控制只到达一次。 注意点1：QoS级别越高，虽然可以增加消息可靠性，但设计的消息交互模式就越复杂，同时也使资源消耗和消息时延大幅增加。所以QoS等级并非最高最优。平台和终端可以根据自己的网络级别和业务场景来选择合适的QoS。
注意点2：MQTT发布与订阅操作中的QoS是分开设置的，若双方设置的QoS等级不一致，则会下向兼容发生消费降级。发布时的QoS等级表示消息发送到MQTT Broker时使用的QoS等级，订阅时的QoS等级表示MQTT Broker向自己发送消息时使用的最大QoS等级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45bcc2607999d79d09973fd5913bd402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0dcca0fda4ae3546854ac897e00cb6e/" rel="bookmark">
			npm install 报错 chromedriver 安装失败的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2321d2c3abda0cd79caee71bf0d94b1/" rel="bookmark">
			CSS 中BFC是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CSS中，BFC（块级格式化上下文）是一个重要的概念，它对于理解和解决布局中的一些问题非常有帮助。本文将深入探讨BFC是什么，以及如何使用代码来详细解释BFC的概念和应用。
引言 在Web开发中，页面布局是一个常见的挑战，特别是在处理复杂的布局结构时。BFC作为CSS中的一个重要概念，可以帮助我们更好地理解和控制元素的布局行为。接下来，我们将分章介绍BFC的概念和代码详解，帮助读者更好地理解和应用BFC。
什么是BFC CSS中的BFC是指“块格式化上下文”，它是指页面上的一个独立的渲染区域，这个区域内部的元素布局不会影响到外部元素。BFC在网页布局中起着非常重要的作用，它可以帮助我们解决一些常见的布局问题，比如浮动元素引起的高度塌陷、外边距重叠等。
一个元素会创建一个BFC的条件有很多，其中包括float不为none、position为absolute或fixed、display为inline-block、table-cell、table-caption、flex、inline-flex中的任意一个、overflow不为visible等。当一个元素创建了BFC后，它会具有一些特性，比如BFC内部的盒子会在垂直方向上一个接一个地放置，盒子垂直方向的边距会发生重叠，BFC的区域不会与float的元素重叠等。
BFC的应用场景非常广泛，比如可以用来清除浮动、防止外边距重叠、创建多栏布局等。在实际的开发中，我们可以通过设置元素的display、float、position、overflow等属性来创建BFC，从而达到我们想要的布局效果。
总的来说，BFC是CSS中一个非常重要的概念，它可以帮助我们解决很多布局上的难题，掌握好BFC的原理和应用，可以让我们在网页布局中游刃有余。希望大家能够在实际开发中多加练习，加深对BFC的理解和掌握。
BFC的代码详解 /* BFC示例 */ .container { overflow: hidden; /* 触发BFC */ } .float-box { float: left; width: 100px; height: 100px; margin: 10px; } 在上面的示例中，我们创建了一个.container容器，并为其设置了overflow: hidden;样式，从而触发了BFC。然后在容器内部创建了一个.float-box浮动盒子。通过触发BFC，我们可以观察到.container容器会包裹着.float-box浮动盒子，不会发生外边距重叠等问题。
BFC的布局规则 外边距重叠问题: 在BFC中，相邻块级盒子的垂直外边距会发生重叠，但是在BFC中可以避免外边距重叠。浮动元素的影响: 在BFC中，浮动元素不会影响BFC内部盒子的布局，BFC会将浮动元素考虑在内，不会发生文字环绕浮动元素的情况。包含浮动元素: 在BFC中，父元素会包含其所有的子元素，包括浮动元素。避免文字环绕: 在BFC中，文字不会环绕浮动元素，而是会在其下方显示。
BFC的代码示例 下面是一个简单的示例代码，演示了如何创建一个BFC以及BFC的一些布局规则：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;style&gt; .container { overflow: auto; /* 触发BFC */ border: 1px solid #000; } .box { width: 100px; height: 100px; margin: 20px; background-color: #f0f0f0; float: left; } &lt;/style&gt; &lt;title&gt;BFC示例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2321d2c3abda0cd79caee71bf0d94b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8394f4cf5426341e388ca3f7567656d7/" rel="bookmark">
			Google Firebase PHP实现消息推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取key的方法：
登录谷歌开发者后台 https://console.firebase.google.com/?hl=zh-cn
function firebaseNotice($title,$body){ $token_arr=['token1','token2']; //用户的firebasetoken列表 $notify_msg = [ "notification" =&gt; [ "title" =&gt; $title, "body" =&gt; $body ], "data" =&gt; [], //由开发者自己定义内容 "registration_ids" =&gt; $token_arr, "direct_boot_ok"=&gt;true ]; $data = json_encode($notify_msg); $notify_server_key = 'AAAAk5ct8mI:A*******1LLtP6jWH'; //替换为自己的firebase开发者后台获取的key $url = "https://fcm.googleapis.com/fcm/send"; $headers = [ "Authorization:key=" . $notify_server_key, "Content-Type:application/json" ]; try { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_POST, true); curl_setopt($ch, CURLOPT_HTTPHEADER, $headers); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); // 在尝试连接时等待的秒数 curl_setopt($ch, CURLOPT_CONNECTTIMEOUT , 2); // 最大执行时间 curl_setopt($ch, CURLOPT_TIMEOUT, 3); $result = curl_exec($ch); //var_dump($result); $respon = json_decode($result, true); } catch (\Exception $e) { $respon = []; } if (isset($respon['results'])) { if (isset($respon['results']['error'])) { return false; } else { return true; } } return true; } 调用方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8394f4cf5426341e388ca3f7567656d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80dd2e751db0d6472e3421d7d9b5fbc5/" rel="bookmark">
			SolidJs与React区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、写法上 声明变量 import { createSignal, type Component, createMemo } from 'solid-js'; const [name, setName] = createSignal&lt;string&gt;(''); useState 改名成 createSignal从直接使用name变为通过方法调用name() createSignal 用来创建响应式数据，它可以跟踪单个值的变化
添加样式函数 const nameOutlineStyle = createMemo(() =&gt; ({ border: nameErrorVisible() ? '1px solid red' : '' })) &lt;input class='input name' type="text" placeholder='Name' style={nameOutlineStyle()} value={name()} onInput={e =&gt; setName(e.target.value)} /&gt; 2、更新速度 在React 与 Vue中存在一层虚拟DOM（React中叫Fiber树），每当发生更新，虚拟DOM会进行比较（Diff算法），比较的结果会执行不同的DOM操作（增、删、改）
SolidJS 与 Svelte在发生更新时，可以直接调用编译好的DOM操作方法，省去了虚拟DOM比较这一步所消耗的时间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3afc4dfeb1bd52dc06eb0594b6d7efb3/" rel="bookmark">
			Mac电脑Visio文件编辑查看软件推荐Visio Viewer for Mac
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac版Visio Viewer功能特色
在Mac OS X上查看Visio绘图和图表
在Mac OS X上轻松查看MS Visio文件
在Mac上快速方便地打开并阅读Visio文件（.vsd，.vsdx）。
支持通过放大，缩小，旋转，文本选择和复制，打印，文本搜索等功能查看Visio文件。
以单页，单页连续，两页，两页连续四种模式浏览多页Visio文档。
支持多标签查看，轻松读取和切换多个Visio文件。
将Visio转换为PDF，一键单击文本
支持将查看的Visio文件转换为PDF格式，并将文本格式轻松转换。
将Visio转换为PDF，保留原始元素，包括线条，颜色和填充等。
将Visio转换为更常见的文件格式PDF，以进一步处理和共享。
Visio Viewer for Mac下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298a9544310f55ff9130fcb7fab2df60/" rel="bookmark">
			关于docker网络实践中遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.禁用docker自动修改iptables规则 查看docker.service文件/usr/lib/systemd/system/docker.service
默认在宿主机部署容器，映射了端口的话，docker能自己修改iptables规则，把这些端口暴露到公网。
如果要求这些端口不能暴露到公网，则可以在docker.service加上–iptables=false这个配置，则可以禁用掉此功能。随之而来的问题是，需要自己配置网络流量在宿主机网口和docker桥接网口之间的流转，否则就会出现网络流量只能出去，回不来的情况。
解决这个问题可以先不添加–iptables=false，让docker服务先运行起来，它就自己创建了对应的规则，然后通过iptables-save &gt; ./iptables.txt 命令把iptables规则保存成一个文件。再把文件内的暴露端口的相关规则删除掉。然后通过iptables-restore &lt; ./iptables.txt命令把规则刷到iptables即可。需要的就是下面这些流量转发的规则。
然后iptables需要放开对docker 网络中指定ip段的访问即可。
如果使用的是firewalld并不使用iptables，则需要编辑/etc/firewalld/direct.xml文件中的规则并重新加载防火墙以激活这些规则。Direct 规则主要由服务或应用程序用来添加特定的防火墙规则。
参考：https://blog.csdn.net/qq_38263083/article/details/130385278
这篇文章详细说明了docker 网络对iptables的影响：https://blog.csdn.net/weixin_39789525/article/details/110640003
Docker 添加了 DOCKER, DOCKER-USER, DOCKER-ISOLATION-STAGE-1， DOCKER-ISOLATION-STAGE-2 四条链
2.docker网络的NAT 启动docker时，docker进程会创建一个名为docker0的虚拟网桥，用于宿主机与容器之间的通信。当启动一个docker容器时，docker容器将会附加到虚拟网桥上，容器内的报文通过docker0向外转发。
如果docker容器访问宿主机，那么docker0网桥将报文直接转发到本机，报文的源地址是docker0网段的地址。而如果docker容器访问宿主机以外的机器，docker的SNAT网桥会将报文的源地址转换为宿主机的地址，通过宿主机的网卡向外发送。
docker容器无法访问宿主机报出 No route to host
docker网络和iptables规则
3.docker网络类型 bridge，使用bridge类型的驱动，这个网络就是我们一直在用的默认网络，此网络使用docker0作为虚拟交换机。host，使用host类型的驱动，当容器接入此网络时，会共享宿主机的网络空间。none，没有使用任何类型的网络驱动，当容器使用none网络时，表示禁用网络。overlay，使得多个Docker主机可以连接在一起，形成一个虚拟网络，从而实现多主机之间的容器通信。Docker Overlay网络使用VXLAN协议实现跨主机的网络通信。 当你初始化一个 Swarm 或将一个Docker主机加入到一个现有的Swarm时，在该Docker主机上会创建两个新的网络：
一个ingress的 overlay 网络，它处理与 swarm 服务相关的控制和数据流量。当你创建一个 swarm 服务，并且没有把它连接到用户定义的 overlay 网络时，它默认连接到 ingress 网络。一个docker_gwbridge 的 bridge 网络，它将单个 Docker daemon 与 Swarm 里的其他daemon 连接起来。 docker overlay网络原理详解
docker swarm网络如何路由
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c6a8a6462aca5111c7dd08726ea8f32/" rel="bookmark">
			内核编译报错: No rule to make target ‘debian/canonical-certs.pem‘, needed by ‘certs/x509_certificate_list‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu22.04 编译 Linux 内核时经常会遇到如下错误：
如果报错 canonical-certs.pem：
make[1]: *** No rule to make target 'debian/canonical-certs.pem', needed by 'certs/x509_certificate_list'. Stop. make: *** [Makefile:1868: certs] Error 2 在命令行中执行：
scripts/config --disable SYSTEM_TRUSTED_KEYS 如果报错 canonical-revoked-certs.pem：
make[1]: *** No rule to make target 'debian/canonical-revoked-certs.pem', needed by 'certs/x509_revocation_list'. Stop. make: *** [Makefile:1868: certs] Error 2 在命令行中执行：
scripts/config --disable SYSTEM_REVOCATION_KEYS 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1aadcebed8f6927752be72e4051baf6/" rel="bookmark">
			TinyMce富文本编辑器使用【详细】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TinyMCE是一款易用、且功能强大的所见即所得的富文本编辑器。同类程序有：UEditor、Kindeditor、Simditor、CKEditor、wangEditor、Suneditor、froala等等。
TinyMCE的优势：
开源可商用，基于LGPL2.1插件丰富，自带插件基本涵盖日常所需功能（示例看下面的Demo-2）接口丰富，可扩展性强，有能力可以无限拓展功能界面好看，符合现代审美提供经典、内联、沉浸无干扰三种模式（详见“介绍与入门”）对标准支持优秀（自v5开始）多语言支持，官网可下载几十种语言。 官网及文档：www.tiny.cloud
官网下载：www.tiny.cloud/get-tiny/self-hosted/
Github：github.com/tinymce
【推荐】为vue开发者整合的tinymce组件
安装 经典模式 |TinyMCE中文文档中文手册 (ax-z.cn)
安装依赖 npm install @tinymce/tinymce-vue -S npm install tinymce -S 编辑器本身是英文编辑器，所以还需要下载本地化文件（下载这个） 语言包 |可信富文本编辑器 |TinyMCE 也可以这里获取【zh-CN.js】
组件注册 1、组件注册引用核心 import tinymce from 'tinymce/tinymce'; //tinymce核心文件 import Editor from '@tinymce/tinymce-vue'; 2、Editor 初始化 tinymce.init({ language_url: tinymce.addI18n("zh_CN", zh_CN), // 中文语言包路径 language: "zh_CN", skin_url: "/src/assets/tinymce/skins/ui/oxide", // 编辑器皮肤样式 content_css: "/src/assets/tinymce/skins/content/default/content.css", menubar: true, // 隐藏菜单栏 autoresize_bottom_margin: 50, min_height: 350, }) 3、Editor 插件引入 // 插件依赖 import "tinymce/themes/silver/theme"; // 引用主题文件 import "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1aadcebed8f6927752be72e4051baf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f2a479b727c91a61e646bd0b430192/" rel="bookmark">
			Matter学习笔记（2）——数据模型和设备类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设备数据模型 Matter 中的设备具有明确定义的 数据模型(DM)，它是设备功能的分层建模。使用 属性(Attribute)、命令(Command) 和 事件(Event) 的概念描述 Matter 节点支持的远程操作，并分组为称为集群的逻辑块。Matter 应用集群规范中包含的集群具有明确定义的范围和行为，以确保不同供应商开发的 Matter 节点之间的互操作性。集群可以是抽象的，这意味着它可以作为多种设备类型的基础，以减少向 Matter 引入新产品类别的时间和成本。
此层次结构的顶层有 设备(Device)。
1.1 节点和端点 所有设备（包括智能手机和家居助理）都由一个或多个节点 节点 组成。节点是网络中唯一可识别且可寻址的资源，用户可以将其视为整个功能。Matter 中的网络通信源自和终止于节点。
节点是 端点 的集合。每个端点都包含一个功能集。 例如，在语音控制门锁设备中，一个端点可以包括用于操作门锁的功能集，而另一端点可以包括用于处理温度传感器的功能集，而另一个端点与实用程序（例如设备 OTA）相关。
注意：端点 0 始终保留给 Matter 的实用程序集群。这是每个 Matter 设备的唯一强制端点。其中包含端点的服务功能，例如发现、寻址、诊断和软件更新。
节点角色 是一组相关行为。每个节点可以有一个或多个角色。节点角色包括：
Commissioner：执行调试的节点。控制器：可以控制一个或多个节点的节点。例如 Google Home app (GHA)、Google Assistant 和 Google Nest Hub (2nd gen)。某些设备类型（例如开/关灯开关）具有 Controller 角色。受控方：可由一个或多个节点控制的节点。大多数设备类型都可以是控制方，但具有“控制器”角色的某些设备类型除外，例如开/关灯开关。开/关灯开关只能是控制器。不能是被控制方。OTA 提供方：可以提供 OTA 软件更新的节点。OTA 请求方：可以请求 OTA 软件更新的节点。 1.2 集群 详细内容查看：Application Cluster Specification
端点由一个或多个集群组成，这些 集群 对属性、命令和事件进行分组，这些属性、命令和事件共同构成了一组中的每个功能。例如智能插座上的“开启/关闭”集群，或可调暗的浅色端点上的“级别控制”集群。
一个节点可能还有多个端点，每个端点都会创建一个功能相同的实例。例如，灯具可以单独控制各个灯，或者电源板可以对各个插座进行控制。
1.2.1 客户端和服务器 集群可以有以下类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4f2a479b727c91a61e646bd0b430192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d43833c1d15d981649390537f7b771/" rel="bookmark">
			ES常用查询命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本命令
1、获取所有_cat命令
curl -X GET localhost:9200/_cat 2、获取es集群服务健康状态
curl -X GET localhost:9200/_cat/health?v epoch: 时间戳的 Unix 时间戳格式，表示快照生成的时间。
timestamp: 可读性更强的时间戳格式，表示快照生成的时间（08:06:34）。
cluster: Elasticsearch 集群的名称，这里是 "es-cluster"。
status: 集群的健康状态，这里是 "yellow"。Elasticsearch 集群状态通常有三种：green（绿色，健康），yellow（黄色，部分健康），red（红色，不健康）。"yellow" 状态表示集群中的某些副本不可用，但主分片是可用的。
node.total: 集群中节点的总数，这里是 1 个节点。
node.data: 充当数据节点的节点数，这里是 1 个节点。
shards: 集群中分片的总数，这里是 98 个分片。
pri: 主分片（primary shard）的数量，这里是 98 个主分片。
relo: 正在进行重新定位的分片数量，这里是 0。
init: 初始化的分片数量，这里是 0。
unassign: 未分配的分片数量，这里是 27。
pending_tasks: 挂起的任务数，这里是 0。
max_task_wait_time: 最大任务等待时间，这里是没有具体数值。
active_shards_percent: 活动分片的百分比，这里是 78.4%。这表示在集群中，有 78.4% 的分片是活动的，而剩下的可能是不可用或者正在恢复的。
3、查看es节点信息
curl -X GET localhost:9200/_cat/nodes?v ip: 节点的IP地址，这里是"192.168.52.11"。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7d43833c1d15d981649390537f7b771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23ac87639071122871ff0867996a0a19/" rel="bookmark">
			Python编程之定时任务(Schedule)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前文引言基础用法简单的例子装饰器传参取消任务只执行一次任务获取所有任务取消所有任务获取部分任务取消部分任务在区间内随机一个时间执行任务直到一个确定时间再执行任务执行所有任务忽略计划执行每两周(第一周)执行一次任务 Reference 前文 c r o n t a b crontab crontab模块在python中实现定时任务Python编程之定时任务(crontab)详解。
引言 虽然 c r o n t a b crontab crontab能够很好的实现定时任务，但是相较于今天要介绍的模块 s c h e d u l e schedule schedule则略显复杂。通过以下的例子可以发现 s c h e d u l e schedule schedule非常的易于使用，甚至代码不需要注解都能看懂代码，非常推荐大家使用。
基础用法 简单的例子 import schedule import time def job(): print("This is a job") # 每 2秒/分/小时/天/周 执行一次任务 schedule.every(2).seconds.do(job) schedule.every(2).minutes.do(job) schedule.every(2).hours.do(job) schedule.every(2).days.do(job) schedule.every(2).weeks.do(job) # 每分钟的第34秒执行一次任务 schedule.every().minute.at(":34").do(job) # 每小时的第43分执行一次任务 schedule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23ac87639071122871ff0867996a0a19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec1054d2317e84b915336b9fb6be24ef/" rel="bookmark">
			虚拟机网络配置和连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章基于windows10上VMware Workstation Pro创建的虚拟机ubuntu18.04.6实现。
1、前情提要 为什么要对虚拟机进行网络配置？ 当我们创建好一个虚拟机并在网络方面未作更改由虚拟机自动生成ip地址时，虚拟机的ip地址是处于动态变化的，每次开启都会再随机生成一个新的ip；这不利于我们通过其他设备远程连接该虚拟机，这时候需要我们将虚拟机设置为静态路由，通过网络配置可自行定义ip地址，确保稳定连接。
远程连接 SSH是一种可靠的、专为远程登录会话和其他网络服务提供安全性的协议，用于计算机之间的加密登录。在linux系统中，SSH是远程登录的默认工具，因为该工具的协议使用了RSA/DSA的加密算法。该工具做linux系统的远程管理是非常安全的，这里通过SSH建立虚拟机与其他设备的远程连接。
2、设置静态ip 不论原虚拟机是使用哪种网络连接模式，这里我们采用NAT模式进行连接。对于默认NAT模式，其依然是动态分配虚拟机ip地址，后续再进行静态设置。
① 确认NAT连接模式（点击左上角虚拟机设置进入如下界面检查或更改）
② 点击虚拟机左上角编辑虚拟网络编辑器进入如下界面后，点击右下角更改设置，确认赋予管理员权限修改网络配置
③ 赋予权限进入后，选择NAT模式，自行设置下方的子网IP和子网掩码，确认后点击右下方的应用
④ 完成上述操作后，点击NAT设置查看当前网络信息
⑤ 进入ubuntu，点击右上角进入有线设置后，点击有线连接右侧的小齿轮
⑥ 点击IPv4，把方式从自动改为手动，然后自行配置下面的地址，根据前面NAT设置中的网络信息：地址从网段中自选一个（192.168.10.0~192.168.10.254），比如这里取192.168.10.101；子网掩码和网关IP与前面相匹配；DNS保持自动即可；修改完成后点击应用。至此，静态ip设置完成，可在终端输入命令ifconfig查看是否为设置的ip地址
3、安装并启动SSH 打开ubuntu终端，依次输入下列指令，安装SSH，实现免密登录，启动SSH
//安装SSH Server sudo apt-get install openssh-server //(可跳过)登录localhost，第一次登录输入yes，并且登录时会发现是需要密码的 ssh localhost //(可跳过)注销，退出登录 exit //进入用户根目录下的.ssh目录 cd ~/.ssh/ //生成密钥 ssh-keygen -t rsa 生成密钥过程中，需要输入保存密钥的位置等信息，直接按&lt;Enter&gt;键默认设置即可，完成后显示如下
生成密钥图案
//将生成的密钥中的公钥追加到用户根目录".ssh"子目录下的authorized_keys文件中 cat ./id_rsa.pub &gt;&gt; ./authorized_keys //追加完公钥后，再次登录localhost ssh localhost //再次登录已经实现免密登录 登录后显示信息 //启动SSH /etc/init.d/ssh start 4、使用MobaXterm连接虚拟机 MobaXterm是一个功能强大的终端工具。针对于本篇文章，MobaXterm是一个SSH客户端，SSH客户端的作用是帮助我们在windows下面连接并操作linux服务器。
安装使用的过程简单，具体参考其他博主的链接操作即可，参考链接如下：
MobaXterm（终端工具）下载&amp;安装&amp;使用教程
SSH连接时要确保虚拟机上的SSH服务已开启；
填写的服务器ip为上述设置的静态ip，
用户名根据自己创建虚拟机时的用户名填入，
端口号保持默认22即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60f41e73ce87783e67bb24516ee1f850/" rel="bookmark">
			最新GitHub学生认证，可以愉快的使用Copilot了(保姆级教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎈博客主页：🌈我的主页🌈
🎈欢迎点赞 👍 收藏 🌟留言 📝 欢迎讨论！👏
🎈本文由 【泠青沼~】 原创，首发于 CSDN🚩🚩🚩
🎈由于博主是在学小白一枚，难免会有错误，有任何问题欢迎评论区留言指出，感激不尽！🌠个人主页
目录 🌟 一、前置设置🌟 二、申请认证 话不多说直接开始认证！！！！
🌟 一、前置设置 需要申请一个github账号需要一个教育邮箱（就是学校的邮箱，通常在学校官网就可以申请）需要在手机上下载Fake Location（google商店） 🌟 二、申请认证 Step1：修改个人信息
头像也可以修改成近期照片（最后通过后换掉就行）
Github右上角头像点击Your profile
Name：改成你的英文名字，例如 Li Mingtian
Bio：I am Li Mingtian, a student in xxx university. I want to study in Github and try to make some contributions to the community.
Company：Xxx University
Location：Xxx University
Step2：准备材料
去学信网拿到学籍/学历/学位在线验证报告查询，之后用谷歌翻译，翻译成英文，截图保存为jpeg格式发送到手机（用手机上传），或者留在桌面（用手机前置摄像头拍照）
Step3：打开手机配置Fake Location
手机设置中-&gt;我的设备-&gt;全部参数和信息-&gt;连续点击5次系统版本进入开发者模式
进入开发者模式
选择Fake Location应用
打开位置模拟，定位到自己的大学的位置（可以使用科学上网，但是位置得定位到自己的大学），提交时github会根据ip来判断所提交的学校位置和ip地址是否相近，如果差的很远的话是直接认证失败，所以要使用科学上网就必须用Fake Location定位
Step4：打开谷歌浏览器提交材料
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60f41e73ce87783e67bb24516ee1f850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c681b2d263c30ec94041787738c272/" rel="bookmark">
			k8s-docker二进制(1.28)的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二进制文件-docker方式 1、准备的服务器 角色ip组件k8s-master1192.168.11.111kube-apiserver,kube-controller-manager,kube-scheduler,etcdk8s-master2192.168.11.112kube-apiserver,kube-controller-manager,kube-scheduler,etcdk8s-node1192.168.11.113kubelet,kube-proxy,dockerk8s-node2192.168.11.114kubelet,kube-proxy,dockerLoad Balancer(Master)192.168.11.115keepalived,haproxyLoad Balancer(Backup)192.168.11.116keepalived,haproxylb192.168.11.100(VIP) 2、系统初始化 1、设置host 根据上面的规划执行 #安装集群环境所需要的依赖 yum install wget sed vim tree jq psmisc vim net-tools telnet yum-utils device-mapper-persistent-data lvm2 git -y hostnamectl set-hostname k8s-master1 #在master执行 hostnamectl set-hostname 其他省略 2、关闭防火墙 #关闭现有防火墙firewalld systemctl disable firewalld systemctl stop firewalld firewall-cmd --state 3、关闭selinux #关闭selinux setenforce 0 #临时 sed -ri 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config #永久（一定要重启操作系统） sestatus 4、交换分区设置 #关闭 swap swapoff -a #临时 sed -ri 's/.*swap.*/#&amp;/' /etc/fstab #永久 echo "vm.swappiness=0" &gt;&gt; /etc/sysctl.conf #永久 当前操作系统没办法重启。执行此操作 sysctl -p 5、主机与IP地址解析(全部执行) #添加hosts[所有节点都添加] cat &gt; /etc/hosts &lt;&lt; EOF 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81c681b2d263c30ec94041787738c272/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4aac3c89f56021f28d8f51a34c79ae5/" rel="bookmark">
			芯片IC的mask位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录芯片ic驱动中mask标志的作用。
mask是指修改指定的位的寄存器配置，而不是全部。
原因是因为之前在调试的时候出现了一些意外，我们一般设置方式是 寄存器地址 + 数据。
格式如下
set_register_date [] = { /* reg data*/ {0x01, 0x11}, {0x02, 0x22} ...... {0x09, 0x11} } 这样我就把 0x01的数据设置为了0x11， 0x02的地址上数据设置为0x22，但是后来死活不对，这个IC就是没有正常工作。
后来发现芯片厂商那边没有给我提供对应的寄存器的mask，我们不应该设置设置对应起存起的全部地址，而是需要设置对应的寄存器地址的指定的位置，如何指定位置，就是通过mask码指定。
格式如下：(仅供参考)
set_register_date [] = { /* reg data mask*/ {0x01, 0x11, 0x0200}, {0x02, 0x22, 0x0100} ...... {0x09, 0x11, 0x4000} } 内核中也使用的 I 运算来达到这个目的。
#define MASK_BIT_RST 0X0101 #define MASK_BIT_PW 0X1000 reg = set_date (0x01, 0x11 | MASK_BIT_RST ); ..... 这里主要记录下mask码的东西，避免有些同学第一次看到会有迷惑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4ab5cf03b5ce6dd847ccc6bb47b207/" rel="bookmark">
			【Java 进阶篇】Java Filter 过滤器拦截路径配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过滤器（Filter）是 Java Web 应用中一种强大的组件，它可以用于在请求到达目标资源之前或响应返回客户端之前执行一些预处理或后处理操作。其中，过滤器的拦截路径配置是非常重要的，它决定了过滤器会拦截哪些请求。在本文中，我们将深入探讨 Java Filter 过滤器的拦截路径配置，为开发者提供详细的解释和示例。
过滤器拦截路径的基本概念 过滤器通过 doFilter 方法来执行过滤操作，而过滤器是否执行，取决于它的拦截路径配置。在 Java Web 应用中，过滤器的拦截路径可以通过 web.xml 文件或注解进行配置。
使用 web.xml 进行配置 在 web.xml 文件中，通过 &lt;filter&gt; 和 &lt;filter-mapping&gt; 元素来配置过滤器及其拦截路径。以下是一个简单的示例：
&lt;!-- 定义过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.example.MyFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 配置过滤器的拦截路径 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/my/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 上述配置表示 MyFilter 过滤器将拦截所有以 “/my/” 开头的请求路径。
使用注解进行配置 除了使用 web.xml 外，还可以使用注解来配置过滤器的拦截路径。在过滤器类上添加 @WebFilter 注解，指定 urlPatterns 属性即可。以下是一个使用注解配置的例子：
import javax.servlet.annotation.WebFilter; import javax.servlet.annotation.WebInitParam; import java.io.IOException; @WebFilter(filterName = "MyFilter", urlPatterns = {"/my/*"}, initParams = { @WebInitParam(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c4ab5cf03b5ce6dd847ccc6bb47b207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79fb93d6958e02cc21f8073833ab726/" rel="bookmark">
			大语言模型-LLM简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大语言模型如此火爆，查了些资料整理一下，做个初步的了解。
语言模型的发展从开始的统计方法到使用神经网络，再到现在通过使用Transformer架构的模型训练大量数据，理解文本规则和模式，同时随着训练数据和模型的扩大，语言模型的能力提升显著，此时大语言模型出现了-LLM。
相比于之前的明星模型-BERT，虽然大预言模型使用的架构和预训练任务相似，但参数数量级的提升使他们有了质的差别。BERT的参数为3.3亿，GPT-2为15亿，而GPT-3则有1750亿参数。此时GPT-3相比之前的模型，就有解决少样本任务的能力了，这种能力可称为涌现能力。
LLM的独特能力 上下文学习：语言模型在获得指令或任务示例时，通过上下文生成答案，此时不需要额外训练或更新参数。
指令微调：LLM可以处理未见过的任务，泛化能力强大。
推理能力：LLM可通过中间推理步骤的提示机制解决中间的任务得到最终的答案。
LLM的特点 模型规模大：参数通常在数十亿，甚至千亿规模，这也是大模型可以获取更多信息的基础。
预训练和微调：LLM使用大量无标签文本数据做预训练，获取通用的知识，再通过微调在单独任务重获得更好的效果。 上下文理解：可解决小模型对前文理解不足的问题。
支持多模态：LLM可支持图像、声音等内容的扩展。
现有的大模型 LLM大放异彩是从OpenAI发布ChatGPT开始的，后面还有Claude、PaLM、Bard等，但由于网络原因，并不好用，而且还需要国际支付以获取user key，国内使用不是很友好。
国内的LLM主要有文心一言、讯飞星火、通义千问等，分别由百度、讯飞、阿里推出。放开测试后只需手机号就能使用，但有些功能需要收费了。
LangChain 一个开源工具，帮助开发者调用大模型并应用于下游任务，其为LLM提供了通用接口，简化开发流程。
主要有六个标准接口：
Input/Output：用户输入及模型输出的结果
Data：将自由数据输入模型训练
Chain：链接多个LLM或组件
Memory：对每个用户生成短期记忆，加强对上文的理解
Agent：为LLM提供计算、检索等功能的支持
Callback：记录流程信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed29610f5b6dfd706682d9ea49a43249/" rel="bookmark">
			利用三次样条插值调整鱼眼扭曲程度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文利用三次样条插值算法，改变鱼眼扭曲程度。效果如下图所示：
源码下载地址：利用三次样条插值算法更改鱼眼特效的扭曲程度资源-CSDN文库
（说明：源码基于QT和opencv ）
主要代码 鱼眼扭曲 void fisheye(const Mat &amp;src, Mat &amp;dst) { dst.create(src.rows, src.cols, CV_8UC3); dst.setTo(0); if (srcX.size() == 0 || srcX.size() != dstY.size() || cubicCoeffs == nullptr) return; Point2f center; center.x = src.cols / 2.0; center.y = src.rows / 2.0; double rr = sqrt(center.x * center.x + center.y * center.y); for (int id = 1; id &lt; src.rows - 1; id++) { for (int jd = 1; jd &lt; src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed29610f5b6dfd706682d9ea49a43249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b5f35a5c2c568bbbdccb29559ad9a9/" rel="bookmark">
			记录一个Arduino调用MPU6050的姿态解算算法代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 Arduino风格代码 Arduino风格代码 /* MPU6050 Basic Example with IMU by: Kris Winer date: May 10, 2014 license: Beerware - Use this code however you'd like. If you find it useful you can buy me a beer some time. Demonstrate MPU-6050 basic functionality including initialization, accelerometer trimming, sleep mode functionality as well as parameterizing the register addresses. Added display functions to allow display to on breadboard monitor. No DMP use.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8b5f35a5c2c568bbbdccb29559ad9a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02add2531eee5c555d696000b5a89c3c/" rel="bookmark">
			嵌软工程师要掌握的硬件知识1：一文了解什么是PN结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文 / 黑猫学长
本文根据笔者个人工作/学习经验整理而成，如有错误请留言。
文章为付费内容，已加入原创侵权保护，禁止私自转载及抄袭。
文章所在专栏: 嵌软工程师要掌握的硬件知识
1 什么是本征半导体 纯净的、不含其他杂质的半导体称为本征半导体。
本征半导体在热力学温度T=0K（相当于-273℃）时不导电，如同绝缘体一样。本征半导体在环境温度升高或光照的作用下，将有少数价电子获得足够的能量，以克服共价键的束缚而成为自由电子。在没有外加电场时自由电子做无规则的运动。价电子离开共价键后，在该共价键处留下一个空位，这种带正电荷的空位称为“空穴”。在本征半导体中，自由电子和空穴是成对出现的，即自由电子与空穴数目相等。相邻共价键中的价电子可以在获得能量后移至有空穴的共价键，并在原来的位置上产生一个新的空穴。这种新的空穴可以在外加电场作用下运动，价电子运动填补一个空穴后，在原来所处位置上产生一个新的空穴，空穴运动的方向与价电子运动的方向相反。在没有外加电场时，如同自由电子一样，空穴在晶体中也做无规则的运动，对外部不显现电流。
2 PN结 P型半导体：也称为空穴型半导体。一般在纯硅中掺入微量3价元素铟或铝，这样和周围的硅组合在一起形成4价键的时候，缺少一个电子，就形成了空穴。所以，P型半导体中，多子就是空穴，少子是电子。
N型半导体：也称为电子型半导体。N型半导体即自由电子浓度远大于空穴浓度的杂质半导体。一般在纯硅中掺入砷、磷、锑等五价元素，这样和周围的硅组合在一起形成4价键的时候，缺多一个电子，这个电子就可以自由移动。所以，N型半导体中，多子就是电子，少子是空穴。
通常，多子：少子 = 1百亿 ： 1
注意：
N型半导体和P型半导体，都是电中性的，单独的N型半导体和P型半导体，不带电！！！
N型半导体只是有一个电子更容易移动而已，但并不是N型半导体带负电！！！
因为P\N半导体本身不带电，但是N有容易移动的电子，所以，PN结分界线处，N的电子跑到了P的空穴。那么C区域就是带正电了，B区域就是带负电了。所以B和C形成一个从C指向B的电场。导致D处的电子想要向P的A区域移动，受到B的反向作用力。D处的电子没办法经过C再经过B，最后到A处。
那么这时候可能又有疑问了：既然C处带正电了，D处有电子，为什么D处的电子不往C处跑？记住，D本身是电中性的，如果D处的电子往C处跑，会收到B处的阻力，而且试想一下，如果D处电子往C处跑，那D处就一定有地方变成正电了，那这时候跑到C处的电子会不会有要被吸回来呢？所以，最终这个PN结就会形成一个动态的平衡。B和C之间形成一个电场，A和D依旧是电中性。
- 势垒电压
这个内部电场，就叫做势垒电场。一般硅材料制作的PN结势垒电压在0.7V左右。
空间电荷区
- 耗尽层
同时，B和C区域，也称为耗尽层。耗尽层与偏置电压大小、温度、材料性质有关。
材料特性主要又指的是参杂浓度，参杂浓度越高，耗尽层越窄。
3 如何让PN结导通 1、P接正，N接负，形成P指向N的电厂，和PN结内部势垒电场相反，使得PN结变窄。同时如果外部电厂比势垒电厂大，电子就会流动，形成通路，导通！这种接法叫做正向接法，也叫做正向偏置。
2、反过来则截至。
PN结的伏安特性曲线：
4 PN结的击穿 PN结的击穿分为雪崩击穿、隧道击穿和热电击穿三类。
热击穿：热击穿是由于大电流造成的，因为功耗过大，散热不及时导致PN结温度升高被烧毁，是永久破坏性的，不可逆。
4.1 雪崩击穿（Avalanche Breakdown） 当PN结接反向偏置的电压，会造成耗尽层变宽，同时，这个势垒电场也会越来越大，就越不容易导通，但是这里又需要注意，耗尽层和势垒电场不可能无穷无尽的变大，总归会到达一个极限，当到这个极限的时候，这个PN结就会被击穿了。这种击穿，就是雪崩击穿。
那么，雪崩击穿原理是什么？
其实，即使PN结内部的势垒电场形成后，PN结内部的电子并不是静态的，而是达到一种动态平衡。在内部中，P型半导体的少子（电子）会存在漂移，从P型半导体经过空间电荷区到达N型半导体。只不过这种漂移运动很少，漂移运动带来的电压很小，忽略不计。
通常，漂移运动的电子撞击到其他共价键上的电子，是不可能把共价键上电子撞走的，因为其比较稳定。但是当加反向电压，空间电荷区变宽，势垒电压越来越大。那么少子运动的势能就会变大。以P型半导体的少子（电子）举例，当达到某个临界值，P型的电子就会撞击其他的共价键中的电子对，让其脱离共价键，这样就会造成，1生2，2生4，4生8…，最后造成雪崩效应。
雪崩效应发生，PN结的损坏不一定是不可逆的。还是取决于反向电压的大小和持续时长。
4.2 隧道击穿 4.2.1 什么是隧道击穿 隧道击穿也叫做齐纳击穿，是齐纳发现的。
在高浓度掺杂的PN结中，由于耗尽层内的正、负离子排列紧密，耗尽层很窄，因此外加不大的反向电压就能在耗尽层内形成很强的电场，而直接破坏共价键，使价电子脱离共价键的束缚，产生大量电子-空穴对，致使反向电流急剧增大，这种击穿称为齐纳击穿。可见，齐纳击穿电压较低，对于硅材料的PN结来说，齐纳击穿的UBR一般小于5V。
乍一看，感觉齐纳击穿和雪崩击穿原理一样啊？其实本质上是差不多的，但是如果要深入，还需要了解到量子力学的知识才能完全理解。这里简单做个解释：
雪崩击穿的电子浓度比较低，其内部电场较小，所以外接一个反向偏置电压，这个电压要很大。但是对应高浓度的PN结，其电荷空间区比较小。因此，内部电场本来就很大了。外部稍微加一点反向偏置电压，就可以把耗尽层内中性原子的价电子直接从共价键中拉出来，变为自由电子，同时产生空穴，这个过程成为场致电离。
场致电离产生大量的载流子，使PN结的反向电流剧增，呈现反向击穿的现象，称为齐纳击穿（Zener breakdown）。齐纳击穿时场致电离的结果，通常发生在掺杂浓度很高的PN结中，在外加较低的反向电压时就会出现这种击穿，击穿电压只有几伏。
4.2.2 隧道击穿和雪崩击穿的区别 （1）性质不同
雪崩击穿：新产生的载流子在电场作用下敲出其他价电子，产生新的自由电子和空穴对。由于这种连锁反应，势垒层中载流子的数量急剧增加，流过PN结的电流急剧增加。这种由碰撞电离引起的击穿称为雪崩击穿。
齐纳击穿：场激发产生大量载流子，使PN结反向电流大大增加，呈现反向击穿现象。
（2）特点不同
雪崩击穿：在低掺杂浓度的PN结中，空间电荷区的电场随着PN结反向电压的增大而增大。这样，空间电荷区的电子和空穴在电场的作用下获得的能量增加。通常为低掺杂浓度的PN结。
齐纳击穿：齐纳击穿需要高参杂浓度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadbee71ea21bb8b91d3d73b6cdf56ee/" rel="bookmark">
			「2024最新JVM面试题」10道不得不会的JVM面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 说一说JVM的主要组成部分2. 说一下 JVM 的作用？3. 说一下堆栈的区别？4. Java内存泄漏5. JVM 有哪些垃圾回收算法？6. 说一下 JVM 有哪些垃圾回收器？7. 说一下类加载的执行过程？8. 什么是双亲委派模型？为什么要使用双亲委派模型？9. CMS垃圾清理的过程10. 常用的 JVM 调优的参数都有哪些？系列文章 基于JDK8
1. 说一说JVM的主要组成部分
点击放大看，一图胜千文
方法区和堆是所有线程共享的内存区域；而虚拟机栈、本地方法栈和程序计数器的运行是线程私有的内存区域，运行时数据区域就是我们常说的JVM的内存。类加载子系统：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到运行时数据区中的方法区中。Java堆是Java虚拟机所管理的内存中最大的一块，也是垃圾回收的主要区域。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，用来指示执行引擎下一条执行指令的地址。Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、返回方法地址等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。执行引擎：根据程序计数器中存储的指令地址执行classes中的指令。本地接口：与本地方法库交互，是其它编程语言交互的接口。 2. 说一下 JVM 的作用？
首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。
3. 说一下堆栈的区别？
物理地址
堆的物理地址分配对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）
栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。
内存分别
堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。
栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。
存放的内容
堆存放的是对象的实例和数组。因此该区更关注的是数据的存储
栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。
PS：
静态变量放在方法区 静态的对象还是放在堆。程序的可见度
堆对于整个应用程序都是共享、可见的。
栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。
4. Java内存泄漏
内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。
严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。
理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。
但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。
5. JVM 有哪些垃圾回收算法？
标记-清除算法：标记有用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半，消耗内存。标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadbee71ea21bb8b91d3d73b6cdf56ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3289f37ced1f8271c95d53fafa7c11f8/" rel="bookmark">
			Linux nohup后台启动/ 后台启动命令中nohup 、&amp;、重定向的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、nohup（不挂断）简介三、nohup使用3.1、nohup启动3.2、nohup与&amp;，后台运行3.3、nohup与&gt;，日志重定向3.4、nohup后台启动-综合使用`(推荐)``2&gt;&amp;1` 3.5、nohup后台启动(不生成日志) 四、查看进程五、知识扩展5.1、不停止服务，直接清空nohup.out5.2、只记录警告级别比较高的日志5.3、不想输出日志 一、前言 经常看到一些jar包，sh脚本用nohup命令后台启动，今天就讲解一下nohup的用法。
nohup主要作用就是可以在后台运行，并可以选择将日志输出到指定文件。如启动jar包，若使用java -jar demo.jar的方式启动程序当窗口关闭的时候程序也停止了，而且日志会直接输出到控制台非常不直观，nohup启动就可以解决这两个问题。
二、nohup（不挂断）简介 nohup 是 no hung up的缩写，意思是不挂断 。
nohup 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。
使用 Xshell 等Linux 客户端工具，远程执行 Linux 脚本时，有时候会由于网络问题，导致客户端失去连接，终端断开，脚本运行一半就意外结束了。这种时候，就可以用nohup 指令来运行指令，即使客户端与服务端断开，服务端的脚本仍可继续运行。
nohup 语法格式：
nohup 命令 [参数]... 说明：
关闭客户端后，命令仍然会运行，不会挂断。nohup命令允许被运行的程序的输出信息将不会显示到终端。 三、nohup使用 3.1、nohup启动 nohup sh test.sh 说明：
后台启动test.sh脚本，日志默认会输出到当前目录的nohup.out 文件 3.2、nohup与&amp;，后台运行 &amp;符号表示将该命令或脚本放入后台运行。 即&amp;方式启动会有进程号，使用Ctrl+C程序不会中断，但终端关闭后运行会中断。
nohup sh test.sh &amp; 3.3、nohup与&gt;，日志重定向 上面提到的日志文件默认名称是 nohup.out ，如果修改日志文件的名称，则用到 重定向 ，符号是&gt;，语法格式是
nohup sh test.sh &gt;test.log &gt;表示标准输出，还可以用&gt;,&gt;&gt;, 1&gt;或1&gt;&gt;等进行表示
3.4、nohup后台启动-综合使用(推荐) # 后台执行test.sh文件，将标准日志输出到output.log文件中，将错误日志也输出到output.log文件中 nohup .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3289f37ced1f8271c95d53fafa7c11f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c8f642ade41076851fae79da25e2f8c/" rel="bookmark">
			java动态设置注解值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：在运行时根据需求更改注解中的值 一、步骤 1.定义类 public class CadreListQueryDTO extends CadreBaseQueryDTO { /** * 出国事由 */ @QueryField(field = "A21.a2114",type = QueryField.LIKE) private String a2114; } 2.定义方法进行动态设置 /** * 动态设置注解值 * * @param annotation * @param valueName * @param value * @param &lt;T&gt; */ @SneakyThrows public static &lt;T extends Annotation&gt; void setValueToAnnotate(T annotation, String valueName, Object value) { InvocationHandler invocationHandler = null; if (Objects.nonNull(annotation)) { invocationHandler = Proxy.getInvocationHandler(annotation); } if (Objects.isNull(invocationHandler)) { return; } Field nameField = invocationHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c8f642ade41076851fae79da25e2f8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464fea3bcb3e03ea8b6b6bcc046b673c/" rel="bookmark">
			移动云获取推拉流地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：帮助文档：
移动云帮助中心https://ecloud.10086.cn/op-help-center/doc/category/753
二：准备工作：
1：进入移动云首页，点击【产品】&gt;【视频服务】&gt;【视频服务】&gt;【视频直播】
点击【立即订购】，会跳转到视频直播购买页面进行购买
2：根据选择订购服务的区域，确认对应的API接入地址。
3：进入控制台，选择视频点播，点击API认证消息，获取uid、secretId、secretKey备用。
三：流程说明：
1：想要获取移动云的直播推拉流地址，首先需要有一个直播频道。
这个直播频道是调用API接口 /l2/live/createChannel创建时返回的channel_Id。
使用该频道id作为参数，再去请求推流和播流的API地址，就能获得对应的推拉流地址。
参考文档：移动云帮助中心https://ecloud.10086.cn/op-help-center/doc/article/40529
2：无论是创建直播频道还是获取推拉流地址，都需要携带token验证字符串，API接口在收到请求时，会验证token是否有效。
所以，生成token是所有请求的必经之路。
3：官方文档推荐使用v2.0版本进行鉴权，那么，接下来我们就讲解v2.0版本的鉴权token如何生成。参考文档：
移动云帮助中心https://ecloud.10086.cn/op-help-center/doc/article/40526
请注意：生成鉴权token时，需要根据每个业务接口文档的GET和POST请求方式不同而给签名body赋予不同的值。下面是官方文档中需要注意事项，特别之处已经标注出来。
四：代码实现：
/** * 生成移动云鉴权token * $business_arr 业务参数列表 * $request_type 请求方式 get/post 默认get */ function getEcloudToken($business_arr,$request_type='get'){ $rs=[]; $uid=; $secretId=; $secretKey=; $apiId=200001; $currentTimeStamp=getMillisecond(); $expired=$currentTimeStamp+12*60*60*1000; $grant_type='v2.0'; $random=sprintf("%08d",rand(0,99999999)); $arr=[ 'apiId'=&gt;$apiId, 'body'=&gt;'%5B%5D', 'currentTimeStamp'=&gt;$currentTimeStamp, 'expired'=&gt;$expired, 'grant_type'=&gt;$grant_type, 'random'=&gt;$random, 'secretId'=&gt;$secretId, 'uid'=&gt;$uid ]; if($request_type=='post'){ $body_str = rawurlencode(json_encode($business_arr)); $arr['body']=$body_str; }else{ $arr=array_merge($arr,$business_arr); } //var_dump($request_type."参与token生成的参数"); //var_dump($arr); //var_dump("业务参数"); //var_dump($business_arr); ksort($arr);//按照字典排序参数数组 //var_dump("字典排序后的参数"); //var_dump($arr); $sign = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/464fea3bcb3e03ea8b6b6bcc046b673c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a30b7854436ffda868f83b43dcbfec2/" rel="bookmark">
			大数据之LibrA数据库系统告警处理（ALM-12033 慢盘故障）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		告警解释 系统每一秒执行一次iostat命令，监控磁盘I/O的系统指标，如果在60s内，svctm大于100ms的周期数大于30次则认为磁盘有问题，产生该告警。
更换磁盘后，告警自动恢复。
告警属性 告警ID
告警级别
可自动清除
12033
严重
是
告警参数 参数名称
参数含义
ServiceName
产生告警的服务名称。
RoleName
产生告警的角色名称。
HostName
产生告警的主机名。
DiskName
产生告警的磁盘名。
对系统的影响 磁盘慢盘故障，导致业务性能下降，阻塞业务的处理能力，例如DBService主备同步等，严重时可能会导致服务不可用。
可能原因 磁盘老化或者磁盘坏道。
处理步骤 检查磁盘状态。
在FusionInsight Manager界面，单击“告警管理”。查看该告警的详细信息，查看定位信息中“HostName”字段和“DiskName”字段的值，获取该告警产生的故障磁盘信息。确认上报告警的节点是否为虚拟化环境。 是，执行步骤 4。否，执行步骤 7。
请检查虚拟化环境提供的存储性能是否满足硬件要求，检查完毕之后执行步骤 17。 说明： 硬件要求说明，可参考产品文档中《产品描述》的“部署方案 &gt; 硬件及运行环境要求”章节。
登录告警节点，执行df -h命令，查看输出内容是否包含“DiskName”字段的值。 是，执行步骤 7。否，执行步骤 6。
执行lsblk命令，是否可以查到“DiskName”字段值与磁盘设备的映射关系。 是，执行步骤 7。.否，执行步骤 25。
使用PuTTY工具，以root用户登录上报告警的节点，执行lsscsi | grep "/dev/sd[x]"命令查看磁盘的设备信息，判断磁盘是否建立了RAID。 说明： 其中/dev/sd[x]为步骤 2中获取到的上报告警的磁盘名称。
例如执行：
lsscsi | grep "/dev/sda"
如果命令执行结果第三列显示ATA、SATA或者SAS，说明磁盘没有建立RAID；显示其他信息，则该磁盘可能建立了RAID。
是，执行步骤 12。否，执行步骤 8。
执行smartctl -i /dev/sd[x]命令检查硬件是否支持smart。 例如执行：
smartctl -i /dev/sda
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a30b7854436ffda868f83b43dcbfec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0391b28fc9bbea388e553de2522212/" rel="bookmark">
			Matlab实现：图像边缘提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 边缘提取算法 方法一：一阶微分算子 Sobel算子 Sobel算子检测方法对灰度渐变和噪声较多的图像处理效果较好，Sobel算子对边缘定位不是很准确，图像的边缘不止一个像素。
Roberts算子 Roberts算子检测方法对具有陡峭的低噪声的图像处理效果较好，但是利用roberts算子提取边缘的结果是边缘比较粗，因此边缘的定位不是很准确。
Prewitt算子 Prewitt算子检测方法对灰度渐变和噪声较多的图像处理效果较好。但边缘较宽，而且间断点多。
Canny算子 Canny算子是目前边缘检测最常用的算法，效果也是最理想的。
Canny边缘检测算法不是简单的模板卷积而已，通过梯度方向和双阈值法来检测边缘点，具体算法可以参考：计算机视觉之一：特征检测 - AndyJee - 博客园；
图像边缘检测及图像区域分割、目标检测、目标识别
Canny方法不容易受噪声干扰，能够检测到真正的弱边缘。优点在于，使用两种不同的阈值分别检测强边缘和弱边缘，并且当弱边缘和强边缘相连时，才将弱边缘包含在输出图像中。
方法二：二阶微分算子 Laplacian算子 Laplacian算子法对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区。
2、 实验结果分析 一、边缘提取： Sobel算子检测方法对灰度渐变和噪声较多的图像处理效果较好，sobel算子对边缘定位不是很准确，图像的边缘不止一个像素；Roberts算子检测方法对具有陡峭的低噪声的图像处理效果较好，但是利用roberts算子提取边缘的结果是边缘比较粗，因此边缘的定位不是很准确；Prewitt算子检测方法对灰度渐变和噪声较多的图像处理效果较好。但边缘较宽，而且间断点多；Laplacian算子法对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区；Canny方法不容易受噪声干扰，能够检测到真正的弱边缘。优点在于，使用两种不同的阈值分别检测强边缘和弱边缘，并且当弱边缘和强边缘相连时，才将弱边缘包含在输出图像中。 二、边缘复合增强 Sobel、Robert、Prewitt算子的增强效果并不是很明显，尤其是Robert算子，因为它提取的边缘点过于稀疏和离散；Laplacian算子和canny算子的增强效果都比较理想， 将边缘叠加上去后，整个手的轮廓和边缘都很清晰，直观上看，canny算子实现的效果比Laplacian算子好，最明显的地方就是手指尖的边缘。基于蚁群算法的图像边缘检测 3、程序实现 下面的程序就实现上面效果的完整Matlab代码：
clear;clc; I=imread('x1.tif'); % I=rgb2gray(I); % gray transform J=imadjust(I,[0.1 0.9],[0 1],1); % Edge detection % Sobel BW1=edge(I,'sobel'); sobelBW1=im2uint8(BW1)+J; figure; %imshow(BW1); subplot(1,2,1); imshow(J); title('original image'); subplot(1,2,2); imshow(sobelBW1); title('Sobel augmented image'); % Roberts BW2=edge(I,'roberts'); robertBW2=im2uint8(BW2)+J; figure; %imshow(BW2); subplot(1,2,1); imshow(J); title('original image'); subplot(1,2,2); imshow(robertBW2); title('robert augmented image'); % prewitt BW3=edge(I,'prewitt'); prewittBW3=im2uint8(BW3)+J; figure; %imshow(BW3); subplot(1,2,1); imshow(J); title('original image'); subplot(1,2,2); imshow(prewittBW3); title('Prewitt augmented image'); % log BW4=edge(I,'log'); logBW4=im2uint8(BW4)+J; figure; %imshow(BW4); subplot(1,2,1); imshow(J); title('original image'); subplot(1,2,2); imshow(logBW4); title('Laplacian augmented image'); % canny BW5=edge(I,'canny'); cannyBW5=im2uint8(BW5)+J; figure; %imshow(BW5); subplot(1,2,1); imshow(J); title('original image'); subplot(1,2,2); imshow(cannyBW5); title('Canny augmented image'); % gaussian &amp; canny % h=fspecial('gaussian',5); % fI=imfilter(I,h,'replicate'); % BW6=edge(fI,'canny'); % figure; % imshow(BW6); figure; subplot(2,3,1), imshow(BW1); title('sobel edge detect'); subplot(2,3,2), imshow(BW2); title('roberts edge detect'); subplot(2,3,3), imshow(BW3); title('prewitt edge detect'); subplot(2,3,4), imshow(BW4); title('log edge detect'); subplot(2,3,5), imshow(BW5); title('canny edge detect'); % subplot(2,3,6), imshow(BW6); % title('gasussian&amp;canny edge detect'); figure; subplot(2,3,1), imshow(sobelBW1); title('sobel edge detect'); subplot(2,3,2), imshow(robertBW2); title('roberts edge detect'); subplot(2,3,3), imshow(prewittBW3); title('prewitt edge detect'); subplot(2,3,4), imshow(logBW4); title('laplacian edge detect'); subplot(2,3,5), imshow(cannyBW5); title('canny edge detect'); 下面的Matlab程序是精简的边缘提取实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c0391b28fc9bbea388e553de2522212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29efc1bfa611c7a24aab4ce2d8aa1f5d/" rel="bookmark">
			面了一个工作4年的JAVA程序员，这些个面试题一个都答不上来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有很多朋友去目前主流的大型互联网公司面试（阿里巴巴、京东、字节跳动、蚂蚁金服、滴滴），面试回来之后会发给我一些面试题。有些朋友轻松过关，拿到offer，但是有一些是来询问我答案的。
我特意整理了一下，有很多问题不是靠几句话能讲清楚，所以整理了一份Java核心知识点来解答这些面试题。很多问题其实答案很简单，但是背后的思考和逻辑不简单，要做到知其然还要知其所以然。
目录：
这个PDF的内容涵盖：Java、MyBatis、ZooKeeper、Dubbo、Elasticsearch、Memcached、Redis、MySQL、Spring、Spring Boot、Spring Cloud、RabbitMQ、Kafka、Linux 等技术栈，文末获取免费领取方式
JVM
线程
JVM内存区域
JVM运行时内存
垃圾回收与算法
JAVA 四种引用类型
GC分代收集算法 VS 分区收集算法
GC垃圾收集器
JAVA IO/NIO
JVM 类加载机制
JAVA集合
接口继承关系和实现
List
ArrayList（数组）
Vector（数组实现、线程同步）
LinkList（链表）
Set
HashSet（Hash表）
TreeSet（二叉树）
JAVA多线程并发
JAVA并发知识库
JAVA线程实现/创建方式
4种线程池
线程生命周期(状态)
终止线程4种方式
sleep与wait 区别
start与run区别
JAVA后台线程
JAVA锁
线程基本方法4.1.11. 线程上下文切换
同步锁与死锁
线程池原理
JAVA阻塞队列原理
CyclicBarrier、CountDownLatch、Semaphore的用法
volatile关键字的作用（变量可见性、禁止重排序）
如何在两个线程之间共享数据
JAVA基础
JAVA异常分类及处理
JAVA反射
JAVA注解
JAVA内部类
JAVA泛型
JAVA序列化(创建可复用的Java对象)
JAVA复制
Spring 原理
Spring 特点
Spring 核心组件
Spring 常用模块
Spring 主要包
Spring 常用注解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29efc1bfa611c7a24aab4ce2d8aa1f5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd691e91a00b9ea605ffa4619082efc7/" rel="bookmark">
			get请求后端返回的是Content-Type: image/jpeg,前端如何展示图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题 Content-Type: image/jpeg,前端何如处理图片处理方法讨论 问题 Content-Type: image/jpeg,前端何如处理图片 response里啥也没有，不通过返回图片地址的方式将图片给前端
在Preview中能看到完整的图片
处理方法 在Preview中鼠标右键点击图片，选择复制图片地址（Copy image url）
将这个地址放到img标签的src属性就可以正常显示图片
在实际开发中，我们需要自己去拼凑出这个地址
&lt;img src={`${window.location.protocol}//${window.location.host}/api/v1/imageinfo/qrcode?content=${ShareUrl}&amp;height=244&amp;width=244`} alt="" width="248px" height="244px" style={{ marginTop: '10px', }} /&gt; 讨论 有的同学提出，完全可以直接使用请求路径给img标签的src属性，一样能够正常渲染出来。某种意义上说，也没错。如果你的url上不存在什么敏感信息，是可以这么做的。为了安全考虑，如果url上有token或者用户信息，不建议直接使用请求路径赋值给img的src。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5a011362a941e6f1428f5e39f8f49d/" rel="bookmark">
			html-webpack-plugin 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML Webpack Plugin 是一个非常有用的插件，它可以帮助你自动化地生成 HTML 文件，并将打包后的静态文件部署到指定的文件夹中。下面是一个基本的 HTML Webpack Plugin 配置示例：
javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
// ...
plugins: [
new HtmlWebpackPlugin({
title: 'My App',
template: 'src/index.html', // 指定要使用的 HTML 模板文件
filename: 'index.html', // 指定输出的 HTML 文件名
inject: 'body', // 将打包后的脚本注入到 HTML 文件的 body 中
minify: {
collapseWhitespace: true, // 压缩 HTML 文件中的空格
removeComments: true, // 删除 HTML 文件中的注释
removeRedundantAttributes: true, // 删除多余的 HTML 属性
removeScriptTypeAttributes: true, // 删除 script 标签中的 type 属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db5a011362a941e6f1428f5e39f8f49d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a6e93481b69b3185823749ef8c7a046/" rel="bookmark">
			MySQL记录文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终端打开和使用mysql命令 管理员模式下，net start mysql打开数据库
然后，输入mysql -u root(用户名) -p 123456(密码)，进入mysql；
show databases; 看看有哪些数据库；
use 数据库名称（如果想要创建一个数据库，使用create databases 名称；来创建）
....
退出数据库时使用quit；命令；
关闭mysql服务，net stop mysql
select version();查看sql的版本号 select database();查看正在使用的数据库 show databases;查看sql中有哪些数据库； creat database 库名；创建数据库 source 绝对路径（不能有中文）；将文件导入数据库,执行脚本文件。 use 库名；使用数据库 show 表名；展示库中的表名 select * from 表名；查看表中的内容（*效率低，可读性差） desc(describe) 表名；查看表的结构
单行处理函数 需要注意 isnull()只能判别是否为null,ifnull(字段，替换值)可以用来替换。
多行处理函数不对null进行处理。max()，min(),count(),avg(),sum();
count((具体字段)不包括null，count（*）包含null；
单表查询执行顺序： from -&gt;where -&gt;group by-&gt;having-&gt;select-&gt; order by
格式：
select ....
from ....
where ....
group by ...
having ...不能单独使用，与group by搭配使用
order by .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a6e93481b69b3185823749ef8c7a046/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef201d5d7b2de727c2866d07b3cde5f4/" rel="bookmark">
			华为两大旗帜性人物相继发声！透露出哪些重要信息？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近几年，“算力”一词越来越频繁地出现在我们的视野中，随着数字化与智能化进程的加快，对于算力的要求越发迫切。
不知道朋友们有没有关注到，近日华为两大旗帜性人物，在短时间内也相继谈及算力......
01 、华为持续加码“算力” 任正非、孟晚舟相继发声 在今年的华为全联接大会上，华为副董事长、轮值董事长、CFO孟晚舟提出要“打造中国坚实的算力底座，为世界构建第二选择”。
孟晚舟认为，算力是人工智能发展的核心驱动力。大模型需要大算力，算力大小决定着AI迭代与创新的速度，也影响着经济发展速度。算力的稀缺和昂贵，已经成为制约AI发展的核心因素。
△ 图片来源网络（如侵删）
无独有偶的是，就在不久前，网络中也流传出华为创始人兼CEO任正非8月21日、8月26日与ICPC基金会的谈话纪要。在谈话中，任正非直言，“我们即将进入第四次工业革命，基础就是大算力，第四次工业革命波澜壮阔，其规模之大不可想象”。
作为华为两大旗帜性人物，任正非与孟晚舟接连谈及算力的重要性，实为罕见。但其实，华为早就在联接、大模型、算力等多个维度上对外赋能，今年以来，其在大模型和算力方面进展尤为迅速。
在算力方面，华为的昇腾系列芯片一直是算力旗舰，近期发布的Atlas 900 SuperCluster吸引了不少人的关注，它采用了自主研发的芯片和技术，性能非常强大。
据说一台Atlas900的价格高达亿元级别，非常抢手，它的算力相当于200台英伟达的H100，即一万两千张4090显卡，可以共享内存，共同完成AI训练任务。这款超级计算机的目标是打造世界上最强的通用型人工智能，以训练出超越ChatGPT的成果。
△ 图片来源网络（如侵删）
随着人工智能的迅速发展，全球范围内的科技巨头都在竞相探索其潜在的边界。在这场算力的竞赛中，华为再次成为引领者。
02 、算力赋能千行百业高质量发展 人才需求迫在眉睫 人类探索的脚步不断向前，算力也在持续创新升级。
简单来说，算力就是计算能力，有人解释说，如果我们把人工智能的发展以及各行各业的数字化转型比喻成“做饭”，那算力就是不可或缺的“炒菜锅”。
在数字经济蓬勃发展的今天，算力如同电力、热力、水一样，正成为经济社会高质量发展的重要支撑。中国信通院发布的《中国算力发展指数白皮书（2023年）》显示，我国算力规模连续两年增速超过50%，2022年我国在全球算力规模中的份额占比达33%，位居世界前列。
△来源中国信息通信研究院、IDC、Gartner、TOP500
近年来，随着算力需求持续增长，我国算力产业加速发展，覆盖相关领域的云计算与大数据产业发展空间也更加广阔。在2022年，我国数字经济规模达到50.2万亿元，同比增长10.3%，占GDP比重达41.5%。自2012年以来，数字经济增速已连续11年显著高于GDP增速，但现有的数字人才数量远少于实际需求。 △ 图片来源网络（如侵删）
同时，《数字经济就业影响研究报告》显示，我国数字化人才缺口已接近1100万，并且伴随全行业的数字化推进，需要更为广泛的数字化人才，人才缺口依然在持续放大。
在未来，AI必然会再次颠覆我们的生活，而相关技术人才也将成为紧缺“资源”，被各大互联网企业争抢。
03 、行业振兴，人才先行 黑马程序员为你保驾护航 眼下，在云计算、通信、AI的技术浪潮下，没有一家巨头会缺席AI的历史性机遇，华为早已躬身入局，凭借其突破性的科技实力和创新能力，成功脱颖而出。
数字化的快速发展，带来了数字人才需求激增。虽然我们每年有大量的理工科毕业生，但供给的缺口仍然巨大。造成人才短缺的原因，一方面是这些新兴技术的应用广泛，应用领域多，需要掌握多种技能和知识。另一方面，这些领域的技术发展迅速，需要不断学习和更新知识，因此对人才水平的要求也更高。
一直以来，黑马紧跟市场需求，课程设置与当前热门行业高度契合，开设：JavaEE、HTML&amp;JS+前端、Python+大数据开发、人工智能开发、电商视觉设计、软件测试、新媒体+短视频直播运营、产品经理、集成电路应用开发(含嵌入式)九大精品课程。全国20个校区遍布各大城市，累计培养超30万+优秀数字化人才。
在黑马，有70%学员来自老学员口碑推荐，很多学长学姐毕业后直接进入了自己心仪的互联网大厂，例如华为、京东、阿里、OPPO、比亚迪、顺丰等等，他们利用自身所学的专业知识，在技术领域发光发热。
同学们对黑马的评价：
我们深耕IT教育17年，始终坚守以“做好课”为课研目标，建立专职课研团队，坚持不断追求更高的课程标准、项目标准，注重教学过程中的应用性与实践性。每年斥资亿元进行多场景、多行业、深技术的项目研发，真实还原企业级项目，助力学员高起点就业。
从黑马毕业的同学凭借扎实的基础知识、丰富的实战经验，以及贴合企业用人需求的综合能力，在互联网行业杀出重围，赢得企业青睐。播妞带来了黑马程序员2023年第三季度各学科就业数据，我们用实力证明，入局更加轻松，高薪不是偶然！
不断涌现的新技术正在以前所未有的速度改变着我们的生活，我们不仅享受科技带来的便利，也在参与、贡献、构建这个伟大的时代。
正像约翰·列侬说的：“一个人的梦想只是梦想，一群人的梦想就能成真”。在此大背景下，作为普通人，我们能做的就是躬身入局，跟上这个时代，跟上这群人，方能成事。
如果你也想成为其中的一员，但苦于没有基础，也没有技术，那么请来黑马程序员吧，通过系统学习，实现高起点就业！可以预见的是，你将获得远超同龄人的高薪、广阔的发展前景、更大晋升空间…… 最好的时代，在等着你大展拳脚！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269c2dd8762e43d87d069b455f394243/" rel="bookmark">
			stable-diffussion-webui&#43;sd-webui-text2video&#43;SadTalker数字人生产力工具安装配置教程（Linux Ubuntu，避坑帖）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 背景 虽然网络上已经有很多类似的文章，但是讲linux 上通过 stable-diffussion-webui整合各类生产力插件的还比较少，而且亲测有效的更是凤毛菱角。为了帮助大家避坑，笔者特意利用休息的时间写了这篇文章。力求让小白玩家也能够上手。
在linux整合stable-difussion有什么用：
1、帮助创作者提高生产力。因为主流的A100、H100等显卡都是跑在服务器上面的专业卡，而服务器99%是用Linxu系统。当然您硬是要给服务器装Windows也是可以的，但实际上可能会造成性能浪费。在Linux服务器上配置一台A100显卡的GPU服务器即使是用40G版本的单卡，也能满足一个小型工作室对生产力的需求了。
2、帮助研究AI应用领域的伙伴增强认知，很多东西不自己亲自去搭一个、跑一个、改一个是很难在脑海中形成对知识的深刻认知的。
3、在linux上运行服务会更稳定，更专业。
实验环境：
服务器SuperMicro 超威操作系统Ubuntu 20.04.6 LTS
Release: 20.04
Codename: focalCPUArchitecture: x86_64
CPU op-mode(s): 32-bit, 64-bit
Byte Order: Little Endian
Address sizes: 46 bits physical, 57 bits virtual
CPU(s): 48
On-line CPU(s) list: 0-47
Thread(s) per core: 2
Core(s) per socket: 12GPUNvidia A100 sxm 40G * 4 (Nvlink 双卡连接) 内存512Gb 笔者估算在不进行任何量化或其它压缩的情况下能稳定运行的最低配置要求：
服务器SuperMicro 超威操作系统Ubuntu 18\20.04.6 LTS
Release: 18\20.04
Codename: focalCPU4核以上够用就行GPU支持CUDA平台的N卡，显存8G以上。内存16Gb以上磁盘固态或者机械（40G以上） 1 介绍 1.1 StableDiffussionWebUI github地址：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/269c2dd8762e43d87d069b455f394243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40bba81db53a50e0b47424ea9eeb11de/" rel="bookmark">
			唐以后汉人政权的扩张欲望是不是降低了，如果是，因为什么呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在科举制以前，是军功授爵制，中华民族武德充沛，想当官封爵，封妻荫子 得靠战场杀敌。宋朝全面科举之后，文官开始成为既得利益集团 ，又不用上前线，在后方紧吃。
科举制无限膨胀，堵死了军功爵制 上升通道，要是没有“自古以来”，文官老爷们连燕云 都不想要，打仗就有人立功，立功就得升官，权利被臭丘八 拿走了可怎么得了。
只要科举制成为朝庭选官的主流，那么军功就一定不太值钱了。军功在高，也不可能做内阁大学士，就是说文武分野就一定会出现，那么就没有出将入相这回事了。既然如此，朝庭就一定是保守风气占主流，开疆扩土就没什么用了。外向型国策就会彻底结束，那么被外敌入侵就是大概率事件 ，只要不能出将入相，那么开疆扩土政策就会终结。
北宋时期西夏 那么丁点人口和耕地的政权就能摁着北宋揍，不是因为北宋时期的蛮夷脑袋上长了通天纹 ，北方军事技术大爆发，而是宋朝社会主要资源流向军队系统的通道被科举制堵死了。
科举制绝对是汉族人的恶性肿瘤 、癌细胞，它吸收了汉族社会几乎所有的资源，培养出来的所谓人才就只有收租，兼并土地，生儿子接着科举这些蝇营狗苟 的梦想，其它任何利益集团都会被科举文官系统无情的碾碎。而对于汉族皇帝来说，瞌睡来了递枕头，也乐于跟科举文官系统一起躺平。
汉族皇帝有科举这么个玩意儿，是不会把权力交给武将的。科举这玩意儿就相当于瞌睡了递来个枕头，哄着皇帝一点点堕落。
皇帝制度最大的弊病就是，担心权臣篡位 ，开国雄主还好，后代一弱，就各种防范权臣出现，拉低了中央政府整体政治水平。一头猛虎为了自己的幼虎，防范家里出现其他猛虎，养了一群哈士奇 ，但哈士奇只是披着狗皮的狼 ，会联合起来架空幼虎，不会扩张领地，最后还把家拆了。天下太平问题还不太大，一旦其他虎群崛起，就是本虎群的灭顶之灾，而哈士奇们只是换个主子
如果府兵制 作为地主阶级会提高战斗力，那么科举制度 必然也会削弱部队的战斗力，因为普通人晋升地主阶级的渠道从参军转变成了科举，出现重文轻武 也是必然趋势。自科举制度诞生以后中国的朝代基本上都重文轻武。反倒是保存着军功贵族的北方游牧民族 开始不断建立政权甚至颠覆汉人政权。
汉唐 不是这个套路，汉唐它的权力核心，地主阶级科举文官从来不是主流，汉唐里面的权力骨干是世家门阀和军功贵族占据了大量股份。
古代的社会管理实在太粗疏了，根本检验不出来水平，一个能吏和一个依靠关系网混事儿的人，看不出多大区别。这也是汉唐高明之处，因为敌人不可能配合你，所以只有用敌人检验过的官吏，才是有真才实学的。卫霍 ，那就是比李广强。哪怕你黑了心去杀良冒功，也得能杀的过自卫的民众啊。明末 不就是一群人连饿殍的穷人都杀不过嘛。
而这种冷酷的考评方式，遭到了笔杆子 阶层的疯狂抵抗。汉唐时期他们是传统贵族，于是写的东西，拼命美化世家子弟 ，从底层一刀一枪拼出来的，哪怕贵为皇帝，照样抹黑你没商量。后期，他们是耕读传家 的地主和文官阶层 ，拼命折腾一切干活上位的人。管你是军功还是农商，只要干活就给我去死，清流只负责挑毛病，你多干多错迟早下台。最后就是我们这些不干不错的人“众正赢朝”了。
千万不能允许皇帝掌握任何有效的考评机制，那样的话他就可以正常的升降官员了。对官员的考评从三年降到五年最后无疾而终咯，大家都是同乡或者同学，合伙糊弄皇帝，喜滋滋一起瓜分国有资产，多么美妙。
国家机构，再怎么奢侈腐败，多少需要干点活啊，多少干点，薪水小偷不能太多。所以，怎么才能筛选出，真正有本事能干活的人，即成了皇权头疼的问题。
两个著名例子，汉武帝对儒生狄山 ，就问他能管理多大地方，不断降低，直到降到一城，狄山终于找不到借口了，只好硬着头皮应承下来。结果没过多久就被匈奴砍了。
另一个是宋神宗 要找人治理黄河 水患，司马光这么牛的大儒就派他去吧，结果吕公著 说：这样不是善待儒士之道。
汉唐喜欢折腾，并不是什么穷兵黩武 ，而是他政策就鼓励底下干活的人折腾，然后有能力的人，自己就漫漫浮出水面了。
九品中正那种子孙世袭，不代降的制度确实会造成阶层固化，底层上升渠道封闭的问题，但九品中正没维持几年就因为五胡乱华，东晋南迁而不再了。无论是南朝 还是北方，在竞争中都需要尽可能地提拔和寻找优秀人才 ，五胡到南北朝 再到隋，到唐早期，汉唐一直是标准的军功爵代降制度 ，并不是子孙代代可保富贵，只要有真才实学的人，绝对不会给埋没，这种制度显然比起后世的科举要优越许多。
以前的小地主阶级 ，想要往上爬，只能去打仗。但科举制带来的改变，影响实在是太大了。出现了一条能安安全全，不用刀口上舔血的路。轻轻松松就阶级跃迁 了，科举制还作弊严重，军功爵则几乎不可能作弊。阶级跃迁本来就应该拿血和泪去换的，这样的精英才是民族需要的
唐以后实行科举制某种意义上削了世家，放开了乡绅士人，但乡绅士人党其实比世家还没底线（乡绅其实就是文官集团的主要来源），世家是股东，起码有自己的荣誉感，这群乡绅士人是管家CEO，为了利益搜刮百姓比世家更狠，结党合谋甚至到把持史官，宋后的历史一直就有种诡异的感觉，被笼罩在一层大阴谋里。乡绅士人党家国意识很差，只要不影响自己利益，换谁当皇帝都行。
唐代 的进士每科不到30名，宋朝扩招了10倍，而且只有进士科 。唐朝 科举考试就有秀才、明经、俊士、进士、明法（法律）、明字、明算（数学）一史、三史（历史）、开元礼、道举等多种科目，唐朝科举还有一些理科。宋朝只有进士科，只考经论、策论、诗词，纯文科。严重脱离实际与基层情况。所以王安石变法要用公立学校替代科举选拔人才，结果遭到科举文官集团强烈抵制失败。
王安石变法的失败，标志着中原汉文化 意识形态政权组织 最后一次自我救赎 的彻底破产，从此一路火花带闪电的坠入深渊，两度被异族征服后消失在历史的长河之中，最终被中华民族文化认同替代，才重新恢复生机。
唐朝的皇帝在初期凭着北朝八柱国 形成的世袭军队、中后期靠着宦官掌握的雇佣军队，还可以搞一搞中兴。宋朝的皇帝就已经完全无法对抗科举文官了。宋仁宗想勤政一点，据说干了一个月就被大臣们收拾得中风了。宋英宗 干脆被收拾成了精神病。宋神宗甚至收到了“你是要和人民站在一边，还是要和官员站在一边”的选择题（熙宁四年，掌握军队的枢密使 文彦博对宋神宗说：“祖宗法制俱在，不须更张，以失人心。”神宗说：“更张法制，于士大夫诚多不悦，然于百姓何所不便?”文彦博回答：“为‘与士大夫治天下，非与百姓治天下也’。”）。
全面推行科举制，中华民族的勇武尚武精神 和对外拓展的能力大倒退，游牧民族卷土重来，首都被两次占领，几次签署卖国条约。从商鞅建立的军功授爵制保证了民族尚武精神，然而宋朝读书考试，投统治者所好的就可以高位，以文制武，民族的灾难就来了。商鞅军功爵数敌人人头是客观分，科举是主考官判断，是主观分。曾国藩 就曾经回忆，很多进士连基本常识都没有，甚至不知道清朝之前还有其他朝代。但这些人依然能当封疆大吏 北宋有个典故就是某人明明成绩很好，主考就不给中，一定要他年纪大了才给中，说是磨去火气，考虑下古代那个人均寿命真的呵呵，居然现在一群人还当美谈传！这些人也不想想，亚历山大几岁死的，霍去病 几岁死的，他们什么功业，宋朝那群美谈士大夫什么功业
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40bba81db53a50e0b47424ea9eeb11de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d227966da5c48b720692ce325714267f/" rel="bookmark">
			是精心培养一个孩子好还是放养一个孩子好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		得看孩子的类型。
第一种孩子。话唠型。
这种请务必贴身养育。
关注他的每一个需求，理解他的每一个顿悟，夸奖他的每一个成就。
因为这样的孩子就是在无时无刻的通过说话整理思维，获取反馈，从而学到知识。
这种孩子就是得跟别人讲，他不讲出来他学不会。甚至说，有些事情不讲出来，他都不知道他自己能联想到那么多。
家长需要做的是帮孩子收束发散的思维，用问题引导他顺着一个方向 说。在他想不明白的时候帮他一把，这样孩子思维就会拥有深度。
第二种类型的孩子，画家。
这样的孩子请务必放养。
早早教会他使用思维导图 ，以及文字阅读的能力。然后保证充分的信息输入。不要过于担心电子设备 的负面影响。放手让孩子使用。这样孩子就会自动的去学习。
第三种类型的孩子，跑者。
这样的孩子请一定，务必，必须贴身养育。
让他去运动。且必须保持一万分的小心，时刻关注他的安全。学习什么的根本不用着急。身体好了脑子才能好。别指着学校，请个家教单教，学习自然错不了。家长只要注意，不要因为考试成绩 等学习原因批评孩子就行了。
还有，此类孩子一般来说都不会被学校老师喜欢。小学教师中还充斥着很多喜欢发泄情绪的人扎，所以尤其要注意保护孩子。不要让这类孩子的学习兴趣被老师打压到。
有哪一刻你彻底恨上了你老师？5.3 万关注 · 3.4 万回答问题 第四种类型的孩子，侍从。
这种类型的孩子绝对不可以放养。
他们需要服从。服从一个权威 让他们舒适，有安全感。如果父母不在身边，他们会非常非常不知所措。这种孩子非常听话，反抗意识 几乎没有。
家长一定得注意保护。因为这种孩子大部分是女孩，又不太会反命令，所以务必务必要严加保护。
这种孩子非常适合那些需要大量练习的项目。例如乐器，舞蹈 等技艺。也需要家长的陪同才能进行。
第五种类型的孩子，演员。
这类孩子可以放养。但需要帮助他挑选一个很好的环境。
这类孩子非常非常善于模仿 ，无论是动作还是语言，总是喜欢模仿。他们很早很早就能学会模仿别人的特点并夸张出来的搞笑方式。
这类孩子要尽可能的报各种班。是的，只有这种孩子才适合去各种培训班 。是“各种”培训班。无论学科类还是非学科类。他们的学习能力是最原始的，最高效的。短板在罗辑思维与推理。几乎没有学霸，但看起来都非常聪明。
家下来还得看家长。
有耐心，能做到不喊不打的家长请尽量多陪伴。
那些动不动又打又骂的请远离。
赚钱能力强的请务必去赚钱，你的时间不应该浪费在孩子身上。应该请专业的人去做这件事，应该通过多生孩子来规避继承人风险。
赚钱能力差的，应该多陪伴孩子。因为孩子本来的起点就差。如果本领再差，那可就真的是太惨了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9514ebee6fe2fa870624760deb9af7f/" rel="bookmark">
			Conda常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看anaconda环境
conda env list 或 conda info -e 2、查看下载源地址
conda config --show-sources 3、设置镜像源
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main 4、设置搜索时显示通道地址
conda config --set show_channel_urls yes 5、换回默认源
conda config --remove-key channels 6、 创建虚拟环境
conda create -n env_name python=xxx 如：创建一个python 3.7，名称为Test环境： conda create -n Test python=3.7 7、激活虚拟环境
Linux: source activate your_env_name(虚拟环境名称) Windows: activate your_env_name(虚拟环境名称) 8、退出虚拟环境
Linux: source deactivate your_env_name(虚拟环境名称) Windows:deactivate env_name， 9、删除环境
conda remove -n evn_name --all 10、复制环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9514ebee6fe2fa870624760deb9af7f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/72/">«</a>
	<span class="pagination__item pagination__item--current">73/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/74/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>