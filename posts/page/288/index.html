<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd440e541b57a0cfff4fb8269fe03fcc/" rel="bookmark">
			【VS code找不到头文件】成功解决 （检测到Include错误，请更新includePath）（明明有头文件，却找不到）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode 是一款好用且功能十分强大的编辑器。
写在前面： 本文是解决有头文件，却找不到的情况。
如果本身没有头文件，肯定是找不到的了。比如，没有安装c语言的运行环境，是没有sdtio.h文件的，再怎么包含还是找不到的，需要先安装c语言的运行环境。再比如，没有单片机的环境，直接include"reg52.h",也是找不到的（且就算复制一份reg52.h到工程，一些特殊的变量、寄存器没有声明，也是会报reg52.h头文件有错误的）
如果是入门学习c/c++，需要编译简单的代码，还是建议使用Visual studio等编译器，而不是Visual studio code这种编辑器。
对于由使用编译器过渡到编辑器而言，在编写C/C++代码时，找不到头文件很让初学者头疼。
找不到头文件，不能进行定义跳转，十分影响开发效率。
如下图，明明工程里面有自己写的头文件，却就显示找不到下面的三个头文件。
问题描述： 工程里面有指定的头文件，却显示无法找到。
解决思路 更新includePath，添加头文件的路径，告诉vsc去哪里找我写的头文件。
解决步骤： 1.新建文件夹 在工作区的根目录，新建.vscode文件夹。操作如图。（也可以直接系统的界面里面新建文件夹）
2.打开json配置文件 在软件界面按住Ctrl+Shift+P，在软件上方出现输入框中输入：C/C++:Edit Configurations。选择第一个配置JSON配置。
3.编辑配置文件 经过第二步，.vscode目录下面会自动添加了一个c_cpp_properties.json。在c_cpp_properties.json中加入自己需要的头文件路径。如图。
添加完成后如图。
保存c_cpp_properties.json即可大功告成。
结果 警告消失了，恭喜你可以正常查看定义了。
注意 1..vscode文件夹要放置在工作区的根目录
2.注意路径添加的格式。以逗号隔开，最后一行可以不用逗号。
3.注意将工作区保存的文件ledc_bsp.code-workspace和.vscode在同一级目录。
4.建议包含的路径使用相对路径。(不会相对路径，写绝对路径也行)
PS：${workspaceFolder}为当前工作区的路径，以${workspaceFolder}开头的路径就是相对工作区的路径。因为使用绝对路径时，当工作区的路径改变（比如从d盘移到e盘），又会陷入找不到头文件的窘境。
如果对你有帮助的话，
麻烦点一下免费的赞，
支持一下。
感谢您的阅读。
欢迎评论交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3817af9c46c1af7d7bf642b0f9226590/" rel="bookmark">
			矩阵的运算及其运算规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、矩阵的加法与减法 1、运算规则
设矩阵 ， ，
则
简言之，两个矩阵相加减，即它们相同位置的元素相加减！
注意：只有对于两个行数、列数分别相等的矩阵（即同型矩阵），加减法运算才有意义，即加减运算是可行的． 2、 运算性质 （假设运算都是可行的）
满足交换律和结合律
交换律　；
结合律　．
二、矩阵与数的乘法 1、 运算规则
数 乘矩阵A，就是将数 乘矩阵A中的每一个元素，记为 或 ．
特别地，称 称为 的负矩阵．
2、 运算性质
满足结合律和分配律
结合律： (λμ)A=λ(μA) ； (λ+μ)A =λA+μA．
分配律： λ (A+B)=λA+λB． 典型例题
例6.5.1　已知两个矩阵 满足矩阵方程 ，求未知矩阵 ．
解　由已知条件知
三、矩阵与矩阵的乘法 1、 运算规则
设 ， ，则A与B的乘积 是这样一个矩阵：
(1) 行数与（左矩阵）A相同，列数与（右矩阵）B相同，即 ．
(2) C的第 行第 列的元素 由A的第 行元素与B的第 列元素对应相乘，再取乘积之和． 典型例题
例6.5.2　设矩阵 计算 解　是 的矩阵．设它为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3817af9c46c1af7d7bf642b0f9226590/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83640250ed982aa50055ee5ed901761c/" rel="bookmark">
			AutoCad 批量打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
软件下载和安装
基本简介
Batchplot(CAD批量打印工具)安装步骤
操作特别说明
软件下载和安装 软件包下载链接：
https://download.csdn.net/download/weixin_43341767/21494419
https://www.onlinedown.net/soft/982973.htm
基本简介 Batchplot是一个专门针对AutoCAD2000以上版本设计的单DWG多图纸的批量打印、批量生成布局、批量分图工具。Batchplot功能强大，操作简单，可以根据自己的需求任意调整打印设置，有需要的小伙伴赶快到华军软件园下载体验吧。
查看
Batchplot(CAD批量打印工具)功能特色
1. 能够批量打印 AutoCAD 和其他软件生成的DWG/DXF 文件。
2. 支持智能识别图纸的打印区域(图框)及绘图比例，无需逐个设置图纸的打印区域。
3. 支持按目录添加图纸，高效率添加图纸文件。
4. 支持一次选择多个图纸文件批量打印，也能够智能识别一个文件中的多张图纸。
5. 图纸排版算法国际领先，最大限度地节省纸张和耗材。
6. 支持单页打印和卷筒纸打印，能自动缩放打印图纸和线宽，批量输出最佳打印效果。
7. 按图纸类别分类分批打印图纸，适用于各种打印硬件环境。
Batchplot(CAD批量打印工具)安装步骤 1、在本站下载batchplot软件包，解压缩双击运行它的.exe文件。之后就打开了它的安装向导，点击下一步;
2、阅读软件相关协议，点击同意再点击下一步;
3、接着就来到软件信息界面，点击下一步。
4、选择电脑上autocad版本，目前它可支持autocad2010及以上版本。勾选后点击下一步继续;
5、选择安装位置，点击路径后面的浏览按钮为batchplot选择一个合适的位置即可。(避免不影响软件的使用和电脑运行速度所以这里小编直接为大家的介绍的自定义安装方式。)
6、然后就阅读软件安装信息，点击安装，等待batchplot安装;
7、安装完成后，就会看到如下界面，点击完成即可。
Batchplot(CAD批量打印工具)使用教程
Batchplot CAD如何批量打印成PDF文件？
1、Batchplot安装完成后，打开AutoCAD软件，在命令栏中输入“bplot”命令（可能batchplot），回车;
2、如果输入以上命令后没任何反应，这时你可以点击工具选项在它的下拉菜单中选择“加载应用程序中”点击等待加载即可。
3、接着来到批量打印窗口，在这里我们看到左上角有三种打印方式：【常用】图框层;【图块】;【图层】。(一般我们这里选择后两种，当然你也都点击试试看，根据自己的需求来选择即可。)
4、然后在来为打印设置一下参数，在这个面板中根据自己的需求点击所需要的选项设置即可。
5、然后确认下以上自己设置的内容无误后点击“应用”，这样就能应用到我们要打印的文件中了。接着选择要处理的图纸，选中一个以后再按下面的批量选择所有的图纸;
6、最后点击确定打印即可，之后就看到我们的图纸按照自己的设置方式打印完成了。
1、Batchplot安装了后，CAD无法识别Bplot这个快捷键，是什么原因?
如果发现上述情况那你可以尝试输入“PU”命令清理一下缓存，接着在输入"RE"命令重新生成一下，完成上述两步后在使用批量打印工具试试看。如果尝试后并无改善那只能再重新安装一下了。
2、如何调整batchplot中的亮显范围?
这里要说明一下的是batchplot是批量打印CAD图的工具，图框呢尽量自己制作，可以把它存放为图块，还可以根据根据自己的需求来缩放旋转。但是如果你想亮显范围batchplot暂无此功能，所以就不能实现了。如果真的想要这个亮显范围的话，手动输入也是可以的，但是可能会有些耗时。
Batchplot(CAD批量打印工具)更新日志
1、添加：支持起点与终点重合的五个顶点的非闭合PLINE线图框
2、增加：对部分种类的pc3和打印机程序的PLT文件默认扩展名的的判断
3、比如：PublishToWeb JPG.pc3设备自动设置扩展名为JPG等等。
操作特别说明 详细操作可以查看如下链接视频
https://haokan.baidu.com/v?pd=wisenatural&amp;vid=13141143568625151330
如下红框部分需要注意选择配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732930253acdca1f2089415544084d4f/" rel="bookmark">
			MATLAB如何进行系统辨识（传递函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB有一个常用的系统辨识工具箱，能够根据输入输出数据计算得到系统的传递函数，或是状态空间模型，下面给出具体的实施方法。
1、准备 将输入输出数据保存存到MATLAB的工作空间中； Matlab命令行窗口输入：systemIdentification 即可打开系统辨识工具箱 如图下所示为Matlab系统辨识工具箱组成说明 2、载入数据 如图，选中要载入数据的类型； 在跳出的数据配置界面中，填入输入输出数据的名字（在工作空间中的变量名）；采样周期，根据实验采集数据输入输出的采样时间而定，本实验中采用的是0.01s；
3、系统辨识 如下图所示为模型辨识设置，根据自己实验模型选择适合的模型辨识，我这里选择【传递函数】。
如图所示为传递函数模型参数配置，这里极数设置为2，零点设置为1作为待辨识模型，配置完参数后，点击“Estimate”按钮开始进行辨识。
如图所示为传递函数模型辨识结果，左边对话框显示了模型辨识精度及相对误差。
如图为系统辨识参数结果，双击右边对话框中的辨识模型结果tf1，弹出如下对话框，至此，完成了整个简单的系统辨识工具箱的使用流程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47086f82c1afcfc1942babb95651adb/" rel="bookmark">
			Java Arrays.asList()方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是对Arrays.asList()方法从源码角度进行分析，解析使用中的一些困惑。
首先看Arrays.asList()的源码
public static &lt;T&gt; List&lt;T&gt; asList(T... a) { return new ArrayList&lt;T&gt;(a); } 使用该方法 可以将一个变长参数或者数组转换成List
看似很简单但实际使用起来却会发现存在很多问题，看下面代码来发现问题。
先来看第一个问题，基本类型数组作为参数问题。
public class ArraysAsListTest { public static void main(String[] args) { int[] a = {1,2,3}; Integer[] b = {1,2,3}; List listA = Arrays.asList(a); List listA1 = Arrays.asList(1,2,3); List listB = Arrays.asList(b); System.out.println(listA.size());//out:1 System.out.println(listA1.size());//out:3 System.out.println(listB.size());//out:3 } } 嗯？用int类型的数组作为参数为什么输出size是1呢，使用Integer类型size就是3了呢。
再看源码，asList接收的是一个泛型变长参数，而我们知道基本类型是不能泛型化的，就是说8种基本类型不能作为泛型参数，要想作为泛型参数就要使用其所对应的包装类。
但是listA的Size为什么是1呢，这是因为listA传递的是一个int类型的数组，数组是一个对象，它是可以泛型化的，也就是说例子中是把一个int类型的数组作为了T的类型，所以转换后在List中就只有一个类型为int数组的元素。后边ListA1与ListB也就可以理解了，一个是进行了自动打包，一个是本来就是包装类型。
我们可以打印下list中元素类型进行验证
System.out.println("ListA元素类型："+listA.get(0).getClass()); //out:ListA元素类型：class [I System.out.println("ListA元素："+Arrays.toString((int[]) listA.get(0))); //ListA元素：[1, 2, 3] 该处是为了验证list中元素 System.out.println("ListA1元素类型："+listA1.get(0).getClass()); //out:ListA1元素类型：class java.lang.Integer System.out.println("ListB元素类型："+listB.get(0).getClass()); //out:ListB元素类型：class java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a47086f82c1afcfc1942babb95651adb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c0e164c387f915f601b2be4d83b9cdd/" rel="bookmark">
			学习笔记2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础模电知识~集成运放一.运算放大器特性二.共模抑制比三.反馈四.同相与反相放大器 基础模电知识~集成运放 一.运算放大器特性 运算放大器（简称“运放”）是具有很高放大倍数的电路单元。在实际电路中，通常结合反馈网络共同组成某种功能模块。它是一种带有特殊耦合电路及反馈的放大器。其输出信号可以是输入信号加、减或微分、积分等数学运算的结果。由于早期应用于模拟计算机中，用以实现数学运算，故得名“运算放大器”。运放是一个从功能的角度命名的电路单元，可以由分立的器件实现，也可以实现在半导体芯片当中。随着半导体技术的发展，大部分的运放是以单芯片的形式存在。运放的种类繁多，广泛应用于电子行业当中。
集成运放是具有高开环电压放大倍数、高输入电阻和低输出电阻的多级直接耦合集成放大电路。
运算放大器理想化的主要条件：
（1）开环电压放大倍数为无穷大；
（2）开环输入电阻为无穷大；
（3）开环输出电阻为零；
（4）共模抑制比为无穷大。
电路符号
端口意义
外部电源连接
实际运放外部引脚实例
运算放大器的电路模型
运算放大器的传输特性
注意输入和输出相位的关系
二.共模抑制比 定义：　差模电压增益与共模电压增益的比值，用dB 表示。
理解：　运算放大器在单端输入使用时，不存在这个概念。只有把运放接成类似于减法器形式，使得运放电路具备两个可变的输入端时，此指标才会发挥作用。
上图电路中，差模增益Ad=R2/R1，如果给电路的两个输入端施加相同的输入电压Uic，在输出端理论上应为0 输出，实际会测量到由Uic引起的输出Uoc，则共模抑制比为：
其实就是现将输出电压按照差模增益折算到入端，再让输入电压除以它——共模输入被抑制了多少倍。
三.反馈 由于运算放大器的开环电压放大倍数很高，当它工作在线性区时必须引入深度负反馈。因此，它的输出与输入之间的关系基本决定于反馈电路和输入电路的结构与参数，而与运放本身的参数关系不大。改变输入电路和反馈电路的结构和形式，就可以实现不同的运算。
负反馈的类型有：电压串联负反馈；电压并联负反馈；电流串联负反馈；电流并联负反馈。
反馈电路直接从输出端引出的，是电压反馈；从负载电阻靠近“地”端引出的，是电流反馈；（也可将输出端短路，若反馈量为零，则为电压反馈；若反馈量不为零，则为电流反馈。） 输入信号和反馈信号分别加在两个输入端，是串联反馈；加在同一输入端的是并联反馈；反馈信号使净输入信号减小的，是负反馈。
负反馈的对放大电路工作性能的影响：提高放大电路的稳定性；改善波形失真；
对输入电阻和输出电阻的影响：电压反馈使输出电阻降低；电流反馈使输出电阻增高；串联反馈使输入电阻增高；并联反馈使输入电阻降低。
实际应用中，线性放大时都需要引入负反馈：
四.同相与反相放大器 同相放大器
优点：输入阻抗和运放的输入阻抗相等，接近无穷大
缺点：放大电路没有虚地，因此有较大的共模电压，抗干扰能力相对较差，使用时要求运放有较高的共模抑制比，另一个小缺点就是放大倍数只能大于1；
反相放大器
优点：两个输入端电位始终近似为零（同相端接地，反相端虚地），只有差模信号，抗干扰能力强；
缺点：输入阻抗很小，等于信号到输入端的串联电阻的阻值。
由此可见，对比它们要在以下几个方面：输入输出阻抗，共模的抗干扰。
1、同相放大器的输入阻抗和运放的输入阻抗相等，接近无穷大，同相放大器的输入电阻取值大小不影响输入阻抗；而反相放大器的输入阻抗等于信号到输入端的串联电阻的阻值。因此当要求输入阻抗很高的时候就应选择同相放大器！
2、同相放大器的输入信号范围受运放的共模输入电压范围的限制，反相放大器则无此限制。因此如果要求输入阻抗不高且相位无要求时，首选反相放大，因为反相放大只存在差模信号，抗干扰能力强，可以得到更大的输入信号范围。
3、在设计中要求放大倍数相同的情况下尽量选择数值小的电阻配合，这样可以减小输入偏置电流的影响和分布电容的影响。如果很计较功耗，则要在电阻数值方面折中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9af87f1ca3726d7b808055a8f971851/" rel="bookmark">
			bootstrap-table 指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、初始化二、使用请求后接口数据三、行操作1. 请求完接口，前端过滤删除的row2. 请求完接口，前端手动修改row 四、总结1. 解决BUG: 开启sort后不显示箭头符号2. 监听每个cell点击事件3. 更新某cell数据4. 更新某行数据5. 自定义列样式6. 重新加载数据7. 显示或隐藏加载状态 bootstrap-table官方教程
为了有更好的代入感，所以先看截图
一、初始化 table.html
&lt;table id="table" data-mobile-responsive="false"&gt; table.js
(function() { init(); /// 初始化数据 $('#table').bootstrapTable({ search: true, /// 搜索 cache:false, /// 是否缓存 clickToSelect:true, /// 可点击 pageSize: 15, /// 每页数量 pageNumber: 1, /// 初始页 pagination: true, /// 分页 showToggle: true, /// 是否显示详细视图和列表视图的切换按钮 showColumns: true, /// 是否显示所有列 iconSize: 'outline', /// 自适应图标大小 toolbar: '#sliderToolbar', /// 绑定自定义bar icons: { refresh: 'glyphicon-repeat', /// 刷新按钮 toggle: 'glyphicon-list-alt', /// 切换视图按钮 columns: 'glyphicon-list' /// 选择列按钮 }, columns: [{ /// 所有列 field: 'id', /// 根据数据对应的字段 title: '编号', /// 显示的名称 align: 'center', /// 居中 sortable: true, /// 展示排序 }, { field: 'name', title: '名称', align: 'center' }, { field: 'cover', title: '图片', align: 'center', formatter:function(value,row,index){ /// 首先判断是否含有http，如果含有，则相应的渲染成图片 if(value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9af87f1ca3726d7b808055a8f971851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d26288d59bfc8a2f7e75e2f482efc4/" rel="bookmark">
			Java后端启航之大二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好🤝，我是👉老孙👈，一个不善于写作✍️却喜欢用博客记录人生的程序猿🙉，或许这是一件有意义又有趣的事⭐，不为别的，只想看看自己到低能走多远🌏，是怎么走远的 ⏰🏘️⛵
⭕ 上大学才明白的道理 ⭕ 经过两年的大学生活，渐渐地让我深刻的明白 自学能力 才是在大学学习中应该具备的最重要的技能；自学能力的强弱，很大程度上可以决定你以后能否在所学专业上走的更远。
大学老师一般不会像高中那样关注你的学习情况，只会在上课或开会时给你打打气，希望你努力学习，但这些被动的作用，并不会对你的学习起太大作用。要想在大学生活中学有所成必须主动出击，不懂的要多问、学会自学、实在解决不了的问题和想不明白的学业和人生问题要问老师、尽量和学习有上进心的人在一块、多思考多总结……
虽然学习的好方法多，但对于一个自控力差和学习底子差的人想要把一个好的方法真正运用在自己身上是十分困难的。需要学的东西很多、需要学的技能很多、需要养成的好习惯也很多……
我们不可能把这一切在短时间内都学会，我们只需跟着自己的和需求和梦想的脚步有选择性的进行下去，剩下的就交给时间去证明吧 ！！！
其实，这两年的大学生活过得很一般 - - - 机会总是留给有准备的人，因此措施了很多好的机会，比如没有参加编程比赛、没有与老师交流、没有向学长学姐交流过，没有找到一个志同道合的朋友……所以最终导致自己一个人在学习上摸索，找各种软件、视频、网站寻找学习方法和路线，经过一波三折，最终也算是选择一条大众路线，确定了要学习Java后端这条编程之路。
总之：没有等出来的美丽，只有拼出来的辉煌
⭕ 确定了要用Java拼搏人生 ⭕ 经过短短4个月的 期待已久的大学生活之大一上，度过大一下学期4个半月的 最长“假期”的网课生活之大一下，大一的生活就这样消逝而去，关于编程就学了一个C语言 😭 ；
还有，由于2019年1月突如其来的新冠病毒，从2020年1月初放寒假到9月初大二开学我整整在家待了8个月。
好在，全国人民团结一心，经过千辛万苦，基本上算是完全控制住了疫情 👍，终于可以不用在家上网课了 😄
2020年9月份大二开学偶然间在CSDN发动态聊天时找到一个一块学习Java后端的，十月一国庆节后开始学习Java后端知识，在B站开始看尚硅谷的JavaSE视频。其实刚刚开始也是被 717集 147h 15min 的视频 吓到了🙉，因为大二比较闲、课很少、疫情期间不能随便出校门，所以每天利用课外时间，平均每天学习5个小时，坚持了32天（没有预料到自己能坚持短时间学完），把JavaSE 视频看完了。👁️‍🗨️
由于学习过C语言，虽然Java大部分知识C语言没有学过，但是基础部分的原理C和Java还是大都一样的，总之学完JavaSE后让我对编程的兴趣又进一步加深了，原来Java能实现的功能真多、真酷、真难😲
接下来学习的知识都是断断续续的😅
然后过一段时间，花费了2个星期把 MySQL基础部分和JDBC 粗略学完。
大二上学期快放假到大二下学期开学断断续续把 javaweb 视频看完。
大二下学期就把《Java核心技术卷I 第10版》前半部分认真看完，后面一半内容去掉不需要学习的部分快速看了一遍，此书可以作为以后学习Java的参考书，但如果单独看这本书学习Java非常不适合新手看 ！
然后在大二快放假到大三开学前把 JavaEE 阶段的 SSM学完了。
🎯 总结 🎯
↪️ 看似在大二一年学习了很多东西，其实，现在回头一想除了知道自己学过的内容知识框架，简单的基础算是能看懂，难的部分看都看不懂！
➡️ 有人说可以先把Java后端整体的知识看视频大致过一遍，心中有先有一个整体知识框架。
➡️ 有人说一定要一步一个脚印，学那块知识就要把他完全弄懂。
➡️ 还有人说除了看视频，还要看书籍，还要多总结做笔记，还要多敲代码，还要要避免花大量时间盲目学习一些无用的东西。
……
🔄 在过去大二一整年独自一人对Java后端的学习过程中，效果确实很差，学习不系统，断断续续，没有写一份属于自己的完整知识点笔记，练的代码比较少等等。但是，也坚持写了66篇博客，对Java后端有了更多的认知，学会了很多优秀的办公工具，收藏了很多优秀的文章和学习网站……
🔄 其实，我目前的观点认为最最最重要的还是学习投入的时间比较少，如果花费大量时间真心投入到学习中，其实上面的这些问题都不是大问题，随着反复的练习都会迎刃而解 ！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d26288d59bfc8a2f7e75e2f482efc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b169ff617d19f852a8b69697020e7161/" rel="bookmark">
			streamlit之开始运行与终止运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在已经安装了所有必要的软件，让我们创建一个新的Python脚本并导入Streamlit。
创建文件first_app.py，然后在你的IDE或文本编辑器中打开接下来导入Streamlit import streamlit as st #To make things easier later, we're also importing numpy and pandas for #working with sample data. import numpy import pandas 运行应用，这会在你的默认浏览器中开启一个新的tab页。目前还是一篇空白，不过没关系。
$ streamlit run first_app.py 运行Streamlit应用和运行其他Python脚本没有区别。任何时候当你需要查看应用 的界面效果时，都可以使用这个命令。
提示：
你知道吗？你也可以丢给streamlit run一个URL让它来启动应用！当你使用Github Gists时这 会感觉很爽。例如：
$ streamlit run https://raw.githubusercontent.com/streamlit/demo-uber-nyc-pickups/master/app.py 任何时候你都可以使用ctrl+c来终止streamlit应用的运行。
原文地址：http://cw.hubwiz.com/card/c/streamlit-manual/1/2/3/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13fbd8a1fe27dfaec07dc57fd77c1c40/" rel="bookmark">
			阿里云、腾讯云、百度云、华为云哪家的性能最好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前做个一项测试，测试的主要是同等配置、同等规格云服务器，相对公平的情况下测试进行的。
下面为具体配置：
阿里云：1核心CPU 、2 GB 内存、 1M的网络(ecs.s6-c1m2.small 1Mbps )，服务器位置在杭州 I 区, 操作系统为 Debian 10。 腾讯云：1核心CPU、 2GB内存、 1M 的网络，操作系统为 Debian 10 华为云：1核心 CPU 、2GB 内存 、1M的网络（通用计算型 | s6.medium.2 ），服务器所在的位置为 北京四 可用区2，操作系统为 Debian 10。 百度云：2核心CPU、2GB内存、1M的网络（密集计算型ic4）操作系统为 Debian 10。 CPU
从结果上看，CPU最差的就是百度云了（其实差距很小），稳定性最好的当属阿里云，这一点也不让我意外（因为百度云不是最擅长硬件，也不是最有资本优势的）。
通过测评结果显示，这四家的CPU稳定性其实差不多，都是实力雄厚的厂商。
从结果上看，这四家的CPU计算稳定性都不差，毕竟都是有雄厚技术支持的厂家。
内存性能
内存最好的就是华为云，这可能跟华为云硬件优势有关。
磁盘性能
磁盘性能最好的还是腾讯云，其次是阿里云。
中国大陆延迟：
实际上网络还是阿里云偏好一点，但是差距都很小，在 10 ms 之内，这几家差距不大。
其它地区延迟：
国际网络也都相差不多（相比较国内网络而言都不好，受大环境的影响，这也不是云平台可以控制的），其中 腾讯云、阿里云的路由很奇怪，Traceroute 的时候会先绕到美国，然后在绕回私有地址。
网络速度
国内上传速度最好的居然是百度云、华为云（进步还是很快的），国内下载速度最好的是阿里云（毕竟阿里云是国内最大的公有云平台，也是第一家实现盈利的云计算厂商）。
海外速度大家可能都是一样的慢（不过腾讯云海外网络速度最佳，有可能和腾讯云在全球游戏业务扩展有关，为此腾讯云还专门拉了一条海底光缆）。
不仅仅是云服务器性能，也要考虑成本，最后落在性价比之上。先说下官网报价成本吧，最值得关注的是官网给出的活动。
今年国内阿里云也好，腾讯云、华为云也罢都像商量好的一样，都给出秒杀活动，有木有感觉现在的云平台也在学直播带货的营销策略，不过价格来说，确实要比平时便宜不少。
聊完这些，那么该选择哪家的云服务器呢？
主流云平台例如阿里云、腾讯云的活动机在安全性、稳定性、易用性及高性价比等方面都占据绝对的优势，是上云的最佳选择。
国内云服务器性能和配置对比参阅：【云服务器推荐】腾讯云、阿里云、华为云服务器价格和配置评测
云服务器作为承载业务的核心产品，具有耐操、低价、升级方便等优质特性，适合脑洞大开的个人开发者和学生使劲造，也适合初创公司转型升级。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482169877134cd2639d62055a131560f/" rel="bookmark">
			【WIN10】此用户无法登录，因为该账户当前已被禁用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 系统：WIN10x64
问题 远程登录共享服务器，弹出如下对话框。
无法输入账号和密码。
解决方法 1、进入 控制面板\凭据管理器\Windows凭据 面板。
2、删除对应凭据。
3、重新登录即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3032306fb6183040241a1ac2a816c19/" rel="bookmark">
			nginx 限流配置是如何做到的?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		限流算法 1、令牌桶算法
算法思想是：
令牌以固定速率产生，并缓存到令牌桶中； 令牌桶放满时，多余的令牌被丢弃； 请求要消耗等比例的令牌才能被处理； 令牌不够时，请求被缓存。 2、漏桶算法
算法思想是：
水（请求）从上方倒入水桶，从水桶下方流出（被处理）； 来不及流出的水存在水桶中（缓冲），以固定速率流出； 水桶满后水溢出（丢弃）。
这个算法的核心是：缓存请求、匀速处理、多余的请求直接丢弃。
相比漏桶算法，令牌桶算法不同之处在于它不但有一只“桶”，还有个队列，这个桶是用来存放令牌的，队列才是用来存放请求的。
从作用上来说，漏桶和令牌桶算法最明显的区别就是是否允许突发流量(burst)的处理，漏桶算法能够强行限制数据的实时传输（处理）速率，对突发流量不做额外处理；而令牌桶算法能够在限制数据的平均传输速率的同时允许某种程度的突发传输。
Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阈值。
Nginx官方版本限制IP的连接和并发分别有两个模块：
limit_req_zone 用来限制单位时间内的请求数，即速率限制,采用的漏桶算法 “leaky bucket”。
limit_req_conn 用来限制同一时间连接数，即并发限制。
3、nginx参数配置
limit_req_zone 参数配置
Syntax:	limit_req zone=name [burst=number] [nodelay]; Default:	— Context:	http, server, location 第一个参数：$binary_remote_addr 表示通过remote_addr这个标识来做限制，“binary_”的目的是缩写内存占用量，是限制同一客户端ip地址。
第二个参数：zone=one:10m表示生成一个大小为10M，名字为one的内存区域，用来存储访问的频次信息。
第三个参数：rate=1r/s表示允许相同标识的客户端的访问频次，这里限制的是每秒1次，还可以有比如30r/m的。
limit_req zone=one burst=5 nodelay;
第一个参数：zone=one 设置使用哪个配置区域来做限制，与上面limit_req_zone 里的name对应。
第二个参数：burst=5，重点说明一下这个配置，burst爆发的意思，这个配置的意思是设置一个大小为5的缓冲区当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内。
第三个参数：nodelay，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回503，如果没有设置，则所有请求会等待排队。
eg:
http { limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; server { location /search/ { limit_req zone=one burst=5 nodelay; } } 当服务器由于limit被限速或缓存时，配置写入日志。延迟的记录比拒绝的记录低一个级别。例子：limit_req_log_level notice延迟的的基本是info。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3032306fb6183040241a1ac2a816c19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e3b503bd770ae702a4ddcca23e39de1/" rel="bookmark">
			基于51单片机的LED显示（静态和动态显示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在51单片机上的LED显示屏上显示（很适合初学者）
LED显示器静态显示
第一个LED显示器显示字符“b"
#include&lt;reg52.h&gt;
#define duan P0
sbit wei1=P2^4;
sbit wei2=P2^5;
sbit wei3=P2^6;
sbit wei4=P2^7;
void mian()
{
wei1=1;
wei2=0;
wei3=0;
wei4=0;
duan=0x7c;
while(1);
}
LED显示器动态显示
在4位一体LED显示器左数第4位显示4，过1s，在左数第3位显示3，过1s，在左数第2位显示2，过1s，在左数第1位显示1，上述过程不断循环。
#include&lt;reg52.h&gt;
#define duan P0
#define uchar unsigned char
sbit wei1=P2^4;
sbit wei2=P2^5;
sbit wei3=P2^6;
sbit wei4=P2^7;
uchar code sz[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00};
void delay(unsigned int xms)
{
unsigned int i,j;
for(i=xms;i&gt;0;i--)
for(j=112;j&gt;0;j--);
}
void main()
{
while(1)
{
duan=sz[4];
wei1=0;
wei2=0;
wei3=0;
wei4=1;
delay(1000);
duan=sz[3];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e3b503bd770ae702a4ddcca23e39de1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f709a7b126e3dc4e5dddf85b315cae0a/" rel="bookmark">
			SpringMVC总复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC课堂笔记1、SpringMVC概述 SpringMVC概念 SpringMVC 也叫 Spring web mvc。是 Spring内置的一个MVC框架，在 Spring3.0 后发布。SpringMVC 框架解决了WEB开发中常见的问题(参数接收、文件上传、表单验证等等)，而且使用简单，与Spring无缝集成。支持 RESTful风格的URL请求。采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。
SpringMVC原理 在没有使用SpringMVC之前我们都是使用Servlet在做Web开发。但是使用Servlet开发在接收请求参数， 数据共享，页面跳转等操作相对比较复杂。servlet是java进行web开发的标准，既然springMVC是对servlet的封装，那么很显然SpringMVC底层就是Servlet，SpringMVC就是对Servlet进行深层次的封 装。
SpringMVC优势 1、基于 MVC 架构，功能分工明确。解决页面代码和后台代码的分离。
2、简单易用。SpringMVC 也是轻量级的，jar 很小。不依赖的特定的接口和类就可以开发一个注解的
SpringMVC 项目。
3、作 为 Spring 框 架 一 部 分 ， 能 够 使 用Spring的IoC和AOP 。 方 便 整 合MyBatis,Hiberate,JPA等其他框架。
4、springMVC的注解强大易用。
2、MVC模式回顾
模型1：jsp+javabean模型—在jsp页面中嵌入大量的java代码
模型2：jsp+servlet+javabean模型—jsp页面将请求发送给servlet，由servlet调用javabean，再 由servlet将制定jsp页面响应给用户。
模型2一般就是现在的MVC模式，也是我们一直使用的。
Model-View-Controller：模型–视图–控制器
Model： 模型层 javaBean 负责数据访问和业务处理 dao service pojo View： 视图 JSP技术 负责收集和展示数据
Controller： 控制器 servlet技术 中间调度控制器的工作：
1、接受客户端的请求（包括请求中携带的数据）
2、处理请求：调用后台的模型层中的业务逻辑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f709a7b126e3dc4e5dddf85b315cae0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a942948c3cb8fb56106ed59ea565b8/" rel="bookmark">
			深入char类型及scanf()和printf()的一些特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		char类型数组的定义方式：
例如：char name[40];
C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中。数组由连续的存储单元组成，字符串中的字符被存储在相邻的存储单元中，每个单元存储一个字符。
如何给char赋值？
例：scanf("%s",name);
为什么这里不需要“&amp;”？
C语言规定，字符串变量就表示这个字符串存储的首地址，并且由于是连续存储，所以知道了首地址就知道只能存了，因此读取字符串时，就不需要取地址了，本身它就代表地址。详情请戳这里。
目前还未涉及到指针内容，在这里也可以简单的记一下：
如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;
如果用scanf()把字符串读入字符数组中，不要使用&amp;
printf()转换说明及其打印的输出结果
%a
浮点数、十六进制数和p 记数法（C99/C11）
%A
浮点数、十六进制数和p 记数法（C99/C11）
%c
单个字符
%d
有符号十进制整数
%e
浮点数，e记数法
%E
浮点数，e记数法
%f
浮点数，十进制记数法
%g
根据值的不同，自动选择%f 或%e。%e 格式用于指数小于-4 或者大于或等于精度时
%G
根据值的不同，自动选择%f或%E。%E 格式用于指数小于-4 或者大于或等于精度时
%i
有符号十进制整数（与%d相同）
%o
无符号八进制整数
%p
指针
%s
字符串
%u
无符号十进制整数
%x
无符号十六进制整数，使用十六进制数0f
%X
无符号十六进制整数，使用十六进制数0F
%%
打印一个百分号
printf()和scanf()的修饰符*
首先来看printf()
例如：printf("%*d",width,num);
*在d的前面，所以width在num的前面
再如printf("%*.*d",width,precision,weight)
width和precision提供打印weight的格式化信息
（后续内容会详细说明其意义）
此修饰符可用于：在不同位置（实现前未知）打印指定内容
再来看scanf()
scanf()中*的用法与此不同。把*放在%和转换字符之间时，会使得scanf()跳过相应的输入项。
例如：scanf("%*d %*d %d",&amp;n);
scanf()指示：跳过两个整数，把第3个整数拷贝给n
此修饰符可用于：用户输入三个数，程序选取其中的数进行接下来的实现。
printf()中的标记
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a942948c3cb8fb56106ed59ea565b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582996909f94c702a9b1647ac1d79dcc/" rel="bookmark">
			idea中导入数据库步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在🔍处输入“database”
选择导入后moudel存放的路径
over！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b330e0adf85bc647a2a85bfc65f9568f/" rel="bookmark">
			c&#43;&#43; vector 内存布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上代码 int main() { vector&lt;int&gt; arr = {1, 2, 3, 4}; int* start = (int*)(*((long long*)&amp;arr)); int* end = (int*)(*((long long*)&amp;arr)) + arr.size(); while(start != end) { cout &lt;&lt; start &lt;&lt; "\t" &lt;&lt;*start &lt;&lt; endl; ++start; } cout &lt;&lt; endl; auto x = arr.begin(); auto y = arr.end(); while(x != y) { cout &lt;&lt; &amp;(*x) &lt;&lt; "\t" &lt;&lt; *x &lt;&lt; endl; x++; } } 输出 vector 有内部有两个指针，start, end
指向一块连续的内存，这块内存是真正存储数据的地方
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b330e0adf85bc647a2a85bfc65f9568f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab552779a35337067fa220d0a43e52f8/" rel="bookmark">
			qinglong青龙面板使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：获取cookie
谷歌浏览器打开 https://m.jd.com/ 京东网址，点击我的, 会有登陆界面，直接登陆。（用密码登陆，可能需要验证码验证，但不要直接用手机验证码登陆）
或者 谷歌浏览器打开https://bean.m.jd.com/bean/signIndex.action
登陆完后，按 f12，进入network页，刷新一下，选中第一个地址newhome……，右侧点击Headers，找到下面cookie，复制出来。
然后在cookie中找到“pt_key=……;pt_pin=……;”复制出来。
然后打开青龙面板，环境变量，添加变量，名称一定要填写JD_COOKIE，值填写上一步复制的内容，备注可以填写这是谁的账号，可以添加多个账号，但名称都必须是JD_COOKIE。添加多个账号的另一个方法：集合在一个环境变量下，多个 cookie 用 &amp; 隔开。(获取不同账号cookie时，要用不同浏览器)
添加了账号和脚本了，可以运行一个脚本试试。随便点击一个脚本右侧的运行，然后点击运行右侧的日志，查看运行情况：
可以看到你绑定的京东账号已经识别了，已经开始执行脚本了，但是有些京东活动是需要去京东app手动开启活动的。这就需要你多关注这些执行日志，配合去app进行某些操作，才能最大化获取京豆。如果你想最大化获取京豆，可以在运行2天之后，进入日志中查看每个脚本的运行日志，看那些脚本需要你手动打开app中的某些服务，然后你配合操作就行，剩下的就交给脚本吧。
其他资源整理
**青龙拉取常用京东脚本库**
新手推荐使用Faker集合仓库，集合仓库内包含本文内所有作者可用脚本，并不断更新。
2021-7-7 16:00更新 原址：https://www.notion.so/da5099068a434e29920cdcb3e7af4410
青龙拉取常用京东脚本库 国内代理 https://ghproxy.com/ 【Faker集合仓库】 ql repo https://ghproxy.com/https://github.com/shufflewzc/faker2.git "jd_|jx_|getJDCookie" "activity|backUp" "^jd[^_]|USER|ZooFaker_Necklace" 【Faker仓库依赖库修复】SSH运行：docker exec -it QL bash -c "apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev &amp;&amp; cd scripts &amp;&amp; npm install canvas --build-from-source" 【curtinlv仓库】 ql repo https://github.com/curtinlv/JD-Script.git 【star】 ql repo https://github.com/star261/jd.git "scripts" "code" 【lxk0301】已私有，以下链接为备份库。柠檬代维护库。 ql repo https://github.com/shufflewzc/jd_scripts-2.git "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab552779a35337067fa220d0a43e52f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3869c4145c847a98966f0e395ba5db71/" rel="bookmark">
			Windows没有MySQL服务及MySQL无法启动解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载MySQL并把MySQL的路径配置到系统环境后执行命令：mysql -u root -p 报错：ERROR 2003 (HY000): Can't connect to MySQL server on 'localhost' (10061)
猜测原因可能是windows没有mysql服务或mysql服务没有启动，这篇文章主要讲windows没有mysql服务的情况下的解决办法【因为我的是这个原因~~】
一：查看windows有没有MySQL服务：在左下角输入‘计算机管理’，点击打开，在‘服务和应用程序’——‘服务’下查看是否有‘MySQL’服务。 二：没有MySQL服务，用管理员权限打开黑窗口，执行命令：mysqld -install 【由于我已经安装成功了，所以会报这句，记不清具体会返回什么语句了，反正只要成功就对】
注意注意：一定要用管理员权限！！！否则会报错：Install/Remove of the Service Denied!
用管理员权限打开黑窗口的方式如图 ​​​​​​
三：开启MySQL服务。 方式一：在步骤一中的‘服务’里找到MySQL服务，右键选择启动。
方式二：管理员权限打开黑窗口，执行命令：net start mysql
如果成功开启，那么恭喜你结束了苦逼的bug修复之路；如果报错，那么恭喜你解锁了新的bug，希望下面的方法能够帮助到你~~
四：管理员权限打开黑窗口，执行命令：mysqld --initialize 五：关闭黑窗口，管理员权限打开黑窗口，执行命令：net start mysql，启动成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149cc276c463da41bbd3cfde56765f36/" rel="bookmark">
			微信小程序自动连接蓝牙电子秤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同品牌的称，只需要打印下方函数返回值，根据自己需要做处理就可以了。
wx.onBLECharacteristicValueChange(function (res) { let receiverText = that.buf2string(res.value); } 第一次连接需要手动配置，然后把所需参数(deviceId)保存到storage中，方便下次自动连接。
App({ globalData: { serviceId: '', characteristicId: '', deviceId: '', // 已连接蓝牙的设备ID BluetoothState: false, // 蓝牙适配器状态 connectState: false, // 蓝牙连接状态, weight: 0, // 重量 }, onLaunch: function () { // 设置初始重量为0 wx.setStorageSync('weight', 0) }, onShow() { // 读取本地数据，实现蓝牙自动连接 let deviceId = wx.getStorageSync('deviceId') || [] if(deviceId){ this.globalData.deviceId = deviceId this.initBlue() } else { wx.showToast({ title: '蓝牙未连接', icon: 'error', duration: 3000, }) } }, // 初始化蓝牙 initBlue(){ var that = this; wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/149cc276c463da41bbd3cfde56765f36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf314e8248524903983d7ba91871b3f/" rel="bookmark">
			垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在进行GC资源清除之前，首先要确认对象是否死亡，针对判断死亡与否，在Java用到了可达性分析的方法，通过GC Roots向下搜索，如果没有搜索到。则认为该对象不会再使用，可回收。
GC Roots一般包括虚拟机栈中引用的方法，本地方法区静态实体引用的对象，方法区常量引用的对象
在Java中引用可达性分析，而在python中不仅使用到了可达性分析，还使用到了引用计数，每一个对象都有一个引用计数的属性，每当新增一个引用时，计数＋1，每当释放一个引用，计数-1，当计数为0，则认为可以被GC
2.GC机制中用到了几种算法，以下介绍最主要的四种算法
①：标记-清除算法：
给每个对象储存一个标记位，记录每个对象的状态，，分别分了两个阶段，第一个阶段就是动态的更新对象的状态，确认对象是否存活，第二个阶段就对状态为死亡的对象进行GC，它仅仅是对死亡的对象进行去除，会导致出现大量内存碎片，直接导致内存的一个浪费。
②：标记-整理算法：
标记整理是在标记清理做的优化，针对标记为存活的对象进行整理，类似于顺序表中间删除元素，将存活的元素整理到一起，减少了内存碎片的产生，但是整理降低了性能
③：复制算法：
复制算法是将内存划分为两个部分，每次放入引用仅放在一个部分，当GC时，将标记为存活的对象复制到另一个区域中，然后删除原来区域中的所有对象，依次循环刚刚的操作，对象在两个区域中来回切换，也因此内存减少了一半
④：分代收集算法：
在JVM中，虚拟机栈，程序计数器和本地方法栈都是随线程的生命周期生存和灭亡，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动内存清理操作，所以GC主要集中于Java堆和方法区，而分代收集就主要用于JVM的堆和方法区
将对象的生命周期划分为两个部分，新生代和老年代
新生代又分为伊甸区和幸存区（幸存区包含from和to两个部分）
当新生代触发Younger GC,首先在伊甸区进行GC，GC的存活对象进入幸存区，在幸存区两个部分进行复制算法，GC一定次数后，进入老年代，进入老年代
在老年代也会发生定期的GC，一般当老年代满了，或者方法区满了，或者显性调用System.gc（）会触法Full GC
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210807ad6c68a221ff07614c6b554e31/" rel="bookmark">
			VHH免疫测序数据分析1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目的简介工具实操1.质控2.修剪3.合并双端reads4.DNA level 计数5.igblast6.根据igblast结果统计unique protein 然后根据CDR3聚类并统计unique cluster7.脚本8.最后 目的简介 根据VHH噬菌体展示筛选结果建库测序（PE300），初步分析结果如下：
1、拼接reads，得到contigs，然后统计unique contig的数量
2、注释拼接得到的contigs得到framework区和CDR区
3、分类形成clonotype：V&amp;J reference gene相同，CDR3长度相同，且相似度高于80%
4、根据上述注释信息统计clonotype count对应的unique contig count 、unique protein count 等等信息
工具 igblastcd-hitpandas 实操 1.质控 mkdir Fastqc ls | grep "fq.gz$" |while read id ;do (fastqc -q -t 16 -o ./Fastqc $id );done &amp; mkdir multiqc multiqc ./ -o ./multiqc #3'端碱基质量有些较差，准备把低于20的碱基及其之后的序列修剪掉 2.修剪 ls |grep "R1_001" &gt; R1.txt ls |grep "R2_001" &gt; R2.txt paste R1.txt R2.txt &gt; list.txt mkdir trim &amp;&amp; cd trim cat .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/210807ad6c68a221ff07614c6b554e31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce40ec2a00148599ae538833eeb37a89/" rel="bookmark">
			OpenLayers源码解析7 ol/layer/Vector.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ol/layer/Vector.js 父类 ol/layer/BaseVectorLayer-BaseVectorLayer
主要功能 渲染矢量图层。
任意设置的属性将被设置为基础属性，可以进行get/set。
参数：VectorLayer({}) 参数类型说明visibleboolean (defaults to true)是否可见，默认可见zIndexnumber图层渲染的层级，若未指定则按加入layers的顺序显示，若使用setMap则为无限大source*module:ol/source/VectorVectorSource&lt;br/&gt;module:ol/source/VectorTileVectorTile数据源propertiesObject.&lt;string, *&gt;任意属性，可以用get() 和 set()访问。 方法 /** * @module ol/layer/Vector */ import BaseVectorLayer from './BaseVector.js'; import CanvasVectorLayerRenderer from '../renderer/canvas/VectorLayer.js'; /** * @classdesc * Vector data that is rendered client-side. * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject} * property on the layer object; for example, setting `title: 'My Title'` in the * options means that `title` is observable, and has get/set accessors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce40ec2a00148599ae538833eeb37a89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c82be46ad2daa7646b7a030102e25fd/" rel="bookmark">
			OpenLayers源码解析6 ol/source/Vector.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ol/source/Vector.js 父类 ol/source/Source-Source
主要功能 提供矢量图层数据源。
该数据源提供的矢量要素可被编辑。
参数：VectorSource({}) 参数类型说明formatmodule:ol/format/Feature~FeatureFormat若设置了url参数，则需指定要素格式format。如new ol.format.GeoJSON()urlstring
module:ol/featureloader~FeatureUrlFunction使用XHR加载要素，需要提供formatwrapXboolean (defaults to true)水平环绕世界。要使跨-180°和180°子午线的矢量编辑正常工作，应将其设置为false。生成的几何体坐标将超出世界边界。 方法 函数名参数源码返回值类型功能forEachFeatureIntersectingExtent(extent, callback)extent module:ol/extent~Extent Extent.
callback function 每个feature调用的回调函数source/Vector.js, line 630{Tundefined} /** * @module ol/source/Vector */ import Collection from '../Collection.js'; import CollectionEventType from '../CollectionEventType.js'; import Event from '../events/Event.js'; import EventType from '../events/EventType.js'; import ObjectEventType from '../ObjectEventType.js'; import RBush from '../structs/RBush.js'; import Source from './Source.js'; import SourceState from './State.js'; import VectorEventType from './VectorEventType.js'; import {TRUE, VOID} from '../functions.js'; import {all as allStrategy} from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c82be46ad2daa7646b7a030102e25fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b536ae502fa48b339c43d3b74e676f/" rel="bookmark">
			CUDA编程(三) —— 编程实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 将两个元素数目为1024×1024的float数组相加 首先我们思考一下如果只用CPU我们怎么串行完成这个任务
#include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;sys/time.h&gt; #include &lt;math.h&gt; using namespace std; int main() { struct timeval start, end; gettimeofday( &amp;start, NULL ); float*A, *B, *C; int n = 1024 * 1024; int size = n * sizeof(float); A = (float*)malloc(size); B = (float*)malloc(size); C = (float*)malloc(size); for(int i=0;i&lt;n;i++) { A[i] = 90.0; B[i] = 10.0; } for(int i=0;i&lt;n;i++) { C[i] = A[i] + B[i]; } float max_error = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b536ae502fa48b339c43d3b74e676f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add270a7c9d7f6aba2debc74f4a2c532/" rel="bookmark">
			一些配置文件所在地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		obs经典版配置文件在
C:\Users\Administrator\AppData\Roaming
其中appdata是隐藏文件夹
------------------------------------------------------
myeclipse配置文件在其工作空间中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3b03f9177723518710a01cecaa42fd8/" rel="bookmark">
			【详细步骤】Ubuntu安装Samba服务及配置共享文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux和Windows直接使用共享文件，有多爽谁用谁知道。
步骤：
0.确保软件安装源可用 1.安装samba 输入密码后等待安装完成
sudo apt-get install samba samba-common 2.创建一个共享文件夹，并设置777权限 nanshou是我的用户名
mkdir /home/nanshou/share sudo chmod 777 /home/nanshou/share 3.添加用户及密码 指令：sudo smbpasswd -a [用户名]
比如我的用户名nanshou
sudo smbpasswd -a nanshou 输入密码，密码会输入俩次。
4.修改配置文件 sudo vi /etc/samba/smb.conf 在配置文件的最后添加如下：
在这里插入图片描述
[share] comment = share folder browseable = yes path = /home/nanshou/share create mask = 0700 directory mask = 0700 valid users = nanshou force user = nanshou force group = nanshou public = yes available = yes writable = yes 其中nanshou，仍为我的用户名信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3b03f9177723518710a01cecaa42fd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e164f6c0be601d9d1be791f18da57f6/" rel="bookmark">
			vs code报错 检测到 #include 错误。请更新 includePath。和 g&#43;&#43; : 无法将“g&#43;&#43;”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于检测到 #include 错误。请更新 includePath的报错 在写c++代码的时候，无法包含iostream头文件，同时有报错提示如下
解决办法 1、下载mingw64 官方下载地址
具体可参考
首先需要在vs code中打开一个文件夹，什么文件夹都可以，最好是自己新建一个新的文件夹用来存放自己的代码，如果没有打开文件夹，IDE也会提示你打开一个文件夹以设置属性
然后在vs code里面按下ctrl+shift+p搜索json
按下enter后会打开c_cpp_propertities.json文件，把自己的编译路径添加进去，即添加一句代码：“compilerPath”: “D:\Program Files\Microsoft VS Code\MinGW64\bin\gcc.exe”,注意是自己下载解压后的mingw64\bin，自己在电脑中复制进去即可，注意需要在后面加上gcc.exe
我把我的改好的代码放在下面：
{ "configurations": [ { "name": "Win32", "includePath": [ "${workspaceFolder}/**" ], "defines": [ "_DEBUG", "UNICODE", "_UNICODE" ], "compilerPath": "D:\\Program Files\\Microsoft VS Code\\MinGW64\\bin\\gcc.exe", "cStandard": "c17", "cppStandard": "c++17", "intelliSenseMode": "clang-x64" // "intelliSenseMode": "windows-msvc-x64" } ], "version": 4 } 然后这个问题解决了
g++ : 无法将“g++”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。 如果安装vs code后没有配置环境，那么会出现下面的报错
需要将自己安装mingw64\bin的路径配置到环境变量中去，方法如下
然后如果还有报错，关掉vs code重启一下！！！！
再重新运行代码就可以了
参考文献：
https://blog.csdn.net/iningwei/article/details/101649090
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b0e8601bc43d209ed49885795fe9a0/" rel="bookmark">
			E: 无法定位软件包:nvidia-470(核显&#43;独显安装ubuntu操作说明)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E: 无法定位软件包
发生这个问题有以下几种情况：
第一 ，你的ubuntu系统需要更新，用以下命令： sudo apt-get update
第二，你的系统软件需要升级，用以下命令：sudo apt-get upgrade
第三，你要安装的软件版本，与ubuntu版本不对应，此种情况，你需要自己阅读要安装软件的安装文档，查找问题。
这里我使用的是
sudo apt-get upgrade 进行解决的问题
当外接显示屏无法连接或者屏幕无法调节亮度的时候，需要进行操作
sudo add-apt-repository ppa:graphics-drivers/ppa sudo add-apt-repository ppa:xorg-edgers/ppa sudo apt-get install nvidia-470 nvidia-settings nvidia-prime 最后发现，如果内容之中加上了server，就能够成功地安装了
sudo apt-get install nvidia-driver-470-server nvidia-settings nvidia-profiler 观察发现，这里安装的是(470.57.02-0ubuntu0.20.04.3) .对应的内容
总结套路：首先安装470.57.02的对应驱动，然后安装nvidia-driver-470-server的对应软件包
装显卡驱动的内容也可以通过如下操作实现
添加Graphic Drivers PPA
sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update 查看合适的驱动版本：
ubuntu-drivers devices 对驱动进行安装‘
sudo apt-get install nvidia-driver-470 双显卡进行切换
总结：先进行正常安装，安装完成之后如果屏幕无法打开进行安装nvidia-settings nvidia-profiler，然后进行显卡切换切换到intel的显卡之中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ffd77b64ebf53c49672884e7b8ed4c6/" rel="bookmark">
			ACL匹配规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ACL - 访问控制列表 前言 ACL: Access Control List, 访问控制列表 ACL是一种技术，不是一种协议
ACL就是第一代防火墙技术
ACL是由一系列规则组成的集合。设备可以通过这些规则对数据包进行分类，并对不同类型的报文进行不同的处理。
本示例中，网关RTA允许192.168.1.0/24中的主机可以访问外网，也就是Internet；而192.168.2.0/24中的主机则被禁止访问Internet。对于服务器A而言，情况则相反。网关允许192.168.2.0/24中的主机访问服务器A，但却禁止192.168.1.0/24中的主机访问服务器A。
设备可以依据ACL中定义的条件（例如源IP地址）来匹配入方向的数据，并对匹配了条件的数据执行相应的动作。在本示例所述场景中，RTA依据所定义的ACL而匹配到的感兴趣流量来自192.168.2.0/24网络，RTA会对这些感兴趣流量进行加密（虚拟局域网VPN中会进行介绍）之后再转发。
ACL工作原理 ACL由一条或多条规则组成每条规则必须选择动作：允许或拒绝每条规则都有一个id序列号（默认=5，间隔=5）序列号越小越先进行匹配只要有一条规则和报文匹配，就停止查找，称为命中规则查找完所有规则，如果没有符合条件的规则，称为未命中规则ACL创建后，必须将其应用到某个接口或其他技术内才会生效应用在接口是必须选择方向：入站或出站(相对设备来判断)不能过滤由设备自己产生数据 ACL规则 一个ACL可以由多条“deny | permit”语句组成，每一条语句描述了一条规则。设备收到数据流量后，会逐条匹配ACL规则，看其是否匹配。如果不匹配，则匹配下一条。一旦找到一条匹配的规则，则执行规则中定义的动作，并不再继续与后续规则进行匹配。如果找不到匹配的规则，则设备不对报文进行任何处理。需要注意的是，ACL中定义的这些规则可能存在重复或矛盾的地方。规则的匹配顺序决定了规则的优先级，ACL通过设置规则的优先级来处理规则之间重复或矛盾的情形。
ARG3系列路由器支持两种匹配顺序：配置顺序和自动排序。
配置顺序按ACL规则编号（rule-id）从小到大的顺序进行匹配。设备会在创建ACL的过程中自动为每一条规则分配一个编号，规则编号决定了规则被匹配的顺序。例如，如果将步长设定为5，则规则编号将按照5、10、15…这样的规律自动分配。如果步长设定为2，则规则编号将按照2、4、6、8…这样的规律自动分配。通过设置步长，使规则之间留有一定的空间，用户可以在已存在的两个规则之间插入新的规则。路由器匹配规则时默认采用配置顺序。另外，ARG3系列路由器默认规则编号的步长是5。
自动排序使用“深度优先”的原则进行匹配，即根据规则的精确度排序。
本示例中，RTA收到了来自两个网络的报文。默认情况下，RTA会依据ACL的配置顺序来匹配这些报文。网络172.16.0.0/24发送的数据流量将被RTA上配置的ACL2000的规则15匹配，因此会被拒绝。而来自网络172.17.0.0/24的报文不能匹配访问控制列表中的任何规则，因此RTA对报文不做任何处理，而是正常转发。
ACL分类 数字型 acl:
​ acl number 数字
命名型 acl:
​ acl name 名称 编号，创建命名型acl时，默认就是高级acl
根据不同的划分规则，ACL可以有不同的分类。最常见的三种分类是基本ACL、高级ACL和二层ACL。
基本ACL可以使用报文的源IP地址、分片标记和时间段信息来匹配报文，其编号取值范围是2000-2999。
高级ACL可以使用报文的源/目的IP地址、源/目的端口号以及协议类型等信息来匹配报文。高级ACL可以定义比基本ACL更准确、更丰富、更灵活的规则，其编号取值范围是3000-3999。
二层ACL可以使用源/目的MAC地址以及二层协议类型等二层信息来匹配报文，其编号取值范围是4000-4999。
这里还有一种acl 5000-5999 这是用户自定义类型的acl 这里边匹配的规则随意搭配
在ACL中没有写的规则就是any
掩码、反掩码、通配符的区别 ACL配置 acl [编号] 创建一个acl
rule [序列号] deny/permit [source] 192.186.1.0 0.0.0.255[通配符] 配置ACL的规则：允许或拒绝源地址为192.169.1.0/24网段内所有的流量
rule [序列号] den/permit tcp source 192.168.1.0 0.0.0.255 destination 8.8.8.8 0 destination-port eq 80 配置ACL规则：允许或拒绝源地址为192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ffd77b64ebf53c49672884e7b8ed4c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a1cbc141409baf6b0cf2149d60031a9/" rel="bookmark">
			我的AI之路(55)--如何获取kinetics数据集和如何制作自己的kinetics数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近来做行为动作识别，根据近两年的CVPR、ICCV、ECCV论文实验了一序列的动作识别方面的模型，很多都用到了kinetics数据集或者something-something数据集，但是后者的官网目前已经关闭了(可能是因为上月bn20被高通收购了的原因)，所以只好依赖于kinetics数据集了，但是网上没有看到有人把kinetics数据集如何使用说清楚了，只好自己花了点时间看这个数据集的内容以及翻看了多个相关动作识别模型加载kinetics数据集的代码，看是如何做data loading的，做下记录也供分享。
Kinetics序列数据集是行为动作识别的标杆数据集之一,所谓的benchmark嘛，视频的总量也十分庞大,仅kinetics400就有100多G的视频，官网https://deepmind.com/research/open-source/kinetics上只给出了csv和json格式的标注文件，例如，下载kinetics400.tar.gz解开看到的是这些文件:
打开train.csv看到的内容是这样的：
这里面label,youtube_id,time_start,time_end,split分别指类别、视频在油管上的唯一id，该类动作内容(每个动作内容时长10秒)在视频里的起始时间和终止时间，所属的数据集划分(train/val/test)，按正常的流程，就是使用此数据集的模型训练代码要自行实现视频数据下载的脚本，在训练前解析train.csv后读取各个youtube_id然后从油管上下载视频，并将文件按以下形式命名:
$(youtube_id)_$(timestamp_start)_$(timestamp_end).mp4
并创建400个(对于kinetics600/700/以及kinetics-moments之类的数据集当然就是600/700/1039个了)目录，根据上面csv文件中视频文件所属的动作类别存放到对应的目录下，就是类似于UCF101那样的存放模式，有的模型的训练代码则做了比较简单的处理，像我试用了的https://github.com/open-mmlab/mmaction2中slowfast/slowonly/r2plus1d支持直接从视频中读取帧数据，为此，要生成train和val的视频清单文件kinetics400_train_list_videos.txt和kinetics400_val_list_videos.txt，文件的内容很简单就是类似如下形式：
也就是视频文件的路径和所属类别的索引值，模型在训练或者测试时按路径和文件名读取文件指定开始时间帧和结束时间帧之间的视频帧数据并记录所属类别值。​​​​​​​
用python实现上面的功能是不难的，但是从国内下载油管上的视频就算你有办法下载也是非常慢那会让人抓狂，其实还有个网站可以直接使用迅雷下载压缩打包了的kinetics400/600/700的视频数据，也可以直接写它提供的shell脚本download.sh下载: https://github.com/cvdfoundation/kinetics-dataset，可以看到下面的视频清单文件和视频标注csv文件:
K400视频和标注文件:
https://s3.amazonaws.com/kinetics/400/train/k400_train_path.txt
https://s3.amazonaws.com/kinetics/400/val/k400_val_path.txt
https://s3.amazonaws.com/kinetics/400/test/k400_test_path.txt
https://s3.amazonaws.com/kinetics/400/annotations/train.csv
https://s3.amazonaws.com/kinetics/400/annotations/val.csv
https://s3.amazonaws.com/kinetics/400/annotations/test.csv
K600视频和标注文件:
https://s3.amazonaws.com/kinetics/600/train/k600_train_path.txt
https://s3.amazonaws.com/kinetics/600/val/k600_val_path.txt
https://s3.amazonaws.com/kinetics/600/test/k600_test_path.txt
https://s3.amazonaws.com/kinetics/600/annotations/train.txt
https://s3.amazonaws.com/kinetics/600/annotations/val.txt
https://s3.amazonaws.com/kinetics/600/annotations/test.csv
K700视频和标注文件:
https://s3.amazonaws.com/kinetics/700_2020/train/k700_2020_train_path.txt
https://s3.amazonaws.com/kinetics/700_2020/val/k700_2020_val_path.txt
https://s3.amazonaws.com/kinetics/700_2020/test/k700_2020_test_path.txt
https://s3.amazonaws.com/kinetics/700_2020/annotations/train.csv
https://s3.amazonaws.com/kinetics/700_2020/annotations/val.csv
https://s3.amazonaws.com/kinetics/700_2020/annotations/test.csv
这里的csv格式的标注文件比官网上的标注文件多了一列，在自己写脚本解析生成kinetics400_train_list_videos.txt和kinetics400_val_list_videos.txt清单文件时可以忽略掉，另外这些文件里面有些文件的youtube_id没有，可以根据视频文件来反查csv解析出来的字典数据，这样就可以忽略掉这些有问题的数据。
像https://github.com/open-mmlab/mmaction2里面有些模型既支持读取帧抽取出来的一张张图片(rawframes)数据，也支持自己按视频清单文件${DATASET}_train_list_videos.txt、${DATASET}_val_list_videos.txt从指定视频(位于videos_train和videos_val下，可以按类别存放，也可以不按类别全部存放在一起，关键是train_list和val_list清单文件中从csv标注文件中获取到的视频文件和对应的类别值要准确)里直接读取帧数据:
mmaction2
├── mmaction
├── tools
├── configs
├── data
│ ├── ${DATASET}
│ │ ├── ${DATASET}_train_list_videos.txt
│ │ ├── ${DATASET}_val_list_videos.txt
│ │ ├── annotations
│ │ ├── videos_train
│ │ ├── videos_val
│ │ │ ├── abseiling
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a1cbc141409baf6b0cf2149d60031a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0bd38a3dfa88644ced2bdc6ffaf9d0/" rel="bookmark">
			Eclipse EE(企业版)安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eclipse EE(企业版)安装及使用 文章目录 Eclipse EE(企业版)安装及使用Eclipse的下载 Eclipse的下载 官网链接：https://www.eclipse.org/
下载步骤
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a82bae748fae0e27f9497ff3e8d359/" rel="bookmark">
			ES6利用filter find查找数据以及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		filter let arr = [ { value: 1, name: '测试1' }, { value: 2, name: '测试2' }, {	value: 3, name: '测试3' } ]; let result = arr.filter(item =&gt; item.value == 2); console.log(result) result 输出结果为 arr 中 name等于 2 的数组。
find let arr = [ { value: 1, name: '测试1' }, { value: 2, name: '测试2' }, {	value: 3, name: '测试3' } ]; let result = arr.find(item =&gt; item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7a82bae748fae0e27f9497ff3e8d359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f06ec735894532f608bb2cf48631d5/" rel="bookmark">
			【课设必备】-Matlab设计串联滞后超前校正-纯干货
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab设计串联滞后超前校正
串联滞后超前校正步骤：
1、确定原系统。
2、根据期望截止频率 ω c ∗ ω_c^* ωc∗​，确定超前装置最大超前角 φ m = γ ∗ − γ 0 ( ω c ∗ ) + 6 ° φ_m=\gamma^*-\gamma_0(ω_c^*)+6° φm​=γ∗−γ0​(ωc∗​)+6°。
3、求解超前校正参数 a = 1 + s i n φ m 1 − s i n φ m a=\frac{1+sinφ_m}{1-sinφ_m} a=1−sinφm​1+sinφm​​
4、根据校正点与两个转折频率处的倍频关系求出两个转折频率，得出超前校正传函。
5、使用超前校正后的系统在 ω c ∗ ω_c^* ωc∗​处进行设计滞后校正。
6、根据滞后校正装置倍频关系求解滞后校正参数。
7、进行串联滞后超前校正，并验算校正后指标是否满足要求。
例：已知单位反馈系统的系统开环传递函数 G 0 = 100 s ( 1 10 s + 1 ) ( 1 60 s + 1 ) G_0=\frac{100}{s(\frac{1}{10}s+1)(\frac{1}{60}s+1)} G0​=s(101​s+1)(601​s+1)100​ 请设计串联滞后超前校正装置，使校正后系统满足 γ ≥ 50 ° ， ω c ∗ ≥ 20 ， h ≥ 10 \gamma≥50°，ω_c^*≥20，h≥10 γ≥50°，ωc∗​≥20，h≥10。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3f06ec735894532f608bb2cf48631d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b668d6ce59b413d613a00ae31f0efbc/" rel="bookmark">
			基于FPGA，解扰码器Verilog的实现，以及扰码器与解扰码器的联合仿真。附上仿真结果。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、扰码器二、解扰码器三、Descrambler的Verilog实现1、descrambler.v2、descrambler_tb.v 四、扰码器与解扰码器的联合仿真1、scrambler_test.v2、scrambler_test_tb.v3、联合仿真结果 五、总结 前言 在数字信号处理系统中，因为发送端的数字信号序列可能会出现很长一段都是“0”，或很长一段序列都是“1”的情况，这样会给接收端进行同步、定时信息的提取带来困难。这时，就需要用到扰码，阻止过长的“0”或“1”的出现。在接收端就需要用到解扰码，恢复出原始数据。
一、扰码器 关于扰码器，请查看我上一篇博文。
基于FPGA，如何用Verilog HDL实现64位宽的扰码器？附上仿真结果。
二、解扰码器 解扰码器就是将已经经过扰码操作的数字信号序列恢复成原始数字信号序列的模块。
三、Descrambler的Verilog实现 1、descrambler.v module	descrambler( use_descrambler	,	//开始使用解扰码器 clk,	reset,	ena_d,	//解扰码器的时钟信号 din_d,	//解扰码器的输入，可以直接连到扰码器的输出端 dout_d	//解扰码器的输出 ); parameter	WIDTH=32'd64;//64位的数据 input	use_descrambler; input	clk; input	reset; input	ena_d; input	[WIDTH-1:0]din_d; output	[WIDTH-1:0]dout_d; reg	[57:0]scram_state; wire	[WIDTH-1:0]dout_w; reg	[WIDTH-1:0]dout_r; wire	[WIDTH+58-1:0]history; assign	history={din_d,scram_state}; //定义变量i，用于在generate中的循环，i不会被综合 genvar	i; //产生并行的赋值块，完成对64位值的更新 generate for(i=0;i&lt;WIDTH;i=i+1) begin: gen_history assign dout_w[i]= history[58+i-58]^history[58+i-39]^ history[58+i]; end endgenerate always @(posedge clk,posedge reset) if(reset)begin scram_state	&lt;=58'h3FF_FFFF_FFFF_FFFF; dout_r	&lt;=0; end else if(ena_d)begin dout_r	&lt;=dout_w; scram_state	&lt;=history[WIDTH+58-1:WIDTH]; end assign	dout_d=use_descrambler?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b668d6ce59b413d613a00ae31f0efbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f8faec6ae128c8c2528b9d2c1230999/" rel="bookmark">
			学习Linux（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 文件基本属性 Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。
为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。
在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：
chown (change ownerp) ： 修改所属用户与组。chmod (change mode) ： 修改用户的权限。 通过 chown 来授权用户，通过 chmod 为用户设置可以开门的权限。
1、利用 ll 或者 ls -l 命令显示一个文件的属性以及文件所属的用户和组。
在上面的实例中，第一个字符代表的是这个是个文件、目录或链接文件等。
当为 d 则是目录当为 - 则是文件；若是 l 则表示为链接文档(link file)；若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。
接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。
最左边的部分：
从左至右用 0-9 这些数字来表示。 第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。
第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。
其中，第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f8faec6ae128c8c2528b9d2c1230999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553b995d8c49917d5d2e85fa8fbcf9e1/" rel="bookmark">
			基于FPGA，如何用Verilog HDL实现64位宽的扰码器？附上仿真结果。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、扰码器1、什么是扰码器2、扰码的原理3、产生扰码的多项式 二、Scrambler的Verilog实现1、scrambler.v2、scrambler_tb.v 三、仿真结果四、总结 前言 在数字信号处理系统中，因为发送端的数字信号序列可能会出现很长一段都是“0”，或很长一段序列都是“1”的情况，这样会给接收端进行同步、定时信息的提取带来困难。这时，就需要用到扰码，阻止过长的“0”或“1”的出现。在接收端就需要用到解扰码，恢复出原始数据。
一、扰码器 1、什么是扰码器 扰码器，顾名思义就是能实现数字信号扰码处理功能的模块。扰码器的作用是：如果输入数字序列是短周期的，将会把该序列以某种规律扰乱为长周期，并且使输出序列中的过判决点接近bit数的一半，这样可以使得接收机更容易提取同步信息。
2、扰码的原理 不用增加冗余度就可以扰乱信号，改变数字信号的统计特性，它的原理是建立在反馈移位寄存器上的。
3、产生扰码的多项式 根据IEEE标准，采用的多项式为 x^58 +x^39 +1,根据反馈移位寄存器，也就是分别在58、39和1的位置的反馈抽头系数为1，其他都为0。
二、Scrambler的Verilog实现 1、scrambler.v 实现扰码器的程序如下:
module	scrambler( use_scrambler, //开始使用扰码器 clk,	//时钟，本代码的时钟频率选择为50Mhz reset,	ena,	//使能信号 din,	//需要进行扰码的64位输入数据 dout	//经过扰码之后的64位输出数据 ); parameter	WIDTH=32'd64; input	use_scrambler; input	clk; input	reset; input	ena; input	[WIDTH-1:0]din; output	[WIDTH-1:0]dout; //以下都是进行扰码操作 reg	[57:0]scram_state; reg	[WIDTH-1:0]dout_r; wire	[WIDTH+58-1:0]history; genvar	i;	//定义变量i，它不会被综合 assign	history[57:0]=scram_state; //利用generate语句生成64个并行的赋值语句，完成64位的每一位的更新 generate for(i=58;i&lt;WIDTH+58;i=i+1) begin: gen_history assign	history[i]= history[i-58]^history[i-39]^ din[i-58]; end endgenerate always @(posedge clk,posedge reset) if(reset)begin dout_r	&lt;=0; scram_state	&lt;=58'h3FF_FFFF_FFFF_FFFF; end else if(ena)begin dout_r	&lt;=history[WIDTH+58-1:58]; scram_state &lt;= history[WIDTH+58-1:WIDTH]; end assign	dout=(use_scrambler==1)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/553b995d8c49917d5d2e85fa8fbcf9e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293490885397b791da4e10b5c1b486a8/" rel="bookmark">
			CentOS7编译安装Nginx 1.20.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 升级Gcc到11之后，编译指令为
./configure --prefix=/opt/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-cc=/usr/local/gcc-11.2.0/bin/gcc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/257e8d1636a69745426ca9089213aa58/" rel="bookmark">
			【课设必备】-Matlab设计串联超前校正-纯干货
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab设计串联超前校正
串联超前校正步骤：
1、确定原系统。
2、求解原系统相角裕度 γ \gamma γ（ γ \gamma γ不足）。
3、设计超前网络最大超前相角 φ m φ_m φm​，并据此来求解参数a。
4、根据 10 l g a 10lga 10lga找出 ω m ω_m ωm​，根据a倍频关系求出两个转折频率，得出校正传函。
5、进行串联校正，并验算校正后指标是否满足要求。
例：已知单位反馈系统的开环传递函数
G 0 = 300 0.5 s + 1 G_0=\frac{300}{0.5s+1} G0​=0.5s+1300​ 请设计串联超前校正装置，使校正后系统相角裕度 γ ≥ 45 ° \gamma≥45° γ≥45°
使用matlab进行校正，结果如下：
鸣谢：感谢江苏科技大学张永韡(wei)老师的悉心教导！
校正代码：
clear; close all; clc K = 300; gamma = 45; s = tf('s'); G0 = K/(s*(0.5*s+1)); % 原系统 lb = 0.1; ub = 1000; % 4个10倍频程 [G0m,P0m,W0cg,W0cp] = margin(G0); phim = gamma - P0m + 5; %设置校正装置最大相角 a = (1+sind(phim))/(1-sind(phim)); % 求解校正参数a mag_wm = -10*log10(a); % 求解校正点 fun = @(w)(20*log10(abs(freqresp(G0,w)))-mag_wm)^2; wm = fminbnd(fun,lb,ub); % 寻找wm w2 = wm*sqrt(a); % 校正装置第二个转折频率 w1 = w2/a; %校正装置第1个转折频率(a倍频关系) Gc = tf([1/w1,1],[1/w2,1]); % 校正传函 G = Gc*G0; % 串联超前校正 bode(G0,Gc,G,{lb,ub}); grid on [Gm,Pm,Wcg,Wcp]= margin(G); title(['超前校正: \gamma^*=',num2str(gamma),'\circ, \gamma=',.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/257e8d1636a69745426ca9089213aa58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12cb02ec218468ed7c4ab4eff8c46080/" rel="bookmark">
			邮箱客户端Foxmail如何配置邮箱服务器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		邮箱客户端是目前大家使用企业邮箱过程中常见的方式之一，首次登录邮箱账号时需要配置邮箱服务器，不少用户都不了解如何配置，这里以TOM企业邮箱为例，说明企业邮箱如何在Foxmail客户端进行配置邮箱服务器。
一、foxmail如何绑定邮箱账号
当用户首次启动Foxmail时是没有绑定邮箱账号的，系统会直接让你输入企业邮箱的账号和密码。如果已经添加过其他邮箱，打开Foxmail右侧菜单，点击“账号管理”，然后点击新建。
二、在新建账号中点击左下角手动设置
填写邮件账号、密码，服务器设置如下，勾选SSL邮件会加密传输，填写完成后点击“创建”，即可成功绑定账号，在Foxmail中收发邮件了。
客户端设置（支持POP3和IMAP协议，支持加密SSL）
（1） 接收服务器：pop.qy.tom.com 端口号110；加密SSL端口号995
接收服务器：imap.qy.tom.com 端口号143；加密SSL端口号993
（2）发送服务器：smtp.qy.tom.com 端口号25；加密SSL端口号465
以上就是邮箱客户端配置流程了，你学会了吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33666559361cea341b92e7e794c1282f/" rel="bookmark">
			游戏LTV计算方法过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 LTV分析意义LTV定义计算公式实际LTV预测LTV LTV计算步骤 LTV分析意义 LTV 分析可以帮助回答以下问题：
哪个渠道来的用户带来的人均价值更高？用户贡献的价值是否高于用户获取的成本？
运营活动是否带来了显著的收益？用户的人均价值是否有所提升？运营活动到底是好还是坏？
游戏产品是否能够带来足够的人均消费来覆盖开发成本？玩家价值会在多久之后趋于稳定？
哪个用户群体是我们产品的高价值人群？这些客户有怎样的特征？
LTV定义 用户生命周期价值（Life Time Value，LTV），即用户在生命周期中贡献的商业价值。LTV 分析是一种分析用户商业价值的分析模型，可分析特定日期访问的用户群体，在一定时长内所贡献的人均价值。
计算公式 实际LTV 实际ltv=总付费金额/总用户数
即n日ltv=选定时间内的用户在n日内付费总金额/n日内总用户数
预测LTV 预测：LTV=LT*ARPU
LTV计算步骤 准备数据
按照上面公式，计算n日ltv需要选定时间内注册用户从注册到第n日的每日留存率、ARPU
eg：
*其中，n日留存：代表不同的留存，如1日留存，2日留存……n日留存；
留存人数：表示不同留存对应的用户数；
金额：不同留存的用户在第n日付费的金额；
注册人数：不同留存对应的用户在注册那天的总注册人数；
*每日活跃用户都是由当天注册用户+不同日注册用户留存下来的用户（老用户）构成* 计算出第n日平均留存率：第n日平均留存率=第n日留存人数/n日前的注册人数，
第n日平均arpu=选定用户第n日付费金额/第n日留存人数
eg： 这里0天代表注册当天，1天代表注册第2天以此类推
值得注意的是，不能采用先计算出选定时间内第n日留存率，再平均得出第n日留存率，应该是计算出选定时间内第n日留存总用户数再除以n日前对应的总注册人数，因为先计算各个留存率再平均会受到异常值、极值的影响；例如计算2021-11-16~2021-11-18日7日平均留存率：
假设这三天对应的7日留存人数分布是10，100，200，注册人数：20，300，1000
正确计算方式：7日留存率=（10+100+200）/（20+300+1000）=23.5%
错误的计算方式：7日留存率=（10/20+100/200+200/1000）/3=40%
很明显16号那天的人数过少，当天的7日留存为50%没有参考意义，n日平均arpu也一样。
留存率、arpu的拟合
查阅相关文章可知，目前留存率的拟合函数为幂函数最为合适；
这里选用幂函数、二项式函数分布对留存率、arpu进行拟合；由于用户的生命周期内不同阶段的留存率、arpu变化趋势是不一样的，前期变化较大，后期比较稳定再到衰弱；因此采用分段式函数对其进行拟合更为精准。
eg：
可以看到第13天前后的留存率变化趋势是不一样的
因此，当n&lt;=13时，拟合曲线为：
当n&gt;13是，拟合曲线为：
同理，n日arpu的二项式拟合曲线为:
这里由于R^2为0.92比较接近1，所以就没有分段进行拟合了
真实与预测ltv对比、校准
根据上面的拟合曲线就可以计算出不同日的预测ltv了，真实与预测ltv差异对比如下：
可以看到，这里真实与预测的ltv差异较小，因为取得数据较多较全，所以预测的ltv较为准确；
实际生活中，游戏上线几天可能就需要对ltv预测，那么拟合出来得曲线与实际得差异就会更大，此时需要根据两个曲线之间差异进行校准，同时也可以常更新数据，使得拟合曲线更接近实际的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b484ebd0dbb5df71af3f889bfebee0e/" rel="bookmark">
			2021最稳C/C&#43;&#43;学习路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是唐唐。
此篇文章关于 C/C++/Linux后端开发的全路线。
前言 于我而言，最开始学习就是 C++，除了计算机专业，其他专业可能学习的第一门编程语言为 C 语言，还是谭浩强爷爷那本，当时想着有点 C 基础，无外乎就是 C 语言的升级版，于是开启了 C++ 的路程。
语言这个东西，可能过后你会发现，它真就一工具，你如果想做个爬虫或者数据分析，那多半会选择 Python，无论是接口还是开源社区都非常的完善，如果想做一个快速迭代的 CRUD 项目，也可以选择 Python 的 Django 框架或者 Java的框架快速完成开发，如果是内核驱动，那老老实实的用大哥 C，如果玩儿数据库，搜索引擎就整 C++,如果是分布式或者 Devops那一套，自然就是 Golang，有轮子直接上手就好，先保证完成任务，其次是优化。
不过在找工作的时候，不同的岗位确实有一个大家公认的语言，比如测试开发，多半就会涉及到 Python 的知识点考察， 毕竟需要一些自动化的开发工作，如果是服务端开发，多半就会涉及到 Linux 的知识点。
研究生期间，实验室很严格，几乎没有实习的时间，专硕，导师的项目又比较紧凑，就只能挤出时间去准备，所以如果大家是非科班的，也不要担心，时间一定是可以挤出来，静下心去积累，结果不会差。
大厂到底喜欢问啥
计算机基础，包含计算机组成原理，操作系统，计算机网络，数据库，设计模式，算法与数据结构。那么最容易被刷掉的就是算法，每一年的招聘中，简历去掉一部分，算法还要去掉一部分。
我当时复习的时候，边学算法导论边抄代码，后面要找工作的时候采取Leetcode 练习，加上剑指 Offer 的复习，几乎三轮左右。
不管你是什么技术栈，都是需要稳扎稳打的，大厂=基础+算法+项目。如果有拿得出手的项目，而且能把项目的背景，目的，干什么的，都能表述的非常清楚了，那可能距离 offer 更进一步。这些每个环节都不能疏漏，进大厂就需要培养自己的大局观，大厂思想，你就是牛逼，别人不会的你就会，你就有机会拿下 offer。
时间上安排 早一点的互联网公司在三四月的时候就会出现提前批，对于没有一点面试经验的你们，可以三四月份找几家公司去体验下面试的流程及面试的难度。
到了八九月就是笔试面试的高峰期，一天面试个四五家公司也算正常，不过你会发现，面试的题目翻来覆去都是那些问题。
我准备的时间还是比较晚，到了九月份基础还不算扎实，上来就被百度当头一棒。对于阿里这样的岗位，七八月大部分的 OFFER 也就结束，腾讯如果 9 月面试，大概 10 月中旬即拿到 OFFER。对于银行和国企，就更往后了，不过那个时候毕业论文啥的也着急，所以找点准备。
就业方向 既然要选定方向，就需要先了解学了这个方向以后可能从事什么岗位，自己喜欢或更加适合哪些岗位。
选择 C/C++ 的同学需要酌情考虑这个问题，它的门槛比 Python，Java 的路线高一些。不过道理是一样的，技术毕竟都相通，Java，Python工作岗位机会多，学的人也多一些，竞争自然也就大。
国内大厂如阿里，腾讯，头条，百度，京东等都有招聘 C/C++ 的岗位，其核心搜索，腾讯的底层架构等机会都是 C++ 写的，所以没必要担心找不到工作，薪资也是杠杠的。
越接近底层机器，其效率越高，各有各的优势，想深入了解计算机系统，选择 C/C++最好不过。有些同学这个月学 C++ 的路线，下个月学 Java 的路线，这是兵家大忌，不管走哪个路线，一定要沉稳，稳扎稳打。学习的过程是枯燥无味的，学习的苦痛是暂时的，未学到的痛苦则是终生的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b484ebd0dbb5df71af3f889bfebee0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e4f67f77b500606ebb72e4c3178d6e/" rel="bookmark">
			（5）机器学习_K折交叉验证(iris数据集实例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、什么是K折交叉验证2、为什么要引入K折交叉验证3、如何实现K折交叉验证3.1 导入必要的包：3.2 导入iris数据集并预处理3.3 设置KFold参数3.4 调参，寻找相对最优3.5 将最佳参数训练模型并查看结果 4、分层交叉验证5、重复交叉验证6、参考文献 1、什么是K折交叉验证 定义：将训练集分成K份，每次用其中一份做测试集，其余的k-1份作为训练集，循环k次，取每次训练结果的平均值作为评分。
c l a s s s k l e a r n . m o d e l _ s e l e c t i o n . K F o l d ( n _ s p l i t s = 5 , ∗ , s h u f f l e = F a l s e , r a n d o m _ s t a t e = N o n e ) class sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e4f67f77b500606ebb72e4c3178d6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f841f4b1621347394eb86db17982d99/" rel="bookmark">
			Python 爬虫进阶必备 | 某电影站视频采集加密参数逻辑分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“咸鱼学Python”，选择“加为星标”
第一时间关注Python技术干货！
今日网站 aHR0cHM6Ly96MS5tMTkwNy5jbi8/ang9JUU1JTkzJTg4JUU1JTg4JUE5JUMyJUI3JUU2JUIzJUEyJUU3JTg5JUI5JUU0JUI4JThFJUU1JUFGJTg2JUU1JUFFJUE0
加密定位与分析 分析的网站是一个电影播放站，有良心的是竟然没有多少广告，
这个请求返回的内容里包含了m3u8的链接，m3u8大家应该都知道是啥吧，我们获取到之后就可以解析出视频了。
所以我们需要的就是构造出这个请求链接，以及下面的几个参数
直接通过Initiator调用栈分析
最后一个请求点击进去，可以看到
这不就是要分析的请求接口嘛
我们要分析的是z、s1ig、g
如上图基本就囊括了全部的参数逻辑
接下来一个一个看下
第一个是z，上面一整串的逗号表达式
c = new Date l = c.getTime() u = 6e4 * c.getTimezoneOffset() d = l + u + 36e5 * 8 m = new Date(d) p = (p = m).getDate() + 9 + 9 ^ 10 p = (p = Et()(String(p))).substring(0, 10) p = Et()(p) 看了下都和时间戳有关，取完时间戳之后经过了Et方法然后得出了p的值
打上断点追进去，可以看到如下逻辑
先是Et方法
这里的d、f、p都是独立的方法，扣一下就可以了，得出结果之后又经过了m方法
以上方法的出结果之后取前 10 位，然后再传入Et方法得出最后z的值
s1ig的值是f
c = new Date l = c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f841f4b1621347394eb86db17982d99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89987af3fb655e6c1c50d8faf05aa934/" rel="bookmark">
			pip 安装模块时报错：ImportError: cannot import name ‘InvalidSchemeCombination‘ ......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip 安装模块时报错：ImportError: cannot import name 'InvalidSchemeCombination' from 'pip._internal.exceptions' (D:\WORK_ENV\workenv1\lib\site-packages\pip\_internal\exceptions.py)
原因：
pip文件损坏
解决：
先找到pip文件所在位置【我的报错pip文件在 D:\WORK_ENV\workenv1\lib\site-packages】，删除pip相关文件，如：pip和pip-21.2.4.dist-info打开网址https://bootstrap.pypa.io/get-pip.py，在网页内，右键——另存为——命名文件为get-pip.py在get-pip.py文件存储位置，如下图，输入cmd打开黑窗口，输入命令：python get-pip.py，执行命令即可 注意：如果是虚拟环境的pip出现问题，需要先转到出现问题的虚拟环境内，执行命令，删除也是删除虚拟环境内的pip相关文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005913dfac23e203f17b1c78116cb54b/" rel="bookmark">
			springboot项目细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置参数为非必传参数 **GetMapping @RequestParam(required =false) 默认为ture 如果使用 注释 @RuquestBody 报错：Required request body is missing
@PostMapping @RequestBody(required =false) MyBatis Plus条件构造器QueryWrapper对应常用SQL语法说明 函数　说明　SQL语法
eq 等于　=
ne 不等于 &lt;&gt;
gt 大于 &gt;
lt 小于 &lt;
ge 大于等于　&gt;=
le 小于等于　&lt;=
or 或者 or
and 并且 and
like 模糊查询包含s like %s%
notLike 模糊查询不包含s not like %s%
likeLeft 左匹配模糊查询　like %s
likeRight 右匹配模糊查询 like s%
between 在v1到v2之间　between v1 and v2
notBetween 不在v1到v2之间　not between v1 and v2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/005913dfac23e203f17b1c78116cb54b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afb5eb4be34f253aca75f1f953b62566/" rel="bookmark">
			springmvc处理器方法的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springmvc处理器方法的参数 处理器方法可以包含以下四类参数，这些参数会在系统调用时由系统自动赋值.所以我们可以在方法内直 接使用。以下是这四类参数:
HttpServletRequest
HttpServletResponse
HttpSession
请求中所携带的请求参数
准备工作：创建新的控制器ParamController.java和前端页面hello.jsp页面
package com.daw.controller; import com.daw.pojo.Team; import com.daw.vo.QueryVO; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import java.util.List; /** * DAW * ParamController * 又不是不能用！ */ @Controller @RequestMapping("param") public class ParamController { @RequestMapping("hello") public ModelAndView hello(){ return new ModelAndView("hello"); } } 1、直接使用方法的参数逐个接收 前端页面
&lt;%-- Created by IntelliJ IDEA. User: Mr-DUAN Date: 2021-08-18 Time: 14:40 To change this template use File | Settings | File Templates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afb5eb4be34f253aca75f1f953b62566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159c5cd4386883cc5a70dc223fa8b4cc/" rel="bookmark">
			华为/思科清除路由器及交换机命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为：
一、reset saved-configuration //重置保存配置
输入命令后会出现：
This will delete the configuration in the flash memory.
The device configuratio
ns will be erased to reconfigure.
Are you sure? (y/n)[n]: y
二、reboot //重新启动
输入命令后会出现：
Info: The system is comparing the configuration, please wait.
Warning: All the configuration will be saved to the next startup configuration.
Continue ? [y/n]: n
系统会继续提示：
System will reboot! Continue ? [y/n]: y 重启中
三、输入上述两个命令后，路由器恢复出厂设置。
补：清除某端口配置，全局模式下clear configuration interface g0/0/x
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/159c5cd4386883cc5a70dc223fa8b4cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25fada518386fcc9b9599726e0a74b82/" rel="bookmark">
			尚学堂__百战程序员__1573题------第六章 异常机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、Java中，处理异常的两大步是?
捕获异常，声明异常
2、如果catch两个异常，一个是父类，一个是子类。这两个异常的catch顺序如何
确定?
先捕获子类异常，再捕获父类异常
3、finally里面一般放置什么代码?
4、Error和Exception的区别和联系
5、Throwable是一个类还是接口?
类
6、如果碰到NullPointerException，我们一般应该如何查错?如何做处理?
debug
7、【上机】完成课堂测试异常的代码
8、【上机】Eclipse中，增加try-catch块的操作是怎么做的?
选中-》alt+shift+z
9、【上机】自定义一个自己的异常类
public class SexException extends Exception{ public SexException(){ super(); } public SexException(String message){ super(message); } } 7、方法重写时，子类声明异常能否超出父类的范围?
不能
8、【上机】下面的代码，有什么问题? 解释原因
class A {
public void method() throws IOException { }
}
class D extends A { public void method() throws Exception { }
}
9、说出你现在接触的几个异常?尽量多写。
ArithmeticException, 算术异常，例如，一个整数“除以零”时，抛出此类的一个实例。 NullPointerException,
ClassCastException,
NoClassFoundException
ArrayIndexOutOfBoundsException,
NumberFormatException, 数字格式化异常 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7a2cedd09d30584c06465114dccdca/" rel="bookmark">
			反爬虫与反反爬虫技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.反爬虫技术 首先我们来思考一下，为什么要反爬虫？
网络中充斥大量爬虫的情况下，会使得整个网络的数据不可靠。网站在面对高并发爬虫的攻击时，很容易被击溃。版权数据被爬取，对于网站来说是巨大的损失。 基于以上原因，反爬虫技术孕育而生，主要包含以下最常用的反爬技术：
封IP
后台对访问进行统计，如果单个IP访问超过阈值，则封锁该IP。封UserAgent
后台对访问进行统计，如果单个UserAgent访问超过阈值，则封锁该UserAgent。封Cookie
后台对访问进行统计，如果单个cookies访问超过阈值，则封锁该cookie.设置请求时间间隔
设置请求时间间隔，规避过于频繁的请求访问，避免爬虫短时间爬取大量数据。robots.txt协议
robots.txt是一个限制爬虫的规范，该文件是用来声明哪些东西不能被爬取； 设置robots.txt协议，位于robots.txt中的UserAgent不可请求网站数据。验证码验证
发生大量请求时，弹出验证码验证，通过验证方可继续访问。JavaScript渲染网页
将重要信息放在网页中但不写入html标签中，而浏览器会自动渲染标签中的js代码，将信息展现在浏览器当中，而爬虫是不具备执行js代码的能力，所以无法将js事件产生的信息读取出来。ajax异步传输
访问网页的时候服务器将网页框架返回给客户端，在与客户端交互的过程中通过异步ajax技术传输数据包到客户端，呈现在网页上，爬虫直接抓取的话信息为空。网页iframe框架嵌套
在下载框处再内嵌一个窗口，使得爬虫提取不到内层窗口的数据。 2.反反爬虫技术 有反爬虫技术，就会有反反爬虫技术存在，这是两种相互对抗的技术；这两种技术也在相互对抗中不断发展。
我们在编写爬虫时，要对获取海量的免费数据心怀感恩，而不是恶意攻击网站，这是一种害人害己的形为。
常用的反反爬虫技术有以下这些：
降低请求频率
对于基于scrapy框架构建的爬虫，在配置文件settings.py中设置DOWN-LAOD_DELAY即可。
以下代码设置下载延迟时间为4秒，即两次请求间隔4秒。 DWONLOAD_DELAY = 4 或设置RANDOMIZE_DOWNLOAD_DELAY，定义一个随机的请求延迟时间。
RANDOMIZE_DOWNLOAD_DELAY = True 修改请求头
禁用Cookie
有些网站会通过Cookie来发现爬虫的轨迹，如非特殊需要，禁用Cookie可以切断网站通过Cookie发现爬虫的途径。
对于基于scrapy框架构建的爬虫，在配置文件settings.py中设置COOKIES_ENABLED即可。 #Disable cookies (enabled by default) COOKIES_ENABLED = False 伪装成不同的浏览器
Scrapy自带专门设置User-Agent的中间件UserAgentMiddleware，在爬虫运行中，会自动将User-Agent添加到HTTP请求中，并且可以设置多个浏览器，请求时可以随机添加不同的浏览器。 1.设定浏览器列表。
将浏览器列表定义至settings.py文件中：
MY_USER_AGENT = ["Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NETCLR 1.1.4322; .NET CLR 2.0.50727)", \ "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser;SLCC1; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb7a2cedd09d30584c06465114dccdca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/287/">«</a>
	<span class="pagination__item pagination__item--current">288/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/289/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>