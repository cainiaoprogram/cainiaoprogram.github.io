<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a945ceecefa73dde83a61b000169f8/" rel="bookmark">
			原型对象、原型链超详细讲解（附图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原型对象、原型链超详细讲解（附图解） 一、函数的原型对象二、prototype（函数的原型)三、__ proto__(原型链)四、constructor（构造函数）五、prototype继承六、结论1.实例对象的原型链指向当前类的原型对象。2.原型对象的原型链指向Object函数的原型对象3.Object函数的原型对象的原型链指向null，Object的原型链是不存在的。4.所有对象最后都会指向Object函数的原型对象。 七、图解过程 一、函数的原型对象 原型对象中有原型链—指向最高函数的原型对象的构造函数指向本身 var arr=new Array(); console.log(arr); //一个对象的原型链指向原型对象 //原型对象的构造函数指向本身（函数本身） //es5中没有类的概念，就是没有class类集合，我们把函数叫类 //也就是自定义函数类，写类对象 //函数的原型属性prototype===函数类的原型对象 function myArray(){ this.length=0; } //当前函数类的原型对象 myArray.prototype={ constructor:myArray, mysort:function(){ //this指向当前类对象本身（实例本身） console.log(this); } } //实例化类对象 var myarr=new myArray(); console.log(myarr); myarr.mysort(); function Animal(){ } //输出的是当前函数的原型对象 console.log(Animal.prototype); //原型对象中有原型链---指向最高 //函数的原型对象的构造函数指向本身 console.log(Animal.prototype.constructor); 二、prototype（函数的原型) 每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性，原型对象上具有原型属性以及原型方法。函数才有prototype，每个函数都有一个prototype属性，这个属性指向函数的原型对象。通过prototype可以为对象在运行期间添加新的属性和方法。 三、__ proto__(原型链) 这是每个对象(除null外)都会有的属性，叫做__proto__，指向自身的构造函数的原型对象。从内置对象上可以观察到，实例化的当前对象__proto__(原型链)指向自身的构造函数的原型对象。 &lt;script&gt; var arr = []; console.log(arr); &lt;/script&gt; 四、constructor（构造函数） 每个原型都有一个constructor属性，指向函数本身。 五、prototype继承 function Person(name,job){ this.name=name; this.job=job; this.sex=''; } Person.prototype={ constructor:Person, sleep:function(){ console.log("睡觉"); }, eat:function(){ console.log("吃饭"); } } Person.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05a945ceecefa73dde83a61b000169f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49ea460d4893a118f50d90a859beb72/" rel="bookmark">
			Spring Security---会话固定攻击防御
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是会话固定攻击？ 会话固定攻击英文叫做 session fixation attack，其攻击原理是利用sessionId的不变性。
假设攻击者登录www.xxx.com网站，此时会生成一个sessionId。攻击者利用某种手段欺骗受害者访问该网站，但是会在网站后拼接自己的sessionId。当受害者访问www.xxx.com并进行登录后，此时的sessionId还是攻击者登录后返回的sessionId，因为sessionId没有变化，当攻击者再次登录该网站后，此时系统发现sessionId没有发生变化，攻击者就拥有了受害者的身份了，就该做坏事了。
Spring Security配置防御会话固定攻击 changeSessionId：表示在登录成功之后，session 不变，但是会修改 sessionid，其实也相当于改变了session，因为这样攻击者的sessionid找不到对应的session了。migrateSession： Spring Security的默认策略，表示在登录成功之后，会创建一个新的Session，把旧的Session中的数据复制过来。newSession : 表示在登录成功之后，创建一个新的 session。none： 表示不做任何事情，在登录成功之后，会继续使用旧的 session，这种情况是无法防御会话固定攻击。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a3975329972c6ae2c5160bfa884da4/" rel="bookmark">
			自然语言处理总复习（十一）—— 信息检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然语言处理总复习（十一）—— 信息检索 一、概述1. 概念2. IR系统的体系结构（1）系统要素（2）Web搜索 3. IR的历史4. IR的困难5. IR相关领域6. 主要的搜索引擎7. 信息检索的应用8. 国际国内会议9. 重要工具 二、评价（一）评价的概述1. 评价IR的原因2. 评价IR系统的困难3. 评价的对象4. 如何评价效果？ （二）基本指标 **`precision, recall, F-measure`**1. 精准率（precision），召回率（recall）2. F-measure（precision + recall） （三）TREC评测1. TREC的查询方式2. Pooling技术3. 性能评价指标 —— MAP（算数平均精度）4. 性能评价指标 —— 11-point AP（11点平均精度）- 计算实例 5. 其他评价指标 三、模型（一）模型概述1. 模型的概念2. 检索模型的核心问题3. 模型分类4. 信息检索的两种主要方式（1）特别（ad hoc retrieval）检索（2）过滤（filtering） （二）信息检索模型1. 布尔模型（Boolean Model）布尔模型的定义和描述（1）定义（2）举例（3）模型小结（4）问题 2. 向量空间模型（Vector Space Model, VSM)（1）索引项（2）文档集的表示方法（3）相似度计算（1）相似度函数 —— 内积（2）相似度函数 —— 余弦 （4）文档和词项的权重计算方法a. 一些定义b. 计算公式 —— 典型计算公式c. 计算公式 —— 归一化计算公式 （5）向量空间模型小结a. 模型优点b. 思考 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a3975329972c6ae2c5160bfa884da4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396157f8f9ef36f82dfc9c28d238b079/" rel="bookmark">
			go的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习博客：https://www.jianshu.com/p/a982807819fa
golang的变量类型： 基本类型
整型，包括int，uint，int8，uint8，int16，uint16，int32，uint32，int64，uint64，byte，rune，uintptr等
浮点型，包括float32，float64
复数类型，包括complex64，complex128
字符串类型，string
布尔型，bool
复合类型
数组
struct结构体
引用类型
slice
map
channel
pointer or 引用类型
接口类型
interface{}
基本类型变量的比较 比较的两个变量类型必须相等：
golang没有隐式类型转换，比较的两个变量类型必须完全一样，类型别名也不行。
如果要比较，先做类型转换再比较。
类型完全不一样的，不能比较
类型再定义，不能比较，可以强转比较
类型别名，可以比较
fmt.Println("2" == 2) //invalid operation: "2" == 2 (mismatched types string and int) type A int var a int = 1 var b A = 1 fmt.Println(a == b) //invalid operation: a == b (mismatched types int and A) fmt.Println(a == int(b)) //true type C = int var c C = 1 fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/396157f8f9ef36f82dfc9c28d238b079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d774214472b892bb03772b3e248b2b9/" rel="bookmark">
			基于Pytorch MNIST手写体检测实验，遇到设置5层网络就导致梯度消失的问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做Pytorch 手写体识别实验时，遇到程序跑多次后，仅设置4层卷积，就出现了梯度消失的问题。
根据书中撰写，卷积层数应该在10层的时候，有较好的运行效果，但是运行参考书的代码历程同样出现了该问题。
书中的源代码如下：
import torch import torchvision # 设置超参数 batch_size = 100 input_size = 784 hidden_size = 1000 num_classes = 10 num_epochs = 5 learning_rate = 0.001 device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu') # 从TorchVision下载MNIST数据集 train_dataset = torchvision.datasets.MNIST(root='./data', train=True, transform=torchvision.transforms.ToTensor(), download = True) test_dataset = torchvision.datasets.MNIST(root='./data', train=False, transform=torchvision.transforms.ToTensor()) # 使用PyTorch提供的DataLoader，以分批乱序加载数据 train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True) test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=False) conv_layer_number = 10 class NeuralNetwork(torch.nn.Module): def __init__(self): super(NeuralNetwork, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d774214472b892bb03772b3e248b2b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e39fd3da691656e653920e3e0d757d/" rel="bookmark">
			线程状态--线程等待
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程状态：辅助线程进行调度，java中线程的状态是通过一个enum来表示的。 NEW：表示Thread对象有了，PCB没有。RUNNABLE：准备就绪，正在cpu执行或者已经准备好上cpu执行。BLOCKED：等待锁，阻塞状态，暂时不上cpu。WAITING： 阻塞状态，暂时不上cpu。TIMED_WAITING：阻塞状态，暂时不上cpu。TERMINATER：线程已经结束，PCB已经销毁，但是代码中的Thread对象还在。 is Alive：线程存活，指PCB是否还存在 。上述除了NEW和TERMINATER之外，其他状态都表示线程存活。以下代码可以查看线程启动之前，线程运行中，线程结束后的状态。
public class ThreadDemo1 { public static void main(String[] args) { Thread t = new Thread() { @Override public void run() { for (int i = 0;i &lt; 100;i++) { } } }; System.out.println("线程启动之前： " + t.getState()); t.start(); while(t.isAlive()) { System.out.println("线程运行中： " + t.getState()); } System.out.println("线程结束后：" + t.getState()); } } 当前线程的引用：Thread.currentThread 相当于this. public class Demo1 { public static void main(String[] args) { Thread t = new Thread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e39fd3da691656e653920e3e0d757d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016552145a06a8f9ae86735f2ab41350/" rel="bookmark">
			M/M/m排队模型 (单队列多服务台并联服务模型)数学建模: 基于生灭过程的理论计算和基于事件推进的Matlab模拟仿真思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		M/M/m排队模型 (单队列多服务台并联服务模型) 数学建模: 基于生灭过程的理论计算和基于事件推进的Matlab模拟仿真思路
原创文章，转载文章请注明出处：©️Sylvan Ding 🎉🎉🎉
摘要 本文研究M/M/m单队列多服务台并联服务的经典排队问题。近年来，对于排队模型的理论研究趋于完善，更复杂的排队模型则不便使用排队理论计算其解析值。随着计算机技术的发展，模拟仿真法已经成为解决复杂排队问题的主要手段。本文提出了一种基于时间调度的M/M/m排队模型模拟仿真方法，采用E(Wq)、E(Ws)、E(Lq)、E(Ls) 这4个评价指标，设定模型初始化参数后，设计了基于马尔可夫状态转移的仿真时钟推进器，不断更新系统状态；将服务台分为空闲和繁忙两类，完成了空闲服务台服务流程和繁忙服务台服务流程的仿真程序设计工作，利用Matlab进行仿真模拟。在此基础上，对经典的M/M/m模型进行理论分析，基于生灭过程建立稳态方程，求出模型的解析解。结果显示，上述4个评价指标的仿真值和理论值极为接近，说明仿真模型设置合理、有效，为后续相关理论研究提供了依据。
第1章 引言 1.1 背景 排队论，又称为随机服务系统，是研究系统由于随机因素的干扰而出现排队或拥塞现象的一门学科，期望对排队系统的运行指标提出优化方法，其适用于一切服务系统，包括通信系统、计算机系统等，对通信系统进行性能评价是当今排队论在应用上的热门课题之一[1]。现实生活中就广泛存在着排队过程，如火车站的售票系统、超市收银系统、图书馆借阅台等。但是排队的出现往往并不是有益的，比如超市服务柜台等待时间过长导致顾客流失、机场未合理调度起飞跑道导致航班延误、访问量过大导致电信运营商网络堵塞等。
排队系统由三个基本部分组成，分别是输入过程、排队规则和服务机构。输入过程是指顾客的到达时间分布情况，客源可以是有限/无限的，顾客到达可以是单个的/成批的，顾客到达时间间隔可以服从负指数分布（泊松到达）/k阶Erlang分布等；排队规则是顾客等候服务的规则，常见的有先到先服务、后到先服务、随机服务和带有优先级的服务规则等；服务机构指的是服务台的数量、服务方式、服务时间分布等，服务时间常见的分布有定长分布、负指数分布和几何分布等，排队规则有损失制、等待值和混合制等，排队方式分为单列、多列和循环队列。
对于经典的排队模型，可以用“顾客到达规律/服务时间分布/服务台数量/队列容量大小/服务规程”来描述。本文讨论的“M/M/m”模型指的是单柏松流输入多队列排队模型。
1.2 研究现状 排队论（Queuing Theory）起源于1909年丹麦电话工程师A. K. Erlang的工作，1917年，其发表了“The Theory of Probabilities and Telephone Conversations”，初步开始了对由于随机需求的出现而产生非稳态队列的现象的研究。Erlang之后，多名学者对其工作做了进一步拓展延伸，Thornton C. Fry 进一步整理的柏松输入，建立广义输出的单/多服务流模型[2]。而后的半个多世纪里，排队论主要为理论模型的发展，如生灭理论和嵌入马尔可夫模型。二战以来，学者开始为该理论赋予应用价值，大量研究开始导向如何精确求解先前学者留下的复杂数学模型，并直接应用于现实的管理决策中。近现代排队论主要为管理决策软件的开发提供理论与模拟支持。
虽然已经有了比较成熟的对排队系统随机过程的理论描述，但是由于理论研究的复杂性和局限性，特别是对复杂的多服务台排队系统的动态模拟问题来说，理论计算相当复杂。近年来得益于计算机技术的发展，更简单的仿真模拟方法成为优化排队问题的主要手段[3]。
1.3 性能评价指标 本文为了研究排队系统运行的效率，估计其服务质量，确定系统最有参数，评价系统结构并提出改进措施，故使用以下性能评价指标：
(1). 平均队长，指系统内顾客数（处于队伍中等待的和服务中的顾客）的数学期望，
记作 E ( L s ) E\left(L_s\right) E(Ls​).
(2). 平均排队长，指系统内等待服务的顾客数的数学期望，记作 E ( L q ) E\left(L_q\right) E(Lq​).
(3). 平均逗留时间，指顾客在系统内的逗留时间的数学期望，包括等待时间和服务时间，
记作 E ( W s ) E\left(W_s\right) E(Ws​).
(4). 平均等待时间，指一个顾客在排队系统中排队等待时间的数学期望，记作 E ( W q ) E\left(W_q\right) E(Wq​).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/016552145a06a8f9ae86735f2ab41350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6bfe20c5cb69a53816c17dd41e2fb73/" rel="bookmark">
			自然语言处理总复习（九）—— 机器翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然语言处理总复习（九）—— 机器翻译 一、概述1. 定义2. 分类3. 发展历史 二、机器翻译的技术路线实用化的策略 （一）基于规则1. 直接式翻译2. 转换式翻译（1）通过句法分析得到某种内部的结果化表达（2）变换句型（3）目标语言的形态生成 （二）基于实例基于实例的机器翻译问题 （三）基于统计1. 基于统计的原因2. 要素（1）数据（2）学习（3）搜索 3. 例子4. 基于词的统计机器翻译（IBM Models）（1）统计机器翻译系统（2）贝叶斯规则（3）统计机器学习的三个问题1）语言模型a. 经典的语言模型 —— N-Grams模型 1）翻译模型 三、机器翻译的评价四、利用互联网获取双语预料 一、概述 1. 定义 用计算机实现从一种自然语言（源语言/source language）到另一种自然语言（目标语言/target language）文本的翻译。
2. 分类 Human Assisted Machine Translation (HAMT) 人助机译Computer Aided Translation (CAT) 机助人译Fully Automatic Machine Translation (FAMT) 全自动机器翻译 3. 发展历史 二、机器翻译的技术路线 基于规则的机器翻译 —— 基于理性主义的方法；于实例和统计的机器翻译 ——经验主义的方法或者基于语料库的方法； 但是这种说法不是很确切。因为语料库已经用于所有的机器翻译开发中。只不过是直接应用还是间接应用。
实用化的策略 （一）基于规则 1. 直接式翻译 进行词汇的更换
2. 转换式翻译 （1）通过句法分析得到某种内部的结果化表达 （2）变换句型 （3）目标语言的形态生成 （二）基于实例 基于实例的机器翻译问题 （三）基于统计 1. 基于统计的原因 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6bfe20c5cb69a53816c17dd41e2fb73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100df206219fba56e54fad104b62ae03/" rel="bookmark">
			C&#43;&#43;中的::
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"::"在C++中表示作用域，和所属关系。"::"是运算符中等级最高的，它分为三种，分别如下：
一、作用域符号：
作用域符号”::“的前面一般是类名称，后面一般是该类的成员名称，C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分。
例如：A,B表示两个类，在A,B中都有成员member。
那么：
1、A::member就表示类A中的成员member。
2、B::member就表示类B中的成员member。
二、全局作用域符号：
全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分，例如：
三、作用域分解运算符：
::是C++里的作用域分解运算符，“比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。例如：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f5086dd1fbe4f7c7f9c45aef687f17/" rel="bookmark">
			2021-10-29
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“21天好习惯”第一期-7 今天学了一个猜数游戏的小程序，其中就用到了rand（）生成随机数的作用。下面是程序的具体情况：
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int main()
{
int a,b,c,d;
printf("boys,please enter your lovely number a,c\n");
scanf("%d%d",&amp;a,&amp;b);
c=sqrt(a*b+a)+a-b;
d=rand()%100;
if(c&gt;d)
{
printf("hi,boys");
printf("you guess the number c is not right");
}
else if(c&lt;d)
{
printf("hi,boys");
printf("you guess the number c is not right");
}
else
{
printf("hi,boys");
printf("you guess the number c is right");
}
return 0;
}
运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca296030b5fab8b5d5bf4064072a2c4f/" rel="bookmark">
			前端后端传数组的正确做法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端正常传值即可
var app = new Vue({ el: "#app", data: { arr:[1,2,3] }, mounted: function () {}, methods: { post:function(){ var that=this console.log(send) axios({ url : '/main/send', method: 'get', params: { array:that.arr } }) .then(function (res) { res=res.data console.log(res) }, function (err) { console.log(err) that.$message({ type: 'error', message: '服务器忙,请稍后再试...' }); }) } }, }) 后端需要做到一下三点:
1.添加tomcat配置,使得传的url中可以出现’[’ 符号,写在Application类中即可:
/** * 添加这部分代码使得url可以出现[ ] */ @Bean public TomcatServletWebServerFactory webServerFactory() { TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(); factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca296030b5fab8b5d5bf4064072a2c4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69cc350fa114f80eb9fecbc91da32b3/" rel="bookmark">
			高频面试题接雨水详解 - 单调栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 题目分析1.1 题目解析：1.1.1为什么该题可以使用单调栈？1.1.2 结算时的第一种情况1.1.3 结算时的第二种情况 2. 相关的模板总结2.1 单调递减栈 ： 求的是下一个更大的元素2.2 单调递增栈 ： 求的是下一个更小的元素2.3 维护的是一个单调递减栈2.4 维护的是一个单调递增栈 AC代码：
public int trap(int[] height) { int ans = 0; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); for(int i = 0; i &lt; height.length; i ++){ while(!s.isEmpty() &amp;&amp; height[s.peek()] &lt; height[i]){ int index = s.pop(); if(s.isEmpty()) break; int left = s.peek(); int min = Math.min(height[i],height[left]); ans += (min - height[index]) * (i - left - 1); } s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c69cc350fa114f80eb9fecbc91da32b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b909dfa01cecfbbf7d8b29d9f138148/" rel="bookmark">
			线性差分方程及其通解的一般求法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了线性差分方程的通解，从特征方程以及延迟算子两个方面介绍了相关概念。并且以AR(2)模型为例，详细介绍了2元线性差分方程的通解情况，另外有若干例题。最后还给出了此类问题矩阵形式，但才疏学浅未能求解。如果有大神路过，知道如何求解还请指点一二。
一、定义 1、线性齐次递推关系 一个常系数的k阶线性齐次递推关系是形如：
a n = c 1 a n − 1 + c 2 a n − 2 + ⋯ + c k a n − k ( n &gt; k ) a_n = c_1a_{n-1}+c_2a_{n-2}+\cdots+c_ka_{n-k} \ \ (n&gt;k) an​=c1​an−1​+c2​an−2​+⋯+ck​an−k​ (n&gt;k)
的递推关系，其中 c i , i = 1 , 2 , ⋯ , k c_i, i=1,2,\cdots,k ci​,i=1,2,⋯,k为常数， c k ≠ 0 c_k\ne0 ck​​=0， { a n } n = 1 ∞ \{a_n\}_{n=1}^{\infty} {an​}n=1∞​是一个序列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b909dfa01cecfbbf7d8b29d9f138148/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3615f8a61dcac661dbb7250b649a9595/" rel="bookmark">
			4511或74LS48来实现BCD转7段数码管及逻辑状态输入演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字电路中常常需要设定一个逻辑输出以测验预定的结果，那么proteus就提供了这么一个元器件，logic state indicator。
我们辅助加入4511的BCD转7段数码管显示的芯片，通过设定逻辑编码值，我们可以看到仿真预定的显示结果非常的理想。
当然，我们使用74LS48也是一样的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b73c54e1b303776fd3d5b53b0f1166/" rel="bookmark">
			AUTOSAR架构介绍（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		架构从上往下分别是:
应用软件层(ASW)
RTE层 (RTE)
基础软件层(BSW)
微控制器层(MCAL)
软硬件分离的分层设计，对于OEM及供应商来说，提高了系统的整合能力，尤其标准化交互接口以及软件组件模型的定义提高了各层的软件复用能力，从而降低了开发成本，使得系统集成与产品推出的速度极大提升。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e091d943ff56750da80490c2b6470b77/" rel="bookmark">
			Markdown 使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
无序列表：Ctrl/Command + Shift + U
有序列表：Ctrl/Command + Shift + O
检查列表：Ctrl/Command + Shift + C
插入代码：Ctrl/Command + Shift + K
插入链接：Ctrl/Command + Shift + L
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e091d943ff56750da80490c2b6470b77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9104e882e841bd2639d8d46fa4f56e27/" rel="bookmark">
			用U盘安装ubuntu系统的具体步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用U盘安装ubuntu系统的具体步骤 1.制作启动盘（已配置好的主机）2.下载ubuntu系统（新机器）3.安装net tool并更新（新机器）4.下载ssh服务器（新机器） 1.制作启动盘（已配置好的主机） （1）将U盘插到Linux主机上（已经安装好系统并存有ubuntu20.04镜像）确认U盘路径，在终端中输入：sudo fdisk -l或者lsblk
（2）格式化U盘：sudo mkfs.ntfs -f /dev/sdb1
（3）使用dd命令，格式如下：sudo dd if=xxx.iso（镜像位置） of=U盘路径
例：sudo dd if=/home/yzc/ubuntu-20.04-desktop-amd64.iso of=/dev/sdb，回车执行，系统就开始制作启动盘了，期间终端命令窗口不会有任何反馈。
制作成功后，如图所示：
2.下载ubuntu系统（新机器） （1）在新机器上插入u盘，并重启（ctrl+alt+del）按住键盘的F7和F12进入bios
（2）选择U盘为启动盘，回车确认后，即进入U盘的ubuntu系统
（3）新机器install ubuntu（按照需求安装即可，网上也有很多教程）
（4）重启并拔掉U盘（等待提示再拔掉U盘）
3.安装net tool并更新（新机器） （1）终端输入ifconfig 确认是否有网络
（2）sudo apt-get update
4.下载ssh服务器（新机器） sudo apt-get install openssh-server
注：本文主要针对新机器安装ubuntu的操作步骤，其中制作启动盘是本文的关键所在，安装net tool和SSH服务是为了其他设备更好使用ssh服务远程登陆新机器，没有展开细说。欢迎大家点赞留言并转发，期待与你的交流！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e7d6fb9fcdff6b28a7c8647c1e8c02/" rel="bookmark">
			关于报错‘TypeError: ‘float‘ object is not callable’的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近出现了这个报错，查了很多相关的解决办法发现在自己的代码中解决不了，在无数次尝试之后才发现了更正的办法，原因未知。
废话不多说，先放代码：
def sigma(y, y_pred, x): return (np.sum((y - y_pred)**2) / (len(x) - int(2)))**0.5 sigma = float(sigma(y, y_pred, x)) sigma1 = float(sigma(lny, lny_pred, x)) 当我定义一个函数，应用一次时没问题，用第二次就会报错
更改如下：
def sigma(y, y_pred, x): return (np.sum((y - y_pred)**2) / (len(x) - int(2)))**0.5 sigma0 = float(sigma(y, y_pred, x)) sigma1 = float(sigma(lny, lny_pred, x)) 本人猜测可能是因为应用函数的时候不能定义为函数名称，如果函数和名称相同，在第二次使用函数的时候无法正确找到函数，只能找到第一个定义的值，就会报错。
所以，如果遇到函数不能应用两次，建议更改应用函数时的定义名称，不要与函数相同。
附完整错误代码：
import numpy as np import pandas as pd from sklearn.linear_model import LinearRegression dt = pd.read_csv('I://python/regression/P174.csv') y = dt[['R']] x = dt[['P']] lrModel = LinearRegression() lrModel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1e7d6fb9fcdff6b28a7c8647c1e8c02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd88f2a7fc27bd26fedafbc684d7c3cd/" rel="bookmark">
			mysql丢失更新问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql丢失更新问题英文叫lost update.指的是两个事务同时更新一条数据，后更新的覆盖了前面更新的结果，从结果上看第一次的更新丢失了的现象。脏读，幻读，不可重复读是读的问题，丢失更新是写的问题。其实现在数据库本身并没有丢失更新的问题，因为当一个事务更新一条记录时，就会加排他锁，另外一个的更新就会阻塞住。通常都是由于程序产生的。可以通过乐观锁的方式来解决这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ea9171d66265389c9787a099113a0f/" rel="bookmark">
			自然语言处理总复习（八）—— 文本聚类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然语言处理总复习（八）—— 文本聚类 一、聚类概述1. 目标2. 定义3. 用途（1）用于试探性数据分析（2）概念一般化（元素之间的可互换性） 4. 聚类算法与分类算法的区别5. 聚类算法分类 二、层级聚类（一）两种层级聚类算法1. 自底而上算法2. 自顶而下算法 （二）三种相似度函数计算方式1. 单连通聚类（1）概念（2）特点 2. 全连通聚类（1）概念（2）特点 3. 平均连通聚类（1）概念（2）算法1）算法描述2）点与点之间的相似度度量方法3）平均相似度的定义4）减少计算量推导过程 三、非层级聚类（一）基本思想（二）两种典型的非层级聚类算法1. K平均算法（1）介绍与特点（2）基本过程描述（3）算法小结 2. EM算法（1）特点 一、聚类概述 1. 目标 2. 定义 3. 用途 （1）用于试探性数据分析 当我们面临一个新问题，并且希望建立一个概率模型或者仅仅是为了理解现象的基本特性时，这是一个首要步骤。对于不懂英语的人也能通过下面的聚类树图对英文的词性有大致的了解。 （2）概念一般化（元素之间的可互换性） 4. 聚类算法与分类算法的区别 5. 聚类算法分类 二、层级聚类 （一）两种层级聚类算法 1. 自底而上算法 2. 自顶而下算法 （二）三种相似度函数计算方式 1. 单连通聚类 （1）概念 单连通聚类：两个集合间最相似样本之间的相似度。
（2）特点 拉长聚类区域（链式效应）；没有考虑全局情况（a/e和a/d）；
2. 全连通聚类 （1）概念 全连通聚类：
两个集合间最不相似样本之间的相似度；考虑到了全局因素，避免了单连通算法中“拉长”区域的产生；
（2）特点 比较而言，全连通聚类更适合统计自然语言处理的要求；主要缺点在于它的算法复杂度是O(n3) 3. 平均连通聚类 （1）概念 集合内部样本之间的平均相似度；是上述两种方法的折中方案；计算复杂度只有O(n2) （2）算法 1）算法描述 算法每次迭代都确定两个集合 c u c_u cu​和 c v c_v cv​，使得 S ( c u ∪ c v ) S(c_u \cup c_v) S(cu​∪cv​)最大（新点集的相似度最大），然后将这两个集合合并。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2ea9171d66265389c9787a099113a0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6a9d4fb702fa759d3ed195fc994931/" rel="bookmark">
			MySQL—事务并发问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脏读（Dirty read） 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
不可重复读 （Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
幻读 （Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
不可重复度和幻读区别： 不可重复读的重点是修改，幻读的重点在于新增或者删除。
解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表 例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。
例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f67b472f9f5453826694566e64cbd7/" rel="bookmark">
			Go -- log日志库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、标准库log介绍1、使用Logger2、配置logger2.1、标准logger的配置 二、自定义日志库1、需要满足的需求2、了解下runtime包3、自定义日志库 一、标准库log介绍 Go语言内置的log包实现了简单的日志服务。 1、使用Logger log包定义了Logger类型，该类型提供了一些格式化输出的方法。log包也提供了一个预定义的“标准”logger，可以通过调用函数Print系列(Print|Printf|Println）、Fatal系列（Fatal|Fatalf|Fatalln）、和Panic系列（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。 logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。
示例： // 直接调用print来输出日志到终端 func main() { log.Println("这是一条很普通的日志。") v := "很普通的" log.Printf("这是一条%s日志。\n", v) log.Fatalln("这是一条会触发fatal的日志。") log.Panicln("这是一条会触发panic的日志。") } 2、配置logger 2.1、标准logger的配置 默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。log标准库中为我们提供了定制这些设置的方法。log标准库中的Flags函数会返回标准logger的输出配置，而SetFlags函数用来设置标准logger的输出配置。 二、自定义日志库 1、需要满足的需求 1、支持网不同地方输出日志2、日志要支持开关控制3、完整的日志要包含时间、行号、文件名、日志级别、日志信息4、日志文件要能切割5、日志级别 DebugTraceInfoWarningErrorFatal 2、了解下runtime包 runtime.Caller() 方法，会返回函数调用的信息，在()内传入int类型数据，代表调用的层数（0代表第一层被调用，1代表第二层，一次类推）。runtime.Caller()返回如下四个参数: pc: 记录了调用的函数消息，如函数名等file: 调用的文件名line: 行数OK: 返回的bool值 // 获取代码行号 func getinfo(n int) { /* runtime.Caller()返回四个参数: pc: 记录了调用的函数消息，如函数名等 file: 调用的文件名 line: 行数 OK: 返回的bool值 */ pc, file, line, ok := runtime.Caller(n) if !ok { fmt.Printf("runtime.Caller() failed\n") return } fmt.Println(pc) // 用于调用函数消息 funcName := runtime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95f67b472f9f5453826694566e64cbd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f61e79878e67b297a1c80693d57018e/" rel="bookmark">
			IP地址，开放端口，http与https的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、IP地址的概述二、IP地址分类1、**共有地址**2、 **私有地址** 三、IPV4和V6四、子网掩码、网关、DNS1、 子网掩码2、网关3、DNS服务器 五、获取目标IP地址的方法1、 通过ping命令：2、 通过NSLOOKUP命令：1.使用资源监视器查看：2.使用命令查看： 六、查询信息七、端口1、 端口分类2、 常见端口 八、http和https1、http:2、https:3、http与https的区别 一、IP地址的概述 IP是Internet Protocol的缩写，意思是“互联网互联的协议”，也就是计算机网络相互连接和进行通信而设计的协议，也可以称为“因特网协议”。 IP地址是一个32位的二进制数，通常被分为四个“八位二进制数”（也就是四个字节）； IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中a、b、c、d都是0~255之间的十进制整数。例如点分十进制IP地址（100.4.5.6），实际上就是32位二进制数（01100100.00000100.00000101.00000110）。 IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A,B,C是基本类，D,E作为多播和保留使用。
二、IP地址分类 1、共有地址 共有地址（public address）由Inter NIC（Internet Network Information Center因特网信息中心）负责；这些IP地址分配给注册并向Inter NIC提出申请的组织机构，通过它就可以访问因特网。
​ A类IP地址范围：1.0.0.0~127.255.255.255
​ A类IP地址的子网掩码：255.0.0.0
​ B类IP地址范围：128.0.0.0~191.255.255.255
​ B类IP地址的子网掩码：255.255.0.0
​ C类IP地址范围：192.0.0.0~223.255.255.255
​ C类IP地址的子网掩码：255.255.255.0
​ D类IP地址范围：224.0.0.0~239.255.255.255
​ 又称为多播地址，它的最高位必须是1110
2、 私有地址 ​ 除去共有地址外，还需要了解常用的三类私有地址，私有地址主要用于解决IP地址不足的问题。
​ A类：10.0.0.0~10.255.255.255
​ B类：172.16.0.0~172.31.255.255
​ C类：192.168.0.0~192.168.255.255
三、IPV4和V6 现有的互联网是在IPV4协议的基础上运行的。IPV6是下一版本的互联网协议。
四、子网掩码、网关、DNS 1、 子网掩码 从逻辑上把一个大网络划分为一些小网络。子网掩码是由一系列的0和1构成，通过将其IP地址做“与运算”，来指出一个IP地址的网络号是什么 2、网关 实质上是一个网络通向其他网络的IP地址。只有设置了网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。 3、DNS服务器 ​ 是计算机域名系统（Domain Name System或Domain Name Server）的缩写，是一种组织成域层次结构的计算机网络服务命名系统，它是由解析器和域名服务器组成的，用于TCP/IP网络。
​ 域名服务器是指保存有该网络中所有主机的域名和对应的IP地址，并具有将域名转换成IP地址功能的服务器。其中，域名必须对应一个IP地址，而IP地址不一定有域名。域名系统采用类似目录树的等级结构。域名服务器为客户机/服务器模式中的服务器方，它主要有两种形式：主服务器和转发服务器。将域名映射为IP地址的过程就是叫做“域名解析”，如果用户对此感兴趣，可以了解Windows的域，可以自行搭建DNS服务器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f61e79878e67b297a1c80693d57018e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf81d7424449ab5c6033844987196456/" rel="bookmark">
			JS判断某个字符串是否包含另一个字符串的5种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文给大家带来JS中判断某个字符串是否包含另一个字符串的五种方法，有string对象的方法，match() 方法，RegExp对象的方法，test() 方法，exec() 方法，具体内容详情大家参考下本文：
String对象的方法： 方法一：indexOf()（推荐）
var str = "123" console.log(str.indexOf("2") != -1); // true indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。
方法二：match()
var str = "123" var reg = RegExp(/3/); if(str.match(reg)){ //包含； } match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。
方法三：search()
var str = "123" console.log(str.search("2") != -1); // true search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。
RegExp对象的方法： 方法四：test()
var str = "123" var reg = RegExp(/3/); console.log(reg.test(str) != -1); // true test() 方法用于检索字符串中指定的值。返回 true 或 false。
方法五:exec()
var str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf81d7424449ab5c6033844987196456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a7444c0d1bf893b810d9993edcbd45/" rel="bookmark">
			自然语言处理总复习（七）—— 概率上下文无关文法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然语言处理总复习（七）—— 概率上下文无关文法 一、背景介绍（一）问题提出（二）上下文无关文法（CFG） 二、概率上下文无关文法（PCFG）（一）定义（二）符号定义（三）应用举例1. 举例2. 规则的概率估计Penn树库 （四）PCFG的基本问题1. 给定一个语法，如何计算一个句子的概率？ P ( w 1 m ∣ G ) P(w_{1m}|G) P(w1m​∣G)（1）相关定义（2）利用内部概率计算句子概率a）内部算法 —— 基于内部概率的动态规划算法b）内部算法 —— 举例 （3）利用外部概率计算句子概率 2. 已知语法，如何计算一个句子最可能的分析树 P ( t ∣ w 1 m , G ) P(t|w_{1m},G) P(t∣w1m​,G)句法分析结果的评估 3. 已知一个句子，如何设定语法的规则概率，才能使该句子的概率最大？ arg ⁡ max ⁡ G P ( w 1 m ∣ G ) \mathop{\arg\max}\limits_{G} P(w_{1m}|G) Gargmax​P(w1m​∣G) （五）PCFG的问题及解决方法PCFG独立性假设的弱化1. 方案一：词汇化2. 方案二：结构化上下文的概率依存 （六）其他句法分析方法1. 依存语法2. 其他句法分析方法3. 一些可免费使用的句法分析器 一、背景介绍 （一）问题提出 自然语言是一种非线性的符号序列，句子结构的表现为复杂的嵌套性。
N-gram 和 HMM 模型只能处理线性序列，分析过程中就会面临一些问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a7444c0d1bf893b810d9993edcbd45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18bb6ec8359f97ea5e77f3b0868c24f/" rel="bookmark">
			LeetCode 416. 分割等和子集 【c&#43;&#43;/java详细题解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自专栏《LeetCode高频面试题》 欢迎订阅 目录 1、题目2、思路3、二维c++代码4、二维java代码5、一维优化6、一维c++代码7、一维java代码 1、题目 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
示例 1：
输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2：
输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。 提示：
1 &lt;= nums.length &lt;= 2001 &lt;= nums[i] &lt;= 100 2、思路 (动态规划) O ( n ∗ m ) O(n * m) O(n∗m)
给定一个只包含正整数的非空数组 nums[0]，判断是否可以从数组中选出一些数字，使得这些数字的和恰好等于整个数组的元素和的一半。
样例：
如样例所示，nums = [1,5,11,5]，数组可以分割成 [1, 5, 5] 和 [11]，因此返回ture。
从题意来看，这个问题可以转换成0-1背包问题，如何看出来的? 我们不妨将换种表述方式：
将大小为n的数组看成n件物品，数组元素和sum的一半看成一个容量为sum / 2的背包， 每件物品只能使用一次，每件物品的体积是nums[i]，求解是否可以选出一些物品，使得这些物品的总体积恰好为背包的容量，因此可以使用动态规划求解，下面我们来讲解具体做法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18bb6ec8359f97ea5e77f3b0868c24f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/863b5a8a523bbba71c92a49ddbfa81d7/" rel="bookmark">
			单例模式和工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式和工厂模式 文章目录 单例模式和工厂模式 一、单例模式1.懒汉式2.饿汉式 二、工厂模式1.简单工厂模式2.工厂方法模式3.抽象工厂模式 总结 一、单例模式 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
主要解决：一个全局使用的类频繁地创建与销毁。
举例：操作一个文件，应该用一个唯一的实例去操作。
1.懒汉式 当使用的时候再实例化，节省空间。
加上synchronized锁保证线程安全。
public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 2.饿汉式 当加载类的时候就实例化，浪费空间。
不用加synchronized锁，效率更高。
public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 二、工厂模式 工厂类模式设计的核心是：让“生产”和“产品”解耦。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/863b5a8a523bbba71c92a49ddbfa81d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db464829642f98a394ccfc579c8d441d/" rel="bookmark">
			Pytorch学习笔记(5)——交叉熵报错RuntimeError: 1D target tensor expected, multi-target not supported
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我使用交叉熵做损失函数时，发生了报错：
RuntimeError: 1D target tensor expected, multi-target not supported 我查了相关资料，里面的说法基本都是：
输入labels维度应该为1维，且精度不能是Double，必须换成long；对输入标签进行降维。 但是却没法解决我的问题，因为我的标签数据在处理好后，用以下代码处理过：
torch.LongTensor(labels) 而且我也打印过我的标签数据的维度：
torch.Size([16, 11]) 这里16指的是batch_size，所以也不是维度的问题。
但是我在看这篇博客（RuntimeError: multi-target not supported at）的时候给了我灵感。里面写的是：
pytorch 中计计算交叉熵损失函数时， 输入的正确 label 不能是 one-hot 格式。函数内部会自己处理成 one hot 格式。所以不需要输入 [ 0 0 0 0 1]，只需要输入 4 就行。
而我的标签数据是多标签问题，如下：
tensor([0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0]) 那么在经过loss的时候，CrossEntropyLoss会自动为其编码为one-hot编码，这样就会导致其升高一维，变为了：
tensor([[1., 0.], [0., 1.], [1., 0.], [1., 0.], [0., 1.], [1., 0.], [1., 0.], [0., 1.], [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db464829642f98a394ccfc579c8d441d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2890ea28d54e486389c28a04a7e1ff/" rel="bookmark">
			字符数组入门（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符数组入门 一、字符数组1、字符串转化成字符数组2、字符数组转化成字符串 二、字符串数组1、字符串数组转化成字符串2、字符数组转化成字符串 一、字符数组 1、字符串转化成字符数组 输出如下
---------------------------------------------------------------------------------
输入如下
2、字符数组转化成字符串 在new新的字符串的时候把字符数组传进去就行，如
String 字符串名 = new String(字符数组); 二、字符串数组 1、字符串数组转化成字符串 结果为
2、字符数组转化成字符串 结果是
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/484827e69f872a3075d16d712a7e44f6/" rel="bookmark">
			小猫爪：S32K3学习笔记05-S32K3之ADC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小猫爪：S32K3学习笔记05-S32K3之ADC 1 前言2 资源简介3 ADC功能详解3.1 ADC mux-mode channels3.2 ADC内部框架3.3 时钟源3.4 通道类型3.5 触发信号3.5.1 标准触发3.5.2 注入触发3.5.3 BCTU触发 3.6 校准和自检3.6.1 校准3.6.2 自检 3.7 模拟门狗3.8 DMA和中断3.9 转换时间的计算 4 使用注意事项4.1 CDR寄存器 5 MCAL配置待续。。。。。 1 前言 今天学习了一下S32K3的ADC模块，接下来做个总结。
2 资源简介 下表是S32K3各型号拥有的ADC模块。
下表是三个ADC模块拥有的体征：
可以看到对于ADC的通道有Precision channels,Standard channels,Special Internal channels,External channels之分，至于这些类型的通道都有什么不同，还有这个图上的信息有点问题，后面会详细说到。
表中还有一个BCTU trigger，这个就是一个硬件触发模块，可以通过配置BCTU去触发ADC转换，之后ADC转换的结果会传递到BCTU模块，一般在电力电子，电机控制应用中比较常见，后面会专抽一章来介绍BCTU。
3 ADC功能详解 3.1 ADC mux-mode channels 这个指的就是一个pad可能会对应多个ADC通道，可以通过DCM寄存器中每个通道对应的GPR位来设置。下图例举了几个例子：
所以说如果配置了一些PAD复用成AI后，还得观察一下这个PAD是否为ADC通道的默认引脚，如果不是的话，还得需要配置一下DCM寄存器。
3.2 ADC内部框架 下图是ADC模块的内部框架图。
乍一看上去巨复杂，但是要是仔细稍微那么一看，其实这个ADC模块也就是个纸老虎，非常简单。
说得简单点就是当ADC接收到触发信号后，就会开始启动转换，转换完成后就会生成转换结果，DMA请求信号以及中断信号，如果使能了看门狗功能，还会输出看门狗的信号。
说得复杂细致点，步骤如下：
当ADC接收到三种不同类型的触发器（BCTU、注入或正常）中的一种时，优先级多路复用器启动转换。根据触发器类型和自检得配置，被选择的通道输入被转换状态机（FSM）从空闲状态转换为转换状态。如果下一次要转换的通道为外部通道，那么转换在DSDR[DSD]配置的延迟后开始。转换开始后，转换控制块将保持内部电容网络CDAC保持相同的CTRi[INPSAMP]的时间。在比较阶段，CALBISTREG[RESN]定义了用于执行逐次逼近算法的步数。校准期间确定的误差校正值将添加到原始结果中。如果平均值被启用（MCR[AVGEN]=1），最多32个（通过MCR[AVGS]指定）转换结果被平均以获得后果。当转换完成且所有平均步骤均已完成时：
A. 转换完成信号置位。
B. 转换_数据[14:0]写入数据结果寄存器。
C. FSM状态机切换为完成状态。通道选择块中的下一个输入被选择，FSM状态机切换到转换状态，第二次转换开始。这将持续进行，直到所有选定的通道输入都已转换。如果启用了模拟看门狗，则将转换结果与配置的阈值进行比较。如果满足条件，可以触发中断。自检可以检查ADC的完整性，可以与正常转换交错进行，也可以作为独立检查。如果正在进行的转换被中止（通过将1写入MCR[ABORT]），或一组输入通道的转换被中止（通过将1写入MCR[ABORTCHAIN]），FSM将转换为空闲状态。如果MCR[ABORT]写1，则转换控制块停止当前转换；如果MCR[ABORTCHAIN]写1，则完成当前转换再中止转换。在这两种情况下，转换控制块的转换完成输出信号都会被置1。 3.3 时钟源 ADC模块最高可支持的时钟频率到达80MHz，如果选择的时钟源超过80MHz的话，那么就需要设置ADC时钟分频器系数，是最后的ADC时钟在80MHz以内。下图显示在各个时钟源区间的分频设置，其中MCR[ADCLKSEL]设置分频系数，AMSIO[17]使能高速转换模式。
3.4 通道类型 在一开始就说了由4种输入通道类型，分别是Precision channels,standard channels,special internal channels，那么这4种分别代表什么呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/484827e69f872a3075d16d712a7e44f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892830a368536aaecfae487455821bdb/" rel="bookmark">
			毛星云opencv之5.5傅里叶变换原理介绍（关于图像高频--代表细节和低频--代表轮廓）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce68c2fe5b2dae4a3c0a42a4c648b74f/" rel="bookmark">
			保姆式教程教你如何一步步在window10系统下安装mindspore框架&#43;pycharm导入python遇到的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、卸载电脑中原有的python文件2、安装3.7.5版本的python3、安装mindspore4、在pycharm里面使用下载的3.7.5版本的python 【前言】 为了下载mindspore框架，我的python可谓是删了又下，下了又删除。一波n折，可算是可以运行了！！！
先是去官方文档中找寻下载方案，由于只能下载3.7.5和3.9.0版本的python，但是官方文档提供的是Linux操作系统的下载链接，只好自己去官网找3.9.0版本的文件，下载了以后说我的python已经下载过了，我只好将python3.9.5卸载，然后下载了3.9.0，后续确实安装成功了mindspore，但是不知道什么原因，我的numpy，pandas，sklearn库并不能用pip install 安装，我麻木了。我只好卸掉这个3.9.0，然后转去安装3.7.5，但是遇到一个问题是，我在系统里面卸载不掉python3.9.0，还莫名的跳出了一个3.7.8，我直接人傻了。在小c站到处找，最后终于安装成功，昨天晚上PyCharm居然不能运行我安装的3.7.5，我都快崩溃了，最终！！！今天中午12点多，我捣鼓捣鼓，把文件捣鼓出来了，终于！！！没问题了，我是真的激动！！下面我来给大家讲解一下哎，我的安装失败路程，如果有相同遭遇的友友们，可以直接借鉴，感谢这三天我搜索到的博客up主，是你们救了我，我现在来拯救更多和我一样无助的人啦~
1、卸载电脑中原有的python文件 文件资源管理器 - 卸载或者更改程序 - 搜索python - 点击你要删除的python文件 - 修改 - repair - 开始卸载
点击：卸载或者更改程序
搜索：python
修改python位置
卸载python
2、安装3.7.5版本的python 这里面有下载链接，我也是在这个博主下面下载的才进去的：
下载链接
自动配置环境变量
3、安装mindspore 前往官方文档： 官方文档链接
下载选项
以管理员身份打开cmd
按照官方文档下的pip代码，直接粘贴下载
判断是否下载成功
4、在pycharm里面使用下载的3.7.5版本的python File - settings - 找到指定的文件 - 进入“python interpreter ” - 导入自己的python路径 - 即可运行
修改pycharm的python版本
进入pycharm换装界面
添加刚刚下载的python3.7.5
找到python的安装路径，直接在cmd中输入where python 即可找到路径
最后，验证mindspore可使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0ed9a7623d55404ada37047ea082e2/" rel="bookmark">
			hbase kerberos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：HBase ThriftServer Kerberos认证 - 程序员大本营
1.前置 用户可以通过ThriftServer来访问HBase服务，它的特点如下：
ThriftServer代理用户访问HBase服务返回操作结果，用户客户端不需要直接跟HBase进行通信用户可以使用java/python/php/c++等语言的Thrift客户端代码访问HBase服务(HBase本身客户端只支持java语言) 2. Kerberos下的ThriftServer使用 如果HBase集群开启了Kerberos认证(E-MapReduce可一键创建安全集群，非常方便)，那么用户怎么通过ThriftServer访问HBase服务呢？
2.1 ThriftServer配置Kerberos
ThriftServer其实是HBase服务的客户端，既然HBase开启了Kerberos认证，那么ThrifServer也必须配置Kerberos的信息才能正常访问HBase集群服务。
在ThriftServer的hbase-site.xml文件中添加新配置:
&lt;property&gt;
&lt;name&gt;hbase.security.authentication&lt;/name&gt;
&lt;value&gt;kerberos&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hbase.thrift.kerberos.principal&lt;/name&gt;
&lt;value&gt;hbase/_HOST@EMR.123456.COM&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hbase.thrift.keytab.file&lt;/name&gt;
&lt;value&gt;/etc/ecm/hbase-conf/hbase-thrift.keytab&lt;/value&gt;
&lt;/property&gt;
上述配置中实际值以用户为准(principle和keytab需对应)。
2.2 ThriftClient访问ThriftServer
用户使用python/java/php等Thrift客户端访问ThrifServer有两种方式：
2.2.1 ThriftServer不对Client进行身份认证
任何用户都可以通过ThriftServer访问HBase服务，而且都是以ThriftServer本身配置的hbase.thrift.kerberos.principal中的用户名去访问HBase服务，即对HBase服务来说只有一个固定的用户来访问。
如下图所示：
这种方式使得HBase集群的Kerberos认证无效，不适合使用开启了Kerberos的场景。
2.2.2 ThriftServer对Client进行身份认证
ThriftServer可以开启对Client进行身份认证，而且以实际的用户身份访问HBase服务。
需要做如下配置：
ThriftServer的hbase-site.xml中增加新的配置： &lt;property&gt;
&lt;name&gt;hbase.thrift.security.qop&lt;/name&gt;
&lt;value&gt;auth&lt;/value&gt;
&lt;/property&gt;
其中hbase.thrift.security.qop可以是auth/auth-init/auth-conf中的一个
HBase集群的所有节点core-site.xml中增加新的配置： &lt;property&gt;
&lt;name&gt;hadoop.proxyuser.$user.hosts&lt;/name&gt;
&lt;value&gt;*&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hadoop.proxyuser.$user.groups&lt;/name&gt;
&lt;value&gt;*&lt;/value&gt;
&lt;/property&gt;
备注:
a) $user为ThriftServer本身配置的hbase.thrift.kerberos.principal中的用户
b) 重启HBase集群(无需重启HDFS)
3. 代码示例 上述2.2.2节的场景代码
3.1 python
参考github上一个项目: GitHub - joshelser/hbase-thrift1-python-sasl: Python client code for Apache HBase 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de0ed9a7623d55404ada37047ea082e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd6a6de9a73d5abb6ff6e54a17668d7/" rel="bookmark">
			【meshlab使用指南】01、删除点云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1 1：画一个多边形，按Q选中多边形内的点云
2：仅删除点
3：仅删除面
4：删除点和面
示例：
方法2 按钮1：矩形选中
按钮2：删除
示例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadff0ce48a7da242097cff1a0de61cb/" rel="bookmark">
			kettle案例11-排序记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考《ETL数据整合与处理》--任务3.1
排序是对数据中心的无序记录，按照自然或客观规律，根据关键字段大小递增或递减的次序，对记录重新排列的过程。
为了得出学生的成绩排名，需要对“2019年11月月考数学成绩.xls”文件，使用【排序记录】组件，对学生的成绩从低到高排序。
参数名称
说明
步骤名称
表示排序组件名称，在单个转换工程中，名称必须唯一。默认值是【排序记录】组件名称
排序目录
表示排序时存放临时文件的目录，可以直接键盘设置，也可以单击【浏览(B)…】按钮，设置为计算机上已存在的目录。默认值是当前系统标准临时文件目录%%java.io.tmpdir%% 临时文件前缀
表示临时文件前缀名称，排序时使用临时文件，可以加快和方便排序。当行数超过指定的排序大小时候，系统将使用临时文件排序行。默认值为out
排序缓存大小
表示存放在内存的记录数，存储在内存中的记录越多，排序过程就越快。默认值为1000000
未使用内存限值(%)
表示未使用内存的百分比限值。排序时，如果发现可用的空闲内存少于指定的数字，系统将会将数据分页到磁盘。默认值为空
压缩临时文件
表示需要临时文件来完成排序时，是否压缩该临时文件。默认值为空
仅仅传递非重复的记录
表示是否启用仅向输出流传递唯一的记录。默认值为空
字段
表示参加排序的字段，使用一个【字段】表来设置字段的参数。有关排序字段参数的说明如下表所示 字段参数
说明
字段名称
指定排序的字段名称，可用多个字段进行组合排序。可以直接键盘输入，也可以单击输入框，从下拉框中选中输入流的字段，还可以点击图 3‑3所示的【获取字段】按钮，获取所有字段进行编辑，保留需要排序的关键字段，删除不参加排序的字段
升序
对指定的字段制订排序方向（升序/降序），选项有：是、否
大小写敏感
指定的排序时是否区分大小写，选项有：是、否
Sort base on current locale?
是否根据当前位置排序，选项有：是、否
Collator Strength
指定排序器强度，选项有：0、1、2、3
Presorted?
是否进行预排序，选项有：是、否
执行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6608f85f867853ded92b47d05e9232f/" rel="bookmark">
			Ubuntu20.04 Ubuntu18.04安装opencv &#43; opencv_contrib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近编译视觉slam十四讲的特征点部分，需要用到opencv的一些模块库，其中就需要opencv-contrib。opencv3以上的版本没有opencv-contrib，所以需要一起安装。由于尝试了好多方法，今天特意写篇帖子记录一下，给有需要的同志使用，也让自己以后好查询怎么安装。
按照我写的步骤去操作，Ubuntu20.04和Ubuntu18.04都可以安装，安装方法是一样的，我亲自在两台电脑上尝试过一台R7000（Ubuntu20.04）另一台Y9000P（Ubuntu18.04）
下面的图片是Ubuntu20.04的：
以ubuntu20.04为例：
opencv-3.4.15
opencv_contrib-3.4.15
一：下载opencv-3.4.15和opencv_contrib-3.4.15（一定要把文件下载齐全）（版本号一定要对应） 1.opencv版本下载（根据你自己需要）： Releases · opencv/opencv · GitHubOpen Source Computer Vision Library. Contribute to opencv/opencv development by creating an account on GitHub.https://github.com/opencv/opencv/releases
2.opencv_contrib版本下载（根据你自己需要）： Tags · opencv/opencv_contrib · GitHubRepository for OpenCV's extra modules. Contribute to opencv/opencv_contrib development by creating an account on GitHub.https://github.com/opencv/opencv_contrib/tags
特别注意：opencv和opencv_contrib版本号要一样。
下载好之后，立一个新的opencv文件夹，放在video文件夹（你可以放在downloads文件夹下面，请随意）下，再把两个文件解压好放在opencv文件夹里面。
二：安装相关依赖 sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6608f85f867853ded92b47d05e9232f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa819024f83bbf43b188d2a106d1a80/" rel="bookmark">
			易康ESP图像分割插件安装及其安装包下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP插件包括（1）ZedGraph.dll（2）ESP_estimation_scale_parameter.dcp（3）ESP_Estimation_Scale_Parameter_Chart.exe
首先把包含插件文件的文件夹放在纯英文目录下。
（1）ZedGraph为dll应用程序拓展文件，把它放在易康安装目录下的D:\Program Files (x86)\eCognition Developer 64 8.9\bin\plugins
（2）打开ecognition软件，建立工作区，导入影像，在Process菜单的Load Rule Set导入ESP_estimation_scale_parameter.dcp， 点击OK后完成。
（3）在在Process菜单下打开Process Tree，在Process Tree窗体空白处右键Append New。
在Algorithm算法一栏中选择ESP插件。
ESP2是2014年最新版，ESP是2010版。
注意这里参数设置，在参数设置选项里，Produce LV Graph，设置为0 时，不生成.txt 文件；设置为 1 时自动生成.txt。生成的文件就保存在你原始影像的存放位置，自动命名成****.Hierarchy_BU（其中**表示你的工程文件名） ，这里的TXT文件就是后面要用到的评估文件。参数设置完毕后，点击Execute后软件即可运行，也可Process Tree中选中ESP，右键Execute来运行。
（4）运行结果
运行结束后在Select Active map下选择Hierarchy_B-Up及可看到结果。
（5）最后在原始影像文件夹里找到（工程名）.Hierarchy_BU.txt文件，将其导入ESP_Estimation_Scale_Parameter_Chart.exe应用程序中分析。
（折线图可以根据需要，把鼠标挡在图中转动中间滚轮来放大缩小）
图中可清晰地看出峰值的存在。在找到峰值以后，可直接用峰值对应的分割尺度做多尺度分割实验，寻找每种地物对应的最优尺度，省去了遍历尺度进行实验的不便。
具体地，在折线图上右击，可勾选Show point value工具，点选峰值以查看其对应尺度。
注意：有的同学设置ESP2算法后，虽然跑出了txt文件，但在Chart工具中计算后，未看到峰值，而是平滑的或陡峭的曲线。这种情况很常见，主要是由于各层分割的起始尺度设置不合适引起的，可以从20开始尝试，20、50、80，不怎么复杂就能试出起始尺度为多少时才会出峰值。
文章转载至栾烟，原文链接：https://blog.csdn.net/huijie_7/article/details/85326504
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9b3fffd8524735c502c7cceff7aca4/" rel="bookmark">
			再谈对比学习：更好的对比样本选择，更好的对比效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		©PaperWeekly 原创 · 作者 | 张琨
学校 | 中国科学技术大学博士生
研究方向 | 自然语言处理
在之前的介绍中，我们对自监督学习（SSL）中的对比学习（CL）进行了简单介绍，然后针对对比学习中的采样方式进行详细的分析。由于对比学习的核心思想是在向量表征空间中将正样本（positive example）与锚点样本（anchor example）之间的距离拉近，将负样本（negative example）与锚点样本（anchor example）之间的距离拉远，因此，所选取的正负样本的质量直接决定了整个方法的效果。为此，有很多研究工作集中在对比学习的采样方法中，本文针对这些方法继续进行深挖，希望能够让大家对对比学习有更深入的认识，为大家带来一些微小的启发。
在接下来的介绍中，本文首先介绍了一个在自然语言中更巧妙使用数据增强的方法，避免了在 NLP 使用数据增强面临的数据质量的问题。接下来针对对比学习中的采样方式，分别从效率，假负样本更充分的利用，以及负样本难度的选择是如何影响模型效果的这几个方面进行简单介绍。
更好的自然语言处理样本生成（ConSERT ）[1]
在具体介绍针对正样本或者负样本的采样之前，首先介绍一个在自然语言处理中进行更好的数据增强的工作。该工作通过选择更合适的自然语言数据增强方法坍缩了 BERT 原生句子表示在表征空间存在的“坍缩”现象，同时也是一个标准的将对比学习应用在自然语言语义表征中的框架。
1.1 亮点
通过分析指出原生的 BERT 模型在句子语义表征中存在“坍缩”现象，即倾向于编码到一个较小的空间区域内，使大多数的句子对都具有较高的相似度分数，影响表征结果在具体下游任务中的表现
基于 BERT 模型提出了一种更好的对比学习方法，用于句子语义的表征
在监督实验，无监督实验，小样本实验中进行了充分的模型验证
1.2 方法 整体的模型框架图如下，相对于 BERT 模型而言思路非常简单，就是在输入到 encoder 的时候加了一个数据增强层。但作者进行了非常全面的考虑，例如为了避免直接从文本层面进行数据增强导致的语义变化问题，以及效率问题。作者提出直接在 embedding 层隐式生成数据增强样本，从而一方面避免以上问题，另一方面能够生成高质量的数据增强样本。
而在数据增强上，由于是在 embedding 层直接进行数据增强的，因此在这里作者选择了以下四种增强方式：
对抗攻击：通过梯度回传生成对抗扰动，将该扰动加到原本的 embedding 矩阵上
词序打乱：这个非常有意思，由于在 BERT 中是通过 position embedding 的方式显式指定位置的，因此直接将 position id 进行 shuffle 即可
裁剪：这部分分为两个粒度：a. 对某个 token 进行裁剪，直接将对应的 embedding 置为 0 即可，b. 对某些特征进行裁剪，即将 embedding 矩阵中对应列置为 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a9b3fffd8524735c502c7cceff7aca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c82430003bf81e65a5aee3ba9aba62f6/" rel="bookmark">
			自然语言处理总复习（五）—— 词义消歧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然语言处理总复习（五）—— 词义消歧 一、相关概念与预备知识（一）词义消歧1. 定义2. 词义消歧需要解决的三个问题3. 应用 （二）预备知识1. 有监督学习和无监督学习2. 伪词3. 算法效能评估 —— 上界和下界 二、有监督的消歧方法（一）基于贝叶斯分类的词义消歧1. 概念介绍及准备工作2. 计算公式推导3. 词义排歧算法（Disambiguation） （二）基于互信息的词义消歧1. 核心思想2. flip-flop算法（1）算法描述（2）算法应用举例 （一&amp;二）贝叶斯方法和互信息方法的比较（三）基于词典的词义消歧1. 核心原理2. 算法描述3. 算法伪代码4. 算法示例5. 算法总结 （四）基于义类词典的消歧1. 相关概念2. 方法过程步骤 （五）基于第二语料库翻译的消歧1. 相关概念2. 举例 三、有监督的消歧方法总结四、无监督的消歧方法（一）EM算法（Expectation-Maximization）1. 概念2. 算法流程 一、相关概念与预备知识 （一）词义消歧 1. 定义 （Word sense disambiguation, WSD）
确定一个歧义词的哪一种语义在一个特殊的使用环境中被调用。
2. 词义消歧需要解决的三个问题 3. 应用 （二）预备知识 1. 有监督学习和无监督学习 2. 伪词 3. 算法效能评估 —— 上界和下界 二、有监督的消歧方法 （一）基于贝叶斯分类的词义消歧 1. 概念介绍及准备工作 2. 计算公式推导 为了防止取值在 (0, 1) 范围内的数连乘趋近于0，加入log函数进行平滑：
3. 词义排歧算法（Disambiguation） for all sense s_i of w do: score(s_i) = log(P(s_i)) for all words w_j in the context of w do: score(s_i) += log(P(w_j | s_i)) end end choose s' = arg(s_i) max score(s_i) c h o o s e s ′ = arg ⁡ max ⁡ s i s c o r e ( s i ) choose \quad s' =\mathop{\arg\max}\limits_{s_i} score(s_i) chooses′=si​argmax​score(si​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c82430003bf81e65a5aee3ba9aba62f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e570166332fcdb2ed2e061cf05d7d8/" rel="bookmark">
			面试官：说说微信小程序的支付流程？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能
在小程序内可调用微信的API完成支付功能，方便、快捷
场景如下图所示：
用户通过分享或扫描二维码进入商户小程序，用户选择购买，完成选购流程
调起微信支付控件，用户开始输入支付密码
密码验证通过，支付成功。商户后台得到支付成功的通知
返回商户小程序，显示购买成功
微信支付公众号下发支付凭证
二、流程 以电商小程序为例
支付流程图如下所示：
具体的做法：
打开某小程序，点击直接下单
wx.login获取用户临时登录凭证code，发送到后端服务器换取openId
在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器
服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息
小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付
接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付
鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示
推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态
其中后端响应数据必要的信息则是wx.requestPayment方法所需要的参数，大致如下：
wx.requestPayment({ // 时间戳 timeStamp: '', // 随机字符串 nonceStr: '', // 统一下单接口返回的 prepay_id 参数值 package: '', // 签名类型 signType: '', // 签名 paySign: '', // 调用成功回调 success () {}, // 失败回调 fail () {}, // 接口调用结束回调 complete () {} }) 参数表如下所示：
三、结束 小程序支付和以往的网页、APP微信支付大同小异，可以说小程序的支付变得更加简洁，不需要设置支付目录、域名授权等操作
参考文献 https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_8_0.shtml
https://juejin.cn/post/6844903895970349064
--The End--
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e570166332fcdb2ed2e061cf05d7d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca55fafab429d2414638af57c7875e72/" rel="bookmark">
			计算机网络通信基础 物理层与数据链路层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 物理层 物理层是TCP/IP五层模型的最底层，它为数据通信的介质提供规范和定义。集线器是典型的工作在物理层的设备，它共享一个广播域，共享一个冲突域。
物理特性解决的问题机械特性指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置电器特性指明在接口电缆的各条线上出现的电压范围功能特性指明某条线上出现的某一电平的电压表示何种意义过程特性指明利用接口传输位流的全过程及各项用于传输的事件发生的合法顺序 0x02 数据链路层 数据链路层位于网络层与物理层之间，它负责数据链路的建立、维护与拆除，能够实现帧包装、帧传输、帧同步、帧的差错恢复以及流量控制。以太网是最常用的数据链路层协议。
以太网是一种计算机局域网技术。IEEE组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。以太网是应用最普遍的局域网技术，取代了其他局域网技术如令牌环、FDDI和ARCNET。
0x03 以太网 以太网（局域网组网规范）模拟了声音的传输，一个教室中一个人说话每个人都能听到（广播域），一个人说话的时候不能有第二个人说话（冲突域）。以太网采用CSMA/CD避免信号的冲突（集线器仅能建立一个信道，属于半双工模式；交换机能够建立多个信道，属于全双工模式）。
CSMA/CD工作原理：发送前先监听信道是否空闲，若空闲则立即发送数据。在发送时，边发边继续监听，若监听到冲突，则立即停止发送，等待一段时间（称为退避）以后，再重新尝试。
MAC地址（英语：Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），MAC位址，以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的位址。在OSI模型中，第三层网络层负责IP地址，第二层数据链路层则负责MAC位址 [1] 。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址 [2] 。
以太网的传播性质虽然是广播，但根据其通话对象又可具体分为单播、组播和广播。例如在教室中说“张三，我要对你说…”，虽然每个人都能听见，但它属于单播。
MAC（Media Acess Control）地址共有48比特，前24比特为供应商标识，后24比特为供应商对网卡的唯一编号。MAC地址的第8位为0则表示单播地址，为1则表示组播地址。如果MAC地址48位全为1（FF-FF-FF-FF-FF-FF），则表示广播地址。
MAC地址一般固化在网卡（网络适配器）的店可擦可编程只读存储器EEPROM中，因此MAC地址也被称为硬件地址，但这并不意味着MAC地址属于网络体系结构中的物理层。
一般情况下，用户主机含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡）。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。故严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。
0x04 数据链路层设备 以太网二层交换机
交换机能够根据以太网帧中目标地址智能的转发数据，因此交换机工作在数据链路层。
交换机分割冲突域，实现全双工通信。
需要注意的是，交换机分割冲突域，但是不分割广播域，即交换机的所有端口均属于同一个广播域。冲突域为广播域的若干个子集。
交换机数据转发原理
转发：交换机根据MAC地址表单播转发数据帧。学习：MAC地址表是交换机通过学习接受到的数据帧的源MAC地址来形成的。广播：如果无法在MAC地址表中查到目标地址（端口），交换机就向所有端口广播该数据帧。更新：交换机MAC地址表的老化时间是300s，如果交换机发现一个帧的入端口和MAC地址表中源MAC地址的端口不同，交换机将会对该源MAC地址对应的端口进行更新。 MAC地址洪水攻击：构造大量虚假的MAC地址对交换机的MAC地址表进行污染（MAC地址表具有一定大小），当交换机在MAC地址表中查询不到所要传输的数据的MAC地址时，交换机将由单播变为广播。
交换机实现分割冲突域使用了两个技术，一个是上述的MAC地址转发表，另一个是交换机的背板交换矩阵结构。
0x05 综合布线 综合布线中的六个子系统，建筑群子系统、设备间子系统、垂直子系统、管理子系统、水平子系统、工作区子系统。
以宿舍楼为例，每个宿舍都有一台交换机，它用来接入寝室内各个同学的计算机，这些交换机被称为接入交换机。同一楼层的交换机通过水平子系统相连接入控制器，各个楼层的控制器再通过垂直子系统相连接入汇聚交换机。最后，不同宿舍楼的汇聚交换机接入核心交换机，再由核心交换机接入路由器。其中汇聚交换机和核心交换机不是必须品，但是它们可以使网络拓扑更加层次化从而方便管理。
接入交换机：通常将网络中直接面向用户连接或访问网络的部分称为接入层，接入层目的是允许终端用户连接到网络，因此接入层交换机具有低成本和高端口密度特性。我们在接入层设计上主张使用性能价格比高的设备。接入层是最终用户与网络的接口，它应该提供即插即用的特性，同时应该非常易于使用和维护。一般POE交换机是直接接终端供电，所以POE交换机是作为接入层交换机。
汇聚交换机：汇聚层是网络接入层和核心层的“中介”，就是在有线终端接入核心层前先做汇聚，以减轻核心层设备的负荷。汇聚层必须能够处理来自接入层设备的所有通信量，并提供到核心层的上行链路，因此汇聚层交换机与接入层交换机比较，需要更高的性能，更少的接口和更高的交换速率。在汇聚层中，应该采用支持三层交换技术和VLAN的交换机，以达到网络隔离和分段的目的。
核心交换机：核心层是网络的高速交换主干，对整个网络的连通起到至关重要的作用。核心层应该具有如下几个特性：可靠性、高效性、冗余性、容错性、可管理性、适应性、低延时性等。因为核心层是网络的枢纽中心，重要性突出。核心层设备采用双机冗余热备份是非常必要的，也可以使用负载均衡功能，来改善网络性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3637f842b20beeff9b09e2b41563c41/" rel="bookmark">
			Python &#43; Steamlit 快速开发可视化 web 页面！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Python做web图形用户界面，最先想到的是Flask、Djong等框架。然而研究这些对于初学者来讲，尤其是没有web开发基础的数据分析人员是痛苦的。
幸运的是，Python中也有很多第三方库来快速进行简单的web可视化，例如之前介绍的 PyWebIO
今天再介绍一个 Steamlit，可以快速利用简单的代码快速布局自己想要的web界面！
一、安装与运行 安装之前，我们需要将 Python 的版本升级到3.7或以上，同时设置好环境变量，这里默认读者都已经设置好不细讲。
在 Windows 或 macOS 中都可以使用pip进行安装
pip install streamlit 在终端输出完毕后，可以执行streamlit hello来检验，如果出现新的网页界面，则说明安装成功。
并且之后利用Streamlit写的程序，需要通过运行streamlit run {你的py文件}来实现。
二、常用命令 接下来我们来了解 Streamlit 的一些常用命令。首先引入相关库
import streamlit as st import numpy as np import pandas as pd import time 构建 MLweb 的标识题目，可以利用st.title()函数创建一个标题。
st.title('我的第一个MLweb') 保存这个py文件，命名为test.py，利用我们第一部分讲解如何运行代码，在命令窗口输入streamlit run test.py。
注意，这里直接用 streamlit 是已经调好了环境变量，如果不想调的，打开 streamlit 的源程序文件，将streamlit的exe文件调用即可。
正常运行下会弹出一个 localhost网页，效果如下
输入文字 如果需要输入文字，可以用st.text_input()函数
构建MLWeb表格 机器学习里面我们必须要做的是查看数据的类型，维度等具体特征。比如我们总是用到df.head()，那么在MLweb里面怎么实现？
有几个方法：st.table()，st.dataframe()，st.write()。
其中st.write()是常见的表格函数，st.write()被称为streamlit库的瑞士军刀，图像、文本、表格都可以用它来实现，至于三者有什么区别呢？
st.write()：交互式表格，不可修改
st.table()：静态表格
st.dataframe()：返回一个可以使用和修改的对象，可以向其中添加数据或替换数据.
代码如下
st.write("尝试运用dataframe弄一个表格") df = pd.DataFrame({ '第一列':[1,2,3,4], '第二列':['a','b','c','d']}) st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3637f842b20beeff9b09e2b41563c41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/617f38039527d4aee6db1d4dd0469d89/" rel="bookmark">
			1024数据库图书管理系统创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建三个表格，然后添加相关的约束，修改、删除、查询…
drop table Books create table Books (BookID char(20) primary key,--图书编号 主键约束 Bname char(50) unique,--图书名 唯一约束 Author varchar(30),--作者 Press varchar(30),--出版社 Price money--定价 ) select *from Books drop table Readers create table Readers (ReaderID char(10) primary key,--读者编号 主键约束 Rname char(20) not null,--读者姓名 非空约束 Rsex char(2) check(rsex = '男' or rsex = '女'),--读者性别 Department varchar(30),--读者所在部门 Phone char(20)--读者电话 ) select *from Readers drop table Lending create table Lending (ReaderID char(10) not null,--读者编号 读者信息表外键 BookID char(20) not null,--图书编号 图书信息表外键 Borrowdate date default getdate() not null,--借出日期 默认当前日期 Returndate date check(Returndate&gt;Borrowdate)--归还日期 晚于借出日期 ) select *from Lending /*给books表增加一个ISBN字段*/ alter table Books add ISBN char(10) select *from Books /*给ISBN字段修改数据类型*/ alter table Books alter column ISBN char(10) --update Books set ISBN ='df_ISBN' where ISBN = '7111085949'; /*给ISBN设置约束*/ alter table Books add constraint df_ISBN default '7111085949'for ISBN /*删除字段上的default约束*/ alter table Books drop constraint df_ISBN select *from Books /*删除表上增加的ISBN字段*/ alter table Books drop column ISBN --alter table Books add foreign key(ISBN) references Books (ISBN = 'df_ISBN'default'7111085949') /*使用insert语句向表中插入若干语句*/ insert into Books values('TP311.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/617f38039527d4aee6db1d4dd0469d89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895b31c90506ec39d26a39d31de1470e/" rel="bookmark">
			使用两层网络实现手写数字识别（《深度学习入门：基于Python的理论与实现》实践笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用两层网络实现手写数字识别（《深度学习入门：基于Python的理论与实现》实践笔记） 一、加载mnist数据集二、构建两层网络1. 两层网络结构2. 参数3. 信号传递4. 计算梯度5. 计算精准度 三、训练模型四、创建及训练模型完整代码五、测试模型的完整代码 一、加载mnist数据集 这部分可以看看本人写的另一篇文章：将MNIST手写数字数据集导入NumPy数组。
二、构建两层网络 1. 两层网络结构 两层网络的结构图如下所示：
由于mnist手写数字的图片都是单通道28×28像素的图片，在将图片所有像素一维展开后得到784个像素，所以输入层一共784个神经元。中间层的神经元个数可自己设定，这里就直接使用书中例子的50个神经元。由于这个神经网络最后需要告诉我们这个图片是哪个数字，那么结果就可能为0~9这10个数字，所以输出层的神经元个数为10。 2. 参数 参数一共有4个：第一层权重w1，第一层偏置值b1，第二层权重w2，第二层偏置值b2。由于两层都是全连接层，所以权重w1是784（输入层神经元个数）×50（隐藏层神经元个数）的数组，而权重w2是50（隐藏层神经元个数）×10（输出层神经元个数）的数组。偏置值b1为50（隐藏层神经元个数），b2为10（输出层神经元个数）。参数在构建网络之初就初始化。初始化时，权重w随机初始化，偏置值b初始化为0。 # 初始化权重 self.params = { 'W1': weight_init_std * np.random.randn(input_size, hidden_size), 'b1': np.zeros(hidden_size), 'W2': weight_init_std * np.random.randn(hidden_size, output_size), 'b2': np.zeros(output_size) } 3. 信号传递 网络的第一层是全连接层，然后信号经过sigmoid激活函数后进入第二层全连接层，最后经过softmax归一化层得到输出。 def predict(self, x): w1, w2 = self.params['W1'], self.params['W2'] b1, b2 = self.params['b1'], self.params['b2'] a1 = np.dot(x, w1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, w2) + b2 y = softmax(a2) return y 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/895b31c90506ec39d26a39d31de1470e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9aa41cfe5cb16e223d60dd972b3d023/" rel="bookmark">
			Numpy生成行向量，列向量（1024水勋章文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、行向量与列向量生成1.行向量2.列向量 总结 前言 就注意一点，下面这句话
np.array([1,2,3]) print(np.array([1,2,3]).shape) 既不是行向量，也不是列向量，你输出它的shape：(3,)。是这么个东西，你可以理解成就是一个维度是三的array。
一、行向量与列向量生成 1.行向量 # 1.产生行向量的方法 row_vector1 = np.array([1, 2, 3]).reshape(1, -1) #最常用 row_vector2 = np.array([[1, 2, 3]]) #也经常用 row_vector3 = np.expand_dims(np.array([1, 2, 3]), axis=0)#很少用 2.列向量 # 1.产生列向量的方法 col_vector1 = np.array([1, 2, 3]).reshape(-1, 1)#最常用 col_vector2 = np.array([[1], [2], [3]])#最常用 col_vector3 = row_vector1.T # 向量转置 常用 col_vector4 = np.expand_dims(np.array([1, 2, 3]), axis=1)#很少用 总结 1024节日快乐。2021.10.24 21:13 模式作业代码过程中记录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c87f968c2581c9aa53dcbd317cd999/" rel="bookmark">
			2021-10-24 文件的物理结构（文件分配方式）(重要)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
知识总览
文件块，磁盘块
文件分配方式——连续分配 文件分配方式——链接分配
链接分配——隐式链接
链接分配——显式链接
链接方式（总结）
文件分配方式——索引分配
链接方案 多层索引 混合索引 索引分配（总结）
知识回顾和考点
知识总览 文件块，磁盘块 文件分配方式——连续分配 优点1
优点2 缺点1
缺点2
总结 连续分配方式要求每个文件在磁盘上占有一组连续的块。
优点：支持顺序访问和直接访问(即随机访问)；连续分配的文件在顺序访问时速度最快
缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片
文件分配方式——链接分配 连接分配采取离散分配的方式，可以为文件分配离散的磁盘块 。分为隐式链接和显式链接两种。
链接分配——隐式链接 隐式链接——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。
优点：很方便文件拓展，不会有碎片问题，外存利用率高。
缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。
链接分配——显式链接 把用于链接文件各物理块的指针显式地存放在一种表中。即文件分配表(FAT)
链接方式（总结） 链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。
隐式链接——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。
优点：很方便文件拓展，不会有碎片问题，外存利用率高。
缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。（考试题目中遇到未指明隐式/显式的“链接分配”，默认指的是隐式链接的链接分配）
显式链接——把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表(FAT,FileAllocation Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。
优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。
缺点：文件分配表的需要占用一定的存储空间。
文件分配方式——索引分配 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块(索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系)。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。
链接方案 多层索引 结论： 采用K层索引结构，且顶级索引表为调入内存，则访问一个数据块只需要K+1次读磁盘操作。
混合索引 索引分配（总结） 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块(索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系)。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。
若文件太大，索引表项太多，可以采取以下三种方法解决：
1.链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i号索引块，必须先依次读入0~i-1号索引块，这就导致磁盘1/0次数过多，查找效率低下。
2.多层索引：建立多层索引(原理类似于多级页表)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作。缺点：即使是小文件，访问一个数据块依然需要K+1次读磁盘。
3.混合索引：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引(直接指向数据块)，又包含一级间接索引(指向单层索引表)、还包含两级间接索引(指向两层索引表)。优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。
超级超级超级重要考点：1要会根据多层索引、混合索引的结构计算出文件的最大长度(Key：各级索引表最大不能超过一个块)；②要能自己分析访问某个数据块所需要的读磁盘次数(Key：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件——顶级索引块是否已调入内存)
知识回顾和考点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e6c6fe219aaf6c9ae00cbfef91b40f0/" rel="bookmark">
			关于计算机无法连接虚拟磁盘服务的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说结论：各种修改之后记得重启电脑，只有重启电脑之后才能生效。 下面我说一下我自己的经历：
首先我按照win10遇到无法连接虚拟磁盘服务解决方法_墨染锦年的博客-CSDN博客_无法连接虚拟磁盘服务的做法，进行了如下操作：
控制面板 -&gt; 系统和安全 -&gt; 管理工具 -&gt; 服务 找到 Virtual Disk
右键属性 找到启动类型改为自动。
这个时候再次打开磁盘管理还是显示无法连接虚拟磁盘服务。
于是我按照https://blog.csdn.net/qq_42095701/article/details/103999375?spm=1001.2101.3001.6650.7&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-7.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-7.no_search_link
中的操作，找到检查了visual Disk的属性信息（控制面板 -&gt; 系统和安全 -&gt; 管理工具 -&gt; 服务-&gt;找到 Virtual Disk，右键属性 ），注意到其可执行文件的路径为C:\windows\System32\vds.exe，w是小写，而我刚刚的路径是Windows。所以我怀疑是这里出了问题，于是win+r，然后输入regedit，找到vds的路径（\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\vds），修改ImagePath的值，将windows改为Windows。之后再次打开磁盘管理，发现还是显示无法连接虚拟磁盘服务。
然后我突然想到第一篇博客中重点提到了“重启电脑”，于是重启了一下，大功告成。
所以，可能网上有很多做法并不一定是错的，只是可能我们自己忽略了某些细节才导致结果跟他们不太一样吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001618f86ed4141c730ddf22b2104fab/" rel="bookmark">
			第一个IDEA---登录功能(超级详细！)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，今天是10.24祝大家代码之路越走越顺越走越远吧，早日年入百万脱离苦海！ 言归正传，先放图，建立框架如下图所示：（我会按照从上往下的顺序一一列出）
话不多说，上代码！！！
1.UserAction:
package Action; import model.User; import java.sql.*; public class UserAction { private User u;//这个东西和set,get都必须要有，不然你可以试试 public UserAction() { } public User getU() {//直接自动生成就行 return u; } public void setU(User u) { this.u = u; } public UserAction(User u) { this.u = u; } public String Login() { Connection con = null; PreparedStatement ps = null; ResultSet rs = null; try { String driver = "com.mysql.cj.jdbc.Driver"; Class.forName(driver); String url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/001618f86ed4141c730ddf22b2104fab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cceb465c221e2693fe2c3a21f5c9a4c1/" rel="bookmark">
			java学习笔记（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
java基本语法（一）
一、注释（comment）
（1）单行注释和多行注释
（2）文档注释（java特有）
二、java程序编写-编译-运行的过程
三、相关知识
四、良好的编程风格
五、关键字和保留字 （1）关键字
（2）保留字 六、标识符及命名规范
（1）标识符的定义和命名规范：
（2）java中名称的命名规范
七、变量
（1）变量的概念
（2）变量的使用
（3）变量的分类
（4）基本数据类型转换
（5）String类型变量
（6）进制
八、运算符
（1）算术运算符
（2）赋值运算符
（3）比较运算符
（4）逻辑运算符
（5）位运算符
（6）三元运算符
九、程序流程控制（三种基本结构）
（1）顺序结构
（2）分支结构
（3）循环结构
（4）循环结构注意点
（5）嵌套循环
（5）break和continue关键字
十、Scanner类
java基本语法（一） 一、注释（comment） Java中的三种注释类型：单行注释、多行注释、文档注释；
（1）单行注释和多行注释 作用：
①对所写的程序进行解释说明，增强可读性。方便自己，方便他人。
②调试所写的代码。
特点：单行注释和多行注释，注释了的内容不参与编译，编译以后生成的字节码（.class）文件中不包含注释掉的信息。多行注释不可以嵌套使用。
（2）文档注释（java特有） 注释内容可以被JDK提供的工具Javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。
文档注释的操作方法：
1、编写注释
2、打开cmd,用Javadoc工具解析注释
3、打开生成的文档
4、点击index.html
5、文档注释
注释提高了代码的阅读性，调试程序的重要方法；是一个程序员必须要具有的良好编程习惯；
二、java程序编写-编译-运行的过程 编写：将编写的java代码保存在以“.java”结尾的源文件中；
编译：使用java.exe命令编译java源文件。格式：javac 源文件名： .java
运行：使用java.exe命令解释运行字节码文件（.class） 格式： java 类名
三、相关知识 在一个java源文件中可以声明多个class，但最多有一个类声明为public的。而且要求声明为public的类的类名必须和源文件名相同。程序的格式是固定的。程序的入口是main()方法。每一句执行语句以“;”结束。编译以后会生成一个或者多个字节码文件，字节码文件的文件名与java源程序中的类名相同。基础知识： 软件：即一系列按照特定顺序组织的计算机数据和指令的集合，分为系统软件和应用软件；
系统软件：Windows,Max os,Linux,Unix,Android,IOS....
应用软件：Word，PPT，画图......
人机交互方式：图形化界面 VS 命令行方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cceb465c221e2693fe2c3a21f5c9a4c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a703493a848d2c588e5ee93ae0d42ce6/" rel="bookmark">
			用 JavaScript 实现手势库 — 手势动画应用【前端组件化】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端《组件化系列》目录 「一」用 JSX 建立组件 Parser（解析器）「二」使用 JSX 建立 Markup 组件风格「三」用 JSX 实现 Carousel 轮播组件「四」用 JavaScript 实现时间轴与动画「五」用 JavaScript 实现三次贝塞尔动画库 - 前端组件化「六」用 JavaScript 实现手势库 - 实现监听逻辑「七」用 JavaScript 实现手势库 — 手势逻辑「八」用 JavaScript 实现手势库 — 支持多键触发「九」用 JavaScript 实现手势库 — 事件派发与 Flick 事件「十」用 JavaScript 实现手势库 — 封装手势库「十一」用 JavaScript 实现手势库 — 手势动画应用 《 本期 》… 待续 … 通过上几篇文章，我们对动画已经有了更深入的了解。这里我们就回到我们之前写好的 Carousel 组件。
如果我们回头去看看我们之前写的 Carousel 代码，我们会发现这里的代码我们真的是写的太粗躁了。
我们的拖拽功能中的点击和拖动都是分不清楚的。然后我们也是没有做 flick 的这种判断。动画的时间也是用 CSS 动画来完成的。
更不用说，这个拖拽动画是否可以暂停、继续这样的逻辑。
那么这里我们就把我们上几篇在文章中实现的 Animation（动画库）和 Gesture（手势库）应用进来，从而实现一个完善的 Carousel（轮播组件）。
同学们注意： 只看这篇文章是无法看懂的，因为这篇文章的内容，都是基于之前的《轮播组件》、《实现动画库》、《实现手势库》三篇文章的内容。还没有学习这三篇文章的，请先前往学习再回来看这里哦～
Gesture 库应用 我们之前写的 Gesture, 是一个单独可用的手势库。但是如果它是作为一个正式的一个 Library，我们还是需要对它进行一些单元测试，或者一些代码 lint 风格的检查等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a703493a848d2c588e5ee93ae0d42ce6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/278/">«</a>
	<span class="pagination__item pagination__item--current">279/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/280/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>