<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d04cfa0328924febdd5ceac5563a8e/" rel="bookmark">
			webstorm解决git冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webstorm解决git冲突 步骤1
注意：先更新服务器的代码
更新代码三部曲：
git stash
git pull
git stash pop
提交代码三部曲：
git add.
git commit -m “注释”
git push
其他一些指令：
git diff -----查看修改详情
git log ----查看提交日志
步骤2
步骤3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ff045da51527e05c4ecc0968df5f2c/" rel="bookmark">
			uniapp unipush点击推送到指定页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 APP.vue的onLaunch()中加入这段代码
plus.push.addEventListener( 'click', msg =&gt; { setTimeout(function() { uni.navigateTo({ url: '/pages/tabbar/tabbar-5/systemMsg/systemMsg' }); }, 1000); }, false ); //监听在线消息事件 plus.push.addEventListener( 'receive', msg =&gt; { setTimeout(() =&gt; { //如果是在线收到推送消息，需要创建一条推送 cover: false 是否覆盖上一条推送消息 if (msg.type == 'receive') { var options = { cover: false, title: msg.payload.title }; let url = '/pages/tabbar/tabbar-5/systemMsg/systemMsg'; plus.push.createMessage(msg.payload.content, url, options); //创建一条推送消息 } }, 2500); }, false ); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f6c28709ceff6939891e66b6006bc56/" rel="bookmark">
			数据表的设计原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据表的设计原则（三少一多） 数据表的个数越少越好
RDBMS的核心在于对实体和联系的定义，也就是E-R图（Entity Relationship Diagram)，数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。数据表中的字段个数越少越好
字段个数越多，数据冗余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。数据表中联合主键的字段个数越少越好
设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是用多个字段来定义一个主键）。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间
和索引空间，因此联合主键的字段个数越少越好。使用主键和外键越多越好
数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。 “三少一多”原则的核心就是简单可复用。简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代表。键设计得越多，证明它们之间的利用率越高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a18db62b9581892c5830f3c288d2988/" rel="bookmark">
			java之NIO简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、NIO基本简介 NIO (New lO)也有人称之为java non-blocking lO是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java lO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。NIO可以理解为非阻塞IO,传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。
NIO相关类都被放在java.nio包及子包下，并且对原java.io包中的很多类进行改写。NIO有三大核心部分:Channel(通道)，Buffer(缓冲区), Selector(选择器)Java NlO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。通俗理解:NIO是可以做到用一个线程来处理多个操作的。假设有1000个请求过来,根据实际情况，可以分配20或者80个线程来处理。不像之前的阻塞IO那样，非得分配1000个。 二、NIO 与 BIO的比较 BIO以流的方式处理数据,而NIO以块的方式处理数据,块I/O的效率比流IO高很多BIO是阻塞的，NIO则是非阻塞的BlO基于字节流和字符流进行操作，而NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如:连接请求，数据到达等)，因此使用单个线程就可以监听多个客户端通道 NIO可以先将数据写入到缓冲区，然后再有缓冲区写入通道，因此可以做到同步非阻塞。
BIO则是面向的流，读写数据都是单向的。因此是同步阻塞。
三、NIO 三大核心原理示意图 NIO有三大核心部分: Channel(通道)，Buffer(缓冲区)，Selector(选择器)
Buffer(缓冲区)
缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer APl更加容易操作和管理。
Channel(通道)
Java NIO的通道类似流，但又有些不同:既可以从通道中读取数据，又可以写数据到通道。但流的(input或output)读写通常是单向的。通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。
Selector(选择器)
Selector是一个ava NIO组件，可以能够检查一个或多个NIO通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率
每个channel都会对应一个 Buffer一个线程对应Selector ,一个Selector对应多个channel(连接)程序切换到哪个channel是由事件决定的Selector 会根据不同的事件，在各个通道上切换Buffer 就是一个内存块，底层是一个数组数据的读取写入是通过 Buffer完成的，BlO中要么是输入流，或者是输出流,不能双向，但是NIO的Buffer是可以读也可以写。Java NIO系统的核心在于:通道(Channel)和缓冲区(Buffer)。通道表示打开到lO设备(例如:文件、套接字)的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，Channel负责传输，Buffer负责存取数据 四、NIO核心一:缓存区 (Buffer) 缓冲区（Buffer）一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类.。Java NIO 中的 Buffer 主要用于与 NIO 通道进行 交互，数据是从通道读入缓冲区，从缓冲区写入通道中的
Buffer 类及其子类：
Buffer就像一个数组，可以保存多个相同类型的数据。根据 数据类型不同 ，有以下 Buffer 常用子类： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 上述 Buffer 类他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a18db62b9581892c5830f3c288d2988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/856c6864ae4648c69d97d79dc6969e97/" rel="bookmark">
			java乱码问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java乱码问题分析 问题描述原因分析：解决方案：要求实例 补充：常见的两种字符集及其代码：Windows系统下查看默认字符集Windows系统切换命令行字符集 总结 问题描述 两种情况：
使用javac命令编译的时候报错，例如：
编译的时候没报错，但在使用java命令运行class文件时出现乱码，例如：
原因分析： 一个Java源代码到输出的过程如下所示：
在解码、编码和显示的时候都会使用到字符集。
通常，在使用javac命令不加任何选项时，javac命令会使用当前系统默认的字符集将.java源文件解码，然后再把解码之后的内容再翻译然后以当前系统默认的字符集编码成.class字节码文件，例如windows系统（通常是GBK）下：
如果使用javac命令时，添加了-encoding &lt;字符集&gt; 选项，那么会使用这个指定的字符集将.java解码，然后翻译，然后还是会根据当前系统默认的字符集编码成.class字节码文件，例如在windows系统下使用javac -encoding utf-8命令编译时：
这就是为什么.java文件字符集为utf-8，使用了javac -encoding utf-8命令，命令行的字符集也是utf-8时还会出现乱码，例如：
这是因为虽然javac命令在解码时是根据utf-8解码的，但是编码时还是使用系统默认的GBK，所以使用utf-8字符集的命令行运行这个以GBK编码的.class文件，还是会出现乱码。
在命令行使用java命令执行.class字节码文件的时候，命令行会根据当前命令行的字符集（通常和系统默认字符集相同）把结果显示出来。
所以在上面遇到的问题，如果这时候把命令行的字符集换成GBK，执行这个.class文件就能正确显示了，如下图：
综上，出现乱码或者编译时报错说有不可映射的字符，那么就是.java源文件与javac命令解码时使用的字符集不同或者是javac命令编码时使用的字符集（也就是生成的.class字节码文件的字符集）与命令行的字符集不同。
解决方案： 要求 不出现乱码需要满足两点要求：
编译时，.java源文件使用的字符集与使用javac命令时使用的字符集相同。也就是说如果系统默认的字符集与.java源文件的字符集不同，就必须要使用-encoding指定字符集；如果系统默认字符集与.java文件相同直接使用javac即可。执行时，.class字节码文件（.class字节码文件的字符集与它生成时的系统默认字符集相同）使用的字符集与命令行使用的字符集相同。也就是说一般情况下，由于命令行的字符集通常与系统的字符集相同，所以在同一个计算机上编译（需要满足上述要求1）得到的.class文件是直接能执行并且不会出现乱码的；如果是在一台计算机上编译（满足上述要求1），然后把编译得到的.class文件拿到另一个计算机上执行，那么可能因为两台计算机的系统默认字符集不同而出现乱码，这时候如果需要执行这个.class文件，就必须把命令行的字符集改成与.class文件相同的字符集，例如“原因分析”部分使用的例子。 实例 ↑由于系统字符集是GBK，与.java文件的utf-8不同，所以在使用javac命令时使用-encoding utf-8指定使用utf-8解码。然后由于命令行的字符集默认是与系统字符集相同的，所以使用java命令执行时，直接能正确显示。
补充： 常见的两种字符集及其代码： 字符集代码GBK936utf-865001 Windows系统下查看默认字符集 在命令行中使用以下命令即可：
chcp Windows系统切换命令行字符集 在命令行中使用以下命令即可切换到指定字符集：
chcp &lt;字符集代码&gt; 总结 如果只是在一台计算机上编译+执行，那么使用javac -encoding &lt;.java源文件的字符集&gt; 命令编译，直接java命令执行，一般都不会出现乱码。如果出现乱码了就得根据编译和执行这两个方面去检查是否符合要求。
上述只是我的个人理解，如有问题还请指出，非常感谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3b620a09008c4d342693e6957edaab4/" rel="bookmark">
			opencv-python——2（颜色分割（RGB、HSV）、读取摄像头和视频并保存）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 关于opencv读取图片等基本操作可以查看opencv-python基础操作汇总——1（读取、画线、平移，旋转缩放、翻转和裁剪等操作）
颜色分割（RGB） 可以通过cv2.split来分割RGB通道，再用cv2.merge来融合通道。
import cv2 import matplotlib.pyplot as plt import numpy as np plt.figure() image = cv2.imread('im0.png') plt.subplot(2,2,1) plt.imshow(image) plt.axis('off') R, G, B = cv2.split(image) # 创建一个跟图片一样大小的全为0的矩阵 z = np.zeros(image.shape[:2], dtype=np.uint8) red = cv2.merge([R, z, z]) # 第一个通道为红色，其它通道全为0 green = cv2.merge([z, G, z]) blue = cv2.merge([z, z, B]) plt.subplot(2,2,2) plt.title('red') plt.imshow(red) plt.axis('off') plt.subplot(2,2,3) plt.title('green') plt.imshow(green) plt.axis('off') plt.subplot(2,2,4) plt.title('blue') plt.imshow(blue) plt.axis('off') plt.show() 效果如下：
HSV HSV是一种比较直观的颜色模型，HSV可以用来更好的数字化来处理颜色。其中HSV分别代表色调（H，Hue）、饱和度（S，Saturation）、明度（V，Value）。
色调：
用角度衡量（0~360°），从红色开始逆时针计算，红色是0°，绿色是120°，蓝色是240°。补色为：黄色是60°，青色是180°，品红是300°。
饱和度：
表示颜色接近光谱色的程度。取值范围：0~100%，值越大，颜色越饱和。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3b620a09008c4d342693e6957edaab4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971aca83982ee8290a6ee041d727e011/" rel="bookmark">
			java.lang.String类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 简单了解JDK常用的包和类后，开始学习String类，学习思路：
了解String类的概念
掌握String类基本的构造器
理解创建String对象的底层区别
掌握String类基本的常用方法
二、String类的概念 String类代表字符串，字符串是常量，他们的值创建之后不能更改。
java.lang.String:
public final class String implements java.io.Serializable,Comparable&lt;String&gt;,CharSequence{ final修饰符：类被final修饰符修饰，所以String类不能被继承，也代表不可变的字符序列（这点目前还不能完全理解，先将其写好）；
Serializable接口：表示字符串是支持序列化的；（据说等到学到IO流的时候即可理解。。）
Comparable接口：表示String可以比较大小；
三、String类的构造方法 1.String类常用的构造方法 熟练掌握几种String类常用的构造器，剩余可看API；（先掌握一些基础常用的）
String str = "hello"; 初始化一个新创建的 String 对象"hello"; ​ String s1 = new String(hello); new一个String对象"hello"; ​ String s1 = new String(char[] a); new一个String对象，内容为char[] a; ​ String s1 = new String(char[] a,int startIndex,int count); new一个String对象char[] a,从索引startIndex出开始截取，长度为count; 2.创建String对象的两种区别 理解创建String对象后一些基础的底层逻辑
直接赋值方式创建对象
直接赋值方式创建对象是在方法区的常量池
通过构造方法创建字符串对象
通过构造方法创建字符串对象是在堆内存
例：
public class TestString { public static void main(String[] args) { String str1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971aca83982ee8290a6ee041d727e011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eabf678384b3ae3678402e3cc5de2548/" rel="bookmark">
			动态图神经网络的分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态网络为网络建模和预测增加了新的维度-时间 这个新的维度从根本上影响网络属性，使网络数据更强大地表示出来，进而提高使用此类数据的方法的预测能力 1.按不同类型划分网络 1.1按照时间粒度——划分网络： Static(静态图)：不关注图中的动态信息，将其作为一张静态图同等处理
edge weighted(边加权)：动态信息知识作为一张静态图中的节点和边的labels而存在
discrete（离散时间）：离散表示使用一组有序的图（快照）来表示动态图 在一个连续的时间内，按照时间进行切片，在每一个时间切片内得到一个图，然后对图采用GNN聚合图的信息对于时间的方式，采用RNN得到时间序列的信息， continuous networks（连续时间）：使用确切时间信息来表示动态图 静态网络最粗糙，连续表示最精细，随着时间粒度的增加，模型的复杂性也随之增加
主要研究：离散时间和连续时间
1.1.1离散表示：DG={ G 1 , G 2 , . . , G T G^1,G^2,..,G^T G1,G2,..,GT}, T–快照数，在每一个时间间隔内形成一个图 1.1.2连续表示：可分为三种 基于链接持续时间的动态网络的表示 ： EB={( u i , v i , t i , Δ i u_i,v_i,t_i,\Delta_i ui​,vi​,ti​,Δi​)；i = 1，2，… } u i , v i u_i,v_i ui​,vi​表示发生事件的一对节点， t i t_i ti​-发生时间， Δ i \Delta_i Δi​-持续时间 例：u和v在t时刻发生事件，事件持续事件为 Δ i \Delta_i Δi​ 在接触序列中，链接是瞬时发生的，不存在持续时间，如电子邮件的发送 EB={( u i , v i , t i u_i,v_i,t_i ui​,vi​,ti​)；i = 1，2，… }例：u和v在t时刻发生的事件 基于事件的表示，它将链接的出现和链接的消失视为单独的事件 GS={ e 1 , e 2 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eabf678384b3ae3678402e3cc5de2548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89989e20f590cdc42bf9d44df447410b/" rel="bookmark">
			HAN:Heterogeneous Graph Attention Network 算法理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HAN:Heterogeneous Graph Attention Network 前置知识： 异构图：包含不同类型节点和链接的异构图
Meta-path 元路径： 链接两个对象的复合关系，是一种广泛适用的捕获语义的结构 M-A-M,M-D-M
Meta-path下的邻居节点 m1-a1-m2,m1-a3-m3，m1-a1-m1 因此m1的邻居节点如d图 HAN算法原理 节点级别的Attention 终结者通过詹姆斯卡梅隆与终结者2形成连接关系，终结者通过詹姆斯卡梅隆与泰坦尼克号形成连接关系，形成同构图根据它的邻居节点终结者2和泰坦尼克号，通过一种聚合方式，可以学习到终结者的特征表示 语义级别的Attention：旨在了解每个元路径的重要性，并为其分配适当的权重 通过不同的Meta-path得到了终结者电影所对应的一个节点特征，然后将两个特征进行特征求和不同类型的邻居分配不同的权重，最终得到终结者所对应的一个节点的特征表示
节点级别的Attention 具体算法 当节点处在不同维度（节点特征数量不一致时）时，先将节点映射到同一个维度 h i ′ = M ϕ i ⋅ h i h'_i = M_{\phi_i}·h_i hi′​=Mϕi​​⋅hi​（1） 之后进行 e i j ϕ = a t t n o d e ( h i ′ , h j ′ , ϕ ) e^\phi_{ij} = att_{node}(h'_i,h'_j,\phi) eijϕ​=attnode​(hi′​,hj′​,ϕ) ϕ \phi ϕ表示Meta-path， a t t n o d e att_{node} attnode​将 i和j 输入后 得到他们之间的attention的值1节点的周围邻居为 e 11 ϕ 0 , e 12 ϕ 0 , e 13 ϕ 0 , e 16 ϕ 0 e^{\phi_0}_{11},e^{\phi_0}_{12},e^{\phi_0}_{13},e^{\phi_0}_{16} e11ϕ0​​,e12ϕ0​​,e13ϕ0​​,e16ϕ0​​ a i j ϕ = s o f t m a x j ( e i j ϕ ) a^\phi_{ij}= softmax_j(e^\phi_{ij}) aijϕ​=softmaxj​(eijϕ​) ：对其做归一化操作，得到归一化之后的一个attention系数 Z i ϕ Z^\phi_i Ziϕ​ ：将attention的系数与他的邻居做一个加权求和，再经过一个激活函数，得到节点所对应的特征表示如1节点的 ： z 1 ϕ 0 = ( α 11 ϕ 0 ∗ e 11 ϕ 0 + … ) z^{\phi_0}_1 = (\alpha^{\phi_0}_{11}* e^{\phi_0}_{11}+…) z1ϕ0​​=(α11ϕ0​​∗e11ϕ0​​+…)求得所有节点不同类型的Meta-path下的embedding结果 Z ϕ 0 Z_{\phi_0} Zϕ0​​ = { z 1 ϕ 0 , z 2 ϕ 0 , z 3 ϕ 0 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89989e20f590cdc42bf9d44df447410b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/491ab8dcaf693ac19d0a8cfcface2e51/" rel="bookmark">
			STM32 HAL库手册获取和查阅方法以及查看官方例程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、概述二、安装芯片pack包三、查看HAL库手册四、查看官方例程 一、概述 STM32固件使用HAL库进行开发，如何查看接口函数的定义呢？本文记录一种通过STM32CubeMX软件获取HAL手册进行查阅的方法。
STM32CubeMX的安装可以参考文章：STM32CubeMX官网下载方法。
二、安装芯片pack包 首先需要安装pack包。打开STM32CubeMX软件，help-&gt;Manage Embedded Software packages，如下图：
根据自己的需要，选择芯片系列，选择pack包版本，选择安装。
回到STM32CubeMX软件主界面，help-&gt;Updatar Settings，查看存储路径，如下图：
这里最好不要选在C盘。
根据路径在本地查找，就可以看到下载的pack包。
三、查看HAL库手册 按照下图目录即可找到HAL库手册，直接双击打开即可。
打开手册后选择搜索，在搜索框输入需要查找的库函数。
以HAL_GPIO_Init为例，在搜索框输入后，双击搜索结果，在右侧显示函数定义。
四、查看官方例程 同样是在pack包的存储路径下，使用everthing搜索Repository关键字也可。这里列出了已经安装的系列：
选择对应的系列查找即可，下面是SPI的路径：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cd7f6b8ae5729082c4fc8321bd93b9e/" rel="bookmark">
			heidisql无法下拉表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		吐了，找了半天
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/843a1bcbc36b5552f5809c6e3ede1172/" rel="bookmark">
			leetcode--599.两个列表的最小索引总和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：假设Andy 和 Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。
你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。1
示例：
# 示例 1 输入: list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"] 输出: ["Shogun"] 解释: 他们唯一共同喜爱的餐厅是“Shogun”。 # 示例 2 输入:list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["KFC", "Shogun", "Burger King"] 输出: ["Shogun"] 解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。 提示： 1 &lt;= list1.length, list2.length &lt;= 1000
1 &lt;= list1[i].length, list2[i].length &lt;= 30
list1[i] 和 list2[i] 由空格 ’ ’ 和英文字母组成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/843a1bcbc36b5552f5809c6e3ede1172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5088ddfd82e6dcb8c0ef1bec801b14e/" rel="bookmark">
			【Leetcode-每日一题】 两个列表的最小索引总和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个列表的最小索引总和
难度：简单
通过map记录较短数组的元素和下标，再遍历另外一个数组找到与map中相匹配的元素，需比较索引和：
若当前索引和小于最小索引和，则清除res数组的内容，更新最小索引值，并记录当前元素。若当前索引和等于最小索引和，则记录当前元素。 代码如下：
public String[] findRestaurant(String[] list1, String[] list2) { //保证list1总是较短的数组 if (list1.length&gt;list2.length){ return findRestaurant(list2,list1); } //遍历list1，将元素和索引下标记录到map中 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; list1.length; i++) { map.put(list1[i],i); } List&lt;String&gt; res = new ArrayList&lt;&gt;(); int min = Integer.MAX_VALUE; for (int i = 0; i &lt; list2.length; i++) { String temp = list2[i]; //当两数组出现相同元素时 if (map.containsKey(temp)){ //若当前索引和小于最小索引和，则清除res数组的内容，更新最小索引值，并记录当前元素。 if (i+map.get(temp)&lt;min){ min = i+map.get(temp); res.clear(); res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5088ddfd82e6dcb8c0ef1bec801b14e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75f008792f4e376acaf79f5abd8273a4/" rel="bookmark">
			BUG Free的简易安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装xampp（已有安装包的情况下）
2.启动XAMPP (xampp无法启动Apache时，需更改端口号：）
1．80端口冲突，解决方法：
打开目录C:\xampp\apache\conf(我的安装目录为C:\xampp)下的httpd.conf文件，将Listen 80和 ServerName localhost:80中的80改为8081
或其它值（尽量不要使用0－1023端口，这个是系统保留端口），要保持一致。 一般改为8081
2．监听端口443冲突，解决方法：
打开目录C:\xampp\apache\conf\extra (我的安装目录为C:\xampp)下的httpd-ssl.conf文件，将Listen 443这句注释掉：
# Listen 443或将443改为4433或其它值（尽量不要使用0－1023）。
3.开启apache 服务与mysql 服务
4.安装bugfree
（1）拷贝Bugfree3.0.4的安装包解压到C:\xampp\htdocs下，
并修改文件夹名为bugfree；xampp安装目录的htdocs文件夹的根目录下新建BugFile文件夹
（2）xampp安装目录的htdocs文件夹的根目录下新建BugFile文件夹
（3）在浏览器输http://localhost/bugfree 打开bugfree的安装页面；
（若端口号非80时，需用IP带端口号访问：如http://192.168.0.178:3036/bugfree
5.在跳转的界面输入数据库用户名为：root，密码置空（因在phpMyAdmin页面没有设置密码），点击完成即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/585d510eec0c7cc3bbbf07bcf9aca1e8/" rel="bookmark">
			java.nio.file.NoSuchFileException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报这个错是找不到上传的文件。
因为上传文件之前会在本地生成一个临时文件。
transferTo(file)这个方法会删除临时文件，注释掉这段代码，不然会产生冲突。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8578fe7f65eb2b32aede83fc0557d344/" rel="bookmark">
			智能算法——蚁群算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、原理 蚁群算法是受到对真实蚂蚁群觅食行为研究的启发而提出。生物学研究表明：一群相互协作的蚂蚁能够找到食物和巢穴之间的最短路径,而单只蚂蚁则不能。生物学家经过大量细致观察研究发现,蚂蚁个体之间的行为是相互作用相互影响的。蚂蚁在运动过程中,能够在它所经过的路径上留下一种称之为信息素的物质,而此物质恰恰是蚂蚁个体之间信息传递交流的载体。蚂蚁在运动时能够感知这种物质,并且习惯于追踪此物质爬行,当然爬行过程中还会释放信息素。一条路上的信息素踪迹越浓,其它蚂蚁将以越高的概率跟随爬行此路径,从而该路径上的信息素踪迹会被加强,因此,由大量蚂蚁组成的蚁群的集体行为便表现出一种信息正反馈现象。某一路径上走过的蚂蚁越多,则后来者选择该路径的可能性就越大。蚂蚁个体之间就是通过这种间接的通信机制实现协同搜索最短路径的目标的。我们举例简单说明蚂蚁觅食行为：
如上图a,b,c的示意图：
a图是原始状态，蚂蚁起始点为A，要到达E，中途有障碍物，要绕过才能到达。BC和BH是绕过障碍物的2条路径(假设只有2条)。各个路径的距离d已经标定。
b图是t=0时刻蚂蚁状态，各个边上有相等的信息素浓度，假设为15；
c图是t=1时刻蚂蚁经过后的状态，各个边的信息素浓度，有变化；因为大量蚂蚁的选择概率会不一样，而选择概率是和路径长度相关的。所以越短路径的浓度会越来越大，经过此短路径达到目的地的蚂蚁也会比其他路径多。这样大量的蚂蚁实践之后就找到了最短路径。
所以这个过程本质可以概括为以下几点：
路径概率选择机制信息素踪迹越浓的路径,被选中的概率越大信息素更新机制路径越短,路径上的信息素踪迹增长得越快协同工作机制蚂蚁个体通过信息素进行信息交流。 从蚂蚁觅食的原理可见,单个个体的行为非常简单蚂蚁只知道跟踪信息素爬行并释放信息素,但组合后的群体智能又非常高蚂蚁群能在复杂的地理分布的清况下,轻松找到蚁穴与食物源之间的最短路径。这种特点恰恰与元启发算法的特点相一致,蚁群优化算法正是受到这种生态学现象的启发后加以模仿并改进而来,觅食的蚂蚁由人工蚁替代,蚂蚁释放的信息素变成了人工信息素,蚂蚁爬行和信息素的蒸发不再是连续不断的,而是在离散的时空中进行。
从深层意义上来讲,蚁群算法作为优化的方法之一,属于人工群集智能领域。人工群集智能,大都受自然群集智能如昆虫群和动物群等的启发而来。除了具有独特的强有力的合作搜索能力外,还可以利用一系列的计算代理对问题进行分布式处理,从而大大提高搜索效率。
2、基本流程
2.1基本数学模型 首先看看基本TSP问题的基本数学模型：
问题其实很简单，目标函数就是各个走过路径的总长度，注意的就是距离矩阵根据实际的问题不一样，长度是不一样的。
2.2说明 在说明群蚁算法流程之前，我们对算法原理和几个注意点进行描述：
TSP问题的人工蚁群算法中，假设m只蚂蚁在图的相邻节点间移动，从而协作异步地得到问题的解。每只蚂蚁的一步转移概率由图中的每条边上的两类参数决定：1. 信息素值也称信息素痕迹。2.可见度，即先验值。
2.信息素的更新方式有2种，一是挥发，也就是所有路径上的信息素以一定的比率进行减少，模拟自然蚁群的信息素随时间挥发的过程；二是增强，给评价值“好”(有蚂蚁走过)的边增加信息素。
3.蚂蚁向下一个目标的运动是通过一个随机原则来实现的，也就是运用当前所在节点存储的信息，计算出下一步可达节点的概率，并按此概率实现一步移动，逐此往复，越来越接近最优解。
4.蚂蚁在寻找过程中，或者找到一个解后，会评估该解或解的一部分的优化程度，并把评价信息保存在相关连接的信息素中。 2.3核心步骤 群蚁算法的2个核心步骤是 路径构建 和 信息素更新。
2.3.1路劲构建
每个蚂蚁都随机选择一个城市作为其出发城市，并维护一个路径记忆向量，用来存放该蚂蚁依次经过的城市。蚂蚁在构建路径的每一步中，按照一个随机比例规则选 择下一个要到达的城市。随机概率是按照下列公式来进行计算的：
上述公式就是计算当前点到每一个可能的下一个节点的概率。分子是信息素强度和能见度的幂乘积，而分母则是所有分子的和值。这个刚开始是很不容易理解的，我们在最后实例计算的时候，可以看得很清楚，再反过来理解公式。注意每次选择好节点后，就要从可用节点中移除选择的节点。
2.3.2信息素更新
信息素更新是群蚁算法的核心。也是整个算法的核心所在。算法在初始期间有一个固定的浓度值，在每一次迭代完成之后，所有出去的蚂蚁回来后，会对所走过的路线进行计算，然后更新相应的边的信息素浓度。很明显，这个数值肯定是和蚂蚁所走的长度有关系的，经过一次次的迭代，近距离的线路的浓度会很高，从而得到近似最优解。那我们看看信息素更新的过程。
初始化信息素浓度C(0)，如果太小，算法容易早熟，蚂蚁会很快集中到一条局部最优路径上来，因为可以想想，太小C值，使得和每次挥发和增强的值都差不多，那么 随机情况下，一些小概率的事件发生就会增加非最优路径的信息素浓度；如果C太大，信息素对搜索方向的指导性作用减低，影响算法性能。一般情况下，我们可以使用贪婪算法获取一个路径值Cnn，然后根据蚂蚁个数来计算C(0) = m/Cnn ,m为蚂蚁个数
每一轮过后，问题空间中的所有路径上的信息素都会发生蒸发,然后，所有的蚂蚁根据自己构建的路径长度在它们本轮经过的边上释放信息素，公式如下：
信息素更新的作用：
1.信息素挥发(evaporation)信息素痕迹的挥发过程是每个连接上的 信息素痕迹的浓度自动逐渐减弱的过程，这个挥发过程主要用于避 免算法过快地向局部最优区域集中，有助于搜索区域的扩展。
2.信息素增强(reinforcement)增强过程是蚁群优化算法中可选的部 分，称为离线更新方式（还有在线更新方式）。这种方式可以实现 由单个蚂蚁无法实现的集中行动。基本蚁群算法的离线更新方式是 在蚁群中的m只蚂蚁全部完成n城市的访问后，统一对残留信息进行 更新处理。
2.3.3迭代与停止
迭代停止的条件可以选择合适的迭代次数后停止，输出最优路径，也可以看是否满足指定最优条件，找到满足的解后停止。最重要的是，我刚开始理解这个算法的时候，以为每一只蚂蚁走一条边就是一次迭代，其实是错的。这里算法每一次迭代的意义是：每次迭代的m只蚂蚁都完成了自己的路径过程，回到原点后的整个过程。
3.计算实例
4.TSP问题的群蚁算法C#代码实现
4.1群蚁算法系统基类 我们封装了一个基础的BaseTspAntSystem类，包括了一些基本属性和计算过程，后续相关改进版本可以进行直接继承。BaseTspAntSystem类的主要属性如下：
基类有一个构造函数，对系统的初始化就是传入基本的参数，并对相关列表进行初始化，代码如下：
核心的是求解过程，完全按照迭代次数要求进行迭代进行，过程就是概率选择和信息素更新，我们辅助的用到了Ant蚂蚁类，目的就是让程序更加独立和容易理解。Ant类里面有蚂蚁路径寻找过程的所有信息。下一节将进行介绍。求解过程代码如下面，看看注释和对比算法进行：
4.2蚂蚁功能类 根据算法的描述，m只蚂蚁同时进行自己的工作和寻找路程，是一个并行的过程，因此也在单次过程中，蚂蚁都是独立的。蚂蚁的每一次迭代，过程都比较清楚，寻找路径过程，注意维护一些可用的节点列表，以及最后一条路径的处理。看看蚂蚁类的主要属性和构造函数：
Ant类的核心是寻找下一个城市节点的过程，以及循环直到所有路径都完成。如下面代码，是一个循环过程：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07548780dc6a8dc658c8afae72cb81ad/" rel="bookmark">
			Win11又双叒叕崩溃？大量网友开始回滚Win10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近来 Windows 11 的更新进度又被提了起来，新系统在界面UI、任务栏设计、开始菜单、通知中心等多方面都有所改变。
同时也具备了任务管理器效率模式、WSA、Auto HDR 等 Windows 10 不具备的新功能，确实给用户带来了不一样的体验。
预览版已更新任务管理器
然而，一些用户不习惯新的界面、新的右键菜单，更何况由于机与机的体质不能一概而论，部分用户遇到了漏洞、功能缺失和兼容性等问题。
那有没有将 Win11 退回 Win10 的后悔药呢？下面有4种退回方法。
01
自带恢复功能 在升级后的10天内，用户可以将 Win11 回退到 Win10 。
在 设置 - Windows 更新 - 高级选项 中找到 恢复功能：
在 “恢复选项” 下选择 “以前版本的Windows” ，点击 “返回” 。
回退原因，随意选择。
你将看到“检查更新”的通知，选择“不，谢谢”。
一步步点下来，选择“回退到早期版本”。
等待完成后，你便成功将Win11还原以前的版本了。
但如果你清理过系统文件可能会遇到无法还原的情况，并且如果升级超过10 天也无法回退了。
02
卸载更新 如果无法使用上述的恢复功能，还可以尝试恢复环境（WinRE）卸载更新 ，虽然听起来意思差不多却是两个不同的东西。
按住 Shift 重启电脑，在 Windows 恢复环境中，选择 “疑难解答” &gt; “高级选项” 。
在高级选项窗口中，选择 “卸载更新” 即可。
03
全新安装 如果上述尝试都不成功，电脑上也没有什么重要东西，或者系统本来就很混乱卡顿不如直接全新安装了。
除了使用 U 盘 PE 重装等方法外，你也可以直接在系统内执行全新安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07548780dc6a8dc658c8afae72cb81ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6108266791541b77fba7cff38e47a70f/" rel="bookmark">
			log4j2.xml配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		log4j2.xml配置详解 1 log4j2介绍2 配置文件节点解析3 配置参数解释3.1 日志级别3.2 输出源3.3 格式 4 最简配置5 模板 参考文章：
https://mp.weixin.qq.com/s/8mEU5ofwQPWA14JbtmQNrw
https://www.cnblogs.com/keeya/p/10101547.html
1 log4j2介绍 log4j2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本配置文件后缀名只能为".xml",".json"或者".jsn"。
配置文件的格式：log2j配置文件可以是xml格式的，也可以是json格式的。
配置文件的位置：log4j2默认会在classpath目录下寻找log4j2.xml、log4j.json、log4j.jsn等名称的文件。
系统选择配置文件的优先级(从先到后)如下：
(1).classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件.
(2).classpath下的名为log4j2-test.xml的文件.
(3).classpath下名为log4j2.json 或者log4j2.jsn的文件.
(4).classpath下名为log4j2.xml的文件.
我们一般默认使用log4j2.xml进行命名。
2 配置文件节点解析 根节点Configuration
两个属性：
status：用来指定log4j本身的打印日志的级别monitorinterval：用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s
两个子节点:AppendersLoggers(表明可以定义多个Appender和Logger). Appenders节点
常见的有三种子节点:Console、RollingFile、File
Console节点用来定义输出到控制台的Appender.
Console节点用来定义输出到控制台的Appender
name:指定Appender的名字.target:SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT.PatternLayout:输出格式，不设置默认为:%m%n.File节点用来定义输出到指定位置的文件的Appender. File节点用来定义输出到指定位置的文件的Appender
name:指定Appender的名字.fileName:指定输出日志的目的文件带全路径的文件名.PatternLayout:输出格式，不设置默认为:%m%n.RollingFile节点用来定义超过指定条件自动删除旧的创建新的Appender. RollingFile节点用来定义超过指定条件自动删除旧的创建新的Appender
name:指定Appender的名字.fileName:指定输出日志的目的文件带全路径的文件名.PatternLayout:输出格式，不设置默认为:%m%n.filePattern : 指定当发生Rolling时，文件的转移和重命名规则.Policies:指定滚动日志的策略，就是什么时候进行新建日志文件输出日志.TimeBasedTriggeringPolicy:Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1 hour。modulate=true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am.SizeBasedTriggeringPolicy:Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小.DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性)。 Loggers节点，常见的有两种:Root和Logger
Root节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出
level:日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; - AppenderRef：Root的子节点，用来指定该日志输出到哪个Appender.Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。level:日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6108266791541b77fba7cff38e47a70f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bd5bc220c4e75a668cea5d90936c07a/" rel="bookmark">
			vscode检测到include错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode检测到include错误 一.安装环境二.配置环境三.运行代码 重装系统之后，在vscode里编写代码时发现#include报错，如果你也是刚重装系统或者刚下载vscode，那么出现错误的原因就是没有安装gcc环境。 一.安装环境 选择开源的MinGW编译器，进入https://sourceforge.net/projects/mingw-w64/files/mingw-w64/，下拉，选择最近的-seh文件，如下图，如果开发windows程序就选win32，linux就选posix。
二.配置环境 将下载好的文件解压，找到bin文件夹，进入，复制该文件夹的绝对路径（如D:\environment\gcc\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\mingw64\bin），添加至环境变量的path中，然后一直单击确定直到退出环境变量设置。
打开cmd，输入gcc -v，有下图的显示，说明安装完成。
三.运行代码 要想在vscode中运行代码，需要在扩展中安装code runner。
安装完成后重启vscode，文件-&gt;首选项-&gt;设置，查找框输入run in进行查找，勾选Run In Terminal选项。
右上角的播放按钮即为运行键。
代码编辑完成后单击运行，即可在终端中编辑输入并查看输出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966b200ee2e708259083219e3ad242b9/" rel="bookmark">
			Windows10家庭版转为专业版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows10家庭版转为专业版 前言：这篇博客纯粹是记录我这个笨蛋不知道怎么装系统，导致在装系统过程中的一些奇奇怪怪的经历。一开始我是上网搜索了Windows10密钥，想通过“白嫖手段”来装好系统，然后一不小心装成了企业版，然后就gg了
错误示范：
下面言归正传吧
第一步：
上网找密钥：2022的最新密钥
2022的最新密钥这个链接
一定要看清楚你要什么！！！
第二步：
1.点击所有设置
2.点击更新和安全
3.选择激活
4.点击更改产品密钥
5.就是把第一步找到的密钥复制粘贴进去
系统安装完毕后，就到了激活环节 第一步：Windows+x，点击管理员
第二步：输入命令
slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX slmgr /skms kms.03k.org slmgr /ato 会依次出现安装密钥成功，激活服务器成功以及激活产品
最后就是查看是否激活成功
如果出现了上面错误示范的情况，可以通过创建一个文本文档，在文档内输入：
接着将文件保存或者另存为，然后将其txt的后缀改成(.bat)批处理文件，然后运行，会出现跟激活环节一样的弹框，一直确定即可（一定是先在txt文档里输入了指令保存后再改文件后缀）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5771aa25c8e1a6d4fc0a73f90e4fcec2/" rel="bookmark">
			python-图片转pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import os from fpdf import FPDF pdf = FPDF() pdf.set_auto_page_break(0) # 自动分页设为False path = r"图片文件夹路劲" imagelist = [i for i in os.listdir(path)] for image in sorted(imagelist): pdf.add_page() pdf.image(os.path.join(path, image), w=190, h=150) # 指定宽高 pdf.output(os.path.join(path, "xxxx.pdf"), "F") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a91a62262786f3d9a210ddcec4f3f1/" rel="bookmark">
			python-svg转png
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import cairosvg def svg2png(svgPath,pngPath): print(svgPath+" 转为 "+pngPath) cairosvg.svg2png(url=svgPath, write_to=pngPath) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c410f05bff9dc115fa8ea9a12818a5/" rel="bookmark">
			python-svg转png-报错-AttributeError: module ‘PIL.ImageOps‘ has no attribute ‘exif_transpose‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误 File "D:\sdk\Anaconda3\lib\site-packages\cairosvg\image.py", line 78, in image image = ImageOps.exif_transpose(Image.open(BytesIO(image_bytes))) AttributeError: module 'PIL.ImageOps' has no attribute 'exif_transpose' 解决 pip install --upgrade pillow -i https://pypi.tuna.tsinghua.edu.cn/simple 然后就ok了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218f1a457bd0e991e93fde534ddd1abf/" rel="bookmark">
			基于python版本的谷歌GEE云计算平台使用，以DEM数据下载为例（GEE系列1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google Earth Engine(GEE)是谷歌的云计算平台，官网为：https://earthengine.google.com/，是目前世界上功能最全的云计算平台。
其支持深度学习和常规数据分析处理，其具有两个编辑器版本，支持JavaScript版本和python版本，其中python版本又分为网页版ipython版本和传统本地python版本。其中python版本能够调用更多的工具包，具有更好的使用前景，但目前官网样例代码，主要以JavaScript版本为主，该语言是web系统开发的主要前端语言，适合于项目系统开发的调用。本文以本地python版本为例。
1、谷歌账号的注册，鉴于某些原因，需要科学上网，其中账号注册过程中，会有一步是短信验证环节，一般情况下收不到验证码，因此需要使用手机端注册谷歌账号，教程可以百度，注册完成谷歌账号后，在注册GEE账号，其实还是谷歌账号，就是开通一下谷歌云计算平台的功能权限，教程网上也有。淘宝有购买谷歌账户的商家，一个账号需要15元，存在风险，不建议购买。
2、配置好gee的python本地环境，教程可以百度，在过程中存在谷歌账户验证失败10060和10061的错误提示，这是网络问题，需要更换一下科学上网工具，验证成功后就可以进行本地python代码编写了。
3、这里使用的是vscode编辑器，目前免费的功能强大且轻便的代码编译器，推荐使用。编辑的代码如下：
import ee import urllib.request ee.Initialize() # Get a download URL for an image. image1 = ee.Image('CGIAR/SRTM90_V4')#选用的dem版本为SRTM90_V4 path = image1.getDownloadUrl({ 'scale': 30, #设置dem的分辨率，这个是30米 'crs': 'EPSG:4326',#设置dem的投影，这个设置为wgs1984地理投影 'region': '[[-120, 35], [-119, 35], [-119, 34], [-120, 34]]'#设置下载区域的四角点坐标 }) print(path)#打印下载地址 urllib.request.urlretrieve(path, "demo.zip")#下载数据到本地，文件名为demo.zip 其中import ee为导入GEE运行环境，每次使用时必须用ee.Initialize()进行初始化。
结果如下：
arcgis中打开影像，可以看到如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b37d27ae15b9876c38ceb62b4c856f/" rel="bookmark">
			155. 最小栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小栈
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类:
MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。
示例 1:
输入：
[“MinStack”,“push”,“push”,“push”,“getMin”,“pop”,“top”,“getMin”]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]
解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); --&gt; 返回 -3.
minStack.pop();
minStack.top(); --&gt; 返回 0.
minStack.getMin(); --&gt; 返回 -2.
提示：
-231 &lt;= val &lt;= 231 - 1
pop、top 和 getMin 操作总是在 非空栈 上调用
push, pop, top, and getMin最多被调用 3 * 104 次
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85b37d27ae15b9876c38ceb62b4c856f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34f7f6bfc029e3e25615ff98e07e6bb/" rel="bookmark">
			windows家庭中文版升级至专业版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、更改产品密钥二、升级 一、更改产品密钥 进入windows设置，点击“更改产品密钥”：
在跳出的页面输入密钥J7QT3-3GCPG-9GVWT-CH2XR-GMRJM：
二、升级 跳出升级页面：
点击【开始】：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546d13ce50618ac35e318a96e5ac533f/" rel="bookmark">
			杰魔（Geomagic Design）逆向工程软件学习1-点云和多边形面片文件的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照扫描文件的处理顺序，扫描仪获得点云数据，点云即无数个点构成的表面数据，看起来像星云般。优化处理后，依照点云，可以理解为点与点间相互连线，连成三角形面片，由此形成面。然后，面也要做平滑等优化，最后封闭形成CAD实体。
1 点云
图1 兔子盒子点云数据
图2 上图放大后的点云
点云的优化处理：
所有的处理命令集中在点选项卡中。
点云数据首先考虑是否需要做优化处理，明显的杂点，点过多，点数据杂乱用相对应的命令处理。
其次，如果一个物件扫描了多个点云文件，为了让逆向更精确，可以使用合并或者结合命令将多个点云结合为一个点云。结合，只是单纯的将点云对齐交织在一起；合并，除了结合的功能外，直接将结合的点云生成了三角形面片。
法线信息向导，就是将点云构成的面提前定义了正反面。
面片创建精灵，集成了结合、优化、面片化功能的命令。
图3 点命令选项卡
2 面片
图4 兔子盒子形成的面片
2.1修补精灵和修复特征
修补精灵的基本使用比较简单，点开选项，观测里面所示的不好数据，直接点击确定执行即可。
图5 修补精灵和修复特征的选项卡命令
填孔功能，选择破洞边界，点击填孔，选择平坦、曲率填充选项或者在边界上右击填充，即可修复表面破洞。
删除特征也是一些平滑的过程，选择明显的突出点，用这个命令可以删掉并填充新的面。
有些扫描过程在物件表面会有一些圆形贴片，扫描后得到数据因此会有挺多同类型的圆形模型破洞，移除标记可以设置半径大小范围快捷地填补一类破洞。图6 兔子面片被移除标记命令锁定的圆形孔洞
2.2面片的优化
加强形状，让圆更圆，让角度更突出
由点云数据形成的面，上面的面片可能十分杂乱，因此可以通过整体再面片化、面片的优化、重新包覆将网格面片做得更好些。整体再面片化，是均匀大小地分布面片网格，可以手动调整网格大小；面片的优化，是在细节的地方面片网格密，在平整的地方面片疏，常用于有限元分析；重新包覆主要的功能是形成一个闭合的面和再次将面片优化。
消减细分平滑是在现有的网格基础上分别合并减少、细分增加、顺滑网格，一般在前面优化步骤后做。
图7 选项中的优化命令
2.3 面片数据的编辑工作
图8 面片编辑选项卡
分割和剪切功能相似，是将模型面片划分为几个部分，区别是分割是定义一个面作分界，剪切是在模型上定义一段曲线来分。
编辑境界，顾名思义是可以选定边界，在执行平滑、缩小、拉伸等功能。
图9 编辑境界功能设置选项
缝合境界类似于填补破面，但这是应用于小三角面缺失的情况，可以理解为自己不小心手动删除了一个三角面，然后测量已知其尺寸，设置缝合的自动寻找尺寸，就可自动将缺失面补齐。
偏移和赋厚，看起来都是面的平移。偏移第一没有厚度，单纯的面，其次不是平移，实际操作起来像放射性扩大。赋厚就是给面赋予厚度，这个看起来就是平移形成外表面，内外表面间形成厚度。
【以上图片均为黑龙教育逆向工程课程提供的模型截图，本文为课后总结笔记，如有侵权联系删除】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1c520eb44e84263ebbf6884d2993f4/" rel="bookmark">
			激光条纹中心提取——Zhang-Suen法python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zhang-Suen法 原理—— Zhang-Suen法代码——python代码 原理—— Zhang-Suen法 细化法（又称形态学骨架法）是通过对光条纹不断地进行腐蚀操作，剥离光条纹边界，得到单像素宽度的光条纹连通线（又称骨架）的形态学处理方法。该方法是通过细化技术，将光条纹区域的细化曲线作为光条纹中心线。 由于细化法是基于形态学的方法，只是对光条纹骨架进行提取，没有考虑到光条纹的横截面灰度分布特点。因此，细化法提取的光条纹中心线精度有限。另一方面，由于该方法需要大量时间来进行反复的细化操作，提取算法的运算速度被大大降低。
细化的方法有很多种，下面介绍一种常用的Zhang-Suen细化算法。细化算法的一般分为以下四个步骤，
（1）标记将被删除的边界点；
（2）删除做了标记的点；
（3）继续标记将被删除的剩余的边界点；
（4）删除标记过的点。反复应用这个基本过程，直到再也没有被删除的点为止，此时算法终止，生成了该区域的骨架。
假设目标像素点标记为1，背景像素点标记为0，在图上图中 的八个邻域如图所示，Zhang-Suen算法第一步循环所有前景像素点，对满足如下公式（1-5）的像素标记点进行删除。第二步和第一步类似，满足公式（1-6）的像素 标记点记为删除。循环上述两个步骤，直到两步中没有像素标记点记为删除为止，输出图像即为二值图像细化后的骨架。
其中 N(P0)表示八个邻域中非零像素标记点的个数（二值图像只有0和1）， S(P0)表示八个邻域中，按照顺时针方向，相邻两个像素出现0→1的次数，。
细化法由于需要做多次膨胀腐蚀操作，耗时较多，处理速度较慢，另外细化法对二值化的要求极高，往往因为噪声的干扰，将图像二值化会出现较大的误差。细化法属于形态学范畴，没有利用到灰度值之间的信息，因此对于复杂条件下的激光曲线提取效果较差。
代码——python代码 # 作用： zhang-sufa # 作者： yeluo import cv2 import numpy as np import time import matplotlib.pyplot as plt def ROI(img): indexXY = np.argwhere(img &gt; 0) minxy = np.min(indexXY, axis=0) maxxy = np.max(indexXY, axis=0) return minxy,maxxy def neighbours(x,y,img): i = img x1,y1,x_1, y_1 = x+1, y-1, x-1, y+1 return [i[y1][x], i[y1][x1], i[y][x1], i[y_1][x1], # P2,P3,P4,P5 i[y_1][x], i[y_1][x_1], i[y][x_1], i[y1][x_1]] # P6,P7,P8,P9 def transitions(neighbours): n = neighbours + neighbours[0:1] # P2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a1c520eb44e84263ebbf6884d2993f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c144f140daeb91618f5e7c4f0b685b6/" rel="bookmark">
			如何设置断点进行debug调试（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常见的bug调试 方式一：硬看，必要的时候在代码中间添加输出语句，看看输出的中间结果和自己想的是否一样
方式二：debug调试
debug调试步骤 1.设置断点（注意：可以设置多个断点）
2.debug as java application
3.常用操作
操作作用step into 跳入（f5）进入当前行所调用的方法中step over 跳过（f6）执行完当前行的语句，进入下一行step return 跳回（f7）执行完当前行所在方法，进入下一行drop to frame回到当前行所在方法的第一行resume 恢复执行完当前行所在断点的所有代码，进入下一个断点，如果没有就结束 按照例子进行debug 这是所要debug的代码，输出如下
所以代码有问题。现在开始debug
1.设置断点 在蓝色区域双击即可设置断点（再双击一次断点就会取消）
设置断点是为了使程序执行到断点停了一下，然后看看断点处的变量值和自己想的是否符合
2.debug as java application 选择debug as进行debug调试，然后出现以下界面
3.常用操作 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027f9223d2fc7ac858a1af6f22a25d87/" rel="bookmark">
			vue自定义组件中再嵌套其他组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实就是在容器组件里放一个插槽（slot)。
VUE的看点是组件。组件应用的典型例子，是一个网站首页。分为若干版块。每个版块都是一个方框框，样式一致，只是版块中间内容不同。对于VUE来说，很自然的想法，就是方框是一个组件，然后里面嵌套个性化内容，或者每个版块索性也做一个组件。这样就提出了题目描述的需求：如何实现自定义组件中再嵌套其他组件。俄罗斯套娃。
实现起来十分简单。就是在方框组件（即容器组件）中放置一个插槽（slot)。
1、容器组件（Block.vue)
&lt;template&gt; &lt;div&gt; &lt;div class="title"&gt; {{title}} &lt;/div&gt; &lt;div class="content"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: ['title'], setup () { return { } } } &lt;/script&gt; &lt;style scoped&gt; .title { height: 35px; } .content { padding: 5px; } &lt;/style&gt; 2、子组件(Yacht.vue)
&lt;template&gt; &lt;div&gt; &lt;Button&gt;太空飞船租赁业务备案&lt;/Button&gt; &lt;/div&gt; &lt;/template&gt; 3、调用
&lt;Block title="行业动态"&gt; &lt;/Block&gt; &lt;Block title="备案申请"&gt; &lt;Yacht /&gt; &lt;/Block&gt; 4、后记
这种需求本来十分普遍。但在某度上搜索，却极少能找到相应的答案。也许是我搜索条件不对？又或许，找计算机相关资料，某度其实真的需要改进太多。没办法，只能捏着鼻子用下去。
react上我也遇到过类似问题。解决方案见拙作：
react小记
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ecc2a81b2867959b22e4c8744408fb3/" rel="bookmark">
			虚拟机（Ubuntu18.04版本）中文字体乱码或混乱的一种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前因为自己制作了一个虚拟机，为了接轨pc机模式所以下了中文语言包，使用的一直也没什么问题，直到昨天打开虚拟机发现突然中文变成了一个个小方格，如下所示：
分析： 一时间无法直接操作了，但是在经过一番折腾后，我发现有两个特点：
1.在虚拟机中无法显示的中文（即小方格），选中复制到pc机上后可以正常显示中文；
2.我使用FileZilla以及mobaxterm连接到虚拟机上的linux系统，依旧可以正常显示中文。
以上述两点进行突破，查询得知：1.当中文的显示为乱码时，表明编码方式错误（编码方式有如GBK,UTF-8,Unicode码等），通俗来说就是GBK编码的放到utf-8编码格式来查看肯定会显示错误。2.当中文字符统一显示小方格时，表明发生了字体显示错误。 鉴于我之前中文都可以显示，那么也不可能会是突然的系统编码错误，所以只会是系统字体包产生了一些问题。
解决： 知道了原因，那便查询问题的解决方式，查阅资料得知：可以选择需要重新下载字体包（或者从pc机上拷贝），也可以选择从镜像iso中的字体包重启。
重新下载字体包的语言命令在csdn上有许多，都是通过yum命令来下载，安装包各有各的说法。我都试了一遍，没用，好吧只能另寻方案了。
那我想着之前的安装镜像还在，看看能不能找到字体安装包，但是这也比较麻烦，因为镜像不是自己做的，字体安装包的位置始终没有查询到（思路就是想先找到带fonts的），这个方案也失败了。
我自己的办法： 网上搜寻的方案都不太适合，但是我想如果是字体的原因，那么我直接换成英文的即可；于是我凭借着以前的一些记忆位置，找到了系统自带语言的安装包下载，顺利切换成了英文：
在系统中修改成功了语言包，相比小方格那样的算是好多了：
如果系统中无法修改，那么还是下载英文字体：
sudo apt update sudo apt -y install font-manager 再回过头来强调一下：如果编码错误改变编码，如果字体错误改字体（也可以选择第三方连接，照常显示）
问题是一个小问题，但是解决起来也比较麻烦，我试了许多的方法，但是对我的系统来说都不大行，这个方案比较全面，所以我还是贴出来供人们一个参考：
1、如果你需要一个纯中文的系统的话，设定LC_ALL= zh_CN.XXXX，或者LANG=
zh_CN.XXXX都可以，当然你可以两个都设定，但正如上面所讲，LC_ALL的值将覆盖所有其他的locale设定，不要作无用功。
2、如果你只想要一个可以输入中文的环境，而保持菜单、标题，系统信息等等为英文界面，那么只需要设定
LC_CTYPE＝zh_CN.XXXX，LANG=en_US.XXXX就可以了。这样LC_CTYPE＝zh_CN.XXXX，而
LC_COLLATE＝LC_MESSAGES＝……＝ LC_PAPER＝LANG＝en_US.XXXX。
3、假如你高兴的话，可以把12个LC_*一一设定成你需要的值，打造一个古灵精怪的系统：
LC_CTYPE＝zh_CN.GBK/GBK(使用中文编码内码GBK字符集)；
LC_NUMERIC=en_GB.ISO-8859-1(使用大不列颠的数字系统)
LC_MEASUREMEN=de_DE@euro.ISO-8859-15(德国的度量衡使用ISO-8859-15字符集)
罗马的地址书写方式，美国的纸张设定……。估计没人这么干吧。
4、假如你什么也不做的话，也就是LC_ALL，LANG和LC_*均不指定特定值的话，系统将采用POSIX作为lcoale，也就是C
locale。 http://apps.hi.baidu.com/share/detail/17181078
补充 因为上述方案只是将系统的中文包改成了英文包，实际的上网中文还是会显示小方格（虽然我只是拿linux来学习，但终归还是觉得别扭）；于是我想接着从系统中更新下载中文包，结果在下载的过程中会一直报错“Failed to download package files Check your Internet connection.”。开始我还以为是我的网络又出现了问题，在我不停重复联网后，确认不是网络问题。在网上搜寻，发现只要修改下载源即可：
按Alt+ F2并输入software-properties-gtk
接着设置成国内的就近服务器即可：
后续就能正常下载，网页上的中文也可以正常显示了：
最后 至于为什么会出现这样的情况，我认为是Ubuntu18版部分功能停止服务，升级一下也许就可以。
个人思路仅提供参考！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8062171b03aad4dd0758561b04293c3/" rel="bookmark">
			CSDN如何自动生成目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、CSDN如何生成目录2、一种方法是点击选中标题行，点击标题即可自动生成3、大部分人说的添加目录我不会，哈哈哈哈 1、CSDN如何生成目录 2、一种方法是点击选中标题行，点击标题即可自动生成 3、大部分人说的添加目录我不会，哈哈哈哈 ①没生成目录前，显示结果
②在标题前添加“@[TOC]”，再将它们设置为标题，即可自动生成为目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1e99fc5fdb93db165d39a58e7a7270/" rel="bookmark">
			nacos基础-注册中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务实例在启动时注册到服务注册表，并在关闭时注销 服务消费者查询服务注册表，获得可用实例服务注册中心需要调用服务实例的健康检查API来验证它是否能够处理请求
8.1 服务注册 spring-cloud-alibaba-nacos-discovery这个jar包下的spring.factories文件引入了
一个关键的配置文件NacosDiscoveryAutoConfiguration实现了ApplicationListener接口。在spring容器启动的时候，会调用其重写的onApplicationEvent方法，因此我们进入此方法。
public void onApplicationEvent(WebServerInitializedEvent event) { this.bind(event); } /** @deprecated */ @Deprecated public void bind(WebServerInitializedEvent event) { ApplicationContext context = event.getApplicationContext(); if (!(context instanceof ConfigurableWebServerApplicationContext) || !"management".equals(((ConfigurableWebServerApplicationContext)context).getServerNamespace())) { this.port.compareAndSet(0, event.getWebServer().getPort()); this.start(); } } public void start() { if (!this.isEnabled()) { if (logger.isDebugEnabled()) { logger.debug("Discovery Lifecycle disabled. Not starting"); } } else { if (!this.running.get()) { this.context.publishEvent(new InstancePreRegisteredEvent(this, this.getRegistration())); //开始注册 this.register(); if (this.shouldRegisterManagement()) { this.registerManagement(); } this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f1e99fc5fdb93db165d39a58e7a7270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1bbd4de216ccff52d78618e2f13b18d/" rel="bookmark">
			MTK TP调试记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TP调试记录 调试问题总结 I2C不通
1、I2C通信地址
​ gt911有两个适配的I2C通信地址供选择，两个地址对应的RST和EINT上电时序是不一样的，但在驱动里，会写好选择使用哪个I2C通信地址，因为驱动内一般会对IC的上电时序进行设定，便指定了使用哪个I2C地址。配置时选择对应的I2C地址即可。
2、检查是否上电，检查上电时序。
3、检查RST、INT引脚是否存在被其它地方使用了，可以通过adb工具进行查看，引脚是否与配置的一致。
4、根据原理图检查引脚号是否配置正确，可以根据adb工具对对应引脚进行拉高拉低操作，同时用示波器看是否有控制到；如果出现没有反应的情况，那可能是引脚号配错了，可根据引脚复用表进行对照检查。
5、检查引脚硬件连接。
TP报点不对、原点设置不对、有区域性触摸无反应
1、检查TP的分辨率与屏幕是否一致。
2、与fae确认固件是否正确。
3、横屏使用时，要注意检查是使用强制横屏还是物理旋转横屏，如果是强制横屏，那么就需要取消旋转横屏，即将MTK_LCM_PHYSICAL_ROTATION值置为0，否则会报点错误、区域性触摸无反应。
其他情况后面再补上
记录 客户硬件上，座子厚度与TP金手指厚度不匹配，接触不良；TP_RST引脚标错
ic型号：gt9xx；
分辨率：480*800
这块TP，调试了很久，IIC通信不了，由于调试经验不足，一开始并未想到连接处接触不良问题，一心只修改软件，最后发现问题时捶胸顿足不已。
解决完接触不良问题，确定接触没问题。
I2C还不通，使用示波器查看RST、INT引脚波形，发现RST没有波形，使用adb命令拉高该引脚也没变化，于是审查引脚复用表（也可以使用adb继续拉高可能的引脚逐个尝试），修改引脚后便通了。
报点不对的情况，首先要与fae确定固件是否正确，再确定软件上是否将更新固件的宏打开（如果出厂时烧好了固件便将其关闭），强制横屏使用时需要将物理旋转关闭，否则TP报点也有影响。固件信息不正确
型号：GSLxxxx
调试完成后，触摸报点不正确，检查软件上配置是没问题的，向fae请求协助，更换固件后便报点正常。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa10965cb05e4f1f3217b0abc149230a/" rel="bookmark">
			一个简单的JavaWeb项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.打开IDEA，创建一个web项目2.导入javax.servlet.jar3.创建一个servlet类4.配置web.xml5.配置Tomcat6.传参数给jsp7.总结 1.打开IDEA，创建一个web项目 2.导入javax.servlet.jar 此jar包可以使用HttpServlet类
3.创建一个servlet类 按住A/t+Insert 点击重写方法
找到doGet和doPost方法并且重写
4.配置web.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;firstServlet&lt;/servlet-name&gt;	&lt;servlet-class&gt;com.xd.servlet.first_servlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;firstServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/first&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; &lt;servlet-name&gt;:名字任意取，并且要和servlet-mapping里的servlet-name对应起来 &lt;servlet-class&gt;:找到写的类的位置 &lt;url-pattern&gt;:地址任意取，/所取的名字 5.配置Tomcat 如果没有tomcat，需要先去官网下载tomcat，并且配置好环境变量
配置好如下参数
添加项目的war包，如果没有war包，需要去project的Artifacts中添加一个war包
其他小tips
6.传参数给jsp public class first_servlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { HttpSession session = req.getSession(); session.setAttribute("name","第一个JavaWeb网站"); req.getRequestDispatcher("/index.jsp").forward(req,resp); //请求转发 } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } &lt;%@ page contentType="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa10965cb05e4f1f3217b0abc149230a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0f65a5cb4110d3b6eebc9c6f7c7fca/" rel="bookmark">
			koji使用外部仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 使用koji来编译rpm包时，因为rpm包会依赖很多的其他的rpm包，而这时我们自己的build tag对应的rpm包又不足够时，我们就会使用外部仓库来提供依赖包，那么koji如何选择依赖包来自于build tag对应仓库还是来自于外部仓库呢？同时又会有什么样的条件呢？这就和我们引进外部仓库时使用的合并模式（merge mode）及优先级等等一些选项相关了。
引进外部仓库 使用指令就可以新建外部仓库
$ koji add-external-repo -t dist-foo-build dist-foo-external-repo http://repo-server.example.com/path/to/repo/for/foo/\$arch/ 我们看下add-external-repo的help:
$ koji add-external-repo --help Usage: koji add-external-repo [options] &lt;name&gt; [&lt;url&gt;] (Specify the --help global option for a list of other help options) Options: -h, --help show this help message and exit -t TAG, --tag=TAG Also add repo to tag. Use tag::N to set priority -p PRIORITY, --priority=PRIORITY Set priority (when adding to tag) -m MODE, --mode=MODE Set merge mode -a ARCH1,ARCH2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd0f65a5cb4110d3b6eebc9c6f7c7fca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923d15eeef70bc2191baf5dbe131900d/" rel="bookmark">
			Fusion Storage 分布式存储三个组件作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MDC(Metadata Controller） ：源数据控制 实现对分布式集群的状态控制，以及控制数据分布式规则，数据重建规则 MDC默认部署在3个节点的ZK 盘上，形成MDC集群
VBS（Virtual Block System）：虚拟块存储管理组件，负责卷元数据的管理，提供分布式集群接入点服务，使计算机能够通过VBS访问分布式存储资源，每个节点默认部署一个VBS进程，形成VBS进程，节点上也可以通过部署多个VBS来提升IO性能
OSD（Object Storage Device）：对象存储设备服务，执行具体的I/O操作，在每个服务器部署多个OSD进程，一块磁盘默认对应部署一个OSD进程，在SSD卡作为主存储时， 为了充分发挥SSD卡的性能，可以在一个ssd卡上部署多个OSD进程进行管理，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cf1584d257b34933036c68ed2a9e531/" rel="bookmark">
			关于RSCB中不提供PDB文件格式的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近利用pymol批量下载结构文件的时候发现很多pdb格式的文件无法下载，而且pymol下载结构文件的时候默认是下载mmcif格式的，大概研究了一下这种情况的原因。
关于文件格式 PDB,PDBx/mmCIF PDBx和mmCIF格式是官方支持的文件格式PDB数据库中所有的结构都会有PDBx/mmCIF格式(而不是PDB格式)PDBx/mmCIF会将会不断扩展包含新的内容，但是也会保证向前兼容 使用PDBx/mmCIF而不是PDB的原因 由于PDB格式从2012年以来它的文件格式没有进行扩展，因此它支持的数据量会比较局限，之后的结构数据因为技术手段的革新会发生较大的变化，但是pdb格式的扩展性较弱。之后的数据会主要是使用PBDx/mmCIF来保存结构的数据。 注:PDB数据库目前也会接受NMR和EM产生的PDB格式文件，这些PDB格式的数据文件也会被转换为PDBx/mmCIF储存下来，也就是说所有的结构都有PDBx/mmCIF格式文件,只有部分结构有PDB格式文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/216717abc7c1cc10d96faaf0fee0657d/" rel="bookmark">
			参考文献使用交叉引用的注意事项（实用篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、使用交叉引用插入文献（插入一篇文献操作方法）二、使用交叉引用插入文献（连续插入两篇文献操作方法）三、使用交叉引用插入文献（连续插入三篇及以上的文献操作方法）四、将交叉引用的参考文献角标弄为上角标格式 一、使用交叉引用插入文献（插入一篇文献操作方法） 1、 将论文中所有的参考文献按照自动编号的形式在论文的参考文献章节中排好序；（不要手动标号！！！）
2、按照步骤中的①②③④⑤进行，即可完成文献插入。
二、使用交叉引用插入文献（连续插入两篇文献操作方法） 1、按照插入一篇文献的方法，在同一个位置插入第二篇文献，如下图所示
2、连续插入两篇文献以后，想要将[1] [2]这种格式转化为[1,2]这种格式，需要进行以下步骤：
①分别将文献1和文献2进行切换域代码操作，其结果如下图
②在文献1的域代码末尾添加\# "[0"，在文献2的域代码末尾添加\# "0]"，则显示结果如下
③选中添加完成后的文献1和文献2的域代码，鼠标右键，点击更新域，其效果如下
④在12之间添加英文逗号即可完成连续两篇文献的插入格式。
三、使用交叉引用插入文献（连续插入三篇及以上的文献操作方法） 1、按照插入一篇文献的方法，在同一个位置插入多篇文献，如下图所示
2、使用交叉引用连续插入多篇文献以后，想要将[1][2][3]这种格式变为[1-3]的格式，需进行以下步骤：
①将文献1、2、3的域代码切换出来，如图所示
②在第一个文献域代码的末尾添加\# "[0"，在中间文献域代码末尾添加\# ""，在最后一篇文献末尾添加\# "0]"，如下图所示
③添加完成后，选中三篇文献的域代码，鼠标右键，更新域即可，如下图所示
④在13中间手动添加“-”即可
四、将交叉引用的参考文献角标弄为上角标格式 用Word打开论文后，按下Ctrl+H，在弹出的“替换”对话框中，单击“高级（或者是更多按钮）”按钮，勾选“使用通配符”，在“查找内容”框中输入\[[0-9]{1,2}\]，(适用两位编号，三位为{1,2,3})，点击“替换为”框，按住键盘的“ctrl+shift+=”，框的下边会出现“上标”这两个字，最后点击“全部替换”即可完成。
图中连续的文献格式无法进行上标操作，通过手动改为上标即可。选中[1-3]，在“开始”界面找到上标按钮，即可完成多篇文献的上标引用操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0555e0db2812594560d54a933d42f956/" rel="bookmark">
			sqlserver 筛选器用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		34work
2
3 结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1768a4bef298681e32c9e10f564d421b/" rel="bookmark">
			（字节面试题）青蛙跳台变形（一次 k 阶台阶）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你一开始在底部，每次可以向上迈最多K级台阶（最少1级），问到达第N级台阶有多少种不同方式，一个学姐在字节面试面到的题目，一次 可以 迈 k 阶台阶，普通的青蛙跳台是迈 1 或者 2，现在是 1 - k 都有可能，所以，依旧使用数组进行求解：范围在 i - k 之间的数都加上，动态转移方程：
dp[n] = dp[n - 1] + dp[n - 2] + ..... + dp[n - k] 解：
import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int k = sc.nextInt(); int[] dp = new int[n + 1]; dp[0] = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= k &amp;&amp; i - j &gt;= 0; j++) { dp[i] += dp[i - j]; } } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1768a4bef298681e32c9e10f564d421b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a913b0548b5f9847326ebf2ce711199/" rel="bookmark">
			Java（石头剪刀布游戏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package class_experiment_questions; import java.util.*; public class rock_paper_scissors { static int wins = 0; static int ties = 0; static int losses = 0; public static void main(String[] args) { System.out.println("This programe plays game of rock_paper_scissors against the computer." + "You'll type in your guess of 1(rock),2(paper)or3(scissors) and try to beat the computer as many times as you can."); Scanner in = new Scanner(System.in); System.out.print("Best out of how many games(must be odd)？"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a913b0548b5f9847326ebf2ce711199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd51d35e27d84825dea981f70255f4a0/" rel="bookmark">
			PyG框架构建GCN、GAT、GraphSAGE模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取Cora数据集，查看训练、测试、验证集比例 from torch_geometric.datasets import Planetoid ​ # ''' # 下载报错，将所有data文件下载到本地 # https://github.com/kimiyoung/planetoid # 将cora相关文件放入到raw文件中 # ''' ​ dataset = Planetoid(root='./tmp/Cora',name='Cora') print((dataset[0].train_mask).sum()) print((dataset[0].test_mask).sum()) print((dataset[0].val_mask).sum()) print(dataset[0]) 获取模型 import torch import torch.nn.functional as F from torch_geometric.nn import GCNConv, SAGEConv, GATConv 构建GCN网络，训练 验证 class GCN_Net(torch.nn.Module): def __init__(self, features, hidden, classes): super(GCN_Net, self).__init__() self.conv1 = GCNConv(features, hidden) self.conv2 = GCNConv(hidden, classes) def forward(self, data): x, edge_index = data.x, data.edge_index ​ x = self.conv1(x, edge_index) x = F.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd51d35e27d84825dea981f70255f4a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03eb9657ebb9c8035692152121739b05/" rel="bookmark">
			基于Autosar Can driver的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Can driver是最低层的一部分，执行硬件访问，并向上层提供一个硬件独立的API。唯一可以访问Can模块的上层是Can If模块。Can模块提供启动传输的服务，并调用CanIf模块的回调函数，以独立于硬件通知事件。此外，它还提供服务来控制属于同一CAN硬件单元的CAN控制器的行为和状态。几个CAN控制器可以由一个CAN模块来控制，只要它们属于同一CAN硬件单元。
我们来看一下图片
如果只使用一个传输缓冲区，可能会发生内部优先级反转。由于优先级较低，存储在缓冲区中的消息会等待到总线上的传输数据稳定下来。在等待时间内，该消息可以防止由同一微控制器产生的更高优先级的消息来通过总线传输。
在一些CAN总线的调用中，可能会出现外部优先级反转的问题。让我们假设一个CAN节点希望传输一个具有高优先级的连续消息包，这些消息存储在不同的消息缓冲区中。如果CAN网络上这些消息之间帧的空间大于CAN标准定义的最小空间，则第二个节点能够开始对较低优先级消息的传输。最小帧空间由3个隐性位组成的间隔字段所决定的。
介绍和功能
CAN driver一共包含着5个功能，由底向上分别为: CAN L-PDU; HTH/HRH; Hardware Object; CAN Controller A,B,C...和CAN Hardware Unit。
CAN Hardware Unit：CAN Hardware可以由一个或多个相同类型的CAN Controller和一个或多个CAN RAM区域组成。
CAN Controller：一个CAN Controller只能去服务于一个物理通道。
Hardware Object：可以想成CAN Hardware Unit 在 CAN RAM区域内的一个PDU缓冲区。
HTH/HRH：全部由CAN driver提供；HRH，通常只表示一个硬件对象(用于软件过滤);HTH，通常表示一个或多个硬件对象。 CAN L-PDU：CAN协议数据单元。 由ID、DLC、Data(SDU)组成。 CAN driver可见。
结合上面的理解，可以看一下下面这幅图，会更直观一些。
我们再谈一下CAN Driver对其它模块的依赖关系。
CAN IF：首先说一下CAN IF，CanIf模块是Can驱动程序的上层。 只有上层能访问Can模块的为CanIf模块。
DET：如果“Default error Tracer”开关打开，Can Module应该能够检测到一些开发错误并报告给DET Module。
DEM：使用服务Dem_ReportErrorStatus()将生产代码相关错误报告给DEM。
ECUM：与Wakeup相关，当CAN总线发生唤醒时调用EcuMCheckWakeUp()。 CAN Dirver的功能
Driver State Machine：里面只包含两种状态，一种是CAN_UNINIT，另一种是CAN_READY，可以理解为假如一个初始化信号传入CAN_UNINIT，因为它自身是不可以将信号初始化的，所以会把信号传给CAN_READY，然后CAN_READY将非初始化的信号再传给CAN_UNINIT。
Can Controller State Machine：有四种状态（UNINIT;STOPPED;SLEEP;STARTED）。
UNINIT ：CAN控制器未初始化。 所有属于CAN Module的寄存器处于Reset状态。 禁用Can Interrupt。 不加入Can总线。 STOPPED：CAN控制器被初始化但没有加入总线。 SLEEP：CAN BUS直接支持CAN Hardware，而SLEEP不同于STOPPED。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03eb9657ebb9c8035692152121739b05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d2e55a323ee396d05678b820fcecec6/" rel="bookmark">
			vsomeip —— 10分钟快速了解 vsomeip （vsomeip wiki 文档翻译）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档声明：
以下资料均属于本人在学习过程中产出的学习笔记，如果错误或者遗漏之处，请多多指正。并且该文档在后期会随着学习的深入不断补充完善。感谢各位的参考查看。
笔记资料仅供学习交流使用，转载请标明出处，谢谢配合。
如果存在相关知识点的遗漏，可以在评论区留言，看到后将在第一时间更新。
作者：Aliven888
vsomeip in 10 minutes 这篇文章是对 vsomeip 官方 wiki 文档的一个翻译。属于个人学习开发笔记的一个记录。
SOME/IP 简介 SOME/IP 是 Scalable service-Oriented middleware over IP 的缩写。 该中间件专为典型的汽车用例而设计，并与 AUTOSAR 兼容（至少在有线格式级别上）。 可在 SOME/IP 上获得可公开访问的规范。 在这个 wiki 中，我们不想进一步深入探讨另一个中间件规范的原因，而是想对 SOME/IP 规范的基本结构及其开源实现 vsomeip 给出一个粗略的概述，而不要求任何完整性。
让我们从 SOME/IP 规范的三个主要部分开始：
On-wire formatProtocolService Discovery SOME/IP On-Wire Format 原则上，SOME/IP 通信由设备或订阅者之间通过 IP 发送的消息组成。 详见如下图示：
这里你会看到两个设备（A 和 B）； 设备 A 向 B 发送一条 SOME/IP 消息，并收到一条回复消息。
底层传输协议可以是 TCP 或 UDP； 对于消息本身，这没有什么区别。
现在我们假设设备 B 上正在运行一个服务，该服务提供了一个由该消息从设备 A 调用的函数，而返回的消息就是答案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d2e55a323ee396d05678b820fcecec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a647683f9ed739a559752213964eaf5/" rel="bookmark">
			反向输入数字C语言（基础题训练）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
将一个四位数反向输出。
输入描述：
一行, 输入一个整数n(1000&lt;=n&lt;=9999)
输出描述：
针对项输入反向出一个四位数实例：输入1234 输出4321
解释：
1.n%10取的是这个这个数字的最右面的位数也就是个位
2. n/10消除个位
3.个位除以10就是零，就跳出while循环
4.n为几位就会循环几次
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/851d835753e51b9448bb400532cf691c/" rel="bookmark">
			/usr/bin/bash: eval: line 130: unexpected EOF while looking for matching `‘‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**原因：**做GitLab-CI时，.gitlab-ci.yml文件的script脚本写错，一条命令写成了多行，如下图所示，写了多个-,导致最后的双引号和前面的双引号都是单独的双引号，相当于多条命令。
**解决：**把多余的-去掉就行了，只留第一行的-。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b31e722172bfb121c75c9f7574df010/" rel="bookmark">
			GitLab-CI bash:xx: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**问题：**在做GitLab-CI持续集成时，Pipeline执行job时报下图所示的错误，明明我做的镜像是有linux环境的，但是还是报命令未找到的错误。
**原因：**是我的script脚本写换行语句时加上了&amp;&amp; \的字样所以导致了这个错误
**解决：**如果是一条命令，在.gitlab-ci.yml文件中直接换行即可，或者光写&amp;&amp;或者\，两者只保留一个即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d85539cd217169eb823febc76efbc1c/" rel="bookmark">
			Ｃ＃基础（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C#简介
C#是微软公司发布的一种面向对象的、运行于.NET Framework之上的高级程序设计语言。C#看起来与Java有着惊人的相似；它包括了诸如单一继承、接口、与Java几乎同样的语法和编译成中间代码再运行的过程。但是C#与Java有着明显的不同，它借鉴了Delphi的一个特点，与COM（组件对象模型）是直接集成的，而且它是微软公司 .NET windows网络框架的主角。
C#是一种安全的、稳定的、简单的、优雅的，由C和C++衍生出来的面向对象的编程语言。它在继承C和C++强大功能的同时去掉了一些它们的复杂特性（例如没有宏以及不允许多重继承）。C#综合了VB简单的可视化操作和C++的高运行效率，以其强大的操作能力、优雅的语法风格、创新的语言特性和便捷的面向组件编程的支持成为.NET开发的首选语言。
二、Create a New C# Project
环境：Visual Studio (VS)
编译 &amp; 执行 C# 程序
如果您使用 Visual Studio.Net 编译和执行 C# 程序，请按下面的步骤进行：
1、启动 Visual Studio，在菜单栏上选择 File -&gt; New -&gt; Project，从模板中选择 Visual C#，然后选择 Windows，选择 Console Application，为您的项目制定一个名称，然后点击 OK 按钮；
2、新项目会出现在解决方案资源管理器（Solution Explorer）中，在代码编辑器（Code Editor）中编写代码，点击 Run 按钮或者按下 F5 键来运行程序。会出现一个命令提示符窗口（Command Prompt window），显示 输出结果。
或者通过命令符工具
打开一个文本编辑器，添加上面提到的代码，保存文件为 helloworld.cs
打开命令提示符工具，定位到文件所保存的目录
键入 csc helloworld.cs 并按下 enter 键来编译代码
如果代码没有错误，命令提示符会进入下一行，并生成 helloworld.exe 可执行文件
接下来，键入 helloworld 来执行程序。
您将看到 “Hello World” 打印在屏幕上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d85539cd217169eb823febc76efbc1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595bddf06bb4abe985cb3c352376ed22/" rel="bookmark">
			超详细的R语言热图之complexheatmap系列（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取更多R语言和生信知识，请关注公众号：医学和生信笔记。 公众号后台回复R语言，即可获得海量学习资料！
目录
第一章 简介
1.1 设计理念
1.2 各章节速览
第二章 单个热图
2.1 颜色
2.2 行标题/列标题
2.3 聚类
2.3.1 距离计算方法
2.3.2 聚类方法
2.3.3 自定义聚类树颜色
2.3.4 重新排列聚类树
2.4 改变行/列顺序
2.5 Seriation包排序
2.6 行名/列名
2.7 热图分割
2.7.1 通过K-means方法分割
2.7.2 通过离散型变量分割
2.7.3 通过聚类树分割
2.7.4 切片顺序
2.7.5 分割标题
2.7.6 分割的图形参数
2.7.7 分割宽度
2.7.8 分割注释条
2.8 光栅图（略）
2.9 自定义热图主体
2.9.1 cell_fun
2.9.2 layer_fun
2.10 热图大小
本系列是对ComplexeHeatmap包的学习笔记，部分内容根据自己的理解有适当的改动，但总体不影响原文。如有不明之处，以原文为准。原文请见：ComplexHeatmap Complete Reference
第一章 简介 复杂热图可用于展示同一个数据集或不同数据集之间的关系或揭示内部规律。ComplexHeatmap包可提供灵活的热图展示及高度自定义的注释图形。
1.1 设计理念 一个完整的热图由热图主体和热图组件构成。热图主体可以被分为不同的行和列，热图组件包括行/列标题，聚类树，行名/列名，行注释条/列注释条。
热图列表由多个热图主体和热图注释组成，但不同的热图主体和注释被有序排列，使得彼此之间具有较好的可比性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/595bddf06bb4abe985cb3c352376ed22/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/255/">«</a>
	<span class="pagination__item pagination__item--current">256/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/257/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>