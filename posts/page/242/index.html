<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302df6fbc2095cc3f8aeb020308636f2/" rel="bookmark">
			华为云服务器区域节点哪个快测速？可用区选择攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为云服务器区域包括北京、上海、广州、深圳、贵阳、中国香港、新加坡、曼谷及非洲约翰内斯堡等，每个地域可选多个可用区。华为云服务器区域可以就近选择，可用区根据应用实际容灾性和网络延时选择，华为云百科来详细说下华为云服务器区域节点分布表以及选择方法：
华为云服务器区域和可用区
活动：华为云服务器39元一年起，多配置可选，有香港节点
华为云服务器区域和可用区分布表 华为云服务器区域（Region）是指云服务器数据中心所在的地理位置，云服务器区域不同，本地到云服务器的网络延迟Ping值也不同，同区域下的云服务器、云数据库、对象存储可通过内网连接；可用区是指同地域下风火水电相互独立的区域，可用区内逻辑上再将计算、网络、存储等资源划分成多个集群，一个可用区故障不会影响另一个可用区的正常运行，同地域下的不同可用区之间使用高速光纤相连。
华为云服务器区域和可用区
华为云服务器区域节点遍布全球，包括华北-北京、华东-上海、华南-广州、华南-深圳、西南-贵阳、中国-香港、非洲-约翰内斯堡、亚太-曼谷及亚太-新加坡，区域及可用区分布表如下：
区域名称区域可用分区名称可用分区非洲-约翰内斯堡af-south-1af-south-1a可用区1af-south-1b可用区2华北-北京四cn-north-4cn-north-4a可用区1cn-north-4b可用区2cn-north-4c可用区3cn-north-4g可用区7华北-北京一cn-north-1cn-north-1a可用区1cn-north-1b可用区2cn-north-1c可用区3华东-上海二cn-east-2cn-east-2a可用区1cn-east-2b可用区2cn-east-2c可用区3cn-east-2d可用区4华东-上海一cn-east-3cn-east-3a可用区1cn-east-3b可用区2cn-east-3c可用区3华南-广州cn-south-1cn-south-1a可用区1cn-south-2b可用区2cn-south-1c可用区3cn-south-1e可用区5cn-south-1f可用区6华南-广州-友好用户环境cn-south-4cn-south-4a可用区1cn-south-4b可用区2cn-south-4c可用区3华南-深圳cn-south-2cn-south-2a可用区1西南-贵阳一cn-southwest-2cn-southwest-2a可用区1亚太-曼谷ap-southeast-2ap-southeast-2a可用区1ap-southeast-2b可用区2ap-southeast-2c可用区3亚太-新加坡ap-southeast-3ap-southeast-3a可用区1ap-southeast-3b可用区2ap-southeast-3c可用区3中国-香港ap-southeast-1ap-southeast-1a可用区1ap-southeast-1b可用区2 华为云服务器区域节点测速 华为云不同区域云服务器终端节点测速表：
区域名称区域终端节点（Endpoint）协议类型非洲-约翰内斯堡af-south-1ecs.af-south-1.myhuaweicloud.comHTTPS华北-北京四cn-north-4ecs.cn-north-4.myhuaweicloud.comHTTPS华北-北京一cn-north-1ecs.cn-north-1.myhuaweicloud.comHTTPS华东-上海二cn-east-2ecs.cn-east-2.myhuaweicloud.comHTTPS华东-上海一cn-east-3ecs.cn-east-3.myhuaweicloud.comHTTPS华南-广州cn-south-1ecs.cn-south-1.myhuaweicloud.comHTTPS华南-广州-友好用户环境cn-south-4ecs.cn-south-4.myhuaweicloud.comHTTPS拉美-墨西哥城一na-mexico-1ecs.na-mexico-1.myhuaweicloud.comHTTPS拉美-圣地亚哥la-south-2ecs.la-south-2.myhuaweicloud.comHTTPS欧洲-巴黎eu-west-0ecs.eu-west-0.myhuaweicloud.comHTTPS西南-贵阳一cn-southwest-2ecs.cn-southwest-2.myhuaweicloud.comHTTPS亚太-曼谷ap-southeast-2ecs.ap-southeast-2.myhuaweicloud.comHTTPS亚太-新加坡ap-southeast-3ecs.ap-southeast-3.myhuaweicloud.comHTTPS中国-香港ap-southeast-1ecs.ap-southeast-1.myhuaweicloud.comHTTPS 华为云服务器区域选择 如何选择华为云服务器区域？云服务器区域选择一般遵循就近原则，用户距离云服务器区域越近，网络延迟越低，速度越快。
中国大陆区域：中国大陆区域北京、上海、广州等地域在华为云基础设施、BGP高速网络的加持下，国内地域网络延迟区别不大，如果是中国内地区域使用可以随心选择大陆地域；亚太地区：除中国大陆以外的亚太地区用户，可以优先选择“中国-香港”、“亚太-曼谷”或“亚太-新加坡”区域；非洲地区：非洲地区用户可以优先选择“非洲-约翰内斯堡”区域；欧洲地区：欧洲地区用户可以优先选择“欧洲-巴黎”区域；拉丁美洲地区：拉丁美洲地区用户可以选择“拉美-圣地亚哥”区域，“拉美-圣地亚哥”区域位于智利。 另外华为云不同区域的云服务器价格可能有所差异，在选择云服务器区域时，也可以考虑下不同区域的价格因素，参考：华为云服务器价格计算器
华为云服务器可用区选择 华为云服务器可用区怎么选择？什么是可用区？可用区是指同地域下，网络和电力相互独立的区域，一个可用区出现故障不会影响另一个可用区的运行，可用区之间可以做到故障隔离。将业务部署在不同可用区，可以提供应用的可靠、容灾性。
单机应用：如果是单机应用，哪个可用区都可以，可用区随机分配即可；高容灾能力：如果应用对容灾性要求较高，那么云服务器吧建议将应用部署在同地域下的不同可用区内，这样一个可用区出现故障，另一个可用区依旧可以正常运行，不会影响业务；网络延时要求较低：如果你的应用需要较低的网络延时，那么可以将应用部署在同一可用区内，因为同一可用区内实例之间的网络延时更小。 以上是华为云百科分享的关于华为云服务器区域、可用区分布表、华为云服务器不同区域速度测试以及区域和可用区选择方法。更多关于华为云服务器配置及报价，请以官方页面为为准：
官方文档：华为云服务器配置及精准报价官方详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7e84d71b9d314f746a9cc6753256e5/" rel="bookmark">
			node.js jwt 封装 token生成 token验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NodeJS 中如何应用 JWT 首先安装 jsonwebtoken npm install jsonwebtoken --save 引入 jsonwebtoken const jwt = require('jsonwebtoken') 封装 jwt.js // token生成的密匙，根据自己需求定义 const jwtKey = 'dengxiansheng' // token生成函数(jwtSign)，有效时间为一个小时 const jwtSign = (data) =&gt; { const token = jwt.sign(data, jwtKey, {expiresIn: 60 * 60}) return token } // token验证函数(jwtCheck) const jwtCheck = (req, res, next) =&gt; { //前端headers传来的token值: const token = req.headers.token jwt.verify(token, jwtKey, (err, data) =&gt; { if (err) { res.send({ status: '401', msg: 'token无效' }) } else { req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b7e84d71b9d314f746a9cc6753256e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc73681ffb2c017188ae4e271407867c/" rel="bookmark">
			POI数据获取-Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POI数据是什么？“Point of interest”的缩写，翻译为“兴趣点”。兴趣点数据可以获得研究区内的餐厅服务、风景区、交通设施等等兴趣点数据，根据这些数据可以进行城市功能区分类、快递点的时空分布特征、人口活动区等等研究，同时结合夜光数据也可进行多源数据的耦合研究。
本文为大家带来兴趣点提取的方法，其中Key需要到高德地图API账号进行申请。
申请链接：
https://console.amap.com/dev/key/app
POI分类编码下载网址：
https://lbs.amap.com/api/webservice/download
提交后即可获取第一张图所示的key
爬取代码如下：
from urllib.parse import quote import urllib.request import pandas as pd import xlwt import json class getpoi: output_path = "D:/pycharm/POI/POI data/"#输出路径 path_class = "E:/Learn/Analysis of urban ribbon/amap_poicode/amap_poicode.xlsx"#POI分类编码表位置 amap_web_key = 'fd6043f1ad500d2b5dd40af6e555b840'#高德地图API_KEY poi_search_url = https://restapi.amap.com/v3/place/text?key=%s&amp;extensions=all&amp;keywords=&amp;types=%s&amp;city=%s&amp;citylimit=true&amp;offset=25&amp;page=%s&amp;output=json #申请密钥 cityname = '北京' areas = ['昌平区']#如爬取整个北京市，建议分区爬取，以免出现数据量限制的问题 totalcontent = {} def __init__(self): data_class = self.getclass() for type_class in data_class: for area in self.areas: page = 1; if type_class['type_num'] / 10000 &lt; 10: classtype = str('0') + str(type_class['type_num']) else: classtype = str(type_class['type_num']) while True: if classtype[-4:] == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc73681ffb2c017188ae4e271407867c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b132a0fd256f5aa102926bb12db9b82/" rel="bookmark">
			Linux Redhat NFS挂载导致导致firefox启动不了的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个触发Linux下firefox启动不了的问题
经检查所有的系统设置都正常，与Firefox或者Java无关。最后发现是其中一个NFS挂载的硬盘掉线了，造成firefox进程处于悬停状态。
解决NFS挂载的方法很多，可以直接启动挂载不了的机器，或者采用umount指令卸载出问题的mount point, 或者直接修改/etc/mtab文件。
所以，解决NFS挂载的问题就自然解决了触发firefox启动不了的问题。特此留印。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191a4eba16cb3b52ff28bbe7c978eb02/" rel="bookmark">
			【解决方案】No input file specified. Apache解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 需求背景原伪静态规则调整后的伪静态规则调整代码调整后显示内容 需求背景 新部署的项目，提示出现“No input file specified.” 如下图所示：
原伪静态规则 &lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L] &lt;/IfModule&gt; 调整后的伪静态规则 调整代码 &lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php?/$1 [QSA,PT,L] &lt;/IfModule&gt; 调整后显示内容 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a51944d8de6be6780856525ff9535641/" rel="bookmark">
			OpenCV中的图像处理 —— 傅里叶变换&#43;模板匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV中的图像处理 —— 傅里叶变换+模板匹配 现在也在逐渐深入啦，希望跟大家一起进步越来越强
目录 OpenCV中的图像处理 —— 傅里叶变换+模板匹配1. 傅里叶变换1.1 Numpy实现傅里叶变换1.2 OpenCV实现傅里叶变换1.3 DFT的性能优化 2. 模板匹配2.1 单对象的模板匹配2.2 多对象的模板匹配 1. 傅里叶变换 关于傅里叶变换最重要的两个概念：时域与频域。以时间作为参照来观察动态世界的方法我们称其为时域分析，而频域是什么呢，它是描述信号在频率方面特性时用到的一种坐标系，频域图显示了在一个频率范围内每个给定频带内的信号量。贯穿时域与频域的方法之一就是大名鼎鼎的傅里叶分析，它可以分为傅里叶级数和傅里叶变换，傅里叶变换也就是我们这一部分要说的东西
傅里叶变换是分析线性系统的一个有力工具。 它告诉我们任何周期函数，都可以看作是不同振幅，不同相位正弦波的叠加。从数学意义上说，傅里叶变换将一个任意的周期函数分解成为无穷个正弦函数的和的形式；从物理效果上看，傅里叶变换实现了将信号从空间域到频率域的转换
在计算机视觉中傅立叶变换用于分析各种滤波器的频率特性，对于图像，使用2D离散傅里叶变换(DFT)查找频域（还有一种称为快速傅立叶变换(FFT)的快速算法）这一段文字是不是不太好理解，因为里面涉及太多比较深奥的东西了，傅里叶变换本身是比较难的一个点，在这里我就不细说了，我们只说说在计算机视觉领域我们是怎么用它的，想要深入了解的同学来看看这篇文章：深入浅出的讲解傅里叶变换（真正的通俗易懂）
对于正弦信号，如果幅度在短时间内变化比较快，则可以说它是高频信号，如果变化缓慢，则为低频信号，我们可以将相同的想法扩展到图像，图像中的振幅在哪里急剧变化？当然是在边缘点或噪声，因此，可以说边缘和噪声是图像中的高频内容
1.1 Numpy实现傅里叶变换 Numpy提供了FFT软件包来查找傅里叶变换，np.fft.fft2()为我们提供了频率转换，它将是一个复杂的数组，它的第一个参数是输入图像（灰度图像），第二个参数是可选的，它决定输出数组的大小。如果它大于输入图像的大小，则在计算FFT之前用零填充输入图像。如果小于输入图像，将裁切输入图像。如果未传递任何参数，则输出数组的大小将与输入的大小相同，但是现在获得的结果它的零频率分量（DC分量）将位于左上角，为了便于分析我们要把它居中，居中处理关系到np.fft.fftshift()函数
import cv2 as cv import numpy as np from matplotlib import pyplot as plt img = cv.imread(r'E:\image\test16.png', 0) f = np.fft.fft2(img) fshift = np.fft.fftshift(f) magnitude_spectrum = 20 * np.log(np.abs(fshift)) plt.subplot(121), plt.imshow(img, cmap='gray') plt.title('Input Image'), plt.xticks([]), plt.yticks([]) plt.subplot(122), plt.imshow(magnitude_spectrum, cmap='gray') plt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([]) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a51944d8de6be6780856525ff9535641/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30ae95ee6428ac9026b01cfd6444db2e/" rel="bookmark">
			C&#43;&#43;编译知识笔记（二）——Linux ELF文件解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、ELF格式概述二、常见段及对应用途三、目标文件内容解析3.1 代码段.text3.2 只读数据段.rodata3.3 数据段.data3.4 .bss段3.5 重定位表（Reloacation Table）相关段.rela.xxx3.6 字符串表.strtab和.shstrtab3.7 符号表.symtab 编译器编译源代码后生成的文件叫做目标文件，也就是.o文件，里面包含了可执行的机器码和数据等，这里我们就以Linux平台为例来详细分析下目标文件里面存放的内容。目标文件从结构上讲，和可执行文件基本是一样的，主要区别仅仅是没有经过链接，从而可能有些符号或者地址还没有被调整，但整体是差不多的。这篇文章会以一个目标文件为实例来详细聊一下Linux下的目标文件里究竟有什么，以及它和可执行文件所用到的格式ELF（Executable Linkable Format）。 一、ELF格式概述 Linux下面的可执行文件格式是ELF，是COFF（Common Object File Format，早期的类UNIX系统使用）格式的变种，虽然名字就是可执行文件格式，但不光是可执行文件是这个格式，目标文件也是按这种文件类型来保存的，不光如此，Linux下面一共有四类文件是按照ELF的格式来保存的，如下：
ELF文件类型说明示例可重定位文件（Relocatable）这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库可可以归为这一类Linux的.o目标文件可执行文件（Excutable File）这类文件包含了可直接执行的程序，比如ELF可执行文件，Linux下一般都没有扩展名/bin/bash文件共享目标文件（Shared Object File）.so文件，这类文件包含了代码和数据，链接器可以使用这种文件跟其他的目标文件和共享目标文件链接，产生新的目标文件。动态链接器则可以将这种共享文件目标文件与可执行文件结合，作为进程映像的一部分来运行/lib/glibc-2.5.so核心转储文件（Core Dump File）当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件core dump文件 对于一个熟练的linux平台的c/c++开发人员，这些文件类型应该都不陌生。另外，前面提到过，.a的静态链接库可以理解为.o的打包，因此本质上也属于ELF类型。
先不考虑具体的格式，我们已经知道目标文件里保存了我们执行程序所需要的内容，那么显然里面应该有执行所需要的指令和数据，这是最基本的，除此之外，还有链接时所需要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性和类型，以“段”（section或segment）的形式存储，比如代码段、数据段等。
下图用一个简单的示例直观的表示了程序编译后的ELF目标文件格式（省略了一些段）：
首先会是一个文件头，它描述了这个ELF文件的属性，包括是否是可执行文件、大端还是小端、文件适应的目标硬件架构等。文件头内容如下：
文件头中还有一个段表，包含了各个段的信息，段表如下：
可以看到一共有13各个段，而后面要用到的ojbdump -h命令则会省略一些不关键的辅助性质的段。
文件头后面就是各个段的具体内容。.开头的段都是系统保留段，应用程序也可以使用一些非保留名字来创建自定义段。图里的.text是代码段，保存了编译后的机器码，.data是数据段，保存已经初始化的全局静态变量和局部静态变量，而.bss段则是保存未初始化的全局变量和局部静态变量，这个比较令人困惑的bss的名字主要是因为历史原因。多提一句，这里说的静态变量指的是声明周期是整个程序的变量，在c/c++程序里，所有的全局变量和static 修饰的局部变量属于这一类型，至于全局变量是否由static关键字修饰影响的只是这个全局变量的可见性，加了static的全局变量只在这个编译单元可见，各个编译单元可以有同名的static全局变量。不要把静态变量和static关键字搞混了。
二、常见段及对应用途 除了上面提到的数据代码bss段等，这里贴一下《程序员的自我修养》一书中的一个ELF文件常见段和对应用途总结表：
段名内容.text存放编译生成的机器码.rodata存放只读数据，一般是程序中的只读静态变量和字符串常量.data保存已经初始化的全局静态变量和局部静态变量.bss存储未初始化以及初始化为0的全局静态变量和局部静态变量.rodata1也是只读数据段，存放字符串常量，全局 const 变量，该段和 .rodata 类似。.comment存放编译器版本信息，比如 “GCC:GNU4.2.0”.debug调试信息.dynamic动态链接信息.hash符号哈希表.line调试时的行号表，即源代码行号与编译后指令的对应表.note额外的编译器信息，比如程序的公司名、发布版本号等.strtabString Table 字符串表，用于存储 ELF 文件中用到的各种字符串.symtabSymbol Table 符号表，从这里可以找到文件中的各个符号.shstrtab各个段的名称表，实际上是由各个段的名字组成的一个字符串数组.plt 和 .got动态链接的跳转表和全局入口表.init 和 .fini程序初始化和终结代码段 三、目标文件内容解析 下面以一个修改过的《程序员的自我修养》一书中的例子来实际看看目标文件的各个段的情况
int printf(const char* format , ...); int global_init_var = 1; int global_uninit_var; void func1(int i){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30ae95ee6428ac9026b01cfd6444db2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7996c6a270d12c2c936654ff3d2fcbb/" rel="bookmark">
			一文读懂串口及各种电平信号含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 背景 做嵌入式开发或硬件开发的同学，一定常听到 RS232、RS485、TTL 等概念，如果对这些概念不清楚，使用起来就会有问题，本文对这些概念的含义进行介绍（看下图有没有绕晕）
1 串口 首先要明确，串口、COM 口是指硬件接口形式，而 TTL、RS-232、RS-485 是指电平信号
1.1 UART 接口 通用异步收发器（UniversalAsynchronous Receiver/Transmitter），UART 是串口收发的逻辑电路，这部分可以独立成芯片，也可以作为模块嵌入到其他芯片里，单片机、SOC、PC 里都会有UART 模块。
UART有 4 个pin（VCC、GND、RX、TX），
UART作为异步串口通信协议的一种，工作原理是将传输数据的每个字符一位接一位地传输。其中各位的意义如下：
起始位：先发出一个逻辑”0”的信号，表示传输字符的开始。资料位：紧接着起始位之后。资料位的个数可以是4、5、6、7、8等，构成一个字符。通常采用ASCII码。从最低位开始传送，靠时钟定位。奇偶校验位：资料位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验资料传送的正确性。停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。 由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。空闲位：处于逻辑“1”状态，表示当前线路上没有资料传送。 1.2 COM 口 COM 口即串行通讯端口，简称串口，一般常见 D 型 9 针插头，这种接口的协议只有两种：RS-232 和 RS-485。不会是 TTL 电平的。一般只接出 RXD、TXD，外加 GND。
1.3 USB 口 通用串行总线，和串口完全是两个概念。虽然也是串行方式通信，但由于USB的通信时序和信号电平都和串口完全不同，因此和串口没有任何关系。USB是高速的通信接口，用于PC连接各种外设，U盘、键鼠、移动硬盘、当然也包括"USB转串口"的模块。（USB转串口模块，就是USB接口的UART模块）
2 TTL TTL电平：全双工（逻辑1：2.4V ~ 5V，逻辑0：0V ~ 0.5V）
连接方式
电平表示
3 RS232 是电子工业协会制定的异步传输标准接口，同时对应着电平标准和通信协议（时序），其电平标准：+3V ~ +15V对应0，-3V ~ -15V对应1。RS232的逻辑电平和TTL不一样但是协议一样。RS-232适合本地设备之间的通信，传输距离一般不超过20m。RS-232只允许一对一通信。
RS-232电平：全双工（逻辑1：-15V ~ -3V，逻辑0：+3V ~ +15V）
连线图
电平表示
4 RS485 RS485是一种串口接口标准，为了长距离传输采用差分方式传输，传输的是差分信号，抗干扰能力比RS232强很多。两线压差为-(2~6)V表示0，两线压差为+(2~6)V表示1。RS-485的传输距离为几十米到上千米。RS-485接口在总线上是允许连接多达128个收发器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7996c6a270d12c2c936654ff3d2fcbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d69a5cbd30d8a1a08e3435698c9f67/" rel="bookmark">
			win10显示未连接到网络，但是任然可以上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在电脑开机后发现右下角的显示如下图片样式。在网上找了很多办法。
这里也提供一种解决方案：
第一步 打开设置界面
选择“网络和internet”。
第二步 点击最下面的“网络重置”
第三步 点击“立即重置”
第四步 点击”是“选项
等待电脑提示，大概在5分钟后电脑会自动重启。
重启时开机时间会变长，不要惊慌，等待开机即可。
此时，电脑右下角重新出现了自带网线小电脑图标；
以上出现的问题已经完美解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d950f5d6f5cba295f74f4766ab4bb69f/" rel="bookmark">
			@ConfigurationProperties 提示错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在springCloud环境下来注入配置时，可以使用@Value和@ConfigurationProperties.
但使用@ConfigurationProperties需要在依赖中额外导入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;!--不传递依赖--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f8f50afe7c6117cee7498e4fb35d6d/" rel="bookmark">
			panda3d场景的主要状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景的状态包括位置、方向、缩放比例、物体朝向、颜色、可见性、透明度、相机等。
最常改变的是位置和方向。
panda3d的默认坐标系：X向右，Y向前，Z向上。
对象方向使用欧拉角度坐标；由航向（Heading|Yaw）、俯仰（Pitch）、滚动（Roll）构成。
这两句设置载入场景的位置和缩放比例；
self.environ.setScale(0.25, 0.25, 0.25)
self.environ.setPos(-8, 42, 0)
缩放比例可分别设置X、Y、Z方向的；
self.taskMgr.add(self.spinCameraTask, "SpinCameraTask")
这句应该是每帧改变相机的位置和方向；
spinCameraTask，这个是自己写的函数；python的语法看上去和C#和C++不同；
taskMgr，这个应是每帧调用的一个东西；
看一下手册；
Tasks are subroutines (functions) that you write that get called by Panda every frame or every specified amount of time. Event handlers are subroutines that you write that get called by Panda when certain special events occur. 任务是一个你自己写的子路由函数，被Panda每帧调用，或者指定的时间到达调用。......；
Together, these two mechanisms enable you to update your Panda world between rendering steps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4f8f50afe7c6117cee7498e4fb35d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858e7e7eb3044be12a2e63794d414d92/" rel="bookmark">
			torchvision中的数据集使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、datasets数据集的使用 torchvision中的datasets含有很多数据集，可以用来生成图片,视频数据集,和一些流行的模型类和预训练模型
1、CIFAR10数据集 先下载该数据集
import torchvision from torch.utils.tensorboard import SummaryWriter #root：数据所在位置 #train：True为训练集，False为测试集 #transform：对数据集的变动 #download：True为自动下载 train_set = torchvision.datasets.CIFAR10(root="./dataset", train=True, download=True) test_set = torchvision.datasets.CIFAR10(root="./dataset", train=False, download=True) 查看某个数据
import torchvision #root：数据所在位置 #train：True为训练集，False为测试集 #transform：对数据集的变动 #download：True为自动下载 train_set = torchvision.datasets.CIFAR10(root="./dataset", train=True, download=True) test_set = torchvision.datasets.CIFAR10(root="./dataset", train=False, download=True) print(test_set[0]) 结果：
Files already downloaded and verified Files already downloaded and verified (&lt;PIL.Image.Image image mode=RGB size=32x32 at 0x23686A83198&gt;, 3) 查看数据集中包含哪些数据
print(test_set.classes) 结果：
['airplane', 'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck'] 数据集中包含以上图片及对应的标签
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/858e7e7eb3044be12a2e63794d414d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da1bcbf6992860ee8df3c66e8159c26/" rel="bookmark">
			Focal and Global Knowledge Distillation——目标检测网络的知识蒸馏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Paper地址：https://arxiv.org/abs/2111.11837
GitHub链接：https://github.com/yzd-v/FGD
方法 FGKD（Focal and Global Knowledge Distillation）通过Focal distillation与Global distillation的结合，兼顾了Instance-level信息、Spatial/Channel Attention以及全局相关性信息。
首先定义前背景分离Mask、Attention等，然后基于Feature map计算Focal distillation（由Feature loss与Attention loss构成），具体如下：
引入Binary mask分离前背景，其中r表示gt-box区域： 设置Scale mask以平衡前背景Loss，其中Hr与Wr表示gt-box的高与宽： 通过Reduced mean计算获得Spatial attention与Channel attention，并进一步通过Softmax计算获得Attention mask： 然后Feature loss计算如下（基于Teacher与Student的特征输出，通常是Neck特征）： 然后计算Attention loss，并最终确定Focal distillation loss，其中l表示L1 loss： def get_fea_loss(self, preds_S, preds_T, Mask_fg, Mask_bg, C_s, C_t, S_s, S_t): loss_mse = nn.MSELoss(reduction='sum') Mask_fg = Mask_fg.unsqueeze(dim=1) Mask_bg = Mask_bg.unsqueeze(dim=1) C_t = C_t.unsqueeze(dim=-1) C_t = C_t.unsqueeze(dim=-1) S_t = S_t.unsqueeze(dim=1) fea_t= torch.mul(preds_T, torch.sqrt(S_t)) fea_t = torch.mul(fea_t, torch.sqrt(C_t)) fg_fea_t = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5da1bcbf6992860ee8df3c66e8159c26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34cf693509b2c86fb338664034b64670/" rel="bookmark">
			将网页，网站（HTML，php，css）上传浏览器,实现输入网址即可访问（保姆级教学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将网页，网站（HTML，php，css）上传浏览器,实现输入网址即可访问（保姆级教学） 提示：以下仅为本人使用方法，仅供参考
前言 作为一个大学生，在学习完静态网页（HTML，php）的制作后，想要将网页上传到网上，实现输入网址即可访问,（让所有上网的人都能看见）
在搜寻了众多方案后，决定使用三丰云这个第三方平台来搭建属于自己的网站和网页，当然网上也有选择其他第三方平台来实现的比如：百度云服务器，腾讯云服务器
有个坑后面会讲
提示：这里不是打广告，只是分享一个我认为比较简单的方法，我也会说明他的缺点和不足，还请审核大发慈悲，感谢！只做单纯的分享
链接: https://www.sanfengyun.com.
下面是我的操作方法
提示：以下是本篇文章正文内容，下面案例可供参考
一、使用步骤 1：浏览器打开网址链接: https://www.sanfengyun.com. 打开后如下
2：右上角登录（没有账号需要先注册一个） 登录成功后需要在——&gt; “账户” ——&gt; “控制台首页” ：绑定自己的手机号码，实名认证（其他信息可自行选择填写）这两个是 必须 填写的，方便以后正常使用
3：然后本页面滑到底部 出现，其中虚拟主机和云服务器是免费的，域名是要花钱的（如果是在三丰云上买的域名，就可享受免备案服务，后面会讲到）
4：我们选择第①个—&gt;免费的虚拟主机，点击进入 5：在这里需要绑定微信才可使用 绑定成功后
6：然后返回，重新进入，就会出现（点击管理面板）值得一提的是：首次申请后只有30天，我们可以选择免费延期，不过只有还剩15天的时候才可以提交申请，为什么说免费还要弄这一出呢？用官方的话回答就是：保留活跃用户（还有就是延期需要你给他做做宣传，就是写一篇文章发表，不想延期的可以不弄） 7：进入管理面板后 ①是你的临时网址
②是你的主机信息
提示：下面一步必不可少
在这里需要设置②中的设置密码等下会用到
8：点击①，进入网址需要FTP密码(就是刚刚设置的)、 进入后
因为这个时候还没有把网页上传上去，所以需要先上传，点击ftp下载 9：在这里可以看网站给的指示文档，我也会再演示一遍、 点击链接下载，下载完成后打开文件夹
可能需要下面这一步
打开文件夹
运行flashfxp.exe这个程序
进入后在 左上角------&gt;“会话”-------&gt;“快速链接”
分别对应输入连接
打开右边的web文件夹，删除里面自带的，然后把自己的网页放进去即可
找到自己的存放文件的文件夹
可以直接全选拖动过去
等它右下角进度条跑完
然后等待1-2分钟（同步到服务器需要一点时间）
（或者换一个浏览器，因为浏览器有“记忆”）
再点击这个网址（这是系统给你可供调试的域名）
进入后输入密码
就可以看见了
截止到目前算是完成了一大半，接下来就是拥有一个属于自己的域名 10：注册域名，并绑定 点击域名绑定
因为我们没有所以先要注册一个（如果您有，并已经解析过，可以在这里直接绑定）
输入自己想要的域名，看是否被人注册，没有的话，我们可以直接购买
购买成功后
在“我的域名”里面可以查看
1实名审核（需要一段时间）还有就是域名备案，可以后面自行探索，网站指导文档里面也有方案，这里可以先不弄
2然后就是需要解析域名才可以正常使用
3在----&gt;“产品”----&gt;“免备案服务”----&gt;“别名地址”，将它复制下来
回到域名这里
点击管理
1点击“新纪录”
2解析类型选择“CNAME”
3输入刚刚复制的别名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34cf693509b2c86fb338664034b64670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb28cddd78527c51ddbba6509c4327f4/" rel="bookmark">
			使用QTreeWidget 模仿Qt Designer属性编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 QTreeWidget类提供了一个使用预定义树模型的视图，提供了一个标准的树小部件，带有一个经典的基于item的接口。这个类基于Qt的模型/视图体系结构，使用默认模型来保存项目，每个项目都是一个QTreeWidgetItem, 使得将数据的存储与其表示分离开来。
运行效果 模仿qt ui设计属性界面
常用Api 设置表头，为每一列设置标签。
void setHeaderLabels(const QStringList &amp;labels) 单列可用下面的函数
void setHeaderLabel(const QString &amp;label) 隐藏表头
void setHeaderHidden(bool hide) 展开所有项
void expandAll() 小部件内单击时，就会发出这个信号。
void itemClicked(QTreeWidgetItem *item, int column); 当指定项中的列的内容发生更改时，发出此信号。
void itemChanged(QTreeWidgetItem *item, int column); 追加顶级项
void addTopLevelItem(QTreeWidgetItem *item); 附加子项
void addChild(QTreeWidgetItem *child); 设置控件显示在给定项和列指定的单元格中
void setItemWidget(QTreeWidgetItem *item, int column, QWidget *widget); 删除给定列和给定项中的控件。
inline void removeItemWidget(QTreeWidgetItem *item, int column); 核心代码 QStringList strList; strList&lt;&lt;QStringLiteral("属性")&lt;&lt;QStringLiteral("值"); ui-&gt;treeWidget-&gt;setHeaderLabels(strList); ui-&gt;treeWidget-&gt;setAlternatingRowColors(true); ui-&gt;treeWidget-&gt;expandAll(); QTreeWidgetItem *item1 = new QTreeWidgetItem(QStringList()&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb28cddd78527c51ddbba6509c4327f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09af83b75f7072ccbe77e3bd453f77f/" rel="bookmark">
			labelImg使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Anaconda环境 安装 Anaconda 之后，在开始菜单下找到 Anaconda 文件夹
找到 Anaconda Prompt 点击运行
安装 labelImg pip install labelImg #直接命令行输入 启动 labelImg labelImg #直接命令行输入名称即可 labelImg界面 注意：change save dir： 如果指定好图片路径后发现没有之前的标签，说明xml的路径指定错了，需要重新指定路径 注意：（因为使用cv2.imread读取图像，路径中不能有中文）
特别注意： 路径有中文也会导致图片和xml文件匹配不上，labelimg上不显示框
开始标注 快捷键：W（创建方框），A（上一张），D（下一张）
XML文件示例
&lt;annotation&gt; &lt;folder&gt;夜读&lt;/folder&gt; &lt;filename&gt;6b6e567cgy1fpsj8k953nj20rs0roq5w.jpg&lt;/filename&gt; &lt;path&gt;C:\Users\Chengguo\Pictures\夜读\6b6e567cgy1fpsj8k953nj20rs0roq5w.jpg&lt;/path&gt; &lt;source&gt; &lt;database&gt;Unknown&lt;/database&gt; &lt;/source&gt; &lt;size&gt; &lt;width&gt;690&lt;/width&gt; &lt;height&gt;687&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;segmented&gt;0&lt;/segmented&gt; &lt;object&gt; &lt;name&gt;person&lt;/name&gt; &lt;pose&gt;Unspecified&lt;/pose&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;bndbox&gt; &lt;xmin&gt;371&lt;/xmin&gt; &lt;ymin&gt;259&lt;/ymin&gt; &lt;xmax&gt;637&lt;/xmax&gt; &lt;ymax&gt;522&lt;/ymax&gt; &lt;/bndbox&gt; &lt;/object&gt; &lt;/annotation&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ac92ee138f4b5a433d7b26904d67aa/" rel="bookmark">
			mac终端神器：iterm2配色---oh-my-zsh&#43;Powerlevel10k
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看最终效果
首先在官网下载item2
iTerm2 - macOS Terminal Replacement
因为国内基本无法使用github，所以我们选择gitee克隆下载oh-my-zsh
终端命令
git clone https://gitee.com/dongzhe3917875/oh-my-zsh.git cd oh-my-zsh/tools sh install.sh 下载完成之后查看我们的默认shell
echo $SHELL 我这里是修改为了zsh
/bin/zsh 如果你的默认shell是bash的话，需要执行命令：将默认shell改为zsh
chsh -s /bin/zsh 接下来我们需要下载所用字体，由于也需要用github，我并没有找到相关链接，故将其上传。
source-code字体-MacOS文档类资源-CSDN下载
网络允许的小伙伴可以在官网下载：https://github.com/adobe-fonts/source-code-pro
下载完后解压并全部添加到字体库，然后再iterm2中设置 最后便是下载我们需要的主题Powerlevel10k
我们依然选择gitee镜像安装
git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 安装完成后打开配置文件.zshrc，找到ZSH_THEME="robbyrussell"，我们将zsh的主题切换为Powerlevel10k
open ~/.zshrc ZSH_THEME="powerlevel10k/powerlevel10k" 接下来重启终端，按照步骤喜好一一设置即可，如果过程中配置错误，可选择终端输入
p10k configure 重新配置
ls配色设置：直接在.zshrc配置文件中添加如下代码即可：
#enables colorin the terminal bash shell export export CLICOLOR=1 #setsup thecolor scheme for list export export LSCOLORS=gxfxcxdxbxegedabagacad #sets up theprompt color (currently a green similar to linux terminal) export PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]\$ ' #enables colorfor iTerm export TERM=xterm-256color 最后我们可以对终端稍加修饰，加上语法高亮，这样错误命令会显示为红色，显而易见。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0ac92ee138f4b5a433d7b26904d67aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e4587947f98f3660325b06a57eab51/" rel="bookmark">
			IPMI20：ipmi——cmd4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		站位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d16c65d4ccb88b678d33f86d8b6a0fb/" rel="bookmark">
			IPMI18：ipmi——cmd2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		站位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6727f15579cea2105e4b482aaf63492c/" rel="bookmark">
			IPMI17：ipmi cmd1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		站位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408de67f1a364d7ed1f74b3ab2b15053/" rel="bookmark">
			树莓派学习之旅01（下载镜像&#43;烧录&#43;启动&#43;SSH&#43;VNC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开始学习树莓派，4B的4G内存，有外接显示器，树莓派用TypeC供电，2.5A的。
下载镜像 去到树莓派官网，下载镜像+烧录 用Raspberry Pi Imager（官网提供，非常好用，而且有中文版）
选择了推荐的Raspberry Pi OS(32-bit)，other里还有64位的，下次可以试试。
启动+SSH+VNC 烧录成功后（需一张SD卡，这就不多说了，最好32G的，16G的也够），将SD卡插入树莓派，上电启动（自带外接显示器，有键盘鼠标），经过简单设置后（国家，城市，时区之类的），还有就是WIFI。
需要重点提一下WIFI，建议一定要能够上公网的WIFI，如果这个WIFI只是内部的，也许树莓派不会连（不是很确定，望有高手指点）。
之后就是开启SSH+VNC（默认是关闭的），简要的写一下如何开启，更多更详细的，网上教程很多，大家可以自行查查。
树莓派–命令行–sudo raspi-config–3 Interface Option–把里面所有的选项都enable（Camera，SSH，VNC，SPI，I2C，Serial Port，1-write，Remote GPIO）
网上有教程说还需把2 Display Options里的D1 Resolution不能选第一个，否则远程桌面会黑屏,一般选择与自己电脑清晰度一样的；但我下载的这个树莓派系统版本中没有D1 Resolution，只有D2，D3，D4，估计是会自适应吧。
设置完成后，重启树莓派。获取树莓派的IP地址后，就可以通过VNC连接了。
VNC用的是VNC Viewer 6.17.731
输入树莓派的用户名和密码后，连接成功，操作一切OK。
随后把树莓派自带的外接显示器拔了（电源线和HDMI线都拔过），之后VNC上操作就延时非常厉害，大约在3秒左右。
有人说是因为树莓派的闭源驱动，一定要接个显示器，不然就要靠软件去算图形界面。解决方法是：装个虚拟显示器（稍后研究一下试试）。
还尝试了用SSH去连接树莓派：
命令行：cmd–ssh 树莓派用户名@树莓派IP地址
图形界面putty：
开启树莓派的学习之旅……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e126b736d8e4ceae11b53af5f41887/" rel="bookmark">
			【游戏开发教程】BehaviorDesigner插件制作AI行为树（Unity | 保姆级教程 | 动态图演示 | Unity2021最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、插件下载1、AssetStore下载2、GitCode下载 三、官方教程1、在线文档2、离线文档 四、插件界面1、打开编辑器2、界面介绍 五、快速制作一棵行为树1、创建物体2、挂BehaviorTree脚本3、添加Task节点4、运行测试5、导出BehaviorTree6、手动引用BehaviorTree树资源6.1、设置External Behavior6.2、使用Behavior Tree Reference 7、动态加载行为树资源并设置External Behavior 六、复合节点：Composities1、Sequence：顺序节点1.1、节点介绍1.2、新发口诀1.3、案例1：通知开饭了1.4、案例2：吃几口饭吃一口菜 2、Parallel：并行节点2.1、节点介绍2.2、新发口诀2.3、案例：边跑步边听歌 3、Selector：选择节点3.1、节点介绍3.2、新发口诀3.3、案例：诈骗举报概率 4、Parallel Selector：并行选择节点4.1、节点介绍4.2、新发口诀4.3、案例：考研和找工作 5、Priority Selector：优先级选择节点5.1、节点介绍5.2、新发口诀5.3、案例：先吵架还是先道歉 6、Random Selector：随机选择节点6.1、节点介绍6.2、新发口诀6.3、案例：吃米饭、面条、饺子 7、Random Sequence：随机顺序节点7.1、节点介绍7.2、新发口诀7.3、案例：番茄炒蛋 8、Parallel Complete：并行竞争节点8.1、节点介绍8.2、新发口诀 9、Selector Evaluator：评估选择节点9.1、节点介绍9.2、新发口诀 七、中断1、Self中断：老妈喊你回家吃饭2、Lower Priority中断：睡觉时地震3、Both中断：两者都中断 八、Variables：行为树成员变量1、添加变量2、读取变量3、修改变量4、拓展变量类型5、代码读写变量 九、行为树事件1、Send Event节点1.1、Target Game Object参数1.2、Event Name参数1.3、Group参数1.4、Argument参数 2、Has Receive Event节点2.1、Event Name参数2.2、Stored Value参数 3、代码中注册和注销事件 十、拓展行为树节点1、继承2、案例：MoveTo3、官方Sample包 十一、完毕 一、前言 嗨，大家好，我是新发。之前用过Behavior Designer行为树插件，最近又需要用到，我发现网上的教程很多写得不够好，今天我就来写写Behavior Designer行为树的教程吧，希望可以帮到大家。
二、插件下载 1、AssetStore下载 插件可以在AssetStore下载到，
地址：https://assetstore.unity.com/packages/tools/visual-scripting/behavior-designer-behavior-trees-for-everyone-15277
目前最新的版本是1.7.2，
可以在官网查看每个版本的迭代内容：
https://opsive.com/news/category/release-notes/behavior-designer-release-notes/
2、GitCode下载 我放了1.7.1版本的到GitCode上，地址：https://gitcode.net/linxinfa/unitybehaviordesigner
下载下来后，放入你的工程即可，
其中我加了一个FixGUIStyle脚本，
因为在Unity专业版上，打开Behavior Designer编辑器是这个鬼样，
注：如果你使用的是个人版，则不会有这个问题
它的GUIStyle在Unity专业版本有问题，插件编辑器是个dll文件，我们无法修改编辑器源码，
然后我进行了反编译，找到了它的封装各种GUIStyle的类：BehaviorDesignerUtility，
通过反射，修改这个类的私有静态成员对象，代码如下：
using UnityEngine; using UnityEditor; using System.Reflection; using BehaviorDesigner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e126b736d8e4ceae11b53af5f41887/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d612e0fb3250f98bc820066e6a6a5a0b/" rel="bookmark">
			Java中有没有类似C#中的区域注释？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C#中的区域注释可以使用#region和#endregion，将代码折叠后，代码结构看起来很清晰，便于阅读，如下：
Console.WriteLine("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXX&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); #region 示例代码区域 Console.WriteLine("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXX&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); if (true) { Console.WriteLine("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXX&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); } else { Console.WriteLine("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXX&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); } #endregion Console.WriteLine("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXX&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); 其实Java中也是有类似的：
System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXX&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); //region 示例代码区域 System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXX&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); if (true) { System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXX&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); } else { System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXX&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); } //endregion System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXX&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/699146e08a2c9801649e5006d02077fd/" rel="bookmark">
			创建Vue项目把报错Error: command failed: yarn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ERROR Error: command failed: yarn bug现象 原因 新建Vue项目，在新建过程中，报错
解决方案 更改项目创建时的包管理器 步骤 进入到Windows环境中C:/users/administrator/用户名 点击记事本打开，把yarn改成’npm’ 保存，即可解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e4bd4a5a52de79cd8a729ecd7f486c/" rel="bookmark">
			连锁多门店收银系统源码之新增采购进货单功能逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		saas连锁多门店管理收银系统源码的进销存体系介绍02期之---新增采购进货单及采购单详情功能逻辑。
1，SaaS收银系统源码-新增采购单--采购须知
新增采购进货单适用于商户（总部）需要向外部供应商进行进货/补货的商品。新增时候会看到相对应的比较重要的采购进货须知，节省大量系统学习成本。
2，SaaS收银系统源码--新增采购单--填写基础进货信息
新增采购单分商户进货和门店进货两种类型，总部可以给自己的总仓进货（商户进货），也可以给各直营门店进货（门店进货）。加盟店需自己操作进货，加盟店也可以向总部申请要货。还可以填写对应的单据备注说明，方便数据追踪。
3，SaaS收银系统源码--新增采购单--添加进货商品
选择对应的进货仓库/门店，供应商，及进货类型后，可操作选择本次进货的商品。进货商品弹窗中，可通过筛选商品分类及模糊搜索来选择商品，同时可以看见商品的库存单位/条码/可售库存/及本次勾选择商品的数量。
4，SaaS收银系统源码--新增采购单--录入进货数据
添加进货商品后可根据进货单位录入本次进货数量/进货单价/生产日期/进货备注等。
其中，有个非常重要的功能：根据“进货单位”选择进货数量。这就需要“商品多单位”功能的支持。
比如烟酒类商品，进货按“条”或“箱”进货，但是售卖上按照“瓶”或“盒”售卖。那么进货的时候就得有相应的进货类型。本收银系统源码这个功能体验做的很棒。
虽说很多竞品友商也有多单位的功能，但是实际使用起来，体验差的一塌糊涂。需用户自行判断。
5，SaaS收银系统源码--新增采购单--操作采购入库/采购单作废
5.1，采购进货单提交成功，单据详情中的状态会显示为“未入库”状态。还需要操作“入库”的工作。只有入库成功的商品，库存才能正式使用。否则都属于“在途库存”。
5.2，针对填写错误，或取消的单据，可操作“作废”采购单，操作“作废”后，得到确认，整个单据作废成功。
注意：采购进货单作废后，和其相关联的“关联付款单”也会一并作废。
6，SaaS收银系统源码--新增采购单--采购单详情
一笔采购进货单成功入库成功后，可点击单据详情查看。详情中会注明笔采购进货单的状态 以及进货入库和实际入库数量/进货金额/本次进货种数。可操作导出单据或打印单据。
7，SaaS收银系统源码--新增采购单--重要功能点综述
7.1，必须可根据商品的多种单位进货；
7.2，必须清晰显示单据的各种实时状态；
7.3，总部可给自己进货，也可帮助特别的门店操作进货；
7.4，有问题的单据必须可作废，作废后必须要关联到采购付款单
7.5，成功的单据必须可导出/可打印/可追踪。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11dd149cf293ad7fa190e4a2ae9093d/" rel="bookmark">
			【功能上新】Python实现OSM地图数据解析——OSM2Rail
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一款开源的铁路网络建模工具
目录 1. 简介2. 功能介绍3. 操作流程3.1 安装3.2 快速上手 4. 未来计划 1. 简介 作为一款面向铁路工作者的开源网络建模工具，OSM2Rail实现了在线OSM地图包快速下载、铁路元素自动解析、网络快速可视化以及规范化数据输出。借助OSM2Rail，你可以快速构建以下车站、站场、线路、网络的地理网络。
（1）北京南站
（2）襄阳北
（3）伦敦城区网
为了进一步简化铁路网建模工作，快速提取特定名称的铁路元素集合，在新版本0.0.6中对包进行了一定功能完善，可实现特定线路的提取。
2. 功能介绍 0.0.6版本的OSM2Rail功能如下：
支持在线下载.osm或.osm.pbf格式的OSM地图数据包支持解析.osm或.osm.pbf格式的OSM地图数据包支持提取特定名称的铁路元素以GMNS数据格式导出CSV文件导出文件可被QGIS读取 3. 操作流程 3.1 安装 PyPI地址：
https://pypi.org/project/osm2rail/
新版本需要以下三方包支持：
bs4osmiumshapelymatplotlibfuzzywuzzypandasnumpyrequests 配置好以上环境后，可输入以下命令快速安装包，
pip install osm2rail 3.2 快速上手 （1）在线下载地图包
支持通过名称或坐标框两种格式在线下载地图包
subarea_names = '徐州东' download_dir= './osmfile' osmfile=orl.download_osm_data_from_overpass(subarea_names='徐州东',download_dir=output_dir,ret_download_path=True) subarea_names：区域名称，可以是 str 或 包含多个str 的list
download_dir：下载到本地的路径
bboxs：区域的坐标范围，格式为：tuple(min_lat, max_lat,min_lon, max_lon)
ret_download_path：是否返回文件路径
（2）解析地图包并格式化
net = orl.get_network_from_file(filename=osmfile[0],POIs=True,check_boundary=True) orl.show_network(net) filename：文件路径
bbox：解析的目标范围，格式为：tuble(min_lat, max_lat,min_lon, max_lon)
check_boundary：bool，是否剔除不再范围内的元素
target_elements：需要解析的特定元素名称，格式为str或包含多个str 的list
POIs：bool，是否解析POI元素
可视化结果如下：
接下来我们尝试使用特定铁路元素解析功能：
首先需要自己准备好一个包含目标区域的地图包，比如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f11dd149cf293ad7fa190e4a2ae9093d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4109525b7e013d0aa0da985dfe69b0b/" rel="bookmark">
			Python爬虫踩坑：UnicodeEncodeError: ‘gbk‘ codec can‘t encode character 全网最有效解的决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述 我在网上看到了一本喜欢的小说，希望用爬虫把正本小说下载下来。
于是写下了这样一段代码： from urllib import request headers = { "User-Agent": "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; ." "NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; InfoPath.3)"} url_menu = "https://www.biqu100.com/3_3075/" req = request.Request(url=url_menu, headers=headers) res = request.urlopen(req, timeout=5) html = res.read().decode("utf-8") print(html) 可是解释器报错：UnicodeEncodeError: ‘gbk’ codec can’t encode character …
2. 解决方法 按照网上找到的很多方法进行了尝试，结果均无效，但是作为笔记，在此还是做一下记录。对于第一次遇到这个问题的同学，建议从第一步开始仔细排查一遍；对于在网上找了很久解决方案的同学，可以直接跳到文章最后，查看最终办法。 2.1 步骤1 检查解码格式首先要确定从网上爬下来的这一段二进制流应该用什么格式来解码。如果这是一串gbk格式的字节流，但我们用utf-8来解码，肯定无法解析。在网页上点击鼠标右键，点击“检查”，在html中的head里找到“meta charset”，这一项就是正确的解码格式。
如果在解码时已经指定了正确的格式，如： html = res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4109525b7e013d0aa0da985dfe69b0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259cd2199412aea7409c712b0fbd9c98/" rel="bookmark">
			OceanBase数据库的日志类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OceanBase数据库的日志类型 事务/存储日志clog observer日志日志级别日志格式日志切换与回收错误码 OceanBase的日志可以分为事务/存储日志和observer日志。
事务/存储日志 事务/存储日志存放在/data/log1/集群名/路径下，又可以分为以下三种类型：
clog：所有分区共用。日志可能是乱序的，记录了事务、PartitionService提供的原始日志内容。此目录下的日志基于paxos协议在多个副本之间同步；ilog：即 index log，所有分区共用。单个分区内部日志是有序的，记录了分区内部log_id &gt; clog(file_id, offset)的索引信息。每个副本自行记录；slog：即 storage log，指SSTable操作日志信息。 其中，clog 和 ilog 合起来被称为事务日志，slog 被称为存储日志。
clog 事务提交日志clog包含了以下内容：
redo log：记录了事务的具体操作；prepare log：记录了事物的准备状态；commit log：表示事务成功提交，记录了commit信息，比如事务的全局版本号；clear log：通知事务清理上下文；abort log：表示事务被回滚。 observer日志 Observer日志记录了OceanBase的启动和运行状态、告警信息，存放在/home/admin/oceanbase/log/路径下。
日志级别 按重要程度由大及小，Observer日志内容可以分为以下五种级别：
Error：严重错误，必须进行故障处理，否则系统不可用；Warn：警告，可能会出现的潜在错误；Info：提示，系统当前运行状态，为正常信息；Trace：与Debug相比，更细致化的事件记录信息；Debug：调试信息，用于调试时了解系统运行状态。 日志格式 Observer日志内容格式如下：
[time]log_level[module_name]function_name(filename:file_no)[thread_id] [Ytrace_id0_trace_id1][log=last_log_print_time]log_data #time 日志记录时间 #log_level 日志级别 #module_name 模块名 #filename:file_no 文件名:行号 #thread_id 线程id 日志切换与回收 在/home/admin/oceanbase/log/路径下，包含以下文件：
选举模块日志：文件名为election.log、election.log.wf；rootservice模块日志：文件名为rootservice.log、rootservice.log.wf；observer日志：文件名为observer.log、observer.log.wf，记录了除选举模块日志和rootservice模块日志以外的信息。 其中，以.wf结尾的日志文件单独记录了Warn和Error级别的日志，由日志文件控制参数enable_syslog_wf控制，默认为True。
当单个日志写满256M时，会发生日志文件切换。OceanBase会在原有的的日志文件名中加上%Y%m%d%H%M%S格式的时间（日志切换时间），并生成一个新的observer日志。
OceanBase默认不会自动清理日志，但可以按照日志个数来回收日志。日志回收由下面两个控制参数控制：
enable_syslog_recycle：默认为False；max_syslog_file_count：默认为0。 错误码 MySQL租户下的错误码如果大于4000，则表示是OceanBase所特有的。如果错误码在4000以内，则是MySQL兼容的错误。
错误码在1到1000之间，表示是预留错误码；错误码在1000到2000之间，表示是MySQL Server错误码；错误码在2000到3000之间，表示是MySQL Client错误码。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4020cd3999e895f5a32ff7140e1d8a31/" rel="bookmark">
			python ddddocr实现验证码签到、登录、点击、按顺序点击，通过验证码识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上代码
import ddddocr import cv2 # ↓这行代码是本地库,可以不写,但需要引入其他库 from lib.init import * # 去掉上面的代码,改成引入os,time,pyautogui # 然后修改下面的代码 # 尝试通过不停的试验试出来 # pyautogui检测识图,不通过重新反复识别 # 然后继续识图,直到通过为止,再进行下一步 w(5) # 等待5秒 def yz(): screenshot('test.jpg',region=(721, 358, 460, 459)) # 在屏幕的721,358(左上)截图,长宽为460,459(到右下) # 截图的范围在721,358到1181,817 det = ddddocr.DdddOcr(det=True) with open("test.jpg", 'rb') as f: image = f.read() # 把截图的图片识别 poses = det.detection(image) print(poses) # 打印识别出来的位置 im = cv2.imread("test.jpg") for box in poses: x1, y1, x2, y2 = box im = cv2.rectangle(im, (x1, y1), (x2, y2), color=(0, 0, 255), thickness=2) click(x1+721+20, y1+358+20) # 读取test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4020cd3999e895f5a32ff7140e1d8a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a234644246901fb259e3aa3ada596ff0/" rel="bookmark">
			SkeyeVSS综合安防监控录像回放控制之自定义可拖动时间轴组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SkeyeVSS综合安防视频云服务通过接入SkeyeRMS录像服务器实现对系统里的摄像机等设备录像，通过自定义的时间轴组件对录像记录进行加载渲染,播放器回调时间与下面时间轴相互联动，集拖动、点击、缩放、无限加载等于一体的时间轴组件。
通过接口获取录像回放记录的列表，数据结构中包含每段录像的开始与结束时间，把每段记录绘制到时间轴上，左右拖动会自动触发日期的改变回调，再通过接口去获取对应日期的数据，方便我们整体查看，点击有录像的时间段区域或拖动指针（三角形）返回当前时间戳，再配合拉流进行播放，通过滚轮缩放最小精确到秒，最终效果如图所示：
时间轴组件基本功能 时间轴初始化代码及录像时间段的数据格式，如下： &lt;div class="timeline-group" id="timeline"&gt;&lt;/div&gt; let times = [ { begin: new Date(new Date('2022-04-14 11:30:00')).getTime(), end: new Date(new Date('2022-04-14 17:00:00')).getTime() }, { begin: new Date(new Date('2022-04-14 17:01:00')).getTime(), end: new Date(new Date('2022-04-14 19:00:00')).getTime() } ] let TimeAxis = new TimeLine({ dom: document.getElementById('timeline'), bg: '#000', date: new Date(new Date('2022-04-14').toLocaleDateString()).getTime(), cellStyle: { background: 'rgba(24,208,217,0.5)' }, timecell: [...times], callback: (data) =&gt; { // {mode: 触发方式 timestamp: 时间戳 valid: 是否有效} console.log(data) this.$emit('changeTime', data) } }) 1、时间轴组件是使用canvas技术绘制，组件的宽高是自动根据外层div的宽高来自适应，通过设置外层div的宽高来控制即可。 创建canvas注册事件初始化边框渲染时间轴初始化刻度线渲染播放指针有效时间区域填充时间段 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a234644246901fb259e3aa3ada596ff0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a1de01a5218187b3b5e666791e26835/" rel="bookmark">
			MCAN论文进阶——MoVie: Revisting Modulated Convolutions for Visual Counting and Beyond 论文笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MCAN论文进阶——MoVie: Revisting Modulated Convolutions for Visual Counting and Beyond 论文笔记 一、Abstract二、引言三、相关工作3.1 显式计数/推理模块3.2 隐式推理3.3 空间计数3.4 通用视觉计数 四、带调制的计数4.1 调制卷积4.1.1 动机4.1.2 管道和模块4.1.3 瓶颈结构4.1.4 调制方式4.1.5 尺度鲁棒性4.1.6 序列表示 4.2 MoVie 作为一个计数模块 五、实验5.1 视觉计数5.1.1 开放性的计数 benchmarks5.1.1.1 调制模块的设计5.1.1.2 瓶颈结构的数量5.1.1.3 尺度鲁棒性 5.1.2 开放性计数结果5.1.3 可视化分析5.1.3 通用目标计数 5.2 视觉问答5.3 超出计数范围外的任务 六、结论A 补充细节1、问题表示2、基于目标检测的计数 B RMSE 变体的定义C 在 VOC 数据集上的通用目标计数D 对于 VQA 架构的计数模块E MoVie 模型究竟在哪些问题类型上其作用的可视化 写在前面 本文是 VQA 2021 Challenge 的冠军，方法上没有太复杂，主要是结合 Defense grid 的思路和 MCAN 的方法，再根据自己的 idea 做出一些创新，最终夺冠的模型采用了 32 个models 的 ensemble。 论文地址：MoVie: Revisting Modulated Convolutions for Visual Counting and Beyond代码链接：Github收录于：ICLR 2021更新一：2022.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a1de01a5218187b3b5e666791e26835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c817ed8420ddfe35a00af49d31b3515/" rel="bookmark">
			C语言实现栅栏式加密算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据栅栏式加密的一般方法，写下如下代码，算是暴力解决加密及解密的算法（无指针，设有循环可持续加密/解密）：
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #define N 60 void test(); void key(); int main (){ int t=1; while(t){ printf("请选择加密/解密/退出（1/2/0）"); scanf("%d",&amp;t); getchar(); if(t==1){ test(); } else if(t==2){ key(); } else if(t==0){ } else{ printf("输入有误，请重新选择"); } } return 0; } void test(){ int i,k,j,d,p,z; char word[N],a[5][30]; printf("请输入明文："); gets(word); p=strlen(word); printf("请选择加密深度："); scanf("%d",&amp;d); getchar(); for(i=0;i&lt;p;i++){//写入二维数组 k=i%d;//k a[k][] j=i/d;//i a[][i] a[k][j]=word[i]; } k=0; z=p%d; if(z==0){ z=-1;} for(i=0;i&lt;z;i++){ for(j=0;j&lt;=(p/d);j++){ word[k]=a[i][j]; k++; } } if(z&lt;d){ for(;i&lt;d;i++){ for(j=0;j&lt;(p/d);j++){ word[k]=a[i][j]; k++; } } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c817ed8420ddfe35a00af49d31b3515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/023fa135950493e00b0d8087e62bf10a/" rel="bookmark">
			C语言实现维吉尼亚（Vigenere）加密算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说直接上代码（无指针，设有循环可循环加密解密）：
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #define m 100 #define n 20 void test(); int main() { int s=1; while(s){ int q,w=0; printf("请选择加密/解密/退出（1/2/0）"); scanf("%d",&amp;q);//选择需要的服务 getchar(); if(q==1){ test(w); } else if(q==2){ w=1; test(w); } else if(q==0){ s=0; } else{ printf("输入错误请重新输入"); } } return 0; } void test(int w){//w是对加密还是解密的设置 char key[n], wordline[m]; int a[n]; int index = 0,i,p,k; printf("请输入明文:"); gets(wordline); printf("输入密钥:"); gets(key); for(i=0;i&lt;strlen(key);i++){ if(key[i] &gt;= 'A' &amp;&amp; key[i] &lt;= 'Z') { if(w=0){ a[i] = (key[i]-'A')%26; } else{ a[i] = 26-(key[i]-'A')%26; } } else if(key[i] &gt;= 'a' &amp;&amp; key[i] &lt;= 'z') { if(w==0){ a[i] = (key[i]-'a')%26; } else{ a[i] = 26-(key[i]-'a')%26; } } } p=strlen(key); for(i=0; i&lt;strlen(wordline); i++) { k=i%p; if(wordline[i] &gt;= 'A' &amp;&amp; wordline[i] &lt;= 'Z') { wordline[i] = ((wordline[i]-'A')+a[k])%26+'A'; } else if(wordline[i] &gt;= 'a' &amp;&amp; wordline[i] &lt;= 'z') { wordline[i] = ((wordline[i]-'a')+a[k])%26+'a'; } } if(w==0){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/023fa135950493e00b0d8087e62bf10a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a7e11fba696cb68d97d94178880538/" rel="bookmark">
			FFmpeg之硬解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读 前面我们已经使用NDK编译出了FFmpeg并且已经集成到了Android Studio中去，相关文章：NDK21编译ffmpeg5.0.1
众所周知，软解码虽然兼容性一流，但是却非常依赖CPU，所以性能消耗笔记大；硬解码使用内置的DSP芯片进行解码，性能高，但是兼容性一般。
虽说硬解码兼容性不太好，但是在实际开发中出于对性能的考虑我们依然会采用能硬解则硬解，不能硬解则软解兜底的方案。
我们知道安卓上可以使用MediaCodec进行硬解码，新版本FFmpeg内部也支持了MediaCodec硬解码，今天我们就使用FFMpeg在安卓上使用MediaCodec进行硬解码。
笔者测试的FFmpeg版本是最新的5.0.1，不同版本之间可以会有差异。
编译支持硬解码的FFmpeg 要编译支持硬解码的FFmpeg，在进行交叉编译时我们只需要打开以下几个属性即可：
--enable-hwaccels \ --enable-jni \ --enable-mediacodec \ --enable-decoder=h264_mediacodec \ --enable-decoder=hevc_mediacodec \ --enable-decoder=mpeg4_mediacodec \ --enable-hwaccel=h264_mediacodec \ 使用FFMpeg进行硬解码 使用FFmpeg无论是硬解码还是软解码流程都是差不多的，对使用FFmpeg编解码API不熟悉的童鞋们可以回看之前发表的博客文章…
在FFmpeg源文件hwcontext.c中我们可以看出mediacodec对应的type类型是AV_HWDEVICE_TYPE_MEDIACODEC，这个AV_HWDEVICE_TYPE_MEDIACODEC很重要，
在配置硬解码器时都是需要使用到这个type。
static const char *const hw_type_names[] = { [AV_HWDEVICE_TYPE_CUDA] = "cuda", [AV_HWDEVICE_TYPE_DRM] = "drm", [AV_HWDEVICE_TYPE_DXVA2] = "dxva2", [AV_HWDEVICE_TYPE_D3D11VA] = "d3d11va", [AV_HWDEVICE_TYPE_OPENCL] = "opencl", [AV_HWDEVICE_TYPE_QSV] = "qsv", [AV_HWDEVICE_TYPE_VAAPI] = "vaapi", [AV_HWDEVICE_TYPE_VDPAU] = "vdpau", [AV_HWDEVICE_TYPE_VIDEOTOOLBOX] = "videotoolbox", [AV_HWDEVICE_TYPE_MEDIACODEC] = "mediacodec", [AV_HWDEVICE_TYPE_VULKAN] = "vulkan", }; 下面说说在FFMpeg配置硬解码器的大体步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71a7e11fba696cb68d97d94178880538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae958551e054bde47c6741d83d53c053/" rel="bookmark">
			成功解决CentOS7中yum能ping通外网，但是无法下载问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天安装完centos7后，使用yum安装redis时出现连接国外源超时情况，想通过yum update来解决问题，但是出现以下情况：
通过ping www.baidu.com，网络是通的。怀疑是CentOS-Base.repo文件出了问题。
通过命令将该文件备份：
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak 通过命令查看一下本地源情况：
yum repolist all 发现已经全部被禁用掉。通过更换源的命令，仍无法解决：
最后想到通过以下网址去下载相应版本的repo文件，然后上传到/etc/yum.repos.d/
网易镜像库 https://mirrors.163.com/.help/centos.html 阿里云镜像库 http://mirrors.aliyun.com/repo/ 运行以下命令生成缓存：
yum clean all yum makecache 再执行yum repolist all查看
成功设置国内源。执行安装redis依赖命令，成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/160ade4936ac43976b8aeaadf227414d/" rel="bookmark">
			数据库表插入中文数据时报错Incorrect string value: ‘\xE4\xBB\x8E\xE5\x85\xA5...‘ for column ‘name‘ at r
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于使用sqlyog创建数据库表插入中文数据时报错
Incorrect string value: ‘\xE4\xBB\x8E\xE5\x85\xA5…’ for column ‘name’ at r
这种情况就是在创建数据库的时候编码没有设置成utf-8
直接在创建表的时候加一句
CHARACTER SET utf8 ENGINE INNODB; 如图所示
谢谢这位作者！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34160d07e92162f068df6950f54e4410/" rel="bookmark">
			SpringBoot集成RabbitMQ---保证消息可靠性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot集成RabbitMQ—保证消息可靠性 在我们使用RabbitMQ消息队列时，使用生产者发送消息，可能出现发送失败，rabbitMQ宕机，一个消息重复发送等问题，一旦出现这种问题，如果不进行相应处理，就可能导致消息丢失，消费者重复消费一条信息等问题，消息就变得不可靠了，进而影响我们的业务逻辑。所以我们要对可能出现的问题进行相应的操作，来保证消息的可靠性。下面我们来介绍在生产端实现消息可靠性投递，消费端幂等性操作两种实现方式。
本篇文章是springboot集成RabbitMQ中保证消息可靠性的一种方案，还有其他的高可用方案（大家可以去网上study一下）
一、生产端消息可靠性投递 生产端消息可靠性传递是为了解决消息投递时丢失的问题，导致这种问题的原因不单一，比如rabbitMQ宕机，投递过程中交换机发生问题等。
生产端消息可靠性投递实现方案： 数据库中核心存储消息的唯一id，消息状态，重试次数，重试时间
如果生产者判定消息发送失败，则进行重试（重新发送），并设置重试时间（也就是超过这个时间才重新发送，这样可以尽量排除因系统延迟原因导致生产者判定消息发送失败），当然不能无限重试，要设定最大重试次数，如果超过最大重试次数，就判定为发送失败，不能重试
发送消息前，存储消息状态（投递中），然后生产者发送消息给MQ，若生产者监听到MQ的接收确认，则更改数据库中消息的状态为发送成功；若监听到MQ的接收拒绝，则更改数据库中的消息状态为发送失败（可以加上其他业务）。
开启一个定时任务，获取所有投递中，并且重试时间小于当前时间的消息集合。然后遍历这个消息集合，判断重试次数是否超过最大可重试次数，如果超过最大重试次数，就判定为发送失败，不能重试；如果不超过，消息的重试次数+1，修改时间为当前时间，重试时间为当前时间加上消息超时时间，重新发送消息；
step1:消息数据进行存储
step2:发送消息
step3:生产者监听到MQ的确认消息
step4:更改数据库中消息的状态
step5:定时任务（定时去获取数据库中消息状态为投递中状态，并且重试时间小于当前时间的消息）
step6:如果重试次数不超过3次，消息的重试次数+1，更新重试时间为当前时间+指定超时时间
step7:如果重试次数超过3次，更新状态为投递失败，不能重试
代码实现 为了不发生错乱 先写一下代码中会用到的参数
public class MailConstants { //消息投递中 public static final Integer DELIVERING = 0; //消息投递成功 public static final Integer SUCCESS = 1; //消息投递失败 public static final Integer FAILURE = 2; //最大重试次数 public static final Integer MAX_TRY_COUNT = 3; //消息超时时间 单位min public static final Integer MSG_TIMEOUT = 1; //队列 public static final String MAIL_QUEUE_NAME = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34160d07e92162f068df6950f54e4410/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2905623c592643611f7c3a31ae9307b7/" rel="bookmark">
			【RTSP流】使用flv.js &#43; websocket播放rtsp视频流（h264）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言
在项目开发过程中经常需要接视频流。之前大都接的是HLS格式的流，这是Html5的video标签直接支持的。最近需要接rtsp流，web端目前不支持直接播放。本文提供一种方法直接播放rtsp流，不需要安装插件。
2 基于flv.js的RTSP播放方案
HTML5 原生仅支持播放 mp4/webm 格式，是不支持 FLV格式的。 flash性能问题是长期以来被全世界人所诟病的，尤其是以后chrome将彻底抛弃flash，越来越多有直播需求的人产生焦虑。这就加速了html5播放器的发展，也使得人们对html5非插件式的播放器更加渴望。而flv.js就是这么一款可以利用html5的video标签将http-flv直播流实时播放的一个js版的播放器。
2.1 使用node构建服务器端
目录如下所示：
package.json
{ "name": "ffmpeg-server", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" }, "author": "", "license": "ISC", "devDependencies": { "express": "^4.17.1", "express-ws": "^4.0.0", "ffmpeg": "0.0.4", "fluent-ffmpeg": "^2.1.2", "http": "0.0.0", "websocket-stream": "^5.5.0" } } index2.js
var express = require("express"); var expressWebSocket = require("express-ws"); var ffmpeg = require("fluent-ffmpeg"); ffmpeg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2905623c592643611f7c3a31ae9307b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7859a242a5735573991a35530abc7aec/" rel="bookmark">
			linux docker 使用centos镜像创建容器，内部搭建宝塔面板过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宿主机指令，创建启动容器 docker run -itd --name bt-host \ -p 7080:80 \ -p 7022:22 \ -p 7021:21 \ -p 7443:443 \ -p 7888:8888 \ -p 7306:3306 \ -p 7379:6379 \ -p 7700-7720:7700-7720 \ --privileged centos:centos7.9.2009 /usr/sbin/init --privileged ：大约在0.6版，privileged被引入docker。
使用该参数，container内的root拥有真正的root权限。
否则，container内的root只是外部的一个普通用户权限。
privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。
甚至允许你在docker容器中启动docker容器。
进入容器执行初始化 #进入容器 -$ docker exec -it bt-host /bin/bash #安装基础指令 -$ yum -y install sudo -$ yum -y install initscripts #安装宝塔 -$ cd /home &amp;&amp; mkdir bt &amp;&amp; cd bt -$ yum install -y wget &amp;&amp; wget -O install.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7859a242a5735573991a35530abc7aec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c74ceab5418b43999dd1f033678cd8/" rel="bookmark">
			RS485通信模块使用及代码【简】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、485模块简介
485，通信接口的远程称重数据采集方法，在要求通信距离为几十米到上千米时，广泛采用 RS-485 串行总线标准。RS-485采用平衡发送和差分接收，因此具有抑制共模干扰的能力。
大致意思：
具有rs485硬件接口，并且采用协议进行数据传输的一种设备。
①从某宝的RS485截图
②作用：这个模块主要可用来进行MCU与MCU之间的通信，支持一个主机多个从机（串口通信一对一）， 并支持MODBUS通信协议。
2、连接方式
这里以STM32F103C8T6最小系统板为例，电源可以接3.3/5V。连接方式如下图。
实现两个单片机之间的通讯需要两个485模块，通常情况下RE与DE要连接在一起，具体解释请参考这位博主的文章，很详细。
(36条消息) RS485模块的介绍及引脚连线说明_6柒的博客-CSDN博客_485模块https://blog.csdn.net/weixin_44035986/article/details/116792884
连接实物方式如下，至于RE-DE共线可以用面包板（个人觉得好接一点）
​​​​​​​ 3、代码
①485初始化及发送数据代码
#define RS485_RX_EN PAout(12) void RS485_Init(void) { GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);//使能PA外设时钟 GPIO_InitStruct.GPIO_Pin = GPIO_Pin_12;	//初始化引脚 GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;	//输出模式 GPIO_InitStruct.GPIO_Speed = GPIO_Speed_2MHz;	//2MHZ GPIO_Init(GPIOA, &amp;GPIO_InitStruct);	//根据GPIO_InitStruct初始化 Usart3_Init(115200);	//串口3初始化 RS485_RX_EN = 0;//默认进入接收模式 } void RS485_SendData(unsigned char *str, unsigned short len) { RS485_RX_EN = 1;	//进入发送模式 while(len--)	{ while(USART_GetFlagStatus(USART3,USART_FLAG_TC) == RESET);//等待上一个字节发送完成 USART_SendData(USART3,*str++);	//发送一个字节 } while(USART_GetFlagStatus(USART3,USART_FLAG_TC) == RESET);//等待最后一个字节发送完成 RS485_RX_EN = 0;	//进入接收模式 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da492c727185f77ed2fd0694f34598a9/" rel="bookmark">
			分享一个离线安装torch环境的方法，效率gang gang的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在linux服务器下训练一个模型时，首要的是安装一个匹配的框架的环境，torch or tensorflow ，如果网速十分的飞快，那也没什么好说的，可是我敢说大部分的公司的网速完全是归途赛跑中的那只乌龟，虽然不断网，可就是跑不起来。这时我们要安装一个几个左右的gpu环境，那简直了，所以，这里给大家分享一个离线安装gpu环境的方法，亲测十分高效，这里只说torch环境哦，tensorflow本人不喜欢用。
首先上网址链接：
Index of /anaconda/cloud/pytorch/linux-64/ | 清华大学开源软件镜像站 | Tsinghua Open Source MirrorIndex of /anaconda/cloud/pytorch/linux-64/ | 清华大学开源软件镜像站，致力于为国内和校内用户提供高质量的开源软件镜像、Linux 镜像源服务，帮助用户更方便地获取开源软件。本镜像站由清华大学 TUNA 协会负责运行维护。https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud//pytorch/linux-64/
大家再熟悉不过。
服务器命令输入nvcc -V
查看我们的cuda的版本。release 11.1
然后从清华源中下载版本匹配的torch 和 torchvision
将这两个压缩包导入我们的服务器目录中，在我们创建的虚拟环境中，输入命令：
conda install pytorch-1.10.1-py3.7_cuda11.1_cudnn8.0.5_0.tar.bz2
安装torchvision也是这个命令
完毕，你会发现 so easy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de4260cd96a58ae886da6906228f6d1/" rel="bookmark">
			信号完整性分析学习--12--IBIS模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面说过信号完整性分析的三要素包括：信号、驱动接收器件和信号的传输通道。之前讲了信号的时域、频域特性，各种常见的电平标准其实就是驱动和接收芯片的基础知识。这一节我们将介绍有关IBS模型的知识，后面我们将会逐渐的接触信号完整性仿真分析的内容。
IBIS模型简介 IBIS（Input/Output Buffer Informational Specifation）是用来描述 IC 器件的输入、输出行为特性的文件。在IBIS模型里包含的核心内容就是在给定负载情况下得到的几条I/V和V/T曲线，有了这几条曲线就可以描述IO buffer的行为特性。需要我们注意的是，IBIS 模型并不提供 IC 器件的功能信息、逻辑信息、输入到输出的时间延迟等信息。也就是说，对于器件厂商而言 IBIS模型不会泄漏器件的内部逻辑电路的结构。
仿真的时候把相应的buffer添加到PCB板上电路的驱动端和接收端就可以进行 SI、串扰、EMC 以及时序的仿真分析。IBIS 模型可以通过实际的测量得出也可以通过器件的 SPICE模型转换得到。由于它是一个行为级模型不包括IC内部的电路信息，因此在仿真速度方面比相应的Spice 的晶体管级模型要快 10～15 倍左右。
通常IBIS 模型是基于器件的。因此，IBIS 模型中除了一些器件 Buffer 的V/I、V/T曲线，还包括 pin与buffer 的映射关系（除了电源、地和没有连接的管脚外，每个管脚都有一个特定的 Buffer），以及器件的封装参数。还包括一些电气说明如 Vinh、Vinl、Vmeas以及管脚的寄生参数（如管脚的引线 R、L、C）等。同时IBIS 有其特定的语法和书写格式，模型中各个字段、各种信息都需要按照其语法格式进行书写。
一般情况，IBIS 模型包含以下一些信息，IBIS 模型的结构如下图 所示。在图的右半部分的内容 “[…]”中的是 IBIS 模型中的关键词；没有方括号的条目则代表的是子参数的标题。同时对于红颜色的字符“Y”标明在 IBIS 模型中是必选项；而“N”则是标明该内容在 IBIS 模型中为任选项。
1.IBIS的头文件：关于文件本身和器件名字的信息。这些信息用以下的关键词描述： [IBIS Ver] IBIS的版本号, [File Name]文件的名称, [File Rev]文件的版本号, [Component]器件的名称和[Manufacturer]。器件的制造商。
2.器件和管脚信息：关于器件的封装电气特性和管脚与Buffer模型的映像关系。可以使用关键词 [Package]和[Pin]描述。
3.model的子参数：为了表述器件管脚的Buffer所需要的相关的数据信息。关键词 [Model] 是用来表示每个Buffer的数据，具体的内容有：Model_type(Buffer的类型)、Vinh、Vinl以及C_comp（IC芯片的电容）。
4、工作电压和温度：为衡量模型的温度特性以及在高低温情况下、不同工艺的极限情况，不同buffer对应不同温度、电压条件。
5、I/V数据：在前面的内容中提到了Buffer的特性描述，在IBIS模型中需要下面的一些关键词描述：[Pull-up]、[Pull-down]、[GND clamp]、[Power clamp]和 [Ramp]。当然对于不同的Buffer可能不需要上面的全部的关键词来描述。如OC和漏极开路电路就不需要[Pull-up]关键词的数据信息。
6、转换波形的数据：描述了IO buffer在特定负载情况下输出的波形的边沿变化率和上升、下降沿。
同时我们要清楚， 并不是所有的buffer都需要上述所有的I/V和V/T曲线进行描述。对于输入、输出和 I/O 管脚的 Buffer 的行为特性描述所需要的曲线是不同的。下面分别对于输入、输出和 I/O 管脚 Buffer 的表述形式作一个介绍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4de4260cd96a58ae886da6906228f6d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b8b1b3e9cb3eef9cb79f36505e20f11/" rel="bookmark">
			Android-开发面经，历时两月斩获BAT&#43;头条四个公司-Offer(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次求职中，比较高频的题目是"第 TopK 大的数"（快排思想、能提到线性查找算法 BFPAT 更佳） 和 “前 TopN 个数” （堆排序、先分治再堆排序）。
2.2 技术基础 就像面试前我们准备的，基础题基本是必问的，就算不深究 Android 的基础，问你一些计算机网络的东西不为过吧。这块我们必须拿出校招时的劲头来，老老实实复习。至于具体的题目什么的我就不罗列了，网上有一堆面经，github 上也有很多整理好的题库。
对 Android 开发来说，可以分成两块，第一块是 Android 相关基础。**跟初级开发的面试不同的是，这里的基础不会是简单的“四大组件是哪些”，而是会问你具体的使用和碰到的问题。**比如四大组件的考察会结合 ANR（四大组件是否都会产生 ANR、时间是多少等）、进程优先级、启动模式 等等一起问。网上的面经和题库命中概率还是蛮高的，大部分题目都似曾相识，毕竟 Android 常用知识点也就这些。当然不要因此掉以轻心，优秀的面试官是会针对细节深入挖掘的，所以不止要“知道”，还要“理解和掌握”。
另一块是计算机网络、计算机原理等。对客户端开发来说，计算机网络的考察会比较多，TCP 和 UDP 的区别、TCP 的拥塞控制、TCP 的握手与挥手流程、HTTP 与 HTTPS 的差别等等。基本面的所有公司都问到这块了。
**这块需要特别注意的点就是你的覆盖面是否足够，因为不同公司的不同部门的不同面试官都可能会有不同的提问姿势。**你不完整系统得把基础过一遍，真不能保证你能信心十足（一两个问题被问倒其实没什么，但能不被问倒更好不是）。
我可以举几个例子，比如在问大图加载时顺口问一下“同一个文件，放到 drawable 目录下和放到 SD 卡中，加载到内存时内存占用一样么” （这里涉及到了 Bitmap decode 时的过程以及 Bitmap 内存占用的计算），比如 HashMap put 方法调用时内部的流程是怎样（方法内部的流程、HashMap 的扩容等），比如 Http 1.1 和 2.0 的特点和区别 —— 这些例子都是我或者我朋友真实碰到的面试题，在没经过充分的面试准备之前，你能答出多少呢？
2.3 技术原理 一般这类问题是在问基础题时顺势往底层问，或者是你自己在回答时顺便带出来，比如屏幕绘制原理、几种动画的原理、布局加载原理等等，是体现个人的技术深度的。
我觉得这类题目不是死记硬背可以解决的，作为面试官，自然有办法考察出你是“了解”还是“理解”。
其实系统地复习这些内容本身也是挺有趣的，你会很容易发现技术背后的实现存在深层的联系。所以这块不只是面试题那么简单，它也是我们以后往“资深开发者”走的一个方向。
**回答这类问题，主动比被动更好。**一般面试官问你很基础的问题时，你当然可以惜字如金只回答对应的答案，但假如你能主动扩展到原理层面、甚至隐晦地表示你看过源码，要我是面试官也会喜欢你（斜眼笑）。
2.4 项目架构和模块设计 我一开始也没有经验，面爱奇艺时让我介绍项目我就简单介绍了下项目需求是怎样，可以看出面试官并不满意。后面专门向一个牛逼的前同事请教了这个，他的建议是注意介绍项目架构，后面面其他家时，果然感觉轻松了一些。
不管是做业务开发还是做基础技术开发，对于整个项目的架构一定要了解。比较常见的情况是面试官会让你画出架构图。当然，就算面试官只是让你介绍项目，你也可以主动介绍项目的架构 —— 这可以体现出你对架构设计的关注。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b8b1b3e9cb3eef9cb79f36505e20f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e5e5c9ce688fa16f66578a0e9cfbc23/" rel="bookmark">
			哪些著名软件是用C、C&#43;&#43;编写的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常跟大家谈论C/C++是多么的厉害，但总是耳听为虚，还需眼见为实，那如何做到眼见为实呢？当然还是要从"业绩"出发，那么今天就跟大家找了一些内容，看看有哪些优秀的软件作品是C，C++的杰作呢？
正文部分：
1、操作系统（OS） Microsoft Windows ：汇编 -&gt; C -&gt; C++
备注：曾经在智能手机的操作系统（Windows Mobile）考虑掺点C#写的程序，比如软键盘，结果因为写出来的程序太慢，实在无法和别的模块合并，最终又回到C++重写。
相信很多朋友都知道Windows Vista，这个系统开发早期比尔盖茨想全部用C#写，但是最终因为执行慢而放弃，结果之前无数软件工程师日夜劳作成果一夜之间被宣告作废。
Linux ：C
Apple MacOS ： 主要为C，部分为C++。备注：之前用的语言比较杂，最早是汇编和Pascal。
Sun Solaris ： C
HP-UX ： C
Symbian OS ： 汇编，主要为C++。（诺基亚手机）
Google Android ：2008 年推出：C语言（有传言说是用Java开发的操作系统，但最近刚推出原生的C语言SDK）
RIM BlackBerry OS 4.x ：黑莓 C++
2、图形界面层 Microsoft Windows UI ：C++
Apple MacOS UI (Aqua) ： C++
Gnome （Linux图形界面之一，大脚）： C和C++， 主要是C。
KDE （Linux图形界面），C++。
3、桌面搜索工具 Google Desktop Search ： C++
Microsoft Windows Desktop Search ： C++
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e5e5c9ce688fa16f66578a0e9cfbc23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55127bb3b0337a79fcabff9a70d41e88/" rel="bookmark">
			CMD命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMD命令大全
cmd命令系列软件最新版本下载
CMD命令速查手册
立即下载
cmd命令大全工具
立即下载
最早期的电脑系统是DOS系统，DOS系统只有一个黑漆漆的窗口，需要自己输入命令，所以学习命令是很有必要的，那么CMD命令大全是什么?直到今天的Windows系统，还是离不开DOS命令的操作。下面一起来看看。
一、CMD命令：
开始-&gt;运行-&gt;键入cmd或command(在命令行里可以看到系统版本、文件系统版本)。 二、CMD命令大全详解：
1、 gpedit.msc-----组策略。
2.、sndrec32-------录音机。
3、Nslookup-------IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。
【cmd命令大全】一、CMD命令
4、explorer-------打开资源管理器。
5、logoff---------注销命令。
6、shutdown-------60秒倒计时关机命令。
7、lusrmgr.msc----本机用户和组。
8、services.msc—本地服务设置。
9、oobe/msoobe /a----检查XP是否激活。
10、 notepad--------打开记事本。
11、cleanmgr-------垃圾整理。
12、net start messenger----开始信使服务。
13、 compmgmt.msc—计算机管理。
14、net stop messenger-----停止信使服务。
15、conf-----------启动netmeeting。
16、dvdplay--------DVD播放器。
17、charmap--------启动字符映射表。
18、 diskmgmt.msc—磁盘管理实用程序。
19、calc-----------启动计算器。
20、 dfrg.msc-------磁盘碎片整理程序。
21、chkdsk.exe-----Chkdsk磁盘检查。
22、devmgmt.msc— 设备管理器。
23、regsvr32 /u *.dll----停止dll文件运行。
24、 drwtsn32------ 系统医生。
25.、rononce -p----15秒关机。
26、dxdiag---------检查DirectX信息。
27、 regedt32-------注册表编辑器。
28、 Msconfig.exe—系统配置实用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55127bb3b0337a79fcabff9a70d41e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a56aa65003cdd801bc95ac479a108f6/" rel="bookmark">
			10、Java类与对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10、Java类与对象 类就是自定义的数据类型，对象就是一个具体的实例
10.1 基本介绍 属性/成员变量/实例字段：是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象；数组）
定义：访问修饰符 属性类型 属性名；若不赋值，则有默认值，规则和数组一致
Java内存结构分析：
栈：一般存放基本数据类型（局部变量）堆：存放对象，数组等方法区：常量池（常量，比如字符串）；类加载信息（属性信息，方法信息） Java创建对象流程（简略）：
在方法区先加载类信息（属性和方法信息，且只会加载一次）在堆中分配空间，进行默认初始化把地址赋给对象进行指定初始化，覆盖原来的初始化值注意：对象的地址在堆中。对象的引用（对象名）在栈中，指向堆中对应的对象地址 Java成员方法的定义：
访问修饰符 返回数据类型 方法名（形参列表…）{方法体；return返回值;}
访问修饰符：规定访问权限返回数据类型：表示成员方法输出，void没有返回值方法名：表示成员方法的输入方法体：实现该方法的具体实现return 不是必须的。如void时可以不用return，或者只写return一个方法最多有一个返回值，返回类型可以是任何类型，包括引用类型（数组，对象）形参列表可以有0个参数，也可以有多个参数；参数类型可以为任何类型，包括引用类型，调用方法时，要对应参数列表传入相同类型或兼容类型的参数方法定义时的参数称为形式参数（形参）；方法调用时传入的参数称为实际参数（实参）。实参和形参类型，个数，顺序必须一致。方法里不能嵌套其他方法的定义在两个方法在同一类中，一个方法可以直接调用另一个方法，不用创建对象跨类调用方法，需要创建该类对象，再通过对象名调用该类方法；注意：跨类的方法调用和方法的访问修饰符相关；后续会细说 Java方法调用机制：
在栈中自动创建一个main栈，当程序执行到方法时，就会开辟一个独立的栈空间当方法执行完毕，或者执行到return语句时，就会返回返回到调用方法的地方返回后，只需执行之后的语句 Java成员方法传参机制
基本数据类型的传参机制：基本数据类型传递的是值（值拷贝），形参的任何改变不会影响实参引用数据类型的传参机制：引用数据类型传递的是地址（传递的也是值，但值是地址），可以通过形参影响实参 练习：编写一个方法copyPerson，可以复制一个Person对象信息，返回复制后的对象；要求两个对象相互独立，只是属性相同
Person person = new Person(); person.age = 10; person.name = "Jack"; Tool T= new Tool(); Person newperson = T.copyPerson(person); System.out.println(newperson.age); System.out.println(newperson.name); System.out.println(person.age); System.out.println(person.name); class Person{ int age; String name; } class Tool{ public Person copyPerson(Person p){ Person newperson =new Person(); newperson.age = p.age; newperson.name = p.name; return newperson; } } 递归练习1：给定整数n ,用递归的方式求出斐波那契1,1,2,3,5,8,13…第n个数为多少
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a56aa65003cdd801bc95ac479a108f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3977e813b45ec7795458a617294e2f5/" rel="bookmark">
			银联小程序支付 提示“认证失败”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发文档：
https://res-mop.chinaums.com/upload_doc/%E9%97%A8%E6%88%B7%E6%96%87%E6%A1%A3/%E6%94%AF%E4%BB%98%E6%96%87%E6%A1%A3/852e835b87835a561c1e4094998af50e934c014be02f0fbc3fc9a1c677bc4058.pdf
{"errCode":"1000","errInfo":"认证失败"} 调用的url：https://api-mop.chinaums.com/v1/netpay/wx/unified-order
代码如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/348c66c450f764be6a94b7863e7f9325/" rel="bookmark">
			轮询、长轮询、长连接、websocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http 协议介绍：
http 协议是请求/响应范式的, 每一个 http 响应都是由一个对应的 http 请求产生的; http 协议是无状态的, 多个 http 请求之间是没有关系的。
http 长连接：
目前 http 协议普遍使用的是 1.1 版本, 之前有个 1.0 版本, 两者之间的一个区别是 1.1 支持http 长连接, 或者叫持久连接，1.0 不支持 http 长连接, 每次一个 http 请求响应后都关闭 tcp 连接, 下个 http 请求会重新建立 tcp 连接.
所谓 http 长连接, 就是多个 http 请求共用一个 tcp 连接; 这样可以减少多次临近 http 请求导致 tcp 建立关闭所产生的时间消耗。http 1.1 中在请求头和相应头中用 connection字段标识是否是 http 长连接, connection: keep-alive, 表明是 http 长连接; connection:closed, 表明服务器关闭 tcp 连接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/348c66c450f764be6a94b7863e7f9325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877cd685bd7d756c205d1c1e39b119b0/" rel="bookmark">
			【Doxygen】Doxygen使用教程（个人总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Doxygen】Doxygen使用教程（个人总结） 简介Doxygen
引言．什么是Doxygen? Doxygen 是一个程序的文件产生工具，可将程序中的特定批注转换成为说明文件。通常我们在写程序时，或多或少都会写上批注，但是对于其它人而言，要直接探索程序里的批注，与打捞铁达尼号同样的辛苦。大部分有用的批注都是属于针对函式，类别等等的说明。所以，如果能依据程序本身的结构，将批注经过处理重新整理成为一个纯粹的参考手册，对于后面利用您的程序代码的人而言将会减少许多的负担。不过，反过来说，整理文件的工作对于您来说，就是沉重的负担。
Doxygen 就是在您写批注时，稍微按照一些它所制订的规则。接着，他就可以帮您产生出漂亮的文档了。
因此，Doxygen 的使用可分为两大部分。首先是特定格式的批注撰写，第二便是利用Doxygen的工具来产生文档。
目前Doxygen可处理的程序语言包含：
C/C++
Java
IDL (Corba, Microsoft及KDE-DCOP类型)
而可产生出来的文档格式有：
HTML
XML
LaTeX
RTF
Unix Man Page
而其中还可衍生出不少其它格式。HTML可以打包成CHM格式，而LaTeX可以透过一些工具产生出PS或是PDF文档。
要想使用Doxygen，需要三大步骤
一．安装Doxygen 1.Doxygen及其相关内容下载 1.1Doxygen下载 由于国内墙了Doxygen的官网，但sourceforge还是可以使用
http://sourceforge.NET/projects/doxygen/?source=dlp 进行下载
本文使用的为Doxygen 1.8.3.1
安装，我们将在配置的时候使用doxywizard，Doxygen的GUI版本。
1.2HTML Help Workshop下载 Doxygen 使用这个工具可以生成 CHM 格式的文档。
如果你希望你的Doxygen自动生成chm，那么请下载HTML Help Workshop，我们将要使用当中的hcc.exe文件以及相关dll
https://docs.microsoft.com/zh-cn/previous-versions/windows/desktop/htmlhelp/microsoft-html-help-downloads?redirectedfrom=MSDN 进行下载
下载其中的htmlhelp.exe并安装，记住安装目录，我们将在Doxygen配置时使用。
1.3 Graphviz Graphviz在Doxygen用于自动生成类图的工具。graphviz 是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。Doxygen 使用 graphviz 自动生成类之间和文件之间的调用关系图，如不需要此功能可不安装该工具包。
登陆官网发现被墙了，只能在天朝大局域网内随便找个方便的连接了。
https://www.graphviz.org/，
安装并记录安装目录，同样我们一会需要配置Doxygen
二．Doxygen的配置 Doxygen 产生文档可以分为三个步骤。一是在程序代码中加上符合Doxygen所定义批注格式。二是使用Doxywizard进行配置。三是使用Doxygen来产生批注文档。
2.1基本配置 在基本配置中，会介绍一些关于Doxygen的基本配置，例如各种乱码，输出内容等。
首先我们打开开始-》所有程序-》Doxygen-》doxywizard
在开始之前，打开Doxygen GUI frontend的File，保存到你需要做测试的目录
会出现一个Doxyfile的配置文件，修改选项后保存，下次通过Doxygen打开这个文件可以还原该项目的配置
2.2 进行配置 Doxygen 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/877cd685bd7d756c205d1c1e39b119b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e79969dce069a126d8f988c0ced8ce/" rel="bookmark">
			第二篇：C语言中实现两个数的加法运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码展示：
//实现两个数的加法运算
#include &lt;stdio.h&gt; //C语言预编译指令 int main(){
int a,b,sum=0; //初始化
scanf("%d%d",&amp;a,&amp;b); //输入a和b的值
sum=a+b; //计算a+b，其结果赋给sum printf("%d, %d,sum=%d\n",a,b,sum);
return 0;
}
运行结果：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/241/">«</a>
	<span class="pagination__item pagination__item--current">242/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/243/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>