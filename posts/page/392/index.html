<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e30229f2d681e67f06a0e8f2c4cc405/" rel="bookmark">
			动态改变map-area区域背景色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天公司项目地图需要改版，要求地图区域根据数据指定背景色
方法一：根据数据动态切图，会有区域*区域各图产生
方法二：采用插件效果图这个是一不小心看到的。然后就一点点扣代码，最终发现是个插件。
html代码`
&lt;img src="${ctx.contextPath}/tkms/images/cz5.png" usemap="#Map" id="imgsrc" title="" width="640px" height="700px" class="maphilighted1" style="opacity: 0; position: absolute; left: 20px; top: 50px; padding: 0px; border: 0px;"&gt; &lt;/div&gt; &lt;map name="Map" id="Map"&gt; &lt;area id="xzq1" style="outline: none;" shape="poly" href="tkqy?xzq=1" xzq="1" title="溧阳市" coords="95,216,97,217,99,217,101,219,104,219,106,219,108,219,108,221,109,224,106,225,105,225,103,224,101,223,100,224,99,224,99,226,100,228,100,229,101,231,101,233,103,234,104,236,106,238,108,240,109,242,111,243,112,245,114,247,115,247,118,247,118,246,119,246,121,244,122,243,125,244,125,246,126,248,128,247,129,247,131,249,133,251,134,254,136,256,137,258,138,261,140,263,141,264,144,266,147,267,149,268,150,268,152,270,152,272,154,273,155,273,157,272,158,271,162,269,162,271,164,273,166,275,168,276,171,277,173,278,175,278,176,278,180,279,184,278,186,278,190,278,194,278,196,278,199,278,201,279,205,281,206,281,210,281,213,281,216,281,218,280,220,280,222,280,227,278,229,279,232,281,232,283,230,286,229,288,228,291,226,294,224,296,224,299,223,301,222,303,221,307,220,310,219,311,218,313,216,314,215,314,212,314,212,314,210,316,210,317,210,320,210,321,212,323,213,325,214,327,214,329,213,331,212,333,212,334,213,335,213,335,215,336,217,336,220,336,221,337,220,340,220,343,219,346,218,348,217,350,215,352,215,354,214,354,211,354,208,354,205,356,204,357,204,360,204,362,202,364,200,364,198,366,197,367,198,369,199,371,199,372,198,375,197,378,196,381,194,385,192,389,191,392,191,395,191,399,191,402,192,404,194,406,194,409,192,411,190,414,189,416,189,418,189,421,190,422,190,423,191,426,192,427,193,429,195,431,194,433,194,435,194,437,194,440,194,442,194,445,193,448,193,450,192,451,191,453,189,455,190,457,191,458,194,460,195,462,195,465,196,467,198,467,200,467,202,468,203,471,203,473,203,476,203,479,203,482,202,485,203,487,203,490,202,492,200,496,197,498,195,500,194,502,192,501,189,503,186,504,182,504,179,503,177,502,174,501,172,501,171,504,171,506,170,505,169,504,166,504,164,504,161,505,160,505,158,504,157,500,157,498,155,496,152,494,150,494,148,494,147,491,147,490,145,489,143,490,142,492,140,493,137,494,136,494,135,492,134,492,131,495,130,496,127,497,125,496,125,494,126,491,127,489,127,488,128,486,124,486,120,485,118,485,115,481,114,477,114,475,114,472,114,470,114,468,113,467,112,464,112,462,113,460,114,459,116,457,116,455,117,453,119,451,119,447,120,445,118,444,117,442,117,441,117,439,117,438,117,436,116,434,116,433,115,431,113,429,112,429,110,428,109,428,108,429,108,431,108,432,108,433,107,436,106,437,106,440,106,443,106,446,105,448,102,448,100,447,95,447,91,446,87,444,83,444,82,445,80,447,78,447,74,448,73,449,69,450,67,450,65,448,64,446,61,448,60,450,59,451,56,450,53,449,51,447,49,447,48,444,47,444,45,446,43,444,42,442,39,443,37,444,35,441,35,438,35,435,35,432,32,430,30,428,29,425,30,423,32,421,33,420,33,418,33,415,33,412,35,410,37,408,39,405,40,403,42,402,43,401,43,398,41,397,39,395,37,393,36,390,34,387,33,385,30,383,27,381,25,379,23,377,22,374,22,371,21,369,21,366,21,364,21,362,21,360,21,359,21,356,21,355,20,353,19,352,18,351,16,351,13,351,11,350,10,348,10,347,8,346,8,344,9,343,10,342,10,342,11,340,12,339,13,338,13,336,14,335,14,333,16,331,16,330,16,328,15,327,14,325,13,322,14,320,18,319,20,318,22,318,24,316,24,316,26,315,28,314,30,314,31,312,33,309,34,306,35,305,35,302,34,301,30,301,28,301,28,298,28,295,28,291,29,290,32,289,34,288,36,288,37,287,38,285,39,283,39,281,40,280,40,279,42,278,44,278,44,276,44,274,44,271,45,267,47,264,48,261,50,259,50,256,50,254,51,252,52,250,53,247,56,245,59,245,61,244,64,245,66,244,68,240,71,238,73,237,75,236,77,235,79,233,81,232,83,232,84,229,85,228,87,226,88,225,90,223,91,220,92,218,94,218" /&gt; &lt;area id="xzq2" style="outline: none;" shape="poly" href="tkqy?xzq=2" xzq="2" title="金坛区" coords="93,216,96,216,98,216,101,218,102,219,104,219,106,219,108,219,108,222,109,224,108,225,105,225,103,224,101,224,100,225,100,228,100,229,102,231,102,234,103,236,104,236,105,239,107,241,108,242,111,244,113,246,115,247,118,246,119,245,121,244,122,244,124,246,124,247,126,248,127,247,129,248,130,249,131,250,133,252,135,254,135,256,137,258,138,260,140,262,141,263,143,265,145,266,147,267,149,268,151,269,152,271,153,272,154,273,156,272,156,271,159,270,161,270,162,271,165,273,167,275,169,276,171,277,173,278,177,278,179,279,183,279,185,279,188,278,190,278,192,278,195,278,197,278,199,278,200,279,203,280,206,281,209,281,211,281,214,281,216,281,218,280,221,280,223,280,225,279,227,279,229,280,231,281,231,282,232,283,234,284,234,284,236,283,238,282,239,281,241,279,241,278,241,276,243,275,244,273,244,271,244,270,244,268,244,266,244,264,244,262,244,261,245,259,247,259,250,258,252,258,255,257,257,257,258,255,258,253,259,251,261,249,263,247,265,245,265,244,266,241,266,239,266,236,266,235,266,233,267,232,268,231,269,230,270,230,271,229,272,228,272,227,271,225,272,222,272,220,272,218,271,216,270,214,269,214,269,211,271,207,273,205,275,204,278,203,281,204,282,205,285,206,287,206,289,205,291,204,293,202,294,200,295,197,295,195,295,193,294,192,291,191,288,190,286,189,283,188,280,188,277,187,275,184,275,181,273,179,271,178,268,176,267,173,265,171,261,168,258,168,256,167,254,167,251,165,249,163,248,161,248,158,247,155,244,152,241,152,240,151,237,151,236,152,233,152,230,152,229,150,228,148,228,144,228,140,226,136,224,136,222,135,221,133,220,131,220,128,219,126,216,125,214,125,213,124,212,122,211,121,209,121,207,121,207,120,205,117,202,119,202,121,200,121,197,122,195,122,192,121,189,121,186,121,184,122,182,122,180,122,178,121,176,120,175,119,174,117,170,115,168,114,165,112,162,111,160,109,159,107,157,105,156,104,154,104,152,105,149,107,148,108,146,110,144,111,142,111,141,113,141,115,140,116,139,118,139,121,139,123,141,123,142,123,144,124,145,124,145,125,147,127,147,128,148,131,149,133,149,135,148,137,145,136,141,135,137,135,135,134,132,133,130,132,128,129,127,128,125,127,123,126,121,126,119,127,118,125,118,122,116,121,114,119,111,120,108,120,107,121,104,121,101,122,99,124,99,126,99,129,98,132,97,133,96,136,95,138,94,140,93,142,92,144,92,146,90,149,90,150,92,153,92,155,92,158,92,160,91,161,89,163,88,165,87,167,87,169,87,171,87,174,87,176,87,179,88,180,88,183,87,185,87,187,88,188,90,189,91,189,93,188,94,188,95,190,96,191,94,194,94,195,94,197,94,199,94,200,95,202,95,204,95,205,96,206,96,208,94,209,94,210,93,211,93,214,94,216" /&gt; &lt;area id="xzq3" style="outline: none;" shape="poly" href="tkqy?xzq=3" xzq="3" title="武进区" coords="287,173,290,173,294,174,296,174,297,176,300,177,303,177,306,177,309,178,311,180,311,181,315,181,316,182,318,181,319,180,320,179,322,179,324,178,326,179,328,179,330,179,332,179,332,179,333,177,334,176,336,173,338,171,341,171,344,171,346,171,350,172,353,172,354,174,358,176,358,178,360,180,363,181,365,182,366,180,370,179,373,178,375,178,377,178,378,178,381,180,385,180,389,180,391,182,394,183,397,184,400,185,403,187,406,189,409,191,412,190,413,191,413,195,412,197,413,200,412,203,412,206,412,209,411,212,411,216,411,219,413,220,415,221,417,222,419,222,421,222,423,221,425,220,427,219,429,219,433,217,436,214,438,214,443,214,446,215,448,216,451,216,455,217,458,218,462,219,465,220,467,221,469,223,471,224,473,226,475,227,476,229,475,232,473,232,471,232,471,235,471,237,471,239,469,240,468,242,467,244,465,244,464,246,462,247,461,249,459,250,457,252,455,254,452,256,450,258,449,260,447,262,448,264,448,266,447,268,446,269,444,271,442,272,441,273,441,275,441,276,441,278,442,281,442,281,442,282,443,283,444,284,445,284,446,284,448,285,449,286,451,287,453,289,456,289,458,289,460,292,460,294,460,297,461,298,461,301,461,303,462,305,463,305,463,306,464,307,466,307,466,307,467,307,468,307,470,309,472,310,473,314,471,317,471,319,470,322,469,324,467,326,465,328,466,332,465,335,465,337,462,339,458,340,455,343,453,344,450,346,447,350,444,351,442,355,440,358,439,360,437,363,435,366,434,370,433,373,432,377,432,381,432,385,433,388,435,391,438,392,440,393,444,394,448,396,453,397,456,398,459,399,460,402,460,404,458,407,456,407,453,407,448,407,444,405,438,404,433,401,429,398,428,396,426,394,425,391,424,389,424,386,424,382,425,378,424,374,425,371,426,368,427,364,428,360,429,357,429,354,429,352,431,348,431,344,432,339,433,337,434,334,434,332,434,328,433,325,432,323,432,322,430,320,426,318,422,317,419,317,417,316,414,316,411,316,409,314,406,312,404,309,402,306,401,304,399,300,397,297,393,296,391,295,387,292,385,291,383,289,380,288,378,288,376,289,371,291,366,291,363,291,359,290,356,290,353,290,350,292,347,295,345,298,342,300,340,301,335,301,331,300,327,299,322,296,318,295,314,293,310,292,306,290,303,287,299,286,296,285,293,285,290,283,288,282,285,283,283,285,281,285,279,284,277,281,277,280,276,278,274,277,273,277,271,276,270,273,269,270,269,267,268,265,266,263,264,262,262,260,260,258,259,257,258,255,258,253,259,251,260,250,262,248,263,247,265,245,266,242,266,239,266,236,266,233,267,232,269,230,271,229,272,228,272,227,271,224,271,222,271,219,271,217,272,215,269,212,270,209,271,207,272,205,273,204,275,203,276,203,278,203,280,203,282,205,283,206,285,206,287,206,290,205,291,204,292,203,293,201,293,200,295,197,296,194,293,192,292,190,291,187,290,184,290,182,289,180,288,178,287,176,286,174" /&gt; &lt;area id="xzq4" style="outline: none;" shape="poly" href="tkqy?xzq=4" xzq="4" title="经开区" shape="poly" coords="412,193,412,197,411,202,411,206,411,212,411,218,411,221,416,223,420,223,424,223,427,221,433,220,436,219,438,218,444,218,448,218,453,219,460,222,466,224,471,228,473,228,474,225,473,222,474,219,474,218,479,219,482,220,483,215,484,212,483,209,487,206,489,203,489,195,489,191,489,186,488,183,488,180,490,178,491,178,496,179,500,179,505,179,507,177,506,171,506,169,504,164,500,160,498,157,494,154,492,151,489,149,484,149,482,150,479,150,476,153,472,153,468,154,465,156,462,157,460,156,456,156,454,159,452,161,450,162,446,163,442,164,438,164,433,165,429,165,424,167,420,169,419,170,418,172,417,174,417,176,418,178,419,179,422,182,423,184,425,185,425,188,423,189,419,189,414,191,412,191" /&gt; &lt;area id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e30229f2d681e67f06a0e8f2c4cc405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2848d79941f45977fd1e0245f586a2d/" rel="bookmark">
			解决vscode无法debug调试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决vscode无法debug调试问题 本人使用的fedoraKDE……直接使用终端可以用gdb正常调试，然后在vscode按网上说的设置
{
"version": "0.2.0", "configurations": [ { "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "${workspaceFolder}/a.out", "args": [], "stopAtEntry": false, "cwd": "${workspaceFolder}", "environment": [], "externalConsole": true, "MIMode": "gdb", "setupCommands": [ { "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true } ] } ] }
结果是会在start debugging 一直读条。
谷歌找了好半天看各种教程……
然后又看各种论坛……就是各种回复你TM都用linux了干嘛还用vscode，直接终端gdb啊。最后终于有人解决了这个问题……
其实就是 “externalConsole”: 这项设置……部分linux里vscode无法启用外部终端……把他设置成false就好了，我想大概是KDE的控制台是konsole吧又或者是权限的问题
一上午的时间啊，我想静静，别问我静静是谁，问就平和岛静雄
原文链接：https://blog.csdn.net/qq_39491052/article/details/86067991
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e65ac7aff598ab862d2f2092f5bb3104/" rel="bookmark">
			数学分析教学：第一章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一章 实数与数列极限
第一节 数轴
术语解析：
第二节 无穷小数和数列
1.定义
补充matlab数学工具
第一章 实数与数列极限 第一节 数轴 术语解析： 区间
开区间：所有在a 与 b 之间的点的集合称为开区间（a, b）= {x: a&lt;x&lt;b}
闭区间：由开区间添加两个端点a 与 b 组成的区间【a, b】。
半开区间（半闭区间）：（a, b]、[a, b)。
实数的集合：
开区间与闭区间的长度：|x - y|
三角不等式
等号成立的条件：x, y中至少有一个为零，或者两者同号
用处很广
实数域
有理数： 可以表示为两个整数之商/比例。
两个定义的等价证明
有理数经过加减乘除（除数不能是0）的四则运算之后仍为有理数
数轴表示有理数（p/q）的方法：设 q 为给定的正整数, 吧单位长度分成 q 等份，找出代表 1/q 的那一点，从而对于任意整数 p 不难找出代表 p/q 的那个点。
实数的有理数逼近：对任意固定的实数 x, 一定可以找出一个整数 p 使得： =&gt; 由于q是任意取定的正整数，每个实数都能用有理数去逼近到任意精确的程度。但只是逼近，数轴上依然有有理数不能表示的点
设 n 为正整数，且 n 为不完全平方数，那么 就不是有理数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e65ac7aff598ab862d2f2092f5bb3104/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fff5a6939575de7d34b626206cdf0aa/" rel="bookmark">
			自己实现一个spring-AOP思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		aop的加载顺序要在IOC加载的前面，即是要实例完代理类之后才在这个实例上注入属性。
实现一个基于注解的aop：
1、定义一个切面注解 Aspect
/** * 切面注解 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Aspect { Class&lt;? extends Annotation&gt; value(); } 2、定义一个代理接口Proxy,定义一个实现这个接口的抽象类（切面代理 AspectProxy）
/** * 代理接口 */ public interface Proxy { /** * 执行链式代理 * @param proxyChain * @return * @throws Throwable */ Object doProxy(ProxyChain proxyChain) throws Throwable; } /** * 切面代理 */ public abstract class AspectProxy implements Proxy { private static final Logger logger = LoggerFactory.getLogger(AspectProxy.class); @Override public final Object doProxy(ProxyChain proxyChain) throws Throwable { Object result = null; Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fff5a6939575de7d34b626206cdf0aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9204910f99e563faa9ca83822ce2ad34/" rel="bookmark">
			Npm的作用及其与Node.js的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章不讲如何安装npm，毕竟这样的文章的网上一大堆，只说说Npm的原理及其作用。
npm是什么 npm（node package manager）Node的包管理工具，这是官方术语，是不是看的一脸茫然，其实没必要这么复杂。
npm可以看做一个托管代码的仓库，当开发一个大型网站时，可能会用到许多类库、框架。比如要用到 jQuery、 BootStrap、React等等，那么开发者就要到对应的网站分别下载：
去 jQuery的官网下载；
去 BootStrap的官网下载 BootStrap ；
去 React的官网下载 React ；
······
不，一定有更简便的方法，于是 npm 应运而生 , npm把这些代码集中起来放到服务器上，当开发者需要用到用到这些代码时，就可以通过 npm 做到按需调用，大大节省了时间，这就是 npm 的作用。
但是，由于 npm 的服务器在国外，所以由于一些原因，可能会无法访问或者速度很慢,这时候就需要备用方案了。于是， nrm出现了。
什么是 nrm npm是管理包，nrm用来管理npm。npm是JS的包管理器，通过npm安装你所需要的项目包，但是有时候会下载不了，所以就需要用nrm修改下npm的下载源。你只需要 nrm ls 来切换一下 npm 的源就可以继续使用了。
npm 如何与 Node.js 走到一起的？ 虽然 npm 这么强，但要使用的前提是要先安装 Node.js，为什么会这样？
这里有一段故事：Node.js 是由一个在德国工作的美国程序员 Ryan Dahl 写的。他写了 Node.js，但是 Node.js 缺少一个包管理器，于是他和 npm 的作者一拍即合、抱团取暖，最终 Node.js 内置了 npm。
因为，npm本身就是依赖Node.js的，所以欲想使用 npm ，必先安装 Node.js。
谢谢观看。
参考文章：npm 是干什么的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48e516698696490f61dde439f573e646/" rel="bookmark">
			Python tkinter（一） 按钮（Button）组件的属性说明及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python tkinter 按钮组件用于tkinter GUI里添加按钮，按钮可以添加文本和图像。当按钮按下时，可以执行指定的函数。
使用语法：
widget = Button( master, parameter=value, ... ) master：按钮控件的父容器parameter：按钮的参数value：参数对应的值 各参数之间以逗号分隔。
参数说明：
state按钮状态选项，状态有DISABLED/NORMAL/ACTIVEactivebackground当鼠标放上去时，按钮的背景色activeforeground当鼠标放上去时，按钮的前景色bd按钮边框的大小，默认为 2 个像素bg按钮的背景色fg按钮的前景色（按钮文本的颜色）font文本字体，文字字号，文字字形。字形有overstrike/italic/bold/underlineheight按钮的高度，如未设置此项，其大小以适应按钮的内容（文本或图片的大小）width按钮的宽度，如未设置此项，其大小以适应按钮的内容（文本或图片的大小）image按钮上要显示的图片，图片必须以变量的形式赋值给image，图片必须是gif格式。justify显示多行文本的时候,设置不同行之间的对齐方式，可选项包括LEFT, RIGHT, CENTERpadx按钮在x轴方向上的内边距(padding)，是指按钮的内容与按钮边缘的距离pady按钮在y轴方向上的内边距(padding)relief边框样式，设置控件显示效果，可选的有：FLAT、SUNKEN、RAISED、GROOVE、RIDGE。wraplength限制按钮每行显示的字符的数量，超出限制数量后则换行显示underline下划线。默认按钮上的文本都不带下划线。取值就是带下划线的字符串索引，为 0 时，第一个字符带下划线，为 1 时，第两个字符带下划线，以此类推text按钮的文本内容command按钮关联的函数，当按钮被点击时，执行该函数 代码示例：
# -*- coding:utf-8 -*- from tkinter import * class buttons: def __init__(self): root = Tk() root.title("按钮") # 设置窗口标题 root.geometry("600x600") # 设置窗口大小 注意：是x 不是* '''按钮样式''' # 按钮文字切换 self.btsd = Label(root, text='按钮文字切换：') self.bts = Button(root, text='按钮开始', command=self.Button_text_switch) # 按钮状态 self.button_state = Label(root, text='按钮状态：') self.disabled_state = Button(root, text='禁用状态') self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48e516698696490f61dde439f573e646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f54b94f8d80b33eb22f70d7739b7fda/" rel="bookmark">
			Forge 极简入门 | ArcBlock 博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者： 王仕军（资深前端工程师）
相信你应该已经知道 ArcBlock[1] 是一家什么样的公司：我们坚信区块链会给人类组织和协作方式带来巨大的变革，我们致力于开发简单易用、灵活可扩展的 dApp 开发框架和工具。到目前为止我们已经发布了 Forge 框架[2] 及围绕 Forge 框架的一系列工具。
Forge 工具箱从开始的只包含 Forge 内核，到现在包含能覆盖 dApp 完整生命周期的如下组件：
•Forge 内核: 交易处理引擎、和共识引擎、数据存储层的交互，每周会有大小版本发布•核心智能合约: Forge 内置的交易合约，能够帮助开发者解决 99% 的账户、交易、跨链、链上治理等业务逻辑•Forge Desktop：桌面版链节点•Forge Web: Forge 链节点的 Web 管理界面和区块浏览器•Forge SDK: 各种语言的 SDK，目前支持的语言包括 Elixir、Javascript、Java、Python、Rust•Forge Simulator：流量模拟器•dApp Workshop：dApp 原型工坊•Forge Patron：集成测试工具•Forge Deploy：生产环境大规模部署的工具，目前只支持 AWS•Forge Compiler：智能合约编译工具，跟随 Forge 发版，在 Forge CLI 里面可用
而 Forge CLI 是开发者获取、使用这些工具的最佳路径：只需安装一条命令，就得到了整个区块链工具箱。
本文中我们会演示如何使用 Forge CLI 来完成下面几个事情：
•一键发链发币：创建和配置自己的链以及链上的通证•一键创建 dApp：基于基石程序快速常见能跑在链上的 dApp
安装 Forge CLI 因为 Forge CLI 使用 Node.js 开发，所以安装前需要确保你的电脑上有 Node.js v10.x 及以上的运行环境，检查是否存在 Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f54b94f8d80b33eb22f70d7739b7fda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312f12e5b4520c09c46b1db104806a03/" rel="bookmark">
			【C语言】世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。 输入格式：
输入在一行中按照“mm-dd-yyyy”的格式给出月、日、年。题目保证给出的日期是1900年元旦至今合法的日期。
输出格式：
在一行中按照“yyyy-mm-dd”的格式给出年、月、日。
代码如下：
#include&lt;stdio.h&gt; int main() { //dayNum:每个月的天数 int year,month,day,dayNum; int sign=0; printf("请输入月-日-年(例如：10-28-2019):"); scanf("%d-%d-%d",&amp;month,&amp;day,&amp;year); //判断是否闰年 if((year%4==0&amp;&amp;year%100!=0)||year%400==0) { //闰年标记为1 sign=1; } if(month&gt;=1&amp;&amp;month&lt;=12) { //判断每个月的天数 switch(month) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: dayNum=31; break; case 4: case 6: case 9: case 11: dayNum=30; break; case 2: if(sign==1) dayNum=29; else dayNum=28; break; default: break; } if(!(day&gt;0&amp;&amp;day&lt;=dayNum)) { printf("日期格式错误！\n"); return 2; } } else { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/312f12e5b4520c09c46b1db104806a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57fa056591b215dfe569b2ea0c1b176/" rel="bookmark">
			小程序 之自定义Dialog模态框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文通过示例代码详细介绍了小程序自定义模态框，需要的朋友可以参考下
点击"模拟 Dialog"按钮，实现如图所示的样式
1.html部分代码如下：
&lt;button class="weui-btn" type="default" bindtap="openDialog"&gt;模拟 Dialog&lt;/button&gt; &lt;view class="weui-demo-dialog {{istrue ? 'weui-demo-dialog_show' : ''}}" catchtouchmove="true"&gt; &lt;view class="weui-mask" bindtap="closeDialog"&gt;&lt;/view&gt; &lt;view class="weui-dialog__wrp" bindtap="closeDialog"&gt; &lt;view class="dialog_box" catchtap="stopEvent"&gt; &lt;!-- 标题文字 --&gt; &lt;view class="model__title"&gt;注册成功&lt;/view&gt; &lt;!-- 提示icon --&gt; &lt;image class="model__img" src="../../../images/finish.png" mode="aspectFill" style="max-width:100%;"/&gt; &lt;!-- 按钮 --&gt; &lt;view class="model__ft" bindtap="closeDialog"&gt;确定&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 滑动弹出的视图，发现根页面page也跟着滑动，此时需要在页面中添加 catchtouchmove="true"这个属性来阻止底部页面的滚动
2.css部分代码如图所示
.weui-demo-dialog{ visibility:hidden; opacity:0; transition:opacity .3s; } .weui-demo-dialog_show{ visibility:visible; opacity:1; } @media screen and (min-width: 352px){ .dialog_box{ width: 542rpx; margin: 0 auto; } } @media screen and (min-width: 750px){ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a57fa056591b215dfe569b2ea0c1b176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c8c6dcba33f02b99e57203f58b66e0/" rel="bookmark">
			自定义简单实现hashmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hashmap基本结构讲解 哈希表(散列表)的基本结构就是“数组+链表”
其中的Entry[] table 就是HashMap的核心数组结构，我们也称之为“位桶数组”
Entry是什么，源码如下：
一个Entry对象存储了：
key：键对象 value：值对象
next:下一个节点
hash: 键对象的hash值
显然每一个Entry对象就是一个单向链表结构，我们使用图形表示一个Entry对象的典型示意：
然后，我们画出Entry[]数组的结构(这也是HashMap的结构)：
HashMap之所以能根据key直接拿到value，原因是它内部通过空间换时间的方法，用一个大数组存储所有value，并根据key直接计算出value应该存储在哪个索引
如果添加超过16个key-value到HashMap，数组不够用了怎么办？ 添加超过一定数量的key-value时，HashMap会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定hashCode()计算的索引位置。
例如，对长度为32的数组计算hashCode()对应的索引，计算方式要改为：
int index = key.hashCode() &amp; 0x1f; // 0x1f = 31
由于扩容会导致重新分布已有的key-value，所以，频繁扩容对HashMap的性能影响很大。如果我们确定要使用一个容量为10000个key-value的HashMap，更好的方式是创建HashMap时就指定容量：
Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(10000)
虽然指定容量是10000，但HashMap内部的数组长度总是2n，因此，实际数组长度被初始化为比10000大的16384（214）。
简单实现 定义节点 package TestList.TestMap; public class Node2&lt;K,V&gt; { int hash; K key; V value; Node2 next; } 具体实现（主要是put方法） package TestList.TestMap; /** * 自定义Hashmap * 采用数组+链表形式存储元素 * hash值对应在哈希表（散列表）的存储位置，通过hashcode计算出hash，用除留余数法，尽可能均匀分布 */ public class HashMap01&lt;K,V&gt; { Node2[] table;//位桶数组,bucket array;java中数组是对象， int size;//存放的键值对的个数 public HashMap01(){ table = new Node2[16];//长度一般定义为2的整数幂 } /**遍历bucket数组*/ public void put(K key,V value){ //定义了新节点对象 Node2 newNode = new Node2(); newNode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94c8c6dcba33f02b99e57203f58b66e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78df0f514ef3e3018881724715364bc2/" rel="bookmark">
			JSP基本语法与内置对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指令：在页面转换时执行，是向容器提供的关于JSP页面的总体信息 page指令：通知容器关于JSP页面的总体特性，如页面输出的内容类型和使用的字符集等，格式如：&lt;%@ page contentType="text/html;charset = gb2312" %&gt;include指令：告诉容器把另一个文件（HTML、JSP等）的内容包含到当前页面中，格式如：&lt;%@ include file="copyright.html" %&gt; taglib指令：指定在JSP页面中使用标准标签或自定义标签的前缀与标签库的URI。格式如：&lt;%@ taglib prefix="test" uri="taglib.tld" %&gt; JSP 中9大内置对象：request,response,session,application,out,pageContext,config,page,exceptionJSP 中有四大作用域对象：pageContext,request,session,applicationJSP页面生命周期的三个方法： public void jspInit()public void _jspService(HttpServletRequest request，HttpServletResponse response) throws ServletException，IOExceptionpublic void jspDestroy() pageContext变量 pageContext是javax.servlet.jsp.PageContext类型的隐含变量，对应于页面上下文对象。它有下面三个作用：
存储隐含对象的引用。 session、application、config与out这些隐含变量是调用pageContext对象的相应方法得到的。提供了在不同作用域内获取或设置属性的方便的方法。提供了forward()方法和include()方法实现将请求转发到另一个资源和将一个资源的输出包含到当前页面中的功能 public void include(String relativeURL)
public void forward(String relativeURL)
例如，从Servlet中将请求转发到另一个资源，我们需要写下面两行：
RequestDispatcher view = request.getRequestDispatcher("other.jsp");
view.forward(request, response);
在JSP页面中，通过使用pageContext变量仅需一行就可以完成上述功能：
pageContext.forward("other.jsp");
config变量 config是javax.servlet.ServletConfig类型的隐含变量。也可以为JSP页面传递一组初始化参数
&lt;servlet&gt;
&lt;servlet-name&gt;InitTestServlet&lt;/servlet-name&gt;
&lt;jsp-file&gt;/initTest.jsp&lt;/jsp-file&gt;
&lt;init-param&gt;
&lt;param-name&gt;email&lt;/param-name&gt;
&lt;param-value&gt;smith@yahoo.com.cn&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;InitTestServlet&lt;/servlet-name&gt;
&lt;url-pattern&gt;/InitTest&lt;/url-pattern&gt;
&lt;/servlet-mapping &gt;
&lt;html&gt; &lt;body&gt;
Servlet Name = &lt;%=config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78df0f514ef3e3018881724715364bc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d59e19e6c02c9c9a5d84b3d3f6ef03e/" rel="bookmark">
			汇编SHR、SHL、SAR、SAL、ROL、ROR、RCL、RCR指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SHL、SHR、SAL、SAR: 移位指令
;SHL(Shift Left): 逻辑左移
;SHR(Shift Right): 逻辑右移
;SAL(Shift Arithmetic Left): 算术左移
;SAR(Shift Arithmetic Right): 算术右移
;其中的 SHL 和 SAL 相同, 但 SHR 和 SAR 不同.
;SHL、SAL: 每位左移, 低位补 0, 高位进 CF
;SHR : 每位右移, 低位进 CF, 高位补 0
;SAR : 每位右移, 低位进 CF, 高位不变
;它们的结果影响 OF、SF、ZF、PF、CF
ROL、ROR、RCL、RCR: 循环移位指令
;ROL(Rotate Left): 循环左移
;ROR(Rotate Right): 循环右移
;RCL(Rotate through Carry Left): 带进位循环左移
;RCR(Rotate through Carry Right): 带进位循环右移
;ROL: 循环左移, 高位到低位并送 CF
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d59e19e6c02c9c9a5d84b3d3f6ef03e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/875034106e26d2958ffab9a54d9e3230/" rel="bookmark">
			自己实现一个spring-IOC思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		servlet ：第一次访问，将访问init()方法，后面只会访问service()方法，如果在web.xml配置了&lt;load-on-startup&gt;将在容器启动时加载。
实现一个依赖注入项目思路：在web.xml中配置一个servlet,路径可配置为/*,在容器启动的时候访问init(),在这个方法里可调用方法获取指定扫描路径下的class文件，包括jar包下的，保存到一个static final Set&lt;Class&lt;?&gt;&gt; CLASS_SET中。
1，获取含有*controller注解的Class&lt;?&gt;类，遍历其中的方法，获取含有requestMapping的方法，获取其值，保存访问路径对应的方法到一个set中。
2，获取含有Service注解的Class&lt;?&gt;类，如果注解没有标明名称，则通过cls.getInterfaces()获取它的接口，保存对应的关系到一个set中。
3，遍历含有*controller 或Service注解的类，通过cls.getDeclaredFields()获取类中的属性，遍历Fields,如果含有Inject注解，field.getType()返回一个Class&lt;?&gt;,如果注解上没有值，将通过cls.getSimpleName()获取名称，然后获取相应的类，调用field.set(obj,value);实现依赖注入。
一个请求通过自己实现的DispatchServlet访问项目的思路：
1、通过request.getPathInfo()获取访问的路径，根据之前初始化保存的内容，获取对应要处理该请求的方法
2、获取请求头部和body的请求参数，构造成一个Map；
3、通过反射method.voke(obj,args)调用实际的处理类，并且通过一个Object类接收返回值。
4、判断返回值类型，如果是视图，返回值中的参数设置到request中，然后进行请求转发；如果是数据，将通过PrintWriter写到输出流，刷新缓存。
这是一个单例，处理所有请求都是同一个实例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f35e1b6fec12348debff62a63700d4/" rel="bookmark">
			Platinum Maestro运动控制器 —— PVT模式笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 文章说明1. PVT说明2.PVT 插值模式2.1 三次多项式插值(eCUBIC_POLYNOM)2.2 五次多项式插值(eQUINTIC_ON_CUBIC)2.3 七次样条多项式(eSEPTIC_ON_CUBIC)2.4 正弦插值2.4.1 三角正弦插值(eCYCLOID_VELOCITY_MODIFIED1)2.4.2 梯形正弦插值(eCYCLOID_VELOCITY_MODIFIED2)2.4.3 正弦速度插值(eCYCLOID_POSITION) 3. 数据加载4. PVT 运动5.动态模式5.1 初始化列表5.2 加载数据5.3 循环模式（Cyclic Mode） 6.PVT在C++中的实现6.1 PVT表初始化函数6.2 PVT数据点加载函数6.3 PVT移动函数 7.PVT 使用教程7.1 使用方法7.2 例程 0. 文章说明 请忽略前面的扯淡内容，直接跳至3
1. PVT说明 详情参见API手册P783
通常，PV/PVT运动由一组点定义，如果在当前位置之前提供了多个点，profiler可以构建一个三次多项式来计算下一个要下载到驱动器的位置。该路径是实时计算的，因此所有多项式系数的计算都在实时模块中进行。PV/PVT运动不需要执行完整的数据，只需要最少的点。
与样条相似，输入表存储在共享内存中，但与样条不同的是，只存储坐标，而多项式系数在实时模块中计算。表可以通过文件加载，也可以通过用户提供的N x M数组加载。可以选择将一行或几行附加到表中，但要在合理的约束条件下;例如，不能将数据附加到当前段，分析器正在操作。PV/PVT函数块仅适用于NC循环/插补模式。
用户提供的点多于3个，即可应用PVT插补。
2.PVT 插值模式 对于PVT表的定义，遵循以下格式：
Ti为时间，有两种模式：两点之间的相对时间、各点分别对应的绝对时间。
轴的数量不受三个坐标轴的限制，最多可达16个坐标轴。
2.1 三次多项式插值(eCUBIC_POLYNOM) 三次多项式保证了位置和速度的连续性。它的缺点是在每一个连接点上都有加速度和加加速度（即簇动jerk）造成的不连续。
2.2 五次多项式插值(eQUINTIC_ON_CUBIC) 五次多项式保证了位置、速度和加速度的连续性。它的缺点是在每一个连接点上都有加加速度造成的不连续。
2.3 七次样条多项式(eSEPTIC_ON_CUBIC) 七次多项式保证了连续的位置，速度，加速度和加加速度。它的缺点是振幅变化比我们看到的低次多项式更高。这是在大多数情况下可以推荐的最通用的插值模式。
2.4 正弦插值 2.4.1 三角正弦插值(eCYCLOID_VELOCITY_MODIFIED1) 三角形正弦加速度-修正三角形加速度与AC(t)和DC(t)由正弦增加到某个最大值，然后下降到零。它保证连续的位置，速度，加速度和加加速度。
2.4.2 梯形正弦插值(eCYCLOID_VELOCITY_MODIFIED2) 梯形正弦加速度或修正梯形加速度通常由两部分组成:
加速度随正弦曲线从0增加到ACmax，运动与ACmax(抛物线位置，线速度剖面)和加速度下降的正弦为零。由正弦波由零到-ACmax减速运动，由-ACmax减速运动(抛物线位置剖面，线速度剖面)，由正弦波减速增加到零。 它保证连续的位置，速度，加速度和加加速度(如果所有的段定义与此插值模式)。
2.4.3 正弦速度插值(eCYCLOID_POSITION) 这种插补方式产生摆线位置和正弦速度插补。正弦速度是这种插值类型的一个优点，但它有两个明显的缺点。首先，它的开始和结束都伴随着最大的jerk。其次，它的应用具有局限性，当Y(i)≠0和Y(i+1)≠0时必须满足开始和结束导数服从条件△Y(i)=0.5(Y(i)+Y(i+1))△X(i)。（此处存疑） 因此，这种插补方式主要用于Y(i)≠0或者Y(i)=0的情况。
3. 数据加载 将每一行输入数据作为表存储在共享内存中，表示时间、位置、速度和向量位置。例如，我们在使用m个轴的情况下，表中第n行按如下格式生成:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31f35e1b6fec12348debff62a63700d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b603df28020d827c0d8d4f6d08b693a8/" rel="bookmark">
			mybatis插件开发之 分页插件pagehelper调用原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * Mybatis - 通用分页拦截器&lt;br/&gt; * 项目地址 : http://git.oschina.net/free/Mybatis_PageHelper * * @author liuzh/abel533/isea533 * @version 5.0.0 */ //springboot集成pagehelper项目中的简单分页查询如下： @Override public PageInfo&lt;SysUser&gt; pageUsers(Integer pageNum, Integer pageSize) { PageHelper.startPage(pageNum,pageSize); List&lt;SysUser&gt; list = userMapper.selectAll(); PageInfo pageInfo = new PageInfo(list); return pageInfo; } 一、 PageHelper.startPage(pageNum,pageSize);
这一步是为了提前设置分页参数 ，调用PageHelper的父类PageMethod.startPage （）-&gt;PageMethod.setLocalPage()设置Page参数 到
protected static final ThreadLocal&lt;Page&gt; LOCAL_PAGE = new ThreadLocal&lt;Page&gt;(); 变量中
二、 List&lt;SysUser&gt; list = userMapper.selectAll();
这步会触发分页拦截器PageInterceptor ，执行
public Object intercept(Invocation invocation) throws Throwable { try { Object[] args = invocation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b603df28020d827c0d8d4f6d08b693a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d436a44097385e7fabe42d87e2682439/" rel="bookmark">
			王道数据结构2.3.7——23、删除单链表中绝对值相等的元素，只保留第一个元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路 该题要求时间复杂度尽可能高效，因此牺牲空间换时间。设置辅助数组q[n+1]，初始化为0.遍历单链表，如果出现数字a，则给q[a]赋值为1；若a重复出现，则删除此结点。
代码 void del_same(LinkList &amp;head,int n){ LNode *p=head-&gt;next,*pre=head; if(p==NULL) return; int arr[n+1],m; //初始化辅助数组 for(int i=0;i&lt;arr.length;i++) arr[i]=0; while(p!=NULL){ m=p-&gt;data&gt;=0?p-&gt;data:-p-&gt;data; if(arr[p-&gt;data]==0){ //没出现过 arr[p-&gt;data]=1; pre=p; p=p-&gt;next; }else{ //出现过了 pre-&gt;next=p-&gt;next; free(p);p=pre-&gt;next; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c2994c909099dcb7d8f768eaaadda34/" rel="bookmark">
			Java  Reference核心原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		带着问题，看源码针对性会更强一点、印象会更深刻、并且效果也会更好。所以我先卖个关子，提两个问题(没准下次跳槽时就被问到)。
我们可以用ByteBuffer的allocateDirect方法，申请一块堆外内存创建一个DirectByteBuffer对象，然后利用它去操作堆外内存。这些申请完的堆外内存，我们可以回收吗？可以的话是通过什么样的机制回收的？
大家应该都知道WeakHashMap可以用来实现内存相对敏感的本地缓存，为什么WeakHashMap合适这种业务场景，其内部实现会做什么特殊处理呢？
GC可到达性与JDK中Reference类型 上面提到的两个问题，其答案都在JDK的Reference里面。JDK早期版本中并没有Reference相关的类，这导致对象被GC回收后如果想做一些额外的清理工作(比如socket、堆外内存等)是无法实现的，同样如果想要根据堆内存的实际使用情况决定要不要去清理一些内存敏感的对象也是法实现的。为此JDK1.2中引入的Reference相关的类，即今天要介绍的Reference、SoftReference、WeakReference、PhantomReference，还有与之相关的Cleaner、ReferenceQueue、ReferenceHandler等。与Reference相关核心类基本都在java.lang.ref包下面。其类关系如下
其中，SoftReference代表软引用对象，垃圾回收器会根据内存需求酌情回收软引用指向的对象。普通的GC并不会回收软引用，只有在即将OOM的时候(也就是最后一次Full GC)如果被引用的对象只有SoftReference指向的引用，才会回收。WeakReference代表弱引用对象，当发生GC时，如果被引用的对象只有WeakReference指向的引用，就会被回收。PhantomReference代表虚引用对象(也有叫幻象引用的，个人认为还是虚引用更加贴切)，其是一种特殊的引用类型，不能通过虚引用获取到其关联的对象，但当GC时如果其引用的对象被回收，这个事件程序可以感知，这样我们可以做相应的处理。最后就是最常见强引用对象，也就是通常我们new出来的对象。在继续介绍Reference相关类的源码前，先来简单的看一下GC如何决定一个对象是否可被回收。其基本思路是从GC Root开始向下搜索，如果对象与GC Root之间存在引用链，则对象是可达的，GC会根据是否可到达与可到达性决定对象是否可以被回收。而对象的可达性与引用类型密切相关，对象的可到达性可分为5种。
强可到达，如果从GC Root搜索后，发现对象与GC Root之间存在强引用链则为强可到达。强引用链即有强引用对象，引用了该对象。
软可到达，如果从GC Root搜索后，发现对象与GC Root之间不存在强引用链，但存在软引用链，则为软可到达。软引用链即有软引用对象，引用了该对象。
弱可到达，如果从GC Root搜索后，发现对象与GC Root之间不存在强引用链与软引用链，但有弱引用链，则为弱可到达。弱引用链即有弱引用对象，引用了该对象。
虚可到达，如果从GC Root搜索后，发现对象与GC Root之间只存在虚引用链则为虚可到达。虚引用链即有虚引用对象，引用了该对象。
不可达，如果从GC Root搜索后，找不到对象与GC Root之间的引用链，则为不可到达。
看一个简单的列子：
ObjectA为强可到达，ObjectB也为强可到达，虽然ObjectB对象被SoftReference ObjcetE 引用但由于其还被ObjectA引用所以为强可到达;而ObjectC和ObjectD为弱引用达到，虽然ObjectD对象被PhantomReference ObjcetG引用但由于其还被ObjectC引用，而ObjectC又为弱引用达到，所以ObjectD为弱引用达到;而ObjectH与ObjectI是不可到达。引用链的强弱有关系依次是 强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用，如果有更强的引用关系存在，那么引用链到达性，将由更强的引用有关系决定。
Reference核心处理流程 JVM在GC时如果当前对象只被Reference对象引用，JVM会根据Reference具体类型与堆内存的使用情况决定是否把对应的Reference对象加入到一个由Reference构成的pending链表上，如果能加入pending链表JVM同时会通知ReferenceHandler线程进行处理。ReferenceHandler线程是在Reference类被初始化时调用的，其是一个守护进程并且拥有最高的优先级。Reference类静态初始化块代码如下:
static {
//省略部分代码...
Thread handler = new ReferenceHandler(tg, "Reference Handler");
handler.setPriority(Thread.MAX_PRIORITY);
handler.setDaemon(true);
handler.start();
//省略部分代码...
}
而ReferenceHandler线程内部的run方法会不断地从Reference构成的pending链表上获取Reference对象，如果能获取则根据Reference的具体类型进行不同的处理，不能则调用wait方法等待GC回收对象处理pending链表的通知。ReferenceHandler线程run方法源码:
public void run() {
//死循环，线程启动后会一直运行
while (true) {
tryHandlePending(true);
}
}
run内部调用的tryHandlePending源码:
static boolean tryHandlePending(boolean waitForNotify) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c2994c909099dcb7d8f768eaaadda34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ea99d391d366985c7f3b4c98ef1b88/" rel="bookmark">
			《CBAM: Convolutional Block Attention Module》论文阅读之 Channel Attention 与 Spatial Attention
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了提高神经网络的性能，许多研究都集中在 “depth, width, and cardinality” 上，而本文的重点在 “Attention”。
“注意力机制（Attention mechanism）”听起来很高大上，实际上是关于调整权重的问题，这篇论文提出了一个“即插即用的”的网络结构——CBAM，能够很方便的加到其他的CNN结构中。CBAM利用了通道注意力（channel attention）与空间注意力（spatial attention）。实际上就是在通道（channel）维度上与空间（spatial）维度上对传进来的特征图（intermediate feature map）进行加权处理，权重越大，说明这一通道（channel 维度）或这一点（spatial维度）的信息很重要。如何确定给每一个channel或每一点的权重大小，不同的论文可能会有不同的衡量方法，例如采用均值，例如采用方差等等，这篇论文是通过最大池化（MaxPool）与平均池化（AvgPool）来决定的。
先看Channel Attention，结构如图所示：
Channel Attention 关注的是channel维度。特征图的每个通道被认为是一种特征检测器检测到的特征（每个通道特征由不同的卷积核（Kernel)得到），论文中说的是“what”，就是说哪一个channel比较重要（有用信息多）。对于一个特征图（C*H*W），计算出每个channel的重要性，也就是权值（C*1*1），将权值与特征图相乘得到加权的特征图，就是Channel Attention。权值通过MaxPool与AvgPool计算（为什么是这两个，因为实验结果证明使用这两个比单独地使用其中一个效果要好）。为了获得Channel维度上的权值，需将每一个Channel（1*H*W）压缩成一个数（1*1*1），两种方法：计算每个Channel的平均值（AvgPool）和最大值（MaxPool）。计算完后，将它们通过一个共同的多层感知机MLP（也就是含有一个隐层的全连接网络），MLP的结构是（输入神经元：C，隐层神经元：C/r，输出神经元：C）,再将这两个输出相加，通过sigmoid函数归一化，得到最后的权重。将此权重与原始特征图相乘，得到channel维度上的加权特征图。Channel Attention基本完成。
Spatial Attention 关注的是“where”，就是每一个通道上（1*H*W）哪一点比较重要，因此我们需要生成一个维度为（1*H*W）的空间权重。怎么生成这个权重，同样，我们将不同的channel在同一平面空间点上的值做平均（AvgPool）和取最大值（MaxPool）来获得（1*H*W）的权重。再通过一个卷积层和sigmoid函数来得到最终的权重，将此权重在spatial维度上和每一个channel（1*H*W）相乘，得到spatial维度上的加权特征图。spatial attention基本完成。
最后的问题是按什么顺序给传进来的特征图加上Channel Attention与Spatial Attention。这里有两种思路，（1）并行模型，Channel Attention 与Spatial Attention并行；（2）顺序模型，先让特征图通过Channel Attention再通过Spatial Attention或者相反。实验证明先通过Channel Attention比较好（深度学习有时候就是不讲道理，看结果调）。因此最后的结构如下所示：
原文地址：CBAM: Convolutional Block Attention Module
Official PyTorch code：https://github.com/Jongchan/attention-module
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b32e2c347bf6162d129ebff068f51372/" rel="bookmark">
			vue3.0全家桶实战过程中配置出现的问题解决记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3.0全家桶实战过程中配置出现的问题解决记录 vue.config.js配置别名，跨域，以及端口vue-cli3 取消eslint 校验代码vue router嵌套路由配置中的一些注意点 vue.config.js配置别名，跨域，以及端口 //vue3.0通过前端解决跨域的方式。注意：一定要在项目的根目录下的vue.config.js里面进行配置 const path = require('path') const debug = process.env.NODE_ENV !== 'production' module.exports={ baseUrl: '/', // 根域上下文目录 outputDir: 'dist', // 构建输出目录 assetsDir: 'assets', // 静态资源目录 (js, css, img, fonts) lintOnSave: false, // 是否开启eslint保存检测，有效值：ture | false | 'error' runtimeCompiler: true, // 运行时版本是否需要编译 transpileDependencies: [], // 默认babel-loader忽略mode_modules，这里可增加例外的依赖包名 productionSourceMap: true, // 是否在构建生产包时生成 sourceMap 文件，false将提高构建速度 configureWebpack: config =&gt; { // webpack配置，值位对象时会合并配置，为方法时会改写配置 if (debug) { // 开发环境配置 config.devtool = 'cheap-module-eval-source-map' } else { // 生产环境配置 } Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b32e2c347bf6162d129ebff068f51372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1016a226a1467507f8cd4edc2fdf79b7/" rel="bookmark">
			Quagga简介、安装、配置说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quagga软件原名是Zebra是由一个日本开发团队编写的一个以GNU版权方式发布的软件。可以使用Quagga将linux机器打造成一台功能完备的路由器。
模块化设计：Quagga基于模块化方案的设计，即对每一个路由协议使用单独的守护进程。
运行速度快：因为使用了模块化的设计，使得Quagga的运行速度比一般的路由选择程序要快。
可靠性高：在所有软件模块都失败的情况下，路由器可以继续保持连接并且daemons也会继续运行。故障诊断不必离线的状态下被诊断和更正
支持Ipv6：Quagga不仅支持Ipv4，还支持Ipv6。
Quagga的运行机制
由于Quagga采用模块化的设计，因此Quagga运行时要运行多个守护进程，包括ripd ripngd ospfd ospf6d bgpd 和Zebra。
其中，Zebra守护进程用来更新内核的路由表，而其他的守护进程负责进行相应路由选择协议的路由更新.
就是ripd，bgpd,ospfd三个路由协议守护进程，把通过动态路由协议学习到路由信息都要交给zebra守护进程，然后zebra进程与 kernel routed交互，把路由信息给kernel 内核根据路由协议守护进程学习到路由内容更新自己路由表。
每个守护程序都有自己的路由表。zebra守护程序维护内核路由表，并且还负责在各种路由协议守护程序之间重新分配信息。
关系如图：
安装：
安装依赖软件包
yum install readline-devel (--enable-vtysh需要) 解压：
tar -zxvf *.tar.gz
cd *
配置，生成Makefile文件
./configure --enable-vtysh --enable-user=root --enable-group=root --localstatedir=/var/run/quagga --sysconfdir=/etc/quagga
1
--enable-vtysh 生成vtysh，vtysh是一个可以直接配置其他Quagga进程的shell。不使用vtysh的话，需要telnet到每个进程中去配置，比较麻烦。
--enable-user=root --enable-group=root 默认运行用户为quagga，这里修改为root，可以不用改变文件夹的属性，也不用单独增加用户。
--localstatedir=/var/run/quagga 运行时的PID文件位置
--sysconfdir=/etc/quagga 运行时的配置文件目录，默认位置在/usr/local/etc中
执行./configure后会显示所有的配置清单，可以核对一下。
Quagga configuration
--------------------
quagga version : 0.99.22.4
host operating system : linux-gnu
source code location : .
compiler : gcc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1016a226a1467507f8cd4edc2fdf79b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd551e5d76f34ce1d659c456ad088407/" rel="bookmark">
			IIR递归高斯滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高斯滤波在项目里很常用，尤其是SIFT特征点提取的时候，PCA也要用。
但是原始的高斯滤波是一个二维的卷积，速度很慢。即使采用优化后的分离高斯滤波（先在x方向滤波，然后在y方向滤波），依然不快。
查阅了很多国内外的文献，在项目中实现了递归高斯滤波， 已经量产运行，效果很不错，运行时间是分离高斯滤波的三分之一到四分之一， 也可以运行到MCU里了！！
递归滤波器能近似模拟高斯滤波器，也是分成两次一维滤波，但是不需要设定滤波窗口大小，复杂度跟窗口大小无关，对于一维滤波先进行一次正向滤波，然后进行一次逆向滤波，每次滤波的结果迭代更新。
公式如下：
Forward：
Backward:
代码实现：
typedef struct { gint scale; gint nscales; gint scales_mode; gfloat cvar; } RetinexParams; /* * Calculate the coefficients for the recursive filter algorithm * Fast Computation of gaussian blurring. */ static void compute_coefs3 (gauss3_coefs *c, gfloat sigma) { /* * Papers: "Recursive Implementation of the gaussian filter.", * Ian T. Young , Lucas J. Van Vliet, Signal Processing 44, Elsevier 1995.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd551e5d76f34ce1d659c456ad088407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f4894aee80102bbf85013a98bc3fcf3/" rel="bookmark">
			【弄nèng - Activiti6】Activiti6入门篇（二十三）—— 监听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 任务监听器1.1 简介1.2 流程设计 2. 流程监听器2.1 简介2.2 流程设计 3. 测试3.1 流程图3.2 测试类3.3 运行3.3.1 启动任务 源码地址项目推荐 Activiti监听器分为任务监听器和流程监听器
*后台服务基于Springboot2 + Activiti6，整合文章请参考：https://blog.csdn.net/yy756127197/article/details/101211510 不需要流程设计器就排除3,4步骤 *
1. 任务监听器 1.1 简介 任务监听器实现TaskListener 。
监听器触发时机有4种，包括人物创建事件（create），指定任务代理人事件（assignment），任务完成事件（complete），删除事件（delete）。assignment是在任务创建阶段，优先级大于create。
监听器的设置方式有三种，包括class，expression，delegateExpression。
expression 需要实现Serializable.
delegateExpression 需要实现Serializable, TaskListener
1.2 流程设计 节点任务监听器设置
使用监听器添加任务处理人
任务监听器内容：
import cn.hutool.json.JSONUtil; import org.activiti.engine.delegate.DelegateTask; import org.activiti.engine.delegate.TaskListener; import java.util.Map; /** *个人任务分配监听器 */ public class UserTaskListener implements TaskListener { private static final long serialVersionUID = 1L; public void notify(DelegateTask delegateTask) { // 指定办理人 delegateTask.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f4894aee80102bbf85013a98bc3fcf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff89397b89a5fbef18ba67b5b066d9a6/" rel="bookmark">
			3大常用PCB设计软件AD、PADS、Allegro应该学哪个？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关PCB设计软件很多，主流的设计软件有：Altium Designer、PADS以及Allegro，我要学习的话，应该从哪个软件入门学习，还是说只要学习了其中之一，另外的软件就学得差不多了呢？还是说，我需要全部去学习一遍？
在学习之前，我们有必要对Altium/PADS/Allegro相同和区别、实际应用场景有所了解。
三大常用PCB设计软件，具体都有哪些区别？
我们先来讲一下Altium Designer
Altium软件分析：
Altium软件的市场定位是一些简单的板子，比如单片机类，简单的工业类，一些相对简单的板子，用这个软件比较多，相对是偏低端产品设计，大部分都是简单的板子。大部分用这个软件的公司产品都是相对偏简单的。一般都是 2层，4层为主。在中国市场上，内地城市使用的比较多，发达城市比较少用。基本上可以说在发达城市，使用这个软件，找工作都不好找。但是这个软件，在内地城市使用的占有率很高。
这个软件在内地城市为什么这么高，我个人认为主要是因为这个软件在学校里面的推广做得比较好，因为每个读电子或者机电相关专业的学生在学校里面就有教这个，或者有要求去学这个。所以目前还在用这个软件的工程师，我可以肯定的是超过 80%是因为在学校里面用的，出社会后就继续用了。所以可以说这个软件如果没有中国大学生这一部分的市场，这个软件应该在中国市场上估计就非常少见了。
其次是PADS软件，现在很多大中型企业、沿海发达城市大多都在使用。
PADS软件分析：
PADS的前身是 POWER PCB ，这个软件界面菜单很少，上手不难。我估计也是这一点能得到了市场的认可。特别是消费类电子产品市场占有率非常高，早期都可以说在消费类产品里面差不多是垄断的地位，比如从早期的 VCD、DVD、MP3 、MP4、U盘、液晶电视，到现在的平板电脑、行车记录仪、车载电子产品、导航仪、数字机顶盒、安卓智能电视盒、手机等都是绝对的市场占有率。特别是手机PCB设计，PADS软件几乎占了垄断的优势。
在整个消费类电子产品里面，几乎PADS都占了大头。特别是前几年的市场占有率更是绝对的高。这几年因为allegro 这个软件慢慢的起来了。PADS占有率感觉有所下降的趋势。
但是目前在沿海发达城市里面，PADS还是占主流市场，尤其是深圳大部分公司还是用PADS ，其次是allegro 。PADS找工作在深圳很容易。
再则是Allegro，现在市场占有率上逐年上升。
目前，数字集成电路，正在往高速度、高密度多层板，高效率电路趋势发展，Allegro相比Altium、PADS，设计效率显著提升。
Allegro软件分析：
Cadence Allegro这个软件的优势是功能强大，缺点是不好学，不容易上手。所以这个软件在10年前或者说7-8年前，市场占有率都还比较低，一般只有大公司用，特别是做电脑主板的公司用，因为这个软件功能强大，画大型板子有优势。
如电脑主板，大型工控板，服务器主板，等大型板子，他的效率和优势非常明显。所以他的市场目前主要还是在电脑主板，大型工控板，服务器主板，等这些大型板子上，以及现在一些平板电脑，手机板也会有少量公司用，或者大公司在用。从长远角度来讲，Allegro市场前景比较大。
如何选择对的PCB设计软件？
1）选择一款软件，就要从钻研进去学习
比如：你想要画简单的板子，那么就去学习Altium。想要画消费类电子产品的话，就学习PADS 。想要画大型板子，就去学习Allegro。
如果学PADS 和Allegro以后，你基本上也都是在沿海等发达城市工作，内地城市没这么好找工作。 如果学习Altium，主要就是内地工作，沿海城市用的不多… 当然这个是相对比例而已，就好比深圳用PADS非常多，但是也还是有公司用AD ，只是说非常少而已。 另外，比如你想要学Altium， 就不要想着去画消费类产品。
比如：你学习AD去画行车记录仪，并想去找个画行车记录仪的工作，根本就找不到，根本就没有做行车记录仪的公司用AD这个软件画板。做平板电脑、液晶电视、手机这些产品的也一样，学AD 想要画这种产品，你非常难找工作或者说根本就找不到这类的工作。
2）根据学习用途去选择软件
学习主要是为了工作，所以学习就应该学到合适的东西。比如：学AD也就应该学画一些简单的板子和工业类相对简单的板子，再复杂的板子，比较少公司用 。如果你想画一个液晶电视，行车记录仪的工作，可以选择相对复杂一点的PADS软件。再则，如果你想学画电脑主板、或者大型工控主板，主机服务器之类的，那么推荐你学习一下Allegro。
3）从就业问题和个人定位来选择
目前，PCB设计在中国城市划分，还是有区域性选择的。比如：在大部分内地城市，Altium软件的市场占有率是比较高的。如果你想在内地工作，画一些基本的2、4层板，建议你学习Altium软件，并且在这些地方找工作，是相对比较容易的。
如果你想要在沿海城市，特别是想要在深圳工作，想要画这种消费类产品的话，建议学PADS，这个软件容易上手，而且深圳找工作非常容易。用的公司很多。
如果你想画大型产品板子，建议学Allegro 。这软件目前市场占有率挺高，特别是在大型板子里面占有绝对的优势。学习PCB设计，大部分人都是为了工作。学完后能找到一份好工作，这是每个人的期望。所以想要学哪个设计软件，要自己定位好，因为这个有好几个影响的因素，比如你以后想在哪个城市工作，主要想设计什么产品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c55233b65c98bfbb0464bcdbc50e0ee7/" rel="bookmark">
			es 索引导出导入（elasticsearch-dump） docker方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		elasticsearch-dump提供两种安装方式，如下：
推荐使用docker，不需要解决环境依赖问题。
1、docker 安装 命令：wget -qO- https://get.docker.com/ | sh 2、启动docker
命令：service docker start 3、安装 elasticsearch-dump
命令：docker pull taskrabbit/elasticsearch-dump
到此就安装成功了。
4、使用
Docker install If you prefer using docker to use elasticdump, you can download this project from docker hub :
docker pull taskrabbit/elasticsearch-dump Then you can use it just by :
using docker run --rm -ti taskrabbit/elasticsearch-dumpyou'll need to mount your file storage dir -v &lt;your dumps dir&gt;:&lt;your mount point&gt; to your docker container Example:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c55233b65c98bfbb0464bcdbc50e0ee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e4947947ee50f67a0807edd1e949b6/" rel="bookmark">
			【Deep Learning】空洞卷积(膨胀卷积)解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在阅读SSD网络的时候，看到conv6层中pad=6，且有个参数dilation: 6。在平时没怎么注意到整个参数，今天对其进行记录。
layer { name: "fc6" type: "Convolution" bottom: "pool5" top: "fc6" param { lr_mult: 1.0 decay_mult: 1.0 } param { lr_mult: 2.0 decay_mult: 0.0 } convolution_param { num_output: 1024 pad: 6 kernel_size: 3 weight_filler { type: "xavier" } bias_filler { type: "constant" value: 0.0 } dilation: 6 } } caffe源码中conv_layer.cpp关于空洞卷积的计算：
const int kernel_extent = dilation_data[i] * (kernel_shape_data[i] - 1) + 1; caffe源码中caffe.proto关于dilation的定义：
// Factor used to dilate the kernel, (implicitly) zero-filling the resulting // holes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e4947947ee50f67a0807edd1e949b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678b38d4de6f647691cebbd6e6f2e1de/" rel="bookmark">
			vsftpd 启动异常 (code=exited, status=2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vsftpd 启动异常 root@kali:~# service vsftpd start root@kali:~# service vsftpd status ● vsftpd.service - vsftpd FTP server Loaded: loaded (/lib/systemd/system/vsftpd.service; disabled; vendor preset: disabled) Active: failed (Result: exit-code) since Sat 2019-10-12 10:32:27 CST; 21s ago Process: 2540 ExecStart=/usr/sbin/vsftpd /etc/vsftpd.conf (code=exited, status=2) Process: 2539 ExecStartPre=/bin/mkdir -p /var/run/vsftpd/empty (code=exited, status=0/SUCCESS) Main PID: 2540 (code=exited, status=2) Oct 12 10:32:27 kali systemd[1]: Starting vsftpd FTP server... Oct 12 10:32:27 kali systemd[1]: Started vsftpd FTP server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/678b38d4de6f647691cebbd6e6f2e1de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2abee0105e88df7586bd133ffa8a6572/" rel="bookmark">
			Centos 7.2 swapfile 创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		swap空间不足时，创建swapfile文件增加swap空间
1.登录系统，建议存放swapfile文件到/usr/bin下或者/etc/init.d下， 避免误删除：
cd /usr/bin;
touch swapfile;
chmod 0600 swapfile; （建议权限）
2.使用dd命令创建名为swapfile（1024*3145728=3G）
dd if=/dev/zero of=/usr/bin/swapfile bs=1024 count=3145728
3.swapfile文件转换为swap分区格式并挂载激活分区：
mkswap /usr/bin/swapfile
swapon /usr/bin/swapfile
4.写入/etc/fstab ,开启系统自动挂载：
vi /etc/fstab
/usr/bin/swapfile swap swap defaults 0 0
5.若要删除增加swapfile，命令如下：
停止正在使用swap分区文件:swapoff /usr/bin/swapfile
删除文件及/etc/fstab配置即可：rm /usr/bin/swapfile
6.命令执行，以7G为例：
touch /usr/bin/swapfile
chmod 600 /usr/bin/swapfile
dd if=/dev/zero of=/usr/bin/swapfile bs=1024 count=7340032
mkswap /usr/bin/swapfile
swapon /usr/bin/swapfile
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/636fac0a506a4610367d3d87ac857065/" rel="bookmark">
			给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。
例如:
给定二叉树: [3,9,20,null,null,15,7],
3
/ \
9 20
/ \
15 7
返回其层次遍历结果：
[
[3],
[9,20],
[15,7]
]
来源：力扣（LeetCode）
链接： https://leetcode-cn.com/problems/binary-tree-level-order-traversal/
解题思路：
这个题比以前的层序遍历多了一步操作，那就是在输出的时候按照层序一层一层的输出。我们并不能简单的在打印上按照数字输出比如，第一层输出1个，第二层2个，第三层4个。而是要根据实际的每层有一个元素就输出什么。
回想层序遍历的方法是：将头结点和它的左右孩子节点全部入队，然后打印头节点，头节点出队，在这里我们可以将一个完整的二叉树看成单个的最小二叉树，所以头节点不单单指整个二叉树的头节点，而是每个最小二叉树的头节点。根据队列的特点，先入先出，就可以很好地完成层序遍历。
但是按层序输出是一个问题，可以想到，第一层 队列长度为1，第一层出队之后剩下的是下一层的所有元素，并且根据队列长度可以控制每一行输出的个数。
#include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; class Solution { struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if (!root) { return res; } vector&lt;int&gt; vtmp; /* 层序遍历 ，先将头入队*/ queue&lt;TreeNode*&gt; qu; TreeNode* cur=root; qu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/636fac0a506a4610367d3d87ac857065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1aef2465edb924f4d32a134cd6bd2e8/" rel="bookmark">
			小程序收集箱：批量调节图像曝光度、锐利度、对比度、亮度的demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本程序用于批量调节图像曝光度、锐利度、对比度、亮度，可视化进行，方便找到最佳值。这些参数在应用到其他程序时，需根据程序中乘的系数换算，不然得不到理想效果。
#!/usr/bin/python # -*- coding: utf-8 -*- # python3.7 # author：FistQ # Date: 2019/10/11 import cv2 import numpy as np import os def Contrast_and_Brightness(alpha, beta, img): blank = np.zeros(img.shape, img.dtype) # dst = alpha * img + beta * blank dst = cv2.addWeighted(img, alpha, blank, 1-alpha, beta) return dst def Img_Adjust(GAMMA,SHARPEN, CONTRAST, BRIGHTNESS,img): kernel = np.array([[0, -1, 0], [-1, SHARPEN, -1], [0, -1, 0]], np.float32) # 定义一个核 dst = Contrast_and_Brightness(CONTRAST, BRIGHTNESS, img) res = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1aef2465edb924f4d32a134cd6bd2e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d4d79deb4771abe5e4dcb68c025702/" rel="bookmark">
			markdown&#43;CSDN&#43;Typora&#43;知乎&#43;微信公众号最佳偷懒写作方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
markdown
思想
适用范畴
基本语法
重点语法
高级语法
Typora
补充工具
公式编辑
保存和导出
导入
定制化主题
图片拖拽
超链接
列表
LaTex 公式
表格
生成目录
编辑模式
导出与公众号
md与CSDN
导入
导出
md与知乎
markdown 思想 使用特定的符号来表示相关文本样式
适用范畴 站长，博主
记笔记，写教程
支持实时预览，快捷键，导出为 PDF、图片、HTML 等格式，制作电子书，乃至生成静态博客都可以完成。
基本语法 #标题
在标题前加1-6个#表示1-6级标题
或者ctrl+1-6
文本样式
加粗
**加粗**
斜体
*斜体*
下划线
&lt;&gt;下划线&lt;/u&gt;
删除线
--删除线--
加粗&amp;斜体
***加粗&amp;斜体***
列表
无序列表
* 列表一（在文本前添加*或者-，空格）
有序列表
1. 列表一（在文本前添加1. 空格）
链接
[链接文本]（链接地址）
[百度]（baidu.com）
![链接文本]（链接地址）
![美女1]（D:...）
引用
在文本前添加&gt;
&gt;引用1
&gt;&gt;嵌套引用
重点语法 代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38d4d79deb4771abe5e4dcb68c025702/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40510d3a7f54a95985a2da5f788e348/" rel="bookmark">
			mmdetection源码解读（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面我们零散的了解了mmdetection用到的一些python和PyTorch的知识。
现在我们开始深入算法模型来学习，这个模块我们尝试自定义一个se_resnet50来学习自定义backbone.
在mmdetection/mmdet/models/backbone文件下创建一个senet.py的python文件。
""" ResNet code gently borrowed from https://github.com/pytorch/vision/blob/master/torchvision/models/resnet.py """ from __future__ import print_function, division, absolute_import from collections import OrderedDict from ..registry import BACKBONES from mmcv.runner import load_checkpoint import logging from mmcv.cnn import constant_init, kaiming_init import math import torch.nn as nn from torch.utils import model_zoo __all__ = ['SENet', 'senet154', 'se_resnet50', 'se_resnet101', 'se_resnet152', 'se_resnext50_32x4d', 'se_resnext101_32x4d'] pretrained_settings = { 'senet154': { 'imagenet': { 'url': 'http://data.lip6.fr/cadene/pretrainedmodels/senet154-c7b49a05.pth', 'input_space': 'RGB', 'input_size': [3, 224, 224], 'input_range': [0, 1], 'mean': [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c40510d3a7f54a95985a2da5f788e348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc3323d9a6f8eaf0baaad2c20a1cd44/" rel="bookmark">
			将DLL打包在EXE文件中的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求描述 在C#的项目中，经常会引用一些外部的DLL库。在发布的时候，必需将这些库和可执行程序一起发布，否则会导致程序无法运行。在一些项目中，会有这样的需求：希望发布一个单独的可执行文件，将所引用的DLL文件打包入EXE程序中的方式来实现。
实现原理 想要实现这个库有以下三种方式：
以嵌入的资源将DLL文件打包，然后在运行的时候再释放出来；以嵌入的资源将DLL文件打包，然后在运行时直接加载至内存；其他，比如使用第三方工具打包（比如 这里），或者将DLL单独发布（比如 这里）等。 针对不同的需求可以选择以上三种情况的任意一种。这里介绍第1种和第2种两种方法。在介绍之前，首先了解一下什么是嵌入的资源。
嵌入的资源 在C#的项目中，我们可以添加任意类型的文件，作为一个纯二进制的文件嵌入至项目中，作为资源使用。以下对嵌入资源的添加和使用进行简要说明。
添加嵌入资源
在项目上中点击右键，选择“添加-&gt;现有项”，然后添加所需要的文件。如果要添加任意类型，在弹出的打开对话框中选择“所有文件(*.*)”。然后选中已经添加的文件，在属性窗口中设置“生成操作”的属性为“嵌入的资源”。嵌入资源的路径
已经添加的资源文件，使用绝对路径访问，格式为 [解决方案名称].[文件夹路径].[文件名]。比如在一个名为 Test 的项目中，加入的资源文件 a.dll 在根目录下，则访问路径为 Test.a.dll。如果 a.dll 是放在文件夹下，比如 Resource 目录下，则其路径为 Test.Resource.a.dll，以此类推。使用嵌入资源
在C#中，一个DLL即是一个程序集，使用 System.Reflection.Assembly 类来表示。加载一个程序集可以使用 Assembly.GetExecutingAssembly().GetManifestResourceStream(resourcePath) 来实现，其中 resoucePath 即为DLL的路径。详细操作可参见相关文章。 注意：以上的嵌入资源都是托管的DLL，即是使用.NET创建的类库。如果是非托管的DLL，如使用C++建立的，则不管用。如需要加载非托管DLL，可以使用以下办法：
1）从嵌入的DLL加载字节数据 data；
2）将data写至一个临时文件中；
3）使用 Assembly.LoadFile(path) 进行加载即可。
实现过程 方法1
第1种方法，只需要读取嵌入的资源，然后写到本地即可。以下代码展示了如何从EXE中读取指定的嵌入的资源文件，读取的结果为字节数组，即 byte[] 类型。
public byte[] GetResource(String respath) { System.IO.Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream("Test.a.dll"); byte[] data = new byte[stream.Length]; stream.Read(data, 0, data.Length); return data; } 读取成功后的数据可以直接写回到磁盘保存为dll文件，然后程序即可正常调用。比如，我们可以使用使用 System.IO.File.WriteAllBytes("a.dll", data) 方法来保存读取至的程序目录下，名称为 a.dll。
方法2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc3323d9a6f8eaf0baaad2c20a1cd44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea81996b7eb03ebd55179bb0d8448d6/" rel="bookmark">
			Android入门之简单的ListView和三级联动Spinner
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android入门之简单的ListView和三级联动Spinner 简单的ListViewUI效果图知识点ui代码Java主体 Spinner之简单的三级联动效果图知识点UI代码Java主体 简单的ListView UI效果图 知识点 ListView的ArrayAdapter数组内容插入点击响应Toast ui代码 &lt;ListView android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/list1" &gt;&lt;/ListView&gt; Java主体 public class MainActivity extends AppCompatActivity { private ListView list1; private ArrayAdapter&lt;String&gt;arr_adapter; private SimpleAdapter simple_adapter; private String[] strs = new String[] { "first", "second", "third", "fourth", "fifth","sixth","seventh","eighth" };//定义一个String数组用来显示ListView的内容 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); list1 = findViewById(R.id.list1); arr_adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, strs);//导入strs数组 list1.setAdapter(arr_adapter); //点击响应 list1.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) { Toast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea81996b7eb03ebd55179bb0d8448d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e28a1625b29cbafd6c5c86bd5a0557/" rel="bookmark">
			使用python将很多个exce合并、输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把指定目录下好多长的一样的表纵向连在一起，然后再横向拼接相关信息
使用excel的操作是无数次Ctrl+c，Ctrl+V，若干次Vlookup
import pandas as pd import os
#读取D:\XXX\YYY下面所有的excel文件，这些文件的表头是一样的
for root,dirs,files in os.walk (r"D:\XXX\YYY"):
df_data = pd.DataFrame()
for name in files:
path = os.path.join(root,name)
#print (path) df_temp = pd.read_excel(path)
#print (df_temp)
#拼好的数据存在df_data中
df_data = pd.concat([df_data,df_temp])
#print (df_all)
#ZZZ为另外一张表，和df_data进行横向拼接，类似excel的vlookup
df_shangji = pd.read_excel(r"D:\XXX\ZZZ.xlsx")
#删除zzz和df_data的序号列
df_shangji=df_shangji.drop(["序号"],axis = 1)
df_data=df_data.drop(["序号"],axis = 1)
#以姓名为关键字，拼接
df_data = pd.merge(df_data,df_shangji,on = "姓名")
print(df_data)
df_data.to_excel(excel_writer = r"D:\XXX\AAA.xlsx")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff7d0bd802c31952336acd0c0fefbcb5/" rel="bookmark">
			怎么装python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的机器：win10 64位
1.下载合适的python版本
https://www.python.org/downloads/——这里有很多版本可以下载，开始我装的是最新的3.7，悲剧的是想打包成exe时，死活不行，后来下载了3.6才算搞定
2.根据需要安装编辑器
编辑器开始装的Jupyter Notebook，编辑和运行也没有问题，打包时，需要将.ipynb另存为.py文件，也是很不方便，后来装了pycharm（下载地址：http://www.jetbrains.com/pycharm/）才搞定
后面我会按顺序讲已经完成的程序和如何打包写出来。
当然可能因为初学，可能很多诀窍没掌握，这里只是记录一下我的工作过程，更多是跟excel结合的使用，本地应用偏多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1843aff2f679f1f927f57253cd55da/" rel="bookmark">
			深浅层特征融合——CBNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本系列博客“深浅层特征融合”对几篇出现较新的深浅层特征融合算法进行简要介绍，多为本人的论文笔记，记录了一个深度学习小学生在看论文时想到的问题。
论文题目：CBNet: A Novel Composite Backbone Network Architecture for Object Detection
论文链接：https://arxiv.org/pdf/1909.03625.pdf
github地址：https://github.com/PKUbahuangliuhe/CBNet
整体介绍 这篇论文来自北大，2019年9月发表，时间很新。
研究背景：作者认为当前基于深度学习的目标检测算法中，负责进行特征提取的backbone网络，其最初的设计目的大多是为了图像分类。利用这些网络提取的特征直接进行不同数据集的目标检测任务时，可能不会达到最优效果。
研究方法：直接设计一个新的backbone并预训练又很慢很艰难，因此作者以对现有的backbone进行融合作为研究出发点
特征融合算法：对多个同结构不同参数的backbone网络并列，横向地沿一个方向对相邻backbone的各个阶段特征进行整合，仅采用最末端的backbone网络所提取的特征进行后续目标检测或语义分割任务。
算法介绍 本文提出的backbone融合的思想很好理解，单看下图就能理解：
这样融合的好处是，Lead Backbone相比于传统单一backbone，每个阶段提取的特征，包含了一些多次经过某阶段卷积核提取出的特征，可以粗糙理解为该阶段该的卷积核反复通过了好几次（不过不同backbone同一阶段的weight也不同，并且进行composite融合前也进行了upsample操作，不是简单地重复该层）。
对比实验 不同composite方式对比 作者对比了相邻backbone之间不同composite方式的效果差异，最终发现“左high-level+右low-level”的形式效果最好，在对几种composite方式的效果进行对比并尝试分析理由时，个人觉得有点牵强。仅从文章中我还是不太能理解为什么“左high-level+右low-level”就能让后者get enhanced，“左low-level+右high-level”就能让后者get harmed。也欢迎和大家讨论。
backbone个数的对比 作者通过实验发现，随着backbone个数的增长，整体效果都是在提高的，但随之而来的memory cost也不容忽视。最终作者建议采用2或3个backbone。
两个backbone会令model size扩充到原先的不到两倍（图中的mb）：
问题记录 以下问题是作者看论文是脑子里蹦出来的所有问题，适合小白日常修补知识漏洞。
关于本文的问题：
QA关于benchmark怎样理解？ identical backbone的identical?只表示结构一样，weight不同 将CBNet和RCNN对比时，为什么用RCNN作为detector的backbone就需要再预训练？
一般upsample都有什么操作？upsample除了维度上的作用，还有别的用途吗？
one stage方法的backbone为什么不保持一样？
本文以外的问题：
QAResNet and ResNeXt 新提出的一些目标检测算法需要看
DetNet 、FishNet？特征为目标检测设计的backbone和普通针对图像分类初衷的backbone有何区别？
RCNN？
FPN、RPN？ Detectron?
hrnet?分辨率维持不变 学习率warm up soft-NMS? 目标检测几个指标的具体算法
single\multi-scale training\inference?
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ce60c1433219bbc3b84ea89978606c/" rel="bookmark">
			老卫带你学---VMware Workstation 不可恢复错误: (vcpu-0) vcpu-0:VERIFY vmcore/vmm/main/cpuid.c:386 bugNr=1036521”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老卫最近在新电脑上搭建hadoop虚拟机；
可是在搭建虚拟机的时候出现这样的问题：
VMware Workstation 不可恢复错误: (vcpu-0) vcpu-0:VERIFY vmcore/vmm/main/cpui...... 后来通过了解，原来是因为自身新电脑的bios设置问题，下面是解决方案。
出现 “VMware Workstation 不可恢复错误: (vcpu-0) vcpu-0:VERIFY vmcore/vmm/main/cpuid.c:386 bugNr=1036521” :
解决办法是需要将电脑的CPU进行虚拟化设置， 需要根据不同的电脑主板 进去BIOS里面进行设置， 我的是 华硕主板，步骤如下：开机时狂按F2-----寻找SVM Mode , 将此模式 开启 ------按F10保存退出；
成功创建虚拟机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444b1a7962c6427e126b3b2e29c27aea/" rel="bookmark">
			AndroidX下的两个坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、butterknife等依赖引发的坑：
The given artifact contains a string literal with a package reference 'android.support.v4.content' that cannot be safely rewritten. Libraries using reflection such as annotation processors need to be updated manually to add support for androidx. 该原因可以这样理解：是引用的依赖版本比较老，未适配Androidx，将butterknife版本更新到最新版本10.0.0即可
二、Androidx的运行环境Java JDK版本的坑：
Static interface methods are only supported starting with Android N (--min-api 24): void butterknife.Unbinder.lambda$static$0() 提示的意思是 AndroidStudio中minSdkVersion最小值应为24，其实将24改为26后编译运行，发现，继续提示上面的错误，不同的是24变成26了。但是由于App 肯定不能只适配 8.0以上的设备 , 所以还得另寻方法
最后发现这问题都是因为没有指定jdk 1.8而产生的
在app build:gradle 中的android 下添加 指定jdk版本的代码,如下:
android { ...... //指定Java运行环境jdk版本 compileOptions { sourceCompatibility JavaVersion.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/444b1a7962c6427e126b3b2e29c27aea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5002783ea4dc17f5b1126b75a676c91/" rel="bookmark">
			Qt 绘图设备，QPixmap 和QImage 相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt的绘图系统允许使用相同的API在屏幕和其他打印设备上进行绘制。整个绘图系统基于 QPainter，QPainterDevice 和 QPaintEngine三个类。
QPainter用来执行绘制的操作；QPaintDevice是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的时间；QPaintEngine提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心QPaintEngine这个类的。我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕等；而对于纸张、屏幕而言，肯定要使用不同的画笔绘制，为了统一使用一种画笔，我们设计了QPaintEngine类，这个类让不同的纸张、屏幕都能使用一种画笔。
如图，明确标明了这三个类之间的层次关系：
Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，他们之间使用QPaintEngine 进行通讯（也就是翻译QPainterDevice的指令）。
绘图设备
QPixmap：专门为图像在屏幕上的显示做了优化
QBitmap：是QPixmap的一个子类，它的色深限定为1，可以使用QPixmap的 isQBitmap() 函数来确定这个QPixmap是不是一个QBitmap。
QImage：专门为图像的像素级访问做了优化
QPicture：则可以记录和重视QPainter的各种命令
/* Widget.h */ class Widget : public QWidget { Q_OBJECT public: explicit Widget(QWidget *parent = 0); ~Widget(); //重写paintEvent()函数 protected: void paintEvent(QPaintEvent *event); private: Ui::Widget *ui; }; /* Widget.cpp */ void Widget::paintEvent(QPaintEvent *event) { QPainter p(this); QPixmap pixmap; pixmap.load("../Image/face.png"); //QPixmap -&gt; QImage QImage tempImage = pixmap.toImage(); p.drawImage(0,0,tempImage); QImage image; image.load("../Image/face.png"); //QImage -&gt; QPixmap QPixmap tempPixmap = QPixmap::fromImage(image); p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5002783ea4dc17f5b1126b75a676c91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d406fee2e068ab8c141f7f767c49e5b/" rel="bookmark">
			Spring表达式语言:SpEL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
Spring表达式语言(简称SpEL):是一个支持运行时查询和操作对象图的强大的表达式语言。语法类似EL:SpEL使用#{…}作为定界符，所有在大括号中的字符都将被认为SpEL。SpEL为bean属性的动态赋值提供了便利。
通过 SpEL 可以实现：
通过 bean 的 id 对 bean 进行引用
调用方法以及引用对象中的属性
计算表达式的值
正则表达式的匹配
1.字面量的赋值
&lt;!--整数--&gt; &lt;property name="count" value="#{5}"/&gt; &lt;!--小数--&gt; &lt;property name="frequency" value="#{1.2}"&gt; &lt;!--科学计数法--&gt; &lt;property name="capacity" value="#{le4}"/&gt; &lt;!--String 可以使用单引号或者双引号作为字符串的定界符号--&gt; &lt;property name="name" value="#{'Tom'}"/&gt;或者是 &lt;property name="name" value='#{"Tom"}'/&gt; &lt;!--Boolean--&gt; &lt;property name="flag" value="#{false}"/&gt; 2.引用其他对象
3.SpEL支持的运算符号
算数运算符：+,-,*,/,%,^
加号还可以作为字符串连接
&lt;property name="infor" value="#{'name= '+'Tome'}"/&gt; 比较运算符
&lt;property name="equal" value="#{couter.total == 100}" /&gt; 逻辑运算符:and,or,not,|
&lt;property name="aaa" value="#{shape.kind =='circle' and shape.price ==1000}"/&gt; &lt;property name="bb" value="!shape.isAvailable"/&gt; &lt;property name="cc" value="not shape.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d406fee2e068ab8c141f7f767c49e5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e280090507f986f51b4adcfe18b1b5d/" rel="bookmark">
			linux中yum无法下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux默认的yum源由于连接的是国外的源，所以无法下载，因此需要改成国内的yum源。
进入/etc/yum.resp.d/，然后修改CentOS-Base.repo文件的内容为下面的：
# CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e280090507f986f51b4adcfe18b1b5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bfd0869db83b8ababb95549588204df/" rel="bookmark">
			SQL Review: 复习 SELECT 查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复习SELECT查询语法 SELECT column, another_column, … FROM mytable WHERE condition(s) ORDER BY column ASC/DESC LIMIT num_limit OFFSET num_offset; 练习 正如实际工作中，最大的变化不是SQL语法，而是实际数据的表结构和数据。在本节练习中，我们会放出一个新的表，简单介绍一下这个表，这个表存储了北美一些城市的人口信息和经纬度地理位置信息， 信息.
小贴士
在这个数据表中，你需要熟悉一下latitudes（纬度）和 longitudes（经度）的概念， latitudes在赤道以北是正数，以南是负数；longitudes在子午线东部是正数，以西是负数， 在查询中需要注意 经纬度和东西南北方向的对应关系。
试一下按Task任务中的要求，来组合应用之前学到的查询知识. 如果你成功的解决了这些查询问题，那么就可以继续学习 多表数据查询这个主题了。
Table(表）: North_american_cities
CityCountryPopulationLatitudeLongitudeGuadalajaraMexico150080020.659699-103.349609TorontoCanada279506043.653226-79.383184HoustonUnited States219591429.760427-95.369803New YorkUnited States840583740.712784-74.005941PhiladelphiaUnited States155316539.952584-75.165222HavanaCuba210614623.05407-82.345189Mexico CityMexico855550019.432608-99.133208PhoenixUnited States151336733.448377-112.074037Los AngelesUnited States388430734.052234-118.243685Ecatepec de MorelosMexico174200019.601841-99.050674MontrealCanada171776745.501689-73.567256ChicagoUnited States271878241.878114-87.629798 练习 do it — 请完成如下任务
1.列出所有加拿大Canadian城市的信息(包括所有字段) SELECT * FROM north_american_cities
where Country like "Canada"
2.列出所有美国United States的城市按纬度从北到南排序(包括所有字段) SELECT * FROM north_american_cities
where Country like "United States"
order by Latitude desc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bfd0869db83b8ababb95549588204df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f603c6948238d99da59dd7f6961cd1/" rel="bookmark">
			终于有人把“人工智能”讲明白是怎么回事了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们正站在变革的边缘，而这次变革将和人类的出现一般意义重大 – Vernor Vinge。如果你站在这里，你会是什么感觉？
看上去非常刺激吧？但是你要记住，当你真的站在时间的图表中的时候，你是看不到曲线的右边的，因为你是看不到未来的。所以你真实的感觉大概是这样的：
稀松平常。
-------------------------------
遥远的未来——就在眼前
想象一下坐时间机器回到1750年的地球，那个时代没有电，畅通通讯基本靠吼，交通主要靠动物拉着跑。你在那个时代邀请了一个叫老王的人到2015年来玩，顺便看看他对“未来”有什么感受。我们可能没有办法了解1750年的老王内心的感受——金属铁壳在宽敞的公路上飞驰，和太平洋另一头的人聊天，看几千公里外正在发生进行的体育比赛，观看一场发生于半个世纪前的演唱会，从口袋里掏出一个黑色长方形工具把眼前发生的事情记录下来，生成一个地图然后地图上有个蓝点告诉你现在的位置，一边看着地球另一边的人的脸一边聊天，以及其它各种各样的黑科技。别忘了，你还没跟他解释互联网、国际空间站、大型强子对撞机、核武器以及相对论。
这时候的老王会是什么体验？惊讶、震惊、脑洞大开这些词都太温顺了，我觉得老王很可能直接被吓尿了。
但是，如果老王回到了1750年，然后觉得被吓尿是个很囧的体验，于是他也想把别人吓尿来满足一下自己，那会发生什么？于是老王也回到了250年前的1500年，邀请生活在1500年的小李去1750年玩一下。小李可能会被250年后的很多东西震惊，但是至少他不会被吓尿。同样是250来年的时间，1750和2015年的差别，比1500年和1750年的差别，要大得多了。1500年的小李可能能学到很多神奇的物理知识，可能会惊讶于欧洲的帝国主义旅程，甚至对于世界地图的认知也会大大的改变，但是1500年的小李，看到1750年的交通、通讯等等，并不会被吓尿。
所以说，对于1750年的老王来说，要把人吓尿，他需要回到更古老的过去——比如回到公元前12000年，第一次农业革命之前。那个时候还没有城市，也还没有文明。一个来自狩猎采集时代的人类，只是当时众多物种中的一个罢了，来自那个时代的小赵看到1750年庞大的人类帝国，可以航行于海洋上的巨舰，居住在“室内”，无数的收藏品，神奇的知识和发现——他很有可能被吓尿。
小赵被吓尿后如果也想做同样的事情呢？如果他会到公元前24000年，找到那个时代的小钱，然后给他展示公元前12000年的生活会怎样呢。小钱大概会觉得小赵是吃饱了没事干——“这不跟我的生活差不多么，呵呵”。小赵如果要把人吓尿，可能要回到十万年前或者更久，然后用人类对火和语言的掌控来把对方吓尿。
所以，一个人去到未来，并且被吓尿，他们需要满足一个“吓尿单位”。满足吓尿单位所需的年代间隔是不一样的。在狩猎采集时代满足一个吓尿单位需要超过十万年，而工业革命后一个吓尿单位只要两百多年就能满足。
进步越来越大，发生的越来越快，也就是说我们的未来会很有趣对吧？
未来学家Kurzweil认为整个20世纪100年的进步，按照2000年的速度只要20年就能达成——2000年的发展速度是20世纪平均发展速度的5倍。他认为2000年开始只要花14年就能达成整个20世纪一百年的进步，而之后2014年开始只要花7年（2021年），就能达到又一个20世纪一百年的进步。几十年之后，我们每年都能达成好几次相当于整个20世纪的发展，再往后，说不定每个月都能达成一次。按照加速回报定，Kurzweil认为人类在21世纪的进步将是20世纪的1000倍。
如果Kurzweil等人的想法是正确的，那2030年的世界可能就能把我们吓尿了——下一个吓尿单位可能只需要十几年，而2050年的世界会变得面目全非。
你可能觉得2050年的世界会变得面目全非这句话很可笑，但是这不是科幻，而是比你我聪明很多的科学家们相信的，而且从历史来看，也是逻辑上可以预测的。
那么为什么你会觉得“2050年的世界会变得面目全非” 这句话很可笑呢？有三个原因让你质疑对于未来的预测：
1. 我们对于历史的思考是线性的。当我们考虑未来35年的变化时，我们参照的是过去35年发生的事情。当我们考虑21世纪能产生的变化的时候，我们参考的是20世纪发生的变化。这就好像1750年的老王觉得1500年的小李在1750年能被吓尿一样。线性思考是本能的，但是但是考虑未来的时候我们应该指数地思考。一个聪明人不会把过去35年的发展作为未来35年的参考，而是会看到当下的发展速度，这样预测的会更准确一点。当然这样还是不够准确，想要更准确，你要想象发展的速度会越来越快。
2. 近期的历史很可能对人产生误导。首先，即使是坡度很高的指数曲线，只要你截取的部分够短，看起来也是很线性的，就好像你截取圆周的很小一块，看上去就是和直线差不多。其次，指数增长不是平滑统一的，发展常常遵循S曲线。
S曲线发生在新范式传遍世界的时候，S曲线分三部分
- 慢速增长（指数增长初期）
- 快速增长（指数增长的快速增长期）
- 随着新范式的成熟而出现的平缓期
如果你只看近期的历史，你很可能看到的是S曲线的某一部分，而这部分可能不能说明发展究竟有多快速。1995-2007年是互联网爆炸发展的时候，微软、谷歌、脸书进入了公众视野，伴随着的是社交网络、手机的出现和普及、智能手机的出现和普及，这一段时间就是S曲线的快速增长期。2008-2015年发展没那么迅速，至少在技术领域是这样的。如果按照过去几年的发展速度来估计当下的发展速度，可能会错得离谱，因为很有可能下一个快速增长期正在萌芽。
3. 个人经验使得我们对于未来预期过于死板。我们通过自身的经验来产生世界观，而经验把发展的速度烙印在了我们脑中——“发展就是这么个速度的。”我们还会受限于自己的想象力，因为想象力通过过去的经验来组成对未来的预测——但是我们知道的东西是不足以帮助我们预测未来的。当我们听到一个和我们经验相违背的对于未来的预测时，我们就会觉得这个预测偏了。如果我现在跟你说你可以活到150岁，250岁，甚至会永生，你是不是觉得我在扯淡——“自古以来，所有人都是会死的。”是的，过去从来没有人永生过，但是飞机发明之前也没有人坐过飞机呀。
接下来的内容，你可能一边读一边心里“呵呵”，而且这些内容可能真的是错的。但是如果我们是真的从历史规律来进行逻辑思考的，我们的结论就应该是未来的几十年将发生比我们预期的多得多得多得多的变化。同样的逻辑也表明，如果人类这个地球上最发达的物种能够越走越快，总有一天，他们会迈出彻底改变“人类是什么”这一观点的一大步，就好像自然进化不不断朝着智能迈步，并且最终迈出一大步产生了人类，从而完全改变了其它所有生物的命运。如果你留心一下近来的科技进步的话，你会发现，到处都暗示着我们对于生命的认知将要被接下来的发展而彻底改变。
_______________
通往超级智能之路
人工智能是什么？
如果你一直以来把人工智能（AI）当做科幻小说，但是近来却不但听到很多正经人严肃的讨论这个问题，你可能也会困惑。这种困惑是有原因的：
1.我们总是把人工智能和电影想到一起。星球大战、终结者、2001：太空漫游等等。电影是虚构的，那些电影角色也是虚构的，所以我们总是觉得人工智能缺乏真实感。
2.人工智能是个很宽泛的话题。从手机上的计算器到无人驾驶汽车，到未来可能改变世界的重大变革，人工智能可以用来描述很多东西，所以人们会有疑惑。
3.我们日常生活中已经每天都在使用人工智能了，只是我们没意识到而已。John McCarthy，在1956年最早使用了人工智能（Artificial Intelligence）这个词。他总是抱怨“一旦一样东西用人工智能实现了，人们就不再叫它人工智能了。”
因为这种效应，所以人工智能听起来总让人觉得是未来的神秘存在，而不是身边已经存在的现实。同时，这种效应也让人们觉得人工智能是一个从未被实现过的流行理念。Kurzweil提到经常有人说人工智能在80年代就被遗弃了，这种说法就好像“互联网已经在21世纪初互联网泡沫爆炸时死去了”一般滑稽。
所以，让我们从头开始。
首先，不要一提到人工智能就想着机器人。机器人只是人工智能的容器，机器人有时候是人形，有时候不是，但是人工智能自身只是机器人体内的电脑。人工智能是大脑的话，机器人就是身体——而且这个身体不一定是必需的。比如说Siri背后的软件和数据是人工智能，Siri说话的声音是这个人工智能的人格化体现，但是Siri本身并没有机器人这个组成部分。
其次，你可能听过“奇点”或者“技术奇点”这种说法。这种说法在数学上用来描述类似渐进的情况，这种情况下通常的规律就不适用了。这种说法同样被用在物理上来描述无限小的高密度黑洞，同样是通常的规律不适用的情况。Kurzweil则把奇点定义为加速回报定律达到了极限，技术进步以近乎无限的速度发展，而奇点之后我们将在一个完全不同的世界生活的。但是当下的很多思考人工智能的人已经不再用奇点这个说法了，而且这种说法很容易把人弄混，所以本文也尽量少用。
最后，人工智能的概念很宽，所以人工智能也分很多种，我们按照人工智能的实力将其分成三大类。
弱人工智能Artificial Narrow Intelligence (ANI): 弱人工智能是擅长于单个方面的人工智能。比如有能战胜象棋世界冠军的人工智能，但是它只会下象棋，你要问它怎样更好地在硬盘上储存数据，它就不知道怎么回答你了。
强人工智能Artificial General Intelligence (AGI): 人类级别的人工智能。强人工智能是指在各方面都能和人类比肩的人工智能，人类能干的脑力活它都能干。创造强人工智能比创造弱人工智能难得多，我们现在还做不到。Linda Gottfredson教授把智能定义为“一种宽泛的心理能力，能够进行思考、计划、解决问题、抽象思维、理解复杂理念、快速学习和从经验中学习等操作。”强人工智能在进行这些操作时应该和人类一样得心应手。
超人工智能Artificial Superintelligence (ASI): 牛津哲学家，知名人工智能思想家Nick Bostrom把超级智能定义为“在几乎所有领域都比最聪明的人类大脑都聪明很多，包括科学创新、通识和社交技能。”超人工智能可以是各方面都比人类强一点，也可以是各方面都比人类强万亿倍的。超人工智能也正是为什么人工智能这个话题这么火热的缘故，同样也是为什么永生和灭绝这两个词会在本文中多次出现。
现在，人类已经掌握了弱人工智能。其实弱人工智能无处不在，人工智能革命是从弱人工智能，通过强人工智能，最终到达超人工智能的旅途。这段旅途中人类可能会生还下来，可能不会，但是无论如何，世界将变得完全不一样。
让我们来看看这个领域的思想家对于这个旅途是怎么看的，以及为什么人工智能革命可能比你想的要近得多。
我们现在的位置——充满了弱人工智能的世界
现在的弱人工智能系统并不吓人。最糟糕的情况，无非是代码没写好，程序出故障，造成了单独的灾难，比如造成停电、核电站故障、金融市场崩盘等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98f603c6948238d99da59dd7f6961cd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd967144ddbfd60f1251cd830fc01ea6/" rel="bookmark">
			natapp在linux服务器上的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发时可能会有这样的需求：
需要将自己开发的机器上的应用提供到公网上进行访问，但是并不想通过注册域名、搭建服务器等等一系列繁琐的操作来实现。
例如：微信公众号的开发调试就需要用到域名访问本机项目。 这时就可以通过将局域网映射到公网来实现，说得专业一点就是：内网穿透。
下面将介绍通过natapp这个软件来实现，并且是免费使用。只需要注册一个账号，然后实名认证后就能使用。
原文地址：
https://www.cnblogs.com/poterliu/p/9512615.html 1、注册natapp账号
到natapp官网注册一个账号，然后实名认证，因为涉及到项目的合法性，所以必须要求实名制，这个没毛病。
官网地址：https://natapp.cn/
到注册页面
链接：https://natapp.cn/register
注册步骤很简单，只需要填该填的信息就对了，要记住使用的手机号和密码，方便下次使用。
2、实名制
必须要实名才能使用natapp的穿透服务，账户信息的姓名后有 立即进行实名认证 的链接，点击开始实名认证。
账户信息链接：https://natapp.cn/member/dashborad
实名制链接：https://natapp.cn/member/realNameVerify
实名认证后的界面如下
3、 购买免费隧道
这里写的是购买，但是其实是免费的。
进入购买界面，点击 免费隧道。
链接：https://natapp.cn/tunnel/buy
再点击 免费购买
这样就算购买成功了，注意：每个用户可以免费获取两个不同隧道协议的隧道。 默认购买web协议的隧道。
4、配置 我的隧道
购买成功进入 我的隧道 页面。
链接：https://natapp.cn/tunnel/lists
页面上的重要信息有：
authtoken：开启natapp服务时用到的参数
隧道协议：该隧道使用的协议类型
点击配置按钮进入配置页面。
主要是修改需要映射的本地ip和端口号。
修改完记得保存。
5、下载natapp并启动natapp服务
natapp下载地址就是官网：https://natapp.cn/#download
如图
然后通过控制台来启动natapp服务，先通过控制台进入到下载natapp软件的位置，
Windows
确保执行命令的目录下存在natapp.exe
执行启动命令：
natapp -authtoken=authtoken
Linux
进入解压目录，我的zip文件放在 /usr/local/natapp 下
先进行解压 unzip natapp_linux_amd64_2_3_9.zip
配置权限
chmod a+x natapp
启动命令
./natapp -authtoken=authtoken
如果要后台运行，可执行以下命令（但尚未知道从哪里查看随机生成的域名）
nohup ./natapp -authtoken=authtoken -log=stdout &amp;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd967144ddbfd60f1251cd830fc01ea6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be565ac71e99065f6399b6df366f952/" rel="bookmark">
			Intouch 制作自定义登录弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在新的自动化项目中，因为业主对设计审美要求比较高，对Intouch自带脚本呼出登录窗体不满意，故而制作自定义登录弹窗来满足其审美需求。在寻求自控群前辈的经验下，将其整理成博客，供大家参考。
1.登录窗体制作 利用网上现成的图片，或者由美工先做出登录框架，添加用户名和密码Textbox。Textbox利用Microsoft Form 2.0 Textbox，因为其功能比intouch自带的更丰富可以设置密码格式***，导入方法的话，首先安装一个32位office破解版，然后intouch向导导入安装Microsoft Form 2.0 Textbox即可。
2.后台脚本编写 在用户名和密码位置放置好textbox后，对Textbox属性进行相应设置，达到验证用户名和密码有效性的目的。然后对登录按钮进行后台脚本编写即可。具体如下：
用户名textbox属性设置
密码框属性设置
其中P1初始值为*，设置为*的目的为将其P1值返回为*代替。
确认按钮脚本制作：
$OperatorEntered=o; $PasswordEntered=p; if $operator==o then P=""; eles TEXT1="用户名或密码错误"; endif; 3.补充（用户名/密码错误） 在用户名或密码错误情况下，对其进行提示，并在一段时间后自动消失。具体实现如下：
先将如下红字动画链接字符串：TEXT1,以及可见性。
至此，初步完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac0af797bd8ef78aab3afe1cab203e82/" rel="bookmark">
			Flask 路由和URL传参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制器文件IndexController.py
from flask import Flask; app = Flask(__name__); # 不区分URL最后的斜杠 app.strict_slashes = False; @app.route('/flask') def hello_flask(): return 'Hello Flask'; @app.route('/python/') def hello_python(): return 'Hello Python'; # URL传参 # 参数格式:&lt;type:variableName&gt;, type默认为string @app.route('/blog/&lt;int:postID&gt;') def show_blog(postID): return 'Blog Number %d' % postID; if __name__ == '__main__': app.run('0.0.0.0', 8080, debug = True); 运行
$ python IndexController.py * Restarting with stat * Debugger is active! * Debugger PIN: 158-818-550 * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit) 使用浏览器访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac0af797bd8ef78aab3afe1cab203e82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13af4ff7378c8fdbd282a4cc21c0b6db/" rel="bookmark">
			华为手机打开调试模式adb连接电脑的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://club.huawei.com/thread-15094024-1-1.html
做android客户端开发，需要用真机测试。但是EMUI5.1很难连接上电脑。
经过一番研究，终于找到解决方案；现在分享给大家，减少大家的摸索时间。
(1) adb驱动；
如果没有安装，在手机连接电脑时，下载驱动人生软件来安装adb驱动；
(2) 开发者选项打开；
打开的方法：设置---关于手机---连续点击“版本号”，即可以打开 ；
(3) “选择USB配置”选项为“仅充电”模式，
这个选项在开发者选项中；向下拉就能找到。
(4) “USB调试打开；
这个选项也是在开发者选项中。
注意：上面四个步骤顺序，234是不能乱的，必须先设置为”仅充电”模式，然后再打开“调试模式”，这样才能正常连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3261904ff0ca1fbe18753880bfc65da3/" rel="bookmark">
			Microsoft Excel 出现错误。很抱歉，您的Office安装无法正常工作，请使用控制面板中的“程序与功能”选项修复您的产品。您也可以联机查找更多帮助。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 在打开Microsoft Excel时，总是弹出警告（如上图所示）。
问题解决： 在网上找了一些资料说大部分说这个问题是由于WPS没有完全卸载引起的，要完全卸载，包括其配置文件等等。但经过大量查找，在一个百度经验上，看到一个不用卸载WPS的解决方法，在此分享。
1.在桌面左下角点击“开始”图标。在弹出窗口，（有的菜单设置不同，在老式菜单的从所有程序中找）找到 “WPS Office” 菜单并点击。在WPS Office”子窗口中，点击 “配置工具”。
2.点击高级。
3.在“WPS配置工具”窗口中，找到“WPS Office 兼容第三方系统和软件“选项并取消选中。
4.若此时点击确定，重启Excel，就已经没有警告了，但此时你电脑上仍安装有WPS，此时打开Word、Excel、PowerPoint文档，以默认WPS方式打开。并在打开Excel时，有下图提示：
5.若想解决此提示，需要把WPS Office 配置工具种的以下复选框全部取消，点击确定即可。
后言： 之后你会发现，你电脑上的文档，全部更新为Office打开方式（包括WPS建立的文档），这个。。。，看自己需要吧，如果主要用WPS 可以取消步骤5。如果主要用Office，那就执行步骤5。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0111e1e87eff3893f19b23325bcb732/" rel="bookmark">
			No module named cv2 报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行python脚本出现“No module named cv2 ”，这时我们安装下opencv-python依赖即可
python3 -m pip install opencv-python 转载于:https://www.cnblogs.com/yinliang/p/11628374.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33e581efdbc2e3c250c8c38d31ce58e/" rel="bookmark">
			kubenetes 1.16.0安装kubernetes-dashboard v2.0.0-beta4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kubenetes github ：https://github.com/kubernetes/dashboard/releases
kubenetes官网：https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/
本人安装kubenetes 1.16.0，刚开始使用kubernetes-dashboard v1.10.1安装后，首页访问接口报错404，怀疑是版本不兼容问题。后面发现kubernetes-dashboard最新版本已经是v2.0.0-beta4。并且kubenetes官方文档安装dashboard的描述，指明部署方法
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yaml https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yaml
所以kubenetes v1.16.0 应该使用新版dashboard ui才兼容
查看github，用到的镜像有两个dashboard:v2.0.0-beta4、metrics-scraper:v1.0.1
kubernetesui/dashboard:v2.0.0-beta4 kubernetesui/metrics-scraper:v1.0.1 先拉取镜像，本人使用的docker版本19.03.2
docker pull kubernetesui/dashboard:v2.0.0-beta4 kubernetesui/metrics-scraper:v1.0.1 拉成功后
获取yaml文件
https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yaml 修改recommended.yaml文件，为了方便访问，修改kubernetes-dashboard的Service定义，指定Service的type类型为NodeType，指定nodePort端口
kind: Service apiVersion: v1 metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboard spec: type: NodePort # 改成NodePort ports: - port: 443 targetPort: 8443 nodePort: 31001 # 指定nodePort端口 selector: k8s-app: kubernetes-dashboard 注：dashboard-metrics-scraper的Service不需要修改 从配置文件可以看到，它还创建了ServiceAccount帐号
apiVersion: v1 kind: ServiceAccount metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboard 还创建了ClusterRoleBinding
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a33e581efdbc2e3c250c8c38d31ce58e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/391/">«</a>
	<span class="pagination__item pagination__item--current">392/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/393/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>