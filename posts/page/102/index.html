<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58dab4bf1d7828ce8932684995634b9/" rel="bookmark">
			多线程并发和多任务并行的小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、多线程并行的一点小结 1.无论是thread::spawn还是tokio::spawn,都是创建一个线程或者任务去执行闭包的函数体。thread::spawn接受一个闭包作为参数，并返回一个 JoinHandle，其中 T 是闭包的返回类型。创建的新线程将在后台运行，并执行闭包中的代码。
2.多线程并行：其他的高级语言可以实现并行，会有额外的运行时来进行多线程调度，耗费时间。C/C++没有额外的运行时，速度快但是不安全，手动保证线程安全。Rust没有多线程运行时，但是可以利用所有权等特征在编译时消除不安全代码。
3.多线程并行：move闭包通常和thread::spawn函数一起使用，闭包move||的作用将变量的所有权从一个线程转移到另一个线程。move||和|v|的作用一样。好处是不用解决借用生命周期的问题，坏处就是无法跟其它代码实现对变量的共享。
4.多线程并行：channel类似单所有权：一旦将值的所有权转移至channel，就无法使用它了。共享内存并发类似多所有权：多个线程可以同时访问同一块内存。
6.多线程并行：Mutex类似于RefCell提供内部可变性，就是多个共享所有权时可以修改变量的值。Rc和Arc都是共享所有权的智能指针，但是Rc和RefCell是非线程安全的，所以使用Mutex和Arc来解决多线程数据共享的安全。
a.clone()和Rc::clone(&amp;a)的效果一样。
二、多任务并发的一点小结 1.什么时候使用异步编程或者多线程？
对于很多的任务，比如读取1000个文件，每个文件开一个线程？很耗费资源，这时可以使用异步编程。
对于IO密集型适合使用异步编程，对于CPU密集型异步编程也不起作用，适合多线程。
要避免在异步任务中处理大量计算密集型的任务，因为效率不高，且还容易饿死其它任务，CPU 密集型任务更适合使用线程，而非 Future。
如果真的需要在 tokio（或者其它异步运行时）下运行计算密集型的代码，那么最好使用 yield 来主动让出 CPU，将线程交还给调度器，自己则进入就绪队列等待下一轮的调度，比如 tokio::task::yield_now()，这样可以避免某个计算密集型的任务饿死其它任务。
2.一个Future创建之后并不会运行，是惰性的。需要执行者，使用.await或者block_on来进行执行过程。block_on会造成当前的程序阻塞，block_on里面的执行完成了才会接着执行，而在async函数里面的.await不会阻塞线程，会让出线程给其他的，等Future有进展了再执行该任务。而且运行是直接接着这个被.await的Future运行，上面的代码不会再运行。
3.补充关于进程、线程、协程的相关概念：进程其实就是一个运行的代码程序，这个程序可以由多个线程来执行，是资源分配和调度的基本单位。线程就是比如CPU有四核，那么最多同时运行4个线程，线程是操作系统进行调度的，创建和销毁都是操作系统来实现，线程是执行和并发的基本单位。协程由用户空间的调度器进行调度，调度器根据协程的调度策略进行切换，切换开销较小，协程在单个线程中执行，通过调度器的切换来实现多个协程之间的并发执行，协程之间共享线程的调用栈和上下文，可见异步编程就是协程的操作。
4.何时唤醒函数？什么时候可以poll了？
这个过程来源于操作系统通知，比如IO操作已完成，操作系统告知waker，waker告知调度器，调度器这个时候就进行poll以获取更多进展。
5.Reactor Pattern 是构建高性能事件驱动系统的一个很典型模式，executor 和 reactor 是 Reactor Pattern 的组成部分。Reactor pattern 包含三部分：
task：待处理的任务。任务可以被打断，并且把控制权交给 executor，等待之后的调度
executor：一个调度器。维护等待运行的任务（ready queue），以及被阻塞的任务（wait queue）
reactor：维护事件队列。当事件来临时，通知 executor 唤醒某个任务等待运行
executor 会调度执行待处理的任务，当任务无法继续进行却又没有完成时，它会挂起任务，并设置好合适的唤醒条件。之后，如果 reactor 得到了满足条件的事件，它会唤醒之前挂起的任务，然后 executor 就有机会继续执行这个任务。这样一直循环下去，直到任务执行完毕。
6.tokio 的调度器会运行在多个线程上，运行线程上自己的 ready queue 上的任务（Future），如果没有，就去别的线程的调度器上偷一些过来运行（work-stealing 调度机制）。当某个任务无法再继续取得进展，此时 Future 运行的结果是 Poll::Pending，那么调度器会挂起任务，并设置好合适的唤醒条件（Waker），等待被 reactor 唤醒。而reactor 会利用操作系统提供的异步 I/O（如epoll / kqueue / IOCP），来监听操作系统提供的 IO 事件，当遇到满足条件的事件时，就会调用 Waker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58dab4bf1d7828ce8932684995634b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47a301e930b8d98b9f994befb9f8bfb/" rel="bookmark">
			vue中push和resolve的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import { useRouter } from 'vue-router'; const route=useRouter() route.push({ path:'/test', query:{ name:1 } }) import { useRouter } from 'vue-router'; const route=useRouter() const url=route.resolve({ path:'/test', query:{ name:1 } }) window.open(url.href) 比较上述代码会发现,resolve能实现跳转到新的窗口,通过使用open方法,但是push不能跳转到新的页面,只能在原页面进行操作.
同时如果不想在地址栏里传参,也可以通过localstorage来进行本地存储,也能获取到参数.
比如:
原页面传参
import { useRouter } from 'vue-router'; const route=useRouter() const url=route.resolve({ path:'/test' }) localStorage.setItem('name', 1); window.open(url.href) 新页面接收参数时
let namDemo=localStorage.getItem('name') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a9728120a6cfad32066081a8dc9d3b/" rel="bookmark">
			用yolov4-tiny检测在电力输电线20种鸟类，灵活运用训练trick，实验较为完备，数据处理丰富度值得参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Detection of bird species related to transmission line faults based on lightweight convolutional neural network Abstract 输电线路高效防鸟害是电网运行维护面临的长期挑战。本文提出了一种将轻量级卷积神经网络(CNN)、图像处理和目标检测相结合的方法来检测与输电线路故障相关的典型鸟类。构建了威胁输电线路安全的20种鸟类图像数据集。结合分阶段训练、马赛克数据增强、余弦退火和标签平滑，构建并训练了YOLOv4-tiny算法模型。通过调整训练过程的参数，在测试集上的平均精度(mAP)可以达到92.04%。然后，根据测试结果和性能指标，与Faster RCNN、SSD、YOLOv4等方法进行比较，验证了所提方法的有效性。利用运动模糊、散焦模糊、对比度和亮度调节等图像预处理方法模拟了实际工程应用场景。该方法能够高效地检测出栖息在输电线路周围的鸟类，有助于对电网因鸟引起的停电进行差别化预防。
论文地址：Detection of bird species related to transmission line faults based on lightweight convolutional neural network - Qiu - 2022 - IET Generation, Transmission &amp; Distribution - Wiley Online Library
南昌大学信息工程学院 (ncu.edu.cn)
INTRODUCTION 随着电网的大规模建设和生态环境的改善，鸟类活动与输电线路之间的矛盾逐渐引起人们的关注。鸟类故障已成为继雷击和外力破坏之后，输电线路中断的第三大原因。据统计，2010 - 2019年，中国国家电网公司110 (66)kV及以上输电线路共发生鸟类活动相关故障2374起，占输电线路故障总数的10.4%。此外，与鸟类有关的停电仍呈上升趋势。
鸟类造成的主要故障包括鸟粪、筑巢、鸟身短路、啄木鸟停飞等。与鸟类相关的一些典型中断案例如下图所示。
(a)绝缘子表面的鸟粪，(b)绝缘子上方横臂上的鸟巢，©大鸟触电导致短路，(d)鸟啄复合绝缘子
鸟粪故障是指鸟粪的导电通道引起的输电线路跳闸;以及附着的鸟粪引起绝缘子表面闪络。巢断和鸟短路断是由相对相或相对地放电引起的，这种放电是由于鸟巢材料或鸟体减少绝缘距离而发生的。
啄型故障是指复合绝缘子因鸟啄型外壳或护套引起的绝缘子损坏或闪络。在输电走廊周围栖息的鸟类对输电线路安全构成不同程度的威胁。一些鸟类以输电线路为最佳觅食地，在输电塔或线路上站立或筑巢，可能造成鸟类粪便或筑巢中断。有些鸟类，如麻雀，喜欢栖息在电力线或塔上，但它们不容易引起故障。不同的鸟类可能造成不同的断层类型，它们的预防措施也不应该完全相同。
针对鸟类故障问题，人们对防鸟装置进行了大量的研究，如防鸟针、防鸟盾、防鸟箱等。Taklaja通过改进绝缘体结构来避免鸟类粪便引起的闪络，从而缩短了鸟类的停留时间。Yang通过研究鸟流引起绝缘子闪络的机理，讨论了防鸟装置的保护半径。Kuang提出了一种合理的护鸟挡板结构设计方案，并验证了其对电场分布的影响。大规模安装防鸟装置需要巨大的投资。
然而，根据经验和SGCC的统计结果，防鸟装置防止了一些与鸟有关的中断，但性能没有达到预期。材料老化、安装不规范、鸟类适应等往往导致防鸟装置失效，无法长期有效解决鸟损问题。此外，有些装置盲目驱赶鸟类，甚至对一些稀有珍贵鸟类造成伤害，如黑云杉、白云杉等，对生态环境造成不良影响。因此，有必要识别栖息在输电线路周围的鸟类，判断其风险等级和可能引起的故障类型，从而采取差异化和高效的预防措施，减少鸟类引起的故障，节省不必要的投资。
近年来，随着卷积神经网络(CNN)的发展，目标检测得到了广泛的研究和应用，与传统方法相比，其对目标识别的效果有了显著提高。目前常用的目标检测算法有R-CNN、Faster R-CNN、SSD、YOLOv3等，已应用于绝缘子缺陷、缺针缺陷等电气设备的检测。对于鸟类的识别与检测，Tian提出了航拍视频中捕捉飞鸟的glance and stare detection (GSD)框架;该算法利用放大算法生成区域建议，并利用三维卷积神经网络提取自适应深度时空特征。Sharma提出了一种基于YOLOv3的印度家麻雀检测方法，并与Tiny-YOLO、YOLOv2和Mask-RCNN同时进行了比较，结果表明，YOLOv3可以达到92%的检测准确率。Li提出了一种基于超分辨率(super-resolution, SR)的鸟类检测方法，在Faster RCNN中引入了VDSR、FSRCNN和DRRN三种方法进行鸟类检测，提高了精度。邹提出了一种基于YOLOv3的传输线周围鸟类数量检测方法，该方法采用扩展卷积取代原有卷积层，通过比例因子计算置信度得分，并对NMS算法进行优化，检测准确率达到86.31%。一般来说，以往对鸟类识别的研究通常集中在鸟类生态学领域，或者作为一个案例来验证图像识别或目标检测算法的有效性。对可能对电网造成安全隐患的有害鸟类的识别研究较少。
因此，为了解决上述问题，本文引入了一种轻量级的传输线鸟类CNN检测方法。构建了与输电线路故障相关的20种典型鸟类的图像数据集，并进行了图像处理，模拟了实际工程场景。结合多种训练方法，建立YOLOv4-tiny轻量化检测模型，学习鸟类图像的特征。根据性能评价指标，将鸟类检测结果与其他目标检测算法进行比较。该方法可以对与输电线路中断相关的20种典型鸟类进行差异检测。平均精度(mAP)和帧数每秒(FPS)分别达到92.04%和40。它可以用来识别输电线路周围的鸟类，为防鸟装置的安装提供参考，从而减少与鸟类有关的停电。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8a9728120a6cfad32066081a8dc9d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cd94bf5b0912fe37e6139b032a007c/" rel="bookmark">
			Linux c&#43;&#43;反汇编源码细节解释说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例c++源码:
int main(int argc, char** argv) { auto sk = argc; int a = 11 &lt;&lt; sk; int b = 19 + argc; volatile int rv = a + b * 8; rv *= sk; return rv; } GUN x86 64bit AT&amp;T 汇编环境下用 g++ -O1 -Wa,-adhln ./main.cc命令反汇编
反汇编源码:
0000 89F9 movl	%edi, %ecx 0002 B80B0000 movl	$11, %eax 0007 D3E0 sall	%cl, %eax 0009 8D84F898 leal	152(%rax,%rdi,8), %eax 0010 0FAFC7 imull	%edi, %eax 0013 C3 ret 一点准备知识：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3cd94bf5b0912fe37e6139b032a007c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77317db46c88db5eb7a1ce4a90c5a7e/" rel="bookmark">
			git 导出差异 diff 文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git 下，做了修改的文件， git diff 可以看到修改前后的差异。
修改后，常常需要导出修改差异文件，如 a.diff 、b.path 。
记录下导出命令。
1.导出本地修改的 diff 本地修改了文件，还没有 git add ，可以这样导出。
格式为：
git diff 【修改的文件或文件夹】&gt;&gt;【差异文件名称】
示例，
git diff device.mk &gt;&gt; device.diff git diff device.mk &gt;&gt; device.pacth device.diff 、device.pacth 是自己命名的，名称自取，后缀一般使用 .diff 和 .path 。
导出后的 device.diff 、device.pacth 文件，用 Notepad++ 、Sublime Text 等编辑器可看到明显的修改差异。
2.导出临近两个 comit 之间的 diff git log 查看提交记录，要导出临近两个提交之间修改的差异，可以这样做。
格式为：
git diff 【old-commit-id】【new-commit-id】&gt;&gt; 【差异文件名称】
这样导出的差异文件，和 git show new-commit-id 的结果一样。
示例，
git diff 03a5cc46f1 a16f3bb31b &gt;&gt; commit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b77317db46c88db5eb7a1ce4a90c5a7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7666a27e21eca9ca672806cb49f2183/" rel="bookmark">
			AndroidStudio 引用多组jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AndroidStudio 导入jar包，在 app 目录下新建 lib 目录，然后放入引用的 jar 包，再右键选择 Add As Library 添加。
同步一下就好了，会在 app 的 build.gradle 生成如下：
dependencies { implementation files('lib/xxx.jar') } 当导入多个 jar 包时。一个个的 Add As Library ，会很麻烦，简单一招，直接把整个目录下的 jar 包引用。
同样适用于引用 aar 包。
dependencies { implementation fileTree(include: ['*.jar'], dir:'lib') implementation fileTree(include: ['*.aar'], dir:'lib') //也可以这样写 implementation fileTree(dir: "lib", include: ["*.jar"]) implementation fileTree(dir: "lib", include: ["*.aar"]) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4c57578a60d2fbc918730e13c9a546/" rel="bookmark">
			利用HttpListener做客户端代理服务拒绝访问异常解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows10下利用winform做了个html页面转PDF文件转换的服务，在利用HttpListener做代理时会出现拒绝访问的问题，具体处理方式:
利用管理员权限执行CMD：
一、使用netsh http delete urlacl url=http://自己的IP:端口号/ 清楚URL保留项
二、使用netsh http add urlacl url=http://自己的IP:端口号/ user=Everyone 添加URL保留项
在域下添加Everyone的时候不生效不知道为什么所以我是通过
netsh http add urlacl url=http://自己的IP:端口号/ user=具体用户 来解决这个问题
三、处理完还是会报错，则确认下防火墙是否拦截了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e7c0aba3faff88528c2c70b8411256/" rel="bookmark">
			Maven介绍_下载_安装_使用_原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 Maven介绍1.1 Maven的介绍1.2 Maven的作用 2 Maven下载与安装2.1 官网下载2.2 文件目录2.3 环境配置 3 Maven基础概念3.1 仓库分类3.2 依赖坐标3.3 坐标组成 4 Maven配置4.1 本地仓库配置4.2 远程仓库的设置4.3 镜像仓库配置4.4 IDEA配置Maven 5 Maven项目创建5.1 Maven项目的构建命令5.2 IDEA创建Maven工程 6 Maven依赖管理6.1 依赖配置6.2 依赖传递6.3 依赖冲突6.4 可选依赖6.5 排除依赖6.6 依赖范围6.7 依赖范围的传递性 7 生命周期与插件7.1 生命周期7.2 插件 1 Maven介绍 1.1 Maven的介绍 Maven的本质是一个项目管理工具，将项目开发中和管理过程抽象成一个项目对象模型 —POM
POM：Project Object Model --即项目对象模型
1.2 Maven的作用 项目构建：提供标准的，跨平台的自动化项目构建方式依赖管理：方便快捷的管理项目依赖的资源lar包，避免资源之间的版本冲突问题统一开发结构：提供标准的，统一的项目结构
2 Maven下载与安装 2.1 官网下载 Maven官网：http://maven.apache.org/.
Maven下载地址：https://maven.apache.org/download.cgi
2.2 文件目录 Maven是绿色软件，下载解压即可使用
2.3 环境配置 Maven运行需要依赖JAVA_HOME （前提需要安装配置好 jdk ）设置Maven自身的运行环境，需要配置MAVEN_HOME 1、配置Maven的安装目录：MAVEN_HOME
2、配置Maven的bin路径（path目录下）
3、cmd指令mvn检查安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1e7c0aba3faff88528c2c70b8411256/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76dfa64de9db0f76046070247d28957a/" rel="bookmark">
			通过LD_PRELOAD绕过disable_functions
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LD_PRELOAD
LD_PRELOAD是Linux/Unix系统的一个环境变量，它可以影响程序的运行时的链接，它允许在程序运行前定义优先加载的动态链接库。通过这个环境变量，可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖系统的函数库。
LD_PRELOAD 超脱于动态链接库的搜索路径先后顺序之外，它可以指定在程序运行前优先加载的动态链接库。
具体的操作步骤如下：
定义一个函数，函数的名称、变量及变量类型、返回值及返回值类型都要与要替换的函数完全一致。这就要求我们在写动态链接库之前要先去翻看一下对应手册等。将所写的 c 文件编译为动态链接库。对 LD_PRELOAD 及逆行设置，值为库文件路径，接下来就可以实现对目标函数原功能的劫持了结束攻击，使用命令 unset LD_PRELOAD 即可 whoami.c
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { char name[] = "mon"; if (argc &lt; 2) { printf("usage: %s &lt;given-name&gt;\n", argv[0]); return 0; } if (!strcmp(name, argv[1])) { printf("\033[0;32;32mYour name Correct!\n\033[m"); return 1; } else { printf("\033[0;32;31mYour name Wrong!\n\033[m"); return 0; } } 接下来写一个动态链接库，目标函数为这里进行判断的 strcmp 函数
hook_strcmp.c
#include &lt;stdlib.h&gt; #include &lt;string.h&gt; int strcmp(const char *s1, const char *s2) { if (getenv("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76dfa64de9db0f76046070247d28957a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90ab9772305ac2062b42479b99ea7517/" rel="bookmark">
			iOS 中 UIViewController 加载之后，将其中的 UITableView 滑到最底部以及遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中，需要在进入 UIViewController 后对它里面的 UITableView 滑动到最底部，那么需要把代码写在 viewDidLoad 中。
下面这一行代码要使得 previewTable 这个UITableView 滑动到最底部的位置。（home.tickTasks 是我对代码中这个 tableView 的数据源，可根据实际需要设置）
self.previewTable.scrollToRow(at: IndexPath.init(row: (Home.tickTasks.count - 1), section: 0), at: .bottom, animated: false) 但是，不管是否需要动画，以上代码总是不能准确地滑动到指定位置，滑动的动作需要一点点时间。
以下使用同步机制来等待一小段时间。
DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) { self.previewTable.scrollToRow(at: IndexPath.init(row: (Home.tickTasks.count - 1), section: 0), at: .bottom, animated: false) } 猜想，是因为代码控制对 tableView 的滑动需要在 tableView 初始化好并且把 cell 的数据加载进来之后，如下代码，若这样写，则会出现 tableView 划不到最底部的情况。
override func viewDidLoad() { super.viewDidLoad() bindTableView() // 配置 tableView 的 dataSource、delegate 等信息 loadFromCoreData() // 加载数据到 tableViewCell 中 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90ab9772305ac2062b42479b99ea7517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599023adc158cb0b3eaf82d21a5c59df/" rel="bookmark">
			excel 动态表头与合并列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、希望Springboot-java导出excel文件，包括动态表头与下边合并的列 使用 org.apache.poi 与自己封装工具类实现相关功能。代码如下
一、代码 1、依赖 implementation(group: 'org.apache.poi',name: 'poi-ooxml',version: '4.1.0') implementation(group: 'org.apache.poi',name: 'poi',version: '4.1.0') implementation(group: 'cn.hutool', name: 'hutool-all', version: '5.8.3') 2、工具类 ExcelMergeUtil.java import cn.hutool.json.JSONUtil; import com.longze.fengqx.HeaderNode; import com.longze.fengqx.PoiModel; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import org.apache.poi.ss.usermodel.*; import org.apache.poi.ss.util.CellRangeAddress; import org.apache.poi.ss.util.RegionUtil; import org.apache.poi.xssf.streaming.SXSSFCell; import org.apache.poi.xssf.streaming.SXSSFSheet; import org.apache.poi.xssf.streaming.SXSSFWorkbook; import java.util.List; import java.util.Map; import java.util.stream.Collectors; import java.util.stream.IntStream; /** * @author Fengqx * @version 1.0 * @description: excel文件合并 * @date 2023/8/20 13:13 */ public class ExcelMergeUtil { public static SXSSFSheet createExcelHead(SXSSFWorkbook book, String sheetName, String headJson){ List&lt;HeaderNode&gt; headerNodes = JSONUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/599023adc158cb0b3eaf82d21a5c59df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6edf0e00f627d9af107326b47006478e/" rel="bookmark">
			google插件开发流程和示例，google插件开发过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要开发Google插件，需要使用Chrome插件API。以下是一个基本的开发流程和一些示例代码：
创建一个新的Chrome插件项目，并创建一个文件夹，其中包含manifest.json文件和所有其他文件。在manifest.json文件中指定插件的名称、描述、版本号、图标等。还需要添加一个"background"字段，该字段指定了插件的主要JavaScript文件。创建一个JavaScript文件，该文件将包含插件的主要逻辑。在JavaScript文件中使用Chrome插件API来访问浏览器窗口、浏览器标签页、浏览器历史记录等。在JavaScript文件中使用事件监听器来响应浏览器的操作。在manifest.json文件中添加必要的权限和访问权限，以确保插件可以访问所需的浏览器功能。完成开发后，使用Chrome网上应用商店开发者工具将插件打包并上传到应用商店。 以下是一个简单的示例代码，它会在浏览器的地址栏中显示一条消息：
php
{ "manifest_version": 2, "name": "My Plugin", "version": "1.0", "description": "This is a simple plugin.", "background": { "scripts": ["background.js"], "persistent": false }, "icons": { "16": "icon16.png", "48": "icon48.png", "128": "icon128.png" }, "permissions": ["tabs"] } 在background.js文件中添加以下代码：
javascript
chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) { if (changeInfo.status == "complete") { chrome.tabs.executeScript(tabId, {file: "content.js"}); } }); 在content.js文件中添加以下代码：
javascript
document.addEventListener('DOMContentLoaded', function() { var message = document.createElement('div'); message.textContent = 'Hello, World!'; message.style.cssText = 'position:fixed;top:0;right:0;padding:5px;background:#ff0;color:#fff;'; document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6edf0e00f627d9af107326b47006478e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f005c8bcc90be517cecdbfe6243b2db/" rel="bookmark">
			编写Dockerfile制作自己的镜像并推送到私有仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：我将用到的私有仓库是Harbor，安装教程参考我的这一篇文章：
安装搭建私有仓库Harbor_Word_Smith_的博客-CSDN博客
一、案例1 1、要求 编写Dockerfile制作Web应用系统nginx镜像，生成镜像nginx:v1.1，并推送其到私有仓库。具体要求如下：
（1）基于centos基础镜像
（2）指定作者信息
（3）安装nginx服务，将提供的dest目录（提供默认主页index.html）传到镜像内，并将dest目录内的前端文件复制到nginx的工作目录
（4）暴露80端口
（5）设置服务自启动
（6）验证镜像
2、实现步骤 （1）编写Dockerfile文件 #创建index.html前端文件 [root@node2 demo01]# cat index.html welcome to demo01 #创建demo01目录用来创建Dockerfile [root@node2 ~]# mkdir -p docker_demo/demo01 [root@node2 ~]# cd docker_demo/demo01/ [root@node2 demo01]# vim Dockerfile #写入以下内容 FROM centos MAINTAINER "benjm &lt;benjm@163.com&gt;" ADD http://nginx.org/download/nginx-1.24.0.tar.gz /usr/local/src/ COPY index.html /usr/share/nginx/ EXPOSE 80 CMD ["/usr/sbin/nginx","-g","daemon off;"] Dockerfile内容如下
（2）构建镜像 [root@node2 demo01]# docker build -t nginx:v1.1 ./ 查看
（3） 推送到私有仓库 在harbor上创建项目demo01 #首先登录到私有仓库 [root@node2 demo01]# docker login -u admin -p Harbor12345 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f005c8bcc90be517cecdbfe6243b2db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171eeb9e7002e26b564ccb2dad5f7eb8/" rel="bookmark">
			解决npm安装错误:No matching version found for XXX@3.3.6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述 使用npm install安装项目依赖包的时候，报错：
npm ERR! A complete log of this run can be found in:
npm ERR! /Users/dragon/.npm/_logs/2018-12-19T11_45_03_469Z-debug.log
2.解决方法 从错误信息：No matching version found for XXX@3.3.6可以知道，是由于没有找到这个包的3.3.6版本。
首先去 https://www.npmjs.com/ 网站搜索这个包，看看是否发布了这个版本：
点击Versions查看这个包的所有历史版本。
查看是否有与你刚才install的版本,如果没有, 找一个你喜欢的版本重新install一下就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c948b257faf26e7a3d3903075cd006be/" rel="bookmark">
			解决element组件位置偏移 , 包含 下拉框、 级联选择器、 popover组件、时间选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 Select组件下拉位置错乱
在select标签里写
二 Popover组件位置偏移
如果el-popover里面的数据是动态的，有时候会出现位置偏移不在可视区域范围内的情况，主要是popper-options这个参数要设置，还请大家看看popper.js的文档
&lt;el-popover ref="dcPopover" placement="left" width="797" trigger="hover" :popper-options="{ boundariesElement: 'viewport', removeOnDestroy: true }" @show="handleShow(scope)" :open-delay="300" &gt; 重点是 :popper-options=“{ boundariesElement: ‘viewport’, removeOnDestroy: true }”
boundariesElement 默认的是body!如果里面数据动态化之后有问题，需获取到数据之后要this.$refs.popover.updatePopper()一下（用来重新计算位置的） 三 时间选择器组件位置偏移
DOM结构中，溢出(overflow: scroll/auto;)容器以下，el-date-picker的输入框（动图中焦点所处位置）以上，存在一个overflow/overflow-x/overflow-y是auto/scroll的容器
为了让我们的fixed定位的控件在el-dialog里可以指哪打哪，我把项目引用的element-ui版本从1.x升级到了2.x（原因见 CSS Transform对定位的影响）
升级之后带来了一个问题：之前在el-dialog老老实实长到24px的控件莫名其妙的长高了2px（这里是另一个问题，下一篇再谈），demo在即，就临时给这些长高的控件的父容器加了overflow-y:hidden;（同时心里充满了膈应），demo过后我偶然发现，el-date-picker出现了上边动图的情况。
首先，弹出的这个日期picker是fixed定位的，如果想要让它能够跟随页面滚动，实现原理就一定是：在溢出容器上绑定scroll事件，回调方法中计算输入框相对窗口的offset，减去滚动offset(scrollTop,scrollLeft)，作为picker的offset。
这其中的重点是：如何找到这个溢出容器。element-ui的方式是在弹出的picker生成的时候，在DOM树种递归向上查找第一个overflow/overflow-x/overflow-y是auto/scroll的容器，在其上绑定scroll事件。详解
解决办法：
找到最外层的元素 加一个样式 ，overflow-y:auto ,亲测解决上图情况以及element-ui里任何以弹出的形式的组件会跟随鼠标滚动而滚动的问题** 四 Cascader级联选择器下拉位置错乱
忘了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/828bef98b5ee032c706d3863e0fa337e/" rel="bookmark">
			Vue &#43; Element UI&#43;Scss &#43; Vuex一键换肤 , 一键换字体大小 ,动态替换全局主题颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 其实我这个写法每个UI库都通用 , 不局限于ElementUI , 看明白思路就知道怎么写了
一键换肤 , 动态替换全局主题颜色功能已经实现很久了 , 在项目验收的时候出现了一个小问题 , 想改动一下 , 于是来记录一下
前段时间公司项目里需要实现一键换服 , 换主题颜色 , 网上看了一部分 大多数都是用js获取标签元素添加Attribute , 如document.XXXXXXX ,或者是建theme.css文件什么的 , 不太符合我想要实现的用最少的代码实现换肤的功能 , 如果用了框架 , 还要用一大堆代码实现一个不复杂的功能的话 , 我觉得他是在凑code量, 凑代码绩效 , 冗余且不易理解
二、效果图 老规矩 , 观众老爷们先看效果图
三、实现思路 前言已经讲了那么多废话 , 这段来捋一下实现的思路 , UI库用的是ElementUi , 要实现一键换肤 , 唯一的一个变量是色值 ,
用 一个变量 来控制颜色 , 首选scss , 想要全局可控一个变量的话 , 肯定是vue里面的vuex状态管理 , 思路到这就够了 , 还想其他什么呢
四、贴上代码 1. 第一步封装一个theme-picker颜色选择器组件 , 是子组件
子组件第一种 ( 不包括element里面的组件色值,比如按钮颜色,单选选中颜色 ,下拉级联等等等等 )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/828bef98b5ee032c706d3863e0fa337e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f7da626709b91a9cd362b00fbd4fee/" rel="bookmark">
			Vue Element table表格实现表头自定义多类型动态筛选 , 目前10种筛选类型，复制即用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、效果图 目前10种筛选类型
看看是否是你需要的，本文可能有点长 ，我尽可能的给讲清楚，包括源码附上
二、无聊发言 点击当前行跳转部分数据后缀追加图标某列数据根据状态增加颜色标识 三、前言 实现图中的表格，特定的两个要求，筛选条件的接口(返回多种类型及字段标识)，列表接口统一为一个，靠mark参数传输与后台商定好的标识，当然，如果你们的后端能够即能返回列表数据又能返回筛选条件的各种类型的标识也是极好的 。
表格中涉及到返回的数据是value（数字、id等类似select option里绑定的value）形式的，可能需要后端处理成label的形式返给前端，如同上图里的地区，下拉选择等列
表格中如有当前行的跳转、当前行的数据状态亦或者尾部的操作列存在时，需小心斟酌封装
目前筛选tag删除掉已选的条件没有支持到筛选popover里面清空数据，类似重置功能
表格上面的搜索组件，是个针对表格数据的全局搜索
vuedraggable是拖拽插件，上图中字段管理里的拖拽效果 ，需要的话请自行npm install
scss样式变量需自行更改，谢谢!!
后续发现的bug我会陆续修复并修改此文
四、组件层级 五、文件目录 六、index.vue(最父级，调用入口) 附：组件zn-开头命名是以公司缩写来命名的,目的也是为了区分全局组件 ，个人组件命名随意
&lt;template&gt; &lt;div class="allCustomer-container"&gt; &lt;zn-query-form&gt; &lt;zn-query-form-top-panel&gt; &lt;!-- 字段管理 --&gt; &lt;field-management @setColumns="getColumns" /&gt; &lt;!-- 搜索 --&gt; &lt;Search @up-Search="upSearch" /&gt; &lt;!-- 筛选条件 --&gt; &lt;filter-tag :tagList="conditionList" @up-table="tableUpdate" /&gt; &lt;/zn-query-form-top-panel&gt; &lt;/zn-query-form&gt; &lt;zn-filter-table ref="filterTable" :multiple="true" :tableData="tableList" :finallyColumns="finallyColumns" :deatilsPath="deatilsPath" @selectList="getSelect" @fetch-data="fetchData" /&gt; &lt;zn-pagination v-show="total &gt; 0" :page.sync="queryForm.page" :limit.sync="queryForm.listRows" @pagination="fetchData" :total="total" :algin="'right'" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Search from '@/components/Search' import FieldManagement from '@/components/ZnFilterTable/components/fieldManagement' import FilterTag from '@/components/ZnFilterTable/components/filterTag' import ZnFilterTable from '@/components/ZnFilterTable' import { getAllList } from '@/api/customer' export default { name: 'allCustomer', components: { Search, FieldManagement, FilterTag, ZnFilterTable, }, provide() { return { mark: 'Member', //特定标识,根据业务模块不同,传输的标识也不同,标识由后端定义(或者字典维护) } }, data() { return { total: 0, tableList: [], listLoading: false, queryForm: { page: 1, listRows: 10, keywords: '', _filter: {}, //头部筛选 }, deatilsPath: '/customer/deatils', //表格当前行跳转路径 options: [], conditionList: [], //自定义筛选条件 columns: [], //筛选条件中的数据 checkList: [], //筛选条件中选中的数据 multipleList: [], //表格复选多选中的数据 } }, computed: { finallyColumns() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f7da626709b91a9cd362b00fbd4fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7fd7f1ccad9f189eee2c085e4fd3711/" rel="bookmark">
			pytorh学习笔记:根据图示写相应神经网络以及对相应的debug进行修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位小伙伴大家好,很高兴又能和你见面,,在这篇博客中我将记录我再暑期学习中出现的debug以及修改debug的过程
首先我们先来看看作业要求
所使用的网络结构:
由上网络结构我们易知此网路我们需要用到残差结构,所以我们可以参考resnet的写法来写这个网络结构
resnet代码写法可以参考我之前写的Pytorch学习笔记:RNN的原理及其手写复现_后来后来啊的博客-CSDN博客
使用pytorch搭建ResNet并基于迁移学习训练(超详细 |附训练代码)_后来后来啊的博客-CSDN博客
在使用pytorch搭建ResNet并基于迁移学习训练(超详细 |附训练代码)_后来后来啊的博客-CSDN博客这篇博客当中,我们定义了一个model函数
所以在此我们也在model.py中定义我们的网络结构
首先我先写了以下代码来实现这个网络结构
import torch import torch.nn as nn import torchsummary class ResidualBlock(nn.Module): def __init__(self, in_channels, out_channels, stride=1, groups=1): super(ResidualBlock, self).__init__() self.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=stride, padding=0) self.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=3, stride=1, padding=1, groups=groups) self.conv3 = nn.Conv2d(out_channels, out_channels, kernel_size=1, stride=1, padding=0) self.relu = nn.ReLU(inplace=True) if stride != 1 or in_channels != out_channels: self.downsample = nn.Sequential( nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=stride, padding=0), nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7fd7f1ccad9f189eee2c085e4fd3711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88fc20c6c4f68459692ac91883e7736/" rel="bookmark">
			Streamlit 讲解专栏（三）：两种方案构建多页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言2 第一种方案：使用Session State实现多页面交互2.1 Session State简介2.2 多页面应用的基本结构2.3 实现多页面交互的代码示例2.4 Session State机制的优缺点 3 第二种方案：Streamlit内置多页面方案（更为推荐）3.1 如何运行多页面应用程序3.2 添加页面3.3 页面在用户界面中的标签和排序方式3.4 现在我们来实现一个多页面应用Hello.pypages/1_📈_Plotting_Demo.pypages/2_🌍_Mapping_Demo.pypages/3_📊_DataFrame_Demo.py 4 结语 1 前言 首先，感谢各位读者阅读之前的一篇博文Streamlit 讲解专栏（二）：搭建第一个应用，该博文详细介绍了如何使用Streamlit框架来搭建数据应用程序。🎉 在那篇博文中，我们强调了Streamlit的简单易用性和强大功能，以及如何通过编写Python代码快速创建交互式应用。
在这篇博文中，我们将进一步扩展之前的内容，并专注于Streamlit多页面应用的构建。多页面是一种重要且常见的应用程序设计方案，它允许我们在一个应用程序中使用多个页面来组织和呈现不同的内容或功能。通过多页面，我们可以更好地组织和管理复杂的应用，使用户能够轻松地与不同的功能模块进行交互。
但是，多页面是什么呢？在简单的术语中，多页面是指将一个大型应用程序拆分为多个独立的页面，每个页面专注于不同的任务或功能。这种设计模式的好处是明显的：它提高了应用的可维护性、可扩展性和用户体验。
在本博文中，我们将介绍两种不同的方案来构建Streamlit多页面应用。每种方案都有其独特的特点和用途；通过掌握这些方案，您将能够根据自己的需求选择最适合的方法。
无论您是数据科学家、开发人员还是对数据应用程序感兴趣的读者，希望这篇博文能为您学习和掌握Streamlit多页面应用的设计和实现提供指导和启发。
在进入具体方案之前，让我们先回顾一下Streamlit的基础知识，确保我们对Streamlit的核心概念和用法有一个清晰的理解。然后，我们将深入研究两个不同的多页面方案，并比较它们的优缺点。
请继续阅读，探索Streamlit多页面应用的令人兴奋和灵活的可能性！
2 第一种方案：使用Session State实现多页面交互 2.1 Session State简介 在介绍具体的设计方案之前，让我们先回顾一下Streamlit的Session State功能。Session State是Streamlit中用于在不同页面之间传递和保存状态数据的一种机制。通过Session State，我们可以在应用程序的整个生命周期中维护和访问特定于会话的变量。这意味着我们可以在不同页面之间共享和使用相同的变量值，从而实现多页面之间的交互和数据传递。
2.2 多页面应用的基本结构 在使用Session State构建多页面应用之前，让我们先了解一下多页面应用的基本结构。一个典型的多页面应用通常包括以下几个组成部分：
导航栏：用于切换页面的导航栏，可以是按钮、链接或下拉菜单等形式。
页面内容：不同页面的具体内容和功能模块，可以通过导航栏进行切换。
状态管理：保持和管理不同页面之间的状态数据，确保用户在切换页面时数据不会丢失。
2.3 实现多页面交互的代码示例 下面是一个使用Session State实现多页面交互的简单代码示例：
import streamlit as st # 设置初始页面为Home session_state = st.session_state session_state['page'] = 'Home' # 导航栏 page = st.sidebar.radio('Navigate', ['Home', 'About']) if page == 'Home': st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b88fc20c6c4f68459692ac91883e7736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a17a99ff694df10f2a5f34e0603941/" rel="bookmark">
			PostgreSQL 函数 for循环使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postgresql 函数例子 本业务是实现将之前已经使用的数据和现在的数据关联起来，需要写个sql函数初始化数据，数据库使用的是postgresql 具体代码 create or replace function insert_user_roles() returns void as $$ declare user RECORD; role RECORD; begin for user in (select id from user where is_delete = false) loop for role in (select * from role where is_delete = false) loop insert into '实际要插入数据的表' ('字段') values (user.id, role.id); end loop; end loop; end; $$ language plpgsql; select insert_user_roles();; 语法 业务需求是为已经在使用的用户初始化数据（模拟需求），学习语法就行，业务代码可以忽略掉。
loop关键字不能忽略,且要跟for循环对应上
声明的变量需要使用declare
begin end要对应上
因为我这个业务场景是不需要返回值的,如果需要有返回值的可以去参考pgsql文档也不是很难
查询*完全就是为了方便，实际业务操作建议不要这么操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d876e7bd044e1131081f0b91a5133ed/" rel="bookmark">
			3种获取OpenStreetMap数据的方法【OSM】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenStreetMap 是每个人都可以编辑的世界地图。 这意味着你可以纠正错误、添加新地点，甚至自己为地图做出贡献！ 这是一个社区驱动的项目，拥有数百万注册用户。 这是一个社区驱动的项目，旨在在开放许可下向每个人提供所有地理数据。
OpenStreetMap 数据是最新、最详细的可用空间数据库。 因此，OSM 已成为希望在其应用程序和网站中使用地图数据的开发人员的流行资源。 但是，将 OpenStreetMap 数据转换为 OSM 对象并在项目中使用它需要经验和特定知识。
在本文中，我们将介绍获取 OpenStreetMap 数据的基础知识以及三种获取OSM数据的方法。
推荐：用 NSDT编辑器 快速搭建可编程3D场景
0、OpenStreetMap 数据结构 在讨论提取数据和查询示例之前，让我们先看看 OpenStreetMap 数据结构，因为需要这些知识来更好地理解查询示例。
OSM 数据库中的每个对象都分配有与其表关联的类型。 对象分为三种类型：节点、路径和关系。 每种对象都有唯一的 ID。 所以OSM中的每个对象都有一个ID和类型。 例如， osm_type=“way” 和 osm_id=67104773。
此外，每个对象可能具有描述其属性的标签，例如地址、开放时间、设施类型、颜色、参考文献、维基百科页面或其他信息。
0.1 节点 节点（Node）是具有位置（坐标）的对象。 节点可以代表邮箱、树、地铁入口、市中心、建筑物编号等。
节点可以是独立的，也可以是关系的一部分。 例如，地铁入口可以是地铁站的一部分。
0.2 路线 路线（way）是一条线或多边形，例如街道、河流、建筑物或边界。
与节点类似，路线可以是独立的，也可以是关系的一部分。 通常，街道和河流由一组方式表示，因此每个部分都可以有自己的标签，例如速度限制、车道数量、表面等。
0.3 关系 关系（relation）是描述世界上某些结构的节点、道路和可能的其他关系的组，例如，关系“自行车道”描述了道路旁边的自行车道的结构。
关系也可以有标签 - 这些通常称为“关系上的标签”，因为它们直接应用于关系，而不是像节点或路径标签这样的单个成员。
0.4 标签 OSM 数据库中的每个对象都可能有一组描述该对象的特征和属性的标签（tag）。 以下是如何标记建筑物的示例：
Building=yes（这告诉我们这是一座建筑物）name=Old Marylebone Town Hall（这是建筑物的名称）operator=Westminster City Council（这告诉我们谁在运营这座大楼）addr:street=Marylebone Road（这告诉我们可以在哪里找到这座建筑） OpenStreetMap (OSM) 社区努力创建一种保持标签平衡且易于理解的方法。 文档门户解释了标签。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d876e7bd044e1131081f0b91a5133ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3936749b840fb45bc13107bbb7b5f83a/" rel="bookmark">
			搭建：基于nginx的上传功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建：基于nginx的上传功能 文章目录 搭建：基于nginx的上传功能一、准备二、安装nginx1.1 解压nginx和nginx插件1.2 编译并安装nginx 三、启动一个python后台服务，用于上传到临时路径文件，转移到正式路径四、添加nginx配置（1）配置一个静态文件服务（2）配置上传文件服务 五、启动nginx和python服务六、python程序测试上传 一、准备 开发一个基于nginx的上传功能。
下载nginx：https://nginx.org/en/download.html
nginx-1.18.0.tar.gz
下载nginx-upload-module插件：https://github.com/vkholodkov/nginx-upload-module/tags
nginx-upload-module-2.3.0.tar.gz
二、安装nginx 1.1 解压nginx和nginx插件 先解压nginx-1.18.0.tar.gz, 然后将nginx-upload-module-2.3.0.tar.gz解压到nginx-1.18.0目录下。
[root@VM-4-3-centos nginx-1.18.0]# ll 总用量 788 drwxr-xr-x 6 1001 1001 4096 8月 19 09:52 auto -rw-r--r-- 1 1001 1001 302863 4月 21 2020 CHANGES -rw-r--r-- 1 1001 1001 462213 4月 21 2020 CHANGES.ru drwxr-xr-x 2 1001 1001 4096 8月 19 09:52 conf -rwxr-xr-x 1 1001 1001 2502 4月 21 2020 configure drwxr-xr-x 4 1001 1001 4096 8月 19 09:52 contrib drwxr-xr-x 2 1001 1001 4096 8月 19 09:52 html -rw-r--r-- 1 1001 1001 1397 4月 21 2020 LICENSE drwxr-xr-x 2 1001 1001 4096 8月 19 09:52 man drwxrwxr-x 3 root root 4096 8月 2 2018 nginx-upload-module-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3936749b840fb45bc13107bbb7b5f83a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5adca95d00a0f44456d65cd0b535c84d/" rel="bookmark">
			Android 源码编译生成framework.jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Debug 系统应用时，导入到 AS 会有大量报红代码，基本都是 framework 和新增模块的，需要导入对应的 jar 包才方便代码查看和跳转。
一般来说，使用 Android 源码全编译之后，
会生成 out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar 。
这个就是我们需要的 framework.jar （重命名一下），导入到 AS 里后，相关的代码就不会报红了。
但有些代码编译之后没有生成这个，
生成的是 out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes-header.jar ，
这个不是我们需要的。
导入到 AS 里，相关的代码还是会报红。
既然有源码，自己编译生成 framework.jar 试试。
在已经编译过的代码上，执行如下命令编译，
make javac-check-framework Android 源码编译使用 jack 编译的。
javac-check 是指用 javac（而非 jack）编译 java文件或模块，需要在已经完整编译后使用。
make javac-check-framework 意思是用 javac 编译 framework 模块。
javac 编译 framework 模块 可以生成 jar 包。
会生成如下文件，
out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar out/target/product/&lt;product_name&gt;/obj/JAVA_LIBRARIES/framework_intermediates/javalib.jar 前者就是我们需要的。
扩展，
对于其他模块，对应的 jar 包生成路径是
out/target/common/obj/JAVA_LIBRARIES/xxx_intermediates/classes.jar xxx 就是对应的模块的名字，如 android-support-v7-recyclerview_intermediates 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5adca95d00a0f44456d65cd0b535c84d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbcc9e8c9b656e6626cfc763f3fc1e52/" rel="bookmark">
			Ubuntu18.04安装Nvidia驱动【全网不坑，超全步骤】（亲测～）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04安装Nvidia驱动【全网不坑，超全步骤】亲测～ 为了方便以后回忆以及给像我一样的菜鸡提供思路，给出具体的步骤：No.1 查看自己的电脑显卡型号（已知麻烦自动略过）No.2 下载电脑对应的Nvidia版本驱动No.3 准备工作，下载依赖No.4 开始安装踩坑第一步（相信很多人都遇到过） 为了方便以后回忆以及给像我一样的菜鸡提供思路，给出具体的步骤： No.1 查看自己的电脑显卡型号（已知麻烦自动略过） 直接上命令：
1）方法一：（可有有些人不适用，就像我）
lshw -c video 结果：
2）方法二：（适用）
lspci | grep -i nvidia 显示：
02:00.0 3D controller: NVIDIA Corporation Device 1d12 (rev a1)
我们要的就是：1d12
然后进入网址：PCI Devices
输入并查找，得到
3）方法三：（说是直接弹出结果，但我没试过）
nvidia-smi -L No.2 下载电脑对应的Nvidia版本驱动 进入官网：https://www.nvidia.cn/Download/index.aspx?lang=cn
PS：这里按照我的电脑选取了驱动程序
然后：
选择下载之后得到一个后缀名为run的文件：
No.3 准备工作，下载依赖 1）禁用BIOS中的安全启动模式secure boot，这是因为此方法使用第三方源安装显卡驱动，不禁止secure boot会导致安装的驱动不能使用，禁用也不会有多大安全隐患。
不禁用后面会导致安装出现error并且fail
具体做法是：
开机进入BIOS，然后选择安全模式，禁止。（图待补充ing…）
2）移除所有以前安装过的nvidia包，并禁用nouveau
移除：
sudo apt-get purge nvidia* 创建文件：
sudo vim /etc/modprobe.d/blacklist-nouveau.conf 一般人很少用vim（vim是a或者i开启编辑，esc退出，输入:wq保存退出），我这里习惯用自带的gedit命令直接打开相当于记事本那样编辑：
sudo gedit /etc/modprobe.d/blacklist-nouveau.conf 插入以下两句代码：
blacklist nouveau options nouveau modeset=0 执行命令禁止nouveau，并重启生效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbcc9e8c9b656e6626cfc763f3fc1e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396d510a362dc211c9c353aa4e4583b4/" rel="bookmark">
			【STL】-- 知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
STL六大组件介绍
容器
序列式容器
vector
list
知识点考察
关联式容器
map/set
set介绍
set常用接口
map介绍
map常用接口
底层结构：红黑树
unordered_map/set
unordered_map/set介绍
底层结构：哈希表
知识考察
适配器
stack
queue
priority_queue
迭代器
什么是迭代器
迭代器的定义
迭代器失效
迭代器分类
STL六大组件介绍 从使用的角度来看，重点关注容器、算法和迭代器三个组件：
在使用C++进行程序编写的过程中，容器的使用必不可少，如用vector/list/map等来进行数据的存储。算法可以非常便捷的对容器进行操作，比如用sort对vector中的数据排序，使用find在map中查找元素等等。在通过算法操作容器的时候，不得不提到迭代器，它就像是容器和算法间的粘合剂：
迭代器的存在，首先封装隐藏了底层的实现细节。其次，为用户提供了统一的方式去访问容器，极大的降低了使用的成本。
从底层的角度，分析各个组件的功能及联系：
容器：各种数据结构，如: vector，list，set，map用来存放数据。
算法：各种常用算法如sort，swap，reverse，find等。
迭代器：扮演容器与算法之间的胶合剂。从实现角度来看，迭代器将operator*， operator-&gt;, operator++, operator--等相关操作进行重载的类。所有STL容器都附带有自己专属的迭代器，用户可以用统一的方式对容器进行访问。
仿函数：实现了operator()，这个类能够像函数一样调用，函数指针可视为狭义的仿函数。可作为算法的某种策略，例如改变sort排序的比较规则，map/set的key比较大小的规则。
配接器：用来修饰容器、仿函数、迭代器接口。如：stack，queue，主要体现了复用。
配置器：负责空间配置与管理，从实现角度来看，配置器实现了动态空间配置，空间管理，空间释放。例如：容器需要频繁的申请和释放小块的内存，这种情况下可以使用空间配置器，提高效率。
容器 序列式容器 vector 介绍：vector是表示可变大小数组的序列式容器，采用连续存储空间来存储元素，支持下标的随机访问，它的大小是可以动态改变的。vector在访问元素、尾插和尾删的场景下相对高效。
如上图所示，vector底层设计通过三个迭代器的指针分别记录数据块的起始位置，末尾有效数据和存储容量的末尾位置。vector的迭代器是原生的指针。
vector常用接口：
push_back:尾插
pop_back：尾删
operator[]：[]重载，使vector可以向数组一样访问。
rsize:改变vector的size，在开辟空间的同时还会初始化。
resrve：改变vector的capacity。
list list的底层结构是双向链表，该容器可以前后双向迭代。list在任意位置插入和删除元素的执行效率更好。
如上图所示，list_node的结构分为三个部分，分别是指向下一个节点的指针Next，执行前一个节点的指针Prev和存储数据的Val。
常用接口：
push_front/pop_front:头插、头删。
push_back/pop_back：尾插、尾删。
insert/erase:在pos位置插入值为val的元素,删除pos位置的元素。
知识点考察 vector和list的区别？
1.底层结构：vector采用连续的空间对数据进行存储（动态顺序表）。list物理结构不连续（带头节点的双向循环链表）。
2.随机访问：vector支持随机访问，访问某个元素的效率是O(1)。list不支持随机访问，访问某个元素的效率是O(n)。
3.迭代器：vector迭代器是原生的指针，list对原生态指针进行了封装。
4.使用场景：vector适合需要高效存储，支持随机访问，不关心插入删除效率的场景（中间插入要挪动数据，效率太低）。而list更适合大量的插入和删除操作，不关心随机访问的场景。
vector如何扩容？
当指向最后一个有效数据位置的迭代器和容量末尾的迭代器重合的时候，代表容器已满，需要进行扩容，在vs下按照1.5倍扩容，g++下按照2倍扩容。但这仅供参考，具体增长多少是根据具体的需求定义的，vs下是PJ版STL,g++是SGI版STL。主要原因就是，扩大了空间浪费，扩小了不够用频繁扩容，所以没有固定的标准说一定扩多少。
resize和reserve有什么区别？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/396d510a362dc211c9c353aa4e4583b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03f10b96565cf1fe137996626a8285f6/" rel="bookmark">
			linux驱动 多路mdio网关网络问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，介绍 以imx8mp为例，网关设备的phy分布如下，现在mac需要绑定一路mdio，可以是原生的mdio，也可以是gpio模拟模拟的。
当绑定到原生的mdio时，应用无法通过eth找到下面4个phy，所以要绑定到模拟mdio上。
当绑定到模拟的mdio时，mdio总线需要挂载下面4个任意一个phy。
如绑定phy1时，会遇到两个问题：
1，当phy1对应网口接入时，即phy1 link up 时mac才会工作。
2，当关闭eth打流时，会导致phy1停止工作，phy1与phy2打流不通。
二，解决 问题1： 修改phy_device.c源码，找到genphy_read_status函数，
屏蔽函数里的内容，添加如下：
phydev-&gt;speed = SPEED_100;
phydev-&gt;duplex = DUPLEX_FULL;
phydev-&gt;pause = 0;
phydev-&gt;asym_pause = 0;
speed配置根据实际需求，有SPEED_100百兆和SPEED_100千兆。
这样，当ifconfig eth up时，mac不会通过读phy寄存器就可以工作起来。
问题2： 添加一个虚拟phy，找到一个不用的phy id，在模拟mdio里添加如下节点：
ethphy_virt: ethphy-virt {
compatible = "ethernet-phy-ieee802.3-c22";
reg = &lt;0x9&gt;;
status = "okay";
};
然后，在mac网络节点里，phy-handle指定该虚拟phy节点，
phy-handle = &lt;&amp;ethphy_virt&gt;;
修改phy_device.c源码，找到get_phy_id函数，在函数最前面对phy地址进行判断，
如果为0x9，则对这个虚拟phy设置一个假的phy id，然后返回成功。
if(0x9==addr){
*phy_id = 0x1234;
return 0;
}
这样，通过添加一个虚拟phy，当ifconfig eth down，关闭的是这个虚拟phy，不会影响到实际phy。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3e13ced3cdfffa3f777e07e23f9373/" rel="bookmark">
			听GPT 讲Prometheus源代码--rules
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prometheus的rules目录主要包含规则引擎和管理规则的文件:
engine.go 该文件定义了规则引擎的接口和主要结构,包括Rule,Record,RuleGroup等。它提供了规则的加载、匹配、评估和结果记录的功能。
api.go 定义了用于管理和查询规则的RESTful API,包括获取、添加、删除规则等方法。
recording.go 定义了记录规则结果的结构,如记录值、标签等。也提供了将记录结果写入时序数据库的接口。
parser.go 解析PromQL规则语句,将规则语句解析为Rule结构体。
notifications.go 定义了Alertmanager通知规则的结构,以及将匹配Alert传递给Alertmanager的方法。
manager.go 实现rules.Engine接口,提供完整的规则管理功能,包括从配置文件加载规则、定期重新加载规则等。
testdata/ 包含测试规则样本,为测试规则引擎提供支持。
registry.go 定义了规则注册表,用于跟踪所有规则及其当前状态,支持规则间依赖管理。
queue.go 定义了规则匹配和评估队列,实现规则评估的并发执行。
总体来说,rules包提供了完整的规则定义、解析、加载、匹配、评估和结果处理的功能,是Prometheus重要的定时查询和动作触发能力的核心组件。
Prometheus的scrape目录主要包含下列文件,用于实现定期 scrape目标并获取其指标:
config.go 解析配置文件中的 targets 配置,生成 ScrapeConfig 结构体。
manager.go 实现 ScraperManager 接口,管理所有 ScrapeConfig 的执行。
ENGINE.go 定义抽象的 Scraper 接口和存储结构。
scraper.go 实现具体的 Scraper 接口,负责单个 target 的指标采集工作。
targetmanager.go 管理目标实例,支持自动估算实例标签等功能。
http.go 对 HTTP 协议的目标进行采集,支持自定义标签和验证等功能。
machine.go 采集机器相关指标,如 CPU、内存等。
docker.go 采集 Docker 容器相关指标。
kubernetes.go 采集 Kubernetes 相关指标。
blackbox.go 实现黑盒监控,对外部不开放接口的服务进行采集。
zookeeper.go 采集 Zookeeper 相关指标。
scrape 包实现了灵活的指标采集方式,支持多种协议以及自动识别实例标签。通过预定义的 Scraper 实现向目标获取指标,并定期执行信息采集任务。它是 Prometheus 核心功能之一。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd3e13ced3cdfffa3f777e07e23f9373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a402e14711030a1fe6630dc425e436d7/" rel="bookmark">
			win10的pycharm开发工具使用Jupyter的各种报错：环境问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 在win10系统的pycharm开发工具使用Jupyter的各种报错，却一直解决不了。
我一度使用过购买云服务器、重装系统等等各种办法，都没能解决。
例如：在speech_processing.ipynb文件中
import librosa y, sr = librosa.load('C:/Test/0001.mp4', sr=16000) mel_spec = librosa.feature.melspectrogram(y=y,sr=sr,n_mels=128).T print(mel_spec.shape) # 25ms 运行报错：
NameError Traceback (most recent call last) Cell In[1], line 1 ----&gt; 1 mel_spec = librosa.feature.melspectrogram(y=y,sr=sr,n_mels=128).T 2 print(mel_spec.shape) # 25ms NameError: name 'librosa' is not defined 我明明是安装好了bilrosa，并且import过了的，但是他还是报错。 二、原因 归根结底，其实就是win10系统的pycharm开发工具，对jupyter支持的不好，才会出现各种莫名奇妙的错误。
我将上述代码复制到libroTest.py文件中，运行就不存在任何问题。
非常完美的解决了问题。
三、解决办法 不要在win10系统中，用pycharm开发工具，使用jupyter进行开发，出现问题，解决不了。
直接使用.py文件进行代码编写，进行开发即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9407465b5d671d895a09296716ab30d0/" rel="bookmark">
			微信支付Native（一）准备和相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：微信支付Native（一）准备和相关知识 – 编程屋
目录
1 需要准备相关参数
2 支付安全
2.1 对称加密和非对称加密
2.2 数字签名
2.2.1 摘要算法
2.3 数字证书
1 需要准备相关参数 1）获取商户号
微信商户平台：https://pay.weixin.qq.com/
场景：Native支付
步骤：提交资料=》签署协议=》获取商户号
2）获取APPID
微信公众平台：https://mp.weixin.qq.com/
步骤：注册服务号=》服务号认证=》获取APPID=》绑定商户号
3）获取API秘钥
API版本的接口需要此秘钥
步骤：登录商户平台=》选择账户中心=》安全中心=》API安全=》设置API秘钥
4）获取APIV3秘钥
APIv3版本的接口需要此秘钥步骤：登录商户平台=》选择账户中心=》安全中心=》API安全=》设置APIv3秘钥
5）申请商户API证书
APIv3版本的所有接口都需要；APIv2版本的高级接口需要（如：退款、企业红包、企业付款）
步骤：登录商户平台=》选择账户中心=》安全中心=》API安全=》申请API证书
2 支付安全 2.1 对称加密和非对称加密 按照秘钥的使用方式，加密可以分为两大类：对称加密和非对称加密
1)对称加密：加密和解密的时候秘钥都是同一个，对称加密算法常见的有:
AES加密算法，秘钥长度128、192或256、安全强度很好，性能很高。
加密分组模式：将明文分组加密，微信支付中使用AEAD_AES_256_GCM
优点：运算速度快
缺点：秘钥需要信息交换的双方共享，一旦被窃取，消息就会被破解
2)非对称加密
非对称加密有两个秘钥，一个是公钥，一个是私钥，两个秘钥不同。
使用公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。其中RSA算法加密算法就是最著名的非对称加密算法。
优点：私钥严格保密 ，公钥任意分发，黑客获取公钥无法破解密文
缺点：运算速度非常慢
一般情况下：如果要保证信息传输的安全性，一般都是对称加密和非对称加密互相结合的。例如：我们可以利用非对称加密传输对称加密所需的秘钥，那么后期的交换过程就可以安全的使用对称加密进行了，这样既能保证对称加密的秘钥不会在传输的过程被拦截，又能保证在后续传输的过程中加密和解密的效率。https底层使用的就是这个原理。
举例：Bob有两把钥匙，一把公钥和一把私钥。Bob将自己的公钥分给自己的三个朋友，一人一把。
如果Susan想要给Bob写信，Susan将信件的内容用公钥加密发给Bob，Bob收到信件之后，用私钥进行解密，就可以看到信件的内容。（只要私钥不泄漏，Bob的朋友都可以给Bob写信，即使信件被截获，敌人也无法获取知道信件的内容）
这个时候大家可以发现，我们写信的时候用的是公钥加密，私钥解密。但是如果我们反过来用私钥加密，公钥解密会发生什么事情呢？
这个时候，当Bob用私钥进行信息加密的时候，持有Bob公钥的朋友都可以对信件进行解密，所以可以发现，当用私钥加密，公钥解密的作用其实就是身份认证。
2.2 数字签名 2.2.1 摘要算法 摘要算法，也是常说的散列函数、哈希函数，它能够将任意长度的数据“压缩”成固定长度。而且独一无二的“摘要”字符串，这好像是给这段数据生成了“指纹”。
作用：保证信心的完整性
特性：
不可逆：只有算法，没有秘钥，只能加密，不能解密难题友好性：想要破解，只能暴力枚举发散性：只要对原文进行一点点改变，摘要就会发生剧烈变化抗碰撞性：原文不同，计算后的摘要也不同。 常见的摘要算法：MD5、SHA1、SHA2
Bob写完信之后，先用摘要算法生成信件原文的摘要（message Digest）bob将摘要附在信件原文的下面，一起发送给pat。
pat接受信之后，使用和Bob一样的摘要算法，加密信件的原文，得到信件的摘要，然后Pat将加密后的摘要和Bob在原文中附加的摘要做一下对比，如果一致说明信件是没有被篡改过的。（但是这种做法存在安全隐患，如果黑客截取了信件并且直接修改了原文，根据原文生成了新的摘要，那么接受者这时候是辨别不出来的）
所以说摘要算法不具有机密性
Bob写完信件之后，先用摘要算法生成信件的摘要，bob使用自己的私钥将摘要加密加密后的结果（加密后的结果称为数字签名）bob将数字签名附在信件下面，一起发给pat。
pat收到信件之后 ，用公钥解密得到信件的摘要，然后pat使用和bob一样的加密算法加密信件的原文，得到信件的摘要，然后比对二者是否一致，如果一致，那么信件就是Bob发的且没有经过篡改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9407465b5d671d895a09296716ab30d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4c3a0e5d453b68ab6eefd63237f266/" rel="bookmark">
			torch.cuda.is_available()为false的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、问题 在进行torch进行开发的过程中，我们习惯性的会使用pip install torch这样的方式来安装torch的包。
其实这样的是安装CPU的torch。
在导入包，执行下面代码的过程中，会出现结果为false。
import torch print(torch.cuda.is_available()) 二、原因 在torch的官网说的很清楚。
要安装CUDA版本的必须要指定下载的地址
执行如下代码
pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu117 如果你只想安装CPU版本的torch，可以执行如下代码。
pip3 install torch torchvision torchaudio 三、解决方式 执行下面代码：
pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu117 输出结果为true
print(torch.cuda.is_available()) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d20dc1457c92f98857f0fa59b652d3/" rel="bookmark">
			谷歌插件开发介绍，谷歌插件开发的流程，谷歌插件开发需要会哪些知识？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌插件开发介绍： 谷歌插件是一种专为Google Chrome浏览器设计的软件应用程序，可以向浏览器中添加新的特性或功能，或者对现有的功能进行增强或改变。插件开发需要了解Web技术，包括HTML、CSS和JavaScript，同时还需要学习一些特定的Google Chrome插件开发知识，比如Chrome的API、插件的生命周期、消息传递机制等。开发出的插件可以在Chrome Web Store发布和更新，用户可以方便地下载和安装。
谷歌插件开发流程： 了解和掌握Chrome插件开发的基础知识和相关API。选择开发语言和开发环境，常见的有HTML和JavaScript，开发环境可以选择Google Chrome的开发者工具。确定插件的功能和目标用户，并进行市场需求分析。设计插件的界面和交互方式，考虑用户体验和易用性。编写插件的代码，并进行测试和调试。在Chrome Web Store上创建和发布插件，并进行市场推广和用户反馈处理。 谷歌插件开发需要会的知识： HTML：用于构建网页的基本结构。CSS：用于美化网页的样式。JavaScript：用于实现网页的交互功能。Chrome API：用于实现插件的特定功能，比如浏览器操作、网页操作等。插件生命周期：了解插件的生命周期，包括加载、运行、挂起等状态，并相应地进行处理。消息传递机制：了解如何在插件的不同部分之间进行消息传递和处理。用户体验设计：了解如何设计插件的用户界面和交互方式，提高用户体验。代码调试和测试：了解如何进行代码调试和测试，保证插件的稳定性和可靠性。 当然，除了上述基础知识，谷歌插件开发还需要了解以下内容：
浏览器扩展性：了解如何使用Chrome的API扩展浏览器的功能，比如添加新的浏览器命令、修改浏览器标签等。用户权限：了解Chrome插件开发中用户权限的使用，比如请求访问剪贴板、请求摄像头等。插件国际化：了解如何为不同地域的用户提供本地化支持。安全和隐私：了解如何保护用户隐私和避免恶意攻击，比如通过HTTPS进行安全通信、避免跨站脚本攻击等。性能优化：了解如何优化插件的性能，包括加载速度、运行效率等。版本控制和更新：了解如何进行插件的版本控制和更新，包括自动更新和手动更新等。插件营销：了解如何进行插件的营销和推广，包括在Chrome Web Store上的宣传和在其他渠道的推广等。 总之，谷歌插件开发需要掌握多种技能和知识，需要不断学习和实践。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69209aaaa65ad2e3de9814320556e938/" rel="bookmark">
			pip install xxx:There was a problem confirming the ssl certificate: HTTPSConnectionPool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 在使用Pip install xxx的时候，经常会报这样的一个错误。
(myenv) PS E:\WorkSpace\1v6_code_fs&gt; pip3 install torch ction has been closed (EOF) (_ssl.c:1131)'))': /simple/torch/ WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'SSLError(SSLZeroReturnError(6, 'TLS/SSL conne ction has been closed (EOF) (_ssl.c:1131)'))': /simple/torch/ WARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'SSLError(SSLZeroReturnError(6, 'TLS/SSL conne ction has been closed (EOF) (_ssl.c:1131)'))': /simple/torch/ WARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'SSLError(SSLZeroReturnError(6, 'TLS/SSL conne ction has been closed (EOF) (_ssl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69209aaaa65ad2e3de9814320556e938/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff380d2b3b4692bc05427f4ebd2a7a5f/" rel="bookmark">
			【Math】特征值和奇异值辨析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		奇异值和特征值都描述了一个矩阵的一些特性，但很多情况下，对于两者之间的区别和联系都不太清楚。
本文就这两者进行解析，并对奇异值的一些简单应用进行探索。
奇异值与特征值的定义 奇异值与特征值都被用于描述矩阵作用于某些向量的标量，都是描述该向量模长变化幅度的数值。矩阵与向量的乘积得到一个新的向量，几何上相当于对向量进行了旋转和拉伸，就像是对向量施加了一个作用，或者说是变换。
定义：
如果有向量 v v v能使得矩阵 A A A与之的积 A v = λ v Av=\lambda v Av=λv， λ \lambda λ为标量，那么 λ \lambda λ和 v v v就分别是 A A A的特征值与特征向量如果存在单位正交矩阵 U U U和 V V V，使得 A = U D V T A=UDV^T A=UDVT， D D D为对角矩阵，对角线上的值被称为奇异值， U U U和 V V V中的列分别被称为 D D D的左奇异向量和右奇异向量 特征值只能在方阵中进行，而奇异值则没有这个限制。
如果考虑矩阵的维度，奇异值的定义为：
对于一个秩为 r r r的矩阵 A m ∗ n A_{m*n} Am∗n​，必存在 m ∗ m m*m m∗m的正交矩阵 U m ∗ m U_{m*m} Um∗m​， n ∗ n n*n n∗n的正交矩阵 V n ∗ n V_{n*n} Vn∗n​， m ∗ n m*n m∗n的矩阵 D m ∗ n D_{m*n} Dm∗n​，使得：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff380d2b3b4692bc05427f4ebd2a7a5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa670598b2059fe0ee4e0cee82a7b8a6/" rel="bookmark">
			Centos安装搜狗输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、切换到root
2、卸载ibus（如果已经卸载，可以忽略该步骤）
3、安装epel源
4、安装fcitx
5、安装拼音输入法
6、安装依赖包
7、安装搜狗输入法
8、安装Alien
9、deb包 转 rpm包 (在deb包目录下或指定deb包目录)
10、安装转换的rpm包
11、进行软链接
12、修改权限
13、配置修改/etc/profile
14、弹出输入法配置框
15、添加开机自启动
16、reboot重启虚拟机，可以看到右上角的键盘标志
1、切换到root #su root 2、卸载ibus（如果已经卸载，可以忽略该步骤） #rpm -e --nodeps ibus 3、安装epel源 #yum -y install epel-release 4、安装fcitx #yum -y install fcitx fcitx-configtool 5、安装拼音输入法 #yum -y install fcitx-pinyin 6、安装依赖包 #yum -y install dpkg #yum -y install qtwebkit #yum -y install fcitx-qt5 fcitx-configtool 7、安装搜狗输入法 #wget http://cdn2.ime.sogou.com/dl/index/1524572264/sogoupinyin_2.2.0.0108_amd64.deb 或去官网下载，官网提供的是deb包：
8、安装Alien #yum -y install alien 9、deb包 转 rpm包 (在deb包目录下或指定deb包目录) #alien -r --scripts sogoupinyin_4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa670598b2059fe0ee4e0cee82a7b8a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2138d7b6f215f84962d05c7863bfeebe/" rel="bookmark">
			6、基于51单片机环境监测 wifi 温湿度光照粉尘PM2.5检测app（原理图&#43;PCB图&#43;程序&#43;开题报告&#43;参考论文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计简介： 本设计是基于51单片机环境监测 wifi 温湿度光照粉尘PM2.5检测app系统，主要实现以下功能：
1. 本设计基于STC89C51/52（与AT89S51/52、AT89C51/52通用）。
2. LCD12864液晶实时显示当前环境中的温度值、湿度值、光照度，粉尘pm2.5值，它们并且以中文显示。
3. DHT11采集温湿度数据，以数字信号传给单片机处理；光敏电阻随光照强度变化将模拟电压信号通过ADC0832进行模数转换成数字信号给单片机处理。
4. 通过按键对温度、湿度、光照进行上下限调节，并且保存在单片机内部，掉电保存。
5. 设计带有esp8266 wifi模块，在液晶显示的同时将信号传到手机APP进行同步显示。
6. 当环境中温度、湿度、光照任意一项不在设定阈值内，启动继电器模拟和蜂鸣器报警。
7. 灰尘传感器GP2Y1010AU0F实时监测pm2.5的值，并在显示屏上显示出来。
主要硬件组成：
51单片机最小系统电路（复位电路+晶振时钟电路+单片机电源电路）+按键+12864液晶显示屏+DHT11温湿度传感器，粉尘pm2.5传感器，光敏电阻+总电源供电电路+继电器+风扇+wifi模块ESP8266+蜂鸣器+ADC0832芯片
二、原理图 三、PCB图 四、资源获取 本项目包含的所有文件都可以点击下面的名片，发送 “ 6、基于51单片机环境监测 wifi 温湿度光照粉尘PM2.5检测app” 获取！
项目纯手打，不是免费的哦~
希望可以帮到你哈！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d13c8ec1b3bd0277798d9e942f4c5e/" rel="bookmark">
			前端js给pdf文件添加印章，前端使用PDF.js获取pdf文件的坐标位置，后端使用C# iTextSharp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老年新手一枚，一直以来都是在网上cv大神们的代码。内心既感激又崇拜。最近在工作中遇到一个问题，需要在电子文档里添加印章，所以，开始接触到pdf.js插件。
PDF.js 官网：PDF.js。
百度了一下，找到第一种方法是通过获取点击点的标签文本，然后后台使用iTextSharp通过关键字查询获取关键词坐标点。这种办法虽可实现功能，但是缺点是非常不灵活，体验也不好。
所以长时间研究查询后，决定在通过获取鼠标点击点相对于pdf文档的坐标来实现项目要求。
如何使用pdf.js打开文档等相关操作，这里不做赘述。
直接进入主题，使用pdf.js的默认展示页面viewer.html打开一个文档后，查看源码找到id="viewerContainer"的元素标签，仔细观察发现pdf文件的每一页内容对应一个class="page"的标签，而每一个page标签下有一个class="canvasWrapper"的元素（里面包含一个canvas元素和一个class="textLayer"的div元素）。注意每个元素的属性，这些属性可以帮助我们更容易获取到坐标。
在class="textLayer"的元素里，pdf文档的每段内容都是一个span元素，元素中有role="presentation"的属性，style样式中有left和top两个属性，并且是百分比值。如下图。
当鼠标点击事件的target元素是role="presentation"的span元素时，直接获取style的left和top属性值即可。这也就大概获取到了鼠标点击点相对于pdf页左上角的坐标。
当点击到pdf页的空白位置时，则需要通过点击事件的target元素的offsetWidth ，offsetHeight属性来获取坐标值，再除以class="textLayer"的元素的宽高获取坐标百分比。
鼠标点击点的坐标已获取到，那么通过iTextSharp在坐标点添加印章则水到渠成。
另外需要注意的是在js中坐标原点为左上角，而iTextSharp中，坐标原点为左下角。因此，在前端js中获取到的纵坐标需要使用差值。
好的，第一次发表文章，希望对大家有些帮助，若有更好的方法，希望能不吝赐教。大家一起进步。能混到一口更好的饭。哈哈。
本文为原创，如需转载，请注明作者及出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062a561f378c37682d97bde0af127697/" rel="bookmark">
			idea安装插件JRebel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装插件 二、下载代理服务并启动 首先下载服务，网址 Releases · ilanyu/ReverseProxy (kgithub.com)
下载后直接双击运行，杀毒软件可以会报警告，直接忽略就行
启动好，等着就行，接下来会用到。
三、在线获取GUID 网址：
在线GUID地址
如果失效刷新重新获取就行！
四、配置JRebel activated 这一步会用到上面两步配置的东西。
按照上图序号的顺序进行点击，弹窗配置
按照上图的序号进行配置点击。点击确认之后，会发现第三步的应用控制台有日志输出，如下图：
此时，就可以把第三步打开的软件，给关闭了。
配置说明：
序号1的参数：http://127.0.0.1:8888/这个地址，就是第三步打开的代理地址。后面的一串字符，就是第四步生成的GUID。
序号2的参数：邮箱，可以是自己的邮箱，也可以随意些个邮箱，符合邮箱规则即可。
序号3：勾选框选中。
序号4:确认，不报错，则证明成功。
到这一步，JRebel就可以正常使用了。以下步骤就是一些常规的设置了。
五、设置离线工作模式 六、设置自动编译 要想实现热部署，需要对idea进行如下配置：
1. JRebel是实时监控class文件的变化来实现热部署的，所以在idea环境下需要打开自动编译功能才能实现改及生效。
将上图红框勾选上。
七、使用 运行项目时，就可以使用JRebel运行项目了，如下图：
修改代码（只测试了Java代码的修改）后，按快捷键 Ctrl + Shift + F9，运行后会提示有变化是否重新加载，选yes。完成加载以后，就已经实现了热更新效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311d9b76a07a6bfe67a90655f0ef7c93/" rel="bookmark">
			如何设置 javaagent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java应用程序中，可以使用Java代理（Java Agent）来在运行时修改或增强字节码，从而实现各种功能，例如性能监控、日志记录、代码注入等。下面是设置Java代理的一般步骤：
创建一个Java代理项目：创建一个新的Java项目，并确保项目中包含所需的构建和依赖项。
编写代理代码：在Java代理项目中编写代理代码。代理代码可以使用Java字节码操作库（如ASM、Byte Buddy等）来修改目标应用程序的字节码。代理代码可以根据需求进行定制，以实现所需的功能。
打包代理项目：将Java代理项目打包成一个JAR文件。确保JAR文件包含了所有必需的类和资源文件。
将代理JAR文件与目标应用程序一起部署：将代理JAR文件与目标应用程序放置在同一个目录下或将其添加到目标应用程序的类路径中。
启动目标应用程序时加载代理：在启动目标应用程序时，使用Java虚拟机的-javaagent参数来加载代理。该参数指定代理JAR文件的路径。例如：
java -javaagent:/path/to/agent.jar -jar YourApplication.jar 请将/path/to/agent.jar替换为代理JAR文件的实际路径。
代理生效：代理JAR文件将在目标应用程序启动时被加载，并且代理代码将开始修改目标应用程序的字节码。根据代理的功能，相应的增强或修改将生效。
需要注意的是，Java代理的具体实现方式可能因使用的字节码操作库而有所不同。不同的字节码操作库可能有不同的API和用法。因此，在编写代理代码时，需要参考所选字节码操作库的文档和示例。
此外，还可以考虑使用现有的Java代理工具，如Byteman、AspectJ等。这些工具提供了更高级的功能和更简化的配置选项，可以根据具体需求选择合适的工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db78e818e0bf9fe6c402aa957d4e2ee/" rel="bookmark">
			奇迹MU服务端IGC架设流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		奇迹MU服务端IGC架设流程 大家好我是艾西，今天跟大家简单聊下奇迹IGC服务端。IGC端是国外的东西全英文大家感兴趣的话也可以自己研究研究，整体的东西还是非常完整。扩展以及端的稳定性还是非常不错的就是有点费脑子........（此教程为个人娱乐搭建测试）
对于很多奇迹老玩家来说，从开始玩奇迹到现在应该都有十年以上，十年，太多的人、太多的事变化了，快到找不到影子，但值得庆幸的是，依然有那么一些人和事，留在我们心中不变，奇迹就是这其中一个。今天各种游戏纷至沓来、各种抢眼，但奇迹依然是我们最爱的网络游戏之一，再过10年是否还有它一席之地，没有人知道，但此刻，你和我心意相通！愿每一个奇迹爱好者明天更好、万事胜意！
准备：服务端、服务器、一台有网的电脑
以s12为例子，奇迹端对外开放的对服务器还是有一定的要求。游戏类的追求稳定以及安全，所有的程序以及软件都是搭建在服务器里的，服务器配置够性能强防护高才能给玩家带来更好的体验！
服务器操作系统要求：win 2008 64位系统
在搭建奇迹的服务端时，经常有朋友遇到数据库不会还原的问题，今天有时间就分享一下还原数据库的具体操作方法。
本教程使用绿色版sql2008自带的还原工具，其他的数据库管理工具的还原方法基本上是大同小异。大家实际操作完之后自己也可以多试试
数据库的还原方式：
第一种：备份文件是.bak时的还原方法，这种备份文件的得来，是采用了一般的备份方式得来的如：MuOnline这个数据库的bak备份文件，一般叫MuOnline.bak
具体还原步骤：
1、建立一个数据库，记下这个数据库储存的路径：D:\Tools\GSQL2008R2\userdata\MuOnline.mdf
这个工具要记，其他的工具可能不需要记
2、导入备份文件进行数据库还原：
碰到导入不进来的情况，提示“无法处理的介质”之类的，是因为这个备份文件，原来使用的数据库版本较高，比我们现在使用的sql2008版本要高，所以无法导入进来，这种情况是没办法处理的，要不就换备份文件，要不就是装高版本的数据库.
我们采用换备份文件的方法创建一个新路径，与我们建数据库时的路径不一样再次导入试试
第二种：备份文件是.sql时的还原方法，这种备份文件得是备份时采用了导出sql数据方式备份的
如：MuOnline这个数据库的sql备份文件，一般叫MuOnline.sql
我们先把这个数据库删了，使用sql方式，还原一次
还原的步骤也是：
1、建立数据库
2、导入sql文件
导入sql备份文件，要用到sql查询工具，sql查询里选择我们刚才建的数据库MuOnline 打开sql文件，执行sql语句，数据比较多，执行会有点久
执行完了那么就OK了
第三种：备份文件是.mdf,一般还会同时带对应的log文件，log文件是同名但以_log.ldf为结尾，这种备份文件的得是直接复制数据库的数据文件得来的
（注：log文件，是数据库的日志，还原时可以不用log文件的，不用的话系统会自动生成一个新的log文件）
如：MuOnline这个数据库，对应的备份文件是MuOnline.mdf和MuOnline_log.ldf
先把原来的删掉还原步骤：把数据库备份文件，复制到你的数据库放数据文件的目录下，sql2008他是把数据文件放在 D:\Tools\GSQL2008R2\userdata\ 这个目录下的。附加数据库，到上面那个目录选择备份文件，填写数据库名，可以按默认的名字
这样就又还原成功了
（这个是题外话，下面正式进入我们今天的主题）
开始架设：
服务器win 2008系统
数据库MySql server 2008
这个端要恢复的数据库有四个，分别如下：
MuOnline
Ranking
BattleCore
Events
请对应备份文件一一进行恢复。
2. 修改几个文件，主要是设置对应的IP和数据库方面的，最终打通服务端和客户端的联系
2.1 服务端要修改的文件
(1) 修改文件： 1._DataServer\DataServer.ini
下面是这个文件要修改的地方，对应注释修改，没列出的选项请保持默认
//你的服务器IP，本次搭建用的103.219.xxx.xxx
WanIP = 103.219.xxx.xxx
// -------------------------------------------
// -- DATABASE &amp; Access SETUP
//数据库设置
// -------------------------------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db78e818e0bf9fe6c402aa957d4e2ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed795e60643b397e359d9ae764c1ce1/" rel="bookmark">
			1Panel上的免费WAF长亭雷池搭配openresty的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接： 1Panel上的长亭雷池WAF搭配openresty的用法
前言 最近把面板换成了国内公司出的但是开源的1panel，跑容器也是挺符合心里需求的，
主界面也挺干净整洁。看到第三方应用库有个免费WAF，然后又上了开源了但没完全开源的长亭雷池WAF。
记录一下在同一台机子上长亭雷池WAF搭配默认openresty的用法。
1. 调整openresty容器网络 需要将openresty修改为桥接网络模式。且修改https外部映射为其他端口如1443。
注意：改桥接端口之后，反向代理的思路就和使用Nginx Proxy Manager一样了，
不能写127.0.0.1:端口来反向代理了。 点击应用参数修改docker-compose.yml，重建openresty。
version: '3' services: openresty: image: openresty/openresty:latest #这里镜像注意对应自己的架构平台 container_name: ${CONTAINER_NAME} restart: always networks: - 1panel-network ports: - "${PANEL_APP_PORT_HTTP}:80" - "1443:1443" volumes: - ./conf/nginx.conf:/usr/local/openresty/nginx/conf/nginx.conf - ./conf/fastcgi_params:/usr/local/openresty/nginx/conf/fastcgi_params - ./conf/fastcgi-php.conf:/usr/local/openresty/nginx/conf/fastcgi-php.conf - ./log:/var/log/nginx - ./conf/conf.d:/usr/local/openresty/nginx/conf/conf.d/ - ./www:/www - ./root:/usr/share/nginx/html - /etc/localtime:/etc/localtime labels: createdBy: "Apps" networks: 1panel-network: external: true 2. 修改站点监听端口 站点正常配置，开启https啥的。
进入站点文件配置，修改https监听端口为1443，与外部端口一致。
可以按Ctrl F批量替换。其他配置可以不用动。
3. 雷池WAF添加站点 3.1 添加第三方库 然后应用商店安装雷池WAF
1Panel 应用商店的非官方应用适配库 以默认1Panel安装在/opt/路径下为例子，如果不是按需修改以下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ed795e60643b397e359d9ae764c1ce1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd515f6122c0cd77e959230658976dca/" rel="bookmark">
			网络安全这玩意儿真不建议一般人学...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作为一名5年网安工程师老菜鸟来说，我实在想不通，开发岗位那么多，为什么要来学网安?
在这里怕是要给准备入坑的同学泼盆冷水了，网络安全这东西真不建议一般人学…
基础确实很简单，是个人稍微认点真都能懂，这就是好多人说的网络安全简单、易懂、好学，然后就是一顿浮夸的言论，误导那些小白，再然后那些小白也就跟着浮夸。这就跟上学时听老师讲课一样，只要认真听，好像都能懂，一到考试起来自己做题的时候就一脸懵逼了。
​很多人上来就说想学习网络安全，但是连方向都没搞清楚就开始学习，最终也只是会无疾而终！安全领域是一个大的概念，里面包含了许多方向，不同的方向需要学习的内容也不一样。
如果你苦于没有方向，不知道从何学起，本篇文章有点长，希望你可以耐心看到最后
👉 黑客&amp;网络安全入门&amp;进阶学习资源包👈
学前感言 1.这是一条坚持的道路,三分钟的热情可以放弃往下看了.
2.多练多想,不要离开了教程什么都不会了.最好看完教程自己独立完成技术方面的开发.
3.有时多google,baidu,我们往往都遇不到好心的大神,谁会无聊天天给你做解答.
4.遇到实在搞不懂的,可以先放放,以后再来解决
零基础入门学习路线&amp;规划 企业级：初级网络安全工程师 1、网络安全理论知识 ①了解行业相关背景，前景，确定发展方向。
②学习网络安全相关法律法规。
③网络安全运营的概念。
④等保简介、等保规定、流程和规范。（非常重要）
2、渗透测试基础 ①渗透测试的流程、分类、标准
②信息收集技术：主动/被动信息搜集、Nmap工具、Google Hacking
③漏洞扫描、漏洞利用、原理，利用方法、工具（MSF）、绕过IDS和反病毒侦察
④主机攻防演练：MS17-010、MS08-067、MS10-046、MS12-20等
3、操作系统基础 ①Windows系统常见功能和命令
②Kali Linux系统常见功能和命令
③操作系统安全（系统入侵排查/系统加固基础）
4、计算机网络基础 ①计算机网络基础、协议和架构
②网络通信原理、OSI模型、数据 转发流程
③常见协议解析（HTTP、TCP/IP、ARP等）
④网络攻击技术与网络安全防御技术
⑤Web漏洞原理与防御：主动/被动攻击、DDOS攻击、CVE漏洞复现
5、数据库基础操作 ①数据库基础
②SQL语言基础
③数据库安全加固
6、Web渗透 ①HTML、CSS和JavaScript简介 ②OWASP Top10 ③Web漏洞扫描工具 ④Web渗透工具：Nmap、BurpSuite、SQLMap、其他（菜刀、漏扫等）
恭喜你，如果学到这里，你基本可以从事一份网络安全相关的工作，比如渗透测试、Web 渗透、安全服务、安全分析等岗位；如果等保模块学的好，还可以从事等保工程师。薪资区间6k-15k。
7、脚本编程（初级/中级/高级） 在网络安全领域。是否具备编程能力是“脚本小子”和真正黑客的本质区别。在实际的渗透测试过程中，面对复杂多变的网络环境，当常用工具不能满足实际需求的时候，往往需要对现有工具进行扩展，或者编写符合我们要求的工具、自动化脚本，这个时候就需要具备一定的编程能力。在分秒必争的CTF竞赛中，想要高效地使用自制的脚本工具来实现各种目的，更是需要拥有编程能力。
零基础入门，建议选择脚本语言Python/PHP/Go/Java中的一种，对常用库进行编程学习； 搭建开发环境和选择IDE,PHP环境推荐Wamp和XAMPP， IDE强烈推荐Sublime； ·Python编程学习，学习内容包含：语法、正则、文件、 网络、多线程等常用库，推荐《Python核心编程》，不要看完； ·用Python编写漏洞的exp,然后写一个简单的网络爬虫； ·PHP基本语法学习并书写一个简单的博客系统； 熟悉MVC架构，并试着学习一个PHP框架或者Python框架 (可选)； ·了解Bootstrap的布局或者CSS。
8、高级网络安全工程师 这部分内容对零基础的同学来说还比较遥远，就不展开细说了，贴一个大概的路线。感兴趣的童鞋可以研究一下
​​一些我收集的网络安全自学入门书籍 ​ 一些我自己买的、其他平台白嫖不到的视频教程：
结语 网络安全产业就像一个江湖，各色人等聚集。相对于欧美国家基础扎实（懂加密、会防护、能挖洞、擅工程）的众多名门正派，我国的人才更多的属于旁门左道（很多白帽子可能会不服气），因此在未来的人才培养和建设上，需要调整结构，鼓励更多的人去做“正向”的、结合“业务”与“数据”、“自动化”的“体系、建设”，才能解人才之渴，真正的为社会全面互联网化提供安全保障。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd515f6122c0cd77e959230658976dca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18010720fe8b448884d777bd42d93318/" rel="bookmark">
			BGP属性&#43;选路规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，BGP的属性—基础属性
1.PrefVal
2.LocPrf
3、优先本地下一跳 （NextHop） 4、AS-PATH 5、起源属性 6、MED -多出口鉴别属性 二，BGP选路规则
三，BGP的社团属性
一，BGP的属性—基础属性 1.PrefVal 传播范围 默认值 大/小优
PrefVal（权重属性） 不传播 0（0-65535） 大
该属性为私有属性（华为），仅本地有效
本地所有通过4.4.4.4邻居学习到的BGP路由，优先级全部修改为1；
[r3]bgp 2
[r3-bgp]peer 4.4.4.4 preferred-value 1 负载均衡: 访问同一个目标，存在多条开销相似路径时，让设备将流量分担后延
多条路径同时传输；
等开销负载均衡: 负载均衡时，必须开销相同；
路由策略来实现—在BGP路由控制层面传递的过程中，抓取路由修改属性
负载分担：访问不同目标时，让路由器选择不同的路径；起到所有路径被使用效果；
[r3]ip ip-prefix p permit 1.1.1.0 24 抓住网络号
[r3]route-policy p permit node 10 定制策略
[r3-route-policy]if-match ip-prefix p 匹配流量
[r3-route-policy] apply preferred-value 1 修改优先级属性
[r3-route-policy]q
[r3]route-policy p permit node 20 由于路由策略存在分发列表的功能，必须考虑空表
[r3-route-policy]q
[r3]bgp 2
[r3-bgp]peer 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18010720fe8b448884d777bd42d93318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5218c36bf14c51f2309439a8f907f4a6/" rel="bookmark">
			开发工具 之七 Visual Studio Code 中 C/C&#43;&#43; 调试配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备 默认情况下，VSCode 仅仅内置了对 node.js 运行时的调试支持，只可以直接调试 JavaScript、TypeScript 和任何其他翻译为JavaScript 的语言。其他语言的调试支持，都是以插件的形式提供支持。为了能够调试 C/C++，必须首先安装插件：ms-vscode.cpptools。直接在 VSCode 的插件库中安装即可。
C/C++插件是负责与 VSCode 的调试规约打交道的，实际的调试必须有对应的调试器。目前在 Windows 下，VSCode支持GDB、LLDB、VC调试器。
调试配置 首先下载 GDB 环境。下载MinGW-w64（目前最新版为 5.01）。下载后将bin目录添加到环境变量中。如下图：
也可以选择 MinGW 或者 Cygwin。
VSCode 的调试使用起来很简单，如下图所示：
VSCode 的特色之一就是原生支持在线调试功能。VSCode 提供了两种调试方式：Launch和Attach。因此，在自动生成的配置文件中，这两种方式都会有。使用者需要那种配置哪一种即可，当然可以都配置好。这里，我们选择C++(GDB/LLDB)之后，VSCode会自动生成lanuch.json的文件，如下：
{ "version": "0.2.0", "configurations": [{ "name": "C++ Launch",	// 配置名称，将会在调试配置下拉列表中显示 "type": "cppdbg",	// 调试器类型：Windows表示器使用cppvsdbg；GDB和LLDB使用cppdbg。该值自动生成 "request": "launch",	// 调试方式 "program": "${workspaceRoot}/main.exe",	// 要调试的程序（完整路径，支持相对路径） "args": [],	// 传递给上面程序的参数，没有参数留空即可 "stopAtEntry": false,	// 是否停在程序入口点（停在main函数开始） "cwd": "${workspaceRoot}",	// 调试程序时的工作目录 "environment": [], "externalConsole": true,	// 调试时是否显示控制台窗口 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5218c36bf14c51f2309439a8f907f4a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/667d31fdcf8128bb6565615f42a8f6cd/" rel="bookmark">
			华为ensp模拟器基础配置命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，用户模式 1.1，用户模式，只能做一些简单的查看操作
&lt;Huawei&gt; #用户模式 1.2，进入系统模式
&lt;Huawei&gt;system-view #简写sys [Huawei] #系统模式 2，基础操作命令 2.1，修改设备名称 进入系统模式下 [Huawei]sysname R1 2.2，进入接口 在系统模式下进入接口模式，配置IP地址 [Huawei]interface GigabitEthernet 0/0/0 可简写为以下命令 [Huawei]int g 0/0/0 端口解析： [Huawei]interface GigabitEthernet 0/0/0
interface: 接口Ethernet：接口类型0/0/0：第一个"0"代表槽位号，第二个“0”代表子卡号，第三个“0”代表端口号 2.3，配置IP地址 进入接口模式，配置IP地址 [Huawei-GigabitEthernet0/0/0] [Huawei-GigabitEthernet0/0/0]ip address 192.168.1.1 255.255.255.0 返回上一级 quit 保存当前配置,在用户模式下进行 &lt;Huawei&gt;save #保存当前配置 &lt;Huawei&gt;reboot #重启设备 &lt;Huawei&gt;reset saved-configuration #清除当前的设备配置 2.4，常见的查看操作 &lt;Huawei&gt;display version 查看版本信息 &lt;Huawei&gt;display current-configuration 查看本设备当前的配置 &lt;Huawei&gt;dis mac-address 查看MAC地址表 &lt; Huawei &gt; display elabel 查看设备型号 #中文切换：
&lt;Huawei&gt;language-mode Chinese 2.5，console口令 配置明文console口令 [Huawei]user-interface console 0 进入console 0 唯一端口 [Huawei-ui-console0]authentication-mode password 启用密码 [Huawei-ui-console0]set authentication password simple 123 设置密码为123 配置密文console口令 [Huawei]user-interface console 0 #进入console 0 唯一端口 [Huawei-ui-console0]authentication-mode password #启用密码 [Huawei-ui-console0]set authentication password cipher 123 #设置密码为123 Simple 明文Cipher 密文 取消console密码： [Huawei]user-interface console 0 #进入console 0 唯一端口 [Huawei-ui-console0]undo set authentication password #取消密码 配置自动退出超时时间： [Huawei]user-interface console 0 #进入console唯一端口 [Huaw：ei-ui-console0]idle-timeout 1440 #设置分钟#防止弹出信息干扰命令： #防止弹出信息干扰命令： &lt;Huawei&gt;undo terminal monitor 设置用户视图 [Huawei]undo info-center enable 设置系统视图 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/667d31fdcf8128bb6565615f42a8f6cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2a06914398fdda075c15235da700bf/" rel="bookmark">
			1的平方加2的平方一直加到n的平方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天写一个算法题要计算某一表达式运行次数，一下子忘记了1的平方加2的平方一直加到n的平方的计算公式了，决定自己推导一下，于是发现可以有如下思路，记录如下：
Sn = 12 + 22 + 32 + …… + n2，求Sn
对Sn使用类似求导的思路（具体应该这个玩意儿不叫求导），发现函数的变化率为：
S’n = 2*1 + 2*2 + 2*3 + …… + 2*n = n(n+1)
于是发现Sn的导数是一个二次式，我们不妨假设Sn的表达式为：
Sn = a*n3 + b*n2 + c*n + d
将下列的四个结果代入解析式，去求a,b,c,d
n = 1,Sn = 1;
n = 2,Sn = 5;
n = 3,Sn = 14;
n = 4,Sn = 30;
最后求得：
a = 1/3
b = 1/2
c = 1/6
d = 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e2a06914398fdda075c15235da700bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ec35f5018dfa3401f9ea1cc0397de3/" rel="bookmark">
			被 GPT 带火的 Prompt 是什么？怎么成为Prompt工程师？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能技术的不断发展，语言模型成为了近年来研究的热点领域之一。GPT系列模型的出现，使得Prompt成为了热门话题。那么，什么是Prompt，以及如何成为Prompt工程师呢？
一、什么是Prompt？
Prompt是AI生成图像或者对话聊天的短文本提示词，旨在为语言模型提供指导性的提示，以产生更加准确和可控的输出。Prompt可以理解为一种“指令”，它能够提供一些关键词或者场景信息，帮助语言模型更好地理解用户输入的问题或需求，从而生成更加准确、符合要求的回答或图像。
二、成为Prompt工程师需要具备哪些技能？
熟练掌握自然语言处理和机器学习基础知识。Prompt工程师需要了解自然语言处理的基本概念和方法，如分词、词性标注、命名实体识别等，以及机器学习算法的原理和应用。
熟悉常见的深度学习框架和编程语言。Prompt工程师需要熟悉深度学习框架如PyTorch、TensorFlow等，并掌握至少一种编程语言，如Python、Java等。
掌握Prompt设计技术和评估方法。Prompt工程师需要了解常见的Prompt设计技术，如模板、指令、问答等，并掌握Prompt的评估方法和工具。
具备相关领域的知识和技能。根据不同的应用场景和需求，Prompt工程师需要具备相关领域的知识和技能，如法律、医学、金融等领域的专业术语和知识。
具有良好的沟通和团队合作能力。Prompt工程师需要与团队成员和业务人员进行有效沟通，理解需求和问题，并能够提供优质的解决方案。
三、如何成为Prompt工程师？
学习相关知识和技能。可以通过阅读书籍、学术论文、技术博客等途径，学习自然语言处理、机器学习、深度学习等领域的知识和技能。
参加相关的培训课程或在线课程。可以参加深度学习、自然语言处理等相关的培训课程或在线课程，了解Prompt的基本原理和应用。
实践练习和项目经验。可以通过实践练习和参与项目，积累Prompt设计和评估的经验，提高自己的技能水平。
参加技术社区和讨论组。可以参加与Prompt相关的技术社区和讨论组，与其他从业者交流经验和技巧，了解最新的技术动态和趋势。
关注行业动态和招聘信息。可以关注行业动态和招聘信息，了解Prompt工程师的需求和市场情况，为自己的职业规划提供参考。
总之，成为Prompt工程师需要不断学习和实践，掌握相关的知识和技能，具备灵活的思维和创新能力，能够根据不同场景和需求进行灵活运用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad290181a4ad77dd7b71f4f0a1ad6db/" rel="bookmark">
			开发工具 之三 Python 新手安装详解 、修改 pip 默认包安装位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直是搞底层相关的东西，目前，需要研究一下Python，特此记录！
下载 首先需要说明的是，Python 是开源跨平台的，不同系统下的安装区别较大。Python最新源码、安装包，新闻资讯等可以在Python的官网 https://www.python.org/ 查看到。你还可以在以上链接中下载 Python 的文档， HTML、PDF 和 PostScript 等格式的文档等等各种资料。
从上面下载下来的默认为32位的，如果要下载64位的，这需要如下图进行查找
点击对应版本后，会出现对应版本的详细介绍页面，将滚动条拉倒最后，就会发现针对各平台的下载文件
这样就得到了 Python 的安装包了！
Windows 下面重点介绍 Windows 下的安装。其他平台后续有用到在完善。
安装 直接双击安装包，就会出现以下界面
其中，最好选择上 Add Python xxx to PATH，否则后续还得自己将 Python 添加到 Windows 的环境变量中。还有个默认选择的 Install launcher for all users(recommended)，这个也是有用的，尤其是在安装了不同版本的 Python 时。这个东西后面在详细说明。然后，直接点击Customise installation，出现如下界面
上面的界面中，默认所有内容都是被选择的。至于每个是啥意思，后面在详细介绍。这里默认全选即可，然后点击Next，出现如下界面
其中的， install for all user 最好选择，选择后 Precompile standard library 将自动被选择，之后点击 Install，等待安装完成就好了！安装完成后，效果图如下
如果在开始安装时，没有选择将 Python 添加到环境变量，则按住后需要自己手动添加上图所示的环境变量！
注意如果是第一次安装，安装完成后会有个提示 Removing the MAX_PATH Limitation。我们选择Enable即可。最新的 3.9.0 如下所示（貌似与之前版本的描述不一致了，之前是 Enable 现在是 Disable）：
主要原因是 Windows historically has limited path lengths to 260 characters.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ad290181a4ad77dd7b71f4f0a1ad6db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa62acb0e412147960fb5dcc99077eeb/" rel="bookmark">
			瞅瞅吧！你可能会用到的 css 动画库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：推荐几个你可能会用到的 CSS 动画库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f72c65449cbbf825034ddaba847bc1/" rel="bookmark">
			eNSP：VLAN-hybrid实验应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[sw1]vlan batch 2 to 6
[sw1]int Ethernet 0/0/2 [sw1-Ethernet0/0/2]port link-type access [sw1-Ethernet0/0/2]port default vlan 2
[sw1-Ethernet0/0/2]int e 0/0/4
[sw1-Ethernet0/0/4]port link-ty access [sw1-Ethernet0/0/4]port default vlan 2
[sw1-Ethernet0/0/2]int g 0/0/1
[sw1-GigabitEthernet0/0/1]port link-type trunk [sw1-GigabitEthernet0/0/1]port trunk allow-pass vlan all
[sw1-Ethernet0/0/1]int e 0/0/3
[sw1-Ethernet0/0/3]port hybrid untagged vlan 2 to 6
[sw1-Ethernet0/0/3]port hybrid pvid vlan 3
[sw1-Ethernet0/0/3]int e 0/0/5
[sw1-Ethernet0/0/5]port hybrid untagged vlan 2 to 4
[sw1-Ethernet0/0/5]port hybrid pvid vlan 4
[sw1]int e 0/0/1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93f72c65449cbbf825034ddaba847bc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b32187a8720fdaae8875fb9b1248d172/" rel="bookmark">
			ubuntu20.04 root用户下使用中文输入法——root用户pycharm无法用中文输入法问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因为一些众所不周知的bug，我的pycharm使用apt或者snap安装都不行了，官网下了“绿色版”，运行pycharm.sh也运行不起来，有个java相关环境报错，jre和jdk都装了，还是有点问题，最后尝试发现可以用root运行。 sudo ./pycharm.sh 但是用root运行pycharm有一个问题——中文输入法不可用——多次重试，发现terminator中$下可以直接打中文，而#下就不可以，所以不是pycharm的问题，是root环境的问题（因为pycharm.sh本身在root下运行，所以不难理解）。 在Ubuntu中，切换到root用户后，默认是无法使用中文输入法的。因为root用户是系统的超级管理员，为了保证系统的安全性，一些用户设置可能会被限制或禁用。 最后尝试如下方法解决 1. 打开终端，输入以下命令切换到root用户： sudo -i 或者用 su root 2. 输入你的用户密码，然后按回车键，切换到#下 3. 输入以下命令，编辑root用户的环境变量配置文件： gedit ~/.bashrc 4. 在打开的文本编辑器中，在文件末尾添加以下内容： export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx 如图 5. 保存并关闭文本编辑器。 6. 重新启动终端，或者注销并重新登录，即可在root用户下使用中文输入法了。 注意：在root用户下操作需要谨慎，因为这样可能会对系统造成不可逆的损坏。建议在root用户下只进行必要的操作，并尽快切换回普通用户。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/101/">«</a>
	<span class="pagination__item pagination__item--current">102/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/103/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>