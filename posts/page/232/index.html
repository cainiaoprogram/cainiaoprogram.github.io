<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58600c0b6b5e059f99b53892f9a6f43/" rel="bookmark">
			cuda编程实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矢量求和 include "error.cuh" #include &lt;stdio.h&gt; #include &lt;cuda_runtime.h&gt; #define N 100 __global__ void add( int *a, int *b, int *c ) { int tid = blockIdx.x; // this thread handles the data at its thread id if (tid &lt; N) c[tid] = a[tid] + b[tid]; } int main( void ) { int a[N], b[N], c[N]; int *dev_a, *dev_b, *dev_c; // allocate the memory on the GPU CHECK( cudaMalloc( (void**)&amp;dev_a, N * sizeof(int) ) ); CHECK( cudaMalloc( (void**)&amp;dev_b, N * sizeof(int) ) ); CHECK( cudaMalloc( (void**)&amp;dev_c, N * sizeof(int) ) ); // fill the arrays 'a' and 'b' on the CPU for (int i=0; i&lt;N; i++) { a[i] = -i; b[i] = i * i; } // copy the arrays 'a' and 'b' to the GPU CHECK( cudaMemcpy( dev_a, a, N * sizeof(int), cudaMemcpyHostToDevice ) ); CHECK( cudaMemcpy( dev_b, b, N * sizeof(int), cudaMemcpyHostToDevice ) ); add&lt;&lt;&lt;N,1&gt;&gt;&gt;( dev_a, dev_b, dev_c ); // copy the array 'c' back from the GPU to the CPU CHECK( cudaMemcpy( c, dev_c, N * sizeof(int), cudaMemcpyDeviceToHost ) ); // display the results for (int i=0; i&lt;N; i++) { printf( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58600c0b6b5e059f99b53892f9a6f43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06bf4b8a1154d565dcaa42fc6e85fd2d/" rel="bookmark">
			C&#43;&#43;读取，修改excel表格数据，重命名excel表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取excel表格数据 #define QSC(s)	(QString::fromLocal8Bit(s)) #define INFO(s)	(qInfo().noquote() &lt;&lt; s) //获取excel表格数据 : GetexcelInfo("E:\\111.xlsx", 1, 1); //代表读取E:\\111.xlsx表格的第一行第一列的内容 QString GetexcelInfo(QString name,int i, int j); QString GetexcelInfo(QString name,int i,int j) { INFO(QSC("Getexcel:读取excel数据")); QAxObject* excel = NULL; //本例中，excel设定为Excel文件的操作对象 QAxObject* workbooks = NULL; QAxObject* workbook = NULL; //Excel操作对象 excel = new QAxObject("Excel.Application"); excel-&gt;dynamicCall("SetVisible(bool)", false); //true 表示操作文件时可见，false表示为不可见 workbooks = excel-&gt;querySubObject("WorkBooks"); //————————————————按文件路径打开文件———————————————————— workbook = workbooks-&gt;querySubObject("Open(QString&amp;)", name); // 获取打开的excel文件中所有的工作sheet QAxObject* worksheets = workbook-&gt;querySubObject("WorkSheets"); // ————————————————获取第n个工作表 querySubObject("Item(int)", n);—————————— QAxObject* worksheet = worksheets-&gt;querySubObject("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06bf4b8a1154d565dcaa42fc6e85fd2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0cfedfde3b7accd44bc5b42e97e68e/" rel="bookmark">
			Redis入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始 Redis是一个高性能的key-value 数据库，同时支持list，set，zset，hash等数据结构的存储
第一个尝试： （先用windows 版本看下入个门，一般linux用的多，学习来源菜鸟教程）
下载安装到一个你能找到的地方
推荐在某个盘下建一个tool的文件夹，把go啦java啦mysql啦Redis啦，这种工具性的工具放进去
https://github.com/tporadowski/redis/releases
下载zip版本
（前提，每个命令提示符都要先进入redis那个文件下，要不找不到，切换路径的命令：cd /d 路径）
在cmd(命令提示符中)打开服务端命令： redis-server.exe redis.windows.conf
再开一个命令提示符，开客服端：redis-cli.exe -h 127.0.0.1 -p 6379
设置键值对：set heiKey ha
取键值对：get heiKey
数据类型
stringhashlistsetzset (有序集合) 简介 偷一张网络视频的图
他是一种nosql数据库，
好处就是如图
作为缓存使用，减小io压力
NoSQL非关系型数据库
MemcacheRedismongoDBNeo4jApache Cassandra 分类Examples举例典型应用场景数据模型优点缺点键值（key-value）Tokyo Cabinet/Tyrant， Redis， Voldemort， Oracle BDB内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。Key 指向 Value 的键值对，通常用hash table来实现查找速度快数据无结构化，通常只被当作字符串或者二进制数据列存储数据库Cassandra， HBase， Riak分布式的文件系统以列簇式存储，将同一列数据存在一起查找速度快，可扩展性强，更容易进行分布式扩展功能相对局限文档型数据库CouchDB， MongoDbWeb应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）Key-Value对应的键值对，Value为结构化数据数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构查询性能不高，而且缺乏统一的查询语法。图形(Graph)数据库Neo4J， InfoGrid， Infinite Graph社交网络，推荐系统等。专注于构建关系图谱图结构利用图结构相关算法。比如最短路径寻址，N度关系查找等很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。 linux版本学习 注意事项 xftp连接云服务器的实例主机密码就是root账户密码：W…….
下载安装 下载安装redis
稳定版本安装地址 : https://redis.io/download/#redis-downloads
在linux中安装redis需要有c语言编译环境，centos7，有gcc就行，通过命令检测是否有gcc，
gcc --version检查是否有gcc环境，有的话就解压tar -zxvf 压缩包名字进入redis文件夹make把redis编译成c文件make install安装 我在这里遇到过一个问题，原因是下错了版本，下载成了stack版本，当时没注意…
redis目录简介
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad0cfedfde3b7accd44bc5b42e97e68e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31fcac85ebf5d86c28068b9d094d4ae6/" rel="bookmark">
			Comodo证书的价格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Comodo是成立于上世纪九十年代的CA认证机构，但是在2018年公司为了和其他安全服务进行区分，改名为了Sectigo，所以现在大多数搜索的Sectigo产品都是曾经Comodo旗下的。虽说改了名字和签章，但是价格没有改变多少，依然是性价比高。申请速度快的SSL证书品牌。今天随SSL盾小编了解Comodo证书的价格。
1.Comodo DV IP证书：这款SSL证书是Comodo旗下专为IP地址准备的SSL证书，为了能够保护网站信息传输安全，并且对服务器的身份进行认真，让客户在浏览器访问网站时不再弹出“不安全”。这款IP证书价格在三百六十元左右，申请时依然需要上传文件验证IP地址所有权才能签发证书。
2.Comodo OV单域名证书：这是一款企业型的单域名SSL数字证书，价格在五百八十元左右，在申请时需要验证域名所有权和申请企事业单位的真实性，一般需要2小时-2个工作日，不过自从Comodo成立了亚太审核机构之后，Comodo旗下的SSL证书在申请效率变快，申请OV单域名SSL数字证书时通常都是在两个小时左右受到通知。
3.Comodo EV多域名证书：这款是性价比比较高的EV增强型多域名SSL数字证书，价格在两千元左右，默认可以保护3个任意类型的域名记录，如果不够的话还可以付费添加域名记录。申请时比较严格，需要验证域名所有权以及申请者的真实性，不过被这款EV增强型的多域名SSL证书保护的域名网站都有绿色地址栏+中文名称展示的待遇，提高了客户对网站的信任。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/884eca7a9ab28f1f1dd7eff46fa24f2f/" rel="bookmark">
			html中标签img大小自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 html中标签img大小自适应办法 1.通过属性 object-fit属性
img { width: 200px; height: 400px; object-fit: cover; } fill 默认
不保证保持原有的比例，内容拉伸填充整个内容容器。contain 保持原有尺寸比例。内容被缩放。cover
保持原有尺寸比例。但部分内容可能被剪切。none
保留原有元素内容的长度和宽度，也就是说内容不会被重置。scale-down
保持原有尺寸比例。内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。initial
设置为默认值 2.宽度设置 只给定img宽度不给高度，将按照宽度自适应。
img { width: 80%; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4dc7bed863daf117634a48c5b369cf7/" rel="bookmark">
			【非严格递增连续数字序列】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		■ 题目描述
【非严格递增连续数字序列】
输入一个字符串仅包含大小写字母和数字，求字符串中包含的最长的非严格递增连续数字序列的长度
（比如12234属于非严格递增连续数字序列）。
输入描述
输入一个字符串仅包含大小写字母和数字，输入的字符串最大不超过255个字符。
输出描述
最长的非严格递增连续数字序列的长度
示例1 输入输出示例仅供调试，后台判题数据一般不包含示例
输入
abc2234019A334bc
输出
4
说明
2234为最长的非严格递增连续数字序列，所以长度为4。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9c814db3faf4ae3aa5deb792f1cb72/" rel="bookmark">
			01_Eclipse插件安装和菜单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01_Eclipse插件安装和菜单介绍 目录概述需求： 设计思路实现思路分析1.安装Eclipse 插件2.打开对应视图文件3.打开对应的属性视图窗口4.注意事项 拓展菜单：性能参数测试： 参考资料和推荐阅读 Survive by day and develop by night.
talk is cheap, show me the code,make a better result.
目录 概述 flowable 是常见的工作流引擎，那么我们常用的设计流程图呢？
需求： 目前的常见方案是:
Eclipse 的插件网页版的流程设计图 设计思路 实现思路分析 1.安装Eclipse 插件 不再赘述
2.打开对应视图文件 使用编辑器打开
3.打开对应的属性视图窗口 如果没有的话，参考如下方案：
4.注意事项 在更改视图的过程中，频繁的操作导致视图可能有缓存。
删除之后，重新打开
拓展菜单： 这里主要出现了很多菜单，其实都是JBMN的规范实现，如下，我们将在实际需求中讲述。
性能参数测试： 无
参考资料和推荐阅读 Eclipse 在线安装flowable插件.相关菜单介绍. 欢迎阅读，各位老铁，如果对你有帮助，点个赞加个关注呗！~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f726d74c9e7724eb1f612d3d898683a3/" rel="bookmark">
			Linux的网络设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 本章概述一、查看网路配置1、查看网络接口信息-ifconfig2、修改网络配置文件3、设置网络接口 二、主机名称配置文件1、查看主机名2、修改主机名2.1 临时修改2.2 永久修改 三、查看路由表条目-route1、route命令1.1 直接使用route1.2 使用route -n 2、添加、删除静态路由记录3、添加、删除默认网关记录 四、netstat命令五、获取socket统计信息-ss六、测试网络连接6.1 ping命令6.2 traceroute命令 七、域名解析-nslookup1、nslookup命令2、域名解析配置文件查看与修改 八、本地主机映射九、总结 本章概述 介绍查看网络信息，如何修改网络信息，以及网络中路由器中的路由表如何配置。
一、查看网路配置 1、查看网络接口信息-ifconfig 执行 ifconfig 命令 主机的网络接口卡（网卡）通常称为网络接口。在Linux操作系统中，使用ifconfig命令可以查看网络接口的地址配置信息（Interface Configuration ）。
注：若采用的是mini版的Centos 7 安装的系统，默认是没有ifconfig命令的，需要通过yum安装net-tools软件包，才可以使用ifconfig 命令。
使用ifconfig命令
①直接使用ifconfig命令
②单个查找ens33信息
上述内容解释
行数内容第一行以太网卡的名字不是常见的etho，变成了ens33。其中en代表以太网卡。
ens33代表PCI接口的物理位置为（0,3），其中横坐标代表bus，纵坐标代表slot
UP：网络接口为启用状态（down为关闭状态）
RUNNING：代表网卡设备已连接
MULTICAST：表示支持组播
MTU：为数据包最大传输单元第二行网卡的IP地址、子网掩码、广播地址第三行IPv6地址第四行Ethernet（以太网）表示连接类型，ether：表示为网卡的mac地址 ③查找全部的网络接口信息
ifconfig -a 或 ip a 2、修改网络配置文件 网络接口的配置文件默认位于/etc/sysconfig/netwrok-scripts/ifcfg-ens33
文件名格式为“ifcfg-XXX”，其中“xxx”是网络接口的名称。
例如：网卡ens33的配置文件是“ifcfg-ens33”，回环接口lo的配置文件是“ifcfg-lo”
在centos 7 操作系统中，当修改了网络接口的配置文件以后，若要使新的配置生效，可以重新启动network服务或者重启主机
systemctl restart network #重新加载网络 注意：建议关闭NetworkManager服务，否则有时启动network会报错 systemctl stop NetworkManager #关闭 systemctl disable NetworkManager #开机不自启 3、设置网络接口 ifconfig命令不仅可以用于查看网卡配置，还可以修改网卡的IP地址，子网掩码，也可以绑定虚拟网络接口、激活或禁用网络接口。
ifconfig ens33 20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f726d74c9e7724eb1f612d3d898683a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e37947f58cb9a61b891075e8b91543/" rel="bookmark">
			[论]Bike Flow Prediction with Multi-Graph Convolutional Networks基于多图卷积网络的自行车流量预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bike Flow Prediction with Multi-Graph Convolutional Networks(基于多图卷积网络的自行车流量预测) 2018年第26届ACM空间地理信息系统进展国际会议论文集
论文链接：见这里
作者： Di Chai, Leye Wang, Qiang Yang
出版：ACM
关键字：多卷积GCN，自行车流量预测
文章目录 Bike Flow Prediction with Multi-Graph Convolutional Networks(基于多图卷积网络的自行车流量预测)摘要 1 INTRODUCTION2 DEFINITIONS AND PROBLEM3 MULTI-GRAPH CONVOLUTIONAL NEURAL NETWORK MODEL3.1 Graph Generation3.2 Multi-graph Convolution3.3 Prediction Network 4 EV ALUATION4.1实验设置4.2 Experiment Results 5 CONCLUSION MGCN的搭建第一种？ 摘要 管理自行车共享系统的一个基本问题是自行车流量预测。由于单站流量预测的困难，最近的研究经常在集群水平上预测流量。但是，它们不能直接指导站点级别的细粒度系统管理问题。在本文中，我们回顾了车站级自行车流量预测的问题，旨在利用深度学习技术的突破来提高预测精度。我们提出了一个多图卷积神经网络模型来预测站点级别的流量，其中的关键新奇之处在于从图的角度观察自行车共享系统。更具体地说，我们构建了一个自行车共享系统的多个图来反映异构的站间关系。然后，我们融合多个图，并应用卷积层来预测车站级的未来自行车流量。在真实的自行车流量数据集上的结果验证了我们的多重图模型可以通过减少高达25.1%的预测误差来超越最先进的预测模型。
abstract
One fundamental issue in managing bike sharing systems is bike flow prediction. Due to the hardness of predicting flow for a single station, recent research often predicts flow at cluster-level.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19e37947f58cb9a61b891075e8b91543/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eee7a44d6d40f0e28f185a45acd675d/" rel="bookmark">
			数据库控制并发字段的设计与想法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库控制并发字段的设计与想法 0. 原场景 最近在做一些增删改查，发现了一点我之前从未想过的场景，在高并发的场景下，假如多个用户对同一条信息进行修改，那么这个信息该如何去update呢？仅仅根据id条件去更新，它会发生什么？
1. 场景demo 这里使用Spring Boot + Mybatis + Thymeleaf做了一个demo。
界面，如下图所示： html核心代码如下： &lt;form th:action="@{/person/update}" method="post"&gt; &lt;input type="hidden" id="id" name="id" th:value="${person.id}"&gt; &lt;div class="mb-3 row"&gt; &lt;label for="name" class="col-sm-2 col-form-label"&gt;姓名&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="text" class="form-control" id="name" name="name" th:value="${person.name}"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="mb-3 row"&gt; &lt;label for="money" class="col-sm-2 col-form-label"&gt;金钱&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="text" class="form-control" id="money" name="money" th:value="${person.money}"&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;修改&lt;/button&gt; &lt;/form&gt; 数据库设计很简单，如下图： Controller层如下： 为了方便看到 是否更新成功，判断了sql执行后的行数
@Controller public class PersonController { @Autowired(required = false) PersonService personService; @RequestMapping(path = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eee7a44d6d40f0e28f185a45acd675d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a691c7d4d9d5af37af057572558a455c/" rel="bookmark">
			pytorch：tensor维度理解及合并操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch：tensor维度理解及合并操作 这是我在做cnn时需要做semi_suprised learning时发现的问题，我需要将两个tensor合并。
例如
import torch as t import numpy as np a=t.tensor([[2,3,4],[3,4,5]]) b=t.tensor([1,2,3]) print(a) print(b) 需要将a、b合并，得到
c=t.tensor([[2,3,4],[3,4,5],[1,2,3]]) 问题十分简单，大佬跳过。
只需要：
c=t.cat((a,b),dim=0) 但是实际运行起来却报错维度不一致
--------------------------------------------------------------------------- RuntimeError Traceback (most recent call last) &lt;ipython-input-6-b2f12a333b67&gt; in &lt;module&gt; ----&gt; 1 c=t.cat((a,b),dim=0) RuntimeError: torch.cat(): Tensors must have same number of dimensions: got 2 and 1 但是使用c=c=torch.cat((a,a),dim=0)却可以
然后我打印了
print(a.shape) print(b.shape) ##结果 torch.Size([2, 3]) torch.Size([3]) 发现了问题，虽然看似形式一样，a确是两维,b是一维。
那怎么办呢？用reshape！
b=b.resahpe(1,3)
再用c=torch.cat((a,b),dim=0)就行了
b=b.reshape(1,3) c=t.cat((a,b),dim=0) c ##结果 tensor([[2, 3, 4], [3, 4, 5], [1, 2, 3]]) 所以看似两次b的形式基本一样，维度却差了一维。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a691c7d4d9d5af37af057572558a455c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a04db84b8e62298ebfbbb26c07e98cc4/" rel="bookmark">
			Python实现Excel中的sheet复制（可跨文件操作、可保留原格式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 跨文件复制2 同一文件内复制2.1 修改sheet名字2.2 完整实例2.2.1 需求说明2.2.2 代码2.2.3 运行结果 1 跨文件复制 from openpyxl import Workbook,load_workbook def copy_sheet(src_xlsx,ssheetname,dst_xlsx,nsheetname=None): if nsheetname==None: nsheetname=ssheetname try: sw=load_workbook(f'{src_xlsx}') except KeyError: raise KeyError('旧工作簿不存在 The old xlsx is not exists') try: dw=load_workbook(f'{dst_xlsx}') except FileNotFoundError: dw=Workbook() try: sheet = dw[f'{nsheetname}'] except KeyError: sheet=dw.create_sheet(f'{nsheetname}') try: src_sheet=sw[f'{ssheetname}'] except KeyError: raise KeyError('源工作簿文件不存在该工作簿 The sheet does not exist in the source file') for row in src_sheet.iter_rows(): row_list=[] for cell in row: row_list.append(cell.value) sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a04db84b8e62298ebfbbb26c07e98cc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/561784846e8eaa75d2519f2906717798/" rel="bookmark">
			BERT源码学习（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BERT源码地址：https://github.com/google-research/bert
学习模块：create_pretraining_data
功能：定义了如何将普通文本转换成可用于预训练BERT模型的tfrecord文件的方法。
目录
01 执行参数及意义：
02 代码解析
01 执行参数及意义： --input_file=./sample_text.txt \ #训练文本
--output_file=/tmp/tf_examples.tfrecord \ #生成记录，指定在tmp下生成
--vocab_file=$BERT_BASE_DIR/vocab.txt \ #需要提前准备的词表
--do_lower_case=True \ #是否小写输入， 默认True
--max_seq_length=128 \ #限制输入中最大句子的长度
--max_predictions_per_seq=20 \ #每一句MLM预测的百分比
--masked_lm_prob=0.15 \ #掩码语言模型的比例
--random_seed=12345 \ #用于数据生成的随机种子
--dupe_factor=5 #复制输入数据的次数(使用不同的掩码)， 默认循环10次
源代码：
必要参数：
flags.DEFINE_string("input_file", None,
"Input raw text file (or comma-separated list of files).")
flags.DEFINE_string(
"output_file", None,
"Output TF example file (or comma-separated list of files).")
flags.DEFINE_string("vocab_file", None,
"The vocabulary file that the BERT model was trained on.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/561784846e8eaa75d2519f2906717798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210dc02888006a1bd4123559e91e68f6/" rel="bookmark">
			DNA 7. 基因组拷贝数变异分析及可视化 (GISTIC2.0)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		桓峰基因
生物信息分析，SCI文章撰写及生物信息基础知识学习：R语言学习，perl基础编程，linux系统命令，Python遇见更好的你
119篇原创内容
公众号
桓峰基因公众号推出基于基因组变异数据生信分析教程并配有视频在线教程，目前整理出来的教程目录如下：
DNA 1. Germline Mutation Vs. Somatic Mutation 傻傻分不清楚
DNA 2. SCI 文章中基因组变异分析神器之 maftools
DNA 3. SCI 文章中基因组变异分析神器之 maftools
DNA 4. SCI 文章中基因组的突变信号（maftools）
DNA 5. 基因组变异文件VCF格式详解
DNA 6. 基因组变异之绘制精美瀑布图（ComplexHeatmap）
DNA 7. 基因组拷贝数变异分析及可视化 (GISTIC2.0)
今天介绍一款，做完CNV calling的分析，一般来说就是圈图，曼哈顿图，这个我都有介绍过，但是技术的进步，有生产更有意义的工具，可以更加精准的定位热点区域以及热点基因，今天就先介绍一款非常好用的软件 GISTIC2.0
前 言
癌症是通过逐步获得体细胞遗传改变形成的，包括点突变、拷贝数改变和融合事件，这些改变影响调控细胞生长和生存的关键基因的功能。这些改变靶向的致癌基因和肿瘤抑制基因的识别大大加快了对癌症发病机制的理解和新的治疗弱点的识别。特别是体细胞拷贝数改变(SCNAs)靶向的基因，在肿瘤发生和癌症治疗中发挥着重要作用。阵列和测序平台的显著改进使数以千计的癌症基因组中SCNAs的高分辨率表征成为可能。而探索驱动型SCNAs及对应受影响的基因，存在两个挑战： 1. 在每个细胞分裂过程中都会随机获得体细胞变异，其中只有一些（驱动变异, ‘driver’ alterations）会促进癌症的发展；2. SCNAs可能同时影响多达数千个基因，但驱动变异的选择性优势可能仅由这些基因中的一个或少数几个介导；
2. 识别drivers的一种常见方法是研究大量的癌症样本，其概念是，包含driver events的区域应该比只包含passengers的区域变异得更频繁。
GISTIC（Genomic Identification of Significant Targets in Cancer）算法的提出即是基于此。算法文章于2011年发表在Genome Biology上，至今引用量已过一千。
我们看下该软件分析流程的pipeline：
软件下载及安装
下载及安装包括两部分，一部分是需要先安装matlab，如果您的已经配置完成，那请忽略；一部分是GISTIC2.0安装。
1. 安装matlab
matlab下载官网链接：
https://ssd.mathworks.cn/supportfiles/downloads/R2014b/deployment_files/R2014b/installers/glnxa64/MCR_R2014b_glnxa64_installer.zip 嫌麻烦，可以关注桓峰基因公众号，发送消息 matlab 即可下载，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/210dc02888006a1bd4123559e91e68f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03961b1bc728439a1f5e8006dc11cb2/" rel="bookmark">
			SQLite数据库的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 其实我们可以对数据进行的操作无非有4种，即CRUD。其中C代表添加( Create), R代表查询( Retrieve), U代表更新(Update), D代表删除( Delete)。
每一种操作又各自对应了一种SQL命令，如果不熟悉SQL语言,Android也提供了一系列的辅助性方法，使得在Android中即使不去编写SQL语句，也能轻松完成所有的CRUD操作。
调用SQLiteOpenHelper的getReadableDatabase( )或getWritableDatabase()方法是可以用于创建和升级数据库的，不仅如此，这两个方法还都会返回一个SQLiteDatabase对象，借助这个对象就可以对数据进行CRUD操作了。
二、添加数据 沿用上一篇博客“SQLite数据库存储”项目
2.1、前言 SQLiteDatabase中提供了一个insert()方法,这个方法就是专门用于添加数据的。它接收3个参数,第一个参数是表名，第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL,一般我们用不到这个功能，直接传入null即可。第三个参数是一个ContentValues对象，它提供了一系列的put()方法重载,用于向ContentValues中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。
2.2、在activity_main.xml中添加代码，如下所示: ................ &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/add_data" android:text="Add data"/&gt; ................ 2.3、在MainActivity中编写添加数据逻辑 ......................... @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this , "BookStore.db" , null , 2); ...................... Button addData = (Button) findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); //开始组装第一条数据 values.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c03961b1bc728439a1f5e8006dc11cb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c83d42e15ee239533dde7ea425fa09/" rel="bookmark">
			Vue实战开发--后台管理系统Vue&#43;Element ui（9）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这节课完成面包屑和tag的布局，并且与左侧菜单联系，涉及组件间通信。 1.提前准备 首先我们先完成每个页面的路由，之前已经有home页面和user页面，缺少mail页面和其它选项下的page1和page2页面。在view文件夹下新建mail文件夹，新建index.vue，填充user页面的内容即可。在view下新建other文件夹，新建pageOne.vue和pageTwo.vue，页面内容简单填充即可。三个页面都要更改name属性，后面会用到，首字母大写。
示例：
配置路由：在路由主文件添加路由，路由位置在CommonAside的menu数组中保持偶一致。这里的name属性是小写，与上面不相同。
{ path:'/mail', name:'mail', component:()=&gt;import('../view/mail') }, { path:'/page1', name:'page1', component:()=&gt;import('../view/other/pageOne.vue') }, { path:'/page2', name:'page2', component:()=&gt;import('../view/other/pageTwo.vue') } 测试发现商品管理可以正常跳转，但是其他的二级菜单不能跳转，原因是没有设置点击事件。为左侧导航栏二级菜单添加点击事件。为el-menu-item添加点击事件。
&lt;el-menu-item-group v-for="(subItem,subIndex) in item.children" :key="subItem.path"&gt; &lt;el-menu-item @click="clickMenu(subItem)" :index="subIndex.toString()"&gt;{{ subItem.label }}&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; 2.面包屑功能 面包屑有数据记忆存储功能，每次点击导航栏后后记录选中的导航栏并列出。这里需要用到Vuex.Store,我们前面左侧导航栏的收起与展开同样使用到Vuex.Store，store可以看做是容器，里面有四个值，由State、Getters、Mutation、Actions这四种组成。在store下的tab.js文件，默认数据定义在state中，我们定义为一个数组tabsList，数组里有多个对象，但这里知识默认对象，对象里有四个属性，path、name、label、icon。currentMenu为一个临时变量，存储点击的tab。
state:{ isCollapse:false, tabsList:[ { path:'/', name:'home', label:'首页', icon:'home' } ], currentMenu:null }, 改变tabsList里的内容要用到Vuex.store的mutations。改变state数据的发都会以函数的形式写在mutations中，之后在页面调用即可。selectMenu函数接收两个参数，state和val，此时需要进行判断，当前点击的导航栏是不是首页，用name属性判断，判断传入的item.name是否等于‘home’，如果不是home，需要赋值val给currentMenu，这样currentMenu就会不断累加，最多为五个（首页、用户、商品、其他1、其他2）。此处还需要一个判断，判断当前点击的导航栏是是不是刚刚已经点击过来，点击过了不再进行累加，而是将面包屑跳转到点击过的那一个。这里用到findIndex（）方法。判断item.name里是否有val.name。 有的话为1，无的话为-1，无的话那么使用push（）方法将val累加到currentMenu。如果点击是‘home’的情况，currentMenu置空。
selectMenu(state,val){ if(val.name !== 'home'){ state.currentMenu = val const result = state.tabsList.findIndex(item =&gt; item.name === val.name) if(result === -1){ state.tabsList.push(val) } }else{ state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4c83d42e15ee239533dde7ea425fa09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/484e54231a718914a185b6df7477e827/" rel="bookmark">
			Vue.js nextTick 源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nextTick vue版本 2.6.11
源码分析(nextTick) nextTick源码调用过程总结：
init-&gt;timerFunc = (Promise/MutationObserver/setImmediate)
初始化阶段为timerFunc的执行方式赋值，一般来说在Windows浏览器环境下运行timerFunc函数的执行方式都会是Promise.then的方式，使用微任务队列的方式。
if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) { var p = Promise.resolve(); timerFunc = function () { p.then(flushCallbacks); if (isIOS) { setTimeout(noop); } }; isUsingMicroTask = true; } else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || MutationObserver.toString() === '[object MutationObserverConstructor]' )) { var counter = 1; var observer = new MutationObserver(flushCallbacks); var textNode = document.createTextNode(String(counter)); observer.observe(textNode, { characterData: true }); timerFunc = function () { counter = (counter + 1) % 2; textNode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/484e54231a718914a185b6df7477e827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88862990d6c5ba6df46aaa87131d7d7b/" rel="bookmark">
			dma_buf_export
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
* DOC: dma buf device access
*
* For device DMA access to a shared DMA buffer the usual sequence of operations
* is fairly simple:
*
* 1. The exporter defines his exporter instance using
* DEFINE_DMA_BUF_EXPORT_INFO() and calls dma_buf_export() to wrap a private
* buffer object into a &amp;dma_buf. It then exports that &amp;dma_buf to userspace
* as a file descriptor by calling dma_buf_fd().
*
* 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88862990d6c5ba6df46aaa87131d7d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8940caafc28197fb2c8ce1cd942925b6/" rel="bookmark">
			原生微信小程序自定义组件以及组件间通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、新建组件二、文件介绍1.index.json2.index.js 三、在父组件中引入子组件四、父子组件通讯属性绑定事件绑定获取组件实例 总结 前言 当我们在开发项目时，有时候会发现，在不同的页面中会用到相同的功能模块，,此时我们就可以将这些相同的部分提取出来并且单独设为一个"页面",然后在要应用到它的地方引用就可以了， 在vue 、react 等框架中，组件化开发的概念相信大家都很熟悉了，下面我来介绍介绍原生微信小程序如何定义组件，如果有纰漏欢迎大家指正。
一、新建组件 首先在根目录下新建一个 components 文件夹用来盛放我们所有的自定义组件，在文件夹下建立第一个自定义组件 cptDemo
二、文件介绍 以下文件都为 cptDemo 下的文件。
1.index.json 要在自定义组件的 json 中进行自定义组件声明,也就是告诉开发者这是一个组件:
{ "component": true } 2.index.js data：用于定义组件模板渲染的私有数据；methods方法：定义事件处理函数和自定义方法；properties属性：用来接受外部数据； //子组件 wxml &lt;view&gt; {{cliname}} &lt;/view&gt; //子组件 js properties：{ cliname: { type:String, value: '' } } //父组件 wxml &lt;cpt-demo cliname='{{cliname}}'&gt;&lt;/cpt-demo&gt; //父组件 js data:{ cliname:"传递给子组件的值" } observers：属性监听器，用于监听和响应任何属性和数据字段的变化，从而执行特定的操作 //数据监听器支持监听对象中单个或多个属性的变化 //使用通配符**来监听对象所有属性的变化 observers:{ '字段A,字段B':function(字段A的的新值，字段B的新值){ //do something } } 自定义组件的生命周期 lifetimes Component({ //新的写法 lifetimes: { created:function(){ //在组件实例刚刚创建时执行 //此时不能调用setData //只能给组件的this添加一些自定义的属性字段 }, ready: function() { // 在组件在视图层布局完成后执行 }, moved: function() { // 在组件实例被移动到节点树另一个位置时执行 }, attached: function() { // 在组件实例进入页面节点树时执行 //this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8940caafc28197fb2c8ce1cd942925b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a887e1cc1a32e375df013e8a76b0aa84/" rel="bookmark">
			手撕迪杰斯特拉算法（Dijkstra）及代码（附图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 迪杰斯特拉（Dijkstra）算法1.算法思想及其步骤2.代码2.1 相关声明2.2 有权图的建立函数定义2.3 核心算法：迪杰斯特拉 迪杰斯特拉（Dijkstra）算法 引言：我们常常纠结一个对路径选择的决策问题，假设我们要从北京到上海，那么如何才能走 花最少的钱，又最节省时间的线路呢？
​ 这时候，我们可以把从 北京 到 上海 间的路线站标记，那么 北京 到 各路线站 都会有相应的金钱和时间花费，我们只需要找出一条从北京到上海所经过的路线站的时间和金钱总值消耗最少的即可。
​ 显而易见，对应到图中，就是一张带权的图，即 一张 网。我们只需要找出 起点 到 终点 权值之和最少的路径即可。即
t a r g e t = M i n ( ∑ b e g i n e n d w e i g h t ) i target=Min{ (\sum_{begin}^{end}weight)_i } target=Min(begin∑end​weight)i​
​
1.算法思想及其步骤 算 法 核 心 \color{SpringGreen}算法核心 算法核心：基于已经求得最短路径的基础上，求得更远顶点的最短路径
​ 图结构 graphNet ： 带权的图 （网），用邻接矩阵表示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a887e1cc1a32e375df013e8a76b0aa84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d717820120c553b20f25754b3061492/" rel="bookmark">
			springboot&#43;lucene实现全文检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lucene是一个基于Java的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene 目前是 Apache Jakarta 家族中的一个开源项目，也是目前最为流行的基于 Java 开源全文检索工具包。
Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具。
Lucene全文检索就是对文档中全部内容进行分词，然后对所有单词建立倒排索引的过程。主要操作是使用Lucene的API来实现对索引的增（创建索引）、删（删除索引）、改（修改索引）、查（搜索数据）。
假设我们的电脑的目录中含有很多文本文档，我们需要查找哪些文档含有某个关键词。为了实现这种功能，我们首先利用 Lucene 对这个目录中的文档建立索引，然后在建立好的索引中搜索我们所要查找的文档。通过这个例子读者会对如何利用 Lucene 构建自己的搜索应用程序有个比较清楚的认识。
建立索引
Document
Document 是用来描述文档的，这里的文档可以指一个 HTML 页面，一封电子邮件，或者是一个文本文件。一个 Document 对象由多个 Field 对象组成，可以把一个 Document 对象想象成数据库中的一个记录，而每个 Field 对象就是记录的一个字段。Field
Field 对象是用来描述一个文档的某个属性的，比如一封电子邮件的标题和内容可以用两个 Field 对象分别描述。Analyzer
在一个文档被索引之前，首先需要对文档内容进行分词处理，这部分工作就是由 Analyzer 来做的。Analyzer 类是一个抽象类，它有多个实现。针对不同的语言和应用需要选择适合的 Analyzer。Analyzer 把分词后的内容交给 IndexWriter 来建立索引。IndexWriter
IndexWriter 是 Lucene 用来创建索引的一个核心的类，他的作用是把一个个的 Document 对象加到索引中来。Directory
这个类代表了 Lucene 的索引的存储的位置，这是一个抽象类，它目前有两个实现，第一个是 FSDirectory，它表示一个存储在文件系统中的索引的位置。第二个是 RAMDirectory，它表示一个存储在内存当中的索引的位置。 检索文档
Query
这是一个抽象类，他有多个实现，比如 TermQuery, BooleanQuery, PrefixQuery. 这个类的目的是把用户输入的查询字符串封装成 Lucene 能够识别的 Query。Term
Term 是搜索的基本单位，一个 Term 对象有两个 String 类型的域组成。生成一个 Term 对象可以有如下一条语句来完成：Term term = new Term(“fieldName”,”queryWord”); 其中第一个参数代表了要在文档的哪一个 Field 上进行查找，第二个参数代表了要查询的关键词。TermQuery
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d717820120c553b20f25754b3061492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a7ef1247a1871b4361f4c8d003fe3d/" rel="bookmark">
			Tomcat的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat是运行java的网络服务器，底层是一个socket的程序，同时Tomcat也是JSP和Serlvet的容器.
那么为什么我们要用Tomcat呢？
一般情况下，如果我们使用HTML/CSS/JS编写了一个网页，这个网页只能由我们本地打开，别的人无法通过远程访问这个页面。那么Tomcat就解决了这个问题，让其他人也可以访问我们写的页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae2ab6bb45d8f2275f50efe067355f66/" rel="bookmark">
			MySQL基础学习第十五课（数据库的备份和还原）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库备份与还原
知识点：数据库的备份和还原是在系统DOS命令行窗口中完成的。
如何进入系统DOS命令行窗口：
使用“微软键+R”打开“运行”对话框，之后在“运行”对话框输入cmd，按“确定”键即可进入系统DOS命令行窗口。
以下语句执行，无需输入 “;”号结束，直接按回车执行。
1、备份：mysqldump -uroot -p123456 two&gt;c:/backup/two_17.sql
注：Two是备份的数据库，two_17.sql是备份的数据库文件。
2、还原：mysql -uroot -p123456 test_17&lt;c:/backup/test.sql
注：test_17是还原的数据库，test.sql是原备份的数据库文件。
练习题（备份）：在C盘新建一个名为“backup”文件夹，将数据库fuxi_23_1备份至“backup”文件夹中，备份文件名字为：fuxi_23_1.sql。并将备份文件拷贝到实验作业文件夹。练习题（还原）：将实验作业文件夹中的“four_student.sql”备份文件还原至数据库fuxi_23_1。（操作提示：先将备份文件拷贝至“backup”文件夹中，再进行还原）练习题（存储过程）：使用fuxi_23_1数据库，创建存储过程，代码如下： 请将以上代码输入并截图提交（截图mysql服务器窗口代码）：
建议使用记事本文件输入以上代码，之后复制到mysql服务器执行。
完成代码输入后，调用存储过程：
Call proc_gender_grade_sum('女',@sum)查看返回结果，截图提交：
存储过程其他知识点 查看所有的存储过程语句 Show procedure status\G
查看存储过程的状态（如果查看的是当前数据库下的存储过程，无需”数据库名.”作为前缀） Show create procedure 数据库名.存储过程名;
举例说明
删除存储过程语句（如果删除当前数据库下的存储过程，无需”数据库名.”作为前缀） Drop procedure 数据库名.存储过程名；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b26746d2f20135bba0edfb3326297f4e/" rel="bookmark">
			@Aspect aop切面获取请求接口类名、方法名、及参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自定义一个注解，通过将自定义的注解添加到对应的方法上，可实现对该方法进行增强操作
package com.basis.aspect; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface BasisLogAnnotation { } 2.切面-环绕通知 我的需求是：在调用接口前有一些操作，在接口调用之后，再做一些操作，具体使用什么通知，看个人具体的业务需求
package com.basis.aspect; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.slf4j.Logger; import org.slf4j.LoggerFactory; @Aspect @Component public class ServiceLogAspect { Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class); /** * 环绕通知 */ @Around(value = "@annotation(basisLogAnnotation)") public Object demoAop(ProceedingJoinPoint proceedingJoinPoint, final BasisLogAnnotation basisLogAnnotation) throws Throwable { logger.debug("执行前："); Object object = proceedingJoinPoint.proceed(); //执行连接点方法，object：方法返回值 logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b26746d2f20135bba0edfb3326297f4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe673c5c3704a014c96972dbf49c6f78/" rel="bookmark">
			Spark - ERROR StatusLogger No log4j2 configuration file found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.引言 spark 项目运行 kafka 相关程序时报警告，虽然不影响运行，但是强迫症看着十分难受，下面立即清除。
ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. 二.问题解决 1.添加 log4j2.xml loggers 里面可以配置 level
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Configuration status="WARN"&gt; &lt;Appenders&gt; &lt;Console name="Console" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="%d{YYYY-MM-dd HH:mm:ss} [%t] %-5p %c{1}:%L - %msg%n" /&gt; &lt;/Console&gt; &lt;RollingFile name="RollingFile" filename="log/test.log" filepattern="${logPath}/%d{YYYYMMddHHmmss}-fargo.log"&gt; &lt;PatternLayout pattern="%d{YYYY-MM-dd HH:mm:ss} [%t] %-5p %c{1}:%L - %msg%n" /&gt; &lt;Policies&gt; &lt;SizeBasedTriggeringPolicy size="10 MB" /&gt; &lt;/Policies&gt; &lt;DefaultRolloverStrategy max="20" /&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe673c5c3704a014c96972dbf49c6f78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2b976a147c4aefd567a9ea3b97bf89/" rel="bookmark">
			centos8安装screen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1) 安装源
cd /etc/yum.repos.d mv CentOS-Base.repo CentOS-Base.repo.back wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo 2）报错
需要安装
yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm 3）安装screen
yum install screen 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0241def145b0043523dc3c50447b608b/" rel="bookmark">
			史上最全推广小程序实操方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用篇
1、用小程序名称抢排位
小程序的排名跟名称、描述、上线时间、用户访问量和小程序的综合质量有关，且小程序的名称是唯一的。根据用户的搜索习惯和产品特性，尽可能多地注册小程序名称，才能让小程序的排名更靠前，更有可能被用户搜索到。
2、小程序广告
微信上线了广告功能， 搜索相关品类关键词，广告商的品牌就会得到优先展示。
3、海报+二维码
这是最常用的推广方法，即通过后台生成小程序二维码，并将其植入到海报或是户外广告中。需要注意的是，小程序的二维码不能用二维码生成器自动生成，渠道则有微信朋友圈、微信群、楼宇电梯、机场、活动现场等。
4、群聊群分享，实现粉丝裂变
商家在原有的粉丝群同步通知，让粉丝自主扩散。可引导粉丝分享，然后凭截图领取小礼物，逐步将流量引到小程序。
5、微信公众号本身的功能
微信开发了微信公众号文章跳转、关联小程序的功能，打通了公众号和小程序的链接，同时支持分享到微信群。
6、小程序商店
可以选择一个较好的平台，入驻微信小程序商店，比如拼多多小程序、京东小程序，目前有许多这样的平台。
7、小程序SEO
微信刚刚开放了小程序关键词搜索。想让用户更快速搜到你家的小程序，就要挑选合适的关键词，小程序后台可以设置10个关键词，用关键词来进行优化。
8、自媒体推广
内容自媒体平台软文+二维码推广，比如微博，一点资讯，今日头条，搜狐自媒体，网易自媒体等等。
9、地推
对于部分小程序而言，地推或许是最贴近用户场景的推广方式。线下以小程序码的方式，通过宣传物料等推广小程序。
10、通过移动端大号推广
以文案传播的方式可以有选择性的通过微博、微信公众号、朋友圈广告等形式推广，但那是在选择大号推广时，主要考察粉丝量和活跃度。
11、通过其他的社交媒体推广
把自己的小程序二维码通过图片或文案的方式，发布到其他社交网站或平台上用户可以直接识别二维码进入小程序平台。
12、通过微信搜索入口推广
微信搜索入口推广，微信目前有顶部的搜索框，小程序搜索框、发现栏的“搜一搜”，如何利用这个搜索入口？最主要的还是注册行业关键词作为自己的小程序名称，或根据自己的销售范围注册“地域+行业词”，还可以根据自己的业务模式注册“行业词+销售模式”或“地域+行业词+销售模式”。
13、通过好友分享和朋友圈推广
利用微信内的【社交属性】想要成为爆款小程序，那绝不能忽视的就是利用社交进行传播。比如：采用拼团特价、分享得优惠的方式，引导用户分享达到引流裂变的效果。
14、通过直接生成手机桌面快捷方式推广。
目前安卓手机支持小程序直接生成桌面快捷方式，类似APP，打开就可以直接使用相应的小程序。苹果手机暂时不支持，也可以肯定未来也不会支持。不过腾讯现在已经在开发手机操作系统，并与硬件厂商发布了首款搭载腾讯手机操作系统的手机。小程序的火爆已经是不可逆的趋势，未来人手一部腾讯手机也极有可能，到时候我们不需要下载任何APP，需要什么应用直接在小程序里面查找，觉得自己经常会用的直接生成桌面快捷方式就可以。
网络病毒视频推广 视频很重要，不用多大的前期投入后期制作专业镜头片段剪辑，弄个DV，边玩边拍边讲解，但是画质和音质起码要保证清楚。把标题和Tag都尽量选的好一点，最好做一些SEO。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52971b06dafbd4aa2e8777a6da0f377/" rel="bookmark">
			对DT的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对DT的理解
互动：构建面向目标的编程框架，多孪生体基于一个目标协同，自学习、自决策、自演进
内敛：修改设备的配置，自动引起设备性能如覆盖范围的变化。
这些都需要相关领域相当充足的知识储备
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792843f87c80346a36c477418f600940/" rel="bookmark">
			Redis 核心技术与实战-实践篇读书笔记 20～终结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 20 | 删除数据后，为什么内存占用率还是很高？如何判断是否有内存碎片？如何清理内存碎片呐？ 21 | 缓冲区：一个可能引发“惨案”的地方（暂略）23 | 旁路缓存：Redis 是如何工作的？只读缓存与读写缓存 24 | 替换策略：缓存满了怎么办？（即内存淘汰策略）如何处理被淘汰的数据？ 25 | 缓存异常（上）：如何解决缓存和数据库的数据不一致问题？只读缓存不一致的几种情况及解决方法 读写缓存同步直写时不一致的几种情况及解决方法 如何解决数据不一致问题？先操作 缓存，后操作 数据库解决：缓存延时双删 先操作 数据库，后操作 缓存 总结 26 | 缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？27 | 缓存被污染了，该怎么办？29 | 无锁的原子操作：Redis如何应对并发访问？如何解决？（两种方式） 30 | 如何使用Redis实现分布式锁？基于单个 Redis 节点实现分布式锁使用 SETNX 和 DEL 时存在的两个风险 基于多个 Redis 节点实现高可靠的分布式锁 31 | 事务机制：Redis能实现ACID属性吗？（暂略）32 | Redis主从同步与故障切换，有哪些坑？（暂略）33 | 脑裂：一次奇怪的数据丢失如何解决？ 36 | Redis 支撑秒杀场景的关键技术和实践都有哪些？37 | 数据分布优化：如何应对数据倾斜？数据量倾斜的成因和应对方法数据访问倾斜的成因和应对方法 39 | Redis 6.0的新特性：多线程、客户端缓存与安全 20 | 删除数据后，为什么内存占用率还是很高？ 主要原因：内存碎片引起的
内存碎片的产生主要是：（1）分配机制 （2）键值对大小不一样和删改操作
如何判断是否有内存碎片？ 看 INFO memory 命令中的 mem_fragmentation_ratio Redis 当前的内存碎片率指标。 mem_fragmentation_ratio 大于 1 但小于 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/792843f87c80346a36c477418f600940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1b06ad4cc1bdf6104bdeeb56fb7c5c/" rel="bookmark">
			CC2530实现ADC采集电池电压并通过串口发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CC2530ADC模块 1. 可选取的抽取率，设置分辨率（7~12位）
2. 8个独立的输入通道，可接收单端或差分信号
3. 参考电压可选为内部单端、外部单端、外部差分或AVDD5
4. 单通道转换结束可产生中断请求
5. 序列转换结束可发出DMA触发
6. 可将片内温度传感器作为输入
7. 电池电压测量功能，可以选择AVDD5/3 的电压作为一个 ADC 输入
二、CC2530ADC寄存器 ①ADCL、ADCH
从图中可以看出,ADC的采样值由ADCH和ADCL共同组成，因此在读取数据的时候需要进行数据处理。
② ADCCON1
Bit7:EOC位，当ADC转换完成，该位赋值为1，读取ADCH时，它就被清除。
Bit6:ST位,当该位为1的时候开启ADC转换
Bit[5:4]:设置ADC触发的事件,设置为ST为1开启触发
③ ADCCON3
Bit[7:6]:设置ADC的参考电压引脚,本实验设置为AVDD5
Bit[5:4]:设置ADC的采样精度,本实验设置为12,实际上计算的时候为13
Bit[3:0] :设置ADC单个转换的通道,本实验设置为VDD/3
三、实验代码 #include &lt;ioCC2530.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; typedef unsigned char uchar; typedef unsigned int uint; //32MHZ晶振ms延时函数 void DelayMS(uint msec) { uint i,j; for (i=0; i&lt;msec; i++) for (j=0; j&lt;1070; j++); } void InitAdc(void) { ADCH = 0; //ADCH寄存器清0,清EOC标志 ADCCON3 = 0xBF; //设置ADC参考电压为AVDD5引脚,ADC精度12位,ADC通道15为VDD/3 ADCCON1 |= 0X70; //设置ADC触发事件为.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b1b06ad4cc1bdf6104bdeeb56fb7c5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026aa01b9b73efd5f81397b1c16eef99/" rel="bookmark">
			实现Mybatis-Plus联表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：maven导入所需依赖包
&lt;dependency&gt; &lt;groupId&gt;com.github.yulichang&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-join&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; 第二步：Mapper接口继承父类MPJBaseMapper&lt;T&gt;
@Mapper public interface CemPsiUseMapper extends MPJBaseMapper&lt;CemPsiUse&gt; { } 第三步：注入Mapper接口
@Autowired private CemPsiUseMapper cemPsiUseMapper; 第四步：实例化条件构造器并可自定义设置搜索条件
MPJQueryWrapper&lt;CemPsiUse&gt; cemPsiUseMPJQueryWrapper = new MPJQueryWrapper&lt;&gt;(); cemPsiUseMPJQueryWrapper.selectAll(CemPsiUse.class); cemPsiUseMPJQueryWrapper.select("t1.maintain_name"); cemPsiUseMPJQueryWrapper.leftJoin("cem_place_maintains t1 on t.maintian_id = t1.id"); if(articleName!=null&amp;&amp; !articleName.equals("")){ cemPsiUseMPJQueryWrapper.like("t.article_name",articleName); } selectAll()方法为查询主表所有的字段，默认表别名为t
select()为查询其他表指定的字段，t1为表别名，select策略为追加，可以查询多个表数据， 一个select方法只能查询一个表的数据
leftjoin()方法为左连接
第五步：使用自动注入的Mapper接口方法进行查询或分页查询（这里使用分页）
Page&lt;CemPsiUseParamVo&gt; page = new Page&lt;&gt;(pageNo, pageSize); IPage&lt;CemPsiUseParamVo&gt; pageList = cemPsiUseMapper.selectJoinPage(page,CemPsiUseParamVo.class, cemPsiUseMPJQueryWrapper); CemPsiUseParamVo为最终查询结果映射实体类，因为是多表查询，所以某一个表的映射实体类不能包含所有字段
第六步：设置映射实体类
这一步即为将所需所有字段总结在一个实体类里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b4d02bca23bfdf4666c541102b9023/" rel="bookmark">
			小程序组件中的监听事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 小程序组件中的监听事件 需求：
微信小程序中，如果进行使用了component级的组件的话，在一些情况下，父组件中使页面中的数据进行变化，子组件中 的数据不会一起变化，由此可以使用该方法 方法：
使用observers方法对会发生改变的数据进行监听 observers与data同级 使用：
observers: { 'mage'(mage) { // mage 父组件中传过来的可能会进行改变的数据 如果进行改变的话，就继续执行 let arr = []; Array.from(this.properties.mage.newsTitle).forEach((item, i) =&gt; { if (i &lt; 26) { arr.push(item) } }) // e.detail.value.totalAmountTax.join().replace(/,/g, "") if (arr.length == 26) { arr.push('...') } // console.log(arr); this.data.stu = arr.join().replace(/,/g, "") // console.log(this.data.stu, '5151515151515151'); this.setData({	// 把获取到的数据放在data下面的这部分在页面中进行展示的数据中 stu: this.data.stu })	// 获取成功，一旦父组件中的内容出现更改，子组件中的数据同步进行，并且页面上一同更改 } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6627bba6f5c3ef84becdeffe6b2465b5/" rel="bookmark">
			【MyBatis】SpringBoot 和 MyBatis 一级缓存和二级缓存的介绍与代码实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念介绍 1、什么是一级缓存 在日常开发过程中，经常会有相同的 sql 执行多次查询的情况，Mybatis 提供了一些缓存来优化这些查询，避免多次请求数据库。一级缓存在 mybatis 中默认是开启的并且是 session 级别（但是想其生效，需要使用事务），它的作用域为一次 sqlSession 会话，在代码中需要使用事务才能生效。
一级缓存是 SqlSession 级别的缓存。在操作数据库时需要构造 sqlSession 对象，在对象中有一个数据结构（HashMap）用于存储缓存数据，缓存是 key-value 形式，key 可以看作 select 语句（key 还包含其他信息）。不同的 sqlSession 之间的缓存数据区域（HashMap）是互相隔离的。
2、什么是二级缓存 相对于一级缓存，二级缓存的作用域更广泛，它是 Mapper 级别的缓存，多个 SqlSession 去操作同一个 Mapper 的 sql 语句，多个 SqlSession 可以共用二级缓存。mybatis 的二级缓存默认也是开启的（但是想其生效，需要在 xml 文件中添加 cache 标签），但由于它的作用域是 namespace ，所以在代码中还需要在 mapper.xml 中写上 cache 标签才能生效。
3、缓存的优先级 通过 mybatis 发起的查询，作用顺序为：二级缓存 -&gt; 一级缓存 -&gt; 数据库。
4、缓存失效 当在一个缓存作用域中发生了 update、insert、delete 动作后，将会触发缓存失效，下一次查询将命中数据库，从而保证不会查到脏数据。
二、一级缓存（local cache、本地缓存、作用域默认为 SqlSession） 注意：对于会话（Session）级别的数据缓存，我们称之为一级数据缓存，简称一级缓存。
每当使用 Mybatis 开启一次和数据库的会话时，Mybatis 会创建出一个 SqlSession 对象表示一次数据库会话。在对数据库的一次会话中，有可能会反复的执行完全相同的查询语句，如果不采取一些措施，每一次查询都会查询一次数据库，而在极短的时间内做了完全相同的查询，它们的结果极有可能完全相同，由于查询一次数据库的代价很大，这有可能造成很大的资源浪费。为了解决这一问题，减少资源的浪费，Mybatis 会在会话的 SqlSession 对象中一个简单的缓存，将每次查询到的结果缓存起来，下次查询时，判断先前若有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6627bba6f5c3ef84becdeffe6b2465b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2099067d4b3109963f5d10a47cbe99a/" rel="bookmark">
			C&#43;&#43; 类使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C++ 类使用 1、类成员的初始化顺序 下面学习下，C++类成员的初始化顺序，例如：
class A { private: int n1; int n2; public: A():n2(0),n1(n2+2){} void Print(){ cout &lt;&lt; "n1:" &lt;&lt; n1 &lt;&lt; ", n2: " &lt;&lt; n2 &lt;&lt;endl; } }; int main() { A a; a.Print(); // 输出结果 n1:46 , n2:0 return 0; } 上面的程序输出时，n1的值是一个随机值，并不是符合预期的值，n2对应的值是0符合预期。下面总结下成员变量的初始化顺序
成员变量使用初始化列表初始化时，成员变量的初始化顺序与初始化列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序进行初始化，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。类中const成员常量必须在构造函数初始化列表中初始化。类中引用类型必须在构造函数初始化列表中初始化。类中static成员变量，必须在类外初始化。 2、构造函数与析构函数主动调用 2.1、构造函数主动调用 一般情况下在创建对象时，构造函数由编译器来调用。但是可以主动调用构造函数来创建匿名对象，例如：
class Person{ private: int age; public: Person(int age) { this-&gt;age = age; } void Display() const { cout &lt;&lt; "age = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2099067d4b3109963f5d10a47cbe99a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12c57b265a0b6a9aa351321c2fbc9fa/" rel="bookmark">
			谷歌与IE浏览器兼容问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取单选框选中的值
这种写法在chrome中无法获取所选标签的value属性的值 var search=$("input[type='radio'][name='search'][checked='checked']").val(); 改成如下方式，在IE和chrome中可获取所选标签的value属性的值
var search=$("input[type='radio'][name='search']:checked").val(); 谷歌不支持window.showModalialog的方式打开新窗口，窗口的大小等参数写法也不一样。 var openWindow=window.open('${ctxPath}/purchase.do?cmd=queryProvince', '','height=550,width=500,center=yes,top=200,resizable=yes,status=no,scrollbars=no'); 使用window.open打开新窗口，且在子页面关闭时获取子页面返回的数据
父页面： function queryProvince(){ var openWindow=window.open('${ctxPath}/purchase.do?cmd=queryProvince', '','height=550,width=500,center=yes,top=200,resizable=yes,status=no,scroll=no'); var tool = setInterval( function(){ if(openWindow.closed){ //在子页面对该标签的value进行赋值 var provinceCode = $("#provinceCode").val(); clearInterval(tool); } },200); } 在父页面的body中定义：
&lt;input id=”provinceCode” type=”hidden” /&gt; 子页面：
function click_save_btn(){ var returnStr=$('input:checked').val(); // 给父页面id为”provinceCode”的元素的value赋值 window.opener.document.getElementById("provinceCode ").value=returnStr; window.close(); } 如果想让iframe 的src属性指向一个空页面，可以写成：src=“”，而不能写成src=”#”判断当前使用的是否是谷歌浏览器，true为谷歌，false为IE。 window.navigator.userAgent.indexOf("Chrome") != -1 如果改为window.open()方法后仍然不生效
1、看下这个方法是不是在$(function{})中被调用的，在这里调用是不生效的，因为浏览器认为这不是用户主动想要跳转的，可以把windo.open()放在点击事件里调用
2、如果是谷歌生效而IE不生效，可以在代码中设置打开窗口时使用指定的IE版本： &lt;meta http-equiv="X-UA-Compatible" content="IE=11" /&gt; 子页面获取父页面的变量
父页面： window.username = “tom”; window.user={“name”:”jack”,”age”:18}; 子页面：
var username= window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e12c57b265a0b6a9aa351321c2fbc9fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa22b30d93e20d73b638b8e365384fe/" rel="bookmark">
			ubuntu18.04下安装OpenDroneMap(WebODM)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenDroneMap：开源的航拍影像处理工具库 前言1.安装1.1.安装docker1.2.下载WebODM 2.测试：2.1 下载数据集2.2 打开网站2.3 效果图 前言 OpenDroneMap-WebODM介绍：
OpenDroneMap 是一个开源的航拍影象处理工具，可以把航拍图像进行点云、正射影像和高程模型等转换处理。
WebODM 全称为 Web OpenDroneMap，顾名思义，它就是 OpenDroneMap 的 Web 界面版本
相比于 OpenDroneMap 命令行界面，同样的图像处理功能，WebODM 搭载在让人感到亲切的 UI 操作界面，用户体验更好了。
WebODM 处理后能生成多种结果，包括点云、GeoTIFF 等，可在 Web 界面做长度、面积等的测试或展示，更有利于 GIS 分析研究
1.安装 1.1.安装docker sudo apt update curl -fsSL https://get.docker.com -o get-docker.sh sh get-docker.sh sudo apt install -y git python python-pip 检查docker版本
docker-compose --version 如果上面命令没安装，执行安装
sudo pip install docker-compose 1.2.下载WebODM cd ~/tools/ git clone https://github.com/OpenDroneMap/WebODM cd WebODM sudo ./webodm.sh start 如果提示错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa22b30d93e20d73b638b8e365384fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432230da0877b51a24b2155490a0e83e/" rel="bookmark">
			opencv3.0的最简单图像系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencv3.0的最简单图像系统，初学者参考代码
设计想法：
文件：
打开测试文件（lena.jpg）
打开自定义文件
还原
清除
退出
帮助：
版权说明
关于
翻转：
水平
垂直
水平垂直
形态：
腐蚀
膨胀
开运算
闭运算
Morphological Gradient(形态学梯度)
顶帽
黑帽
滤波：
均值滤波
方框滤波：归一化 非归一化
高斯滤波
中值滤波
双边滤波
缩放：
放大（PyrUp）
缩小（PyrDown）
放大（Resize）
缩小（Resize）
旋转：
顺时针无缩放
顺时针缩放
逆时针
零旋转缩放
槽：
//打开当前目录下的测试文件lena.jpg
void on_openLenaJpg_triggered();
//打开自定义文件
void on_openCustomeFile_triggered();
//还原图像，将标签“目标图像”内的图像替换为原始图像
void on_restoreFile_triggered();
//清除标签内图像
void on_CLEAR_triggered();
//退出系统
void on_exitSystem_triggered();
//版权说明
void on_copyright_triggered();
//关于
void on_about_triggered();
//临时测试用
//void on_action_triggered();
//水平翻转
void on_Horizen_triggered();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/432230da0877b51a24b2155490a0e83e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdcf28b43b0c417f478baf094e1107ea/" rel="bookmark">
			electron 打包报错 npm ERR! code ELIFECYCLE npm ERR! errno 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错原因：路径文件夹有中文 把放项目的文件夹中文名换成英文即可
INFO Building app with electron-builder: • electron-builder version=22.14.13 os=10.0.19044 • description is missed in the package.json appPackageFile=F:\桌面应用\gitee-electron\electron-vue-updater\upms-dist\bundled\package.json • writing effective config file=upms-dist\builder-effective-config.yaml • rebuilding native dependencies dependencies=node-sass@4.14.1 platform=win32 arch=x64 • packaging platform=win32 arch=x64 electron=11.5.0 appOutDir=upms-dist\win-unpacked • rebuilding native dependencies dependencies=node-sass@4.14.1 platform=win32 arch=ia32 • packaging platform=win32 arch=ia32 electron=11.5.0 appOutDir=upms-dist\win-ia32-unpacked • building target=nsis file=upms-dist\upms Setup 7.0.1.exe archs=x64, ia32 oneClick=false perMachine=false ExecError: C:\Users\Dell\AppData\Local\electron-builder\Cache\nsis\nsis-3.0.4.1\Bin\makensis.exe exited with code ERR_ELECTRON_BUILDER_CANNOT_EXECUTE Output: Command line defined: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdcf28b43b0c417f478baf094e1107ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34ca393967011bce4424e74dda4c805/" rel="bookmark">
			Java开发注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一） 之 字符串判空
1、String 类中封装了自带的判空方法
可以看出：在且只在字符串长度为0时返回true。
2、那么就有以下问题
如果字符串未赋值，为null，会出现什么问题？
打断点测试一下：
结果：
java.lang.NullPointerException at com.road.api.controller.LoginController.login(LoginController.java:36) at com.road.api.controller.LoginController$$FastClassBySpringCGLIB$$a3f05868.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88) at com.road.api.common.aop.LockMethodInterceptor.interceptor(LockMethodInterceptor.java:51) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) at com.road.api.controller.LoginController$$EnhancerBySpringCGLIB$$3f29f80e.login(&lt;generated&gt;) at sun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34ca393967011bce4424e74dda4c805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1318b837419c1f4f5db7d9c778bfac9/" rel="bookmark">
			python学习（6）——分支结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任何简单或者复杂的算法都可以由顺序结构，选择结构，循环结构这三种基本结构组合而成。
顺序结构：
程序从上到下顺序的执行代码，中间没有任何的判断和跳转，直到程序结束
对象的布尔值：
使用内置函数bool() 获取
以下的对象的布尔值为False：
False
数值0
none
空字符串
空列表
空元组
空字典
空集合
布尔值的测试代码如下：
#测试对象的布尔值 print(bool(False)) print(bool(0)) print(bool(0.0)) print(bool(None)) #空字符串 print(bool('')) #空列表 print(bool([])) print(bool(list())) #空元组 print(bool(())) print(bool(tuple())) #空字典 print(bool({})) print(bool(dict())) #空集合 print(bool(set())) #其他对象的布尔值全部都为True 选择结构：
程序根据判定条件的布尔值选择性的执行部分代码
明确的让计算机知道在什么条件下，该去做什么
单分支结构：
语法形式：if 条件表达式：
执行条件体
money = 1000 #余额 s = int(input("请输入取款金额：")) #取款金额 #判断余额是否充足 if s &lt;= money: money = money - s print("取款成功，余额为：",money) print("取款成功，余额为："+str(money)) #用加号连接的时候money必须为str类型才可以连接 双分支结构：
语法结构：if 条件表达式：
条件执行体1
else：
条件执行体2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1318b837419c1f4f5db7d9c778bfac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8613ef67279f6f0b572774ff6d2ebcf8/" rel="bookmark">
			C语言 字母大小互相转换 三种思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.利用ASCII值方法（大小写相差32） 方法(1)
#include&lt;stdio.h&gt; int main() { char ch; printf("请输入一个字符：\n"); scanf("%c", &amp;ch); if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') { ch -= 32; printf("%c\n", ch); } else if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') { ch += 32; printf("%c\n", ch); } else { printf("输入的不是大写或者小写字母\n"); } return 0; } 方法 (2）
#include&lt;stdio.h&gt; void main() { char a; printf("请输入一个字母:"); scanf("%c", &amp;a); if (a &lt;= 91) //对应ASCII表判断输入字母的ASCII值，大写字母A~Z的ASCII值为65~91 { a = a + 32; //字母a~z的ASCII值为97~123，则给该字符加32之后，他的ASCII值变为对应的小写字母的ASCII值 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8613ef67279f6f0b572774ff6d2ebcf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9deab130a4ca7bb22aa574851e708912/" rel="bookmark">
			fastJson如何将json与对象、集合、数组相互转换呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自:
fastJson如何将json与对象、集合、数组相互转换呢？
下文笔者讲述fastjson在对象，集合，数组之间互相转换的方法分享，如下所示
fastjson简介
fastjson是阿里巴巴的开源JSON解析 它可以解析JSON格式的字符串 支持将Java Bean序列化为JSON字符串 也可以从JSON字符串反序列化到JavaBean 使用方法
Maven引入依赖
&lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.83&lt;/version&gt; &lt;/dependency&gt; 定义一个对象 User u =new User(); u.setId(8888); u.setUName("忘忧草"); u.setUPwd("1314521"); 一、对象转JSON
String json = JSON.toJSONString(user); //序列化 二、对象转JsonObject
JSONObject jsonObject=(JSONObject)JSON.toJSON(user); jsonObject.getIntValue("id")+jsonObject.getString("uPwd") 三、JSON 字符串转换为 Java 对象
User user =JSON.parseObject(json,User.class); //反序列化 四、JsonObject转对象
User user=JSON.toJavaObject(jsonObject, User.class); 五、JSON转Map
{ "msg": "操作成功!", "code": "200", "data": [ { "id": "0683d34aa31e4323be6d21b6d2bbd19eE41891461", "status": 1, "netAddress": "36.7.108.200" }, { "id": "0683d34aa31e4323be6d21b6d2bbd19eE41891466", "status": 1, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9deab130a4ca7bb22aa574851e708912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd2a0eb4334560f1b120eb06741ece5/" rel="bookmark">
			v-lazy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* vue插件一枚 1.长列表中图片是否加载完，没有加载完显示一张默认的加载图片 2.100张图片 默认优先加载可视区域（1屏幕2屏幕）的图片，不显示的不加载， 3. 滚动的时候图片元素是否在规定的加载区域没，如果在就加载 * 添加滚动的监听 * 谁有overflow scroll auto 4. new Image() onload() 5. 对外抛出的不是一个类 外部没有实例化 */ //创建了一个检测父元素有没有scroll的样式，要一层一层找 function getScrollParent(el) { // 获取子元素绑定overflow： scroll， auto 属性的父元素 //console.log(el); 这里的el是img元素 let parent = el.parentNode; while (parent) { if (/(scroll)|(auto)/.test(getComputedStyle(parent)["overflow"])) { return parent; } parent = parent.parentNode;//要每次都要重新给parent赋值，需要一层层向上找，有的话就把这个父元素的标签返回出来，没有就返回null } return null; } // 同步加载图片方法，在函数中加载图片的时候使用 function asyncImgLoad(src, resove, reject) { let img = new Image(); img.src = src; img.onload = resove; img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bd2a0eb4334560f1b120eb06741ece5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b700abdf26efee456ae4ad65a93bcdd/" rel="bookmark">
			【Spring注解驱动开发】00-Configuration Bean 注册组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记来源：✨尚硅谷Spring注解驱动教程(雷丰阳源码级讲解)
文章目录 Configuration Bean 注册组件1、准备工作pom实体类 2、@Bean 注解3、@ComponentScan 注解excludeFiltersincludeFilters@ComponentScansFilterType按照类型过滤自定义规则 4、@Scope 注解5、@Lazy 注解6、@Conditional 注解ConditionalConditionConditionContextAnnotatedTypeMetadata 总结 Configuration Bean 注册组件 1、准备工作 pom 引入 spring-context 依赖
&lt;dependencies&gt; &lt;!-- 核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试用 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Q：为什么只需要一个 spring-context？
A：查看 spring-context 的 pom 文件就一目了然了
查看 spring-context-4.3.12.RELEASE.pom 文件内容，其中引入 Spring 核心依赖 spring-aop、spring-beans、spring-core、spring-expression，所以引入 spring-context 一个依赖足矣
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b700abdf26efee456ae4ad65a93bcdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9dcf58a6d6b271b26cd0199e3a3d05b/" rel="bookmark">
			C&#43;&#43;引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引用概念 引用即为某个已存在的变量取别名，引用变量与被引用变量公用一块内存空间，比如西红柿、番茄都是同一物品的不同命名。通过在数据类型后、变量名前添加“&amp;”符号来定义引用类型。
int ival = 1024; int &amp;rename_ival = ival;//rename_ival为变量ival的引用（rename_ival为ival的别名） 二、引用特性 1、引用必须初始化 引用实质为“取别名”，故在取别名前必须已有名字，那么其实也要求了被引用的必须为一个对象。
2、一旦引用一个对象将无法引用其他对象 一般在初始化变量时，初始值会被拷贝到新建对象，而在定义引用时则是将初始值与引用进行绑定，故引用一旦引用一个对象将无法引用其他对象，对引用的赋值实质为对被引用对象的赋值,以下代码即可证明。
#include &lt;iostream&gt; int main() { int ival = 1024; int&amp; rename_ival = ival; int new_ival = 2048; rename_ival = new_ival; std::cout &lt;&lt; "ival = " &lt;&lt; ival &lt;&lt; std::endl; std::cout &lt;&lt; "rename_ival = " &lt;&lt; rename_ival &lt;&lt; std::endl; return 0; } 3.一个变量可有多个引用 一个变量可以有多个引用，可通俗理解为一个人可以有多个昵称。
三、const引用 const引用即将引用与const对象绑定。由于const引用是为const对象取别名，故无法通过修改const引用修改被引用的const对象。
//使用场景1 const int ival = 1024; const int &amp;reival1 = ival;//正确 int &amp;reival2 = ival;//错误：将非常量引用指向常量对象，将被引用对象的只读特性改变为可读可写，是权限的放大，不被允许 int ival3 = 2048; const int &amp;ival4 = ival3;//const引用可引用非常量对象，允许权限的缩小。 //使用场景2 #include &lt;iostream&gt; int main() { double ival1 = 1024.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9dcf58a6d6b271b26cd0199e3a3d05b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8edb0cbc7c797ba4aef32b3605110e18/" rel="bookmark">
			nginx 反向代理 获取客户端真实IP和域名以供日志分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：
客户网站或者移动APP在请求到达后端服务之前，会经过层层代理的转发。
典型的是CDN（反向代理+Squid缓存），如果是带有安全或者WAF功能的则结构要更为复杂些。
一般的解决方案： proxy_set_header Host $host; proxy_set_header X-real-ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 后端服务获取客户端真实IP的方法：
request.getAttribute("X-real-ip") 现象：
后端服务获取到的IP并不是客户端真实IP，而是某一级代理的IP。
分析：
从CDN开始，每经过一个代理做一次转发，x_forwarded_for就会在后面追加一个代理IP。请求到达nginx时，x_forwarded_for已经变成一个以逗号分隔的ip串，并且以转发顺序排序。
nginx的内置变量remote_addr仅能代表nginx的上一层代理的IP，现有的nginx配置将该值赋给X_Real_Ip，那么后端获取到的X_Real_Ip也是nginx上一层代理的IP，而不是客户端真实IP。
其他解决方法：
如果采用阿里腾讯华为百度西数等云的cdn控制台可以进行参数设置IP寻址方式，但美中不足的是不能设置user-agent请求方式（无法判断），所以只能在客户端编码的形式进行获取真实IP。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb0c17232618c4a5cd317b5bfdfa9b6/" rel="bookmark">
			List多字段排序，orderBy，ThenBy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先去重，再分页，再排序。
List排序问题，orderBy，ThenBy
1、List中一个字段排序
前几天做的项目中，获取的List&lt;T&gt;需要用某个字段来进行排序，困扰了很久。用OrderBy解决了。具体是这样的。
List.OrderBy(i=&gt;i.id):表示根据id来排序，默认是升序。
List.OrderByDescending(i=&gt;i.name):根据name排序，降序排列。
2、List中两个字段排序：
写法如下，直接用例子：
List.OrderBy(i=&gt;i.id).ThenBy(i=&gt;i.name);表示先根据id排序，然后根据name排序。顺序是先前再后。根据自己需要些就好。
3、List中有多个字段的写法：
List.OrderBy(i=&gt;id).ThenBy.(i=&gt;i.name).ThenBy().ThenBy.....
如果要来将获取的数据取前多少条，用Take（）方法。例如：前10条。Take(10);
List.OrderBy(i=&gt;id).ThenBy.(i=&gt;i.name).ThenBy().ThenBy.....Take(10);
多字段降序用ThenByDescending.
注意：好像不能这样写：List.OrderBy((i=&gt;i.id) &amp;&amp; (i=&gt;i.name)). 这样写是不对的，因为lambda表达式不能使用“&amp;&amp;” 符号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad562f103f056202bb05104e1147cf6d/" rel="bookmark">
			基于Mybatis&#43;Maven&#43;（*）的图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现的需求（暂时，后续会添加）： 在线录入学生信息和书籍信息 √查询书籍信息列表查询学生信息列表查询借阅信息列表完整的日志系统 项目准备阶段 数据库准备阶段 项目取名为BookManger，在Navicat中创建数据库为book_manage，包含三个表分别为学生，书籍，将学生与书籍连接起来的借阅表如下图
程序准备阶段 在IDEA创建BookManage，配置maven，导入如下坐标
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;BookManger&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 将创建时的配置文件删除，自己定义使用mapper的配置文件，连接上述所述的数据库如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad562f103f056202bb05104e1147cf6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2faf052f04091ae83853c164a03ce26d/" rel="bookmark">
			什么是PON？EPON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光纤接入网（Optical Access Network，OAN）是指在接入网中采用光纤作为主要传输介质来实现信息传送的网络形式，根据光纤接入网传输设施中是否采用有源器件分为AON有源光网络和PON无源光网络。根据采用的技术不同，PON可以分为APON，即基于ATM技术的无源光网络，后来更名为BPON宽带无源光网络；EPON，基于以太网的无源光网络；GPON吉比特无源光网络，GPON是BPON的扩展。
AON比PON传输距离长，传输容量大，业务配置灵活，但不足之处是成本高、需要供电系统、维护复杂。而PON结构简单，易于扩容和维护，所以在接入网当中，PON得到越来越广泛的应用。
PON网络组成、拓扑结构 国际电联ITU-T G.982建议给出了OAN（PON）的功能参考配置，主要包含4个基本功能模块：光线路终端OLT、光网络单元ONU、光分配网络ODN、AN系统管理功能模块。
各个模块的功能如下：
OLT：OLT的作用是通过一个或多个ODN光纤分配网与用户侧的ONU通信，OLT与ONU的关系为主从通信关系，OLT对来自ONU的信令和监控信息进行管理。OLT设备一般部署于运营商基站，或业务节点机房。ONU：位于ODN光纤分配网和用户之间。ONU的网络侧具有光接口，而用户侧为电接口。一般家庭用户，采用的都是光猫，单芯光纤即可。当然，也可以使用ONU，不过要使用2芯光纤，对纤芯资源浪费比较大。ODN：是光纤接入网中的传输设施，即光纤网络，为ONU和OLT提供光传输通道，作为两者之间的物理连接。ODN包含光纤、光缆交接箱、光连接器（尾纤）、无源光分路器（Optical Branching Device，OBD）（分光器）和光纤接头等。这些光纤网络的组成部分，都是由无源光器件组成，这也是PON无源光网络名称的来源。AN管理模块：负责对光纤接入网进行维护管理，包括配置管理、性能管理、故障管理、安全管理及计费管理，这主要指的是网管系统。 PON网络拓扑结构主要分为星形结构、树型结构和总线型结构。在实际工程中，采用比较多的是树形结构，树形结构是星形结构的扩展。连接OLT的第1个分光器OBD将光信号分成n路，下一级连接第2级分光器OBD或直接连接ONU，最后一级的分光器OBD连接n个ONU。
树形结构的线路维护容易、不存在雷电及电磁干扰，可靠性高。但由于OLT的一个光源提供给所有ONU光功率，光源的功率有限，限制了所连接ONU的数量以及光信号的传输距离。
根据光网络单元ONU设置的位置不同，光纤接入网可分成不同的类型,主要包括光纤到路边FTTC、光纤到大楼FTTB、光纤到家FTTH或光纤到办公室FTTO等。一般小区覆盖都是采用FTTH的类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7045e8b328de140f38ae65fbb4402ab/" rel="bookmark">
			error while loading shared libraries: libm.so.6: cannot open shared object file: No such file or解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在调试代码的过程中，遇到了
ImportError: /lib64/libm.so.6: version `GLIBC_2.23‘ not found (required by /root/anaconda3/lib/pyt
后来按照
​​​​​​解决ImportError: /lib64/libm.so.6: version `GLIBC_2.23‘ not found (required by /root/anaconda3/lib/pyt_永胜永胜的博客-CSDN博客_libm.so.6
进行操作，发现没有可以编译的，然后linux就真的陷入了崩溃，home文件夹也变得打不开，打开终端显示：
觉得是缺少了libm.so.6的原因，就在
libm.so.6放到/usr/lib64/_libm.so.6-Linux文档类资源-CSDN下载
下载好libm.so.6文件，又通过anydesk传到服务器，感谢我的室友帮我在终端窗口完成了将libm.so.6转移到 /usr/lib64/ 文件夹下，后面系统才恢复正常
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/231/">«</a>
	<span class="pagination__item pagination__item--current">232/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/233/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>