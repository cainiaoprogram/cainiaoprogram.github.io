<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1976f53f46d21fbefd03c4277229c2b3/" rel="bookmark">
			Nginx静态资源POST请求返回405状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://my.oschina.net/lemonzone2010/blog/174505 同事给了一个json请求，在HTTP接口测试工具中post请求结果返回405状态，get请求则返回数据。搜了一番发现返回405是因为Apache、IIS、Nginx等绝大多数web服务器，都不允许静态文件响应POST请求。 试了网上的好几种方法，下面这个受用，通过upstream转换静态文件接收的POST请求到GET方式
upstream static_resource { server localhost:80; } server { listen 80; server_name app.test.com; root /home/app.test.com/; location / { root /home/app.test.com/; index index.shtml index.html; } error_page 405 =200 @405; location @405 { root /home/app.test.com/; proxy_method GET; proxy_pass http://static_resource; } 再次在HTTP接口测试工具测试，发现405变成了404，想了一下，是因为web服务器上配置了多个虚拟主机监听在80端口，upstream默认访问的是一个配置文件中的第一个虚拟主机，而不是我要放行post请求的app.test.com，于是尝试在定义一个虚拟主机监听在81端口，指向app.test.com
server { listen 81; server_name app.test.com; root /home/app.test.com/; location / { root /home/app.test.com/; } } 同时修改upstream中server，再次请求返回状态由405变成200
upstream static_resource { server localhost:81; } 下面备注下网传的方法，此方法我配置后无效
error_page 405 =200 @405; location @405 { root /home/app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1976f53f46d21fbefd03c4277229c2b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b462b112cb10f4830fe1c4b1d2415a/" rel="bookmark">
			教你使用AndroidStudio关联源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从转到了AndroidStudio开发之后，发现确实是一款开发神器。但唯一一点就是没有给我关联到源码，每次看到的都是这种情况。 注意看上面有句话Sources for ‘Android API 23 Platform’ not found就说明没有关联到源码。 每次重写方法的时候看到参数列表，我的内心是奔溃的。 在网上找了半天解决方法，终于找到了。下面就来告诉大家怎么搞定它！
首先进入C盘找到\Users\用户名\.AndroidStudio2.0\config\options这个目录，在里面找到这个文件jdk.table.xml文件，让我们先来看下里面有什么。 注意看里面有个 sourcePath这里面配置的就是源代码路径了。
要关联源码，首先你SDK里面得有源码。 最后一步了，就是把jdk.table.xml这个文件给删了，没错就是这么暴力，然后在重启AndroidStudio你就会神奇的发现OK，搞定了！让我们来看下效果 这下看参数列表就舒服多了， 源码也不是抛异常了！ 这就是解决Window下没有关联到源码的方法，如果是Mac平台的话可以参考一下差别应该也不大。 小白初来乍到，如有不周请多多包涵！
个人CSDN地址：http://blog.csdn.net/a_zhon 个人github地址：https://github.com/azhon
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98822183346516c7fad77d2ac6fe2dd/" rel="bookmark">
			小指数rsa 多线程版writeup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载flag.enc 和pubkey.pem文件
将pem文件拖入openssl得到n(modulus)和e(exponent)
openssl rsa -pubin -text -modulus -in pubkey.pem
需从github下载libnum,gmpy
from multiprocessing import Pool
from libnum import s2n
import gmpy
workerCount=4
n=0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929
e=3
f=open('exp/flag.enc','rb')
c=f.read()
c=s2n(c)
f.close()
def worker(workerID):
global workerCount
print("[%d] " % workerID, "Worker start, workerID =", workerID, ",workerCount =", workerCount)
ibase = 0
i = ibase + workerID
while True:
gTempC = gmpy.mpz(c + i * n)
(M, flag) = gmpy.root(gTempC, e)
if flag == True :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e98822183346516c7fad77d2ac6fe2dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5bdafe79a6df5e44ad5e3d741d03235/" rel="bookmark">
			Particle for alexa smart home skill (6)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面幾章已經完成了大部分的準備工作， 接下來可以正式測試了。
第六章、啟用 alexa skill &amp; 測試
1) 打開 amazon echo app, 點擊Home菜單
2) 點擊 Skills
3) 點擊 Your Skills
4) 點擊我們建好的 skill: particle0815
5) 點擊 Enable Skill, app 會調會驗證 particle 賬號 和 Lambda 賬號, 只有賬號驗證通過并且 alexa skill 配置正確才能 Enable skill成功。
6) 點擊 Discover Device
發現到2個設備 Bedroom Light 和 Kitchen Light (之前在 Lambda 中定義的)
7) 向 alexa dot 發送語音命令: alexa, turn on/off the bedroom/kitchen room light 即可打開/關閉 A4/A5 的LED燈.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5bdafe79a6df5e44ad5e3d741d03235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a92e51df3a66350d5fca539a2a6edd/" rel="bookmark">
			如何用C&#43;&#43;写一个简单的小游戏？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：JustForFun 链接：http://www.zhihu.com/question/22108858/answer/51858521 来源：知乎 著作权归作者所有，转载请联系作者获得授权。
首先我分析下你的问题： “怎么从我们这样一开始学C++到能做一个像平时玩的一个简单的游戏”
“从我们这样一开始学C++”　这是你的现在状态，那么我假定：你还没有C++入门咯，或者C++刚完成“理论部分” 其实第一个答主， Clones 这位同学说的是调用游戏引擎和图形库去开发游戏，我觉得题主还没有达到这个水平，所以我暂时不和你说一些图形库和游戏引擎。 我认为你是刚入门。（如果我理解错了，请纠正O(∩_∩)O哈！）
“能做一个像平时玩的一个简单的游戏” 我不知道咯租户对于这个“简单的游戏”是怎么定义的？
1. 黑窗口的贪吃蛇你玩过没？ （你懂黑窗口吧，就是cmd菜单，就是你第一次输入”hello world”那个黑黑的窗口，学术名：控制台程序） 听懂了吗？
2. 或者说，你所谓“简单游戏”，是电脑上的“拳皇“，”合金弹头“，这些单机， 或者一些更炫的桌游或者，现在很流行的撸啊撸这类网游。
3. 或者说，你想要的是安卓手机上，社么”2048“ “天天酷跑 ” “3D飙车”
这三类都是游戏，所谓”简单”，我觉得不好理解。 我建议楼主以后问问题的时候，可以打个比方，举个详细的例子，否则他人无法理解，你到底想要什么？
言归正传，我上面标记为1的是楼主必须要会的，就是你如果想做2,3，这种类型的游戏，第一步 1代表的控制台程序必须要会。
这些游戏，比如 “贪吃蛇” ”俄罗斯方块“ ”飞行器“ 这类控制台的游戏，虽然无趣，但是如果你想做一些看起来很炫很艳丽的2,3类游戏，相信我，你控制台这关，最好是认真做完。 这类游戏，你可以去图书馆借一本 ”C语言课程设计” 这本书真的认认真真学完，敲出每一行代码，你的面向过程编程能力，基本可以放心了。 有什么代码细节搞不定，上 CSDN， 博客园，overflow 去问，去发帖问。 问百度。 翻墙问谷歌。 但如果是架构上的问题，问老师吧或者一些 “真的很” 牛逼的学长。
不要急躁，打基础这一步，千万不要跳 完成这一步，第1类游戏相信，对你来说不在话下，更重要的是，你的C语言功底绝对会有一个很大提升。
第二，当你第一步完成了，1类游戏搞定了，那我就可以告诉你，第二类游戏，会接触4个概念：面向对象编程OOP，游戏引擎，可视化编程，GUI（图形界面） 这个时候C++的确可以做，一些简单的带图形的游戏。
至于用了啥技术，你把我说的下面这本书看一下，就都知道了，码字好累。。。
比如，你能力够，完全可以把 合金弹头 那种游戏，或者 手机上 天天酷跑 这些游戏移植到windows上来，只是你至少要去图书馆借一本书：
当初我倒是做过一个 坦克大战的windows版。可惜源码已不知所踪。 你可以百度试试有没有写好的源码。
这本书当时我是下的pdf版，如果嫌弃太老了，你去图书馆借一本和这本书类似的吧，推荐我就不了，其实我也就完整看了这一本，我觉得对于初学者，够了。
至于第3类，那是安卓程序，所以，你至少需要再学一门java，它不是C++能搞定的， 然后再百度 “安卓开发入门” 然后再百度安卓游戏开发
之后，等你搞清楚什么是安卓开发的，搞定java基础，对OOP有一点实战经验， 而且决心做安卓，再去做 社么 “天天酷跑”子类的游戏吧、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a92e51df3a66350d5fca539a2a6edd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eea0dab3782fa1d4fd14383d4e89372/" rel="bookmark">
			AD10 自动布线的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		altium 对某一部分自动布线的时候，其他部分的过孔会消失：
这是我老师的解释：
解决办法如下：
1.锁定已有的布局：
1.1：选中已经存在的布局，包括元件和线，还有过孔等
1.2：按下F11键，然后选中锁定
2.在自动布局之前设置好锁定以前所有的布局选项，如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdb46b54ca0abe596c1e715993b0319/" rel="bookmark">
			经典dp模型的变形（未完待续。。)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天做了几道dp题，发现有几道是很经典的dp模型的变形，总结一下：
数字三角形 这算是dp的最最最入门的题了吧，但是这题变形的话，还是需要好好想想才能看出来的。 题目：hdu 1176 免费馅饼 题意：
一定时间，天上会从某个位置Xi掉下一块馅饼，1&lt; =xi&lt; =10，这个人位于xi，只能接到xi-1,xi,xi+1，三处之一，问这人可以接到的最多馅饼？
分析：
这题想想还是挺有意思的QAQ，因为是按照时间落馅饼，所以dp的方向是显然的，就是按照时间，第二维当然就是位置了！所以用dp[i][j]表示在i时刻这个人在j位置可以得到的最大馅饼数，num[i][j]表示i时刻j位置落下的馅饼数，不难写出dp方程: dp[i][x]=max(dp[i-1][x-1],dp[i-1][x],dp[i-1][x+1])+num[i][x] 想明白后，0时刻在5这个位置，然后顺着时间转移，转移到最后一块馅饼落下的时刻，那么这题不就做出来了吗？当然可以！注意下边界即可。 仔细想想这题，这不就是数字三角形吗？所以逆推很容易就可以搞定了！
const int N=1e5+2; int n,x,T,t,f[N][11]; int main() { while(~scanf("%d",&amp;n)&amp;&amp;n){ T=0; memset(f,0,sizeof(f)); for(int i=0;i&lt;n;i++){ scanf("%d%d",&amp;x,&amp;t); f[t][x]++; if(T&lt;t)T=t; } for(int i=T-1;i&gt;=0;i--){ for(int j=1;j&lt;=9;j++) f[i][j]+=max(f[i+1][j+1],max(f[i+1][j],f[i+1][j-1])); f[i][0]+=max(f[i+1][0],f[i+1][1]); f[i][10]+=max(f[i+1][10],f[i+1][9]); } cout&lt;&lt;f[0][5]&lt;&lt;endl; } return 0; } 背包问题 背包问题无疑是变形最多的一类dp题，要想掌握好这类题目，关键还是要深刻理解01背包和完全背包！当然还有更多变形，像分组背包，有依赖的背包，泛化背包等，都是些不好掌握的东东，当然做题时如果能看出这是背包的题目，就离解决问题更近了一大 步！ （此处应有各种背包的分类，等多做几道题后再补QAQ）
完全背包 题目：hdu 1114 Piggy-Bank 题意：
存钱罐里有一些硬币，总共重量是F，空罐重量是E，给出n种钱币，每种钱币的有两个参数，v价值，w重量。问存钱罐中最少的价值是多少？
分析：
赤裸裸的完全背包的题目，注意初始化。
const int INF=0x3f3f3f3f; const int N=1e4+9; int n; int E,F; int f[N],p[N],w[N]; int main() { int T; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fdb46b54ca0abe596c1e715993b0319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95dbb4004c4373b4c3913b54c59cbb5b/" rel="bookmark">
			Ubuntu 修改 ssh远程端口号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中SSH默认端口为22，为了安全考虑，我们有必要对22端口进行修改，现修改端口为60000；
修改方法如下：
在/etc/ssh/sshd_config中找到Port 22，将其修改为60000,或使用/usr/sbin/sshd -p 60000指定端口。
如果用户想让22和60000端口同时开放，只需在/etc/ssh/sshd_config增加一行内容如下：
[root@localhost /]# vi /etc/ssh/sshd_config
Port 22
Port 60000
保存并退出
[root@localhost /]#service ssh restart
如果远程登陆的时候提示 ：no route to host ，应该是防火墙没配置好对应端口的权限，在防火墙设置下就ok了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d19ffc8396bf51fbbd85b6790e2d957/" rel="bookmark">
			ArrayList的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是ArrayList
ArrayList就是传说中的动态数组，用MSDN中的说法，就是Array的复杂版本，它提供了如下一些好处：
动态的增加和减少元素实现了ICollection和IList接口灵活的设置数组的大小 2、如何使用ArrayList
最简单的例子：
ArrayList List = new ArrayList();
for( int i=0;i&lt;10;i++ ) //给数组增加10个Int元素
List.Add(i); //..程序做一些处理
List.RemoveAt(5);//将第6个元素移除
for( int i=0;i&lt;3;i++ ) //再增加3个元素
List.Add(i+20);
Int32[] values = (Int32[])List.ToArray(typeof(Int32));//返回ArrayList包含的数组
这是一个简单的例子，虽然没有包含ArrayList所有的方法，但是可以反映出ArrayList最常用的用法
3、ArrayList重要的方法和属性
（1）构造器
ArrayList提供了三个构造器：
public ArrayList();
默认的构造器，将会以默认（16）的大小来初始化内部的数组
public ArrayList(ICollection);
用一个ICollection对象来构造，并将该集合的元素添加到ArrayList
public ArrayList(int);
用指定的大小来初始化内部的数组
（2）IsSynchronized属性和ArrayList.Synchronized方法
IsSynchronized属性指示当前的ArrayList实例是否支持线程同步，而ArrayList.Synchronized静态方法则会返回一个ArrayList的线程同步的封装。
如果使用非线程同步的实例，那么在多线程访问的时候，需要自己手动调用lock来保持线程同步，例如：
ArrayList list = new ArrayList();
//...
lock( list.SyncRoot ) //当ArrayList为非线程包装的时候，SyncRoot属性其实就是它自己，但是为了满足ICollection的SyncRoot定义，这里还是使用SyncRoot来保持源代码的规范性
{
list.Add( “Add a Item” );
}
如果使用ArrayList.Synchronized方法返回的实例，那么就不用考虑线程同步的问题，这个实例本身就是线程安全的，实际上ArrayList内部实现了一个保证线程同步的内部类，ArrayList.Synchronized返回的就是这个类的实例，它里面的每个属性都是用了lock关键字来保证线程同步。
****
但是，使用这个方法（ArrayList.Synchronized）并不能保证枚举的同步，例如，一个线程正在删除或添加集合项，而另一个线程同时进行枚举，这时枚举将会抛出异常。所以，在枚举的时候，你必须明确使用 SyncRoot 锁定这个集合。
Hashtable与ArrayList关于线程安全性的使用方法类似。
****
（3）Count属性和Capacity属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d19ffc8396bf51fbbd85b6790e2d957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40cf79d5928bdde46236ca125c760932/" rel="bookmark">
			to_number() ----函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 用法简介 TO_NUMBER函数()是Oracle中常用的类型转换函数之一，主要是将字符串转换为数值型的格式，与TO_CHAR()函数的作用正好相反。
To_number函数的格式如下：
&lt;code class="language-SQL hljs livecodeserver has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;"&gt;To_number（varchar2 &lt;span class="hljs-operator" style="box-sizing: border-box;"&gt;or&lt;/span&gt; &lt;span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;"&gt;char&lt;/span&gt;,’&lt;span class="hljs-built_in" style="color: rgb(102, 0, 102); box-sizing: border-box;"&gt;format&lt;/span&gt; model’）&lt;/code&gt;&lt;ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40cf79d5928bdde46236ca125c760932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30654f9f2391ea5552e6a7dc76c39057/" rel="bookmark">
			CTP源码分析3 CTP链路质量估计层结构及源码分析（二）----LEEP协议中的Trickle算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LEEP帧的发送的时间间隔不是固定的，而是采用了非常巧妙的方法兼顾了链路质量估计的变化和广播帧发送的开销。
受到Trickle算法加持的LEEP协议实现是下面的效果：当链路刚刚开始构建的时候这个时候拓扑还没有构成，那么就需要进行大量的LEEP帧发送，来进行链路估计和路由建立；当拓扑结构逐渐趋向于稳定的时候，这个时候LEEP帧的发送频率会逐渐降低（但降低到一定程度便不再降低了）。但是如果一旦发现了路由没有形成或者路由需要变换以及有新节点的加入，那么就会将LEEP帧的发送频率重新置到最高。
Trickle（涓流）算法
Trickle做到了LEEP帧发送频率的逐渐减弱的效果。
Trickle算法的核心在于计时器，和一个时间区间[Imin，Imax]，以及一个时间点t。时间区间I一开始是是Imin，但是这个I并不是最终的间隔时间，时间点t是最终发送LEEP帧的时间点，t和I满足下面的关系，t在区间[I/2，I]中随机取一个值，如果在一次LEEP帧发送之后没有出现任何意外，整个系统的拓扑结构稳定，那么就I就翻倍，然后重新选出一个t时间点然后在t的时间点发送LEEP帧，这样子就达到了发送间隔逐渐边长的效果，并且整个系统发送的平均时间间隔达到了3I/4。当然I的增加不是无限的，只要达到了Imax就不再增加。其实看结果是在不断扩大t的取值，但是实际上是在让3I/4这个值（系统平均的LEEP发送时间间隔）在链路质量稳定的情况下不断翻倍。一旦检测到类似于节点的物理空间转变或者新节点的加入，那么就要重置I为Imin，然后重复这个过程。而Imin和Imax是要人为设定的。当然TinyOS中的实现也有些出入，不过大体就是这个思路。
Trickle算法的精神在路由引擎中得以实现，因为正如前文所说路由帧和LEEP帧2位一体，所以Trickle算法来路由引擎中发送路由帧的计时器上得以体现。
下一篇将会开始进入看源码实现的环节。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/959d027e3528dfb90366ceb443aaedc8/" rel="bookmark">
			CTP源码分析1 CTP结构及概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTP做了什么
试想一个情景，在一定的物理空间中有很多的传感器，这些传感器会和你的一个手持设备进行通信，返回一些数据供你使用，那么这个通信应该如果做呢。最简单的一种想法就是这些节点和直接和手持设备进行通信，这就要求所有的传感器（通信节点）都在手持设备的通信范围之内，这就大大缩小了传感器可以放置的物理空间。而CTP通过在传感器以及手持设备之间组网，通过传感器与手持设备之间的多跳通信大大扩展了传感器放置的物理空间。换言之传感器既充当了信息的的采集和发送者，又充当了其他传感器信息的转发者，而传感器（普通节点）和手持节点之间就形成了一个汇聚树，手持设备（将信息进行集中汇总的节点）就是这个汇聚树的根。
我们将这个场景抽象出来，就是这样：
左边是最简单的思路，右边是CTP的方式
CTP如何实现
CTP（汇聚树协议）实现了灵活动态的树状拓扑结构，并满足拓扑中其他节点与根节点的单向通信。为了实现灵活动态的拓扑结构变化，CTP蕴含了两个稳定有效的汇聚树原则，这些原则可以让汇聚树得以获得稳定有效的连接质量估计，并且通过连接质量的估计值获得通往根节点的路径。当每个节点都获得通往根节点的路径之后，汇聚树也就形成了。
第一个原则是保证数据通道的有效性原则。CTP协议在数据传输的时候可以动态地进行拓扑结构的探测，快速发现并且修复路由环路。第二个就是自适应信标（beacon）原则，根据CTP协议，每个节点都会定时地发送广播帧，来进行链路质量的估计和拓扑结构的建立。而广播帧发送的时间间隔并不是固定的，CTP扩展了涓流算法（Trickle code），在广播帧的发送的时间间隔方面做了文章，在兼顾了路径修理延迟的基础上可以发送更少的广播帧。
TinyOS实现了CTP协议，旨在达成汇聚树协议的4大目标：
1、可靠性：99.9%的包发送成功率，即便在比较恶劣的条件下也可以达到90%的包发送成功率。
2、健壮性：汇聚树协议可以实现灵活的拓扑调整，可以根据节点的实时位置和网络情况自动变换拓扑而不需要人为的干涉。
3、高效率：只需要发送少量的数据包就可以达到高效性和健壮性的目标。Trickle算法和通过数据包发送成功率来计算链路质量的方式功不可没。
4、硬件独立性
CTP协议在结构上一共分为3层，从下到上分别是：
1、链路质量估计层。在这里有LEEP协议来实现Trickle算法，维护一个链路质量估计表，统计周边节点和此节点的连接质量。
2、路由引擎。这一层将进行路由帧的发送，值得一提的是，路由帧的发送使用的书链路质量估计层提供的发送接口，这个发送接口在路由帧的头部和尾部分别套上了LEEP帧的帧头和帧尾（header and footer）。这意味着路由的形成、链路质量的估计2位一体。
3、转发引擎。这一层主要是进行数据包的发送和其他节点数据包的转发，并且通过ACK帧来计算转发的成功率。将成功率回馈给链路质量估计层。由此来看，汇聚树中所有的数据包都将直接或者间接对链路质量估计值产生影响。此外转发引擎还维护了一个发送队列，这个发送队列提供了阻塞警告。
上面就是CTP结构的示意图。
接着说转发引擎。
CTP之所以可以实现灵活的拓扑主要是因为每个节点都可以灵活地找出在不同的网络环境下的父节点，无论是转发帧还是此节点自己发送的数据帧，都是发往在那个时刻的父节点的。但是这样子很可能会出现被称之为“路由环路”东西。这种情况是绝对不允许存在的，这样子会导致数据包的循环发送，并且数据包永远也到不了根节点，所以在转发引擎中还做了路由环路的侦测工作，一旦发现路由环路，那么发现路由环路的节点就要从路由表选出一个信号强度“合适”的父节点代替现有父节点。
帧类型
CTP一共两种数据帧，一个是路由帧（LEEP帧），还有一种是数据帧，路由帧由路由引擎发送，负责组网工作。数据帧是由转发引擎发送，是基于CTP的数据平台一切功能的基础。
路由帧：
数据帧：
具体功能后面展开。
以上就是CTP三个模块的工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97efa3b607b604873cc274e91fb35233/" rel="bookmark">
			struts2的处理请求的全过程是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个请求在Struts2框架中的处理步骤： a) 客户端初始化一个指向Servlet容器的请求； b) 根据Web.xml配置，请求首先经过ActionContextCleanUp过滤器，其为可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助（SiteMesh Plugin），主要清理当前线程的ActionContext和Dispatcher； c) 请求经过插件过滤器，如：SiteMesh、etc等过滤器； d) 请求经过核心过滤器FilterDispatcher，执行doFilter方法，在该方法中，询问ActionMapper来决定这个请求是否需要调用某个Action； e) 如果ActionMapper决定需要调用某个Action，则ActionMapper会返回一个ActionMapping实例（存储Action的配置信息），并创建ActionProxy（Action代理）对象，将请求交给代理对象继续处理； f) ActionProxy对象根据ActionMapping和Configuration Manager询问框架的配置文件，找到需要调用的Action类； g) ActionProxy对象创建时，会同时创建一个ActionInvocation的实例； h) ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用； i) 一旦Action执行完毕，ActionInvocation实例负责根据struts.xml中的配置创建并返回Result。Result通常是一个需要被表示的JSP或者FreeMarker的模版，也可能是另外的一个Action链； j) 如果要在返回Result之前做些什么，可以实现PreResultListener接口，PreResultListener可以在Interceptor中实现，也可以在Action中实现； k) 根据Result对象信息，生成用户响应信息response，在生成响应过程中可以使用Struts2 框架中继承的标签，在此过程中仍会再次涉及到ActionMapper； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6b0d18b6af3ab02c3d79b2a42105a8/" rel="bookmark">
			Java中Math.pow()的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java中Math.pow()的用法
1.问题描述
153是一个非常特殊的数，它等于它的每位数字的立方和，即153=1*1*1+5*5*5+3*3*3。编程求所有满足这种条件的三位十进制数。 输出格式 按从小到大的顺序输出满足条件的三位十进制数，每个数占一行。
public class Main { static int a ,b ,c; public static void function(){ for(int i =100;i&lt;1000;i++){ a=i/100; b=i%10; c=(i/10)%10; if(Math.pow(a,3) + (Math.pow(b,3)) + (Math.pow(c, 3))==(i)){ System.out.println(i); } /* if(a*a*a+b*b*b+c*c*c==i){ //System.out.println(abc); System.out.println(i); */} } public static void main(String [] args){ function(); } }（1）直接使用Math.pow(a,3)即可，即等于求a的3次方。Math方法直接是在Java.lang 包下的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa65139218aff72b05bdbc69e4e23248/" rel="bookmark">
			JSP里面的JS获取后台传来的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过request的getParameter的方法获取
1、通过request.getParameter("参数名")获取后台的值
2、通过&lt;%=变量%&gt;的方式赋给js变量
示例：
&lt;script&gt; &lt;% String s2 = (String)request.getParameter("参数名");//获取后台参数给s2变量，&lt;%%&gt;表示这范围内是服务器解析的语言 %&gt; var s = '&lt;%=s2%&gt;';//输出s2给js变量s &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2716f661db390910e5b1c78dfbbae66/" rel="bookmark">
			《Mimics软件临床应用：计算机辅助外科手术》目录摘要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文由Markdown语法编辑器编辑完成。
1. Mimics软件 在前面的博文中，已经有介绍Mimics和Amira这两款在医学影像处理中非常流行的软件。这篇文章主要介绍一本详细讲解Mimics软件在临床手术中的应用，书名为《Mimics软件临床应用：计算机辅助外科手术》，这本书的百度云分享地址如下： http://pan.baidu.com/s/1eSBdC3K。
书籍的封面为： 这本书的作者是在临床工作多年的大夫，这也是一本由医生撰写的关于软件操作的书籍，可见这本书蕴含着作者多大的心血。
作者苏秀云和刘蜀彬在熟练操作和临床应用开发的基础上，简要介绍了Mimics软件相关知识及具有强大的体数据浏览功能的基础模块，重点介绍了Mimics软件的图像分割、三维重建、MedCAD模块、Simulation模块、FEA模块、RPslice模块等临床应用开发和应用经验。
《Mimics软件临床应用：计算机辅助外科入门技术》既是一本研究型学术著作，也是一本Mimics软件操作指南，《Mimics软件临床应用：计算机辅助外科入门技术》可供各级临床医师，尤其是数字医学研究人员参考阅读。
2. 《Mimics软件临床应用：计算机辅助外科手术》目录摘要 第1章 计算机辅助外科之钥匙-Mimics软件 一、数字医学——信息技术与医学科学的融合
二、计算机辅助外科的灵魂——医学影像三维建模 （一）计算机辅助外科的发展 （二）计算机辅助外科的机遇与挑战
三、医学影像的梦工厂-Mimics软件 （一）常用软件及Mimics的特点 （二）Mimics软件在医学中应用简介 （三）Mimics软件设计流程或思路 （四）Mimics软件界面
第2章 认识Mimics基础模块——强大的体数据浏览功能 一、医学数字图像基础知识 （一）灰度图像、彩色图像及图形 （二）像素、分辨率与像素尺寸 （三）颜色深度 （四）图像格式 （五）数字医学图像传输与储存标准——DICOM
二、连续断层图像输入 （一）Mimics输入模块（importmodule） （二）Dicom输入程序（dicomimputapplication） （三）图像输入前的准备 （四）自动导入DICOM格式图像 （五）手动导入DICOM格式图像 （六）自动导入BMP或TIFF格式图像 （七）项目管理（保存、另存为、打开及关闭）
三、窗宽窗位及调整 （一）Hounsfield值 （二）调整窗宽窗位
四、图像增强 （一）伪彩（pseudocolor） （二）滤波（filter）
五、重组正交断层浏览 （一）不同的视口（the different views） （二）导航（navigation）
六、重组任意断层浏览 （一）在线重切片（online reslice） （二）重新切割项目（reslice project）
七、体渲染 （一）体渲染的参数 （二）Mimics软件的体渲染
八、断层图像测量及灰度值统计 （一）测量距离 （二）测量角度 （三）测量矩形区域像素灰度值 （四）测量椭圆区域像素灰度 （五）像素沿自定义线段灰度值曲线图 （六）体素灰度值直方图
第3章 医学三维重建之基石-Mimics图像分割 一、医学图像分割的特点 （一）医学图像分割困难的原因 （二）笔者的经验与建议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2716f661db390910e5b1c78dfbbae66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e248a8310e50fe8ecbe3df39e84757cd/" rel="bookmark">
			EasyUI ComboGrid（数据表格下拉框）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扩展自$.fn.combo.defaults和$.fn.datagrid.defaults。使用$.fn.combogrid.defaults重写默认值对象。
数据表格下拉框结合了可编辑文本框控件和下拉数据表格面板控件，该控件允许用户快速查找和选择，并且该控件提供了键盘导航支持，对行进行筛选。 http://blog.csdn.net/hsliwei/article/details/9134219
Properties 这些属性继承至 combo,下面是combobox的一些新增属性.
Name TypeDescriptionDefaultvalueFieldstring绑定到这个combobox的基础数据值名.valuetextFieldstring绑定到这个combobox的数据字段名.textmodestring当文本改变时定义如何加载显示列表数据.如果设置为'remote' combobox从远程服务器加载数据.当设置为'remote'模式时, 用户输入的信息将发送作为http请求参数,参数名为'q'到服务器检索新的数据.localurlstring一个从远程服务器加载列表数据的URL.nullmethodstring检索数据的http请求方法.postdataarray需要加载到列表的数据. 示例代码:
&lt;input class="easyui-combobox" data-options=" valueField: 'label', textField: 'value', data: [{ label: 'java', value: 'Java' },{ label: 'perl', value: 'Perl' },{ label: 'ruby', value: 'Ruby' }]" /&gt; nullfilterfunction定义如何过滤本地数据,当'mode'设置为'local'的时候. 这个函数提供两个参数:
q: 用户输入的文本.
row: 列表的行数据.
返回true 允许行显示 . 示例代码:
$('#cc').combobox({ filter: function(q, row){ var opts = $(this).combobox('options'); return row[opts.textField].indexOf(q) == 0; } }); formatterfunction定义如何呈现行. 这个函数提供一个参数 :row. 示例代码:
$('#cc').combobox({ formatter: function(row){ var opts = $(this).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e248a8310e50fe8ecbe3df39e84757cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252c196151c8ee852ea02c1ceb89a951/" rel="bookmark">
			PPTPD centos7 install problem fix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照网上的教程，在一台centos７上安装完ＰＰＴＰ　ＶＰＮ服务器之后，ＩＯＳ一直报错，连不上，查看ＶＡＲ　ＬＯＧ　ＭＥＳＳＡＧＥＳ发现报如下错误： Aug 4 16:05:04 oltsvr pptpd[15707]: CTRL: Client 112.17.247.42 control connection started Aug 4 16:05:04 oltsvr pptpd[15707]: CTRL: Starting call (launching pppd, opening GRE) Aug 4 16:05:05 oltsvr kernel: conntrack: generic helper won’t handle protocol 47. Please consider loading the specific helper module. Aug 4 16:05:05 oltsvr pppd[15708]: /usr/lib/pptpd/pptpd-logwtmp.so: wrong ELF class: ELFCLASS32 Aug 4 16:05:05 oltsvr pppd[15708]: Couldn’t load plugin /usr/lib/pptpd/pptpd-logwtmp.so Aug 4 16:05:05 oltsvr pptpd[15707]: GRE: read(fd=6,buffer=8059680,len=8196) from PTY failed: status = -1 error = Input/output error, usually caused by unexpected termination of pppd, check option syntax and pppd logs Aug 4 16:05:05 oltsvr pptpd[15707]: CTRL: PTY read or GRE write failed (pty,gre)=(6,7) Aug 4 16:05:05 oltsvr pptpd[15707]: CTRL: Client 112.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/252c196151c8ee852ea02c1ceb89a951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275a3f7627e26d7f834fa2ae31cd14ae/" rel="bookmark">
			ftp  ssh  http  telnet  https服务及端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FTP服务器，则是在互联网上提供存储空间的计算机，它们依照FTP协议提供服务。 FTP就是专门用来传输文件的协议。简单地说，支持FTP协议的服务器就是FTP服务器。
SSH 为 Secure Shell 的缩写，SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。S S H客户端适用于多种平台。几乎所有U N I X平台—包括H P - U X、L i n u x、A I X、S o l a r i s、Digital UNIX、I r i x，以及其他平台—都可运行S S H。
HTTP超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。
Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。
HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。
常用默认端口号 网络层---数据包的包格式里面有个很重要的字段叫做协议号。
比如在传输层如果是TCP连接，那么在网络层IP包里面的协议号就将会有个值是6，
如果是UDP的话那个值就是17---传输层。 传输层---通过接口关联(端口的字段叫做端口)---应用层。 用netstat –an 可以查看本机开放的端口号。 代理服务器常用以下端口： （1）. HTTP协议代理服务器常用端口号：80/8080/3128/8081/9080 （2）. SOCKS代理协议服务器常用端口号：1080 （3）. FTP（文件传输）协议代理服务器常用端口号：21 （4）. Telnet（远程登录）协议代理服务器常用端口：23 HTTP服务器，默认的端口号为80/tcp（木马Executor开放此端口）； HTTPS（securely transferring web pages）服务器，默认的端口号为443/tcp 443/udp； Telnet（不安全的文本传送），默认端口号为23/tcp（木马Tiny Telnet Server所开放的端口）； FTP，默认的端口号为21/tcp（木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口）； TFTP（Trivial File Transfer Protocol ），默认的端口号为69/udp； SSH（安全登录）、SCP（文件传输）、端口重定向，默认的端口号为22/tcp； SMTP Simple Mail Transfer Protocol (E-mail)，默认的端口号为25/tcp（木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口）； POP3 Post Office Protocol (E-mail) ，默认的端口号为110/tcp； WebLogic，默认的端口号为7001； Webshpere应用程序，默认的端口号为9080； webshpere管理工具，默认的端口号为9090； JBOSS，默认的端口号为8080； TOMCAT，默认的端口号为8080； WIN2003远程登陆，默认的端口号为3389； Symantec AV/Filter for MSE ,默认端口号为 8081；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/275a3f7627e26d7f834fa2ae31cd14ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b351848b2b1a346ba68d65525caefacf/" rel="bookmark">
			maven编译时报错：致命错误: 在类路径或引导类路径中找不到程序包 java.lang
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven编译时报错：致命错误: 在类路径或引导类路径中找不到程序包 java.lang：
[INFO] Scanning for projects...
[INFO] [INFO] ------------------------------------------------------------------------
[INFO] Building weixin_project Maven Webapp 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ weixin_project ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 2 resources
[INFO] [INFO] --- maven-compiler-plugin:3.0:compile (default-compile) @ weixin_project ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 2 source files to E:\Spring-tool-suit\weixin_project\target\classes
[语法分析开始时间 RegularFileObject[E:\Spring-tool-suit\weixin_project\src\main\java\org\seele\weixin\servlet\CoreServlet.java]]
[语法分析已完成, 用时 12 毫秒]
[语法分析开始时间 RegularFileObject[E:\Spring-tool-suit\weixin_project\src\main\java\org\seele\weixin\servlet\SignUtil.java]]
[语法分析已完成, 用时 3 毫秒]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b351848b2b1a346ba68d65525caefacf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2308158dc16cd653db3a1e8504f31fcb/" rel="bookmark">
			【玩转数据系列五】农业贷款发放预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（本文数据为虚构，仅供实验）
产品地址：https://data.aliyun.com/product/learn?spm=a21gt.99266.416540.102.OwEfx2 一、背景 很多农民因为缺乏资金，在每年耕种前会向相关机构申请贷款来购买种地需要的物资，等丰收之后偿还。农业贷款发放问题是一个典型的数据挖掘问题。贷款发放人通过往年的数据，包括贷款人的年收入、种植的作物种类、历史借贷信息等特征来构建经验模型，通过这个模型来预测受贷人的还款能力。 本文借助真实的农业贷款业务场景，利用回归算法解决贷款发放业务。 线性回归，是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。本文通过农业贷款的历史发放情况，预测是否给预测集的用户发放他们需要的金额的贷款。
二、数据集介绍 具体字段如下：
字段名含义类型描述id数据唯一标识符string人name用户名string人region用户所属地区string从北到南排列farmsize拥有土地大小double土地面积rainfall降雨量double降雨量landquality土地质量double土地质量数值越大越好farmincome收入double年收入maincrop种植作物string种植作物的种类claimtype贷款类型string两种claimvalue贷款金额double贷款金额 数据截图： 三、数据探索流程 首先，实验流程图： 1.数据源 数据的输入有两部分，贷款训练集用来进行回归模型的训练，共二百条数据，是历史贷款数据，包括一些farmsize、rainfall等特征，claimvalue是贷款收回的金额。贷款预测集是今年申请贷款者，claimvalue是农民申请的贷款金额，共71人。我们通过已有的二百多条历史数据，预测给七十一人中的哪些申请贷款人发放贷款。
2.特征工程 将一些字符串类型的数据，根据他们的含义映射成数字。比如说region字段，我们将其中的north、middle、south按照从北到南的顺序分别映射成0、1、2。然后通过类型转换将字段转换成double类型，这样就可以进行下面的回归计算了。 如下图： 3.回归及预测 线性回归组件对于历史数据训练并生成回归模型，在预测组件中利用回归模型对于预测集数据进行了预测。通过合并列组件将用户ID、预测值、申请的贷款值合并。预测值表示的是用户的还贷能力（预期可以归还的金额）。 4.回归模型评估 通过回归模型评估组件对于回归模型进行评估。 5.发放贷款人 通过过滤与映射组件筛选出可以获得贷款的人，这里的业务逻辑是针对每个客户，如果他被预测得到的还款能力大于他申请贷款的金额，就对他发放贷款。
四、其它 作者微信公众号(与作者讨论)： 参与讨论：云栖社区公众号 免费体验：阿里云数加机器学习平台 往期文章： 【玩转数据系列一】人口普查统计案例 【玩转数据系列二】机器学习应用没那么难，这次教你玩心脏病预测 【玩转数据系列三】利用图算法实现金融行业风控 【玩转数据系列四】听说啤酒和尿布很配？本期教你用协同过滤做推荐
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70892fe28f141df657b91d3c2ccf6e04/" rel="bookmark">
			状态压缩(棋盘问题&#43;hdu3254&#43;poj1185&#43;hud2553)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1： 在n*n(n≤20)的方格棋盘上放置 n 个车(可以攻击所在行、列)，求使它们不能互相攻击的方案总数。 分析： 利用组合数学：答案为n！ 状态压缩递推： 首先，每一行只能有一个车，只要一行行地放，每行只放一个，保证同一行之间不会有攻击。其次，每一列只能放一个车，只要能记录下哪一列有车，下次不再考虑这一列就可以了。用一个二进制数S来表示某一列是否已经放置了车。例如n=5，S=01101，就表示第一、三、四列（从低位开始）已经放置了车。f[S]表示在状态S下的方案数。 那么状态S是怎么来的呢？ 因为是一行行放置的，所以到状态S的时候已经放置到了第三行。 三种情况： ①前两行在第3、 4 列放置了棋子(不考虑顺序，下同)，第三行在第 1 列放置； ②前两行在第1、 4 列放置了棋子，第三行在第 3 列放置； ③前两行在第1、 3 列放置了棋子，第三行在第 4 列放置。 如下图所示，依次 为以上三种情况，(红,蓝)，(红,绿)分别代表两种顺序。 这三种情况互不相交，且只可能有这三种情况，根据加法原理，应该等于这三种情况的和，写成递推式就是f[01101]= f[01100]+f[01001]+f[00101]，这个式子相当于01101分别从右到左把有1的位置变为零，然后相加。 推广状态S，那么f[S] =Σf[S^(1&lt;&lt;(i-1))]，其中i是枚举的状态S中每一个1的位置（从低位到高位）。然后依次去掉一个1。 边界条件：f[0] = 1。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int INF=(1&lt;&lt;20)-1; int f[INF]; int main() { int n; scanf("%d",&amp;n); int i,S,j; f[0]=1; for(S=1;S&lt;=(1&lt;&lt;n)-1;++S) { for(i=1;i&lt;=n;++i) { if(( S &amp; 1&lt;&lt;(i-1))&gt;0)//状态S的第i列有棋子, { int s=S^1&lt;&lt;(i-1);//去掉第i列的1 f[S]+=f[s]; } } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70892fe28f141df657b91d3c2ccf6e04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dafd25e51bcd0baa77e2e28063db139b/" rel="bookmark">
			java.lang.IllegalStateException:   Make sure the Cursor is initialized correctly before accessing...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.lang.IllegalStateException: Couldn't read row 0, col 2 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it.
这个错误是使用Dao获取数据库数据时，有的字段是无效的，重新检查下sql的字段名，和对应的表字段名是否一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65fac1ea918aa8362a82d76c2a07e81/" rel="bookmark">
			Educational Codeforces Round 15（简单题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. Maximum Increase 题意： 给出一个数列（n&lt;100000），问最长连续上升子序列？
#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N=1e5+9; int a[N]; int main() { int n;scanf("%d",&amp;n); int maxn=1; for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); a[0]=0; int t=0; for(int i=1;i&lt;=n;i++){ if(a[i]&gt;a[i-1])t++; else maxn=max(maxn,t),t=1; } maxn=max(maxn,t); printf("%d\n",maxn); return 0; } B. Powers of Two 题目： 给一个数列(n&lt;100000)，问符合ai+aj是2的幂次（i&lt; j）的有几对？
#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N=1e5+9; int a[N]; int main() { int n;scanf("%d",&amp;n); map&lt;int,int&gt;mp; for(int i=0;i&lt;n;i++){ scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f65fac1ea918aa8362a82d76c2a07e81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0c9d034fabc2d00d084ea71aec9432/" rel="bookmark">
			SSD固态硬盘才装上确找不到盘怎么办-原来要初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址::http://www.upantool.com/jiaocheng/ssd/2014/6263.html
相关文章
1\固态硬盘如何安装----http://jingyan.baidu.com/article/c843ea0b76557877931e4aba.html
最扫兴的事情，莫过于等快递等到脖子都长了到手马上装上SSD（即固态硬盘）却找不到盘。 找不到盘啊！游戏安装包已经下好了，炸鸡啤酒已经恭候大驾了，装机过程也已经拍好发朋友圈了，万事俱备只欠东风。东风啊东风，你怎么那么坑！ 找不到盘，其实是因为用户没有对SSD进行初始化。如何初始化？金泰克工程师为您带来专业、详细的讲解。
一般SSD在初次使用的时候，都需要经过一个“初始化”过程。由于SSD与机械硬盘在存储方式上有本质区别，在生产过程中，需要在SSD主控中写入程序，即所谓固件。SSD在生产完毕时，主控内还没有SSD的分区信息，所以需要对SSD进行初始化来确定分区信息。 那么怎么对SSD进行初始化呢？如果是把SSD当作数据盘使用，请参考以下步骤进行（下面的教程是建立在之前有一个普通硬盘（有系统）的基础上再加一个ssd为例子）： 1、把新购买的SSD接到电脑上，开机。一般初次连接到某台电脑上时，系统会自动安装驱动。当驱动安装完成后，会如下图提示：
点开此条信息即可查看SSD的安装信息，如下图：
中红框内“tigo SSD 120G”即为金泰克SSD的基本信息形式，各容量略有差别。“USB Device”是因为笔者是用USB转SATA工具连接到电脑上的，如果是直接连接到SATA线上，则会显示“ATA Device”。
2、安装完成后，可以在“设备管理器”中查看该SSD信息。右击“我的电脑”，选择“管理”，再选择“设备管理器”，在“磁盘驱动器”可以查看到磁盘信息，如下图：
自此代表SSD已经正确安装驱动。但是此时在我的电脑中并不会找到新的磁盘。因为接下来的步骤才是“初始化”的重点。
3、右击“我的电脑”，选择“管理”，再选择“设备管理器”，此时会弹出“初始化磁盘”对话框，如图：
这 就是“初始化”SSD的主要操作了。图中我们需要选择SSD的磁盘分区形式。对于一般用户来说，选择“MBR（主启动记录）”，点击“确认”就完成初始化 SSD操作了。 “MBR”是即主引导记录，是对IBM兼容机的硬盘或者可移动磁盘分区时，在驱动器最前端的一段引导扇区。只有创建了主引导记录才可以进 行常说的分区操作。 “GPT”主要是一些追求极限性能的玩家来使用“高大上”的复杂方法来使用的。这里不再多述，避免造成干扰。
4、此时，SSD的初始化工作就算完成了。我们可以用过查看磁盘信息看到此时磁盘是在“联机”状态，如图：
如果在“初始化磁盘”对话框点击了取消，或者是在初次联机时没有初始化，这时，系统会认为磁盘处于“脱机”状态，如图：
此时，只要右击上图红框处，手动选择“初始化磁盘”，即可再次弹出“初始化磁盘”对话框。
再按步骤3完成初始化SSD操作即可。
5、SSD已经创建主引导记录，初始化完成后，我们看到容量部分是“未分配”的。这是指还没有对SSD进行分区操作。只有进行分区操作才能读写数据，这里一并分享。 5.1首先右击磁盘未分配部分，选择“新建简单卷”，如下图：
5.2此时会弹出“新建简单卷向导”对话框，选择“下一步”即可：
5.3指定卷大小，即分区大小。系统默认的大小是整盘大小，用户可以根据自己的需要选择。设置大小时，系统单位是MB，1024MB=1GB，强迫症患者可以自己换算。
5.4 “格式化分区”设置。这个操作与前面教程中“4K对齐”息息相关。格式化设置时，文件系统选择默认的“NTFS”分区格式，分配单元大小选择默认的“默认值”，再执行“下一步”即可保证分区后的SSD是“4K对齐”的。
也就是说，格式化操作时，只要直接默认“下一步”，SSD分区就是“4K对齐”的。Windows 7和以上系统均可以根据默认操作执行。
5.5分配驱动器号和路径。这个即为SSD分区分配盘符，只有分配盘符 ，才能在“我的电脑”中找到该分区。一般默认会分配到最后一个盘符，直接“下一步”即可。
5.6分区信息核对。此时对话框中会创建分区操作的所有参数，供用户确认。确认无误后，点击“完成”，系统就会对SSD进行格式化操作，创建分区。
5.7等待分区完成后，新分区的盘就能在“我的电脑”中看到了。如图，创建的分区大小为29.5GB，分配的盘符为F盘，分区格式为NTFS格式。
此时，SSD初始化分区操作就完成了。系统会提示找到新的磁盘，我们就可以在SSD中存放自己的数据了。若需要多个分区，只需要重复以上操作即可。 5.8通过“AS SSD Benchmark”工具查看刚创建的分区，如图：
我们可以看到图中第二行绿字显示“1024-OK”，即代表已经“4K对齐”。第一个OK代表已经开启“AHCI”，由于笔者是用USB转SATA工具连接到电脑上的，第一行绿字前面就没有如“iaStorA”、“msahci”等AHCI驱动名称的字样。
以 上主要针对把SSD作为数据盘使用而遇到“找不到盘”的情况。如果是直接拿SSD装系统使用，就不用如此麻烦了。使用WIN7、WIN8系统安装盘启动， 在安装系统过程中选择驱动器高级选项，就可以对未分区磁盘进行分区与格式化。此时的分区也是自动“4K对齐”的，没有后顾之忧。 开启AHCI、“4K对齐”、SSD初始化，这是使用SSD的基本要求。只要用户在使用SSD时能满足这三个基本点，就能体验电脑飞一般的感觉了！入手SSD，切记要检查是否满足这三个基本点哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25eead1909f1c3e6d435f89a2b39806a/" rel="bookmark">
			(可再看)基于深度学习的目标检测研究进展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 开始本文内容之前，我们先来看一下上边左侧的这张图，从图中你看到了什么物体？他们在什么位置？这还不简单，图中有一个猫和一个人，具体的位置就是上图右侧图像两个边框(bounding-box)所在的位置。其实刚刚的这个过程就是目标检测，目标检测就是“给定一张图像或者视频帧，找出其中所有目标的位置，并给出每个目标的具体类别”。 目标检测对于人来说是再简单不过的任务，但是对于计算机来说，它看到的是一些值为0~255的数组，因而很难直接得到图像中有人或者猫这种高层语义概念，也不清楚目标出现在图像中哪个区域。图像中的目标可能出现在任何位置，目标的形态可能存在各种各样的变化，图像的背景千差万别……，这些因素导致目标检测并不是一个容易解决的任务。 得益于深度学习——主要是卷积神经网络(convolution neural network: CNN)和候选区域(region proposal)算法，从2014年开始，目标检测取得了巨大的突破。本文主要对基于深度学习的目标检测算法进行剖析和总结，文章分为四个部分：第一部分大体介绍下传统目标检测的流程，第二部分介绍以R-CNN为代表的结合region proposal和CNN分类的目标检测框架(R-CNN, SPP-NET, Fast R-CNN, Faster R-CNN); 第三部分介绍以YOLO为代表的将目标检测转换为回归问题的目标检测框架(YOLO, SSD); 第四部分介绍一些可以提高目标检测性能的技巧和方法。
一. 传统目标检测方法 如上图所示，传统目标检测的方法一般分为三个阶段：首先在给定的图像上选择一些候选的区域，然后对这些区域提取特征，最后使用训练的分类器进行分类。下面我们对这三个阶段分别进行介绍。 (1) 区域选择 这一步是为了对目标的位置进行定位。由于目标可能出现在图像的任何位置，而且目标的大小、长宽比例也不确定，所以最初采用滑动窗口的策略对整幅图像进行遍历，而且需要设置不同的尺度，不同的长宽比。这种穷举的策略虽然包含了目标所有可能出现的位置，但是缺点也是显而易见的：时间复杂度太高，产生冗余窗口太多，这也严重影响后续特征提取和分类的速度和性能。（实际上由于受到时间复杂度的问题，滑动窗口的长宽比一般都是固定的设置几个，所以对于长宽比浮动较大的多类别目标检测，即便是滑动窗口遍历也不能得到很好的区域） (2) 特征提取 由于目标的形态多样性，光照变化多样性，背景多样性等因素使得设计一个鲁棒的特征并不是那么容易。然而提取特征的好坏直接影响到分类的准确性。（这个阶段常用的特征有SIFT、HOG等） (3) 分类器 主要有SVM, Adaboost等。 总结：传统目标检测存在的两个主要问题：一个是基于滑动窗口的区域选择策略没有针对性，时间复杂度高，窗口冗余；二是手工设计的特征对于多样性的变化并没有很好的鲁棒性。
二. 基于Region Proposal的深度学习目标检测算法 对于传统目标检测任务存在的两个主要问题，我们该如何解决呢？ 对于滑动窗口存在的问题，region proposal提供了很好的解决方案。region proposal（候选区域）是预先找出图中目标可能出现的位置。但由于region proposal利用了图像中的纹理、边缘、颜色等信息，可以保证在选取较少窗口（几千个甚至几百个）的情况下保持较高的召回率。这大大降低了后续操作的时间复杂度，并且获取的候选窗口要比滑动窗口的质量更高（滑动窗口固定长宽比）。比较常用的region proposal算法有selective Search和edge Boxes，如果想具体了解region proposal可以看一下PAMI2015的“What makes for effective detection proposals？” 有了候选区域，剩下的工作实际就是对候选区域进行图像分类的工作（特征提取+分类）。对于图像分类，不得不提的是2012年ImageNet大规模视觉识别挑战赛（ILSVRC）上，机器学习泰斗Geoffrey Hinton教授带领学生Krizhevsky使用卷积神经网络将ILSVRC分类任务的Top-5 error降低到了15.3%，而使用传统方法的第二名top-5 error高达 26.2%。此后，卷积神经网络占据了图像分类任务的绝对统治地位，微软最新的ResNet和谷歌的Inception V4模型的top-5 error降到了4%以内多，这已经超越人在这个特定任务上的能力。所以目标检测得到候选区域后使用CNN对其进行图像分类是一个不错的选择。 2014年，RBG（Ross B. Girshick）大神使用region proposal+CNN代替传统目标检测使用的滑动窗口+手工设计特征，设计了R-CNN框架，使得目标检测取得巨大突破，并开启了基于深度学习目标检测的热潮。21. R-CNN (CVPR2014, TPAMI2015) (Region-based Convolution Networks for Accurate Object detection and Segmentation) 上面的框架图清晰的给出了R-CNN的目标检测流程： (1) 输入测试图像 (2) 利用selective search算法在图像中提取2000个左右的region proposal。 (3) 将每个region proposal缩放（warp）成227x227的大小并输入到CNN，将CNN的fc7层的输出作为特征。 (4) 将每个region proposal提取到的CNN特征输入到SVM进行分类。 针对上面的框架给出几点解释： * 上面的框架图是测试的流程图，要进行测试我们首先要训练好提取特征的CNN模型，以及用于分类的SVM：使用在ImageNet上预训练的模型（AlexNet/VGG16）进行微调得到用于特征提取的CNN模型，然后利用CNN模型对训练集提特征训练SVM。 * 对每个region proposal缩放到同一尺度是因为CNN全连接层输入需要保证维度固定。 * 上图少画了一个过程——对于SVM分好类的region proposal做边框回归（bounding-box regression)，边框回归是对region proposal进行纠正的线性回归算法，为了让region proposal提取到的窗口跟目标真实窗口更吻合。因为region proposal提取到的窗口不可能跟人手工标记那么准，如果region proposal跟目标位置偏移较大，即便是分类正确了，但是由于IoU(region proposal与Ground Truth的窗口的交集比并集的比值)低于0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25eead1909f1c3e6d435f89a2b39806a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f94e2dc42f6673b3792ab73d806ef1/" rel="bookmark">
			Application.persistentDataPath
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天研究一下Application.persistentDataPath，做个案例，如下,使用persistentDataPath可以在真实手机上临时保存一些数据，经过测试在真实手机上是不能够使用Application.streamingAssetsPath和Application.dataPath的，如果想临时保存一些数据，只能够用Application.persistentDataPath
上面实现的功能是： 在输入框内输入内容 点击保存按钮后，将输入框内容保存在Application.persistentDataPath路径下的文件 然后再点击显示，将输入框保存的内容再显示出来
实现代码如下：
发布到手机上截图如下：
以下是手机截图：
FR:徐海涛（Hunk Xu)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/223f3bd9278b2f248ef74f07fa73419b/" rel="bookmark">
			Gson高级用法---&gt;对json字符串进行过滤和检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：https://futurestud.io/blog/gson-builder-exclusion-strategies
相信你们基本都会使用Gson，所以就不介绍Gson如何使用了，直接介绍一些Gson高级的用法。
Gson完美依赖java8，如果Gson解析有啥问题的话，建议更新jdk到8.0再试一下。
上面是自己的一些经验，下面是对https://futurestud.io/blog/gson-builder-exclusion-strategies的总结和翻译。
这里讲下 Gson 的 ExclusionStrategy类的用法。
先看代码吧：
Gson实体类
public class UserDate { private String _name; private String email; private boolean isDeveloper; private int age; private Date registerDate = new Date(); } gson操作
GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setExclusionStrategies(new ExclusionStrategy() { @Override public boolean shouldSkipField(FieldAttributes f) { return f.getName().contains("_");; } @Override public boolean shouldSkipClass(Class&lt;?&gt; incomingClass) { return incomingClass == Date.class || incomingClass == boolean.class; } }); Gson gson = gsonBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/223f3bd9278b2f248ef74f07fa73419b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3272ca372693841baeaa6d90c66ccfe/" rel="bookmark">
			RSA算法的简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原理 (a): 我们取2个很大的质数 p,q,记n=pq,w=(p−1)(q−1) . (b): 取e&lt;p,q,若de=N∗(p−1)∗(q−1)+1,则我们可以进行如下操作 (c): 对数C加密,x=Cemodn,则xdmodn=cdemodn (d): 根据费马小定理,cp−1modp=1,cq−1modq=1,cwmodn=1=⟩cde−1modn=1 (e):所以cdemodn=c，因此只需要(n,e),(n,d)两组信息就可以对数据加密和解密,而且由于传递信息只要其中一个,所以不担心解密办法会被破译。 (f) :回到(b),我们怎么求出来d?这里需要用到辗转相除法的变形来计算逆元,具体算法请查阅资料。 算法的简单实现:里面主要有一个辗转相除法的变形和快速求余的算法。 def rev_gcd(a,b):#计算逆元 an,N = [],a while 1: divisior = a//b a,b = b,a%b if b==0:break an.append(divisior) b1,b2 = 1,0 for ai in an[::-1]:b1,b2 = b1*ai+b2,b1 if len(an)%2 ==0:return b1 else:return N-b1 def create(p,q): n = p*q e = (p&gt;&gt;1)+(q&gt;&gt;1) x = (p-1)*(q-1) d = rev_gcd(x,e) return n,d,e def rsa_endecode(c,e,n):#快速求余算法 u = 1; while e: if e&amp;1:u = (u*c)%n c = (c**2)%n e &gt;&gt;=1 return u n,d,e = create(104729,15485863) c = rsa_endecode(310,e,n) print(c,rsa_endecode(c,d,n)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21eb78a1222dfef8f4b5559a08906749/" rel="bookmark">
			关于对cpu的理解和kvm虚拟机到物理cpu的绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间一直在想，云计算除了虚拟化之外，还应该有其它的东西，那就是优化。因为我们虚拟出来资源之后怎么用，怎么划分，是并行也好，是租给用户使用也好，都要实现资源调度和使用的最优化。嗯，这是这段时间关于云计算的想法。 下面分享一下最近两天做的一些事。
首先是对cpu的理解，这个大家应该都清楚，我这里只是进行记录，方便后面查询。
在linux下的/proc/cpuinfo文件里，保存了cpu的详细的信息，有兴趣的可以打开看看，有一个误区就是大家看到有两个或四个cpu其实只是一个物理cpu，那四个只是逻辑的，也就是说我们一般的pc只有一个插槽（socket），这个可以看你的physical id来确定，如果只有一个cpu的话，这几个逻辑cpu的physicalid应该都是一样的。那么我们平时所说的几核几核怎么看呢？对，你应该看你的core id，我现在用的机器就有两个coreid，一个0，一个1，也就是说是两核的。那么你可能会问，逻辑cpu和核是什么关系呢？应该是这样的，你注意看你的 /proc/cpuinfo文件会发现，有两个或多个逻辑cpu的coreid相同，是的，也就是说，两个或多个逻辑cpu运行在一个核上。
如果还不够理解，那么看下面的例子：
从表中可以看到有两个物理cpu，八个逻辑cpu。
此例说明有逻辑处理器0 和 4 驻留在物理封装 0 的内核 0 上。这就表示逻辑处理器 0 和 4 支持超线程（HT）技术。相同的工作可用于封装 0 内核1 上的逻辑处理器 2 和 6，封装 1 内核 2 上的逻辑处理器 1 和 5，以及封装 1 内核 3 上的逻辑处理器 3 和7。此系统支持超线程（HT）技术，因为两个逻辑处理器共享同一个内核。有两种方式可以确定是否支持多内核。由于内核 0 和 1 存在于封装0 上，而内核 2 和 3 存在于封装 1 上，所以这是一个多内核系统。此外，cpu cores 条目为2，也说明有两个内核驻留在物理封装中。这是一个多路系统，因为有两个封装。
下面我们考虑，kvm虚拟出来的虚拟机（vm）是运行在单独的一个逻辑cpu还是可以分别在各个cpu之间运行？虚拟机cpu（vcpu）是什么概念？物理机（host）怎么看待kvm和vcpu?为了搞懂这个概念我们还是要回到命令行中看。举例说明：
我这里有一个虚拟机叫core8，它含有8个虚拟cpu它的进程编号是20736.不知道怎么看虚拟机的进程编号？在host里使用top命令，嗯，这时你会发现所有的运行在host上面的进程及其使用cpu情况，那么找到这个core8虚拟机的进程编号呢？我们在core8上面执行任意一个死循环操作，这时你再看host上的top就会发现，基本上第一个进程就是这core8了，因为它占得cpu最多，我这里是20736。就是说core8在host看来就是一个进程而已，这个集成的编号是20736.那么现在提出一个问题，这个core8的8个vcpu是怎么个情况呢？在哪里运行呢？这时还是得借助命令行。我们在host里使用ps指令，但是不能单纯了用ps，还要借助于参数：ps -eL//e的意思是打印所有进程，L的意思是连县城也不放过。我这里只显示一下和我们的20736进程相关的信息：
你会看到和20736相关的有九行，那么这九行是什么呢？
首先第一列都是20736，第二列里只有第一行是20736，后面的都不是。那么我们这时就应该明白了，对于host来说，kvm虚拟机是一个进程（20736），虚拟机的vcpu都是这个进程衍生出来的线程。这就是为什么除了20736还有另外八行的原因。
那么我们接着询问，这八个线程是跑在同一个逻辑cpu里吗？为了回答这个问题，我们接着做实验：
还是借助于ps指令 ：ps -eLo ruser,pid,ppid,lwp,psr| awk ‘{if($5==1) print$0}’
解释为：ps命令显示当前系统的进程信息的状态，它的“-e”参数用于显示所有的进程，“-L”参数用于将线程（LWP，light-weightprocess）也显示出来，“-o”参数表示以用户自定义的格式输出（其中“psr”这列表示当前分配给进程运行的处理器编号，“lwp”列表示线程的ID，“ruser”表示运行进程的用户，“pid”表示进程的ID，“ppid”表示父进程的ID，）。结合ps和awk工具的使用，是为了分别打印出来运行在不同的逻辑cpu上的进程线程情况。上面的指令就是打印出1号（从0开始编号）cpu的进行线程情况，我们这里只列出和我们相关的：
这时你会看到，哦，20736号进程衍生出来的线程只有一部分运行在逻辑cpu1上，其它的线程在其它的cpu上了。
这时就大概明白了，不同的vcpu只是不同的线程，而不同的线程是跑在不同的cpu上的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21eb78a1222dfef8f4b5559a08906749/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ceb9bd5d93ce014774a0b0a70dc194/" rel="bookmark">
			curl上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在写上传文件的后台接口时，本来是想用postman测试的，不知道为什么，测试一直失败，上传的数据格式老是不对。后来想到，用curl来试试，好像还真成。
curl -F "key=value" -F "filename=@file.tar.gz" http://localhost/upload 如果使用了-F参数，curl会以multipart/form-data的方式发送POST请求。-F以key=value的形式指定要上传的参数，如果是文件，则需要使用key=@file的形式。
如果使用-d命令，curl会以application/x-www-url-encoded格式上传参数。
curl -d "action=del" -d "id=12" http://localhost/test 如果要以json格式上传参数，需要使用-H在命令中指定。
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' http://localhost/api/login 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7de428e839e6a791885bc8fea8fac75/" rel="bookmark">
			通过netty实现服务端与客户端的长连接通讯，及心跳检测。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过netty实现服务端与客户端的长连接通讯，及心跳检测。
from:http://my.oschina.net/robinyao/blog/399060
基本思路：netty服务端通过一个Map保存所有连接上来的客户端SocketChannel,客户端的Id作为Map的key。每次服务器端如果要向某个客户端发送消息，只需根据ClientId取出对应的SocketChannel,往里面写入message即可。心跳检测通过IdleEvent事件，定时向服务端放送Ping消息，检测SocketChannel是否终断。
环境JDK1.8 和netty5
以下是具体的代码实现和介绍：
1公共的Share部分(主要包含消息协议类型的定义)
设计消息类型：
public enum MsgType { PING,ASK,REPLY,LOGIN } Message基类：
//必须实现序列,serialVersionUID 一定要有,否者在netty消息序列化反序列化会有问题，接收不到消息！！！ public abstract class BaseMsg implements Serializable { private static final long serialVersionUID = 1L; private MsgType type; //必须唯一，否者会出现channel调用混乱 private String clientId; //初始化客户端id public BaseMsg() { this.clientId = Constants.getClientId(); } public String getClientId() { return clientId; } public void setClientId(String clientId) { this.clientId = clientId; } public MsgType getType() { return type; } public void setType(MsgType type) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7de428e839e6a791885bc8fea8fac75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ffe6f3e474d7da7f3d6382c8318b6fa/" rel="bookmark">
			Android设置ViewPager不能左右滑动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在viewpager对象绑定适配器之前，设置如下方法
viewpager .setOnTouchListener( new OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { return true; //修改为true } }); 上面的方法虽然简单，但确实可能出现可以慢慢滑动的情况，以下是更新，重写一个ViewPager，使用重写的ViewPager就没有问题了
/** * Created by Suzi on 2016/11/14. * 自定义ViewPage，可以设置ViewPager页面之间不能滑动 */ public class MyViewPager extends ViewPager { /* 更改scrollble的值可设置是否可滑动，默认true为可滑动 */ private boolean scrollble = true; private int startX; private int startY; public MyViewPager(Context context) { super(context); } public MyViewPager(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean onTouchEvent(MotionEvent ev) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ffe6f3e474d7da7f3d6382c8318b6fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e4b3a3b827ebc6bc99e4ab1217f153/" rel="bookmark">
			【c&#43;&#43;】STL里的priority_queue用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、头文件
#include&lt;queue&gt;
2、定义
priority_queue&lt;int&gt; p; 3、优先输出大数据
priority_queue&lt;Type, Container, Functional&gt;
Type为数据类型， Container为保存数据的容器，Functional为元素比较方式。
如果不写后两个参数，那么容器默认用的是vector，比较方式默认用operator&lt;，也就是优先队列是大顶堆，队头元素最大。
例如：
#include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main(){ priority_queue&lt;int&gt; p; p.push(1); p.push(2); p.push(8); p.push(5); p.push(43); for(int i=0;i&lt;5;i++){ cout&lt;&lt;p.top()&lt;&lt;endl; p.pop(); } return 0; } 输出：
4、优先输出小数据
方法一：
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; p; 例如：
#include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main(){ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;p; p.push(1); p.push(2); p.push(8); p.push(5); p.push(43); for(int i=0;i&lt;5;i++){ cout&lt;&lt;p.top()&lt;&lt;endl; p.pop(); } return 0; } 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24e4b3a3b827ebc6bc99e4ab1217f153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa89e7b2dbcb13682aa8acc26f53daf0/" rel="bookmark">
			QT操作Word，插入表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做QT导出word报表，发现网上的资源不是很多，也浪费了很多时间，我自己做了一份demo,将会详细讲述如何做出需要样式的报表。在网上很容易查到java或者其他语言操作word的接口函数，但是QT能操作word的，不是很多，而且还不太好用。我把自己已经调试出来的代码，贡献出来，免得以后浪费时间。
写了一部分接口函数，可以满足大部分的word报表。在QT工程中，QWorddemo.pro中，需要加入如下：
QT默认安装在C盘中。
下载地址：http://download.csdn.net/download/blackbattery/10001438
分数有点高了，分享一个百度云盘网址：链接: https://pan.baidu.com/s/1qWv4tTY-VGPNONJUvyhLlw 提取码: esqk
链接：https://share.weiyun.com/59gwQjX 密码：v74rng
LIBS +=C:\Qt\Qt5.5.1\5.5\msvc2010\lib\qtmaind.lib LIBS +=C:\Qt\Qt5.5.1\5.5\msvc2010\lib\Qt5Cored.lib LIBS +=C:\Qt\Qt5.5.1\5.5\msvc2010\lib\Qt5Guid.lib LIBS +=C:\Qt\Qt5.5.1\5.5\msvc2010\lib\Qt5Widgetsd.lib LIBS +=C:\Qt\Qt5.5.1\5.5\msvc2010\lib\Qt5AxContainerd.lib LIBS +=C:\Qt\Qt5.5.1\5.5\msvc2010\lib\Qt5AxBased.lib 在word中插入表格：
void QWord::intsertTable(int row,int column) {	QAxObject* tables = m_document-&gt;querySubObject("Tables");	QAxObject* selection = m_word-&gt;querySubObject("Selection");	QAxObject* range = selection-&gt;querySubObject("Range"); QVariantList params; params.append(range-&gt;asVariant());	params.append(row); params.append(column);	tables-&gt;querySubObject("Add(QAxObject*, int, int, QVariant&amp;, QVariant&amp;)", params); QAxObject* table = selection-&gt;querySubObject("Tables(int)",1); table-&gt;setProperty("Style","网格型"); QAxObject* Borders = table-&gt;querySubObject("Borders"); Borders-&gt;setProperty("InsideLineStyle",1); Borders-&gt;setProperty("OutsideLineStyle",1); QString doc = Borders-&gt;generateDocumentation(); QFile outFile("D:\\360Downloads\\Picutres\\Borders.html"); outFile.open(QIODevice::WriteOnly|QIODevice::Append); QTextStream ts(&amp;outFile); ts&lt;&lt;doc&lt;&lt;endl; /*QString doc = tables-&gt;generateDocumentation(); QFile outFile("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa89e7b2dbcb13682aa8acc26f53daf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49dbb40781dd4ad6a66fdf9070093d1b/" rel="bookmark">
			POJ 1321 棋盘问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目重现 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。
输入描述 输入含有多组测试数据。 每组数据的第一行是两个正整数： n,k(0&lt;k≤n≤8) ，用一个空格隔开，表示了将在一个 n×n 的矩阵内描述棋盘，以及摆放棋子的数目。 当为-1 -1时表示输入结束。 随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。
输出描述 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证 C&lt;231 ）。
样例输入 2 1 #. .# 4 4 ...# ..#. .#.. #... -1 -1 样例输出 2 1 题解 基本的路线就是搜索了，同八皇后问题类似，利用回溯法暴力搜索即可。
本题的剪枝条件较为简单，在判定是否落子的时候满足以下情形之一的即可剪枝：
所在位置为. 表示此处不能落子。与已落棋子位于同一行或同一列。已落棋子等于k。 当剪枝越少时意味着搜索算法代价越高，即当棋盘上没有. 全是# 的时候可以得到答案的上界： F(n,k)=AknCkn=n!n!(n−k)!(n−k)!k! 即最终答案。 但搜索算法的代价不止于此，在每个点要判断是否要剪枝需要付出额外的代价。
数据结构 &amp; 算法要点 将棋盘以0-1邻接矩阵的形式来存储可以在很小的常数时间内判断一个给定的(行、列)元组，这个位置是否可落子。(bool board[N][N];)按行搜索，可以保证棋子不在同一行。保存列是否被占用的情况即可在很小的常数时间内判断一个给定的列是否已经被使用，维护这个值的正确性也只需要一个很小的常数时间。(bool isColumnUsed[N])不需要在每个case之前初始化 board, isColumnUsed ，要保证第一个case 之前isColumnUsed 全为 false，程序可以保证 isColumnUsed 在case 结束时复原。 数学漫谈 F(n,k) 关于 n 递增： F(n,k)F(n−1,k)=n2(n−k)2&gt;1 F(n,k) 关于 k 先递增后递减，其递增区间： F(n,k+1)F(n,k)=(n−k)2k+1&gt;1k2−(2n+1)k+n2−1&gt;0k&lt;2n+1−4n+5−−−−−√2或k&gt;2n+1+4n+5−−−−−√2&gt;n(舍去) 即 F(n,k) 关于 k 在 (0,2n+1−4n+5√2) 上递增，在 (2n+1−4n+5√2,n] 上递减。 则 maxF(n,k)=max{F(n,⌊2n+1−4n+5√2⌋),F(n,⌈2n+1−4n+5√2⌉)} 对于 0&lt;k≤n≤8 ， maxF(n,k)=maxF(8,k)=max{F(8,5),F(8,6)}=F(8,6)=564480 参考代码 POJ 1321 棋盘问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e96e4e8d01d2595dce1b094d977cb9/" rel="bookmark">
			三个思路解决413 Request Entity Too Large报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一个项目当中，要求上传图片，并且限制图片大小，虽然在laravel当中已经添加了相关的表单验证来阻止文件过大的上传，然而当提交表单时，还没轮到laravel处理，nginx就先报错了。当你仔细看报错页面时，你会发现有nginx版本信息，经过分析，这报错是因为nginx的默认上传文件大小配置client_max_body_size只有2MB， 基于nginx验证比laravel验证要早，想要友好报错而不是直接显示413 Request Entity Too Large，那么就有三个思路去解决。
思路一：修改nginx配置 这是最简单的一个做法，着报错原因是nginx不允许上传配置过大的文件，那么件把nginx的上传大小配置调高就好。 1、打开nginx主配置文件nginx.conf，一般在/usr/local/nginx/conf/nginx.conf这个位置，找到http{}段并修改以下内容： client_max_body_size 2m; 当中的2m修改成你需要的允许文件大小。 2、修改后，测试nginx配置是否正确 /usr/local/nginx/sbin/nginx -t 3、测试配置正确后，重启nginx使配置生效 /etc/init.d/nginx restart 注意:要是以php运行的话，这个大小client_max_body_size要和php.ini中的如下值的最大值差不多或者稍大，这样就不会因为提交数据大小不一致出现错误。 post_max_size = 2M upload_max_filesize = 2M 当中的2m修改成你需要的允许文件大小。把当中的2m修改成你第一步设置的大小。
思路二：修改添加友好报错页面 思路一虽然简单，但是不一定能过项目测试那一关，项目测试就要求不要看到413 Request Entity Too Large这样显示错误，所以我们只好添加友好报错页面咯。 1、编辑一个简单的htm作为静态友好页面 (注意html文件乱码请用&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;) 2、更改nginx.conf在http定义区域加入： fastcgi_intercept_errors on; 3、nginx的网站conf配置中的server 定义区域加入： error_page 413 /413.htm; （注意此处413与/413.htm之间不要用等号，否则返回状态码为200而不是413，同时尽量不要 http://www.xxx.com/404.html出错则会跳过该页面） 4、测试nginx配置是否正确 /usr/local/nginx/sbin/nginx -t 5、如果上一步成功重启nginx /etc/init.d/nginx restart 思路三：表单提交之前先用JS判断并且阻止表单提交 思路二虽然比思路一有进步了一些，但是提醒还是跳转页面了，这样的用户体验并不会好到哪里去，所以最终想到了思路三。上文已经说过，这413报错是来自后端nginx的，nginx的判断虽然比PHP还要早，但是我们可以直接从前端处理呀！想到这里，实现并不难了。可以添加文件上传事件判断，如果文件超过限制的大小，那么就弹出警告框并让提交按钮失效，如果文件没有超过限制大小，就提示大小合适，并且把之前的按钮失效状态取消掉。 简单的HTML代码： &lt;form action="" method="post" enctype="multipart/form-data"&gt; &lt;div class="form-group"&gt; &lt;label for="picture"&gt;文章展示图片(800KB内):&lt;/label&gt; &lt;input id="picture" name="picture" type="file"/&gt; &lt;/div&gt; &lt;button type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e96e4e8d01d2595dce1b094d977cb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f5a3131290f44c33e1b818bc84328a/" rel="bookmark">
			Spring Bean 循环依赖解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于service层互相调用，一下子没有什么好的拆分方案，所以先解决循环依赖问题。
现有AService 和BService，都在对方bean中注入，导致初始化时循环初始报错，解决方案就是选择其一使其延迟加载。
用配置方式只要将其一设置lazy-init，具体没尝试过因为不适用配置申明的方式。
使用@Resouce或@Autowire方式自动注入的，将其一去掉自动注入注解（或者两个都去掉），使其在创建对象时不进行自动注入，而是在使用前从IOC容器中获取。获取IOC容器的方法参见 获取Spring的上下文环境ApplicationContext的方式
然后从上下文中获取AService类型的bean即可
synchronized (AService .class) { if (aService== null) { synchronized (AService .class) { aService= applicationContext .getBean(AService .class); } } } 良好的设计架构一般不会出现循环依赖的问题，但一下子没有好的解决方案的时候，使用一些小技巧也未尝不可，这是我的一个思路，有其他好的解决方案欢迎指教。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd8521e0efe338339e57ce2839ebe5b/" rel="bookmark">
			完美实现跨域Iframe高度自适应【Iframe跨域高度自适应解决方案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Iframe的强大功能偶就不多说了，它不但被开发人员经常运用，而且黑客们也常常使用它，总之用过的人知道它的强大之处，但是Iframe有个致命的“BUG”就是iframe的高度无法自动适应，这一点让很多人都头疼万分。百度或是谷歌一下，确实很多解决方法，但尝试一下，会发现问题很多：浏览器兼容性差，不能自适应，仅支持同域Iframe等诸多问题，尤其是跨域Iframe高度自适应问题。网上根本找不到一种可行的方案（唯一有一种提到加入代理页面的，经过测试发现无用）。难道真的没有一种可行的解决方案了吗？ No，下面小鸣子和大家分享一种强大的方法，代码如下：
&lt;html&gt; &lt;head&gt; &lt;style&gt; body {margin-left: 0px;margin-top: 0px;margin-right: 0px;margin-bottom: 0px;overflow: hidden;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src='http://hi.baidu.com/' width='100%' height='100%' frameborder='0' name="_blank" id="_blank" &gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 代码强大之处： 1. 该方法完美兼容IE6，7，8 ，Fire fox,chrome，opera 等主流的浏览器； 2.同域，跨域皆支持； 3.不调用任何JS脚本； 注意三点. 1. 文件开头不能是： &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;必须 是&lt;html&gt;开头 2. body样式中的 overflow: hidden; 绝对不对省略； 3.Iframe 中的 height='100%' 以及 滚动条不能设为no(默认是yes，不用设置即可) 好了，马上试试吧。100%不会让你失望。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd305981bca5d0fa06ceffefdc625a3/" rel="bookmark">
			快学scala 第十章 特质 读书笔记及习题答案代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chapter 10 特质 标签：快学scala
一、笔记 scala和java一样不允许从多个超类继承，scala提供特质而非接口。特质可以同时拥有抽象方法和具体方法，而类可以实现多个特质。 不需要将方法声明为abstract，特质中未被实现的方法默认就是抽象的。在重写特质的抽象方法时不需要给出override关键字。特质跟类更为相像。用with添加额外的特质： class ConsoleLogger extends Logger with Cloneable with Serialiable 由上，Logger ith Cloneable with Serialiable首先是一个整体，然后再由类来扩展。 2. 特质的方法并不需要一定是抽象的：
trait ConsoleLogger{ def log(msg: String) { println(msg)}}class SavingAccount extends Account with ConsoleLogger { def withdraw(amount: Double){ if(amount &gt; balance) log("Insufficient funds") else balance -= amount }} //scala与java的区别，SavingAccount从ConsoleLogger特质得到了一个具体的log方法，java的接口是不可能做到的。scala中是ConsoleLogger的功能被混入了SavingAccount类 JVM中，一个类只能扩展一个超类，因此来自特质的字段不能以相同的方式继承。对于特质的构造顺序：首先调用超类的构造器。特质构造器在超类构造器之后、类构造器之前执行。特质由左到右被构造。每个特质当中，父特质先被构造。如果多个特质共有一个父特质，而那个父特质已经被构造，则不会被再次构造。所有特质构造完毕，子类被构造。 class SavingsAccount extends Account with FileLogger with ShortLogger//构造顺序是： Account（超类）Looger（第一个特质的父特质）FileLogger（第一个特质）ShortLogger（第二个特质，它的父特质Logger已被构造），SavingsAccount(类) 特质不能有构造器参数，每个特质都有一个无参数的构造器。缺少构造器参数是特质和类之间唯一的技术差别。 val acct = new SavingsAccount with FileLogger("myapp.log") //错误：特质不能使用构造器参数 FileLogger构造器先于子类构造器执行，在轮到子类之前，FileLogger的构造器就会抛出一个空指针异常。解决方法是 “提前定义”：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cd305981bca5d0fa06ceffefdc625a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc9244e7393275d89571983f34412f89/" rel="bookmark">
			SharedPreferences.Editor 的apply()与commit()方法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		commit()的文档 官方文档如下:
Commit your preferences changes back from this Editor to the SharedPreferences object it is editing. This atomically performs the requested modifications, replacing whatever is currently in the SharedPreferences.
Note that when two editors are modifying preferences at the same time, the last one to call commit wins.
If you don't care about the return value and you're using this from your application's main thread, consider using apply() instead.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc9244e7393275d89571983f34412f89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6d5699106bb868ba858b12a7d189f9/" rel="bookmark">
			poj 几道简单的dp题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：poj 1836 题意： 求使数列程先递增后递减的形式需要去掉的数字个数。当然也可以直接递减或者只递减不递增。 分析： 用最长递增子序列的方法求，然后枚举两个起点的位置即可。
#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int INF=1e8; const int N=1000+9; void LIS(int n,int d[],double g[],double A[]) //Nlog(N) { for(int i=1;i&lt;=n;i++)g[i]=INF; for(int i=0;i&lt;n;i++){ int k=lower_bound(g+1,g+1+n,A[i])-g; d[i]=k; g[k]=A[i]; } } int d1[N],d2[N]; double a[N],b[N],g[N]; int n; int main() { // freopen("f.txt","r",stdin); scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)scanf("%lf",&amp;a[i]),b[n-i-1]=a[i]; //b翻转过来 LIS(n,d1,g,a); LIS(n,d2,g,b); int maxn=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n-i-1;j++)maxn=max(maxn,d1[i]+d2[j]); printf("%d\n",n-maxn); return 0; } 题目：poj 1260 题意： 给出几类珍珠，以及它们的单价，要求用最少的钱就可以买到相同数量的，相同（或更高）质量的珍珠。 【规定买任一类的珍珠n个(价格为p)，都要支付(n+10)*p的钱，即额外支付10*p】 分析： f[i]表示到第i个品类最少花费。 那么f[i]=min{ f[j]+(num[j+1]+num[j+2]+….
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a6d5699106bb868ba858b12a7d189f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0816d711292eb0a45d13ee7b85374b51/" rel="bookmark">
			史上最强的Vim 配置文件（修正版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://blog.csdn.net/redguardtoo/article/details/1172136
史上最强的vimrc文件,据说有800行,还是作者精简后的结果.
我在尽可能保留原作者的创意的前提下做了些小的修正,主要的修改如下:
增加了对win32系统的兼容,原来的vimrc文件只兼容linux和mac
修正了一些快捷键,例如ctr-q被原作者用来搜索buffer,用过win32版本vim的都知道ctrl-q被用来作为块编辑的快捷键,所以ctrl-q是万万不能被移做他用的.
去掉了colorscheme,原作者的colorscheme对我来说实在是太geeky,我想软件默认的colorscheme就该是最适合大多数人的.
启用了swap文件,因为我的机器配置太低,而且我经常要编辑大文件
取消了所有和python有关的plugin,因为一些路径问题,也因为我觉得vim对python的支持够强大了(事实是,我缺乏用python写大项目的经验).
增加了对中文编码的支持,参考了吴咏炜的一篇文章
兼容低版本vi，目前我在vim5.8.9, vim6.1,vim6.3, vim6.4,vim7.0, 上测试过。 其他一些通用性,兼容性的修正
去掉了输入([{时的自动填入右括号的功能,在我修改代码时增加很多麻烦.
我强烈建议你通读这个vimrc文件,一定会很有收获的,至少我是如此.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" _
" __ |
" / | /
" __ |
" by Amix - http://amix.dk/
"
" Maintainer: Amir Salihefendic &lt;amix3k at gmail.com&gt;
" Version: 2.0
" Last Change: 12/08/06 13:39:28
" Fixed (win32 compatible) by: redguardtoo &lt;chb_sh at gmail.com&gt;
" This vimrc file is tested on platforms like win32,linux, cygwin,mingw
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0816d711292eb0a45d13ee7b85374b51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f458850a66a59c52ba974e4518bfe91/" rel="bookmark">
			《PCL点云库学习&amp;VS2010(X64)》Part 15 PCL1.72（VTK6.2.0）三角网格化（2）之泊松重构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《PCL点云库学习&amp;VS2010(X64)》Part 15 PCL1.72（VTK6.2.0）三角网格化（2）之泊松重构
1、cpp
//点的类型的头文件 #include &lt;pcl/point_types.h&gt; //点云文件IO（pcd文件和ply文件） #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/io/ply_io.h&gt; //kd树 #include &lt;pcl/kdtree/kdtree_flann.h&gt; //特征提取 #include &lt;pcl/features/normal_3d_omp.h&gt; #include &lt;pcl/features/normal_3d.h&gt; //重构 #include &lt;pcl/surface/gp3.h&gt; #include &lt;pcl/surface/poisson.h&gt; //可视化 #include &lt;pcl/visualization/pcl_visualizer.h&gt; //多线程 #include &lt;boost/thread/thread.hpp&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;string&gt; //计时 #include &lt;time.h&gt; int main(int argc, char** argv) { // 确定文件格式 char tmpStr[100]; strcpy(tmpStr, argv[1]); char* pext = strrchr(tmpStr, '.'); std::string extply("ply"); std::string extpcd("pcd"); if (pext){ *pext = '\0'; pext++; } std::string ext(pext); //如果不支持文件格式，退出程序 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f458850a66a59c52ba974e4518bfe91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac61a1ee3f2e2a0eea48f041c6ea830/" rel="bookmark">
			FASText(上) : Fast 角点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0导语
本文主要介绍论文FASText:Efficient Unconstrained Scene Text Detector[pdf][code],其核心思想是定制化fast角点使其更有利于场景文字的检测。因此本文主要分上下两篇，第一篇先介绍fast角点，并剖析其opencv（2.4.10）的代码，下篇再介绍FSAText.
首先我们直观感受下FASText和Fast角点，参数阈值为12，FASText用的是FASText12，fast的是TYPE_7_12。并且根据论文的数据，它的proposal比MSER要少一半，但是检出率recall要高25%，并且速度还是4倍以上，全面优于MSER。
FASText(3013个角点)
Fast(7924个角点)
1 Fast特征点
1.1角点候选
Fast角点的思想很简单，很早就已经出来了[2],但是请注意opencv(2.4.10)中NMS的做法法跟论文中有些差别,后面我们会看到。
Fast中对特征点的定义是这样的：
如图3，以当前点（绿色点）为中心，某个半径r画圆。考查圆周上的点（红色），假设它们一共有k个。如果红色的点中有连续超过n个点都大于（或小于）当前点像素值加上某一阈值t的和,那么当前坐标就会被认为是角点的候选。opencv中k和n有3种配置，默认的是k = 16,n = 9,还有k=12, n=7和k=8,n=5这两种配置
上面的例子中如果我们假设k=16,n=9,t=10的话，那么我们就可以找到这么一组点（黄色），其满足上面的所有条件
1)在圆周上且是连续的
2)点的个数10,超过9
3)它们的像素值都低于中心点t以上
所以该点就是潜在角点。从原理上看，fast角点的不具备scale不变性，但基本具有旋转不变和平移不变性。
1.2 NMS
再次强调论文和opencv采用的是不同的思路
第二步也是最后一步就是普通的NMS，但是这里面比较麻烦的是这么去评价一个点的好坏，论文中用的是
其中
意思就是先挑选出圆周上所有比中心点大阈值t以上的点集G和比它小阈值t以上的点集L
G = {,} L = {138,135，82，96，109，71，121，117，140，117，74，110，137，141}
求绝对差并减掉t
G = {}, L ={5,8,61,47,34,72,22,26,3,26,69,33,6,2};
求和
G = 0, L = 414
取两者的最大值414作为分数
但是opencv代码中用的是另外一种思路。类似于木桶原理，它选的是符合条件的点集中与中心点相差最小的像素点，并用他们之间的绝对差作为这个角点的分数。上面的例子中，黄色的点与中心点相差最下的是140，因此分数是13.
本文就讲到这，由于本人水平有限，错误与纰漏还请指正。附上opencv的代码，去掉了优化部分，以方便阅读。
&lt;pre name="code" class="cpp"&gt;#include &lt;opencv/cv.hpp&gt; #include &lt;vector&gt; namespace TestFastKeyPoint { using namespace cv; void makeOffsets(int pixel[25], int rowStride, int patternSize) { static const int offsets16[][2] = { { 0, 3 }, { 1, 3 }, { 2, 2 }, { 3, 1 }, { 3, 0 }, { 3, -1 }, { 2, -2 }, { 1, -3 }, { 0, -3 }, { -1, -3 }, { -2, -2 }, { -3, -1 }, { -3, 0 }, { -3, 1 }, { -2, 2 }, { -1, 3 } }; static const int offsets12[][2] = { { 0, 2 }, { 1, 2 }, { 2, 1 }, { 2, 0 }, { 2, -1 }, { 1, -2 }, { 0, -2 }, { -1, -2 }, { -2, -1 }, { -2, 0 }, { -2, 1 }, { -1, 2 } }; static const int offsets8[][2] = { { 0, 1 }, { 1, 1 }, { 1, 0 }, { 1, -1 }, { 0, -1 }, { -1, -1 }, { -1, 0 }, { -1, 1 } }; const int(*offsets)[2] = patternSize == 16 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac61a1ee3f2e2a0eea48f041c6ea830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9a39f8a191c903451b4d9dcbe942569/" rel="bookmark">
			js的Image对象属性的简单认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说来也惭愧，从接触前端开发以来，一直都在运用jQuery，因为jquery用起来确实是给我们的前端工作带来很大的便利，以至于忽略了对创造出jquery的始祖javascript学习（可能对我这样的前端小白来说都对javascript存在着一定的恐惧。），现在终于下定决心好好啃原生js这块知识。下面是最近自己在学习js基础知识时的一些总结，归纳起来帮助自己记忆了解的同时也希望可以给跟我一样的初学者一些帮助，规避一些不必要的错误。话不多说，下面是自己一些“简单粗暴式”的理解：
js Dom的image对象的属性:
align：设置图片与内联内容的对齐方式 alt：设置或返回图片无法显示时的文字 complete：浏览器判断图片是否加载完整 这个是否涉及到懒加载？？？有待研究 border：设置或者返回图片周围的边框 height：设置或返回图片的高度 width：设置或返回图片的宽度 isMap：返回图像是否是服务器端的图像映射。 这个是否可以用做判断从数据库中拿到的数据是否正确？ useMap：设置或返回客户端图像映射的 usemap 属性的值。 id：设置或者返回图片的id 利用id操作图片 name：设置或者返回图片的name hspace：设置或者返回图片左或者右的空白部分 vspace：设置或者返回图片上或者下的空白部分 longDesc：设置或返回指向包含图像描述的文档的 URL。（即alt或者是有文字的图片中的文字） lowsrc：设置或返回指向图像的低分辨率版本的 URL。 src：设置或返回图像的 URL。 注：Image属性也有优先级。
每创建一个img标签&lt;img/&gt; Image对象也跟着被创建，只是有没有用到就另当别论，下面是对image属性的运用：
html部分：
&lt;img id="img" class="img" src="img/3.jpg" lowsrc="img/6.jpg" alt="js中的Iamge属性的学习" /&gt;
&lt;span&gt;some text some text some text&lt;/span&gt;
js部分：
&lt;script&gt;
//Image中的align属性 js在页面中的位置也很重要，因为html的翻译是从上至下的。因此要特别注意js的位置
document.getElementById("img").align="left";//图片的align属性值默认为center！
//Image中的alt属性 document.getElementById("img").alt="图片的alt属性"; //设置alt的内容
//alert(document.getElementById("img").alt); //获取图片alt的内容
//Image中的complete属性 由于是判断浏览器是否对图片已完成加载，因此需要html中的body标签调用这个属性来判断 利用的是onload事件 //complete返回的值是布尔类型 即只有true或者false
function alterImage(){ alert("Image loaded=" + document.getElementById("img").complete)
} //Image中的border属性 与css样式中的border不同的是，Image中的border属性只需大小，不需要设置其他的属性
document.getElementById("img").border="3";
//Image中的height/width属性 只需要数值，不需要带上单位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9a39f8a191c903451b4d9dcbe942569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9195a7bc00b7a1bf6193b95bada1bdf1/" rel="bookmark">
			Exception in thread &#34;Thread-0&#34; org.eclipse.swt.SWTException: Invalid thread access. 错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行SWT GUI的应用程序是遇到异常：
Exception in thread "Thread-0" org.eclipse.swt.SWTException: Invalid thread access at org.eclipse.swt.SWT.error(SWT.java:4491) at org.eclipse.swt.SWT.error(SWT.java:4406) at org.eclipse.swt.SWT.error(SWT.java:4377) at org.eclipse.swt.widgets.Widget.error(Widget.java:482) at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:373) at org.eclipse.swt.widgets.Text.append(Text.java:437) at com.thomsonreuters.timeseries.HMC.GUI.DoWork.run(DoWork.java:51) at java.lang.Thread.run(Unknown Source) 原因： 在写用户界面是通常画静态界面放在一个类，称为UI线程。而某个按钮或事件触发的另一个事件发生时，起一个线程去处理这个事件，这个线程叫非UI线程。如果你在非UI线程里面对界面的变量，如：某个按钮、text等，就会报上面的错误。因为程序找不到对应的Display。如果您了解Display功能就会很容易理解这个问题，Display的作用就是负责enent loop, font,color,UI线程和其他线程的通信。
解决方法： 在非UI线程操作操作UI线程的地方加上
Display.getDefault().syncExec(new Runnable(){
public void run() {
// 需要操作的ui线程的代码
}
});
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68bdc3e3246dbcdb0402cea2323f728/" rel="bookmark">
			用WindowBuilder编写SWT 桌面应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WindowBuilder是一款基于Eclipse平台的双向Java的GUI设计插件式的软件。它具备SWT/JFACE开发、Swing开发及GWT 开发三大功能，是一款不可多得的Java体系中的WYSIWYG工具。
1 安装WindowBuilder
可以从http://download.csdn.net/detail/sahusoft/9571016 ，下载安装包。然后就是按照eclipse安装插件的形式安装即可。即： Help/ Install New Software...
2 创建项目
File/New/Other..
在Design窗口中，你可以使用拖拽的方式很容易的使用各种部件。
3 设置布局
SWT库中几个典型的布局有”FillLayout, RowLayout， GridLayout
3.1 FillLayout
FillLayout fillLayout = new FillLayout(); fillLayout.type = SWT.VERTICAL; shell.setLayout(fillLayout); 用WindowBuilder的话，鼠标点击在你要设置的组件的上，然后右键有个setLayout的选项，然后选择你要设置的类型即可。
Source下的源码如下：
FillLayoutExample.java
package org.o7planning.tutorial.swt.layout; import org.eclipse.swt.SWT; import org.eclipse.swt.layout.FillLayout; import org.eclipse.swt.layout.RowLayout; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; public class FillLayoutExample { public static void main(String[] args) { Display display = new Display(); final Shell shell = new Shell(display); shell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d68bdc3e3246dbcdb0402cea2323f728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae9ee2b92ecebb87febc63c1391e785a/" rel="bookmark">
			【C/C&#43;&#43;】回溯经典算法之--&gt;八皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、八皇后问题 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。
二、问题分析 整体思路： 创建一个全局变量的二维数组chess;
并初始化全为0
一行一行开始放皇后；
若存在相互攻击，则皇后向右移一列
若不存在攻击，进行下一行皇后的放置（这里要用到递归）
要点： （1）国际象棋的格数 国际像是是8*8，因此，如果放置八个皇后，那么每一行都有一个
（2）问题具体化 利用二维数组，用1来代表皇后，其他为0
（3）皇后的放置方法 利用循环，判断位置是否可以放置皇后，若可以，则放置（将其置1）
三、代码实现 代码块： #include&lt;stdio.h&gt; #include&lt;windows.h&gt; #define N 8 //可以根据N来修改棋盘的格数 int count = 0;//设置一个计数器 int chess[N][N] = {0};//用于存放棋盘的二维数组 void print()//打印函数 {	int i = 0; int j = 0; printf("*****************************************\n"); for(i = 0; i&lt;N ;i++) { for(j = 0; j&lt;N ; j++) { printf("%d ",chess[i][j]); } printf("\n"); } printf("*****************************************\n"); } //判断是否会互吃 //关键条件 //返回1 表示存在互吃 //返回0 表示正常 int check(int i, int j)//i = 7,j = 4 {	if(i == 0) return 0;//表示正常 int k = 0; for(k = 0; k&lt;i ; k++) { if(chess[k][j] == 1)//(0,4)(1,4).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae9ee2b92ecebb87febc63c1391e785a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72efddfa253dc26fe35f3d81541189c0/" rel="bookmark">
			JS前端DES加密参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DES加密为可解密的机制，这里使用DES进行加密方便后台解密还原参数值。本文的功能中des.js与Des.java作用相同，在不同地方产生作用。在登录的页面引入des.js文件，后台写个Des.java类，然后在登录验证前调用即可，方便易用。 jsp页面js函数与表单改造： 注意：要让表单中明文文本框不提交，只需将该文本框的name属性去掉即可。前后台加解密的三个密码字符串要一直。 &lt;script type="text/javascript"&gt;
function setPass(originId,decId){
var orginName = window.parent.document.getElementById('orginName').value;
var newName = strEnc(orginName,'itmp','des','encrypt');
window.parent.document.getElementById('userId').value = newName;
var orginPass = window.parent.document.getElementById(originId).value;
var newPass = strEnc(orginPass,'itmp','des','encrypt');
//alert('newPass=' + newPass + ' pass='+strDec(newPass,'itmp','des','encrypt'));
window.parent.document.getElementById(decId).value = newPass;
}
&lt;/script&gt;
&lt;form id="form" name="form" action="${ctx}/j_spring_security_check" method="post"&gt;
&lt;table width="100%" border="0" cellspacing="0" cellpadding="0"&gt;
&lt;tr&gt;
&lt;td width="20%" height="10" class="black14" align="center" valign="middle"&gt;&lt;/td&gt;
&lt;td colspan="2" align="left"&gt;
&lt;div class="error${param.error==true?'':'hide'}" style="color:red;"&gt;
${sessionScope['SPRING_SECURITY_LAST_EXCEPTION'].message}
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="20%" height="35" class="black14"&gt;用户名&lt;/td&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72efddfa253dc26fe35f3d81541189c0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/462/">«</a>
	<span class="pagination__item pagination__item--current">463/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/464/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>