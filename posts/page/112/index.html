<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97b621235f89b8d5abfe39ff1989cc4e/" rel="bookmark">
			面试必备之Java 最常见 200&#43; 面试题全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了面试必备之Java 最常见 200+ 面试题全解析，老王觉得挺不错的，现在分享给大家，也给大家做个参考。
给准备面试的大家，特别总结了 Java 程序员面试必备的面试题库
共含208道面试题，涵盖十九个模块：从 Java 基础到框架再到JVM，提供详细解读和代码案例，让你知其然还知其所以然。所有面试题答案都可以在文末获取！
而且啊，所总结的这 200+ 道都是必考题！
如果这些都能看懂的话，去面试就十拿九稳了！
适合人群：
想要面试的初/中/高级 Java 程序员
想要查漏补缺的人
想要不断完善和扩充自己 Java技术栈的人
原本就掌握了技术却不知道怎么表达的人
有上进心，也愿意学习的人
Java面试官
说了这么多，直奔主题，这套面试必备的《Java 最常见 200+ 面试题全解析》到底优质在哪？
一、 面试题覆盖全，且解析全面 这份面试题总内容包含了十九个模块：Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、Mybatis、RabbitMQ、Kafka、Zookeeper、MySql、Redis、JVM 。
二 、专业的作者，注重实战经验 作者老王，十余年编程从业经验，曾就职于 360，有着丰富的大型系统设计、开发和调优的经验，在不断探索和学习的过程中，积累了宝贵的编程经验。并且希望在自我解剖和记录的同时，可以帮助到更多的人！
老王说：“我从 2009 年开始参加编程工作，到现在为止还觉得要学的东西很多，学习的过程也给我带来了很多成就感，成就感推动着我学习更多的技术知识。
刚开始的时候我还觉得，总结的这 200+ 道都是必考题，这么做是不是帮人“作弊”的嫌疑，最后我想通了，这是一件值得去做的事儿。
因为第一：让更多的人因此而学到了更多的知识，这是一件大好事。第二：这只是经验的高度提炼，让那些原本就掌握了技术却不知道怎么表达的人，学会如何在面试中展示自己！
具体面试题如下 一、Java 基础
1.JDK 和 JRE 有什么区别？
2. == 和 equals 的区别是什么？
3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？
4. final 在 java 中有什么作用？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97b621235f89b8d5abfe39ff1989cc4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444977f223e3c23cc6d774fa3840ef87/" rel="bookmark">
			linux 安装jdk、tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Linux上安装jdk1、jdk安装与配置过程2、linux查看jdk安装路径 二、Linux上安装tomcat1、tomcat安装与配置过程2、对外开放访问的端口、重启防火墙、查看日志3、修改tomcat的默认端口 三、在window系统中通过浏览器访问四、部署的前端如果一刷新就404，解决方法 前言 先检察是否安装jdk
java -jar ## 查看是否安装jdk java -version ## 查看版本 getconf LONG_BIT ## 检察linux的位数 64 文件后缀含义：
（1）bin代表二进制class文件(由java文件编译而成)，src代表源码（java源码），源码source比binary大一些，一般正常使用下载bin类型即可，如果要学习源码下载src类型。 （2）.tar.gz是linux的压缩包，.zip是windows的压缩包 因此： bin.tar.gz是适用于linux、MacOsX系统的二进制文件 bin.zip是适用于windows的二进制文件 src.tar.gz是linux下的源码 src.zip是windows的源码 java jdk 国内下载镜像地址及安装
下载地址
（1）TUNA镜像 https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/
（2）HUAWEI镜像 https://repo.huaweicloud.com/java/jdk/
（3）injdk https://www.injdk.cn/
一、Linux上安装jdk 官网地址：https://www.oracle.com/java/technologies/downloads/#java8，但需要注册登录
# jdk1.8下载需要登陆oracle账号解决 # 解决：从网上找到一个Oracle账号和密码，直接登录使用下载即可 账号：2696671285@qq.com 密码：Oracle123 账号：1985479344@qq.com 密码：Oracle123 1、jdk安装与配置过程 上传 jdk-8u371-linux-x64.tar.gz 到linux 在/usr/java下 mkdir java # 创建java文件夹,将安装包拖动到/usr/java 解压下载的jdk tar -zxvf jdk-8u371-linux-x64.tar.gz 解压成功后得到文件夹 jdk1.8.0_371
编辑配置文件，配置环境变量 vim /etc/profile ## 配置环境变量 在最后一行添加以下内容
export JAVA_HOME=/usr/java/jdk1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/444977f223e3c23cc6d774fa3840ef87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b376a7f61865e162a319f38ce2b7f27a/" rel="bookmark">
			互联网一线大厂最全Java面试题及答案整理（2023最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 2023秋招即将来临，很多同学会问Java面试八股文有必要背吗？
我的回答是：很有必要。你可以讨厌这种模式，但你一定要去背，因为不背你就进不了大厂。
国内的互联网面试，恐怕是现存的、最接近科举考试的制度。
而且，我国的八股文确实是独树一帜。以美国为例，北美工程师面试比较重视算法（Coding），近几年也会加入Design轮（系统设计和面向对象设计OOD）和BQ轮（Behavioral question，行为面试问题）。
那么为什么国内面试不采取这样的考察方式呢？简单来说，互联网IT行业的求职者太多了，如果考察的是清一溜的算法题和设计题，那么会要求面试官有极高的技术水平，还要花大量的时间成本和精力。
也许现行的八股文面试不是最优的解法，但的确是最符合当前国内IT环境的做法。
所以，我采访了超过20位资深大厂面试官后，一直在尽量精炼准确的整理一套切实可行的八股文，现在已经有329位粉丝通过这套题走入了理想的岗位，所以分享出来给大伙看看，有什么不足之处欢迎评论补充。
Java 面试 现在 Java 面试都是靠八股文，所以我花了很长时间搜集整理出来了这套 Java 面试题大全，希望对大家有帮助哈，记得收藏点赞哟~博主已将以下这些面试题整理成了一个 Java 面试手册，是 PDF 版的。
来看看整体的大纲 JavaOOP 面试题（108 道）
Java 集合/泛型面试题（24 道）
Java 异常面试题（8 道）
Java 中的 IO 与 NIO 面试题（15 道）
Java 反射面试题（11 道）
Java 序列化面试题（38 道）
Java 注解面试题多线程 &amp;并发面试题（78 道）
JVM 面试题（108 道）
Mysql 面试题（78 道）
Redis 面试题（96 道）
Memcached 面试题（54 道）
MongoDB 面试题（12 道）
Spring 面试题（30 道）
Spring Boot 面试题（156 道）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b376a7f61865e162a319f38ce2b7f27a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa2caabe68bb73e7d2a281ab65e74001/" rel="bookmark">
			使用FFMPEG提取图片数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用FFmpeg提取图片数据 FFmpeg介绍FFmpeg安装(Windows)命令行下提取图片数据命令行下将提取的图片数据转成视频结尾 FFmpeg介绍 FFmpeg是一个非常强大的多媒体视频处理工具，其功能包括视频采集功能、视频格式转换、视频抓图、给视频加水印等。FFmpeg有两种常用的方式：
编写代码进行操作使用命令行进行操作 FFmpeg安装(Windows) 这里只分享Windows下的安装方法。安装方法也非常简单，我们首先去官网下载Windows版本的zip压缩包，然后解压即可。
官网链接FFmpeg下载地址
根据需求下载需要的版本即可
解压安装包（解压后可以直接在当前目录打开命令行进行使用也可以配置环境变量）
命令行下提取图片数据 每一秒钟提取一张图片数据
ffmpeg -i movie.ogg -r 1 -f image2 video2img\foo-%03d.jpeg 参数说明
-i 输入视频的位置-r 帧速率（上述语句中设置为1，表示1s的视频中提取一张图片）-f 指定输出格式（imags2是指输出格式为图片）video2img\foo-%03d.jpeg（存储图片的位置） 命令行下将提取的图片数据转成视频 ffmpeg -f image2 -framerate 12 -i video2img\foo-%03d.jpeg video2img\foo.avi 参数说明
-i 输入图片的位置-framerate 帧速率（设置输出的视频帧率为12）-f 指定输入格式（imags2是指输入格式为图片）video2img\foo.avi（存储视频的位置） 结尾 欢迎大家在评论区讨论、学习！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f945c8b5b8c80133dfd20d2f0911b347/" rel="bookmark">
			关于GLTF模型压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、GLTF格式介绍
1) glTF是一种3D内容的格式标准，由Khronos Group管理（Khronos Group还管理着OpenGL系列、OpenCL等重要的行业标准）；
2）glTF的设计是面向实时渲染应用的，尽量提供可以直接传输给图形API的数据形式，不再需要二次转换；
3) glTF对OpenGL ES、WebGL非常友好；
4) glTF的目标是：3D领域的JPEG；
5) 作为一个标准，自2015年10月发布（glTF 1.0）以来，已经得到了业界广泛的认可，你可以相信它的水平；
6）glTF目前最新版本为2.0已于2017年6月正式发布。
GLTF具体的数据存储格式可以去官方网站上看：https://www.khronos.org/gltf/ 有GLTF+bin+Texture以及GLB组织格式，其中GLB是二进制，GLTF是Json方式。
2、GLTF模型压缩方式
1）Draco
扩展：KHR_draco_mesh_compression
用于GLTF扩展以及由 Google 开发的开源库，提供3D图形mesh和点云的压缩和解压。它的目标是提升3D图形的存储和传输效率。它压缩顶点位置、法线、颜色、纹理坐标和任何其他通用顶点属性，从而提高在网络上传输 3D 内容的效率和速度。
使用Draco的好处:
减少空间的占用, 减少网络传输量,该优点是它的核心好处。Draco的解压算法，网页端提供了wasm的解压算法，一定程度的降低了网页端解压消耗 使用Draco的缺憾：
可能性能提升也并没有期望中那么大，这个跟数据源的特点有关，不能得到保证,特别对于纹理压缩不是很理想。模型画质的损失是肉眼可观的，需要总体权衡。 压缩方式：
gltf-pipeline -i scene.glb -o scene-processed.glb -d 详细参考 https://github.com/CesiumGS/gltf-pipeline
2）Meshopt
扩展：KHR_mesh_quantization
压缩方式：
gltfpack -i male.glb -o male-processed.glb -cc 3）MeshQuan
扩展：EXT_meshopt_compression
压缩方式：
gltfpack -i male.glb -o male-processed.glb KHR_mesh_quantization和EXT_meshopt_compression可以使用同一个工具gltfpack
&gt; npm i -g gltfpack # gltfpack命令行工具是C项目构建出WASM执行的，目测未来会有更多wasm这类项目产出 # KHR的优化版的basis trancoder是使用assemblyscript编译成wasm # 转成KHR_mesh_quantization &gt; gltfpack -i model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f945c8b5b8c80133dfd20d2f0911b347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af0dc1aa266757e5b956657d9c60092a/" rel="bookmark">
			JUI-四大布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤： 1、JFrame窗体
2、窗体里添加容器
3、容器添加面板
4、构件可以添加到“容器”中，也可以添加到“面板”里，显示效果不同。
提醒：关于网格布局(GridLayout)，行和列的关系说明可以看往期的“网格布局”的博文
四大布局： 网格布局: GridLayout
边界布局: BorderLayout
流布局: FlowLayout
绝对布局： setLayout(null);
效果图： 代码： class FourLayout { JFrame f = new JFrame();// 新建窗体f Container c;// 新建“容器”c public static void main(String[] args) { // 创建一个Demo类d，class后面的自命名 FourLayout d = new FourLayout(); d.way1();// 窗体属性 d.way2();// 容器镶入窗体，设置面板属性 d.f.setVisible(true);// 窗体可见 } /** * 方法way1 * 设置窗体的属性 */ public void way1(){ f.setSize(900,780);// 窗体f的尺寸 // Location(位置)，Relative(相对的)，null则为居中（默认） f.setLocationRelativeTo(null);// 居中显示，null（空值） // Default(默认)，Operration（操作），点×程序停止运行 f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } /** * 方法way2 * 设置插入容器中面板的数量、属性 */ public void way2(){ c=f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af0dc1aa266757e5b956657d9c60092a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2806a8dd973429f9d6b07b89eea372b/" rel="bookmark">
			python-去除去除字符串首尾的字符strip()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 中的 strip() 是一个字符串方法，用于去除字符串两端的指定字符（默认为空格）。
strip() 方法的语法如下：
string.strip([chars]) 其中，string 是要进行处理的字符串，chars 是可选参数，表示要去除的字符集合。如果没有指定 chars 参数，则默认去除字符串两端的空格字符。
下面是一些常见的用法示例：
1、去除字符串两端的空格：
string = " Hello, World! " result = string.strip() print(result) # 输出："Hello, World!" 2、去除字符串左端的指定字符：
string = "=====Hello, World!" result = string.lstrip("=") print(result) # 输出："Hello, World!" 3、去除字符串右端的指定字符：
string = "Hello, World!....." result = string.rstrip(".") print(result) # 输出："Hello, World!" 需要注意的是，strip() 方法返回一个新的字符串，原始字符串不会被修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7798103605e8e4c52dbf74253cbee126/" rel="bookmark">
			Python内容聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python3 教程 Python 标准库概览 pip 设置代理 设置代理 PyCharm支持的4种Python Interpreter和配置方法Python中import的as语法Python安装自己的代码到site-packagesPython虚拟环境venv的日常使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed9f36a311a57e684a79ea26d1ea087/" rel="bookmark">
			继电器开关阿里云IOT上云设置操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云IOT继电器开关产品
阿里云IOT设备接入的入口有两个。一是物联网平台，二是生活物联网平台(飞燕平台）。
飞燕平台主要是为生成APP用，它创建的产品也会出现在物联网平台下。物联网平台下创建更方便配置相对较少，但其创建的设备不能在飞燕平台下直接生成APP。
一、物联网平台接入
https://iot.console.aliyun.com/lk/summary/new
进入物联网平台控制台 选择华东2（上海）才有免费的公工实例。
进入公共实例。
https://iot.console.aliyun.com/product
进入阿里云物联网平台/设备管理/产品页
1、点击创建产品
2，按图创建产品，产品名可任意但不能重复，品类最好是开关相关的。
3、为产品添加物模型
4、点击编辑草稿
标识符Switch 一定也要写对，读写类型。也可通过快速导入中导入物模型加入。确认后点击发布上线。
物模型下载：
链接：https://pan.baidu.com/s/1mxOrH64r3V-Mdjk1x1ynzg
提取码：qe2f
5、为该产品添加设备
6、配置WIFI及设备证书
设备下点击查看提取设备证书，和同当前使用的WIFI名及密码一起通过QQ或微信发到手机端方便手机上复制操作。
将继电器设备接上电源，第一次使用时会自动转到WIFI配置模式指标灯快闪。打开手机WIFI找到"奇想继电器开关设置"连接，进入设置页面，依次复制输入对应的WIFI名、密码、设备证书。
当指示灯程呼吸状态时，设备进入正常工作。在物联网台设备项能看到当前设备在线。
指示灯状态：
1、常亮 开机连网中。
2、快闪 WIFI配置模式
3、慢闪 无法连接阿里云服务器
4、呼吸 正常工作中
红灯亮灭对应继电器开关通断
Set键： 长按4秒进入wifif配置
7、在线调试
选择开或关 点击设置可看到继电器对应工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49f697c87f9d2007c153bfc03c41eff/" rel="bookmark">
			Sspring Boot 处理数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们接着上一期来说一下，如果出现空值，SpringBoot会如何处理
在实际项目中，难免会遇到一些 null 值出现，转 json 时是不希望有这些 null 出现的，比如期望所有的 null 在转 json 时都变成""这种空字符串，那该如何做呢？在 Spring Boot 中做一下配置即可。
1.新建一个 jackson 的配置类
import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializerProvider; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; import java.io.IOException; @Configuration *[HTML]: 用于声明当前类是一个配置类，最新的注解为@SpringBootConfiguration public class JacksonConfig { @Bean 用于在配置类中，表示方法的返回值是一个受管 bean @Primary 如果多个配置，则以当前的为主 @ConditionalOnMissingBean(ObjectMapper.class) 条件注解，表示如果受管 bean 中没有 ObjectMapper 类型的对象，则需要构建 public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() { @Override public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { jsonGenerator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c49f697c87f9d2007c153bfc03c41eff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d94c0117ad92433f8f6b99661514118/" rel="bookmark">
			Ubuntu下打开QtCreator环境变量LD_LIBRARY_PATH与终端不一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 在unbuntu下使用QtCreator编译、运行程序时，总是出现XXX.so: cannot open shared object file: No such file or directory这类问题，但是在终端中编译或者运行程序则不会出现这些问题。在网上查了好久才明白QtCreator在打开时，并不会像打开终端那样运行source ~/.bashrc，所以就找不到在~/.bashrc中添加的环境变量（export LD_LIBRARY_PATH）。
解决办法： 修改QtCreator启动图标中的相关设置，使用bash -ic命令让启动的应用程序沿用当前终端的环境变量。
gedit /home/kzhao/.local/share/applications/org.qt-project.qtcreator.desktop 将Exec="/opt/Qt5.14.2/Tools/QtCreator/bin/qtcreator" %F修改为：
Exec=bash -ic "/opt/Qt5.14.2/Tools/QtCreator/bin/qtcreator" %F。
参考： Ubuntu下打开QtCreator，环境变量（PATH、LD_LIBRARY_PATH等）与预期不一致的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31df9599a3cf710140459707ccc812f7/" rel="bookmark">
			基于OpenCV的红绿灯识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于OpenCV的红绿灯识别 技术背景 为了实现轻舟航天机器人实现红绿灯的识别，决定采用传统算法OpenCV视觉技术。
技术介绍 航天机器人的红绿灯识别主要基于传统计算机视觉技术，利用OpenCV算法对视频流进行处理，以获取红绿灯的状态信息。具体而言，该系统通过连接工控机摄像头读取视频流，将视频帧转换成HSV色彩空间的图像，以便更好地识别出图像中的红色像素。
HSV是一种将RGB色彩空间中的点在倒圆锥体中的表示方法，其中色相、饱和度和亮度分别用于描述颜色的不同属性。色调（H）用角度度量，其取值范围为0°～360°，从红色开始按逆时针方向计算，具体的光谱色如黄色、青色和品红等的色调取值为60°、180°和300°，而它们的补色则分别为青色、洋红和黄色。饱和度（S）用于描述颜色接近光谱色的程度，其取值范围为0%～100%，值越大，颜色越饱和。亮度（V）表示颜色明亮的程度，其取值范围为0%（黑）到100%（白）。
在红绿灯识别过程中，系统将视频帧转换成HSV图像后，通过筛选出所有红色像素值，利用切片技术切出图像中的红绿灯兴趣区域。接着，系统通过统计区域中红色像素块数量，设定阈值来判断红绿灯的状态，如果红色像素块数量超过阈值，则判定红绿灯为红灯闪烁，小车禁止通行；反之，如果红色像素块数量小于阈值，则判定红绿灯为绿灯闪烁，小车可以通行。
这种基于传统计算机视觉技术的红绿灯识别系统具有精度高、鲁棒性强等优点，可以在复杂的环境下准确地判断红绿灯的状态，从而为机器人的自主导航和交通安全提供可靠的技术支持。
HSV 模型的三维表示从 RGB 立方体演化而来。设想从 RGB 沿立方体对角线的白色顶点 向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度， 明度沿垂直轴测量。HSV 颜色空间可以用一个圆锥空间模型来描述。圆锥的顶点处，V=0，H 和 S 无定义，代表黑色。圆锥的顶面中心处 V=max，S=0，H 无定义，代表白色。
代码实现 import cv2 import numpy as np # from cv_nano3_good import Img, Video def gstreamer_pipeline( capture_width=1280, capture_height=720, display_width=1280, display_height=720, framerate=120, flip_method=0, ): return ( "nvarguscamerasrc ! " "video/x-raw(memory:NVMM), width=(int)%d, height=(int)%d, format=(string)NV12, framerate=(fraction)%d/1! " "nvvidconv flip-method=%d ! " "video/x-raw, width=(int)%d, height=(int)%d, format=(string)BGRx ! " "videoconvert ! " "video/x-raw, format=(string)BGR !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31df9599a3cf710140459707ccc812f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40f74603d0aa5986a9937f91eb8f3b6/" rel="bookmark">
			Git学习记录之一Git常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Git常用命令总结 前言 最近在学习Git，作为我们码农界的菜鸟，当然需要时常整理笔记，并且与大家分享，互相帮助啦。需要的同学请继续往下看吧
Git常用命令 先给小伙伴们看两张git操作的流程示意图吧！
1.基础操作指令
git add (工作区-&gt;暂存区)
git commit(暂存区-&gt;本地仓库)
*创建文件：touch 文件名 例如：touch file03.txt
*初始化git仓库：git init
*用vi编辑器来修改文件
在vi编辑器中修改文件后，可以按下Esc键，然后输入冒号(:)进入命令模式。接下来可以输入以下命令来保存修改并退出vi编辑器：
输入:w命令保存文件，但不退出vi编辑器。
输入:wq命令保存文件并退出vi编辑器。
输入:q!命令不保存文件并强制退出vi编辑器。
如果只是想退出vi编辑器而不保存修改，可以按下Esc键，然后输入冒号(:)进入命令模式，再输入:q命令即可退出。
1.1查看修改的状态
作用：查看修改的状态(暂存区，工作区)
命令：git status
1.2添加工作区到暂存区（add）
作用：添加工作区一个或多个文件到暂存区
命令：git add 单个文件名
*将所有修改加到暂存区：git add .
1.3提交暂存区到本地仓库
作用：提交暂存区内容到本地仓库的当前分支
命令：git commit -m '注释内容'
1.4查看提交日志
作用：查看提交记录
命令：git log[options]
options
--all 显示所有分支
--pretty=oneline将提交的信息显示为一行
--abbrev-commit 使得输出的commit更简短
--graph 一图的形式显示
1.5版本回退
作用：版本切换
命令：git reset --hard commitID
commitID可以使用git-log或git log指令查看
如何查看已经删除的记录？
git reflog
这个指令可以看到已经删除的提交记录
1.6文件删除
命令：rm -rf 文件名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40f74603d0aa5986a9937f91eb8f3b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/029b589c6b17e0bca5e1c74e77bc6373/" rel="bookmark">
			全光谱吸顶灯选购指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.客厅 1.1 客厅吸顶灯对比 2.卧室 2.1 卧室吸顶灯对比 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f94bf8084fd1699c588aa55d4a1278/" rel="bookmark">
			Python学习笔记：函数和变量传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数和变量传递 函数 函数是一个可重复使用的代码块。函数能提高应用的模块性和代码的重复利用率。
Python提供了许多内建函数供用户直接调用，比如print()。同时也可以自己创建函数，称之为用户自定义函数。
函数定义 使用def关键字来定义函数。语法格式为：
def 函数名 (参数): """ 说明文档 """ 执行语句 (return 返回值) 即使函数没有参数值，参数的括号也不能省略。
如：
def add(a, b): """ 输入两个值，返回他们的和 """ return a + b 上述代码段中定义了一个函数add()，括号内包含两个参数a和b，函数的返回值为a+b。
返回值return是指退出函数并返回结果，一个函数可以没有返回值，也可以有多个返回值；有多个返回值时，若只有一个变量来接受，则返回值为元组类型；或者必须有对应的变量数量来接收，否则会报错。
函数调用 一个简单的两个参数输入返回一个值的函数： def add(a, b): return a + b print(add(1, 2)) # 输出：3 ​ 调用函数时，需严格按照函数的参数格式输入，包括参数的数量和顺序。
​ 上述代码中，add()函数指定了两个输入参数，用户在调用函数时也需要输入两个参数来获得函数的返回值。
多个参数输入多个参数返回的函数： def my_print(a, b, c): return a, b, c a = my_print(1, 2, 3) print(a) # 输出：(1, 2, 3) a, b = my_print(1, 2, 3) print(a, b) # 错误 a, b, c = my_print(1, 2, 3) print(a, b, c) # 输出：1 2 3 调用函数时请注意参数的对应关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82f94bf8084fd1699c588aa55d4a1278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27adb4953c2feba5b2e4c1a6976394bd/" rel="bookmark">
			Java反射getMethod和getDeclaredMethod区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java反射中,Class类提供了getMethod()和getDeclaredMethod()两个方法用于获取方法,两者的区别是:
1. getMethod():只能获取public的方法,包括从父类继承的public方法。
2. getDeclaredMethod():可以获取类本身声明的所有方法,包括public、protected、default访问修饰的方法,但是不包括继承的方法。
public class Main { public void publicMethod() {} private void privateMethod() {} public static void main(String[] args) throws Exception { Class&lt;?&gt; clazz = Main.class; // 获取public方法 clazz.getMethod("publicMethod"); // 成功 // 获取private方法 clazz.getMethod("privateMethod"); // 抛出NoSuchMethodException // 获取所有声明的方法 clazz.getDeclaredMethod("publicMethod"); // 成功 clazz.getDeclaredMethod("privateMethod"); // 成功 } } 可以通过Method的setAccessible(true)设置可访问属性 结论:
getMethod():只能获取public方法
getDeclaredMethod():可以获取类声明的所有方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2a84c46dcdfa71de04cb5b684195e4a/" rel="bookmark">
			实现token的无感刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 token：
作用：在访问一些接口时，需要传入token，就是它。 有效期：2小时（安全）。
refresh_token：
作用: 当token的有效期过了之后，可以使用它去请求一个特殊接口（这个接口也是后端指定的，明确需要传入refresh_token），并返回一个新的token回来（有效期还是2小时），以替换过期的那个token。
有效期：14天。（最理想的情况下，一次登陆可以持续14天。）
安全和体验 从安全角度来看 token 必须要具有一定的时效性，失效后的 token 不再能标识用是登录状态。 另外也要考虑用户的体验，例如用户在 token 失效的前 1 分钟打开小程序，用户浏览小程序 1 分钟后 token 失效，用户不得不再次去登录，这样的用户体验是极差的。 为了既能保证安全性又兼顾用户体验，咱们需要能够自动刷新 token 的方法，即 refresh_token。 refresh_token工作机制 用户在首次完成登录时会分别得到 token 和 refresh_token 当 token 失效后（例如2小时之后），调用接口A会返回 401 状态码（这是与后端约定好的规则） 检测状态码是否为 401，如果是，则携带refreshToken去调用刷新token的接口 刷新 token 的接口后会返回新的 token 和 refreshToken 把401的接口A重新发送一遍 注意：
refresh_token也是有过期时间的，只不过一般会比token过期时间更长一些。这就是为啥如果某个应用我们天天打开，则不会提示我们登录，如果是有几周或更长时间去打开时，会再次要求我们登录。
refresh_token一个更常见的名字叫token无感刷新。
refreshToken功能-基本实现 操作如下：
正常登录进入页面在本地存储中直接修改localstorage的token值，模拟token失效。刷新页面，重新发一次请求（此时请务必确保请求拦截器中的token是从本地存储中拿到的）出现401错误。 主要代码 // 响应拦截器 http.intercept.response = async ({ statusCode, data, config }) =&gt; { // debugger console.log(statusCode, data, config) // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2a84c46dcdfa71de04cb5b684195e4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b26d8c5fd736a6e757884ea1a735f80/" rel="bookmark">
			前端大文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大文件上传是需要前端和后端同时参与才可以实现的。
思路 大文件上传整体思路：文件切片 和 断点续传
前端思路 利用上传控件 input type="file" 绑定一个change事件，在回调中通过事件对象的e.target.files拿到这个文件对象，进行文件对象的slice方法，进行切片，一个大文件就转换成多个小文件了。借助 http 的可并发性，同时上传多个切片。这样从原本传一个大文件，同时传多个小的文件切片，可以减少上传时间断点续传：前端在上传切片时，给对应的切片添加一个唯一标识符，上传到后端，服务器需要记住已上传的切片，这样下次就可以跳过之前已经上传的部分 后端思路 服务端负责接受前端传输的切片，并在接收到所有切片后合并所有切片。服务端保存已上传的切片 hash，上传相同文件要可以进行排除。 切片处理 通过上传文件的控件 input type="file"以及他的change 事件拿到当前上传文件的文件对象e.target.files将文件对象 进行切片处理，利用slice方法。 createFileChunk(file, size = SIZE) { const fileChunkList = []; let cur = 0; while (cur &lt; file.size) { fileChunkList.push({ file: file.slice(cur, cur + size) }); cur += size; } return fileChunkList; } 注意：循环截取.slice方法不是数组的slice方法,而是文件对象原型上的slice方法,继承自 Blob的slice
以小文件的形式 向后端发请求 Promise.all &lt;template&gt; &lt;div&gt; &lt;input type="file" @change="handleFileChange" /&gt; &lt;el-button @click="handleUpload"&gt;upload&lt;/el-button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import axios from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b26d8c5fd736a6e757884ea1a735f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55aaa91f7260ad8d02eec142a719c7cf/" rel="bookmark">
			Linux安装jdk，Tomcat，mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建虚拟机 1.创建虚拟机。 点击工具，选择新建虚拟机
名称可以随意取名，类型选择Linux，版本建议选择other Linux（64-bit），而后点击下一步。
若安装mysql5.7以上的建议设置为6G（4G内存会不够用，导致一些文件解压不出来）。
直接点击创建即可。
默认选择第一个，点击下一步即可。
默认选择第一个，点击下一步即可。
直接点击创建。 2.虚拟机初始化和配置网络环境 这里分俩种情况，一种为无线WiFi网络，一种是连接网线的
2.1连接网线的情况下。 点击：网络地址转换（NAT） ，选择桥接模式。
而后直接启动即可。
2.2连接无线WiFi的情况下。 3.虚拟机初始化 启动虚拟机之后，点击回车，而后显示这个界面。
往下滑找到中文，选择中文的简体中文 （中国）而后点击，继续。
而后进入该界面，点击安装位置。
点击方框内的下拉框，选择标准分区。
点击+号
要添加的挂载点有： 第一个（/），第二个（/boot），第五个（swap）。这三个都是必须要添加的。第一个期望容量建议为6个G（主要是mysql5.7版本及以后的版本需要占用的内存较大） 其他俩个各位1G即可。
添加挂载点：/，期望容量为6GB
添加完三个之后点击完成。
点击接受更改
往下滑找到网络和主机名，点击网络和主机名。
点击关闭按钮左边的按钮，打开网络连接。主机名更改为localhost，点击应用。
若你连接的是网线且选择的网络连接方式为桥接方式，则会显示已连接和显示出ip地址和子网掩码等内容。
若你连接的是无线WiFi，但是连接方式为桥接方式，则会显示连接已断开
而后点击左上角的完成。
点击最小化安装，勾选图中内容。
最后点击开始安装。
设置root密码。
密码过于简单则需要点击俩次完成按钮。
而后等待安装完成点击重启。
二、设置共享文件夹 共享文件夹是用于在主机（Windows）与虚拟机（Linux）互传文件最简单的一种方式。
1.安装增强功能 点击虚拟机窗口上的设备，选择最后的安装增强功能，若没有任何反应则说明操作成功。
若出现如下错误。
则点击设备，选择第一个分配光驱中的移除虚拟盘。
2.挂载 因为是最小化安装的centos，光盘加载之后不会自动播放，所以需要手动挂载光盘 先建立挂载点：mkdir /mnt/cdrom，然后执行：mount /dev/sr0 /mnt/cdrom。而后进入cdrom文件夹：cd /mnt/cdrom/。 运行VboxLinuxAddtions.run：sudo /mnt/cdrom/VBoxLinuxAdditions.run，即可正确安装 virtualbox的增强功能了，整个安装过程需要1分钟左右 (如果提示缺少bzip，请自行安装)具体教程可以去百度。若是你在最小化安装的时候勾选了图中的内容（具体可以往上翻，找到最小化安装设置哪里），则不会出现这种报错。（我是没有遇到的，不清楚其他人的情况）。
3.设置共享文件夹
点击设备上的共享文件夹。点击方框内，添加共享文件夹
路文件夹路径为你主机（Windows系统）的文件夹。勾选自动挂载和固定分配。
进入挂载点： cd /tmp/tools,可以看到共享文件夹内的内容。
二、jdk 1.解压jdk安装包 查看是否安装了jdk：rpm -qa | grep jdk(若有则删除jdk：yum -y remove java，避免冲突）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55aaa91f7260ad8d02eec142a719c7cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69009789535e952c9f5367257a59a61e/" rel="bookmark">
			一张图转3D质量起飞！GitHub刚建空仓就有300&#43;人赶来标星
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梦晨 发自 凹非寺
量子位 | 公众号 QbitAI 最新“只用一张图转3D”方法火了，高保真那种。
对比之前一众方法，算得上跨越式提升。（新方法在最后一行）
挑出一个结果放大来看，几何结构细节丰富，渲染分辨率也高达1024x1024。
新方法Magic123，来自KAUST、Snap和牛津联合团队，一作为KAUST博士生钱国成。
只需输入单个图像，不光生成高质量3D网格，连有视觉吸引力的纹理也一起打包生成。
甚至论文刚挂在arXiv上，代码还没来得及上传时，就已经有300+人赶来标星码住（顺便催更）。
从粗到精，两阶段方案 以往2D转3D最常见方法就是NeRF。但NeRF不光占显存高，分辨率还低。
论文中指出，即使资源效率更高的Instant-NGP方案在16G显存GPU上也只能达到128x128的分辨率。
为进一步提高3D内容的质量，团队在NeRF之后引入了第二阶段，采用DMTet算法将分辨率提高到1024x1024，并且细化NeRF得出的几何结构和纹理。
对于仅有一张的2D参考图像，首先使用现成的Dense Prediction Transformer模型进行分割，再使用预训练的MiDaS提取深度图，用于后续优化。
然后进入第一步粗阶段，采用Instant-NGP并对其进行优化，快速推理并重建复杂几何，但不需要太高分辨率，点到为止即可。
在第二步精细阶段，在用内存效率高的DMTet方法细化和解耦3D模型。DMTet是一种混合了SDF体素和Mesh网格的表示方法，生成可微分的四面体网格。
并且在两个阶段中都使用Textural inversion来保证生成与输入一致的几何形状和纹理。
团队将输入图像分为常见对象（如玩具熊）、不太常见对象（如两个叠在一起的甜甜圈）、不常见对象（如龙雕像）3种。
发现仅使用2D先验信息可以生成更复杂的3D结构，但与输入图像的一致性不高。
仅使用3D先验信息能产生精确但缺少细节的几何体。
团队建议综合使用2D和3D先验，并经过反复试验，最终找到了二者的平衡点。
2D先验信息使用了Stable Diffusion 1.5，3D先验信息使用了哥伦比亚大学/丰田研究所提出的Zero-1-to-3。
在定性比较中，结合两种先验信息的Magic123方法取得了最好的效果。
在定量比较中，评估了Magic123在NeRF4和RealFusion15数据集上的表现，与之前SOTA方法相比在所有指标上取得Top-1成绩。
那么Magic123方法有没有局限性呢？
也有。
在论文最后，团队指出整个方法都建立在“假设参考图像是正视图”的基础上，输入其他角度的图像会导致生成的几何性质较差。
比如从上方拍摄桌子上的食物，就不适合用这个方法了。
另外由于使用了SDS损失，Magic123倾向于生成过度饱和的纹理。尤其是在精细阶段，更高分辨率会放大这种问题。
项目主页：
https://guochengqian.github.io/project/magic123/
论文：
https://arxiv.org/abs/2303.11328
GitHub：
https://github.com/guochengqian/Magic123
参考链接：
[1]https://twitter.com/_akhaliq/status/1675684794653351936
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd06e7d8b4e9171ee338fb6382ef31fa/" rel="bookmark">
			docker || 启动mysql容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1步：拉取mysql镜像。
[root@docker ~]# docker pull mysql:5.7.41 第2步：启动mysql容器。
[root@docker ~]# docker run -d --name sc-mysql-1 -p 33060:3306 -e MYSQL_ROOT_PASSWORD='sc123456' mysql:5.7.41 5a758962f18df44b0d8c8377b9652bfb791690fa0d15b495f3377ea73dca1463 [root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5a758962f18d mysql:5.7.41 "docker-entrypoint.s…" 3 seconds ago Up 2 seconds 33060/tcp, 0.0.0.0:33060-&gt;3306/tcp, :::33060-&gt;3306/tcp sc-mysql-1 [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql 5.7.41 0018a8d83892 11 hours ago 455MB [root@docker ~]# netstat -anplut|grep 3306 tcp 0 0 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd06e7d8b4e9171ee338fb6382ef31fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5efd3e6153f6f6d76e039ae7615c2a7/" rel="bookmark">
			项目安全问题-SM4加解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇建议与下方链接文章一起观看
http://t.csdn.cn/tjmeS
项目安全问题一直被人们研究，当前端路径上通过?status这种拼接参数时，参数的值在浏览器路径栏上非常醒目，是很容易被人恶意修改的，比如该用户并没有编辑权限，但有心之人却可以通过修改参数status的值把see改成edit，然后还可以改query路径参数的id，前端通常会通过上述参数开启页面按钮权限，也会根据id去调用接口实现功能。
事实上如果是移动端，也会出现上述情况，我之前在做公众号开发时，就经常在右上角复制页面路径然后改参数值去测试功能，后来是通过一些判断，右上角三个点是否出现，把相关功能给隐藏了才得以解决，关于隐藏右上角的功能按键，微信开发者官方文档应该是写的很清楚，我们可以在指定页面再开启该功能。
项目中我们会把后端返回的一些信息放在会话存储或本地存储中，这也会带来安全问题
web端开发项目时怎么解决安全问题，下文便是我当前项目在用的方法。
1.使用SM4加密——请求头加两个参数，一个是token加用户ID加时间戳加当前请求的路径,一个是请求时时间戳，默认query上拼两个参数这种，md5加解密用户信息。
// 获取当前时间-时间戳-ISO 8601扩展格式的日期 new Date(Date.now()).toISOString() 2.把参数传给后端后，后端解密然后判断该用户是否有修改、查询当前页面内容的权限，进而阻止有心之人的恶意操作。
3.后端传给前端的所有响应数据都加密，前端SM4解密后使用。
4.前后端怎么加解密：
参考该gitee 项目
其中的base64js.js文件可能有问题，我自己npm install base64-js了一下，然后在SM4Util.js里引入使用
var base64js = require('base64-js'); 一、在前端axios请求拦截器可以获取到我们想要的，像接口路径和参数，我们可以在这里进行加密处理。
Vue.prototype.$http.interceptors.request.use(config =&gt; { // console.log('config的路径，参数 :&gt;&gt; ', config.url,config.data); // 加密 SM4Util.sm4ECBEncrypt(需要加密的字符串, 密钥) config.headers.随便起的名称={加密后的参数}; return config; }); 二、在响应拦截器Vue.prototype.$http.interceptors.response.use里做对响应的统一解密处理，然后return出去；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a58c97c6f6eb96f3ee4e36fd259f2a43/" rel="bookmark">
			高等数学❤️第一章~第二节~极限❤️极限的计算~两个重要极限详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【精讲】高等数学中两个重要极限的详解 博主：命运之光的主页
专栏：高等数学
目录
【精讲】高等数学中两个重要极限的详解
导言
一、自然对数的底e的极限
二、正弦函数的极限
必需记忆知识点
例题（用于熟悉高等数学中两个重要极限） 例题1
例题2
例题3
例题4
例题5
例题6
例题7
例题8
例题9
结论
导言 在高等数学中，极限是研究函数和数列趋向某个值的重要概念。两个特别重要的极限是自然对数的底e的极限和正弦函数的极限。本文将详细解释这两个重要极限的定义、性质以及在数学和科学领域中的应用。
一、自然对数的底e的极限 自然对数的底e是一个重要的常数，它是一个无理数，约等于2.71828。e可以通过以下极限定义： lim(n→∞) (1 + 1/n)^n = e
证明：我们可以利用数列的极限性质来证明自然对数的底e的极限。考虑数列{a_n} = (1 + 1/n)^n，当n趋向无穷大时，每个项都会接近e。通过数学分析和上确界与下确界的定义，我们可以得出e是这个数列的极限。
应用：自然对数的底e在数学、物理学和工程学等领域中有广泛应用。它与复利计算、指数函数、微积分和微分方程等密切相关。
二、正弦函数的极限 正弦函数是三角函数中的一种，它是周期函数，取值范围在[-1, 1]之间。在高等数学中，我们经常用以下极限来定义正弦函数的性质： lim(x→0) sin(x)/x = 1
证明：正弦函数的极限可以通过洛必达法则（L'Hôpital's rule）来证明。洛必达法则是解决0/0型或∞/∞型的不定式极限的常用方法。对于此极限，我们可以对sin(x)和x同时求导，然后再次计算极限。通过洛必达法则，可以得出lim(x→0) sin(x)/x = 1。
应用：正弦函数的极限在三角学、波动学、信号处理等领域中有广泛应用。它是振动和周期性现象的重要数学模型。
必需记忆知识点 例题（用于熟悉高等数学中两个重要极限） 例题1 例题2 例题3 例题4 例题5 例题6 例题7 例题8 例题9 结论 自然对数的底e的极限和正弦函数的极限是高等数学中两个重要的极限。e的极限是自然对数和指数函数的基础，而正弦函数的极限是三角函数的基本性质之一。这两个极限在数学和科学研究中扮演着重要角色，为许多数学理论和实际问题提供了有效的工具。
本章的内容就到这里了，觉得对你有帮助的话就支持一下博主把~
🌌点击下方个人名片，交流会更方便哦~
↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed456a681c31b6a69863b68defd69e2/" rel="bookmark">
			编译器与解释器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译器（Compiler）和解释器（Interpreter）是将高级语言代码转换成机器可执行代码的不同工具。它们之间的主要区别在于执行过程和结果的产生方式。
一、编译器：
概念： 编译器将整个源代码作为输入，并通过多个阶段的处理将其转换为低级语言或机器码，以供后续直接执行。 特点 ：
1.编译器在执行前对源代码进行全部编译，并生成目标代码（二进制文件）。 2.生成的目标代码可以在不同平台上独立执行，不需要依赖编译器本身。
3.在运行时，编译器不需要再次处理源代码，只需执行已编译的目标代码。这使得编译器生成的程序执行速度较快。
工作过程：
词法分析：编译器首先对源代码进行词法分析，将其划分为不同的标记（tokens），如关键字、变量名、操作符等。
语法分析：编译器进行语法分析，根据编程语言的语法规则生成语法树或抽象语法树（AST）。语法树表示源代码中的结构和关系。
语义分析：编译器进行语义分析，检查代码是否符合语言规范，并进行类型检查、作用域分析等。它还会建立符号表来管理变量、函数等信息。
优化：编译器进行代码优化，通过重组、简化或替换代码，提高程序的性能和效率。优化可以包括常量折叠、循环展开、内联函数等技术。
中间代码生成：编译器将源代码转化为中间代码（intermediate code），这是一种抽象的、与机器无关的表示形式。通常，中间代码是一种类似于汇编语言的低级别代码。
目标代码生成：编译器将中间代码翻译为特定机器平台上的目标代码，也称为汇编代码。目标代码是与机器体系结构相关的二进制指令序列，可以直接在计算机硬件上执行。
链接：对于大型程序，编译器可能还需要进行链接操作。链接器将目标代码与其他模块（如库文件）合并成一个可执行文件。
二、解释器： 概念：
解释器一次只处理一行或一个语句，并将其翻译为机器代码并立即执行。
特点：
1.解释器逐行读取源代码，逐行解释执行。它将源代码逐行翻译成机器语言并立即执行，不生成独立的目标代码。
2.解释器每次执行都要经过翻译和执行两个步骤，因此相比编译器而言，解释器的执行速度较慢。
3.不同平台上的解释器通常不兼容，需要针对特定平台定制和适配。
工作过程：
读取：解释器首先读取源代码文件或用户输入的代码。
解析：解释器将源代码按照语法规则进行解析，创建语法树或抽象语法树（AST）。
词法分析：解释器对源代码进行词法分析，将其划分为不同的标记（tokens），如关键字、变量名、操作符等。
语义分析：解释器进行语义分析，检查代码是否符合语言规范，并建立符号表来管理变量、函数等信息。
翻译和执行：解释器逐行地将代码翻译为机器代码或字节码，并立即执行相应的操作。这个过程可以是逐行执行，或者将一部分代码先编译成中间表示，再解释执行。
错误处理：解释器在执行过程中处理错误，如语法错误、运行时错误等，并提供相应的错误提示和处理。
总结：
编译器将源代码一次性编译成目标代码，然后目标代码可以独立执行。解释器则逐行解释执行源代码，每次执行一行。编译器的优势在于程序的执行速度较快，而解释器的优势在于灵活性，可以根据不同平台动态解释执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d00a76ef74a9bff27679998ac1f69f8/" rel="bookmark">
			Allegro学习笔记——网络表从生成到导入PCB及放置器件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、生成网表 1.1、在OrCAD Capture中对dsn文件进行DRC检查。一定要先点击dsn文件再进行检查。
然后出现下图
1.2、DRC无误后生成网表
下图保持默认即可。
至此，网络表导出成功。
你会在原理图所在目录发现名为‘allegro‘的文件夹其中包含网表文件
2、导入网表 第一步：
第二步：
没有出现报错即导入成功，或者可以
看到有器件未放置
3、放置器件 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83aa20b427288f3e8bdc16e36dfbe48d/" rel="bookmark">
			Linux—Web服务器（静态、动态网站的搭建）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、web服务器 1.1www所用的协议
HTTP超文本传输协议，是互联网上最广泛的一种网络协议，所有的www文件都必须遵守这个标准
它是建立在TCP上一种的无状态连接，整个基本的工作流程是客户端发送一个HTTP请求，说明客户端想要访问的资源和请求的动作，服务端收到请求之后，服务端开始处理请求，并根据请求做出相应的动作访问服务器资源，最后通过发送HTTP相应把结果返回给客户端，其中一个请求的开始到一个相应的结束称为事务，当一个事务结束后还会在服务端添加一条日志条目
1.1.1 网址及HTTP简介
web服务器提供的这些数据大部分都是文件，那么我们需要在服务器端先将数据文件写好，并且放置在某个特殊的目录下面，这个目录就是我们整个网站的首页，在Redhat中，这个目录默认在/var/www/html。
URL：统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址
网址格式：&lt;协议&gt;://&lt;主机或主机名&gt;[:port]/&lt;目录资源或路径&gt;
httpd常用的协议状态码：
status(状态码)： 1xx：100-101 信息提示 2xx：200-206 成功 3xx：300-305 重定向 4xx：400-415 错误类信息，客户端错误 5xx：500-505 错误类信息，服务器端错误 常见状态码、状态描述的说明：
200： 客户端请求成功 400： 客户端请求有语法错误，不能被服务器所理解 401： 请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用 403： 服务器收到请求，但是拒绝提供服务 404： 请求资源不存在，举个例子：输入了错误的URL 500： 服务器内部错误 502： 代理服务器从后端服务器收到了一条伪响应，如无法连接到网关 503 – 服务不可用，临时服务器维护或过载，服务器无法处理请求 504 – 网关超时 505 — http的版本不受支持 二、HTTP协议请求的工作过程 （1）终端客户在web浏览器地址输入访问地址http://www.ceshi.con:80/index.html （2）web浏览器请求DNS服务器把域名www.ceshi.com解析成web服务的IP地址 （3）web浏览器将端口号（默认是80）从访问地址（URL）中解析出来 （4）web浏览器通过解析后的IP地址及端口号与web服务器之间建立一条TCP连接 （5）建立TCP连接后，web浏览器向web服务器发送一条HTTP请求报文 （6）web服务器响应并读取浏览器的请求信息，然后返回一条	HTTP响应报文 （7）web服务器关闭HTTP连接，关闭TCP连接，web浏览器显示访问的网站内容到屏幕上 三、www服务器的基本配置 在服务端（192.168.169.128）进行：
第一步：挂载
mount /dev/sr0 /mnt 第二步：配置yum源仓库
vim /etc/yum.repos.d/base.repo 第三步：安装http并启动服务，关闭防火墙和selinux
[root@server ~]# yum install httpd -y [root@server ~]# systemctl start httpd [root@server ~]# systemctl stop filewalld [root@server ~]# setenforce 0 测试结果：可以访问到资源界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83aa20b427288f3e8bdc16e36dfbe48d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39e875d2ae065f998c7b7fad6b3afe2/" rel="bookmark">
			Element Plus 稳定版正式发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，我们非常高兴地宣布 Element Plus 稳定版正式发布。自第一个 commit 起，经过 1 年零 7 个月的持续迭代开发，总计 2635 commits，经过 256 位贡献者所提交的 2494 个 PR，137 个 Alpha 与 Beta 版本，在社区每一位同学的参与帮助下，Element Plus 的第一个正式版终于和大家见面。
重大更新 TypeScript 与 Vue 3 Element Plus 使用 TypeScript 与 Vue 3.2 开发，提供完整的类型定义文件。并使用 Composition API 降低耦合，简化逻辑。
兼容性 由于 Vue 3 不再兼容 IE，所以 Element Plus 也提高了最低兼容的版本。
Edge ≥ 79Firefox ≥ 78Chrome ≥ 64Safari ≥ 12 如果想在低版本浏览器上正常使用 Element Plus，请自行使用 Babel、ESBuild 或其他转换工具，并引入相应的 polyfill。
值得注意的是，Element Plus 使用到了 ResizeObserver，如有兼容性需求需要您自行引入 resize-observer-polyfill。详情请参阅 ResizeObserver 的兼容性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c39e875d2ae065f998c7b7fad6b3afe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f03247ab7ba8e59503cf66e1fa0fe225/" rel="bookmark">
			element-plus 动态Icon图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1，前言2，使用 2.1，方式一2.2，方式二 1，前言 源自
Element Plus 团队正在将原有组件内的 Font Icon 向 SVG Icon 迁移，请多多留意更新日志, 及时获取到更新信息，Font Icon 将会在第一个正式发布被废弃，请尽快迁移
在此记录一下如何使用element-plus中的icon组件
环境：
Vue：3.2.16Element-Plus：1.2.0-beta.3TypeScript：4.4.3Vite：2.6.4 2，使用 文档原话：如果你想像用例一样直接使用，你需要全局注册组件，才能够直接在项目里使用
在main.ts中先导入
import * as Icons from '@element-plus/icons' 2.1，方式一 在main.ts中
import { createApp } from 'vue' import App from './App.vue' import router from './router' import { store, key } from './store' import * as Icons from '@element-plus/icons' const app = createApp(App) app.use(store, key) app.use(router) app.mount('#app') // 注册全局组件 Object.keys(Icons).forEach(key =&gt; { app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f03247ab7ba8e59503cf66e1fa0fe225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0efbc603eccb7a23725bd70e33fda0d6/" rel="bookmark">
			hadoop3编译安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.参考资料
官方的https://github.com/apache/hadoop/blob/trunk/BUILDING.txt
2.编译环境
Linux系统：Centos7.2
Jdk版本：jdk1.8
cmake版本：3.19
Hadoop版本：3.1.2
Maven版本：3.6.3
Protobuf版本：2.5
编译工具准备
a.安装依赖
1
yum -y install kernel-devel gcc* glibc-headers gcc-c++ zip-devel openssl-devel git ncurses-devel lzo-devel autoconf libtool automake b. java 和maven 环境
java 和maven 环境用到的太普遍了，这个就不重复了
c.安装protobuf
可以先查看yum上的版本
2.5.0正是所需要的，而不是官方里说的3.x，为什么呢？
直接
1
yum install -y protobufx
自己安装时，以为yum没有protobufx，所以是到github上下载源码编译的GitHub - protocolbuffers/protobuf at v2.5.0
正常解压后只要
1
2
3
4
$ ./configure
$ make
$ make check
$ make install
但你会发现根本没有configure，我们需要执行autogen.sh去生成configure脚本
执行autogen.sh，会发现无法下载gtest-1.5.0.tar.bz2
我们需要自行下载gtest-1.5.0.tar.bz2，
Index of /repo/pkgs/gtest/gtest-1.5.0.tar.bz2/md5/8b2c3c3f26cb53e64a3109d03a97200a
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0efbc603eccb7a23725bd70e33fda0d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aec5f9f6f9fc55b8e156c29f09f220e/" rel="bookmark">
			C语言编程必备技能！小写转大写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，要区分字母的大小写，可以利用ASCII码中大写字母和小写字母之间的转换关系，差值为32，通过这个差值可以将小写字母转换为大写字母。
下面编写程序实现该功能：从键盘输入一个小写字母，按回车键后，程序将该小写字母转换为大写字母，并输出其ASCII值。
程序的算法思想如下：
1. 定义两个字符变量a和b。
2. 从键盘输入一个小写字母，并将其赋给变量a。
3. 将变量a的ASCII码值减去32，并将结果赋给变量b，得到对应的大写字母的ASCII码值。
4. 打印输出转换后的大写字母，并同时输出其ASCII值。
#include &lt;stdio.h&gt; int main() { char a,b; printf("输入一个小写字母:\n"); a=getchar(); b=a-32; printf("转换后的字母为：%c，%d\n",b,b);// C/C++学习交流群；558970390 return 0; } 调试运行结果
当输入小写字母 "c" 时，转换为大写字母及对应的 ASCII 值如下所示：
请输入一个小写字母：
c
转换后的字母为："C"，ASCII 值为 67。
当输入小写字母 "m" 时，转换为大写字母及对应的 ASCII 值如下所示：
请输入一个小写字母：
m
转换后的字母为："M"，ASCII 值为 77。
总结概括：
① 在这个实例中，需要对 ASCII 码有所了解，知道小写字母和大写字母之间的差值为 32。
② "getchar" 函数的作用是从键盘输入一个字符。一般形式为 "getchar()"。通常将输入的字符赋给一个字符变量，例如：char c; 或 c = getchar();
③ 使用 "getchar" 函数时需要注意几个问题：
"getchar" 函数只能接收单个字符，输入数字也将按字符处理。如果输入多于一个字符，只会接收第一个字符。
在使用 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aec5f9f6f9fc55b8e156c29f09f220e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e29e2fbd037028c3cdbe70dd327010/" rel="bookmark">
			C#--使用Quartz实现定时任务的暂停定时、恢复定时、关闭定时等操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#–使用Quartz实现定时任务的暂停定时、恢复定时、关闭定时等操作 基于Quartz3.0版本总结一些quartz定时任务的暂停、恢复、删除等操作。定时任务的暂停、删除等操作主要是基于JobKey或TriggerKey。
一、 暂停Job: //通过JobName以及JobGroup获得JobKey JobKey jobKey = JobKey.jobKey("aaaa" + 1, JOB_GROUP_NAME); try { Scheduler scheduler = schedulerFactoryBean.getScheduler(); scheduler .pauseJob(jobKey); } catch (SchedulerException e) { e.printStackTrace(); } 注：此处暂停job会根据jobkey暂停job及对应的trigger 二、 恢复Job: //通过JobName以及JobGroup获得JobKey JobKey jobKey = JobKey.jobKey("aaaa" + 1, JOB_GROUP_NAME); try { schedulerFactoryBean.getScheduler().resumeJob(jobKey); } catch (SchedulerException e) { e.printStackTrace(); } 三、删除job 方法一： //通过JobName以及JobGroup获得JobKey JobKey jobKey = JobKey.jobKey("aaaa" + 1, JOB_GROUP_NAME); try { schedulerFactoryBean.getScheduler().deleteJob(jobKey); } catch (SchedulerException e) { e.printStackTrace(); } 方法二： //通过triggerName获取TriggerKey TriggerKey aaatrigger = TriggerKey.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41e29e2fbd037028c3cdbe70dd327010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410e96c70bc4728791eb1719d2971694/" rel="bookmark">
			vue3中将后端传来的json文件转成excel下载到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在浏览器中将JSON格式数据以excel文件的形式下载。该组件是基于[this thread] (https://stackoverflow.com/questions/17142427/javascript-to-export-html-table-to-excel)提出的解决方案。支持Vue3.2.25及以上版本使用
重要提示! Microsoft Excel中的额外提示
此组件中实现的方法使用HTML表绘制。在xls文件中，Microsoft Excel不再将HTML识别为本机内容，因此在打开文件之前会显示警告消息。excel的内容已经完美呈现，但是提示信息无法避免，请不要在意！
使用效果： 如果出现下面的提示，点是就行了 官方地址：点我 使用步骤： 1、安装 npm/cnpm/pnpm/yarn 都可以，装下面插件 vue3-json-excel 2、main.js中配置 import vue3JsonExcel from 'vue3-json-excel'; const app = createApp(App); app.component('Vue3JsonExcel', vue3JsonExcel); 3、页面具体使用 template &lt;template&gt; &lt;vue3-json-excel :json-data="json_data" :fields="fields" name="测试111.xls" &gt; &lt;el-button&gt;点我下载&lt;/el-button&gt; &lt;/vue3-json-excel&gt; &lt;/template&gt; ts &lt;script lang="ts" setup&gt; const fields = ref({ '姓名':'name', '年龄':'age', '编号':'num', }); const json_data = ref([ { name:'张三', age:17, num:'~00013', //能解决丢0问题 },{ name:'李四', age:33, num:'00014',//会出现丢失0 }, ]); &lt;/script&gt; 4、 尚存在问题 和vue2的插件vue-json-excel一样，也是有 0 被丢失问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/410e96c70bc4728791eb1719d2971694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef197ec821c287a693905786edb2a4a8/" rel="bookmark">
			并发给数据库带来的问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方↑“追梦 Java”关注，一起追梦！
假设没有事务的隔离性，当两个事务并发地去操作数据库的表或者行的时候，那么会产生什么问题？
1
并发给数据库带来的问题
1、读脏数据
A 事务修改了一个数据（假设 A 从 1 改为 2），B 事务读取 A 事务修改后的数据（B 读取到了 2），但由于某种原因 A 事务撤销了事务（这个数据回滚到 1），此时导致 B 事务读取到的数据不正确（B 认为数据是 2），这就表示 B 事务读取到了脏数据，一般称为脏读。
2、不可重复读
A 事务读取数据后（假设 A 读到了 1），B 事务执行更新操作（B 把 1 改成了 2），然后 B 事务提交（此时数据的值为 2）；然后 A 事务再次读取数据（A 读到了 2），也就是说 A 事务两次读取操作得到了2个结果（第一次是 1，第二次是 2）。说明在一个事务里对同一个数据读取，得到的值不一致，后面的读操作获得了其他它事务提交的结果，这就表示 A 事务不可重复度。
3、幻读
A 事务读取价格小于 10 的产品数据（假设 A 读到了 100 条数据），B 事务往产品表里插了一条价格小于 10 的产品，然后 B 事务提交（此时价格小于 10 的产品有 101 条）；然后 A 事务再次读取价格小于 10 的产品数据（A 读到了 101 条数据），也就是说 A 事务读取到了 B 事务新增的记录（第一次是 100 条，第二次是 101 条）。这就表示 A 事务发生了幻读。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef197ec821c287a693905786edb2a4a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de5bddcb18a95b7f0eb4d2a65ea047fb/" rel="bookmark">
			Jetson Nano的配置&#43;opencv&#43;torch&#43;torchvision（新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于原版有特别特别多问题，我就懒得再去改了，直接出一个新篇
一．烧录 每一个jetson nano用的时候都需要配备一个SD卡用来盛装系统和数据，其中的系统就需要用我们自己的电脑和读卡器进行烧录。
系统前去英伟达下载，链接：Jetson Download Center | NVIDIA Developerhttps://developer.nvidia.com/embedded/downloads
我用的系统名称：Jetson Nano Developer Kit SD Card Image 其他的系统可以根据自己的需求进行挑选
随后将下载的系统烧录到SD卡上（下载的压缩包不需要解压，保持下载原样就好）
烧录的软件为balenaEtcher
烧录完成后就可以插卡准备开机了
注：倘若SD卡原本就有旧系统，插上电脑后可能会跳出十几个甚至几十个磁盘并报错，无需慌张，全部关闭后前往前往磁盘管理进行格式化
参考链接：Jetson-NanoSD卡重新格式化 | 码农家园 (codenong.com)https://www.codenong.com/cs106946176/
建议使用方法1，但是注意别手滑输错磁盘，不然寄。
注：开机时尽量不要连接任何USB接口，否则可能一直报错无法开机，一般是卡在’A start job is running for end-user configureation after initial OEM installation‘
注：假如开机的时候一直卡在英伟达logo界面，就是SD卡读取的问题，关机之后用擦一下SD卡就好（金手指）
二．设置中文 语言在最初初始设置就会让你选择中文，但是并非完整版，完整的中文需要右上角设置——语言支持中下载，进入后提示有部分库未安装，静等安装即可。安装完毕后在原界面向下拉即可看到中文，将其拖到English上面，随后点击应用到所有。
下方还有添加或删除语言按钮，点击后根据中文是否选中进行修改。
（输入法设置）很多人使用ibus，好像确实好用，但是我没用，所以我也不好给出时间步骤，参考链接：Jetson Nano配置与使用（3）中文输入法ibus配置 - 简书 (jianshu.com)https://www.jianshu.com/p/c95167d7d6c3
我使用的是google输入法，倒也还可以，可以根据自己的喜好进行选择，参考链接：Jetson nano安装Google拼音输入法 | 码农家园 (codenong.com)https://www.codenong.com/cs106177082/
注：假如使用的时候不显示文本框，那么可以试试以下代码
killall fcitx-qimpanel sudo apt-get remove fcitx-ui-qimpanel 三．风扇 首先下载驱动，在命令台输入以下指令
git clone https://github.com/Pyrestone/jetson-fan-ctl.git 随后安装
sudo ./install.sh 根据自己的喜好进行参数调整（这边建议不做调整）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de5bddcb18a95b7f0eb4d2a65ea047fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c27f5d9b7769713a31a4c9d6c43219/" rel="bookmark">
			网络精通-GRE-VPN（虚拟专用网）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		396、虚拟专用网络，
应用类型：
①总部与分部之间的互联
②远程出差人员通过VPN拨号的方式访问企业内网；
397、GRE VPN的配置
实验topo:
实验步骤:
分别在企业路由上配置缺省路由，指向运营商：
R6
#
ip route-static 0.0.0.0 0.0.0.0 15.1.1.2
#
R5：
#
ip route-static 0.0.0.0 0.0.0.0 45.1.1.1
#
运营商的路由全部运行OSPF，使得公司总部的公网IP地址可以ping 到分布的公网IP地址；
tips :搭建VPN的首要条件：两个公网IP地址可以互相通信；
VPN搭建：
R5：
#
interface Tunnel0/0/0 指定隧道接口为路由器的G0/0/0口
tunnel-protocol gre 指定隧道协议为GRE协议
source 45.1.1.2 指定隧道院IP地址
destination 15.1.1.1 指定隧道的目的IP地址
#
R6：
#
interface Tunnel0/0/0
tunnel-protocol gre
source 15.1.1.1
destination 45.1.1.2
#
给隧道的两端配上IP地址以及静态路由：
R6：
#
interface Tunnel0/0/0
ip address 192.168.254.1 255.255.255.0 给你隧道配置IP地址
#
ip route-static 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26c27f5d9b7769713a31a4c9d6c43219/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b12ebab99a504427d4696dbbe178d4/" rel="bookmark">
			计算机网络——应用层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章是计算机网络系列文章的第五篇
计算机网络——物理层
计算机网络——数据链路层
计算机网络——网络层
计算机网络——传输层
计算机网络——应用层
序言 计算机网络中的应用层在当今的社会起到了什么作用？
应用层在当今社会有着必不可缺的作用。是协议栈中的最顶层，在处理应用程序之间的通信和数据交换有着相当出众的能力。主要有着网络通信；数据传输和共享；客户端和服务器应用；实时通信；多媒体处理；数据安全和隐私；云计算和Web服务等作用。推动了信息技术的发展和社会的进步。
应用层 应用层是计算机网络协议栈中的最顶层，负责处理应用程序之间的通信和数据交换。它提供了各种协议和服务，使得不同设备和应用程序能够进行网络通信。以下是应用层的一些主要功能和特点：
协议和通信：应用层定义了各种协议，如HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）等，用于不同应用程序之间的通信。这些协议规定了数据的格式、传输方式和交互规则。
用户界面：应用层提供了用户与应用程序之间的接口和交互方式。这包括图形用户界面（GUI）、命令行界面（CLI）、Web页面等。用户可以通过这些界面与应用程序进行交互和操作。
数据表示和编码：应用层负责将数据表示为特定格式，以便应用程序之间进行交换和解释。例如，在Web应用中，数据通常使用HTML、JSON或XML等格式进行表示和传输。
数据存储和访问：应用层提供了数据的存储和访问功能，使得应用程序可以读取、写入和管理数据。这包括数据库访问、文件系统操作、云存储等。
安全和身份验证：应用层提供了安全机制，以保护数据和通信的安全性。这包括加密通信、数字签名、身份验证和访问控制等。常见的安全协议和技术如SSL/TLS、OAuth等就是在应用层实现的。
远程访问和控制：应用层支持远程访问和控制，使得用户可以从远程位置访问和操作其他计算机或设备上的应用程序和资源。远程桌面、SSH（安全外壳协议）等技术就是在应用层提供了这种功能。
分布式计算和协作：应用层支持分布式计算和协作，使得多个应用程序可以在不同计算机上进行协同工作和资源共享。这包括分布式数据库、协同编辑、版本控制等。
总而言之，应用层提供了丰富的功能和服务，使得应用程序能够进行通信、数据交换、安全保护和远程访问等。它在计算机网络和互联网中起着至关重要的作用，推动了各种应用的发展和用户的便利性。
文章目录 序言应用层域名系统DNS域名系统概述互联网的域名结构域名服务器 文件传送协议FTP概述FTP的基本工作原理简单文件传送协议TFTP 远程终端协议TELNET万维网WWW万维网概述统一资源定位符URL超文本传送协议HTTP万维网的文档万维网的信息检索系统博客和微博社交网站 电子邮件电子邮件概述简单邮件传送协议SMTP电子邮件的信息格式邮件读取协议POP3和IMAP基于万维网的电子邮件通用互联网邮件扩充MIME 动态主机配置协议DHCP简单网络管理协议SNMP网络管理的基本概念管理信息结构SMI管理信息库MIBSNMP的协议数据单元和报文 应用进程跨越网络的通信系统调用和应用编程接口几种常用的系统调用 P2P应用具有集中目录服务器的P2P工作方式具有全分布式结构的P2P文件共享程序P2P文件分发的分析在P2P对等方中搜索对象 总结习题 域名系统DNS 域名系统（Domain Name System，DNS）是互联网中的一种分布式命名系统，用于将域名转换为相应的IP地址。它充当了互联网的"电话簿"，通过将易于记忆的域名映射到对应的IP地址，使得人们可以使用方便的域名来访问网站和其他网络资源。
以下是DNS的一些关键功能和特点：
域名解析：DNS的主要功能是将人们熟悉的域名（如example.com）转换为对应的IP地址（如192.0.2.1）。当用户在浏览器中输入一个域名时，浏览器会向本地DNS服务器发送查询请求，本地DNS服务器会依次向其他上层DNS服务器发起查询，直到找到域名对应的IP地址。
分布式系统：DNS是一个分布式系统，它由多个DNS服务器组成，分为多个层次。根DNS服务器、顶级域名服务器、权威域名服务器和本地DNS服务器共同构成了一个层次化的系统。这种分布式结构使得DNS系统具有高可用性和可伸缩性。
缓存和查询优化：DNS服务器会在本地进行查询结果的缓存，以提高查询效率和减轻上层DNS服务器的负载。当一个DNS服务器接收到查询请求时，它首先检查自己的缓存中是否有相应的解析结果，如果有，则直接返回，否则才向上层DNS服务器发起查询。
反向解析：DNS不仅可以将域名解析为IP地址，还可以进行反向解析，将IP地址转换为对应的域名。这对于网络管理员和安全分析人员来说非常有用，可以通过IP地址查找相应的域名和相关信息。
其他记录类型：DNS不仅可以解析域名到IP地址，还可以提供其他类型的记录，如邮件交换记录（MX记录）用于指定邮件服务器，别名记录（CNAME记录）用于指向另一个域名，文本记录（TXT记录）用于存储任意文本信息等。
安全性：DNS也面临一些安全问题，如DNS劫持、DNS污染和DNS重放攻击等。为了提高DNS的安全性，一些安全机制被引入，如DNSSEC（DNS安全扩展）用于验证解析结果的完整性和真实性。
总结而言，域名系统（DNS）在互联网中扮演着关键的角色，将易于记忆的域名转换为相应的IP地址，使得用户可以轻松访问网站和其他网络资源。它是一个分布式系统，具有缓存和查询优化功能，并支持不同类型的记录和反向解析。DNS的安全性也受到越来越多的关注，以保护用户免受各种DNS相关的攻击。
域名系统概述 域名系统（Domain Name System，DNS）是互联网中的一种分布式命名系统，用于将人们可读的域名（例如example.com）映射到对应的IP地址（例如192.0.2.1）。它充当了互联网的"电话簿"，为用户提供了一种方便记忆的方式来访问网站和其他网络资源。
DNS的概述如下：
域名结构：域名是层次化的结构，由多个部分组成，每个部分之间用点号（.）分隔。例如，www.example.com是一个典型的域名，它包含了三个部分：子域名（www）、二级域名（example）和顶级域名（com）。
分布式系统：DNS是一个分布式系统，由多个DNS服务器组成。这些服务器被组织成一个层次化的结构，包括根DNS服务器、顶级域名服务器、权威域名服务器和本地DNS服务器等。每个服务器负责管理一部分域名和相应的解析信息。
域名解析：当用户在浏览器中输入一个域名时，浏览器会向本地DNS服务器发送查询请求。本地DNS服务器首先检查自己的缓存，如果有对应的解析结果，则直接返回给浏览器。如果没有，则本地DNS服务器会向上层DNS服务器发起查询，直到找到域名对应的IP地址，并将解析结果返回给浏览器。
缓存和查询优化：DNS服务器会对解析结果进行缓存，以提高查询效率和减轻上层服务器的负载。当一个DNS服务器接收到查询请求时，它首先检查自己的缓存中是否有相应的解析结果，如果有，则直接返回；如果没有，则才向上层服务器发起查询。这样，可以减少查询延迟并降低网络流量。
其他记录类型：除了将域名解析为IP地址外，DNS还支持其他类型的记录，用于存储不同类型的信息。例如，邮件交换记录（MX记录）用于指定邮件服务器，别名记录（CNAME记录）用于指向另一个域名，文本记录（TXT记录）用于存储任意文本信息等。
安全性：DNS也面临一些安全问题，如DNS劫持、DNS污染和DNS重放攻击等。为了提高DNS的安全性，一些安全机制被引入，如DNSSEC（DNS安全扩展）用于验证解析结果的完整性和真实性。
总体而言，域名系统（DNS）是互联网中重要的基础设施之一，它为用户提供了方便的域名访问方式，并在背后提供了复杂的分布式系统和解析机制。通过DNS，用户可以使用易于记忆的域名来访问网站和其他网络资源，而无需记住复杂的IP地址。
互联网的域名结构 互联网的域名结构是一个层次化的结构，由多个部分组成，每个部分之间用点号（.）分隔。域名结构从右向左逐级递增，从顶级域名开始，逐渐细分为子域名和子子域名。
以下是互联网域名结构的不同级别：
顶级域名（Top-Level Domain，TLD）：顶级域名是域名结构的最高级别，通常表示一个国家、地区或特定类型的组织。例如，.com表示商业组织，.edu表示教育机构，.gov表示政府机构，.cn表示中国等。顶级域名还可以进一步划分为两种类型：
国家顶级域名（Country Code Top-Level Domain，ccTLD）：代表特定国家或地区的顶级域名，如.cn（中国）、.uk（英国）、.de（德国）等。
通用顶级域名（Generic Top-Level Domain，gTLD）：代表特定类型的组织或领域的顶级域名，如.com（商业）、.org（非营利组织）、.net（网络）等。
二级域名（Second-Level Domain，SLD）：二级域名位于顶级域名之下，是域名结构的下一级别。它可以是注册人选择的自定义名称，用于标识特定的组织、企业、个人或网站。例如，在域名example.com中，"example"就是二级域名。
子域名（Subdomain）：子域名位于二级域名之下，用于进一步细分和组织域名空间。子域名可以根据需要任意添加，并以点号分隔。例如，在域名www.example.com中，"www"就是子域名。
子子域名（Sub-subdomain）：子子域名位于子域名之下，用于进一步细分域名空间。同样地，子子域名可以根据需要任意添加，并以点号分隔。
域名结构的层次化和分层特性使得域名可以唯一地标识互联网上的不同网站和资源。用户可以通过输入域名来访问特定的网站，而无需记住复杂的IP地址。域名系统（DNS）负责将域名解析为对应的IP地址，使得互联网的域名系统能够正常运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39b12ebab99a504427d4696dbbe178d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99802e1277c030d43111d5ef7988ba80/" rel="bookmark">
			python问题汇总——pycharm查找不到安装的库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm查找不到安装的库 1. 安装python和pycharm时候出现的 1. 安装python和pycharm时候出现的 1.我将python安装在了C盘，pycharm安装在了D盘。
在cmd命令提示行输入
python -m pip list 然后显示了已经安装的python库
但是pycharm中总是找不到安装的库，例如下所示：
查看已经安装的库，发现没有和安装在C盘时候里面的库一样。
原因：建立工程时候选择的python并不是你所安装的哪一个。
我们先找到在C盘安装的库的具体位置：
以pygame包为例子：
输入：
pip show pygame cmd中显示如下：
在C盘中找到对应位置，也能看到python解释器的位置：
可以看到包都安装好了。
接着我们去pycharm。
点击settings-&gt;python interpreter
可以看到此处的python 3.9 与前面C盘里安装的位置不一样。
点击Add interpreter 然后添加前面C盘对应的位置，此时有两个可选
选择另个一即可显示很多已经安装的包：
然后选择即可实现：
此时不在有错误出现。
然后我去看了看第一个对应的python.exe
如图时间日期，是以前我装python时候安装遗留下来的文件，当时建立工程时候，没有注意到选错了。导致纠结了很久。可以直接把以前的文档删除了就行。
然后建立新工程：
建立新工程：
另外：建立工程时候注意勾选 inherit globol site-packages，这样pip安装的包才能使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a5e2f8acb286ae70e1fb2a3bb6e1a4/" rel="bookmark">
			Ubuntu 系统使用问题解决记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双系统安装：
1.先装好windows；
2.在windows上下载ubuntu 的iso镜像，用UltraISO制成U盘启动盘；
3.开机按F2进入BIOS，设置启动顺序，将U盘（可能是USB HDD 或 USB key）调到最上面。如果从BIOS里面读不出U盘内容，则设置了也不会起效。关机再启动可能会好。注意：是关机，再启动，而不是重启；
4.如果从U盘启动了，接下来顺理成章了，安装Ubuntu。注意：设置用户名的时候，电脑会自动填充主机名，根据喜好修改主机名。
常见问题：
1.能ping通百度，apt-update 却失败：无法识别 mirrors.ubuntu.com 之类
原因：DNS没配好
解决方法：
修改 /etc/network/interfaces，最后加上一行：
dns-nameservers 114.114.114.114 8.8.8.8
（注：网上诸如修改 /etc/resolvconf/resolv.conf.d/base 之类，在我的Ubuntu16上无效）
打开 软件和更新，“下载自”选择中科大的源
2.firefox无法启动
原因：～/.mozilla 的所有者为root
解决方法：
cd
sudo chown -hR chenjun:chenjun .mozilla
3.输入法问题
能切换到中文输入法，输出来的却是英文
解决方法：
打开 系统设置— 》语言支持，键盘输入方式系统选择 ibus。
安装搜狗拼音输入法：
sudo add-apt-repository ppa:fcitx-team/nightly
sudo apt-get update
sudo apt-get install fcitx
sudo dpkg -i sogoupinyin_2.0.0.0066_i386.deb
其中 .deb 文件从搜狗拼音官方网站下载，根据自己的系统选择32还是64位的。
4.update 失败，"Some index files failed to download. They have been ignored"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61a5e2f8acb286ae70e1fb2a3bb6e1a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2adb86fbc248c49a73edd3565816ea0f/" rel="bookmark">
			精心整理20&#43;Python实战案例(附源码、数据)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近小编认真整理了20+个基于python的实战案例，主要包含：数据分析、可视化、机器学习/深度学习、时序预测等，案例的主要特点：
提供源码：代码都是基于jupyter notebook，附带一定的注释，运行即可
数据齐全：大部分案例都有提供数据，部分案例使用内置数据集
数据统计分析 基于python和第三方库进行数据处理和分析，主要使用pandas、plotly、matplotlib等库，具体案例：
电子产品（手机）销售分析： （1）不同内存下的销量(代码片段)
nei_cun = color_size["Number_GB"].value_counts().reset_index() nei_cun.columns = ["Number_of_GB","Count"] # 重命名 nei_cun["Number_of_GB"] = nei_cun["Number_of_GB"].apply(lambda x: str(x) + "GB") fig = px.pie(nei_cun, values="Count", names="Number_of_GB") fig.show() （2）不同闪存Ram下的价格分布（代码片段）
fig = px.box(df, y="Sale Price",color="Ram") fig.update_layout(height=600, width=800, showlegend=False) fig.update_layout( title={ "text":'不同&lt;b&gt;闪存&lt;/b&gt;下的价格分布', "y":0.96, "x":0.5, "xanchor":"center", "yanchor":"top" }, xaxis_tickfont_size=12, yaxis=dict( title='Distribution', titlefont_size=16, tickfont_size=12, ), legend=dict( x=0, y=1, bgcolor='rgba(255, 255, 255, 0)', bordercolor='rgba(2, 255, 255, 0)' ) ) fig.show() 7万条餐饮数据分析 fig = px.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2adb86fbc248c49a73edd3565816ea0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/780b2e22253f4b5d1a667e86a4b93902/" rel="bookmark">
			【毕业设计/课程设计】基于微信小程序的在线学习系统设计与实现（源码&#43;文章） 含Java Web管理端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开发工具 1、数据库：MySQL
2、开发工具
微信端：微信开发工具
管理后端：Idea、Eclipse、MyEclipse等Java开发工具均可
3、服务器：Tomcat系列均可
技术简介 微信端采用微信开发者工具开发，管理后端采用Java语言，MySQL数据库，开发框架是Springboot
摘要 从90年代末开始，计算机技术方兴未艾，犹如龙卷风般风靡全球，颠覆了各行各业的运营管理模式，无论是吃穿，还是住行，都逐渐渗透到我们日常生活的方方面面。时代的进步，教育也越来越受到国家的重视，对教育的事业发展投入也越来越大，而移动互联网技术发展十分迅速，建立一款功能丰富，设计美观，能够进行个性化服务的语文学习微信小程序，无疑是给要进行自行学习的学习者带来了极大的便捷。学习者不再局限于登录电脑端的网页进行语文的学习与查询了，可以直接登录微信小程序，在手机上就可以实现单词的复习与打卡等，让学习更加自由化、灵活化。
该语文学习微信小程序的设计与实现，首先基于背景以及研究现状的调研分析后，提出具有针对性的建议，利用小程序开发技术，后台使用Java技术，Spring Boot框架，在数据存储上，使用MySQL数据库，并结合SuperMemory算法进行词汇背诵时间的计算，满足学习者的语文词汇学习的个性化需求，将其一共划分为单词记背，单词复习，错题查看，评语查看以及后台管理等功能，而每个功能又包括不同的子功能，从而共同构建成一个完整的语文学习生态圈。经过一系列的开发，该小程序具有一定的可行性，能够稳定而流畅地运行，并且仍然保留了界面的美观度。
关键字：语文学习微信小程序；Java；MySQL；Spring Boot
文章目录 第一章 绪论
1.1课题研究背景
1.2课题研究意义
1.3课题研究内容及目标
第二章 相关技术介绍与可行性分析
2.1 相关技术介绍
2.2 可行性分析
第三章 需求分析
3.1需求分析的定义及任务
3.2系统功能需求
3.3 非功能需求分析
第四章 系统设计
4.2系统技术架构设计
4.2系统功能架构设计
4.3系统数据库设计
4.4系统流程设计
第五章 系统实现
5.1小程序用户模块实现
5.2后台功能模块实现
第六章 系统测试
6.1测试目的与方法
6.2测试计划
6.3测试用例
结 论
谢 辞
参考文献
功能结构图 系统截图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61092a46ff43c99552434280681c7199/" rel="bookmark">
			减少跨国传输大文件所需时间的技巧与工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今的数字化时代，人们在生活和工作中经常需要传输大文件，但传输大文件时往往会遇到很多困难，比如传输时间过长、传输速度慢等。为了解决这些困难，下面将分享一些缩短跨国传输大文件所需时间的方法和工具。
一、选用适合的网络传输协议 在传输文件时，最先要考虑的就是网络传输协议。不同的网络传输协议有不同的优劣，因此我们应该根据具体情况选用适合的网络传输协议。
目前比较常用的网络传输协议包括 FTP、HTTP、SCP 以及 BitTorrent 等。这些协议虽然可以用于传输文件，但都有各自的局限性。FTP 和 HTTP 协议适用于小文件的传输，但对于大文件的传输效率很低，而且容易受到网络波动和防火墙的影响。SCP 协议虽然可以加密传输文件，但也会消耗更多的 CPU 资源和带宽，导致传输速度下降。BitTorrent 协议可以利用 P2P 技术分发文件，但也需要依赖种子文件和足够多的节点，而且存在版权和安全的风险。
如果传输的文件较大，建议使用镭速传输协议。镭速（可以申请免费试用）自主开发的传输协议，主要是针对大文件传输，提供一站式传输解决方案。镭速传输协议可以自动选择最优的线路和节点，实现端到端的加密和断点续传，保证传输的安全性和稳定性。镭速传输协议还可以根据网络状况动态调整窗口大小和重发策略，有效避免拥塞和丢包，提高传输效率。镭速传输协议可以支持多种场景和平台，无论是 PC、移动设备还是服务器，都可以轻松实现大文件的快速传输。
二、使用分片传输技术 在传输大文件时，经常会出现传输不稳定或传输失败的问题。为了避免这些问题，可以采用分片传输技术。通过将大文件分成多个小文件进行传输，不仅能够降低传输过程中的数据丢失和传输失败的风险，还能够提高传输速度。同时，在接收端将这些小文件拼接成一个完整的文件即可。
三、使用压缩技术 在传输大文件时，文件的大小会直接影响到传输时间和速度。因此，为了减少文件的大小，我们可以采用文件压缩技术。目前比较热门的压缩格式有 ZIP、RAR、7z 等。通过压缩这些大文件可以极大地减小文件的大小，在传输过程中不仅能够提高传输速度，还能够节省传输带宽。
四、使用 P2P 网络传输 除了常规的网络传输协议外，我们还可以采用 P2P 网络传输方式进行文件传输。P2P 网络传输方式不仅能够提高传输速度，还可以通过多个对等节点进行数据交换，从而缩短传输时间。
然而，P2P 网络传输方式也有一些缺点。首先，P2P 网络需要依赖于足够多的节点才能保证数据分发的效率，如果节点数量不够或者节点质量不高，就会影响传输的速度和稳定性。其次，P2P 网络存在一定的安全隐患，因为数据在传输过程中会被多个节点拷贝和存储，如果这些节点被黑客攻击或者泄露数据，就会造成数据的泄密和损失。最后，P2P 网络可能会引起版权和法律的问题，因为很多 P2P 网络上分发的文件是没有经过授权的，如果涉及到版权保护的内容，就可能会遭到版权方的投诉和追究。
综上所述，缩短跨国传输大文件所需时间的方法和工具主要包括选用适合的网络传输协议、使用分片传输技术、使用压缩技术以及使用 P2P 网络传输等多种方式。其中，镭速传输协议是一种专门针对大文件传输的高效、安全、稳定的解决方案，可以在不需要使用加速器和云服务商的情况下，实现大文件的快速传输。如果你需要进行跨国传输大文件，可以根据具体情况选择适合自己的方法和工具，以获得更快、更安全的文件传输体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e3e2e3208b47aae8955f8a13050636/" rel="bookmark">
			vue3&#43;vite的项目中实现右键事件的神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： vue3+vite的项目中实现右键事件的神器：@imengyu/vue3-context-menu
实现效果： 使用步骤： 1、安装 npm/cnpm/pnpm/yarn 都可以，装上下面插件 @imengyu/vue3-context-menu 2、main.js中配置引入 import '@imengyu/vue3-context-menu/lib/vue3-context-menu.css'; import ContextMenu from '@imengyu/vue3-context-menu'; const app = createApp(App); app.use(ContextMenu); 3、页面上使用： template &lt;ul v-else class="list-inlin text-white bg-light p-1 m-2" style="border-radius: 2px;" @click="handleDownload()" @contextmenu.stop="onContextMenu($event)" &gt; //因为有其他的点击事件，.stop是必须的，不然冒泡了 ... ts中 &lt;script lang="ts" setup&gt; import ContextMenu from '@imengyu/vue3-context-menu'; const onContextMenu = (e: MouseEvent) =&gt; { ContextMenu.showContextMenu({ x: e.x, y: e.y, items: [ { label: '转发', onClick: () =&gt; { forwardingMessage(); }, }, { label: '引用', onClick: () =&gt; { alert('引用') }, }, { label: '撤回', onClick: () =&gt; { alert('撤回') }, }, ], }); }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba424bb3cf8026ef204ee8b261fb94e/" rel="bookmark">
			OBCP理论考题型易错点汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认超时类（单位都是微妙）：
单条 SQL 执行超时时间，由租户变量 ob_query_timeout控制。单位是微秒，默认是10秒。
单个事务的空闲超时时间是多少，由租户变量 ob_trx_idle_timeout控制。单位是微秒，默认120秒。
事务超时时间，由租户变量 ob_trx_timeout控制。单位是微秒，默认100秒。
备份恢复
日志归档是定期备份到备份目的端的，只需要用户发起一次 alter system archivelog，日志备份就会在后台持续进行。
错误码：
0001-3999 mysql错误码
大于4000是OB特有错误码
视图：
1、确定是通过绑定的 Outline 生成的计划后，需要确定生成的计划是否符合预期，可以通过查询 “gvKaTeX parse error: Expected group after '_' at position 64: …形状，具体查看方式可参考 2、_̲_all_rootservic…plan_cache_plan_stat和gvKaTeX parse error: Expected group after '_' at position 21: …udit可以排查慢sql 4、_̲_all_zone,__all…memory和__all_virtual_memory_info记录内存各模块使用情况，gv$memstore记录各租户memstore内存使用情况
8、__all_virtual_server_stat查看OB集群内各个服务器已分配的资源用量
参数/变量类：
1、merge_check_interval：每个 Zone 的合并进度检查间隔。
2、trace_log_slow_query_watermark 用于设置查询的执行时间阈值，如果查询的执行时间超过该阈值，则被认为是慢查询，慢查询的追踪日志会被打印到系统日志中。
3、enable_sql_audit和trace_log_slow_query_watermark不属于变量
负载均衡类：
1、租户级的 primary_zone 不能为空，如果创建时未指定 primary_zone，默认填写成 RANDOM，表示各个 Zone 优先级相同
状态类：
1、注意停止observer的状态也是active，但是stop_time&gt;0
2、zone的状态只有active和inactive，删除后是无状态
OBProxy类：
1、一台机器上可以部署多个OBproxy，但是需要指定不同的端口
2、生产环境下，可以通过config url启动，或者守护进程
3、测试模式下，通过rslist启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba424bb3cf8026ef204ee8b261fb94e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/675d540a62bd0ea6b7ef64e64d3843f6/" rel="bookmark">
			乌班图vscode头文件设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乌班图vscode头文件设置 文件结构
2. 按快捷键：Ctrl + Shift + P 选择–&gt;C/C++:Edit Configurations(JSON)
3.在红色部分添加头文件路径 其中 ${workspaceFolder} 应该为当前工作路径。
4.在tasks.json里面红色区域添加头文件路径和 .cpp文件路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0b3fe756f813e5cef009bffc6cbb3d/" rel="bookmark">
			基于Python的简易评论区抽奖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言引入模块获取博客评论抽取用户程序入口效果 总结最后 前言 博主空空star主页空空star的主页 大家好，我是空空star，本篇给大家分享一下《基于Python的简易评论区抽奖》。
引入模块 import random import requests 获取博客评论 size设置为1000应该够了，不够的话依据实际情况调整。
def comment_list(username,article_id): url = f'https://blog.csdn.net/phoenix/web/v1/comment/list/{article_id}?page=1&amp;size=1000' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17763', 'Cookie': f'UserName={username}' } res = requests.get(url, headers=headers) comments = res.json()['data']['list'] comment_dicts = [] for comment in comments: if comment['info']['parentId'] == 0: content = comment['info']['content'] userName = comment['info']['userName'] nickName = comment['info']['nickName'] comment_dict = { 'userName': userName, 'nickName': nickName, 'content': content } comment_dicts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab0b3fe756f813e5cef009bffc6cbb3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154eac2703859628cb6ae35f5a9d766a/" rel="bookmark">
			【mysql】聚簇索引和非聚簇索引（B树和B&#43;树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主简介：想进大厂的打工人博主主页：@xyk:所属专栏: mysql 目录
一、索引分类
二、索引的数据结构
2.1 B树：改造二叉树
2.2 B+树：改造B树
三、Mysql索引实现—InnoDB引擎
3.1 主键索引（聚簇索引）
3.2 辅助索引（非聚簇索引）
3.3 避免回表
3.4 覆盖索引
一、索引分类 索引一般可以分为以下几类：
主键索引：主键索引是一种特殊的索引类型，它是用于唯一标识每一行数据的索引，每个表只能有一个主键索引，索引列中的值必须是唯一的，不允许有空值。
复合索引：复合索引也叫多列索引或联合索引，它是包含多个列的索引类型，能够加速多列查询和排序操作。需要遵循最左前缀匹配原则（最左匹配原则）
普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。
唯一索引：唯一索引是用来保证列的唯一性的索引，一个表可以有多个唯一索引。比如说，因为人有可能同名，所以同一个姓名在同一个“员工个人资料”数据表里可能出现两次或更多次。索引列中的值必须是唯一的，但是允许为空值。
全文索引：全文索引是一种用于全文搜索的索引类型，能够对文本数据进行快速的模糊搜索和关键字搜索。只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。
哈希索引：哈希索引是基于哈希表实现的索引类型，能够对等值查询进行高效的处理，但不支持范围查询和排序，MySQL 中 Memory 引擎中支持哈希索引。
二、索引的数据结构 Hash表
Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的方式存储数据。我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。
2.1 B树：改造二叉树 MySQL的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，磁盘IO操作非常耗时，所以我们优化的重点就是尽量减少磁盘IO操作。访问二叉树的每个结点就会发生一次IO，如果想要减少IO操作，就需要降低树的高度。
假如key为bigint=8字节，每个节点有两个指针，每个指针为4个字节，一个节点占用的空间16个字节（8+4*2=16）。
因为在MySQL的InnoDB存储引擎一次IO会读取的一页（默认一页16K）的数据量，而二叉树一次IO有效数据量只有16字节，空间利用率极低。为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k/16=1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000=1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。
这种数据结构我们称为B树，B树是一种多叉平衡查找树，如下图主要特点：
B树的节点中存储着多个元素，每个内节点有多个分叉。节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。父节点当中的元素不会出现在子节点中。所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。 举个例子：
假如我们查询值等于10的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块5。
第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，10&lt;15，走左路，到磁盘寻址磁盘块2。
第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7&lt;10，到磁盘中寻址定位到磁盘块5。
第三次磁盘IO：将磁盘块5加载到内存中，在内存中从头遍历比较，10=10，找到10，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。
相比二叉平衡查找树，在整个查找过程中，虽然数据的比较次数并没有明显减少，但是磁盘IO次数会大大减少。同时，由于我们的比较是在内存中进行的，比较的耗时可以忽略不计。B树的高度一般2至3层就能满足大部分的应用场景，所以使用B树构建索引可以很好的提升查询的效率。
过程如图：
看到这里你一定觉得B树很理想了，但是B树不支持范围查询的快速查找，如果我们想查询15-30之间的数据，查到15之后，我们还要返回根节点重新遍历查找下一个数据，直到全部遍历找到。
如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。
2.2 B+树：改造B树 B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于非叶子节点是否存储数据的问题
B树：非叶子节点和叶子节点都会存储数据。B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。 范围查询：
假如我们想要查找9和26之间的数据。查找路径是磁盘块1-&gt;磁盘块2-&gt;磁盘块6-&gt;磁盘块7。
首先查找值等于9的数据，将值等于9的数据缓存到结果集。这一步和前面等值查询流程一样，发生了三次磁盘IO。查找到15之后，底层的叶子节点是一个有序列表，我们从磁盘块6，键值9开始向后遍历筛选所有符合筛选条件的数据。第四次磁盘IO：根据磁盘6后继指针到磁盘中寻址定位到磁盘块7，将磁盘7加载到内存中，在内存中从头遍历比较，9&lt;25&lt;26，9&lt;26&lt;=26，将data缓存到结果集。主键具备唯一性（后面不会有&lt;=26的数据），不需再向后查找，查询终止。将结果集返回给用户。 B+树的节点中可存N个key，N个key划分出N个区间，树的高度是相对矮的。所有父节点都会重复出现在子节点中，从左到右依次递增非叶子结点只起索引作用， 叶子结点包含信息。非叶子结点可能在内存中缓存所有的叶子结点都位于最后一层，叶节点之间首尾连接，所有key值都在子节点中存在，且最大为key MySQL的索引就采用了B+树的数据结构。
三、Mysql索引实现—InnoDB引擎 3.1 主键索引（聚簇索引） 聚集索引：指索引项的排序方式和表中数据记录排序方式一致的索引。聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。
每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。
除聚簇索引之外的所有索引都称为辅助索引。在中InnoDB，辅助索引中的叶子节点存储的数据是该行的主键值。在检索时，InnoDB使用此主键值在聚簇索引中搜索行记录。
select * from user_innodb where id = 28; 先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路。（1次磁盘IO）将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索。（1次磁盘IO）检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28=28。查找到值等于28的索引项，直接可以获取整行数据。将改记录返回给客户端。（1次磁盘IO）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/154eac2703859628cb6ae35f5a9d766a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fcf9fd374024d66225fb3467ff047bf/" rel="bookmark">
			【MATLAB 】 VMD-ARIMA联合时序预测算法，科研创新优选算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有意向获取代码，请转文末观看代码获取方式~
1 VMD分解算法 VMD 分解又叫变分模态分解，英文全称为Variational Mode Decomposition。
VMD是一种新型的信号分解方法，它是通过使用变分推断方法将信号分解为一组局部振动模式，每个模式包含多个频率组件。VMD的主要步骤如下：
将原始信号进行多次低通滤波，得到多个频带信号。
对每个频带信号进行变分推断，得到该频带信号的局部振动模式。
将所有频带信号对应的局部振动模式相加，得到原始信号的 VMD 分解。 VMD 分解具有以下优点：能够自动提取信号的局部特征，避免了传统分解方法中需要手动选择基函数的问题；能够处理非线性和非平稳信号，并且不会产生模态重叠的问题。因此，VMD 在信号处理、图像处理和模式识别等领域也得到了广泛的应用。
关于简短的代码视频教程均可关注B站、小红书、知乎同名账号（Lwcah）观看教程~
MATLAB 信号分解第七期-VMD 分解:
信号分解全家桶详情请参见：
2 ARIMA时序预测算法 ARIMA（Autoregressive Integrated Moving Average）模型是一种基于时间序列分析的预测模型，可以用于分析和预测具有时间依赖性和随机性的数据。ARIMA 模型最初是由 Box 和 Jenkins 等人于 1976 年提出的，是一种广泛使用的时间序列模型，被用于生产和金融等领域的数据预测。 ARIMA 模型的核心思想是对时间序列数据进行差分，使得序列变得平稳，然后通过自回归（AR）和移动平均（MA）的组合来建立模型，并利用该模型进行预测。ARIMA 模型中的“AR”表示自回归，即当前数据与前面若干时刻的数据相关；“I”表示差分，即对数据进行差分使其平稳；“MA”表示移动平均，即当前数据与前面若干时刻的误差相关。 ARIMA 模型的建立过程包括模型识别、参数估计和模型检验三个步骤。在模型识别阶段，需要确定 ARIMA 模型的阶数和差分次数；在参数估计阶段，需要对模型进行参数估计；在模型检验阶段，需要对模型进行检验并判断模型的预测精度是否满足要求。 ARIMA 模型的优点是可以充分利用时间序列数据的历史信息进行预测，能够适应多种不同类型的时间序列数据，并且模型具有较好的解释性。但是 ARIMA 模型也有一些缺点，如对于非平稳的时间序列数据需要进行差分处理，同时模型的参数估计过程较为繁琐。
MATLAB | 时间序列预测 | ARIMA 预测模型:
5 种时序预测方案全家桶详情请参见：
3 VMD-ARIMA联合时序预测算法 接下来详细介绍一下最新的 VMD-ARIMA 联合时序预测算法的原理和思路。
信号分解可以将原始数据分解为 N 层 imf 分量，然后本研究对每层的 imf 分量展开 ARIMA 时序预测，并将预测后的 imf 分量的预测值进行重构，即可得到 VMD-ARIMA 联合时序预测值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fcf9fd374024d66225fb3467ff047bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e431c6e8ade0f72df629e459d73c8861/" rel="bookmark">
			集合set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # set集合 set1 = {1, 2, 3, 4, 5, 6} set2 = {4, 5, 6} # set1.add(7) # set1.discard(3) print(set1) # 取交集 print(set1.intersection(set2)) # 取没有的集合 print(set1.difference(set2)) # 判断是否子集 print(set2.issubset(set1)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2be77058d18f3b74c92b66052585ad/" rel="bookmark">
			白嫖国内算力资源，AIStudio。谁不想完成一次算法竞赛的结果提交呢！paddledet和mmdet真的很像，上手很快
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑区 Markdown Cell，是Notebook中文本编辑单元，通过在Markdown Cell中输入Markdown格式的文本，可以编写文字教程说明.
命令/编辑模式
绿色代表块内容可编辑状态-编辑模式（比如输入文字），蓝色代表块可操作状态-命令模式(预览md展示样式)，编辑模式和命令模式之间可以用Esc和Enter来切换。 编辑Cell 支持插入公式、表格、图片、音乐、视频、网页等. 相关Markdown用法可以参考Markdown官网.
常用快捷键操作
模式模式快捷键(Windows)命令模式 (Esc切换)运行块Shift-Enter命令模式在下方插入块B命令模式在上方插入块A命令模式在上方插入块dd命令模式切换到编辑模式Enter编辑模式 (Enter切换)运行块Shift-Enter编辑模式缩进Ctrl-]编辑模式取消缩进Ctrl-[编辑模式注释Ctrl-/编辑模式函数内省Tab Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本。命令模式，键盘输入运行程序命令。
Enter : 转入编辑模式 Shift-Enter : 运行本单元，选中下个单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在其下插入新单元 Y : 单元转入代码状态 M :单元转入markdown状态 R : 单元转入raw状态 1 : 设定 1 级标题 2 : 设定 2 级标题 3 : 设定 3 级标题 4 : 设定 4 级标题 5 : 设定 5 级标题 6 : 设定 6 级标题 Up : 选中上方单元 K : 选中上方单元 Down : 选中下方单元 J : 选中下方单元 Shift-K : 扩大选中上方单元 Shift-J : 扩大选中下方单元 A : 在上方插入新单元 B : 在下方插入新单元 X : 剪切选中的单元 C : 复制选中的单元 Shift-V : 粘贴到上方单元 V : 粘贴到下方单元 Z : 恢复删除的最后一个单元 D,D : 删除选中的单元 Shift-M : 合并选中的单元 Ctrl-S : 文件存盘 S : 文件存盘 L : 转换行号 O : 转换输出 Shift-O : 转换输出滚动 Esc : 关闭页面 Q : 关闭页面 H : 显示快捷键帮助 I,I : 中断Notebook内核 0,0 : 重启Notebook内核 Shift : 忽略 Shift-Space : 向上滚动 Space : 向下滚动 编辑模式 ( Enter 键启动)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b2be77058d18f3b74c92b66052585ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e52941fc28354c266524cb7e36dc910/" rel="bookmark">
			UnicodeEncodeError: ‘charmap‘ codec can‘t encode characters in position 0-1: character maps to ＜unde
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用vc code,编辑python对数据进行入库时,出现如下错误:
UnicodeEncodeError: 'charmap' codec can't encode characters in position 0-1: character maps to &lt;undefined&gt; 解决方法,在sql.py中,或者是链接数据库时,添加:最后增加一个 ： charset="utf8" 就好了
database = MySQLdb.connect (host="localhost", user = "root", passwd = "root", db = "tpyuyue",charset="utf8")
如果是其他情况出现的,可使用:
create_engine('mysql+mysqldb://USER:@SERVER:PORT/DB?charset=utf8', encoding='utf-8') 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/111/">«</a>
	<span class="pagination__item pagination__item--current">112/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/113/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>