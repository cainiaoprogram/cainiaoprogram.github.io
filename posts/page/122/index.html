<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a87fa2117fed14f4b4c0454af0d590/" rel="bookmark">
			STM32CubeMx之硬件SPI驱动W25Q64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32CubeMx之硬件SPI驱动W25Q64 1.SPI简介 SPI是串行外设接口（Serial Peripheral Interface）的缩写，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，越来越多的芯片集成了这种通信协议。
SPI：高速同步串行口。是一种标准的四线同步双向串行总线，是串行外围设备接口。是Motorola首先在其MC68HCXX系列处理器上定义的。SPI接口主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。
该接口一般使用4条线：串行时钟线（SCLK）、主机输入/从机输出数据线MISO、主机输出/从机输入数据线MOSI和低电平有效的从机选择线SS（有的SPI接口芯片带有中断信号线INT、有的SPI接口芯片没有主机输出/从机输入数据线MOSI）。
SPI根据时钟极性(CPOL)和时钟相位(CPHA)的不同，能够产生4时钟时序。时钟极性(CPOL)控制时钟线空闲电平状态，时钟相位(CPHA)用来控制数据采样极性。
模式0：CPOL=0,CPHA=0
时钟线空闲电平为低电平，第一个边沿采样数据，第二个边沿发送数据；
模式1：CPOL=0,CPHA=1
时钟线空闲电平为低电平，第一个边沿发送数据，第二个边沿采样数据；
模式2：CPOL=1,CPHA=0
时钟线空闲电平为高电平，第一个边沿采样数据，第二个边沿发送数据；
模式3：CPOL=1,CPHA=1
时钟线空闲电平为高电平，第一个边沿发送数据，第二个边沿采样数据；
2 硬件接口 CPU：STM32F103ZE 屏幕：3.5寸TFTLCD屏 Flash： W25Q64(SPI方式) 软件平台： STM32CubeMx 2.1 W25Q64简介 W25Q64(64M-bit)，W25Q16(16M-bit)和W25Q32(32M-bit)是为系统提供一个最小的空间、引脚和功耗的存储器解决方案的串行Flash存储器。25Q系列比普通的串行Flash存储器更灵活，性能更优越。基于双倍/四倍的SPI，它们能够可以立即完成提供数据给RAM，包括存储声音、文本和数据。芯片支持的工作电压2.7V到3.6V，正常工作时电流小于5mA，掉电时低于1uA。所有芯片提供标准的封装。
W25Q64/16/32由每页256字节组成。每页的256字节用一次页编程指令即可完成。每次可以擦除16页(1个扇区)、128 页(32KB块)、256页(64KB块)和全片擦除。
W25Q64的内存空间结构：一页256字节，4K(4096字节)为一个扇区，16个扇区为1块，容量为8M字节,共有128个块,2048个扇区。
W25Q64可擦写周期至少10万次，数据保存20年。
W25Q64驱动方式为SPI，支持SPI总线的工作模式0(0，0)和3( 1，1)。模式0和模式3。
2.2 硬件接口 引脚说明CS片选(低电平选中) PB12SPI2_MISO主机输入从机输出PB14SPI2_MOSI主机输出从机输入PB15SPI_SCK时钟线PB13 2.3 软件设置 SPI2配置:
NSS引脚配置：
3 代码生成 3.1 SPI初始化 SPI配置信息可参考STM32中文参考手册第23.5.1SPI控制寄存器小结。
3.2 SPI读写一字节函数 uint8_t SPI2_WROneByte(uint8_t data) { uint8_t dat_rx=0; HAL_SPI_TransmitReceive(&amp;hspi2,&amp;data,&amp;dat_rx,1,100); return dat_rx; } 3.3 W25Q64 编程 3.3.1 读取W25Q64制造商/芯片ID 示例代码：
/*获取W25Q64设备ID*/ uint16_t W25Q64_GetDeviceID(void) { uint16_t id; W25Q64_CS(0);//选中W25Q64 SPI2_WROneByte(0x90);//发送指令0x90 //发送24位地址 SPI2_WROneByte(0); SPI2_WROneByte(0); SPI2_WROneByte(0); id=SPI2_WROneByte(0xff);//制造商ID:0xef id&lt;&lt;=8; id|=SPI2_WROneByte(0xff);//设备ID:0x16 W25Q64_CS(1);//取消选中 return id; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a87fa2117fed14f4b4c0454af0d590/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c044b44a84c316efac6f0c691c368e4/" rel="bookmark">
			Android Studio直接install系统签名的apk到设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 准备文件 1.1 获取platform.pk8和platform.x509.pem 在Android源码的build/target/product/security/目录下找到文件platform.pk8和platform.x509.pem，复制到Linux下新建的signature文件夹下。
1.2 获取signapk.jar 在Android源码的out/host/linux-x86/framework/目录下找到文件signapk.jar，复制到Linux下signature目录下。
2.生成签名秘钥 上述文件都放到Linux的signature目录下，则在该目录下依次执行以下指令，就可以在同一目录下生成系统签名platform.keystore。
利用platform.pk8文件生成一个名为shared.priv.pem的中间文件 openssl pkcs8 -in platform.pk8 -inform DER -outform PEM -out shared.priv.pem -nocrypt 利用platform.x509.pem文件生成另一个名为shared.pk12中间文件 openssl pkcs12 -export -in platform.x509.pem -inkey shared.priv.pem -out shared.pk12 -name platform 这一步，会让输入密码
Enter Export Password: android12
Verifying - Enter Export Password: android12
生成秘钥platform.keystore keytool -importkeystore -deststorepass android12 -destkeypass android12 -destkeystore platform.keystore -srckeystore shared.pk12 -srcstoretype PKCS12 -srcstorepass android12 -alias platform 3. Android Studio中使用该系统签名 把第二步生成的platform.keystore系统签名复制到window 上任意目录即可。
3.1 Generate Signed Bundle or APK 这样就可以打包系统签名的apk了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c044b44a84c316efac6f0c691c368e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/960d6eb2c1303d08b1c05c3505efd981/" rel="bookmark">
			vue 文件流下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tool.js （用来存放工具函数）
import axios from 'axios' export const downloadFile = (method, url, config, fileName) =&gt; { let _data = null let _params = null if (method === 'GET' || method === 'get') { _params = config.params } else { _data = config.data } return axios({ url, method, params: _params, data: _data, responseType: 'blob', headers: { // 'X-Token': localStorage.getItem('token') || '', "X-Nideshop-Token" : window.sessionStorage.getItem('token') }, }) .then(res =&gt; { console.log(res) const str = res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/960d6eb2c1303d08b1c05c3505efd981/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68c69ff5a763ef238980d21e47787d2/" rel="bookmark">
			R语言随机森林分析全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言随机森林全流程分析 引言 再2023年6月，如果你以Random Forest为关键词在Google Scholar检索，时间降序。
image-20230626173703705 你会发现这些方法用于各个领域的研究：GIS、环境、遥感（只要有大数据）
发表的期刊水平也参差不齐，有Frontiers、Remote Sensing（MDPI）、总环。
除了很少有顶尖期刊，但也不乏还不错的期刊，从一区到四区。为何这个方法一直在使用？这就引出了随机森林的几个优点。
随机森林是集成学习（Ensemble Learning），集成学习的基本思想就是将多个分类器组合，从而实现一个预测效果更好的集成分类器。
随机森林既可以胜任分类任务又可以胜任回归任务。机器学习中有两种任务，回归和分类，而随机森林可以同时胜任这两种任务。其中分类任务是对离散值进行预测（比如将一景图像中的植被，建筑，水体等地物类型分类）；回归任务是对连续值进行预测（比如根据已有的数据预测明天的气温是多少度，预测明天某基金的价格）。
随机森林能评估特征的相对重要性。集成学习模型的一大特点是可以输出特征重要性，特征重要性能够在一定程度上辅助我们对特征进行筛选，从而使得模型的鲁棒性更好。在实际研究中，也能提供一定的物理意义。
代码实现 借助于R语言的高效数据分析，我们使用R的randomForest包实现这一效果
数据集载入 首先加载数据集：
library(tidyverse)
data(airquality)
airquality &lt;- airquality %&gt;% na.omit()
airquality
image-20230626174902091 在airquality数据集中，Ozone是臭氧变量，其它太阳辐射Solar.R、风速Wind和温度Temp等等对臭氧的影响。
数据训练 这里首先把数据集划分训练集（70%）和测试集（30%）
使用randomForest开始训练，其中Ozone~代表臭氧Ozone为因变量，其它数据为自变量。
# To evaluate the performance of RF
# split traning data (70%) and validation data (30%)
set.seed(123)
train &lt;- sample(nrow(airquality), nrow(airquality)*0.7)
ozo_train &lt;- airquality[train, ]
ozo_test &lt;- airquality[-train, ]
# randomForest
library(randomForest)
# Random forest calculation（default 500 tress），please see ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f68c69ff5a763ef238980d21e47787d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15682fb4f43c7ef4a07fff2be3d01269/" rel="bookmark">
			谷歌浏览器（chrome）安装crx插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载crx插件
2、插件扩展名改名为zip
3、解压zip文件
4、打开谷歌浏览器扩展程序
chrome://extensions/
5、打开开发者模式，加载已解压的扩展程序，安装成功即如图展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/314b977aea0cd81e0db1866aeaad600c/" rel="bookmark">
			JavaSE-06 【面向对象OOP--封装】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JavaSE-06 [面向对象+封装]第一章 面向对象思想1.1 面向过程和面向对象1.2 面向对象编程的三大特征(抽象)1.3 类和对象1.4 类的定义1.5 对象的使用1.6 类与对象的练习1.7 对象内存图理解1.8 成员变量和局部变量 第二章 封装2.1 封装的定义2.2 private关键字2.3 this关键字2.4 构造方法2.5 定义标准的类 JavaSE-06 [面向对象+封装] 第一章 面向对象思想 1.1 面向过程和面向对象 面向过程： 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了面向对象： 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为总结 都是解决问题的思维方式，都是代码的组织方式解决简单问题可以使用面向过程解决复杂问题，宏观上使用面向对象把握，微观处理上仍然使用面向过程处理 1.2 面向对象编程的三大特征(抽象) 封装：需要让用户知道的暴露出来，不需要用户知道的隐藏起来，这就是封装–“该露的露，该藏的藏”继承：一方面，继承的本质是对某一批类的抽象，从而实现对现实世界更好的封装。另一方面，代码的重用多态：为了提高处理问题的灵活性，原始的抽象的事务，可以出现多种不同的形态展现 1.3 类和对象 什么是类 类: 类是一组相关属性和行为的集合， 可以看成是一类事物的模板， 使用事务特征和行为特征来描述该类事物 现实中，描述一类事物 属性：就是事物的状态信息 行为：就是事物的功能 什么是对象 对象：对象是一类事物的具体体现，对象是类的一个实例， 必然具备该事物的属性和行为 现实中,一类事物的一个实例，就是一个对象 类和对象的关系 关系： 1、类可以看做是一个模板，或者图纸， 系统根据类的定义来创造出对象 2、类是对一类事物的描述，是抽象的 3、对象是一类事物的实例，是具体的 1.4 类的定义 类的定义 类是现实世界的一类事物 属性：事物的状态信息 行为：事物的功能和作用 Java中用Class描述事物也是如此 成员变量：对应事物的属性 成员方法：对应事物的行为 定义类： 就是定义类的成员，包括成员属性和成员方法 成员变量的位置： 定义在类中，方法外 成员方法的位置： 定义在类中，与之前的方法不一致的是，去掉了static 类的定义格式 public class 类的名称{ //成员变量 //成员方法 } /** * 类的定义 * 定义一个类，用于模拟学生事物，由两部分组成 * 学生属性：年龄。升高。体重.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/314b977aea0cd81e0db1866aeaad600c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d560a2fca0e0456e938654d728967a36/" rel="bookmark">
			CentOS 7 安装 Redis-7.0 步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、检查安装环境 1. gcc 1) 检查gcc环境 rpm -qa | grep gcc 2) 若不存在下载安装 yum install gcc -y 二、下载Redis 1. 使用国内地址下载 wget http://download.redis.io/releases/redis-7.0.5.tar.gz 2. 自行去官网进行下载 官网下载网页链接：https://redis.io/download
下载完成之后，打开Xftp，把我们下载好的Redis压缩包，上传到 /opt/ 文件目录下
三、解压Redis 1. 新建Redis安装文件夹 mkdir /usr/local/redis 2. 解压安装包到安装文件夹 tar -zxvf /opt/redis-7.0.5.tar.gz -C /usr/local/redis 四、编译安装Redis 1. 进入解压后的文件夹 cd /usr/local/redis/redis-7.0.5 2. 编译并安装Redis make &amp;&amp; make install 五、配置启动Redis 1. 配置redis.conf文件 1) 编辑redis.conf vim redis.conf 2) 配置后台启动运行 #定位关键字daemonize :/daemonize #默认配置为no,变更为yes daemonize yes 3) 设置密码 #定位关键字requirepass :/requirepass #默认配置为no,变更为yes requirepass 123456 4) 设置端口 #定位关键字port :/port #默认配置为6379,有需要可以变更,这里变更为6380，若变更了端口需要同步变更pidfile的配置 port 6380 #定位关键字pidfile :/pidfile #变更配置默认为/var/run/redis_6379.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d560a2fca0e0456e938654d728967a36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d0a8ec38beb2bcf160795e01555b1a/" rel="bookmark">
			ESP32-S3 V5.0.2 flash 手动生成密钥加密 _By星年（已验证）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 ESP32-S3 ESP_IDF V5.0.2 手动生成密钥加密
官方参考资料：
https://docs.espressif.com/projects/esp-idf/zh_CN/v5.0.2/esp32s3/search.html?q=generate_flash_encryption_key&amp;check_keywords=yes&amp;area=default
一、加密
(1)生成密钥
espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin (2)工程加密配置及串口配置安全模式
idf.py menuconfig (3)烧录密钥到设备（修改端口号）（只能烧录一次）
espefuse.py --port COM7 burn_key BLOCK_KEY1 my_flash_encryption_key.bin XTS_AES_128_KEY (4)加密镜像并烧录（根据idf.py build编译后信息，修改文件路径、文件名、烧录地址及生成文件名）
idf.py build flash monitor espsecure.py encrypt_flash_data --aes_xts --keyfile my_flash_encryption_key.bin --address 0x10000 --output esp32-bauer-ciphertext.bin build/esp32-bauer.bin espsecure.py encrypt_flash_data --aes_xts --keyfile my_flash_encryption_key.bin --address 0x90000 --output ota_data_initial-ciphertext.bin build/ota_data_initial.bin (5)烧录加密bin
esptool.py -p COM7 -b 460800 --before default_reset --after no_reset --chip esp32s3 write_flash --flash_mode dio --flash_size 16MB --flash_freq 80m 0x9000 ota_data_initial-ciphertext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d0a8ec38beb2bcf160795e01555b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d4947baed8fb9baaebbf385f597ce6/" rel="bookmark">
			毕业设计Day4--MyBatis数据库连接测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 测试数据库是否连接将application.properties后缀更改为yml，节省代码在数据库中创建表插入数据设置entity包并书写User实体类①使用alt+insert快捷键迅速填充get/set方法②使用@Data注解，自动代替get/set方法 定义Mapper包，定义数据库的查询接口要想使用GetMapping注解，必须先添加@RestController注解！写任何注解前都要添加RestController注解！！ Controller包idea的Debugdebug过程debug后需要把断点去掉！ 测试数据库是否连接 将application.properties后缀更改为yml，节省代码 对比：
propeties：
**yml：**冒号后面要空一格！！！
在数据库中创建表 表名sys_user
插入数据 设置entity包并书写User实体类 ①使用alt+insert快捷键迅速填充get/set方法 ②使用@Data注解，自动代替get/set方法 此时就无需书写get/set方法，但可以在其他地方直接使用get/set方法
类似还有
@NoArgsConstructor代替无参构造函数
@AllArgsConstructor代替有参构造函数
定义Mapper包，定义数据库的查询接口 与数据库进行交互
定义一个查询所有数据的函数
使用MyBatis提供的select注解
@Mapper可以把UserMapper这个bean注入到spring boot，即可以直接使用UserMapper类，如下图
要想使用GetMapping注解，必须先添加@RestController注解！ @AutoWired注解可以向spring中注入userMapper类，生成对应bean
此时，运行9090端口，即可出现数据库中对应数据
即表示数据库连接成功
写任何注解前都要添加RestController注解！！ Controller包 定义专门的controller包
如下将刚刚写的代码复制到UserController中
package com.ww.car.controller; import com.ww.car.entity.User; import com.ww.car.mapper.UserMapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; @RestController public class UserController { @Autowired private UserMapper userMapper; @GetMapping("/") public List&lt;User&gt; index(){ return userMapper.findAll(); } } 运行后与之前界面相同
idea的Debug debug过程 运行按钮旁边的小虫子即为debug按钮
在任意一行代码前标红（此行代码不能只有括号），即在此行代码处打断点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48d4947baed8fb9baaebbf385f597ce6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cee53642b3e8957e10cdf6b3fb1e3fdd/" rel="bookmark">
			【Jmeter教程】_事务控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、添加事务控制器
二、事务控制器参数说明
三、运用事务控制器
统计性能测试结果一定会关注TPS，TPS表示每秒处理事务数，JMeter默认每个事务对应一个请求。我们可以用逻辑控制器中的事务控制器将多个请求统计为一个事务。
一、添加事务控制器 二、事务控制器参数说明 Generate parent sample：如果事务控制器下有多个取样器，勾选它，那么在“擦看结果树”中我们不仅可以看到事务控制器，还可以看到每个取样器，并且事务控制器定义的事务是否成功取决于子事务是否都成功，子事务其中任何一个失败即代表整个事务失败。
Include duration of timer and pre-post processors in generated sample：是否包括定时器、预处理和后期处理延迟的时间
三、运用事务控制器 察看结果树中的运行结果
聚合报告中的运行结果
事必有法，然后有成- 最后祝大家早日达到测试的天花板！
以下是我收集到的比较好的学习教程资源，虽然不是什么很值钱的东西，如果你刚好需要，可以留言【777】直接拿走就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/604b8157f26cb0b591df5f941e201b78/" rel="bookmark">
			centos 7.9离线下载安装vscode，以及插件安装下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、软件的下载1.采取的方法2.下载相应压缩包3.安装过程4.相关知识 二、插件的安装和下载1.查看vscode的版本号2.查找插件的版本号3.安装vscode插件 三、vscode以及依赖安装包，常用插件百度云： 一、软件的下载 1.采取的方法 从一台联网的centos中下载好相关文件和依赖，再导入无网络的Centos服务器中,最后进行安装
2.下载相应压缩包 ①、依赖包的下载
下载libXScrnSaver（vscode运行需要）
yum install --downloadonly --downloaddir=/usr/local libXScrnSaver ②、VScode的安装包rmp下载
Ⅰ、访问Visual Studio Code官网 https://code.visualstudio.com/docs?dv=linux64
Ⅱ、或者:wget + “下载链接”
③、通过FileZilla拷出相应的安装包，通过光盘上传到相应的内网服务器内。（FileZilla的使用和安装自行百度）
2023年6月26的vscode和libXScrnSaver(此时版本，可能会随时间变化不一样，时间推移后请自行安装下载)百度云：
链接：https://pan.baidu.com/s/1pWZP-X0yDKki8JKu8FZSGA
提取码：bh80
3.安装过程 ①先安装相关依赖(切换到依赖所在的文件夹中执行)：
rpm -Uvh --force --nodeps libXScrnSaver-1.2.2-6.1.el7.x86_64.rpm ②安装vscode
rpm -ivh code-1.79.2-1686734266.el7.x86_64.rpm #对应你自己的rpm安装包 ③ 重启
reboot 重启后即可在 application里面找到相应的vscode软甲，可以把它拉到桌面上
4.相关知识 - yum 下载rpm包到指定目录，只下载不安装
yum install --downloadonly --downloaddir=路径 安装包名
实例：yum install --downloadonly --downloaddir=/usr/local libXScrnSaver
- 安装: rpm -Uvh --force --nodeps .rpm
实例：rpm -Uvh --force --nodeps libXScrnSaver-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/604b8157f26cb0b591df5f941e201b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c8d68435cfd201eeafe2ddcf523847/" rel="bookmark">
			关于@profiles.active@的环境配置，将环境配置放在pom文件配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用@profiles.active@，需要在pom文件对其进行配置，然后加载到bootstrap.yml的@profiles.active@所在的位置 bootstrap.yml的文件配置如下 server: port: 9041 servlet: context-path: /service tomcat: uri-encoding: UTF-8 max-http-form-post-size: -1 spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 application: name: service profiles: active: @profiles.active@ main: allow-bean-definition-overriding: true cloud: nacos: discovery: server-addr: @nacos.server@ ip: @nacos.discovery@ config: server-addr: @nacos.server@ file-extension: yaml 在pom文件对开发环境配置
&lt;profiles&gt; &lt;!-- 测试配置 --&gt; &lt;profile&gt; &lt;id&gt;develop&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profiles.active&gt;develop&lt;/profiles.active&gt; &lt;log.level&gt;INFO&lt;/log.level&gt; &lt;nacos.server&gt;localhost:8848&lt;/nacos.server&gt; &lt;nacos.username&gt;nacos&lt;/nacos.username&gt; &lt;nacos.password&gt;nacos&lt;/nacos.password&gt; &lt;nacos.discovery&gt;localhost&lt;/nacos.discovery&gt; &lt;loki4j.ip&gt;localhost:19084&lt;/loki4j.ip&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- 生产配置 --&gt; &lt;profile&gt; &lt;id&gt;product&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profiles.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36c8d68435cfd201eeafe2ddcf523847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d7a6f55d1f152c7970b7c208dcb5d08/" rel="bookmark">
			Spring @Transactional注解失效的情况及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring框架中的@Transactional注解是非常常用的注解，它可以将一个方法标记为事务性方法，使得在方法执行过程中发生异常时，可以自动回滚事务，保证数据的一致性。然而，在某些情况下，@Transactional注解可能会失效，本文将会介绍这些情况及其解决方法。
一、@Transactional注解的原理 在介绍@Transactional注解失效的情况之前，我们先来了解一下@Transactional注解的原理。
@Transactional注解的实现是基于Spring框架中的AOP（面向切面编程）机制，它通过代理模式在运行时动态地为标记了@Transactional注解的方法生成一个代理对象，这个代理对象会拦截方法的调用，并在方法执行前后开启和提交事务。
具体来说，当一个标记了@Transactional注解的方法被调用时，Spring框架会在运行时为这个方法生成一个代理对象，这个代理对象会在方法执行前开启一个新的事务，并将这个事务与当前线程绑定。当方法执行完成后，代理对象会根据方法的执行结果决定是提交事务还是回滚事务，并将事务与当前线程解绑。
需要注意的是，@Transactional注解只对public方法有效，对于private、protected或者默认访问级别的方法是不起作用的。
二、@Transactional注解失效的情况 虽然@Transactional注解是非常方便的，但是在某些情况下，它可能会失效。下面我们将介绍一些常见的情况。
1. 方法内部调用 如果在一个标记了@Transactional注解的方法内部调用另一个标记了@Transactional注解的方法，那么内部方法的事务将会失效。这是因为Spring框架默认使用基于代理的AOP实现，而代理对象的调用是通过Java反射机制实现的，因此在一个方法内部调用另一个方法时，实际上是在同一个对象中调用方法，而不是通过代理对象调用方法，因此事务无法生效。
@Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Transactional public void updateUser(User user) { // 更新用户信息 userDao.updateUser(user); // 调用另一个标记了@Transactional注解的方法 updateUserScore(user.getId(), 100); } @Transactional public void updateUserScore(Long userId, int score) { // 更新用户积分 userDao.updateUserScore(userId, score); } } 上面的代码中，updateUser方法和updateUserScore方法都标记了@Transactional注解，但是当updateUser方法调用updateUserScore方法时，updateUserScore方法的事务将会失效。
2. 异常被捕获 如果一个标记了@Transactional注解的方法抛出了异常，并且这个异常被捕获了，那么事务将不会回滚。这是因为Spring框架默认只对未捕获的异常进行回滚，如果异常被捕获了，那么Spring框架就认为这个异常已经被处理了，不需要回滚事务。
@Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Transactional public void updateUser(User user) { // 更新用户信息 userDao.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d7a6f55d1f152c7970b7c208dcb5d08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eff856d3e19eed1895098b9e7a25880/" rel="bookmark">
			linux系统使用-vimrc文件的组织
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每到一家新公司都会有自己整理软件使用的这一个步骤，为了方便查找，总结一下vimrc的编写。
.vimrc 文件一般的linux系统里有两个，一个默认放在/usr/share/vim/vimrc下面，是系统配置。一个放在用户的根目录（~）下面，是用户自定义的配置。以下配置的是用户自定义的配置，常用的操作
set cursorcolumn#光标所在列高亮显示
set incsearch#输入关键字的时候高亮显示
set laststatus=2#查看文件路径或者名称
syntax enable #启用语法高亮
syntax on#打开语法高亮
filetype on#打开文件类型检测
filetype plugin on#用于vim打开加载类型插件
filetype indent on
set autoindent#自动缩进
set smartindent#基于autoindent的一些改进
set expandtab#扩展tab为空格
set shiftwidth=4#把每级缩进设置为4个空格
set tapstop=4#一个tab占四个空格
set showmatch#高亮括号匹配
set guioptions+=b#添加水平滚动条
set hlsearch#搜索数据时设置高亮
set magic#设置魔术
set showcmd#vim窗口的右下角显示一个完整的命令已经完成的部分
set wildmenu#启用wildmenu
set backspace=2#设置backplace可以删除任意字符
set textwidth=0#固定行的长度
set history=500#历史记录最长是500个
set foldenable#设置可折叠
set ignorecase#设置不区分大小写
set smartcase#智能大小写搜索
set wrap#自动换行
set tabpagemax=50#最多打开50个标签页
nmap？？
vmap？？
imap？？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/227a29d8951deb67dd6a7462521b9802/" rel="bookmark">
			spring security POST请求 报403 Forbidden
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring security POST请求 报403 Forbidden Security配置代码：
@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { /** * 配置不需要验证 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().permitAll().and().logout().permitAll();//配置不需要登录验证 } } 配置那么就不需要认证就可以请求接口
但是一样的接口使用post就会有问题
为了查看这个请示具体的执行过程，把日志级别调整到debug,看一下是否有收获
查阅资料后发现这是一个RESTful技术与CSRF(Cross-site request forgery跨站请求伪造)的冲突造成的，CSRF默认支持的方法： GET|HEAD|TRACE|OPTIONS，不支持POST。可以在security在配置中禁用掉它。
@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { /** * 配置不需要验证 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception { http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/227a29d8951deb67dd6a7462521b9802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5aac600d99d87bf03155c09722b1b2f/" rel="bookmark">
			vue2 draggable拖拽组件的使用及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录draggable拖拽组件的使用方法以及遇到的问题。
参考文章draggable拖拽组件使用
参考文章Vue项目拖拽插件 ---- vuedraggable的安装与使用
效果图 vue.draggable中文api地址https://www.itxst.com/vue-draggable/tutorial.html
安装 npm install vuedraggable 引入与使用 &lt;template&gt; &lt;div class="cardDrag-container common-container"&gt; &lt;div class="cardDrag-content"&gt; &lt;div class="left-drag-container"&gt; &lt;draggable tag="ul" class="cardDrag-list-wrap" v-model="leftComponentsList" :group="groupLeft" animation="300" &gt; &lt;li class="cardDrag-list" v-for="item in leftComponentsList" :key="item.id" &gt; &lt;div class="cardDrag"&gt; &lt;svg-icon class="svg-width" :iconClass="item.icon"&gt;&lt;/svg-icon&gt; &lt;label&gt;{{item.name}}&lt;/label&gt; &lt;/div&gt; &lt;/li&gt; &lt;/draggable&gt; &lt;/div&gt; &lt;div class="right-drag-container"&gt; &lt;draggable tag="ul" class="cardDrag-list-wrap" v-model="rightComponentsList" :group="groupRight" animation="300" @add="handleAdd" &gt; &lt;li class="cardDrag-list" v-for="item in rightComponentsList" :key="item.id" &gt; &lt;div class="cardDrag cardBackground" :style="computedStyle"&gt; &lt;div class="card-box"&gt; &lt;svg-icon class="svg-width" :iconClass="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5aac600d99d87bf03155c09722b1b2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b88400250115c07f5983d7033f36c1f/" rel="bookmark">
			语雀批量导出MarkDown文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 笔记写在语雀有时候总想本地再存储一份，但是一个个导出又太麻烦了。需要导出语雀的全部文件，并导出为markdown格式。
二、实现 2.1配置json配置文件 设置token
登录网页版语雀，点击头像创建token，语雀token链接 👉https://www.yuque.com/settings/tokens/new
填写配置信息
配置信息用来设置用户的token等一些基础信息
# config.json { "TOKEN": "xxxxxxxx", # 用户token "USER_AGENT": "Rion", # 就是一个用户名称，可以随意写，但必须要有 "BASE_URL": "https://customspace.yuque.com/api/v2", # 语雀基础api "DATA_PATH": "yuque" # 数据储存的文件夹名称（默认当前文件夹下创建） } 2.2 实现代码 """ 这是一个导出语雀库中所有文档的脚本, 并将文件转为md格式 """ import json import sys import os import re import requests import psutil from datetime import datetime if getattr(sys, 'frozen', False): APPLICATION_PATH = os.path.dirname(sys.executable) else: APPLICATION_PATH = os.path.dirname('.') jsonConfig = json.load(open(os.path.join(APPLICATION_PATH, "config.json"), encoding='utf-8')) class ExportYueQueDoc: def __init__(self): try: if getattr(sys, 'frozen', False): APPLICATION_PATH = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b88400250115c07f5983d7033f36c1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee13fda5b622733e8dcf300433249609/" rel="bookmark">
			Vue实现video视频倍速播放、调节声音、拖动进度条、生成智能字幕等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言介绍
在现代化的网站中，视频播放已经成为了不可或缺的一部分。而对于视频播放的需求也越来越多样化，比如倍速播放、调节声音、拖动进度条、生成智能字幕等。本文将介绍如何使用Vue实现这些功能。
组件实现思路
首先，我们需要一个video标签来播放视频。然后，我们可以使用Vue的v-bind指令来绑定video标签的属性，比如src、controls等。接下来，我们需要实现以下功能：
1. 倍速播放：我们可以使用video标签的playbackRate属性来实现倍速播放。通过一个下拉框来选择倍速，然后通过v-bind将所选倍速绑定到playbackRate属性上即可。
2. 调节声音：我们可以使用video标签的volume属性来调节声音。通过一个滑动条来选择音量大小，然后通过v-bind将所选音量大小绑定到volume属性上即可。
3. 拖动进度条：我们可以使用video标签的currentTime属性来实现拖动进度条。通过一个滑动条来选择进度，然后通过v-bind将所选进度绑定到currentTime属性上即可。
4. 生成智能字幕：我们可以使用Vue的computed属性来生成智能字幕。首先，我们需要将视频的音频转换成文本，然后通过一些算法来生成字幕。最后，将字幕渲染到页面上即可。
Demo代码
下面是一个简单的Vue组件，实现了以上功能：
```
&lt;template&gt;
&lt;div&gt;
&lt;video ref="video" v-bind:src="src" v-bind:controls="controls" v-bind:playbackRate="playbackRate" v-bind:volume="volume" v-bind:currentTime="currentTime"&gt;&lt;/video&gt;
&lt;select v-model="playbackRate"&gt;
&lt;option value="0.5"&gt;0.5x&lt;/option&gt;
&lt;option value="1"&gt;1x&lt;/option&gt;
&lt;option value="1.5"&gt;1.5x&lt;/option&gt;
&lt;option value="2"&gt;2x&lt;/option&gt;
&lt;/select&gt;
&lt;input type="range" min="0" max="1" step="0.1" v-model="volume"&gt;
&lt;input type="range" min="0" max="100" step="1" v-model="currentTime"&gt;
&lt;div&gt;{{ subtitles }}&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
data() {
return {
src: 'video.mp4',
controls: true,
playbackRate: 1,
volume: 1,
currentTime: 0,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee13fda5b622733e8dcf300433249609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/189905948f4e22aa2958f86fec4350d0/" rel="bookmark">
			新手入门python实现神经网络，超级简单!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
这篇文章完全是为新手准备的。我们会通过用Python从头实现一个神经网络来理解神经网络的原理。
文章目录 神经元1、一个简单的例子2、编码一个神经元 把神经元组装成网络1、例子：前馈2、编码神经网络：前馈 训练神经网络 第一部分1、损失2、损失计算例子3、代码：MSE损失 训练神经网络 第二部分1、例子：计算偏导数2、训练：随机梯度下降 代码：一个完整的神经网络 神经元 首先让我们看看神经网络的基本单位，神经元。神经元接受输入，对其做一些数据操作，然后产生输出。例如，这是一个2-输入神经元：
这里发生了三个事情。首先，每个输入都跟一个权重相乘（红色）：
然后，加权后的输入求和，加上一个偏差b（绿色）：
最后，这个结果传递给一个激活函数f：
激活函数的用途是将一个无边界的输入，转变成一个可预测的形式。常用的激活函数就是S型函数：
S型函数的值域是(0, 1)。简单来说，就是把(−∞, +∞)压缩到(0, 1) ，很大的负数约等于0，很大的正数约等于1。
1、一个简单的例子 2、编码一个神经元 让我们来实现一个神经元！用Python的NumPy库来完成其中的数学计算：
import numpy as np def sigmoid(x): # 我们的激活函数: f(x) = 1 / (1 + e^(-x)) return 1 / (1 + np.exp(-x)) class Neuron: def __init__(self, weights, bias): self.weights = weights self.bias = bias def feedforward(self, inputs): # 加权输入，加入偏置，然后使用激活函数 total = np.dot(self.weights, inputs) + self.bias return sigmoid(total) weights = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/189905948f4e22aa2958f86fec4350d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d137d7e8b7ffec0aa219f8028f5bfc59/" rel="bookmark">
			【无标题】vue中的父子组件通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		父组件向子组件传递数据：props 子组件向父组件传递数据：$emit事件 &lt;div id="app"&gt; &lt;my-cpn :c-info = "info" :cmessage = "message"&gt;&lt;/my-cpn&gt; &lt;!-- 子传父 此处的item-click 是子组件通过$emit时间传递过来的时间名称（自定义），后面的cpnClick则对应父组件中的methods中的函数 ，需要注意的是：子组件传递时间的时候，名称不能使用驼峰格式，全部小写或者使用短横线连接，但是在脚手架模式中是可以使用驼峰格式的--&gt; &lt;my-cbn v-on:item-click = "cpnClick"&gt;&lt;/my-cbn&gt; &lt;/div&gt; &lt;template id="myCpn"&gt; &lt;div&gt; &lt;h2&gt;父传子&lt;/h2&gt; &lt;h3&gt;{{cInfo}}&lt;/h3&gt; &lt;h4&gt;{{cmessage}}&lt;/h4&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id="myCpn1"&gt; &lt;div&gt; &lt;h1&gt;子传父&lt;/h1&gt; &lt;ul&gt; &lt;li v-for="item in categories" &gt; &lt;button @click = "btnClick(item)"&gt;{{item.name}}&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('my-cpn',{ template:'#myCpn', props:{ cInfo:{ type:Object, default(){ return {} } }, cmessage:{ type:String, default:'' } } }) Vue.component('my-cbn',{ template: '#myCpn1', data(){ return { categories:[ {id:'aaaa',name:'常用推荐1'}, {id:'bbbb',name:'常用推荐2'}, {id:'cccc',name:'常用推荐3'}, {id:'dddd',name:'常用推荐4'} ] } }, methods:{ btnClick(item){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d137d7e8b7ffec0aa219f8028f5bfc59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5a83e1676e354d321d4b08b442c5c3/" rel="bookmark">
			Python编程快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是当前最流行的编程语言之一，可应用于Web开发、数据分析、人工智能、科学计算、桌面应用、游戏开发等等多个领域。Python的一大特色就是它具有丰富的程序库（包括内置的库及第三方开发的库），我们不必从头开始编写代码，就可以实现功能强大的应用程序。Python不但功能强大，而且和其他编程语言相比它相对简单，不需要任何先前的编程经验即可学习、使用，对初学者极为友好。下面就让我们一起走进丰富多彩的Python编程世界。
文|梦飞
Python编程环境设置
Python是一种解释性语言，它使用解释器来解释和执行代码，这对用户来说省去了C或C++之类语言的编译步骤，直接从源代码即可运行，因此更容易编写和调试。工欲善其事，必先利其器。在学习Python编程之前，先让我们安装好相应的工具并对编程环境进行设置。
首先进入Python官方下载频道https://www.python.org/downloads，点击“Download Python 3.11.2”按钮进入下载页面（此数字会随着版本的升级而改变）。找到适合自己系统的下载链接，比如笔者为Windows的64位系统，所以选择下载了“Windows installer (64-bit)”。双击下载所得的EXE可执行文件启动Python安装向导（图1）。
图1 Python安装向导 勾选“Add python.exe to PATH”项，这样就不用后期手动将Python程序添加到系统路径中了。点击“Install Now”即可自动安装。如果不希望安装到默认的C盘，可以点击“Customize installation”自定义安装项，根据向导提示一步步安装（图2）。
图2 Python自定义安装 作为初学者选择默认安装选项即可。安装成功后，对于Windows系统将会有一个“Disable path length limit（禁用路径长度限制）”的提示，这是因为Windows系统能够处理的文件路径长度有一定的限制（图3）。点击禁用这一限制可以避免处理长文件路径时出现的调试问题，不过这也可能导致与旧版本Windows 10的兼容性问题。对于我们初学者来说可以暂时跳过此选项，因为以后有需要时还可以修改注册表来解决。
图3 Python安装成功的界面 点击“Close”按钮关闭安装向导。现在我们测试Python是否安装成功。按Win+R键调出运行对话框，输入“cmd”后按回车键打开命令提示符窗口，然后输入“python”并按回车，如果能够显示出Python版本等信息内容，并且提示符变成了“&gt;&gt;&gt;”，则表示安装成功了。此时可输入一行测试代码：
print(“嗨，欢迎来到Python世界！”)
按回车键执行，即可得到“嗨，欢迎来到Python世界！”的显示信息。几乎每种编程语言教程中都会展示一下“hello, world!”程序，虽然很俗套，但不得不说Python的实现是如此的简单。紧接着执行代码“exit()”退出Python环境，完成此一阶段的测试（图4）。
图4 Python的“hello, world!”程序示例 命令提示符的界面过于简陋，我们可以试试Python自带的IDLE交互式开发环境。点击系统“开始”按钮，在开始菜单顶部的最近添加中就可以看到“IDLE(Pyton 3.11 64-bit)”程序了，点击即可打开。
IDLE通过不同的颜色区分代码及执行结果，清晰明了。尤其方便的是，当我们输入某个函数时，它会智能显示参数提示，辅助我们输入代码，非常方便（图5）。
图5 Python的IDLE交互式开发环境 除了一行一行的交互式执行，IDLE还可以执行扩展名为“py”的Python程序文件，下面就来做个测试。首先点击菜单命令“File→New File”打开IDLE的代码编辑器，输入以下代码：
# Python 3: 显示n个数以内的斐波纳契（Fibonacci）序列
def fib(n):
a, b = 0, 1
while a &lt; n:
print(a, end=’ ')
a, b = b, a+b
print()
fib(1000)
代码解释：“#”后面的文字表示注释，是程序员对代码的说明，这是给阅读代码的人看的，Python解释器会自动忽略这一行。接下来的“def fib(n):”定义了一个名为“fib”的函数，其后缩进的几行代码就是该函数的内容，其主体是一个“while”循环，通过斐波纳契数列公式反复运算，运算结果通过“print()”函数显示出来，其参数“end=’ '”表示每个数字后面加几个空格，是为了将数字隔开（用来显示的print函数在后面的示例中将频繁出现）。当然，函数定义只是表明此函数能做什么，真正运行还得对它进行调用，这就是最后一行代码“fib(1000)”的作用，在调用该函数时，传递了一个参数“1000”，表示要计算1000以内的斐波纳契数列（图6）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d5a83e1676e354d321d4b08b442c5c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8a53a392199d0e7589adc717358915/" rel="bookmark">
			openfeign实现远程调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 openfeign简介 Feign 是声明性(注解)web 服务客户端它使编写 web 服务客户端更加容易请创建一个接口并对其进行注解.它具有可插入注解支持，包括Feign注解和JAXRS注解Feign 还支持可插拔编码器和解码器。Spring cloud 添加了对Spring MVC注解的支持，并支持使用 HttpMessageConverters，Spring Web 中默认使用的注解。Spring cloud集成了Ribbon和Eureka以及 Spring cloud LoadBalancer，以在使用 Feign 时提供负载平衡的 http 客户端。
二、使用 1.分别建立提供者和消费者两个服务模块，模拟消费者调用提供者服务的场景
2.配置文件如下：
server: port: 8080 eureka: client: service-url: defaultZone: http://localhost:8761/eureka spring: application: name: provider-service server: port: 8081 spring: application: name: consumer-service eureka: client: service-url: defaultZone: http://localhost:8761/eureka ribbon: ReadTimeout: 3000 #调用超时时间 ConnectTimeout: 3000 #连接超时时间 3.provider模块：
需要注意的是，如果要实现带参传入，则传参注解不能省略。
@RestController public class ProviderController { @GetMapping("/provider") public String providerService(){ return "啤酒饮料矿泉水，瓜子花生八宝粥"; } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e8a53a392199d0e7589adc717358915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ee9248a2bd25e2cf13fbb6a94127ce/" rel="bookmark">
			jpg和png通道数上的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JPEG（.jpg）和PNG（.png）是两种常见的图像格式，它们在通道数上有一些区别。
1.JPEG图像的通道数： JPEG图像通常用于存储彩色图像，具有3个通道（红色、绿色和蓝色），表示RGB颜色模式。每个通道存储相应颜色的强度值，以生成彩色图像。
JPEG图像是一种有损压缩的格式，在JPEG图像中，通常使用YCbCr颜色空间进行压缩编码。YCbCr颜色空间包含亮度（Y）和色度（Cb和Cr）三个分量。在编码过程中，亮度分量（Y）通常保留所有细节，而色度分量（Cb和Cr）则以较低的分辨率进行采样，从而实现对颜色信息的压缩。但是，在JPEG文件中存储的数据仍然是RGB，而不是直接存储YCbCr分量。
虽然JPEG支持存储单通道图像，但在实践中，单通道图像通常使用灰度图像的专用格式，如灰度JPEG（.jpeg）或灰度PNG（.png）来存储。这是因为使用灰度图像格式可以更有效地压缩和存储单通道图像数据，而不需要额外的颜色通道。因此，虽然JPEG理论上可以存储单通道图像，但在实际应用中，使用专门的灰度图像格式更常见和推荐。
2.PNG图像的通道数。 RGB图像：大多数PNG图像是RGB图像，具有3个通道（红色、绿色和蓝色），用于表示彩色图像。
RGBA图像：PNG还支持RGBA图像，具有4个通道（红色、绿色、蓝色和透明度），用于表示彩色图像以及透明度信息。透明度通道允许图像具有透明或半透明的部分。
灰度图像：PNG也可以存储灰度图像，只包含一个通道，用于表示图像的灰度级别。
因此我们在使用PNG格式的彩色图像时，如果只想要rgb三个通道，我们最后对其进行转换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5097ea399f0679d9afe7d31224f78438/" rel="bookmark">
			Idea中的Maven home path: 无法修改，修改后马上变成默认值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天创建Springboot模块的时候，模块一直无法被正确的加载，右侧的MAVEN栏中只有lifecycle没有plugins和dependencise，java文件中需要使用的包名全部爆红
反复点击clean和install也没任何作用，后来发现是idea默认在使用自带的放在c盘的MAVEN而不是我自己配置的MAVEN，
反复尝试修改 重启也没有作用。
后来发现这应该是Idea2020.2版本的一个BUG
解决办法：
我重新安装了一个2021.2.2版本的idea问题就得到了解决
以上问题仅针对使用Idea2020.2版本且遇到相同问题的同学，实在没有办法了不妨试试
电脑上可以同时存在不同版本的idea 所以可以放心安装
只是在安装的时候会提示uninstall卸载掉原来的版本 不要勾选就是了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d314b364facc73cab8b04a1a6e47f3dd/" rel="bookmark">
			域控制器是什么以及需求分析和用例设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		域控制器是一种网络服务器
它管理和控制用户、计算机和其他网络资源的访问和权限。它是Windows Server操作系统中的一种角色，可以通过Active Directory服务来实现。
需求分析：
1. 用户管理：域控制器需要能够管理用户的身份验证、访问权限和组织结构。
2. 计算机管理：域控制器需要能够管理计算机的身份验证、访问权限和组织结构。
3. 安全性：域控制器需要提供安全性，包括身份验证、访问控制和审计。
4. 可扩展性：域控制器需要能够支持大量的用户和计算机，并能够扩展到多个域和林。
用例设计：
1. 用户登录：用户使用其凭据登录到域控制器，以便访问其授权的资源。
2. 用户管理：管理员可以创建、修改和删除用户帐户，并分配访问权限。
3. 计算机管理：管理员可以创建、修改和删除计算机帐户，并分配访问权限。
4. 安全性管理：管理员可以配置安全策略、审计和访问控制。
5. 域控制器管理：管理员可以管理域控制器的配置、备份和恢复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09b1b4c7e27f7523e2c14a2aef38967/" rel="bookmark">
			陶哲轩甩出调教GPT-4聊天记录，点击领取大佬的研究助理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		量子位 | 公众号 QbitAI 鹅妹子嘤，天才数学家陶哲轩搞数学研究，已经离不开普通人手里的“数学菜鸡”GPT了！
就在他最新解决的一个数学难题下面，陶哲轩明确指出自己“使用了GPT-4”，后者给他提出了一种可行的解决方法。
借助GPT-4，他不仅成功地突破了这一难题，还将答案分享在了MathOverflow上：
它给我提供了最终的解题思路，接下来我只需要继续计算就行。
为了给更多数学家分享用GPT-4工作的便利性，陶哲轩还将自己的聊天记录po了出来，里面完整地记载了他和GPT-4的对话。
可以看见，在这份聊天记录中，他把GPT-4称呼为“专业数学合作者”，而不仅仅是一个普通的数学助手。
这个身份属实不一般了，不知道之后陶哲轩写论文的时候会不会把GPT-4列为共同作者（手动狗头）。
不仅如此，戳对话记录底部的“continue this conversation”按钮，还能一键把对话记录导入自己的ChatGPT中，突然闯入人类大师和AI的交谈。
陶哲轩解决了什么新问题？ 陶哲轩研究的问题，是一个两天前在数学网站MathOverflow上更新的提问。
这个名叫“优雅的递归之A301897”问题，具体长这样：
其中，A301897是一个被整数数列网站OEIS收录的数列：
这个数列中有一系列来自长度为n的排列b的数，它们有一个共同点，就是满足Diaconis-Graham不等式且等号成立。
Diaconis-Graham不等式由戴康尼斯（Persi Diaconis）和葛立恒（没错，就是“最大数”之父Ronald Graham）于1977年共同提出，属于概率统计方面的研究。
显然，这一大段提问中不仅夹杂着大量专业数学公式，而且还涉及需要跳转的网页资料。
作为数学公认不太好的“数学菜鸡”，GPT-4真的能像一名专业数学家那样快速读懂公式、给出解决问题的专业建议吗？
事实上，相比直接把问题复制粘贴给GPT-4，陶哲轩做了三件事：
首先，做一些提示工程，明确GPT-4的“身份”和“目标”。其中身份是“一个擅长给技巧性建议的数学合作专家”，目标是“提供一些建议”而非解决问题。
然后，相比直接把大段公式复制进GPT-4提问栏（确实可以这样做），陶哲轩选择将问题描述转成Markdown格式。
最后，涉及需要GPT-4自己查找资料的内容，陶哲轩将它转变成一个引用注释，并在结尾给出网址。
完整的提问过程长这样：
也就是说，相比让GPT-4直接化身数学家去“解决问题”，陶哲轩只是把它当成一个提供灵感来源的“专家”，给自己建议一些研究的方向。
GPT-4很快给出了8个具体的建议：
1、理解问题：在深入证明之前，确保你理解了问题中的每一项。如果你不熟悉Diaconis-Graham不等式，研究一下它，了解表达式a(n)和R(n, q)中的每一项代表什么。
2、简化表达：有时候，复杂的表达可以被简化。例如，你可能想看看表达式中a(n)的二项式系数是否可以简化，或者是否可以用更简单的方式计算总和。
3、归纳法：由于R(n, q)是递归定义的，因此证明猜想的一种自然方法是使用数学归纳法。你可能想要证明，如果这个猜想对n成立，那么它对n+1也成立。
4、生成函数：另一种方法是使用生成函数。尝试找到a(n)和R(n, 0)的生成函数，然后证明它们是相等的。这有时可以把一个复杂的组合问题变成一个更简单的代数问题。
5、渐近分析：正如你提到的，分析a(n)和R(n, 0)的渐近行为可能会对它们的关系有一些深入的了解。这有时可以用斯特林的阶乘近似来实现，或者通过分析表达式中的主导项来实现。
6、数值证据：虽然不是证明，但收集数值证据有时可以让我们了解如何证明一个猜想。因为你有PARI/GP代码，可以用数值来检查猜想，你可能想读一读每个序列的前几项，看看是否能发现任何模式。
7、寻找类似问题：有时，一个问题或猜想是一个已知问题的泛化或变体。在组合文献中寻找类似的问题或定理，看看它们的证明是否可以适用于这个问题。
8、寻求反馈和合作：不要犹豫，从同事那里寻求反馈，或者在MathOverflow这样的论坛上发布你的部分结果。协作和同行评议通常是解决复杂数学问题的关键。
最终，陶哲轩使用建议4，也就是生成函数的方法，成功解决了问题。
当然，解决问题的过程并不需要用到GPT-4，采用MAPLE工作表+纸笔手动计算就能完成。陶哲轩也尝试了渐进分析（建议5）的方法，不过事实证明还是用生成函数更有效。
简单来说，陶哲轩只是用GPT-4给自己提供不同的解题思路，也就是“解题灵感”，但具体怎么解答，也就是更加数学的方法，他则不会交给GPT-4来完成。
至于“查资料”这种GPT-4的应用，陶哲轩也发挥到了极致。
例如在思考问题时，他还会把自己的“灵光乍现”拿出来和GPT-4讨论一下，例如他觉得这个问题和卡特兰数（Catalan numbers）有相似之处，希望GPT-4帮他查找一下对应的资料。
GPT-4很快给出了对应的回答，这也促使陶哲轩对另一个问题产生了新的灵感。
简单来说，陶哲轩在短短两段与GPT-4的对话中，展示了数学家使用GPT-4的正确姿势——找灵感和查资料。
这样一来，即使“数学菜鸡”如GPT-4，也能成为数学家的AI助理了。
大佬是怎么玩儿GPT的 分享人类大师和AI的聊天记录之余，陶哲轩的乳齿象博文里还附带着一份贴心指南，是他使用ChatGPT和GPT-4的经验之谈。
根据他过去的实操经验，最要紧的第一点：
不要试图让AI直接回答问题，因为这几乎肯定会得到一些看起来专业的废话。
为了避免GPT成为废话文学大王，行之有效的方案如下：
让AI扮演合作者的角色，而后让它提供策略建议。
Like this：
除此之外，“数学菜鸡”GPT，在大数学家手里能有什么用处？
陶哲轩大概的意思是酱婶儿的：
ChatGPT数学能力虽然不咋滴，但对做学术研究的人来说是个发散思维的好工具。
（对普通人来说有点不太专业，但对搞数学的学术人员来说刚刚好）
怎么解释用来“发散思维”这句话呢？
陶哲轩表达出来的观点是，既然ChatGPT在具体数学问题上给出的答案是不完全正确的，那不如索性发挥发挥它生成答案部分正确的特性。
简而言之，就是让它帮你找灵感balabalabla：
在处理数学问题时，可以让ChatGPT这类大语言模型做一些半成品的语义搜索工作。
也就是说，ChatGPT不用提供确切的答案，只用生成一些可能的提示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c09b1b4c7e27f7523e2c14a2aef38967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853d3c61e3d955d2899fc5ddc905cb15/" rel="bookmark">
			基础篇：新手使用vs code新建go项目（从0开始到运行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习新语言，搭建新环境。在网上找了一些教程，感觉还是写一个比较详细的方便以后自己使用。其实vs code没有新建项目这个功能，具体怎么运行go语言的项目请看下文。
一、下载GO安装包
1.点击go安装包下载链接下载相应的版本（本次下载的是：推荐下载-Microsoft Windows）。
2.打开下载的文件夹地址，双击安装包，如下图。
3.点击Next。
4.勾选同意后，点击Next。
5.选择安装的路径，，点击Next。
6.点击Install。
7.点击Finish，安装完成。
二、配置go mod
在搜索框输入cmd，打开命令提示符，输入如下语句（输入go version可以查看版本，如果可以看到版本号证明第一步安装成功）。
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct
go clean --modcache
三、vscode相关操作
1.打开vscode按照下图步骤，点【安装】后安装插件。
2.需要安装的插件如下图，可选择安装。
3.在vscode界面按键盘ctrl+shift+p，输入Go: install/update tools，回车如下图，选择要安装的依赖（这里全选），等待安装完成。
到这里安装就基本完成了~
四、新建项目初始化
1.新建一个项目的文件夹（因为vscode没有新建项目的功能，所以需要自己新建文件）。
2.在vscode中点击文件-&gt;打开文件夹，选择刚刚新建的文件夹。打开后，如下图新建一个文件后缀为.go（main.go）。
3.打开终端，如下图，输入go mod init go_test（格式：go mod init 新建的文件名称），回车等待。点击运行按钮或ctrl+alt+n运行项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2418ccb7d6f6ef2ca1031de824e3e271/" rel="bookmark">
			spring中事务失效的情况（常见的5种）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.多线程调用
从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。
这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。
如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。
我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。
2.方法内部调用
有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：
我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。
方法内部调用的解决办法
在该Service类中注入自己
3.访问权限问题 java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。
但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：
我们可以看到add方法的访问权限被定义成了private，这样会导致事务失效，spring要求被代理方法必须是public的。
说白了，在AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法中有个判断，如果目标方法不是public，则TransactionAttribute返回null，即不支持事务。
也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是public，而是private、default或protected的话，spring则不会提供事务功能。
4.方法被final修饰 有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：
我们可以看到add方法被定义成了final的，这样会导致事务失效。
为什么？
如果你看过spring事务的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。
但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。
注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。
5.未被spring管理
使用spring事务的前提是：对象要被spring管理，需要创建bean实例。
通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a1959c919016a2b03802d737d947fa/" rel="bookmark">
			车牌识别部署瑞芯微RK3588
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为国内关于rockchip方面的文档不是很多,所以在此记录一下车牌识别模型转化以及部署的过程:
数据集:
cpdd,github上寻找到数据集
​​​​​​​​​​​​​​链接: https://pan.baidu.com/s/1SeqcoBBDqOYVBvpOTZy7tQ 提取码: 46wk 模型:
yolov5,crnn(lprnet_rknn模型量化失败)
目录
车牌检测
车牌识别
模型部署
​​​​​​​
车牌检测 yolov5模型不过多赘述,网络上面开源的很多,转化过程我分两步,pytorch转onnx,再onnx转rknn.
yolov5开源代码中有export.py文件用于输出onnx模型,
python3 export.py --weights weights/yolov5s.pt --opset 12
在onnx转rknn模型时可能会出现报错,需要修改opset参数(目前没有遇到这种情况).
rknn_toolkit2官方提供了python3.6和python3.8的package,如果pc没有这两个版本,就需要按转对应版本.
官方有提供onnx转rknn模型的代码(rknn-toolkit2-1.4.0/examples/onnx/yolov5/):
# Create RKNN object rknn = RKNN(verbose=True) # pre-process config print('--&gt; Config model') rknn.config(mean_values=[[0, 0, 0]], std_values=[[1, 1, 1]], target_platform='rk3588') print('done') # Load ONNX model print('--&gt; Loading model') # ret = rknn.load_onnx(model=ONNX_MODEL, outputs=['326', '384', '442']) ret = rknn.load_onnx(model=ONNX_MODEL, outputs=['343', '360', '377']) if ret !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57a1959c919016a2b03802d737d947fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c9e7c442c38aa5f281b04d4d36c36ef/" rel="bookmark">
			redis中opsForList().range()的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试stringRedisTemplate.opsForList().range(key, start, end)的使用 结论（具体测试数据请往下看） 1、start—end总体保持着顺序就没问题
2、按照顺序，即便start &lt; -N或者end &gt; N-1也能查询出数据
3、特殊用法：通过stringRedisTemplate.opsForList().range(key, 0, -1)可以查询索引第一个到索引倒数第一个（即所有数据）
1、环境 redis 2、测试代码： @Resource private StringRedisTemplate stringRedisTemplate; @Test void testRedis() { String key = "testList"; String[] data = new String[]{"1_1", "1-2", "2_1", "2_2"}; Boolean flag = stringRedisTemplate.hasKey(key); if (!flag) { stringRedisTemplate.opsForList().leftPushAll(key, data); } List&lt;String&gt; range = stringRedisTemplate.opsForList().range(key, -100, -1); System.out.println("range = " + range); } 3、测试数据（假设List长度为N） 4、测试从索引倒数开始 4.1、stringRedisTemplate.opsForList().range(key, -4, -1) 从结果看：从索引倒数第4个——索引倒数第1个
4.2、stringRedisTemplate.opsForList().range(key, -3, -1) 从结果看：从索引倒数第3个——索引倒数第1个
4.3、stringRedisTemplate.opsForList().range(key, -3, -2) 从结果看：从索引倒数第3个——索引倒数第2个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c9e7c442c38aa5f281b04d4d36c36ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3309d4041b415bdd8f7499eef91e331c/" rel="bookmark">
			Windows10host文件修改方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先打开“此电脑”，定位到：
C:\Windows\System32\drivers\etc
2、使用鼠标右键单击“hosts”，弹出来的菜单中选择“属性”
3、弹出“文件属性”窗口后单击“上方的”安全“栏”。
选中“ALL APPLICATON PACKAGES”后单击“编辑”
4、同样选中“ALL APPLICATON PACKAGES”之后勾选“修改”和“写入”设置为“允许”。
完成后单击“确定”，这时候弹出“Windows安全中心”对话框，单击“是”即可
5、回到hosts文件目录。使用鼠标右键单击“hosts”文件，弹出来的菜单中选择“打开方式”。
6、这时后可以正常修改hosts文件了，完成修改后按“Ctrl+S”保存即可 192.168.18.140 CentOS140
192.168.18.141 CentOS141
192.168.18.142 CentOS142
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08408647ece72ea38d31d4c84c936e2b/" rel="bookmark">
			【Qt】【qDebug】输出std::string字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我只能说这个方法很奇葩。但不这样，还没办法😄
【Qt】【qDebug】输出std::string字符串
我有个参数是std::string，需要用QDeubg打印，
有三种方法：
std::string sourceID = "call-goodmao";
1.直接用std::cout输出
但不保证多线程打印的问题。QDebug可以用于多线程。
std::cout &lt;&lt; "sourceID : " &lt;&lt; sourceID &lt;&lt; std::endl; 2.QDubug的“&lt;&lt;”输出方法
QString qstr = QString::fromStdString(str); qDebug() &lt;&lt; "sourceID : " &lt;&lt; qstr; 3.QDebug的括号输出方法
QDebug不能直接输出std::string，需要先转换成QString；
QDebug也不能直接输出QString，还需要调用函数：qPrintable()。
QString qstr = QString::fromStdString(str); qDebug("souceID : %s", qPrintable(qstr)); 【感谢】：
感谢帮我纠正代码问题的好友😄：
louis_cheng_61
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e42970354a628f3ee2ba95516cebd693/" rel="bookmark">
			JAVA宝典----关键字(理解记忆)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 final、finally和finalize有什么区别
二、JDK中哪些类是不能继承的？
三、 assert有什么作用？
四、static关键字有哪些作用？
1.什么是实例变量？什么是局部变量？什么是类变量？什么是final变量？
2.static与final结合使用表示什么意思？
五、volatile有什么作用？
六、 instanceof有什么作用？
七、 strictfp有什么作用？
一、 final、finally和finalize有什么区别 final、finally和finalize的区别如下：
1）final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承（不能再派生出新的子类）。
final属性：被final修饰的变量不可变。由于不可变有两重含义：一是引用不可变；二是对象不可变，final指的是引用的不可变性，即它只能指向初始时指向的那个对象，而不关心指向对象内容的变化。所以，被final修饰的变量必须被初始化。一般可以通过以下几种方式对其进行初始化：
①在定义的时候初始化。
②final成员变量可以在初始化块中初始化，但不可在静态初始化块中初始化。
③静态final成员变量可以在静态初始化块中初始化，但不可在初始化块中初始化。
④在类的构造器中初始化，但静态final成员变量不可以在构造函数中初始化。
final方法：当一个方法声明为final时，该方法不允许任何子类重写这个方法，但子类仍然可以使用这个方法。另外，还有一种被称为inline（内联）的机制，当调用一个被声明为fi-nal的方法时，直接将方法主体插入到调用处，而不是进行方法调用（类似于C++中的in-line），这样做能提高程序的效率。
final参数：用来表示这个参数在这个函数内部不允许被修改。
2）finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定被执行，经常被用在需要释放资源的情况下。
3）finalize是Object类的一个方法，在垃圾回收器执行时会调用被回收对象的finalize（）方法，可以覆盖此方法来实现对其他资源的回收，例如关闭文件等。需要注意的是，一旦垃圾回收器准备好释放对象占用的空间，将首先调用其finalize（）方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。
二、JDK中哪些类是不能继承的？ 从上面的介绍可以知道，不能继承的类是那些用final关键字修饰的类。一般比较基本的类型为防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在JDK中，String、StringBuffer等都是基本类型，所以，String、StringBuffer等类是不能继承的。
三、 assert有什么作用？ 断言（assert）作为一种软件调试的方法，提供了一种在代码中进行正确性检查的机制，目前很多开发语言都支持这种机制。它的主要作用是对一个boolean表达式进行检查，一个正确运行的程序必须保证这个boolean表达式的值为true，若boolean表达式的值为false，则说明程序已经处于一种不正确的状态下，系统需要提供告警信息并且退出程序。在实际的开发中，assert主要用来保证程序的正确性，通常在程序开发和测试时使用。为了提高程序运行的效率，在软件发布后，assert检查默认是被关闭的。
assert包括两种表达式，分别为assert expression1与assert expression2，其中
expression1表示一个boolean表达式expression2表示一个基本类型或者是一个对象，基本类型包括boolean、char、double、float、int和long
assert的应用范围很多，主要包括
①检查控制流；
②检查输入参数是否有效；
③检查函数结果是否有效；
④检查程序不变量。
虽然assert的功能与if判断类似，但二者存在着本质的区别：assert一般在调试程序时使用，但如果不小心用assert来控制了程序的业务流程，那在调试结束后去掉assert就意味着修改了程序的正常逻辑，这样的做法是非常危险的；而if判断是逻辑判断，本身就是用以控制程序流程的。
需要注意的是，在Java语言中，assert与C语言中的assert尽管功能类似，但也不完全一样，具体表现为两个方面的不同：
①Java语言中是使用assert关键字去实现其功能，而C语言中使用的是库函数；
②C语言中的assert是在编译时开启，而Java语言中则是在运行时开启。
四、static关键字有哪些作用？ static关键字主要有两种作用：
第一，为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。
第二，实现某个方法或属性与类而不是对象关联在一起，也就是说，在不创建对象的情况下就可以通过类来直接调用方法或使用类的属性。
具体而言，在Java语言中，static主要有4种使用情况：成员变量、成员方法、代码块和内部类。
（1）static成员变量
虽然Java语言中没有全局的概念，但可以通过static关键字来达到全局的效果。Java类提供了两种类型的变量：用static关键字修饰的静态变量和不用static关键字修饰的实例变量。静态变量属于类，在内存中只有一个复制（所有实例都指向同一个内存地址），只要静态变量所在的类被加载，这个静态变量就会被分配空间，因此就可以被使用了。对静态变量的引用有两种方式，分别为“类.静态变量”和“对象.静态变量”。
实例变量属于对象，只有对象被创建后，实例变量才会被分配空间，才能被使用，它在内存中存在多个复制。只能用“对象.实例变量”的方式来引用
从上例可以看出，静态变量只有一个，被类拥有，所有对象都共享这个静态变量，而实例对象是与具体对象相关的。需要注意的是，与C++语言不同的是，在Java语言中，不能在方法体中定义static变量。
（2）static成员方法
与变量类似，Java类同时也提供了static方法与非static方法。static方法是类的方法，不需要创建对象就可以被调用，而非static方法是对象的方法，只有对象被创建出来后才可以被使用。
static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和成员方法，因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法。同理，static方法也不能访问非static类型的变量。
static一个很重要的用途是实现单例模式。单例模式的特点是该类只能有一个实例，为了实现这一功能，必须隐藏类的构造函数，即把构造函数声明为private，并提供一个创建对象的方法，由于构造对象被声明为private，外界无法直接创建这个类型的对象，只能通过该类提供的方法来获取类的对象，要达到这样的目的只能把创建对象的方法声明为static
用public修饰的static变量和方法本质上都是全局的，若在static变量前用private修饰，则表示这个变量可以在类的静态代码块或者类的其他静态成员方法中使用，但是不能在其他类中通过类名来直接引用。
（3）static代码块
static代码块（静态代码块）在类中是独立于成员变量和成员函数的代码块的。它不在任何一个方法体内，JVM在加载类时会执行static代码块，如果有多个static代码块，JVM将会按顺序来执行。static代码块经常被用来初始化静态变量
（4）static内部类
static内部类是指被声明为static的内部类，它可以不依赖于外部类实例对象而被实例化，而通常的内部类需要在外部类实例化后才能实例化。静态内部类不能与外部类有相同的名字，不能访问外部类的普通成员变量，只能访问外部类中的静态成员和静态方法（包括私有类型）
需要注意的是，只有内部类才能被定义为static。
1.什么是实例变量？什么是局部变量？什么是类变量？什么是final变量？ 实例变量：变量归对象所有（只有在实例化对象后才可以）。每当实例化一个对象时，会创建一个副本并初始化，如果没有显示初始化，那么会初始化一个默认值。各个对象中的实例变量互不影响。
局部变量：在方法中定义的变量，在使用前必须初始化。
类变量：用static可修饰的属性、变量归类所有，只要类被加载，这个变量就可以被使用（类名.变量名）。所有实例化的对象共享类变量。
final变量：表示这个变量为常量，不能被修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e42970354a628f3ee2ba95516cebd693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f28f9989bc9edde96e090a6807e792/" rel="bookmark">
			mybatisPlus中apply的使用以进行联表等复杂sql语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 MyBatis-Plus 中，`apply()` 方法可以用于添加任意的 SQL 片段，包括联表查询。因此，你可以使用 `apply()` 方法来处理各种类型的联表查询。
使用 `apply()` 方法的好处是可以在查询条件中直接添加原生的 SQL 片段，而不受 MyBatis-Plus 提供的常规查询条件构建方法的限制。这使得你可以更灵活地构建复杂的联表查询语句，满足特定的查询需求。
但是需要注意的是，使用 `apply()` 方法需要谨慎处理。由于 `apply()` 方法允许添加原生的 SQL 片段，这可能导致 SQL 注入等安全问题。为了避免潜在的安全风险，需要确保你添加的 SQL 片段是可信的，并且进行合适的参数化处理。
另外，使用 `apply()` 方法可能会导致查询性能下降，特别是在处理大量数据时。如果可能，建议优先考虑使用 MyBatis-Plus 提供的常规查询条件构建方法，以充分利用框架的优化能力。
综上所述，虽然 `apply()` 方法可以用于处理各种联表查询，但在使用时需要谨慎考虑安全性和性能方面的问题。
比如我想左联三张表，最后以时间倒序排序，怎么写？举例子
假设你有三张表：`user`、`order` 和 `product`，它们之间的关系是 `user` 表和 `order` 表通过 `user_id` 进行关联，`order` 表和 `product` 表通过 `product_id` 进行关联。你想要进行左联三张表，并按照时间倒序排序。
你可以使用 `apply()` 方法添加原生的 SQL 片段，来构建这个查询。
```java
QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
queryWrapper
.select("user.*, order.*, product.*") // 选择需要的列
.apply("LEFT JOIN `order` ON `user`.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f28f9989bc9edde96e090a6807e792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58919e0d081ef3dea1157936c3406579/" rel="bookmark">
			python中.ix（）函数的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在早期版本的Pandas库中，.ix函数被用于基于标签和整数位置进行数据访问和操作。然而，在较新的版本中（从Pandas 0.20.0开始），.ix函数已被弃用，并建议使用.loc和.iloc函数来替代。
在较新版本的Pandas中，.loc和.iloc函数提供了更清晰和一致的方法来进行基于标签和整数位置的数据选择和操作。这两个函数的作用如下：
.loc：基于标签（行和列的标签）进行访问和操作数据。可以使用标签进行切片、选择特定行或列、进行布尔索引等。
.iloc：基于整数位置（行和列的索引）进行访问和操作数据。可以使用整数位置进行切片、选择特定行或列、进行布尔索引等。
下面是一些示例，展示了.loc和.iloc的用法：
import pandas as pd # 创建一个示例数据框 data = {'A': [1, 2, 3], 'B': [4, 5, 6], 'C': [7, 8, 9]} df = pd.DataFrame(data, index=['X', 'Y', 'Z']) # 使用.loc进行基于标签的数据选择 print(df.loc['X']) # 选择标签为'X'的行 print(df.loc[:, 'A']) # 选择'A'列的所有值 print(df.loc['Y', 'B']) # 选择标签为'Y'的行和'B'列的交叉点的值 # 使用.iloc进行基于整数位置的数据选择 print(df.iloc[0]) # 选择第一个行的所有值 print(df.iloc[:, 1]) # 选择第二列的所有值 print(df.iloc[1, 2]) # 选择第二行和第三列的交叉点的值 请注意，在最新版本的Pandas中，.ix函数已被弃用，因此在编写新代码时，请使用.loc和.iloc函数来代替.ix函数，以确保代码的兼容性和可读性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6f3831b8b8c894a0617b21694cb3a1/" rel="bookmark">
			【无标题】vue中表单绑定v-model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单绑定v-model 表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单。
Vue中使用v-model指令来实现表单元素和数据的双向绑定。
案例的解析：
当我们在输入框输入内容时
因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。
当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变。
所以，通过v-model实现了双向的绑定。
当然，我们也可以将v-model用于textarea元素
v-model原理 v-model其实是一个语法糖，它的背后本质上是包含两个操作：
1.v-bind绑定一个value属性
2.v-on指令给当前元素绑定input事件
也就是说下面的代码：等同于下面的代码：
&lt;input type="text" v-model="message"&gt; 等同于 &lt;input type="text" v-bind:value="message" v-on:input="message = $event.target.value"&gt; v-model：radio 当存在多个单选框时
v-model：checkbox 复选框分为两种情况：单个勾选框和多个勾选框
单个勾选框：
v-model即为布尔值。
此时input的value并不影响v-model的值。
多个复选框：
当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。
当选中某一个时，就会将input的value添加到数组中。
v-model：select 和checkbox一样，select也分单选和多选两种情况。 单选：只能选中一个值。
v-model绑定的是一个值。
当我们选中option中的一个时，会将它对应的value赋值到mySelect中多选：可以选中多个值。
v-model绑定的是一个数组。
当选中多个值时，就会将选中的option对应的value添加到数组mySelects中 修饰符 lazy修饰符： 默认情况下，v-model默认是在input事件中同步输入框的数据的。也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。lazy修饰符可以让数据在失去焦点或者回车时才会更新： number修饰符： 默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。number修饰符可以让在输入框中输入的内容自动转成数字类型： trim修饰符： 如果输入的内容首尾有很多空格，通常我们希望将其去除trim修饰符可以过滤内容左右两边的空格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/346b7237281ac11827774677213eb4f9/" rel="bookmark">
			vue中v-model的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div id="app"&gt; &lt;h1&gt;{{message}}&lt;/h1&gt; &lt;!-- &lt;input type="text" v-model = "message"&gt;--&gt; &lt;input type="text" :value="message" v-on:input="valueChange"&gt; &lt;!--&lt;input type="text" :value="message" @input = "message = $event.target.value"&gt;--&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el:'#app', data:{ message:"hello,vue" }, methods:{ //每个事件在浏览器上都会生成一个事件 valueChange(event){ //获取当前input 的值 this.message = event.target.value } } }) &lt;/script&gt; 上述代码中，v-model等于：value +v-on:input实现的效果，:value是表单绑定message，表单中的值会随着message的改变而改变；而v-on：input则是message绑定了表单，此时message会随着表单中输入的数据而改变，这就是v-model实现双向绑定的原理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ae05baca4ff88fd8e36079cbbb922e/" rel="bookmark">
			Surface Reconstruction from Point Clouds without Normalsby Parametrizing the Gauss Formula
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于改进高斯公式的曲面重建 发布在ACM Transactions on Graphics期刊上的一篇关于三维点云重建模型的文章，该文章基于非数据驱动的方式，通过高斯公式去拟合点云表面的等值面，然后从等值面中提取网格曲面，使用marching cubes提取表面。 该论文的创新点为：将高斯公式参数化，以无定向点云进行表面重建表述为求解线性系统，作为i一个严谨的数学公式，可以通过非定向输入确定表面；通过高斯公式可以获取一个一致去向向外的表面。
如下核心公式：
该公式通过计算后可以得到每个点对应的水平面，可通过其等值面重建曲面。
我觉得比较优秀的点子：宽度函数，宽度函数w修改基础函数的半径，导致附近平滑的隐式场，但是论文中人工确定w的上下界，通过认为控制它的边界；且选择一个合适的w非常重要，如果过大，局部细节会消除；太小，对于提取的网格不够平滑，如何以模型的大小自适应宽度函数我觉的还是挺重要的。
上面是他的算法流程，我认为求解B的复杂度受到点云大小的影响，计算的大小是输入点云的二次方，使投入点云过大会影响算法速度。
论文中通过迭代的方式求解u，A表示一个n*n的矩阵，表示每个点之间的关系，其中上面求解出的
λ作为重建曲面marching cubes 的level。 方法分析： 采用自适应正则化和采样密度，使求解u时能够一个迭代的方式解决一个近似解。 使用的不同参数的无噪声以及统一采样模型的重建。如果没有应用正则化，对于干净的模型出现虚假的模型呈现，并且该参数不能过大，随着a的增加重建质量首先会提高之后下降。并且会影响CG的收敛速度，经过实验发现，a代表的残差，a越大，收敛越快。 尽管有这些限制，高斯公式还是提供了一个新的决解方案，当只提供原始点云是，可以寻找表面的指示函数，证明了高斯公式作为一个指导性的定理可以变成一个可行的算法来完成这项任务，可能为曲面重建工作提供一个新的视角，促进这方面的更多研究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22dcc53e2eb0e0b8ee79bb4e299ba983/" rel="bookmark">
			从0开始python学习-4.if判断语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
if 判断语句
if 和else使用
if、elif、else组合使用
True真和False假
三目运算符
if 判断语句 if：后面是根据布尔值判断条件满不满足
age = int(input()) if age &gt;= 18: print("您成年了") # 当输入的值大于等于18，则满足if判断条件，进入if判断下层代码，打印输入【您成年了】 print("您还是未成年") # 当输入的值小于18，则不满足if判断条件，不会进入if判断下层代码。直接打印【您还是未成年】 if 和else使用 else后面不能加条件只能用冒号表示，不满足的情况
scores = int(input()) if scores &gt;= 60: print("您分数及格了") # 当输入的值大于等于60，则满足if判断条件，进入if判断下层代码，打印输入【您分数及格了】 else: print("您的分数不及格") # 当输入的值小于60，则不满足if判断条件，跳转进入else下层代码。直接打印【您的分数不及格】 if、elif、else组合使用 使用elif进行多个条件的判断使用
scores = int(input()) if 60 &lt;= scores &lt; 90: print("您的分数已经及格但是还需努力") # 当输入的值在60和90区间内时，则满足if判断条件，进入if判断下层代码，打印输入【您的分数已经及格但是还需努力】 elif scores &gt;= 90: print("您的分数满足本次考试要求") #当输入的值大于等于90时，满足elif的判断条件，进入elif判断下层代码，打印输入【您的分数满足本次考试要求】 elif scores == 100: print("您的分数是满分呀") else: print("您的分数不及格") # 当输入的值小于60，则不满足if判断条件，跳转进入else下层代码。直接打印【您的分数不及格】 True真和False假 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22dcc53e2eb0e0b8ee79bb4e299ba983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cfec37cb30955a99f67a8f36d97204a/" rel="bookmark">
			Jetson安装Anaconda（miniforge3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 miniforge3 miniforge集成了Anaconda的核心工具：conda。conda是一个包和环境管理工具。因此，
miniforge里面的conda和Anaconda里面的conda完全一样；你能用Anaconda做的安装、升级、删除包等功能，miniforge都能做；你能用Anaconda做的conda虚拟环境管理，miniforge也都能做。 我下载anaconda安装时报下面错误illegal instruction（core dumped），没安装成功，故安装miniforge了。据说anaconda还没完全支持arm芯片架构。
2 下载地址 GitHub - conda-forge/miniforge: A conda-forge distribution.
3 安装 输入下面命令即可安装：
bash Minifore3-Linux-aarch64.sh
安装完成后，关闭命令终端，重新打开，可以看到前面带有（base）：
如上，创建自己的conda环境，使用命令
conda create --name 您的环境名 python=3.9
查看已创建的环境，conda env list。
4 pycharm 集成miniforge3的conda环境 如下图配置，自己手动选择路径：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7bdebcf9d3119139b2209b09f94b4a9/" rel="bookmark">
			SpringBoot使用RSA对接口的请求和相应进行加密解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1、前置：2、实现步骤：3、注意： 1、前置： 使用Spring 框架提供的两个接口RequestBodyAdvice 和 ResponseBodyAdvice ，用于在请求的参数绑定和响应结果处理过程中进行拦截和增强。本代码只实现了RSA对接口的数据进行加密解密；相较于AES的方式较为消耗性能。引用（https://blog.csdn.net/qq_41520636/article/details/130341449?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-130341449-blog-109512384.235%5Ev38%5Epc_relevant_anti_vip_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-130341449-blog-109512384.235%5Ev38%5Epc_relevant_anti_vip_base&amp;utm_relevant_index=5） 2、实现步骤： 1、创建RSA加密解密工具类2、准备三个注解，加密，解密，加密解密同时进行。3、使用反射（Utils ）来判断controller，某个接口决定使用哪个注解，如果是Encrypt注解，那么加密和解密同时进行。4、准备一个读取yml配置类（KeyConfig ）它将用于是否开启统一加密和解密，以及是否打印解密数据等配置。5、接着，配置publicKey和privateKey，大家可以通过RSAUtils的generateKeyPair方法生成 api: encrypt: rsa: publicKey: xxx privateKey: xxx showLog: true # 是否打印加密解密log true or false open: true # 是否开启加密 true or false 6、创建：EncryptRequestAdvice 和 EncryptResponseAdvice 类进行请求体和响应体的解密和加密 3、注意： 该统一加密和解密，必须是@RequestBody注解，否则RequestBodyAdvice的底层过滤器不会过滤这些请求，最终两端应用都无法通信哦。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b540b0df0a9f46803b4dd6bcd49636c2/" rel="bookmark">
			opencv imread图像读取不成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不论是imread读取相对路径还是绝对路径，如果imread读取不成功，显示Nnoe,很有可能是你的路径名字中含有中文，检查你的路径中是否含有中文，有的话将其改为英文。
1.相对路径示例： import cv2 # 假如图像文件位于当前工作目录下的"images"文件夹内 image_path = "images/my_image.jpg" # 使用相对路径加载图像 image = cv2.imread(image_path) # 检查图像是否成功加载 if image is None: print('无法加载图像') else: # 在此处进行图像处理或显示等操作 cv2.imshow('Image', image) cv2.waitKey(0) cv2.destroyAllWindows() 2绝对路径示例： 在Python中，使用绝对路径时，通常需要在路径字符串中使用反斜杠（\）来分隔目录和文件名。但需要注意的是，反斜杠在Python中也是转义字符的一种，因此在字符串中使用反斜杠时，可能需要进行转义。
对于Windows系统，路径中的反斜杠可以按照下面的方式使用：
import cv2 # 假如图像文件的绝对路径 image_path = "C:\\path\\to\\my_image.jpg" #或者 image_path = r"C:\path\to\my_image.jpg" # 使用绝对路径加载图像 image = cv2.imread(image_path) # 检查图像是否成功加载 if image is None: print('无法加载图像') else: # 在此处进行图像处理或显示等操作 cv2.imshow('Image', image) cv2.waitKey(0) cv2.destroyAllWindows() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460b127518ee4457265ea815ffba1280/" rel="bookmark">
			Apache Doris (四) ：Doris分布式部署（一） FE部署及启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Apache Doris下载
2.节点划分
3. 节点配置
​​​​​​​4. FE部署及启动
​​​​​
进入正文之前，欢迎订阅专题、对博文点赞、评论、收藏，关注IT贫道，获取高质量博客内容！
部署Apache Doris时需要分别部署FE、BE、Broker。然后再建立FE，BE两者关系。
Apache Doris 中部署多FE的思路为先在一台节点上配置部署一个FE并启动，相当于是启动Doris服务，然后配置更多的FE节点，添加到Doris服务中给该Doris的FE进行扩容，最终形成多节点FE。FE又分为Leader、Follwer和Observer三种角色，多节点FE中首先启动的FE节点自动为Leader，部署完成一个FE节点后，按照集群划分将其他Follower和Observer节点加入到FE中即可。
部署BE时我们也需要部署FE完成后，然后配置BE各个节点并启动，通过对应命令将多个BE节点添加到Apache Doris集群中即可，即创建了FE、BE两者关系。
Broker的部署是可选的，如果需要从第三方存储系统导入数据，需要部署相应的 Broker，默认提供了读取 HDFS 、对象存储的 fs_broker。Borker以插件的形成独立于Doris集群，部署时也需部署完成FE和BE后，将各个Broker节点添加到 Doris集群中。
1.Apache Doris下载 先前Apache Doris需要自己手动编译源码进行部署安装，现在Apache Doris官方提供了对应编译好的安装包，可以直接下载进行部署。Apache Doris 下载地址为:https://doris.apache.org/zh-CN/download/。这里我们下载最新1.2.1版本。
由于 Apache 服务器文件大小限制，1.2 版本的二进制程序被分为三个包：
apache-doris-fe-1.2.1-bin-x86_64.tar.xz apache-doris-be-1.2.1-bin-x86_64.tar.xz apache-doris-dependencies-1.2.1-bin-x86_64.tar.xz 其中新增的 apache-doris-dependencies 包含用于支持 JDBC 外表和 JAVA UDF 的jar包，以及 Broker 和 AuditLoader。下载后，需要将其中的 java-udf-jar-with-dependencies.jar 放到 be/lib 目录下。
2.节点划分 根据Doris官方建议，部署Doris时FE和BE分开部署，这里我们部署Doris集群时部署3个Follower（Leader和Follow统称为Follower）、2个Observer、3个BE、5个Broker，共使用5台节点完成，每个节点的使用4core和4G内存，角色和节点分布如下：
节点IP
节点名称
FE(Follower)
FE(Observer)
BE
Broker（可选）
192.168.179.4
node1
★
★
192.168.179.5
node2
★
★
192.168.179.6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/460b127518ee4457265ea815ffba1280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb24d66730fca27704d0d86d4f8c4d44/" rel="bookmark">
			javascript高阶函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#map
const app = new Vue({ el:'#app', data:{ message:"hello,vue", arr:[10,50,55,62,88,455,551,254,100,65,99] }, computed:{ nums(){ //1.需求：获取小于100的数字 // filter 回调函数有一个要求：必须返回boolean 返回true,函数内部会自动将这次回调的n加入到新的数组中 // 返回false,函数内部会自动过滤掉这次的n // let newArr = this.arr.filter(function (n) { // return n &lt; 100 // }) // console.log(newArr) // //2.需求：从小于一百的数字里面获取新数组，然后乘以2 // //map 回调函数中的m是每项的值 // let new2Arr = newArr.map(function (m) { // return m * 2 // }) // console.log(new2Arr); // //3.需求：将乘以2的新数组结果相加 // // reduce 将数组中的所有数据进行汇总 prevalue 上一次返回的数据；n是遍历的值 // let total = new2Arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb24d66730fca27704d0d86d4f8c4d44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69add9c8ddc52f837c71da8b601992d1/" rel="bookmark">
			彻底弄懂C#中delegate、event、EventHandler、Action、Func的使用和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 委托 在.NET中定义“委托”需要用到delegate关键字，它是存有对某个方法的引用的一种引用类型变量，类似于 C 或 C++ 中函数的指针。
“委托”主要有两大作用：
（1）将方法当作参数传递
（2）方法的一种多态（类似于一个方法模板，可以匹配很多个方法）
下面，给出一个展现了上述两大作用的委托代码示例：
//定义一个委托 public delegate int MyDelegate(int x, int y); //与委托匹配的一个方法 public static int Add(int a, int b) { return a + b; } //与委托匹配的另一个方法 public static int Reduce(int a, int b) { return a - b; } //示例：将委托/方法当参数传递 public static int Test(MyDelegate MD) { return MD(10, 20); } static void Main(string[] args) { int a, b, x, y; MyDelegate md; //将委托指向Add这个方法，并进行相关操作 md = Add; a = md(1, 2); b = Test(md); //再将委托指向Reduce这个方法，并进行相关操作 md = Reduce; x = md(7, 2); y = Test(md); Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69add9c8ddc52f837c71da8b601992d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4109d4a7479ee2d54e9fba1171b13cc6/" rel="bookmark">
			Python八种数据导入方法，你掌握了吗？赶紧收藏!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分析过程中，需要对获取到的数据进行分析，往往第一步就是导入数据。导入数据有很多方式，不同的数据文件需要用到不同的导入方式，相同的文件也会有几种不同的导入方式。下面总结几种常用的文件导入方法。
大多数情况下，会使用NumPy或Pandas来导入数据，因此在开始之前，先执行：
import numpy as np import pandas as pd 两种获取help的方法 很多时候对一些函数方法不是很了解，此时Python提供了一些帮助信息，以快速使用Python对象。
使用Numpy中的info方法 np.info(np.ndarray.dtype) Python内置函数 help(pd.read_csv) 一、文本文件 1、纯文本文件 1.filename = 'demo.txt' 2.file = open(filename, mode='r') # 打开文件进行读取 3.text = file.read() # 读取文件的内容 4.print(file.closed) # 检查文件是否关闭 5.file.close() # 关闭文件 6.print(text) 使用上下文管理器 – with
with open('demo.txt', 'r') as file: print(file.readline()) # 一行一行读取 print(file.readline()) print(file.readline()) 2、表格数据：Flat文件 使用 Numpy 读取 Flat 文件
Numpy 内置函数处理数据的速度是 C 语言级别的。
Flat 文件是一种包含没有相对关系结构的记录的文件。（支持Excel、CSV和Tab分割符文件 ）
具有一种数据类型的文件 用于分隔值的字符串跳过前两行。在第一列和第三列读取结果数组的类型。
filename = 'mnist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4109d4a7479ee2d54e9fba1171b13cc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f067f17ad5eab712aec1ee0ad1d4b66/" rel="bookmark">
			git 切换到指定commit以及提交并且删除分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是通过git log --pretty=oneline 查找到指定的commit ID
git checkout 4da58520
提示没有在任何一个分支上，需要新建一个分支关联变更 git checkout -b new_commit_branch
推送变更
git push
此时 新的分支回退到指定的提交ID，可以做我们的事情了。
使用完之后需要删除掉这个分支，毁尸灭迹
切换到其他分支
本地 git checkout new_branch
删除临时分支
git branch -d new_commit_branch
删除远程分支 git push origin --delete origin/new_commit_branch
查看　打完收工。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17c2d16a10af4d8e05ba37faadf7f3c/" rel="bookmark">
			小程序navigator不跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 小程序navigator不跳转第一幕第二幕第三幕 小程序navigator不跳转 第一幕 今日编写小程序时，有一个很简单的navigator没有跳转。
代码如下：
&lt;navigator url="../index/index"&gt;跳转到新页面&lt;/navigator&gt; 在位博主的博客上找到以下内容：
如果之前在app.json中设置了TabBar并且其中list中已有路径,那么在其它地方就不能再使用，使用不报错,但是也无效,不会发生跳转。
例如我在TabBar中的list中设置了一个pages/shoplist/shoplist路径，而我想在index页面中通过点击一个navigator跳转到/pages/shoplist/shoplist这个页面,就不能进行跳转.
根据以上内容，我找到自己的app.json，发现以下内容和博主情况吻合。
"tabBar":{ "list":[ { "pagePath":"pages/index/index", "text":"首页", "iconPath": "images/home1.png", "selectedIconPath": "images/home2.png" }] } 我重新设置了一个navigator路径，发现成功跳转！！！
&lt;navigator url="../text/text"&gt;跳转到新页面&lt;/navigator&gt; 成功解决。
第二幕 哭笑不得，刚刚我又弄了一次，结果还是navigator不能跳转。
结果发现是点击的位置问题，只有点击到特定地方才能跳转，而且这个特定地方是这个view的左边小角落，靠右边一点就不行。
代码为：
&lt;navigator url="../test/test"&gt;&lt;text&gt;跳转到新页面&lt;/text&gt;&lt;/navigator&gt; 如图中“跳转到新页面”中，只有点击“跳”时才可以跳转，点击“转到新页面”中的任意一个部分都不能跳转。
真的是哭笑不得，目前还没找到方法，找到再更新。 找到方法了，见第三幕。
第三幕 找到原因了。查了很多资料，确定是view覆盖导致无法选中有跳转的view。简单而言就是，一个view1盖住了那个有跳转的view2，导致view2 无法被选中或者只有一小部分没有被遮挡住的地方才能选中。
但是又不知道是哪个view的问题，刚开始我还对每个view添加背景色来判断，但是 找了好久都没找到，最后在微信开发者工具的左上角找到了个“可视化”的工具，真的是非常方便，一下子就找到了。
选中可视化后，就可以直接在模拟器上移动，很容易就发现哪个地方存在view覆盖。
借鉴：
解决微信小程序navigator点击无法跳转的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8e0f4d57bbd010fb14ff1967b0cb99c/" rel="bookmark">
			2023版IDEA安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步：浏览器输入IDEA，进入IDEA官网，点击下载进入第二步 第二步：点击红框中的Download下载IDEA最新版 第三步：双击打开下载好的IDEA 第四步：点击下一步 第五步：选中IDEA的安装路径，点击下一步 第六步：64位选64位，32位同理，勾选后点击下一步 第七步：默认，点击Install即可 第八步：等待安装即可 第九步：点击finish，完成安装 题外话 众所周知，网络安全与我们息息相关，无论是企业还是个人都应该重视网络安全。而且网络安全是一个新兴行业，人才需求量远大于供给，因此在薪资福利上具有很大的优势，但对于初学者而言，很多人依然担心前景问题，那么网络安全就业前景如何?下面为大家介绍一下。
从目前市场情况来讲，网络安全的就业前景是非常不错的，2022年的统计数据，网络安全专业的缺口已经增长到140万人。
1、就业岗位多，发展方向广 ①就业环境：网络安全可以在计算机科学与技术、信息通信、电子商务、互联网金融、电子政务等领域从事相关工作，还可以在政府机关事业单位、银行、保险、证券等金融机构，电信、传媒等行业从事相关工作。
②就业岗位：网络安全工程师、渗透测试工程师、代码审计工程师、等级保护工程师、安全运维工程师、安全运营工程师、安全服务工程师等。
2、薪资待遇可观 作为一个新兴行业，网络安全人才的市场需求远远大于供给，企业想真正招到人才，就必须在薪酬福利上有足够的竞争优势。因此，网络安全领域的薪资近年来也呈现稳步增长的态势。
根据工信部近日发布的《网络安全产业人才发展报告》，网络安全产业人才需求还在高速增长，2021年上半年，行业人才需求总量已经较去年同期增长了39.87%，不少企业为了招到人才不惜付出高薪，2021年网络安全领域的平均招聘薪酬已达到22387元/月，较去年同期提高了4.85%。平均工资较全行业偏高的主要原因是大部分公司希望通过社会招聘网站招募经验足、技术强的人才。
3、职业发展空间大 从网络安全专业学习的主要内容来看，包括linux运维、Python开发、渗透测试、代码审计、等级保护、应急响应、风险评估等。可见该网络安全专业的技术性很强，具有鲜明的专业特点，是一门能够学到真正技术的工科类专业之一。
因此，在职业发展上，网络安全专业除了就业岗位众多之外，由于专业技术性较强，在工作单位将处于技术核心骨干地位，职业发展空间很大。
4、职业增值潜力大 网络安全专业具有很强的技术特性，尤其是掌握工作中的核心网络架构、安全技术，在职业发展上具有不可替代的竞争优势。
随着个人能力的不断提升，所从事工作的职业价值也会随着自身经验的丰富以及项目运作的成熟，升值空间一路看涨，这也是为什么受大家欢迎的主要原因。
从某种程度来讲，在网络安全领域，跟医生职业一样，越老越吃香，因为技术愈加成熟，自然工作会受到重视，升职加薪则是水到渠成之事。
2022届大学毕业生月收入较高的前10个专业
本科计算机类、高职自动化类专业月收入较高。2022届本科计算机类、高职自动化类专业月收入分别为6863元、5339元。其中，本科计算机类专业起薪与2021届基本持平，高职自动化类月收入增长明显，2022届反超铁道运输类专业（5295元）排在第一位。
具体看专业，2022届本科月收入较高的专业是信息安全（7579元）。对比2018届，电子科学与技术、自动化等与人工智能相关的本科专业表现不俗，较五年前起薪涨幅均达到了19%。数据科学与大数据技术虽是近年新增专业但表现亮眼，已跻身2022届本科毕业生毕业半年后月收入较高专业前三。五年前唯一进入本科高薪榜前10的人文社科类专业——法语已退出前10之列。
“没有网络安全就没有国家安全”。当前，网络安全已被提升到国家战略的高度，成为影响国家安全、社会稳定至关重要的因素之一。
网络安全行业特点 就业薪资非常高，涨薪快 2021年猎聘网发布网络安全行业就业薪资行业最高人均33.77万！
人才缺口大，就业机会多
如果你对网络安全入门感兴趣，那么你点击这里👉CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享 如果你对网络安全感兴趣，学习资源免费分享，保证100%免费！！！（嘿客入门教程）
👉网安（嘿客）全套学习视频👈
我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
​ ​ 👉网安（嘿客红蓝对抗）所有方向的学习路线👈 对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。
​ 学习资料工具包 压箱底的好资料，全面地介绍网络安全的基础理论，包括逆向、八层网络防御、汇编语言、白帽子web安全、密码学、网络安全协议等，将基础理论和主流工具的应用实践紧密结合，有利于读者理解各种主流工具背后的实现机制。
​
面试题资料
独家渠道收集京东、360、天融信等公司测试题！进大厂指日可待！
​
👉嘿客必备开发工具👈 工欲善其事必先利其器。学习嘿客常用的开发软件都在这里了，给大家节省了很多时间。
这份完整版的网络安全（嘿客）全套学习资料已经上传至CSDN官方，朋友们如果需要点击下方链接也可扫描下方微信二v码获取网络工程师全套资料【保证100%免费】 ​ 如果你有需要可以点击👉CSDN大礼包：《嘿客&amp;网络安全入门&amp;进阶学习资源包》免费分享 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c69b87ede618330e32972aebc8a6a1/" rel="bookmark">
			rancher 节点重启无感发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里设置 时间 为120s ，保证 新节点起来后，和 老节点并行2分钟后再剔除，老节点 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/121/">«</a>
	<span class="pagination__item pagination__item--current">122/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/123/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>