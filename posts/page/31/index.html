<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2159c6394aa65f878a0766fa240fed45/" rel="bookmark">
			pm2 设置自启动服务（Windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
全局安装pm2
全局安装 pm2-windows-service
添加环境变量
安装服务
启动node程序
保存服务
全局安装pm2 npm i pm2 -g 全局安装 pm2-windows-service npm i -g pm2-windows-service 添加环境变量 右键 [我的电脑] - [属性] - [高级系统设置] - [环境变量] - 新建 [系统变量]
名称：PM2_HOME
路径：C:\Users\admin\.pm2（以下命令获取）
查看路径：命令行窗口输入 pm2 -v
pm2 -v 如果报错：可能需要管理员权限运行 cmd 需要管理员运行的原因一般是因为 node 或 npm 安装在 C 盘导致
修改 npm 装包目录参考：node安装与配置_木心操作的博客-CSDN博客
问题参考：node只能以管理员的身份运行才能正常使用_nodejs管理员方式运行_认识则是有缘的博客-CSDN博客
查看路径：上面命令看不到时试下此命令
命令行窗口输入 pm2 logs
安装服务 以管理员权限打开新的命令行窗口，执行以下命令安装pm2服务
pm2-service-install Perform environment setup ? 选 n , 回车
通过 Win+R，输入 services.msc 查看PM2服务已安装并已启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2159c6394aa65f878a0766fa240fed45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe034c67a84240e13d24fcd5d9b41e1/" rel="bookmark">
			MySQL 日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、错误日志 错误日志是MySQL中最重要的日志之一，它记录了当mysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。
该日志是默认开启的，默认存放目录/var/log/，默认的日志文件名为 mysqld.log。
查看日志位置:show variables like '%log error%'
# 修改配置文件：将此文件UUID更改一下，模拟错误操作 vim /var/lib/mysql/auto.cnf # 重启服务 -&gt; 报错 systemctl restart mysqld # 查看mysql报错信息 cat /var/log/mysqld.log 2、二进制日志 描述：二进制日志（BINLOG）记录了所有的DDL(数据定义语言）语句和DML(数据操纵语言）语句，但不包括数据查询（SELECT、SHOW) 语句。
作用：① 灾难时的数据恢复; ② MySQL的主从复制。
# 在MySQL8版本中，默认二进制日志是开启着的: show variables like '%log_bin%' MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下:
# 查看默认的日志格式 show variables like '%binlog_format%' # 设置二进制日志格式 vim /etc/my.cnf binlog_format=STATEMENT 对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志:
也可以在mysql的配置文件中配置二进制日志的过期时间、设置了之后，二进制日志过期会自动删除。
# 查看二进制日志的过期时间 show variables like '%binlog_expire_logs_seconds%'; # 设置二进制日志过期时间 vim /etc/my.cnf …… 3、查询日志 查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的。
如果需要开启查询日志，可以设置以下配置︰
show variables like 'general'; 修改MySQL的配置文件/etc/my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe034c67a84240e13d24fcd5d9b41e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074538c355ec225925e6304f6245159c/" rel="bookmark">
			Scrum的工件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们采用了Scrum进行开发方面的管理，那么所有的计划和工作都应该是透明的，这给了我们检查这些东西的机会，以便能够即时做出调整来适应即将发生的变化。
那么Scrum为我们设计了一些工件帮助我们检查我们的工作和计划，每个工件都有它的承诺，这有效地帮助我们的团队理解和检查我们的工作时否取得了工件所代表的工作或价值。
这些工件存在的目的是为了最大化关键信息的透明度。这些工件就是我们每个人在检查我们的工作进展和方向时，作出评价的最低适应标准或者说是基础。
每个工件的承诺确保了它能够提供足够的信息来增强计划和工作的透明度。这些工件各自的承诺都有自己的目标，如：
1.Product Backlog（产品待办列表）
对于产品待办列表来说，它的目标是取得Product Goal（产品目标）
2.Sprint Backlog（Sprint待办列表）
对于Sprint待办列表来说，它的目标是取得Sprint Goal（Sprint目标）
3.Increment（增量）
对于增量来说，它的目标就是实现Definition of Done（完成的定义）的要求。
由于每个工件都有自己的承诺，它们的存在增强了我们进一步应用前面实践的获得的经验（在Scrum实践中，经验是很重要的，但是它会随着检查和再适应的过程不断发展），同时这些承诺也增强了Scrum的价值。
接下来，我们来介绍一下这些工件，它们有六个。
Product Backlog（产品待办列表） Product Backlog 产品待办列表里有很多任务要做，这些任务最终需要我们的Scrum团队来在一个Sprint或多个Sprint来完成。这里任务一般是很多，不可能在一个Sprint里全部完成，因此综合所有的资源（测试、开发、商业分析、设计等）的可用度和任务优先级来确定要从这个待办列表里拿出多少个任务来在一个Sprint里完成。这些工作都会发生在做Sprint计划会议中（Sprint Planning event.）。
这个产品待办列表会不断被优化，如有些不再需要，有些需要调整，有些再描述更详细些，有些需要增加进来，有些任务需要进一步拆分等等，这些优化的工作是一个持续进行的过程，只要这个项目还要存在的价值，那么这个列表的优化是不会停止的。
在这个过程中，Product Owner可能会受到开发者的影响，开发者会帮助其理解和权衡选择出来的任务。
Product Backlog 的承诺就是要实现产品的目标。产品是传递价值的载体。它有清晰的边界、已知的涉众、定义良好的用户或客户。产品可以是一种服务，一种实体产品，或者更抽象的东西。产品目标是Scrum团队的长期目标。在开始下一个目标之前，他们必须完成(或放弃)一个目标。
Product Goal产品目标
承诺，一个精神上的东西，一旦许诺了，就会全力以赴去达成。这个魔力在很多人身上都会应验。所以在Scrum的实践中，一个软技能就是让Scrum的参考者作出相应的承诺。这也是在后来可以进行问责的一个依据，承诺巩固了Product Owner, Scrum Master 和 Developers在Scrum Sprint中的责任。产品目标是Product Backlog产品待办列表作出的承诺。产品目标贯穿了产品待办列表的始终。所以这是一个方向性问题，所以的努力都是为了达成这个目标，它也是产品在未来的状态。它必须具备战略性。换句话说，Scrum团队正在实现未来的产品，在一步一步朝着那个方向去迈进。Product Backlog产品待办列表包含了要实现这个目标的必要工作。理想一点来说，只要Scrum团队实现了产品待办列表中的必要任务就可以实现产品目标。 产品目标，是Product Owner负有责任的一个工件，其必需时常优化和沟通这个目标，具备一定的战略眼光，提高产品的成功率。
在一个Sprint结束的倒二天会举行Sprint Review会议，这是一个复盘会议，这个会议邀请整个Scrum 团队和相关的干系人和客户，目的是复盘在这个Sprint交付的增量和进度是否依然向着产品目标的。这个会议鼓励提问，如工作是如确保工作不会偏离产品目标的，有什么新的发现，有没有出什么问题等等。这些发现都会很助于做下一次的Sprint planning。
Sprint Backlog（冲刺待办列表）
Sprint Backlog是Developers的一个计划，他们会在当前这个冲刺完成里面的任务。冲刺待办列表是在Sprint planning会议中经过各方（包括Developers）深思熟虑后从产品待办列表（Product Backlog）中选出来的任务。同时，Sprint Backlog也是一个增量交付的一个行动计划表。 Sprint Backlog一定是高度可视化，也就是每天都能够清楚地看到进度、完成的情况（可视化方面的工具都可以用上，常的就是看板、燃尽图等等），这个待办列表每天都会被更新，这通常发在整个Sprint过程中，Daily Scrum每日站会是一个重要更新场所，关于Sprint Backlog的任何更新和反馈提供了足够的细节来检查我们的进度，也给作出新的调整适应新的变化提供了依据。
Sprint Backlog的承诺是实现冲刺目标Sprint Goal。这个承诺是由Developers作出的。这个承诺分解下去，就是Developers在领取了任务对那个任务的承诺，承诺在什么时候交付那一个增量。通过每个Developer的承诺，最终兑现这个Sprint的承诺。
Sprint目标还创建了一致性和焦点，鼓励Scrum团队一起工作，而不是各自独立地工作。一起工作才能更好的实现1+1大于2的效果。大家的智慧和技能才能互补。如果团队成员出各扫门前雪的情况，那么这个Scrum团队就是很不专业的。
Sprint目标会在Sprint Planning event 中产生，然后添加到Sprint Backlog中。Developers中冲刺时，只要把本次Sprint的目标放在心上即可。如果中途出现了与预期的不一样的增量或情况，那么是可以和Product Owner讨论调整Sprint Backlog的范围，尽量不影响本次Sprint的目标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/074538c355ec225925e6304f6245159c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fdb9b18e0833974c89ff21d81f512bd/" rel="bookmark">
			4《数据结构》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 绪论逻辑结构存储结构【物理结构】顺序和链式存储区别顺序表和数组区别数组和链表的区别链表结点概念链表为空条件链表文章http://t.csdnimg.cn/dssVK二叉树B树B+树【MYSQL索引默认数据结构】B树和B+树区别冒泡排序插排选排快排 绪论 数据结构：研究非数值计算程序设计中的操作对象，以及这些对象之间的关系和操作数据：客观事物的符号表示，所有输入到计算机并被程序处理的符号总称算法：为了解决某类问题而规定的一串有限长的操作序列算法标准：健壮性、有穷性、可行性、及低存储量节点：实体，有处理能力，类似网络的计算机结点：逻辑，链表中的元素，包括数据域和存储下一个结点地址的指针域数据项：数据结构的最小单位数据元素：数据的基本单位，是数据项的集合 逻辑结构 集合：无逻辑关系线性结构：有序数据元素的集合
线性表，数组，栈，队列，串非线性结构：一个结点元素可能有多个直接前趋和多个直接后继
多维数组，广义表，树、图 存储结构【物理结构】 顺序存储链式存储索引存储散列存储 顺序和链式存储区别 顺序存储链式存储数组链表数据元素放在地址连续的存储单元中数据元素存储在任意的存储单元里数据元素在存储器中的相对位置结点中指针逻辑相邻逻辑相邻物理相邻物理不一定相邻 顺序表和数组区别 顺序表数组逻辑结构角度物理存储角度顺序表 是由数组组成的线性表 数组和链表的区别 数组链表连续内存分配动态内存分配在栈上分配内存，自由度小【栈必须连续且固定大小，后进先出的取】在堆上分配内存，自由度大【堆是直接随意存取】事先固定数组长度，不支持动态改变数组大小支持动态增加或删除元素数组元素增加时，有可能会数组越界；数组元素减少时，会造成内存浪费；数组增删时需要移动其它元素使用malloc或者new来申请内存，不用时使用free或者delete来释放内存下标访问，访问效率高访问需要从头遍历,访问效率低数组的大小是固定的，所以存在访问越界的风险只要可以申请得到链表空间，链表就无越界风险 链表结点概念 头结点：在第一个结点之前的结点首元结点：链表存储的第一个结点头指针：链表第一个结点的存储位置 链表为空条件 带头结点不为空的单链表：L-&gt;next!=NULL带头结点为空的单链表：L-&gt;next==NULL不带头结点不为空的单链表：L!=NULL不带头结点为空的单链表：L==NULL带头结点的双循坏链表为空的条件：L-&gt;next==L-&gt;prior=L 链表文章http://t.csdnimg.cn/dssVK 二叉树 二叉树是一种常见的树状数据结构，它由节点组成，每个节点最多有两个子节点，分别称为左子节点和右子节点。
特点
树形结构：二叉树是一种层次结构，由根节点开始，每个节点可以有零、一个或两个子节点。这种结构使得数据可以以分层的方式进行组织和存储。节点：二叉树的每个节点包含一个数据元素，通常表示某种值或对象，以及指向其左子节点和右子节点的指针（引用）。根节点：树的顶部节点称为根节点。它是整个二叉树的起始点，所有其他节点都通过它连接。叶节点：叶节点是没有子节点的节点，它们位于树的末端。子树：每个节点的左子节点和右子节点都可以看作是一个独立的子树，这些子树也是二叉树。 B树 节点排序（节点存储：地址信息+索引+表结构中除了索引外的其他信息）一个节点可以存多个元素，元素也排序b树和b+树及其区别？ - 知乎用户的回答 - 知乎
https://www.zhihu.com/question/57466414/answer/182514854 B+树【MYSQL索引默认数据结构】 拥有B树的特点叶子节点之间有指针非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序。非节点存储：地址信息+索引、叶子节点存储：索引+表结构中除了索引外的其他信息） B树和B+树区别 B树B+树key和value都在节点上。并且叶子节点之间没有关系非叶子节点没有存value。叶子节点之间有双向指针，有引用链路。因为B树的key和value都存在节点上，因此在查找过程中，可能不用查找的叶子节点就找到了对应的值。B+树需要查找到叶子节点，才能获取值 冒泡排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
package one; public class Xu { public int[] sort_MAOPAO(int[] nums) { if (nums.length == 0 || nums.length == 1) return nums; for (int i = 0; i &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fdb9b18e0833974c89ff21d81f512bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996650246556e65001d3487d3881874d/" rel="bookmark">
			修改 Git 仓库的远程地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要修改 Git 仓库的远程地址，你可以使用以下命令：
首先，查看当前的远程地址列表，使用命令 git remote -v。如果你想修改已存在的远程地址，可以使用命令 git remote set-url &lt;remote_name&gt; &lt;new_url&gt;。在这个命令中，将 &lt;remote_name&gt; 替换为你要修改的远程仓库名，&lt;new_url&gt; 替换为新的远程地址。如果你想添加一个新的远程地址，使用命令 git remote add &lt;remote_name&gt; &lt;new_url&gt;。同样，在这个命令中，将 &lt;remote_name&gt; 替换为新的远程仓库名，&lt;new_url&gt; 替换为新的远程地址。 例如，要将远程仓库名为 origin 的地址修改为 https://github.com/example/example.git，可以使用命令 git remote set-url origin https://github.com/example/example.git。
注意：在执行这些命令之前，请确保你对新的远程地址已经拥有访问权限，并且确认地址正确无误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd5ab4dfe491ccbcaba0887d3ae0c53/" rel="bookmark">
			贝叶斯推断：细谈贝叶斯变分和贝叶斯网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 贝叶斯推断 统计推断这件事大家并不陌生，如果有一些采样数据，我们就可以去建立模型，建立模型之后，我们通过对这个模型的分析会得到一些结论，不管我们得到的结论是什么样的结论，我们都可以称之为是某种推断。
对于数据 和未知参数 ，频率学派会建立起关于数据的模型 ，模型当中会有我们的参数，如果我们把参数看成是确定的未知量。我们就可以用频率学派的观点来进行推断了。此时数据是随机量，参数是确定量，我们用数据来估计参数，也就是构成所谓的统计 ，然后用这个统计去对参数进行估计。我们还会有各种各样的关于这个估计好坏的说法，也就是有各种各样的 Metric，这是我们熟悉的频率学派的套路。
贝叶斯推断自然是在贝叶斯框架下展开推断：
贝叶斯的想法是不一样的，数据和参数之间是对称（Symmetric）的，两者同为随机变量，当我们去考察参数的时候，这个参数会有一个先验分布 ，先验分布你可以说是拍脑袋的，也可以说是天上掉下来的，总之在我们没有获得数据之前，它就有一个先验分布了。然后我们确实也会建立模型 ，这一点和频率学派当中所做的事情是完全对应的，而我们想要做的事情，并不是直接在模型上去动手，而是通过先验分布和模型，来做后验分布 。
后验分布如果能被我们掌握，那就意味着我们对于参数的认识就有一点变化：原来我们对参数有一个先验认识，但这个先验认识谈不上科学，因为这个先验认识与我们的实际的生产实践活动、与我们的观测、与我们的数据之间，它没有关系。而有了数据之后，我们必然要对先验认识进行某种更新和迭代，这种更新和迭代融汇了数据当中的信息，这才是科学，因为我们要相信观测、相信事实。而基于数据这一事实，我们所得到的关于参数的分布，那才是比较合理有效的对于参数的认知，这个认知是贝叶斯推断的核心。也就是说，当我们有了后验分布以后，我们就能够通过后验分布对我们的参数进行各种各样的推断与决策。
这里有一个有趣的事情：如果你从频率学派的观点看，参数是一个确定的未知量，你可以形成各种各样对参数的估计，就好像解方程，我们有未知数，我们通过数据建立了模型之后我们就来解这个未知数，这就显得很自然。贝叶斯呢，得出了后验分布，你说你对参数的认识究竟是进步了，还是退步了呢？这事很难说，原因在哪？原因在于，我们这里所拿到的是一个参数的分布。分布这件事情我们都不习惯，说实话，因为概率统计上的事情大家都认为是比较困难的，因此大家都是能绕就绕，能躲就躲。现在如果我们现在拿到的仅仅是个分布的话，似乎就有点老虎吃天，无从下爪，因此从分布这个角度入手，我们需要有新的观点， 乃至于新的方法。
于是我们有基于仿真（Simulation）的办法，仿真方法它的基本思路是很清晰的：就是要产生出一系列的伪随机样本，既然这个分布（后验分布）我们通过贝叶斯公式已经得到了，我们就产生出关于这个分布的一系列的伪随机样本，它在数量上没有任何的限制，想生成多少就生成多少。而基于这些伪随机样本，我们就可以做很多事情了，比如我们要想估计后验均值就很简单，只需要算一个算术平均值来估计它就可以了：
你甚至还可以做直方图来看一看这个后验分布到底长什么样子。不用担心因为数据量太小，导致直方图做出来很粗糙。所以仿真的方法真的是一个好方法。关于仿真（MCMC）我会在另一篇文章详细展开，这篇文章介绍另一种跟仿真并重的方法：基于近似（Approximate）的方法。
2. 变分贝叶斯（Variation Bayes） 变分方法跟仿真方法都是为了对付复杂的后验分布而产生的。因为后验分布的复杂程度往往很高，往往是多元的，这很难用简单的随机数发生器把他给产生出来，MCMC实际上是相当复杂的随机数发生器，因为你首先要构造这个马氏链，然后你得 run 这个马氏链，然后你还得确保这个马氏链 run 到了马氏链的稳态里面去，然后你的采样才能有效地获取。这样不仅消耗的算力巨大，而且 online 的计算很难，一般都是 offline，所以你不能对它的实时性有太高的期待。那么如果我们不愿意去面对这样的复杂性，我们就可以去尝试使用这种近似的手段去处理。当然，在面对这样的复杂性的时候，还有另外的一种处理手段，就是分析其中的分布结构，然后有效地利用这个分布结构来为我服务，这就是贝叶斯网络（Beyasian Network）干的事情：利用网络来刻画分布结构。
变分贝叶斯是这么一个思想：我先找到一个已知的分布 ，就跟找MCMC的那个Proposal矩阵的思想一样。这个已知分布 比较容易，各种性质都很好算。然后我们用这个 通过某种方式来近似后验分布。
其实大家可以设身处地地想一想，如果是你，你能不能产生出这样的想法，如果不能，究竟是思维上的哪一块受到了限制，还是哪一部分意识受到了限制，因为这个想法说出来大家都觉得很自然。但是近似这件事，是我们中国学生普遍的盲点，是因为我们长期应试，我们习惯于任何一个问题都有精确答案，太习惯了，只要那个答案不是2，我得出2.01、2.001都是Nonsense没有任何意义的，我的分就被扣光了。而实际上，在科学里，尤其是在工程上，如果这个值为2，你能得出2.001这多数情况就OK了。当然你说有误差限，没问题，你把误差限、工程里的要求说出来，然后我的目标并不在于说去找到2那么一个准确的值，只要我能通过某种方法，能够让我们的答案与2之间的那个差小于你的误差限，这个就已经是满分了。
我如果想用g来近似我的后验分布，我首先要解决一个什么问题？首先要解决一个 距离Metric 的问题。没有距离，也就根本谈不上近似。
我们在这里只选一种距离：Kullback-Leibler distance / divergence（KL距离 / 散度）
Kullback-Leibler理论上来讲只是一种伪距离，不是真正意义上的距离。因为距离的三个条件：
KL散度只有第一条是OK的，其余两条都不满足。不过即便如此，这个距离人们也用的最多，因为它比较容易算。 可以看到
我们也把叫做：evidence lower bound(ELBO)。同时，最小化也就是极大化ELBO
变分是一种以函数为自变量的优化：
这里我们提供变分的两种路径，第一种方法叫做 均场（Mean Field Approch）
2.1. 均场假定（Mean Field Assumption） 我们对g有一种先验的结构添加。这种先验的结构反映了我们希望能够用尽可能简单的方法来完成我们的变分/近似。
假设θ能写成两个部分 ，g(θ)也能分拆成两个部分 。这其实是在做分离变量（Seperated Variable）。这对我们有什么好处呢？我们来看一下：
第一项： 使用分离参数的原因就在于： 维度太高，我们企图把它简单化，把它分离成更小的一部分一部分，然后在这些分离后的变量上进行轮转。把这个优化从高维简化成低维，我们在优化的时候其实经常这么做：我不想在高维空间里直接做搜索，所以我先固定住一些维度，转而优化某一维，优化完了这一维之后我再把这一维固定住，再去优化另外一维，如此反过来倒过去。这么干虽然不能够保证它一定可以找到最优的。但是我们反正已经开始近似了，就不用有啥心理压力（反正目标不是那100分，也许及格就够了）。
第二项： 里头那个积分 ，其中， 被认为是已经被我们掌握的结构，所以复杂的根源来自于 ，但是我们发现它的前面有一个 ，一般来讲（虽然算不上定律，但这是一般性的规律）分布加个log就简单多了。因为多数情况下，我们处理的分布都是指数族，就跟高斯一样，指数上方可能是一次项、二次项，总之指数族一旦一log就简单多了，所以这是在一个变简单的函数上来用已知分布进行期望。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cd5ab4dfe491ccbcaba0887d3ae0c53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2deb632257d495be3fd3f544997867f8/" rel="bookmark">
			jvm | 垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		垃圾回收相关算法 垃圾回收算法的演进包括标记和清除两个主要阶段。初始阶段采用标记清除算法，通过标记存活对象，再清除未标记的垃圾对象。为了解决标记清除算法的空间碎片问题，引入了标记整理算法，它在标记的基础上将存活对象整理到内存的一端，减少碎片。复制清除算法则将内存划分为两个区域，通过复制存活对象至一块区域，再清除未复制的区域，解决了碎片问题。
随着对象生命周期的不同，引入了分代垃圾回收算法，标记阶段采用可达性分析， 清除阶段将堆内存划分为新生代和老年代，根据不同特性分别采用适合的回收算法。在标记阶段，这些算法都依赖于可达性分析，通过根对象集合追踪引用链，确定存活对象。
在 JDK 1.8 中，为提高效率和适应多核处理器，引入了并行收集器，采用多线程并行处理垃圾回收。同时，G1 收集器作为一种新型收集器，引入了分区概念，以更灵活、高效地管理内存，逐步替代了 CMS（Concurrent Mark-Sweep） 收集器。这些演进的算法和技术共同构成了现代 Java 虚拟机垃圾回收的体系。
标记阶段相关算法 引用计数算法 在Java虚拟机（JVM）中，堆是存放几乎所有Java对象实例的地方。在执行垃圾回收之前，首要任务是区分内存中的存活对象和已经死亡的对象。只有被标记为已经死亡的对象，垃圾回收才会在执行时释放其占用的内存空间，这个过程通常称为垃圾标记阶段。
那么在JVM中，是如何判断一个对象是否死亡的呢？简而言之，当一个对象不再被任何存活对象引用时，就可以被判定为已经死亡。
引用计数算法（Reference Counting）相对简单，为每个对象维护一个整型的引用计数器属性，用于记录对象被引用的情况。
对于一个对象A，只要有任何一个对象引用了A，A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
优点：
实现简单，垃圾对象容易辨识；
判定效率高，回收没有延迟性。
缺点：
需要单独的字段存储计数器，增加了存储空间的开销；
每次赋值都需要更新计数器，伴随着加法和减法操作，增加了时间开销；
无法处理循环引用的情况，是引用计数算法的致命缺陷，会出现内存泄露问题。
由于引用计数算法的缺陷，Java的垃圾回收器并未采用这种算法，而是选择了更为可靠的可达性分析算法。可达性分析通过一系列的根对象出发，追踪对象之间的引用关系，判断对象的存活状态，从而决定是否进行回收。
可达性分析算法 概念：
可达性分析算法，也称为根搜索算法或追踪性垃圾收集，是一种用于判断对象是否存活的垃圾回收算法。相对于引用计数算法，可达性分析算法不仅实现简单且执行高效，更重要的是能够有效解决引用计数算法中可能发生的循环引用导致的内存泄漏问题。
思路：
GC Roots集合（根集合）： 可达性分析算法以GC Roots集合为起始点，GC Roots是一组必须保持活跃的引用。这些引用可以是虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象，以及本地方法栈中JNI（Java Native Interface）引用的对象。
搜索可达对象： 从GC Roots集合出发，按照从上至下的方式搜索被GC Roots集合所连接的目标对象是否可达。这个搜索的过程构成了引用链（Reference Chain）。
标记存活对象： 使用可达性分析算法，内存中的存活对象都会被GC Roots集合直接或间接连接。如果一个对象能够通过引用链与GC Roots集合相连，则被认为是存活对象。只有能够被连接到GC Roots集合的对象才是存活对象。
标记垃圾对象： 如果目标对象没有任何引用链相连，说明该对象不可达，即已经死亡，可以标记为垃圾对象。这些垃圾对象将在后续的垃圾回收阶段被清理。
可达性分析算法通过判断对象是否与GC Roots集合相连，实现了对存活对象和垃圾对象的准确区分，避免了引用计数算法中循环引用导致的内存泄漏问题。这一算法为现代垃圾回收器的实现提供了有效的基础。
GC Roots GC Roots 是一组必须保持活跃的引用，它们作为起始点，帮助可达性分析算法判断对象的存活状态。以下是可能成为 GC Roots 的对象：
虚拟机栈中的引用： 对象被局部变量表中的引用变量所引用，即使是方法调用尚未完成，这些引用仍然有效。
本地方法栈中 JNI 引用的对象： JNI（Java Native Interface）是 Java 调用本地语言的接口，本地方法栈中保存了对 Java 对象的引用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2deb632257d495be3fd3f544997867f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d25be182a696cca3de2033f87709545/" rel="bookmark">
			小程序购物商城搭建开发分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序商城作为现代商业模式的重要组成部分，具有巨大的发展潜力和商业价值。通过搭建一个功能完善、用户友好的小程序商城，您将能够提供便捷的购物体验，吸引更多的用户并实现商业增长。在进行小程序商城开发搭建之前，我们需要对项目进行充分的需求分析和规划。首先，明确小程序商城的目标用户群体、定位和特色，以便提供个性化的服务和满足用户需求。其次，详细列举小程序商城所需的功能和模块，如商品展示、购物车、订单管理、支付系统等，并根据优先级进行排序。在技术方面，根据自己的预算，选择适合的技术框架和开发语言。同时，确保小程序商城的界面设计美观、用户友好，提供良好的用户体验。在安全性方面，需要采取必要的措施来保护用户的隐私和数据安全。技术搭建完成之后，还需要进行小程序商城的推广工作。通过社交媒体宣传、搜索引擎优化、广告投放等方式，提高小程序商城的曝光度和用户量，推动商业价值的实现。搭建一款好的商城需要高效、专业的态度搭建一款出色的小程序商城，有的时候需要专业人士提供全程技术支持和维护服务。需要共同创造出一款优秀的小程序商城App，为业务带来巨大的成功和增长。
需求分析与设计在开发小程序商城之前，首先需要进行需求分析和设计，明确商城的功能和特点，包括商品展示、购物车、订单管理、支付等。根据需求设计UI界面，确定所需技术和框架。技术选型根据需求分析和设计，选择适合小程序商城开发的技术栈。前端开发可以选用流行的框架如React Native或Weex，后端开发可以选用Node.js或Java等。同时考虑到小程序的特点，可能需要使用微信小程序提供的API或第三方SDK。前端开发开始设计并开发用户界面，包括首页、商品列表、商品详情、购物车、订单管理等。使用HTML、CSS和JavaScript等技术进行开发，并确保小程序在不同设备上的兼容性和响应式布局。通过合理的页面设计和交互方式，提高用户体验。后端开发搭建服务器环境，处理用户请求和数据存储。根据需求设计并开发后台管理系统，包括商品管理、订单管理、用户管理等功能。使用合适的数据库进行数据存储和管理，如MySQL或MongoDB。确保后端的安全性和性能。支付集成接入微信支付、支付宝等支付平台，实现在线支付功能。确保支付流程安全可靠，并提供退款、发票等功能。
我们可以构建一个功能完善、稳定可靠的小程序商城。然而，开发只是一个开始，真正成功的小程序商城需要不断地改进和创新，以满足用户的需求并保持竞争力。只有持续关注市场动态和用户反馈，才能在激烈的竞争中脱颖而出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a60307fcea3fe2c1f43af51382691513/" rel="bookmark">
			STM32通用定时器-输入捕获-脉冲计数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、知识点 编码器
两相编码器（正交编码器）：两相编码器由 A 相和 B 相组成，相位差为 90 度。当旋转方向为顺时针时，A 相先变化，然后 B 相变化；当旋转方向为逆时针时，B 相先变化，然后 A 相变化。通过检测相位差变化，可以确定旋转的方向。STM32 单片机可以使用定时器的正交编码器模式（Encoder Mode）来实现两相编码器的接口。
四相编码器：四相编码器由 A 相、B 相、C 相和 D 相组成，相位差为 90 度。通过检测相位差变化和不同相位的信号变化情况，可以确定旋转的方向。STM32 单片机可以使用定时器的四相编码器模式（X4 Encoder Mode）来实现四相编码器的接口。
编码器接口
编码器的两个输入引脚，就是每个定时器的CH1和CH2引脚，CH3和CH4不能接编码器。
最终的实验现象，编码器有两个输出，一个是A相，一个是B相，然后接入到STM32，定时器的编码器接口，编码器的接口自动控制定时器时基单元中的CNT计数器，进行自增或自减。比如初始化之后，CNT初始值为0，然后编码器右转，CNT就++，右转产生一个脉冲，CNT就加一次，比如右转产生10个脉冲后，停下来，那么这个过程CNT就由0自增到10，停下来，编码器左转，CNT就–，左转产生一个脉冲，CNT就自减一次， 比如编码器再左转产生5个脉冲，那CNT就在原来10的基础上自减5，停下来。
编码器接口，其实就相当于是一个带有方向控制的外部时钟，同时控制着CNT的计数时钟和计数方向，这样CNT的值就表示了编码器的位置。如果我们每隔一段时间取一次编码器的值，再把CNT清零，那么每次取出来的值就表示了编码器的速度。
编码器测速实际上就是测频法测正交脉冲的频率，CNT计次，然后每隔一段时间取一次计次，这就是测频法的思路。编码器计次能根据旋转方向，不仅能自增计次还能自减计次，是一个带方向的测速。
每个高级定时器和通用定时器都拥有1个编码器接口。 二、框图 三、编码器计数操作 解释：当Tl1先产生脉冲，Tl2后产生脉冲。（A相先变化，B相后变化）时电机正转，计数器开始计数CNT++。当产生毛刺时，CNT不计数。Tl2先产生脉冲，Tl1后产生脉冲。（B相先变化，A相后变化）时电机反转，计数器CNT–。当产生毛刺时不计数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0e6b2a0c505c0a63bd9902358561db/" rel="bookmark">
			全网最简单vscode使用Makefile调试多文件的C/C&#43;&#43;代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 vscode调试C/C++教程很多，操作麻烦，这里试图找到一个最简单的使用vscode调试C/C++代码的方法。这里是使用Makefile的多文件方式。
测试文件 tree . ├── func.c ├── func.h ├── main.c └── Makefile fun.c
#include &lt;stdio.h&gt; #include "func.h" int foo1(int a) { int b = ++a; printf("This is foo1 %d\n",b); } fun.h
int foo1(int a); main.c
#include &lt;stdio.h&gt; #include "func.h" int main() { int a = 1; printf("Hello, I am coming %d\n", a); foo1(a); return 0; } Makefile
CC = gcc CFLAGS = -g LDFLAGS = TARGET = test SRCS = $(wildcard *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b0e6b2a0c505c0a63bd9902358561db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b358a417d97fab3f423b3d89baf4a793/" rel="bookmark">
			切换列表html
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;STYLE type=text/css&gt;
OL LI {
MARGIN: 8px
}
#con {
FONT-SIZE: 12px; MARGIN: 0px auto;
}
#tags {
PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px 0px 0px 10px; PADDING-TOP: 0px; HEIGHT: 23px
}
#tags LI {
BACKGROUND: url(images/tagleft.gif) no-repeat left bottom; FLOAT: left; MARGIN-RIGHT: 1px; LIST-STYLE-TYPE: none; HEIGHT: 23px
}
#tags LI A {
font-size: 16px;
margin: 0 2rem; FLOAT: left; PADDING-BOTTOM: 0px; COLOR: #999; LINE-HEIGHT: 23px; HEIGHT: 23px; TEXT-DECORATION: none
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b358a417d97fab3f423b3d89baf4a793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d34726306960a39eeaeb08d592acf00/" rel="bookmark">
			PHP篇——html&#43;php实现表单提交的一个简单例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html： &lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表单示例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 创建表单 --&gt; &lt;form action="form.php" method="post" id="myForm"&gt; &lt;!-- 普通文字输入框 --&gt; &lt;label for="normalText"&gt;普通文字：&lt;/label&gt; &lt;input type="text" id="normalText" name="normalText" value="请输入普通文字"&gt;&lt;br&gt;&lt;br&gt; &lt;label for="picture"&gt;图片&lt;label&gt; &lt;input type="file" single accept=".png,.jpg" id="pictureAddr" name="pictureAddr"&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 用户名输入框 --&gt; &lt;label for="username"&gt;用户名：&lt;/label&gt; &lt;input type="text" id="username" name="username"&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 密码输入框 --&gt; &lt;label for="password"&gt;密码：&lt;/label&gt; &lt;input type="password" id="password" name="password"&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 提交按钮 --&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt; var fileUP = document.getElementById('pictureAddr'); var myForm = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d34726306960a39eeaeb08d592acf00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7faa363384fd848ad21ac77ad1dfa89e/" rel="bookmark">
			python路径获取那些事儿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、获取当前路径 1 os.getcwd()
2 os.path.abspath(__file__)
3 os.path.realpath(__file__)
1、os.getcwd()
在Python中，为了获得当前的目录与当前正在执行的脚本的文件路径，你可以使用来自于Python标准库的os与os.path模块 示例如下：
import os # Get the current directory current_directory = os.getcwd() # Print the current directory print("The current directory is:", current_directory) 在该示例中，我们导入os模块，使用os.getcwd()方法来获得当前的路径（字符串的形式）。然后我们打印了当前的路径
需要注意： 获取当前路径使用os.getcwd()并不总是有效的，实际上这个方法显示的是执行脚本的路径。getcwd == get current working directory，即获取当前工作目录。
例如，有个脚本test.py中在D:\test目录下，test.py内容如下：
import os print(os.getcwd()) 此时获取到的路径为D:\test
当在E盘下执行python D:\test\test.py时,获取到的路径为E:\ 故一般不建议使用该方法获取当前路径，当代码路径迁移或执行路径发生变化时，可能会出现问题。
2、os.path.abspath(file)
为了获得当前正在执行的脚本的文件路径，你可以将__file__属性与os.path模块结合使用：
import os # Get the absolute path of the currently executing script script_path = os.path.abspath(__file__) # Print the script path print("The script path is:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7faa363384fd848ad21ac77ad1dfa89e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89dcf0e442f07f807530bdc91dc18774/" rel="bookmark">
			AI绘画-通义万相
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通义万相_AI创意作画_AI绘画_人工智能-阿里云 (aliyun.com)
画的还不错
二次元，请生成16张符合微信表情包尺寸（240像素 × 240像素）的Q版白色约克夏犬表情图片，每张图片文件大小应在几KB到几十KB之间。设计时应采用色彩鲜明、大眼睛和圆润脸型的漫画风格，包含 沉思 微笑 厌恶 大笑 震惊 皱眉 哭泣 咬唇 掀嘴 翻白眼 眨眼 脸红 打哈欠 紧张 担忧
凝视等常见情绪。这些表情应易于识别和理解，适合各种年龄和背景的微信用户使用。在生成完成后，请确保表情在微信中显示清晰、加载速度快，并能准确传达相应的情绪。
酷熊智绘-支持Midjourney绘画中文专业版及AI写作-已支持最新v6 (dmw61.com)
1. 沉思：约克夏犬坐在地上，手托着下巴，眼神远望。背景是蓝天白云和绿草地。表情轻柔，透露出思考的气息。 2. 微笑：约克夏微笑着，眼睛弯成月牙形，嘴巴微微张开。背景是粉色爱心和小星星。表情温馨可爱，适合用于表达友好、感谢等情绪。 3. 厌恶：约克夏皱着鼻子，眉头紧皱，嘴巴扁扁的。背景是粉红色的呕吐表情符号。表情生动有趣，适合用于表达反感、厌烦等情绪。 4. 大笑：约克夏哈哈大笑，嘴巴张得很大，眼睛也变成了两个弯弯的小月牙。背景是黄色的笑脸符号。表情活泼欢快，适合用于表达开心、幸福等情绪。 5. 震惊：约克夏张大了嘴巴，眼睛瞪得溜圆，全身僵硬。背景是紫色的惊讶表情符号。表情夸张生动，适合用于表达惊奇、震惊等情绪。 6. 皱眉：约克夏皱着眉头，眼神阴郁，嘴巴微微咧开。背景是蓝色的忧愁表情符号。表情沉重消极，适合用于表达不满、烦恼等情绪。 7. 哭泣：约克夏哭得稀里哗啦，眼泪直流，嘴巴扁扁的。背景是深蓝色的哭泣表情符号。表情悲伤可怜，适合用于表达伤心、难过等情绪。 8. 咬唇：约克夏咬着下嘴唇，眼神坚定。背景是红色的勇气表情符号。表情坚毅决绝，适合用于表达决心、勇气等情绪。 9. 紧张：约克夏紧闭双眼，全身发抖。背景是绿色的紧张表情符号。表情紧张害怕，适合用于表达紧张、害怕等情绪。
100个中文AI绘画关键词汇总，附效果图！ (pixso.cn)
去掉背景
https://fabiaoqing.com/bgremove
如何将自制的表情包发布到微信平台？ - 知乎 (zhihu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221f00bcd37f5dfb31ab63edbc95b097/" rel="bookmark">
			如何制作自己的数字人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何制作自己的数字人呢？不用担心平台的使用授权，也不用担心哪一天自己自媒体被号被无故封杀，那么SadTalker将是你的首选，他是完全开源的数字人软件，现已达到Apache2的授权，完全自由的开源软件。作者自己试着搭建效果还不错，口形模拟、脖子的扭动、眨眼晴等都非常的自然。
制作方法
1、创建python环境
conda create -n sadtalker python=3.8
如果使用英伟达的GPU，你还需要安装pytorch,版本1.12.1
2、安装视频处理工具
conda install ffmpeg
3、下载sadtalker的原代码：
git clone https://github.com/Winfredy/SadTalker.git将代码完整克隆。
4、进入下载目录，安装相关依赖
pip install -r requirements.txt
5、下载预训练模型
https://github.com/OpenTalker/SadTalker/releases
将下载的模型放在checkpoints文件夹下，如果没这个文件夹就自己建一个。
6、将gfpgan\weights\GFPGANv1.4.pth目下的权重文件考到anaconda3的weights目下。举个例子：
gfpgan\weights\GFPGANv1.4.pth 剪切到虚拟环境的 D:\Anaconda3\envs\sadtalker\Lib\site-packages\gfpgan\weights 这个目录下
7、语音文件放到：sadTalker\examples\driven_audio 目录下。语音文件可以自己录制，如果测试也可以用目下面已经录好的wav文件。
8、找一张个人的正面照片放到：sadTalker\examples\source_image 目录下。
接下来就可以生成数字人了:
python inference.py --driven_audio D:\project\SadTalker\examples\driven_audio\map_chinese.wav --source_image D:\project\SadTalker\examples\source_image\full_body.png --enhancer gfpgan --preprocess full --stil
安装git和anaconda，如果不会安装可以参考我在CSDN上的的相关文档，里面有详细的安装方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce01567352706755c839689ff0c5b944/" rel="bookmark">
			GnuTLS recv error (-110): The TLS connection was non-properly terminated.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 bug 解决方案：参考 GnuTLS recv error (-110): The TLS connection was non-properly terminated. 解决方案： apt-get install gnutls-bin git config --global http.sslVerify false git config --global http.postBuffer 1048576000 参考 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/defe02cd6388624bdeab3130cf6c153e/" rel="bookmark">
			自存react crash course（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建一个react 项目
确保有node.js
创建名为react-task-tracker的react项目
npx create-react-app react-task-tracker 启动项目
npm start 2.项目结构
所有组件都是放在src下面的
3. jsx
// jsx语法 和html很像，class用的是className来使用css的样式 &lt;div className="App"&gt; &lt;header className="App-header"&gt; {/* 动态的变量 */} &lt;img src={logo} className="App-logo" alt="logo" /&gt; a.jsx 只能返回一个元素
b.返回的元素可以是一个空标签
c.jsx的变量
d.jsx {}中执行语句
// react的组件可以是一个函数 也可以是一个class
4.快捷插件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bb8b582d6c8b0a7d2a448ba5c1a0d3e/" rel="bookmark">
			多线程和JVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，多线程实现的四种方式 1. 实现Runnable接口 普通实现： public class MyRunnable implements Runnable { @Override public void run() { System.out.println("线程执行中..."); } } public class Main { public static void main(String[] args) { Thread thread = new Thread(new MyRunnable()); thread.start(); } } Lambda表达式：
public class Main { public static void main(String[] args) { Thread thread = new Thread(() -&gt; System.out.println("线程执行中...")); thread.start(); } } 2. 实现Callable接口 普通实现方式：
import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class MyCallable implements Callable&lt;String&gt; { @Override public String call() throws Exception { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bb8b582d6c8b0a7d2a448ba5c1a0d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55479d05af10dfe2ae6fe71352c38483/" rel="bookmark">
			WPF 入门教程DispatcherTimer计时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.zhihu.com/tardis/bd/art/430630047?source_id=1001
在 WinForms 中，有一个名为 Timer 的控件，它可以在给定的时间间隔内重复执行一个操作。WPF 也有这种可能性，但我们有DispatcherTimer控件，而不是不可见的控件。它几乎做同样的事情，但不是将它放在表单上，​​而是专门从代码隐藏代码中创建和使用它。
DispatcherTimer 类的工作方式是指定一个时间间隔，然后订阅每次满足该时间间隔时将发生的Tick事件。在调用Start()方法或将IsEnabled属性设置为 true之前，不会启动 DispatcherTimer 。
让我们尝试一个简单的例子，我们使用 DispatcherTimer 创建一个数字时钟：
&lt;Window x:Class="WpfTutorialSamples.Misc.DispatcherTimerSample" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="DispatcherTimerSample" Height="150" Width="250"&gt; &lt;Grid&gt; &lt;Label Name="lblTime" FontSize="48" HorizontalAlignment="Center" VerticalAlignment="Center" /&gt; &lt;/Grid&gt; &lt;/Window&gt; using System; using System.Windows; using System.Windows.Threading; namespace WpfTutorialSamples.Misc { public partial class DispatcherTimerSample : Window { public DispatcherTimerSample() { InitializeComponent(); DispatcherTimer timer = new DispatcherTimer(); timer.Interval = TimeSpan.FromSeconds(1); timer.Tick += timer_Tick; timer.Start(); } void timer_Tick(object sender, EventArgs e) { lblTime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55479d05af10dfe2ae6fe71352c38483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cdf22c5e5636666f380a648ee8ff9c/" rel="bookmark">
			Python安装Pandas库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：cmd命令行执行pip install pandas
1.Windows+R，输入cmd打开命令行窗口，输入pip install pandas。
如下图所示
2.若出现下图所示的告警，说明版本有冲突。
按照提示输入pip install --upgrade pip，对pip进行升级
3.若出现下图所示的升级报错，输入python -m ensurepip，python -m pip install --upgrade pip
4.再输入pip install pandas进行安装
5.若依然安装报错，可采取方法二进行安装
方法二：找到pandas下载库，然后通过pip install [pandas包路径]安装
1.进入网站 https://www.lfd.uci.edu/~gohlke/pythonlibs/
Ctrl+F,输入pandas,找到需要的版本下载即可。
比如我要下载的是pandas-1.4.3-cp310-cp310-win_amd64.whl。
下载后保存到磁盘某一个路径下
2.打开cmd命令行，输入pip install [pandas包路径]
方法三：如果报超时的错，是因为国外的源文件在国内下载比较慢，可更换为国内的镜像。
使用清华大学的pandas镜像进行安装：
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas
下载很快，且无报错。
最后执行一下python -m pip list命令查看已经安装的包，可以看到不光pandas已经装好了，还安装了numpy库。
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，Python自动化测试学习等教程。带你从零基础系统性的学好Python！
👉[[CSDN大礼包：《python安装包&amp;全套学习资料》免费分享]]（安全链接，放心点击）
一、Python大礼包 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、 Python电子书 三、入门学习视频 四、 Python爬虫秘笈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、 数据分析全套资源 六、python副业兼职与全职路线 上述这份完整版的Python全套学习资料已经上传CSDN官方，如果需要可以微信扫描下方CSDN官方认证二维码 即可领取
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5cdf22c5e5636666f380a648ee8ff9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc312b2b849c75d3e4f1b513939b7aa9/" rel="bookmark">
			烟花燃放如何管控？智能分析网关V4烟火检测保障烟火安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、方案背景 随着元旦佳节的热潮退去，春节也即将来临，在众多传统的中国节日里，烟花与烧纸祭祀都是必不可少的，一方面表达了人们对节日的庆祝的期许，另一方面也是一种对故者思念的寄托。烟花爆竹的燃放不仅存在着巨大的安全隐患，还极易污染环境，虽然各地在节日来临之前都会发布禁燃禁放烟花爆竹的倡议书，但也难挡人们燃放热情，如何最大限度地管制烟花爆竹燃放，除了人员的实时劝阻，人工智能也能起到极大助力。
二、方案概述 基于烟花爆竹燃放现场环境制约条件与视频建设需求，TSINGSEE青犀智能分析网关通过太阳能供电模组+4G摄像机+智能分析网关V4架构，建立野外烟花燃放智能视频监管平台，满足野外空旷少人监管、无人值守的智能化建设需求。
1、野外供电
使用太阳能电池模组进行光电转化，将白天的太阳光转化为电能，在为设备供电的同时，还能进行电池蓄电。在夜间与雨水天气时，仅靠内置的蓄电都可支撑监控摄像机持续工作5天以上。若用户需要更长待机时间，还有更大AH的电池组进行选择。
2、4G网络传输
在野外或较为偏僻的城市周边，通过配置流量卡，即可解决视频网络传输问题。通过4G网络可将监控摄像头采集的监控音视频数据传输到安防监控系统EasyCVR平台，在平台实现流畅观看现场监控视频，实时了解现场情况。平台支持设备通过4G、5G、WIFI、有线等方式进行视频流的接入和传输，十分便捷。
3、智能分析网关
将部署在各地的视频流接入到智能视频分析网关V4中，利用V4的智能分析算法，对户外视频进行实时监控与分析，及时发现户外烟火情况，并实时发出告警，通知后台管理人员进行解决，还可根据语音联动，进行声光告警或语音驱赶，最大限度避免消防事故发生。
智能分析网关V4在户外烟火检测场景中还可配备以下算法：
区域入侵检测：在野外草垛、干草和草地树木密集处，利用电子围栏划分区域，一旦有人闯入该区域，就会立即发出告警并自动截图或录屏。烟雾检测：可以对燃烧过程中烟雾形成的不规则运动特征，如呈现出不同的颜色，烟雾从无到有的形状、面积、反射频率等持续性变化进行辨识和分析判断，从而形成对烟雾的判断并触发报警。火焰识别：对燃烧过程中火焰的图像特征，呈现出的不同颜色，火焰从无到有的形状、面积、闪烁频率、强度等增长性和持续性变化进行辨识与其成的火焰处以分析判断。人员摔倒检测：户外人员稀少 ，一旦发生火灾人员就极易产生慌乱，从而导致摔倒，引发事故，在烟火检测的同时配备摔倒检测算法，可以进一步保护人员安全，减少事故损失。 4、视频融合平台
视频汇聚平台EasyCVR具备视频融合汇聚能力，支持多协议接入、多格式视频流分发，可支持的主流标准协议有国标GB28181、RTSP/Onvif、RTMP等，以及支持厂家私有协议与SDK接入，包括海康Ehome、海大宇等设备的SDK等。
EasyCVR视频能力非常丰富，具体可实现视频监控直播、视频轮播、视频录像、云存储、回放与检索、智能告警、服务器集群、语音对讲、云台控制、电子地图、H.265自动转码H.264、平台级联等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3e5ce0cf4fd2488e61032a27b6999f/" rel="bookmark">
			【一对一小组】2024年有三AI-CV中阶-GAN组发布，如何循序渐进地学习好生成对抗网络原理与应用...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年有三AI-CV中阶-GAN组正式发布！有三AI已经推出了CV初-中-高级培养计划（原名有三AI-CV季划），这是我们的终身计算机视觉学习小组。
该培养计划具有以下特点：
【系统性】配套有非常完备的理论与实践
【永久性】不限制学习期限，一直有效
【成长性】内容保持更新，不额外收费
【专业性】原创书+视频讲解+真实项目锻炼
【丰富性】数千页PPT，文档，项目等
【权威性】工业界资深背景辅导老师，弱运营属性
什么是有三AI-CV中阶-GAN组
GAN自从被提出来后，技术发展就非常迅猛，已经被落地于众多的方向，其应用涉及图像与视频生成，数据仿真与增强，各种各样的图像风格化任务，人脸与人体图像编辑，图像质量提升。
本组聚焦于让大家能够跟随我们社区长期学习GAN相关的算法。下图是2024年CV中阶-GAN组包括的内容预览图，可以自行放大仔细阅读。
学习内容覆盖以下几个方向：
(1) 生成对抗网络基础，包括生成模型原理、GAN的优化目标与评估指标等。
(2) 图像与视频生成GAN，包括全卷积GAN、多尺度GAN、条件GAN、StyleGAN、视频生成GAN等。
(3) 图像翻译GAN，包括有监督翻译GAN、无监督翻译GAN等。
(4) 图像增强GAN，包括图像降噪GAN、图像去模糊GAN、超分辨GAN、图像修复GAN等。
(5) 人脸属性编辑GAN，包括通用人脸属性编辑GAN、人脸表情编辑GAN、人脸年龄编辑GAN等。
学习资源包括以下部分：
(1) 1本配套的图书教材，《生成对抗网络GAN：原理与实践》。
(2) 配套的视频教程，唯一的学习平台，课程不定期更新。
(3) 1个知识星球学习社区，存储部分图文资料与数据。
(4) 有三AI项目研发组进入权限，有机会负责真实产业案例研发。
生成模型基础
这一部分主要是学习对GAN的基础理论的理解，包括生成模型基础，自编码器与变分自编码器，GAN的原理，GAN的优化，GAN的评估。我们配置了1门时长超过3小时的《深度生成模型GAN：理论基础篇》课程。
详细了解课程，请阅读：【视频课】永久免费课程！如何掌握好深度生成模型与GAN的基础理论知识
图像与视频生成GAN
高质量图像生成和视频生成是GAN最为人熟知的应用方向，当前已经可以生成1024分辨率以上的高清逼真图像。本部分内容会讲解如何掌握图像生成技术的基本原理，视频生成技术的基本原理，如何提高生成图像和视频的质量，如何使用GAN提高已有数据的质量！我们配置了图像与视频生成GAN课程，当前包含的内容超过6个小时，PPT数量超过200页。
理论部分内容：详细解读了基本的全卷积GAN，各类条件生成GAN，强大的StyleGAN系列，数据增强与仿真GAN，视频生成GAN。
实践部分内容：包含了2个Pytorch实战案例，分别为DCGAN人脸嘴唇表情生成任务，StyleGAN人脸图像生成任务，后续还会增加3D与视频部分的实践内容。
详细了解课程，请阅读：【视频课】CV必学，超6小时，2大模块，循序渐进地搞懂GAN图像生成！
图像翻译与风格化
图像翻译与风格化包含的方向非常多，因为从图像到图像的任务都可以称之为图像翻译任务，如经典的图像分割/边缘检测，图像超分辨率/图像风格化。我们配置了图像翻译与风格化课程，当前包含的内容超过6个小时，PPT数量超过150页。
理论部分内容：涵盖了深度学习之图像翻译的核心方向，如有监督图像翻译模型，无监督图像翻译模型，多域图像翻译模型。
实践部分内容：包含了3个实践案例，分别为基于Pix2Pix的黑白图像上色实战，基于StarGAN的人脸表情编辑实战，基于BeautyGAN的人脸美妆实战。
详细了解课程，请阅读：【视频课】CV必学，超7小时，3大模块，3大案例，掌握图像翻译与风格化GAN核心技术！
图像增强
随着GAN相关技术的发展逐渐成熟，它在图像质量提升等底层任务中得到了广泛的应用，极大地促进了图像降噪、图像色调映射、图像去模糊、图像超分辨、图像修复等领域的算法进步。我们配置了图像增强GAN课程，当前包含的内容超过8个小时，PPT数量超过200页。
理论部分内容：涵盖了图像增强GAN的核心方向，包括图像降噪、图像去模糊、图像超分辨、图像色调映射、图像修复。
实践部分内容：包含了3个实践案例，分别为基于SRGAN的图像超分辨实战，基于EnlightenGAN的图像增强实战，基于DANet的图像降噪实战。
详细了解课程，请阅读：【视频课】超8小时，5大模块，掌握基于GAN的图像增强应用（降噪色调映射去模糊超分辨修复）
人脸属性编辑
随着人脸图像算法应用和GAN等生成式模型的发展逐渐成熟，如今基于深度学习模型的人脸属性编辑是当下人脸算法与应用的热点，近些年在互联网产品中有许多落地，比如人脸变老变小孩，人脸风格化特效，人脸美妆等。我们配置了深度学习之人脸属性编辑：理论与实践课程，当前包含的内容超过10个小时，包含3个典型案例。
理论部分内容：涵盖了人脸属性编辑的核心方向，包括基于StyleGAN模型的通用人脸属性编辑，基于图像翻译模型的通用人脸属性编辑，以及各类专用的人脸属性编辑模型，包括人脸表情、年龄、姿态、妆造等。
实践部分内容：一共已经包含了3个实践案例，分别为基于StyleGAN的通用人脸属性编辑实战，基于StarGAN的人脸表情编辑实战，基于BeautyGAN的人脸妆造编辑实战，后续还会增加其他方向的实战：
详细了解课程，请阅读：【视频课】超10小时，3大模块，掌握深度学习人脸属性编辑算法理论与实践
如何学以致用
有三AI-CV学习小组的目标不仅是让学习者完成对深度学习CV算法知识的掌握，更是要在实际项目中进行使用，因此提供了学习后的一些输出形式，包括做项目、授课等。关于产出形式，下面是一些往期成员的分享，供大家参考：
【杂谈】有三AI季划的最核心价值在哪，听听这些同学怎么说！
【杂谈】我在有三AI从学生到老师
【杂谈】从学员到开发者，我在有三AI打怪升级
【杂谈】有三AI课程兼职讲师，打造自己的影响力，我从这里开始！
【杂谈】蛰伏3年，从学习到负责适合自己方向的项目研发
【杂谈】一个项目获得10倍学费收入，我在有三AI学以致用的故事
【杂谈】从学员到合作伙伴，我与有三AI不得不说的故事
【杂谈】从学员到参与书籍写作，我在有三AI学习与成长的故事
【杂谈】从学员到专栏作者、讲师，我在有三AI学习与名利双收的故事
【杂谈】从学生到讲师，我如何20天里在有三AI赚3万
【杂谈】从失业到重要项目负责人，2020年里我如何在有三AI上岸
【杂谈】参加有三AI秋季划4个月，薪资翻倍，我在有三AI都学了啥？
【杂谈】一个五岁孩子妈妈在有三AI学习并且赚钱的故事 【杂谈】有三AI-CV春季划有用吗，听听他们的分享
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac3e5ce0cf4fd2488e61032a27b6999f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b04093300cda5abfa9719950c46d554/" rel="bookmark">
			Certum与Geotrust的OV多域名证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Certum和Geotrust都是知名的CA认证机构，旗下的SSL证书产品丰富，有单域名SSL证书、多域名SSL证书以及通配符SSL证书。这些SSL数字证书作为一种重要的网络安全产品，能够实现数据加密和身份验证，保障网站的安全性和隐私性。OV多域名SSL证书的使用范围比较广泛，Certum和Geotrust旗下都有这款SSL证书。今天就随SSL盾小编了解Certum与Geotrust旗下的OV多域名。
1.Certum和Geotrust旗下的OV多域名SSL证书是专为企事业单位准备的，在安全性、加密强度等方面都达到了较高的标准。这两个品牌旗下的OV多域名SSL证书在申请时需要将所有需要保护的域名以及基础信息生成CSR，然后验证域名所有权以及申请企业的真实性。申请企业需要提前准备好营业执照、企业电话等信息。
2.Certum旗下的OV多域名SSL证书价格并不高，只有九百九十元，默认保护3个域名记录，如果不够用还可以付费添加。Certum的OV多域名SSL证书价格相对较低，性价比较高，适合中小型企业使用。
3.Geotrust旗下的OV多域名SSL证书价格是两千一百元，默认包含5个域名记录，还可以付费增添至250个域名记录。这款OV多域名SSL证书支持SHA256位加密，提高了网站加密强度。Geotrust的OV多域名SSL证书价格相对较高，但其品牌知名度、安全性能等方面更加出色，因此对于更注重安全性能的大型企业来说，可能更具性价比。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b3c43a83523e341a13454d979bdf424/" rel="bookmark">
			CentOS 7 安装 PPTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：
阿里云试用机：
外网IP：114.55.80.150
内网IP：172.28.11.92
一、服务器安装 PPTP 1、安装
yum install epel-release -y 2、安装pptp
yum install pptpd iptables-services -y 3、修改配置
vim /etc/pptpd.conf # 最后加入 localip 114.55.80.150 # 本机外网IP remoteip 172.28.11.200-220 # 分配给客户端的IP，跟本机内网一个网段，地址不要冲突 4、创建用户
vim /etc/ppp/chap-secrets # 加入用户tomma 密码123456 # Secrets for authentication using CHAP # client server secret IP addresses tomma * 123456 * 5、配置DNS
vim /etc/ppp/options.pptpd # 修改 ms-dns 114.114.114.114 ms-dns 8.8.8.8 6、打开转发
echo "net.ipv4.ip_forward = 1" &gt;&gt;/etc/sysctl.conf # 生效 sysctl -p 7、关闭防火墙和 selinux
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b3c43a83523e341a13454d979bdf424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf670a3f2c3df561fdd3b928a05acd3/" rel="bookmark">
			【AWS系列】巧用 G5g 畅游Android流媒体游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 Amazon EC2 G5g 实例由 AWS Graviton2 处理器提供支持，并配备 NVIDIA T4G Tensor Core GPU，可为 Android 游戏流媒体等图形工作负载提供 Amazon EC2 中最佳的性价比。它们是第一个具有 GPU 加速功能的基于 Arm 的实例。
借助 G5g 实例，游戏流媒体客户可以在基于 Arm 的实例上本地运行 Android 游戏，对渲染的图形进行编码，并通过网络将游戏流式传输到移动设备。
在这篇博客中，将在 G5g 实例上通过 Anbox Cloud Appliance 设置 Android 环境，通过 Anbox Cloud API 构建 Android 流媒体游戏应用程序，最后在手机上通过 Firefox 浏览器玩游戏！
一、架构解析 从上图中，我们可以看到此博客中设置的演示示例架构。该架构可以简单分为两部分，
左边：是客户端，手机上支持WebRTC的任何浏览器，右边：是基于G5g实例的服务器。 可以看到，首先需要在 G5g 实例上通过 Anbox Cloud Appliance 设置 Android 环境，然后需要设置一个 Web 服务器处理来自客户端的请求，之后配置 Android 应用程序并通过 Anbox Cloud 启动应用程序接口。
当Web服务器接受客户端的请求时，它会将请求转发给应用服务器，应用服务器将与Anbox流网关和Anbox Cloud API通信以启动Android容器，Android应用程序将托管在容器中并将游戏流传回给客户。
二、具体步骤 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdf670a3f2c3df561fdd3b928a05acd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75bbc145baf8397f2065b4be5228115/" rel="bookmark">
			mysql如何取出json里某一个字段或计算两数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql如何取出json里某一个字段或计算两数 假如mysql里有这么一个字段：your_json_column，存储json数据为
{ "status":2, "orderNo":"BC20231114035353321101", "dealTime":1699960357000, "reportUrl":"https://internalt.sffix.cn", "recycleOrderNo":"VCNZJ202311155521", "supplementaryPrice":421.99, "oldMachineDealPrice":1372, "oldMachineSubsidyPrice":0 } 问题：现在要取出reportUrl字段和计算质检回收价 = oldMachineDealPrice-oldMachineSubsidyPrice，如果小于0或不存在，则显示0.00，否则保留两位小数，并且提取出reportUrl字段
问题解决 在你的 JSON 数据中，你需要计算质检回收价，并且在计算值小于0或不存在时显示0.00。同时，你也想提取 reportUrl 字段。你可以使用 MySQL 中的 JSON 函数来实现这个目标。
以下是一个示例 SQL 查询：
SELECT JSON_UNQUOTE(JSON_EXTRACT(your_json_column, '$.reportUrl')) AS reportUrl, CASE WHEN JSON_EXTRACT(your_json_column, '$.oldMachineDealPrice') IS NULL OR JSON_EXTRACT(your_json_column, '$.oldMachineSubsidyPrice') IS NULL OR (JSON_EXTRACT(your_json_column, '$.oldMachineDealPrice') - JSON_EXTRACT(your_json_column, '$.oldMachineSubsidyPrice')) &lt; 0 THEN '0.00' ELSE FORMAT( JSON_EXTRACT(your_json_column, '$.oldMachineDealPrice') - JSON_EXTRACT(your_json_column, '$.oldMachineSubsidyPrice'), 2 ) END AS qualityCheckRecoveryPrice FROM your_table WHERE -- 如果有其他的条件，可以在这里添加 -- 可选：JSON_EXTRACT(your_json_column, '$.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e75bbc145baf8397f2065b4be5228115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/142211017fb75956e314b1aa9d16d618/" rel="bookmark">
			专业课130&#43;，总分390&#43;四川大学951信号与系统考研通信，电子信息经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年专业课130+，总分390+，顺利上岸，将近一年复习一路走来，感慨很多，希望以下经历可以给后来的同学提供一些参考。
初试备考经验
公共课：三门公共课，政治，英语，数学。在备考阶段前期，我也咨询了许多考研的学长学姐关于他们备考的经历，也在b站知乎看了一些关于考研经验的分享，但看了太多的话也会让人眼花缭乱无从下手，所以我建议要以实践为主，只有自己亲身经历了才知道合适与否。因此下面我从大体框架和一些要点给出自己的见解和经验。
政治
复习关键词：选择题+肖四
政治是四门课中最简单的（一定是不接受反驳）主要分前期和后期两块介绍
前期：多注重选择题（不要背诵！！！不要背诵！！！听课就行，暑假8月开始即可）
推荐复习用书(按照重要程度）：徐涛的《核心考案》（主要是未来方便配套网课、也可以用肖老的精讲精练）、肖老的《1000题》&gt;各类政治思维导图&gt;徐涛的《优题库》（有时间就刷，没时间不刷）
推荐复习网课：徐涛的强化班
政治虽然简单但一定要看网课跟着徐涛过知识点，前期只需要刷选择题，肖老的《1000题》是最为重要的至少要刷两遍，没事可以看看政治思维导图增强逻辑记忆，最后实在有时间可以刷徐涛的《优题库》
后期（11月底-考前）：肖八肖四选择题全掌握+大题只背肖四
推荐复习用书(按照重要程度）：肖四+时政小册（徐涛肖老的均可）&gt;肖八&gt;涛八、腿姐等模拟卷
推荐复习网课：徐涛的时政课
后期主要还是刷题+背诵，闲暇时间可以没事看看时政小册子+徐涛的冲刺背诵笔记，政治比较喜欢抓热点事件和周年事件，因此时政题每年考的都比较多
然后重点讲一下肖四肖八吧，前期如果做肖八错很多不要紧，我当时最差也只有28分，其实大部分时政扣分严重，抓紧时间背还是来得及的，最后得40分不是梦。背肖四大题并不是赌肖老押题，而是背那些答题的模板，等你积累好模板就算肖老没押中，你抄抄材料加一些模板套话也是能获得不错的分数的。最后肖四最好四套全背，没时间按照第一套、第二套顺序依次背诵（因为考的概率大的会放到前面）
英语二
复习关键词：单词+阅读+作文翻译+真题
推荐复习用书：张剑的《黄皮书》、田静语法书《句句真研》（有时间的同学可以看看她的课，讲的还是非常不错的）、唐静的《考研英语翻译教程》
推荐复习网课：唐迟老师阅读课(强烈推荐）、王江涛作文课、刘晓艳翻译课
单词：（持续时间：开始准备-初试前）单词是基础，基础不牢地动山摇，学好英语前提就是背好单词！背过的单词会按照熟悉程度在之后的时间出现让你复习巩固，因为有些单词总是记不住，但多记几遍就能把意思记得差不多了。记单词一开始可能会比较痛苦，一时半会也背不了几个，可以少设置一点单词量，但只要过完一遍，背到后期的话就会比较轻松，一天复习十几分钟就结束。
阅读：（复习时间：8月-11月）阅读绝对是考研英语最最为重要的一个题型（阅读+新题型七选五/观点匹配等的总分数为50分，占比为50%）“得阅读者得天下”大家懂的都懂 先说说新题型吧，个人认为最为简单的一类题型（英语一有难度），文章长度略长于传统阅读，不需要精读（除七选五以外），抓住文章段落的大致意思即可，考过六级应该觉得这个算是小儿科了。然后是传统的阅读题，个人感觉阅读难度：英语一＞六级＞英语二＞四级。这部分想必大家应该特别熟悉，从小学初中一直到高中甚至大学四六级都在做，也算是大家的老熟人，个人觉得考研英语更喜欢考熟词生义，大家在背单词的时候还是多注意一下生僻义。其实大家在阅读的过程中都经历过前期错误率比较高，一篇错3-4个甚至全错都有过，这个时候需要细致阅读，不要在乎时间上的问题，每做完一篇就会对照翻译和解析把所有的生词（部分基本不可能考的可以不加）挑出来加入当天的单词背诵，并且把每个做错的题目都完全弄清楚，错误的原因具体是什么，单词不认识/没看懂这句话/理解错了等等，再对症下药，之后再做就会格外注意之前犯过的错误，正确率后来就越来越高。
作文翻译：（复习时间：10月-11月）我是考前两个月需要准备作文和翻译，翻译自己动手写然后跟着答案订正就可，一般阅读准备的差不多，翻译问题也不会太大（当然如果大家追求翻译的信达雅，恕本人无能，我只会直译）然后就是作文，这里说重点，一定要准备模板！
另外：英语一真题是英语二的最好的模拟题
数学二
推荐复习用书：(数学用书市面上特别多，并且做的都不错，选择自己适合的即可）
（1）各个大佬的《数学复习全书（提高篇）》、《高等数学/线性代数 辅导讲义》（三本）
（2）《数学基础过关660题》、《数学强化通关330题》
（3）《数学历年真题全精解析》
（4）《考研数学命题人终极预测8套卷》《李林考前预测4套卷》
推荐复习网课：市面上很多找到自己适合的即可（基础不好的先听基础班）
复习关键词：重基础 、重计算
大部分同学数学不好的原因无非是两个方面，一是基础不扎实，二是计算不过关
基础：本人在备考的前期将数学基础知识过了两遍，这对后面的强化阶段有很大帮助。对数学基础知识的掌握，需要知道整体的框架和分点，每一章节的知识范围和每一个知识点的概念都要知道，细节部分如公式可能会忘但不要紧，后续的强化阶段就是用于巩固补缺的，并且强化阶段也可以进行多轮，时间绝对够用。
计算：对于考研数学二，除了很少的一两个难题，大部分都是基础概念题和计算题，这一部分拿下的话，数学分数不会低。计算没有什么特别好的训练方法，就是动手做，在做题的过程中不断强化。但是可以培养一些良好的习惯，如草稿纸分块，每一块对应一道题，字迹写清楚，草稿也尽量保持良好的格式。反正，就是动手算~
坚持：数学的学习不能断，必须坚持连续学习，每天都要学习数学做题保持手感。
终于等到大家关注的专业课
951信号与系统
四川大学电子信息951专业课覆盖面广，注重基础和概念，题量和计算量较大，一些学校信号与系统喜欢全考大题，川大有明显区别，951信号与系统基本会考填空题、选择题、判断题、简答题、计算题、以及最后的S变换、Z变换和采样大题，根据我去年备考的经验来看，前些年的真题几乎快把书上的重点知识考遍了，所以近年来川大真题出现了一些新的知识点和新题型，是奥本海姆书上没有的，而且离散的知识点考察的更多了，仅仅掌握书本知识是不够的，建议参加博睿泽信息通信Jenny老师辅导课，b站有很多老师分享的专业课视频，可以先看看，确实是老师，比研究生和博士讲课好多了，当初也是上岸学长非常推荐，这一路复习过来，确实对专业课帮助非常大。
6-8月：跟着Jenny老师基础，强化和提升课程，结合奥本海姆课本，整理老师上课内容形成自己的笔记。每次辅导课后的精选测评题目必须做透，及时发现每次课掌握情况。书本看着吃力的话，可以先跟老师课程，确实更通俗易懂，深入浅出。老师的课程一定要吃透，老师每次课从理论知识点引入，到结合专业课经典题目实战，再到考研得分，一步到到位，非常高效，每次课后还有针对性测评精选题目，查缺补漏。
8-9月：跟着老师课程完成第一遍复习，顺便参加第一次模考测评，尽快从真实的考试中找到第一遍复习和考研要求的差距，返回打磨第一遍复习中的不足。
9月-考前：进入Jenny老师课程的突破阶段课程，开始刷真题，至少刷两遍，我是刷了三遍，真题非常重要，最好做到滚瓜烂熟，要一直做到考前，因为951考的非常细，计算也很灵活，要保持手感。二刷真题的时候要卡时间，最好在两个半小时内做完。和高数一样，记不清的知识点和公式记录下来，尤其是一些简答题，每天看看，可以看到考前。每题来龙去脉都要非常清晰，有问题及时联系Jenny老师解答，后面老师也选择了一些难度高于川大的c9和顶尖985信息通信高校的真题拓展思路，这个确实对复习有很强的延伸，避免出现新内容无所适从的感觉。最后回归课本，和最后的模考测评，查缺补漏，返回Jenny老师对应的课程内容，强化。
复试复习：
复试的话，我个人其实表现的一般，笔试和面试各占一半，笔试表现还可以，面试有几个问题答的一般，但是我还是很建议同学们不要摆烂，只有有一丝希望都不要放弃，很多同学都是初试成绩出来就不怎么复习复试，现在很多学校55开，很容易逆袭的，据我所知今年就有好几个高分被刷以及逆袭的。给大家建议就是尽量有笔试的复试，多看看自己的笔试科目，面试大家其实感觉水平都那样，你只要诚实，不懂就承认就好，但是也不能一点不看，最起码对一些基本知识要理解。总之复试在我看来笔试最容易拉开差距，最起码面试把基本知识，毕设搞懂就好。整个复试流程非常短，面试老师也很随和，回答不上来老师也会提示，
最后祝大家成功登录川大！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf3d245e89991b20f8076a1a07667cc5/" rel="bookmark">
			更改数据库名称时 存储过程的数据库名称如何改变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 SQL Server 中，当你更改数据库名称时，存储过程中的 USE [big_data] 语句不会自动更改。你需要手动更新所有引用旧数据库名称的存储过程。
若要修改存储过程中的数据库引用，可以按照以下步骤操作：
首先，使用 ALTER DATABASE 语句更改数据库名称：ALTER DATABASE big_data MODIFY NAME = big_data_test; 然后，找出所有引用旧数据库名称（big_data）的存储过程，并使用 sp_rename 或直接编辑存储过程内容来更新 USE 语句： sql -- 查找引用 big_data 的存储过程 SELECT DISTINCT so.name FROM sys.sql_modules sm JOIN sys.objects so ON sm.object_id = so.object_id WHERE sm.definition LIKE N'%big_data%'; -- 更新存储过程 DECLARE @SQL NVARCHAR(MAX); SELECT @SQL = STRING_AGG('ALTER PROCEDURE ' + QUOTENAME(SCHEMA_NAME(so.schema_id)) + '.' + QUOTENAME(so.name) + CHAR(13) + CHAR(10) + 'AS' + CHAR(13) + CHAR(10) + REPLACE(sm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf3d245e89991b20f8076a1a07667cc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50abc248c8c7ba0be37921d14a7e4081/" rel="bookmark">
			LeetCode[62] 不同路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Description： 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
解法：动态规划 int uniquePaths(int m, int n) { vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); for(int i=0; i &lt; m; i++) for(int j = 0; j &lt; n; j++) dp[i][j] = 0; for(int i = 0; i &lt; m; i++) dp[i][0] = 1; for(int j = 0; j &lt; n; j++) dp[0][j] = 1; for(int i = 1; i &lt; m; i++) for(int j = 1; j &lt; n; j++) dp[i][j] = dp[i][j-1] + dp[i-1][j]; return dp[m-1][n-1]; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457dc10279c3db1d7da4e21ed77a7a2d/" rel="bookmark">
			flutter版本升级后，解决真机和模拟器运行错误问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter从3.3.2升级到3.16.0，项目运行到真机和模拟器报同样的错，错误如下:
解决办法：在android目录下的build.gradle加入下面这行，如下图：
重新运行，正常把apk安装到真机上或者运行到模拟器上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9669c8683a65799100a154218329eb83/" rel="bookmark">
			apisix 官方example，单机docker的etcd备份和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		etcd配置就是官方example，很多文档都是集群k8s的，不能照搬，记录下官方试例的过程,
etcd配置如下：
version: "3" services: etcd: image: bitnami/etcd:3.4.15 restart: always volumes: - ./etcd_data:/bitnami/etcd environment: ALLOW_NONE_AUTHENTICATION: "yes" ETCD_ADVERTISE_CLIENT_URLS: "http://etcd:2379" ETCD_LISTEN_CLIENT_URLS: "http://0.0.0.0:2379" ports: - "2379:2379/tcp" networks: apisix: 备份与恢复：
1 在./etcd_data目录下创建data,chmod 777，启动恢复时用
2 备份ETCDCTL_API=3 docker exec api_etcd_1 etcdctl --endpoints=":2379" snapshot save "/bitnami/etcd/backup.db"
3 恢复：
1. 先停掉服务（apisix相关，只留下etcd docker)
2. 删除./etcd_data下的data，执行
ETCDCTL_API=3 docker exec -it etcd etcdctl snapshot restore "/bitnami/etcd/backup.db" --endpoints=":2379" --data-dir=/bitnami/etcd/data, 然后chmod data 777
3. 重启服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a88b0121b71e6a05dd5c94cfce13b20/" rel="bookmark">
			划分VOC数据集，以及转换为划分后的COCO数据集格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.VOC数据集 LabelImg是一款广泛应用于图像标注的开源工具，主要用于构建目标检测模型所需的数据集。Visual Object Classes（VOC）数据集作为一种常见的目标检测数据集，通过labelimg工具在图像中标注边界框和类别标签，为训练模型提供了必要的注解信息。VOC数据集源于对PASCAL挑战赛的贡献，涵盖多个物体类别，成为目标检测领域的重要基准之一，推动着算法性能的不断提升。
使用labelimg标注或者其他VOC标注工具标注后，会得到两个文件夹，如下:
BirdNest -------&gt;&gt;&gt; 主目录,存放下面的两个文件夹 ----Annotations -------&gt;&gt;&gt; 存放.xml标注信息文件 ----JPEGImages -------&gt;&gt;&gt; 存放图片文件 2.划分VOC数据集 如下代码是按照训练集:验证集 = 8:2来划分的，会找出没有对应.xml的图片文件，且划分的时候支持JPEGImages文件夹下有如下图片格式:
['.jpg', '.png', '.gif', '.bmp', '.tiff', '.jpeg', '.webp', '.svg', '.psd', '.cr2', '.nef', '.dng'] 整体代码为:
import os import random from tqdm import tqdm image_extensions = ['.jpg', '.png', '.gif', '.bmp', '.tiff', '.jpeg', '.webp', '.svg', '.psd', '.cr2', '.nef', '.dng'] ef split_voc_dataset(dataset_dir, train_ratio, val_ratio, use_random_seed=False, random_seed=999): if not (0 &lt; train_ratio + val_ratio &lt;= 1): print("Invalid ratio values.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a88b0121b71e6a05dd5c94cfce13b20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fddbfabd6fe62ea7a1734691af3e9c2/" rel="bookmark">
			Python&#43;Requests&#43;PyTest&#43;Excel&#43;Allure 接口自动化测试实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍了Python+Requess+PyTest+Excel+Allure 接口自动化测试实战，文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值，需要的朋友们下面随着小编来一起学习学习吧
Unittest是Python标准库中自带的单元测试框架，Unittest有时候也被称为PyUnit，就像JUnit是Java语言的标准单元测试框架一样，Unittest则是Python语言的标准单元测试框架。
Pytest是Python的另一个第三方单元测试库。它的目的是让单元测试变得更容易，并且也能扩展到支持应用层面复杂的功能测试。
两者对比：
Pytest项目实战： 第一步、搭建项目框架(创建Gwyc_Api_Script_Pytest项目目录)
依次创建子目录如下：base：存放一些最底层的方法封装，协议，请求发送等。common:存放一些公共方法。config:存放配置文件。data:存放测试数据。 log:存放日志。report:存放报告。tests:存放用例。utils:存放公共类。 readme:用于说明文档。requirements.txt: 用于记录所有依赖包极其版本号，便于环境部署，可以通过pip命令自动生成和安装。
第二步、封装请求方法(base目录下面创建method.py)
封装有两种方法：
第一种：直接调用requests库下面的request方法，并将所有需要用到的参数定义进去，分为实参和行参，实参调用必须要传参，行参可给默认值，调用时可重新赋值也可以使用默认值。这种方法代码量少，不用做判断，request会自动根据传入的参数进行发送请求到服务器。
​第二种：分别对各个请求方式按函数的形式封装，分别调用requests进行发送请求。以get和post为例：put，delete请求按一样方法封装，各个请求方式封装完成以后再定义一个主方法，直接调用主方法会自动根据请求方式进行判断调用各个请求函数，这里也可以不对请求方式汇总封装，直接调用各个函数进行发送请求也是可以的。这种方法封装涉及代码量较多，也没有能够很好的用上requests库，因此推荐使用第一种方法。
​第三步、封装读取文件的方法(common目录下创建public.py)：
1、这里需要用到python的os库，os 库是Python标准库，包含几百个函数，常用的有路径操作、进程管理、环境参数等。
2、分别对获取目录和获取目录下文件进行了封装，直接调用并传入相应的参数即可使用。如下图：
​第四步、准备数据(data目录下创建data.xlsx)
将接口写入excel表，将接口需要用到的字段都写进excel然后直接进行读取。
​
第五步、封装读取文件方法(utils目录下面创建operationExcel.py)
定义一个文件类分别再定义一个方法获取Sheet表，定义一个方法获取出所有数据存放进列表。
第六步、封装登录方法(common目录下面创建login.py)
获取token提供给接口使用，使用@pytest.fixture装饰器每次执行所有用例前执行一遍登录方法获取到token并返回。
第七步、对表头定义全局变量，可以定义在utils目录下面的operationExcel.py文件中
第八步、封装用例(tests目录下面创建test_gwyc_api_all.py)
需要用到@pytest.mark.parametrize()装饰器进行封装用例，调用getExceldatas()将读取出来的用例存放进装饰器，"data"为别名。如下图，分别请求头和参数做了为空判断，并将token插入到headers里面，这样每一个接口都能使用到登录返回的token，不用每次都去调用获取token。
第九步、利用allure生成测试报告。
allure是Pytest的插件包需要下载安装，并将allure里面的bin目录所在的路径配置到PATH环境变量中就可以直接使用报告。
将生成的json文件存放到用例所在的目录下面执行完成以后会在tests目录下面生成一个report目录，下面包含result目录和html目录,前者是存放json文件，后者存放读取后生成的html报告
第十步、封装日志方法(log目录下面创建log.py)
日志在自动化测试中起到的参考作用相对较小以测试报告为准，直接按相应规则配置好直接调用即可
​到此这篇关于Python+Requests+PyTest+Excel+Allure 接口自动化测试实战的文章就介绍到这了
这可能是B站最详细的pytest自动化测试框架教程，整整100小时，全程实战！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42fc230a31a51ac52e90768df7936be0/" rel="bookmark">
			怎么放大图片保持清晰度？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&amp;nbsp; 怎么放大图片保持清晰度？图片是大家都很爱保存的一种文件类型，因为图片不仅能够帮助我们工作，在生活中也可以成为娱乐、纪念的代表物，但有时我们会发现自己拍的图片太小了，根本看不清楚，想要将图片放大又怕清晰度受到影响，这种时候我们就可以选择“优速图片无损放大器”将图片放大并且保持清晰度了。
就像上面所说的那样，使用“优速图片无损放大器”可以轻松将图片放大并保持清晰度，这样做的好处有非常多，首先当然是我们的图片被放大了，而且清晰度没有任何的影响，其次是更加适合分享了，因为更加高清的图片别人看着也会更加舒服一点，不会引起任何人的反感，然后放大图片还能够让我们编辑更加简单，因为图片看的更清楚了，我们想要P图也会更加的轻松，不会因为看不见而导致P图失误的情况出现，最后放大图片还能让我们的适用范围更广，比如说图片大小但是需要比较大的照片时，我们就可以使用软件将图片放大然后发送过去，轻松解决问题，那么具体应该如何操作才将图片方法并保持清晰度呢？这里小编就带给大家几个使用的方法介绍，快来看看吧！
&amp;nbsp;
方法一：使用“优速图片无损放大器”将图片放大并保持清晰度
步骤1：首先，如果我们想使用这个方法一定要先下载并安装“优速图片无损放大器”软件才行，安装完成后将软件打开，在软件主界面点击【添加文件】按钮，然后选择想要放大的图片，选择完成后它就会被自动导入到软件中，直接拖拽这个图片到中间空白处也可以进行导入。
&amp;nbsp;
步骤2：图片导入成功后就会在右侧显示其预览图，预览图下方就可以进行一些设置，首先我们需要【选择算法】有神经网络算法和高性能算法两种，具体选择哪个需要看你的电脑对哪种支持比较好，然后再根据自己的需求调整【降噪程度】和【放大倍数】。
&amp;nbsp;
步骤3：调整完上面这些设置后点击右上角的【开始转换】按钮，启动图片放大程序。
&amp;nbsp;
步骤4：图片放大需要一会时间，我们可以留意文件右侧的进度条，放大完成后会弹出提示框，点击提示框上的“前往导出文件位置”就能找到无损放大后的图片了。
&amp;nbsp;
步骤5：我们打开原图和放大后的图片对比一下可以很清楚的看到图片被放大了，而且图片清晰度没有任何的影响。
&amp;nbsp;
方法二：使用小讯图片处理器进行无损放大
在给大家介绍一个可以进行图片无损放大的软件吧，名称叫做小讯图片处理器，这是一个包含很多功能的图片处理软件，无损放大只是其中一个小功能，下面是详细的步骤，请跟着操作吧。
1、安装好这个软件工具后直接打开使用，然后在左边可以看到功能列表，有非常多的功能，我们依次找到并点击“照片修复-无损放大”功能。
&amp;nbsp;
2、点击无损放大功能上的“添加图片”蓝色按钮，随后将需要放大尺寸的图片上传至软件中，可以上传多张图片哦。
&amp;nbsp;
3、如下图所示我们需要设置图片放大的倍数，最大为4倍，大家根据自己的需要设置合适的倍数即可。最后点击“立即保存”按钮，这样我们就能得到一张无损放大后的图片了。
&amp;nbsp;
方法三：使用在线工具进行无损放大
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这个方法中我将为大家介绍一个名称为“bigpng”的在线图片无损放大软件来教大家如何操作，这个工具采用AI技术进行图片无损放大，下面是详细的步骤。
1、我们只需要借助电脑上的浏览器就能将这个在线工具打开，随后点击页面里的“选择图片”绿色按钮，上传需要无损放大的图片到软件中。
&amp;nbsp;
2、上传好图片后点击图片缩略图旁边的“开始”按钮，之后就会弹出图片无损放大的配置窗口，我们可以对图片的类型、放大倍数和降噪程度进行详细的设置，设置好之后点击确定按钮，这样就正式启动图片无损放大操作了。
&amp;nbsp;
3、如下图所示这是图片完成无损放大后的样子，我们点击“下载”绿色按钮，就可以将无损放大后的图片下载到电脑本地进行使用了。
&amp;nbsp;
需要注意的是，在我们放大图片的时候一定要注意选择合适的软件，如果比较差的软件就会导致各种问题的发生，比如虽然图片放大了，但是清晰度也受到影响了，这很可能是软件在调整图片的分辨率，那这完全是没有必要的操作，不仅浪费你的时间也浪费了各种资源，然后还有可能发生图片虽然放大，但不能自由的调节放大的比例，这就会让图片无限制的放大，太大的图片会导致人们根本看不清内容，只会让图片变的模糊并且丢失细节，最后图片放大是不可逆的操作，大家在放大图片之前一定要注意保存原文件，或者直接选择“优速图片无损放大器”软件，它会重新将文件上传一遍，完全不会影响原文件的任何内容。到这里相信大家对放大图片并保持清晰度肯定有了自己的了解，如果还不会操作的话肯定根据小编上面写的步骤来一步步操作，肯定能够很快学会，那么今天这篇“怎么放大图片保持清晰度？”就到此结束了，感谢大家的阅读！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81881126addcb5f7c207bf024abd57f9/" rel="bookmark">
			IDEA设置自动导入包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File-&gt;Settings-&gt;Editor-&gt;General-&gt;Auto Import
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b105deb74112bd4fad60812a3b56a0c3/" rel="bookmark">
			视频智能分析/云存储平台EasyCVR接入海康SDK，通道名称未自动更新该如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频监控GB28181平台EasyCVR能在复杂的网络环境中，将分散的各类视频资源进行统一汇聚、整合、集中管理，在视频监控播放上，TSINGSEE青犀视频安防监控汇聚平台可支持1、4、9、16个画面窗口播放，可同时播放多路视频流，也能支持视频定时轮播。视频监控汇聚平台EasyCVR支持多种播放协议，包括：HLS、HTTP-FLV、WebSocket-FLV、WebRTC、RTSP、RTMP，并且支持对外分享。
用户反馈，在EasyCVR接入海康SDK通道的设备，只有在第一次写入数据库时，会根据海康SDK接口保存通道名称，若设备修改了通道名称，EasyCVR不会自动更新通道名称。
收到用户反馈后，技术人员立即开展排查。
1）修改后端部分代码，随后调用sdk获取通道信息，并更新通道信息；
2）修改后的前端效果如下：
3）根据以上代码进行修改，即可解决该问题。
GB28181视频汇聚/视频云存储/集中存储/视频监控管理平台EasyCVR能在复杂的网络环境中，将分散的各类视频资源进行统一汇聚、整合、集中管理，实现视频资源的鉴权管理、按需调阅、全网分发、云存储、智能分析等，视频智能分析平台EasyCVR融合性强、开放度高、部署轻快，在智慧工地、智慧园区、智慧工厂、智慧码头、智慧水利等场景中有着广泛的应用前景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/119008712ab9330bdca9fd9952c349d1/" rel="bookmark">
			在 CentOS 7.8 上安装 GDAL 3.4.1 及相关库的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装 SQLite3
# 下载 SQLite 源码 wget https://www.sqlite.org/2023/sqlite-autoconf-3440200.tar.gz # 解压缩 tar -zxvf sqlite-autoconf-3440200.tar.gz # 进入解压后的目录 cd sqlite-autoconf-3440200 # 配置安装路径为 /usr/local ./configure --prefix=/usr/local # 编译 make -j4 # 安装 sudo make install # 运行 ldconfig 以更新共享库缓存 sudo ldconfig # 检查 SQLite 版本 sqlite3 --version # 如果需要设置 PKG_CONFIG_PATH export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig 2. 安装 Proj6
# 下载 Proj6 源码 wget https://download.osgeo.org/proj/proj-6.3.2.tar.gz # 解压缩 tar -zxvf proj-6.3.2.tar.gz # 进入解压后的目录 cd proj-6.3.2 # 配置安装路径为 /usr/local .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/119008712ab9330bdca9fd9952c349d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc37de841849bdacc4c196bdd1c66e99/" rel="bookmark">
			【开源】基于JAVA&#43;Vue&#43;SpringBoot的城市桥梁道路管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块三、系统展示四、核心代码4.1 查询城市桥梁4.2 新增城市桥梁4.3 编辑城市桥梁4.4 删除城市桥梁4.5 查询单个城市桥梁 五、免责说明 一、摘要 1.1 项目介绍 基于Vue+SpringBoot+MySQL的城市桥梁道路管理系统，支持管理人员动态维护城市桥梁道路数据，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，城市桥梁道路管理系统于角色的访问控制，给管理员、普通用户使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 城市桥梁道路管理系统是一种基于Vue、SpringBoot和MySQL的应用系统，旨在为城市管理部门提供桥梁和道路的监控、维护和管理功能。下面是一些可能包含的功能模块：
用户管理：管理系统的用户账号和权限，包括管理员和普通用户。
桥梁管理：记录和管理城市中的桥梁信息，包括桥梁的名称、位置、结构、年限等。可以进行桥梁的查询、添加、修改和删除操作。
道路管理：记录和管理城市中的道路信息，包括道路的名称、起止位置、车道数等。可以进行道路的查询、添加、修改和删除操作。
监控管理：实时监控城市中的桥梁和道路状况，包括实时数据的采集、展示和报警功能。
维护管理：记录和管理桥梁和道路的维护工作，包括维护计划、维护记录和维护人员的安排。
统计分析：对桥梁和道路的数据进行统计和分析，包括使用年限、维护次数、损坏程度等指标的统计和可视化展示。
报表管理：生成各种报表和文档，包括桥梁和道路的巡查报告、维护记录和统计分析报表等。
这些功能模块可以通过Vue作为前端框架实现用户界面的设计和交互，SpringBoot作为后端框架实现业务逻辑和数据处理，MySQL作为数据库存储和管理系统的数据。整个系统的开发和部署需要前后端协作，同时考虑用户友好性、系统性能和安全性等方面的要求。
三、系统展示 四、核心代码 4.1 查询城市桥梁 @RequestMapping(value = "/getByPage", method = RequestMethod.GET) @ApiOperation(value = "查询城市桥梁") public Result&lt;IPage&lt;CityBridge&gt;&gt; getByPage(@ModelAttribute CityBridge cityBridge ,@ModelAttribute PageVo page){ QueryWrapper&lt;CityBridge&gt; qw = new QueryWrapper&lt;&gt;(); if(!ZwzNullUtils.isNull(cityBridge.getTitle())) { qw.like("title",cityBridge.getTitle()); } if(!ZwzNullUtils.isNull(cityBridge.getCode())) { qw.like("code",cityBridge.getCode()); } if(!ZwzNullUtils.isNull(cityBridge.getType())) { qw.eq("type",cityBridge.getType()); } if(!ZwzNullUtils.isNull(cityBridge.getBuildCompany())) { qw.like("build_company",cityBridge.getBuildCompany()); } if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc37de841849bdacc4c196bdd1c66e99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08debff0ab32e2dd3f7ebe9606db6a3/" rel="bookmark">
			PyQT5实现图像处理应用（含Windows7下完整打包方案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、任务概述2、环境安装2.1 创建虚拟环境2.2 安装依赖库 3、程序开发3.1 框架搭建3.2 读取图像3.3 图像处理 4、打包部署5、小结 1、任务概述 本篇博文将通过PyQT5来实现一个简单的图像处理应用，并完成打包部署。
本文开发平台：Windows10 64位系统。部署平台：Windows7 64位系统。
具体实现效果如下：
由于PyQT依赖Python，因此在学习下面的章节前，请先安装好Python。本教程使用的Python版本为3.8.0（由于部署平台为Windows7，因此不能使用Python3.8以上版本）。
2、环境安装 2.1 创建虚拟环境 为方便后面打包部署，我们将相关Python的依赖库存放到虚拟环境中，因此需要先创建一个虚拟环境。
Windows平台下的虚拟环境需要使用第三方工具virtualenv来创建，打开命令终端，输入下面的命令即可完成安装：
pip install virtualenv -i https://mirror.baidu.com/pypi/simple 创建一个项目文件夹demo，我们现在的目标就是在这个demo项目中创建python虚拟环境，这个虚拟环境是专门为demo项目成立的。在命令行终端中通过cd命令进入项目目录中（假设demo文件夹位于D:\code目录下）：
输入下面的命令用来创建名为venv的虚拟环境：
virtualenv env 这样我们就在demo文件夹下有了一个名为env的子文件夹，它保存了一个全新的虚拟环境，其中有一个私有的Python解释器位于demo/env/Scripts，在该虚拟环境中安装的python包会存放在demo/env/Lib路径下。
最后，在Windows平台下激活并使用该虚拟环境：
env\Scripts\activate 如下图所示：
成功激活之后，虚拟环境解释器的路径就被加入PATH中，但这种改变不是永久的，他只会影响当前的命令行终端。
2.2 安装依赖库 在虚拟环境中安装pyqt5和opencv：
pip install pyqt5 opencv-python -i https://mirror.baidu.com/pypi/simple 其中pyqt5用于开发界面程序，而opencv用于图像处理算法操作。
3、程序开发 3.1 框架搭建 在demo文件夹下面创建一个名为main.py的脚本，内容如下：
# -*- coding:utf-8 -*- import sys from PyQt5.QtWidgets import QMainWindow, QApplication, QPushButton, QLabel, QFileDialog from PyQt5.QtCore import QRect,QCoreApplication,Qt from PyQt5.QtGui import QPixmap,QImage class MainWindow(QMainWindow): def __init__(self, parent=None): super(MainWindow, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08debff0ab32e2dd3f7ebe9606db6a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277e1b0ad31a1d19a2bcf9f3ccd81abc/" rel="bookmark">
			【投稿优惠|优质会议】2024年材料化学与清洁能源国际学术会议(IACMCCE 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【投稿优惠|优质会议】2024年材料化学与清洁能源国际学术会议(IACMCCE 2024)
2024 International Conference Environmental Engineering and Mechatronics Integration(ICEEMI 2024)
一、【会议简介】
随着全球能源需求的不断增长，清洁能源的研究与应用成为了国际关注的热点。材料化学作为一门新兴的交叉学科，在清洁能源领域具有广泛的应用前景。本次会议旨在为全球范围内的材料化学与清洁能源领域的专家、学者提供一个交流平台，共同探讨该领域的发展趋势、研究热点和前沿技术。
二、【征稿主题】主题包括但不限于以下
电化学材料
表面化学
新能源材料
化学物理
光学材料
材料的物理和结构特性
新功能无机非金属材料
微结构材料设计
胶体与界面化学
加工、制造及应用
环境与能源
清洁能源技术
氢与燃料电池
能源安全与清洁利用
节能减排
绿色能源技术
生物质能源工程
太阳能工程
风能工程
可再生能源
太阳能光伏发电系统
新能源转换与控制技术
水力发电
热能
风力发电
生物质发电
海洋发电
地热发电
储能技术
低碳能源技术
三、【重要信息】
投稿邮箱：iac_info@163.com
投稿时请邮箱正文备注：论文投稿+苏老师推荐+投稿人姓名
最终截稿时间：请查看官网
接受/拒稿：投稿后2-3日内通知
四、【论文提交】
1. 文章需全英文，重复率低于30%。
2. 文章必须要有题目、作者、单位、邮箱、关键词、摘要、必要的图表、结论、参考文献等。
3. 投稿流程：投稿→审稿→录用→注册→开具增值税普票（专票）→电子版→纸质版→检索。
4. 请勿一稿多投，所有稿件将接受两三名专家进行评审
五、【联系我们】
会议官网：http://www.iacmcce.com
邮箱：iac_info@163.com
备注：你的名字+苏老师推荐，享投稿优惠+优先审稿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4b07d5d290d4e8f4a6ebea4126f9eb/" rel="bookmark">
			scopus数据库收录论文快吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scopus是国际知名的数据库，收录文献类型包含期刊，会议论文，丛书，专利等，那么scopus数据库收录论文快吗?scopus检索收录时间是浮动的，有的论文可能需要2个月左右，有的可能需要3-4个月。
论文录用见刊到能够被scopus数据库检索时间，取决于出版社和期刊稿源情况，期刊工作人员要将论文数据提交给scopus数据库，这个时间并不确定，但相对wos、ei数据库来说，scopus数据库更加高效，更新是比较频繁的。
作者可能发表的是期刊论文，也可能是会议论文，所有录用论文以会议论文集形式出版，见刊后由期刊社提交至Scopus 检索，目前SCOPUS检索非常稳定。scopus数据库是规模最大的数据库，收录顶级英文刊物有Elsevier、Springer、Nature等。还收录了一些重要的中文期刊，如：《计算机学报》、《力学学报》、《中国物理快报》、《中华医学杂志》等。
因此作者可放心的安排scopus论文，在期刊覆盖国家上，scopus也是比较均衡，国际化认可度高，而WoS在多数学科中则更偏重英美等欧洲国家。在检索方式上，Scopus相比WoS有更高级的检索方式，能控制更多检索词，检索功能也是比较多的。
最后也提醒各位作者，发表论文多数单位会有检索的要求，时间上也并不确定，作者能做的就是尽早的做准备，不可盲目轻信快速检索，scopus数据库是独立的，认可的是高质量、符合主题的论文，还可以阅读其他scopus相关的知识，更有利于论文发表检索。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2febd97d8ed0d4fcfddb9bf808a4c169/" rel="bookmark">
			如何使用 NFTScan NFT API 在 PlatON 网络上开发 Web3 应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PlatON 是由万向区块链和矩阵元主导开发的面向下一代的全球计算架构，创新性的采用元计算框架 Monad 和基于 Reload 覆盖网络的同构多链架构，其愿景是成为全球首个提供完备隐私保护能力的运营服务网络。它提供计算、存储、通讯服务，并提供算力、算法、数据等众多基础资源以及公共基础设施软件开发、咨询及运营服务等。
就 NFTScan 数据来看，截至 1 月 5 日，PlatON 网络上已累计发行 NFT 资产 2,710,774 枚，NFT Collection 2,261 个，产生交互记录 6,865,324 条，有过交互的钱包地址 1,180,646 个，总交易额 190,295.2 LAT。
PlatON NFTScan：
创建 NFTScan 开发者账号
在开始使用 NFTScan API 之前，首先需要访问开发者网站并创建一个账户。前往 NFTScan 官方网站点击 NFTScan API “Sign Up”按钮进行注册。
https://developer.nftscan.com/user/signup
登录后在 Dashboard（面板）上找到自己独有的 API KAY，将其复制。访问 API 文档，将自己的 API KEY 输进 API 文档的相应位置。根据文档的指引，就可以开始使用 API 服务了。在 API 文档中，开发者可以找到多种可供选择的接口模式，根据需求来选择最合适的接口。
在 Dashboard 中，开发人员还可以查看自己 API 使用情况的统计数据，帮助记录历史使用数据。不仅如此，NFTScan 还为每位注册开发者提供 1M CU 的 API 调用服务，用于请求所有的 NFT API 接口，并且 CU 永不过期，用完为止！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2febd97d8ed0d4fcfddb9bf808a4c169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109e72f08970672619617cf63797cc3a/" rel="bookmark">
			大创项目推荐 深度学习图像修复算法 - opencv python 机器视觉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言2 什么是图像内容填充修复3 原理分析3.1 第一步：将图像理解为一个概率分布的样本3.2 补全图像 3.3 快速生成假图像3.4 生成对抗网络(Generative Adversarial Net, GAN) 的架构3.5 使用G(z)生成伪图像 4 在Tensorflow上构建DCGANs最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 深度学图像修复算法
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
2 什么是图像内容填充修复 内容识别填充(译注: Content-aware fill ,是 photoshop
的一个功能)是一个强大的工具，设计师和摄影师可以用它来填充图片中不想要的部分或者缺失的部分。在填充图片的缺失或损坏的部分时，图像补全和修复是两种密切相关的技术。有很多方法可以实现内容识别填充，图像补全和修复。
首先我们将图像理解为一个概率分布的样本。基于这种理解，学*如何生成伪图片。然后我们找到最适合填充回去的伪图片。 自动删除不需要的部分（海滩上的人）
最经典的人脸补充
补充前：
补充后：
3 原理分析 3.1 第一步：将图像理解为一个概率分布的样本 你是怎样补全缺失信息的呢？
在上面的例子中，想象你正在构造一个可以填充缺失部分的系统。你会怎么做呢？你觉得人类大脑是怎么做的呢？你使用了什么样的信息呢？
在博文中，我们会关注两种信息：
语境信息：你可以通过周围的像素来推测缺失像素的信息。
感知信息：你会用“正常”的部分来填充，比如你在现实生活中或其它图片上看到的样子。
两者都很重要。没有语境信息，你怎么知道填充哪一个进去？没有感知信息，通过同样的上下文可以生成无数种可能。有些机器学*系统看起来“正常”的图片，人类看起来可能不太正常。
如果有一种确切的、直观的算法，可以捕获前文图像补全步骤介绍中提到的两种属性，那就再好不过了。对于特定的情况，构造这样的算法是可行的。但是没有一般的方法。目前最好的解决方案是通过统计和机器学习来得到一个类似的技术。
从这个分布中采样，就可以得到一些数据。需要搞清楚的是PDF和样本之间的联系。
从正态分布中的采样
2维图像的PDF和采样。 PDF 用等高线图表示，样本点画在上面。
3.2 补全图像 首先考虑多变量正态分布， 以求得到一些启发。给定 x=1 , 那么 y 最可能的值是什么？我们可以固定x的值，然后找到使PDF最大的 y。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/109e72f08970672619617cf63797cc3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9683f9a252a01093f8aa4f552bae1aea/" rel="bookmark">
			ReactNative 常见问题及处理办法（加固混淆）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文章目录
摘要
引言
正文
ScrollView内无法滑动
RN热更新中的文件引用问题
RN中获取高度的技巧
RN强制横屏UI适配问题
低版本RN（0.63以下）适配iOS14图片无法显示问题
RN清理缓存
RN navigation参数取值
pod install 或者npm install 443问题处理
打开要处理的IPA文件
设置签名使用的证书和描述文件
开始ios ipa重签名
总结
参考资料
文章目录 摘要
引言
正文ScrollView内无法滑动RN热更新中的文件引用问题RN中获取高度的技巧RN强制横屏UI适配问题低版本RN（0.63以下）适配iOS14图片无法显示问题RN清理缓存RN navigation参数取值pod install 或者npm install 443问题处理
打开要处理的IPA文件
设置签名使用的证书和描述文件
开始ios ipa重签名
总结
参考资料
摘要 本文总结了 ReactNative 开发中常见问题及解决方法。从 ScrollView 在 TouchableOpacity 组件内滑动困难到 Xcode 编译路径设置，都有相应解决方案。此外，还介绍了热更新问题、高度获取、强制横屏UI适配、清理缓存等实用技巧。
引言 ReactNative 作为一种跨平台开发框架，尽管强大，但也常伴随着一些问题。本文收集并解答了一些常见问题，为开发者提供了一些实用的技术指南。
正文 ScrollView内无法滑动 在 TouchableOpacity 组件内使用 ScrollView 可能导致滑动失效。解决方法是将 ScrollView 内容用 TouchableOpacity 包裹，并设置 onPress={() =&gt; {}} 属性。
&lt;TouchableOpacity onPress={() =&gt; {}}&gt; &lt;ScrollView&gt; {/* Scrollable content */} &lt;/ScrollView&gt; &lt;/TouchableOpacity&gt; RN热更新中的文件引用问题 使用 codepush 进行热更新后，在 Android 系统中 src 目录下的音频文件可能无法引用。解决方法是将文件放到原生系统中，因为热更的 bundle 文件无法包含音频文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9683f9a252a01093f8aa4f552bae1aea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45bc8cf7b014a01ee129b74885709a41/" rel="bookmark">
			Vue生命周期钩子函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生命周期：
页面内容的三个阶段：创建阶段、更新阶段、销毁阶段。当一个页面内容出现在App.vue中，页面进入创建阶段。当响应式数据发生变化时页面自动更新，此时进入更新阶段。最后切换页面时，旧页面消失，就是进入了销毁阶段。
对应这三个阶段，vue提供了不同生命周期函数，也叫钩子函数。让我们可以在不同阶段对页面内容进行处理。
创建阶段生命周期只会在组件第一次加载时执行。除非组件被卸载了，当再次进入这个页面，创建阶段的生命周期会再次执行。
生命周期图示：
beforeCreate() : 创建阶段的第一个生命周期，它是在vue实例对象刚刚被创建出来，但还没有完成data和methods与实例对象的结合。此时this已经存在了，只不过此时的this仅仅完成了第一个阶段的初始化，实例内部的属性和方法刚刚和this实例绑定完成。
created() : 创建阶段的第二个生命周期，它是vue实例第二个阶段初始化完成，第二个阶段主要是把咱们配置的一些data、method、computed内容挂载到this实例上。所以我们才可以通过this.属性，this.方法，this.计算属性。
这个生命周期表示this实例已经初始化完成。页面的初始化请求最早（不是唯一或必须）只能放在这里，也可以放在后面，不能放在beforeCreate中，因为它里面的this还不存在响应式数据，请求结果没地方存。
beforeMount() : 创建阶段的第三个生命周期，vue渲染模板前执行，此时DOM还没有渲染出来.在挂载开始之前被调用.
mounted() : 创建阶段的第四个生命周期，vue渲染模板结束，此时DOM已经渲染出来。这个生命周期是最早能操作DOM的位置。
beforeUpdate() : 更新阶段的生命周期，响应式数据发生变化，页面在重新渲染前执行这个钩子。
updated() : 更新阶段的生命周期，响应式数据发生变化，页面在重新渲染后执行这个钩子。
beforeDestroy() : vue实例销毁前调用，卸载阶段，页面卸载前，清楚一些定时器（window的）、订阅事件，因为这些不是vue的东西，只能我们手动清除。
destroyed() : vue实例销毁后调用，该钩子在服务器端渲染期间不被调用。
个人练习，仅供参考：
&lt;template&gt; &lt;div class="life main"&gt; &lt;h5&gt; 生命周期：页面内容的三个阶段创建阶段、更新阶段、销毁阶段。当一个页面内容出现在App.vue中，页面进入创建阶段。当响应式数据发生变化时页面自动更新，此时进入更新阶段，最后切换页面时，旧页面消失，就是进入了销毁阶段。 对应这个三个阶段，vue提供了不同的生命周期函数，也叫钩子函数。让我们可以在不同的阶段对页面内容进行处理。 &lt;/h5&gt; &lt;h5&gt; 创建阶段生命周期只会在组件第一次加载时执行。除非组件被卸载了，当再次进入这个页面，创建阶段的生命周期会再次执行。 &lt;/h5&gt; &lt;p id="p" @click="num++"&gt;num: {{ num }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { num: 1, timer: null, }; }, methods: { add() { this.num++; }, }, computed: { allName() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45bc8cf7b014a01ee129b74885709a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/515224db2a628c3dc8e1d85f208e90f3/" rel="bookmark">
			分布式数据之复制（Replication）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 1.1简介——使用复制的目的 在分布式系统中，数据通常需要被分散在多台机器上，主要为了达到以下目的：
扩展性，数据量因读写负载巨大，一台机器无法承载，数据分散在多台机器
上可以有效地进行负载均衡，达到灵活的横向扩展。容错、高可用，在分布式系统中，单机故障是常态，在单机故障下仍然希望
系统能够正常工作，这时候就需要数据在多台机器上做冗余，在遇到单机故
障时其他机器就可以及时接管。统一的用户体验，如果系统客户端分布在多个地域，通常考虑在多个地域部署
服务，以方便用户能够就近访问到他们所需要的数据，获得统一的用户体验。 数据的多机分布的方式主要有两种，一种是将数据分片保存，每个机器保存数据的部分分片（Kafka 中称为 Partition，其他部分系统称为 Shard），另一种则是完全的冗余，其中每一份数据叫做一个副本（Kafka 中称为 Replica），通过数据复制技术实现。在分布式系统中，两种方式通常会共同使用，最后的数据分布往往是下图的样子，一台机器上会保存不同数据分片的若干个副本。本系列博文主要介绍的是数据如何做复制，分区则是另一个主题，不在本文的讨论范畴
复制的目标需要保证若干个副本上的数据是一致的，这里的“一致”是一个十分不确定的词，既可以是不同副本上的数据在任何时刻都保持完全一致，也可以是不同客户端不同时刻访问到的数据保持一致。一致性的强弱也会不同，有可能需要任何时候不同客端都能访问到相同的新的数据，也有可能是不同客户端某一时刻访问的数据不相
同，但在一段时间后可以访问到相同的数据。因此，“一致性”是一个值得单独抽出来细说的词。在下一篇文章中，我们将重点介绍这个词在不同上下文之间的含义。此时，大家可能会有疑问，直接让所有副本在任意时刻都保持一致不就行了，为啥还要有各种不同的一致性呢？我们认为有两个考量点，第一是性能，第二则是复杂性。
性能比较好理解，因为冗余的目的不完全是为了高可用，还有延迟和负载均衡这类提升性能的目的，如果只一味地为了地强调数据一致，可能得不偿失。复杂性是因为分布式系统中，有着比单机系统更加复杂的不确定性，节点之间由于采用不大可靠的网络进行传输，并且不能共享统一的一套系统时间和内存地址（后文会详细进行说明），这使得原本在一些单机系统上很简单的事情，在转到分布式系统上以后就变得异常复杂。这种复杂性和不确定性甚至会让我们怀疑，这些副本上的数据真的能达成一致吗？下一篇文章会专门详细分析如何设计算法来应对这种复杂和不确定性。
2.数据复制模式 总体而言，最常见的复制模式有三种，分别为主从模式、多主节点模式、无主节点模式，下面分别进行介绍。
2.1 最简单的复制模式——主从模式 简介
对复制而言，最直观的方法就是将副本赋予不同的角色，其中有一个主副本，主副本将数据存储在本地后，将数据更改作为日志，或者以更改流的方式发到各个从副本（后文也会称节点）中。在这种模式下，所有写请求就全部会写入到主节点上，读请求既可以由主副本承担也可以由从副本承担，这样对于读请求而言就具备了扩展性，并进行了负载均衡。但这里面存在一个权衡点，就是客户端视角看到的一致性问题。这个权衡点存在的核心在于，数据传输是通过网络传递的，数据在网络中传输的时间是不能忽略的。
如上图所示，在这个时间窗口中，任何情况都有可能发生。在这种情况下，客户端何时算写入完成，会决定其他客户端读到数据的可能性。这里我们假设这份数据有一个主副本和一个从副本，如果主副本保存后即向客户端返回成功，这样叫做异步复制（1）。而如果等到数据传送到从副本 1，并得到确认之后再返回客户端成功，称为同步复制（2）。这里我们先假设系统正常运行，在异步同步下，如果从副本承担读请求，假设 reader1 和 reader2 同时在客户端收到写入成功后发出读请求，两个 reader 就可能读到不一样的值。
为了避免这种情况，实际上有两种角度的做法，第一种角度是让客户端只从主副本读取数据，这样，在正常情况下，所有客户端读到的数据一定是一致的（Kafka 当前的做法）；另一种角度则是采用同步复制，假设使用纯的同步复制，当有多个副本时，任何一个副本所在的节点发生故障，都会使写请求阻塞，同时每次写请求都需要等待所有节点确认，如果副本过多会极大影响吞吐量。而如果仅采用异步复制并由主副本承担读请求，当主节点故障发生切换时，一样会发生数据不一致的问题
很多系统会把这个决策权交给用户，这里我们以 Kafka 为例，首先提供了同步与异步复制的语义（通过客户端的 acks 参数确定），另外提供了 ISR 机制，而只需要 ISR中的副本确认即可，系统可以容忍部分节点因为各种故障而脱离 ISR，那样客户端将不用等待其确认，增加了系统的容错性。当前 Kafka 未提供让从节点承担读请求的设计，但在高版本中已经有了这个 Feature。这种方式使系统有了更大的灵活性，用户可以根据场景自由权衡一致性和可用性
2.1.1主从模式下需要的一些能力 增加新的从副本（节点） 在 Kafka 中，我们所采取的的方式是通过新建副本分配的方式，以追赶的方式从主副本中同步数据。数据库所采用的的方式是通过快照 + 增量的方式实现。
a. 在某一个时间点产生一个一致性的快照。 b. 将快照拷贝到从节点。 c. 从节点连接
到主节点请求所有快照点后发生的改变日志。 d. 获取到日志后，应用日志到自己的
副本中，称之为追赶。 e. 可能重复多轮 a-d。 处理节点失效 从节点失效——追赶式恢复
针对从节点失效，恢复手段较为简单，一般采用追赶式恢复。而对于数据库而言，从节点可以知道在崩溃前所执行的最后一个事务，然后连接主节点，从该节点将拉取所有的事件变更，将这些变更应用到本地记录即可完成追赶。
对于 Kafka 而言，恢复也是类似的，Kafka 在运行过程中，会定期项磁盘文件中写入 checkpoint，共包含两个文件，一个是 recovery-point-offset-checkpoint，记录已经写到磁盘的 offset，另一个则是 replication-offset-checkpoint，用来记录高水位（下文简称 HW），由 ReplicaManager 写入，下一次恢复时，Broker 将读取两个文件的内容，可能有些被记录到本地磁盘上的日志没有提交，这时就会先截断（Truncate）到 HW 对应的 offset 上，然后从这个 offset 开始从 Leader 副本拉取数据，直到认追上 Leader，被加入到 ISR 集合中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/515224db2a628c3dc8e1d85f208e90f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f9eb960b760acb226d3c727903077b/" rel="bookmark">
			Hbase进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过hive操作hbase的注意事项：
（1）启动yarn服务：
yarn-daemon.sh start resourcemanager
yarn-daemon.sh start nodemanager
（2）在hive中建表时附加上：
stored by 'org.apache.hadoop.hive.hbase.HBaseStorageHandler'
with serdeproperties ("hbase.columns.mapping"=":key,列族:列名,...")
tblproperties("hbase.table.name" = "表名");
=====例1=====
--在hbase中创建表
create 'customer','order','addr'
--在hive中创建表映射
create external table customer(
name string, order_numb string,
order_date string,
addr_city string,
addr_state string)
stored by 'org.apache.hadoop.hive.hbase.HBaseStorageHandler'
with serdeproperties ("hbase.columns.mapping"=":key,order:numb,order:date,addr:city,addr:state")
tblproperties("hbase.table.name" = "customer")
;
--在hive中执行以下更新查询操作
insert into table customer values ('James','1121','2018-05-31','toronto','ON');
select * from customer;
--在hbase中执行如下语句
scan 'customer'
put 'customer','Smith','order:numb','1122'
put 'customer','Smith','order:date','2019-09-12'
put 'customer','Smith','addr:city','beijing'
put 'customer','Smith','addr:state','HD'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4f9eb960b760acb226d3c727903077b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7d52a38fe398f7fb23e5a76624519c/" rel="bookmark">
			将Debug目录下的所有文件打包到exe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关闭杀毒软件，
最终结果
设置图标
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504b0bd6f4a4d7fe6a322e3447c99dfd/" rel="bookmark">
			书生·浦语大模型全链路开源体系 学习笔记 第一课
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 大模型是发展人工通用人工智能的一个重要途径，能够解决多种任务和多种模态，展示了一个更面向更高阶的智能的潜在途径。大模型的发展历程是从专用模型到通用模型的过程，从语音识别、图像识别、人脸识别等专用模型，到通用的大模型，能够解决多种任务和多种模态。
书生浦语大模型覆盖了轻量级、中量级、重量级的不同大小的系列，具备强大的性能和全面的优势，能够超过相近量级的模型，且开源可用。
技术路线-从模型到应用 有了模型之后，需要在多个场景应用。从模型怎么样去到最终的应用，是目前研究的重点方向之一。
第一步模型选型。针对于应用场景，比较多种大模型相关维度的能力，进行模型评测。经过模型评测初步选型之后，可选定意向大模型。
第二步评估业务场景复杂度。若不复杂，可直接把模型拿过来应用。则继续如果业务场景非常复杂，通常来讲直接开源模型无法满足需求，需要微调、prompt工程等进一步构建。
第三步，判断全参数微调或部分微调等，并计算所需算力，应提前规划，避免微调失败。如果算力足够，可进行全参数微调。如果算力资源比较受限，只能进行部分参数微调，类似把大部分的参数固定住，只调一小部分参数。
第四步，构建基于大模型的智能体需要考虑模型与环境的交互。如果需要调用外部API或与已有业务数据库交互，就需要构建智能体。如果不需要与环境交互，就可以直接将微调好的模型在业务场景中试用。
第五步，模型评测，并评估是否上线应用或继续迭代。
第六步，模型部署。关于软件系统相关性能、安全、功能等方面内容。如考虑如何以更少的资源部署模型，或者如何提升整个应用的吞吐量。
开源数据和工具-书生·浦语 进行了一些基本介绍。
书生·浦语大模型全链路开源体系_哔哩哔哩_bilibili
书生浦语全链条开放体系，包括了书生万卷多模态的语料库，包括文本、图像、视频等数据，大小超过2个TB，涵盖了不同领域的数据。提供了超过5400多个数据集，涵盖了30多种模态，总共大概有80TB的数据，包括图像、视频、文本语料、3D模型、音频等不同数据。
预训练工具的特点包括高可扩展性、极致的性能优化、兼容主流生态、开箱启用等特点。
增量续训和有精度微调的区别是什么？增量续训主要是让基座模型学习到新的知识，训练数据通常包括垂直领域的文章、书籍、代码等；有精度微调主要是让模型学会理解和遵循各种指令，训练数据主要是高质量的对话数据和问答数据。
有监督微调中的部分参数微调是什么？部分参数微调是将预先的权重固定住，引入新的较小的可训练参数进行微调，可以大大节省训练代价。
xTuner框架能够适配多种生态，兼容不同的微调算法和策略，同时能够加载开源生态的模型和数据集，并进行自动化优化加速。xTuner框架支持NVIDIA20系以上的所有显卡，包括2080、3060到3090等。同时支持多种数据格式和训练引擎。
OpenCompass评测体系是一个全球领先的开源评测体系，提供了六大维度和超过80个数据集，支持40多万道评测题目，涵盖了大模型能力的多个维度和细分，形成一个比较全面的评测体系。同时，它不仅仅是一个评测维度或体系，还提供了一系列工具。包括平台级架构，分为模型层和能力层，支持基础模型和对话模型，以及通用能力和特色能力等评测。
OpenCompass提供了便捷的数据集接口，社区用户可以快速添加自定义的数据集。支持主流的模型
部署方面 语言模型部署面临的技术挑战包括设备存储、推理加速、动态shape、内存管理和利用、吞吐量提升、请求响应时间降低等
LMDeploy是一个高效的推理框架，能够提供大模型部署的全流程解决方案。
智能体应用方面 LLM作为核心，执行不同动作如网络搜索、python代码解释器等
legend支持哪些大语言模型？
AgentLego可以做什么？可以连接大语言模型和环境，调用更多的工具完成任务。
Lagent和AgentLego有什么区别？Lagent是搭建智能体框架，而AgentLego是为大模型提供工具集合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f969b8769af938540e65640aeff6c41e/" rel="bookmark">
			Git的基础知识（持续更新中~）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/30/">«</a>
	<span class="pagination__item pagination__item--current">31/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/32/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>