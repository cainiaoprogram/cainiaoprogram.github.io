<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee63cb7f14ba2a9a3102e707f619af8/" rel="bookmark">
			阿里云实习生部门笔试2020.04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		月初申请阿里c/c++实习生，公司很快安排了上机笔试，是两道算法题大题，很难，没刷过题导致题目也看不怎么懂。
笔试完第二天阿里云打电话安排另一场笔试，题目如下：
//评测题目: 无 第一题： char str[] = “http://www.ibegroup.com/” char *p = str ; int n = 10; 请计算 sizeof (str ) = sizeof ( p ) = sizeof ( n ) = void Foo ( char str[100]){ 请计算 sizeof( str ) = } void *p = malloc( 100 ); 请计算 sizeof ( p ) = 第二题: 已知strcat函数的原型是char *strcat (char *strDest, const char *strSrc); 其中strDest 是目的字符串，strSrc 是源字符串。不调用C++/C 的字符串库函数，请编写函数 strcat 第三题：举例说明内存对齐的问题 第四题：简述C语言中Static和const关键字的用法 第五题：有数据库表student_score，字段为(stu_id, score1, score2, score3, score4)，记录学生四门功课的成绩。 用一条sql语句，统计总分超过300分的学生个数。 笔试完面试官现场检查然后问问题，内容涉及：TCP通讯，编译原理，c/c++语言特性，linux，makefile等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fee63cb7f14ba2a9a3102e707f619af8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad0b0ed5d281c2aa96887252195396c/" rel="bookmark">
			有了它（powermock）再也不担心单元测试不达标了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要写单元测试 优点：单元测试可以减少bug率,提升代码的质量。还可以通过单元测试来熟悉业务。公司硬性要求：有些公司可能还会强制要求，每次新增代码、或者变更代码单测覆盖率要达到多少比例才能申请代码合并请求。 选择哪个单元测试框架 目前应用比较普遍的java单元测试工具 junit4+Mock（Mockito、jmock、EasyMock、powermock）。为什么会选择powermock？
在做单元测试的时候，我们会发现我们要测试的方法会有很多外部依赖的对象或者一些其他服务的调用比如说（发送邮件，网络通讯，soa调用）。 而我们没法控制这些外部依赖的对象。 为了解决这个问题，我们需要用到Mock来模拟这些外部依赖的对象,从而控制它们。只关心我们自己的业务逻辑是否正确。而这时powermock就起作用了，它不仅可以mock外部的依赖，还可以mock私有方法、final方法，总之它的功能很强大。
什么是powerMocker PowerMock是一个框架，它以更强大的功能扩展了其他模拟库，例如EasyMock。 PowerMock使用自定义的类加载器和字节码操作来模拟静态方法，构造函数， 最终类和方法，私有方法，删除静态初始化程序等。通过使用自定义类加载器，无需对IDE或持续集成服务器进行任何更改，从而简化了采用过程。熟悉受支持的模拟框架的开发人员会发现PowerMock易于使用，因为整个期望API都是相同的，
无论是静态方法还是构造函数。PowerMock 旨在通过少量方法和注释扩展现有的API，以启用额外的功能。
常用注解 @RunWith(PowerMockRunner.class)
告诉JUnit使用PowerMockRunner进行测试@PrepareForTest({DemoDao.class})
所有需要测试的类列在此处，适用于模拟final类或有final, private, static, native方法的类@PowerMockIgnore({“javax.management.", "javax.net.ssl.”})
为了解决使用powermock后，提示classloader错误@SuppressStaticInitializationFor
不让静态代码加载
其他更多注解可以参考：https://github.com/powermock/powermock/wiki/Suppress-Unwanted-Behavior 如何开始 JUnit 4.4及以上 &lt;properties&gt; &lt;powermock.version&gt;2.0.2&lt;/powermock.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt; &lt;version&gt;${powermock.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt; &lt;version&gt;${powermock.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; powerMock样例 这是一个需要被mock的类里面有私有方法、静态方法、等等下面一一来演示各个方法的mock功能。
/** * * @Date: 2020/3/31 * @Description: */ @Repository public class DemoDao { public String mockPublicMethod(String type) throws Throwable { throw new Throwable(); } public final String mockFinalMethod(String type) throws Throwable { throw new Throwable(); } public static String mockStaticMethod(String type) throws Throwable { throw new Throwable(); } } /** * @Date: 2020/3/31 11:34 * @Description: */ @Component public class DemoService extends AbstractDemo{ @Autowired private DemoDao demoDao; public String mockPublicMethod() throws Throwable { return demoDao.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad0b0ed5d281c2aa96887252195396c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/465687eb668de872b3fab0764fd3ea54/" rel="bookmark">
			LeetCode 787 - K 站中转内最便宜的航班
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 787. K 站中转内最便宜的航班
解法：DP（C++） d p ( k , v ) dp(k, v) dp(k,v)表示最多中转 k k k站由 s r c src src到 v v v的最低花费，则转移方程为 d p ( k , v ) = m i n ( d p ( k − 1 , v ) , d p ( k − 1 , u ) + w ( u , v ) ) dp(k,v)=min(dp(k-1,v),dp(k-1,u)+w(u,v)) dp(k,v)=min(dp(k−1,v),dp(k−1,u)+w(u,v))
b a c k u p [ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/465687eb668de872b3fab0764fd3ea54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447b5aa5d1ffb7cbe3e3c97bc476602b/" rel="bookmark">
			Numpy 拼接数组的各种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Numpy 拼接数组的各种方式 拼接方法介绍numpy.append(arr, values, axis=None)numpy.concatenate((a1, a2, ...), axis=0, out=None)stack(), hstack(), vstack()np.r_ 和 np.c_ 总结将两个一维数组拼接成一个更长的一维数组：将两个一维数组拼接成二维数组：拼接两个二维数组 拼接方法介绍 numpy.append(arr, values, axis=None) 可以拼接一个数组和一个数值或两个数组，但三个及以上数组不能直接append拼接。
&gt;&gt;&gt; import numpy as np &gt;&gt;&gt; a = np.array([1, 2, 3]) &gt;&gt;&gt; b = np.array([5, 6, 7]) # 拼接一个数组和数值 &gt;&gt;&gt; np.append(a, 4) array([1, 2, 3, 4]) # 拼接两个数组 &gt;&gt;&gt; np.append(a, b) array([1, 2, 3, 5, 6, 7]) # 拼接列表成为数组 &gt;&gt;&gt; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]]) array([1, 2, 3, 4, 5, 6, 7, 8, 9]) # 不同坐标轴方向的拼接 &gt;&gt;&gt; np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/447b5aa5d1ffb7cbe3e3c97bc476602b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a1cd636b7e3daaa5d86a6b78a7cb6c/" rel="bookmark">
			SAS的Sum Statement
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Sum Statement
The following program is submitted:
data all_sales; infile 'file-specification'; input receipts; &lt;insert statement(s) here&gt; run; Which statement(s) complete(s) the program and produce(s) a running total of the Receipts variable?
a. total+receipts;
b. total 0;
sum total;
c. total=total+receipts;
d. total=sum(total,receipts);
答案：a
SAS中sum statement语句表达式，total+receipts;初始total为0，然后累加。
Here are examples of sum statements that illustrate various expressions:
balance+(-debit); sumxsq+x*x; nx+(x ne .); if status='ready' then OK+1; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27c1c792e4f5caf0b339dd23c0a8195/" rel="bookmark">
			Pycharm无法输入中文怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Pycharm无法输入中文或显示编码错误怎么办？ 那当然是调整一下啊！！！ 调整Pycharm中文编码总共三个步骤 第一步，打开Pycharm；第二步，调整编码方式；第三步，没有第三步，调整好了不就可以用了嘛！ 基于第一步太简单，实在没有啥难度，我就不再啰嗦了。
我们直接上手第二步，干就完了，奥利给！！！
基本上按照上面两幅图的操作就能搞定了，如果还不行的话，请看下面继续下面的操作： 如果是打开的文件编码有误的话，请看下面这个帖子哦~ https://blog.csdn.net/andyleo0111/article/details/104731380 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/906b055c7c1c03346a50a7574c0c37f0/" rel="bookmark">
			数据结构与算法——队列（python版附带详细例子）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		author：xiao黄
缓慢而坚定的生长
单向队列 队列也是一种基本的数据结构，在队列中的插入和删除都遵循先进先出（First in First out, FIFO）的原则。元素可以在任何时刻进行插入，但是只有在队列最前面的元素才能被删除。
通常将队列中允许插入的一端称为队尾，将允许删除的一端称为队头。
队列的抽象数据类型 对于队列Q而言，有下面的一些基本的方法：
Q.enqueue(x)：向队列Q的队尾添加一个元素；Q.dequeue()：从队列Q中移除并返回第一个元素，如果队列为空，则触发一个错误；Q.first()：返回队列Q中的第一个元素，但并不删除该元素，如果队列为空，则触发一个错误；Q.len()：返回队列Q中元素的数量；Q.isEmpty()：如果队列Q没有包含任何元素，则返回"True"，否则返回"False"。 下面用一个表格来讲解一下队列的基本操作：
基于数组的队列实现 通过使用python列表来实现一个队列。
先上简化版的队列代码：
class ArrayQueue: # 创建一个先入先出的队列 def __init__(self): # 创建一个空队列 self._items = [] def isEmpty(self): # 如果队列为空则返回'True' return len(self._items) == 0 def enqueue(self, x): # 向队列尾部添加元素x self._items.insert(0,x) def dequeue(self): # 移除第一个元素并返回 # 如果队列为空，则触发一个错误 if self.isEmpty(): raise Exception('Queue is empty') return self._items.pop() def len(self): # 返回队列中元素的数量 return len(self._items) def first(self): # 返回队列中第一个元素，但并不移除 # 如果队列为空，则触发一个错误 if self.isEmpty(): raise Exception('Queue is empty') return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/906b055c7c1c03346a50a7574c0c37f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a35bf239b269142cbdb5b6e72fb16b2/" rel="bookmark">
			P1162 填涂颜色——dfs算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由数字000组成的方阵中，有一任意形状闭合圈，闭合圈由数字111构成，围圈时只走上下左右444个方向。现要求把闭合圈内的所有空间都填写成222.例如：6×66 \times 66×6的方阵（n=6n=6n=6），涂色前和涂色后的方阵如下：
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a35bf239b269142cbdb5b6e72fb16b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/175cde7c1987df8edfb7fac837d338a1/" rel="bookmark">
			BC协议总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BC协议总结 1、 问：为什么要引入这个规范？ 答：原有USB2.0规范并没有考虑到使用USB接口为便携式设备的电池进行充电的需求， 而这样的需求却越来越多。BC规范要解决的就是这个问题，符合规范的设备和系 统即向下兼容USB2.0标准，又针对充电做出了特别的优化。 2、 问：BC的内容是什么 答：BC规范的核心内容就是引入了充电端口识别机制。 3、 问：便携式设备有几种USB充电接口？ 答：有三种，分别为： Portable Device ： (以下简称PD)指设备本身用电池供电的便携式USB外设或者OTG设备， 可以通过USB接口来为自身的电池充电。BC规范建议这些的PD应该具 备相应的端口识别能力和对从USB总线获取电流的控制能力。 A、 Standard Downstream Port ： 基本上，这个 Standard Downstream Port 指符合现有USB2.0规范的主机(HOST)或集线器(HUB)上 的下行USB接口。根据USB2.0规范，当USB外设处于未连接(un-connect)或休眠(suspend)的状态时， 一个 Standard Downstream Port 可向该外设提供不超过2.5mA的平均电流;当外设处于已经连接并 且未休眠的状态时，电流可以至最大100mA;而当外设已经配置(configured )并且未休眠时，最大可 从VBUS获得500mA电流。 B、 Charging Downstream Port : Charging Downstream Port 是即兼容USB2.0规范，又针对USB充电作出了优化的下行USB接口，它可 以是主机上的USB接口，也可以是USB集线器上的。这些下行USB接口能配合Portable Device 完成 充电端口识别动作，并提供最大至1.5A的供电能力，满足PD大电流快速充电的需求 C、 USB Charger ： BC1.1规范中定义的 USB Charger 与目前市面上可以买到的USB专用充电器类似。 USB Charger 通过USB口为PD提供 充电所需电能，BC1.1要求将USB Charger中的D+和D-进行短接，以配合PD的识别动作，但它不具备和USB设备通信的 能力。规范中对USB Charger的电压电流输出能力做出了较严格要求，以确保PD的安全。 4、问： 如何识别USB端口? 这其中有什么协议约定，或者USB端口识别机制是如何进行工作的？ 答： BC规范的核心在于充电识别机制，通过这个机制，当PD插入到USB接口时，PD将识别出所插入的USB接口类型。 Standard Downstream Port的检测机制： 当PD插入到USB接口以后，它向 D+ 上加载一个0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/175cde7c1987df8edfb7fac837d338a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d08091826729552ff028dbb60ea4b15/" rel="bookmark">
			5G NR PDCP协议（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5G NR协议栈其他博文参考：
https://blog.csdn.net/qq_41245381/article/details/105805643
5G NR PDCP协议（一）参考：
https://blog.csdn.net/qq_41245381/article/details/105831692
一、切换 1.1 移动性概述
移动通信的核心技术是终端的可移动性，根据终端是否处于连接态，移动性可分为两种，非连接态和连接态。其中非连接态又可分为两种，小区选择和小区重选，在这两种情况下，终端都没有做通信业务，终端自己检测到更好的信号，决定移动到目的小区。连接态的移动性只有一种——切换，终端做业务期间根据网络设置的测量策略，周期性上报测量结果，网络侧根据测量报告作出切换判决。 小区重选和小区切换在本质上是一样的，都是手机从当前驻留的小区更换到另一个信号质量更好的小区。它们的区别主要是手机做重选时协议状态处于空闲态，手机做切换时协议状态处于连接态（手机正在做通信业务，打电话、上网等）。小区切换技术是移动通信系统的关键技术，它实现了用户在通话或者上网过程中，手机和网络之间的无线链路自动的从一个小区到另外一个小区的转接，且不会中断通话或数据业务，从而真正的实现了无线覆盖的连续性。切换的目的和小区选择/重选的一样，都是是选择最优的无线通信资源块，从而提供更好的通信质量，它也是无线链路的重要控制手段，能够保持手机在穿越不同的蜂窝小区时通话的连续性，减小掉话率，并且能提供更好的上网体验。
1.2 切换概述
从LTE开始，根据无线承载（Radio Bearer）的QoS要求的不同，切换过程可以分为无缝切换(Seamless handover)和无损切换(lossless handover)。
无缝切换，应用于对于时间延迟有严格要求，而对误包率（丢包率）具有相对容忍度的一些应用（比如，语音VoIP）。无缝切换在LTE中可以降低切换的复杂度和时间延迟，但同时可能引起某些数据包的丢失。无缝切换主要应用于控制面的无线承载（SRB）以及用户数据面RLC UM模式的无线承载。 在无缝切换的模式下，对于下行的数据传输，源gNB将尚未进行传输的PDCP SDU转发给目标gNb，对于经N3接口转发下来，尚未进行PDCP处理的下行数据，源gNb也同样转发给目标gNb。已经完成 PDCP SDU传输的下行数据， 则无需转发给目标gNb。对于已经进行了部分PDCP SDU的传输，但尚存部分RLC PDU的数据，源gNb会将剩余的RLC PDU丢弃，也就是说，在无缝切换模式下，源gNb不会将下行数据的RLC 上下文 （RLC Context）转发给目标gNb，这样，这部分PDCP SDU的数据将会丢失。目标gNb侧，会将PDCP的SN和HFN重新置为零。同时，目标gNb在传输经由N3接口的下行数据之前，会优先传输源gNb通过Xn接口转发过来的下行数据。我们知道，UPF在将下行通道切换到目标gNb之前会向源gNb发送“End Marker”数据包。源gNb会将此数据包转发给目标gNB。目标gNb据此可以获知源gNb转发数据的结束。
在无缝切换的模式下，对于上行的PDCP SDU数据， 同样，对于已经在源gNb中完成传输的数据，UE不会在目标gNb中重新发送。相反， 在目标gNb中，UE 将传输那些尚未在源gNb中传输的PDCP SDU数据，源gNb将所有接收到的PDCP SDU上行数据递交给UPF，其中可能包括有失序的PDCP SDU。对于无法组装成PDCP SDU的部分RLC PDU分段，源gNb将把他们丢弃。也就是说，无缝模式下源gNb并不将上行数据的RLC 上下文转发给目标gNb，这部分对应的PDCP SDU上行数据将会丢失。
无损切换主要用于RLC AM模式的无线承载，典型的例子如FTP上下载，PDCP SDU传输的丢失可能对上层协议（TCP）的吞吐量有较大的影响，相反，对于时间延迟不象实时应用那样敏感。 在无损切换中，对于上行数据，切换到目标gNb后，UE会从第一个尚未在源gNb中得到确认的PDCP SDU开始，重传该序号以后的PDCP SDU包（其中可能包括源gNb收到，但UE没有收到确认的PDCP SDU或UE虽收到确认，但失序的PDCP SDU），除非目标gNb通过PDCP 状态报告包确认收到其中的某些SDU（源gNb转发给目标gNb）。
在无损切换的过程中，对于下行的PDCP SDU，如果UE已经在源gNb中完成PDCP SDU的确认， 源gNb无需将它们转发给目标eNodeB （包括连续的和失序的PDCP SDU）。源gNb需要将尚未传输完毕（包括已有部分传输和尚未进行传输的。注意，与无缝切换中不同，无缝切换中转发的是尚未进行传输的SDU）的PDCP SDU转发给目标gNb，包括经N3接口转发下来，尚未进行PDCP处理的下行数据。对于已经进行了部分PDCP SDU的传输，但尚存部分RLC PDU的数据，源gNb会将RLC PDU丢弃，也就是说，在无损切换模式下，源gNb不会将RLC 上下文 （RLC Context）转发给目标gNb（源gNb丢弃的只是RLC的上下文，并非是PDCP SDU的数据，PDCP SDU的数据仍会转发给目标gNb，因为他们属于尚未传输完毕的PDCP SDU）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d08091826729552ff028dbb60ea4b15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8693daf44eb6c76ce86b27dd0d065e80/" rel="bookmark">
			世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。
输入格式：
输入在一行中按照“mm-dd-yyyy”的格式给出月、日、年。题目保证给出的日期是1900年元旦至今合法的日期。
输出格式：
在一行中按照“yyyy-mm-dd”的格式给出年、月、日。
输入样例：
03-15-2017
输出样例：
2017-03-15
#include&lt;stdio.h&gt; int main() { int year,month,day; scanf("%d-%d-%d",&amp;month,&amp;day,&amp;year); printf("%04d-%02d-%02d\n",year,month,day); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f7a1bca22ffbd198d6c7b125050554b/" rel="bookmark">
			如何查看自己的Windows可用时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Win + R 进入 在输入框输入 slmgr.vbs -xpr 然后确定
注： slmgr.vbs 和 -xpr 之间有个空格，不要少。
2、确定之后，将会提示我们到期时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/135730437eab212896c8ea4c776e396e/" rel="bookmark">
			PCB中抗ESD的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常生活中，ESD （Electro-Static Discharge，静电放电）对于我们来说是一种常见的现象，然而对电子产品而言，ESD 往往是致命的——它可能导致元器件内部线路受损，直接影响产品的正常使用寿命，甚至造成产品的损坏。例如穿透元器件内部薄的绝缘层；损毁MOSFET 和CMOS 元器件的栅极；CMOS 器件中的触发器锁死；短路反偏的PN 结；短路正向偏置的PN 结；熔化有源器件内部的焊接线或铝线。因此，ESD 防护一直以来都是工程师们的工作重点。在PCB 板的设计当中，要达到期望的抗ESD 能力，使之具有最强的ESD 防范性能，可以通过分层、恰当的布局布线和安装实现PCB 的抗ESD 设计。以下是一些常见的防范措施。 （一）分层
尽可能使用多层PCB，在多层PCB 中地线面作为一个重要的电荷源，可抵消静电放电源上的电荷，这有利于减小静电场带来的问题。PCB 地线面也可作为其对信号线的屏蔽体（当然，地线面的开口越大，其屏蔽效能就越低）。另外，如果发生放电，由于PCB 板的地平面很大，电荷很容易注入到地线面中，而不是进入到信号线中。这样将有利于对元件进行保护，因为在引起元件损坏前，电荷可以泄放掉。当然在某些方案中为降低成本，只能使用双面板。
多层PCB 相对于双面PCB 而言，地平面和电源平面以及排列紧密的信号线-地线间距能够减小共模阻抗（common impedance）和感性耦合，使之达到双面PCB 的1/10 到1/100。同时尽量地将每一个信号层都紧靠一个电源层或地线层。对于顶层和底层表面都有元器件、具有很短连接线以及许多填充地的高密度PCB，可以考虑使用内层线。大多数的信号线以及电源和地平面都在内层上，因而类似于具备屏蔽功能的法拉第盒。
对于双面PCB 来说，要采用紧密交织的电源和地栅格，如图 所示。电源线紧靠在垂直和水平线或填充区之间，要尽可能多地连接。一面的栅格尺寸小于等于60mm。如果可能，栅格尺寸应小于13mm（0.5 英寸）。
（二）电路环路
电流通过感应进入到电路环路，这些环路是封闭的，并具有变化的磁通量。电流的幅度与环的面积成正比。较大的环路包含有较多的磁通量，因而在电路中感应出较强的电流。因此，必须减少环路面积。
最常见的环路如图 所示，由电源和地线所形成。在可能的条件下，可以采用具有电源及接地层的多层PCB 设计。前面的多层PCB 设计就是将电源和接地间的回路面积减到最小，而且也减小了ESD 脉冲产生的高频EMI 电磁场。
同时我们要确保信号线和相应回路之间的环路面积尽可能小。减少环路面积及感应电流的另一个方法是减小互连器件间的平行通路。如图所示。
当必须采用长于30 厘米的信号连接线时，可以采用保护线。一个更好的办法是在信号线附近放置地层。信号线应该距保护线或接地线层13 毫米以内。如图 所示。
将每个敏感元件的长信号线（》30 厘米）或电源线与其接地线进行交叉布置。交叉的连线必须从上到下或从左到右的规则间隔布置。如图所示。
（三）电路连线长度
要确保信号线尽可能短。因为天线要具有较高的效率，其长度必须是波长很大的一部分。这就是说，较长的导线将有利于接收静电放电脉冲产生的更多的频率成份；而较短的导线只能接收较少的频率成分。因此，短导线从静电放电产生的电磁场中接收并馈入电路的能量较少。信号线的长度大于300mm（12 英寸）时，一定要平行布一条地线，在信号线上方或其相邻面上放置地线也是可以的。在相关的元件组，相互之间具有很多互连线的元件应彼此靠得很近。例如，I/O器件是与I/O 连接器尽量靠得近些；以减少互连的印制线长度。
（四）地电荷注入
ESD 对地线层的直接放电可能损坏敏感电路。在使用TVS二极管的同时还要使用一个或多个高频旁路电容器，这些电容器放置在易损元件的电源和地之间。如图6 所示。旁路电容减少了电荷注入，保持了电源与接地端口的电压差。TVS使感应电流分流，保持TVS 钳位电压的电位差。TVS 及电容器应放在距被保护的IC 尽可能近的位置，要确保TVS 到地通路以及电容器管脚长度为最短，以减少寄生电感效应。
（五）保护电路中的寄生电感
TVS 二极管通路中的寄生电感在发生ESD 事件时会产生严重的电压过冲。尽管使用了TVS 二极管，由于在电感负载两端的感应电压VL=L×di/dt，过高的过冲电压仍然可能超过被保护IC 的损坏电压阈值。
保护电路承受的总电压是TVS 二极管钳位电压与寄生电感产生的电压之和，VT=VC+VL。一个ESD 瞬态感应电流在小于1ns 的时间内就能达到峰值（依据IEC 61000-4-2 标准），假定引线电感为每英寸20nH，线长为四分之一英寸，过冲电压将是50V/10A 的脉冲。经验设计准则是将分流通路设计得尽可能短，以此减少寄生电感效应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/135730437eab212896c8ea4c776e396e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b666471b86fb5637807b21d01542a5b/" rel="bookmark">
			厚颜无耻！剽窃开源项目赚钱，连原开发者名字都没删干净，反而有勇气质疑正主……...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击“开发者技术前线”，选择“星标????”
在看|星标|留言, 真爱
综合整理：程序员的那些事
参考：v2ex、GitHu
IINA 是一个开源的 macOS 播放器，使用 Swift 语言实现，遵循 GPLv3 许可证。
这个开源项目在 GitHub 有着 2 万 3 千多 Star，并且口碑还挺不错。
也正是因为开源，IINA 采用的 GPLv3 许可证与 Mac App Store （MAS）协议有冲突，所以它一直没有在 MAS 上架。反倒是一直有剽窃品上架了。
4 月 1 日，IINA 的开发者公开发帖称，他的软件又被人全盘剽窃然并且 App Store 上架销售了，剽窃者甚至连原开发者的名字都没删掉。
IINA 开发者称，
Apple 对这种事情的处理比较懒，会要求对方的开发者和我直接沟通。一小部分开发者可能会主动下架，但大部分都是选择沉默。对方的开发者在提醒两次都不回应的情况下，MAS 会将 App 强制下架，而这整个流程差不多要三个月（也就是对方开发者可以继续销售三个月）
今天遇到的这位开发者非常厉害。我把他回复的原话复制上来：请问我哪里使用了，请告知，谢谢！」
这款名叫 MPlayer X Pro 的 App 在港区售价 15 港币，国区应该是 12 元左右。如果你试用一下就会发现，它完全就是 IINA 的复制品。之前见过的复制品，有的还会加上一些分享之类的新功能，而这个相比之下显得非常没有诚意。
IINA 开发者对比剽窃品后发现：
此 App 和 IINA 有完全相同的用户界面，完全相同的 xib 结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b666471b86fb5637807b21d01542a5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/729185c78fb0fdf4d6024c1deb9bd91c/" rel="bookmark">
			学堂在线数据结构上5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章 二叉树
a树
1.下列哪种数据结构可以高效地兼顾静态操作和动态操作:树
解析:向量长于静态操作而列表长于动态操作,树则在某种程度上兼顾二者.
2.n个顶点的树有多少条边?n−1
3.树是:连通无环图
4.在一棵树中,顶点p是顶点v的父亲,则它们的高度的关系是
height(v) &lt; height§
b.树的表示
1.用父节点+孩子节点的方法存储n个节点的树,需要的空间是:
O(n)
2.
以上树在计算机中表示如下:
第三行中parent[]的内容应该是:-1, 5, 5, 7, 0, 4, 5, 0, 0, 7
c.二叉树
1.高度为h的满二叉树有多少个节点?2^(h+1)−1
解析：满二叉树深度为i的节点有2i个，求和得出答案
2.一棵高度为h,节点数为n的真二叉树的特点是:
不存在只有一个孩子的节点
3.在长子-兄弟表示法中,树中某节点的长子相当于二叉树中的:左子
d.二叉树的实现
1.设二叉树有n个节点,高度为h.在其中插入一个新的节点,高度发生改变的节点个数为:O(h)
解析：新插入节点到根节点的路径上所有节点(即新节点的祖先)高度都有可能变化.
e1.先序遍历
1.对以下二叉树进行先序遍历:
刚访问完节点d时（迭代实现2）栈中的元素从栈顶到栈底依次为:f
2.二叉树是:半线性结构
3.若在先序遍历中规定访问完根节点后先访问右子树再访问左子树,则左、右子树的入栈顺序是：先左后右
4.先序遍历的顺序是:先自上而下访问左侧链上的节点,再自下而上访问它们的右子树
e2.中序遍历
1.中序遍历中第一个被访问的节点是:最左的节点
2.对以下二叉树进行中序遍历:
节点c刚被访问完毕时栈中的元素从栈顶到栈底为:d, f
e3.层次遍历
1.层次遍历的次序是:自上而下访问各个深度的节点,同样深度的节点中自左向右
2.对以下二叉树进行层次遍历:
节点F正欲出队时队列中的元素从队头到队尾为:F,G
e4.重构
1.后序遍历序列中最后一个节点是：根节点
本章测试
1.二叉树有n个节点，高度为h。在其中插入一个新的节点，高度发生改变的节点个数最多为：O(h)
解析：新插入节点到根节点的路径上所有节点(即新节点的祖先)高度都有可能变化
2.高度为 h 的完全二叉树可能有多少个节点?2^h
解析：高度为h的完全二叉树节点最多的情况即满二叉树，最少的情况比高度为h-1的满二叉树多1。
3.下列关于树的命题中错误的是：在树中删除任一条边得到的还是树。
解析：删除一条边后得到两个连通分量
4.并查集是一种用于表示不相交集合的数据结构，支持以下操作：一种基本的实现是将每一个集合中的元素组织成一棵有根树，集合中的元素即树中的节点，选取树根为该集合的代表元，而整个并查集就是由若干棵树组成的森林。接口实现的方法是：
例子：下图中的并查集原先有两棵表示集合的树{c,h,b,e}和{f,d,g}，调用Union(h, f)后得到了右边的树，如果此时再调用Find(e)会返回f。
并查集中的树最适合用什么方法表示：
答：父节点法
解析：父节点法能够高效定位父亲而不能高效地定位孩子，而并查集中的树只需要能够定位父节点。
5.从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，以下说法中错误的是：
每上溯一层，当前节点的深度减小1，而高度增加1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/729185c78fb0fdf4d6024c1deb9bd91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1da3a7d7c629128d0967e0a58367dd3/" rel="bookmark">
			骨架矢量化sknw源码研读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路网分割后得到region，提取骨架得到centerline，之后需要进行矢量化得到结点和边，进而转化成geojson格式进行生产。
本文对矢量化函数库sknw源码进行研读，并改进源码使结点和边之间紧密连接。
一、骨架提取并矢量化demo from skimage.morphology import skeletonize from skimage import data import sknw import numpy as np import matplotlib.pyplot as plt # 骨架提取 img = data.horse() ske = skeletonize(~img).astype(np.uint16) # 矢量化调用函数 graph = sknw.build_sknw(ske) # draw image plt.imshow(img, cmap='gray') # draw edges by pts for (s, e) in graph.edges(): ps = graph[s][e]['pts'] plt.plot(ps[:, 1], ps[:, 0], 'green') # draw node by o # node, nodes = graph._node, graph.nodes() # ps = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1da3a7d7c629128d0967e0a58367dd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ff8dc9b931613619ca1a55fddc7820/" rel="bookmark">
			Centos中部署vue出现Error: EACCES: permission denied问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Error: EACCES: permission denied问题集锦 前言错误截图总结 前言 由于才开始接触vue，然后在centos中部署vue项目时，遇到很多问题。这里我记录一个在centos中使用npm install出现Error: EACCES: permission denied问题的解决方式。
错误截图 当我在执行 npm install命令时，出现下图错误。
出现上述问题，本仙人立马百度一通，毕竟作为一名渣渣，面向百度编程是不可或缺的技能。百度找到的解决方式我进行了罗列:
1）方式一 : 删除node_modules，再重新安装vue-cli。
npm install -g vue-cli
或者
sudo npm install -g vue-cli
或者
重新安装 node 后再 npm install -g vue-cli
请参考:https://blog.csdn.net/ZNYSYS520/article/details/84696173
PS：写这帖子的博主思路很清晰，就是重新安装vue-cli服务，如果不行?简单，连nodejs的环境你都重新安装一遍，再安装vue-cli。这脑回路这是牛逼，等同于你电脑死机了，先重装系统，还不行？换台电脑吧。(顺便一提，这种方式我尝试了，未能解决我的问题。)
2)方式二： 在命令前增加sudo，即"sudo npm stall"。
请参考:https://www.it610.com/article/5280509.htm
PS：该博主说是由于该命令没有管理员权限。(亲测，未能解决该问题。)
3)方式三：端口占用。
我们知道vue运行成功会默认占用8080端口，如下图:
PS：因此，如果该端口被占用了也可能会出现Error: EACCES: permission denied该错误。
(由于打开的网页太多，该方式的参考网址我找不到了。)
4)方式四：调整npm install指令
执行 npm install --save-dev grunt 命令
PS：该执行我也执行了，但是没有生成node_modules目录，因此我觉得口令本身可能是有误的。(亲测，未能解决问题)
请参考：https://blog.csdn.net/testcs_dn/article/details/78869419
4)方式4： 执行口令 ：(亲测，解决问题。)
npm install --unsafe-perm=true --allow-root
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ff8dc9b931613619ca1a55fddc7820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab19326ead0889c8c11b3bed6a8fb0e/" rel="bookmark">
			Core3.0 EntityFrameWork DbFirst  and CodeFirst
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DbFirst Asp.net Core3.0 MVC下使用EntityFrameWork框架实现DbFirst
一：生成
DbFirst 数据库优先
首先NuGet引入以下包
Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkC ore.Tools
Microsoft.EntityFrameworkCore.Design
Microsoft.EntityFrameworkCore.SqlServer
Microsoft.EntityFrameworkCore. SqlServer.Design
其次在程序包管理器控制台输入：
Scaffold-DbContext "Server=.;database=Core;uid=sa;pwd=123456" （数据库连接字符串）Microsoft.EntityFrameworkCore.SqlServer -OutputDir GeneralModels（任意文件夹名）
回车即可
生成后如下图
Ps:
CoreContext.cs是DbFirst根据数据库名称自动生成的数据库上下文类，不要擅自更改以免报错
然后打开上下文类注释掉OnConfiguring方法或者三个方法一起注释掉
其次打开appsettings.json文件，加入红色框中字符串，将其数据库连接写入配置文件。
最后打开Startup类，在ConfigureServices中注册添加代码：
即可
二：使用上下文增删改查
举例：在HomeController中使用上下文查询数据，在这里需要用到依赖注入中的构造函数注入，这里不过多阐述依赖注入原理，仅实现此次功能。
首先：声明一个上下文私有变量
private readonly CoreContext _coreContext;
然后：实例一个HomeConroller构造函数
public HomeController(CoreContext coreContext)
{
this._coreContext = coreContext;
}
这样我们就拿到了数据库上下文这个实例。
最后我们就可以进行增删改查了
这里直接贴出代码
如果数据库有修改字段或者表
在上面创建的命令后面 添加 -f 就好，-f 表示 -Force 覆盖
增、改、查的测试在下面 如果遇到 Build failed. 且没有提示，请把 项目 生成成功不报错了再执行 CodeFirst 先引用 NuGet 包
再编写继承自 DbContext 的数据库上下文类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ab19326ead0889c8c11b3bed6a8fb0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264a7c6c56a5cda74a2ba0ea604a8b1e/" rel="bookmark">
			struts2  简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、struts2 是一个框架，属于属于表现层，需要我们基于这个框架下进行开发。
特点：
可读性 可维护性 可拓展性。
javaEE 开发根据职责的纵向划分：表现层 业务层 持久层。也就所说的javaEE的三大框架（ssh）。
表现层：负责处理与界面交互的相关操作。（struts2/spring)。
业务层：负责复杂的逻辑业务计算和判断。（spring）
持久层：负责将业务逻辑数据进行持久化处理。（Hibernate/MyBatis）
如图所示：
MVC 思想
作用： 将表现层中的代码做的更加细致的划分，也就是说责任分离。
数据模型（model）负责封装应用的状态，并实现应用的功能。通常有划分为数据模型、业务模型，数据模型负责用来存放业务数据（订单信息、用户信息），业务模型包含应用的业务操作（数据添加、修改）等。（Service、DAO/Entity）
视图展现（view）：也就我们所说的界面，用来将模型的内容展现给用户，用户可以通过视图来请求模型进行更新，用户可以通过点击按钮向控制器发送请求。（jsp）
控制器（controller）：用来控制应用程序的流程和处理视图所发出的请求。（Selvlet）
二、前端控制器（核心控制器）
流程图：
前端控制（Front Controller）是在web应用系统前端设置一个入口控制器，所有的request请求都该发往该控制器统一处理。（认证 导航 session 国际化 本地化处理）
优点：
1、集中控制
2、提高管理性和安全控制能力
3、提高可重用性可扩展性
三、Struts2 入门
Struts1 与 Struts2 是相互不兼容的。
Struts2框架 = Struts1 + XWork；
Struts1 与 Struts2 区别
Struts1 有个核心控制器，但是只提供一个接口，也就是 execute ，还要配置actionform之类的，依赖性比较强。
Struts2 是针对拦截器来开发的，就是所谓AOP思想，可以配置很多的action，但是因为请求之前的拦截器有一些注入的操作，速度相对Struts1 慢一些。
3.1、 strut2 框架是通过过滤器来配置前端控制器 （web.xml）配置
语法如下：
&lt;filter&gt;
&lt;!--权限命名 -- &gt;
&lt;filter-name&gt;struts&lt;/filter-name&gt; --名称自定义
&lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt; --类路径 快捷键查找 【Ctrl+Shift+t】 输入【strutspre】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264a7c6c56a5cda74a2ba0ea604a8b1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bdb1a85c0c109b0adb9ec08121011e3/" rel="bookmark">
			深刻理解VLAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础概念： VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的LAN在逻辑上划分成多个广播域的通信技术。VLAN内的主机间可以直接通信，而VLAN间不能直接通信，从而将广播报文限制在一个VLAN内。
关键问题： 一、为什么要划分vlan？
1.减少广播风暴（广播数据充斥网络无法处理，并占用大量网络带宽，导致正常业务不能运行，甚至彻底瘫痪，这就发生了“广播风暴”。）
VLAN最大的好处是可以隔离冲突域和广播域，试想，如果一个局域网内有上百台主机，如果一旦产生广播风暴，那么，这个网络就会被彻底的瘫痪。
可以通过vlan还划分广播与，这样使得广播被限制在每一个vlan里面，而不会跨VLAN传播。
2、网络管理方便
另外一个好处就是管理灵活，当一个用户需要切换到另外一个网络时，只需要更改交换机的vlan划分即可，而不用换端口和连线。
二、广播域和冲突域
广播域就是一个站点发送的信号能接受这个信号的一个范围
冲突域指一个站点向另一个站点发出信号。除目的站点外，有多少站点能收到这个信号。这些站点就构成一个冲突域。这些站点就构成一个冲突域。所有的共享介质环境都是一个冲突域，在共享介质环境中一定类型的冲突域是正常行为。
集线器是物理层设备，通过广播转发数据看对应mac地址是否是自己mac地址，整个集线器是一个冲突域
交换机是二层设备，有分割冲突域的功能，每个端口都是独立的，每个端口都是一个冲突域
vlan工作过程
在同一vlan下可以相互通信，包括交换机之间相同vlan也可相互通信，实现这个技术在交换机之间连接一条trunk接口，即可实现同一vlan不同交换机之间进行通信。不同vlan不能通信。
如果要实现不同vlan的跨网段通信可以利用单臂路由技术进行通信，一个路由器通过划分子接口
三、本征vlan
经过trunk接口的数据帧都要被打上trunk接口的标记，除了本征vlan（默认是vlan1），如果没有打标记的vlan会被传输到本征vlan下，如果两头本征vlan不匹配的话，就会出现数据发错的情况
1.更改native vlan
Switch(config-if)#switchport trunk native vlan 2
2.在本征vlan为2的交换机上，连接一个pc1把它划分到vlan2下网段为192.168.3.0
3.在本征vlan默认（vlan1）的交换机上连接一个pc2网段为192.168.3.0
4.pc2 ping pc1发现可以ping通
实验部分： 实验拓扑
1.手动创建VLAN
如果不创建VLAN，在划分的时候直接写vlan号也会自动创建
(1) Switch#vlan database % Warning: It is recommended to configure VLAN from config mode, as VLAN database mode is being deprecated. Please consult user documentation for configuring VTP/VLAN in config mode. Switch(vlan)#vlan 10 name it VLAN 10 added: Name: it (2) Switch#conf t Enter configuration commands, one per line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bdb1a85c0c109b0adb9ec08121011e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa45b4e9f64c29ec20b7cd0ab9a907c/" rel="bookmark">
			Duplicate entry &#39;0&#39; for key &#39;PRIMARY&#39; 分析及其解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写了一个接口，里面用到了MyBatis的自增配置（ useGeneratedKeys ），写好后在使用Test测试时返发现报了错：Duplicate entry '0' for key 'PRIMARY'，如下图所示：
当时以为是因为之前自己自己手动在数据库表中插入的数据导致表数据中的数据记录条数没有被记录，把原数据删了后再次运行发现确实可以插进去，但是当我再次运行方法时发现又出现了这个问题，看来之前的办法并不对，在网上查了查，发现了是数据库表设计不合理导致的；
因为主键设置不能为空，因此默认是以"0"来进行填充的。因此在数据插入时数据的主键id值被0占据，但由于之前已经有数据了，id为“0”的索引已经被占，在使用就会报这个错误，因此我们只需要对表中的主键“id”设置成自增即可，设置（Navicat）如下：
设置好后再次测试：
《END》 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e405e616e4ccfec518fefb08adf69d/" rel="bookmark">
			5G NR协议栈SDAP、PDCP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5G NR协议栈其他博文参考：
https://blog.csdn.net/qq_41245381/article/details/105700029
https://blog.csdn.net/qq_41245381/article/details/105782751
一、SDAP概述 SDAP层是通过RRC信令来配置的，SDAP层负责将QoS流映射到对应的DRB上。一个或者多个QoS流可以映射到同一个DRB上，一个QoS流只能映射到一个DRB上。SDAP架构如图所示。
SDAP层功能主要有：
传输用户面数据为上下行数据进行QoS Flow到DRB的映射在上下行数据包中标记QoS FLow ID为上行SDAP数据进行反射QoS流到DRB的映射 SDAP实体位于SDAP层，每个PDU会话都会建立对应的SDAP实体，一个UE可以有多个SDAP实体（因为一个UE可以同时建立多个PDU会话）。一个SDAP实体从上层接收SDAP SDU（也就是应用层的数据包），将其打包为SDAP PDU（增加了SDAP header），最后通过下层（PDCP）将SDAP PDU发给对端SDAP实体。一个SDAP实体从下层（PDCP）接收对端SDAP实体发过来的SDAP PDU，去除SDAP header后，将SDAP SDU投递给上层。
二、PDCP概述 PDCP（Packet Data Convergence Protocol）层位于SDAP/RRC层和RLC层之间。它通过RLC通道（RLC channel）访问RLC层的传输服务，并向上层提供DRB(对SDAP，用户面)和SRB(对RRC，信令面)服务访问点(SAP)。
同一gNB下的两个UE通信流程如下图，UE2向UE1发数据。
用户面协议栈处理报文流程如下图。
5GNR的PDCP主要有3个功能：头压缩、加密/完保、排序
PDCP层加密功能只对Data部分（不包含SDAP协议头）进行。PDCP提供两种RB承载，SRB和DRB，其中SRB的Data PDU必须进行完整性保护，DRB的Data PDU可根据配置需要进行完整性保护。
PDCP实体内部结构如图，每个PDCP实体对应一个无线承载。同时，每个PDCP层都包含控制平面和用户平面，根据无线承载携带的信息确定相应的平面。如果存在RB分割，则添加Routing和Duplication功能。5GNR系统PDCP协议层的主要目的是发送或接收对等PDCP实体的分组数据PDCP PDU。PDCP的上层实体有两种，控制平面和用户平面，在控制平面，加密和完整性保护是必选功能；而在用户平面，可靠头压缩（ROHC）为必选功能，数据加密为可选功能，这里的数据既可以是用户数据，也可以是应用层信令，如SIP、RTCP等。5GNR中，PDCP是UE和gNB之间的传输协议，PDCP终结于gNB。PDCP向上层提供的业务包括：透明数据传输业务、确认的数据传输业务（包括对PDCP PDU传输成功的指示）、非确认的数据传输业务（按序传输、包复制或丢弃处理）等。 PDCP功能小结：
transfer of data (user plane or control plane);maintenance of PDCP SNs;header compression and decompression using the ROHC protocol;ciphering and deciphering;integrity protection and integrity verification;timer based SDU discard;for split bearers, routing;duplication;reordering and in-order delivery;out-of-order delivery;duplicate discarding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5e405e616e4ccfec518fefb08adf69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99c677ba5680fb992b8e2b2385f0345f/" rel="bookmark">
			挑选手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写的几篇激活系统，激活office都发布了破解版激活器，因故被下架了，中国现在对于知识产权的重视越来越高，盗版的产品首先在网络平台光明正大的发出来是不太现实了。
今天介绍挑选手机 首先明确一个概念手机就是微型电脑，在本质上在两个东西是一样的。对于手机不乏许多财主们，一年一款，一床的手机平板。
今天，我所面对的是广大的普通百姓， 也就是我自己这样的，如何挑选性价比高的手机。
首先明确自己的使用目的。看剧党，屏幕分辨率就是要考虑的一个问题；爱摄影，摄像头的水平就极关重要；等等吧之类的吧！但最重要的看CPU
手机cpu天梯图，百度就有。在同等价位，买一个cpu最好的，很多人买手机看新款，觉得新款的就好，然而对于普通用户不会花四五千买个手机，咱们面对的价位就是在2500以下，这个情况，一定不要买新款，去买旗舰级的老款，也就是去年三四五千的 今年会变到两千左右，尽管是去年的也比今年的中端机强，因为什么呢，cpu 强，cpu决定手机使用的寿命，因为每隔几个月就有新款CPU出来，直接百度，我就不一一介绍了， 一千以下的手机除了给老年人打电话用， 其他人就不要考虑了，因为你随便玩玩就卡了。手机这个东西确实是消耗品，但旗舰级就是能用四年，你在上市第二年买就是可以三年，然而你买中端机新款也就两年就卡的你不想用了，对于这几天新上市平板matepad我极度吐槽一下，官网2399，老款M6 2099 已经上市一年了，然而定位不同，新款810芯片跑分是不如老款旗舰980的，买的用户还觉得很开心，然而810跑分对标970差不多，970用户都已经使用两年多了，你才用上还在那乐呢？？？这就是花钱买的不值得了，对于小白用户，不要听信手机店推荐你买啥，推荐你买的都是利润最高的，在小编看来，新上的matepad 售价1700还差不多，因为之前放的810芯片最低已经卖到了1200元一台手机，所以仔细看看都是套路，干销售的都是满满套路，而我们需要做的就是在套路中寻求最大性价比。
当然这都是省钱之道，但俺还是想说，钱是挣出来的不是省出来的，希望每个人都能多多挣钱，有钱就不用对比了，直接最新的旗舰机真爽，钱能解决99%的问题是真的没毛病。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59285a855f25b2208d1b9b012adb48fd/" rel="bookmark">
			MyBatis-Plus 通过typeConvert进行java类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当生成的model实体类，java类型不满足时可以自定义转换 例如：datetime默认生成的java类型为localDateTime, 改成Date类型 // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl("jdbc:mysql://127.0.0.1:3306/xxx?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8"); dsc.setDriverName("com.mysql.cj.jdbc.Driver"); dsc.setUsername("111"); dsc.setPassword("111"); //类型转换 dsc.setTypeConvert(new ITypeConvert() { @Override public IColumnType processTypeConvert(GlobalConfig globalConfig, String fieldType) { String t = fieldType.toLowerCase(); if(t.contains("datetime")){ return DbColumnType.DATE; } //其它字段采用默认转换（非mysql数据库可以使用其它默认的数据库转换器） return new MySqlTypeConvert().processTypeConvert(globalConfig,fieldType); } }); mpg.setDataSource(dsc); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df4e8aed1e380f3bede5d9123b990259/" rel="bookmark">
			【算法竞赛刷题模板15】【二维数组前缀和】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【算法竞赛刷题模板15】【二维数组前缀和】 0.总结 Get to the points first. The article comes from LawsonAbs! 二维数组前缀和容斥原理 下面结合一道例题【洛谷】P2280 [HNOI2003]激光炸弹，来讲讲如何实现二维数组的前缀和。
1.题意 二维坐标中每个点都有一定的价值。求出坐标系中以某点作为边长m的正方形的右下角的最大价值。
2.思想 二维数组前缀和
这里的前缀指的是从(0,0) 到 (x,y)这个矩形区域，其和就是 s[x][y]前缀和的推导公式
s[i][j] = s[i-1][j] + s[i][j-1]- s[i-1][j-1] + val[i][j]，其中s[0][j]和 s[i][0]需要单独判断 如果用图形表示的话，则是下面这个样子
s[i][j] =
s[i][j] =
s[i-1][j] =
s[i-1][j-1]=
val[i][j]=
综合表述，也就是下面这个样子：
棕色是绿色和紫色的重合部分。
在得到前缀和的基础上，针对题目要求适当变形即可 3.代码 #include&lt;iostream&gt; using namespace std; const int X = 5005,Y = 5005,N = 5005; int s[N][N];//二维数组前缀和 int res = 0; int main(){ int n,m; cin &gt;&gt; n&gt;&gt; m; int a,b,w,mx=0,my=0; for(int i =0;i &lt; n;i++){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; w ; mx=max(mx,a);//求出坐标的最大值 my=max(my,b); s[a][b]+=w;//为节省空间，直接累加 } //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df4e8aed1e380f3bede5d9123b990259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a86482daed53e9f0426176d00db1c87/" rel="bookmark">
			IDEA Listener 模板设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 IDEA Listener 模板1. IDEA 提供的默认模板a. @WebListenerb. attributec. Listener 接口 2. 打开模板设置3. 推荐模板内容 IDEA Listener 模板 1. IDEA 提供的默认模板 import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpSessionAttributeListener; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; import javax.servlet.http.HttpSessionBindingEvent; @WebListener() public class Listener implements ServletContextListener, HttpSessionListener, HttpSessionAttributeListener { // Public constructor is required by servlet spec public Listener() { } // ------------------------------------------------------- // ServletContextListener implementation // ------------------------------------------------------- public void contextInitialized(ServletContextEvent sce) { /* This method is called when the servlet context is initialized(when the Web application is deployed).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a86482daed53e9f0426176d00db1c87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b89e59c5233e7007617a8113c12a811/" rel="bookmark">
			CommonJS 规范、ES6中的模块导出导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		·# 模块
require: node 和 es6 都支持的引入
export / import : 只有es6 支持的导出引入
module.exports / exports: 只有 node 支持的导出
CommonJS 规范定义的模块分为: 模块标识(module)
模块定义(exports)
模块引用(require)
exports 暴露值和函数 //my.js var name = 'jack'; exports.name = name; exports.user = 'lily'; //require var myname = require("./my.js"); var show = function() { } exports.show = show; exports.show = function(){ } var myshow = require('./my.js'); myshow.show(); module.exports 暴露类
require(“安装的包”)
require("./package/自定义的文件")
ES6中的模块导出导入 现阶段的node.js不支持export,export default
1,在package.json增加 babel的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b89e59c5233e7007617a8113c12a811/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bf736094696208bd26cf9066e7cc836/" rel="bookmark">
			demosiac
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Demosiac是整个ISP imaging pipeline的核心算法，将Bayer pattern的图像转换成RGB。
去马赛克算法是用于从覆盖有颜色滤波器阵列（CFA）的图像传感器输出的不完整颜色样本重建全色图像的数字图像处理。 也称为CFA插值或颜色重建。 重建图像通常在均匀着色的区域中是精确的，但是具有分辨率（细节和清晰度）的损失并且具有边缘伪影。
1. Bayer Pattern
我们知道，CMOS其实只能记录光子的能量，并不能记录光波的波长（即色彩信息），所以，为了得到图像的颜色信息，前人们想到了一种办法，就是在每一个像素面前加带颜色的滤光片，这样就知道某一颜色分量的光强了，柯达的工程师提出了下面这种pattern，也叫CFA（color filter array）。
这样就可以记录色彩信息了，绿色pixel比其他两种颜色多，是因为人眼对绿色(550nm左右)最敏感啊，为什么是这三种颜色呢，三原色呀，那么这样每个像素还是只有一种色彩呀，怎么能得到每个像素的所有色彩呢，插值去马赛克呗
图1
插值，邻域像素的色彩都有了，我们肯定是可以插值出本像素的值的。不过简单的双线性插值的方法总是在IQ上面有缺陷的。在图像的边缘，会产生伪彩色，这一点不难理解。
2. Demosiac CIP的基本方法
demosiac的插值一般遵循以下几个原则：
1.先对G分量进行插值，因为G的像素个数是GB的两倍
2.插值时采用方向性插值，即如果是垂直的边缘，则采用上下的像素进行插值，而不选用左右
3.Hamilton提出的patent奠定了基础，基本原理就是色差恒定，即相邻点的R(i,j)-G(i,j) = R(i, j+1)-G(i, j+1)
A.先获取图像中的物体的边缘
B.根据边缘信息重建G分量
C.根据哈密尔顿提出的色差恒定理论，重建R和B
D.一些后处理，包括伪彩色抑制和zipper cancelling等
3. Nearest Neighbor Replication
每个插值输出像素被分配输入图像中最近像素的值。 最近的邻居可以是上，下，左和右像素中的任何一个。
下面的示例在图2中以绿色平面中的3x3块为例。 在这里，我们假设左侧的相邻像素值用于填充缺失的像素值。
4. Bilinear Interpolation
绿色像素插值：将上，下，左和右像素值的平均值指定为插值像素的G值。 例如：G8 =（G3 + G7 + G9 + G13）/ 4
为方便起见，图1在此重复
红色/蓝色像素的插值：
红色/蓝色像素在绿色位置的插值：将对应颜色的两个相邻像素值的平均值分配给插值像素。 例如：B7 =（B6 + B8）/ 2; R7 =（R2 + R12）/ 2
红色/蓝色像素在蓝色/红色位置的插值：将四个相邻对角像素值的平均值分配给该插值像素。 例如：R8 =（R2 + R4 + R12 + R14）/ 4; B12 =（B6 + B8 + B16 + B18）/ 4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bf736094696208bd26cf9066e7cc836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f83b8fc0722491f6cd1234ee3f5e564/" rel="bookmark">
			重温 golang 的 ListenAndServe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang 启动 web 服务的方法 最原始的方法
ListenAndServe(addr string, handler Handler) error { server := &amp;Server{Addr:addr, Handler: handler} return server.ListenAndServe() } 上面的方法是最原始的方法，直接写一个地址，就可以启动web服务, 也可以写一个继承 Handler 接口的结构体
来实现自定义的路由处理逻辑
从上面的代码可以看出 底层是实例了一个 Server，然后调用 Server 的 ListenAndServe() 方法来启动服务
那让我们来看下 Server 结构体 都有哪些属性吧
// 只看我们可以修改的属性 type Server struct { Addr string // 监听的地址 Handler Handler // 处理路由的程序 不填默认调用 http.DefaultServeMux 来处理路由 // 看字面意思就知道是处理 https 的 // tls.Config 有个属性 Certificates []Certificate // Certificate 里有属性 Certificate PrivateKey 分别保存 certFile keyFile 证书的内容 TLSConfig *tls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f83b8fc0722491f6cd1234ee3f5e564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75dd0452aed71b10bbfa50cecaa520c9/" rel="bookmark">
			日均20亿流量：携程机票查询系统的架构升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 | 携程机票查询系统，日均20亿流量，且要求高吞吐，低延迟的架构设计。于是，提升缓存的效率以及实时计算模块长尾延迟，成为制约机票查询系统性能的关键。本文是携程集团机票业务技术总监宋涛在「云加社区沙龙online」的分享整理，着重介绍了携程机票查询系统在缓存和实时计算两个领域的架构提升。
携程是OTA行业内首屈一指的互联网企业，而在携程内部，机票搜索又是使用最频繁的服务（没有之一）。所以，我们所面对的一些技术问题，可能会对很多中型企业有一些借鉴作用，希望今天的分享能给大家带来一些收获。
点击视频，查看完整直播回放
一、 机票搜索服务概述
1. 携程机票搜索的业务特点 首先简单介绍一下机票的搜索业务：大家可能都用过携程，当你去输入目的地，然后点击搜索的时候，我们的后台就开始了紧张的工作。我们基本上会在一两秒的时间，将最优的结果反馈给用户。这个业务存在以下业务特点。
（1）高流量、低延时、高成功率
首先，我们不得不面对非常高的流量，同时，我们对搜索结果要求也很高——成功率要高，不能说查询失败，或者强说成功，我们希望能够反馈给用户最优质最新鲜的数据。
（2）多引擎聚合，SLA不一
携程机票搜索的数据来源于哪儿呢？有很大一部分结果来源于我们自己的机票运价引擎。除此之外，为了补充产品丰富性，我们还引入了国际上的一些GDS、SLA，比如我们说的联航。我们将外部的引擎，和我们自己的引擎结果聚合之后发送给大家。
（3）计算密集&amp;IO密集
大家可能会意识到，我说到我们自己的引擎就是基于一些运价的数据、仓位的数据，还有其他一些航班的信息，我们会计算、比对、聚合，这是一个非常技术密计算密集型的这么一个服务。同时呢，外部的GDS提供的查询接口或者查询引擎，对我们来说又是一个IO密集型的子系统。我们的搜索服务要将这两种不同的引擎结果很好地聚合起来。
（4）不同业务场景的搜索结果不同要求
携程作为一个非常大的OTA，还会支持不同的应用场景。例如，同样是北京飞往上海，由于设定的搜索条件或搜索渠道不一样，返回的结果会有一些不同。比如，有的客户是学生，可能就搜到学生的特价票，而其他的用户则看不到这个信息。
总体来说，每天的查询量是20亿次，这是一个平均的查询量。其中经过鉴定，9%的查询量来自于爬虫，这其中有一些恶意爬虫，也有一些是出于获取信息目的的爬虫，可能来自于其他的互联网厂商。对于不同的爬虫，我们会有不同的应对策略。
在有效查询当中，大概有28%是来自国际客户，然后有63%属于中文客户。携程的国际客户，特别是机票业务，所占有的比重越来越多。
2. 携程基础设施（Infrastructure）建设情况 好，接下来就简单介绍一下，就是为了应对这样的业务特点，我们有哪些武器呢？
（1）三个独立的数据中心
携程目前有三个独立的数据中心。他们是可以互相做灾备的，就在两天前，我们有一个比较盛大的庆祝会，经过差不多一年的系统提升和演练。我们实现了其中一个数据中心完全宕机的情况下，携程的业务不会受到影响。这个我们给他起了一个很fashion的名字叫流浪地球。我也代表我们机票业务领到了一个团体贡献奖。
（2）技术栈
讲一下我们的DataCenter大概的技术栈。可能跟很多的互联网厂商一样，我们是用了SpringCloud+K8s+云服务（海外），这里感谢Netflix无私的开源项目，其实支撑了很多互联网的基础设施部门，不然，大家可能还要摸索很长时间才能达到同样的效果。
（3）基于开源的DevOps
我们基于开源做了整套的DevOps工具和框架。
（4）多种存储方案
在携程内部有比较完善可用度比较高的存储方案，包括MySQL，Redis，MangoDB……
（5）网络可靠性
携程非常注重网络的可靠性，做了很多DR的开发，做了很多SRE实践，广泛推动了熔断，限流等等，以保证我们的用户得到最高质量的服务。
3. 携程搜索服务的架构 这里我简单画了一下携程机票搜索服务的架构，如下图所示。
我们的数据中心有三个，中间部分可以看到，我们首先引入了GateWay分流前端的服务，前端的服务通过服务治理，可以和后端聚合服务进行交互。聚合服务再调用很多的引擎服务，在这儿大家看出可以看到非常熟悉的Redis的图标，这就是我们广泛使用的分布式缓存。
缓存的具体细节下文会讲到。我们聚合服务的结果，可以通过Kafka推送到我们的AI数据平台，会做一些大数据的分析、流量回放，还有其他的一些数据相关的操作。在图中trip.com框的右边，我们还专门在云上部署了数据的过滤服务，使得传回的数据减少了90%，这是我们的data Center的介绍。
二、缓存架构的演进
1. 缓存的挑战和策略 （1）为什么大量使用缓存应对流量高峰？ 在流量高下为什么要使用缓存？其实有过实战经验的同学都知道，缓存是提高效率、提升速度，首先需要考虑的一种技术手段。
对于我们来说，为什么要大量使用缓存？
首先，我们虽然使用了很多比较流行的开源技术，但是我们还是有一些瓶颈的。比如，虽然我们的数据库是分片的、高可用的的MySQL，但是它跟一些比较流行的云存储、云数据库相比，它的带宽、存储量、可用性还是有一定差距，所以我们通常情况下需要使用缓存来保护我们的数据库，不然频繁的读取会使得数据库很快超载。
另外，我们有比较多的外部依赖，它们提供给我们的带宽，QPS也是很有限的。携程的整整业务量是快速增长的，而外部的业务伙伴给我们的带宽，要么已经达到了他们的技术瓶颈，要么开始收非常高的费用。在这种情况下，使用缓存就可以保护外部的一些合作伙伴，不至于把他们系统给击穿，另外也可以帮我们节省一些费用。
（2）本地缓存 VS 分布式缓存 在整个携程架构的演进的过程当中，一开始本地缓存比较多的，后来部分用到分布式缓存，然后占比越来越高。
本地缓存主要有两个问题：一个启动的时候，它会有一个冷启动的过程，这对快速部署是非常不利的。另外一个问题是，与分布式缓存相比，本地缓存的命中率实在是太低了。对于我们海量的数据而言，单机所能提供的命中率非常低，低到5%甚至更低。
在这种情况下，我们现在已经几乎全面切向了分布式缓存。现在我们的分布式缓存解决方案是Redis分布式缓存，总体而言，现在携程可用性和容错性都是比较高的。
我们在设计当中，本着对战failure的这么一个理念，我们也不得不考虑失败的场景。万一集群挂掉了，或者它的一部分分片挂掉了，这时候需要通过限流客户端、熔断等方式，防止它的雪崩效应，这是在我们设计当中需要注意到的。
（3）TTL设置 还有一点需要强调的，TTL生命周期设置的时候需要花一点心思，这也是跟业务密切相关的。
买机票经常有这种场景：刚刚看到一个低价机票，点进去就没有了。这种情况出现的原因可能是什么呢？大家知道，航空公司的低价舱位票，一次可能就只放出来几张，如果是热门航线，可能同时有几百人在查询。所以，几百人都可能会看到这几张票，它就会出现在缓存里边。如果已经有10个人去订了票，其他人看到缓存再点进去，运价就已经失效了。
这种情况就要求有一个权衡，不能片面追求高命中率，还要兼顾数据新鲜度。所以，为了保证新鲜度、数据准确性，我们还会有大量的定时工作去做更新和清理。
2. 缓存架构演进 接下来讲一下缓存架构的演进。
（1）多级缓存 这里我举了三处缓存：
子引擎级别的缓存。
L1分布式聚合缓存，L1聚合缓存基本上就是我们用户看到的最终查询结果。
L2二级缓存，二级缓存是分布式的子引擎的结果。
如果聚合服务需要多个返回结果的话，那么很大程度上都是先读一级缓存，一级缓存没有命中的话，再从二级缓存里面去读中间结果，这样可以快速聚合出一个大家所需要的结果返回。
（2）引擎缓存 我们使用了一个多级的缓存模式。如下右图所示，最顶部的是我们指引前的结果缓存，储存在Redis中，在引擎内部，往往根据产品、供应商，会有多个渠道的中间结果，所以对我们的子引擎来说会有一个中间缓存。这些中间结果的计算，需要数据，这个数据就来自上文提到的最基础的一级缓存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75dd0452aed71b10bbfa50cecaa520c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe50d272ac8414c58b865913b3a181a7/" rel="bookmark">
			C语言：输入10个数整数，输出最大（或最小）的数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
int main(void)
{
int a[10],i,max = 0;
printf(“请输入十个整数：”);
for(i = 0;i &lt; 10;i++)
scanf("%d",&amp;a[i]);
for(i = 0;i &lt; 10;i++)
if(a[i] &gt; a[max])
max = i;
printf(“最大的整数为：%d\n”,a[10]);
return 0;
}
include &lt;stdio.h&gt;
int main(void)
{
int a[10],i,min = 0;
printf(“请输入十个整数：”);
for(i = 0;i &lt; 10;i++)
scanf("%d",&amp;a[i]);
for(i = 0;i &lt; 10;i++)
if(a[i] &lt; a[min])min = i;
printf(“最小的整数为：%d\n”,a[10]);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1449cad9d1646fb3bec46ccd7568388/" rel="bookmark">
			服务端thrift 使用非阻塞式IO报异常Got an IOException in internalRead!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/z13192905903/article/details/103181204
参考：https://blog.csdn.net/xmtblog/article/details/79431748
报错
Got an IOException in internalRead! 全文
2020-04-26 11:54:31.934 WARN 21088 --- [ Thread-4] .s.AbstractNonblockingServer$FrameBuffer : Got an IOException in internalRead! java.io.IOException: Connection reset by peer at sun.nio.ch.FileDispatcherImpl.read0(Native Method) ~[na:1.8.0_181] at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39) ~[na:1.8.0_181] at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223) ~[na:1.8.0_181] at sun.nio.ch.IOUtil.read(IOUtil.java:197) ~[na:1.8.0_181] at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380) ~[na:1.8.0_181] at org.apache.thrift.transport.TNonblockingSocket.read(TNonblockingSocket.java:141) ~[libthrift-0.10.0.jar!/:0.10.0] at org.apache.thrift.server.AbstractNonblockingServer$FrameBuffer.internalRead(AbstractNonblockingServer.java:539) [libthrift-0.10.0.jar!/:0.10.0] at org.apache.thrift.server.AbstractNonblockingServer$FrameBuffer.read(AbstractNonblockingServer.java:338) [libthrift-0.10.0.jar!/:0.10.0] at org.apache.thrift.server.AbstractNonblockingServer$AbstractSelectThread.handleRead(AbstractNonblockingServer.java:203) [libthrift-0.10.0.jar!/:0.10.0] at org.apache.thrift.server.TNonblockingServer$SelectAcceptThread.select(TNonblockingServer.java:203) [libthrift-0.10.0.jar!/:0.10.0] at org.apache.thrift.server.TNonblockingServer$SelectAcceptThread.run(TNonblockingServer.java:154) [libthrift-0.10.0.jar!/:0.10.0] 1、服务端修改最大读取的缓存大小，默认值非常大，实际上并不需要那么大
# args为Args后的实例,以下表示10M args.maxReadBufferBytes = 10 * 1024 *1024L; 2、客户端的transport为null的时候调用也会出问题，如果通信还没结束不要关闭transport.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1449cad9d1646fb3bec46ccd7568388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/780a32789504ba783b7766a079b08799/" rel="bookmark">
			python pyplot 可视化之绘制柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可视化操作是工程师必备技能。在算法开发中，可视化能够辅助调试。本文对pyplot绘制柱形图做记录。
今天我欲对se_net中权重的学习情况进行可视化研究，从而判断出哪个通道/特征占据主导因素。其中使用pyplot进行可视化。jupyter notebook代码如下：
%matplotlib inline %config InlineBackend.figure_format = 'svg' #se权重 outputs = [0.9999635, 0.8995363, 0.13885525, 0.12847622, 0.11337245, 0.11435881, 0.11065625, 0.11901541, 0.11137064, 0.14423777, 0.99997544, 0.02447405, 0.03595051, 0.02142572, 0.02746158, 0.01961504, 0.03209742, 0.02768629, 0.0280421] #特征标签 tags = ["n_points","speed","north","northeast","east","sourtheast", "sourth","sourthwest","west","northwest","line_number","line_north", "line_northeast","line_east","line_sourtheast","line_sourth","line_sourthwest", "line_west","line_northwest"] fig,ax=plt.subplots() ax.bar([i+1 for i in range(19)],outputs, width=0.5) ax.set_xlabel("feature") #设置x轴标签 ax.set_ylabel("importance") #设置y轴标签 ax.set_title("feature importance") #设置标题 #添加x坐标对应的label plt.xticks([i+1 for i in range(19)],tags,rotation=90) plt.show() #显示图像 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc4b1e35931f97d1034e390915ed403/" rel="bookmark">
			vim将文本中的tab替换为4个空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、使用vim编辑器输入tab时，自动替换为4个空格 在.vimrc文件中加入如下语句：
"TAB "空格代替Tab" "注意: 插入模式下输入【ctrl+v+i】可以强制输入一个tab set tabstop=4 " tabstop 表示一个 tab 显示出来是多少个空格的长度，默认8 set softtabstop=4 " softtabstop 表示在编辑模式的时候按退格键的时候退回缩进的长度，当使用 expandtab 时特别有用 set expandtab " 当设置成 expandtab 时，缩进用空格来表示，noexpandtab 则是用制表符表示一个缩进 set autoindent " 自动缩进 set cindent " 自动缩进补充 set shiftwidth=4 " 自动缩进空白字符个数 2、替换文本中已存在的Tab为空格 注意：先在.vimrc中插入第一步骤中的语句
底行模式下输入如下命令：
:%retab 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7993a2b2b69dfe023e35f14be5dbb1d2/" rel="bookmark">
			视觉SLAM（一）——视觉SLAM框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介及说明 SLAM（Simultaneous Localization And Mapping）——同时定位与地图构建。因此SLAM是研究“定位”和“地图构建”问题的。
目前多用于机器人导航、无人车驾驶、跟踪建模。对于不同应用场景，精度要求、鲁棒性等有所差异，此时选择传感器、运算侧重环节也往往不同。但是基本框架几乎一致。
本系列主要研究以视觉为主的SLAM系统，主要是系统的学习基础的SLAM相关内容。本人从事三维机器视觉相关工作，主要在交通行业应用，由于项目侧重于跟踪建模，研究过ORB-SLAM（特征点匹配法）、DSO（光度恒定直接法）源代码，各有优缺点。主要工作内容是对高速场景下的多车道车辆实时跟踪三维建模，为了保证准确、实时、同时跟踪多目标并建模，所有运算环节均在Nvidia GPU中完成，产品已经满足设计要求，且工作稳定，下图为自主研发产品检测建模结果。现在作为回顾，系统学习SLAM的相关内容。
主要参考书目是高翔博士的《视觉SLAM十四讲》，中间会记录一些个人实践经验和思考。
2.SLAM基础框架 SLAM伴随着机器视觉发展和机器人导航已经相对成熟，形成了合理高效的基本框架。
主要包含：
传感器数据、前端视觉里程计、后端优化、回环检测、建图。
传感器数据 采集根据不同应用场景和需求进行选择，主要有如下几种传感器：
1.单目： 也就是单独一个摄像机，应用于手机AR场景。
单目第一个问题是没有像素点的深度信息，在DSO初始化环节中，通过小位移假设对有效的像素点进行试探扫描，进而对深度初始化。ORB-SLAM中初始化对特征点匹配进行，运Homography和Fundamental Matrix，选择较好的运算位姿，最后进行Full Bundle Adjustment。
单目第二个问题是尺度不确定，测试过单目DSO，建图会出现突然场景变大好多倍的现象。
2.双目： 双目的好处是受光线影响较小在户外场景可以使用，按照场景可以选择不同基线距离和分辨率的双目相机。分辨率高时，运算量会非常大，并且目前双目匹配优化比较消耗内存或显存；分辨率低时，远处准确度会变差；基线小时，远处准确率难以保证；基线大时，近处测量不到，增大视差扫描范围可部分解决，但性价比不高，64像素与128像素，可能只是增加近处0.5m的深度检测范围，但是视差运算时运算量会增加近一倍。
需要根据应用场景特点，在分辨率和基线参数上权衡。
市面上目前消费级双目相机有：
ZED（一代）：分辨率高，深度由SDK优化过，速度和精度均为顶尖水平，需要在带有GPU的主机上运算，深度范围：0.3-25m（实际10m处精度已经比较差了），视场角大：90x60，卷帘快门：对快速运动物体会有拖影，效果可能比较差。
RealSense（D435）：基线距离短，Intel的产品！所以片上运算出深度数据，不必消耗太多计算机资源，但是实际测试3m以外，测量误差几乎超过20cm了。
自主设计双目相机：
匹配算法主要有OpenCV——BM、SGBM，开源的有libSGM；opencv的BM有GPU实现，但是无亚像素级，远处深度直接分段，几乎可以认为GPU的BM算法不可用（截至目前）。SGBM运算效果很好，但是运算速度太慢，无GPU版本，github上有个国内的大佬实现了SGBM的GPU版本，只支持640*480分辨率，测试效果与CPU运算结果几乎一致！但是工程使用中，还是不太敢用，毕竟没有深入研究代码，怕有bug（逃。。。）。libSGM是日本的fixstar做的开源版本具有GPU版本的双目匹配算法，一直都有维护，youtube上看该团队做的项目很高大上，也研究并改动过源代码，效果虽然没有SGBM好，但是运算效率高且稳定，支持64\128像素视差，居家必备良心推荐。
3.RGB-D相机： KinectV1:结构光，年代太早，现在几乎已经找不到了。
KinectV2：Tof，效果很棒，在室内非常好用，精度高，数据稳定。官方SDK只支持一台相机连接到计算机，使用libfreenect开源库，可以同时连接多台，之前专门编写了多路libfreenect的采集同步，但由于KinectV2没有同步触发方式，多台相机会存在同步采集问题。目前已经停产有两年了，以后可能想用也用不上了。
Kinect Azure：第三代Kinect，也是Tof。与KinectV2对比测试过，KinectV2有三个激光发射模块（后边只装了两个，另一个空着没有焊接发射模块，可能是节约成本或者怕引起过曝），而Kinect Azure只有一个激光发射模块。由于激光模块功率变小，对于反射率低的空洞会变多。但是总体来说，Kinect Azure各方面性能都接近完美，可惜只适用于室内场景。
RealSense（L515）：MEMS，没有测评过，但是看youtube上的演示视频，只给出伪彩深度图的室内场景测试结果，目测精度没有Kinect Azure高，并且发现对于测试场景中有个人人腿处大面积空洞，应当对于反射率低或黑色的效果比较差，失去了测评的兴趣。
总体来说，RGB-D相机多数为室内场景设计，一般850nm左右的波长就是针对室内场景了，905nm或者940nm左右的应当是室外自然光条件下也可以使用的。（阳光中该波长的光含量少，对于传感器来讲噪音就少了很多）
4.激光雷达： 激光雷达目前多应用于无人车驾驶，价格昂贵，点云稀疏。但是好在测量结果稳定性好、测量深度范围大，对于低反射率或者室外阳光下环境效果也保持稳定、准确。仅测评过DJI的Livox Mid-100，室内外测量效果没得说，棒！价格也比较亲民，只要9999！但是，机械式单点扫描速度较慢，100ms的采样周期，相对比较稀疏，1s时很稠密，对于具体应用场景需要权衡。多线激光雷达采样周期短，但就是太贵，造价不降下来的话，产品难以大量推广应用，预研、demo都没问题，量产产品就很心疼了。
5.IMU（惯性测量单元）： 基于各种视觉导航的都会在特定场景下失效，比如少纹理时，所有基于视觉的都无法正常跟踪。惯性导航作为数据融合补充项，在视觉失效的场景下，能够提供粗略的位姿信息。
实际用于定位导航的产品，几乎都需要增加IMU作为补充，提高产品环境适应性。但是视觉SLAM中暂时没有研究这块内容，开源项目VINS很好的对视觉和IMU进行融合，大神做的工作很充分了，值得学习研究。
前端视觉里程计（VO-Visual Odometry） 根据视觉特征，对相邻帧间的位姿进行拟合运算。不同方式，最终结果都是完成相机平移、旋转的运算。
后端优化（Optimization） 通过大量观测点的拟合，最终针对平移、旋转6个参数进行寻优，往往得到结果准确度是比较高的。但准确度再高，也会有误差，小误差累计起来，会对建图准确性产生很大影响。为了得到准确的建图结果，VO环节得到的位姿都输入到优化器内，当优化器收到回环检测信息时，即可对所有中间输入位姿全局优化，减小累计误差对建图准确性的影响。
回环检测（Loop Closing） 通过关键帧的特征匹配，检测到相机回到之前走过的场景，此时就可以作为先验知识，使用优化器去将之前的位姿人为闭合。
这里没有专门研究过，想到了两个问题：
1.如果遇上相似场景，导致匹配误报，那场景岂不就大错特错了，是不是就得增加其他手段进行干预，比如GPS？对场景进行关联，限定当前帧匹配范围？
2.即使使用Bow，对特征匹配进行加速，当场景很大时，关键帧就会变得非常多，此时匹配的速度一定会变慢，并且误匹配的概率也会增加。应该也是需要分区域，限定匹配范围。
建图（Mapping） 根据需求，构建相应性质的地图。
侧重于定位时，多采用稀疏的路标地图。
侧重于路径规划自主导航时，则需要稠密的地图，二维Grid、三维Voxel。
侧重于实景建模时，需要对三维地图进一步网格化。
关于传感器数据就在本章完成讨论，对于视觉里程计、后端优化、回环检测、建图后续单独分章节记述。
The End.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a68bb3f3fb750ab4e138cef2d3a3239/" rel="bookmark">
			Win10默认输入法中英文标点切换：快捷键【Ctrl&#43;.】Ctrl&#43;句点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10使用——个人经验
Win10默认输入法中英文标点切换
快捷键【Ctrl+.】Ctrl+句点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ca54e584ff0b796acc0dd70d8afb75/" rel="bookmark">
			lotus version 0.3.0&#43;git1bfa2311 安装 interopnet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus version 0.3.0+git1bfa2311 安装 1，lotus interopnet 安装2，运行3，bench编译4，同步区块高度 1，lotus interopnet 安装 终端代理（使用木马） # export ALL_PROXY=socks5://127.0.0.1:1080 # git config --global http.proxy 'socks5://127.0.0.1:1080' # export GO111MODULE=on # export GOPROXY=https://goproxy.cn # mkdir interopnet # cd interopnet/ git clone --branch interopnet https://github.com/filecoin-project/lotus.git # git show commit 1bfa2311d6931dc0c961d42f561ba0268dbd21c3 (HEAD -&gt; interopnet, tag: interop.4.24, origin/interopnet) Author: Travis Person &lt;travisperson@users.noreply.github.com&gt; Date: Fri Apr 24 22:28:33 2020 +0000 New interopt network info make clean all &amp;&amp; make install # lotus --version lotus version 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83ca54e584ff0b796acc0dd70d8afb75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247dff13936d21dad12035345004ed61/" rel="bookmark">
			java.lang.ExceptionInInitializerError异常原因及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.lang.ExceptionInInitializerError at com.wangyin.aks.security.sign.SignEnvelopServiceImpl.getSignService(SignEnvelopServiceImpl.java:8) at com.wangyin.aks.security.sign.SignEnvelopServiceImpl.signEnvelop(SignEnvelopServiceImpl.java:13) at com.iruidou.bestpay.EncryptUtils.tradeRequestSSL(EncryptUtils.java:44) at com.iruidou.bestpay.AgreementPayServiceImpl.authTradeApply(AgreementPayServiceImpl.java:45) at com.iruidou.bestpay.bestTests.sumTest(bestTests.java:77) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:538) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/247dff13936d21dad12035345004ed61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd73e675e3f26780b730c00e9f110ad9/" rel="bookmark">
			PG进入单用户模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入单用户模式 停止PG服务器 如果不停PG，则无法通过单用户模式进入到PG
-bash-4.1$ /home/postgres/pgsql/bin/postgres --single -D /mnt/syncdata/pgsql/data/ postgres &lt;2020-04-26 19:06:40.446 CST 9177 &gt;FATAL: lock file "postmaster.pid" already exists &lt;2020-04-26 19:06:40.446 CST 9177 &gt;HINT: Is another postmaster (PID 9065) running in data directory "/mnt/syncdata/pgsql/data"? -bash-4.1$ -bash-4.1$ ps -ef |grep postm postgres 9065 1 0 19:06 ? 00:00:00 /home/postgres/pgsql/bin/postmaster -p 5432 -D /mnt/syncdata/pgsql/data postgres 9192 9086 0 19:06 pts/0 00:00:00 grep postm -bash-4.1$ -bash-4.1$ -bash-4.1$ /home/postgres/pgsql/bin/pg_ctl stop -D /mnt/syncdata/pgsql/data/ waiting for server to shut down.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd73e675e3f26780b730c00e9f110ad9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbff042c85b8fa2be3db5aa1df53f58/" rel="bookmark">
			prometheus relabel_config 详解加示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		relabel_config配置 Relabeling(重定义标签),是在拉取(scraping)阶段前,修改target和它的labels;
在每个scrape_configs可以定义多个重定义标签的步骤;
默认的, target的job标签设置为配置文件里的job_name的值;
__address__设置为配置里的targets的值;
而instance标签的值,是重定义标签操作之后__address__的值
__scheme__和__metrics_path__标签的值,也是从配置里取值的;
__param_&lt;name&gt;标签的值,是传给URL的查询参数&lt;name&gt;的值;
以__meta_开头的标签,也可以用于重定义标签;
重定义标签完成后,__开头的标签会被删除;
重定义标签阶段,如果要临时存储值用于下一阶段的处理,使用__tmp开头的标签名,这种标签不会被Prometheus使用;
# 从已有的标签选择值的源标签组;多个标签,使用separator分隔; # regex匹配源标签里的值 # 动作为replace, keep, 和 drop [ source_labels: '[' &lt;labelname&gt; [, ...] ']' ] # 多个源标签的分隔符; [ separator: &lt;string&gt; | default = ; ] # replace动作必需,regex匹配到的值,要替换的目标标签; [ target_label: &lt;labelname&gt; ] # 正则匹配源标签的值 [ regex: &lt;regex&gt; | default = (.*) ] # 源标签值取hash的模块; [ modulus: &lt;uint64&gt; ] # 要替换的匹配分组号 [ replacement: &lt;string&gt; | default = $1 ] # 基于正则匹配的动作 [ action: &lt;relabel_action&gt; | default = replace ] 正则匹配是到结尾的, 可以使用.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edbff042c85b8fa2be3db5aa1df53f58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8757d16cb37648b6367fa87d75e23993/" rel="bookmark">
			如何通过代码插桩的方式在任何apk添加自己的逻辑代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过安卓修改大师可以很轻松的在任何apk中添加新的代码逻辑，实现额外添加的功能，本次教程通过对一款名为“VMware Horizon”的软件进行反编译，实现在登录界面添加自动登录功能（该登录界面之前已经有自动登录功能，但是未实现相应的逻辑，且自动登录功能按钮在代码中自动隐藏掉了）。
为了方便大家学习，文中用到的apk和java代码请点击后面的连接下载：点击这里下载
1、 反编译安装包，将要反编译的安装包拖拽到安卓修改大师界面上，弹出的界面中选择反编译。系统将自动进行反编译打包。首次修改的时候，建议什么都不改，直接打包，看看有什么问题，并进行修复，确保可以打包运行才进行后续的操作。
2、 修复打包过程错误，在打包的过程中会遇到图示的错误，尝试按照提示的自动修复进行打包，发现并不能进行自动修复。然后看底部的日志，按照日志的要求，按照文件路径打开文件，删除提示的不存在的属性，然后重新编译。
3、 定位要修改的布局和Activity类。重新编译后，项目可以正常在手机上面运行，将手机浏览到登录界面，在安卓修改大师的左侧点击“代码/布局定位”，并点击打开界面的抓取界面布局按钮，就可以获得当前界面的Activity类名和布局文件。请记住上面的类名：
com.vmware.view.client.android.WindowsPasswordPrompt，后续修改都是在这个文件。
4、 点击上图右下角红框圈中的“定位布局和代码”按钮，将自动定位和搜索引用这个按钮的布局和代码文件，可以双击布局或者代码进入看布局逻辑或者代码的逻辑。
5、 找到界面元素对应的在类里面映射的变量的方法，以找到上述的“保存密码”复选框对应的变量为例，按照同样的方法，需要自行找到界面上面的用户名、密码和登录按钮对应的变量。按照上面的步骤抓取界面后，做抓取界面左侧的预览窗口点击相应的元素，然后右侧就会显示这个元素相应的一些属性，如果这个元素有id，就会在右下角的列表中显示“查看布局”的按钮，点击后就是上面步骤看到的搜索界面。然后点击smali结尾的文件（就是程序处理源代码文件），看到的代码如下：
最好把映射的变量记下来，同样找到用户名和密码的输入框，登录按钮对应的变量，记录下来。
6、 上面是准备工作，下面切入正题。本教程的主要工作是实现自动登录，按照这个逻辑，需要实现两个方法，一个是点击登录后的保存登录信息的功能（保存用户名，密码和保存密码选择框的状态），一个是页面加载的时候读取保存的用户名、密码和保存密码的状态，并自动点击登录按钮进行登录。
7、 要实现上述功能，需要额外添加代码来实现。一般的做法是先写好一个demo的Android studio项目，把要实现的功能写成一个类，然后确保实现功能并完成功能测试。下面就是实现该逻辑的代码，该代码也在附带的压缩包中。
package com.kongyu.project;
import android.app.Activity;
import android.content.SharedPreferences;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
public class AutoLogin {
//实现自动登录
public static void autoclick(final Activity context, CheckBox cbRemmber, EditText etUser, EditText etPwd, Button btnSave) {
SharedPreferences shareData = context.getSharedPreferences("Data", Activity.MODE_PRIVATE);//创建一个给全局使用
etUser.setText(shareData.getString("UserName", ""));
etPwd.setText(shareData.getString("Password", ""));
cbRemmber.setChecked(shareData.getString("CheckedUser", "").toLowerCase().equals("true"));
if(cbRemmber.isChecked())btnSave.performClick();
}
//保存登录信息
public static void saveinfo(final Activity context, CheckBox cbRemmber, EditText etUser, EditText etPwd) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8757d16cb37648b6367fa87d75e23993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b50ed91df6699748848cb1b7186e8f4/" rel="bookmark">
			在secureCRT软件上运行python脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		secureCRT支持运行.js和.vbs以及.py格式的脚本，无奈mac上识别前两个格式的脚本只能写一写python脚本，
举个简单的例子，利用脚本直接ssh连接一台机器，
在View菜单中勾选Button Bar让这个菜单在下方显示出来，
在下方的Default右方右键出现一个菜单点击New Button按钮，在显示框的Function一栏选择Run Script中间选择编写好的.py文件
.py文件的内容大致如下：
这里写两个小脚本
# $language = "python" # $interface = "1.0" #官方的实例可以在未连接任何服务器的情况下进行ssh连接 #你要连接的ssh服务器ip host = '139.196.53.1**' #ssh用户名 user = 'root' #ssh密码 passwd = 'Jinx0007' def main(): #进行cmd操作连接创建新的session连接 cmd = "/SSH2 /L %s /PASSWORD %s /C 3DES /M MD5 %s" % (user, passwd, host) crt.Session.Connect(cmd) #使用默认弹窗提示信息 crt.Dialog.MessageBox('登录成功!') main() 2.另外一个：
# $language = "python" # $interface = "1.0" #此方法表示你必须先登录一台ssh服务器然后再去ssh到另外一台服务器 #ssh主机的ip host = '192.168.0.111' #ssh主机的用户名 user = 'root' #ssh主机的密码 passwd = 'Jinx0007' def main(): #向屏幕光标后发送以下文字内容，\r表示回车执行 crt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b50ed91df6699748848cb1b7186e8f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25de03b935c293f5c478acd36148f8b1/" rel="bookmark">
			VSCode插件大全｜VSCode高级玩家之第二篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章《VSCode常用快捷键大全》，我们了解到了VSCode中的常用快捷键。学会了快捷键可以让我们更高效和迅速的编写代码。但是没有IDE中的一些辅助功能，还是美中不足。
VSCode没有安装插件，就等同于一把枪没有安装配件，打把的时候还是缺失精准度，开枪的时候也会有很重的后坐力。当然没有插件，也可以很好的编写代码，就是没有那么强而已。
所以这篇文章会给大家介绍VSCode中最常用的插件，让我们的编辑器加上一双翅膀，让我们在编写代码的过程中如虎添翼的感觉。
🌟所有插件，只要搜索插件名就能找到哦！
导航 「一」国人必备集合VSCode中文简体包代码翻译检测代码英文单词错误 「二」主题集合Dracula ThemeMaterial ThemeNebula ThemeAtom One Dark ThemeOne Monokai ThemeGitHub Plus Theme 「三」图标主题集合Material Icon ThemeVSCode Icons 「四」实用插件集合代码书签括号对彩色化增强Git功能Git历史记录实时协作编辑路径智能提示 「五」前端开发插件集合自动关闭标签自动同步标签名CSS颜色高亮高亮匹对标签HTML CSS 支持小程序支持Vue支持React支持NPM支持NPM智能提示强大的代码格式化编辑器中的实时预览实时预览浏览器打开 「六」PHP开发插件PHP强化插件PHP规范检测 「七」Java开发插件其他语言支持 「待续」总结好文推荐 「一」国人必备集合 这些插件都是我们作为中国人必备的，妈妈再也不怕我们看不懂英文了。
VSCode中文简体包 插件名：Chinese (Simplified) Language Pack for Visual Studio Code
这个插件一键把整个VSCode的文字转换成中文。一个全中文化的IDE是我们特别需要的。而且这个是官方汉化包，理解无障碍。
代码翻译 插件名：翻译(英汉词典)
英语不是很好的童鞋，在写代码的时候经常会使用“某道翻译”，但是其实对于代码来说，很多时候我们会用驼峰、小驼峰、下划线等等写法来写变量名、属性名、类名和方法名的。这种写法想使用“某道翻译”在编辑器中悬浮翻译就是不可能了。
找了很久我为大家找到一个非常好用的一个插件可以解决这个问题！
本地77万词条英汉词典，不依赖任何在线翻译API，无查询次数限制。可翻译驼峰和下划线命名，及对整个文件中的标识符批量翻译。
检测代码英文单词错误 插件名：Code Spell Checker
一个基本的拼写检查器，可以检测驼峰写法。这个拼写检查程序的目标是帮助捕获常见的拼写错误。在编写代码的时候，我们都是用英文单词，很多时候我们都会写错单词的可能性。用错了单词其实对于维护性是有一定的影响的。
使用有意义的单词做为方法名、类名和变量名会给自己代码更多的意义和含义。当自己或者别人去查看代码时更容易懂其中的用意。但是如果我们拼错了单词，有些时候就无法理解这个单词是什么意思了。
所以这个插件对我们来说非常实用，就算是老外都非常多人在使用它。（目前有100多万下载量）
「二」主题集合 一个程序员一天8-12个小时都是看着编辑器和代码。如果我们的编辑器不好看，没有一定的美观和吸引力，怎么可能耐看不厌呢？加上长期看代码，一个舒服的主题自然是必备之一。
这里介绍几款我最喜欢的主题给大家使用。有更多大家喜欢的主题欢迎在评论中提出，我会补充到这里哦！
Dracula Theme 主题名：Dracula Official
这款主题主调色是偏深紫色，我用了这个主题至少也有2-3年，一直都很喜欢。里面代码的高亮和颜色都很细致，很适合长期看。这个主题的颜色有根据不同的语言做了适配，无论我们是在开发什么语言都非常好看。
Material Theme 主题名：Material Theme
这款也是非常出名的主题，在非常多的IDE/编辑器都有。用习惯这个主题的可以在VSCode中安装使用。使用量也是有200多万+。这款主题在我使用SublimeText的时候非常热爱。（也用了好几年）
Nebula Theme 主题名：Nebula Theme
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25de03b935c293f5c478acd36148f8b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3874c61e3a058f341a4c09c313cca0a8/" rel="bookmark">
			MATLAB-Control System Toolbox™&amp;0.控制系统工具箱说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MATLAB-Control System Toolbox™ 0.控制系统工具箱产品说明 《控制系统工具箱》提供系统分析、设计和调整线性控制系统的算法和应用程序。 系统类型： 传递函数、状态空间、零极点增益或频率响应模型。 主要功能： 阶跃响应图和波德图，分析和可视化系统行为在时间和频率域；可以使用诸如Bode循环整形和根轨迹方法等交互技术来调整补偿器参数。 工具箱自动调优PID控制器； 可以对增益调度控制器进行调优，并指定多个调优目标，如参考跟踪、干扰抑制和稳定裕度； 可以通过验证上升时间、超调等时域、频域技术指标来验证您的设计。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a86c6f9f53c10a476f99650a02818e/" rel="bookmark">
			矩概念与图像矩详解及其hu矩的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、矩概念详解 矩这个东西，能组成的名词太多了，矩形，就是长方形，矩阵，就是m行n列的二维数组，所以想了解矩，就要从其具体的场景中去理解。
今天我们要讲的图像矩，就是一个新的概念，图像矩就是图像的矩，这个概念来源于数学中的矩，所以我们要先来理解一下，数学中的矩。首先我们先来看一下它的定义和相关概念：
在数学和统计学中，矩（moment）是对变量分布和形态特点的一组度量。当所有的变
量矩的定义是各点对某一固定点离差幂的平均值。n阶矩被定义为一变量的n次方与其概率密度函数（ProbabilityDensity Function, PDF）之积的积分。在文献中n阶矩通常用符号μn表示。
直接使用变量计算的矩被称为原始矩（raw moment），移除均值后计算的矩被称为中心矩（central moment）。
1、离散情况 我们从矩的概念出发，我们先考虑离散情况：
假设有一个离散的随机变量X，用A表示一个常数，用k来表示幂（阶数）。那么我们有下面这个公式：
这个称为X关于点A的k阶矩。
如果这个常数A为0，我们把这个k阶矩称之为k阶原点矩。
如果这个常数A为X的均值E(X)，我们把这个k阶矩称之为k阶中心矩。
变量的一阶矩是数学期望（expectation），表示分布重心；
变量的二阶矩是方差（variance），表示离散程度；
变量的三阶矩是偏度（skewness），表示分布偏离对称的程度；
变量的四阶矩是峰度（kurtosis），描述分布的尖峰程度，例如正态分布峰态系数=0。 如果我们有两个离散随机变量：X,Y。A1，A2分别代表对应于两个随机变量的常数，用p，q表示幂（阶数），那么我们有下面的公式：
这个称为X，Y关于点A1，A2的p+q阶矩。
如果两个常数都是0，那么我们称之为p+q阶混合原点矩。
如果两个常数都是对应的均值，即A1=E(X)，A2=E(Y)，那么我们称之为p+q阶混合中心矩。
2、连续情况 接下来我们考虑连续情况：
假设有一个连续的随机变量x，其单变量的概率密度函数为f(x)，用A表示一个常数，用k来表示幂（阶数）。那么我们有下面这个公式：
这个称为X关于点A的k阶矩。 如果我们有两个连续的随机变量：x,y，两个变量的联合概率密度为f(x,y)。A1，A2分别代表对应于两个随机变量的常数，用p，q表示幂（阶数），那么我们有下面的公式： 这个称为x，y关于点A1，A2的p+q阶矩。
一阶原点矩就是期望。二阶中心矩就是随机变量的的方差. 在统计学上，高于4阶的矩极少使用。三阶中心距可以去衡量分布是否有偏。四阶中心矩可以去衡量分布在均值附近的陡峭程度如何。
二、图像的几何矩 1、几何矩的概念 了解了矩的概念，我们接下来说一下图像的几何矩。在图像中，矩的概念如下：
矩是描述图像特征的算子。
这里的图像是单通道，也就是灰度图像，相当于一个矩阵，也就是上面提到的离散的情况。矩阵上每个位置的取值范围是0-255的整数。
2、图像的p+q阶矩 一阶原点矩就是期望。二阶中心矩就是随机变量的的方差. 在统计学上，高于4阶的矩极少使用。三阶中心距可以去衡量分布是否有偏。四阶中心矩可以去衡量分布在均值附近的陡峭程度如何。
那针对一幅图像，我们把像素的坐标看成是一个二维随机变量(X, Y)，那么一副灰度图可以用二维灰度图密度函数来表示，因此可以用矩来描述灰度图像的特征。 空间矩的实质为面积或者质量。可以通过一阶矩计算质心/重心。 图像的重心坐标 为：
物体形状方向 为：
3、HU矩 把图像的像素看做密度函数f(x,y)f(x,y)，对该像素点求期望，即是图像的矩（原点矩）
一般来说，一阶矩和零阶矩可以计算某个形状的重心，二阶矩可以计算形状的方向。
图像的矩主要表征了图像区域的几何特征，又称几何矩，由于具有旋转、平移、尺度等不变的特兴奋，所以又称为不变矩。
利用不变矩可以计算出物体的圆形度（物体形状和园的接近程度）、物体的矩形度（物体形状和矩形的接近程度）、物体的水平和垂直对称性、物体的主轴方向、扁度等。
几何矩： 中心距： 由几何矩可表示出中心距： 请注意，上述中心距是平移不变的。 换句话说，无论图像中的斑点在哪里，如果形状相同，则矩将是相同的。
如果我们还能让这个距具有尺度不变，那会不会很酷？ 那么，为此，我们需要标准化的中心矩，如下所示。
归一化中心距： 其中r=p+q+2, p+q=2,3,…r=p+q+22,p+q=2,3,…
中心距是平移不变的。 但这还不足以进行形状匹配。 我们想要计算对平移，缩放和旋转不变的矩，如下图所示。
幸运的是，我们实际上可以计算出这样的距，他们被称为Hu不变距。
7个Hu不变距计算如下：
感兴趣的可以尝试推导一下，这些都是关于图像的平移，缩放大小，旋转等参数不变性的推导式，
hu不变距的数学依据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60a86c6f9f53c10a476f99650a02818e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ffc39700c4d5e37178301da4eab485/" rel="bookmark">
			css遇到的坑：一行文字内容没有填满，就跑去下一行去了。看着很不舒服。怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题的问题 在我的外层div设置pading值，或是pading-right值后，内部的文字内容换行样式看起来很奇葩。
类似这样的，一行文字内容没有填满，就自动换行了。
解决办法1：padding-right的值捣鬼。 外壳的div属性，不要设置pading-right的值，或是设置为0就可以了。
这个办法不是很好，不推荐。不喜欢，不舒服，不爽啊。
解决办法2：word-break: break-all; 给壳div添加样式word-break: break-all;完美解决。666啊！
是不是很丸美？biu踢否不biu踢否？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867166d1a8829de9de6154d3b7378f12/" rel="bookmark">
			数据结构与算法Python版第十周OJ作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 二叉查找树填空（10分） 题目内容：
给定一个二叉树结构，与一个整数列表，请将整数填充至二叉树对应节点内，使其成为一个二叉查找树；请输出该二叉查找树的层次遍历。下图展示了给定样例对应的二叉树结构：
输入格式:
每个测试样例第一行包含一个整数，为二叉树的节点总数N。随后N行分别给定了编号由0至(N-1)的节点的左右子树编号，以空格分隔；若编号-1则代表对应子树为空。最后一行给出了以空格分隔的N个整数
输出格式：
对填空后的二叉查找树进行层次遍历，按顺序输出整数序列，即从第1层根结点开始，逐层向下，同一层从左到右，以空格分隔，行尾无多余空格
输入样例：
9
1 6
2 3
-1 -1
-1 4
5 -1
-1 -1
7 -1
-1 8
-1 -1
73 45 11 58 82 25 67 38 42
输出样例：
58 25 82 11 38 67 45 73 42
解题思路： 先按照题目要求构造二叉树：先创建N个树节点添加到列表里，然后根据每个节点的左右子树编号将各节点链接起来。接着中序遍历二叉树将整数序列按从小到大的顺序放入二叉树中，最后逐层输出
程序代码： class TreeNode: def __init__(self, key, left=None, right=None, parent=None): self.key = key self.val = None self.leftChild = left self.rightChild = right def generateTree(total): node_list = [TreeNode(i) for i in range(total)] for currentNode in node_list: seq = [int(j) for j in input().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/867166d1a8829de9de6154d3b7378f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df4d8cde329e6952f43213f24a688366/" rel="bookmark">
			Integral-human-pose-2D
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Integral-human-pose-2D Integral human pose estimation的2D pytorch实现 Integral human pose estimation的2D pytorch实现 原始链接：
https://github.com/JimmySuen/integral-human-pose/blob/master/pytorch_projects/common_pytorch/loss/integral.py
import torch.nn.functional as F import torch from torch.autograd import Variable import torch.nn as nn import numpy as np import os def makeGaussian(height, width, sigma = 3, center=None): """ Make a square gaussian kernel. size is the length of a side of the square sigma is full-width-half-maximum, which can be thought of as an effective radius. """ x = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df4d8cde329e6952f43213f24a688366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd83f7da5abd1a6c01c39273e4b624a6/" rel="bookmark">
			Tkinter 文件对话框filedialog模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在filedialog模块下提供了各种用于生成文件对话框的工具函数，如下所示： askopenfile():生成打开单个文件的对话框，返回所选文件的文件流，程序可通过该文件流读取文件内容 askopenfiles():生成打开多个文件的对话框，返回多个所选择文件的文件流组成的列表，程序可通过这些文件流读取文件内容 askopenfilename():生成打开单个文件的对话框，返回所选择文件的文件路径 askopenfilenames():生成打开多个文件的对话框，返回多个所选择文件的文件路径组成的元组 asksaveasfile():生成保存文件的对话框，返回所选文件的文件输出流，程序可通过该文件输出流向文件写入数据 asksaveasfilename():生成保存文件的对话框，返回所选择文件的文件路径 askdirectory():生成打开目录的对话框 上面用于生成打开文件的对话框的工具函数有如下选项 defaultextension：指定默认拓展名，当用户没有输入拓展名时，系统会默认添加该选项指定的拓展名 filetypes：指定该文件对话框中能查看的文件类型。该选项是一个序列，可能指定多个文件类型，可通过“*”只当浏览所有文件 initialdir：指定初始打开的目录 initialfile：指定所选择的文件 parent：指定该对话框的属主窗口 title：指定该对话框的标题 multiple：只当是否允许多选 下面代码演示了文件对话框的各个工具函数的用法：
from tkinter import * # 导入ttk from tkinter import ttk # 导入filedialog from tkinter import filedialog class App: def __init__(self, master): self.master = master self.initWidgets() def initWidgets(self): # 创建7个按钮，并为之绑定事件处理方法 ttk.Button(self.master, text='打开单个文件', command=self.open_file).pack(side=LEFT, ipadx=5, ipady=5, padx=10) ttk.Button(self.master, text='打开多个文件', command=self.open_files).pack(side=LEFT, ipadx=5, ipady=5, padx=10) ttk.Button(self.master, text='获取单个打开文件的文件名', command=self.open_filename).pack(side=LEFT, ipadx=5, ipady=5, padx=10) ttk.Button(self.master, text='获取多个打开文件的文件名', command=self.open_filenames).pack(side=LEFT, ipadx=5, ipady=5, padx=10) ttk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd83f7da5abd1a6c01c39273e4b624a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6282b82d220a6b09dae364a3cbf01b9/" rel="bookmark">
			win10家庭版升级为专业版详解 --- 0xC004C003问题详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 叙：本人电脑原装是win10家庭版的，但是由于远程等功能的需要，自己或者工作上不允许用远程软件，只能用自带的远程功能，因此只能升级为专业版的，但是在升级为专业版的时候总是会遇到这样或那样的问题，就比如说这个0xC004C003问题，下面就此问题下的系统从家庭版升级至专业版进行讲解~
升级操作 第一步：打开cmd命令（管理员模式下的）
最好是使用Windows+X的组合键，会在左下角出现一列选项，选择如下图：
选择管理员的shell模式（一般的shell模式也可以，不过用管理员的不宜出问题）打开后如下图所示：
第二步：输入命令
总共需要输入四次不同的命令，每个命令都是承接着上一个命令的，由于我的系统已经使用此方法jihuo过了，所以就不再再次真正的运行此命令，截图中只有一行代码用于演示，真正操作时在一个shell命令框内按顺序输入这四个命令即可；
1）输入slmgr.vbs /upk命令；
这一步的目的是为了卸载原有的密钥，只有先卸载掉原有的才能进行更新，输入后会弹出个卸载（/移除）密钥成功！的提示；
2）输入slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX命令
上一步移除了原有的密钥后在将我们的密钥添加进去，这一步就是添加密钥（或者替换已有的密钥）；
3）输入slmgr /skms zh.us.to命令
此步是密钥管理服务计算机名设置为****的；
4）输入slmgr /ato命令
jihuo Windows操作，会出现jihuo成功或者正在jihuo的提示框；
完事后点击电脑属性查看会发现如下图所示：
jihuo后的样子；
pass：希望对你们有所帮助！
上面的信息太过陈旧，对于系统的JiHuo可能灵也可能已经失效了，下面给大家个JIHUO器，这个可以直接JiHuo Windows系统，这个里面可以自动生成Windows XuLie号以及JiHuoMa，一套下来的，而且还可以JiHuo office以及生成安装office JiHuoMa的，需要的请进入： 链接：https://pan.baidu.com/s/1rF8GZYZxkcxlilvPGCc_Tw 提取码：4zdq 这是一个傻瓜式的jihuoqi，很方便使用，但也存在一些问题，需要注意的是：
1、已经jihuo但快要过期的系统使用此jihuoqi无效，只有等待系统完全过期后才能jihuo；
2、对于一些系统jihuo可能不成功，需要重启电脑后再次使用此jihuoqi才能jihuo成功；
pass:此软件仅用于解决私人问题，仅用于交流使用，出现任何商业行为或会造成侵权且与本人无关!
《完》 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/370/">«</a>
	<span class="pagination__item pagination__item--current">371/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/372/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>