<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5883553de7bba00701f65c8d4b3cda6a/" rel="bookmark">
			unity图像处理简单流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在渲染管线中，后处理通常位于渲染过程的末尾，即在所有的渲染通道（例如顶点着色器、片段着色器等）完成之后执行后处理操作。后处理操作是在已经渲染的图像上进行的，它不会影响到场景的几何形状或光照等因素。一般来说，后处理操作会在渲染目标纹理（例如帧缓存或渲染纹理）上进行。在每一帧的渲染完成后，后处理操作会将渲染目标纹理作为输入，并应用各种效果和滤镜来修改图像的外观。包括亮度处理、色相调整、饱和度与对比度调整和晕影效果的实现。由着色器控制像素颜色，并使用脚本控制着色器。
shader着色器
以控制亮度来举例：
首先定义_Brightness变量控制亮度数值，在fragment shader中进行计算：
//获取图像颜色值 //half4 col = tex2D(_MainTex, i.uv);//CG方法 half4 col = SAMPLE_TEXTURE2D(_MainTex,sampler_MainTex, i.uv);//HLSL方法 //亮度处理 half3 final_color = col.rgb * _Brightness; C#脚本控制Shader
OnRenderImage() 是Unity 中用于在渲染每一帧图像之前或之后执行自定义后处理操作的函数，只能搭载在Main Camera上才能正确执行。通过OnRenderImage()，控制每一帧渲染图像之后需要执行的执行自定义的后处理效果。创建C#脚本ImageEffect.cs，传入对应的Material材质用于控制各种后处理的效果。编写OnRenderImage()函数。
public class ImageEffect : MonoBehaviour { public Material material; public float Brightness = 1; private void OnRenderImage(RenderTexture source, RenderTexture destination) { material.SetFloat("_Brightness", Brightness); Graphics.Blit(source, destination, material); } } 变量 material用于指定要应用效果的材质。变量 Brightness，用于控制图像的亮度。
在OnRenderImage()中设置材质的 _Brightness 属性,然后，使用 Graphics.Blit 函数将源纹理 source 绘制到目标纹理 destination 上，并应用材质。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8448cb0168e28795e51987accffa3f9c/" rel="bookmark">
			使用原生JavaScript代码将HTML保存为图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 有朋友了解了我上篇svg绘制中国象棋棋盘后，想要将其使用代码保存下来，正好今天有时间，顺便给大家介绍一下我的解决方案。
代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;My first SVG&lt;/h1&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"&gt; &lt;circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="red" /&gt; &lt;/svg&gt; &lt;br /&gt; &lt;button onclick="svgSave()"&gt;Svg保存&lt;/button&gt; &lt;button onclick="notSvgSave('jpeg')"&gt;Jpeg保存&lt;/button&gt; &lt;button onclick="notSvgSave('png')"&gt;Png保存&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type="text/javascript"&gt; function svgSave() { let svg = document.querySelector("svg").outerHTML; let src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg))); let a = document.createElement("a"); a.href = src; a.download = "result.svg"; a.click(); } function notSvgSave(type) { let svg = document.querySelector("svg").outerHTML; let src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg))); let img = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8448cb0168e28795e51987accffa3f9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd71f6112579330279092d186680449/" rel="bookmark">
			html益智游戏拼图游戏源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一个简单的益智游戏的HTML代码示例，这个游戏名为“拼图游戏”。游戏的目标是将打乱的图片拼回原状。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;拼图游戏&lt;/title&gt; &lt;style&gt; #puzzle { width: 300px; height: 300px; border: 1px solid black; position: relative; } .piece { width: 150px; height: 150px; position: absolute; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="puzzle"&gt; &lt;!-- 拼图块会被动态地添加到这里 --&gt; &lt;/div&gt; &lt;script&gt; var puzzle = document.getElementById('puzzle'); var pieces = [ 'img1.png', // 这里应该是你的图片文件路径 'img2.png', 'img3.png', 'img4.png', 'img5.png', 'img6.png', 'img7.png', 'img8.png' ]; var puzzlePieces = []; for (var i = 0; i &lt; pieces.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cd71f6112579330279092d186680449/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0be8b1ac3acc8cdea2b8e55fe2aabdd/" rel="bookmark">
			【话题】ChatGPT等大语言模型为什么没有智能2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们接着上一次的讨论，继续探索大模型的存在的问题。正巧CSDN最近在搞文章活动，我们来看看大模型“幻觉”。当然，本文可能有很多我自己的“幻觉”，欢迎批评指正。如果这么说的话，其实很容易得出一个小结论——大模型如果想朝着真的智能发展，“幻觉”问题不可能被完全解决，只可能缓解。
向量碎片化：大模型也会连接错误 大模型“幻觉”的问题其实就是if-clauses走入了一个死胡同，概率连接到错误地方或者说预测下一个token进入了一个奇怪的局部最优，并且很难走出来。
最简单的一个例子就是 1+1 = 2这个公式，如果在训练中，一直喂 1+1 = 3，你觉得当回答1+1 = ？这个问题的时候，神经网络会回答几？
这里我们看人类如何处理。在回答 1+1 = ？的时候，2 作为最快cache会最先被获取到；但是，如果在特殊context下，它的答案多种多样。比如算式里的1是二进制，那么1+1 = 10；比如遇到社会学科的时候，1+1 = 3 可以给生一个娃的家庭建模，人为定义=3；比如高中或者初中化学老师经常用一些公式进行比喻1个化学物质和另1个化学物质进行反应，结果多种多样。
所以这也是我们在上一话提过词向量碎片化的问题。当训练数据开始因为context产生歧义的时候，词向量开始碎片化，向量长度的固定意味着原本我可以用更多维度表示一种概念，之后会不停压缩，让这些维度分别去对应不同context下不同的意义，于是诸如transformer里feedforward层那2个线性矩阵真的能模拟诸多离散的情况么？当然是可能的，就是你参数的规模不停变大，而且随着context增多，这个规模是爆炸的；即使不管这个爆炸，碎片化越严重，超过了向量维度承载能力，整个模型也会崩塌。
宕开一笔，现在deep learning铺天盖地，把以前很多其他学派的文献冲淡的一塌糊涂（如果大家感兴趣，可以参考《终极算法》一书，bayes，logic，nn，svm/knn，ea五大学派）；真的得抱怨下，钱途无限的世界很现实也很残酷，哪里钱多点哪里so easy。
个人感觉上，在embedding层上需要作一些调整，一个词向量可能可以是多个，然后引入evolutionary algorithm，在诸如用蒙特卡洛法选择一个向量的时候，最常用概念的向量大概率被最先取到，我们用个top k就能应付一些其他context了。当然，这个和MoE有那么一点类似，但是最终架构应该是往另一个方向了，因为MoE用到最后你会发现我要处理gating的时候需要recursive，就是gating的gating然后堆上去。
说着说着，我们就又得聊到目前整个神经网络的问题，它是一个外轮廓模型，就相当于你有一个吹得很大的气球，你要训练这个模型就是你把一个事物装进这个气球，然后气球开始放气，最后气球完全贴合了整个事物得外轮廓，loss就是0了；如果这个气球太小，你没有办法把一个事物装进去，就是你的参数太少。现在deep learning基本已经探索出了人类视觉和文字的外轮廓，视觉嘛大概19层cnn+poolmax+residual基本“击穿”了；文字上transformer在当前的规模也基本“击穿”了；这里的“击穿”指的是气球够大了，效果出来了。其实还有一个内轮廓模型，这个太难了，目前RL、EA这些都是在探索这个模型，我最喜欢的例子就是code parser；你看本来一个模型只能把整篇code所有字符标记成unknown，当你告诉它 " 可以作为字符串的开始和结束，它开始能把code中的字符串标记出来，再接着你告诉它 " 表示转义，你能得到更复杂的状态机，它需要逐步学习，慢慢补全事物的内轮廓。相当于你把事物挖空，把瘪的气球放进去充气，最后得到事物的内轮廓。人类的学习感觉上是走在外轮廓和内轮廓的交界处的，这个是真正的智能学习，当然，这个可能只是我个人的“幻觉”。所以如果神经网络只知道外轮廓，在它推理的边界，很容易产生“幻觉”；如果神经网络太小，模型看不清外轮廓，也会有“幻觉”。
另一方面，如果我们人为定义“幻觉”，其实大模型也不能很好去处理。比如改变数学规则定义新“幻觉”，神经网络只能根据之前的学习作概率预测，很难处理其中逻辑。曾经作过一个试验，定义0+1=1+0=1, 1+1=3, 1+3=3+1=2, 1+2=2+1=5, 1+5=5+1=4, 1+4=4+1=6, 1+6=6+1=8, 1+8=8+1=7, 1+7=7+1=9, 1+9=9+1=10，问5367+3456=?：目前还没有一个大模型能给出正确答案。
这个问题应该还是出在词向量上。妄图用global的一个向量表示所有local概念，很傻。我们刚才讨论过用EA作多向量，其实embedding这里应该就是少了一个组件，这个组件需要将global vector transform成local vector，貌似transformer里K Q V有这样模糊的操作，但是linear去猜测离散，效率可想而知。关于这个话题，我想等到我思索得更清楚点的时候再展开，现在就简单提两句，作抛砖引玉。
“争议”是另一种“幻觉” 想想，如果你是1+1=2的信徒，你进入的世界人家定义就是1+1=3，那么你所相信的1+1=2算是“幻觉”么？“幻觉”的另一个问题是“争议”。比如“中医”，各大论坛上吵得不可开交，到底它有没有用？像这样的话题，如果给到训练数据，大部分都是有偏见的；即使我们均衡了训练数据，50%的人说有用，50%的人说无用，那这个概率不偏不倚，机器只能因为误差偏向了另一个，对，就是那个50.0000000002%和49.9999999998%。这个问题其实是我们还没有系统去处理，我们需要有一个数据库去构建，赞成和反对的声音有多少，如果存在争议，我们最好的办法是给出reference让读者自己判断，而不是硬下结论。
最近stackoverflow的流量下降的厉害，因为ChatGPT确实解决了太多问题；与其我等别人回复，不如ChatGPT直接给出解；当然，这个是恶性的；当GPT扼杀community的时候，好的训练数据会越来越少。但是我们从“幻觉”来看，感觉社区的另一个方向就是有争议的问题列出来投票，盖棺定论的都放在wiki上就好了搜索引擎会解决一切。
我们从“争议”看到了另一种“幻觉”，也从“争议”聊到了那个什么50.0000000002%。不要忘记神经网络参数更新的原理 W = W + a.dW；这个是一个迭代过程，迭代会积累误差，所以如果我们遇上了混沌(Chaos)，那么你可能会发现新大陆——一只蝴蝶引发了飓风。混沌会导致训练的时候就是不收敛，所以学习到的“幻觉”一直消除不了。
所以这里再放送一个可以免费体验各种大模型（gpt4, gpt3.5, gemini-pro, yi-34b, mistral 8x7b, qwen, …）的学术机构网址，可能需要科学上网：https://chat.lmsys.org。从我个人体验来说，目前GPT领先的不仅仅是在模型上，而是在训练数据上。这也是为什么GPT能缓解一定的“幻觉”，在解答一些问题上比其他模型准确。从这方面来说，也看出现在的大预言模型“没有智能”，当然这个有点“幻觉”硬下结论了，至少在我看来，有智能意味着它可以生成代码，按照代码的形式执行各种复杂分析，更偏向于内轮廓模型；不过欣喜的是，GPT已经有一些雏形了。所以我后面的兴趣就是研究内轮廓模型，干掉GPU，一台CPU机器作为一个智能agent，白日梦中……
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0be8b1ac3acc8cdea2b8e55fe2aabdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f8f38839ca36bf2df20f5e9e05a874/" rel="bookmark">
			架构设计模式详解：夯实架构设计的基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、分层架构设计1、层的定义2、什么是分层3、经典分层架构（1）OSI 网络7层架构（2）CS架构（3）BS架构（4）企业应用三层架构 4、为什么需要分层架构（1）复杂度隔离（2）防止错误传播（3）层自治 5、分层架构的优缺点（1）优点：高内聚（2）优点：低耦合（3）优点：易扩展（4）优点：可维护性好（5）优点：可测试性高（6）缺点：性能下降（7）缺点：开发成本上升 6、如何设计分层架构（1）依赖规则（2）定义职责（3）定义技术栈（4）代码抽象与分层（5）集成 7、分层架构模型（1）MVC模型（2）MVP模型（3）MVVM模型（4）BFF模型 二、EDA事件驱动架构设计1、EDA：Notification（通知）2、EDA：Carried State Transfer（事件携带的状态转移）3、总结：什么是EDA4、EDA：经典应用NIO5、EDA：经典应用nginx6、EDA：两种Topology（拓扑结构）（1）Mediactor（中介模式）（2）Broker（代理模式） 7、EDA架构的优点（1）整体灵活性（2）可扩展性（3）整体性能较高（4）易于部署 8、EDA架构的缺点（1）可测试性（2）可维护性（3）性能问题 9、案例 三、Microkernel微内核架构设计1、什么是微内核2、微内核系统的核心3、插件模块4、优点（1）符合开闭原则（2）良好的隔离性（3）灵活性高（4）可测试性好（5）性能较好（6）易于部署 5、缺点（1）开发难度高（2）可扩展性不高 6、设计微内核架构（1）核心（2）定义开放规范（3）注册规范（4）定义通信机制（5）实现插件（6）装载插件 7、微内核架构经典应用（1）操作系统（2）Eclipse（3）Rule Engine 规则引擎（4）ESB（5）BPM 工作流（6）Nginx Plus（7）Servlet 四、生产者消费者架构设计1、什么是生产者消费者模式2、生产者3、消费者4、容器5、核心问题：平衡6、与EDA的异同7、消费者的消费策略8、优点（1）低耦合（2）分布式部署（可选）（3）平衡系统差速（4）削峰填谷 9、设计数据单元10、设计生产者（1）生产者成功确认（2）序列化（3）数据单元独立性（4）异常处理 11、设计消费者（1）消费者的消费方式（2）消费者的分发模式（3）反序列化（4）消费确认（5）消费策略 12、设计Container（1）集群（2）消息/数据存储（3）调度算法 13、消费保证（QOS）（1）At least onse 至少一次（2）At most once 至多一次（3）Exactly once 有且仅有一次 14、经典案例（1）BlockingQueue（2）Kafka（3）ERP审批流程（4）消息广播：Spring events 一、分层架构设计 1、层的定义 层：软件的逻辑单元。
每一层都有特定的功能。
组件被分配到不同层。
2、什么是分层 将系统按照之策拆分和组织。
上层依赖于直接下层。（下层不可以依赖于上层，不可以跨层访问）
3、经典分层架构 （1）OSI 网络7层架构 （2）CS架构 CS架构是典型的两层架构，分为Client客户端和Server服务端。
客户端运行于客户的终端，服务端处理应用服务、业务逻辑和数据存储。
客户端和服务端通过网络交换信息。
（3）BS架构 BS架构同样是典型的两层架构，分为Browser浏览器和Server服务端。
Browser运行于各种浏览器的瘦客户端。
客户端和服务端通过网络交换信息。
（4）企业应用三层架构 Presentation：与用户交互和呈现信息（UI）。
Domain：业务逻辑。
Data：数据存储。
4、为什么需要分层架构 （1）复杂度隔离 隔离业务复杂度和技术复杂度。
解决不同层的问题，可以采用不同的技术栈。
每层变化速度不一致。
（2）防止错误传播 防止错误传播。
降低错误影响。
防水仓设计。（熔断）
（3）层自治 本层功能内聚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88f8f38839ca36bf2df20f5e9e05a874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61ba62a80aa76410eccecab30de86c2/" rel="bookmark">
			华为HCIA课堂笔记第七章 以太网交换基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第七章 以太网交换基础 7.1 ARP的种类 普通ARP：通过已知的IP地址获取未知的MAC地址。免费ARP（无辜ARP）：用于重复IP地址检测（ARP报文中携带的目的IP地址是自己的），如果有收到回复，则认为自己的地址和对端的地址出现了重复。设备接口手动配置了IP地址或者自动学习到IP地址的时候。反向ARP：通过已知的MAC地址获取未知的IP地址（ipconfig）ARP代理：本地设备收到ARP请求之后，代理目标地址回复本地MAC地址。 冲突域和广播域 7.2.1冲突域： 早期以太网中，通过Hub集线器连接所有的设备，设备节点发出去的数据将通过Hub复制到所有的出口，交给所有其他设备。即单个节点发送的数据，所有的其他节点都能收到，形成冲突。冲突域是指：在共享网络中，出现通信冲突的所有节点的组合。解决方法： 通过CSMA/CD机制（载波监听多路访问/冲突检测机制） 先听后发边发边听冲突后停发随机时间重发通过部署交换机隔离冲突域，交换机的每一个接口是一个冲突域。 7.2.2 广播域 每一个交换机就是一个广播域，即交换机所有接口默认属于一个广播域。
交换机收到一个广播B、组播M、未知单播帧U（BUM帧），默认向所有接口转发，其他所有与交换机相连的设备能收到BUM帧，组成一个广播域。
路由器可以隔离广播域（路由器不转发广播报文）、VLAN技术可以隔离广播域
7.3 数据帧格式： 以太网数据帧存在两种格式：Ethernet II，802.3帧，包含数据的总长度不超过1518B
Ethernet II格式字段：数据部分长度46-1500B D.MAC：目的MAC地址，6BS.MAC：数据帧的源MAC，6BType字段：用于标识上层协议（网络层）种类： Type字段取值为0x0800表示上层协议为IP协议Type字段取值为0x0806表示上层协议是ARP协议，2BData字段（包含了上层协议+传输层协议+Data）FCS：帧尾校验，对数据包整个进行校验，校验成功后才能接受，否则丢弃。802.3帧：数据部分长度38-1492B D.MAC：数据帧的目的MAC地址S.MAC：数据帧的源MAC地址Length：后续携带的数据的字节长度，不包含FCS帧尾LLC：略（DSAP目的服务访问点、SSAP源服务访问点，取固定值）SNAP：略（Ctrl取固定值，OUI取值厂商代码，Type字段） Type字段：2B，标识上层协议，与Ethernet II相同 Data字段（包含了上层协议+传输层协议+Data）FCS：帧尾校验，对数据包整个进行校验，校验成功后才能接受，否则丢弃。如何区分两个帧 S.MAC地址后的2B字段判断（Type/Length）
值&gt;1536，则该字段名称为Type字段，表明该数据帧是一个Ethernet II帧值&lt;1500，则该字段名称为Length字段，表明该数据帧是一个802.3帧 7.4 园区网部署架构 接入层：负责终端设备的接入。汇聚层：汇聚接入层的流量。核心层：汇总汇聚层的流量。出口层：出口设备负责连接互联网。 7.5 以太网交换 7.5.1 交换机转发数据（转发数据） 交换机依据MAC地址表项单播转发数据：查看数据帧头部中的目的MAC地址，是否在本地的MAC地址表中存在映射关系，如果存在，则向对应的表项中的端口外转发数据。
7.5.2 MAC表的形成（学习） 当交换机收到一个数据帧，查看数据帧的源MAC地址，以及收包接口，形成MAC地址与收包接口的映射关系（MAC地址表项）。
交换机三种处理报文的动作：泛洪、转发、丢弃
丢弃：交换机收到报文后查找目的MAC地址对应的MAC地址表项，发现要从收包接口再次发出，则丢弃。 MAC地址表的特点：
一个接口可以学习多个不同的MAC地址一个MAC地址只能在一个接口被学习，后学习该MAC地址的接口记录覆盖前学习的记录。MAC地址表的老化时间 默认300s，表项在没有通信报文的情况下，超时就会删除，如果在老化时间内，存在报文通信，则学习MAC地址，刷新表项老化时间为300s。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f21b133f3baa8d7666982caebe2388/" rel="bookmark">
			华为HCIE课堂笔记第十一章 IPv6概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十一章 IPv6概述 11.1 背景 根本原因是：IPv4地址枯竭，IPv6是IPV4的升级版本
11.1.1 IPv6地址的优势： 地址空间足够大 128bit支持即插即用底层化地址结构：地址分配有一定的标准相比于IPv4简化了报文的头部，提高了转发效率安全特性：IPv6支持对IPv6报文进行认证（AH）和加密（ESP）移动性：对于移动网络实时通信有较大改进，整个移动网络性能有比较大的提升。增强Qos功能（Flow Label字段）。 11.1.2 IPv6的过渡技术 IPv4地址枯竭，由于IPv6地址设计之初不兼容IPv4地址，因此出现了一些共存技术，通过共存技术，使得网络在IPv4向IPv6过渡的过渡过程中平缓演进。
隧道技术：通过隧道技术，使得IPv4孤岛在IPv6的网络中可以通信；或者IPv6孤岛可以在IPv4的网络中进行通信。双栈技术：设备同时支持IPv4和IPv6技术地址转换技术：将IPV4地址与IPV6地址之间进行互换（对报文头部进行整个更换），满足通信需求。NAT64 11.1.3 IPv6路由协议 OSPFv3 新的协议，与OSPFV2不兼容，用于支持IPv6 基于链路（层）运行取消了LSA头部中的IP地址，与网络层解耦，实现拓扑与路由计算分离新增LSA支持路由的传递ISIS协议（协议版本未变） 通过新增一个网络层标识符和多个（2个）TLV用于传递路由BGP协议（多协议BGP，协议本身版本未变） 通过增加支持支持IPv6地址簇通过增加两个NLRI支持IPV6的路由发布和撤销。PIM协议（协议版本未变） 协议本来就是协议无关组播协议，仅源目IP地址为IPv6地址 11.2 IPv6地址 11.2.1 IPV6地址格式 128bit组成，分为网络前缀（IPv4的网络前缀）和接口标识（IPv4的主机位），通过冒分16进制表示，每16bit位一个小组，总共8小组。掩码表示网络前缀的长度，掩码仅能通过数值表示。
例如：2001:0DB8:2345:CD30:1230:4567:89AB:CDEF/64
IPV6地址的三种格式：
首选格式：没有经过压缩的格式，每16bit以小组，共8组，没有简写 例如：2001:0DB0:0000:0001:0000:0000:0000:45ff/64压缩格式： 每段前导0可以省略，但是如果该段为全0，则至少保留一个“0”字符；拖尾的0不能被省略。一个或多个连续的段为全0时，可用“::”表示，整个IPv6地址缩写中只允许有一个“::”。结果例如：2001:DB0:0: 1::45ff/64、或者2001:DB0:: 1:0:0:0:45ff/64内嵌IPv4地址的格式,用于IPv4、IPv6相互兼容 地址的前96bit为IPv6地址格式，后32bit为IPv4地址格式。IPv6部分可采用首选或压缩格式，IPv4部分采用点分十进制格式。例如：0:0:0:0:0:0:166.168.1.2/64。或者是::166.168.1.2/64 11.2.2 IPV6组成 前缀部分：注意前缀的长度（掩码） 2001::/16 //用于IPV6网络的公网地址（已分配的IPV6地址的前三bit固定为001）2002::/16 //用于ipv6 6to4隧道专用地址FE80::/10 //链路本地地址，用于链路本地通信使用，仅链路有效。多种协议使用该地址进行通信。FF00::/8 //IPV6的组播地址::/128 //未指定地址，与IPV4的0.0.0.0相似::1/128 //环回口地址。接口ID部分：手工、动态获取（DHCPv6、无状态自动配置EUI-64，系统自动生成（如Windows系统根据一定算法计算得到接口ID）） 动态获取，EUI-64方式：该方式用于无状态自动配置，通过ICMPv6的报文通告前缀，自动根据EUI-64算法计算出接口ID，组合前缀和接口ID形成IPv6地址。EUI-64计算和IPV6生成（无状态自动配置） 48bit的MAC地址，前24bit是OUI，后24bit厂商指定，在OUI和厂商指定的部分中间插入FFFE并将MAC地址的第7bit取反，为0的取值1，形成了64bit的接口ID根据收到的64位前缀，组合成IPV6地址。 11.2.3 IPv6地址分类 任播地址：主要用于DNS和HTTP协议，将同一个单播地址配置在不同的设备上，并携带任播参数，终端访问任播地址选择最近的路由到达。当最近的出现故障，路由收敛后，再次选择剩余的设备中最近的任播地址进行访问。组播地址：FF00::/8前缀，表示IPv6中接受相同数据的一组成员。与IPv4概念相同。 结构：FF+4bit Flags+4bit Scop字段+80bit预留字段+32bit组播组ID FF固定1BFlags：0000表示永久组播组地址，0001表示临时组播组地址。Scop范围：表示该组播地址的有效范围，0预留的，2表示链路本地范围（FF02：：1），E表示全球范围（FF0E：：1）常用组播地址： FF02::2 //所有路由器节点组播地址FF02::1 //所有设备节点的组播地址FF02::5 //所有启用了OSPFV3的接口的组播地址FF02::6 //OSPFv3的DR的组播地址FF02::D //PIMv2协议的组播地址（224.0.0.13）IPv6组播地址对应的组播MAC地址 该组播MAC地址的前16bit固定为33:33将IPV6组播地址的后32bit复制到组播MAC地址后32bit形成33:33+复制部分，形成IPv6地址对应的组播MAC地址。被请求节点组播组地址： FF02::1:FF00:1 //被请求节点组播组地址格式：FF02::1:FF00/104 前缀固定+24bit内容（从单播/任播IPV6地址映射而来）用于邻居发现（类似IPV4的 MAC地址解析）和重复地址检测（IPV4 免费ARP）邻居发现：通过被请求节点组播组地址进行，类似ARP解析地址的过程。 PC1和PC2直连进行通信，PC1封装NS报文（ICMPV6 135号）用于请求邻居PC2的MAC地址，报文内容：帧头+IPv6头部+ICMPv6报文 IPv6报文中的原IP地址为自己的IPV6的地址，目的IPv6地址为被请求单节点对应的组播组地址（PC2对应的被请求节点组播组地址）。ICMPv6报文内的目标地址PC2的单播地址，源MAC地址是自己的MAC地址。帧头中：源MAC地址是自己的MAC地址，目的MAC地址是被请求节点组播组地址对应的组播MAC地址（33:33+IPV6地址后32bit）除被请求节点PC2收到外需要回复，其他节点收到后，发现被请求节点组播组地址不是自己的IP地址加入的被请求节点组播组地址，从而丢弃报文。PC2单播回复响应报文（NA报文）。单播相应中的ICMPv6报文中的目标地址是本端的IPv6地址（对端请求解析的地址）。单播地址： 全球单播地址（GUA），类似IPV4的公网IP地址，已分配的IP地址前3bit位001（即第一个16进制字符为2或者3）本地唯一地址LUA，类似IPV4的私网地址，具有全球唯一性，前缀FC::/7（分为了两个部分：FC::/8和FD::/8），目前使用的仅FD::/8，另一半用于以后扩展。链路本地地址LLA：作用范围仅在本链路有效，格式： FE80::/10 //其中前缀/10的bit保持不变+54bit 0+64bit接口ID 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f21b133f3baa8d7666982caebe2388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513418e8a5ca81e87ce7cdddeb6662d5/" rel="bookmark">
			2024上海国际智慧城市,物联网,大数据博览会（上海智博会）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的飞速发展，智慧城市、物联网与大数据已经成为当今社会发展的重要驱动力。作为国内最具影响力的科技展会之一，2024上海国际智慧城市,物联网,大数据博览会（简称:世亚智博会）汇聚了全球顶尖的智慧城市、物联网与大数据技术，为人们展示了一个未来生活的美好蓝图。
在本次展会上，人们看到了各种各样的智慧城市解决方案。从智能交通管理系统，到智能垃圾分类回收系统，再到智慧能源管理，每一项技术都让人们对未来生活充满了期待。例如，一款名为“City Brain”的城市大脑平台，利用大数据和人工智能技术，实现了对城市各项数据的实时监测和智能分析，为城市管理者提供了更加科学、高效的决策依据。
物联网作为智慧城市的重要组成部分，在本次展会上也备受关注。通过物联网技术，各类设备可以相互连接，实现数据的共享和交换。一款名为“Smart Home”的智能家居系统，可以让人们通过手机或语音助手实现对家中各种设备的控制，大大提高了生活的便利性。此外，在工业领域，物联网技术的应用也日益广泛，为工厂和企业带来了更高的生产效率和更低的运营成本。
大数据技术作为智慧城市和物联网发展的重要支撑，在本次展会上也取得了突破性进展。通过对海量数据的收集、分析和挖掘，人们可以更好地了解城市运行状况、预测未来趋势，从而做出更加科学、合理的决策。同时，大数据技术还可以帮助企业精准定位市场需求，优化产品设计和营销策略。
在本次展会上，各国参展商纷纷带来了各自的最新技术和解决方案，让人们深刻感受到了智慧城市、物联网与大数据的无限可能。与此同时，展会还为业内人士提供了一个交流和学习的平台，促进了各方之间的合作与共同进步。
未来，智慧城市、物联网与大数据将继续发挥重要作用，为人类创造更加美好的生活。而2024上海国际智慧城市,物联网,大数据博览会（简称:世亚智博会）作为这一领域的重要盛会，将继续发挥其平台作用，引领科技发展的新潮流。让我们共同期待“2024世亚智博会”的精彩绽放，见证一个更加智慧、便捷和美好的未来！
如果您有意愿成为展商或希望了解更多信息可关注官网http://www.acewlz.com，也可直接致电185 1555 6762，我们期待您的参与！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3a80d1eaa46a39b69a134261b8a058f/" rel="bookmark">
			腾讯云2核2G轻量应用服务器300GB月流量够用吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云2核2G轻量服务器300GB月流量够用吗？够用，对于个人博客或流量较少的企业网站是够用的，如果是视频类应用肯定是不够的，300GB月流量折合每天10GB，大家可以根据自身实际应用来估算。腾讯云服务器网txyfwq.com分享目前这款轻量2核2G4M配置新老用户均可买，可选三年，活动 https://curl.qcloud.com/oRMoSucP
关于流量的说明：腾讯云轻量应用服务器仅统计公网出方向流量，私网产生的流量是不计费的，公网入方向产生的流量也是免费的，只有公网出方向的流量才会被统计。用户使用从网上传数据到云服务器，产生的流量是公网入流量，这个流量是不计费的；用户使用公网从云服务器下载文件到本地，产生的流量是出流量，是统计收费的。
如果流量超额了怎么办？流量超额后，超额部分的流量需要另外支付流量费，中国大陆地域的流量是0.8元每GB，关于流量计费请参考：https://curl.qcloud.com/ZtOYywjs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5b426e6901fea84a515e87bbdc0d4b/" rel="bookmark">
			【仅供测试】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://microsoftedge.microsoft.com/addons/detail/%E7%AF%A1%E6%94%B9%E7%8C%B4/iikmkjmpaadaobahmlepeloendndfphd
测试网站：
https://www.alipan.com/s/tJ5uzFvp2aF
// ==UserScript== // @name 阿里云盘助手 // @namespace http://tampermonkey.net/ // @version 2.1.6 // @description 支持生成文件下载链接、修改文件后缀,支持第三方播放器Artplayer(突破视频2分钟限制,长按倍速,选集,历史播放) // @license MIT // @icon https://img.alicdn.com/imgextra/i1/O1CN01JDQCi21Dc8EfbRwvF_!!6000000000236-73-tps-64-64.ico // @match https://www.aliyundrive.com/* // @match https://www.alipan.com/* // @require https://cdn.bootcdn.net/ajax/libs/vue/3.2.47/vue.global.min.js // @require data:application/javascript,window.Vue%3DVue%3B // @require https://cdn.bootcdn.net/ajax/libs/jquery/3.6.3/jquery.min.js // @require https://cdn.bootcdn.net/ajax/libs/axios/1.3.4/axios.min.js // @require https://cdn.bootcdn.net/ajax/libs/hls.js/1.3.3/hls.min.js // @require https://cdn.bootcdn.net/ajax/libs/artplayer/4.6.2/artplayer.min.js // @require https://cdn.bootcdn.net/ajax/libs/element-plus/2.2.32/index.full.min.js // @resource element-plus/dist/index.css https://cdn.bootcdn.net/ajax/libs/element-plus/2.2.32/index.min.css // @grant GM_getResourceText // @grant unsafeWindow // ==/UserScript== (t=&gt;{const e=document.createElement("style");e.dataset.source="vite-plugin-monkey",e.innerText=t,document.head.appendChild(e)})(".icon-wrapper--3dbbo[data-v-e5d83ee0]{height:28px;width:28px;display:-ms-flexbox;display:flex;border-radius:5px;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;color:var(--context_secondary);position:absolute;top:18px;right:16px;-webkit-transition:all .3s ease;-o-transition:all .3s ease;transition:all .3s ease;cursor:pointer;z-index:10}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd5b426e6901fea84a515e87bbdc0d4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b7b6be347137c67b7a83636f1f6f50/" rel="bookmark">
			docker中部署websocket客户端无法连接的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Docker中部署websocket，设置网络为host，与宿主机共享网络。但前端无法连接
原因是设置为host后websocket被映射到127.0.0.1导致出错，通过修改配置文件将其改为0.0.0.0即可
server: ip: 0.0.0.0 port: 8888 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39446aa6dd19516d7c5c66ecf1a35247/" rel="bookmark">
			【心得】PHP反序列化高级利用(phar|session)个人笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
①phar反序列化
②session反序列化
①phar反序列化 phar 认为是java的jar包 calc.exe
phar能干什么
多个php合并为独立压缩包，不解压就能执行里面的php文件，支持web服务器和命令行
phar协议
phar://xxx.phar
$phar-&gt;setmetadata($h);
metaData可以存放一个类实例，会将这个类实例以序列化字符串形式存放至Phar文件内
当使用phar协议加载phar文件时，会自动反序列化这个类的序列化字符串
总结：
1.生成phar包时，可以往metaData里面放对象
2.生成后，对象会自动序列化保存到phar包中
3.使用phar协议读取phar包时，如果当前脚本识别了这个类，会自动调用这个类的魔术方法
哪里使用的多
如果有上传点，上传文件的前半部分可控，后缀黑名单，不能上传危险的后缀为php phps phtml ini 没有禁止上传phar文件
能够上传phar文件，找到大量使用的file_exists等文件读取函数，通过控制phar://头，来使用phar协议来解析phar包
就能自动进行反序列化
条件：
1 能够生成phar包并上传写入
2 有可利用的文件操作函数，并控制了协议头，使用phar协议解析
3 有可利用的恶意类
可以触发phar反序列化的函数
fopen() unlink() stat() fstat() fseek() rename() opendir() rmdir() mkdir() file_put_contents() file_get_contents() file_exists() fileinode() include() require() include_once require_once() filemtime() fileowner() fileperms() filesize() is_dir() scandir() rmdir() highlight_file()
②session反序列化 在 PHP 中，PHP_SESSION_UPLOAD_PROGRESS是一个内置的会话变量，用于跟踪文件上传的进度。当使用 PHP 通过 HTTP POST 方法上传文件时，PHP 将自动创建并初始化这个变量。它的值表示上传文件的字节数。这个值可能会在整个上传过程中不断更新，以反映上传的实时进度。在一些情况下，可以使用这个变量来实现对上传进度的监控和处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39446aa6dd19516d7c5c66ecf1a35247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f372e316a6c089249d3e712dfb00ef/" rel="bookmark">
			5个用于构建Web应用程序的Go Web框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索高效Web开发的顶级Go框架 Go（或称为Golang）以其简洁性、高效性和出色的标准库而闻名。然而，有几个流行的Go Web框架和库为构建Web应用程序提供了额外的功能。以下是五个最值得注意的Go框架：
1. Gin： Gin是一个高性能、极简的Go Web框架。它因低延迟而著称，非常适合构建RESTful API。Gin提供了一个强大的路由系统和中间件支持，使得创建Web应用程序和服务变得简单。
GitHub仓库：Gin
要安装Gin框架并在Go中创建一个“Hello, World!”程序，请按照以下步骤操作：
1. 安装Gin框架： 您可以使用go get命令安装Gin。打开您的终端或命令提示符，并运行以下命令：
go get -u github.com/gin-gonic/gin 这将下载并安装Gin及其依赖项。
2. 创建一个Hello World程序： 创建一个使用Gin框架创建“Hello, World!”网络服务器的Go程序。您可以按照以下示例代码操作：
package main import "github.com/gin-gonic/gin" func main() { // Create a new Gin router r := gin.Default() // Define a route that responds with "Hello, World!" when accessed r.GET("/", func(c *gin.Context) { c.String(200, "Hello, World!") }) // Start the server on port 8080 r.Run(":8080") } 在这段代码中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9f372e316a6c089249d3e712dfb00ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f5237f87204fadce83d2b434d03b09/" rel="bookmark">
			modelsim安装使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 modelsim 简介 modelsim 简介 ModelSim 是三大仿真器公司之一mentor的产品，他可以模拟行为、RTL 和门级代码 - 通过独立于平台的编译提高设计质量和调试效率。单内核模拟器技术可在一种设计中透明地混合 VHDL 和 Verilog，常用在fpga 的仿真中。
##下载软件
网上找到的资源一般是包含两个文件：
一个安装文件，一个注册机
点击exe 进行安装，一路都是点击同意，最后有可能重启，是因为没有license 。
然后进行注册：
拷贝四个文件到安装目录中的win64中
点击拷贝后的patch64_dll.bat
如果只读权限就修改为可写权限
会弹出一个LICENSE.TXT 文件，这个文件还没有保存，需要另存到安装目录下
新建环境变量（环境变量在“我的电脑–属性–高级系统设置–环境变量”），变量名为MGLS_LICENSE_FILE，变量值为上面LICENSE.TXT文件的路径，部分版本或者系统为LM_LICENSE_FILE
之后就可以双击图标使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f527da3f5d6496c7826c3161b71eebb7/" rel="bookmark">
			Spring Cloud Gateway &#43; Nacos 灰度发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文将会使用 SpringCloud Gateway 网关组件配合 Nacos 实现灰度发布（金丝雀发布）
环境搭建 创建子模块服务提供者 provider，网关模块 gateway
父项目 pom.xml 配置
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-gateway-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;spring-gateway-demo&lt;/name&gt; &lt;description&gt;spring-gateway-demo&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;maven.compiler.plugin&gt;3.8.1&lt;/maven.compiler.plugin&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2.2.2.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; &lt;spring-cloud-starter-alibaba-nacos-config&gt;2.2.0.RELEASE&lt;/spring-cloud-starter-alibaba-nacos-config&gt; &lt;/properties&gt; &lt;modules&gt; &lt;module&gt;provider&lt;/module&gt; &lt;module&gt;gateway&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f527da3f5d6496c7826c3161b71eebb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d607fee35fda95ec0fbc271cc7fb9b3/" rel="bookmark">
			深度学习核心技术与实践之自然语言处理篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非书中全部内容，只是写了些自认为有收获的部分。
自然语言处理简介 NLP的难点 （1）语言有很多复杂的情况，比如歧义、省略、指代、重复、更正、倒序、反语等
（2）歧义至少有如下几种：
1.有些歧义是指代不明确带来的。比如“曾记否，我与你认识的时候，还是个十来岁的少年，纯真无瑕，充满幻想。"其中十来岁的少年指代不明，有可能指你，也有可能指我。
2.有些歧义是机器断句困难导致组合层次不同带来的。比如“我们四个人一”可以理解为“我们/四个人一组”或“我们四个人/一组”，“这件事我办不好”可以理解为“这件事/我/办不好”或“这件事/我办/不好”。
3.有些歧义是结构关系不同导致的。比如“学生家长”可以理解为“学生的家长”或"学生和家长”，"出口食品”可以理解为动宾关系，也可以理解为偏正关系。
4.有些歧义是词语语义多带来的。比如“他想起来了”可以理解为“他想起床了”或者“他想起来某件事情了”
5.词类不同也可以带来歧义。比如“我要炒饭”中的“炒”可以是动词，也可以是形容词.
6.很多新的品牌或网络用语也会带来歧义问题
NLP的研究范围 （1）分词：利用算法将一个汉字序列切分为一个个单独的词。比如将“手
爱机器学习”切分为“我/爱/机器学习“
（2）词性标注：将分词结果中的每个单词标注为名词、动词、形容词或其他词性的过程
（3）命名实体识别：识别文本串中具有特定物理意义的实体单词，比如人名、地名、机构名等
（4）关键词提取：提取文本串中若干个可以代表文章语义内容的词汇或词语
（5）自动摘要：也称为摘要提取，即根据文本语义内容提取较短的语句
（6）主题模型：隐式的主题模型如Latent Semantic Analysis (LSA) 、Probabilistic Latent Semantic Analysis ( PLSA) 、 Latent Dirichlet Allocation (LDA) 等都是非常常见的研究领域。
（7）依存句法分析：分析语言成分之间的依存关系，并揭示其语法树
（8）词嵌入 (Word Embedding) ：将词采用向量表示。词嵌入从2013年左右开始就一直比较流行，可以说，词嵌入本身不是深度学习，但词嵌入是深度学习用于自然语言处理的基本前提
（9）机器翻译：利用计算机将一种自然语言转换成另一种自然语言的过程，两种自然语言分别称为源语言和目标语言
词性标注 传统词性标注模型 （1）传统的词性标注方法有隐马尔可夫模型(HMM)和最大马尔可夫模型(MEMM)等。其中，HMM是生成模型，MEMM是判别模型
（2）基于MEMM的词性标注器抽取当前待标注单词附近的特征，然后利用这些特征判别当前单词的词性。MEMM是最大熵模型(ME) 在处理序列模型方面的变种。其思想是在一串满足约束的标签中选出一个熵最大的标签
（3）当前单词的上下文信息又叫作特征。根据在语料中出现的频次，可以将单词分为常见词和罕见词。常见词周围的特征包括：待标注的单词、待标注单词附近的单词、待标注单词附近已标注单词的词性标签等；罕见词的特征包括：单词的后缀、单词的前缀、单词是否包合数字、单词是否首字母大写等
（4）HMM和MEMM存在同一个问题，就是只能从一个方向预测接下来的标注。一种解决方法是用例如CRF这样的强大模型，但是CRF的计算开销太大，并且对标注效果的提升有限
基于神经网络的词性标注模型 （1）模型从左向右依次标注句子中的单词，对于当前单词，抽取周用一定窗口大小内的特征，然后将其作为特征向量送入前馈神经网络分类器
（2）整个神经网络分为多层。第一层把每个单词映射到一个特征向量，得到单词级别的特征，第二层利用滑动窗口得到单词上下文的特征向量，不像传统的词袋方法，这个方法保留了窗口内单词的顺序关系。同时也可以加入其他特征，如单词是否首字母大写、单词的词干等
（3）在计算上下文特征时只考虑当前单词附近窗口大小为k范围内的单词，这种方法叫作窗口方法
（4）将整个句子的单词特征向量送入后续网络中，这种方法叫作句子方法
（5）对于词性标注来说，句子方法并不能带来明显的效果提升，但是对于自然语言里的某些任务，如语义角色标注(SRL)，句子方法带来的效果提升会比较明显
（6）因为句子长度一般是不定的，所以在使用句子方法的神经网络模型中会增加卷积层
（7）用无监督训练得到的词向量初始化词性标注模型的词向量，能明显提升词性标注的准确率
基于Bi-LSTM的神经网络词性标注 （1）普通的词向量结合大量语料可以学习到单词间语义和语法上的相似性。举个例子，模型可以学到cats、kings、queens之间的线性相关性与cat、king、queen之间的线性相关性一样。不过模型并不能学到前面这组单词是由后面这组单词在末尾加s得到的
（2）普通的词向量模型查找表过于庞大，于是就有人提出将单词拆成更小的单元。基于字符的词向量模型的输入、输出和普通的词向量模型是一样的，因此在神经网络模型中这两种模型可以相互替换。与普通的词向量模型类似，基于字符的词向量模型是给字符集合建立一个查找表。字符集合包括大小写字母、数字、标点等，每个字符都可以在查找表中找到对应的字符向量，每个单词都可以看成一串字符，将单词中的字符对应的向量从左到右依次送入LSTM模型，再以右向左依次送入LSTM模型。两个方向的LSTM模型生成的结果组合生成当前单词的词向量，这样就可以利用Bi-LSTM模型得到单词的向量表示。整个过程如图19-3所示
（3）模型架构
（4）相对于普通的词向量模型，基于字符的词向量模型减少了很多参数。不过，因为英文中单词构成的复杂性，该模型在词性标注上的表现并没有超越现有模型
（5）虽然基于字符的词向量模型可以学习ed，ily这种形变特征，但是英文中有些字符构成很像的单词之间的差异却很大，比如lesson和lessen，虽然以字符角度看起来很像，但是它们的含义却完全不同
依存句法分析 未完待续...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d236ad7649c75a26778bca0616859c/" rel="bookmark">
			lua调用C/C&#43;&#43;的函数，十分钟快速掌握
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 lua调用C\C++动态库函数 系列文章目录摘要环境一些说明使用步骤你需要有个lua环境引入库码代码lua代码 摘要 在现代软件开发中，Lua作为一种轻量级脚本语言，在游戏开发、嵌入式系统等领域广泛应用。Lua与C/C++的高度集成使得开发者能够借助其灵活性和高效性实现更强大的功能。本文将通过一些简单、直接的示例探讨Lua调用C/C++函数的技术。Lua通过调用C/C++实现的extern "C"函数来交互，首先，我们需要在C/C++中编写适当的包装函数，并使用Lua API将其注册到Lua虚拟机中，这一过程包括参数的传递、函数调用以及返回值的处理。通过合理设计的接口，生成动态库文件使其在lua脚本中用require引用，我们能够在Lua中直接调用C/C++函数，实现跨语言的功能扩展。这为项目提供了更大的灵活性，允许开发者在Lua中编写高层逻辑，同时利用C/C++的性能优势处理底层任务。从实践角度看，Lua调用C/C++的技术架构在提高代码可维护性和性能的同时，也为项目带来了更强大的扩展性。通过深入学习Lua与C/C++交互的原理和最佳实践，开发者可以更好地应用这一技术，提升项目的开发效率和整体性能。
还有一种提供C API给lua用的方法：把lua的源码clone一份自己改，定义一个library导出，然后编译成可执行文件或者库，那么lua依然可以通过require引入和使用。
环境 软件版本Windows10visual studio2022lua5.1C++17 一些说明 本质上在C++与Lua的相互调用中它们的地位并不”平等“，要不是C++程序作为启动程序（主程），要不就是lua作为启动程序（主程）。lua作为启动程序使用C++代码只能通过动态库引用其实现的C风格函数，而C++程序作为启动程序中，使用lua脚本则是嵌入式的使用，有两种方式，1、直接在cpp里写lua代码，2、在cpp中引用外部lua脚本文件，这两种方式下可以在cpp中通过sol2这种绑定库将一些类、函数绑定到Lua中提供给内嵌的lua代码或者外部的lua脚本使用。像openResty、neovim也是这么用的，我们会介绍这些方式。
使用步骤 你需要有个lua环境 在lua官网下载编译好的动态库、静态库、头文件和可执行二进制文件。
https://luabinaries.sourceforge.net/
拿到lua.hpp头文件和lua5.1.lib静态库，加到自己项目的引用。
引入库 lua.hpp头文件去安装目录找。
码代码 头文件
代码如下（示例）：
#pragma once /* 几个简单的函数 */ // step 1 #include "lua.hpp" // step 2 定义自己的函数 int addTwoNumber(int a, int b) { return a + b; } const char* linkNameAndNumber(const char* name, int age) { std::unique_ptr&lt;char&gt; pbuf(new char[128]); sprintf(pbuf.get(), "Your name is %s, and %d years old.", name, age); std::string r(pbuf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46d236ad7649c75a26778bca0616859c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a4637a49505ac3ba19c63471fe7be6/" rel="bookmark">
			MySQL 中的 JSON_CONTAINS 函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在处理 MySQL 中的 JSON 数据时，我们经常需要检查一个 JSON 文档是否包含特定的值。这时，JSON_CONTAINS 函数就显得非常有用。
JSON_CONTAINS函数介绍 JSON_CONTAINS 是 MySQL 提供的一个 JSON 函数，用于测试一个 JSON 文档是否包含特定的值。如果包含则返回 1，否则返回 0。该函数接受三个参数：
target: 待搜索的目标 JSON 文档。candidate: 在目标 JSON 文档中要搜索的值。path（可选）： 路径表达式，指示在哪里搜索候选值。 一般的使用语法为：
JSON_CONTAINS(target, candidate[, path]) JSON_CONTAINS函数实例演示 假设我们有一个名为 products 的表，其中包含了一些产品信息：
CREATE TABLE products ( id INT AUTO_INCREMENT PRIMARY KEY, details JSON ); INSERT INTO products (details) VALUES ('{"name": "Product 1", "tags": ["tag1", "tag2", "tag3"]}'), ('{"name": "Product 2", "tags": ["tag1", "tag4"]}'); 现在，我们想要找出tags字段中所有包含 “tag1” 标签的产品。我们可以利用 JSON_CONTAINS 函数来实现这个需求：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54a4637a49505ac3ba19c63471fe7be6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9156eac6f3a3d943ae929aae728290d/" rel="bookmark">
			Altium Designer开发合集【目录】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏡《专栏目录》
欢迎大家来到《Altium Designer开发合集》该专栏包括【电路设计篇】【PCB设计篇】【电路仿真篇】【PCB仿真篇】四个部分，以供大家参考。大家直接点击大纲中蓝色标题即可轻松传送。
【电路设计篇】
Altium Designer（AD）创建工程文件包图文视频
Altium Designer（AD）新工程复用设计文件图文视频
Altium Designer（AD）以二极管为例创建原理图符号库图文视频
Altium Designer（AD）以创建运放为例创建相同多部分元器件原理图库方法图文视频
Altium Designer（AD）创建非相同多部分元器件原理图库方法图文视频
Altium Designer（AD）原理图符号库设计的常用经验技巧总结图文视频【持续更新】
Altium Designer（AD）切换中文界面与英文界面的方法图文视频
Altium Designer（AD）软件界面切换为浅灰色与深灰色的方法图文视频
【PCB设计篇】
【电路仿真篇】
【PCB仿真篇】
🏡《专栏目录》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a7340406a1d76b3d0d53476aa60f58/" rel="bookmark">
			【MATLAB】鲸鱼算法优化混合核极限学习机(WOA-HKELM)时序预测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有意向获取代码，请转文末观看代码获取方式~也可转原文链接获取~
1 基本定义 鲸鱼算法优化混合核极限学习机（WOA-HKELM）是一种时序预测算法，它结合了鲸鱼算法和混合核极限学习机（HKELM）的优点。以下是该算法的基本原理：
「初始化」：在算法开始时，需要在可行解空间中初始化一群鲸鱼个体。每个鲸鱼个体代表一个潜在的最优解，位置表示鲸鱼的特征，适应度值由适应度函数计算得到。
「搜索」：每个鲸鱼按照一定的规则探索空间。这个过程模拟了鲸鱼包围、追捕和攻击猎物等过程。具体来说，每只鲸鱼会根据其当前位置和速度，按照一定的规则在解空间中移动，并更新其位置。
「评估」：每当鲸鱼移动时，都会计算当前的适应度值。适应度值由目标函数计算得到，表示鲸鱼的优劣。如果当前的适应度值优于之前的适应度值，则将当前适应度值设为最优解。
「更新」：当所有的鲸鱼都完成移动和评估后，算法会根据一定的规则更新所有鲸鱼的位置和速度。更新的规则是基于鲸鱼的适应度值和种群最优解的情况，确保算法向着更优的方向演化。
「迭代」：重复上述步骤，直到满足终止条件或者达到预设的最大迭代次数。在迭代过程中，鲸鱼的主要行为包括包围猎物、捕获猎物、搜索猎物等。通过这些行为，鲸鱼种群逐渐向最优解靠近。
通过以上步骤，鲸鱼算法优化混合核极限学习机（WOA-HKELM）能够找到最优解，实现时序预测。该算法具有较高的效率和稳定性，能够应用于各种类型的优化问题。
在WOA-HKELM中，HKELM被用作预测模型，而鲸鱼算法被用于优化HKELM的参数。通过优化参数，WOA-HKELM能够提高预测精度和稳定性。
总的来说，WOA-HKELM 是一种非常实用的时序预测工具，尤其适合新手学习和研究人员进行时序预测的实验和比较。在实际应用中，通过调整参数和优化算法，WOA-HKELM 工具也能够满足不同场景和任务的需求。
以下是对鲸鱼算法优化混合核极限学习机（WOA-HKELM）实现过程的描述：
「初始化」：在算法开始时，需要在可行解空间中初始化一群鲸鱼个体。每个鲸鱼个体代表一个潜在的最优解，位置表示鲸鱼的特征，适应度值由适应度函数计算得到。
「搜索」：每个鲸鱼按照一定的规则探索空间。这个过程模拟了鲸鱼包围、追捕和攻击猎物等过程。具体来说，每只鲸鱼会根据其当前位置和速度，按照一定的规则在解空间中移动，并更新其位置。
「评估」：每当鲸鱼移动时，都会计算当前的适应度值。适应度值由目标函数计算得到，表示鲸鱼的优劣。如果当前的适应度值优于之前的适应度值，则将当前适应度值设为最优解。
「更新」：当所有的鲸鱼都完成移动和评估后，算法会根据一定的规则更新所有鲸鱼的位置和速度。更新的规则是基于鲸鱼的适应度值和种群最优解的情况，确保算法向着更优的方向演化。
「迭代」：重复上述步骤，直到满足终止条件或者达到预设的最大迭代次数。在迭代过程中，鲸鱼的主要行为包括包围猎物、捕获猎物、搜索猎物等。通过这些行为，鲸鱼种群逐渐向最优解靠近。
通过以上步骤，鲸鱼算法优化混合核极限学习机（WOA-HKELM）能够找到最优解，实现时序预测。该算法具有较高的效率和稳定性，能够应用于各种类型的优化问题。
在鲸鱼优化算法（WOA）中，参数的调整可以通过实验和经验来决定。以下是一些常见的参数调整方法：
「种群规模」：种群规模是指算法中鲸鱼的数量，通常需要通过实验来选择合适的种群规模。一般来说，种群规模不宜过大或过小，需要根据问题的复杂性和求解精度要求进行合理设置。
「迭代次数」：迭代次数是指算法的迭代次数，也需要在实验中进行合理设置。如果迭代次数太少，算法可能无法找到全局最优解；如果迭代次数太多，可能会导致算法运行时间过长。
「搜索空间」：搜索空间是指鲸鱼在解空间中移动的范围，可以通过设置适当的搜索空间来限制鲸鱼的移动范围。搜索空间的设置需要根据问题的特性进行合理设置。
「学习因子」：学习因子是指鲸鱼之间的学习程度，可以通过调整学习因子的值来影响算法的性能。一般来说，学习因子的值应该在一定范围内进行选择，以便在全局搜索和局部搜索之间取得平衡。
「边界条件」：边界条件是指解空间的边界，可以通过设置合理的边界条件来避免鲸鱼越界。边界条件的设置应该根据问题的实际情况进行合理设置。
在调整参数时，可以尝试不同的参数组合，通过实验和比较来选择最优的参数配置。同时，也可以参考其他优化算法的参数调整经验，以便更好地优化鲸鱼优化算法的性能。
2 出图效果 附出图效果如下：
附视频教程操作：
【MATLAB】鲸鱼算法优化混合核极限学习机(WOA-HKELM)时序预测算法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/790e6b831a3c9e985e2646d555e14433/" rel="bookmark">
			【5G PHY】5G 物理层加速卡介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主未授权任何人或组织机构转载博主任何原创文章，感谢各位对原创的支持！
博主链接
本人就职于国际知名终端厂商，负责modem芯片研发。
在5G早期负责终端数据业务层、核心网相关的开发工作，目前牵头6G算力网络技术标准研究。
博客内容主要围绕：
5G/6G协议讲解
算力网络讲解（云计算，边缘计算，端计算）
高级C语言讲解
Rust语言讲解
文章目录 5G 物理层加速卡介绍一、物理层加速的分类1.1 内置加速器1.2 外挂加速器 二、选择物理层加速卡的考虑因素三、一些物理层加速卡 5G 物理层加速卡介绍 物理层加速卡，是一种专门用于提高5G无线网络物理层性能的硬件。物理层加速卡通常用于5G基站，将一些需要密集计算处理和大功率的数据传输任务卸载到加速卡（例如信道估计、均衡和解码等）。通过将上述这些任务卸载到专用的硬件加速器，可以帮助提高物理层数据传输的速度和效率。此外，使用加速卡有助于降低5G基站的功耗，这可以是能效的重要考虑因素。
加速卡通常使用专用的硬件组件，如FPGA或ASIC，来执行物理层所需的信号处理任务。这种硬件加速可以显著提高网络的处理速度和效率，实现更高的数据传输率、低延迟和更好的可靠性。
一、物理层加速的分类 硬件加速 内置加速器外挂加速器 软件加速 1.1 内置加速器 在这种类型的加速卡中，物理层的一部分或整个物理层功能都可以卸载到加速器上。
这种类型的加速解决方案可以是可编程和硬编码的混合，取决于对灵活性和效率之间的权衡。对于高带宽的vRAN应用，可能需要完整的物理层处理卸载。在这种情况下，内置硬件加速器可能会以最低的延迟和所需的最少内核提供最佳结果。
1.2 外挂加速器 在这种类型的加速卡中，只有选定的功能被发送到加速器，然后返回到CPU（如下图所示）。
当加速器处理选定的功能时，允许处理器处理其它的任务。一旦处理器接收到加速器处理后的数据，可以切换进程上下文，返回到之前的进程中继续执行后面流程。
二、选择物理层加速卡的考虑因素 是否需要可扩展；支持各种部署场景；在不同的部署和客户场景中具有成本效益；CPU和加速能力相匹配；不受PCIe带宽的限制；不受散热要求；能源效率； 三、一些物理层加速卡 有许多公司，如高通、Marvell和Xilinx等正在开发物理层加速卡，其中包括内置加速器和旁路加速器。下图是一些比较有名的加速卡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5721b433fa14f4fb842773c94cc2ee35/" rel="bookmark">
			numpy的科学计算（亲测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
from django.test import TestCase import numpy as np # Create your tests here. def nuTest(): #特定范围内的随机数 a=np.random.randint(5,size=7)#创建一个0-5内7个长度的任意数字 a1=np.random.randint(5,size=(3,4))#创建一个3x4的二维数组，5以内的数字创建 print(a1) print(a) b=np.random.randint(2,10,size=(3,2))#创建一个2-10范围内3x2的数组 print(b) c=np.random.random(9)#创建一个0-1以内的8个长度的数组浮点数 print(c) d=np.random.randn(100).mean()#创建100个浮点数用于标准正态分布零均值 print(d) f=np.random.randn(100).std()#创建100个浮点数用于标准正态分布单位方差 print(f) g=np.ones((4,3))#创建二维 g1=np.ones(4) #创建一维 h=np.zeros((4,3)) h1=np.zeros(10) j=np.eye(3)#创建一个单位矩阵 print(j) k=np.identity(3)#创建一个单位矩阵 print(k) l=np.arange(7)#创建一维的7个长度的数组 l1=np.arange(1,7)#创建一个步长是1，长度是1-7的数组 print(l1) l3=np.arange(0,10,2)#创建一个步长是2,0-10之间的数 print(l3) z=np.full((3,4),9)#创建一个3行4列，全是数字9的矩阵 print(z) z1=np.full((3,4),9,dtype="float") print(z1) x=np.random.randint(6,size=(3,4)) x1=x.ravel()#把一个3x4的二维数组，变换成一个1维的数组 print(x1) c=x.reshape(4,3)#把x数组调整成一个4x3的数组 c1=x.reshape(2,6)#把x数组调整成一个4x3的数组 print(c1) #让NumPy通过传递-1来确定尺寸 c2=x.reshape(-1,3) #4x3 c3=x.reshape(-1,1)#12x1 #把一个矩阵转换成一个转置矩阵，也就是行和列进行互换位置 v=x.transpose() print(v) #np的切片技术 b=np.random.randint(6,size=(4,3)) b1=np.vsplit(b,2) #行数一定是偶数，切成一个2x3的数组 print(b1) b2=np.vsplit(b,2)[0]##行数一定是偶数，切成一个2x3的数组，输出第一项 print(b2) n=np.random.randint(7,size=(6,4)) n1=np.hsplit(n,2) n2=np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5721b433fa14f4fb842773c94cc2ee35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475a5fea8b2934347e1b19ed744419f7/" rel="bookmark">
			numpy的增删改查操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码：
#-*- ecoding:utf-8 -*- import numpy as np #增 def insert(): a=np.array([[1,2],[3,4]]) b=np.array([[40,50],[4,90]]) c=np.vstack((a,b))#增加行 d=np.hstack((a,b))#增加列 print(c) print(d) #删除 def delete(): a=np.array([[1,2],[3,4],[4,5]]) # a=a[0] # a=np.delete(a,1,axis=0)#删除a矩阵的第二行 # a=np.delete(a,(1,2),axis=0)#删除第二，三列的数据 # a=np.delete(a,1,axis=1)#删除第一列的数据 # a=np.hsplit(a,2)#垂直分 a=np.split(a,2,axis=1)#垂直分 # a=np.vsplit(a,3)#水平分 print(a) #修改 def update(): a=np.array([[1,2],[3,4],[4,5]]) # a[0]=[11,33]#修改[1,2]为[11,33] # a[0][0]=111#修改1为111 print(a) #查询 def query(): a=np.array([[1,2],[3,4],[3,5]]) print(a[0][1]) b=np.arange(6)#[0,1,2,3,4,5] c=b[1:3]#左闭右开 f=b[:3]#左边默认为0 g=b[3:]#右边默认元素个数 h=b[0:4:2]#下标递增2 print(b) print(h) def showAttr(): a = np.linspace(0, 10, 7) # 生成首位是0，末位是10，含7个数的等差数列 a = np.logspace(0, 4, 5) # 用于生成首位是10**0，末位是10**4，含5个数的等比数列。 a = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/475a5fea8b2934347e1b19ed744419f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f09c2b3a115a80f61b6433da60e127/" rel="bookmark">
			pandas创建和文件读取笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 结构：
代码：
import pandas as pd import numpy as np #pandas依赖处理Excel的xlrd模块，所以我们需要提前安装这个，安装命令是：pip install xlrd #在更新为2.0.1之后,如果不指定engine='openpyxl’的话默认xlrd只能读取xls文件,安装pip install openpyxl data_series=pd.Series([1,2,3,4]) #列表生成series print(data_series) ##可用包含等长列表（数组/Series）的字典生成DataFrame data_pd=pd.DataFrame({"id":[1,2,3,4],"name":["gree","huitao","luss","penfei"]}) print(data_pd) #分别查看值和索引 print(data_series.values) print(data_series.index) print(data_pd.values) print(data_pd.index) #读取其他数据文件 pd_excel=pd.read_excel("huitao.xlsx",sheet_name="Sheet1",engine="openpyxl")#现在就ok了 p_head=pd_excel.head()#默认显示前5行数据 print(p_head) #读取cvs df_csv = pd.read_csv('huitao.csv') #读入csv文件 print(df_csv) #读取json数据 df_json=pd.read_json("huitao.json") print(df_json) #输出数据文件 data_pd .to_csv('save_file.csv') data_pd .to_excel('save_file.xlsx') data_pd .to_json('save_file.json') 测试结果：
F:\开发工具\pythonProject\tools\venv\Scripts\python.exe F:/开发工具/pythonProject/tools/python的sklear学习/pandastest.py 0 1 1 2 2 3 3 4 dtype: int64 id name 0 1 gree 1 2 huitao 2 3 luss 3 4 penfei [1 2 3 4] RangeIndex(start=0, stop=4, step=1) [[1 'gree'] [2 'huitao'] [3 'luss'] [4 'penfei']] RangeIndex(start=0, stop=4, step=1) id name adrress 0 1 huitao beijing 1 2 qiwei shanghai 2 3 weiping shanxi Empty DataFrame Columns: [谢谢你给我的爱，让我度过那个春天] Index: [] id name address 0 1 huitao 陕西省清涧县 1 2 huitao 陕西省梓州 Process finished with exit code 0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a3487baa531a1673380570a633344d6/" rel="bookmark">
			【MATLAB】【数字信号处理】线性卷积和抽样定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已知有限长序列：xk=1,2,1,1,0,-3, hk=[1,-1,1]
,
计算离散卷积和yk=xk*h(k) 。
程序如下：
function [t,x] = My_conv(x1,x2,t1,t2,dt) %文件名与函数名对应 %自写的卷积函数 x = conv(x1,x2)*dt; t0 = t1(1) + t2(1); L = length(x1) + length(x2)-2; t = t0:dt:(t0+L*dt); end clear; k1 = [0, 1, 2, 3, 4, 5]; %xk的序列号 xk = [1, 2, 1, 1, 0, -3]; %xk的序列值 subplot(311); stem(k1,xk,'filled'); title('x(k) = [1,2,1,1,0,-3]'); k2 = [0, 1, 2]; hk = [1, -1, 1]; subplot(312); stem(k2, hk,'filled'); title('h(k) = [1,-1,1]'); [k3,yk] = My_conv(xk, hk, k1, k2, 1); %调用卷积的函数 subplot(313); stem(k3,yk,'filled'); title('y(k) 卷积后图像'); 运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a3487baa531a1673380570a633344d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1fe00231d6972ad6f0d54cae9e09712/" rel="bookmark">
			【MATLAB】【数字信号处理】基本信号的仿真与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的 1、用MATLAB软件实现冲激序列
2、用MATLAB软件实现阶跃序列
3、用MATLAB软件实现指数序列
4、用MATLAB软件实现正弦序列
内容与测试结果 1、用MATLAB软件实现冲激序列 程序如下：
% 1 冲激序列 clc; clear all; n0 = -10; nf = 50; ns = 1; A = 1;%起点为-1，终点为5，幅值为1 在3出有单位冲激 n = n0 : nf; %生成离散信号的时间序列 y = dirac(n - ns); % n = ns处有δ函数，即δ(n-ns) y = A * sign(y); %改变幅度 subplot(2, 2, 1); stem(n, y, 'r'); axis([n0, nf, -0.1, 1.1]); %绘制离散序列 title('δ(k-3)'); %加标题 运行结果如下：
2、用MATLAB软件实现阶跃序列 代码如下：
% 2 阶跃序列 clc; clear all; n0 = -10; nf = 50; ns = 2; %起点为-1，终点为5，在3出有单位阶跃序列 n = n0 : nf; %生成离散信号的时间序列 f = [zeros(1,ns-n0), ones(1,nf-ns+1)]; %生成离散信号f(n) %也可用逻辑运算方法产生，f=[(n-ns)&gt;=0] subplot(2, 2, 2); stem(n, f, 'filled'); axis([n0, nf, -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1fe00231d6972ad6f0d54cae9e09712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a3aa35fea3ccecc7006d70091339a28/" rel="bookmark">
			嵌入式Linux之Ubuntu学习笔记（文件系统结构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二.Ubuntu文件系统结构 /bin 存放二进制可执行文件，这些命令在单用户模式下也能够使用。可以被root和一般的账号使用。
/boot Ubuntu内核和启动文件，比如vimlinuz-xxx。gurb引导装载程序。
/dev 设备驱动文件
/etc 存放一些系统配置文件，比如用户帐号和密码文件，各种服务的起始地址。
/home 系统默认的用户文件夹，一般创建用户帐号的时候，默认的用户主文件夹都会放到此目录下。
/lib 存放库文件
/media此目录下放置可插拔设备，比如SD卡，或者U盘就是挂载到此处。
/mnt 用户可使用的挂载点，如果要挂载一些额外的设备，那么就可以挂载到此处。
/opt 可选的文件和程序存放目录，给第三方软件放置的目录。
/root root用户目录，也就是系统管理员目录。
sbin 和/bin类似，也是存放一些二进制可执行文件。sbin下面的一般是系统开机过程中所需要的命令。
/srv 服务相关目录。比如网络服务。
/sys 记录内核信息，虚拟文件系统。
/tmp 临时目录
/var 存放一些变化的文件，比如日志文件。
/usr usr不是user的缩写，而是UNIX Software Resource的缩写，存放于系统用户有关的文件，会占用很大的存储空间！
/proc 虚拟文件系统，数据放置到内存中，存放系统运行信息。
三.绝对路径和相对路径 绝对路径：从根目录/算起的路径。
相对路径：相对于目前路径的文件名写法，比如./home/lcp/不是以/开头的就行。
.代表当前路径，也可以用./表示。
..代表上一层目录，也可以用../表示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54b459ded455402e4d131d38f1895e3/" rel="bookmark">
			牛客周赛 Round 26 解题报告 | 珂学家 | 0-1 BFS &#43; 状态机DP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 整体评价 T3是一道0-1 BFS题, 这样时间复杂度可以控制在O(n*m), 也可以用优先队列。
T4这类题型，在牛客Round周赛系列出现好多次了，要么状态机DP，要么容斥，如果n很大，就用矩阵幂优化。
欢迎关注 珂朵莉 牛客周赛专栏
珂朵莉 牛客小白月赛专栏
A. 小红的整数操作 思路：同余分组
对k进行取模分组，同余的任意两个数，一定可以构造成一样
from collections import Counter n, k = list(map(int, input().split())) arr = list(map(int, input().split())) cnt = Counter() for v in arr: cnt[v % k] += 1 res = max(cnt.values()) print (res) B. 小红的01串 思路：奇偶分析，找规律
可以枚举最终趋同的数是0，还是1
同时相邻2数翻转，其0,1本身个数的奇偶是不改变的
这样可以发现，如果0的个数，1的个数都是奇数，必然是死局，无法构造。
t = int(input()) while t &gt; 0: t -= 1 s = input() n0, n1 = 0, 0 for c in s: if c == '0': n0 += 1 else: n1 += 1 if n0 % 2 == 1 and n1 % 2 == 1: print ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a54b459ded455402e4d131d38f1895e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c25fdf034248f4f289961ee0dc7789/" rel="bookmark">
			OBCA题库疑问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Liunx OS采用 admin 用户来部署OB？
2、OB架构特点？
全对等节点、中心管控
补充、城市A 2个Zone 城市B 1个Zone
城市A 1个Zone宕机，会增加异地同步延迟？？？
3、OB采用租户隔离资源，内存（物理）隔离，CPU（逻辑）隔离 ？
https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-10000000000885920
4、OB系统参数生效范围：集群、Zone、OBServer？
5、alter system set XX=“YY”
可以修改该Parameter在某台具体的OBServer上的值
可以修改该Parameter在某个Zone上的值
如果不带任何条件，则修改所有OBServer的值
6、备份恢复功能支持哪些数据
用户权限、表定义、系统变量、用户信息、视图信息
7、负载均衡
调度单元：资源单元（Unit）、分区（Partition）
系统根据一定的策略，通过动态调整UNIT的位置和UNIT内副本的位置，使得一个Zone内所有Server的资源使用率达到均衡的过程。
8、主副本故障后，业务无法访问主副本数据，OB如何保证高可用性？
剩余从副本依然构成多数派，自动选出新的主副本来承接业务，切换过程对业务不可见
主副本联系不到所有的从副本，其变成少数派，将自动卸任主副本
9、分区Partiton
数据表根据分区规则，拆分成多个分区，每个分区包括表种的若干行记录
每个分区还可以用不同的分区维度再进行分区，叫做二级分区
分区Partiton Group是数据迁移的最小单元，也是高可用切换的最小单元
10、OB的租户权限管理
任何租户（不论是系统租户还是普通租户）下的用户不能跨租户访问其他普通租户下的用户数据
只有系统租户下的管理员用户才有集群管理权限，执行系统管理操作，如创建/删除普通租户、设置系统配置参数、开启每日合并操作
补充：OCP上OB Proxy管理功能
安装、重启、下线
补充：OCP告警功能
调整告警阈值
查看告警列表
自定义告警发送对象
调整告警开关，确定哪些项需要监控
11、租户逻辑上类似传统数据库的实例，创建完成后每个租户都将有自己的专属进程？ 错
12、应用通过OB Proxy连接到OB集群，比直连主副本所在的OB Server性能更好？错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5caa9824275d72089846372df7ae6500/" rel="bookmark">
			2024新年快乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 2023年马上就要过去，希望2024年会越来越好，根据自己学的内容来实现一些我的idea。
单片机 思路 最开始的构思是这样的，“2024”用数码管来输出然后中文的“新年快乐”用点阵来实现，但是点阵是动态的截图不好看，就想干脆用LCD1602输出英文的新年快乐算了，这样就只需要一个AT89C51就行了，还剩下五根引脚，想起来过年我印象中听过最多的歌是“好运来”就想增加一个蜂鸣器来播放好运来歌曲，大致的构思出的原理图如下，实验所需器件在代码后面。
2024 首先是对2024的输出，这个就是输出他的BCD码。这个网络标号最开始就是C0在上面，输出的时候发现不对，然后就反过来标记，算是蒙对的。
#include&lt;reg51.h&gt; void main(void){ while(1){ //2024 0010 0000 0010 0100 P1=0x20; P3=0x24; } } Happy New Year 用LCD 1602输出我们没必要重新书写代码，只需要修改之后的代码即可。顺便对输出“2024”部分封装成函数。字符型液晶显示器LCD 1602的显示控制（Keil+Proteus）_1602液晶显示电路在keli中名称-CSDN博客https://blog.csdn.net/weixin_64066303/article/details/134224776
#include&lt;reg51.h&gt; #include&lt;intrins.h&gt;	//包含_nop_()空函数指令的头文件 #define uchar unsigned char #define uint unsigned int #define out P0 sbit RS=P2^0;//位变量 sbit RW=P2^1;//位变量 sbit E=P2^2;//位变量 //函数声明部分 void lcd_initial(void);//LCD初始化函数 void check_busy(void);//检查忙标志位函数 void write_command(uchar com);//写命令函数 void write_data(uchar dat);//写数据函数 void string(uchar ad,uchar *s);//显示字符串 void delay(uint);//延时 void print_LED();//输出“2024”的数码管 void main(void){ lcd_initial();//对LCD初始化 while(1){ print_LED(); string(0x81,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5caa9824275d72089846372df7ae6500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f1f7d97412027f08eb1b105f7481c2/" rel="bookmark">
			病情聊天机器人，利用Neo4j图数据库和Elasticsearch全文搜索引擎相结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目设计目的：
本项目旨在开发一个病情聊天机器人，利用Neo4j图数据库和Elasticsearch全文搜索引擎相结合，实现对病情相关数据的存储、查询和自动回答。通过与用户的交互，机器人可以根据用户提供的症状描述，给出初步的可能诊断和建议，并提供推荐的医生或医院信息。
功能需求：
用户输入症状描述，机器人根据症状查询数据库，返回可能的诊断结果。根据诊断结果，机器人提供相应的建议和治疗方案。提供医生和医院的推荐信息，包括专长、资质和患者评价等。支持用户提问和机器人解答的对话交互。支持用户对机器人回答的评价和反馈。 表结构设计：
User Chat datetime timestamp string input_text string output_text Symptom string name string description Disease string name string description Doctor string name string specialization string qualification Hospital string name string address string rating has 对应的表结构设计如下：
User 表：
id: 主键，自动生成的唯一标识符username: 用户名 Symptom 表：
id: 主键，自动生成的唯一标识符name: 症状名称description: 症状描述 Disease 表：
id: 主键，自动生成的唯一标识符name: 疾病名称description: 疾病描述 Doctor 表：
id: 主键，自动生成的唯一标识符name: 医生姓名specialization: 专长qualification: 资质 Hospital 表：
id: 主键，自动生成的唯一标识符name: 医院名称address: 医院地址rating: 患者评分 Chat 表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f1f7d97412027f08eb1b105f7481c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021adb777bccd570cd2387f2b26d9f72/" rel="bookmark">
			Spring通信传参的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring通信传参的方法 目录概述需求： 设计思路实现思路分析1.简单参数传递2.复合参数3.动态参数 参考资料和推荐阅读 Survive by day and develop by night.
talk for import biz , show your perfect code,full busy，skip hardness,make a better result,wait for change,challenge Survive.
happy for hardess to solve denpendies.
目录 概述 接口传参的是一个非常常见的需求。
需求： 设计思路 实现思路分析 1.简单参数传递 postman 前后端联调典型接口联调总结 这篇写的Blog已经定义写了部分传参的方式，主要是基于静态的参数传递，主要包含的基本数据类型和对象数据类型的传参等。
Spring MVC支持动态参数的方式有很多种，以下是其中的一些常见方式：
路径参数（Path Parameters）：可以在请求URL中使用占位符来表示参数，例如/users/{id}，其中{id}就是一个路径参数。在控制器方法中可以使用@PathVariable注解来获取路径参数的值。
查询参数（Query Parameters）：可以在请求URL中使用?符号后面的参数来表示查询参数，例如/users?id=1&amp;name=John，其中id和name就是查询参数。在控制器方法中可以使用@RequestParam注解来获取查询参数的值。
请求体参数（Request Body Parameters）：可以通过HTTP请求的请求体中传递参数。在控制器方法中可以使用@RequestBody注解来获取请求体的参数，通常用于处理复杂的数据结构或对象。
表单参数（Form Parameters）：可以通过HTTP请求的请求体中发送表单数据。在控制器方法中可以使用@RequestParam注解来获取表单参数的值，也可以使用@ModelAttribute注解来绑定表单数据到对象。
请求头参数（Request Header Parameters）：可以通过HTTP请求的请求头中传递参数。在控制器方法中可以使用@RequestHeader注解来获取请求头参数的值。
这些方式可以根据实际需要灵活组合和使用，以满足不同的业务需求。
2.复合参数 复合参数是什么意思呢？ 是各个数据类型是不同的，
一般的实现方案是定义一个类，添加对应的复合参数的集合去模拟参数传递即可
Spring MVC支持复合参数的方式有以下几种：
使用Java Bean作为参数：可以将多个参数封装到一个Java Bean中，然后将该Bean作为参数传递给Controller方法。在Controller方法中可以直接使用该Bean的属性来获取参数值。 public class User { private String name; private int age; // getters and setters } @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/021adb777bccd570cd2387f2b26d9f72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15394a259e0770b1885280d8aed10bc9/" rel="bookmark">
			Java并发编程（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ThreadLocal 1.ThreadLocal是什么 ThreadLocal 类让每一个线程都拥有了自己的本地变量，这意味着每个线程都可以独立地、安全地操作这些变量，而不会影响其他线程。
ThreadLocal的常用API
get()：获取当前线程中与ThreadLocal对象关联的变量副本。
set(T value)：将指定的值设置为当前线程中与ThreadLocal对象关联的变量副本。
remove()：删除当前线程中与ThreadLocal对象关联的变量副本。这样可以避免内存泄漏问题。注意，remove()方法只会删除当前线程中的变量副本，不会影响其他线程中的副本。
initialValue()：当调用get()或set()方法时，如果当前线程没有与ThreadLocal对象关联的变量副本，则会调用initialValue()方法创建一个新的变量副本并与当前线程关联。默认情况下，initialValue()方法返回null，可以通过继承ThreadLocal类并重写initialValue()方法来自定义初始化值。
2.ThreadLocal原理了解吗？ 从 Thread 类源代码入手。
public class Thread implements Runnable { //...... //与此线程有关的ThreadLocal值。由ThreadLocal类维护 ThreadLocal.ThreadLocalMap threadLocals = null; //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护 ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; //...... } 从上面 Thread 类中可以看出 Thread 类中有一个 threadLocals 和一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量。默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set 或 get 方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap 类对应的 get、set 方法。
ThreadLocal 类的 set 方法
public void set(T value) { //获取当前请求的线程 Thread t = Thread.currentThread(); //取出 Thread 类内部的 threadLocals 变量(哈希表结构) ThreadLocalMap map = getMap(t); if (map !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15394a259e0770b1885280d8aed10bc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5973686dcd45c297ae4e71c87493d3b/" rel="bookmark">
			SpringBoot解决前后端分离跨域问题：状态码403拒绝访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在写和同学一起做一个前后端分离的项目，今日开始对接口准备进行 登录注册 的时候发现前端在发起请求后，抓包发现后端返回了一个403的错误，解决了很久发现是【跨域问题】，第一次遇到，便作此记录✍
异常描述 在后端服务器启动后，前端页面也起了起来，然后点击这个【登录】按钮准备向后端发起POST请求时却没有任何的反应，便觉得很疑惑
于是来到后端的控制台观察是否有什么异常，但是也发现并没有任何的异常Exception显示出来，就觉得很奇怪(・∀・(・∀・(・∀・*) 抓包排查 那么这个时候：提升自己的机会就又来了，我便准备去查看网页控制台并抓包进行观察
再次打开这个网页发送请求的时候便发现，出现了两个 url，仔细观察发现端口号是不一样的，一个是我服务器启动的端口，为8080，另一个呢问了前端的同学说是它占用的这个端口号，为5173那么两个端口号都不一致前端发起请求后端无法接受到确实是可以解释得通的 接着仔细查看这里的英文便可以看到前面的这个localhost:5173已经被 CORS策略 给拒绝了，说：不存在“Access Control Allow Origin”这样的标头，那读到这里我又可以进一步断定应该是【访问被拒绝】了，但是还无法做出完全的肯定 此时我又去进行抓包确认，连着点了三次登录按钮，并通过【Fiddler】进行抓包便可以观察到很醒目的三个403，那么清楚HTTP协议的状态码的同学便可以清楚 【403状态码】：表示访问被拒绝，有的页面通常需要用户具有一定的权限才能访问(登陆后才能访问)
例如:：查看码云的私有仓库, 如果不登陆, 就会出现403
Spring Boot解决跨域问题 那么此时，我们便可以在后端通过SpringBoot去写一个配置文件，以指定哪个端口是可以进行跨域访问的
以下是相关的代码，只需要在config包（一般放配置文件）下添加一个这样的类即可，因为它是有关一些配置，所以要加上@Configuration注解 package com.example.demo.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; @Configuration public class MyCorsConfig { @Bean public CorsFilter corsFilter() { CorsConfiguration configuration = new CorsConfiguration(); configuration.addAllowedOrigin(http"://localhost:5173"); // 允许谁跨域 configuration.setAllowCredentials(true); // 传cookie configuration.addAllowedMethod("*"); // 允许哪些方法跨域 post/get configuration.addAllowedHeader("*"); // 允许哪些头信息 UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5973686dcd45c297ae4e71c87493d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff363802c8c327e396c0e7c6b4f1f83e/" rel="bookmark">
			关于MySQL Cluster
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.MySQL Cluster2.MySQL Cluster架构3.MySQL Cluster 与 MySQL 主从架构有什么区别4.参考 MySQL Cluster是MySQL的一个高可用性，高性能的分布式数据库解决方案。它结合了内存数据库和共享无状态架构的技术，提供了99.999%的可用性，满足严格的高可用性需求。
1.MySQL Cluster MySQL Cluster是一个高可用性，高性能的分布式数据库解决方案，其主要特点包括：
高可用性：MySQL Cluster通过数据的自动分区（分片）和实时复制，可以提供高达99.999%的可用性，满足严格的高可用性需求。高性能：MySQL Cluster使用内存存储数据，可以提供高速的读写性能。并且，通过自动分区，可以在多个节点上并行处理查询，进一步提高性能。线性可扩展性：可以通过添加更多的节点来扩展MySQL Cluster的处理能力，支持在线添加节点，无需停机。数据持久性：虽然MySQL Cluster主要在内存中存储数据，但它也支持将数据持久化到磁盘，以防止数据丢失。多地理位置复制：MySQL Cluster支持在多个地理位置之间复制数据，以提供灾难恢复能力。支持SQL和NoSQL：MySQL Cluster支持通过SQL和NoSQL两种方式访问数据，提供了灵活性和性能。 总的来说，MySQL Cluster是一个适合需要高可用性和高性能的应用的数据库解决方案。
2.MySQL Cluster架构 3.MySQL Cluster 与 MySQL 主从架构有什么区别 MySQL Cluster和MySQL主从架构都是MySQL的高可用性解决方案，但它们在设计和使用上有一些重要的区别：
数据分布：在MySQL Cluster中，数据被自动分片（分区）并在多个节点上存储，每个节点都可以处理查询和事务。而在MySQL主从架构中，主服务器处理所有的写操作，从服务器复制主服务器的数据并处理读操作。可用性：MySQL Cluster可以提供高达99.999%的可用性，因为它使用了数据的实时复制和自动故障转移。而在MySQL主从架构中，如果主服务器出现故障，需要手动或通过第三方工具进行故障转移。写入性能：在MySQL Cluster中，由于数据被分布在多个节点上，所以可以并行处理写操作，提供更高的写入性能。而在MySQL主从架构中，所有的写操作都需要在主服务器上进行，可能会成为性能瓶颈。数据一致性：MySQL Cluster提供了同步复制，可以确保所有节点上的数据始终保持一致。而在MySQL主从架构中，数据复制是异步的，可能会出现主从数据不一致的情况。复杂性：MySQL Cluster的架构和管理相对复杂，需要更多的硬件资源。而MySQL主从架构相对简单，易于设置和管理。 总的来说，MySQL Cluster和MySQL主从架构各有优势，适用于不同的场景。你应该根据你的具体需求和资源来选择最适合你的解决方案。
4.参考 MySQL Cluster文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd997934827ec4b863fb603f41d41ea/" rel="bookmark">
			2023年中国航天发射列表（全年67发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 序号
有效载荷发射时间火箭型号发射场状态1 实践二十三号
2023-1-9/6:00CZ-7A文昌成功2科技壹号/天启星座13星/天目一号气象星座01/02/南通中学号2023-1-9/13:04谷神星一号酒泉成功3亚太6E2023-1-13/2:10CZ-2C西昌成功4遥感三十七号/试验二十二号A/B2023-1-13/15:00CZ-2D酒泉成功5齐鲁二号、齐鲁三号等14星2023-1-15/11:14CZ-2D太原成功6中星26号2023-2-23/19:49CZ-3B西昌成功7荷鲁斯1号2023-2-24/12:01CZ-2C酒泉成功8天绘六号A/B2023-3-10/6:41CZ-4C太原成功9荷鲁斯2号2023-3-13/12:02CZ-2C酒泉成功10试验十九号2023-3-15/19:41CZ-11酒泉成功11高分十三号02星2023-3-17/16:33CZ-3B西昌成功12天目一号03-06星2023-3-22/17:09KZ-1A酒泉成功13宏图一号01组2023-3-30/18:50CZ-2D太原成功14遥感三十四号04星2023-3-31/14:27CZ-4C酒泉成功15爱太空科学号2023-4-2/16:48天龙二号酒泉成功16测试载荷2023-4-7/12:00双曲线一号酒泉成功17风云三号07星2023-4-16/9:36CZ-4B酒泉成功18天舟六号2023-5-10/21:22CZ-7西昌成功19北斗导航第56颗(GEO)2023-5-17/10:49CZ-3B西昌成功20澳门科学一号A/B，珞珈二号01星2023-5-21/16:00CZ-2C酒泉成功21神州十六号2023-5-30/9:31CZ-2F酒泉成功22 试验二十四号a星、b星等26颗卫星
2023-6-7/12:10ZK-1A酒泉成功23平板式新体制通信试验卫星“龙江三号”2023-6-9/10:35KZ-1A酒泉成功24吉林一号高分06A等41星2023-6-15/13:30CZ-2D太原成功25试验二十五号2023-6-20/11:18CZ-6太原成功26互联网技术试验卫星2023-7-9/19:0CZ-2C酒泉成功27无载荷2023-7-12/9:0朱雀二号酒泉成功28天目一号气象星座07-10星2023-7-20/11:20KZ-1A酒泉成功29星时代16，乾坤一号2023-7-22/13:07谷神星一号酒泉成功30四象01~03 星、银河航天灵犀03星2023-7-23/10:50CZ-2D太原成功31遥感三十六号3星2023-7-27/4:02CZ-2D西昌成功32风云三号F星2023-8-3/11:47CZ-4C酒泉成功33环境减灾二号06星2023-8-9/6:53CZ-2C太原成功34西光壹号01,星池一号B,地卫智能应急一号,西安航投88/96/104/1122023-8-10/12:03谷神星一号酒泉成功35陆地探测四号01星2023-8-13/1:26CZ-3B西昌成功36和德三号A~E星2023-8-14/13:32KZ-1A西昌成功37高分十二号04星2023-8-21/1:45CZ-4C酒泉成功38吉林一号宽幅02A2023-8-25/12:59谷神星一号酒泉成功39遥感三十九A~C2023-8-31/15:36CZ-2D西昌成功40天启星座21-24号2023-9-5/17:34谷神星一号海阳海上平台成功41遥感三十三03星2023-9-7/2:14CZ-4C酒泉成功42遥感四十A/B/C2023-9-10/12:30CZ-6太原成功43遥感三十九02A~C2023-9-17/12:13CZ-2D西昌成功44吉林一号高分04B2023-9-21/12:59谷神星一号酒泉失败45遥感三十三042023-9-27/4:15CZ-4C酒泉成功46遥感三十九03A~C2023-10-5/8:24CZ-2D西昌成功47云海一号04星2023-10-15/8:54CZ-2D酒泉成功48遥感三十九号04A~C2023-10-24/4:03CZ-2D西昌成功49神州十七号2023-10-26/11:14CZ-2F酒泉成功50天绘五号2023-11-1/6:50CZ-6A太原成功51通信技术试验卫星十号2023-11-3/22:54CZ-7A文昌成功52中星6E2023-11-9/19:23CZ-3B西昌成功53海洋水色观测卫星 01 星2023-11-16/11:55CZ-2C酒泉成功54卫星互联网技术试验卫星2023-11-23/18:00CZ-2D西昌成功55埃及二号卫星/星池一号第二组A/B星2023-12-4/12:10CZ-2C酒泉成功56天雁16星/星池一号A星2023-12-5/7:33谷神星一号酒泉成功57卫星互联网技术试验卫星2023-12-6/3:24捷龙三号阳江海上平台成功58鸿鹄卫星/天仪33卫星/鸿鹄二号卫星2023-12-9/7:39朱雀二号酒泉成功59遥感三十九号05A~C2023-12-10/9:58CZ-2D西昌成功60可重复使用试验航天器2023-12-14/22:04CZ-2F酒泉成功61遥感四十一号2023-12-15/21:43CZ-5文昌成功62迪迩一号2023-12-17/15:00双曲线一号酒泉成功63天目一号气象星座11~14星2023-12-25/9:00KZ-1A酒泉成功64试验二十四号C卫星(3颗)2023-12-26/6:39CZ-11阳江海上平台成功65北斗MEO(57/58)2023-12-26/11:26CZ-3B西昌成功66天目一号气象星座19~22星2023-12-27/14:50KZ-1A酒泉成功67互联网技术试验卫星2023-12-30/8:13CZ-2C酒泉成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7349d702bb778d74fff4e7992cbc9cc1/" rel="bookmark">
			【MyBatis】操作数据库——入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为什么要学习MyBatis什么是MyBatisMyBatis 入门创建带有MyBatis框架的SpringBoot项目数据准备在配置文件中配置数据库相关信息实现持久层代码单元测试 为什么要学习MyBatis 前面我们肯定多多少少学过 sql 语言，sql 语言是一种操作数据库的一类语言，数据库是保证数据能够持久化存储的一种集合。在众多 sql 语言中，MySQL就是其中一种，并且是人们使用较多的一种 sql 语言，而就是因为 MySQL 使用较简单，使用的人较多，所以就出现了 JDBC 编程，也就是 Java 的一个 API，可以让我们通过 Java 代码来操作我们的数据库，但是呢？JDBC 编程的操作太复杂了，为什么会说 JDBC 操作复杂呢？看下面这段代码。
package com.example.mybatis20231226.Dao; import javax.sql.DataSource; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.SQLException; public class UserDao { DataSource dataSource = null; public UserDao(DataSource dataSource) { this.dataSource = dataSource; } public void addUser() throws SQLException { Connection connection = null; PreparedStatement statement = null; try { connection = dataSource.getConnection(); String sql = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7349d702bb778d74fff4e7992cbc9cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0df33847f3a1c57aa1a9f40ce01a1be/" rel="bookmark">
			【深度学习：Recurrent Neural Networks】循环神经网络（RNN）的简要概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【深度学习】循环神经网络（RNN）：连接过去与未来的桥梁 循环神经网络简介什么是循环神经网络 (RNN)？传统 RNN 的架构循环神经网络如何工作？常用激活函数RNN的优点和缺点RNN 的优点：RNN 的缺点： 循环神经网络与前馈神经网络随时间反向传播 (BPTT)标准 RNN 的两个问题RNN 应用基本 Python 实现（RNN 与 Keras）经常问的问题结论 苹果的Siri和谷歌的语音搜索都使用递归神经网络（RNN），这是最先进的顺序数据方法。这是第一个具有内部存储器的算法，可以记住其输入，使其非常适合机器学习中涉及顺序数据的问题。它是在过去几年中导致深度学习取得惊人进步的算法之一。在本文中，我们将介绍递归神经网络的基础知识，以及最紧迫的困难以及如何解决它们。
循环神经网络简介 用于对顺序数据进行建模的深度学习方法是循环神经网络 （RNN）。在注意力模型出现之前，RNN是处理顺序数据的标准建议。深度前馈模型可能需要序列中每个元素的特定参数。它也可能无法泛化为可变长度序列。
递归神经网络对序列的每个元素使用相同的权重，从而减少了参数的数量，并允许模型泛化为不同长度的序列。由于其设计，RNN 泛化到序列数据以外的结构化数据，例如地理或图形数据。
与许多其他深度学习技术一样，循环神经网络相对较旧。它们最初是在 20 世纪 80 年代开发的，但直到最近我们才充分认识到它们的潜力。 20 世纪 90 年代长短期记忆 (LSTM) 的出现，加上计算能力的提高和我们现在必须处理的大量数据，确实将 RNN 推到了最前沿。
什么是循环神经网络 (RNN)？ 神经网络在人工智能、机器学习和深度学习领域模仿人脑的功能，使计算机程序能够识别模式并解决常见问题。
RNN 是一种可用于对序列数据建模的神经网络。 RNN 由前馈网络组成，其行为与人脑相似。简而言之，循环神经网络可以以其他算法无法做到的方式预测顺序数据。
标准神经网络中的所有输入和输出都是相互独立的，但是在某些情况下，例如在预测短语的下一个单词时，前面的单词是必要的，因此必须记住前面的单词。结果，RNN 应运而生，它使用隐藏层来克服这个问题。 RNN 最重要的组成部分是隐藏状态，它记住有关序列的特定信息。
RNN 有一个内存，用于存储有关计算的所有信息。它对每个输入采用相同的设置，因为它通过在所有输入或隐藏层上执行相同的任务来产生相同的结果。
传统 RNN 的架构 RNN 是一种具有隐藏状态并允许将过去的输出用作输入的神经网络。他们通常是这样的：
RNN 架构可能会根据您要解决的问题而有所不同。从具有单个输入和输出的那些到具有多个输入和输出的那些（之间存在差异）。
下面是一些 RNN 架构的示例，可以帮助您更好地理解这一点。
一对一：这里只有一对。传统神经网络使用一对一架构。 一对多：一对多网络中的单个输入可能会产生大量输出。例如，在音乐制作中使用了太多的网络。多对一：在这种情况下，单个输出是通过组合来自不同时间步骤的多个输入来生成的。情感分析和情绪识别使用这样的网络，其中类别标签由单词序列确定。多对多：对于多对多，有多种选择。两个输入产生三个输出。机器翻译系统，例如英语到法语的翻译系统，反之亦然，使用多对多网络。 循环神经网络如何工作？ 循环神经网络中的信息通过循环循环到中间隐藏层。
输入层 x 接收并处理神经网络的输入，然后将其传递到中间层。
中间层 h 可以找到多个隐藏层，每个隐藏层都有自己的激活函数、权重和偏差。如果不同隐藏层的各种参数不受前一层的影响，即神经网络中没有记忆，则可以使用循环神经网络。
不同的激活函数、权重和偏差将由循环神经网络标准化，确保每个隐藏层具有相同的特征。它不会构建大量隐藏层，而是仅创建一个隐藏层并根据需要循环多次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0df33847f3a1c57aa1a9f40ce01a1be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e30e6ed0c54e788758a5af3e78fb40b/" rel="bookmark">
			认识数据挖掘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数据库技术的迅速发展及数据库管理系统的广泛应用，人们积累的数据越来越多。激增的数据背后隐藏着许多重要的信息，人们希望能够对其进行更高层次的分析，以便更好地利用这些数据。目前的数据库系统可以高效地实现数据的录入、查询、统计等功能，但无法发现数据中存在的关系和规则，无法根据现有的数据预测未来的发展趋势。缺乏挖掘数据背后隐藏的知识的手段，导致了“数据爆炸但知识贫乏”的现象。
一、数据挖掘的概念
数据挖掘（Data Mining）技术是人们长期对数据库技术进行研究和开发的结果。起初各种商业数据是存储在计算机的数据库中的，然后发展到可对数据库进行查询和访问，进而发展到对数据库的即时遍历。数据挖掘使数据库技术进入了一个更高级的阶段，它不仅能对过去的数据进行查询和遍历，并且能够找出过去数据之间的潜在联系，从而促进信息的传递。现在数据挖掘技术在商业应用中已经可以马上投入使用，因为对这种技术进行支持的三种基础技术已经发展成熟，它们是海量数据搜集、强大的多处理器计算机和数据挖掘算法。
从技术角度来看，数据挖掘就是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中，提取隐含在其中的、人们事先不知道的、但又是潜在有用的信息和知识的过程。这个定义包括好几层含义：数据源必须是真实的、大量的、含噪声的；发现的是用户感兴趣的知识；发现的知识要可接受、可理解、可运用；并不要求发现放之四海而皆准的知识，仅支持特定的发现问题。
还有很多和这一术语相近的术语，如从数据库中发现知识、数据分析、数据融合（Data Fusion），以及决策支持等。
何为知识？从广义上理解，数据、信息也是知识的表现形式，但是人们更把概念、规则、模式、规律和约束等看做知识。原始数据可以是结构化的，如关系数据库中的数据；也可以是半结构化的，如文本、图形和图像数据；甚至是分布在网络上的异构型数据。发
现知识的方法可以是数学的，也可以是非数学的；可以是演绎的，也可以是归纳的。发现的知识可以被用于信息管理，查询优化，决策支持和过程控制等，还可以用于数据自身的维护。因此，数据挖掘是一门交叉学科，它把人们对数据的应用从低层次的简单查询，提升到从数据中挖掘知识，提供决策支持。在这种需求牵引下，汇聚了不同领域的研究者，尤其是数据库技术、人工智能技术、数理统计、可视化技术、并行计算等方面的学者和工程技术人员，投身到数据挖掘这一新兴的研究领域，形成新的技术热点。
从商业角度来看，数据挖掘是一种新的商业信息处理技术，其主要特点是对商业数据库中的大量业务数据进行抽取、转换、分析和其他模型化处理，从中提取辅助商业决策的关键性数据。
简而言之，数据挖掘其实是一种深层次的数据分析方法。数据分析本身已经有很多年的历史，只不过在过去数据收集和分析的目的是用于科学研究，另外，由于当时计算能力的限制，对大量数据进行分析的复杂数据分析方法受到很大限制。现在，由于各行业业务自动化的实现，商业领域产生了大量的业务数据，这些数据不再是为了分析的目的而收集，而是由于纯机会的商业运作而产生。分析这些数据也不再是单纯为了研究的需要，更主要是为商业决策提供真正有价值的信息，进而获得利润。但所有企业面临的一个共同问题是：企业数据量非常大，而其中真正有价值的信息却很少，因此从大量的数据中通过深层分析，获得有利于商业运作、提高竞争力的信息，就像从矿石中淘金一样，数据挖掘也因此而得名。
因此，数据挖掘可以描述为：按企业既定业务目标，对大量的企业数据进行探索和分析，揭示隐藏的、未知的或验证已知的规律性，并进一步将其模型化的先进有效的方法。
数据挖掘与传统的数据分析（如查询、报表、联机应用分析）的本质区别是数据挖掘是在没有明确假设的前提下去挖掘信息、发现知识。数据挖掘所得到的信息应具有先知，有效和可实用三个特征。
先前未知的信息是指该信息是预先未曾预料到的，即数据挖掘是要发现那些不能靠直觉发现的信息或知识，甚至是违背直觉的信息或知识，挖掘出的信息越是出乎意料，就可能越有价值。在商业应用中最典型的例子就是一家连锁店通过数据挖掘发现了小孩纸尿布和啤酒之间有着惊人的联系。
特别要指出的是，数据挖掘技术从一开始就是面向应用的。它不仅是面向特定数据库的简单检索查询调用，而且要对这些数据进行微观、中观乃至宏观的统计、分析、综合和推理，以指导实际问题的求解，企图发现事件间的相互关联，甚至利用已有的数据对未来的活动进行预测。例如，加拿大 BC 省电话公司要求加拿大 Simon Fraser 大学知识发现研究组，根据其拥有十多年的客户数据，总结、分析并提出新的电话收费和管理办法，制定既有利于公司又有利于客户的优惠政策。这样一来，就把人们对数据的应用，从低层次的末端查询操作，提高到为各级经营决策者提供决策支持。这种需求驱动力比数据库查询更为强大。
二、数据挖掘的功能
数据挖掘通过预测未来趋势及行为，做出前摄的、基于知识的决策。数据挖掘的目标是从数据库中发现隐含的、有意义的知识，主要有以下五类功能。
1．自动预测趋势和行为数据挖掘自动在大型数据库中寻找预测性信息，以往需要进行大量手工分析的问题如今可以迅速直接由数据本身得出结论。一个典型的例子是市场预测问题，数据挖掘使用过去有关促销的数据来寻找未来投资中回报最大的用户，其他可预测的问题包括预报破产及认定对指定事件最可能做出反应的群体。
2．关联分析数据关联是数据库中存在的一类重要的可被发现的知识。若两个或多个变量的取值之间存在某种规律性，就称为关联。关联可分为简单关联、时序关联、因果关联。关联分析的目的是找出数据库中隐藏的关联网。有时并不知道数据库中数据的关联函数，即使知道也是不确定的，因此关联分析生成的规则带有可信度。
3．聚类数据库中的记录可被划分为一系列有意义的子集，即聚类。聚类增强了人们对客观现实的认识，是概念描述和偏差分析的先决条件。聚类技术主要包括传统的模式识别方法和数学分类学。20 世纪 80 年代初，Mchalski 提出了概念聚类技术及其要点，即在划分对象时不仅要考虑对象之间的距离，还要求划分出的类具有某种内涵描述，从而避免了传统技术的某些片面性。
4．概念描述概念描述就是对某类对象的内涵进行描述，并概括这类对象的有关特征。概念描述分为特征性描述和区别性描述，前者描述某类对象的共同特征，后者描述不同类对象之间的区别。生成一个类的特征性描述只涉及该类对象中所有对象的共性。生成区别性描述的方法很多，如决策树方法、遗传算法等。
5．偏差检测数据库中的数据常有一些异常记录，从数据库中检测这些偏差很有意义。偏差包括很多潜在的知识，如分类中的反常实例、不满足规则的特例、观测结果与模型预测值的偏差、量值随时间的变化等。偏差检测的基本方法是，寻找观测结果与参照值之间有意义的差别。
三、数据挖掘常用技术
常用的数据挖掘技术包括关联分析、序列分析、分类、预测、聚类分析及时间序列分析等。
1．关联分析
关联分析主要用于发现不同事件之间的关联性，即一个事件发生的同时，另一个事件也经常发生。关联分析的重点在于快速发现那些有实用价值的关联发生的事件。其主要依据是事件发生的概率和条件概率应该符合一定的统计意义。
对于结构化的数据，以客户的购买习惯数据为例，利用关联分析，可以发现客户的关联购买需要。例如，一个开设储蓄账户的客户很可能同时进行债券交易和股票交易，购买纸尿裤的男顾客经常同时购买啤酒等。利用这种知识可以采取积极的营销策略，扩展客户购买的产品范围，吸引更多的客户。通过调整商品的布局便于顾客买到经常同时购买的商品，或者通过降低一种商品的价格来促进另一种商品的销售等。
对于非结构化的数据，以空间数据为例，利用关联分析，可以发现地理位置的关联性。例如，85%的靠近高速公路的大城镇与水相邻，或者发现通常与高尔夫球场相邻的对象等。
2．序列分析
序列分析技术主要用于发现一定时间间隔内接连发生的事件。这些事件构成一个序列，发现的序列应该具有普遍意义，其依据除了统计上的概率之外，还要加上时间的约束。
3．分类分析
分类分析通过分析具有类别的样本的特点，得到决定样本属于各种类别的规则或方法。利用这些规则和方法对未知类别的样本分类时应该具有一定的准确度。其主要方法有基于统计学的贝叶斯方法、神经网络方法、决策树方法及支持向量机（support vector machines）等。
利用分类技术，可以根据顾客的消费水平和基本特征对顾客进行分类，找出对商家有较大利益贡献的重要客户的特征，通过对其进行个性化服务，提高他们的忠诚度。
利用分类技术，可以将大量的半结构化的文本数据，如 WEB 页面、电子邮件等进行分类。可以将图片进行分类，例如，根据已有图片的特点和类别，可以判定一幅图片属于何种类型的规则。对于空间数据，也可以进行分类分析，例如，可以根据房屋的地理位置决定房屋的档次。
4．聚类分析
聚类分析是根据物以类聚的原理，将本身没有类别的样本聚集成不同的组，并且对每一个这样的组进行描述的过程。其主要依据是聚到同一个组中的样本应该彼此相似，而属于不同组的样本应该足够不相似。
仍以客户关系管理为例，利用聚类技术，根据客户的个人特征及消费数据，可以将客户群体进行细分。例如，可以得到这样的一个消费群体：女性占 91%，全部无子女、年龄在 31 岁到 40 岁占 70%，高消费级别的占 64%，买过针织品的占 91%，买过厨房用品的占89%，买过园艺用品的占 79%。针对不同的客户群，可以实施不同的营销和服务方式，从而提高客户的满意度。
对于空间数据，根据地理位置及障碍物的存在情况可以自动进行区域划分。例如，根据分布在不同地理位置的 ATM 机的情况将居民进行区域划分，根据这一信息，可以有效地进行 ATM 机的设置规划，避免浪费，同时也避免失掉每一个商机。
对于文本数据，利用聚类技术可以根据文档的内容自动划分类别，从而便于文本的检索。
5．预测
预测与分类类似，但预测是根据样本的已知特征估算某个连续类型的变量的取值的过程，而分类则只是用于判别样本所属的离散类别而已。预测常用的技术是回归分析。
6．时间序列
分析时间序列分析的是随时间而变化的事件序列，目的是预测未来发展趋势，或者寻找相似发展模式或者是发现周期性发展规律。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e30e6ed0c54e788758a5af3e78fb40b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e76e8073b7aef59c32f5de2ab8755a3/" rel="bookmark">
			基于Matlab的各种图像滤波Filter算法（代码开源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文为手把手教学 Matlab 平台下的各种图像滤波算法的教程，将编程代码与图像滤波知识相联系，以实战为例！博客中图像滤波算法包含：均值滤波、中值滤波、高斯滤波、双边滤波、引导滤波。图像滤波算法是计算机视觉领域CV必修课，被广泛运用于各行各业，尤其是科研领域！希望本篇博客能给读者朋友的工程项目或科研生活给予些许帮助。（篇末代码开源！）
图像滤波算法总图：
一、图像滤波知识 1.1 基本概念 图像滤波是一种常见的图像处理技术，旨在抑制图像中的噪声，并在尽量保留图像细节特征的条件下改善图像质量。该技术是图像预处理中非常重要的步骤，将直接影响后续的图像数据挖掘与分析性能（例如：目标检测，目标分割与去雾去雨算法等）！其实如今大火的卷积神经网络 CNN 其实也是滤波的一种，都是用卷积核去提取图像的特征模式。不过传统的滤波，使用的卷积核是固定的参数，是由经验丰富的人去手动设计的，也称为手工特征。而卷积神经网络的卷积核参数是未知的，是根据不同的任务由数据驱动去学习得到的参数，更能适应于不同的任务。作者补充：卷积是图像算法中很重要的知识点，读者朋友一定需要熟练掌握!
1.2 图像噪声 在数字图像处理中，由于成像系统、传输介质和记录设备等的不完善，数字图像在其形成、传输和记录过程中往往会受到多种噪声的污染。这些噪声在图像上常表现为一些孤立像素点或像素块，它们以无用的信息形式出现，扰乱了图像的可观测信息。因此，图像滤波核心目的是消除这些噪声，以便更好地提取出图像的特征。
★常见的图像噪声分类：（1）椒盐噪声；（2）高斯噪声；（3）泊松噪声
1.2.1 椒盐噪声 椒盐噪声(salt-and-pepper noise)又称脉冲噪声，它随机改变一些像素值，在二值图像上表现为使一些像素点变白，一些像素点变黑。 是由图像传感器，传输信道，解码处理等产生的黑白相间的亮暗点噪声，也就是老人们比较熟悉的所谓“雪花”。作者补充：RGB图像上的椒盐噪声也可以为红绿蓝（RGB）的像素点。
matlab代码：
%%椒盐噪声 close all; clear all; clc; I=imread('test.png'); I=im2double(I); % J = imnoise(I,‘salt &amp; pepper’,d),默认d=0.05 % 在添加类型为Salt &amp; Pepper的噪声时,符号&amp;的前面和后面必须有空格,否则系统会出错 J=imnoise(I,'salt &amp; pepper',0.01); K=imnoise(I,'salt &amp; pepper',0.05); % 图像中黑色的像素点为椒盐噪声,白色的像素点为盐噪声 subplot(131),imshow(I); subplot(132),imshow(J); subplot(133),imshow(K); 1.2.2 高斯噪声 高斯噪声是一种源于电子电路噪声和由低照明度或高温带来的传感器噪声。高斯噪声又称为正态噪声，是自然界中最常见的噪声。高斯噪声可以通过平滑滤波技术或图像复原技术来消除。
matlab代码：
%%高斯滤波 close all; clear all; clc; I=imread('test1.jpg'); h=0:0.1:1; % h为在[0,1]之间的向量,表示图像的亮度值 v=0.01:-0.001:0; % v为一个长度和h相同,表示与h中亮度对应的高斯噪声的方差 % J=imnoise(I,'localvar',h,v)在图像的不同亮度值上叠加不同方差的高斯噪声,向量h中没有的亮度值将自动插值得到 J=imnoise(I,'localvar',h,v); subplot(121),imshow(I); subplot(122),imshow(J); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e76e8073b7aef59c32f5de2ab8755a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d18384859184cd13aa9eaa4820e8504/" rel="bookmark">
			QtitanRibbon 开始使用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建一个界面程序：
修改项目里面的源码：
至此，一个简单界面就出来了，效果如下所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978d3daaf62e472da5aa1bd9a8c32979/" rel="bookmark">
			Wargames与bash知识05
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wargames与bash知识05 Bandit Level 8 grep 常用选项：
-E 等同于egrep命令，支持扩展正则表达式
-i 忽略大小写
-v 取反。匹配结果的反集
正则表达式入门知识： 正则表达式主要依赖于元字符，元字符都有特殊的含义，一些元字符写在方括号中的时候有一些特殊的意思。 以下是一些元字符的介绍。
“^” 与 “$”，锚定符。”^"行首，如’^ABC’代表匹配以ABC开头的行；$行尾，如’ABC$',grep代表匹配以ABC结尾的行。
. 匹配任意一个字符，不包含换行。
[ ] 字符集，匹配[ ]中的任一字符。
[^ ] 字符集的补集，不包含在字符集中的任何一个字符。
量词：“？”、“+”、“*” 。量词的效果作用于它前面的单元，单元可以是单个字符或者字符串。如boo?k，匹配book、bok，?的作用是0出现0次或一次。
? 匹配前面单元0到1次
+ 匹配前面单元1到无数次
* 匹配前面单元0到无数次
{n,m}，中括号[ ]字符集的量词。如[gu]{1,3}：g或者u至少出现一次，最多出现三次。
{ ,m}是匹配前面单元0到m次 ，最多出现m次；
{n, }匹配前面单元n到无限次，最少出现n次。
(xyz)，小括号括起来的字符串为一个整体单元处理。正则处理文本是逐行逐个字符处理的，小括号作用是将字符串按一个整体处理。
| 或， (abc|xyz)匹配为abc或者xyz。
\ 转义元字符：[ ] ( ) { } . * + ? ^ $ \ |，使其去除特殊含义，恢复字面意义。
使用grep命令前有一些注意事项：
1、最好使用egrep或者grep -E以防止扩展正则未开启而造成的困扰。
2、正则表达式最好使用单引号 ’ 括起来，防止特殊符号被shell解释。
3、最好开启grep和egrep颜色显示。查看grep和egrep是否开启颜色显示，开启颜色匹配会用颜色标识出匹配项。
gyj@DESKTOP-S52KD5S:~/xue$ alias alias egrep='egrep --color=auto' alias fgrep='fgrep --color=auto' alias grep='grep --color=auto' 使用文本编辑器建立一个演示文件，内容如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/978d3daaf62e472da5aa1bd9a8c32979/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b951da076c26c99b25f6df7c29e09b3/" rel="bookmark">
			2021/11/11 idea设置和快捷键、idea打jar包、nsis工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这才是属于我的节日嘛，呜呜，┭┮﹏┭┮，节日快乐（快乐不起来啊）
idea目录文件 idea四层级结构 idea操作Java文件的基本单位：项目（Project）。对应四级结构
第1层级架构：项目（project）
在 IntelliJ IDEA 中Project是最顶级的结构单元，然后就是Module，一个Project可以有多个Module，模块之间彼此可以相互依赖
项目project包含： .idea文件夹（项目的配置文件） out文件夹（第2层级对应的所有字节码文件） 模块文件夹（第2层级架构） 第2层级架构：模块（moudle）
在一个项目中，每个模块都可以使用特定的SDK或继承在项目级别定义的SDK。
模块moudle包含： src文件夹（存储第3层级架构内容） 模块名.iml 文件(模块配置文件) 模块上右键-Open Module settiongs（可以新建模块，移除模块，导入模块） 第3层级架构：包（Package）
包的含义：多级文件夹
包的好处：1.对程序文件管理分类。2.有效避免重名的文件 包中包含：
java程序（第4层架构）
包的注意：如果程序在包中，必须在第4层架构进行包的声明
包的声明：
1.包名就是公司域名倒序+功能 如：com.atguigu.idea
2.格式：package 包名；
3.命名规范：
一个单词：单词全部小写（一般没有）
多个单词：使用.进行间隔，一个单词就是一级文件夹
第4层级架构：.java文件（类文件）
public class HelloWorld { public static void main(String[] args) { System.out.println("Helloworld"); } } .iml文件 .iml:配置信息之意， infomation of module
iml文件是idea自己创建的模块文件，用于java应用开发，存储一些模块相关的信息。每个模块都有一个iml文件。 .idea目录 .idea目录：存放项目的配置信息。包括数据源，类库，项目字符编码，历史记录，版本控制信息等
working dir目录 编辑配置
导入lib目录jar lib目录，很久很久以前。那时候还没有maven。。。那么就没有本地仓库，pom文件，gav这一说。此时是把jar包放在lib目录下。jar文件我们并不能进行查看，也不能使用。
idea怎么把lib下的jar引入呢？将jar正式添加到java的工具库中
方式一 选中lib文件夹，右键-Add as Library 就会出现下面的弹框了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b951da076c26c99b25f6df7c29e09b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80da8c3d400a39e0a32851fa575663ad/" rel="bookmark">
			深度学习核心技术与实践之计算机视觉篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非书中全部内容，只是写了些自认为有收获的部分
计算机视觉背景 （1）视觉皮层的神经元是一列一列组织起来的，每一列神经元只喜欢某一种特定的形状或者某些简单的线条组合，而不是鱼、老鼠、鲜花
（2）视觉的前期，并不是对鱼或老鼠进行整体识别，而是对简单的形状结构进行处理，这种简单的形状结构就是边缘
（3）视觉是分层的
（4）简单的3D摄像机就是用两个镜头，然后把图片叠加实现的。同样，对干语音问题，自然界的语音是重叠的，解决办法是用两只耳朵，在技术上就可以采用多个麦克风
（5）对人来说，很多遮挡并不是问题，比如看到部分虎纹就知道是老虎，这说明对视觉来说特征可能是最重要的。尺度不变特征变换算法认为只需要看到部分即可进行识别。而且就算整体上有些形变，具体特征也会保持不变
图像分类模型 LeNet-5 （1）对输入像素归一化：白色背景取值-0.1，黑色前景取值1.175，这样使得在MNIST数据集上像素点取值均值近似为0，方差近似为1
（2）每个C3层的特征图只与部分S2层的特征图进行连接。这样做有两个原因:
1.部分不完全的连接关系能将连接数控制在一个比较合理的范围内
2.更重要的是，它强制地打破了网络的对称性，不同的特征图由干输入不同而能够表达出不同的特征
（3）输出层由每个类别对应一个欧几里得RBF单元构成，每个RBF单元计算的是输入向量和参数向量w之间的欧式距离，输入向量与参数向量之间的距离越远，RBF单元的输出越大
AlexNet （1）AlexNet模型中间层分为两路，明确显示了两块GPU之间的职责划分——一块GPU运行图中顶部模型部分，而另一块GPU则运行图中底部模型部分。GPU之间仅在某些层互相通信。
（2）创新之处：
1.ReLU
2.多GPU训练：第三层卷积需要以第二层产生的所有特征图作为输入，而第四层卷积则只需要以第三层的特征图中处在同一块GPU的部分作为输入。选择层间特征图的连接关系是一个交叉验证问题，但这使得我们能够将通信量精准地调整到一个可接受的范围内
3.局部相应归一化：
4.重叠池化：有重叠的池化层相比传统池化层出现过拟合现象的问题也略有缓解
5.整体网络结构：第二、四、五个卷积层只连接到前一个卷积层中也位于同一块GPU上的那些特征图，第三个卷积层则连接着第二个卷积层中的所有特征图，全连接层中的神经元连接前一层所有的神经元。在第一和第二个卷积层后面各接了一个局部响应归一化层。在局部响应归一化层和第五个卷积层之后接的最大池化层采用了前文介绍的重叠池化方式。所有卷积层和全连接层都采用ReLU作为非线性激活函数
6.降低过拟合：
运用两种数据增强：裁剪和水平翻转、改变训练数据中RGB通道的强度(对整个ImageNet训练数据的RGB像素值做主成分分析)。后一种变换能够使网络近似地学习到自然物体识别中一个很重要的属性，即物体识别应该对光照强度和颜色保持不变性
使用Dropout。测试时将所有神经元输出x0.5来近似
VGGNet （1）VGGNet采用的卷积核感受野很小: 3x3；在其中一组配置中，VGGNet甚至采用了1x1的卷积核，这时卷积退化成为对输入的线性变换 (后面跟一个非线性单元)
（2）小卷积核代替大卷积核的好处：
1.用整合了的三个非线性激活层替代单一非线性激活层，增加了判别能力。
2.减少了网络参数。假设三个3x3的卷积层的输入输出都是C个通道，那么小结构中参数个数为3x(3C)² =27C²。类似地，一个7x7的卷积层则需要 7²C² =49C²个参数，多出了81%。也可以看作对7x7的卷积网络施加了某种正则化，使其能够分解成三个3x3的卷积层
3.使用尺寸为1x1的卷积层能够在不影响感受野的情况下，增加网络非线性判别能力。尽管在VGGNet中 1x1卷积实质上是在相同维度空间(输入输出通道数一致) 上的线性投影，但激活函数还是引入了额外的非线性能力
GoogLeNet （1）在 AlexNet 和 VGGNet 中全连接层占据 90%的参数量，而且容易引起过拟合；而GoogLeNet用全局平均池化层取代全连接层
（2）在传统的CNN中卷积层实质上是一种广义的线性模型，其表达和抽象能力不足；相比普通的卷积网络，MLP网络能够更好地拟合局部特征，也就是增强了输入局部的表达能力
（3）两个卷积层级联，如果统一增加卷积核数量，那么计算量的增大将与卷积核数的增加成平方关系
（4）如果用一个大型、稀疏的深度神经网络表示某数据集的概率分布，那么最优的网络拓扑可以通过逐层分析与之前神经元的统计相关，并将高相关性的神经元进行聚类得到。
Inception （1）Inception模块将稀疏矩阵聚成相对稠密的子矩阵能带来客观的性能提升
（2）Inception结构的主要思想是用便捷可得的密集原件去近以卷积视觉网络的最优局部稀疏结构。接下来需要做的就是找到一种最优的局部结构，重复这结构把它们拼接在一起组成网络
（3）Arora等人提出一种层与层的结构，在结构的最后一层进行相关性统计，将相关性高的单元聚集到一起。这些簇构成下一层的单元，与上一层的单元连接
（4）假设前面层的每个单元对应于输入图像的某些区域，这些单元被滤波器进行分组。低层(接近输入层)的单元集中在某些局部区域，这意味着最终会得到在单个区域的大量群，它们能在下一层通过 1x1卷积覆盖；然而，也可以通过一个簇覆盖更大的空间来减少的数量。为了避免patch-alignment问题，将滤波器大小限制在1x1、3x3 和 5x5(主要是为了方便，非必要)。在池化层添加一个备用的池化路径可以提高效率
（5）得益于Embedding技术的成功，即使低维度的Embedding也能包含相对大的图像区域中的丰富信息。然而，Embedding将信息表达为调密压缩的模式，处理起来更困难。我们期望的是在大部分地方保持稀疏，只在需要放大的位置产生稠密信号。于是，1x1卷积放置在计算昂贵的3x3和5x5卷积层前，用于减少计算量。1x1卷积不仅用来降维，还用来修正线性特征
后续版本改进 (1) Inception-v2在之前的版本中主要加入了Batch Normalization；另外也借鉴了VGGNet的思想，用两个3x3的卷积代替了5x5的卷积，不仅降低了训练参数，而且提升了速度。
(2) Inception-v3在v2的基础上进一步分解大的卷积，比如把nxn的卷积拆分成两个一维的卷积1xn，nx1。例如7x7的卷积可以被拆分为1x7和7x1两个卷积。
(3) Inception-v4借鉴了ResNet可以构建更深层网络的相关思想，设计了一个更深、更优化的模型。
ResNet （1）放弃直接拟合某个函数y=H(x)的传统思路，转而拟合残差F(x) =H(x) - x，原始映射就变成H(x)=F(x)+x
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80da8c3d400a39e0a32851fa575663ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/381d1c28b117a6406bde4973f1fd2fdb/" rel="bookmark">
			新年快乐！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024希望
1、能够继续创作一些有用的博客；
2、积极锻炼，身心健康；
3、劳逸结合，收获付出。
共勉~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76be9bc3060cf116dbc25b7fec0004a/" rel="bookmark">
			【电路笔记】-电容分压器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电容分压器 文章目录 电容分压器1、概述2、串联电容器的电压分布3、电容分压器示例14、电容分压器示例2 分压器电路可以由电抗元件构成，就像由固定值电阻器构成一样容易。 1、概述 但就像电阻电路一样，电容分压器网络即使使用属于电抗元件的电容器，也不会受到电源频率变化的影响，因为串联链中的每个电容器都会受到电源频率变化的影响。
但在我们更详细地了解电容分压器电路之前，我们需要更多地了解电容电抗及其在不同频率下如何影响电容器。
在我们关于电容器的第一篇教程中，我们看到电容器由两个由绝缘体隔开的平行导电板组成，一个板上带有正 (+) 电荷，另一个板上带有相反的负 (–) 电荷。 我们还看到，当连接到 DC（直流）电源时，一旦电容器充满电，绝缘体（称为电介质）就会阻止电流流过它。
电容器就像电阻器一样阻止电流流动，但与以热量形式耗散不需要的能量的电阻器不同，电容器在充电时将能量存储在其极板上，并在放电时释放或将能量返回到所连接的电路中。
电容器通过在其极板上存储电荷来对抗或“反应”电流的能力称为“电抗”，并且由于该电抗与电容器相关，因此称为电容电抗 ( X c X_c Xc​ )，与电阻一样，电抗为 也以欧姆为单位进行测量。
当完全放电的电容器连接到直流电源（例如电池或电源）时，电容器的电抗最初极低，并且随着电容器极板呈指数充电，最大电路电流在非常短的时间内流过电容器。
在大约等于“5RC”或 5 个时间常数的一段时间后，电容器的极板完全充电，等于电源电压，并且不再有电流流动。 此时，电容器对直流电流的电抗在兆欧范围内达到最大值，几乎处于开路状态，这就是电容器阻止直流电的原因。
现在，如果我们将电容器连接到不断反转极性的交流（交流）电源，则对电容器的影响是其极板根据所施加的交流电源电压连续充电和放电。 这意味着充电和放电电流总是流入和流出电容器板，如果有电流流动，我们还必须有一个电抗值来对抗它。 但容抗的值是多少，由哪些因素决定。
在有关电容和电荷的教程中，我们看到电容器板上存在的电荷量 ( Q Q Q ) 与施加的电压和电容器的电容值成正比。 当施加的交流电源电压 (Vs) 的值不断变化时，极板上的电荷值也必须发生变化。
如果电容器的电容值较大，那么对于给定的电阻 R R R，电容器充电所需的时间会更长，因为 τ = R C \tau = RC τ=RC，这意味着充电电流流动的时间更长。 对于给定频率，较高的电容会导致较小的电抗值 X c X_c Xc​。
同样，如果电容器的电容值较小，则需要较短的 RC 时间常数来对电容器充电，这意味着电流将流过较短的时间。 电容越小，电抗 Xc 值越高。 那么我们可以看到，电流越大，电抗越小，电流越小，电抗越大。 因此，容抗与电容器的电容值成反比， X C ∝ − 1 C X_C ∝^{-1} C XC​∝−1C。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c76be9bc3060cf116dbc25b7fec0004a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22c743a7f1ceffeb804b756cc90337c/" rel="bookmark">
			图书管理系统 毕业设计-附源码97051
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
摘要 1 绪论 1.1研究背景与意义 1.2开发现状 1.3flask框架介绍 1.4论文结构与章节安排 2
2 图书管理系统分析 2.1 可行性分析 2.2 系统流程分析 2.2.1数据流程 2.2.2业务流程 2.3 系统功能分析 2.3.1功能性分析 2.3.2非功能性分析 2.4 系统用例分析 2.5本章小结 3 图书管理系统总体设计 3.1 系统架构设计 3.2 系统功能模块设计 3.2.1整体功能模块设计 3.2.2用户管理模块设计 3.2.3 评论管理模块设计 3.2.4 图书管理模块设计 3.2.5 借阅申请管理模块设计 3.3 数据库设计 3.3.1 数据库概念结构设计 3.3.2 数据库逻辑结构设计 3.4本章小结 4 图书管理系统详细设计与实现 4.1用户功能模块 4.1.1 前台首页界面 4.1.2 用户注册界面 4.1.3 用户登录界面 22
4.1.4 公告栏界面 4.1.5 图书资讯界面 4.1.6图书信息界面 4.1.7申请借阅界面 4.2管理员功能模块 4.2.1轮播图管理界面 4.2.2 系统用户管理界面 4.2.3 资源管理界面 4.2.4图书信息管理界面 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a22c743a7f1ceffeb804b756cc90337c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b40926ee8e75ba50ffe0582251de84/" rel="bookmark">
			Rust 学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust官网：https://www.rust-lang.org/zh-CN/
Rust模块 库：https://crates.io/
官方文档：https://rustwiki.org/zh-CN/std/all.html
Rust Cookbook：https://rust-lang-nursery.github.io/rust-cookbook/
Rust 爬虫：https://zhuanlan.zhihu.com/p/516033159
[Rust] Scraper 爬虫简单使用：https://zhuanlan.zhihu.com/p/595712847
所有内容全部来自 《Rust 程序设计语言》和 《通过例子学 Rust》！！！！！
1、Rust 简介 Rust 语言的主要目标之一是解决传统 系统级编程语言（如 C 和 C++）中常见的安全性问题，例如空指针引用、数据竞争等。为了实现这个目标，Rust 引入了一种称为 "所有权" 的概念，通过静态检查来确保内存安全和线程安全。此外，Rust 还具有其他一些特性，如模式匹配、代数数据类型、函数式编程风格的特性（如闭包和高阶函数）等。它还提供了丰富的标准库和包管理器 Cargo，使得开发者可以轻松构建和管理他们的项目。
Rust 是一门注重安全（safety）、速度（speed）和并发（concurrency）的现代系统编程语言。Rust 通过内存安全来实现以上目标，但不使用垃圾回收机制（garbage collection, GC）。
Rust 是 静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。
Rust 特点 高性能：Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。可靠性：Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。生产力：Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。 Rust 相关概念 channel：Rust 会发布3个不同版本：stable、beta、nightly。
stable：Rust 的稳定版本，每 6 周发布一次。
beta：Rust 的公开测试版本，将是下一个 stable 版本。
nightly：每天更新，包含以一些实验性的新特性。toolchain：一套 Rust 组件，包括编译器及其相关工具，并且包含 channel，版本及支持的平台信息。target：指编译的目标平台，即：编译后的程序在哪种操作系统上运行。component (组件)：toolchain 是由 component 组成的。查看所有可用和已经安装的组件命令如下：rustup component list。rustup 默认安装的组件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b40926ee8e75ba50ffe0582251de84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96cc40500ebf320b82319ed84b574e08/" rel="bookmark">
			2023年终总结——你相信光吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言回顾2023工作上学习上投资上生活上 展望2024工作学习投资生活 总结 不断追求利益的经济冲动，不停侵蚀人们的生活，压垮、吞噬并统治生活本身，无法言喻的不安和看不到明天的混沌感，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉~
前言 最近在看一本叫《饱食穷民》的书，讲述的是泡沫经济年代的日本社会，宛如梦幻泡影一样变化无常，又像断梗浮萍一样飘忽不定，到处充斥着不安的色彩，我试图从中寻找一些当前现实问题的解决方案，上段文字也是出自此书之中，阅读之后我大受震撼，其中描述的有关软件工程师的篇章，简直就是我的复刻版，无论是心境、情感、还是所面临的问题都如出一辙，读完觉得背后隐隐发凉，因为最终那些令人无法接受的结局，确实是我不想看到的。
2023年要结束了，今年的时光过的格外的快，突然想起大年初二时半夜更新游戏版本好像还是昨天发生的事情，结果一眨眼就来到了2023的尾巴，2022年末的时候大家对2023年的发展充满了希望，结果今年快过完了，发现比之前“三年”更难了，零下20度的温度配合着各种“毕业”的声音，让不安的情绪充斥着每一个打工人的内心。
面对除夕上班的决定，一开始大家还是强烈反对，但是渐渐的情绪发生了逆转，除夕上班说明还有工作，很多人在这个寒冷的冬天已经“提前放假”，没有打工的机会了，在这个寒冷的冬天，你还相信光吗？
回顾2023 回顾这一年忙忙碌碌，高强度的工作却没取得预想的成果，各种Flag完成情况更是惨不忍睹。
工作上 FLAG
适应自己身份的转变，提升自己的管理技能，做一名合格的管理者继续做好本职可开发工作，做好工作内容的总结，推动新项目顺利上线根据自己的技能树框架，查漏补缺，有针对性的学习和探索 完成度 ：80%
作为一个入门的管理者，今年见识到了更多更复杂的管理情景，Hire and Fire 全都经历过了，管理经验更加完整，尝试跨过了之前一直无法逾越的坎，为了能生存下去，有时不得不做出取舍，参加了一系列的管理课程，学习后发现万物皆可为工具，招人的工具、提升效率的工具、提升凝聚力的工具、提高团队氛围的工具、优化团队的工具，学习过后内心不禁生出一丝悲凉。
本职工作继续充当牛马，还真是个踏踏实实的老黄牛，推动项目一步步往前走，但目前项目暂时停滞了，今年上线是不可能了，不过经历了一次完整的测试过程，算是在失望之中获得了一点点慰藉。
今年的工作强度依旧很大，前三季度基本上12点左右回家，个别时候会工作到后半夜，比上一年能好一点，但是最终的结果却不尽如人意。
技能树框架基本荒废，因为没时间往里边填东西，基本上是被项目推着走，缺什么就补什么，nginx测试和调整配置有了一定的经验，linux系统参数的调优也在压测是接触了不少，还有网络参数配置等等。
对于这一项来说，努力到位了，结果并不能说明什么，可能还是缺少一点点运气了。
学习上 FLAG
继续博客总结，40篇是基础线，2023要超过这个值，尽量一周一篇，放假可休息新的一年依旧很忙，刷题不强制要求，每周最好有贡献，每月必须有输出在现有的技能树框架上继续丰富，做到枝繁叶茂，试试找点副业开源代码还是以项目为驱动，选取经典实现，比如kafka继续读书，今年书也买好了，数量不多，下半年应该还会买一批 完成度 ：70%
博客总结目标达成，今年在CSDN共有42篇总结，较40篇的及格线多了一点点，年初有篇关于ChatGPT的博文一开始阅读量刷刷刷的涨，后来判定违规就被吞了，整体上博客内容比较基础，大多数来源于工作之中的知识点，也有一些是平时的思考和感悟，以下是近两年的数据对比。
2023年一年的博客访问量突破了60万，相比于去年的40多万上升了不少，文章基数增多了应该是主要原因，去年的10W+文章《float的精度和取值范围》 一年就上涨了6万多，看来高质量的内容才是吸引人的关键，并且会形成头部效应，马太效应，出现强者恒强的情况。
今年的CSDN活动依旧不少，但是我已经很少参加了，一方面没有那么多时间，还有就是看不懂规则，年终的博客之星评选，由于博文的数量没有达标，连报名的资格都没有，有点遗憾。
关于刷题这个Flag约等于没有，别说刷题了，忙的连账号都没登录几次，刚刚看了看提交记录，仅在前两个月提交了十几道题，图我就不截了，有点磕碜，不过新的一年中可能需要多一点了，毕竟工作都不稳定了，得准备准备练练手感了。
技能树框架秃了，其实我也不想秃，但是每天回家总是很晚，我实在是懒得补充了，这明显是一个借口，但却是一个事实，心里知道这个事情要做，所以换了一种方式，改为记笔记的方式来弥补，一开始准备每天问自己一个问题，后来坚持不下来，但是每次有空闲想起来就会认真回答一次，然后就是将工作中遇到的盲点和知识点记录下来，为技能树积累素材。
阅读经典代码这部分还是以项目驱动为主，比如修改easyloging++文件描述符不释放的问题，分析libevent网络数据读取缓慢的问题，扩展框架支持 websocket 连接等，都是从项目需求实际出发，当然也看了一些帧同步小游戏的示例代码，有C#的也有JS的，暂时没有找到能明显解决我对帧同步疑问的项目，目前还在学习和寻找中。
读书一直没有停，由于每天大强度的工作时间，休息之余我已经不读技术类书籍了，现在读的更多是传记、小说、散文等等，通过一页页纸张回顾历史长河，窥探他人的一生。
有的人纷繁的一生落在纸上不过一页，而绝大多数人根部就不会在书本上留下痕迹。以下便是2023年阅读的书籍内容：
时间从来不语却回答了所有问题（2023-2-12 13:56） 一本杂记，更多的是晚年的人生 苏东坡传 —— 一蓑烟雨任平生（2023-2-26 23:57） 人身缘何不快乐，只因未读苏东坡 知行合一王阳明（2023-3-12 20:43） 良知源自内心，无需外求。功名利禄，本是外在的，得之我幸，不得我命。 别让孩子伤在敏感期（2023-3-19 16:32:23） 在孩子处于各种敏感期时，学会给予尊重，顺其自然，适时引导不要规划孩子必须在哪一个领域取得成就，但只要她喜欢，就提供一个舞台，让她尽情去发挥 我是猫（2023-6-25 00:48:05） 两年的猫生戛然而止，古怪的苦沙弥高朋满座 人间失格（2023-6-24 13:30:50） 一个从小就将自己伪装起来的孩子着实令人害怕，让人回忆起了令人心酸的表哥虽然一切都已经过去，但还是有些记忆片段会在读书是产生共鸣，从记忆深处涌上来《斜阳》中的我是贵族是对时代的呐喊，回不去也融不进《GoodBye》更是写成了幻想小说的范畴 罗生门（2023-8-7 23:13:34） 怪诞、讽刺、描写细致的短篇小说，不过有些故事的寓意看不太懂 浮生六记（2023-11-26 22:35:23） 初中时的课文《童趣》居然来自这本书，据说后两记是伪写的，但最后一记《养生记道》却多次引起共鸣，可能我正处在迷茫期吧。“五百年谪在红尘，略成游戏。三千里击开沧海，便是逍遥。” 月亮与六便士（2023-12-10 17:00:27） 一个完全不顾他人感受的人是否能称之为伟大，疯子还差不多 《苏东坡传》描写了苏东坡的一生，他虽狂放不羁，但有个一直拯救他的弟弟却是它一生的幸福，“人身缘何不快乐，只因未读苏东坡”，其实不止是苏东坡，很多大人物的一生就极其坎坷，如果看看他们的经历，我们的人生才刚刚开始，而如今这个浮躁的社会已经很难让人平静的接受这一切了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96cc40500ebf320b82319ed84b574e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ea0896247c1b76233a96abd468ce49/" rel="bookmark">
			排序算法-选择插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 排序算法-选择插入排序 排序算法-选择插入排序 /// &lt;summary&gt; /// 选择插入排序 /// Krystal 2023-11-10 09:02:06 每一次找一个最小的放到正确的位置上 /// 直接选择排序通过每一轮的比较，找到最大值和最小值，将最大值的节点和右边交换，最小值节点和左边交换，达到排序的升序的效果 /// &lt;/summary&gt; /// &lt;param name="array"&gt;&lt;/param&gt; public void selectSort(int [] array) { int t; for (int i=0;i&lt;array.Length-1;i++) { int index = i; for (int j=i+1;j&lt;array.Length;j++) { if (array[index] &gt; array[j]) index = j; } if (index!=i)//找到了比array[i]小的则与array[i]交换位置 { t = array[i]; array[i] = array[index]; array[index] = t; } } } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/43/">«</a>
	<span class="pagination__item pagination__item--current">44/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/45/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>