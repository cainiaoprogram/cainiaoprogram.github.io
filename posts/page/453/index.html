<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3fb4fa64f92d6d2048244ed6f11f43d/" rel="bookmark">
			mysql使用select into from 提示 Undeclared variable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行数据库表的复制与备份的操作过程中，我们应该都知道有 select into from 和 insert into select 两种方法，这两种方法的区别在此就不讲了。
然而今天在使用 SELECT INTO FROM 备份mysql数据表的时候，运行相关 sql 语句的时候却一直返回 [Err] 1327 - Undeclared variable: ...... 这种错误，实在不解，经过查询相关资料才知道，原来 mysql 数据库是不支持 SELECT INTO FROM 这种语句的，但是经过研究是可以通过另外一种变通的方法解决这个问题的，下面就来说说解决这个错误的办法吧！
经过搜索相关资料以及实验结果证实，可以使用
Create table Table2 (Select * from Table1);
这种语句代替
SELECT vale1, value2, value3 into Table2 from Table1;
下面看一个本人实际操作中的例子吧！
create table hyd_day_loandetil_del_bak (SELECT * FROM hyd_day_loandetil WHERE ID in(SELECT DAY_ID FROM TEMP_DAY_ID));
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202e4040ebf5e92d767905fda034c185/" rel="bookmark">
			xcode安装simulator失败解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xcode安装simulator失败解决方法 众所周知因为某墙，我们下载国外的一些资源总是比较困难，每次出来一个新版本的ios版本后我们都要在xcode中更新simulator，但由于网络问题常常下载一会后就超时，或者安装失败，我经过研究总结了一套最有效的方法：
打开xcode——preference——downloads；打开osx的console，点击清除显示，以方便定位；回到xcode的downloads页面，找到自己需要的simulator，点下载并取消；切换到console，查看刚刚产生的一条记录，复制粘贴到记事本中，选择其中的下载链接进行复制打开osx的terminal，cd到一个合适的目录后，输入 curl [第4步中复制的链接] -O (注意是字母O)，等待下载结束（当然也可以使用迅雷等工具加速下载，直接粘贴下载链接就可以了）复制下载下来的dmg文件，定位到如下文件：~/Library/Caches/com.apple.dt.Xcode，右键点击 显示包内容，看里面有没有Downloads文件夹，若没有则创建一个，将下载下来的dmg文件粘贴在Downloads文件夹内最后一步，重新回到xcode的downloads页面，找到刚刚准备要下载的simulator，重新点击下载，会发现直接进入了安装过程。 做完上述7步，大功告成！
CoWill
Think two steps further, you will see the daylight!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/738553d6165bf9006e5237c7a8d8ed29/" rel="bookmark">
			Java文件上传功能代码 —— 普遍适用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言
通过之前的博客，基本上已经将各个框架上传文件的功能逻辑理清楚，有文件下载肯定就需要有文件上传，那么接下来会跟大家一起分享各个框架上传文件的功能代码；
那么，今天我们将重点放在各个框架适用的java文件上传功能代码方面，直接切入主题：
二. 实例
1.方法实例1：
//upload file,普通java上传文件方式 public String uploadFile() throws IOException{ //file为获取到的前台的文件，每个框架获取的方式不一样，可按需去查询 File file = "前台的文件"; //fileName为文件的名称，可通过file获取，不同框架获取的方式不一样 String fileName = "文件的名称，包括格式"; //获取文件的项目的根路径，不同框架获取的方式不一样，这里使用struts2的获取方式 String basePath=ServletActionContext.getServletContext().getRealPath("/upload"); //拼接成完整的指定的文件路径名，创建新文件 String filePath = basePath+File.separator+fileName; File filelocal = new File(filePath); if(filelocal.exists()){ filelocal.delete(); } //使用输入流读取前台的file文件	InputStream is=new FileInputStream(file); //循环读取输入流文件内容，通过输出流将内容写入新文件 OutputStream os=new FileOutputStream(filelocal); byte buffer[]=new byte[1024]; int cnt=0; while((cnt=is.read(buffer))&gt;0){ os.write(buffer, 0, cnt); } //关闭输入输出流 os.close(); is.close(); return null; } 2.方法实例2，连起来的简单代码工具类：
//file为上传的文件File，转换为inputstream流	InputStream stream=new FileInputStream(file); //创建本地的临时空文件 File fileTem = new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/738553d6165bf9006e5237c7a8d8ed29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b67b0d0671b76c7b9cc72097d9f8e37/" rel="bookmark">
			endnote中文献分类消失的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法； 当我们的文献库文献分类栏 消失的时候， 可以进行下列操作。 点击右下角 layerout&gt;选择Group Panel &gt; Left. 如果还是没有出现分类栏目。‘’ 那么可能是分类栏目已经存在， 但是被其他几栏目占据了屏幕的显示位置。 可以把鼠标靠近最左端，等变成“||”的时候，把分类栏往外拉出~~ 拉扯出来后~~ All commends are based on endnotes X7 software.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc2f2a8952b3a910acb9b179d1611c35/" rel="bookmark">
			Android 的Activity.getWindowManager().getDefaultDisplay().getWidth()过时了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android获取屏幕宽度和高度的方法 1.下面方发已经过时在API-13就已经放弃了
Activity.getWindowManager().getDefaultDisplay().getWidth()//获取屏幕宽度 Activity.getWindowManager().getDefaultDisplay().getHeight()和getWidth() //获取屏幕高度 官方文档给出: 现在我们来看看官方推荐的方法 很简单那就是用 .getSize(outSize) 这个方法 例子:
Display display = getWindowManager().getDefaultDisplay(); Point outSize = new Point(); display.getSize(outSize);//不能省略,必须有 int screenWidth = outSize.x;//得到屏幕的宽度 int screenHeight = outSize.y;//得到屏幕的高度 或者:
DisplayMetrics metrics = new DisplayMetrics(); getWindowManager().getDefaultDisplay().getMetrics(metrics); int height = metrics.heightPixels; int width = metrics.widthPixels; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34c4a81a3f529f0f83ea43f2258e33d2/" rel="bookmark">
			帆软报表之小白入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
其实并非完全小白，之前偶用过，只是作为给业务人员提供展示sql的平台，未接触过统计图表等功能。眼下计划用帆软观察数据特性，所以想在熟悉下其数据可视化方面的功能。
软件版本8.0（自行百度下载）
帆软的实例是不错，挺多挺全，但是没有一步步的详细教程，所以直接接触案例还是有点蒙。我按照步骤一步步讲吧
1，打开帆软后，进入帆软报表设计器，看到界面大概这样，中间一个大类似EXCEL的表格。
图1
2，先跑下帆软自带样例，在demo文件夹中的（图1左侧上部的那个文件夹demo）
比较适合入门的是demo下authority/Authority.opt这个例子，点开（截图标记1）。然后点击“预览”(截图标记2)
系统会自动弹出一个浏览器，展示最终统计效果（见图3）
这个例子中需要注意的是3，4，5，这三项都是sum(D6）但是从最终展示结果看，结果并不相同。理解上很好理解，行列角度不同，但不清楚帆软后台是如何如此“智能”的领悟我们设计含义的。虽然很智能，但是不清楚内部机制，在实现复杂功能时可能踩坑。眼下不考虑那么多把。
图2
图3
3，自己设计一个简单demo
3.1首先配置数据库连接
菜单栏-服务器-定义数据库连接-这里程序员应该都能看懂了。别再这里修改，否则demo就跑不了了。
点击此时窗口左侧的+号，添加数据库连接。
选择数据库，配置url等会根据选择的数据库自动生成，自己需要配置下用户名密码就ok了
然后点击测试连接。
弹出“连接成功”就说明数据库配置好了。要点都已经在图中标识出来了
图4
3.2数据库连接好了，如何取得数据呢？
点击菜单栏-模版数据集
先解释概念：模版数据集，听起来很复杂的样子，其实就是sql语句，或者看作excel也行（sql执行后就是二维数据和excel等价的）
点击左侧的加号+，下拉中选择第一个，数据库查询，然后输入sql语句（暂不考虑带参数的），就一个死sql，需要注意的是table名前要加database名次，就是database.table才行，这个留意下。然后点击预览（参考图5），要点已经标识出。
图5
3.3这是注意菜单栏左侧下部，会多出来一个“数据库查询”的东西，然后还有2个字段，这些个字段恰恰就是sql中返回的columns字段。
把这2字段分别拖放到A1，B1表格，然后点击“预览”就看到查询结果了。
图6
小白入门贴，到此结束
友情链接：
帆软报表学习-快速入门：http://blog.csdn.net/javaissohard/article/details/50664283?_t_t_t=0.38307334878481925
FineReport图表制作基本方法：http://bbs.fanruan.com/thread-66593-1-1.html
帆软操作培训：https://wenku.baidu.com/view/dd10fcee5901020206409ca5.html
（视频教程）Java/Web报表开发工具/报表工具-FineReport初级入门教程：http://edu.csdn.net/course/detail/801/
’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d7bfdda9e14cd1582957e98bbae68b9/" rel="bookmark">
			Java 实例 – 时间戳转换成时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 中我们常用的时间戳来转时间用的两个包
import java.text.SimpleDateFormat; import java.util.Date; 方法:
//long timeStamp = 1495777335060;//直接是时间戳 long timeStamp = System.currentTimeMillis(); //获取当前时间戳,也可以是你自已给的一个随机的或是别人给你的时间戳(一定是long型的数据) SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//这个是你要转成后的时间的格式 String sd = sdf.format(new Date(timeStamp)); // 时间戳转换成时间 System.out.println(sd);//打印出你要的时间 结果就是: 2017-05-26 13:42:15 固有时间转时间戳
String res = "2019-07-15 10:10:10"; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date date = simpleDateFormat.parse(res); long ts = date.getTime(); System.out.println("对应时间戳:" + ts); 感谢收看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c4a3b1e610b6dfb2b0c51e6d1117cd/" rel="bookmark">
			Jetson TX1开发笔记(六)：V4L2&#43;OpenCV3.1以MJPG格式读取USB摄像头图像并实时显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明作者和出处： http://blog.csdn.net/c406495762 嵌入式平台(Target)： Jeston TX1 OpenCV： OpenCV3.1 摄像头： USB 800W摄像头
前言预备知识 1 V4L2基础2 OpenCV图像解码 编译程序 1 整体代码2 编译及运行 运行结果总结 1 前言 博主手中的800W高清摄像头：
从上两幅图可以看出，该摄像头的YUV2输出格式只有一种640 x 480分辨率，而输出格式为MJPG有多种分辨率，如果想实现高清采集，需要通过MJPG格式进行采集。
摄像头的输出格式可以是YUY2、MJPG等。对于输出格式为YUV2的摄像头，可以使用上个笔记中的nvcamerasrc，直接调用的是Gstreamer进行视频图像采集。而对于输出格式MJPG的摄像头，由于博主对Gstreamer不太了解，因此决定使用V4L2+OpenCV3.1进行图像采集。
2 预备知识 2.1 V4L2基础 这部分的内容，可以看这位大牛的博客：http://www.cnblogs.com/surpassal/archive/2012/12/19/zed_webcam_lab1.html
由于，采用MJPG采集格式，因此在V4L2设备初始化的时候，摄像头帧格式的pixelformat需要设置为V4L2_PIX_FMT_MJPEG：
2.2 OpenCV图像解码 可以使用cvDecodeImage进行图像解码，buf是保存图像的buffer。iscolor参数为0，解码成灰度图，参数为1，解码成彩色图。此处iscolor参数，我们设置为1。
代码如下：
3 编译程序 3.1 整体代码 由于代码较长，贴出来影响美观。可以在我的Github下载整体代码：
URL：https://github.com/Jack-Cherish/VideoCapture/blob/master/capture.cpp
欢迎follow、star！
3.2 编译及运行 运行环境需要配置好OpenCV3.1，配置教程详见：http://blog.csdn.net/c406495762/article/details/72302980
在~/.bashrc最后添加环境变量(我的OpenCV3.1安装在了/home/ubuntu/opencv-3.1.0下，这里需要改为自己的OpenCV3.1的路径)：
export LD_LIBRARY_PATH=/home/ubuntu/opencv-3.1.0/lib:$LD_LIBRARY_PATH export PKG_CONFIG_PATH=/home/ubuntu/opencv-3.1.0/lib/pkgconfig:$PKG_CONFIG_PATH 使添加的环境变量生效：
source ~/.bashrc 将程序拷贝到TX1中，使用使用如下指令编译(我的OpenCV3.1安装在了/home/ubuntu/opencv-3.1.0下，这里需要 改为自己的OpenCV3.1的路径) ：
g++ -o capture -I /home/ubuntu/opencv-3.1.0/include -O2 -g -Wall capture.cpp -L /home/ubuntu/opencv-3.1.0/lib -lopencv_core -lopencv_imgproc -l opencv_flann -l opencv_imgcodecs -lopencv_videoio -lopencv_highgui -lopencv_ml -lopencv_video -lopencv_objdetect -lopencv_photo -lopencv_features2d -lopencv_calib3d -lopencv_stitching -lopencv_videostab -lopencv_shape -lopencv_cudaobjdetect -lopencv_cudawarping -lopencv_cudaimgproc 4 运行结果 video dev : /dev/video0 Driver Name:uvcvideo Card Name:RecordexUSA Bus info:usb-tegra-xhci-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97c4a3b1e610b6dfb2b0c51e6d1117cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad1a54c277e20d7ac58a33ba235eda8/" rel="bookmark">
			[Sencha Touch/ExtJS] (函数节流)阻止用户快速频繁点击，导致多次触发点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://blog.csdn.net/lovelyelfpop/article/details/72730455
一、前言 以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。
window对象的resize、scroll事件
拖拽时的mousemove事件
射击游戏中的mousedown、keydown事件
文字输入、自动完成的keyup事件
实际上对于window的resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。
函数去抖(debounce) 如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。
也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。
函数节流(throttle) 如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。
也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。
二、Sencha Touch/ExtJS 中防止频繁触发点击事件 比如我们想要这样的效果：
用户在500ms内，如果多次点击按钮或列表项，那么点击事件只触发一次(即第一次点击时触发)。
我们可以拦截点击事件的触发(fireEvent)，这就需要用到sencha中的before和after来实现”拦截器”了。
下面代码有两个实现，一种用Mixin实现，另一种用Plugin实现。其中前者用在类中(即define的时候)，后者用在类的实例(Ext.Create/Ext.widget/Ext.factory等)中。
支持Ext.Button和Ext.DataView、Ext.List。
支持自定义节流的时间间隔，单位ms，默认500ms。
Mixin: //ExtJS 6 Ext.define("UX.mixin.Throttle", { extend: "Ext.Mixin", //如果是Sencha Touch, 这里换成"Ext.mixin.Mixin" mixinConfig: { id: 'throttle', before: { onTap: 'onBeforeTapThrottle', onItemTap: 'onBeforeItemTapThrottle' }, after: { onTap: 'onAfterTapThrottle', onItemTap: 'onAfterItemTapThrottle' } }, throttleDuration: 500, onBeforeTapThrottle: function() { //console.log('before tap'); if (this._justTapped &amp;&amp; new Date().getTime() - this._justTapped &lt;= this.throttleDuration) { //console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ad1a54c277e20d7ac58a33ba235eda8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a830051bc23b1752712473eb392e9ac/" rel="bookmark">
			解决&lt;input type=“file” multiple&gt; 多文件上传问题（可以多次选取文件，也可以一次选取多个文件），而且点击的是一个同一个div
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html标签部分&lt;div id="uploadDiv" class="weui-uploader__input-box"&gt;&lt;/div&gt; &lt;div id="fileDiv" style="display: none"&gt;&lt;/div&gt; js 部分
$(function() {	$("#uploadDiv").on("click",function(){ var uploadFile = '&lt;input name="files" id="uploaderInput" class="weui-uploader__input" type="file" accept="image/*" multiple/&gt;'; $("#fileDiv").append($(uploadFile)); $("#uploaderInput").bind("change",function(e){//可以做一些其他的事，比如图片预览$(this).removeAttr("id"); }); $("#uploaderInput").click();	}); 思路大致是点击第一个div就创建一个input并绑定change事件，然后将这个input对象加入到第二个div中同时触发input对象的click事件来选取需要的文件。
注意：第二个div是不可见，不然一堆的&lt;input type=“file”&gt;会很难看的。
要在change事件中移除创建的input对象的id属性，如果不移除你会看到很有意思的现象的。
效果如图（当然图是加了样式做了预览的）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a90ab2fdead163b8d43eb8bc34f60a9/" rel="bookmark">
			网页嵌入视频背景（mp4当作banner）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;视频播放&lt;/title&gt; &lt;style&gt; body{ margin:0; padding:0} .abc{ width: auto; height: auto; min-width: 100%; min-height: 100%; position: relative; width: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;video class="abc" autoplay="" loop="" style="background-image:url(&gt;)"&gt;&lt;source src="video.mp4" type="video/mp4"&gt;&lt;/video&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f08e177b777f89514e809bd157574c1/" rel="bookmark">
			&#39;grep&#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现问题时的命令： adb shell logcat | grep START
问题内容：’grep’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。
解决方法：将logcat | grep START用双引号引起来，即adb shell “logcat | grep START”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcf24f50db9e5a5279d1f3201fcfa7e/" rel="bookmark">
			javascript中的关键字this
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javascript中的关键字this 前言一、ES6 箭头函数中的 this？二、什么情况下不能用箭头函数1. 定义对象方法2 定义原型方法3. 定义构造函数4. 定义事件回调函数 三、深入理解this的4种绑定规则深入理解this的绑定规则默认绑定隐式丢失显式绑定 总结 前言 面向对象语言中 this 表示当前对象的一个引用。
但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。
1、在对象方法中， this 指向调用它所在方法的对象。
2、单独使用 this，它指向全局(Global)对象。
3、函数使用中，this 指向函数的所属者。
4、严格模式下函数是没有绑定到 this 上，这时候 this 是 undefined。
5、在 HTML 事件中，this 指向了接收事件的 HTML 元素。
6、apply 和 call 允许切换函数执行的上下文环境（context），即 this 绑定的对象，call() 和 apply() 方法可以将 this 引用到任何对象。
提示：以下是本篇文章内容，案例仅供参考
一、ES6 箭头函数中的 this？ 许多人，都会这么描述箭头函数里 this 的行为：局部的 this。什么意思呢？是否局部（Lexical）？
&lt;div id="demo" onclick="foo()" &gt; 点我&lt;/div&gt; &lt;script&gt; document.getElementById('demo').onclick = function(){ console.log(this.tagName); //div setTimeout(function(){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afcf24f50db9e5a5279d1f3201fcfa7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1bd69b30de513de6c012d2299514db8/" rel="bookmark">
			oracle 数据库 去重查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle 数据库多字段去重
方法介绍：distinct 关键字、group by 、row_number ()over(partition by 列 order by 列 desc)
我的需求是：根据某几列去重 查询出去重后的全部信息。最后我选择的是第三种方法。
我的想法：我想找出一种更简单的方法去 实现去重查询。越直接越好。
表结构&amp;&amp;内容
1、distinct 关键字的用法：distinct 关键字后面的字段组合去重 distinct 必须
select distinct id from test
结果 ;根据id 去重
select distinct id，name from test
结果：根据id和name 组合去重（类似于 id || name 这样去重）
2、group by 分组去重
select id，name from test group by id，name
结果：根据id，name 组合去重
3、row_number ()over(partition by 列 order by 列 asc | desc)方法
3.1 row_number() over(order by column asc) 先对列column按照升序，再为每条记录返回一个序列号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1bd69b30de513de6c012d2299514db8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f4ff5f1ae910bbd196143f14ff3cec/" rel="bookmark">
			IE,谷歌浏览器的兼容性问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.时间转换兼容问题
var oldtime = (new Date(this.props.data.create_time)).getTime()/1000;
var nowtime = Date.parse(new Date())/1000;
这个时间转化在谷歌，火狐浏览器中能正确的获取到正确的数据。但是在IE浏览器却出现了问题。 打出的时间却是NAN。
NaN类型指的是一种特殊的number(但是NaN与任何值都不相等与自己都不相等)
设置断点后，发现问题的原因，在于解析的过程无法解析这种2017-1-7 01-15-15年月日的格式。主要原因在与无法读取“-”，所以只能读取2017/1/7 01/15/15 所以把日期格式转位／的方式就能正确获取这种日期了。
var oldtime = new Date(Date.parse(this.props.data.create_time.replace(/-/g,"/"))).getTime()/1000; var nowtime = Date.parse(new Date())/1000;
2.Scrolltop兼容问题。
最近做微信商品管理，在二期优化里面提出了。需要将醒目的商品数目，商品消耗总额一直显示在标题栏上。
&lt;div className="content-hd" style={{'position':'fixed','zIndex':'500','background':'white',top':'0px'}}&gt;
然后就开始考虑标题栏和上边界接触的时候，把格式转化为position : fixed格式
通过该方法检验滚动事件的发生。 document.body.scrollTop能够获取到谷歌滚动条的位置，但是IE通过该方法只能获取到0px.
document.documentElement.scrollTop通过该方法就能让IE也能获取到滚动条的位置。
$(window).scroll(function() {
if ((($("#panel-body").offset().top - Math.max(document.body.scrollTop,document.documentElement.scrollTop)) &lt;= 0) &amp;&amp; (that.state.main_status == 1 || that.state.main_status == 2)) {
}
}); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ccb8c947178e6c5c92367385ff23976/" rel="bookmark">
			《Spring 5 官方文档》1. Spring入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Spring入门指南 本参考指南提供了有关Spring Framework的详细信息。它全面的介绍了Spring的所有的功能，以及Spring涉及的基础概念（如“依赖注入” “Dependency Injection”）。
如果你是刚开始使用Spring，你可能需要首先创建一个Spring Boot应用程序来开始Spring框架之旅。Spring Boot提供了一个快速（和自治的）的方式来创建一个基于Spring的生产环境。它是基于Spring框架，支持约定优于配置，并且被设计成尽可能快地让你启动和运行程序。
您可以使用start.spring.io生成一个基本项目或按照新手入门指南里的任意一个指南构建项目，例如构建一个RESTful Web服务入门指南 。为了更容易帮助你理解，这些指南都是面向任务的，其中大部分都是基于Spring Boot的。 他们还涵盖了很多Spring原型工程，在您需要解决特定问题时可以考虑使用他们。
2.介绍Spring框架 Spring 框架是一个Java平台，它为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此您可以专注于应用程序的开发。
Spring可以让您从“plain old Java objects”（POJO）中构建应用程序和通过非侵入性的POJO实现企业应用服务。此功能适用于Java SE的编程模型，全部的或部分的适应Java EE模型。
这些例子告诉你，作为一个应用程序开发人员，如何从Spring平台中受益：
写一个Java方法执行数据库事务，而无需处理具体事务的APIs。
写一个本地Java方法去远程调用，而不必处理远程调用的APIs。
写一个本地Java方法实现管理操作，而不必处理JMX APIs。
写一个本地Java方法实现消息处理，而不必处理JMS APIs。
2.1依赖注入和控制反转 Java应用程序-这是一个宽松的术语，它包括的范围从受限的嵌入式应用程序到n层的服务器端企业应用程序-通常组成程序的对象互相协作而构成正确的应用程序。因此，在一个应用程序中的对象彼此具有依赖关系（dependencies）。
虽然Java平台提供了丰富的应用程序开发功能，但它缺乏将基本的模块组织成一个整体的方法，而将该任务留给了架构师和开发人员。虽然你可以使用如工厂，抽象工厂，Builder，装饰器和Service Locator等 设计模式来构建各种类和对象实例，使他们组合成应用程序，但这些模式无非只是：最佳实践赋予的一个名字，以及这是什么样的模式，应用于哪里，它能解决的问题等等。 模式是您必须在应用程序中自己实现的形式化的最佳实践。
Spring框架控制反转（IOC）组件通过提供一系列的标准化的方法把完全不同的组件组合成一个能够使用的应用程序来解决这个问题。Spring框架把形式化的设计模式编写为优秀的对象，你可以容易的集成到自己的应用程序中。许多组织和机构使用Spring框架，以这种方式(使用Spring的模式对象)来设计健壮的，可维护的应用程序。
背景
“ 现在的问题是，什么方面的控制被（他们）反转了？ ”马丁·福勒2004年在他的网站提出了这个有关控制反转（IOC）的问题 ，福勒建议重命名，使之能够自我描述，并提出了依赖注入( Dependency Injection)。
2.2模块 Spring框架的功能被有组织的分散到约20个模块中。这些模块分布在核心容器，数据访问/集成，Web，AOP（面向切面的编程），植入(Instrumentation)，消息传输和测试，如下面的图所示。
图2.1 Spring框架概述
以下部分列出了每个可用模块，以及它们的工件名称和它们支持的主要功能。工件的名字对应的是工件标识符，使用在依赖管理工具中。
2.2.1核心容器 核心容器由以下模块组成，spring-core， spring-beans，spring-context，spring-context-support，和spring-expression （Spring表达式语言）。
spring-core和spring-beans模块提供了框架的基础功能，包括IOC和依赖注入功能。 BeanFactory是一个成熟的工厂模式的实现。你不再需要编程去实现单例模式，允许你把依赖关系的配置和描述从程序逻辑中解耦。
上下文（spring-context）模块建立在由Core和Beans模块提供的坚实的基础上：它提供一个框架式的对象访问方式，类似于一个JNDI注册表。上下文模块从Beans模块继承其功能，并添加支持国际化（使用，例如，资源集合），事件传播，资源负载，并且透明创建上下文，例如，Servlet容器。Context模块还支持Java EE的功能，如EJB，JMX和基本的远程处理。ApplicationContext接口是Context模块的焦点。 spring-context-support支持整合普通第三方库到Spring应用程序上下文，特别是用于高速缓存（ehcache，JCache）和调度（CommonJ，Quartz）的支持。
spring-expression模块提供了强大的表达式语言去支持查询和操作运行时对象图。这是对JSP 2.1规范中规定的统一表达式语言（unified EL）的扩展。该语言支持设置和获取属性值，属性分配，方法调用，访问数组，集合和索引器的内容，逻辑和算术运算，变量命名以及从Spring的IoC容器中以名称检索对象。 它还支持列表投影和选择以及常见的列表聚合。
2.2.2 AOP和Instrumentation spring-aop模块提供了一个符合AOP联盟（要求）的面向方面的编程实现，例如，允许您定义方法拦截器和切入点（pointcuts），以便干净地解耦应该被分离的功能实现。 使用源级元数据(source-level metadata)功能，您还可以以类似于.NET属性的方式将行为信息合并到代码中。
单独的spring-aspects模块，提供了与AspectJ的集成。
spring-instrument模块提供了类植入(instrumentation)支持和类加载器的实现,可以应用在特定的应用服务器中。该spring-instrument-tomcat 模块包含了支持Tomcat的植入代理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ccb8c947178e6c5c92367385ff23976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b9ffcfef91631aacc81b21445bf9838/" rel="bookmark">
			TensorFlow的reduce_sum()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日期：2017.5.20
导师让下周二之前用TensorFlow把MNIST跑通，今天看源码碰到这么一行，发现TensorFlow里面的求和函数和其他语言差别挺大，便记录下来。
import tensorflow as tf ... # 交叉熵评估代价 cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1])) ... 在知乎上看到几个回答，挺浅显易懂的，话不多说，先上图
上面是TensorFlow官方文档中的函数解释。
其实在reduce_sum()中，是从维度上去考虑的（感觉这个Matlab中数据的概念比较像）
调用reduce_sum(arg1, arg2)时，参数arg1即为要求和的数据，arg2有两个取值分别为0和1，通常用reduction_indices=[0]或reduction_indices=[1]来传递参数。从上图可以看出，当arg2 = 0时，是纵向对矩阵求和，原来矩阵有几列就得到几个值；相似地，当arg2 = 1时，是横向对矩阵求和；当省略arg2参数时，默认对矩阵所有元素进行求和。
看到这里，函数名的前缀为什么是reduce_其实也就很容易理解了，reduce就是“对矩阵降维”的含义，下划线后面的部分就是降维的方式，在reduce_sum()中就是按照求和的方式对矩阵降维。那么其他reduce前缀的函数也举一反三了，比如reduce_mean()就是按照某个维度求平均值，等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02fe0fad90f9b7a63ca655226d250599/" rel="bookmark">
			Intellij IDEA 设置字体加粗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依次打开 File -&gt; settings -&gt; editor -&gt; colors &amp; fonts -&gt; java , 当然你选择 java 只对 java 代码生效，右边的所有类型都需要勾上 Bold ，也可以按照个人喜好,选择部分字体加粗。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f3c0028f3c9eb05801fa3588d117c7/" rel="bookmark">
			python学习之——import sys模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，我们利用import语句 输入 sys模块。基本上，这句语句告诉Python，我们想要使用这个模块。sys模块包含了与Python解释器和它的环境有关的函数。 当Python执行import sys语句的时候，它在sys.path变量中所列目录中寻找sys.py模块。如果找到了这个文件，这个模块的主块中的语句将被运行，然后这个模块将能够被你 使用 。注意，初始化过程仅在我们 第一次 输入模块的时候进行。另外，“sys”是“system”的缩写。
Sys模块函数之多，我只能选取自己认为比较实用的一些函数列在此处。借马云找员工的说法,”找最合适的而不是最天才的”，这句话，我个人觉得在很多方面都能适应，学习也不在话下。Sys模块功能的确很多，但我们应该将重点放在那些功能才是最适合我们的，为此，我列的这些函数，就是我认为比较适合我以后开发的函数。 (1)sys.argv 很多人会想，我如何给我的程序在外部传递参数呢？这个，就可以实现。如： Tesy.py Import sys Print sys.argv[number] 一般情况下，number为0是这个脚本的名字，1，2…则为命令行下传递的参数.如： Test.py脚本内容： import sys print sys.argv[0] print sys.argv[1] print sys.argv[2] print sys.argv[3] 那么 [root@databak scripts]# python test.py arg1 arg2 arg3 test.py arg1 arg2 arg3 看到，对应的关系了吗？ sys模块中的argv变量通过使用点号指明——sys.argv——这种方法的一个优势是这个名称不会与任何在你的程序中使用的argv变量冲突。另外，它也清晰地表明了这个名称是sys模块的一部分。 sys.argv变量是一个字符串的 列表 （列表会在后面的章节详细解释）。特别地，sys.argv包含了 命令行参数 的列表，即使用命令行传递给你的程序的参数。 这里，当我们执行python using_sys.py we are arguments的时候，我们使用python命令运行using_sys.py模块，后面跟着的内容被作为参数传递给程序。Python为我们把它存储在sys.argv变量中。 记住，脚本的名称总是sys.argv列表的第一个参数。所以，在这里，'using_sys.py'是sys.argv[0]、'we'是sys.argv[1]、'are'是sys.argv[2]以及'arguments'是sys.argv[3]。注意，Python从0开始计数，而非从1开始。 (2)sys.platform 大家都知道，当今的程序比较流行的是跨平台。简单的说就是这段程序既可以在windows下，换到linux下也可以不加修改的运行起来，听起来就不错。所以，这个函数就可以派上用场了。 假设，我们想实现一个清除终端，linux下用clear, windows下用cls Ostype=sys.platform() If ostype==”linux” or ostype==”linux2”: Cmd=”clear” Else: Cmd=”cls” (3) sys.exit(n) 执行至主程序的末尾时,解释器会自动退出. 但是如果需要中途退出程序, 你可以调用sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f3c0028f3c9eb05801fa3588d117c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703da1e9f023ee7ad43eb8eba6b063ae/" rel="bookmark">
			CTF--信息技术对抗赛ISCC之安卓逆向分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 题目介绍 本题目是一道信息安全大赛上的安卓逆向题目，主要考察选手，逆向分析能力，
反汇编能力，安卓程序结构分析能力，以及常见的安全加密编码算法得能力。题
目下载 http://download.csdn.net/detail/bjtbjt/9846682可能部分步骤过于啰嗦，大
佬略过。方便入门者学习。这个题目拿到手是个安卓apk程序。下载下来，我们先
不着急进行分析。先对其程序apk安装测试一下，看看有什么功能和提示，或者了
解一下要求我们做什么。在这里呢， 不建议大家直接在自己的安卓手机上安装，
最好使用模拟器。我这里呢，使用的是模拟器。模拟器地址网上也很多，我自己
安装的是蓝叠模拟器
http://www.bluestacks.cn/
安装很简单，就是下一步。如果出现这个说明安装成功了。
然后把我们的程序添加到这个模拟器，本地安装APK点击选择，安装好即可。
我们测试一下题目，随便输入1234，发现验证失败。那么此题目输入正确答案
密码串。
0x02 解题要点 到了这里，可以请出我们的安卓逆向神器，当然也有其它类似反编译器。
apktool，jd等之类的工具。JEB我这里是jeb 2.2.7破解版。载入我们的apk程
序进行分析。
通过关键按钮菜单，我们进行手动分析。和反编译部分函数和模块。由于刚才的
安卓程序有个按钮和编辑框。因此必须找到这个关键点位置。如下：onClick事件
就是负责处理验证密码过程。
前面绿色的数字ID就是按钮编辑框的标识，主要观察这个验证过程。对于用户的输入
这个程序先进行了。
此处把用户输入进行了字符串转化，然后去除空格。进行了encode函数编码。到底这是
个什么算法，还得跟踪Digest这个类对象的定义。先别着急分析编码函数，我们继续看
下面的代码关键点有个checkFlag函数进行了正确与否的验证，因为后面的输出判断刚好
有失败和成功之分。
这个函数呢，有声明，但是没有具体定义实体。为什么呢，因为这个是个内部JNI函数。
科普一下 Java Native Interface (JNI)标准是java平台的一部分，它允许Java代码和其他
语言写的代码进行交互。JNI 是本地编程接口，它使得在 Java 虚拟机 (VM) 内部运行的 Java 代码能够与用其它编程语言(如 C、C++ 和汇编语言)编写的应用程序和库进行交互
操作。
http://www.cnblogs.com/hoys/archive/2010/10/28/1863612.html
http://www.2cto.com/kf/201308/232666.html
到这里基本上就算是验证结束。那么我们看到了其中经历两个验证函数。一个是encode，
一个是checkFlag函数。只要分析清楚这两个函数，那么我们就直接可以进行反推，逆向
分析算法获取结果。
先来看看第一个函数encode
看编码和基本操作，好像是个base64，这个为了高校简单起见，我们可以直接验证这段java代码类。
自己编辑测试个字符串即可。
找个bas64算法验证一下。
验证成功。
下面我们关注第二个函数算法
既然是个内部函数，那么我们看看它在哪，其实我们可以从内部导出这个库文件，存储为*.so
然后单独ida分析这个iscc.so库。
关键函数checkFlag定位
关键静态密文字符串
分析算法
这里面将用户输入的字符串重新复制了一份，然后操作
先将用户输入的字符串按照长度分割成两半
把前一半字符串中的字符按照从左到右的顺序取出来
ASCII码减去 5 , 然后与后半个字符串与之对应的位置进行交换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/703da1e9f023ee7ad43eb8eba6b063ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef78e779e5e60595dc77ab668ab4624/" rel="bookmark">
			基于部分亲和字段PAF(Part Affinity Field)的2D图像姿态估计(openpose)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章出自2017年的CVPR，Realtime Multi-Person 2D Pose Estimation using Part Affinity Field，是CMU的工作，效果真的amazing。
也许这篇文章的亮点在于，融合了PCM和PAF的级联cascade形网络结构，网络设计思想和RefineNet的网络设计思想很像，以及相应条件约束的偶匹配（bipartite matchings）算法。
整个检测过程如上图所示，输入一幅图像，然后经过7个stage，得到PCM和PAF。然后根据PAF生成一系列的偶匹配，由于PAF自身的矢量性，使得生成的偶匹配很正确，最终合并为一个人的整体骨架。
在models/pose/mpi/下面有2个模型，pose_deploy_linevec.prototxt模型相对更准确一些，pose_deploy_linevec_faster_4_stages.prototxt模型精度稍微有所下降，大概2个点，但是速度提升有30%。
这2个模型的区别就是，后者去掉了stage5，stage6这2个卷积模块（如下图所示，每个stage由一系列的卷积层组成，其中Branch1由1个列组成，Branch2由2个列组成，在进入下一个stage前，上一个stage的3个列进行融合）。
models/pose/coco/pose_deploy_linevec.prototxt和models/pose/mpi/pose_deploy_linevec.prototxt网络结构一样，区别就是coco的卷基层滤波器数目更多点。这个模型是3个模型中最精确的一个。
模型的设置可以在，examples/openpose/openpose.cpp中设置，默认调用COCO的model
DEFINE_string(model_pose,"COCO","Modelto be used (e.g. COCO, MPI, MPI_4_layers).");
安装步骤（环境centos）：
git clone https://github.com/CMU-Perceptual-Computing-Lab/openpose.git cd 3rdparty/caffe cp Makefile.config.Ubuntu14.example Makefile.config #修改其中的路径为自己计算机路径 make all -j8 cd ../../models/ ./getModels.sh cd .. cp Makefile.config.Ubuntu14.example Makefile.config #修改其中的路径为自己计算机路径 make -j8 可能错误：
/tmp/cciLUahT.s:1660: Error: no suchinstruction: `vextracti128 $0x1,%ymm0,%xmm0'
make: ***[.build_release/src/openpose/gui/guiInfoAdder.o] 错误 1
make: *** 正在等待未完成的任务....
/tmp/ccpTDNgT.s:3892: Error: no suchinstruction: `vextracti128 $0x1,%ymm0,%xmm0'
make: ***[.build_release/src/openpose/gui/gui.o] 错误 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cef78e779e5e60595dc77ab668ab4624/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/747b9d051d12699c9fcf3ca607495aac/" rel="bookmark">
			C&#43;&#43;使用CHttpFile实现Http请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++实现http请求的代码，参照网上的修改了下在mfc中使用
1、HttpClient.h
[cpp] view plain copy HttpClient.h #ifndef HTTPCLIENT_H #define HTTPCLIENT_H #include &lt;afxinet.h&gt; #include &lt;string&gt; using namespace std; #define IE_AGENT _T("Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)") // 操作成功 #define SUCCESS 0 // 操作失败 #define FAILURE 1 // 操作超时 www.it165.net #define OUTTIME 2 class CHttpClient { public: CHttpClient(LPCTSTR strAgent = IE_AGENT); virtual ~CHttpClient(void); int HttpGet(LPCTSTR strUrl, LPCTSTR strPostData, CString &amp;strResponse); int HttpPost(LPCTSTR strUrl, LPCTSTR strPostData, CString &amp;strResponse); int HttpPut(LPCTSTR strUrl, LPCTSTR strPostData, CString &amp;strResponse); private: int ExecuteRequest(int strMethod, LPCTSTR strUrl, LPCTSTR strPostData, CString &amp;strResponse); void Clear(); private: CInternetSession *m_pSession; CHttpConnection *m_pConnection; CHttpFile *m_pFile; }; #endif // HTTPCLIENT_H 2、HttpClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/747b9d051d12699c9fcf3ca607495aac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3427cc0befed6a062872619c9cbe01c/" rel="bookmark">
			Block 到底啥时候会崩溃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		block可以说是OC一项非常好用的功能。block的本质，实际上是『带有自动变量值的匿名函数』。但是在block的使用上，有各种江湖传说，说在某某情况下，block的使用是不安全的，会造成崩溃。于是也有很多面试题喜欢考察block。但是，实际的block的不安全使用，貌似除了循环引用，也没遇到过什么情况啊？我敢说，block在现如今的iOS开发中，99%的崩溃都是因为你没有给block判空。而其他问题，都是因为循环引用。那么block到底啥时候不安全呢？
其实关于block，我们不用那么害怕。
block的数据结构 首先，block的数据结构其实可以通过查看源码来获得。关于block的数据结构和runtime是开源的，可以在llvm项目看到，或者下载苹果的libclosure库的源码来看。苹果也提供了在线的代码查看方式，其中包含了很多示例和文档说明。
所以，block真正的结构，就是这个样子：
struct Block_descriptor_1 { uintptr_t reserved; uintptr_t size; }; struct Block_layout { void *isa; volatile int32_t flags; // contains ref count int32_t reserved; void (*invoke)(void *, ...); struct Block_descriptor_1 *descriptor; // imported variables }; 在objc中，根据对象的定义，凡是首地址是*isa的结构体指针，都可以认为是对象(id)。这样在objc中，block实际上就算是对象。
那么既然block是个对象，那么block就应该有Class，那么block的Class是什么呢？
在block runtime中，定义了6种类：
_NSConcreteStackBlock 栈上创建的block
_NSConcreteMallocBlock 堆上创建的block
_NSConcreteGlobalBlock 作为全局变量的block
_NSConcreteWeakBlockVariable
_NSConcreteAutoBlock
_NSConcreteFinalizingBlock
其中我们能接触到的主要是前3种，后三种用于GC不做讨论。
全局block 其实，这三种block类型的情况非常好理解。
首先我们要明确，在编译完成后，block内部的代码将会提取出来，成为一个单独的C函数。创建block时，实际就是在方法中声明一个struct，并且初始化该struct的成员。而执行block时，就是调用那个单独的C函数，并把该struct指针传递过去。block的的实际作用效果，相当于C语言中的匿名函数。
于是，就可以理解_NSConcreteGlobalBlock的使用了。因为全局block是当一个block内部没有捕获任何外部变量时，就会是一个全局block类型。此时，这个block与一个函数无异。所以，那么它就应该有和函数一样的静态特性。而且，我们在调用block的时候，其实和普通C函数的调用很相似，都是名称加括号：block()。
那么有函数一样静态特性的block，显然不需要再取考虑他的生命周期。
栈block 这个类型的block，是在编译器发现block内部引用了外部变量后，会生成的block类型。
在block内部有引用外部变量时，当struct第一次被创建时，它是存在于该函数的栈帧上的，其Class是固定的_NSConcreteStackBlock。其捕获的变量是会赋值到结构体的成员上，所以当block初始化完成后，捕获到的变量不能更改。
当函数返回时，函数的栈帧被销毁，这个block的内存也会被清除。所以在函数结束后仍然需要这个block时，就必须用Block_copy()方法将它拷贝到堆上。这个方法的核心动作很简单：申请内存，将栈数据复制过去，将Class改一下，最后向捕获到的对象发送retain，增加block的引用计数。详细代码可以直接点这里查看。
之所以这样设计，实际上，可以认为成，当block有了外部变量的捕获，那么它就需要持有这个外部变量，就是赋值到结构体成员上。这种捕获，造成了block对应struct结构体大小的动态变化，所以，在设计上适合放在栈上更合理。
堆block 在栈block中，说到过，当函数的栈帧的销毁，那么栈block也会被随之清楚。但是我们一般都需要在函数结束后仍然能使用这个block，所以，需要把栈block拷贝到堆上。在copy时，就把栈block的类型转换成了堆block。
所以在MRC时代，block属性的关键字必须是copy。这样就可以保证在给block属性赋值的时候，能把在栈上的block给copy到堆区。
而讲得再细一点，为什么非要把block放到堆区才安全。
因为你可以这么理解，block就是个匿名函数，只不过我们给了一个变量来引用这个匿名函数，在需要的时候调用。但是,栈block会随着函数栈帧的销毁而销毁，这样一来，我们用之前做引用的变量再去调用这么一块被销毁的内存，就会出现内存崩溃。
所以，只有把block放到由我们来控制生命周期的堆区中，才能安全地使用block。
我们知道，在OC中，对象都会在堆区存储。实际上，此时的堆block，它的确就是一个对象。而且，你还需要对它手动release。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3427cc0befed6a062872619c9cbe01c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981c0cb1aa7e4f273e200537eb7414ce/" rel="bookmark">
			13_栈的递归实例4---全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "linkStack.h" static int number = 0; void hanoi( char *s , int a , int b ) { if ((0 &lt;= a) &amp;&amp; (a &lt;= b)){ if (a == b) { cout &lt;&lt; s &lt;&lt; endl; ++number; } else { for (int i = a; i &lt;= b; ++i) { if ( (i&gt;a)&amp;&amp;(s[i] == s[a]) ) continue; char temp = s[a]; s[a] = s[i]; s[i] = temp; hanoi(s, a + 1, b); temp = s[a]; s[a] = s[i]; s[i] = temp; } } } } int main(int argc, char **argv) { char s[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/981c0cb1aa7e4f273e200537eb7414ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72324e4f531eebf718dce307146ccaee/" rel="bookmark">
			maven java.lang.NoClassDefFoundError: org/codehaus/plexus/util/cli/CommandLineException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建maven项目后，clean install，报错：
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ mavenTest ---
[WARNING] Error injecting: org.codehaus.plexus.compiler.javac.JavacCompiler java.lang.NoClassDefFoundError: org/codehaus/plexus/util/cli/CommandLineException at java.lang.Class.getDeclaredConstructors0(Native Method) at java.lang.Class.privateGetDeclaredConstructors(Class.java:2671) at java.lang.Class.getDeclaredConstructors(Class.java:2020) at com.google.inject.spi.InjectionPoint.forConstructorOf(InjectionPoint.java:245) at com.google.inject.internal.ConstructorBindingImpl.create(ConstructorBindingImpl.java:99) at com.google.inject.internal.InjectorImpl.createUninitializedBinding(InjectorImpl.java:658) at com.google.inject.internal.InjectorImpl.createJustInTimeBinding(InjectorImpl.java:882) at com.google.inject.internal.InjectorImpl.createJustInTimeBindingRecursive(InjectorImpl.java:805) at com.google.inject.internal.InjectorImpl.getJustInTimeBinding(InjectorImpl.java:282) at com.google.inject.internal.InjectorImpl.getBindingOrThrow(InjectorImpl.java:214) at com.google.inject.internal.InjectorImpl.getProviderOrThrow(InjectorImpl.java:1006) at com.google.inject.internal.InjectorImpl.getProvider(InjectorImpl.java:1038) at com.google.inject.internal.InjectorImpl.getProvider(InjectorImpl.java:1001) at com.google.inject.internal.InjectorImpl.getInstance(InjectorImpl.java:1051) at org.eclipse.sisu.space.AbstractDeferredClass.get(AbstractDeferredClass.java:48) at com.google.inject.internal.ProviderInternalFactory.provision(ProviderInternalFactory.java:81) at com.google.inject.internal.InternalFactoryToInitializableAdapter.provision(InternalFactoryToInitializableAdapter.java:53) at com.google.inject.internal.ProviderInternalFactory$1.call(ProviderInternalFactory.java:65) at com.google.inject.internal.ProvisionListenerStackCallback$Provision.provision(ProvisionListenerStackCallback.java:115) at org.eclipse.sisu.bean.BeanScheduler$Activator.onProvision(BeanScheduler.java:176) at com.google.inject.internal.ProvisionListenerStackCallback$Provision.provision(ProvisionListenerStackCallback.java:126) at com.google.inject.internal.ProvisionListenerStackCallback.provision(ProvisionListenerStackCallback.java:68) at com.google.inject.internal.ProviderInternalFactory.circularGet(ProviderInternalFactory.java:63) at com.google.inject.internal.InternalFactoryToInitializableAdapter.get(InternalFactoryToInitializableAdapter.java:45) at com.google.inject.internal.ProviderToInternalFactoryAdapter$1.call(ProviderToInternalFactoryAdapter.java:46) at com.google.inject.internal.InjectorImpl.callInContext(InjectorImpl.java:1103) at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72324e4f531eebf718dce307146ccaee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a226fc79d4814ac88e41911402e582e/" rel="bookmark">
			有道云笔记客户端收起左侧目录边栏方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 有道云笔记 Windows 版客户端（V 5.8）在使用默认编辑器（非 Markdown 编辑器）编辑文章时，无法收起左边的目录栏和中间的文件列表栏（全屏编辑更是不方便），在多窗口任务时非常占地方，没有直观的收起左侧目录的按钮。
解决方法 如果想只单独显示正在编辑的文章窗口，并且可以随意调节窗口大小和位置，我发现有以下两种方法：
方法一 双击中间文件列表部分需要独立窗口编辑的文件，这样就会弹出一个单独的窗口 比如双击上图红框中的文章，就会弹出一个单独的窗口，这样就可以随意更改窗口大小和位置 方法二 点击有道云笔记客户端右上角“菜单”按钮，依次选择“试图”-“左侧面板”-“显示左侧面板”，当“显示左侧面板”前的 √ 去掉后就会收起左侧面板 当依次选择“视图”-“笔记列表面板”，当“笔记列表面板”前的 √ 去掉后就会收起中间笔记列表面板 此时就会只剩下当前需要编辑的文章窗口。
参考： 新版本的有道云笔记如何优雅的一键隐藏侧边栏？：https://www.zhihu.com/question/51822290
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4df9af6ce704f01db929ec10224ce0c/" rel="bookmark">
			python 停止线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import threading import time import inspect import ctypes def _async_raise(tid, exctype): """raises the exception, performs cleanup if needed""" tid = ctypes.c_long(tid) if not inspect.isclass(exctype): exctype = type(exctype) res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype)) if res == 0: raise ValueError("invalid thread id") elif res != 1: # """if it returns a number greater than one, you're in trouble, # and you should call it again with exc=NULL to revert the effect""" ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None) raise SystemError("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4df9af6ce704f01db929ec10224ce0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2410640c55a79133eba677a004442c9a/" rel="bookmark">
			Pycharm连接Oracle数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Python操作数据库时，很多时候会编辑SQL语言。但是，对于IDE来说，它不能明确的知道你写的SQL语言的正确性，所以会提示警告。Pycharm中的信号是橙色警告，告警信息是：
SQL dialect is not configuredpycharm No data sources are configured to run this SQL 第一条告警信息是说，SQL语系没有配置。解决方法见stackoverflow：在Pycharm中进入File &gt; Settings &gt; Languages &amp; Frameworks &gt; SQL Dialects然后为对应的项目文件设置SQL dialect，例如：我设的是Oracle，如下图: 第二条告警信息是说，Pycharm没有配置数据库来运行SQL。当然，代码可以运行成功，但是，因为Pycharm没有连接数据库，不知道数据库中的结构，就不知道你写的SQL的正确性，就提前报错了，所以弹出警告。解决方案就是配置数据库连接，这个网上的信息几乎没有，在 IntelliJIEDA的官方文档里给出了方法。 打开 Database tool window。位置：View | Tool Windows | Database点开工具栏中的在新弹出的Data Sources and Drivers窗口中，点击新建数据库资源。看一下窗口下方有没有告警(安装对应数据库的驱动)，如果有的话，点击自动安装就好。填写General窗口和SSH/SSL窗口中的相应信息。如果是数据库在本地或在远程windows服务器上，则不需要配置SSH/SSL。点击Test Connection测试，成功后点击Apply，然后点击OK。 具体窗口如下图所示， 马赛克部分为远程服务器IP。如果是本机，则填写127.0.0.1或localhost： 现在退回到文本编辑界面，SQL语句上没有了橙色的警告，而是变成了绿色~而且现在可以直接在Pycharm中操作数据库了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6ead0f96e7ce8bc81903bf99f9787c/" rel="bookmark">
			核函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核函数简介
根据模式识别理论，低维空间线性不可分的模式通过非线性映射到高维特征空间则可能实现线性可分，但是如果直接采用这种技术在高维空间进行分类或回归，则存在确定非线性映射函数的形式和参数、特征空间维数等问题，而最大的障碍则是在高维特征空间运算时存在的“维数灾难”，采用核函数技术可以有效地解决这样问题。
1.直接非线性映射
线性回归：
我们称该对象有n个属性(attribute)，可以将该属性直接作为特征(feature)来使用，也可以将该属性做出映射，例如映射为feature：
而之后在每一个需要使用x的地方以来替代。
2.在含有点积的计算过程中使用核函数
例如在svm分类器中,推导出(只举例，不详述推导过程)：
应此分类函数为： 这里的形式的有趣之处在于，对于新点 x的预测，只需要计算它与训练数据点的内积即可，这就是所谓 Supporting Vector ，所有非Supporting Vector 所对应的系数都是等于零的，因此对于新点的内积计算实际上只要针对少量的“支持向量”，非支持向量的训练数据对超平面没有影响。
原始特征内积为：，依据(1)中的映射，得到映射后的特征内积为：
然而这种计算方式是非常低效的。
定义:
但是该核函数只能在选择该映射函数时才能够等价于映射后特征的内积。
由于计算的是内积：
所以向量之间夹角越小，核函数值越大。
在上述的例子中，通过推导出k(x,z)与Φ(x)的关系来证明该核函数是有效的。那么给定任意一个核函数，如何判断它的有效性呢，也就是说，能否找到一个Φ，使得对于所有的x和z，都满足？
3.核函数的有效性判定
必要条件
假设有n个训练样本，每个样本对应的特征向量为：
计算任意两个样本的核函数值为：
这样可以得到一个n*n的核函数矩阵，该核函数矩阵是一个对称矩阵。
假设核函数是有效的，也就是说满足条件：
那么对于任意向量a：
所以核矩阵为半正定矩阵是该核函数有效的必要条件。
充分条件
Mercer定理表明为了证明K是有效的核函数，那么我们不用去寻找Φ，而只需要在训练集上求出各个Kij，然后判断矩阵K是否是半正定（使用左上角主子式大于等于零等方法）即可。
所以核矩阵为半正定矩阵是该核函数有效的充分必要条件。
4.常见核函数
线性核：
多项式核：
径向基核函数：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b03a96c8505460db38baea90adcf67/" rel="bookmark">
			Myeclipse10用不了jdk1.8和tomcat8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天装了Myeclipse10 ，我发现所有程序都出错了，然后我进入BuildPath发现jre版本错了，于是我就打算修改成1.8，但是改不了。tomcat最高也只是能够选tomcat7 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8351ba9b616c4a5eaabfd453392a2090/" rel="bookmark">
			Android资源管理框架（Asset Manager）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android资源管理框架（Asset Manager） Android应用程序资源的编译和打包过程分析 我们在编译一个android应用程序时，至少涉及两个包，其中一个是被应用的系统资源包，另一个就是当前的应用资源包。一个包引用其他包的资源通过资源ID方式实习。资源ID是一个4字节的无符号整数，其中，最高字节表示Package ID，次高字节表示Type ID，最低两字节表示Entry ID。
Package ID相当于资源的命名空间，系统资源为0x01,应用资源为0x7f. Type ID指资源类型ID。 Entry ID指该资源在该类型下出现的次序。
在编译应用资源前，aapt工具会创建一个AaptAssets对象，用来收集资源文件。 然后会将该AaptAssets对象中的数据添加到资源表中，后续会根据该表生成资源索引表，即生成resources.arsc文件。
然后再为其他资源分配ID,前面准备的资源ID就是为后续编译xml文件做准备。
解析xml文件是为了可以在内存中用一些列树形结构XMLNode来表示，然后将前面的资源ID赋值给该对象中的资源。
android:id属性值“@+id/button_start_in_process”，其中，“@”表示后面描述的属性是引用类型的，“+”表示如果该引用不存在，那么就新建一个，“id”表示引用的资源类型是id, “button_start_in_process”表示引用的名称。应用属性前面还可以指定包名，例如：“@+[package:]id/button_start_in_process”
Android应用程序资源管理器（Asset Manager）的创建过程分析 Activity通过ContextImpl类中的getResources和getAssets得到Resources对象和AssetManager对象，其中，Resources对象通过资源id访问资源，AssetManager则是通过文件名访问资源，实际上Resources是先通过id找到资源文件名，在通过AssetManager进行资源获取。
ContextImpl中的mResources指向了Resources对象，而Resources里的mAssets则指向了AssetManager。getAssets就是按照这条路径来获取AssetManager对象。系统的资源打包在/system/framework/framework-res.apk文件中，应用程序通过单独的一个Resources和AssetManager来访问，通过getSystem即可访问到这两个单独的对象。
Java层的AssetManager主要是通过C++层的AssetManager来实现。C++层的AssetManager类有三个重要的成员变量mAssetPaths、mResources和mConfig。其中，mAssetPaths保存的是资源存放目录，mResources指向的是一个资源索引表，而mConfig保存的是设备的本地配置信息。
每个Activity加载过程中会创建ContextImpl来初始化上下文，Resources和AssetManager也是此时创想。
class ContextImpl extends Context { private ContextImpl(...) { .... mPackageInfo = packageInfo; mResourcesManager = ResourcesManager.getInstance(); ..... Resources resources = packageInfo.getResources(mainThread); .... if (container != null) { // This is a nested Context, so it can't be a base Activity context. // Just create a regular Resources object associated with the Activity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8351ba9b616c4a5eaabfd453392a2090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be7c8cf78eeaf86a683be952b667c745/" rel="bookmark">
			Apache Options Indexes FollowSymLinks详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果该虚拟目录下没有 index.html，浏览器也会显示该虚拟目录的目录结构，列出该虚拟目录下的文件和子目录。
如何禁止 Apache 显示目录列表呢？
要禁止 Apache 显示目录结构列表，只需将 Option 中的 Indexes 去掉即可。
比如我们看看一个目录的目录配置：
&lt;Directory "D:/Apa/blabla"&gt; Options Indexes FollowSymLinks #----------&gt;Options FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; 你只需要将上面代码中的 Indexes 去掉，就可以禁止 Apache 显示该目录结构。用户就不会看到该目录下的文件和子目录列表了。
Indexes 的作用就是当该目录下没有 index.html 文件时，就显示目录结构，去掉 Indexes，Apache 就不会显示该目录的列表了。
第二种方法 解决办法： 1、编辑httpd.conf文件 vi ./conf/httpd.conf
找到如下内容： ?BR&gt; &lt;Directory “C:/Program Files/Apache2.2/htdocs”&gt; # # Possible values for the Options directive are “None”, “All”, # or any combination of: Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that “MultiViews” must be named *explicitly* — “Options All” # doesn’t give it to you.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be7c8cf78eeaf86a683be952b667c745/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/638c80e5a3e055c1e25397aaa1293742/" rel="bookmark">
			kernel 中WiFi模块报错：device not accepting address .error -71
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在板子上验证WiFi模块，出现一条打印 usb 1-1:device not accepting address 4,error -71 查找kernel的错误码 enolink 67 link has been servered eadv 68 advertise error ····· erpoto 71 protocol error 也就是说协议错误， 说明没有开启wifi 协议的支持 在menuconfig 中的device-&gt;usb-&gt;wireless support 之后手上的两个模块终于有其中一个可以正常用了，但是另一个还是打印这个错误，看来这个错误出现的云因不只是协议不支持问题，一般不能枚举都是这会打印这个错误，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e710438b99b4169f2574f4f12795cebe/" rel="bookmark">
			红外图像非均匀矫正——一点矫正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着微电子工艺的进步，红外探测器的价格下降的很快，过去一台红外相机80%的成本都在探测器上，剩下的20%还得扣除软硬件成本才是利润，并且由于本国红外探测器的工艺水平低下，就算是高价都不能拿到性能达标的产品，军品都是在民品中筛选盲元少非均匀性好一点的出来用。所以最后产品性能其实非常依赖于软件对于图像处理。对比可见光sensor，红外探测器一个很大的问题就是非均匀性。 非均匀矫正一般采用两点法进行，为了解决多温度段之间的响应问题还需要进行温度分区的两点法非均匀矫正，极端的公司常温下都做了十几个温度段！因为红外图像处理比较麻烦，往往使用很多的计算，所以一般都是需要一个带有大量乘法器的dsp进行，当前为了减少体积、功耗、成本、方向都是使用单片cpu 进行所有处理，这样就对算法提出了简化的要求，对比于两点法的非均匀矫正，对于处理后效果和计算量的平衡,就可以使用一点法进行矫正。
起源 一点法是由SchulzM和CaldwellL在1995年提出的最早的一种非均匀校正算，其实一点法就是使用一幅在一均匀光辐射下图片,就能把各个像元的输出信号校正为一致的方法,这种做法是在一强度相同光辐射下,将不同像元的的响应值校正为相同的响应值，因为他们是在同一照度下的。它可以为此时的信号平均值，也可以为此条件下的最大值等等。
实现方法 针对具体情况又可分为两种校正方法 1.偏置不均匀的一点校正法 该方法主要用于偏置不均匀性较为明显,而增益不均匀性可忽略的情况.这种探测器的原始图像就不是特别差，至少能够达到看出目标物体形状的状态。 -计算标定图的平均值 avr = sum（背景照度图）/像素数 -计算偏置参数 cell_offset[分辨率] = 背景照度图像素响应 - avr -实时矫正响应 result = cell_realtime - cell_offset 2. 增益不均匀的一点矫正法 该方法主要用于增益不均匀性较为明显,而偏置不均匀性可忽略的情况，这种情况下的响应往往没法看。 -计算标定图的平均值 avr = sum（背景照度图）/像素数 -计算偏置参数 cell_offset[分辨率] = 背景照度图像素响应 / avr -实时矫正响应 result = cell_realtime *cell_offset
结论 对于当前工艺水平和能拿到的探测器等级来讲，增益和偏置的不均匀都是很严重的，所以对于一点法的矫正效果肯定是不够的，虽然他能较少一部分的运算量，但是在产品应用中使用时不多的，对比效果才能明白性能和资源消耗在产品中永远只能做平衡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ecb8cfbfeee33b982bc5bd407b5091/" rel="bookmark">
			qemu-img管理虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qemu-img管理虚拟机 1. 查看正在运行的虚拟机 [root@idca-vm02 ~]# virsh list
Id 名称 状态
----------------------------------------------------
2 idca-bankccb-b2c-45 running
4 idca-bankicbc-42-clone running
6 idca_rhel5_con29_6.29 running
7 idca_w03_bkccb_b2b_101 running
10 idca_w03_bkicbc_b2b_102 running
16 idca-bankcncb-44 running
18 idca_w03_bkcmb_b2b_105 running
20 idca_w03_bkpab_87 running
32 idca_w03_bkcomm_b2b_103 running
34 idca-bankhxb-43 running
38 idca_rhel5_con23_6.23_new running
43 idca_w03_bkpab_dk_6.88 running
2. 查看所有虚拟机 [root@idca-vm02 ~]# virsh list --all
Id 名称 状态
----------------------------------------------------
2 idca-bankccb-b2c-45 running
4 idca-bankicbc-42-clone running
6 idca_rhel5_con29_6.29 running
7 idca_w03_bkccb_b2b_101 running
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98ecb8cfbfeee33b982bc5bd407b5091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0553a57d736415104b57ec04763c4ca/" rel="bookmark">
			plus.webview.show 后刷新页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、详情页
在详情页添加一个刷新函数，改函数使用ajax请求后台并替换页面数据
二、列表页
在列表页使用 plus.webview.show 成功后，有个回调方法，在回调方法里获取详情页的 webview 对象，然后调用详情页的 刷新函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da4e596f37f213b6fefafeb3fceddbc5/" rel="bookmark">
			nginx配置https后，网站出现无法访问情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		证书来自阿里云。
Nginx配置如下
server { listen 443; server_name package.oeynet.com; root /server/wwwroot/package_v1/Public; ssl on; ssl_certificate /server/certs/package.oeynet.com/214082784100471.pem; ssl_certificate_key /server/certs/package.oeynet.com/214082784100471.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { index index.html index.htm index.php l.php; # autoindex on; if (!-e $request_filename) { rewrite ^/(.*)$ /index.php/$1 last; break; } } location ~ \.php(.*)$ { fastcgi_pass 127.0.0.1:9000; fastcgi_split_path_info ^((?U).+\.php)(/?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; } location ~* \.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da4e596f37f213b6fefafeb3fceddbc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71b66678afefdfc53f3efcacad3c999/" rel="bookmark">
			如何读懂一段代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一段不知道背景知识的代码，如何读懂？ 对于程序员来说，读代码要比写代码困难。因为写代码是在自己的世界创造，而读代码却是在接触别人的世界的建筑。每个人的世界都是不尽相同的，因此在读别人的代码时，总会有些滞涩，我也是更愿意自己写，读懂算法思想、梗概，然后自己来实现。因此在过去很长一段时间，写的代码都只是一时之快，很难长久——写完不久之后，我已经不认识自己曾经写的东西了，甚至觉得那是别人写的。 要学会写，先学会读。 读别人的代码，就是走出自己的舒适区，挑战自己的理解力，开阔自己的思维。同时，在读的过程中会意识到怎样的代码才更容易让人理解。 今天读到的一段如下（Matlab代码，不是很熟悉语法）：
for i = 2:n p(i) = inf; s(i) = i; end %用Ford 算法求最短路, 赋初值 for k = 1 : n %求有向赋权图中源点vs到汇点vt的最短路 pd = 1; for i = 2 : n for j = 1 : n if (p(i) &gt; p(j) + a(j,i)) p(i) = p(j) + a(j,i); s(i) = j; %s(i)为点i的标号，表示在最短路径中i点的前一个点的编号 pd = 0; end; end; end if (pd) break; end; end %求最短路的Ford 算法结束 第一步，先读最简单的——注释。最容易被看懂的注释应该解释的是读者最想知道的内容：这段代码什么意思？但注释不能写那么详细，要尽量写得简洁，所以应该注释的是：这段代码是来做什么的。 这里用名词简洁介绍：Ford算法，作用：求最短路径。那么就知道这段代码是用来求最短路径的，但这还不够。 第二步，读结构。程序的基本结构：顺序、循环、条件分支是大部分程序代码所共有的。这个程序的第一层有顺序的两个结构：循环、循环。第一个循环是顺序语句；第二个循环内含一个两层循环和一个条件语句，两层循环内是一个条件语句。 这步看似复杂，其实熟悉语法的可以很快过掉，即使不熟悉语法，也可以半猜半查的读懂结构，这一步是为后面了解程序所做的数据操作做准备。 第三步，读变量。由于Matlab中的变量是弱类型的，风格不好的代码很难找到其声明或定义，变量往往是拿来就用，因此需要以关键词的形式来分类理解。 这个程序中，有如下关键词是已知显示定义了的：p、s、pd；有如下关键词是未知的（来自于前文或者全局）：a；有如下关键词是用于循环变量的：k，i，j。列举如下： p：初始化为(0,inf,inf….
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e71b66678afefdfc53f3efcacad3c999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0bf9895c1c846e4851692da7b42f7b/" rel="bookmark">
			开发企业微信之接收消息服务器配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果在你的企业应用中需要用到如下功能时需提前开启接收消息模式
获取企业成员的地理位置信息动态调整企业应用的信息获取企业成员点击事件类型的应用菜单行为获取企业成员通过应用给企业后台发送的消息 关于操作过程，企业微信API里已经介绍的很清晰了http://work.weixin.qq.com/api/doc#10514 后台开启接收消息&gt;使用接收消息&gt;消息的加解密处理 主要是用到了微信提供的加解密处理库，对微信请求来的参数进行解密出来，再把 echostr参数明文返回给微信 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eab92a458e69b27d320a0a2dfdac793/" rel="bookmark">
			图像纹理特征总体简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像纹理特征总体简述 纹理是一种反映图像中同质现象的视觉特征，它体现了物体表面的具有缓慢变化或者周期性变化的表面结构组织排列属性。纹理具有三大标志：
某种局部序列性不断重复；非随机排列；纹理区域内大致为均匀的统一体； 不同于灰度、颜色等图像特征，纹理通过像素及其周围空间邻域的灰度分布来表现，即局部纹理信息。另外，局部纹理信息不同程度上的重复性，就是全局纹理信息。 纹理特征体现全局特征的性质的同时，它也描述了图像或图像区域所对应景物的表面性质。但由于纹理只是一种物体表面的特性，并不能完全反映出物体的本质属性，所以仅仅利用纹理特征是无法获得高层次图像内容的。与颜色特征不同，纹理特征不是基于像素点的特征，它需要在包含多个像素点的区域中进行统计计算。在模式匹配中，这种区域性的特征具有较大的优越性，不会由于局部的偏差而无法匹配成功。 在检索具有粗细、疏密等方面较大差别的纹理图像时，利用纹理特征是一种有效的方法。但当纹理之间的粗细、疏密等易于分辨的信息之间相差不大的时候，通常的纹理特征很难准确地反映出人的视觉感觉不同的纹理之间的差别。例如，水中的倒影，光滑的金属面互相反射造成的影响等都会导致纹理的变化。由于这些不是物体本身的特性，因而将纹理信息应用于检索时，有时这些虚假的纹理会对检索造成“误导”。
参考地址： 《图像特征提取（纹理特征）》 《纹理特征简介》
一. 纹理特征的特点 优点： 包含多个像素点的区域中进行统计计算；常具有旋转不变性；对于噪声有较强的抵抗能力；缺点： 当图像的分辨率变化的时候，所计算出来的纹理可能会有较大偏差；有可能受到光照、反射情况的影响；从2-D图像中反映出来的纹理不一定是3-D物体表面真实的纹理； 二. 纹理特征分类 1. 基本说明 纹理特征分类图如下所示： 纹理特征的提取，一般都是通过设定一定大小的窗口，然后从中取得纹理特征。然而窗口的选择，存在着矛盾的要求：
窗口设定大：纹理是一个区域概念，它必须通过空间上的一致性来体现。观察窗口取的越大，能检测出同一性的能力愈强；反之，能力愈弱；窗口设定小：由于不同纹理的边界对应于区域纹理同一性的跃变，因此为了准确地定位边界，要求将观察窗口取得小一点； 这种情况下，会出现困难是：窗口太小，则会在同一种纹理内部出现误分割；而分析窗太大，则会在纹理边界区域出现许多误分割。
后文介绍纹理特征描述方法时，会从下面四个角度，分别对各方法进行比较：
计算复杂度是否与人类视觉感受一致是否利用全局信息是否具有多分辨特性 2. 纹理特征描述方法 按照纹理特征描述方法，可以分为以下几类：
(1) 统计方法 统计方法是基于像素及其邻域的灰度属性，来研究纹理区域的统计特性。统计特性包括像素及其邻域内灰度的一阶、二阶或高阶统计特性等。 统计方法的典型代表，是一种被称为灰度共生矩阵(GLCM)的纹理分析方法。它是建立在估计图像的二阶组合条件概率密度基础上的一种方法。这种方法通过实验，研究了共生矩阵中各种统计特性，最后得出灰度共生矩阵中的四个关键特征：能量、惯量、熵和相关性。 尽管GLCM提取的纹理特征具有较好的鉴别能力，但是这个方法在计算上是昂贵的，尤其是对于像素级的纹理分类更具有局限性。并且，GLCM的计算较为耗时，好在不断有研究人员对其提出改进。 其他的统计方法，还包括图像的自相关函数，半方差图等。
优点： 方法简单，易于实现。尤其是灰度共生矩阵(GLCM)方法是公认有效方法，有较强的适应性与鲁棒性；缺点： 与人类视觉模型脱节，缺少全局信息的利用，难以在研究纹理尺度之间像素的遗传或依赖关系；缺乏理论支撑；计算复杂度较高，制约了实际应用。 (2) 几何法 几何法是建立在纹理基元理论基础上的一种纹理特征分析方法，其中的纹理基元即为基本的纹理元素。纹理基元理论认为，复杂的纹理可以由若干简单的纹理基元按照一定规律的形式重复排列构成。 在几何法中，比较有影响的算法有Voronio棋盘格特征法。 但几何法应用和发展极其受限，且后继研究很少。
(3) 模型法 模型法中存在假设：纹理是以某种参数控制的分布模型方式为基础而形成的。 由于模型法从纹理图像的实现来估计计算模型参数，同时以参数为特征，或采用某种分类策略进行图像分割，所以模型参数的估计是模型法的核心问题。 模型型纹理特征提取方法以随机场模型方法和分形模型方法为主。
随机场模型方法：试图以概率模型来描述纹理的随机过程，它们对随机数据或随机特征进行统计运算，进而估计纹理模型的参数，然后对一系列的模型参数进行聚类，形成和纹理类型数一致的模型参数。由估计的模型参数来对灰度图像进行逐点的最大后验概率估计，确定像素及其邻域情况下该像素点最可能归属的概率。随机场模型实际上描述了图像中像素对邻域像素的统计依赖关系。分形模型方法：分数维作为分形的重要特征和度量，把图像的空间信息和灰度信息简单而又有机的结合起来，因而在图像处理中备受人们的关注。研究表明，人类视觉系统对于粗糙度和凹凸性的感受与分形维数之间有着非常密切的联系。因此，可以用图像区域的分形维数来描述图像区域的纹理特征。分形维描述纹理的核心问题是如何准确地估计分形维。分数维在图像处理中的应用时以两点为基础： (1) 自然界中不同种类的形态物质一般具有不同的分形维；(2) 由于研究人员的假设，自然界中的分形与图像的灰度表示之间存在着一定的对应关系。 随机场模型法的典型方法，如马尔可夫随机场（MRF）模型法、Gibbs随机场模型法、分形模型和自回归模型。
优点： 模型家族的方法能够兼顾纹理局部的随机性和整体上的规律性，并且具有很大的灵活性；采用随机场模型法对遥感影像纹理特征进行描述并在此基础上进行分割，在很大程度上符合或反映了地学规律；MRF的主要优点是，它提供了一种一般而自然的用来表达空间上相关随机变量之间的相互作用的模型（它注意到纹理的多分辨率特性，结合图像的分层理论，发展了分层MRF方法、多分辨率MRF方法等，不但可以提高处理效率，而且研究纹理尺度间像素的遗传或依赖关系以取得纹理特征）。缺点： 由于主要是通过模型系数来标识纹理特征，模型系数的求解有难度；计算量很大。由于基于MRF模型的纹理图像分割是一个迭代的优化过程，它由局部到全局的收敛速度很慢（即使条件迭代模式(ICM)能加速寻找解），通常需要迭代数百次才能收敛；参数调节不方便，模型不宜复杂。 (4) 信号处理法 信号处理的方法是建立在时域、频域分析，以及多尺度分析的基础上。这种方法对纹理图像某个区域内实行某种变换后，再提取出能够保持相对平稳的特征值，并以该特征值作为特征，表示区域内的一致性以及区域之间的相异性。 信号处理类的纹理特征主要是利用某种线性变换、滤波器或者滤波器组将纹理转换到变换域，然后应用某种能量准则提取纹理特征。因此，基于信号处理的方法也称之为滤波方法。大多数信号处理方法的提出，都基于这样一个假设：频域的能量分布能够鉴别纹理。 信号处理法的经典算法有：灰度共生矩阵、Tamura纹理特征、自回归纹理模型、小波变换等。
优点： 对纹理进行多分辨表示，能在更精细的尺度上分析纹理；小波符合人类视觉特征，由此提取的特征也是有利于纹理图像分割；能够空间/频域结合分析纹理特征。缺点： 正交小波变换的多分辨分解只是将低频部分进行进一步的分解，而对高频部分不予考虑；而真实图像的纹理信息往往也存在于高频部分。小波包分析虽然克服了这一缺点，但对非规则纹理又似乎无能为力；小波多应用于标准或规则纹理图像，而对于背景更复杂的自然图像，由于存在噪声干扰，或者某一纹理区域内的像素并非处处相似，导致正交小波变换往往效果不佳；计算量较大。 (5) 结构分析法 结构分析法认为，纹理是由纹理基元的类型、数目、以及基元之间的“重复性”的空间组织结构与排列规则来描述的，而且纹理基元几乎具有规范的关系。假设纹理图像的基元可以被分离出来，以基元特征和排列规则进行纹理分割，显然结构分析法要解决的问题，就是确定与抽取基本的纹理单元，以及研究存在于纹理基元之间的“重复性”结构关系。 由于结构分析法强调纹理的规律性，所以比较适用于分析人造纹理，然而真实世界大量自然纹理通常是不规则的。此外，解耦股的变化是频繁的，所以结构分析法的应用受到很大程度的限制。 结构分析法的典型算法：句法纹理描述算法、数学形态学方法。
综上所述，在提取纹理特征的有效性方面，统计方法、模型法和信号处理法相较于几何法与结构分析法，可以说相差无几，都获得了认可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b2e299bbe63a71a9e4c610d90d2a4c/" rel="bookmark">
			Android读取联系人的姓名及电话号码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android中联系人的信息是通过ContentProvider来供外部应用获取的，我们使用时只需根据系统联系人ContentProvider的Uri即可获取所需数据。下面讲解如何获取联系人的姓名及电话号码，别的数据如邮箱、照片等数据的获取都可使用此方式。
首先在清单文件添加下述权限 &lt;uses-permission android:name="android.permission.WRITE_CONTACTS"/&gt; &lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt; &lt;uses-permission android:name="android.permission.GET_ACCOUNTS"/&gt; 其次编写布局文件 此布局有一个ListView 和一个Button，点击Button时获取姓名及电话号码并显示在ListView 上
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/lv_contacts" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_weight="1"/&gt; &lt;Button android:id="@+id/btn_contacts" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="获取联系人"/&gt; &lt;/LinearLayout&gt; Java代码 mGetContactsButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //getContacts()方法获取联系人的姓名及电话号码 ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1, getContacts()); //将姓名及电话号码显示到ListView上 mContactsListView.setAdapter(adapter); } }); private String[] getContacts() { //联系人的Uri，也就是content://com.android.contacts/contacts Uri uri = ContactsContract.Contacts.CONTENT_URI; //指定获取_id和display_name两列数据，display_name即为姓名 String[] projection = new String[] { ContactsContract.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60b2e299bbe63a71a9e4c610d90d2a4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bbac687581369f61ca87189f8f39107/" rel="bookmark">
			关于在winform使用iwebpdf遇到问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 iwebpdf是金格比较的一款比较好的中间件 可以阅读pdf 可以签章，iwebpdf 是COM控件的形式安装的，按常规使用COM控件的方式拖入控件会引起ide的闪退,尝试多种方法和咨询了官方才知道这玩意不支持.net4.0的环境 支持.net2.0。于是将项目降级到2.0。在使用这个控件就没问题了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3f3d7e9cc787edcadb8dfa34a5ce13b/" rel="bookmark">
			【html】设置有滚动条的select
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题提出：select默认的会将所有的option全部显示出来，当数据过多时，下拉框会显得很长。
期待结果：带有滚动条，显示一定数量的option，通过滚动查看更多option。
第一种方式：
效果展示：
源码：
&lt;select class='newsTypeList' οnfοcus="selectFocus(this)"&gt; &lt;option οnclick="selectClick(this)"&gt;1&lt;/option&gt; &lt;/select&gt; window.selectFocus = function(that) { $(that).attr("size", 5); }; window.selectClick = function(that) { $(that).parent().removeAttr("size"); $(that).parent().blur(); $(that).parent().children("[selected='selected']").removeAttr("selected"); $(that).attr("selected", ""); }; 第二种方式：
使用input和selec组合实现
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Combobox&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;style type="text/css"&gt; *{ box-sizing:border-box; } input,select{ width: 200px; } #words{ display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input id="show" type="text" name=""&gt; &lt;br /&gt; &lt;select id="words"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;option&gt;D&lt;/option&gt; &lt;option&gt;E&lt;/option&gt; &lt;option&gt;F&lt;/option&gt; &lt;option&gt;G&lt;/option&gt; &lt;/select&gt; &lt;script type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3f3d7e9cc787edcadb8dfa34a5ce13b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e1fbce1281454e426a5f72ba626aa3/" rel="bookmark">
			微信小程序循环赋值坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在弄微信小程序，类似于共享单车用来练练手，基本原理就是小程序发送经纬度给服务器，服务器从数据库中检索经纬度附近的单车传给小程序。
就在这里。。没错就是这里，传回来的值是以jsonarray格式传过来的。
我需要将jsonarray进行解析获取经纬度，ID等车辆信息，然后赋值给小程序地图上的mark，一般我的思路时直接用个for循环给每个mark进行赋值然后再Setdata一下就ok，
结果没想到小程序setData()设置数组对象的某个元素的属性时根本没用。。。。。
然后百度一会儿找到了方法 http://blog.csdn.net/hicoldcat/article/details/53967334
/
最近在使用微信小程序的setData时，遇到了以下问题。如下： 官网文档在使用setData()设置数组对象的某个元素的属性时，是这么使用的： Page({ data: { array: [{text: 'init data'}], }, changeItemInArray: function() { this.setData({ 'array[0].text':'changed data' }) } }) 12345678910 使用了 ‘array[0].text’ : ‘changed data’ 这样的值。但在实际使用中，我们对数组的中的某个元素的设置是动态的。即 我们通常应该是‘array[‘+index+’].text’ : ‘changed data’ ,其中index应该是一个动态的数字。但显然，这样是无法使用在对象的key中的。 所以，我只能使用了一个变通的方法。如下： var param = {}; var string = "array["+index+"].text; param[string] = 'changed data'; that.setData(param); / 这个每个属性都需要来一次。。。
不知道是我没找到更好的方法还是怎样，我的强迫症都出来了。。
下面就是我的代码。。。
markers: {
iconPath: "/picture/bike.png",
id: 0,
latitude: 23.099994,
longitude: 113.324520,
width: 50,
height: 50
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e1fbce1281454e426a5f72ba626aa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e63d76a80318dc9562f9a30770db9531/" rel="bookmark">
			Retinex图像增强算法(SSR, MSR, MSRCR)详解及其OpenCV源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Retinex图像增强算法(SSR, MSR, MSRCR)详解及其OpenCV源码 Retinex是一种常用的建立在科学实验和科学分析基础上的图像增强方法，它是Edwin.H.Land于1963年提出的。就跟Matlab是由Matrix和Laboratory合成的一样，Retinex也是由两个单词合成的一个词语，他们分别是retina 和cortex，即：视网膜和皮层。Land的retinex模式是建立在以下三个假设之上的：
真实世界是无颜色的，我们所感知的颜色是光与物质的相互作用的结果。我们见到的水是无色的，但是水膜—肥皂膜却是显现五彩缤纷，那是薄膜表面光干涉的结果。每一颜色区域由给定波长的红、绿、蓝三原色构成的；三原色决定了每个单位区域的颜色。 Retinex理论的基础理论是物体的颜色是由物体对长波（红色）、中波（绿色）、短波（蓝色）光线的反射能力来决定的，而不是由反射光强度的绝对值来决定的，物体的色彩不受光照非均匀性的影响，具有一致性，即retinex是以色感一致性（颜色恒常性）为基础的。不同于传统的线性、非线性的只能增强图像某一类特征的方法，Retinex可以在动态范围压缩、边缘增强和颜色恒常三个方面达到平衡，因此可以对各种不同类型的图像进行自适应的增强。
40多年来，研究人员模仿人类视觉系统发展了Retinex算法，从单尺度Retinex算法，改进成多尺度加权平均的MSR算法，再发展成彩色恢复多尺度MSRCR算法。笔者在本文中，从原理阐述算法的流程，并提供源码地址。
参考链接： http://blog.csdn.net/carson2005/article/details/9502053 http://www.cnblogs.com/Imageshop/archive/2013/04/17/3026881.html 参考论文： 《一种结合直方图均衡化和MSRCR的图像增强新算法》——李锦 等人
一. 单尺度SSR(Single Scale Retinex) 1. 原理 一幅给定的图像S(x,y)可以分解为两个不同的图像：反射图像R(x,y)和入射图像（也有人称之为亮度图像）L(x,y)，其原理图如下所示： 如上图所示，图像可以看做是入射图像和反射图像构成，入射光照射在反射物体上，通过反射物体的反射，形成反射光进入人眼。最后形成的图像可以如下公式表示： r(x,y)=logR(x,y)=logS(x,y)L(x,y) 其中，R(x, y)表示了物体的反射性质，即图像内在属性，我们应该最大程度的保留；而L(x, y)表示入射光图像，决定了图像像素能达到的动态范围，我们应该尽量去除。 一般，我们把照射图像假设估计为空间平滑图像，原始图像为S(x, y)，反射图像为R(x, y)，亮度图像为L(x, y)，可以得出上面的公式(1)，以及下面的公式：
r(x,y)=logR(x,y)=logS(x,y)L(x,y) …………(2)
r(x,y)=logS(x,y)−log[F(x,y)⨂S(x,y)] ………….(3)
这里，r(x, y)是输出图像，式(3)中后面中括号里的运算是卷积运算。F(x, y)是中心环绕函数，表示为：
F(x,y)=λe−(x2+y2)c2 ………….(4)
式(4)中的C是高斯环绕尺度，λ是一个尺度，它的取值必须满足下式：
∫∫F(x,y)dxdy=1 ………….(5)
上面的式中可以看出，SSR算法中的卷积是对入射图像的计算，其物理意义是通过计算像素点与周围区域在加权平均的作用下，估计图像中照度的变化，并将 L(x,y) 去除，只保留 S(x,y) 属性。
2. 算法的实现流程 单尺度Retinex算法SSR的实现流程可以概括如下：
读原图S(x, y)： 若原图为灰度图：将图像各像素的灰度值由整数型(int)转换为浮点数(float)，并转换到对数域；若原图为彩色图：将颜色分通道处理，每个分量像素值由整数型(int)转换为浮点数(float)，并转换到对数域；输入高斯环绕尺度C，把积分运算离散化，转为求和运算，通过上式(4)(5)确定λ的值；由式(3)得r(x, y)； 若原图是灰度图，则只有一个r(x, y)；若原图为彩色图，则每个通道都有一个对应的r(x, y)；将r(x, y)从对数域转换到实数域，得到输出图像R(x, y)；此时的R(x, y)值的范围并不是0–255，所以还需要进行线性拉伸并转换成相应的格式输出显示。 前面的公式中，中心环绕函数F(x, y)用的是低通函数，这样能够在算法中估计出入射图像对应原始图像的低频部分。从原始图像中除去低频照射部分，就会留下原始图像所对应的高频分量。高频分量很有价值，因为在人类的视觉系统中，人眼对边缘部分的高频信息相当敏感，所以SSR算法可以较好的增强图像中的边缘信息。 由于SSR算法中所选用的高斯函数特点，对于动态范围大幅度压缩和对比度增强两个指标，增强后的图像不能同时保证。但是为了平衡两种增强效果，就必须选择一个较为恰当的高斯尺度常量C。C值一般取值在80–100之间。
3. OpenCV源码 见源码附录的Retenix()函数。
二. 多尺度MSR(Multi-Scale Retinex) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e63d76a80318dc9562f9a30770db9531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a251141fb1ad29c6762c8e9afeaf227f/" rel="bookmark">
			数据库设计 - 01外卖配送系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tb_delivery(配送地址表) 字段 类型 属性 空 默认 备注 id bigint(20) unsigned primary key AUTO_INCREMENT 否 唯一标识 address varchar(255) 否 配送地址 linkman varchar(60) 否 联系人 phone varchar(11) 否 手机号码 sex tinyint(1) unsigned 否 0 性别 province varchar(50) 否 空 省 city varchar(50) 否 空 市 district varchar(50) 否 空 区 tag tinyint(3) unsigned 否 空 标签 created datetime 否 0000-00-00 00:00:00 创建时间 updated timestamp on update CURRENT_TIMESTAMP 否 CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 修改时间 deleted tinyint(1) unsigned 否 0 是否删除 备注：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a251141fb1ad29c6762c8e9afeaf227f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ffb1b11d736518fcf49c2e7a1555cef/" rel="bookmark">
			YII2.0框架(三) 缓存机制yii\caching\Cache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘自：http://www.yiichina.com/doc/guide/2.0/caching-data
一、Yii 缓存机制
1.数据缓存
$cache = new \yii\caching\FileCache(); //文件缓存
$key = 'name';
$value = 'value11111111111';
$duration = 100;
$data = [
['name' =&gt; 'name'],
['value' =&gt; 'value']
];
$exists = $cache-&gt;exists($key); //检查指定的键是否存在缓存中
$buildKey = $cache-&gt;buildKey($key); //检查指定的键是否存在缓存中,超过32位使用MD5加密
$get = $cache-&gt;get($key); //从缓存中取得指定键的值
$set = $cache-&gt;set($key, $value, $duration); //将指定键的值存储在缓存中
$multiSet = $cache-&gt;multiSet($data, $duration); //将多条数据存在缓存中
$add = $cache-&gt;add($key, $value, $duration); //将多条数据存在缓存中
$delete = $cache-&gt;delete($key); //删除指定键值的数据
$flush = $cache-&gt;flush($key); //从缓存中删除所有数据 2.片段缓存
&lt;?php
/*@var $this yii\web\View*/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ffb1b11d736518fcf49c2e7a1555cef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c06e2cb52108cb162549dd48aee80cbf/" rel="bookmark">
			页面引用bootstrap报错Bootstrap&#39;s JavaScript requires jQuery
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导致这个报错的原因是bootstrap加载的顺序有问题，必须先引用jquery.min.js文件，然后再引用botstrap的js。
如下
&lt;script src="../js/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="../js/ajax.js"&gt;&lt;/script&gt; &lt;script src="../js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;script src="../js/bootstrap.js"&gt;&lt;/script&gt; &lt;script src="../js/angular.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css"&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d1f68c7e655330c8cf995007c83eb2/" rel="bookmark">
			TCP接入层的负载均衡、高可用、扩展性架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、web-server的负载均衡
互联网架构中，web-server接入一般使用nginx来做反向代理，实施负载均衡。整个架构分三层：
上游调用层，一般是browser或者APP
中间反向代理层，nginx
下游真实接入集群，web-server，常见web-server的有tomcat，apache
整个访问过程为：
browser向daojia.com发起请求
DNS服务器将daojia.com解析为外网IP(1.2.3.4)
browser通过外网IP(1.2.3.4)访问nginx
nginx实施负载均衡策略，常见策略有轮询，随机，IP-hash等
nginx将请求转发给内网IP(192.168.0.1)的web-server
由于http短连接，以及web应用无状态的特性，理论上任何一个http请求落在任意一台web-server都应该得到正常处理（如果必须落在一台，说明架构不合理，不能水平扩展）。
问题来了，tcp是有状态的连接，客户端和服务端一旦建立连接，一个client发起的请求必须落在同一台tcp-server上，此时如何做负载均衡，如何保证水平扩展呢？
二、单机法tcp-server
单个tcp-server显然是可以保证请求一致性：
client向tcp.daojia.com发起tcp请求
DNS服务器将tcp.daojia.com解析为外网IP(1.2.3.4)
client通过外网IP(1.2.3.4)向tcp-server发起请求
方案的缺点？
无法保证高可用。
三、集群法tcp-server
通过搭建tcp-server集群来保证高可用，客户端来实现负载均衡：
client内配置有tcp1/tcp2/tcp3.daojia.com三个tcp-server的外网IP
客户端通过“随机”的方式选择tcp-server，假设选择到的是tcp1.daojia.com
通过DNS解析tcp1.daojia.com
通过外网IP连接真实的tcp-server
如何保证高可用呢？
如果client发现某个tcp-server连接不上，则选择另一个。
潜在的缺点？
每次连接前，需要多实施一次DNS访问：
难以预防DNS劫持
多一次DNS访问意味着更长的连接时间，这个不足在手机端更为明显
如何解决DNS的问题？
直接将IP配置在客户端，可以解决上述两个问题，很多公司也就是这么做的（俗称“IP直通车”）。
“IP直通车”有什么新问题？
将IP写死在客户端，在客户端实施负载均衡，扩展性很差：
如果原有IP发生变化，客户端得不到实时通知
如果新增IP，即tcp-sever扩容，客户端也得不到实时通知
如果负载均衡策略变化，需要升级客户端
四、服务端实施负载均衡
只有将复杂的策略下沉到服务端，才能根本上解决扩展性的问题。
增加一个http接口，将客户端的“IP配置”与“均衡策略”放到服务端是一个不错的方案：
client每次访问tcp-server前，先调用一个新增的get-tcp-ip接口，对于client而言，这个http接口只返回一个tcp-server的IP
这个http接口，实现的是原client的IP均衡策略
拿到tcp-server的IP后，和原来一样向tcp-server发起TCP长连接
这样的话，扩展性问题就解决了：
如果原有IP发生变化，只需要修改get-tcp-ip接口的配置
如果新增IP，也是修改get-tcp-ip接口的配置
如果负载均衡策略变化，需要升级客户端
然而，新的问题又产生了，如果所有IP放在客户端，当有一个IP挂掉的时候，client可以再换一个IP连接，保证可用性，而get-tcp-ip接口只是维护静态的tcp-server集群IP，对于这些IP对应的tcp-server是否可用，是完全不知情的，怎么办呢？
五、tcp-server状态上报
get-tcp-ip接口怎么知道tcp-server集群中各台服务器是否可用呢，tcp-server主动上报是一个潜在方案，如果某一个tcp-server挂了，则会终止上报，对于停止上报状态的tcp-server，get-tcp-ip接口，将不返回给client相应的tcp-server的外网IP。
该设计的存在的问题？
诚然，状态上报解决了tcp-server高可用的问题，但这个设计犯了一个“反向依赖”的耦合小错误：使得tcp-server要依赖于一个与本身业务无关的web-server。
六、tcp-server状态拉取
更优的方案是：web-server通过“拉”的方式获取各个tcp-server的状态，而不是tcp-server通过“推”的方式上报自己的状态。
这样的话，每个tcp-server都独立与解耦，只需专注于资深的tcp业务功能即可。
高可用、负载均衡、扩展性等任务由get-tcp-ip的web-server专注来执行。
多说一句，将负载均衡实现在服务端，还有一个好处，可以实现异构tcp-server的负载均衡，以及过载保护：
静态实施：web-server下的多个tcp-server的IP可以配置负载权重，根据tcp-server的机器配置分配负载（nginx也有类似的功能）
动态实施：web-server可以根据“拉”回来的tcp-server的状态，动态分配负载，并在tcp-server性能极具下降时实施过载保护
七、总结
web-server如何实施负载均衡？
利用nginx反向代理来轮询、随机、ip-hash。
tcp-server怎么快速保证请求一致性？
单机。
如何保证高可用？
客户配置多个tcp-server的域名。
如何防止DNS劫持，以及加速？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d1f68c7e655330c8cf995007c83eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80d2c1ec139df4fd1940377352dc62d6/" rel="bookmark">
			经纬度计算两地之间的距离（原理与方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 怎么用经纬度计算两地之间的距离？ 1、地球赤道上环绕地球一周走一圈共40075.04公里,而@一圈分成360°,而每1°(度)有60,每一度一秒在赤道上的长度计算如下： 40075.04km/360°=111.31955km 111.31955km/60=1.8553258km=1855.3m 而每一分又有60秒,每一秒就代表1855.3m/60=30.92m 任意两点距离计算公式为 d＝111.12cos{1/[sinΦAsinΦB十cosΦAcosΦBcos(λB—λA)]} 其中A点经度，纬度分别为λA和ΦA，B点的经度、纬度分别为λB和ΦB，d为距离。 2、分为3步计算： 第1步 分别将两点经纬度转换为三维直角坐标： 假设地球球心为三维直角坐标系的原点，球心与赤道上0经度点的连线为X轴，球心与赤道上东经90度点的连线为Y轴，球心与北极点的连线为Z轴，则地面上点的直角坐标与其经纬度的关系为： x=R×cosα×cosβ y=R×cosα×sinβ z=R×sinα R为地球半径，约等于6400km； α为纬度，北纬取+，南纬取-； β为经度，东经取+，西经取-。 第2步 根据直角坐标求两点间的直线距离（即弦长）： 如果两点的直角坐标分别为(x1,y1,z1)和(x2,y2,z2)，则它们之间的直线距离为： L=[(x1-x2)^2+(y1-y2)^2+(z1-z2)^2]^0.5 上式为三维勾股定理，L为直线距离。 第3步 根据弦长求两点间的距离（即弧长）： 由平面几何知识可知弧长与弦长的关系为： S=R×π×2[arc sin(0.5L/R)]/180 上式中角的单位为度，1度＝π/180弧度，S为弧长。 3、1度的实际长度是111公里。但纬线的距离会越考两端越小，他的距离就会变成111乘COS纬度数，经度不变。 4、南北方向算出两点纬度差,一度等于60海里,1分等于1海里,海里与公里换算关系1海里等于1.852公里。东西方向量出距离到两点间纬度附近量出纬度差，得出海里数，再乘以1.852换算成公里。可按直角三角形原理求出两点间距离。 5、度的实际长度是111公里。但纬线的距离会越考两端越小，他的距离就会变成111乘COS纬度数，经度不变(如果在同一经度) 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/452/">«</a>
	<span class="pagination__item pagination__item--current">453/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/454/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>