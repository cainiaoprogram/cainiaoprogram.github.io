<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fde141759d8804f826cfcc9660d2117/" rel="bookmark">
			AlmaLinux Centos 8.5 如何进入单用户模式并重置root密码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AlmaLinux Centos 8.5 如何进入单用户模式并重置root密码？
其实, AlmaLinux Centos 8.5 跟Centos 7.2一样，在忘记root密码后，如果linux是使用grub引导，直接修改grub的引导参数后进入单用户模式，然后在单用户模式下输入命令“passwd root”，按“enter”键，输入新的密码，再次输入确定密码；最后输入重启系统，即可使用新的密码啦！
如何进入单用户模式并修改密码呢？具体方法有如下两种：
方法一 1.1 重启服务器，一直按“E”键,进入grub引导菜单的内核界面 1.2 在内核详情界面使用上下箭头移动光标选择要进行修改的行（启动权限所在行）； 1.3 启动权限所在行选定之后再次按下“E”键进行编辑； 先将所在行中的 ro（只读权限）改为：rw （可读可写权限）； 然后在此行的行末尾添加 rhgb quiet init=/bin/sh (如果所在行末尾已经有rhgb quiet，则行末尾只添加 init=/bin/sh)； 1.4 按住Ctrl+x执行刚刚修改的内容； 1.5 然后来到单用户模式界面（可以用命令runlevel查看目前处于哪个运行基本，此处我省略）； 1.6 修改用户密码 非明文修改密码
默认修改root密码，也可以修改其他用户的密码 （passwd 其他用户名） passwd root 输入新密码： 再次输入新密码： touch /.autorelabel &amp;&amp; echo $? exec /sbin/init 明文修改密码
建议明文修改密码，保不准万一键入问题又被搞死，修改完成后，创建隐藏文件 /.autorelabel , 让selinux 重新打标签，最后执行命令 exec /sbin/init 退出单用户模式并快速重新启动系统以使新密码生效。
echo '新密码' | passwd --stdin root touch /.autorelabel &amp;&amp; echo $?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fde141759d8804f826cfcc9660d2117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f341d74d84f5991b357c3a43e72df1b/" rel="bookmark">
			USB 设备返回的 USB BOS 描述符无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装fastboot电脑端驱动，出现感叹号，驱动程序报错：USB 设备返回的 USB BOS 描述符无效。
但是换了其他的电脑，就可以正常安装使用。说明开发板是没有问题的。
然后各种百度都不行，研究了整整两天都没解决。然后必应国际版搜索英文，终于找到解决办法了。
[Q] USB BOS descriptor failed, “waiting for device”, “Device cannot start. (Code 10)”
果然，自己的USB接到电脑的3.0接口了，尝试了一下，将USB接到电脑的2.0端口，驱动程序就正常了。干！百度查了各种办法都没解决，原来就这么简单，U口插错了而已！！！
不得不说，作为程序员，有些问题还是得用英文搜索，要培养自己得英文阅读网页能力！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c43e7a4fc577fef36b4943b188e73986/" rel="bookmark">
			JDK1.8安装和环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 1、运行JDK安装包
jdk-8u181-windows-x64
2、进入开始安装向导界面，单击下一步。如图所示。
3、选择jdk安装目录。单击“下一步”。
4、开始安装，等待安装完成。
5、单击确定，继续安装。
6、默认选择，单击“下一步”。
7、等待安装完成。如图所示。
8、安装完成。点击“关闭”。接下来配置环境变量。
9、配置环境变量。打开控制面板，选择“系统和安全”，选择“系统”，选择“高级系统设置”。如图所示。
10、打开后，选择“环境变量”。如图所示。
环境变量配置 11、点击系统变量下面的“新建”按钮，进行环境变量配置。
12、变量名JAVA_HOME（代表你的JDK安装路径），值对应的是JDK的安装路径。如图所示。
变量名：JAVA_HOME
变量值：C:\Program Files\Java\jdk1.8.0_181 //根据自己的实际路径配置
13、继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示。
变量名：CLASSPATH
变量值：.;%JAVA_HOME%\lib
14、在系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码。确定保存。
%JAVA_HOME%\bin
测试java环境变量配置是否正确 java -version 2. java
3. javac
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b21253f39d063811527b104a7fda778/" rel="bookmark">
			simulink——产生阶梯波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		simulink产生阶梯波的方法有很多种，下面我只介绍用模块搭建产生可调阶梯波。
具体如下：
运行结果如下：
黄色是三角波，蓝色是阶梯波。原理就是把三角波经过采样生成阶梯波，这里离散采样时间设置的是5，如下图：
sample time = 非零正数，例如2，3等，表示离散采样时间，例如我们输入的信号采样周期是0.01秒，那么此处的sample time就可以填成0.01。
至此，产生阶梯波的介绍基本完毕，不足之处，大家见谅！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40191674f70bbc1c84cb40af78801f27/" rel="bookmark">
			I/O流基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I/O流基础 I/O流基础I/O流概述字节流字节流的读/写操作 字符流字符流的读/写操作 I/O流基础 I/O流分为很多种，按照操作数据的不同，可以分为字节流和字符流，按照数据传输的方向又可以分为输入流和输出流，程序从输入流中读取数据，向输入流中写入数据。
I/O流概述 在I/O包中：
字节流的输入/输出分别用java.io.InputStream和java.io.OutputStream表示。字符流的输入/输出分别用java.io.Reader和java.io.Writer表示。
字节流 在计算机中，无论是文本、图片还是音频和视频，都是以字节的形式存在的，因此要对这些文件进行传输就需要使用字节流，字节流是程序中最常用的流。
根据数据传输方向的不同可将其分为字节输入流和字节输出流，在JDK中提供了两个抽象类InputStream和OutputStream表示字节输入流和字节输出流，他们是字节流的两个顶级父类。
InputStream的常用方法:
方法声明功能描述int read()从输入流中读取数据的下一个字节int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中int read(byte[] b,int off,int len)从输入流中读取若干字节，把它们保存到参数 b 指定的字节数组中，off 指定字节数组开始保存数据的起始下标，len 表示读取的字节数目void close()关闭此输入流并释放与该流关联的所有系统资源 与InputStream对应的是OutputStream。OutputStream用与写数据，因此OutputStream提供了一些与写数据有关的方法。
InputStream的常用方法:
方法声明功能描述void write(int b)将指定的字节写入此输出流void write(byte[] b)将b.length个字节从指定的byte数组写入此输出流void write(byte[] b,int off,int len)将指定byte数组中从偏移量off开始的len个字节写入输出流void flush()刷新此输出流并强制写出所有缓冲的输出字节void close()关闭此输出流释放与此流有关的所有系统资源 字节流的读/写操作 字节流的读操作：
import java.io.File; import java.io.FileInputStream; public class IORead { public static void main(String[] args) { FileInputStream stream = null; try { // 文件的路径 File file = new File("D:\\ideaCode\\testdemo\\src\\Test.txt"); stream = new FileInputStream(file); int i = 0; while (true) { i = stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40191674f70bbc1c84cb40af78801f27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10644306e0939b68398750567dd16176/" rel="bookmark">
			Excel表格中带公式的数值如何复制？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Excel表格中带公式的数值如何复制？ 目录
Excel表格中带公式的数值如何复制？
1、首先选中复制有公式的单元格，选择“复制”
2、在单元格中右键打开弹窗点击“选择性粘贴”，在粘贴选项中选择“数值”或“值和数字格式”。
1、首先选中复制有公式的单元格，选择“复制” 2、在单元格中右键打开弹窗点击“选择性粘贴”，在粘贴选项中选择“数值”或“值和数字格式”。 安利一个R语言的优秀博主及其CSDN专栏：
博主博客地址：
Data+Science+Insight的博客_CSDN博客-R语言从入门到机器学习,数据科学从0到1,机器学习面试+横扫千军领域博主
安利一个R语言的优秀博主及其CSDN专栏： 博主为CSDN数据科学领域知名博主（博客内容包括：数据科学从0到1、R语言从入门到机器学习、机器学习面试+横扫千军、Python编程技巧高效复用等系列） 毕业于中国科学院大学智能计算专业。研究方向为，数据挖掘、机器学习、深度学习等。深度参与了多项数据挖掘、计算机视觉以及自然语言处理相关项目，例如，社会计算、异常分析、聚类分析、预测分析、序列标记、语言生成、OCR、图像分类+检测+分割等。现任某茅数据科学家，负责数据科学团队的管理及项目实施。曾就职于中国信科集团，负责大数据与机器学习组的管理及项目实施。曾参与国家级医疗大数据平台机器学习项目的开发和建设、构建了完整的数据链路、特征池、模型仓库、迁移中心、数据应用、数据服务Pipeline，并与AWS中国基于AWS云服务合作开发大型工业互联网项目，积累了工业互联网模型构建、部署、监控实战经验。
Microsoft Excel是Microsoft为使用Windows和Apple Macintosh操作系统的电脑编写的一款电子表格软件。直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，使Excel成为最流行的个人计算机数据处理软件。在1993年，作为Microsoft Office的组件发布了5.0版之后，Excel就开始成为所适用操作平台上的电子制表软件的霸主。
在 Excel中，函数实际上是一个预先定义的特定计算公式。按照这个特定的计算公式对一个或多个参数进行计算，并得出一个或多个计算结果，叫做函数值。使用这些函数不仅可以完成许多复杂的计算，而且还可以简化公式的繁杂程度。
我们生活的这个世界是丰富多彩的，几乎所有的知识都来自于视觉。也许无法记住一连串的数字，以及它们之间的关系和趋势。但是可以很轻松地记住一幅图画或者一个曲线。因此通过使用图表，会使得用Excel编制的工作表更易于理解和交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4afb18154485edf27401da95f672a1/" rel="bookmark">
			微信小程序路线规划导航，选择起点和终点路线规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
实现： 先添加插件
微信小程序插件 | 腾讯位置服务
腾讯位置服务路线规划 | 小程序插件 | 微信公众平台
在app.json添加插件：
"plugins": { "routePlan": { "version": "1.0.19", "provider": "wx50b5593e81dd937a" } } 代码：
// pages/discovery/index.js const app = getApp() import { wxAppStop } from '../../utils/util' import markers from './markers.js' let plugin = requirePlugin('routePlan'); let key = 'QHMBZ-HR3CO-CJ6WM-SS4CM-4PINO-2ZBAM'; //使用在腾讯位置服务申请的key let referer = '红狼'; //调用插件的app的名称 var isQiDian = ""; var isZhongDian = ""; Page({ /** * 页面的初始数据 */ data: { isStop: false, longitude: '87.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee4afb18154485edf27401da95f672a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b7e0d67c2055d2495cb74aef9426d7/" rel="bookmark">
			springboot前后端分离-使用微信扫码登录（后端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot前后端分离-使用微信扫码登录（后端） 最近项目需要，临时加入了微信扫码登录的功能，让身为小白的我很是折磨，在网上搜了很多的教程，也被一些cv博客误导了许久，本篇blog主要从小白（我自己）的角度介绍前后端分离项目中如何接入微信扫码登录功能（仅后端）
扫码登录的基本流程 使用微信扫码登录 我们肯定要先来了解一下扫码登录的基本流程啦
前端首先向服务端发送一个请求，用来获取二维码的url和唯一随机数（用UUID即可，这个随机数可以理解为这个二维码的key值，一一对应，所以尽量要用唯一的）同时服务端要记录这条随机数（存redis和其他数据库均可，找个地方记录下来）前端自从收到二维码和随机数后，展示二维码，并轮询一个检查二维码状态的接口（用来判断用户是否扫码并确认）很关键的一步客户扫码并确认后，会回调给服务端一个请求，服务端就能拿到对应的二维码的key（之前产生的随机数）前端轮询中 发现二维码状态值变为用户扫码已确认的值后，向后端发送业务请求（登录。。。。） 微信扫码登录的流程 首先你要有微信开放平台的资质和已审核过的应用（这里我就不过多赘述了，实际我也不太懂##）
官方文档：https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html
首先要在微信开放平台网站应用里设置授权回调域
这个地方要注意不要加http:// https://前缀 要用域名，不要用ip地址 可以加端口号（我自己做的时候加了端口号，是可以的，但是我不知道有些博客上说不能加端口）（不要在这加接口哈！至于微信是怎么知道回调的接口的 是在获取二维码url时候拼接一个请求wx的url，在这个url里有一个redirect_uri参数 在这里指定接口）
本机测试的话 建议进行一下内网穿透 我使用的工具（https://suidao.oauth.k9s.run/）
coding的流程 给微信发个请求 获取二维码url
这部其实就是拼接请求url 具体看下官方文档 我在这里就不cv了
注：我这里state的作用：把二维码和一个随机数绑定起来（随机数可理解为二维码的key，设为唯一的）
把state设为这个key 并发送给前端，让前端轮询的时候带上这个key
/** * 生成二维码 * @return */ @GetMapping("/getWechatQtCode") public Object getWechatQtCode(){ JSONObject res = new JSONObject(); try { // 生成随机数 作为二维码的key String key = UUID.randomUUID().toString().replace("-",""); String redirectUri2 = URLEncoder.encode(redirectUri,"utf-8"); String oauthUrl = " https://open.weixin.qq.com/connect/qrconnect" + "?appid=" + appId + "&amp;redirect_uri=" + redirectUri2 + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8b7e0d67c2055d2495cb74aef9426d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a82580d934f75e38e505ee8a0e9333/" rel="bookmark">
			VOSviewer | （二）入门-分析web of science
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.文献下载 按需求搜索，wos一次只能导出500条文献信息，如果相关文献过多，可以按被引排序。
导出-制表符分隔文件-全记录与引用的参考文献
2.可视化实现 打开VOSviewer软件，单击左区Map下的create，选择“create a map based on bibliographic data”，导入文献计量数据集。
选择刚才下载的文件~可以多选
设置相关参数
点击finish即可呈现结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3023faa1e7703c3b0a16a1009caacf/" rel="bookmark">
			分析 WebAssembly 二进制文件 - Wasm 逆向工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们最近发表了一篇关于WebAssembly (Wasm)的安全问题和基本概念的博文。作为后续，这篇文章将介绍 Wasm 应用程序的逆向工程。考虑一下您遇到未知 Wasm 应用程序的场景，您需要弄清楚它的作用。你将如何分析它？目前几乎没有任何关于该主题的有用文档，因此我们决定部分填补这一空白。
Wasm 应用程序可以通过不同的方式进行分析。今天我们将通过一个非常简单的应用程序来介绍 Chrome 内置的 Wasm 调试功能。随着我们的进行，一些理论将被介绍。
想要直接了解更多技术内容的不耐烦的读者可以从附录部分获取 HTML 文件 test.html，然后直接跳转到“调试我们的示例应用程序”部分。
为什么要分析 Wasm？ 为什么我们首先对分析 Wasm 应用程序感兴趣？在深入研究动手技术之前，让我们回答这个问题。
在 Forcepoint，我们对恶意行为者如何利用新兴技术和技术感兴趣。每当出现新的威胁时，例如新的勒索软件系列、物联网蠕虫或更不寻常的东西，安全研究人员都希望分析该恶意代码的功能。当我们知道恶意软件是如何工作的，并且我们知道它的属性时，我们可以编写签名来获得保护。
存在许多用于分析传统恶意软件的工具，无论是混淆的 JavaScript、恶意 Flash 对象、可移植可执行文件 (PE) 还是其他东西。存在一种行之有效的方法来分析这些类型的威胁。
正如我们在本系列的第一篇文章中提到的那样，Wasm 的情况有所不同。几乎没有关于如何分析 Wasm 应用程序的文档，而且大多数常见的逆向工程工具还不了解 Wasm。这篇博文试图阐明对 Wasm 二进制文件的逆向工程。
创建示例“Hello World”Wasm 应用程序 让我们从创建一个简单的 Wasm 应用程序开始，稍后我们将对其进行分析。我们将在浏览器中运行应用程序并使用 Chrome 的开发者工具对其进行分析。
要在浏览器中运行 Wasm 应用程序，我们需要一个 HTML 文件来加载和执行 Wasm 二进制文件。让我们来看看创建这个 HTML 文件的过程。（如前所述，我们最终将获得本文末尾附录中列出的文件。）
从以下骨架开始（我们将进一步修改）并将其保存为名为 test.html 的文件：
&lt;html&gt; &lt;script&gt; function test() { } &lt;/script&gt; &lt;body onLoad="test()"&gt; &lt;/body&gt; &lt;/html&gt; 为了便于设置并避免安装任何工具，让我们使用一个名为WasmFiddler的在线 Web 应用程序来生成我们的 Wasm。在 WasmFiddler 中，键入以下简单程序：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b3023faa1e7703c3b0a16a1009caacf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/609c76b369532474ebb8c09a60372b77/" rel="bookmark">
			无线渗透-----aircrack-ng破解WEP加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.WEP介绍
二.认证类型
1.开放系统认证
2.共享密钥认证
三.加密算法介绍
1.同步加密算法
2.异步加密算法
3.流加密和块加密
四.WEP加密和解密
1.加密
1.1加密介绍
1.2加密流程 五.Aircrack-ng常用工具包
六.Aireplay-ng的六种攻击模式详解
1.冲突模式
2.伪装客户端连接
3.交互模式
4.注入攻击
5.chop攻击模式
6.碎片包攻击模式
七.WEP wifi破解步骤
1.环境准备
1.1路由器介绍
1.2路由器配置
2.查看网卡是否连接kali
3.开启Monitor Mode工作模式
4.扫描附近的wifi
5.对目标所在的信道进行抓包
6.手工创建客户端连接
7.进行ARP注入攻击
8.使用Deautenticate攻击模式
9.手动连接AP
10.破解wifi，获取WEP密码
一.WEP介绍 我们平常在使用wifi的时候，往往会用到的加密方式主要有WEP（pre-RSNA),WPA(TKIP),WPA2(CCMP-AES),如果有个别对安全要求比较高的也会使用企业级加密（802.1x)
在最新的802.11-2010标准中，有明确的指出新的无线设备应该抛弃WEP和WPA加密方式，而且必须支持WPA2加密方式，但不得不接受的是，现在我们是有大多数设备并没有更新的那么快，广泛的WEP和WPA仍然在使用，而且新开发的设备也应该保持对他们的兼容，所以即使在最新开发的产品中也并没有完全按照802.11-2010的要求，直接放弃对WEP和WPA的支持
刚开始了解无线加密，也有必要从WEP加密开始掌握WEP-WPA-WPA2-802.1x等相关知识，一是这些东西在当前还用的上，二是后面哪些更高级的加密方法其实根本上还是基于WEP加密思想改进来的
无线加密主要是对数据在链路层进行加密，如下图，802.11主要对physical和Data-link层进行了定义，而数据链路层又被分成两个部分，媒介访问控制（MAC）和逻辑链路控制（LLC）。无线数据的加密处理就是在MAC和LLC两个阶段中间做的事情，加密的对象就是MSDU。
所以对于没有MSDP的无线帧是不用加密的，比如管理帧只携带layer2的信息，不需要加密；控制帧只有头部和尾部，不需要加密；空帧没有数据域（但有特定功能），也不需要加密；总之，需要加密的帧，往往是数据帧。
二.认证类型 加密的分类主要包括共享密钥认证和开放系统认证，WEP加密是共享密钥式，而TKIP，CCMP和802.1x则是开放系统，这两种分类个人觉得主要区别是先完成密钥认证再进行关联，还是先完成关联再进行密钥认证。。
比如，它要求无线客户端发送的authentication报文中指定加密方式，如果是共享密钥就会进行密钥的确认，如果是开放系统，则辉留到后面关联成功后进行密钥的确认.
1.开放系统认证 这种认证方式不需要确认STA的任何信息，它只是和AP进行一个招呼式的交互，这个过程中并没有交互身份信息，所以也可以认为是一个空加密。这样做的目的是，双方都认为应该再后面使用更安全的加密方式，在这里只是先打个招呼，STA先进来，我们慢慢坐下核对信息。所以STA发送的第一个Authentication报文只要表明自己使用的开放系统认证就好了，AP自然会给予successful答复，接着后面顺利完成关联。
2.共享密钥认证 这种认证方式使用WEP认证STA，所以这种认证的前提是STA和AP都有静态的WEP密钥，因此认证的目的就是确认两者使用的密钥是否一致。共享密钥认证是通过四个认证帧的交互来完成的，STA首先发送一个Authentication request给AP，然后AP会给STA恢复一个挑战明文，接着STA使用密钥对这个明文进行加密发送给AP，最后AP对其进行解密，如果能够解密成功并且明文一致则标识认证成功并回复
虽然看起来共享密钥认证比开放系统认证会更安全，其实实际上并不是这样，因为对于共享密钥认证，攻击者可以捕获明文内容，也可以捕获加密后的密文，那就很容易被破解，而且密钥一旦被破解，那么后面交互的所有数据包都能轻易的解密
三.加密算法介绍 根据加密算法的分类，可以分为同步加密算法和异步加密算法：
1.同步加密算法 这种算法不管是加密还是解密，都是使用同一个密钥，为了确保数据的安全，就需要对这个密钥进行保护，但问题是在进行认证的时候必须对这个密钥进行确认，那么就需要提出一种安全的确认密钥的方法，这些方法包括WEP，TKIP and CCMP
2.异步加密算法 这种算法包含了两个密钥，分别是公钥和私钥，公钥用于消息的加密，私钥用于消息的解密，所以即使好多人知道公钥，没有私钥也破解不了消息。
3.流加密和块加密 流加密以一个bit为单位进行处理，块加密以一个块为单位进行处理
四.WEP加密和解密 1.加密 1.1加密介绍 WEP是一个Layer 2的加密方式，它使用的是ARC4流加密。它有一个数据完整性校验操作，也就是Integrity Check Value（ICV），这个值是通过计算为加密的数据域（MSDU）而来的
802.11标准定义了两个WEP版本，分别是WEP-40和WEP-104支持64bit和128bit加密，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/609c76b369532474ebb8c09a60372b77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c8ffc57a23b174ef77617210db5a23/" rel="bookmark">
			数组中01，可以将数组的一段翻转（0 变 1, 1 变 0），求翻转后数组最多1的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这道题的关键思想：
翻转 0 变 1 ，相当于让 1 的个数 +1翻转 1 变 0 ，相当与让 1 的个数 -1 解题思路：
根据原来的数组 a[] 构造一个新的数组 b[]，
若 a[i] = 0 则 b[i] = 1若 a[i] = 1 则 b[i] = -1 对 b[] 求最长子段和，包含最长子段和的区间就是进行01翻转的区间。
代码略
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b16d3bca6baa1b528507a8e044760d/" rel="bookmark">
			19.系统知识-数字证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码学相关概念 明文(plain text)：发送人、接受人和任何访问消息的人都能理解的消息。
密文(cipher text)：明文消息经过某种编码后，得到密文消息。
加密(encryption)：将明文消息变成密文消息。
解密(decryption)：将密文消息变成明文消息。
算法：取一个输入文本，产生一个输出文本。
加密算法：发送方进行加密的算法。
解密算法：接收方进行解密的算法。
密钥(key)：只有发送方和接收方掌握的消息
对称密钥加密(Symmetric Key Cryptography)：加密与解密使用相同密钥。
非对称密钥加密(Asymmetric Key Cryptography)：加密与解密使用不同密钥，分为公钥和私钥
非对称密钥加密(Asymmetric Key Cryptography)：加密与解密使用不同密钥，分为公钥和私钥
对称加密算法 • 在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的，加密和解密都是使用同一个密钥。
• 通信双方采用相同的密钥来加解密会话内容，即一段待加密内容，经过同一个密钥的两次对称加密后，与原
来的结果一样。
• 举例说明：
根据异或性质：
(A ⊕ B) ⊕ B = A A
得到如下加密方法，其中C为密文，P为明文，K是双方约定的常量，
C = P ⊕ K K
对应的解密方法则为：
P = C ⊕ K K
这就是一种简单的对称密钥算法的过程，其中异或操作是对称加密、解密算法，K则是密钥
非对称加密算法 • 非对称加解密算法的密钥是成对出现的，公钥加密过的密文只有对应的私钥能解密；私钥签名过的密文可以
通过对应的公钥验签。原则上私钥是不能在网络中传递的。
• 双方通信时，首先要将密钥对中的公钥传给对方，这个密钥可以在不安全的信道中传输；传输数据时，先使
用自己持有的密钥做加密，对方只能用自己传输过去的密钥解密。
• 举例说明：
其中C表示密文，P表示明文，x是公钥，y是私钥，
并假设 xy= 1，则有下加解密方法
加密小游戏-第一回合 “小客”-&gt;“小服”：你好
“小服”-&gt;“小客”：你好，我是小服
因为消息是在网络上传输的，有人可以冒充自己是“小服”来向小客发送信息。所以会出现下面的情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71b16d3bca6baa1b528507a8e044760d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c4a589d234ab3e4e86d4e1de7ca223/" rel="bookmark">
			Win10版本太低更新不了怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Win10版本太低更新不了怎么办？很多朋友的电脑一直没有更新，就这么用着，后来才听说老是不更新不安全，所以开始想要进行更新，可是版本太低了，微软已经停止服务了，这种时候系统还没办法进行更新可怎么办。
电脑怎么快速重装Win10系统
如图所示，看edge浏览器图标的样子就知道Win10的版本很低，系统更新后很多地方感觉都不一样，只要电脑的配置不是太老，那么肯定是推荐大家更新一下的。
如何从低版本Win10升级到高版本？
其实到了更新的时候系统会自动提醒大家的，不过为了一些收不到通知的小伙伴着想，韩博士还是有必要和大家唠唠的。
1.按下WIN+I打开设置界面，快准狠找到“更新和安全”。
2.直接在“windows更新”中点击“检查更新”即可，电脑会自动帮你处理的。
但是如果你的系统版本已经停止服务，那么就无法进行自动更新了。
Win10系统各大版本何时终止服务？
虽然大家用的都是Win10，但是版本是不一样的。
目前win10 v1507/1511/1607/1703/1709/1803/1809/1903版本服务均已过期，微软不可能一直致力于服务某个版本，就连10岁大的win7都已经停止更新支持了。所以说人生错过了就无法再留住，要好好珍惜现有的一切。
俺搜罗了一堆资料后为大家带来详细的Win10版本服务终止时间，快来瞅瞅有没有你的win10。
如果你的Win10已经停止了服务，那么就没办法进行更新了。只能够采用其他的方法把系统弄成最新版本。这里推荐大家重装系统，很简单的。
1909版本即将在2022年5月停止服务，还没更新的要赶紧啦。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c693db15be965a5d79517d534a008fa9/" rel="bookmark">
			17.AD域和LDAP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LDAP需求分析 为了集中管理，容易维护和优化，降低运维成本，在任何计算机平台上，用很容易获得的而且数目不断增加的LDAP的客户端程序访问LDAP目录，更容易定制应用程序企业引用LDAP服务器。
LDAP服务器可以用“推”或“拉”的方法复制部分或全部数据，例如：可以把数据“推”到远程的办公室，以增加数据的安全性。复制技术是内置在LDAP服务器中的而且很容易配置。如果要在DBMS中使用相同的复制功能，数据库产商就会要你支付额外的费用，而且也很难管理。LDAP允许你根据需要使用ACI（一般都称为ACL或者访问控制列表）控制对数据读和写的权限。例如，设备管
理员可以有权改变员工的工作地点和办公室号码，但是不允许改变记录中其它的域。ACI可以根据谁访问数据、访问什么数据、数据存在什么地方以及其它对数据进行访问控制。因为这些都是由LDAP目录服务器完成的，所以不用担心在客户端的应用程序上是否要进行安全检查。
LDAP对于这样存储这样的信息最为有用，也就是数据需要从不同的地点读取，但是不需要经常更新。例如，这些信息存储在LDAP目录中是十分有效的：公司员工的电话号码簿和组织结构图；客户的联系信息；计算机管理需要的信息，包括NIS映射、email假名，等等；软件包的配置信息；公用证书和安全密匙。
LDAP概述 LDAP是Lightweight Directory Access Protocol的缩写，指轻量级目录访问协议（这个主要是相对另一目录访问协议X.500而言的；LDAP略去了x.500中许多不太常用的功能，且以TCP/IP协议为基础， 一般使用389端口进行数据传输。目录服务用于通过键-值类型格式存储、整理及表达数据。一般来讲，目录会面向查找、搜索以及读取操作做出优化，因此适用于经常引用但却较少变更的数据。）。目录服务和数据库很类似，但又有着很大的不同之处。数据库设计为方便读写，但目录服务专门进行了读优化的设计，因此不太适合于经常有写操作的数据存储。LDAP只是协议
LDAP概述-基本模型 LDAP协议分析 AD需求背景 AD域概述 活动目录Active Directory的缩写，面向微软服务器的目录服务，LDAP协议（轻量级目录访问协议）下的一种产品。它为用户管理网络环境各个组成要素的标识和关系提供了一种有力的手段
Active Directory存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。Active Directory使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。Active Directory 域内的 directory database（目录数据库）被用来存储用户账户、计算机账户、打印机和共享文件夹等对象，而提供目录服务的组件就是 Active Directory （活动目录）域服务（ActiveDirectory Domain Service，AD DS），它负责目录数据库的存储、添加、删除、修改与查询等操作 .
AD域特点及常用功能
1、特点
1）微软基于AD的域模式，最大的优点是实现了集中式管理。
2）回收并管理普通用户对客户机的权限。
3）AD是一个大的安全边界，用户只要在登录时验证了身份，这个域林中所有允许访问资源都可以直接访问，
不用再做身份验证，也提高的效率减少了维护成本。
4）对于用户好处，通过文件夹的重定向可以将所有用户桌面的“我的文档”重定向到文件服务器上。
2、常用功能
1）用户账号管理
2）权限管理
3）软件/补丁推送
域信任关系 创建域信任关系
域信任关系是有方向性的，如果A域信任B域，那么A域的资源可以分配给B域的用户；但B域的资源并不能分配给A域的用户，如果想达到这个目的，需要让B域信任A域才可以。
如果A域信任了B域，那么A域的域控制器将把B域的用户账号复制到自己的Active Directory中，这样A域内的资源就可以分配给B域的用户了。从这个过程来看，A域信任B域首先需要征得B域的同意，因为A域信任B域需要先从B域索取资源
域的信任关系的主动权掌握在被信任域手中而不是信任域。
•A域信任B域，意味着A域的资源有分配给B域用户的可能性，但并非必然性！如果不进行资源分配，B域的用户无法获得任何资源
域树
域树是Active Directory针对NT4的传统域模型所进行的重要改进。在NT4时代的域模型中，每个域都要使用没有层次结构的NETBIOS名称，而且域和域之间缺少关联，只能创建不能传递的域信任关系。这会在企业管理方面造成诸多不利因素：
首先域和域之间很难根据域名判断彼此间的隶属关系，例如beijing域和shanghai域；
其次由于域之间的信任关系不可传递，在域数量较多时光是创建域之间的完全信任就要耗费大量时间。假定有10个域，那我们在10个域之间要建立45次信任关系才能让这些域相互之间都完全信任。域树针对以上问题进行了很好的解决，域树的父域和子域之间由于使用了层次分明的DNS域名，只要根据域名我们就可以判断出两个域的隶属关系，例如有两个域abc.com和test.abc.com，我们可以很轻易地判断出后者是前者的子域。 组策略 组策略是一个允许执行针对用户或计算机进行配置的基础架构。
其实通俗地说，组策略和注册表类似，是一项可以修改用户或计算机设置的技术。
那组策略和注册表的区别在哪儿呢？
注册表只能针对一个用户或一台计算机进行设置；
组策略却可以针对多个用户和多台计算机进行设置。
举例：在一个拥有1000用户的企业中，如果我们用注册表来进行配置，我们可能需要在
1000台计算机上分别修改注册表。但如果改用组策略，那只要创建好组策略，然后通过一
个合适的级别部署到1000台计算机上就可以了。
组策略和Active Directory结合使用，可以部署在OU，站点和域的级别上，当然也可以部署
在本地计算机上，但部署在本地计算机并不能使用组策略中的全部功能，只有和Active
Directory配合，组策略才可以发挥出全部潜力。 组策略部署在不同级别的优先级是不同的，
本地计算机&lt;站点&lt;域&lt;OU。 我们可以根据管理任务，为组策略选择合适的部署级别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c693db15be965a5d79517d534a008fa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c4387d02186b00fb737db28c865567/" rel="bookmark">
			＜ 数据结构 ＞ 堆的应用 --- 堆排序和Topk问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、堆排序
法一：自己写堆进行排序
时间复杂度分析
法二：直接对数组建堆
①、向上调整建堆
②、向下调整建堆
向上建堆和向下建堆熟优？
升序能否建小堆？
排序（建大堆）
2、TopK问题
何为Topk？
实现过程
1、堆排序 假如我们有一串乱序数组，如下： 现在想要对它进行排序，按照我们之前学过的知识，想要单纯的实现排序其实并不难，可以直接暴力排序，也可以冒泡排序，甚至使用库函数qsort进行排序……
但是，既然近期学习了堆，那么堆的一个重要应用就是进行堆排序，这里先简要提下：堆排序即快排的一种。在后面的学习中，我将为大家继续展开其它更多样的快排。今儿个就向各位浅谈下快排之一：堆排序
法一：自己写堆进行排序 思路： 在上篇博文中，我们模拟实现了堆，实现后即可对一串乱序数组进行堆排序。假设我们排升序，且堆为小根堆。实现过程非常简单。
首先，把数组的每个元素（HeapPush）插入到堆中。其次，我们深知小根堆的堆顶是最小的数字，依次遍历堆顶（HeapTop）的元素，将堆顶元素赋值到数组里，从下标0开始，赋值后删除（HeapPop）堆顶元素，++数组下标。此时堆就会重新调整，最终堆顶依旧是最小的，再重复上述赋值堆顶到数组的操作，直到堆为空（HeapEmpty） 代码如下： //堆排序 --- 升序 void HeapSort(int* a, int size) { //创建堆结构并初始化 HP hp; HeapInit(&amp;hp); //将数组元素插入堆中 for (int i = 0; i &lt; size; i++) { HeapPush(&amp;hp, a[i]); } size_t j = 0; //依次遍历，取堆顶赋值数组，++下标，pop堆顶，依次循环，直至堆为空 while (!HeapEmpty(&amp;hp)) { a[j] = HeapTop(&amp;hp); j++; HeapPop(&amp;hp); } //记得销毁动态开辟空间 HeapDestroy(&amp;hp); } int main() { int a[] = { 4,2,7,8,5,1,0,6 }; HeapSort(a, sizeof(a) / sizeof(int)); //实现堆排序 for (int i = 0; i &lt; sizeof(a) / sizeof(int); i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77c4387d02186b00fb737db28c865567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ddb77edf633f4d5cd7ac4be76a381a/" rel="bookmark">
			Parcel服务报错:regeneratorRuntime is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 Parcel 前端打包工具来启动本地服务时，console 控制台报错：Uncaught ReferenceError: regeneratorRuntime is not defined。查阅资料得知：regeneratorRuntime 是打包工具生成的一个全局辅助函数，由 babel 生成，用于兼容 async/await 的语法，所以需要配置相应的 babel 插件。
一、配置babel 配置 babel 插件有以下两种方式：
1.创建一个单独的配置文件 .babelrc。 在 window 系统下，不能直接生成以 . 为文件名开头的文件，但是可以在 cmd 命令行中使用 echo 命令来生成。操作如下：
echo &gt; .babelrc 编辑 .babelrc 文件，配置如下：
{ "plugins": [ '@babel/plugin-transform-runtime' ] } 2.在 package.json 中配置 babel。 "babel": { "plugins": [ '@babel/plugin-transform-runtime' ] } 配置成功后，重启服务，Parcel 会自动下载安装依赖，不用手动 npm install ，这一点真是太友好了。
二、总结 注意： package.json 要比 .babelrc 权重高。
如果项目不是太复杂，极力推荐使用 Parcel 构建Web应用，绝对的省心省事，方便又快捷。
欢迎访问：天问博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d93926651ca840ac435792d830fa767/" rel="bookmark">
			调试SAR SENSOR的一些感悟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机工作时是有电磁辐射的https://zhuanlan.zhihu.com/p/353591714，那怎样能降低电磁辐射对人体的伤害呢。
sar sensor能感应到有人在使用手机，从而发消息让modem降低发射功率(从而达到标准)。如果没人在使用手机，手机可以按正常功率工作。sar sensor的工作原理不描述，目前接触到的是艾为的aw9610x系列，sar sensor(可理解为一个接近传感器)一般有现成的驱动，调试也比较简单。
sar sensor默认有一个感应阀值(可软件设置)，超过该值(人接近手机)，或者低于该值(人远离手机)，都会触发sar sensor中断，ap收到该中断后，可以跟sensor sensor进行通信，判定sar sensor当前的状态，可以汇报键值给Android系统。
sar sensor由于碰撞或其他原因，需要校准。可以在插入或者拔出充电器时，执行sensor的校准函数。
framerwork层收到该键值后，可以调用soc提供的at接口来回退Modem功率。如展讯平台
import com.android.unisoc.telephony.RadioInteractor; private static String[] mRep = new String[]{}; private static RadioInteractor radioInteractor; radioInteractor = new RadioInteractor(context); if (radioInteractor != null) { radioInteractor.sendAtCmd("AT+SPPOWERFB=0", mRep, 0);//正常功率 radioInteractor.sendAtCmd("AT+SPPOWERFB=1,0", mRep, 0);//回退功率 } mtk平台可参考[FAQ24764] AP如何調用AT指令給Modem
或者通过工程模式发送AT指令
1、拨号键盘输入*#*#3646633#*#*进入工模 2、选择Connectivity-&gt;CDS Information-&gt;Radio Information-&gt;SIM1 MAIN/SIM2 SUB AT+ERFIDX=1,0//场景0 回退功率
AT+ERFIDX=1,1//场景1 回退功率
AT+ERFIDX=1,x//场景x 回退功率
AT+ERFIDX=1,-1//正常功率
一般配一个场景就够了，如
AT+ERFIDX=1,0//场景0 回退功率
AT+ERFIDX=1,-1//正常功率
当然，soc厂商回提供回退功率的的方法，如
CS0021-GAK1AC-AND-V1.3EN_Modem_SW_Platform_System_RF_SAR_Tx_backoff_Customization(2G_3G_4G)_Application_Note.pdf 34096_UMS512TSR3595D多场景下功率回退提升指南V1.2.pdf Modem工程师根据文档配置好对应场景的nv，然后驱动/系统工程师调用接口发送at指令就ok了。
有个问题，如果手机休眠了，把手机放口袋里要不要降功率呢，应该是需要的。这时候就需要让sar sensor(sar sensor不能睡眠)中断能唤醒系统了，可根据Linux休眠后开启中断的方法及中断唤醒过程_那颗流星的博客-CSDN博客_android 中断唤醒修改驱动代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6325d7b6c7682e2f084c82463555f180/" rel="bookmark">
			【文本检测】DB:Real-time Scene Text Detection with Differentiable Binarization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
网络整体流程
一. Label generation
1.1 probability map生成
1.2 threshold map 生成
二.Differentiable Binarization可微二值化
2.1 传统二值化和DB可微二值化的区别
2.2 ☆可微二值化
2.2.1 可微分的二值化公式：
2.2.2 DB函数反向传播求导的过程
2.2.3 可微二值化实际计算示例
三. 损失函数
四、实验结果
DB:Real-time Scene Text Detection with Differentiable Binarization
关键创新点：Differentiable Binarization(DB,可微分二值化)，作者提出了一种可微分的二值化方式，相比于传统的二值化操作，DB能够在网络中进行端到端训练。另外还是用可变形卷积用于更好的处理不同长度的文本。
网络整体流程 网络整体流程如下图所示：
backbone提特征 + FPN结构 进行多尺度图像特征融合FPN结构融合特征后会生成两个特征图 probability map(预测图) 跟 threshold map(阈值图)通过probability map 与threshold map 两个特征图做DB差分操作得到文字区域二分图二分图经过cv2 轮廓得到文字区域信息 一. Label generation label生成的流程图如下所示，特征图 probability map(预测图) 跟 threshold map(阈值图)
1.1 probability map生成 使用Vatti clipping algorithm 对gt多边形polygon 进行缩放，将G缩减到Gs（蓝线内部）。probability map中蓝线以内的区域取值为1，其它区域值为0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6325d7b6c7682e2f084c82463555f180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7916969c5036517dc0e8fa7f61278de8/" rel="bookmark">
			15.网络协议-Radius协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AAA概述 功能介绍
1. AAA：分别为Authentication、Authorization、Accounting
2. 认证(Authentication)：验证用户的身份（用户名，密码认证）与可使用的网络服务（服务范围广）；
3. 授权(Authorization)：依据认证结果开放网络服务给用户；
4. 计帐(Accounting)：记录用户对各种网络服务的用量，并提供给计费系统。
AAA的优势
1. 灵活性
2. 可控性
3. 可扩展性
4. 可靠性
5. 标准化协议
AAA概述-认证模型 AAA认证基本模型
AAA基本模型包括用户，NAS，认证服务器三个部
分
版权所有© 2020深信服科技股份有限公司 第6页
AAA认证流程
1，用户向NAS发起认证连接请求
2，NAS设备将用户的认证请求转发给认证服务器
3，认证服务器返回认证结果给NAS
4，NAS设备根据认证的返回结果对用户进行相应的
认证，授权和计费操作
PS：NAS(Network Authentication Server)不是
(Network Attached Storage)网络附属存储
Radius需求背景-1 场景1：通过AAA(Radius服务器)为上网用户提供认证、授权和计费：
某企业网络通过LANSwitch与AC/NGAF作为目的网络接入服务器。用户需要通过服务器的远端认证才能通过建立连接，该网络中的用户需要访问Internet资源。为了保证网络的安全性，
企业管理员希望控制用户对于Internet的访问。
通过在AC/NGAF上配置AAA，实现AC/NGAF与AAA服务器的对接，可以由AAA服务器对用户进行统一管理。用户在客户端上输入用户名和密码后，AC/NGAF可以接收到用户的用户名和密码等认证信息并将用户信息发送给AAA服务器，由AAA服务器对其进行认证。如果认证通过，则用户可以开始访问Internet。在用户访问过程中，AAA服务器还可以记录用户使用网络资源的情况。为了提高可靠性，可以部署两台AAA服务器，并在AC/NGAF上进行相应配置实现AAA服务器的主备备份，主服务器发生故障时，备服务器可以接替主服务器工作，保证用户业务不会中断。
Radius需求背景-2 场景1：通过AAA对管理用户进行认证和授权：
管理用户（Administrator）与AC/AD/NGAF建立连接，对AC/AD/NGAF进行管理、配置和维护。
在AC/AD/NGAF上配置AAA后，当管理用户登录Switch时，AC/AD/NGAF将管理用户的用户名和密码等信息发送给AAA服务器，由AAA服务器来进行统一认证，同时记录这些用户的操作行为
Radius概述 AAA可以通过多种协议来实现，在实际应用中，最常使用RADIUS协议。
RADIUS是一种分布式的、客户端/服务器结构的信息交互协议，能保护网络不受未授权访问的干扰，常应用在既要求较高安全性、又允许远程用户访问的各种网络环境中。该协议定义了基于UDP（User DatagramProtocol）的RADIUS报文格式及其传输机制，并规定UDP端口1812、1813分别作为默认的认证、计费端口。
RADIUS最初仅是针对拨号用户的AAA协议，后来随着用户接入方式的多样化发展，RADIUS也适应多种用户接入方式，如以太网接入等。它通过认证授权来提供接入服务，通过计费来收集、记录用户对网络资源的使用。
RADIUS协议的主要特征如下：
1. 客户端/服务器模式
2. 安全的消息交互机制
3. 良好的扩展性
Radius概述-客户端/服务器模式 • RADIUS客户端
1. 持标准RADIUS协议及扩充属性，包括RFC2865、
RFC2866。
2. RADIUS服务器主备或负载分担功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7916969c5036517dc0e8fa7f61278de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cc0faaba34835f2b6321171d972617e/" rel="bookmark">
			记录一次服务器断电重启后网络配置的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述 服务器系统 CentOS 7， IP 是 172.22.xx.245，一直正常使用。
前两天突然断电重启后发现网络不通，在服务器上使用 ip a 命令查看，发现状态为 UP 的网卡名称是 enp4s0，其 IP 是 192.168.1.4 。
但是在 /etc/sysconfig/network-scripts/ 下发现只有一个名为 ifcfg-enp5s0 的配置，并没有 enp4s0 的，很奇怪。
使用 ifup enp5s0 和 ifup ifcfg-enp5s0 命令启动网卡，报错如下：
Error: Connection activation failed: No suitable device found for this connection (device enp5s0 not available because profile is not compatible with device (mismatching interface name)). 2. 问题解决 首先是按照网上说的禁用 NetworkManager 后重启 network 服务 （没用）systemctl stop NetworkManager systemctl disable NetworkManager systemctl restart network 可能是网卡配置中没有 mac 地址导致的，于是使用 enp4s0 的 mac 地址放在 ifcfg-enp5s0 配置文件中增加如下配置 （没用）HWADDR="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cc0faaba34835f2b6321171d972617e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983e8dd3ec8d4bf6c810d64268bdd62e/" rel="bookmark">
			Gitea在windows平台的安装和简单使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gitea在windows平台的安装和简单使用教程 一、Gitea简介 官网介绍：Gitea的首要目标是创建一个极易安装，运行非常快速，安装和使用体验良好的自建 Git 服务。我们采用Go作为后端语言，这使我们只要生成一个可执行程序即可。并且他还支持跨平台，支持 Linux, macOS 和 Windows 以及各种架构，除了x86，amd64，还包括 ARM 和 PowerPC。详情可以到官网了解。
也就是说Gitea一个git管理工具，类似构建自己的github，但是github仓库需要公开（私有付费）,国内的gitee免费的也有一定的限制，而且是线上的。我们可以通过Gitea在局域网管理自己的项目代码。
二、Gitea安装 可以到Gitea官网下载或者Gitea的Github上下载Gitea软件。
到官网点击下载
选择版本：
选择对应的操作系统，这里选择windows 64位操作系统：
下载后建议在非系统盘新建一个文件夹，比如gitea文件夹
在gitea文件夹下存放Gitea软件，然后在gitea文件夹下新建data文件夹：
然后直接双击启动软件，会弹出一个dos框，软件这时已经成功启动：
软件启动之后我们打开浏览器，输入http://localhost:3000/，会出现登录界面，点击登录
第一次登录会直接弹出初始化界面，按以下参数进行配置：
填写完之后直接安装，这时等dos安装完，然后关闭软件，然后重启一下软件
重启后，在浏览器输入刚才注册的IP地址和端口号，上图是http://10.0.0.168:80/，然后会看到登录界面，点击登录，输入刚才的管理员账号密码，就能成功登录了。登录后就可以使用了，在右上角可以设置个人信息和配置其他一些后台管理，此时Gitea算是安装完成了。
三、将Gitea注册成为服务 我们希望Gitea能一直启动并且在开机或者软件崩溃时能自动重启，所以我们需要把Gitea注册成服务。此时我们需要一个软件：nssm。
nssm软件的下载网址：NSSM - the Non-Sucking Service Manager
下载好后解压，打开找到对应win64文件夹（32位的就打开win32文件夹），空白处右键打开命令提示符(CMD)
输入：nssm install gitea
然后会弹出的软件，选择我们下载的Gitea的软件的路径
然后点击安装
安装好后打开计算机的服务，就能看到gitea已经成为一项服务了，服务默认的状态就是自动启动了的，如果不是，需要手动设置为自动。这时候我们再打开浏览器登录gitea验证能不能登录，如果登录不了，可能需要将服务停止一下再启动。
四、在gitea上新建账号、组织、团队和仓库 1.更换头像 我们可以在右上角进入管理员的设置页面，可以在里头设置个人信息和其他各种设置等，可以先在个人信息中设置个人头像，不然头像会一直是一张加载不出来的图片
2.新建组织 右上角选择后台管理，创建新的组织，输入需要的组织名字和需要的其他设置，点击创建组织就可以
3.新建账户 跟新建组织类似，这里不做过多介绍，大家可以自己尝试，新建好的用户可以在同一个局域网内输入IP地址和端口就可以登录建立好的gitea平台。
4.新建团队 新建账户后就可以建立团队，建立团队的目的是为了更好的管理账户的权限。
在组织中选择组织团队，点击新建团队，配置相应的权限等，然后创建团队，然后把需要拉进来的账户名称输入到添加团队成员框，点击添加团队。
5.新建仓库 我们可以在组织里新建仓库，选择拥有者，输入仓库名字等信息后创建仓库。
创建好后会有一个仓库的地址，在局域网内的已经授权的用户就可以访问这个仓库
6.修改Gitea平台的配置信息 有时候我们的IP地址更换了，登不了平台，可以在安装目录下…\gitea\custom\conf文件夹下找到app.ini文件，然后打开，更改里头的信息就行。
五、将本地代码推送到Gitea平台上或者拉取代码 1.将代码从本地推送到Gitea平台上 本教程使用的是Sourcetree软件进行代码的拉取和推送等功能。
选择一个本地需要推送的仓库，下图是新建一个test的仓库。
然后点击右上角的设置-添加远程仓库
将Gitea平台上已经新建的仓库的名称和地址填入对应的信息框中，确定。
然后点击推送-选择分支-推送，第一次推送要输入Gitea端的账号和密码，注意此账号和密码指的是Gitea平台账户的账号和密码。
打开Gitea端，就能看到推送的信息
2.将代码从Gitea平台上拉取到本地 这里为了从零演示，我们新建一个文件夹
然后点击右上角的设置-添加远程仓库
将Gitea平台上已经新建的仓库的名称和地址填入对应的信息框中，确定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/983e8dd3ec8d4bf6c810d64268bdd62e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f63cdf6d8732897335d1f1fad80042f/" rel="bookmark">
			Origin中多峰拟合方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当数据中存在多个峰值时，在origin中如何进行多峰拟合呢？
1、首先，创建测试的数据如下图所示：
2、创建图像，如下图所示：
3、选择工具栏上的analysis，按下图中划红线的选项（Peaks and Baseline -&gt; Multiple Peak Fit -&gt; Open Dialog）进行选择：
4、根据自己需求选择拟合函数：
5、左键双击选中峰值，点击Fit即可获得结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4358e65c8677efcdffd888583463866/" rel="bookmark">
			Vue01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.vue简介
2.vue特点
3.初识Vue
4.模板语法
5. MVVM模型
6. 数据代理
7. 事件处理
1.vue简介 2.vue特点 1.采用组件化模式，提高代码复用率、且让代码更好维护
2.声明式编码，让编码人员无需直接操作DOM，提高开发效率
3.使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点
.学习Vue之前要掌握的JavaScript基础知识
ES6语法规范ES6模块化包管理器原型、原型链数组常用方法axiospromise
3.初识Vue 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象;root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法; root容器里的代码被称为【Vue模板】;Vue实例和容器是一一对应的;真实开发中只有一个Vue实例,并且会配合着组件一起使用;{{xxx}}中的xxx要写js表达式,且xxx可以自动读取到data中的所有属性; 一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新;
注意区分:js表达式和js代码(语句)
1.表达式:一个表达式会产生一个值，可以放在任何一个需要值的地方:
(1). a
(2). a+b (3). demo(1)
(4). x === y ? 'a’ : "b"
2.js代码(语句)
(1). if(){}
(2). for(){}
4.模板语法 Vue模板语法有2大类:
1.插值语法:
功能:用于解析标签体内容。写法:{{xxx]},xxx是js表达式，且可以直接读取到data中的所有属性。 2.指令语法
功能:用于解析标签（包括:标签属性、标签体内容、绑定事件.....） .举例:v-bind:href="xxx”或简写为:href="xxx"，xxx同样要写js表达式,且可以直接读取到data中的所有属性。备注:Vue中有很多的指令，且形式都是: v-???? 数据绑定
Vue中有2种数据绑定的方式:
单向绑定(v-bind):数据只能从data流向页面。双向绑定(v-model):数据不仅能从data流向页面，还可以从页面流向data。 备注:
双向绑定一般都应用在表单类元素上（如: input、select等)v-model :value可以简写为v-model，因为v-model默认收集的就是value值.
data与el的2种写法
1.el有2种写法
(1).new Vue时候配置el属性。
(2).先创建Vue实例，随后再通过vm.$mount( ' #root ')指定el的值。
2.data有2种写法
(1).对象式
(2).函数式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4358e65c8677efcdffd888583463866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85c9f4baf826643164564701599460d/" rel="bookmark">
			MySQL存储引擎特性解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MySQL存储引擎特性解析 关于 各存储引擎之间的对比：官方介绍
InnoDB存储引擎的详细介绍：官方介绍
注意：此处官方介绍的MySQL版本为5.7，不同版本的介绍可能存在差异，可自行去官方网站上寻找对应的地址
存储引擎 InnoDBMyISAMMemoryCSVArchiveNDB 存储引擎特性 InnoDB 支持事务（ACID）、外键、表级别和行级别的锁、读写的并发、写不阻塞读（MVCC），数据的完整性和一致性更高，用一种索引特殊存储方式，该方式可以减少IO次数，从而达到提升查询的效率，用于数据一致性高，要求事务的特性并且有比较多的更新场景下。 MyISAM 应用范围比较小，而且表级别的锁限制了读写性能，用在只读的工作里面，插入和查询的效率比较高，count速度比较快（只支持表级别的锁，而且不支持事务）。 Memory 数据存储在内存里面，读写速度非常快，用于临时存储数据 CSV 纯文本文件，可以用其他文本编辑工具打开，体积比较小，解析起来比较高效，不支持索引，一般用于导入导出 Archive 归档，只会读，不会写，可内容压缩，不支持索引，也不支持update和delete操作，可用于日志记录 NDB 用来做集群的存储引擎 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a9a0010d4a18648803f9212641494d8/" rel="bookmark">
			Zynq-Linux移植学习笔记之55-国产ZYNQ Linux下适配NST175温感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景介绍 模块中使用国产纳芯微的温感，型号为NST175，该温感通过I2C连接模块上的国产ZYNQ，实现温度采集功能。
通过查阅datasheet，能够发现该温感通过I2C读写时序为标准的I2C读写时序
Nst175的I2C地址为7位
温度寄存器地址为0
温度寄存器是一个16位的数，一般取前8位即可
2、vivado工程配置 vivado中通过PL中的I2C IP核来连接NST175，注意模式选择7bit，同时把中断接上
3、内核配置 内核中需要添加i2c-nst175的驱动，将驱动编译进内核
驱动源码可参考之前的cps1848，代码见下
/* * nst175 bus driver * * Copyright (C) 2014 CGT Corp. * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; version 2 of the License. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a9a0010d4a18648803f9212641494d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/752a8b997a4a8733d629c58596e3ba7c/" rel="bookmark">
			docker搭建vulhub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开终端
su root
输入密码进入root用户
1.
python3
查看python3的版本
pip -V
查看是否安装了pip3环境
如果没有安装
apt install python3-pip
安装pip3环境
2.
docker -v（小写v）
查看docker版本
docker安装可参考
Ubuntu安装docker
3.
apt upgrade
更新系统包索引
pip3 install docker-compose
安装docker-compose命令
docker-compose -v
安装成功
4.
git clone https://github.com/vulhub/vulhub.git
下载vulhub
下载完成
5.
以tomcat8弱口令漏洞靶场为例
cd vulhub
cd tomcat
如图找到tomcat8的位置
cd tomcat8
在tomcat8目录下
执行docker-compose build
建立容器
执行docker-compose up -d
启用漏洞环境
ifconfig查看虚拟机ip
宿主机访问虚拟机ip并指定端口为8080
可见tomcat8的漏洞环境可以访问到
在该目录下使用
docker-compose down
可关闭此漏洞环境
vulhub中其他漏洞环境的开启类似 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99219776b25a10b333a72a992fdfc714/" rel="bookmark">
			Hali硬件安全工具-串口通讯RS232/485/422/CAN抓包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.场景需求 我发现我的CSDN的优点之一就是，每篇文章都有讲清楚起因，平白无故的技术学习是没有根的，没有落地的场景，没有技术的应用，技术本身就是昙花一现。
这次的分享，是Hali硬件安全工具的第一次分享。关于Hali是什么，Hali能做什么，请参考：
​​​​​​极客“Hali”硬件信息安全检测工具集（硬件Kali）简介_千夫长-向往生的博客-CSDN博客_kali查看硬件
通过以下的分享，我将为你揭开，如何通过这些软硬件工具，对串口通讯进行抓包分析，首先确保你的抓包是在实验室中进行，或在安全的工厂环境下进行。
2.工具列表 工欲善其事必先利其器，我们先来看下，你需要的工具：
2.1【硬件】通用总线分析-逻辑分析仪
型号为：LA2016(或LA1010)，可淘宝搜索型号购买。
2.2【硬件】串口工具
从左到右分别是：USB转RS232，USB转RS482/RS422，USB转TTL串口的工具，品牌型号都有，可以淘宝自己搜。
【硬件】CAN抓包分析仪
【软件】逻辑分析仪软件下载地址
通过这个分析工具，可以监听41种工业通讯总线数据，包括常见的232/TTL/485/422/IIC/SPI等，还可以自动探测串口波特率。
CAN分析仪软件：采购后会有店家发送软件下载地址。
通过这个软件，可以探测CAN总线的波特率，并直接把抓到的CAN数据包保存到Excel中，还可以主动，周期性的发CAN包。
串口抓包软件
这个是最常用的串口抓包工具，可以在各种视图中才查看到串口接收的时间，间隔，数据，数据的ASCII码，注册了会员，还可以把数据导出成txt做后续的python数据流分析。
3.基本使用方法 3.1.总线识别 一般在工厂的总线连接处，会明确的标识RS23/RS485，或者CAN_H，CAN_L，但如果出于保护或是标识看不到，那么可以先用逻辑分析仪接上去，看一下波形，或是用CAN分析仪怼上去，探测一下波特率。
3.2 总线抓包 这类软件基本上是比较傻瓜化的，插上硬件，把驱动装好，选择串口，点击开始抓包就可以，然后保存为默认的文件格式，再回到办公室，打开抓包文件就可以分析了。
3.3 数据清洗和分析 针对串口抓取回来的数据，导出成11.txt（以UTF-8存储），通过以下的脚本，实现数据的清理。
numindex=0 countW=0 countR=0 PID='Data' global fileHandname fileHandname='11' try: f = open(fileHandname+'.txt', 'r', encoding='UTF-8') #f = open('1.txt', 'r') #print('读取成功') except: print('读取文件错误，请确认文件正常存放') ResultData='' data_lines = f.readlines() f.close() num = len(data_lines) # 得到存储的行数 for i in range(num): # 读取最新的ChannelNum行数据， line = data_lines[i] # 从第0行开始 dataread='' numindex=line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99219776b25a10b333a72a992fdfc714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1507d1cfbe30d082bf549f5803f22e/" rel="bookmark">
			【HTML5】1.语法入门总结（第一部分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.思维导图 1.HTML5基本框架 HTML5 是HyperText Markup Language 5 的缩写，是一种标记语言。
第一个程序，基本框架。
&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;第一个程序&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello world &lt;/body&gt; &lt;/html&gt; 2.语法举例 2.1.标题标签 有h1-h6级标题
&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;标题标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;标题标签口诀&lt;/h1&gt; &lt;h1&gt;标题一共六级选&lt;/h1&gt; &lt;h2&gt;文字加粗一行显&lt;/h2&gt; &lt;h3&gt;由小到大依次减&lt;/h3&gt; &lt;h4&gt;从重到轻随之变&lt;/h4&gt; &lt;h5&gt;语法规范随后写&lt;/h5&gt; &lt;h6&gt;具体效果刷新见&lt;/h6&gt; &lt;/body&gt; &lt;/html&gt; 2.2.段落与换行 p：段落
br:换行
&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1507d1cfbe30d082bf549f5803f22e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a193411cd76e1bb0d6af6b807c7e9ad/" rel="bookmark">
			vue(六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TODOList案例
总结TodoList案例 1.组件化编码流程:
(1).拆分静态组件:组件要按照功能点拆分，命名不要与html元索冲突.
(2).实现动态组件:考虑好数据的存放位置,数据是一个组件在用， 还是一
些组件在用:
1).一个组件在用:放在组件自身即可。
2). 一些组件在用:放在他们共同的父组件上(状态提升) .
(3).实现交互:从绑定事件开始。
2. props适用于:
(1).父组件==&gt;子组件通信
(2).子组件==&gt;父组件通信(要求父先给子一个函数)
3.使用v-model时要切记: v-model绑定的值不能是props传过来的值，因为props
是不可以修改的!
4. props传过来的若是对象类型的值,修改对象中的属性时Vue不会报错，但不推
荐这样做。
webStorage 1.存储内容大小一般支持5MB左右(不同浏览器可能还不一样)
2.浏览器端通过Window. sessionStorage和Window.localStorage属性来实现本地存储机制。
3.相关API: .
1. xxxStorage.setItem(key', "value°);
该方法接受一个键和值作为参数，会把键值对添加到存储中,如果键名存在,则更新其对应
的值。
2. xxxStorage.getItem( 'person'); !
该方法接受一个键名作为参数,返回键名对应的值。
3. xxxStorage.removeIten('key');
该方法接受一个键名作为参数，并把该键名从存储中删除。
4.xxxxStorage .clear()
该方法会清空存储中的所有数据。
4.备注:
1. SessionStorage存储的内容会随着浏览器密口关闭而消失。
2. LocalStorage存储的内容，需要手动清除才会消失。
3. xxxStorage.getItem(xxx)如xx对应的value获取不到，那么getItem的返回值是null,
4.JSON.parse(null)的结果依然是nul.
LocalStorage.html &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;localStorage&lt;/title&gt; &lt;script&gt; let p = { name: "zzc", age: 18 } function addDate() { localStorage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a193411cd76e1bb0d6af6b807c7e9ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6028977dc2eeace2fad151746974fdd/" rel="bookmark">
			7-2 货币转换 (10 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编写一个美元与人民币转换的程序，用户输入金额和汇率，输出转换为另一种货币表示的金额。（美元用符号’$’表示，人民币用￥表示，￥可以在中文输入法下按shift+4获取）
输入格式: 第一行输入一个以货币符号结尾的正数，数值作为金额，货币符号表明货币种类
第二行输入一个浮点数作为汇率
输出格式: 输入符合要求时输出一个带货币符号的数值（保留2位小数）
输入不符合要求时输出Data error!
输入样例: 58$ 6.75 输出样例: 391.50￥ 输入样例: 100￥ 6.85 输出样例: 14.60$ a = str(input()) b = float(input()) if '$' in a: #如果含“$”,则为美元 c = float(a.strip('$')) c = c*b print("%.2f￥"%c) elif '￥' in a: #含“￥”，为人民币 c = int(a.strip('￥')) #strip函数用于删除字符串最后一个字符 c = c/b print("%.2f$"%c) else: print("Data error!") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24313bdc57f87986cc61db055cc17a08/" rel="bookmark">
			python-猜数字游戏（0-9）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 from random import * x=randint(0,9)#预设0-9的整数 n=0 print("请输入0-9的数字") while(1): m=eval(input()) if x&lt;m: print("遗憾，太大了") n+=1 continue if(x&gt;m): print("遗憾，太小了") n+=1 continue else: n+=1 break print("预测{:}次，你猜中了！".format(n)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ffc7849b2f335346c23f6eed76beaf/" rel="bookmark">
			Word中调节图片统一大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在word中调节图片的统一大小方法：
1、我们先调节好一张图片的大小；
2、选中其他图片，按F4快捷键即可统一图片大小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1f900b7ffc7c93217adaf0c93cd1d2/" rel="bookmark">
			雷达相机标定（一）----点云提取标定板角点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 思路源码效果数据 图像提取角点：https://blog.csdn.net/xx970829/article/details/123233609
思路 velodyne16线点云稀疏，与相机标定时不利于角点的提取，本文先提取出平面，再把平面边缘点投影到yoz平面，拟合出交点，然后结合空间平面方程计算出其空间位置。
源码 //-------------------------------------------------------------------------------------------- // source /home/xx/catkin_ws/devel/setup.bash &amp;&amp; rosrun my_cam_lidar_calib cloud 1.pcd // // 提取点云中的标定板 //-------------------------------------------------------------------------------------------- #include &lt;iostream&gt; #include &lt;math.h&gt; #include &lt;cmath&gt; #include &lt;string.h&gt; //常用点云类 #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/io/ply_io.h&gt; #include &lt;pcl/filters/passthrough.h&gt; //直通滤波器头文件 #include &lt;pcl/filters/statistical_outlier_removal.h&gt; //滤波相关 #include &lt;pcl/visualization/cloud_viewer.h&gt; //类cloud_viewer头文件申明 //分割类 #include &lt;pcl/sample_consensus/method_types.h&gt; #include &lt;pcl/sample_consensus/model_types.h&gt; #include &lt;pcl/segmentation/sac_segmentation.h&gt; #include &lt;pcl/ModelCoefficients.h&gt; #include &lt;pcl/filters/extract_indices.h&gt; //图像类 #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;Eigen/Eigen&gt; #include &lt;Eigen/Core&gt; // 稠密矩阵的代数运算（逆，特征值等） #include &lt;Eigen/Dense&gt; //标定板长、宽 #define LONG 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1f900b7ffc7c93217adaf0c93cd1d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da21f503b3f779fb0903397665f2ac78/" rel="bookmark">
			torchvision.datasets.CIFAR10模块使用讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		torchvision.dataset数据集 所有的数据集都是torch.utils.data.Dataset的子类， 它们实现了__getitem__和__len__方法。因此，它们都可以传递给torch.utils.data.DataLoader.
transform = transforms.Compose( [transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]) trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform) trainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True, num_workers=2) 目前为止，收录的数据集包括：
__all__ = ('LSUN', 'LSUNClass', 'ImageFolder', 'DatasetFolder', 'FakeData', 'CocoCaptions', 'CocoDetection', 'CIFAR10', 'CIFAR100', 'EMNIST', 'FashionMNIST', 'QMNIST', 'MNIST', 'KMNIST', 'STL10', 'SVHN', 'PhotoTour', 'SEMEION', 'Omniglot', 'SBU', 'Flickr8k', 'Flickr30k', 'VOCSegmentation', 'VOCDetection', 'Cityscapes', 'ImageNet', 'Caltech101', 'Caltech256', 'CelebA', 'WIDERFace', 'SBDataset', 'VisionDataset', 'USPS', 'Kinetics400', "Kinetics", 'HMDB51', 'UCF101', 'Places365', 'Kitti', "INaturalist", "LFWPeople", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da21f503b3f779fb0903397665f2ac78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4039d2dc77464cbc1b9dfb001c199b4/" rel="bookmark">
			【静态时序分析】如何寻找时序分析的起点与终点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看《集成电路时序分析与建模》中看到这么一个知识点，觉得有点意思，就记录下来，与大家一起分享。
先看 如下电路图：
左边的电路图是需要分析的电路，我们的目的是要对此电路进行时序分析，那首先要找到该电路需要分析的时序路径，既然找路径，那找到时序分析的起点与终点即可。
寻找时序路径的起点和终点的原则如下：
起点：
设计边界的数据输入端口或信号输入端口；如上图右边的I0，I1；时序元件（一般指DFF）的输出，例如上图右边的11，13，15；存储单元的数据输出，其实这和第2条一致，时序单元也是存储单元，例如DFF，但这里的存储单元一般指存储器，例如RAM等； 终点：
时序单元的数据输入，例如上图右边的10，12，14；存储单元的数据输入，类似于时序单元，但更多指存储器等，例如RAM等；设计边界的输出Q0，Q1，Q2； 根据上述原则即可得到，时序分析的起点（最左边）和终点（最右边）：
中间经过的节点都可认为是延迟单元。
实际进行时许分析时，可不必每次都这么转换，但是不得不说，这种理论化的方式可以让你的分析更具理论支撑，见多了熟悉了之后便可更快速的识别时序路径。
这是分析的第一步，祝入门快乐。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e9631b1c43299f86109759dd95f3bf/" rel="bookmark">
			Bat文件的创建及其命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bat文件的创建及其命令大全 一、bat文件的创建 新建txt文本文件
向文本文件中输入命令
保存并修改文本文件后缀为.bat
双击保存后的bat文件，运行
二、bat命令大全 echo 和 @ @ #关闭单行回显 echo off #从下一行开始关闭回显 @echo off 1 echo 和 @ @ #关闭单行回显 echo off #从下一行开始关闭回显 @echo off #从本行开始关闭回显。一般批处理第一行都是这个 echo on #从下一行开始打开回显 echo #显示当前是 echo off 状态还是 echo on 状态 echo. #输出一个”回车换行”，空白行 #(同echo, echo; echo+ echo[ echo] echo/ echo\) errorlevel echo %errorlevel% 每个命令运行结束，可以用这个命令行格式查看返回码 默认值为0，一般命令执行出错会设 errorlevel 为1 dir dir #显示当前目录中的文件和子目录 dir /a #显示当前目录中的文件和子目录，包括隐藏文件和系统文件 dir c: /a:d #显示 C 盘当前目录中的目录 dir c: /a:-d #显示 C 盘根目录中的文件 dir c:\ /b/p #/b只显示文件名，/p分页显示 dir *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0e9631b1c43299f86109759dd95f3bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0556d91366bd471f51a48d0fbfc344f/" rel="bookmark">
			python-货币转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写一个美元与人民币转换的程序，用户输入金额和汇率，输出转换为另一种货币表示的金额。（美元用符号’$’表示，人民币用￥表示，￥可以在中文输入法下按shift+4获取）
输入格式: 第一行输入一个以货币符号结尾的正数，数值作为金额，货币符号表明货币种类
第二行输入一个浮点数作为汇率
输出格式: 输入符合要求时输出一个带货币符号的数值（保留2位小数）
输入不符合要求时输出Data error!
输入样例: 58$ 6.75 输出样例: 391.50￥ a=input()
b=float(input())
try:
for i in range(len(a)):
if a[i] in ['$']:
print("{:.2f}￥".format(eval(a[:-1])*b))
elif a[i] in ['￥']:
print("{:.2f}$".format(eval(a[:-1])/b))
except: print("Data error!")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468fa32ba63fe5f93334acb96900e95e/" rel="bookmark">
			python-判断火车票座位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我国高铁一等座车座席采用2+2方式布置,每排设有“2+2”方式排列四个座位,以“A、C、D、F”代表,字母“A”和“F”的座位靠窗,字母“C”和“D”靠中间走道。 二等座车座席采用2+3布置,每排设有“3+2”方式排列五个座位,以“A、B、C、D、F”代表,字母“A”和“F”的座位靠窗,字母“C”和“D”靠中间走道,“B”代表三人座中间座席。每个车厢座位排数是1-17，字母不区分大小写。
用户输入一个数字和一个字母组成的座位号，根据字母判断位置是窗口、过道还是中间座席，输入不合法座位号时输出'输入错误'。
输入格式: 输入一个数字和字母组合成的字符串
输出格式: '窗口'、'过道'、'中间' 或'输入错误'
输入样例: 在这里给出一组输入。例如：
12F 输出样例: 在这里给出相应的输出。例如：
窗口 在这里给出一组输入。例如：
2C 输出样例: 在这里给出相应的输出。例如：
过道 a=input()
if int(a[:-1])&lt;=17:
if a[-1] in ("a","A","F","f"):
print("窗口")
elif a[-1] in ("c","C","D","d"):
print("过道")
elif a[-1] in ("b","B"):
print("中间")
else :
print("输入错误")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1f48fd15ee8e36c5ff54547eed32044/" rel="bookmark">
			python实现货币转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实现美元与人民币的转换
2022.4.16 ：1美元=6.37人民币
moneyStr = input('请输入带有标志(RMB,rmb,USD,usd)的钱数:') if moneyStr[-3:] in ['RMB','rmb']: dollar = eval(moneyStr[0:-3])/6.37 print('转换后的美元是%f USD'%(dollar)) elif moneyStr[-3:] in ['USD','usd']: yuan = 6.37*eval(moneyStr[0:-3]) print('转换后的人民币是%f RMB'%yuan) else: print('格式错误') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa8e3cdeb6edd9e98ab174fce622241/" rel="bookmark">
			Redis的简介以及安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的简介以及安装教程 简介 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库
特点 Redis支持数据持久化，可以将内存中的数据存入到磁盘中Redis不仅支持简单的key-value类型的数据，同时还提供了list，set，zset，hash等数据结构的存储Redis支持master-slave模式的数据备份 安装教程 https://redis.io 官网下载tar -zxvf tar包名cd 到解压目录中，执行make；tcl 、gcc环境如果没有的话，需要自行安装make test 测试编译状态make install 正常执行完 如果在执行make test后报以下错：
You need tcl 8.5 or newer in order to run the Redis test
解决方式：
wget http://downloads.sourceforge.net/tcl/tcl8.6.0-src.tar.gz sudo tar xzvf tcl8.6.0-src.tar.gz -C /usr/local/ cd /usr/local/tcl8.6.0/unix/ sudo ./configure sudo make sudo make install 此方法如果不行的话可以参考如下操作：
#wget http://downloads.sourceforge.net/tcl/tcl8.6.0-src.tar.gz #tar xzvf tcl8.6.0-src.tar.gz -C /usr/local/ #cd /usr/local/tcl8.6.0/unix/ #./configure --prefix=/usr \ --without-tzdata \ --mandir=/usr/share/man \ $([ $(uname -m) = x86_64 ] &amp;&amp; echo --enable-64bit) &amp;&amp; make &amp;&amp; sed -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa8e3cdeb6edd9e98ab174fce622241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998919efbef13804abc11bcfac5d0843/" rel="bookmark">
			MySQL优化解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MySQL优化解析 前言 无论在工作实践还是面试理论中MySQL优化作为重要的一环，都应需要各位开发了解并掌握其解决方案
硬件与操作系统 硬件配置升级 cpu性能和核心数内存固态硬盘网络 操作系统 windows改linux MySQL配置 增加MySQL服务器可用连接数
show variables like 'MAX_CONNECTIONS'; --- 查看连接数，默认151，可以设置成16384(2^14) 减少客户端可用连接数
连接池设置批量操作最大传输数据大小 调节MySQL的配置文件my.ini中的 max_allowed_socket 参数大小 设置第三方缓存模块 使用redis等第三方中间件开启mybatis或hibernate等ORM框架缓存模块 慢查询等性能分析工具开启
慢查询日志show variables like 'slow_query%'; --- 慢日志信息 show variables like 'long_query_time'; --- 当SQL执行超过这个值时才记录到慢日志中,默认10s mysql专门用来分析慢日志的工具 mysqldumpslow profilesmysqldumoslow -s t -t 20 -g 'select' /var/lib/mysql/localhost-slow.log --表示前二十个耗时最长的SQL语句查询语句 show profiles; select @@profiling; 数据库架构 分库分表 mycat/sharing jdbc 集群 一主多从多主一从互为主从级联复制 存储引擎和表结构 存储引擎 当插入和查询较多时，选择MyISAM存储引擎，不支持事务临时表，选择基于内存的Memory存储引擎大多数业务场景下使用默认Innodb存储引擎，支持事务 表结构 字段类型选择字段大小选择 SQL和索引 SQL优化 执行计划：EXPLAIN SELECT * FROM USER WHERE id =1; select_type;简单查询、子查询、联合查询type:衡量SQL执行效率的一个重要指标 system/const/eq_ref 一般业务SQL很难优化到这种起步，忽略ref：select * from student where name=‘小明’; //name为索引rang：select name from student where id&gt;1; //id字段为索引index：select name from student; //name字段为索引all：select name from student; //name字段不为索引 possible_keys：查询过程中可能使用到的索引key：查询过程中实际使用到的索引Extra：十分重要的额外信息 using filesort：select * from student order by name; //name字段不为索引using temporary：select distinct name,phone from student;using index：select phone from student where name=‘小明’; //name_phone为联合索引using where：select * from student where phone=18012345678; //iphone不为索引using index condition：索引下推 索引优化 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b8df1f132a2a6ef0f9b3bdb67ff1da7/" rel="bookmark">
			MySQL常见的索引及创建方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MySQL常见的索引及创建方式 普通索引 CREATE INDEX indexName ON tableName(columnName(length)); ALTER table tableName INDEX indexName(columnName); CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 主键索引 ALTER table tableName ADD CONSTRAINT indexName PRIMARY KEY (columnName); CREATE TABLE `user_innodb` ( `id` int(11) PRIMARY KEY AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `gender` tinyint(1) DEFAULT NULL, `phone` varchar(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 全文索引 CREATE FULLTEXT indexName ON tableName(columnName); ALTER table tableName FULLTEXT INDEX indexName(columnName); CREATE TABLE article ( id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY, title VARCHAR(200), content TEXT, FULLTEXT (title, content) --在title和content列上创建全文索引 ); 唯一索引 CREATE UNIQUE indexName ON tableName(columnName); ALTER table tablename UNIQUE [indexName](columnName); CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 联合索引（组合索引） CREATE INDEX indexName ON tableName(columnName,columnName); ALTER table tableName INDEX indexName(columnName,columnName); CREATE TABLE mytable ( `id` int(11) , `name` VARCHAR(32) , INDEX index_mytable_id_name (`id`,`name`) ); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12bf7c807e694d382a4e8f779509865a/" rel="bookmark">
			小程序API之天气预报查询及百度APIkey(ak)的申请
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：天气预报查询实时的天气状况，和实时温度，在input输入框中输入城市名称，点击搜索即可显示。
wx.request发起https网络请求。默认超时时间和最大时间都是60s，超时时间可在app.json中设置。一个微信小程序同时只能有五个网络请求连接。
我先一步一步写一下，写完后在最下面系统的帖一下所有代码。当然一步按步骤写也能写出来，但是没有样式而已
1.动态获取输入的城市名 在wxml中编写：
为input输入框绑定bindKeyInput()函数
&lt;input placeholder="输入城市名进行搜索" bindinput="bindKeyInput"&gt;&lt;/input&gt; &lt;view class="icon"&gt; &lt;icon type="search" size="25" bindtap="search" /&gt; &lt;/view&gt; 在js文件中编写代码，在Page()函数外声明一些变量，用于保存获取到的值，
var defaultcity, getweather, gettemp, getwind, getpic, getdate 然后编写input的bindKeyInput()事件处理函数
bindKeyInput:function(e){ defaultcity = e.detail.value }, 2.请求天气接口数据 点击搜索图标时，发起网络请求，调用获取天气API：
search: function(e) { var that = this wx.request({ url: 'https://api.map.baidu.com/telematics/v3/weather?output=json&amp;ak=这里写自己申请的百度ak&amp;location=' + defaultcity, success: res =&gt; { console.log(res.data) if (!res.data.results) { console.log('获取天气接口失败') return } getweather = res.data.results[0].weather_data[0].weather gettemp = res.data.results[0].weather_data[0].temperature getwind = res.data.results[0].weather_data[0].wind getpic = res.data.results[0].weather_data[0].dayPictureUrl getdate = res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12bf7c807e694d382a4e8f779509865a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e3590f5ce97219c3da97cc9be801cd/" rel="bookmark">
			lotus同一台机拆分P1、P2绑定CPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus同一台机拆分P1、P2绑定CPU 创建目录运行P1，绑定cpu 0-15运行P2，绑定cpu 16-31 创建目录 /tmp01 /tmp02 /seal/worker01 /seal/worker02 运行P1，绑定cpu 0-15 env TMPDIR=/tmp01 nohup taskset -c 0-15 lotus-worker --worker-repo=/seal/worker01 run --listen=192.168.1.10:3456 --precommit2=false --commit=false &gt;&gt; /var/log/calibnet/worker01.log 2&gt;&amp;1 &amp; 运行P2，绑定cpu 16-31 --no-local-storage 不指定目录 env TMPDIR=/tmp02 nohup taskset -c 16-31 lotus-worker --worker-repo=/seal/worker02 run --no-local-storage --listen=192.168.1.10:3457 --addpiece=false --precommit1=false --commit=false &gt;&gt; /var/log/calibnet/worker02.log 2&gt;&amp;1 &amp; 设置目录指向worker01 lotus-worker --worker-repo=/seal/worker02 storage attach /seal/worker01 # lotus-miner storage list Unsealed: 0; Sealed: 0; Caches: 0; Reserved: 0 B Weight: 10; Use: Seal Groups: k010 AllowTo: k010 URL: http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e3590f5ce97219c3da97cc9be801cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26aa3f0d4c690323ab0009597f53f69f/" rel="bookmark">
			c#实现文件批处理：剪切、复制、删除、改名、分类等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全栈工程师开发手册 （作者：栾鹏）
c#教程全解
c#实现文件批处理，包含批量剪切、复制、删除、按时间分类到不同文件夹，按格式分类到不同文件夹，以及批量修改名称等等。
c#批量剪切文件函数
/// &lt;summary&gt; /// 文件剪切、改名操作 /// &lt;/summary&gt; /// &lt;param name="srcdir"&gt;源文件夹&lt;/param&gt; /// &lt;param name="desdir"&gt;目的文件夹&lt;/param&gt; public static void file_cut(string srcdir,string desdir) { DirectoryInfo thefolder = new DirectoryInfo(srcdir); foreach (FileInfo nextfile in thefolder.GetFiles()) { try { string filename = nextfile.Name; string filefullname = nextfile.FullName; string mudi = desdir + "\\" + filename; File.Move(filefullname,mudi); } catch (System.Exception ex) { System.Console.WriteLine(ex.ToString()); } } } c#批量复制文件函数
/// &lt;summary&gt; /// 文件复制函数 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26aa3f0d4c690323ab0009597f53f69f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f69602bd30f4818fe062cdad2e22d2/" rel="bookmark">
			idea中依赖找不到，例如dependency ‘mysql-connector-java‘not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先先到File&gt;setting&gt;Build,Execution,Deployment&gt;BuildTool&gt;ignored Files中去查看你是不是默认了，如果那里勾选了请取消
2.点开importing
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf56d570e62cdb573c86b18526296117/" rel="bookmark">
			websocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是websocket？HTTP与WebSocket的关系快速入门SpringBoot+WebSocket 实时监控异常消息 什么是websocket？ WebSocket 协议是基于 TCP 的一种新的网络协议。它实现了客户端与服务器之间的全双工通信，既然是全双工，就说明了服务器可以主动发送信息给客户端。
为什么不使用 HTTP 协议呢？
这是因为HTTP是单工通信，通信只能由客户端发起，客户端请求一下，服务器处理一下,于是 websocket 应运而生。
WebSocket 相比普通的 Socket 来说，仅仅是借助 HTTP 协议完成握手，创建连接。后续的所有通信，都和 HTTP 协议无关。
HTTP与WebSocket的关系 结论：
WebSocket和HTTP都是基于TCP协议的两个不同的协议WebSocket依赖于HTTP连接 问题：
WebSocket依赖于HTTP连接，那么它如何从连接的HTTP协议转化为WebSocket协议？WebSocket为什么要依赖于HTTP协议的连接？ 每个WebSocket连接都始于一个HTTP请求。
具体来说，WebSocket协议在第一次握手连接时，通过HTTP协议在传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端：
GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ== Origin: http://example.com Sec-WebSocket-Version: 13 注意，关键的地方是，这里面有个Upgrade首部，用来把当前的HTTP请求升级到WebSocket协议，这是HTTP协议本身的内容，是为了扩展支持其他的通讯协议。
如果服务器支持新的协议，则必须返回101：
HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept:s3pPLMBiTxaQ9kYGzzhZRbK+xOo= 至此，HTTP请求物尽其用，如果成功触发onopen事件，否则触发onerror事件，后面的传输则不再依赖HTTP协议。
快速入门 1、 在 pom.xml 文件中，引入相关依赖。
&lt;dependencies&gt; &lt;!-- 实现对 WebSocket 相关依赖的引入，方便~ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf56d570e62cdb573c86b18526296117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6929dc1cbc5e16832ad3df0146717ebf/" rel="bookmark">
			【系统分析师之路】如何备考系统分析师与架构师（软件水平考试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何备考系统分析师与架构师考试 报考的背景与动机 2018年11月，经过了半年漫长的备考，参加了信息系统项目管理师(以下简称高项)的考试，虽然成绩还没有出来，但是自我估分后还是及格了，有点小兴奋也有一身的洪荒之力，浑身的学习气没有得到释放，怎么办呢？于是想继续学些对自己有用的东西。
在考过PMP和高项以后，为完善自己的管理类技能树，本想再去考个NPDP和系统集成项目管理师，但是NPDP考试价格不菲，而且目前的工作似乎在暂时派不上用场。想想如果没有一定的技术沉淀，要想做好管理是不大可能的。那么新的一年中是不是应该把注意力回到自己的技术提升上呢。掐指一算自己已经在IT行业划水划了13年了，如果在目前的工作岗位上坚持不下去了怎么办？因为年纪的缘故，要是再出去找IT类工作的话，没有两把刷子人家企业又凭什么会要我呢？虽然已经工作了13年，但一想到以上的种种痛点，不得不放下老司机的身段，决定摆正心态，好好扎实自己的技术。以考促学一直是很好的一种方式，于是决定将注意力放到了两个考试上：上半年的信息系统分析师和下半年的信息系统架构师。
1.系统分析师考试目标
通过本考试的合格人员应熟悉应用领域的业务，能分析用户的需求和约束条件，写出信息系统规格说明书，制定项目开发计划，协调信息系统开发与运行所涉及的各类人员；
能指导制定企业的战略数据规划，组织开发信息系统；
能评估与选用适宜的开发方法和工具；
能按照标准规范编写系统分析，设计文档；
能对开发过程进行质量控制与进度控制；
能具体指导项目开发；
具有高级工程师的实际工作能力和业务水平；
2.系统架构师的考试目标
通过本考试的合格人员，能够根据需求规格说明书，结合应用领域和技术发展的实际情况，考虑有关约束条件，设计正确合理的软件架构，确保系统架构具有良好的特征
能够按照相关标准编写相应的设计文档
能够与系统分析师，项目管理师相互协作，配合工作
具有高级工程师的实际工作能力和业务水平
系统分析师和架构师的介绍 信息系统分析师（简称系分）和信息系统架构师（简称架构）和高项一样，都是工信部的最高级别的考试，都考三门并且要三门同时45分以上才算过。这两个考试都是偏向IT技术类的认证。考过都可以评定高级职称，而且该项证书由国家工信部颁发，得到中日韩三国的相互认证，权威性就摆在那儿就不多做介绍了。大家都知道高项的证书不光可以用来评定职称，也是可以挂靠赚钱的（虽然现在挂靠越来越困难了），但和高项不同的是系分和架构却只能拿来评定职称和增加大城市落户的积分。而且系分和架构通过率比高项目更加低更加难通过，全国通过率常年维持在10%以下，每年全国通过者更是寥寥数百人，既然已经有把握拿到高项证书了，为什么还要去考系分和架构呢？
3.系统分析师考试要求
1）掌握信息系统的基础知识
2）掌握开发信息系统所需的综合技术知识（软件，硬件，网络，数据库）
3）熟悉企业或政府信息化建设，并掌握组织信息化战略规划的知识
4）掌握信息系统开发的过程和方法
5）熟悉信息系统开发标准
6）掌握信息安全的相关知识与技术
7）熟悉信息系统项目管理的知识与方法
8）掌握应用数学，经济与管理的相关基础知识，熟悉有关的法律法规
9）熟练阅读和正确理解相关领域的英文文献
4.系统架构师的考试要求
1）掌握计算机硬软件与网络的基本知识
2）熟悉信息系统开发过程
3）理解信息系统开发标准，常用信息技术标准
4）熟悉主流的中间件和应用服务器平台
5）掌握软件系统建模，系统架构设计基本技术
6）掌握信息安全技术，安全策略，安全管理知识
7）了解信息化，信息技术有关法律法规的基础知识
8）了解用户行业的特点，并根据行业特点架构合适的系统设计
9）掌握应用的基础数学知识
10）熟练阅读和正确理解相关领域英文文献
为什么选择去考系统分析师和架构师 综合自己的实际情况，我想原因有以下四点：
第一：既然在IT行业混了13年了，很多基础知识还是要补一补，学一学的。不然连跟自己小弟吹牛的资本都没有了，是不是会觉得自己混的很差啊。
第二：通过率低自然含金量就高了，给自己增值何乐而不为呢。享受学习的过程在某种层面上来说，比结果更加重要吧。而且通过备考论文，可以提高自己的写作能力，毕竟35岁这个年纪在IT业也到了该转型的年纪，相比代码，更重要的或许是写文档写PPT等沟通呈现等的能力吧。
第三：因为同为工信部的考试，高项的备考经验不是可以全部可以用上吗。把备考也作为一个项目来管理是不是很有意思和挑战呢。
第四：在拿到软件设计师证书后，其实自己在08年就参加过系分的考试，当时虽是裸考，但下午两门课都45分过了（运气好）。却死在了上午题中。这份残念一直延续了十年之久（残念变怨念，怨念变执念）。
系统分析师和架构师的区别在哪里 架构是09年的时候新开的，之后系分由每年两次变成了每年一次，形成了上半年系分，下半年架构的局面。系分和架构在性质和考核内容上，是有高度重合的。但两者还是有细微区别的。架构强调的是在需求明确的前提下，做出最佳的产品实现方案，更加纯粹的技术人员。而系分强调的是收集需求和在需求基础上系统建模，所以沟通项目管理能力都有所要求。
备考系统分析师的难点在哪里 相比工信部其他的考试，因为系分和架构的难度还是相当大的。每年的通过率毕竟就摆在那里。那么难点主要在哪里呢，在我看了考试大纲后，总结为一下三点：考试范围广，资料缺，需要项目经验。
首先，不管是系分还是架构，考试的范围都太广了，光是系分涉及的科目就有：计算机组成原理，操作系统，数据库，嵌入式，项目管理，计算机网络，多媒体，软件工程，软件架构，面向对象，信息化信息系统，法律法规和标准化，安全性，计算机英语，应用数学，系统配置与性能评价，各种新技术等。光一个章节在大学就是一门课，也就是说这项考试中等于考核了你20门学科的综合能力。就算是科班出身的人，也未必能够轻松通过，何况是像我一样上班又要兼顾家庭的人，时间就是资源，没有时间资源是覆盖不全这么广的范围的，不是吗。
其次总所周知，高项考试网络上的培训资料，视频满天飞，随便都可以度娘到，甚至淘宝上都可以花钱买到视频备考文件等。但系分和架构却寥寥无几。最权威的网站除了CSDN就是希赛网两个了吧。而官方教材【系统分析师教程】最后一次更新是在09年，也就是十年前了，很多新技术的考核往往超出了该书籍的范围。如何选择备考教材和备考资料也是一个不得不考虑的让人头疼的问题。希赛虽然有培训资料和视频，但是除了公开课以外，都是要收费的，要花至少5-7千大洋来买视频，对于工薪阶层的我来说还是很心疼的（于是决定自学）。
最后，准备这个考试，没有项目实战经验是不行的。下午2案例分析，形式是和高项一样，考得内容都是主观题，一共五道题，去掉两道题后作答三题。考察我们的分析思考能力，没有项目经验的积累，要写案例分析那是比较困难的，而且技术专项性太强，就算本人有嵌入式开发经验，要是考到了WEB类或者数据库类或是没有接触过的新技术，没有经验还是很难作答的。而且主观题给分也要看阅卷老师的心情。而下午2论文，相比高项的论文，系分和架构的论文范围更广，论题是四选一，押题几乎都不太可能。没有一定的经验，要想通过那是难上加难。而且两个小时写2500个字啊，现在都还记得写高项的论文写到手抽筋的情景。
如何突破难点达成目标 今天距离2019年5月18日系分开考还有166天（架构师考试太遥远，毕竟计划的制定要渐进明细嘛，明年4月份在制定计划吧）。于是在分析了系统分析师考试大纲后，我便以挣值管理的方式，制定了个人备考管理计划。其中时间是备考的稀缺资源，但时间可以靠挤出来的。时间上估算自己每天可投入项目时间为2个小时，那么到考试，我还有332人时的预算。在预算的资源里完成既定的学习备考计划就算完成项目。
虽然还有半年时间，但做了计划后才明白，留给自己的时间不够多了。而且对于有工作要加班有家庭有娃的社会人来说，时间预算不够的风险随时都可能发生（项目的风险管理）。
接下来，备考的教材已经在CSDN上面下载了电子版教材。经过筛选后我将教材锁定在系统分析师全程指导和历年真题上。历年考试的真题准备在淘宝上购买书籍，并决定认真做上两边。对于新技术新知识，还是平时上班多逛逛CSDN，以便跟上最新技术发展的行情。听老师录的视频讲解虽可以避免少走弯路节约工时，但综合考虑并做了决策树分析后（项目的立项管理），还是觉得自学为主，放弃视频学习资源。
最后对于自己项目经验缺乏的问题，决定采用有针对性的重点突破的策略。比如下午案例题只准备嵌入式的题目，放弃WEB类的题目备考。论文选题上，还是备考自己有工作经验熟悉的领域，比如软件工程项目管理，嵌入式等。一定一定一定要练好字和提前准备论文。同时主观题也好论文也好，应该也是有套路可循的。变得是题目，不变的是答题的模式和套路。我想这点应该通过反复做题和写文章是可以找到规律的吧。抓重点找捷径便是我应对自己项目经验广的有效对策吧。
结尾 有了对考试的分析（分析考纲的能力是最最基本的分析师的要求，毕竟本人先备考的是分析师嘛），有了项目管理计划(备考计划)，也买了相应的书籍（采购管理）。接下来如何督促自己在不影响工作生活的前提下，完成每天的学习计划，管理和监控项目工作，调整变更计划，并最终达成目标（项目的整体管理）。其实也是一个非常有趣的过程呢。做好每天每周的学习总结(项目的质量管理，PDCA)。先分析师再架构师。如能考试通过固然欣慰，但更希望自己能够在备考中享受学习的过程。或许系统分析师，系统架构师这两本证书并没有什么大用，但通过这个备考过程，为自己将来工作中的升职加薪，更好的管理项目工作相信还是很有帮助的。
过程大于结果，用结果来肯定自己的过程。并享受这个学习的过程。那么加油吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b829b5d60a534cd131a725445a39ba57/" rel="bookmark">
			Android————一个简单记账本(Bookkeeping)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android————一个简单记账本 简述实体类数据库建表Dao类 插入数据效果图布局代码适配器获取数据效果图布局代码 显示数据适配器效果图布局代码 最终效果图 简述 实现功能： 1：先将数据添加到数据库中(SQLite) 2: 使用RecyclerView将数据库中的数据展示出来 //备注：带加号的ImageButton用于添加数据，带勾的ImageButton用于获取数据并展示 //先按带加号的在按带勾的 实体类 public class Event { private String Title; private String Time; private double Money; public Event(){ } public Event(String Title, String Time, double Money) { this.Title = Title; this.Time = Time; this.Money = Money; } public String getTitle() { return Title; } public String getTime() { return Time; } public double getMoney() { return Money; } public void setTitle(String Title) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b829b5d60a534cd131a725445a39ba57/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/245/">«</a>
	<span class="pagination__item pagination__item--current">246/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/247/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>