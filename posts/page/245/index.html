<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad4131b4a5af32ae32823902093d73e/" rel="bookmark">
			SQL server 时间段 拆分为 每天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DECLARE @days INT,@date_start DATETIME,@date_end DATETIME ;
set @date_start= '2018-07-29'; set @date_end= '2018-09-01' ;
SET @days = DATEDIFF(DAY, @date_start, @date_end); select DATEADD(dd, number, @date_start) AS work_date
from master.dbo.spt_values
where type = 'p' and number &lt;=DATEDIFF(DAY, @date_start,@date_end)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e23bde40593a05c6bb1100f9d7e66325/" rel="bookmark">
			本机磁盘序列号和MAC地址查询方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 磁盘序列号查看方法
1、首先在开始菜单栏中输入cmd。
2、点击程序CMD。
3、然后输入diskpart并按下回车键，如下图所示。
4、接下来输入list disk，如下图所示。这样就可以看到我们的磁盘的相关信息了。
5、然后输入select disk 0并按下回车键。
6、最后输入detail disk并按下按下回车键，就可以查看我们磁盘的序列号了。
磁盘ID 就是磁盘序列号
=======================================================================
查看mac地址方法：
搜索控制面板，并打开 打开网络和共享中心点击“以太网”,物理地址即MAC地址 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95fc9f130b064d17d8b40aa51d729e26/" rel="bookmark">
			SpMV矩阵格式自动调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpMV的自动调优和矩阵格式和kernal实现都有关系，在这样的调研中，我们主要关注具体的建模和模型训练手段。
1、
Adaptive SpMV/SpMSpV on GPUs for Input Vectors of Varied Sparsity
在机器学习的应用中，不仅仅稀疏矩阵乘密集向量，稀疏矩阵乘稀疏向量也很多。这篇文章同时处理这两个问题，并且根据输入的实际情况，来选择最优的kernal实现。这篇文章的稀疏矩阵，默认采用CSR和CSC格式。
计算模式、线程的分配、线程中间结果的规约策略是kernal实现的三个方面。计算模式包括向量是稀疏的还是密集的，在SpMV中的线程是按照行方向遍历矩阵还是列方向遍历矩阵。线程的分配包括，是将行和列以对齐的方式分配给线程（每个线程固定一行或者一列），还是给每个线程分配相同数量的非零元（优先保证线程的负载均衡）。对于线程的计算方向和非零元分配如下图所示，同一个颜色代表分别到同一个线程的元素：
当每个线程按列处理数据时，每个线程都要更新y中的所有元素，这就有两种更新方法，一种是通过原子操作对显存上的y直接原子加（atom），还有一种是将每个线程中对每一行执行的中间结果按照&lt;行号，值&gt;的方式暂时放在显存中，然后按照行排序，将每一个线程同一行的中间结果排在一起，然后再用一个kernal来reduce by key，这种方式叫sort-based，可以不用同步的方式来规约结果。
这三种执行策略可以产生一个三层的决策树：
这里的1、2、3分别是用来做选择的机器学期模型，将输入矩阵和向量的特征分别输入这三个模型就能分别在三层中做选择。这些特征不赘述了，主要是一些矩阵和向量的形状、稀疏的程度、非零元的分布等信息，不同模型的输入是不一样的：
用的模型是decision tree，SVM，random forest，gradient tree boosting。
2、
Adaptive Optimization of Sparse Matrix-Vector Multiplication on Emerging Many-Core Architectures
在SpMV中，根据矩阵特征选格式。特征就是矩阵的形状和非零元分布的信息：
为了屏蔽数据结构之外因素的影响，文章将每个数据结构的SpMV实现调到了最优。文章选择以下模型做了测试：decision tree based model (DTC)，Gaussian naive bayes (GNB)，multilayer perception (MLP)，soft voting/majority rule Classification (VC)，k-Nearest Neighbor (KNC, k=1)，logistic regression (LR)，random forests classification (RFC)。
3、
Automatic Selection of Sparse Matrix Representation on GPUs
这篇文章认为已有的矩阵格式设计本质就是分块，已有的autotunning的本质就是调blocksize。这篇文章主要是根据不同的输入矩阵特征，从cuSPARSE、CUSP两个库中，选择ELL、CSR、COO、HYB的SpMV实现。是一个选库、选实现的工作。
使用的特征是如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95fc9f130b064d17d8b40aa51d729e26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa751e367195a1703b20e5547d344446/" rel="bookmark">
			SpMV稀疏格式调研
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对矩阵格式介绍的benchmark：
Evaluation Criteria for Sparse Matrix Storage Formats
类似于综述。这篇文章调研了2015年之前在多核共享内存系统中常见的矩阵格式。这篇文章认为，对于一个新的考虑一个针对SpMV的数据格式，仅仅使用FLOPS这样的指标是不够的，要考虑多个方面：1）FLOPS，和SpMV的执行时间相关；2）相对于CSR的执行时间；3）FLOPS占硬件极限性能的占比；4）SpMV的内存占用；5）每个非零元素的所占的平均内存；6）相对于CSR，每个非零元素的所占的平均内存；7）将CSR格式的、相对通用的格式转化为特定的新格式；8）格式转换的内存占用；9）格式的较优超参的寻找时间；10）格式的较优超参的寻找所占的内存。
一篇17年的综述，更详尽地总结了矩阵的格式（70种），并且将矩阵的格式分为了几类：
Sparse Matrix-Vector Multiplication on GPGPUs
这些格式主要按照几种初始格式的派生来分类：CSR、COO、ELL、DIA等。
分块矩阵的存储，用COO存储矩阵块，然后从CSR、COO、Bitmap、Dense选一个类型来存储子矩阵块内部的元素：
Adaptive-Blocking Hierarchical Storage Format for Sparse Matrices
整个的存储如上图所示。block matrix这一层（level 1）是以块为单位来存储，存的本质上是每一个块的索引。blocks这一层（level 0）存的是真正的数据。Level 1是完全按照COO的方式来存储的，level 0是完全依照最小空间占用的方式来选择合适的数据结构。只要知道下列信息，一种格式的空间复杂度可以很精确地算出：1）子块的长宽；2）子块的非零元数量；3）子块的索引数量；4）子块索引的数据类型所占的字节数；5）非零元数据类型所占的字节数。基于这些信息，每种存储方式的空间复杂度都可以得出，就可以选择了。这个工作没有考虑到性能问题。
通过简单的预处理，解决GPU负载均衡的问题：
Fast Sparse Matrix-Vector Multiplication on GPUs for Graph Applications
在动态图分析这类应用中，SpMV的矩阵一直在变化，没有什么机会来进行长时间的、精细的预处理来转换矩阵格式。文章提出了一种新的格式，几乎不需要对传统的通用格式CSR进行转换，只需要统计一下CSR格式中每一行非零元的数量就可以了就足够了。这篇文章的设计主要建立在两个观点上。
第一个观点是，在GPU中，为了保证数据的合并读取，应该让线程在行方向上并行。一个线程块负责一行中的连续非零元。
第二个观点是，很多现实的图存在严重的幂律分布，有些行需要很多的线程数量，有些行中的非零元甚至塞不满一个thread wrap（如下图所示）。这些不同类型的行需要用不同的方式处理。
所以这篇文章提出了ACSR，采用的方式总体如下图，首先就是将不同的行按照非零元的数量归类到不同的桶（Bin）中，（简单来说）每个桶启动一个内核：
对非零元比较多的行按照行为单位来执行SpMV，在这个内核中不执行任何计算（图中Parent内核），而是去根据每一行的非零元数量计算出这一行所需要的线程块的大小，然后进一步对每一行启动一个新的内核（Parent后面的SpMV）来执行真正的SpMV计算。
对非零元比较少的行以组（Bin）为单位来执行SpMV（如图中的上面两个SpMV）。这样子就保证了一些非零元特别少的组（Bin）中，可以合并到一个内核中进行处理，防止因为非零元实在是太小，甚至不到一个Thread wrap所导致的难以高效地并行。
针对ELL格式的进一步调整，打破一个线程负责ELL一行的现状。通过一个线程处理多行或者多个线程处理一行数据，来均衡各个线程的负载。从而进一步平衡wrap内不同线程的负载，以及不同wrap之间的负载：
AdELL: An Adaptive Warp-Balancing ELL Format for Efficient Sparse Matrix-Vector Multiplication on GPUs
上面这个AdELL的设计主要是为了保证一个wrap内部不同线程的负载均衡。AdELL后面两个矩阵一个是值一个是列索引。他的主要处理就是将比较长的行在列方向上进行折叠（保护y=Ax中x的局部性），由多个线程处理。通过保证事实上负责一行的多个线程源自于一个wrap，可以利用wrap内自带的同步来完成对于同一位y中元素的更新（A中同一行的数据被用于更新y中的一位）。上面这张图w代表wrap，wrap size是4。前面几个数组都是元数据。因为是ELL操作，所以数据所列号的记录也是需要补零的。
此外，因为存在多个thread处理一行的问题，所以需要用其中一个thread规约一行的结果，这个thread被记录在Reduction Map里面。K里面放的是每个wrap的负载，并累计起来的结果。
此外，因为每个SM可以调度的block数量有限，如果wrap之间的负载不均衡，会导致block因为大的尾部延迟退出不了，占用调度资源。为了平衡Wrap之间的负载，AdELL使用了一种相对简单的思路。首先计算每一行所需要的线程数量，使得每个线程的负载差不多（这是关键）。然后用贪婪算法、在不超过wrap容量（总非零元数量/wrap数量，此外每个wrap不能超过32个线程）的前提下，尽可能将占用线程多的行分配给可以装得下的wrap，类似于“先装石头、再装沙子、再装水”的思路。这种方式可以保证wrap之间的负载均衡，但是会打乱已有的行排序，需要加入新的索引来记录一个wrap要处理的行，以及线程对行中小块的对应关系。
在GPU上的CSR格式，在总体上按行并行的同时，每一行还能再分chunk，一个chunk一个线程，在行维度进一步增加并行度，解决CSR中线程不均衡的问题：
Adaptive row-grouped CSR format for storing of sparse matrices on GPU
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa751e367195a1703b20e5547d344446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd94eade019853231c645ae89a4a7c8d/" rel="bookmark">
			数据资产管理介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据资产管理介绍 1.定义 在明白数据资产管理之前，要明白管理的数据资产是什么？
“数据资产”定义为：“由企业拥有或控制的，能够为企业带来未来经济利益的，以物理或者电子的方式记录的数据资源，如文件资料、电子数据等。”
从上面的数据资产定义来看，数据资产具有如下3个特征：
1）“企业拥有或控制”。 这个特征指明数据是有其主体的，同时也说明数据资源既可能来源于企业内部的信息系统或者日常经营活动的沉淀， 可能是企业通过外部的交换、购买等手段获取的。
2）“能带来未来经济利益”。 这个特征清楚表明，在企业中，并非所有的数据都构成数据资产，数据资产是能够为企业产生价值的数据资源。
3）“数据资源”。 这个特征表明数据资产的存在形态，是以物理或者电子方式记录下来的数据。
“数据资产管理”的定义为：“规划、控制和提供数据及信息资产的一组业务职能，包括开发、执行和监督有关数据的计划、政策、方案、项目、流程、方法和程序，从而控制、保护、交付和提高数据资产的价值。”
数据资产管理在数据中台架构中处于中间位置，介于数据开发和数据应用之间，处于承上启下的重要地位。数据资产管理对上支持以价值挖掘和业务赋能为导向的数据应用开发，对下依托大数据平台实现数据全生命周期的管理，并对企业数据资产的价值、质量进行评估，促进企业数据资产不断自我完善，持续向业务输出动力。
2.数据资产管理现状和挑战 缺乏统一的数据视图：数据资源分布在企业的多个业务系统中，分布在线上和线下，甚至分布在企业的外部。
数据基础薄弱：大部分企业的数据基础还很薄弱，存在数据标准混乱、数据质量参差不齐、各业务系统之间数据孤岛化严重、没有进行数据资产的萃取等现象，阻碍了数据的有效应用。
数据应用不足：受限于数据基础薄弱和应用能力不足，多数企业的数据应用刚刚起步，主要在精准营销、舆情感知和风险控制等有限场景中进行了一些探索，数据应用的深度不够，应用空间亟待开拓。
数据价值难估：企业难以对数据对业务的贡献进行评估，从而难以像运营有形资产一样运营数据。产生这个问题的原因有两个：一是没有建立起合理的数据价值评估模型；二是数据价值与企业的商业模式密不可分，在不同应用场景下，同一项数据资产的价值可能截然不同。
缺乏安全的数据环境：数据的价值越来越得到全社会的广泛认可，但随之而来的是针对数据的犯罪活动日渐猖獗，数据泄露、个人隐私受到侵害等现象层出不穷。很多数据犯罪是由安全管理制度不完善、缺乏相应的数据安全管控措施导致的
数据管理浮于表面：没有建立一套数据驱动的组织管理制度和流程，没有建设先进的数据管理平台工具，导致数据管理工作很难落地。
回到顶部
数据资产管理 1.目标 可见：通过对数据资产的全面盘点，形成数据资产地图。针对数据生产者、管理者、使用者等不同的角色，用数据资产目录的方式共享数据资产，用户可以快速、精确地查找到自己关心的数据资产。
可懂：通过元数据管理，完善对数据资产的描述。同时在数据资产的建设过程中，注重数据资产业务含义的提炼，将数据加工和组织成人人 可懂的、无歧义的数据资产。具体来说，在数据中台之上，需要将数据资产进行标签化。标签是面向业务视角的数据组织方式。
可用：通过统一数据标准、提升数据质量和数据安全性等措施，增强数据的可信度，让数据科学家和数据分析人员没有后顾之忧，放心使用数据资产，降低因为数据不可用、不可信而带来的沟通成本和管理成本。
可运营：数据资产运营的最终目的是让数据价值越滚越大，因此数据资产运营要始终围绕资产价值来开展。通过建立一套符合数据驱动的组织管理制度流程和价值评估体系，改进数据资产建设过程，提升数据资产管理的水平，提升数据资产的价值。
2.数据资产管理vs数据治理 数据治理（Data Governance，DG）是指对数据资产管理行使权力和控制的活动集合（规划、监督和执行）。传统的数据治理内容通常包含数据标准管理、元数据管理、数据质量管理、数据安全管理、数据生命周期管理等内容
数据治理的目标是保障数据资产的质量，促进数据资产的价值创造。这个根本目标可以分解成以下6项：
提升数据质量，帮助做出基于数据的更高效、更准确的决策；构建统一的、可执行的数据标准；良好地响应数据生产者、消费者、数据处理技术人员等数据利益相关者的需求，如保护好客户（数据生产者）的数据隐私和数据安全；培训组织内所有的管理层和员工，让大家采用共同的解决数据问题的办法；实现可重复的数据管理流程，并确保流程透明；实现数据的可持续运营、数据资产的增值。 数据治理的6个原则：
标准化原则：数据标准化是实现高价值数据、支撑以数据为基础的相关业务的先决条件。组织必须制定可参考、可落地的标准。透明原则：除了一些需要保密的安全措施之外，数据治理相关的文件、数据问题的发现等，都应该是公开透明的，相关人员应该清楚正在发生的事情，以及事情发生后应如何按照原则处理。数据的认责与问责：数据治理必须解决无人问责的问题，比如将很多岗位列为负责人，最终却没有人真正负责。数据的认责是数据治理的先决条件，数据的问责和考核制度是确保数据治理工作真正落地的制度保障。平衡原则：在大数据时代，时时刻刻都在涌现海量数据。在进行数据治理工作的过程中，必须在代价和收益之间取得平衡。往往没有必要追求百分之百的数据质量，而对于历史遗留数据，数据标准也不可能对其进行完全约束。很多时候，对于企业来说，数据可商用是平衡原则的重要参考。变更原则：随着市场和业务的不断发展，数据标准、元数据、数据质量等要求并不是一成不变的，既要控制数据的变更流程，也要主动适应这些变化，推动标准更新。持续改进原则：业务在不断变化，数据在持续产生，数据治理非朝夕之功，需要持续推动，不断改进，形成长效机制。 数据治理和数据资产管理的定义有异曲同工之处，它们围绕的对象都是数据资产。数据标准管理、元数据管理、数据质量管理和数据安全管理等同时也属于传统数据治理的必要工作内容。数据资产管理在传统数据治理的基础上，加入了数据价值管理、数据共享管理等内容。可以这么理解：数据资产管理就是传统的数据治理的升级版，可以认为是数据治理2.0。
3.数据资产管理职能 《数据资产管理实践白皮书4.0》中规定，数据资产管理的管理职能包括数据标准管理、数据模型管理、元数据管理、主数据管理、数据质量管理、数据安全管理、数据价值管理和数据共享管理共8个方面。而在数据中台中，还可以包括数据资产门户、生命周期管理、 标签管理3个新的管理职能。
1.数据标准管理
大数据的标准体系框架共由7个类别的标准组成，分别为基础标准、数据标准、技术标准、平台和工具标准、管理标准、安全和隐私标准及行业应用标准。
数据标准是对数据的表达、格式及定义的一致约定，包含数据业务属性、技术属性和管理属性的统一定义；数据标准的目的是使组织内外部使用和交换的数据是一致的、准确的。通常可分为业务术语标准，参考数据和主数据标准，数据元标准，指标数据标准。
业务术语是被批准、管理的业务概念定义的描述，需要通过流程来定义组织如何创建、审批、修改和发布统一的业务术语。参考数据是用于将其他数据进行分类或目录整编的数据，可以简单理解为是数据字典，是数据可能的取值范围。主数据是组织中需要跨系统、跨部门共享的核心业务实体数据。主数据因为其重要价值，被喻为企业的黄金数据记录，如多个系统共享的客户、商品等核心业务实体数据。数据元是用一组属性描述其定义、标识、表示和允许值的数据单元，是描述数据的最基本单元。数据元由3部分组成：对象类、特性、表示值域和数据类型的组合。指标数据是组织在经营分析过程中衡量某一个目标或事物的数据，一般由指标名称、指标解释、时间限定、其他条件限定、指标数值等组成，如企业的人均利润率、季度离职率等。 数据标准管理是指数据标准的制定和实施的一系列活动，关键活动包括：
理解数据标准化需求；构建数据标准体系和规范；规划制定数据标准化的实施路线和方案；制定数据标准管理办法和实施流程要求；建设数据标准管理工具，推动数据标准的执行落地；评估数据标准化工作的开展情况。 数据标准化的难题和应对方案：
一是制定的数据标准本身有问题。 有些标准一味地追求先进，向行业领先者看齐，标准大而全，脱离实际的数据情况，导致很难落地。
二是在标准化推进过程中出了问题。 这是笔者重点阐述的原因，主要有以下几种情况：
对建设数据标准的目的不明确过分依赖咨询公司对数据标准化的难度估计不足缺乏落地的制度和流程规划组织管理水平不足 应对方案：
第一，制定可落地的执行方案。 执行方案要侧重于可落地性，不能落地的方案最终只能被废弃。一个可落地的方案要有组织架构和人员分工，每个人负责什么，如何考核，怎么监管，都必须纳入执行方案中。第二，正确认识数据标准建设的目， 即是统一组织内的数据口径，指导信息系统建设，提高数据质量，更可信地处理和交换数据，而不是应付上级和监管机构的检查。第三，正确认识咨询公司在数据资产管理工作前期的作用。 咨询公司的定位应该是准确评估组织的数据管理水平，制订可以落地的方案，而不应一味地追求咨询输出物的技术含量。第四，充分认识到数据标准化的难度。 要取得管理决策层的支持，提升组织管理水平，做好长期推进的工作准备，建立起数据标准化的工作制度和流程，遇到问题通过正式的流程和沟通机制逐步解决。第五，实际落地中，建立起科学可行的数据标准落地形式。 2.数据模型管理
数据模型是指对现实世界数据特征的抽象，用于描述一组数据的概念和定义。数据模型从抽象层次上描述了数据的静态特征、动态行为和约束条件。
数据模型管理主要是为了解决架构设计和数据开发的不一致，而对数据开发中的表名、字段名等规范性进行约束。数据模型管理一般与数据标准相结合，通过模型管理维护各级模型的映射关系，通过关联数据标准来保证最终数据开发的规范性。理想的数据模型应该具有非冗余、稳定、一致和易用等特征。
数据模型按不同的应用层次分成概念数据模型、逻辑数据模型、物理数据模型3种。
概念模型是一种面向用户、面向客观世界的模型，主要用来描述世界的概念化结构，与具体的数据库管理系统无关。逻辑模型是一种以概念模型的框架为基础，根据业务条线、业务事项、业务流程、业务场景的需要，设计的面向业务实现的数据模型。逻辑模型可用于指导在不同的数据库管理系统中实现。逻辑数据模型包括网状数据模型、层次数据模型等。物理模型是一种面向计算机物理表示的模型，描述了数据在存储介质上的组织结构。物理模型的设计应基于逻辑模型的成果，以保证实现业务需求。它不但与具体的数据库管理系统有关，而且还与操作系统和硬件有关，同时考虑系统性能的相关要求。 数据模型管理的关键活动包括：
定义和分析企业数据需求；定义标准化的业务用语、单词、域、编码等；设计标准化数据模型，遵循数据设计规范；制定数据模型管理办法和实施流程要求；建设数据模型管理工具，统一管控企业数据模型。 数据模型是数据资产管理的基础，一个完整、可扩展、稳定的数据模型对于数据资产管理的成功起着重要的作用。通过数据模型管理可以清楚地表达企业内部各种业务主体之间的数据相关性，使不同部门的业务人员、应用开发人员和系统管理人员获得关于企业内部业务数据的统一完整视图。
3.元数据管理
元数据（Metadata）是描述数据的数据。元数据按用途不同分为技术元数据、业务元数据和管理元数据。详情见数据中台(元数据篇)
4.主数据管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd94eade019853231c645ae89a4a7c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d0b00c11a4eb7985de89a7590bb1f5/" rel="bookmark">
			com.baomidou.mybatisplus.autoconfigure.IdentifierGeneratorAutoConfiguration$InetUtilsAutoConfig.iden
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错日志：
*************************** APPLICATION FAILED TO START *************************** Description: An attempt was made to call a method that does not exist. The attempt was made from the following location: com.baomidou.mybatisplus.autoconfigure.IdentifierGeneratorAutoConfiguration$InetUtilsAutoConfig.identifierGenerator(IdentifierGeneratorAutoConfiguration.java:44) The following method did not exist: com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator.&lt;init&gt;(Ljava/net/InetAddress;)V The calling method's class, com.baomidou.mybatisplus.autoconfigure.IdentifierGeneratorAutoConfiguration$InetUtilsAutoConfig, was loaded from the following location: jar:file:/E:/software/JarLocalRepository/com/baomidou/mybatis-plus-boot-starter/3.5.1/mybatis-plus-boot-starter-3.5.1.jar!/com/baomidou/mybatisplus/autoconfigure/IdentifierGeneratorAutoConfiguration$InetUtilsAutoConfig.class The called method's class, com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator, is available from the following locations: jar:file:/E:/software/JarLocalRepository/com/baomidou/mybatis-plus-core/3.3.0/mybatis-plus-core-3.3.0.jar!/com/baomidou/mybatisplus/core/incrementer/DefaultIdentifierGenerator.class The called method's class hierarchy was loaded from the following locations: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d0b00c11a4eb7985de89a7590bb1f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d028605be140898ec25ccd3b1f477204/" rel="bookmark">
			常用网址链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题搜索 百度、CSDN搜索
资源下载 PPT模板、 脚本之家开发书籍、阿里巴巴图标下载、项目构建工具gradle下载、字体下载
电子书下载 github编程中文书籍
官方网站 SpringCloud
系统教程 书栈网（前后端线上书籍免费阅读）、 腾讯云开发者手册(包括前后端、服务器常用技术，如C、Go、JavaScript、CSS、PHP、Nginx)、w3cschool.cn、华为云JDK下载
Java开发 maven、jetbrains开发IDE插件仓库、
有哪些学JAVA的微信公众号推荐？ 、Java代码精简之道、SpringBoot常用注解、SpringBoot参数校验、SpringBoot技术栈搭建个人博客、
mybatis 官方教程、结果映射
mybatis-plus 官网、mybatisPlus自动代码生成实例、
C# C#基础
MySQL 朱双印博客mysql、 DATE_FORMAT() 函数格式
HTML与CSS SCSS
JavaScript 亚马逊Web 开发技术、亚马逊JavaScript教程、 阮一峰 JavaScript 教程、廖雪峰JavaScript教程、ES6入门、Echarts
js库：BootCDN、数据写入JSON文件
vue vue官方教程、Vue路由、 elementUI组件、vant组件、
vue-cli4.x构建的项目的执行顺序详解
uni-app 官方组件、DCloud插件市场、
书栈网uni-app教程、
echarts Echarts官网、Echarts配置项（重点）、Echarts官网示例、Echarts社区示例、w3cschool.cn关于Echarts教程、Echarts3、 echarts进阶操作、
Linux Linux系统运维
Docker docker仓库、
docker-compose详解、
nginx nginx从入门到精通、
ELK Kibana 用户手册、logstash参考手册、
区块链 Hyperledger Fabric动态配置Raft节点、
代码管理 码云、github
开发工具 清华大学开源软件镜像站、工具大全、JSON美化、时区名称
开源工具 JavaScript excel表格LuckySheet、
办公软件 typora快捷键如何修改、
网络协议 关于HTTP协议，一篇就够了、网络协议 – HTTP协议，get和post的区别？、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ee8c92f3357108666061941d9965e1/" rel="bookmark">
			R语言中实现随机森林建模的包randomForest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍randomForest()的用法参数介绍输出参数实例 varImpPlot()的用法参数介绍实例 介绍 randomForest 使用 Breiman 的随机森林算法(based on Breiman and Cutler’s original Fortran code)实现分类和回归。它也具有无监督模式(unsupervised mode for assessing proximities among data points).
randomForest()的用法 ## S3 method for class 'formula' randomForest(formula, data=NULL, ..., subset, na.action=na.fail) ## Default S3 method: randomForest(x, y=NULL, xtest=NULL, ytest=NULL, ntree=500, mtry=if (!is.null(y) &amp;&amp; !is.factor(y)) max(floor(ncol(x)/3), 1) else floor(sqrt(ncol(x))), replace=TRUE, classwt=NULL, cutoff, strata, sampsize = if (replace) nrow(x) else ceiling(.632*nrow(x)), nodesize = if (!is.null(y) &amp;&amp; !is.factor(y)) 5 else 1, maxnodes = NULL, importance=FALSE, localImp=FALSE, nPerm=1, proximity, oob.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ee8c92f3357108666061941d9965e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf4cdef424c79bca30edaf3da1b9af0/" rel="bookmark">
			五分钟写一个VUE结合SpringBoot的单表增删改查带JWT登录功能界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先先准备WebStorm与IDEA
数据库准备一个简单的表
CREATE TABLE `sys_user` ( `id` int NOT NULL AUTO_INCREMENT COMMENT '主键', `username` char(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '用户名', `password` char(16) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '密码', `nickname` char(30) COLLATE utf8mb4_unicode_ci DEFAULT 'NewUser' COMMENT '昵称', `email` char(30) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '邮箱', `phone` char(11) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '手机号', `address` char(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '地址', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`id`), UNIQUE KEY `idx_username` (`username`) ) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci 后端的Mybatis实现一下Mapper
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cf4cdef424c79bca30edaf3da1b9af0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371eda0cfaea2278472c65ce9bc7c70e/" rel="bookmark">
			认识和学习orchestrator之基本使用篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01
介绍
orchestrator目前GitHub上star 4.5k+，非常适用于有多个数据中心MySQL集群的管理。该工具使用起来很简单，但能用好却不容易，其配置参数将近200个，后端存储表47张，下面将介绍orchestrator以及它的使用方法。
02
orchestrator是什么
2.1 功能
其是一个管理MySQL复制拓扑的高可用、管理、可视化的工具。会定时采集探测到的各个实例的元数据信息，并将其存储在后端的DB库中。后端库支持的DB类型有SQLite和MySQL两种。
相比较于MHA等常用管理工具，其支持高可用部署，并对故障进行一个完整的探测分析后才会做相应的故障转移，探测更精准、全面。
依赖于采集的各个实例的元数据信息，其具有如下功能和特色：
发现实例
通过指定复制集集群里任意一个节点实例，其可以主动遍历该复制集的拓扑结构，还能读取MySQL的相关信息，如复制信息、配置、状态信息等；
重构拓扑结构
对已经发现的复制集集群，其可以通过命令、图形化的拖拽等方式，对现有复制集的关系进行重构；
故障恢复
orchestrator通过一个整体的方式来探测Master或者中间库的故障，支持优雅切换、自动故障切换、手动强制切换等多种故障切换方式；
2.2 部署架构
测试环境中，使用单点即可。orchestrator本身基于 Raft 实现高可用，避免了单点故障问题。部署架构支持单点、半高可用、高可用等多种方式。关于部署架构，后面会单独介绍下。
生产推荐的部署架构
共享后端库架构
raft部署架构
03
相关配置
3.1 orchestrator后端库的配置和权限
orchestrator对各个实例的采集信息会存储在后端库中，后端库只供orchestrator自己本身使用，可做如下的配置：
MySQL 由于orchestrator会在后端创建一些表，且创建的库是由orchestrator自身使用，可以直接赋权库的all权限；
CREATE DATABASE IF NOT EXISTS orchestrator; CREATE USER 'orch_backend'@'127.0.0.1' IDENTIFIED BY 'orch_backend_password'; GRANT ALL PRIVILEGES ON `orchestrator`.* TO 'orch_backend'@'127.0.0.1'; orchestrator.conf.json的配置
针对后端库的认证配置，使用如下参数进行配置
{ "MySQLOrchestratorHost": "127.0.0.1", "MySQLOrchestratorPort": 3306, "MySQLOrchestratorMaxPoolConnections": 4, "MySQLOrchestratorDatabase": "orchestrator", "MySQLOrchestratorUser": "orch_backend", "MySQLOrchestratorPassword": "orch_backend_password", "MySQLOrchestratorUseMutualTLS": false, } 还可以使用MySQLOrchestratorCredentialsConfigFile参数，指定一个类似.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/371eda0cfaea2278472c65ce9bc7c70e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd11560b5dfd3339c66fe4f65566dfce/" rel="bookmark">
			VisionTransformer（一）—— Embedding Patched与Word embedding及其实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Embedding Patched与Word embedding及其实现 前言
零、VIT是什么？
一、Word Embedding
1）为什么要有Word Embedding
2）Word Embedding在做什么
二、Embedding Patch
1）将图片进行划分成Patch
2) N(embeded_dim)维空间映射
3）实现 Embedding Patch
总结
前言 VisionTransformer可以说火到不得不会的程度，而本人之前其实对NLP领域了解不是很多，在学习中，认为在VIT论文里比较值得学习的地方有两点，一个是对图片的预处理成image token的Embedding Patched，另一个则是Transformer模块里的多头注意力模块，这次先讲讲个人Embedding Patched的理解。
零、VIT是什么？ 在了解其他东西前，先对VIT做一个，个人简单的理解与概况。 这里简单的说VIT其实就是作者想对image采取和context一样的处理方法，将image像context一样处理成一个个token，然后送到transform中，然后再接上一个分类头，就得到了一个基于transform的分类器了。
所以说其实要搞懂VIT，我画了一个图，其实就是两部分：
一部分就是如何将image处理成token的样子——Embedding Patch。另一部分就是transformer，而这里的transformer相较与NLP里的transformer是没有Decoder部分的，所以只有Encoder。而Encoder部分网络，除了多头注意力模块——Multi-Head Attention以外的其他部分实现起来是很简单的，所以另一部分就要研究的就是这个多头注意力机制。 而这篇文章，主要讲解一下个人对Embedding Patch的理解。 一、Word Embedding 想要对Embedding Patch有比较好的了解，个人认为有必要简单介绍一下在NLP领域里的Word Embedding技术，对比学习，会有更深的理解。
1）为什么要有Word Embedding Word Embedding简单的说，其实就是一种token（词）到向量的映射编码。
为什么需要做这件事呢，下面举个例子来说明这件事。
有一个句子：今天天气不错，我要去看电影。假如我们想要机器就认识这个句子，那我们可以采取先对这个句子每个部分进行分词，然后对每个分词出来的单词进行编码，那么下次在遇到相应的单词时，就可以通过查这个编码，去获得这个句子的意思了。
今天天气不错，我要去看电影。可以通过分词划分为，今天/天气/不错/，/我/要去/看/电影这8个词，那么我们对这八个词进行one-hot编码，比如今天可以得到编码为[1,0,0,0,0,0,0,0],而我则被编码为[0,0,0,0,1,0,0,0].
那么当下次遇到句子：今天去看电影，机器只要先对这个句子进行分词，然后在自己的码表中查找相应的编码，那么机器就可以认识这个句子了。
但我们现在考虑两个问题就是：
中文的字和词太多了，如果按照这个方法进行one-hot编码，那么这个码表，少说也是一个5000*5000的稀疏矩阵，如果要用这个矩阵去给机器进行学习，是十分耗费内存和浪费时间的。使用one-hot编码，词和词之间丢失了关联性。比如对于中文来说，我和你应该属于近义词，英语里cat和cats更应该是相近的词，但如果使用了one-hot编码，词与词之间的相似性被丢弃了，也不利于机器进行学习。 所以就引入了word embedding的做法。 2）Word Embedding在做什么 现在，每个token不仅停留在独热编码，而是把每个token的独热编码再映射为N维（embedded_dim）空间上的点。比如今天可以再次后编码为[0.1，0.2，0.3]， 我则编码为[0.5，0.6，0.6].
所以说整个word embedding（广义）具体在做什么事情，我用两步来概括：
对context进行分词操作。对分好的词进行one-hot编码，根据学习相应的权重对one-hot编码进行N（embedded_dim）维空间的映射. 这里针对第二点，以我们上面的例子来说，今天天气不错，我要去看电影这个句子，通过one-hot编码，整个句子可以表示为一个8X8的矩阵，我们通过学习一个权重矩阵，其大小为8X(embedded_dim)，那么与其相乘，就相对于做了一个到（embedded_dim）维的映射，得到8X（embedded_dim）的矩阵。
而如果我们对这N维的空间上的点进行降维，会发现意思相近的词，相互靠近的情况
例如上图，man和king的点更加相近，cat和cats也更加相近。所以word embedding即解决了one-hot编码稀疏矩阵的问题，又使编码的向量具有的语义信息。
二、Embedding Patch word embedding是针对context进行编码，便于使机器进行学习的方法，而Embedding patch则是针对image进行编码，便于机器学习的方法。而像作者说的，作者的本义其实就是在想，将image当成context一样去处理。
所以Embedding patch也其实在做两步：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd11560b5dfd3339c66fe4f65566dfce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e22ad635d1dcbf37c86048b37488f69/" rel="bookmark">
			Linux驱动_多点电容触摸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一丶Linux下多点电容触摸驱动框架 ① 电容触摸屏IC是FT5426,为IIC协议芯片,因此需要编写IIC驱动
② 触摸IC会发出中断信号，并在中断服务函数中上报信息，因此需要编写中断框架
③ 触摸屏向Linux内核上报的信息都属于Input子系统，因此需要编写Input子系统
④ 上报的信息需要满足Input子系统的多点电容触摸协议
二、多点电容触摸协议 在Documentation/input/multitouch-protocol.txt。
MT协议主要是分为2种type A和type B。
type B适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过slot更新某一个触摸点的信息， FT5426就属于此类型。
在中断函数中我们需要将触摸点的信息上报给Linux内核,在协议文档中介绍了，触摸点的信息通过ABS_MT事件上传给内核的。
相关事件的宏定义如下：
#define ABS_MT_SLOT 0x2f /* MT slot being modified */ #define ABS_MT_TOUCH_MAJOR 0x30 /* Major axis of touching ellipse */ #define ABS_MT_TOUCH_MINOR 0x31 /* Minor axis (omit if circular) */ #define ABS_MT_WIDTH_MAJOR 0x32 /* Major axis of approaching ellipse */ #define ABS_MT_WIDTH_MINOR 0x33 /* Minor axis (omit if circular) */ #define ABS_MT_ORIENTATION 0x34 /* Ellipse orientation */ #define ABS_MT_POSITION_X 0x35 /* Center X touch position */ #define ABS_MT_POSITION_Y 0x36 /* Center Y touch position */ #define ABS_MT_TOOL_TYPE 0x37 /* Type of touching device */ #define ABS_MT_BLOB_ID 0x38 /* Group a set of packets as a blob */ #define ABS_MT_TRACKING_ID 0x39 /* Unique ID of initiated contact */ #define ABS_MT_PRESSURE 0x3a /* Pressure on contact area */ #define ABS_MT_DISTANCE 0x3b /* Contact hover distance */ #define ABS_MT_TOOL_X 0x3c /* Center X tool position */ #define ABS_MT_TOOL_Y 0x3d /* Center Y tool position */ 从名称中我们不难看出， ABS_MT_POSITION_X 和ABS_MT_POSITION_Y 表示触摸点的X、Y坐标。ABS_MT_SLOT 用来上报触摸点的ID，除此之外，对于我们使用的满足type B类型的IC芯片，还需要使用ABS_MT_TRACKING_ID 关联每一个SLOT信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e22ad635d1dcbf37c86048b37488f69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1bcf2c693f307d56fdd7319927981b1/" rel="bookmark">
			c&#43;&#43; 中括号字符串转换成数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;utility&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;unordered_map&gt; #include &lt;unordered_set&gt; #include &lt;algorithm&gt; #include &lt;numeric&gt; using namespace std; class NestedVec { public: NestedVec() { valid = false; _value = 0; } explicit NestedVec(int value) { valid = true; _value = value; } bool isInteger() const { return valid; } int getInteger() const { return _value; } void setInteger(int value) { valid = true; _value = value; } void add(const NestedVec &amp;ni) { vn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1bcf2c693f307d56fdd7319927981b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39779d2c438e960f3e40ad55e56f39f4/" rel="bookmark">
			yaml语法和303检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ymal语法 创建application.yaml
application.properties
语法结构 ：key=value application.yml
语法结构 ：key：空格 value 这种语言以数据作为中心，而不是以标记语言为重点！
说明：语法要求严格！
1、空格不能省略
2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。
3、属性和值的大小写都是十分敏感的
基本语法：对空格要求很高
#k: v空格不能丢 #注入到我们的配置中 #对象 student: name:ws age:8 #行内写法 student2: {name: ws,age: 8} #数组 pets: -dog -cat -pig pets2: [cat,dog.pig] 在application.properties中
k: v student.name=ws 通过yaml给实体类赋值 实体类Person.java
package com.liu.pojo; import org.springframework.stereotype.Component; import java.util.Date; import java.util.List; import java.util.Map; @Component public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; public Person() { } public Person(String name, Integer age, Boolean happy, Date birth, Map&lt;String, Object&gt; maps, List&lt;Object&gt; lists, Dog dog) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39779d2c438e960f3e40ad55e56f39f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29a23fa38152206d514fcf9860113b9/" rel="bookmark">
			银行账户管理体系总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		银行账户管理体系总结 账户是机构与客户之间关系维系的直接纽带，客户的每一个金融需求都会通过账户最直接地与金融机构产品联系。因此，账户管理是银行业务流程过程中十分重要且必备的环节之一，在银行业务流程中起着承上启下的作用，其重要性不言而喻。但近年来，各类金融诈骗、客户资料泄露、账户盗用等违法活动层出不穷，其中绝大部分案例均与新兴支付手段有关，这直接反映了当前账户管理体系存在的巨大问题。
那么，如何确保客户账户资金和信息的安全、如何在提供创新与敏捷的同时有效防范风险，是账户体系建设需要一直平衡的关键点。在满足监管合规需求下，构建账户层结构足够灵活、可扩展、参数化、易融合的统一账户体系设计，是各家银行提高账户使用粘性的基础，是全面升级经营模式和客户营销的前提，更是未来占领市场的关键发力点。
本文即尝试在此背景下，对账户体系的发展历程进行了概述、梳理，然后介绍了账户体系设计思路、实践和建议，最后探讨和分析未来的发展方向。以期抛砖引玉，促进账户体系的进一步发展完善。如有不当、不周之处，还请多多指正。
1、此文适合人群：
银行业务咨询、架构师、技术leader、开发、产品经理、经历过存款相关项目的小伙伴，以及对账户体系建设比较有兴趣的小伙伴，如账户层次、账号与客户关系、账号与介质、虚拟账户管理（多级账簿、母实子虚或母虚子实）、账户树管理（多层级账户）、多层次账户路由，如何登记历史等。
2、此文解决问题：
对新人来说，学习完后对账户体系的基本框架有初步认识，有助于个人业务能力的沉淀和提升。因为核心系统的产品、交易、核算都是由账户体系决定的，所以不了解账户体系则无从了解核算等流向；对职场人来说，如果想吃透账户体系，在传统银行经营管理中最大化发挥账户体系的作用，或在金融科技创新中构建“客户为中心”的服务体系，或许本文能扩展思路。
3、其他声明：
此文的输出凝聚了我在实际工作过程中遇到无数坑和查阅了各种资料后而得出总结，内容沉淀后脱敏处理，文章会引用业内产品的流程作为讲解实例。文章中提到的知识点概念具有模式普适性和可实操复用性。对某个分支有兴趣的同学，自行索引我的其他文章深入学习。文章内容不代表公司观点，部分名词解释和内容来自网络与书籍，欢迎转发。
此文分为三部分：
一、账户体系发展历程及变革要求
二、账户体系建设的常见方案列举
三、构建统一生态账户体系的关键
一、 账户体系发展历程及变革要求
1.1 银行账户体系的发展历程
1994年10月9日，人民银行发布《银行账户管理办法》的通知（银发[1994] 255号）。规范了存款账户的分类（基本户/一般户/临时户/专用户）及用途和使用限制、开户与撤销条件、长期不动户的处理、申报要求等。这是我国银行账户体系的起点。（注：未对个人存款账户做出相关说明）
2000年3月20日，国务院令第285号发布《个人存款账户实名制规定》，以行政法规的形式明确了个人银行账户实名制，主要内容包括了代理他人开立存款账户、金融往来、及账户信息的保密责任等。
2003年4月10日，人民银行发布《人民币银行结算账户管理办法》（中国人民银行令[2003]第5号）。因原先的账户法规体系存在交叉和重叠之处，所以全面梳理了人民币银行结算账户的开立、使用、变更与撤销等规定。同时，将1994年颁布的《银行账户管理办法》废止。
2005年1月19日，人民银行发布了《人民币结算账户管理实施细则》的通知（银发[2005] 16号）。该发文是根据《人民币银行结算账户管理办法》制定的实施细则。（注：同年6月在全国推广运行人民币银行结算账户管理系统）
2006年11月14日，人民银行发布《金融机构大额交易和可疑交易报告管理办法》（中国人民银行令[2006]第2号。该发文对《中华人民共和国反洗钱法》中关于大额交易和可疑交易行为，做了详细的规定和分解。
2008年6月20日，人民银行下发《中国人民银行关于进一步落实个人人民币银行存款账户实名制的通知》（银发[2008] 191号），重新疏理并规范了新形势下个人银行账户的开立及使用规定，有效指导了银行的实名制落实工作。
2014年3月14日，人民银行下发《关于规范银行业金融机构开立个人人民币电子账户的通知(讨论稿)》，提出银行要规范开设个人人民币电子账户，推出强弱实名电子账户，实现直销银行远程开户。
2014年5月18日，人民银行发布《中国人民银行关于银行业金融机构远程开立人民币银行账户的指导意见 (征求意见稿)》，指导意见指出以柜台开户为主，远程开户为辅，及远程开立银行账户的业务范围。（注：同年，民生银行直销银行上线，创新性推出弱实名电子银行账户，用于投资理财业务）
2014年6月24日，人民银行出台《中国人民银行关于加强银行业金融机构人民币同业银行结算账户管理的通知》（银发[2014] 178号），对商业银行同业银行结算账户的开立、落实日常管理做出严格要求，并要求各银行建立同业银行结算账户专项管理制度，同时对存量同业银行结算账户进行清理核实。（注：非个人存款账户）
2015年11月13日，银监会下发《中国银监会关于银行业打击治理电信网络新型违法犯罪有关工作事项的通知》（银监发[2015] 48号），提出同一商业银行为同一客户开立借记卡原则上不得超过4张。（注：同年年底P2P平台跑路事件的爆发，为互联网金融行业敲响警钟，监管开始规范整治市场环境）
2015年12月25日，人民银行发布《中国人民银行关于改进个人银行账户加强账户管理的通知》（银发[2015] 392号），提出银行应建立银行账户分类管理机制，将个人银行账户种类划分为Ⅰ类银行账户、Ⅱ类银行账户和Ⅲ类银行账户。同时，规定了账户功能升级制度：对于Ⅱ类户，银行可按规定对存款人身份信息进行进一步核验后，将其转为Ⅰ类户。对于Ⅲ类户，银行可按规定对存款人身份信息进行进一步核验后，将其转为Ⅰ类户或Ⅱ类户。
2016年9月30日，人民银行下发《中国人民银行关于加强支付结算管理防范电信网络新型违法犯罪有关事项的通知》（银发[2016] 261号），提出自2016年12月1日起，同一个人在同一家银行（以法人为单位）只能开立一个Ⅰ类户，再新开户的，应当开立Ⅱ类户或Ⅲ类户；以及自助柜员机向非同名账户转账的，资金24小时后到账；支付账户转账要限制转账笔数；账户6个月内无活动将暂停使用；同一手机号对应同一身份证，对多人使用同一联系电话号码开立和使用账户的情况进行排查清理，联系相关当事人进行确认等条款。
2016年11月25日，人民银行发布《中国人民银行关于落实个人银行账户分类管理制度的通知》（银发[2016] 302号），详细规定了Ⅱ、Ⅲ类个人银行账户的使用限制、开户与撤销，并提出建立健全绑定账户信息验证机制。
2018年1月19日，人民银行下发了《关于改进个人银行账户分类管理有关事项的通知》（银发[2018] 16号），从开户、资金转入转出及限额等方面，都做了很多优化和改进。例如，同一银行法人为同一个人开立Ⅱ类户、Ⅲ类户的数量原则上分别不得超过5个。进一步明确了网络支付账户、个人银行账户的市场定位。
2019年3月19日，人民银行下发了《中国人民银行支付结算司关于加强个人二三类银行结算账户风险防范有关事项的通知》（银支付[2019] 55号），文件重点描述了银行互联网端系统中Ⅱ、Ⅲ类户的相关风险和用户异常行为等，要求强化账户业务监督管理。
2019年3月27日，人民银行下发了《中国人民银行关于进一步加强支付结算管理 防范电信网络新型违法犯罪有关事项的通知》（[2019] 85号）加强账户实名制管理、加强转账管理，加强对反欺诈反洗钱的打击
从已公开的监管文件脉络来看：我国银行账户体系是伴随银行业向互联网化发展而演进的，也是传统金融转型升级的必经之路。相信随着市场的不断变化，后续还会出台更为完善的监管明细，有效规范市场秩序。
1.2 个人账户体系监管再梳理
经过以上描述，我们不难发现，监管文件基本围绕着账户、反洗钱和防范电信诈骗三方面进行了严格规范。接下来，以这三方面的对个人存款账户进行总结和梳理。
（1）账户分类
参考文件：
《人民币银行结算账户管理办法》（[2003] 5号），《中国人民银行关于改进个人银行账户 加强账户管理的通知》（银发[2015] 392号），《中国人民银行关于落实个人银行账户分类管理制度的通知》（银发[2016] 302号），《关于改进个人银行账户分类管理有关事项的通知》（银发[2018] 16号），《中国人民银行支付结算司关于加强个人二三类银行结算账户风险防范有关事项的通知》（[2019] 55号）
（2）反洗钱
参考文件：
（3）防范电信诈骗
参考文件：
《中国银监会关于银行业打击治理电信网络新型违法犯罪有关工作事项的通知》（银监发[2015] 48号），《中国人民银行关于加强支付结算管理防范电信网络新型违法犯罪有关事项的通知》 （[2016] 261号），《中国人民银行关于进一步加强支付结算管理 防范电信网络新型违法犯罪有关事项的通知》（[2019] 85号）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f29a23fa38152206d514fcf9860113b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0acc348b5edd794f11c35212b1c3f93/" rel="bookmark">
			【笔记】Git常用指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建仓库 git init # 在当前目录下新建git仓库 git init xxx_repo # 新建一个目录并将其初始化成一个git仓库； 配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。
git config -list # 显示当前配置 git config --global --list # 显示全局配置 git config -e [--global] #编辑config文件 git config --global user.name "xxx_name" #重要，提交或clone代码时需要 git config --global uesr.email "xxx_email" 添加/移除文件 git add [file1] [file2] ... # 添加文件到暂存区(Untracked-&gt;Staged) git add . # 添加当前工作区目录下所有文件到暂存区 git add dir # 添加目录到暂存区 git add -p # 依次列出该工作区所有修改，选择性的添加到暂存区 git add -A # 提交所有修改 git add -f #强制添加文件到暂存区，避免使用 git rm --cache xxx_file # * -&gt; Untracked git rm xxx_file # 在所有“区”删除该文件 git mv src_file dst_file # 重命名并将这个重命名放入暂存区 提交代码到本地仓 git commit -m xxx_msg # 提交整个暂存区到本地仓库，并附带提交信息； git commit [file1] [file2] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0acc348b5edd794f11c35212b1c3f93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f723ae6d38c85c279beb4ece4f4ccbe7/" rel="bookmark">
			afl-cov实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fuzz upx 首先拉取upx代码并切换到3.94版本
git clone https://github.com/upx/upx.git cd upx git checkout v3.94 拉取依赖（在当前目录下运行）
git submodule update --init --recursive 上面这一步是为了拉取src/lzma-sdk/目录下的代码
vim src/Makefile # toolchain CC = /home/yan/fuzz/ijon/afl-gcc -fprofile-arcs -ftest-coverage(添加) CXX ?= /home/yan/fuzz/ijon/afl-g++ -fprofile-arcs -ftest-coverage（修改） 安装 UCL
参考https://blog.csdn.net/qq_33728095/article/details/110174556?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2aggregatepagefirst_rank_ecpm_v1~rank_v31_ecpm-4-110174556.pc_agg_new_rank&amp;utm_term=upx+%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85&amp;spm=1000.2123.3001.4430
链接：http://www.oberhumer.com/opensource/ucl/ ./configure CPPFLAGS="$CPPFLAGS -std=c90 -fPIC" make sudo make install 进入upx目录
export UPX_UCLDIR=/home/yan/fuzz/ucl-1.03 make all 注意是在upx文件夹而不是src
错误提示：warnings being treated as errors
解决方法：打开Makefile，将-Werror选项去掉，编译通过
编译完成之后就可以进行fuzz了
afl-cov的使用 afl-cov主要是为了查看覆盖率，并且需要编译支持。
参考原文：fuzz upx
./afl-cov/afl-cov -d fuzz_upx/upx_out/ --live --coverage-cmd="./upx/upx_2/src/upx.out AFL_FILE" --code-dir="./upx/upx_2/src/" -d afl-fuzz 的输出目录 --live 实施获取 --coverage-cmd 被fuzz文件与AFL_FILE 为生成的例子 --code-dir= 代码目录 先执行afl-cov，再执行afl，afl-cov将读取afl output/queue中的所有文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f723ae6d38c85c279beb4ece4f4ccbe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/071fd90562e1860f164202c61d61b862/" rel="bookmark">
			c&#43;&#43; 输入文件流ifstream用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 c++ 输入文件流`ifstream`用法详解输入流的继承关系：C++ 使用标准库类来处理面向流的输入和输出：成员函数Public member functions1. **`(constructor)`**2. **`ifstream::open`**3. **`ifstream:: is_open`**4. **`ifstream:: close`**5. **`ifstream:: rdbuf`**6. **`ifstream:: operator =`** Public member functions `inherited from istream`7. **`std::istream::operator&gt;&gt;`**8. **`istream::gcount`**9. **`istream::get`**10. **`istream::getline`**11. **`istream::ignore`**12. **`istream::peek`**13. **`istream::read`**14. **`istream::putback`**15. **`istream::unget`**16. **`istream::tellg`**17. **`istream::seekg`** Public member functions `inherited from ios`18. **`ios::good`**19. **`ios::operator!`**20. **`ios::operator bool`** c++ 输入文件流ifstream用法详解 输入流的继承关系： ios_base &lt;- ios &lt;- istream &lt;- ifstream C++ 使用标准库类来处理面向流的输入和输出： iostream 处理控制台 IOfstream 处理命名文件 IOstringstream 完成内存 string 的IO 每个IO 对象都维护一组条件状态 flags (eofbit, failbit and badbit)，用来指出此对象上是否可以进行 IO 操作。如果遇到错误—例如输入流遇到了文件末尾，则对象的状态变为是失效，所有的后续输入操作都不能执行，直到错误纠正。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/071fd90562e1860f164202c61d61b862/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8fe629dce7454bddebb2e325710abe4/" rel="bookmark">
			tensorRT踩坑日常之训练模型转ONNX转engine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tensorRT踩坑日常之训练模型转ONNX转engine tensorRT是用来干嘛的在这里就不多介绍了
在使用tensorRT提速之前需要先训练模型
在将训练好的模型转ONNX再转engine
一、将训练好的模型转ONNX这里就提供将torch转ONNX，其余的网上还是有很多教程的
import torch import torch.nn import onnx model = torch.load('best.pt') model.eval() input_names = ['input'] output_names = ['output'] x = torch.randn(1,3,32,32,requires_grad=True) torch.onnx.export(model, x, 'flame.onnx', input_names=input_names, output_names=output_names, verbose='True') 输出就行
二、将ONNX转engine
可以直接使用tensorrt自带的trtexec将onnx模型转engine：
进入tensorrt的安装目录下的bin文件，就能看到trtexec：输入
ubuntu下的trtexec
/usr/src/tensorrt/bin
trtexec -h 查看帮助命令
=== Model Options === --uff=&lt;file&gt; UFF model --onnx=&lt;file&gt; ONNX model --model=&lt;file&gt; Caffe model (default = no model, random weights used) --deploy=&lt;file&gt; Caffe prototxt file --output=&lt;name&gt;[,&lt;name&gt;]* Output names (it can be specified multiple times); at least one output is required for UFF and Caffe --uffInput=&lt;name&gt;,X,Y,Z Input blob name and its dimensions (X,Y,Z=C,H,W), it can be specified multiple times; at least one is required for UFF models --uffNHWC Set if inputs are in the NHWC layout instead of NCHW (use X,Y,Z=H,W,C order in --uffInput) === Build Options === --maxBatch Set max batch size and build an implicit batch engine (default = 1) --explicitBatch Use explicit batch sizes when building the engine (default = implicit) --minShapes=spec Build with dynamic shapes using a profile with the min shapes provided --optShapes=spec Build with dynamic shapes using a profile with the opt shapes provided --maxShapes=spec Build with dynamic shapes using a profile with the max shapes provided --minShapesCalib=spec Calibrate with dynamic shapes using a profile with the min shapes provided --optShapesCalib=spec Calibrate with dynamic shapes using a profile with the opt shapes provided --maxShapesCalib=spec Calibrate with dynamic shapes using a profile with the max shapes provided Note: All three of min, opt and max shapes must be supplied.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8fe629dce7454bddebb2e325710abe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e95aedb61f300f207d6671ebb3f66fb/" rel="bookmark">
			服务器代码运行的小tips
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在远程服务器跑代码时，网络不稳定笔记本断网，且不能自动连接，而服务器在短暂断网后可以自动链接，导致代码运行终止。针对这种情况，可以用screen指令。
几个常用的指令如下：
1）创建一个自己的screen，最好不要用数字，用字母
screen -S LXX ##LXX是名字 2）进去之后就是激活自己的环境啊，正常跑。然后退出这个screen用 ctrl+A当左下角有个条条闪的厉害，再＋D。
3）查看所有的screen
screen -ls 4）进入自己创建的screen，查看代码运行进度
screen -r LXX 嘿嘿，目前我就用到这几个，但是很好用哦~
其他的相关指令可以参照
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d5ccccade699d6ac8c475985165599/" rel="bookmark">
			MySQL时间字段TIMESTAMP、DATETIME（自动更新、毫秒存储）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 数据类型简介2. 方便的处理2.1 默认值与自动更新2.2 毫秒及更高精度 1. 数据类型简介 MySQL中关于日期和时间有DATE、TIME、DATETIME、TIMESTAMP这几种数据类型：
1️⃣DATE：储存日期，格式为YYYY-MM-DD，范围1000-01-01到9999-12-31；2️⃣TIME：储存时间，格式为hhh:mm:ss，范围-838:59:59 到838:59:59；3️⃣DATETIME：储存日期和时间，格式为YYYY-MM-DD hh:mm:ss，范围1000-01-01 00:00:00到9999-12-31 23:59:59；4️⃣TIMESTAMP：储存时间戳，格式与DATETIME相同，范围1970-01-01 00:00:01到2038-01-19 03:14:07； 赋值时通过上述格式的字符串赋值即可，还有一些如同NOW()之类的函数也可赋值，但本质可以理解为返回了格式化字符串后赋值的。
其中的TIME可以有缩写，但❌十分不建议❌这样做：
1112将被转化为00:11:12；11:12将被转化为11:12:00。 类似地，DATE也可以简写，参考官方文档📖2-Digit Years in Dates
对于后两者（DATETIME和TIMESTAMP）很类似，又有所不同：
1️⃣☀️首先能够轻松注意到TIMESTAMP的储存范围比DATETIME要小很多，那简单一想：
正经人谁还用TIMESTAMP啊❓
从官方介绍中了解到，TIMESTAMP在存储时会存成UTC时间，在取出时转换为服务器的所在时区的时间。因此能够提供时区自动变换的功能，不过看起来不是跨国大鳄🐊也不太用得上这功能……
UTC：协调世界时，又称世界统一时间。
2️⃣🌔在未指定默认值时，TIMESTAMP和DATETIME的默认值根据是否允许NULL值有区别：
// DATETIME默认允许NULL值，指定不允许NULL时默认值为0 CREATE TABLE t1 ( dt1 DATETIME ON UPDATE CURRENT_TIMESTAMP, -- default NULL dt2 DATETIME NOT NULL ON UPDATE CURRENT_TIMESTAMP -- default 0 ); // TIMESTAMP默认不允许NULL值，指定允许NULL时默认值为NULL CREATE TABLE t1 ( ts1 TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- default 0 ts2 TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP -- default NULL ); 💡建议：这种知识点🔖不建议去记，在声明字段时显式指出☝️即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3d5ccccade699d6ac8c475985165599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1c2951d76e17e429aa4620bf9be1ec/" rel="bookmark">
			访问url图片并上传oss图片显示不完整问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在之前通过链接上传图片的时候，都是先获取inputStream流，然后通过available()方法获取文件大小。但是通过这种方法获取到的文件大小是不准确的，因为这个时候文件还没有读取完全，所以获取到的文件大小是不完全的。
所以导致上传的文件只显示了一半不到。
解决方法：
在使用oss上传时需要传文件大小的参数,方法： objectMetadata.setContentLength(file.length())。
URL url = new URL(posturl); URLConnection uc = url.openConnection(); // 打开的连接读取的输入流。 InputStream in = uc.getInputStream(); String substring = posturl.substring(posturl.lastIndexOf(".")).toLowerCase(); String fileName = IdUtil.fastSimpleUUID() + substring; res = ossUtil.putObject(in, fileName, filedir, uc.getContentLengthLong()); in.close(); public String putObject(InputStream inputStream, String fileName, String filedir, Long fileLength) { try { uploadFileOSSWithLength(inputStream, fileName, filedir, fileLength); String str = getFileUrl(fileName, filedir); return str.trim(); } catch (Exception e) { throw new RuntimeException("上传失败！"); } } private String uploadFileOSSWithLength(InputStream instream, String fileName, String path, Long fileLength) { String ret = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee1c2951d76e17e429aa4620bf9be1ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a650c2313429c7196b998f12f5b1f8/" rel="bookmark">
			基于Linux的C&#43;&#43;轻量级web服务器/webserver/httpserver——httpconnect模块介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP连接处理详解 背景 服务器和核心功能是完成对HTTP请求报文的解析，并向客户端发出HTTP响应报文。在Httpconnection模块正是要完成上述的功能需求。
为了完成报文解析、资源定位、发送响应等功能需求，该项目一共是写了4个头文件，与此对应的就是4个模块：Httpconnection模块、Httprequest模块、Httpresponse模块以及Buffer缓冲区模块。四个模块之间的相互关系如下图所示
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wWaMy8LW-1650472188539)(…/images/img1.png)]
Httpconnection类成员变量介绍 Httpconnection是对HTTP连接的抽象，在模块中要定义一些变量保存socket通信客户端的信息：（建立socket连接由其他模块负责，这里只负责通信和关闭通信）一条socket连接就需要一个Httpconnection模块，所以我们使用m_fd唯一的标记它；并且使用m_isClose判断连接是否被关闭，便于调用closeConn关闭客户端连接。一个HTTP连接还需要读写数据，所以给每一个HTTP连接定义一个读缓冲区和一个写缓冲区。在解析请求和响应请求的时候，我们借助Httprequest和Httpresponse完成，所以也需要各种定义一个这两种变量。
private: int m_fd; struct sockaddr_in m_addr; // 获取IP和port bool isClose; int m_iovCnt; struct iovec m_iov[2]; // 用于分散写writev的结构体 Buffer m_readBuf; Buffer m_writeBuf; Httprequest m_request; Httpresponse m_response; 此外，还定义了三个static静态成员：isET, srcDir, userCount。类的静态成员不属于某一个类对象，是属于整个类的，所有的类对象都可以访问该静态成员。
isET布尔变量表征所有的Httpconnection对象是否在使用epoll的ET边缘触发模式。
srcDir定位资源的根路径
userCount是当前连接的数量。由于对该变量有多线程读取和写入，需要作线程保护。我们可以使用std::atomic对变量进行线程保护
public: static bool isET; static const char *srcDir; static std::atomic&lt;int&gt; userCount; Httpconnection任务流程介绍 成员变量的介绍到这里就结束了。下面对Httpconnection模块的执行流程作一个介绍：
完成工作任务的主要是3个函数：
ssize_t readBuffer(int *saveErrno); bool handleHTTPConn(); ssize_t writeBuffer(int *saveErrno); readBuffer函数从m_fd对应的socket中读取数据，由于在Buffer缓冲区中我们已经定义好了读取函数recvFd，这里只是简单的对该函数进行封装即可。读取到的HTTP请求报文会保存在之前定义的读取缓冲m_readBuf
handlerHTTPConn整个类执行任务的核心。在该函数中，我们将m_readBuf交由请求解析模块m_request进行报文解析，成功解析后，会调用报文响应模块m_response完成响应报文状态行和首部字段的填写、分散写结构体m_iov的装填等一系列操作。函数执行成功后，将会返回1。
writeBuffer函数是将数据发送到m_fd对应的socket中去。由于需要发送服务器上的文件资源，针对这种情况通常都是使用writev分散写函数将多块内存的数据一同发送到socket对端。当handlerHTTPConn函数执行成功后，m_iov结构体已经填充好了要发送的响应报文（状态行、首部字段、报文主体），此时调用writeBuffer函数就可以将响应报文发送给客户端。
以上便是Httpconnection模块的工作流程。当然，在执行任务之前，需要调用initHTTPConn函数对成员变量进行初始化。此外，还定义了一些外部接口函数，以供访问内部的成员变量。
Httpconnection类的实现：
#ifndef __HTTPCONNECT_H__ #define __HTTPCONNECT_H__ #include &lt;arpa/inet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05a650c2313429c7196b998f12f5b1f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c22f19fdec4ecef7e0894290515f4f/" rel="bookmark">
			python&#43;OpenCV笔记（三十九）：离散傅里叶变换（DFT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是傅里叶变换
二、代码编写：傅里叶变换与逆傅里叶变换
【一、OpenCV实现傅里叶变换】
【二、OpenCV实现逆傅里叶变换】
【三、Numpy实现傅里叶变换】
【四、Numpy实现逆傅里叶变换】
三、应用实践：低通滤波与高通滤波
一、低通滤波
二、高通滤波
一、什么是傅里叶变换 傅里叶原理表明：任何连续测量的时序或信号，都可以表示为不同频率的正弦波信号的无限叠加。也就是说，傅里叶变换是一种特殊的积分变换，它能将满足一定条件的某个函数表示成正弦基函数的线性组合或者积分。
不同的研究领域，傅里叶变换具有多种不同的变体形式，如连续傅里叶变换和离散傅里叶变换。
（看一张动态图，原作者：傅里叶分析之掐死教程（完整版）更新于2014.06.06 - 知乎） （动态图的开始部分很清晰的展现了：红色曲线可以由众多条（或者无数条）蓝色的正弦函数以及余弦函数叠加而成）
（再看一张老面孔） 在数字图像领域，我们一般使用的都是二维的灰度图像，所以这里从二维的傅里叶变换说起。
（1）首先，先看时域图像，他是我们经常见到与接触的一种函数，称它为 f(t)： 从大图中可以看到，这条线是由所有的正弦波叠加而成的总和，反过来说就是，所有的正弦波都是这条总和波的分量。其中，频率最低的排在最前面，越往后，频率越高（即上下跳动越活越），并且，每一条波的振幅都不同（因为波形的高度不同）。同时，我们也发现在所有的正弦波中，有很多分量是直线，那是因为时域图像中的 f(t) 并不需要某种特定频率的正弦波，所以表现为直线。
（2）接下来，我们从正弦波的侧面看过去，便是 f(t) 在频域的样子（终于到这一步了） 在频域上，自变量为正弦波分量的频率，因变量为振幅，他们两形成的函数 F(w),也就是频域图像。这时，一个时域——频域的映射就完成了。
（3）让我们在回顾一下文章开头的动图的最后一张： 由 时域上的红色图像 映射到了 频域上的蓝色图像，这便是傅里叶变换所做的事。
离散傅里叶变换在图像处理领域的应用：
对于数字图像这种离散的信号，频率大小表示信号变化的剧烈程度或者说是信号变化的快慢。 频率越大，变化越剧烈，频率越小，信号越平缓，对应到图像中，高频信号往往是图像中的边缘信号和噪声信号，而低频信号包含图像变化频繁的图像轮廓及背景等信号。
因此，我们可以做相应的锐化和模糊的处理：提出其中的高频分量做傅里叶逆变换得到的就是锐化的结果（高通滤波器）。 提出其中的低频分量做傅里叶逆变换得到的就是模糊的结果（低通滤波器）。
另外，需要特别注意的一点是：
截取频域图中的任何一个区域对应的都是原来的整张图的区域，而不是对应的局部 二、代码编写：傅里叶变换与逆傅里叶变换 【Numpy与OpenCV均可实现傅里叶变换与逆傅里叶变换】
【一、OpenCV实现傅里叶变换】 OpenCV API:dst = cv2.dft (src , flags) 参数：
src：输入图像，需要转换格式为np.float32，可以为实数矩阵或者复数矩阵flags：转换标志
（如DFT_COMPLEX_OUTPUT，对一维或二维实数数组正变换，输出一个同样尺寸的复数矩阵）
（DFT_REAL_OUTPUT，对一维或二维复数数组反变换，通常输出同样尺寸的复矩阵）返回结果：是双通道的，第一个的结果是虚数部分，第二个通道的结果是实数部分 其他函数：
np.fft.fftshift(dst)：将图像的低频部分移动到图像的中心 返回值 = cv2.magnitude(参数1， 参数2)——将复数结果转换为幅值
参数1：浮点型X坐标值，也就是实部
参数2：浮点型Y坐标值，也就是虚部
【代码编写】
import cv2 import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5c22f19fdec4ecef7e0894290515f4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66aca9e5f8a8b2c56e27bd5b3ef7f754/" rel="bookmark">
			Linux应用编程之空洞文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空洞文件（hole file）的描述： 使用 lseek 可以修改文件的当前读写位置偏移量，此函数不但可以改变位置偏移量，并且还允许文件偏移量超出文件长度，这是什么意思呢？譬如有一个 test_file ，该文件的大小是 4K （也就是 4096 个字节），可以通过 lseek 系统调用将该文件的读写偏移量移动到偏移文件头部 6000 个字节处。 接下来使用 write() 函数对文件进行写入操作，也就是说此时将是从偏移文件头部 6000 个字节处开始写 入数据，也就意味着 4096~6000 字节之间出现了一个空洞，因为这部分空间并没有写入任何数据，所以形成了空洞，这部分区域就被称为文件空洞，那么相应的该文件也被称为空洞文件。 文件空洞部分实际上并不会占用任何物理空间，直到在某个时刻对空洞部分进行写入数据时才会为它分配对应的空间，但是空洞文件形成时，逻辑上该文件的大小是包含了空洞部分的大小的，这点需要注意。 空洞文件（hole file）的作用： 空洞文件对多线程共同操作文件是及其有用的，有时候我们创建 一个很大的文件，如果单个线程从头开始依次构建该文件需要很长的时间，有一种思路就是将文件分为多段，然后使用多线程来操作，每个线程负责其中一段数据的写入。 这个有点像我们现实生活当中施工队修路 的感觉，比如说修建一条高速公路，单个施工队修筑会很慢，这个时候可以安排多个施工队，每一个施工队负责修建其中一段，最后将他们连接起来。 空洞文件（hole file）的实际应用场景：
⚫ 在使用迅雷下载文件时，还未下载完成，就发现该文件已经占据了全部文件大小的空间，这也是空洞文件；下载时如果没有空洞文件，多线程下载时文件就只能从一个地方写入，这就不能发挥多线程的作用了；如果有了空洞文件，可以从不同的地址同时写入，就达到了多线程的优势； ⚫ 在创建虚拟机时，你给虚拟机分配了 100G 的磁盘空间，但其实系统安装完成之后，开始也不过只用了 3 、 4G 的磁盘空间，如果一开始就把 100G 分配出去，资源是很大的浪费。 示例代码：
#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int main(void) { int fd; int ret; char buffer[1024]; int i; /* 打开文件 */ fd = open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66aca9e5f8a8b2c56e27bd5b3ef7f754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23bc916ee03679dbc83a4b8d05c50bd4/" rel="bookmark">
			lotus本地测试网2K环境多节点搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置环境变量 因为参数默认托管在国外，因此设置环境变量提速
export IPFS_GATEWAY=https://proof-parameters.s3.cn-south-1.jdcloud-oss.com/ipfs/ 安装lotus（Linux环境） 因为此处使用的是从源代码安装，因此先安装系统依赖，这里本机电脑使用的是Ubuntu20.04
sudo apt install mesa-opencl-icd ocl-icd-opencl-dev gcc git bzr jq pkg-config curl clang build-essential hwloc libhwloc-dev wget -y &amp;&amp; sudo apt upgrade -y 安装RustUp curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh 安装Go，我本地安装的是1.16.6版本的golang
wget -c https://golang.org/dl/go1.16.4.linux-amd64.tar.gz -O - | sudo tar -xz -C /usr/local 构建和安装lotus git clone https://github.com/filecoin-project/lotus.git cd lotus/ 选择最新代码以及使用主分支代码进行编译
git checkout v1.13.0 编译 我们使用的是测试网环境，因为要在2K环境中启动结点
make clean calibnet
make sudo install
这将把lotus,lotus-miner和lotus-worker 放入 /usr/local/bin 目录中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23bc916ee03679dbc83a4b8d05c50bd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a308fe073d102cc28ebc0c9ff35c8e5a/" rel="bookmark">
			(二层) VLAN 章节整体知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小记一篇，以便日后翻阅
如有问题欢迎积极评论指正
目录 前言Ⅰ. VLAN 的基本原理VLAN 标签（VLAN Tag）VLAN 数据帧VLAN 的实现 Ⅱ. VLAN 的划分方式Ⅲ. 端口类型Access 口Trunk 口Hybrid 口 Ⅳ . VLAN 的应用VLAN 的规则配置 VLAN1. 创建 VLAN2. 配置 VLAN ★Ⅴ . 实操案例案例一案例2 前言 以太网是一种基于CSMA / CD 的数据通信技术，其特征是共享通信介质.当主机数目较多时会导致安全隐患、广播泛滥、性能显著下降甚至造成网络不可用，这时出现了VLAN技术。
先明白一些概念：
端口（port）：在通信设备中，一般指二层口，该口用于隔绝广播域，基于MAC地址转发，但本身不能设置任何地址；
接口（interface）：在通信设备中，用于区别二层的端口，指的是三层口，该口可以配置IP地址，基于IP路由转发。
冲突域与广播域
“在传统的局域网中，几个至几十个交换机连接一个大的局域网，一个局域网中的主机台数可能达到上千台，那么由于交换机只能隔绝冲突域，一个端口是一个冲突域，而不能隔绝广播域，会导致局域网内的ARP广播占用大量带宽影响性能，甚至影响网络的正常使用。此外成百上千的计算机在同一个局域网中也会影响网络安全性。”(转自VLAN层次与特点概念性总结)
VLAN：Virtual Local Area Network 虚拟局域技术
通过在交换机上部署VLAN机制，可以将一个规模较大的广播域在逻辑上划分成若干不同的、规模较小的广播域。广播域：由于二层交换机总是对广播帧执行泛洪操作，结果让其他的计算机都会收到这个广播帧，所以把一个广播帧所能到达的整个范围称为二层广播域，俗称广播域（Broadcast Domain）。一个交换网络其实就是一个广播域。一个VLAN就是一个广播域。 Ⅰ. VLAN 的基本原理 VLAN 标签（VLAN Tag） 数据在交换机内部一切操作都必须要有VLAN标签报文中添加标识VLAN信息的字段使得交换机能够分辨不同VLAN的报文 VLAN 数据帧 原始以太网数据帧（无标记帧，Untagged帧）：标记帧 802.1Q Tag （Tagged帧）： 补充：802.1Q Tag帧格式
VLAN 的实现 交换机在收到PC端发来的数据后打上Tag标签再在链路上传递，待发送到与目标主机直连的交换机后，由交换机再脱掉Tag标签把数据帧传送给相应主机。对于VLAN隔离只发生在交换机上，对于用户是不知道的 Ⅱ. VLAN 的划分方式 基于端口的划分： 把一个接口打上标签，不管下面有多少台主机，只需要从端口收上来的数据，都会打上相应标签。缺点：端口发生变化，VLAN标签也会变。 基于MAC地址的划分： (MAC1，MAC3)，(MAC2，MAC4)，根据数据帧的源MAC地址来划分VLAN。 基于IP子网的划分： 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a308fe073d102cc28ebc0c9ff35c8e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446d2c0d7ec51dbb5f7661f050461e66/" rel="bookmark">
			esp32学习笔记——UART
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、UART主要介绍二、使用步骤及接口函数介绍1.设置通讯参数- 设置波特率、数据位、停止位等2、设置通信引脚- 分配用于连接到设备的引脚。3、驱动程序安装- 为 UART 驱动程序分配 ESP32 的资源。4、运行 UART 通信- 发送/接收数据。5、使用中断- 触发特定通信事件的中断。6、删除驱动程序- 如果不再需要 UART 通信，则释放分配的资源 总结 前言 提示：这里可以添加本文要记录的大概内容：
嵌入式应用通常要求一个简单的并且占用系统资源少的方法来传输数据。通用异步收发传输器 (UART) 即可以满足这些要求，它能够灵活地与外部设备进行全双工数据交换。
通用异步接收器/发送器 (UART) 是一种硬件功能，它使用广泛采用的异步串行通信接口（例如 RS232、RS422、RS485）来处理通信（即时序要求和数据帧）。
ESP32 芯片具有三个 UART 控制器（UART0、UART1 和 UART2），每个控制器都具有一组相同的寄存器，以简化编程并提高灵活性。每个 UART 控制器可独立配置波特率、数据位长度、位顺序、停止位数量、奇偶校验位等参数。
一、UART主要介绍 UART 是一种以字符为导向的通用数据链，可以实现设备间的通信。异步传输的意思是不需要在发送数据上添加时钟信息。这也要求发送端和接收端的速率、停止位、奇偶校验位等都要相同，通信才能成功。
一个典型的 UART 帧开始于一个起始位，紧接着是有效数据，然后是奇偶校验位（可有可无），最后是停止位。
ESP32 上的 UART 控制器支持多种字符长度和停止位。另外，控制器还支持软硬件流控和 DMA，可以实现无缝高速的数据传输。开发者可以使用多个 UART 端口，同时又能保证很少的软件开销。
主要特性：
• 可编程收发波特率
• 3 个 UART 的发送 FIFO 以及接收 FIFO 共享 1024 × 8-bit RAM
• 全双工异步通信
• 支持输入信号波特率自检功能
• 支持 5/6/7/8 位数据长度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/446d2c0d7ec51dbb5f7661f050461e66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a45039763eea53e3cdbbc6a1c45a30f1/" rel="bookmark">
			Java出现@Autowired注入bean产生循环依赖part of a circular reference解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java出现@Autowired注入bean产生循环依赖part of a circular reference解决方案 问题背景解决方案Lyric：爱从中穿越 问题背景 我有两个类相互注入了对方的bean，产生了bean的循环依赖
Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2022-03-25 09:09:44.889 ERROR [main] o.s.b.SpringApplication.reportFailure(SpringApplication.java:837): Application run failed org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'computeController': Unsatisfied dependency expressed through field 'computeService'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'computeService': Bean with name 'computeService' has been injected into other beans [flowService] in its raw version as part of a circular reference, but has eventually been wrapped.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a45039763eea53e3cdbbc6a1c45a30f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce221a97c4c0676d744a9ee4f8233924/" rel="bookmark">
			达梦数据库主备集群备库异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主备集群备库状态异常
登录备库首先发现数据目录的磁盘空间已经用完，需要清理出空间。
查看日志的相关报错信息，主库发送归档日志到备库回复失败
登录dmonitor 查看集群状态。，备库状态为invalid。日志号相差甚大，只能用异构回复备库。
解决办法登录主库，执行一下备份命令；backup database full backupset ‘/opt/bak/fullbak’;
由于该盘是主备集群的共享盘，不需要另外拷贝到备库，备库也行查到该备份数据。
如果需要远程拷贝数据的话可以使用命令，scp -R /opt/bak/fullbak dmdba@ip:/路径即可
备库
先停掉守护进程：
/etc/init.d/DmWatcherServicedw stop
在停掉服务
/etc/init.d/DmServicedw stop
进入到安装目录下运行drman
RMAN&gt; restore database '/dm/dmdbms/data/dw/dm.ini' from backupset '/opt/bak/fullbak'
RMAN&gt; recover database '/dm/dmdbms/data/dw/dm.ini' from backupset '/opt/bak/fullbak'
恢复完成之后
启动备库到mount，在修复：
disql SYSDBA/SYSDBA
SQL&gt; sp_set_oguid(453331)；
SQL&gt; alter database standby
启动守护进程
/etc/init.d/DmWatcherServicedw start
在查看监视器正常：
状态正常日志号正在恢复
达梦技术社区：https://eco.dameng.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4299e731b9a965d99fa4ec6341ecce/" rel="bookmark">
			自定义FragmentNavigator解决Navigation重复创建的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习用Navigation管理Fragment时,我们会发现在切换Fragment的时候并不会像ViewPager一样复用Fragment而是会创建新的Fragment,而这样的后果就是每次切还都会重新请求数据,这样一是用户体验会不好,二是加重了服务器的负担。所以需要想办法搞一搞o(╥﹏╥)o。。。
在查看源码后我们得知，之所以会重复创建Fragment是因为在FragmentNavigator中并没有对Fragment做复用，而是在切换时直接移除了前一个Fragment(源代码如下):
@Nullable @Override public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) { if (mFragmentManager.isStateSaved()) { Log.i(TAG, "Ignoring navigate() call: FragmentManager has already" + " saved its state"); return null; } String className = destination.getClassName(); if (className.charAt(0) == '.') { className = mContext.getPackageName() + className; } final Fragment frag = instantiateFragment(mContext, mFragmentManager, className, args); frag.setArguments(args); final FragmentTransaction ft = mFragmentManager.beginTransaction(); int enterAnim = navOptions !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d4299e731b9a965d99fa4ec6341ecce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef708f63bb34a5677d6dd7bd9f58102/" rel="bookmark">
			python 提示‘grep‘ 不是内部或外部命令，也不是可运行的程序或批处理文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改grep为findstr + 关键词
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b4be9732499290961a4c0b2204eb36/" rel="bookmark">
			nmap扫描渗透测试(详细解析)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nmap简介：
Nmap，也就是Network Mapper，最早是Linux下的网络扫描和嗅探工具包。
功能:
其基本功能有三个，一是探测一组主机是否在线；其次是扫描 主机端口，嗅探所提供的网络服务；还可以推断主机所用的操作系统 ,Nmap可用于扫描仅有两个节点的LAN，直至500个节点以上的网络。Nmap 还允许用户定制扫描技巧。通常，一个简单的使用ICMP协议的ping操作可以满足一般需求；也可以深入探测UDP或者TCP端口，直至主机所 使用的操作系统；还可以将所有探测结果记录到各种格式的日志中， 供进一步分析操作。
nmap -P0 x.x.x.x 对服务器场景Linux不ping主机进行扫描
nmap -n -sU -p53 111 x.x.x.x 对靶机场景UDP端口53,111进行扫描
nmap -sX 进行圣诞树（Xmas Tree）扫描
nmap -sW 172.16.1.20 进行滑动窗口扫描
nmap --script vnc-info x.x.x.x 对服务器场景Linux进行VNC服务扫描渗透测试
nmap --script smb-os-discovery 对服务器场景Linux上运行的Samba版本进行扫描
nmap -A -T4 x.x.x.x
-sT TCP connect()扫描，这种方式会在目标主机的日志中记录大批连接请求和错误信息。
-sS 半开扫描，很少有系统能把它记入系统日志。不过，需要Root权限。
-sF -sN 秘密FIN数据包扫描、Xmas Tree、Null扫描模式
-sP ping扫描，Nmap在扫描端口时，默认都会使用ping扫描，只有主机存活，Nmap才会继续扫描。
-sU UDP扫描，但UDP扫描是不可靠的
-sA 这项高级的扫描方法通常用来穿过防火墙的规则集
-sV 探测端口服务版本
-Pn 扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描
-v 显示扫描过程，推荐使用
-h 帮助选项，是最清楚的帮助文档
-p 指定端口，如“1-65535、1433、135、22、80”等
-O 启用远程操作系统检测，存在误报
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b4be9732499290961a4c0b2204eb36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d9654031c822d9960e55372f598524/" rel="bookmark">
			【大数据导论】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章 第四章 (单选题)以下哪项不属于大数据在城市管理中的应用:( )
• A. 智能交通
• B. 环保监测
• C. 城市规划
• D. 比赛预测
我的答案: D正确答案: D
10分(单选题)下面关于推荐系统的描述错误的是:( )
• A. 推荐系统是自动联系用户和物品的一种工具
• B. 和搜索引擎相比,推荐系统通过研究用户的兴趣偏好,进行个性化计算
• C. 推荐系统可发现用户的兴趣点,帮助用户从海量信息中去发掘自己潜在的需求
• D. 推荐系统是一种只能通过专家进行人工推荐的系统
我的答案: D正确答案: D
10分(单选题)以下哪项不属于大数据在零售领域的应用:( )
• A. 大数据征信
• B. 发现关联购物行为
• C. 客户群体划分
• D. 供应链管理
我的答案: A正确答案: A
10分(单选题)以下推荐方法中,哪一个是基于内容的推荐:( )
• A. 由资深的专业人士来进行物品的筛选和推荐
• B. 基于统计信息进行推荐
• C. 通过机器学习的方法去描述内容的特征,并基于内容的特征来发现与之相似的内容
• D. 对多种推荐算法进行有机组合,然后给出推荐结果
我的答案: C正确答案: C
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81d9654031c822d9960e55372f598524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af741672e16e7c977f7be7600348455/" rel="bookmark">
			C# WinForm 运行久了就内存不足
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载地址:https://www.debugease.com/csharp/4441632.html
1、WinForm，主窗体-子窗体模式
2、关闭子窗体，使用Hide()，打开子窗体，使用Show()
3、软件就是ERP、进销存，支持图片，Socket上传下载
4、表格数据多大概这些，然后，软件运行久了，就达到几百M，然后用着用着就突然弹出内存不足，好恐怖，请问解决思想好，谢谢。
===============================================================================
解决方案 »
32位程序，最大内存 3.2 G 左右。
窗体 尽量不要 Hide() 、Visible —— 能关就关，最好能调用 窗体的 Dispose() 函数（释放组件、释放数据都彻底一些）
打开任务管理器：工具栏&gt;选择列&gt; 勾选 “用户对象”、“GDI对象”、“句柄数”—— 这三列 都不允许超过 10000 （超过程序直接崩溃）
主要是我用Hide()，那再次打开窗口的话，直接就Show出来，不会New一个新对象。这样挺好。
仅从你的描述，看不出问题。你的所谓 hide()、show() 并不是别人口中所说的“关闭窗体、打开窗体”，而纯粹是隐藏、显示的意思，所以这不会出现什么问题。真正的内存溢出是需要测试的。但是看起来、感觉到你的开发技术本身就达不到测试驱动开发的程度，这就很难说深入技术的内容。总之招聘专业开发人员进行开发和测试，测试几万遍之后才敢上线，这是产品思路。
不管别人如何给你说什么看代码，注意回收资源等等。。你都不要相信。。因为Winform确实不适合做大一点的商业软件开发。。不然呢我也认为Winform确实是很方便做桌面的。。为什么那些大些商业软件不选择Winform呢？如photoshop, CorelDraw, UG,PRO/E,AutoCad真的方便功能强大这些软件早就用Winform改写了，你说是不是呢？
你就把WinForm当一个玩具和学习编程的入门工具吧。。就如微软当年的VB，也许当年的VB都要比Winform好很多
某一个窗口、自定义控件有没有内存泄漏问题，这个是要通过写程序来测试的。测试出bug之后才可能调试，不可能靠用鼠标随便“点点点”就能开始调试出来bug，所以专业的开发要以测试驱动开发，而不是随便拼凑界面。那么这就在开发技术上存在着你完全没有学过的技术过程，当你提不出问题时也就不会免费给你回答，所以这就不太方便讨论了。
正常的Winform写的服务跑半个月都没问题，.net的GC 是很高效的。
肯定是你有些资源占用没释放，using{} 了解一下
上WPF
使用资源的方式不能太粗放
1。凡涉及非托管资源，使用完后一定要有释放操作
2。重点关注循环调用的代码
3。关注异常处理环节： 很多情况下，泄漏是由于异常处理跳过了回收处理逻辑
4。借助第三方工具，比如Process Explorer，确定句柄是否有泄漏
hide()只是隐藏，关闭是close
在内存占用最高的时候，拉一个进程dump，
简单的用任务管理器就可以，然后用windbg分析一下主要的内存占用是什么内容
纯粹的 hide和show，应该不会造成内存泄漏。
主要考虑有什么资源没有释放，这个问题就大的去了。
因为光从你的描述，是很难找到winform本身的毛病的。
其实还是代码上的问题。
多检查检查代码中 new 的对象最终有么有释放掉，只有新建没有释放内存必然溢出。
是否有 event handler 忘了remove？推荐使用 Ants Memory Profiler 内存检测工具。
Winform主要是 new 对象要用完就释放掉，不然一直占有内存，还有hide少用，这是个隐藏窗口，程序在运行窗口看不见。但窗口在运行，还是占用内存的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5af741672e16e7c977f7be7600348455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1833fa43c0740fb1071f903e9b070c96/" rel="bookmark">
			类中的泛型以及泛型类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章将介绍TypeScript中类的泛型以及泛型类型的相关知识。
类中的泛型 定义类泛型，构造函数接收泛型数组，在创建类实例时指定具体类型，并传递指定类型数组。
class DataManager&lt;T&gt; { // 构造函数传递泛型数组 constructor(private params: T[]) { } getItem(index: number): T { return this.params[index] } } // 传递泛型代表的类型数组 const data = new DataManager&lt;number&gt;([1, 3, 4]) console.log(data.getItem(0)) console.log(data.getItem(1)) console.log(data.getItem(2)) 泛型类型 使用interface定义一个类，并将该类指定为类泛型的类型（extends），在创建实例时，需要传递泛型类型中包含的属性值。
interface Item { name:string } class DataManager&lt;T extends Item&gt; { constructor(private params: T[]) { } getItem(index: number): string { return this.params[index].name } } // 传递的对象必须包含Item类包含的属性 const data = new DataManager&lt;Item&gt;([ { name:'jake' }, { name:'smith' } ]) console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1833fa43c0740fb1071f903e9b070c96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd78dc5734e9b6c7e55cbc4177de7f1/" rel="bookmark">
			Altium designer除了GND以外的Nets自动布线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本思路：将除GND以外的nets放到一个net class中，再对那个net class进行自动布线。
具体操作：
1. 点击Design - Classes;
2. 鼠标移至Net Classes, 右击 - Add class，将新的class改名为No GND（随便取，意思懂就行）；
3. 在右边选择GND， 再点击中间向左的箭头，将GND移至左边Non-members栏下。
效果：
然后点击OK。
4. 选择Route - Auto Route - Net Classes,
选中No GND，点击OK，然后除GND以外就自动布线了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05eb9977cb3b33944144ad4fc093dc05/" rel="bookmark">
			[OpenGL] VAO、VBO、EBO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、BO（Buffer Object，缓冲对象） 缓冲对象是OpenGL管理的一段内存，为了与我们CPU的内存区分开，一般称OpenGL管理的内存为：显存。
显存，也就是显卡里的内存。显卡访问显存比较快，而Buffer Object，就是由OpenGL维护的一块显存区域。比如说在一块显存为2G的显卡里，分配了128K大小的内存区域给OpenGL使用，这个128K大小的内存区域，就叫一个Buffer Object。
由于显卡访问显存，比访问内存（CPU里的内存区域）要快很多。而且显卡做运算，一般都是访问显存的数据，然后运算得到结果，并把结果也都保存在显存中。所以一般，需要先把数据，从内存传输到显存中去。
显卡里申请的这片显存区域，存放顶点数据，就叫VBO，存放图像数据，就叫PBO，根据它存放的数据的不同，有不同的叫法。
二、VBO（Vertex Buffer Object，顶点缓冲对象） 顶点数据输入 在开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。这些数据一开始存在C++语言创建的CPU的内存中，比如指定三个顶点的坐标，存在float数组内。
float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f }; 而后需要把这个顶点数据作为输入发送给OpenGL的图形渲染管线的第一个阶段：顶点着色器。顶点着色器会在GPU上创建显存用于储存这些顶点数据，同时我们还需要告诉OpenGL如何解释这些显存（比如告诉OpenGL，顶点数据前三个是物体的三维坐标，后三个是顶点法线，再后两个是纹理坐标）。
顶点缓冲对象（VBO）的作用就是管理这个在GPU上创建的显存。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器访问顶点是个非常快的过程的。
首先使用glGenBuffers函数和一个unsigned int变量生成一个VBO对象（顶点缓冲对象）： unsigned int VBO; glGenBuffers(1, &amp;VBO); void glGenBuffers(GLsizei n,GLuint * buffers); 个人理解这个函数的解释如下：
将n个当前未使用的缓冲对象名称（也就是ID），保存到buffers所指的内存区域中。这n个缓冲对象ID不一定是连续的整型数据（比如可能是1，5，8，而不一定是1，2，3，它们之间没有连续关系）
当然也可以声明一个unsigned int 数组，那么创建的n个缓冲对象的ID会依次保存在数组里。
unsigned int VBO[3]; glGenBuffers(3,VBO); 也就是说，这时候VBO内会是一个从未被使用过的缓冲对象的ID，类似于起名字，起了一个全人类都没用过的名字，自然意味着独一无二。
我的理解中，glGenBuffers函数起了一个名字，这个名字应该对应了GPU内的显存的地址，VBO内存储的那个名字（ID），可能就是那片显存的起始地址。也就是说，VBO（unsigned int 变量）成了一个将指向GPU内开辟的一块内存空间的指针。我认为此时还未指向。
然后使用glBindBuffer函数给这个生成的顶点缓冲对象绑定一个缓冲类型 glBindBuffer(GL_ARRAY_BUFFER, VBO); void glBindBuffer(GLenum target,GLuint buffer); target: 缓冲对象的类型，GL_ARRAY_BUFFER：数组缓冲区，存储颜色、位置、纹理坐标等顶点属性，或者其它自定义属性。
buffer: 要绑定的缓冲对象的名称（ID）, 即我们在glGenBuffers函数里生成的ID。
glBindBuffer函数完成了三项工作：
1、如果是第一次绑定buffer，且buffer是一个非0的unsigned int。那么将创建一个与该名称相对应的新缓冲对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05eb9977cb3b33944144ad4fc093dc05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d7f4b893f48cb520f48a4cfe03b23c/" rel="bookmark">
			7款优秀Vim插件帮你打造完美IDE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自公众号“夕小瑶的卖萌屋”，专业带逛互联网算法圈的神操作
-----》我是传送门
关注后，回复以下口令：
回复【789】 ：领取深度学习全栈手册（含NLP、CV海量综述、必刷论文解读）
回复【入群】：加入卖萌屋深度学习/NLP/CV/搜广推等方向的技术交流与内推社群（大V、顶会审稿人云集）
回复【0511】：领取算法岗面试手册（刷offer神器）
回复【0424】：领取刷论文神器（挖掘每日、每月必刷重磅论文）
集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，不管是Java、C还是Python，使用IDE编程可以帮你检查语法、自动补全、后台编译等，写代码就变得容易许多。另外，如果经常在服务器上工作的小伙伴一定知道Vim在进行文本编辑的时候是多么的方便。那么当vim的高效编辑性和IDE辅助编程性相融合，岂不是天下无敌？
下面介绍7款常用插件，帮你打造高可用性的VIM-IDEヾ(◍°∇°◍)ﾉﾞ
Vim-plug 既然是要安装插件，自然是少不了插件管理工具。当没有插件管理器时，Vim 用户必须手动下载 tarball 包形式的插件，并将它们解压到 ~/.vim 目录中。在少量插件的时候可以。但当他们安装更多的插件时，就会变得一团糟。所有插件文件分散在单个目录中，用户无法找到哪个文件属于哪个插件。此外，他们无法找到他们应该删除哪个文件来卸载插件。这时 Vim 插件管理器就可以派上用场。插件管理器将安装插件的文件保存在单独的目录中，因此管理所有插件变得非常容易。
Vim-plug 是一个自由、开源、速度非常快的、极简的 vim 插件管理器。它可以并行地安装或更新插件。你还可以回滚更新。它创建shallow clone最小化磁盘空间使用和下载时间。它支持按需加载插件以加快启动时间。其他值得注意的特性是支持分支/标签/提交、post-update 钩子、支持外部管理的插件等[1]。
1.安装 安装和使用起来非常容易。你只需打开终端并运行以下命令：
$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 2.配置 要安装插件，你必须如下所示首先在 Vim 配置文件中声明它们。一般 Vim 的配置文件是 ~/.vimrc。请记住，当你在配置文件中声明插件时，列表应该以 call plug#begin(PLUGIN_DIRECTORY) 开始，并以 plug#end() 结束。
例如，我们安装 “lightline.vim” 插件。为此，请在 ~/.vimrc 的顶部添加以下行
call plug#begin('~/.vim/plugged') Plug 'itchyny/lightline.vim'call plug#end() 3.使用 $ vim #打开vim :PlugStatus #查看插件状态 :PlugInstall #安装之前在配置文件中声明的插件 安装完的状态如下所示
还有一些常用操作如下：
:PlugUpdate #更新插件 :PlugDiff #查看插件的变化状态，简单地回滚有问题的插件。 :PlugClean #删除插件 更多详细细节参考: https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d7f4b893f48cb520f48a4cfe03b23c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/652e2f1b24d00306ae3ee43e3fd63175/" rel="bookmark">
			文本匹配（语义相似度）综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自公众号“夕小瑶的卖萌屋”，专业带逛互联网算法圈的神操作
-----》我是传送门
关注后，回复以下口令：
回复【789】 ：领取深度学习全栈手册（含NLP、CV海量综述、必刷论文解读）
回复【入群】：加入卖萌屋深度学习/NLP/CV/搜广推等方向的技术交流与内推社群（大V、顶会审稿人云集）
回复【0511】：领取算法岗面试手册（刷offer神器）
回复【0424】：领取刷论文神器（挖掘每日、每月必刷重磅论文）
目录
打卡的baseline模型
打卡的任务场景和数据集
一、相似度计算&amp;复述识别（textual similarity¶phrase identification）
二、问答匹配（answer selection）
三、对话匹配（response selection）
四、自然语言推理/文本蕴含识别（Natural Language Inference/Textual Entailment）
五、信息检索中的匹配
六、机器阅读理解问题
打卡的Siamese结构（基于表示）
打卡的花式attention结构（基于交互）
打卡的学习方法
打卡的开源工具
文本匹配是一个很宽泛的概念，只要目的是研究两段文本之间的关系，基本都可以把这个问题看作是文本匹配问题。由于在不同的场景下对”匹配“的定义可能非常不同，因此文本匹配并不是一个完整独立的研究方向。不过有相当多的NLP任务可以建模成文本匹配问题，当它们建模成文本匹配问题时，当然会发现模型结构、训练方法等是高度高度相似的，却又有着微妙的不同。所以这个问题虽然跑个baseline简单，但是把具体的匹配问题中做好却并不容易（尤其是在有BERT之前）。
下面就来具体说说可以打卡的内容。
PS：关注「夕小瑶的卖萌屋」订阅号后台回复「文本匹配」可领取小夕打包好的论文大礼包噢～（包括正文中的papers）
打卡的baseline模型 无论具体的匹配问题是什么，有一些很好实现的baseline是可以不管三七二十一的直接跑一下的。
我自己最喜欢用的baseline是SiameseCNN这种结构的模型，毕竟从头手撸一遍非常快的，跑的又很快，效果又不错，训练又比较稳定，受超参数的影响相对较小。
模型大体结构如图所示，这里一般没必要实现的太花哨，一般就用一层CNN来分别encoding一下需要匹配的textA和textB，然后max pooling一下或再concat一个mean pooling得到两个文本的向量表示vecA和vecB（上图中的u和v）。
这之后可以直接套用一些公式如cosine距离、L1距离、欧式距离等得到两个文本的相似度，不过我们做文本匹配并不一定是希望判断这两个文本是否相似，除了相似关系外，还可以有问答关系、对话回复关系、文本蕴含关系等，因此更通用的做法是基于u和v构建用于建模两者匹配关系的特征向量，然后用额外的模型（比如MLP）来学习通用的文本关系函数映射。
这个特征向量可以像上图一样包括vec1, vec, |vec1-vec2|, vec1*vec2，也可以包括一些更加fancy的features，比如小夕常加的max(vec1, vec2)^2等，在一些匹配场景下有奇效。当然啦，更加靠谱的还是根据实际匹配场景的(bad)case来精心构造features。
如果对LSTM有执念，完全可以用lstm替代cnn来当sentence encoder，也就是使用SiameseLSTM结构，同样这里的encoder可以搭配各种预训练模型强化一下文本的向量表示。
燃鹅，其实有了BERT之后，我就更喜欢拿BERT来当baseline了╮(￣▽￣"")╭，毕竟连代码都不用写了，更方便（经常baseline跑了一下发现问题解决了）。
打卡的任务场景和数据集 一、相似度计算&amp;复述识别（textual similarity&amp;paraphrase identification） 这个可以说是文本匹配最典型最经典的场景了，也就是判断两段文本是不是表达了同样的语义，即是否构成复述（paraphrase）关系。有的数据集是给出相似度等级，等级越高越相似（这种更合理一些），有的是直接给出0/1匹配标签。这一类场景一般建模成分类问题。
代表性数据集：
_SemEval STS Task：_从2012年开始每年都举办的经典NLP比赛。这个评测将两段文本的相似度程度表示为0.0~5.0，越靠近0.0表示这两段文本越不相关，越靠近5.0表示越相似。使用皮尔逊相关系数（Pearson Correlation）来作为评测指标。链接[2]
_Quora Question Pairs (QQP)：_这个数据集是Quora发布的。相比STS，这个数据集规模明显大，包含400K个question-question pairs，标签为0/1，代表两个问句的意思是否相同。既然建模成了分类任务，自然可以使用准确率acc和f1这种常用的分类评价指标啦。（知乎什么时候release一个HuQP数据集(￣∇￣)）链接[3]
_MSRP/MRPC：_这是一个更标准的复述识别数据集。在QQP数据集中文本都是来自用户提问的问题，而MRPC里的句子则是来源于新闻语料。不过MRPC规模则要小得多，只有5800个样本（毕竟是2005年release的数据集，而且人工标注，所以可以理解╮(￣▽￣"")╭）。跟QQP一样，MRPC一般也用acc或f1这种分类指标评估。链接[4]
_PPDB：_这个paraphrase数据集是通过一种ranking方法来远程监督[]做出来的，所以规模比较大。文本粒度包含lexical level（单词对）、phrase level（短语对）和syntactic level（带句法分析标签）。而且不仅包含英文语料，还有法语、德语、西班牙语等15种语言（为什么没有中文！）。语料库规模从S号、M号一直到XXXL号让用户选择性下载也是很搞笑了，其中短语级就有7000多万，句子级则有2亿多。由于语料规模太大，标注质量还可以，因此甚至可以拿来训练词向量[5]。链接[6]
二、问答匹配（answer selection） 问答匹配问题虽然可以跟复述识别一样强行建模成分类问题，但是实际场景往往是从若干候选中找出正确答案，而且相关的数据集也往往通过一个匹配正例+若干负例的方式构建，因此往往建模成ranking问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/652e2f1b24d00306ae3ee43e3fd63175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b22c87359afef7f45177ef639a969d/" rel="bookmark">
			NLP数据增强方法总结：EDA、BT、MixMatch、UDA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自公众号“夕小瑶的卖萌屋”，专业带逛互联网算法圈的神操作
-----》我是传送门
关注后，回复以下口令：
回复【789】 ：领取深度学习全栈手册（含NLP、CV海量综述、必刷论文解读）
回复【入群】：加入卖萌屋深度学习/NLP/CV/搜广推等方向的技术交流与内推社群（大V、顶会审稿人云集）
回复【0511】：领取算法岗面试手册（刷offer神器）
回复【0424】：领取刷论文神器（挖掘每日、每月必刷重磅论文）
1. 数据增强的背景和应用场景 随着AI技术的逐步发展，更好的神经网络模型对数据规模的要求也逐步提升。而在分类任务中，若不同类别数据量相差很大，模型则会出现过拟合现象，严重影响预测的正确性。
从广义上来讲，有监督模型的效果相对半监督或无监督学习都是领先的。但是有监督模型需要获取大量的标注数据，当数据需求达到十万、百万甚至更多时，人工标注数据昂贵的代价已经让很多人望而却步。
如何利用有限的标注数据，获取到更多的训练数据，减少网络中的过拟合现象，训练出泛化能力更强的模型？数据增强无疑是一种强有力的解决方法。
数据增强起初在计算机视觉领域应用较多，主要是运用各种技术生成新的训练样本，可以通过对图像的平移、旋转、压缩、调整色彩等方式创造新的数据。虽然，‘新’的样本在一定程度上改变了外观，但是样本的标签保持不变。且NLP中的数据是离散的，这导致我们无法对输入数据进行直接简单地转换，换掉一个词就有可能改变整个句子的含义。因此本文将重点介绍文本数据增强的方法和技术，以快速补充文本数据。
2 传统文本数据增强的技术 现有NLP的Data Augmentation大致有两条思路，一个是加噪，另一个是回译，均为有监督方法。加噪即为在原数据的基础上通过替换词、删除词等方式创造和原数据相类似的新数据。回译则是将原有数据翻译为其他语言再翻译回原语言，由于语言逻辑顺序等的不同，回译的方法也往往能够得到和原数据差别较大的新数据。
Easy Data Augmentation for Text Classification Tasks （EDA）提出并验证了几种加噪的 text augmentation 技巧，分别是同义词替换（SR: Synonyms Replace）、随机插入(RI: Randomly Insert)、随机交换(RS: Randomly Swap)、随机删除(RD: Randomly Delete)，下面进行简单的介绍：
2.1 EDA (1) 同义词替换（SR: Synonyms Replace）：不考虑stopwords，在句子中随机抽取n个词，然后从同义词词典中随机抽取同义词，并进行替换。
Eg: “我非常喜欢这部电影” —&gt; “我非常喜欢这个影片”，句子仍具有相同的含义，很有可能具有相同的标签。
(2) 随机插入(RI: Randomly Insert)：不考虑stopwords，随机抽取一个词，然后在该词的同义词集合中随机选择一个，插入原句子中的随机位置。该过程可以重复n次。
Eg : “我非常喜欢这部电影” —&gt; “爱我非常喜欢这部影片”。
(3) 随机交换(RS: Randomly Swap)：句子中，随机选择两个词，位置交换。该过程可以重复n次。
Eg: “如何评价 2017 知乎看山杯机器学习比赛?” —&gt; “2017 机器学习?如何比赛知乎评价看山杯”。
(4) 随机删除(RD: Randomly Delete)：句子中的每个词，以概率p随机删除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7b22c87359afef7f45177ef639a969d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/013baef855b8a403db4b0b0300674812/" rel="bookmark">
			抖音算法推荐机制详解（科普向）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自公众号“夕小瑶的卖萌屋”，专业带逛互联网算法圈的神操作
-----》我是传送门
关注后，回复以下口令：
回复【789】 ：领取深度学习全栈手册（含NLP、CV海量综述、必刷论文解读）
回复【入群】：加入卖萌屋深度学习/NLP/CV/搜广推等方向的技术交流与内推社群（大V、顶会审稿人云集）
回复【0511】：领取算法岗面试手册（刷offer神器）
回复【0424】：领取刷论文神器（挖掘每日、每月必刷重磅论文）
文 | 金钱兽@知乎
众所周知抖音的流量分配是去中心化的，这种去中心化算法，让每个人都有机会爆红，可为什么别人几个粉玩抖音，就能轻松获得10w+点赞?而你怒拍几十条也枉然?
抖音的游戏规则是什么?推荐算法怎样的?
一入抖音就深似海，可以说，一出爆款就能带火整个品牌，也就成了商家品牌营销的香饽饽，从15s短视频的下半场里胜出，可见其系统持续输出爆款的强大能力。
抖音短视频玩法千千万，了解算法与机制，针对的与抖音算法方面，进行一次深度的剖析，谈不上什么专业，但是针对抖音这块，我们能深入的挖掘，让你的抖音视频投放更加事半功倍。​
短视频发布后抖音一般会进行的一系列推荐流程，如下图所示：​技术层面是非常复杂的，涉及到很多专业的数据与理论。那么算法有什么好处？
算法对内容生产者的好处：我们既然想在别人的地盘为自己吸粉，就一定要明白别人的规则。就像追一个女孩子你得明白女孩子的喜恶，才有机会见缝插针地进入她的心。更何况，读懂平台比读懂女孩子容易的多！只要我们意识到平台的推荐机制，我们便可以有意识的设计自己的行为，引导平台判定我们是优质用户从而分配给我们更多、更精准的流与更高的权限。
下面我们往简单了说：根据算法，机器审核+人工双重审核。
首先看短视频发布后抖音一般会进行的一系列推荐流程：​
第一步：双重审核 在抖音，每天有数量庞大的新作品上传，纯靠机器审核容易被钻空子，纯靠人工审核又不太现实。因此，双重审核成为抖音算法筛选视频内容的第一道门槛。
机器审核：一般是通过提前设置好的人工智能模型来识别你的视频画面和关键词，它主要有两个关键作用：
其一，审核作品、文案中是否存在违规行为，如果疑似存在，就会被机器拦截，通过飘黄、标红等提示人工注意；
其二，通过抽取视频中的画面、关键帧，与抖音大数据库中已存在的海量作品进行匹配消重，内容重复的作品进行低流量推荐，或者降权推荐（仅粉丝可见、仅自己可见）。
人工审核：主要集中在3块：视频标题、封面截图和视频关键帧。针对机器审核筛选出疑似违规作品，以及容易出现违规领域的作品，抖音审核人员进行逐个细致审核。如果确定违规，将根据违规抖音账号进行删除视频、降权通告、封禁账号等处罚。​
第二步：冷启动 抖音的推荐算法机制是著名的信息流漏斗算法，也是今日头条的核心算法。通过审核后，第一步叫冷启动流量池曝光，比如你今天上传一个视频，通过双重审核的作品，系统将会分配给你一个初始流量池：200-300在线用户（也可能有上千个曝光）。不论你是不是大号，只要你有能力产出优质内容，就有机会跟大号竞争。
第三步：数据加权 抖音会根据这1000次曝光所产出的数据，结合你账号分值来分析是否给你加权，比如完播率、点赞、关注、评论、转发、转粉、游览深度等。
（点赞、评论、转发、点击率、完播率） 决定是否进行第二轮推荐及推荐力度。
即播放量=A完播率+B 点赞率+C* 评论率+D* 转发率
会对你的短视频数据造成影响，以及对你的短视频作出是否要加权的判断，比如会挑选前10%的视频，再增加1万次曝光。
也就是说，如果我们想让自己的视频火起来，那么就应该提高完播率、点赞率、评论率、转发率。
珍惜基础推荐流量池，提高四个数据，争取进入叠加推荐，对优质内容可以长期进行引导点赞评论。
​ 第四步：加大流量推荐 这一步会给数据好的短视频进行更大的加权，并且会在第三步强化人群标签分发，让内容分发的更加精准，这类似猜你喜欢的打标，视频是有标签的，用户也是有标签的，两者之间会做标签匹配。
账号的权重影响着初始流量池的大小，经常出爆款视频的账号无一例外都有很高的权重，这就要求从养号开始提升账号的权重——坚持定期发布视频，保证视频内容优质与专注，同时切记不要违反官方规则。
内容优质除了用户喜爱度外，主要与画面清晰度、是否原创及标题描述相关；而内容专注是指视频与账号领域相关且保持长期稳定的产出；而刷粉、硬广告和发布违禁内容都属于违规。
​ 第五步：进入精品推荐池（抖音的顶级流量池塘） 进入精品推荐池，大规模曝光，一旦进入精品推荐后，人群标签就被弱化了，就像当年温婉的视频，几乎每个抖音用户都会刷到温婉的视频。
第六：其他概念和现象 延后“引爆” 不少抖音运营者会发现，有些内容发布的当天、一周甚至一个月内都数据平平，但突然有一天就火了，为什么？两种原因：
第一种，被很多老司机戏称为“挖坟”。它是指抖音会重新挖掘数据库里的“优质老内容”，并给它更多的曝光。这些老作品之所以能被“引爆”，首当其冲是它的内容够好，其次，是你的账号已经发布了很多足够垂直的内容，标签变得更清晰，系统能够匹配给你更精准的用户。优质内容+精准用户，老作品重新火爆起来就不意外了。
第二种，我们可以称之为“爆款效应”，它是指，你的某一个作品在获得大量曝光（几百万，甚至千万级）时，会带来巨量用户进入你的个人主页，去翻看你之前的作品。如果你的某一个作品，能够获得足够多的关注（转评赞），系统将会把这些视频重新放入推荐池。很多垂直内容的创作者，往往都是因为某一个视频的“火爆”，直接把其他几个优质视频“点燃”，形成多点开花，全盘爆炸引流的盛况。
​
流量触顶 抖音作品经过双重审核、初始推荐、叠加推荐层层引爆之后，通常会给账号带来大量的曝光、互动和粉丝。而这种高推荐曝光的时间，一般不会超过一周。之后，爆款视频乃至整个账号会迅速冷却下来，甚至后续之后发布的一些作品也很难有较高的推荐量。为什么？
抖音每天的日活是有限的，也就是说总的推荐量是基本固定的：一方面，跟你内容相关标签的人群基本完成推荐，其他非精准标签人群反馈效果差，所以停止推荐；另一方面，抖音也不希望某个账号迅速火起来，而是通过一轮轮考验，考验你的内容再创新能力，考验你持续输出优质内容的能力。
第七：如何提高抖音账号权重 抖音在分配流量时会参考账号的权重，所以创作者不应忽视个人信息的搭建工作，要从官方认证、账号名、简介、头像、背景几方面进行完善。
1.抖音官方认证 抖音官方认证是平台对用户身份真实性的确认，进行身份认证有利于为视频争取更多推荐位。抖音官方认证分为三种：个人认证、企业认证和机构认证。
用户点击设置—账号与安全—申请官方认证，进入申请页面按要求申请。个人认证需同时满足以下条件：发布视频数量大于1，粉丝数大于1万，绑定手机号，并且账号无违规记录。
2.完善个人信息 账号应该具有鲜明的个人风格。账号名简洁与账号的整体调性相符。个人简介用来描述账号定位并引导用户关注。背景图的设置与账号整体风格相呼应，再加以文字标识引导关注。视频创作者要精心设计任何一个可以自定义的板块，为自己的账号提升转化机会。
第八：短视频内容优化技巧 1. 垂直 你是做美容类的视频就不要发一些与美容无关的视频，以免系统不能准确识别你是什么领域的账号从而给你打错标签或者不打标签，这样会导致你的账号权重上不去导致流量少与不精准。
2. 原创 最好不要抄袭，其实搬运别人的视频比自己拍一个视频还麻烦而且搬运越来越玩不起来啦。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/013baef855b8a403db4b0b0300674812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ce2c4c3d298f59a160aa5994391f05/" rel="bookmark">
			小猫爪：S32K3学习笔记03-S32K3之eMIOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小猫爪：S32K3学习笔记03-S32K3之eMIOS 1 前言2 eMIOS资源介绍3 CNT和Counter Bus4 UC的工作模式4.1 General-Purpose Input and Output (GPIO) mode4.2 Single Action Input Capture (SAIC) mode4.3 Single Action Output Capture (SAOC) mode4.4 Input Pulse Width Measurement (IPWM) mode4.5 Input Period Measurement (IPM) Mode4.6 Double Action Output Compare (DAOC) mode4.7 Pulse Edge Counting (PEC) mode4.8 Modulus Counter (MC) mode4.9 Modulus Counter Buffered (MCB) mode4.10 Output Pulse Width and Frequency Modulation Buffered (OPWFMB) mode4.11 Center Aligned Output PWM with Dead Time Insertion Buffered (OPWMCB) mode4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71ce2c4c3d298f59a160aa5994391f05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12051bcaa36ea0d3780ee9149e22765a/" rel="bookmark">
			WASM反编译，WASM逆向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯安全中心的一个"码上种树"活动里遇到了一道题，用的是WebAssembly。
放一个测试的wasm地址：test.wasm
之前没有接触过，上网查了一下之后发现都是通过wabt(WebAssembly二进制工具包)中的wasm2c进行转换:
在线转换地址
转换结果：
(module (type $t0 (func (param i32 i32) (result i32))) (import "Math" "min" (func $Math.min (type $t0))) (import "Math" "max" (func $Math.max (type $t0))) (func $Run (type $t0) (param $p0 i32) (param $p1 i32) (result i32) (local $l2 i32) (local $l3 i32) (local $l4 i32) (local $l5 i32) (local $l6 i32) (local $l7 i32) local.get $p0 local.set $l2 i32.const 10 i32.const 1 i32.sub local.tee $l4 if $I0 loop $L1 local.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12051bcaa36ea0d3780ee9149e22765a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec0d2695615da8be83b5af1f72680a0/" rel="bookmark">
			esp32学习笔记（4）——adc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、ESP32 ADC相关介绍二、使用步骤1.接口函数介绍2.代码示例 总结 前言 ADC即模拟数字转换器（Analog-to-digital converter）是用于将模拟形式的连续信号转换为数字形式的离散信号的一类设备。一个模拟数字转换器可以提供信号用于测量。与之相对的设备成为数字模拟转换器。
例如温度、压力、声音或者图像等，需要转换成更容易储存、处理和发射的数字形式。那就可以用到ADC了
提示：以下是本篇文章正文内容，下面案例可供参考
一、ESP32 ADC相关介绍 一些 ADC2 引脚用作捆绑引脚（GPIO 0、2、15），因此不能自由使用。
ESP32 DevKitC：由于外部自动编程电路，GPIO 0 无法使用。
ESP-WROVER-KIT：GPIO 0、2、4 和 15 不能使用，因为用于不同目的的外部连接。
由于 ADC2 模块也被 Wi-Fi 使用，因此它们一起使用时只有一个可以抢占，这意味着adc2_get_raw()可能会被阻塞直到 Wi-Fi 停止
ESP32 集成了 2 个 SAR（逐次逼近寄存器）ADC，总共支持 18 个测量通道（模拟使能引脚）。
ADC1，8通道：GPIO32 - GPIO39
ADC2，10个通道：GPIO0、GPIO2、GPIO4、GPIO12 - GPIO15、GOIO25 - GPIO27
以下介绍通过ADC1进行介绍
2、ADC衰减
Vref 是 ESP32 ADC 内部用于测量输入电压的参考电压。ESP32 ADC 可以测量从 0 V 到 Vref 的模拟电压。在不同的芯片中，Vref 不同，中位数为 1.1 V。为了转换大于 Vref 的电压，可以在输入 ADC 之前对输入电压进行衰减。有 4 种可用的衰减选项，衰减越高，可测量的输入电压就越高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ec0d2695615da8be83b5af1f72680a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f87eaa02b1a442d1e13b73d5a5fa140/" rel="bookmark">
			C语言32个关键字详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容建议大家收藏，全是干货，建议反复观看！！！ Let's Go ! ! ! 首先我们把 C89(C90) 的所有关键字进行一下分类，方便大家理解。 数据类型关键字(12个)： char、short、int、long、signed、unsigned、float、double、struct、union、enum、void 控制语句关键字 (12 个）： 1、循环控制（5个） for、do、while、break、continue 2、条件语句（3个） if、else、goto 3、开关语句（3个） switch、case、default 4、返回语句（1个） return 存储类型关键字（ 5 个） auto、extern、register、static、typedef 其他关键字（ 3 个） const、sizeof、volatile 上面我们把32个关键字进行的详细的分类，下面我们对于单个用法进行介绍，go! go! go! 优质内容推荐，建议每天学习：[字符串函数讲解] [C语言三子棋游戏] [操作符详细讲解] 目录
char
short
int
long
signed
unsigned
float
double
struct
union
enum
void
for
do
while
break
continue
if
else
goto
switch
case
default
return
auto
extern
register
static
typedef
const
sizeof
volatile
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f87eaa02b1a442d1e13b73d5a5fa140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60fb0701f5a4bd5b3dd7b2e2e90fb8d6/" rel="bookmark">
			Python 复制一份文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文讲述如何复制一份文件，用例是复制模板.xlsx文件到相同目录下，复制后的文件名为模板1.xlsx。
该代码运行有个前提就是，你必须要有一份被复制的文件，否则将复制不成功
这个方法可以复制word文件等等。只要修改文件的后缀名即可。
代码 import os from shutil import copyfile prePath = os.getcwd() + "/模板.xlsx" finPath = os.getcwd() + "/模板1.xlsx" copyfile(prePath, finPath) os、shutil都是Python自带的库，不需要安装，os的getcwd()方法主要用来获取该py文件所在位置，把所在位置相同的模板.xlsx文件复制一份到这个文件夹下。
os.getcwd()：用户获取当前py文件所在路径。如果你的Py文件放在C盘，那么执行如下代码会输出：“C：”
print(os.getcwd()) copyfile()：用于复制的方法
运行效果如下图所示：
模板.xlsx是原先同mian.py放在一个文件夹下，执行完上述代码后，在相同目录下建立一个模板1.xlsx文件
举一反三 那么，聪明的小伙伴也想到了，如何把C盘的文件复制到D盘呢？
答：只要修改prePath和finPath中的内容即可。可以自由的复制A文件到B文件的文件夹下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee1a12b44c220cde5b53e8924792ab6/" rel="bookmark">
			ES6-4【解构赋值、函数默认值、数组解构、对象解构】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.函数默认值 (1).补充 var x = 1; { let x = x; log(x) }//是报错x is not defined 暂时性死区
TDZ(Temporal Dead Zone)
(2).函数默认值 虚值解决
function foo(x,y){ x = x || 1; y = y || 2; console.log(x+y); } foo(); //3 foo(5,6); //11 foo(5); //7 foo(null,6);//7 foo(0,5);//6 这里就会出问题这是falsy(虚值Boolean为假的值)，我赋值的是0 //es5解决方案 function foo(x,y){ var a = typeof(argument[0]!=='undefined' ? arguments[0]:1); var b = typeof(argument[1]!=='undefined' ? arguments[1]:2); console.log(a+b); } foo(); //3 foo(5,6); //11 foo(5); //7 foo(null,6);//6 foo(0,5);//5 //es6 function foo(x=1,y=2){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fee1a12b44c220cde5b53e8924792ab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a109c0d76acf553ff5ea38e6af65dfaf/" rel="bookmark">
			Python from import导包ModuleNotFoundError No module named,找不到模块问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习Flask框架的蓝图时，遇到导包时用到了`from . 模块 import 对象`，然后试了试直接 import会报错，直接告诉我找不到模块，发现问题以此记录。 场景 有一个flask框架的项目，目录结构如下:
有一个主包pro_flask，然后下面有两个子包admin和web，还有和pro_flask同级的启动文件
我在与admin和web同级的__init__.py文件中，导入admin和web里的一些资源。
代码如下：
在导入admin和web中的资源时，告诉我ModuleNotFoundError: No module named 'admin'
from flask import Flask # 以下 import的admin和web，是admin和web包下__init__.py中定义的对象 from admin import admin	# 项目启动后，这里会报错 from web import web	# 项目启动后，这里会报错 admin包下的__init__.py文件
from flask import Blueprint admin = Blueprint(	# 需要在其他模块中导入这个 admin 蓝图对象 'admin', __name__, template_folder='templates', static_folder='static' ) from . import views web包下的__init__.py文件
from flask import Blueprint web = Blueprint(	# 需要在其他模块中导入这个 web 蓝图对象 'web', __name__, template_folder='templates', static_folder='static' ) from .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a109c0d76acf553ff5ea38e6af65dfaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b24984890818a59e9f1a72f90bbb081/" rel="bookmark">
			Redis源码分析（一）内存池-zmalloc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 源码分析（一）内存池-zmalloc 概述内存管理zmalloc 内存分配结构图malloc库重要宏定义全局变量update_zmalloc_stat_add(__n) 增加记录使用的内存大小update_zmalloc_stat_alloc 增加已经分配的内存大小update_zmalloc_stat_add(__n) 减小记录使用内存大小update_zmalloc_stat_free 减小已经分配的内存大小OOM内存溢出处理zmalloc 分配内存zcalloc 分配内存空间，并且初始化zrealloc 重新开辟空间的大小zmalloc_size 当前分配的空间大小zfree 内存回收zmalloc_used_memory 获取已经使用的内存zmalloc_get_rss 获取内存碎片大小zmalloc_get_fragmentation_ratio 获取内存碎片率zmalloc_get_private_dirty 获取私有的被占有的脏内存 概述 大家好，我是一名萌新，在文章分享有不正确的、语言比较晦涩的地方，欢迎大家明确提出来。
本人经历：过去一年在某高校的Java方向的科研团队工作学习，今年在武汉做图像算法方向的工作。自己比较喜欢玩特性数据库比如Elasticsearch、Redis。对数据结构方面极其敏感，就从今天开始立一个flag，一个一个分析。
内存管理 zmalloc 内存分配结构图 malloc库 malloc是C语言的标准库函数，但是Redis并未使用标准malloc。在Redis源码src\Makefile中间有一段源码是这样写的： ifeq ($(uname_S),Linux) MALLOC = jemalloc，从次可以发现，Redis默认使用了 &lt;jemalloc/jemalloc.h&gt; 第三方内存池框架，它的官方描述它可以避免碎片和可扩展的高性能并发支持。除了此套框架外，同时它给出了其他两套内存分配回收方案。其中一套解决方案是google的 &lt;google/tcmalloc.h&gt; ，它是基于C++实现的，性能上比其他的框架都要好，但是与C语言存在一定的兼容性。另外一套就是标准库的 &lt;malloc/malloc.h&gt;，最不佳的选择，因为malloc进行的动态内存分配和嵌入式系统中使用到堆区的内存分配会产生内存碎片。
重要宏定义 HAVE_MALLOC_SIZE这个宏定义是会判断当前的操作系统是否有 malloc_size() 函数，也就是判断当前指针malloc开辟空间后指向空间的大小。PREFIX_SIZE 作为新开辟空间的头部信息，这块内存空间主要是存放size_t类型的开辟空间的大小信息。在Redis高版本中，如果是Mac平台，PREFIX_SIZE的大小就是有默认值固定的。
全局变量 已经使用的内存
static size_t used_memory = 0; 判断当前是否线程安全
static int zmalloc_thread_safe = 0; 有两种方法创建互斥锁，静态方式和动态方式。
POSIX定义了一个宏PTHREAD_MUTEX_INITIALIZER来静态初始化互斥锁。在LinuxThreads实现中，pthread_mutex_t是一个结构，而PTHREAD_MUTEX_INITIALIZER则是一个结构常量。
PTHREAD_MUTEX_NORMAL ： 不提供死锁检测PTHREAD_MUTEX_ERRORCHECK ：提供错误检查，尝试重新锁定的互斥锁已经由该线程锁定 或者
解除锁定的互斥锁不是由该线程锁定或者未锁定 返回错误PTHREAD_MUTEX_RECURSIVE ：锁定计数，锁住 +1 ，解除 -1 ，0可以获取PTHREAD_MUTEX_DEFAULT ： 以递归方式锁定，尝试解除对它的锁定、解除锁定尚未锁定的互斥锁，则会产生不确定的行为 POSIX这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b24984890818a59e9f1a72f90bbb081/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/244/">«</a>
	<span class="pagination__item pagination__item--current">245/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/246/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>