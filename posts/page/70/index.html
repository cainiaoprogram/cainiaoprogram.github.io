<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a37b77215afc2cbe4676a24364f669/" rel="bookmark">
			在 Node.js 中发出 HTTP 请求的 5 种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Node.js 中发出 HTTP 请求的 5 种方法 学习如何在 Node.js 中发出 HTTP 请求可能会让人感到不知所措，因为有数十个可用的库，每个解决方案都声称比上一个更高效。一些库提供跨平台支持，而另一些库则关注捆绑包大小或开发人员体验。
在这篇文章中，我们将探讨在 Node.js 中发出 HTTP 请求的五种最流行的方法，并为每种方法提供说明。
首先，我们将介绍使用标准库的 HTTP 请求和 HTTPS 请求。之后，我们将展示如何使用 node-fetch、Axios 和 superagent 等替代方案。
先决条件 在开始之前，请确保我们的开发环境具备以下条件：
Node.js节点包管理器 (NPM) 下面，我们将展示如何通过以下五种方法在 Node.js 中发出 HTTP 请求：
标准库（HTTP 模块）标准库（HTTPS 模块）Axiosnode-fetchsuperagent 标准库（HTTP模块） Node.js 中的标准库配备了默认http模块。它可以发出 HTTP 请求，而无需添加大量外部包。然而，由于该模块是低级别的，因此它可能对开发人员更加友好。
此外，我们需要使用异步流来对数据进行分块，因为 HTTP 请求的async/await功能不能与此库一起使用。然后需要手动解析响应数据。
通常，我们会使用 HTTP 模块进行测试或演示，因为它不安全。
这是使用http模块发出get请求的简单示例：
const http = require('http'); const options = { hostname: 'example.com', port: 80, path: '/', method: 'GET', }; const req = http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a37b77215afc2cbe4676a24364f669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e57d6cd9d03669c3d4535fe360fe49b/" rel="bookmark">
			Express.js 与 Nest.js对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Express.js 与 Nest.js对比 自从 Node.js 发布以来，Javascript 在后端领域的使用有所增加。由于 Node.js 的使用越来越多，每天都会有新的框架和工具发布。Express 和 Nest 是使用 Node.js 创建后端应用程序的最著名的框架之一，在本文中，我们将对它们进行比较。
Express Express 是 Node.js 的简约框架。尽管它涵盖了创建服务器端应用程序的几个核心方面，但由于其简单性、灵活性和性能，它很流行，甚至 Nest 也是构建在 Express 之上的。但是，express 仍然存在一些问题，在我们深入研究这些问题之前，我们需要了解它们为我们提供了什么，让我们不使用任何框架而仅使用 Node.js 创建一个 Web 服务器。
const http = require("node:http"); // Create a local server to receive data from const server = http.createServer((req, res) =&gt; { res.writeHead(200, { "Content-Type": "application/json" }); res.end(JSON.stringify({ message: "Hello World!" })); }); server.listen(8000); 在上面的代码中，我们使用 Node.js 中内置的 HTTP 模块创建一个 Web 服务器。如果我们向http://localhost:8000发送 Web 请求，将从我们的 Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e57d6cd9d03669c3d4535fe360fe49b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4577ff31d0a7d0af214adb957b96bd55/" rel="bookmark">
			windows11专业工作站版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows11已经发布很久了，你有没有升级呢，如果电脑不兼容，可以使用密钥升级，如下图：
有想要的小伙伴可以关注我并私信，我把密钥单独发布，此选项也适用于windows8.1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94715519d76494de08d15c100a462072/" rel="bookmark">
			react中设置activeClassName的笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React是一种流行的JavaScript库，用于构建动态用户界面。它具有许多有用的组件，其中之一是NavLink组件。NavLink组件用于在React应用程序中创建链接，并且它具有许多有用的属性，例如选中的样式设置。
react-router-dom": “^6.0.0”, 一下版本 在React中，NavLink组件的选中样式设置可以通过activeClassName属性进行设置。该属性指定当链接处于活动状态时应用的CSS类名。例如，如果您想将选定的链接的文本颜色更改为红色，则可以将activeClassName属性设置为“active-link”，然后在CSS中定义以下样式：
.active-link { color: red; } 此外，NavLink还具有一个名为activeStyle的属性，该属性允许直接指定选中链接的CSS样式。例如，如果您想将选中的链接的文本颜色更改为蓝色并添加下划线，则可以在NavLink组件中设置activeStyle属性，如下所示：
&lt;NavLink to="/home" activeStyle={{ color: 'blue', textDecoration: 'underline' }}&gt;Home&lt;/NavLink&gt; 在这个例子中，我们将选中链接的文本颜色设置为蓝色，并添加了下划线。
除了activeClassName和activeStyle属性之外，NavLink还具有其他一些属性，例如exact和strict。exact属性用于确保链接的路径完全匹配，而strict属性用于确保链接的路径与当前URL的末尾斜杠匹配。
React中的NavLink组件使得创建链接和处理选中的样式变得非常简单和直观。通过使用activeClassName和activeStyle属性，您可以轻松地自定义选中链接的样式，从而提高用户体验。
react-router-dom": “^6.0.0”, 一上版本 请使用以下方式
&lt;NavLink className={({ isActive }) =&gt; (isActive ? " selectnav" : "")} to={ele.path}&gt;{ele.name} &lt;/NavLink&gt; isActive 是一个boolean 表示路径是否匹配上 返回是一个class名字
navLink的api讲解笔记 React是一种流行的JavaScript库，它可以帮助开发人员构建复杂的Web应用程序。在React中，NavLink是一个非常有用的组件，它可以帮助我们轻松地为导航栏添加样式和路由功能。在本文中，我们将深入研究NavLink的API和属性，并提供基本的使用案例和场景，以及代码和注释。
NavLink的API和属性 activeClassName activeClassName是NavLink的一个属性，它定义了当链接处于活动状态时使用的CSS类名。例如，如果您想在导航栏中突出显示当前页面的链接，您可以将activeClassName设置为“active”，然后在CSS中定义.active类来设置样式。
activeStyle activeStyle是NavLink的另一个属性，它允许您定义链接在活动状态下使用的样式。与activeClassName不同，您可以在activeStyle中直接指定CSS属性和值，而不需要在CSS文件中定义类名。例如，您可以将activeStyle设置为{fontWeight: “bold”, color: “red”}，以使当前链接加粗并显示为红色。
exact exact是NavLink的一个布尔属性，它指定链接是否必须与当前URL精确匹配才能处于活动状态。默认情况下，exact为false，这意味着如果链接的路径与当前URL的路径匹配，则它将处于活动状态。如果您将exact设置为true，则链接必须与当前URL的路径完全匹配才能处于活动状态。
strict strict是NavLink的另一个布尔属性，它指定链接是否应该严格匹配路径。默认情况下，strict为false，这意味着如果链接的路径是当前URL路径的子集，则它将处于活动状态。如果您将strict设置为true，则链接必须与当前URL的路径完全匹配才能处于活动状态。
to to是NavLink的必需属性，它指定链接的目标URL。to可以是一个字符串，也可以是一个对象。如果to是一个字符串，则它应该是链接的路径。如果to是一个对象，则它应该具有以下属性：
pathname：链接的路径search：查询字符串hash：URL中的哈希值state：一个对象，它将与URL一起传递，可以在目标页面中使用。 基本的使用案例和场景 下面是一个基本的使用案例，它演示了如何使用NavLink来创建一个简单的导航栏：
import { NavLink } from "react-router-dom"; function Navigation() { return ( &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;NavLink exact to="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94715519d76494de08d15c100a462072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6732d4d40fe3213af52eb6ac676a8803/" rel="bookmark">
			SSH使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ssh的安装查看系统是否已经安装了ssh套件,或则系统是否已经启动了ssh服务安装ssh通过源代码安装ssh ssh配置修改SSH监听端口：禁止root用户登录：设置登录时提示信息 ssh命令使用通过远程主机1跳到远程主机2：通过SSH运行远程shell命令：进行端口映射： ssh端口转发示例三个非常强大的命令：本地转发远程转发（或ssh反向转发）反向隧道的维持增加反向ssh的维持时间代理ftp转发的例子 ssh密钥。使用密钥免密登录的原理举例serverA 免密登录 serverB生成密钥密钥分发将密钥复制进入一个名字为"authorized_keys"中。注意事项指定私钥登录有对应公钥的主机使用密钥连接报错scp指定端口 ssh的安装 查看系统是否已经安装了ssh套件,或则系统是否已经启动了ssh服务 dpkg -l openssh-server //查看是否安装服务器端 dpkg -l openssh-client //查看是否安装客户端 netstat -tl //查看系统是否已经启动了ssh服务 -t:表示tcp协议 -l:表示listen状态 安装ssh ubuntu系统 sudo apt install openssh-server sudo apt install openssh-client 或centos yum install openssh-server yum install openssh-client 通过源代码安装ssh 从官网下载合适的版本的源码，源码安装可以选择合适的版本，远程安装需要登录上机器，替换openssh，需要安装telnet来协助，
$ sudo apt install telnetd 完成后可以删除telnet服务
下载地址：http://www.openssh.com/portable.html
wget ttps://cloudflare.cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-6.6p1.tar.gz 下载完毕，解压缩
tar xzvf openssh-6.6p1.tar.gz 进入文件夹
用默认选项安装ssh:
./configure make make install 这将安装OpenSSH 二进制文件到 /usr/local/bin, 配置文件到 /usr/local/etc, 服务到/usr/local/sbin, etc.
如果报错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6732d4d40fe3213af52eb6ac676a8803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a3aff2ea449e5ccc9b40d451c033d1/" rel="bookmark">
			瑞芯微rk3588部署yolov5模型实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		瑞芯微rk3588部署yolov5模型实战 模型转换通过pt模型转换为onnx模型通过onnx模型转换为rknn模型 模型部署编译推送执行文件到板子运行(单图测试)多图测试 模型转换 ​使用此yolov5 仓库获取yolov5代码以及模型
通过pt模型转换为onnx模型 python export.py --rknpu rk3588 --weight yolov5s.pt ​rk_platform 支持 rk1808、rv1109、rv1126、rk3399pro、rk3566、rk3562、rk3568、rk3588、rv1103、rv1106。（实际上，无论平台如何，导出的模型都是相同的）
​’yolov5s.pt’ 可以替换为您的模型路径
​将生成一个文件名“RK_anchors.txt”，可以在外部执行 post_process 时使用它。
​注意：请使用–rknpu参数调用，不要更改export.py中的默认rknpu值。​
通过onnx模型转换为rknn模型 ​使用此模型转换库
打开yolo_ppyolo.yml文件
#support yolo[v5,v6,v7,v8], ppyoloe_plus model_framework: onnx model_file_path: best_3588B.onnx RK_device_platform: RK3588 dataset: coco_dataset_20.txt quantize: True pre_compile: online graph: in_0: shape: 3,640,640 mean_values: 0 std_values: 255 img_type: RGB configs: quantized_dtype: asymmetric_quantized-8 quantized_algorithm: normal optimization_level: 3 ​根据模型修改 yml 配置文件参数
必填项
​model_framework 参数，指定模型来源框架，如 onnx / pytorch.
​model_file_path 参数，指定模型路径
​RK_device_platform 参数，指定RKNN平台
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60a3aff2ea449e5ccc9b40d451c033d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40cc2920a50d94ba29f02953843b602/" rel="bookmark">
			Gradio构建AI算法网页界面显示教程（附实战代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gradio构建AI算法网页界面显示教程（附实战代码） 安装Gradio介绍.Interface文本输入和文本输出图像输入和文本输出文本输入和图像输出多个输入和单个输出 控制界面的外观和布局设置界面标题设置界面描述 实战代码——以ocr为例结语 Gradio是一个用于构建用户界面的Python库，可以轻松地构建和共享原型、演示和API。它提供了一个简单的方法来加载和运行Python函数，并以可视化的方式展示输入和输出。在本文中，我们将介绍如何使用Gradio的.Interface来构建一个可视化界面。 安装Gradio 在开始之前，确保已经安装了Python。然后在命令行中运行以下命令来安装Gradio：
重要！目前gradio4.0有bug，所以选择安装3.50.2
pip install gradio==3.50.2 介绍.Interface Gradio的.Interface是一个高级类，用于构建用户界面。它提供了一些预定义的界面模板，可以快速构建出具有吸引力的界面。下面是一个简单的例子，展示如何使用.Interface来构建一个可视化界面：
import gradio as gr def hello(name): return "Hello " + name iface = gr.Interface(fn=hello, inputs="text", outputs="text") iface.launch() 在上面的代码中，我们定义了一个名为hello的函数，它接受一个名字作为输入，并返回一个带有名字的问候语。然后，我们使用gradio.Interface来创建一个Interface实例，将hello函数作为fn参数传递。我们还指定了输入参数类型为"text"，输出参数类型为"text"。最后，我们调用launch方法来启动界面。 ### 接收不同类型的输入和输出 .Interface支持多种类型的输入和输出，包括文本、图像、音频和视频。下面是一些示例：
文本输入和文本输出 iface1 = gr.Interface(fn=hello, inputs="text", outputs="text") iface1.launch() 图像输入和文本输出 iface2 = gr.Interface(fn=ocr, inputs="image", outputs="text") iface2.launch() 文本输入和图像输出 iface2 = gr.Interface(fn=ocr, inputs="image", outputs="text") iface2.launch() 多个输入和单个输出 iface4 = gr.Interface(fn=combine, inputs=["text", "text"], outputs="text") iface4.launch() 控制界面的外观和布局 .Interface提供了许多选项来控制界面的外观和布局。下面是一些示例：
设置界面标题 iface = gr.Interface(fn=hello, inputs="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a40cc2920a50d94ba29f02953843b602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e9a2317c326366c2f6b135a79fff55/" rel="bookmark">
			清华开源语言大模型ChatGLM3部署实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		清华开源语言大模型ChatGLM3部署实战 安装环境下载模型文件测试是否安装成功gpu推理cpu推理量化推理 ChatGLM3 是智谱AI和清华大学 KEG 实验室联合发布的新一代对话预训练模型。 项目库地址：https://github.com/THUDM/ChatGLM3 安装环境 建议使用虚拟环境
git clone https://github.com/THUDM/ChatGLM3 cd ChatGLM3 pip install -r requirements.txt 其中 transformers 库版本推荐为 4.30.2，torch 推荐使用 2.0 及以上的版本，以获得最佳的推理性能。
下载模型文件 git lfs install git clone https://www.modelscope.cn/ZhipuAI/chatglm3-6b.git 需等待较长时间
测试是否安装成功 推理时将THUDM/chatglm3-6b改为自己下载模型的路径
gpu推理 推理需13g以上显存
from transformers import AutoTokenizer, AutoModel tokenizer = AutoTokenizer.from_pretrained("THUDM/chatglm3-6b", trust_remote_code=True) model = AutoModel.from_pretrained("THUDM/chatglm3-6b", trust_remote_code=True, device='cuda') model = model.eval() response, history = model.chat(tokenizer, "你好", history=[]) print(response) response, history = model.chat(tokenizer, "晚上睡不着应该怎么办", history=history) print(response) cpu推理 推理需32g以上内存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e9a2317c326366c2f6b135a79fff55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43179ccad6ef259cccf93b2df7115982/" rel="bookmark">
			基于UniGUI的管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.界面略图。
2.仅通过数据库即可二次开发，支持多个服务，多个数据库开发，轻松几步配置即可轻松打造任意管理类系统。
3.三层结构，支持多种数据库。
4.支持hyper_sever负载均衡。
5.dll扩展支持已开发成功。你可以使用此框架同时 通过dll集成自己的定制页面。 移动端正在开发中...
竖屏图总是传不上去，见谅！ 6. 新增动态DLL调用。如图所示，是一个隐私号码绑定方法（在dll里）的调用模板。
7.新增自定义主题
2023-11-17 新增内置Http Get/Post 功能，可以将三方接口的数据展示在系统表格中
以http://whois.pconline.com.cn/ipJson.jsp 获取IP地址信息为例
我们配置一个页面，类型为HttpGet 执行脚本填入请求头信息，表头字段配置为请求参数，自定义一个dll，将返回数据转换为指定格式的json即可。 效果如下图：
欢迎各位同学提出宝贵的意见和建议
附上 演示地址 用户 test01, 密123456,需要了解的同学请私信获取账号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a3b0da920f0fd3dc3840580c18c21ed/" rel="bookmark">
			Java Excel的数据导入导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyExcel简介 easyexcel 是阿里巴巴开源的一款excel 解析工具，底层逻辑也是基于apache poi进行二次开发的。不同的是，再读写数据的时候，采用 sax 模式一行一行解析，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）在并发量很大的情况下，依然能稳定运行！easyexcel支持采用注解方式进行导出、导入！
引入依赖 &lt;!-- EasyExcel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--csv文件操作--&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.javacsv&lt;/groupId&gt; &lt;artifactId&gt;javacsv&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; AnalysisEventListener读取监听 对象命名时严格遵守驼峰命名法，如果忽略可能会导致读取数据失败。 导入数据时，程序解析和读取数据用，通用读取监听类！
import com.baomidou.mybatisplus.toolkit.ReflectionKit; /** * excel通用读取监听类 */ public class ExcelListener&lt;T&gt; extends AnalysisEventListener&lt;T&gt; { /** * 自定义用于暂时存储data 可以通过实例获取该值 */ private final List&lt;T&gt; list = new ArrayList&lt;&gt;(); /** * 这个每一条数据解析都会来调用 * * @param data * @param context */ @Override public void invoke(T data, AnalysisContext context) { // 如果一行Excel数据均为空值，则不装载该行数据 if (isLineNullValue(data)) { return; } if (context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a3b0da920f0fd3dc3840580c18c21ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259d0c0ec867a75ffa32d7147d57f192/" rel="bookmark">
			Anaconda最新安装图文教程（详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、安装anaconda
1、首先需要到Anaconda的官网下载适合自己系统的版本。目前，Anaconda支持Windows、Mac OS X和Linux三种操作系统。Anaconda官网： https://www.anaconda.com/products/distribution
图1 anaconda官网是外国网站，速度非常慢，建议去清华大学开源软件镜像站下载，网址是：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/,点击即可进入。进入后如图2： 图2 根据网站信息选择适合的，我选的就是最新版那个，直接点击下载，不需要几分钟。 2、安装 下载完成后打开下载的安装程序，如图3
图3 出现下方界面后，点击I Agree
出现下方界面后，点击Next 出现下方界面后，点击Browse更改安装位置，再点击Next
点击安装（Install）等待安装 出现下方界面后，表示安装完成，点击Next
出现下方界面后，点击Finish
出现下方界面后，证明Anaconda已经安装完成。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a405fee5fcf3e7488a7d8e60dc1d177/" rel="bookmark">
			Flutter NestedScrollView 、SliverAppBar全解析，悬浮菜单的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们开发过程中经常会使用到悬浮菜单的使用，当我们滑动到指定位置后，菜单会自动悬浮。
实现效果如下（左为滑动前、右为滑动后）：
上述便是通过NestedScrollView 、SliverAppBar实现的效果，通过两个控件我们便可以实现上述的效果。
废话不多说直接上代码，代码的实现原理会以注释的形式实现：
import 'package:aboxmini/view/home/room/room_device_page.dart'; import 'package:flutter/material.dart'; import '../../model/app_model.dart'; class HomeTabBar extends StatefulWidget { const HomeTabBar({super.key}); @override State&lt;HomeTabBar&gt; createState() =&gt; _HomeTabBarState(); } class _HomeTabBarState extends State&lt;HomeTabBar&gt; with TickerProviderStateMixin { /// 自定义的一个类，此类可获取屏幕宽度等 final AppModel _appModel = AppModel.share(); /// 设置 中间展示区域的高度 final double _topHeight = 180 + AppModel.share().safeTop + kToolbarHeight; /// 分栏控制器 late TabController tabController = TabController(length: 3, vsync: this); /// 分栏控制器每一个标题 final _tabs = &lt;String&gt;["Tab 1", "Tab 2", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a405fee5fcf3e7488a7d8e60dc1d177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f9bff18790c124bd781e03edcafd58c/" rel="bookmark">
			【开发路上的坑合集】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数组的修改 需求：对数组中每个元素的某个属性修改其值
错误代码：直接对数组每项中的值修改了，
原因：数组的地址没变就不会改变到数组
this.arr.forEach((item) =&gt; { item.name = item.name + '学生'	}) 正确做法：
map() - 创建一个新数组，其中的元素是原数组经过某个函数处理后的结果。
const resultArr = this.arr.map(item =&gt; { item.name = item.name + '学生' return item }) this.arr = [...this.arr, ...resultArr] 知识点：
1.ES6 解构
[…arr, …array]
不改原数组值，生成新的数组。
2.遍历添加
array.forEach(item =&gt; {
arr.push(item)
})
遍历方法：forEach、map、filter、every、for、for in、for of等。
添加方法：push（后追加）、unshift（前追加）等。
arr值改变成追加后的样子，array值不改变
3.concat
arr.concat(array)
不改原数组值，生成新的数组。
4.join &amp; split
(arr.join(‘,’) + ‘,’ + array.join(‘,’)).split(‘,’)
原数组值不改变。
默认会把数组中的数字类型转成字符串类型。
数组的项是引用类型时会自动生成’[object Object]'，造成数据丢失或错误。
5.解构添加
arr.push(…array)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f9bff18790c124bd781e03edcafd58c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eeee6184f61cd301809428c8291c9e8/" rel="bookmark">
			事务死锁排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记一次 事务死锁的排查过程
首先使用
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX; 可以查看当前数据库所有事务状态
使用
SHOW ENGINE INNODB STATUS 可以查看一些事务状态
可以看出 trxId 565678168 锁住了 invoice表，
使用命令杀掉对应mysql线程，释放锁
kill &lt;thredId&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5235fc112914105f97dc7fae6950386/" rel="bookmark">
			mysql查询json字符串内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：mysql json 基础查询_mysql json查询-CSDN博客 mysql查询json字符串内容 （多层数组嵌套） select id,name JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.template_list[*].sms_content') sms_content, JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.template_list[*].sms_sign') sms_sign, JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.template_list[*].templateDTOS[*].smsTemplet') smsTemplate, JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.template_list[*].smsTemplateList[*].template_content') template_content, JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.template_list[*].smsTemplateList[*].template_sign') template_sign from t_config_json config where config_json like '%template_list%' order by create_time desc; 2. mysql 中json提取查询
select id, name JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.sms_templet') smsTemplate, JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.sms_sign') smsSign, JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.templateDTOS[*].smsTemplet') dtoContent, JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.templateDTOS[*].smsTempletId') dtoTempletId, JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.smsTemplateList[*].template_content') listContent, JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.baseInfo')), '$.smsTemplateList[*].template_sign') listSign, JSON_EXTRACT(JSON_UNQUOTE(JSON_EXTRACT(JSON_UNQUOTE(config_json), '$.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5235fc112914105f97dc7fae6950386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2240d169eca5fd4178b2f71c59cad280/" rel="bookmark">
			JSTL标签库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 STL的设计目的是通过减少在JSP页面中使用Java代码的量，提高JSP的可读性和可维护性。它提供了一系列与常见Web开发任务相关的标签，如循环、条件判断、格式化、国际化等。通过使用这些标签，开发人员可以在JSP页面中更简洁地实现复杂的功能。JSTL（JavaServer Pages Standard Tag Library）提供了多个标签库，每个标签库都包含一组相关的标签。以下是JSTL发布版本1.2中的标签库及其所包含的标签列表：
1. Core Tag Library（核心标签库）: &lt;c:set&gt;：用于设置变量的值。&lt;c:remove&gt;：用于移除或删除指定的作用域中的变量。&lt;c:catch&gt;：用于捕获异常并处理异常信息。&lt;c:out&gt;：用于输出表达式的值。&lt;c:if&gt;：用于条件判断。&lt;c:choose&gt;：用于基于条件选择执行。&lt;c:when&gt;：用于在&lt;c:choose&gt;标签内部定义条件。&lt;c:otherwise&gt;：用于在&lt;c:choose&gt;标签内部定义默认条件。&lt;c:forEach&gt;：用于迭代集合或数组。&lt;c:forTokens&gt;：用于根据分隔符分隔字符串并进行迭代。&lt;c:param&gt;：用于设置URL参数。 2. Formatting Tag Library（格式化标签库）: &lt;fmt:formatDate&gt;：用于格式化日期。&lt;fmt:parseDate&gt;：用于解析日期字符串。&lt;fmt:setLocale&gt;：用于设置区域设置。&lt;fmt:message&gt;：用于显示本地化文本。&lt;fmt:formatNumber&gt; 是 JSTL Core 标签库中的一个标签，用于格式化数字并进行本地化处理。 3. SQL Tag Library（SQL标签库）: &lt;sql:setDataSource&gt;：用于设置数据库连接。&lt;sql:update&gt;：用于执行SQL更新操作。&lt;sql:query&gt;：用于执行SQL查询操作。&lt;sql:param&gt;：用于设置SQL参数。 4. XML Tag Library（XML标签库）: &lt;x:parse&gt;：用于解析XML文档。&lt;x:out&gt;：用于输出XML文档内容。&lt;x:set&gt;：用于设置XML节点属性。&lt;x:forEach&gt;：用于迭代XML节点。 5. Functions Tag Library（函数标签库）: &lt;fn:length&gt;：用于获取字符串长度。&lt;fn:startsWith&gt;：用于判断字符串是否以指定前缀开头。&lt;fn:endsWith&gt;：用于判断字符串是否以指定后缀结尾。&lt;fn:substring&gt;：用于截取子字符串。&lt;fn:toUpperCase&gt;：用于将字符串转换为大写。&lt;fn:toLowerCase&gt;：用于将字符串转换为小写。&lt;fn:contains&gt;：用于判断字符串是否包含指定子字符串。&lt;fn:escapeXml&gt;：用于对XML敏感字符进行转义。 以上是JSTL 1.2版本中的标签列表。请注意，不同版本的JSTL可能会略有不同，因此您可能需要根据您使用的具体版本进行参考和使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01797cb589fc8987a494c882fd647719/" rel="bookmark">
			Eclipse常用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 在eclipse中，默认的Text file encoding是GBK（操作系统是中文简体）；如果操作系统是中文繁体，默认是MS950（Big5）
项目中大多使用的是UTF-8
通过在eclipse中对workspace修改编码格式，如下：
Windows -&gt; Preferences -&gt; General -&gt; Workspace -&gt; Text file encoding -&gt; Other , 修改成 UTF-8 2. 设置合适的字体大小和背景色
Windows -&gt; Preferences -&gt; Colors and Fonts -&gt; Text Font ,点击Edit设置字体。 Windows -&gt; Preferences -&gt; General -&gt; Editors -&gt; Text Editors -&gt; Background color ,设置背景色。建议设置为豆沙绿保护眼睛，red:204;green:232;blue:207。
3.设置JSP文件编码
Window -&gt; Preferences -&gt; Web -&gt; JSP Files -&gt; Encoding (一般是设置为UTF-8) 4. 设置JDK 设置JDk： Window -&gt; Preferences -&gt; Java -&gt; Installed JREs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01797cb589fc8987a494c882fd647719/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a1e0eda8df8958b4cbe617953bc203/" rel="bookmark">
			eclipse从SVN检出项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开eclipse后，在【window】里面找到 【show View】，点击 【other】 输入【svn】，点击【SVN资源库】
2、打开【SVN 资源库】视图后，在空白处【点击右键】，【新建】----》【资源库位置】
3.添加 URL路径：
填写SVN用户名和密码，点击OK.
4.在URL 下找到 要检出的 项目【右键】——》【检出为】
5.选择做为新项目检出，并配置。
6、返回 【Java】视图后，左侧就会出现检出的项目
7、【右键点击项目】——》【properties】
9、编码根据自己所需的进行修改——》点击【apply】
10、配置Build Path。【右键点击项目】——》【properties】-🡪【Java Build Path】
配置Source :点击Add Folder，勾选上resource.点击OK.
配置Libraries:标签切至Libraries。点击Add Libray.选择JRE System Library,
选择JRE，点击Finish.
点击Add Libray.选择Server Runtime,
选择tomcat。点击Finish.
11、运行项目。选中项目，右击【Run As】🡪【Run on server】
选择一个tomcat，或新建一个。【next】。最后【finish】.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d97c4aabc6354b6876951a6a5dcc9f9/" rel="bookmark">
			欧洲数据格式----EDF&#43;的格式释义及与BDF的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EDF+同EDF的区别
1：EDF+ 允许将多个非连续记录存储到一个文件中。这是与EDF唯一不兼容的地方。
2：EDF+ 标头记录可识别患者并根据 EDF 规范指定记录信号的技术特征，但第一个“保留（reserved）”字段（44 个字符）除外。-------------保留字段内容不同
3：如果记录不间断，“保留（reserved）”字段则必须以“EDF+C”开头，因此具有连续的数据记录，即每个数据记录的开始时间与前一个数据记录的结束时间（开始时间 + 持续时间）一致。如果记录中断，“保留(reserved)”字段必须以“EDF+D”开头，因此并非所有数据记录都是连续的。
4：EDF+的“版本(version)”字段必须仍然像EDF一样读'0 '。EDF+软件将从上述“保留(reserved)”字段中知道连续文件和不连续文件之间的区别。
5：“普通信号（ordinary signal）”：一系列 2 字节样本，后续样本表示该信号的后续整数值，以相等的时间间隔进行采样。
6：EDF+数据记录包含根据EDF规范（包括61440的大小限制）的普通信号，但数据记录可以无条件地短于1s，后续数据记录不需要形成连续记录。
7：EDF+中，普通信号的样本在每个数据记录包内必须具有相等的采样间隔，但到下一个数据记录包的第一个样本的间隔可能不同。
8：极端情况下，若每个普通信号在每个数据记录中仅占用一个样本，或文件是不连续的（EDF+D），则将“数据记录的持续时间（duration of a data record）”指定为 0。
9：EDF+中，在header头部分，仅使用字节值为 32到126 的可打印 US-ASCII 字符。
10：标题中的“开始日期（startdate）”和“开始时间（'starttime）”字段应仅包含字符0-9，并将句点（.）作为分隔符，例如“02.08.51”。在“开始日期（startdate）”中，使用1985年作为剪辑日期，以避免Y2K问题。因此，1985-1999 年必须用 yy=85-99 表示，2000-2084 年必须用 yy=00-84 表示。2084年之后，yy必须是“yy”。
11：“本地患者标识（local patient identification）”字段必须以子字段开头（子字段不包含空格，但用空格分隔），子字段任何空格都必须替换为其他字符，例如下划线。
12： “数字最大值（Digital maximum）”必须大于“数字最大值（Digital minimum）”。在负放大器增益的情况下，相应的“物理最大值（Physical maximum）”小于“物理最大值（Physical minimum）”。
13：普通信号样本（2 字节 2 的补码整数）必须以“小端序（little-endian）”格式存储，即最低有效字节优先。这是 PC 应用程序中的默认格式。
14：旧的EDF软件只会将此“EDF注释（EDF Annotations）”信号视为（奇怪的）普通信号。
15：即使不保留注释，EDF+文件也必须至少包含一个“EDF Annotations”信号，以便指定每个数据记录的开始时间（见第2.2.4节）。当然，label中的“EDF Annotations”标签不允许用于普通信号。标头中的“每个数据记录中的样本数（nr of samples in each data record）”字段指定该“EDF Annotations”信号在每个数据记录中占多少2字节整数。
16：“EDF Annotations”信号只有有意义的标题字段“label”和“nr of samples in each data record（每个数据记录中的样本数量）”。为了与EDF兼容，字段“数字最小值（digital minimum）”和“数字最大值（digital maximum）”必须分别填写-32768和32767。“物理最大值（Physical maximum）”和“物理最小值（Physical minimum）”字段必须包含彼此不同的值。该信号的其他字段用空格填充。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d97c4aabc6354b6876951a6a5dcc9f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f051c782057403084163b6dbb3096b/" rel="bookmark">
			C# WinForm窗体大小变化后页面切换控件闪烁的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# WinForm窗体大小变化后页面切换控件闪烁的解决方法 问题描述 窗体大小变化后页面切换控件闪烁，用了双缓冲也无效。
制作WinForm页面时，页面上有大量控件，导致窗体页面切换时控件加载闪烁。按照网上的双缓冲解决方法可以解决第一次页面加载后页面切换的闪烁问题。代码如下：
public MainForm() { InitializeComponent(); //设置控件风格 SetStyle( ControlStyles.AllPaintingInWmPaint | //全部在窗口绘制消息中绘图 ControlStyles.OptimizedDoubleBuffer, //使用双缓冲 true); } /// &lt;summary&gt; /// 重写函数处理闪屏 /// &lt;/summary&gt; protected override CreateParams CreateParams { get { CreateParams cp = base.CreateParams; cp.ExStyle |= 0x02000000; return cp; } } 但是窗体最小化后再变大后，页面切换控件依然闪烁。
解决方案： 设置窗体的TransparencyKey，用窗体编辑器或写在初始化代码中都可以。
this.TransparencyKey = System.Drawing.Color.LightGray; 添加此方法后，窗体加载时会先出现整片的LightGray片刻后进入窗体。再在窗体的Resize方法中添加如下方法：
private Timer Timer = null; private void MainForm_Resize(object sender, EventArgs e) { if (this.WindowState == FormWindowState.Normal) { Timer = new Timer() { Interval = 100 }; Timer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f051c782057403084163b6dbb3096b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e034249d3b45e7a73819d371836e01b7/" rel="bookmark">
			2023前端面试题总汇（持续更新中...）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、HTML、XHTML、XML 有什么区别？⭐
2、 XML和JSON的区别？
3、是否了解W3C的规范？⭐
4、什么是语义化标签？⭐⭐
5、常用的块级元素和行内元素有哪一些? ⭐
6、行内元素和块级元素的区别？⭐ 7、css盒子模型有几种类型？它们区别是什么 ⭐ 8、标签上title与alt属性有什么区别？
9、 H5新特性有哪些？⭐⭐
10、css3的新特性有哪些？⭐⭐
11、css的引用有哪些，link和@import的区别？
12、href和src的区别？⭐
13、CSS常用尺寸单位有哪些？应用场景？
14、移动端适配方案有哪些？⭐
15、什么是浮动？
16、清除浮动有哪些方法? ⭐
17、css选择器有哪些？⭐
18、CSS 样式覆盖规则？⭐
19、CSS 样式的优先级？⭐⭐
20、display: none 和 visibily: hidden 区别? 21、相对定位，绝对定位，固定定位的区别？
22、说几个未知宽高元素水平垂直居中方法? 二、JS 篇
1、JS数据类型有哪些？区别？⭐⭐⭐
2、JS中检测数据类型的有哪些？⭐⭐
3、JS中的栈和堆是什么？优缺点？⭐⭐⭐
4、深克隆和浅克隆？⭐⭐⭐
5、JS垃圾回收机制？⭐
6、JS哪些操作会造成内存泄露？⭐⭐
7、闭包？⭐⭐
8、什么是原型链？⭐⭐⭐
9、JS继承的方法有哪些？优缺点？⭐
10、new操作符具体都干了什么?⭐⭐
11、JS的几种具体异常类型(报错)
12、什么是事件冒泡？什么是事件委托？
13、事件对象？ 14、undefined 和 null 区别？⭐
15、说一说伪数组和数组的区别？
16、对于数组去重都有哪些方法？⭐⭐ 17、 对join、push、split、splic、slice的理解？
18、说一下this指向？⭐⭐ 19、 js中call、apply、bind有什么区别?⭐⭐
20、箭头函数和普通函数有什么区别？⭐⭐ 21、JQ对象和DOM元素之间如何转换？ 22、JS模块化有哪些？
23、如何操作DOM元素？
24、防抖与节流的区别，并分别用代码表示 24、数组迭代的方法有哪些？ 25、for循环和forEach有什么区别?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e034249d3b45e7a73819d371836e01b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a31dfc3cf5e452abbbecf1a4d808600/" rel="bookmark">
			linux使用spi读取icm20608传感器数值一直显示0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.这个问题困扰了我两天，把下面这些uart2相关引脚屏蔽掉也不行，ICM20608 ID 读出的数值一直为 0X0
pinctrl_flexcan2: flexcan2grp{
fsl,pins = &lt;
/* MX6UL_PAD_UART2_RTS_B__FLEXCAN2_RX 0x1b020*/
/* MX6UL_PAD_UART2_CTS_B__FLEXCAN2_TX 0x1b020*/
&gt;;
};
pinctrl_uart2: uart2grp {
fsl,pins = &lt;
/* MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX 0x1b0b1
MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX 0x1b0b1*/
MX6UL_PAD_UART3_RX_DATA__UART2_DCE_RTS 0x1b0b1
MX6UL_PAD_UART3_TX_DATA__UART2_DCE_CTS 0x1b0b1
&gt;;
};
pinctrl_uart2dte: uart2dtegrp { fsl,pins = &lt; /* MX6UL_PAD_UART2_TX_DATA__UART2_DTE_RX	0x1b0b1 // MX6UL_PAD_UART2_RX_DATA__UART2_DTE_TX	0x1b0b1 // MX6UL_PAD_UART3_RX_DATA__UART2_DTE_CTS	0x1b0b1 // MX6UL_PAD_UART3_TX_DATA__UART2_DTE_RTS	0x1b0b1*/ &gt;; }; ecspi3使用原厂的代码也不行
/mnt/22_spi # insmod icm20608.ko
ICM20608 ID = 0X0
2.后来发现出厂源码写错了！！！！！！！cs-gpio少些了一个s。改后就可以读到ID值了。
/mnt/22_spi # insmod icm20608.ko
ICM20608 ID = 0XAE
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/266d46b77a28ff63570f8e27798dde5d/" rel="bookmark">
			冒泡排序，选择排序，插入排序，快速排序的核心思想和代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 冒泡排序
1.1 冒泡排序的核心思想
1.2 冒泡排序代码展示
2. 选择排序
2.1 选择排序的核心思想
2.2 选择排序代码展示
3. 插入排序
3.1 插入排序的核心思想
3.2 插入排序代码展示
4. 快速排序
4.1 快速排序的核心思想
4.2 快速排序代码展示
1. 冒泡排序 1.1 冒泡排序的核心思想 如下图所示，是一个乱序的数组，冒泡排序的解题思路就是，让两个相邻数据作比较，把大的数据放在后边，小的数据放在前面，经过循环之后，最大的一个数据就已经在数组的最后了
过程如下：
（1）3和5作比较，后面的5大，不需要做交换；
（2）5和2作比较，前面的5大，5和2交换位置；
（3）5和1作比较，前面的5大，5和1交换位置；
（4）5和4作比较，前面的5大，5和4交换位置； 经过4次循环之后，最大的数据5已经确定并放在了数组的最后，我们也可以发现，5个数据，需要比较四次，那么类比推理，数组中如果有 n 个数据，则需要比较 n-1 次。
经过了第一次循环之后，最大的数据5此时在数组的最后，但是现在数组还不是完全有序的，我们只确定了最大的一个，其余的数据还需要继续使用冒泡排序，现在我们除去刚才的数据5，那么就剩下了4个数据需要进行排序，就需要进行 4 - 1 = 3 次，经过排序之后，我们又能确定数据4。
但是前面三个数据还是无序的，我们还要对前面三个数据再进行排序，进行3 - 1 = 2次排序，确定数据3；
确定了数据3的位置之后，还有两个数据需要排序，进行 2 - 1 = 1次排序，此时，整个数组才算是完全有序的；
1.2 冒泡排序代码展示 // 将冒泡排序定义为一个方法，方便调用，方法参数为待排序的乱序数组 public static int[] bubbleSort(int[] arr) { // 定义一个第三方变量 temp 用于存储数组的值 int temp; // 数组长度就是变量个数，一共要经历(数组长度 - 1)次循环 // -1 另一方面是防止索引越界 for (int i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/266d46b77a28ff63570f8e27798dde5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5901a6d9214c2a7aa5358126b1e9923/" rel="bookmark">
			SeuratData包里pbmc3k数据集下载老失败的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pbmc3k是单细胞经典数据集，SeuratData包里包含了pbmc3k等各种数据集供下载。但是因为网络原因，在R里直接下载很容易失败。把该数据集用浏览器（用IDM等下载工具更快）下载下来后查看发现是R包的形式存在的，因此可以用手动安装的方式获得该数据集。详细如下：
# 从github上安装SeuratData包 devtools::install_github('satijalab/seurat-data') # 导入SeuratData包 library(SeuratData) # 查看当前所有可获取的数据集和简介 AvailableData() # timeout时间从默认60改为1000，尝试代码自动下载安装 options(timeout = 1000) InstallData("pbmc3k") 下载报错信息
trying URL
‘http://seurat.nygenome.org/src/contrib/pbmc3k.SeuratData_3.1.4.tar.gz’
Content type ‘application/octet-stream’ length 93780025 bytes (89.4
MB)
downloaded 1.2 MB
Error in download.file(url, destfile, method, mode = “wb”, …) :
download from
‘http://seurat.nygenome.org/src/contrib/pbmc3k.SeuratData_3.1.4.tar.gz’
failed
手动下载该链接：‘http://seurat.nygenome.org/src/contrib/pbmc3k.SeuratData_3.1.4.tar.gz’，放到指定目录，这里放在home目录下
# 手动安装该数据集 install.packages('~/pbmc3k.SeuratData_3.1.4.tar.gz', repos = NULL, type = "source") # 仅首次需要手动导入，后续可以直接加载 library(pbmc3k.SeuratData)	# 加载该数据集 data("pbmc3k") # 查看数据 pbmc3k = UpdateSeuratObject(pbmc3k) pbmc3k 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/376663a469f4bfbfe790266c9d1fab3f/" rel="bookmark">
			制造业工厂的MES系统数据采集功能概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MES系统与数据采集
MES系统是专门针对制造业工厂的信息化管理系统，旨在提高生产效率、降低成本、优化资源配置。数据采集作为MES系统的重要功能之一，能够实时获取生产现场的数据信息，为生产管理提供可靠的决策依据。
二、MES数据采集功能
设备连接与数据采集
MES系统可以与各种生产设备进行连接，实现数据的自动采集。通过数据接口、通信协议等方式，MES系统从设备中获取关键的生产数据，如产量、质量、能耗等，同时还可以对设备的运行状态进行监控。
数据存储与处理
MES系统具备强大的数据存储和处理能力，能够将采集到的生产数据进行实时存储和分析。通过数据挖掘、统计等技术手段，MES系统可以对生产数据进行深入处理，为后续的数据分析和优化提供支持。
可视化展示
MES系统可以将采集到的生产数据进行可视化展示，帮助管理者直观地了解生产情况。通过数据报表、图形化界面等方式，管理者可以实时掌握生产进度、产品质量、设备状态等信息，为决策提供依据。
数据报警与预警
MES系统具有数据报警与预警功能，能够根据预设的条件对异常数据进行实时提醒。例如，当设备出现故障或产品质量出现问题时，MES系统可以立即发出警报，以便相关人员及时采取措施进行干预。
数据追溯与分析
MES系统支持对历史数据的追溯与分析，帮助企业实现对生产过程的精细化管理。通过对历史数据的挖掘和分析，企业可以找出生产过程中的瓶颈和问题，优化生产流程，提高生产效率。
数据整合与共享
MES系统可以与其他管理系统进行数据整合和共享，如ERP、SCM等。通过数据交互和共享，企业可以实现信息的协同和集成化管理，提高整体运营效率。
MES数据采集主要采集以下几类数据：
三、主要采集哪些数据
生产数据：包括生产计划、订单、生产进度以及生产线的运转情况等。这些数据有助于企业管理者实时了解生产状况，及时调整生产进度和计划以保证生产流程的顺利开展。通过MES系统，企业可以掌握每个生产过程中的生产设备和物料的状态，以便及时发现并处理生产过程中的问题，从而提高生产效率并减少产品的浪费。
工艺文件数据：MES系统中的工序间的周转系统自动完成，其转序依据就是工艺流程，这也是其运行的基础。
库存数据：包括原材料、半成品和成品的数据，如物料齐套清单等。这些数据在ERP中产生并通过集成接口导入到MES系统中执行，完成状态再返回ERP。
图纸等技术文件数据：为了降低成本以及技术、工艺的需要，很多企业希望能够实现无纸化生产，生产过程中不再使用纸质图纸、工艺等文件，所有文件均在MES系统中读取。
DNC（分布式数控）系统数据：DNC系统中的设备、数控程序及任务完成情况等信息可以导入MES系统中，该系统也可把生产任务信息导入DNC。
四、MES数据采集的优势
提高生产效率：通过实时数据采集和分析，MES系统能够帮助企业实现生产过程的可视化、精细化管理，从而提高生产效率。
降低成本：通过数据采集和分析，企业可以实现对原材料、能源等资源的优化利用，降低生产成本。同时，数据采集还可以帮助企业减少人工干预和错误率，降低质量损失。
提高产品质量：MES系统可以对生产过程中的质量数据进行实时监控和分析，帮助企业及时发现并解决问题，从而提高产品质量。
优化资源配置：通过数据采集和分析，企业可以实现对人力、设备等资源的优化配置，提高资源利用效率。
增强决策支持：MES系统提供的数据采集和分析功能可以帮助企业做出更明智的决策，如产品优化、生产计划调整等。
适应工业4.0发展：随着工业4.0时代的到来，MES系统的数据采集功能将更加智能化、自动化和互联化，为企业实现智能化制造提供有力支持。
五、总结
通过实时获取生产现场的数据信息并进行分析处理，企业可以实现对生产过程的全面数字化管理。同时，结合其他管理系统的数据整合和共享，企业可以实现信息的协同和集成化管理，提高整体运营效率。为了充分发挥MES系统的优势，企业需要深入了解其业务需求和技术支持能力，并选择适合的MES系统供应商进行合作。通过不断优化和完善MES系统的数据采集功能，企业可以实现更高效、精准和智能化的生产管理，为制造业的发展提供强大支撑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10cb6a5ff626c7dc184a7294096c56d/" rel="bookmark">
			《如何为Java程序配置JVM参数》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《如何为Java程序配置JVM参数》 Systemd 入门教程：实战篇1、JVM相关参数2、服务配置文件3、命令解释 Systemd 入门教程：实战篇 不懂Systemd的伙伴，可以参考这篇文章：Systemd 入门教程：实战篇
1、JVM相关参数 在Java虚拟机（JVM）中，-XX参数用于设置一些非标准的、高级的或者实验性的选项。这些选项通常被称为“非稳定”选项，因为它们可能在不同的JVM版本中以及不同的操作系统上表现不同，甚至在未来的版本中可能会被移除。
以下是一些常用的-XX参数：
-XX:+HeapDumpOnOutOfMemoryError：当发生内存溢出错误时，自动生成堆转储文件。-XX:HeapDumpPath=&lt;path&gt;：指定堆转储文件的保存路径。-XX:MaxHeapDumpSize=&lt;size&gt;：设置堆转储文件的最大大小。-XX:InitialHeapSize=&lt;size&gt;：设置初始堆大小。-XX:MaxHeapSize=&lt;size&gt;：设置最大堆大小。-XX:PermSize=&lt;size&gt;和-XX:MaxPermSize=&lt;size&gt;：用于设置永久代的初始大小和最大大小（在JDK 8及更高版本中已被废弃）。-XX:MetaspaceSize=&lt;size&gt;和-XX:MaxMetaspaceSize=&lt;size&gt;：用于设置元空间（Metaspace）的初始大小和最大大小（JDK 8及更高版本中取代了永久代）。 请注意，使用-XX参数需要谨慎，因为它们可能会影响JVM的稳定性和性能。此外，这些参数在不同的JVM实现中可能有所不同，建议仔细阅读相关文档并进行测试后再在生产环境中使用。
2、服务配置文件 [root@iZ0pu00rjhghkqcoaldf06Z /]# cat /etc/systemd/system/CITask.service [Unit] Description=java-task servcie After=syslog.target [Service] User=root ExecStart=/usr/bin/java -Djava.util.Arrays.useLegacyMergeSort=true -jar -Xmx8g -Xms1g -XX:MaxMetaspaceSize=512M -XX:MetaspaceSize=512M -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:+ParallelRefProcEnabled -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./dump/ /app/task/java-task.jar --spring.profiles.active=prod --spring.cloud.nacos.config.file-extension=properties --spring.cloud.nacos.config.server-addr=11.11.11.11:8848 --spring.cloud.nacos.discovery.server-addr=11.11.11.11:8848 --logging.level.com.alibaba.nacos.client.naming=ERROR --logging.path=/data/log/dcb/java-task SuccessExitStatus=143 [Install] WantedBy=multi-user.target 3、命令解释 这里提供的内容是一个 Systemd 服务单元文件的片段，用于定义一个名为 “community-intensive-task” 的系统服务。让我解释一下这些内容的含义：
[Unit]：这个部分定义了系统服务单元的基本属性，包括描述和启动顺序等信息。
Description=community-intensive-task service：这里定义了服务的描述，即它是 “community-intensive-task” 服务。
After=syslog.target：这里指定了在 syslog.target 启动后再启动这个服务。syslog.target 是系统日志服务的一个目标单元，这意味着该服务将在系统日志服务之后启动。
[Service]：这个部分定义了服务的具体参数和设置。
User=root：这里指定了以 root 用户的身份来运行这个服务。这意味着该服务将以超级用户权限来运行。 在整个服务单元文件中，[Unit] 部分提供了有关服务的基本信息，而 [Service] 部分则提供了有关服务运行方式的详细设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f10cb6a5ff626c7dc184a7294096c56d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79e9f5c5936dc9f4feb21e8d2b01fd1/" rel="bookmark">
			applicationContext.getBean 为null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景： 使用SpringUtils 添加了统一类的调用。单元测试是正常的。
SpringUtils public class SpringUtils implements ApplicationContextAware { private static ApplicationContext applicationContext; @Override public void setApplicationContext(@Nonnull ApplicationContext applicationContext) throws BeansException { SpringUtils.applicationContext = applicationContext; } public static ApplicationContext getApplicationContext() { return applicationContext; } public static Object getBean(String name) { return applicationContext.getBean(name); } public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) { return applicationContext.getBean(clazz); } } 实例化： @Configuration @AutoConfigureOrder(value = Ordered.LOWEST_PRECEDENCE) public class SpringAutoConfiguration { @Bean @ConditionalOnMissingBean(name = "springUtils") public SpringUtils springUtils() { return new SpringUtils(); } } 问题场景1： 在另外一个项目，引用SpringUtils，报错。applicationContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a79e9f5c5936dc9f4feb21e8d2b01fd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac03519a2fa3d82ee7c09017a1d57e49/" rel="bookmark">
			vue3学习之hook
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于使用vue3.2已经有段时间，对于setup-api的应用也有了基础的认识，最近一直疑惑的一个问题就是作者为什么从2x 升级到3x 直接改变了vue项目文件的形态。要知道这样做会增加vue的学习成本，那么就必然是老版本有痛点，新版本有优势。在3x版本被重点提及的hook又是什么？如何使用？我们一起来探讨。
一、Hook是什么？ 首先我们来看看官方对hook的定义：
当构建前端应用时，我们常常需要复用公共任务的逻辑。例如为了在不同地方格式化时间，我们可能会抽取一个可复用的日期格式化函数。这个函数封装了无状态的逻辑：它在接收一些输入后立刻返回所期望的输出。
很清晰明了的说明了hook是做什么的，但是又觉得有什么不对的地方，这不是和2x版本的mixin的功能有些相似么？那接下来我们写一个功能对比下看看。
二、编写自己的hook 使用2x实现联动选择城市功能 &lt;!-- html --&gt; &lt;template&gt; &lt;div style="padding:100px 40%"&gt; 联动选择省市 &lt;el-select v-model="province" placeholder="选择省份"&gt; &lt;el-option v-for="(item,index) in provinceList" :key="index" :value="item" :label="item"&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;el-select v-model="city" placeholder="选择市"&gt; &lt;el-option v-for="(item, index) in cityList" :key="index" :value="item" :label="item"&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/div&gt; &lt;/template&gt; // js 部分 export default { data () { return { province: '', city: '', provinceList: [], cityList: [] } }, mounted () { this.getProvinceList() }, watch: { province () { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac03519a2fa3d82ee7c09017a1d57e49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32d9eb5d33a72f550132ea5cb8cb34c5/" rel="bookmark">
			单点登录和Auth2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单点登录 1、什么是单点登录（SSO）？ 单点登录英文全称Single Sign On，简称SSO。指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。
2、单点登录的原理 3、SSO 的关键概念 3.1 用户代理 用户代理是指用户使用的客户端软件，例如浏览器用户代理可以与身份提供者和服务提供者进行交互，处理重定向和认证流程。在单点登录过程中，用户代理扮演着用户与身份提供者和服务提供者之间的中介角色 3.2 身份提供者（Identity Provider） 身份提供者是负责用户身份验证和颁发身份令牌的组件用户访问终端会通过身份提供者登录，并提供有效的身份凭据（例如用户名和密码）身份提供者验证用户凭据后，会发放包含用户身份信息的身份令牌，用于后续的认证和授权。 3.3 服务提供者（Service Provider） 服务提供者是依赖单点登录功能的应用程序或服务用户访问服务提供者时，服务提供者会检查用户是否已验证，如果未验证，则要求用户进行身份验证过程如果用户还未登录，服务提供者将用户重定向到身份提供者进行认证，在认证成功后，服务提供者可以使用收到的身份令牌建立用户会话。 4、单点登录的实现方法 4.1 基于 Cookie 的单点登录 cookie 是某些网站为了辨别用户身份，由服务端生成，发给客户端暂时或永久保存的信息。简言之，cookie 就是一种存储用户数据的媒介。举例来说，当我们打开一个网站，输入用户名和密码登录后系统会弹出是否保存 cookie，如果我们选择保存，在下一次登录时，就不需要再次输入用户名和密码，而是默认登录成功，直接进入页面。
4.2 基于令牌的单点登录 token 在身份认证中是令牌的意思，在词法分析中是标记的意思。一般作为邀请、登录系统使用。简言之，token 就是一种凭证，用户在登录注册时需要获取凭证，在经过验证后，方可登录相关被授权的应用。用户在首次登录系统时输入账号和密码，服务器会收到登录请求，然后验证是否正确；服务器会根据用户信息，如用户 ID、用户名、秘钥、过期时间等信息生成一个 token 签名，然后发给用户；用户验证成功后，返回 token；前端服务器收到 token 后，存储到 cookie 或 Local Storage 里； 当用户再次登录时，会被服务器验证 token；服务器收到用户登录请求后，对 token 签名进行比对：如果 token 验证正确，用户登录成功；如果 token 验证不正确，用户登录失败，跳转到登录页。
4.3 基于 OpenID Connect 的单点登录 使用 OpenID，用户的凭据仅在浏览器路由请求后由授权服务器使用。验证后，将向用户颁发访问令牌，用户可以通过该令牌访问多个应用程序，而无需与每个应用程序共享其凭据。
5、SSO 的优势和应用场景 优势 用户便利性：SSO允许用户使用一组凭据（例如用户名和密码）在多个应用程序或系统中进行身份验证，避免了重复输入凭据的繁琐过程，提高了用户体验安全性增强：相比于传统的多个独立的凭据，SSO使用更强大的身份验证和授权机制，提升了安全性。用户只需在单个身份验证过程中输入凭据，减少了密码泄露的风险提高工作效率：对于企业或组织来说，SSO可以减轻IT团队的管理负担，避免了为每个应用程序单独进行用户管理和授权的工作。此外，员工不需要花费额外的时间和精力来管理多个不同的凭据，可以专注于业务工作。统一访问控制：SSO可以集中管理用户的访问权限，通过一个中心化的身份提供者来控制用户对不同应用程序或系统的访问权限，确保只有经过授权的用户可以使用对应的资源和功能降低成本：通过SSO，企业可以降低对硬件、软件以及相关的IT支持和维护的成本。减少了因为密码重置和用户管理等问题而产生的支持成本 应用场景 企业内部：在企业内部应用中，SSO可以实现员工访问不同的内部系统、应用和资源而无需重复登录。电子商务平台：用户在电子商务平台上可以通过SSO登录，享受一次购物车和统一会员体验。教育机构：学生和教职工可以通过SSO登录学校的学习资源平台、图书馆系统等。 二、OAuth 2.0 1、什么是OAuth 2.0？ OAuth 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32d9eb5d33a72f550132ea5cb8cb34c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df99e7b6e523dc75946254c4c327eb53/" rel="bookmark">
			深入理解vue3 响应式数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前研究了vue的reactive方法，简写了vue3的响应式的核心原理，然后萌生了编写简易版vue3实现的想法。查阅相关资料后，来使用原生js环境模vue3的响应式数据的核心api实现。
// 响应式代码 const reative = (target) =&gt; { return new Proxy(target, { get: function (obj, key, ctx) { console.log('我被获取了') // 收集依赖 return obj[key]; }, set: function (obj, key, value) { console.log('我被设置了', key) // 执行回调 obj[key] = value; return true; } }) } const obj = reative({ name: '张三' }) console.log(obj.name, '----') obj.name = '张三子' console.log(obj.name, '------') // 我被获取了 // 张三 ---- // 我被设置了 name // 我被获取了 // 张三子 ------ 这个例子很好理解，reative 这个方法创建对象后，能去监听数据的get/set。 不管是vue2还是vue3, 最核心的还是 依赖收集 + 执行回调 ，而effect函数可以说是它的核心实现了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df99e7b6e523dc75946254c4c327eb53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea4d4b110c216ab4b7399f9aea55700/" rel="bookmark">
			科研学习|科研软件——SPSS统计的单因素方差分析与单变量方差分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在spss统计分析中，方差分析在比较均值菜单和一般线性模型菜单中都可以做，单因素方差分析一般称为单因素Anova分析，单变量方差分析一般称为一般线性模型单变量分析。这两种方法既有区别又有联系，在统计学中，这两种分析方法统称为方差分析，在spss中由于线性模型的引入，才有所区分，那么这两种分析方法在具体应用中有什么样的区别和联系？二者的适用情况是什么？分析结果有何异同？下面将进行详细介绍。
一、【基本概念】 方差分析（analysisof variance，Anova）是对总体均值的比较，其目的是检验平均值之间的差异是否具有统计学意义。单因素方差分析（One-wayAnova），是检验由单一因素影响的多组样本某因变量的均值是否有显著差异。与之对应的是多因素方差分析，需要说明的是：这里的单因素与多因素是针对自变量而言的，因变量可以有多个，但只有一个自变量（spss里称为因子）。单变量方差分析: 即单因变量方差分析，单变量对应的英文名称为“univariate”,其实际含义是“只有一个因变量的方差分析模型”，是检验几个分类变量对单个因变量均值的影响。与之相对应的是多变量方差分析。需要说明的是：这里的自变量（spss里称为因子，又包括固定因子和随机因子）可以有多个，但只有一个因变量。 二、【SPSS实现】 2.1 案例分析 某公司生产某种新食品，在不同区域内随机选取不同规模的超市，进行销售（具体数据见下图），要求分析超市规模对该产品销量的影响；
2.2 分析思路 案例中有两个自变量即超市规模（大、中、小，分别用1，2，3表示）和超市区位（市区、乡下，分别用1，2表示）；两个因变量，即产品销量和客流量。如果要研究超市规模对产品销量的影响，那么这里的自变量就只有一个，即超市规模（三种水平，大、中、小），因变量也只有一个，即产品销量。因此，本例可以使用单因素方差分析法，也可以使用单变量方差分析法。
我们同时采用这两种方法进行分析，对比一下这两种分析方法的结果有何异同。
2.3 分析步骤 （1）单因素方差分析 选择菜单【分析】-【比较均值】-【单因素Anova】，在弹出的对话框中进行如下选择：把【产品销量】选入因变量列表框，把【超市规模】选入因子列表框。从这里可以看出，因变量列表框是可以选择多个因变量的，但是因子列表框中，只能选择一个变量。 2.在右侧选择【事后多重比较】菜单，进行如下操作：勾选【LSD】、【SNK】、【Bonferroni】、【Tukey】、【Duncan】复选框，单击【继续】按钮，返回主对话框。（方法的选择主要依据想要何种多重比较结果，一般以选择LSD\TUKEY\SNK\SCHEFFE居多，Bonferroni法是对LSD法的改进，这里为了进行不同方法间的比较，故选以上方法）。此对话框对应的是均值的多重比较，主要分为假定方差齐性和未假定方差齐性两类，基本上只使用假定方差齐性，因为如果方差不齐性，不建议做方差分析或进行两两比较。
3.在右侧选择【选项】菜单，依次勾选【描述性】、【方差同质性检验】、【平均值图】，其他默认，单击【继续】按钮，返回主对话框。其中方差同质性检验即方差齐性检验，检验不同规模超市之间的产品销量的方差是否齐性。因为方差齐性与否直接决定着进行多重比较时的方法选择。
4.单击【确定】按钮，输出结果。
（2）单变量方差分析 1.选择菜单【分析】-【一般线性模型】-【单变量】，在弹出的对话框中进行如下选择：把【产品销量】选入因变量列表框，把【超市规模】选入固定因子列表框。需要注意的是：这里的【因变量】列表框只能选择一个变量，【固定因子】、【随机因子】列表框可以选择多个变量。
从对话框可以看出单变量方差分析与单因素方差分析的差别：一般线性模型单变量方差分析的因子区分为固定因子和随机因子，比单因素Anova分析更为细致，而且固定因子列表框可以同时选入多个变量，单因素Anova分析，因子列表框只能选入一个变量。
2.在主对话框界面选择右侧【模型】菜单，选择默认【全因子】，【类型Ⅲ】，单击【继续】按钮返回主对话框
3.在主对话框界面右侧选择【事后多重比较】菜单，把【超市规模】选入【事后检验】列表框，同样勾选【LSD】、【SNK】、【Bonferroni】、【Tukey】、【Duncan】复选框，单击【继续】按钮，返回主对话框。该对话框与单因素Anova对话框类似，但不同的是这里可以自由选入因子。
4. 在主对话框界面右侧选择【选项】菜单，在【输出】栏，勾选【描述性统计】【同质性检验】、【残差图】复选框，单击【继续】按钮返回主对话框
5. 单击【确定】按钮，输出结果。
2.4 结果解释 （1）单因素Anova分析结果解释 1.描述性统计结果
下图输出了基本的样本量、平均值、标准差等描述性统计结果。可知，较大规模超市的平均销量是最高的，但这只是针对该样本的，其所在总体是否也如此，需要进行后续分析。
2.方差同质性检验结果
下图输出了方差同质性检验结果，方差同质性检验采用的是levene检验，检验3种超市规模之间的方差是否齐性，由表中显著性=0.165&gt;0.05可知，接受原假设，认为3种超市规模之间方差相等。
3.方差分析结果
方差分析采用的是F检验，表中，平方和表示离差平方和，也就是变异，分为组间变异、组内变异。Df为自由度，均方为离差平方和/自由度，F统计量=组间均方/组内均方。其显著性=0.042&lt;0.05，故拒绝原假设，认为不同超市规模之间的均值具有显著差异（由于显著性=0.042，说明是弱显著性）。具体是哪种规模之间有均值有显著差异，故需要再进一步做多重比较分析。
4.事后检验结果
下图输出了【LSD】、【Bonferroni】、【Tukey】法的分析结果，可以看出，规模较大超市与较小超市之间差异显著，中等规模超市与较大规模超市和较小规模超市之前均不存在显著差异。三种比较方法的结果一致。
5.同类子集
下图为同类子集输出结果，Student-Newman-Keuls，Tukey，Duncan(D)三种方法的思想，都是在样本中寻找同质的组，认为同组的水平没有差异，从结果可以看出，三种方法都把规模分为两组，小中一组，中大一组，因此可以排除中等规模的影响，认为较小规模与较大规模之间均值存在显著差异。
6.平均值图
从3种规模超市之间的销量均值图也可以看出三种规模之间的差异。
（2）一般线性模型单变量结果解释
1.描述统计结果
同样输出了三种规模超市的平均值、标准差、样本量等情况，可以看出较大规模超市的平均销量较高，同时其标准差也较大。
2.方差齐性检验
由下图可以看出，显著性=0.165&gt;0.05,与单因素Anova分析结果一致，不能拒绝原假设，认为三种水平的方差相等。
3.方差分析结果
第1行，校正的模型，是对整个方差分析模型的检验，原假设为模型中所有因素对因变量无影响，即μ=0，此处p&lt;0.05，即均值不等于0，拒绝原假设，即认为超市规模对产品销量有影响。第2行，截距，原假设为不考虑自变量影响时，因变量的均值为0，此处P&lt;0.05，拒绝原假设。第3行，超市规模，也就是对自变量的检验即组间变异，原假设为自变量对因变量没有影响，此处P&lt;0.05，拒绝原假设。可以看出此处的结果同第1行的结果是相同的，这是因为案例只涉及到单一变量（产品销量）的比较。第4行，错误即误差第5行，总计=截距+组间+误差第6行，校正=组间+误差 4.事后检验
同样，下图输出了【LSD】、【Bonferroni】、【Tukey】法的分析结果，可以看出，规模较大超市与较小超市之间差异显著，中等规模超市与较大规模超市和较小规模超市之前均不存在显著差异，三种比较方法的结果一致。该结果与单因素Anova方法一致。
5.均一子集
下图为均一子集输出结果，Student-Newman-Keuls，Tukey，Duncan(D)三种方法的分析结果与单因素Anova分析结果一致。
三、【总结】 单因素方差分析和单变量方差分析的区别主要体现在在前者是单个自变量，后者是单个因变量。在实际运用中，这两种方法的统计效能是等价的，一般不做特别严格的区分，只是一般线性模型比单因素在某些方面更为细致一些。在适用条件上，二者的条件相同，均为：独立性、正态性、方差齐性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad3d178d3e0205ca75b8c6f81573acc/" rel="bookmark">
			17. Series.dt.month-提取日期数据中的月份信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【目录】
文章目录 17. Series.dt.month-提取日期数据中的月份信息1. 知识回顾-创建一个Series对象2. 知识回顾-pd.to_datetime()将数据转换为pandas中的日期时间格式3. 实例化类相关知识4. Series.dt.month是什么？5. 如何使用Series.dt.month？6. Series.dt.month的语法7. 返回值8. 实操练习9. 总结 【正文】 17. Series.dt.month-提取日期数据中的月份信息 学习时间：30分钟。
1. 知识回顾-创建一个Series对象 pandas库的核心数据结构是两种类型的数据对象：Series对象和DataFrame对象。Series对象是一维数组。DataFrame对象是二维数组。 创建一个Series对象：
【语法】
pd.Series(data, index) 【参数】
pd是库名。.英文小圆点。库名后接一个小圆点表示调用。Series类名。data是必需参数，表示要传递的数据。index是可选参数，用于自定义行索引。 【课堂练习】
创建一个Series对象，存储以下3个数据：
2021-01-01
2022-02-02
2023-03-03
【代码示例】
# 导入pandas库并简写为pd import pandas as pd data =['2021-01-01', '2022-02-02', '2023-03-03'] s1 = pd.Series(data) print(s1) 【终端输出】
0 2021-01-01 1 2022-02-02 2 2023-03-03 dtype: object 【备注】
以上知识点可以参加下面的链接：
2. Series对象-一维数据
学习就是一个从陌生到熟悉的过程，重复的次数多了，它就是你的了。
2. 知识回顾-pd.to_datetime()将数据转换为pandas中的日期时间格式 【作用】
pd.to_datetime()函数是pandas库中的一个函数，用于将输入的日期时间转换为pandas中的日期时间格式。
【语法】
pd.to_datetime(arg, format) pd库名，是pandas库的简写。英文小圆点.。to_datetime函数名，理解为转换成日期格式的函数。 【参数】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad3d178d3e0205ca75b8c6f81573acc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d7b5927c87d07335d0535230ee4038/" rel="bookmark">
			永磁同步电机矢量控制——电流环转速环 PI 参数整定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、预备知识 （1）典型I型系统的传递函数如下图所示：
（2）通常情况下，一个实际系统可以通过工程上的近似处理和调节器校正变换成 典型I（前面已讲） 或 典型 II 系统。
本节用到的工程上近似处理方法：小惯性群的近似处理，自动控制系统中有多个小时间常数的惯性环节相串联的情况，在一定条件下可以将这些小惯性环节合并为一个惯性环节。
调节器结构选择的基本思路：将控制对象校正成典型I或者典型II系统。
2、电流环PI参数整定 2.1、电流环的开环传递函数
上图为电流环传递函数框图，电流环的输入为电流信号的误差值，输出为电压，控制电机转矩。 第一个环节： PI调节器的传函
第二个环节：延迟传函
在实际计算过程中，CPU进入中断读取电流反馈值，然后进行PI调节器的计算，得到输出电压（或者三角波比较值），但是输出电压或者比较值不是立即作用出去的，通常会延迟一个PWM周期，才会将比较值输出出去。这样就造成了采样和计算的延迟，这里近似看成一阶延迟环节，时间常数为Ts(这里td=Ts)。
第三个环节： 逆变器的传函
经过第二个环节，更新了三角波的比较值后，输出的电压是立刻作用到了负载上面吗？还不是的。对于7段式SVPWM来说，调制特点决定了还有0.5Ts的延时。而Kpwm为逆变器的增益，这个值没有一个确定的数值，这里取Kpwm为1，默认他为理想型。
第四个环节： 电机传递函数
电机传递函数可近似处理为：
说下电机传函的由来，前面讲过电机在dq轴坐标系下的电压方程：
忽略耦合项的电压平衡方程为（这里只列出q轴电压方程）：
上式拉式变换后得到电机的传函。
在开关频率为10KHZ时，PWM逆变器和延迟环节的时间常数都很小。工程近似就可以把延迟环节和PWM环节合并处理：
因为时间常数Ts很小，那么分母中的二次项系数可以看做0，从而等效为一个典型的I型系统。
则可得电流传递函数框图：
则电流环的开环传函数：
2.2 、电流环参数整定 前面我们得到了电流环的开环传递函数，下面我们把开环传递函数配置成典型系统：
2.2.1、I型系统配置 I型系统开环传递函数的结构是：
Wcur(s)貌似又和I型系统的结构不一样。怎么处理？ 采用零极点对消法 ，将参数设置满足
Kp/Ki=Lq/R 这个条件，让分子分母各自约去一项，就能将电流环变成了I型系统。
剩下的Wcur(s)中，分子Ki/R就是I型系统的分子K，分母中的1.5Ts就是I型系统的T。如果按
照 ξ = 0.707 ，故可知 KT = 0.5 。
计算出PI调节器参数为：
其中Ts为PI调节器计算的周期，一般情况下等同于逆变器的开关周期。
典型I型系统跟随性能指标和频域指标与参数的关系如下表所示：
参考：
1.https://blog.csdn.net/sy243772901/article/details/82221672
2.2021-06-14_pi调节器里面kp和ki的确定-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a336c35e21b784f3924b947bec1d8a0/" rel="bookmark">
			永磁同步电机矢量控制——转速环 PI 参数整定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究转速外环的时候，将电流内环闭环传递函数简单视作一阶环节：
上节已推导，
考虑转速外环延时环节，合并上延时小惯性环节，由于转速外 环采样时间 Ts2 (即图中td) 远大于电流环采样时间 Ts，可以得到：
假设负载转矩 Tl=0，转速外环变为：
此时，开环传递函数为：
如果积分环节参数 Ki 的值比较小，转速外环可以简化成标准的二阶系统传递函数：
对比我们已知标准的二阶系统闭环传递函数：
可以得到：
式中，J 为转动惯量，Pn 为极对数，ψf 为永磁体磁链参数为已知常数，ξ 为阻尼系数与电流内环相同， Ts2 为延时环节时间常数，即为转速外环的釆样时间。
参考：
1. https://blog.csdn.net/sy243772901/article/details/82221672
2.《采用 id=0 的永磁同步电机矢量控制系统 MATLAB/Simulink 仿真》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7355bb72fa33b9492d68b6d9d719f56/" rel="bookmark">
			RT-Thread零基础快速入门第5讲——外部中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言源码链接 二、编程讲解三、项目实战四、结束语 一、前言 这一讲，我要讲的是外部中断，也不知道是太简单了还是没有人用，我没找到比较完整的关于RT-thread外部中断的教程，只发现RT-thread文档中心的PIN设备里面有提及中断相关的函数。不管怎样，我觉得外部中断平常用的还是很多的，至少我在使用RT-thread之前是经常会用到，好了，废话不多说，马上开始进入我们的教程。
源码链接 我发布的所有关于RT-thread的教程源代码都在下面这个链接里面，随着我教程的更新，新的代码也会加入进去。
教程源码下载链接：https://pan.baidu.com/s/1N2D8dM31deKIqNqaIQfPiA
提取码：7nsx
二、编程讲解 第一步：配置外部中断
从这个函数的描述我们可以很清楚的看到，只要调用上面这个函数就可以配置成外部中断脚，中断触发的方式，以及回调函数（等同于中断服务函数），而且回调函数的名称我们还可以自由定义，不像我们用裸机程序的时候，中断服务函数是已经固定了的。
第二步：使能中断
直接调用下面这个函数即可。
第三步：自己定义一个回调函数
因为RT-thread的外部中断没有固定的中断服务函数，所以我们需要自己定义一个，示例如下：
/* 自己定义一个回调函数，相当于中断服务函数 */ void IQR_HANDALE_KEY0(void *args) { rt_pin_write(LED0_PIN, PIN_LOW);//点亮LED0 } 三、项目实战 因为这个两个函数原本在pin.c里面就有定义，所以我们也不需要自己去写，直接调用就行了。
我这里用两个按键，KEY0按下，触发外部中断，点亮LED0，KEY1按下，熄灭LED0，示例代码如下：
#include &lt;rtthread.h&gt; #include &lt;rtdevice.h&gt; #include &lt;board.h&gt; #define LED0_PIN GET_PIN(F, 9) #define LED1_PIN GET_PIN(F, 10) #define KEY0_PIN GET_PIN(E, 4) #define KEY1_PIN GET_PIN(E, 3) /* 自己定义KEY0的回调函数，相当于中断服务函数 */ void IQR_HANDALE_KEY0(void *args) { rt_pin_write(LED0_PIN, PIN_LOW);//点亮LED0 } /* 自己定义KEY1的回调函数，相当于中断服务函数 */ void IQR_HANDALE_KEY1(void *args) { rt_pin_write(LED0_PIN, PIN_HIGH);//熄灭LED0 } int main(void) { int i = 0; /* 把LED引脚设置为输出 */ rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LED1_PIN, PIN_MODE_OUTPUT); /* 先把两个灯关掉 */ rt_pin_write(LED0_PIN, PIN_HIGH); rt_pin_write(LED1_PIN, PIN_HIGH); /* 把KEY引脚设置为输入 */ rt_pin_mode(KEY0_PIN, PIN_MODE_INPUT); rt_pin_mode(KEY1_PIN, PIN_MODE_INPUT); /* 绑定中断，下降沿模式，回调函数名为IQR_HANDALE_KEY0 */ rt_pin_attach_irq(KEY0_PIN, PIN_IRQ_MODE_FALLING, IQR_HANDALE_KEY0, RT_NULL); /* 使能中断 */ rt_pin_irq_enable(KEY0_PIN, PIN_IRQ_ENABLE); /* 绑定中断，下降沿模式，回调函数名为IQR_HANDALE_KEY1 */ rt_pin_attach_irq(KEY1_PIN, PIN_IRQ_MODE_FALLING, IQR_HANDALE_KEY1, RT_NULL); /* 使能中断 */ rt_pin_irq_enable(KEY1_PIN, PIN_IRQ_ENABLE); while (1) { rt_pin_write(LED1_PIN, PIN_LOW);//点亮LED1 rt_thread_mdelay(1000); rt_pin_write(LED1_PIN, PIN_HIGH);//熄灭LED1 rt_thread_mdelay(1000); } } 四、结束语 好了，关于外部中断的编程讲解就到这里，如果还有什么问题可以私信给我。如果需要本文对应的源码的话可以在博文前言部分的链接下载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7355bb72fa33b9492d68b6d9d719f56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d214f84ebdaf8354a5e9ee175a2177d/" rel="bookmark">
			颜色标记txt和多根走线【Cadance进阶】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言颜色标记txt多根走线 前言 今天来介绍个基础操作中不常见的，但是非常实用的技巧。第一个是颜色标记，它是与text文件结合，根据text文件中的网络来染色标记的，致力于找出那些特定的走线，或者是查询出现问题的走线。第二个是多根走线，功能正如其名，不必多说，它能使得走线非常漂亮，整齐有序。
颜色标记txt 功能：根据text文件中的网络来染色标记走线或者焊盘等
需要基础的技能和材料
染色操作text文件查看操作 操作步骤：
先用查看命令得知是它的网络名字是4-3-C41，这个便是Txt的内容，我们把它放到PCB文件下。名字为new1.txt文件。
打开PCB Editor软件，使用染色操作。
打开txt文件后，PCB Editor就会根据new1.txt文件的网络，将对应的网络染成黄色。
多根走线 走线命令 操作步骤：
首先打开走线操作，右键选择多根走线，Multi-Line Route.
在所要走线的区域，其中心点点击鼠标左键确认
会出现一个弹窗，设置好，走线数量，线宽，线与线之间的距离确认就可以走线了。
这些的应用场景很多，你掌握之后会给你带来非常大的便利，在应用过程中尽可能使用它们，会节省很多时间，也会让走线走得特别整齐。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aba8efd069f4d3a6d129a3ef8ba63d1/" rel="bookmark">
			[Vue 配置] Vite &#43; Vue3 项目配置和使用 NProgress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章归档：https://www.yuque.com/u27599042/coding_star/mfmsrf9tz98ox3qg
安装 pnpm i nprogress 配置 NProgress 其他更多可参考，仓库地址：https://github.com/rstacruz/nprogress
在 src/config/nprogress.js 中进行配置
是否展示右上角圆圈加载动画 NProgress.configure({ showSpinner: false }); 设置样式 src/styles/nprogress.css
#nprogress .bar { /* 自定义进度条颜色 */ background: #fa2c19 !important; } #nprogress .peg { /* 自定义进度条阴影颜色 */ box-shadow: 0 0 10px #fa2c19, 0 0 5px #fa2c19 !important; } 启动时进度的最小百分比 默认 0.08
NProgress.configure({ minimum: 0.1 }); 进度条动画和速度 动画可选值：
linear：动画从开始到结束保持相同的速度。ease：默认值，动画有一个缓慢的开始，然后加速，在结束之前又变慢。ease-in：动画有一个缓慢的开始。ease-out：动画有一个缓慢的结束。ease-in-out：动画有一个缓慢的开始和一个缓慢的结束。cubic-bezier(n,n,n,n)：在三次贝塞尔（cubic-bezier）函数中定义自己的值。可以是从 0 到 1 之间的数字值。 NProgress.configure({ easing: 'ease', speed: 500 }); 关闭自动递增 默认 true
NProgress.configure({ trickle: false }); 进度条递增速度 单位毫秒，多久自动递增一次
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aba8efd069f4d3a6d129a3ef8ba63d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67512727ca1238da8cb7fa9ab4124d3f/" rel="bookmark">
			2023最新IDEA下载安装及使用，超全面图文详解！亲测好用，看这篇就完事了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，今天为大家带来的是 IDEA 2023最新版本的下载安装，及使用教程，超详细图文教程详解，亲测好用。
不管你是小白还是大牛，看这篇文章就可以了！分分钟给你教明白
IDEA全称IntelliJ IDEA，是Java语言对的集成开发环境，IDEA在业界被认为是公认最好的Java开发工具
1、IDEA 下载 Tips：在官网下载很慢，你可以直接下载，各个版本安装包---&gt;&gt;&gt;：下载
当然你也可以到官网 https://www.jetbrains.com/idea/download/other.html 进入idea软件下载页面，下载安装包
我以idea2023.2.5 旗舰版本为例，为您全面讲解：
选择左边的 Ultimate 版本进行下载安装。Ultimate 版本为旗舰版，需要付费，包括完整的功能。
这里我们选择左边 Ultimate 版本进行下载，然后进行激活。
2、IDEA 安装 下载好zip安装包后，双击运行 Next 选择安装路径
点 Install，安装 安装完成后，点击 Finish，也可勾选Run Intellij IDEA 再点击 Finish，会自动打开安装好的 IDEA
如果你想授权的话，可以看这篇文章-&gt;&gt;&gt; 授权教程，里面有详细的激活介绍
3、IDEA 2023使用 通过上面步骤，已经完美的弄好了idea，亲测到2026。其他版本也一样的，这里以最新版演示
点击 New Project，新建一个项目。或者open 打开本地项目
效果如下： 如此，甚好，hello，word！！！！！！！！！！！
IntelliJ IDEA 是一款跨平台的开发工具，支持 Windows、Mac、Linux 等操作系统
功能强大
①强大的整合能力。比如：Git Maven Spring等
②开箱即用的体验（集成版本控制系统，多语言支持的框架随时可用，无需额外安装插件）
✅符合人体工程学
①高度智能（快速的智能代码补全 实时代码分析 可靠的重构工具）
②提示功能的快速 便捷 范围广
③好用的快捷键和代码模板
④精准搜索
4、Java21 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98bca8ef676501ed191507d0eb1af449/" rel="bookmark">
			在win10环境下安装python，配置python环境，执行python脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装python 去python官网下载：
https://www.python.org/
这里采用 Python 3.10.8 版本
选择windows 64位
双击安装：
安装这里有两个选项：
1.默认安装直接选Install Now
2.勾选install launcher for all users（recommend），勾选此选项安装python后，该电脑下的所有用户都可以运行安装的python。
建议选第二种，第一种默认安装到c盘去了。因为后续我们还需要配置环境，所以选第二个目录，好记。
2.配置 配置系统环境变量：
设置-系统-关于-相关设置（高级系统设置）-环境变量，打开界面如下：
在系统变量下找到Path的变量如图；点击编辑，将其变量设为.exe安装目录下即可。
win+r，输入cmd，进入命令行窗口。
输入 python -v 查看版本
输入 where python 查看安装目录
3.win10如何执行python文件 新建py格式的脚本：
print("Hello World") 具体操作步骤：
1、在win10桌面中使用快捷键【win+r】打开运行窗口。
2、在运行窗口中输入“cmd”命令，打开终端命令行模式。
3、在命令行窗口中通过cd命令切换到python文件目录下。
4、最后根据以下命令格式执行python文件即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0530895985ee4d9367bb1965affb4194/" rel="bookmark">
			解决编译时提示“没有那个文件或目录 #include ＜pcap.h＞”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决编译时提示“没有那个文件或目录 #include 当你在编译代码时遇到“没有那个文件或目录 #include &lt;pcap.h&gt;”的错误提示，这通常意味着编译器在你的系统路径中找不到 pcap.h 头文件。pcap.h 是网络流量捕获库 pcap 的头文件，用于在 C/C++ 程序中捕获网络数据包。下面是一些解决这个问题的方法。
安装 pcap 库：
首先，确保你的系统上已经安装了 pcap 库。可以通过包管理器来安装，例如在 Ubuntu 上可以运行以下命令： sudo apt-get install libpcap-dev 在 CentOS 上可以使用：
sudo yum install pcap-devel 检查 pcap.h 的位置：
在安装 pcap 库之后，确认 pcap.h 头文件的位置。一般情况下，它应该位于 /usr/include 目录下。你可以使用以下命令来查找 pcap.h 文件的位置： find /usr -name pcap.h 确认路径是否正确：
确保在代码中使用 #include &lt;pcap.h&gt; 的时候，路径是正确的。如果 pcap.h 文件位于其他目录下，你需要使用正确的路径，例如： #include &lt;/usr/include/pcap.h&gt; 或者使用相对路径，相对路径是相对于你的代码文件所在的路径。
4. 设置环境变量：
如果 pcap.h 的位置不在标准路径下，你可以通过设置 C_INCLUDE_PATH 环境变量来指定额外的头文件搜索路径。在终端中执行以下命令：
export C_INCLUDE_PATH=/path/to/pcap.h:$C_INCLUDE_PATH 将 /path/to/pcap.h 替换为实际的 pcap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0530895985ee4d9367bb1965affb4194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf17ef549d156145d8a6447016ffdf53/" rel="bookmark">
			YOLO-V5分类实战系列 —— 调优自己的数据集&#43;RK1808部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLO-V5分类实战系列 —— 调优自己的数据集 1、保存训练和测试图片2、数据归一化3、数据增强3.1、数据增强库：albumentations3.2、数据增强库：torchvision 4、ONNX CPU 推理4.1、Pt 模型转为 ONNX4.2、ONNX 推理验证4.3、 ONNX CPU推理（C++） 5、RK 1808 部署5.1、查看模型输入、输出名字5.2、转换为RKNN模型5.3、C++ 芯片部署 6、调优策略6.1、数据标注6.2、数据清洗6.3、网络调优 1、保存训练和测试图片 问题1：训练过程中，如何保证训练集的数据增强和验证集的数据增强是基本一致的？
问题2：训练过程中，如何保证训练集和验证集的标签是正确的？
解决方法：训练测试过程中，保存训练图片和测试图片，并将标签画到图片可视化。
训练过程中，需要保证训练的数据预处理和测试的数据预处理保持一致，这一步还是很重要的，需要优先验证其一致性。常见的【预处理】包括：图片尺寸调整（resize，crop），色彩增强，空间变换（翻转，旋转等），归一化等。
下面的代码片段是数据读取的核心类，包括数据读取和数据增强。代码位置： 【utils/dataloaders.py】，并且需要在 def __init__() 中需要添加 self.augment = augment，保存图像的调用位置 def __getitem__() 中添加 self.save_images(f, sample)，下面代码都有添加（红色框内的代码） 训练和测试图片保存的代码片段如下，将其添加到类 ClassificationDataset 的成员函数即可。通过self.augment 判定是训练图片还是测试图片，进而对图片名字进行命名。保存的路径自己可以设置，
def save_images(self, f, sample): # 保存数据增强后的图片，用于对比训练和验证的图片预处理是否一致 print(' -------------self.augment: ', self.augment) if self.augment: print(' -------------f: ', f) a = f.split('/train/')[0]+'/train_aug/'+os.path.basename(f)[:-4]+'_train.jpg' print(' -------------a: ', a) torchvision.utils.save_image(sample, a) else: print(' -------------f: ', f) a = f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf17ef549d156145d8a6447016ffdf53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c09ab8e812bad673d72f14d560f7898/" rel="bookmark">
			前端界面网页截图(干货)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果可以实现记得点赞分享，谢谢老铁～ 看了一些谷歌插件，可以对网页进行局部截图或者是整个网页截图，于是想着弄个demo,关于前端的截图。最后选择了 html2canvas
1.下载安装包 Install NPM
npm install --save html2canvas 或者
Install Yarn
yarn add html2canvas 2.先看效果图 点击【局部截图】按钮可以自定义指定想要的位置点击【整个网页截图】按钮将整个网页截图 3.代码演示 vue文件
&lt;script setup lang="ts"&gt; import {onMounted,toRef } from "vue"; import html2canvas from "html2canvas"; let imgUrl: any = toRef('') // 生成快照 const convertToImage = (container, options?: any) =&gt; { // 设置放大倍数 const scale = window.devicePixelRatio; // 传入节点原始宽高 const _width = container.offsetWidth; const _height = container.offsetHeight; if(options){ let { width, height } = options; width = width || _width; height = height || _height; } // html2canvas配置项 const ops = { scale, // width, // height, useCORS: true, allowTaint: false, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c09ab8e812bad673d72f14d560f7898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773be0fe6af92acf58e851578072839c/" rel="bookmark">
			【自动化测试】Appium环境搭建与配置-详细步骤，一篇带你打通...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 1、Node.js环境搭建
1）下载msi安装包
官方网址：https://nodejs.org/en/
2）安装node.js
一路点击下一步即可，默认会自动添加path环境变量
3）验证是否安装成功
命令行模式下输入：node -v
4）验证npm是否安装成功
命令行模式下输入：npm -v
2、android下载与环境配置
Android sdk下载
1）sdk官网下载
地址：http://tools.android-studio.org/index.php/sdk
2）选择一个非中文目录，解压
Android组件下载
3）进入到android_sdk中，点击SDK Manerger.exe
4）勾选强制使用https://代替http://
5）选择最新的开发工具包下载
6）选择下载需要其他安卓版本的开发工具包（时间很长，耐心等待）
配置sdk环境变量
7）在系统变量中添加名称ANDROID_HOME
8）进入系统-高级设置-环境变量-系统变量-path-新建，添加上面的工具包路径：%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools;
9）在cmd命令输入android -h，检查是否配置成功
3、appium下载与环境配置
搭建appium1.8环境
1）官方下载地址：http://appium.io/
下载1.8.2版本
2）安装appium桌面软件
3）安装appium-doctor
Cmd命令行输入：npm install –g appium-doctor
4）使用appium-doctor检查appium环境是否安装好
Cmd命令行输入：appium-doctor
5）根据提示依次下载依赖
6）重新执行appium-doctor检查是否全部完好
7）启动appium
打开appium-desktop桌面图标，点击start server。
下面是我整理的2023年最全的软件测试工程师学习知识架构体系图 一、Python编程入门到精通 二、接口自动化项目实战 三、Web自动化项目实战 四、App自动化项目实战 五、一线大厂简历 六、测试开发DevOps体系 七、常用自动化测试工具 八、JMeter性能测试 九、总结（尾部小惊喜） 梦想是一种动力，它能够激发我们的潜能。勇敢地追求自己的梦想，不断超越自我，永不言败，最终就能够取得巨大的成功。
人生的意义在于不断地追求自己的梦想，不断地超越自我。要相信自己有无限的潜力和能力，只要坚持不懈地努力下去，就一定能够实现自己的梦想。
人生就像一场马拉松比赛，要想取得最终的胜利，就需要有决心、毅力和坚持不懈的精神。只要你勇敢地去追寻自己的梦想，就一定能够获得无比的成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/570269c1f2255aa8aee74e0c067004bd/" rel="bookmark">
			微信小程序uploader上传图片和表单数据至django后台存入MySQL数据库。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人小白一枚，最近想完成一个小程序界面，把上传的图片和表单一起传入后台，研究了一阵，现在把自己的体会分享一下，也当做笔记了。
1：wx.chooseMedia存入图片临时路径 首先，我们要把上传的图片路径存入wx.chooseMedia里（之前是wx.chooseImage，从基础库2.21.0开始，该接口停止维护，使用wx.chooseMedia代替）
参考链接：wx.chooseMedia(Object object) | 微信开放文档
下面展示我的页面：
wxml界面：这里定义了两个事件，uploadImg用于上传图片（就是把我们相册或者拍照的图片上传到界面上）然后存入到临时路径到时候和表单通过submit事件一起提交。
js界面：下面我们就要来完成具体事件的功能，完成uploadImg事件后上传的图片应该会显示在界面上显示出来可供我们浏览了。完成submit事件提交图片和表单。
uploadImg事件
2.wx.uploadFile上传图片和表单 参考链接：UploadTask | 微信开放文档
submit事件
这里我上网查看资料，有人说先用uploadFile把图片临时存放起来，然后用wx.request发起请求把表单和图片通过data属性提交。我试了一下，发现把图片上传后是字符串类型，因为data属性默认类型是string。后台能接受到这个参数，但是得不到具体数据内容。这使表单数据能存入数据库，但图片实体存入不了，只能存入字符串。而uploadFile能存入图片
数据库显示：
这里通过wx.request上传可能是我还没有悟到（应该是data属性格式转换有问题，或者是我django数据库字段类型定义有误，再或者是后台取数据有误，不能使图片存入数据库），使用request和uploadFile有几个地方有坑需要注意一下：
参考1：https://www.cnblogs.com/huangshuqiang/p/9907598.html
参考2：https://www.cnblogs.com/bosins/p/14783932.html
3.后端diango配置 因为我主要是想记录小程序内容，所以django就略过一下，还是会把所有代码和设计流程写下（详细就不说啦，自己也不是很会，怕误导家人们！！！）
首先要创建django项目、创建app文件、在settings.py中INSTALLED_APPS下写入创建的app文件名、配置图片存放路径、配置MySQL数据库、写视图文件、配置url地址。上面的基础搭建信息可以去找django大神的博客看。这里我就从配置图片存放路径开始噢。
在settings.py文件最下面配置图片存放路经：
MEDIA_ROOT = os.path.join(BASE_DIR, 'media') # 设置文件夹名 MEDIA_URL = '/media/' # url映射 在自己创建的app文件下的models.py文件中定义数据库字段（upload_to意思是把图片存入media文件夹下的photo文件夹下）：
from django.db import models class Company(models.Model): picture = models.ImageField(upload_to='photo', verbose_name='公司资质') title = models.CharField(max_length=50) number = models.CharField(max_length=50) time = models.DateTimeField(auto_now_add=True, editable=False) django连接MySQL数据库还要在__init__.py下定义，这样数据库才能连接成功。：
import pymysql pymysql.install_as_MySQLdb() 上面定义好后，就可以生成迁移文件（makemigrations）和数据迁移（migrate）了。迁移好之后就和mysql数据库连接好了：
django采用ORM（对象关系映射），也就是类对应MySQL的表，属性对应MySQL的字段。然后QuerySet（查询集）通过各种接口和字段使ORM达到跟SQL语句同样的表单能力！
接下来就编写views.py视图文件了：
from django.shortcuts import render from .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/570269c1f2255aa8aee74e0c067004bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b700047c28ec39ea0f8bdd49b040061b/" rel="bookmark">
			【成都医学院毕业论文】基于javaweb的美食交流分享平台的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：展示部分文档内容和系统截图，需要完整的视频、代码、文章和安装调试环境请私信up主。 4.4 数据库设计原则 学习程序设计，如果要了解数据库管理系统或者是根据需求而制定的系统接口，就必须创建一种数据库管理系统的模式，用来保存数据资料，这样当在应用编程过程中时候，就不需要再向操作系统页面上加载信息，进而增加了整个系统的工作效率。信息库管理系统中保存着许多数据，应该说是一个管理信息系统建设的中心和基础，而信息库管理系统也为管理信息系统建设提出了新增、删除、更改和搜索的操作功能，使管理信息系统建设能够迅速地查询所需要的数据，而不会直接从程序代码中查找。信息库管理系统通过将信息表的各个组成部分按照特定的方法准确地合并，排序和组成信息库管理系统。
通过对校园美食交流分享平台的主要功能信息进行规划并分为若干功能实体信息，实体信息将使用E-R图加以表示，本系统的主要功能实体图如下图所示。
4.5 数据表 把按照数据库理念建立的E-R图，转换为国际关系信息库。在关联数据库中，统计关联主要由统计表所构成，但是表的构成主要体现在表格的数文字段上。如下表所示。
表4-1收藏表
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
userid
bigint
用户id
refid
bigint
商品id
tablename
varchar
200
表名
name
varchar
200
名称
picture
longtext
1000
图片
type
varchar
200
类型
1
inteltype
varchar
200
推荐类型
remark
varchar
200
备注
表4-2美食资讯
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b700047c28ec39ea0f8bdd49b040061b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c34117c5947e660ee740ee588aeb1c/" rel="bookmark">
			Vue&#43;ElementUI技巧分享：自定义表单项label的文字提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要在表单项label后添加文字提示1. 使用 Slot 自定义 Label2. 添加问号图标与提示信息 slot的作用详解1. 基本用法2. 具名插槽 显示多行文字提示的方法1. 问题背景2. 实现多行内容显示3. 样式优化 结语 概要 在Vue和ElementUI的丰富组件库中，定制化表单是常见的需求之一。本文将分享一项实用技巧，即如何在表单项label后添加文字提示，以提升用户体验。我们将深入探讨Vue中slot的作用，并通过实战演示如何通过ElementUI的el-tooltip实现这一功能。
在表单项label后添加文字提示 1. 使用 Slot 自定义 Label 在 ElementUI 中，el-form-item 组件允许使用 slot 自定义 label。通过在 el-form-item 中添加 template 标签，我们可以在其中插入自定义的内容，并使用 slot="label" 来指定这一区域作为 label 的内容。
&lt;el-form-item label="扣款"&gt; &lt;template slot="label"&gt; &lt;span&gt;扣款 &lt;!-- 此处插入自定义内容，例如问号图标 --&gt; &lt;/span&gt; &lt;/template&gt; &lt;!-- 具体表单项的内容 --&gt; &lt;/el-form-item&gt; 2. 添加问号图标与提示信息 为了在 label 后添加问号图标并提供提示信息，我们使用了 el-tooltip 组件。以下是完整的代码片段：
&lt;el-form-item label="扣款"&gt; &lt;template slot="label"&gt; &lt;span&gt;扣款 &lt;el-tooltip class="item" effect="dark" content="客户对本单的扣款" placement="left"&gt; &lt;i class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07c34117c5947e660ee740ee588aeb1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/587cb9eb23565f3fb25c512d137e3d6f/" rel="bookmark">
			国内最受欢迎的电商API接口调用京东商品详情数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国内实用的API接口
国内最受欢迎的7大API供应平台对比和介绍
本文将介绍7款API供应平台：电商API数据、百度e、Apix、数说聚合、通联数据、HaoService、datasift 。排名不分先后！
免费实用的API接口
第一部分
1、电商数据（API数据接口_开发者数据定制）
2、百度API Store(API集市_APIStore)
3、webxml（确实不错）WebXml | WEB服务
第二部分
1、地图接口
阿里云根据经纬度获取地区名接口：
http://gc.ditu.aliyun.com/regeocoding?l=39.938133,116.395739&amp;type=001
阿里云根据地区名获取经纬度接口：
http://gc.ditu.aliyun.com/geocoding?a=苏州市
参数解释: 纬度,经度type 001 (100代表道路，010代表POI，001代表门址，111可以同时显示前三项)
2、查ip接口
太平洋接口
太平洋网络IP地址查询Web接口
淘宝接口
http://ip.taobao.com/service/getIpInfo.php?ip=117.89.35.58
新浪接口
http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=117.89.35.58
3、电商接口
京东 商品接口
http://p.3.cn/prices/mgets?skuIds=J_商品ID&amp;type=1
4、音乐接口
豆瓣音乐　http://www.douban.com/j/app/radio/channels
百度音乐　http://box.zhangmen.baidu.com/x?op=12&amp;count=1&amp;title=歌名$$歌
虾米　http://kuang.xiami.com/app/nineteen/search/key/歌曲名称/diandian/1/page/歌曲当前页?_=当前毫秒&amp;callback=getXiamiData
QQ空间音乐　http://qzone-music.qq.com/fcg-bin/cgi_playlist_xml.fcg?uin=QQ号码&amp;json=1&amp;g_tk=1916754934
多米音乐 http://v5.pc.duomi.com/search-ajaxsearch-searchall?kw=关键字&amp;pi=页码&amp;pz=每页音乐数
5、翻译、词典接口
腾讯：
http://dict.qq.com/dict?q=词语
有道翻译：
有道翻译API
爱词霸：
http://dict-co.iciba.com/search.php?word=词语&amp;submit=提交
5、酒店住宿接口
住哪网开放平台
6、腾讯qq相关的接口
API列表 - 腾讯开放平台
第三部分
Github上别人的收集（包括国内与国外）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43578fb2f708deb7b747cd9c3791410d/" rel="bookmark">
			Python爬虫--获取POI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、爬虫简介 爬虫是一种自动化获取互联网信息的程序。通过模拟人类浏览器行为，自动抓取网页上的数据，并进行处理和分析。他能够获取常规的网页HTML源代码，CSS、JavaScript文件，图片、视频等二进制文件，还有很多API接口类的信息像JSON类信息等。
二、如何通过python获取POI POI表示某个地理位置周边的信息。本文使用高德地图api，以获取广东财经大学周边5000米范围内的粤菜馆为例进行阐述。
（声明：本人非计算机相关专业，编程基础也寥寥无几，文章仅是作为选修课学习内容和个人爱好，分享和记录学习过程。）
具体流程主要分为三步：
1.获取所需网页信息
2.将信息进行解析、提取 3.将数据保存为自己想要的格式。
（一）获取所需网页信息。 这里我也将其分为三小步：首先确定广财的具体位置，其次获取地点信息，最后对其进行周边搜索，获取网页信息。
1.确定具体位置 要获得广财大周边信息，首先我们要确认广财大的具体位置，这里有两种方法。
方法一：利用高德地图拾取器确认其坐标位置。
网址如下：
高德地图APIhttps://lbs.amap.com/tools/picker*温馨提示：如果只是作为游客查询，查询地点的坐标精度只有两位数，其实是不够精确的。将”按关键字搜索“获取到的广财大的坐标重新输入”按坐标搜索“，会发现显示出的地址与原来想要查询的有偏差。如图所示：
这里只要在高德地图进行登录及认证，就可以获得更精确的坐标了。
结果如图所示，可以精确到小数点后六位：
方法二：关键字搜索POI
高德地图为我们提供了搜索POI功能，能够通过文本关键字搜索想要的地点信息。
具体步骤如下：
第一步，申请wed服务api类型key。
点击高德地图api控制台—管理应用—我的应用
创建新应用-添加key
这里服务平台选web服务
所需key创建完成
第二步，发起请求。
我们通过高德地图关键字搜索api提供的url访问地点信息，代码如下：
（URL是对互联网上得到的资源的位置和访问方法的一种简洁表示，是互联网上标准资源的地址。）
https://restapi.amap.com/v5/place/text?parameters
其中parameters替换为图中所示必填的参数key和keywords（或types）
在本文例子下完整代码如下：
https://restapi.amap.com/v5/place/text?key=48a31ebd6dd0a05b15b97f23393f7895（这里换成自己创建的key）&amp;keyword=广东财经大学
(用&amp;连接各个参数)
写好之后可以将url输入浏览器，可以访问一个包含广财大的地址信息的json文件，如下图所示。同时可以通过此检查url是否正确。
到这里我们获得了广财大的坐标信息就足够了，不用进行第三步，到后面获取我们想要的周边粤菜馆信息时候再进行解析即可。
2.获取周边信息
这里和上一步步骤几乎相同，不过多赘述，这里几个参数进行解释：
types：由于我们要查询的是粤菜馆，所以必须要填写参数types作为制定类型。types的规则说明中有“POI分类码表”excel表。可以查询想要的地点类型。这里types=050103,如果需要查询多个类型，用|将代码隔开。
radius、page_size和page_num:分别表示要搜索的半径范围，每页25条数据，第几页。这些参数也可以不填，则默认为缺省值
此步url为：
https://restapi.amap.com/v5/place/around?key= 48a31ebd6dd0a05b15b97f23393f7895（这里换成自己创建的key）&amp;types=05103&amp;location=113.354053,23.090164&amp;radius=5000&amp;page_size=25&amp;page_num=1
访问结果如图：
到这里我们已经以json文件的形式获得到我们想要的信息了，但看起来并不整齐直观，接下来我们需要将它解析出来。
（二）将信息进行解析、提取 这里我们用python对所获得的json文件进行解析、提取。
需要用到几个库：
requests，请求访问json文件
pandas，用于存储、处理数据
openpyxl，将数据导入excel
代码如下（按自己理解写的注释，可能解释的不专业）：
*最后导入的excel表格需要自己先创建好，再将路径写入代码。
（三）将数据保存为自己想要的格式 这里我们将数据保存在excel中，结果如图所示：
以上为本案例所有过程，希望大家批评指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2bd863251f1892c921397c6d5b15c54/" rel="bookmark">
			时间序列预测之卷积神经网络CNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前期准备1.1 引入库1.2 读取数据1.3 可视化 2 数据预处理2.1 划分训练集、测试集2.2 划分特征与标签 3 构建一维卷积神经网络4 训练模型4.1 划分batch4.2 设置损失函数4.3 参数初始化4.4 训练模型 5 模型结果5.1 损失函数曲线5.2 测试集的真实值与预测值曲线 1 前期准备 1.1 引入库 import numpy as np import pandas as pd import torch.nn as nn #用于构建网络 import torch import matplotlib.pyplot as plt import torch.nn.functional as F torch.set_default_tensor_type(torch.DoubleTensor) #将tensor的默认类型设置为双精度浮点类型（torch.doubletensor），便于反向传播 1.2 读取数据 本文选取了每月太阳黑子数据集，该数据集描述了1749年1月至2023 年10月观测到的太阳黑子数量的月度计数。
数据网址如下（也可以关注并私信博主来获取数据集）：
http://www.sidc.be/silso/datafiles
Data=pd.read_csv("E:\\代码学习\\CSDN博客\\CNN\\SN_m.csv") start_time=pd.to_datetime("1749-01-01") end_time=pd.to_datetime("2023-11-01") time=pd.date_range(start=start_time,end=end_time,freq='M')#生成时间序列 Data['time']=time #将时间设为索引 data=Data.set_index('time',drop=True, append=False, inplace=False, verify_integrity=False) series=np.array(data['Sunspots']) 1.3 可视化 从图中可以看出该数据集有很强的的季节性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2bd863251f1892c921397c6d5b15c54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e2bb0d1f792db7d7d4f8617528903b2/" rel="bookmark">
			iOS学习 --- Xcode 15 下载iOS_17.0.1_Simulator失败解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.去开发者官网下载安装包 https://developer.apple.com/download/all/?q=iOS%2017 使用浏览器下载。
2.打开终端通过命令添加到xcode
命令如下：
sudo xcode-select -s /Applications/Xcode.app(输入开始密码)xcodebuild -runFirstLaunch (等待一小会)xcrun simctl runtime add "/Users/xxxxx/Downloads/iOS_17.0.1_Simulator_Runtime.dmg" 3.执行完毕后，到xcode 快捷键 command + ， 查看安装是否成功，如下图证明安装成功
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/69/">«</a>
	<span class="pagination__item pagination__item--current">70/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/71/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>