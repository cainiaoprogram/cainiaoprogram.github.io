<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93bebd7c5b655a99d459cebdae921694/" rel="bookmark">
			javaweb环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统以及工具版本号
操作系统：Windows 10
Tomcat：9.0
Eclipse IDE for Enterprise Java Developers Version: 2020-12 (4.18.0)
搭建过程
安装 JDK
运行安装程序：
等待程序运行：
弹出java安装窗口：
等待程序运行
安装完成
配置环境变量
新建JAVA_HOME变量
新建ClassPath变量
编辑path变量
验证JDK配置成功
安装Tomcat
下载
进入 Tomcat 官网：http://tomcat.apache.org/
安装
期间一直点next，以及agree即可
点击 finish 运行 Tomcat。
验证安装成功
打开浏览器输出 localhost:8080 ，显示如下即安装成功。
安装Eclipse
下载安装包，并运行
更改安装目录
点击eccept now
耐心等待安装
点击accept
安装完成，点击launch
Eclipse配置javaweb环境
应用并关闭
创建javaweb项目
接着next直到下图，勾选上箭头所指选项，finish
创建一个html文件
填写文件名，点击next
点击finish
创建server
添加项目到server
运行项目
右键项目名，点击Run As-&gt;Run on Server
点击next
点击finish
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d87b27ea5bdd4d4f2468445c744d5c/" rel="bookmark">
			【论文】解读Deep Neural Networks for Learning Graph Representations
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deep Neural Networks for Learning Graph Representations 摘要 本文提出了一个新颖的学习图表示的模型，它可以对每个节点通过抓取图结构信息得到一个低维的向量表示。不同于前任的研究，我们采用一个‘随机冲浪模型’(random surfing model)去直接抓取结构信息，而不是使用Perozzi等人提出的基于采样方法的生成的线性序列。我们方法的优势将从理论和经验的角度来说明。
我们还为Levy和Goldberg (2014)提出的矩阵分解方法提供了一个新的视角，其中点互信息(PMI)矩阵(pointwise mutual information matrix)被认为是Mikolov等人(2013)提出的负采样’skip-gram model’的目标函数的解析解.与他们使用SVD从PMI矩阵中找到低维投影的方法不同，我们的模型中引入了堆叠的去噪自动编码器(the stacked denoising autoencoder)来提取复杂特征和模型非线性性。
为了证明我们的模型的有效性，我们在聚类和可视化任务上进行实验，使用所学的顶点表示作为特征。在不同规模数据集上的实验结果表明，我们的模型在此类任务中优于其他最新模型。
1 Introduction 图形是许多现实问题中用于信息管理的常见表示。例如，在蛋白质网络研究中，从蛋白质-蛋白质相互作用网络中挖掘蛋白质复合物在描述同源蛋白质的功能多样性方面起着重要作用，并提供有价值的进化见解，这本质上是一个聚类问题。因此，开发自动算法从图形中提取有用的深层信息至关重要。组织与潜在的大而复杂的图相关联的这种信息的有效手段之一是学习图表示，其将低维密集向量表示分配给图的每个顶点，编码由图传达的有意义的信息
（前略）虽然已经确定了学习线性结构的良好表示的高效且有效的方法，处理具有丰富拓扑结构的图结构更加复杂。为此，一种自然的方法是确定有效的方法，将学习图结构的顶点表示的任务转化为从线性结构学习表示的任务。Perozzi等人(2014)提出的🐸DeepWalk提出了一种通过截断随机游走(truncated random walk)的均匀采样的方法将未加权图转换成线性序列集合的思想。在他们的方法中，采样顶点序列(sampled vertex sequences)描绘了图中顶点之间的连接的特征。这一步可以理解为将一般的图形结构转换成大量线性结构集合的过程。接下来，他们利用Mikolov等人(2013)提出的🐸skip-gram model从这种线性结构中学习顶点的低维表示。学习的顶点表示在一些任务中是有效的，优于以前的一些方法，如谱聚类和模块化方法。
思考：虽然这种学习未加权图的顶点表示的方法是有效的，但仍有两个重要问题有待解决。第一，对于加权图，如何更准确、更直接地捕捉图的结构信息？第二，有没有更好的表示线性结构顶点的方法？
为了回答第一个问题，我们设计了一个适用于加权图的随机冲浪模型，它可以直接产生一个概率共现矩阵(probailistic co-occurrence matrix)。这种矩阵类似于通过从图中采样线性序列获得的共生矩阵(co-occurrence matrix)，但是在我们的方法中不需要采样过程。
为了回答第二个问题，我们首先重温一种用于学习线性结构的顶点表示的流行的现有方法。Levy and Goldberg(2014)最近的一项研究表明，使用负采样方法优化与skip-gram相关的目标函数与分解单词及其上下文的正点互信息(positive pointwise mutual information)(PPMI)矩阵有内在联系。具体来说，他们表明可以使用标准奇异值分解(SVD)方法来分解PPMI矩阵，以从分解的矩阵中归纳出顶点(单词)表示。我们最近的方法被称为😏GraRep已被证明在学习图形表示的任务上取得了良好的实证结果。然而，该方法采用奇异值分解进行线性降维，而没有探索更好的非线性降维技术。
本文对Levy and Goldberg(2014)的工作给予了新的视角。我们认为，原始PPMI矩阵本身是图的显式表示矩阵，奇异值分解步骤本质上起到了降维工具箱的作用。虽然诱导最终单词表示的奇异值分解步骤被证明是有效的，但Levy等人(2015)也证明了使用PPMI矩阵自身作为单词表示的有效性。有趣的是，如作者所示，从奇异值分解方法中获得的表示不能完全优于PPMI矩阵本身的表示(Levy，Goldberg和Dagan2015)。由于我们的最终目标是有效捕捉图形信息的顶点表示，因此有必要研究从PPMI矩阵中恢复顶点表示的更好方法，其中可以捕捉不同顶点之间潜在的复杂非线性关系。
深度学习揭示了非线性复杂现象建模的途径，在不同领域有许多成功的应用，如语音识别(Dahl等人，2012年)和计算机视觉(Krizhevsky，Sutskever，和Hinton，2012年)。深度神经网络(DNN)，例如堆叠式自动编码器，可被视为从低级特征学习高级抽象的有效方法。这个过程本质上执行降维，将数据从高维空间映射到低维空间。与(截断的)基于奇异值分解的降维方法不同，基于奇异值分解的降维方法通过线性投影从原始表示空间映射到具有较低秩的新空间，深度神经网络(如堆叠自动编码器)可以学习高度非线性的投影。事实上，Tian等人(2014)最近的工作在聚类任务中使用稀疏自动编码器来代替谱聚类的特征值分解步骤，并且他们实现了显著的改进。受他们工作的启发，我们还研究了使用基于深度学习的替代方法从原始数据表示中学习低维表示的有效性。与他们的工作不同，我们的目标是学习一般图的顶点表示，而不是专门关注聚类任务。我们将深度学习方法应用于PPMI矩阵，而不是他们模型中使用的拉普拉斯矩阵。前者已被证明有潜力产生比后者更好的代表性(佩罗齐，阿尔福和斯基纳，2014年)。为了增强我们的模型的鲁棒性，我们还使用堆叠去噪自动编码器来学习多层表示。
称我们提出的模型为DNGR(deep neural networks for graph representations)。学习的表示可以被视为输入特征，其可以被馈送到其他任务，例如无监督聚类和有监督分类任务。为了验证我们模型的有效性，我们进行了实验，将学习到的表示用于一系列不同的任务，其中考虑了不同风格和拓扑的真实世界网络。为了进一步证明我们的模型在考虑更简单、更大规模的实际图形结构时的有效性，我们在一个非常大的语言数据集上应用了我们的算法，并在单词相似性任务上进行了实验。在所有这些任务中，我们的模型优于其他学习图形表示的方法，并且我们的模型也是可并行的。我们的主要贡献有两个方面:
理论上，我们认为深度神经网络提供了能够捕获由图形传达的非线性信息的优势，而这种信息不容易被许多广泛使用的传统线性降维方法捕获。此外，我们认为我们的随机冲浪模型可以用来取代广泛使用的传统的基于抽样的方法来收集图形信息。根据经验，我们证明了我们的新模型能够更好地学习加权图的低维顶点表示，其中可以捕获图的有意义的语义、关系和结构信息。我们表明，所得到的表示可以有效地用作不同下游任务的特征。 2 Background and Related Work 在这一节中，我们首先介绍了DeepWalk中提出的未加权图的随机采样，以说明将顶点表示转换为线性表示的可行性。接下来，我们考虑两种单词表示方法:负采样skip-gram和基于PPMI矩阵的矩阵分解。这些方法可以被视为从线性结构数据中学习单词表示的线性方法。
Notation给定一个加权图 G = &lt; V , E &gt; G=&lt;V,E&gt; G=&lt;V,E&gt;,where V = { v 1 , v 2 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3d87b27ea5bdd4d4f2468445c744d5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8775d850817e3f1dfab0451efa7da4f5/" rel="bookmark">
			新浪微博开放平台第三方登陆请求授权出现错误码：21322(重定向地址不匹配)的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、在【我的应用】-【应用信息】-【高级信息】中设置回调地址 2、在跳转至引导页的url中填写在【高级信息】中设置的回调地址 redirect_uri=http://gulimall.com/success
https://api.weibo.com/oauth2/authorize?client_id=3847135515&amp;response_type=code&amp;redirect_uri=http://gulimall.com/success 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d19694ebaa5195c6967453c639ae0a0/" rel="bookmark">
			Eclipse创建maven-archetype-quickstart项目报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
问题
在创建maven-archetype-quickstart时出现以下报错
解决方案
一、配置本地和远程maven仓库
二、在本地maven库中装载maven-archetype-quickstart
三、eclipse修改本地Maven仓库地址
四、查看是否配置成功
配置结束
至此可以新建maven-archetype-quickstart项目了
问题
在创建maven-archetype-quickstart时出现以下报错
解决方案
※如果已有本地Maven请从解决方案步骤（二）开始即可
一、配置本地和远程maven仓库
1、下载maven安装包
网址：http://maven.apache.org/download.cgi
2、安装包解压
3、配置环境变量
此电脑（右键）-&gt; 属性 -&gt; 高级系统设置 -&gt; path（双击）-&gt; 编辑文本
（其实这样配置是偷懒的行为，我实在太懒了…如果你勤快一点可以去新建系统变量哟）
4、验证是否配置成功
Win+r输入cmd，输入mvn -n命令
5、配置maven本地仓库和远程仓库
E盘下新建文件夹：apache-maven-3.6.3-repos（目前是空文件夹，起什么名字都可以）
修改setting.xml文件中的本地仓库地址
&lt;!--本地仓库地址，此行不需要复制--&gt;
&lt;localRepository&gt;E:\apache-maven-3.6.3-repos&lt;/localRepository&gt;
&lt;!--配置远程maven仓库，依旧是本人比较懒，就一同配置了，如果你勤快的话，可以在配置成功本地maven后再来配置，然后重新运行下面的6步骤--&gt;
&lt;mirror&gt;
&lt;id&gt;alimaven&lt;/id&gt;
&lt;name&gt;aliyun maven&lt;/name&gt;
&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
&lt;/mirror&gt;
6、验证配置是否成功
Win+r输入cmd，输入mvn help:system命令
出现BUILD SUCCESS即为成功
（我这个是在做完的基础上重新运行的，所以时间可能会显示的稍微快一点）
7、查看刚刚新建的空文件夹apache-maven-3.6.3-repos是否多出了许多文件
二、在本地maven库中装载maven-archetype-quickstart
（我之前找到的教程都是maven-archetype-quickstart-1.1jar包，恕我无能我没找到o(╥﹏╥)o，后来在阿里仓库下的1.4）
1、下载maven-archetype-quickstart-1.4.jar文件
网址：https://maven.aliyun.com/mvn/search
2、将其放入本地maven的lib文件夹中
E:\apache-maven-3.6.3\lib
3、在lib目录下输入cmd，直接在命令行进入此文件夹
输入命令：
mvn install:install-file -DgroupId=org.apache.maven.archetypes -DartifactId=maven-archetype-quickstart -Dversion=1.4 -Dpackaging=jar -Dfile=maven-archetype-quickstart-1.4.jar
（如果你的版本不是1.4，要注意把上面的1.4换成你所下载的版本号）
三、eclipse修改本地Maven仓库地址
1、Window -&gt; Preferences -&gt; Maven -&gt; User Settings，在Global Setting中选择setting文件所在位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d19694ebaa5195c6967453c639ae0a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a12a10396f543e9d2d1c8f53c2a6052/" rel="bookmark">
			ubuntu使用qt时QIODevice::ReadWrite串口打开失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开串口时：老是进入“if(!m_serialPort-&gt;open(QIODevice::ReadWrite))”
if(!m_serialPort-&gt;open(QIODevice::ReadWrite))//用ReadWrite 的模式尝试打开串口 { qDebug()&lt;&lt;"打开失败!"; ui-&gt;textEdit-&gt;append("send$:QIODevice::ReadWrite打开失败!"); } 但是能进入“if(m_serialPort-&gt;isOpen())”
if(m_serialPort-&gt;isOpen()) { ui-&gt;textEdit-&gt;append("send$:isOpen打开成功!"); } 意思是串口是打开了，但是“QIODevice::ReadWrite”模式是没有打开的
在实际操作时发现，虽然QIODevice::ReadWrite”模式是没有打开，但是能正常通信（能读能写）
（通过无线数传将数据65发出去，然后另一台设备把接收到的数据传回来）
如果你也遇到“QIODevice::ReadWrite”打开失败的问题也可以先试一下读写功能，说不定也是好使的呢。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8469897dc02595faf271bad7c66dd4a9/" rel="bookmark">
			推荐一个开源文件管理系统，简单好用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是为广大程序员兄弟操碎了心的小编，每天推荐一个小工具/源码，装满你的收藏夹，每天分享一个小技巧，让你轻松节省开发效率，实现不加班不熬夜不掉头发，是我的目标！
今天小编推荐一个开源文件管理系统：基于 SpringBoot2.x + MyBatisPlus + MySQL + Shiro+ Layui 等搭配七牛云，阿里云OSS实现的云存储管理系统。包含文件上传、删除、预览、云资源列表查询、下载、文件移动、重命名、目录管理、登录、注册、以及权限控制等功能。
开源协议 使用 Apache-2.0 开源许可协议
链接地址 公众号【Github导航站】回复关键词【ffs】获取git地址
技术栈 后端：
Spring Boot 2.4.3orm: MyBatis Plus数据库：MySQL 5.7权限安全控制：shiro本地缓存：ehcache文件上传：七牛云 阿里云OSS 前端：
ThymeleafLayui v2.5.5JqueryAjax 演示截图 登录页
注册页
主页
资源操作
目录管理
重命名
添加文件夹
移动文件或目录
删除文件
结尾 本期就分享到这里，我是小编南风吹，专注分享好玩有趣、新奇、实用的开源项目及开发者工具、学习资源！希望能与大家共同学习交流，欢迎关注我的公众号**【Github导航站】**。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f863e69ff806a1df613af4d42f0bc63b/" rel="bookmark">
			嵌入式Linux开发  多线程的并发性————多线程存在延时函数和不存在延时函数运行结果不同的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程的并发性————多线程存在延时函数和不存在延时函数运行结果不同的原因 今天继续学习了linux应用程序开发有关线程的知识，主要学的是线程同步互斥，内容是互斥锁(mutex)和信号量(sem)。在学习的过程中发现了一个问题，让我产生疑惑，当我们在线程函数体中写延时函数和不写延时函数最终程序运行的结果是完全不同的，主要原因就是多线程的并发性，通过以下这个程序举例。
先在线程函数体中添加一秒钟的延时函数看一下运行效果
然后将延时函数屏蔽，屏蔽后在运行看结果
分析: 只是因为一秒的延时函数，程序运行结果却相差很大，在程序中两个线程共用一块资源。当不存在延时函数的时候，cpu一般会先执行完一个线程再去执行另外的一个线程。但是当存在延时函数的时候，cpu就会有时间去执行其他的线程。话这样说没毛病，可是为什么cpu不乖乖的等着呢，主要原因还是多线程的并发性。并发性指的是在一个核上也就是只有一个cpu在进行数据处理工作，cpu会周期性的执行这些工作，这就好像你在跑400米，跑了一圈又一圈，周而复始的跑。通过下面这个图可能会更直观一些，我们日常生活中电脑会运行很多的软件，但是cpu不是同时运行他们的，而是在一个很短的周期内依次循环执行这些软件，cpu好像在围绕这个圈跑，跑到哪运行哪一个。理解了这个概念以后忽然明白了，为什么有无延时函数结果差异这大，无延时函数的时候，cpu之所以先执行完一个线程再去顺序执行另一个的原因是，执行一个线程所需要时间太短了，cpu只需要跑动一个周期的特别少的一部分就可以完成，所以就顺序执行下来了。然而存在延时函数，在延时函数的过程中，cpu又继续的向下跑了很远，具体是到了下一个线程还是跑过一个周期又回到我们当前这个线程就看缘分了，所以有延时函数时出现的效果不是顺序执行的效果，而且每运行完依次含延时函数的程序最终的结果都是不一样。但是也不是绝对的，如果我们某个线程的函数体特别大运行时间特别长，占用cpu时间多了，这时候即使没有延时函数的存在，cpu也可能去执行其他的线程，这个点是需要注意的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5bea7d3b86f13518344e484500f5bc8/" rel="bookmark">
			空间注意力机制和通道注意力机制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Attention机制在近几年来在图像，自然语言处理等领域中都取得了重要的突破，被证明有益于提高模型的性能。
Attention机制本身也是符合人脑和人眼的感知机制，这次我们主要以计算机视觉领域为例，讲述Attention机制的原理，应用以及模型的发展。
何为Attention机制？ 所谓Attention机制，便是聚焦于局部信息的机制，比如，图像中的某一个图像区域。随着任务的变化，注意力区域往往会发生变化。
面对上面这样的一张图，如果你只是从整体来看，只看到了很多人头，但是你拉近一个一个仔细看就了不得了，都是天才科学家。
图中除了人脸之外的信息其实都是无用的，也做不了什么任务，Attention机制便是要找到这些最有用的信息，可以想到，最简单的场景就是从照片中检测人脸了。
基于Attention的显著目标检测 和注意力机制相伴而生的一个任务便是显著目标检测，即salient object detection。它的输入是一张图，输出是一张概率图，概率越大的地方，代表是图像中重要目标的概率越大，即人眼关注的重点，一个典型的显著图如下：
右图就是左图的显著图，在头部位置概率最大，另外腿部，尾巴也有较大概率，这就是图中真正有用的信息。
显著目标检测需要一个数据集，而这样的数据集的收集便是通过追踪多个实验者的眼球在一定时间内的注意力方向进行平均得到，典型的步骤如下：
(1) 让被测试者观察图。
(2) 用eye tracker记录眼睛的注意力位置。
(3) 对所有测试者的注意力位置使用高斯滤波进行综合。
(4) 结果以0～1的概率进行记录。
于是就能得到下面这样的图，第二行是眼球追踪结果，第三行就是显著目标概率图。
上面讲述的都是空间上的注意力机制，即关注的是不同空间位置，而在CNN结构中，还有不同的特征通道，因此不同特征通道也有类似的原理 ，下面一起讲述。
Attention模型架构 注意力机制的本质就是定位到感兴趣的信息，抑制无用信息，结果通常都是以概率图或者概率特征向量的形式展示，从原理上来说，主要分为空间注意力模型，通道注意力模型，空间和通道混合注意力模型三种，这里不区分soft和hard attention。
1.空间注意力模型(spatial attention) 不是图像中所有的区域对任务的贡献都是同样重要的，只有任务相关的区域才是需要关心的，比如分类任务的主体，空间注意力模型就是寻找网络中最重要的部位进行处理。
我们在这里给大家介绍两个具有代表性的模型，第一个就是Google DeepMind提出的STN网络(Spatial Transformer Network[1])，它通过学习输入的形变，从而完成适合任务的预处理操作，是一种基于空间的Attention模型，网络结构如下：
这里的Localization Net用于生成仿射变换系数，输入是C×H×W维的图像，输出是一个空间变换系数，它的大小根据要学习的变换类型而定，如果是仿射变换，则是一个6维向量。
这样的一个网络要完成的效果如下图：
即定位到目标的位置，然后进行旋转等操作，使得输入样本更加容易学习。这是一种一步调整的解决方案，当然还有很多迭代调整的方案，感兴趣可以去有三知识星球星球中阅读。
相比于Spatial Transformer Networks 一步完成目标的定位和仿射变换调整，Dynamic Capacity Networks[2]则采用了两个子网络，分别是低性能的子网络(coarse model)和高性能的子网络(fine model)。
低性能的子网络(coarse model)用于对全图进行处理，定位感兴趣区域，如下图中的操作fc。高性能的子网络(fine model)则对感兴趣区域进行精细化处理，如下图的操作ff。两者共同使用，可以获得更低的计算代价和更高的精度。
由于在大部分情况下我们感兴趣的区域只是图像中的一小部分，因此空间注意力的本质就是定位目标并进行一些变换或者获取权重。 2 通道注意力机制 对于输入2维图像的CNN来说，一个维度是图像的尺度空间，即长宽，另一个维度就是通道，因此基于通道的Attention也是很常用的机制。
SENet(Sequeeze and Excitation Net)[3]是2017届ImageNet分类比赛的冠军网络，本质上是一个基于通道的Attention模型，它通过建模各个特征通道的重要程度，然后针对不同的任务增强或者抑制不同的通道，原理图如下。
在正常的卷积操作后分出了一个旁路分支，首先进行Squeeze操作(即图中Fsq(·))，它将空间维度进行特征压缩，即每个二维的特征图变成一个实数，相当于具有全局感受野的池化操作，特征通道数不变。
然后是Excitation操作(即图中的Fex(·))，它通过参数w为每个特征通道生成权重，w被学习用来显式地建模特征通道间的相关性。在文章中，使用了一个2层bottleneck结构(先降维再升维)的全连接层+Sigmoid函数来实现。
得到了每一个特征通道的权重之后，就将该权重应用于原来的每个特征通道，基于特定的任务，就可以学习到不同通道的重要性。
将其机制应用于若干基准模型，在增加少量计算量的情况下，获得了更明显的性能提升。作为一种通用的设计思想，它可以被用于任何现有网络，具有较强的实践意义。而后SKNet[4]等方法将这样的通道加权的思想和Inception中的多分支网络结构进行结合，也实现了性能的提升。
通道注意力机制的本质，在于建模了各个特征之间的重要性，对于不同的任务可以根据输入进行特征分配，简单而有效。
3 空间和通道注意力机制的融合 前述的Dynamic Capacity Network是从空间维度进行Attention，SENet是从通道维度进行Attention，自然也可以同时使用空间Attention和通道Attention机制。
CBAM(Convolutional Block Attention Module)[5]是其中的代表性网络，结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5bea7d3b86f13518344e484500f5bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a110c5705a4b56435e69c15b9740bdc8/" rel="bookmark">
			filezilla里怎么解决中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		filezilla里怎么解决中文乱码问题 使用Filezilla client FTP客户端登陆某些FTP站点会出现中文乱码,原因是FTP服务器端编码与filezilla client端编码不一致造成的，解决方法如下：
文件-站点管理-选中要登陆的站点-字符集-选择”强制UTF-8″ 或使用自定义字符集GB2312,二者之一定能解决中文显示乱码的问题
1、首先打开FileZilla软件进入到软件主窗口后，连接FTP站点。
2、FTP连接后，点击上方菜单栏的“文件”选项，在下拉菜单中点击“添加当前连接到站点管理器”。
3、然后在弹出的“站点管理器”窗口中，在左侧选择“新站点”，右侧切换到“字符集”选项卡后，勾选“使用自定义的字符集 ”并将编码设置为“gb2312”即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4777f450e29eca16d5e619726f4179/" rel="bookmark">
			postman &#43;Jenkins 接口自动化实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装postman；
2.collections中创建文件夹A，标题最好使用英文，添加要测试的接口到该文件夹中；
如果接口太多，但域名大多重复，可以右击文件夹A=》edit=》Variables，设置域名，设置variable值，此时接口url可以用如下链接代替
{{weather}}/WeatherWS.asmx/getRegionDataset? （weather即是variable的值），这样后面如果有服务器迁移，接口域名变更会方便很多；
3.接口调试：调试接口，可以正常获取数据； 增加断言，Tests中输入类似的代码（里面对应的数据需要修改为测试时的接口数据）：
pm.test("status code is 200",function(){ pm.response.to.have.status(200)}) pm.test("接口响应时间小于200ms",function(){ pm.expect(pm.response.responseTime).to.be.below(200)}) pm.test("响应数据检查",function(){ pm.expect(pm.response.text()).to.be.include("广东")}) 如果有全局变量或数据依赖，增加全局变量或数据依赖，同样在Tests中输入类似的代码：
var jsonObject = xml2Json(responseBody); var code = jsonObject.ArrayOfString.string[0].split(',')[1] tests["get one citycode"] = code pm.globals.set("citycode",code); 调用全局变量如下图所示：
4. 用Runner可以调试运行文件夹中所有接口；
鼠标右击文件夹=》export（导出文件夹中所有接口数据，生成一个json文件）； 如果有全局变量，再导出全局变量（仍是一个json文件），具体步骤如下图（点击postman右上角manage environments按钮）；
5.安装node，成功后安装newman（npm install -g newman），再安装newman-reporter-html（npm install -g newman-reporter-html）
cmd下执行代码（代码意义：执行postman接口生成的json文件（有globals变量时加上对应的json文件），生成一个html的报告并放在设置的路径中）：
注意：下方json文件及html文件的路径是我自己存放的文件路径，大家执行时需换成你们自己的路径，路径最好不要直接放在C、D、E盘中，最好放在子文件夹中；
newman run "E:\weather\WeatherPro.postman_collection.json" -g "E:\weather\Workspace.postman_globals.json" --reporters html --reporter-html-export E:\weather\demo.html 6.（Jenkins安装及构建大家额外学习，该文章不做太多描述）Jenkins中构建自由风格的任务（每天定时跑任务需选择“Build periodically“），再在Execute Windows batch command 中写入步骤5中执行的代码newman run "E:\weather\WeatherPro.postman_collection.json" -g "E:\weather\Workspace.postman_globals.json" --reporters html --reporter-html-export E:\weather\demo.html，保存并执行（build now）该任务；如果执行报错，则在Manage Jenkins=》Manage Nodes and Clouds=》master右侧设置按钮，增加path变量键：PATH 值：D:\program\nodejs;C:\Users\Administrator\AppData\Roaming\npm（npm路径可执行npm config get prefix查看）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f4777f450e29eca16d5e619726f4179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5bcc7f7cdc464b557c731cdafeb0e3/" rel="bookmark">
			Python3 条件控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python3 条件控制 Python 条件语句是通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块。可以通过下图来简单了解条件语句的执行过程:
代码执行过程：
if 语句
Python中if语句的一般形式如下所示：
if condition_1: statement_block_1 elif condition_2: statement_block_2 else: statement_block_3 如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句
如果 “condition_1” 为False，将判断 “condition_2”
如果"condition_2" 为 True 将执行 “statement_block_2” 块语句
如果 “condition_2” 为False，将执行"statement_block_3"块语句
Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else。
注意：
1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。
2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。
3、在Python中没有switch – case语句。
#!/usr/bin/python3 var1 = 100 if var1: print("1 - if 表达式条件为 true") print(var1) var2 = 0 if var2: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac5bcc7f7cdc464b557c731cdafeb0e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e89698f2bb360f76db9fc82e89a14c7/" rel="bookmark">
			js获取天数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gettoday(){ let date = new Date() let day = date.getDate() let year = date.getFullYear() let month = date.getMonth()+1 let days = this.amountday(year,month,day) return days }, js获取年月日时，月份是从0开始计算直到11月，所以如果需要获取到当前真正的月份需要date.getMonth()+1才是当前真正月份
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d381aabfd392e399dc1e24d77d33ad2/" rel="bookmark">
			概率与排列组合——2017NOIP-pj第19题——一家四口人，至少两个人生日属于同一月份的概率是
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第 19 题
一家四口人，至少两个人生日属于同一月份的概率是（C ）（假定每个人生日属于每个月份的概率相同且不同人之间相互独立）。
A. 1/12
B. 1/144
C. 41/96
D. 3/4
本题共 1.5 分
解：只要去掉四个人都不在同一个月的概率即可，因为题目是至少
1 − P ( 4 12 ) 1 2 4 = 1 − 12 × 11 × 10 × 9 12 × 12 × 12 × 12 = 1 − 55 96 = 41 96 1 -\frac{P{4\choose12}}{12^4} = 1-\frac{12\times11\times10\times9}{12\times12\times12\times12} =1-\frac{55}{96}= \frac{41}{96} 1−124P(124​)​=1−12×12×12×1212×11×10×9​=1−9655​=9641​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e10f82b70734a1ac73dab50cf0bf6e7/" rel="bookmark">
			VRRP 基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VRRP 基本配置 原理概述 随着Internet 的发展，人们对网络可靠性的要求越来越高。对于用户来说，能够时刻与外部网络保待通信非常重要，但内部网络中的所有主机通常只能设置一个网关IP 地址，通过该出口网关实现主机与外部网络的通信。若此时出口网关设备发生故障，主机与外部网络的通信就会中断，所以配置多个出口网关是提高网络可靠性的常用方法。为此， IETF 组织推出了VRRP 协议， 主机在多个出口网关的情况下，仅需配置一个虚拟网关IP 地址作为出口网关即可，解决了局域网主机访问外部网络的可靠性问题。
VRRP ( Virtual Router Redundancy Protocol ) 全称是虚拟路由器冗余协议，它是一种容错协议。该协议通过把几台路由设备联合组成一台虚拟的路由设备，该虚拟路由器在本地局域网拥有唯一的一个虚拟ID 和虚拟IP 地址。实际上，该虚拟路由器是由一个Master 设备和若干Backup 设备组成。正常情况下，业务全部由Master 承担，所有用户端仅需设置此虚拟IP 为网关地址。当Master 出现故障时， Backup 接替工作，及时将业务切换到备份路由器，从而保持通信的连续性和可靠性。而用户端无需做任何配置更改，对故障无感知。
VRRP的Master 选举基于优先级， 优先级取值范围是0~2 55, 默认情况下，配置优先级为100 。在接口上可以通过配置优先级的大小来手工选择Master 设备。
实验目的 理解VRRP 的应用场景掌握VRRP 虚拟路由器的配置掌握修改VRRP 优先级的方法掌握查看VRRP 主备状态的方法 实验内容 本实验模拟企业网络场景。公司内员工所用电脑，如PC-1 、PC-2, 通过交换机S1连接到公司网络，S1 连接到公司出口网关路由器。为了提高网络的可靠性，公司使用两台路由器R2 与R3 作为双出口连接到外网路由器R1。R1 、R2 、R3 之间运行OSPF协议。在双网关的情况下，如果在PC 上配置R2 或R3 的真实IP 地址作为网关，当其中一台路由器故障时，就需要手动更改PC 的网关IP, 若网络中有大量PC 则需要耗费大量时间和人力去更改配置，且会带来一定时间的断网影响。为了能够使故障所造成的断网影响达到最小化，增强网络的可靠性，网络管理员在R2 与R3 之间部署VRRP 协议，这样当任一网关发生故障时就能自动切换而无需更改PC 的网关IP 地址。
实验拓扑 实验编址 我们配置一下相关信息
设备
接口
IP地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e10f82b70734a1ac73dab50cf0bf6e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2580e67c5ddd9461889f22919fda146b/" rel="bookmark">
			C#判断文件是否被占用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 在C#中判断文件是否被占用一般有两种方法，一是利用FileStream结合try...catch...finally实现，二是调用Windows API实现，下面给出两种方法的代码。
2、文件流法 using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; using System.Threading.Tasks; namespace ConsoleApp3 { class Program { static void Main(string[] args) { string filePath = @"D:\data.xlsx"; bool occupied = IsOccupied(filePath); if (occupied) { Console.WriteLine("文件被占用"); } else { Console.WriteLine("文件未被占用"); } Console.ReadKey(true); } static bool IsOccupied(string filePath) { FileStream stream = null; try { stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.None); return false; } catch { return true; } finally { if (stream !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2580e67c5ddd9461889f22919fda146b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771030b27d894d12a4515bfd2ca87f5b/" rel="bookmark">
			pycharm调试时单步调试失效，无法读取数据信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		故障现象:
用pycharm进行debug时，可以跳到断点，但将鼠标停留在某个数据上时，显示evaluating…。然后数据一直不显示出来。此时如果继续按F8单步调试或者F7进入下一层时。程序不会继续往前走。类似于卡机的状态。
我的解决方法:
pytorch的dataloader的num_workers设置为0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d1f0371c79a2dd8f2ec82dd3b63651/" rel="bookmark">
			:rules用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在vue中使用rules对表单字段进行验证 1. 写在 data 中验证 &lt;el-form ref="rulesForm" :rules="formRules" :model="rulesForm" label-width="200px"&gt; formRules: { userName: [ {required: true,message: "请输入用户名称",trigger: "blur"} ] } 2. 写在行内 &lt;el-form-item label="用户名" prop="name" &gt; &lt;el-input type="text" id="username" v-model="username" :rules="[{ required: true, message: '请填写用户名' },//用于表当验证 {pattern:/^[1][3,4,5,6,7,8][0-9]{9}$/,message:'请输入正确的11位手机号'}]" &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; 3. 引入外部定义的规则 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205743e553cb4097d2eaa96c344da444/" rel="bookmark">
			uniapp实现页面左右滑动，上下滑动事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实现代码：
&lt;view class="" @touchstart="touchstart" @touchend="touchend"&gt; &lt;/view&gt; data() { return { touchData: {}, //滑动事件数据 } } methods: { touchstart(e) { this.touchData.clientX = e.changedTouches[0].clientX; this.touchData.clientY = e.changedTouches[0].clientY; }, touchend(e) { const subX = e.changedTouches[0].clientX - this.touchData.clientX; const subY = e.changedTouches[0].clientY - this.touchData.clientY; if(subY &gt; 50){ console.log('下滑') } if(subY &lt; -50){ console.log('上滑') } if (subX &gt; 50) { console.log('右滑') } if (subX &gt; -50) { console.log('左滑') } }, } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e33501d99fa8b54d06c6ccf506f0b50f/" rel="bookmark">
			L2-022 重排链表 (25 分)（测试点3，超级详细解析，看不懂捶我）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个单链表 L1​​ →L2 →⋯→L​n−1​​ →L​n​​ ，请编写程序将链表重新排列为 L​n​​ →L​1​​ →L​n−1​​ →L​2​​ →⋯。例如：给定L为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。
输入格式：
每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数N (≤10​5​​ )。结点的地址是5位非负整数，NULL地址用−1表示。
接下来有N行，每行格式为：
Address Data Next
其中Address是结点地址；Data是该结点保存的数据，为不超过10
​5
​​ 的正整数；Next是下一结点的地址。题目保证给出的链表上至少有两个结点。
输出格式：
对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。
输入样例：
00100 6 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 输出样例：
68237 6 00100 00100 1 99999 99999 5 12309 12309 2 00000 00000 4 33218 33218 3 -1 和之前的链表去重有一定的区别，输出的时候别被带跑偏了，具体思路是这样的：首先先将链表都输入结构体中，然后根据循环条件
while(a[i].next!=-1){ b1[t1++]=a[i].address; b2[t2++]=a[i].data; i=a[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e33501d99fa8b54d06c6ccf506f0b50f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256e4507b3d2969bb1ce7154897c1513/" rel="bookmark">
			任务提交修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老师要求我不输入报修用户，默认是自己的账号，那么我想到的就是用vuex全局变量来实现。
最终结果是这样，但实现时遇到了一个问题，用户名可以是中文也可以是英文，中文与英文计算长度的方法是完全不一样的。所以就需要进行字符的判断。
vuex:
export default new Vuex.Store({ state: { username:'Zyatoer', pwd:'233', url:'', amountprice:0, waterprice:0, charge:0, dormid:0, roomid:0, tasktitle:'哈', taskarea:'', tasklist:[] }, getters:{ getTasktitle(state){ return state.tasktitle }, getTaskarea(state){ return state.taskarea }, getUsername(state){ return state.username }, getPassworld(state){ return state.pwd }, getUrl(state){ return state.url }, getAmountPrice(state){ return state.amountprice }, getWaterPrice(state){ return state.waterprice }, getCharge(state){ return state.charge }, getDormid(state){ return state.dormid }, getRoomid(state){ return state.roomid }, getTasklist(state){ return state.tasklist } 这里是根据用户的输入来获取相应的全局变量
mounted () { var _this = this; _this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/256e4507b3d2969bb1ce7154897c1513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be349d64019ab05f7634e2fb11f3e38d/" rel="bookmark">
			Java岗面试必问！互联网公司常用分库分表方案汇总！看看这篇文章吧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Alibaba作为国内互联网行业的“老大”，一直以来也是很多“数码宝贝”梦寐以求的公司，我个人是做Java开发的，阿里这些年也开发了很多屌炸天的开源项目，像什么Spring Cloud Alibaba，开源Java诊断工具Arthas，Apache Dubbo，JDBC连接池、监控组件Druid等等，属实牛逼！
阿里能做到这样，也不知道各位“数码宝贝”花了多少个日日夜夜换来的，因此我本也不想进大厂累死累活的。之前每个月在北京每个月拿个小30k，日子过的也还算不错，但自从有了娃以后，越发有种家庭责任感，钱也越来越感觉不够花，因此我便萌生了进阿里的想法。
因为今年疫情原因，北京管理相当严格，我在家也是间断的在补充新知识，夯实基础，直到今年7月中下旬才拿到了Alibaba的offer，下面我会为大家分享我主要在用的一些资料笔记，以及面经分享。
下面会介绍这些资料笔记的主要内容涵盖的知识点，由于文章篇幅，所以只展示了截图内容
01 源码分析 源码阅读，最核心有三点：技术基础+强烈的求知欲+耐心。
1.1 设计模式（45设计模式：介绍+优缺点+应用实例+源代码+解决问题）
1.2 Spring复习大纲：依赖注入Ioc+Beans+注解+数据访问+AOP+MVC等
1.3 Spring全家桶笔记：Spring+Spring Boot+Spring Cloud+Spring MVC
面试题（含解析）+学习书籍+学习思维脑图
02 分布式架构 近几年目前分布式最主流的技术：
2.1 大规模分布式存储系统：原理解析与架构实战（PDF）
2.2 ZooKeeper-分布式过程协同技术详解（PDF）
2.3 Redis学习笔记
2.4 MangoBD面试必备题
2.5 并发编程72道题+解析
03 微服务 微服务需要学习的知识点：
3.1 微服务那些事儿（PDF）
3.2 Spring Cloud参考指南
3.3 docker学习思维脑图
04 性能优化 结性能优化应该学习理解的几大知识体系：
4.1 MySQL面试必备+21个最佳性能调优实践
4.2 MySQL技术内幕 InnoDB存储引擎
4.3 JVM性能调优学习脑图（xmind）
4.4 Tomcat专题资料
05 Java工程化 Java工程化应该学习理解的几大知识体系：
最后总结 ActiveMQ+Kafka+RabbitMQ学习笔记PDF RabbitMQ实战指南 手写RocketMQ笔记 手写“Kafka笔记” 关于分布式，限流+缓存+缓存，这三大技术（包含：ZooKeeper+Nginx+MongoDB+memcached+Redis+ActiveMQ+Kafka+RabbitMQ）等等。这些相关的面试也好，还有手写以及学习的笔记PDF，都是啃透分布式技术必不可少的宝藏。以上的每一个专题每一个小分类都有相关的介绍，并且小编也已经将其整理成PDF啦
+缓存，这三大技术（包含：ZooKeeper+Nginx+MongoDB+memcached+Redis+ActiveMQ+Kafka+RabbitMQ）等等。这些相关的面试也好，还有手写以及学习的笔记PDF，都是啃透分布式技术必不可少的宝藏。以上的每一个专题每一个小分类都有相关的介绍，并且小编也已经将其整理成PDF啦
资料领取方式：戳这里免费领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb75364f58d10aacee5ea7818672568/" rel="bookmark">
			注册公司流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习笔记请置顶
1）注册公司准备
办公场所十个名字（核名）——工商要核名，如果准备一个重名就得再跑一趟经营范围——看同类型公司的经营范围是什么就写什么就好了注册资金——最低3万，建议多一点，50w以上，因为也不用立即交上年限——最长16年，建议选最长 2）注册公司费用
工章——4个，每个150，共600对公账户——不建议开四大行的，它们的管理费、开户费比较贵。每年1000+，开广发、平安、民生、交通的，它们的费用180+财务记账——法人不能记账，一般是委托财务记账公司来记，每月300
注：纳税人要选小规模纳税人（只能开普票），但是记账费便宜。如果选一般纳税人（可开普票和增值税发票），它的记账票比较贵。​ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cbf4edccc5b5e245572775d469113ac/" rel="bookmark">
			总结了这67个pandas函数，完美解决数据处理，拿来即用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不管是业务数据分析 ，还是数据建模。数据处理都是及其重要的一个步骤，它对于最终的结果来说，至关重要。
今天，就为大家总结一下 “Pandas数据处理” 几个方面重要的知识，拿来即用，随查随查。
导⼊数据导出数据查看数据数据选取数据处理数据分组和排序数据合并 # 在使用之前，需要导入pandas库 import pandas as pd 导⼊数据 这里我为大家总结7个常见用法。
pd.DataFrame() # 自己创建数据框，用于练习 pd.read_csv(filename) # 从CSV⽂件导⼊数据 pd.read_table(filename) # 从限定分隔符的⽂本⽂件导⼊数据 pd.read_excel(filename) # 从Excel⽂件导⼊数据 pd.read_sql(query,connection_object) # 从SQL表/库导⼊数据 pd.read_json(json_string) # 从JSON格式的字符串导⼊数据 pd.read_html(url) # 解析URL、字符串或者HTML⽂件，抽取其中的tables表格 导出数据 这里为大家总结5个常见用法。
df.to_csv(filename) #导出数据到CSV⽂件 df.to_excel(filename) #导出数据到Excel⽂件 df.to_sql(table_name,connection_object) #导出数据到SQL表 df.to_json(filename) #以Json格式导出数据到⽂本⽂件 writer=pd.ExcelWriter('test.xlsx',index=False) df1.to_excel(writer,sheet_name='单位')和writer.save()，将多个数据帧写⼊同⼀个⼯作簿的多个sheet(⼯作表) 查看数据 这里为大家总结11个常见用法。
df.head(n) # 查看DataFrame对象的前n⾏ df.tail(n) # 查看DataFrame对象的最后n⾏ df.shape() # 查看⾏数和列数 df.info() # 查看索引、数据类型和内存信息 df.columns() # 查看字段（⾸⾏）名称 df.describe() # 查看数值型列的汇总统计 s.value_counts(dropna=False) # 查看Series对象的唯⼀值和计数 df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cbf4edccc5b5e245572775d469113ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf86dd8a8fe626c09f3ede386a0fe28/" rel="bookmark">
			Docker架构原理及常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker的介绍
Docker是一个开源的应用容器引擎，使用Go语言开发，基于Linux内核的cgroup，namespace，Union FS等技术，对应用进程进行封装隔离，并且
独立于宿主机与其他进程，这种运行时封装的状态称为容器。
Docker早起版本实现是基于LXC，并进一步对其封装，包括文件系统、网络互联、镜像管理等方面，极大简化了容器管理。从0.7版本以后开始去
除LXC，转为自行研发的libcontainer，从1.11版本开始，进一步演进为使用runC和containerd。
Docker理念是将应用及依赖包打包到一个可移植的容器中，可发布到任意Linux发行版Docker引擎上。使用沙箱机制运行程序，程序之间相互隔离。
1.2、docker的体系架构
Containerd：是一个简单的守护进程，使用runC管理容器。向Docker Engine提
供接口。
Shim：只负责管理一个容器。
runC：是一个轻量级的工具，只用来运行容器。
1.4、docker的内部组件
1. Namespaces
命名空间，Linux内核提供的一种对进程资源隔离的机制，例如进程、网络、挂载点等资源。
2. CGroups
控制组，Linux内核提供的一种限制进程资源的机制；例如CPU、内存等资源。
3. UnionFS
联合文件系统，支持将不同位置的目录挂载到同一虚拟文件系统，形成一种分层的模型。
1.5、虚拟机与容器区别
以 KVM 举例，与 Docker 对比
启动时间
Docker秒级启动，KVM分钟级启动。
轻量级
容器镜像大小通常以M为单位，虚拟机以G为单位。
容器资源占用小，要比虚拟机部署更快速。
性能
容器共享宿主机内核，系统级虚拟化，占用资源少，没有Hypervisor层开销，容器性能基本接近物理机；
虚拟机需要Hypervisor层支持，虚拟化一些设备，具有完整的GuestOS，虚拟化开销大，因而降低性能，没有容器性能好。
安全性
由于共享宿主机内核，只是进程级隔离，因此隔离性和稳定性不如虚拟机，容器具有一定权限访问宿主机内核，存在一定安全隐患。
使用 要求
KVM基于硬件的完全虚拟化，需要硬件CPU虚拟化技术支持；
容器共享宿主机内核，可运行在主流的Linux发行版，不用考虑CPU是否支持虚拟化技术。
1.6、docker 的应用场景
场景一：节省项目环境部署时间
1. 单项目打包
2. 整套项目打包
3. 新开源技术试用
场景二：环境一致性
场景三：持续集成
场景四：微服务
场景五：弹性伸缩
参看： https://blog.51cto.com/lizhenliang/1978081
1.7、在Centos7.x安装docker
CentOS7
# 安装依赖包
yum install -y yum-utils device-mapper-persistent-data lvm2
# 添加Docker软件包源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf86dd8a8fe626c09f3ede386a0fe28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571b86ebd4351b0accef160cf386a988/" rel="bookmark">
			2021最全HW蓝队指导手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021最全HW蓝队指导手册 简述 一年一度的HW即将开始，我也即将参与HW的工作中。为了防止被红队打穿出局，我花了两天时间从知识库https://evalshell.com 上整理了截止到目前为止最全的蓝队操作手册。本次手册还会持续更新，截止到发稿日期，共整理了7个方向，方别是：信息收集、渗透测试(防御)、加固、研判、溯源、反制、总结7个部分，文章来源自公众号，先知论坛，各大博客等等，部分字典和工具我会同步在Notion上动态更新。总体来说，至少可以当红队攻进来的时候你不会束手无措，还能进行一定程度的溯源和反制。
废话不多说，直接上干货
文章列表(持续更新…) 因为非微信内部链接会失效，所以原版请访问 Notion地址：https://www.notion.so/4f2d8f3ff5d2491b9fc5a3ea9f6ace8d
01 信息收集 文档区 收集的路径字典
弱口令字典
红队渗透手册之信息收集篇HW演习前的自我信息排查下周的HW工作，重新学习下就不慌了红蓝对抗 - 蓝队手册2020HW小技巧总结红队视角下Linux信息收集攻防演练之蓝队视角下的Linux信息收集 02 渗透测试 文档区 常见组件漏洞
HW平安夜: 09/12 漏洞PAYlOADHW平安夜: 09/17 红队手册之代理转发与隧道 03 加固 Windows安全加固手册Linux安全加固手册打造HW蓝队工具之文件监控蓝队防守必须排查的57个安全漏洞与解决方案 04 研判 日志分析相关工具
CentOS系统中常用查看系统信息和日志命令小结windows下使用netstat查看指定网络连接数HW防守中之日志分析应急响应介绍域渗透：使用蜜罐检测出Kerberoast攻击web-log-parser蓝队经验——Wireshark数据包分析浅析 05 溯源 HW平安夜 09/19 攻击溯源HW平安夜 09/21 死磕到底HW平安夜 09/22 风平浪静红蓝演习对抗之溯源篇如何从日志文件溯源出攻击手法？安全分析–追踪溯源的找人思路浅谈攻击溯源的一些常见思路在线沙盒（恶意软件行为分析工具）整理介绍追踪邮件发送者的地理位置蓝队溯源与反制蓝队：HW溯源小工具 shiro payload decode蓝队经验—应急响应方法论(精选版) 06 反制 蓝队反制JSON探针蓝色吃定红色-爆破CS Teamserver 密码HW｜蓝队实战溯源反制手册分享 07 总结 2021HW之蓝队经验总结 最后 Xmind分享图太大，如果想要原图，可以在公众号回复 “蓝队手册” 获得原图，更多网络安全请在evalshell.com 知识库上查询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62106019062b0457df9ecb24c2fe4e83/" rel="bookmark">
			web通讯的四种方式：短轮询、长轮询(comet)、长连接(SSE)、WebSocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		短轮询 定义 http端轮询是服务器收到请求不管是否有数据都直接响应 http 请求;
其实就是普通的轮询。指在特定的的时间间隔（如每1秒），由浏览器对服务器发出 HTTP request，然后由服务器返回最新的数据给客户端的浏览器。
应用场景 传统的 web 通信模式。后台处理数据，需要一定时间，前端想要知道后端的处理结果，就要不定时的向后端发出请求以获得最新情况。
优点 前后端程序编写比较容易。
缺点 请求中有大半是无用，难于维护，浪费带宽和服务器资源；
响应的结果没有顺序（因为是异步请求，当发送的请求没有返回结果的时候，后面的请求又被发送。而此时如果后面的请求比前面的请 求要先返回结果，那么当前面的请求返回结果数据时已经是过时无效的数据了）。
实例： 适于小型应用。 前端实现： var xhr = new XMLHttpRequest(); setInterval(function(){ xhr.open('GET','/user'); xhr.onreadystatechange = function(){ }; xhr.send(); },1000) 长轮询 定义 客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。
优点 在无消息的情况下不会频繁的请求，耗费资源小。
缺点 服务器 hold 连接会消耗资源
返回数据顺序无保证，难于管理维护。
浏览器端对统一服务器同时 http 连接有最大限制, 最好同一用户只存在一个长轮询;
实例： WebQQ、Hi 网页版、Facebook IM。
前端实现： function ajax(){ var xhr = new XMLHttpRequest(); xhr.open('GET','/user'); xhr.onreadystatechange = function(){ ajax(); }; xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62106019062b0457df9ecb24c2fe4e83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d602241c54cf9014987a1bec614ba55d/" rel="bookmark">
			查询mongodb数据库自增_id字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 app.get('/student/repair/cancelrepai',(req,res)=&gt;{ let id =req.query._id id = ObjectId(id) console.log(id) let obj = {_id:id} newtask.find(obj).then(arr=&gt;{ res.send(arr) }) }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dc6bae4040d23ee234b316d95387a40/" rel="bookmark">
			拼贴纸问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 给定一个字符串str，给定一个字符串数组arr； arr里的每一个字符串代表一张贴纸，可以把单个字符剪开使用， 目的是拼出字符串str，求至少需要多少张贴纸可以拼出字符串str。 例：str = "babac"，arr = {"ba", "c", "abcd"} 至少需要两张贴纸，分别是“ba”和“abcd”，使用这两张贴纸，把每个字符单独剪开， 有2个a，2个b，1个c，可以拼出babac，所以结果是2。 题解 /** * @author IT00ZYQ * @date 2021/4/10 19:31 **/ public class 拼贴纸 { public static int way1(String str, String[] arr) { // 将每个贴纸以数组的形式存储 int[][] map = new int[arr.length][26]; for (int i = 0; i &lt; arr.length; i++) { for (char c : arr[i].toCharArray()) { map[i][c - 'a'] ++; } } return wayFunc1(str, map); } /** * @param rest 当前剩余的需要拼的字符，可变变量 * @param map 每个贴纸的字符及其数量 * @return 拼出rest字符串需要的最少贴纸数 */ private static int wayFunc1(String rest, int[][] map) { // 需要拼的字符串已经为空字符串，不再需要任何贴纸 if ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dc6bae4040d23ee234b316d95387a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81b5a697ad21319b006d3103b676735/" rel="bookmark">
			Java包装类、基本数据类型、String的关系及互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本数据类型、包装类、String三者之间的转换 学习包装类，图片及代码来自尚硅谷教育，侵删
包装类是什么？为什么要用包装类？ java提供了8中基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征。
基本数据类型--&gt;包装类 调用构造器
//基本数据类型 ---&gt; 包装类 //具体方法： 调用包装类的构造器,可以是数值，可以是字符串 @Test public void test1() { int num1 = 10; //不能这么写，因为基本数据类型不是Object的子类 // System.out.println(num1.toString()); Integer integer = new Integer(num1); System.out.println(integer.toString());//包装类可以调用toString方法 System.out.println(integer.doubleValue() );//可以输出为其他格式 //构造器参数可以是字符串 Integer integer1 = new Integer("123"); System.out.println(integer1); //报异常 // Integer integer2 = new Integer("123abc"); Float float1 = new Float(12.3f); Float float2 = new Float("12.3f"); System.out.println(float1); System.out.println(float2); Float float3 = new Float(12.3); System.out.println("参数不带f时"+float3); Boolean b1 = new Boolean(true); Boolean b2 = new Boolean("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f81b5a697ad21319b006d3103b676735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e11ac34261a5377ff27da8eb1eed2d8/" rel="bookmark">
			2021-04-10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进现在公司大半年了，在进这家公司之前，一直觉得自己挺牛逼的。毕竟虚拟摄像头、边录mp4边写软字幕，都是我第一个做出来的。特别是虚拟摄像头做出来后，带动了很多人围绕这个技术，深入研究并商用。进了现在公司系统性的学习camera hal后，才觉得之前自己所掌握的太肤浅了。之前有多自信，现在就有多惶恐。为了不掉队，为了能早一日将camera 从上到下，真正的做到全线融会贯通，差不多都是朝九晚十了。
希望能在接下来的几年内，早日将camera吃透。加油加油
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01fe18ae4d8094962281940dfec1b33f/" rel="bookmark">
			肚子开发中关于vant-ui中uploader组件无法点击的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在开发时，使用了vant-ui中的uploader的文件上传组件，但出现了一个问题有些时候从其他界面进入就没法进行点击上传动作但一刷新又可以使用了；看了开发者工具才知道是之前设置Input属性值时也一并设置上了，导致组件中负责文件上传的input标签换了位置
解决方法：
.van-uploader__upload input{ margin: 0; width: 100%; } 这样就能避免uploader组件下的input标签乱跑的问题了，当然如果为了求稳还可以将padding和margin也统统设置为0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccac3088be2f5528481d9a296c5d2d3a/" rel="bookmark">
			python字符串和切片操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python字符串和切片操作 1.去掉字符串中所有的空格2. 获取字符串中汉字的个数3.将字母全部转换为大写和小写4.根据标点符号对字符串进行分行5. 去掉字符串数组中每个字符串的空格（循环）6.随意输入心中想到的一个书名，然后输出它的字符串长度(len属性)7.用户输入一个日期格式如‘’2021/03/28“，将输入的日期转换为”2021年-3月-28日“8.接收用户输入的字符串，将其中的字符进行排序，并以逆序输出。9.. 用户输入一句英文，将其中的单词以反序输出10. 用户输入一句话，找出所有”呵“的位置11.有个字符串数组，存储了10个书名，书名有长有短，现在将他们统一处理，若长度大于10，则截取长度为8的子串,将统一处理后的结果输出12.用户输入一句话，找出所有”呵呵“的位置13.如何判断一个字符串是否是另一个字符串的子串14.如何验证一个字符串中的每一个字符均在另一个字符串中出现15.如何生成无数字的全字母的字符串16.如何随机生成带数字和字母的字符串17.如何判定一个字符串中既有数字又有字母18.python中不可变对象有哪些？19.判断一个数是否是回文数字20. L = [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’]取前三个元素21. range()函数可以创建一个数列：range(1, 101)22.利用倒序切片对 1 - 100 的数列取出：最后10个数；最后10个5的倍数23. 请设计一个函数，它接受一个字符串，然后返回一个仅首字母变成大写的字符串（切片upper()）24.利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法25.从键盘上输入自己或同学的身份证号，从中取出出生年份、月份、日期以及性别信息 1.去掉字符串中所有的空格 我们可以适用replace（m,n）方法来实现去掉字符串中的所以的空格
下面是代码实现
// 将字符串中所有的空格删除 s=' This is a demo ' print(s.replace(' ','')) 运行结果如下图所示
2. 获取字符串中汉字的个数 首先要获取汉字的话我们要了解Unicode里的字符编码，
\u0020 空格
\u0040 ~ \u005A 大写字母A~Z
\u0061 ~ \u007A 小写字母a~z
\u4E00 ~ \u9FFF 中文字符
\u0030 ~ \u0039 数字
了解了这些字符编码后我们就可以用isalpha()函数来判断字符串中的汉字个数了。
下面是代码实现
ch=0; string = input() for x in string: if x &lt;='\u9fff' and x&gt;='u4e00': ch+=1 print(ch) 运行结果如下图所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccac3088be2f5528481d9a296c5d2d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d5c66a1faf7d25345454bcaa795955/" rel="bookmark">
			springsecurity出现重定向次数过多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用springsecurity时，出现了以下问题
1、.anyRequest() .authenticated(); http.formLogin() .loginPage("/login.html") .loginProcessingUrl("/api/private/login") .defaultSuccessUrl("/success.html") .and() .authorizeRequests() .anyRequest() .authenticated(); 原因是我们使用了这个
.anyRequest() .authenticated()，它的意思是任何请求都需要进行登录认证，当跳转到/login.html时，由于login.html也是请求，它会让login.html进行认证，所以会再次访问login.html，所以就造成了无限循环进行重定向。
解决方法
http.formLogin() .loginPage("/login.html") .loginProcessingUrl("/api/private/login") .defaultSuccessUrl("/success.html") .and() .authorizeRequests() .antMatchers("/login.html").permitAll() .anyRequest() .authenticated(); .and().csrf().disable(); 其中的.and().csrf().disable(); csrf(跨站请求伪造）也可以理解为防火墙；如果没关闭，当你登录时，它虽然不会出现重定向次数过多的情况，但也会回到login.html页面
当然重定向次数过多也有其他情况，本质上都是访问login.html，然后又让login.html进行认证，结果就是陷入访问死循环
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae131eaeae7a84dfe318a3e2dd42975/" rel="bookmark">
			H3C设备网吧万兆光模块解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网吧网络系统需要有很高的带宽，要支持大量的数据传输，因此，网吧对网络硬件有较高的要求。网吧网络在设计的时候，需要保证优质的网络传输速度，而且还要考虑到日后的网络升级和维护。下面，易天光通信（ETU-LINK）就为大家介绍下网吧的网络设备解决方案。
首先，在网络设备的选择方面，我们需要选择一台高性能无盘服务器，选配方面可以选择支持双路CPU、512G内存的主板、英特尔E5架构的CPU。
然后选择两台H3C全万兆交换机构建万兆网络，畅享游戏、4k电影等服务体验。服务器与交换机的传输载体可采用易天万兆光模块搭配OM3多模光纤跳线，实现300米内的链路传输。交换机与电脑的连接采用超5类线（Cat5e）网线。网吧的组网示意图如下：
采用光纤进行布线的好处是就是具有扩展性，以便未来接入更多的设备，而且光纤在高速传输时，有很好的抗干扰性，能适应复杂的电磁干扰。相比铜缆布线而言，在稳定性方面，光纤更好。
另外，病毒入侵和非法攻击是网吧最大的安全隐患，出于对安全问题的考虑，可以接入防火墙设备，不过由于防火墙的价格比较贵，所以建议在资金允许的情况下，再做考虑。
为保障网吧网络的稳定性，在选择交换机、路由器等网络设备时，需要选择能有效防APR欺骗，防IP扫描、DDOS等攻击的设备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1dcacecbcb3f379294837989daeb62/" rel="bookmark">
			Filecoin系统发展历程之Lotus网络优化大盘点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/229b248189c4567ba33dae662fc60093/" rel="bookmark">
			阿里笔试题：机器人走K步到达M点问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 假设有排成一行的N个位置，记为1~N，N一定大于或等于2; 开始时机器人在M（1 &lt;= M &lt;= N）位置上， 如果机器人位于1位置，那么下一步只能走到2位置， 如果机器人位于N位置，那么下一步只能走到N-1位置， 如果机器人位于中间的任一位子，那么下一步可以向左走，也可以向右走。 机器人必须走K步，最终来到P（1 &lt;= P &lt;= N），给定参数N，M，K，P，有多少种走法？ 三种解题方法 /** * 假设有排成一行的N个位置，记为1~N，N一定大于或等于2; * 开始时机器人在M（1 &lt;= M &lt;= N）位置上， * 如果机器人位于1位置，那么下一步只能走到2位置， * 如果机器人位于N位置，那么下一步只能走到N-1位置， * 如果机器人位于中间的任一位子，那么下一步可以向左走，也可以向右走。 * 机器人必须走K步，最终来到P（1 &lt;= P &lt;= N），给定参数N，M，K，P，有多少种走法？ * @author IT00ZYQ * @Date 2021/4/8 23:02 **/ public class 机器人走K步达到P { /** * 暴力递归法 * @param n N个位置 * @param m 开始时机器人在M（1 &lt;= M &lt;= N）位置上 * @param k 必须走K步 * @param p 目标位置p * @return 方案数 */ public static int way1(int n, int m, int k, int p) { return fun1(k, m, n, p); } /** * 从cur位置走rest步到达p位置的方法数 * @param rest 剩余步数 * @param cur 当前位置 * @param n 位置数 * @param p 目标位置 * @return 从cur位置走rest步到达p位置的方法数 */ public static int fun1(int rest, int cur, int n, int p) { // 步数已走完，且当前处于目标位置上，则属于一种方法 if (rest == 0) { return cur == p ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/229b248189c4567ba33dae662fc60093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f992ad3358e30a38070043bb2b2cad7f/" rel="bookmark">
			经典N皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		N皇后问题 n 皇后问题： 如何将 n 个皇后放置在 n×n 的棋盘上， 并且使皇后彼此之间不能相互攻击（不在同一行，同一列，同一对角线上）。 给定一个整数 n ，返回有多少种摆放方法。 两种解法 /** * @author IT00ZYQ * @Date 2021/4/8 21:50 **/ public class N皇后 { /** * 暴力递归法 * @param n * @return */ public static int way1(int n) { if (n &lt; 0) { return -1; } int[] record = new int[n]; return wayFun1(0, n, record); } /** * @param cur 当前需要的摆放的是第cur个皇后 * @param n 总共有n-1个皇后需要摆放 * @param record 前cur-1个皇后摆放的列 * @return */ private static int wayFun1(int cur, int n, int[] record) { if (cur == n) { return 1; } int res = 0; for (int i = 0; i &lt; n; i++) { if (isValid(record, cur, i)) { record[cur] = i; res += wayFun1(cur + 1, n, record); // 由于每次进行操作都会修改record[cur]的值，此处不需要还原现场 } } return res; } private static boolean isValid(int[] record, int i, int j) { for (int k = 0; k &lt; i; k++) { // 用于判断（k, record[k]） 与 （i, j）是否在同一列或者同一对角线上 if (record[k] == j || Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f992ad3358e30a38070043bb2b2cad7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a184dac3c62411d10aeaf19f4f834038/" rel="bookmark">
			flex布局中，最后一个元素居右展示以及input组件与内容一样宽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写项目时有一个想法，filestate组件里面就是下面报修项目以及报修内容中我希望采用flex布局，希望最后一个元素在最右边该如何实现了
&lt;div class="filestate"&gt; &lt;van-icon name="smile-comment-o" /&gt; &lt;h1&gt;报修人&lt;/h1&gt; &lt;input class="reportman" type="text" v-model="rname"&gt; &lt;/div&gt; .filestate input{ border: none; background-color: rgba(0,0,0,0); font-size: .36rem; font-family: '楷体'; line-height: .88rem; /* margin-left: auto; */ width: auto; } 可以通过设置margin-left:auto方法实现最后一个元素在最右边
但还有个问题就是如何使input的内容与元素内容一样宽，当时想的是能不能给width写一个auto就行了结果是不行
搜了一圈好像使用css只能通过计算多少个字来计算定宽才行，单纯用css并不能用所以只能通过js进行自定义。
一开始想的时在挂载时获取与之绑定的data数据的长度然后乘以设置的文字大小，但如果使用v-model绑定data数据的话，挂载时data数据没有完全渲染无法获取到长度甚至会报错
所以只能通过传统方法获取其值
resetinput(){ let name = document.getElementById('reportman').value let phone = document.getElementById('reporphone').value console.log(phone.length+'哈'+name.length) } 能够得到长度了，现在就该设置input的长度了
//重置input长度 resetinput(){ let name = document.getElementById('reportman') let phone = document.getElementById('reporphone') let namelength = name.value.length*0.36 name.style.width = namelength+'rem' } 好成功完成效果，剩下的在挂载页面时调用方法就行了
mounted () { var _this = this; _this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a184dac3c62411d10aeaf19f4f834038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce88cc35842d38677595ebbea3b9f2af/" rel="bookmark">
			设计数据密集型应用——复制（5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 写在最前面2. 复制2.1 复制的目的2.2 复制的方式 3 单领导者3.1 架构图3.2 待解决的问题3.3 复制的实现3.4 解决复制延迟遇到的问题 4. 多领导者4.1 架构图4.2 多主复制的应用场景4.3 处理写入冲突4.4 复制拓扑 5. 无领导者5.1 架构图5.2 当节点故障时写入数据库5.3 检测并发写入 6. 碎碎念7. 参考资料 1. 写在最前面 最近在看《Designing Data-Intensive Application》这本书，讲的是在设计一个数据密集型的应用的时候有哪些难点。为了防止自己又一次草草的读完，不能将书本上的知识内化为自己的知识，所以还是老规矩写一份读书笔记，不仅加深理解还能方便后续复习，一举多得。
作为一个不走寻常路的人，看书也都是看心情的。所以「出人意料」的第一篇文章的总结是书中的第二部分——分布式数据中的第五章——复制。
2. 复制 2.1 复制的目的 在开始了解复制之前，思考一个问题——数据复制的目的是什么？
提高可用性（即使系统的一部分出现故障，系统也能继续工作减少延迟（使数据与用户在地理上更接近提供读取吞吐量（伸缩可以接受读请求的机器数量 2.2 复制的方式 如果复制的数据不会随时间而改变，那复制就很简单，将数据复制到每个节点一次即可。复制的困难之处在于处理复制数据的变更（change)。以下涵盖了几乎所有分布式数据库中的复制算法：
单领导者（single leader）多领导者（multi leader）无领导者（leaderless） 3 单领导者 3.1 架构图 3.2 待解决的问题 选择同步复制还是异步复制？
做选择最好的方式就是列出优缺点，然后一条条对比，嗯，真香。
优点缺点同步复制保证从库与主库有一致的最新副本数据从库无响应时，主库无法继续写入异步复制即使从库落后时，主库仍可继续写入主库失效且不可恢复，未复制给从库的写入将丢失半同步复制兼顾了同步与异步二者的优点复制成本增加 注：半同步的复制架构，是为主库设置一个同步的从库和一个异步的从库
如何确保新增的从库拥有主库数据的精确副本？
在不锁定主库的情况下，获取某个时刻主库的快照（ps MySQL 中可以使用 innobackupex 将快照复制到新的从库节点
从库连接主库，并拉取快照之后发生的所有数据变更。这要求快照与主库复制日志中的位置精确关联。当从库处理完快照之后积压的数据变更，我们就说它赶上了主库。即可以继续处理主库上产生的数据变化。 如何处理节点宕机？
从库失效——追赶恢复
主库失效——故障切换
注1：故障切换（failover）—— 将一个从库提升为新的主库，重新配置客户端，以将它们的写操作发送给新的主库，其他从库拉取来自新主库的变更，着整个过程我们称之为故障切换。
注 2：主库的故障切换在细节处理上会有一系列问题，比如提升异步复制的从库会丢失掉部分数据、两个节点都认为自己是主库（脑裂）、标记主库的不可用的超时时间如何设置……等。
3.3 复制的实现 主库与从库之间的数据复制如何实现？——「魔鬼藏在细节里」
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce88cc35842d38677595ebbea3b9f2af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6304bd0200fbee98f10a9fc2182d0757/" rel="bookmark">
			Java获取当前时间的小时/分钟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java获取当前时间的小时/分钟等。。。 方法一：
Date date = new Date(); int hours = date.getHours(); 方法二：
GregorianCalendar calendar = new GregorianCalendar(); int hour = calendar.get(Calendar.HOUR_OF_DAY); System.out.println("hour=" + hour); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f45cffbc62a0357a92d6bae0fa11a8/" rel="bookmark">
			screen安装使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux screen命令用于多重视窗管理程序。 screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。 1、screen安装
1)通过以下链接获取screen rpm包：
链接：https://pan.baidu.com/s/1o_t2Ueg37euUFC2ZQj0p0Q 提取码：1234 2)将该rpm包上传至node的/root/路径下，通过以下命令进行安装：
rpm -ivh screen-4.1.0-0.25.20120314git3c2946.el7.x86_64.rpm 2、screen使用
语法
screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s &lt;shell&gt;][-S &lt;作业名称&gt;] 参数说明：
-A 将所有的视窗都调整为目前终端机的大小。 -d&lt;作业名称&gt; 将指定的screen作业离线。 -h&lt;行数&gt; 指定视窗的缓冲区行数。 -m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。 -r&lt;作业名称&gt; 恢复离线的screen作业。 -R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。 -s&lt;shell&gt; 指定建立新视窗时，所要执行的shell。 -S&lt;作业名称&gt; 指定screen作业的名称。 -v 显示版本信息。 -x 恢复之前离线的screen作业。 -ls或--list 显示目前所有的screen作业。 -wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。 实例
1）创建 screen 终端
# screen //创建 screen 终端 2）创建 screen 终端 并执行任务
# screen vi ~/main.c //创建 screen 终端 ，并执行 vi命令 3）在screen终端下按下Ctrl+a+d键，离开screen终端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8f45cffbc62a0357a92d6bae0fa11a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd702eb05f24f9ae170a50f3d754b0ac/" rel="bookmark">
			【Golang】七、基础篇 --- 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法 一、方法定义二、方法中的变量传递1、结构体变量传值2、String()方法 三、工厂模式的引入四、方法和函数的区别 一、方法定义 什么是方法？
方法是作用于自定义数据类型上的，只可以由该数据类型声明的变量调用！
定义：func (type type) funcName(行参列表) (返回列表) { }
调用：变量.函数名(实参列表)
案例1：自定义结构体绑定的方法
type Utils struct { M int N int } func (util Utils) PrintJX() (area int) { for i := 0; i &lt; util.M; i++ { for i := 0; i &lt; util.N; i++ { fmt.Print("*") } fmt.Println() } area = util.M * util.N return } func main() { // 调用 util := Utils{1,2} util.PrintJX() } 案例2：自定义数据类型绑定的方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd702eb05f24f9ae170a50f3d754b0ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76cffac770755fe0532a55e24c9b4022/" rel="bookmark">
			vue 解决:Error in v-on handler: “TypeError: Cannot read property ‘compareTo‘ of undefined“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue 解决:Error in v-on handler: “TypeError: Cannot read property ‘compareTo‘ of undefined“ 解决方法:这里必须是$refs和ref对应,并且调用的compareTo需要名称一致 一定要仔细检查调用的名称 大小写不能乱
用于下滑加载数据 可视区 getBoundingClientRect用于获取某个元素相对于视窗的位置集合。集合中有top, right, bottom, left等属性。
1.语法：这个方法没有参数。
rectObject = object.getBoundingClientRect();
2.返回值类型：TextRectangle对象，每个矩形具有四个整数性质（ 上， 右 ， 下，和左 ）表示的坐标的矩形，以像素为单位。
rectObject.top：元素上边到视窗上边的距离;
rectObject.right：元素右边到视窗左边的距离;
rectObject.bottom：元素下边到视窗上边的距离;
rectObject.left：元素左边到视窗左边的距离;
mounted(){ //优化 每隔一段时间 去执行 不用频繁 需要节流函数 this.scrollHandler = throttle(300,this.scroll.bind(this)); window.addEventListener("scroll",this.scrollHandler) //bind指向当前实例 }, destroyed(){//销毁 window.removeEventListener("scroll",this.scrollHandler) }, methods:{ //事件解绑 scroll(){ if(this.isloading) return; console.log(123) if(this.$refs.waterfall.getBoundingClientRect().bottom &lt; document.documentElement.clientHeight){ //判断下面的高度是否小于初始的高度 //getBoundingClientRect用于获取某个元素相对于视窗的位置集合。 console.log("到达可视区") this.isloading=true; this.$emit("view") } } } addEventListener() 方法用于向指定元素添加事件句柄。 JavaScript中Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76cffac770755fe0532a55e24c9b4022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65012ffcd50b0efe445db1bc92d8454f/" rel="bookmark">
			经纬度与墨卡托之间的转换（matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经纬度转墨卡托
gpstoMercator.m
function [jing,wei] = gpstoMercator(j,w ) jing = j * 20037508.34 / 180; ly = log(tan((90+ w)*pi/360))/(pi/180); wei = ly *20037508.34/180; end 墨卡托转经纬度
MercatorToGps.m
function [jing,wei] = MercatorToGps(j,w ) jing = j/ 20037508.34 * 180; ly= w/ 20037508.34 * 180; wei = 180 /pi * (2 *atan(exp(ly *pi / 180)) - pi / 2); end 举例：
%******************************************************************************* % 根据某点四元数与GPS计算出其雷达坐标系的经纬坐标 %******************************************************************************* clc %导入旋转矩阵 l_i_z=0.2; %手测沿惯导坐标系z轴平移 l_i_x=0.1; %手测沿惯导坐标系x轴平移 l_i_z2=0.14; %手测沿惯导坐标系z轴平移(到雷达中心高度) a=40; %手测沿惯导坐标系y轴旋转角度 R=imutolidar(l_i_z,l_i_x,l_i_z2,a); %打开txt数据 F=importdata('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65012ffcd50b0efe445db1bc92d8454f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71dc299b190d201063b4d3d4f61fec5a/" rel="bookmark">
			workspace.xml分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project version="4"&gt; &lt;component name="ArtifactsWorkspaceSettings"&gt; &lt;artifacts-to-build&gt; &lt;artifact name="ssm-demo01:war exploded" /&gt; &lt;/artifacts-to-build&gt; &lt;/component&gt; &lt;component name="AutoImportSettings"&gt; &lt;option name="autoReloadType" value="SELECTIVE" /&gt; &lt;/component&gt; &lt;component name="ChangeListManager"&gt; &lt;list default="true" id="28a78fd1-de97-467c-98d4-60ba93bf3416" name="Default Changelist" comment="第二次提交" /&gt; &lt;option name="SHOW_DIALOG" value="false" /&gt; &lt;option name="HIGHLIGHT_CONFLICTS" value="true" /&gt; &lt;option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" /&gt; &lt;option name="LAST_RESOLUTION" value="IGNORE" /&gt; &lt;/component&gt; &lt;component name="FileTemplateManagerImpl"&gt; &lt;option name="RECENT_TEMPLATES"&gt; &lt;list&gt; &lt;option value="web.xml" /&gt; &lt;option value="mybatis-config" /&gt; &lt;option value="applicationContext" /&gt; &lt;option value="Interface" /&gt; &lt;option value="Mapper.xml" /&gt; &lt;option value="Class" /&gt; &lt;option value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71dc299b190d201063b4d3d4f61fec5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f188e71a8da90e3b3a5e380582c42a/" rel="bookmark">
			李宏毅2020机器学习2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		李宏毅2020机器学习2 10. Classification10.1 Generative model 生成模型 11. Logistic Regression12. Deep Learning13. Backpropagation14. Tips for Deep Learning15. 为什么选择deep15.1. Modularization15.2. End-to-end Learning 16. PyTorch 介绍16.1. tensor.view16.2. Broadcasting16.3. Computation graphs16.4. CUDA Semantics16.5. PyTorch是一个自动微分框架16.6. 梯度的使用16.7. Linear Regression16.8. torch.nn.Module16.9. Activation functions16.10. Sequential16.11. Loss functions16.12. optim16.13. 使用PyTorch实现线性回归16.14. 神经网络16.15. CrossEntropyLoss 17. Convolutional Neural Network18. Graph Neural Network 10. Classification 分类应用很多，例如：
Credit scoring：Input: income, savings, profession, age, …, Output: accept or refuse
Medical Diagnosis: Input: current symptoms, age, gender, …, Output: which kind of diseases
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4f188e71a8da90e3b3a5e380582c42a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b424a571c00736f46c074469b71fd962/" rel="bookmark">
			MySQL XtraBackup 备份原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现原理：
XtraBackup基于InnoDB的crash recovery机制，在备份还原时利用redo log得到完整的数据文件，并通过全局读锁，保证InnoDB数据与非InnoDB数据的一致性，最终完成备份还原的功能
由于是热备操作，在备份过程中可能有持续的数据写入，直接复制出来的数据文件可能有缺失或被修改的页，而redo log记录了InnoDB引擎的所有事务日志，可以在还原时应用redo log来补全数据文件中缺失或修改的页。所以为了确保redo log一定包含备份过程中涉及的数据页，需要首先开始复制redo log
全备流程 1. 复制已有的redo log，然后监听redo log变化并持续复制
2. 复制事务引擎数据文件 3. 等到数据文件复制完成
4. 加锁：全局读锁
5. 备份非事务引擎数据文件及其他文件
6. 获取binlog点位信息等元数据
7. 停止复制redo log
为什么要先停止复制redo log，再解锁全局读锁？
也是因为要保证“非事务资源与事务资源的一致性”，保证通过redo log回放后的InnoDB数据与非InnoDB数据都是处于读锁期间取得的位点。
8. 解锁：全局读锁
9. 复制buffer pool dump
10. 备份完成
全备还原流程
1. 模拟MySQL进行recover，将redo log回放到数据文件中
2. 等到recover完成
3. 重建redo log，为启动数据库做准备
4. 将数据文件复制回MySQL数据目录
5. 还原完成
在recover完成后，InnoDB数据与非InnoDB数据是达成一致的吗
InnoDB数据会被恢复至备份结束时(全局读锁时)的状态，而非InnoDB数据本身即是在全局读锁时被复制出来，它们的数据一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a75739aa69b20937ce38acd7d2ae4b99/" rel="bookmark">
			模糊连接度分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 相对模糊连接度 迭代模糊连接度 基于尺度的亲和度 基于向量场的亲和度 参考资料 https://github.com/joakimlindblad/FuzzConn 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dea82b8ae2175cce8454cdda2df6a16/" rel="bookmark">
			模糊连接度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用OpenCV实现模糊连接度分割（Fuzzy Connectedness Segment）。
概述 随机性和模糊性是两种不同的不确定性，概率论用于前者，而模糊集合则用于出来后者。由于模糊集合理论能够很好地表述和处理不确定性问题，所以模糊集合理论在图像分割领域获得广泛应用。由于在模糊集合中，图像地一个像素属于一个边界点或某个区域是用一个隶属度表示的，因此这样就可以避免过早地做出明确判断，已便为更高级地处理保留尽可能多的信息。
在传统集合理论中，一个元素或者属于一个集合，或者不属于一个集合。但在实际问题中，往往需要表示元素对集合从属关系的不确定性。1965年，Zadeh提出模糊数学的概念，用来描述这种带有模糊不确定性的现象和事物。传统图像分割方法在面对边界本身就是不清晰的目标物体时，很难准确定义目标物体的区域。一种自然的方法就是用模糊性来描述图像。 在图像处理中，“连接”用来描述图像的拓扑关系及区域的熟悉。1979年，Rosenfeld首先将“连接”扩展到模糊集领域，描述无法精确定义的区域。在此基础上，Upupa提出了基于模糊连接度的图像分割框架。其主要思想是：每两个相邻的像素组成一条连边，将隶属函数应用于此连边，该函数输出一个0到1之间的隶属度值来表示连边属于感兴趣对象的程度，在此基础上建立像素到待分割目标之间的相似关系，此关系称为模糊连接。并依此关系来度量像素对的目标从属程度。
许多图像分割算法都是基于各个区域之间（或区域内）的硬编码关系,模糊算法考虑了各种不确定性，例如噪声，不均匀的照度/亮度/对比度差异.FC已经在医学（和其他）图像中获得了巨大的成功
Udupa和Samarasekera是最早在医学图像中使用FC的人(Graphical Models and Image Processing, 1996).FC Family
• Absolute FC
• Scale-based FC (b-, t-, g-scale based)
• Relative FC
• Iterative Relative FC
• Vectorial FC
• Hierarchical FC
• Model-based FC
基本概念 结合《Fuzzy Connectedness and Object Definition: Theory, Algorithms,
and Applications in Image Segmentation》介绍相关概念。
模糊集,隶属函数和模糊关系 介绍模糊集(Fuzzy Subsets),隶属函数(Membership Function)
和模糊关系(Fuzzy Relation)
模糊邻近关系,模糊数字空间 模糊邻近关系(Fuzzy Spel Adjacency),模糊数字空间(Fuzzy Digital Space)
模糊邻近关系描述的是两个空间元素之间的位置关系。
场景,隶属度场,二值场 场景(Scenes),隶属度场(Membership Scenes),二值场(Binary Scenes)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dea82b8ae2175cce8454cdda2df6a16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5712766c201d59ce35dac48a38d9bda/" rel="bookmark">
			RS232与RS485波形分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常遇到初学者，对单片机串行通讯出了问题不知道如何办的情况。其实最有效的调试方法是用示波器观察收发数据的波形。通过观察波形可以确定以下情况： 是否有数据接收或发送； 数据是否正确； 波特率是否正确； 一、串行数据的格式
异步串行数据的一般格式是：起始位+数据位+停止位，其中起始位1 位，数据位可以是5、6、7、8位，停止位可以是1、1.5、2位。
起始位是一个值为0的位，所以对于正逻辑的TTL电平，起始位是一位时间的低电平；停止位是值为1的位，所以对于正逻辑的TTL电平，停止位是高电平。线路路空闲或者数据传输结束，对于正逻辑的TTL电平，线路总是1。对于负逻辑(如RS-232电平)则相反。
例如，对于16进制数据55aaH，当采用8位数据位、1位停止位传输时，它在信号线上的波形如图1(TTL电平)和图2(RS-232电平)所示。 （先传第一个字节55，再传第二个字节aa，每个字节都是从低位向高位逐位传输）
图1 TTL电平的串行数据帧格式(55aah)
图2 RS-232电平的串行数据帧格式(55aah)
二、根据波形图计算波特率
如图3是图1在示波器中的显示示意，其中灰色线是示波器的时间分度线，此时假设是200us/格。
图3 波特率计算示意图
可以看了，第一个字节的10位(1位起始位，8位数据位和1位停止位)共占约1.05ms，这样可计算出其波特率约为：
10bit / 1.05ms X 1000 ≈ 9600 bit/s
如果上图中的时间轴是100us/格，同样可以计算出波特率应是19200bit/s。
当通讯不正常，又能观察到波形时，就可根据上述方法，从波形图计算一下波特率是否正确。
三、根据波形图判断RS-485收发数据的正确与否
RS-485是一种半双工的串行通讯方式（RS-422为全双工），485电平芯片所以要正确接收和发送数据，必需保证控制信号和数据的同步，否则要么发送数据丢失，要么接收数据可能丢失。
RS-485发送数据时的正确时序如图4所示。
图4 RS-485的正确发送数据时序
在图4中，发送控制信号的宽度基本与数据信号的宽度一致，所以能保证发送数据的正确和发送后及时转为接收。
图5 和图6 分别是控制信号太短和控制信号太长
图5 RS-485控制信号太短时的时序
图6 RS-485控制信号太短时的时序
在图5中，由于控制信号关闭过早，则第二个字节的后两位将发送错误；在图6中，由于控制信号关闭过迟，使485芯片在发送数据后，不能及时转到接收状态，此时总线若有数据过来，则本单元将不能正确接收。
总结：只要掌握上述波形分析方法，任何异步串行数据的接收和发送问题，基本都可以得到解决。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/318/">«</a>
	<span class="pagination__item pagination__item--current">319/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/320/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>