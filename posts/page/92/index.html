<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/729307aa18462ed7faf617d6889e7aa4/" rel="bookmark">
			Pytorch load模型出错：_pickle.UnpicklingError: invalid load key, ‘＜‘.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在torch.load时候报错：
Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/usr/local/lib/python3.7/dist-packages/torch/serialization.py", line 795, in load return _legacy_load(opened_file, map_location, pickle_module, **pickle_load_args) File "/usr/local/lib/python3.7/dist-packages/torch/serialization.py", line 1002, in _legacy_load magic_number = pickle_module.load(f, **pickle_load_args) _pickle.UnpicklingError: invalid load key, '&lt;'. 结论：模型文件损坏，检查模型大小（大概率没下载完整），重新（手动）下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca6e5c64345fcbff1b3a96906b1d966/" rel="bookmark">
			解决Windows11系统目录winmmbase.dll文件丢失出现错误问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实很多用户玩单机游戏或者安装软件的时候就出现过这种问题，如果是新手第一时间会认为是软件或游戏出错了，其实并不是这样，其主要原因就是你电脑系统的该dll文件丢失了或没有安装一些系统软件平台所需要的动态链接库，这时你可以下载这个winmmbase.dll文件(挑选合适的版本文件)把它放入到程序或系统目录中，当我们执行某一个.exe程序时，相应的DLL文件就会被调用，因此将缺失的文件放回到原目录之后就能打开你的软件或游戏了.
那么出现winmmbase.dll丢失要怎么解决？
一、手动从网站下载单个dll文件 1、从下面列表下载winmmbase.dll文件
32/64位 文件:
winmmbase.dll
2、将下载的文件放入到你要运行的软件或者游戏的安装所在文件夹之中，可以右键点击主执行程序.exe然后选择"打开文件所在的位置" 找到安装目录，将文件复制进去。
或者将文件复制到Windows系统目录，这个需要注意电脑的系统是32位还是64位，如果是32位的系统，那就将本站下载32位的dll文件放到“C:/Windows/System32”这个文件夹里面,如果是64位的系统，那就将本站下载的32位dll文件放到“C:/Windows/SysWOW64”这个文件夹里面,本站下载的64位文件放到“C:/Windows/System32”这个文件夹里面.
如果问题依然无法解决，值得注意的是此类文件的丢失有时候和杀毒软件的误报毒有关，所以请将此类dll文件添加到杀毒软件的信任列表当中.
二、使用DLLEscort软件进行自动修复 DLLEscort软件能够修复解决常见的Windows系统文件与系统所需的大部分运行库，它可以帮助您一键修复系统软件或游戏丢失的DLL运行库文件，节省您的宝贵时间。 如果是因为缺少了运行库 导致的提示文件找不到错误 通常当你单独下载了一个文件放入到目录后，程序可能还会立即提示又丢失了另外一个文件，所以建议大家使用DLLEscort软件一键修复解决系统缺少运行库的问题，软件可随Windows系统长久的使用，每次重新安装系统后也可以使用它修复一次，以保障各软件或游戏在此后的平稳运行. 软件能够修复常见的Windows系统dll文件; DirectX游戏运行库; Microsoft Visual C++运行库; 其它常用运行库等.
DLLEscort软件支持32/64位 Windows XP,Windows Vista, Windows 7, Windows 8, Windows 8.1, Windows 10 操作系统,Windows 11 操作系统
下载地址：本站下载下载完成后得到安装包文件运行后，点击Next下一步进行安装，安装完毕后会自动打开软件或手动执行桌面主程序(DLLEscort)即可打开软件，
一、点击 "扫描系统" --&gt; "扫描" 开始对系统所需文件扫描
二、扫描完成，扫描结果分成三部分，包括1，待修复的丢失文件。 2，待修复的注册表。 3.待清理的系统缓存文件。
三、点击”修复全部”修复开始，请保持网络正常,直到所有问题修复完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/265d87d94b621abc4bfd60fa9a2c2903/" rel="bookmark">
			K-Lite Mega Codec 怎么安装使用？K-Lite Mega Codec 安装使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K-Lite Mega Codec 怎么安装使用？K-Lite MegaCodec具有兼容性好、内存小、启动速度快等功能，是一款非常好的解码器。那么，K-Lite Mega Codec要怎么安装使用呢，下面就给大家分享具体步骤。
1、下载K-Lite Mega Codec Pack安装包。这里给出的是个安装包，双击运行（直接打开）开始安装过程。Windows中可能会在打开此安装包的时候弹出一个安全警告，如下图0所示，因为此安装包没有有效的证书。从这里下载的安装包是比较安全的，直接单击“运行”按钮即可。
图 0 Windows 中打开文件时的安全警告
2、开始安装。如图1。这里没什么好说的，直接 Next 》 进入下一步。修订的时候这个界面仅仅是版本号不一样，就没有重新做图，无碍。
图1 K-Lite Mega Codec Pack 开始安装
3、选择安装模式。下面的图2是用 K-Lite Codec Pack 截的，但是除了标题外别的都一样。K-Lite Codec Pack 只是比K-Lite Mega Codec Pack 少了对播放视频不重要的几个组件。
图2 K-Lite Mega Codec Pack 安装模式选择
共有三种模式可选：
简单模式：提供较少的自定义选项（可选择使用的播放器、设备的扬声器类型），多数选项都按照默认设置
一般模式：所有选项（可选择是否安装 Media Player Classic 播放器） ，默认安装位置
高级模式：所有选项，可选安装位置
根据需要选择一种即可。下面以“高级模式”为例，因为它的步骤中包含了前面 2种模式里的所有步骤。所以，如果你选择了前面的某个模式来安装，下面的步骤可以跳着看。
提示：在最后确认安装之前，你还可以返回到这里重新选择安装模式。
4. 选择安装位置。默认是安装在 Windows系统默认的程序文件夹中。看你的习惯，改不改都一样。如果要改，单击下图中中间靠右的那个按钮，浏览选择安装位置即可。然后单击下面的 Next 》。
K-Lite Mega Codec Pack 选择安装位置
5、选择组件，如下图所示。MPC（Media PlayerClassic）是一个非常受欢迎的播放器，多平台支持。实际上看各自的习惯吧，根据你的需要决定是否要把图中红框所圈部分都取消选择 。默认是选中的。
其它的各个组件不用做修改，保持默认就行了，然后 Next 》 进入下一步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/265d87d94b621abc4bfd60fa9a2c2903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7247eb026c7d2ce87b667707fd37a596/" rel="bookmark">
			Error:Kotlin: Module was compiled with an incompatible version of Kotlin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端项目debug运行时出现标题所示的错误，字面意思就是说模块在不相容的Kotlin版本中编译，试过Invalidate Caches / Restart（清缓存重启）以及clean--&gt;compile操作两种方法均无效，现总结解决方法如下：在IDEA工具栏中找到Build，点进去执行Rebuild Project。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd0eb614bc882488b081017c76278af/" rel="bookmark">
			Jdk8 动态编译 Java 源码为 Class 文件（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jdk8 动态编译 Java 源码为 Class 文件 一.JDK版本二.工程介绍1.依赖2.启动类3.配置类（用于测试依赖注入）4.工具类1.Java 源码文件读取类2.SpringBoot 容器实例管理类 5.测试类1.抽象类2.接口类3.默认抽象实现4.默认接口实现 6.接口类1.测试接口2.类重载控制接口 7.动态编译类1.类加载器2.类管理器3.类对象4.Java 文件类 8.配置文件 三.测试1.测试用类1.测试类原类修改 2.测试1.原类直接打印2.原类修改 四.Jar 反编译记录 一.JDK版本 二.工程介绍 动态源码编译需要自定义类加载器，JVM会根据所属类加载器和全类名判断是否为同一个类，所以动态编译和加载时，同一个类无法用同一个类加载器加载两次，除非从 JVM 层面移除旧的类。
同一个类由不同类加载器加载时，JVM 会判断为非同类，所以无法直接实例化后强转为同一类型的实例，需要基于接口、抽象类来实现动态替换
1.依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;spring-dynamic&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;2.7.4&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdd0eb614bc882488b081017c76278af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b995250c0a56f3b96765324f0ce3c642/" rel="bookmark">
			codeium使用方法（自动生成代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		codeium使用方法 Codeium是一款轻量级的代码编辑器，它可以帮助用户高效地编写代码。本文将介绍如何使用Codeium进行代码编写。 一、安装Codeium Codeium是一款跨平台的编辑器，可以在Windows、Mac和Linux上运行。用户可以在官网上下载对应的安装包进行安装。安装完成后，打开Codeium即可开始使用。 二、新建文件 在Codeium中新建文件非常简单，用户只需点击菜单栏中的“File”，然后点击“New File”即可。用户也可以使用快捷键Ctrl+N（Windows和Linux）或Cmd+N（Mac）来快速新建文件。 三、编写代码 Codeium支持多种编程语言，用户可以根据自己的需要选择相应的语言进行编写。在Codeium中，用户可以使用自动缩进和代码高亮等功能来提高编写代码的效率。 四、保存文件 在Codeium中，用户可以使用菜单栏中的“File”来保存文件。用户也可以使用快捷键Ctrl+S（Windows和Linux）或Cmd+S（Mac）来快速保存文件。用户需要注意的是，Codeium会自动保存文件，但是最好还是手动保存一次，以防止意外情况的发生。 五、运行代码 Codeium提供了一些运行代码的方式，用户可以根据自己的需要选择相应的方式。其中，用户可以使用菜单栏中的“Run”来运行代码。用户也可以使用快捷键F5来快速运行代码。用户需要注意的是，不同的编程语言可能有不同的运行方式，用户需要根据具体情况进行选择。 六、调试代码 Codeium提供了一些调试代码的功能，用户可以根据自己的需要选择相应的功能。其中，用户可以使用菜单栏中的“Debug”来进行调试。用户也可以使用快捷键F6来快速进行调试。用户需要注意的是，不同的编程语言可能有不同的调试方式，用户需要根据具体情况进行选择。 七、插件管理 在Codeium中，用户可以通过安装插件来扩展其功能。用户可以使用菜单栏中的“Plugins”来进行插件管理。用户可以从官方插件库中选择需要的插件进行安装。 八、主题管理 在Codeium中，用户可以通过更改主题来改变编辑器的外观。用户可以使用菜单栏中的“View”来进行主题管理。用户可以从官方主题库中选择需要的主题进行更改。 总结：Codeium是一款功能简单但实用的编辑器，它非常适合初学者和轻量级用户使用。在使用过程中，用户可以根据自己的需求进行插件和主题的管理，以提高编写代码的效率和舒适度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20da703f1e2ce0247d753d7d673c7250/" rel="bookmark">
			探索GitHub上最受欢迎的Python项目：2023年9月第3周热门推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索GitHub上最受欢迎的Python项目：2023年9月第3周热门推荐 GitHub 是全球最大的开源代码托管平台，每天都有数以千计的开发者在这里分享他们的创意和技术成果。这里给大家分享一下GitHub 9月第3周热门的python项目：AI肖像画、简历匹配器、高铁动车购票助手、演唱会抢票器，问答机器人等等。更多精彩项目，等着我们去发掘。
项目Top1: /KillianLucas/open-interpreter stars总数量: 23,057forks数量: 1,885本周新增stars数量: 8,178项目简介:这个项目是OpenAI开发的一个代码解释器,可以在终端上本地运行。可以帮助用户更方便地编写和测试代码,提高编程效率。无需连接到互联网,可以在本地使用解释器,保护代码安全。它还支持多种编程语言,包括Python、JavaScript和Ruby等。 项目Top2: /XPixelGroup/DiffBIR stars总数量: 1,632forks数量: 87本周新增stars数量: 738项目简介:董超团队提出的DiffBIR:利用生成扩散先验实现盲图像复原的官方源码。 项目Top3: /OpenBMB/ChatDev stars总数量: 5,696forks数量: 547本周新增stars数量: 1,516项目简介:这个项目是利用自然语言思维(通过多智能体协作)来创建定制化软件的。它的价值在于可以让非技术人员也能够轻松地创建自己所需的软件,而不需要具备编程技能。通过多智能体协作,可以实现更高效的软件开发过程,同时也可以提高软件的质量和可靠性。 项目Top4: /guoyww/AnimateDiff stars总数量: 3,571forks数量: 286本周新增stars数量: 454项目简介:AnimateDiff的官方实现。它可以帮助用户快速生成动画效果,使得数据可视化更加生动形象。这个项目的实现非常简单易用,可以让用户轻松地创建出高质量的动画效果。 项目Top5: /baichuan-inc/Baichuan2 stars总数量: 1,587forks数量: 84本周新增stars数量: 607项目简介:这个项目是由百川智能科技开发的一系列大型语言模型。Baichuan 2 是百川智能推出的新一代开源大语言模型,采用 2.6 万亿 Tokens 的高质量语料训练。Baichuan 2 在多个权威的中文、英文和多语言的通用、领域 benchmark 上取得同尺寸最佳的效果。本次发布包含有 7B、13B 的 Base 和 Chat 版本,并提供了 Chat 版本的 4bits 量化。 项目Top6: /microsoft/promptflow stars总数量: 1,938forks数量: 142本周新增stars数量: 1,203项目简介:这个项目的价值在于它提供了一套完整的解决方案,帮助开发者从原型设计、测试到生产部署和监控,构建高质量的LLM应用程序。 项目Top7: /facebookresearch/nougat stars总数量: 4,923forks数量: 295本周新增stars数量: 1,372项目简介:这是Nougat的官方存储库,它是一个了解LaTeX数学和表格的学术文档PDF解析器。 项目Top8: /aigc-apps/sd-webui-EasyPhoto stars总数量: 1,562forks数量: 113本周新增stars数量: 431项目简介:EasyPhoto是一款Webui UI插件,用于生成AI肖像画,该代码可用于训练与您相关的数字分身。建议使用 5 到 20 张肖像图片进行训练,最好是半身照片且不要佩戴眼镜(少量可以接受)。训练完成后,我们可以在推理部分生成图像。我们支持使用预设模板图片与上传自己的图片进行推理。 项目Top9: /ECTO-1A/AppleJuice stars总数量: 801forks数量: 67本周新增stars数量: 363项目简介:该项目是一个针对苹果设备的蓝牙低功耗(BLE)接近配对信息欺骗的工具。它可以模拟苹果设备发送的BLE接近配对信息,从而欺骗其他设备认为它们已经配对。这个项目的价值在于它可以用于测试和评估设备的安全性,以及在实际应用中用于攻击和防御。通过使用这个工具,用户可以更好地了解BLE接近配对的安全性,并采取相应的措施来保护自己的设备。 项目Top10: /fishaudio/Bert-VITS2 stars总数量: 669forks数量: 124本周新增stars数量: 164项目简介:基于Bert-VITS2的原神+崩铁全角色文本转语音实现,这个项目可以将文本转换为原神任意角色的语音。 项目Top11: /srbhr/Resume-Matcher stars总数量: 2,795forks数量: 513本周新增stars数量: 805项目简介:这是一个开源免费的简历匹配器工具,可以比较简历和职位描述,并创建一个得分来排名它们,整个过程如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20da703f1e2ce0247d753d7d673c7250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c5de3c4f6a09a112b2f655155b319a2/" rel="bookmark">
			如何通过bat批处理实现快速生成文件目录，一键生成文件名和文件夹名目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		碰对了情人，相思一辈子。
具体方法步骤：
一、创建一个执行bat文件（使用记事本即可）；
1、新建一个txt文本空白记事本文件
2、复制以下内容进记事本内
dir/a/s/b&gt;LIST.TXT
（其中LIST.TXT文件名是提取后将要自动新建的文本文件）
二、记事本保存，文件名可以任意写
三、把保存的文件名后缀.txt改为.bat，这样就形成了一个可以执行的文件
四、把改了名的文件复制到需要输出文件夹和文件名称的文件夹内
五、双击运行bat文件，文件夹会自动生成LIST.TXT文件，里面就包含了该文件夹下的所有文件名称。
附注：
/b是去掉多余信息，其中把/a改/ad 表示只要文件夹，如果改成/a-d则是只要文件，如：
dir/ad/s/b&gt;LIST.TXT （只要文件夹名列表）
dir/a-d/s/b&gt;LIST.TXT（只要文件名列表）
更多命令： dir /b &gt;LIST.TXT （输出干净的文件名，不包括文件夹名）
dir /s /n &gt;list.txt（输出文件名和文件夹列表，并包含文件信息。）
此种方法一次制成批处理文件，可以长期使用，不用每次都新建bat批处理文件或者cmd批处理文件。
你可以使用 Windows 的批处理文件（.bat）来实现快速生成文件目录和一键生成文件名与文件夹名目录的操作。下面是两种常用的方法：
方法一：快速生成文件目录 以下是一个示例的批处理脚本，它可以在指定的路径下创建多层文件夹：
@echo off
setlocal enabledelayedexpansion
set "baseDir=C:\Your\Directory" REM 指定要创建目录的基础路径
for %%i in (Folder1 Folder2 Folder3) do (
set "dirPath=!baseDir!\%%i"
mkdir "!dirPath!"
echo Created directory: "!dirPath!"
)
echo All directories created.
pause
将 baseDir 的值更改为你想要创建目录的基础路径。在 for 循环中，可以列出要创建的目录的名称，例如 Folder1、Folder2 和 Folder3。这个批处理脚本会在基础路径下创建指定的目录，并在命令行中显示创建的目录名称。 方法二：一键生成文件名与文件夹名目录 以下是另一个示例的批处理脚本，它可以在指定的路径下创建多层文件夹，并在每个文件夹中创建相同名称的文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c5de3c4f6a09a112b2f655155b319a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33ca6b7d4cb33395af133d455a0b06a/" rel="bookmark">
			进程 线程 协程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同步、异步
同步是有序运行，同步操作时后面的任务要等待当前任务返回才运行；
异步则是相反，其他任务不需要等待当前调用返回，结果通常依靠事件、回调返回。
是同步或轮询查看事情进展，还是等异步通知
阻塞、非阻塞
阻塞状态时，当前线程无法从事其他任务，只有条件就绪才能继续；
非阻塞是不管io是否完成都直接返回，相应操作在后台继续处理。
等着完成或是不等
1、进程
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
2、线程
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
3、协程
协程又称微线程,是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。
栈： 用户维护函数调用上下文。由高地址向低地址生长，通常以M为单位，由操作系统维护。
[不能申请占用过大的内存的局部变量，会导致栈爆掉而core.如果变量太大，可以考虑放到全局变量区或者使用堆]
堆： 动态申请内存，即使用new or malloc等分配到的内存，可以比栈大很多，需用户自己释放
[new/delete,malloc/free成对出现，否则会导致内存泄露，可以使用查找内存泄露的工具监控或者自己写代码监控]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e97e6511f526cb32cf498df02b2ed38/" rel="bookmark">
			latex里的box
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		水平盒子 \makebox[5em][l]{text} % [长度][对齐] 水平盒子只有一行. 不会自动换行. 文字的对齐方式有c(中), l(左), r(右)
水平带框盒子 \framebox[5cm][l]{text} 盒子会带框, 其他与上面一样.
竖直盒子 text1 \parbox[t]{5em}{text1} % [对齐]{长度} 盒子是竖直的, 对齐方式有c（中）、t（顶）、b（底）. 这里的对齐指左边的text1与box的顶部还是底部对齐.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1638004dd311105342b429cdde87e92e/" rel="bookmark">
			Flask 数据库 连接池、DBUtils、http 连接池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、DBUtils 简介、使用 DBUtils 简介 DBUtils 是一套用于管理 数据库 "连接池" 的Python包，为 "高频度、高并发" 的数据库访问提供更好的性能，可以自动管理连接对象的创建和释放。并允许对非线程安全的数据库接口进行线程安全包装和连接。该连接可在各种多线程环境中使用。
使用场景：如果使用的是流行的对象关系映射器 SQLObject 或 SQLAlchemy 之一，则不需要 DBUtils，因为它们带有自己的连接池。SQLObject 2 (SQL-API) 实际上是从 DBUtils 中借用了一些代码，将池化分离到一个单独的层中。
DBUtils 提供两种外部接口：
PersistentDB ：提供线程专用的数据库连接，并自动管理连接。PooledDB ：提供线程间可共享的数据库连接，并自动管理连接。 另外，实际使用的数据库驱动也有所依赖，比如SQLite数据库只能使用PersistentDB作连接池。 下载地址：http://www.webwareforpython.org/downloads/DBUtils/
使用 DBUtils 数据库 连接池 安装：pip install DBUtils
示例：MySQLdb 模块使用 连接池对象只初始化一次，一般可以作为模块级代码来确保。 PersistentDB 的连接例子:
import DBUtils.PersistentDB # maxusage 则为一个连接最大使用次数 persist = DBUtils.PersistentDB.PersistentDB(dbpai=MySQLdb,maxusage=1000,**kwargs) # 获取连接池 conn = persist.connection() # 关闭连接池 conn.close() 参数 dbpai 指定使用的数据库模块，兼容 DB-API 。下面是支持 DB-API 2 规范的数据库模块
pip install pymysql（mysql）
pip install pymssql（sqlserver）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1638004dd311105342b429cdde87e92e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/564915589fd9de89504a0576ef0d44c8/" rel="bookmark">
			面试被问：Mysql的InnoDB下RR是如何解决幻读问题的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题应该分几方面来答 第一方面：什么是幻读 Mysql事务在并发下会产生脏读、不可重复读、幻读问题。
赃读：一个事务可以读到另一个事务还没有提交的数据；
不可重复读：一个事务可以读到另一个事务修改并提交的数据；
幻读：一个事务两次相同的范围查找，之间另一个事务对这个范围insert了一条数据并提交，导致这两次事务查找的结果不一致。
第二方面：事务的隔离级别 读未提交:简称RU,可以读到其他事务还没有提交的数据。所以会有脏读、不可重复读、幻读问题。
读已提交：简称RC,解决了赃读的问题，但是还是有不可重复读、幻读问题。
可重复读：解决了不可重复读问题，当前读还解决了幻读问题。
串行化：事务串行执行，效率低。
第三方面：RR是如何解决的 RR下的当前读（for update）会给范围查找的范围区间加上间隙锁或者临键锁，在这个区间加了间隙锁后就会阻塞其他事务对这个区间的数据插入，就解决了幻读问题
总结： RR解决幻读是通过当前读会加间隙锁，这样效率肯定会降低，如果我们的业务可以接受幻读和不可重复读的话，可以把隔离级别设置为RC,RC的当前读是不会加间隙锁的，RC只有记录锁，可以一定程度上提高我们程序的性能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b851df132b599828d10599654ee025d/" rel="bookmark">
			c语言中的rand（）函数和srand（）函数产生随机的整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中,rand()函数可以用来产生随机数，但是这不是真真意义上的随机数，是一个伪随机数，是根据一个数，我们可以称它为种子，为基准以某个递推公式推算出来的一系数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统，为了改变这个种子的值，C提供了srand()函数，它的原形是void srand( inta)。 可能大家都知道C语言中的随机函数random，可是random函数并不是ANSI C标准，所以说，random函数不能在gcc,vc等编译器下编译通过。
rand()会返回一随机数值，范围在0至RAND_MAX间。返回0至RAND_MAX之间的随机数值，RAND_MAX定义在stdlib.h，(其值至少为32767)我运算的结果是一个不定的数，要看你定义的变量类型，int整形的话就是32767。 在调用此函数产生随机数前，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。一般用for语句来设置种子的个数。具体见下面的例子。
一 如何产生不可预见的随机序列呢
利用srand((unsigned int)(time(NULL))是一种方法，因为每一次运行程序的时间是不同的。
在C语言里所提供的随机数发生器的用法：现在的C编译器都提供了一个基于ANSI标准的伪随机数发生器函数，用来生成随机数。它们就是rand()和srand()函数。这二个函数的工作过程如下：
1)首先给srand()提供一个种子，它是一个unsigned int类型，其取值范围从0~65535；
2)然后调用rand()，它会根据提供给srand()的种子值返回一个随机数(在0到32767之间)
3)根据需要多次调用rand()，从而不间断地得到新的随机数；
4)无论什么时候，都可以给srand()提供一个新的种子，从而进一步“随机化”rand()的输出结果。
下面是0~32767之间的随机数程序：
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; //使用当前时钟做种子 void main( void ) {int i; srand( (unsigned)time( NULL ) ); //初始化随机数 for( i = 0; i &lt; 10;i++ ) //打印出10个随机数 printf( " %d\n", rand() ); } 根据上面的程序可以很容易得到0~1之间的随机数：
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; main( ) {int i; srand( (unsigned)time( NULL ) ); for( i = 0; i &lt; 10;i++ ) printf( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b851df132b599828d10599654ee025d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec942b3672f43f8ac18635ce81714d9e/" rel="bookmark">
			FastJson——JSO字符串与对象的相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、FastJson介绍二、FastJson序列化 API2.1 JSON对象转换成字符串2.2 List集合转换成JSON对象2.3 Map集合转换成JSON对象 三、FastJSON反序列化3.1 JSON字符串转Object对象3.2 JSON字符串转List集合3.3 JSON字符串转Map集合 四、JSONObject对象4.1 JSON字符串转换成JSONObject4.2 从JSONObject中得到某一个封装数据4.3 将JSONObject对象中的key按照ASCII排序 五、关于将JSONObject之前返回前端的问题六、常用注解6.1 @JSONField6.1.1 指定字段在生成的JSON中的名称6.1.2 ordinal属性指定字段的序列化顺序6.1.3 format属性 一、FastJson介绍 ​ Fastjson是阿里巴巴的开源SON解析库它可以解析JSON格式的字符串，支持将java Bean序列化为ISON字符串，也可以从JSON字符串反序列化到JavaBean。
Fastjson的优点
速度快
fastjson相对其他JSON库的特点是快，从2011年fastjson发布1.1.版本之后其性能从未被其他ava实现的]SON库超越
使用广泛
fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一
测试完备
fastjson有非常多的testcase，在1.2.11版本中，testcase超过3321个。每次发布都会进行回归测试，保证质量稳定
使用简单
fastison的API十分简洁
功能完备
支持泛型，支持流处理超大文本，支持枚举，支持序列化和反序列化扩展
二、FastJson序列化 API 序列化： 将Java对象转换成JSON格式字符串的过程。
2.1 JSON对象转换成字符串 使用 JSON.toJSONString(Object object)； 方法
public class ObjectToJSON { public static void main(String[] args) { Student student = new Student("张三",20,"北京市","zhangjinfqi@qq.com"); String jsonString = JSON.toJSONString(student); System.out.println(jsonString); } } @Data @AllArgsConstructor @NoArgsConstructor public class Student { private String name; private Integer age; private String address; private String email; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec942b3672f43f8ac18635ce81714d9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba0e94d5f99c3242c074f2a75192946e/" rel="bookmark">
			【数据分享】2023年DEM地形数据（无需转发/全球/全国/分省/分市）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地形数据，也叫DEM数据，是我们在各项研究中最常使用的数据之一，通过地形数据我们可以分析地表的高程、坡度、坡向等信息！之前我们分享过来自于GEBCO这个组织的2022年的全球范围的DEM地形数据（戳我跳转）！
最近，该数据更新了2023年的数据，我们对数据进行了下载和处理分享给大家！概括来说：本次我们分享的是来自于GEBCO组织的2023年DEM地形数据！我们下载了全球范围的地形数据，并将全球数据拼接成一张地形图，此外我们还将数据裁剪成了全国范围的数据，以及裁剪为了全国各个省份的数据，和全国各个城市的数据，方便大家使用！数据格式为栅格（.tif）格式，数据单位为m，数据空间分辨率为 15 弧秒,精度相当于 500米左右，数据坐标为GCS_WGS_1984。
以下为数据的详细介绍：
01 数据预览 首先，我们先来看看全球范围的数据：
接着，我们来看看中国范围的数据：
接着，我们以湖北省为例来看看分省份的数据：
然后，我们以武汉市为例来看看分城市的数据：
02 数据详情
GEBCO是一个国际测绘专家组织，在国际水文组织 (IHO) 和政府间海洋学委员会(IOC) 的联合赞助下开发一系列测深数据集和数据产品。本次分享的DEM数据就是由GEBCO提供的2023年覆盖全球范围的包含陆地高程和海洋深度的数据。GEBCO栅格数据是整合许多国际和国家数据存储库和区域测绘计划的数据集而得到的连续的全球海洋和陆地地形模型，2023年数据是目前最新的测深数据集，数值单位为米，空间分辨率为 15 弧秒,精度相当于 0.5km左右。GEBCO_2023提供了两个版本的数据，一个是包含陆地和冰面高程信息，另一个版本还包含格陵兰岛和南极洲的冰下地形信息。以下为数据的详细指标：
坐标投影：
GCS_WGS_1984
数据格式：
.tif格式
空间分辨率：
15 弧秒（约500米）
数据来源网站：
大家如果下载原始数据，以及查看数据详情，点击该网站：
https://www.gebco.net/data_and_products/gridded_bathymetry_data/
引用方式：
GEBCO Compilation Group (2023) GEBCO 2023 Grid (doi:10.5285/f98b053b-0cbc-6c23-e053-6c86abc0af7b)
文末下方是我们的公众号名片，我们将定期介绍各类城市数据以及数据的可视化和分析技术，有关2023年DEM地形数据，欢迎大家多多关注我们进行了解！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/724acb07e6e36e584af677125e904e5f/" rel="bookmark">
			令人惊艳的AI项目，这也太猛了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是 Jack。
这两天，我在网上冲浪，发现了一款神器！
我在使用 AI 绘画 Stable Diffsuion 和 Midjourney 的时候，花费时间最多的就是写 prompt 描述词了，绞尽脑汁地调试 prompt。
同样，我在使用 ChatGPT、Llama 等对话大语言模型的时候，为了获得更好的结果，也需要按照一定的格式书写 prompt 内容。
想要写好 prompt 都需要具备一定的基础，也就是前期有一定的学习成本。
最近，我看到了一款非常不错的软件，能够帮助我们大幅节省 prompt 调优的时间，能够帮助我们又快又稳地生成我们想要的结果。
这软件就是 PromptPerfect，而且它的强大之处可不仅仅局限于生成提示词。
都有哪些强大的功能，我们一起体验下吧！
PromptPerfect 先放下官网地址（PC端体验最好）：
https://promptperfect.jinaai.cn/a/NEW
可以使用微信扫码登陆，非常方便，直接网页版在线使用。
PromptPerfect（以下简称 PP）功能非常丰富：
1、提示词 我们重点先聊下提示词优化。
大家都知道，大模型的使用门槛，已经转换到了Prompt 优化上。Prompt 优化是门学问。
想用好 AI 帮助我们提高工作效率，结果我们还要学习 Prompt 优化。那我要你何用？
那有没有一款工具，能够帮助我们做 Prompt 调优吗？PP 闪亮登场。
PP 的提示词功能就是针对这种需求的。
比如想要用 Stable Diffusion 生成好的图片效果，需要经过多次的 Prompt 调优，但有了 PP 就可以节省很大的精力。
在提示词功能里选中针对 SD 的优化模型后，输入原始文本：一张近景图，长相精致的女生在河边拍照。
PP 经过优化，输出优化好后的 Prompt，一共 113 字。
我们拿着这个 PP 输出的提示词，放到 SD 里生成图片，就得到了这样的结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/724acb07e6e36e584af677125e904e5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d421216fbfa1841e6704e43bec3f3709/" rel="bookmark">
			linux下各目录的大概含义 详细版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，根目录详解 以centos7为例
/：根目录，包含整个文件系统的基础目录。所有文件和目录的路径都是以根目录为起点的。
/bin：二进制可执行文件的目录，包含常用的命令和工具（如ls、cp、mv等）。这里存放的命令通常可以被普通用户使用。
/dev：设备文件目录，包含与硬件设备和外部设备的连接点，例如硬盘、USB 设备、串口等等。这里的所有文件都是虚拟的，它们提供了对实际物理设备的访问接口。
/home：用户主目录的基础目录，每个用户都有一个对应的子目录。例如，用户名为 john 的用户主目录就是 /home/john。
/lib64 目录是用于存放 64 位架构的库文件的目录。它包含了许多系统程序和库文件所需的动态链接共享库文件，这些共享库文件通常被程序在运行时动态加载。
/mnt：临时挂载点的目录，用于临时挂载其他文件系统或网络共享。例如我们可以将其他磁盘的分区挂载到此目录下。
/proc：虚拟文件系统，包含当前运行进程和内核信息的文件。这些文件都是动态生成的，实时反映了系统状态的变化。
/run：在系统启动期间存放临时运行时数据的目录。例如 PID 文件、锁文件等等。
/srv：服务相关数据的目录，用于存放特定服务所需的数据。例如 Web 服务器的网站数据、FTP 服务器的文件存储目录等。
/tmp：临时文件目录，用于存放临时文件和临时数据。这个目录下的内容通常是瞬时的，可以被任何用户访问。
/var：可变数据的目录，包含日志文件、缓存数据等。例如邮件系统的邮件内容、打印任务的文档等。
/boot：启动加载器（boot loader）相关的文件目录，包括内核、initramfs 和 grub 等启动所需的文件。一般情况下，这些文件不需要手动操作。
/etc：系统配置文件目录，包含各种系统和应用程序的配置文件。例如网络配置文件、系统服务配置文件、用户帐户信息等等。
/lib：库文件的目录，包含共享库和内核模块。这里存放的文件被系统和程序动态链接使用，从而提供了常用的函数和程序库。
/media：可移动媒体设备（如光盘、USB 设备等）挂载点的目录。当可移动设备被插入计算机时，它们通常会自动挂载到这个目录下。
/opt：可选软件包的安装目录，常用于安装第三方软件。在一些情况下，软件包的具体安装位置不太容易确定，这个时候可以选择安装到这个目录下。
/root：超级用户（root）的主目录。与普通用户的目录类似，主要用于保存超级用户的文件和数据。
/sbin：系统管理命令的目录，只有管理员可以使用。与 /bin 目录不同，/sbin 目录存放的命令通常需要特殊权限才能执行。
/sys 目录是一个虚拟文件系统，它提供了一种访问内核启动时相关信息的方式。该目录包含了当前系统中硬件设备、内核模块、进程等实体的相关信息，以及一些系统和内核参数的配置项。
/usr：用户程序和文件的目录，包含系统级应用程序、库文件和文档。这个目录通常占用了主机上大部分的空间。
二，根目录下目录详解 1，/bin 目录是用于存放二进制可执行文件的目录 /bin/cat：用于将文件内容输出到标准输出或合并文件。 ​ /bin/chmod：用于修改文件或目录的权限。 ​ /bin/cp：用于复制文件或目录。 ​ /bin/date：显示系统日期和时间。 ​ /bin/echo：将指定的字符串输出到标准输出。 ​ /bin/grep：在文件中搜索匹配指定模式的文本行。 ​ /bin/kill：用于终止进程或发送信号给进程。 ​ /bin/ls：显示目录内容。 ​ /bin/mkdir：创建新目录。 ​ /bin/mv：用于移动或重命名文件或目录。 ​ /bin/pwd：显示当前工作目录的路径。 ​ /bin/rm：删除文件或目录。 ​ /bin/rmdir：删除空目录。 ​ /bin/touch：更新文件的访问时间和修改时间，如果文件不存在则创建空文件。 ​ /bin/uname：显示系统信息，如内核版本、节点名等。 /bin 目录下的命令和工具是一些基本的系统命令，通常不需要特殊权限即可执行。这些命令和工具的路径会被自动包含在系统的执行路径中，因此，用户可以直接在终端中输入命令名称，而无需指定完整的路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d421216fbfa1841e6704e43bec3f3709/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a14b28344990ae4a8a46124e9f50f1/" rel="bookmark">
			【大数据之Kafka】十四、Kafka-Eagle监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka-Eagle 框架可以监控Kafka 集群的整体运行情况，在生产环境中经常使用。
1 MySQL环境准备 https://blog.csdn.net/qq_18625571/article/details/130613704?spm=1001.2014.3001.5501
2 Kafka环境准备 （1）关闭Kafka集群。
kf.sh stop （2）修改/opt/module/kafka/bin/kafka-start.sh命令中
vim bin/kafka-start.sh #修改处如下： if [ "x$KAFKA_HEAP_OPTS" = "x"]; then export KAFKA_HEAP_OPTS="-Xmx1G -Xms1G" fi #修改为： if [ "x$KAFKA_HEAP_OPTS" = "x"]; then export KAFKA_HEAP_OPTS="-server -Xms2G -Xmx2G -XX:PermSize=128m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=8 -XX:ConcGCThreads=5 -XX:InitiatingHeapOccupancyPercent=70" export JMX_PORT="9999" # export KAFKA_HEAP_OPTS="-Xmx1G -Xms1G" fi #分发： xsync kafka-server-start.sh 3 安装Kafka-Eagle （1）官网：https://www.kafka-eagle.org/
（2）上传压缩包 kafka-eagle-bin-2.0.8.tar.gz 到集群/opt/software 目录。
（3）解压到本地。
tar -zxvf kafka-eagle-bin-2.0.8.tar.gz （4）进入刚才解压的目录，将 efak-web-2.0.8-bin.tar.gz 解压至/opt/module。
tar -zxvf efak-web-2.0.8-bin.tar.gz -C /opt/module/ （5）修改名称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8a14b28344990ae4a8a46124e9f50f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0004394e488f163879b6fc68f14804db/" rel="bookmark">
			论文解读：Siren’s Song in the AI Ocean: A Survey on Hallucination in Large Language Models
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文解读：Siren’s Song in the AI Ocean: A Survey on Hallucination in Large Language Models 核心要点 针对大模型幻觉问题进行综述，从detection、explanation和mitigation三个方面进行介绍；对幻觉现象和评估基准进行归纳，分析现有的缓解幻觉的方法，讨论未来潜在的研究发展相关文献整理：https://github.com/HillZhang1999/llm-hallucination-survey 一、什么是大模型的幻觉 大模型幻觉的三种类型：
生成的内容与输入存在冲突：Input-conflicting hallucination, where LLMs generate content that deviates from the source input provided by users;生成的内容中，前后矛盾：Context-conflicting hallucination, where LLMs generate content that conflicts with previously generated information by itself;生成的内容中有事实性错误：Fact-conflicting hallucination, where LLMs generate content that is not faithful to established world knowledge. 更多的例子如下表所示：
（1）Input-conflicting hallucination
通常存在两种情况：
输入的input是一个用户指令，而大模型给出的结果与指令不相关，或存在一些冲突；输入的input是一个文档，例如做文本摘要和机器翻译任务，大模型给出的结果与文档内容存在冲突； 例如下表，Lucas与Hill存在冲突问题。
（2）Context-conflicting hallucination
表示大模型生成的内容存在自相矛盾的现象。通常出现这种情况是因为：
大模型在上下文状态追踪和一致性上存在缺陷；在长程记忆方面存在不足； 如下表，一直在说Silver，可是说着说着提到了Stern。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0004394e488f163879b6fc68f14804db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab35dd923216c20292ba65fb4bb7198/" rel="bookmark">
			ubuntu安装eigen、pangolin库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装eigen
方法一、命令行安装
sudo apt install libeigen3-dev 一般情况下，方法二同理，eigen会默认安装到/usr/include或者/usr/local/include/下的eigen目录下，需要执行复制命令，将Eigen文件夹及其内容复制到/usr/inlcude/或者/usr/local/include/下：
如果在 /usr/include
sudo cp -r /usr/include/eigen3/Eigen /usr/include 如果在 /usr/local/include
sudo cp -r /usr/local/include/eigen3/Eigen /usr/local/include 关于命令的说明：
因为eigen3 被默认安装到了usr/local/include里了（或者是usr/include里，这两个都差不多，都是系统默认的路径），在很多程序中include时经常使用#include &lt;Eigen/Dense&gt;而不是使用#include &lt;eigen3/Eigen/Dense&gt;所以要做下处理，否则一些程序在编译时会因找不到Eigen/Dense而报错。上面指令将usr/local/include/eigen3文件夹中的Eigen文件递归地复制到上一层文件夹（直接放到/usr/local/include中，否则系统无法默认搜索到 -&gt; 此时只能在CMakeLists.txt用include_libraries(绝对路径了)）
方法二、源码安装
http://eigen.tuxfamily.org/index.php?title=Main_Page
选择合适的版本。
cd eigen-3.2.10 mkdir build cd build cmake .. sudo make install 二、安装pangolin
1. 安装pangolin依赖项以及安装过程中用到的工具
ctrl+alt+t打开终端，依次输入命令，安装相关依赖和工具
sudo apt update sudo apt upgrade sudo apt install libglew-dev cmake libboost-dev libboost-thread-dev libboost-filesystem-dev 3. 下载pangolin源文件
进入安装目录后使用git工具下载pangolin源文件
官方github下载
git clone https://github.com/stevenlovegrove/Pangolin.git 镜像gitee下载（推荐使用，或者自行在gitee上搜索一个下载地址，基本上都是克隆的github上面官方的代码，选择一个较新的就行）
git clone https://gitee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eab35dd923216c20292ba65fb4bb7198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd1bdd77769c0cd31a2ac6c9126d8bc/" rel="bookmark">
			VCS和UVM常用编译选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VCS编译选项 -full64在64bit模式下编译、仿真，用于64位操作系统-j8指定编译器可以并行编译的进程数为8-timescale=1ns/1ps指定仿真时间和精度-y &lt;dir_pathname&gt;指定verilog库路径+libext+.v+.V+.sv+.svh识别.v、.sv、.svh等多种格式文件-sverilog支持system verilog 语法的编译选项-f xxx.lisf 指定包含所有设计文件列表的文件名-top test设置顶层模块为test。（指包含DUT和TB的top？）-l xx.log编译log输出到指定的文件xx.log+define+XX_MACRO定义一个宏变量XX_MACRO，可作用到dut或tb文件中。也可以具体给这个宏定义一个具体的值：+define+XX_MACRO = 9+incdir+/xx/xx/指定 `include指令使用的包含文件的目录，可以指定多个-M使能增量编译，即编译时只对修改的文件进行重新编译-Mdir=&lt;directory&gt;指定一个目录让VCS存储编译产生的文件，默认是csrc-Mlib=&lt;directory&gt;指定一个目录让VCS搜索某个模块是否需要重新编译。与-Mdir配合，可以实现不同模块的增量编译。-Mupdate[=0]默认情况下，VCS编译时会覆盖上次编译生成的makefile。如果想保留上次的makefile，使用-Mupdate=0；如果不带=0，则进行增量编译，并覆盖上次的makefile。-noIncrComp关闭增量编译-notice `-notice`是VCS编译器的一个选项，用于控制编译过程中的警告信息的显示方式。
通过使用`-notice`选项，您可以获得更多关于编译和仿真过程的信息，并且能够找到潜在的问题或改进的建议。这对于调试和优化设计非常有用。
-R编译完成后立即执行simv命令进行仿真；（一般还是先编译，再仿真；方便debug和调试）+memcbk使能多维数组变量的回调。为了可以查看多维数组变量的波形（vcs默认是不能查看多维数组或memory型变量）+warn=none忽略所有warning，不予显示+warn=all显示所有warning-debug_access+all-debug_all将debug的信息全部保存下来，如波形文件等-debug 或 -debug_all使能UCLI命令行-kdb 选项在执行仿真时，打开KDB调试模式，以便可以通过命令行进行交互式的调试操作。
-cm &lt;options&gt;指定覆盖率的类型，包括：line（行覆盖）、cond（条件覆盖）、fsm（状态机覆盖）、tgl（翻转率覆盖）、path（路径覆盖）、branch（分支覆盖）和assert（断言覆盖）。如果包括两种或以上的覆盖率类型，可用“+”，如-cm line+cond+fsm+tgl-cm_assert_hier &lt;filename&gt;将SVA覆盖率统计限定在文件列表中指定的module层次-cm_cond &lt;arguments&gt;进一步细化条件覆盖率的统计方式，包括：basic,std,full,allops,event,anywidth,for,tf,sop等选项。-cm_count在统计是否覆盖的基础上，进一步统计覆盖的次数-cm_dir &lt;directory_path_name&gt;指定覆盖率统计结果的存放路径，默认是simv.cm-cm_hier &lt;filename&gt;指定覆盖率统计的范围，范围在文件中定义，可以指定module名、层次名和源文件等。-cm_log &lt;filename&gt;指定仿真过程中记录覆盖率的log文件名-cm_name &lt;filename&gt;指定保存覆盖率结果的文本文件的名称-o &lt;name&gt;指定编译生成的可执行文件的名称，默认是simv+v2k支持Verilog-2001标准+vcs+initmem+0/1/x/z初始化设计中所有存储器的值+vcs+initreg+0/1/x/z初始化设计中所有寄存器的值+vcs+lic+wait一直等待license +nospecify
是一种仿真运行时的选项。它用于控制VCS在仿真过程中如何处理Verilog中的`specify`块。 `specify`块是一种用于描述和约束时序电路中时序行为的特殊语言结构。它可以定义信号的时序延迟、校准和约束规则等。在仿真过程中，通常使用`specify`块进行时序约束的模拟。
，当我们希望对设计进行功能仿真或性能分析时，并不需要考虑`specify`块中的时序约束，而只关注设计本身的逻辑行为。这时，可以使用`+nospecify`选项告诉VCS在仿真过程中忽略`specify`块。 具体地说，当使用了`+nospecify`选项时，VCS会在编译时将`specify`块从Verilog源代码中移除，并在仿真过程中忽略时序约束，从而将仿真重点放在逻辑行为上。
+notimecheck 是一种仿真运行时的选项。它用于控制VCS在仿真过程中是否执行时序约束的检查。
Verilog中的时序约束用于描述和约束时序电路中的时序行为，例如信号的时序延迟、时钟和数据的关系等。在仿真过程中，VCS默认会执行时序约束的检查，以确保设计是否满足约束规定的时序要求。 然而，有时在进行功能仿真或性能分析时，并不需要进行严格的时序约束检查，而只关注设计本身的逻辑行为。这时可以使用`+notimecheck`选项告诉VCS在仿真过程中跳过时序约束的检查。 具体来说，当使用了`+notimecheck`选项时，VCS会忽略时序约束，不执行相关的检查。这将加快仿真速度，并且更侧重于逻辑行为的仿真。
上面这2个编译有时候需要加上，之前遇到了自己的makefile跑用例没有问题，但是eman回归就有问题，最后发现是两边的编译选项不一样；仿真选项（SIM）+ntb_random_seed-line使能VriSim中的单步运行-ntb使能ntb（Native TestBench），支持OpenVera验证平台语言结构。-timescale=&lt;time_unit&gt;/&lt;time_precision&gt;源代码文件中有的包括timescale编译指令，有的不包括，如果在VCS命令行中，不包括timescale的源代码文件在最前面，VCS会停止编译。使用-timescale选项为这些在前面且又没有`timescale的源文件指定timescale-override_timescale=&lt;time_unit&gt;/&lt;time_precision&gt;让源文件统一使用指定的timescale-pvalues+&lt;parameter_name&gt;=&lt;value&gt;改变指定参数的值
-pvalue选项支持在编译阶段去更改parameter的值；然后直接在makefile里控制parameter的随机即可-parameters &lt;filename&gt;通过文件的方式改变参数的值，参数的路径和改变的值均在文件中定义+error+&lt;n&gt;将编译时运行的NTB错误增加到N-vcd &lt;filename&gt;指定VCD波形文件名，默认是verilog.dump，会被源代码文件中的$dumpfile覆盖 分离（块）（编译选项： -partcomp=adaptive_sched -fastpartcomp=j8 分离编译的优点 （1）拆分成多个线程去并行执行编译，节省了编译时间。-fastpartcom=jn，n代表并行线程的数量
（2）将DUT和TB分成若干partition，未修改的partition不需要重新编译
参考链接：
vcs 分离编译_vcs分块编译_卓麻麻的博客-CSDN博客
参考：vcs常用仿真选项_lobbiy的博客-CSDN博客
vcs把verilog文件编译完成后，会生成simv文件；
（跑仿真：./simv -l sim.log）
跑仿真：./simv +ntb_random_seed=12345 -l sim.log；（自动化脚本中，随机种子一般在makefile里面通过变量SEED传递进来）
vcs的单步仿真： 生成波形文件：在top_tb.sv中加入下面这个initial块
把数组型数据生成到波形文件中：
-F/-f的区别：
1. -F 使用相对路径索引include的文件。
2.-f 使用绝对路径索引include的文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdd1bdd77769c0cd31a2ac6c9126d8bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fd92de9c3bbe05e24aec16983490055/" rel="bookmark">
			docker部署最新版nacos(2.2.3)设置登录密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新版nacos（2.2.3）安装 1、下载 docker pull nacos/nacos-server 2、启动nacos 如果nacos版本在2.0及以上，需要把8848、9848和9849三个端口映射出来，否则访问会404失败
docker run --env MODE=standalone --name nacos -d -p 8848:8848 -p 9848:9848 -p 9849:9849 nacos/nacos-server 此时登录直接就进入了页面,并没有授权
3、复制镜像中的配置文件 1、复制配置文件 mkdir -vp /usr/local/docker/nacos/logs mkdir -vp /usr/local/docker/nacos/ &amp;&amp; cd /usr/local/docker/nacos/ #复制到容器数据卷 docker cp nacos:/home/nacos/conf/ /usr/local/docker/nacos/ 2、将该版本对应的数据库还原 mysql-schema.sql是nacos对应的sql信息，将该文件再对应的nacos数据库中执行即可
/* * Copyright 1999-2018 Alibaba Group Holding Ltd. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fd92de9c3bbe05e24aec16983490055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008e6f77301c36900d5300d790e35a09/" rel="bookmark">
			libevent 定制——libevent 定制多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		libevent 定制多线程 文章目录 libevent 定制多线程开启多线程定制多线程调试锁的使用 编写多线程程序的时候,在多个线程中同时访问同样的数据并不总是安全的。 libevent 的结构体在多线程下通常有三种工作方式: 某些结构体内在地是单线程的:同时在多个线程中使用它们总是不安全的。
某些结构体具有可选的锁:可以告知 libevent 是否需要在多个线程中使用每个对象。
某些结构体总是锁定的:如果 libevent 在支持锁的配置下运行,在多个线程中使用它们总是安全的。
开启多线程 目前默认编译生成的libevent是支持多线程的，这一点可以从他的cmake过程文件(build/CMakeCache.txt)中看出：
EVENT__DISABLE_THREAD_SUPPORT:BOOL=OFF 之后这个宏会在libevent-2.1.12-stable/include/event2/thread.h这个提供给用户的头文件中用到：
#if !defined(EVENT__DISABLE_THREAD_SUPPORT) || defined(EVENT_IN_DOXYGEN_) #define EVTHREAD_LOCK_API_VERSION 1 #define EVTHREAD_LOCKTYPE_RECURSIVE 1 #define EVTHREAD_LOCKTYPE_READWRITE 2 struct evthread_lock_callbacks { int lock_api_version; unsigned supported_locktypes; void *(*alloc)(unsigned locktype); void (*free)(void *lock, unsigned locktype); int (*lock)(unsigned mode, void *lock); int (*unlock)(unsigned mode, void *lock); }; EVENT2_EXPORT_SYMBOL int evthread_set_lock_callbacks(const struct evthread_lock_callbacks *); #define EVTHREAD_CONDITION_API_VERSION 1 struct timeval; struct evthread_condition_callbacks { int condition_api_version; void *(*alloc_condition)(unsigned condtype); void (*free_condition)(void *cond); int (*signal_condition)(void *cond, int broadcast); int (*wait_condition)(void *cond, void *lock, const struct timeval *timeout); }; EVENT2_EXPORT_SYMBOL int evthread_set_condition_callbacks( const struct evthread_condition_callbacks *); EVENT2_EXPORT_SYMBOL void evthread_set_id_callback( unsigned long (*id_fn)(void)); #if (defined(_WIN32) &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/008e6f77301c36900d5300d790e35a09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a1b8af06fc7bc6d70de1431617ad62a/" rel="bookmark">
			element-plus修改英语语言模式为中文方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element-plus 默认是英文模式，需要中文模式的话需要设置一下：
项目框架（vue3）：vite + TS + element-plus
① 在 “App.vue” 组件中引入 中文包 import zhCn from 'element-plus/dist/locale/zh-cn.mjs' ② 使用 “el-config-provider” 组件包裹 “router-view” 组价 &lt;el-config-provider :locale="zhCn"&gt; &lt;router-view /&gt; &lt;/el-config-provider&gt; 如图所示：
引入中文包后可能会出现报错，如下：
鼠标悬浮到报错的地方，出现提示：
根据提示，在 “env.d.ts” 文件中添加声明：
declare module 'element-plus/dist/locale/zh-cn.mjs' 如图所示：
添加后保存，报错就消失了
更多操作可以查阅element-plus官方文档~ https://element-plus.gitee.io/zh-CN/component/config-provider.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71fe4e0d74de775b1bb56b09c3c1ca5f/" rel="bookmark">
			SPI驱动理论与实例分析2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、idt8v97003（无线收发器）原理图设备树数据手册整理数据手册编写驱动数据结构读写函数完成驱动结构体驱动出入口 二、Admv1139（ADC）原理图设备树数据手册驱动编写寄存器设置SPI 传输函数注册驱动驱动出入口 前言 DEBUG 用的一些宏：
//将一字节十进制数字转换成二进制 debug用，一般用于查看寄存器每个位的数值 #define PRINTF_BINARY_PATTERN_INT8 "%c %c %c %c %c %c %c %c" #define PRINTF_BYTE_TO_BINARY_INT8(i) \ (((i) &amp; 0x80ll) ? '1' : '0'), \ (((i) &amp; 0x40ll) ? '1' : '0'), \ (((i) &amp; 0x20ll) ? '1' : '0'), \ (((i) &amp; 0x10ll) ? '1' : '0'), \ (((i) &amp; 0x08ll) ? '1' : '0'), \ (((i) &amp; 0x04ll) ? '1' : '0'), \ (((i) &amp; 0x02ll) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71fe4e0d74de775b1bb56b09c3c1ca5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1220f85587c4823ddc0f0e3cf292e7a6/" rel="bookmark">
			SQLI-labs-第七关和第八关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第七关 知识点：单引号（'）加括号闭合错误的布尔盲注 思路：
寻找注入点 我们首先看一下正常的回显，并没有显示出什么明显的信息
输入?id=1' 发现报错
输入?id=1' --+ 还是报错，说明SQL语句的语法错误可能不是单引号闭合错误，这时我们可以把双引号(")、括号都试试
输入?id=1')) --+ ，页面正常回显，说明存在单引号+括号的闭合错误
输入?id=1')) and 1=1 --+ , 正常回显
再输入?id=1')) and 1=2 --+ ,报错
看到这里，因为只有正确和错误两种回显信息，且没有回显其他有用的信息，我们可以确认为布尔盲注
接下来的步骤就跟前面第五关的一样 猜库名长度，爆库名，猜表名长度，爆表名，猜字段长度，爆字段名，爆值
参考链接：SQLI-labs-第五关和第六关_賺钱娶甜甜的博客-CSDN博客
第八关 知识点：单引号闭合错误的布尔盲注
思路：
寻找注入点： 首先输入?id=1 看看正常的回显效果
然后输入?Id=1' ，发现没有任何回显
输入?id=1' --+ ,页面正常回显，结合这些回显效果，说明这里存在单引号闭合错误的SQL盲注
知道注入点后，我们就可以进行爆库，爆值
利用length()，substr()这两个函数
接下来的步骤可以参考之前的文章，SQLI第五关
参考链接：SQLI-labs-第五关和第六关_賺钱娶甜甜的博客-CSDN博客
这篇文章就先写到这里了，详细可以查看第五关的步骤，哪里不好，欢迎指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6453f82a04593783be49ad85dc1c4637/" rel="bookmark">
			Vue3图片（Image）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本图片预览组件主要包括以下功能：
展示图片时，可设置鼠标悬浮时的预览文本；图像无法加载时要显示的描述；自定义图像高度和宽度；设置图像如何适应容器高度和宽度（ fill(填充) | contain(等比缩放包含) | cover(等比缩放覆盖)）；传入单张图像或图像数组；设置图像缩放比率；设置最大最小缩放比例；
单张图片预览时，左上角展示图片名称：水平镜像或垂直镜像；可顺时针旋转或逆时针旋转；还原图片；放大缩小；鼠标任意拖动；鼠标双击图片还原；使用触摸板或鼠标滚轮控制图片缩放；
多张图片预览时，除了单张展示的功能以外：可点击左右切换按钮预览多张图片；使用键盘上下左右按键进行图片切换；设置是否可以循环切换图片；
可自定义设置以下属性：
图像地址 | 图像地址数组（src），类型：string | Array&lt;{src: string, alt?: string}&gt;，默认 ''
图像无法加载时显示的描述（alt），类型：string，默认 'image'
图像宽度（width），类型：string | number，单位px，默认 300
图像高度（height），类型：string | number，默认 '100%'
是否显示边框（bordered），类型：boolean，默认 true
展示图片间距大小，数组时表示: [水平间距, 垂直间距]（gap），类型：number|number[]，默认 8px
图形如何适应容器高度和宽度（fit），类型：'contain'|'fill'|'cover'，默认'contain'，可选 fill(填充)、contain(等比缩放包含)、cover(等比缩放覆盖)
预览文本（preview），类型：string | slot，默认 '预览'
每次缩放比率（zoomRatio），类型：number，默认 0.1
最小缩放比例（minZoomScale），类型：number，默认 0.1
最大缩放比例（maxZoomScale），类型：number，默认 10
缩放移动旋转图片后，是否可以双击还原（resetOnDbclick），类型：boolean，默认 true
是否可以循环切换图片（loop），类型：boolean，默认 false
相册模式，即从一张展示图片点开相册（album），类型：boolean，默认 false
效果如下图：在线预览
预览时样式：
正常展示时样式：
图片加载时样式：
鼠标悬浮时样式：
其中引入组件：Vue3加载中（Spin）、Vue3间距（Space） ①创建图片预览组件Image.vue：
&lt;script setup lang="ts"&gt; import { computed, ref, onMounted, onUnmounted, watchEffect } from 'vue' import Spin from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6453f82a04593783be49ad85dc1c4637/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1633ec51af38eaf418fd2d9c04f7ea5e/" rel="bookmark">
			GPU对应的cuda以及cuDNN驱动安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cudnn 临时个性化版本切换:https://blog.csdn.net/sslfk/article/details/123053540
1、查看自己的cuda 最高支持的版本：查看方法，sudo cat /usr/local/cuda/version.txt
2、查看系统版本：lsb_release -a 系统内核版本查看：uname -a
方法2：利用conda安装，
1、切换conda源(国内源已经全部失效，建议直接使用国外默认源即可，速度还可以)：
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --set show_channel_urls yes
2、安装对应版本的cuda工具以及对应的cudnn
cuda与cudnn版本的对应关系查看：#如下命令可以查看cudnn8的各个子版本与cuda版本的关系：conda search cudnn=8 --info
conda install cudatoolkit=10.2.89
或则创建虚拟环境时安装：conda create -n deepfacelab -c main python=3.7 cudnn=7.6.5.32 cudatoolkit=10.2.89
已经验证的对应关系：
conda create -n chatglm python=3.10.9 cudnn=8.4.1.50 cudatoolkit=11.3.1 conda create -n deepfacelab -c main python=3.7 cudnn=7.6.5.32 cudatoolkit=10.2.89
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec85f56d1f8d8220ecf308c801bddd6e/" rel="bookmark">
			基于51单片机的积水监测系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 适用场景 道路积水监测、城市街道等需要进行水量监控的场景。
小鱼儿电子设计微信号：IOTElectronics
2 硬件方案 51系列单片机（芯片型号为STC12C5A60S2单片机）、水位传感器*2、E18-D80NK漫反射式光电红外传感器、HC-SR04超声波传感器、ESP8266WiFi模块、蜂鸣器、按键模块、USB转TTL-CH340模块、OLED显示幕、USB充电线
3 系统实现功能 实时监测：实时监测积水的水位情况（低水位/中水位/高水位）、积水的高度（单位：dm）、井盖是否存在（0：不存在，1：存在），并将监测结果显示到OLED屏幕上。手动控制模式：手动控制按键结合OLED屏幕进行积水最佳阈值设定。自动控制模式：当积水水位为高水位或测量到的积水高度大于最佳阈值时，自动声光报警。云平台远程监测：通过WiFi将监测数据上传到OneNET云平台，在手机端、电脑端和网页端均可以查看积水的水位情况、积水高度、报警触发次数及井盖是否存在等。 4 设计思路 超声波测距计算策略：d=超声波传感器安装高度-超声波传感器安装高度到积水的距离 高、中、低水位计算策略：将水位传感器1放在3dm处，水位传感器2放在6dm处，如果未淹没水位传感器1为低水位，如果淹没水位传感器1，未淹没水位传感器2为高水位，同时淹没两个水位传感器为高水位。 5 实物展示 5.1 云平台展示 5.2 下位机展示 6 云平台源码 用户需要自行完成一下2个函数的实现 1、定时下发数据任务初始化函数：device_timer_init(dev)【可选】 2、对设备上传数据进行解析（包括心跳等）：device_data_analyze(dev) ----------------------------------------------------------------------------------------- function device_timer_init(dev) dev:timeout(5) dev:add(10,"dev1","syn\r\n") end ----------------------------------------------------------------------------------------- function device_data_analyze(dev)	local t = {} --数组定义	local a = 0 --数声明	local s = dev:size() --获得数据总长度 dev_logon(dev)--注册返回 local length = dev:byte(3)--获取负载长度LEN（PAYLOAD长度） local cmd = dev:byte(4)--获取命令内容CMD（CMD命令） if dev:byte(1)==0x5A and dev:byte(2)==0x5A and dev:byte(5+length)==0xA5 then if cmd==0x01 then --上报状态值status add_val(t,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec85f56d1f8d8220ecf308c801bddd6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54209cd5d3ca5f30dbd2c896c1608989/" rel="bookmark">
			数据结构学习笔记—— 基数排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、基数排序排序思想例题 二、基数排序算法分析 一、基数排序排序思想 基数排序与前面的排序算法不一样，它不基于比较和移动元素来进行排序，而是基于多关键字排序的思想，将一个逻辑关键字分为多个关键字，它是基于关键字各位的大小进行排序的。基数排序有两种实现方式：最高位优先法（MSD）和最低位优先法（LSD），分别是按关键字高次位排序和低次位排序。
例题 例如，下面通过最低位优先法，对给定的关键字序列{110，119，007，911，114，120，122}进行排序：
1、该序列的链式结构如下：
2、首先按照关键字的个位数字大小进行第一趟基数排序：
3、根据第一趟的顺序，按照关键字的十位数字大小进行第二趟基数排序：
4、根据第二趟的顺序，按照关键字的百位数字大小进行第三趟基数排序：
即，通过最低位优先法，得到排好的序列为{007，110，114，119，120，122，911}。
二、基数排序算法分析 分析：
（1）基数排序适用于以下情况：
1、数据元素的关键字可以很容易地进行拆分成d组，且d较小； 2、每组关键字的取值范围不大，即r较小； 3、数据元素个数n较大。 （2）空间复杂度：每一趟基数排序需要辅助空间r个队列，每趟排序后会重复使用这些队列，基数排序的空间复杂度为O( r )。
（3）时间复杂度：由于基数排序需进行d趟分配和收集操作，所以基数排序的排序趟数与初始序列无关。其时间复杂度与初始序列无关，基数排序需进行d趟分配和收集操作，一趟分配需要O(n)数量级，一趟收集需要O( r )数量级，即总排序的时间复杂度为O(d(n+r))。
（4）稳定性：基数排序是一种稳定的排序算法。
（5）适用性：基数排序只适用于链式存储。
（6）排序方式：基数排序与前面的归并排序一样，也是是一种外部排序（Out-place）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/747160ed904511b8086c45e27df12777/" rel="bookmark">
			UVLO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欠压锁定（Undervoltage-Lockout）简称UVLO，是电子设备中在电源电压低于正常工程准位时，切断电源的电路。
在嵌入式系统中常会用UVLO监控电池电压，若电压低于一定值，会直接切断电源，保护嵌入式系统的电路。
许多电子设备中都有UVLO的功能，例如在镇流器中就有UVLO电路，若电压过低时直接切断电源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741f4aa5cd896269157be01ee986ede3/" rel="bookmark">
			web引入live2d教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		live2d 介绍 使用live2d安装到网站教程，超详细！超简单！（附带多种模型）
文件下载链接：点击下载
安装教程 先把必要的三个文件夹下载下来，然后上传到服务器网站目录（ps:这里的目录文件必须是可以通过链接访问的）
在你的网站首页文件index.html中插入以下代码 (ps:记得看准文件路径)
在头部&lt;head&gt;标签内引入css样式
&lt;link rel="stylesheet" href="/live2d/css/live2d.css" /&gt; &lt;link rel="stylesheet" href="/live2d/css/waifu.css" /&gt; 在尾部&lt;body&gt;标签内引入js及初始化live2d
&lt;script type="text/javascript" src="live2d/js/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="live2d/js/live2d.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="live2d/js/waifu-tips.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; initWidget({ waifuPath: "/live2d/waifu.json", cdnPath: "/live2d/" }); &lt;/script&gt; 两步就完成了，刷新你的页面，去看看效果吧啊(●ˇ∀ˇ●) ps: 鼠标放在页面某个元素上时，需要 Live2D 看板娘提示的请修改 live2d/waifu.json 文件
wordpress用户安装教程 上面的安装教程也可用于wordpress, 只要进入 wordpress根目录/wp-content/themes/正在使用的主题名 此目录，然后找到里面的 header.php以及footer.php文件引入以上的css和js即可
不过第一种方法只能在wordpress首页显示, 接下来介绍一种可以全局显示的方法：
(1) 首先进入主题文件的根目录，创建一个js文件夹
(2) 在文件夹中创建一个autoload.js文件，并写入以下代码加载所需文件（ps:文件在仓库中也有，可直接复制）
// 注意：live2d_path 参数应使用绝对路径 const live2d_path = "http://域名/live2d/"; //const live2d_path = "/live2d-widget/"; // 封装异步加载资源的方法 function loadExternalResource(url, type) { return new Promise((resolve, reject) =&gt; { let tag; if (type === "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741f4aa5cd896269157be01ee986ede3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2431eaac99424d504197c1bf1e38b2d6/" rel="bookmark">
			Flowable 之任务分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、任务分配和流程变量1.1 任务分配1.1.1 固定分配1.1.2 表达式分配① 值表达式② 方法表达式 1.1.3 监听器分配 1.2 流程变量1.2.1 全局变量1.2.2 局部变量1.2.3 案例讲解 二、候选人和候选人组2.1 候选人2.1.1 部署和启动流程2.1.2 任务的查询2.1.3 任务的拾取2.1.4 任务的退还2.1.5 任务的交接2.1.6 任务的完成 2.2 候选人组2.2.1 管理用户和组2.2.2 流程的部署启动2.2.3 任务的拾取完成 提示：以下是本篇文章正文内容，Java 系列学习将会持续更新 一、任务分配和流程变量 1.1 任务分配 1.1.1 固定分配 固定分配就是我们前面介绍的，在绘制流程图或者直接在流程文件中通过 Assignee 来指定的方式。
1.1.2 表达式分配 Flowable 使用 UEL 进行表达式解析。UEL代表Unified Expression Language，是EE6规范的一部分.Flowable支持两种UEL表达式： UEL-value 和 UEL-method。
① 值表达式 值表达式 Value expression：解析为一个值。默认情况下，所有流程变量都可以使用。（若使用Spring）所有的Spring bean也可以用在表达式里。例如
可以看到通过表达式处理的效果。
先部署流程，然后在启动流程实例的时候绑定表达式对应的值。
/** * 启动流程实例 */ @Test public void testRunProcess(){ // 设置 assignee 的取值 Map&lt;String,Object&gt; variables = new HashMap&lt;&gt;(); variables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2431eaac99424d504197c1bf1e38b2d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9871c332037417517f9137cb073113d4/" rel="bookmark">
			Flowable 之表结构分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、表结构分类二、代码案例讲解2.1 部署流程定义2.1.1 act_ge_bytearray2.1.2 act_re_deployment2.1.3 act_re_procdef2.1.4 挂起和激活 2.2 启动流程实例2.2.1 act_ru_execution2.2.2 act_ru_task2.2.3 act_ru_variable2.2.4 act_ru_identitylink 2.3 处理流程任务2.4 完成流程2.4.1 act_hi_actinst2.4.2 act_hi_identitylink2.4.3 act_hi_procinst2.4.4 act_hi_taskinst2.4.5 act_hi_varinst 提示：以下是本篇文章正文内容，Java 系列学习将会持续更新 一、表结构分类 工作流程的相关操作都是操作存储在对应的表结构中，为了能更好的弄清楚 Flowable 的实现原理和细节，我们有必要先弄清楚 Flowable 的相关表结构及其作用。在 Flowable 中的表结构在初始化的时候会创建五类表结构，具体如下：
ACT_RE：RE 表示 repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则等）。ACT_RU：RU 表示 runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Flowable只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。ACT_HI：HI 表示 history。 这些表包含历史数据，比如历史流程实例， 变量，任务等。ACT_GE：GE 表示 general。 通用数据， 用于不同场景下 。ACT_ID：ID 表示 identity(组织机构)。这些表包含标识的信息，如用户，用户组等。 表分类表名解释一般数据[ACT_GE_BYTEARRAY]通用的流程定义和流程资源[ACT_GE_PROPERTY]系统相关属性流程历史记录[ACT_HI_ACTINST]历史的流程实例[ACT_HI_ATTACHMENT]历史的流程附件[ACT_HI_COMMENT]历史的说明性信息[ACT_HI_DETAIL]历史的流程运行中的细节信息[ACT_HI_IDENTITYLINK]历史的流程运行过程中用户关系[ACT_HI_PROCINST]历史的流程实例[ACT_HI_TASKINST]历史的任务实例[ACT_HI_VARINST]历史的流程运行中的变量信息流程定义表[ACT_RE_DEPLOYMENT]部署单元信息[ACT_RE_MODEL]模型信息[ACT_RE_PROCDEF]已部署的流程定义运行实例表[ACT_RU_EVENT_SUBSCR]运行时事件[ACT_RU_EXECUTION]运行时流程执行实例[ACT_RU_IDENTITYLINK]运行时用户关系信息，存储任务节点与参与者的相关信息[ACT_RU_JOB]运行时作业[ACT_RU_TASK]运行时任务[ACT_RU_VARIABLE]运行时变量表用户用户组表[ACT_ID_BYTEARRAY]二进制数据表[ACT_ID_GROUP]用户组信息表[ACT_ID_INFO]用户信息详情表[ACT_ID_MEMBERSHIP]人与组关系表[ACT_ID_PRIV]权限表[ACT_ID_PRIV_MAPPING]用户或组权限关系表[ACT_ID_PROPERTY]属性表[ACT_ID_TOKEN]记录用户的token信息[ACT_ID_USER]用户表 回到目录…
二、代码案例讲解 2.1 部署流程定义 /** * 部署流程 */ @Test public void test1(){ Deployment deploy = repositoryService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9871c332037417517f9137cb073113d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7785774723e156ea22fd67a8084b8f10/" rel="bookmark">
			摩尔斯电码（摩斯电码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摩尔斯电码 简介电码对照表应用互译工具特殊符号常见缩写交流示例中文与摩斯电码 简介 摩尔斯电码（又译为摩斯密码，Morse code）是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。它发明于1837年，发明者有争议，是美国人塞缪尔·莫尔斯或者艾尔菲德·维尔。 摩尔斯电码是一种早期的数字化通信形式，但是它不同于现代只使用零和一两种状态的二进制代码，它的代码包括五种： 点、划、点和划之间的停顿、每个字符之间短的停顿、每个词之间中等的停顿以及句子之间长的停顿。
电码对照表 基本说明
摩尔斯电码由两种基本信号组成：短促的点信号·，读“滴”；保持一定时间的长信号—，读“嗒”。
间隔时间：滴=1t，嗒=3t，滴嗒间=1t，字符间=3t，单词间=7t。
若以代码的格式表示摩尔斯代码，其默认采用空格分隔每个字母，为了在网页或文件中显示方便，许多摩斯代码采用单斜杠/进行分隔。
国际摩尔斯电码救难信号
SOS是国际通用求救信号，这三个字母并非任何单词缩写，只是因为它的电码.../---/...（三点，三长，三点）是电报中最容易发出和辨识的电码。
摩斯码发错了怎么办
在操作时难免出错导致发出的信号有误，为了及时修正避免误解，摩斯码中有一些具有特殊意义的固定组合和缩写，如........表示错误。
应用 摩斯密码编码简单清晰，二义性小，编码主要是由两个字符表示：.、-，一长一短，这在很多情况下应用很多，比如发送求救信号。
灯光
在利用摩尔密码灯光求救的时候，定义：灯光长亮为-，灯光短亮为.，那么就可以通过手电筒的开关来发送各种信息，例如求救信息。
声音
同理声音也可以打出摩尔斯编码，短音代表.，长音代表-。
敲击
用手指敲击也可以打出摩尔斯编码，间隔短的敲击代表“滴”，间隔长的代表“嗒”，也可以用手掌敲击代表：“嗒”。
互译工具 在线网站
网址：摩斯电码在线互译
手机APP
App名称：morsee
CSDN下载地址：morsecode.apk
百度网盘下载地址：morsecode.apk ，提取码：tu0t 。
简介：该应用可以实现摩斯电码和英文的互译，并可以对电码进行播放，收藏，和分享。还拥有摩斯电码对照表，可以在忘记电码时参照，以备不时之需。
注意：若链接失效，可以在评论区评论，本人看到会及时更新链接。
特殊符号 这是一些有特殊意义的点划组合。它们由二个字母的摩尔斯电码连成一个使用，这样可以省去正常时把它们做为两个字母发送所必须的中间间隔时间。
AR：·—·—·（停止，消息结束）
AS：·—···（等待）
K：—·—（邀请发射信号）（一般跟随AR，表示“该你了”）
SK：···—·—（终止，联络结束）
BT：—···—（分隔符）
···—·：我将重新发送最后一个单词
·· ··：同样
········：错误
常见缩写 缩写和同一符号不同，缩写保留着字元中间的间隔，它们并没有被连成一个使用。
A - All after （问号后用于请求重复）
AB - All before （同样）
ARRL - American Radio Relay League（美国无线电中继联盟）
ABT - About（关于）
ADS - Address（地址）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7785774723e156ea22fd67a8084b8f10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00cd91ac40d84eb47186b971ee96f5cf/" rel="bookmark">
			Mac如何安装brew
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在 macOS 上安装 Homebrew（也称为 brew），请按照以下步骤进行操作：
打开终端应用程序。你可以在"应用程序"文件夹中的"实用工具"文件夹里找到它，也可以使用 Spotlight 搜索。
在终端中，复制并粘贴以下命令，并按下回车键：
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
这将下载 Homebrew 安装脚本并开始安装过程。
安装过程可能会要求你提供管理员密码。输入密码并按下回车键。
等待安装完成。安装过程可能需要几分钟，具体时间取决于你的计算机和互联网连接速度。
安装完成后，你可以通过在终端中输入以下命令来验证是否成功安装了 Homebrew：
brew --version
如果安装成功，将显示 Homebrew 的版本信息。
现在你已成功安装了 Homebrew！你可以使用它来安装各种 macOS 软件包和工具。
Press RETURN/ENTER to continue or any other key to abort:是什么意思
当你看到提示信息"Press RETURN/ENTER to continue or any other key to abort"时，它意味着你需要按下回车键（或者输入键）来继续执行安装过程。这个提示通常出现在安装程序需要确认某些选择或继续下一步之前。如果你按下其他键，安装过程将会被中止并退出。所以，如果你希望继续安装，只需按下回车键即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d0c7ea41cd9bee5b1a957fa43c4ed7/" rel="bookmark">
			软考 - 系统架构设计师如何备考？文中含资料分享和备考心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我参加了2022年11月份的《软考-系统架构设计师》考试，在两个多月的备考之中我总结了一些学习经验和答题技巧，现毫无保留的分享给大家，希望对报考的同学们有所帮助。
一、软考的作用 1、以考代评（国企、事业单位、公务员评职称）
2、积分落户
3、政策扶持（继续教育专项附加扣除税的扣除3600块）
4、项目竞标 5、装b用 ！！！哈哈哈！！！
二、自学还是报班 自考还是培训，是很多报考软考都会思考的问题（钱包不争气）。
选择自学还是培训这个主要结合自身情况。
有大把时间去学习，技术比较OK的，可以选择自学。
辅导用书的话不太建议购买，我当时准备软考的时候，没有购买资料，主要靠看视频、多刷题。
如果非计算机专业，又想一次通过，可以考虑培训（单位评级）。
这里有我的学习后的总结资料，主要就是自己认为较为重要的、备考视频、真题讲解视频。
获取方式：CTO说 （回复：系统架构设计师）
三、如何备考 科目一，综合题目。 综合题目共75道单选题，70道中文，最后五题是英文题。
考试时间也都是150分钟，一般是上午 9:00-11:30。
如果没时间看书，建议要多刷题，对于错题建议多看几次。
我通常是，先做完再好好看解析，对答案理解答案，理解不了就记。
如果时间不够，可以只看错题的解析。
综合题涉及的知识面很广，建议利用碎片时间来做，建议用好手机刷题软件。
在此推荐我刷题的软件：「软考达人」小程序
把周末这样完整可控的时间，让出来给案例分析题和论文题的训练。
科目二，案例分析题。 案例分析题，5选3来回答，中级和高级都有，都是75满分，题目数量也差不多。
安排在下午，一般是13:30-15:00，90分钟。
系统架构设计师通常会有嵌入式的部分题目，如果不擅长嵌入式相关的知识，复习时间也不够，那么可以忽略这部分。
因为时间关系，没空看教程，主要还是通过刷题和背题。
当然这对于常年一线工作的程序员来说，不是很难。
因为很多知识无意中你都会接触到，凭着自己的理解达，也能得一些分。
这其中会有一部分计算题，这需要会，对理科生来说，这可能是好事，因为通常就是那几类题目，公式也都是那些。
在「软考达人」上有案例分析题训练模块，大家可以试一试，个人觉得蛮好用的。
科目三，论文题。 这是高项独有的题目，15:20-17:20, 120分钟。
论文是给几个题目，然后你选一个来撰写，系统架构设计师通常是4选1。
论文是分摘要和正文两部分的，摘要一般写200-350就可以了，正文可能要1600-2500，我考系统架构设计师的时选题是和微服务有关的，写了大概1600字，得分47。
所以，我觉得至少要1600字以上。
至于怎么准备，这个得平时有些积累，不然很难两个小时内写完。
另外就是要先找几篇范文熟悉，主要是熟悉书写的格式和架构段落。摘要那几百字好办，基本按照格式写即可。
在「软考达人」上有论文训练模块，大家可以试一试，个人觉得蛮好用的。
我成功通过了这次的考试，希望备考的小伙伴也能顺利通过考试，拿到证书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eedfdd585c6f96219ac17994442e2c9/" rel="bookmark">
			CENTOS下启动和关闭MYSQL服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CENTOS下启动和关闭MYSQL服务 1、配置MySQL的开机自动启动 chkconfig --add mysql chkconfig mysqld on 2、命令启动/关闭MySQL实例 service mysqld start/stop /etc/init.d/mysqld start/stop 3、命令关闭MySQL mysqladmin -p -u root shutdown 4、检查mysql是否真正的启动 方法一：查询端口 #netstat -tulpn MySQL监控的是TCP的3306端口，图中命令操作结果的最后一行即是MySQL服务在运行中。
方法二：查询进程 ps -ef | grep mysqld 如果有mysqld_safe和mysqld两个进程，说明MySQL服务当前在启动状态。
标签: MySQL
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19e0c1111e15e597bf1ee532c216862/" rel="bookmark">
			LaTeX 伪代码 algorithm最后出现=0, 并且行号都是0 的参考解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 LaTeX 伪代码 algorithm最后出现=0, 并且行号都是0 的参考解决方法
二、解决方法 书写伪代码一般需要包含的 package 是
\usepackage{algorithm} \usepackage{algorithmic} \usepackage{algpseudocode} 笔者注释掉 \usepackage{algorithmic}，也就是把上述代码修改为
\usepackage{algorithm} # \usepackage{algorithmic} \usepackage{algpseudocode} 就可以不报错就编译通过。
（注意：有的朋友是注释掉 \usepackage{algpseudocode} 才能不报错，具体读者可以都尝试一下~~）
参考链接 [1] amorfatilily. latex错误记录之algorithm最后出现=0 [EB/OL]. https://blog.csdn.net/weixin_41741485/article/details/111454300, 2020-12-20/2023-09-16.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43a543374af8e4f901b6eedeba8c713/" rel="bookmark">
			Java 数学函数 实现加减乘除 代理模式 &amp;&amp; 装饰模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整代码 ​interface math { double result(double x);//计算带入具体x的返回结果 math set(double x);//不同计算增加的内容 } public class project7 { public static void main(String[] args) { // x 当 x = 3 System.out.println(new Function().result(3)); // x+x 当 x = 4 System.out.println(new Function().addition().result(4)); // (x+x)*3 当 x = 5 System.out.println(new Function().addition().multiplication(3).result(5)); } } //函数 class Function { private math function; double x; public double result(double x) {//带入值计算返回结果 this.x = x; return function.result(x); } //创建函数 public Function() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a43a543374af8e4f901b6eedeba8c713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4045e83faa99792a68f6749866faa3f/" rel="bookmark">
			Mybatisplus报错@TableId can‘t more than one in Class解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatisplus报错@TableId can't more than one in Class解决方案 问题背景解决方案Lyric： 能不能原谅我 问题背景 Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sqlSessionFactory' defined in class path resource [com/baomidou/mybatisplus/autoconfigure/MybatisPlusAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method 'sqlSessionFactory' threw exception; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: 'file [D:\software\catalystplus-release\catalystplus-ranking\target\classes\mapper\QrtzBlobTriggersMapper.xml]'; nested exception is com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: @TableId can't more than one in Class: "com.catalystplus.ranking.entity.QrtzBlobTriggers". at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:656) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4045e83faa99792a68f6749866faa3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d976ebe08c02fee2e0714e59c7d981/" rel="bookmark">
			How to make nand flash factory bin image?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. How to make nand flash factory bin?Step1. Create workspace directoryStep2. Prepare for the partition binsStep3. Create shell scriptStep4. Delivery the factory bin image 2. Script Example2.1 Alder2.2 Miami When you make a NAND FLASH factory bin image, you need to use a factory bin delivery tool that QC engineer will provide to you.
1. How to make nand flash factory bin? You can make a factory bin as below steps,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55d976ebe08c02fee2e0714e59c7d981/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d33d5a8126afdd3ab533b020948e47/" rel="bookmark">
			android 源碼開發環境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 通用Android环境和工具配置
1. 系统更新升级
sudo apt-get update
sudo apt-get upgrade
2. 配置ntlmaps代理上网环境（本公司网络需要代理）
sudo apt-get update
sudo apt-get install ntlmaps
Parent proxy：cnkusisal
Parent proxy port：8080
NT Windows domain：xxxcn
以后如果需要重新配置ntlmaps可以用下面命令：
sudo dpkg-reconfigure ntlmaps
3. 安装搜狗输入法
下载Linux版搜狗输入法：http://pinyin.sogou.com/linux/
安装输入法：
sudo apt-get install -f
sudo dpkg -i sogoupinyin_2.0.0.0072_amd64.deb
打开语言设置
fcitx-config-gtk3
如果没有一个键盘，在Addon中全部勾选，重启
按+，不要勾选“Only ... ...”，选择搜狗，重启
4. 安装VIM文本编辑器
sudo apt-get install vim
5. 安装其他工具
a. 安装系统状态监测Syspeek
sudo add-apt-repository ppa:nilarimogard/webupd8
sudo apt-get update
sudo apt-get install syspee
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1d33d5a8126afdd3ab533b020948e47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2e8a3756acdde3d7c9b64e7e93c683/" rel="bookmark">
			EMQX的docker部署与使用(mqtt)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：先创建一个挂载emqx的目录 2：docker拉去emqx docker pull emqx/emqx:latest 2-1：先启动一次eqmx，然后停止，删除容器 docker run -d --name emqx --privileged=true -p 1883:1883 -p 8883:8883 -p 8083:8083 -p 8084:8084 -p 8081:8081 -p 18083:18083 emqx/emqx:latest 2-2：然后复制eqmx目录 docker cp emqx:/opt/emqx . 这个命令是使用 Docker 的 docker cp 命令来从一个正在运行的容器中将文件或目录复制到主机上这里是引用具体解释如下：docker cp：Docker 命令，用于在容器和主机之间复制文件或目录。emqx：容器名称或容器 ID，指定要复制文件或目录的容器。/opt/emqx：容器内的路径，指定要复制的文件或目录在容器内的位置。. 主机内的路径，指定要将文件或目录复制到主机上的位置。. 表示当前用户的主目录。综合起来，命令 docker cp emqx:/opt/emqx ~ 表示将容器 emqx 中位于 /opt/emqx 路径下的文件或目录复制到当前用户的主目录下。这可以将容器内的文件或目录复制到主机上进行查看、编辑或处理。 2-3：然后停止，删除容器 docker stop emqx docker rm emqx 2-4：再重新启动容器与挂载 docker run -d --name emqx --privileged=true -p 1883:1883 -p 8883:8883 -p 8083:8083 -p 8084:8084 -p 8081:8081 -p 18083:18083 -v /root/emqx:/opt/emqx emqx/emqx:latest 3：登录EMQX的dashboard界面：输入http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f2e8a3756acdde3d7c9b64e7e93c683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8d1653c66090bd86323bd740d53ea6/" rel="bookmark">
			关于若依（ruoyi）前端，f12跟踪失效的问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、根据作者反馈，使用了vite-plugin-vue-setup-extend该插件；
2、参考作者指导，我采用了去掉这个插件的方法；
具体操作：
（1）找到package.json,去掉该插件；
（2）继续，调整对应的依赖，进行去掉，或注释；
按照如上操作，就可以实现f12跟踪前端代码的需求了；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2772c7970776e13970de1bf04155b12e/" rel="bookmark">
			WATLOW ANAFAZE CLS208 系统模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Watlow ANAFAZE CLS208 是一个系统模块，是 ANAFAZE 模块化过程控制系统的一部分。以下是有关此模块的一些关键细节：
产品名称：ANAFAZE CLS208系统模块
制造商：Watlow Electric Manufacturing Company
兼容性：ANAFAZE 模块化过程控制系统
输入：16 个模拟输入（0-10VDC 或 4-20mA），8 个数字输入（24VDC），1 个外部参考输入（0-10VDC）\V/; 18579229209
输出：16 个模拟输出（0-10VDC 或 4-20mA），8 个数字输出（24VDC）
控制功能：PID控制、开关控制、斜坡/保温控制
通信：RS-232串行通信，ANAFAZE通信协议
电源要求：90-250VAC，47-63Hz，最大 180VA
工作温度：0至50摄氏度
储存温度：-20至70摄氏度
尺寸：43.2 厘米 x 38.1 厘米 x 8.9 厘米（17" x 15" x 3.5"）
重量：6.4 千克（14.1 磅）
Watlow ANAFAZE CLS208 系统模块是 ANAFAZE 模块化过程控制系统的多功能且功能强大的组件。它的输入和输出允许对范围广泛的过程变量进行精确控制，而其通信能力使其能够轻松集成到更大的控制系统中。如果您需要将 CLS208 模块集成到您的 ANAFAZE 系统中，请务必查阅制造商的文档以获取安装说明和任何所需的软件更新。
REF615A_E HAFAABAAABE1BCA1XE
PM864AK01 3BSE018161R1
PCD232A 3BHE022293R0101REF542PLUS 1VCR007346
REF542PLUS 1VCF752000
PPD113B03-26-100100 3BHE023584R2625
PP865A 3BSE042236R2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2772c7970776e13970de1bf04155b12e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ea1a3338cdf4a2d1ba2fcfaca01e0e/" rel="bookmark">
			Visio 画大括号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Visio文档中，依次点击“文件(File)”—“更多形状(Shapes)”–“其他Visio方案(Visio Extras)”—“标注(Callouts)”，然后左边的选项中多了“标注”栏，在“标注”栏中有“侧边大括号”（默认是右侧，旋转180之后就是左侧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0abcaafda417d5f2a2fa1530f8019ae7/" rel="bookmark">
			CentOS/RHEL 7/8 进入单用户模式的三种方法（linux救砖指南）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Single user mode, also referred to as maintenance mode, allows a single super user to recover/repair the system problems.
Generally, these problems cannot be solved in a multi-user environment. The system can boot but will not function properly OR you won’t be able to log in.
Maintenance mode uses runlevel1.target or rescue.target on Red Hat (RHEL) 7/8 based systems.
In this mode, the system mounts all local file systems, but does not activate network interfaces.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0abcaafda417d5f2a2fa1530f8019ae7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62bc4f0dd4675d79ea63ec4bf7728b48/" rel="bookmark">
			华为云云耀云服务器L实例评测 | 华为云部署Docker容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是Docker二、Docker 的好处☁️模块化⛅层和镜像版本控制❄️回滚⚡快速部署 三、华为云云耀云服务器L实例安装 Docker四、Docker 安装镜像测试五、Docker 常用命令⛵小结 一、什么是Docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的或操作系统的机器上，也可以实现。容器是完全使用机制，相互之间不会有任何接口。
二、Docker 的好处 ☁️模块化 Docker 容器化方法非常注重在不停止整个应用的情况下 ，单独截取部分应用进行更新或修复的能力。除了这种基于微服务的方法，您还可以采用与面向服务的架构（SOA）类似的使用方法，在多个应用间共享进程。
⛅层和镜像版本控制 每个 Docker 镜像文件都包含多个层。这些层组合在一起，构成单个镜像。每当镜像发生改变时，就会创建一个新的镜像层。用户每次发出命令（例如 run 或 copy）时，都会创建一个新的镜像层。
Docker 重复使用这些层来构建新容器，借此帮助加快流程构建。镜像之间会共享中间变化，从而进一步提升速度、规模以及效率。版本控制是镜像层本身自带的能力。每次发生新的更改时，您大都会获得一个内置的更改日志，实现对容器镜像的全盘管控。
❄️回滚 回滚也许是层最值得一提的功能。每个镜像都拥有多个层。举例而言，如果您不喜欢迭代后的镜像版本，完全可以通过回滚，返回之前的版本。这一功能还支持敏捷开发方法，帮助持续实施集成和部署（CI/CD），使其在工具层面成为一种现实。
⚡快速部署 启动和运行新硬件、实施部署并投入使用，这在过去一般需要数天时间。投入的心力和成本往往也让人不堪重负。基于 Docker 的容器可将部署时间缩短到几秒。通过为每个进程构建容器，您可以快速将这些类似进程应用到新的应用程序中。而且，由于无需启动操作系统即可添加或移动容器，因此大幅缩短了部署时间。除此之外，得益于这种部署速度，您可以轻松无虞、经济高效地创建和销毁容器创建的数据。
因此，Docker 技术是一种更加精细、可控、基于微服务的技术，可为企业提供更高的效率价值。
三、华为云云耀云服务器L实例安装 Docker 云耀云服务器L实例购买
打开华为云官网
新用户可以领取更多的大额优惠，购买更划算。
购买后进入 云耀云服务器L实例 控制台，复制IP地址通过xshell远程链接。
进入后复制 公网弹性 IP地址，进行远程链接
连接云耀云服务器L实例
新建回话 输入ip地址，密码 即可链接成功 如下：
环境准备
uname -r 查看系统配置
cat /etc/os-release 系统为CentOS 7以上 最好！
先查看本机是否存在Docker，删除旧版本Docker
查看docker 版本
docker version 没有docker，我们执行以下命令，删除残余文件
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 进入Linux根目录，安装Docker
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62bc4f0dd4675d79ea63ec4bf7728b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e03e8244ad11a8fb2aad56b0cc16a1a/" rel="bookmark">
			cpolar 的内网渗透（抵挡不住攻击，可内部使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
系列文章概述1. Windows安装StudyPHP 1.1 下载后解压并安装1.2 打开默认站点，测试2 下载静态演示站点 2.1 下载演示站点2.2 解压并复制2.3 打开站点根目录2.4 复制演示站点到站网根目录2.2 在浏览器中，查看演示效果。3. 将站点发布到公网 3.1 生成cpolar随机URL公网地址3.2 复制命令行窗口里的随机网址3.3 如何生成一个非随机的公网URL？总结下一步做什么？ 系列文章 Windows用户如何安装Cpolar如何在Windows上搭建Web站点，并发布到公网 1/2如何在Windows上搭建Web站点，并发布到公网 2/2如何在Windows下搭建WordPress博客站点并发布到公网如何为Windows上的WordPress站点配置自己的域名并公网可访问如何为WordPress站点配置HTTPS证书远程办公神器:如何在家里远程办公室的电脑,利用Cpolar远程办公神器：如何使用Cpolar远程桌面，配置固定TCP端口地址 概述 这非常适合设置您的第一个网站，我们将在Windows上搭建一个PHP站点环境，然后部署一个演示站点，并且将它发布到公网上。让您的好友及用户可以访问到它。
1. Windows安装StudyPHP 官网下载：Windows版phpstudy下载 - 小皮面板(phpstudy)
1.1 下载后解压并安装 安装后的效果，如图：
点击，一键启动 WNMP 旁边的启动按钮
会默认启动nginx，MYSQL 5.7
在启动过程中，如有提示防火墙提示，允许即可。
1.2 打开默认站点，测试 在StudyPHP面版–网站–选择localhost 80的默认站点，点击管理，弹出下拉菜单，选择打开网站，会弹出浏览器，打开本地默认站点http://localhost
如下图，说明安装成功。
2 下载静态演示站点 2.1 下载演示站点 下载:https://www.cpolar.com/static/downloads/meditation-app-master.zip
2.2 解压并复制 下载后，解压缩，复制目录下的所有文件，如下图
2.3 打开站点根目录 我们找到并打开网站的根目录
默认在 D:\phpstudy_pro\WWW, 我们将目录里所有文件删除，如下图
2.4 复制演示站点到站网根目录 复制我们的演示站点所有文件到该目录下,复制后如下图：
2.2 在浏览器中，查看演示效果。 这是一个冥想站点，可以选择2-5-10分钟不同的时间，可以切换下雨与阳光不同的情景。用于放松自我，调解心境，给自己做一个心灵SPA
3. 将站点发布到公网 这里，使用cpolar内网穿透工具，如果您还没有安装，请参考前一篇教程《如何在Windows下安装cpoalr》
3.1 生成cpolar随机URL公网地址 打开命令行窗口：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e03e8244ad11a8fb2aad56b0cc16a1a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/91/">«</a>
	<span class="pagination__item pagination__item--current">92/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/93/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>