<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5c71aa29c0d548062d8be39e3f01c69/" rel="bookmark">
			速下载｜2023上半年网络与数据安全法规政策、国标、报告合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着国家数字经济建设进程加快，数据安全立法实现由点到面、由面到体加速构建，目前我国数据安全立法已基本形成以《网络安全法》《数据安全法》《个人信息保护法》《密码法》等法律为核心，行政法规、部门规章为依托，地方性法规、地方规章为抓手，国家标准为指南的数据安全法规保障体系。
顶层政策出台，构建数据安全发展支撑。2023年1月，工信部等十六部门联合印发《关于促进数据安全产业发展的指导意见》，提出到2025年，数据安全产业基础能力和综合实力明显增强，产业规模超过1500亿元，到2035年，数据安全产业进入繁荣成熟期。2023年3月《数字中国建设整体布局规划》要强化数字中国关键能力。筑牢可信可控的数字安全屏障。切实维护网络安全，完善网络安全法律法规和政策体系。增强数据安全保障能力，建立数据分类分级保护基础制度，健全网络数据监测预警和应急处置工作体系。2023年4月《商用密码管理条例》在1999年发布24年后重新修订发布，旨在规范商用密码应用和管理，鼓励和促进商用密码产业发展，保障网络与信息安全，促进了商用密码技术的研发和应用，推动了数据安全产业的发展，为数字化时代的可持续发展提供了有力的保障。
组建监管部门，为数据安全治理强力加持。2023年3月《党和国家机构改革方案》指出，组建国家数据局，负责协调推进数据基础制度建设，统筹数据资源整合共享和开发利用，推进数字中国、数字经济、数字社会规划和建设等，为数据安全治理提供强力支撑。具体来说，国家数据局将从完善数据全流程合规与监管规则体系、统筹构建规范高效的数据交易场所、统筹构建规范高效的数据交易场所、构建数据安全合规有序机制四个方面对流通和交易制度进行构建，促进数字化转型升级和高质量发展。
为助力产业发展，炼石搜集整理2023上半年91项网络与数据安全相关政策，包括13项国家政策法律、10项重点行业政策、21项地方政策规章、31项国家技术标准、16项重点领域报告，为行业同仁提供参考。
总览图
关注炼石的本公众号（或从微信中搜索公众号：炼石网络CipherGateway）并后台回复关键词“炼石就是数据安全058”，即可打包下载91项2023年上半年网络与数据安全政策文件。
注：由于部分国家标准采用了ISO、IEC等国际国外组织的标准，鉴于版权保护问题，故有3项国标（总31项）无法提供文件下载。
为了共同推动数据安全产业发展，欢迎行业同仁加入“[炼石】数据安全法规圈”微信群，探讨数据安全领域的政策动态和合规要求。
国家法律规章
《商用密码管理条例》
【施行时间】2023/7/1
【发布单位】国务院第4次常务会议
【概述要求】《商用密码管理条例》（国令第760号），已于2023年4月14日国务院第4次常务会议修订通过，自2023年7月1日起施行。《条例》规定，规范商用密码应用和管理，鼓励和促进商用密码产业发展，保障网络与信息安全，维护国家安全和社会公共利益，保护公民、法人和其他组织的合法权益。法律、行政法规和国家有关规定要求使用商用密码进行保护的关键信息基础设施，使用的商用密码产品、服务应当经检测认证合格，使用的密码算法、密码协议、密钥管理机制等商用密码技术应当通过国家密码管理部门审查鉴定。
《反间谍法》
【施行时间】2023/7/1
【发布单位】第十四届全国人民代表大会常务委员会第二次会议
【概述要求】《反间谍法》规定，任何个人和组织都不得非法获取、持有属于国家秘密的文件、数据、资料、物品。违反本法规定，拒不配合数据调取的，由国家安全机关依照《中华人民共和国数据安全法》的有关规定予以处罚。
《关于推进IPv6技术演进和应用创新发展的实施意见》
【发布时间】2023/4/20
【发布单位】工业和信息化部
【概述要求】《实施意见》以促进IPv6技术演进和应用创新发展、增强IPv6规模部署和应用内生动力为目标，打造技术、网络、设备、应用、安全协同互促的产业生态，构筑下一代互联网创新发展新优势，积极助力制造强国、网络强国和数字中国建设，有力支撑经济社会高质量发展。
《关于加强新时代检察机关网络法治工作的意见》
【发布时间】2023/4/18
【发布单位】最高人民检察院
【概述要求】《意见》共6方面21条，围绕党的二十大关于健全网络综合治理体系的重要部署，结合检察履职实际，从网络立法、执法、司法、普法以及法治研究、队伍建设等方面，对加强新时代检察机关网络法治工作提出具体要求。
《关于调整网络安全专用产品安全管理有关事项的公告》
【发布时间】2023/4/12
【发布单位】国家互联网信息办公室、工信部、公安部、财政部、国家认监委
【概述要求】《公告》要求，加强网络安全专用产品安全管理，推动安全认证和安全检测结果互认，避免重复认证、检测。
《关于开展网络安全服务认证工作的实施意见》
【发布时间】2023/3/25
【发布单位】市场监管总局、中央网信办、工信部、公安部
【概述要求】《实施意见》为推进网络安全服务认证体系建设，提升网络安全服务机构能力水平和服务质量，根据《网络安全法》《认证认可条例》，市场监管总局、中央网信办、工业和信息化部、公安部就开展国家统一推行的网络安全服务认证工作提出以下意见。
《网信部门行政执法程序规定》
【发布时间】2023/3/18
【发布单位】国家互联网信息办公室
【概述要求】《规定》为了规范和保障网信部门依法履行职责，保护公民、法人和其他组织的合法权益，维护国家安全和公共利益。
《党和国家机构改革方案》
【发布时间】2023/3/16
【发布单位】中共中央、国务院
【概述要求】《方案》指出，组建国家数据局。负责协调推进数据基础制度建设，统筹数据资源整合共享和开发利用，统筹推进数字中国、数字经济、数字社会规划和建设等，由国家发展和改革委员会管理。
《数字中国建设整体布局规划》
【发布时间】2023/2/27
【发布单位】中共中央、国务院
【概述要求】《规划》指出，要强化数字中国关键能力。筑牢可信可控的数字安全屏障。切实维护网络安全，完善网络安全法律法规和政策体系。增强数据安全保障能力，建立数据分类分级保护基础制度，健全网络数据监测预警和应急处置工作体系。
《个人信息出境标准合同办法》
【发布时间】2023/2/22
【发布单位】国家互联网信息办公室
【概述要求】《办法》为了保护个人信息权益，规范个人信息出境活动，根据《中华人民共和国个人信息保护法》等法律法规，制定本办法。
《关于进一步做好两用物项出口管制工作的通知》
【发布时间】2023/2/12
【发布单位】商务部
【概述要求】《办法》明确，核心机构和经营机构应当依法履行网络和信息安全保护义务，对本机构网络和信息安全负责，相关责任不因其他机构提供产品或者服务进行转移或者减轻。信息技术系统服务机构应当勤勉尽责，对提供产品或者服务的安全性、合规性承担责任。
《关于进一步鼓励外商投资设立研发中心的若干措施》
【发布时间】2023/1/11
【发布单位】商务部、科技部
【概述要求】《若干措施》为加快实施创新驱动发展战略，扩大国际科技交流合作，加大对外商投资在华设立研发中心开展科技研发创新活动的支持力度，更好发挥其服务构建新发展格局、推动高质量发展的积极作用，
《关于促进数据安全产业发展的指导意见》
【发布时间】2023/1/3
【发布单位】工业和信息化部等十六部门
【概述要求】数据安全产业是为保障数据持续处于有效保护、合法利用、有序流动状态提供技术、产品和服务的新兴业态。为贯彻落实《中华人民共和国数据安全法》，推动数据安全产业高质量发展，提高各行业各领域数据安全保障能力，加速数据要素市场培育和价值释放，夯实数字中国建设和数字经济发展基础，制定本意见。
重点行业政策
金融
《关于加强境内企业境外发行证券和上市相关保密和档案管理工作的规定》
【发布时间】2023/2/24
【发布单位】中国证监会 财政部 国家保密局 国家档案局
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5c71aa29c0d548062d8be39e3f01c69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c325b13501a72cc6963fad1b9a5033b/" rel="bookmark">
			如何解决opencv-python，以及opencv-contrib-python包安装运行解决人脸识别问题等问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		痛苦 通过老师给的教程一直下载一直下载，下载不能通过而且把系统弄崩了只能重装系统，家人们谁能懂重装系统7、8次的痛苦啊最后我终于终于解决了
遇到的问题 下载的opencv-python慢，需要等待的时间长，浪费大量时间
opencv-python下载包解压不能完全解压，解压出问题
opencv-python的依赖项目没有下载全，不能很好的启动，并且报错
opencv-contrib-python库的安装慢
问题的原因 opencv-python在清华的库中没有，要从国外的库下载就很慢
可能跟TF卡内存以及树莓派内存大小有关
需要安装相关库
也要指定pip的库源，不然下载慢
问题的解决 我下载的版本是4.1.0.25
opencv-python国外下载地址
https://www.piwheels.org/simple/opencv-python/opencv_python-4.1.0.25-cp37-cp37m-linux_armv7l.whl
opencv-python安装 解决的关键是opencv-python这个包就不能通过pip3安装，所以我是怎么安装的呢
首先开启网络魔法，从国外网站下载whl安装包,从自己的电脑上传到树莓派自己指定的文件夹
下面是whl包解压办法：要在树莓派4WD小车上直接解压OpenCV的Python的.whl文件，你可以按照以下步骤进行操作：
首先，在你的树莓派上安装zip工具：
&lt;span style="background-color:#f8f8f8"&gt;&lt;span style="color:#3300aa"&gt;sudo&lt;/span&gt; apt-get install zip&lt;/span&gt; 将OpenCV的.whl文件（例如，opencv_python-4.5.3.56-cp37-cp37m-linux_armv7l.whl）下载到树莓派的某个目录中。
进入保存了.whl文件的目录：
&lt;span style="background-color:#f8f8f8"&gt;&lt;span style="color:#3300aa"&gt;cd&lt;/span&gt; /path/to/your/whl/file&lt;/span&gt; 创建一个临时目录来解压.whl文件：
&lt;span style="background-color:#f8f8f8"&gt;&lt;span style="color:#3300aa"&gt;mkdir&lt;/span&gt; temp&lt;/span&gt; 使用zip工具解压.whl文件到临时目录：
&lt;span style="background-color:#f8f8f8"&gt;unzip opencv_python-4.5.3.56-cp37-cp37m-linux_armv7l.whl &lt;span style="color:#0000cc"&gt;-d&lt;/span&gt; temp&lt;/span&gt; 进入临时目录：
&lt;span style="background-color:#f8f8f8"&gt;&lt;span style="color:#3300aa"&gt;cd&lt;/span&gt; temp&lt;/span&gt; 在临时目录中你将找到解压后的OpenCV文件。你可以将它们复制到你希望存放OpenCV文件的目录中，例如Python的site-packages目录：
&lt;span style="background-color:#f8f8f8"&gt;&lt;span style="color:#3300aa"&gt;sudo&lt;/span&gt; &lt;span style="color:#3300aa"&gt;cp&lt;/span&gt; &lt;span style="color:#0000cc"&gt;-r&lt;/span&gt; cv2 /usr/local/lib/python3.7/site-packages&lt;/span&gt; 请注意，上述路径/usr/local/lib/python3.7/site-packages适用于Python 3.7版本。如果你使用的是其他Python版本，请相应地修改路径。在我们的系统上，python3.7的包都安装在dist-packages里面（也许是其他自己看一下）
最后，删除临时目录：
&lt;span style="background-color:#f8f8f8"&gt;&lt;span style="color:#3300aa"&gt;cd&lt;/span&gt; .. &lt;span style="color:#3300aa"&gt;rm&lt;/span&gt; &lt;span style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c325b13501a72cc6963fad1b9a5033b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ae75e0892c1c4531bffd278cadd6f16/" rel="bookmark">
			边界值法和等价类方法的异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		边界值属于等价类方法的特定输入域，包含在有效等价类或无效等价类中，根据等价类推断理论，
边界值方法产生的测试效果与等价类方法相同，只是边界值方法选择测试数据时更有针对性，通常
选择输入域的边界值。
从事测试7年后更新答案：
边界值法（Boundary Value Analysis）和等价类方法（Equivalence Partitioning）是软件测试中常用的两种黑盒测试技术，它们都旨在帮助测试人员更有效地设计测试用例。以下是它们的异同点：
相同点：
目标：边界值法和等价类方法都是用于选择有效和高效的测试用例，以最大程度地覆盖输入领域和边界条件。输入分区：两种方法都将输入域划分为不同的等价类或边界值分区，以减少测试用例的数量。质量改进：两种方法都有助于发现和修复潜在的缺陷，并提高软件质量。 异同点：
侧重点：边界值法更加注重测试输入的边界条件，包括边界上、边界内和边界外的值，以检测可能的边界问题。而等价类方法则更注重将输入域划分为等价类，每个等价类中的值被认为具有相同的测试行为。测试用例选择：边界值法关注于选择特定的边界值和边界附近的值作为测试用例，以验证系统的行为是否正确。而等价类方法关注于选择代表每个等价类的典型测试用例，以验证每个等价类的行为是否一致。用例数量：边界值法生成的测试用例通常比等价类方法更多，因为它需要考虑每个边界和边界附近的值。而等价类方法通过选择代表性的测试用例，可以减少测试用例的数量。适用范围：边界值法通常适用于具有数值范围或限制条件的输入，如数字、日期和时间等。而等价类方法适用于将输入域划分为不同等价类的场景，无论输入类型是数字、字符串还是其他类型。精确度：边界值法可以更精确地发现可能的边界问题和错误。等价类方法虽然可能无法覆盖所有可能的边界情况，但可以提供对等价类的广泛覆盖。 总的来说，边界值法和等价类方法是两种有效的测试设计技术，它们在测试用例选择和输入分区上有所不同，测试人员可以根据具体情况和测试目标选择适合的方法或结合使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3534428f7ca6048224caa886e2f6bd08/" rel="bookmark">
			利用官方工具将百万级cvs数据文件导入oracle数据库（Windows系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到的问题：需要跨服务器将数据处理到另一台数据库，数据为百万级，凭借代码获取导入时间过慢
处理方法：利用oracle提供的官方数据sqlldr
一、 安装官方工具 下载sqlldr官方工具链接
下载好以后解压，会得到一个命名为instantclient_19_17的文件夹，打开里面会有sqlldr.exe的文件
二、 打开dos进入到该文件夹里，输入sqlldr测试是否安装完成 #此处我输入时提示【无法启动此程序，因为计算机中丢失VCRUNTIME140.dll】，于是还要下载Windows插件：vs_redist_x64下载地址
安装完成会显示如下图数据
三、 使用sqlldr 1、 首先编辑执行脚本文件，文件名：load_csv_data.ctl
options(skip=1) load data CHARACTERSET UTF8 infile 'D:\dir1\dir2\20221205\part-001.csv' append into table "table_name" WHEN status = 'used' fields terminated by '|' TRAILING NULLCOLS (id,name,age,address,col01,col02) 释义
options(skip=1) #跳过第一行（一般用于文件首行为表头的情况）
load data
CHARACTERSET UTF8 #设置编码格式（当导入数据库数据出现中文乱码时设置此行）
infile 'D:\dir1\dir2\20221205\part-001.csv' #导入文件的路径
infile 'D:\dir1\dir2\20221205\part-002.csv' #可多行
append into table "table_name" #对应的数据库表名
WHEN status = 'used' #过滤数据条件
fields terminated by '' #导入文件数据分隔符，看文件内容更换
TRAILING NULLCOLS #遇到空值也作插入，没有此行大概率会报错
(id,name,age,col01,col02) #对应的表中字段名，与导入文件数据列顺序需一一对应
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3534428f7ca6048224caa886e2f6bd08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d24bf90e10be8212a67c750722b8e5/" rel="bookmark">
			HCIP学习笔记-华为云运维方案-9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.云运维概述 1.1 传统运维方式面临的挑战 运维人员技能要求高，配置烦杂，同时需要维护多套系统无法关联分析，虽然指标很多，但需要根据运维经验逐一排查对于分布式追踪系统，学习和使用成本高，并且稳定性较差。 1.2 云上架构对运维的要求 随着IT架构不断演进，系统架构变得越来越复杂，企业云上运维和传统IT运维的差异明显，运维人员也面临着诸多的挑战。在企业内部开发和运维往往是两个独立的部门，在工作和技术方向上存在明显的差异这就造成了在共同完成，个应用项目的时候沟通不顺畅，进而导致应用进度推迟，企业效率大幅度下降。因此，整个体系架构需要不断演进，从传统运维走向自动化运维将运维工程师、开发工程师、质量保障工程师的壁垒打破，从而形成一套高效的工作体系。 1.3 华为云运维及业务运维全景 支撑用户聚焦业务层运维，减少用户在平台日常维护上消耗精力，由华为负责平台运维，为客户提供稳定可靠的云平台Console是面向云资源用户的，用于日常管理资源及发放资源的一个可视化入口。CES/AOM/APM为用户提供立体化监控平台，可以全面了解云上资源使用情况、业务的运行状况，并及时收到异常告警做出反应，保证业务顺畅运行。用户可以通过使用Console(控制台)、CES/AOM/APM(云监控服务)等工具组合完成租户业务支撑活动。 1.4 企业云化应用多样性灵活性带来的挑战 随着微服务的普及，应用间关联关系越来越复杂，单纯通过维护人员进行管理已经越来越不现实。需要借助专业的软件工具，对应用间调用等场景进行全方面的监控，可视化地还原业务的执行轨迹和状态，协助性能及故障快速定位等。应用上云后，微服务依赖关系能否可视化、最终用户体验如何、问题如何快速追踪散落的日志无法关联分析?如何解决或改善此类问题?华为云包含多种运维服务，帮助运维人员简化运维流程、提高运维效率。 1.5 云应用立体运维解决方案全景 华为云推出云应用立体运维解决方案，融合了华为云的应用运维管理服务AOM、应用性能管理服务APM等服务，对基础设施层、应用层、业务层实时多维度监控，并通过应用与资源告警关联、日志分析、智能闯值、分布式调用追踪、手机APP异常分析等技术，实现分钟级问题快速诊断和修复，保障应用长稳运行, 针对海量资源监控场景: AOM提供实时监控应用及云资源，采集各项指标、日志及事件等数据分析应用健康状态，提供告警及数据可视化功能针对海量日志管理场景:LTS提供日志收集、实时查询、存储等功能，帮助用户轻松应对日志实时采集:5查询分析等日常运营、运维场景针对性能问题定位场景:APM提供专业的分布式应用性能分析能力，帮助运维人员快速解决分布式架构下的问题定位和性能瓶颈等难题。 2.开源运维工具 2.1 Prometheus介绍 Prometheus是一款开源的监控工具，它启发于Google的borgmon监控系统，由工作在SoundCloud的Google前员工在2012年创建，作为社区开源项目进行开发，并于2015年正式发布。2016年，Prometheus正式加入Cloud Native ComputingEoundation，成为受欢迎度仅次于Kubernetes的项目。监控作为可观察性实践(监控、日志、追踪》中的关键一环，相较以往的系统监控在云原生时代产生了诸多变化。一是微服务和容器化，导致监控对象和指标的指数级增加;二是监控对象的生命周期更加短暂，导致监控数据量和复杂度的成倍增加。这就需要一款统一监控指标和数据查询语言的工具，Prometheus应运而生了Pemetheus可以很方便的与众多开源项目集成，帮助我们了解系统和服务的运行状态另一方面分析其收集的大数据，可以帮助我们进行系统优化和作出决策。它不仅是可以应用在IT领域，对于任何需要收集指标数据的情形下都可以使用。PromQL是Prometheus针对这种带标签的时序数据开发的查询语句。它与针对关系数据库的查询语句SQL是完全不同的。Prometheus可以理解为一个时间序列数据库。当然，它不仅仅是一个时间序列数据库。它涵盖了可以绑定的整个生态系统工具集及其功能。Prometheus主要用于对基础设施的监控，包括服务器( CPU、MEM等)、数据库(MySQL、PostgreSQL等)、Web服务等，几乎所有东西都可以通过Prometheus进行监控。而它的数据，则是通过配置，建立与数据源的联系来获取的。 2.2 Prometheus架构图 Prometheus专为可靠性而设计，可让用户快速诊断问题。每个Prometheus服务器都是独立的，不依赖于网络存储或其他远程服务。基本实现原理是从exporter拉取数据，或者间接地通过网关qatewav拉取数据(如果在k8s内部署，可以使用服务发现的方式)，它默认本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，9并把得到的结果存储到新的时间序列中，采集到的数据有两个去向，一个是报警，另一个是可视化。Prometheus组件使用逻辑: Prometheus server 定期从静态配置的target或者服务发现的target拉取数据当新拉取的数据大于配置内存缓存区的时候，Prometheus会将数据持久化到磁盘(如果使用Remote storage将持久化到云端 )Prometheus可定时查询数据，当条件触发的时候，会将alert推送到配置的Alertmanager。Alertmanager收到警告的时，可以根据配置聚合、去重、降噪，最后发送警告。可以使用API、Prometheus Console或者Grafana查询和聚合数据 Prometheus有两种数据采集方式，pull主动拉取和push被动推送 pull: 指的是客户端先安装各类已有的exporters并以守护进程的模式运行Explorter采集数据并且可以对http请求作出响应，返回metrics数据Prometheus通过pull的方式(HTTP GET)去访问每个节点上的exporter并返回hw35802903需要的数据。push：指的是客户端(或服务端)安装官方的pushgateway插件，将监控数据组织成metrics的形式发送给pushgateway，而后pushgateway再推送给prometheus，这里需要注意的是pushgateway只是一个中间转发的媒介 2.3 Grafana介绍 主要有以下六大特点: 展示方式:快速灵活的客户端图表，具备丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式。数据源:支持多种数据源，如:Graphite/InfluxDB/OpenTSDB/Prometheus/Elasticsearch等。通知提醒: 根据不同指标定义不同的告警规则，计算是否触发告警并发送通知混合展示:在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源。注释:使用来自不同数据源的丰富事件注释图表，将鼠标悬停在事件上会显示完整的事件元数据和标记。过滤器: Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。 TSDB是针对时间戳或时间序列数据进行优化的数据库，专门为处理带有时间戳的度量和事件或度量而构建的。时间序列数据可以是随时间跟踪、监视、下采样和聚合的度量或事件，如服务器指标、应用程序性能、网络数据及许多其他类型的分析数据.Grafana主要组件介绍: filebeat: 采集ftds数据metricbeat: 采集系统资源数据logstash: 日志清洗,influxdb: 分布式时序数据库grafana: 数据展示。 2.4 Prometheus+Grafana Fluentd_exporter日志收集、处理转发Node_exporter 主机数据采集。 2.5 开源运维解决方案架构 通过Prometheus实现对Kubernetes集群监控，可以支持: 节点: cpu、load、fdisk、memory等指标。内部组件的状态:比如kube-scheduler、kube-controller-manager、kubedns/coredns等组件的运行状态应用: 比如Deployment的状态、资源请求、调度和API延迟等数据指标。 3.华为云运维服务 3.1 云监控服务 CES 云监控服务主要具有以下功能: 云资源自动监控: 云监控服务不需要开通，在创建弹性云服务器等资源后监控服务会自动启动，可以直接到云监控服务查看该资源运行状态并设置告警规则主机监控: 通过在弹性云服务或裸金属服务器中安装云监控服务Agent插件用户可以实时采集ECS或BMS分钟级粒度的监控数据。灵活配置告警规则: 对监控指标设置告警规则时，支持对多个云服务资源同时添加告警规则。告警规则创建完成后，可随时修改告警规则，支持对告警规则进行启用、停止、删除等灵活操作。实时通知: 通过在告警规则中开启消息通知服务，当云服务的状态变化触发告警规则设置的闯值时?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d24bf90e10be8212a67c750722b8e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1705ed4dfb0e86dd3d7be38bd7f14580/" rel="bookmark">
			【区块链】BLS数字签名算法介绍及拓展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 BLS数字签名原理概念须知基础应用单个签名单个签名验证 比特币中的应用签名聚合聚合签名验证 联盟链中的应用(m,m)多重签名(m,n)多重签名(较复杂，重点) BLS的缺陷 JAVA简单实现 BLS数字签名原理 概念须知 曲线哈希（Hashing to the curve）曲线配对（curves pairing）双线性配对特性(方便理解聚合签名)
e ( a ∗ b , p ) = e ( b , a ∗ p ) e(a*b,p)=e(b,a*p) e(a∗b,p)=e(b,a∗p)
e ( a , b + c ) = e ( a , b ) ∗ e ( a , c ) e(a,b+c)=e(a,b)*e(a,c) e(a,b+c)=e(a,b)∗e(a,c) 更加具体的介绍，网上很多，此处不赘述。
基础应用 单个签名 1、 p k pk pk代表私钥， P = p k ∗ G P=pk*G P=pk∗G代表公钥， m s g msg msg代表要签名的消息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1705ed4dfb0e86dd3d7be38bd7f14580/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980b7cace2be2a7494f1dbec56b9727f/" rel="bookmark">
			HTML5 游戏开发实战 ｜ 五子棋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五子棋是一种家喻户晓的棋类游戏，它的多变吸引了无数的玩家。本章首先实现单机五子棋游戏(两人轮流下)，而后改进为人机对战版。整个游戏棋盘格数为 15×15，单击鼠标落子，黑子先落。在每次下棋子前，程序先判断该处有无棋子，有则不能落子，超出边界不能落子。任何一方有横向、竖向、斜向、反斜向连到 5 个棋子则胜利。
五子棋游戏的运行界面如上图所示。
01、五子棋游戏设计的思路 在下棋过程中，为了保存下过的棋子的信息，使用数组 chessData。chessData［x］［y］存储棋盘(x，y)处棋子信息，1 代表黑子，2 代表白子，0 为无棋子。
整个游戏运行时，在鼠标单击事件中判断单击位置是否合法，既不能在已有棋的位置单击，也不能超出游戏棋盘边界，如果合法则将此位置信息加入 chessData，同时调用 judge(x，y，chess)判断游戏的输赢。
02、关键技术 判断输赢的算法
本游戏关键技术是判断输赢的算法。对于算法具体实现大致如下：
判断 X=Y 轴上是否形成五子连珠；
判断 X=-Y 轴上是否形成五子连珠；
判断 X 轴上是否形成五子连珠；
判断 Y 轴上是否形成五子连珠。
以上 4 种情况只要任何一种成立，那么就可以判断输赢。
判断输赢实际上不用扫描整个棋盘，如果能得到刚下的棋子位置(x，y)，仅在此棋子附近横竖斜方向均判断一遍即可。
judge(x，y,chess)判断这个棋子是否和其他的棋子连成五子，即输赢判断。它是以(x,y)为中心，横向、纵向、斜方向判断并统计相同个数来实现的。
以水平方向(横向)判断为例，以(x，y)为中心计算水平方向棋子数量时，首先向左统计，相同则 count1 加 1；然后向右统计，相同则 count1 加 1。统计完成后，如果 count1&gt;=5 则说明水平方向连成五子，其他方向同理。
function judge(x，y， chess) //判断该局的输赢 //保存当前共有多少相同的黑色棋子相连var count1 =0;var count2 = 0;var count3 = 0;var count4 = 0://左右判断,横向的判断//判断横向是否有 5个棋子相连,特点是纵坐标相同,即 chessData[x][y]中y值是相同的//向左统计for(var i=x;i&gt;=0;i--)[if(chessData[i][y] != chess){ break; count1++; for(var i=x+1;&lt;15; i++)!if(chessData[il[y] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/980b7cace2be2a7494f1dbec56b9727f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df9a2100322ac4d419b6a0ecd5420ad/" rel="bookmark">
			ubuntu安装MobaXterm和WPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ubuntu安装MobaXtermi386 架构wine操作步骤 ubuntu安装WPS操作步骤WPS版本知识补充 ubuntu安装MobaXterm i386 架构 sudo dpkg --add-architecture i386 是一个Linux系统中的命令，用于添加一个新的架构（architecture）支持到当前系统的软件包管理工具dpkg。
在Linux系统中，不同的硬件架构可以使用不同的指令集和二进制格式。常见的架构包括 x86_64 (64位), i386 (32位), armhf, arm64等。默认情况下，系统可能只支持当前主要架构，但有时候需要在系统上安装和运行其他架构的软件。
当运行 sudo dpkg --add-architecture i386 命令时，它会告诉**dpkg添加32位x86架构支持（i386）**到当前的系统中，这样你就可以在64位系统上安装和运行32位的软件包。这对于一些旧的或者特定的应用程序可能是必需的。
在添加了 i386 架构后，需要使用 apt update 命令来更新软件包列表，使得新的架构能够生效，然后你就可以使用 apt install 命令来安装32位的软件包了。
wine Wine（Wine Is Not an Emulator）是一个开源的兼容层软件，它允许在类Unix操作系统（如Linux、macOS）上运行Windows应用程序。 Wine并不是一个模拟器，而是实现了Windows API的库，使得Windows应用程序能够在非Windows环境下运行。 Wine的一些主要特点和重要信息：
兼容性：Wine致力于提供尽可能高的兼容性，使得许多Windows程序在Linux和其他Unix-like系统中能够顺利运行。虽然并不是所有的Windows应用都能在Wine下完美运行，但许多常见的Windows程序，特别是较早版本的软件，往往能够很好地在Wine中工作。Windows API 实现：Wine实现了Windows操作系统的API（应用程序编程接口），这样Windows程序可以直接调用这些API，而无需修改源代码。这种“透明”的方式使得很多Windows软件在Linux环境下可以无需改动就运行。WineHQ：Wine项目拥有一个名为WineHQ的官方网站，网站上有关于支持的Windows应用程序的数据库，用户可以查看某个程序在Wine中的兼容性和工作状态。Wine的图形界面：Wine也提供了一些图形界面工具，如winecfg用于配置Wine，winefile用于文件管理，以及wineboot用于模拟Windows的启动过程等。可定制性：用户可以通过配置来调整Wine的行为，如改变Windows版本的模拟、修改注册表等。不需要Windows许可证：Wine是一个自由开源软件，因此它不需要Windows许可证。你可以自由地在Linux、macOS和其他类Unix系统上使用Wine。 操作步骤 Wine是一个允许在Linux系统上运行Windows应用程序的兼容层。尽管Wine在很多情况下都能很好地运行Windows应用程序，但并不是所有应用程序都能完美地在Wine中运行。 安装Wine：//过程较长，请耐心等待 sudo dpkg --add-architecture i386 sudo apt update sudo apt install wine64 wine32 查看ubuntu系统的wine版本wine --version 下载MobaXterm安装程序：
从MobaXterm官方网站下载MobaXterm安装程序
运行安装程序：在终端中导航到下载解压后的MobaXterm目录下，并使用以下命令运行它：
注意文件名称请使用自己下载的文件名称 wine msiexec /i .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df9a2100322ac4d419b6a0ecd5420ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3232bd927d991e6a55ca09e70ec8b98/" rel="bookmark">
			MySQL的体系架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言MySQL的Server层MySQL的存储引擎1）InnoDB 存储引擎2）MyISAM 存储引擎3）Memory 存储引擎 前言 在学习一种事务之前，我们需要先了解事物的基本组成结构，清楚了事物的基本组成结构之后，我们才能更深入的了解相关操作，那么今天我将为大家介绍MySQL的体系架构。
MySQL数据库的服务端主要分为Server层和存储引擎层，接下来我将以这两层为着重点为大家介绍MySQL的体系架构。
MySQL的Server层 MySQL的Server层照顾要有七个组件：
MySQL 向外提供的交互接口（Connectors）连接池组件（Connection Pool）管理服务组件和工具组件（Management Service &amp; Utilities）SQL 接口组件（SQL Interface）查询分析器组件（Parser）优化器组件（Optimizer）查询缓存组件（Query Caches &amp; Buffers） 1）MySQL向外提供的交互接口（Connectors）
Connectors 组件是 MySQL 向外提供的交互组件，如Java，.NET，PHP等语言可以通过该组件来操作 MySQL 语句，实现与 MySQL 的交互。建立连接之后，可以通过show processlist 语句来查看已经建立的连接。
如果客户端一段时间内没有活跃行为，那么连接器在默认的8个小时后会主动断开连接。加果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query。
客户端连接到MySQL数据库上时，根据连接时间的长短可以分为：短连接和长连接。短连接比较简单，指每次查询之后会断开，再次查询需要重新建立连接，因此使用短连接的成本较高；长连接指长时间连接到MySOL数据库上并执行数据库操作，因此长连接会导致出现内存溢出的问题从而使MySQL异常重启。
在使用长连接时，可以使用客户端函数mysql_reset_connection()来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。
2）连接池组件（Connection Pool）
负责监听客户端向MySQL服务器端的各种请求，接收请求、转发请求到目标模块。每个成功连接MySQL服务器端的客户请求都会被创建或分配一个线程，该线程负责客户端与MySQL服务器端的通信，接收客户端发送的命令，传递服务器端的结果信息等。
3）管理服务组件和工具组件（Management Service &amp;Utilities）
提供对MySOL的集成管理，如备份（Backup)、恢复（Recovery）、安全管理（Security）等。
4）SQL接口组件（SQL Interface）
接收用户SQL命令，如DML、DDL和存储过程等，并将最终结果返回给用户。
5）查询分析器组件（Parser）
系统在执行输入语句之前，必须分析出语句想要干什么。例如:首先通过select关键字得知这是一条查询命令，还包括分析要查询的是哪张表以及查询条件是什么。同时，分析器必须分析输入语句的语法正确性。如果SQL中存在语法的错误，则查询分析器组件将返回提示信息“You have an error in your SQL syntax”。
6）优化器组件（Optimizer）
优化器是MySQL用来对输人语句在执行之前所做的最后一步优化。优化内容包括：是否选择索引、选择哪个索引、多表查询的联合顺序等。每一种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一种方案。
7）查询缓存组件（Query Caches &amp; Buffers）
这个查询缓存是比较容易理解的。在每一次查询时，MySQL 都先去看看是否命中缓存，命中则直接返回，提高了系统的响应速度。但是这个功能有一个相当大的弊病，那就是一旦这个表中数据发生更改，那么这张表对应的所有缓存都会失效。
对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非业务系统就只有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。所以在生产系统中，建议关闭该功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3232bd927d991e6a55ca09e70ec8b98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a8b9aeb496ca37e12f0b7e4070dde4/" rel="bookmark">
			解决mysql主从不同步问题思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天从库查询发现和主库数据不一致，还能因为啥，停止同步了呗。
1、首先查看从库的同步状态
SHOW SLAVE STATUS；
主要看Slave_IO_Running和Slave_SQL_Running，发现Slave_SQL_Running是NO，也就是由于某些原因导致SQL同步线程停止了。
2、查看mysql错误日志找原因
进入mysql配置文件默认/etc/my.cnf，
找到错误日志存放位置,我的是/var/log/mysqld.log
进去一看发现
[ERROR] Slave SQL for channel '': Error 'Can't create database 'test'; database exists' on query. Default database: 'test'. Query: 'CREATE DATABASE `test`', Error_code: 1007
[Warning] Slave: Can't create database 'test'; database exists Error_code: 1007
[ERROR] Error running query, slave SQL thread aborted. Fix the problem, and restart the slave SQL thread with "SLAVE START". We stopped at log 'mysql-bin.000001' position 5793227.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a8b9aeb496ca37e12f0b7e4070dde4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4241045bf9a6d3905da11a5d0b8ec24c/" rel="bookmark">
			基于Vue.js和Node.js实现网页微信登录功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在现代Web应用程序中，社交登录已成为一个常见的功能需求。微信作为全球最大的社交媒体平台之一，它的登录功能也备受关注。本文将介绍如何使用Vue.js和Node.js来实现网页微信登录功能。
1、技术栈选择 我们选择使用Vue.js作为前端框架，它提供了响应式的数据绑定和组件化开发的能力。而Node.js则是我们的后端框架选择，它具有高性能和非阻塞I/O的特点，非常适合处理实时应用程序。
2、前端实现 首先，我们使用Vue CLI创建一个新的Vue项目，并安装必要的依赖：
# 创建项目 vue create wechat-login # 进入项目根目录 cd wechat-login # 安装依赖 npm install axios vue-router 接下来，我们创建一个名为 ​Login.vue​的组件，在该组件中实现微信登录的逻辑。以下是一个简单的示例代码：
&lt;template&gt; &lt;div&gt; &lt;h1&gt;微信登录&lt;/h1&gt; &lt;button @click="login"&gt;点击登录&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import axios from 'axios'; export default { methods: { async login() { try { const response = await axios.get('/api/wechat/login'); // 处理登录成功后的逻辑 console.log(response.data); } catch (error) { // 处理登录失败的逻辑 console.error(error); } }, }, }; &lt;/script&gt; 在上述代码中，我们使用了Axios库来发送HTTP请求，并通过 ​/api/wechat/login ​来模拟微信登录的接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4241045bf9a6d3905da11a5d0b8ec24c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76db9ae9804ebdcc95e5de9b9a980567/" rel="bookmark">
			GeoJSON几何对象示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GeoJSON几何对象示例 GeoJSON 是一种开放的标准，用于描述地理信息对象的 JSON（JavaScript Object Notation）格式。它以文本方式存储地理空间数据，并包含了对象的地理位置信息和其他属性信息。GeoJSON 对象可用于 GIS 应用程序的分析和显示。
GeoJSON 官方规范定义了以下几种对象类型：
Point（点） – 表示一个具有一组地理坐标的点LineString（线） – 表示一个由线段组成的路径Polygon（面）-- 包括由线形环组成的封闭面MultiPoint（多个点） – 包含多个点的集合MultiLineString（多条线） – 包含多条线的集合MultiPolygon（多个面） – 包含多个面的集合GeometryCollection（几何图元集合） – 包含多个简单几何对象的集合Feature（要素） – 表示一个要素，包含一个几何图元和其他属性FeatureCollection（要素集） – 包含多个要素的集合 GeoJSON 格式通过简单的 JSON 对象来表示以上对象，如下是一个简单的 GeoJSON 示例：
{ "type": "Feature", "geometry": { "type": "Point", "coordinates": [104.0, 30.0] }, "properties": { "name": "test point" } } 在这个示例中，"type":"Feature" 表示这是一个要素对象。"geometry" 包含着要素对象的几何信息，"properties" 包含着要素对象的其他属性。 "geometry" 对象中的 "type":"Point" 表示这是一个点对象，而 "coordinates" 数组则包含着该点的经纬度坐标。
使用 GeoJSON 可以方便地存储和传输地图和空间数据，并且易于处理。GeoJSON 格式已被广泛应用于 Web 地图应用程序、GPS 设备、地图编辑器和空间数据分析工具等领域。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76db9ae9804ebdcc95e5de9b9a980567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc41c6b549c733d457e6d914049cd0e/" rel="bookmark">
			PgSql - PostGIS 在 PostgreSQL 中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 首先来介绍一下 PostGIS 是什么？
PostGIS 是 PostgreSQL 对象关系数据库的一个空间数据库扩展。它增加了对地理对象的支持，允许在SQL中运行位置查询。
官方介绍：
PostGIS：Spatial and Geographic objects for PostgreSQL
PostGIS is a spatial database extender for PostgreSQL object-relational database. It adds support for geographic objects allowing location queries to be run in SQL.
SELECT superhero.name FROM city, superhero WHERE ST_Contains(city.geom, superhero.geom) AND city.name = 'Gotham'; In addition to basic location awareness, PostGIS offers many features rarely found in other competing spatial databases such as Oracle Locator/Spatial and SQL Server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc41c6b549c733d457e6d914049cd0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3beb5569631afd2f2d45a4b44588e4b6/" rel="bookmark">
			WINDBG 查崩溃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：windbg大家都很熟悉，它是做windows系统客户端测试的QA人员很应该掌握的定位程序崩溃原因的工具，
网上也有很多资料，但是真正适合QA阅读和实用的资料不多，我把我认为最重要最应该掌握的结合以前的使用经验分享一下：
基础篇
1、 打开windbg，打开dmp文件，File——〉open crash dump（其实有更方便的方法，后面会说）
2、 设置符号下载路径和加载路径，File——〉symbol file path，输入srv*d:\symbolslocal*http://msdl.microsoft.com/download/symbols，中间这个路径可以随意设置，如果有其他符号路径，比如产品的模块PDB，加分号分隔即可。
符号是可以定位到具体函数，甚至具体错在哪一行代码的。在分析过程中只要dmp中牵涉到相关的微软模块的pdb都会被下载和加载。网上也有“集合版”的pdb，可以自行搜索，但是符号对应模块的版本不一定适合。
3、 弹出一个workspace的对话框，选什么都无所谓，yes、no都一样，不需要关注
4、 打开dump以后可以看到命令行窗口，如下图打开一个IE的dump文件:
5、 上图最下方的输入窗口就是用来输入调试命令的
6、 第一条命令: !analyze –v，回车，这条命令是万金油，可以自动分析大概是谁导致的崩溃，那么它执行后要关注什么内容？看下图
7、 上图应该怎么看？从下往上看！这里面就是崩溃时内存里面的模块的执行过程。注意看“Following XXX”，字面意思是接下来的段可以错了，程序在这里崩溃了的意思，因为是从下往上走的，所以“Following XXX”上方的内容就是崩溃后的东西，而“Following XXX”下方的内容就是导致崩溃的“原因”，越接近“Following XXX”的越代表有可能是导致崩溃的直接模块，但是这不一定。如果抓到的dmp时机太迟，会出现堆栈破坏的情景，那么“Following XXX”得到的内容可能就是错误的了，那么这个dmp意义就不大，当然QA可以不关注这个，要关注的是如何让自己抓dmp的时机更及时。
8、 第二条命令：kb，回车，这条命令是上面的补充，用来显示当前线程call stack（调用栈）的内容，它可以查看更详细的内存信息，更好的定位崩溃原因，比如上图内容看不到360相关的东西，是不是说这个崩溃和360没关系呢？不一定！看kb的内容
9、 记住从下往上看！上图可以看到是IE调用了safemon.dll的函数后才开始创建dmp的，是不是有理由怀疑这个崩溃和网盾有关了？提BUG吧！
10、 可惜我们只看到和网盾有关，但是具体是网盾什么函数、什么参数导致的都看不到，如何看？这时就看出符号文件的重要性了！
Ps：还有一个命令是~*kb ，它用来显示dump中所有线程的call stack， 一般用到它说明这个dump已经比较难看了，可以从命令结果中搜索KiUserExceptionDispatcher等关键字，一般可以认为存在KiUserExceptionDispatcher的线程就是导致崩溃的线程。
高级篇 1、 设置DMP类型文件关联用windbg打开
a) cmd到windbg目录运行windbg –IA 2、 手动抓DMP的方法：
a) 如果程序崩溃后没有DMP文件生成可采取下面方法转存DUM。
b) 当程序崩溃还没有退出的时候，开启WINDEBUGGER程序，在FILE——执行attach to a process——选择崩溃的进程。
c) 再执行.dump /ma C:\testdump.dmp（如果没有/ma，dump大小比较小） 3、自动抓DMP的方法：
a) cmd到windbg目录运行 windbg -IS
b) 进行导致崩溃的操作
c) 即可抓到dmp，执行.dump /ma C:\testdump.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3beb5569631afd2f2d45a4b44588e4b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7cd33cccd1431f091ae2ddacb7ee6d/" rel="bookmark">
			Process Explorer高级使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 工具描述
Process Explorer使用个轻量级的进程管理器，是由Sysinternals出品的免费工具，请猛击这里下载最新版本使用。
以下是官方介绍的翻译： “想知道是那个程序打开了某个文件或者目录么？现在可以找出它了。PorcessExplorer将会显示出进程打开或者加载了哪些的句柄（handles）或者动态链接库（Dlls）。 ProcessExplorer的显示区包含由两个子窗口组成。上部的窗口显示了当前系统的活动进程、以及这些进程的是属于哪个用户的。同时，上部的窗口依据ProcessExplorer的显示“模式”决定着底部窗口显示的内容：如果选择的是句柄模式，那么你将会在底部的窗口中显示的是上部窗口中选中进程所打开的句柄；如果选择的是Dll模式，那么你将看到进程所加载的动态链接库文件dlls以及内存映射文件。ProcessExplorer还具有强大是搜索功能，帮助你找出特定的某个句柄或者dll正在被哪个进程所加载。 ProcessExplorer的功能使得它在跟踪Dll版本问题或者句柄泄露方面起到很好的作用，并且向用户展示了Windows系统以及应用程序内部是如何工作的”。
典型应用场景
使用PE查看文件句柄和Dll加载情况
PE中可以在下方窗口显示指定进程的打开的句柄加载的DLL等，方法：View--&gt;Lower Pane View--&gt;DLls/Handls，也可以使用查找的方式来定位（Ctrl+F）
场景：删除USB设备的时候提示“无法停止”，如同： 可能的原因：USB磁盘中的文件句柄被某个进程占用时，有可能会导致这个问题 1 解决方法：启动PE，按住Ctrl+F打开查找dll(handle)的对话框，输入USB设备的分区名称比如L:\，然后点查找
1 这个时候会显示出L:\分区上被打开的句柄，这个时候点击某个句柄，PE会打开上下窗口，并且指出是哪个进程占用了哪个句柄。
1 右键点击下方handle视图中的这个句柄，选择Close Handle
1 再次尝试停止USB设备，应该就ok了
检查进程和线程(堆栈)的详细信息
场景：有段时间发现MSN在登录后CPU长时间占用达到50%以上 1 问题定位：打开PE双击MSN的进程打开对话框显示进程详细信息，找到Thread线程tab页，发现一个线程占用了大量CPU，且线程切换次数最高。如下面左图：
1 点击Stack，看看这个线程在做什么，如右图：
2 发现Flash.OCX模块在工作最为可疑。所以怀疑系统的flash控件有问题，推断原因。MSN主程序下方的Flash显示有可能造成了这个问题。后来用Shell禁用Flash广告后没有再出现CPU占用过高的情况。
上述右图中如果需要通过配置Symbols来显示系统模块使用的函数名称，而Flash属于第三方模块所以显示不到函数。配置方法如下：在Options菜单选择Configure Symbols。对话框中第一个选择windbg安装目录下的dbghelp.dll,第二个选择本地的symbols符号路径，这里我选择从微软的公共符号服务器下载符号到本地的固定文件夹
观察进程细节的Tips
进程可以显示成为树状结构，可以清晰的看到哪个进程的父进程是谁，子进程是谁； 可以显示进程更为详细的信息，比如vista下的“强制完整性级别”、是否虚拟化。虚拟内存、工作集等信息。通过菜单View-&gt;Select Columns可以定制自己想要显示的关于进程相关的各种信息
有些子进程或父进程退出速度很快，无法查看关系,可以设置Difference Highlight Duration的时间为最长的9秒，这样进程退出后也还会继续显示9秒的； 进程的颜色代表了不同的含义：如图 Own Process用淡紫色表示，代表和以当前登录用户身份启动的进程Services用粉色表示，代表系统服务类的进程.Net的进程用黄色表示，比如我的移动飞信的进程是.net进程Packed Images指的是捆绑的进程，很多病毒流氓软件为了避便被杀毒软件进行特征检查对自己的进程文件进行Pack.当然，也有很多正常的进行也是Packed类型的，比如我的TC和Foxmail。 红色、绿色分别表示新创建的和销毁的对象(注意：对象可以是加载的dll打开的句柄也可以是进程对象 本身)当观察进程启动的顺序或者加载模块的先后讯息等细节的时候注意观察红色和绿色一个进程一闪而过的创建起来，我还没有来得及看。怎么办？可以配置上述高亮颜色的“滞留时间”：使用Options--Different Highlight Duration 将这个时长设置为更长的时间就可以了。最后要说的是Jobs作业对象用咖啡色表示，举例说明，如Google浏览器,下面具体分析一下其中部分的安全特性： 场景1：Google浏览器安全特性分析
2 步骤使用PE查看进程特性在vista下tab的进程运行在低MIC级别，见Integrity列为Low：这类似于在vista系统下IE7的“IE保护模式”，因为默认情况下高MIC级别的进程不响应低MIC级别进程的窗口消息，从而避免一些核心进程在浏览器遭到劫持后，被攻击，如窗口粉碎工具。同时低MIC级别的进程在vista下不能修改一些vista系统关键对象，如敏感注册表和文件位置。chrome充分利用vista系统的安全性。
3 不过chrome的主进程和插件进程是运行在Medium级别的，chrome将插件做为独立的进程来维持，有助于提高浏览器稳定性，插件或者tab挂掉不会导致整个浏览器崩溃。(这是题外话，下面是Chrome自己的进程管理器显示的信息)
4 打开进程管理器你会发现，chrome的每个tab进程实际上是个作业job（简单来讲就是一个可以容纳多个进程的容器），从开发角度来说，对于job可以进行一个更有效的权限限制程序“边界”的限定。每个tab的作业只容纳了一个进程。用PE打开该job查看详细信息。我们打开一个tab进程，查看权限标签页：发现进程没有特权，而权限列表中很多被设置为Deny。这说明当被访问资源（注册表，文件）的ACL中如果明确要求具有管理员或者高权限才可以操作的情况下，tab进程是不能修改这些资源的。
如何做到的呢？我们前面说了，这是通过作业来实现的，windowsAPI在创建作业进程的时候可以使用参数将job这个单位的一些特定权限进行限制(可配置的)，同样，我们打开一个tab进程，切换到job标签页（普通进程是没有的），查看下面limited的列表，发现该job的很多行为被限制了，包括：仅运行一个活跃进程工作；不允许进程创建Desktop对象；不允许修改显示设置;不允许进程使得windows退出、关机等；用户对象读取限制；对于剪贴板的读写操作的限制，管理员权限操作限制等，从而实现这个“沙盒”。
场景2：恶意软件侦查和逆向工程
使用进程属性中是String标签页信息：
进程属性的String标签也通常能够显示这个进程在运行的时候可能会使用到的一些字符串，比如网址、路径名、注册表信息等等蛛丝马迹。如果是病毒或者恶意软件通过包含着一个远程的地址用来下载病毒或者将窃取的信息上传。这里通常还会包含其他信息，对于不同的场合来说，总有一些是有用的。通常有些杀毒软件也会从这里提取病毒特征码的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d2ee11421b642ee28ede69e0d012dd/" rel="bookmark">
			macOS/iOS WKWebview 下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WKWebview 下载文件需要通过JS注入的方式来下载。js下载的数据是base64编码的，回调给原生后，原生需要反编码后才是原始文件的数据。
具体步骤：
配置WKWebview的js回调句柄（标识）创建WKWebview并添加到视图上实现WKScriptMessageHandler的(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message，处理下载的数据实现WKNavigationDelegate的 (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler，注入js下载代码 配置WKWebview的js回调句柄（标识）并创建 WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init]; WKPreferences *preference = config.preferences; preference.javaScriptEnabled = YES; WKUserContentController * wkUController = [[WKUserContentController alloc] init]; [wkUController addScriptMessageHandler:self name:@"onBlobData"]; config.userContentController = wkUController; self.webView = [[WKWebview alloc] initWithFrame:self.bounds configuration:config]; 关键代码 [wkUController addScriptMessageHandler:self name:@“onBlobData”]; onBlobData 就是我们定义给js调回来的接口或标识
#实现WKScriptMessageHandler 代理
重点实现函数didReceiveScriptMessage，这里需要捕获我们上一步定义的标识事件“onBlobData”，并处理对应的数据
-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{ if ([message.name isEqualToString:@"onBlobData"]) { NSString * content = message.body; content = [content stringByReplacingOccurrencesOfString:@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d2ee11421b642ee28ede69e0d012dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a33676e694cd59ddb31ded078ef2614/" rel="bookmark">
			解决vue中报错 “TypeError: Cannot read properties of null (reading ‘forEach‘)“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错截图： 报错原因： 上图的报错翻译过来其实就是无法读取 null 的属性。简单来说就是循环遍历的数组是 null 值，而一旦循环遍历的数组为 null 值的同时再使用 forEach 方法遍历数组就会出现此报错。
例如：在 vue 模板中使用未定义或空值的变量
&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for="item in items"&gt;{{ item }}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { items: null, // 或者未定义的变量 }; }, }; &lt;/script&gt; 解决方案： 知道报错的原因，那么问题也就能迎刃而解了，由于之前是因为 null 值的问题才导致循环遍历报错，那么我们完全可以在进入循环遍历之前将要循环遍历的数组做一个非空判断，如下代码：
未修改代码：
res.data.forEach((item) =&gt; { // 执行操作 }); 加上非空判断后：
// 循环遍历之前加上非空判断 if (res.data) { res.data.forEach((item) =&gt; { // 执行操作 }); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d773744575a58920813d3adc15c4329/" rel="bookmark">
			灵魂一问：一个Java文件的执行全部过程你确定都清楚吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时我们都使用 idea、eclipse 等软件来编写代码，在编写完之后直接点击运行就可以启动程序了，那么这个过程是怎么样的？
总体过程
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
我们编写的 java 文件在由编译器编译后会生成对应的 class 字节码文件， 然后再将 class 字节码文件转给 JVM 。 JVM 会处理解析 class 文件，将其内部设置的类、方法、常量等信息全部提取出来，然后找到 main 方法开始一步一步编译成机器码并执行，中间会根据需要调用前面提取的数据。
那为什么不让 JVM 直接编译 java 文件呢？这样效率不是更高么？
首先要知道 java 之所以强大，原因之一就是 JVM 的强大。
强大之一是 JVM 是 " 跨平台 " 的。无论在哪种操作系统上执行，都可以转成对应的机器语言，不需要担心适配问题。
第二点就是 JVM 是 " 跨语言 " 的，因为 JVM 只认 class 文件，所以其他语言只需要一个编译器编译成 class 文件就可以使用 JVM 来编译执行了。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
组件分析
根据上面的说明可以知道 java 程序执行的核心是通过 JVM 来实现的，那么就需要知道 JVM 内部是如何执行的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d773744575a58920813d3adc15c4329/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37000b4a9220c04c110b378c2478066/" rel="bookmark">
			Ai 制作简单的iconfont字体图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开网址https://www.iconfont.cn/icons/upload?spm=a313x.7781069.1998910419.d059fa781
下载矢量图标设计模板,如图
打开下载的图标制作模版.ai文件
点击椭圆工具画一个大小为900*900的圆
点击文字工具，输入文字内容并调整为合适的大小，例610px
选中圆形–右键–建立复合路径
选中字体—对象—扩展
点击确定
按住shift，选中字体和图形 —剪去顶层
文件—存储为
保存类型(SVG)—确定 最终效果如图所示：
上传iconfont图标库，打开网址https://www.iconfont.cn/icons/upload?spm=a313x.7781069.1998910419.d059fa781
点击上传图标按钮
选择需要上传的图标
审核通过后，点击保留颜色并提交
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3656e36563282c7683a6d25162dd67f/" rel="bookmark">
			【MATLAB笔记】基础函数及向量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、基础函数绘制 版本：Matlab2021a
实例1：生成向量
&gt;&gt; x=0:0.1:30; &gt;&gt; y=sin(x).*cos(x); &gt;&gt; plot(x,y) 实例2：创建向量
&gt;&gt; x=linspace(0,2*pi); &gt;&gt; y=sin(x) &gt;&gt; plot(x,y) 二、向量的点积 &gt;&gt; a=[2 4 5 3] a = 2 4 5 3 &gt;&gt; b=[3 2 3 2] b = 3 2 3 2 &gt;&gt; c=dot(a,b) c = 35 &gt;&gt; c=a.*b c = 6 8 15 6 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac414910908df787eb9c9a6705b188c4/" rel="bookmark">
			vue-i18n 实现国际化，支持切换不同语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：后台管理系统，可以实现语言切换
实现过程：用的i18n来实现的语言切换，网上能看到好多模板，根据自己的需求，修改一下即可使用，大概都是差不多的，因为涉及到后端，所以要跟后端协商一致决定去写，我的设计思路是跟着后端设计更改的，如下:
1.语言是后端接口返回的，不是前端写死的（eg：中文、English）,由于我的切换语言，设计到了两个地方，一个是登录页面，一个是登录之后的页面，后端不能给一个接口，要区分两个接口给前端，所以关于这个需求，前端自己加了判断（如果你们后端给一个接口，则可忽略我写的判断）
2.根据自己选择的哪一种语言，需要通过接口传给后端，后端会将其存到某个用户表里，这个接口也是两个，也需写判断
3.如果用户是从来没有选择过语言的用户，则前端需要规定默认语言，且要与后端的默认语言保持一致，于是和后端协商一致决定，其默认语言是后端返回的语言的第一个
4.如果后端有选择是哪个语言，我们将其传给了后端，后端讲其存入了用户表，用户登录之后，会在用户接口里，返回给我们，我们将其存 localStorage,这时候，就算用户再次退出到登录页面，我们就可以将用户默认语言做一个判断，判断存入localStorage的language是否有值，如果有值，则登录页面的语言取localStorage的language，如果没有，则还是取后端语言接口返回的第一个值,这样，就可以把用户已经选择过的语言，在登录页面也能进行判断用户习惯
文档: vue-i18n
一.安装vue-i18n npm install vue-i18n 二.在mian.js引入
//i18n import i18n from "@/lang"; Vue.use(Element,{ size:Cookies.get('size') || 'small', i18n:(key,value)=&gt;i18n.t(key,value) }) new Vue({ el: '#app', router, store, i18n, render: h =&gt; h(App) }) 三.在src下创建一个lang文件夹，其中包括en.js、zh.js、index.js文件
1.src/lang/en.js
export default { login: { username:'username',//用户名 password:'password',//密码 code:'code',//验证码 login:'login',//登录 logging: 'logging...',//登录... storage:'remember the password',//记住密码 }, home:{ welcome:'Welcome to use',//欢迎使用 }, route:{ homepage:'Home page',//首页 profile:'Profile',//个人中心 系统管理:"system manage",//系统管理 系统监控:'system monitor', 系统工具:"system tools", 创建运单:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac414910908df787eb9c9a6705b188c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9db1715c0c9bcd363cd6e508206c7b/" rel="bookmark">
			Qt/C&#43;&#43;编写控件属性设计器1-加载插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 加载插件是整个属性设计器的第一步要打通的功能，插件中的控件都加载不了，后面就别搞别玩下去了没法玩的，要从一个动态库中加载出来控件，肯定需要用到反射机制，以前做.NET开发的时候就觉得反射这个东西相当强大，居然可以读取DLL加载出来控件，现在用Qt，发现Qt也有反射机制，也许这东东可能各大开发语言平台都具备吧，Qt反射对应的类叫QMetaObject，着实强大，其实整个Qt开发框架也是超级强大的，本人自从转为Qt开发为主后，就深深的爱上了她，在其他跨平台的GUI开发框架平台面前，都会被Qt秒成渣，Qt的跨平台性是毋庸置疑的，几十兆的内存存储空间即可运行，尤其是嵌入式linux这种资源相当紧张的情况下，Qt的性能发挥到极致。
体验地址：https://gitee.com/feiyangqingyun/QUCSDK
https://github.com/feiyangqingyun/qucsdk
二、功能特点 自动加载插件文件中的所有控件生成列表，默认自带的控件超过120个。拖曳到画布自动生成对应的控件，所见即所得。右侧中文属性栏，改变对应的属性立即应用到对应选中控件，直观简洁，非常适合小白使用。独创属性栏文字翻译映射机制，效率极高，可以非常方便拓展其他语言的属性栏。所有控件的属性自动提取并显示在右侧属性栏，包括枚举值下拉框等。支持手动选择插件文件，外部导入插件文件。可以将当前画布的所有控件配置信息导出到xml文件。可以手动选择xml文件打开控件布局，自动根据xml文件加载控件。可拉动滑动条、勾选模拟数据复选框、文本框输入，三种方式来生成数据应用所有控件。控件支持八个方位拉动调整大小，自适应任意分辨率，可键盘上下左右微调位置。打通了串口采集、网络采集、数据库采集三种方式设置数据。代码极其精简，注释非常详细，可以作为组态的雏形，自行拓展更多的功能。纯Qt编写，支持任意Qt版本+任意编译器+任意系统。 三、效果图 四、核心代码 void frmMain::initPlugin() { //载入默认的插件 #if defined(Q_OS_WIN) QString pluginName = QString("%1/quc.dll").arg(qApp-&gt;applicationDirPath()); #elif defined(Q_OS_UNIX) QString pluginName = QString("%1/libquc.so").arg(qApp-&gt;applicationDirPath()); #elif defined(Q_OS_MAC) QString pluginName = QString("%1/libquc.dylib").arg(qApp-&gt;applicationDirPath()); #endif loadPlugin(pluginName); //载入默认的控件xml数据 openFile(qApp-&gt;applicationDirPath() + "/quc.xml"); qApp-&gt;processEvents(); ui-&gt;listWidget-&gt;verticalScrollBar()-&gt;setValue(0); } void frmMain::loadPlugin(const QString &amp;fileName) { openPlugin(fileName); this-&gt;setWindowTitle(QString("自定义控件属性设计器(共 %1 个控件)(QQ:517216493)").arg(ui-&gt;listWidget-&gt;count())); } void frmMain::openPlugin(const QString &amp;fileName) { qDeleteAll(listWidgets); listWidgets.clear(); listNames.clear(); ui-&gt;listWidget-&gt;clear(); //加载自定义控件插件集合信息,包括获得类名+图标 QPluginLoader loader(fileName); if (loader.load()) { QObject *plugin = loader.instance(); //获取插件容器,然后逐个遍历容器找出单个插件 QDesignerCustomWidgetCollectionInterface *interfaces = qobject_cast&lt;QDesignerCustomWidgetCollectionInterface *&gt;(plugin); if (interfaces) { listWidgets = interfaces-&gt;customWidgets(); int count = listWidgets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9db1715c0c9bcd363cd6e508206c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03531201bf23d1a35527c117e8be689b/" rel="bookmark">
			python使用selenium获取京东商品详情--存入mysql和excel中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import time import pymysql import requests import selenium.common.exceptions from selenium import webdriver from lxml import etree import pandas as pd jd_browser = webdriver.Chrome('chromedriver.exe') with open('stealth.min.js', 'r', encoding='utf-8')as f: js_code = f.read() jd_browser.get('https://www.jd.com/') input_jd = jd_browser.find_element_by_id('key') input_jd.send_keys('创维电视') cick_job = jd_browser.find_element_by_css_selector('button') cick_job.click() jd_browser.implicitly_wait(20) # 实现滑块滚动，获取动态数据 def drop_down(): for i in range(50): time.sleep(0.3) jd_browser.execute_script('window.scrollBy(0,300)', '') drop_down() lis = jd_browser.find_elements_by_css_selector('.goods-list-v2 .gl-item') # print(len(lis)) urls = [] # 获取商品详情页的url for i in lis: jd_browser.implicitly_wait(20) url = i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03531201bf23d1a35527c117e8be689b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc8ca732f36603406210c47c3cda7b7/" rel="bookmark">
			STM32单片机（一）STM32简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️ 专栏简介：本专栏记录了从零学习单片机的过程，其中包括51单片机和STM32单片机两部分；建议先学习51单片机，其是STM32等高级单片机的基础；这样再学习STM32时才能融会贯通。
☀️ 专栏适用人群 ：适用于想要从零基础开始学习入门单片机，且有一定C语言基础的的童鞋。
🌙专栏目标：实现从零基础入门51单片机和STM32单片机，力求在玩好单片机的同时，能够了解一些计算机的基本概念，了解电路及其元器件的基本理论等。
⭐️ 专栏主要内容： 主要学习STM32单片机的功能、各个模块、单片机的外设、驱动等，最终玩好单片机和单片机的外设，全程手敲代码，实现我们所要实现的功能。
🌴 专栏说明 ：如果文章知识点有错误的地方，欢迎大家随时在文章下面评论，我会第一时间改正。让我们一起学习，一起进步。
💑专栏主页：http://t.csdn.cn/HCD8v
本学习过程参考：https://space.bilibili.com/383400717
STM3单片机安装软件、各种资料以及源码的路径：
链接：https://pan.baidu.com/s/1snD0uuTfMhchFqOMWvAiHA?pwd=asdf#list/path=%2F 提取码：asdf
链接里压缩包的解压密码：32
本节是STM32单片机部分的第一节，主要对STM32部分课程进行简单介绍，以及对STM32单片机进行简单介绍；其中包括STM32介绍、ARM介绍、片上资源/外设、命名规则、系统结构、引脚定义、启动配置、最小系统电路等。
文章目录 一、STM32课程简介二、STM32简介2.1 STM32介绍2.2 ARM介绍2.3 片上资源/外设2.4 命名规则2.5 系统结构2.6 引脚定义2.7 启动配置2.8 最小系统电路 一、STM32课程简介 在STM32的学习过程中，将使用stm32最小系统板+面包板硬件平台进行学习和练习，硬件平台如上图所示，将STM32最小系统板（上图蓝色板子）插在面包板上，作为基本的硬件单元，下面插上一块0.96寸的OLED（右下角黑色板子）作为调试和显示的屏幕，在调试程序时，可以把程序中的变量显示在这个屏幕上，这样调试起来就会比较方便；右边的STLINK（紫色部分）插在电脑上用于下载程序和供电；最上面的是蜂鸣器模块；
使用面包板可以完成任意电路的连接，接线和修改都是非常方便的；相比较成品的开发板方式，使用面包板更有利于我们对硬件电路的学习，而且也可以避免开发板的一些问题，比如引脚冲突、引脚无法更改等；
当然使用面包板也会带来一些问题，比如如果程序现场跑不出来，不仅有可能是程序的问题，也有可能是接线的问题等；这就需要我们在连线的时候要更加细心；关注软件程序的同时，也要关注硬件电路；
硬件设备：
软件设备：
这次学习STM32使用的是Keil5 MDK这个软件，Keil5 SDK是用来给ARM系列的单片机编程的。
套件介绍
中间白色部分是面包板，左边这一盒是面包板专用的跳线，这种跳线比较短，可以贴在面包板上插线，比较适合长时间插线的情况；上面那一扎是面包板的飞线，这种线比较长，也方便挪动，比较适合经常挪动的接线情况；飞线下面两排是杜邦线，分别是公对母和母对母的，可以用于插接一些电路模块；
蓝色部分是STM32最小系统板，该板上中间的黑色小模块就是STM32芯片，我们就是主要学习这个小芯片；STM32最小系统板的右边是0.96寸的OLED显示屏模块，用于显示参数和变量，这个显示屏是一个4引脚版本的，现在网上卖的由4引脚和7引脚的，主要不要弄错了；
图中右上角的是电位器，主要用来进行AD转换试验的；电位器下面是按键，两引脚的小按键，它可以正好跨接在面包板的引脚插孔和电源插孔之间，插接非常方便整洁，如下图所示：
五颜六色的是LED灯；左边紫色部分的是STLINK，用来下载程序和供电的；STLINK下面是USB转串口模块，使用这个模块就可以使STM32和电脑进行串口通信了；
有源蜂鸣器模块，内置震荡源，接上电就可以响；相比较无源蜂鸣器模块需要不断反转IO口的操作方式，有源蜂鸣器模块就方便多了，基本和点灯一样简单；
右边四个是传感器模块，第一个是光敏电阻模块，下面的四个引脚有两个是用来供电的，还有两个是光敏电阻信号的模拟输出和数字输出，可以用来进行IO口读取实验或者AD试验；第二个是热敏电阻模块，也是有模拟输出和数字输出的；第三个是对射式红外模块，这个模块配合遮光片可以用来计次，或者配合编码盘用来测速；第四个是反射式红外模块，它可以向地面发射红外光，然后再用红外接收管接收地面反射的红外光，通过判断接收光的强度，就可以大体地识别出地面的颜色变化了；
W25Q64 Flash存储模块，它可以存储数据，并且是用SPI总线进行通信的，我们主要用它来学习SPI通信；
MPU6050陀螺仪和加速度计，它可以测量芯片自身的姿态，像四轴飞行器上，一般都会配有陀螺仪和加速度计，他是用I2C总线通信的，我们主要用它来学习I2C通信；
旋转编码器，它可以输出两路正交的方波信号，用于指示旋转的方向和速度，STM32里有专用的编码器电路，可以很方便的识别这种信号，这个模块可以当做一个快读的按键来使用，当然本节主要还是用它来模拟编码器的测速，现在的编码电机一般配备活儿传感器或光电传感器，这些传感器的输出和这种旋转编码器是一样的，所以学习一下旋转编码器就可以了；而且这种旋转编码器还比较方便插在面包板上，而且比较便宜；
直流电机和TB6612电机驱动模块，可以用来进行直流电机的PWM调速实验；
SG90舵机，也是用PWM来控制的，它的输出端可以像船舵一样，根据我们给定的PWM信号的占空比固定在某一个角度上，可以用来做一些机器人或者机械臂的关节；
二、STM32简介 2.1 STM32介绍 ST的意思是ST公司，M是微控制器Microcontroller的首字母；微控制器就是MCU，就是我们常说的单片机，所以STM32也是一款单片机；32的意思是这是一款32位的单片机，相比较8位的51单片机，STM32的性能还是非常强的，当然ST也推出过8位的单片机，名字叫STM8，这个了解一下就行；
这个ARM Cortex-M内核就是STM32内部的核心部分；这个内核是ARM公司设计的，它在STM32中占据极为重要的地位；比如我们程序指令的执行，加减乘除的运算，都是在内核中完成的；它相当于整个芯片的CPU；
如图中所示，目前STM32主要有四个系列，分别是高性能系列（High Performance）、主流系列（Mainstream）、超低功耗系列（Ultra-low-power系列）和无线系列（Wireless）；每个系列对应着不同的产品；
例如：
高性能系列就有STM32F2、F4、F7、H7这些；图中有具体型号芯片的详细性能介绍；比如F2系列就是398 CoreMark和120MHz主频的Cortex-M3内核；这个CoreMark就是一个内核跑分，跑分越高性能越好；Cortex-M3内核就是ARM的其中一个内核芯片；可以看到，STM32H7是目前最强的STM32芯片，拥有3224的内核跑分，550MHz的cortex-M7和240MHz的cortex-M4的内核，是一个双核微控制器；主流系列包含了F0、F1、F3这些型号；我们本次教程使用的就是STM32F1的这个系列，由177的内核跑分和72MHz的cortex-M3内核；超低功耗系列包含L0、L1、L4、L5等型号；无线系列的STM32，包括STM32Wl和STM32WB，可以了解一下； 以上这些就是目前STM家族中的所有系列了；可以看出来这个系列还是比较全的；我们学习的事主流系列；当然如果觉得性能不够也可以继续进阶学习高性能的系列；如果对功耗比较敏感，也可以学习一下低功耗系列；如果想做无线通信的产品，可以了解一下无线的系列；因为他们都是一个家族的，所以换一个系列再学习的话也会比换别的芯片轻松很多；
2.2 ARM介绍 在本学习过程中我们使用的STM32的型号是STM32F103C8T6，如上图中右侧的图片所示；根据他的型号再对应前面的介绍，我们就已经知道了它是主流系列的STM32F1，他的内核是ARM Cortex-M3，主频是72MHz，它的RAM大小是20K，ROM大小是64K，这里的RAM就是运行内存，实际的存储介质是SRAM；这里的ROM就是程序存储器，实际的存储介质是Flash闪存；它的供电电压是2.0~3.6V，标准是3.3V供电；这里需要注意下，我们以前学的51单片机使用的是5V供电，还有USB输出的电压也是5V，5V不在STM32的供电范围内，因此不能直接给STM32供电；如果是5V电压给STM32供电，需要在中间加一个稳压芯片，把电压降到3.3V，再给STM32供电；它的封装是L QFP48，也就是上图这种比较小的封装，总共有48个引脚。
2.3 片上资源/外设 下面看一下这款芯片上的片上资源，片上资源又叫外设，英文是Peripheral；上图的表里列出了STM32F1系列的外设资源；我们主要学习的就是STM32的外设；通过程序配置外设，来实现我们想要的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dc8ca732f36603406210c47c3cda7b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69dd13a2971499c94530ca72de4b815b/" rel="bookmark">
			基于SpringBoot的校园请假管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✌全网粉丝20W+,csdn特邀作者、博客专家、CSDN新星计划导师、java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
🍅文末获取项目下载方式🍅
一、项目背景介绍： 校园请假信息管理系统是一种针对学生请假事宜的管理工具，旨在简化请假流程、提高管理效率、降低出勤管理成本。该系统的背景分析可以从以下几个方面进行：
学校请假管理繁琐：在传统的请假流程中，学生需要填写请假单、班主任审批、学生处审核、辅导员签字等一系列手续，流程繁琐、时间成本高、管理效率低下。
信息化建设迫在眉睫：随着信息化时代的到来，各行各业都在积极推进信息化建设。学校作为重要的社会教育机构，也应该积极借助信息化手段提升管理效率。
学生出勤管理面临挑战：学生出勤管理一直是学校工作的重要内容，而传统的管理方式已经无法满足管理需要。在学生请假方面，如何实现信息化、数字化、自动化
二、项目技术简介： JAVA：Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。SpringBoot：SpringBoot框架是一个开放源代码的J2EE应用程序框架，由Rod Johnson发起，是针对bean的生命周期进行管理的轻量级容器（lightweight container）。 Spring解决了开发者在J2EE开发中遇到的许多常见的问题，提供了功能强大IOC、AOP及Web MVC等功能。Spring可以单独应用于构筑应用程序，也可以和Struts、Webwork、Tapestry等众多Web框架组合使用，并且可以与 Swing等桌面应用程序AP组合。因此， Spring不仅仅能应用于J2EE应用程序之中，也可以应用于桌面应用程序以及小应用程序之中。Spring框架主要由七部分组成，分别是 Spring Core、 Spring AOP、 Spring ORM、 Spring DAO、Spring Context、 Spring Web和 Spring Web MVC。Mybatis：MyBatis本是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github。
iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）。Spring-Mvc：Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的Spring MVC框架或集成其他MVC开发框。Thymeleaf：thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。 Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。
6. Bootstrap：Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。Bootstrap一经推出后颇受欢迎，一直是GitHub上的热门开源项目，包括NASA的MSNBC（微软全国广播公司）的Breaking News都使用了该项目。 国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来。
7. Html：HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。
等。
超文本是一种组织信息的方式，它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，为人们查找，检索信息提供方便。
三、系统功能模块介绍： 四、数据库设计： 1：dept（dept）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69dd13a2971499c94530ca72de4b815b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/093c9bc48bff34e3f57089527334b3aa/" rel="bookmark">
			【操作系统】磁盘管理高级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 RAID磁盘阵列什么是RAID？RAID 0RAID 1RAID 5RAID 10磁盘阵列管理mdadm 工具的使用创建并管理RAID LVM 磁盘管理物理卷 - PV卷组 - VG逻辑卷 - LV命令行创建 LVM调整 LVM 的大小删除逻辑卷 RAID磁盘阵列 Redundant Array of Independent Disks - 独立冗余磁盘阵列
什么是RAID？ 把多个磁盘设备组合成一个容量更大、更安全的磁盘阵列 把数据切割成多个区段，分别存放在不同的物理硬盘设备上，然后利用 分散读写技术 来提升磁盘阵列整体的性能； 同时把多个重要数据的 副本 同步到不同的物理硬盘设备上，从而起到非常好的 数据冗余备份 效果 优点
冗余备份硬盘吞吐量提升，读写速度提升反面：成本支出提升 RAID 磁盘阵列 方案：
至少十几种，详细介绍四种
RAID 0RAID 1RAID 5RAID 10 RAID 0 数据条带化 数量：2块及以上的硬盘，性能和容量随硬盘数递增 优点：所有的RAID级别中，速度最快；（并发读取和写入）
缺点：无冗余或错误修复能力，无法容忍硬盘损坏。
RAID 1 数据镜像（一模一样的备份） 数量：2块及以上的硬盘（偶数） 优点：数据在每组磁盘中都有一份，读性能好，一组磁盘损坏，不影响数据访问；
缺点：写性能下降，因为要写双份数据；
RAID 5 奇偶校验 数量：3块及以上的硬盘 并发存放 优点：能容忍任意坏掉一块盘，奇偶校验恢复 接近 RAID-0 的数据读取速度，具有一定的容灾能力，写速度比RAID-1慢
RAID 10 奇偶校验 数量：至少4块 优点：更好的性能，更好的可靠性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/093c9bc48bff34e3f57089527334b3aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f15b4ca95ff3760786f929baf029f39/" rel="bookmark">
			Linux进程管理-实时调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux进程管理---实时调度 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a4bf12b6999158f4ceefdbe75f691f/" rel="bookmark">
			Java8中Lambda表达式和方法引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Lambda表达式 1.1 函数式编程思想 1）概念 ​ 面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要关注的是对数据进行了什么操作。
2）优点 代码简洁，开发快速接近自然语言，易于理解易于"并发编程" 1.2 Lambda表达式基础 1）概述 Lambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。
它是函数式编程思想的一个重要体现。
让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。
2）核心原则 可推导可省略。
需要是函数式接口，既只有一个方法的接口。
3）基本格式 由三部分组成： 一些参数一个箭头一段代码 格式： (参数列表)-&gt;{重写方法的代码} 解释说明格式： (): 接口中抽象方法的参数列表，没有参数就空着，有参数就写出参数，多个参数使用逗号分隔-&gt; : 就是传递的意思。即把参数传递给方法体{}{} : 重写接口的抽象方法的方法体 1.3 示例 创建并启动线程 // 在创建线程并启动时可以使用匿名内部类的写法： new Thread(new Runnable() { @Override public void run() { System.out.println("hello!"); } }).start(); // ------------------------------分隔线----------------------------- // 使用Lambda的格式对其进行修改 new Thread(()-&gt;{ System.out.println("hello!"); }).start(); 函数式接口作为参数
现有方法定义如下，其中IntBinaryOperator是一个函数式接口。
// 先使用匿名内部类的写法调用该方法 public static int calculateNum(IntBinaryOperator operator){ int a = 10; int b = 20; return operator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53a4bf12b6999158f4ceefdbe75f691f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb9cded4d8d9fdc6d4feb0ece8be5e3f/" rel="bookmark">
			pandas如何禁用科学计数法，或者如何把二十位数字无损还原？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你在使用pandas时遇到了一列数据被显示成了科学计数法，而且这些数据都是整型数字，你可以通过以下方法禁用科学计数法：
pd.options.display.float_format = '{:.0f}'.format 这个方法会将所有的浮点数都以整型的形式显示出来，不会再使用科学计数法。
如果你想将这些科学计数法的数字还原成原来的数字，你可以使用以下方法：
pd.set_option('display.float_format', lambda x: '%.0f' % x) 这个方法会将所有的浮点数都以整型的形式显示出来，不会再使用科学计数法，并且不会改变原来的数据。
如果你想将这些数字导出到Excel文件中，你可以使用以下方法：
df.to_excel('filename.xlsx', index=False, float_format='%.0f') 这个方法会将所有的浮点数都以整型的形式导出到Excel文件中，不会再使用科学计数法，并且不会改变原来的数据。
如果你的数字长度超过了17位，可以通过设置pandas显示的最大列宽来解决。以下是一个例子：
pd.options.display.max_colwidth = 100 这个方法会将pandas显示的最大列宽设置为100个字符，可以适应更长的数字。如果你想要显示更长的数字，请将100替换成你需要的列宽。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a57ab888d59e221ef52dc114e626e46/" rel="bookmark">
			进程间通信的常用方式和特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、管道
二、消息队列
三、共享内存
四、信号量
五、信号
六、socket
一、管道 特点：传输数据是单向的，生命周期伴随着进程；
分类：类似“|”叫做匿名管道，还有fifo命令管道。
mkfifo命令可以用来创建命名管道；
创建管道调用的系统调用是：
int pipe(int fd[2])
其中返回值是两个文件描述符，fd[0]是读取的,fd[1]是写入的，由于采取流传输，大小有限制，且只能单向；
原理：对于匿名管道，它的通信范围是存在父子关系的进程。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。
对于命名管道，它可以在不相关的进程间也能相互通信。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持lseek 之类的文件定位操作。
缺点：效率低，不适合进程间频繁地读取数据；
优点：简单；
二、消息队列 特点：消息队列是保存到内存中的消息链表，两个进程可以约定好放入同一个消息队列，生命周期是伴随着内核的；、
原理：类似邮件，一方寄一方收即可；
缺点：通信可能不及时，不适合传输大数据，因为消息的长度大小都是有限制的，而且存在用户态和内核态的数据拷贝开销；
三、共享内存 特点：没有内核态和用户态数据拷贝开销；
原理：每个进程都有自己的虚拟内存空间，共享内存就是给两个需要通信的进程的虚拟内存映射到同一个共享内存（物理内存），一方修改了数据，另一方可以直接看到；
缺点：多个进程不能同时修改同一个地址，因此需要与信号量一起使用；
四、信号量 特点：信号量其实是一个整型的计数器，用来实现多个进程间的同步和互斥；
原理：有两种原子操作：PV操作，P代表信号量-1，如果-1后信号量的值&lt;0，就会阻塞；V代表信号量+1，如果+1后&lt;=0，会唤醒阻塞的进程；
五、信号 特点：信号是进程间唯一的异步通信机制，任何时候有信号产生，都有三种处理方式：
1、执行默认行为，2、注册自己的处理函数用来捕捉信号，3、忽略信号。
六、socket 特点：socket除了本机进程间通信，还可以跨机和跨网络在不同的两个主机间通信。
原理：有三种通信方式，tcp、udp、本地进程间（本地文件）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dfc764c75e7e85c8644f2a3e067d02b/" rel="bookmark">
			操作系统之调度算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、进度调度算法
二、内存调度算法
一、先来先服务调度算法
二、最短寻道时间优先调度算法
三、扫描算法
四、循环扫描算法
五、LOOK和C-LOOK算法
三、内存页面置换算法
一、进度调度算法 常见的进度调度算法以及特点如下：
二、磁盘调度算法 一、先来先服务调度算法 先来的请求先服务，如果请求访问的磁道很分散的话，性能会很差；
二、最短寻道时间优先调度算法 优先选择从当前磁头位置所需寻道时间最短的请求。会造成一些请求的长时间等待，很可能磁头会在一个小区域内来回移动。
三、扫描算法 为了防止磁头在一个小区域内来回的移动，规定磁头只能在一个方向上移动，直到磁头到达该方向上的最后的磁道，再调换方向。类似于电梯。
中间部分的磁道更容易得到响应。
四、循环扫描算法 扫描算法会造成中间部分的磁道响应频率高，而循环扫描规定只能按同一个方向进行扫描，从而优化了该问题。
五、LOOK和C-LOOK算法 扫描和循环扫描算法都是磁头移动到了最末端或者最始端才开始调换方向，而LOOK和C-LOOK则表示当达到最远请求的位置后，就立即调换方向。
LOOK算法在调转方向时会响应途中的请求；
C-LOOK算法在调转方向时不会响应途中的请求。
三、内存页面置换算法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a04affdd2e1e370bb843b9d43b9c2a0/" rel="bookmark">
			浅谈JavaAgent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章首发于先知社区：浅谈JavaAgent
Java Agent Javaagent是java命令的一个参数。参数 Javaagent 可以用于指定一个 jar 包，并且对该 java 包有2个要求：
这个 jar 包的 MANIFEST.MF 文件必须指定 Premain-Class 项。Premain-Class 指定的那个类必须实现 premain() 方法。 premain 方法，从字面上理解，就是运行在 main 函数之前的的类。当Java 虚拟机启动时，在执行 main 函数之前，JVM 会先运行-javaagent所指定 jar 包内 Premain-Class 这个类的 premain 方法 。
启动时加载Agent 前边提到premain()函数，它实在main函数之前运行的，也就是启动时加载的Agent，函数声明如下，Instrumentation inst参数的方法优先级更高：
public static void agentmain(String agentArgs, Instrumentation inst) { ... } public static void agentmain(String agentArgs) { ... } String agentArgs 就是Java agent后跟的参数。
Instrumentaion inst 用于和目标JVM进行交互，从而达到修改数据的效果。
先看下premain()函数的具体使用：
PreMainDemo import java.lang.instrument.Instrumentation; public class PreMainDemo { public static void premain(String agentArgs, Instrumentation inst){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a04affdd2e1e370bb843b9d43b9c2a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10fe5df1b7624ed9e43136981719c03e/" rel="bookmark">
			第十周：机器学习周报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
Abstract
1 Slot Filling（槽位填充）
2 Recurrent Neural Network（循环神经网络）
2.1 RNN的结构
2.2 RNN的分类
2.3 RNN的原理
2.4 RNN can be deep
2.5 Bidirectional RNN（ 双向RNN）
2.6 RNN的训练
3 Long Short-term Memory(长短期记忆)
3.1 LSTM的结构
3.2 Multiple-layer LSTM
3.3 LSTM Example
3.4 GRU
4 RNN的应用
总结
摘要 在做语义辨识任务中，传统的前馈神经网络无法结合上下文分辨出同一词汇的不同语义，而循环神经网络（RNN）是一类用于处理序列数据的神经网络，它能挖掘数据中的时序信息以及语义信息，是一种有记忆力的神经元。通过手动演算RNN的运作过程，认识到网络的输入顺序将会影响输出，这是因为它与CNN等结构不同，它不仅考虑前一时刻的输入,而且赋予了网络对前面的内容的一种“记忆”功能。RNN进行训练时会存在梯度无效和梯度爆炸等问题，为了解决这些问题有一种特殊的RNN叫做Long short-term memory，相比普通的RNN，LSTM能够在更长的序列中有更好的表现，解决了RNN训练时的梯度无效问题。同时学习了LSTM三个门的原理以及LSTM的一个计算实例，还有RNN和LSTM的实际应用领域。
Abstract In the task of semantic identification, the traditional Feedforward neural network can not distinguish different semantics of the same word in combination with the context, while Recurrent neural network (RNN) is a kind of neural network used to process sequence data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10fe5df1b7624ed9e43136981719c03e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217d3a744e325c901ed7ced426102301/" rel="bookmark">
			Nuxt3入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Nuxt是什么？1.SSR概念2.Nuxt3.Hydration概念 二、Nuxt3准备1.Node版本2.nvm 三、创建一个Nuxt3应用四、应用场景1.SSR2.SSG3.CSR 总结扩展阅读 前言 上一篇文章（了解Vue3预渲染）探讨了Vue的预渲染方案，但是预渲染对于首屏有动态内容的网页还是有着较大的局限性，需要考虑使用SSR（服务端渲染），所以这篇文章来介绍一下基于Vue的SSR方案，即Nuxt框架，同时也会陆续把最近学习Nuxt3框架过程中的一些心得体会记录下来，分享给大家。那么开始吧~
一、Nuxt是什么？ 1.SSR概念 SSR全称是 Server-Side Rendering，即服务端渲染。与客户端渲染 CSR（Client-Side Rendering）不同的是，SSR输出的是一个渲染完成的HTML，整个渲染过程是在服务器端进行的。 用户访问网址后得到的是一个完全呈现的HTML 页面，其中包含网站所需的所有信息，无需等待任何 JavaScript 或 CSS 文件加载。这意味着访问网站的用户将能够比在等待JavaScript 文件加载时只是看着空白屏幕更快地看到所有内容；另外搜索引擎爬虫可以直接看到完全渲染的页面，也有利于网页搜索引擎优化，即 SEO（Search Engine Optimization）。
2.Nuxt Nuxt 是一个基于Vue.js的、可用来创建服务端渲染（SSR）应用的通用应用框架，对应 React 技术栈的叫做 Next.js 框架，两者名字长得很像，都是支持 SSR 技术的框架，由于我没使用过Next.js，所以无法对比就不介绍了Next了，只对比 Nuxt2 。
Nuxt3优势
①：全面拥抱Vue3
②：全面支持TypeScript
③：自动导入与引用（包括 Vue3 的 setup 语法）
④：支持所有渲染模式和所有环境
⑤：充分支持Vue生态系统（如：Vite、Pinia）
特点：
①：基于目录结构约定式开发
②：允许使用路由规则为每个路由使用不同的渲染模式或缓存策略
3.Hydration概念 当浏览器请求启用通用（服务器端+客户端）渲染的 URL 时，服务器会向浏览器返回完全渲染的 HTML 页面。无论页面是提前生成并缓存还是动态渲染，在某个时刻，Nuxt 都会在服务器环境中运行 JavaScript (Vue.js) 代码，生成 HTML 文档。用户立即获得我们应用程序的内容，这与客户端渲染相反。此步骤类似于PHP 或 Ruby 应用程序执行的传统服务器端渲染。
为了不失去客户端渲染方法的优点，例如动态界面和页面转换，一旦下载了 HTML 文档，客户端（浏览器）就会加载在后台服务器上运行的 JavaScript 代码。浏览器再次解释它（因此称为通用渲染），Vue.js 控制文档并启用交互性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/217d3a744e325c901ed7ced426102301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/832b9b02c3399b9295d818fb8917fe65/" rel="bookmark">
			Matlab中统计矩阵中元素个数的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、 tabulate函数 a = [1,2,1,3,1,4,1,5,2,3,1,4,2,5,4,2]; tabulate(a) 第一列代表了元素，第二类代表该元素出现的个数，第三列代表该元素的占比。
2、find函数和length函数 判断矩阵a中元素2出现的次数
a = [1,2,1,3,1,4,1,5,2,3,1,4,2,5,4,2]; length(find(a==2)) 3、sum函数 a = [1,2,1,3,1,4,1,5,2,3,1,4,2,5,4,2]; sum(a(:)==2) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e46ab138aa4ac056f816bde4c20b698/" rel="bookmark">
			深入理解Java——从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题: 深入理解Java——从入门到精通
Java是一门广泛应用于软件开发领域的高级编程语言。它的特点包括强大的跨平台性、面向对象的编程范式、丰富的类库以及良好的安全性。无论是在企业级应用开发、移动应用开发还是嵌入式系统开发中，Java都扮演着重要的角色。本文将带您深入理解Java，并逐步从入门到精通。
1. 基础知识与语法 学好任何一门编程语言，首先需掌握其基础知识和语法。Java的语法相对简洁明了，但也有一些独特的规则和特性需要注意。从数据类型、控制流、方法、类和对象等基础概念开始，逐步扩展到异常处理、多线程编程、输入输出流等高级特性。
2. 面向对象编程 Java被广泛称为一门面向对象的编程语言，因此掌握面向对象编程思想对于Java的学习是至关重要的。理解类与对象、封装、继承、多态等概念，并学会如何设计和构建可重用的、可扩展的面向对象程序。
3. Java类库 Java类库是Java开发中的重要组成部分。掌握常用类库的使用方法，例如集合框架、IO操作、网络编程、数据库连接等，将有助于提高开发效率和代码质量。同时，了解Java类库的设计原则和思想，可以帮助我们更好地使用和扩展类库。
4. 并发编程 在现代应用程序中，并发编程已成为必备技能。Java提供了丰富的并发编程工具和API，如线程、锁、条件变量、同步集合等，用于处理多线程编程中的共享资源和线程同步问题。深入学习并发编程，可以提高程序的性能和响应能力。
5. Java虚拟机（JVM） Java作为一门解释性的语言，通过Java虚拟机（JVM）来执行字节码。了解JVM的工作原理、内存模型和垃圾回收机制，可以帮助我们优化程序性能、发现和解决内存泄漏等问题。
6. Java应用开发 Java在企业级应用开发领域有着广泛的应用。掌握JavaEE（或Java Web）开发框架、服务器容器、设计模式等，可以帮助我们构建健壮、可扩展的Web应用程序。此外，掌握移动开发框架如Android开发，可以在移动应用开发中发挥Java的优势。
7. 开源社区与工具生态 与其他流行编程语言一样，Java也有庞大的开源社区和丰富的工具生态系统。了解并使用这些工具和框架，如Maven、Gradle、Spring、Hibernate等，不仅可以提高我们的开发效率，还能从开源社区中受益并贡献自己的力量。
无论是初学者还是有一定经验的开发者，掌握Java编程语言都是一项值得投入时间和精力的投资。通过不断学习和实践，不仅可以掌握Java的核心概念和技术，还能够在软件开发领域取得长足
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77fc7358425d53b668c60a1420f66ac/" rel="bookmark">
			mac 安装 Homebrew教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为 macOS 用户，如果你还没有安装 Homebrew，那真的太可惜了，因为它是一个非常强大且实用的软件包管理器。不过，安装 Homebrew 有时可能会遇到一些挑战，但别担心，下面是我个人第一次成功安装 Homebrew 的步骤，希望能对你有所帮助。
打开终端应用程序。你可以在 Launchpad 中找到它，或者使用 Spotlight 搜索 “终端”。在终端中，复制并粘贴以下命令，然后按回车键： /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 这个命令将自动下载并安装 Homebrew。
3. 安装过程可能需要一些时间，取决于你的网络速度。在安装过程中，你可能需要输入你的 macOS 用户密码，以便确认安装。
4. 安装完成后，你应该会看到安装成功的提示信息。
在安装完成后，你可以使用 Homebrew 来安装各种软件包和工具。例如，如果你想安装 Git，只需在终端中运行以下命令：
brew install git Homebrew 将自动下载并安装 Git。你可以根据需要安装其他软件包，只需运行适当的 brew install 命令即可。
另外，为了优化安装速度，你可以使用中国科学技术大学的 Homebrew 镜像。在终端中执行以下命令来设置镜像：
git -C "$(brew --repo)" remote set-url origin https://mirrors.ustc.edu.cn/brew.git 这将将 Homebrew 的远程仓库设置为中国科学技术大学的镜像地址，加快软件包的下载速度。
还有一个办法就是使用中科大的主体（我使用这个成功了）
/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 如下图
Homebrew 是一个功能强大的软件包管理器，它提供了许多有用的命令来安装、更新和管理软件包。以下是一些常用的 Homebrew 命令：
安装软件包： brew install &lt;package&gt; 这个命令用于安装指定的软件包，将 &lt;package&gt; 替换为要安装的软件包名称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b77fc7358425d53b668c60a1420f66ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2424101c7791ed390042e5764bd3693e/" rel="bookmark">
			基于java的雷电游戏系统设计与实现(项目报告&#43;答辩PPT&#43;源代码&#43;部署视频)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目报告
基于Java的雷电游戏
电脑游戏，是指在计算机上能够运转的游戏软件。这种软件具有较强的娱乐性。电脑游戏的创新和发展与硬件、软件的发展紧密相关。它能够给玩家提供一个虚拟的环境，使游戏带给了人们很多的享受和欢乐。雷电游戏因为操作简单，节奏明快，一直是纵轴射击游戏的经典之作。经常能够在手机或者计算机中见到这款游戏，深得广大玩家的喜爱，可以说是妇孺皆知的一款益智类游戏。
本游戏基于Eclipse开发平台，以java作为编程语言，整个项目开发旨在模拟雷电游戏的飞机射击游戏。游戏界面的下部是玩家的飞机，可以根据按键控制子弹的发射，上部为敌方飞机，在界面中随机出现。在游戏过程当中，用户飞机的移动是被电脑键盘的方向键所控制的，在整个游戏过程当中，如果用户飞机的子弹与敌方飞机发生相撞时，敌方飞机就会有爆炸的效果产生。游戏中使用到的飞机、子弹均采用对应的类实现。
雷电；电脑游戏；java；Eclipse；
目 录
摘 要........................................................ I
Abstract...................................................... II
1 引言........................................................ 3
1.1 项目背景................................................ 3
1.2 电脑游戏的发展历史...................................... 3
1.3国内游戏项目研究现状.................................... 5
1.4项目主要工作............................................ 6
1.5本文组织结构............................................ 7
1.6 电脑游戏的策划.......................................... 7
2 开发平台与开发技术.......................................... 8
2.1 Eclipse................................................. 8
2.2 Eclipse平台............................................ 8
2.3 Java.................................................... 9
2.4游戏图形界面的开发基础................................. 11
2.5Java游戏中的基本框架................................... 14
3 雷电游戏模块设计........................................... 16
3.1 用户需求分析........................................... 16
3.2 可行性分析............................................. 16
3.3 总体设计原则........................................... 17
3.4 功能模块设计........................................... 18
3.4.1 游戏状态控制功能................................. 18
3.4.2 游戏难度的调整................................... 18
3.4.3 游戏界面绘画功能................................. 18
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2424101c7791ed390042e5764bd3693e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ef7861ce9bdb7d3f8af977a45c0eaa/" rel="bookmark">
			torch.jit.script 与 torch.jit.trace
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 torch.jit.script 与 torch.jit.tracetorch.jit.scripttorch.jit.tracetorch.jit.savetorch.jit.loadCode torch.jit.script 与 torch.jit.trace torch.jit.script 和 torch.jit.trace 是 PyTorch 中用于将模型转换为脚本或跟踪模型执行的工具。
它们是 PyTorch 的即时编译（Just-in-Time Compilation）模块的一部分，用于提高模型的执行效率并支持模型的部署。
torch.jit.script torch.jit.script 是将模型转换为脚本的函数。
它接受一个 PyTorch 模型作为输入，并将其转换为可运行的脚本。转换后的脚本可以像普通的 Python 函数一样调用，也可以保存到磁盘并在没有 PyTorch 依赖的环境中执行。
这种转换的好处是可以减少模型执行过程中的开销，因为它消除了 Python 解释器的开销。
示例：
import torch # 定义模型 class MyModel(torch.nn.Module): def __init__(self): super(MyModel, self).__init__() self.conv = torch.nn.Conv2d(3, 64, kernel_size=3, padding=1) self.fc = torch.nn.Linear(64 * 8 * 8, 10) def forward(self, x): x = self.conv(x) x = torch.nn.functional.relu(x) x = x.view(-1, 64 * 8 * 8) x = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27ef7861ce9bdb7d3f8af977a45c0eaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224a8627f7ab1207d47d682275df5470/" rel="bookmark">
			测试测试测试测试测试测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试测试测试测试测试测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f78eff5e7d2c7a84a5038056a5a7767/" rel="bookmark">
			ES安装教程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES安装教程详解
转载：https://blog.csdn.net/he19970408/article/details/107359861/
文章目录
0. 安装前准备
2. 在官方网站下载ES
3. 安装JDK(必须JDK1.8+)
4. 配置环境变量
5. 重载系统配置
6. 安装elasticsearche
7. elasticsearche的目录结构
8. 运行es服务
9. 不能以root用户身份启动
10. 登录es用户启动ES
11. 测试ES是否启动成功
12. 开启ES远程访问
13. 启动时错误解决方案
14. 关闭网络防火墙
15. 外部浏览器访问即可
安装前准备
centos7 +
java 8 +
elastic 6.2.4+
在官方网站下载ES
wget http://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.1.tar.gz
安装JDK(必须JDK1.8+)
rpm -ivh jdk-8u181-linux-x64.rpm
/注意:默认安装位置 /usr/java/jdk1.8.0_171-amd64/
配置环境变量
vim /etc/profile
在文件末尾加入:
export JAVA_HOME=/usr/java/jdk1.8.0_171-amd64
export PATH= P A T H : PATH: PATH:JAVA_HOME/bin
重载系统配置
source /etc/profile
安装elasticsearche
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f78eff5e7d2c7a84a5038056a5a7767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b24c975c0c8d9ed7d26ad8fc473d699/" rel="bookmark">
			ENVI预处理GF-1号WFV1遥感数据提取NDVI指数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ENVI预处理GF-1号WFV1遥感数据提取NDVI指数 目录：
遥感数据获取遥感数据预处理
2.1编辑头文件
2.2辐射定标
2.3FLAASH大气校正
2.4正射校正
2.5计算NDVI
2.6图像裁剪 提取结果如下：
遥感数据获取 https://data.cresda.cn/#/home
打开陆地观测卫星数据服务网站，注册登录之后
选择高分1号16m数据，搜索河北省廊坊市大厂回族自治县，采集时间按实验需要（我用的2023年5月26日，后面需要实地测量数据验证，因此时间上选对应的）
选择一个能够覆盖研究区域的图像，加入购物车，提交订单等待网站邮件，然后下载。
遥感数据预处理 编辑头文件 下载好后，先将tiff格式的遥感影像拖动到ENVI中，右键点击选择View Metadata
打开Spectral一栏，主要修改红圈中的四个传感器参数，点击Edit Metadata
找到对应的几个修改参数一栏，如果没有的话，在上方Add中添加。高分1号的Wavelength和FWHM、Offset可以参考上面我图中的参数，第三列的Radiance Gains可以参考下表。
选择2022年的WFV1传感器参数。具体见下面网站
https://blog.csdn.net/weixin_56529683/article/details/129276880
辐射定标 流程也可以参考如下网站
https://www.cnblogs.com/enviidl/p/16553338.html
在右侧工具栏中，找到Radiometric Calibration
FLAASH大气校正 具体过程可以参考下面网站
https://www.cnblogs.com/enviidl/p/16553338.html
工具栏中打开
输入文件找到刚刚辐射定标处理后的影像
打开后点击下面的选项，默认为1就好
然后输出路径和文件夹也设置一下，这里有个注意事项，就是输入输出的路径名当中一定不要包含中文，路径最好也不要太长，可以在D盘下面专门放一个文件夹来保存ENVI处理的过程结果
一些参数设置
打开Multispectral Settings设置波谱响应函数，选好后点Ok
点击Advanced Settings，上面的参数设置为100，然后点击Ok，退回到FLAASH参数设置界面，点击左下角的Apply选项。开始大气校正，电脑过程中可能会无响应，等待一段时间即可。
正射校正 具体参考下面网站
https://zhuanlan.zhihu.com/p/400902530
计算NDVI 过程参考网站
ENVI提取NDVI与植被覆盖度估算 - 知乎 (zhihu.com)
打开Band Math,输入公式(float(b5)-b4)/(b5+b4)
点击Add to List
选中，并点击Ok
B4选择0.6650的红光波段，B5选择0.8的近红外波段,设置好输出路径后，点击Ok
得到如下NDVI影像。
图像裁剪 首先需要有自己研究区域的shape文件，该文件如何制作参考我的文章
拖动大厂回族自治县的shape文件到ENVI中，自动生成红线内的区域
工具栏中，找到Subset工具
点击Cursor Value工具，某点的Data值就是该点的NDVI计算结果
最后将该处理结果保存为TIFF格式影像。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c988ec3194bfa1a9e5b29386eb7a1e/" rel="bookmark">
			DAY3、DAY4(路飞)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典 因为key不能为变量 只能为不可变的值
字典的key必须是唯一的 不然后面的值会吧前面的值覆盖
字典取值只能一个一个取 且只能通过key查询value 不能反过来
d.items就是变成了列表里 元祖的形式
这种取值是最推荐的。第三种比第二种推荐的方式 是因为第2种取值会先转换为大列表。然后取值，有一个转化的过程，所以效率低。
第三种就是直接拿key去取value的值 取1亿条和取1条一样的快
解释器自带函数
二进制计算 问题：如何去打印两个空格1个对号呢？？
因为空格的ascii码对应的数字就是0
1个二进制位就是1bit
8bit就是一个字符就是 1bytes
如何识别中文的呢 2个字节 2^16 =65535 所以2个字节代表一个中文汉字。
2个字节的首位都是1 代表就是汉字
因为ascii码128以后的都是乱七八糟的字符 --扩展表 基本只用0-128 基本字节
代表英文数字都在0-128内
所以2个高字节一起出现 就认定是中文。
编码的战国时代 后来囊括了 中文 日文 少数民族的所有语言 编码为gbk
比如 中文用 2个字节代表 其他的xx用3个代表
万国码可以转的表
比如路字在万国码里的位置是8DEF 在gbk是4237 这样子就很好转换了 都有转换的关系；
这样子不至于中文编译的软件 转换为万国码也很方便了
但是万国码使得转换为硬盘上就会变大了 传输时间也长了
UTF32 相当于不管是啥都转为4个字节离谱
UTF-8 就是传输到文件最通用的方式 在内存就还是unicode
16进制 参考：本文链接：https://blog.csdn.net/weixin_43857827/article/details/126304561
Day4 gbk的文字如何转换 问题：文字在windos上产生的 gbk编码
发送到mac 要求mac正常显示怎么办？
演示：
pycharm默认就是utf8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c988ec3194bfa1a9e5b29386eb7a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce54badd6862c3acd25904954be3a25f/" rel="bookmark">
			Echarts入门(SpringBoot &#43; Vue)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Echarts简介 代码已上传至码云:echarts_boot: echarts使用demo
ECharts是一个使用 JavaScript 实现的"数据可视化"库, 它可以流畅的运行在 PC 和移动设备上
什么是数据可视化?
也就是可以将数据通过图表的形式展示出来，
Echarts官网:Apache ECharts
本篇文章以此柱状图为例：
二、业务背景 数据库中分别有学生表、课程表、成绩表三张表
使用echarts对 某科目全班平均分近三年变化、某个人总分数变化、某人某年各科成绩作统计和可视化操作
表结构如下：
三、数据准备 /* Navicat Premium Data Transfer Source Server : CloudShell Source Server Type : MySQL Source Server Version : 50736 (5.7.36) Source Host : 124.70.69.186:13306 Source Schema : echarts_test Target Server Type : MySQL Target Server Version : 50736 (5.7.36) File Encoding : 65001 Date: 01/07/2023 15:44:13 */ SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for course -- ---------------------------- DROP TABLE IF EXISTS `course`; CREATE TABLE `course` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `cou_num` int(11) DEFAULT NULL COMMENT '课程号', `cou_name` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL COMMENT '课程名', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='课程表'; -- ---------------------------- -- Records of course -- ---------------------------- BEGIN; INSERT INTO `course` (`id`, `cou_num`, `cou_name`) VALUES (1, 1, '语文'); INSERT INTO `course` (`id`, `cou_num`, `cou_name`) VALUES (2, 2, '数学'); INSERT INTO `course` (`id`, `cou_num`, `cou_name`) VALUES (3, 3, '英语'); COMMIT; -- ---------------------------- -- Table structure for score -- ---------------------------- DROP TABLE IF EXISTS `score`; CREATE TABLE `score` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `cou_num` int(11) NOT NULL COMMENT '课程号', `stu_num` int(11) NOT NULL COMMENT '学号', `score` int(11) DEFAULT NULL COMMENT '成绩', `time` timestamp NULL DEFAULT NULL COMMENT '时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='成绩表'; -- ---------------------------- -- Records of score -- ---------------------------- BEGIN; INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (1, 1, 1, 90, '2023-06-30 09:57:19'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (2, 2, 1, 88, '2023-06-30 09:57:31'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (3, 3, 1, 95, '2023-06-30 09:57:42'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (4, 1, 2, 70, '2023-06-30 09:57:54'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (5, 2, 2, 99, '2023-06-30 09:58:04'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (6, 3, 2, 60, '2023-06-30 09:58:12'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (7, 1, 3, 56, '2023-06-30 09:58:20'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (8, 2, 3, 32, '2023-06-30 09:58:31'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (9, 3, 3, 43, '2022-06-30 09:58:48'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (10, 1, 1, 88, '2022-06-30 09:57:19'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (11, 2, 1, 86, '2022-06-30 09:57:31'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (12, 3, 1, 93, '2022-06-30 09:57:42'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (13, 1, 2, 70, '2022-06-30 09:57:54'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (14, 2, 2, 99, '2022-06-30 09:58:04'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (15, 3, 2, 60, '2022-06-30 09:58:12'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (16, 1, 3, 56, '2022-06-30 09:58:20'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (17, 2, 3, 32, '2022-06-30 09:58:31'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (18, 3, 3, 43, '2022-06-30 09:58:48'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (19, 1, 1, 86, '2021-06-30 09:57:19'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (20, 2, 1, 84, '2021-06-30 09:57:31'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (21, 3, 1, 91, '2021-06-30 09:57:42'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (22, 1, 2, 70, '2021-06-30 09:57:54'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (23, 2, 2, 99, '2021-06-30 09:58:04'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (24, 3, 2, 60, '2021-06-30 09:58:12'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (25, 1, 3, 56, '2021-06-30 09:58:20'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (26, 2, 3, 32, '2021-06-30 09:58:31'); INSERT INTO `score` (`id`, `cou_num`, `stu_num`, `score`, `time`) VALUES (27, 3, 3, 43, '2021-06-30 09:58:48'); COMMIT; -- ---------------------------- -- Table structure for student -- ---------------------------- DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `stu_num` int(11) NOT NULL COMMENT '学号', `stu_name` varchar(255) COLLATE utf8mb4_bin NOT NULL COMMENT '姓名', `stu_sex` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL COMMENT '性别', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='学生表'; -- ---------------------------- -- Records of student -- ---------------------------- BEGIN; INSERT INTO `student` (`id`, `stu_num`, `stu_name`, `stu_sex`) VALUES (1, 1, '张三', '男'); INSERT INTO `student` (`id`, `stu_num`, `stu_name`, `stu_sex`) VALUES (2, 2, '李四', '女'); INSERT INTO `student` (`id`, `stu_num`, `stu_name`, `stu_sex`) VALUES (3, 3, '王五', '男'); COMMIT; SET FOREIGN_KEY_CHECKS = 1; 四、构建后端工程 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce54badd6862c3acd25904954be3a25f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76b4b2b4cbf39f424f923a8e617f748/" rel="bookmark">
			IDEA中删除某个模块后在创建同名模块显示已存在 的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA中删除某个模块后在创建同名模块显示已存在 的解决方案 出现的问题复现解决方案成功添加后可能会出现的问题 出现的问题复现 前提是你认为已经删干净了，因为删除模块得删除两次才能从本地的文件夹中删除。
解决方案 右击项目名 找到 这个玩意儿，点进去会出来一个对话框，在左边会有子模块，你会发现里边有一个你要创建的同名模块，点着点卸载，卸载完就可以重新添加模块了。
成功添加后可能会出现的问题 可能子模块会没有这些玩意儿
然后你可以找着相关文件右击找到
这玩意儿自己设置设置，我试来，设置完了里边的yml文件啥的都好使
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8194199a1b9d35c00368cfd3d493997/" rel="bookmark">
			浅谈 Spring 如何解决 Bean 的循环依赖问题(转载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是循环依赖？ 通俗来讲，循环依赖指的是一个实例或多个实例存在相互依赖的关系（类之间循环嵌套引用）。
举个例子
public class AService { private BService bService; } public class BService { private AService aService; } 上述例子中 AService 依赖了 BService，BService 也依赖了 AService，这就是两个对象之间的相互依赖。当然循环依赖还包括 自身依赖、多个实例之间相互依赖。
正常运行上面的代码调用 AService 对象并不会出现问题，也就是说普通对象就算出现循环依赖也不会存在问题，因为对象之间存在依赖关系是很常见的，那么为什么被 Spring 容器管理后的对象会出现循环依赖问题呢？
2. Spring Bean 的循环依赖问题 被 Spring 容器管理的对象叫做 Bean，为什么 Bean 会存在循环依赖问题呢？
想要了解 Bean 的循环依赖问题，首先需要了解 Bean 是如何创建的。
2.1 Bean 的创建步骤 为了能更好的展示出现循环依赖问题的环节，所以这里的 Bean 创建步骤做了简化：
1、在创建 Bean 之前，Spring 会通过扫描获取 BeanDefinition。
2、BeanDefinition就绪后会读取 BeanDefinition 中所对应的 class 来加载类。
3、实例化阶段：根据构造函数来完成实例化 （未属性注入以及初始化的对象 这里简称为 原始对象）
4、属性注入阶段：对 Bean 的属性进行依赖注入 （这里就是发生循环依赖问题的环节）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8194199a1b9d35c00368cfd3d493997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af13e1cbf29c726be6de36cba7fed236/" rel="bookmark">
			【实操记录】vm配置网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【实操记录】vm配置网络 1.环境2.网络配置模式简介3.网络配置实操3.1 仅主机模式3.2 NAT模式3.2.1 打开虚拟网络编辑器3.2.2 更改设置3.2.3 选择nat模式3.2.4 设置网关3.2.5 虚拟机网络设置3.2.6 验证是否可以访问外网3.2.7 主机访问虚拟机3.2.8 验证主机访问虚拟机 3.3 桥接模式3.3.1 打开虚拟网络编辑器3.3.2 更改设置3.3.3 选择桥接模式3.3.4 修改redhat网络设置3.3.5 验证 4.参考资料 1.环境 操作系统：win11
虚拟机工具：vm17pro
虚拟机系统：redhat8
2.网络配置模式简介 仅主机模式：不能连接外网，只能和主机互通
NAT模式：可以连接外网，虚拟一个子网
桥接模式：可以连接外网，与主机共享网卡
3.网络配置实操 3.1 仅主机模式 不能连外网，感觉不实用，在此不做介绍
3.2 NAT模式 3.2.1 打开虚拟网络编辑器 3.2.2 更改设置 3.2.3 选择nat模式 说明：
1.选择nat模式
2.如果需要主机连接虚拟机就勾上
3.设置子网ip
4.设置网关，须和子网ip在同一个网段
3.2.4 设置网关 3.2.5 虚拟机网络设置 进入redhat 命令行输入
vi /etc/sysconfig/network-scripts/ifcfg-ens160 修改 IPADDR,只要和子网在同一网段即可
GATEWAY 和子网网关一致
DNS1 114.114.114.114，8.8.4.4
3.2.6 验证是否可以访问外网 执行以下命令
ping wwwbaidu.com 出现以下内容说明可以连接外网了。
3.2.7 主机访问虚拟机 win设置网络
说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af13e1cbf29c726be6de36cba7fed236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eabf9dd0fc0e5aff8d7caaf3e8f269e6/" rel="bookmark">
			彻底告别mysql乱码（mysql字符集详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		彻底告别mysql乱码（mysql字符集详解） 用到的指令涉及系统变量character_set_clientcharacter_set_connectioncharacter_set_results 案例说明案例环境表结构及内容变量值字符集 执行过程 补充参考 用到的指令 # 查看变量 show [GLOBAL|SESSION(LOCAL)] variables [LIKE 匹配内容]; # 修改变量 set [GLOBAL|SESSION(LOCAL)] varable_name=value; 涉及系统变量 character_set_client 将客户端请求内容，通过该变量指定的字符集进行解码
character_set_connection 将解码结果按指定字符集进行编码，编码结果用于服务器处理
character_set_results 服务器向客户端返回数据时使用的字符集
案例说明 用一个简单查询举例：select * from student where name = '郁‘;
案例环境 表结构及内容 CREATE TABLE student( name VARCHAR(10) CHARACTER SET chat_y; ) insert into student(name) value ("郁"); insert into student(name) value ("王"); 变量值 character_set_client=chat_w;character_set_connection=chat_y;character_set_results=chat_z; 字符集 chat_y
字符字节郁1王2 chat_w
字符字节王1郁2 chat_z
字符字节王3 执行过程 客户端输入指令。
指令编码成二进制串，传递至服务端（这里我们假设客户端采用的字符集为chat_y，所以"郁"对应的编码为"1"）服务端接收请求。
此时用到的变量为“character_set_client”，值为“chat_w”。经过解码，我们的查询语句就变成了"select * from student where name = “王”。服务端处理请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eabf9dd0fc0e5aff8d7caaf3e8f269e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ad28f183d63f27601342e3ad92ef6d/" rel="bookmark">
			Spring Boot 中的 @Field 注解详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 中的 @Field 注解详解 引言 Spring Boot 是目前 Java 生态圈中最受欢迎的 Web 应用开发框架之一，它提供了很多优秀的功能和工具，可以帮助开发者快速构建高效、可靠的 Web 应用程序。其中一个重要的功能就是数据绑定和验证，Spring Boot 提供了多种方式来绑定请求参数、表单数据、JSON 数据等。其中，@Field 注解就是其中一个非常常用的注解，它可以帮助我们将请求参数映射到 Java 对象的属性上，本文将详细介绍 @Field 注解的原理和使用方法。
@Field 注解的原理 在 Spring Boot 中，@Field 注解是用来绑定请求参数到 Java 对象属性上的注解，它的原理是通过 Java 反射机制将 HTTP 请求中的参数值自动绑定到 Java 对象的属性上。当使用 @Field 注解时，Spring Boot 会根据注解中指定的属性名，在请求参数中查找同名的参数值，并将其自动转换为该属性的类型，然后赋值给该属性。
例如，我们有一个 User 类，其中包含两个属性：name 和 age，我们希望在 HTTP 请求中传递 name 和 age 参数，并将其绑定到 User 对象的属性上，可以使用如下代码：
public class User { private String name; private int age; // getter 和 setter 方法省略 } @RestController public class UserController { @PostMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ad28f183d63f27601342e3ad92ef6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21746fa5da49993b6cc6a8fc2a58e2cb/" rel="bookmark">
			【云原生】k8s之pod基础（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.pod的镜像拉取策略 1.1 镜像拉取说明 当你在创建容器时会针对指定的镜像来进行容器的创建，所以pod的创建是以镜像为基础。当你在拉取镜向不指定仓库的主机名，Kubernetes 认为你在使用 Docker 公共仓库。
在镜像名称之后，你可以添加一个标签（Tag）（与使用 docker 或 podman 等命令时的方式相同）。 使用标签能让你辨识同一镜像序列中的不同版本。
镜像标签可以包含小写字母、大写字母、数字、下划线（_）、句点（.）和连字符（-）。 关于在镜像标签中何处可以使用分隔字符（_、- 和 .）还有一些额外的规则。 如果你不指定标签，Kubernetes 认为你想使用标签latest
1.2 镜像拉取的策略 首先在资源式声明中存在着imagePullPolicy的字段，它的value决定着k8s创建容器时拉取镜像的方式策略。【此字段所在位置也说明了在声明式yaml中，imagePullPolicy是包含containers中】
kubectl explain pod.spec.containers.imagePullPolicy
如图所示，这三种便是k8s拉取镜像的三种策略：
IfNotPresent
只有当镜像在本地不存在时才会拉取。（先对本地进行排查，本地有该镜像直接使用，本地没有该镜像则选择在仓库中拉取）
Always
总是从仓库拉取镜像，无论本地是否存在镜像（即使本地中存在我们所指定的相关镜像，该策略也会先从仓库中拉取进行应用）
Never
Kubelet 不会尝试获取镜像。如果镜像已经以某种方式存在本地， kubelet 会尝试启动容器；否则，会启动失败。（如果本地不存在，并不会在仓库中拉取，直接报错）
注意：如果没有显式设定的话， Pod 中所有容器的默认镜像拉取策略是IfNotPresent。但是也存在着默认策略选择Always的情况。
此外：
在生产环境中部署容器时，你应该避免使用 :latest 标签，因为这使得正在运行的镜像的版本难以追踪，并且难以正确地回滚。（难以追溯版本，且latest一直会不断迭代更新，给版本维护照成困扰） 1.3 镜像拉取策略的设置操作 （1）Never策略的使用 kubectl run app-test --image=httpd --dry-run=client -o yaml &gt; demo1.yaml
vim demo1.yaml
（2）IfNotPresent策略在本地无镜像的情况下使用 vim demo1.yaml
#查看详细的pod信息，其中也有日志的作用
kubectl describe pod app-test
（3）Always策略 2.pod的启动命令说明 在k8s的容器中也存在着和docker-compose类似的shell启动命令字段，用于pod容器启动后执行命令的操作。 该字段存在containers中：
kubectl explain pod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21746fa5da49993b6cc6a8fc2a58e2cb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/118/">«</a>
	<span class="pagination__item pagination__item--current">119/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/120/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>