<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa927face81ce1c54593dd9fe3178be8/" rel="bookmark">
			tensorRT从零起步高性能部署：课程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. cuda驱动API2. cuda运行时API3. tensorRT基础4. tensorRT高级5. tensorRT封装6. 自动驾驶案例项目总结 前言 杜老师推出的 tensorRT从零起步高性能部署 课程，之前有看过一遍，但是没有做笔记，很多东西也忘了。这次重新撸一遍，顺便记记笔记。
本次课程主要是课程总结，对之前学习的知识的一个复习
课程大纲可看下面的思维导图
1. cuda驱动API 这个章节我们主要了解了 CUDA Driver API 这个与 GPU 沟通的驱动级底层 API，在 Driver API 中我们主要学习了 CUDA 系列接口的开发习惯、Context 的管理机制和内存模型
我们在调用 CUDA Driver API 时都会去对 API 返回值的结果进行一个检查，这样做的目的当然是便于我们发现错误，方便调试，具体实现我们是通过函数封装+宏的方式提供一个统一的接口，并根据返回值判断 API 执行是否成功，从而进行相应的处理。以后的诸如 Runtime API、Kernel 核函数都是这样做的，为各种 CUDA API 函数添加 check 功能，方便定位错误信息，有利于后续开发。
接着我们了解了 context，它是一种上下文，可以关联对 GPU 的所有操作。使用 context 的目的是可以将一系列相关的 CUDA 操作关联到一个 context 中，而不用每次在执行诸如 cuMalloc、cuMemcpy 时都需要显式的制定设备标识符 device。此外，关于上下文的创建更推荐使用 cuDevicePrimaryCtxRetain，它不需要显式地管理上下文栈，代码更简洁。
最后我们简单地学习了 device memory、page-locked memory 的内存分配，分别使用的是 cuMemAlloc 和 cuMemAllocHost
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa927face81ce1c54593dd9fe3178be8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c544c9f9381c604a9df469e2910b66e7/" rel="bookmark">
			Dockerfile创建镜像异常问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dockerfile创建 dockerfile文件一定要在Linux创建，windows会默认结尾带 /r 会导致生成的镜像文件无法启动，且报错十分诡异。
镜像启动查看日志可以通过 docker logs [容器ID] 来查看
由于是启动jar包，docker logs 显示的报错是：
docker logs [容器id]
unable to access jarfile
会让人错误的认为是jar相关命令出问题，忽略了文件类型的原因。
可以diff Linux和Windows创建的两个文件，或者 file 文件查看文件属性。
Linux 上的文件：ASCII text
Windows上的文件：ASCII text, with CRLF line terminators.
Docker save保存镜像 表现：Docker-镜像导入后repository和tag名称都为none的解决办法
[root@owy-bd-c16-18 patrol]# docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
nginx latest ea335eea17ab 7 days ago 141MB
43ce62428b8c 5 months ago 185MB
原因：docker save镜像时未指明 和。
docker save -o .tar（会导致载入镜像后名字标签都为）
解决办法：
正确的导出方式：docker save : -o .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c544c9f9381c604a9df469e2910b66e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d49693c579044ced4c01f5fb1a7498/" rel="bookmark">
			Less 和 SCSS 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述 Less 和 SCSS 都是 CSS 预处理器，它们可以让开发人员编写更高效的 CSS 代码来实现快速样式化页面。
下面是一些它们之间的区别： 1、语法差异 Less 和 SCSS 有不同的语法。Less 更像是 CSS，使用大括号 {} 来定义代码块，而且没有必要输入分号 ;。相反，SCSS 借鉴了其他编程语言（如JavaScript）的语法，使用的是类似于Sass的语法。，使用大括号 {} 来定义代码块，必须要以分号 ; 结尾。
2、变量和常量 Less 和 SCSS 都允许使用变量和常量，但它们对这些特性的支持略有不同。Less 的变量使用 @ 符号，而 SCSS 的变量使用 $ 符号。
3、Mixin（混合） Less 和 SCSS 的 Mixin（混合）方式不同。Less 使用 @mixin 关键字来定义多个 CSS 规则，并使用带有 @apply 的选择器来应用混合后的样式；而 SCSS 使用 @mixin 关键字来定义样式，但是使用 @include 将混合样式应用到选择器中。混合可以让开发人员将一组 CSS 规则定义一次并在任何时间引用它们。
4、继承和实现 在 Less 中，通过 extend 关键字来扩展样式，而 SCSS 使用 @extend 关键字来实现样式的扩展。 在 Less 中，可以通过 import 关键字将另一个 Less 文件的样式导入到当前文件中。而在 SCSS 中，使用了 @import 指令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08d49693c579044ced4c01f5fb1a7498/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddbcda9ca5a9dbb7c16875550b899bbf/" rel="bookmark">
			基于Citespace、vosviewer、R语言的文献计量学可视化分析技术及全流程文献可视化SCI论文高效写作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文献计量学是指用数学和统计学的方法，定量地分析一切知识载体的交叉科学。它是集数学、统计学、文献学为一体，注重量化的综合性知识体系。特别是，信息可视化技术手段和方法的运用，可直观的展示主题的研究发展历程、研究现状、研究热点和发展态势。Citespace和vosviewer是使用最广泛的文献信息可视化软件工具，在理工、经管、法学、教育、农学、文史、医学、艺术等学科中普遍应用，发文量逐年显著上升。
理论与实践相结合，通过文献计量学讲解、高效选题、数据库检索数据下载、软件使用等专题详细讲解，系统全面的掌握文献计量学的基本理论和知识；熟练掌握Citespace和vosviewer及R语言文献可视化分析技术；最终实现从主题确定、数据分析绘图、文章框架与写作，全流程掌握一篇文献信息可视化分析报告（论文）的思路逻辑与技术方法。
原文链接：基于Citespace、vosviewer、R语言的文献计量学可视化分析技术及全流程文献可视化SCI论文高效写作
专题一 文献计量学方法与应用简介
1.文献计量学方法基本介绍
2.与其他综述方法区别联系
3.各学科领域应用趋势近况
4.主流分析软件优缺点对比
专题二主题确定、检索与数据采集
1.热点主题高效选择方法
2.目标主题可行性预判
3.CNKI数据库检索式构建
4.CNKI数据导出方法与注意事项
5.WOS数据库检索式构建
6.WOS数据导出与注意事项
专题三 VOSviewer可视化绘图精讲 【案例+实践】
1.Vosviewer界面与主要概念简介
2.WOS与CNKI数据导入
3.共被引网络图绘制与解读关键
4.叠加网络图绘制与解读关键
5.密度图绘制与解读关键
6.关键词合并方法与注意事项
7.VOSviewer与Pajek耦合展示
专题四 Citespace可视化绘图精讲
1.CiteSpace版面与主要概念介绍
2.WOS与CNKI数据导入、清洗方法
3.学科分布图绘制参数选择与解读
4.共现网络图绘制参数选择与解读
5.聚类图绘制参数选择与解读
6.突现图绘制参数选择与解读
7.时间线图绘制参数选择与解读
专题五 R语言文献计量学绘图分析 【案例+实践】
1.R包安装调用、数据加载与过滤
2.发文趋势及引用分析与解读
3.文献来源分析与解读
4.合作网络分析与解读
5.文献分析与解读
6.关键词分析与解读
7.国家出版密度及合作分析与解读
专题六 论文写作
1 典型结构模式剖析
2 软件搭配组合技巧
3 图表搭配组图策略
4 定向文献参考套路
5 模块化写作思路
专题七 论文投稿
1 期刊选择方法
2 投稿前准备工作
3 投稿过程注意事项
4 文献计量学常见审稿意见
5 拒搞后再投如何提高命中率
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddbcda9ca5a9dbb7c16875550b899bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5022f522ccebfcc418aa56d23f2745e2/" rel="bookmark">
			Python学习笔记——从面试题出发学习Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python学习笔记——从面试题出发学习Python Python学习笔记——从面试题出发学习Python1. 可变数据类型与不可变数据类型，深拷贝与浅拷贝，函数参数的传递机制1.1 变量与对象1.2 可变数据类型与不可变数据类型1.3 深拷贝与浅拷贝1.4 函数参数的传递机制1.5 is和==的区别 2. Python的内存管理机制，Python是否会存在内存泄漏的情况2.1 内存池机制2.2 垃圾回收机制2.2.1 标记-清除机制2.2.2 分代回收机制 2.3 Python内存泄漏 3. 闭包与装饰器3.1 Python的作用域3.2 闭包3.3 装饰器 4. 迭代器与生成器4.1 惰性计算4.1 迭代器4.2 生成器 5. 正则表达式5.1 元字符和语法5.2 re模块函数5.3 re模块变量 6. Python中的魔法方法类别有哪些？__init__和__new__的区别是什么？6.1 魔法方法6.2 __ init__和__ new__的区别 7. 多重继承中的MRO机制7.1 新式类和旧式类的区别7.2 多重继承带来的问题7.3 MRO机制7.4 super()作用 8. Python中为什么没有重载？8.1 为什么没有重载8.2 Python函数可变参数 9. Python内建模块9.1 collections模块的用法9.2 functools模块的用法9.3 itertools模块的用法 10 协程10.1 GIL的概念10.2 协程的概念 Python学习笔记——从面试题出发学习Python 1. 可变数据类型与不可变数据类型，深拷贝与浅拷贝，函数参数的传递机制 1.1 变量与对象 对象指的是内存中存储数据的实体，具有明确的类型，在 Python 中一切都是对象，包括函数。变量作为对象的引用/别名，实质保存着所指对象的内存地址。 1.2 可变数据类型与不可变数据类型 在Python中类型属于对象，变量没有类型，仅仅是对一个对象的引用。而赋值语句改变的是变量所执的对对象的引用，故一个变量可指向各种数据类型的对象。
从现象上看：不可变数据类型更改值后，内存地址发生改变；可变数据类型更改值后，内存地址不发生改变。从本质上看：不可变数据类型对象相应内存中的值不可改变，但变量对对象的引用或指向关系仍是可变的，指向原不可变对象的变量被改变为指向新对象时，Python 会开辟一块新的内存区域，并令变量指向这个新内存，并通过 “垃圾回收机制” 回收原对象；可变数据类型对象的内存地址处的值可改变，因此指向可变对象的变量若发生改变，则该可变对象亦随之改变，即发生原地 (in-place) 修改可变数据类型：list（列表）、dict（字典）不可变数据类型：数值类型（int、float、bool）、string（字符串）、tuple（元组） 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5022f522ccebfcc418aa56d23f2745e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6459e6190bf6b37c5613d3f8a058d402/" rel="bookmark">
			关于ELF文件格式的理解与读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、ELF Header 注：以下只讨论64位的情况 该段结构体如下：
typedef struct { unsigned char e_ident[EI_NIDENT]; //16 B (B for bytes) Elf64_Half e_type; // 2 B Elf64_Half e_machine; // 2 B Elf64_Word e_version; // 4 B Elf64_Addr e_entry; // 8 B Elf64_Off e_phoff; // 8 B Elf64_Off e_shoff; // 8 B Elf64_Word e_flags; // 4 B Elf64_Half e_ehsize; // 2 B Elf64_Half e_phentsize; // 2 B Elf64_Half e_phnum; // 2 B Elf64_Half e_shentsize; // 2 B Elf64_Half e_shnum; // 2 B Elf64_Half e_shstrndx; // 2 B } Elf64_Ehdr; 我们可以结合使用readelf -as ‘elf文件名’命令来查看：图1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6459e6190bf6b37c5613d3f8a058d402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a2cee235197bab89356d058fa9994c8/" rel="bookmark">
			git ------ IDEA中建立本地/远程仓库及上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
建立本地仓库
1. idea中选择创建本地仓库
选择目标文件
创建远程仓库
1.码云上进行库创建
将本地仓库数据提交到远程仓库
提交代码
推送到远程
建立本地仓库 1. idea中选择创建本地仓库 或 vsm中找下列2 即可
选择目标文件 成功后会出现以下标识
更新 提交 推到 历史记录
创建远程仓库 1.码云上进行库创建 复制http代码 然后进行远程仓库操作
URL填入刚刚赋值的链接即可
将本地仓库数据提交到远程仓库 引入 （过滤不提交的项目后缀）.gitignore 或者 下载插件 .gitignore
没有的在Settings-&gt;Editor-&gt;File Types-&gt;Ignored Files and Folders 中把.gitignore文件去掉就可以了
提交代码 推送到远程 第三个
最后在gitee 中查看成功与否
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8bb67fb815541d0c82a12076fca6be/" rel="bookmark">
			CSDN 排版之颜色、字体、字号、空格、换行及背景色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语法格式 &lt;font color=颜色 face=字体 size=字号大小&gt; 需要显示的正文内容 &lt;/font&gt; 颜色 &lt;font color=blue &gt; blue &lt;/font&gt;
示例结果： blue &lt;font color=#00f9ff &gt; #00f9ff &lt;/font&gt;
示例结果： #00f9ff 常用颜色集锦：(颜色英文名）
blue mediumblue red black brown bright brown chartreuse green darkgreen orange darkorange pink gold yellow lawngreen purple
bright magenta teal
RGB颜色参照 网址为：https://tool.oschina.net/commons?type=3 字体 &lt;font face="楷体"&gt; 楷体&lt;/font&gt;
示例结果： 楷体
&lt;font face="黑体"&gt; 黑体&lt;/font&gt;
示例结果： 黑体
&lt;font face="微软雅黑"&gt; 微软雅黑&lt;/font&gt;
示例结果： 微软雅黑
&lt;font face="STCAIYUN"&gt; 华文彩云&lt;/font&gt;
示例结果：华文彩云
&lt;font face="宋体"&gt; 宋体&lt;/font&gt;
示例结果： 宋体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8bb67fb815541d0c82a12076fca6be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b74e64bef0a3e096032443cd68d5c1/" rel="bookmark">
			6. series对象及DataFrame对象知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【目录】
文章目录 6. series对象及DataFrame对象知识总结1. 导入pandas库2. pd.Series创建Series对象2.1 data = 列表2.2 data = 字典 3. s1.index获取索引4. s1.value获取值5. pd.DataFrame()-创建DataFrame 对象5.1 data = 列表5.2 data = 嵌套列表5.3 data = 字典 6. df['列索引']获取特定列的数据7. 总结 【正文】 6. series对象及DataFrame对象知识总结 学习时间：20分钟。
1. 导入pandas库 # 导入pandas库并简写为pd import pandas as pd 2. pd.Series创建Series对象 【语法】
pd.Series(data, index) data是必需参数，表示要传递的数据。index是可选参数，用于自定义行索引。 data可以是列表、字典等。
2.1 data = 列表 # 导入pandas库并简写为pd import pandas as pd # 传入的数据为列表 data =["赵", "钱", "孙", "李"] index=['A','B','C','D'] s1 = pd.Series(data,index) print(s1) 【终端输出】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b74e64bef0a3e096032443cd68d5c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e1e2f01a093ae8c08da4c5fd7305d5/" rel="bookmark">
			yum 、rpm、yumdownloader、repotrack 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Linux 包管理器概述 rpm的使用：
rpm -ivh filename.rpm #这列出该packageName（包名）安装的所有文件列表。 rpm -ql packageName #查询已安装的该packageName的详细信息，包括版本、发布日期等。 rpm -qi packageName #列出该packageName安装的所有配置文件。 rpm -qc packageName rpm -Uvh filename.rpm rpm -e packageName rpm -qpi tree-1.6.0-10.el7.x86_64.rpm 的解释： #-q选项表示查询已安装的软件包， #-p选项指定要查询的软件包文件（在这种情况下是"tree-1.6.0-10.el7.x86_64.rpm"）。 #-i选项表示显示软件包的详细信息。 #该命令将显示有关已安装的"tree"软件包的各种详细信息，包括版本号、发布日期、文件依赖关系、安装路径等。 2 rpm的查询、升级与卸载命令 rpm查询
rpm -qa | grep httpd rpm -qi httpd rpm -ql httpd rpm -qc httpd rpm -qd httpd rpm -qR httpd rpm -qRp /media/cdrom/Packages/bind-9.9.4-61.el7.x86_64.rpm rpm -q httpd --scripts rpm升级/降级
升级：
降级：
3 rpm依赖关系问题及处理 rpm -ivh /media/cdrom/Packages/httpd-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07e1e2f01a093ae8c08da4c5fd7305d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1af32c41fdc77eb1660a410bda7865/" rel="bookmark">
			各种媒体视频和文件的http Content-Type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各种媒体视频文件的Content-Type
"application/x-apple-diskimage": "DMG",
"application/epub+zip": "EPUB",
"application/java-archive": "JAR",
"video/x-matroska": "MKV",
"text/html": "HTML|HTM",
"text/css": "CSS",
"text/javascript": "JS|JSON",
"text/mspg-legacyinfo": "MSI|MSP",
"text/plain": "TXT|SRT",
"text/srt": "SRT",
"text/vtt": "VTT|SRT",
"text/xml": "XML|F4M|TTML",
"text/x-javascript": "JS|JSON",
"text/x-json": "JSON",
"application/f4m+xml": "F4M",
"application/gzip": "GZ",
"application/javascript": "JS",
"application/json": "JSON",
"application/msword": "DOC|DOCX|DOT|DOTX",
"application/pdf": "PDF",
"application/ttaf+xml": "DFXP",
"application/vnd.apple.mpegurl": "M3U8",
"application/zip": "ZIP",
"application/x-7z-compressed": "7Z",
"application/x-aim": "PLJ",
"application/x-compress": "Z",
"application/x-compress-7z": "7Z",
"application/x-compressed": "ARJ",
"application/x-gtar": "TAR",
"application/x-msi": "MSI",
"application/x-msp": "MSP",
"application/x-gzip": "GZ",
"application/x-gzip-compressed": "GZ",
"application/x-javascript": "JS",
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1af32c41fdc77eb1660a410bda7865/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a795c2eb7016798ffb8f710114c978b/" rel="bookmark">
			mybatis-plus判断表的两个字段相等？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //判断两列相等 wrapper.apply("violation_amount = final_amount"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e40dc1235ef9b69e6782b4f4e350a173/" rel="bookmark">
			The differences of some purchased intangible assets
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The intangible assets created internally consists the following types:
Patents
Copyrights
Trademarks
Franchises
Licenses
Everything else is well understood, but the difference between a franchise and a license is a little difficult.
The main difference between franchising and licensing lies in the differences in brand authorization, use scope, authorization content, and focus. Franchising involves brand authorization and replication of business models, and is mainly applied in franchise stores or authorized operations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e40dc1235ef9b69e6782b4f4e350a173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a18de7fd7847208702bd0b9ce3148b/" rel="bookmark">
			Laravel 集合的使用 &amp; 集合的常用方法 &amp; 模型的数据集合 ⑩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@作者 : SYFStrive
@博客首页 : HomePage
📜： THINK PHP
📌：个人社区（欢迎大佬们加入） 👉：社区链接🔗
📌：觉得文章不错可以点点关注 👉：专栏连接🔗
👉 VUEJS（🔥） 👉 MYSQL（🔥） 👉 微信小程序（🔥） 👉 PHPMYSQL（🔥） 👉 UNIAPP开发（🔥） 目录 PHP LARAVEL 简介PHP LARAVEL 集合的使用 创建集合 &amp; 简单使用PHP LARAVEL 集合的常用方法 常用方法PHP LARAVEL 模型的数据集合 模型数据集合最后 ⡖⠒⠒⠒⠤⢄⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸ ⠀⠀⠀⡼⠀⠀⠀⠀ ⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢶⣲⡴⣗⣲⡦⢤⡏⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠋⠉⠉⠓⠛⠿⢷⣶⣦⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠘⡇⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⢰⠇⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⡴⠊⠉⠳⡄⠀⢀⣀⣀⡀⠀⣸⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠰⠆⣿⡞⠉⠀⠀⠉⠲⡏⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠈⢧⡀⣀⡴⠛⡇⠀⠈⠃⠀⠀⡗⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣱⠃⡴⠙⠢⠤⣀⠤⡾⠁⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⢀⡇⣇⡼⠁⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⣸⢠⣉⣀⡴⠙⠀⠀⠀⣼⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠈⠁⠀⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⣀⠤⠚⣶⡀⢠⠄⡰⠃⣠⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⢀⣠⠔⣋⣷⣠⡞⠀⠉⠙⠛⠋⢩⡀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀ ⠀⡏⢴⠋⠁⠀⣸⠁⠀⠀⠀⠀⠀ ⠀⣹⢦⣶⡛⠳⣄⠀⠀⠀⠀⠀ ⠀⠙⣌⠳⣄⠀⡇ 不能 ⡏⠀⠀ ⠈⠳⡌⣦⠀⠀⠀⠀ ⠀⠀⠈⢳⣈⣻⡇ 白嫖 ⢰⣇⣀⡠⠴⢊⡡⠋⠀⠀⠀⠀ ⠀⠀⠀⠀⠳⢿⡇⠀⠀⠀⠀⠀⠀⢸⣻⣶⡶⠊⠁⠀⠀ ⠀⠀⠀⠀⠀⢠⠟⠙⠓⠒⠒⠒⠒⢾⡛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⣠⠏⠀⣸⠏⠉⠉⠳⣄⠀⠙⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⡰⠃⠀⡴⠃⠀⠀⠀⠀⠈⢦⡀⠈⠳⡄⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⣸⠳⣤⠎⠀⠀⠀⠀⠀⠀⠀⠀⠙⢄⡤⢯⡀⠀⠀⠀⠀⠀⠀ ⠀⠐⡇⠸⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡆⢳⠀⠀⠀⠀⠀⠀ ⠀⠀⠹⡄⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣇⠸⡆⠀⠀⠀⠀⠀ ⠀⠀⠀⠹⡄⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡀⣧⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⢹⡤⠳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣷⠚⣆⠀⠀⠀⠀ ⠀⠀⠀⡠⠊⠉⠉⢹⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡎⠉⠀⠙⢦⡀⠀ ⠀⠀⠾⠤⠤⠶⠒⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠒⠲⠤⠽ 提示：以下是本篇文章正文内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a18de7fd7847208702bd0b9ce3148b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2e5318071eddbc5a734c663b86f2f4/" rel="bookmark">
			STM32读取GXHT30A模拟温湿度传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32读取GXHT30A模拟温湿度传感器 文章目录 STM32读取GXHT30A模拟温湿度传感器 前言一、GXHT30A的特点二、简介1.实物图2.电气参数 三、程序配置1.ADC配置2.读入数据并计算 总结 前言 `数字传感器现在应用越来越广泛，但在许多领域，模拟输出的传感器因为其简单，易用的特点还是广泛应用在很多行业中，例如家电等行业，中科银河芯的GXHT30A就是一款电压输出的模拟温湿度传感器。
提示：以下是本篇文章正文内容，下面案例可供参考
一、GXHT30A的特点 GXHT30A的封装和管脚兼容SHT30A传感器，并且其温度和湿度的输出电压都能根据需求进行调整，因此输出量也能做到和SHT30A兼容。
二、简介 1.实物图 2.电气参数 芯片支持的工作电压范围为2.2V到5.5V，温湿度的输出电压会根据工作电压不同而变化，只需将读取的电压值带入公式进行计算即可得出最终温湿度值。
而传感器的管脚顺序和另外一款数字输出的温湿度传感器GXHT30匹配，在某些情况下两颗芯片的PCB能通用。
三、程序配置 1.ADC配置 配置DMA方式读取传感器ADC值：
/*配置采样通道端口 使能GPIO时钟	设置ADC采样PA0端口信号*/ void ADC1_GPIO_Config(void) { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 ; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;	//GPIO设置为模拟输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 ; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;	//GPIO设置为模拟输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); } /*配置ADC1的工作模式为MDA模式 */ void ADC1_Mode_Config(void) { DMA_InitTypeDef DMA_InitStructure; ADC_InitTypeDef ADC_InitStructure;	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); //使能MDA1时钟 /* DMA channel1 configuration */ DMA_DeInit(DMA1_Channel1); //指定DMA通道 DMA_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d2e5318071eddbc5a734c663b86f2f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ef92d7e4e1007569f0d818b4f861ad/" rel="bookmark">
			驱动兼容18b20系列的单总线温湿度传感器GXHT3W
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 单总线 一、GXHT3W简介 GXHT3W是北京中科银河芯设计生产的一款使用单总线协议通信的温湿度传感器，区别于IIC和SPI等常用接口的地方在于单总线支持两线/三线通信，通信距离远，在主机驱动能力足够的情况下可达数百米，同时，总线上可搭载多个传感器。
在驱动程序方面，GXHT3W和18b20系列的读写以及复位时序兼容，也有64位ID，与18b20不同的地方只有读取的数据多了湿度数据，以及计算公式不同。
二、参数简介 1.工作参数 电气特性参数
硬件电路
三线制电路
当需要驱动更多传感器或者在长距离环境下使用时，可以增加强驱动电路来辅助DQ上拉和下拉。
三、驱动程序 1.读写时序 GXHT3W有IIC和单总线两种通信方式，其中IIC通信和GXHT3X系列相同，兼容SHT3x系列，因此在这就对单总线通信时序做一些简单介绍。使用单总线通信时，用过18b20的朋友可以直接使用18b20程序驱动，下面做一个使用18b20程序驱动的简单示例。
初始化时序代码如下（示例）：
//直接使用18b20的复位程序 static void GX18B20_Rst(void) {	GX18B20_Mode_Out_PP(); GX18B20_DQ_0; delay_us(750); GX18B20_DQ_1; delay_us(15); } static uint8_t GX18B20_Presence(void) { uint8_t pulse_time = 0; GX18B20_Mode_IPU(); while( GX18B20_DQ_IN() &amp;&amp; pulse_time&lt;100 ) { pulse_time++; delay_us(1); }	if( pulse_time &gt;=100 ) return 1; else pulse_time = 0; while( !GX18B20_DQ_IN() &amp;&amp; pulse_time&lt;240 ) { pulse_time++; delay_us(1); }	if( pulse_time &gt;=240 ) return 1; else return 0; } 复位的具体时间只要满足复位时序图的要求均可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25ef92d7e4e1007569f0d818b4f861ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b35fa98c29e9bfe609a484deec68df/" rel="bookmark">
			贝叶斯网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 贝叶斯网络(Bayesian network)，又称为信念网络(Belief network) 。是一种通过有向无环图(Directed acyclic graph, DAG)表示一组随机变量及其条件依赖概率的概率图模型。概率图中，节点表示随机变量，有向边表示随机变量间的依赖关系，条件概率表示依赖关系的强度。没有父节点的节点用先验概率表达信息。两个节点若无连接则表示相互独立的随机变量。贝叶斯网络中的节点可以表示任意问题，丰富的概率表达能力使能较好地处理不确定性信息或问题。贝叶斯网络中所有节点都是可见的，并且节点间的因果关系可以非常直观地观察到。这些特性都使得贝叶斯网络在众多智能系统中有相当重要的应用。
贝叶斯定理 贝叶斯公式:假设 x x x为属性， y y y为类别
p ( y ∣ x ) = p ( x ∣ y ) p ( y ) p ( x ) p ( y ) 为先验概率， p ( y ∣ x ) 为后验概率 从先验概率 p ( y ) 求出后验概率 p ( y ∣ x ) p(y|x)=\frac{p(x|y)p(y)}{p(x)}\\p(y)为先验概率，p(y|x)为后验概率\\ 从先验概率p(y)求出后验概率p(y|x) p(y∣x)=p(x)p(x∣y)p(y)​p(y)为先验概率，p(y∣x)为后验概率从先验概率p(y)求出后验概率p(y∣x)
朴素贝叶斯 ​ 朴素贝叶斯分类模型是一种简单的构造分类器的方法。朴素贝叶斯分类模型是将问题分为特征向量和决策向量两类，并假设问题的特征向量都是相互独立地作用于决策向量的，即问题的特征之间都是互不相关的。尽管有这样过于简单的假设，但朴素贝叶斯分类模型能指数级降低贝叶斯网络构建的复杂性，同时还能较好地处理训练样本的噪声和无关属性。
​ 简单来说，朴素贝叶斯分类就是：通过某对象的先验概率利用贝叶斯公式计算其后验概率，即该对象属于某一类概率，选择后验概率最大的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85b35fa98c29e9bfe609a484deec68df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b8acd46fb6fd8556a6e0eb29854747/" rel="bookmark">
			Vue笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章：Vue环境搭建 1.搭建Vue环境 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 1.引入Vue.js--&gt; &lt;script src="1.vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; Vue.config.productionTip=false//阻止Vue在启动时 生成生产提示 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.helloWorld(插值语法) &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 1.引入Vue.js--&gt; &lt;script src="1.vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--2.准备好一个容器--&gt; &lt;div id="root"&gt; &lt;!-- 使用插值语法：插入一个值 两组花括号--&gt; &lt;h1&gt;hello {{name}} &lt;/h1&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip=false;//设置关闭生产者提示 // 全局多了Vue这个构造函数 因此可以 使用new去用 const i=new Vue({ el:"#root", //对象第一个属性：匹配容器和实例 el用于指定当前vue实例为那个容器服务 值通常为css选择器字符串 // el:document.getElementById("root")//也可以这样子 data:{ // 在来个对象 对象里面可以存任意数据类型的对象 /* 因此data中用来存储数据 数据提供给data使用 * 值 我们先暂时写成对象的形式 {} * * */ name:'计算机科学与技术' } })//创建Vue实例 参数传递一个 叫做配置对象 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66b8acd46fb6fd8556a6e0eb29854747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e5c3a98e285773d57de103436b9bd6d/" rel="bookmark">
			ROS 2官方文档（基于humble版本）学习笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS 2官方文档（基于humble版本）学习笔记（一） 一、安装ROS 2二、按教程学习1.CLI 工具配置环境使用turtlesim，ros2和rqt安装 turtlesim启动 turtlesim使用 turtlesim安装 rqt使用 rqt重映射关闭turtlesim 由于市面上专门讲ROS 2开发的书籍不多，近期看完了《ROS机器人开发实践》其中大部分内容还是基于ROS 1写的，涉及topic，service，action等一些重要的概念，常用组件，建模与仿真，应用（机器视觉，机器语音，SLAM，机械臂），最后一章写了ROS 2的安装，话题通信和服务通信的示例。总觉得不是太系统，于是决定按着ROS官方文档学习ROS 2，把学习过程中的要点记录下来。
一、安装ROS 2 ​官方提供了部分操作系统平台的ROS 2的二进制安装包，分别为Ubuntu Linux、RHEL、Windows，不同ROS 2的版本对应的Linux版本也略有不同。
截至目前有两个ROS 2的版本还没有到项目终止日期（EOL end-of-life)，一个是最新的发布版本为Iron Irwini，发布时间是2023年5月23日，EOL date是2024年11月，另一个是Humble Hawksbill，发布时间是2022年5月23日，EOL date是到2027年5月，比较后我选择了Humble这个版本来学习。
为了方便，我选择了直接安装二进制安装包，首先在虚拟机上安装了Ubuntu 22.04（Jammy）,
然后按照官方文档一步一步安装即可。
命令整理如下：
​ #--------准备工作-------- #1.确保有universe源 sudo apt install software-properties-common sudo add-apt-repository universe #2.获取ROS 2 GPG key以便在接下来的apt命令中使用 sudo apt update &amp;&amp; sudo apt install curl -y sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg #3.将ROS仓库加入sources list列表 echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e5c3a98e285773d57de103436b9bd6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8908bec1a3eba8af00472e7b213b309/" rel="bookmark">
			GSON基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GSON基本用法 GSON 是 Google 提供的一个用于在 Java 对象和 JSON 数据之间进行转换的开源库。以下是使用 GSON 解析 JSON 数据的示例：
首先，你需要在项目中添加 GSON 的依赖。你可以在 pom.xml 文件中添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.8&lt;/version&gt; &lt;!-- 请根据需要选择版本 --&gt; &lt;/dependency&gt; 然后，你可以按照以下步骤使用 GSON 解析 JSON 数据：
创建一个包含要解析 JSON 数据的类。 public class Person { private String name; private int age; // Getter and setter methods } 使用 GSON 创建一个 Gson 实例，然后使用它来解析 JSON 数据。 import com.google.gson.Gson; public class GsonParserExample { public static void main(String[] args) { String json = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8908bec1a3eba8af00472e7b213b309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c1e8e88e5ccd36e50ba09dabd64ccc4/" rel="bookmark">
			【免配置】Qt的mingw使用编译opencv库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【免配置】Qt的mingw_32/64使用编译opencv库 网上在qt中使用mingw编译器配置opencv的时候，通常需要使用cmake编译工具，进行预先编译，步骤比较繁琐，这里推荐一个捷径，直接使用前人编译好的opencv库即可，避免自己再去画时间造轮子。
案例工程文件仓库
本人测试了4.0.1在qt中可以使用debug和release运行程序，但是4.5.2只能使用release运行程序
步骤1：下载对应编译完成的opencv库文件
仓库地址 https://gitcode.net/mirrors/huihut/opencv-mingw-build
将下载完成的压缩包解压到Qt安装目录的同级目录下：
步骤2：添加系统环境变量
注意：在添加环境变量的时候，如果电脑中有多个版本的opencv库， 则一定要将此版本的opencv版本放置在其他opencv版本的前面，
环境变量配置完成之后，可以重启电脑一下。
步骤3：添加Qt测试工程
注意：这里的路径一定要和自己压缩包解压的路径以及环境变量中的路径一至
INCLUDEPATH += E:/Qt/OpenCV-MinGW-Build-OpenCV-4.0.1-x64/include E:/Qt/OpenCV-MinGW-Build-OpenCV-4.0.1-x64/include/opencv2 LIBS += E:/Qt/OpenCV-MinGW-Build-OpenCV-4.0.1-x64/x64/mingw/lib/lib*.a 下面是工程中需要的文件
widget.h中配置如下
#ifndef WIDGET_H #define WIDGET_H #include &lt;QWidget&gt; #include &lt;QFileDialog&gt; #include &lt;QMessageBox&gt; #include &lt;opencv2/opencv.hpp&gt; using namespace cv; QT_BEGIN_NAMESPACE namespace Ui { class Widget; } QT_END_NAMESPACE class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); Mat img_input; //原始图片 Mat gray_img; //灰度图片 int isGray = 0; //判断是否设置为灰度图 private slots: void on_pushButton_clicked(); void on_checkBox_clicked(); private: Ui::Widget *ui; }; #endif // WIDGET_H widget.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c1e8e88e5ccd36e50ba09dabd64ccc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e93a7b5c4a53d6cd697709ce052e20/" rel="bookmark">
			机器学习笔记之正则化(一)拉格朗日乘数法角度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习笔记之正则化——拉格朗日乘数法角度 引言回顾：基于正则化的最小二乘法正则化描述正则化的优化对象常见的正则化方法 正则化角度处理神经网络的过拟合问题场景构建最优模型参数的不确定性最优模型参数不确定性带来的问题约束模型参数的方法从图像角度观察从拉格朗日求解角度观察 关于常数 C \mathcal C C 引言 从本节开始，将介绍正则化，并从拉格朗日乘数法角度进行观察。
回顾：基于正则化的最小二乘法 对应《深度学习》(花书) P147 7.3 正则化与欠约束问题
在处理线性回归任务过程中，我们以 L 2 L_2 L2​正则化( Regularization \text{Regularization} Regularization)为例介绍了正则化在最小二乘法损失函数的作用。
关于最小二乘估计关于权重 W \mathcal W W的矩阵形式表达公式表示如下：
{ L ( W ) = W T X T X W − 2 W T X T Y + Y T Y W ^ = arg ⁡ min ⁡ W L ( W ) \begin{cases} \mathcal L(\mathcal W) = \mathcal W^T\mathcal X^T\mathcal X \mathcal W - 2 \mathcal W^T\mathcal X^T\mathcal Y + \mathcal Y^T\mathcal Y \\ \hat {\mathcal W} = \mathop{\arg\min}\limits_{\mathcal W} \mathcal L(\mathcal W) \end{cases} ⎩ ⎨ ⎧​L(W)=WTXTXW−2WTXTY+YTYW^=Wargmin​L(W)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83e93a7b5c4a53d6cd697709ce052e20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c107db4010850ef8545068bb0260f261/" rel="bookmark">
			【Linux】序列化和反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 定义利用 Json 实现序列化反序列化Json 的认识Jsoncpp 库的下载与认识实现序列化实现反序列化 在网络编程中，直接使用 结构体 进行数据传输会出错，因为本质上socket无法传输结构体，我们只有将结构体装换为字节数组，或者是字符串格式来传输，然后对端主机收到了数据，再将其转化为结构体，这就是序列化和反序列化的过程！
定义 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。
序列化主要有两个用途：
把对象的字节序列永久保存到硬盘上，通常存放在一个文件中（序列化对象）在网络上传送对象的字节序列（网络传输对象） 实际上就是将数据持久化，防止一直存储在内存当中，消耗内存资源。而且序列化后也能更好的便于网络运输何传播。
如下，在网上找到的一张图片，可以很好地描述序列化和反序列化，及其作用（以 java 对象为例）。
利用 Json 实现序列化反序列化 Json 的认识 json 是一种数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。
例如：小明同学的学生信息:
char name = "小明"; int age = 18; float score[3] = {88.5, 99, 58}; 则json这种数据交换格式是将这多种数据对象组织成为一个字符串：
[ { "姓名" : "小明", "年龄" : 18, "成绩" : [88.5, 99, 58] }, { "姓名" : "小黑", "年龄" : 18, "成绩" : [88.5, 99, 58] } ] json 数据类型：对象，数组，字符串，数字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c107db4010850ef8545068bb0260f261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9841053ca2faae44d7aebfa92ee9718c/" rel="bookmark">
			一篇关于LLM指令微调的综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习自然语言处理 原创
作者：cola
指令微调(IT)是提高大型语言模型(LLM)能力和可控性的关键技术。其本质是指在由(INSTRUCTION, OUTPUT)对组成的数据集上以监督的方式进一步训练LLM的过程，它弥合了LLM的下一个词预测目标与用户让LLM遵循人类指令的目标之间的差距。这篇文章对现有研究进行了系统的回顾、包括IT的一般方法、IT数据集的构建、IT模型的训练、以及不同模式，领域和应用的应用。
论文：
Instruction Tuning for Large Language Models: A Survey
地址：
https://arxiv.org/pdf/2308.10792.pdf
背景 近年来LLMs取得了显著的进展，例如GPT3、PaLM以及LLaMA等大语言模型在广泛的自然语言处理任务上都表现出了令人深刻的能力。LLMs的一个主要问题是训练目标和用户目标之间的不匹配。通常LLM是在大型预料上通过最小化上下文词预测误差进行训练，而用户希望模型有效且安全的遵循他们的指令。
为了解决这个不匹配，提出了指令微调（IT）来增强模型的能力和可控性。IT使用(INSTRUCTION, OUTPUT)对进一步训练LLM，其中INSTRUCTION表示模型的人工指令，OUTPUT表示遵循INSTRUCTION的期望输出。IT有三个好处：
弥合了LLM的下一个此预测目标与用户指令目标之间的差距；
IT允许更可控和预测的模型行为。指令用于约束模型的输出，使其与期望的响应特征或领域知识保持一致，为人类干预模型的行为提供了一个渠道；
计算效率更高。
目前，IT面临的挑战：
制作高质量的指令。现有的指令数据集通常在数量、多样性和创造力方面有限；
IT可能只会改善那些在IT训练数据集中得到大量支持的任务；
有人认为IT只捕获表面的模式和样式(例如，输出格式)，而不是理解并学习任务。
方法 这一小节主要介绍使用指令调优的pipeline。
指令数据集的构造 指令数据集中的每个实例由三个元素组成:一个指令，它是指定任务的自然语言文本序列(例如，为XX写一封感谢信给XX，写一篇关于XX主题的博客，等等)；为上下文提供补充信息的可选输入；以及基于指令和输入的预期输出。
通常构造指令数据集有两种方法：
来自带注释的自然语言数据集的数据集成。在这种方法中，通过使用模板将文本标签对转换为(INSTRUCTION, PUT)对，从现有的带注释的自然语言数据集中收集INSTRUCTION, TPUT)对。Flan和P3数据集是基于数据集成策略构建的。
使用LLM生成输出:使用诸如GPT-3.5-Turbo或GPT4之类的LLM收集输出。指令可以来源于人工收集或基于使用LLM的少量手写指令进行扩展。接下来，将收集到的指令馈送到LLM以获得输出。使用这种方法生成了instructwind和self - directive等数据集。
对于多回合会话IT数据集，可以让LLM扮演不同的角色(用户和AI助手)来生成会话格式的消息。
指令微调 基于收集到的IT数据集，可以以完全监督的方式直接对预训练模型进行调优，在给定指令和输入的情况下，通过顺序预测输出中的每个标记来训练模型。
数据集 这一小节将介绍一些广泛应用的指令调优数据集。
Natural Instructions Natural Instructions是一个人工制作的英语指令数据集，由193K个实例组成，来自61个不同的NLP任务。数据集由“instructions”和“instances”组成。“instructions”中的每个实例都是一个任务描述，由7个部分组成:title、definition、emphasis/caution、things to avoid、prompt、positive example、negative example。
“Instances”由(“input”，“output”)对组成，它们是正确遵循给定指令的输入数据和文本结果。
作者通过参考数据集标注指令文件收集“instructions”。接下来，作者通过将所有NLP数据集中的数据实例统一为(“input”,“output”)对来构建“instances”。
P3 P3(Public Pool of Prompts)是一个整合170个英语NLP数据集和2052个英语提示构建的指令微调数据集。提示是将传统NLP任务中的数据实例(例如，问题回答、文本分类)映射到自然语言输入输出对的函数。
P3中的每个实例都有三个组成部分:“inputs”、“answer_choices”和“targets”。“inputs”是用自然语言描述任务的文本序列(例如，"If he like Mary is true, is it also true that he like Mary’s cat?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9841053ca2faae44d7aebfa92ee9718c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206435c7dd0ddd744718cd7f4f098c27/" rel="bookmark">
			微信小游戏上半年流量变现增长30%，“小程序”游戏迎来爆发前夜？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在新品批量扎堆出现后，游戏行业又卷出了新的有趣局面。
昨日（8月27日），以“星穹铁道/黑悟空，中国游戏行业未来向何方?”为辩题的华语辩论赛落幕，吸引大批游戏乐子人前来分享观点。最终反方观点“当前中国游戏行业更需要《黑神话:悟空》(这类3A大作)”，以4:1的比分拿下了比赛，有趣的是，现实却正呈现出相反的局面。
《黑神话:悟空》是由游戏科学开发的一款以中国神话系角色扮演游戏，受业内瞩目的国产3A大作，在近日的科隆游戏展现场，其试玩间一度挂着“排队需等待约300分钟”的牌子。而手游《崩坏:星穹铁道》则是在今年梦幻开局，为米哈游守住了“二次元”擂台，首月流水预估超12亿元。按说二者从研发周期到品类风格甚至受众群体都没法作为对比。
当市场数年如一日地渴求着3A大作的同时，轻量化游戏却正成为各家的重要布局领地。近日，腾讯、网易、等游戏业务存在感明显的互联网企业及游戏公司相继发布财报，娱乐独角兽观察到，除了各有侧重的产品布局，小游戏正在成为新的重点关键字。
一面是手游市场也未能逃过的唯流量论:游戏行业被多重因素牵制数年，先做“赚钱游戏”吃饱饭才是紧要;另一方面则是科技崛起，头部厂商为主的游戏公司对大模型、新技术的痴迷与耕作，让行业似乎几个月就要迎来一次技术变革。根据最新厂商动向及已披露的头部游戏公司财报，我们或许能窥见新的潮水走向。
新品扎堆内卷，海外渐入佳境 恢复版号后，在长达一年的时间里，游戏公司财报关键字都围绕在旧游营收、新品表现、海内外市场以及AI新动向，今年的二季度财报也不例外。
腾讯方面，海外营收的增长已经成为这两年的老生常谈。据统计，自腾讯2019年第三季度单独划分出国际市场数据后，腾讯国际市场游戏收入已从30亿元上涨至如今的127亿元，约是国内市场收入的近四成。2022年，腾讯副总裁马晓轶曾公开发言:以前他只花20%的时间在海外，现在他把60%的时间花在了全球市场。
海外市场的迅猛增长像极了2016年左右的遍地生机的国内游戏大环境，除了前期一片湛蓝的拓展空间外，这很大程度上得益于厂商对产品进行的本土化处理。腾讯在国内的社交产品网大大提振着玩家游玩过程中产生的各类诉求，遗憾的是，这一系列链条与海外玩家的文化喜好与消费习惯、海外的运营环境并不适配。
反馈到数据上也愈来愈明显。财报显示，腾讯游戏2023年第二季度收入为445亿元，同比增长5%。其中，国内市场游戏收入318亿元人民币，与去年同期持平，环比下降9.4%，但国际市场游戏收入127亿元，同比增长19%。腾讯的《PUBG MOBILE》《胜利女神:NIKKE》在海外表现可圈可点。
尽管在海外方面渐入佳境，但腾讯在游戏产品方面并未出现新的市场撼动者。上半年被市场寄予厚望的《黎明觉醒:生机》《合金弹头:觉醒》《白夜极光》表现平淡。反观同期米哈游新作《崩坏:星穹铁道》、弯道超车的休闲类手游《蛋仔派对》以及舆论话题不断赚足眼球的《逆水寒手游》，一度在免费游戏榜单前10徘徊，直接改写了被《王者荣耀》《和平精英》等“现金牛”长久霸占的手游榜单。
就目前来看，腾讯游戏没能卷过其他大厂及中生代游戏公司，在新品上承压。对此其曾于财报电话会上表示，在第一季度，腾讯游戏发布大量的传统优势游戏的商业内容，使游戏总收入显著增加，但二季度进入了一个暂停期，并计划在第三季度恢复商业内容的发布。
有人欢喜有人忧，腾讯新品表现不出色，网易方面利润率增长。网易二季度净收入240亿元，同比增长3.7%;取得净利润90亿元，同比增长67%。主要收入来自于游戏及相关增值服务:创造了188亿元收入，同比增长3.6%，占总收入比78.3%。
一方面是网易今年终止了与暴雪的代理运营，一定程度上提升了利润率。另一方面，新产品表现强劲，在线游戏收入的增加也极大地提振了利润增长。如被称作“小学生收割机”的手游《蛋仔派对》成为网易有史以来日活用户数最高的游戏、《逆水寒手游》上线首月超过4000万玩家，《巅峰极速》也短暂地冲入畅销榜首。后两者的成绩单将于下季度财报显示。
网易的表现在游戏行业整体营收增速放缓的背景下并不容易，在其财报中，另外一个重点是大刀阔斧地砸研发。
AI大模型“上任”，“技术流”的崛起 财报显示:今年二季度，网易研发投入39亿元。而近五年，网易已累计投入研发近600亿元，平均研发投入强度15%。截至目前，网易专利申请公开量超1万件，授权专利超4000件，集中在人工智能、区块链、音视频等数字产业关键技术领域。
目前头部厂商中，网易游戏算是高调“技术流”。以其今年暑期上线的新游为例，《逆水寒手游》宣称是全球首个大规模落地自研AI玩法。网易高管曾介绍:AI在《逆水寒》手游中的应用，主要包括提升研发效率和用户体验两方面。一方面，《逆水寒》手游在美术生产环节、程序开发等环节都借助AI提升效率。更重要的是，整个游戏的研发逻辑从“游戏+AI”转变成“AI+游戏”，在AI大模型的基础上设计、研发了玩家从角色选择到游戏交互的全环节，丰富玩家开放世界体验。
另外一款新游《巅峰极速》对标3A游戏使用了大量在主机上先进的渲染技术，网易近期公布的《代号:无限大》也结合了包括大数据集成、人工智能等的新技术尝试。网易高管在财报会上也提及，希望能巩固其在AI智能游戏上的积累。此前《蛋仔派对》新增AI辅助地图创作功能，目前创作者人数超2600万。
财报中，网易提到，二季度以来，网易技术团队斩获CVPR、IJCAI、ACM MM等国际AI顶会竞赛5个冠军，相关成果已应用于原画、建模、动画合成等游戏美术资产生产环节，大幅缩短研发周期，降低制作成本。同时，基于自研大模型等AI技术，网易游戏行业首创了智能 NPC互动、AI文字捏脸、AI换装等创新玩法。如果说内容产出与技术流正在成为“正确方向”，那么小程序小游戏似乎正在成为双重加持的“天选之子”。
双端互补，小游戏成为第二曲线? 小游戏将为行业带来的增长点令各大厂商展开了充满想象力的尝试，娱乐独角兽观察到，厂商对于小程序游戏的应用，目前主要有几种形式。
其一是版本前置，以轻量级的游戏体验承载着主要产品的宣发动作。如近期，吉比特待发游戏中关注度较高的一款放置RPG手游《勇者与装备》（代号BUG），率先上线了小程序版本，引发业界探讨，算是开创了游戏产品上线的先河。
吉比特董事长、总经理卢竑岩表示，此举是出于业务上的考虑，不仅是《勇者与装备》，其他项目也会考虑发行小游戏版本。“具体还是要看项目情况，因为如果不是轻量级的产品，可能需要针对小游戏版本裁减掉一部分内容，还需要耗费一些时间成本。”
其二是作为社交载体，参考此前引全民闯关的《跳一跳》《羊了个羊》等，在引爆社交圈后，掀动全民熬夜通关效应。小程序小游戏的社交属性在腾讯财报中也有所反馈，自去年开放了微信小程序游戏与抖音之间互通的腾讯，也品尝到小游戏业务的果实。财报显示:第二季度腾讯社交网络收入为297亿元，同比增长2%，主要得益于小游戏及音乐付费会员服务收入的增长。
在业绩会上，腾讯高管表示，随着新的休闲游戏体验出现，小游戏平台增长的速度还会越来越快，仍有巨大的发展潜力。腾讯未来还会在小游戏领域持续投资。
其三是提振存量市场，以小游戏的形式焕新大量不愠不火的游戏产品，抑或是帮助其完成第二增长曲线。抖音小游戏也于前段时间在ChinaJoy上举办了宣讲会，重点强调平台的用户增长和给开发者的让利，吸引更多开发者为抖音平台开发小游戏，繁荣平台的产品生态。
从移植到作为首发、宣发平台，小程序小游戏的优势明显，低于app的买量成本、转化链路短、用户基数广等优势，迅速吸引了大量开发者入局投放。据DataEye数据，2023年上半年微信小游戏素材投放量环比2022年下半年增长5倍，小程序游戏承载的功能也将增加。
不仅于此，技术市场也在给予小游戏赛道积极反馈。近日，Unity中国正式推出Unity中国版引擎——团结引擎，针对性布局小游戏赛道。“对于游戏开发者，团结引擎可以让开发者轻松地将其他平台的游戏转换为微信小游戏，并针对性地推出了一站式微信小游戏解决方案。”Unity高管透露。
如今，大环境下是版号总量调控、行业积压良久后迎来骤然爆发，致使游戏新品又从数量、质量卷到宣发战术，市场将筛选出大批存量游戏产品，而小游戏平台或许能够让这些产品迸发出新的可能性，可以让这些存量游戏找到新的收入来源。微信游戏已有4亿月活跃用户、30万游戏开发者。据微信小游戏团队数据，上半年小游戏流量变现和广告推广规模均实现超30%增长。小游戏距离爆发前夜，将不会太远。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa48aaae6819213c52b381d22bae4451/" rel="bookmark">
			Segment Routing原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以上内容均属原创，如有不详或错误，敬请指出。 本文作者： 坏坏 本文链接： http://t.csdn.cn/2fUE5 版权声明： 本博客所有文章除特别声明外，如需转载，请联系作者注明出处并附带本文链接！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6762558b24f5aced38c02f6411e64301/" rel="bookmark">
			Flask Modules - How to connect to MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Establish a connection between Pycharm and MySQL.
# Configure the "SQLALCHEMY_DATABASE_URI" argument with all the required information. # This argument is used to specify the SQLAlchemy database connection URI. # Here, we construct the database connection URI as a MySQL connection string, # including the username, password, hostname, port, database name, and character set # setting. app.config['SQLALCHEMY_DATABASE_URI'] = f"mysql://{USERNAME}:{PASSWORD}@{HOSTNAME}:{PORT}/{DATABASE}?charset=utf8mb4" # Utilize 'SQLAlchemy' to alias 'app' as 'db'. db = SQLAlchemy(app) # Create an application context using app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6762558b24f5aced38c02f6411e64301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f695ac1c1937a9f258b5db600c6370a3/" rel="bookmark">
			Cadence Allegro（1）原理图设计——建立单逻辑器件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、选择菜单 “File—New—Library ”，出现如下图所示界面。
2、 将“libraryl .olb” 另存到自己的文件夹，取名为 “01_Connector”（可以取其他名，建议按照类别，方便后期使用），再来新建器件，如下图所示。
3、右击 “C:\Users\Desktop-ASFX\Desktop\candence\SCH_LIB\01_Connector.OLB”，选择 “New Part ”，如下图所示。
4、单击 “OK ” 按钮，进入绘制界面。
5、选择菜单栏 “ Place—Rectangle”或边框放置栏 ，如图。
画出合适大小框，然后通过右键选择 “End Mode” 结束命令。 说明：初次画好后，选中矩形框后，鼠标按住边缘，是可以调整大小的。
6、放置引脚，选择菜单 “Place—Pin...”, 出现的界面如图。
Name 处填上引脚名；
Number 处填上引脚号；其他保持默认即可。
设置引脚形状：
Clock：表示该引线为时钟信号。
Dot：表示“非”。 Dot -Clolk：表示经“非”作用的时钟信号。
Line：一般引线；其长度为三个格点间距。
Short：表示短引线。其长度为一个格点间距。
Short Clock：为短引线的时钟信号。
Short Dot：为短引线的“非”。
Short Dot Clock：为短引线的“非”形式时钟信号。
Zero Length：表示长度为零的引线。一般用于表示“电源”和“地”引线。
3 State：三态引线。该引线可能为低电平、高电平和高阻三种状态。
Bidirectional：双向信号引线，既可以起输入作用也可以起输出作用。
Input：输入端引线。
Open Collector：集电极开路输出端引线。
Open Emitter：发射极开路输出端引线。
Output：输出端引线。
Passive：无源器件的引线。
Power：电源引线和地引线。
Width：指定该引线信号是一般信号 “Scalar ” 还是总线信号 “Bus”。
7、设置好后，单击 “OK ” 按钮，在页面上放置即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f695ac1c1937a9f258b5db600c6370a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4bea1feb46edd2c71b658efe59090a/" rel="bookmark">
			私有化部署无忧企业文档2.1.7版本功能清单已更新！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无忧企业文档是软开企服研发的一款基于云端的在线文档管理工具，适用于团队内部协作、知识管理、项目管理等多个领域。与其他在线文档工具相比，无忧企业文档更注重团队协作和安全性，适合企业和团队使用。并且它还提供了丰富的API接口，方便与企业现有系统进行集成，实现数据的互通和流程的优化。
随着时间的沉淀以及众多用户的支持，无忧企业文档一直在不断的成长，经过多个版本的迭代，目前已迭代到2.1.7版本，接下来看看这个版本拥有哪些功能。
功能清单 无忧·企业文档功能清单V2.1.7
功能模块
功能名称
功能点
描述
备注
首页
自定义首页
首页配置
可通过拖拉拽的方式自定义配置首页风格和文档库
所有文库
所有文库
查看所有文库，包含私有、企业、全网级文库及对应文档。
具有查看权限
我的文库
我的文库
查看该角色创建的文库。
我的收藏
收藏信息
展示该角色所收藏的文档。
取消收藏
取消收藏并去除对应收藏记录。
常用文档
常用文档
展示该角色最近新增/修改的文档，可快速链接进入文档预览页。
模板市场
模板市场
展示后台配置的模板信息，用户选择模板后，可快速创建该文档。
文档工具
文档转换
支持选择本地和系统中文件，将文件转换为其他格式
OCR识别
支持选择本地和系统中文件，识别图片文字内容。
文档合并
支持选择本地和系统中文件，将多个文件内容合并为一个文件。
回收站
删除信息
展示该角色删除的文档信息。
恢复
将删除后的文档恢复至对应文库中。
彻底删除
彻底删除回收站内的文档。
文库管理
基础设置
文库封面
自行选择系统提供的多种文库封面。
文档信息
输入文档名称及文档介绍信息。
权限设置
共享设置
可设置文档为私有级或企业级、全网级。
成员权限
选择文库人员，并对该人员绑定角色，不同角色拥有不同操作权限。
高级设置
文库转移
可将文库转移给其他人管理。
消息设置
文库动态提醒
开启推送动态消息后可进行配置消息通知。
消息通知配置
选择对应事件及消息模板，完成消息发送。
下载
文库下载
可将文库中文档以压缩包的方式下载至本地中。
文档首页
文库信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b4bea1feb46edd2c71b658efe59090a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bd0fad961fb7b51165f28abd0b6ed07/" rel="bookmark">
			vue项目中使用开源Vditor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vditor 是一款所见即所得编辑器，支持 Markdown。
支持多种前端框架 这里介绍在vue中使用包括编辑所见即所得模式，以及仅仅预览展示 更多细节和用法请参考 Vditor - 浏览器端的 Markdown 编辑器，谢谢 ❤️
所见即所得（编辑+预览状态）教程 首先我们需要在html中添加一个有id的容器放置Vditor ，如果你也需要大纲 那在添加一个放置大纲的容器很有必要。
接着我们在script 中，引入它的实例和样式（确认路径）
import Vditor from 'vditor' import 'vditor/dist/index.css' 同时在你的 data中声明工具栏变量和接手vdtor的实例变量 toolbar: [], contentEditor: {} // Vditor实例 然后在挂载时，即可声明vditor了 关于option其他说明 这段内容展示了在所见即所得，比如：
除了toolbar 我们注意还有其他的配置comment 以及cache，cache中的after是实时保存钩子函数option链接 - [超级链接](https://ld246.com/article/1549638745630/comment/1681288989528#options-comment) 仅预览展示模式 在上文中提及如果只预览，那么我们如何使用Vditor ？
NOTE:
通常markdown解析的东西很多比如vue-markdown，可依据返回值灵活使用vditor也可以自己解析 预览 雷同点💢 和上文一样 也需要盒子放置markdown内容，如果需要大纲预览 这时候需要一个盒子放大纲。
同时也需要引入❤️
import Vditor from ‘vditor’
import ‘vditor/dist/index.css’
注意💋 如果你要使用大纲，那挂载时，即可声明initoutline函数了。
1,需要初始化获取后端的数据
2,然后调用vditor的预览api
如下 这里挂载了id为preview和outline的两个dom，同时渲染了后端返回值，渲染结束后时刻待执行着initoutline函数
官网地址
NOTE: 这里很容易出现一个问题就是 父组件设置滚动会触发不了initoutline，需要注意！
同时大纲和内容的联动 标记高亮色其实是自己写上去的😤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bd0fad961fb7b51165f28abd0b6ed07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c07b56bb003d7d7218bc8bab3c2c8289/" rel="bookmark">
			蓝易云：使用dbeaver连接MongoDB教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 DBeaver 连接 MongoDB 的教程如下：
首先，确保已经安装了 DBeaver 工具。你可以从 DBeaver 官方网站（DBeaver Community | Free Universal Database Tool）下载适用于你的操作系统的安装包，并按照安装向导进行安装。打开 DBeaver 工具，并点击 "新建连接"。 在连接配置页面，选择 "MongoDB" 作为数据库类型，并填写以下信息：
主机：MongoDB 服务器的主机名或 IP 地址。端口：MongoDB 服务器的端口，默认为 27017。用户名和密码：MongoDB 数据库的登录凭据，如果启用了身份验证。认证数据库：用于身份验证的数据库名称，默认为 "admin"。连接方式：选择 "直接连接"。点击 "测试连接" 按钮，确认连接配置是否正确。点击 "确定" 保存连接配置。在 DBeaver 工具的导航面板中，你将看到已创建的 MongoDB 连接。展开连接，可以看到数据库和集合。双击要查询的集合，DBeaver 将显示该集合中的数据。你可以执行 SQL 查询、添加、更新和删除数据等操作。 通过上述步骤，你可以使用 DBeaver 工具连接到 MongoDB 数据库，并对数据进行管理和查询。
希望以上回答对你有所帮助。如果还有其他问题，请随时提问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fcb724c9975c3b464214ddef151f6d5/" rel="bookmark">
			IIC驱动理论与实例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言IIC 驱动框架总线驱动设备驱动设备和驱动的匹配过程主机（控制器/适配器）驱动节选设备驱动编写 实例1：读取IIC接口传感器的数据实例2：RK3568触摸屏驱动 前言 `
不啰嗦，直接从驱动开讲，需要学习IIC协议基础知识的可以先看这篇文章：https://www.rstk.cn/news/369263.html?action=onClick
提示：需要了解 IIC 的帧格式、读写/命令模式才能彻底了解 i2c_msg 的使用。不想进半导体厂的驱动工程师直接看 设备驱动和设备驱动编写 ！！！
IIC 驱动框架 IIC 驱动分为主机驱动、设备驱动，主机驱动是 SOC 上IIC控制器驱动，主机驱动由原厂BSP工程师编写；设备驱动是通过调用主机驱动提供的API从而驱动从机上的IIC设备。这个思维很重要，后面的 SPI、USB、以太网都是这样的。
总线驱动 类似 platform 总线，总线就是用来挂载设备的；但是又不同于 platform ，因为 IIC 总线是真实的总线。
IIC 总线驱动的重点就是完成 IIC 适配器（也叫IIC控制器）的驱动。
/* include/linux/i2c.h */ struct i2c_adapter { struct module *owner; unsigned int class; /* classes to allow probing for */ const struct i2c_algorithm *algo; /* 总线访问算法，读写操作 */ void *algo_data; /* data fields that are valid for all devices */ struct rt_mutex bus_lock; int timeout; /* 单位为 jiffies */ int retries; struct device dev; int nr; /*i2c bus 编号， 若置为-1， 则代表动态分配*/ char name[48]; struct completion dev_released; struct mutex userspace_clients_lock; struct list_head userspace_clients; }; struct i2c_algorithm { /* 如果adapter不能支持i2c访问， 则置 master_xfer 为NULL */ int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num); /* 如果adapter支持SMBus访问， 则设置smbus_xfer, 若 smbus_xfer 为NULL， 则使用I2C访问来模拟SMBus访问 */ int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr, unsigned short flags, char read_write, u8 command, int size, union i2c_smbus_data *data); u32 (*functionality) (struct i2c_adapter *); /* 用于查询i2c adapter支持那些function */ }; /* i2c_algorithm 中的通信函数以 ic2_msg 为通信的基本单位 */ struct i2c_msg { __u16 addr; /* slave address */ __u16 flags; #define I2C_M_TEN 0x0010 /* this is a ten bit chip address */ #define I2C_M_RD 0x0001 /* read data, from slave to master */ #define I2C_M_NOSTART 0x4000 /* if I2C_FUNC_PROTOCOL_MANGLING */ #define I2C_M_REV_DIR_ADDR 0x2000 /* if I2C_FUNC_PROTOCOL_MANGLING */ #define I2C_M_IGNORE_NAK 0x1000 /* if I2C_FUNC_PROTOCOL_MANGLING */ #define I2C_M_NO_RD_ACK 0x0800 /* if I2C_FUNC_PROTOCOL_MANGLING */ #define I2C_M_RECV_LEN 0x0400 /* length will be first received byte */ #define I2C_M_NEED_DELAY 0x0020 // add by kfx #define I2C_M_REG8_DIRECT 0x0040 // add by kfx __u16 len; /* msg length */ __u8 *buf; /* pointer to msg data */ }; 注册 i2c_adapter 的方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fcb724c9975c3b464214ddef151f6d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3be8128d48f95f053e817fbbb88f5b0/" rel="bookmark">
			input子系统理论与实例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言基础知识数据结构evbit 上报事件类型input设备API 按键输入驱动实例上报输入事件 触摸屏部分电阻屏数据电容屏数据多点触摸协议（MT） 实战：基于tslib，不断打印2个触点的距离tslib库的用处数据结构应用程序 前言 直接上图：（图片来源于正点原子笔记）
（输入子系统对触摸屏狠重要，会用 TS Handler 狠重要！）
驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。
核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行
处理。
事件层：和用户空间进行交互。
驱动触发消息，内核收集后产生对应的回调任务，事件层就可以执行内核发布的回调任务。
为什么不直接内核执行任务？你当内核傻啊，内核主要就是调度任务，这个更重要。任务下发后就可以被更重要的任务阻塞。
基础知识 驱动程序上报的数据含义三项重要内容：
type：哪类？例如 EV_KEY 按键类
code：哪个？例如 KEY_A
value：值，例如 0 按下，1 松开
而应用层可以得到一个输入事件，一个个 struct input_event：
数据结构 /* include/uapi/linux/input.h */ struct input_event{ __u16 type; __u16 code; __u16 value; }; /* include/uapi/linux/time.h */ struct timeval{ __kernel_time_t tv_sec; //秒 __kernel_suseconds_t tv_usec; //微秒 } /* 每个输入事件 input_event 中含有发生时间，timeval 表示的是自系统启动以后过了多少时间。*/ 所有输入设备都可以在 /proc/bus/input/devices 中显示。
描述输入设备的结构体：
/* include/uapi/linux/input.h */ struct input_dev { const char *name;//输入设备的名字 const char *phys;//在系统层次结构中设备的物理路径; const char *uniq; struct input_id id;//输入设备id,包含总线类型,制造商id,产品id和版本号等; unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; //设备属性和怪异位图 unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; //设备支持的事件类型;EV_KEY, EV_REL; unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; //设备具有的按键(能够报告的) unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; //设备相对轴 unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; //绝对坐标的位图 unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; //设备支持的杂项设备事件 unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; //设备存在的led位图 unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; //设备支持的声音效果 unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; //设备支持的力反馈效果位图 unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; //设备存在的开关位图 /*以上支持哪些位就ke'y unsigned int hint_events_per_packet; unsigned int keycodemax; //按键编码表的大小; unsigned int keycodesize; //按键编码表中每个编码的大小 void *keycode;//按键编码表 int (*open)(struct input_dev *dev); //打开设备 void (*close)(struct input_dev *dev); //关闭设备 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3be8128d48f95f053e817fbbb88f5b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec856b629398c77ff1952e71e01179a/" rel="bookmark">
			学校头歌作业1_2四则运算(头歌作业[Python])
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CSDN上补充前几期的内容
第1关：整数四则运算 """ 试编程实现分两行输入两个非零整数，并在4 行中按顺序输出两个数的加、减、乘、除的计算结果。 要求输出与如下示例格式相同，符号前后各有一个空格。 """ #输入整数变量a和b，定义输入函数 ##############Begin################## a = int(input()) b = int(input()) ##############End#################### #a和b之间进行四则运算并输出 ##############Begin################## print(f'{a} + {b} = {a + b}') print(f'{a} - {b} = {a - b}') print(f'{a} * {b} = {a * b}') print(f'{a} / {b} = {a / b}') ##############End#################### 第2关：浮点类型四则运算 ''' 试编程实现分两行输入两个非零浮点数，并在4 行中按顺序输出两个数的加、减、乘、除的计算式和计算结果。计算结果str.format()方法保留小数点后3位数字。要求输出与如下示例格式相同，符号前后各有一个空格。 ''' #输入浮点型变量a和b，定义输入函数 #############Begin############## a = float(input()) b = float(input()) #############End################ #a和b之间进行四则运算并输出 #############Begin################ print(f'{a} + {b} = {a + b:.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dec856b629398c77ff1952e71e01179a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc520f153b99b0d1bbb946a033f498e/" rel="bookmark">
			110-基于stm32单片机温湿度PM2.5微尘空气质量环境监测系统Proteus仿真&#43;程序源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：功能介绍
1、采用stm32单片机+LCD1602+DHT11温湿度传感器+PM2.5传感器+空气质量检测传感器+蜂鸣器+LED灯，制作一个单片机温湿度PM2.5微尘空气质量环境监测系统；
2、通过PM2.5传感器检测有害气体浓度，并且显示到LCD1602显示屏上面，当检测浓度大于一定值，蜂鸣器和LED进行声光报警提醒；
3、通过空气质量传感器检测空气质量，并且显示到LCD1602显示屏上面，当空气质量值大于一定值，进行蜂鸣器LED声光报警提醒；
4、LCD1602显示温湿度、PM2.5浓度、空气质量；
二：仿真演示视频+程序简要讲解：（程序有中文注释，新手容易看懂）
110-基于stm32单片机温湿度PM2.5微尘空气质量环境监测系统Proteus仿真+程序源码+讲解视频
三：设计软件介绍
本设计使用C语言编程设计，程序代码采用keil5编写，程序有中文注释，新手容易看懂，仿真采用Proteus软件进行仿真，演示视频使用的是Proteus8.9版本；资料包里有相关软件包，可自行下载安装。
四：程序打开方法
特别注意：下载资料包以后一定要先解压！！！（建议解压到桌面上，文件路径太深会导致程序打开异常），解压后再用keil5打开。
程序部分展示，有中文注释，新手容易看懂 /*****************引脚配置********************/ void GPIO_Configuration(void) { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); //LCD1602 管脚 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8| GPIO_Pin_9| GPIO_Pin_10| GPIO_Pin_11| GPIO_Pin_12| GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 |GPIO_Pin_6|GPIO_Pin_5; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //DHT11 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); } void IO_out( void ) { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC ,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dc520f153b99b0d1bbb946a033f498e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f09621348bc66b0d2511e4d05822fd4e/" rel="bookmark">
			js中...variable的使用（解决变量的双向绑定）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 普通的变量在前面增加三个点号有不一样的含义和用法，主要体现在函数调用、对象复制和变量拼接三个方面。
二、使用场景 1、函数调用 分析：如上图结果，sum(...obj) 是等同于 sum(1,2,3) 的，也就是说 ...obj 表示将 obj 对象里的元素挨个取出来作为参数一对一地传给 sum 函数，如果直接使用 sum(obj) 就相当于 sum([1,2,3]) ，那么调用 sum函数后[1,2,3] 就作为整体赋值给了 x ，至于参数 y 和 z 由于没有对应数值就显示为未定义，最后结果就变成了 1,2,3undefinedundefined。
2、对象复制 在对象复制这一块可谓是 ...variable 的用武之地了，先抛出普通赋值语句的一个问题：
分析：将变量 info 赋值给 obj ，然后改变 obj 中其中一个元素的值，结果导致 info 这个对象的元素值也跟着改变，这是我们在开发中不愿意看到的数据双向绑定机制，如果想改变 obj 的属性而不影响到 info ，那就不能采用赋值方式，而应该采用复制变量的方式，...variable 在对象的复制上是特别方便的。
分析：将语句 let obj = info 修改为 let obj = [...info] 后，表示的就不是普通的赋值操作了，而是对象的复制，此时 obj 无论如何修改都不会改变 info 对象的值，这种复制用法的功能类似函数 Object.assign({},info)，不同点在于 [...info] 既能适用于 Array 的变量类型也能适用于 Object 的变量类型，但是 Object.assign({},info) 只适用于 Object 变量类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f09621348bc66b0d2511e4d05822fd4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4388c13132a835aacc0cc228f4c51bdc/" rel="bookmark">
			PTA 7-279 字符串输入输出练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PTA 7-279 字符串输入输出练习 分数 10
作者 黄龙军
单位 绍兴文理学院
输入起始位置m、长度l及字符串s，要求输出字符串s从第m个字符开始的长度为l的子串。
输入格式:
测试数据有多组，处理到文件尾。
每组测试数据输入一行，首先是以一个空格间隔的两个整数m、l，分别表示起始位置和长度，然后在一个空格之后是一个字符串s（长度不超过80，可能包含空格）。测试数据保证取得的结果字符串至少包含一个字符。
输出格式:
对于每组测试，输出字符串s从第m个字符开始的长度为l的子串（若长度不足l，则只需输出从第m个字符开始到最后一个字符结束的子串）。每两组测试数据之间留一个空行。
输入样例:
1 2 hello world! 9 6 welcome to acm world 输出样例:
he to acm 来源：
黄龙军, 等. 大学生程序设计竞赛入门—C/C++程序设计（微课视频版）, 北京:清华大学出版社, 2020.11. ISBN:9787302564744
代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB
#include&lt;stdio.h&gt; int main(){ int m, l, i, j = 0; char s[80][80]; char ss[80][80]; while(scanf("%d %d", &amp;m, &amp;l) != EOF){ //处理到文件尾 gets(s[j]); //获取字符串 for(i = m; i &lt; m+l; i++){ //按照题目要求截取字符串并储存到另一个数组中 ss[j][i-m] = s[j][i]; } ss[j][l] = '\0'; j++; } for(i = 0; i &lt; j; i++){ puts(ss[i]); if(i !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4388c13132a835aacc0cc228f4c51bdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0710b422896ab60f8784240d8c14b73/" rel="bookmark">
			IDEA打开一个项目时，idea左侧project模式下，不显示项目工程目录的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在IDEA打开一个一个已有的项目chapter3时，idea左侧project模式下，左侧也没有project按钮，如下问题截图：（ps:项目结构可以显示，但是src等目录不见）
在网上查了一些方法：
1、解决办法
方法1：找到 出错位置，修复
方法2：清除配置，重新导入
1）关闭重启IDEA，（注意不是关闭项目，而是清除内存，重启idea）
2）删除项目文件夹下的.idea文件夹
3）重新用IDEA工具打开项目
这些方法对我都没有用，于是就有如下第二个解决方案
上图idea中的project下就有了整个项目的目录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eccdfbf0aac54ea9df83fbbf91843f7/" rel="bookmark">
			Pytorch查看GPU是否可用、模型参数量numel统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看是否可用 import torch import os print('torch.cuda.is_available() = {}'.format(torch.cuda.is_available())) print("torch.cuda.device_count()={}".format(torch.cuda.device_count())) print("torch.cuda.get_device_name(0)={}".format(torch.cuda.get_device_name(0))) print("torch.cuda.current_device()={}".format(torch.cuda.current_device())) device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu") a_cpu = torch.Tensor(2, 3) print('a_cpu.device={}'.format(a_cpu.device)) # device(type='cpu') a_cuda = a_cpu.to(device) # tensor([[-2.1800e-01, 4.5737e-41, 2.3351e-37], # [ 0.0000e+00, 4.4842e-44, 0.0000e+00]], device='cuda:0') print('a_cuda.device={}'.format(a_cuda.device)) print('-----------os.environ.items()-----------') for k,v in os.environ.items(): print('os.environ.items_key={} v={}'.format(k,v)) print('-----------os.environ.items()-----------') 模型参数量统计 for name, param in model.state_dict().items(): print('name:{} param.size():{} param.numel():{} param.dtype:{}'.format(name, param.size(), param.numel(), param.dtype)) 其中param.size()返回的是tensor的shape，而param.numel()返回的是size的乘积jit_model.state_dict()返回的是一个有序字典OrderedDict, 包含了所有可学习参数和不可学习参数；model.parameters()返回的是一个生成器，该生成器中只保存了可学习、可被优化器更新的参数的具体的参数；model.named_parameters()返回的是一个生成器(generator)，该生成器中只保存了可学习、可被优化器更新的参数的参数名和具体的参数不可学习参数将会通过Module.register_parameter()注册在self._buffers中，self._buffers是一个OrderedDict，例如bn1层中的参数running_mean、running_var和num_batches_tracked均是不可学习参数可学习参数也可叫做模型参数，其就是要参与学习和更新的，特别注意这里的参数更新是指在优化器的optim.step步骤里更新参数，即需要反向传播更新的参数，使用nn.parameter.Parameter()创建的变量是可学习参数(模型参数) 部分转载自Pytorch中state_dict()、named_parameters()和parameters()的区别_Jiyang@UESTC的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca299475f66b157d08a315ba156c9bd/" rel="bookmark">
			C&#43;&#43;学习笔记——从面试题出发学习C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++学习笔记——从面试题出发学习C++ C++学习笔记——从面试题出发学习C++1. 成员函数的重写、重载和隐藏的区别？2. 构造函数可以是虚函数吗？内联函数可以是虚函数吗？析构函数为什么一定要是虚函数？3. 解释左值/右值、左值/右值引用、std::move、移动语义、完美转发等相关的概念？3.1 左值/右值的概念3.2 左值引用/右值引用的概念3.3 std::move的作用3.3 移动语义的概念3.4 完美转发的概念 4. decltype、volatile、explicit、override、mutable关键字的作用？4.1 decltype4.2 volatile4.3 explicit4.4 override4.5 mutable 5. 构造函数相关的default和delete关键字的作用？6 . extern C的作用？7. 解释动态多态和静态多态的区别？8. 菱形继承有什么问题，如何解决？9. 段错误有哪些类型？10. 如何定义一个只能在堆上（栈上）生成对象的类？11. delete this 合法吗？12. 不同类型智能指针的区别？12.1 auto_ptr12.2 shared_ptr12.3 weak_ptr12.4 unique_ptr 13. 不同强制类型转换运算符的区别？13.1 static_cast13.2 dynamic_cast13.3 reinterpret_cast13.4 const_cast 14. 如何重载操作符？重载操作符的返回值？流运算符为什么不能通过成员函数重载？16. 如何理解函数指针、类成员函数指针？ C++学习笔记——从面试题出发学习C++ C++博大精深，在学习过程中我也有看过《Effective C++》、《Efficient C++》、《C++ Prime》这样一些C++的经典大作，但是个人感觉是由于语法太多，很难抓住重点，在工作中如果不很经常用到某个语法，即使在书籍上有看过也会很快忘记。而刷面试题是一个很好的查漏补缺的方式，本博客将以面试题为切入点，将面试题中涉及的语法展开学习以彻底搞懂，进而达到在平常的工作中能够灵活运用目的，下面就逐个开始语法的学习：
1. 成员函数的重写、重载和隐藏的区别？ 这里我们直接给出三种不同概念的定义：
重载指的是同一作用域内（例如同为某一个类的成员函数），函数名相同，入参不同的情况；
隐藏指的是不同作用域内（例如两个函数分别位于父类和子类中），函数名相同，入参不同则直接构成隐藏，入参相同且非虚函数，否则为重写；
重写特指两个函数分别位于父类和子类中，函数名相同，入参相同且为虚函数的情况（注意和隐藏做区别）；
我们要知道：
重载是静态多态的表达形式，重写是动态多态的表达形式。
除此之外，下面这种情况注意隐藏和重写输出的区别：
如下是隐藏，调用的是Base类中的func函数
#include&lt;iostream&gt; using namespace std; class Base { public: void fun(int i){ cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ca299475f66b157d08a315ba156c9bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83218ac34c1834c26781fe4bde918ee4/" rel="bookmark">
			Welcome
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Welcome to Apache Maven（欢迎来到Apache Maven） Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of information.
Apache Maven 是一个软件项目管理和comprehension工具。基于项目对象模型(POM)的概念，Maven能够根据一个核心信息块管理项目的构建、报告和文档。
If you think that Maven could help your project, you can find out more information in the “About Maven” section of the navigation. This includes an in-depth description of what Maven is and a list of some of its main features.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83218ac34c1834c26781fe4bde918ee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62895d3c6f52f4c009ca88eb953626c/" rel="bookmark">
			【DRONECAN】（三）WSL2 及 ubuntu20.04 CAN 驱动安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【DRONECAN】（三）WSL2 及 ubuntu20.04 CAN 驱动安装
前言 这一篇文章主要介绍一下 WSL2 及 ubuntu20.04 CAN 驱动的安装，首先说一下介绍本文的目的。
大家肯定都接触过 ubuntu 系统，但是我们常用的操作系统都是 Windows，想要切换到 ubuntu 系统要么装虚拟机，要么装双系统。双系统必然是麻烦的，而且得两个系统来回切换，而虚拟机的代表就是 vmware，简单的使用还行，但是涉及到三维仿真就会比较卡顿了，而且占用资源也是比较大的。WSL2（Windows Subsystem for Linux 2）是 Windows 10 操作系统中的一个功能，用于在 Windows 系统中运行 Linux 环境，以便用户可以在 Windows 系统中使用 Linux 的命令行工具和应用程序。它是一种虚拟化技术，通过在 Windows 系统上运行一个轻量级的 Linux 内核来实现。注意，相比较于 WSL 1 使用翻译层将 Linux 系统调用转化成 Windows 系统调用，WSL2 是有一个 Linux 内核，只不过微软做了一些裁剪。
因此，WSL2 更适合做 Linux 开发。所以，目前我也沉迷用 WSL2 做 Linux 开发，例如在 WSL2 做 Ardupilot 开发、GAZEBO 仿真等等，都是基于 WSL2 有一个 Linux 的内核。
安装 WSL2 WSL2 安装就很容易，网上也有很多教程，总结一下就是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62895d3c6f52f4c009ca88eb953626c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16999f4683991137adea5dc2a6e5cfac/" rel="bookmark">
			kafka一篇文章解答90%以上面试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kafka整体架构
整体架构分为producer、broker、consumer三部分，3.0版本之前依赖zookeeper做集群管理，3.0版本之后通过KRaft进行集群管理。
consumer有消费者组概念，同一个组内不同消费者负责消费不同的partation，一个分区只能由一个组内消费者消费；消费者组之间互不影响
集群中的broker会选举出一个leader作为Controller负责管理整个集群中所有分区和副本的状态
每个topic由多个partation组成，partation为真实存储数据的地方，每个partation以文件夹的形式存储在文件系统中。每个对应的partation数据目录下存储*.index，*log ，*timeindex三个文件
每个partation都有对应的副本，分散在不同的broker中来实现分布式存储。
整体使用主写主读架构，通过partation分布不同的broker上，尽量保证每个broker既有replicas分区拉数据也有leader分区生产数据，实现负载
kafka的基本组件
1. Broker：通俗理解成一台部署了kafka的服务器就是一个Broker，一个kafka集群由多个Broker组成，每个Broker包含多个Topic
2. Controller：broker的领导者，主写主读，它负责管理整个集群中所有分区和副本的状态
3. Producer：消息生产者，自己决定向哪个partaion发送数据，hash或轮询
4. Consumer：消息消费者，通过zookeeper维护offset
5. Consumer Group：消费者组，同一个组内不同消费者负责消费不同的partation，也就是一个分区只能由一个组内消费者消费；消费者组之间互不影响。每条消息只能被Consumer Group中的一个Consumer消费；但是可以被多个Consumer Group组消费。
6. Topic：消息主题，一类消息的总称/消息队里，逻辑概念，真实数据存放在partation中，一个 topic 由多个 partions 组成
7. Partation：分区,真实存储数据的地方，负载均衡与扩展性考虑，一个Topic可以分为多个Partition,物理存储在Kafka集群中的多个Broker上。可靠性上考虑，每个Partition都会有备份Replica。partation保持分区顺序
8. Replica副本：Partition的副本，为了保证集群中的某个节点发生故障时，该节点上的Partition数据不会丢失，且Kafka仍能继续工作，所以Kafka提供了副本机制，一个Topic的每个Partition都有若干个副本，一个Leader和若干个Follower。
9. Leader：Replica的主角色，Producer与Consumer只跟Leader交互。
10. Follwer：Replica的从角色，实时从Leader中同步数据，保持和Leader数据的同步。Leader发生故障时，经过一系列选举算法，某个Follower会变成新的Leader。
11. Offset：每个分区日志都有一个offset来唯一的标记一条消息,offset的值为8个字节的数字,表示此消息在此partition中所处的起始位置
kafka数据存储原理
1. partation为真实存储数据的地方，每个partation以文件夹的形式存储在文件系统中。每个对应的每个partation文件夹下的日志被分割成很多segment段。
2. 日志分段名通过偏移量确定，比如segment1的段号是509，segment2的段号是1397，那么segment1就存储了偏移量509-1397的消息。
3. 定位到段后通过稀疏索引的方式，也就是利用*.index文件。之所以成为稀疏索引是因为并没有维护所有数据的索引，定位数据的时候要通过二分查找的方式定位索引的位置，再通过索引对应的真实数据的位置回表查询。
4. *.timeindex 和kafka清理数据有着密切的关系，kafka默认保留7天内的数据，对于超过7天的数据，会被清理掉，这里的清理逻辑主要根据timeindex时间索引文件里最大的时间来判断的，如果最大时间与当前时间差值超过7天，那么对应的数据段就会被清理掉
5.由于生产者生产的消息会不断追加到 log 文件末尾，为防止log文件过大导致数据定位效率低下，Kafka采取了分段和索引机制，
6.partition 在服务器上的表现形式就是一个一个的文件夹（命名规则：topic名称+分区序号），每个 partition 文件夹下面会有多组 segment（逻辑分组，并不是真实存在），每个 segment 对应三个文件 （.log文件、.index文件、.timeindex文件）。
7.log文件就实际是存储 message 的地方，而 index 和 timeindex 文件为索引文件，用于检索消息。
如上图，这个 partition 有三组 segment 文件，每个 log 文件的大小是一样的，但是存储的 message 数量是不一定相等的（每条的 message 大小不一致）。文件的命名是以该 segment 最小 offset 来命名的，如 000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16999f4683991137adea5dc2a6e5cfac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58181e265eefa825b58942b7fe05c42e/" rel="bookmark">
			【超详细~KVM】KVM概述、安装及简单操作-------从小白到大神之路之学习运维第91天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四阶段提升
时 间：2023年8月30日
参加人：全班人员
内 容：
KVM概述、安装及简单操作
目录
一、KVM 概述
二、KVM工作原理
三、KVM应用场景
四、centos7 下安装部署
五、新建虚拟机步骤
1、创建存储池并创建存储卷
2、点击+号创建KVM存储池
3、创建存储卷
4、创建ISO存储池
5、利用winscp工具，将主机上的镜像上传到虚拟机的ISO的目录
6、生成新虚拟机
六、KVM的简单操作
一、KVM 概述 KVM 是 Kernel-based Virtual Machine 的缩写，是一种用于虚拟化的开源硬件虚拟化技术。
它使用 Linux 内核的虚拟化模块，将物理服务器划分为多个虚拟机。
KVM 允许虚拟机直接访问物理硬件资源,从而提供出色的性能和稳定性,同时还支持许多常见的操作系统和应用程序。
KVM 使用了 QEMU (Quick Emulator) 作为其默认的虚拟机监控程序。
除此之外，KVM 还支持多种嵌入式和云计算场景，并且得到了广泛的应用。
二、KVM工作原理 KVM 的工作原理是使用 Linux 内核的虚拟化模块，将物理服务器划分为多个虚拟机。
具体来说，它在 Linux 内核之上构建一个虚拟化层，该虚拟化层允许多个虚拟机共享物理服务器上的计算资源(如 CPU、内存和 0 设备)。在此虚拟化层中，每个虚拟机都被视为单独的计算机，每个虚拟机可以运行不同的操作系统和应用程序。
KVM使用硬件虚拟化技术，即通过 intel VT-x 和 AMD-V 等 CPU 虚拟化指集的支持，将虚拟化性能提升到接近原生性能。
此外，KVM 还使用 QEMU 作为其虚拟机监控程序，QEMU为每个虚拟机提供了一个虚拟化的环境，在该环境中，虚拟机可以访问它需要的资源(如磁盘、网络和其他I/0 设备)。
同时，KVM 利用 Linux 内核的强大功能，如分时调度和内存管理，来确保多个虚拟机之间的隔离性和安全性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58181e265eefa825b58942b7fe05c42e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8269299b695fe653392a346c4681db8c/" rel="bookmark">
			微信小程序————实现登录功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：对于web端网站系统来说，实现登录功能一般通过账号密码，或者手机号验证码进行登录，之后后端进行校验，通过之后，发送token（代表登录状态）给前端，以便进行后续的交互。但是在微信小程序中，却不同，可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登录功能。
注意：实现小程序登录功能主要涉及到code和openID的概念：
开发者通过调用wx.login()接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。
小程序的登录流程：
说明：
1、首先调用wx.login()获取临时登录凭证code，并传到开发者服务器。
2、接着服务器调用auth.code2Session()接口，换取用户唯一标识OpenId，用户在微信开放平台帐号下的唯一标识UnionID（若当前小程序已绑定到微信开放平台帐号）和会话密钥 session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。
实现登录第一步—————获取code 小程序通过wx.login()方法获取登录凭证code，在小程序页面中声明一个按钮，点击时触发登录的函数。
toLogin(){ //wx.login()方法获取code wx.login({ success (res) { if (res.code) { console.log(res.code) } } }） } 以上就是获取登录凭证code，并打印到控制台查看
实现登录第二步——————将code发送到开发者服务器 login:function(){ // wx.login()获取code wx.login({ success:(res)=&gt;{ console.log("code: " + res.code); //通过wx.request()方法将code发送到开发者服务器 wx.request({ url:'http://127.0.0.1:3000/login', method:'POST', data:{ code : res.code } }) } }) } 在开发者服务器中写一个路由与该请求进行匹配，
// '/login'即响应在小程序中的请求http://127.0.0.1:3000/login app.post('/login',(req,res)=&gt;{ console.log('code: '+req.body.code) // 打印一下code }) 实现登录第四步——————通过微信接口服务校验 接着开发者服务器将appID和appSecret和code发送给微信接口服务去校验，成功后会返回openid(用户唯一标识)和session_key(会话信息记录)
//在这里一定要导入这个，否则无法使用下面的request函数，这里踩过坑 const request=require('request') // 开发者信息 const wx = { // appid:' ', // 填写用户自己的appid // secret:' ' // 填写用户自己的密钥 } // '/login'即响应在小程序中的请求http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8269299b695fe653392a346c4681db8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90014a1de0172da71ed30932be2b5fe7/" rel="bookmark">
			前端防抖与节流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前端防抖与节流 防抖定义: 触发后在n秒内，只执行一次，若在n秒内再次触发则重新计算!
code演示
function debounce(fn,delay=300){ let timer; return function (){ if(timer){ clearTimeout(timer) } timer=setTimeout(()=&gt;{ fn(); },delay) } } input.onkeyup=debounce(()=&gt;{ },1000) 节流定义: 连续发生的事件在n秒内只执行一次
code演示
function throttle(fn,delay=300){ let timer; return function (...args){ if(timer){ return; } timer=setTimeout(()=&gt;{ fn(...args); timer=null; },delay) } } owrap.ondrag=throttle((e)=&gt;{ console.log(e.offsetX,e.offsetY); },1000) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36402deea2af244c8de51414cac5d95/" rel="bookmark">
			Vue组件之间的通讯方式数据处理：父子组件，兄弟组件，同级组件，爷孙组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贴一张图先建立几个组件
先讲一句 每个 Vue 实例都实现了事件接口，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 Vue 的事件系统与浏览器的 EventTarget API 有所不同。尽管它们的运行起来类似， 但是 $on 和 $emit 并不是addEventListener 和 dispatchEvent 的别名， 另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。 那就同级兄弟之间数据的传递，刚才贴了兄弟之一，再贴一下它老弟
好了，老大想搞老二？他们之间怎么搞呢？
建个房啊，公共枢纽站多方便以后也划算
你可以随便建 我就不说了，我在src/assets/下创建一个js文件,内容如下
嗯，内容虽然少，但是我不想写啊，也防止你直接copy啊，哈哈
（eventBus中我们创建了一个新的Vue实例，以后它就承担起了组件之间通信的桥梁了，也就是中央事件总线。
（这句话不是我说的，不过的却是eventBus的确是这意思）
1、一句话就是我们在响应点击事件的sendMsg函数中，用$emit触发了一个自定义的userDefinedEvent事件， 并传递了一个字符串参数，而$emit实例方法触发当前实例(这里的当前实例就是bus)上的事件,附加参数就会传给监听器回调。 所以在 第二个组件里
在mounted中，监听了userDefinedEvent,并把传递过来的字符串参数传递给了$on监听器的回调函数
好了，三分归元气当然是把组建放到父级上去，注册这两个组件，并添加这两个组件的标签
算了，贴一下 总结
1、创建一个事件总线，例如demo中的eventBus，用它作为通信桥梁 2、在需要传值的组件中用bus.$emit触发一个自定义事件，并传递参数 3、在需要接收数据的组件中用bus.$on监听自定义事件，并在回调函数中处理传递过来的参数 好像有点长，算了，快一点，父子之间传递，父向子，子向父我这里放在了一个组件里
同时我们看到app.Vue里面的蓝2 是通过绑定的形式直接传进子组件的，不过是在子组件里的pros里面接受一下就能使用
里面的红1是子组件向父组件传值后（@reduce-parent） 是v-on 来监听子组件触发的事件，别瞎搞
至于下面methods里面写的，上面也说了，也不说了，好像完了…
对于vue来说，组件之间的消息传递是非常重要的，组件之间消息传递的各种方式有那些呢？
1. props和$emit 父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e36402deea2af244c8de51414cac5d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd05ac98af04e0cf6b65c10ab70333f5/" rel="bookmark">
			Power Pivot 实现数据建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 Excel中的透视表适合小规模数据；如果想在稍微大一些的数据中进行高性能透视表分析，就要使用Power Pivot；再大一些数据，可能就需要大数据分析服务来进行分析。
Power Pivot，可以让没有技术背景的企业业务人员快速通过Excel进行数据建模，执行复杂数据分析，制作可自动更新的企业级数据报告。
传统Excel对比Power Pivot
Mac版本的excel没有power pivot 功能，所以同样用不了power bi。
二、创建一个简单的多表数据模型 第一种方法 VLOOKUP VLOOKUP(a表匹配字段，b表查询字段 需匹配字段作为第一被选择的列，b表匹配结果列，0或1表示是否精确匹配)
功能：在表格的首列查找指定的数值，并返回表格当前行中指定列处的数值。
结构：=VLOOKUP(查找值,查找区域,列序数,匹配条件)
解释：=VLOOKUP(找谁,在哪里找,第几列,0或1)
说明：
1、第一参数：查找值（找谁），比如说根据【姓名】来查找【成绩】，【姓名】就是查找值
2、第二参数：查找区域（在哪里找），查找的数据区域也就是所选择的区域，注意所选择的区域要根据查找值位于第一列开始选择，比如说根据【姓名】来查找【成绩】，那数据表所选的区域要从【姓名】列开始选择。建议设置为绝对引用，在选定区域后按F4键就可以快速切换，就是在行和列的前面添加$符号，拖动公式时，区域就不会发生改变；
3、第三参数：列序数（第几列），也就是返回的结果在数据表中位于第几列，包含隐藏的列；
4、第四参数：匹配条件（0或1），若为0或FALSE代表精确匹配，1或TRUE代表近似匹配；
注：查找值在数据表中多次出现，导致有多个结果，函数仅仅会返回第一个找到的结果。
VLOOKUP函数16种经典用法（史上最全，记得收藏） - 知乎
第二种方法Power Query power query的合并查询
第三种方法 Power Pivot多表查询 1.导入数据 管理数据模型进入power pivot界面
主页--从其他源--选择Excel导入表 导入后界面分为两部分：数据预览区域和计算区域。 计算区域可以对预览区域的数据进行一些计算，比如求和等。
可以重复上述步骤导入多张数据表。
Excel求和只会有加和数字，但是Power Pivot会有文字+求和数字，这是Excel函数和Power Pivot DAX函数的区别。 点击求和数字，可以修改显示文字和数字格式。
2.两表连线建立关系 两张表能够连线建立关系必须满足如下
（1）两张表的连线字段必须一张表是唯一值，另一张表唯一值或重复值，即1：N。不能够N：N
导入多张数据表点击“关系图视图”，会进入多表界面，显示每张表的所有字段。鼠标左键将关联字段连线。就会出现联系线段，线段三个内容 1 * 箭头。1和* 表示连线字段哪边是唯一值，哪边是重复值；箭头代表箭尾的表可以查询箭头指向表的数据。反之不可以调用。只有唯一值的表可以调用*值的表。详述见下连线建立后，点击数据透视表就会带着此数据模型回到Excel透视表界面。 Power Pivot中连线成功的表使用方法
（1）连线成功后，会自动分配1端表和*端表，1端表所有字段可以作为“行”同时让 *端表的字段作为 “值”，反之*端表作为“行”同时让1端表作为“值”会报错，但是单独*端表作为“行”同时作为“值”没问题。
如下图，”行“中为两个1端的字段，“值”为*端的字段。
3.数据透视表 两张表建立关系后，点击数据透视图回到Excel数据透视表界面。
4.数据透视图 数据透视表和数据透视图，如果原始表格数据发生变化，即使未保存，此时点击Power Pivot菜单中的刷新也会同步变化统计值。
刷新下拉箭头，全部刷新是指会将所有表格都进行比对刷新。
1.给关心的字段添加切片器。
左键--添加切片器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd05ac98af04e0cf6b65c10ab70333f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9024ded26dd93779784b2ed64cd2b610/" rel="bookmark">
			Css3 记录参考手册-新增伪类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS3 是最新的 CSS 标准。一篇文章向您讲解 CSS3 中的新特性。
CSS3 完全向后兼容，因此您不必改变现有的设计。浏览器通常支持 CSS2。
CSS3 被划分为模块。
其中最重要的 CSS3 模块包括：
选择器框模型 背景和边框 文本效果 多列布局 2D/3D 转换 动画用户界面 选择器例子例子描述CSS.class.intro选择 class="intro" 的所有元素。1#id#firstname选择 id="firstname" 的所有元素。1**选择所有元素。2elementp选择所有 &lt;p&gt; 元素。1element,elementdiv,p选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。1element elementdiv p选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。1element&gt;elementdiv&gt;p选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。2element+elementdiv+p选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。2[attribute][target]选择带有 target 属性所有元素。2[attribute=value][target=_blank]选择 target="_blank" 的所有元素。2[attribute~=value][title~=flower]选择 title 属性包含单词 "flower" 的所有元素。2[attribute|=value][lang|=en]选择 lang 属性值以 "en" 开头的所有元素。2:linka:link选择所有未被访问的链接。1:visiteda:visited选择所有已被访问的链接。1:activea:active选择活动链接。1:hovera:hover选择鼠标指针位于其上的链接。1:focusinput:focus选择获得焦点的 input 元素。2:first-letterp:first-letter选择每个 &lt;p&gt; 元素的首字母。1:first-linep:first-line选择每个 &lt;p&gt; 元素的首行。1:first-childp:first-child选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。2:beforep:before在每个 &lt;p&gt; 元素的内容之前插入内容。2:afterp:after在每个 &lt;p&gt; 元素的内容之后插入内容。2:lang(language)p:lang(it)选择带有以 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9024ded26dd93779784b2ed64cd2b610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b5f1e8caedac8ce3b33d4b6fee9e469/" rel="bookmark">
			基于ant-design的a-modal自定义vue拖拽指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网自定义指令链接
写一个dragDialog.js
在main.js中引入
import ‘./core/directives/dragDialog.js’
// 让 dialog 支持鼠标拖动 import Vue from 'vue' Vue.directive('DragDialog', { update: function (el, binding, vnode) { if (!binding.value || !binding.value.reset) return const dialog = el.querySelector('.ant-modal') if (el.hasAttribute('margin-top') &amp;&amp; el.style.display &amp;&amp; el.style.display === 'none') { dialog.style.margin = null dialog.style.marginTop = el.getAttribute('margin-top') dialog.style.left = null dialog.style.top = null } }, inserted: function (el, binding, vnode) { const header = el.querySelector('.ant-modal-header') const dialog = el.querySelector('.ant-modal') const body = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b5f1e8caedac8ce3b33d4b6fee9e469/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/97/">«</a>
	<span class="pagination__item pagination__item--current">98/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/99/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>