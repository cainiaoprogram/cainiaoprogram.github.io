<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39745420013d7ab6fb9445c18139285e/" rel="bookmark">
			docker-宿主机与容器的命令执行方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在宿主机中命令运行状态的容器执行一条命令 问题描述 当前有一个容器在运行，在不进入容器的情况下，如何在宿主机中命令该容器在容器内执行一条命令？
环境 宿主机：centos7，python2.7，
容器：ubuntu20，python3.8
解法 假设有一个test.py，内容是：
print "hello!" 需要实现的效果是在宿主机中，使用python3运行test.py。（会报错，但是仅作测试、示意）
首先将test.py放在/home/xxx/test，并且在容器中建立一个文件夹/mnt/share/test作为可共享的文件夹。
然后启动容器：
docker run -itd --privileged -v /home/xxx/test:/mnt/share/test ubuntu-py385:2023 复制容器id备用。
此时在宿主机中只需要执行docker exec即可看到结果。
(base) [root@localhost test]# docker exec 容器ID python3 /mnt/share/test/test.py File "/mnt/share/test/test.py", line 1 print "hello!" ^ SyntaxError: Missing parentheses in call to 'print'. Did you mean print("hello!")? 在运行的容器中命令宿主机执行一条命令 问题描述 当前有一个容器在运行，如何在容器中向宿主机发送一条命令，要求宿主机执行？
环境 同上。
解法 test.py存放位置同上，内容同上，容器启动方法同上。
这里使用socket解决这个问题。
准备两个python文件：
host.py 在宿主机中执行container.py 在容器中执行 '''host.py ''' import os import socket server = socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39745420013d7ab6fb9445c18139285e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2621e55c545abd5ab69c49fd0f5877/" rel="bookmark">
			HttpClient调用外部接口业务别忘了超时配置！公司工具类打包好啦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在工作中，往往会遇到需要对接外部接口的业务需求，根据接口文档确定请求IP以及相关的参数数据需求后，通过HttpClient进行第三方外部接口的调用。在这种业务中，也要考虑好请求超时导致的接口报错的处理。为什么呢？就我公司业务而言，我们这边的视频或者说融合通讯，因为厂商多，设备型号杂，经常都有调用不通的情况。今天正常的视频可能明天就不行了，如果后端这里不处理超时，前端如果无法拿到设备信息或者设备ID，页面的报错信息可能反应的就是接口报错了。这显然是不合情理的，为此，我们可以考虑加一个请求超时的参数（在配置文件中读取自定义参数） ，控制一下。本文就HttpClient做一个简单的快速入门，并搭配好我编写的一个完整工具类，希望可以帮助大家在第三方接口调用业务中有所帮助。
实现思路步骤 创建 HttpClient 对象，可以使用 HttpClients.createDefault() 方法。
确定请求方法类型
如果是无参数的 GET 请求，则直接使用构造方法 HttpGet(String url) 创建 HttpGet 对象即可；如果是带参数的 GET 请求，则可以先使用 URIBuilder(String url) 创建对象，再调用 addParameter(String param, String value) 或者 setParameter(String param, String value) 方法来设置请求参数，并调用 build() 方法构建一个 URI 对象。只有构造方法 HttpGet(URI uri) 可以创建 HttpGet 对象。如果是无参数的GET请求，则直接使用构造方法HttpPost(String url)创建HttpPost对象即可； 如果是带参数POST请求，先构建HttpEntity对象并设置请求参数，然后调用setEntity(HttpEntity entity) 创建HttpPost对象。 加载配置类中的超时配置数据，配置在 RequestConfig 对象中，将该对象配置到具体的HttpPost / HttpGet 对象里，设置好超时规则
创建 HttpResponse，调用 HttpClient 对象的 execute(HttpUriRequest request) 方法发送请求，该方法返回一个 HttpResponse。调用 HttpResponse 的 getAllHeaders() 、getHeaders(String name) 等方法可以获取服务器的响应头；调用 HttpResponse 的 getEntity() 方法可以获取 HttpEntity 对象，该对象包装了服务器的响应内容。程序可以通过该对象获取服务器的响应内容。通过调用 getStatusLine().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e2621e55c545abd5ab69c49fd0f5877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbeefd16cc5ed545d4fcf1da44b7fc5/" rel="bookmark">
			x-cmd pkg | grex - 用于生成正则表达的命令行工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介首次用户生成的正则表达式与 perl 和 rust 兼容支持 Unicode 符号友好的用户体验进一步阅读 简介 grex 是一个旨在简化创作正则表达式的复杂且繁琐任务的库和命令行程序。这个项目最初是 Devon Govett 编写的 JavaScript 工具 regexgen 的 Rust 移植。但 regexgen 在几年前停止了开发。现在grex提供了 regexgen 提供的所有功能，还增加了许多新的功能。
首次用户 使用 x grex 即可自动下载并使用
在终端运行 eval "$(curl https://get.x-cmd.com)" 即可完成 x 命令安装, 详情参考 x-cmd 官网 x-cmd 提供1分钟教程，其中包含了 grex 命令常用功能的 demo 示例，可以帮你快速上手 grex 。
使用案例:
# 生成字母 a-f 的正则表达式 x grex a b c d e f # 将所有 Unicode 十进制数字转换为 \d x grex -d "bc" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fbeefd16cc5ed545d4fcf1da44b7fc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca7cfceccaa7e643d214bfddea21f031/" rel="bookmark">
			Docker 使用DockerFile构建Nodejs服务镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker 使用DockerFile构建Nodejs服务镜像 一、创建Dockerfile文件 使用vim命令创建DockerFile文件
vim Dockerfile 粘贴内容
# 基础依赖镜像 FROM video-stream-player:1.0.1 # 项目路径 # WORKDIR /root/node # 项目对外暴露端口号 EXPOSE 3000 #安装依赖 # RUN npm install cnpm -g --registry=https://registry.nlark.comRUN cnpm install #启动项目执行命令 ENTRYPOINT ["nohup","node","/root/node/rtsp-to-flv-master/index.js"] 二、构建新镜像
# . 表示当前目录下Dockerfile文件 docker build -t 镜像名称:tag . 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6c461446d6273922c55b52bf7e2cfd9/" rel="bookmark">
			婚恋/社交娱乐/同城相亲/红娘相亲交友软件开发小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求分析：首先明确小程序的目标、功能和用户需求。确定小程序的主要功能，例如用户注册、登录、个人资料编辑、浏览其他用户资料、发送消息等。
技术选型：选择适合的开发框架和技术工具。在小程序开发中，可以使用微信小程序原生开发框架（WXML + WXSS + JavaScript）或跨平台开发框架（如uni-app、Taro等）。
原型设计：使用设计工具（如Sketch、Adobe XD等）创建小程序的页面原型。确定页面结构、布局和交互流程，保证用户体验。
页面开发：根据原型设计，开始编写小程序的页面代码。使用WXML编写页面结构，WXSS编写样式，JavaScript处理交互逻辑。按照需求逐步开发页面，并进行调试和优化。
后端开发：如果小程序需要与服务器进行数据交互，需要开发后端接口和数据库。选择合适的后端开发语言和数据库，根据需求编写API接口，实现用户注册、登录、数据存储等功能。
接口对接：将前端和后端连接起来，通过HTTP请求或WebSocket等方式进行数据交互。确保前后端接口的正确性和稳定性。
测试和调试：开发完成后进行测试和调试，确保小程序的稳定性和功能完善性。进行单元测试、集成测试、界面测试等，修复bug并进行性能优化。
发布上线：将小程序打包并提交到相关平台（如微信小程序平台）进行审核和发布。确保遵守相关规定和要求。
运营和维护：小程序上线后，需要进行运营和维护工作。收集用户反馈，持续改进功能，修复bug，保证用户体验和小程序的稳定性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b815cb02c5deb516fd06eb04ff7704/" rel="bookmark">
			【MyBatis】#{}和${} | 数据库连接池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言#{}和${}的使用#{}和${}的区别排序功能模糊查询 数据库连接池 前言 前面我们学习了 MyBatis 的基础操作，其中参数的传递使用到了
#{}，而参数的传递不仅仅只有这一个可以使用，还有 ${} 可以使用，那么今天这篇文章我将为大家说说关于 #{} 和 ${}，这个是 MyBatis 在面试中最常问的面试题，以及数据库连接池相关的知识。
#{}和${}的使用 首先我们还是需要在 YAML 配置文件中配置数据库的相关配置。
# 配置数据库相关信息 spring: datasource: url: jdbc:mysql://127.0.0.1:3306/mybatis_test?characterEncoding=utf8&amp;useSSL=false username: root password: lmh041105666 # 打印mybatis日志 mybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl UserInfoMapper文件中的代码
@Mapper public interface UserInfoMapper { //这里是使用#{}作为参数的传递 @Select("select * from userinfo where id=#{id}") public UserInfo selectById(Integer id); } 单元测试中代码
@Slf4j @SpringBootTest class UserInfoMapperTest { @Autowired private UserInfoMapper userInfoMapper; @Test void selectById() { log.info(userInfoMapper.selectById(3).toString()); } } 然后我们讲这里的 #{} 改为 ${} 看看有什么效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6b815cb02c5deb516fd06eb04ff7704/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3f5cd68b9a9e50246929363786b43f/" rel="bookmark">
			MYSQL学习之buffer pool的理论学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MYSQL学习之buffer pool的理论学习 by 小乌龟
文章目录 MYSQL学习之buffer pool的理论学习一、buffer pool是什么？二、buffer pool 的内存结构三、buffer pool 的初始化和配置初始化配置 四、buffer pool 空间管理LRU淘汰法冷热数据分离的LRU算法 一、buffer pool是什么？ 我们都知道，MySQL的数据都是存储在磁盘空间中的，但是操作系统与磁盘的交互是比较耗时的，势必会影响MySQL的性能，如果要提高MySQL的性能，势必要解决交互的速度问题，为了解决这一问题，buffer pool 应运而生。buffer pool 是MySQL在内存中专门为自己开辟的内存空间，相当于数据缓存，主要目的是暂存一些使用频率较高的一些，以达到提高MySQL性能的。
二、buffer pool 的内存结构 buffer pool 中主要包含两部分：数据页和数据块，数据页主要存储MySQL的数据，数据块主要存储和数据也相关的信息，两者一一对应；
数据页：存储MySQL中的真实数据，每一页的默认大小为16KB。
数据块：存储数据页的页码，在buffer pool中的地址以及数据页所属的表空间等数据，大约为数据页大小的5%，816个字节左右。
三、buffer pool 的初始化和配置 初始化 1、MySQL 启动时，会根据参数 innodb_buffer_pool_size 的值来为 Buffer Pool 分配内存区域。
2、然后会按照缓存页的默认大小 16k 以及对应的描述数据块的 800个字节 左右大小，在 Buffer Pool 中划分中一个个的缓存页和一个个的描述数据库块。
此时的缓存页和描述数据块都是空的，毕竟才刚启动 MySQL 配置 ？
四、buffer pool 空间管理 缓冲池的大小是有限的，当数据页不断被复制到缓冲池中时，必然会出现溢出的情况，因此要存在相应的淘汰策略去不断淘汰到缓冲池中的数剧，同时还要保证常用的数据能够保存在缓冲池中。buffer pool采用LRU方法进行数据页的数据页的淘汰管理，（LRU，全称是 Least Recently Used，中文名字叫作「最近最少使用」）顾名思义，淘汰最近最少使用的数据页。
但是呢，如果基于此算法，当遇到全表扫描时，此时缓存池中会加载大量的新的数据页，从而将缓存池中的已存在的且被频繁访问的数据页替换出去，从而也影响了MySQL的性能，因此，基于冷热数据分离的LRU算法登场；
LRU淘汰法 首先，为了能够完成LRU算法，底层采用链表的形式存储数据的地址，链表中每一个节点存储的是该节点所指向数据页的地址（此节点也称为称为控制块），当有一个数据页被访问时，此节点会移动到表头，基于此算法，表尾的节点自然就成为了最少使用的节点，当要进行淘汰数据页操作时时，将表尾节点所指向的内存替换即可，同时删掉此链表的结尾结点。通常我们此链表称为LRU链表
1. 缓存页已在缓冲池中
这种情况下会将对应的缓存页放到 LRU 链表的头部，无需从磁盘再进行读取，也无需淘汰其它缓存页。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef3f5cd68b9a9e50246929363786b43f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d92ffed25265adaa6c50db711d692c84/" rel="bookmark">
			vue中＜router-view＞使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;router-view&gt; 是 Vue Router 提供的一个用于动态显示匹配到的组件内容的组件。在单页面应用中，页面的切换是通过路由的变化来实现的，而 &lt;router-view&gt; 负责根据当前路由匹配到的组件渲染相应的内容。
下面是 &lt;router-view&gt; 的一些使用详解：
基本使用：
在主模板中使用 &lt;router-view&gt; 标签，它会根据当前路由的匹配情况动态渲染对应的组件。
&lt;template&gt; &lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { // 组件的其他配置 }; &lt;/script&gt; 嵌套路由：
&lt;router-view&gt; 可以嵌套使用，以支持嵌套路由的场景。在父组件中使用多个 &lt;router-view&gt; 标签，每个标签对应一个具体的嵌套路由。
&lt;template&gt; &lt;div&gt; &lt;header&gt;Header&lt;/header&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;footer&gt;Footer&lt;/footer&gt; &lt;/div&gt; &lt;/template&gt; 命名视图：
使用 &lt;router-view&gt; 标签时，你还可以为其指定 name 属性，从而支持命名视图，这在同时展示多个视图的情况下很有用。
&lt;template&gt; &lt;div&gt; &lt;router-view name="header"&gt;&lt;/router-view&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;router-view name="footer"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 在路由配置中，对应的路由定义也需要添加 components 字段：
const routes = [ { path: '/', components: { default: Home, header: Header, footer: Footer } } ]; 动态组件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d92ffed25265adaa6c50db711d692c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f49ab5b2d1552f24b3fea74d107f1cc/" rel="bookmark">
			用JAVA实现樱花飘落
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用java实现一个樱花飘落的方法
package Text2; import javax.swing.*; import java.awt.*; import java.util.ArrayList; import java.util.List; public class Sakura extends JFrame { private List&lt;Point&gt; sakuraList; // 樱花的位置列表 public Sakura() { sakuraList = new ArrayList&lt;&gt;(); setTitle("Sakura Falling"); setSize(800, 600); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLocationRelativeTo(null); SakuraPanel panel = new SakuraPanel(); add(panel); generateSakura(); // 生成随机的樱花位置 setVisible(true); startFalling(); // 开始樱花飘落 } // 生成随机的樱花位置 private void generateSakura() { for (int i = 0; i &lt; 100; i++) { // 生成100朵樱花 int x = (int) (Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f49ab5b2d1552f24b3fea74d107f1cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0eddce032c77f4e6e2c662a5c881298/" rel="bookmark">
			Linux 下查看内存使用情况方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做Linux系统优化的时候，物理内存是其中最重要的一方面。自然的，Linux也提供了非常多的方法来监控宝贵的内存资源的使用情况。下面的清单详细的列出了Linux系统下通过视图工具或命令行来查看内存使用情况的各种方法。
1./proc/meminfo 查看RAM使用情况最简单的方法是通过 /proc/meminfo。这个动态更新的虚拟文件实际上是许多其他内存相关工具(如：free / ps / top)等的组合显示。/proc/meminfo列出了所有你想了解的内存的使用情况。进程的内存使用信息也可以通过 /proc/&lt;pid&gt;/statm 和 /proc/&lt;pid&gt;/status 来查看。
\$ cat /proc/meminfo
2.atop atop命令是一个终端环境的监控命令。它显示的是各种系统资源（CPU, memory, network, I/O, kernel）的综合，并且在高负载的情况下进行了彩色标注。
\$ sudo atop
3.free free命令是一个快速查看内存使用情况的方法，它是对 /proc/meminfo 收集到的信息的一个概述。
\$ free -h
4.GNOME System Monitor GNOME System Monitor 是一个显示最近一段时间内的CPU、内存、交换区及网络的使用情况的视图工具。它还提供了一种查看CPU及内存使用情况的方法。
\$ gnome-system-monitor
5.htop htop命令显示了每个进程的内存实时使用率。它提供了所有进程的常驻内存大小、程序总内存大小、共享库大小等的报告。列表可以水平及垂直滚动。
\$ htop
6.KDE System Monitor 功能同 4 中介绍的GENOME版本。
\$ ksysguard
7.memstat memstat是一个有效识别 executable(s), process(es) and shared libraries使用虚拟内存情况的命令。给定一个进程ID，memstat可以列出这个进程相关的可执行文件、数据和共享库。
\$ memstat -p \&lt;PID&gt;
8.nmon nmon是一个基于ncurses的系统基准测试工具，它可以监控CPU、内存、I/O、文件系统及网络资源等的互动模式。对于内存的使用，它可以实时的显示 总/剩余内存、交换空间等信息。
\$ nmon
9.ps ps命令可以实时的显示各个进程的内存使用情况。Reported memory usage information includes %MEM (percent of physical memory used), VSZ (total amount of virtual memory used), and RSS (total amount of physical memory used)。你可以使用 “–sort”选项对进程进行排序，例如按RSS进行排序：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0eddce032c77f4e6e2c662a5c881298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d25b9bf32465566eb2466d247de14c0/" rel="bookmark">
			AI嵌入式1——君正T40之基础使用篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、君正T40参数二、使用步骤1.putty安装配置使用 前言 近年来，随着深度学习的突破，人工智能得到了快速发展。人工智能作为一种通用计算技术，正在与各行各业融合，正在世界上掀起又一场工业革命。
嵌入式系统是指“嵌入”在应用中的计算机系统。嵌入式系统和传统PC的不同之处在于它通常针对特定应用配备专用软硬件接口，在运算速度、存储容量、可靠性、功耗、体积方面的要求和通用PC有明显差别。我们在日常生活中随处可见嵌入式系统，比如智能手机、万用表、无人机控制系统、电信交换机、洗衣机、智能电视、汽车控制系统、医用CT设备等。
NPU是神经网络处理器Neural Processing Unit的缩写，是一种专门用于加速人工智能应用的芯片。它可以在较短的时间内完成大量的计算任务，从而提高了人工智能应用的效率和速度，可以大幅提高人工智能应用的运行速度和效率。其次，它可以降低计算成本，因为使用NPU进行计算比使用传统CPU或GPU更加节省时间和资源。此外，NPU还可以提高系统的稳定性和可靠性，因为它可以减少由于计算错误而导致的系统崩溃或故障。
一、君正T40参数 Ingenic AIE在计算效率和灵活性方面都很好，这意味着它具有很高的计算能力和可编程性。这种灵活性确保了AIE与各种和发展中的神经网络架构良好配合，而低比特量化技术进一步提升了Ingenic AIE的AI计算能力，其具有低功耗和低带宽的特点。
为了更好地匹配主流的深度神经网络，Ingenic AIE核心包含了不同维度和强度的指令。在灵活的同时，AIE核心可以被编程以加速卷积、池化和其他计算。
Ingenic AIE内核支持低比特量化，因此可以根据不同场景的需要，提供不同的计算能力和不同的计算分辨率。
集成了模型训练、模型转换和优化以及模型部署和诱导，Magik是面向边缘AI应用的深度神经网络的一体化开放平台。
主流模型训练插件、模型优化转换工具链、诱导固件以及自主研发的算法和应用参考库Model Zoo都集成在了与人工智能行业共同进化的平台中。
通过Ingenic Magik AIE SDK，开发人员可以将模型部署到运行在Ingenic SoC上的AIE中，这些模型可以构建在不同深度学习架构上。在开发资源可以更经济地使用的同时，应用产品可以更快地发布。
二、使用步骤 1.putty 安装 使用在线安装putty：
sudo apt-get install putty 配置 输入即可运行（因为要操作串口设备文件，需要超级用户权限）：
sudo putty 检查串口tty名，输入命令：
dmesg 查看串口状态，输入命令：
ls /dev/ttyUSB* 如果提示
ls: 无法访问'/dev/ttyUSB': 没有那个文件或目录 可能是USB口没有连接，或者brltty驱动占用问题，建议插拔usb口或者更换usb接口。
正常情况下：
OK，证明串口线连上了，设备文件名是ttyUSB0
然后连接到USB转串口：
1）. Connection type选择 “Serial”
2）. Serial line:“/dev/ttyUSB0”, 将第二步查看到的串口号输入
3）. Speed： 115200
4）. 按下“Open”,即完成Putty的设定
使用 使用putty连接开发板后，重启电源或按下开发板的复位键，可以看到linux开发板的开机信息：
提示登录，输入root，进入管理员模式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4412897c8abf1a370a8e3761adec3a78/" rel="bookmark">
			【RabbitMQ】3 RabbitMQ使用及交换机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 代码示例交换机概述无名交换机绑定（binding）交换机的类型FanoutDirectTopic 官网地址：https://www.rabbitmq.com/getstarted.htm 代码示例 先来看下如何使用rabbitmq：
使用 Java 编写两个程序，发送单个消息的生产者和接收消息并打印出来的消费者。
在下图中，P 是生产者，C 是消费者，中间的框是一个队列（代表使用者保留的消息缓冲区）。
生产者：
import cn.hutool.core.map.MapUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.concurrent.TimeoutException; /** * 生产者 */ public class Producer { /** * 队列的名称 */ public static final String QUEUE_NAME = "hello"; public static void main(String[] args) throws IOException, TimeoutException { // 创建连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); // 设置连接 RabbitMQ 的信息 connectionFactory.setHost("192.168.65.137"); connectionFactory.setVirtualHost("/"); connectionFactory.setPort(5672); connectionFactory.setUsername("guest"); connectionFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4412897c8abf1a370a8e3761adec3a78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3def03065f16b9073a8da39ec720dc5/" rel="bookmark">
			数据库备份和恢复以及配置优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
备份方法
备份策略
完全备份
完全恢复
增量备份
断点恢复
MySQL配置优化
参数汇总：
1）连接请求的变量
2）缓冲区变量
3）配置Innodb的几个变量
参数汇总：
备份方法 物理备份：直接对数据库的物理文件（数据文件、日志文件等）进行备份
逻辑备份：对数据库的库和表对象以SQL语言的形式导出进行备份
备份策略 完全备份：每次备份都备份完整的库或者表数据
差异备份：只备份上一次完全备份后的更新数据
增量备份：每次备份只备份上一次完全备份或增量备份后的更新数据
数据库上云迁移 冷迁移 物理冷备 先关闭数据库，再打包备份+恢复
热迁移 阿里云 DTS
完全备份 物理冷备：先关闭数据库，使用tar命令打包备份数据库的数据目录和文件 mysql/data/
mysqldump逻辑热备
mysqldump -uXXX -pXXX --databases 库1 [库2 ....] &gt; XXX.sql 备份一个或多个库及库中所有的表数据
mysqldump -uXXX -pXXX --all-databases &gt; XXX.sql 备份所有的库
mysqldump -uXXX -pXXX 库名 &gt; XXX.sql 备份指定库中的所有的表数据，不包含库对象
mysqldump -uXXX -pXXX 库名 表1 [表2 ....] &gt; XXX.sql 备份指定库中的一个或多个表数据，不包含库对象
xtrabackup物理热备
完全恢复 先登录到数据库，再执行 source XXX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3def03065f16b9073a8da39ec720dc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb53dec7c7004194f2b3c2e96610251d/" rel="bookmark">
			C&#43;&#43;qt-信号-信号槽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概念 信号和槽是两种函数，这是Qt在C++基础上新增的特性，类似于其他技术中的回调的概念。
信号和槽通过程序员提前设定的“约定”，可以实现对象之间的通信，有两个先决的条件：
通信的对象必须都是从QObject类中派生出来的。类中要有Q_OBJECT宏。 2、函数原型 信号槽需要在使用前进行“约定”，这个约定被称为连接。
【例子】：如果金龙考试考了100分，新宇请金龙吃饭。
// 参数1：const QObject * sender 发射者，表示因发起对象 // 参数2：const char * signal信号函数，表示因的发起动作，使用SIGNAL()包裹。 // 参数3：const QObject * receiver 接收者，表示果的发起对象 // 参数4：const char * method 槽函数，表示果发起的动作，请吃饭，SLOT()包裹。 QObject:: connect(const QObject * sender, const char * signal, const QObject * receiver, const char * method)[static] 3、实现 为了学习，把信号槽分为三种实现方式。
自带信号 -&gt; 自带槽自带信号 -&gt; 自定义槽自定义信号 3.1 自带信号-&gt;自带槽 这种连接方式是最简单的，因为信号函数和槽函数都是Qt内置的，只需要在文档中查询出函数后，使用connect函数连接即可。
查找函数 F1F1 查找手册 查找函数：在对应的QPushButton Class基类继承自（QAbstractButton）类，查找自带槽（Public Slots），找到对应槽函数（click），
// 按钮按下后时发射的信号 void QAbstractButton:: clicked(bool checked = false)[signal] 查询函数：在对应的Widget基类查找自带槽（Public Slots），找到对应槽函数（close），
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb53dec7c7004194f2b3c2e96610251d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caff3e03089e88274ebc574ff265df05/" rel="bookmark">
			LeetCode 36 有效的数独
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 有效的数独
请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 注意：
一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。空白格用 '.' 表示。 示例 1：
输入：board = [["5","3",".",".","7",".",".",".","."] ,["6",".",".","1","9","5",".",".","."] ,[".","9","8",".",".",".",".","6","."] ,["8",".",".",".","6",".",".",".","3"] ,["4",".",".","8",".","3",".",".","1"] ,["7",".",".",".","2",".",".",".","6"] ,[".","6",".",".",".",".","2","8","."] ,[".",".",".","4","1","9",".",".","5"] ,[".",".",".",".","8",".",".","7","9"]] 输出：true 示例 2：
输入：board = [["8","3",".",".","7",".",".",".","."] ,["6",".",".","1","9","5",".",".","."] ,[".","9","8",".",".",".",".","6","."] ,["8",".",".",".","6",".",".",".","3"] ,["4",".",".","8",".","3",".",".","1"] ,["7",".",".",".","2",".",".",".","6"] ,[".","6",".",".",".",".","2","8","."] ,[".",".",".","4","1","9",".",".","5"] ,[".",".",".",".","8",".",".","7","9"]] 输出：false 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 提示：
board.length == 9board[i].length == 9board[i][j] 是一位数字（1-9）或者 '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caff3e03089e88274ebc574ff265df05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436ebf735c2ff77c6970afa50b5eafb0/" rel="bookmark">
			Redis 常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Redis常用的5种数据类型 字符串（String）：最基本的数据类型，可以存储字符串、整数或浮点数。哈希（Hash）：键值对的集合，可以在一个哈希数据结构中存储多个字段和值。列表（List）：按照插入顺序存储一组有序的值，可以在列表的两端执行插入、删除和访问操作。集合（Set）：无序的唯一值的集合，支持对集合执行添加、删除和集合间的交集、并集、差集等操作。有序集合（Sorted Set）：也叫Zset，类似于集合，但每个成员都关联着一个分数（score），可以根据分数对成员进行排序，同时保持唯一性。 二、String类型 常用操作
SET key value：设置指定 key 的值为给定的 value。GET key：获取指定 key 的值。DEL key：删除指定的 key。MSET key value [key value ...]：批量设置key value。MGET key [key ...]：批量获得key value。SETEX key seconds value：设置指定 key 的值，并指定过期时间（以秒为单位）。SETNX key value：设置 key 不存在的key value，如果key存在，那么当前value不会覆盖已存在key的value。STRLEN key：返回指定 key 的值的长度。 原子加减操作：
INCR key：将指定 key 的值加 1。DECR key：将指定 key 的值减 1。INCRBY key increment：将指定key的value与increment相加，只针对数字类型。DECEBY key decrement：将指定key的value减去decrement，只针对数字类型。APPEND key value：将指定 value 追加到指定 key 的值末尾。GETSET key value：设置指定 key 的新值，并返回旧值。 单值缓存操作：
SET key valueGET key 对象缓存操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/436ebf735c2ff77c6970afa50b5eafb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b2ecb0f4f0f0ea87d4410f9c07abc3/" rel="bookmark">
			模型评估：评估指标的局限性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“没有测量，就没有科学。”这是科学家门捷列夫的名言。在计算机科学特别是机器学习领域中，对模型的评估同样至关重要。只有选择与问题相匹配的评估方法，才能快速地发现模型选择或训练过程中出现的问题，迭代地对模型进行优化。模型评估主要分为离线评估和在线评估两个阶段。针对分类、排序、回归、序列预测等不同类型的机器学习问题，评估指标的选择也有所不同。知道每种评估指标的精确定义、有针对性地选择合适的评估指标、根据评估指标的反馈进行模型调整，这些都是机器学习在模型评估阶段的关键问题，也是一名合格的算法工程师应当具备的基本功。
在模型评估过程中，分类问题、排序问题、回归问题往往需要使用不同的指标进行评估。在诸多评估指标中，大部分指标只能片面地反映模型的一部分性能。如果不能合理地运用评估指标，不仅不能发现模型本身的问题，而且会得出错误的结论。
1.准确率的局限性 假设公司客户希望把产品定向投放给目标用户。而公司通过第三方渠道拿到一部分目标用户的数据，并以此为训练集和测试集，训练和测试目标用户的分类模型。该模型的分类准确率超过了95%，但在实际广告投放过程中，该模型还是把大部分广告投给了非目标用户。这可能是什么原因造成的？
在解答该问题之前，我们首先回顾一下分类准确率的定义。准确率是指分类正确的样本占总样本个数的比例，即
其中，为被正确分类的样本个数，为总样本个数。
准确率是分类问题中最简单，也是最直观的评价指标，但存在明显的缺陷。比如，当负样本占99%时，分类器把所有样本都预测为负样本也可以获得99%的准确率。所以当不同类别的样本比例非常不均衡时，占比大的类别往往称为影响准确率的最主要因素。
明确了这一点，这个问题也就迎刃而解了。第三方数据给的目标用户只占全体用户的一小部分，虽然模型的分类准确率高，但是不代表对目标用户整体的分类准确率也很高。在线上投放过程中，我们只会对模型判定的“目标用户”进行投放，因此，对目标用户判定的准确率不够高的问题就被放大了。为了解决这个问题，可以使用更为有效地平均准确率（每个类别下的样本准确率的算术平均）作为模型评估的指标。
事实上，这是一道比较开放的问题，可以根据遇到的问题一步步地排查原因。标准答案也不限于指标的选择，即使评估指标选择对了，仍会存在模型过拟合或欠拟合、测试集和训练集划分不合理、线下评估与线上测试的样本分布存在差异等一系列问题，但评估指标的选择是最容易被发现，也是最可能影响评估结果的因素。
2.精确率与召回率的权衡 假设公司提供视频的模糊搜索功能，搜索排序模型返回的Top5的精确率非常高，但在实际使用过程中，用户还是经常找不到想要的视频，特别是一些比较冷门的剧集，这可能是哪个环节出了问题呢？
要回答这个问题，首先明确两个概念，精确率和召回率。
精确率（Precision）是指分类正确的正样本个数占分类器判定为正样本的样本个数的比例。召回率（Recall）是指分类正确的正样本个数占真正的正样本个数的比例 在排序问题中，通常没有一个确定的阈值把得到的结果直接判定为正样本或负样本，而是采用Top N返回结果的Precision值和Recall指来衡量排序模型的性能，即认为模型返回的Top N 的结果就是模型判定的正样本，然后计算前N个位置上的准确率Precision@N和前N个位置上的召回率Recall@N。
Precision值和Recall值是既矛盾又统一的两个指标，为了提高Precision值，分类器需要尽量在“更有把握”时才把样本预测为正样本，但此时往往会因为过于保守而漏掉很多“没有把握”的正样本，导致Recall值降低。
回到问题中来，模型返回的Precision@5的结果非常好，也就是说排序模型Top5的返回值的质量是很高的。但在实际应用过程中，用户为了找一些冷门的视频，往往会寻找排在较靠后位置的结果，甚至翻页去查找目标视频。但根据题目描述，用户经常找不到想要的视频，这说明模型没有把相关的视频都找出来呈现给用户。显然，问题出现在召回率上：如果相关结果有100个，即使Precision@5达到了100%，而Recall@5却仅仅只有5%。在模型评估时，我们是否应该同时关注Precision值和Recall值？是否应该选取更高阶的评估指标来更全面地反映模型在Precision值和Recall值两方面的表现？
答案都是肯定的，为了综合评估一个排序模型的好坏，不仅要看模型在不同Top N下的Precision@N和Recall@N，而且最好绘制出模型的P-R（Precision-Recall）曲线。这里简单介绍一下P-R曲线的绘制方法。
P-R曲线的横轴是召回率，纵轴是精确率。对于一个排序模型来说，其P-R曲线上的一个点代表着，在某一阈值下，模型将大于该阈值的结果判定为正样本，小于该阈值的结果判定为负样本，此时返回结果对应的召回率和精确率。整条P-R曲线是通过将阈值从高到低移动而生成的。图2.1是P-R曲线样例图，其中实线代表模型A的P-R曲线，虚线代表模型B的P-R曲线。原点附近代表当阈值最大时模型的精确率和召回率。
由图可见，当召回率接近于0时，模型A的精确率为0.9，模型B的精确率是1，这说明模型B得分前几位的样本全部是真正的正样本，而模型A即使得分最高的几个样本也存在预测错误的情况。并且，随着召回率的增加，精确率整体呈下降趋势。但是，当召回率为1时，模型A的精确率反而超过了模型B。这充分说明，只用某个点对应的精确率和召回率是不能全面地衡量模型的性能，只有通过P-R曲线的整体表现，才能够对模型进行更为全面的评估。
除此之外，F1score和ROC曲线也能综合地反映一个排序模型的性能。F1score是精确率和召回率的调和平均值，它定义为
3.平方根误差的意外 假设一家流媒体公司，拥有众多的美剧资源，预测每部美剧的流量趋势对于广告投放、用户增长都非常重要。我们希望构建一个回归模型来预测某部美剧的流量趋势，但无论采用哪种回归模型，得到的RMSE指标都非常高。然而事实是，模型在95%的时间区间内的预测误差都小于1%，取得了相当不错的预测结果。那么，造成RMSE指标居高不下的最可能原因是什么？
RMSE经常被用来衡量回归模型的好坏，但按照题目的叙述，RMSE这个指标却失效了。先看一下RMSE的计算公式为
其中，yi 是第 i 个样本点的真实值， 是第 i 个样本点的预测值，n是样本点的个数。
一般情况下，RMSE能够很好地反映回归模型预测值与真实值的偏离程度。但在实际问题中，如果存在个别偏离程度非常大的利群点（Outlier）时，即使离群点数量非常少，也会让RMSE指标变得很差。
回到问题中来，模型在95%的时间区间内的预测误差都小于1%，这说明，在大部分时间区间内，模型的预测效果都是非常优秀的。然而，RMSE却一直很差，这很可能是由于在其他的5%时间区间内存在非常严重的离群点。事实上，在流量预估这个问题中，噪声点确实是很容易产生的，比如流量特别小的美剧、刚上映的美剧或者刚获奖的美剧，甚至一些相关社交媒体突发事件带来的流量，都可能会造成离群点。
针对这个问题，有什么解决方案呢？可以从三个角度来思考。
第一，如果我们认定这些离群点是噪声点的话，就需要在数据预处理的阶段把这些噪声点过滤掉。
第二，如果不认为这些离群点是噪声点的话，就需要进一步提高模型的预测能力，将离群点产生的机制建模进去（这又是一个宏大的话题）。
第三，可以找一个更合适的指标来评估该模型。关于评估指标，其实是存在比RMSE的鲁棒性更好的指标，比如平均绝对百分比误差（Mean Absolute Percent Error, MAPE），它定义为
相比RMSE，MAPE相当于把每个点的误差进行了归一化，降低了个别离群点带来的绝对误差的影响。
总结：本文基于三个假想的实际应用场景和遇到的问题，说明了选择合适的评估指标的重要性。每个评估指标都有其价值，但如果只从单一的评估指标出发去评估模型，往往会得出片面甚至错误的结论；只有通过一组互补的指标去评估模型，才能更好地发现并解决模型存在的问题，从而更好地解决实际业务场景中遇到的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2248c91bcf704e6808afa3e8faabc63c/" rel="bookmark">
			Redis服务器配置文件的常用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 网络配置 bind 127.0.0.1 # 绑定的IP地址，默认为本地回环地址，0.0.0.0表示监听所有地址
port 6379 # 监听的端口号，默认为6379
tcp-backlog 511 # TCP连接的backlog队列长度，默认为511
tcp-keepalive 0 # 是否开启TCP keepalive功能，默认为0
timeout 0 # 客户端连接的超时时间，单位秒，0表示无限制
# 通用配置 daemonize no # 是否以守护进程方式运行，默认为no
logfile "" # 日志文件路径，默认为空，表示不输出到文件
pidfile /var/run/redis_6379.pid # PID文件路径，默认为/var/run/redis_6379.pid
databases 16 # 数据库数量，默认为16
# 持久化配置 save 900 1 # 在900秒内，如果至少有1个key发生了变化，则执行一次RDB持久化
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes # 如果持久化过程中出现错误，是否停止写入
rdbcompression yes # 是否使用RDB文件压缩，默认为yes
rdbchecksum yes # 是否开启RDB文件校验，默认为yes
dir /var/dump/ # RDB文件和AOF文件的存储目录，默认为/var/dump/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2248c91bcf704e6808afa3e8faabc63c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7991696078b3e6dee429f389c0de446/" rel="bookmark">
			开源大数据集群部署（三）集群mysql数据库部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源大数据集群部署（一）集群实施规划
开源大数据集群部署（二）集群基础环境实施准备
作者：櫰木
本文将介绍mysql部署，其中在hd1.dtstack.com主机root权限下安装配置
1 解压文件 解压名为mysql-8.0.31-linux-glibc2.12-x86_64.tar.xz的压缩包，其内容解压到/opt/目录下。然后通过符号链接将目录/opt/mysql-8.0.31-linux-glibc2.12-x86_64/链接到/opt/mysql。
tar -xvJf mysql-8.0.31-linux-glibc2.12-x86_64.tar.xz -C /opt/ ln -s /opt/mysql-8.0.31-linux-glibc2.12-x86_64/ /opt/mysql 2 配置文件 mysql配置文件/etc/my.cnf包含了一系列参数和设置，用于配置MySQL服务器的行为和性能，具体配置内容如下：
[client] port = 3306 socket = /data/mysql8/data/mysql.sock [mysql] prompt = "\u@mysql \R:\m:\s [\d]&gt;" port = 3306 socket = /data/mysql8/data/mysql.sock [mysqld] # 用户 user = mysql # # 端口 port = 3306 # # 安装目录 basedir = /opt/mysql # # 数据目录 datadir = /data/mysql57/data # # sock 文件目录 socket = /data/mysql57/data/mysql.sock # # 临时文件目录 tmpdir = /data/mysql57/tmp # # 错误日志目录 log-error = /data/mysql57/logs/error.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7991696078b3e6dee429f389c0de446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42965909f9db8ded26da4220ffabc0db/" rel="bookmark">
			Python中的科学计算和数学建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的科学计算和数学建模
Python作为一种通用编程语言，在科学计算和数学建模领域有着广泛的应用。通过Python，科学家、工程师和研究人员可以进行复杂的数据分析、建模和可视化。
一、Python中的科学计算
Python的科学计算库非常丰富，其中最著名的要数NumPy和SciPy。这些库提供了大量的数学函数和算法，可以用于进行各种科学计算。
NumPy库 NumPy是Python中用于进行科学计算的基础库，提供了多维数组对象、数学函数以及强大的矩阵运算功能。
示例代码：使用NumPy创建数组并进行数学运算
python复制代码
import numpy as np # 创建数组 a = np.array([1, 2, 3]) b = np.array([4, 5, 6]) # 进行数学运算 c = a + b # 加法 d = a * b # 乘法 e = np.sum(a) # 求和 f = np.mean(a) # 平均值 SciPy库 SciPy是一个用于解决科学计算中各种问题的库，包括数学、物理、工程等方面的计算。SciPy基于NumPy，提供了更多的高级算法和工具。
示例代码：使用SciPy求解一元二次方程的根
python复制代码
import numpy as np from scipy.optimize import root # 定义一元二次方程 f(x) = x^2 - 2x - 3 = 0 def equation(x): return x**2 - 2*x - 3 # 使用SciPy求解方程的根 solutions = root(equation, 1) # 从x=1开始搜索根 print(solutions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42965909f9db8ded26da4220ffabc0db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a965e2485679f526832d69339dd18705/" rel="bookmark">
			使用Java读取Excel文件，实现数据批处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 通过编程方式读取Excel数据能实现数据导入、批量处理、数据比对和更新等任务的自动化。这不仅可以提高工作效率还能减少手动处理的错误风险。此外读取的Excel数据可以与其他系统进行交互或集成，实现数据的无缝传输和共享，满足特定项目的需求。本文将从以下三个方面介绍如何通过Java读取Excel文件中的数据。
读取某个单元格中的数据读取指定单元格范围的数据读取Excel工作表中的数据 二、免费Java库 2.1 安装： 操作Excel的免费Java库为 Free Spire.XLS for Java。该免费库在读写 .xls 格式的 Excel 文档时，有每个文档 5 个工作表，每个工作表 200 行的限制。但在读写 .xlsx 格式的 Excel 文档时是没有任何限制。
我么可以从下面链接下载产品包后手动引入jar包或者直接通过Maven仓库安装也可。
下载免费Java Excel控件https://www.e-iceblue.cn/Downloads/Free-Spire-XLS-JAVA.html
2.2 读取Excel数据的核心方法： 要读取Excel单元格、单元格范围、或者Excel工作表中的数据，我们需要用到Free Spire.XLS for Java库提供的以下接口：
Workbook类、Worksheet类：分别用于代表 Excel 工作簿、和工作簿中的工作表。
CellRange类：用于代表某个特定的单元格或单元格区域。
Worksheet.getCellRange(String name) 方法：获取某个单元格或单元格区域并返回 CellRange 对象。
Worksheet.getAllocatedRange() 方法：获取工作表中包含数据的单元格区域，并返回 CellRange 对象。
CellRange.getValue() 方法：获取单元格中的数值或文本值。（如果单元格有公式，该方法会返回公式而不是公式计算的结果）
三、Java代码示例 3.1 使用Java 读取某个单元格的数据 import com.spire.xls.CellRange; import com.spire.xls.Workbook; import com.spire.xls.Worksheet; public class ReadData { public static void main(String[] args) { //创建Workbook对象 Workbook wb = new Workbook(); //加载Excel文件 wb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a965e2485679f526832d69339dd18705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a222d3d3108871978e28c321af4dad6/" rel="bookmark">
			MySQL半同步复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MySQL主从复制的几个同步模式：
●异步复制（Asynchronous replication）
●全同步复制（Fully synchronous replication）
●半同步复制（Semisynchronous replication）
//主数据库配置
//从数据库配置
#主数据库执行
#从数据库执行（此时可能还是OFF状态，需要在下一步重启IO线程后，从库半同步状态才会为ON）
#重启从数据库上的IO线程
#在主库查询半同步状态
MySQL主从复制的几个同步模式： ●异步复制（Asynchronous replication） MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。
●全同步复制（Fully synchronous replication） 指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。
●半同步复制（Semisynchronous replication） 介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。
//主数据库配置 vim /etc/my.cnf #在 [mysqld] 区域添加下面内容
......
plugin-load=rpl_semi_sync_master=semisync_master.so #加载mysql半同步复制的插件
rpl_semi_sync_master_enabled=ON #或者设置为"1"，即开启半同步复制功能
rpl-semi-sync-master-timeout=1000 #超时时间为1000ms，即1s
systemctl restart mysqld
//从数据库配置 vim /etc/my.cnf ......
plugin-load=rpl_semi_sync_slave=semisync_slave.so
rpl_semi_sync_slave_enabled=ON
systemctl restart mysqld
//查看半同步是否在运行
#主数据库执行 show status like 'Rpl_semi_sync_master_status';
show variables like 'rpl_semi_sync_master_timeout';
#从数据库执行（此时可能还是OFF状态，需要在下一步重启IO线程后，从库半同步状态才会为ON） show status like 'Rpl_semi_sync_slave_status';
#重启从数据库上的IO线程 STOP SLAVE IO_THREAD;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a222d3d3108871978e28c321af4dad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ccaccc05ae51c7f28634604d80c4c8a/" rel="bookmark">
			solr8.4配置用户登录验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、增加用户名称密码配置 进入目录：solr-8.4/server/etc目录下，增加user.properties文件。这个文件一会要配置到solr-jetty-context.xml文件中。
user.properties文件增加如下内容：
# 用户名：密码，权限 admin: admin123.,admin user: user123.,admin 二、配置solr-jetty-context.xml文件 在这个solr-8.4\server\contexts目录下只有一个文件，就是它了。打开文件，增加如下内容：
&lt;!-- 添加配置权限认证：在文件configure中添加获取用户文件的配置，内容如下： --&gt; &lt;Get name="securityHandler"&gt; &lt;Set name="loginService"&gt; &lt;New class="org.eclipse.jetty.security.HashLoginService"&gt; &lt;!-- name与web.xml中realm-name一致即可 --&gt; &lt;Set name="name"&gt;user-name&lt;/Set&gt; &lt;!-- user.properties与上面新建的文件保持同名即可 --&gt; &lt;Set name="config"&gt;&lt;SystemProperty name="jetty.home" default="."/&gt;/etc/user.properties&lt;/Set&gt; &lt;/New&gt; &lt;/Set&gt; &lt;/Get&gt; 添加后的整个文件内容如下：
&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE Configure PUBLIC "-//Jetty//Configure//EN" "http://www.eclipse.org/jetty/configure_9_0.dtd"&gt; &lt;Configure class="org.eclipse.jetty.webapp.WebAppContext"&gt; &lt;Set name="contextPath"&gt;&lt;Property name="hostContext" default="/solr"/&gt;&lt;/Set&gt; &lt;Set name="war"&gt;&lt;Property name="jetty.base"/&gt;/solr-webapp/webapp&lt;/Set&gt; &lt;Set name="defaultsDescriptor"&gt;&lt;Property name="jetty.base"/&gt;/etc/webdefault.xml&lt;/Set&gt; &lt;Set name="extractWAR"&gt;false&lt;/Set&gt; &lt;!-- 添加配置权限认证：在文件configure中添加获取用户文件的配置，内容如下： --&gt; &lt;Get name="securityHandler"&gt; &lt;Set name="loginService"&gt; &lt;New class="org.eclipse.jetty.security.HashLoginService"&gt; &lt;!-- name与web.xml中realm-name一致即可 --&gt; &lt;Set name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ccaccc05ae51c7f28634604d80c4c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030f4b1656b5aa20f4f97cdfe7fed067/" rel="bookmark">
			SQL EXISTS 运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EXISTS 运算符 EXISTS 运算符用于判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False。
SQL EXISTS 语法 SELECT column_name(s) FROM table_name WHERE EXISTS (SELECT column_name FROM table_name WHERE condition); 含义：
当exist（）子句内的查询结果存在时，返回true，执行外层SQL语句。
当exist（）子句内的查询结果不存在时，返回false，不执行外层SQL语句。
使用频率：exists（）子句使用频率很低，很少用到。
当你只需要判断后面的查询结果是否存在时，使用exists()。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1803576fa66d0253ac6603d2e3b1ef/" rel="bookmark">
			R语言【sp】——SpatialPoints()：创建类SpatialPoints或SpatialPointsDataFrame的对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Package sp version 1.5-0
Description 从坐标或数据帧的坐标创建类 SpatialPoints-class 或 SpatialPointsDataFrame-class 的对象。
Usage SpatialPoints(coords, proj4string=CRS(as.character(NA)), bbox = NULL) SpatialPointsDataFrame(coords, data, coords.nrs = numeric(0), proj4string = CRS(as.character(NA)), match.ID, bbox = NULL) Arguments 参数【coords】：带有坐标的数字矩阵或数据帧（每行是一个点）；在 SpatialPointsDataFrame 的情况下，也允许一个 SpatialPoints-class 类的对象。
参数【proj4string】：CRS 类的投影字符串。
参数【bbox】：边界框矩阵，通常为 NULL，由数据构造，但如果明确需要，可以通过强制转换。
参数【data】：类 data.frame 的对象；数据中的行数应该等于坐标对象中的点数。
参数【coords.nrs】：数值型；如果存在，则记录数据中获取坐标的列位置（由 coordinates &lt;- 使用)。
参数【match.ID】：逻辑值或字符值。如果缺少，并且参数【coords】和参数【data】都有行名，并且它们的顺序不对应，则由这些行名进行匹配并发出警告；可以通过设置参数【match.ID】来抑制此警告。如果为 TRUE 且 参数【coords】具有非自动行名（即，由 as.matrix 强制到矩阵，dimnames(coordinates)[[1]] 不是 NULL)， 并且参数【data】有行名（即一个 data.frame），那么 SpatialPointsDataFrame 对象通过匹配两个组件的行名而形成，保持坐标的顺序不变。检查两个行名是否足够唯一，以及所有数据是否匹配。如果为 FALSE，坐标和数据简单地 “粘合” 在一起，忽略行名。如果是字符值：表示参数【data】中有表示坐标 id 的列，用于匹配记录。
Value SpatialPoints 返回一个 SpatialPoints 类的对象；返回一个 SpatialPointsDataFrame 类的对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52575cbc8b614bdb47b6261ca2067c2/" rel="bookmark">
			《计算机网络》 第七章 网络安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7.1 网络安全问题的概述 7.1.1 计算机网络面临的安全性威胁 两大威胁：①被动攻击 ②主动攻击（篡改、恶意程序、拒接服务DoS）
对付被动攻击：加密技术
对付主动攻击：加密技术+ 鉴别技术
7.1.2 安全的计算机网络 四个目标：①保密性 ②端点鉴别（身份验证） ③信息完整性 ④运行安全性（访问控制）
7.1.3 数据加密模型 7.2 两类密码体制 7.2.1 对称密钥密码体制 加密密钥和解密密钥使用相同密钥的体制
例如：DES（分组密码，密钥保密算法公开）、三重DES、高级加密标准AES
7.2.1 公钥密码体制 使用不同的加密密钥和解密密钥
产生原因：对称密钥密码体制的密钥分配问题、数字签名需求
应用：RSA
7.3 鉴别 报文鉴别: 对每一个收到的报文都要鉴别报文的发送者
实体鉴别:在系统接入的全部持续时间内，对和自己通信的对方实体只需验证一次
7.3.1 报文鉴别 鉴别方法：①数字签名进行鉴别 ②密码散列函数鉴别 ③报文鉴别码鉴别
7.3.2 实体鉴别 ①使用共享对称密钥实现实体鉴别
7.4 密钥分配 7.4.1 对称密钥的分配 设立密钥分配中心 KDC：给需要进行秘密通信的用户临时分配一个会话密钥 （仅用一次）
7.4.2 公钥的分配 在公钥密码体制中，如果每个用户都具有其他用户的公钥，就可实现安全通信但不能随意公布用户的公钥。
方法：借助可信任的第三方机构（CA）
7.5 互联网使用的安全协议 7.5.1 网络层安全协议 IP不具备任何安全性，无法保证①数据机密性 ②数据完整性 ③数据来源认证
IPsec 提供了标准、健壮且包含广泛的机制保证IP 层安全
1.IPsec协议族概述 IPsec不是单一协议，而是协议族
IPsec 是个框架:允许通信双方选择合适的算法和参数
三部分组成：
①IP安全数据报格式：
鉴别首部AH协议（提供源点鉴别和数据完整性，但不能保密）封装安全有效载荷ESP协议（提供源点鉴别和数据完整性，保密） ②加密算法：三个协议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b52575cbc8b614bdb47b6261ca2067c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0574ebd8d87a452f1843cb434d5f341a/" rel="bookmark">
			Linux入门攻坚——12、Linux网络属性配置相关知识2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7网络属性配置：
传统命名机制：以太网eth[0,1,2,...]，wlan[0,1,2...]
可预测功能的命名机制：
udev支持多种不同的命名方案：
Firmware ，拓扑结构
在对待设备文件这块，Linux改变了几次策略。早期，设备文件仅仅是一些带有适当的属性集的普通文件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs,一个基于内核的动态设备文件系统，他首次出现在2.3.46 内核中。devfs创建的设备文件是动态的。但是devfs有一些严重的限制，从 2.6.13版本后移走了。目前取代他的便是udev－－一个用户空间程序。
在工作中多次碰到这样的要求：linux系统中原来有一块SCSI硬盘，系统分配的设备文件是/dev/sda。现在新增加了一个外置的磁盘阵列，通过SCSI卡连接。但接上这个磁盘阵列后，/dev/sda变成了磁盘阵列的硬盘了，原来内置的SCSI硬盘变成了 /dev/sdb，现在希望将设备文件固定下来。过去，这个比较麻烦，因为/dev/sda等文件都是linux内核自动分配的。很难固定下来，除非你更改加载SCSI卡驱动程序的顺序，让内置硬盘连接的SCSI卡比外接磁盘阵列连接的SCSI卡的驱动模块先加载到内核，这样就能保证/dev/sda总是指向内置的硬盘。但这种解决方法毕竟不太完美，而且对于其他的即插即用设备，如USB设备等都不适用。
udev是一种工具，它能够根据系统中的硬件设备的状态动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在/dev目录下。使用udev后，在/dev目录下就只包含系统中真正存在的设备。udev能够实现所有devfs实现的功能。但udev运行在用户模式中，而devfs运行在内核中。据称：devfs具有一些不太容易解决的先天缺陷。
udev的工作过程：
1. 当内核检测到在系统中出现了新设备后，内核会在sysfs文件系统中为该新设备生成一项新的记录，一般sysfs文件系统会被 mount到 /sys目录中。新记录是以一个或多个文件或目录的方式来表示。每个文件都包含有特定的信息。
2. udev在系统中是以守护进程的方式udevd在运行，它通过某种途径，检测到新设备的出现，通过查找设备对应的sysfs中的记录得到设备的一些信息。
3. udev 会根据/etc/udev/udev.conf文件中的udev_rules指定的目录，逐个检查该目录下的文件，这个目录下的文件都是针对某类或某个设备应该施行什么措施的规则文件。udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev 就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。
（1）网卡命名机制
systemd对网络设备的命名方式：
1）如果Firmware或BIOS为主板上集成的设备提供的索引信息可用，且可预测则根据此索引进行命名，例如：eno1；
2）如果Firmware或BIOS为PCI-E扩展槽所提供的索引信息可用，且可预测，则根据此索引进行命名，例如：ens1；
3）如果硬件接口的物理位置信息可用，则根据此信息进行命名，例如enp2s0；
4）如果用户显示启动，也可根据MAC地址进行命名，enx2387aadc56；
5）上述均不可用，则使用传统命名机制；
上述命名机制中，有的需要biosdevname程序的参与；
（2）名称组成格式
en：ethernet
wl：wlan，无线局域网设备
ww：wwan，无线广域网设备
名称类型：
o&lt;index&gt;：集成设备的设备索引号；
s&lt;slot&gt;：扩展槽的索引号，支持虚拟设备
x&lt;MAC&gt;：基于MAC地址的命名；
p&lt;bus&gt;s&lt;slot&gt;：enp2s1
网卡设备的命名过程：
第一步：
udev，辅助工具程序/lib/udev/rename_device,根据 /usr/lib/udev/rules.d/60-net.rules的指示，查找/etc/sysconfig/network-scripts/下的ifcfg-文件，如果HWADDR相同，将其中的DEVICE值作为网卡的名字。
第二步：
biosdevname会根据/usr/lib/udev/rules.d/71-biosdevname.rules所定义的规则进行命名
第三步：
通过检测网络接口设备，根据/usr/lib/udev/rules.d/75-net-description.rules
ID_NET_NAME_ONBOARD，ID_NET_NAME_SLOT，ID_NET_NAME_PATH
对于CentOS6，是在/lib/udev/rules.d/目录下。
回归传统命名方式：
1）编辑/etc/default/grub配置文件
GRUB_CMDLINE_LINUX="net.ifnames=0 rhgb quiet"
2）为grub2生成其配置文件
grub2-mkconfig -o /etc/grub2.cfg
3）重启系统
地址配置工具：nmcli
0.8.1版本：nmcli [ OPTIONS ] OBJECT { COMMAND | help }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0574ebd8d87a452f1843cb434d5f341a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86d4a5a628660e1f46e4754104d0803e/" rel="bookmark">
			【CSS】CSS中的BFC，是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常见定位方案 普通流 默认，从上而下，行内元素水平排列，行满换行，块级元素渲染成一个新行。 浮动 先按普通流位置出现，然后根据浮动方向偏移。 绝对定位 元素具体位置由绝对定位坐标组成。 二、什么是BFC BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。
BFC 即 Block Formatting Contexts (块级格式化上下文)，属于普通流。
可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。
三、形成BFC的条件 1、浮动元素，float 除 none 以外的值； 2、绝对定位元素，position（absolute，fixed）； 3、display 为以下其中之一的值 inline-block，table-cell，table-caption、flex； 4、overflow 除了 visible 以外的值（hidden，auto，scroll）； 5、body 根元素 四、BFC的特性 1、内部的Box会在垂直方向上一个接一个的放置。 2、垂直方向上的距离由margin决定 3、bfc的区域不会与float的元素区域重叠。 4、计算bfc的高度时，浮动元素也参与计算 5、bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 五、实例讲解 1、BFC中的盒子对齐 特性的第一条是：内部的Box会在垂直方向上一个接一个的放置。 &lt;template&gt; &lt;div id="app"&gt; &lt;!-- 1、BFC中的盒子对齐 --&gt; &lt;div class="container"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;div class="box3"&gt;&lt;/div&gt; &lt;div class="box4"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'App', data(){ return { } }, methods:{ } } &lt;/script&gt; &lt;style scoped&gt; /* 1、BFC中的盒子对齐 */ div { height: 20px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86d4a5a628660e1f46e4754104d0803e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61440a05ac505ddad0511cf1aa016fe8/" rel="bookmark">
			融邦JAVA面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 公司介绍 公司简介：
山东融邦电子商务有限公司（简称融邦集团），成立于2012年，注册资金壹亿元人民币，总部设在济南市高新区汉峪金谷，主营方向：支付、科技、微金融、大数据。
经营范围：
电子商务的技术开发、技术转让；计算机软硬件的开发；信息系统集成服务；电子产品的开发；金融机具的租赁与维修；应用软件的开发、技术服务；数据处理服务；国内广告业务；票务代理服务；商务信息咨询服务；经济贸易咨询服务；接受金融机构委托从事金融业务流程外包。（依法须经批准的项目，经相关部门批准后方可开展经营活动）
公司地址：
山东融邦电子商务有限公司是一家小微企业，成立于2012年11月14日，位于山东省济南市历下区龙奥西路1号银丰财富广场1号楼1单元804室，目前处于开业状态。
该公司的经营范围广泛，包括电子商务的技术开发、技术转让；计算机软硬件的开发；信息系统集成服务；电子产品的开发；金融机具的租赁与维修；应用软件的开发、技术服务；数据处理服务；国内广告业务；票务代理服务；商务信息咨询服务；经济贸易咨询服务；接受金融机构委托、从事金融业务流程外包等。
公司其他信息：
山东融邦电子商务有限公司法定代表人为曾涛，参保人数为1人，其中曾涛担任执行董事兼总经理，陈风林担任监事。该公司已在电子商务的技术开发、技术转让；计算机软硬件的开发；信息系统集成服务等方面有一定的积累，拥有8个注册商标，2个软件著作权。
2 最新2023年JAVA面试题 2.1 Java线程池的作用及使用方式 线程池的作用：
(1) 降低系统资源消耗：通过重用已存在的线程，降低线程创建和销毁造成的消耗。
(2) 提高系统响应速度：当有任务到达时，无需等待新线程的创建便能立即执行。
(3) 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
(4) 更强大的功能：线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。
线程池的使用：
newCachedThreadPool();可缓存线程池
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。
newFixedThreadPool();可定长度
创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。
newScheduledThreadPool() ;可定时
创建一个定长线程池，支持定时及周期性任务执行。
ScheduledExecutorService比Timer更安全，功能更强大。
newSingleThreadExecutor();单例
创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
2.2 用java实现，计算字符串中子串出现的次数 public class FindWords { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String str1 = "chuanzhi"; int count = 0; int start = 0; while (str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61440a05ac505ddad0511cf1aa016fe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f06c49a642098287d60238d895f731/" rel="bookmark">
			阿里云国际服务器设置安全防护程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 阿里云云服务器（ECS）提供弹性、安全、高性能、高性价比的虚拟云服务器，满足您的所有需求。立即在这里免费注册！
常见 Web 应用程序
请勿对 Web 服务控制台（如 WDCP、TOMCAT、Apache、Nginx、Jekins、PHPMyAdmin、WebLogic 和 Jboss）使用默认密码或空白密码。必须使用复杂密码（至少 10 个字符，可以包含大小写字母、数字和特殊符号）。必须关闭空闲主机。否则，这些控制台可能会受到攻击，从而控制您的 ECS 服务器。将 Web 应用程序升级到最新版本。例如，对于以前版本的 Struts 和 ElasticSearch，漏洞可远程执行。确保您的 Web 应用程序是最新的。否则，攻击者可能会控制您的ECS服务器。如果Redis、Memcached和MongoDB设置为免密访问，攻击者可能会远程登录以控制您的服务器。为了保证服务器安全，请使用复杂的密码进行访问。此外，修改端口并将侦听 IP 绑定到 127.0.0.1。 常见数据库应用程序
将Postgresql、Oracle、MySQL、SQLServer等服务的默认连接端口修改为非通用端口。为不同的角色创建不同的帐户并优化身份验证。请勿共享该帐户，也不要使用系统帐户登录数据库。使用复杂密码（最少 10 个字符，可以包含大小写字母、数字和特殊符号）作为数据库密码。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a9b2cb1bb0b5773105880b812bc2aa/" rel="bookmark">
			VUE指令（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue会根据不同的指令，针对不同的标签实现不同的功能。指令是带有 v- 前缀的特殊标签属性。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。
1、v-text：设置元素的文本内容，不会解析div标签、样式等；
2、v-html ：设置元素的innerHTML（v-html=“表达式”），会解析div标签、样式等；
&lt;div id="app"&gt; &lt;p&gt;{{content}}&lt;/p&gt; &lt;p v-html="content"&gt;{{content}}&lt;/p&gt; &lt;p v-text="content"&gt;{{content}}&lt;/p&gt; &lt;/div&gt; data: { content: '&lt;strong&gt;vue使用步骤&lt;/strong&gt;' } 3、v-show：通过切换 display:none来控制元素显示还是隐藏，v-show = "表达式（值 true 显示， false 隐藏）"，适合于频繁切换显示隐藏的场景；
4、v-if：基于条件判断，通过创建或移除元素节点来控制元素的显示和隐藏，v-if = "表达式（值 true 显示， false 隐藏）"，适合于显示隐藏切换不频繁的场景；
5、v-else/v-else-if：配合v-if使用，进行链式调用，v-else-if="表达式"，v-else。需紧跟v-if使用
&lt;div id="app"&gt; &lt;p v-if="gender === 1"&gt;性别：♂ 男&lt;/p&gt; &lt;p v-else&gt;性别：♀ 女&lt;/p&gt; &lt;hr&gt; &lt;p v-if="score &gt;= 90"&gt;成绩评定A&lt;/p&gt; &lt;p v-else-if="score &gt;= 70"&gt;成绩评定B&lt;/p&gt; &lt;p v-else-if="score &gt;= 60"&gt;成绩评定C&lt;/p&gt; &lt;p v-else&gt;成绩评定D&lt;/p&gt; &lt;/div&gt; 6、v-on：给元素添加事件监听及处理逻辑；v-on:事件名="内联语句/methods中的函数名"；v-on还可简写为@；如果再模板（页面）中使用事件对象，可以使用$event，如果再js中使用事件对象，则使用事件处理函数的形参e；
&lt;div id="app"&gt; &lt;button @click="count--"&gt;-&lt;/button&gt; &lt;span&gt;{{ count }}&lt;/span&gt; &lt;button v-on:click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a9b2cb1bb0b5773105880b812bc2aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5cf061e8fc99124c780a08b6a5454fd/" rel="bookmark">
			MySQL运维实战(3.2) 常见数据库连接失败问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：俊达
我们经常会遇到一些数据库连接失败或访问报错的问题。收集并分析具体的报错信息，可以帮助我们迅速定位问题。
1、客户端到服务端的网络是否畅通，服务端端口是否能连通。 使用ping、telnet等工具探测服务端的端口是否能访问。
[root@box3 ~]# telnet 172.16.20.51 3306 Trying 172.16.20.51... Connected to 172.16.20.51. Escape character is '^]'. J 5.7.3-m/i _Y(^#XTCcie|Pmysql_native_password] !#08S01Got packets out of orderConnection closed by foreign host. [root@box3 ~]# telnet 172.16.20.52 3306 Trying 172.16.20.52... telnet: connect to address 172.16.20.52: Connection refused 如果端口不通，要先排除网络问题，如是否有防火墙限制，服务端是否正常。
2、如果端口能访问，需要看客户端的报错信息。 客户端或者编程接口连接数据库失败，通常会有相应的错误消息。通过错误消息可以判断问题原因，常见的连接失败、查询报错的原因如下：
账号密码错误数据库连接数占满数据库账号被锁定超出max-connect-error限制客户端连接池满了连接会话被KILL会话超时对应的客户端报错信息 [root@box3 ~]# mysql -udemo -h172.16.20.51 -pdem mysql: [Warning] Using a password on the command line interface can be insecure. ERROR 1045 (28000): Access denied for user 'demo'@'box3' (using password: YES) [root@box3 ~]# mysql -h 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5cf061e8fc99124c780a08b6a5454fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf0cc6905e2fbb1cc0bc17d6a88c1ad/" rel="bookmark">
			三步完成ChatGLM3-6B在英特尔CPU上的INT4量化和部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者: 英特尔边缘计算创新大使 刘力
1.1 ChatGLM3-6B简介 ChatGLM3 是智谱AI和清华大学 KEG 实验室联合发布的新一代对话预训练模型。ChatGLM3-6B 是 ChatGLM3 系列中的开源模型，在填写问卷进行登记后亦允许免费商业使用。
引用自：https://github.com/THUDM/ChatGLM3
请使用命令，将ChatGLM3-6B模型下载到本地：
git clone https://www.modelscope.cn/ZhipuAI/chatglm3-6b.git 1.2 BigDL-LLM简介 BigDL-LLM是开源，遵循Apache 2.0许可证，专门用于在英特尔的硬件平台上加速大语言模型（Large Language Model, LLM）推理计算的软件工具包。它是在原有的BigDL框架基础上，为了应对大语言模型在推理过程中对性能和资源的高要求而设计的。BigDL-LLM旨在通过优化和硬件加速技术来提高大语言模型的运行效率，减少推理延迟，并降低资源消耗。
BigDL-LLM的主要特点包括：
1.低精度优化：通过支持INT4/INT5/INT8等低精度格式，减少模型的大小和推理时的计算量，同时保持较高的推理精度。
2.硬件加速：利用英特尔CPU集成的硬件加速技术，如AVX（Advanced Vector Extensions）、VNNI（Vector Neural Network Instructions）和AMX（Advanced Matrix Extensions）等，来加速模型的推理计算。
3.使用方便：对于基于Hugging Face Transformers API的模型，只需修改少量代码即可实现加速，使得开发者可以轻松地在其现有模型上应用BigDL-LLM。
4.性能提升：BigDL-LLM可以显著提高大语言模型在英特尔平台上的运行速度，减少推理时间，特别是在处理大规模模型和复杂任务时。
5.资源友好：通过优化模型运行时的资源使用，BigDL-LLM使得大语言模型可以在资源受限的环境中也能高效运行，如普通的笔记本电脑或服务器。
1.3 使用BigDL-LLM量化并部署ChatGLM3-6B 1.3.1 第一步，创建虚拟环境 请安装Anaconda，然后用下面的命令创建名为llm的虚拟环境
conda create -n llm python=3.9 conda activate llm 1.3.2 第二步，安装BigDL-LLM 执行命令：
​pip install --pre --upgrade bigdl-llm[all] -i Simple Index ​ 1.3.3 第三步：运行范例程序 范例程序下载地址：https://gitee.com/Pauntech/chat-glm3/blob/master/chatglm3_infer.py
import time from bigdl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf0cc6905e2fbb1cc0bc17d6a88c1ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797f97ba6171691cc8cc46fd0603c86a/" rel="bookmark">
			Vue3-watch的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		watch简介 作用:监视数据的变化 (和 Vue2 中的 watch 作用一致)
特点: Vue3 中的 watch 只能监视以下四种数据
1.ref 定义的数据(又可以分 基本 和 对象 )
2.reactive 定义的数据
3.函数返回一个值。(getter 函数)
4.一个包含上述内容的数组
我们在 Vue3 中使用 watch 的时候，通常会遇到以下几种情况
情况一 （监视 ref 定义的[基本类型]数据） 监视 ref 定义的[基本类型]数据: 直接写数据名即可，监视的是其 value 值的改变
情况二 （监视 ref 定义的[对象类型]数据） 监视 ref 定义的[对象类型]数据: 直接写数据名，监视的是对象的[地址值]，若想监视对象内部的数据，要手动开启深度监视。
注意
若修改的是 ref 定义的对象中的属性，newValue 和 oldValue 都是新值，因为它们是同一个对象
若修改整个ref 定义的对象，newValue 是新值， oldValue 是旧值，因为不是同一个对象了
情况三（监视reactive定义的对象类型数据） 监视reactive定义的对象类型数据，且默认开启了深度监视。
情况四（监视 ref 或 reactive 定义的[对象类型]数据中的某个属性）（关键） 监视 ref 或 reactive 定义的[对象类型]数据中的某个属性，注意点如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/797f97ba6171691cc8cc46fd0603c86a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f83217d2af95793551cc75bf327cbf7/" rel="bookmark">
			2024美赛数学建模思路 - 复盘：人力资源安排的最优化模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 赛题思路1 描述2 问题概括3 建模过程3.1 边界说明3.2 符号约定3.3 分析3.4 模型建立3.5 模型求解 4 模型评价与推广5 实现代码 建模资料 0 赛题思路 （赛题出来以后第一时间在CSDN分享）
https://blog.csdn.net/dc_sinor?type=blog
1 描述 某大学数学系人力资源安排问题是一个整数规划的最优化问题，通过具体分析数学系现有的技术力量和各方面的约束条件，在问题一的求解中，可以列出一天最大直接收益的整数规划，求得最大的直接收益是42860元；而在问题二的求解中，由于教授一个星期只能工作四天，副教授一个星期只能工作五天，在这样的约束条件下，列出一个星期里最大直接收益的整数规划模型，求得其最大直接收益是198720元。
2 问题概括 数学系的教师资源有限，现有四个项目来源于四个不同的客户，工作的难易程度不一，各项目对有关技术人员的报酬不同。所以：
1.在满足工作要求的情况下，如何分配数学系现有的技术力量，使得其一天的直接收益最大？
2.在教授与副教授工作时间受到约束的条件下，如何分配数学系现有的技术力量，使得其在一个星期里的直接收益最大？
3 建模过程 3.1 边界说明 1.不同技术力量的人每天被安排工作的几率是相等的，且相同职称的个人去什么地方工作是随机的；
2.客户除了支付规定的工资额外，在工作期间里，还要支付所有相关的花费（如餐费，车费等）；
3.当天工作当天完成．
3.2 符号约定 3.3 分析 由题意可知各项目对不同职称人员人数都有不同的限制和要求．对客户来说质量保证是关键，而教授相对稀缺，因此各项目对教授的配备有不能少于一定数目的限制．其中由于项目技术要求较高，助教不能参加．而两项目主要工作是在办公室完成，所以每人每天有50元的管理费开支．
由以上分析可得：最大直接收益=总收益－技术人员工资－、两地保管费．
3.4 模型建立 3.5 模型求解 相关数据表格如下：
数学系的职称结构及工资情况
4 模型评价与推广 本模型通过合理的假设，充分考虑各方面的限制条件，得出的人员安排和直接收益
都是本模型的最优解与最优值，对武汉大学数学系的人力资源安排有一定的指导作用。但从模型假设中，我们可以知道对数
学系现有的技术力量的安排是随机的，在相同工作时段里，可能会出现部分人工作次数较多，而部分人较少的不公平情况。
所以在满足工作需求的情况下，分配工作时应该要人为地尽量使得每个人的工作次数不要相差太远，或者相等。
此模型通过对人力资源的调配，从量化的角度得出数学系的最大直接收益。利用此模型的方法可以求出所有类似本模型的线性规划模型。但是，本模型只是单目标的规划，可以在此基础上，增加目标要求。如在数学系的直接收益尽可能大的基础上，使得客户所花费的资金最少，等等。从而建立多目标规划模型。解决更为复杂的实际问题。
5 实现代码 f=[-1000;-800;-550;-450;-1500;-800;-650;-550;-1300;-900;-650;-350;-1000;-800;-650;-450]; A=zeros(9,16); for i=1:1 for j=1:16 A(i,j)=1; end end for i=2:5 for j=i-1:4:11+i A(i,j)=1; end end i0=0; for i=6:9 for j=i0+1:(i-5 )*4 A(i,j)=1; end i0=j; end b=[64;17;20;15;18;12;25;17;10]; Aeq=zeros(1,16); Aeq(1,3)=1; beq=[2]; LB=[1;2;2;1;2;2;2;2;2;2;2;1;1;3;1;0]; UB=[3;5;2;2;inf;inf;inf;8;inf;inf;inf;inf;inf;inf;inf;0]; [x,fval]=linprog(f,A,b,Aeq,beq,LB,UB) f=[-1000;-1000;-1000;-1000;-1000;-1000;-1000;-1500;-1500;-1500;-1500;-1500;-1500;-1500;-1250;-1250;-1250;-1250;-1250;-1250;-1250;-950;-950;-950;-950;-950;-950;-950;-800;-800;-800;-800;-800;-800;-800;-800;-800;-800;-800;-800;-800;-800;-850;-850;-850;-850;-850;-850;-850;-750;-750;-750;-750;-750;-750;-750;-600;-600;-600;-600;-600;-600;-600;-700;-700;-700;-700;-700;-700;-700;-650;-650;-650;-650;-650;-650;-650;-650;-650;-650;-650;-650;-650;-650;-500;-500;-500;-500;-500;-500;-500;-600;-600;-600;-600;-600;-600;-600;-350;-350;-350;-350;-350;-350;-350;-450;-450;-450;-450;-450;-450;-450]; A=zeros(60,112); for i=1;1 for j=1:112 A(i,j)=1; end end i0=0; for i=2:4 for j=i0+1:(i-1)*28 A(i,j)=1; end i0=j; end for i=5:32 for j=(i-4):28:80+i A(i,j)=1; end end for i=33:39 for j= i-32:7:(i-11) A(i,j)=1; end end j0=j; for i=40:46 for j=j0+(i-39):7:(i-18)+j0 A(i,j)=1; end end j0=j; for i=47:53 for j=j0+(i-46):7:j0+(i-25) A(i,j)=1; end end j0=j; for i=54:60 for j=j0+(i-53):7:j0+(i-32) A(i,j)=1; end end b=[362;48;125;119;17;17;17;17;17;17;17;20;20;20;20;20;20;20;15;15;15;15;15;15;15;18;18;18;18;18;18;18;12;12;12;12;12;12;12;25;25;25;25;25;25;25;17;17;17;17;17;17;17;10;10;10;10;10;10;10]; UB=[3;3;3;3;3;3;3;5;5;5;5;5;5;5;3;3;3;3;3;3;3;2;2;2;2;2;2;2;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;8;8;8;8;8;8;8;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;+inf;0;0;0;0;0;0;0]; LB=[1;1;1;1;1;1;1;2;2;2;2;2;2;2;1;1;1;1;1;1;1;1;1;1;1;1;1;1;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;1;1;1;1;1;1;1;1;1;1;1;1;1;1;3;3;3;3;3;3;3;1;1;1;1;1;1;1;0;0;0;0;0;0;0]; Aeq=zeros(7,112); for i=1:7 Aeq(i,i+14)=1; end beq=[2;2;2;2;2;2;2]; [x,fval]=linprog(f,A,b,Aeq,beq,LB,UB) 建模资料 资料分享: 最强建模资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518116418dfead4f76b379d7ffe28ced/" rel="bookmark">
			蓝桥杯 python 第二题 数列排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里给出一种解法
""" # 错的 n = int(input()) dp=[int(i) for i in input().split(" ")] dp.sort() print(" ".join(str(i) for i in dp)) """ #这个是对的 num = int(input()) l = list(map(int, input().split())) l.sort() print(" ".join(map(str, l))) 这里什么写俩呢, 仔细看split()函数, 如果里面填上用" "参数, 蓝桥杯练习系统就运行错误, 而不使用参数则没有任何问题, 相同的代码只错在这里, 不知道是python3.8.6的版本问题, 还是蓝桥杯练习系统的猫病.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53fde3e12bb9cd1e540820c767bc455/" rel="bookmark">
			Midjourney 步 OpenAI 后尘，将面临创作者的集体诉讼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Midjourney 被曝光未经许可使用了包含16000名艺术家的作品风格来训练其图像生成AI。这个名单不仅包括现代和当代著名艺术家的作品，还包括了为公司如Hasbro和Nintendo工作的商业插画师的作品，甚至还包括了一名6岁儿童的作品。
Midjourney创建了一个艺术家的数据库，这些艺术家在数据库中被简化为不同的风格标签，然后利用这些信息来训练他们的 AI 系统。换句话说，Midjourney使用了这些艺术家的风格和技巧，在没有艺术家本人同意的情况下进行的。
这些著名艺术家包括赛·托姆布雷、安迪·沃霍尔、安尼什·卡普尔、草间弥生、格哈德·里希特、弗里达·卡罗、安迪·沃霍尔、埃尔斯沃斯·凯利、达明安·赫斯特、阿梅迪奥·莫迪利亚尼、巴勃罗·毕加索、保罗·西涅克、诺曼·洛克威尔、保罗·塞尚、班克斯、沃尔特·迪士尼、和文森特·梵高。
其中一个值得注意的例子是六岁的孩子 Hyan Tran 的作品也被 Midjourney 爬取，这个孩子曾在2021年为西雅图儿童医院的筹款活动贡献艺术作品。这一发现引起了艺术家们的担忧，并促使他们寻求法律援助。
一些艺术家已经对 Midjourney 和其他公司提起了集体诉讼，因为他们的作品在未经许可的情况下被用于训练人工智能图像生成器。
另外，《中途》的开发者们发现了关于洗钱的讨论，并创建了一个艺术家数据库（他们的风格已经被非人化）来训练《中途》。这已被提交作为诉讼证据。提示工程师，你的“技能”不是你的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7831ffbeaedf9ce087bb0b046bcb6ae7/" rel="bookmark">
			【CSS】首个字符占用多行，并自定义样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果 代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;首字母大写&lt;/title&gt; &lt;style&gt; p:first-child::first-letter { float: left; font-size: 4rem; font-family: 仿宋; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 晚会以“欣欣向荣的新时代中国，日新月异的更美好生活”为主题，通过各种艺术形式，充分展现开心信心、顽强奋进的主旋律 [10]。 2023年1月21日20时，晚会在总台央视综合频道、综艺频道、中文国际频道、国防军事频道、少儿频道、音乐频道、农业农村频道、4K/8K超高清频道等电视频道，中国之声、音乐之声、经典音乐广播、文艺之声、大湾区之声、台海之声、中国乡村之声、华语环球广播、南海之声、中国交通广播等广播频率，央视频、央视新闻、云听、央视网、央广网、国际在线等新媒体平台同步直播 &lt;/p&gt; &lt;/body&gt; &lt;/html&gt;``` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7fa9d1043c1daf7c254b4f78ab6f7b/" rel="bookmark">
			Java 设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.单例设计模式 对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。
1.1 饿汉式 构造器私有化 --&gt; 防止直接new类的内部创建对象提供一个static的public方法 getInstance class GirlFriend { private String name; private static GirlFriend gf = new GirlFriend("小红红"); private GirlFriend(String name) { System.out.println("構造器被調用."); this.name = name; } public static GirlFriend getInstance() { return gf; } public class SingleTon01 { public static void main(String[] args) { //通过方法可以获取对象 GirlFriend instance = GirlFriend.getInstance(); System.out.println(instance); GirlFriend instance2 = GirlFriend.getInstance(); System.out.println(instance2); System.out.println(instance == instance2); //T } } 1.2 懒汉式 构造器私有化 --&gt; 防止直接new类的内部定义一个static对象提供一个static的public方法 getInstance只有当用户使用 getInstance 时，才返回对象, 再次调用时，会返回上次创建的对象 class Cat { private String name; private static Cat cat ; //默認是 null private Cat(String name) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b7fa9d1043c1daf7c254b4f78ab6f7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76d2eaa04d6c0badf82f8e4a32d562b/" rel="bookmark">
			ASP .net core微服务实战(杨中科)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开发&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
0)用户
用户到nginx之间需要用https，避免被监听。
1)nginx // 做统一的分发，到微服务，相当于网关,提供统一访问端口。
2)具体服务
1.common // 各个服务的共用模块，jwt之类的
2.微服务1
3.微服务2
3)分层
领域。
基础设施。
应用服务。
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Rider中一键启动&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;部署上线&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
YouZack-英语听力精听、背单词
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39e3239421e3061c64f0b512cf0d9d6/" rel="bookmark">
			.NetCore部署微服务（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
什么是微服务
微服务的优势
微服务的原则
创建项目
在Docker中运行服务
客户端调用
简单的集群服务
前言 写这篇文章旨在用最简单的代码阐述一下微服务
什么是微服务 微服务描述了从单独可部署的服务构建分布式应用程序的体系结构流程，同时这些服务会执行特定业务功能并通过 Web 接口进行通信，DevOps 团队通过将微服务（如构建块）组合在一起，从而将单个功能纳入微服务中以及构建更大的系统。
微服务的优势 微服务采用了某一开放/封闭原则：
它们会开放以便进行扩展（使用它们公开的接口）它们会关闭以便进行修改（每个修改都会独立执行并进行版本控制） 微服务为整体体系结构提供了众多优势：
它们可以通过确保一个服务中的问题不会崩溃或影响应用程序的其他部分来移除单一故障点 (SPOF)。可独立扩展单个微服务，以提供额外的可用性和容量。DevOps 团队可通过添加新微服务来扩展功能，而无需不必要的影响应用程序的其他部分。 使用微服务可提高团队速度。微服务通过允许软件开发团队利用事件驱动的编程和自动缩放等场景，很好地补充基于云的应用程序体系结构。 微服务组件通常会通过 REST 协议公开 API（应用程序编程接口），以便与其他服务通信。
微服务的原则 顾名思义，微服务体系结构是一种将服务器应用程序生成为一组小型服务的方法。 这意味着微服务体系结构主要面向后端，虽然该方法也会用于前端。 每个服务都在自己的进程中运行，并使用 HTTP/HTTPS、WebSocket 或 AMQP 等协议与其他进程进行通信。 每个微服务在特定的上下文边界内实现特定的端到端域或业务功能，每个微服务都必须自主开发，并且可以独立部署。 最后，每个微服务都应拥有其自己的相关域数据模型和域逻辑（主权和分散式数据管理），并且可以基于不同的数据存储技术（SQL、NoSQL）和不同的编程语言。
微服务应该有多大？ 在开发微服务时，大小不应成为重点。 相反，重点应该是创建松散耦合的服务以便自主地为每个服务进行开发、部署和缩放。 当然，在标识和设计微服务时，只要与其他微服务不存在过多的直接依赖项，就应尝试让它们尽可能地小。 比微服务的大小更重要的是，它必须具有内部内聚，并且独立于其他服务。
创建项目 我们在项目中新建两个文件夹，Client跟Service。Client文件夹用于管理我们的客户端，Service文件夹用于管理我们的Api.
项目结构目录如下：
三个项目都是Asp.Net Core Web API。
我们为ForumProductApi以及ForumOrderApi添加一些基础代码，我们返回接口名称以及当前时间，服务的IP地址，端口等信息，以让我们更好的区分接口。
我们修改OrderApi的代码如下：
[ApiController] [Route("order")] public class OrderController : ControllerBase { private readonly ILogger&lt;OrderController&gt; _logger; public OrderController(ILogger&lt;OrderController&gt; logger) { _logger = logger; } [HttpGet(Name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f39e3239421e3061c64f0b512cf0d9d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d91e4ecc4b84cfd50cdf47a75e38faa/" rel="bookmark">
			阿里云服务器经济型e实例和云服务器u1实例区别？哪个性能优？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 阿里云服务器u1和e实例有什么区别？ECS通用算力型u1实例是企业级独享型云服务器，ECS经济型e实例是共享型云服务器，所以相比较e实例，云服务器u1性能更好一些。e实例为共享型云服务器，共享型实例采用非绑定CPU调度模式，不同ECS实例vCPU会争抢物理CPU资源，并导致高负载时计算性能波动不稳定。阿里云百科aliyunbaike.com来详细对比阿里云服务器通用算力型u1和经济型e实例区别对比：
云服务器u1和e实例区别 阿里云服务器ECS经济型e实例是阿里云面向个人开发者、学生、小微企业，在中小型网站建设、开发测试、轻量级应用等场景推出的全新入门级云服务器；通用算力型云服务器u1实例属于企业级独享型云服务器，u1适用于Web应用及网站，企业办公类应用，数据分析和计算等大多数通用的对vCPU算力和性能要求不高的应用场景。
阿里云服务器u1和e实例
e实例和u1实例CPU处理器区别 阿里云ECS经济型e实例CPU采用Intel Xeon Platinum架构处理器，如下图：
阿里云服务器ECS经济型e实例CPU处理器型号
通用算力型u1实例CPU采用2.5 GHz主频的Intel(R) Xeon(R) Platinum处理器。
e实例和云服务器u1实例优惠活动 目前阿里云服务器ECS经济型e实例是阿里云主推的，e系列2核2G、3M固定带宽、40G ESSD Entry云盘，99元一年，续费也是99元一年，活动如下：
官方活动入口 https://t.aliyun.com/U/bLynLC
活动打开如下图：
阿里云99元服务器
云服务器u1实例也是有活动的，配置款2核4G、2核8G、4核8G等配置，详细请移步到上方活动页面查看精准报价。
共享型和企业级独享型区别 e实例是共享型云服务器：共享型实例采用非绑定CPU调度模式。每个vCPU会被随机分配到任何空闲CPU超线程上，不同实例vCPU会争抢物理CPU资源，并导致高负载时计算性能波动不稳定，有可用性SLA保证，但无性能SLA保证。u1实例是企业级（独享型）：企业级实例采用固定CPU调度模式。每个vCPU绑定到一个物理CPU超线程，实例间无CPU资源争抢，实例计算性能稳定且有严格的SLA保证。 共享和独享详细说明，请参考：一看就懂：阿里云服务器ECS共享型和独享型性能区别对比
以上是阿里云百科aliyunbaike.com简单对比的关于ECS经济型e实例和ECS通用算力型u1实例的区别，详细说明请参考：
阿里云服务器经济型e系列CPU性能测评_价格0.5元/天起阿里云通用算力型u1云服务器CPU性能、租用费用及使用限制说明 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbcc0029f2808871babaad05dbb9bac/" rel="bookmark">
			[uniapp] uni-ui&#43;vue3.2小程序评论列表组件 回复评论 点赞和删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看效果 下载地址 uni-app官方插件市场: cc-comment组件
环境 基于vue3.2和uni-ui开发;
依赖版本参考如下:
"dependencies": { "@dcloudio/uni-mp-weixin": "3.0.0-3090820231124001", "@dcloudio/uni-ui": "^1.4.28", "uni-ui": "^1.0.0", "vue": "^3.2.45" }, "devDependencies": { "vite": "4.0.3" } } 小程序调试基础库: 3.3.0
场景 即拿即用, 组件有详细注释内容, 方便二次开发;
目前仅在小程序使用, 其他平台能否使用请评论留言反馈谢谢, 祝大家使用愉快.
附言 主要是插件市场没找到满意的, 诸多用着也不顺, 所以有了cc-comment, 如有Bug请留言或Email, 开源不易且用且珍惜, 感谢使用.
关于功能样式, 主打一个借鉴如下;
参考[小红书]App的评论回复功能: 点击评论内容展示回复弹窗, 二级评论默认显示一条, 点击展开查看更多, 无评论收起功能.
参考[什么值得买]App的多层级回复评论title显示效果
功能 已实现 无评论显示场景 √显示评论数量(新增和删除动态更新数量) √发起新评论 √点击评论内容回复 √回复一级评论 √回复二级评论 √展开二级评论 √展开超长评论内容 √不能回复自身评论 √删除 √仅可删除自身评论 √可选三类删除模式 √点赞 √点赞大于100显示99+ √ 待实现 图片上传 × 有其他需求的评论区留言
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cbcc0029f2808871babaad05dbb9bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1882a81af8d19852e7bed25fe3931f/" rel="bookmark">
			小白向：搭建企业培训APP的完整技术指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当下，许多企业转向了现代化的培训方法，其中一个关键的工具就是企业培训APP。本文将为你提供搭建企业培训APP的完整技术指南，助你在数字化时代更好地满足企业培训的需求。
一、需求分析与功能规划
在开始开发之前，首先需要明确企业培训APP的具体需求和功能。这可能包括用户管理、课程管理、学习进度跟踪、测验与评估等功能。详细的需求分析将有助于更好地设计和开发APP，确保满足企业实际培训的要求。
二、技术选型
选择合适的技术堆栈是搭建企业培训APP的关键一步。通常，一个典型的企业培训APP可能包含前端、后端和数据库。前端可以选择常见的移动应用框架，如ReactNative或Flutter，以实现跨平台开发。后端可以采用Node.js、Django、Flask等框架，数据库可以选择MySQL、PostgreSQL或MongoDB，根据具体需求灵活选用。
三、课程管理与内容发布
实现一个灵活的课程管理系统是企业培训APP的核心之一。包括课程的创建、编辑、发布和管理，以及对不同类型的教育内容的支持，如文档、视频、在线测试等。考虑到内容的多样性，可以选择合适的媒体存储和流媒体服务。
四、学习进度追踪与报告
为了更好地了解员工的学习情况，需要实现学习进度的追踪和报告功能。这包括课程完成情况、考试成绩等数据的收集和展示。借助数据分析工具，如GoogleAnalytics或自定义的报表系统，可以更好地监控和评估培训效果。
五、移动端优化与用户体验
由于企业培训APP主要面向移动设备，优化用户体验是至关重要的。确保APP在不同设备和屏幕尺寸上都能正常运行，并考虑到用户习惯，提供友好的界面和交互体验。
总结：
通过本文提供的完整技术指南，你可以更好地规划和实施企业培训APP的开发过程。记住，成功的培训APP不仅仅是技术的堆砌，更是对企业培训需求的深刻理解和灵活应对。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c88762aac83a3121c5a569b2233fa2/" rel="bookmark">
			在 VS2022 中创建的 Qt 应用程序中查看 std::cout 输出的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 Qt 开发 GUI 应用程序时，常常需要输出一些调试信息以了解程序的运行状态。然而，对于 Qt GUI 应用程序，std::cout 的输出并不会直接显示在 GUI 界面上，特别是在 Windows 平台上，默认情况下 GUI 应用程序并不会打开控制台窗口，因此 std::cout 的输出可能会“丢失”。这篇博文将介绍几种在 Qt 应用程序中查看 std::cout 输出的方法。
方法 1: 创建一个控制台窗口 对于 Visual Studio 用户，可以通过更改项目属性来为 GUI 应用程序创建一个控制台窗口。
在 Visual Studio 中，右键点击项目 -&gt; 属性。转到链接器 -&gt; 系统。在子系统下拉菜单中选择“控制台”。点击应用并关闭属性窗口。重新编译并运行程序。 这将会在运行 GUI 应用程序时同时打开一个控制台窗口，std::cout 的输出将显示在这个控制台窗口中。
方法 2: 使用 Qt 的消息日志系统 Qt 提供了自己的消息日志系统，你可以使用 qDebug() 来代替 std::cout。这将输出信息到 Qt Creator 的“应用程序输出”控制台中。
#include &lt;QDebug&gt; // ... virtual void OnLeftButtonDown() override { qDebug() &lt;&lt; "Left button down event captured.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c88762aac83a3121c5a569b2233fa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f5539e8b0bc599e453b252333c8ac8/" rel="bookmark">
			IRF540资料手册数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IRF540是一种功率MOSFET（金属氧化物半导体场效应晶体管）器件，常用于高功率放大和开关应用。它具有较低的开关电阻和较高的电流承载能力。IRF540可以承受较高的电压和电流，并具有较低的导通电阻，因此常用于开关电源、电机驱动、功率放大器、DC-DC转换器等应用中。以下是对IRF540 datasheet的数据详情分析：
标准参数：IRF540的标准参数包括最大漏极电压（Vds）为100V，最大漏极电流（Id）为33A，最大功率（Pd）为150W，最大栅极-源极电压（Vgs）为20V，典型导通电阻（Rds(on)）为0.077Ω。这些参数说明了IRF540具有较高的电压和电流承受能力，并且具有较低的导通电阻。耐压和耐电压：IRF540具有耐受较高电压的特点，能够在100V的漏极电压下正常工作。这使得IRF540适用于需要承受较高电压的应用，如电源开关和电机驱动器。导通电阻：IRF540的典型导通电阻（Rds(on)）为0.077Ω。较低的导通电阻意味着在开关状态下，IRF540能够提供较低的功率损耗和更高的效率。因此，IRF540适用于高效率的开关电源和功率放大器设计。热特性：IRF540具有低热阻，可以有效地散热，从而降低功率晶体管的工作温度。这有助于提高器件的可靠性和寿命。在设计高功率应用时，必须考虑合适的散热措施，以确保IRF540在安全的工作温度范围内运行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a887a17455bf914832c6b17e8e79bab5/" rel="bookmark">
			非均衡设计评价两个批次的数据一致性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务描述 第一批次的药物实验设置了三个剂量（0.2，0.6，1.8）mg/kg，每个剂量水平有十个受试者。
第二批次的药物实验设置了其他三个剂量(1.2,2.4,4.8) mk/kg，每个剂量水平有两个受试者。
问：这两个数据一致性怎么样？
其实我不理解这个一致性如何评价！！！
我理解是不是这两批数据可以用一个方程表示？或者说第二批次数据落在第一批次方程的置信区间内？
数据 getwd() rm(list=ls()) list.files() library(tidyverse) df &lt;- read.table("AUClast1.csv",header = T,sep=",",encoding = "UTF-8") head(df) 代码 # 重新整理一下数据 dose &lt;- as.numeric(df[,1]) resp &lt;- c(27.33,88.06,351.4,487.5,1046,2520) df &lt;- as.data.frame(cbind(dose,resp)) df &lt;- df %&gt;% arrange(dose) head(df) # dose resp #1 0.2 27.33 #2 0.6 88.06 #3 1.2 487.50 #4 1.8 351.40 #5 2.4 1046.00 #6 4.8 2520.00 plot(log10(dose),log10(resp)) # 散点图可以看到数据取log后基本上是线性相关的，那就做线性拟合好了 # 然后第一批次的数据就三个点，什么正态分布，方差齐性，强影响点，都不考虑了，直接干 # 把第一批的数据拿出来 df1 &lt;- df[c(1,2,4),] model &lt;- lm(log10(resp)~log10(dose),df1) summary(model) # 模型的截距和系数都有意义，继续 Call:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a887a17455bf914832c6b17e8e79bab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de6ad61856b582c267a93b89073e405/" rel="bookmark">
			java基础之Map集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# Map集合 ## Map的存储特点 1. 以键值对的形式存放
2. 键(key-K): 无序、无下标、元素不可重复
3. 值(value-V)：无序、无下标、元素可以重复
## 常用实现类 1. HashMap
- JDK1.2 底层哈希表实现 线程不安全，效率高
2. LinkedHashMap
- JDK1.2 是HashMap的子类，底层哈希表实现 线程不安全，效率高
3. TreeMap
- JDK1.2 是SortedMap的实现类，底层红黑树实现 线程不安全，效率高
4. Hashtable
- JDK1.0 底层哈希表实现 线程安全，效率低
5. Properties
- JDK1.0 是Hashtable的子类，底层哈希表实现 线程安全，效率低
## 创建 建议使用多态
~~~java
Map&lt;键的泛型,值的泛型&gt; 集合名=new 实现类名&lt;&gt;();
~~~
## 常用方法 1. V put(K,V)：往集合中添加一个键值对
- 如果键已经存在，则进行值的覆盖
2. int size()：获取集合元素个数
3. boolean containsKey(K)：判断是否包含指定键
4. boolean containsValue(V)：判断是否包含指定值
5. V get(K)：根据键获取值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de6ad61856b582c267a93b89073e405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada228af80169045fbb57d2d421ae49a/" rel="bookmark">
			linux网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看linux基础的网络设置 网关
route -nip地址ifconfig或ip adns服务器cat /etc/resolv.conf主机名hostname路由 route -n
网络连接状态ss或netstatif域名解析nslookup或host 修改linux基础的网络设置
ifconfig命令 ifconfig默认显示活动的网卡ifconfig -a显示所有的网卡ifconfig 网卡名称只显示前面的网卡信息ifconfig 网卡 down关闭网卡ifconfig 网卡 up开启网卡ifconfig ens33:0 IP地址/子网掩码设置虚拟网卡 主机名 hostname 主机名文件在/etc/hostname
hostname查看主机名hostname 主机名临时修改主机名hostnamectl set-hostname 主机名永久修改主机名 vim /etc/hostname 将名字写入文件也是永久修改 （只有写在第一行有用）
网络连接状态 ss -natup 快 更靠近内核
n数字a详细ttcpuudpp相关程序及pid netstat 慢 它要去遍历文件查看状态
路由 route route -n显示路由表 -n数字形式显示路由表route add -net 10.0.0.0/8 gw 192.168.91.2添加一条去往10.0.0.0段的路由，通过网关192.168.91.2转发route del -net 10.0.0.0/8删除去往10.0.0.0段的路由route add -net 0.0.0.0(default) gw 192.168.91.2添加默认路由route del -net 0.0.0.0(default)删除默认路由 永久添加路由 vim /etc/sysconfig/network-scripts/route-ens33
10.0.0.0/24 via 192.168.91.100
systemctl restart network
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada228af80169045fbb57d2d421ae49a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ad5a10f17dcafcbae79fdac642322f/" rel="bookmark">
			Mysql判断一个表中的数据是否在另一个表存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方式一： 判断A表中有多少条数据在B表中【存在】,并且显示这些数据–EXISTS语句
select A.ID, A.NAME from 表A where EXISTS(select * from 表B where A.ID=B.ID) 判断A表中有多少条数据在B表中【不存在】，并且显示这些数据–NOT EXISTS语句
select A.ID, A.NAME from 表A where NOT EXISTS(select * from 表B where A.ID=B.ID) 方式二： select dataid ,if(dataid in (select ID from aip_1732602471460208641_file where ID IN (1095882,1095883)),"yes","no") from gf_file 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/12/">«</a>
	<span class="pagination__item pagination__item--current">13/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/14/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>