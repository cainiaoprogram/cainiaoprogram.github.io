<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/531e0664e180e35423417bf43cf08e19/" rel="bookmark">
			HTML是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML是什么？ HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。
超文本是一种组织信息的方式，它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，为人们查找，检索信息提供方便。
由来 HTML的英文全称是 Hyper Text Markup Language，即超文本标记语言。HTML是由Web的发明者 Tim Berners-Lee和同事 Daniel W. Connolly于1990年创立的一种标记语言，它是标准通用化标记语言SGML的应用。用HTML编写的超文本文档称为HTML文档，它能独立于各种操作系统平台(如UNIX， Windows等)。使用HTML，将所需要表达的信息按某种规则写成HTML文件，通过专用的浏览器来识别，并将这些HTML文件“翻译”成可以识别的信息，即现在所见到的网页。
自1990年以来，HTML就一直被用作万维网的信息表示语言，使用HTML描述的文件需要通过web浏览器显示出效果。HTML是一种建立网页文件的语言，通过标记式的指令(Tag)，将影像、声音、图片、文字动画、影视等内容显示出来。事实上，每一个HTML文档都是一种静态的网页文件，这个文件里面包含了HTML指令代码，这些指令代码并不是一种程序语言，只是一种排版网页中资料显示位置的标记结构语言，易学易懂，非常简单。HTML的普遍应用就是带来了超文本的技术―通过单击鼠标从一个主题跳转到另一个主题，从一个页面跳转到另一个页面，与世界各地主机的文件链接超文本传输协议规定了浏览器在运行HTML文档时所遵循的规则和进行的操作。HTTP的制定使浏览器在运行超文本时有了统一的规则和标准。
万维网（world wide web，简称www）上的一个超媒体文档称之为一个页面（外语：page）。作为一个组织或者个人在万维网上放置开始点的页面称为主页（外语：Homepage）或首页，主页中通常包括有指向其他相关页面或其他节点的指针（超级链接），所谓超级链接，就是一种统一资源定位器（Uniform Resource Locator，外语缩写：URL）指针，通过激活（点击）它，可使浏览器方便地获取新的网页。这也是HTML获得广泛应用的最重要的原因之一。在逻辑上将视为一个整体的一系列页面的有机集合称为网站（Website或Site）。超文本标记语言（英文缩写：HTML）是为“网页创建和其它可在网页浏览器中看到的信息”设计的一种标记语言。
网页的本质就是超文本标记语言，通过结合使用其他的Web技术（如：脚本语言、公共网关接口、组件等），可以创造出功能强大的网页。因而，超文本标记语言是万维网（Web）编程的基础，也就是说万维网是建立在超文本基础之上的。超文本标记语言之所以称为超文本标记语言，是因为文本中包含了所谓“超级链接”点。
定义
超文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。网页文件本身是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容（如：文字如何处理，画面如何安排，图片如何显示等）。浏览器按顺序阅读网页文件，然后根据标记符解释和显示其标记的内容，对书写出错的标记将不指出其错误，且不停止其解释执行过程，编制者只能通过显示效果来分析出错原因和出错部位。但需要注意的是，对于不同的浏览器，对同一标记符可能会有不完全相同的解释，因而可能会有不同的显示效果。
HTML版本历史 HTML 1.0：在1993年6月作为互联网工程工作小组(IETF)工作草案发布。
HTML 2.0：1995年1 1月作为RFC 1866发布，于2000年6月发布之后被宣布已经过时。
HTML 3.2：1997年1月14日，W3C推荐标准。
HTML 4.0：1997年12月18日，W3C推荐标准。
HTML 4.01（微小改进）：1999年12月24日，W3C推荐标准。
HTML 5：HTML5是公认的下一代Web语言，极大地提升了Web在富媒体、富内容和富应用等方面的能力，被喻为终将改变移动互联网的重要推手。Internet Explorer 8及以前的版本不支持。
超文本标记语言HTML 英文：Hyper Text Markup Language
区分：
HTML ----超文本标记语言—展示数据
XML ---- 可扩展标记语言 ----存储数据 配置文件 json
内容：
HTML ----固定标签 h1 body
XML ---- 没有固定标签 任何标签都可以。 标签—Tag
关于HTML+CSS 部分的知识内容 大家可以到W3C的网站去学习
HTML文档的结构 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/531e0664e180e35423417bf43cf08e19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7934d045da40956ae0e4dd3c4257747c/" rel="bookmark">
			VS code内置浏览器插件-Preview on Web Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS code内置浏览器需要自己下载安装，下面我们就来看看下载安装使用VS code内置浏览器的图文教程。
软件名称：
Visual Studio Code(代码编辑器) v1.51.1 64位 中文免费绿色版
软件大小：
60.7MB
更新时间：
2020-11-13立即下载
1、打开VS code
2、点击如图所示的插件商店
3、点击顶部搜索栏输入“Preview on Web Server”
4、 搜索结果第一个就是 点击install下载
5、回到代码部分 ，鼠标右键单击，鼠标左键单击选择最后一行 如图所示
6、这样VS code内置浏览器效果就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33632f31ac1b28d5a2c3dea16b7e1ea/" rel="bookmark">
			Linux内不能使用Tab键进行命令补全！！！原因竟然是……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多初次学习LInux的小伙伴私信，为什么无法使用tab键补全命令
有可能在安装的时候选择的是最小化mini安装，像CentOS7最小化安装是默认没有命令补全的，需要自行安装。
[root@localhost ~]# yum install -y bash-completion #下载命令补全工具
[root@localhost ~]# bash #这里使用bash进入新的shell，也可以选择重启虚拟机
恭喜你，完成到了最后，你也太棒了吧！（不考虑给个三连吗？恶搞标题，不喜欢勿喷）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2089d1274636c87b9afc5c1fdfbc62c6/" rel="bookmark">
			IntelliJ IDEA 开发zookeeper环境设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zookeeper版本是: apache-zookeeper-3.7.0
IntelliJ 版本是: IntelliJ IDEA 2021.1 (Community Edition)
1.使用IntelliJ 打开zookeeper源码目录: 2. 将conf文件夹下的zoo_sample.cfg复制为zoo.cfg 3. 创建数据存储目 右击apache-zookeeper-3.7.0[parent]， New-&gt;Directory，输入tmp/zookeeper
4. 编译zookeeper包，点击右侧边栏的Maven，打开Maven窗口 这是为解决 程序包org.apache.zookeeper.data不存在 的错误;
点击Apache Zookeeper -&gt; compile
5. QuorumPeerMain运行设置 定位到zookeeper-server-&gt; src-&gt; main -&gt; java -&gt;org -&gt;apache -&gt;zookeeper -&gt;server -&gt;quorum -&gt; QuorumPeerMain
右击QuorumPeerMain -&gt; Modify Run Configuration…
然后点击Modify options -&gt; Add VM option
输入如下参数: 都是在源码conf目录下
6. 定位到zookeeper-server -&gt; pom.xml 将所有的provided注释掉
这是为了解决 Exception in thread “main” java.lang.NoClassDefFoundError: com/codahale/metrics/Reservoir的错误;
7. 运行 右击QuorumPeerMain -&gt; Run “QuorumPeerMain.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2089d1274636c87b9afc5c1fdfbc62c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b4a27e176f4cb442b9e2a1dddaba1b/" rel="bookmark">
			C# 复制文件夹及文件夹目录下的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/// &lt;summary&gt;
/// 复制文件夹中的所有内容
/// &lt;/summary&gt;
/// &lt;param name="sourceDirPath"&gt;源文件夹目录&lt;/param&gt;
/// &lt;param name="targetDirPath"&gt;目标文件夹目录&lt;/param&gt;
public static void CopyDirectory(string sourceDirPath, string targetDirPath)
{
try
{
//如果文件夹不存在，则创建
if (!Directory.Exists(targetDirPath)) { Directory.CreateDirectory(targetDirPath); }
string[] files = Directory.GetFiles(sourceDirPath);
foreach (string file in files)
{
var fullPath = Path.Combine(targetDirPath, Path.GetFileName(file));
Console.WriteLine(fullPath);
File.Copy(file, fullPath, true);
}
string[] dirs = Directory.GetDirectories(sourceDirPath);
foreach (string dir in dirs)
{
//递归
CopyDirectory(dir, Path.Combine(targetDirPath, Path.GetFileName(dir)));
}
}
catch (Exception ex)
{
Console.WriteLine("error= "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b4a27e176f4cb442b9e2a1dddaba1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a505f345f93467816eee1eaa431b7b/" rel="bookmark">
			Pyinstaller打包exe运行提示Failed to execute script pyi_rth_certifi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 使用pyinstaller打包后，运行exe报错如下图：
解决办法 安装OpenSSL库
下载页面：https://slproweb.com/products/Win32OpenSSL.html
默认安装之后就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608cc836ac1a47b97974a8a0426eea3d/" rel="bookmark">
			python在mysql中插入或者更新null空值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlQu = 'SELECT id,university_id,grade FROM a_kuakao_school WHERE university_id &gt; 0 ORDER BY university_id ASC' self.cursor.execute(sqlQu) result = self.cursor.fetchall() for row in result: if row[4]: grade = '"%s"' % row[2] else: grade = 'NULL' sqlUp = 'UPDATE university SET grade = %s WHERE id = %d' % (grade,row[1]) print(sqlUp) self.cursor.execute(sqlUp) self.cursor.connection.commit() python在mysql中插入null空值应该跟上边的代码一样。
注意：语句grade = %s不加引号（重点）改在上边判断如果grade = "%s"一旦加上引号之后语句就是UPDATE university SET grade = "NULL" WHERE id = 1
引号不加的话字符串肯定是更新或者插入不进去的，这样
if row[4]:
grade = '"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/608cc836ac1a47b97974a8a0426eea3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42d820db36d10f508921cb78247e280/" rel="bookmark">
			ubuntu更换apt源、pip源和conda源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu更换apt源、pip源和conda源 ​ 在配置深度学习环境，下载安装包时，主要会使用apt源、pip源和conda源这三个进行包的下载。
一、更换apt源
​ 1.1、存放apt源的配置文件路径为/etc/apt/source.list，首先要对这个配置文件进行备份，备份命令如下。
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak ​ 如果需要恢复原来的配置文件，只需要用备份的配置文件覆盖原来的配置文件即可，命令如下。
sudo cp /etc/apt/sources.list.bak /etc/apt/sources.list ​ 1.2、使用gedit打开source.list文件，命令如下。
sudo gedit /etc/apt/sources.list ​ 打开界面如下，删除其中的内容，将阿里云镜像源粘贴在其中，点击保存。
​ 不同版本的ubuntu系统，所粘贴的镜像源内容有所不同。
​ ubuntu16.04：
deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d42d820db36d10f508921cb78247e280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb837170a723701058b6b3e4d99c8ec7/" rel="bookmark">
			python学习 字符串与正则表达式详解1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python学习 字符串与正则表达式 背景知识
字符：数字、字母、字、符号等等都是字符，如8、H、h、国、&amp;等
字符串：2是一个字符，s、c、h、o、o、l都是字符，现在我将这些字符连接起来，123pythonschool就是一个由15个字符组成的字符串字符串常用操作
2.1拼接字符串
“+”，可以完成多个字符串的拼接 entext = 'I am busy coding.' cntext = '正在码代码。' print(entext + '---' + cntext) I am busy coding.---正在码代码。 #字符串不允许直接和其他类型的数据拼接
str1 = '我今天一共走了' num = 12345 str2 = '步' print(str1 + str(num) + str2) 我今天一共走了12345步 2.2计算字符串的长度
首先需要了解各字符所占的字节数
①ASCII码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。
②UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。
③Unicode编码中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。
符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。
④UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。
⑤UTF-32编码中，世界上任何字符的存储都需要4个字节。
len()函数计算字符的长度
len(string) str = '人生苦短，我用python!' length = len(str) print(length) 14 通过len()计算字符串的长度时，不区分英文中文数字，所有字符都认为是一个。 在实际开发时，有时需要获取字符串实际所占的字节数，即如果采用UTF-8编码，汉字占3个字节， 采用GBK或者GB2312时，汉字占2个字节.这时需要用encode()方法进行编码后再进行获取。 str = '人生苦短，我用python!' length1 = len(str.encode('gbk')) length2 = len(str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb837170a723701058b6b3e4d99c8ec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93e9eae3da8cd0f44266a43546c78d19/" rel="bookmark">
			golang 第四课  结构体(struct)、interface{}、方法(func)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频教程地址: bilibili.com/video/BV1aU4y1h7dE/
func 方法 跟其它语言的差不多，多了一个可以传 0 个 或多个参数的形式
// 无参数 无返回值 func fn() { // 方法的格式 // func funcName(arg type ...) ([arg] type ...) { // 返回值只有一个可以省略括号 // } } // 有参数 有返回值 func fn1(arg1 int, arg2 int) (a int) { // 返回参数名可以指定，这样在方法体内就不需要声明了 a = arg1 + arg2 return } // 0个或多个参数 func fn2(args ...int) { fmt.Printf("%T, %v\n", args, args) a := 0 for _, k := range args { a += k } fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93e9eae3da8cd0f44266a43546c78d19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b11696e8ea6dabe52b492851447b3a0/" rel="bookmark">
			可视化 | Python绘制精美仪表盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 准备工作1.1 pyechars安装1.2 导入模块 2. 绘制仪表盘2.1 基本仪表盘2.2 改变刻度盘半径，去掉文字标签2.3 改变刻度盘颜色2.4 纯数字显示标签2.5 速度仪表盘 推荐阅读 大家好，我是欧K。
仪表盘是一种拟物化图表，比如我们平时看到的水表，气压表，时速表等，可以很直观的观测数据和设备状态。本期给大家分享如何使用python绘制仪表盘，希望对你有所帮助。
1. 准备工作 1.1 pyechars安装 这里有两种安装方法：
# 方法1 pip install pyecharts # 方法2 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ pyecharts 1.2 导入模块 from pyecharts import options as opts from pyecharts.charts import Gauge 2. 绘制仪表盘 2.1 基本仪表盘 代码：
c1 = ( Gauge() .add('', [("完成率", 80)]) .set_global_opts( title_opts=opts.TitleOpts(title='基本仪表盘'), legend_opts=opts.LegendOpts(is_show=False), ) .render("gauge_base.html") ) 效果：
add函数部分参数：
def add( # 系列名称，用于 tooltip 的显示，legend 的图例筛选。 series_name: str, # 系列数据项，格式为 [(key1, value1), (key2, value2)] data_pair: Sequence, # 是否选中图例 is_selected: bool = True, # 最小的数据值 min_: Numeric = 0, # 最大的数据值 max_: Numeric = 100, # 仪表盘平均分割段数 split_number: Numeric = 10, # 仪表盘半径，可以是相对于容器高宽中较小的一项的一半的百分比，也可以是绝对的数值。 radius: types.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b11696e8ea6dabe52b492851447b3a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc2adc0597d4f750b2f457d88bc266a5/" rel="bookmark">
			[Vue warn]: Error in render: “TypeError: i.reduce is not a function“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		框架说明 Element UI 和 vue 情况说明：
类型错误：[Vue warn]: Error in render: “TypeError: i.reduce is not a function”
这种情况一般来说，是赋值错误，类型不匹配。
我这里用的是ElementUI中的table模块
于是去官方文档看了一下参数类型
发现我传过来的不是集合类型的，而他需要的是集合类型。所以出现了上面的报错。
解决方法： 将后台传来的数据改为集合 即可。
ElementUI官网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5330972280bd6abfc640b79c0fbd2610/" rel="bookmark">
			各邮箱服务商的接收、发送邮件服务器地址、端口号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各邮箱服务商的收、发邮件服务器地址、端口号 后端开发邮件的收发功能（Java后端实现多附件邮件发送案例讲解）时总是需要针对不同的邮箱服务商做出不同的邮件接收、发送服务器地址和端口号的配置，本文中主要介绍和记录两种常用的邮件服务器：POP3和SMTP及其端口号（其实还有一种IMAP类型的，但是不建议使用，因为这种类型的权限太大，容易出问题），两种服务器协议分别是介绍分别如下：
POP3
POP3是Post Office Protocol3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。 SMTP
SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。 国内常用各大邮箱的收发邮件服务器及其端口号：
网易163邮箱（mail.163.com）:
POP3服务器地址：pop.163.com（端口：110）
SMTP服务器地址：smtp.163.com（端口：25）
网易126邮箱（mail.126.com）：
POP3服务器地址：pop.126.com（端口：110）
SMTP服务器地址：smtp.126.com（端口：25）
移动139邮箱（mail.10086.cn）：
POP3服务器地址：POP.139.com（端口：110）
SMTP服务器地址：smtp.139.com(端口：25)
腾讯QQ邮箱（mail.qq.com）：
POP3服务器地址：pop.qq.com（端口：110）
SMTP服务器地址：smtp.qq.com （端口：25）
腾讯QQ企业邮箱（exmail.qq.com） ：
POP3服务器地址：pop.exmail.qq.com （SSL启用 端口：995）
SMTP服务器地址：smtp.exmail.qq.com（SSL启用 端口：587/465）
谷歌Gmail邮箱（mail.google.com）：
POP3服务器地址：pop.gmail.com（SSL启用 端口：995）
SMTP服务器地址：smtp.gmail.com（SSL启用 端口：587）
腾讯Foxmail邮箱（mail.qq.com）：
POP3服务器地址：pop.foxmail.com（端口：110）
SMTP服务器地址：smtp.foxmail.com（端口：25）
新浪sina邮箱（mail.sina.com.cn）:
POP3服务器地址：pop3.sina.com.cn（端口：110）
SMTP服务器地址：smtp.sina.com.cn（端口：25）
新浪sinaVIP邮箱（mail.sina.com.cn）：
POP3服务器：pop3.vip.sina.com （端口：110）
SMTP服务器：smtp.vip.sina.com （端口：25）
搜狐sohu邮箱（mail.sohu.com）:
POP3服务器地址：pop3.sohu.com（端口：110）
SMTP服务器地址：smtp.sohu.com（端口：25）
雅虎yahoo邮箱（login.yahoo.com）:
POP3服务器地址：pop.mail.yahoo.com
SMTP服务器地址：smtp.mail.yahoo.com
雅虎yahoo.com.cn邮箱（login.yahoo.com）:
POP3服务器地址：pop.mail.yahoo.com.cn（端口：995）
SMTP服务器地址：smtp.mail.yahoo.com.cn（端口：587 ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5330972280bd6abfc640b79c0fbd2610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ae1590352a19e583b543cf825f394d/" rel="bookmark">
			Anconda安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anconda安装教程 一、下载
​ 下载地址：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ ，一般64位ubuntu系统下载的-Linux-x86_64.sh后缀格式的Anconda，例如下载的是Anaconda3-5.3.0-Linux-x86_64.sh。
二、安装
​ 2.1、默认下载的目录是~/Downloads下，进入Downloads目录下，运行bash命令，进行安装。
cd ~/Downloads bash Anaconda3-5.3.0-Linux-x86_64.sh ​ 2.2、安装过程中会询问是否将路径安装到环境变量中，输入yes就行，然后可以在~/.bashrc文件中，会有下图所示的一行代码，只有其中的用户名不相同。
​ 2.3、添加路径之后，即安装完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b9938e364d546662293786a7ef4a5e3/" rel="bookmark">
			避免HashMap扩容的正确姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置HashMap的初始容量 HashMap在Java的使用中占据着很重要的地位，平时使用的时候，相信很多Java程序员都知道在定义HashMap的时候，给它设置一个初始容量，以便减少hashMap扩容（resize）带来的额外开销，比如像我同（zi）事（ji）的这段代码：
@Test public void longLongAGo() { int count = 1000000; System.out.println("---------------- 不设置hashMap初始容量 ------------"); long start = System.currentTimeMillis(); HashMap&lt;Integer, Object&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; count; i++) { map.put(i, UUID.randomUUID()); } long end = System.currentTimeMillis(); System.out.println("添加1000000个元素耗时：" + (end - start)); System.out.println("---------------- 设置hashMap初始容量 -------------------"); long start1 = System.currentTimeMillis(); HashMap&lt;Integer, Object&gt; map1 = new HashMap&lt;&gt;(count); for (int i = 0; i &lt; count; i++) { map1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b9938e364d546662293786a7ef4a5e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba1b767f442b5d6025f928761026fed4/" rel="bookmark">
			默认python版本从 2换到3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		update-alternatives --install /usr/bin/python python /usr/bin/python3 150
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b91a7e4bc5244cc53c3578599d8c1db/" rel="bookmark">
			uniapp 躺坑之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp 页面传递参数 数据过大的解决办法 传递参数:encodeURIComponent(JSON.stringify(data))
接受参数:JSON.parse(decodeURIComponent(data))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7158d9efec13d1029da005a0d9180e0d/" rel="bookmark">
			ALTER USER ‘root‘@‘localhost‘ IDENTIFIED WITH mysql_native_password BY ‘123456‘；记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 alter user ‘root‘@’localhost’identified with mysql_native_password by ‘新密码’; 这行会报错，You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'mysql_native_password by 123456' at line 1 正确如下：
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a32977424bf6a03519a762727bd885b/" rel="bookmark">
			Apache服务的家目录修改和主页类型或主页名的修改（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.家目录修改
[root@xiaolu conf.d]# vi /etc/httpd/conf/httpd.conf #进入Apache服务的配置文件
将文件内的“/var/www/html“进行替换，博主选择的是替换为/morning
[root@xiaolu conf.d]# mkdir /morning #创建Apachef服务的家目录
[root@xiaolu conf.d]# cd /morning #切换到Apachef服务的家目录
[root@xiaolu morning]# touch /morning/index.html #创建主页
[root@xiaolu morning]# echo “Welcome to my stage!” &gt;&gt; index.html #将一句话追加到主页文件中
[root@xiaolu morning]# systemctl restart httpd #重启服务
[root@xiaolu morning]# curl 172.16.70.10 #用curl命令获取主页内容
Welcome to my stage!
当然我们叶可以在浏览器上输入http://IP地址，进行查看，如下图：
2.修改主页类型或主页名
[root@xiaolu morning]# vi /etc/httpd/conf/httpd.conf #进入Apache服务的配置文件
将主页名index修改为bilibili
[root@xiaolu morning]# systemctl restart httpd #重启服务
在浏览器上输入http://IP地址，进行查看，可以发现无法访问到主页内容，如下图：
[root@xiaolu morning]# mv index.html bilibili.html #修改文件名
[root@xiaolu morning]# ls #查看目录下的文件名是否修改成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a32977424bf6a03519a762727bd885b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c212a96ffb0cd3774cc3ca74a93e391b/" rel="bookmark">
			VSCode npm scripts面板无法显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm scripts 面板无法显示 解决方案1解决方案2 解决方案1 打开一个json文件然后直接关闭vscode，再次打开vscode，可以正常启动。
解决方案2 打开VSCode的设置，选择Edit in settings.json，最后一行输入：
npm.enableScriptExplorer = true, VSCode v1.23官方发布说明
解决方案的讨论地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af994ecfcfe3a2272cbfa0fe5dd7ab0f/" rel="bookmark">
			Alpha-Beta剪枝算法原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 前言 前文：极小化极大（Minimax）算法原理
极小化极大算法在完全信息零和博弈中，基于己方努力使得在N步后优势最大化（即评估函数输出值最大化）和对方努力使得N步后己方优势最小化这两个出发点，构建决策树。在决策树上通过这两个出发点的内在逻辑进行搜索，最后给出行动策略。
显然，极小化极大算法需要展开整个决策树，对于局面复杂的问题，其搜索空间将会非常大。
同时，我们可以清晰地看到有部分节点是否被搜索不会影响最后的结果，因此，无需展开此类节点以及计算此类节点的子节点的估值。
通过上述方法，可节省算法的搜索时间。这种不展开搜索不必要节点的算法，被称为——Alpha-Beta剪枝算法。
2. 算法原理 Alpha-Beta剪枝算法可加速极小化极大算法的搜索过程。在构建和搜索决策树时，每个节点除存储局面估值之外，还存储可能取值的上下界。下界即为Alpha值，上界即为Beta值。
2.1 Alpha剪枝 如图1所示，在对max节点的子节点进行搜索时，子节点是否需要进一步展开搜索受到其兄弟节点值的影响。
图1中每个矩形节点为max节点，圆形节点为min节点。节点b的minimax值为3，节点d的minimax值为8，节点e的minimax值为2。因为节点c为一个min节点，其minimax值为其所有子节点minimax值中的最小值。又因为节点a为max节点，其minimax值为其所有子节点minimax值中的最大值。因此，当搜索到节点c的子节点e时，节点c的其余子节点不用展开搜索。
节点e的minimax值为2,节点c为min节点，因此节点c的minimax值必然小于或等于2。又因为节点a为max节点，且其子节点b的minimax值为3，因此节点a的minimax值必然大于或等于3。
反过来考虑：若按照极小化极大算法逻辑，将节点c的子节点全部展开搜索完毕，节点c的minimax值必然不会大于2。又因为节点b的minimax值为3，因此不论搜索完毕后节点c的minimax值取任何不大于2的值，均不会影响节点a的minimax值。最终不会影响决策树根节点的minimax值和相应的行动策略。
2.2 Beta剪枝 如图2所示，在对min节点的子节点进行搜索时，子节点是否需要进一步展开搜索也受到其兄弟节点值的影响。
图2中每个矩形节点为max节点，圆形节点为min节点。节点b的minimax值为4，节点d的minimax值为8。因为节点c为一个max节点，其minimax值为其所有子节点minimax值中的最大值。又因为节点a为min节点，其minimax值为其所有子节点minimax值中的最小值。因此，当搜索到节点c的子节点d时，节点c的其余子节点不用展开搜索。
节点d的minimax值为8,节点c为max节点，因此节点c的minimax值必然大于或等于8。又因为节点a为min节点，且其子节点b的minimax值为4，因此节点a的minimax值必然小于或等于4。
反过来考虑：若按照极小化极大算法逻辑，将节点c的子节点全部展开搜索完毕，节点c的minimax值必然不会小于8。又因为节点b的minimax值为4，因此不论搜索完毕后节点c的minimax值取任何不小于8的值，均不会影响节点a的minimax值。最终不会影响决策树根节点的minimax值和相应的行动策略。
3. 算法过程 根据上述原理，Alpha-Beta剪枝算法过程可描述如下：
开始构建决策树；将估值函数应用于叶子节点；使用深度优先搜索顺序构建和搜索决策树，传递并更新 α 、 β 、 节 点 m i n i m a x 值 \alpha、\beta、节点minimax值 α、β、节点minimax值； max结点更新α值(下限)，Min结点更新β值(上限)。
从根结点选择评估值最大的分支，作为行动策略。 3.1 算法过程图解 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bae0473fcb93982016ef78fe0c3677c/" rel="bookmark">
			解决 Android Emulator 无法联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案 这很可能是 DNS 未被正确配置导致的。
通过 Terminal ，进入 emulator 文件夹。
以 emulator -list-avds 命令列出模拟器列表
提前关闭模拟器
以 emulator @&lt;your_target_emulator_name&gt; -dns-server 8.8.8.8 命令启动模拟器。
​ 这个命令带有附加条件：设置 DNS 为 8.8.8.8
启动后即可联网
参考资料 https://cafonsomota.medium.com/android-emulator-when-theres-no-connection-to-the-internet-129e8b63b7ce
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeadebc62e8aa3c349d609387cc8c1fc/" rel="bookmark">
			idea和maven设置代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一次内网开发，idea和maven设置代理的过程
遇到的坑，分享出来，供大家参考！
先说一下本次开发的情况：
首先是我开发的环境是需要代理才能访问外网的，所以导致idea无法从阿里云下载最新的pom依赖。
以下是我的解决过程 idea配置代理
到此，完成idea的代理配置，一般代理的ip和端口号你问一下就知道了，而且内网开发的代理在开发之前就应该给你的。ip写自己的也行，我是直接写的代理ip。
你现在可以下载idea的插件啥的测试了，完全没问题了。开始配置maven的代理，为什么呢？这里需要着重强调一下，如果你只是单纯的配置了idea的代理，那么在你新添加了pom依赖后，依旧无法从阿里云或者中央仓库去下载对应的jar包，说白了就是无法访问到。
下面开始进行配置
另外把seeting.xml中配置的阿里云配置也贴出来供大家参考： 到此将全部的操作结束，可以正常的下载pom依赖了！
测试：
这里可以看到，引入的糊涂工具类版本号没有飘红，而且右侧的依赖也没有飘红出错。可以正常使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccabbbac0c5ccba499c4855bb8b80a46/" rel="bookmark">
			Apache服务的搭建与网页的简单配置（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载安装并启动Apache
[root@xiaolu conf]# yum install -y httpd #yum 安装
[root@xiaolu conf]# systemctl start httpd #使用systemctl命令启动Apche
Job for httpd.service failed because the control process exited with error code.
See “systemctl status httpd.service” and “journalctl -xe” for details.
#注意这里报错，httpd启动失败，我们使用lsof命令查看一下Apache服务的默认端口80
[root@xiaolu conf]# lsof -i:80 #lsof是一个列出当前系统打开文件的工具,-i选项列出符合条件的进程，-i用法：在i后接4、6、协议、:端口、 @ip
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
nginx 1083 root 8u IPv4 27484 0t0 TCP *:http (LISTEN)
nginx 1085 nobody 8u IPv4 27484 0t0 TCP *:http (LISTEN)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccabbbac0c5ccba499c4855bb8b80a46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407f9fc6a5ea4e28c911f3d3c1de0ae2/" rel="bookmark">
			SSM整合：pom.xml中的`＜packaging＞`标签上报错：Plugin execution not covered by lifecycle configuration: org.apach
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eclipse在pom.xml中的&lt;packaging&gt;标签上报错：Plugin execution not covered by lifecycle configuration: org.apache.maven.plugins:maven-resources-plugin:2.6:resources (execution: default-resources, phase: process-resources)
百度了很久，改pom.xml配置文件或改lifecycle-mapping-metadata.xml文件，都没有用。
后来用了这个方法才弄好：
1、打开eclipse或myeclipse的问题显示窗口：‘Window’ -&gt; ‘Show View’ -&gt; ‘Problems’
2、右击一个显示描述为“ ‘Plugin execution not covered by lifecycle configuration: com.googlecode.mavenfilesync:maven-filesync-plugin:1.0.0:generate (execution: default, phase: initialize)’”的报错信息，在弹出的菜单中选着“‘Quick Fix’”
3、在Quick Fix窗口中,选中 ‘Permanently mark goal generate in pom.xml as ignored in Eclipse build’，然后点击 ‘Finish’-》选 ‘OK’
4、Eclipse和myeclipse可能会报错 ‘Projct configuration is not up-to-date with pom.xml. Run project configuration update’.按照上述方法，右击“quick Fix”解决
5、重复 2-3步骤解决其他的问题
引用：pom.xml文件报错：Plugin execution not covered by lifecycle…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/450e01bcc72aca870a1e1a0a3511f89f/" rel="bookmark">
			LeetCode每日一题，Z字形变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 Z 字形变换 https://leetcode-cn.com/problems/zigzag-conversion/
公众号 《java编程手记》记录JAVA学习日常，分享学习路上点点滴滴，从入门到放弃，欢迎关注
描述 难度：中等
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：
P A H N
A P L S I I G
Y I R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。
请你实现这个将字符串进行指定行数变换的函数：
string convert(string s, int numRows);
示例 1：
输入：s = "PAYPALISHIRING", numRows = 3 输出："PAHNAPLSIIGYIR" 示例 2：
输入：s = "PAYPALISHIRING", numRows = 4 输出："PINALSIGYAHRPI" P I N
A L S I G
Y A H R
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/450e01bcc72aca870a1e1a0a3511f89f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6fbc56535910a24dbb268d46df454b/" rel="bookmark">
			LINUX GPIO 基操之应用层操作gpio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LINUX GPIO 基操之应用层 应用层sysfs操作GPIO相关文件节点介绍如何编写应用程序操作GPIO如何通过寄存器操作GPIO 注：所有文章基于linux-3.13 以上，本系列主要介绍 GPIO的一些基本知识，驱动操作GPIO的接口，应用层通过sysfs操作GPIO的接口，GPIO一些debug信息查看，以及对高通相关GPIO的寄存器操作。分享给刚刚接触外设bsp的小伙伴们。当然后面有时间还会分享GPIO子系统框架和pinctrl子系统框架，先知道黑盒怎么使用，然后咱再打开仔细瞅瞅。有错误不正当点，勿喷，还请指出，一起修改，谢谢！！ 本篇为应用层控制接口篇，主要分享，应用层对gpio的操作和如何通过寄存器操作gpio（主要介绍高通的寄存器方式）。 应用层sysfs操作GPIO 相关文件节点介绍 1）导出节点
//下面的动作前提是要先导出对应的gpio，动态生成了对应的节点才能下一步操作 echo 1 &gt; /sys/class/gpio/export 2） 设置输入方向，读取对应的值
echo in &gt; /sys/class/gpio/gpio1/direction cat /sys/class/gpio/gpio1/value 3）设置输出方向，设置对应的值
echo out &gt; /sys/class/gpio/gpio1/direction //拉高 echo 1 &gt; /sys/class/gpio/gpio1/value //拉低 echo 1 &gt; /sys/class/gpio/gpio1/value 4） 设置中断触发方式
//设置的中断触发方式 none rising falling both， echo none &gt; /sys/class/gpio/gpio1/edge // 要结合poll机制来获取对应gpio口的中断 5）销毁对应GPIO节点
echo 1 &gt; /sys/class/gpio/unexport 如何编写应用程序操作GPIO 我们完全可以通过调用system的方式实现上面提到的前三种操作,但是无法实现中断的监控，而且system方式太消耗资源。linux里面万物皆文件，下面重点介绍如何通过open，write，poll等方式对gpio进行操作。
1）需要包含的头文件
#include stdlib.h #include stdio.h #include string.h #include unistd.h #include fcntl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb6fbc56535910a24dbb268d46df454b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceddbb48618e033e9cb22edf04e03143/" rel="bookmark">
			极小化极大（Minimax）算法原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 极小化极大算法是基于决策树和搜索的智能系统中的典型算法，可用于指导井字棋、黑白棋、五子棋等经典完全信息零和博弈。虽在学生时代学习过极小化极大算法，但时过境迁，思量该算法的来龙去脉已然如雾里探花水中望月。近来自学人工智能算法，恰好又一次接触到了该算法，也算与其有缘，理应将其悉数记下。下文将以井字棋为例详细说明该算法原理。
2. 博弈树 2.1 井字棋 井字棋(Tic-Tac-Toe)是由两个玩家轮流在3X3的格子上标记自己符号（圈或者叉）的游戏，最先以横、直、斜连成一线则获胜，如下图所示。
2.2 博弈树构建 以完全信息零和游戏“井字棋”为例，将每一个局面均视为一棵树上一个节点，每一个动作视为树上的边，因此“井字棋”游戏可以被完全展开成一棵树。一局游戏的发展过程是博弈树从根节点到叶结点的一条路径。井字棋的博弈树最高有9层，如下图所示（井字棋博弈树前3层）。
3. 估值函数 估值函数使用来给每一个局面给出一个估值，用判断博弈树中当前局面的形势。在传统的棋类游戏智能系统中，估值函数一般是人为指定的，对棋类游戏智能的水平有决定性作用。
估值函数的形式不是固定的，它的输入一般是一个局面的信息，输出是一个表明相应局面好坏程度的数值。为了说明极小化极大算法，本文中规定井字棋的估值函数为：玩家X还存在可能性的行、列、斜线数减去玩家O还存在可能性的行、列、斜线数。如图3所示，玩家X还存在可能性的行、列、斜线数为6，玩家O还存在可能性的行、列、斜线数为3，因此估值函数在图3局面下的输出为3。
4. 极小化极大算法 4.1 算法原理 在零和博弈中，玩家均会在可选的选项中选择将其N步后优势最大化或者令对手优势最小化的选择。将双方决策过程视作一颗决策树，若决策树某一层均为己方决策依据状态（即接下来是己方进行动作），则己方必定会选择使得己方收益最大化的路径，将该层称为MAX层。若决策树某一层均为对手决策依据状态（即接下来是对手进行动作），则对手必定会选择使得己方收益最小化的路径，将该层成为MIN层。由此，一个极小化极大决策树将包含max节点（MAX层中的节点）、min节点（MIN层中的节点）和终止节点（博弈终止状态节点或N步时的状态节点）。每个节点对应的预期收益成为该节点的minimax值。
对于终止结点， minimax值等于直接对局面的估值。对于max结点，由于max节点所选择的动作将会由己方给定，因此选择minimax值最大的子结点的值作为max结点的值。对于min结点，则选择minimax值最小的子结点的值作为min结点的值。
极小化极大算法过程可描述如下：
构建决策树；将评估函数应用于叶子结点；自底向上计算每个结点的minimax值；从根结点选择minimax值最大的分支，作为行动策略。 minimax计算流程如下：
如果节点是终止节点：应用估值函数求值；如果节点是max节点：找到每个子节点的值，将其中最大的子节点值作为该节点的值；如果节点时min节点：找到每个子节点的值，将其中最小的子节点值作为该节点的值。 4.2 算法过程 如图4所示，假设玩家X可在井字棋游戏中向下思考3步，则其必定会选择3步后优势最大的落子策略。构建3层决策树如下，对于每一个叶结点，可运用上述估值函数得到叶结点对应局面的估值。
由于叶结点所在层的上一层到叶结点层的动作由玩家X作出，因此叶结点层上一层为MAX层。玩家X会选择使得己方局面最佳的落子方法，因此MAX层的节点的minimax值应该为下一层中最大的值。
同时，MIN层到MAX层的动作由玩家X的对手作出，因此MIN层的节点的minimax值应该为下一层中的最小值。
对于每一个叶结点，其minimax值可根据估值函数得出。对应每一个max节点或min节点，其值可根据上述规则得出。由此，可以得到整个决策树。
作出决策的目的是是的己方N步后的局面最佳，因此，从根结点选择minimax值最大的分支，作为行动策略。
5. 后记 最小化最大算法构造决策树，并自底向上计算每个节点的minimax值，最终从根结点选择minimax值最大的分支，作为行动策略。
当一个零和博弈双方每一步可选动作数量较多时，决策树会变得非常庞大，因此构造决策树，并对其进行遍历，求取每个minimax值将会非常耗时。
在决策树的构建与搜索过程中，存在一些不必要搜索的节点。如果不展开不必要搜索的节点，将会极大的节省搜索时间。
下文将讲解极小化极大算法的优化版本——AlphaBeta剪枝算法。
后文：Alpha-Beta剪枝算法原理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fce7ae05d5869e71c4899e09a357bc2/" rel="bookmark">
			单例模式、工厂模式，观察者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式(Singleton) 限制了类的实例化次数只能一次。从经典意义来将，单例模式，在实例不存在的时候，可以通过一个方法创建一个类来实现创建类的新实例;如果实例已经存在，他会简单返回该对象的引用。单例模式不同于静态类，可以推迟它们的初始化，这通常是因为我们需要一些信 息，而这些信息在初始化的时候可能无法获取到;对于没有擦觉到之前引用的代码，不会提供方便检索的方法
优点:能够单独划分出一个命名空间，避免和别的内部变量发生冲突，所以单例可以分为简单单例和闭包单例。
项目的实际用途:
1.简单单例
//判断实例是否存在，存在则返回，不存在 var testSingle = testSingle || { name: 'jack', age: 15, gender: '1', sayName: function() { console.log(this.name); }, sayAge: function() { console.log(this.age); } } 2.闭包单例
//闭包的作用是保护一些私 有属性，不被外界访问，只有return将属性暴露才能被外界访问到 var testSingle = testSingle || { introduction = (function() { var _name = 'jack' var _age = 1 var _gender var _sayName = function() { console.log(_name); } var _sayAge = function() { console.log(_age); } return { name: _name， age: _age， gender: _gender, sayName: function() { return _sayName(); } sayAge: function() { return _sayAge(); } } } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fce7ae05d5869e71c4899e09a357bc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd809a2dbab779fbc1e8d4827586c91/" rel="bookmark">
			java设计模式之单例设计模式（singleton）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式 什么是设计模式？ 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式。
设计模式免去我们自己再思考和摸索，某种程度上，也可以称为“套路”。
设计模式常见有23种 创建型模式：
工厂方法模式抽象工厂模式单例模式建造者模式原型模式 结构性模式：
适配器模式装饰器模式代理模式外观模式桥接模式组合模式享元模式 行为型模式：
策略模式模板方法模式观察者模式迭代子模式责任链模式命令模式备忘录模式状态模式访问者模式中介者模式解释器模式 这篇文章介绍的是单例设计模式 单例模式介绍 什么是单例模式 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中的，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。
怎么用单例模式 我们首先必须将类的构造器的访问权限设置为private，这样一来我们就无法在外部通过new操作符创建对象了。
将构造器访问权限设置为private，那如何创建对象呢？
答：调用该类的某个静态方法，以返回类内部创建的对象。
注意：由于静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类的对象的变量也必须定义成静态的。
单例模式代码实现有两种方法 饿汉式 步骤：
私有化构造器内部创建类的对象（static的）提供公共方法，返回类的对象 为什么叫饿汉式，随着类的加载直接创建好对象了，就像饥饿的人迫不及待想要吃饭一样。
/** * 单例设计模式：两种实现 * 饿汉式 * 为什么叫饿汉式 随着类的加载直接创建好对象 * @Author imu_zxq * @Date 2021/4/13 16:05 **/ public class SingletonTest1 { public static void main(String[] args) { Bank bank = Bank.getInstance(); } } //饿汉式 实现 class Bank{ //1、私有化类的构造器 private Bank(){ } //2、内部创建类的对象 private static Bank instance = new Bank(); //3、提供公共的方法，返回类的对象 public static Bank getInstance() { return instance; } } 懒汉式 步骤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dd809a2dbab779fbc1e8d4827586c91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c2a22abf5c41dc1dbe0f1ca4d95222/" rel="bookmark">
			查看Pytorch是否使用GPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面的命令可以帮助我们查看Pytorch是否使用GPU：
# 返回当前设备索引 torch.cuda.current_device() # 返回GPU的数量 torch.cuda.device_count() # 返回gpu名字，设备索引默认从0开始 torch.cuda.get_device_name(0) # cuda是否可用 torch.cuda.is_available() 我的结果是：
转载自：https://blog.csdn.net/weixin_43593330/article/details/112132428
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aee998d15f554b706556f022fee662d4/" rel="bookmark">
			手机移动端基础样式base.css样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机移动端基础样式base.css样式 @charset "utf-8"; /* 禁用iPhone中Safari的字号自动调整 */ html { -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; /* 解决IOS默认滑动很卡的情况 */ -webkit-overflow-scrolling : touch; } /* 禁止缩放表单 */ input[type="submit"], input[type="reset"], input[type="button"], input { resize: none; border: none; } /* 取消链接高亮 */ body, div, ul, li, ol, h1, h2, h3, h4, h5, h6, input, textarea, select, p, dl, dt, dd, a, img, button, form, table, th, tr, td, tbody, article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { -webkit-tap-highlight-color: rgba(0, 0, 0, 0); } /* 设置HTML5元素为块 */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } /* 图片自适应 */ img { width: 100%; height: auto; width: auto\9; /* ie8 */ display: block; -ms-interpolation-mode: bicubic;/*为了照顾ie图片缩放失真*/ } /* 初始化 */ body, div, ul, li, ol, h1, h2, h3, h4, h5, h6, input, textarea, select, p, dl, dt, dd, a, img, button, form, table, th, tr, td, tbody, article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { margin: 0; padding: 0; } body { font: 12px/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aee998d15f554b706556f022fee662d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/623c23937ec37e6614acfe9d0e55d8da/" rel="bookmark">
			使用PyMOL绘制蛋白与配体分子结合模式图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更好的阅读体验：使用PyMOL绘制蛋白与配体分子结合模式图 摘要 本文将带大家使用免费开源的PyMOL软件绘制D715-2441蛋白与与PB2cap配体分子的结合模式图。
我们先来看一张成品图：
研究背景 根据分析结果，我们获得以下相互作用：
1、化合物D715-2441的芳环夹在氨基酸残基H357和F404之间并形成π-π堆积作用，还与F404形成疏水作用；
2、化合物苯环上的羟基与E361的羧基和K376的N+原子形成氢键作用，另一个羟基与F404的O原子形成氢键作用；
3、化合物吡喃酮环酯基与K339的N+原子和H357的咪唑基形成盐桥作用。
操作步骤 PyMOL作图通常是对特定对象进行展示形式、颜色、字体等方面的修饰。PyMOL的精髓在于命令行与鼠标的配合使用，本文高度依赖命令行，请做好心理准备。大多数命令格式较为一致，请注意总结归纳。
PyMOL作图 1 设定工作目录，打开文件 打开PyMOL软件，导入刚才下载的复合物PDB文件（rli-D715-2441-1.pdb）。 注意：有两种方法导入文件，一种是鼠标点击菜单栏File -&gt; Open…，另一种是通过命令行。在这里，我们采用命令来操作，因为这样可以同时把工作目录设置好，方便后续保存文件。 假设我们的工作目录为D:\demo。注意：路径中不要有中文和空格，这是导致很多计算类软件（尤其是免费软件）出现问题的原因。
在PyMOL上界面或下界面的命令输入框输入以下命令（PyMOL&gt;表示这是PyMOL的命令），每行输入完毕后按【Enter】键：
2 设置操作对象
结合模式图通常涉及到受体（蛋白）与配体（小分子化合物）两部分（有的还可能涉及水分子、金属离子、辅酶；等等），需为之分别设置对象，以便后续操作。设置配体对象：按照下图顺序，将配体设置为lig对象。 3 设置关键残基对象
关键残基包括：A链的K339、H357、E361、K376和F404。由于该蛋白只有一条链，在使用命令选择残基时，可以不用指定链名。按照下图顺序，将关键残基设置为res对象。
4 显示所需，隐藏多余
在PyMOL中输入以下命令：
然后，进行鼠标操作：
5 绘制相互作用力
前面说过，命令行和鼠标的配合是很重要的。这里再简单讲讲鼠标的几个操作用法：
A） 拖动鼠标左键：按住右键，任意方向拖动鼠标，使视图转动；
B） 上下拖动鼠标右键：按住右键，上下拖动鼠标，使视图缩放；
C） 拖动鼠标中间滚轮：按住滚轮，任意方向拖动鼠标，使视图移动；
D）滚动鼠标中间滚轮：拉进或拉远镜头，使近处原子逐渐显示或隐藏。
我们参照平台给出的结合模式图（本文第二张图），通过下面的键鼠操作来绘制相互作用力。
· 绘制π-π堆积与盐桥作用
首先，确保鼠标模式（Mouse Mode）为Viewing状态，选择（Selecting）模式为Atoms状态（位置在PyMOL右下方）。然后，按照下面步骤操作：然后，点击PyMOL菜单栏的Wizard -&gt; Measurement，然后根据示意图点击刚才创建的小球，两两一组，便画出虚线（相应地，生成对象measure01~05）。
· 绘制其他作用力
采用相同的办法，把氢键和疏水作用也画出来。由于这些作用力的两端刚好落在原子上，因此，不用绘制小球。
6 最后加工
为方便调整，也为图片规格符合要求（通常，出版社要求全版图片宽度≤2000像素，半版图片宽度≤1000像素，分辨率≥300 dpi），我们将PyMOL界面放大或靠边最大化，并将上半部分的对话框往上拉到最小，让视图最大。然后放大、摆动视图至合适的角度，使尽可能清晰地看到各关键细节。
基本的创建工作已经完成，接下来进行细致的修饰。
我们还可按下图步骤微调cartoon样式：
还可移动label的位置（设置Mouse Mode为Editing模式后，按住Ctrl键，用鼠标左键或右键拖动label；必要时，可先将cartoo隐藏起来，等调整好label后，再显示出来），让视图更清晰。经过上述一系列操作，得到下图：
7 生成图片
上面的图已经可以发表文章了，但为了更好看，还需要进行一步：光线追踪（Ray tracing）。
继续使用命令：
至此，我们拿到3张图片：focus.png、label.png和overview.png。 说明 本文由 生化环材摘编自 高质量PyMOL作图教程，遵循 CC 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/623c23937ec37e6614acfe9d0e55d8da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00ac5f592d2e92a90545c1abf5fbcbb/" rel="bookmark">
			计算机网络笔记总结：Part2 物理层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章参考于B站：王道考研——计算机网络
相关文章：计算机网络笔记总结：Part1 概述
学习建议：
对于准备找实习且还没学过计网的小伙伴，可以跟着王道考研的教程过一遍知识点，然后刷面试题(在面试时候常考的只是计网的某些部分内容，考研可能侧重点更多些理论知识)！考研题和面试题可能侧重点不太一样，根据自己的选择情况刷题！ 1. 基本概念 物理层的概念：物理层解决如何在在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。
物理层的任务及其作用：确定与传输媒体接口有关的一些特性，即定义标准。
物理层的特性：
一、机械特性：
定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。 二、电气特性：
规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。 举例：某网络在物理层规定，信号的电平用 +10V~+15V(电压范围) 表示二进制0，用 -10V~-15V 表示二进制1，电线长度限于15m(距离限制) 以内； 三、功能特性：
指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。 四、规程特性：
(又称过程特性)定义各条物理线路的工作规程和时序关系。 2. 数据通信基本知识 2.1 一个数据通信流程的例子 2.2 相关术语 通信的目的是为了传送消息！
数据：传送信息的实体，通常是有意义的符号序列。信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式。 数字信号：代表消息的参数取值是离散的。模拟信号：代表消息的参数取值是连续的。 信源：产生和发送数据的源头。信宿：接收数据的终点。信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。 信道： 传输信号：模拟信道(传送模拟信号)，数字信道(传送数字信号)传输介质：无线信道，有线信道 2.3 三种通讯方式 从通信双发信息的交互方式看，可以有三种基本方式：
一、单工信道：
只能由一个方向的通信而没有反向的交互，仅需要一条信道。举例：A 和 B 两个人，只能A 攻击 B ，B不能攻击A！ 二、半双工信道：
通信双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道。举例：A 和 B 两个人，A和B都可以互相攻击，但是当A攻击B的时候，B不能攻击A，当A攻击结束后，B才能攻击！ 三、全双工通信：
通信双方可以同时发送和接收信息，需要两条信道。举例：A 和 B 两个人可以相互同时攻击对方！ 名称英文定义需要信道条数1.单工通信Simplex只能一个发一个收一条2.半双工通信half-duplex都可以发或者收，但是同一时间只能进行一个发送和接收两条3.全双工通信duplex都可以同时收发数据两条 2.4 两种数据传输方式 传输方式特点串行传输速度慢，省钱，适合远距离并行传输速度快，耗钱，适合近距离 2.5 码元（Symbol） 码元的定义：码元是指用一个固定时长的信号波形（数字脉冲），代表离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号成为k 进制码元。当有码元的离散状态有M个时，此时码元位M进制码元；
1个码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元状态，一种代表0状态，另一种代表1状态。
个人理解：码元就是在网线上传输的一个个信号段。码元的不同进制就是用来表示不同的数值的；
2.6 波特（Baud） 波特（Baud）：用来指一秒可以传输多少个码元！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00ac5f592d2e92a90545c1abf5fbcbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd71e847e29e43ad23cf64732b826fc/" rel="bookmark">
			leetcode算法题：两数相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2. 两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例 1：
输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2：
输入：l1 = [0], l2 = [0] 输出：[0] 示例 3：
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 实现
/**https://leetcode-cn.com/problems/add-two-numbers/ * * @Author anyao * @DateTime 2021-04-17 * @param {[array]} l1 [数组1] * @param {[array]} l2 [数组2] * @return {[array]} [结果数组] */ const getArr = (l1, l2) =&gt; { let xL = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd71e847e29e43ad23cf64732b826fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/637b3dd317cff5eef57b901c13c629b4/" rel="bookmark">
			Spark任务的core，executor，memory资源配置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark任务的core，executor，memory资源配置方法
1、背景 执行Spark任务，资源分配是很重要的一方面。如果配置不准确，Spark任务将耗费整个集群的机缘导致其他应用程序得不到资源。
怎么去配置Spark任务的executors，cores，memory，有如下几个因素需要考虑：
数据量任务完成时间点静态或者动态的资源分配上下游应用 2、Spark应用当中术语的基本定义： Partitions : 分区是大型分布式数据集的一小部分。 Spark使用分区来管理数据，这些分区有助于并行化数据处理，并且使executor之间的数据交换最小化Task：任务是一个工作单元，可以在分布式数据集的分区上运行，并在单个Excutor上执行。并行执行的单位是任务级别。单个Stage中的Tasks可以并行执行Executor：在一个worker节点上为应用程序创建的JVM，Executor将巡行task的数据保存在内存或者磁盘中。每个应用都有自己的一些executors，单个节点可以运行多个Executor，并且一个应用可以跨多节点。Executor始终伴随Spark应用执行过程，并且以多线程方式运行任务。spark应用的executor个数可以通过SparkConf或者命令行 –num-executor进行配置Cores：CPU最基本的计算单元，一个CPU可以有一个或者多个core执行task任务，更多的core带来更高的计算效率，Spark中，cores决定了一个executor中并行task的个数Cluster Manager：cluster manager负责从集群中请求资源 3、cluster模式执行的Spark任务包含了如下步骤： driver端，SparkContext连接cluster manager（Standalone/Mesos/Yarn）Cluster Manager在其他应用之间定位资源，只要executor执行并且能够相互通信，可以使用任何Cluster ManagerSpark获取集群中节点的Executor，每个应用都能够有自己的executor处理进程发送应用程序代码到executor中SparkContext将Tasks发送到executors 以上步骤可以清晰看到executors个数和内存设置在spark中的重要作用。
4、spark任务的最佳方式 以下将尝试理解优化spark任务的最佳方式：
静态分配：配置值从spark-submit中体现动态分配：从数据量和计算需求上衡量资源需求，并在使用后释放掉，这样可以让其他应用重复利用资源 4.1、静态分配 以下按不同例子讨论验证不同参数和配置组合
例子1
硬件资源： 6 节点，每个节点16 cores, 64 GB 内存
每个节点在计算资源时候，给操作系统和Hadoop的进程预留1core，1GB，所以每个节点剩下15个core和63GB
内存。
core的个数，决定一个executor能够并发任务的个数。所以通常认为，一个executor越多的并发任务能够得到更好的性能，但有研究显示一个应用并发任务超过5，导致更差的性能。所以core的个数暂设置为5个。
5个core是表明executor并发任务的能力，并不是说一个系统有多少个core，即使我们一个CPU有32个core，也设置5个core不变。
executor个数，接下来，一个executor分配 5 core,一个node有15 core，从而我们计算一个node上会有3 executor（15 / 5），然后通过每个node的executor个数得到整个任务可以分配的executors个数。
我们有6个节点，每个节点3个executor，6 × 3 = 18个executors，额外预留1个executor给AM，最终要配置17个executors。
最后spark-submit启动脚本中配置 –num-executors = 17
memory，配置每个executor的内存，一个node，3 executor， 63G内存可用，所以每个executor可配置内存为63 / 3 = 21G
从Spark的内存模型角度，Executor占用的内存分为两部分：ExecutorMemory和MemoryOverhead，预留出MemoryOverhead的内存量之后，才是ExecutorMemory的内存。
MemoryOverhead的计算公式： max(384M, 0.07 × spark.executor.memory)
因此 MemoryOverhead值为0.07 × 21G = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/637b3dd317cff5eef57b901c13c629b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcdd6028c2584e49a700aadb7085d861/" rel="bookmark">
			树结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ⭐️树的定义
树是n（n&gt;=0）个有限数据元素的集合
⭐️树的特点
（1）树的根结点没有前驱结点，除根结点之外的所有结点有且只有一个前驱结点。
（2）树中所有结点可以有0个或多个后继结点
⭐️树的相关术语
（1）结点的度：结点所拥有的子树的个数
（2）叶结点：度为0的结点称为叶结点，或者称为终端结点
（3）分支结点：度不为0的结点称为分支结点，或者称为非终端结点。一棵树的结点除叶结点外，其余的都是分支结点。
（4）左孩子、右孩子、双亲、兄弟：树中一个结点的子树的根结点称为这个结点的孩子 在二叉树中，左子树的根结点称为左孩子，右子树的根结点称为右孩子。反过来这个结点称为它孩子结点的双亲。具有同一个双亲的孩子结点互称为兄弟。
（5）路径、路径长度：如果一棵树中的一串结点n1,n2,n3•••nk，有如下关系：结点ni是ni+1的父结点（1&lt;=i&lt;k）就把n1，n2，•••，nk称为一条由n1至nk的路径，这条路径的长度是k-1【树的路径长度指根结点到各结点的路径长度之和】
例：
总路径长度：AB+AB+BD+AC+AC+CF+AC+CE
（6）祖先，子孙：在树中，如果有一条路径从结点M到结点N，那么M就称为结点N的祖先，N称为结点M的子孙
（7）结点的层数：规定树的根结点层数为1，其余结点的层数等于他的双亲的层数加1
（8）树的深度：树中的结点的最大层数称为树的深度
（9）树的度：树中各结点度的最大值称为该树的度
（10）有序树和无序树：如果一棵树中的结点的各子树从左到右是有次序的，即若交换了某结点各子树的相对位置，则构成不同的树，称这颗树为有序树；反之，则称为无序树
（11）森林：0颗或者有限颗不相交的树的集合
🌟🌟二叉树
❄️二叉树的任何一个结点最多只能拥有2个子树（左子树和右子树）
❄️相关术语
（1）满二叉树
如果一颗二叉树每一层的结点个数都达到了最大，这棵二叉树称作满二叉树。所有的分支结点都存在左子树和右子树，所有的叶子都在最下层这一层。
（2）完全二叉树
一棵深度为k的有n个结点的二叉树，对其结点按从上至下，从左至右的顺序进行编号，如果编号为i(1&lt;=i&lt;=n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则称这棵二叉树为完全二叉树。
【特点：叶子结点只能出现在最下层和次最下层，且最下层的叶子结点集中在树的左部】
❄️满二叉树必定是完全二叉树，而完全二叉树未必是满二叉树
❄️二叉树的主要性质
（1）一棵非空二叉树的第i层上最多有2^（i-1）个结点（i&gt;=1）
(2)一棵深度为k的二叉树中，最多具有2^k-1个结点
（3）对于一棵非空的二叉树，若叶子结点数为n0，度数为2的结点数为n2，则有n0=n2+1
（4）具有n个结点的完全二叉树的深度k为[log2(n)]+1
(5)对于具有n个结点的完全二叉树，如果按照从上之下和从左至右的顺序对二叉树中的所有结点从1开始顺序编号，则对于任意的编号为i的结点有如下性质：
1）如果i&gt;1,则编号为i的结点的双亲结点的编号为[i/2]；如果i=1，则序号为i的结点为根结点，无双亲结点
2）如果2i&lt;=n，则编号为i的结点的左孩子结点的编号为2i；如果2i&gt;n，则序号为i的结点无左孩子。
3）如果2i+1&lt;=n，则编号为i的结点的右孩子结点的编号为2i+1；如果2i+1&gt;n，则序号为i的结点无右孩子
【二叉树的根结点的编号从1开始】
❄️二叉树的存储
（1）顺序存储结构
一般是按从上至下，从左到右的顺序存储的
满二叉树和完全二叉树采用顺序存储比较合适
（2）链式存储结构
1）二叉链表存储
链表中每个结点由3个域组成，1个数据域和2个指针域，分别用来给出该结点的左孩子和右孩子所在的链结点的存储地址
2）三叉链表存储
在二茬链表存储的基础上增加一个parent域，只想该结点的双亲结点的指针
❄️二叉树的二叉链表存储结构
typedef struct bitnode {datatype data; struct bitnode *Ichild;*rchild; }BiTNode,*BiTree; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f3160b8c7c4ac2f2bf626c0287aac4/" rel="bookmark">
			conda Python 虚拟环境相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、易混名词 Conda:一个通用包管理器（在系统上提前编译和配置好的软件包集合， 装好了后就可以直接用）。等价于pip（仅适用Python），但是conda不限于Python语言，都可以实现包的安装和环境隔离。 Anaconda:一个python发行版（在系统上提前编译和配置好的软件包集合， 装好了后就可以直接用）。会预装很多pydata生态圈里的软件（conda、某个版本的python、众多packages、科学计算工具等）。 Miniconda：等价于于Anaconda，一个python发行版，只包含最基本的内容——python与conda，以及相关的必须依赖项。 pip:一个针对python的包管理器。pip可以允许你在任何环境中安装python包，而conda允许你在conda环境中安装任何语言包（包括c语言或者python）。 二、conda使用 1、conda安装 1）下载conda最小依赖 wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh 2）安装 bash Miniconda3-latest-Linux-x86_64.sh 3）检查 conda —version 4）更换仓库源 # 添加Anaconda的TUNA镜像 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ # 设置搜索时显示通道地址 conda config --set show_channel_urls yes 5）升级conda conda update conda 6）删除conda rm -rf path_install # 或者卸载anaconda 2、conda管理环境 conda可以实现环境隔离，理解为不同项目需要不同的Python版本，不同的包版本。 一旦激活某个环境，那么操作均是仅针对该环境的操作，在环境外部操作，需要区分针对所有环境还是某个环境，需要使用--name参数指定。 1）创建并激活一个环境 conda create --name yolov5 位置在Anaconda安装文件的/envs/yolov5 还可以指定Python版本： conda create --name yolov5 python=3.8 2)激活这个新环境 conda activate yolov5 # linux下 新的开发环境会被默认安装在你conda目录下的envs文件目录下。你可以指定一个其他的路径；通过conda create -h查看参数使用 3）列出所有环境 conda env list 4)切换到另一个环境(activate/deactivate)：即从一个项目环境切换到另外一个项目环境 conda activate yolov5 # linux下 # 如果要从你当前工作环境的路径切换到系统根目录时，键入： conda deactivate # linux 5）复制一个环境 conda create -n yolov6 --clone yolov5 # 根据yolov5克隆一个yolov6 6）删除一个环境 conda remove -n yolov5 --all 注意：如果移除环境失败，可以尝试下面的方法 conda env remove -n ENV_NAME 三、包管理 1）查看已安装包：激活一个环境后可以通过下面的命令查看已经安装的包 conda list 2）向指定环境中安装包：有三种方式 A-1:使用Conda命令安装包：直接指定-n 指定安装环境的名字 conda install --name yolov5 numpy A-2:使用Conda命令安装包：先激活环境，再使用conda install命令 conda activate yolov5 conda install numpy B:从 Anaconda.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f3160b8c7c4ac2f2bf626c0287aac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48f4d07f00e668554f839651607c69e/" rel="bookmark">
			抽象工厂模式-abstract Factory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言
概念
结构与实现
UML类图
代码如下
优点&amp;缺点
使用场景
引言： 前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。
工厂方法模式太单一了，只能“一对一”
这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。
本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族
概念： 是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。
抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。
结构： 抽象工厂模式的主要角色如下：
抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。
具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。
实现： 现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。
UML类图： 代码如下： （1）DessertFactory
package 抽象工厂; public interface DessertFactory { //生产咖啡 Coffee createCoffee(); //生产甜品 Dessert createDessert(); } （2）AmericanDessertFactory类
package 抽象工厂; //美式工厂 //可以生产美式咖啡 与 抹茶慕斯 public class AmericanDessertFactory implements DessertFactory { public Coffee createCoffee() { return new AmericanCoffee(); } public Dessert createDessert() { return new MatchaMousse(); } } （3）ItalyDessertFactory类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b48f4d07f00e668554f839651607c69e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a562d6ceadb12f94f81457b9e5bb2058/" rel="bookmark">
			微信小程序 通过wx.redirectTo,实现单页面刷新效果 ＆ 下拉刷新页面数据效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微信小程序 通过wx.redirectTo,实现单页面刷新效果 ＆ 下拉刷新页面数据效果 一: 使用 wx.redirectTo(),实现页面刷新数据效果
API说明:
关闭当前页面，跳转到应用内的某个页面。
但是不允许跳转到 tabbar 页面。
在小程序插件中使用时，只能在当前插件的页面中调用
实现效果:
例如,当点击某个按钮,清空了本地数据缓存,而页面显示效果并没有发生变化,
此时可以在按钮执行成功逻辑后,加入以下代码,以实现刷新页面效果.
refreshPage(){ wx.redirectTo({ url: '当前页面名称如:home' }) } 二:通过下拉刷新页面数据效果
①　开启下拉效果,在需要下拉效果的页面,json中加入以下代码
"enablePullDownRefresh":true ②　在需求页面中onPullDownRefresh()方法里面写入以下代码
//刷新页面方法 this.refreshPage() //就是上面第一种方法 //停止下拉 wx.stopPullDownRefresh() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1883551536613fffb39f62caeb82b09e/" rel="bookmark">
			write.csv()函数--R语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数功能：
write.table prints its required argument x (after converting it to a data frame if it is not one nor a matrix) to a file or connection. 将X输出到文件或者链接
函数语法：
write.table(x, file = "", append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA", dec = ".", row.names = TRUE, col.names = TRUE, qmethod = c("escape", "double"), fileEncoding = "") write.csv(...) write.csv2(...) 函数参数
x	the object to be written, preferably a matrix or data frame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1883551536613fffb39f62caeb82b09e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c9a02358bfe1aa2f11614352557953/" rel="bookmark">
			C&#43;&#43;错误提示: 无法将参数 1 从“const char [7]”转换为“char *”  或“const char *”类型的值不能用于初始化“char *”类型的实体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++错误提示: 无法将参数 1 从“const char [7]”转换为“char *” 或“const char *”类型的值不能用于初始化“char *”类型的实体 用VS2017或VS2019写C++代码时，发生以下两个错误之一时，均可按以下两个方法解决：
解决办法一： 将变量char *改为const char * 解决办法二： 按如下操作即可：
项目-&gt;属性-&gt;C/C++-&gt;语言-&gt;符合模式，将符合模式由是改为否
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3478f94a6b2b76aa6cb6e26d45fcdebc/" rel="bookmark">
			Rmarkdown第四弹—— 主题格式更换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rmarkdown的主题格式 Rmarkdowm作为可复用报告的优秀工具，除了提供文档编辑、图表输出外，还有许多主题格式供使用者选择。除了默认的主题外，还可以通过加载rticles、prettydoc、rmdformats、tufte等包获取更多主题格式。下面我们看看几类扩展包里的主题样式。
注： 接下来的教程我是已经安装这些包了，没安装的记得提前安装好！不然运行会出错。
1 rticles包 官网：https://github.com/rstudio/rticles；
具体教程：https://bookdown.org/yihui/rmarkdown/rticles-templates.html
rticles软件包提供了各种期刊和出版商的模板：
JSS articles (Journal of Statistical Software)R Journal articlesCTeX documents(中文pdf，强烈推荐！)ACM articles (Association of Computing Machinery)ACS articles (American Chemical Society)AMS articles (American Meteorological Society)PeerJ articlesElsevier journal submissionsAEA journal submissions (American Meteorological Society)IEEE Transaction journal submissionsStatistics in Medicine journal submissionsRoyal Society Open Science journal submissionsBulletin de l’AMQ journal submissionsMDPI journal submissionsSpringer journal submissions 在此只对下面一个模板进行演示，其他模板操作类似，但是一般模板是不能包含中文字体的哦！
CTeX Documents（中文版本） 下载完对应的包之后，找到对应模板打开即可。输出pdf是需要配置tex环境的哦！建议安装Tinytex，具体安装教程见前面。
编译后得到的结果，这是他模板原始的样子，如果想调整页面行间距，字体颜色等，请见下次推文（公众号：庄闪闪的R语言手册），我将会把这些小细节进行汇总。
2 rmdformats包 之后的这几个包，内部都包含了挺多模板的，下面yaml文件只是其中一个，如果想尝试该包内部其他模板，请根据上述操作进行，选择好模板，编译之后看看是不是你想要的模板。
接下来我对部分相对不错的模板进行展示，你可以直接复制我的头部文件到.rmd格式中，或者打开模板窗口进行选择（操作在下面）。
方法一 --- title: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3478f94a6b2b76aa6cb6e26d45fcdebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc94d49b343fcd6d2e2af4ba5432e4b/" rel="bookmark">
			缺货？用BLE芯片替代M0就行了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近芯片市场严重缺货，有些主流物料交期已回复到10个月以上，前几天还有客户开玩笑说马上只能放假回家了，说许多厂家即将无米下锅也不为过。
虽然通用型单片机缺货严重，但似乎蓝牙芯片暂时还未受波及。
CH573是一颗集成BLE、USB、4串口、12PWM、SPI等接口的32位RISC-V内核单片机。
**CH573是一颗蓝牙芯片，但其资源相比通用型M0单片机更有优势，一般M0单片机8K RAM，64K FLASH，而CH573是18K RAM， 512K FLASH，32K EEPROM，各种外设接口，其性能完全胜任普通M0的方案设计。**CH573F不使用蓝牙功能就是一颗通用型单片机，而且性价比高，外围接口丰富。
CH573F的开发流程也很通用，开发环境使用的Mounriver界面友好易懂，并提供了丰富的开发实例以共参考，可以通过沁恒WCH-LINK仿真调试，也可以通过芯片自带的USB口或者串口下载代码。
CH573F的上手步骤可以参考下这篇文章：https://blog.csdn.net/m0_46513394/article/details/115721244?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8db532ad98ca4f19cc895ec6a57d72de/" rel="bookmark">
			沁恒微USB蓝牙单片机CH573F初步熟悉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开发板简介 图上面是沁恒CH573F的官方最小系统板，直接找沁恒申请CH573F/CH571F样品大概率会拿到这块板子，板子上有USB-C口、电源开关、两个按键和所有IO口引出插针。
1、USB-C口：可用于下载程序和验证CH573F的USB通信功能
2、按键：下载按键、复位按键
3、LED0、LED1：独立的LED灯，可用杜邦线连接到任意IO口
板子下面是沁恒提供的仿真器WCH-LINK，可用于沁恒RISC-V内核和任意品牌ARM-M内核MCU的仿真调试。
WCH-LINK具体资料请看：https://download.csdn.net/download/m0_46513394/16679823
沁恒的MCU既可以通过芯片的USB口或者串口配合沁恒提供的上位机ISP软件直接下载程序，也可以通过仿真器下载程序。
二、开发环境：MounRiver Studio MounRiver Studio是一款面向RISC-V内核单片机的集成开发环境。为用户提供专业嵌入式项目所需的开发、调试环境，烧录工具及完善的项目管理功能。代码编辑，工程模板导入、导出，单步调试，代码烧录，IDE在线、离线升级…MounRiver Studio为单片机开发提供了完整的解决方案。 MounRiver Studio的详细介绍可以看：https://blog.csdn.net/qq_36353650/article/details/108321298
MounRiver下载地址：
三、跑定时器点灯例程 例程代码官网可下载，见：CH573EVT\EVT\EXAM\TMR，演示包含PB15闪灯，精简一下如下： //CH573演示PB15闪灯程序 #include "CH57x_common.h" int main() { SetSysClock( CLK_SOURCE_PLL_60MHz ); GPIOB_ModeCfg( GPIO_Pin_15, GPIO_ModeOut_PP_5mA ); while( 1 ) { GPIOB_ResetBits( GPIO_Pin_15 ); DelayMs(200); GPIOB_SetBits( GPIO_Pin_15 ); DelayMs(200); } } 三、将程序下载到CH573F 1、使用CH573F的USB口或串口配合官网提供的ISP软件下载，具体操作可见开发包中的：CH573EVT使用说明.PDF 编译生成HEX后用以下软件下载： 注意步骤：连接板子USB到电脑，按住板子下载按键，打开开关，ISP软件会识别到USB设备，用户程序文件选择对应HEX，点下载，软件会提示下载成功。 2、也可以通过WCH-LINK连接芯片SWD调试脚下载，和ARM-M方式一样。
下载成功后将PB15连接到LED，效果如下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d91796b9b58e936108e6536e9b0ef1/" rel="bookmark">
			php 动态链接库加载,手动加载动态链接库 - pirtt的个人空间 - OSCHINA - 中文开源技术交流社区...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#ifndef __PLUGIN__DYNAMICMGR_H_
#define __PLUGIN__DYNAMICMGR_H_
class DynamicMgr
{
public:
~DynamicMgr(){free_lib();}
/** */
const char* get_name()const;
/** */
bool load_lib(const char* libName);
/** */
void* get_address(const char* symbolMane)const;
private:
void free_lib();
std::string __m_libName;
#if defined(__unix__) || defined(unix) || defined(linux)
void*__m_lib;
#else
HMODULE __m_lib;
#endif
};
#endif
const char* DynamicMgr::get_name()const
{
return __m_libName.c_str();
}
/*************************************************************
* Unix System
**************************************************************/
#if defined(__unix__) || defined(unix) || defined(linux)
#include bool DynamicMgr::load_lib(const char* libName)
{
std::string strName = libName;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d91796b9b58e936108e6536e9b0ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a9a19c93058bdf24ca9ec33750875a/" rel="bookmark">
			C&#43;&#43;打家劫舍问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结成一句话就是：走到一间屋要考虑偷还是不偷？
首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。
如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k~(k&gt;2) 间房屋，有两个选项：
1.偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k-2 间房屋的最高总金额与第 k 间房屋的金额之和。
2. 不偷窃第 k间房屋，偷窃总金额为前 k-1间房屋的最高总金额。
在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。
用 dp[i] 表示前 i间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：
dp[i]=max(dp[i−2]+nums[i],dp[i−1])
class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { if(!nums.size())return 0; if(nums.size()==1)return nums[0]; vector&lt;int&gt; dp(nums.size()); dp[0]=nums[0]; dp[1]=max(nums[1],nums[0]); for(int i=2;i&lt;nums.size();i++){ dp[i]=max(dp[i-2]+nums[i],dp[i-1]); } return dp[nums.size()-1]; } }; 如果此题增加难度：
这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。
此时就要考虑第一间屋打不打劫的问题：
class Solution { private: vector&lt;int&gt; dp; public: int rob(vector&lt;int&gt;&amp; nums) { if(!nums.size())return 0; if(nums.size()==1)return nums[0]; if(nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09a9a19c93058bdf24ca9ec33750875a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/375e9547a01a59b32e11085296ee6408/" rel="bookmark">
			matlab捕获奇异值警告(函数lastwarn, warning)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际问题： 警告：矩阵接近奇异值，或者缩放错误。结果可能不正确。
实验中遇到奇异值警告时，想要捕获该警告，跳出该层循环不再执行后续程序，并且在结果中记录警告
解决方法： matlab官方文档其实给出了一些关于错误的处理方式
但是由于我这里想要捕获的警告不是自己定义的，而是在计算过程中系统自己发出来的，所以我采取了比较综合的方式：
选取函数lastwarn（官方文档）捕获最后一条警告信息（注意：这里说的最后一条警告信息是全局的，假设代码中设置每一次循环都用lastwarn去捕获警告信息，若某一个参数设置下出现了警告A，使用lastwarn捕获A，但是在下一个参数设置中即便程序本身没有错误，但是lastwarn仍然会捕获到A；亦或是程序本身就不会出现警告，但是lastwarn还可以捕获在程序运行之前出现的警告信息）利用函数warning（官方文档）在循环前面输出一个事先定义的不相关的警告将lastwarn捕获到的信息与事先定义的信息进行比较（也可以通过其他方式进行比较），如果长度不一致则跳出循环（根据实际需要决定需要跳出几层循环），反之代表没有警告出现，继续进行实验 示意代码：
for i=1:10 for j=1:10 warning('off');%不在命令行显示警告信息 msg=char('Message 1.');%自定义警告信息 warning('Message 1.');%输出自定义警告信息 error=0;%每次确定参数后，error归0 *** （主要代码） *** [msg1, warnID]=lastwarn;%捕获最新一条警告信息 if length(msg1)~=length(msg) %判断最新一条警告信息是否和自定义的警告信息一致 error=1; %如果两条警告信息不一致，说明出现了新的警告，error置1并跳出循环 break else end end %将结果记录在txt中 if error==1 fp=fopen('results.txt','a+'); fprintf(fp,'i:%d, j:%d, warnID:%s, msg1:%s\n', i, j, warnID, msg1); fclose(fp); else fp=fopen('results.txt','a+'); fprintf(fp,'i:%d, j:%d, results:%f\n', results); fclose(fp); end 为了方便处理结果（避免电脑自动更新或停电带来的沉痛教训），我选择将结果直接保存至txt文件中，如果有更好的方法欢迎大家指点~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78ff9fbbb7d6703292995f70207e844/" rel="bookmark">
			vs2015（VS2017等）配置属性里面没有c/c&#43;&#43;   bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事发过程与问题：
使用VS建过C#的工程，再打开C++工程，新建一个项目，空工程，找不到配置属性页（可能也经历过一些自动关键和断电之类的异常情形，但不确定是导致bug的原因）。
使用包括win32控制台程序等多种方式，都不存在C/C++页，而同解决方案的其他旧工程正常。
解决方式：随便编译一次新加工程，页签恢复
对此只能解释为bug
后续：在此之后，重启VS，新建项目，现象没缓解，暂时需要编译每个新加的工程才可见C/C++页签
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca98ea373ef8c86e2bf3620a665e5b1/" rel="bookmark">
			能拿蚂蚁offer，全靠阿里P8大牛总结的Java架构开发手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		金三能拿到蚂蚁金服的offer，这全靠一份阿里P8大牛总结的Java架构开发手册，内容非常全面 包括从基础到架构进阶。
Java架构开发手册内容目录展示： 因为手册内容太多，在此就只截取部分内容展示了。有想获取完整版JJava架构开发手册的朋友：
细节内容展示 JAVA基础部分
JAVA集合部分
多线程与高并发部分
数据结构部分
JVM部分
Spring部分
Netty与RPC部分
网络部分
zookeeper部分
Kafka部分
RabbitMQ部分
负载均衡部分
数据库部分
分布式部分
Hadoop部分
因为手册内容太多，在此就只截取部分内容展示了。有想获取完整版JJava架构开发手册的朋友
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/317/">«</a>
	<span class="pagination__item pagination__item--current">318/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/319/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>