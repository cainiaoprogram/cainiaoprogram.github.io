<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/326ce2be0962701805e67424e39e61ef/" rel="bookmark">
			腾讯云服务器搭建网站详细教程_2023更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用腾讯云服务器搭建网站全流程，包括轻量应用服务器和云服务器CVM建站教程，轻量可以使用应用镜像一键建站，云服务器CVM可以通过安装宝塔面板的方式来搭建网站，腾讯云服务器网分享使用腾讯云服务器建站教程，新手站长搭建网站全流程：
已经有了腾讯云服务器如何搭建网站？腾讯云服务器网以腾讯云服务器，借助宝塔面板搭建Web环境，然后使用WordPress博客程序搭建网站，大致分为三步，首先购买腾讯云服务器，然后在腾讯云服务器上部署宝塔面板，最后在宝塔面板上安装WordPress程序。
腾讯云服务器搭建网站教程 腾讯云服务器可选云服务器或轻量应用服务器，云服务器购买后可以自行搭建Web网站所需的环境，也可以使用腾讯云官方提供的镜像，最后我们在搭建好环境的云服务器上安装WordPress程序，将域名解析到云服务器公网IP地址上，网站就可以上线了。
目录
腾讯云服务器搭建网站教程
一：购买腾讯云服务器
二：腾讯云服务器安装Web网站环境
1、SSH登录到腾讯云服务器
2、执行宝塔安装命令
3、开启宝塔面板所需端口号
4、登录宝塔面板后台
5、宝塔面板安装LNMP套件
6、添加站点
7、下载WordPress安装包程序
8、上传网站程序到根目录
9、域名解析到云服务器公网IP地址上
10、访问网站域名，开始安装WordPress
一：购买腾讯云服务器 使用腾讯云服务器搭建网站，腾讯云服务器分为CVM云服务器或轻量应用服务器，详细购买流程如下：
购买流程：https://www.txyfwq.com/goumai
如果是轻量应用服务器，直接提供WordPress镜像，如下图：
轻量服务器应用镜像
如上图，如果是轻量应用服务器可以直接选择所需要的应用镜像，如宝塔镜像、WordPress、Discuz及LAMP等，一劳永逸。
更多轻量应用服务器建站参考：
腾讯云轻量应用服务器怎么搭建网站？全流程超详细腾讯云轻量应用服务器宝塔面板安装和使用说明使用腾讯云轻量应用服务器搭建Typecho博客网站全流程 本文是以腾讯云CVM云服务器安装Linux纯净版操作系统为例，手动安装宝塔面板，然后在宝塔上安装WordPress程序。
二：腾讯云服务器安装Web网站环境 安装Web环境要根据网站程序而定，本文最终要搭建的WordPress网站程序，为WordPress安装LNMP环境Linux+Nginx+MySQL和PHP，腾讯云服务器网小编直接为云服务器安装宝塔Linux面板，宝塔面板集成了LNMP环境，然后在宝塔上新建站点安装WordPress程序。
腾讯云服务器网使用的云服务器系统为TencentOS Server 3.1 (TK4)镜像，TencentOS Server是腾讯云推出的Linux操作系统，兼容CentOS生态及操作方式，所以在该台云服务器上执行宝塔面板CentOS安装命令即可。
1、SSH登录到腾讯云服务器 在腾讯云服务器控制台，找到目标云服务器，点击右侧“登录”，如下图：
腾讯云服务器登录
腾讯云服务器网使用腾讯云Web网页自带的远程登录方式，输入云服务器root登录密码，登录。如果是SSH密匙登录，就选择密匙。
2、执行宝塔安装命令 宝塔安装命令如果是TencentOS系统使用CentOS命令即可：
yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh
其他云服务器系统安装宝塔命令参考：腾讯云服务器安装宝塔Linux面板命令脚本一键执行
期间会提示如下：
Do you want to install Bt-Panel to the /www directory now?(y/n): y
回复一个字母“y”回车，腾讯云服务器即可自动安装宝塔Linux面板。
宝塔面板安装成功后，显示如下：
success
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/326ce2be0962701805e67424e39e61ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c26f3f004ff0abb330b5d351cfd26a4e/" rel="bookmark">
			Django23——练习1（后台传数据页面显示数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 任务：下载素材，如下图所示。 将页面放成Django项目运行，并将图片红框中的文字和图片传递到页面进行显示。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89582ca41ad0ee632ada334936093324/" rel="bookmark">
			nginx-获取客户端IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上有服务器与客户端中间是有nginx代理服务器的，上游服务器如何获取客户端真实ip地址？
nginx代理服务器设置X-Forwarded-For的header参数，代理服务器通过remote_addr获取客户端ip地址，将ip地址写入nginx代理服务器的X-Forwarded-For中， 上游服务端通过在nginx的这个参数拿到客户端IP地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ae939e918dd24afa751a1da907b642/" rel="bookmark">
			升级OpenSSL版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CentOS7升级OpenSSL版本 1、查看linux服务器内核版本
cat /proc/version
2、查看本地OpenSSL版本
openssl version
如果不是最新的openSSL 1.1.1版本，则可以进行升级
下载最新的openssl版本
wget https://www.openssl.org/source/openssl-1.1.1c.tar.gz
或者
外网下载openssl-1.1.1c.tar.gz安装包，然后拷贝到服务器上
3、解压并编译安装
tar -zxvf openssl-1.1.1c.tar.gz
cd openssl-1.1.1c
./config --prefix=/usr/local/openssl #如果此步骤报错,需要安装perl以及gcc包
make &amp;&amp; make install
mv /usr/bin/openssl /usr/bin/openssl.bak
ln -sf /usr/local/openssl/bin/openssl /usr/bin/openssl
echo "/usr/local/openssl/lib" &gt;&gt; /etc/ld.so.conf
ldconfig -v # 设置生效
4、查看本地OpenSSL版本
openssl version
如果是最新的openSSL 1.1.1版本,则说明升级成功
二、Redhat升级OpenSSL版本 1、查看linux服务器内核版本
cat /proc/version
2、查看本地OpenSSL版本
openssl version
如果不是最新的openSSL 1.1.1版本，则可以进行升级
下载最新的openssl版本
wget https://www.openssl.org/source/openssl-1.1.1c.tar.gz
或者
外网下载openssl-1.1.1c.tar.gz安装包，然后拷贝到服务器上
3、解压并编译安装
tar -zxvf openssl-1.1.1c.tar.gz
cd openssl-1.1.1c
./config no-shared --libdir=lib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ae939e918dd24afa751a1da907b642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f5929c49e330858a272a9bf7ffbed9c/" rel="bookmark">
			Linux防火墙操作命令，开放或关闭端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在外部访问CentOS中部署应用时，需要通过防火墙管理软件,开端口,或者直接关闭防火墙进行解决(不建议)
常用命令：
systemctl start firewalld #启动
systemctl stop firewalld #停止
systemctl status firewalld #查看状态
systemctl disable firewalld #开机禁用
systemctl enable firewalld #开机启动
开放或关闭端口：
firewall-cmd --zone=public --add-port=80/tcp --permanent #开放80/tcp端口 （--permanent永久生效，没有此参数重启后失效）
firewall-cmd --zone=public --query-port=80/tcp #查看80/tcp端口
firewall-cmd --zone=public --remove-port=80/tcp --permanent #关闭80/tcp端口
批量开放或关闭端口：
firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent #批量开放端口，打开从40000到45000之间的所有端口
firewall-cmd --zone=public --list-ports #查看系统所有开放的端口
firewall-cmd --zone=public --remove-port=40000-45000/tcp --permanent #批量关闭端口，关闭从40000到45000之间的所有端口
更新防火墙的设置：
firewall-cmd --reload #更新防火墙的设置，使上面的修改生效
CentOS7 防火墙（firewall）的操作命令
安装：yum install firewalld 1、firewalld的基本使用 启动： systemctl start firewalld
查看状态： systemctl status firewalld
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f5929c49e330858a272a9bf7ffbed9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca7a51c29432a0565dd14320d60e7ccf/" rel="bookmark">
			SpringBoot&#43;quartz实现定时任务的创建、删除、查询操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在pom.xml文件中导入quartz的依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; 2、配置quartz的数据源等操作 package com.train.batch.config; import jakarta.annotation.Resource; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.quartz.SchedulerFactoryBean; import javax.sql.DataSource; import java.io.IOException; @Configuration public class SchedulerConfig { @Resource private MyJobFactory myJobFactory; @Bean public SchedulerFactoryBean schedulerFactoryBean(@Qualifier("dataSource") DataSource dataSource) throws IOException { SchedulerFactoryBean factory = new SchedulerFactoryBean(); factory.setDataSource(dataSource); factory.setJobFactory(myJobFactory); // 启动之后2秒后可以执行 factory.setStartupDelay(2); return factory; } } 需要对父类的方法进行重写。 package com.train.batch.config; import jakarta.annotation.Resource; import org.quartz.spi.TriggerFiredBundle; import org.springframework.beans.factory.config.AutowireCapableBeanFactory; import org.springframework.scheduling.quartz.SpringBeanJobFactory; import org.springframework.stereotype.Component; @Component public class MyJobFactory extends SpringBeanJobFactory { @Resource private AutowireCapableBeanFactory beanFactory; /** * 这里覆盖了super的createJobInstance方法，对其创建出来的类再进行autowire。 */ @Override protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception { Object jobInstance = super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca7a51c29432a0565dd14320d60e7ccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c77007bbe248c07a1231e3408e67cb1/" rel="bookmark">
			指针详解（看完直接起飞） 第一部分，分5个部分。（无杂乱图纯享版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.内存和地址
1.1首先关于内存和地址，你可以先构思一个公寓楼，里面有很多房间，如果这个公寓很不友好，没把门牌号整上，这天你要去找你的朋友，这样是不是就很麻烦也没效率。
1.2.怎么理解编址
2.指针变量和地址
2.1取地址操作符（&amp;）
2.2指针变量和解引用操作符（*）
2.2.1 指针变量
2.2.2如何拆解指针类型
2.2.3 解引用操作符（*）
2.3 指针变量大小
3.指针变量类型的意义
3.1指针的解引用
3.2指针+ -整数
4.const修饰指针
4.1const修饰变量
4.2const修饰指针变量
5.指针运算
5.1 指针 +- 整数
5.2 指针 - 指针
5.3 指针的关系运算 6.野指针
6.1野指针的成因
1.指针未初始化。
2.指针越界访问。
3.指针指向的空间已被释放。
6.2如何规避野指针
6.2.1指针的初始化
6.2.2小心指针越界。 6.2.3 指针变量不再使⽤时，及时置NULL，指针使⽤之前检查有效性
6.2.4避免返回局部变量的地址 7.assert断言
assert的好处：
8.指针的使用和传地址调用
8.1传址调用
1.内存和地址 1.1首先关于内存和地址，你可以先构思一个公寓楼，里面有很多房间，如果这个公寓很不友好，没把门牌号整上，这天你要去找你的朋友，这样是不是就很麻烦也没效率。 2.那如果我们把门牌号搞上那是不是就方便多了，很快就能找到你的朋友。相同的计算机中的 内存就是很像这样一个公寓楼，CPU在处理数据时，它要的数据也是从内存中找到的，将数据处理好后，又将数据送回他的地址房间中。
3.其实内存中也是划分好一个个内存单元的，每个内存单元就是1 个 字节（byte）。
4.下表是内存换算单位呢。
1b yte = 8b it 1 KB = 1024b yte 1 MB = 1024 KB 1 GB = 1024 MB 1 TB = 1024 GB 1 PB = 1024 TB 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c77007bbe248c07a1231e3408e67cb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b33b59d5bce528da1a8ee999a6550e2/" rel="bookmark">
			不使用VMTools，宿主机与虚拟机交换文件的方法(接上章)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 VMTool虽然方便，但毕竟是专用于虚拟机的软件，将要封装的系统不安装VMTools，易导致一些琐碎问题。下面我给大家介绍一个最常用的宿主机与虚拟机交换文件的方法，当然，比VMTools繁琐，但绝不影响系统封装。
1、将文件从宿主机导入至虚拟机（虚拟机开机或停机状态均可用） （1）使用UltraISO将要导入的文件做成ISO映像
（2）在 VMware Player 中，按照下图步骤进入虚拟机设置页面 （3）找到光驱，加载刚才生成的ISO映像 （4）虚拟机内系统光驱会出现刚才我们装载的ISO映像 （5）打开虚拟机光盘盘符，把文件复制进虚拟机硬盘即可 2、将文件从虚拟机导出至宿主机（虚拟机必须为停机状态） （1）使用DiskGenius的打开虚拟机磁盘功能
（2）浏览选中虚拟机磁盘文件的主文件（与虚拟机最初命名同名） （3）虚拟机硬盘由DiskGenius打开后，如下图方法可以很便捷的将文件“拿”到宿主机中 3、系统备份 封装的第一步，其实是备份当前安装好的操作系统。避免我们在之后的步骤中出现问题，以至于还要重新安装操作系统，浪费时间精力。系统备份想必大家都会。对于Win7而言，建议使用ImageX备份。推荐使用 U盘装机助理 中的 Easy Image X 执行 ImageX 备份操作， Easy Image X 具有图形化操作、便于设置压缩率等特点。
在 Easy Image X 中设置 ImageX 备份的方法与 Ghost 十分类似。不过提醒大家注意两点：
（1）压缩率无需选太高，这只是便于封装的备份而不是最终备份，压缩率建议选择“快速压缩”，体积略大，但备份和恢复速度都很快；
（2）ImageX是可以做到映像叠加的，即多次备份如果文件相同则只占一个文件的体积（此功能会有后续详解），所以除了设置映像文件保存位置外，还要设置当前这个子映像的名称，如下图中的子映像名称“Win7”。
稍事等待后，系统备份完毕。
一个阶段一个备份，一个备份一个小结，一个小结一个进步，多个进步一个成功
封装前的准备 封装的目的，是为了快速的部署操作系统，减少不必要的重复劳动。所以，我们需要向源系统集成系统补丁、安装常用软件，从而减少每次部署后的重复劳动。
1、安装补丁 Windows 7 的补丁安装，可以选用自带的 Windows Update 或使用第三方补丁包，如 系统补丁安装助理。
如果使用的是 Windows Update，有一个值得一提的技巧，即多个版本先装高版本，再重新扫描补丁列表，可以杜绝反复安装并避免一定的问题。例如IE10，首次扫描时会扫除IE8相关补丁、IE9安装程序和IE10安装程序，如果你的目的就是要装IE10，则没有任何必要再去装IE8的补丁和IE9，直接如下图只点选IE10，自动安装并重启后，再次扫描列表，你会发现IE8、IE9相关的内容都不见了。
* 说到IE10，还要提一个要点，这个应该是微软方面的BUG。如果封装的是 Win7 x64，默认IE8，如果先升级IE9，再升级IE10，则封装报错；如果IE8不升级IE9，直接升级IE10，则封装正常。如果你要集成IE10，请切记此要点。
2、安装软件 常用软件常用的一般也就几种，大家请根据自己的系统部署范围而决定，如下图示例：
特别提醒 （1）不是所有的软件都能良好适应系统封装部署，特别是某些国产软件；
（2）需要激活的软件，部署完毕后一般都需要重新激活；
（3）不建议集成安全类软件，某些安全软件会阻挡正常的系统部署进程，甚至导致蓝屏宕机；
（4）如果某些软件不适合集成在系统，可以使用首次进桌面静默安装的方法来解决。
3、系统备份 补丁安装要20分钟左右，软件也需要逐个安装与调整，所以整体时间一般不少于30分钟。为防止封装时出现未知错误，建议再次备份系统，以备今后的调整操作。这次备份完，我们就可以放心大胆的开始封装操作了。
这次备份我们就要说一下 ImageX 的多映像叠加功能了。所谓映像叠加（又叫“增量备份”），就是在同一个映像文件中可以同时存放多个子映像，例如Win7的安装文件install.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b33b59d5bce528da1a8ee999a6550e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0d939955c318b7480fb4f3fc4d72e4/" rel="bookmark">
			ThinkPhp&#43;Vue前后端分离框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目介绍 一款 PHP 语言基于ThinkPhp6、Vue、ElementUI等框架精心打造的一款模块化、插件化、高性能的前后端分离架构敏捷开发框架，可用于快速搭建前后端分离后台管理系统，本着简化开发、提升开发效率的初衷，目前框架已集成了完整的RBAC权限架构和常规基础模块，前端Vue端支持多主题切换，可以根据自己喜欢的风格选择想一个的主题，实现了个性化呈现的需求；为了敏捷快速开发，提升研发效率，框架内置了一键CRUD代码生成器，自定义了模块生成模板，包括后端PHP文件模块和前端Vue端个性化模板，可以根据已建好的表结构(字段注释需规范)快速的一键生成整个模块的所有代码和增删改查等等功能业务，真正实现了低代码开发，极大的节省了人力成本的同时提高了开发效率，缩短了研发周期，是一款真正意义上实现组件化、低代码敏捷开发框架。
内置模块 用户管理：用于维护管理系统的用户，常规信息的维护与账号设置。角色管理：角色菜单管理与权限分配、设置角色所拥有的菜单权限。菜单管理：配置系统菜单，操作权限，按钮权限标识等。职级管理：主要管理用户担任的职级。岗位管理：主要管理用户担任的岗位。部门管理：主要管理系统组织架构，对组织架构进行统一管理维护。操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。登录日志：系统登录日志记录查询包含登录异常。字典管理：对系统中常用的较为固定的数据进行统一维护。配置管理：对系统的常规配置信息进行维护，网站配置管理功能进行统一维护。城市管理：统一对全国行政区划进行维护，对其他模块提供行政区划数据支撑。友链管理：对系统友情链接、合作伙伴等相关外链进行集成维护管理的模块。个人中心：主要是对当前登录用户的个人信息进行便捷修改的功能。广告管理：主要对各终端的广告数据进行管理维护。站点栏目：主要对大型系统网站等栏目进行划分和维护的模块。会员管理：对各终端注册的会员进行统一的查询与管理的模块。网站配置：对配置管理模块的数据源动态解析与统一维护管理的模块。通知公告：系统通知公告信息发布维护。代码生成：一键生成模块CRUD的功能，包括后端和前端Vue等相关代码。案例演示：常规代码生成器一键生成后的演示案例。 软件信息 软件名称：RXThinkCMF敏捷开发框架ThinkPhp6.x+EleVue版本官网网址：https://www.rxthink.cn文档网址：http://docs.thinkphp6.elevue.rxthink.cn演示地址：http://manage.thinkphp6.elevue.rxthink.cn 版本说明 版本名称版本说明版本地址ThinkPhp3.2+Layui混编版采用ThinkPhp3.2、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp3.2_LayuiThinkPhp5.1+Layui混编版采用ThinkPhp5.1、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp5.1_LayuiThinkPhp6.x+Layui混编版采用ThinkPhp6、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp6_LayuiThinkPhp8.x+Layui混编版采用ThinkPhp8、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp8_LayuiLaravel8.x+Layui混编版采用Laravel8、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_laravel8_LayuiLaravel9.x+Layui混编版采用Laravel9、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel9_LayuiLaravel10.x+Layui混编版采用Laravel10、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel10_LayuiThinkPhp3.2+EleVue前后端分离版采用ThinkPhp3.2、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp3.2_EleVueThinkPhp3.2+AntdVue前后端分离版采用ThinkPhp3.2、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp3.2_AntdVueThinkPhp5.1+EleVue前后端分离版采用ThinkPhp5.1、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp5.1_EleVueThinkPhp5.1+AntdVue前后端分离版采用ThinkPhp5.1、Vue2.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp5.1_AntdVueThinkPhp6.x+EleVue前后端分离版采用ThinkPhp6、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp6_EleVueThinkPhp6.x+AntdVue前后端分离版采用ThinkPhp6、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp6_AntdVueThinkPhp8.x+EleVue前后端分离版采用ThinkPhp8、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp8_EleVueThinkPhp8.x+AntdVue前后端分离版采用ThinkPhp8、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp8_AntdVueLaravel8.x+EleVue前后端分离版采用Laravel8、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel8_EleVueLaravel8.x+AntdVue前后端分离版采用Laravel8、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel8_AntdVueLaravel9.x+EleVue前后端分离版采用Laravel9、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel9_EleVueLaravel9.x+AntdVue前后端分离版采用Laravel9、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel9_AntdVueLaravel10.x+EleVue前后端分离版采用Laravel10、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel10_EleVueLaravel10.x+AntdVue前后端分离版采用Laravel10、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel10_AntdVue 模块展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9ce2af29ad39f3b9bdf397d5091dd2/" rel="bookmark">
			计算机网络笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料： 从实践中学习TCP/IP协议书籍
家庭网络常识 1：猫、路由器、wifi_哔哩哔哩_bilibili
B站计算机网络微课堂（湖科大教书匠）学习笔记_湖科大教书匠ppt_SS上善的博客-CSDN博客
【android】 使用vpn实现抓包 | iTimeTraveler
文章目录 参考资料：一、概述(一)、名词解释1、网卡2、网络设备3、网络相关4、常用Linux命令 (二)、网络分层1、OSI协议层次2、TCP/IP协议层次结构 (三)、Wireshark使用1、常见网卡2、数据包层次结构3、使用过滤器 (四)、其他1、外网不能访问主机，需要借助端口映射(内网穿透)技术2、127.0.0.1和0.0.0.03、socks5代理和HTTP代理 二、应用层(一)、动态主机配置协议DHCP1、DHCP工作方式 (二)、DNS协议1、域名解析流程 三、传输层(一)、端口和嵌套字1、端口2、嵌套字3、TCP/IP体系的应用层常用协议所使用的运输层熟知端口号 (二)、TCP协议1、TCP协议作用2、TCP报文首部格式3、TCP协议三次握手4、TCP协议四次挥手 (三)、UDP协议1、UDP协议特点2、UDP协议数据格式 四、网络层(一)、概述1、网络层主要解决的问题 (二)、IP地址1、分类编址2、特殊IP地址 3、子网划分以及CIDR格式4、IP数据报格式 (三)、ARP协议1、基本流程2、ARP表3、MAC表4、总结 (四)、NAT地址转换(五)、IP数据报的发送和转发过程1、主机发送IP数据报：局域网内通信2、路由器转发IP数据报 (六)、ICMP协议1、探测主机：ping2、路由跟踪：traceroute (七)、VPN(Virtual Private Network)1、原理2、VPN抓包原理 (八)、端口映射(内网穿透)1、作用2、原理 五、数据链路层(一)、帧结构 一、概述 (一)、名词解释 1、网卡 网卡也被称为网络适配器（Network Adapter），是连接计算机和 传输介质的接口。网卡主要用来将计算机数据转换为能够通过传输介 质传输的信号。
有线网卡
无线网卡：无线网卡通常特指Wi-Fi网络的无线网卡
蓝牙适配器
虚拟网卡：是在软件中模拟的网络接口卡
桥接模式：虚拟机可以看作一台独立的主机，与物理主机处于同一网段。NAT模式：虚拟机的所有网络流量先通过宿主机的虚拟网卡，然后通过宿主机的物理网卡转发到互联网，并使用宿主机的IP地址。该模式下虚拟机的ip地址是通过虚拟网卡转换得到的。仅主机模式：虚拟机只能与宿主机通信，不能与外部网络通信。这通常用于测试和隔离环境。 模式使用网卡通信情况桥接模式真实网卡可以与主机和外网通讯，有独立ip地址，容易造成ip地址冲突NAT模式VMnet8网卡可以与主机和外网通讯，不占用ip地址Host-only：仅主机模式VMnet1网卡只能与主机通信 2、网络设备 网络设备指的是网络组成中的设备，如交换机、路由器、调制解 调器等。它们是发送或接收数据的终端设备
交换机：可以将多个网络设备连接起来组成一个局域网路由器：又称网关设备(Gateway)，用于连接多个逻辑 上分开的网络，即单独的网络或者子网，只有网络层、数据链路层、物理层猫：信号转换的 3、网络相关 IP地址由网络号和主机号组成子网掩码告诉计算机哪些是网络号，哪些是主机号网络地址IP地址&amp;子网掩码网段网络地址相同的IP地址属于同一网段，即同一子网网关网络关卡，目标IP在不同网段时需要经过网关ARP表存放IP和MAC地址的映射MAC表存放MAC地址和物理端口的映射信息路由表存放目标网络的对应网关，即下一跳 4、常用Linux命令 常看路由表route -n查看默认路由ip route show |grep default查看本机IP和MAC地址ip addr查看本机ARP表arp -a查看Socket相关的端口号netstat -tulnp (tcp：显示tcp相关 u：显示udp相关 l：监听状态 n：不显示别名，以数字形式显示 p：显示程序名和进程pid)查看进程打开的文件列表lsof -p PID查看网络连通性ping ip地址查看达到目标网络经过的路由traceroute ip地址查看域名IPhost/ping 域名 (二)、网络分层 1、OSI协议层次 分层常见协议作用应用层HTTP、HTTPS、DNS、DHCP、Telnet、SNMP、FTP为应用程序提供服务并规定应用程序中相关的通信细节表示层转换应用层的信息为适合网络传输的格式会话层socks5代理负责建立和断开Socket通信连接传输层TCP、UDP、解决进程之间的传输问题网络层ARP、ICMP、IP将数据传输到目标地址，主要负责寻址和路由转发问题数据链路层负责物理层面上互联的节点间的通信传输物理层进行比特流传输 2、TCP/IP协议层次结构 应用层传输层网际层：即网络层网络访问层：数据链路层+物理层 (三)、Wireshark使用 1、常见网卡 eth0以太网接口lo本地回环接口wlan0无线接口rmnetsim卡接口tun0代理转发接口 2、数据包层次结构 Packet List面板：上面部分，显示Wireshark捕获到的所有数据包， 这些数据包从1进行顺序编号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a9ce2af29ad39f3b9bdf397d5091dd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e53841c6572ee486a9e69f37e16f75/" rel="bookmark">
			Laravel9极速后台开发框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 一款 PHP 语言基于 Laravel9、Layui、MySQL等框架精心打造的一款模块化、插件化、高性能的前后端分离架构敏捷开发框架，可用于快速搭建前后端分离后台管理系统，本着简化开发、提升开发效率的初衷，框架自研了一套个性化的组件，实现了可插拔的组件式开发方式：单图上传、多图上传、下拉选择、开关按钮、单选按钮、多选按钮、图片裁剪等等一系列个性化、轻量级的组件，是一款真正意义上实现组件化开发的敏捷开发框架，框架已集成了完整的RBAC权限架构和常规基础模块，为了敏捷快速开发，提升研发效率，框架内置了一键CRUD代码生成器，自定义了模块生成模板，可以根据已建好的表结构(字段注释需规范)快速的一键生成整个模块的所有代码和增删改查等等功能业务，真正实现了低代码开发，提高了开发效率，是一款真正意义上实现组件化、低代码敏捷开发框架。
内置模块 用户管理：用于维护管理系统的用户，常规信息的维护与账号设置。角色管理：角色菜单管理与权限分配、设置角色所拥有的菜单权限。菜单管理：配置系统菜单，操作权限，按钮权限标识等。职级管理：主要管理用户担任的职级。岗位管理：主要管理用户担任的岗位。部门管理：主要管理系统组织架构，对组织架构进行统一管理维护。操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。登录日志：系统登录日志记录查询包含登录异常。字典管理：对系统中常用的较为固定的数据进行统一维护。配置管理：对系统的常规配置信息进行维护，网站配置管理功能进行统一维护。城市管理：统一对全国行政区划进行维护，对其他模块提供行政区划数据支撑。友链管理：对系统友情链接、合作伙伴等相关外链进行集成维护管理的模块。个人中心：主要是对当前登录用户的个人信息进行便捷修改的功能。广告管理：主要对各终端的广告数据进行管理维护。站点栏目：主要对大型系统网站等栏目进行划分和维护的模块。会员管理：对各终端注册的会员进行统一的查询与管理的模块。网站配置：对配置管理模块的数据源动态解析与统一维护管理的模块。通知公告：系统通知公告信息发布维护。代码生成：一键生成模块CRUD的功能，包括后端和前端等相关代码。案例演示：常规代码生成器一键生成后的演示案例。 软件信息 软件名称：RXThinkCMF敏捷开发框架Laravel9.x+Layui版本官网网址：https://www.rxthink.cn文档网址：http://docs.laravel9.layui.rxthink.cn演示地址：http://manage.laravel9.layui.rxthink.cn 版本说明 版本名称版本说明版本地址ThinkPhp3.2+Layui混编版采用ThinkPhp3.2、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp3.2_LayuiThinkPhp5.1+Layui混编版采用ThinkPhp5.1、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp5.1_LayuiThinkPhp6.x+Layui混编版采用ThinkPhp6、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp6_LayuiThinkPhp8.x+Layui混编版采用ThinkPhp8、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp8_LayuiLaravel8.x+Layui混编版采用Laravel8、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_laravel8_LayuiLaravel9.x+Layui混编版采用Laravel9、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel9_LayuiLaravel10.x+Layui混编版采用Laravel10、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel10_LayuiThinkPhp3.2+EleVue前后端分离版采用ThinkPhp3.2、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp3.2_EleVueThinkPhp3.2+AntdVue前后端分离版采用ThinkPhp3.2、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp3.2_AntdVueThinkPhp5.1+EleVue前后端分离版采用ThinkPhp5.1、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp5.1_EleVueThinkPhp5.1+AntdVue前后端分离版采用ThinkPhp5.1、Vue2.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp5.1_AntdVueThinkPhp6.x+EleVue前后端分离版采用ThinkPhp6、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp6_EleVueThinkPhp6.x+AntdVue前后端分离版采用ThinkPhp6、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp6_AntdVueThinkPhp8.x+EleVue前后端分离版采用ThinkPhp8、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp8_EleVueThinkPhp8.x+AntdVue前后端分离版采用ThinkPhp8、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp8_AntdVueLaravel8.x+EleVue前后端分离版采用Laravel8、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel8_EleVueLaravel8.x+AntdVue前后端分离版采用Laravel8、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel8_AntdVueLaravel9.x+EleVue前后端分离版采用Laravel9、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel9_EleVueLaravel9.x+AntdVue前后端分离版采用Laravel9、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel9_AntdVueLaravel10.x+EleVue前后端分离版采用Laravel10、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel10_EleVueLaravel10.x+AntdVue前后端分离版采用Laravel10、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel10_AntdVue 核心组件 单图上传组件 @render('UploadImageComponent', ['name'=&gt;'avatar|头像|90x90|建议上传尺寸450x450|450x450','value'=&gt;isset($info['avatar_url']) ? $info['avatar_url'] : '']) 多图上传组件 @render('UploadAlbumComponent', ['name'=&gt;'imgs|图集|90x90|20|建议上传尺寸450x450|450x450','value'=&gt;isset($info['imgsList']) ? $info['imgsList'] : []]) 下拉选择组件 @render('SelectComponent', ['name'=&gt;'gender|1|性别|name|id','data'=&gt;config("admin.gender_list"),'value'=&gt;isset($info['gender']) ? $info['gender'] : 1]) 单选按钮组件 @render('RadioComponent', ['name'=&gt;'gender|name|id','data'=&gt;config("admin.gender_list"),'value'=&gt;isset($vo['gender']) ? $vo['gender'] : 0]) 复选框组件 @render('CheckboxComponent', ['name'=&gt;'type|name|id','data'=&gt;"1=云计算,2=数据库,3=大数据",'value'=&gt;isset($vo['type']) ? $vo['type'] : []]) 城市选择组件 @render('CityComponent', ['cityId'=&gt;isset($info['district_id']) ? $info['district_id'] : 0,'limit'=&gt;3]) 开关组件 @render('SwitchComponent', ['name'=&gt;'status','title'=&gt;'在用|禁用','value'=&gt;isset($info['status']) ? $info['status'] : 1]) 日期组件 @render('DateComponent', ['name'=&gt;'entry_date|入职时间|date','value'=&gt;isset($info['format_entry_date']) ? $info['format_entry_date'] : '']) 图标组件 @render('IconComponent', ['name'=&gt;'icon','value'=&gt;isset($info['icon']) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6e53841c6572ee486a9e69f37e16f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7845f9077a021924512e610b48c1dfea/" rel="bookmark">
			Laravel通用权限管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 一款 PHP 语言基于 Laravel8、Layui、MySQL等框架精心打造的一款模块化、插件化、高性能的前后端分离架构敏捷开发框架，可用于快速搭建前后端分离后台管理系统，本着简化开发、提升开发效率的初衷，框架自研了一套个性化的组件，实现了可插拔的组件式开发方式：单图上传、多图上传、下拉选择、开关按钮、单选按钮、多选按钮、图片裁剪等等一系列个性化、轻量级的组件，是一款真正意义上实现组件化开发的敏捷开发框架，框架已集成了完整的RBAC权限架构和常规基础模块，同时支持多主题切换，可以根据自己喜欢的风格选择想一个的主题，实现了个性化呈现的需求；
为了敏捷快速开发，提升研发效率，框架内置了一键CRUD代码生成器，自定义了模块生成模板，可以根据已建好的表结构(字段注释需规范)快速的一键生成整个模块的所有代码和增删改查等等功能业务，真正实现了低代码开发，极大的节省了人力成本的同时提高了开发效率，缩短了研发周期，是一款真正意义上实现组件化、低代码敏捷开发框架。
内置模块 用户管理：用于维护管理系统的用户，常规信息的维护与账号设置。角色管理：角色菜单管理与权限分配、设置角色所拥有的菜单权限。菜单管理：配置系统菜单，操作权限，按钮权限标识等。职级管理：主要管理用户担任的职级。岗位管理：主要管理用户担任的岗位。部门管理：主要管理系统组织架构，对组织架构进行统一管理维护。操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。登录日志：系统登录日志记录查询包含登录异常。字典管理：对系统中常用的较为固定的数据进行统一维护。配置管理：对系统的常规配置信息进行维护，网站配置管理功能进行统一维护。城市管理：统一对全国行政区划进行维护，对其他模块提供行政区划数据支撑。友链管理：对系统友情链接、合作伙伴等相关外链进行集成维护管理的模块。个人中心：主要是对当前登录用户的个人信息进行便捷修改的功能。广告管理：主要对各终端的广告数据进行管理维护。站点栏目：主要对大型系统网站等栏目进行划分和维护的模块。会员管理：对各终端注册的会员进行统一的查询与管理的模块。网站配置：对配置管理模块的数据源动态解析与统一维护管理的模块。通知公告：系统通知公告信息发布维护。代码生成：一键生成模块CRUD的功能，包括后端和前端等相关代码。案例演示：常规代码生成器一键生成后的演示案例。 软件信息 软件名称：RXThinkCMF敏捷开发框架Laravel8.x+Layui版本官网网址：https://www.rxthink.cn文档网址：http://docs.laravel8.layui.rxthink.cn演示地址：http://manage.laravel8.layui.rxthink.cn 版本说明 版本名称版本说明版本地址ThinkPhp3.2+Layui混编版采用ThinkPhp3.2、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp3.2_LayuiThinkPhp5.1+Layui混编版采用ThinkPhp5.1、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp5.1_LayuiThinkPhp6.x+Layui混编版采用ThinkPhp6、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp6_LayuiThinkPhp8.x+Layui混编版采用ThinkPhp8、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp8_LayuiLaravel8.x+Layui混编版采用Laravel8、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_laravel8_LayuiLaravel9.x+Layui混编版采用Laravel9、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel9_LayuiLaravel10.x+Layui混编版采用Laravel10、Layui、MySQL等框架研发的混编专业版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel10_LayuiThinkPhp3.2+EleVue前后端分离版采用ThinkPhp3.2、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp3.2_EleVueThinkPhp3.2+AntdVue前后端分离版采用ThinkPhp3.2、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp3.2_AntdVueThinkPhp5.1+EleVue前后端分离版采用ThinkPhp5.1、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp5.1_EleVueThinkPhp5.1+AntdVue前后端分离版采用ThinkPhp5.1、Vue2.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp5.1_AntdVueThinkPhp6.x+EleVue前后端分离版采用ThinkPhp6、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp6_EleVueThinkPhp6.x+AntdVue前后端分离版采用ThinkPhp6、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp6_AntdVueThinkPhp8.x+EleVue前后端分离版采用ThinkPhp8、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp8_EleVueThinkPhp8.x+AntdVue前后端分离版采用ThinkPhp8、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_ThinkPhp8_AntdVueLaravel8.x+EleVue前后端分离版采用Laravel8、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel8_EleVueLaravel8.x+AntdVue前后端分离版采用Laravel8、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel8_AntdVueLaravel9.x+EleVue前后端分离版采用Laravel9、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel9_EleVueLaravel9.x+AntdVue前后端分离版采用Laravel9、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel9_AntdVueLaravel10.x+EleVue前后端分离版采用Laravel10、Vue2.x、ElementUI等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel10_EleVueLaravel10.x+AntdVue前后端分离版采用Laravel10、Vue3.x、AntDesign等框架研发前后端分离版本https://gitee.com/rxthinkcmf/RXThinkCMF_Laravel10_AntdVue 核心组件 单图上传组件 @render('UploadImageComponent', ['name'=&gt;'avatar|头像|90x90|建议上传尺寸450x450|450x450','value'=&gt;isset($info['avatar_url']) ? $info['avatar_url'] : '']) 多图上传组件 @render('UploadAlbumComponent', ['name'=&gt;'imgs|图集|90x90|20|建议上传尺寸450x450|450x450','value'=&gt;isset($info['imgsList']) ? $info['imgsList'] : []]) 下拉选择组件 @render('SelectComponent', ['name'=&gt;'gender|1|性别|name|id','data'=&gt;config("admin.gender_list"),'value'=&gt;isset($info['gender']) ? $info['gender'] : 1]) 单选按钮组件 @render('RadioComponent', ['name'=&gt;'gender|name|id','data'=&gt;config("admin.gender_list"),'value'=&gt;isset($vo['gender']) ? $vo['gender'] : 0]) 复选框组件 @render('CheckboxComponent', ['name'=&gt;'type|name|id','data'=&gt;"1=云计算,2=数据库,3=大数据",'value'=&gt;isset($vo['type']) ? $vo['type'] : []]) 城市选择组件 @render('CityComponent', ['cityId'=&gt;isset($info['district_id']) ? $info['district_id'] : 0,'limit'=&gt;3]) 开关组件 @render('SwitchComponent', ['name'=&gt;'status','title'=&gt;'在用|禁用','value'=&gt;isset($info['status']) ? $info['status'] : 1]) 日期组件 @render('DateComponent', ['name'=&gt;'entry_date|入职时间|date','value'=&gt;isset($info['format_entry_date']) ? $info['format_entry_date'] : '']) 图标组件 @render('IconComponent', ['name'=&gt;'icon','value'=&gt;isset($info['icon']) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7845f9077a021924512e610b48c1dfea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5753cc995189e70f6ade8569e424c3b/" rel="bookmark">
			R语言学习系列 # Tidyverse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # Tidyverse tidyverse是一系列包的合集（80个以上），最重要的是8个核心包：
ggplot2，高级数据可视化，画图用。dplyr，提供了一种数据操作方法。对数据进行操作，如select() ， filter()。tidyr，提供了一组清洗数据的函数。整洁数据：每个变量都放在一个列中，而每个列都是一个变量。readr，提供了一种快速、友好的方式来读取数据(如csv、tsv和fwf)。purrr，增强了R的函数式编程(FP)工具包，提供了一组完整而一致的工具，用于处理函数和向量。tibble，是对数据框架的现代重新想象，对data.frame的改进。stringr，提供了一组函数，旨在使使用字符串尽可能更容易。forcats，可以解决与因子有关的常见问题。R使用因子来处理类别变量，即具有固定和已知的可能值集的变量。 Tidyverse中部分包的图标
tidyverse 官网： Tidyverse packages library(tidyverse) tidyverse自带8个包（ggplot2、purrrr、tibble、dplyr、tidyr、stringr、readr、forcats）。
下面的Conflicts是因为不同包中具有相同函数名，解决办法是在调用函数的时候在前面加上包名（如：dplyr::）。
dplyr::filter() tidyverse官网：
Tidyverse packages R for Date Science、《R语言编程：基于tidyverse》：
3 Data visualisation | R for Data Science (had.co.nz) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384546a091cb493596bca1ad83fc3ac4/" rel="bookmark">
			Docker容器学习：Dockerfile制作Web应用系统nginx镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
编写Dockerfile
1.文件内容需求：
2.编写Dockerfile：
3.开始构建镜像
4.现在我们运行一个容器，查看我们的网页是否可访问
推送镜像到私有仓库
1.把要上传的镜像打上合适的标签
2.登录harbor仓库
3.上传镜像
编写Dockerfile 1.文件内容需求： 基于centos基础镜像。指定作者信息。安装nginx服务，将提供的dest目录（提供默认主页index.html）传到镜像内，并将dest目录内的前端文件复制到nginx的工作目录。暴露80端口。设置服务自启动。验证镜像。 2.编写Dockerfile： [root@node4 web]# pwd /dockerfile/web [root@node4 web]# ll total 8 -rw-r--r-- 1 root root 362 Aug 20 23:23 Dockerfile -rw-r--r-- 1 root root 36 Aug 20 22:55 index.html [root@node4 web]# more index.html This is a nginx test for Dockerfile [root@node4 web]# more Dockerfile # 基于centos:7基础镜像 FROM centos:7 # 指定作者信息 MAINTAINER "Xcgouge &lt;xcgouge@163.com&gt;" # 安装nginx RUN yum -y update &amp;&amp; \ yum -y install epel-release &amp;&amp; \ yum -y install nginx &amp;&amp; \ yum clean all # 默认主页 COPY index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/384546a091cb493596bca1ad83fc3ac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28417253b29bb2a3c30183ecdb25d6fc/" rel="bookmark">
			解决前后端交互Long类型精度丢失的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、全局注解 package com.jiawa.train.common.config; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; /** * 统一注解，解决前后端交互Long类型精度丢失的问题 @Configuration public class JacksonConfig { @Bean public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); SimpleModule simpleModule = new SimpleModule(); simpleModule.addSerializer(Long.class, ToStringSerializer.instance); objectMapper.registerModule(simpleModule); return objectMapper; } } 2、单独配置 使用注解就可以解决问题。
/** * id */ @JsonSerialize(using= ToStringSerializer.class) private Long id; /** * 会员id */ @JsonSerialize(using= ToStringSerializer.class) private Long memberId; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/301f076635096fad421092f62a24388f/" rel="bookmark">
			《我的 Classic Platform AUTOSAR之路》 Mcal Dio配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《我的 Classic Platform AUTOSAR之路》 Mcal Dio配置 Dio 模块Dio模块在AUTOSAR架构中的位置Dio模块接口使用简介 Dio 模块 Dio模块在AUTOSAR架构中的位置 架构参考：https://www.autosar.org/
Dio是汽车嵌入式架构中比较简单的模块，其配置相对简单，主要是和芯片的引脚编号有关，Dio 模块和Port模块配合，才能实现普通GPIO的输出输入控制。其在AUTOSAR架构中的位置如图：
Dio模块属于AUTOSAR 架构中的MCAL层，Dio又属于I/O Drivers，上面与I/O Hardware Abstraction交互。其调用关系：MCU-&gt;Dio-&gt;IoHwAb-&gt;Rte-&gt;ASW.
Dio模块接口使用简介 AUTOSAR Dio模块主要去获得芯片的Port索引号，其实际就是把引脚与芯片的引脚寄存器的一层Mapping关系，实际上在引脚上使用什么功能都是通过Port模块去配置。所以Dio模块基本上是MCAL中最简单的配置模块。
Dio主要的两个函数：
Sts = Dio_ReadChannel(Channnel); Ret = Dio_WriteChannel(Channel,STD_ON/STD_OFF) 建议：如果芯片重复在不同的硬件使用，这个模块可以配置成平台化配置，所有的硬件使用PA01这种厂商自带编号，在不同的工程上无需重复配置，最大化配置，不影响功能使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67508189ffd802d84b9bf6919bb450a4/" rel="bookmark">
			总结MATLAB中常用函数进行总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MATLAB中常用函数一 . matalab 中的zeros（）函数和ones（）函数1.zeros（）函数的具体用法如下：2.ones（）函数的具体用法如下： 二 . matlab中的size（）函数三 . matlab中的sum（）函数1. plot函数示例代码： 2. linspace函数示例代码： 3. meshgrid函数示例代码： 4. fft函数示例代码： 5. filter函数示例代码： Matlab是一种高级的数学软件，具有强大的数值计算功能，是科学计算、工程计算和数据分析的重要工具。在Matlab中，函数是非常重要的一部分，它们可以帮助我们快速完成计算任务。下面我们将
MATLAB中常用函数 一 . matalab 中的zeros（）函数和ones（）函数 zeros（）函数用来生成全0矩阵
ones（）函数用来生成全1矩阵
1.zeros（）函数的具体用法如下： zeros(n)：nn 全零矩阵
zeros(m,n)：mn全零矩阵
zeros(d1,d2,d3……dn)：生成 d1d2d3*……*dn 全零矩阵或数组。
zeros(size(A))：生成与矩阵A大小相同的全零矩阵。
2.ones（）函数的具体用法如下： ones(n)：nn 全1矩阵
ones(m,n)：mn全1矩阵
ones(d1,d2,d3……dn)：生成 d1d2d3*……*dn 全1矩阵或数组。
ones(size(A))：生成与矩阵A大小相同的全1矩阵。
二 . matlab中的size（）函数 size(）函数的用法：
size（A）：对于矩阵A，函数size（A）返回一行向量。
该行向量的第一个元素表示矩阵的行，第二个元素表示矩阵的列.
size(A, 1)：表示获取矩阵A的行数
size(A, 2)：表示获取矩阵A的列数
三 . matlab中的sum（）函数 sum（）函数的用法：
对于sum(A)，
若A为一个行向量，不指定dim或者指定dim为2，即sum（A）或者sum（A，2），结果是该行向量所有元素的和；
如果指定dim为1，则计算结果为一个行向量，且该行向量与原来的行向量相同。
介绍一些Matlab中常用的函数以及示例代码。
1. plot函数 plot函数可以将数据绘制成图形。该函数接受一个或多个向量作为输入，将它们绘制为曲线或散点图。
示例代码： x = -10:0.1:10; y = sin(x); plot(x, y); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67508189ffd802d84b9bf6919bb450a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4139f253b34691f56a34d87321a4691d/" rel="bookmark">
			C&#43;&#43; 中的“＆”、“*”、“.”、“-＞”、“:”和“::”运算符介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 中的 "＆"，"*"，"."，"-&gt;"，":" 和 "::"运算符介绍 在C++中 "＆"，"*"，"."、"-&gt;"、":"和"::"都是运算符
&amp; 取地址符、引用符、按位与运算符。
* 乘法运算符、指针解引用运算符(也称为间接寻址运算符)
. 点运算符或成员访问运算符。
-&gt; 箭头运算符或成员指针访问运算符。
: 冒号运算符或成员初始化列表符号。
:: 作用域解析运算符或命名空间限定符。
它们的使用场景也各有不同。需要根据具体情况来选择使用哪个运算符。
"&amp;"运算符 在C++中，&amp;被称为取地址符或引用符号。按不同的应用场景，有多种用法，以下是其中几种常见的用法及示例说明。
1.取地址运算符：
&amp;用于获取变量的内存地址。例如：
#include &lt;iostream&gt; using namespace std; int main() { int a = 10; int* ptr = &amp;a; // 取变量a的地址并赋值给指针ptr cout &lt;&lt; "a 的地址: " &lt;&lt; ptr &lt;&lt; endl; return 0; } 2.引用类型：
&amp;可以用于定义引用类型，即某个变量的别名。例如：
#include &lt;iostream&gt; using namespace std; int main() { int a = 10; int&amp; ref = a; // 定义一个引用ref，它是变量a的别名 ref = 20; // 修改引用ref的值，也会修改变量a的值 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4139f253b34691f56a34d87321a4691d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d5c40684d3397899aa676e128e4cde/" rel="bookmark">
			Docker容器学习：搭建自己专属的LAMP环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
编写Dockerfile
1.文件内容需求：
2.值得注意的是centos6官方源已下线，所以需要切换centos-vault源！
3.Dockerfile内容 4.进入到 lamp 开始构建镜像
推送镜像到私有仓库
1.把要上传的镜像打上合适的标签
2.登录harbor仓库
3.上传镜像
LAMP 环境结合了 Linux、Apache、MySQL 和 PHP，提供了一个稳定、可靠、安全和高效的平台，用于创建和管理 Web 应用程序的开源开发平台。
编写Dockerfile 1.文件内容需求： 基于centos:6基础镜像。指定作者信息。安装httpd、mysql、mysql-server、php、php-mysql、php-gd。暴露80和3306端口。设置服务自启动。验证镜像。 2.值得注意的是centos6官方源已下线，所以需要切换centos-vault源！ mkdir /dockerfile/lamp cd /dockerfile/lamp wget -O CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-6.10.repo [root@node4 lamp]# ll total 8 -rw-r--r-- 1 root root 2533 Aug 4 2022 CentOS-Base.repo -rw-r--r-- 1 root root 620 Aug 20 21:15 Dockerfile 3.Dockerfile内容 [root@node4 lamp]# vim Dockerfile # 基于centos:6基础镜像 FROM centos:6 # 指定作者信息 LABEL maintainer="Zly &lt;1647082043@qq.com&gt;" # 将新的yum源复制到centos中 COPY CentOS-Base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84d5c40684d3397899aa676e128e4cde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/273e040b5c5c2e1f4c57f5c0e04bfb14/" rel="bookmark">
			网络安全（黑客）零基础自学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全是什么？ 网络安全，顾名思义，网络上的信息安全。
随着信息技术的飞速发展和网络边界的逐渐模糊，关键信息基础设施、重要数据和个人隐私都面临新的威胁和风险。
网络安全工程师要做的，就是保护网络上的信息安全。确保计算机网络系统的机密性、完整性和可用性，保护系统不受未经授权的访问、破坏或数据泄露等威胁。这需要采取一系列措施来保护网络和其相关设备，比如说，使用防火墙、入侵检测和预防系统、虚拟专用网络（VPN）和加密技术。
通俗一点来说，网络安全工程师可以通过各种技术来对公司的数据进行保护。技能讲究一个“攻防兼备”比如说寻找公司数据存放的弱点，监控公司系统或网络中的缺陷等，同时也要修复和加强公司信息网络中可能会被攻击的地方。
但这样“攻防兼备”的人才，在当前的就业形势下，可以说是严重缺失，网络安全方向工程师就业前景还是比较好的。
如何入门学习网络安全 1、多练多想，不要离开了教程什么都不会，最好看完教程自己独立完成技术方面的开发。
2、有问题多google,baidu…我们往往都遇不到好心的大神，谁会无聊天天给你做解答。遇到实在搞不懂的，可以先放放，以后再来解决。
3、既然决定开始学，那就需要坚持坚持再坚持，暂时的枯燥烦恼只是你以后工作时的悠闲谈资。
零基础入门 对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。
学习方法看书学习，这是最最基础的实际动手，开发路线需要多写代码，阅读优秀开源代码，二进制路线多分析样本，编写EXP等等，渗透测试多拿网站练手（合法方式）等打CTF，多参与一些网络安全比赛，接近实战的环境下锻炼动手能力混圈子，多混一些安全大牛出没的社群、社区、论坛，掌握行业信息，了解最新技术变化趋势国内外各大网络安全论坛、网站有不懂的问题就多去这些论坛网站搜索，基本可以解决问题，实在弄不懂那只能去请教大神了。
1、安全焦点BugTraq：http://www.fuzzysecurity.com/
2、Exploit-DB：https://www.exploit-db.com/hackone
3、一个漏洞提交平台，可以提交各种大厂的漏洞获得奖金，也有很多大佬分享的挖洞经验。
HackerOne | #1 Trusted Security Platform and Hacker Program
4、FreeBuf：FreeBuf网络安全行业门户
5、先知社区：国内安全技术社区
6、技术文章 - 先知社区看雪论坛：https://bbs.pediy.com/
7、安全客，提供网络安全资讯的网站
8、安全资讯平台secquan：Powered by SecQuan
我最讨厌的就是搭建环境了，这个为我剩了太多时间了，而且学到了很多新姿势
我这里有一些自学时的资料，有一些是花钱买的，也有一些是自己在网上找的资源，整理了一些比较好的比较有用的分享给大家，关注后会自动发链接给大家，都是23年高清pdf版的。
推荐前期需要学习的几个网络安全相关的工具： Wireshark：数据包捕获和分析工具，可以用于分析网络流量和协议，对于理解网络通信和网络安全非常有帮助。
Nmap：网络扫描工具，可以用于快速扫描目标主机的端口和服务，发现网络中的漏洞和弱点。
Metasploit：渗透测试工具，包含了很多常用的攻击模块和漏洞利用代码，可以用于测试系统的安全性。
Burp Suite：Web应用程序渗透测试工具，可以用于拦截、修改和发送HTTP请求，分析Web应用程序的漏洞。
Hydra：密码破解工具，可以用于破解常用的用户名和密码，测试系统的强密码策略和用户认证机制。
以上工具都是网络安全领域中非常流行和常用的工具，掌握它们可以帮助你进行网络安全测试和攻防实践。当然，掌握这些工具需要较好的计算机基础和网络安全知识。
结语 网络安全是当今社会中至关重要的议题。随着科技的迅猛发展，网络已经渗透到我们生活的方方面面，给我们带来了巨大的便利和机遇。然而，网络也存在着各种风险和威胁，如黑客攻击、数据泄露等。因此，学习网络安全知识成为每个人都应该关注和重视的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef4e646ee80c59f26146144cc56927a6/" rel="bookmark">
			快捷键大全cad(快捷键大全表格图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 快捷键大全表格图(cad快捷键命令大全) AUTO CAD 快捷键命令大全
1. 创建直线 L+空格 25 .复制
2. 创建圆 C+空格 26 .粘贴
3. 创建圆弧 A+空格 27 .剪切
4. 创建矩形 REC +空格 28 . 新建文件
5. 创建点 PO +空格 29 . 在 CAD 里寻求帮助时
6. 创建单行文本 DT 30 . 正交
7. 创建多行文本 MT 31 . 打开和关闭对象捕捉工具
8. 创建填充 H 32 . 直线标注的快捷方式是 DLI +空格
9. 将已经画出的线段延伸到某一线段 EX +空格 33 . 调整文字样式
10 .将已经画出的矩形倒圆角 F+空格 34 . 重新生成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef4e646ee80c59f26146144cc56927a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3287d41f6452d5140d03bd54f9cbdb/" rel="bookmark">
			Java中日志的相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的过程中直接复制进入就可以了。
@Aspect @Component public class LogAspect { public LogAspect() { System.out.println("Common LogAspect"); } private final static Logger LOG = LoggerFactory.getLogger(LogAspect.class); /** * 定义一个切点 */ @Pointcut("execution(public * com.jiawa..*Controller.*(..))") public void controllerPointcut() { } @Before("controllerPointcut()") public void doBefore(JoinPoint joinPoint) { // 增加日志流水线 MDC.put("LOG_ID",System.currentTimeMillis()+ RandomUtil.randomString(3)); // 开始打印请求日志 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); Signature signature = joinPoint.getSignature(); String name = signature.getName(); // 打印请求信息 LOG.info("------------- 开始 -------------"); LOG.info("请求地址: {} {}", request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c3287d41f6452d5140d03bd54f9cbdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d23e1488a8cebf651bc5ff1b88e26cb/" rel="bookmark">
			计算机基础（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机基础（一） 文章目录 计算机基础（一）一、计算机的五大组成部分1.控制器2.运算器3.存储器4.输入设备5.输出设备 二、计算机的三大核心硬件1.中央处理器（CPU）2.内存3.硬盘 三、操作系统1.PC端操作系统2.移动端操作系统3.操作系统的三大架构 四、编程和编程语言1.什么是语言？2.什么是编程？3.什么是编程语言？4.计算机的本质 一、计算机的五大组成部分 1.控制器 控制器是计算机的指挥中心，用来控制计算机的其他组件的运行，相当于人的大脑。
2.运算器 运算器是处理计算机的算术运算和逻辑运算。
3.存储器 存储器是存储计算机的数据。存储器分为“内存”和“外存”。
“内存”相当于“人的短期记忆”。有着断电丢失数据的特性外存。程序想要运行，数据必须先存在于内存中“外存”（硬盘）相当于记事本，有着永久保存数据的特性。eg:硬盘、磁带、光盘、软盘、U盘、移动硬盘等。 4.输入设备 输入设备是计算机接收外部数据的工具，如键盘、鼠标、麦克风等。
5.输出设备 输出设备是计算机对外输出数据的工具，如显示器、打印机等。
二、计算机的三大核心硬件 1.中央处理器（CPU） CPU=控制器+运算器
2.内存 读取速度快，基于电工作，断电数据丢失。
3.硬盘 读取速度相对 来说较慢，但是可以永久保存数据。
三、操作系统 1.PC端操作系统 Windows操作系统MacOS操作系统Linux操作系统 2.移动端操作系统 Andriod系统 IOS系统HarmonyOS系统 3.操作系统的三大架构 计算机硬件操作系统应用软件 四、编程和编程语言 1.什么是语言？ 语言就是人与人之间沟通交流的媒介
2.什么是编程？ 编程就是程序员使用计算机能够读懂的语言把自己所想的东西给写下来的过程就是编程。
3.什么是编程语言？ 就是人与计算机沟通的交流的媒介。
常见的编程语言：Python、Java、Go、PHP、C等。 4.计算机的本质 让电脑像人脑一样，能够像人一样工作。
人类想让计算机能够无休止的代替人类工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b357777e9fb58ebeb484c19ed2c7c0a/" rel="bookmark">
			新手云服务器上搭建个人网站&#43;数据库（宝塔面板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境准备 一台云服务器。 推荐大厂：阿里云，华为云，腾讯云，百度云等,这里我的操作系统是centos7。
2.连接云服务器安装宝塔面板 提示：ssh，xshell，Workbench 都可以远程连接
2.1这里我使用面板自带的Workbench连接。 2.2 安装宝塔面板
宝塔Linux面板安装教程 安装成功后会有登录信息，访问链接进入宝塔面板，安装宝塔面板推荐的 LNMP 这个系统 也就是下面这几个软件。
3.建立网站 3.1 设置安全策略和防火墙 服务器安全策略打开一些常用端口 例如mysql3306端口，http443端口，在创建一些建站端口，我的是5555,5354端口，后面自己的网页就是ip+端口(没有购买域名，学习够用就行)。
3.2 服务器防火墙（centos）
查看防火墙是否开启
systemctl status firewalld.service 查看防火墙放行端口
firewall-cmd --list-ports 永久添加5555端口，放行端口
firewall-cmd --zone=public --add-port=5555/tcp --permanent 重新加载防火墙配置，再次执行上面代码查看放行端口
sudo firewall-cmd --reload 注意：后面建站访问不起一定一定一定是你运行商服务器安全策略没打开，防火墙没放行端口
注意：后面建站访问不起一定一定一定是你运行商服务器安全策略没打开，防火墙没放行端口
注意：后面建站访问不起一定一定一定是你运行商服务器安全策略没打开，防火墙没放行端口
重要！！！！！！！！
3.3 宝塔面板建站 这里是创建网站的默认文件（可以换成自己的）
建站默认默认网页，访问例如http://47.111.222.333:5555/ （公网ip+端口）
4.创建云数据库服务器 4.1 宝塔面板创建数据库，这里我选择的是mysql
4.2 登录mysql,执行以下命令登录，出现mysql&gt;命令符登录成功 mysql -u study -p 4.4 创建简单的mysql表 (可以使用 navicat 工具来管理数据库) 使用study数据库
use study; 创建user表
CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(50) NOT NULL, `info` varchar(255) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=50 DEFAULT CHARSET=utf8; 插入数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b357777e9fb58ebeb484c19ed2c7c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc2ea885cfce9cd4e98d7994af16424/" rel="bookmark">
			TensorFlow：tensorflow.keras.Model.fit（）报错： TypeError: Failed to convert elements of xxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 在使用TensorFlow进行数据训练的时候，报了下面这样的一个错误。
代码如下：
import tensorflow as tf from utilz import * import numpy as np acoustic = load_features('C:/Test/MSA Datasets/data/acoustic_wav2vec.pkl') label = load_features('C:/Test/MSA Datasets/data/labels.pkl') shapeReturn = np.shape(acoustic['train']) print(shapeReturn) x = tf.keras.layers.Input((128, 512)) h = tf.keras.layers.LSTM(32, dropout=0.5)(x) res = tf.keras.layers.Dense(3, 'softmax')(h) model = tf.keras.Model(inputs=x, outputs=res) # 问题出现在下面这一行 model.compile(optimizer='Adam', loss=tf.keras.losses.SparseCategoricalCrossentropy) model.summary() print(model.summary()) output_layer = model.layers[-1] print(output_layer.activation) callback_list = [tf.keras.callbacks.ModelCheckpoint(filepath='C:/Test/MSA Datasets/res_tmp/model.tf', monitor='val_loss', save_best_only=True, save_freq='epoch')] model.fit(x=np.asarray(acoustic['train']), y=np.asarray(label['train']), batch_size=16, epochs=30, validation_data=[np.asarray(acoustic['valid']), np.asarray(label['valid'])], callbacks=callback_list) 报错如下：
Traceback (most recent call last): File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dc2ea885cfce9cd4e98d7994af16424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/891a15b742d8429ea645c8767f047f98/" rel="bookmark">
			如何区分ChatGPT4.0对比3.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT4.0对比3.5，可以归纳以下几点
一、更强大的语言理解能力
二、更好的上下文理解能力
三、更好的可解释性
四、更广泛的应用场景
地址:ALLlinkai
以下截图的问题，可以直接分辨出对话的是4.0还是3.5
3.5对于下面截图2个问题回答都是错误的，而4.0可以很完美的解答这2个问题。
Midjourney 绘画
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3494a34d8eccb5ca822a8614f37800f6/" rel="bookmark">
			uniapp 安卓平台签名证书(.keystore)生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装JRE环境 下载jre安装包：https://www.oracle.com/java/technologies/downloads/#java8安装jre安装包时，记录安装目录(例:C:\Program Files\Java\jdk-20)打开命令行（cmd），将JRE安装路径添加到系统环境变量 d: set PATH=%PATH%;"C:\Program Files\Java\jdk-20\bin" 第一行：切换工作目录到D:路径
第二行：将jre命令添加到临时环境变量中
生成签名证书 使用keytool -genkey命令生成证书： keytool -genkey -alias [证书别名] -keyalg RSA -keysize 2048 -validity [有效期，以天为单位] -keystore [文件名].keystore 注意:
A 证书别名：可修改为自己想设置的字符，建议使用英文字母和数字
B 证书文件名称：可修改为自己想设置的文件名称，也可以指定完整文件路径
C 证书的有效期：单位天，建议时间设置长一点，避免证书过期
按照提示内容输入命令行 keytool -genkey -alias Android -keyalg RSA -keysize 2048 -validity 36500 -keystorecertificate.keystore 输入密钥库口令: // 输入证书文件密码，输入完成回车 再次输入新口令: // 再次输入证书文件密码，输入完成回车 您的名字与姓氏是什么? // 输入名字和姓氏，输入完成回车 [Unknown]: L** 您的组织单位名称是什么? [Unknown]: a** 您的组织名称是什么? [Unknown]: a** 您所在的城市或区域名称是什么? [Unknown]: shanghai 您所在的省/市/自治区名称是什么? [Unknown]: shanghai 该单位的双字母国家/地区代码是什么? // 输入国家/地区代号（两个字母），中国为CN，输入完成回车 [Unknown]: CN CN=XX, OU=XX, O=XX, L=XX, ST=XX, C=XX 是否正确?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3494a34d8eccb5ca822a8614f37800f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fd3c38104e71413a08516b40d3782bd/" rel="bookmark">
			实验4-2-8 验证“哥德巴赫猜想”_c语言_PTA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数学领域著名的“哥德巴赫猜想”的大致意思是：任何一个大于2的偶数总能表示为两个素数之和。比如：24=5+19，其中5和19都是素数。本实验的任务是设计一个程序，验证20亿以内的偶数都可以分解成两个素数之和。
输入格式： 输入在一行中给出一个(2, 2 000 000 000]范围内的偶数N。
输出格式： 在一行中按照格式“N = p + q”输出N的素数分解，其中p ≤ q均为素数。又因为这样的分解不唯一（例如24还可以分解为7+17），要求必须输出所有解中p最小的解。
输入样例： 24 输出样例： 24 = 5 + 19 思路：两个素数判断即可。
#include &lt;stdio.h&gt; #include &lt;math.h&gt; int isprime(int n); int main(int argc, char *argv[]) { int N; scanf("%d",&amp;N); for(int i=2;i&lt;=N;i++) { if(isprime(i)&amp;&amp;isprime(N-i)) { printf("%d = %d + %d",N,i,N-i); break; } } return 0; } int isprime(int n)//素数判断函数 { int ret; if(n==2) ret=1;//2是素数 else{ for(int i=2;i&lt;=sqrt(n);i++) { if(n%i==0) { ret=0; break;//不是素数及时跳出循环。 } ret=1; } } return ret; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb1f20e56828b11a21e37951d459ae04/" rel="bookmark">
			Unity 小程序开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着微信团队发布了UnityWebGL 直接发布小程序的工具，使用unity开发微信小程序也变得简单许多。
unity 开发微信小程序 官方工具https://github.com/wechat-miniprogram/minigame-unity-webgl-transform
由于是微信团队开发的，所以在GitHub的文档已经很详细了，推荐大家看一下里边的优化解决方案。还自带了项目优化工具。
但是还有有几个小坑会让初学者掉进去。
关于项目设置在这里填写对应信息后，使用微信开发者工具打开后，就不用每次再手动输入申请appid时，必须声明为小游戏。不然打开项目后就会报错：找不到.app文件如果只是demo即总包4M以内的话，首保资源加载方式直接选择小游戏分保就可以了如果包体过大，则应选择CDN加载CDN可以自己搭建（很花钱）也可以直接使用微信自带的云开发的CDN服务自己搭建的就不再介绍了，使用自带云开发CDN的话，地址有点难理解这里说明一下： 效果：
unity开发微信小程序
=========================================================================
分割线
=========================================================================
2023.08.25
unity 发布了新的tuanjie版本，提供了更好的小游戏解决方案
团结引擎2022.3.2t1微信小游戏解决方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/237bcfe06ff015a2d24a142180620ec5/" rel="bookmark">
			Nginx的启动与关闭命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录： 一、前言二、命令 一、前言 nginx如果全局安装则可以如下命令执行，否则需要进入nginx的sbin下执行，都带上./
二、命令 启动: 直接使用命令: nginx nginx 关闭1: 快速停止 nginx -s stop 关闭2: 完整有序停止 nginx -s quit 重启: 如下 nginx -s reload 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda92787c9a8fb7ee5f38a087b995c48/" rel="bookmark">
			配置开启Hive远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置开启Hive远程连接 Hive远程连接默认方式远程连接Hive自定义身份验证类远程连接Hive权限问题额外说明 Hive远程连接 要配置Hive远程连接，首先确保HiveServer2已启动并监听指定的端口
hive/bin/hiveserver2 检查 HiveServer2是否正在运行
# lsof -i:10000 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME java 660 root 565u IPv6 89917 0t0 TCP *:ndmp (LISTEN) 默认方式远程连接Hive 如果Hive 运行在与 Hadoop集成的环境中，HiveServer2可以与Hadoop中的用户验证机制集成，并且会使用已经验证的Hadoop用户凭据来进行身份验证和授权。
在IDEA的Database菜单栏如下操作，添加Hive连接
填写Hive地址，以及Hadoop中使用的用户名
注意：初次使用，配置过程会提示缺少JDBC驱动，按照提示下载即可。
点击Test Connection测试，发现连接Hive失败，同时hiveserver2后台日志提示：
WARN [HiveServer2-Handler-Pool: Thread-47] thrift.ThriftCLIService (ThriftCLIService.java:OpenSession(340)) - Error opening session: org.apache.hive.service.cli.HiveSQLException: Failed to open new session: java.lang.RuntimeException: org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.authorize.AuthorizationException): User: root is not allowed to impersonate root at org.apache.hive.service.cli.session.SessionManager.createSession(SessionManager.java:434) at org.apache.hive.service.cli.session.SessionManager.openSession(SessionManager.java:373) at org.apache.hive.service.cli.CLIService.openSessionWithImpersonation(CLIService.java:195) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda92787c9a8fb7ee5f38a087b995c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f8edd4e61c0beee998d15a588b73b3/" rel="bookmark">
			cf Codeforces Round 888 E. Nastya and Potions
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原题：
E. Nastya and Potions
time limit per test3 seconds
memory limit per test256 megabytes
inputstandard input
outputstandard output
Alchemist Nastya loves mixing potions. There are a total of n types of potions, and one potion of type i can be bought for ci coins.
Any kind of potions can be obtained in no more than one way, by mixing from several others. The potions used in the mixing process will be consumed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f8edd4e61c0beee998d15a588b73b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68e89912db31402538ea95506cc98f9/" rel="bookmark">
			git diff 取差异命令获取变更的文件列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git diff 一般用法 git diff commit id1 commit id2 &gt; xxxx.diff git apply xxxx.diff 取单个文件的 git diff commit1 commit2 file &gt; xxx.diff 获取文件列表，加- -stat参数。或者- -name-status git diff commit id1 commit id2 --stat
git diff commit id1 commit id2 --name-status
–stat和&gt; kernel.diff不能连用。–stat会失效。
参考：
https://segmentfault.com/q/1010000000133613
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe02f138e6431699e5344f7930c98d72/" rel="bookmark">
			初识Docker Desktop for Windows10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 初识Docker Desktop for Windows10Docker Desktop for Windows 的安装步骤第一步 下载Docker for Windows安装程序第二步安装Docker Desktop for Windows第三步 启动重新点击桌面图标，启动docker desktop Docker Desktop 使用的简单介绍停止，或者删除运行容器记录如果你还想做一些其他的操作：获取一个新的镜像，以mysql镜像为例一个正常启动mysql容器的实例注意成功的方式 删除容器记录以上就是我初次使用Docker Desktop的操作记录，更多的操作使用还需继续探索，到此结束。 初识Docker Desktop for Windows10 Docker是什么？我想这就不需要过多的解释了，容器的使用带来的应用环境的相互隔离优点也是它能风靡全球，作为云原生技术之一，广泛应用的原因。
我们都知道Windows操作系统，上手容易，但使用时间长了之后，就会出各种古怪的问题，应用残留、软件冲突诸多问题，最后导致系统性能下降、速度变慢，甚至瘫痪。
所以，我对Windows下的Docker很感兴趣，它会不会是想windows那样让人简简单单的就上手使用，都不用去专门的学习相关知识，只要知道功能，通过点点菜单，找找命令就一切OK了？
那就试试呗……
Docker Desktop for Windows 的安装步骤 第一步 下载Docker for Windows安装程序 浏览器访问Docker官网：
https://www.docker.com
打开后会自动识别正在使用的系统，并提供Windows安装程序下载
点击图中”Download Docker Desktop“开始下载安装程序，速度与个人网速有关，文件总大小约 621 MB (651,885,904 字节)
第二步安装Docker Desktop for Windows Windows系统下，安装程序都比较简单，没做任何修改，根据向导提示默认”下一步“，最后完成。
完成后，系统会注销当前用户，重新登陆（不知道是不是必须的，我用的本地用户模式ping码验证登录系统）
桌面上会出现一个”Docker Desktop"图标，蓝底白色小鲸鱼，非常好看:
第三步 启动 在注销重新登陆Windows桌面后，Docker Desktop窗口会自动弹出，
提示需要更新的WSL内核，才能运行，按照提示：
管理员身份打开”powershell"，输入下边命令：
wsl --update 完成后显示：
过程还是比较快的……
我以为更新完后，就已经可以使用了，但是
在powershell命令窗口里，输了两个命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe02f138e6431699e5344f7930c98d72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f03c3b01da6ee0000bd48e32b0572b/" rel="bookmark">
			YOLOV 训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度网盘链接：https://pan.baidu.com/s/12x2t-EYbRC6q2IqqiznZVQ?pwd=LIIB 提取码：LIIB 环境搭建网上搜一下，cuda cudnn nvidia驱动 anconda pytorch pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/
pytorch 安装与cuda驱动一致的版本
图片放在my_data的images下
标注xml数据将文件放my_data的Annotations下运行xml_txt.py
标注txt文件直接将结果放在my_data的labels（xml文件最终是要转为txt的，所以上面在转换）
上述结束运行my_data下的data.py将数据集划分为3组 放置在VOCData文件下
回到yolov7下运行：
//训练用 python train.py --weights ./yolov7.pt --cfg ./cfg/training/yolov7.yaml --data ./myvoc.yaml --device 0 --batch-size 4 --epoch 300 //训练结束测试用 python detect.py --weigths ./runs/train/exp24/weights/best.pt --source ./VOCData/1/ 1.数据集xml文件转txt格式 xml_data.py
import glob import os # xml文件的路径 xml_path = './Annotations/' #定义从xml获取信息的函数 def _read_anno(filename): import xml.etree.ElementTree as ET tree = ET.parse(filename) #获取宽w和高h a = tree.find('size') w,h = [int(a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f03c3b01da6ee0000bd48e32b0572b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00a4464f093c985c078c7cd7740178b/" rel="bookmark">
			设计数据密集型应用 第七章：事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第七章：事务 一些作者声称，支持通用的两阶段提交代价太大，会带来性能与可用性的问题。让程序员来处理过度使用事务导致的性能问题，总比缺少事务编程好得多。
—— James Corbett 等人，Spanner：Google 的全球分布式数据库（2012）
文章目录 第七章：事务事务的棘手概念ACID的含义原子性一致性隔离性持久性复制与持久性 单对象和多对象操作单对象写入多对象事务的需求处理错误和中止 弱隔离级别读已提交没有脏读没有脏写实现读已提交 快照隔离和可重复读实现快照隔离观察一致性快照的可见性规则索引和快照隔离可重复读与命名混淆 防止丢失更新原子写显式锁定自动检测丢失的更新比较并设置（CAS）冲突解决和复制 写入偏差与幻读写入偏差的特征写入偏差的更多例子导致写入偏差的幻读物化冲突 可串行化真的串行执行在存储过程中封装事务存储过程的优点和缺点分区串行执行小结 两阶段锁定2PL不是2PC实现两阶段锁两阶段锁定的性能谓词锁索引范围锁 可串行化快照隔离悲观与乐观的并发控制基于过时前提的决策检测旧MVCC读取检测影响之前读取的写入可串行化快照隔离的性能 本章小结参考文献 在数据系统的残酷现实中，很多事情都可能出错： 数据库软件、硬件可能在任意时刻发生故障（包括写操作进行到一半时）。应用程序可能在任意时刻崩溃（包括一系列操作的中间）。网络中断可能会意外切断数据库与应用的连接，或数据库之间的连接。多个客户端可能会同时写入数据库，覆盖彼此的更改。客户端可能读取到无意义的数据，因为数据只更新了一部分。客户端之间的竞争条件可能导致令人惊讶的错误。 为了实现可靠性，系统必须处理这些故障，确保它们不会导致整个系统的灾难性故障。但是实现容错机制工作量巨大。需要仔细考虑所有可能出错的事情，并进行大量的测试，以确保解决方案真正管用。
数十年来，事务（transaction） 一直是简化这些问题的首选机制。事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式。从概念上讲，事务中的所有读写操作被视作单个操作来执行：整个事务要么成功 提交（commit），要么失败 中止（abort）或 回滚（rollback）。如果失败，应用程序可以安全地重试。对于事务来说，应用程序的错误处理变得简单多了，因为它不用再担心部分失败的情况了，即某些操作成功，某些失败（无论出于何种原因）。
和事务打交道时间长了，你可能会觉得它显而易见。但我们不应将其视为理所当然。事务不是天然存在的；它们是为了 简化应用编程模型 而创建的。通过使用事务，应用程序可以自由地忽略某些潜在的错误情况和并发问题，因为数据库会替应用处理好这些。（我们称之为 安全保证，即 safety guarantees）。
并不是所有的应用都需要事务，有时候弱化事务保证、或完全放弃事务也是有好处的（例如，为了获得更高性能或更高可用性）。一些安全属性也可以在没有事务的情况下实现。
怎样知道你是否需要事务？为了回答这个问题，首先需要确切理解事务可以提供的安全保障，以及它们的代价。尽管乍看事务似乎很简单，但实际上有许多微妙但重要的细节在起作用。
本章将研究许多出错案例，并探索数据库用于防范这些问题的算法。尤其会深入 并发控制 的领域，讨论各种可能发生的竞争条件，以及数据库如何实现 读已提交（read committed），快照隔离（snapshot isolation） 和 可串行化（serializability） 等隔离级别。
本章同时适用于单机数据库与分布式数据库；在 第八章 中将重点讨论仅出现在分布式系统中的特殊挑战。
事务的棘手概念 现今，几乎所有的关系型数据库和一些非关系数据库都支持 事务。其中大多数遵循 IBM System R（第一个 SQL 数据库）在 1975 年引入的风格【1,2,3】。40 年里，尽管一些实现细节发生了变化，但总体思路大同小异：MySQL、PostgreSQL、Oracle 和 SQL Server 等数据库中的事务支持与 System R 异乎寻常地相似。
2000 年以后，非关系（NoSQL）数据库开始普及。它们的目标是在关系数据库的现状基础上，通过提供新的数据模型选择（请参阅 第二章）并默认包含复制（第五章）和分区（第六章）来进一步提升。事务是这次运动的主要牺牲品：这些新一代数据库中的许多数据库完全放弃了事务，或者重新定义了这个词，描述比以前所理解的更弱得多的一套保证【4】。
随着这种新型分布式数据库的炒作，人们普遍认为事务是可伸缩性的对立面，任何大型系统都必须放弃事务以保持良好的性能和高可用性【5,6】。另一方面，数据库厂商有时将事务保证作为 “重要应用” 和 “有价值数据” 的基本要求。这两种观点都是 纯粹的夸张。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c00a4464f093c985c078c7cd7740178b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e102300f2b41255cda863c0a61bb83/" rel="bookmark">
			当你在浏览器中输入了网址访问时产生了哪些技术步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你在浏览器中输入了网址访问时产生了哪些技术步骤 前段时间在知乎上了看一些网络方面的知识，刚好小编自己也是从事这一块的相关工作由对网络方面有一定的了解。今天我们来讲讲，当你在浏览器中输入本站域名并回车后，这背后到底发生来什么事情？
（因平台原因本文中www即为xxx ，com即为zzz，http/ccccc即为cccc/ccccc）
大致总结归纳了下，发生的事情如下图：
看到这里，大部分人都是蒙的。哪怕你有一点网络知识的基础，看起来也是蒙的。为了跟大家生动形象地说明原理，下面，我们用拟人的手法，讲述从输入一个网址，到最终显示出页面，这背后所发生的事情。
某天，小明心血来潮，想去艾西服务器论坛看一下有没有更新的博文，于是他打开了chrome浏览器，稍微回忆了一下网址，输入了：27server.zzz，并按下了回车。
一 ，浏览器格式化检查
chrome检查了一下，嗯？这好像是一个蛮标准的网址。但如果小明输入的是27server@zzz或者27server.zzz1这样的，chrome就会无情的拒绝小明的提议，并提示他网址出错。
所以在第一步，浏览器对网址进行了格式化检验，确定这是一个有效的网址，才会进入下一步。但是，在访问之前，浏览器必须知道，用了什么协议，是http呢，还是https呢？显然chrome对这种事情已经见怪不怪了，他有自己的一套方案，这里小明没有给定是什么协议的，于是chrome默认用了http协议，于是将网址修改成了：cccc://27server.zzz
二 DNS分级查询
在互联网上，有一家名叫TCP/IP的快递公司，专门负责运送用户的包裹。
于是chrome联系了TCP/IP快递公司，但却被告知：需要知道对方的IP地址，才能把包裹寄给对方！chrome并不是一个灰心的孩子，于是它找到了“黄页公司”-DNS。
求DNS帮忙查询下“27server.zzz”的IP地址是多少？DNS于是着手开始查找。首先看了下本地的hosts文件，没有找到对应！然后看了下本地内存，也没有！没办法，DNS只好联系了村口的一家名叫路由器的公司，192.168.1.1。路由器查看了下，最近村里没人访问过这个域名呀，要不你去市里的DNS公司问问？这是市里的DNS公司地址：114.114.114.114
于是DNS又联系了市里的DNS公司，却被告知最近市里最近也没人访问过这个域名。但是市里的DNS公司毕竟是专业的DNS公司，不会随便推卸责任，对DNS说，你等一等，我找我的上级查询下。于是市里的DNS公司联系了它的上级，根域名服务器。这个根域名服务器可了不得，全球只有13台，掌控着全球的DNS根域名查询。市里的DNS公司找到了离他最近的根域名服务器，说：“老哥，麻烦帮我查下.com顶级域名的服务器地址。”
没过一会儿，根域名服务器回复道：“你好，你要查询的地址是1.2.3.4。”
于是市里的DNS公司又联系到了1.2.3.4，询问 27server这个二级域名的域名服务器地址。
同样，1.2.3.4回复给了市里的DNS公司，地址是2.3.4.5。
市里的DNS公司又找2.3.4.5问了下，地址是：27server.zzz.w.kunluncan.zzz。等等，这怎么是一个别名（CNAME）？
于是市里的DNS公司又不厌其烦的重复了上面的几个步骤，一级一级地查找了 com &gt; kunluncan &gt; w &gt; com &gt; 27server的域名服务器地址，一直找到了驰网云的CDN域名服务器，DNS联系了对方，对方回复道：“查询到25个IP地址，分别是xxxxxxxx，帮你找到了离你最近的地址，3.4.5.6，已经打包，收件人地址：114.114.114.114 发件人地址：3.3.3.3，已委托TCP/IP快递公司的UDP小哥发送给你。”
三，网关 ARP原理
UDP是这一行的老司机，随手在包裹上写着：
收件人门牌号：53
发件人门牌号：56002
因为UDP知道，同一个地址会有很多的门牌号，为了避免混淆，必须要写。
UDP随手联系了TCP/IP公司的货车司机，让他捎带一下这个包裹。
司机来了，把包裹放进了驾驶室，坐上车准备开车。
司机打开了导航（路由表），发现要出关（网关），但是要知道关口的编号（mac地址）。但是导航信息里并没有关口的编号。于是司机找到了当地的向导ARP，问这个关口的编号是多少？ARP吼了一嗓子，关口回复说：“我的编号是xxxxx”。司机很快就到达了关口，关口放行，载着快递，上了Internet高速公路，一路狂奔不止。
四，建立DNS缓存
市里的DNS公司收到结果后，又通过村口的路由器公司联系到了DNS，并把结果告诉给了对方。同时村口的路由器公司和DNS都在自己的小本本上默默地记下了这个对应关系。
最后，DNS又把结果告诉给了已经等得不耐烦的chrome了。
五 ，TCP的三次握手
知道了27server.zzz的IP地址，chrome又立即联系了TCP/IP快递公司，快递公司派出了TCP小哥来接洽此时。和UDP小哥不同的是，TCP小哥是一个做事一丝不苟的人，知道chrome想要去拜访3.4.5.6，就要先和对方联系一下，确定在不在，这是通过TCP三次握手实现的。
TCP小哥：在吗？有人想要去拜访您。
对方：在啊，随时欢迎。
TCP小哥：马上到。
这三次消息，要通过TCP/IP公司的司机来来回回运输三次。DNS查询也是同样的道理，这里就不赘述了。
通过这三次握手，TCP小哥建立起了一条chrome到3.4.5.6的通道。
chrome将http请求消息（我是谁，要找谁等），打包给了TCP小哥，寄件人IP地址：2.2.2.2 门牌号：23755。收件人IP地址：3.4.5.6 门牌号：80
然后TCP小哥联系了司机，将包裹送到了3.4.5.6的80门牌号上。
六 Nginx的工作原理
3.4.5.6的80门牌号的门卫是nginx老大爷。老大爷一看，是送给家里的27server.zzz的。
路上老大爷看了下nginx.conf里找人的顺序：首先找index.php，如果找不到就找index.htm，再找不到就找index.html。
于是敲开了27server.zzz的门，里面只有index.html在家。index.html头也不回地告诉nginx老大爷，告诉chrome，我们已经搬家了，去找ccccc://xxx.27server.zzz（强制跳转）。
七 https加密原理
chrome收到了这个消息，立马又重复了上面的所有步骤，联系了“黄页公司”DNS，费了很大一番周折，找到了 xxx.27server.zzz的IP地址。
其实这两次访问，整体流程相似，不一样的地方如下：
查找到 xxx.27server.zzz的IP地址后，chrome这回没有直接把包裹给TCP小哥，而是联系了TLS安保大叔，让他全权负责包裹的安全问题，确保包裹在运输过程中的安全，即包裹的内容保密，包裹内容不能被篡改、替换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e102300f2b41255cda863c0a61bb83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75bccfae0957adf430635df1dc9d9414/" rel="bookmark">
			10*1000【2】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识:
-----------金融科技背后的技术----------------
-------------三个数字化趋势
1.数据爆炸：internet of everything（iot）；实时贡献数据；公有云服务-&gt;提供了灵活的计算和存储。
2.由计算能力驱动的，新型计算单元【神经处理单元Neural Processing Unit (NPU)】，
3.网络连接万物
-------基本
互联网的三个核心能力：连通性，风险管控，建立信任。
注：Iot：物联网。最后一行是数字发展的基石【简称BASIC】。
----------------------区块链【Blockchain】------------
区块链是一个数字化的公共账本，记录不断增长的在线交易清单的数字公共账本。它的价值在于新的互联网架构。作用：这将有助于解决信任方面的重大挑战。
关于比特币：比特币达到防止重复消费的目的。
这种链结构可以随时往里面新增结构，每一个块都有自己的密码【由加密技术保护】，并且 可以防止数据不被泄露。
每一个节点都可以自由加入到网络中来接收、广播、记录并验证交易。一个节点上的复制不会被其他节点识别。每一次的新进都会被录入账簿。每一个人都有自己的单独版本。
比特币的设计机制包括数字签名和共识算法。让其能够辨别出最合理的账本。
如何激励这些节点：贡献计算能力去维护账本。【挖掘机制】
区块链是一种基于整个网络的分布式存储。
----------------区块链实践-----
（一：医疗发票）比如用户需要问医院要相关发票，虽然看起来很常见的概念和过程，但是这中间涉及到的机构却很多（医院，财政局，保险公司，支付宝）， 每一个结点都有自己的 分工在云上，因此区块链可以记录并保护这些数据与流程。此外区块链便于随时调取自己所需要的数据，是程序的效率大大提高，花费降低。
（二：跨国商贸）
对跨境业务来说，区块链使信息变得真实，不可改，可追朔，让双方彼此建立了信任。
---------------人工智能
1.增强智能
2.基础设施智能化
---------------人工智能的实践
------------安全简介公司
数字安全
·数字身份实时风险管理
.数据安全和隐私
AlphaRisk的技术：人工智能，生物认证。
-------物联网简介
物联网：是指一切物理设备（包括但不限于电脑，家电，车辆等），它们使用传感器和应用程序编程接口 (API)，通过互联网与唯一标识符(UID)，来连接和交换数据。
物联网连接了虚拟世界和物质世界。5G为物联网带来了更多的可能性。相比于4G：
-------------物联网实践
他无法脱离技术但是可以和其他方面的如金融，市场，运营等。
---------------------计算机导论
计算机是一切数字技术的即使。它改变了我们的生活，其中一个就是支付
它需要两个能力：
1.
2.
3.除此之外：
所以，该如何解决上述问题：
这些能够使金融服务取得巨大的发展：高并发事务处理能力，一致性强，业务连续，容忍灾难，弹性的可扩展性。 ----------------金融科技展望
趋势1
·数字金融的深远影响才刚刚显现。
趋势2
将金融与创新技术相结合，可以实现各自优势的互补。
趋势3
“金融科技”一词将逐渐消失在数字世界中，所有金融服务都将而且应该数字化。
建议1：工业化，研究与开发，应用。
建议2：安全技术，监理技术，风险保障网络。
建议3：构建数字化、开放式的合作架构
---------------------区块链在金融服务中的应用----------------（people：jerry）
-----------Covid-19：挑战与新常态
挑战：医疗，传播速度，平衡公共卫生和经济建设，经济复苏
方法：中间是“trust”
---------蚂蚁链在整个疫情期间的策略
案例研究:利用区块链应对大流行挑战
爆发：医疗供应链；防止供应链诈骗有效匹配实际供给和需求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75bccfae0957adf430635df1dc9d9414/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7116ae1e8b3febad25fa5239b00c6960/" rel="bookmark">
			SpringBoot 配置文件外置方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 方案一：项目启动时设置环境变量方案二：基于SpringCloud的PropertySourceLocator接口加载配置文件 方案一：项目启动时设置环境变量 在Application文件中的configure方法添加如下代码（注：会影响同一jvm环境中的其他项目）：
YamlPropertiesFactoryBean yaml = new YamlPropertiesFactoryBean(); yaml.setResources(new FileSystemResource(“yml文件地址”)); System.getProperties().putAll(Objects.requireNonNull(yaml.getObject())); 方案二：基于SpringCloud的PropertySourceLocator接口加载配置文件 在pom文件中添加依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt; &lt;version&gt;2.2.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; 实现PropertySourceLocator接口，完整代码如下： import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.config.YamlMapFactoryBean; import org.springframework.cloud.bootstrap.config.PropertySourceLocator; import org.springframework.core.annotation.Order; import org.springframework.core.env.Environment; import org.springframework.core.env.MapPropertySource; import org.springframework.core.env.PropertySource; import org.springframework.core.io.FileSystemResource; import java.util.*; @Slf4j @Order(0) public class IvPropertySourceLocator implements PropertySourceLocator { @Override public PropertySource&lt;?&gt; locate(Environment environment) { return new MapPropertySource("iv", ymlParse("/opt/weblogic/config/application-dev.yml")); } /** * yml文件解析 */ private Map&lt;String, Object&gt; ymlParse(String location) { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7116ae1e8b3febad25fa5239b00c6960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87f3ce7e634b12d19b556ca5535f2237/" rel="bookmark">
			Linux-使用mobaxterm连接虚拟机ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作 VMware：16.0.0
Ubuntu：18.4
MobaxTerm：链接：https://pan.baidu.com/s/1dNsahe9wO5KrWlWXtNqT0A?pwd=az39 提取码：az39
二、实操 1.检查系统是否安装ssh service sshd status 如果显示未安装，则需要安装。
2.安装ssh sudo apt-get update sudo apt-get install openssh-server 如果报错如下：
表示安装依赖有问题，需要删除现有安装，重新安装。
sudo apt-get remove openssh-server openssh-client --purge -y sudo apt-get install openssh-server openssh-client 3.启动ssh sudo service ssh start 4.查看ip ifconfig 注：如果提示“ifconifg找不到该命令”，可以通过如下命令进行安装：
sudo apt install net-tools 5.在windows终端中ping通该ip。 表示是通的。如果ping不通，查看本地的虚拟网卡是否开启。如未开启，则右键启动。
然后在本地终端下输入ipconfig查看IP
看到VMnet8的网段与虚拟机网段是相同的。此时再次在windows下ping虚拟机的IP就可以ping通了。
6.连接远程虚拟机 输入远程虚拟机的IP，开始连接。
输入虚拟机ubuntu系统的账号密码
连接成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7eb9cb54a8d207adffde1234b81913/" rel="bookmark">
			pandas（一）：read_csv解决第一列Unnamed问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先直接给答案：configdata = pd.read_csv(savepath, encoding='utf-8', index_col=0)。
然后我们展开来说明：
首先下面这个图片是原始csv数据
1、第一列问题
上述图片可以看到，因为csv文件自带第一列序号，如果我们直接用pd.read_csv读取就会将第一列的序号也认为是一列，然后这列没有列名，所以就默认赋了一个Unnamed。所以就得到如下图片：
解决办法很简单，就是指定第一列为index（即设置参数index_col=0，其默认值是None），具体实现如下：
configdata = pd.read_csv(savepath, index_col=0)。
2、编码问题
这里可以注意到我把encoding参数去掉了，因为默认编码就是utf8的，如果我换成gbk会咋样？看看结果：
这样就报错了，会出现UnicodeDecodeError这个错误，告诉你gbk codec can’t decode。所以保存的文件编码格式也要注意。
3、列名问题
接着再讲讲，假如第一行不是列名（即原数据没有保存列名），直接是数值，该怎么处理。解决方法就是指定无表头就行（即设置header=None，其默认值是infer）：
configdata = pd.read_csv(savepath, header=None, index_col=0)
可以看到，默认给的列名是数字，如果想直接给定也行，指定参数names即可：
4、第一行问题
假如第一行列名我不想要（即不想读取），该怎么处理。pd提供了一个参数叫skiprows，你只要设置你不想读取的行号即可：
configdata = pd.read_csv(savepath, index_col=0, skiprows=[0])
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c1ceff08e034fcf2845cb9bbd1f9e4/" rel="bookmark">
			java过滤器（Filter）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：java过滤器（Filter – 编程屋
目录
1 过滤器简介
2 Filter详细介绍
3 Filter的用法
3.1 用法1
3.2 用法2
1 过滤器简介 filter也称之为过滤器，它是javaWeb三大组件之一（Servlet程序、Listener监听器、Filter过滤器）
作用：既可以对请求进行拦截，也可以对响应进行处理。
常见场景：权限检查，日记操作、拦截请求、过滤操作、对请求字符设置编码。
2 Filter详细介绍 要想介绍filter，就必须介绍Filter中的三个方法。
/** * web应用启动时，web服务器将创建Filter的实例对象，并调用init方法，读取web.xml的配置，完成对象的初始化功能， * 从而为后续的用户请求做好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次，开发人员通过init的参数， * 可或得代表当前filter配置信息的FilterConfig对象） * @param filterConfig * @throws ServletException */ @Override public void init(FilterConfig filterConfig) throws ServletException { } /** * 这个方法完成实际的过滤操作，当客户请求访问与过滤器相关联的URL的时候，Servlet过滤器将先执行doFilter方法，FilterChain参数用于访问后续过滤器 * @param servletRequest * @param servletResponse * @param filterChain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { } /** * filter创建后会保存在内存中，当web应用移除或者服务器停止时才销毁，该方法在Filter的生命周期中仅执行一次，在这个方法中，可以释放过滤器使用的资源 */ @Override public void destroy() { } 3 Filter的用法 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70c1ceff08e034fcf2845cb9bbd1f9e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/086d8ab57641dac1842ce5921857d181/" rel="bookmark">
			Redis 序列化器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 Redis是一个基于内存的key-value结构数据库，所以Redis的读写性能高。可以用作数据库、缓存和消息中间件。
在 Redis 中，序列化器（Serializer）是用于将数据在存储和读取时进行序列化和反序列化操作，即对数据进行编码和解码。
在 Java 中操作 Redis 可以使用 Redis 客户端库。以下是一些常用的操作方式
方式一：Redis的Java客户端有很多，官方推荐的有三种：
Jedis
Lettuce
Redisson
方式二：Spring Data Redis
Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，可以简化 Redis 操作。在 Spring Boot 项目中还提供了对应的 Starter，即 spring-boot-starter-data-redis
二、Spring Data Redis Spring Data Reids 中提供了一个高度封装的类：RedisTemplate，针对Jedis客户端中大量api进行了归类封装，将同一类型的操作封装为operation接口，具体分类如下：
ValueOperations：string类型操作
SetOperations：set类型数据操作
ZSetOperations：zset类型数据操作
HashOperations：map类型的数据操作
ListOperations：list类型的数据操作
三、设置序列化器原理 序列化：Java向Redis写入数据时，会对key以及value进行序列化
反序列化：Java从Redis读取数据时，会对key以及value进行反序列化
进入 RedisTemplate 类，可以看到它继承了 RedisAccessor 类。
进入 RedisAccessor 类，可以看到它实现了 InitializingBean 接口，它是一个 Spring 框架提供的接口，是用于在 Bean 实例化后进行初始化操作。
这个 InitializingBean 接口里面定义了一个方式 afterPropertiesSet() 方法，该方法就是在 Bean 的属性设置完成之后会自动调用该方法 ，可以在这个方法中可以进行一些额外的初始化操作，例如设置序列化器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/086d8ab57641dac1842ce5921857d181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2490efec00353242f33c6cc720aef95f/" rel="bookmark">
			机器人力控入门——牛顿欧拉法动力学建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 建立机器人的动力学模型是完成力控的基础，常用的动力学模型建模法有拉格朗日法和牛顿-欧拉法，其中牛顿-欧拉采用递推形式，计算更为简便，使用也更为广泛。本文就来介绍下牛顿-欧拉的动力学建模方法，
PS，网上关于动力学建模的参考资料很多，看了一圈还是感觉《机器人学导论 Craig》写的最清楚，建议刚学习的时候还是看这种经典的书籍。下面的公式和图也都是来自《机器人学导论》，后续看书学习的时候也不会陌生。
我的知乎原文：机器人力控入门——牛顿欧拉法动力学建模 - 知乎
外推
理解牛顿-欧拉法建模有两个要点，其中一个是搞清楚连杆之间的速度/加速度传递关系（建立起 和以及 和的关系），这是后面求解连杆间力/力矩的基础。
首先明确一下定义：和
这两个变量分别是连杆的线速度和角速度在坐标系上表示，如图 1所示，
只有在同一个坐标系中，速度才能加减，也就是说，对于角速度和线速度：
看一下公式（1），坐标系 i+1原点处的角速度除了自身的角速度，还包含上一个坐标系 原点处角速度的叠加。这里 表示关节角速度是沿着z轴方向的
公式（2）：坐标系 i+1原点处的线速度除了上一个坐标系 原点处的线速度，还包括由于坐标系 旋转带来的线速度。
这两个公式理解没有问题的话，下面的肯定也都能看懂。
对公式(1)和(2)求导，可得：
这个公式中可能会对这个部分有疑问：
可以参考：旋转矩阵的导数（机器人学）_旋转矩阵求导_cuntou0906的博客-CSDN博客 或者以旋转矩阵的导数为关键词自行搜索。
同理，对原点处的线速度做平移，得到连杆 i质心处 的线速度，因为质心坐标系和连杆坐标系姿态相同，因此： 对(3)和(4)做坐标变换（乘以一个旋转矩阵），可以得到如下加速度传递关系:
内推
理解牛顿-欧拉法建模的另一个要点是要搞清楚连杆之间力/力矩的传递关系
同样的，先明确下力和力矩的定义，
如图 2所示， 表示由连杆 i-1作用在连杆 i上的力， 表示由连杆 i-1作用在连杆 i上的力矩。
连杆运动所需的力是关于加速度及其质量的函数，计算出每个连杆质心处的线加速度和角加速度之后，运用牛顿-欧拉公式，计算出作用在连杆质心 上的惯性力 和力矩 ，由牛顿方程可得：
由欧拉方程可得： 是连杆 的转动惯量，分析作用在连杆 上的力平衡关系： 从内推和外推的公式中可以看出动力学模型中有一些变量时恒定不变的，如 ，这些参数被称为机器人的动力学参数，而后续在机器人平台上实现力控的下一个关键步骤就是要把这些变量辨识出来，这样就可以准确算出伺服系统要提供多大的转矩，从而实现机械臂（连杆）的运动控制。
如果把所有公式都带入到（13）式中展开，把它表示成 的函数，那么就有了拉格朗日形式的动力学方程：
细心的朋友可能会发现这里面没有包含摩擦力矩，在上面牛顿-欧拉递推的过程中，确实是忽略了摩擦的，这可能是因为摩擦力本身模型不确定，单独加到关节上会更加简洁些。在辨识的时候会把摩擦力加上，或者单独辨识摩擦力。拉格朗日形式的动力学方程也会加上摩擦力矩，变成这样的形式
最后再贴一个学习资料sympybotics GitHub - cdsousa/SymPyBotics: [UNMAINTAINED] Symbolic Framework for Modeling and Identification of Robot Dynamics，这是一个用python的开源机器人运动学和动力学的符号推导工具包，可以去里面读读代码，看看人家是怎么实现的，这对理解机器人动力学会有很大帮助。（PS,这个工具包也是后面做辨识必不可少的，可以先阅读了解下） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10a93224c7e51ae7cdf0dee6733346f4/" rel="bookmark">
			Redis中的序列化器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
目录
一、什么是序列化器？
二、Redis使用步骤
1.在Maven中引入依赖
2.配置redis的相关信息
三.更改redis key的序列化器
一、什么是序列化器？ 在Java中，序列化器主要用于将对象转换为字节流，以便将其存储到文件、数据库或通过网络传输到其他计算机，然后再将字节流反序列化为原始对象。
二、Redis使用步骤 1.在Maven中引入依赖 &lt;!--Spring Data Redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2.配置redis的相关信息 在yml配种文件中 配置redis的相关信息
spring: redis: host: ${sky.redis.host} port: ${sky.redis.port} password: ${sky.redis.password} database: ${sky.redis.database} 3.进行测试
package com.sky.test; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.*; import java.util.concurrent.TimeUnit; /** * @author: Administrator * @description: TODO * @date: 2023/8/22 10:48 */ @SpringBootTest public class SpringDataRedisTest { @Autowired private RedisTemplate redisTemplate; @Test public void testRedisTemplate(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10a93224c7e51ae7cdf0dee6733346f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1956691d41b8c9358a8d2f63a411607/" rel="bookmark">
			Java如何操作Excel并保存于原文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家对excel的操作可能更多的使用EasyExcel框架，但是我们需要了解一点。esayexcel库并不支持直接对原文件进行内容修改，它主要用于读取和写入Excel文件。如果要修改原文件的内容，我们需要使用到Java的POI库。
1，添加POI依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2， 使用框架做具体处理
public void testFile(File file, String page) { FileOutputStream fileOutputStream = null; try { // 读取Excel文件 Integer rowNum = 0; Integer cellNum = 0; try ( // 读取xlsx类型文件 Workbook workbook = new XSSFWorkbook(Files.newInputStream(file.toPath()))) { // 选择处理的sheet Sheet sheet = workbook.getSheet(page); // 下面是我这边对某个数据列的处理 for (int i = 0; i &lt; 100; i++) { for (int j = 0; j &lt; 100; j++) { Row row = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1956691d41b8c9358a8d2f63a411607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83d8bcde73b1a945351db580b664ad8e/" rel="bookmark">
			Linux三大根文件系统移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、buildroot1、buildroot 下载2、buildroot 构建根文件系统配置 buildroot编译 buildroot偶遇BUG 3、根文件系统测试第三方软件和库的配置 4、buildroot 下的 busybox 配置busybox 配置busybox 中文字符的支持编译 busybox遇到问题 二、Yocto1、在线构建根文件系统安装与配置git获取 yocto 项目 2、离线构建根文件系统构建根文件系统构建 SDK 工具 三、Ubuntu-base1、ubuntu-base 获取2、ubuntu 根文件系统构建解压缩 ubuntu base 根文件系统安装 qemu设置软件源在主机挂载并配置根文件系统 3、ubuntu 根文件系统测试nfs 挂载测试buntu 根文件系统烧写 4、ubuntu 根文件系统继续添加部分添加新用户网络 DHCP 配置安装软件FTP 服务器搭建 总结 前言 文章主要来自正点原子的教学文档，本文将驱动开发篇中的根文件系统和yocto构建篇合并起来，部分内容加入自己的理解和补充自己遇到的问题以及解决方法。
首先，busybox 构建的根文件系统不齐全，很多东西需要我们自行添加，比如 lib 库文件。
如果自己纯手工去移植过一个第三方软件，就会发现这个软件会依赖很多库，而移植其中某一个库又需要依赖其他库，一连串的连锁反应会导致移植过程十分艰难！！！
所以 buildroot 就为此而生，只需要在 makefile 中添加这么一句：
DEPENDS:=+aaa +bbb +ccc buildroot 就会帮你自动编译 aaa库、bbb库、ccc库，不够可以再加。
即使本地没有这些包，也会自动从它们的开源网站上下载。
再次批评一下 busybox，busybox 仅仅只是帮我们构建好了一些常用的命令和文件，像 lib 库、/etc 目录下的一些文件都需要我们自己手动创建，而且 busybox 构建的根文件系统默认没有用户名和密码设置。
而 buildroot 不仅集成了 busybox，而且还集成了各种常见的第三方库和软件！！！
前置知识：文章所有提到的 nfs 目录，实际上是使用 nfs 文件系统，将开发板根目录挂载到虚拟机的 nfs 目录中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83d8bcde73b1a945351db580b664ad8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61fed2f6e7b1caae6bf8a46bf4807845/" rel="bookmark">
			利用免费WAF雷池社区版解决「爬虫占用网络带宽问题」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 关联词：限频、访问控制、爬虫、反爬虫、WAF、长亭、雷池
对于一些自动的 bot 或者恶意的爬虫，其访问网站的频率大、时间长，如果打开云服务器的管理后台，往往会发现网络的大部分流量都集中在一个或几个的 IP 上。对于这些情况其实都可以以一个很简单的手段实现，那就是在服务器中对访问IP限频。
但是对于访问IP的限频功能通常与业务逻辑关系不大，开发者通常不太想要去自己维护一个IP访问频次表，同时在分布式、并发等条件下手动维护所有访问者的信息有着很大的开发成本。
长亭的雷池 WAF 正好解决了这一系列问题， 雷池提供了限频、端口转发、手动IP黑白名单等功能，以及其核心功能——防御 Web 攻击。
2. 安装雷池 官网提供了在线安装、离线安装、牧云助手安装三种方式，本文不再赘述，详情可以查看：
https://waf-ce.chaitin.cn/docs/guide/install
3. 登录雷池 雷池采用了 OTP 手段进行登录鉴权， 简单来说就是通过腾讯身份验证器等软件，向登录页面输入手机软件上生成的动态密码（约15s 会更新一次密码）即可。
3.1 软件扫码绑定 扫码后即绑定，可以在首页看到动态密码
3. 2 输入口令密码 3.3 进入雷池管理界面 4. 配置站点和限频功能 4.1 雷池站点配置 雷池的站点配置功能比较齐全，包括自动上传 TLS 证书、私钥，指定多个转发端口等，不需要开发者自己配置 nginx 转发
4.2 配置限频功能 具体的封禁策略可以进行自定义，推荐为 10 s，100 次 ，封禁 10分钟
PS：如果是自己测试，或者发现误报的，可以手动解除封禁
5. 测试及其他 5.1 测试 后台准备了一个简单的服务器，提供一个hello的接口，带有一个a的参数
简单编写测试的爬虫代码：
def send_request(url,request_method="GET",header=None,data=None): try: if header is None: header=Config.get_global_config().header response = requests.request(request_method, url, headers=header) return response except Exception as err: print(err) pass return None if __name__ == '__main__': # config=Config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61fed2f6e7b1caae6bf8a46bf4807845/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7487ae4c3c891e612037f9b973f4512/" rel="bookmark">
			设计模式系列之代理模式(Proxy)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： 代理模式，顾名思义就是一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。
代理，在显示生活中有很多代理的例子，比如我们可以在售票点买到火车站的火车票，售卖点就是铁路公司的代理，Windows电脑桌面的快捷方式就是应用软件启动程序的代理。
从上面的例子可以明白代理的意图就是代替原有的对象执行该对象的功能。
那么为什么需要代理呢？不能直接访问该对象的功能吗？
因为有时候我们直接访问该对象会比较麻烦，比如 我们买火车票总不能每次跑到几十公里外的火车站去买吧，家门口的售票点就能买到火车站的火车票，简单方便；我们打开软件，总不能打开文件资源管理器，根据安装目录一层层地找到应用启动程序文件（还得记住启动程序文件地路径），多麻烦呀，在桌面放一个代理这个启动程序文件，一键启动快捷方便。
特点： 优点：
职责清晰高扩展性智能化 缺点：
在客户端和被代理对象之间增加了一个代理对象 ，因此有些类型的代理模式可能会造成请求处理的速度变慢实现代理模式需要额外的工作，有些代理模式实现非常复杂 对比适配器模式和装饰器模式：
适配器模式主要改变所考虑对象的接口，代理模式则不能改变所代理的对象的接口装饰器模式主要为了增强功能，代理模式是为了加以控制 使用场景： 远程代理虚拟代理Copy-on-Write 代理保护（Protect or Access）代理Cache代理防火墙（Firewall）代理同步化（Synchronization）代理智能引用（Smart Reference）代理 实现方法： 现在我们有这样一个需求，我们需要加载一个图片返回给客户端进行展示，但是我们程序所在的这个服务器呢特别差，需要减少对象加载对内存的占用。
首先我们有一个图片展示的接口
public interface Image { void display(); } 然后有一个实际加载图片并实现该接口的RealImage类来实现实际的加载和展示
public class RealImage implements Image{ private String filename; public RealImage (String filename){ this.filename = filename; loadFromDisk(filename); } @Override public void display() { System.out.println("image display "+ filename); } private void loadFromDisk(String filename){ // 这个方法特别占用内存 System.out.println("image loading from disk "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7487ae4c3c891e612037f9b973f4512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cef9cdbae03ae2827ad58eab5fb6b0f/" rel="bookmark">
			设计模式系列之装饰器模式(Decorator)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： 装饰器模式（Decorator Pattern)允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。
装饰器模式，顾名思义，给别的类进行装饰，使别的类变得更漂亮（功能更强），同时有保留原有类，不改变原有的类。
特点： 优点：
装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式
装饰模式可以动态扩展一个实现类的功能。
缺点：
多层装饰比较复杂。
使用场景： 1、扩展一个类的功能。
2、动态增加功能，动态撤销。
实现方法： 例如装修房子，我们买来的房子如果是毛坯房（被包装的类），我们在收房之后会对其进行装修（Decorator）,得到一个装修的很漂亮（被增强的功能）的房子（装饰之后的类）
首先房子开发商定义了一个房子的基本功能living()
public interface House { // 居住 void living(); } 然后房子开发商批量创建了一批毛坯房（被包装的类）Room,只有基本的功能living()
public class Room implements House { @Override public void living() { System.out.println("Room living"); } } 再然后我们买了毛坯房（被包装的类）Room，然后对毛坯房进行装饰，得到一个精装修的房子BeautyRoom，除了实现了本来定义的基本功能living()外，还变得更好看了（被增强功能）
public class BeautyRoom implements House { private House room; BeautyRoom(House room){ this.room = room; } @Override public void living() { // 基本功能 room.living(); // 增强功能 System.out.println("this room becomes more beauty"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cef9cdbae03ae2827ad58eab5fb6b0f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/99/">«</a>
	<span class="pagination__item pagination__item--current">100/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/101/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>